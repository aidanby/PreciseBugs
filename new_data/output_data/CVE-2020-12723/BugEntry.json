{"buggy_code": [": BEGIN{die \"You meant to run regen/embed.pl\"} # Stop early if fed to perl.\n:\n: This file is processed by regen/embed.pl and autodoc.pl\n: It is used to declare the interfaces to the functions defined by perl.  All\n: non-static functions must have entries here.  Static functions need not, but\n: there is benefit to declaring them here, as it generally handles the thread\n: context parameter invisibly, as well as making sure a PERL_ARGS_ASSERT_foo\n: macro is defined, which can save you debugging time.\n:\n: Lines are of the form:\n:    flags|return_type|function_name|arg1|arg2|...|argN\n:\n: A line may be continued on another by ending it with a backslash.\n: Leading and trailing whitespace will be ignored in each component.\n:\n: The default without flags is to declare a function for internal perl-core use\n: only, not visible to XS code nor to Perl extensions.  Use the A and E flags to\n: modify this.  Most non-static functions should have the 'p' flag to avoid\n: namespace clashes with programs that embed perl.\n:\n: flags are single letters with following meanings:\n:\n:   A  Available fully everywhere (usually part of the public API):\n:\n:         add entry to the list of exported symbols (unless x or m);\n:         any doc entry goes in perlapi.pod rather than perlintern.pod.  If no\n:\t     documentation is furnished for this function, and M is also\n:\t     specified, the function is not listed as part of the public API.\n:\t     If M isn't specified, and no documentation is furnished, the\n:\t     function is listed in perlapi as existing and being undocumented\n:         makes '#define foo Perl_foo' scope not just for PERL_CORE/PERL_EXT\n:\n:      If the function is only exported for use in a public\n:      macro, see X.\n:\n:   a  Allocates memory a la malloc/calloc.  Also implies \"R\".\n:      This should only be on functions which returns 'empty' memory\n:      which has no other pointers to it, and which does not contain\n:      any pointers to other things. So for example realloc() can't be\n:      'a'.\n:\n:         proto.h: add __attribute__malloc__\n:\n:   b  Binary backward compatibility.  This is used for functions which are\n:      kept only to not have to change legacy applications that call them.  If\n:      there are no such legacy applications in a Perl installation for all\n:      functions flagged with this, the installation can run Configure with the\n:      -Accflags='-DNO_MATHOMS' parameter to not even compile them.  If there\n:      is a macro form of this function that provides equivalent functionality\n:      (using a different implementation), also specify the 'm' flag.  The 'b'\n:      functions are normally moved to mathoms.c, but if circumstances dictate\n:      otherwise, they can be anywhere, provided the whole function is wrapped\n:      with\n:       #ifndef NO_MATHOMS\n:       ...\n:       #endif\n:\n:      Note that this flag no longer automatically adds a 'Perl_' prefix to the\n:      name.  Additionally specify 'p' to do that.\n:\n:      For functions, like wrappers, whose macro shortcut doesn't call the\n:      function, but which, for whatever reason, aren't considered legacy-only,\n:      use the 'o' flag\n:\n:      This flag effectively causes nothing to happen if the perl interpreter\n:      is compiled with -DNO_MATHOMS; otherwise these happen:\n:         add entry to the list of exported symbols;\n:         create PERL_ARGS_ASSERT_foo;\n:\t  add embed.h entry (unless overridden by the 'm' flag)\n:\n:   D  Function is deprecated:\n:\n:         proto.h: add __attribute__deprecated__\n:\n:   d  Function has documentation (somewhere) in the source:\n:\n:         enables 'no docs for foo\" warning in autodoc.pl\n:\n:   E  Visible to extensions included in the Perl core:\n:\n:         in embed.h, change \"#ifdef PERL_CORE\"\n:         into               \"#if defined(PERL_CORE) || defined(PERL_EXT)\"\n:\n:      To be usable from dynamically loaded extensions, either:\n:\t  1) must be static to its containing file (\"i\" or \"s\" flag); or\n:         2) be combined with the \"X\" flag.\n:\n:   f  Function takes a format string. If the function name =~ qr/strftime/\n:      then its assumed to take a strftime-style format string as 1st arg;\n:      otherwise it's assumed to be a printf style format string, varargs\n:      (hence any entry that would otherwise go in embed.h is suppressed):\n:\n:         proto.h: add __attribute__format__ (or ...null_ok__)\n:\n:   i  Static inline: function in source code has a S_ prefix:\n:\n:         proto.h: function is declared as S_foo rather than foo unless the 'p'\n:\t\t   flag is also given in which case 'Perl_foo' is used,\n:                PERL_STATIC_INLINE is added to declaration;\n:         embed.h: \"#define foo S_foo\" or Perl_foo entries added\n:\n:   M  May change:\n:\n:         any doc entry is marked that function may change.  Also used to\n:\t  suppress making a doc entry if it would just be a placeholder.\n:\n:   m  Implemented as a macro:\n:\n:         suppress proto.h entry unless 'b' also specified (actually, not\n:\t\tsuppressed, but commented out)\n:         suppress entry in the list of exported symbols\n:         suppress embed.h entry\n:\n:   n  Has no implicit interpreter/thread context argument:\n:\n:         suppress the pTHX part of \"foo(pTHX...)\" in proto.h;\n:         In the PERL_IMPLICIT_SYS branch of embed.h, generates\n:             \"#define foo Perl_foo\",      rather than\n:             \"#define foo(a,b,c) Perl_foo(aTHX_ a,b,c)\n:\n:   O  Has a perl_ compatibility macro.\n:\n:      The really OLD name for API funcs\n:\n:   o  Has no Perl_foo or S_foo compatibility macro:\n:\n:\tThis can be used when you define a macro with this entry's name that\n:\tdoesn't call the function specified by this entry.  This is typically\n:\tdone for a function that effectively just wraps another one, and where\n:\tthe macro form calls the underlying function directly.  For these, also\n:\tspecify the 'm' flag.  Legacy-only functions should instead use 'b'.\n:\n:         embed.h: suppress \"#define foo Perl_foo\"\n:\n:   P  Pure function:\n:\n:\tA pure function has no effects except the return value, and the return\n:       value depends only on params and/or globals.  This is a hint to the\n:\tcompiler that it can optimize calls to this function out of common\n:\tsubexpressions.  Consequently if this flag is wrongly specified, it can\n:\tlead to subtle bugs that vary by platform, compiler, compiler version,\n:\tand optimization level.  Also, a future commit could easily change a\n:\tcurrently-pure function without even noticing this flag.  So it should\n:\tbe used sparingly, only for functions that are unlikely to ever become\n:\tnot pure by future commits.  It should not be used for static\n:\tfunctions, as the compiler already has the information needed to make\n:\tthe 'pure' determination and doesn't need any hint; so it doesn't add\n:\tvalue in those cases, and could be dangerous if it causes the compiler\n:\tto skip doing its own checks.  It should not be used on functions that\n:\ttouch SVs, as those can trigger unexpected magic.  Also implies \"R\":\n:\n:         proto.h: add __attribute__pure__\n:\n:   p  Function in source code has a Perl_ prefix:\n:\n:         proto.h: function is declared as Perl_foo rather than foo\n:         embed.h: \"#define foo Perl_foo\" entries added\n:\n:   R  Return value must not be ignored (also implied by 'a' and 'P' flags):\n:\n:        proto.h: add __attribute__warn_unused_result__\n:\n:   r  Function never returns:\n:\n:        proto.h: add __attribute__noreturn__\n:\n:   s  Static function: function in source code has a S_ prefix:\n:\n:         proto.h: function is declared as S_foo rather than foo,\n:                STATIC is added to declaration;\n:         embed.h: \"#define foo S_foo\" entries added\n:\n:   U  Suppress usage example in autogenerated documentation\n:\n:         (currently no effect)\n:\n:   W  Add a _pDEPTH argument to function prototypes, and an _aDEPTH\n:      argument to the function calls. This means that under DEBUGGING\n:      a depth argument is added to the functions, which is used for\n:      example by the regex engine for debugging and trace output.\n:      A non DEBUGGING build will not pass the unused argument.\n:      Currently restricted to functions with at least one argument.\n:\n:   X  Explicitly exported:\n:\n:         add entry to the list of exported symbols, unless x or m\n:\n:      This is often used for private functions that are used by public\n:      macros.  In those cases the macros must use the long form of the\n:      name (Perl_blah(aTHX_ ...)).\n:\n:   x  Not exported\n:\n:         suppress entry in the list of exported symbols\n:\n: (see also L<perlguts/Internal Functions> for those flags.)\n:\n: Pointer parameters that must not be passed NULLs should be prefixed with NN.\n:\n: Pointer parameters that may be NULL should be prefixed with NULLOK.  This has\n: no effect on output yet.  It's a notation for the maintainers to know \"I have\n: defined whether NULL is OK or not\" rather than having neither NULL or NULLOK,\n: which is ambiguous.\n:\n: Individual flags may be separated by whitespace.\n\n#if defined(PERL_IMPLICIT_SYS)\nAno\t|PerlInterpreter*|perl_alloc_using \\\n\t\t\t\t|NN struct IPerlMem *ipM \\\n\t\t\t\t|NN struct IPerlMem *ipMS \\\n\t\t\t\t|NN struct IPerlMem *ipMP \\\n\t\t\t\t|NN struct IPerlEnv *ipE \\\n\t\t\t\t|NN struct IPerlStdIO *ipStd \\\n\t\t\t\t|NN struct IPerlLIO *ipLIO \\\n\t\t\t\t|NN struct IPerlDir *ipD \\\n\t\t\t\t|NN struct IPerlSock *ipS \\\n\t\t\t\t|NN struct IPerlProc *ipP\n#endif\nAnod\t|PerlInterpreter*\t|perl_alloc\nAnod\t|void\t|perl_construct\t|NN PerlInterpreter *my_perl\nAnod\t|int\t|perl_destruct\t|NN PerlInterpreter *my_perl\nAnod\t|void\t|perl_free\t|NN PerlInterpreter *my_perl\nAnod\t|int\t|perl_run\t|NN PerlInterpreter *my_perl\nAnod\t|int\t|perl_parse\t|NN PerlInterpreter *my_perl|XSINIT_t xsinit \\\n\t\t\t\t|int argc|NULLOK char** argv|NULLOK char** env\nAnpR\t|bool\t|doing_taint\t|int argc|NULLOK char** argv|NULLOK char** env\n#if defined(USE_ITHREADS)\nAnod\t|PerlInterpreter*|perl_clone|NN PerlInterpreter *proto_perl|UV flags\n#  if defined(PERL_IMPLICIT_SYS)\nAno\t|PerlInterpreter*|perl_clone_using \\\n\t\t\t\t|NN PerlInterpreter *proto_perl \\\n\t\t\t\t|UV flags \\\n\t\t\t\t|NN struct IPerlMem* ipM \\\n\t\t\t\t|NN struct IPerlMem* ipMS \\\n\t\t\t\t|NN struct IPerlMem* ipMP \\\n\t\t\t\t|NN struct IPerlEnv* ipE \\\n\t\t\t\t|NN struct IPerlStdIO* ipStd \\\n\t\t\t\t|NN struct IPerlLIO* ipLIO \\\n\t\t\t\t|NN struct IPerlDir* ipD \\\n\t\t\t\t|NN struct IPerlSock* ipS \\\n\t\t\t\t|NN struct IPerlProc* ipP\n#  endif\n#endif\n\nAanop\t|Malloc_t|malloc\t|MEM_SIZE nbytes\nAanop\t|Malloc_t|calloc\t|MEM_SIZE elements|MEM_SIZE size\nARnop\t|Malloc_t|realloc\t|Malloc_t where|MEM_SIZE nbytes\nAnop\t|Free_t\t|mfree\t\t|Malloc_t where\n#if defined(MYMALLOC)\nnpR\t|MEM_SIZE|malloced_size\t|NN void *p\nnpR\t|MEM_SIZE|malloc_good_size\t|size_t nbytes\n#endif\n#if defined(PERL_IN_MALLOC_C)\nsn\t|int\t|adjust_size_and_find_bucket\t|NN size_t *nbytes_p\n#endif\n\nAnpR\t|void*\t|get_context\nAnp\t|void\t|set_context\t|NN void *t\n\nXEop\t|bool\t|try_amagic_bin\t|int method|int flags\nXEop\t|bool\t|try_amagic_un\t|int method|int flags\nAp\t|SV*\t|amagic_call\t|NN SV* left|NN SV* right|int method|int dir\nAp\t|SV *\t|amagic_deref_call|NN SV *ref|int method\np\t|bool\t|amagic_is_enabled|int method\nAp\t|int\t|Gv_AMupdate\t|NN HV* stash|bool destructing\nApR\t|CV*\t|gv_handler\t|NULLOK HV* stash|I32 id\nApd\t|OP*\t|op_append_elem\t|I32 optype|NULLOK OP* first|NULLOK OP* last\nApd\t|OP*\t|op_append_list\t|I32 optype|NULLOK OP* first|NULLOK OP* last\nApd\t|OP*\t|op_linklist\t|NN OP *o\nApd\t|OP*\t|op_prepend_elem|I32 optype|NULLOK OP* first|NULLOK OP* last\n: FIXME - this is only called by pp_chown. They should be merged.\np\t|I32\t|apply\t\t|I32 type|NN SV** mark|NN SV** sp\nApM\t|void\t|apply_attrs_string|NN const char *stashpv|NN CV *cv|NN const char *attrstr|STRLEN len\nApd\t|void\t|av_clear\t|NN AV *av\nApd\t|SV*\t|av_delete\t|NN AV *av|SSize_t key|I32 flags\nApdR\t|bool\t|av_exists\t|NN AV *av|SSize_t key\nApd\t|void\t|av_extend\t|NN AV *av|SSize_t key\np\t|void\t|av_extend_guts\t|NULLOK AV *av|SSize_t key \\\n\t\t\t\t|NN SSize_t *maxp \\\n\t\t\t\t|NN SV ***allocp|NN SV ***arrayp\nApdR\t|SV**\t|av_fetch\t|NN AV *av|SSize_t key|I32 lval\nApd\t|void\t|av_fill\t|NN AV *av|SSize_t fill\nApdR\t|SSize_t|av_len\t\t|NN AV *av\nApdR\t|AV*\t|av_make\t|SSize_t size|NN SV **strp\np\t|SV*\t|av_nonelem\t|NN AV *av|SSize_t ix\nApd\t|SV*\t|av_pop\t\t|NN AV *av\nApdoxM\t|void\t|av_create_and_push|NN AV **const avp|NN SV *const val\nApd\t|void\t|av_push\t|NN AV *av|NN SV *val\n: Used in scope.c, and by Data::Alias\nEXp\t|void\t|av_reify\t|NN AV *av\nApdR\t|SV*\t|av_shift\t|NN AV *av\nApd\t|SV**\t|av_store\t|NN AV *av|SSize_t key|NULLOK SV *val\nAidR\t|SSize_t|av_top_index\t|NN AV *av\nAmpdR\t|SSize_t|av_tindex\t|NN AV *av\nApd\t|void\t|av_undef\t|NN AV *av\nApdoxM\t|SV**\t|av_create_and_unshift_one|NN AV **const avp|NN SV *const val\nApd\t|void\t|av_unshift\t|NN AV *av|SSize_t num\nApo\t|SV**\t|av_arylen_p\t|NN AV *av\nApo\t|IV*\t|av_iter_p\t|NN AV *av\n#if defined(PERL_IN_AV_C)\ns\t|MAGIC*\t|get_aux_mg\t|NN AV *av\n#endif\n: Used in perly.y\npR\t|OP*\t|bind_match\t|I32 type|NN OP *left|NN OP *right\n: Used in perly.y\nApdR\t|OP*\t|block_end\t|I32 floor|NULLOK OP* seq\nApR\t|U8\t|block_gimme\n: Used in perly.y\nApdR\t|int\t|block_start\t|int full\nAodp\t|void\t|blockhook_register |NN BHK *hk\n: Used in perl.c\np\t|void\t|boot_core_UNIVERSAL\n: Used in perl.c\np\t|void\t|boot_core_PerlIO\nAp\t|void\t|call_list\t|I32 oldscope|NN AV *paramList\nApd\t|const PERL_CONTEXT *\t|caller_cx|I32 level \\\n\t\t\t\t|NULLOK const PERL_CONTEXT **dbcxp\n: Used in several source files\npR\t|bool\t|cando\t\t|Mode_t mode|bool effective|NN const Stat_t* statbufp\nApRn\t|U32\t|cast_ulong\t|NV f\nApRn\t|I32\t|cast_i32\t|NV f\nApRn\t|IV\t|cast_iv\t|NV f\nApRn\t|UV\t|cast_uv\t|NV f\n#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)\nApR\t|I32\t|my_chsize\t|int fd|Off_t length\n#endif\np\t|const COP*|closest_cop\t|NN const COP *cop|NULLOK const OP *o \\\n\t\t\t\t|NULLOK const OP *curop|bool opnext\n: Used in perly.y\nApdR\t|OP*\t|op_convert_list\t|I32 optype|I32 flags|NULLOK OP* o\n: Used in op.c and perl.c\npM\t|void\t|create_eval_scope|NULLOK OP *retop|U32 flags\nAprd\t|void\t|croak_sv\t|NN SV *baseex\n: croak()'s first parm can be NULL.  Otherwise, mod_perl breaks.\nAfprd\t|void\t|croak\t\t|NULLOK const char* pat|...\nAprd\t|void\t|vcroak\t\t|NULLOK const char* pat|NULLOK va_list* args\nAnprd\t|void\t|croak_no_modify\nAnprd\t|void\t|croak_xs_usage\t|NN const CV *const cv \\\n\t\t\t\t|NN const char *const params\nnpr\t|void\t|croak_no_mem\nnprX\t|void\t|croak_popstack\nfnrp\t|void\t|croak_caller|NULLOK const char* pat|...\nfnprx\t|void\t|noperl_die|NN const char* pat|...\n#if defined(WIN32)\nnorx\t|void\t|win32_croak_not_implemented|NN const char * fname\n#endif\n#if defined(PERL_IMPLICIT_CONTEXT)\nAfnrp\t|void\t|croak_nocontext|NULLOK const char* pat|...\nAfnrp\t|OP*    |die_nocontext  |NULLOK const char* pat|...\nAfnp\t|void\t|deb_nocontext\t|NN const char* pat|...\nAfnp\t|char*\t|form_nocontext\t|NN const char* pat|...\nAnp\t|void\t|load_module_nocontext|U32 flags|NN SV* name|NULLOK SV* ver|...\nAfnp\t|SV*\t|mess_nocontext\t|NN const char* pat|...\nAfnp\t|void\t|warn_nocontext\t|NN const char* pat|...\nAfnp\t|void\t|warner_nocontext|U32 err|NN const char* pat|...\nAfnp\t|SV*\t|newSVpvf_nocontext|NN const char *const pat|...\nAfnp\t|void\t|sv_catpvf_nocontext|NN SV *const sv|NN const char *const pat|...\nAfnp\t|void\t|sv_setpvf_nocontext|NN SV *const sv|NN const char *const pat|...\nAfnp\t|void\t|sv_catpvf_mg_nocontext|NN SV *const sv|NN const char *const pat|...\nAfnp\t|void\t|sv_setpvf_mg_nocontext|NN SV *const sv|NN const char *const pat|...\nAbfnp\t|int\t|fprintf_nocontext|NN PerlIO *stream|NN const char *format|...\nAbfnp\t|int\t|printf_nocontext|NN const char *format|...\n#endif\n: Used in pp.c\np\t|SV *\t|core_prototype\t|NULLOK SV *sv|NN const char *name \\\n\t\t\t\t|const int code|NULLOK int * const opnum\n: Used in gv.c\np\t|OP *\t|coresub_op\t|NN SV *const coreargssv|const int code \\\n\t\t\t\t|const int opnum\n: Used in sv.c\nEMXp\t|void\t|cv_ckproto_len_flags\t|NN const CV* cv|NULLOK const GV* gv\\\n\t\t\t\t|NULLOK const char* p|const STRLEN len \\\n                                |const U32 flags\n: Used in pp.c and pp_sys.c\nApdR\t|SV*\t|gv_const_sv\t|NN GV* gv\nApdRn\t|SV*\t|cv_const_sv\t|NULLOK const CV *const cv\npRn\t|SV*\t|cv_const_sv_or_av|NULLOK const CV *const cv\nApd\t|SV *\t|cv_name\t|NN CV *cv|NULLOK SV *sv|U32 flags\nApd\t|void\t|cv_undef\t|NN CV* cv\np\t|void\t|cv_undef_flags\t|NN CV* cv|U32 flags\np\t|void\t|cv_forget_slab\t|NULLOK CV *cv\nAp\t|void\t|cx_dump\t|NN PERL_CONTEXT* cx\nAp\t|SV*\t|filter_add\t|NULLOK filter_t funcp|NULLOK SV* datasv\nAp\t|void\t|filter_del\t|NN filter_t funcp\nApR\t|I32\t|filter_read\t|int idx|NN SV *buf_sv|int maxlen\nApPR\t|char**\t|get_op_descs\nApPR\t|char**\t|get_op_names\n: FIXME discussion on p5p\npPR\t|const char*\t|get_no_modify\n: FIXME discussion on p5p\npPR\t|U32*\t|get_opargs\nApPR\t|PPADDR_t*|get_ppaddr\n: Used by CXINC, which appears to be in widespread use\nApR\t|I32\t|cxinc\nAfp\t|void\t|deb\t\t|NN const char* pat|...\nAp\t|void\t|vdeb\t\t|NN const char* pat|NULLOK va_list* args\nAp\t|void\t|debprofdump\nEXp\t|SV*\t|multideref_stringify\t|NN const OP* o|NULLOK CV *cv\nEXp\t|SV*\t|multiconcat_stringify\t|NN const OP* o\nAp\t|I32\t|debop\t\t|NN const OP* o\nAp\t|I32\t|debstack\nAp\t|I32\t|debstackptrs\npR\t|SV *\t|defelem_target\t|NN SV *sv|NULLOK MAGIC *mg\nAnp\t|char*\t|delimcpy\t|NN char* to|NN const char* toend|NN const char* from \\\n\t\t\t\t|NN const char* fromend|int delim|NN I32* retlen\nnp\t|char*\t|delimcpy_no_escape|NN char* to|NN const char* toend \\\n\t\t\t\t   |NN const char* from \\\n\t\t\t\t   |NN const char* fromend|int delim \\\n\t\t\t\t   |NN I32* retlen\n: Used in op.c, perl.c\npM\t|void\t|delete_eval_scope\nAprd\t|OP*    |die_sv         |NN SV *baseex\nAfrpd\t|OP*    |die            |NULLOK const char* pat|...\n: Used in util.c\npr\t|void\t|die_unwind\t|NN SV* msv\nAp\t|void\t|dounwind\t|I32 cxix\n: FIXME\npmb\t|bool|do_aexec\t|NULLOK SV* really|NN SV** mark|NN SV** sp\n: Used in pp_sys.c\np\t|bool|do_aexec5\t|NULLOK SV* really|NN SV** mark|NN SV** sp|int fd|int do_report\nAbp\t|int\t|do_binmode\t|NN PerlIO *fp|int iotype|int mode\n: Used in pp.c\nAp\t|bool\t|do_close\t|NULLOK GV* gv|bool not_implicit\n: Defined in doio.c, used only in pp_sys.c\np\t|bool\t|do_eof\t\t|NN GV* gv\n\n#ifdef PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION\npm\t|bool|do_exec\t|NN const char* cmd\n#else\np\t|bool|do_exec\t|NN const char* cmd\n#endif\n\n#if defined(WIN32) || defined(__SYMBIAN32__) || defined(VMS)\nAp\t|int\t|do_aspawn\t|NULLOK SV* really|NN SV** mark|NN SV** sp\nAp\t|int\t|do_spawn\t|NN char* cmd\nAp\t|int\t|do_spawn_nowait|NN char* cmd\n#endif\n#if !defined(WIN32)\np\t|bool|do_exec3\t|NN const char *incmd|int fd|int do_report\n#endif\n#if defined(PERL_IN_DOIO_C)\ns\t|void\t|exec_failed\t|NN const char *cmd|int fd|int do_report\ns\t|bool\t|argvout_final\t|NN MAGIC *mg|NN IO *io|bool not_implicit\n#endif\n#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)\n: Defined in doio.c, used only in pp_sys.c\np\t|I32\t|do_ipcctl\t|I32 optype|NN SV** mark|NN SV** sp\n: Defined in doio.c, used only in pp_sys.c\np\t|I32\t|do_ipcget\t|I32 optype|NN SV** mark|NN SV** sp\n: Defined in doio.c, used only in pp_sys.c\np\t|I32\t|do_msgrcv\t|NN SV** mark|NN SV** sp\n: Defined in doio.c, used only in pp_sys.c\np\t|I32\t|do_msgsnd\t|NN SV** mark|NN SV** sp\n: Defined in doio.c, used only in pp_sys.c\np\t|I32\t|do_semop\t|NN SV** mark|NN SV** sp\n: Defined in doio.c, used only in pp_sys.c\np\t|I32\t|do_shmio\t|I32 optype|NN SV** mark|NN SV** sp\n#endif\nAp\t|void\t|do_join\t|NN SV *sv|NN SV *delim|NN SV **mark|NN SV **sp\n: Used in pp.c and pp_hot.c, prototype generated by regen/opcode.pl\n: p\t|OP*\t|do_kv\n: used in pp.c, pp_hot.c\npR\t|I32\t|do_ncmp\t|NN SV *const left|NN SV *const right\nApmb\t|bool\t|do_open\t|NN GV* gv|NN const char* name|I32 len|int as_raw \\\n\t\t\t\t|int rawmode|int rawperm|NULLOK PerlIO* supplied_fp\nAbp\t|bool\t|do_open9\t|NN GV *gv|NN const char *name|I32 len|int as_raw \\\n\t\t\t\t|int rawmode|int rawperm|NULLOK PerlIO *supplied_fp \\\n\t\t\t\t|NN SV *svs|I32 num\npn\t|void\t|setfd_cloexec|int fd\npn\t|void\t|setfd_inhexec|int fd\np\t|void\t|setfd_cloexec_for_nonsysfd|int fd\np\t|void\t|setfd_inhexec_for_sysfd|int fd\np\t|void\t|setfd_cloexec_or_inhexec_by_sysfdness|int fd\npR\t|int\t|PerlLIO_dup_cloexec|int oldfd\np\t|int\t|PerlLIO_dup2_cloexec|int oldfd|int newfd\npR\t|int\t|PerlLIO_open_cloexec|NN const char *file|int flag\npR\t|int\t|PerlLIO_open3_cloexec|NN const char *file|int flag|int perm\npnoR\t|int\t|my_mkstemp_cloexec|NN char *templte\n#ifdef HAS_PIPE\npR\t|int\t|PerlProc_pipe_cloexec|NN int *pipefd\n#endif\n#ifdef HAS_SOCKET\npR\t|int\t|PerlSock_socket_cloexec|int domain|int type|int protocol\npR\t|int\t|PerlSock_accept_cloexec|int listenfd \\\n\t\t\t\t|NULLOK struct sockaddr *addr \\\n\t\t\t\t|NULLOK Sock_size_t *addrlen\n#endif\n#if defined (HAS_SOCKETPAIR) || \\\n    (defined (HAS_SOCKET) && defined(SOCK_DGRAM) && \\\n\tdefined(AF_INET) && defined(PF_INET))\npR\t|int\t|PerlSock_socketpair_cloexec|int domain|int type|int protocol \\\n\t\t\t\t|NN int *pairfd\n#endif\n#if defined(PERL_IN_DOIO_C)\ns\t|IO *\t|openn_setup    |NN GV *gv|NN char *mode|NN PerlIO **saveifp \\\n\t\t\t\t|NN PerlIO **saveofp|NN int *savefd \\\n                                |NN char *savetype\ns\t|bool\t|openn_cleanup\t|NN GV *gv|NN IO *io|NULLOK PerlIO *fp \\\n\t\t\t\t|NN char *mode|NN const char *oname \\\n                                |NULLOK PerlIO *saveifp|NULLOK PerlIO *saveofp \\\n                                |int savefd|char savetype|int writing \\\n                                |bool was_fdopen|NULLOK const char *type \\\n                                |NULLOK Stat_t *statbufp\n#endif\nAp\t|bool\t|do_openn\t|NN GV *gv|NN const char *oname|I32 len \\\n\t\t\t\t|int as_raw|int rawmode|int rawperm \\\n\t\t\t\t|NULLOK PerlIO *supplied_fp|NULLOK SV **svp \\\n\t\t\t\t|I32 num\nMp\t|bool\t|do_open_raw\t|NN GV *gv|NN const char *oname|STRLEN len \\\n\t\t\t\t|int rawmode|int rawperm|NULLOK Stat_t *statbufp\nMp\t|bool\t|do_open6\t|NN GV *gv|NN const char *oname|STRLEN len \\\n\t\t\t\t|NULLOK PerlIO *supplied_fp|NULLOK SV **svp \\\n\t\t\t\t|U32 num\n: Used in pp_hot.c and pp_sys.c\np\t|bool\t|do_print\t|NULLOK SV* sv|NN PerlIO* fp\n: Used in pp_sys.c\npR\t|OP*\t|do_readline\n: Defined in doio.c, used only in pp_sys.c\np\t|bool\t|do_seek\t|NULLOK GV* gv|Off_t pos|int whence\nAp\t|void\t|do_sprintf\t|NN SV* sv|SSize_t len|NN SV** sarg\n: Defined in doio.c, used only in pp_sys.c\np\t|Off_t\t|do_sysseek\t|NN GV* gv|Off_t pos|int whence\n: Defined in doio.c, used only in pp_sys.c\npR\t|Off_t\t|do_tell\t|NN GV* gv\n: Defined in doop.c, used only in pp.c\np\t|Size_t\t|do_trans\t|NN SV* sv\n: Used in my.c and pp.c\np\t|UV\t|do_vecget\t|NN SV* sv|STRLEN offset|int size\n: Defined in doop.c, used only in mg.c (with /* XXX slurp this routine */)\np\t|void\t|do_vecset\t|NN SV* sv\n: Defined in doop.c, used only in pp.c\np\t|void\t|do_vop\t\t|I32 optype|NN SV* sv|NN SV* left|NN SV* right\n: Used in perly.y\np\t|OP*\t|dofile\t\t|NN OP* term|I32 force_builtin\nApR\t|U8\t|dowantarray\nAp\t|void\t|dump_all\np\t|void\t|dump_all_perl\t|bool justperl\nAp\t|void\t|dump_eval\nAp\t|void\t|dump_form\t|NN const GV* gv\nAp\t|void\t|gv_dump\t|NULLOK GV* gv\nApd\t|OPclass|op_class\t|NULLOK const OP *o\nAp\t|void\t|op_dump\t|NN const OP *o\nAp\t|void\t|pmop_dump\t|NULLOK PMOP* pm\nAp\t|void\t|dump_packsubs\t|NN const HV* stash\np\t|void\t|dump_packsubs_perl\t|NN const HV* stash|bool justperl\nAp\t|void\t|dump_sub\t|NN const GV* gv\np\t|void\t|dump_sub_perl\t|NN const GV* gv|bool justperl\nApd\t|void\t|fbm_compile\t|NN SV* sv|U32 flags\nApdR\t|char*\t|fbm_instr\t|NN unsigned char* big|NN unsigned char* bigend \\\n\t\t\t\t|NN SV* littlestr|U32 flags\np\t|CV *\t|find_lexical_cv|PADOFFSET off\n: Defined in util.c, used only in perl.c\np\t|char*\t|find_script\t|NN const char *scriptname|bool dosearch \\\n\t\t\t\t|NULLOK const char *const *const search_ext|I32 flags\n#if defined(PERL_IN_OP_C)\ns\t|OP*\t|force_list\t|NULLOK OP* arg|bool nullit\ni\t|OP*\t|op_integerize\t|NN OP *o\ni\t|OP*\t|op_std_init\t|NN OP *o\n#if defined(USE_ITHREADS)\ni\t|void\t|op_relocate_sv\t|NN SV** svp|NN PADOFFSET* targp\n#endif\ni\t|OP*\t|newMETHOP_internal\t|I32 type|I32 flags|NULLOK OP* dynamic_meth \\\n\t\t\t\t\t|NULLOK SV* const_meth\n: FIXME\ns\t|OP*\t|fold_constants\t|NN OP * const o\ns\t|OP*\t|traverse_op_tree|NN OP* top|NN OP* o\n#endif\nAfpd\t|char*\t|form\t\t|NN const char* pat|...\nAp\t|char*\t|vform\t\t|NN const char* pat|NULLOK va_list* args\nAp\t|void\t|free_tmps\n#if defined(PERL_IN_OP_C)\ns\t|OP*\t|gen_constant_list|NULLOK OP* o\n#endif\n#if !defined(HAS_GETENV_LEN)\n: Used in hv.c\np\t|char*\t|getenv_len\t|NN const char *env_elem|NN unsigned long *len\n#endif\n: Used in pp_ctl.c and pp_hot.c\npox\t|void\t|get_db_sub\t|NULLOK SV **svp|NN CV *cv\nAp\t|void\t|gp_free\t|NULLOK GV* gv\nAp\t|GP*\t|gp_ref\t\t|NULLOK GP* gp\nAp\t|GV*\t|gv_add_by_type\t|NULLOK GV *gv|svtype type\nApmb\t|GV*\t|gv_AVadd\t|NULLOK GV *gv\nApmb\t|GV*\t|gv_HVadd\t|NULLOK GV *gv\nApmb\t|GV*\t|gv_IOadd\t|NULLOK GV* gv\nAmR\t|GV*\t|gv_autoload4\t|NULLOK HV* stash|NN const char* name \\\n\t\t\t\t|STRLEN len|I32 method\nApR\t|GV*\t|gv_autoload_sv\t|NULLOK HV* stash|NN SV* namesv|U32 flags\nApR\t|GV*\t|gv_autoload_pv\t|NULLOK HV* stash|NN const char* namepv \\\n                                |U32 flags\nApR\t|GV*\t|gv_autoload_pvn\t|NULLOK HV* stash|NN const char* name \\\n                                        |STRLEN len|U32 flags\nAp\t|void\t|gv_check\t|NN HV* stash\nAbp\t|void\t|gv_efullname\t|NN SV* sv|NN const GV* gv\nApmb\t|void\t|gv_efullname3\t|NN SV* sv|NN const GV* gv|NULLOK const char* prefix\nAp\t|void\t|gv_efullname4\t|NN SV* sv|NN const GV* gv|NULLOK const char* prefix|bool keepmain\nAp\t|GV*\t|gv_fetchfile\t|NN const char* name\nAp\t|GV*\t|gv_fetchfile_flags|NN const char *const name|const STRLEN len\\\n\t\t\t\t|const U32 flags\nAmd\t|GV*\t|gv_fetchmeth\t|NULLOK HV* stash|NN const char* name \\\n\t\t\t\t|STRLEN len|I32 level\nApd\t|GV*\t|gv_fetchmeth_sv\t|NULLOK HV* stash|NN SV* namesv|I32 level|U32 flags\nApd\t|GV*\t|gv_fetchmeth_pv\t|NULLOK HV* stash|NN const char* name \\\n                                        |I32 level|U32 flags\nApd\t|GV*\t|gv_fetchmeth_pvn\t|NULLOK HV* stash|NN const char* name \\\n                                        |STRLEN len|I32 level|U32 flags\nAmd\t|GV*\t|gv_fetchmeth_autoload\t|NULLOK HV* stash \\\n\t\t\t\t\t|NN const char* name|STRLEN len \\\n\t\t\t\t\t|I32 level\nApd\t|GV*\t|gv_fetchmeth_sv_autoload\t|NULLOK HV* stash|NN SV* namesv|I32 level|U32 flags\nApd\t|GV*\t|gv_fetchmeth_pv_autoload\t|NULLOK HV* stash|NN const char* name \\\n                                        |I32 level|U32 flags\nApd\t|GV*\t|gv_fetchmeth_pvn_autoload\t|NULLOK HV* stash|NN const char* name \\\n                                        |STRLEN len|I32 level|U32 flags\nApdmb\t|GV*\t|gv_fetchmethod\t|NN HV* stash|NN const char* name\nApd\t|GV*\t|gv_fetchmethod_autoload|NN HV* stash|NN const char* name \\\n\t\t\t\t|I32 autoload\nApM\t|GV*\t|gv_fetchmethod_sv_flags|NN HV* stash|NN SV* namesv|U32 flags\nApM\t|GV*\t|gv_fetchmethod_pv_flags|NN HV* stash|NN const char* name \\\n \t\t\t\t|U32 flags\nApM\t|GV*\t|gv_fetchmethod_pvn_flags|NN HV* stash|NN const char* name \\\n\t\t\t\t|const STRLEN len|U32 flags\nAp\t|GV*\t|gv_fetchpv\t|NN const char *nambeg|I32 add|const svtype sv_type\nAbp\t|void\t|gv_fullname\t|NN SV* sv|NN const GV* gv\nApmb\t|void\t|gv_fullname3\t|NN SV* sv|NN const GV* gv|NULLOK const char* prefix\nAp\t|void\t|gv_fullname4\t|NN SV* sv|NN const GV* gv|NULLOK const char* prefix|bool keepmain\n: Used in scope.c\npMox\t|GP *\t|newGP\t\t|NN GV *const gv\npX\t|void\t|cvgv_set\t|NN CV* cv|NULLOK GV* gv\npoX\t|GV *\t|cvgv_from_hek\t|NN CV* cv\npX\t|void\t|cvstash_set\t|NN CV* cv|NULLOK HV* stash\nAmd\t|void\t|gv_init\t|NN GV* gv|NULLOK HV* stash \\\n                                |NN const char* name|STRLEN len|int multi\nAp\t|void\t|gv_init_sv\t|NN GV* gv|NULLOK HV* stash|NN SV* namesv|U32 flags\nAp\t|void\t|gv_init_pv\t|NN GV* gv|NULLOK HV* stash|NN const char* name \\\n                                |U32 flags\nAp\t|void\t|gv_init_pvn\t|NN GV* gv|NULLOK HV* stash|NN const char* name \\\n                                |STRLEN len|U32 flags\nAp\t|void\t|gv_name_set\t|NN GV* gv|NN const char *name|U32 len|U32 flags\npx\t|GV *\t|gv_override\t|NN const char * const name \\\n\t\t\t\t|const STRLEN len\nXMpd\t|void\t|gv_try_downgrade|NN GV* gv\np\t|void\t|gv_setref\t|NN SV *const dstr|NN SV *const sstr\nApd\t|HV*\t|gv_stashpv\t|NN const char* name|I32 flags\nApd\t|HV*\t|gv_stashpvn\t|NN const char* name|U32 namelen|I32 flags\n#if defined(PERL_IN_GV_C)\ni\t|HV*\t|gv_stashpvn_internal\t|NN const char* name|U32 namelen|I32 flags\ni\t|HV*\t|gv_stashsvpvn_cached\t|NULLOK SV *namesv|NULLOK const char* name|U32 namelen|I32 flags\ni\t|GV*\t|gv_fetchmeth_internal\t|NULLOK HV* stash|NULLOK SV* meth|NULLOK const char* name \\\n\t\t\t\t\t|STRLEN len|I32 level|U32 flags\n#endif\nApd\t|HV*\t|gv_stashsv\t|NN SV* sv|I32 flags\nApd\t|void\t|hv_clear\t|NULLOK HV *hv\n: used in SAVEHINTS() and op.c\nApdR\t|HV *\t|hv_copy_hints_hv|NULLOK HV *const ohv\nAp\t|void\t|hv_delayfree_ent|NN HV *hv|NULLOK HE *entry\nAbmdp\t|SV*\t|hv_delete\t|NULLOK HV *hv|NN const char *key|I32 klen \\\n\t\t\t\t|I32 flags\nAbmdp\t|SV*\t|hv_delete_ent\t|NULLOK HV *hv|NN SV *keysv|I32 flags|U32 hash\nAbmdRp\t|bool\t|hv_exists\t|NULLOK HV *hv|NN const char *key|I32 klen\nAbmdRp\t|bool\t|hv_exists_ent\t|NULLOK HV *hv|NN SV *keysv|U32 hash\nAbmdp\t|SV**\t|hv_fetch\t|NULLOK HV *hv|NN const char *key|I32 klen \\\n\t\t\t\t|I32 lval\nAbmdp\t|HE*\t|hv_fetch_ent\t|NULLOK HV *hv|NN SV *keysv|I32 lval|U32 hash\nAp\t|void*\t|hv_common\t|NULLOK HV *hv|NULLOK SV *keysv \\\n\t\t\t\t|NULLOK const char* key|STRLEN klen|int flags \\\n\t\t\t\t|int action|NULLOK SV *val|U32 hash\nAp\t|void*\t|hv_common_key_len|NULLOK HV *hv|NN const char *key \\\n\t\t\t\t|I32 klen_i32|const int action|NULLOK SV *val \\\n\t\t\t\t|const U32 hash\nApod\t|STRLEN\t|hv_fill\t|NN HV *const hv\nAp\t|void\t|hv_free_ent\t|NN HV *hv|NULLOK HE *entry\nApd\t|I32\t|hv_iterinit\t|NN HV *hv\nApdR\t|char*\t|hv_iterkey\t|NN HE* entry|NN I32* retlen\nApdR\t|SV*\t|hv_iterkeysv\t|NN HE* entry\nApdRbm\t|HE*\t|hv_iternext\t|NN HV *hv\nApdR\t|SV*\t|hv_iternextsv\t|NN HV *hv|NN char **key|NN I32 *retlen\nApMdR\t|HE*\t|hv_iternext_flags|NN HV *hv|I32 flags\nApdR\t|SV*\t|hv_iterval\t|NN HV *hv|NN HE *entry\nAp\t|void\t|hv_ksplit\t|NN HV *hv|IV newmax\nApdbm\t|void\t|hv_magic\t|NN HV *hv|NULLOK GV *gv|int how\n#if defined(PERL_IN_HV_C)\ns\t|SV *\t|refcounted_he_value\t|NN const struct refcounted_he *he\n#endif\nXpd\t|HV *\t|refcounted_he_chain_2hv|NULLOK const struct refcounted_he *c|U32 flags\nXpd\t|SV *\t|refcounted_he_fetch_pvn|NULLOK const struct refcounted_he *chain \\\n\t\t\t\t|NN const char *keypv|STRLEN keylen|U32 hash|U32 flags\nXpd\t|SV *\t|refcounted_he_fetch_pv|NULLOK const struct refcounted_he *chain \\\n\t\t\t\t|NN const char *key|U32 hash|U32 flags\nXpd\t|SV *\t|refcounted_he_fetch_sv|NULLOK const struct refcounted_he *chain \\\n\t\t\t\t|NN SV *key|U32 hash|U32 flags\nXpd\t|struct refcounted_he *|refcounted_he_new_pvn \\\n\t\t\t\t|NULLOK struct refcounted_he *parent \\\n\t\t\t\t|NN const char *keypv|STRLEN keylen \\\n\t\t\t\t|U32 hash|NULLOK SV *value|U32 flags\nXpd\t|struct refcounted_he *|refcounted_he_new_pv \\\n\t\t\t\t|NULLOK struct refcounted_he *parent \\\n\t\t\t\t|NN const char *key \\\n\t\t\t\t|U32 hash|NULLOK SV *value|U32 flags\nXpd\t|struct refcounted_he *|refcounted_he_new_sv \\\n\t\t\t\t|NULLOK struct refcounted_he *parent \\\n\t\t\t\t|NN SV *key \\\n\t\t\t\t|U32 hash|NULLOK SV *value|U32 flags\nXpd\t|void\t|refcounted_he_free|NULLOK struct refcounted_he *he\nXpd\t|struct refcounted_he *|refcounted_he_inc|NULLOK struct refcounted_he *he\nApbmd\t|SV**\t|hv_store\t|NULLOK HV *hv|NULLOK const char *key \\\n\t\t\t\t|I32 klen|NULLOK SV *val|U32 hash\nApbmd\t|HE*\t|hv_store_ent\t|NULLOK HV *hv|NULLOK SV *key|NULLOK SV *val\\\n\t\t\t\t|U32 hash\nApbmM\t|SV**\t|hv_store_flags\t|NULLOK HV *hv|NULLOK const char *key \\\n\t\t\t\t|I32 klen|NULLOK SV *val|U32 hash|int flags\nAmd\t|void\t|hv_undef\t|NULLOK HV *hv\npoX\t|void\t|hv_undef_flags\t|NULLOK HV *hv|U32 flags\nAmP\t|I32\t|ibcmp\t\t|NN const char* a|NN const char* b|I32 len\nAinp\t|I32\t|foldEQ\t\t|NN const char* a|NN const char* b|I32 len\nAmP\t|I32\t|ibcmp_locale\t|NN const char* a|NN const char* b|I32 len\nAinp\t|I32\t|foldEQ_locale\t|NN const char* a|NN const char* b|I32 len\nAm\t|I32\t|ibcmp_utf8\t|NN const char *s1|NULLOK char **pe1|UV l1 \\\n\t\t\t\t|bool u1|NN const char *s2|NULLOK char **pe2 \\\n\t\t\t\t|UV l2|bool u2\nAmd\t|I32\t|foldEQ_utf8\t|NN const char *s1|NULLOK char **pe1|UV l1 \\\n\t\t\t\t|bool u1|NN const char *s2|NULLOK char **pe2 \\\n\t\t\t\t|UV l2|bool u2\nAMp\t|I32\t|foldEQ_utf8_flags |NN const char *s1|NULLOK char **pe1|UV l1 \\\n\t\t\t\t|bool u1|NN const char *s2|NULLOK char **pe2 \\\n\t\t\t\t|UV l2|bool u2|U32 flags\nAinp\t|I32\t|foldEQ_latin1\t|NN const char* a|NN const char* b|I32 len\n#if defined(PERL_IN_DOIO_C)\nsR\t|bool\t|ingroup\t|Gid_t testgid|bool effective\n#endif\n: Used in toke.c\np\t|void\t|init_argv_symbols|int argc|NN char **argv\n: Used in pp_ctl.c\npo\t|void\t|init_dbargs\n: Used in mg.c\np\t|void\t|init_debugger\nAp\t|void\t|init_stacks\nAp\t|void\t|init_tm\t|NN struct tm *ptm\n: Used in perly.y\nAbmnpPR\t|char*\t|instr\t\t|NN const char* big|NN const char* little\n: Used in sv.c\np\t|bool\t|io_close\t|NN IO* io|NULLOK GV *gv \\\n\t\t\t\t|bool not_implicit|bool warn_on_fail\n: Used in perly.y\npR\t|OP*\t|invert\t\t|NULLOK OP* cmd\nApR\t|I32\t|is_lvalue_sub\n: Used in cop.h\nXopR\t|I32\t|was_lvalue_sub\nApMRnP\t|STRLEN\t|_is_utf8_char_helper|NN const U8 * const s|NN const U8 * e|const U32 flags\nAbDMpR\t|U32\t|to_uni_upper_lc|U32 c\nAbDMpR\t|U32\t|to_uni_title_lc|U32 c\nAbDMpR\t|U32\t|to_uni_lower_lc|U32 c\nAbDMpR\t|bool\t|is_uni_alnum\t|UV c\nAbDMpR\t|bool\t|is_uni_alnumc\t|UV c\nAbDMpR\t|bool\t|is_uni_idfirst\t|UV c\nAbDMpR\t|bool\t|is_uni_alpha\t|UV c\nAbDMpPR\t|bool\t|is_uni_ascii\t|UV c\nAbDMpPR\t|bool\t|is_uni_blank\t|UV c\nAbDMpPR\t|bool\t|is_uni_space\t|UV c\nAbDMpPR\t|bool\t|is_uni_cntrl\t|UV c\nAbDMpR\t|bool\t|is_uni_graph\t|UV c\nAbDMpR\t|bool\t|is_uni_digit\t|UV c\nAbDMpR\t|bool\t|is_uni_upper\t|UV c\nAbDMpR\t|bool\t|is_uni_lower\t|UV c\nAbDMpR\t|bool\t|is_uni_print\t|UV c\nAbDMpR\t|bool\t|is_uni_punct\t|UV c\nAbDMpPR\t|bool\t|is_uni_xdigit\t|UV c\nAMp\t|UV\t|to_uni_upper\t|UV c|NN U8 *p|NN STRLEN *lenp\nAMp\t|UV\t|to_uni_title\t|UV c|NN U8 *p|NN STRLEN *lenp\nAbDMpR\t|bool\t|isIDFIRST_lazy\t|NN const char* p\nAbDMpR\t|bool\t|isALNUM_lazy\t|NN const char* p\np\t|void\t|init_uniprops\n#ifdef PERL_IN_UTF8_C\nsnR\t|U8\t|to_lower_latin1|const U8 c|NULLOK U8 *p|NULLOK STRLEN *lenp  \\\n\t\t|const char dummy\n#  ifndef UV_IS_QUAD\nsnR\t|int\t|is_utf8_cp_above_31_bits|NN const U8 * const s\t\t    \\\n\t\t\t\t\t |NN const U8 * const e\t\t    \\\n\t\t\t\t\t |const bool consider_overlongs\n#  endif\n#endif\n#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)\nEXnp\t|UV        |_to_fold_latin1|const U8 c|NN U8 *p|NN STRLEN *lenp|const unsigned int flags\n#endif\n#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)\np\t|UV\t|_to_upper_title_latin1|const U8 c|NN U8 *p|NN STRLEN *lenp|const char S_or_s\n#endif\nAMp\t|UV\t|to_uni_lower\t|UV c|NN U8 *p|NN STRLEN *lenp\nAMmp\t|UV\t|to_uni_fold\t|UV c|NN U8 *p|NN STRLEN *lenp\nAMp\t|UV\t|_to_uni_fold_flags|UV c|NN U8 *p|NN STRLEN *lenp|U8 flags\nAbDMpR\t|bool\t|is_uni_alnum_lc|UV c\nAbDMpR\t|bool\t|is_uni_alnumc_lc|UV c\nAbDMpR\t|bool\t|is_uni_idfirst_lc|UV c\nAMpR\t|bool\t|_is_uni_perl_idcont|UV c\nAMpR\t|bool\t|_is_uni_perl_idstart|UV c\nAbDMpR\t|bool\t|is_uni_alpha_lc|UV c\nAbDMpPR\t|bool\t|is_uni_ascii_lc|UV c\nAbDMpPR\t|bool\t|is_uni_space_lc|UV c\nAbDMpPR\t|bool\t|is_uni_blank_lc|UV c\nAbDMpPR\t|bool\t|is_uni_cntrl_lc|UV c\nAbDMpR\t|bool\t|is_uni_graph_lc|UV c\nAbDMpR\t|bool\t|is_uni_digit_lc|UV c\nAbDMpR\t|bool\t|is_uni_upper_lc|UV c\nAbDMpR\t|bool\t|is_uni_lower_lc|UV c\nAbDMpR\t|bool\t|is_uni_print_lc|UV c\nAbDMpR\t|bool\t|is_uni_punct_lc|UV c\nAbDMpPR\t|bool\t|is_uni_xdigit_lc|UV c\nAndmoR\t|bool\t|is_utf8_invariant_string|NN const U8* const s\t\t    \\\n\t\t|STRLEN len\nAnidR\t|bool\t|is_utf8_invariant_string_loc|NN const U8* const s\t    \\\n\t\t|STRLEN len\t\t\t\t\t\t    \\\n\t\t|NULLOK const U8 ** ep\n#ifndef EBCDIC\nAniR\t|unsigned int|_variant_byte_number|PERL_UINTMAX_T word\n#endif\n#if defined(PERL_CORE) || defined(PERL_EXT)\nEinR\t|Size_t\t|variant_under_utf8_count|NN const U8* const s\t\t    \\\n\t\t|NN const U8* const e\n#endif\nAmnpdRP\t|bool\t|is_ascii_string|NN const U8* const s|STRLEN len\nAmnpdRP\t|bool\t|is_invariant_string|NN const U8* const s|STRLEN len\n#if defined(PERL_CORE) || defined (PERL_EXT)\nEXnidR\t|bool\t|is_utf8_non_invariant_string|NN const U8* const s\t    \\\n\t\t|STRLEN len\n#endif\nAbnpdD\t|STRLEN\t|is_utf8_char\t|NN const U8 *s\nAbmnpd\t|STRLEN\t|is_utf8_char_buf|NN const U8 *buf|NN const U8 *buf_end\nAnidR\t|Size_t\t|isUTF8_CHAR|NN const U8 * const s0\t\t\t    \\\n\t\t\t    |NN const U8 * const e\nAnidR\t|Size_t\t|isSTRICT_UTF8_CHAR |NN const U8 * const s0\t\t    \\\n\t\t\t\t    |NN const U8 * const e\nAnidR\t|Size_t\t|isC9_STRICT_UTF8_CHAR |NN const U8 * const s0\t\t    \\\n\t\t\t\t       |NN const U8 * const e\nAnmdpR\t|bool\t|is_utf8_string\t|NN const U8 *s|STRLEN len\nAnidR\t|bool\t|is_utf8_string_flags\t\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|const U32 flags\nAnmdpR\t|bool\t|is_strict_utf8_string|NN const U8 *s|STRLEN len\nAnmdpR\t|bool\t|is_c9strict_utf8_string|NN const U8 *s|STRLEN len\nAnpdmb\t|bool\t|is_utf8_string_loc\t\t\t\t\t    \\\n\t\t|NN const U8 *s|const STRLEN len|NN const U8 **ep\nAndm\t|bool\t|is_utf8_string_loc_flags\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|NN const U8 **ep\t\t    \\\n\t\t|const U32 flags\nAndm\t|bool\t|is_strict_utf8_string_loc\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|NN const U8 **ep\nAndm\t|bool\t|is_c9strict_utf8_string_loc\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|NN const U8 **ep\nAnipd\t|bool\t|is_utf8_string_loclen\t\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|NULLOK const U8 **ep\t\t    \\\n\t\t|NULLOK STRLEN *el\nAnid\t|bool\t|is_utf8_string_loclen_flags\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|NULLOK const U8 **ep\t\t    \\\n\t\t|NULLOK STRLEN *el|const U32 flags\nAnid\t|bool\t|is_strict_utf8_string_loclen\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|NULLOK const U8 **ep\t    \\\n\t\t|NULLOK STRLEN *el\nAnid\t|bool\t|is_c9strict_utf8_string_loclen\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|NULLOK const U8 **ep\t    \\\n\t\t|NULLOK STRLEN *el\nAmnd\t|bool\t|is_utf8_fixed_width_buf_flags\t\t\t\t    \\\n\t\t|NN const U8 * const s|STRLEN len|const U32 flags\nAmnd\t|bool\t|is_utf8_fixed_width_buf_loc_flags\t\t\t    \\\n\t\t|NN const U8 * const s|STRLEN len\t\t\t    \\\n\t\t|NULLOK const U8 **ep|const U32 flags\nAnid\t|bool\t|is_utf8_fixed_width_buf_loclen_flags\t\t\t    \\\n\t\t|NN const U8 * const s|STRLEN len\t\t\t    \\\n\t\t|NULLOK const U8 **ep|NULLOK STRLEN *el|const U32 flags\nAmndP\t|bool\t|is_utf8_valid_partial_char\t\t\t\t    \\\n\t\t|NN const U8 * const s|NN const U8 * const e\nAnidR\t|bool\t|is_utf8_valid_partial_char_flags\t\t\t    \\\n\t\t|NN const U8 * const s|NN const U8 * const e|const U32 flags\nAMpR\t|bool\t|_is_uni_FOO|const U8 classnum|const UV c\nAMpR\t|bool\t|_is_utf8_FOO|U8 classnum|NN const U8 * const p\t\t    \\\n\t\t|NN const char * const name\t\t\t\t    \\\n\t\t|NN const char * const alternative\t\t\t    \\\n\t\t|const bool use_utf8|const bool use_locale\t\t    \\\n\t\t|NN const char * const file|const unsigned line\nAMpR\t|bool\t|_is_utf8_FOO_with_len|const U8 classnum|NN const U8 *p\t    \\\n\t\t|NN const U8 * const e\nAbDMpR\t|bool\t|is_utf8_alnum\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_alnumc\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_idfirst|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_xidfirst|NN const U8 *p\nAMpR\t|bool\t|_is_utf8_idcont|NN const U8 *p\nAMpR\t|bool\t|_is_utf8_idstart|NN const U8 *p\nAMpR\t|bool\t|_is_utf8_xidcont|NN const U8 *p\nAMpR\t|bool\t|_is_utf8_xidstart|NN const U8 *p\nAMpR\t|bool\t|_is_utf8_perl_idcont_with_len|NN const U8 *p\t\t    \\\n\t\t|NN const U8 * const e\nAMpR\t|bool\t|_is_utf8_perl_idstart_with_len|NN const U8 *p\t\t    \\\n\t\t|NN const U8 * const e\nAbDMpR\t|bool\t|is_utf8_idcont\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_xidcont\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_alpha\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_ascii\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_blank\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_space\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_perl_space\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_perl_word\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_cntrl\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_digit\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_posix_digit\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_graph\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_upper\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_lower\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_print\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_punct\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_xdigit\t|NN const U8 *p\nAMpR\t|bool\t|_is_utf8_mark\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_mark\t|NN const U8 *p\n#if defined(PERL_CORE) || defined(PERL_EXT)\nEXdpR\t|bool\t|isSCRIPT_RUN\t|NN const U8 *s|NN const U8 *send   \\\n\t\t\t\t|const bool utf8_target\n#endif\n: Used in perly.y\np\t|OP*\t|jmaybe\t\t|NN OP *o\n: Used in pp.c \npP\t|I32\t|keyword\t|NN const char *name|I32 len|bool all_keywords\n#if defined(PERL_IN_OP_C)\ns\t|void\t|inplace_aassign\t|NN OP* o\n#endif\nAp\t|void\t|leave_scope\t|I32 base\np\t|void\t|notify_parser_that_changed_to_utf8\n: Public lexer API\nAMpd\t|void\t|lex_start\t|NULLOK SV* line|NULLOK PerlIO *rsfp|U32 flags\nAMpd\t|bool\t|lex_bufutf8\nAMpd\t|char*\t|lex_grow_linestr|STRLEN len\nAMpd\t|void\t|lex_stuff_pvn\t|NN const char* pv|STRLEN len|U32 flags\nAMpd\t|void\t|lex_stuff_pv\t|NN const char* pv|U32 flags\nAMpd\t|void\t|lex_stuff_sv\t|NN SV* sv|U32 flags\nAMpd\t|void\t|lex_unstuff\t|NN char* ptr\nAMpd\t|void\t|lex_read_to\t|NN char* ptr\nAMpd\t|void\t|lex_discard_to\t|NN char* ptr\nAMpd\t|bool\t|lex_next_chunk\t|U32 flags\nAMpd\t|I32\t|lex_peek_unichar|U32 flags\nAMpd\t|I32\t|lex_read_unichar|U32 flags\nAMpd\t|void\t|lex_read_space\t|U32 flags\n: Public parser API\nAMpd\t|OP*\t|parse_arithexpr|U32 flags\nAMpd\t|OP*\t|parse_termexpr\t|U32 flags\nAMpd\t|OP*\t|parse_listexpr\t|U32 flags\nAMpd\t|OP*\t|parse_fullexpr\t|U32 flags\nAMpd\t|OP*\t|parse_block\t|U32 flags\nAMpd\t|OP*\t|parse_barestmt\t|U32 flags\nAMpd\t|SV*\t|parse_label\t|U32 flags\nAMpd\t|OP*\t|parse_fullstmt\t|U32 flags\nAMpd\t|OP*\t|parse_stmtseq\t|U32 flags\n: Used in various files\nApd\t|void\t|op_null\t|NN OP* o\n: FIXME. Used by Data::Alias\nEXp\t|void\t|op_clear\t|NN OP* o\nAp\t|void\t|op_refcnt_lock\nAp\t|void\t|op_refcnt_unlock\nApdn\t|OP*\t|op_sibling_splice|NULLOK OP *parent|NULLOK OP *start \\\n\t\t|int del_count|NULLOK OP* insert\nApdn\t|OP*\t|op_parent|NN OP *o\n#if defined(PERL_IN_OP_C)\ns\t|OP*\t|listkids\t|NULLOK OP* o\n#endif\np\t|OP*\t|list\t\t|NULLOK OP* o\nApd\t|void\t|load_module|U32 flags|NN SV* name|NULLOK SV* ver|...\nAp\t|void\t|vload_module|U32 flags|NN SV* name|NULLOK SV* ver|NULLOK va_list* args\n: Used in perly.y\np\t|OP*\t|localize\t|NN OP *o|I32 lex\nApdR\t|I32\t|looks_like_number|NN SV *const sv\nApd\t|UV\t|grok_bin\t|NN const char* start|NN STRLEN* len_p|NN I32* flags|NULLOK NV *result\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_TOKE_C) || defined(PERL_IN_DQUOTE_C)\nEMpRX\t|bool\t|grok_bslash_x\t|NN char** s\t\t \\\n\t\t\t\t|NN const char* const send\t \\\n\t\t\t\t|NN UV* uv\t\t\t \\\n\t\t\t\t|NN const char** error_msg       \\\n\t\t\t\t|const bool output_warning       \\\n\t\t\t\t|const bool strict               \\\n\t\t\t\t|const bool silence_non_portable \\\n\t\t\t\t|const bool utf8\nEMpRX\t|char\t|grok_bslash_c\t|const char source|const bool output_warning\nEMpRX\t|bool\t|grok_bslash_o\t|NN char** s\t\t \\\n\t\t\t\t|NN const char* const send\t \\\n\t\t\t\t|NN UV* uv\t\t\t \\\n\t\t\t\t|NN const char** error_msg       \\\n\t\t\t\t|const bool output_warning       \\\n\t\t\t\t|const bool strict               \\\n\t\t\t\t|const bool silence_non_portable \\\n\t\t\t\t|const bool utf8\nEMiR\t|char*|form_short_octal_warning|NN const char * const s  \\\n\t\t\t\t|const STRLEN len\nEiRn\t|I32\t|regcurly\t|NN const char *s\n#endif\nApd\t|UV\t|grok_hex\t|NN const char* start|NN STRLEN* len_p|NN I32* flags|NULLOK NV *result\nApd\t|int\t|grok_infnan\t|NN const char** sp|NN const char *send\nApd\t|int\t|grok_number\t|NN const char *pv|STRLEN len|NULLOK UV *valuep\nApd\t|int\t|grok_number_flags|NN const char *pv|STRLEN len|NULLOK UV *valuep|U32 flags\nApdR\t|bool\t|grok_numeric_radix|NN const char **sp|NN const char *send\nApd\t|UV\t|grok_oct\t|NN const char* start|NN STRLEN* len_p|NN I32* flags|NULLOK NV *result\nEXpn\t|bool\t|grok_atoUV\t|NN const char* pv|NN UV* valptr|NULLOK const char** endptr\n: These are all indirectly referenced by globals.c. This is somewhat annoying.\np\t|int\t|magic_clearenv\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_clear_all_env|NN SV* sv|NN MAGIC* mg\ndp\t|int\t|magic_clearhint|NN SV* sv|NN MAGIC* mg\ndp\t|int\t|magic_clearhints|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_clearisa\t|NULLOK SV* sv|NN MAGIC* mg\np\t|int\t|magic_clearpack|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_clearsig\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_copycallchecker|NN SV* sv|NN MAGIC *mg|NN SV *nsv \\\n\t\t\t\t      |NULLOK const char *name|I32 namlen\np\t|int\t|magic_existspack|NN SV* sv|NN const MAGIC* mg\np\t|int\t|magic_freeovrld|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_get\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getarylen|NN SV* sv|NN const MAGIC* mg\np\t|int\t|magic_getdefelem|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getdebugvar|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getnkeys\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getpack\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getpos\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getsig\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getsubstr|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_gettaint\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getuvar\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getvec\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_nextpack\t|NN SV *sv|NN MAGIC *mg|NN SV *key\np\t|U32\t|magic_regdata_cnt|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_regdatum_get|NN SV* sv|NN MAGIC* mg\n:removing noreturn to silence a warning for this function resulted in no\n:change to the interpreter DLL image under VS 2003 -O1 -GL 32 bits only because\n:this is used in a magic vtable, do not use this on conventionally called funcs\n#ifdef _MSC_VER\np\t|int\t|magic_regdatum_set|NN SV* sv|NN MAGIC* mg\n#else\npr\t|int\t|magic_regdatum_set|NN SV* sv|NN MAGIC* mg\n#endif\np\t|int\t|magic_set\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setarylen|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_cleararylen_p|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_freearylen_p|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setdbline|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setdebugvar|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setdefelem|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setnonelem|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setenv\t|NN SV* sv|NN MAGIC* mg\ndp\t|int\t|magic_sethint\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setisa\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setlvref\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setmglob\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setnkeys\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setpack\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setpos\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setregexp|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setsig\t|NULLOK SV* sv|NN MAGIC* mg\np\t|int\t|magic_setsubstr|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_settaint\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setuvar\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setvec\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setutf8\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_set_all_env|NN SV* sv|NN MAGIC* mg\np\t|U32\t|magic_sizepack\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_wipepack\t|NN SV* sv|NN MAGIC* mg\npod\t|SV*\t|magic_methcall\t|NN SV *sv|NN const MAGIC *mg \\\n\t\t\t\t|NN SV *meth|U32 flags \\\n\t\t\t\t|U32 argc|...\nAp\t|I32 *\t|markstack_grow\n#if defined(USE_LOCALE_COLLATE)\np\t|int\t|magic_setcollxfrm|NN SV* sv|NN MAGIC* mg\npb\t|char*\t|mem_collxfrm\t|NN const char* input_string|STRLEN len|NN STRLEN* xlen\n: Defined in locale.c, used only in sv.c\n#   if defined(PERL_IN_LOCALE_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_MATHOMS_C)\npM\t|char*\t|_mem_collxfrm\t|NN const char* input_string\t\\\n\t\t\t\t|STRLEN len\t\t\t\\\n\t\t\t\t|NN STRLEN* xlen\t\t\\\n\t\t\t\t|bool utf8\n#   endif\n#endif\nAfpd\t|SV*\t|mess\t\t|NN const char* pat|...\nApd\t|SV*\t|mess_sv\t|NN SV* basemsg|bool consume\nApd\t|SV*\t|vmess\t\t|NN const char* pat|NULLOK va_list* args\n: FIXME - either make it public, or stop exporting it. (Data::Alias uses this)\n: Used in gv.c, op.c, toke.c\nEXp\t|void\t|qerror\t\t|NN SV* err\nApd\t|void\t|sortsv\t\t|NULLOK SV** array|size_t num_elts|NN SVCOMPARE_t cmp\nApd\t|void\t|sortsv_flags\t|NULLOK SV** array|size_t num_elts|NN SVCOMPARE_t cmp|U32 flags\nApd\t|int\t|mg_clear\t|NN SV* sv\nApd\t|int\t|mg_copy\t|NN SV *sv|NN SV *nsv|NULLOK const char *key \\\n\t\t\t\t|I32 klen\n: Defined in mg.c, used only in scope.c\npd\t|void\t|mg_localize\t|NN SV* sv|NN SV* nsv|bool setmagic\nApd\t|SV*\t|sv_string_from_errnum|int errnum|NULLOK SV* tgtsv\nApdRn\t|MAGIC*\t|mg_find\t|NULLOK const SV* sv|int type\nApdRn\t|MAGIC*\t|mg_findext\t|NULLOK const SV* sv|int type|NULLOK const MGVTBL *vtbl\n: exported for re.pm\nEXpR\t|MAGIC*\t|mg_find_mglob\t|NN SV* sv\nApd\t|int\t|mg_free\t|NN SV* sv\nApd\t|void\t|mg_free_type\t|NN SV* sv|int how\nApd\t|void\t|mg_freeext\t|NN SV* sv|int how|NULLOK const MGVTBL *vtbl\nApd\t|int\t|mg_get\t\t|NN SV* sv\nApdD\t|U32\t|mg_length\t|NN SV* sv\nApdn\t|void\t|mg_magical\t|NN SV* sv\nApd\t|int\t|mg_set\t\t|NN SV* sv\nAp\t|I32\t|mg_size\t|NN SV* sv\nApn\t|void\t|mini_mktime\t|NN struct tm *ptm\nAMmd\t|OP*\t|op_lvalue\t|NULLOK OP* o|I32 type\npoX\t|OP*\t|op_lvalue_flags|NULLOK OP* o|I32 type|U32 flags\np\t|void\t|finalize_optree\t\t|NN OP* o\np\t|void\t|optimize_optree|NN OP* o\n#if defined(PERL_IN_OP_C)\ns\t|void\t|optimize_op\t|NN OP* o\ns\t|void\t|finalize_op\t|NN OP* o\ns\t|void\t|move_proto_attr|NN OP **proto|NN OP **attrs \\\n\t\t\t\t|NN const GV *name|bool curstash\n#endif\n: Used in op.c and pp_sys.c\np\t|int\t|mode_from_discipline|NULLOK const char* s|STRLEN len\nAp\t|const char*\t|moreswitches\t|NN const char* s\nAp\t|NV\t|my_atof\t|NN const char *s\nAnpR\t|NV\t|my_strtod\t|NN const char * const s|NULLOK char ** e\nApr\t|void\t|my_exit\t|U32 status\nApr\t|void\t|my_failure_exit\nAp\t|I32\t|my_fflush_all\nAnp\t|Pid_t\t|my_fork\nAnp\t|void\t|atfork_lock\nAnp\t|void\t|atfork_unlock\nApmb\t|I32\t|my_lstat\npX\t|I32\t|my_lstat_flags\t|NULLOK const U32 flags\n#if ! defined(HAS_MEMRCHR) && (defined(PERL_CORE) || defined(PERL_EXT))\nExin\t|void *\t|my_memrchr\t|NN const char * s|const char c|const STRLEN len\n#endif\n#if !defined(PERL_IMPLICIT_SYS)\nAp\t|I32\t|my_pclose\t|NULLOK PerlIO* ptr\nAp\t|PerlIO*|my_popen\t|NN const char* cmd|NN const char* mode\n#endif\nAp\t|PerlIO*|my_popen_list\t|NN const char* mode|int n|NN SV ** args\nAp\t|void\t|my_setenv\t|NULLOK const char* nam|NULLOK const char* val\nApmb\t|I32\t|my_stat\npX\t|I32\t|my_stat_flags\t|NULLOK const U32 flags\nAfp\t|char *\t|my_strftime\t|NN const char *fmt|int sec|int min|int hour|int mday|int mon|int year|int wday|int yday|int isdst\n: Used in pp_ctl.c\np\t|void\t|my_unexec\nAbDMnPR\t|UV\t|NATIVE_TO_NEED\t|const UV enc|const UV ch\nAbDMnPR\t|UV\t|ASCII_TO_NEED\t|const UV enc|const UV ch\nApR\t|OP*\t|newANONLIST\t|NULLOK OP* o\nApR\t|OP*\t|newANONHASH\t|NULLOK OP* o\nAp\t|OP*\t|newANONSUB\t|I32 floor|NULLOK OP* proto|NULLOK OP* block\nApdR\t|OP*\t|newASSIGNOP\t|I32 flags|NULLOK OP* left|I32 optype|NULLOK OP* right\nApdR\t|OP*\t|newCONDOP\t|I32 flags|NN OP* first|NULLOK OP* trueop|NULLOK OP* falseop\nApd\t|CV*\t|newCONSTSUB\t|NULLOK HV* stash|NULLOK const char* name|NULLOK SV* sv\nApd\t|CV*\t|newCONSTSUB_flags|NULLOK HV* stash \\\n\t\t\t\t  |NULLOK const char* name|STRLEN len \\\n\t\t\t\t  |U32 flags|NULLOK SV* sv\nAp\t|void\t|newFORM\t|I32 floor|NULLOK OP* o|NULLOK OP* block\nApdR\t|OP*\t|newFOROP\t|I32 flags|NULLOK OP* sv|NN OP* expr|NULLOK OP* block|NULLOK OP* cont\nApdR\t|OP*\t|newGIVENOP\t|NN OP* cond|NN OP* block|PADOFFSET defsv_off\nApdR\t|OP*\t|newLOGOP\t|I32 optype|I32 flags|NN OP *first|NN OP *other\npM\t|LOGOP*\t|alloc_LOGOP\t|I32 type|NULLOK OP *first|NULLOK OP *other\nApdR\t|OP*\t|newLOOPEX\t|I32 type|NN OP* label\nApdR\t|OP*\t|newLOOPOP\t|I32 flags|I32 debuggable|NULLOK OP* expr|NULLOK OP* block\nApdR\t|OP*\t|newNULLLIST\nApdR\t|OP*\t|newOP\t\t|I32 optype|I32 flags\nAp\t|void\t|newPROG\t|NN OP* o\nApdR\t|OP*\t|newRANGE\t|I32 flags|NN OP* left|NN OP* right\nApdR\t|OP*\t|newSLICEOP\t|I32 flags|NULLOK OP* subscript|NULLOK OP* listop\nApdR\t|OP*\t|newSTATEOP\t|I32 flags|NULLOK char* label|NULLOK OP* o\nApbm\t|CV*\t|newSUB\t\t|I32 floor|NULLOK OP* o|NULLOK OP* proto \\\n\t\t\t\t|NULLOK OP* block\npd\t|CV *\t|newXS_len_flags|NULLOK const char *name|STRLEN len \\\n\t\t\t\t|NN XSUBADDR_t subaddr\\\n\t\t\t\t|NULLOK const char *const filename \\\n\t\t\t\t|NULLOK const char *const proto \\\n\t\t\t\t|NULLOK SV **const_svp|U32 flags\npX\t|CV *\t|newXS_deffile\t|NN const char *name|NN XSUBADDR_t subaddr\nApM\t|CV *\t|newXS_flags\t|NULLOK const char *name|NN XSUBADDR_t subaddr\\\n\t\t\t\t|NN const char *const filename \\\n\t\t\t\t|NULLOK const char *const proto|U32 flags\nApd\t|CV*\t|newXS\t\t|NULLOK const char *name|NN XSUBADDR_t subaddr\\\n\t\t\t\t|NN const char *filename\nApmdbR\t|AV*\t|newAV\nApR\t|OP*\t|newAVREF\t|NN OP* o\nApdR\t|OP*\t|newBINOP\t|I32 type|I32 flags|NULLOK OP* first|NULLOK OP* last\nApR\t|OP*\t|newCVREF\t|I32 flags|NULLOK OP* o\nApdR\t|OP*\t|newGVOP\t|I32 type|I32 flags|NN GV* gv\nAm\t|GV*\t|newGVgen\t|NN const char* pack\nApR\t|GV*\t|newGVgen_flags\t|NN const char* pack|U32 flags\nApR\t|OP*\t|newGVREF\t|I32 type|NULLOK OP* o\nApR\t|OP*\t|newHVREF\t|NN OP* o\nApmdbR\t|HV*\t|newHV\nApR\t|HV*\t|newHVhv\t|NULLOK HV *hv\nApRbm\t|IO*\t|newIO\nApdR\t|OP*\t|newLISTOP\t|I32 type|I32 flags|NULLOK OP* first|NULLOK OP* last\nAMpdRn\t|PADNAME *|newPADNAMEouter|NN PADNAME *outer\nAMpdRn\t|PADNAME *|newPADNAMEpvn|NN const char *s|STRLEN len\nAMpdRn\t|PADNAMELIST *|newPADNAMELIST|size_t max\n#ifdef USE_ITHREADS\nApdR\t|OP*\t|newPADOP\t|I32 type|I32 flags|NN SV* sv\n#endif\nApdR\t|OP*\t|newPMOP\t|I32 type|I32 flags\nApdR\t|OP*\t|newPVOP\t|I32 type|I32 flags|NULLOK char* pv\nApR\t|SV*\t|newRV\t\t|NN SV *const sv\nApdR\t|SV*\t|newRV_noinc\t|NN SV *const tmpRef\nApdR\t|SV*\t|newSV\t\t|const STRLEN len\nApR\t|OP*\t|newSVREF\t|NN OP* o\nApdR\t|OP*\t|newSVOP\t|I32 type|I32 flags|NN SV* sv\nApdR\t|OP*\t|newDEFSVOP\npR\t|SV*\t|newSVavdefelem\t|NN AV *av|SSize_t ix|bool extendible\nApdR\t|SV*\t|newSViv\t|const IV i\nApdR\t|SV*\t|newSVuv\t|const UV u\nApdR\t|SV*\t|newSVnv\t|const NV n\nApdR\t|SV*\t|newSVpv\t|NULLOK const char *const s|const STRLEN len\nApdR\t|SV*\t|newSVpvn\t|NULLOK const char *const buffer|const STRLEN len\nApdR\t|SV*\t|newSVpvn_flags\t|NULLOK const char *const s|const STRLEN len|const U32 flags\nApdR\t|SV*\t|newSVhek\t|NULLOK const HEK *const hek\nApdR\t|SV*\t|newSVpvn_share\t|NULLOK const char* s|I32 len|U32 hash\nApdR\t|SV*\t|newSVpv_share\t|NULLOK const char* s|U32 hash\nAfpdR\t|SV*\t|newSVpvf\t|NN const char *const pat|...\nApR\t|SV*\t|vnewSVpvf\t|NN const char *const pat|NULLOK va_list *const args\nApd\t|SV*\t|newSVrv\t|NN SV *const rv|NULLOK const char *const classname\nApmbdR\t|SV*\t|newSVsv\t|NULLOK SV *const old\nApmdR\t|SV*\t|newSVsv_nomg\t|NULLOK SV *const old\nApR\t|SV*\t|newSVsv_flags\t|NULLOK SV *const old|I32 flags\nApdR\t|SV*\t|newSV_type\t|const svtype type\nApdR\t|OP*\t|newUNOP\t|I32 type|I32 flags|NULLOK OP* first\nApdR\t|OP*\t|newUNOP_AUX\t|I32 type|I32 flags|NULLOK OP* first \\\n\t\t\t\t|NULLOK UNOP_AUX_item *aux\nApdR\t|OP*\t|newWHENOP\t|NULLOK OP* cond|NN OP* block\nApdR\t|OP*\t|newWHILEOP\t|I32 flags|I32 debuggable|NULLOK LOOP* loop \\\n\t\t\t\t|NULLOK OP* expr|NULLOK OP* block|NULLOK OP* cont \\\n\t\t\t\t|I32 has_my\nApdR\t|OP*\t|newMETHOP\t|I32 type|I32 flags|NN OP* dynamic_meth\nApdR\t|OP*\t|newMETHOP_named|I32 type|I32 flags|NN SV* const_meth\nApd\t|CV*\t|rv2cv_op_cv\t|NN OP *cvop|U32 flags\nApd\t|OP*\t|ck_entersub_args_list|NN OP *entersubop\nApd\t|OP*\t|ck_entersub_args_proto|NN OP *entersubop|NN GV *namegv|NN SV *protosv\nApd\t|OP*\t|ck_entersub_args_proto_or_list|NN OP *entersubop|NN GV *namegv|NN SV *protosv\npo\t|OP*\t|ck_entersub_args_core|NN OP *entersubop|NN GV *namegv \\\n\t\t\t\t      |NN SV *protosv\nApd\t|void\t|cv_get_call_checker|NN CV *cv|NN Perl_call_checker *ckfun_p|NN SV **ckobj_p\nApd\t|void\t|cv_get_call_checker_flags|NN CV *cv|U32 gflags|NN Perl_call_checker *ckfun_p|NN SV **ckobj_p|NN U32 *ckflags_p\nApd\t|void\t|cv_set_call_checker|NN CV *cv|NN Perl_call_checker ckfun|NN SV *ckobj\nApd\t|void\t|cv_set_call_checker_flags|NN CV *cv \\\n\t\t\t\t\t  |NN Perl_call_checker ckfun \\\n\t\t\t\t\t  |NN SV *ckobj|U32 ckflags\nApd\t|void\t|wrap_op_checker|Optype opcode|NN Perl_check_t new_checker|NN Perl_check_t *old_checker_p\nAMpd\t|void\t|wrap_keyword_plugin|NN Perl_keyword_plugin_t new_plugin|NN Perl_keyword_plugin_t *old_plugin_p\nApR\t|PERL_SI*|new_stackinfo|I32 stitems|I32 cxitems\nAp\t|char*\t|scan_vstring\t|NN const char *s|NN const char *const e \\\n\t\t\t\t|NN SV *sv\nApd\t|const char*\t|scan_version\t|NN const char *s|NN SV *rv|bool qv\nApd\t|const char*\t|prescan_version\t|NN const char *s\\\n\t|bool strict|NULLOK const char** errstr|NULLOK bool *sqv\\\n\t|NULLOK int *ssaw_decimal|NULLOK int *swidth|NULLOK bool *salpha\nApd\t|SV*\t|new_version\t|NN SV *ver\nApd\t|SV*\t|upg_version\t|NN SV *ver|bool qv\nApd\t|SV*\t|vverify\t|NN SV *vs\nApd\t|SV*\t|vnumify\t|NN SV *vs\nApd\t|SV*\t|vnormal\t|NN SV *vs\nApd\t|SV*\t|vstringify\t|NN SV *vs\nApd\t|int\t|vcmp\t\t|NN SV *lhv|NN SV *rhv\n: Used in pp_hot.c and pp_sys.c\np\t|PerlIO*|nextargv\t|NN GV* gv|bool nomagicopen\n#ifdef HAS_MEMMEM\nAdnopP\t|char*\t|ninstr\t\t|NN const char* big|NN const char* bigend \\\n\t\t\t\t|NN const char* little|NN const char* lend\n#else\nAdnpP\t|char*\t|ninstr\t\t|NN const char* big|NN const char* bigend \\\n\t\t\t\t|NN const char* little|NN const char* lend\n#endif\nApd\t|void\t|op_free\t|NULLOK OP* arg\nMp\t|OP*\t|op_unscope\t|NULLOK OP* o\n#ifdef PERL_CORE\np\t|void\t|opslab_free\t|NN OPSLAB *slab\np\t|void\t|opslab_free_nopad|NN OPSLAB *slab\np\t|void\t|opslab_force_free|NN OPSLAB *slab\n#endif\n: Used in perly.y\np\t|void\t|package\t|NN OP* o\n: Used in perly.y\np\t|void\t|package_version|NN OP* v\n: Used in toke.c and perly.y\np\t|PADOFFSET|allocmy\t|NN const char *const name|const STRLEN len\\\n\t\t\t\t|const U32 flags\n#ifdef USE_ITHREADS\nAMp\t|PADOFFSET|alloccopstash|NN HV *hv\n#endif\n: Used in perly.y\npR\t|OP*\t|oopsAV\t\t|NN OP* o\n: Used in perly.y\npR\t|OP*\t|oopsHV\t\t|NN OP* o\n\n: peephole optimiser\np\t|void\t|peep\t\t|NULLOK OP* o\np\t|void\t|rpeep\t\t|NULLOK OP* o\n: Defined in doio.c, used only in pp_hot.c\ndopM\t|PerlIO*|start_glob\t|NN SV *tmpglob|NN IO *io\n\nAp\t|void\t|reentrant_size\nAp\t|void\t|reentrant_init\nAp\t|void\t|reentrant_free\nAnp\t|void*\t|reentrant_retry|NN const char *f|...\n\n: \"Very\" special - can't use the O flag for this one:\n: (The rename from perl_atexit to Perl_call_atexit was in 864dbfa3ca8032ef)\nAp\t|void\t|call_atexit\t|ATEXIT_t fn|NULLOK void *ptr\nApdO\t|I32\t|call_argv\t|NN const char* sub_name|I32 flags|NN char** argv\nApdO\t|I32\t|call_method\t|NN const char* methname|I32 flags\nApdO\t|I32\t|call_pv\t|NN const char* sub_name|I32 flags\nApdO\t|I32\t|call_sv\t|NN SV* sv|volatile I32 flags\nAp\t|void\t|despatch_signals\nAp\t|OP *\t|doref\t\t|NN OP *o|I32 type|bool set_op_ref\nApdO\t|SV*\t|eval_pv\t|NN const char* p|I32 croak_on_error\nApdO\t|I32\t|eval_sv\t|NN SV* sv|I32 flags\nApdO\t|SV*\t|get_sv\t\t|NN const char *name|I32 flags\nApdO\t|AV*\t|get_av\t\t|NN const char *name|I32 flags\nApdO\t|HV*\t|get_hv\t\t|NN const char *name|I32 flags\nApdO\t|CV*\t|get_cv\t\t|NN const char* name|I32 flags\nApd\t|CV*\t|get_cvn_flags\t|NN const char* name|STRLEN len|I32 flags\nAndo\t|const char*|Perl_setlocale|const int category|NULLOK const char* locale\n#if defined(HAS_NL_LANGINFO) && defined(PERL_LANGINFO_H)\nAndo\t|const char*|Perl_langinfo|const nl_item item\n#else\nAndo\t|const char*|Perl_langinfo|const int item\n#endif\nApOM\t|int\t|init_i18nl10n\t|int printwarn\nAbpOM\t|int\t|init_i18nl14n\t|int printwarn\np\t|char*\t|my_strerror\t|const int errnum\nXpn\t|void\t|_warn_problematic_locale\nXp\t|void\t|set_numeric_underlying\nXp\t|void\t|set_numeric_standard\nXp\t|bool\t|_is_in_locale_category|const bool compiling|const int category\nApdn\t|void\t|switch_to_global_locale\nApdn\t|bool\t|sync_locale\nApMn\t|void\t|thread_locale_init\nApMn\t|void\t|thread_locale_term\nApdO\t|void\t|require_pv\t|NN const char* pv\nAbpd\t|void\t|pack_cat\t|NN SV *cat|NN const char *pat|NN const char *patend \\\n\t\t\t\t|NN SV **beglist|NN SV **endlist|NN SV ***next_in_list|U32 flags\nApd\t|void\t|packlist \t|NN SV *cat|NN const char *pat|NN const char *patend|NN SV **beglist|NN SV **endlist\n#if defined(PERL_USES_PL_PIDSTATUS) && defined(PERL_IN_UTIL_C)\ns\t|void\t|pidgone\t|Pid_t pid|int status\n#endif\n: Used in perly.y\np\t|OP*\t|pmruntime\t|NN OP *o|NN OP *expr|NULLOK OP *repl \\\n\t\t\t\t|UV flags|I32 floor\n#if defined(PERL_IN_OP_C)\ns\t|OP*\t|pmtrans\t|NN OP* o|NN OP* expr|NN OP* repl\n#endif\nAp\t|void\t|pop_scope\nAp\t|void\t|push_scope\nApmb\t|OP*\t|ref\t\t|NULLOK OP* o|I32 type\n#if defined(PERL_IN_OP_C)\ns\t|OP*\t|refkids\t|NULLOK OP* o|I32 type\n#endif\nAp\t|void\t|regdump\t|NN const regexp* r\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_PERL_C) || defined(PERL_IN_UTF8_C)\nEXpR\t|SV*\t|_new_invlist_C_array|NN const UV* const list\nEXMp\t|bool\t|_invlistEQ\t|NN SV* const a|NN SV* const b|const bool complement_b\n#endif\nAp\t|I32\t|pregexec\t|NN REGEXP * const prog|NN char* stringarg \\\n\t\t\t\t|NN char* strend|NN char* strbeg \\\n\t\t\t\t|SSize_t minend |NN SV* screamer|U32 nosave\nAp\t|void\t|pregfree\t|NULLOK REGEXP* r\nAp\t|void\t|pregfree2\t|NN REGEXP *rx\n: FIXME - is anything in re using this now?\nEXp\t|REGEXP*|reg_temp_copy\t|NULLOK REGEXP* dsv|NN REGEXP* ssv\nAp\t|void\t|regfree_internal|NN REGEXP *const rx\n#if defined(USE_ITHREADS)\nAp\t|void*\t|regdupe_internal|NN REGEXP * const r|NN CLONE_PARAMS* param\n#endif\nEXp\t|regexp_engine const *|current_re_engine\nAp\t|REGEXP*|pregcomp\t|NN SV * const pattern|const U32 flags\np\t|REGEXP*|re_op_compile\t|NULLOK SV ** const patternp \\\n\t\t\t\t|int pat_count|NULLOK OP *expr \\\n\t\t\t\t|NN const regexp_engine* eng \\\n\t\t\t\t|NULLOK REGEXP *old_re \\\n\t\t\t\t|NULLOK bool *is_bare_re \\\n\t\t\t\t|const U32 rx_flags|const U32 pm_flags\nAp\t|REGEXP*|re_compile\t|NN SV * const pattern|U32 orig_rx_flags\nAp\t|char*\t|re_intuit_start|NN REGEXP * const rx \\\n\t\t\t\t|NULLOK SV* sv \\\n\t\t\t\t|NN const char* const strbeg \\\n\t\t\t\t|NN char* strpos \\\n\t\t\t\t|NN char* strend \\\n\t\t\t\t|const U32 flags \\\n\t\t\t\t|NULLOK re_scream_pos_data *data\nAp\t|SV*\t|re_intuit_string|NN REGEXP  *const r\nAp\t|I32\t|regexec_flags\t|NN REGEXP *const rx|NN char *stringarg \\\n\t\t\t\t|NN char *strend|NN char *strbeg \\\n\t\t\t\t|SSize_t minend|NN SV *sv \\\n\t\t\t\t|NULLOK void *data|U32 flags\nApR\t|regnode*|regnext\t|NULLOK regnode* p\nEXp\t|SV*|reg_named_buff          |NN REGEXP * const rx|NULLOK SV * const key \\\n                                 |NULLOK SV * const value|const U32 flags\nEXp\t|SV*|reg_named_buff_iter     |NN REGEXP * const rx|NULLOK const SV * const lastkey \\\n                                 |const U32 flags\nAp\t|SV*|reg_named_buff_fetch    |NN REGEXP * const rx|NN SV * const namesv|const U32 flags\nAp\t|bool|reg_named_buff_exists  |NN REGEXP * const rx|NN SV * const key|const U32 flags\nAp\t|SV*|reg_named_buff_firstkey |NN REGEXP * const rx|const U32 flags\nAp\t|SV*|reg_named_buff_nextkey  |NN REGEXP * const rx|const U32 flags\nAp\t|SV*|reg_named_buff_scalar   |NN REGEXP * const rx|const U32 flags\nAp\t|SV*|reg_named_buff_all      |NN REGEXP * const rx|const U32 flags\n\n: FIXME - is anything in re using this now?\nEXp\t|void|reg_numbered_buff_fetch|NN REGEXP * const rx|const I32 paren|NULLOK SV * const sv\n: FIXME - is anything in re using this now?\nEXp\t|void|reg_numbered_buff_store|NN REGEXP * const rx|const I32 paren|NULLOK SV const * const value\n: FIXME - is anything in re using this now?\nEXp\t|I32|reg_numbered_buff_length|NN REGEXP * const rx|NN const SV * const sv|const I32 paren\n\n: FIXME - is anything in re using this now?\nEXp\t|SV*|reg_qr_package|NN REGEXP * const rx\n\nAnp\t|void\t|repeatcpy\t|NN char* to|NN const char* from|I32 len|IV count\nAdnpP\t|char*\t|rninstr\t|NN const char* big|NN const char* bigend \\\n\t\t\t\t|NN const char* little|NN const char* lend\nAp\t|Sighandler_t|rsignal\t|int i|Sighandler_t t\n: Used in pp_sys.c\np\t|int\t|rsignal_restore|int i|NULLOK Sigsave_t* t\n: Used in pp_sys.c\np\t|int\t|rsignal_save\t|int i|Sighandler_t t1|NN Sigsave_t* save\nAp\t|Sighandler_t|rsignal_state|int i\n#if defined(PERL_IN_PP_CTL_C)\ns\t|void\t|rxres_free\t|NN void** rsp\ns\t|void\t|rxres_restore\t|NN void **rsp|NN REGEXP *rx\n#endif\n: Used in pp_hot.c\np\t|void\t|rxres_save\t|NN void **rsp|NN REGEXP *rx\n#if !defined(HAS_RENAME)\n: Used in pp_sys.c\np\t|I32\t|same_dirent\t|NN const char* a|NN const char* b\n#endif\nApda\t|char*\t|savepv\t\t|NULLOK const char* pv\nApda\t|char*\t|savepvn\t|NULLOK const char* pv|I32 len\nApda\t|char*\t|savesharedpv\t|NULLOK const char* pv\n\n: NULLOK only to suppress a compiler warning\nApda\t|char*\t|savesharedpvn\t|NULLOK const char *const pv \\\n\t\t\t\t|const STRLEN len\nApda\t|char*\t|savesharedsvpv\t|NN SV *sv\nApda\t|char*\t|savesvpv\t|NN SV* sv\nAp\t|void\t|savestack_grow\nAp\t|void\t|savestack_grow_cnt\t|I32 need\nAmp\t|void\t|save_aelem\t|NN AV* av|SSize_t idx|NN SV **sptr\nAp\t|void\t|save_aelem_flags|NN AV* av|SSize_t idx|NN SV **sptr \\\n\t\t\t\t |const U32 flags\nAp\t|I32\t|save_alloc\t|I32 size|I32 pad\nAp\t|void\t|save_aptr\t|NN AV** aptr\nAp\t|AV*\t|save_ary\t|NN GV* gv\nAp\t|void\t|save_bool\t|NN bool* boolp\nAp\t|void\t|save_clearsv\t|NN SV** svp\nAp\t|void\t|save_delete\t|NN HV *hv|NN char *key|I32 klen\nAp\t|void\t|save_hdelete\t|NN HV *hv|NN SV *keysv\nAp\t|void\t|save_adelete\t|NN AV *av|SSize_t key\nAp\t|void\t|save_destructor|DESTRUCTORFUNC_NOCONTEXT_t f|NN void* p\nAp\t|void\t|save_destructor_x|DESTRUCTORFUNC_t f|NULLOK void* p\nApmb\t|void\t|save_freesv\t|NULLOK SV* sv\n: Used in SAVEFREOP(), used in op.c, pp_ctl.c\nApmb\t|void\t|save_freeop\t|NULLOK OP* o\nApmb\t|void\t|save_freepv\t|NULLOK char* pv\nAp\t|void\t|save_generic_svref|NN SV** sptr\nAp\t|void\t|save_generic_pvref|NN char** str\nAp\t|void\t|save_shared_pvref|NN char** str\nAdp\t|void\t|save_gp\t|NN GV* gv|I32 empty\nAp\t|HV*\t|save_hash\t|NN GV* gv\nAp\t|void\t|save_hints\nAmp\t|void\t|save_helem\t|NN HV *hv|NN SV *key|NN SV **sptr\nAp\t|void\t|save_helem_flags|NN HV *hv|NN SV *key|NN SV **sptr|const U32 flags\nAp\t|void\t|save_hptr\t|NN HV** hptr\nAp\t|void\t|save_I16\t|NN I16* intp\nAp\t|void\t|save_I32\t|NN I32* intp\nAp\t|void\t|save_I8\t|NN I8* bytep\nAp\t|void\t|save_int\t|NN int* intp\nAp\t|void\t|save_item\t|NN SV* item\nAp\t|void\t|save_iv\t|NN IV *ivp\nAbp\t|void\t|save_list\t|NN SV** sarg|I32 maxsarg\nAbp\t|void\t|save_long\t|NN long* longp\nApmb\t|void\t|save_mortalizesv|NN SV* sv\nAbp\t|void\t|save_nogv\t|NN GV* gv\n: Used in SAVEFREOP(), used in gv.c, op.c, perl.c, pp_ctl.c, pp_sort.c\nApmb\t|void\t|save_op\nAp\t|SV*\t|save_scalar\t|NN GV* gv\nAp\t|void\t|save_pptr\t|NN char** pptr\nAp\t|void\t|save_vptr\t|NN void *ptr\nAp\t|void\t|save_re_context\nAp\t|void\t|save_padsv_and_mortalize|PADOFFSET off\nAp\t|void\t|save_sptr\t|NN SV** sptr\nXp\t|void\t|save_strlen\t|NN STRLEN* ptr\nAp\t|SV*\t|save_svref\t|NN SV** sptr\nAMpo\t|void\t|savetmps\nAp\t|void\t|save_pushptr\t|NULLOK void *const ptr|const int type\nAp\t|void\t|save_pushi32ptr|const I32 i|NULLOK void *const ptr|const int type\n: Used by SAVESWITCHSTACK() in pp.c\nAp\t|void\t|save_pushptrptr|NULLOK void *const ptr1 \\\n\t\t\t\t|NULLOK void *const ptr2|const int type\n#if defined(PERL_IN_SCOPE_C)\ns\t|void\t|save_pushptri32ptr|NULLOK void *const ptr1|const I32 i \\\n\t\t\t\t|NULLOK void *const ptr2|const int type\n#endif\n: Used in perly.y\np\t|OP*\t|sawparens\t|NULLOK OP* o\nApd\t|OP*\t|op_contextualize|NN OP* o|I32 context\n: Used in perly.y\np\t|OP*\t|scalar\t\t|NULLOK OP* o\n#if defined(PERL_IN_OP_C)\ns\t|OP*\t|scalarkids\t|NULLOK OP* o\ns\t|OP*\t|scalarseq\t|NULLOK OP* o\n#endif\n: Used in pp_ctl.c\np\t|OP*\t|scalarvoid\t|NN OP* o\nApd\t|NV\t|scan_bin\t|NN const char* start|STRLEN len|NN STRLEN* retlen\nApd\t|NV\t|scan_hex\t|NN const char* start|STRLEN len|NN STRLEN* retlen\nAp\t|char*\t|scan_num\t|NN const char* s|NN YYSTYPE *lvalp\nApd\t|NV\t|scan_oct\t|NN const char* start|STRLEN len|NN STRLEN* retlen\nAMpd\t|OP*\t|op_scope\t|NULLOK OP* o\n: Only used by perl.c/miniperl.c, but defined in caretx.c\npx\t|void\t|set_caret_X\nApd\t|void\t|setdefout\t|NN GV* gv\nAp\t|HEK*\t|share_hek\t|NN const char* str|SSize_t len|U32 hash\n#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)\n: Used in perl.c\nnp\t|Signal_t |sighandler\t|int sig|NULLOK siginfo_t *info|NULLOK void *uap\nAnp\t|Signal_t |csighandler\t|int sig|NULLOK siginfo_t *info|NULLOK void *uap\n#else\nnp\t|Signal_t |sighandler\t|int sig\nAnp\t|Signal_t |csighandler\t|int sig\n#endif\nAp\t|SV**\t|stack_grow\t|NN SV** sp|NN SV** p|SSize_t n\nAp\t|I32\t|start_subparse\t|I32 is_format|U32 flags\nXp\t|void\t|init_named_cv\t|NN CV *cv|NN OP *nameop\n: Used in pp_ctl.c\np\t|void\t|sub_crush_depth|NN CV* cv\nApbmd\t|bool\t|sv_2bool\t|NN SV *const sv\nApd\t|bool\t|sv_2bool_flags\t|NN SV *sv|I32 flags\nApd\t|CV*\t|sv_2cv\t\t|NULLOK SV* sv|NN HV **const st|NN GV **const gvp \\\n\t\t\t\t|const I32 lref\nApd\t|IO*\t|sv_2io\t\t|NN SV *const sv\n#if defined(PERL_IN_SV_C)\ns\t|bool\t|glob_2number\t|NN GV* const gv\n#endif\nApmb\t|IV\t|sv_2iv\t\t|NN SV *sv\nApd\t|IV\t|sv_2iv_flags\t|NN SV *const sv|const I32 flags\nApd\t|SV*\t|sv_2mortal\t|NULLOK SV *const sv\nApd\t|NV\t|sv_2nv_flags\t|NN SV *const sv|const I32 flags\n: Used in pp.c, pp_hot.c, sv.c\npMd\t|SV*\t|sv_2num\t|NN SV *const sv\nApmb\t|char*\t|sv_2pv\t\t|NN SV *sv|NULLOK STRLEN *lp\nApd\t|char*\t|sv_2pv_flags\t|NN SV *const sv|NULLOK STRLEN *const lp|const I32 flags\nApd\t|char*\t|sv_2pvutf8\t|NN SV *sv|NULLOK STRLEN *const lp\nApd\t|char*\t|sv_2pvbyte\t|NN SV *sv|NULLOK STRLEN *const lp\nAbp\t|char*\t|sv_pvn_nomg\t|NN SV* sv|NULLOK STRLEN* lp\nApmb\t|UV\t|sv_2uv\t\t|NN SV *sv\nApd\t|UV\t|sv_2uv_flags\t|NN SV *const sv|const I32 flags\nAbpd\t|IV\t|sv_iv\t\t|NN SV* sv\nAbpd\t|UV\t|sv_uv\t\t|NN SV* sv\nAbpd\t|NV\t|sv_nv\t\t|NN SV* sv\nAbpd\t|char*\t|sv_pvn\t\t|NN SV *sv|NN STRLEN *lp\nAbpd\t|char*\t|sv_pvutf8n\t|NN SV *sv|NN STRLEN *lp\nAbpd\t|char*\t|sv_pvbyten\t|NN SV *sv|NN STRLEN *lp\nApd\t|I32\t|sv_true\t|NULLOK SV *const sv\n#if defined(PERL_IN_SV_C)\nsd\t|void\t|sv_add_arena\t|NN char *const ptr|const U32 size \\\n\t\t\t\t|const U32 flags\n#endif\nApdn\t|void\t|sv_backoff\t|NN SV *const sv\nApd\t|SV*\t|sv_bless\t|NN SV *const sv|NN HV *const stash\n#if defined(PERL_DEBUG_READONLY_COW)\np\t|void\t|sv_buf_to_ro\t|NN SV *sv\n# if defined(PERL_IN_SV_C)\ns\t|void\t|sv_buf_to_rw\t|NN SV *sv\n# endif\n#endif\nAfpd\t|void\t|sv_catpvf\t|NN SV *const sv|NN const char *const pat|...\nApd\t|void\t|sv_vcatpvf\t|NN SV *const sv|NN const char *const pat \\\n\t\t\t\t|NULLOK va_list *const args\nApd\t|void\t|sv_catpv\t|NN SV *const sv|NULLOK const char* ptr\nApmdb\t|void\t|sv_catpvn\t|NN SV *dsv|NN const char *sstr|STRLEN len\nApmdb\t|void\t|sv_catsv\t|NN SV *dstr|NULLOK SV *sstr\nApd\t|void\t|sv_chop\t|NN SV *const sv|NULLOK const char *const ptr\n: Used only in perl.c\npd\t|I32\t|sv_clean_all\n: Used only in perl.c\npd\t|void\t|sv_clean_objs\nApd\t|void\t|sv_clear\t|NN SV *const orig_sv\n#if defined(PERL_IN_SV_C)\ns\t|bool\t|curse\t\t|NN SV * const sv|const bool check_refcnt\n#endif\nAopd\t|I32\t|sv_cmp\t\t|NULLOK SV *const sv1|NULLOK SV *const sv2\nApd\t|I32\t|sv_cmp_flags\t|NULLOK SV *const sv1|NULLOK SV *const sv2 \\\n\t\t\t\t|const U32 flags\nAopd\t|I32\t|sv_cmp_locale\t|NULLOK SV *const sv1|NULLOK SV *const sv2\nApd\t|I32\t|sv_cmp_locale_flags\t|NULLOK SV *const sv1 \\\n\t\t\t\t|NULLOK SV *const sv2|const U32 flags\n#if defined(USE_LOCALE_COLLATE)\nApbmd\t|char*\t|sv_collxfrm\t|NN SV *const sv|NN STRLEN *const nxp\nApd\t|char*\t|sv_collxfrm_flags\t|NN SV *const sv|NN STRLEN *const nxp|I32 const flags\n#endif\nApd\t|int\t|getcwd_sv\t|NN SV* sv\nApd\t|void\t|sv_dec\t\t|NULLOK SV *const sv\nApd\t|void\t|sv_dec_nomg\t|NULLOK SV *const sv\nAp\t|void\t|sv_dump\t|NULLOK SV* sv\nApdR\t|bool\t|sv_derived_from|NN SV* sv|NN const char *const name\nApdR\t|bool\t|sv_derived_from_sv|NN SV* sv|NN SV *namesv|U32 flags\nApdR\t|bool\t|sv_derived_from_pv|NN SV* sv|NN const char *const name|U32 flags\nApdR\t|bool\t|sv_derived_from_pvn|NN SV* sv|NN const char *const name \\\n                                    |const STRLEN len|U32 flags\nApdR\t|bool\t|sv_does\t|NN SV* sv|NN const char *const name\nApdR\t|bool\t|sv_does_sv\t|NN SV* sv|NN SV* namesv|U32 flags\nApdR\t|bool\t|sv_does_pv\t|NN SV* sv|NN const char *const name|U32 flags\nApdR\t|bool\t|sv_does_pvn\t|NN SV* sv|NN const char *const name|const STRLEN len \\\n                                |U32 flags\nApbmd\t|I32\t|sv_eq\t\t|NULLOK SV* sv1|NULLOK SV* sv2\nApd\t|I32\t|sv_eq_flags\t|NULLOK SV* sv1|NULLOK SV* sv2|const U32 flags\nApd\t|void\t|sv_free\t|NULLOK SV *const sv\npoMX\t|void\t|sv_free2\t|NN SV *const sv|const U32 refcnt\n: Used only in perl.c\npd\t|void\t|sv_free_arenas\nApd\t|char*\t|sv_gets\t|NN SV *const sv|NN PerlIO *const fp|I32 append\nApd\t|char*\t|sv_grow\t|NN SV *const sv|STRLEN newlen\nApd\t|void\t|sv_inc\t\t|NULLOK SV *const sv\nApd\t|void\t|sv_inc_nomg\t|NULLOK SV *const sv\nApmdb\t|void\t|sv_insert\t|NN SV *const bigstr|const STRLEN offset \\\n\t\t\t\t|const STRLEN len|NN const char *const little \\\n\t\t\t\t|const STRLEN littlelen\nApd\t|void\t|sv_insert_flags|NN SV *const bigstr|const STRLEN offset|const STRLEN len \\\n\t\t\t\t|NN const char *little|const STRLEN littlelen|const U32 flags\nApd\t|int\t|sv_isa\t\t|NULLOK SV* sv|NN const char *const name\nApd\t|int\t|sv_isobject\t|NULLOK SV* sv\nApd\t|STRLEN\t|sv_len\t\t|NULLOK SV *const sv\nApd\t|STRLEN\t|sv_len_utf8\t|NULLOK SV *const sv\np\t|STRLEN\t|sv_len_utf8_nomg|NN SV *const sv\nApd\t|void\t|sv_magic\t|NN SV *const sv|NULLOK SV *const obj|const int how \\\n\t\t\t\t|NULLOK const char *const name|const I32 namlen\nApd\t|MAGIC *|sv_magicext\t|NN SV *const sv|NULLOK SV *const obj|const int how \\\n\t\t\t\t|NULLOK const MGVTBL *const vtbl|NULLOK const char *const name \\\n\t\t\t\t|const I32 namlen\nEin\t|bool\t|sv_only_taint_gmagic|NN SV *sv\n: exported for re.pm\nEXp\t|MAGIC *|sv_magicext_mglob|NN SV *sv\nApdbmR\t|SV*\t|sv_mortalcopy\t|NULLOK SV *const oldsv\nXpR\t|SV*\t|sv_mortalcopy_flags|NULLOK SV *const oldsv|U32 flags\nApdR\t|SV*\t|sv_newmortal\nApd\t|SV*\t|sv_newref\t|NULLOK SV *const sv\nAp\t|char*\t|sv_peek\t|NULLOK SV* sv\nApd\t|void\t|sv_pos_u2b\t|NULLOK SV *const sv|NN I32 *const offsetp|NULLOK I32 *const lenp\nApd\t|STRLEN\t|sv_pos_u2b_flags|NN SV *const sv|STRLEN uoffset \\\n\t\t\t\t|NULLOK STRLEN *const lenp|U32 flags\nApd\t|void\t|sv_pos_b2u\t|NULLOK SV *const sv|NN I32 *const offsetp\nApd\t|STRLEN\t|sv_pos_b2u_flags|NN SV *const sv|STRLEN const offset \\\n\t\t\t\t |U32 flags\nApmdb\t|char*\t|sv_pvn_force\t|NN SV* sv|NULLOK STRLEN* lp\nApd\t|char*\t|sv_pvutf8n_force|NN SV *const sv|NULLOK STRLEN *const lp\nApd\t|char*\t|sv_pvbyten_force|NN SV *const sv|NULLOK STRLEN *const lp\nApd\t|char*\t|sv_recode_to_utf8\t|NN SV* sv|NN SV *encoding\nApd\t|bool\t|sv_cat_decode\t|NN SV* dsv|NN SV *encoding|NN SV *ssv|NN int *offset \\\n\t\t\t\t|NN char* tstr|int tlen\nApdR\t|const char*\t|sv_reftype\t|NN const SV *const sv|const int ob\nApd\t|SV*\t|sv_ref\t|NULLOK SV *dst|NN const SV *const sv|const int ob\nApd\t|void\t|sv_replace\t|NN SV *const sv|NN SV *const nsv\nApd\t|void\t|sv_report_used\nApd\t|void\t|sv_reset\t|NN const char* s|NULLOK HV *const stash\np\t|void\t|sv_resetpvn\t|NULLOK const char* s|STRLEN len \\\n\t\t\t\t|NULLOK HV *const stash\nAfpd\t|void\t|sv_setpvf\t|NN SV *const sv|NN const char *const pat|...\nApd\t|void\t|sv_vsetpvf\t|NN SV *const sv|NN const char *const pat|NULLOK va_list *const args\nApd\t|void\t|sv_setiv\t|NN SV *const sv|const IV num\nApdb\t|void\t|sv_setpviv\t|NN SV *const sv|const IV num\nApd\t|void\t|sv_setuv\t|NN SV *const sv|const UV num\nApd\t|void\t|sv_setnv\t|NN SV *const sv|const NV num\nApd\t|SV*\t|sv_setref_iv\t|NN SV *const rv|NULLOK const char *const classname|const IV iv\nApd\t|SV*\t|sv_setref_uv\t|NN SV *const rv|NULLOK const char *const classname|const UV uv\nApd\t|SV*\t|sv_setref_nv\t|NN SV *const rv|NULLOK const char *const classname|const NV nv\nApd\t|SV*\t|sv_setref_pv\t|NN SV *const rv|NULLOK const char *const classname \\\n\t\t\t\t|NULLOK void *const pv\nApd\t|SV*\t|sv_setref_pvn\t|NN SV *const rv|NULLOK const char *const classname \\\n\t\t\t\t|NN const char *const pv|const STRLEN n\nApd\t|void\t|sv_setpv\t|NN SV *const sv|NULLOK const char *const ptr\nApd\t|void\t|sv_setpvn\t|NN SV *const sv|NULLOK const char *const ptr|const STRLEN len\nApd\t|char  *|sv_setpv_bufsize|NN SV *const sv|const STRLEN cur|const STRLEN len\nXp\t|void\t|sv_sethek\t|NN SV *const sv|NULLOK const HEK *const hek\nApmdb\t|void\t|sv_setsv\t|NN SV *dstr|NULLOK SV *sstr\nApmdb\t|void\t|sv_taint\t|NN SV* sv\nApdR\t|bool\t|sv_tainted\t|NN SV *const sv\nApd\t|int\t|sv_unmagic\t|NN SV *const sv|const int type\nApd\t|int\t|sv_unmagicext\t|NN SV *const sv|const int type|NULLOK MGVTBL *vtbl\nApdmb\t|void\t|sv_unref\t|NN SV* sv\nApd\t|void\t|sv_unref_flags\t|NN SV *const ref|const U32 flags\nApd\t|void\t|sv_untaint\t|NN SV *const sv\nApd\t|void\t|sv_upgrade\t|NN SV *const sv|svtype new_type\nApdmb\t|void\t|sv_usepvn\t|NN SV* sv|NULLOK char* ptr|STRLEN len\nApd\t|void\t|sv_usepvn_flags|NN SV *const sv|NULLOK char* ptr|const STRLEN len\\\n\t\t\t\t|const U32 flags\nApd\t|void\t|sv_vcatpvfn\t|NN SV *const sv|NN const char *const pat|const STRLEN patlen \\\n\t\t\t\t|NULLOK va_list *const args|NULLOK SV **const svargs|const Size_t sv_count \\\n\t\t\t\t|NULLOK bool *const maybe_tainted\nApd\t|void\t|sv_vcatpvfn_flags|NN SV *const sv|NN const char *const pat|const STRLEN patlen \\\n\t\t\t\t|NULLOK va_list *const args|NULLOK SV **const svargs|const Size_t sv_count \\\n\t\t\t\t|NULLOK bool *const maybe_tainted|const U32 flags\nApd\t|void\t|sv_vsetpvfn\t|NN SV *const sv|NN const char *const pat|const STRLEN patlen \\\n\t\t\t\t|NULLOK va_list *const args|NULLOK SV **const svargs \\\n\t\t\t\t|const Size_t sv_count|NULLOK bool *const maybe_tainted\nApR\t|NV\t|str_to_version\t|NN SV *sv\nEXpRM\t|SV*\t|swash_init\t|NN const char* pkg|NN const char* name|NN SV* listsv|I32 minbits|I32 none\nEXpM\t|UV\t|swash_fetch\t|NN SV *swash|NN const U8 *ptr|bool do_utf8\n#ifdef PERL_IN_REGCOMP_C\nEiMR\t|SV*\t|add_cp_to_invlist\t|NULLOK SV* invlist|const UV cp\nEiMRn\t|bool\t|invlist_is_iterating|NN SV* const invlist\n#ifndef PERL_EXT_RE_BUILD\nEiMRn\t|UV*\t|_invlist_array_init\t|NN SV* const invlist|const bool will_have_0\nEiMRn\t|UV\t|invlist_max\t|NN SV* const invlist\nEsM\t|void\t|_append_range_to_invlist   |NN SV* const invlist|const UV start|const UV end\nEsM\t|void\t|invlist_extend    |NN SV* const invlist|const UV len\nEsM\t|void\t|invlist_replace_list_destroys_src|NN SV *dest|NN SV *src\nEiMRn\t|IV*\t|get_invlist_previous_index_addr|NN SV* invlist\nEiM\t|void\t|invlist_set_len|NN SV* const invlist|const UV len|const bool offset\nEiMn\t|void\t|invlist_set_previous_index|NN SV* const invlist|const IV index\nEiMRn\t|IV\t|invlist_previous_index|NN SV* const invlist\nEiMn\t|void\t|invlist_trim\t|NN SV* invlist\nEiM\t|void\t|invlist_clear\t|NN SV* invlist\nsM\t|void\t|initialize_invlist_guts|NN SV* invlist|const Size_t initial_size\n#endif\nEiMRn\t|STRLEN*|get_invlist_iter_addr\t|NN SV* invlist\nEiMn\t|void\t|invlist_iterinit|NN SV* invlist\nEsMRn\t|bool\t|invlist_iternext|NN SV* invlist|NN UV* start|NN UV* end\nEiMn\t|void\t|invlist_iterfinish|NN SV* invlist\nEiMRn\t|UV\t|invlist_highest|NN SV* const invlist\nEMRs\t|SV*\t|_make_exactf_invlist\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t\t|NN regnode *node\nEsMR\t|SV*\t|invlist_contents|NN SV* const invlist\t\t    \\\n\t\t\t\t |const bool traditional_style\nEsRn\t|bool\t|new_regcurly\t|NN const char *s|NN const char *e\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_UTF8_C)\nEXmM\t|void\t|_invlist_intersection\t|NN SV* const a|NN SV* const b|NN SV** i\nEXpM\t|void\t|_invlist_intersection_maybe_complement_2nd \\\n\t\t|NULLOK SV* const a|NN SV* const b          \\\n\t\t|const bool complement_b|NN SV** i\nEXmM\t|void\t|_invlist_union\t|NULLOK SV* const a|NN SV* const b|NN SV** output\nEXpM\t|void\t|_invlist_union_maybe_complement_2nd        \\\n\t\t|NULLOK SV* const a|NN SV* const b          \\\n\t\t|const bool complement_b|NN SV** output\nEXmM\t|void\t|_invlist_subtract|NN SV* const a|NN SV* const b|NN SV** result\nEXpM\t|void\t|_invlist_invert|NN SV* const invlist\nEXMpR\t|SV*\t|_new_invlist\t|IV initial_size\nEXMpR\t|SV*\t|_add_range_to_invlist\t|NULLOK SV* invlist|UV start|UV end\nEXMpR\t|SV*\t|_setup_canned_invlist|const STRLEN size|const UV element0|NN UV** other_elements_ptr\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_SV_C)\nEMpX\t|SV*\t|invlist_clone\t|NN SV* const invlist|NULLOK SV* newlist\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_TOKE_C) || defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)\nEiMRn\t|UV*\t|invlist_array\t|NN SV* const invlist\nEiMRn\t|bool\t|is_invlist\t|NULLOK SV* const invlist\nEiMRn\t|bool*\t|get_invlist_offset_addr|NN SV* invlist\nEiMRn\t|UV\t|_invlist_len\t|NN SV* const invlist\nEMiRn\t|bool\t|_invlist_contains_cp|NN SV* const invlist|const UV cp\nEXpMRn\t|SSize_t|_invlist_search\t|NN SV* const invlist|const UV cp\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)\nEXpM\t|SV*\t|_get_regclass_nonbitmap_data\t\t\t\t   \\\n\t\t\t\t|NULLOK const regexp *prog\t\t   \\\n\t\t\t\t|NN const struct regnode *node\t\t   \\\n\t\t\t\t|bool doinit\t\t\t\t   \\\n\t\t\t\t|NULLOK SV **listsvp\t\t\t   \\\n\t\t\t\t|NULLOK SV **lonly_utf8_locale\t\t   \\\n\t\t\t\t|NULLOK SV **output_invlist\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined (PERL_IN_DUMP_C)\nEXMp\t|void\t|_invlist_dump\t|NN PerlIO *file|I32 level   \\\n\t\t\t\t|NN const char* const indent \\\n\t\t\t\t|NN SV* const invlist\n#endif\nAp\t|void\t|taint_env\nAp\t|void\t|taint_proper\t|NULLOK const char* f|NN const char *const s\nEpM\t|char *\t|_byte_dump_string\t\t\t\t\t\\\n\t\t\t\t|NN const U8 * const start\t\t\\\n\t\t\t\t|const STRLEN len\t\t\t\\\n\t\t\t\t|const bool format\n#if defined(PERL_IN_UTF8_C)\ninR\t|int\t|does_utf8_overflow|NN const U8 * const s\t\t\\\n\t\t\t\t   |NN const U8 * e\t\t\t\\\n\t\t\t\t   |const bool consider_overlongs\ninR\t|int\t|is_utf8_overlong_given_start_byte_ok|NN const U8 * const s \\\n\t\t\t\t\t\t     |const STRLEN len\ninR\t|int\t|isFF_OVERLONG\t|NN const U8 * const s|const STRLEN len\nsMR\t|char *\t|unexpected_non_continuation_text\t\t\t\\\n\t\t|NN const U8 * const s\t\t\t\t\t\\\n\t\t|STRLEN print_len\t\t\t\t\t\\\n\t\t|const STRLEN non_cont_byte_pos\t\t\t\t\\\n\t\t|const STRLEN expect_len\ns\t|void\t|warn_on_first_deprecated_use\t\t\t\t    \\\n\t\t\t\t|NN const char * const name\t\t    \\\n\t\t\t\t|NN const char * const alternative\t    \\\n\t\t\t\t|const bool use_locale\t\t\t    \\\n\t\t\t\t|NN const char * const file\t\t    \\\n\t\t\t\t|const unsigned line\ns\t|U32\t|check_and_deprecate\t\t\t\t\t    \\\n\t\t\t\t|NN const U8 * p\t\t\t    \\\n\t\t\t\t|NN const U8 ** e\t\t\t    \\\n\t\t\t\t|const unsigned type\t\t\t    \\\n\t\t\t\t|const bool use_locale\t\t\t    \\\n\t\t\t\t|NN const char * const file\t\t    \\\n\t\t\t\t|const unsigned line\ns\t|UV\t|_to_utf8_case  |const UV uv1\t\t\t\t\t\\\n\t\t\t\t|NULLOK const U8 *p\t\t\t\t\\\n\t\t\t\t|NN U8* ustrp\t\t\t\t\t\\\n\t\t\t\t|NN STRLEN *lenp\t\t\t\t\\\n\t\t\t\t|NN SV *invlist\t\t\t\t\t\\\n\t\t\t\t|NN const int * const invmap\t\t\t\\\n\t\t\t\t|NULLOK const unsigned int * const * const aux_tables\t\\\n\t\t\t\t|NULLOK const U8 * const aux_table_lengths\t\\\n\t\t\t\t|NN const char * const normal\ns\t|UV\t|turkic_fc\t|NN const U8 * const p |NN const U8 * const e|NN U8* ustrp|NN STRLEN *lenp\ns\t|UV\t|turkic_lc\t|NN const U8 * const p0|NN const U8 * const e|NN U8* ustrp|NN STRLEN *lenp\ns\t|UV\t|turkic_uc\t|NN const U8 * const p |NN const U8 * const e|NN U8* ustrp|NN STRLEN *lenp\n#endif\nApbmdD\t|UV\t|to_utf8_lower\t|NN const U8 *p|NN U8* ustrp|NULLOK STRLEN *lenp\nAMp\t|UV\t|_to_utf8_lower_flags|NN const U8 *p|NULLOK const U8* e\t\t\\\n\t\t\t\t|NN U8* ustrp|NULLOK STRLEN *lenp|bool flags\t\\\n\t\t\t\t|NN const char * const file|const int line\nApbmdD\t|UV\t|to_utf8_upper\t|NN const U8 *p|NN U8* ustrp|NULLOK STRLEN *lenp\nAMp\t|UV\t|_to_utf8_upper_flags\t|NN const U8 *p|NULLOK const U8 *e\t\\\n\t\t\t\t|NN U8* ustrp|NULLOK STRLEN *lenp|bool flags\t\\\n\t\t\t\t|NN const char * const file|const int line\nApbmdD\t|UV\t|to_utf8_title\t|NN const U8 *p|NN U8* ustrp|NULLOK STRLEN *lenp\nAMp\t|UV\t|_to_utf8_title_flags\t|NN const U8 *p|NULLOK const U8* e\t\\\n\t\t\t\t|NN U8* ustrp|NULLOK STRLEN *lenp|bool flags\t\\\n\t\t\t\t|NN const char * const file|const int line\nApbmdD\t|UV\t|to_utf8_fold\t|NN const U8 *p|NN U8* ustrp|NULLOK STRLEN *lenp\nAMp\t|UV\t|_to_utf8_fold_flags|NN const U8 *p|NULLOK const U8 *e\t\t\\\n\t\t\t\t|NN U8* ustrp|NULLOK STRLEN *lenp|U8 flags  \\\n\t\t\t\t|NN const char * const file|const int line\n#if defined(PERL_IN_MG_C) || defined(PERL_IN_PP_C)\npn\t|bool\t|translate_substr_offsets|STRLEN curlen|IV pos1_iv \\\n\t\t\t\t\t |bool pos1_is_uv|IV len_iv \\\n\t\t\t\t\t |bool len_is_uv|NN STRLEN *posp \\\n\t\t\t\t\t |NN STRLEN *lenp\n#endif\n#if defined(UNLINK_ALL_VERSIONS)\nAp\t|I32\t|unlnk\t\t|NN const char* f\n#endif\nAbpd\t|SSize_t|unpack_str\t|NN const char *pat|NN const char *patend|NN const char *s \\\n\t\t\t\t|NULLOK const char *strbeg|NN const char *strend|NULLOK char **new_s \\\n\t\t\t\t|I32 ocnt|U32 flags\nApd\t|SSize_t|unpackstring\t|NN const char *pat|NN const char *patend|NN const char *s \\\n\t\t\t\t|NN const char *strend|U32 flags\nAp\t|void\t|unsharepvn\t|NULLOK const char* sv|I32 len|U32 hash\n: Used in gv.c, hv.c\np\t|void\t|unshare_hek\t|NULLOK HEK* hek\n: Used in perly.y\np\t|void\t|utilize\t|int aver|I32 floor|NULLOK OP* version|NN OP* idop|NULLOK OP* arg\nApM\t|void\t|_force_out_malformed_utf8_message\t\t\t    \\\n\t\t|NN const U8 *const p|NN const U8 * const e|const U32 flags \\\n\t\t|const bool die_here\nEXp\t|U8*\t|utf16_to_utf8\t|NN U8* p|NN U8 *d|I32 bytelen|NN I32 *newlen\nEXp\t|U8*\t|utf16_to_utf8_reversed|NN U8* p|NN U8 *d|I32 bytelen|NN I32 *newlen\nAdpR\t|STRLEN\t|utf8_length\t|NN const U8* s|NN const U8 *e\nAipdR\t|IV\t|utf8_distance\t|NN const U8 *a|NN const U8 *b\nAipdRn\t|U8*\t|utf8_hop\t|NN const U8 *s|SSize_t off\nAipdRn\t|U8*\t|utf8_hop_back|NN const U8 *s|SSize_t off|NN const U8 *start\nAipdRn\t|U8*\t|utf8_hop_forward|NN const U8 *s|SSize_t off|NN const U8 *end\nAipdRn\t|U8*\t|utf8_hop_safe\t|NN const U8 *s|SSize_t off|NN const U8 *start|NN const U8 *end\nApMd\t|U8*\t|utf8_to_bytes\t|NN U8 *s|NN STRLEN *lenp\nApd\t|int\t|bytes_cmp_utf8\t|NN const U8 *b|STRLEN blen|NN const U8 *u \\\n\t\t\t\t|STRLEN ulen\nAModp\t|U8*\t|bytes_from_utf8|NN const U8 *s|NN STRLEN *lenp|NN bool *is_utf8p\nAMnp\t|U8*\t|bytes_from_utf8_loc|NN const U8 *s\t\t\t    \\\n\t\t\t\t    |NN STRLEN *lenp\t\t\t    \\\n\t\t\t\t    |NN bool *is_utf8p\t\t\t    \\\n\t\t\t\t    |NULLOK const U8 ** first_unconverted\nApMd\t|U8*\t|bytes_to_utf8\t|NN const U8 *s|NN STRLEN *lenp\nApdD\t|UV\t|utf8_to_uvchr\t|NN const U8 *s|NULLOK STRLEN *retlen\nAbpdD\t|UV\t|utf8_to_uvuni\t|NN const U8 *s|NULLOK STRLEN *retlen\nAbpMD\t|UV\t|valid_utf8_to_uvuni\t|NN const U8 *s|NULLOK STRLEN *retlen\nAopd\t|UV\t|utf8_to_uvchr_buf\t|NN const U8 *s|NN const U8 *send|NULLOK STRLEN *retlen\nApdD\t|UV\t|utf8_to_uvuni_buf\t|NN const U8 *s|NN const U8 *send|NULLOK STRLEN *retlen\npM\t|bool\t|check_utf8_print\t|NN const U8 *s|const STRLEN len\n\nAdnop\t|UV\t|utf8n_to_uvchr\t|NN const U8 *s\t\t\t\t    \\\n\t\t\t\t|STRLEN curlen\t\t\t\t    \\\n\t\t\t\t|NULLOK STRLEN *retlen\t\t\t    \\\n\t\t\t\t|const U32 flags\nAdnop\t|UV\t|utf8n_to_uvchr_error|NN const U8 *s\t\t\t    \\\n\t\t\t\t|STRLEN curlen\t\t\t\t    \\\n\t\t\t\t|NULLOK STRLEN *retlen\t\t\t    \\\n\t\t\t\t|const U32 flags\t\t\t    \\\n\t\t\t\t|NULLOK U32 * errors\nAMndi\t|UV\t|utf8n_to_uvchr_msgs|NN const U8 *s\t\t\t    \\\n\t\t\t\t|STRLEN curlen\t\t\t\t    \\\n\t\t\t\t|NULLOK STRLEN *retlen\t\t\t    \\\n\t\t\t\t|const U32 flags\t\t\t    \\\n\t\t\t\t|NULLOK U32 * errors\t\t\t    \\\n\t\t\t\t|NULLOK AV ** msgs\nAMnp\t|UV\t|_utf8n_to_uvchr_msgs_helper\t\t\t\t    \\\n\t\t\t\t|NN const U8 *s\t\t\t\t    \\\n\t\t\t\t|STRLEN curlen\t\t\t\t    \\\n\t\t\t\t|NULLOK STRLEN *retlen\t\t\t    \\\n\t\t\t\t|const U32 flags\t\t\t    \\\n\t\t\t\t|NULLOK U32 * errors\t\t\t    \\\n\t\t\t\t|NULLOK AV ** msgs\nAipnR\t|UV\t|valid_utf8_to_uvchr\t|NN const U8 *s|NULLOK STRLEN *retlen\nAp\t|UV\t|utf8n_to_uvuni|NN const U8 *s|STRLEN curlen|NULLOK STRLEN *retlen|U32 flags\n\nAdm\t|U8*\t|uvchr_to_utf8\t|NN U8 *d|UV uv\nAp\t|U8*\t|uvuni_to_utf8\t|NN U8 *d|UV uv\nAdm\t|U8*\t|uvchr_to_utf8_flags\t|NN U8 *d|UV uv|UV flags\nAdmM\t|U8*\t|uvchr_to_utf8_flags_msgs|NN U8 *d|UV uv|UV flags|NULLOK HV ** msgs\nApod\t|U8*\t|uvoffuni_to_utf8_flags\t|NN U8 *d|UV uv|const UV flags\nApM\t|U8*\t|uvoffuni_to_utf8_flags_msgs|NN U8 *d|UV uv|const UV flags|NULLOK HV** msgs\nAp\t|U8*\t|uvuni_to_utf8_flags\t|NN U8 *d|UV uv|UV flags\nApd\t|char*\t|pv_uni_display\t|NN SV *dsv|NN const U8 *spv|STRLEN len|STRLEN pvlim|UV flags\nApdR\t|char*\t|sv_uni_display\t|NN SV *dsv|NN SV *ssv|STRLEN pvlim|UV flags\nEXpR\t|Size_t\t|_inverse_folds\t|const UV cp\t\t\t\t    \\\n\t\t\t\t|NN unsigned int * first_folds_to\t    \\\n\t\t\t\t|NN const unsigned int ** remaining_folds_to\n: Used by Data::Alias\nEXp\t|void\t|vivify_defelem\t|NN SV* sv\n: Used in pp.c\npR\t|SV*\t|vivify_ref\t|NN SV* sv|U32 to_what\n: Used in pp_sys.c\np\t|I32\t|wait4pid\t|Pid_t pid|NN int* statusp|int flags\n: Used in locale.c and perl.c\np\t|U32\t|parse_unicode_opts|NN const char **popt\nAp\t|U32\t|seed\nXpno\t|double\t|drand48_r\t|NN perl_drand48_t *random_state\nXpno\t|void\t|drand48_init_r |NN perl_drand48_t *random_state|U32 seed\n: Only used in perl.c\np\t|void\t|get_hash_seed        |NN unsigned char * const seed_buffer\n: Used in doio.c, pp_hot.c, pp_sys.c\np\t|void\t|report_evil_fh\t|NULLOK const GV *gv\n: Used in doio.c, pp_hot.c, pp_sys.c\np\t|void\t|report_wrongway_fh|NULLOK const GV *gv|const char have\n: Used in mg.c, pp.c, pp_hot.c, regcomp.c\nXEpd\t|void\t|report_uninit\t|NULLOK const SV *uninit_sv\n#if defined(PERL_IN_OP_C) || defined(PERL_IN_SV_C)\np\t|void\t|report_redefined_cv|NN const SV *name \\\n\t\t\t\t    |NN const CV *old_cv \\\n\t\t\t\t    |NULLOK SV * const *new_const_svp\n#endif\nApd\t|void\t|warn_sv\t|NN SV *baseex\nAfpd\t|void\t|warn\t\t|NN const char* pat|...\nApd\t|void\t|vwarn\t\t|NN const char* pat|NULLOK va_list* args\nAfp\t|void\t|warner\t\t|U32 err|NN const char* pat|...\nAfp\t|void\t|ck_warner\t|U32 err|NN const char* pat|...\nAfp\t|void\t|ck_warner_d\t|U32 err|NN const char* pat|...\nAp\t|void\t|vwarner\t|U32 err|NN const char* pat|NULLOK va_list* args\n#ifdef USE_C_BACKTRACE\npd\t|Perl_c_backtrace*|get_c_backtrace|int max_depth|int skip\ndm\t|void\t|free_c_backtrace|NN Perl_c_backtrace* bt\nApd\t|SV*\t|get_c_backtrace_dump|int max_depth|int skip\nApd\t|bool\t|dump_c_backtrace|NN PerlIO* fp|int max_depth|int skip\n#endif\n: FIXME\np\t|void\t|watch\t\t|NN char** addr\nAm\t|I32\t|whichsig\t|NN const char* sig\nAp\t|I32    |whichsig_sv    |NN SV* sigsv\nAp\t|I32    |whichsig_pv    |NN const char* sig\nAp\t|I32    |whichsig_pvn   |NN const char* sig|STRLEN len\n: used to check for NULs in pathnames and other names\nAiR\t|bool\t|is_safe_syscall|NN const char *pv|STRLEN len|NN const char *what|NN const char *op_name\n#ifdef PERL_CORE\ninR\t|bool\t|should_warn_nl|NN const char *pv\n#endif\n: Used in pp_ctl.c\np\t|void\t|write_to_stderr|NN SV* msv\n: Used in op.c\np\t|int\t|yyerror\t|NN const char *const s\np\t|void\t|yyquit\npr\t|void\t|abort_execution|NN const char * const msg|NN const char * const name\np\t|int\t|yyerror_pv\t|NN const char *const s|U32 flags\np\t|int\t|yyerror_pvn\t|NULLOK const char *const s|STRLEN len|U32 flags\n: Used in perly.y, and by Data::Alias\nEXp\t|int\t|yylex\np\t|void\t|yyunlex\n: Used in perl.c, pp_ctl.c\np\t|int\t|yyparse\t|int gramtype\n: Only used in scope.c\np\t|void\t|parser_free\t|NN const yy_parser *parser\n#ifdef PERL_CORE\np\t|void\t|parser_free_nexttoke_ops|NN yy_parser *parser \\\n\t\t\t\t\t |NN OPSLAB *slab\n#endif\n#if defined(PERL_IN_TOKE_C)\ns\t|int\t|yywarn\t\t|NN const char *const s|U32 flags\n#endif\n#if defined(MYMALLOC)\nAp\t|void\t|dump_mstats\t|NN const char* s\nAp\t|int\t|get_mstats\t|NN perl_mstats_t *buf|int buflen|int level\n#endif\nAnpa\t|Malloc_t|safesysmalloc\t|MEM_SIZE nbytes\nAnpa\t|Malloc_t|safesyscalloc\t|MEM_SIZE elements|MEM_SIZE size\nAnpR\t|Malloc_t|safesysrealloc|Malloc_t where|MEM_SIZE nbytes\nAnp\t|Free_t\t|safesysfree\t|Malloc_t where\nAsrnx\t|void\t|croak_memory_wrap\n#if defined(PERL_GLOBAL_STRUCT)\nAp\t|struct perl_vars *|GetVars\nAp\t|struct perl_vars*|init_global_struct\nAp\t|void\t|free_global_struct|NN struct perl_vars *plvarsp\n#endif\nAp\t|int\t|runops_standard\nAp\t|int\t|runops_debug\nAfpd\t|void\t|sv_catpvf_mg\t|NN SV *const sv|NN const char *const pat|...\nApd\t|void\t|sv_vcatpvf_mg\t|NN SV *const sv|NN const char *const pat \\\n\t\t\t\t|NULLOK va_list *const args\nApd\t|void\t|sv_catpv_mg\t|NN SV *const sv|NULLOK const char *const ptr\nApdbm\t|void\t|sv_catpvn_mg\t|NN SV *sv|NN const char *ptr|STRLEN len\nApdbm\t|void\t|sv_catsv_mg\t|NN SV *dsv|NULLOK SV *ssv\nAfpd\t|void\t|sv_setpvf_mg\t|NN SV *const sv|NN const char *const pat|...\nApd\t|void\t|sv_vsetpvf_mg\t|NN SV *const sv|NN const char *const pat \\\n\t\t\t\t|NULLOK va_list *const args\nApd\t|void\t|sv_setiv_mg\t|NN SV *const sv|const IV i\nApdb\t|void\t|sv_setpviv_mg\t|NN SV *const sv|const IV iv\nApd\t|void\t|sv_setuv_mg\t|NN SV *const sv|const UV u\nApd\t|void\t|sv_setnv_mg\t|NN SV *const sv|const NV num\nApd\t|void\t|sv_setpv_mg\t|NN SV *const sv|NULLOK const char *const ptr\nApd\t|void\t|sv_setpvn_mg\t|NN SV *const sv|NN const char *const ptr|const STRLEN len\nApd\t|void\t|sv_setsv_mg\t|NN SV *const dstr|NULLOK SV *const sstr\nApdbm\t|void\t|sv_usepvn_mg\t|NN SV *sv|NULLOK char *ptr|STRLEN len\nApR\t|MGVTBL*|get_vtbl\t|int vtbl_id\nApd\t|char*\t|pv_display\t|NN SV *dsv|NN const char *pv|STRLEN cur|STRLEN len \\\n\t\t\t\t|STRLEN pvlim\nApd\t|char*\t|pv_escape\t|NULLOK SV *dsv|NN char const * const str\\\n                                |const STRLEN count|const STRLEN max\\\n                                |NULLOK STRLEN * const escaped\\\n                                |const U32 flags\t\t\t\t\nApd\t|char*  |pv_pretty      |NN SV *dsv|NN char const * const str\\\n                                |const STRLEN count|const STRLEN max\\\n                                |NULLOK char const * const start_color\\\n                                |NULLOK char const * const end_color\\\n                                |const U32 flags\t\t\t\t\nAfp\t|void\t|dump_indent\t|I32 level|NN PerlIO *file|NN const char* pat|...\nAp\t|void\t|dump_vindent\t|I32 level|NN PerlIO *file|NN const char* pat \\\n\t\t\t\t|NULLOK va_list *args\nAp\t|void\t|do_gv_dump\t|I32 level|NN PerlIO *file|NN const char *name\\\n\t\t\t\t|NULLOK GV *sv\nAp\t|void\t|do_gvgv_dump\t|I32 level|NN PerlIO *file|NN const char *name\\\n\t\t\t\t|NULLOK GV *sv\nAp\t|void\t|do_hv_dump\t|I32 level|NN PerlIO *file|NN const char *name\\\n\t\t\t\t|NULLOK HV *sv\nAp\t|void\t|do_magic_dump\t|I32 level|NN PerlIO *file|NULLOK const MAGIC *mg|I32 nest \\\n\t\t\t\t|I32 maxnest|bool dumpops|STRLEN pvlim\nAp\t|void\t|do_op_dump\t|I32 level|NN PerlIO *file|NULLOK const OP *o\nAp\t|void\t|do_pmop_dump\t|I32 level|NN PerlIO *file|NULLOK const PMOP *pm\nAp\t|void\t|do_sv_dump\t|I32 level|NN PerlIO *file|NULLOK SV *sv|I32 nest \\\n\t\t\t\t|I32 maxnest|bool dumpops|STRLEN pvlim\nAp\t|void\t|magic_dump\t|NULLOK const MAGIC *mg\nAp\t|void\t|reginitcolors\nApdRmb\t|char*\t|sv_2pv_nolen\t|NN SV* sv\nApdRmb\t|char*\t|sv_2pvutf8_nolen|NN SV* sv\nApdRmb\t|char*\t|sv_2pvbyte_nolen|NN SV* sv\nApmdbR\t|char*\t|sv_pv\t\t|NN SV *sv\nApmdbR\t|char*\t|sv_pvutf8\t|NN SV *sv\nApmdbR\t|char*\t|sv_pvbyte\t|NN SV *sv\nApmdb\t|STRLEN\t|sv_utf8_upgrade|NN SV *sv\nAmd\t|STRLEN\t|sv_utf8_upgrade_nomg|NN SV *sv\nApd\t|bool\t|sv_utf8_downgrade|NN SV *const sv|const bool fail_ok\nApd\t|void\t|sv_utf8_encode |NN SV *const sv\nApd\t|bool\t|sv_utf8_decode |NN SV *const sv\nApdmb\t|void\t|sv_force_normal|NN SV *sv\nApd\t|void\t|sv_force_normal_flags|NN SV *const sv|const U32 flags\npX\t|SSize_t|tmps_grow_p\t|SSize_t ix\nApd\t|SV*\t|sv_rvweaken\t|NN SV *const sv\nApd\t|SV*\t|sv_rvunweaken\t|NN SV *const sv\nAnpMd\t|SV*\t|sv_get_backrefs|NN SV *const sv\n: This is indirectly referenced by globals.c. This is somewhat annoying.\np\t|int\t|magic_killbackrefs|NN SV *sv|NN MAGIC *mg\nAp\t|OP*\t|newANONATTRSUB\t|I32 floor|NULLOK OP *proto|NULLOK OP *attrs|NULLOK OP *block\nAm\t|CV*\t|newATTRSUB\t|I32 floor|NULLOK OP *o|NULLOK OP *proto|NULLOK OP *attrs|NULLOK OP *block\npdX\t|CV*\t|newATTRSUB_x\t|I32 floor|NULLOK OP *o|NULLOK OP *proto \\\n\t\t\t\t |NULLOK OP *attrs|NULLOK OP *block \\\n\t\t\t\t |bool o_is_gv\nAp\t|CV *\t|newMYSUB\t|I32 floor|NN OP *o|NULLOK OP *proto \\\n\t\t\t\t|NULLOK OP *attrs|NULLOK OP *block\np\t|CV*\t|newSTUB\t|NN GV *gv|bool fake\n: Used in perly.y\np\t|OP *\t|my_attrs\t|NN OP *o|NULLOK OP *attrs\n#if defined(USE_ITHREADS)\nApR\t|PERL_CONTEXT*|cx_dup\t|NULLOK PERL_CONTEXT* cx|I32 ix|I32 max|NN CLONE_PARAMS* param\nApR\t|PERL_SI*|si_dup\t|NULLOK PERL_SI* si|NN CLONE_PARAMS* param\nApR\t|ANY*\t|ss_dup\t\t|NN PerlInterpreter* proto_perl|NN CLONE_PARAMS* param\nApR\t|void*\t|any_dup\t|NULLOK void* v|NN const PerlInterpreter* proto_perl\nApR\t|HE*\t|he_dup\t\t|NULLOK const HE* e|bool shared|NN CLONE_PARAMS* param\nApR\t|HEK*\t|hek_dup\t|NULLOK HEK* e|NN CLONE_PARAMS* param\nAp\t|void\t|re_dup_guts\t|NN const REGEXP *sstr|NN REGEXP *dstr \\\n\t\t\t\t|NN CLONE_PARAMS* param\nAp\t|PerlIO*|fp_dup\t\t|NULLOK PerlIO *const fp|const char type|NN CLONE_PARAMS *const param\nApR\t|DIR*\t|dirp_dup\t|NULLOK DIR *const dp|NN CLONE_PARAMS *const param\nApR\t|GP*\t|gp_dup\t\t|NULLOK GP *const gp|NN CLONE_PARAMS *const param\nApR\t|MAGIC*\t|mg_dup\t\t|NULLOK MAGIC *mg|NN CLONE_PARAMS *const param\n#if defined(PERL_IN_SV_C)\ns\t|SV **\t|sv_dup_inc_multiple|NN SV *const *source|NN SV **dest \\\n\t\t\t\t|SSize_t items|NN CLONE_PARAMS *const param\nsR\t|SV*\t|sv_dup_common\t|NN const SV *const sstr \\\n\t\t\t\t|NN CLONE_PARAMS *const param\n#endif\nApR\t|SV*\t|sv_dup\t\t|NULLOK const SV *const sstr|NN CLONE_PARAMS *const param\nApR\t|SV*\t|sv_dup_inc\t|NULLOK const SV *const sstr \\\n\t\t\t\t|NN CLONE_PARAMS *const param\nAp\t|void\t|rvpv_dup\t|NN SV *const dstr|NN const SV *const sstr|NN CLONE_PARAMS *const param\nAp\t|yy_parser*|parser_dup\t|NULLOK const yy_parser *const proto|NN CLONE_PARAMS *const param\n#endif\nApR\t|PTR_TBL_t*|ptr_table_new\nApR\t|void*\t|ptr_table_fetch|NN PTR_TBL_t *const tbl|NULLOK const void *const sv\nAp\t|void\t|ptr_table_store|NN PTR_TBL_t *const tbl|NULLOK const void *const oldsv \\\n\t\t\t\t|NN void *const newsv\nAp\t|void\t|ptr_table_split|NN PTR_TBL_t *const tbl\nApD\t|void\t|ptr_table_clear|NULLOK PTR_TBL_t *const tbl\nAp\t|void\t|ptr_table_free|NULLOK PTR_TBL_t *const tbl\n#if defined(HAVE_INTERP_INTERN)\nAp\t|void\t|sys_intern_clear\nAp\t|void\t|sys_intern_init\n#  if defined(USE_ITHREADS)\nAp\t|void\t|sys_intern_dup\t|NN struct interp_intern* src|NN struct interp_intern* dst\n#  endif\n#endif\n\nAmop\t|const XOP *\t|custom_op_xop\t|NN const OP *o\nAbpR\t|const char *\t|custom_op_name\t|NN const OP *o\nAbpR\t|const char *\t|custom_op_desc\t|NN const OP *o\npRX\t|XOPRETANY\t|custom_op_get_field\t|NN const OP *o|const xop_flags_enum field\nAop\t|void\t|custom_op_register\t|NN Perl_ppaddr_t ppaddr \\\n\t\t\t|NN const XOP *xop\n\nAdp\t|void\t|sv_nosharing\t|NULLOK SV *sv\nAdpbm\t|void\t|sv_nolocking\t|NULLOK SV *sv\nAdp\t|bool\t|sv_destroyable\t|NULLOK SV *sv\nAdpb\t|void\t|sv_nounlocking\t|NULLOK SV *sv\nAdp\t|int\t|nothreadhook\np\t|void\t|init_constants\n\n#if defined(PERL_IN_DOOP_C)\nsR\t|Size_t\t|do_trans_simple\t|NN SV * const sv\nsR\t|Size_t\t|do_trans_count\t\t|NN SV * const sv\nsR\t|Size_t\t|do_trans_complex\t|NN SV * const sv\nsR\t|Size_t\t|do_trans_simple_utf8\t|NN SV * const sv\nsR\t|Size_t\t|do_trans_count_utf8\t|NN SV * const sv\nsR\t|Size_t\t|do_trans_complex_utf8\t|NN SV * const sv\n#endif\n\n#if defined(PERL_IN_GV_C)\ns\t|void\t|gv_init_svtype\t|NN GV *gv|const svtype sv_type\ns\t|void\t|gv_magicalize_isa\t|NN GV *gv\ns\t|bool|parse_gv_stash_name|NN HV **stash|NN GV **gv \\\n                     |NN const char **name|NN STRLEN *len \\\n                     |NN const char *nambeg|STRLEN full_len \\\n                     |const U32 is_utf8|const I32 add\ns\t|bool|find_default_stash|NN HV **stash|NN const char *name \\\n                     |STRLEN len|const U32 is_utf8|const I32 add \\\n                     |const svtype sv_type\ns\t|bool|gv_magicalize|NN GV *gv|NN HV *stash|NN const char *name \\\n                     |STRLEN len \\\n                     |const svtype sv_type\ns\t|void|maybe_multimagic_gv|NN GV *gv|NN const char *name|const svtype sv_type\ns\t|bool|gv_is_in_main|NN const char *name|STRLEN len \\\n                      |const U32 is_utf8\ns\t|void\t|require_tie_mod|NN GV *gv|NN const char varname \\\n\t\t\t\t|NN const char * name|STRLEN len \\\n\t\t\t\t|const U32 flags\n#endif\n\n#if defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C)\npo\t|SV*\t|hfree_next_entry\t|NN HV *hv|NN STRLEN *indexp\n#endif\n\n#if defined(PERL_IN_HV_C)\ns\t|void\t|hsplit\t\t|NN HV *hv|STRLEN const oldsize|STRLEN newsize\ns\t|void\t|hv_free_entries|NN HV *hv\ns\t|SV*\t|hv_free_ent_ret|NN HV *hv|NN HE *entry\nsR\t|HE*\t|new_he\nsanR\t|HEK*\t|save_hek_flags\t|NN const char *str|I32 len|U32 hash|int flags\nsn\t|void\t|hv_magic_check\t|NN HV *hv|NN bool *needs_copy|NN bool *needs_store\ns\t|void\t|unshare_hek_or_pvn|NULLOK const HEK* hek|NULLOK const char* str|I32 len|U32 hash\nsR\t|HEK*\t|share_hek_flags|NN const char *str|STRLEN len|U32 hash|int flags\nrs\t|void\t|hv_notallowed\t|int flags|NN const char *key|I32 klen|NN const char *msg\nin\t|U32|ptr_hash|PTRV u\ns\t|struct xpvhv_aux*|hv_auxinit|NN HV *hv\nsn\t|struct xpvhv_aux*|hv_auxinit_internal|NN struct xpvhv_aux *iter\nsM\t|SV*\t|hv_delete_common|NULLOK HV *hv|NULLOK SV *keysv \\\n\t\t|NULLOK const char *key|STRLEN klen|int k_flags|I32 d_flags \\\n\t\t|U32 hash\nsM\t|void\t|clear_placeholders\t|NN HV *hv|U32 items\n#endif\n\n#if defined(PERL_IN_MG_C)\ns\t|void\t|save_magic_flags|I32 mgs_ix|NN SV *sv|U32 flags\ns\t|int\t|magic_methpack\t|NN SV *sv|NN const MAGIC *mg|NN SV *meth\ns\t|SV*\t|magic_methcall1|NN SV *sv|NN const MAGIC *mg \\\n\t\t\t\t|NN SV *meth|U32 flags \\\n\t\t\t\t|int n|NULLOK SV *val\ns\t|void\t|restore_magic\t|NULLOK const void *p\ns\t|void\t|unwind_handler_stack|NULLOK const void *p\ns\t|void\t|fixup_errno_string|NN SV* sv\n\n#endif\n\n#if defined(PERL_IN_OP_C)\nsRn\t|bool\t|is_handle_constructor|NN const OP *o|I32 numargs\nsR\t|I32\t|assignment_type|NULLOK const OP *o\ns\t|void\t|forget_pmop\t|NN PMOP *const o\ns\t|void\t|find_and_forget_pmops\t|NN OP *o\ns\t|void\t|cop_free\t|NN COP *cop\ns\t|OP*\t|modkids\t|NULLOK OP *o|I32 type\ns\t|OP*\t|scalarboolean\t|NN OP *o\nsR\t|OP*\t|search_const\t|NN OP *o\nsR\t|OP*\t|new_logop\t|I32 type|I32 flags|NN OP **firstp|NN OP **otherp\ns\t|void\t|simplify_sort\t|NN OP *o\nsRn\t|bool\t|scalar_mod_type|NULLOK const OP *o|I32 type\ns\t|OP *\t|my_kid\t\t|NULLOK OP *o|NULLOK OP *attrs|NN OP **imopsp\ns\t|OP *\t|dup_attrlist\t|NN OP *o\ns\t|void\t|apply_attrs\t|NN HV *stash|NN SV *target|NULLOK OP *attrs\ns\t|void\t|apply_attrs_my\t|NN HV *stash|NN OP *target|NULLOK OP *attrs|NN OP **imopsp\ns\t|void\t|bad_type_pv\t|I32 n|NN const char *t|NN const OP *o|NN const OP *kid\ns\t|void\t|bad_type_gv\t|I32 n|NN GV *gv|NN const OP *kid|NN const char *t\ns\t|void\t|no_bareword_allowed|NN OP *o\nsR\t|OP*\t|no_fh_allowed|NN OP *o\nsR\t|OP*\t|too_few_arguments_pv|NN OP *o|NN const char* name|U32 flags\ns\t|OP*\t|too_many_arguments_pv|NN OP *o|NN const char* name|U32 flags\ns\t|bool\t|looks_like_bool|NN const OP* o\ns\t|OP*\t|newGIVWHENOP\t|NULLOK OP* cond|NN OP *block \\\n\t\t\t\t|I32 enter_opcode|I32 leave_opcode \\\n\t\t\t\t|PADOFFSET entertarg\ns\t|OP*\t|ref_array_or_hash|NULLOK OP* cond\ns\t|bool\t|process_special_blocks\t|I32 floor \\\n\t\t\t\t\t|NN const char *const fullname\\\n\t\t\t\t\t|NN GV *const gv|NN CV *const cv\ns\t|void\t|clear_special_blocks\t|NN const char *const fullname\\\n\t\t\t\t\t|NN GV *const gv|NN CV *const cv\n#endif\nXpR\t|void*\t|Slab_Alloc\t|size_t sz\nXp\t|void\t|Slab_Free\t|NN void *op\n#if defined(PERL_DEBUG_READONLY_OPS)\n#    if defined(PERL_CORE)\npx\t|void\t|Slab_to_ro\t|NN OPSLAB *slab\npx\t|void\t|Slab_to_rw\t|NN OPSLAB *const slab\n#    endif\n: Used in OpREFCNT_inc() in sv.c\npoxM\t|OP *\t|op_refcnt_inc\t|NULLOK OP *o\n: FIXME - can be static.\npoxM\t|PADOFFSET\t|op_refcnt_dec\t|NN OP *o\n#endif\n\n#if defined(PERL_IN_PERL_C)\ns\t|void\t|find_beginning\t|NN SV* linestr_sv|NN PerlIO *rsfp\ns\t|void\t|forbid_setid\t|const char flag|const bool suidscript\ns\t|void\t|incpush\t|NN const char *const dir|STRLEN len \\\n\t\t\t\t|U32 flags\ns\t|SV*\t|mayberelocate\t|NN const char *const dir|STRLEN len \\\n\t\t\t\t|U32 flags\ns\t|void\t|incpush_use_sep|NN const char *p|STRLEN len|U32 flags\ns\t|void\t|init_interp\ns\t|void\t|init_ids\ns\t|void\t|init_main_stash\ns\t|void\t|init_perllib\ns\t|void\t|init_postdump_symbols|int argc|NN char **argv|NULLOK char **env\ns\t|void\t|init_predump_symbols\nrs\t|void\t|my_exit_jump\ns\t|void\t|nuke_stacks\ns\t|PerlIO *|open_script\t|NN const char *scriptname|bool dosearch \\\n\t\t\t\t|NN bool *suidscript\nsr\t|void\t|usage\n#ifndef SETUID_SCRIPTS_ARE_SECURE_NOW\nso\t|void\t|validate_suid\t|NN PerlIO *rsfp\n#endif\nsr\t|void\t|minus_v\n\ns\t|void*\t|parse_body\t|NULLOK char **env|XSINIT_t xsinit\nrs\t|void\t|run_body\t|I32 oldscope\n#  ifndef PERL_IS_MINIPERL\ns\t|SV *\t|incpush_if_exists|NN AV *const av|NN SV *dir|NN SV *const stem\n#  endif\n#endif\n\n#if defined(PERL_IN_PP_C)\ns\t|size_t\t|do_chomp\t|NN SV *retval|NN SV *sv|bool chomping\ns\t|OP*\t|do_delete_local\nsR\t|SV*\t|refto\t\t|NN SV* sv\n#endif\n#if defined(PERL_IN_PP_C) || defined(PERL_IN_PP_HOT_C)\n: Used in pp_hot.c\npRxo\t|GV*\t|softref2xv\t|NN SV *const sv|NN const char *const what \\\n\t\t\t\t|const svtype type|NN SV ***spp\n#endif\n\n#if defined(PERL_IN_PP_PACK_C)\ns\t|SSize_t|unpack_rec\t|NN struct tempsym* symptr|NN const char *s \\\n\t\t\t\t|NN const char *strbeg|NN const char *strend|NULLOK const char **new_s\ns\t|SV **\t|pack_rec\t|NN SV *cat|NN struct tempsym* symptr|NN SV **beglist|NN SV **endlist\ns\t|SV*\t|mul128\t\t|NN SV *sv|U8 m\ns\t|SSize_t|measure_struct\t|NN struct tempsym* symptr\ns\t|bool\t|next_symbol\t|NN struct tempsym* symptr\nsR\t|SV*\t|is_an_int\t|NN const char *s|STRLEN l\ns\t|int\t|div128\t\t|NN SV *pnum|NN bool *done\ns\t|const char *|group_end\t|NN const char *patptr|NN const char *patend \\\n\t\t\t\t|char ender\nsR\t|const char *|get_num\t|NN const char *patptr|NN SSize_t *lenptr\nns\t|bool\t|need_utf8\t|NN const char *pat|NN const char *patend\nns\t|char\t|first_symbol\t|NN const char *pat|NN const char *patend\nsR\t|char *\t|sv_exp_grow\t|NN SV *sv|STRLEN needed\nsnR\t|char *\t|my_bytes_to_utf8|NN const U8 *start|STRLEN len|NN char *dest \\\n\t      \t\t\t|const bool needs_swap\n#endif\n\n#if defined(PERL_IN_PP_CTL_C)\nsR\t|OP*\t|docatch\t|Perl_ppaddr_t firstpp\nsR\t|OP*\t|dofindlabel\t|NN OP *o|NN const char *label|STRLEN len \\\n                                |U32 flags|NN OP **opstack|NN OP **oplimit\ns\t|MAGIC *|doparseform\t|NN SV *sv\nsnR\t|bool\t|num_overflow\t|NV value|I32 fldsize|I32 frcsize\nsR\t|I32\t|dopoptoeval\t|I32 startingblock\nsR\t|I32\t|dopoptogivenfor|I32 startingblock\nsR\t|I32\t|dopoptolabel\t|NN const char *label|STRLEN len|U32 flags\nsR\t|I32\t|dopoptoloop\t|I32 startingblock\nsR\t|I32\t|dopoptosub_at\t|NN const PERL_CONTEXT* cxstk|I32 startingblock\nsR\t|I32\t|dopoptowhen\t|I32 startingblock\ns\t|void\t|save_lines\t|NULLOK AV *array|NN SV *sv\ns\t|bool\t|doeval_compile\t|U8 gimme \\\n\t\t\t\t|NULLOK CV* outside|U32 seq|NULLOK HV* hh\nsR\t|PerlIO *|check_type_and_open|NN SV *name\n#ifndef PERL_DISABLE_PMC\nsR\t|PerlIO *|doopen_pm\t|NN SV *name\n#endif\niRn\t|bool\t|path_is_searchable|NN const char *name\nsR\t|I32\t|run_user_filter|int idx|NN SV *buf_sv|int maxlen\nsR\t|PMOP*\t|make_matcher\t|NN REGEXP* re\nsR\t|bool\t|matcher_matches_sv|NN PMOP* matcher|NN SV* sv\ns\t|void\t|destroy_matcher|NN PMOP* matcher\ns\t|OP*\t|do_smartmatch\t|NULLOK HV* seen_this \\\n\t\t\t\t|NULLOK HV* seen_other|const bool copied\n#endif\n\n#if defined(PERL_IN_PP_HOT_C)\ns\t|void\t|do_oddball\t|NN SV **oddkey|NN SV **firstkey\ni\t|HV*\t|opmethod_stash\t|NN SV* meth\n#endif\n\n#if defined(PERL_IN_PP_SORT_C)\ns\t|I32\t|sv_ncmp\t|NN SV *const a|NN SV *const b\ns\t|I32\t|sv_i_ncmp\t|NN SV *const a|NN SV *const b\ns\t|I32\t|amagic_ncmp\t|NN SV *const a|NN SV *const b\ns\t|I32\t|amagic_i_ncmp\t|NN SV *const a|NN SV *const b\ns\t|I32\t|amagic_cmp\t|NN SV *const str1|NN SV *const str2\n#  ifdef USE_LOCALE_COLLATE\ns\t|I32\t|amagic_cmp_locale|NN SV *const str1|NN SV *const str2\n#  endif\ns\t|I32\t|sortcv\t\t|NN SV *const a|NN SV *const b\ns\t|I32\t|sortcv_xsub\t|NN SV *const a|NN SV *const b\ns\t|I32\t|sortcv_stacked\t|NN SV *const a|NN SV *const b\n#endif\n\n#if defined(PERL_IN_PP_SYS_C)\ns\t|OP*\t|doform\t\t|NN CV *cv|NN GV *gv|NULLOK OP *retop\n#  if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)\nsR\t|int\t|dooneliner\t|NN const char *cmd|NN const char *filename\n#  endif\ns\t|SV *\t|space_join_names_mortal|NULLOK char *const *array\n#endif\np\t|OP *\t|tied_method|NN SV *methname|NN SV **sp \\\n\t\t\t\t|NN SV *const sv|NN const MAGIC *const mg \\\n\t\t\t\t|const U32 flags|U32 argc|...\n\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)\nEp\t|void\t|regprop\t|NULLOK const regexp *prog|NN SV* sv|NN const regnode* o|NULLOK const regmatch_info *reginfo \\\n\t\t\t\t|NULLOK const RExC_state_t *pRExC_state\nEp\t|int\t|re_printf\t|NN const char *fmt|...\n#endif\n#if defined(PERL_IN_REGCOMP_C)\nEs\t|regnode_offset|reg\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|I32 paren|NN I32 *flagp|U32 depth\nEs\t|regnode_offset|regnode_guts|NN RExC_state_t *pRExC_state          \\\n\t\t\t\t|const U8 op\t\t\t\t   \\\n\t\t\t\t|const STRLEN extra_len\t\t\t   \\\n\t\t\t\t|NN const char* const name\nEs\t|void\t|change_engine_size|NN RExC_state_t *pRExC_state|const Ptrdiff_t size\nEs\t|regnode_offset|reganode|NN RExC_state_t *pRExC_state|U8 op \\\n\t\t\t\t|U32 arg\nEs\t|regnode_offset|reg2Lanode|NN RExC_state_t *pRExC_state\t\t   \\\n\t\t\t\t|const U8 op\t\t\t\t   \\\n\t\t\t\t|const U32 arg1\t\t\t\t   \\\n\t\t\t\t|const I32 arg2\nEs\t|regnode_offset|regatom\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN I32 *flagp|U32 depth\nEs\t|regnode_offset|regbranch\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN I32 *flagp|I32 first|U32 depth\nEs\t|void\t |set_ANYOF_arg\t|NN RExC_state_t* const pRExC_state \\\n\t\t\t\t|NN regnode* const node                    \\\n\t\t\t\t|NULLOK SV* const cp_list                  \\\n\t\t\t\t|NULLOK SV* const runtime_defns\t\t   \\\n\t\t\t\t|NULLOK SV* const only_utf8_locale_list\nEs\t|void\t|output_posix_warnings\t\t\t\t\t    \\\n\t\t\t\t|NN RExC_state_t *pRExC_state\t\t    \\\n\t\t\t\t|NN AV* posix_warnings\nEs\t|AV*\t |add_multi_match|NULLOK AV* multi_char_matches\t\t    \\\n\t\t\t\t|NN SV* multi_string\t\t\t    \\\n\t\t\t\t|const STRLEN cp_count\nEs\t|regnode_offset|regclass|NN RExC_state_t *pRExC_state                 \\\n\t\t\t\t|NN I32 *flagp|U32 depth|const bool stop_at_1 \\\n\t\t\t\t|bool allow_multi_fold                        \\\n\t\t\t\t|const bool silence_non_portable              \\\n\t\t\t\t|const bool strict                            \\\n\t\t\t\t|bool optimizable\t\t\t      \\\n\t\t\t\t|NULLOK SV** ret_invlist\nEs\t|void|add_above_Latin1_folds|NN RExC_state_t *pRExC_state|const U8 cp \\\n\t\t\t\t|NN SV** invlist\nEi\t|regnode_offset|handle_named_backref|NN RExC_state_t *pRExC_state   \\\n\t\t\t\t|NN I32 *flagp\t\t\t\t    \\\n\t\t\t\t|NN char * parse_start\t\t\t    \\\n\t\t\t\t|char ch\nEsnR\t|unsigned int|regex_set_precedence|const U8 my_operator\nEs\t|regnode_offset|handle_regex_sets|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NULLOK SV ** return_invlist            \\\n\t\t\t\t|NN I32 *flagp|U32 depth                \\\n\t\t\t\t|NN char * const oregcomp_parse\nEs\t|void\t|set_regex_pv\t|NN RExC_state_t *pRExC_state|NN REGEXP *Rx\n#if defined(DEBUGGING) && defined(ENABLE_REGEX_SETS_DEBUGGING)\nEs\t|void\t|dump_regex_sets_structures\t\t\t\t    \\\n\t\t\t\t|NN RExC_state_t *pRExC_state\t\t    \\\n\t\t\t\t|NN AV * stack\t\t\t\t    \\\n\t\t\t\t|const IV fence|NN AV * fence_stack\n#endif\nEs\t|void|parse_lparen_question_flags|NN RExC_state_t *pRExC_state\nEs\t|regnode_offset|reg_node|NN RExC_state_t *pRExC_state|U8 op\nEs\t|regnode_offset|regpiece|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN I32 *flagp|U32 depth\nEs\t|bool\t|grok_bslash_N\t|NN RExC_state_t *pRExC_state\t\t    \\\n\t\t\t\t|NULLOK regnode_offset* nodep\t\t    \\\n\t\t\t\t|NULLOK UV *code_point_p\t\t    \\\n\t\t\t\t|NULLOK int* cp_count\t\t\t    \\\n\t\t\t\t|NN I32 *flagp\t\t\t\t    \\\n\t\t\t\t|const bool strict\t\t\t    \\\n\t\t\t\t|const U32 depth\nEs\t|void\t|reginsert\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|const U8 op\t\t\t\t    \\\n\t\t\t\t|const regnode_offset operand\t\t    \\\n\t\t\t\t|const U32 depth\nEsR\t|bool\t|regtail\t|NN RExC_state_t * pRExC_state\t\t    \\\n\t\t\t\t|NN const regnode_offset p\t\t    \\\n\t\t\t\t|NN const regnode_offset val\t\t    \\\n\t\t\t\t|const U32 depth\nEs\t|SV *\t|reg_scan_name\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|U32 flags\nEs\t|U32\t|join_exact\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode *scan|NN UV *min_subtract  \\\n\t\t\t\t|NN bool *unfolded_multi_char          \\\n\t\t\t\t|U32 flags|NULLOK regnode *val|U32 depth\nEin\t|U8   |compute_EXACTish|NN RExC_state_t *pRExC_state\nEs\t|void\t|nextchar\t|NN RExC_state_t *pRExC_state\nEs\t|void\t|skip_to_be_ignored_text|NN RExC_state_t *pRExC_state  \\\n\t\t\t\t|NN char ** p\t\t\t    \\\n\t\t\t\t|const bool force_to_xmod\nEin\t|char *\t|reg_skipcomment|NN RExC_state_t *pRExC_state|NN char * p\nEs\t|void\t|scan_commit\t|NN const RExC_state_t *pRExC_state \\\n\t\t\t\t|NN struct scan_data_t *data        \\\n\t\t\t\t|NN SSize_t *minlenp\t\t    \\\n\t\t\t\t|int is_inf\nEs\t|void\t|populate_ANYOF_from_invlist|NN regnode *node|NN SV** invlist_ptr\nEs\t|void\t|ssc_anything\t|NN regnode_ssc *ssc\nEsRn\t|int\t|ssc_is_anything|NN const regnode_ssc *ssc\nEs\t|void\t|ssc_init\t|NN const RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode_ssc *ssc\nEsRn\t|int\t|ssc_is_cp_posixl_init|NN const RExC_state_t *pRExC_state \\\n\t\t\t\t|NN const regnode_ssc *ssc\nEs\t|void\t|ssc_and\t|NN const RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode_ssc *ssc                \\\n\t\t\t\t|NN const regnode_charclass *and_with\nEs\t|void\t|ssc_or\t\t|NN const RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode_ssc *ssc \\\n\t\t\t\t|NN const regnode_charclass *or_with\nEs\t|SV*\t|get_ANYOF_cp_list_for_ssc                                 \\\n\t\t\t\t|NN const RExC_state_t *pRExC_state \\\n\t\t\t\t|NN const regnode_charclass* const node\nEi\t|void\t|ssc_intersection|NN regnode_ssc *ssc \\\n\t\t\t\t|NN SV* const invlist|const bool invert_2nd\nEi\t|void\t|ssc_union\t|NN regnode_ssc *ssc \\\n\t\t\t\t|NN SV* const invlist|const bool invert_2nd\nEi\t|void\t|ssc_add_range\t|NN regnode_ssc *ssc \\\n\t\t\t\t|UV const start|UV const end\nEi\t|void\t|ssc_cp_and\t|NN regnode_ssc *ssc \\\n\t\t\t\t|UV const cp\nEin\t|void\t|ssc_clear_locale|NN regnode_ssc *ssc\nEns\t|bool\t|is_ssc_worth_it|NN const RExC_state_t * pRExC_state \\\n\t\t\t\t|NN const regnode_ssc * ssc\nEs\t|void\t|ssc_finalize\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode_ssc *ssc\nEs\t|SSize_t|study_chunk\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode **scanp|NN SSize_t *minlenp \\\n\t\t\t\t|NN SSize_t *deltap|NN regnode *last \\\n\t\t\t\t|NULLOK struct scan_data_t *data \\\n                                |I32 stopparen|U32 recursed_depth \\\n\t\t\t\t|NULLOK regnode_ssc *and_withp \\\n\t\t\t\t|U32 flags|U32 depth\nEs\t|void\t|rck_elide_nothing|NN regnode *node\nEsR\t|SV *\t|get_ANYOFM_contents|NN const regnode * n\nEsRn\t|U32\t|add_data\t|NN RExC_state_t* const pRExC_state \\\n\t\t\t\t|NN const char* const s|const U32 n\nrs\t|void\t|re_croak2\t|bool utf8|NN const char* pat1|NN const char* pat2|...\nEs\t|int\t|handle_possible_posix\t\t\t\t\t    \\\n\t\t\t\t|NN RExC_state_t *pRExC_state\t\t    \\\n\t\t\t\t|NN const char* const s\t\t\t    \\\n\t\t\t\t|NULLOK char ** updated_parse_ptr\t    \\\n\t\t\t\t|NULLOK AV** posix_warnings\t\t    \\\n\t\t\t\t|const bool check_only\nEs\t|I32\t|make_trie\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode *startbranch|NN regnode *first \\\n\t\t\t\t|NN regnode *last|NN regnode *tail \\\n\t\t\t\t|U32 word_count|U32 flags|U32 depth\nEs\t|regnode *|construct_ahocorasick_from_trie|NN RExC_state_t *pRExC_state \\\n                                |NN regnode *source|U32 depth\nEnsR\t|const char *|cntrl_to_mnemonic|const U8 c\nEnsR\t|int\t|edit_distance\t|NN const UV *src\t\t    \\\n\t\t\t\t|NN const UV *tgt\t\t    \\\n\t\t\t\t|const STRLEN x\t\t\t    \\\n\t\t\t\t|const STRLEN y\t\t\t    \\\n\t\t\t\t|const SSize_t maxDistance\nEpX\t|SV *\t|parse_uniprop_string|NN const char * const name\t    \\\n\t\t\t\t     |const Size_t name_len\t\t    \\\n\t\t\t\t     |const bool is_utf8\t\t    \\\n\t\t\t\t     |const bool to_fold\t\t    \\\n\t\t\t\t     |const bool runtime\t\t    \\\n\t\t\t\t     |const bool deferrable\t\t    \\\n\t\t\t\t     |NN bool * user_defined_ptr\t    \\\n\t\t\t\t     |NN SV * msg\t\t\t    \\\n\t\t\t\t     |const STRLEN level\nEXp\t|SV *\t|handle_user_defined_property|NN const char * name\t    \\\n\t\t\t\t\t     |const STRLEN name_len\t    \\\n\t\t\t\t\t     |const bool is_utf8\t    \\\n\t\t\t\t\t     |const bool to_fold\t    \\\n\t\t\t\t\t     |const bool runtime\t    \\\n\t\t\t\t\t     |const bool deferrable\t    \\\n\t\t\t\t\t     |NN SV* contents\t\t    \\\n\t\t\t\t\t     |NN bool *user_defined_ptr\t    \\\n\t\t\t\t\t     |NN SV * msg\t\t    \\\n\t\t\t\t\t     |const STRLEN level\n#  ifdef DEBUGGING\nEp\t|int\t|re_indentf\t|NN const char *fmt|U32 depth|...\nEs\t|void        |regdump_intflags|NULLOK const char *lead| const U32 flags\nEs\t|void\t|regdump_extflags|NULLOK const char *lead| const U32 flags\nEs\t|const regnode*|dumpuntil|NN const regexp *r|NN const regnode *start \\\n\t\t\t\t|NN const regnode *node \\\n\t\t\t\t|NULLOK const regnode *last \\\n\t\t\t\t|NULLOK const regnode *plast \\\n\t\t\t\t|NN SV* sv|I32 indent|U32 depth\nEs\t|void\t|put_code_point\t|NN SV* sv|UV c\nEs\t|bool\t|put_charclass_bitmap_innards|NN SV* sv\t\t    \\\n\t\t\t\t|NULLOK char* bitmap\t\t    \\\n\t\t\t\t|NULLOK SV* nonbitmap_invlist\t    \\\n\t\t\t\t|NULLOK SV* only_utf8_locale_invlist\\\n\t\t\t\t|NULLOK const regnode * const node  \\\n\t\t\t\t|const bool force_as_is_display\nEs\t|SV*\t|put_charclass_bitmap_innards_common\t\t    \\\n\t\t\t\t|NN SV* invlist\t\t\t    \\\n\t\t\t\t|NULLOK SV* posixes\t\t    \\\n\t\t\t\t|NULLOK SV* only_utf8\t\t    \\\n\t\t\t\t|NULLOK SV* not_utf8\t\t    \\\n\t\t\t\t|NULLOK SV* only_utf8_locale\t    \\\n\t\t\t\t|const bool invert\nEs\t|void\t|put_charclass_bitmap_innards_invlist\t\t    \\\n\t\t\t\t|NN SV *sv\t\t\t    \\\n\t\t\t\t|NN SV* invlist\nEs\t|void\t|put_range\t|NN SV* sv|UV start|const UV end    \\\n\t\t\t\t|const bool allow_literals\nEs\t|void\t|dump_trie\t|NN const struct _reg_trie_data *trie\\\n\t\t\t\t|NULLOK HV* widecharmap|NN AV *revcharmap\\\n\t\t\t\t|U32 depth\nEs\t|void\t|dump_trie_interim_list|NN const struct _reg_trie_data *trie\\\n\t\t\t\t|NULLOK HV* widecharmap|NN AV *revcharmap\\\n\t\t\t\t|U32 next_alloc|U32 depth\nEs\t|void\t|dump_trie_interim_table|NN const struct _reg_trie_data *trie\\\n\t\t\t\t|NULLOK HV* widecharmap|NN AV *revcharmap\\\n\t\t\t\t|U32 next_alloc|U32 depth\nEsR\t|bool\t|regtail_study\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode_offset p|NN const regnode_offset val|U32 depth\n#  endif\n#endif\n\n#if defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C)\nEXRpM\t|bool\t|isFOO_lc\t|const U8 classnum|const U8 character\n#endif\n\n#if defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_TOKE_C)\nERp\t|bool\t|_is_grapheme\t|NN const U8 * strbeg|NN const U8 * s|NN const U8 *strend|const UV cp\n#endif\n\n#if defined(PERL_IN_REGEXEC_C)\nERs\t|bool\t|isFOO_utf8_lc\t|const U8 classnum|NN const U8* character|NN const U8* e\nERns\t|U8 *\t|find_next_masked|NN U8 * s\t\t\t\t\\\n\t\t\t\t |NN const U8 * send\t\t\t\\\n\t\t\t\t |const U8 byte|const U8 mask\nERns\t|U8 *|find_span_end\t|NN U8* s|NN const U8 * send|const U8 span_byte\nERns\t|U8 *|find_span_end_mask|NN U8 * s|NN const U8 * send\t\\\n\t\t\t\t|const U8 span_byte|const U8 mask\nERs\t|SSize_t|regmatch\t|NN regmatch_info *reginfo|NN char *startpos|NN regnode *prog\nWERs\t|I32\t|regrepeat\t|NN regexp *prog|NN char **startposp \\\n\t\t\t\t|NN const regnode *p \\\n\t\t\t\t|NN char *loceol\t\t\\\n\t\t\t\t|NN regmatch_info *const reginfo \\\n\t\t\t\t|I32 max\nERs\t|bool\t|regtry\t\t|NN regmatch_info *reginfo|NN char **startposp\nERs\t|bool\t|reginclass\t|NULLOK regexp * const prog  \\\n\t\t\t\t|NN const regnode * const n  \\\n\t\t\t\t|NN const U8 * const p       \\\n\t\t\t\t|NN const U8 * const p_end   \\\n\t\t\t\t|bool const utf8_target\nWEs\t|CHECKPOINT|regcppush\t|NN const regexp *rex|I32 parenfloor\\\n\t\t\t\t|U32 maxopenparen\nWEs\t|void\t|regcppop\t|NN regexp *rex|NN U32 *maxopenparen_p\nWEs\t|void\t|regcp_restore\t|NN regexp *rex|I32 ix|NN U32 *maxopenparen_p\nERsn\t|U8*\t|reghop3\t|NN U8 *s|SSize_t off|NN const U8 *lim\nERsn\t|U8*\t|reghop4\t|NN U8 *s|SSize_t off|NN const U8 *llim \\\n\t\t\t\t|NN const U8 *rlim\nERsn\t|U8*\t|reghopmaybe3\t|NN U8 *s|SSize_t off|NN const U8 * const lim\nERs\t|char*\t|find_byclass\t|NN regexp * prog|NN const regnode *c \\\n\t\t\t\t|NN char *s|NN const char *strend \\\n\t\t\t\t|NULLOK regmatch_info *reginfo\nEs\t|void\t|to_utf8_substr\t|NN regexp * prog\nEs\t|bool\t|to_byte_substr\t|NN regexp * prog\nERsn\t|I32\t|reg_check_named_buff_matched\t|NN const regexp *rex \\\n\t\t\t\t\t\t|NN const regnode *scan\nEsR\t|bool\t|isGCB\t\t|const GCB_enum before\t\t\t\\\n\t\t\t\t|const GCB_enum after\t\t\t\\\n\t\t\t\t|NN const U8 * const strbeg\t\t\\\n\t\t\t\t|NN const U8 * const curpos\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|GCB_enum|backup_one_GCB|NN const U8 * const strbeg\t\t\t\\\n\t\t\t\t|NN U8 ** curpos\t\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|bool\t|isLB\t\t|LB_enum before\t\t\t\t\\\n\t\t\t\t|LB_enum after\t\t\t\t\\\n\t\t\t\t|NN const U8 * const strbeg\t\t\\\n\t\t\t\t|NN const U8 * const curpos\t\t\\\n\t\t\t\t|NN const U8 * const strend\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|LB_enum|advance_one_LB |NN U8 ** curpos\t\t\t\t\\\n\t\t\t\t|NN const U8 * const strend\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|LB_enum|backup_one_LB  |NN const U8 * const strbeg\t\t\t\\\n\t\t\t\t|NN U8 ** curpos\t\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|bool\t|isSB\t\t|SB_enum before\t\t\t\t\\\n\t\t\t\t|SB_enum after\t\t\t\t\\\n\t\t\t\t|NN const U8 * const strbeg\t\t\t\\\n\t\t\t\t|NN const U8 * const curpos\t\t\t\\\n\t\t\t\t|NN const U8 * const strend\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|SB_enum|advance_one_SB |NN U8 ** curpos\t\t\t\t\\\n\t\t\t\t|NN const U8 * const strend\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|SB_enum|backup_one_SB  |NN const U8 * const strbeg\t\t\t\\\n\t\t\t\t|NN U8 ** curpos\t\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|bool\t|isWB\t\t|WB_enum previous\t\t\t\t\\\n\t\t\t\t|WB_enum before\t\t\t\t\\\n\t\t\t\t|WB_enum after\t\t\t\t\\\n\t\t\t\t|NN const U8 * const strbeg\t\t\t\\\n\t\t\t\t|NN const U8 * const curpos\t\t\t\\\n\t\t\t\t|NN const U8 * const strend\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|WB_enum|advance_one_WB |NN U8 ** curpos\t\t\t\t\\\n\t\t\t\t|NN const U8 * const strend\t\t\t\\\n\t\t\t\t|const bool utf8_target\t\t\t\t\\\n\t\t\t\t|const bool skip_Extend_Format\nEsR\t|WB_enum|backup_one_WB  |NN WB_enum * previous\t\t\t\\\n\t\t\t\t|NN const U8 * const strbeg\t\t\t\\\n\t\t\t\t|NN U8 ** curpos\t\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEin\t|I32\t|foldEQ_latin1_s2_folded|NN const char* a|NN const char* b|I32 len\n#  ifdef DEBUGGING\nEs\t|void\t|dump_exec_pos\t|NN const char *locinput|NN const regnode *scan|NN const char *loc_regeol\\\n\t\t\t\t|NN const char *loc_bostr|NN const char *loc_reg_starttry|const bool do_utf8|const U32 depth\nEs\t|void\t|debug_start_match|NN const REGEXP *prog|const bool do_utf8\\\n\t\t\t\t|NN const char *start|NN const char *end\\\n\t\t\t\t|NN const char *blurb\n\nEp\t|int\t|re_exec_indentf\t|NN const char *fmt|U32 depth|...\n#  endif\n#endif\n\n#if defined(PERL_IN_DUMP_C)\ns\t|CV*\t|deb_curcv\t|I32 ix\ns\t|void\t|debprof\t|NN const OP *o\ns\t|UV\t|sequence_num\t|NULLOK const OP *o\ns\t|SV*\t|pm_description\t|NN const PMOP *pm\n#endif\n\n#if defined(PERL_IN_SCOPE_C)\ns\t|SV*\t|save_scalar_at\t|NN SV **sptr|const U32 flags\n#endif\n\n#if defined(PERL_IN_GV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_PAD_C) || defined(PERL_IN_OP_C)\n: Used in gv.c\npo\t|void\t|sv_add_backref\t|NN SV *const tsv|NN SV *const sv\n#endif\n\n#if defined(PERL_IN_HV_C) || defined(PERL_IN_MG_C) || defined(PERL_IN_SV_C)\n: Used in hv.c and mg.c\npoM\t|void\t|sv_kill_backrefs\t|NN SV *const sv|NULLOK AV *const av\n#endif\n\n#if defined(PERL_IN_SV_C) || defined (PERL_IN_OP_C)\npR\t|SV *\t|varname\t|NULLOK const GV *const gv|const char gvtype \\\n\t\t\t\t|PADOFFSET targ|NULLOK const SV *const keyname \\\n\t\t\t\t|SSize_t aindex|int subscript_type\n#endif\n\npX\t|void\t|sv_del_backref\t|NN SV *const tsv|NN SV *const sv\n#if defined(PERL_IN_SV_C)\nniR\t|char *\t|uiv_2buf\t|NN char *const buf|const IV iv|UV uv|const int is_uv|NN char **const peob\ni\t|void\t|sv_unglob\t|NN SV *const sv|U32 flags\ns\t|const char *|sv_display\t|NN SV *const sv|NN char *tmpbuf|STRLEN tmpbuf_size\ns\t|void\t|not_a_number\t|NN SV *const sv\ns\t|void\t|not_incrementable\t|NN SV *const sv\ns\t|I32\t|visit\t\t|NN SVFUNC_t f|const U32 flags|const U32 mask\n#  ifdef DEBUGGING\ns\t|void\t|del_sv\t|NN SV *p\n#  endif\n#  if !defined(NV_PRESERVES_UV)\n#    ifdef DEBUGGING\ns\t|int\t|sv_2iuv_non_preserve\t|NN SV *const sv|I32 numtype\n#    else\ns\t|int\t|sv_2iuv_non_preserve\t|NN SV *const sv\n#    endif\n#  endif\nsR\t|STRLEN\t|expect_number\t|NN const char **const pattern\nsn\t|STRLEN\t|sv_pos_u2b_forwards|NN const U8 *const start \\\n\t\t|NN const U8 *const send|NN STRLEN *const uoffset \\\n\t\t|NN bool *const at_end\nsn\t|STRLEN\t|sv_pos_u2b_midway|NN const U8 *const start \\\n\t\t|NN const U8 *send|STRLEN uoffset|const STRLEN uend\ns\t|STRLEN\t|sv_pos_u2b_cached|NN SV *const sv|NN MAGIC **const mgp \\\n\t\t|NN const U8 *const start|NN const U8 *const send \\\n\t\t|STRLEN uoffset|STRLEN uoffset0|STRLEN boffset0\ns\t|void\t|utf8_mg_len_cache_update|NN SV *const sv|NN MAGIC **const mgp \\\n\t\t|const STRLEN ulen\ns\t|void\t|utf8_mg_pos_cache_update|NN SV *const sv|NN MAGIC **const mgp \\\n\t\t|const STRLEN byte|const STRLEN utf8|const STRLEN blen\ns\t|STRLEN\t|sv_pos_b2u_midway|NN const U8 *const s|NN const U8 *const target \\\n\t\t|NN const U8 *end|STRLEN endu\ns\t|void\t|assert_uft8_cache_coherent|NN const char *const func \\\n\t\t|STRLEN from_cache|STRLEN real|NN SV *const sv\nsn\t|char *\t|F0convert\t|NV nv|NN char *const endbuf|NN STRLEN *const len\ns\t|SV *\t|more_sv\ns\t|bool\t|sv_2iuv_common\t|NN SV *const sv\ns\t|void\t|glob_assign_glob|NN SV *const dstr|NN SV *const sstr \\\n\t\t|const int dtype\nsRn\t|PTR_TBL_ENT_t *|ptr_table_find|NN PTR_TBL_t *const tbl|NULLOK const void *const sv\ns\t|void\t|anonymise_cv_maybe\t|NN GV *gv|NN CV *cv\n#endif\n\n: Used in sv.c and hv.c\npo\t|void *\t|more_bodies\t|const svtype sv_type|const size_t body_size \\\n\t\t\t\t|const size_t arena_size\nEXpR\t|SV*\t|get_and_check_backslash_N_name|NN const char* s\t\\\n\t\t\t\t|NN const char* const e\t\t\t\\\n\t\t\t\t|const bool is_utf8\t\t\t\\\n\t\t\t\t|NN const char** error_msg\n\n: For use ONLY in B::Hooks::Parser, by special dispensation\nEXpMR\t|char*\t|scan_str\t|NN char *start|int keep_quoted \\\n\t\t\t\t|int keep_delims|int re_reparse \\\n\t\t\t\t|NULLOK char **delimp\nEXpM\t|char*\t|scan_word\t|NN char *s|NN char *dest|STRLEN destlen \\\n\t\t\t\t|int allow_package|NN STRLEN *slp\nEXpMR\t|char*\t|skipspace_flags|NN char *s|U32 flags\n#if defined(PERL_IN_TOKE_C)\ns\t|void\t|check_uni\ns\t|void\t|force_next\t|I32 type\ns\t|char*\t|force_version\t|NN char *s|int guessing\ns\t|char*\t|force_strict_version\t|NN char *s\ns\t|char*\t|force_word\t|NN char *start|int token|int check_keyword \\\n\t\t\t\t|int allow_pack\ns\t|SV*\t|tokeq\t\t|NN SV *sv\nsR\t|char*\t|scan_const\t|NN char *start\nsR\t|SV*\t|get_and_check_backslash_N_name_wrapper|NN const char* s \\\n\t\t\t\t|NN const char* const e\nsR\t|char*\t|scan_formline\t|NN char *s\nsR\t|char*\t|scan_heredoc\t|NN char *s\ns\t|char*\t|scan_ident\t|NN char *s|NN char *dest\t\\\n\t\t\t\t|STRLEN destlen|I32 ck_uni\nsR\t|char*\t|scan_inputsymbol|NN char *start\nsR\t|char*\t|scan_pat\t|NN char *start|I32 type\nsR\t|char*\t|scan_subst\t|NN char *start\nsR\t|char*\t|scan_trans\t|NN char *start\ns\t|void\t|update_debugger_info|NULLOK SV *orig_sv \\\n\t\t\t\t|NULLOK const char *const buf|STRLEN len\nsR\t|char*\t|swallow_bom\t|NN U8 *s\n#ifndef PERL_NO_UTF16_FILTER\ns\t|I32\t|utf16_textfilter|int idx|NN SV *sv|int maxlen\ns\t|U8*\t|add_utf16_textfilter|NN U8 *const s|bool reversed\n#endif\ns\t|void\t|checkcomma\t|NN const char *s|NN const char *name \\\n\t\t\t\t|NN const char *what\ns\t|void\t|force_ident\t|NN const char *s|int kind\ns\t|void\t|force_ident_maybe_lex|char pit\ns\t|void\t|incline\t|NN const char *s|NN const char *end\ns\t|int\t|intuit_method\t|NN char *s|NULLOK SV *ioname|NULLOK CV *cv\ns\t|int\t|intuit_more\t|NN char *s|NN char *e\ns\t|I32\t|lop\t\t|I32 f|U8 x|NN char *s\nrs\t|void\t|missingterm\t|NULLOK char *s|STRLEN len\ns\t|void\t|no_op\t\t|NN const char *const what|NULLOK char *s\ns\t|int\t|pending_ident\nsR\t|I32\t|sublex_done\nsR\t|I32\t|sublex_push\nsR\t|I32\t|sublex_start\nsR\t|char *\t|filter_gets\t|NN SV *sv|STRLEN append\nsR\t|HV *\t|find_in_my_stash|NN const char *pkgname|STRLEN len\nsR\t|char *\t|tokenize_use\t|int is_use|NN char *s\nso\t|SV*\t|new_constant\t|NULLOK const char *s|STRLEN len\t    \\\n\t\t\t\t|NN const char *key|STRLEN keylen|NN SV *sv \\\n\t\t\t\t|NULLOK SV *pv|NULLOK const char *type\t    \\\n\t\t\t\t|STRLEN typelen\t\t\t\t    \\\n\t\t\t\t|NULLOK const char ** error_msg\ns\t|int\t|ao\t\t|int toketype\ns\t|void|parse_ident|NN char **s|NN char **d \\\n                     |NN char * const e|int allow_package \\\n\t\t\t\t|bool is_utf8|bool check_dollar \\\n\t\t\t\t|bool tick_warn\n#  if defined(PERL_CR_FILTER)\ns\t|I32\t|cr_textfilter\t|int idx|NULLOK SV *sv|int maxlen\ns\t|void\t|strip_return\t|NN SV *sv\n#  endif\n#  if defined(DEBUGGING)\ns\t|int\t|tokereport\t|I32 rv|NN const YYSTYPE* lvalp\nsf\t|void\t|printbuf\t|NN const char *const fmt|NN const char *const s\n#  endif\n#endif\nEXMp\t|bool\t|validate_proto\t|NN SV *name|NULLOK SV *proto|bool warn \\\n\t\t|bool curstash\n\n#if defined(PERL_IN_UNIVERSAL_C)\ns\t|bool\t|isa_lookup\t|NN HV *stash|NN const char * const name \\\n                                        |STRLEN len|U32 flags\n#endif\n\n#if defined(PERL_IN_LOCALE_C)\n#  ifdef USE_LOCALE\nsn\t|const char*|category_name |const int category\ns\t|const char*|switch_category_locale_to_template|const int switch_category|const int template_category|NULLOK const char * template_locale\ns\t|void\t|restore_switched_locale|const int category|NULLOK const char * const original_locale\n#  endif\n#  ifdef HAS_NL_LANGINFO\nsn\t|const char*|my_nl_langinfo|const nl_item item|bool toggle\n#  else\nsn\t|const char*|my_nl_langinfo|const int item|bool toggle\n#  endif\ninR\t|const char *|save_to_buffer|NULLOK const char * string\t\\\n\t\t\t\t    |NULLOK char **buf\t\t\\\n\t\t\t\t    |NN Size_t *buf_size\t\\\n\t\t\t\t    |const Size_t offset\n#  if defined(USE_LOCALE)\ns\t|char*\t|stdize_locale\t|NN char* locs\ns\t|void\t|new_collate\t|NULLOK const char* newcoll\ns\t|void\t|new_ctype\t|NN const char* newctype\ns\t|void\t|set_numeric_radix|const bool use_locale\ns\t|void\t|new_numeric\t|NULLOK const char* newnum\n#    ifdef USE_POSIX_2008_LOCALE\nsn\t|const char*|emulate_setlocale|const int category\t\t\\\n\t\t\t\t    |NULLOK const char* locale\t\t\\\n\t\t\t\t    |unsigned int index\t\t\t\\\n\t\t\t\t    |const bool is_index_valid\n#    endif\n#    ifdef WIN32\ns\t|char*\t|win32_setlocale|int category|NULLOK const char* locale\n#    endif\n#    ifdef DEBUGGING\ns\t|void\t|print_collxfrm_input_and_return\t\t\\\n\t\t\t    |NN const char * const s\t\t\\\n\t\t\t    |NN const char * const e\t\t\\\n\t\t\t    |NULLOK const STRLEN * const xlen\t\\\n\t\t\t    |const bool is_utf8\ns\t|void\t|print_bytes_for_locale\t|NN const char * const s\t\\\n\t\t\t\t\t|NN const char * const e\t\\\n\t\t\t\t\t|const bool is_utf8\nsnR\t|char *\t|setlocale_debug_string\t|const int category\t\t    \\\n\t\t\t\t\t|NULLOK const char* const locale    \\\n\t\t\t\t\t|NULLOK const char* const retval\n#    endif\n#  endif\n#endif\n\n#if        defined(USE_LOCALE)\t\t\\\n    && (   defined(PERL_IN_LOCALE_C)\t\\\n        || defined(PERL_IN_MG_C)\t\\\n\t|| defined (PERL_EXT_POSIX)\t\\\n\t|| defined (PERL_EXT_LANGINFO))\nApM\t|bool\t|_is_cur_LC_category_utf8|int category\n#endif\n\n\n#if defined(PERL_IN_UTIL_C)\ns\t|SV*\t|mess_alloc\ns\t|SV *\t|with_queued_errors|NN SV *ex\ns\t|bool\t|invoke_exception_hook|NULLOK SV *ex|bool warn\n#if defined(PERL_MEM_LOG) && !defined(PERL_MEM_LOG_NOIMPL)\nsn\t|void\t|mem_log_common\t|enum mem_log_type mlt|const UV n|const UV typesize \\\n\t\t\t\t|NN const char *type_name|NULLOK const SV *sv \\\n\t\t\t\t|Malloc_t oldalloc|Malloc_t newalloc \\\n\t\t\t\t|NN const char *filename|const int linenumber \\\n\t\t\t\t|NN const char *funcname\n#endif\n#endif\n\n#if defined(PERL_MEM_LOG)\npn\t|Malloc_t\t|mem_log_alloc\t|const UV nconst|UV typesize|NN const char *type_name|Malloc_t newalloc|NN const char *filename|const int linenumber|NN const char *funcname\npn\t|Malloc_t\t|mem_log_realloc\t|const UV n|const UV typesize|NN const char *type_name|Malloc_t oldalloc|Malloc_t newalloc|NN const char *filename|const int linenumber|NN const char *funcname\npn\t|Malloc_t\t|mem_log_free\t|Malloc_t oldalloc|NN const char *filename|const int linenumber|NN const char *funcname\n#endif\n\n#if defined(PERL_IN_UTF8_C)\nsR\t|HV *\t|new_msg_hv |NN const char * const message\t\t    \\\n\t\t\t    |U32 categories\t\t\t\t    \\\n\t\t\t    |U32 flag\nsRM\t|UV\t|check_locale_boundary_crossing\t\t\t\t    \\\n\t\t|NN const U8* const p\t\t\t\t\t    \\\n\t\t|const UV result\t\t\t\t\t    \\\n\t\t|NN U8* const ustrp\t\t\t\t\t    \\\n\t\t|NN STRLEN *lenp\niR\t|bool\t|is_utf8_common\t|NN const U8 *const p\t\t\t    \\\n\t\t\t\t|NULLOK SV* const invlist\niR\t|bool\t|is_utf8_common_with_len|NN const U8 *const p\t\t    \\\n\t\t\t\t\t|NN const U8 *const e\t\t    \\\n\t\t\t\t\t|NULLOK SV* const invlist\nsR\t|SV*\t|swatch_get\t|NN SV* swash|UV start|UV span\nsRM\t|U8*\t|swash_scan_list_line|NN U8* l|NN U8* const lend|NN UV* min \\\n\t\t|NN UV* max|NN UV* val|const bool wants_value\t\t    \\\n\t\t|NN const U8* const typestr\n#endif\n\nEXiMn\t|void\t|append_utf8_from_native_byte|const U8 byte|NN U8** dest\n\nApd\t|void\t|sv_set_undef\t|NN SV *sv\nApd\t|void\t|sv_setsv_flags\t|NN SV *dstr|NULLOK SV *sstr|const I32 flags\nApd\t|void\t|sv_catpvn_flags|NN SV *const dstr|NN const char *sstr|const STRLEN len \\\n\t\t\t\t|const I32 flags\nApd\t|void\t|sv_catpv_flags\t|NN SV *dstr|NN const char *sstr \\\n\t\t\t\t|const I32 flags\nApd\t|void\t|sv_catsv_flags\t|NN SV *const dsv|NULLOK SV *const ssv|const I32 flags\nApmd\t|STRLEN\t|sv_utf8_upgrade_flags|NN SV *const sv|const I32 flags\nAp\t|STRLEN\t|sv_utf8_upgrade_flags_grow|NN SV *const sv|const I32 flags|STRLEN extra\nApd\t|char*\t|sv_pvn_force_flags|NN SV *const sv|NULLOK STRLEN *const lp|const I32 flags\nApmb\t|void\t|sv_copypv\t|NN SV *const dsv|NN SV *const ssv\nApmd\t|void\t|sv_copypv_nomg\t|NN SV *const dsv|NN SV *const ssv\nApd\t|void\t|sv_copypv_flags\t|NN SV *const dsv|NN SV *const ssv|const I32 flags\nApo\t|char*\t|my_atof2\t|NN const char *orig|NN NV* value\nAp\t|char*\t|my_atof3\t|NN const char *orig|NN NV* value|const STRLEN len\nApn\t|int\t|my_socketpair\t|int family|int type|int protocol|int fd[2]\nApn\t|int\t|my_dirfd\t|NULLOK DIR* dir\n#ifdef PERL_ANY_COW\n: Used in pp_hot.c and regexec.c\npMXE\t|SV*\t|sv_setsv_cow\t|NULLOK SV* dstr|NN SV* sstr\n#endif\n\nAop\t|const char *|PerlIO_context_layers|NULLOK const char *mode\n\n#if defined(USE_PERLIO)\nAp\t|int\t|PerlIO_close\t\t|NULLOK PerlIO *f\nAp\t|int\t|PerlIO_fill\t\t|NULLOK PerlIO *f\nAp\t|int\t|PerlIO_fileno\t\t|NULLOK PerlIO *f\nAp\t|int\t|PerlIO_eof\t\t|NULLOK PerlIO *f\nAp\t|int\t|PerlIO_error\t\t|NULLOK PerlIO *f\nAp\t|int\t|PerlIO_flush\t\t|NULLOK PerlIO *f\nAp\t|void\t|PerlIO_clearerr\t|NULLOK PerlIO *f\nAp\t|void\t|PerlIO_set_cnt\t\t|NULLOK PerlIO *f|SSize_t cnt\nAp\t|void\t|PerlIO_set_ptrcnt\t|NULLOK PerlIO *f|NULLOK STDCHAR *ptr \\\n\t\t\t\t\t|SSize_t cnt\nAp\t|void\t|PerlIO_setlinebuf\t|NULLOK PerlIO *f\nAp\t|SSize_t|PerlIO_read\t\t|NULLOK PerlIO *f|NN void *vbuf \\\n\t\t\t\t\t|Size_t count\nAp\t|SSize_t|PerlIO_write\t\t|NULLOK PerlIO *f|NN const void *vbuf \\\n\t\t\t\t\t|Size_t count\nAp\t|SSize_t|PerlIO_unread\t\t|NULLOK PerlIO *f|NN const void *vbuf \\\n\t\t\t\t\t|Size_t count\nAp\t|Off_t\t|PerlIO_tell\t\t|NULLOK PerlIO *f\nAp\t|int\t|PerlIO_seek\t\t|NULLOK PerlIO *f|Off_t offset|int whence\nXp\t|void\t|PerlIO_save_errno\t|NULLOK PerlIO *f\nXp\t|void\t|PerlIO_restore_errno\t|NULLOK PerlIO *f\n\nAp\t|STDCHAR *|PerlIO_get_base\t|NULLOK PerlIO *f\nAp\t|STDCHAR *|PerlIO_get_ptr\t|NULLOK PerlIO *f\nApR\t|SSize_t\t  |PerlIO_get_bufsiz\t|NULLOK PerlIO *f\nApR\t|SSize_t\t  |PerlIO_get_cnt\t|NULLOK PerlIO *f\n\nApR\t|PerlIO *|PerlIO_stdin\nApR\t|PerlIO *|PerlIO_stdout\nApR\t|PerlIO *|PerlIO_stderr\n#endif /* USE_PERLIO */\n\n: Only used in dump.c\np\t|void\t|deb_stack_all\n#if defined(PERL_IN_DEB_C)\ns\t|void\t|deb_stack_n\t|NN SV** stack_base|I32 stack_min \\\n\t\t\t\t|I32 stack_max|I32 mark_min|I32 mark_max\n#endif\n\n: pad API\nApdR\t|PADLIST*|pad_new\t|int flags\n#ifdef DEBUGGING\npnX\t|void|set_padlist| NN CV * cv | NULLOK PADLIST * padlist\n#endif\n#if defined(PERL_IN_PAD_C)\ns\t|PADOFFSET|pad_alloc_name|NN PADNAME *name|U32 flags \\\n\t\t\t\t|NULLOK HV *typestash|NULLOK HV *ourstash\n#endif\nApd\t|PADOFFSET|pad_add_name_pvn|NN const char *namepv|STRLEN namelen\\\n\t\t\t\t|U32 flags|NULLOK HV *typestash\\\n\t\t\t\t|NULLOK HV *ourstash\nApd\t|PADOFFSET|pad_add_name_pv|NN const char *name\\\n\t\t\t\t|const U32 flags|NULLOK HV *typestash\\\n\t\t\t\t|NULLOK HV *ourstash\nApd\t|PADOFFSET|pad_add_name_sv|NN SV *name\\\n\t\t\t\t|U32 flags|NULLOK HV *typestash\\\n\t\t\t\t|NULLOK HV *ourstash\nAMpd\t|PADOFFSET|pad_alloc\t|I32 optype|U32 tmptype\nApd\t|PADOFFSET|pad_add_anon\t|NN CV* func|I32 optype\np\t|void\t|pad_add_weakref|NN CV* func\n#if defined(PERL_IN_PAD_C)\nsd\t|void\t|pad_check_dup\t|NN PADNAME *name|U32 flags \\\n\t\t\t\t|NULLOK const HV *ourstash\n#endif\nApd\t|PADOFFSET|pad_findmy_pvn|NN const char* namepv|STRLEN namelen|U32 flags\nApd\t|PADOFFSET|pad_findmy_pv|NN const char* name|U32 flags\nApd\t|PADOFFSET|pad_findmy_sv|NN SV* name|U32 flags\nApdD\t|PADOFFSET|find_rundefsvoffset\t|\nApd\t|SV*\t|find_rundefsv\t|\n#if defined(PERL_IN_PAD_C)\nsd\t|PADOFFSET|pad_findlex\t|NN const char *namepv|STRLEN namelen|U32 flags \\\n\t\t\t\t|NN const CV* cv|U32 seq|int warn \\\n\t\t\t\t|NULLOK SV** out_capture \\\n\t\t\t\t|NN PADNAME** out_name|NN int *out_flags\n#endif\n#ifdef DEBUGGING\nApd\t|SV*\t|pad_sv\t\t|PADOFFSET po\nApd\t|void\t|pad_setsv\t|PADOFFSET po|NN SV* sv\n#endif\npd\t|void\t|pad_block_start|int full\nApd\t|U32\t|intro_my\npd\t|OP *\t|pad_leavemy\npd\t|void\t|pad_swipe\t|PADOFFSET po|bool refadjust\n#if defined(PERL_IN_PAD_C)\nsd\t|void\t|pad_reset\n#endif\nAMpd\t|void\t|pad_tidy\t|padtidy_type type\npd\t|void\t|pad_free\t|PADOFFSET po\npd\t|void\t|do_dump_pad\t|I32 level|NN PerlIO *file|NULLOK PADLIST *padlist|int full\n#if defined(PERL_IN_PAD_C)\n#  if defined(DEBUGGING)\nsd\t|void\t|cv_dump\t|NN const CV *cv|NN const char *title\n#  endif\n#endif\nApd\t|CV*\t|cv_clone\t|NN CV* proto\np\t|CV*\t|cv_clone_into\t|NN CV* proto|NN CV *target\npd\t|void\t|pad_fixup_inner_anons|NN PADLIST *padlist|NN CV *old_cv|NN CV *new_cv\npdX\t|void\t|pad_push\t|NN PADLIST *padlist|int depth\nApbdR\t|HV*\t|pad_compname_type|const PADOFFSET po\nAMpdRn\t|PADNAME *|padnamelist_fetch|NN PADNAMELIST *pnl|SSize_t key\nXop\t|void\t|padnamelist_free|NN PADNAMELIST *pnl\nAMpd\t|PADNAME **|padnamelist_store|NN PADNAMELIST *pnl|SSize_t key \\\n\t\t\t\t     |NULLOK PADNAME *val\nXop\t|void\t|padname_free\t|NN PADNAME *pn\n#if defined(USE_ITHREADS)\npdR\t|PADNAME *|padname_dup\t|NN PADNAME *src|NN CLONE_PARAMS *param\npR\t|PADNAMELIST *|padnamelist_dup|NN PADNAMELIST *srcpad \\\n\t\t\t\t      |NN CLONE_PARAMS *param\npdR\t|PADLIST *|padlist_dup\t|NN PADLIST *srcpad \\\n\t\t\t\t|NN CLONE_PARAMS *param\n#endif\np\t|PAD **\t|padlist_store\t|NN PADLIST *padlist|I32 key \\\n\t\t\t\t|NULLOK PAD *val\n\nApdR\t|CV*\t|find_runcv\t|NULLOK U32 *db_seqp\npR\t|CV*\t|find_runcv_where|U8 cond|IV arg \\\n\t\t\t\t |NULLOK U32 *db_seqp\n: Only used in perl.c\np\t|void\t|free_tied_hv_pool\n#if defined(DEBUGGING)\n: Used in mg.c\npR\t|int\t|get_debug_opts\t|NN const char **s|bool givehelp\n#endif\nAp\t|void\t|save_set_svflags|NN SV *sv|U32 mask|U32 val\n#ifdef DEBUGGING\nApod\t|void\t|hv_assert\t|NN HV *hv\n#endif\n\nApdR\t|SV*\t|hv_scalar\t|NN HV *hv\np\t|void\t|hv_pushkv\t|NN HV *hv|U32 flags\nApdRM\t|SV*\t|hv_bucket_ratio|NN HV *hv\nApoR\t|I32*\t|hv_riter_p\t|NN HV *hv\nApoR\t|HE**\t|hv_eiter_p\t|NN HV *hv\nApo\t|void\t|hv_riter_set\t|NN HV *hv|I32 riter\nApo\t|void\t|hv_eiter_set\t|NN HV *hv|NULLOK HE *eiter\nAp\t|void   |hv_rand_set    |NN HV *hv|U32 new_xhv_rand\nAp\t|void\t|hv_name_set\t|NN HV *hv|NULLOK const char *name|U32 len|U32 flags\np\t|void\t|hv_ename_add\t|NN HV *hv|NN const char *name|U32 len \\\n\t\t\t\t|U32 flags\np\t|void\t|hv_ename_delete|NN HV *hv|NN const char *name|U32 len \\\n\t\t\t\t|U32 flags\n: Used in dump.c and hv.c\npoM\t|AV**\t|hv_backreferences_p\t|NN HV *hv\n#if defined(PERL_IN_DUMP_C) || defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_SCOPE_C)\npoM\t|void\t|hv_kill_backrefs\t|NN HV *hv\n#endif\nApd\t|void\t|hv_clear_placeholders\t|NN HV *hv\nXpoR\t|SSize_t*|hv_placeholders_p\t|NN HV *hv\nApoR\t|I32\t|hv_placeholders_get\t|NN const HV *hv\nApo\t|void\t|hv_placeholders_set\t|NN HV *hv|I32 ph\n\n: This is indirectly referenced by globals.c. This is somewhat annoying.\np\t|SV*\t|magic_scalarpack|NN HV *hv|NN MAGIC *mg\n\n#if defined(PERL_IN_SV_C)\ns\t|SV *\t|find_hash_subscript|NULLOK const HV *const hv \\\n\t\t|NN const SV *const val\ns\t|SSize_t|find_array_subscript|NULLOK const AV *const av \\\n\t\t|NN const SV *const val\nsMd\t|SV*\t|find_uninit_var|NULLOK const OP *const obase \\\n\t\t|NULLOK const SV *const uninit_sv|bool match \\\n\t\t|NN const char **desc_p\n#endif\n\nAp\t|GV*\t|gv_fetchpvn_flags|NN const char* name|STRLEN len|I32 flags|const svtype sv_type\nAp\t|GV*\t|gv_fetchsv|NN SV *name|I32 flags|const svtype sv_type\n\n#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP\n: Used in sv.c\np\t|void\t|dump_sv_child\t|NN SV *sv\n#endif\n\n#ifdef PERL_DONT_CREATE_GVSV\nApbm\t|GV*\t|gv_SVadd\t|NULLOK GV *gv\n#endif\n#if defined(PERL_IN_UTIL_C)\ns\t|bool\t|ckwarn_common\t|U32 w\n#endif\nApoP\t|bool\t|ckwarn\t\t|U32 w\nApoP\t|bool\t|ckwarn_d\t|U32 w\n: FIXME - exported for ByteLoader - public or private?\nXEopMR\t|STRLEN *|new_warnings_bitfield|NULLOK STRLEN *buffer \\\n\t\t\t\t|NN const char *const bits|STRLEN size\n\nApnodf\t|int\t|my_snprintf\t|NN char *buffer|const Size_t len|NN const char *format|...\nApnod\t|int\t|my_vsnprintf\t|NN char *buffer|const Size_t len|NN const char *format|va_list ap\n#ifdef USE_QUADMATH\nApnd\t|const char*\t|quadmath_format_single|NN const char* format\nApnd\t|bool|quadmath_format_needed|NN const char* format\n#endif\n\n: Used in mg.c, sv.c\npx\t|void\t|my_clearenv\n\n#ifdef PERL_IMPLICIT_CONTEXT\n#ifdef PERL_GLOBAL_STRUCT_PRIVATE\nApo\t|void*\t|my_cxt_init\t|NN const char *my_cxt_key|size_t size\nApo\t|int\t|my_cxt_index\t|NN const char *my_cxt_key\n#else\nApo\t|void*\t|my_cxt_init\t|NN int *indexp|size_t size\n#endif\n#endif\n#if defined(PERL_IN_UTIL_C)\nso\t|void\t|xs_version_bootcheck|U32 items|U32 ax|NN const char *xs_p \\\n\t\t\t\t|STRLEN xs_len\n#endif\nXpon\t|I32\t|xs_handshake\t|const U32 key|NN void * v_my_perl\\\n\t\t\t\t|NN const char * file| ...\nXp\t|void\t|xs_boot_epilog\t|const I32 ax\n#ifndef HAS_STRLCAT\nApnod\t|Size_t\t|my_strlcat\t|NULLOK char *dst|NULLOK const char *src|Size_t size\n#endif\n\n#ifndef HAS_STRLCPY\nApnod\t|Size_t |my_strlcpy     |NULLOK char *dst|NULLOK const char *src|Size_t size\n#endif\n\n#ifndef HAS_STRNLEN\nApnod\t|Size_t |my_strnlen     |NN const char *str|Size_t maxlen\n#endif\n\n#ifndef HAS_MKOSTEMP\npno\t|int\t|my_mkostemp\t|NN char *templte|int flags\n#endif\n#ifndef HAS_MKSTEMP\npno\t|int\t|my_mkstemp\t|NN char *templte\n#endif\n\nAPpdn\t|bool\t|isinfnan\t|NV nv\np\t|bool\t|isinfnansv\t|NN SV *sv\n\n#if !defined(HAS_SIGNBIT)\nAMdnoP\t|int\t|Perl_signbit\t|NV f\n#endif\n\n: Used by B\nXEMop\t|void\t|emulate_cop_io\t|NN const COP *const c|NN SV *const sv\n: Used by SvRX and SvRXOK\nXEMop\t|REGEXP *|get_re_arg|NULLOK SV *sv\n\nAop\t|SV*\t|mro_get_private_data|NN struct mro_meta *const smeta \\\n\t\t\t\t     |NN const struct mro_alg *const which\nAop\t|SV*\t|mro_set_private_data|NN struct mro_meta *const smeta \\\n\t\t\t\t     |NN const struct mro_alg *const which \\\n\t\t\t\t     |NN SV *const data\nAop\t|const struct mro_alg *|mro_get_from_name|NN SV *name\nAop\t|void\t|mro_register\t|NN const struct mro_alg *mro\nAop\t|void\t|mro_set_mro\t|NN struct mro_meta *const meta \\\n\t\t\t\t|NN SV *const name\n: Used in HvMROMETA(), which is public.\nXpo\t|struct mro_meta*\t|mro_meta_init\t|NN HV* stash\n#if defined(USE_ITHREADS)\n: Only used in sv.c\np\t|struct mro_meta*\t|mro_meta_dup\t|NN struct mro_meta* smeta|NN CLONE_PARAMS* param\n#endif\nApd\t|AV*\t|mro_get_linear_isa|NN HV* stash\n#if defined(PERL_IN_MRO_C)\nsd\t|AV*\t|mro_get_linear_isa_dfs|NN HV* stash|U32 level\ns\t|void\t|mro_clean_isarev|NN HV * const isa   \\\n\t\t\t\t |NN const char * const name \\\n\t\t\t\t |const STRLEN len \\\n\t\t\t\t |NULLOK HV * const exceptions \\\n\t\t\t\t |U32 hash|U32 flags\ns\t|void\t|mro_gather_and_rename|NN HV * const stashes \\\n\t\t\t\t      |NN HV * const seen_stashes \\\n\t\t\t\t      |NULLOK HV *stash \\\n\t\t\t\t      |NULLOK HV *oldstash \\\n\t\t\t\t      |NN SV *namesv\n#endif\n: Used in hv.c, mg.c, pp.c, sv.c\npd\t|void   |mro_isa_changed_in|NN HV* stash\nApd\t|void\t|mro_method_changed_in\t|NN HV* stash\npdx\t|void\t|mro_package_moved\t|NULLOK HV * const stash|NULLOK HV * const oldstash|NN const GV * const gv|U32 flags\n: Only used in perl.c\np\t|void   |boot_core_mro\nApon\t|void\t|sys_init\t|NN int* argc|NN char*** argv\nApon\t|void\t|sys_init3\t|NN int* argc|NN char*** argv|NN char*** env\nApon\t|void\t|sys_term\nApoM\t|const char *|cop_fetch_label|NN COP *const cop \\\n\t\t|NULLOK STRLEN *len|NULLOK U32 *flags\n: Only used  in op.c and the perl compiler\nApoM\t|void|cop_store_label \\\n\t\t|NN COP *const cop|NN const char *label|STRLEN len|U32 flags\n\nxpo\t|int\t|keyword_plugin_standard|NN char* keyword_ptr|STRLEN keyword_len|NN OP** op_ptr\n\n#if defined(USE_ITHREADS)\n#  if defined(PERL_IN_SV_C)\ns\t|void\t|unreferenced_to_tmp_stack|NN AV *const unreferenced\n#  endif\nARnop\t|CLONE_PARAMS *|clone_params_new|NN PerlInterpreter *const from \\\n\t\t|NN PerlInterpreter *const to\nAnop\t|void\t|clone_params_del|NN CLONE_PARAMS *param\n#endif\n\n: Used in perl.c and toke.c\nop\t|void\t|populate_isa\t|NN const char *name|STRLEN len|...\n\n: Used in keywords.c and toke.c\nXop\t|bool\t|feature_is_enabled|NN const char *const name \\\n\t\t|STRLEN namelen\n\n: Some static inline functions need predeclaration because they are used\n: inside other static inline functions.\n#if defined(PERL_CORE) || defined (PERL_EXT)\nEi\t|STRLEN\t|sv_or_pv_pos_u2b|NN SV *sv|NN const char *pv|STRLEN pos \\\n\t\t\t\t |NULLOK STRLEN *lenp\n#endif\n\nAp\t|void\t|clear_defarray\t|NN AV* av|bool abandon\n\nApM\t|void\t|leave_adjust_stacks|NN SV **from_sp|NN SV **to_sp \\\n                |U8 gimme|int filter\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nAiM\t|PERL_CONTEXT *\t|cx_pushblock|U8 type|U8 gimme|NN SV** sp|I32 saveix\nAiM\t|void\t|cx_popblock|NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_topblock|NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_pushsub      |NN PERL_CONTEXT *cx|NN CV *cv \\\n\t\t\t\t |NULLOK OP *retop|bool hasargs\nAiM\t|void\t|cx_popsub_common|NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_popsub_args  |NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_popsub       |NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_pushformat   |NN PERL_CONTEXT *cx|NN CV *cv \\\n\t\t\t\t |NULLOK OP *retop|NULLOK GV *gv\nAiM\t|void\t|cx_popformat    |NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_pusheval     |NN PERL_CONTEXT *cx \\\n\t\t\t\t |NULLOK OP *retop|NULLOK SV *namesv\nAiM\t|void\t|cx_popeval      |NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_pushloop_plain|NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_pushloop_for |NN PERL_CONTEXT *cx \\\n\t\t\t\t |NN void *itervarp|NULLOK SV *itersave\nAiM\t|void\t|cx_poploop      |NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_pushwhen     |NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_popwhen      |NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_pushgiven    |NN PERL_CONTEXT *cx|NULLOK SV *orig_defsv\nAiM\t|void\t|cx_popgiven     |NN PERL_CONTEXT *cx\n#endif\n\n#ifdef USE_DTRACE\nXEop\t|void   |dtrace_probe_call |NN CV *cv|bool is_call\nXEop\t|void   |dtrace_probe_load |NN const char *name|bool is_loading\nXEop\t|void   |dtrace_probe_op   |NN const OP *op\nXEop\t|void   |dtrace_probe_phase|enum perl_phase phase\n#endif\n\nXEop\t|STRLEN*|dup_warnings\t|NULLOK STRLEN* warnings\n\n: ex: set ts=8 sts=4 sw=4 noet:\n", "/* -*- buffer-read-only: t -*-\n *\n *    embed.h\n *\n *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others\n *\n *    You may distribute under the terms of either the GNU General Public\n *    License or the Artistic License, as specified in the README file.\n *\n * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n * This file is built by regen/embed.pl from data in embed.fnc,\n * regen/embed.pl, regen/opcodes, intrpvar.h and perlvars.h.\n * Any changes made here will be lost!\n *\n * Edit those files and run 'make regen_headers' to effect changes.\n */\n\n/* (Doing namespace management portably in C is really gross.) */\n\n/* By defining PERL_NO_SHORT_NAMES (not done by default) the short forms\n * (like warn instead of Perl_warn) for the API are not defined.\n * Not defining the short forms is a good thing for cleaner embedding. */\n\n#ifndef PERL_NO_SHORT_NAMES\n\n/* Hide global symbols */\n\n#define Gv_AMupdate(a,b)\tPerl_Gv_AMupdate(aTHX_ a,b)\n#define _force_out_malformed_utf8_message(a,b,c,d)\tPerl__force_out_malformed_utf8_message(aTHX_ a,b,c,d)\n#define _is_uni_FOO(a,b)\tPerl__is_uni_FOO(aTHX_ a,b)\n#define _is_uni_perl_idcont(a)\tPerl__is_uni_perl_idcont(aTHX_ a)\n#define _is_uni_perl_idstart(a)\tPerl__is_uni_perl_idstart(aTHX_ a)\n#define _is_utf8_FOO(a,b,c,d,e,f,g,h)\tPerl__is_utf8_FOO(aTHX_ a,b,c,d,e,f,g,h)\n#define _is_utf8_FOO_with_len(a,b,c)\tPerl__is_utf8_FOO_with_len(aTHX_ a,b,c)\n#define _is_utf8_char_helper\tPerl__is_utf8_char_helper\n#define _is_utf8_idcont(a)\tPerl__is_utf8_idcont(aTHX_ a)\n#define _is_utf8_idstart(a)\tPerl__is_utf8_idstart(aTHX_ a)\n#define _is_utf8_mark(a)\tPerl__is_utf8_mark(aTHX_ a)\n#define _is_utf8_perl_idcont_with_len(a,b)\tPerl__is_utf8_perl_idcont_with_len(aTHX_ a,b)\n#define _is_utf8_perl_idstart_with_len(a,b)\tPerl__is_utf8_perl_idstart_with_len(aTHX_ a,b)\n#define _is_utf8_xidcont(a)\tPerl__is_utf8_xidcont(aTHX_ a)\n#define _is_utf8_xidstart(a)\tPerl__is_utf8_xidstart(aTHX_ a)\n#define _to_uni_fold_flags(a,b,c,d)\tPerl__to_uni_fold_flags(aTHX_ a,b,c,d)\n#define _to_utf8_fold_flags(a,b,c,d,e,f,g)\tPerl__to_utf8_fold_flags(aTHX_ a,b,c,d,e,f,g)\n#define _to_utf8_lower_flags(a,b,c,d,e,f,g)\tPerl__to_utf8_lower_flags(aTHX_ a,b,c,d,e,f,g)\n#define _to_utf8_title_flags(a,b,c,d,e,f,g)\tPerl__to_utf8_title_flags(aTHX_ a,b,c,d,e,f,g)\n#define _to_utf8_upper_flags(a,b,c,d,e,f,g)\tPerl__to_utf8_upper_flags(aTHX_ a,b,c,d,e,f,g)\n#define _utf8n_to_uvchr_msgs_helper\tPerl__utf8n_to_uvchr_msgs_helper\n#define amagic_call(a,b,c,d)\tPerl_amagic_call(aTHX_ a,b,c,d)\n#define amagic_deref_call(a,b)\tPerl_amagic_deref_call(aTHX_ a,b)\n#define apply_attrs_string(a,b,c,d)\tPerl_apply_attrs_string(aTHX_ a,b,c,d)\n#define atfork_lock\t\tPerl_atfork_lock\n#define atfork_unlock\t\tPerl_atfork_unlock\n#define av_clear(a)\t\tPerl_av_clear(aTHX_ a)\n#define av_delete(a,b,c)\tPerl_av_delete(aTHX_ a,b,c)\n#define av_exists(a,b)\t\tPerl_av_exists(aTHX_ a,b)\n#define av_extend(a,b)\t\tPerl_av_extend(aTHX_ a,b)\n#define av_fetch(a,b,c)\t\tPerl_av_fetch(aTHX_ a,b,c)\n#define av_fill(a,b)\t\tPerl_av_fill(aTHX_ a,b)\n#define av_len(a)\t\tPerl_av_len(aTHX_ a)\n#define av_make(a,b)\t\tPerl_av_make(aTHX_ a,b)\n#define av_pop(a)\t\tPerl_av_pop(aTHX_ a)\n#define av_push(a,b)\t\tPerl_av_push(aTHX_ a,b)\n#define av_shift(a)\t\tPerl_av_shift(aTHX_ a)\n#define av_store(a,b,c)\t\tPerl_av_store(aTHX_ a,b,c)\n#define av_top_index(a)\t\tS_av_top_index(aTHX_ a)\n#define av_undef(a)\t\tPerl_av_undef(aTHX_ a)\n#define av_unshift(a,b)\t\tPerl_av_unshift(aTHX_ a,b)\n#define block_end(a,b)\t\tPerl_block_end(aTHX_ a,b)\n#define block_gimme()\t\tPerl_block_gimme(aTHX)\n#define block_start(a)\t\tPerl_block_start(aTHX_ a)\n#define bytes_cmp_utf8(a,b,c,d)\tPerl_bytes_cmp_utf8(aTHX_ a,b,c,d)\n#define bytes_from_utf8_loc\tPerl_bytes_from_utf8_loc\n#define bytes_to_utf8(a,b)\tPerl_bytes_to_utf8(aTHX_ a,b)\n#define call_argv(a,b,c)\tPerl_call_argv(aTHX_ a,b,c)\n#define call_atexit(a,b)\tPerl_call_atexit(aTHX_ a,b)\n#define call_list(a,b)\t\tPerl_call_list(aTHX_ a,b)\n#define call_method(a,b)\tPerl_call_method(aTHX_ a,b)\n#define call_pv(a,b)\t\tPerl_call_pv(aTHX_ a,b)\n#define call_sv(a,b)\t\tPerl_call_sv(aTHX_ a,b)\n#define caller_cx(a,b)\t\tPerl_caller_cx(aTHX_ a,b)\n#define cast_i32\t\tPerl_cast_i32\n#define cast_iv\t\t\tPerl_cast_iv\n#define cast_ulong\t\tPerl_cast_ulong\n#define cast_uv\t\t\tPerl_cast_uv\n#define ck_entersub_args_list(a)\tPerl_ck_entersub_args_list(aTHX_ a)\n#define ck_entersub_args_proto(a,b,c)\tPerl_ck_entersub_args_proto(aTHX_ a,b,c)\n#define ck_entersub_args_proto_or_list(a,b,c)\tPerl_ck_entersub_args_proto_or_list(aTHX_ a,b,c)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define ck_warner\t\tPerl_ck_warner\n#define ck_warner_d\t\tPerl_ck_warner_d\n#endif\n#define clear_defarray(a,b)\tPerl_clear_defarray(aTHX_ a,b)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define croak\t\t\tPerl_croak\n#endif\n#define croak_memory_wrap\tS_croak_memory_wrap\n#define croak_no_modify\t\tPerl_croak_no_modify\n#define croak_sv(a)\t\tPerl_croak_sv(aTHX_ a)\n#define croak_xs_usage\t\tPerl_croak_xs_usage\n#ifndef NO_MATHOMS\n#define custom_op_desc(a)\tPerl_custom_op_desc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define custom_op_name(a)\tPerl_custom_op_name(aTHX_ a)\n#endif\n#define cv_clone(a)\t\tPerl_cv_clone(aTHX_ a)\n#define cv_const_sv\t\tPerl_cv_const_sv\n#define cv_get_call_checker(a,b,c)\tPerl_cv_get_call_checker(aTHX_ a,b,c)\n#define cv_get_call_checker_flags(a,b,c,d,e)\tPerl_cv_get_call_checker_flags(aTHX_ a,b,c,d,e)\n#define cv_name(a,b,c)\t\tPerl_cv_name(aTHX_ a,b,c)\n#define cv_set_call_checker(a,b,c)\tPerl_cv_set_call_checker(aTHX_ a,b,c)\n#define cv_set_call_checker_flags(a,b,c,d)\tPerl_cv_set_call_checker_flags(aTHX_ a,b,c,d)\n#define cv_undef(a)\t\tPerl_cv_undef(aTHX_ a)\n#define cx_dump(a)\t\tPerl_cx_dump(aTHX_ a)\n#define cxinc()\t\t\tPerl_cxinc(aTHX)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define deb\t\t\tPerl_deb\n#endif\n#define debop(a)\t\tPerl_debop(aTHX_ a)\n#define debprofdump()\t\tPerl_debprofdump(aTHX)\n#define debstack()\t\tPerl_debstack(aTHX)\n#define debstackptrs()\t\tPerl_debstackptrs(aTHX)\n#define delimcpy\t\tPerl_delimcpy\n#define despatch_signals()\tPerl_despatch_signals(aTHX)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define die\t\t\tPerl_die\n#endif\n#define die_sv(a)\t\tPerl_die_sv(aTHX_ a)\n#ifndef NO_MATHOMS\n#define do_binmode(a,b,c)\tPerl_do_binmode(aTHX_ a,b,c)\n#endif\n#define do_close(a,b)\t\tPerl_do_close(aTHX_ a,b)\n#define do_gv_dump(a,b,c,d)\tPerl_do_gv_dump(aTHX_ a,b,c,d)\n#define do_gvgv_dump(a,b,c,d)\tPerl_do_gvgv_dump(aTHX_ a,b,c,d)\n#define do_hv_dump(a,b,c,d)\tPerl_do_hv_dump(aTHX_ a,b,c,d)\n#define do_join(a,b,c,d)\tPerl_do_join(aTHX_ a,b,c,d)\n#define do_magic_dump(a,b,c,d,e,f,g)\tPerl_do_magic_dump(aTHX_ a,b,c,d,e,f,g)\n#define do_op_dump(a,b,c)\tPerl_do_op_dump(aTHX_ a,b,c)\n#ifndef NO_MATHOMS\n#define do_open9(a,b,c,d,e,f,g,h,i)\tPerl_do_open9(aTHX_ a,b,c,d,e,f,g,h,i)\n#endif\n#define do_openn(a,b,c,d,e,f,g,h,i)\tPerl_do_openn(aTHX_ a,b,c,d,e,f,g,h,i)\n#define do_pmop_dump(a,b,c)\tPerl_do_pmop_dump(aTHX_ a,b,c)\n#define do_sprintf(a,b,c)\tPerl_do_sprintf(aTHX_ a,b,c)\n#define do_sv_dump(a,b,c,d,e,f,g)\tPerl_do_sv_dump(aTHX_ a,b,c,d,e,f,g)\n#define doing_taint\t\tPerl_doing_taint\n#define doref(a,b,c)\t\tPerl_doref(aTHX_ a,b,c)\n#define dounwind(a)\t\tPerl_dounwind(aTHX_ a)\n#define dowantarray()\t\tPerl_dowantarray(aTHX)\n#define dump_all()\t\tPerl_dump_all(aTHX)\n#define dump_eval()\t\tPerl_dump_eval(aTHX)\n#define dump_form(a)\t\tPerl_dump_form(aTHX_ a)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define dump_indent\t\tPerl_dump_indent\n#endif\n#define dump_packsubs(a)\tPerl_dump_packsubs(aTHX_ a)\n#define dump_sub(a)\t\tPerl_dump_sub(aTHX_ a)\n#define dump_vindent(a,b,c,d)\tPerl_dump_vindent(aTHX_ a,b,c,d)\n#define eval_pv(a,b)\t\tPerl_eval_pv(aTHX_ a,b)\n#define eval_sv(a,b)\t\tPerl_eval_sv(aTHX_ a,b)\n#define fbm_compile(a,b)\tPerl_fbm_compile(aTHX_ a,b)\n#define fbm_instr(a,b,c,d)\tPerl_fbm_instr(aTHX_ a,b,c,d)\n#define filter_add(a,b)\t\tPerl_filter_add(aTHX_ a,b)\n#define filter_del(a)\t\tPerl_filter_del(aTHX_ a)\n#define filter_read(a,b,c)\tPerl_filter_read(aTHX_ a,b,c)\n#define find_runcv(a)\t\tPerl_find_runcv(aTHX_ a)\n#define find_rundefsv()\t\tPerl_find_rundefsv(aTHX)\n#define find_rundefsvoffset()\tPerl_find_rundefsvoffset(aTHX)\n#define foldEQ\t\t\tPerl_foldEQ\n#define foldEQ_latin1\t\tPerl_foldEQ_latin1\n#define foldEQ_locale\t\tPerl_foldEQ_locale\n#define foldEQ_utf8_flags(a,b,c,d,e,f,g,h,i)\tPerl_foldEQ_utf8_flags(aTHX_ a,b,c,d,e,f,g,h,i)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define form\t\t\tPerl_form\n#endif\n#define free_tmps()\t\tPerl_free_tmps(aTHX)\n#define get_av(a,b)\t\tPerl_get_av(aTHX_ a,b)\n#define get_context\t\tPerl_get_context\n#define get_cv(a,b)\t\tPerl_get_cv(aTHX_ a,b)\n#define get_cvn_flags(a,b,c)\tPerl_get_cvn_flags(aTHX_ a,b,c)\n#define get_hv(a,b)\t\tPerl_get_hv(aTHX_ a,b)\n#define get_op_descs()\t\tPerl_get_op_descs(aTHX)\n#define get_op_names()\t\tPerl_get_op_names(aTHX)\n#define get_ppaddr()\t\tPerl_get_ppaddr(aTHX)\n#define get_sv(a,b)\t\tPerl_get_sv(aTHX_ a,b)\n#define get_vtbl(a)\t\tPerl_get_vtbl(aTHX_ a)\n#define getcwd_sv(a)\t\tPerl_getcwd_sv(aTHX_ a)\n#define gp_free(a)\t\tPerl_gp_free(aTHX_ a)\n#define gp_ref(a)\t\tPerl_gp_ref(aTHX_ a)\n#define grok_bin(a,b,c,d)\tPerl_grok_bin(aTHX_ a,b,c,d)\n#define grok_hex(a,b,c,d)\tPerl_grok_hex(aTHX_ a,b,c,d)\n#define grok_infnan(a,b)\tPerl_grok_infnan(aTHX_ a,b)\n#define grok_number(a,b,c)\tPerl_grok_number(aTHX_ a,b,c)\n#define grok_number_flags(a,b,c,d)\tPerl_grok_number_flags(aTHX_ a,b,c,d)\n#define grok_numeric_radix(a,b)\tPerl_grok_numeric_radix(aTHX_ a,b)\n#define grok_oct(a,b,c,d)\tPerl_grok_oct(aTHX_ a,b,c,d)\n#define gv_add_by_type(a,b)\tPerl_gv_add_by_type(aTHX_ a,b)\n#define gv_autoload_pv(a,b,c)\tPerl_gv_autoload_pv(aTHX_ a,b,c)\n#define gv_autoload_pvn(a,b,c,d)\tPerl_gv_autoload_pvn(aTHX_ a,b,c,d)\n#define gv_autoload_sv(a,b,c)\tPerl_gv_autoload_sv(aTHX_ a,b,c)\n#define gv_check(a)\t\tPerl_gv_check(aTHX_ a)\n#define gv_const_sv(a)\t\tPerl_gv_const_sv(aTHX_ a)\n#define gv_dump(a)\t\tPerl_gv_dump(aTHX_ a)\n#ifndef NO_MATHOMS\n#define gv_efullname(a,b)\tPerl_gv_efullname(aTHX_ a,b)\n#endif\n#define gv_efullname4(a,b,c,d)\tPerl_gv_efullname4(aTHX_ a,b,c,d)\n#define gv_fetchfile(a)\t\tPerl_gv_fetchfile(aTHX_ a)\n#define gv_fetchfile_flags(a,b,c)\tPerl_gv_fetchfile_flags(aTHX_ a,b,c)\n#define gv_fetchmeth_pv(a,b,c,d)\tPerl_gv_fetchmeth_pv(aTHX_ a,b,c,d)\n#define gv_fetchmeth_pv_autoload(a,b,c,d)\tPerl_gv_fetchmeth_pv_autoload(aTHX_ a,b,c,d)\n#define gv_fetchmeth_pvn(a,b,c,d,e)\tPerl_gv_fetchmeth_pvn(aTHX_ a,b,c,d,e)\n#define gv_fetchmeth_pvn_autoload(a,b,c,d,e)\tPerl_gv_fetchmeth_pvn_autoload(aTHX_ a,b,c,d,e)\n#define gv_fetchmeth_sv(a,b,c,d)\tPerl_gv_fetchmeth_sv(aTHX_ a,b,c,d)\n#define gv_fetchmeth_sv_autoload(a,b,c,d)\tPerl_gv_fetchmeth_sv_autoload(aTHX_ a,b,c,d)\n#define gv_fetchmethod_autoload(a,b,c)\tPerl_gv_fetchmethod_autoload(aTHX_ a,b,c)\n#define gv_fetchmethod_pv_flags(a,b,c)\tPerl_gv_fetchmethod_pv_flags(aTHX_ a,b,c)\n#define gv_fetchmethod_pvn_flags(a,b,c,d)\tPerl_gv_fetchmethod_pvn_flags(aTHX_ a,b,c,d)\n#define gv_fetchmethod_sv_flags(a,b,c)\tPerl_gv_fetchmethod_sv_flags(aTHX_ a,b,c)\n#define gv_fetchpv(a,b,c)\tPerl_gv_fetchpv(aTHX_ a,b,c)\n#define gv_fetchpvn_flags(a,b,c,d)\tPerl_gv_fetchpvn_flags(aTHX_ a,b,c,d)\n#define gv_fetchsv(a,b,c)\tPerl_gv_fetchsv(aTHX_ a,b,c)\n#ifndef NO_MATHOMS\n#define gv_fullname(a,b)\tPerl_gv_fullname(aTHX_ a,b)\n#endif\n#define gv_fullname4(a,b,c,d)\tPerl_gv_fullname4(aTHX_ a,b,c,d)\n#define gv_handler(a,b)\t\tPerl_gv_handler(aTHX_ a,b)\n#define gv_init_pv(a,b,c,d)\tPerl_gv_init_pv(aTHX_ a,b,c,d)\n#define gv_init_pvn(a,b,c,d,e)\tPerl_gv_init_pvn(aTHX_ a,b,c,d,e)\n#define gv_init_sv(a,b,c,d)\tPerl_gv_init_sv(aTHX_ a,b,c,d)\n#define gv_name_set(a,b,c,d)\tPerl_gv_name_set(aTHX_ a,b,c,d)\n#define gv_stashpv(a,b)\t\tPerl_gv_stashpv(aTHX_ a,b)\n#define gv_stashpvn(a,b,c)\tPerl_gv_stashpvn(aTHX_ a,b,c)\n#define gv_stashsv(a,b)\t\tPerl_gv_stashsv(aTHX_ a,b)\n#define hv_bucket_ratio(a)\tPerl_hv_bucket_ratio(aTHX_ a)\n#define hv_clear(a)\t\tPerl_hv_clear(aTHX_ a)\n#define hv_clear_placeholders(a)\tPerl_hv_clear_placeholders(aTHX_ a)\n#define hv_common(a,b,c,d,e,f,g,h)\tPerl_hv_common(aTHX_ a,b,c,d,e,f,g,h)\n#define hv_common_key_len(a,b,c,d,e,f)\tPerl_hv_common_key_len(aTHX_ a,b,c,d,e,f)\n#define hv_copy_hints_hv(a)\tPerl_hv_copy_hints_hv(aTHX_ a)\n#define hv_delayfree_ent(a,b)\tPerl_hv_delayfree_ent(aTHX_ a,b)\n#define hv_free_ent(a,b)\tPerl_hv_free_ent(aTHX_ a,b)\n#define hv_iterinit(a)\t\tPerl_hv_iterinit(aTHX_ a)\n#define hv_iterkey(a,b)\t\tPerl_hv_iterkey(aTHX_ a,b)\n#define hv_iterkeysv(a)\t\tPerl_hv_iterkeysv(aTHX_ a)\n#define hv_iternext_flags(a,b)\tPerl_hv_iternext_flags(aTHX_ a,b)\n#define hv_iternextsv(a,b,c)\tPerl_hv_iternextsv(aTHX_ a,b,c)\n#define hv_iterval(a,b)\t\tPerl_hv_iterval(aTHX_ a,b)\n#define hv_ksplit(a,b)\t\tPerl_hv_ksplit(aTHX_ a,b)\n#define hv_name_set(a,b,c,d)\tPerl_hv_name_set(aTHX_ a,b,c,d)\n#define hv_rand_set(a,b)\tPerl_hv_rand_set(aTHX_ a,b)\n#define hv_scalar(a)\t\tPerl_hv_scalar(aTHX_ a)\n#define init_i18nl10n(a)\tPerl_init_i18nl10n(aTHX_ a)\n#ifndef NO_MATHOMS\n#define init_i18nl14n(a)\tPerl_init_i18nl14n(aTHX_ a)\n#endif\n#define init_stacks()\t\tPerl_init_stacks(aTHX)\n#define init_tm(a)\t\tPerl_init_tm(aTHX_ a)\n#define intro_my()\t\tPerl_intro_my(aTHX)\n#ifndef NO_MATHOMS\n#define isALNUM_lazy(a)\t\tPerl_isALNUM_lazy(aTHX_ a)\n#endif\n#define isC9_STRICT_UTF8_CHAR\tS_isC9_STRICT_UTF8_CHAR\n#ifndef NO_MATHOMS\n#define isIDFIRST_lazy(a)\tPerl_isIDFIRST_lazy(aTHX_ a)\n#endif\n#define isSTRICT_UTF8_CHAR\tS_isSTRICT_UTF8_CHAR\n#define isUTF8_CHAR\t\tS_isUTF8_CHAR\n#define is_c9strict_utf8_string_loclen\tS_is_c9strict_utf8_string_loclen\n#define is_lvalue_sub()\t\tPerl_is_lvalue_sub(aTHX)\n#define is_safe_syscall(a,b,c,d)\tS_is_safe_syscall(aTHX_ a,b,c,d)\n#define is_strict_utf8_string_loclen\tS_is_strict_utf8_string_loclen\n#ifndef NO_MATHOMS\n#define is_uni_alnum(a)\t\tPerl_is_uni_alnum(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_alnum_lc(a)\tPerl_is_uni_alnum_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_alnumc(a)\tPerl_is_uni_alnumc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_alnumc_lc(a)\tPerl_is_uni_alnumc_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_alpha(a)\t\tPerl_is_uni_alpha(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_alpha_lc(a)\tPerl_is_uni_alpha_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_ascii(a)\t\tPerl_is_uni_ascii(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_ascii_lc(a)\tPerl_is_uni_ascii_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_blank(a)\t\tPerl_is_uni_blank(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_blank_lc(a)\tPerl_is_uni_blank_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_cntrl(a)\t\tPerl_is_uni_cntrl(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_cntrl_lc(a)\tPerl_is_uni_cntrl_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_digit(a)\t\tPerl_is_uni_digit(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_digit_lc(a)\tPerl_is_uni_digit_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_graph(a)\t\tPerl_is_uni_graph(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_graph_lc(a)\tPerl_is_uni_graph_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_idfirst(a)\tPerl_is_uni_idfirst(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_idfirst_lc(a)\tPerl_is_uni_idfirst_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_lower(a)\t\tPerl_is_uni_lower(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_lower_lc(a)\tPerl_is_uni_lower_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_print(a)\t\tPerl_is_uni_print(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_print_lc(a)\tPerl_is_uni_print_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_punct(a)\t\tPerl_is_uni_punct(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_punct_lc(a)\tPerl_is_uni_punct_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_space(a)\t\tPerl_is_uni_space(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_space_lc(a)\tPerl_is_uni_space_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_upper(a)\t\tPerl_is_uni_upper(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_upper_lc(a)\tPerl_is_uni_upper_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_xdigit(a)\tPerl_is_uni_xdigit(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_xdigit_lc(a)\tPerl_is_uni_xdigit_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_alnum(a)\tPerl_is_utf8_alnum(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_alnumc(a)\tPerl_is_utf8_alnumc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_alpha(a)\tPerl_is_utf8_alpha(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_ascii(a)\tPerl_is_utf8_ascii(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_blank(a)\tPerl_is_utf8_blank(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_char\t\tPerl_is_utf8_char\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_cntrl(a)\tPerl_is_utf8_cntrl(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_digit(a)\tPerl_is_utf8_digit(aTHX_ a)\n#endif\n#define is_utf8_fixed_width_buf_loclen_flags\tS_is_utf8_fixed_width_buf_loclen_flags\n#ifndef NO_MATHOMS\n#define is_utf8_graph(a)\tPerl_is_utf8_graph(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_idcont(a)\tPerl_is_utf8_idcont(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_idfirst(a)\tPerl_is_utf8_idfirst(aTHX_ a)\n#endif\n#define is_utf8_invariant_string_loc\tS_is_utf8_invariant_string_loc\n#ifndef NO_MATHOMS\n#define is_utf8_lower(a)\tPerl_is_utf8_lower(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_mark(a)\t\tPerl_is_utf8_mark(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_perl_space(a)\tPerl_is_utf8_perl_space(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_perl_word(a)\tPerl_is_utf8_perl_word(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_posix_digit(a)\tPerl_is_utf8_posix_digit(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_print(a)\tPerl_is_utf8_print(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_punct(a)\tPerl_is_utf8_punct(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_space(a)\tPerl_is_utf8_space(aTHX_ a)\n#endif\n#define is_utf8_string_flags\tS_is_utf8_string_flags\n#define is_utf8_string_loclen\tPerl_is_utf8_string_loclen\n#define is_utf8_string_loclen_flags\tS_is_utf8_string_loclen_flags\n#ifndef NO_MATHOMS\n#define is_utf8_upper(a)\tPerl_is_utf8_upper(aTHX_ a)\n#endif\n#define is_utf8_valid_partial_char_flags\tS_is_utf8_valid_partial_char_flags\n#ifndef NO_MATHOMS\n#define is_utf8_xdigit(a)\tPerl_is_utf8_xdigit(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_xidcont(a)\tPerl_is_utf8_xidcont(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_xidfirst(a)\tPerl_is_utf8_xidfirst(aTHX_ a)\n#endif\n#define isinfnan\t\tPerl_isinfnan\n#define leave_adjust_stacks(a,b,c,d)\tPerl_leave_adjust_stacks(aTHX_ a,b,c,d)\n#define leave_scope(a)\t\tPerl_leave_scope(aTHX_ a)\n#define lex_bufutf8()\t\tPerl_lex_bufutf8(aTHX)\n#define lex_discard_to(a)\tPerl_lex_discard_to(aTHX_ a)\n#define lex_grow_linestr(a)\tPerl_lex_grow_linestr(aTHX_ a)\n#define lex_next_chunk(a)\tPerl_lex_next_chunk(aTHX_ a)\n#define lex_peek_unichar(a)\tPerl_lex_peek_unichar(aTHX_ a)\n#define lex_read_space(a)\tPerl_lex_read_space(aTHX_ a)\n#define lex_read_to(a)\t\tPerl_lex_read_to(aTHX_ a)\n#define lex_read_unichar(a)\tPerl_lex_read_unichar(aTHX_ a)\n#define lex_start(a,b,c)\tPerl_lex_start(aTHX_ a,b,c)\n#define lex_stuff_pv(a,b)\tPerl_lex_stuff_pv(aTHX_ a,b)\n#define lex_stuff_pvn(a,b,c)\tPerl_lex_stuff_pvn(aTHX_ a,b,c)\n#define lex_stuff_sv(a,b)\tPerl_lex_stuff_sv(aTHX_ a,b)\n#define lex_unstuff(a)\t\tPerl_lex_unstuff(aTHX_ a)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define load_module\t\tPerl_load_module\n#endif\n#define looks_like_number(a)\tPerl_looks_like_number(aTHX_ a)\n#define magic_dump(a)\t\tPerl_magic_dump(aTHX_ a)\n#define markstack_grow()\tPerl_markstack_grow(aTHX)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define mess\t\t\tPerl_mess\n#endif\n#define mess_sv(a,b)\t\tPerl_mess_sv(aTHX_ a,b)\n#define mg_clear(a)\t\tPerl_mg_clear(aTHX_ a)\n#define mg_copy(a,b,c,d)\tPerl_mg_copy(aTHX_ a,b,c,d)\n#define mg_find\t\t\tPerl_mg_find\n#define mg_findext\t\tPerl_mg_findext\n#define mg_free(a)\t\tPerl_mg_free(aTHX_ a)\n#define mg_free_type(a,b)\tPerl_mg_free_type(aTHX_ a,b)\n#define mg_freeext(a,b,c)\tPerl_mg_freeext(aTHX_ a,b,c)\n#define mg_get(a)\t\tPerl_mg_get(aTHX_ a)\n#define mg_length(a)\t\tPerl_mg_length(aTHX_ a)\n#define mg_magical\t\tPerl_mg_magical\n#define mg_set(a)\t\tPerl_mg_set(aTHX_ a)\n#define mg_size(a)\t\tPerl_mg_size(aTHX_ a)\n#define mini_mktime\t\tPerl_mini_mktime\n#define moreswitches(a)\t\tPerl_moreswitches(aTHX_ a)\n#define mro_get_linear_isa(a)\tPerl_mro_get_linear_isa(aTHX_ a)\n#define mro_method_changed_in(a)\tPerl_mro_method_changed_in(aTHX_ a)\n#define my_atof(a)\t\tPerl_my_atof(aTHX_ a)\n#define my_atof3(a,b,c)\t\tPerl_my_atof3(aTHX_ a,b,c)\n#define my_dirfd\t\tPerl_my_dirfd\n#define my_exit(a)\t\tPerl_my_exit(aTHX_ a)\n#define my_failure_exit()\tPerl_my_failure_exit(aTHX)\n#define my_fflush_all()\t\tPerl_my_fflush_all(aTHX)\n#define my_fork\t\t\tPerl_my_fork\n#define my_popen_list(a,b,c)\tPerl_my_popen_list(aTHX_ a,b,c)\n#define my_setenv(a,b)\t\tPerl_my_setenv(aTHX_ a,b)\n#define my_socketpair\t\tPerl_my_socketpair\n#define my_strftime(a,b,c,d,e,f,g,h,i,j)\tPerl_my_strftime(aTHX_ a,b,c,d,e,f,g,h,i,j)\n#define my_strtod\t\tPerl_my_strtod\n#define newANONATTRSUB(a,b,c,d)\tPerl_newANONATTRSUB(aTHX_ a,b,c,d)\n#define newANONHASH(a)\t\tPerl_newANONHASH(aTHX_ a)\n#define newANONLIST(a)\t\tPerl_newANONLIST(aTHX_ a)\n#define newANONSUB(a,b,c)\tPerl_newANONSUB(aTHX_ a,b,c)\n#define newASSIGNOP(a,b,c,d)\tPerl_newASSIGNOP(aTHX_ a,b,c,d)\n#define newAVREF(a)\t\tPerl_newAVREF(aTHX_ a)\n#define newBINOP(a,b,c,d)\tPerl_newBINOP(aTHX_ a,b,c,d)\n#define newCONDOP(a,b,c,d)\tPerl_newCONDOP(aTHX_ a,b,c,d)\n#define newCONSTSUB(a,b,c)\tPerl_newCONSTSUB(aTHX_ a,b,c)\n#define newCONSTSUB_flags(a,b,c,d,e)\tPerl_newCONSTSUB_flags(aTHX_ a,b,c,d,e)\n#define newCVREF(a,b)\t\tPerl_newCVREF(aTHX_ a,b)\n#define newDEFSVOP()\t\tPerl_newDEFSVOP(aTHX)\n#define newFORM(a,b,c)\t\tPerl_newFORM(aTHX_ a,b,c)\n#define newFOROP(a,b,c,d,e)\tPerl_newFOROP(aTHX_ a,b,c,d,e)\n#define newGIVENOP(a,b,c)\tPerl_newGIVENOP(aTHX_ a,b,c)\n#define newGVOP(a,b,c)\t\tPerl_newGVOP(aTHX_ a,b,c)\n#define newGVREF(a,b)\t\tPerl_newGVREF(aTHX_ a,b)\n#define newGVgen_flags(a,b)\tPerl_newGVgen_flags(aTHX_ a,b)\n#define newHVREF(a)\t\tPerl_newHVREF(aTHX_ a)\n#define newHVhv(a)\t\tPerl_newHVhv(aTHX_ a)\n#define newLISTOP(a,b,c,d)\tPerl_newLISTOP(aTHX_ a,b,c,d)\n#define newLOGOP(a,b,c,d)\tPerl_newLOGOP(aTHX_ a,b,c,d)\n#define newLOOPEX(a,b)\t\tPerl_newLOOPEX(aTHX_ a,b)\n#define newLOOPOP(a,b,c,d)\tPerl_newLOOPOP(aTHX_ a,b,c,d)\n#define newMETHOP(a,b,c)\tPerl_newMETHOP(aTHX_ a,b,c)\n#define newMETHOP_named(a,b,c)\tPerl_newMETHOP_named(aTHX_ a,b,c)\n#define newMYSUB(a,b,c,d,e)\tPerl_newMYSUB(aTHX_ a,b,c,d,e)\n#define newNULLLIST()\t\tPerl_newNULLLIST(aTHX)\n#define newOP(a,b)\t\tPerl_newOP(aTHX_ a,b)\n#define newPADNAMELIST\t\tPerl_newPADNAMELIST\n#define newPADNAMEouter\t\tPerl_newPADNAMEouter\n#define newPADNAMEpvn\t\tPerl_newPADNAMEpvn\n#define newPMOP(a,b)\t\tPerl_newPMOP(aTHX_ a,b)\n#define newPROG(a)\t\tPerl_newPROG(aTHX_ a)\n#define newPVOP(a,b,c)\t\tPerl_newPVOP(aTHX_ a,b,c)\n#define newRANGE(a,b,c)\t\tPerl_newRANGE(aTHX_ a,b,c)\n#define newRV(a)\t\tPerl_newRV(aTHX_ a)\n#define newRV_noinc(a)\t\tPerl_newRV_noinc(aTHX_ a)\n#define newSLICEOP(a,b,c)\tPerl_newSLICEOP(aTHX_ a,b,c)\n#define newSTATEOP(a,b,c)\tPerl_newSTATEOP(aTHX_ a,b,c)\n#define newSV(a)\t\tPerl_newSV(aTHX_ a)\n#define newSVOP(a,b,c)\t\tPerl_newSVOP(aTHX_ a,b,c)\n#define newSVREF(a)\t\tPerl_newSVREF(aTHX_ a)\n#define newSV_type(a)\t\tPerl_newSV_type(aTHX_ a)\n#define newSVhek(a)\t\tPerl_newSVhek(aTHX_ a)\n#define newSViv(a)\t\tPerl_newSViv(aTHX_ a)\n#define newSVnv(a)\t\tPerl_newSVnv(aTHX_ a)\n#define newSVpv(a,b)\t\tPerl_newSVpv(aTHX_ a,b)\n#define newSVpv_share(a,b)\tPerl_newSVpv_share(aTHX_ a,b)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define newSVpvf\t\tPerl_newSVpvf\n#endif\n#define newSVpvn(a,b)\t\tPerl_newSVpvn(aTHX_ a,b)\n#define newSVpvn_flags(a,b,c)\tPerl_newSVpvn_flags(aTHX_ a,b,c)\n#define newSVpvn_share(a,b,c)\tPerl_newSVpvn_share(aTHX_ a,b,c)\n#define newSVrv(a,b)\t\tPerl_newSVrv(aTHX_ a,b)\n#define newSVsv_flags(a,b)\tPerl_newSVsv_flags(aTHX_ a,b)\n#define newSVuv(a)\t\tPerl_newSVuv(aTHX_ a)\n#define newUNOP(a,b,c)\t\tPerl_newUNOP(aTHX_ a,b,c)\n#define newUNOP_AUX(a,b,c,d)\tPerl_newUNOP_AUX(aTHX_ a,b,c,d)\n#define newWHENOP(a,b)\t\tPerl_newWHENOP(aTHX_ a,b)\n#define newWHILEOP(a,b,c,d,e,f,g)\tPerl_newWHILEOP(aTHX_ a,b,c,d,e,f,g)\n#define newXS(a,b,c)\t\tPerl_newXS(aTHX_ a,b,c)\n#define newXS_flags(a,b,c,d,e)\tPerl_newXS_flags(aTHX_ a,b,c,d,e)\n#define new_stackinfo(a,b)\tPerl_new_stackinfo(aTHX_ a,b)\n#define new_version(a)\t\tPerl_new_version(aTHX_ a)\n#define nothreadhook()\t\tPerl_nothreadhook(aTHX)\n#define op_append_elem(a,b,c)\tPerl_op_append_elem(aTHX_ a,b,c)\n#define op_append_list(a,b,c)\tPerl_op_append_list(aTHX_ a,b,c)\n#define op_class(a)\t\tPerl_op_class(aTHX_ a)\n#define op_contextualize(a,b)\tPerl_op_contextualize(aTHX_ a,b)\n#define op_convert_list(a,b,c)\tPerl_op_convert_list(aTHX_ a,b,c)\n#define op_dump(a)\t\tPerl_op_dump(aTHX_ a)\n#define op_free(a)\t\tPerl_op_free(aTHX_ a)\n#define op_linklist(a)\t\tPerl_op_linklist(aTHX_ a)\n#define op_null(a)\t\tPerl_op_null(aTHX_ a)\n#define op_parent\t\tPerl_op_parent\n#define op_prepend_elem(a,b,c)\tPerl_op_prepend_elem(aTHX_ a,b,c)\n#define op_refcnt_lock()\tPerl_op_refcnt_lock(aTHX)\n#define op_refcnt_unlock()\tPerl_op_refcnt_unlock(aTHX)\n#define op_scope(a)\t\tPerl_op_scope(aTHX_ a)\n#define op_sibling_splice\tPerl_op_sibling_splice\n#ifndef NO_MATHOMS\n#define pack_cat(a,b,c,d,e,f,g)\tPerl_pack_cat(aTHX_ a,b,c,d,e,f,g)\n#endif\n#define packlist(a,b,c,d,e)\tPerl_packlist(aTHX_ a,b,c,d,e)\n#define pad_add_anon(a,b)\tPerl_pad_add_anon(aTHX_ a,b)\n#define pad_add_name_pv(a,b,c,d)\tPerl_pad_add_name_pv(aTHX_ a,b,c,d)\n#define pad_add_name_pvn(a,b,c,d,e)\tPerl_pad_add_name_pvn(aTHX_ a,b,c,d,e)\n#define pad_add_name_sv(a,b,c,d)\tPerl_pad_add_name_sv(aTHX_ a,b,c,d)\n#define pad_alloc(a,b)\t\tPerl_pad_alloc(aTHX_ a,b)\n#ifndef NO_MATHOMS\n#define pad_compname_type(a)\tPerl_pad_compname_type(aTHX_ a)\n#endif\n#define pad_findmy_pv(a,b)\tPerl_pad_findmy_pv(aTHX_ a,b)\n#define pad_findmy_pvn(a,b,c)\tPerl_pad_findmy_pvn(aTHX_ a,b,c)\n#define pad_findmy_sv(a,b)\tPerl_pad_findmy_sv(aTHX_ a,b)\n#define pad_new(a)\t\tPerl_pad_new(aTHX_ a)\n#define pad_tidy(a)\t\tPerl_pad_tidy(aTHX_ a)\n#define padnamelist_fetch\tPerl_padnamelist_fetch\n#define padnamelist_store(a,b,c)\tPerl_padnamelist_store(aTHX_ a,b,c)\n#define parse_arithexpr(a)\tPerl_parse_arithexpr(aTHX_ a)\n#define parse_barestmt(a)\tPerl_parse_barestmt(aTHX_ a)\n#define parse_block(a)\t\tPerl_parse_block(aTHX_ a)\n#define parse_fullexpr(a)\tPerl_parse_fullexpr(aTHX_ a)\n#define parse_fullstmt(a)\tPerl_parse_fullstmt(aTHX_ a)\n#define parse_label(a)\t\tPerl_parse_label(aTHX_ a)\n#define parse_listexpr(a)\tPerl_parse_listexpr(aTHX_ a)\n#define parse_stmtseq(a)\tPerl_parse_stmtseq(aTHX_ a)\n#define parse_termexpr(a)\tPerl_parse_termexpr(aTHX_ a)\n#define pmop_dump(a)\t\tPerl_pmop_dump(aTHX_ a)\n#define pop_scope()\t\tPerl_pop_scope(aTHX)\n#define pregcomp(a,b)\t\tPerl_pregcomp(aTHX_ a,b)\n#define pregexec(a,b,c,d,e,f,g)\tPerl_pregexec(aTHX_ a,b,c,d,e,f,g)\n#define pregfree(a)\t\tPerl_pregfree(aTHX_ a)\n#define pregfree2(a)\t\tPerl_pregfree2(aTHX_ a)\n#define prescan_version(a,b,c,d,e,f,g)\tPerl_prescan_version(aTHX_ a,b,c,d,e,f,g)\n#define ptr_table_clear(a)\tPerl_ptr_table_clear(aTHX_ a)\n#define ptr_table_fetch(a,b)\tPerl_ptr_table_fetch(aTHX_ a,b)\n#define ptr_table_free(a)\tPerl_ptr_table_free(aTHX_ a)\n#define ptr_table_new()\t\tPerl_ptr_table_new(aTHX)\n#define ptr_table_split(a)\tPerl_ptr_table_split(aTHX_ a)\n#define ptr_table_store(a,b,c)\tPerl_ptr_table_store(aTHX_ a,b,c)\n#define push_scope()\t\tPerl_push_scope(aTHX)\n#define pv_display(a,b,c,d,e)\tPerl_pv_display(aTHX_ a,b,c,d,e)\n#define pv_escape(a,b,c,d,e,f)\tPerl_pv_escape(aTHX_ a,b,c,d,e,f)\n#define pv_pretty(a,b,c,d,e,f,g)\tPerl_pv_pretty(aTHX_ a,b,c,d,e,f,g)\n#define pv_uni_display(a,b,c,d,e)\tPerl_pv_uni_display(aTHX_ a,b,c,d,e)\n#define re_compile(a,b)\t\tPerl_re_compile(aTHX_ a,b)\n#define re_intuit_start(a,b,c,d,e,f,g)\tPerl_re_intuit_start(aTHX_ a,b,c,d,e,f,g)\n#define re_intuit_string(a)\tPerl_re_intuit_string(aTHX_ a)\n#define reentrant_free()\tPerl_reentrant_free(aTHX)\n#define reentrant_init()\tPerl_reentrant_init(aTHX)\n#define reentrant_retry\t\tPerl_reentrant_retry\n#define reentrant_size()\tPerl_reentrant_size(aTHX)\n#define reg_named_buff_all(a,b)\tPerl_reg_named_buff_all(aTHX_ a,b)\n#define reg_named_buff_exists(a,b,c)\tPerl_reg_named_buff_exists(aTHX_ a,b,c)\n#define reg_named_buff_fetch(a,b,c)\tPerl_reg_named_buff_fetch(aTHX_ a,b,c)\n#define reg_named_buff_firstkey(a,b)\tPerl_reg_named_buff_firstkey(aTHX_ a,b)\n#define reg_named_buff_nextkey(a,b)\tPerl_reg_named_buff_nextkey(aTHX_ a,b)\n#define reg_named_buff_scalar(a,b)\tPerl_reg_named_buff_scalar(aTHX_ a,b)\n#define regdump(a)\t\tPerl_regdump(aTHX_ a)\n#define regexec_flags(a,b,c,d,e,f,g,h)\tPerl_regexec_flags(aTHX_ a,b,c,d,e,f,g,h)\n#define regfree_internal(a)\tPerl_regfree_internal(aTHX_ a)\n#define reginitcolors()\t\tPerl_reginitcolors(aTHX)\n#define regnext(a)\t\tPerl_regnext(aTHX_ a)\n#define repeatcpy\t\tPerl_repeatcpy\n#define require_pv(a)\t\tPerl_require_pv(aTHX_ a)\n#define rninstr\t\t\tPerl_rninstr\n#define rsignal(a,b)\t\tPerl_rsignal(aTHX_ a,b)\n#define rsignal_state(a)\tPerl_rsignal_state(aTHX_ a)\n#define runops_debug()\t\tPerl_runops_debug(aTHX)\n#define runops_standard()\tPerl_runops_standard(aTHX)\n#define rv2cv_op_cv(a,b)\tPerl_rv2cv_op_cv(aTHX_ a,b)\n#define safesyscalloc\t\tPerl_safesyscalloc\n#define safesysfree\t\tPerl_safesysfree\n#define safesysmalloc\t\tPerl_safesysmalloc\n#define safesysrealloc\t\tPerl_safesysrealloc\n#define save_I16(a)\t\tPerl_save_I16(aTHX_ a)\n#define save_I32(a)\t\tPerl_save_I32(aTHX_ a)\n#define save_I8(a)\t\tPerl_save_I8(aTHX_ a)\n#define save_adelete(a,b)\tPerl_save_adelete(aTHX_ a,b)\n#define save_aelem_flags(a,b,c,d)\tPerl_save_aelem_flags(aTHX_ a,b,c,d)\n#define save_alloc(a,b)\t\tPerl_save_alloc(aTHX_ a,b)\n#define save_aptr(a)\t\tPerl_save_aptr(aTHX_ a)\n#define save_ary(a)\t\tPerl_save_ary(aTHX_ a)\n#define save_bool(a)\t\tPerl_save_bool(aTHX_ a)\n#define save_clearsv(a)\t\tPerl_save_clearsv(aTHX_ a)\n#define save_delete(a,b,c)\tPerl_save_delete(aTHX_ a,b,c)\n#define save_destructor(a,b)\tPerl_save_destructor(aTHX_ a,b)\n#define save_destructor_x(a,b)\tPerl_save_destructor_x(aTHX_ a,b)\n#define save_generic_pvref(a)\tPerl_save_generic_pvref(aTHX_ a)\n#define save_generic_svref(a)\tPerl_save_generic_svref(aTHX_ a)\n#define save_gp(a,b)\t\tPerl_save_gp(aTHX_ a,b)\n#define save_hash(a)\t\tPerl_save_hash(aTHX_ a)\n#define save_hdelete(a,b)\tPerl_save_hdelete(aTHX_ a,b)\n#define save_helem_flags(a,b,c,d)\tPerl_save_helem_flags(aTHX_ a,b,c,d)\n#define save_hints()\t\tPerl_save_hints(aTHX)\n#define save_hptr(a)\t\tPerl_save_hptr(aTHX_ a)\n#define save_int(a)\t\tPerl_save_int(aTHX_ a)\n#define save_item(a)\t\tPerl_save_item(aTHX_ a)\n#define save_iv(a)\t\tPerl_save_iv(aTHX_ a)\n#ifndef NO_MATHOMS\n#define save_list(a,b)\t\tPerl_save_list(aTHX_ a,b)\n#endif\n#ifndef NO_MATHOMS\n#define save_long(a)\t\tPerl_save_long(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define save_nogv(a)\t\tPerl_save_nogv(aTHX_ a)\n#endif\n#define save_padsv_and_mortalize(a)\tPerl_save_padsv_and_mortalize(aTHX_ a)\n#define save_pptr(a)\t\tPerl_save_pptr(aTHX_ a)\n#define save_pushi32ptr(a,b,c)\tPerl_save_pushi32ptr(aTHX_ a,b,c)\n#define save_pushptr(a,b)\tPerl_save_pushptr(aTHX_ a,b)\n#define save_pushptrptr(a,b,c)\tPerl_save_pushptrptr(aTHX_ a,b,c)\n#define save_re_context()\tPerl_save_re_context(aTHX)\n#define save_scalar(a)\t\tPerl_save_scalar(aTHX_ a)\n#define save_set_svflags(a,b,c)\tPerl_save_set_svflags(aTHX_ a,b,c)\n#define save_shared_pvref(a)\tPerl_save_shared_pvref(aTHX_ a)\n#define save_sptr(a)\t\tPerl_save_sptr(aTHX_ a)\n#define save_svref(a)\t\tPerl_save_svref(aTHX_ a)\n#define save_vptr(a)\t\tPerl_save_vptr(aTHX_ a)\n#define savepv(a)\t\tPerl_savepv(aTHX_ a)\n#define savepvn(a,b)\t\tPerl_savepvn(aTHX_ a,b)\n#define savesharedpv(a)\t\tPerl_savesharedpv(aTHX_ a)\n#define savesharedpvn(a,b)\tPerl_savesharedpvn(aTHX_ a,b)\n#define savesharedsvpv(a)\tPerl_savesharedsvpv(aTHX_ a)\n#define savestack_grow()\tPerl_savestack_grow(aTHX)\n#define savestack_grow_cnt(a)\tPerl_savestack_grow_cnt(aTHX_ a)\n#define savesvpv(a)\t\tPerl_savesvpv(aTHX_ a)\n#define scan_bin(a,b,c)\t\tPerl_scan_bin(aTHX_ a,b,c)\n#define scan_hex(a,b,c)\t\tPerl_scan_hex(aTHX_ a,b,c)\n#define scan_num(a,b)\t\tPerl_scan_num(aTHX_ a,b)\n#define scan_oct(a,b,c)\t\tPerl_scan_oct(aTHX_ a,b,c)\n#define scan_version(a,b,c)\tPerl_scan_version(aTHX_ a,b,c)\n#define scan_vstring(a,b,c)\tPerl_scan_vstring(aTHX_ a,b,c)\n#define seed()\t\t\tPerl_seed(aTHX)\n#define set_context\t\tPerl_set_context\n#define setdefout(a)\t\tPerl_setdefout(aTHX_ a)\n#define share_hek(a,b,c)\tPerl_share_hek(aTHX_ a,b,c)\n#define sortsv(a,b,c)\t\tPerl_sortsv(aTHX_ a,b,c)\n#define sortsv_flags(a,b,c,d)\tPerl_sortsv_flags(aTHX_ a,b,c,d)\n#define stack_grow(a,b,c)\tPerl_stack_grow(aTHX_ a,b,c)\n#define start_subparse(a,b)\tPerl_start_subparse(aTHX_ a,b)\n#define str_to_version(a)\tPerl_str_to_version(aTHX_ a)\n#define sv_2bool_flags(a,b)\tPerl_sv_2bool_flags(aTHX_ a,b)\n#define sv_2cv(a,b,c,d)\t\tPerl_sv_2cv(aTHX_ a,b,c,d)\n#define sv_2io(a)\t\tPerl_sv_2io(aTHX_ a)\n#define sv_2iv_flags(a,b)\tPerl_sv_2iv_flags(aTHX_ a,b)\n#define sv_2mortal(a)\t\tPerl_sv_2mortal(aTHX_ a)\n#define sv_2nv_flags(a,b)\tPerl_sv_2nv_flags(aTHX_ a,b)\n#define sv_2pv_flags(a,b,c)\tPerl_sv_2pv_flags(aTHX_ a,b,c)\n#define sv_2pvbyte(a,b)\t\tPerl_sv_2pvbyte(aTHX_ a,b)\n#define sv_2pvutf8(a,b)\t\tPerl_sv_2pvutf8(aTHX_ a,b)\n#define sv_2uv_flags(a,b)\tPerl_sv_2uv_flags(aTHX_ a,b)\n#define sv_backoff\t\tPerl_sv_backoff\n#define sv_bless(a,b)\t\tPerl_sv_bless(aTHX_ a,b)\n#define sv_cat_decode(a,b,c,d,e,f)\tPerl_sv_cat_decode(aTHX_ a,b,c,d,e,f)\n#define sv_catpv(a,b)\t\tPerl_sv_catpv(aTHX_ a,b)\n#define sv_catpv_flags(a,b,c)\tPerl_sv_catpv_flags(aTHX_ a,b,c)\n#define sv_catpv_mg(a,b)\tPerl_sv_catpv_mg(aTHX_ a,b)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define sv_catpvf\t\tPerl_sv_catpvf\n#define sv_catpvf_mg\t\tPerl_sv_catpvf_mg\n#endif\n#define sv_catpvn_flags(a,b,c,d)\tPerl_sv_catpvn_flags(aTHX_ a,b,c,d)\n#define sv_catsv_flags(a,b,c)\tPerl_sv_catsv_flags(aTHX_ a,b,c)\n#define sv_chop(a,b)\t\tPerl_sv_chop(aTHX_ a,b)\n#define sv_clear(a)\t\tPerl_sv_clear(aTHX_ a)\n#define sv_cmp_flags(a,b,c)\tPerl_sv_cmp_flags(aTHX_ a,b,c)\n#define sv_cmp_locale_flags(a,b,c)\tPerl_sv_cmp_locale_flags(aTHX_ a,b,c)\n#define sv_copypv_flags(a,b,c)\tPerl_sv_copypv_flags(aTHX_ a,b,c)\n#define sv_dec(a)\t\tPerl_sv_dec(aTHX_ a)\n#define sv_dec_nomg(a)\t\tPerl_sv_dec_nomg(aTHX_ a)\n#define sv_derived_from(a,b)\tPerl_sv_derived_from(aTHX_ a,b)\n#define sv_derived_from_pv(a,b,c)\tPerl_sv_derived_from_pv(aTHX_ a,b,c)\n#define sv_derived_from_pvn(a,b,c,d)\tPerl_sv_derived_from_pvn(aTHX_ a,b,c,d)\n#define sv_derived_from_sv(a,b,c)\tPerl_sv_derived_from_sv(aTHX_ a,b,c)\n#define sv_destroyable(a)\tPerl_sv_destroyable(aTHX_ a)\n#define sv_does(a,b)\t\tPerl_sv_does(aTHX_ a,b)\n#define sv_does_pv(a,b,c)\tPerl_sv_does_pv(aTHX_ a,b,c)\n#define sv_does_pvn(a,b,c,d)\tPerl_sv_does_pvn(aTHX_ a,b,c,d)\n#define sv_does_sv(a,b,c)\tPerl_sv_does_sv(aTHX_ a,b,c)\n#define sv_dump(a)\t\tPerl_sv_dump(aTHX_ a)\n#define sv_eq_flags(a,b,c)\tPerl_sv_eq_flags(aTHX_ a,b,c)\n#define sv_force_normal_flags(a,b)\tPerl_sv_force_normal_flags(aTHX_ a,b)\n#define sv_free(a)\t\tPerl_sv_free(aTHX_ a)\n#define sv_get_backrefs\t\tPerl_sv_get_backrefs\n#define sv_gets(a,b,c)\t\tPerl_sv_gets(aTHX_ a,b,c)\n#define sv_grow(a,b)\t\tPerl_sv_grow(aTHX_ a,b)\n#define sv_inc(a)\t\tPerl_sv_inc(aTHX_ a)\n#define sv_inc_nomg(a)\t\tPerl_sv_inc_nomg(aTHX_ a)\n#define sv_insert_flags(a,b,c,d,e,f)\tPerl_sv_insert_flags(aTHX_ a,b,c,d,e,f)\n#define sv_isa(a,b)\t\tPerl_sv_isa(aTHX_ a,b)\n#define sv_isobject(a)\t\tPerl_sv_isobject(aTHX_ a)\n#ifndef NO_MATHOMS\n#define sv_iv(a)\t\tPerl_sv_iv(aTHX_ a)\n#endif\n#define sv_len(a)\t\tPerl_sv_len(aTHX_ a)\n#define sv_len_utf8(a)\t\tPerl_sv_len_utf8(aTHX_ a)\n#define sv_magic(a,b,c,d,e)\tPerl_sv_magic(aTHX_ a,b,c,d,e)\n#define sv_magicext(a,b,c,d,e,f)\tPerl_sv_magicext(aTHX_ a,b,c,d,e,f)\n#define sv_newmortal()\t\tPerl_sv_newmortal(aTHX)\n#define sv_newref(a)\t\tPerl_sv_newref(aTHX_ a)\n#define sv_nosharing(a)\t\tPerl_sv_nosharing(aTHX_ a)\n#ifndef NO_MATHOMS\n#define sv_nounlocking(a)\tPerl_sv_nounlocking(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define sv_nv(a)\t\tPerl_sv_nv(aTHX_ a)\n#endif\n#define sv_peek(a)\t\tPerl_sv_peek(aTHX_ a)\n#define sv_pos_b2u(a,b)\t\tPerl_sv_pos_b2u(aTHX_ a,b)\n#define sv_pos_b2u_flags(a,b,c)\tPerl_sv_pos_b2u_flags(aTHX_ a,b,c)\n#define sv_pos_u2b(a,b,c)\tPerl_sv_pos_u2b(aTHX_ a,b,c)\n#define sv_pos_u2b_flags(a,b,c,d)\tPerl_sv_pos_u2b_flags(aTHX_ a,b,c,d)\n#ifndef NO_MATHOMS\n#define sv_pvbyten(a,b)\t\tPerl_sv_pvbyten(aTHX_ a,b)\n#endif\n#define sv_pvbyten_force(a,b)\tPerl_sv_pvbyten_force(aTHX_ a,b)\n#ifndef NO_MATHOMS\n#define sv_pvn(a,b)\t\tPerl_sv_pvn(aTHX_ a,b)\n#endif\n#define sv_pvn_force_flags(a,b,c)\tPerl_sv_pvn_force_flags(aTHX_ a,b,c)\n#ifndef NO_MATHOMS\n#define sv_pvn_nomg(a,b)\tPerl_sv_pvn_nomg(aTHX_ a,b)\n#endif\n#ifndef NO_MATHOMS\n#define sv_pvutf8n(a,b)\t\tPerl_sv_pvutf8n(aTHX_ a,b)\n#endif\n#define sv_pvutf8n_force(a,b)\tPerl_sv_pvutf8n_force(aTHX_ a,b)\n#define sv_recode_to_utf8(a,b)\tPerl_sv_recode_to_utf8(aTHX_ a,b)\n#define sv_ref(a,b,c)\t\tPerl_sv_ref(aTHX_ a,b,c)\n#define sv_reftype(a,b)\t\tPerl_sv_reftype(aTHX_ a,b)\n#define sv_replace(a,b)\t\tPerl_sv_replace(aTHX_ a,b)\n#define sv_report_used()\tPerl_sv_report_used(aTHX)\n#define sv_reset(a,b)\t\tPerl_sv_reset(aTHX_ a,b)\n#define sv_rvunweaken(a)\tPerl_sv_rvunweaken(aTHX_ a)\n#define sv_rvweaken(a)\t\tPerl_sv_rvweaken(aTHX_ a)\n#define sv_set_undef(a)\t\tPerl_sv_set_undef(aTHX_ a)\n#define sv_setiv(a,b)\t\tPerl_sv_setiv(aTHX_ a,b)\n#define sv_setiv_mg(a,b)\tPerl_sv_setiv_mg(aTHX_ a,b)\n#define sv_setnv(a,b)\t\tPerl_sv_setnv(aTHX_ a,b)\n#define sv_setnv_mg(a,b)\tPerl_sv_setnv_mg(aTHX_ a,b)\n#define sv_setpv(a,b)\t\tPerl_sv_setpv(aTHX_ a,b)\n#define sv_setpv_bufsize(a,b,c)\tPerl_sv_setpv_bufsize(aTHX_ a,b,c)\n#define sv_setpv_mg(a,b)\tPerl_sv_setpv_mg(aTHX_ a,b)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define sv_setpvf\t\tPerl_sv_setpvf\n#define sv_setpvf_mg\t\tPerl_sv_setpvf_mg\n#endif\n#ifndef NO_MATHOMS\n#define sv_setpviv(a,b)\t\tPerl_sv_setpviv(aTHX_ a,b)\n#endif\n#ifndef NO_MATHOMS\n#define sv_setpviv_mg(a,b)\tPerl_sv_setpviv_mg(aTHX_ a,b)\n#endif\n#define sv_setpvn(a,b,c)\tPerl_sv_setpvn(aTHX_ a,b,c)\n#define sv_setpvn_mg(a,b,c)\tPerl_sv_setpvn_mg(aTHX_ a,b,c)\n#define sv_setref_iv(a,b,c)\tPerl_sv_setref_iv(aTHX_ a,b,c)\n#define sv_setref_nv(a,b,c)\tPerl_sv_setref_nv(aTHX_ a,b,c)\n#define sv_setref_pv(a,b,c)\tPerl_sv_setref_pv(aTHX_ a,b,c)\n#define sv_setref_pvn(a,b,c,d)\tPerl_sv_setref_pvn(aTHX_ a,b,c,d)\n#define sv_setref_uv(a,b,c)\tPerl_sv_setref_uv(aTHX_ a,b,c)\n#define sv_setsv_flags(a,b,c)\tPerl_sv_setsv_flags(aTHX_ a,b,c)\n#define sv_setsv_mg(a,b)\tPerl_sv_setsv_mg(aTHX_ a,b)\n#define sv_setuv(a,b)\t\tPerl_sv_setuv(aTHX_ a,b)\n#define sv_setuv_mg(a,b)\tPerl_sv_setuv_mg(aTHX_ a,b)\n#define sv_string_from_errnum(a,b)\tPerl_sv_string_from_errnum(aTHX_ a,b)\n#define sv_tainted(a)\t\tPerl_sv_tainted(aTHX_ a)\n#define sv_true(a)\t\tPerl_sv_true(aTHX_ a)\n#define sv_uni_display(a,b,c,d)\tPerl_sv_uni_display(aTHX_ a,b,c,d)\n#define sv_unmagic(a,b)\t\tPerl_sv_unmagic(aTHX_ a,b)\n#define sv_unmagicext(a,b,c)\tPerl_sv_unmagicext(aTHX_ a,b,c)\n#define sv_unref_flags(a,b)\tPerl_sv_unref_flags(aTHX_ a,b)\n#define sv_untaint(a)\t\tPerl_sv_untaint(aTHX_ a)\n#define sv_upgrade(a,b)\t\tPerl_sv_upgrade(aTHX_ a,b)\n#define sv_usepvn_flags(a,b,c,d)\tPerl_sv_usepvn_flags(aTHX_ a,b,c,d)\n#define sv_utf8_decode(a)\tPerl_sv_utf8_decode(aTHX_ a)\n#define sv_utf8_downgrade(a,b)\tPerl_sv_utf8_downgrade(aTHX_ a,b)\n#define sv_utf8_encode(a)\tPerl_sv_utf8_encode(aTHX_ a)\n#define sv_utf8_upgrade_flags_grow(a,b,c)\tPerl_sv_utf8_upgrade_flags_grow(aTHX_ a,b,c)\n#ifndef NO_MATHOMS\n#define sv_uv(a)\t\tPerl_sv_uv(aTHX_ a)\n#endif\n#define sv_vcatpvf(a,b,c)\tPerl_sv_vcatpvf(aTHX_ a,b,c)\n#define sv_vcatpvf_mg(a,b,c)\tPerl_sv_vcatpvf_mg(aTHX_ a,b,c)\n#define sv_vcatpvfn(a,b,c,d,e,f,g)\tPerl_sv_vcatpvfn(aTHX_ a,b,c,d,e,f,g)\n#define sv_vcatpvfn_flags(a,b,c,d,e,f,g,h)\tPerl_sv_vcatpvfn_flags(aTHX_ a,b,c,d,e,f,g,h)\n#define sv_vsetpvf(a,b,c)\tPerl_sv_vsetpvf(aTHX_ a,b,c)\n#define sv_vsetpvf_mg(a,b,c)\tPerl_sv_vsetpvf_mg(aTHX_ a,b,c)\n#define sv_vsetpvfn(a,b,c,d,e,f,g)\tPerl_sv_vsetpvfn(aTHX_ a,b,c,d,e,f,g)\n#define switch_to_global_locale\tPerl_switch_to_global_locale\n#define sync_locale\t\tPerl_sync_locale\n#define taint_env()\t\tPerl_taint_env(aTHX)\n#define taint_proper(a,b)\tPerl_taint_proper(aTHX_ a,b)\n#define thread_locale_init\tPerl_thread_locale_init\n#define thread_locale_term\tPerl_thread_locale_term\n#define to_uni_lower(a,b,c)\tPerl_to_uni_lower(aTHX_ a,b,c)\n#ifndef NO_MATHOMS\n#define to_uni_lower_lc(a)\tPerl_to_uni_lower_lc(aTHX_ a)\n#endif\n#define to_uni_title(a,b,c)\tPerl_to_uni_title(aTHX_ a,b,c)\n#ifndef NO_MATHOMS\n#define to_uni_title_lc(a)\tPerl_to_uni_title_lc(aTHX_ a)\n#endif\n#define to_uni_upper(a,b,c)\tPerl_to_uni_upper(aTHX_ a,b,c)\n#ifndef NO_MATHOMS\n#define to_uni_upper_lc(a)\tPerl_to_uni_upper_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define unpack_str(a,b,c,d,e,f,g,h)\tPerl_unpack_str(aTHX_ a,b,c,d,e,f,g,h)\n#endif\n#define unpackstring(a,b,c,d,e)\tPerl_unpackstring(aTHX_ a,b,c,d,e)\n#define unsharepvn(a,b,c)\tPerl_unsharepvn(aTHX_ a,b,c)\n#define upg_version(a,b)\tPerl_upg_version(aTHX_ a,b)\n#define utf8_distance(a,b)\tPerl_utf8_distance(aTHX_ a,b)\n#define utf8_hop\t\tPerl_utf8_hop\n#define utf8_hop_back\t\tPerl_utf8_hop_back\n#define utf8_hop_forward\tPerl_utf8_hop_forward\n#define utf8_hop_safe\t\tPerl_utf8_hop_safe\n#define utf8_length(a,b)\tPerl_utf8_length(aTHX_ a,b)\n#define utf8_to_bytes(a,b)\tPerl_utf8_to_bytes(aTHX_ a,b)\n#define utf8_to_uvchr(a,b)\tPerl_utf8_to_uvchr(aTHX_ a,b)\n#ifndef NO_MATHOMS\n#define utf8_to_uvuni(a,b)\tPerl_utf8_to_uvuni(aTHX_ a,b)\n#endif\n#define utf8_to_uvuni_buf(a,b,c)\tPerl_utf8_to_uvuni_buf(aTHX_ a,b,c)\n#define utf8n_to_uvchr_msgs\tS_utf8n_to_uvchr_msgs\n#define utf8n_to_uvuni(a,b,c,d)\tPerl_utf8n_to_uvuni(aTHX_ a,b,c,d)\n#define uvoffuni_to_utf8_flags_msgs(a,b,c,d)\tPerl_uvoffuni_to_utf8_flags_msgs(aTHX_ a,b,c,d)\n#define uvuni_to_utf8(a,b)\tPerl_uvuni_to_utf8(aTHX_ a,b)\n#define uvuni_to_utf8_flags(a,b,c)\tPerl_uvuni_to_utf8_flags(aTHX_ a,b,c)\n#define valid_utf8_to_uvchr\tPerl_valid_utf8_to_uvchr\n#ifndef NO_MATHOMS\n#define valid_utf8_to_uvuni(a,b)\tPerl_valid_utf8_to_uvuni(aTHX_ a,b)\n#endif\n#define vcmp(a,b)\t\tPerl_vcmp(aTHX_ a,b)\n#define vcroak(a,b)\t\tPerl_vcroak(aTHX_ a,b)\n#define vdeb(a,b)\t\tPerl_vdeb(aTHX_ a,b)\n#define vform(a,b)\t\tPerl_vform(aTHX_ a,b)\n#define vload_module(a,b,c,d)\tPerl_vload_module(aTHX_ a,b,c,d)\n#define vmess(a,b)\t\tPerl_vmess(aTHX_ a,b)\n#define vnewSVpvf(a,b)\t\tPerl_vnewSVpvf(aTHX_ a,b)\n#define vnormal(a)\t\tPerl_vnormal(aTHX_ a)\n#define vnumify(a)\t\tPerl_vnumify(aTHX_ a)\n#define vstringify(a)\t\tPerl_vstringify(aTHX_ a)\n#define vverify(a)\t\tPerl_vverify(aTHX_ a)\n#define vwarn(a,b)\t\tPerl_vwarn(aTHX_ a,b)\n#define vwarner(a,b,c)\t\tPerl_vwarner(aTHX_ a,b,c)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define warn\t\t\tPerl_warn\n#endif\n#define warn_sv(a)\t\tPerl_warn_sv(aTHX_ a)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define warner\t\t\tPerl_warner\n#endif\n#define whichsig_pv(a)\t\tPerl_whichsig_pv(aTHX_ a)\n#define whichsig_pvn(a,b)\tPerl_whichsig_pvn(aTHX_ a,b)\n#define whichsig_sv(a)\t\tPerl_whichsig_sv(aTHX_ a)\n#define wrap_keyword_plugin(a,b)\tPerl_wrap_keyword_plugin(aTHX_ a,b)\n#define wrap_op_checker(a,b,c)\tPerl_wrap_op_checker(aTHX_ a,b,c)\n#if !(defined(HAS_MEMMEM))\n#define ninstr\t\t\tPerl_ninstr\n#endif\n#if !(defined(HAS_SIGACTION) && defined(SA_SIGINFO))\n#define csighandler\t\tPerl_csighandler\n#endif\n#if !defined(EBCDIC)\n#define _variant_byte_number\tS__variant_byte_number\n#endif\n#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)\n#define my_chsize(a,b)\t\tPerl_my_chsize(aTHX_ a,b)\n#endif\n#if !defined(PERL_IMPLICIT_SYS)\n#define my_pclose(a)\t\tPerl_my_pclose(aTHX_ a)\n#define my_popen(a,b)\t\tPerl_my_popen(aTHX_ a,b)\n#endif\n#if !defined(PERL_NO_INLINE_FUNCTIONS)\n#define cx_popblock(a)\t\tS_cx_popblock(aTHX_ a)\n#define cx_popeval(a)\t\tS_cx_popeval(aTHX_ a)\n#define cx_popformat(a)\t\tS_cx_popformat(aTHX_ a)\n#define cx_popgiven(a)\t\tS_cx_popgiven(aTHX_ a)\n#define cx_poploop(a)\t\tS_cx_poploop(aTHX_ a)\n#define cx_popsub(a)\t\tS_cx_popsub(aTHX_ a)\n#define cx_popsub_args(a)\tS_cx_popsub_args(aTHX_ a)\n#define cx_popsub_common(a)\tS_cx_popsub_common(aTHX_ a)\n#define cx_popwhen(a)\t\tS_cx_popwhen(aTHX_ a)\n#define cx_pushblock(a,b,c,d)\tS_cx_pushblock(aTHX_ a,b,c,d)\n#define cx_pusheval(a,b,c)\tS_cx_pusheval(aTHX_ a,b,c)\n#define cx_pushformat(a,b,c,d)\tS_cx_pushformat(aTHX_ a,b,c,d)\n#define cx_pushgiven(a,b)\tS_cx_pushgiven(aTHX_ a,b)\n#define cx_pushloop_for(a,b,c)\tS_cx_pushloop_for(aTHX_ a,b,c)\n#define cx_pushloop_plain(a)\tS_cx_pushloop_plain(aTHX_ a)\n#define cx_pushsub(a,b,c,d)\tS_cx_pushsub(aTHX_ a,b,c,d)\n#define cx_pushwhen(a)\t\tS_cx_pushwhen(aTHX_ a)\n#define cx_topblock(a)\t\tS_cx_topblock(aTHX_ a)\n#endif\n#if defined(DEBUGGING)\n#define pad_setsv(a,b)\t\tPerl_pad_setsv(aTHX_ a,b)\n#define pad_sv(a)\t\tPerl_pad_sv(aTHX_ a)\n#endif\n#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)\n#define csighandler\t\tPerl_csighandler\n#endif\n#if defined(HAVE_INTERP_INTERN)\n#define sys_intern_clear()\tPerl_sys_intern_clear(aTHX)\n#define sys_intern_init()\tPerl_sys_intern_init(aTHX)\n#  if defined(USE_ITHREADS)\n#define sys_intern_dup(a,b)\tPerl_sys_intern_dup(aTHX_ a,b)\n#  endif\n#endif\n#if defined(MYMALLOC)\n#define dump_mstats(a)\t\tPerl_dump_mstats(aTHX_ a)\n#define get_mstats(a,b,c)\tPerl_get_mstats(aTHX_ a,b,c)\n#endif\n#if defined(PERL_GLOBAL_STRUCT)\n#define GetVars()\t\tPerl_GetVars(aTHX)\n#define free_global_struct(a)\tPerl_free_global_struct(aTHX_ a)\n#define init_global_struct()\tPerl_init_global_struct(aTHX)\n#endif\n#if defined(PERL_IMPLICIT_CONTEXT)\n#define croak_nocontext\t\tPerl_croak_nocontext\n#define deb_nocontext\t\tPerl_deb_nocontext\n#define die_nocontext\t\tPerl_die_nocontext\n#define form_nocontext\t\tPerl_form_nocontext\n#ifndef NO_MATHOMS\n#define fprintf_nocontext\tPerl_fprintf_nocontext\n#endif\n#define load_module_nocontext\tPerl_load_module_nocontext\n#define mess_nocontext\t\tPerl_mess_nocontext\n#define newSVpvf_nocontext\tPerl_newSVpvf_nocontext\n#ifndef NO_MATHOMS\n#define printf_nocontext\tPerl_printf_nocontext\n#endif\n#define sv_catpvf_mg_nocontext\tPerl_sv_catpvf_mg_nocontext\n#define sv_catpvf_nocontext\tPerl_sv_catpvf_nocontext\n#define sv_setpvf_mg_nocontext\tPerl_sv_setpvf_mg_nocontext\n#define sv_setpvf_nocontext\tPerl_sv_setpvf_nocontext\n#define warn_nocontext\t\tPerl_warn_nocontext\n#define warner_nocontext\tPerl_warner_nocontext\n#endif\n#if defined(UNLINK_ALL_VERSIONS)\n#define unlnk(a)\t\tPerl_unlnk(aTHX_ a)\n#endif\n#if defined(USE_C_BACKTRACE)\n#define dump_c_backtrace(a,b,c)\tPerl_dump_c_backtrace(aTHX_ a,b,c)\n#define get_c_backtrace_dump(a,b)\tPerl_get_c_backtrace_dump(aTHX_ a,b)\n#endif\n#if defined(USE_ITHREADS)\n#define alloccopstash(a)\tPerl_alloccopstash(aTHX_ a)\n#define any_dup(a,b)\t\tPerl_any_dup(aTHX_ a,b)\n#define cx_dup(a,b,c,d)\t\tPerl_cx_dup(aTHX_ a,b,c,d)\n#define dirp_dup(a,b)\t\tPerl_dirp_dup(aTHX_ a,b)\n#define fp_dup(a,b,c)\t\tPerl_fp_dup(aTHX_ a,b,c)\n#define gp_dup(a,b)\t\tPerl_gp_dup(aTHX_ a,b)\n#define he_dup(a,b,c)\t\tPerl_he_dup(aTHX_ a,b,c)\n#define hek_dup(a,b)\t\tPerl_hek_dup(aTHX_ a,b)\n#define mg_dup(a,b)\t\tPerl_mg_dup(aTHX_ a,b)\n#define newPADOP(a,b,c)\t\tPerl_newPADOP(aTHX_ a,b,c)\n#define parser_dup(a,b)\t\tPerl_parser_dup(aTHX_ a,b)\n#define re_dup_guts(a,b,c)\tPerl_re_dup_guts(aTHX_ a,b,c)\n#define regdupe_internal(a,b)\tPerl_regdupe_internal(aTHX_ a,b)\n#define rvpv_dup(a,b,c)\t\tPerl_rvpv_dup(aTHX_ a,b,c)\n#define si_dup(a,b)\t\tPerl_si_dup(aTHX_ a,b)\n#define ss_dup(a,b)\t\tPerl_ss_dup(aTHX_ a,b)\n#define sv_dup(a,b)\t\tPerl_sv_dup(aTHX_ a,b)\n#define sv_dup_inc(a,b)\t\tPerl_sv_dup_inc(aTHX_ a,b)\n#endif\n#if defined(USE_LOCALE)\t\t    && (   defined(PERL_IN_LOCALE_C)\t        || defined(PERL_IN_MG_C)\t\t|| defined (PERL_EXT_POSIX)\t\t|| defined (PERL_EXT_LANGINFO))\n#define _is_cur_LC_category_utf8(a)\tPerl__is_cur_LC_category_utf8(aTHX_ a)\n#endif\n#if defined(USE_LOCALE_COLLATE)\n#define sv_collxfrm_flags(a,b,c)\tPerl_sv_collxfrm_flags(aTHX_ a,b,c)\n#endif\n#if defined(USE_PERLIO)\n#define PerlIO_clearerr(a)\tPerl_PerlIO_clearerr(aTHX_ a)\n#define PerlIO_close(a)\t\tPerl_PerlIO_close(aTHX_ a)\n#define PerlIO_eof(a)\t\tPerl_PerlIO_eof(aTHX_ a)\n#define PerlIO_error(a)\t\tPerl_PerlIO_error(aTHX_ a)\n#define PerlIO_fileno(a)\tPerl_PerlIO_fileno(aTHX_ a)\n#define PerlIO_fill(a)\t\tPerl_PerlIO_fill(aTHX_ a)\n#define PerlIO_flush(a)\t\tPerl_PerlIO_flush(aTHX_ a)\n#define PerlIO_get_base(a)\tPerl_PerlIO_get_base(aTHX_ a)\n#define PerlIO_get_bufsiz(a)\tPerl_PerlIO_get_bufsiz(aTHX_ a)\n#define PerlIO_get_cnt(a)\tPerl_PerlIO_get_cnt(aTHX_ a)\n#define PerlIO_get_ptr(a)\tPerl_PerlIO_get_ptr(aTHX_ a)\n#define PerlIO_read(a,b,c)\tPerl_PerlIO_read(aTHX_ a,b,c)\n#define PerlIO_seek(a,b,c)\tPerl_PerlIO_seek(aTHX_ a,b,c)\n#define PerlIO_set_cnt(a,b)\tPerl_PerlIO_set_cnt(aTHX_ a,b)\n#define PerlIO_set_ptrcnt(a,b,c)\tPerl_PerlIO_set_ptrcnt(aTHX_ a,b,c)\n#define PerlIO_setlinebuf(a)\tPerl_PerlIO_setlinebuf(aTHX_ a)\n#define PerlIO_stderr()\t\tPerl_PerlIO_stderr(aTHX)\n#define PerlIO_stdin()\t\tPerl_PerlIO_stdin(aTHX)\n#define PerlIO_stdout()\t\tPerl_PerlIO_stdout(aTHX)\n#define PerlIO_tell(a)\t\tPerl_PerlIO_tell(aTHX_ a)\n#define PerlIO_unread(a,b,c)\tPerl_PerlIO_unread(aTHX_ a,b,c)\n#define PerlIO_write(a,b,c)\tPerl_PerlIO_write(aTHX_ a,b,c)\n#endif\n#if defined(USE_QUADMATH)\n#define quadmath_format_needed\tPerl_quadmath_format_needed\n#define quadmath_format_single\tPerl_quadmath_format_single\n#endif\n#if defined(WIN32) || defined(__SYMBIAN32__) || defined(VMS)\n#define do_aspawn(a,b,c)\tPerl_do_aspawn(aTHX_ a,b,c)\n#define do_spawn(a)\t\tPerl_do_spawn(aTHX_ a)\n#define do_spawn_nowait(a)\tPerl_do_spawn_nowait(aTHX_ a)\n#endif\n#if defined(PERL_CORE) || defined(PERL_EXT)\n#define _byte_dump_string(a,b,c)\tPerl__byte_dump_string(aTHX_ a,b,c)\n#define _inverse_folds(a,b,c)\tPerl__inverse_folds(aTHX_ a,b,c)\n#define append_utf8_from_native_byte\tS_append_utf8_from_native_byte\n#define av_reify(a)\t\tPerl_av_reify(aTHX_ a)\n#define current_re_engine()\tPerl_current_re_engine(aTHX)\n#define cv_ckproto_len_flags(a,b,c,d,e)\tPerl_cv_ckproto_len_flags(aTHX_ a,b,c,d,e)\n#define get_and_check_backslash_N_name(a,b,c,d)\tPerl_get_and_check_backslash_N_name(aTHX_ a,b,c,d)\n#define grok_atoUV\t\tPerl_grok_atoUV\n#define mg_find_mglob(a)\tPerl_mg_find_mglob(aTHX_ a)\n#define multiconcat_stringify(a)\tPerl_multiconcat_stringify(aTHX_ a)\n#define multideref_stringify(a,b)\tPerl_multideref_stringify(aTHX_ a,b)\n#define op_clear(a)\t\tPerl_op_clear(aTHX_ a)\n#define qerror(a)\t\tPerl_qerror(aTHX_ a)\n#define reg_named_buff(a,b,c,d)\tPerl_reg_named_buff(aTHX_ a,b,c,d)\n#define reg_named_buff_iter(a,b,c)\tPerl_reg_named_buff_iter(aTHX_ a,b,c)\n#define reg_numbered_buff_fetch(a,b,c)\tPerl_reg_numbered_buff_fetch(aTHX_ a,b,c)\n#define reg_numbered_buff_length(a,b,c)\tPerl_reg_numbered_buff_length(aTHX_ a,b,c)\n#define reg_numbered_buff_store(a,b,c)\tPerl_reg_numbered_buff_store(aTHX_ a,b,c)\n#define reg_qr_package(a)\tPerl_reg_qr_package(aTHX_ a)\n#define reg_temp_copy(a,b)\tPerl_reg_temp_copy(aTHX_ a,b)\n#define report_uninit(a)\tPerl_report_uninit(aTHX_ a)\n#define scan_str(a,b,c,d,e)\tPerl_scan_str(aTHX_ a,b,c,d,e)\n#define scan_word(a,b,c,d,e)\tPerl_scan_word(aTHX_ a,b,c,d,e)\n#define skipspace_flags(a,b)\tPerl_skipspace_flags(aTHX_ a,b)\n#define sv_magicext_mglob(a)\tPerl_sv_magicext_mglob(aTHX_ a)\n#define sv_only_taint_gmagic\tS_sv_only_taint_gmagic\n#define swash_fetch(a,b,c)\tPerl_swash_fetch(aTHX_ a,b,c)\n#define swash_init(a,b,c,d,e)\tPerl_swash_init(aTHX_ a,b,c,d,e)\n#define utf16_to_utf8(a,b,c,d)\tPerl_utf16_to_utf8(aTHX_ a,b,c,d)\n#define utf16_to_utf8_reversed(a,b,c,d)\tPerl_utf16_to_utf8_reversed(aTHX_ a,b,c,d)\n#define validate_proto(a,b,c,d)\tPerl_validate_proto(aTHX_ a,b,c,d)\n#define vivify_defelem(a)\tPerl_vivify_defelem(aTHX_ a)\n#define yylex()\t\t\tPerl_yylex(aTHX)\n#  if ! defined(HAS_MEMRCHR) && (defined(PERL_CORE) || defined(PERL_EXT))\n#define my_memrchr\t\tS_my_memrchr\n#  endif\n#  if !defined(PERL_EXT_RE_BUILD)\n#    if defined(PERL_IN_REGCOMP_C)\n#define _append_range_to_invlist(a,b,c)\tS__append_range_to_invlist(aTHX_ a,b,c)\n#define _invlist_array_init\tS__invlist_array_init\n#define get_invlist_previous_index_addr\tS_get_invlist_previous_index_addr\n#define invlist_clear(a)\tS_invlist_clear(aTHX_ a)\n#define invlist_extend(a,b)\tS_invlist_extend(aTHX_ a,b)\n#define invlist_max\t\tS_invlist_max\n#define invlist_previous_index\tS_invlist_previous_index\n#define invlist_replace_list_destroys_src(a,b)\tS_invlist_replace_list_destroys_src(aTHX_ a,b)\n#define invlist_set_len(a,b,c)\tS_invlist_set_len(aTHX_ a,b,c)\n#define invlist_set_previous_index\tS_invlist_set_previous_index\n#define invlist_trim\t\tS_invlist_trim\n#    endif\n#  endif\n#  if defined(DEBUGGING)\n#    if defined(PERL_IN_REGCOMP_C)\n#define dump_trie(a,b,c,d)\tS_dump_trie(aTHX_ a,b,c,d)\n#define dump_trie_interim_list(a,b,c,d,e)\tS_dump_trie_interim_list(aTHX_ a,b,c,d,e)\n#define dump_trie_interim_table(a,b,c,d,e)\tS_dump_trie_interim_table(aTHX_ a,b,c,d,e)\n#define dumpuntil(a,b,c,d,e,f,g,h)\tS_dumpuntil(aTHX_ a,b,c,d,e,f,g,h)\n#define put_charclass_bitmap_innards(a,b,c,d,e,f)\tS_put_charclass_bitmap_innards(aTHX_ a,b,c,d,e,f)\n#define put_charclass_bitmap_innards_common(a,b,c,d,e,f)\tS_put_charclass_bitmap_innards_common(aTHX_ a,b,c,d,e,f)\n#define put_charclass_bitmap_innards_invlist(a,b)\tS_put_charclass_bitmap_innards_invlist(aTHX_ a,b)\n#define put_code_point(a,b)\tS_put_code_point(aTHX_ a,b)\n#define put_range(a,b,c,d)\tS_put_range(aTHX_ a,b,c,d)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define re_indentf\t\tPerl_re_indentf\n#endif\n#define regdump_extflags(a,b)\tS_regdump_extflags(aTHX_ a,b)\n#define regdump_intflags(a,b)\tS_regdump_intflags(aTHX_ a,b)\n#define regtail_study(a,b,c,d)\tS_regtail_study(aTHX_ a,b,c,d)\n#    endif\n#    if defined(PERL_IN_REGEXEC_C)\n#define debug_start_match(a,b,c,d,e)\tS_debug_start_match(aTHX_ a,b,c,d,e)\n#define dump_exec_pos(a,b,c,d,e,f,g)\tS_dump_exec_pos(aTHX_ a,b,c,d,e,f,g)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define re_exec_indentf\t\tPerl_re_exec_indentf\n#endif\n#    endif\n#  endif\n#  if defined(DEBUGGING) && defined(ENABLE_REGEX_SETS_DEBUGGING)\n#    if defined(PERL_IN_REGCOMP_C)\n#define dump_regex_sets_structures(a,b,c,d)\tS_dump_regex_sets_structures(aTHX_ a,b,c,d)\n#    endif\n#  endif\n#  if defined(PERL_ANY_COW)\n#define sv_setsv_cow(a,b)\tPerl_sv_setsv_cow(aTHX_ a,b)\n#  endif\n#  if defined(PERL_CORE) || defined (PERL_EXT)\n#define is_utf8_non_invariant_string\tS_is_utf8_non_invariant_string\n#define sv_or_pv_pos_u2b(a,b,c,d)\tS_sv_or_pv_pos_u2b(aTHX_ a,b,c,d)\n#  endif\n#  if defined(PERL_CORE) || defined(PERL_EXT)\n#define isSCRIPT_RUN(a,b,c)\tPerl_isSCRIPT_RUN(aTHX_ a,b,c)\n#define variant_under_utf8_count\tS_variant_under_utf8_count\n#  endif\n#  if defined(PERL_IN_REGCOMP_C)\n#define _make_exactf_invlist(a,b)\tS__make_exactf_invlist(aTHX_ a,b)\n#define add_above_Latin1_folds(a,b,c)\tS_add_above_Latin1_folds(aTHX_ a,b,c)\n#define add_cp_to_invlist(a,b)\tS_add_cp_to_invlist(aTHX_ a,b)\n#define add_data\t\tS_add_data\n#define add_multi_match(a,b,c)\tS_add_multi_match(aTHX_ a,b,c)\n#define change_engine_size(a,b)\tS_change_engine_size(aTHX_ a,b)\n#define cntrl_to_mnemonic\tS_cntrl_to_mnemonic\n#define compute_EXACTish\tS_compute_EXACTish\n#define construct_ahocorasick_from_trie(a,b,c)\tS_construct_ahocorasick_from_trie(aTHX_ a,b,c)\n#define edit_distance\t\tS_edit_distance\n#define get_ANYOFM_contents(a)\tS_get_ANYOFM_contents(aTHX_ a)\n#define get_ANYOF_cp_list_for_ssc(a,b)\tS_get_ANYOF_cp_list_for_ssc(aTHX_ a,b)\n#define get_invlist_iter_addr\tS_get_invlist_iter_addr\n#define grok_bslash_N(a,b,c,d,e,f,g)\tS_grok_bslash_N(aTHX_ a,b,c,d,e,f,g)\n#define handle_named_backref(a,b,c,d)\tS_handle_named_backref(aTHX_ a,b,c,d)\n#define handle_possible_posix(a,b,c,d,e)\tS_handle_possible_posix(aTHX_ a,b,c,d,e)\n#define handle_regex_sets(a,b,c,d,e)\tS_handle_regex_sets(aTHX_ a,b,c,d,e)\n#define handle_user_defined_property(a,b,c,d,e,f,g,h,i,j)\tPerl_handle_user_defined_property(aTHX_ a,b,c,d,e,f,g,h,i,j)\n#define invlist_contents(a,b)\tS_invlist_contents(aTHX_ a,b)\n#define invlist_highest\t\tS_invlist_highest\n#define invlist_is_iterating\tS_invlist_is_iterating\n#define invlist_iterfinish\tS_invlist_iterfinish\n#define invlist_iterinit\tS_invlist_iterinit\n#define invlist_iternext\tS_invlist_iternext\n#define is_ssc_worth_it\t\tS_is_ssc_worth_it\n#define join_exact(a,b,c,d,e,f,g)\tS_join_exact(aTHX_ a,b,c,d,e,f,g)\n#define make_trie(a,b,c,d,e,f,g,h)\tS_make_trie(aTHX_ a,b,c,d,e,f,g,h)\n#define new_regcurly\t\tS_new_regcurly\n#define nextchar(a)\t\tS_nextchar(aTHX_ a)\n#define output_posix_warnings(a,b)\tS_output_posix_warnings(aTHX_ a,b)\n#define parse_lparen_question_flags(a)\tS_parse_lparen_question_flags(aTHX_ a)\n#define parse_uniprop_string(a,b,c,d,e,f,g,h,i)\tPerl_parse_uniprop_string(aTHX_ a,b,c,d,e,f,g,h,i)\n#define populate_ANYOF_from_invlist(a,b)\tS_populate_ANYOF_from_invlist(aTHX_ a,b)\n#define rck_elide_nothing(a)\tS_rck_elide_nothing(aTHX_ a)\n#define reg(a,b,c,d)\t\tS_reg(aTHX_ a,b,c,d)\n#define reg2Lanode(a,b,c,d)\tS_reg2Lanode(aTHX_ a,b,c,d)\n#define reg_node(a,b)\t\tS_reg_node(aTHX_ a,b)\n#define reg_scan_name(a,b)\tS_reg_scan_name(aTHX_ a,b)\n#define reg_skipcomment\t\tS_reg_skipcomment\n#define reganode(a,b,c)\t\tS_reganode(aTHX_ a,b,c)\n#define regatom(a,b,c)\t\tS_regatom(aTHX_ a,b,c)\n#define regbranch(a,b,c,d)\tS_regbranch(aTHX_ a,b,c,d)\n#define regclass(a,b,c,d,e,f,g,h,i)\tS_regclass(aTHX_ a,b,c,d,e,f,g,h,i)\n#define regex_set_precedence\tS_regex_set_precedence\n#define reginsert(a,b,c,d)\tS_reginsert(aTHX_ a,b,c,d)\n#define regnode_guts(a,b,c,d)\tS_regnode_guts(aTHX_ a,b,c,d)\n#define regpiece(a,b,c)\t\tS_regpiece(aTHX_ a,b,c)\n#define regtail(a,b,c,d)\tS_regtail(aTHX_ a,b,c,d)\n#define scan_commit(a,b,c,d)\tS_scan_commit(aTHX_ a,b,c,d)\n#define set_ANYOF_arg(a,b,c,d,e)\tS_set_ANYOF_arg(aTHX_ a,b,c,d,e)\n#define set_regex_pv(a,b)\tS_set_regex_pv(aTHX_ a,b)\n#define skip_to_be_ignored_text(a,b,c)\tS_skip_to_be_ignored_text(aTHX_ a,b,c)\n#define ssc_add_range(a,b,c)\tS_ssc_add_range(aTHX_ a,b,c)\n#define ssc_and(a,b,c)\t\tS_ssc_and(aTHX_ a,b,c)\n#define ssc_anything(a)\t\tS_ssc_anything(aTHX_ a)\n#define ssc_clear_locale\tS_ssc_clear_locale\n#define ssc_cp_and(a,b)\t\tS_ssc_cp_and(aTHX_ a,b)\n#define ssc_finalize(a,b)\tS_ssc_finalize(aTHX_ a,b)\n#define ssc_init(a,b)\t\tS_ssc_init(aTHX_ a,b)\n#define ssc_intersection(a,b,c)\tS_ssc_intersection(aTHX_ a,b,c)\n#define ssc_is_anything\t\tS_ssc_is_anything\n#define ssc_is_cp_posixl_init\tS_ssc_is_cp_posixl_init\n#define ssc_or(a,b,c)\t\tS_ssc_or(aTHX_ a,b,c)\n#define ssc_union(a,b,c)\tS_ssc_union(aTHX_ a,b,c)\n#define study_chunk(a,b,c,d,e,f,g,h,i,j,k)\tS_study_chunk(aTHX_ a,b,c,d,e,f,g,h,i,j,k)\n#  endif\n#  if defined(PERL_IN_REGCOMP_C) || defined (PERL_IN_DUMP_C)\n#define _invlist_dump(a,b,c,d)\tPerl__invlist_dump(aTHX_ a,b,c,d)\n#  endif\n#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_PERL_C) || defined(PERL_IN_UTF8_C)\n#define _invlistEQ(a,b,c)\tPerl__invlistEQ(aTHX_ a,b,c)\n#define _new_invlist_C_array(a)\tPerl__new_invlist_C_array(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)\n#define _get_regclass_nonbitmap_data(a,b,c,d,e,f)\tPerl__get_regclass_nonbitmap_data(aTHX_ a,b,c,d,e,f)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define re_printf\t\tPerl_re_printf\n#endif\n#define regprop(a,b,c,d,e)\tPerl_regprop(aTHX_ a,b,c,d,e)\n#  endif\n#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_TOKE_C) || defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)\n#define _invlist_contains_cp\tS__invlist_contains_cp\n#define _invlist_len\t\tS__invlist_len\n#define _invlist_search\t\tPerl__invlist_search\n#define get_invlist_offset_addr\tS_get_invlist_offset_addr\n#define invlist_array\t\tS_invlist_array\n#define is_invlist\t\tS_is_invlist\n#  endif\n#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_SV_C)\n#define invlist_clone(a,b)\tPerl_invlist_clone(aTHX_ a,b)\n#  endif\n#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_TOKE_C) || defined(PERL_IN_DQUOTE_C)\n#define form_short_octal_warning(a,b)\tS_form_short_octal_warning(aTHX_ a,b)\n#define grok_bslash_c(a,b)\tPerl_grok_bslash_c(aTHX_ a,b)\n#define grok_bslash_o(a,b,c,d,e,f,g,h)\tPerl_grok_bslash_o(aTHX_ a,b,c,d,e,f,g,h)\n#define grok_bslash_x(a,b,c,d,e,f,g,h)\tPerl_grok_bslash_x(aTHX_ a,b,c,d,e,f,g,h)\n#define regcurly\t\tS_regcurly\n#  endif\n#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_UTF8_C)\n#define _add_range_to_invlist(a,b,c)\tPerl__add_range_to_invlist(aTHX_ a,b,c)\n#define _invlist_intersection_maybe_complement_2nd(a,b,c,d)\tPerl__invlist_intersection_maybe_complement_2nd(aTHX_ a,b,c,d)\n#define _invlist_invert(a)\tPerl__invlist_invert(aTHX_ a)\n#define _invlist_union_maybe_complement_2nd(a,b,c,d)\tPerl__invlist_union_maybe_complement_2nd(aTHX_ a,b,c,d)\n#define _new_invlist(a)\t\tPerl__new_invlist(aTHX_ a)\n#define _setup_canned_invlist(a,b,c)\tPerl__setup_canned_invlist(aTHX_ a,b,c)\n#  endif\n#  if defined(PERL_IN_REGEXEC_C)\n#define advance_one_LB(a,b,c)\tS_advance_one_LB(aTHX_ a,b,c)\n#define advance_one_SB(a,b,c)\tS_advance_one_SB(aTHX_ a,b,c)\n#define advance_one_WB(a,b,c,d)\tS_advance_one_WB(aTHX_ a,b,c,d)\n#define backup_one_GCB(a,b,c)\tS_backup_one_GCB(aTHX_ a,b,c)\n#define backup_one_LB(a,b,c)\tS_backup_one_LB(aTHX_ a,b,c)\n#define backup_one_SB(a,b,c)\tS_backup_one_SB(aTHX_ a,b,c)\n#define backup_one_WB(a,b,c,d)\tS_backup_one_WB(aTHX_ a,b,c,d)\n#define find_byclass(a,b,c,d,e)\tS_find_byclass(aTHX_ a,b,c,d,e)\n#define find_next_masked\tS_find_next_masked\n#define find_span_end\t\tS_find_span_end\n#define find_span_end_mask\tS_find_span_end_mask\n#define foldEQ_latin1_s2_folded\tS_foldEQ_latin1_s2_folded\n#define isFOO_utf8_lc(a,b,c)\tS_isFOO_utf8_lc(aTHX_ a,b,c)\n#define isGCB(a,b,c,d,e)\tS_isGCB(aTHX_ a,b,c,d,e)\n#define isLB(a,b,c,d,e,f)\tS_isLB(aTHX_ a,b,c,d,e,f)\n#define isSB(a,b,c,d,e,f)\tS_isSB(aTHX_ a,b,c,d,e,f)\n#define isWB(a,b,c,d,e,f,g)\tS_isWB(aTHX_ a,b,c,d,e,f,g)\n#define reg_check_named_buff_matched\tS_reg_check_named_buff_matched\n#define regcp_restore(a,b,c)\tS_regcp_restore(aTHX_ a,b,c _aDEPTH)\n#define regcppop(a,b)\t\tS_regcppop(aTHX_ a,b _aDEPTH)\n#define regcppush(a,b,c)\tS_regcppush(aTHX_ a,b,c _aDEPTH)\n#define reghop3\t\t\tS_reghop3\n#define reghop4\t\t\tS_reghop4\n#define reghopmaybe3\t\tS_reghopmaybe3\n#define reginclass(a,b,c,d,e)\tS_reginclass(aTHX_ a,b,c,d,e)\n#define regmatch(a,b,c)\t\tS_regmatch(aTHX_ a,b,c)\n#define regrepeat(a,b,c,d,e,f)\tS_regrepeat(aTHX_ a,b,c,d,e,f _aDEPTH)\n#define regtry(a,b)\t\tS_regtry(aTHX_ a,b)\n#define to_byte_substr(a)\tS_to_byte_substr(aTHX_ a)\n#define to_utf8_substr(a)\tS_to_utf8_substr(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_TOKE_C)\n#define _is_grapheme(a,b,c,d)\tPerl__is_grapheme(aTHX_ a,b,c,d)\n#  endif\n#  if defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C)\n#define isFOO_lc(a,b)\t\tPerl_isFOO_lc(aTHX_ a,b)\n#  endif\n#  if defined(PERL_IN_UTF8_C) || defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)\n#define _to_fold_latin1\t\tPerl__to_fold_latin1\n#  endif\n#endif\n#ifdef PERL_CORE\n#define PerlLIO_dup2_cloexec(a,b)\tPerl_PerlLIO_dup2_cloexec(aTHX_ a,b)\n#define PerlLIO_dup_cloexec(a)\tPerl_PerlLIO_dup_cloexec(aTHX_ a)\n#define PerlLIO_open3_cloexec(a,b,c)\tPerl_PerlLIO_open3_cloexec(aTHX_ a,b,c)\n#define PerlLIO_open_cloexec(a,b)\tPerl_PerlLIO_open_cloexec(aTHX_ a,b)\n#define Slab_Alloc(a)\t\tPerl_Slab_Alloc(aTHX_ a)\n#define Slab_Free(a)\t\tPerl_Slab_Free(aTHX_ a)\n#define _is_in_locale_category(a,b)\tPerl__is_in_locale_category(aTHX_ a,b)\n#define _warn_problematic_locale\tPerl__warn_problematic_locale\n#define abort_execution(a,b)\tPerl_abort_execution(aTHX_ a,b)\n#define alloc_LOGOP(a,b,c)\tPerl_alloc_LOGOP(aTHX_ a,b,c)\n#define allocmy(a,b,c)\t\tPerl_allocmy(aTHX_ a,b,c)\n#define amagic_is_enabled(a)\tPerl_amagic_is_enabled(aTHX_ a)\n#define apply(a,b,c)\t\tPerl_apply(aTHX_ a,b,c)\n#define av_extend_guts(a,b,c,d,e)\tPerl_av_extend_guts(aTHX_ a,b,c,d,e)\n#define av_nonelem(a,b)\t\tPerl_av_nonelem(aTHX_ a,b)\n#define bind_match(a,b,c)\tPerl_bind_match(aTHX_ a,b,c)\n#define boot_core_PerlIO()\tPerl_boot_core_PerlIO(aTHX)\n#define boot_core_UNIVERSAL()\tPerl_boot_core_UNIVERSAL(aTHX)\n#define boot_core_mro()\t\tPerl_boot_core_mro(aTHX)\n#define cando(a,b,c)\t\tPerl_cando(aTHX_ a,b,c)\n#define check_utf8_print(a,b)\tPerl_check_utf8_print(aTHX_ a,b)\n#define ck_anoncode(a)\t\tPerl_ck_anoncode(aTHX_ a)\n#define ck_backtick(a)\t\tPerl_ck_backtick(aTHX_ a)\n#define ck_bitop(a)\t\tPerl_ck_bitop(aTHX_ a)\n#define ck_cmp(a)\t\tPerl_ck_cmp(aTHX_ a)\n#define ck_concat(a)\t\tPerl_ck_concat(aTHX_ a)\n#define ck_defined(a)\t\tPerl_ck_defined(aTHX_ a)\n#define ck_delete(a)\t\tPerl_ck_delete(aTHX_ a)\n#define ck_each(a)\t\tPerl_ck_each(aTHX_ a)\n#define ck_eof(a)\t\tPerl_ck_eof(aTHX_ a)\n#define ck_eval(a)\t\tPerl_ck_eval(aTHX_ a)\n#define ck_exec(a)\t\tPerl_ck_exec(aTHX_ a)\n#define ck_exists(a)\t\tPerl_ck_exists(aTHX_ a)\n#define ck_ftst(a)\t\tPerl_ck_ftst(aTHX_ a)\n#define ck_fun(a)\t\tPerl_ck_fun(aTHX_ a)\n#define ck_glob(a)\t\tPerl_ck_glob(aTHX_ a)\n#define ck_grep(a)\t\tPerl_ck_grep(aTHX_ a)\n#define ck_index(a)\t\tPerl_ck_index(aTHX_ a)\n#define ck_join(a)\t\tPerl_ck_join(aTHX_ a)\n#define ck_length(a)\t\tPerl_ck_length(aTHX_ a)\n#define ck_lfun(a)\t\tPerl_ck_lfun(aTHX_ a)\n#define ck_listiob(a)\t\tPerl_ck_listiob(aTHX_ a)\n#define ck_match(a)\t\tPerl_ck_match(aTHX_ a)\n#define ck_method(a)\t\tPerl_ck_method(aTHX_ a)\n#define ck_null(a)\t\tPerl_ck_null(aTHX_ a)\n#define ck_open(a)\t\tPerl_ck_open(aTHX_ a)\n#define ck_prototype(a)\t\tPerl_ck_prototype(aTHX_ a)\n#define ck_readline(a)\t\tPerl_ck_readline(aTHX_ a)\n#define ck_refassign(a)\t\tPerl_ck_refassign(aTHX_ a)\n#define ck_repeat(a)\t\tPerl_ck_repeat(aTHX_ a)\n#define ck_require(a)\t\tPerl_ck_require(aTHX_ a)\n#define ck_return(a)\t\tPerl_ck_return(aTHX_ a)\n#define ck_rfun(a)\t\tPerl_ck_rfun(aTHX_ a)\n#define ck_rvconst(a)\t\tPerl_ck_rvconst(aTHX_ a)\n#define ck_sassign(a)\t\tPerl_ck_sassign(aTHX_ a)\n#define ck_select(a)\t\tPerl_ck_select(aTHX_ a)\n#define ck_shift(a)\t\tPerl_ck_shift(aTHX_ a)\n#define ck_smartmatch(a)\tPerl_ck_smartmatch(aTHX_ a)\n#define ck_sort(a)\t\tPerl_ck_sort(aTHX_ a)\n#define ck_spair(a)\t\tPerl_ck_spair(aTHX_ a)\n#define ck_split(a)\t\tPerl_ck_split(aTHX_ a)\n#define ck_stringify(a)\t\tPerl_ck_stringify(aTHX_ a)\n#define ck_subr(a)\t\tPerl_ck_subr(aTHX_ a)\n#define ck_substr(a)\t\tPerl_ck_substr(aTHX_ a)\n#define ck_svconst(a)\t\tPerl_ck_svconst(aTHX_ a)\n#define ck_tell(a)\t\tPerl_ck_tell(aTHX_ a)\n#define ck_trunc(a)\t\tPerl_ck_trunc(aTHX_ a)\n#define closest_cop(a,b,c,d)\tPerl_closest_cop(aTHX_ a,b,c,d)\n#define core_prototype(a,b,c,d)\tPerl_core_prototype(aTHX_ a,b,c,d)\n#define coresub_op(a,b,c)\tPerl_coresub_op(aTHX_ a,b,c)\n#define create_eval_scope(a,b)\tPerl_create_eval_scope(aTHX_ a,b)\n#define croak_caller\t\tPerl_croak_caller\n#define croak_no_mem\t\tPerl_croak_no_mem\n#define croak_popstack\t\tPerl_croak_popstack\n#define custom_op_get_field(a,b)\tPerl_custom_op_get_field(aTHX_ a,b)\n#define cv_clone_into(a,b)\tPerl_cv_clone_into(aTHX_ a,b)\n#define cv_const_sv_or_av\tPerl_cv_const_sv_or_av\n#define cv_forget_slab(a)\tPerl_cv_forget_slab(aTHX_ a)\n#define cv_undef_flags(a,b)\tPerl_cv_undef_flags(aTHX_ a,b)\n#define cvgv_set(a,b)\t\tPerl_cvgv_set(aTHX_ a,b)\n#define cvstash_set(a,b)\tPerl_cvstash_set(aTHX_ a,b)\n#define deb_stack_all()\t\tPerl_deb_stack_all(aTHX)\n#define defelem_target(a,b)\tPerl_defelem_target(aTHX_ a,b)\n#define delete_eval_scope()\tPerl_delete_eval_scope(aTHX)\n#define delimcpy_no_escape\tPerl_delimcpy_no_escape\n#define die_unwind(a)\t\tPerl_die_unwind(aTHX_ a)\n#define do_aexec5(a,b,c,d,e)\tPerl_do_aexec5(aTHX_ a,b,c,d,e)\n#define do_dump_pad(a,b,c,d)\tPerl_do_dump_pad(aTHX_ a,b,c,d)\n#define do_eof(a)\t\tPerl_do_eof(aTHX_ a)\n#define do_ncmp(a,b)\t\tPerl_do_ncmp(aTHX_ a,b)\n#define do_open6(a,b,c,d,e,f)\tPerl_do_open6(aTHX_ a,b,c,d,e,f)\n#define do_open_raw(a,b,c,d,e,f)\tPerl_do_open_raw(aTHX_ a,b,c,d,e,f)\n#define do_print(a,b)\t\tPerl_do_print(aTHX_ a,b)\n#define do_readline()\t\tPerl_do_readline(aTHX)\n#define do_seek(a,b,c)\t\tPerl_do_seek(aTHX_ a,b,c)\n#define do_sysseek(a,b,c)\tPerl_do_sysseek(aTHX_ a,b,c)\n#define do_tell(a)\t\tPerl_do_tell(aTHX_ a)\n#define do_trans(a)\t\tPerl_do_trans(aTHX_ a)\n#define do_vecget(a,b,c)\tPerl_do_vecget(aTHX_ a,b,c)\n#define do_vecset(a)\t\tPerl_do_vecset(aTHX_ a)\n#define do_vop(a,b,c,d)\t\tPerl_do_vop(aTHX_ a,b,c,d)\n#define dofile(a,b)\t\tPerl_dofile(aTHX_ a,b)\n#define dump_all_perl(a)\tPerl_dump_all_perl(aTHX_ a)\n#define dump_packsubs_perl(a,b)\tPerl_dump_packsubs_perl(aTHX_ a,b)\n#define dump_sub_perl(a,b)\tPerl_dump_sub_perl(aTHX_ a,b)\n#define finalize_optree(a)\tPerl_finalize_optree(aTHX_ a)\n#define find_lexical_cv(a)\tPerl_find_lexical_cv(aTHX_ a)\n#define find_runcv_where(a,b,c)\tPerl_find_runcv_where(aTHX_ a,b,c)\n#define find_script(a,b,c,d)\tPerl_find_script(aTHX_ a,b,c,d)\n#define free_tied_hv_pool()\tPerl_free_tied_hv_pool(aTHX)\n#define get_hash_seed(a)\tPerl_get_hash_seed(aTHX_ a)\n#define get_no_modify()\t\tPerl_get_no_modify(aTHX)\n#define get_opargs()\t\tPerl_get_opargs(aTHX)\n#define gv_override(a,b)\tPerl_gv_override(aTHX_ a,b)\n#define gv_setref(a,b)\t\tPerl_gv_setref(aTHX_ a,b)\n#define gv_try_downgrade(a)\tPerl_gv_try_downgrade(aTHX_ a)\n#define hv_ename_add(a,b,c,d)\tPerl_hv_ename_add(aTHX_ a,b,c,d)\n#define hv_ename_delete(a,b,c,d)\tPerl_hv_ename_delete(aTHX_ a,b,c,d)\n#define hv_pushkv(a,b)\t\tPerl_hv_pushkv(aTHX_ a,b)\n#define init_argv_symbols(a,b)\tPerl_init_argv_symbols(aTHX_ a,b)\n#define init_constants()\tPerl_init_constants(aTHX)\n#define init_debugger()\t\tPerl_init_debugger(aTHX)\n#define init_named_cv(a,b)\tPerl_init_named_cv(aTHX_ a,b)\n#define init_uniprops()\t\tPerl_init_uniprops(aTHX)\n#define invert(a)\t\tPerl_invert(aTHX_ a)\n#define io_close(a,b,c,d)\tPerl_io_close(aTHX_ a,b,c,d)\n#define isinfnansv(a)\t\tPerl_isinfnansv(aTHX_ a)\n#define jmaybe(a)\t\tPerl_jmaybe(aTHX_ a)\n#define keyword(a,b,c)\t\tPerl_keyword(aTHX_ a,b,c)\n#define list(a)\t\t\tPerl_list(aTHX_ a)\n#define localize(a,b)\t\tPerl_localize(aTHX_ a,b)\n#define magic_clear_all_env(a,b)\tPerl_magic_clear_all_env(aTHX_ a,b)\n#define magic_cleararylen_p(a,b)\tPerl_magic_cleararylen_p(aTHX_ a,b)\n#define magic_clearenv(a,b)\tPerl_magic_clearenv(aTHX_ a,b)\n#define magic_clearhint(a,b)\tPerl_magic_clearhint(aTHX_ a,b)\n#define magic_clearhints(a,b)\tPerl_magic_clearhints(aTHX_ a,b)\n#define magic_clearisa(a,b)\tPerl_magic_clearisa(aTHX_ a,b)\n#define magic_clearpack(a,b)\tPerl_magic_clearpack(aTHX_ a,b)\n#define magic_clearsig(a,b)\tPerl_magic_clearsig(aTHX_ a,b)\n#define magic_copycallchecker(a,b,c,d,e)\tPerl_magic_copycallchecker(aTHX_ a,b,c,d,e)\n#define magic_existspack(a,b)\tPerl_magic_existspack(aTHX_ a,b)\n#define magic_freearylen_p(a,b)\tPerl_magic_freearylen_p(aTHX_ a,b)\n#define magic_freeovrld(a,b)\tPerl_magic_freeovrld(aTHX_ a,b)\n#define magic_get(a,b)\t\tPerl_magic_get(aTHX_ a,b)\n#define magic_getarylen(a,b)\tPerl_magic_getarylen(aTHX_ a,b)\n#define magic_getdebugvar(a,b)\tPerl_magic_getdebugvar(aTHX_ a,b)\n#define magic_getdefelem(a,b)\tPerl_magic_getdefelem(aTHX_ a,b)\n#define magic_getnkeys(a,b)\tPerl_magic_getnkeys(aTHX_ a,b)\n#define magic_getpack(a,b)\tPerl_magic_getpack(aTHX_ a,b)\n#define magic_getpos(a,b)\tPerl_magic_getpos(aTHX_ a,b)\n#define magic_getsig(a,b)\tPerl_magic_getsig(aTHX_ a,b)\n#define magic_getsubstr(a,b)\tPerl_magic_getsubstr(aTHX_ a,b)\n#define magic_gettaint(a,b)\tPerl_magic_gettaint(aTHX_ a,b)\n#define magic_getuvar(a,b)\tPerl_magic_getuvar(aTHX_ a,b)\n#define magic_getvec(a,b)\tPerl_magic_getvec(aTHX_ a,b)\n#define magic_killbackrefs(a,b)\tPerl_magic_killbackrefs(aTHX_ a,b)\n#define magic_nextpack(a,b,c)\tPerl_magic_nextpack(aTHX_ a,b,c)\n#define magic_regdata_cnt(a,b)\tPerl_magic_regdata_cnt(aTHX_ a,b)\n#define magic_regdatum_get(a,b)\tPerl_magic_regdatum_get(aTHX_ a,b)\n#define magic_scalarpack(a,b)\tPerl_magic_scalarpack(aTHX_ a,b)\n#define magic_set(a,b)\t\tPerl_magic_set(aTHX_ a,b)\n#define magic_set_all_env(a,b)\tPerl_magic_set_all_env(aTHX_ a,b)\n#define magic_setarylen(a,b)\tPerl_magic_setarylen(aTHX_ a,b)\n#define magic_setdbline(a,b)\tPerl_magic_setdbline(aTHX_ a,b)\n#define magic_setdebugvar(a,b)\tPerl_magic_setdebugvar(aTHX_ a,b)\n#define magic_setdefelem(a,b)\tPerl_magic_setdefelem(aTHX_ a,b)\n#define magic_setenv(a,b)\tPerl_magic_setenv(aTHX_ a,b)\n#define magic_sethint(a,b)\tPerl_magic_sethint(aTHX_ a,b)\n#define magic_setisa(a,b)\tPerl_magic_setisa(aTHX_ a,b)\n#define magic_setlvref(a,b)\tPerl_magic_setlvref(aTHX_ a,b)\n#define magic_setmglob(a,b)\tPerl_magic_setmglob(aTHX_ a,b)\n#define magic_setnkeys(a,b)\tPerl_magic_setnkeys(aTHX_ a,b)\n#define magic_setnonelem(a,b)\tPerl_magic_setnonelem(aTHX_ a,b)\n#define magic_setpack(a,b)\tPerl_magic_setpack(aTHX_ a,b)\n#define magic_setpos(a,b)\tPerl_magic_setpos(aTHX_ a,b)\n#define magic_setregexp(a,b)\tPerl_magic_setregexp(aTHX_ a,b)\n#define magic_setsig(a,b)\tPerl_magic_setsig(aTHX_ a,b)\n#define magic_setsubstr(a,b)\tPerl_magic_setsubstr(aTHX_ a,b)\n#define magic_settaint(a,b)\tPerl_magic_settaint(aTHX_ a,b)\n#define magic_setutf8(a,b)\tPerl_magic_setutf8(aTHX_ a,b)\n#define magic_setuvar(a,b)\tPerl_magic_setuvar(aTHX_ a,b)\n#define magic_setvec(a,b)\tPerl_magic_setvec(aTHX_ a,b)\n#define magic_sizepack(a,b)\tPerl_magic_sizepack(aTHX_ a,b)\n#define magic_wipepack(a,b)\tPerl_magic_wipepack(aTHX_ a,b)\n#define mg_localize(a,b,c)\tPerl_mg_localize(aTHX_ a,b,c)\n#define mode_from_discipline(a,b)\tPerl_mode_from_discipline(aTHX_ a,b)\n#define mro_isa_changed_in(a)\tPerl_mro_isa_changed_in(aTHX_ a)\n#define mro_package_moved(a,b,c,d)\tPerl_mro_package_moved(aTHX_ a,b,c,d)\n#define my_attrs(a,b)\t\tPerl_my_attrs(aTHX_ a,b)\n#define my_clearenv()\t\tPerl_my_clearenv(aTHX)\n#define my_lstat_flags(a)\tPerl_my_lstat_flags(aTHX_ a)\n#define my_stat_flags(a)\tPerl_my_stat_flags(aTHX_ a)\n#define my_strerror(a)\t\tPerl_my_strerror(aTHX_ a)\n#define my_unexec()\t\tPerl_my_unexec(aTHX)\n#define newATTRSUB_x(a,b,c,d,e,f)\tPerl_newATTRSUB_x(aTHX_ a,b,c,d,e,f)\n#define newSTUB(a,b)\t\tPerl_newSTUB(aTHX_ a,b)\n#define newSVavdefelem(a,b,c)\tPerl_newSVavdefelem(aTHX_ a,b,c)\n#define newXS_deffile(a,b)\tPerl_newXS_deffile(aTHX_ a,b)\n#define newXS_len_flags(a,b,c,d,e,f,g)\tPerl_newXS_len_flags(aTHX_ a,b,c,d,e,f,g)\n#define nextargv(a,b)\t\tPerl_nextargv(aTHX_ a,b)\n#define noperl_die\t\tPerl_noperl_die\n#define notify_parser_that_changed_to_utf8()\tPerl_notify_parser_that_changed_to_utf8(aTHX)\n#define oopsAV(a)\t\tPerl_oopsAV(aTHX_ a)\n#define oopsHV(a)\t\tPerl_oopsHV(aTHX_ a)\n#define op_unscope(a)\t\tPerl_op_unscope(aTHX_ a)\n#define optimize_optree(a)\tPerl_optimize_optree(aTHX_ a)\n#define package(a)\t\tPerl_package(aTHX_ a)\n#define package_version(a)\tPerl_package_version(aTHX_ a)\n#define pad_add_weakref(a)\tPerl_pad_add_weakref(aTHX_ a)\n#define pad_block_start(a)\tPerl_pad_block_start(aTHX_ a)\n#define pad_fixup_inner_anons(a,b,c)\tPerl_pad_fixup_inner_anons(aTHX_ a,b,c)\n#define pad_free(a)\t\tPerl_pad_free(aTHX_ a)\n#define pad_leavemy()\t\tPerl_pad_leavemy(aTHX)\n#define pad_push(a,b)\t\tPerl_pad_push(aTHX_ a,b)\n#define pad_swipe(a,b)\t\tPerl_pad_swipe(aTHX_ a,b)\n#define padlist_store(a,b,c)\tPerl_padlist_store(aTHX_ a,b,c)\n#define parse_unicode_opts(a)\tPerl_parse_unicode_opts(aTHX_ a)\n#define parser_free(a)\t\tPerl_parser_free(aTHX_ a)\n#define peep(a)\t\t\tPerl_peep(aTHX_ a)\n#define pmruntime(a,b,c,d,e)\tPerl_pmruntime(aTHX_ a,b,c,d,e)\n#define re_op_compile(a,b,c,d,e,f,g,h)\tPerl_re_op_compile(aTHX_ a,b,c,d,e,f,g,h)\n#define refcounted_he_chain_2hv(a,b)\tPerl_refcounted_he_chain_2hv(aTHX_ a,b)\n#define refcounted_he_fetch_pv(a,b,c,d)\tPerl_refcounted_he_fetch_pv(aTHX_ a,b,c,d)\n#define refcounted_he_fetch_pvn(a,b,c,d,e)\tPerl_refcounted_he_fetch_pvn(aTHX_ a,b,c,d,e)\n#define refcounted_he_fetch_sv(a,b,c,d)\tPerl_refcounted_he_fetch_sv(aTHX_ a,b,c,d)\n#define refcounted_he_free(a)\tPerl_refcounted_he_free(aTHX_ a)\n#define refcounted_he_inc(a)\tPerl_refcounted_he_inc(aTHX_ a)\n#define refcounted_he_new_pv(a,b,c,d,e)\tPerl_refcounted_he_new_pv(aTHX_ a,b,c,d,e)\n#define refcounted_he_new_pvn(a,b,c,d,e,f)\tPerl_refcounted_he_new_pvn(aTHX_ a,b,c,d,e,f)\n#define refcounted_he_new_sv(a,b,c,d,e)\tPerl_refcounted_he_new_sv(aTHX_ a,b,c,d,e)\n#define report_evil_fh(a)\tPerl_report_evil_fh(aTHX_ a)\n#define report_wrongway_fh(a,b)\tPerl_report_wrongway_fh(aTHX_ a,b)\n#define rpeep(a)\t\tPerl_rpeep(aTHX_ a)\n#define rsignal_restore(a,b)\tPerl_rsignal_restore(aTHX_ a,b)\n#define rsignal_save(a,b,c)\tPerl_rsignal_save(aTHX_ a,b,c)\n#define rxres_save(a,b)\t\tPerl_rxres_save(aTHX_ a,b)\n#define save_strlen(a)\t\tPerl_save_strlen(aTHX_ a)\n#define sawparens(a)\t\tPerl_sawparens(aTHX_ a)\n#define scalar(a)\t\tPerl_scalar(aTHX_ a)\n#define scalarvoid(a)\t\tPerl_scalarvoid(aTHX_ a)\n#define set_caret_X()\t\tPerl_set_caret_X(aTHX)\n#define set_numeric_standard()\tPerl_set_numeric_standard(aTHX)\n#define set_numeric_underlying()\tPerl_set_numeric_underlying(aTHX)\n#define setfd_cloexec\t\tPerl_setfd_cloexec\n#define setfd_cloexec_for_nonsysfd(a)\tPerl_setfd_cloexec_for_nonsysfd(aTHX_ a)\n#define setfd_cloexec_or_inhexec_by_sysfdness(a)\tPerl_setfd_cloexec_or_inhexec_by_sysfdness(aTHX_ a)\n#define setfd_inhexec\t\tPerl_setfd_inhexec\n#define setfd_inhexec_for_sysfd(a)\tPerl_setfd_inhexec_for_sysfd(aTHX_ a)\n#define sub_crush_depth(a)\tPerl_sub_crush_depth(aTHX_ a)\n#define sv_2num(a)\t\tPerl_sv_2num(aTHX_ a)\n#define sv_clean_all()\t\tPerl_sv_clean_all(aTHX)\n#define sv_clean_objs()\t\tPerl_sv_clean_objs(aTHX)\n#define sv_del_backref(a,b)\tPerl_sv_del_backref(aTHX_ a,b)\n#define sv_free_arenas()\tPerl_sv_free_arenas(aTHX)\n#define sv_len_utf8_nomg(a)\tPerl_sv_len_utf8_nomg(aTHX_ a)\n#define sv_mortalcopy_flags(a,b)\tPerl_sv_mortalcopy_flags(aTHX_ a,b)\n#define sv_resetpvn(a,b,c)\tPerl_sv_resetpvn(aTHX_ a,b,c)\n#define sv_sethek(a,b)\t\tPerl_sv_sethek(aTHX_ a,b)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define tied_method\t\tPerl_tied_method\n#endif\n#define tmps_grow_p(a)\t\tPerl_tmps_grow_p(aTHX_ a)\n#define unshare_hek(a)\t\tPerl_unshare_hek(aTHX_ a)\n#define utilize(a,b,c,d,e)\tPerl_utilize(aTHX_ a,b,c,d,e)\n#define vivify_ref(a,b)\t\tPerl_vivify_ref(aTHX_ a,b)\n#define wait4pid(a,b,c)\t\tPerl_wait4pid(aTHX_ a,b,c)\n#define watch(a)\t\tPerl_watch(aTHX_ a)\n#define write_to_stderr(a)\tPerl_write_to_stderr(aTHX_ a)\n#define xs_boot_epilog(a)\tPerl_xs_boot_epilog(aTHX_ a)\n#define yyerror(a)\t\tPerl_yyerror(aTHX_ a)\n#define yyerror_pv(a,b)\t\tPerl_yyerror_pv(aTHX_ a,b)\n#define yyerror_pvn(a,b,c)\tPerl_yyerror_pvn(aTHX_ a,b,c)\n#define yyparse(a)\t\tPerl_yyparse(aTHX_ a)\n#define yyquit()\t\tPerl_yyquit(aTHX)\n#define yyunlex()\t\tPerl_yyunlex(aTHX)\n#  if !(defined(DEBUGGING))\n#    if !defined(NV_PRESERVES_UV)\n#      if defined(PERL_IN_SV_C)\n#define sv_2iuv_non_preserve(a)\tS_sv_2iuv_non_preserve(aTHX_ a)\n#      endif\n#    endif\n#  endif\n#  if !(defined(HAS_NL_LANGINFO))\n#    if defined(PERL_IN_LOCALE_C)\n#define my_nl_langinfo\t\tS_my_nl_langinfo\n#    endif\n#  endif\n#  if !(defined(HAS_SIGACTION) && defined(SA_SIGINFO))\n#define sighandler\t\tPerl_sighandler\n#  endif\n#  if !(defined(PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION))\n#define do_exec(a)\t\tPerl_do_exec(aTHX_ a)\n#  endif\n#  if !(defined(_MSC_VER))\n#define magic_regdatum_set(a,b)\tPerl_magic_regdatum_set(aTHX_ a,b)\n#  endif\n#  if !defined(HAS_GETENV_LEN)\n#define getenv_len(a,b)\t\tPerl_getenv_len(aTHX_ a,b)\n#  endif\n#  if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)\n#    if defined(PERL_IN_PP_SYS_C)\n#define dooneliner(a,b)\t\tS_dooneliner(aTHX_ a,b)\n#    endif\n#  endif\n#  if !defined(HAS_RENAME)\n#define same_dirent(a,b)\tPerl_same_dirent(aTHX_ a,b)\n#  endif\n#  if !defined(NV_PRESERVES_UV)\n#    if defined(DEBUGGING)\n#      if defined(PERL_IN_SV_C)\n#define sv_2iuv_non_preserve(a,b)\tS_sv_2iuv_non_preserve(aTHX_ a,b)\n#      endif\n#    endif\n#  endif\n#  if !defined(PERL_DISABLE_PMC)\n#    if defined(PERL_IN_PP_CTL_C)\n#define doopen_pm(a)\t\tS_doopen_pm(aTHX_ a)\n#    endif\n#  endif\n#  if !defined(PERL_EXT_RE_BUILD)\n#    if defined(PERL_IN_REGCOMP_C)\n#define initialize_invlist_guts(a,b)\tS_initialize_invlist_guts(aTHX_ a,b)\n#    endif\n#  endif\n#  if !defined(PERL_IS_MINIPERL)\n#    if defined(PERL_IN_PERL_C)\n#define incpush_if_exists(a,b,c)\tS_incpush_if_exists(aTHX_ a,b,c)\n#    endif\n#  endif\n#  if !defined(PERL_NO_UTF16_FILTER)\n#    if defined(PERL_IN_TOKE_C)\n#define add_utf16_textfilter(a,b)\tS_add_utf16_textfilter(aTHX_ a,b)\n#define utf16_textfilter(a,b,c)\tS_utf16_textfilter(aTHX_ a,b,c)\n#    endif\n#  endif\n#  if !defined(UV_IS_QUAD)\n#    if defined(PERL_IN_UTF8_C)\n#define is_utf8_cp_above_31_bits\tS_is_utf8_cp_above_31_bits\n#    endif\n#  endif\n#  if !defined(WIN32)\n#define do_exec3(a,b,c)\t\tPerl_do_exec3(aTHX_ a,b,c)\n#  endif\n#  if defined (HAS_SOCKETPAIR) ||     (defined (HAS_SOCKET) && defined(SOCK_DGRAM) && \tdefined(AF_INET) && defined(PF_INET))\n#define PerlSock_socketpair_cloexec(a,b,c,d)\tPerl_PerlSock_socketpair_cloexec(aTHX_ a,b,c,d)\n#  endif\n#  if defined(DEBUGGING)\n#define get_debug_opts(a,b)\tPerl_get_debug_opts(aTHX_ a,b)\n#define set_padlist\t\tPerl_set_padlist\n#    if defined(PERL_IN_LOCALE_C)\n#      if defined(USE_LOCALE)\n#define print_bytes_for_locale(a,b,c)\tS_print_bytes_for_locale(aTHX_ a,b,c)\n#define print_collxfrm_input_and_return(a,b,c,d)\tS_print_collxfrm_input_and_return(aTHX_ a,b,c,d)\n#define setlocale_debug_string\tS_setlocale_debug_string\n#      endif\n#    endif\n#    if defined(PERL_IN_PAD_C)\n#define cv_dump(a,b)\t\tS_cv_dump(aTHX_ a,b)\n#    endif\n#    if defined(PERL_IN_SV_C)\n#define del_sv(a)\t\tS_del_sv(aTHX_ a)\n#    endif\n#    if defined(PERL_IN_TOKE_C)\n#define printbuf(a,b)\t\tS_printbuf(aTHX_ a,b)\n#define tokereport(a,b)\t\tS_tokereport(aTHX_ a,b)\n#    endif\n#  endif\n#  if defined(DEBUG_LEAKING_SCALARS_FORK_DUMP)\n#define dump_sv_child(a)\tPerl_dump_sv_child(aTHX_ a)\n#  endif\n#  if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)\n#define do_ipcctl(a,b,c)\tPerl_do_ipcctl(aTHX_ a,b,c)\n#define do_ipcget(a,b,c)\tPerl_do_ipcget(aTHX_ a,b,c)\n#define do_msgrcv(a,b)\t\tPerl_do_msgrcv(aTHX_ a,b)\n#define do_msgsnd(a,b)\t\tPerl_do_msgsnd(aTHX_ a,b)\n#define do_semop(a,b)\t\tPerl_do_semop(aTHX_ a,b)\n#define do_shmio(a,b,c)\t\tPerl_do_shmio(aTHX_ a,b,c)\n#  endif\n#  if defined(HAS_NL_LANGINFO)\n#    if defined(PERL_IN_LOCALE_C)\n#define my_nl_langinfo\t\tS_my_nl_langinfo\n#    endif\n#  endif\n#  if defined(HAS_PIPE)\n#define PerlProc_pipe_cloexec(a)\tPerl_PerlProc_pipe_cloexec(aTHX_ a)\n#  endif\n#  if defined(HAS_SIGACTION) && defined(SA_SIGINFO)\n#define sighandler\t\tPerl_sighandler\n#  endif\n#  if defined(HAS_SOCKET)\n#define PerlSock_accept_cloexec(a,b,c)\tPerl_PerlSock_accept_cloexec(aTHX_ a,b,c)\n#define PerlSock_socket_cloexec(a,b,c)\tPerl_PerlSock_socket_cloexec(aTHX_ a,b,c)\n#  endif\n#  if defined(MYMALLOC)\n#define malloc_good_size\tPerl_malloc_good_size\n#define malloced_size\t\tPerl_malloced_size\n#  endif\n#  if defined(PERL_CORE)\n#define opslab_force_free(a)\tPerl_opslab_force_free(aTHX_ a)\n#define opslab_free(a)\t\tPerl_opslab_free(aTHX_ a)\n#define opslab_free_nopad(a)\tPerl_opslab_free_nopad(aTHX_ a)\n#define parser_free_nexttoke_ops(a,b)\tPerl_parser_free_nexttoke_ops(aTHX_ a,b)\n#define should_warn_nl\t\tS_should_warn_nl\n#    if defined(PERL_DEBUG_READONLY_OPS)\n#define Slab_to_ro(a)\t\tPerl_Slab_to_ro(aTHX_ a)\n#define Slab_to_rw(a)\t\tPerl_Slab_to_rw(aTHX_ a)\n#    endif\n#  endif\n#  if defined(PERL_CR_FILTER)\n#    if defined(PERL_IN_TOKE_C)\n#define cr_textfilter(a,b,c)\tS_cr_textfilter(aTHX_ a,b,c)\n#define strip_return(a)\t\tS_strip_return(aTHX_ a)\n#    endif\n#  endif\n#  if defined(PERL_DEBUG_READONLY_COW)\n#define sv_buf_to_ro(a)\t\tPerl_sv_buf_to_ro(aTHX_ a)\n#    if defined(PERL_IN_SV_C)\n#define sv_buf_to_rw(a)\t\tS_sv_buf_to_rw(aTHX_ a)\n#    endif\n#  endif\n#  if defined(PERL_IN_AV_C)\n#define get_aux_mg(a)\t\tS_get_aux_mg(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_DEB_C)\n#define deb_stack_n(a,b,c,d,e)\tS_deb_stack_n(aTHX_ a,b,c,d,e)\n#  endif\n#  if defined(PERL_IN_DOIO_C)\n#define argvout_final(a,b,c)\tS_argvout_final(aTHX_ a,b,c)\n#define exec_failed(a,b,c)\tS_exec_failed(aTHX_ a,b,c)\n#define ingroup(a,b)\t\tS_ingroup(aTHX_ a,b)\n#define openn_cleanup(a,b,c,d,e,f,g,h,i,j,k,l,m)\tS_openn_cleanup(aTHX_ a,b,c,d,e,f,g,h,i,j,k,l,m)\n#define openn_setup(a,b,c,d,e,f)\tS_openn_setup(aTHX_ a,b,c,d,e,f)\n#  endif\n#  if defined(PERL_IN_DOOP_C)\n#define do_trans_complex(a)\tS_do_trans_complex(aTHX_ a)\n#define do_trans_complex_utf8(a)\tS_do_trans_complex_utf8(aTHX_ a)\n#define do_trans_count(a)\tS_do_trans_count(aTHX_ a)\n#define do_trans_count_utf8(a)\tS_do_trans_count_utf8(aTHX_ a)\n#define do_trans_simple(a)\tS_do_trans_simple(aTHX_ a)\n#define do_trans_simple_utf8(a)\tS_do_trans_simple_utf8(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_DUMP_C)\n#define deb_curcv(a)\t\tS_deb_curcv(aTHX_ a)\n#define debprof(a)\t\tS_debprof(aTHX_ a)\n#define pm_description(a)\tS_pm_description(aTHX_ a)\n#define sequence_num(a)\t\tS_sequence_num(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_GV_C)\n#define find_default_stash(a,b,c,d,e,f)\tS_find_default_stash(aTHX_ a,b,c,d,e,f)\n#define gv_fetchmeth_internal(a,b,c,d,e,f)\tS_gv_fetchmeth_internal(aTHX_ a,b,c,d,e,f)\n#define gv_init_svtype(a,b)\tS_gv_init_svtype(aTHX_ a,b)\n#define gv_is_in_main(a,b,c)\tS_gv_is_in_main(aTHX_ a,b,c)\n#define gv_magicalize(a,b,c,d,e)\tS_gv_magicalize(aTHX_ a,b,c,d,e)\n#define gv_magicalize_isa(a)\tS_gv_magicalize_isa(aTHX_ a)\n#define gv_stashpvn_internal(a,b,c)\tS_gv_stashpvn_internal(aTHX_ a,b,c)\n#define gv_stashsvpvn_cached(a,b,c,d)\tS_gv_stashsvpvn_cached(aTHX_ a,b,c,d)\n#define maybe_multimagic_gv(a,b,c)\tS_maybe_multimagic_gv(aTHX_ a,b,c)\n#define parse_gv_stash_name(a,b,c,d,e,f,g,h)\tS_parse_gv_stash_name(aTHX_ a,b,c,d,e,f,g,h)\n#define require_tie_mod(a,b,c,d,e)\tS_require_tie_mod(aTHX_ a,b,c,d,e)\n#  endif\n#  if defined(PERL_IN_HV_C)\n#define clear_placeholders(a,b)\tS_clear_placeholders(aTHX_ a,b)\n#define hsplit(a,b,c)\t\tS_hsplit(aTHX_ a,b,c)\n#define hv_auxinit(a)\t\tS_hv_auxinit(aTHX_ a)\n#define hv_auxinit_internal\tS_hv_auxinit_internal\n#define hv_delete_common(a,b,c,d,e,f,g)\tS_hv_delete_common(aTHX_ a,b,c,d,e,f,g)\n#define hv_free_ent_ret(a,b)\tS_hv_free_ent_ret(aTHX_ a,b)\n#define hv_free_entries(a)\tS_hv_free_entries(aTHX_ a)\n#define hv_magic_check\t\tS_hv_magic_check\n#define hv_notallowed(a,b,c,d)\tS_hv_notallowed(aTHX_ a,b,c,d)\n#define new_he()\t\tS_new_he(aTHX)\n#define ptr_hash\t\tS_ptr_hash\n#define refcounted_he_value(a)\tS_refcounted_he_value(aTHX_ a)\n#define save_hek_flags\t\tS_save_hek_flags\n#define share_hek_flags(a,b,c,d)\tS_share_hek_flags(aTHX_ a,b,c,d)\n#define unshare_hek_or_pvn(a,b,c,d)\tS_unshare_hek_or_pvn(aTHX_ a,b,c,d)\n#  endif\n#  if defined(PERL_IN_LOCALE_C)\n#define save_to_buffer\t\tS_save_to_buffer\n#    if defined(USE_LOCALE)\n#define category_name\t\tS_category_name\n#define new_collate(a)\t\tS_new_collate(aTHX_ a)\n#define new_ctype(a)\t\tS_new_ctype(aTHX_ a)\n#define new_numeric(a)\t\tS_new_numeric(aTHX_ a)\n#define restore_switched_locale(a,b)\tS_restore_switched_locale(aTHX_ a,b)\n#define set_numeric_radix(a)\tS_set_numeric_radix(aTHX_ a)\n#define stdize_locale(a)\tS_stdize_locale(aTHX_ a)\n#define switch_category_locale_to_template(a,b,c)\tS_switch_category_locale_to_template(aTHX_ a,b,c)\n#      if defined(USE_POSIX_2008_LOCALE)\n#define emulate_setlocale\tS_emulate_setlocale\n#      endif\n#      if defined(WIN32)\n#define win32_setlocale(a,b)\tS_win32_setlocale(aTHX_ a,b)\n#      endif\n#    endif\n#  endif\n#  if defined(PERL_IN_LOCALE_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_MATHOMS_C)\n#    if defined(USE_LOCALE_COLLATE)\n#define _mem_collxfrm(a,b,c,d)\tPerl__mem_collxfrm(aTHX_ a,b,c,d)\n#    endif\n#  endif\n#  if defined(PERL_IN_MALLOC_C)\n#define adjust_size_and_find_bucket\tS_adjust_size_and_find_bucket\n#  endif\n#  if defined(PERL_IN_MG_C)\n#define fixup_errno_string(a)\tS_fixup_errno_string(aTHX_ a)\n#define magic_methcall1(a,b,c,d,e,f)\tS_magic_methcall1(aTHX_ a,b,c,d,e,f)\n#define magic_methpack(a,b,c)\tS_magic_methpack(aTHX_ a,b,c)\n#define restore_magic(a)\tS_restore_magic(aTHX_ a)\n#define save_magic_flags(a,b,c)\tS_save_magic_flags(aTHX_ a,b,c)\n#define unwind_handler_stack(a)\tS_unwind_handler_stack(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_MG_C) || defined(PERL_IN_PP_C)\n#define translate_substr_offsets\tPerl_translate_substr_offsets\n#  endif\n#  if defined(PERL_IN_MRO_C)\n#define mro_clean_isarev(a,b,c,d,e,f)\tS_mro_clean_isarev(aTHX_ a,b,c,d,e,f)\n#define mro_gather_and_rename(a,b,c,d,e)\tS_mro_gather_and_rename(aTHX_ a,b,c,d,e)\n#define mro_get_linear_isa_dfs(a,b)\tS_mro_get_linear_isa_dfs(aTHX_ a,b)\n#  endif\n#  if defined(PERL_IN_OP_C)\n#define apply_attrs(a,b,c)\tS_apply_attrs(aTHX_ a,b,c)\n#define apply_attrs_my(a,b,c,d)\tS_apply_attrs_my(aTHX_ a,b,c,d)\n#define assignment_type(a)\tS_assignment_type(aTHX_ a)\n#define bad_type_gv(a,b,c,d)\tS_bad_type_gv(aTHX_ a,b,c,d)\n#define bad_type_pv(a,b,c,d)\tS_bad_type_pv(aTHX_ a,b,c,d)\n#define clear_special_blocks(a,b,c)\tS_clear_special_blocks(aTHX_ a,b,c)\n#define cop_free(a)\t\tS_cop_free(aTHX_ a)\n#define dup_attrlist(a)\t\tS_dup_attrlist(aTHX_ a)\n#define finalize_op(a)\t\tS_finalize_op(aTHX_ a)\n#define find_and_forget_pmops(a)\tS_find_and_forget_pmops(aTHX_ a)\n#define fold_constants(a)\tS_fold_constants(aTHX_ a)\n#define force_list(a,b)\t\tS_force_list(aTHX_ a,b)\n#define forget_pmop(a)\t\tS_forget_pmop(aTHX_ a)\n#define gen_constant_list(a)\tS_gen_constant_list(aTHX_ a)\n#define inplace_aassign(a)\tS_inplace_aassign(aTHX_ a)\n#define is_handle_constructor\tS_is_handle_constructor\n#define listkids(a)\t\tS_listkids(aTHX_ a)\n#define looks_like_bool(a)\tS_looks_like_bool(aTHX_ a)\n#define modkids(a,b)\t\tS_modkids(aTHX_ a,b)\n#define move_proto_attr(a,b,c,d)\tS_move_proto_attr(aTHX_ a,b,c,d)\n#define my_kid(a,b,c)\t\tS_my_kid(aTHX_ a,b,c)\n#define newGIVWHENOP(a,b,c,d,e)\tS_newGIVWHENOP(aTHX_ a,b,c,d,e)\n#define newMETHOP_internal(a,b,c,d)\tS_newMETHOP_internal(aTHX_ a,b,c,d)\n#define new_logop(a,b,c,d)\tS_new_logop(aTHX_ a,b,c,d)\n#define no_bareword_allowed(a)\tS_no_bareword_allowed(aTHX_ a)\n#define no_fh_allowed(a)\tS_no_fh_allowed(aTHX_ a)\n#define op_integerize(a)\tS_op_integerize(aTHX_ a)\n#define op_std_init(a)\t\tS_op_std_init(aTHX_ a)\n#define optimize_op(a)\t\tS_optimize_op(aTHX_ a)\n#define pmtrans(a,b,c)\t\tS_pmtrans(aTHX_ a,b,c)\n#define process_special_blocks(a,b,c,d)\tS_process_special_blocks(aTHX_ a,b,c,d)\n#define ref_array_or_hash(a)\tS_ref_array_or_hash(aTHX_ a)\n#define refkids(a,b)\t\tS_refkids(aTHX_ a,b)\n#define scalar_mod_type\t\tS_scalar_mod_type\n#define scalarboolean(a)\tS_scalarboolean(aTHX_ a)\n#define scalarkids(a)\t\tS_scalarkids(aTHX_ a)\n#define scalarseq(a)\t\tS_scalarseq(aTHX_ a)\n#define search_const(a)\t\tS_search_const(aTHX_ a)\n#define simplify_sort(a)\tS_simplify_sort(aTHX_ a)\n#define too_few_arguments_pv(a,b,c)\tS_too_few_arguments_pv(aTHX_ a,b,c)\n#define too_many_arguments_pv(a,b,c)\tS_too_many_arguments_pv(aTHX_ a,b,c)\n#define traverse_op_tree(a,b)\tS_traverse_op_tree(aTHX_ a,b)\n#    if defined(USE_ITHREADS)\n#define op_relocate_sv(a,b)\tS_op_relocate_sv(aTHX_ a,b)\n#    endif\n#  endif\n#  if defined(PERL_IN_OP_C) || defined(PERL_IN_SV_C)\n#define report_redefined_cv(a,b,c)\tPerl_report_redefined_cv(aTHX_ a,b,c)\n#  endif\n#  if defined(PERL_IN_PAD_C)\n#define pad_alloc_name(a,b,c,d)\tS_pad_alloc_name(aTHX_ a,b,c,d)\n#define pad_check_dup(a,b,c)\tS_pad_check_dup(aTHX_ a,b,c)\n#define pad_findlex(a,b,c,d,e,f,g,h,i)\tS_pad_findlex(aTHX_ a,b,c,d,e,f,g,h,i)\n#define pad_reset()\t\tS_pad_reset(aTHX)\n#  endif\n#  if defined(PERL_IN_PERL_C)\n#define find_beginning(a,b)\tS_find_beginning(aTHX_ a,b)\n#define forbid_setid(a,b)\tS_forbid_setid(aTHX_ a,b)\n#define incpush(a,b,c)\t\tS_incpush(aTHX_ a,b,c)\n#define incpush_use_sep(a,b,c)\tS_incpush_use_sep(aTHX_ a,b,c)\n#define init_ids()\t\tS_init_ids(aTHX)\n#define init_interp()\t\tS_init_interp(aTHX)\n#define init_main_stash()\tS_init_main_stash(aTHX)\n#define init_perllib()\t\tS_init_perllib(aTHX)\n#define init_postdump_symbols(a,b,c)\tS_init_postdump_symbols(aTHX_ a,b,c)\n#define init_predump_symbols()\tS_init_predump_symbols(aTHX)\n#define mayberelocate(a,b,c)\tS_mayberelocate(aTHX_ a,b,c)\n#define minus_v()\t\tS_minus_v(aTHX)\n#define my_exit_jump()\t\tS_my_exit_jump(aTHX)\n#define nuke_stacks()\t\tS_nuke_stacks(aTHX)\n#define open_script(a,b,c)\tS_open_script(aTHX_ a,b,c)\n#define parse_body(a,b)\t\tS_parse_body(aTHX_ a,b)\n#define run_body(a)\t\tS_run_body(aTHX_ a)\n#define usage()\t\t\tS_usage(aTHX)\n#  endif\n#  if defined(PERL_IN_PP_C)\n#define do_chomp(a,b,c)\t\tS_do_chomp(aTHX_ a,b,c)\n#define do_delete_local()\tS_do_delete_local(aTHX)\n#define refto(a)\t\tS_refto(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_PP_CTL_C)\n#define check_type_and_open(a)\tS_check_type_and_open(aTHX_ a)\n#define destroy_matcher(a)\tS_destroy_matcher(aTHX_ a)\n#define do_smartmatch(a,b,c)\tS_do_smartmatch(aTHX_ a,b,c)\n#define docatch(a)\t\tS_docatch(aTHX_ a)\n#define doeval_compile(a,b,c,d)\tS_doeval_compile(aTHX_ a,b,c,d)\n#define dofindlabel(a,b,c,d,e,f)\tS_dofindlabel(aTHX_ a,b,c,d,e,f)\n#define doparseform(a)\t\tS_doparseform(aTHX_ a)\n#define dopoptoeval(a)\t\tS_dopoptoeval(aTHX_ a)\n#define dopoptogivenfor(a)\tS_dopoptogivenfor(aTHX_ a)\n#define dopoptolabel(a,b,c)\tS_dopoptolabel(aTHX_ a,b,c)\n#define dopoptoloop(a)\t\tS_dopoptoloop(aTHX_ a)\n#define dopoptosub_at(a,b)\tS_dopoptosub_at(aTHX_ a,b)\n#define dopoptowhen(a)\t\tS_dopoptowhen(aTHX_ a)\n#define make_matcher(a)\t\tS_make_matcher(aTHX_ a)\n#define matcher_matches_sv(a,b)\tS_matcher_matches_sv(aTHX_ a,b)\n#define num_overflow\t\tS_num_overflow\n#define path_is_searchable\tS_path_is_searchable\n#define run_user_filter(a,b,c)\tS_run_user_filter(aTHX_ a,b,c)\n#define rxres_free(a)\t\tS_rxres_free(aTHX_ a)\n#define rxres_restore(a,b)\tS_rxres_restore(aTHX_ a,b)\n#define save_lines(a,b)\t\tS_save_lines(aTHX_ a,b)\n#  endif\n#  if defined(PERL_IN_PP_HOT_C)\n#define do_oddball(a,b)\t\tS_do_oddball(aTHX_ a,b)\n#define opmethod_stash(a)\tS_opmethod_stash(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_PP_PACK_C)\n#define div128(a,b)\t\tS_div128(aTHX_ a,b)\n#define first_symbol\t\tS_first_symbol\n#define get_num(a,b)\t\tS_get_num(aTHX_ a,b)\n#define group_end(a,b,c)\tS_group_end(aTHX_ a,b,c)\n#define is_an_int(a,b)\t\tS_is_an_int(aTHX_ a,b)\n#define measure_struct(a)\tS_measure_struct(aTHX_ a)\n#define mul128(a,b)\t\tS_mul128(aTHX_ a,b)\n#define my_bytes_to_utf8\tS_my_bytes_to_utf8\n#define need_utf8\t\tS_need_utf8\n#define next_symbol(a)\t\tS_next_symbol(aTHX_ a)\n#define pack_rec(a,b,c,d)\tS_pack_rec(aTHX_ a,b,c,d)\n#define sv_exp_grow(a,b)\tS_sv_exp_grow(aTHX_ a,b)\n#define unpack_rec(a,b,c,d,e)\tS_unpack_rec(aTHX_ a,b,c,d,e)\n#  endif\n#  if defined(PERL_IN_PP_SORT_C)\n#define amagic_cmp(a,b)\t\tS_amagic_cmp(aTHX_ a,b)\n#define amagic_i_ncmp(a,b)\tS_amagic_i_ncmp(aTHX_ a,b)\n#define amagic_ncmp(a,b)\tS_amagic_ncmp(aTHX_ a,b)\n#define sortcv(a,b)\t\tS_sortcv(aTHX_ a,b)\n#define sortcv_stacked(a,b)\tS_sortcv_stacked(aTHX_ a,b)\n#define sortcv_xsub(a,b)\tS_sortcv_xsub(aTHX_ a,b)\n#define sv_i_ncmp(a,b)\t\tS_sv_i_ncmp(aTHX_ a,b)\n#define sv_ncmp(a,b)\t\tS_sv_ncmp(aTHX_ a,b)\n#    if defined(USE_LOCALE_COLLATE)\n#define amagic_cmp_locale(a,b)\tS_amagic_cmp_locale(aTHX_ a,b)\n#    endif\n#  endif\n#  if defined(PERL_IN_PP_SYS_C)\n#define doform(a,b,c)\t\tS_doform(aTHX_ a,b,c)\n#define space_join_names_mortal(a)\tS_space_join_names_mortal(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_SCOPE_C)\n#define save_pushptri32ptr(a,b,c,d)\tS_save_pushptri32ptr(aTHX_ a,b,c,d)\n#define save_scalar_at(a,b)\tS_save_scalar_at(aTHX_ a,b)\n#  endif\n#  if defined(PERL_IN_SV_C)\n#define F0convert\t\tS_F0convert\n#define anonymise_cv_maybe(a,b)\tS_anonymise_cv_maybe(aTHX_ a,b)\n#define assert_uft8_cache_coherent(a,b,c,d)\tS_assert_uft8_cache_coherent(aTHX_ a,b,c,d)\n#define curse(a,b)\t\tS_curse(aTHX_ a,b)\n#define expect_number(a)\tS_expect_number(aTHX_ a)\n#define find_array_subscript(a,b)\tS_find_array_subscript(aTHX_ a,b)\n#define find_hash_subscript(a,b)\tS_find_hash_subscript(aTHX_ a,b)\n#define find_uninit_var(a,b,c,d)\tS_find_uninit_var(aTHX_ a,b,c,d)\n#define glob_2number(a)\t\tS_glob_2number(aTHX_ a)\n#define glob_assign_glob(a,b,c)\tS_glob_assign_glob(aTHX_ a,b,c)\n#define more_sv()\t\tS_more_sv(aTHX)\n#define not_a_number(a)\t\tS_not_a_number(aTHX_ a)\n#define not_incrementable(a)\tS_not_incrementable(aTHX_ a)\n#define ptr_table_find\t\tS_ptr_table_find\n#define sv_2iuv_common(a)\tS_sv_2iuv_common(aTHX_ a)\n#define sv_add_arena(a,b,c)\tS_sv_add_arena(aTHX_ a,b,c)\n#define sv_display(a,b,c)\tS_sv_display(aTHX_ a,b,c)\n#define sv_pos_b2u_midway(a,b,c,d)\tS_sv_pos_b2u_midway(aTHX_ a,b,c,d)\n#define sv_pos_u2b_cached(a,b,c,d,e,f,g)\tS_sv_pos_u2b_cached(aTHX_ a,b,c,d,e,f,g)\n#define sv_pos_u2b_forwards\tS_sv_pos_u2b_forwards\n#define sv_pos_u2b_midway\tS_sv_pos_u2b_midway\n#define sv_unglob(a,b)\t\tS_sv_unglob(aTHX_ a,b)\n#define uiv_2buf\t\tS_uiv_2buf\n#define utf8_mg_len_cache_update(a,b,c)\tS_utf8_mg_len_cache_update(aTHX_ a,b,c)\n#define utf8_mg_pos_cache_update(a,b,c,d,e)\tS_utf8_mg_pos_cache_update(aTHX_ a,b,c,d,e)\n#define visit(a,b,c)\t\tS_visit(aTHX_ a,b,c)\n#    if defined(USE_ITHREADS)\n#define sv_dup_common(a,b)\tS_sv_dup_common(aTHX_ a,b)\n#define sv_dup_inc_multiple(a,b,c,d)\tS_sv_dup_inc_multiple(aTHX_ a,b,c,d)\n#define unreferenced_to_tmp_stack(a)\tS_unreferenced_to_tmp_stack(aTHX_ a)\n#    endif\n#  endif\n#  if defined(PERL_IN_SV_C) || defined (PERL_IN_OP_C)\n#define varname(a,b,c,d,e,f)\tPerl_varname(aTHX_ a,b,c,d,e,f)\n#  endif\n#  if defined(PERL_IN_TOKE_C)\n#define ao(a)\t\t\tS_ao(aTHX_ a)\n#define check_uni()\t\tS_check_uni(aTHX)\n#define checkcomma(a,b,c)\tS_checkcomma(aTHX_ a,b,c)\n#define filter_gets(a,b)\tS_filter_gets(aTHX_ a,b)\n#define find_in_my_stash(a,b)\tS_find_in_my_stash(aTHX_ a,b)\n#define force_ident(a,b)\tS_force_ident(aTHX_ a,b)\n#define force_ident_maybe_lex(a)\tS_force_ident_maybe_lex(aTHX_ a)\n#define force_next(a)\t\tS_force_next(aTHX_ a)\n#define force_strict_version(a)\tS_force_strict_version(aTHX_ a)\n#define force_version(a,b)\tS_force_version(aTHX_ a,b)\n#define force_word(a,b,c,d)\tS_force_word(aTHX_ a,b,c,d)\n#define get_and_check_backslash_N_name_wrapper(a,b)\tS_get_and_check_backslash_N_name_wrapper(aTHX_ a,b)\n#define incline(a,b)\t\tS_incline(aTHX_ a,b)\n#define intuit_method(a,b,c)\tS_intuit_method(aTHX_ a,b,c)\n#define intuit_more(a,b)\tS_intuit_more(aTHX_ a,b)\n#define lop(a,b,c)\t\tS_lop(aTHX_ a,b,c)\n#define missingterm(a,b)\tS_missingterm(aTHX_ a,b)\n#define no_op(a,b)\t\tS_no_op(aTHX_ a,b)\n#define parse_ident(a,b,c,d,e,f,g)\tS_parse_ident(aTHX_ a,b,c,d,e,f,g)\n#define pending_ident()\t\tS_pending_ident(aTHX)\n#define scan_const(a)\t\tS_scan_const(aTHX_ a)\n#define scan_formline(a)\tS_scan_formline(aTHX_ a)\n#define scan_heredoc(a)\t\tS_scan_heredoc(aTHX_ a)\n#define scan_ident(a,b,c,d)\tS_scan_ident(aTHX_ a,b,c,d)\n#define scan_inputsymbol(a)\tS_scan_inputsymbol(aTHX_ a)\n#define scan_pat(a,b)\t\tS_scan_pat(aTHX_ a,b)\n#define scan_subst(a)\t\tS_scan_subst(aTHX_ a)\n#define scan_trans(a)\t\tS_scan_trans(aTHX_ a)\n#define sublex_done()\t\tS_sublex_done(aTHX)\n#define sublex_push()\t\tS_sublex_push(aTHX)\n#define sublex_start()\t\tS_sublex_start(aTHX)\n#define swallow_bom(a)\t\tS_swallow_bom(aTHX_ a)\n#define tokenize_use(a,b)\tS_tokenize_use(aTHX_ a,b)\n#define tokeq(a)\t\tS_tokeq(aTHX_ a)\n#define update_debugger_info(a,b,c)\tS_update_debugger_info(aTHX_ a,b,c)\n#define yywarn(a,b)\t\tS_yywarn(aTHX_ a,b)\n#  endif\n#  if defined(PERL_IN_UNIVERSAL_C)\n#define isa_lookup(a,b,c,d)\tS_isa_lookup(aTHX_ a,b,c,d)\n#  endif\n#  if defined(PERL_IN_UTF8_C)\n#define _to_utf8_case(a,b,c,d,e,f,g,h,i)\tS__to_utf8_case(aTHX_ a,b,c,d,e,f,g,h,i)\n#define check_and_deprecate(a,b,c,d,e,f)\tS_check_and_deprecate(aTHX_ a,b,c,d,e,f)\n#define check_locale_boundary_crossing(a,b,c,d)\tS_check_locale_boundary_crossing(aTHX_ a,b,c,d)\n#define does_utf8_overflow\tS_does_utf8_overflow\n#define isFF_OVERLONG\t\tS_isFF_OVERLONG\n#define is_utf8_common(a,b)\tS_is_utf8_common(aTHX_ a,b)\n#define is_utf8_common_with_len(a,b,c)\tS_is_utf8_common_with_len(aTHX_ a,b,c)\n#define is_utf8_overlong_given_start_byte_ok\tS_is_utf8_overlong_given_start_byte_ok\n#define new_msg_hv(a,b,c)\tS_new_msg_hv(aTHX_ a,b,c)\n#define swash_scan_list_line(a,b,c,d,e,f,g)\tS_swash_scan_list_line(aTHX_ a,b,c,d,e,f,g)\n#define swatch_get(a,b,c)\tS_swatch_get(aTHX_ a,b,c)\n#define to_lower_latin1\t\tS_to_lower_latin1\n#define turkic_fc(a,b,c,d)\tS_turkic_fc(aTHX_ a,b,c,d)\n#define turkic_lc(a,b,c,d)\tS_turkic_lc(aTHX_ a,b,c,d)\n#define turkic_uc(a,b,c,d)\tS_turkic_uc(aTHX_ a,b,c,d)\n#define unexpected_non_continuation_text(a,b,c,d)\tS_unexpected_non_continuation_text(aTHX_ a,b,c,d)\n#define warn_on_first_deprecated_use(a,b,c,d,e)\tS_warn_on_first_deprecated_use(aTHX_ a,b,c,d,e)\n#  endif\n#  if defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)\n#define _to_upper_title_latin1(a,b,c,d)\tPerl__to_upper_title_latin1(aTHX_ a,b,c,d)\n#  endif\n#  if defined(PERL_IN_UTIL_C)\n#define ckwarn_common(a)\tS_ckwarn_common(aTHX_ a)\n#define invoke_exception_hook(a,b)\tS_invoke_exception_hook(aTHX_ a,b)\n#define mess_alloc()\t\tS_mess_alloc(aTHX)\n#define with_queued_errors(a)\tS_with_queued_errors(aTHX_ a)\n#    if defined(PERL_MEM_LOG) && !defined(PERL_MEM_LOG_NOIMPL)\n#define mem_log_common\t\tS_mem_log_common\n#    endif\n#  endif\n#  if defined(PERL_MEM_LOG)\n#define mem_log_alloc\t\tPerl_mem_log_alloc\n#define mem_log_free\t\tPerl_mem_log_free\n#define mem_log_realloc\t\tPerl_mem_log_realloc\n#  endif\n#  if defined(PERL_USES_PL_PIDSTATUS) && defined(PERL_IN_UTIL_C)\n#define pidgone(a,b)\t\tS_pidgone(aTHX_ a,b)\n#  endif\n#  if defined(USE_C_BACKTRACE)\n#define get_c_backtrace(a,b)\tPerl_get_c_backtrace(aTHX_ a,b)\n#  endif\n#  if defined(USE_ITHREADS)\n#define mro_meta_dup(a,b)\tPerl_mro_meta_dup(aTHX_ a,b)\n#define padlist_dup(a,b)\tPerl_padlist_dup(aTHX_ a,b)\n#define padname_dup(a,b)\tPerl_padname_dup(aTHX_ a,b)\n#define padnamelist_dup(a,b)\tPerl_padnamelist_dup(aTHX_ a,b)\n#  endif\n#  if defined(USE_LOCALE_COLLATE)\n#define magic_setcollxfrm(a,b)\tPerl_magic_setcollxfrm(aTHX_ a,b)\n#ifndef NO_MATHOMS\n#define mem_collxfrm(a,b,c)\tPerl_mem_collxfrm(aTHX_ a,b,c)\n#endif\n#  endif\n#  if defined(USE_PERLIO)\n#define PerlIO_restore_errno(a)\tPerl_PerlIO_restore_errno(aTHX_ a)\n#define PerlIO_save_errno(a)\tPerl_PerlIO_save_errno(aTHX_ a)\n#  endif\n#  if defined(_MSC_VER)\n#define magic_regdatum_set(a,b)\tPerl_magic_regdatum_set(aTHX_ a,b)\n#  endif\n#endif\n\n#endif\t/* #ifndef PERL_NO_SHORT_NAMES */\n\n/* Compatibility stubs.  Compile extensions with -DPERL_NOCOMPAT to\n   disable them.\n */\n\n#if !defined(PERL_CORE)\n#  define sv_setptrobj(rv,ptr,name)\tsv_setref_iv(rv,name,PTR2IV(ptr))\n#  define sv_setptrref(rv,ptr)\t\tsv_setref_iv(rv,NULL,PTR2IV(ptr))\n#endif\n\n#if !defined(PERL_CORE) && !defined(PERL_NOCOMPAT)\n\n/* Compatibility for various misnamed functions.  All functions\n   in the API that begin with \"perl_\" (not \"Perl_\") take an explicit\n   interpreter context pointer.\n   The following are not like that, but since they had a \"perl_\"\n   prefix in previous versions, we provide compatibility macros.\n */\n#  define perl_atexit(a,b)\t\tcall_atexit(a,b)\n#  define perl_call_argv(a,b,c)\t\tcall_argv(a,b,c)\n#  define perl_call_method(a,b)\t\tcall_method(a,b)\n#  define perl_call_pv(a,b)\t\tcall_pv(a,b)\n#  define perl_call_sv(a,b)\t\tcall_sv(a,b)\n#  define perl_eval_pv(a,b)\t\teval_pv(a,b)\n#  define perl_eval_sv(a,b)\t\teval_sv(a,b)\n#  define perl_get_av(a,b)\t\tget_av(a,b)\n#  define perl_get_cv(a,b)\t\tget_cv(a,b)\n#  define perl_get_hv(a,b)\t\tget_hv(a,b)\n#  define perl_get_sv(a,b)\t\tget_sv(a,b)\n#  define perl_init_i18nl10n(a)\t\tinit_i18nl10n(a)\n#  define perl_init_i18nl14n(a)\t\tinit_i18nl14n(a)\n#  define perl_require_pv(a)\t\trequire_pv(a)\n\n/* varargs functions can't be handled with CPP macros. :-(\n   This provides a set of compatibility functions that don't take\n   an extra argument but grab the context pointer using the macro\n   dTHX.\n */\n#if defined(PERL_IMPLICIT_CONTEXT) && !defined(PERL_NO_SHORT_NAMES)\n#  define croak\t\t\tPerl_croak_nocontext\n#  define deb\t\t\tPerl_deb_nocontext\n#  define die\t\t\tPerl_die_nocontext\n#  define form\t\t\tPerl_form_nocontext\n#  define load_module\t\tPerl_load_module_nocontext\n#  define mess\t\t\tPerl_mess_nocontext\n#  define newSVpvf\t\tPerl_newSVpvf_nocontext\n#  define sv_catpvf\t\tPerl_sv_catpvf_nocontext\n#  define sv_catpvf_mg\t\tPerl_sv_catpvf_mg_nocontext\n#  define sv_setpvf\t\tPerl_sv_setpvf_nocontext\n#  define sv_setpvf_mg\t\tPerl_sv_setpvf_mg_nocontext\n#  define warn\t\t\tPerl_warn_nocontext\n#  define warner\t\tPerl_warner_nocontext\n#endif\n\n#endif /* !defined(PERL_CORE) && !defined(PERL_NOCOMPAT) */\n\n#if !defined(PERL_IMPLICIT_CONTEXT)\n/* undefined symbols, point them back at the usual ones */\n#  define Perl_croak_nocontext\tPerl_croak\n#  define Perl_deb_nocontext\tPerl_deb\n#  define Perl_die_nocontext\tPerl_die\n#  define Perl_form_nocontext\tPerl_form\n#  define Perl_load_module_nocontext\tPerl_load_module\n#  define Perl_mess_nocontext\tPerl_mess\n#  define Perl_newSVpvf_nocontext\tPerl_newSVpvf\n#  define Perl_sv_catpvf_nocontext\tPerl_sv_catpvf\n#  define Perl_sv_catpvf_mg_nocontext\tPerl_sv_catpvf_mg\n#  define Perl_sv_setpvf_nocontext\tPerl_sv_setpvf\n#  define Perl_sv_setpvf_mg_nocontext\tPerl_sv_setpvf_mg\n#  define Perl_warn_nocontext\tPerl_warn\n#  define Perl_warner_nocontext\tPerl_warner\n#endif\n\n/* ex: set ro: */\n", "/* -*- buffer-read-only: t -*-\n *\n *    proto.h\n *\n *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others\n *\n *    You may distribute under the terms of either the GNU General Public\n *    License or the Artistic License, as specified in the README file.\n *\n * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n * This file is built by regen/embed.pl from data in embed.fnc,\n * regen/embed.pl, regen/opcodes, intrpvar.h and perlvars.h.\n * Any changes made here will be lost!\n *\n * Edit those files and run 'make regen_headers' to effect changes.\n */\n\nSTART_EXTERN_C\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tASCII_TO_NEED(const UV enc, const UV ch)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\nPERL_CALLCONV int\tPerl_Gv_AMupdate(pTHX_ HV* stash, bool destructing);\n#define PERL_ARGS_ASSERT_GV_AMUPDATE\t\\\n\tassert(stash)\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tNATIVE_TO_NEED(const UV enc, const UV ch)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\nPERL_CALLCONV const char *\tPerl_PerlIO_context_layers(pTHX_ const char *mode);\nPERL_CALLCONV int\tPerl_PerlLIO_dup2_cloexec(pTHX_ int oldfd, int newfd);\nPERL_CALLCONV int\tPerl_PerlLIO_dup_cloexec(pTHX_ int oldfd)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV int\tPerl_PerlLIO_open3_cloexec(pTHX_ const char *file, int flag, int perm)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PERLLIO_OPEN3_CLOEXEC\t\\\n\tassert(file)\n\nPERL_CALLCONV int\tPerl_PerlLIO_open_cloexec(pTHX_ const char *file, int flag)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PERLLIO_OPEN_CLOEXEC\t\\\n\tassert(file)\n\nPERL_CALLCONV const char*\tPerl_setlocale(const int category, const char* locale);\nPERL_CALLCONV void*\tPerl_Slab_Alloc(pTHX_ size_t sz)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_Slab_Free(pTHX_ void *op);\n#define PERL_ARGS_ASSERT_SLAB_FREE\t\\\n\tassert(op)\nPERL_CALLCONV char *\tPerl__byte_dump_string(pTHX_ const U8 * const start, const STRLEN len, const bool format);\n#define PERL_ARGS_ASSERT__BYTE_DUMP_STRING\t\\\n\tassert(start)\nPERL_CALLCONV void\tPerl__force_out_malformed_utf8_message(pTHX_ const U8 *const p, const U8 * const e, const U32 flags, const bool die_here);\n#define PERL_ARGS_ASSERT__FORCE_OUT_MALFORMED_UTF8_MESSAGE\t\\\n\tassert(p); assert(e)\nPERL_CALLCONV Size_t\tPerl__inverse_folds(pTHX_ const UV cp, unsigned int * first_folds_to, const unsigned int ** remaining_folds_to)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__INVERSE_FOLDS\t\\\n\tassert(first_folds_to); assert(remaining_folds_to)\n\nPERL_CALLCONV bool\tPerl__is_in_locale_category(pTHX_ const bool compiling, const int category);\nPERL_CALLCONV bool\tPerl__is_uni_FOO(pTHX_ const U8 classnum, const UV c)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl__is_uni_perl_idcont(pTHX_ UV c)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl__is_uni_perl_idstart(pTHX_ UV c)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl__is_utf8_FOO(pTHX_ U8 classnum, const U8 * const p, const char * const name, const char * const alternative, const bool use_utf8, const bool use_locale, const char * const file, const unsigned line)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_FOO\t\\\n\tassert(p); assert(name); assert(alternative); assert(file)\n\nPERL_CALLCONV bool\tPerl__is_utf8_FOO_with_len(pTHX_ const U8 classnum, const U8 *p, const U8 * const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_FOO_WITH_LEN\t\\\n\tassert(p); assert(e)\n\nPERL_CALLCONV STRLEN\tPerl__is_utf8_char_helper(const U8 * const s, const U8 * e, const U32 flags)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#define PERL_ARGS_ASSERT__IS_UTF8_CHAR_HELPER\t\\\n\tassert(s); assert(e)\n\nPERL_CALLCONV bool\tPerl__is_utf8_idcont(pTHX_ const U8 *p)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_IDCONT\t\\\n\tassert(p)\n\nPERL_CALLCONV bool\tPerl__is_utf8_idstart(pTHX_ const U8 *p)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_IDSTART\t\\\n\tassert(p)\n\nPERL_CALLCONV bool\tPerl__is_utf8_mark(pTHX_ const U8 *p)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_MARK\t\\\n\tassert(p)\n\nPERL_CALLCONV bool\tPerl__is_utf8_perl_idcont_with_len(pTHX_ const U8 *p, const U8 * const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_PERL_IDCONT_WITH_LEN\t\\\n\tassert(p); assert(e)\n\nPERL_CALLCONV bool\tPerl__is_utf8_perl_idstart_with_len(pTHX_ const U8 *p, const U8 * const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_PERL_IDSTART_WITH_LEN\t\\\n\tassert(p); assert(e)\n\nPERL_CALLCONV bool\tPerl__is_utf8_xidcont(pTHX_ const U8 *p)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_XIDCONT\t\\\n\tassert(p)\n\nPERL_CALLCONV bool\tPerl__is_utf8_xidstart(pTHX_ const U8 *p)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_XIDSTART\t\\\n\tassert(p)\n\nPERL_CALLCONV UV\tPerl__to_uni_fold_flags(pTHX_ UV c, U8 *p, STRLEN *lenp, U8 flags);\n#define PERL_ARGS_ASSERT__TO_UNI_FOLD_FLAGS\t\\\n\tassert(p); assert(lenp)\nPERL_CALLCONV UV\tPerl__to_utf8_fold_flags(pTHX_ const U8 *p, const U8 *e, U8* ustrp, STRLEN *lenp, U8 flags, const char * const file, const int line);\n#define PERL_ARGS_ASSERT__TO_UTF8_FOLD_FLAGS\t\\\n\tassert(p); assert(ustrp); assert(file)\nPERL_CALLCONV UV\tPerl__to_utf8_lower_flags(pTHX_ const U8 *p, const U8* e, U8* ustrp, STRLEN *lenp, bool flags, const char * const file, const int line);\n#define PERL_ARGS_ASSERT__TO_UTF8_LOWER_FLAGS\t\\\n\tassert(p); assert(ustrp); assert(file)\nPERL_CALLCONV UV\tPerl__to_utf8_title_flags(pTHX_ const U8 *p, const U8* e, U8* ustrp, STRLEN *lenp, bool flags, const char * const file, const int line);\n#define PERL_ARGS_ASSERT__TO_UTF8_TITLE_FLAGS\t\\\n\tassert(p); assert(ustrp); assert(file)\nPERL_CALLCONV UV\tPerl__to_utf8_upper_flags(pTHX_ const U8 *p, const U8 *e, U8* ustrp, STRLEN *lenp, bool flags, const char * const file, const int line);\n#define PERL_ARGS_ASSERT__TO_UTF8_UPPER_FLAGS\t\\\n\tassert(p); assert(ustrp); assert(file)\nPERL_CALLCONV UV\tPerl__utf8n_to_uvchr_msgs_helper(const U8 *s, STRLEN curlen, STRLEN *retlen, const U32 flags, U32 * errors, AV ** msgs);\n#define PERL_ARGS_ASSERT__UTF8N_TO_UVCHR_MSGS_HELPER\t\\\n\tassert(s)\nPERL_CALLCONV void\tPerl__warn_problematic_locale(void);\nPERL_CALLCONV_NO_RET void\tPerl_abort_execution(pTHX_ const char * const msg, const char * const name)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_ABORT_EXECUTION\t\\\n\tassert(msg); assert(name)\n\nPERL_CALLCONV LOGOP*\tPerl_alloc_LOGOP(pTHX_ I32 type, OP *first, OP *other);\nPERL_CALLCONV PADOFFSET\tPerl_allocmy(pTHX_ const char *const name, const STRLEN len, const U32 flags);\n#define PERL_ARGS_ASSERT_ALLOCMY\t\\\n\tassert(name)\nPERL_CALLCONV SV*\tPerl_amagic_call(pTHX_ SV* left, SV* right, int method, int dir);\n#define PERL_ARGS_ASSERT_AMAGIC_CALL\t\\\n\tassert(left); assert(right)\nPERL_CALLCONV SV *\tPerl_amagic_deref_call(pTHX_ SV *ref, int method);\n#define PERL_ARGS_ASSERT_AMAGIC_DEREF_CALL\t\\\n\tassert(ref)\nPERL_CALLCONV bool\tPerl_amagic_is_enabled(pTHX_ int method);\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_append_utf8_from_native_byte(const U8 byte, U8** dest);\n#define PERL_ARGS_ASSERT_APPEND_UTF8_FROM_NATIVE_BYTE\t\\\n\tassert(dest)\n#endif\nPERL_CALLCONV I32\tPerl_apply(pTHX_ I32 type, SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_APPLY\t\\\n\tassert(mark); assert(sp)\nPERL_CALLCONV void\tPerl_apply_attrs_string(pTHX_ const char *stashpv, CV *cv, const char *attrstr, STRLEN len);\n#define PERL_ARGS_ASSERT_APPLY_ATTRS_STRING\t\\\n\tassert(stashpv); assert(cv); assert(attrstr)\nPERL_CALLCONV void\tPerl_atfork_lock(void);\nPERL_CALLCONV void\tPerl_atfork_unlock(void);\nPERL_CALLCONV SV**\tPerl_av_arylen_p(pTHX_ AV *av);\n#define PERL_ARGS_ASSERT_AV_ARYLEN_P\t\\\n\tassert(av)\nPERL_CALLCONV void\tPerl_av_clear(pTHX_ AV *av);\n#define PERL_ARGS_ASSERT_AV_CLEAR\t\\\n\tassert(av)\nPERL_CALLCONV void\tPerl_av_create_and_push(pTHX_ AV **const avp, SV *const val);\n#define PERL_ARGS_ASSERT_AV_CREATE_AND_PUSH\t\\\n\tassert(avp); assert(val)\nPERL_CALLCONV SV**\tPerl_av_create_and_unshift_one(pTHX_ AV **const avp, SV *const val);\n#define PERL_ARGS_ASSERT_AV_CREATE_AND_UNSHIFT_ONE\t\\\n\tassert(avp); assert(val)\nPERL_CALLCONV SV*\tPerl_av_delete(pTHX_ AV *av, SSize_t key, I32 flags);\n#define PERL_ARGS_ASSERT_AV_DELETE\t\\\n\tassert(av)\nPERL_CALLCONV bool\tPerl_av_exists(pTHX_ AV *av, SSize_t key)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_AV_EXISTS\t\\\n\tassert(av)\n\nPERL_CALLCONV void\tPerl_av_extend(pTHX_ AV *av, SSize_t key);\n#define PERL_ARGS_ASSERT_AV_EXTEND\t\\\n\tassert(av)\nPERL_CALLCONV void\tPerl_av_extend_guts(pTHX_ AV *av, SSize_t key, SSize_t *maxp, SV ***allocp, SV ***arrayp);\n#define PERL_ARGS_ASSERT_AV_EXTEND_GUTS\t\\\n\tassert(maxp); assert(allocp); assert(arrayp)\nPERL_CALLCONV SV**\tPerl_av_fetch(pTHX_ AV *av, SSize_t key, I32 lval)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_AV_FETCH\t\\\n\tassert(av)\n\nPERL_CALLCONV void\tPerl_av_fill(pTHX_ AV *av, SSize_t fill);\n#define PERL_ARGS_ASSERT_AV_FILL\t\\\n\tassert(av)\nPERL_CALLCONV IV*\tPerl_av_iter_p(pTHX_ AV *av);\n#define PERL_ARGS_ASSERT_AV_ITER_P\t\\\n\tassert(av)\nPERL_CALLCONV SSize_t\tPerl_av_len(pTHX_ AV *av)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_AV_LEN\t\\\n\tassert(av)\n\nPERL_CALLCONV AV*\tPerl_av_make(pTHX_ SSize_t size, SV **strp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_AV_MAKE\t\\\n\tassert(strp)\n\nPERL_CALLCONV SV*\tPerl_av_nonelem(pTHX_ AV *av, SSize_t ix);\n#define PERL_ARGS_ASSERT_AV_NONELEM\t\\\n\tassert(av)\nPERL_CALLCONV SV*\tPerl_av_pop(pTHX_ AV *av);\n#define PERL_ARGS_ASSERT_AV_POP\t\\\n\tassert(av)\nPERL_CALLCONV void\tPerl_av_push(pTHX_ AV *av, SV *val);\n#define PERL_ARGS_ASSERT_AV_PUSH\t\\\n\tassert(av); assert(val)\nPERL_CALLCONV void\tPerl_av_reify(pTHX_ AV *av);\n#define PERL_ARGS_ASSERT_AV_REIFY\t\\\n\tassert(av)\nPERL_CALLCONV SV*\tPerl_av_shift(pTHX_ AV *av)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_AV_SHIFT\t\\\n\tassert(av)\n\nPERL_CALLCONV SV**\tPerl_av_store(pTHX_ AV *av, SSize_t key, SV *val);\n#define PERL_ARGS_ASSERT_AV_STORE\t\\\n\tassert(av)\n/* PERL_CALLCONV SSize_t\tPerl_av_tindex(pTHX_ AV *av)\n\t\t\t__attribute__warn_unused_result__; */\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE SSize_t\tS_av_top_index(pTHX_ AV *av)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_AV_TOP_INDEX\t\\\n\tassert(av)\n#endif\n\nPERL_CALLCONV void\tPerl_av_undef(pTHX_ AV *av);\n#define PERL_ARGS_ASSERT_AV_UNDEF\t\\\n\tassert(av)\nPERL_CALLCONV void\tPerl_av_unshift(pTHX_ AV *av, SSize_t num);\n#define PERL_ARGS_ASSERT_AV_UNSHIFT\t\\\n\tassert(av)\nPERL_CALLCONV OP*\tPerl_bind_match(pTHX_ I32 type, OP *left, OP *right)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_BIND_MATCH\t\\\n\tassert(left); assert(right)\n\nPERL_CALLCONV OP*\tPerl_block_end(pTHX_ I32 floor, OP* seq)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV U8\tPerl_block_gimme(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV int\tPerl_block_start(pTHX_ int full)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_blockhook_register(pTHX_ BHK *hk);\n#define PERL_ARGS_ASSERT_BLOCKHOOK_REGISTER\t\\\n\tassert(hk)\nPERL_CALLCONV void\tPerl_boot_core_PerlIO(pTHX);\nPERL_CALLCONV void\tPerl_boot_core_UNIVERSAL(pTHX);\nPERL_CALLCONV void\tPerl_boot_core_mro(pTHX);\nPERL_CALLCONV int\tPerl_bytes_cmp_utf8(pTHX_ const U8 *b, STRLEN blen, const U8 *u, STRLEN ulen);\n#define PERL_ARGS_ASSERT_BYTES_CMP_UTF8\t\\\n\tassert(b); assert(u)\nPERL_CALLCONV U8*\tPerl_bytes_from_utf8(pTHX_ const U8 *s, STRLEN *lenp, bool *is_utf8p);\n#define PERL_ARGS_ASSERT_BYTES_FROM_UTF8\t\\\n\tassert(s); assert(lenp); assert(is_utf8p)\nPERL_CALLCONV U8*\tPerl_bytes_from_utf8_loc(const U8 *s, STRLEN *lenp, bool *is_utf8p, const U8 ** first_unconverted);\n#define PERL_ARGS_ASSERT_BYTES_FROM_UTF8_LOC\t\\\n\tassert(s); assert(lenp); assert(is_utf8p)\nPERL_CALLCONV U8*\tPerl_bytes_to_utf8(pTHX_ const U8 *s, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_BYTES_TO_UTF8\t\\\n\tassert(s); assert(lenp)\nPERL_CALLCONV I32\tPerl_call_argv(pTHX_ const char* sub_name, I32 flags, char** argv);\n#define PERL_ARGS_ASSERT_CALL_ARGV\t\\\n\tassert(sub_name); assert(argv)\nPERL_CALLCONV void\tPerl_call_atexit(pTHX_ ATEXIT_t fn, void *ptr);\nPERL_CALLCONV void\tPerl_call_list(pTHX_ I32 oldscope, AV *paramList);\n#define PERL_ARGS_ASSERT_CALL_LIST\t\\\n\tassert(paramList)\nPERL_CALLCONV I32\tPerl_call_method(pTHX_ const char* methname, I32 flags);\n#define PERL_ARGS_ASSERT_CALL_METHOD\t\\\n\tassert(methname)\nPERL_CALLCONV I32\tPerl_call_pv(pTHX_ const char* sub_name, I32 flags);\n#define PERL_ARGS_ASSERT_CALL_PV\t\\\n\tassert(sub_name)\nPERL_CALLCONV I32\tPerl_call_sv(pTHX_ SV* sv, volatile I32 flags);\n#define PERL_ARGS_ASSERT_CALL_SV\t\\\n\tassert(sv)\nPERL_CALLCONV const PERL_CONTEXT *\tPerl_caller_cx(pTHX_ I32 level, const PERL_CONTEXT **dbcxp);\nPERL_CALLCONV Malloc_t\tPerl_calloc(MEM_SIZE elements, MEM_SIZE size)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl_cando(pTHX_ Mode_t mode, bool effective, const Stat_t* statbufp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CANDO\t\\\n\tassert(statbufp)\n\nPERL_CALLCONV I32\tPerl_cast_i32(NV f)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV IV\tPerl_cast_iv(NV f)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV U32\tPerl_cast_ulong(NV f)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV UV\tPerl_cast_uv(NV f)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl_check_utf8_print(pTHX_ const U8 *s, const STRLEN len);\n#define PERL_ARGS_ASSERT_CHECK_UTF8_PRINT\t\\\n\tassert(s)\nPERL_CALLCONV OP *\tPerl_ck_anoncode(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_ANONCODE\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_backtick(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_BACKTICK\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_bitop(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_BITOP\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_cmp(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_CMP\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_concat(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_CONCAT\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_defined(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_DEFINED\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_delete(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_DELETE\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_each(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_EACH\t\\\n\tassert(o)\n\nPERL_CALLCONV OP*\tPerl_ck_entersub_args_core(pTHX_ OP *entersubop, GV *namegv, SV *protosv);\n#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_CORE\t\\\n\tassert(entersubop); assert(namegv); assert(protosv)\nPERL_CALLCONV OP*\tPerl_ck_entersub_args_list(pTHX_ OP *entersubop);\n#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_LIST\t\\\n\tassert(entersubop)\nPERL_CALLCONV OP*\tPerl_ck_entersub_args_proto(pTHX_ OP *entersubop, GV *namegv, SV *protosv);\n#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_PROTO\t\\\n\tassert(entersubop); assert(namegv); assert(protosv)\nPERL_CALLCONV OP*\tPerl_ck_entersub_args_proto_or_list(pTHX_ OP *entersubop, GV *namegv, SV *protosv);\n#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_PROTO_OR_LIST\t\\\n\tassert(entersubop); assert(namegv); assert(protosv)\nPERL_CALLCONV OP *\tPerl_ck_eof(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_EOF\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_eval(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_EVAL\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_exec(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_EXEC\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_exists(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_EXISTS\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_ftst(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_FTST\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_fun(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_FUN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_glob(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_GLOB\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_grep(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_GREP\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_index(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_INDEX\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_join(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_JOIN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_length(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_LENGTH\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_lfun(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_LFUN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_listiob(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_LISTIOB\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_match(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_MATCH\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_method(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_METHOD\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_null(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_NULL\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_open(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_OPEN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_prototype(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_PROTOTYPE\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_readline(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_READLINE\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_refassign(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_REFASSIGN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_repeat(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_REPEAT\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_require(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_REQUIRE\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_return(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_RETURN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_rfun(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_RFUN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_rvconst(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_RVCONST\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_sassign(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SASSIGN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_select(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SELECT\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_shift(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SHIFT\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_smartmatch(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SMARTMATCH\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_sort(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SORT\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_spair(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SPAIR\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_split(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SPLIT\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_stringify(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_STRINGIFY\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_subr(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SUBR\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_substr(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SUBSTR\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_svconst(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SVCONST\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_tell(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_TELL\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_trunc(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_TRUNC\t\\\n\tassert(o)\n\nPERL_CALLCONV void\tPerl_ck_warner(pTHX_ U32 err, const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_2,pTHX_3);\n#define PERL_ARGS_ASSERT_CK_WARNER\t\\\n\tassert(pat)\n\nPERL_CALLCONV void\tPerl_ck_warner_d(pTHX_ U32 err, const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_2,pTHX_3);\n#define PERL_ARGS_ASSERT_CK_WARNER_D\t\\\n\tassert(pat)\n\nPERL_CALLCONV bool\tPerl_ckwarn(pTHX_ U32 w)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV bool\tPerl_ckwarn_d(pTHX_ U32 w)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV void\tPerl_clear_defarray(pTHX_ AV* av, bool abandon);\n#define PERL_ARGS_ASSERT_CLEAR_DEFARRAY\t\\\n\tassert(av)\nPERL_CALLCONV const COP*\tPerl_closest_cop(pTHX_ const COP *cop, const OP *o, const OP *curop, bool opnext);\n#define PERL_ARGS_ASSERT_CLOSEST_COP\t\\\n\tassert(cop)\nPERL_CALLCONV const char *\tPerl_cop_fetch_label(pTHX_ COP *const cop, STRLEN *len, U32 *flags);\n#define PERL_ARGS_ASSERT_COP_FETCH_LABEL\t\\\n\tassert(cop)\nPERL_CALLCONV void\tPerl_cop_store_label(pTHX_ COP *const cop, const char *label, STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_COP_STORE_LABEL\t\\\n\tassert(cop); assert(label)\nPERL_CALLCONV SV *\tPerl_core_prototype(pTHX_ SV *sv, const char *name, const int code, int * const opnum);\n#define PERL_ARGS_ASSERT_CORE_PROTOTYPE\t\\\n\tassert(name)\nPERL_CALLCONV OP *\tPerl_coresub_op(pTHX_ SV *const coreargssv, const int code, const int opnum);\n#define PERL_ARGS_ASSERT_CORESUB_OP\t\\\n\tassert(coreargssv)\nPERL_CALLCONV void\tPerl_create_eval_scope(pTHX_ OP *retop, U32 flags);\nPERL_CALLCONV_NO_RET void\tPerl_croak(pTHX_ const char* pat, ...)\n\t\t\t__attribute__noreturn__\n\t\t\t__attribute__format__null_ok__(__printf__,pTHX_1,pTHX_2);\n\nPERL_CALLCONV_NO_RET void\tPerl_croak_caller(const char* pat, ...)\n\t\t\t__attribute__noreturn__\n\t\t\t__attribute__format__null_ok__(__printf__,1,2);\n\nPERL_STATIC_NO_RET void\tS_croak_memory_wrap(void)\n\t\t\t__attribute__noreturn__;\n\nPERL_CALLCONV_NO_RET void\tPerl_croak_no_mem(void)\n\t\t\t__attribute__noreturn__;\n\nPERL_CALLCONV_NO_RET void\tPerl_croak_no_modify(void)\n\t\t\t__attribute__noreturn__;\n\nPERL_CALLCONV_NO_RET void\tPerl_croak_popstack(void)\n\t\t\t__attribute__noreturn__;\n\nPERL_CALLCONV_NO_RET void\tPerl_croak_sv(pTHX_ SV *baseex)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_CROAK_SV\t\\\n\tassert(baseex)\n\nPERL_CALLCONV_NO_RET void\tPerl_croak_xs_usage(const CV *const cv, const char *const params)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_CROAK_XS_USAGE\t\\\n\tassert(cv); assert(params)\n\nPERL_CALLCONV regexp_engine const *\tPerl_current_re_engine(pTHX);\n#ifndef NO_MATHOMS\nPERL_CALLCONV const char *\tPerl_custom_op_desc(pTHX_ const OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CUSTOM_OP_DESC\t\\\n\tassert(o)\n#endif\n\nPERL_CALLCONV XOPRETANY\tPerl_custom_op_get_field(pTHX_ const OP *o, const xop_flags_enum field)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CUSTOM_OP_GET_FIELD\t\\\n\tassert(o)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV const char *\tPerl_custom_op_name(pTHX_ const OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CUSTOM_OP_NAME\t\\\n\tassert(o)\n#endif\n\nPERL_CALLCONV void\tPerl_custom_op_register(pTHX_ Perl_ppaddr_t ppaddr, const XOP *xop);\n#define PERL_ARGS_ASSERT_CUSTOM_OP_REGISTER\t\\\n\tassert(ppaddr); assert(xop)\n/* PERL_CALLCONV const XOP *\tPerl_custom_op_xop(pTHX_ const OP *o); */\nPERL_CALLCONV void\tPerl_cv_ckproto_len_flags(pTHX_ const CV* cv, const GV* gv, const char* p, const STRLEN len, const U32 flags);\n#define PERL_ARGS_ASSERT_CV_CKPROTO_LEN_FLAGS\t\\\n\tassert(cv)\nPERL_CALLCONV CV*\tPerl_cv_clone(pTHX_ CV* proto);\n#define PERL_ARGS_ASSERT_CV_CLONE\t\\\n\tassert(proto)\nPERL_CALLCONV CV*\tPerl_cv_clone_into(pTHX_ CV* proto, CV *target);\n#define PERL_ARGS_ASSERT_CV_CLONE_INTO\t\\\n\tassert(proto); assert(target)\nPERL_CALLCONV SV*\tPerl_cv_const_sv(const CV *const cv)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_cv_const_sv_or_av(const CV *const cv)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_cv_forget_slab(pTHX_ CV *cv);\nPERL_CALLCONV void\tPerl_cv_get_call_checker(pTHX_ CV *cv, Perl_call_checker *ckfun_p, SV **ckobj_p);\n#define PERL_ARGS_ASSERT_CV_GET_CALL_CHECKER\t\\\n\tassert(cv); assert(ckfun_p); assert(ckobj_p)\nPERL_CALLCONV void\tPerl_cv_get_call_checker_flags(pTHX_ CV *cv, U32 gflags, Perl_call_checker *ckfun_p, SV **ckobj_p, U32 *ckflags_p);\n#define PERL_ARGS_ASSERT_CV_GET_CALL_CHECKER_FLAGS\t\\\n\tassert(cv); assert(ckfun_p); assert(ckobj_p); assert(ckflags_p)\nPERL_CALLCONV SV *\tPerl_cv_name(pTHX_ CV *cv, SV *sv, U32 flags);\n#define PERL_ARGS_ASSERT_CV_NAME\t\\\n\tassert(cv)\nPERL_CALLCONV void\tPerl_cv_set_call_checker(pTHX_ CV *cv, Perl_call_checker ckfun, SV *ckobj);\n#define PERL_ARGS_ASSERT_CV_SET_CALL_CHECKER\t\\\n\tassert(cv); assert(ckfun); assert(ckobj)\nPERL_CALLCONV void\tPerl_cv_set_call_checker_flags(pTHX_ CV *cv, Perl_call_checker ckfun, SV *ckobj, U32 ckflags);\n#define PERL_ARGS_ASSERT_CV_SET_CALL_CHECKER_FLAGS\t\\\n\tassert(cv); assert(ckfun); assert(ckobj)\nPERL_CALLCONV void\tPerl_cv_undef(pTHX_ CV* cv);\n#define PERL_ARGS_ASSERT_CV_UNDEF\t\\\n\tassert(cv)\nPERL_CALLCONV void\tPerl_cv_undef_flags(pTHX_ CV* cv, U32 flags);\n#define PERL_ARGS_ASSERT_CV_UNDEF_FLAGS\t\\\n\tassert(cv)\nPERL_CALLCONV GV *\tPerl_cvgv_from_hek(pTHX_ CV* cv);\n#define PERL_ARGS_ASSERT_CVGV_FROM_HEK\t\\\n\tassert(cv)\nPERL_CALLCONV void\tPerl_cvgv_set(pTHX_ CV* cv, GV* gv);\n#define PERL_ARGS_ASSERT_CVGV_SET\t\\\n\tassert(cv)\nPERL_CALLCONV void\tPerl_cvstash_set(pTHX_ CV* cv, HV* stash);\n#define PERL_ARGS_ASSERT_CVSTASH_SET\t\\\n\tassert(cv)\nPERL_CALLCONV void\tPerl_cx_dump(pTHX_ PERL_CONTEXT* cx);\n#define PERL_ARGS_ASSERT_CX_DUMP\t\\\n\tassert(cx)\nPERL_CALLCONV I32\tPerl_cxinc(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_deb(pTHX_ const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_1,pTHX_2);\n#define PERL_ARGS_ASSERT_DEB\t\\\n\tassert(pat)\n\nPERL_CALLCONV void\tPerl_deb_stack_all(pTHX);\nPERL_CALLCONV I32\tPerl_debop(pTHX_ const OP* o);\n#define PERL_ARGS_ASSERT_DEBOP\t\\\n\tassert(o)\nPERL_CALLCONV void\tPerl_debprofdump(pTHX);\nPERL_CALLCONV I32\tPerl_debstack(pTHX);\nPERL_CALLCONV I32\tPerl_debstackptrs(pTHX);\nPERL_CALLCONV SV *\tPerl_defelem_target(pTHX_ SV *sv, MAGIC *mg)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DEFELEM_TARGET\t\\\n\tassert(sv)\n\nPERL_CALLCONV void\tPerl_delete_eval_scope(pTHX);\nPERL_CALLCONV char*\tPerl_delimcpy(char* to, const char* toend, const char* from, const char* fromend, int delim, I32* retlen);\n#define PERL_ARGS_ASSERT_DELIMCPY\t\\\n\tassert(to); assert(toend); assert(from); assert(fromend); assert(retlen)\nPERL_CALLCONV char*\tPerl_delimcpy_no_escape(char* to, const char* toend, const char* from, const char* fromend, int delim, I32* retlen);\n#define PERL_ARGS_ASSERT_DELIMCPY_NO_ESCAPE\t\\\n\tassert(to); assert(toend); assert(from); assert(fromend); assert(retlen)\nPERL_CALLCONV void\tPerl_despatch_signals(pTHX);\nPERL_CALLCONV_NO_RET OP*\tPerl_die(pTHX_ const char* pat, ...)\n\t\t\t__attribute__noreturn__\n\t\t\t__attribute__format__null_ok__(__printf__,pTHX_1,pTHX_2);\n\nPERL_CALLCONV_NO_RET OP*\tPerl_die_sv(pTHX_ SV *baseex)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_DIE_SV\t\\\n\tassert(baseex)\n\nPERL_CALLCONV_NO_RET void\tPerl_die_unwind(pTHX_ SV* msv)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_DIE_UNWIND\t\\\n\tassert(msv)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_do_aexec(pTHX_ SV* really, SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_AEXEC\t\\\n\tassert(mark); assert(sp)\n#endif\nPERL_CALLCONV bool\tPerl_do_aexec5(pTHX_ SV* really, SV** mark, SV** sp, int fd, int do_report);\n#define PERL_ARGS_ASSERT_DO_AEXEC5\t\\\n\tassert(mark); assert(sp)\n#ifndef NO_MATHOMS\nPERL_CALLCONV int\tPerl_do_binmode(pTHX_ PerlIO *fp, int iotype, int mode);\n#define PERL_ARGS_ASSERT_DO_BINMODE\t\\\n\tassert(fp)\n#endif\nPERL_CALLCONV bool\tPerl_do_close(pTHX_ GV* gv, bool not_implicit);\nPERL_CALLCONV void\tPerl_do_dump_pad(pTHX_ I32 level, PerlIO *file, PADLIST *padlist, int full);\n#define PERL_ARGS_ASSERT_DO_DUMP_PAD\t\\\n\tassert(file)\nPERL_CALLCONV bool\tPerl_do_eof(pTHX_ GV* gv);\n#define PERL_ARGS_ASSERT_DO_EOF\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_do_gv_dump(pTHX_ I32 level, PerlIO *file, const char *name, GV *sv);\n#define PERL_ARGS_ASSERT_DO_GV_DUMP\t\\\n\tassert(file); assert(name)\nPERL_CALLCONV void\tPerl_do_gvgv_dump(pTHX_ I32 level, PerlIO *file, const char *name, GV *sv);\n#define PERL_ARGS_ASSERT_DO_GVGV_DUMP\t\\\n\tassert(file); assert(name)\nPERL_CALLCONV void\tPerl_do_hv_dump(pTHX_ I32 level, PerlIO *file, const char *name, HV *sv);\n#define PERL_ARGS_ASSERT_DO_HV_DUMP\t\\\n\tassert(file); assert(name)\nPERL_CALLCONV void\tPerl_do_join(pTHX_ SV *sv, SV *delim, SV **mark, SV **sp);\n#define PERL_ARGS_ASSERT_DO_JOIN\t\\\n\tassert(sv); assert(delim); assert(mark); assert(sp)\nPERL_CALLCONV void\tPerl_do_magic_dump(pTHX_ I32 level, PerlIO *file, const MAGIC *mg, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim);\n#define PERL_ARGS_ASSERT_DO_MAGIC_DUMP\t\\\n\tassert(file)\nPERL_CALLCONV I32\tPerl_do_ncmp(pTHX_ SV *const left, SV *const right)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_NCMP\t\\\n\tassert(left); assert(right)\n\nPERL_CALLCONV void\tPerl_do_op_dump(pTHX_ I32 level, PerlIO *file, const OP *o);\n#define PERL_ARGS_ASSERT_DO_OP_DUMP\t\\\n\tassert(file)\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_do_open(pTHX_ GV* gv, const char* name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO* supplied_fp);\n#define PERL_ARGS_ASSERT_DO_OPEN\t\\\n\tassert(gv); assert(name)\n#endif\nPERL_CALLCONV bool\tPerl_do_open6(pTHX_ GV *gv, const char *oname, STRLEN len, PerlIO *supplied_fp, SV **svp, U32 num);\n#define PERL_ARGS_ASSERT_DO_OPEN6\t\\\n\tassert(gv); assert(oname)\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_do_open9(pTHX_ GV *gv, const char *name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO *supplied_fp, SV *svs, I32 num);\n#define PERL_ARGS_ASSERT_DO_OPEN9\t\\\n\tassert(gv); assert(name); assert(svs)\n#endif\nPERL_CALLCONV bool\tPerl_do_open_raw(pTHX_ GV *gv, const char *oname, STRLEN len, int rawmode, int rawperm, Stat_t *statbufp);\n#define PERL_ARGS_ASSERT_DO_OPEN_RAW\t\\\n\tassert(gv); assert(oname)\nPERL_CALLCONV bool\tPerl_do_openn(pTHX_ GV *gv, const char *oname, I32 len, int as_raw, int rawmode, int rawperm, PerlIO *supplied_fp, SV **svp, I32 num);\n#define PERL_ARGS_ASSERT_DO_OPENN\t\\\n\tassert(gv); assert(oname)\nPERL_CALLCONV void\tPerl_do_pmop_dump(pTHX_ I32 level, PerlIO *file, const PMOP *pm);\n#define PERL_ARGS_ASSERT_DO_PMOP_DUMP\t\\\n\tassert(file)\nPERL_CALLCONV bool\tPerl_do_print(pTHX_ SV* sv, PerlIO* fp);\n#define PERL_ARGS_ASSERT_DO_PRINT\t\\\n\tassert(fp)\nPERL_CALLCONV OP*\tPerl_do_readline(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl_do_seek(pTHX_ GV* gv, Off_t pos, int whence);\nPERL_CALLCONV void\tPerl_do_sprintf(pTHX_ SV* sv, SSize_t len, SV** sarg);\n#define PERL_ARGS_ASSERT_DO_SPRINTF\t\\\n\tassert(sv); assert(sarg)\nPERL_CALLCONV void\tPerl_do_sv_dump(pTHX_ I32 level, PerlIO *file, SV *sv, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim);\n#define PERL_ARGS_ASSERT_DO_SV_DUMP\t\\\n\tassert(file)\nPERL_CALLCONV Off_t\tPerl_do_sysseek(pTHX_ GV* gv, Off_t pos, int whence);\n#define PERL_ARGS_ASSERT_DO_SYSSEEK\t\\\n\tassert(gv)\nPERL_CALLCONV Off_t\tPerl_do_tell(pTHX_ GV* gv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_TELL\t\\\n\tassert(gv)\n\nPERL_CALLCONV Size_t\tPerl_do_trans(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_DO_TRANS\t\\\n\tassert(sv)\nPERL_CALLCONV UV\tPerl_do_vecget(pTHX_ SV* sv, STRLEN offset, int size);\n#define PERL_ARGS_ASSERT_DO_VECGET\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_do_vecset(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_DO_VECSET\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_do_vop(pTHX_ I32 optype, SV* sv, SV* left, SV* right);\n#define PERL_ARGS_ASSERT_DO_VOP\t\\\n\tassert(sv); assert(left); assert(right)\nPERL_CALLCONV OP*\tPerl_dofile(pTHX_ OP* term, I32 force_builtin);\n#define PERL_ARGS_ASSERT_DOFILE\t\\\n\tassert(term)\nPERL_CALLCONV bool\tPerl_doing_taint(int argc, char** argv, char** env)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP *\tPerl_doref(pTHX_ OP *o, I32 type, bool set_op_ref);\n#define PERL_ARGS_ASSERT_DOREF\t\\\n\tassert(o)\nPERL_CALLCONV void\tPerl_dounwind(pTHX_ I32 cxix);\nPERL_CALLCONV U8\tPerl_dowantarray(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_drand48_init_r(perl_drand48_t *random_state, U32 seed);\n#define PERL_ARGS_ASSERT_DRAND48_INIT_R\t\\\n\tassert(random_state)\nPERL_CALLCONV double\tPerl_drand48_r(perl_drand48_t *random_state);\n#define PERL_ARGS_ASSERT_DRAND48_R\t\\\n\tassert(random_state)\nPERL_CALLCONV void\tPerl_dump_all(pTHX);\nPERL_CALLCONV void\tPerl_dump_all_perl(pTHX_ bool justperl);\nPERL_CALLCONV void\tPerl_dump_eval(pTHX);\nPERL_CALLCONV void\tPerl_dump_form(pTHX_ const GV* gv);\n#define PERL_ARGS_ASSERT_DUMP_FORM\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_dump_indent(pTHX_ I32 level, PerlIO *file, const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_3,pTHX_4);\n#define PERL_ARGS_ASSERT_DUMP_INDENT\t\\\n\tassert(file); assert(pat)\n\nPERL_CALLCONV void\tPerl_dump_packsubs(pTHX_ const HV* stash);\n#define PERL_ARGS_ASSERT_DUMP_PACKSUBS\t\\\n\tassert(stash)\nPERL_CALLCONV void\tPerl_dump_packsubs_perl(pTHX_ const HV* stash, bool justperl);\n#define PERL_ARGS_ASSERT_DUMP_PACKSUBS_PERL\t\\\n\tassert(stash)\nPERL_CALLCONV void\tPerl_dump_sub(pTHX_ const GV* gv);\n#define PERL_ARGS_ASSERT_DUMP_SUB\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_dump_sub_perl(pTHX_ const GV* gv, bool justperl);\n#define PERL_ARGS_ASSERT_DUMP_SUB_PERL\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_dump_vindent(pTHX_ I32 level, PerlIO *file, const char* pat, va_list *args);\n#define PERL_ARGS_ASSERT_DUMP_VINDENT\t\\\n\tassert(file); assert(pat)\nPERL_CALLCONV STRLEN*\tPerl_dup_warnings(pTHX_ STRLEN* warnings);\nPERL_CALLCONV void\tPerl_emulate_cop_io(pTHX_ const COP *const c, SV *const sv);\n#define PERL_ARGS_ASSERT_EMULATE_COP_IO\t\\\n\tassert(c); assert(sv)\nPERL_CALLCONV SV*\tPerl_eval_pv(pTHX_ const char* p, I32 croak_on_error);\n#define PERL_ARGS_ASSERT_EVAL_PV\t\\\n\tassert(p)\nPERL_CALLCONV I32\tPerl_eval_sv(pTHX_ SV* sv, I32 flags);\n#define PERL_ARGS_ASSERT_EVAL_SV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_fbm_compile(pTHX_ SV* sv, U32 flags);\n#define PERL_ARGS_ASSERT_FBM_COMPILE\t\\\n\tassert(sv)\nPERL_CALLCONV char*\tPerl_fbm_instr(pTHX_ unsigned char* big, unsigned char* bigend, SV* littlestr, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FBM_INSTR\t\\\n\tassert(big); assert(bigend); assert(littlestr)\n\nPERL_CALLCONV bool\tPerl_feature_is_enabled(pTHX_ const char *const name, STRLEN namelen);\n#define PERL_ARGS_ASSERT_FEATURE_IS_ENABLED\t\\\n\tassert(name)\nPERL_CALLCONV SV*\tPerl_filter_add(pTHX_ filter_t funcp, SV* datasv);\nPERL_CALLCONV void\tPerl_filter_del(pTHX_ filter_t funcp);\n#define PERL_ARGS_ASSERT_FILTER_DEL\t\\\n\tassert(funcp)\nPERL_CALLCONV I32\tPerl_filter_read(pTHX_ int idx, SV *buf_sv, int maxlen)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FILTER_READ\t\\\n\tassert(buf_sv)\n\nPERL_CALLCONV void\tPerl_finalize_optree(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_FINALIZE_OPTREE\t\\\n\tassert(o)\nPERL_CALLCONV CV *\tPerl_find_lexical_cv(pTHX_ PADOFFSET off);\nPERL_CALLCONV CV*\tPerl_find_runcv(pTHX_ U32 *db_seqp)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV CV*\tPerl_find_runcv_where(pTHX_ U8 cond, IV arg, U32 *db_seqp)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_find_rundefsv(pTHX);\nPERL_CALLCONV PADOFFSET\tPerl_find_rundefsvoffset(pTHX)\n\t\t\t__attribute__deprecated__;\n\nPERL_CALLCONV char*\tPerl_find_script(pTHX_ const char *scriptname, bool dosearch, const char *const *const search_ext, I32 flags);\n#define PERL_ARGS_ASSERT_FIND_SCRIPT\t\\\n\tassert(scriptname)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE I32\tPerl_foldEQ(const char* a, const char* b, I32 len);\n#define PERL_ARGS_ASSERT_FOLDEQ\t\\\n\tassert(a); assert(b)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE I32\tPerl_foldEQ_latin1(const char* a, const char* b, I32 len);\n#define PERL_ARGS_ASSERT_FOLDEQ_LATIN1\t\\\n\tassert(a); assert(b)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE I32\tPerl_foldEQ_locale(const char* a, const char* b, I32 len);\n#define PERL_ARGS_ASSERT_FOLDEQ_LOCALE\t\\\n\tassert(a); assert(b)\n#endif\n/* PERL_CALLCONV I32\tfoldEQ_utf8(pTHX_ const char *s1, char **pe1, UV l1, bool u1, const char *s2, char **pe2, UV l2, bool u2); */\nPERL_CALLCONV I32\tPerl_foldEQ_utf8_flags(pTHX_ const char *s1, char **pe1, UV l1, bool u1, const char *s2, char **pe2, UV l2, bool u2, U32 flags);\n#define PERL_ARGS_ASSERT_FOLDEQ_UTF8_FLAGS\t\\\n\tassert(s1); assert(s2)\nPERL_CALLCONV char*\tPerl_form(pTHX_ const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_1,pTHX_2);\n#define PERL_ARGS_ASSERT_FORM\t\\\n\tassert(pat)\n\nPERL_CALLCONV void\tPerl_free_tied_hv_pool(pTHX);\nPERL_CALLCONV void\tPerl_free_tmps(pTHX);\nPERL_CALLCONV SV*\tPerl_get_and_check_backslash_N_name(pTHX_ const char* s, const char* const e, const bool is_utf8, const char** error_msg)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_AND_CHECK_BACKSLASH_N_NAME\t\\\n\tassert(s); assert(e); assert(error_msg)\n\nPERL_CALLCONV AV*\tPerl_get_av(pTHX_ const char *name, I32 flags);\n#define PERL_ARGS_ASSERT_GET_AV\t\\\n\tassert(name)\nPERL_CALLCONV void*\tPerl_get_context(void)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV CV*\tPerl_get_cv(pTHX_ const char* name, I32 flags);\n#define PERL_ARGS_ASSERT_GET_CV\t\\\n\tassert(name)\nPERL_CALLCONV CV*\tPerl_get_cvn_flags(pTHX_ const char* name, STRLEN len, I32 flags);\n#define PERL_ARGS_ASSERT_GET_CVN_FLAGS\t\\\n\tassert(name)\nPERL_CALLCONV void\tPerl_get_db_sub(pTHX_ SV **svp, CV *cv);\n#define PERL_ARGS_ASSERT_GET_DB_SUB\t\\\n\tassert(cv)\nPERL_CALLCONV void\tPerl_get_hash_seed(pTHX_ unsigned char * const seed_buffer);\n#define PERL_ARGS_ASSERT_GET_HASH_SEED\t\\\n\tassert(seed_buffer)\nPERL_CALLCONV HV*\tPerl_get_hv(pTHX_ const char *name, I32 flags);\n#define PERL_ARGS_ASSERT_GET_HV\t\\\n\tassert(name)\nPERL_CALLCONV const char*\tPerl_get_no_modify(pTHX)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV char**\tPerl_get_op_descs(pTHX)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV char**\tPerl_get_op_names(pTHX)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV U32*\tPerl_get_opargs(pTHX)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV PPADDR_t*\tPerl_get_ppaddr(pTHX)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV REGEXP *\tPerl_get_re_arg(pTHX_ SV *sv);\nPERL_CALLCONV SV*\tPerl_get_sv(pTHX_ const char *name, I32 flags);\n#define PERL_ARGS_ASSERT_GET_SV\t\\\n\tassert(name)\nPERL_CALLCONV MGVTBL*\tPerl_get_vtbl(pTHX_ int vtbl_id)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV int\tPerl_getcwd_sv(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_GETCWD_SV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_gp_free(pTHX_ GV* gv);\nPERL_CALLCONV GP*\tPerl_gp_ref(pTHX_ GP* gp);\nPERL_CALLCONV bool\tPerl_grok_atoUV(const char* pv, UV* valptr, const char** endptr);\n#define PERL_ARGS_ASSERT_GROK_ATOUV\t\\\n\tassert(pv); assert(valptr)\nPERL_CALLCONV UV\tPerl_grok_bin(pTHX_ const char* start, STRLEN* len_p, I32* flags, NV *result);\n#define PERL_ARGS_ASSERT_GROK_BIN\t\\\n\tassert(start); assert(len_p); assert(flags)\nPERL_CALLCONV UV\tPerl_grok_hex(pTHX_ const char* start, STRLEN* len_p, I32* flags, NV *result);\n#define PERL_ARGS_ASSERT_GROK_HEX\t\\\n\tassert(start); assert(len_p); assert(flags)\nPERL_CALLCONV int\tPerl_grok_infnan(pTHX_ const char** sp, const char *send);\n#define PERL_ARGS_ASSERT_GROK_INFNAN\t\\\n\tassert(sp); assert(send)\nPERL_CALLCONV int\tPerl_grok_number(pTHX_ const char *pv, STRLEN len, UV *valuep);\n#define PERL_ARGS_ASSERT_GROK_NUMBER\t\\\n\tassert(pv)\nPERL_CALLCONV int\tPerl_grok_number_flags(pTHX_ const char *pv, STRLEN len, UV *valuep, U32 flags);\n#define PERL_ARGS_ASSERT_GROK_NUMBER_FLAGS\t\\\n\tassert(pv)\nPERL_CALLCONV bool\tPerl_grok_numeric_radix(pTHX_ const char **sp, const char *send)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GROK_NUMERIC_RADIX\t\\\n\tassert(sp); assert(send)\n\nPERL_CALLCONV UV\tPerl_grok_oct(pTHX_ const char* start, STRLEN* len_p, I32* flags, NV *result);\n#define PERL_ARGS_ASSERT_GROK_OCT\t\\\n\tassert(start); assert(len_p); assert(flags)\n#ifndef NO_MATHOMS\nPERL_CALLCONV GV*\tPerl_gv_AVadd(pTHX_ GV *gv);\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV GV*\tPerl_gv_HVadd(pTHX_ GV *gv);\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV GV*\tPerl_gv_IOadd(pTHX_ GV* gv);\n#endif\nPERL_CALLCONV GV*\tPerl_gv_add_by_type(pTHX_ GV *gv, svtype type);\n/* PERL_CALLCONV GV*\tgv_autoload4(pTHX_ HV* stash, const char* name, STRLEN len, I32 method)\n\t\t\t__attribute__warn_unused_result__; */\n\nPERL_CALLCONV GV*\tPerl_gv_autoload_pv(pTHX_ HV* stash, const char* namepv, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GV_AUTOLOAD_PV\t\\\n\tassert(namepv)\n\nPERL_CALLCONV GV*\tPerl_gv_autoload_pvn(pTHX_ HV* stash, const char* name, STRLEN len, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GV_AUTOLOAD_PVN\t\\\n\tassert(name)\n\nPERL_CALLCONV GV*\tPerl_gv_autoload_sv(pTHX_ HV* stash, SV* namesv, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GV_AUTOLOAD_SV\t\\\n\tassert(namesv)\n\nPERL_CALLCONV void\tPerl_gv_check(pTHX_ HV* stash);\n#define PERL_ARGS_ASSERT_GV_CHECK\t\\\n\tassert(stash)\nPERL_CALLCONV SV*\tPerl_gv_const_sv(pTHX_ GV* gv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GV_CONST_SV\t\\\n\tassert(gv)\n\nPERL_CALLCONV void\tPerl_gv_dump(pTHX_ GV* gv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_gv_efullname(pTHX_ SV* sv, const GV* gv);\n#define PERL_ARGS_ASSERT_GV_EFULLNAME\t\\\n\tassert(sv); assert(gv)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_gv_efullname3(pTHX_ SV* sv, const GV* gv, const char* prefix);\n#define PERL_ARGS_ASSERT_GV_EFULLNAME3\t\\\n\tassert(sv); assert(gv)\n#endif\nPERL_CALLCONV void\tPerl_gv_efullname4(pTHX_ SV* sv, const GV* gv, const char* prefix, bool keepmain);\n#define PERL_ARGS_ASSERT_GV_EFULLNAME4\t\\\n\tassert(sv); assert(gv)\nPERL_CALLCONV GV*\tPerl_gv_fetchfile(pTHX_ const char* name);\n#define PERL_ARGS_ASSERT_GV_FETCHFILE\t\\\n\tassert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchfile_flags(pTHX_ const char *const name, const STRLEN len, const U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHFILE_FLAGS\t\\\n\tassert(name)\n/* PERL_CALLCONV GV*\tgv_fetchmeth(pTHX_ HV* stash, const char* name, STRLEN len, I32 level); */\n/* PERL_CALLCONV GV*\tgv_fetchmeth_autoload(pTHX_ HV* stash, const char* name, STRLEN len, I32 level); */\nPERL_CALLCONV GV*\tPerl_gv_fetchmeth_pv(pTHX_ HV* stash, const char* name, I32 level, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETH_PV\t\\\n\tassert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchmeth_pv_autoload(pTHX_ HV* stash, const char* name, I32 level, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETH_PV_AUTOLOAD\t\\\n\tassert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchmeth_pvn(pTHX_ HV* stash, const char* name, STRLEN len, I32 level, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETH_PVN\t\\\n\tassert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchmeth_pvn_autoload(pTHX_ HV* stash, const char* name, STRLEN len, I32 level, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETH_PVN_AUTOLOAD\t\\\n\tassert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchmeth_sv(pTHX_ HV* stash, SV* namesv, I32 level, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETH_SV\t\\\n\tassert(namesv)\nPERL_CALLCONV GV*\tPerl_gv_fetchmeth_sv_autoload(pTHX_ HV* stash, SV* namesv, I32 level, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETH_SV_AUTOLOAD\t\\\n\tassert(namesv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV GV*\tPerl_gv_fetchmethod(pTHX_ HV* stash, const char* name);\n#define PERL_ARGS_ASSERT_GV_FETCHMETHOD\t\\\n\tassert(stash); assert(name)\n#endif\nPERL_CALLCONV GV*\tPerl_gv_fetchmethod_autoload(pTHX_ HV* stash, const char* name, I32 autoload);\n#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_AUTOLOAD\t\\\n\tassert(stash); assert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchmethod_pv_flags(pTHX_ HV* stash, const char* name, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_PV_FLAGS\t\\\n\tassert(stash); assert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchmethod_pvn_flags(pTHX_ HV* stash, const char* name, const STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_PVN_FLAGS\t\\\n\tassert(stash); assert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchmethod_sv_flags(pTHX_ HV* stash, SV* namesv, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_SV_FLAGS\t\\\n\tassert(stash); assert(namesv)\nPERL_CALLCONV GV*\tPerl_gv_fetchpv(pTHX_ const char *nambeg, I32 add, const svtype sv_type);\n#define PERL_ARGS_ASSERT_GV_FETCHPV\t\\\n\tassert(nambeg)\nPERL_CALLCONV GV*\tPerl_gv_fetchpvn_flags(pTHX_ const char* name, STRLEN len, I32 flags, const svtype sv_type);\n#define PERL_ARGS_ASSERT_GV_FETCHPVN_FLAGS\t\\\n\tassert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchsv(pTHX_ SV *name, I32 flags, const svtype sv_type);\n#define PERL_ARGS_ASSERT_GV_FETCHSV\t\\\n\tassert(name)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_gv_fullname(pTHX_ SV* sv, const GV* gv);\n#define PERL_ARGS_ASSERT_GV_FULLNAME\t\\\n\tassert(sv); assert(gv)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_gv_fullname3(pTHX_ SV* sv, const GV* gv, const char* prefix);\n#define PERL_ARGS_ASSERT_GV_FULLNAME3\t\\\n\tassert(sv); assert(gv)\n#endif\nPERL_CALLCONV void\tPerl_gv_fullname4(pTHX_ SV* sv, const GV* gv, const char* prefix, bool keepmain);\n#define PERL_ARGS_ASSERT_GV_FULLNAME4\t\\\n\tassert(sv); assert(gv)\nPERL_CALLCONV CV*\tPerl_gv_handler(pTHX_ HV* stash, I32 id)\n\t\t\t__attribute__warn_unused_result__;\n\n/* PERL_CALLCONV void\tgv_init(pTHX_ GV* gv, HV* stash, const char* name, STRLEN len, int multi); */\nPERL_CALLCONV void\tPerl_gv_init_pv(pTHX_ GV* gv, HV* stash, const char* name, U32 flags);\n#define PERL_ARGS_ASSERT_GV_INIT_PV\t\\\n\tassert(gv); assert(name)\nPERL_CALLCONV void\tPerl_gv_init_pvn(pTHX_ GV* gv, HV* stash, const char* name, STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_GV_INIT_PVN\t\\\n\tassert(gv); assert(name)\nPERL_CALLCONV void\tPerl_gv_init_sv(pTHX_ GV* gv, HV* stash, SV* namesv, U32 flags);\n#define PERL_ARGS_ASSERT_GV_INIT_SV\t\\\n\tassert(gv); assert(namesv)\nPERL_CALLCONV void\tPerl_gv_name_set(pTHX_ GV* gv, const char *name, U32 len, U32 flags);\n#define PERL_ARGS_ASSERT_GV_NAME_SET\t\\\n\tassert(gv); assert(name)\nPERL_CALLCONV GV *\tPerl_gv_override(pTHX_ const char * const name, const STRLEN len);\n#define PERL_ARGS_ASSERT_GV_OVERRIDE\t\\\n\tassert(name)\nPERL_CALLCONV void\tPerl_gv_setref(pTHX_ SV *const dstr, SV *const sstr);\n#define PERL_ARGS_ASSERT_GV_SETREF\t\\\n\tassert(dstr); assert(sstr)\nPERL_CALLCONV HV*\tPerl_gv_stashpv(pTHX_ const char* name, I32 flags);\n#define PERL_ARGS_ASSERT_GV_STASHPV\t\\\n\tassert(name)\nPERL_CALLCONV HV*\tPerl_gv_stashpvn(pTHX_ const char* name, U32 namelen, I32 flags);\n#define PERL_ARGS_ASSERT_GV_STASHPVN\t\\\n\tassert(name)\nPERL_CALLCONV HV*\tPerl_gv_stashsv(pTHX_ SV* sv, I32 flags);\n#define PERL_ARGS_ASSERT_GV_STASHSV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_gv_try_downgrade(pTHX_ GV* gv);\n#define PERL_ARGS_ASSERT_GV_TRY_DOWNGRADE\t\\\n\tassert(gv)\nPERL_CALLCONV AV**\tPerl_hv_backreferences_p(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_HV_BACKREFERENCES_P\t\\\n\tassert(hv)\nPERL_CALLCONV SV*\tPerl_hv_bucket_ratio(pTHX_ HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_BUCKET_RATIO\t\\\n\tassert(hv)\n\nPERL_CALLCONV void\tPerl_hv_clear(pTHX_ HV *hv);\nPERL_CALLCONV void\tPerl_hv_clear_placeholders(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_HV_CLEAR_PLACEHOLDERS\t\\\n\tassert(hv)\nPERL_CALLCONV void*\tPerl_hv_common(pTHX_ HV *hv, SV *keysv, const char* key, STRLEN klen, int flags, int action, SV *val, U32 hash);\nPERL_CALLCONV void*\tPerl_hv_common_key_len(pTHX_ HV *hv, const char *key, I32 klen_i32, const int action, SV *val, const U32 hash);\n#define PERL_ARGS_ASSERT_HV_COMMON_KEY_LEN\t\\\n\tassert(key)\nPERL_CALLCONV HV *\tPerl_hv_copy_hints_hv(pTHX_ HV *const ohv)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_hv_delayfree_ent(pTHX_ HV *hv, HE *entry);\n#define PERL_ARGS_ASSERT_HV_DELAYFREE_ENT\t\\\n\tassert(hv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV SV*\tPerl_hv_delete(pTHX_ HV *hv, const char *key, I32 klen, I32 flags);\n#define PERL_ARGS_ASSERT_HV_DELETE\t\\\n\tassert(key)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV SV*\tPerl_hv_delete_ent(pTHX_ HV *hv, SV *keysv, I32 flags, U32 hash);\n#define PERL_ARGS_ASSERT_HV_DELETE_ENT\t\\\n\tassert(keysv)\n#endif\nPERL_CALLCONV HE**\tPerl_hv_eiter_p(pTHX_ HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_EITER_P\t\\\n\tassert(hv)\n\nPERL_CALLCONV void\tPerl_hv_eiter_set(pTHX_ HV *hv, HE *eiter);\n#define PERL_ARGS_ASSERT_HV_EITER_SET\t\\\n\tassert(hv)\nPERL_CALLCONV void\tPerl_hv_ename_add(pTHX_ HV *hv, const char *name, U32 len, U32 flags);\n#define PERL_ARGS_ASSERT_HV_ENAME_ADD\t\\\n\tassert(hv); assert(name)\nPERL_CALLCONV void\tPerl_hv_ename_delete(pTHX_ HV *hv, const char *name, U32 len, U32 flags);\n#define PERL_ARGS_ASSERT_HV_ENAME_DELETE\t\\\n\tassert(hv); assert(name)\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_hv_exists(pTHX_ HV *hv, const char *key, I32 klen)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_EXISTS\t\\\n\tassert(key)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_hv_exists_ent(pTHX_ HV *hv, SV *keysv, U32 hash)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_EXISTS_ENT\t\\\n\tassert(keysv)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV SV**\tPerl_hv_fetch(pTHX_ HV *hv, const char *key, I32 klen, I32 lval);\n#define PERL_ARGS_ASSERT_HV_FETCH\t\\\n\tassert(key)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV HE*\tPerl_hv_fetch_ent(pTHX_ HV *hv, SV *keysv, I32 lval, U32 hash);\n#define PERL_ARGS_ASSERT_HV_FETCH_ENT\t\\\n\tassert(keysv)\n#endif\nPERL_CALLCONV STRLEN\tPerl_hv_fill(pTHX_ HV *const hv);\n#define PERL_ARGS_ASSERT_HV_FILL\t\\\n\tassert(hv)\nPERL_CALLCONV void\tPerl_hv_free_ent(pTHX_ HV *hv, HE *entry);\n#define PERL_ARGS_ASSERT_HV_FREE_ENT\t\\\n\tassert(hv)\nPERL_CALLCONV I32\tPerl_hv_iterinit(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_HV_ITERINIT\t\\\n\tassert(hv)\nPERL_CALLCONV char*\tPerl_hv_iterkey(pTHX_ HE* entry, I32* retlen)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_ITERKEY\t\\\n\tassert(entry); assert(retlen)\n\nPERL_CALLCONV SV*\tPerl_hv_iterkeysv(pTHX_ HE* entry)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_ITERKEYSV\t\\\n\tassert(entry)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV HE*\tPerl_hv_iternext(pTHX_ HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_ITERNEXT\t\\\n\tassert(hv)\n#endif\n\nPERL_CALLCONV HE*\tPerl_hv_iternext_flags(pTHX_ HV *hv, I32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_ITERNEXT_FLAGS\t\\\n\tassert(hv)\n\nPERL_CALLCONV SV*\tPerl_hv_iternextsv(pTHX_ HV *hv, char **key, I32 *retlen)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_ITERNEXTSV\t\\\n\tassert(hv); assert(key); assert(retlen)\n\nPERL_CALLCONV SV*\tPerl_hv_iterval(pTHX_ HV *hv, HE *entry)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_ITERVAL\t\\\n\tassert(hv); assert(entry)\n\nPERL_CALLCONV void\tPerl_hv_ksplit(pTHX_ HV *hv, IV newmax);\n#define PERL_ARGS_ASSERT_HV_KSPLIT\t\\\n\tassert(hv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_hv_magic(pTHX_ HV *hv, GV *gv, int how);\n#define PERL_ARGS_ASSERT_HV_MAGIC\t\\\n\tassert(hv)\n#endif\nPERL_CALLCONV void\tPerl_hv_name_set(pTHX_ HV *hv, const char *name, U32 len, U32 flags);\n#define PERL_ARGS_ASSERT_HV_NAME_SET\t\\\n\tassert(hv)\nPERL_CALLCONV I32\tPerl_hv_placeholders_get(pTHX_ const HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_PLACEHOLDERS_GET\t\\\n\tassert(hv)\n\nPERL_CALLCONV SSize_t*\tPerl_hv_placeholders_p(pTHX_ HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_PLACEHOLDERS_P\t\\\n\tassert(hv)\n\nPERL_CALLCONV void\tPerl_hv_placeholders_set(pTHX_ HV *hv, I32 ph);\n#define PERL_ARGS_ASSERT_HV_PLACEHOLDERS_SET\t\\\n\tassert(hv)\nPERL_CALLCONV void\tPerl_hv_pushkv(pTHX_ HV *hv, U32 flags);\n#define PERL_ARGS_ASSERT_HV_PUSHKV\t\\\n\tassert(hv)\nPERL_CALLCONV void\tPerl_hv_rand_set(pTHX_ HV *hv, U32 new_xhv_rand);\n#define PERL_ARGS_ASSERT_HV_RAND_SET\t\\\n\tassert(hv)\nPERL_CALLCONV I32*\tPerl_hv_riter_p(pTHX_ HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_RITER_P\t\\\n\tassert(hv)\n\nPERL_CALLCONV void\tPerl_hv_riter_set(pTHX_ HV *hv, I32 riter);\n#define PERL_ARGS_ASSERT_HV_RITER_SET\t\\\n\tassert(hv)\nPERL_CALLCONV SV*\tPerl_hv_scalar(pTHX_ HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_SCALAR\t\\\n\tassert(hv)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV SV**\tPerl_hv_store(pTHX_ HV *hv, const char *key, I32 klen, SV *val, U32 hash);\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV HE*\tPerl_hv_store_ent(pTHX_ HV *hv, SV *key, SV *val, U32 hash);\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV SV**\tPerl_hv_store_flags(pTHX_ HV *hv, const char *key, I32 klen, SV *val, U32 hash, int flags);\n#endif\n/* PERL_CALLCONV void\thv_undef(pTHX_ HV *hv); */\nPERL_CALLCONV void\tPerl_hv_undef_flags(pTHX_ HV *hv, U32 flags);\n/* PERL_CALLCONV I32\tibcmp(pTHX_ const char* a, const char* b, I32 len)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__; */\n\n/* PERL_CALLCONV I32\tibcmp_locale(pTHX_ const char* a, const char* b, I32 len)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__; */\n\n/* PERL_CALLCONV I32\tibcmp_utf8(pTHX_ const char *s1, char **pe1, UV l1, bool u1, const char *s2, char **pe2, UV l2, bool u2); */\nPERL_CALLCONV void\tPerl_init_argv_symbols(pTHX_ int argc, char **argv);\n#define PERL_ARGS_ASSERT_INIT_ARGV_SYMBOLS\t\\\n\tassert(argv)\nPERL_CALLCONV void\tPerl_init_constants(pTHX);\nPERL_CALLCONV void\tPerl_init_dbargs(pTHX);\nPERL_CALLCONV void\tPerl_init_debugger(pTHX);\nPERL_CALLCONV int\tPerl_init_i18nl10n(pTHX_ int printwarn);\n#ifndef NO_MATHOMS\nPERL_CALLCONV int\tPerl_init_i18nl14n(pTHX_ int printwarn);\n#endif\nPERL_CALLCONV void\tPerl_init_named_cv(pTHX_ CV *cv, OP *nameop);\n#define PERL_ARGS_ASSERT_INIT_NAMED_CV\t\\\n\tassert(cv); assert(nameop)\nPERL_CALLCONV void\tPerl_init_stacks(pTHX);\nPERL_CALLCONV void\tPerl_init_tm(pTHX_ struct tm *ptm);\n#define PERL_ARGS_ASSERT_INIT_TM\t\\\n\tassert(ptm)\nPERL_CALLCONV void\tPerl_init_uniprops(pTHX);\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_instr(const char* big, const char* little)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#define PERL_ARGS_ASSERT_INSTR\t\\\n\tassert(big); assert(little)\n#endif\n\nPERL_CALLCONV U32\tPerl_intro_my(pTHX);\nPERL_CALLCONV OP*\tPerl_invert(pTHX_ OP* cmd)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl_io_close(pTHX_ IO* io, GV *gv, bool not_implicit, bool warn_on_fail);\n#define PERL_ARGS_ASSERT_IO_CLOSE\t\\\n\tassert(io)\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_isALNUM_lazy(pTHX_ const char* p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISALNUM_LAZY\t\\\n\tassert(p)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE Size_t\tS_isC9_STRICT_UTF8_CHAR(const U8 * const s0, const U8 * const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISC9_STRICT_UTF8_CHAR\t\\\n\tassert(s0); assert(e)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_isIDFIRST_lazy(pTHX_ const char* p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISIDFIRST_LAZY\t\\\n\tassert(p)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE Size_t\tS_isSTRICT_UTF8_CHAR(const U8 * const s0, const U8 * const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISSTRICT_UTF8_CHAR\t\\\n\tassert(s0); assert(e)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE Size_t\tS_isUTF8_CHAR(const U8 * const s0, const U8 * const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISUTF8_CHAR\t\\\n\tassert(s0); assert(e)\n#endif\n\n/* PERL_CALLCONV bool\tPerl_is_ascii_string(const U8* const s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__; */\n\n/* PERL_CALLCONV bool\tPerl_is_c9strict_utf8_string(const U8 *s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__; */\n\n/* PERL_CALLCONV bool\tis_c9strict_utf8_string_loc(const U8 *s, STRLEN len, const U8 **ep); */\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_c9strict_utf8_string_loclen(const U8 *s, STRLEN len, const U8 **ep, STRLEN *el);\n#define PERL_ARGS_ASSERT_IS_C9STRICT_UTF8_STRING_LOCLEN\t\\\n\tassert(s)\n#endif\n/* PERL_CALLCONV bool\tPerl_is_invariant_string(const U8* const s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__; */\n\nPERL_CALLCONV I32\tPerl_is_lvalue_sub(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_safe_syscall(pTHX_ const char *pv, STRLEN len, const char *what, const char *op_name)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_SAFE_SYSCALL\t\\\n\tassert(pv); assert(what); assert(op_name)\n#endif\n\n/* PERL_CALLCONV bool\tPerl_is_strict_utf8_string(const U8 *s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__; */\n\n/* PERL_CALLCONV bool\tis_strict_utf8_string_loc(const U8 *s, STRLEN len, const U8 **ep); */\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_strict_utf8_string_loclen(const U8 *s, STRLEN len, const U8 **ep, STRLEN *el);\n#define PERL_ARGS_ASSERT_IS_STRICT_UTF8_STRING_LOCLEN\t\\\n\tassert(s)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_alnum(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_alnum_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_alnumc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_alnumc_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_alpha(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_alpha_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_ascii(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_ascii_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_blank(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_blank_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_cntrl(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_cntrl_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_digit(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_digit_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_graph(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_graph_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_idfirst(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_idfirst_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_lower(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_lower_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_print(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_print_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_punct(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_punct_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_space(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_space_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_upper(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_upper_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_xdigit(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_xdigit_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_alnum(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_ALNUM\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_alnumc(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_ALNUMC\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_alpha(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_ALPHA\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_ascii(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_ASCII\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_blank(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_BLANK\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV STRLEN\tPerl_is_utf8_char(const U8 *s)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_IS_UTF8_CHAR\t\\\n\tassert(s)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV STRLEN\tPerl_is_utf8_char_buf(const U8 *buf, const U8 *buf_end);\n#define PERL_ARGS_ASSERT_IS_UTF8_CHAR_BUF\t\\\n\tassert(buf); assert(buf_end)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_cntrl(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_CNTRL\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_digit(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_DIGIT\t\\\n\tassert(p)\n#endif\n\n/* PERL_CALLCONV bool\tis_utf8_fixed_width_buf_flags(const U8 * const s, STRLEN len, const U32 flags); */\n/* PERL_CALLCONV bool\tis_utf8_fixed_width_buf_loc_flags(const U8 * const s, STRLEN len, const U8 **ep, const U32 flags); */\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_fixed_width_buf_loclen_flags(const U8 * const s, STRLEN len, const U8 **ep, STRLEN *el, const U32 flags);\n#define PERL_ARGS_ASSERT_IS_UTF8_FIXED_WIDTH_BUF_LOCLEN_FLAGS\t\\\n\tassert(s)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_graph(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_GRAPH\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_idcont(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_IDCONT\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_idfirst(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_IDFIRST\t\\\n\tassert(p)\n#endif\n\n/* PERL_CALLCONV bool\tis_utf8_invariant_string(const U8* const s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__; */\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_invariant_string_loc(const U8* const s, STRLEN len, const U8 ** ep)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_INVARIANT_STRING_LOC\t\\\n\tassert(s)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_lower(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_LOWER\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_mark(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_MARK\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_perl_space(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_PERL_SPACE\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_perl_word(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_PERL_WORD\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_posix_digit(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_POSIX_DIGIT\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_print(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_PRINT\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_punct(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_PUNCT\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_space(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_SPACE\t\\\n\tassert(p)\n#endif\n\n/* PERL_CALLCONV bool\tPerl_is_utf8_string(const U8 *s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__; */\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_string_flags(const U8 *s, STRLEN len, const U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_STRING_FLAGS\t\\\n\tassert(s)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_string_loc(const U8 *s, const STRLEN len, const U8 **ep);\n#define PERL_ARGS_ASSERT_IS_UTF8_STRING_LOC\t\\\n\tassert(s); assert(ep)\n#endif\n/* PERL_CALLCONV bool\tis_utf8_string_loc_flags(const U8 *s, STRLEN len, const U8 **ep, const U32 flags); */\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tPerl_is_utf8_string_loclen(const U8 *s, STRLEN len, const U8 **ep, STRLEN *el);\n#define PERL_ARGS_ASSERT_IS_UTF8_STRING_LOCLEN\t\\\n\tassert(s)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_string_loclen_flags(const U8 *s, STRLEN len, const U8 **ep, STRLEN *el, const U32 flags);\n#define PERL_ARGS_ASSERT_IS_UTF8_STRING_LOCLEN_FLAGS\t\\\n\tassert(s)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_upper(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_UPPER\t\\\n\tassert(p)\n#endif\n\n/* PERL_CALLCONV bool\tis_utf8_valid_partial_char(const U8 * const s, const U8 * const e)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__; */\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_valid_partial_char_flags(const U8 * const s, const U8 * const e, const U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_VALID_PARTIAL_CHAR_FLAGS\t\\\n\tassert(s); assert(e)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_xdigit(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_XDIGIT\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_xidcont(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_XIDCONT\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_xidfirst(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_XIDFIRST\t\\\n\tassert(p)\n#endif\n\nPERL_CALLCONV bool\tPerl_isinfnan(NV nv)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV bool\tPerl_isinfnansv(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_ISINFNANSV\t\\\n\tassert(sv)\nPERL_CALLCONV OP*\tPerl_jmaybe(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_JMAYBE\t\\\n\tassert(o)\nPERL_CALLCONV I32\tPerl_keyword(pTHX_ const char *name, I32 len, bool all_keywords)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#define PERL_ARGS_ASSERT_KEYWORD\t\\\n\tassert(name)\n\nPERL_CALLCONV int\tPerl_keyword_plugin_standard(pTHX_ char* keyword_ptr, STRLEN keyword_len, OP** op_ptr);\n#define PERL_ARGS_ASSERT_KEYWORD_PLUGIN_STANDARD\t\\\n\tassert(keyword_ptr); assert(op_ptr)\nPERL_CALLCONV void\tPerl_leave_adjust_stacks(pTHX_ SV **from_sp, SV **to_sp, U8 gimme, int filter);\n#define PERL_ARGS_ASSERT_LEAVE_ADJUST_STACKS\t\\\n\tassert(from_sp); assert(to_sp)\nPERL_CALLCONV void\tPerl_leave_scope(pTHX_ I32 base);\nPERL_CALLCONV bool\tPerl_lex_bufutf8(pTHX);\nPERL_CALLCONV void\tPerl_lex_discard_to(pTHX_ char* ptr);\n#define PERL_ARGS_ASSERT_LEX_DISCARD_TO\t\\\n\tassert(ptr)\nPERL_CALLCONV char*\tPerl_lex_grow_linestr(pTHX_ STRLEN len);\nPERL_CALLCONV bool\tPerl_lex_next_chunk(pTHX_ U32 flags);\nPERL_CALLCONV I32\tPerl_lex_peek_unichar(pTHX_ U32 flags);\nPERL_CALLCONV void\tPerl_lex_read_space(pTHX_ U32 flags);\nPERL_CALLCONV void\tPerl_lex_read_to(pTHX_ char* ptr);\n#define PERL_ARGS_ASSERT_LEX_READ_TO\t\\\n\tassert(ptr)\nPERL_CALLCONV I32\tPerl_lex_read_unichar(pTHX_ U32 flags);\nPERL_CALLCONV void\tPerl_lex_start(pTHX_ SV* line, PerlIO *rsfp, U32 flags);\nPERL_CALLCONV void\tPerl_lex_stuff_pv(pTHX_ const char* pv, U32 flags);\n#define PERL_ARGS_ASSERT_LEX_STUFF_PV\t\\\n\tassert(pv)\nPERL_CALLCONV void\tPerl_lex_stuff_pvn(pTHX_ const char* pv, STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_LEX_STUFF_PVN\t\\\n\tassert(pv)\nPERL_CALLCONV void\tPerl_lex_stuff_sv(pTHX_ SV* sv, U32 flags);\n#define PERL_ARGS_ASSERT_LEX_STUFF_SV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_lex_unstuff(pTHX_ char* ptr);\n#define PERL_ARGS_ASSERT_LEX_UNSTUFF\t\\\n\tassert(ptr)\nPERL_CALLCONV OP*\tPerl_list(pTHX_ OP* o);\nPERL_CALLCONV void\tPerl_load_module(pTHX_ U32 flags, SV* name, SV* ver, ...);\n#define PERL_ARGS_ASSERT_LOAD_MODULE\t\\\n\tassert(name)\nPERL_CALLCONV OP*\tPerl_localize(pTHX_ OP *o, I32 lex);\n#define PERL_ARGS_ASSERT_LOCALIZE\t\\\n\tassert(o)\nPERL_CALLCONV I32\tPerl_looks_like_number(pTHX_ SV *const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_LOOKS_LIKE_NUMBER\t\\\n\tassert(sv)\n\nPERL_CALLCONV int\tPerl_magic_clear_all_env(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEAR_ALL_ENV\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_cleararylen_p(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEARARYLEN_P\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_clearenv(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEARENV\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_clearhint(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEARHINT\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_clearhints(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEARHINTS\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_clearisa(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEARISA\t\\\n\tassert(mg)\nPERL_CALLCONV int\tPerl_magic_clearpack(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEARPACK\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_clearsig(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEARSIG\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_copycallchecker(pTHX_ SV* sv, MAGIC *mg, SV *nsv, const char *name, I32 namlen);\n#define PERL_ARGS_ASSERT_MAGIC_COPYCALLCHECKER\t\\\n\tassert(sv); assert(mg); assert(nsv)\nPERL_CALLCONV void\tPerl_magic_dump(pTHX_ const MAGIC *mg);\nPERL_CALLCONV int\tPerl_magic_existspack(pTHX_ SV* sv, const MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_EXISTSPACK\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_freearylen_p(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_FREEARYLEN_P\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_freeovrld(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_FREEOVRLD\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_get(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GET\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getarylen(pTHX_ SV* sv, const MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETARYLEN\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getdebugvar(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETDEBUGVAR\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getdefelem(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETDEFELEM\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getnkeys(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETNKEYS\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getpack(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETPACK\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getpos(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETPOS\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getsig(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETSIG\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getsubstr(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETSUBSTR\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_gettaint(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETTAINT\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getuvar(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETUVAR\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getvec(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETVEC\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_killbackrefs(pTHX_ SV *sv, MAGIC *mg);\n#define PERL_ARGS_ASSERT_MAGIC_KILLBACKREFS\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV SV*\tPerl_magic_methcall(pTHX_ SV *sv, const MAGIC *mg, SV *meth, U32 flags, U32 argc, ...);\n#define PERL_ARGS_ASSERT_MAGIC_METHCALL\t\\\n\tassert(sv); assert(mg); assert(meth)\nPERL_CALLCONV int\tPerl_magic_nextpack(pTHX_ SV *sv, MAGIC *mg, SV *key);\n#define PERL_ARGS_ASSERT_MAGIC_NEXTPACK\t\\\n\tassert(sv); assert(mg); assert(key)\nPERL_CALLCONV U32\tPerl_magic_regdata_cnt(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_REGDATA_CNT\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_regdatum_get(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_REGDATUM_GET\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV SV*\tPerl_magic_scalarpack(pTHX_ HV *hv, MAGIC *mg);\n#define PERL_ARGS_ASSERT_MAGIC_SCALARPACK\t\\\n\tassert(hv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_set(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SET\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_set_all_env(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SET_ALL_ENV\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setarylen(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETARYLEN\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setdbline(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETDBLINE\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setdebugvar(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETDEBUGVAR\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setdefelem(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETDEFELEM\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setenv(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETENV\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_sethint(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETHINT\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setisa(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETISA\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setlvref(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETLVREF\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setmglob(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETMGLOB\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setnkeys(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETNKEYS\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setnonelem(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETNONELEM\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setpack(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETPACK\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setpos(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETPOS\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setregexp(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETREGEXP\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setsig(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETSIG\t\\\n\tassert(mg)\nPERL_CALLCONV int\tPerl_magic_setsubstr(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETSUBSTR\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_settaint(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETTAINT\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setutf8(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETUTF8\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setuvar(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETUVAR\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setvec(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETVEC\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV U32\tPerl_magic_sizepack(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SIZEPACK\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_wipepack(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_WIPEPACK\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV Malloc_t\tPerl_malloc(MEM_SIZE nbytes)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV I32 *\tPerl_markstack_grow(pTHX);\nPERL_CALLCONV SV*\tPerl_mess(pTHX_ const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_1,pTHX_2);\n#define PERL_ARGS_ASSERT_MESS\t\\\n\tassert(pat)\n\nPERL_CALLCONV SV*\tPerl_mess_sv(pTHX_ SV* basemsg, bool consume);\n#define PERL_ARGS_ASSERT_MESS_SV\t\\\n\tassert(basemsg)\nPERL_CALLCONV Free_t\tPerl_mfree(Malloc_t where);\nPERL_CALLCONV int\tPerl_mg_clear(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_MG_CLEAR\t\\\n\tassert(sv)\nPERL_CALLCONV int\tPerl_mg_copy(pTHX_ SV *sv, SV *nsv, const char *key, I32 klen);\n#define PERL_ARGS_ASSERT_MG_COPY\t\\\n\tassert(sv); assert(nsv)\nPERL_CALLCONV MAGIC*\tPerl_mg_find(const SV* sv, int type)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV MAGIC*\tPerl_mg_find_mglob(pTHX_ SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MG_FIND_MGLOB\t\\\n\tassert(sv)\n\nPERL_CALLCONV MAGIC*\tPerl_mg_findext(const SV* sv, int type, const MGVTBL *vtbl)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV int\tPerl_mg_free(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_MG_FREE\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_mg_free_type(pTHX_ SV* sv, int how);\n#define PERL_ARGS_ASSERT_MG_FREE_TYPE\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_mg_freeext(pTHX_ SV* sv, int how, const MGVTBL *vtbl);\n#define PERL_ARGS_ASSERT_MG_FREEEXT\t\\\n\tassert(sv)\nPERL_CALLCONV int\tPerl_mg_get(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_MG_GET\t\\\n\tassert(sv)\nPERL_CALLCONV U32\tPerl_mg_length(pTHX_ SV* sv)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_MG_LENGTH\t\\\n\tassert(sv)\n\nPERL_CALLCONV void\tPerl_mg_localize(pTHX_ SV* sv, SV* nsv, bool setmagic);\n#define PERL_ARGS_ASSERT_MG_LOCALIZE\t\\\n\tassert(sv); assert(nsv)\nPERL_CALLCONV void\tPerl_mg_magical(SV* sv);\n#define PERL_ARGS_ASSERT_MG_MAGICAL\t\\\n\tassert(sv)\nPERL_CALLCONV int\tPerl_mg_set(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_MG_SET\t\\\n\tassert(sv)\nPERL_CALLCONV I32\tPerl_mg_size(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_MG_SIZE\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_mini_mktime(struct tm *ptm);\n#define PERL_ARGS_ASSERT_MINI_MKTIME\t\\\n\tassert(ptm)\nPERL_CALLCONV int\tPerl_mode_from_discipline(pTHX_ const char* s, STRLEN len);\nPERL_CALLCONV void *\tPerl_more_bodies(pTHX_ const svtype sv_type, const size_t body_size, const size_t arena_size);\nPERL_CALLCONV const char*\tPerl_moreswitches(pTHX_ const char* s);\n#define PERL_ARGS_ASSERT_MORESWITCHES\t\\\n\tassert(s)\nPERL_CALLCONV const struct mro_alg *\tPerl_mro_get_from_name(pTHX_ SV *name);\n#define PERL_ARGS_ASSERT_MRO_GET_FROM_NAME\t\\\n\tassert(name)\nPERL_CALLCONV AV*\tPerl_mro_get_linear_isa(pTHX_ HV* stash);\n#define PERL_ARGS_ASSERT_MRO_GET_LINEAR_ISA\t\\\n\tassert(stash)\nPERL_CALLCONV SV*\tPerl_mro_get_private_data(pTHX_ struct mro_meta *const smeta, const struct mro_alg *const which);\n#define PERL_ARGS_ASSERT_MRO_GET_PRIVATE_DATA\t\\\n\tassert(smeta); assert(which)\nPERL_CALLCONV void\tPerl_mro_isa_changed_in(pTHX_ HV* stash);\n#define PERL_ARGS_ASSERT_MRO_ISA_CHANGED_IN\t\\\n\tassert(stash)\nPERL_CALLCONV struct mro_meta*\tPerl_mro_meta_init(pTHX_ HV* stash);\n#define PERL_ARGS_ASSERT_MRO_META_INIT\t\\\n\tassert(stash)\nPERL_CALLCONV void\tPerl_mro_method_changed_in(pTHX_ HV* stash);\n#define PERL_ARGS_ASSERT_MRO_METHOD_CHANGED_IN\t\\\n\tassert(stash)\nPERL_CALLCONV void\tPerl_mro_package_moved(pTHX_ HV * const stash, HV * const oldstash, const GV * const gv, U32 flags);\n#define PERL_ARGS_ASSERT_MRO_PACKAGE_MOVED\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_mro_register(pTHX_ const struct mro_alg *mro);\n#define PERL_ARGS_ASSERT_MRO_REGISTER\t\\\n\tassert(mro)\nPERL_CALLCONV void\tPerl_mro_set_mro(pTHX_ struct mro_meta *const meta, SV *const name);\n#define PERL_ARGS_ASSERT_MRO_SET_MRO\t\\\n\tassert(meta); assert(name)\nPERL_CALLCONV SV*\tPerl_mro_set_private_data(pTHX_ struct mro_meta *const smeta, const struct mro_alg *const which, SV *const data);\n#define PERL_ARGS_ASSERT_MRO_SET_PRIVATE_DATA\t\\\n\tassert(smeta); assert(which); assert(data)\nPERL_CALLCONV SV*\tPerl_multiconcat_stringify(pTHX_ const OP* o);\n#define PERL_ARGS_ASSERT_MULTICONCAT_STRINGIFY\t\\\n\tassert(o)\nPERL_CALLCONV SV*\tPerl_multideref_stringify(pTHX_ const OP* o, CV *cv);\n#define PERL_ARGS_ASSERT_MULTIDEREF_STRINGIFY\t\\\n\tassert(o)\nPERL_CALLCONV NV\tPerl_my_atof(pTHX_ const char *s);\n#define PERL_ARGS_ASSERT_MY_ATOF\t\\\n\tassert(s)\nPERL_CALLCONV char*\tPerl_my_atof2(pTHX_ const char *orig, NV* value);\n#define PERL_ARGS_ASSERT_MY_ATOF2\t\\\n\tassert(orig); assert(value)\nPERL_CALLCONV char*\tPerl_my_atof3(pTHX_ const char *orig, NV* value, const STRLEN len);\n#define PERL_ARGS_ASSERT_MY_ATOF3\t\\\n\tassert(orig); assert(value)\nPERL_CALLCONV OP *\tPerl_my_attrs(pTHX_ OP *o, OP *attrs);\n#define PERL_ARGS_ASSERT_MY_ATTRS\t\\\n\tassert(o)\nPERL_CALLCONV void\tPerl_my_clearenv(pTHX);\nPERL_CALLCONV int\tPerl_my_dirfd(DIR* dir);\nPERL_CALLCONV_NO_RET void\tPerl_my_exit(pTHX_ U32 status)\n\t\t\t__attribute__noreturn__;\n\nPERL_CALLCONV_NO_RET void\tPerl_my_failure_exit(pTHX)\n\t\t\t__attribute__noreturn__;\n\nPERL_CALLCONV I32\tPerl_my_fflush_all(pTHX);\nPERL_CALLCONV Pid_t\tPerl_my_fork(void);\n#ifndef NO_MATHOMS\nPERL_CALLCONV I32\tPerl_my_lstat(pTHX);\n#endif\nPERL_CALLCONV I32\tPerl_my_lstat_flags(pTHX_ const U32 flags);\nPERL_CALLCONV int\tPerl_my_mkstemp_cloexec(char *templte)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MY_MKSTEMP_CLOEXEC\t\\\n\tassert(templte)\n\nPERL_CALLCONV PerlIO*\tPerl_my_popen_list(pTHX_ const char* mode, int n, SV ** args);\n#define PERL_ARGS_ASSERT_MY_POPEN_LIST\t\\\n\tassert(mode); assert(args)\nPERL_CALLCONV void\tPerl_my_setenv(pTHX_ const char* nam, const char* val);\nPERL_CALLCONV int\tPerl_my_snprintf(char *buffer, const Size_t len, const char *format, ...)\n\t\t\t__attribute__format__(__printf__,3,4);\n#define PERL_ARGS_ASSERT_MY_SNPRINTF\t\\\n\tassert(buffer); assert(format)\n\nPERL_CALLCONV int\tPerl_my_socketpair(int family, int type, int protocol, int fd[2]);\n#ifndef NO_MATHOMS\nPERL_CALLCONV I32\tPerl_my_stat(pTHX);\n#endif\nPERL_CALLCONV I32\tPerl_my_stat_flags(pTHX_ const U32 flags);\nPERL_CALLCONV char*\tPerl_my_strerror(pTHX_ const int errnum);\nPERL_CALLCONV char *\tPerl_my_strftime(pTHX_ const char *fmt, int sec, int min, int hour, int mday, int mon, int year, int wday, int yday, int isdst)\n\t\t\t__attribute__format__(__strftime__,pTHX_1,0);\n#define PERL_ARGS_ASSERT_MY_STRFTIME\t\\\n\tassert(fmt)\n\nPERL_CALLCONV NV\tPerl_my_strtod(const char * const s, char ** e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MY_STRTOD\t\\\n\tassert(s)\n\nPERL_CALLCONV void\tPerl_my_unexec(pTHX);\nPERL_CALLCONV int\tPerl_my_vsnprintf(char *buffer, const Size_t len, const char *format, va_list ap);\n#define PERL_ARGS_ASSERT_MY_VSNPRINTF\t\\\n\tassert(buffer); assert(format)\nPERL_CALLCONV OP*\tPerl_newANONATTRSUB(pTHX_ I32 floor, OP *proto, OP *attrs, OP *block);\nPERL_CALLCONV OP*\tPerl_newANONHASH(pTHX_ OP* o)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newANONLIST(pTHX_ OP* o)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newANONSUB(pTHX_ I32 floor, OP* proto, OP* block);\nPERL_CALLCONV OP*\tPerl_newASSIGNOP(pTHX_ I32 flags, OP* left, I32 optype, OP* right)\n\t\t\t__attribute__warn_unused_result__;\n\n/* PERL_CALLCONV CV*\tnewATTRSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block); */\nPERL_CALLCONV CV*\tPerl_newATTRSUB_x(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block, bool o_is_gv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV AV*\tPerl_newAV(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV OP*\tPerl_newAVREF(pTHX_ OP* o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWAVREF\t\\\n\tassert(o)\n\nPERL_CALLCONV OP*\tPerl_newBINOP(pTHX_ I32 type, I32 flags, OP* first, OP* last)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newCONDOP(pTHX_ I32 flags, OP* first, OP* trueop, OP* falseop)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWCONDOP\t\\\n\tassert(first)\n\nPERL_CALLCONV CV*\tPerl_newCONSTSUB(pTHX_ HV* stash, const char* name, SV* sv);\nPERL_CALLCONV CV*\tPerl_newCONSTSUB_flags(pTHX_ HV* stash, const char* name, STRLEN len, U32 flags, SV* sv);\nPERL_CALLCONV OP*\tPerl_newCVREF(pTHX_ I32 flags, OP* o)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newDEFSVOP(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_newFORM(pTHX_ I32 floor, OP* o, OP* block);\nPERL_CALLCONV OP*\tPerl_newFOROP(pTHX_ I32 flags, OP* sv, OP* expr, OP* block, OP* cont)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWFOROP\t\\\n\tassert(expr)\n\nPERL_CALLCONV OP*\tPerl_newGIVENOP(pTHX_ OP* cond, OP* block, PADOFFSET defsv_off)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWGIVENOP\t\\\n\tassert(cond); assert(block)\n\nPERL_CALLCONV GP *\tPerl_newGP(pTHX_ GV *const gv);\n#define PERL_ARGS_ASSERT_NEWGP\t\\\n\tassert(gv)\nPERL_CALLCONV OP*\tPerl_newGVOP(pTHX_ I32 type, I32 flags, GV* gv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWGVOP\t\\\n\tassert(gv)\n\nPERL_CALLCONV OP*\tPerl_newGVREF(pTHX_ I32 type, OP* o)\n\t\t\t__attribute__warn_unused_result__;\n\n/* PERL_CALLCONV GV*\tnewGVgen(pTHX_ const char* pack); */\nPERL_CALLCONV GV*\tPerl_newGVgen_flags(pTHX_ const char* pack, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWGVGEN_FLAGS\t\\\n\tassert(pack)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV HV*\tPerl_newHV(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV OP*\tPerl_newHVREF(pTHX_ OP* o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWHVREF\t\\\n\tassert(o)\n\nPERL_CALLCONV HV*\tPerl_newHVhv(pTHX_ HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV IO*\tPerl_newIO(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV OP*\tPerl_newLISTOP(pTHX_ I32 type, I32 flags, OP* first, OP* last)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newLOGOP(pTHX_ I32 optype, I32 flags, OP *first, OP *other)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWLOGOP\t\\\n\tassert(first); assert(other)\n\nPERL_CALLCONV OP*\tPerl_newLOOPEX(pTHX_ I32 type, OP* label)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWLOOPEX\t\\\n\tassert(label)\n\nPERL_CALLCONV OP*\tPerl_newLOOPOP(pTHX_ I32 flags, I32 debuggable, OP* expr, OP* block)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newMETHOP(pTHX_ I32 type, I32 flags, OP* dynamic_meth)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWMETHOP\t\\\n\tassert(dynamic_meth)\n\nPERL_CALLCONV OP*\tPerl_newMETHOP_named(pTHX_ I32 type, I32 flags, SV* const_meth)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWMETHOP_NAMED\t\\\n\tassert(const_meth)\n\nPERL_CALLCONV CV *\tPerl_newMYSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block);\n#define PERL_ARGS_ASSERT_NEWMYSUB\t\\\n\tassert(o)\nPERL_CALLCONV OP*\tPerl_newNULLLIST(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newOP(pTHX_ I32 optype, I32 flags)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV PADNAMELIST *\tPerl_newPADNAMELIST(size_t max)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV PADNAME *\tPerl_newPADNAMEouter(PADNAME *outer)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWPADNAMEOUTER\t\\\n\tassert(outer)\n\nPERL_CALLCONV PADNAME *\tPerl_newPADNAMEpvn(const char *s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWPADNAMEPVN\t\\\n\tassert(s)\n\nPERL_CALLCONV OP*\tPerl_newPMOP(pTHX_ I32 type, I32 flags)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_newPROG(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_NEWPROG\t\\\n\tassert(o)\nPERL_CALLCONV OP*\tPerl_newPVOP(pTHX_ I32 type, I32 flags, char* pv)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newRANGE(pTHX_ I32 flags, OP* left, OP* right)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWRANGE\t\\\n\tassert(left); assert(right)\n\nPERL_CALLCONV SV*\tPerl_newRV(pTHX_ SV *const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWRV\t\\\n\tassert(sv)\n\nPERL_CALLCONV SV*\tPerl_newRV_noinc(pTHX_ SV *const tmpRef)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWRV_NOINC\t\\\n\tassert(tmpRef)\n\nPERL_CALLCONV OP*\tPerl_newSLICEOP(pTHX_ I32 flags, OP* subscript, OP* listop)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newSTATEOP(pTHX_ I32 flags, char* label, OP* o)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV CV*\tPerl_newSTUB(pTHX_ GV *gv, bool fake);\n#define PERL_ARGS_ASSERT_NEWSTUB\t\\\n\tassert(gv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV CV*\tPerl_newSUB(pTHX_ I32 floor, OP* o, OP* proto, OP* block);\n#endif\nPERL_CALLCONV SV*\tPerl_newSV(pTHX_ const STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newSVOP(pTHX_ I32 type, I32 flags, SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWSVOP\t\\\n\tassert(sv)\n\nPERL_CALLCONV OP*\tPerl_newSVREF(pTHX_ OP* o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWSVREF\t\\\n\tassert(o)\n\nPERL_CALLCONV SV*\tPerl_newSV_type(pTHX_ const svtype type)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVavdefelem(pTHX_ AV *av, SSize_t ix, bool extendible)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWSVAVDEFELEM\t\\\n\tassert(av)\n\nPERL_CALLCONV SV*\tPerl_newSVhek(pTHX_ const HEK *const hek)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSViv(pTHX_ const IV i)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVnv(pTHX_ const NV n)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVpv(pTHX_ const char *const s, const STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVpv_share(pTHX_ const char* s, U32 hash)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVpvf(pTHX_ const char *const pat, ...)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__format__(__printf__,pTHX_1,pTHX_2);\n#define PERL_ARGS_ASSERT_NEWSVPVF\t\\\n\tassert(pat)\n\nPERL_CALLCONV SV*\tPerl_newSVpvn(pTHX_ const char *const buffer, const STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVpvn_flags(pTHX_ const char *const s, const STRLEN len, const U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVpvn_share(pTHX_ const char* s, I32 len, U32 hash)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVrv(pTHX_ SV *const rv, const char *const classname);\n#define PERL_ARGS_ASSERT_NEWSVRV\t\\\n\tassert(rv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV SV*\tPerl_newSVsv(pTHX_ SV *const old)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV SV*\tPerl_newSVsv_flags(pTHX_ SV *const old, I32 flags)\n\t\t\t__attribute__warn_unused_result__;\n\n/* PERL_CALLCONV SV*\tPerl_newSVsv_nomg(pTHX_ SV *const old)\n\t\t\t__attribute__warn_unused_result__; */\n\nPERL_CALLCONV SV*\tPerl_newSVuv(pTHX_ const UV u)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newUNOP(pTHX_ I32 type, I32 flags, OP* first)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newUNOP_AUX(pTHX_ I32 type, I32 flags, OP* first, UNOP_AUX_item *aux)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newWHENOP(pTHX_ OP* cond, OP* block)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWWHENOP\t\\\n\tassert(block)\n\nPERL_CALLCONV OP*\tPerl_newWHILEOP(pTHX_ I32 flags, I32 debuggable, LOOP* loop, OP* expr, OP* block, OP* cont, I32 has_my)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV CV*\tPerl_newXS(pTHX_ const char *name, XSUBADDR_t subaddr, const char *filename);\n#define PERL_ARGS_ASSERT_NEWXS\t\\\n\tassert(subaddr); assert(filename)\nPERL_CALLCONV CV *\tPerl_newXS_deffile(pTHX_ const char *name, XSUBADDR_t subaddr);\n#define PERL_ARGS_ASSERT_NEWXS_DEFFILE\t\\\n\tassert(name); assert(subaddr)\nPERL_CALLCONV CV *\tPerl_newXS_flags(pTHX_ const char *name, XSUBADDR_t subaddr, const char *const filename, const char *const proto, U32 flags);\n#define PERL_ARGS_ASSERT_NEWXS_FLAGS\t\\\n\tassert(subaddr); assert(filename)\nPERL_CALLCONV CV *\tPerl_newXS_len_flags(pTHX_ const char *name, STRLEN len, XSUBADDR_t subaddr, const char *const filename, const char *const proto, SV **const_svp, U32 flags);\n#define PERL_ARGS_ASSERT_NEWXS_LEN_FLAGS\t\\\n\tassert(subaddr)\nPERL_CALLCONV PERL_SI*\tPerl_new_stackinfo(pTHX_ I32 stitems, I32 cxitems)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_new_version(pTHX_ SV *ver);\n#define PERL_ARGS_ASSERT_NEW_VERSION\t\\\n\tassert(ver)\nPERL_CALLCONV STRLEN *\tPerl_new_warnings_bitfield(pTHX_ STRLEN *buffer, const char *const bits, STRLEN size)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEW_WARNINGS_BITFIELD\t\\\n\tassert(bits)\n\nPERL_CALLCONV PerlIO*\tPerl_nextargv(pTHX_ GV* gv, bool nomagicopen);\n#define PERL_ARGS_ASSERT_NEXTARGV\t\\\n\tassert(gv)\nPERL_CALLCONV_NO_RET void\tPerl_noperl_die(const char* pat, ...)\n\t\t\t__attribute__noreturn__\n\t\t\t__attribute__format__(__printf__,1,2);\n#define PERL_ARGS_ASSERT_NOPERL_DIE\t\\\n\tassert(pat)\n\nPERL_CALLCONV int\tPerl_nothreadhook(pTHX);\nPERL_CALLCONV void\tPerl_notify_parser_that_changed_to_utf8(pTHX);\nPERL_CALLCONV OP*\tPerl_oopsAV(pTHX_ OP* o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_OOPSAV\t\\\n\tassert(o)\n\nPERL_CALLCONV OP*\tPerl_oopsHV(pTHX_ OP* o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_OOPSHV\t\\\n\tassert(o)\n\nPERL_CALLCONV OP*\tPerl_op_append_elem(pTHX_ I32 optype, OP* first, OP* last);\nPERL_CALLCONV OP*\tPerl_op_append_list(pTHX_ I32 optype, OP* first, OP* last);\nPERL_CALLCONV OPclass\tPerl_op_class(pTHX_ const OP *o);\nPERL_CALLCONV void\tPerl_op_clear(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_OP_CLEAR\t\\\n\tassert(o)\nPERL_CALLCONV OP*\tPerl_op_contextualize(pTHX_ OP* o, I32 context);\n#define PERL_ARGS_ASSERT_OP_CONTEXTUALIZE\t\\\n\tassert(o)\nPERL_CALLCONV OP*\tPerl_op_convert_list(pTHX_ I32 optype, I32 flags, OP* o)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_op_dump(pTHX_ const OP *o);\n#define PERL_ARGS_ASSERT_OP_DUMP\t\\\n\tassert(o)\nPERL_CALLCONV void\tPerl_op_free(pTHX_ OP* arg);\nPERL_CALLCONV OP*\tPerl_op_linklist(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_OP_LINKLIST\t\\\n\tassert(o)\n/* PERL_CALLCONV OP*\top_lvalue(pTHX_ OP* o, I32 type); */\nPERL_CALLCONV OP*\tPerl_op_lvalue_flags(pTHX_ OP* o, I32 type, U32 flags);\nPERL_CALLCONV void\tPerl_op_null(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_OP_NULL\t\\\n\tassert(o)\nPERL_CALLCONV OP*\tPerl_op_parent(OP *o);\n#define PERL_ARGS_ASSERT_OP_PARENT\t\\\n\tassert(o)\nPERL_CALLCONV OP*\tPerl_op_prepend_elem(pTHX_ I32 optype, OP* first, OP* last);\nPERL_CALLCONV void\tPerl_op_refcnt_lock(pTHX);\nPERL_CALLCONV void\tPerl_op_refcnt_unlock(pTHX);\nPERL_CALLCONV OP*\tPerl_op_scope(pTHX_ OP* o);\nPERL_CALLCONV OP*\tPerl_op_sibling_splice(OP *parent, OP *start, int del_count, OP* insert);\nPERL_CALLCONV OP*\tPerl_op_unscope(pTHX_ OP* o);\nPERL_CALLCONV void\tPerl_optimize_optree(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_OPTIMIZE_OPTREE\t\\\n\tassert(o)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_pack_cat(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist, SV ***next_in_list, U32 flags);\n#define PERL_ARGS_ASSERT_PACK_CAT\t\\\n\tassert(cat); assert(pat); assert(patend); assert(beglist); assert(endlist); assert(next_in_list)\n#endif\nPERL_CALLCONV void\tPerl_package(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_PACKAGE\t\\\n\tassert(o)\nPERL_CALLCONV void\tPerl_package_version(pTHX_ OP* v);\n#define PERL_ARGS_ASSERT_PACKAGE_VERSION\t\\\n\tassert(v)\nPERL_CALLCONV void\tPerl_packlist(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist);\n#define PERL_ARGS_ASSERT_PACKLIST\t\\\n\tassert(cat); assert(pat); assert(patend); assert(beglist); assert(endlist)\nPERL_CALLCONV PADOFFSET\tPerl_pad_add_anon(pTHX_ CV* func, I32 optype);\n#define PERL_ARGS_ASSERT_PAD_ADD_ANON\t\\\n\tassert(func)\nPERL_CALLCONV PADOFFSET\tPerl_pad_add_name_pv(pTHX_ const char *name, const U32 flags, HV *typestash, HV *ourstash);\n#define PERL_ARGS_ASSERT_PAD_ADD_NAME_PV\t\\\n\tassert(name)\nPERL_CALLCONV PADOFFSET\tPerl_pad_add_name_pvn(pTHX_ const char *namepv, STRLEN namelen, U32 flags, HV *typestash, HV *ourstash);\n#define PERL_ARGS_ASSERT_PAD_ADD_NAME_PVN\t\\\n\tassert(namepv)\nPERL_CALLCONV PADOFFSET\tPerl_pad_add_name_sv(pTHX_ SV *name, U32 flags, HV *typestash, HV *ourstash);\n#define PERL_ARGS_ASSERT_PAD_ADD_NAME_SV\t\\\n\tassert(name)\nPERL_CALLCONV void\tPerl_pad_add_weakref(pTHX_ CV* func);\n#define PERL_ARGS_ASSERT_PAD_ADD_WEAKREF\t\\\n\tassert(func)\nPERL_CALLCONV PADOFFSET\tPerl_pad_alloc(pTHX_ I32 optype, U32 tmptype);\nPERL_CALLCONV void\tPerl_pad_block_start(pTHX_ int full);\n#ifndef NO_MATHOMS\nPERL_CALLCONV HV*\tPerl_pad_compname_type(pTHX_ const PADOFFSET po)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV PADOFFSET\tPerl_pad_findmy_pv(pTHX_ const char* name, U32 flags);\n#define PERL_ARGS_ASSERT_PAD_FINDMY_PV\t\\\n\tassert(name)\nPERL_CALLCONV PADOFFSET\tPerl_pad_findmy_pvn(pTHX_ const char* namepv, STRLEN namelen, U32 flags);\n#define PERL_ARGS_ASSERT_PAD_FINDMY_PVN\t\\\n\tassert(namepv)\nPERL_CALLCONV PADOFFSET\tPerl_pad_findmy_sv(pTHX_ SV* name, U32 flags);\n#define PERL_ARGS_ASSERT_PAD_FINDMY_SV\t\\\n\tassert(name)\nPERL_CALLCONV void\tPerl_pad_fixup_inner_anons(pTHX_ PADLIST *padlist, CV *old_cv, CV *new_cv);\n#define PERL_ARGS_ASSERT_PAD_FIXUP_INNER_ANONS\t\\\n\tassert(padlist); assert(old_cv); assert(new_cv)\nPERL_CALLCONV void\tPerl_pad_free(pTHX_ PADOFFSET po);\nPERL_CALLCONV OP *\tPerl_pad_leavemy(pTHX);\nPERL_CALLCONV PADLIST*\tPerl_pad_new(pTHX_ int flags)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_pad_push(pTHX_ PADLIST *padlist, int depth);\n#define PERL_ARGS_ASSERT_PAD_PUSH\t\\\n\tassert(padlist)\nPERL_CALLCONV void\tPerl_pad_swipe(pTHX_ PADOFFSET po, bool refadjust);\nPERL_CALLCONV void\tPerl_pad_tidy(pTHX_ padtidy_type type);\nPERL_CALLCONV PAD **\tPerl_padlist_store(pTHX_ PADLIST *padlist, I32 key, PAD *val);\n#define PERL_ARGS_ASSERT_PADLIST_STORE\t\\\n\tassert(padlist)\nPERL_CALLCONV void\tPerl_padname_free(pTHX_ PADNAME *pn);\n#define PERL_ARGS_ASSERT_PADNAME_FREE\t\\\n\tassert(pn)\nPERL_CALLCONV PADNAME *\tPerl_padnamelist_fetch(PADNAMELIST *pnl, SSize_t key)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PADNAMELIST_FETCH\t\\\n\tassert(pnl)\n\nPERL_CALLCONV void\tPerl_padnamelist_free(pTHX_ PADNAMELIST *pnl);\n#define PERL_ARGS_ASSERT_PADNAMELIST_FREE\t\\\n\tassert(pnl)\nPERL_CALLCONV PADNAME **\tPerl_padnamelist_store(pTHX_ PADNAMELIST *pnl, SSize_t key, PADNAME *val);\n#define PERL_ARGS_ASSERT_PADNAMELIST_STORE\t\\\n\tassert(pnl)\nPERL_CALLCONV OP*\tPerl_parse_arithexpr(pTHX_ U32 flags);\nPERL_CALLCONV OP*\tPerl_parse_barestmt(pTHX_ U32 flags);\nPERL_CALLCONV OP*\tPerl_parse_block(pTHX_ U32 flags);\nPERL_CALLCONV OP*\tPerl_parse_fullexpr(pTHX_ U32 flags);\nPERL_CALLCONV OP*\tPerl_parse_fullstmt(pTHX_ U32 flags);\nPERL_CALLCONV SV*\tPerl_parse_label(pTHX_ U32 flags);\nPERL_CALLCONV OP*\tPerl_parse_listexpr(pTHX_ U32 flags);\nPERL_CALLCONV OP*\tPerl_parse_stmtseq(pTHX_ U32 flags);\nPERL_CALLCONV OP*\tPerl_parse_termexpr(pTHX_ U32 flags);\nPERL_CALLCONV U32\tPerl_parse_unicode_opts(pTHX_ const char **popt);\n#define PERL_ARGS_ASSERT_PARSE_UNICODE_OPTS\t\\\n\tassert(popt)\nPERL_CALLCONV void\tPerl_parser_free(pTHX_ const yy_parser *parser);\n#define PERL_ARGS_ASSERT_PARSER_FREE\t\\\n\tassert(parser)\nPERL_CALLCONV void\tPerl_peep(pTHX_ OP* o);\nPERL_CALLCONV PerlInterpreter*\tperl_alloc(void);\nPERL_CALLCONV void\tperl_construct(PerlInterpreter *my_perl);\n#define PERL_ARGS_ASSERT_PERL_CONSTRUCT\t\\\n\tassert(my_perl)\nPERL_CALLCONV int\tperl_destruct(PerlInterpreter *my_perl);\n#define PERL_ARGS_ASSERT_PERL_DESTRUCT\t\\\n\tassert(my_perl)\nPERL_CALLCONV void\tperl_free(PerlInterpreter *my_perl);\n#define PERL_ARGS_ASSERT_PERL_FREE\t\\\n\tassert(my_perl)\nPERL_CALLCONV int\tperl_parse(PerlInterpreter *my_perl, XSINIT_t xsinit, int argc, char** argv, char** env);\n#define PERL_ARGS_ASSERT_PERL_PARSE\t\\\n\tassert(my_perl)\nPERL_CALLCONV int\tperl_run(PerlInterpreter *my_perl);\n#define PERL_ARGS_ASSERT_PERL_RUN\t\\\n\tassert(my_perl)\nPERL_CALLCONV void\tPerl_pmop_dump(pTHX_ PMOP* pm);\nPERL_CALLCONV OP*\tPerl_pmruntime(pTHX_ OP *o, OP *expr, OP *repl, UV flags, I32 floor);\n#define PERL_ARGS_ASSERT_PMRUNTIME\t\\\n\tassert(o); assert(expr)\nPERL_CALLCONV void\tPerl_pop_scope(pTHX);\nPERL_CALLCONV void\tPerl_populate_isa(pTHX_ const char *name, STRLEN len, ...);\n#define PERL_ARGS_ASSERT_POPULATE_ISA\t\\\n\tassert(name)\nPERL_CALLCONV REGEXP*\tPerl_pregcomp(pTHX_ SV * const pattern, const U32 flags);\n#define PERL_ARGS_ASSERT_PREGCOMP\t\\\n\tassert(pattern)\nPERL_CALLCONV I32\tPerl_pregexec(pTHX_ REGEXP * const prog, char* stringarg, char* strend, char* strbeg, SSize_t minend, SV* screamer, U32 nosave);\n#define PERL_ARGS_ASSERT_PREGEXEC\t\\\n\tassert(prog); assert(stringarg); assert(strend); assert(strbeg); assert(screamer)\nPERL_CALLCONV void\tPerl_pregfree(pTHX_ REGEXP* r);\nPERL_CALLCONV void\tPerl_pregfree2(pTHX_ REGEXP *rx);\n#define PERL_ARGS_ASSERT_PREGFREE2\t\\\n\tassert(rx)\nPERL_CALLCONV const char*\tPerl_prescan_version(pTHX_ const char *s, bool strict, const char** errstr, bool *sqv, int *ssaw_decimal, int *swidth, bool *salpha);\n#define PERL_ARGS_ASSERT_PRESCAN_VERSION\t\\\n\tassert(s)\nPERL_CALLCONV void\tPerl_ptr_table_clear(pTHX_ PTR_TBL_t *const tbl)\n\t\t\t__attribute__deprecated__;\n\nPERL_CALLCONV void*\tPerl_ptr_table_fetch(pTHX_ PTR_TBL_t *const tbl, const void *const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PTR_TABLE_FETCH\t\\\n\tassert(tbl)\n\nPERL_CALLCONV void\tPerl_ptr_table_free(pTHX_ PTR_TBL_t *const tbl);\nPERL_CALLCONV PTR_TBL_t*\tPerl_ptr_table_new(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_ptr_table_split(pTHX_ PTR_TBL_t *const tbl);\n#define PERL_ARGS_ASSERT_PTR_TABLE_SPLIT\t\\\n\tassert(tbl)\nPERL_CALLCONV void\tPerl_ptr_table_store(pTHX_ PTR_TBL_t *const tbl, const void *const oldsv, void *const newsv);\n#define PERL_ARGS_ASSERT_PTR_TABLE_STORE\t\\\n\tassert(tbl); assert(newsv)\nPERL_CALLCONV void\tPerl_push_scope(pTHX);\nPERL_CALLCONV char*\tPerl_pv_display(pTHX_ SV *dsv, const char *pv, STRLEN cur, STRLEN len, STRLEN pvlim);\n#define PERL_ARGS_ASSERT_PV_DISPLAY\t\\\n\tassert(dsv); assert(pv)\nPERL_CALLCONV char*\tPerl_pv_escape(pTHX_ SV *dsv, char const * const str, const STRLEN count, const STRLEN max, STRLEN * const escaped, const U32 flags);\n#define PERL_ARGS_ASSERT_PV_ESCAPE\t\\\n\tassert(str)\nPERL_CALLCONV char*\tPerl_pv_pretty(pTHX_ SV *dsv, char const * const str, const STRLEN count, const STRLEN max, char const * const start_color, char const * const end_color, const U32 flags);\n#define PERL_ARGS_ASSERT_PV_PRETTY\t\\\n\tassert(dsv); assert(str)\nPERL_CALLCONV char*\tPerl_pv_uni_display(pTHX_ SV *dsv, const U8 *spv, STRLEN len, STRLEN pvlim, UV flags);\n#define PERL_ARGS_ASSERT_PV_UNI_DISPLAY\t\\\n\tassert(dsv); assert(spv)\nPERL_CALLCONV void\tPerl_qerror(pTHX_ SV* err);\n#define PERL_ARGS_ASSERT_QERROR\t\\\n\tassert(err)\nPERL_CALLCONV REGEXP*\tPerl_re_compile(pTHX_ SV * const pattern, U32 orig_rx_flags);\n#define PERL_ARGS_ASSERT_RE_COMPILE\t\\\n\tassert(pattern)\nPERL_CALLCONV char*\tPerl_re_intuit_start(pTHX_ REGEXP * const rx, SV* sv, const char* const strbeg, char* strpos, char* strend, const U32 flags, re_scream_pos_data *data);\n#define PERL_ARGS_ASSERT_RE_INTUIT_START\t\\\n\tassert(rx); assert(strbeg); assert(strpos); assert(strend)\nPERL_CALLCONV SV*\tPerl_re_intuit_string(pTHX_ REGEXP  *const r);\n#define PERL_ARGS_ASSERT_RE_INTUIT_STRING\t\\\n\tassert(r)\nPERL_CALLCONV REGEXP*\tPerl_re_op_compile(pTHX_ SV ** const patternp, int pat_count, OP *expr, const regexp_engine* eng, REGEXP *old_re, bool *is_bare_re, const U32 rx_flags, const U32 pm_flags);\n#define PERL_ARGS_ASSERT_RE_OP_COMPILE\t\\\n\tassert(eng)\nPERL_CALLCONV Malloc_t\tPerl_realloc(Malloc_t where, MEM_SIZE nbytes)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_reentrant_free(pTHX);\nPERL_CALLCONV void\tPerl_reentrant_init(pTHX);\nPERL_CALLCONV void*\tPerl_reentrant_retry(const char *f, ...);\n#define PERL_ARGS_ASSERT_REENTRANT_RETRY\t\\\n\tassert(f)\nPERL_CALLCONV void\tPerl_reentrant_size(pTHX);\n#ifndef NO_MATHOMS\nPERL_CALLCONV OP*\tPerl_ref(pTHX_ OP* o, I32 type);\n#endif\nPERL_CALLCONV HV *\tPerl_refcounted_he_chain_2hv(pTHX_ const struct refcounted_he *c, U32 flags);\nPERL_CALLCONV SV *\tPerl_refcounted_he_fetch_pv(pTHX_ const struct refcounted_he *chain, const char *key, U32 hash, U32 flags);\n#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_PV\t\\\n\tassert(key)\nPERL_CALLCONV SV *\tPerl_refcounted_he_fetch_pvn(pTHX_ const struct refcounted_he *chain, const char *keypv, STRLEN keylen, U32 hash, U32 flags);\n#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_PVN\t\\\n\tassert(keypv)\nPERL_CALLCONV SV *\tPerl_refcounted_he_fetch_sv(pTHX_ const struct refcounted_he *chain, SV *key, U32 hash, U32 flags);\n#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_SV\t\\\n\tassert(key)\nPERL_CALLCONV void\tPerl_refcounted_he_free(pTHX_ struct refcounted_he *he);\nPERL_CALLCONV struct refcounted_he *\tPerl_refcounted_he_inc(pTHX_ struct refcounted_he *he);\nPERL_CALLCONV struct refcounted_he *\tPerl_refcounted_he_new_pv(pTHX_ struct refcounted_he *parent, const char *key, U32 hash, SV *value, U32 flags);\n#define PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_PV\t\\\n\tassert(key)\nPERL_CALLCONV struct refcounted_he *\tPerl_refcounted_he_new_pvn(pTHX_ struct refcounted_he *parent, const char *keypv, STRLEN keylen, U32 hash, SV *value, U32 flags);\n#define PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_PVN\t\\\n\tassert(keypv)\nPERL_CALLCONV struct refcounted_he *\tPerl_refcounted_he_new_sv(pTHX_ struct refcounted_he *parent, SV *key, U32 hash, SV *value, U32 flags);\n#define PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_SV\t\\\n\tassert(key)\nPERL_CALLCONV SV*\tPerl_reg_named_buff(pTHX_ REGEXP * const rx, SV * const key, SV * const value, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF\t\\\n\tassert(rx)\nPERL_CALLCONV SV*\tPerl_reg_named_buff_all(pTHX_ REGEXP * const rx, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_ALL\t\\\n\tassert(rx)\nPERL_CALLCONV bool\tPerl_reg_named_buff_exists(pTHX_ REGEXP * const rx, SV * const key, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_EXISTS\t\\\n\tassert(rx); assert(key)\nPERL_CALLCONV SV*\tPerl_reg_named_buff_fetch(pTHX_ REGEXP * const rx, SV * const namesv, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_FETCH\t\\\n\tassert(rx); assert(namesv)\nPERL_CALLCONV SV*\tPerl_reg_named_buff_firstkey(pTHX_ REGEXP * const rx, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_FIRSTKEY\t\\\n\tassert(rx)\nPERL_CALLCONV SV*\tPerl_reg_named_buff_iter(pTHX_ REGEXP * const rx, const SV * const lastkey, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_ITER\t\\\n\tassert(rx)\nPERL_CALLCONV SV*\tPerl_reg_named_buff_nextkey(pTHX_ REGEXP * const rx, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_NEXTKEY\t\\\n\tassert(rx)\nPERL_CALLCONV SV*\tPerl_reg_named_buff_scalar(pTHX_ REGEXP * const rx, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_SCALAR\t\\\n\tassert(rx)\nPERL_CALLCONV void\tPerl_reg_numbered_buff_fetch(pTHX_ REGEXP * const rx, const I32 paren, SV * const sv);\n#define PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_FETCH\t\\\n\tassert(rx)\nPERL_CALLCONV I32\tPerl_reg_numbered_buff_length(pTHX_ REGEXP * const rx, const SV * const sv, const I32 paren);\n#define PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_LENGTH\t\\\n\tassert(rx); assert(sv)\nPERL_CALLCONV void\tPerl_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren, SV const * const value);\n#define PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_STORE\t\\\n\tassert(rx)\nPERL_CALLCONV SV*\tPerl_reg_qr_package(pTHX_ REGEXP * const rx);\n#define PERL_ARGS_ASSERT_REG_QR_PACKAGE\t\\\n\tassert(rx)\nPERL_CALLCONV REGEXP*\tPerl_reg_temp_copy(pTHX_ REGEXP* dsv, REGEXP* ssv);\n#define PERL_ARGS_ASSERT_REG_TEMP_COPY\t\\\n\tassert(ssv)\nPERL_CALLCONV void\tPerl_regdump(pTHX_ const regexp* r);\n#define PERL_ARGS_ASSERT_REGDUMP\t\\\n\tassert(r)\nPERL_CALLCONV I32\tPerl_regexec_flags(pTHX_ REGEXP *const rx, char *stringarg, char *strend, char *strbeg, SSize_t minend, SV *sv, void *data, U32 flags);\n#define PERL_ARGS_ASSERT_REGEXEC_FLAGS\t\\\n\tassert(rx); assert(stringarg); assert(strend); assert(strbeg); assert(sv)\nPERL_CALLCONV void\tPerl_regfree_internal(pTHX_ REGEXP *const rx);\n#define PERL_ARGS_ASSERT_REGFREE_INTERNAL\t\\\n\tassert(rx)\nPERL_CALLCONV void\tPerl_reginitcolors(pTHX);\nPERL_CALLCONV regnode*\tPerl_regnext(pTHX_ regnode* p)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_repeatcpy(char* to, const char* from, I32 len, IV count);\n#define PERL_ARGS_ASSERT_REPEATCPY\t\\\n\tassert(to); assert(from)\nPERL_CALLCONV void\tPerl_report_evil_fh(pTHX_ const GV *gv);\nPERL_CALLCONV void\tPerl_report_uninit(pTHX_ const SV *uninit_sv);\nPERL_CALLCONV void\tPerl_report_wrongway_fh(pTHX_ const GV *gv, const char have);\nPERL_CALLCONV void\tPerl_require_pv(pTHX_ const char* pv);\n#define PERL_ARGS_ASSERT_REQUIRE_PV\t\\\n\tassert(pv)\nPERL_CALLCONV char*\tPerl_rninstr(const char* big, const char* bigend, const char* little, const char* lend)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#define PERL_ARGS_ASSERT_RNINSTR\t\\\n\tassert(big); assert(bigend); assert(little); assert(lend)\n\nPERL_CALLCONV void\tPerl_rpeep(pTHX_ OP* o);\nPERL_CALLCONV Sighandler_t\tPerl_rsignal(pTHX_ int i, Sighandler_t t);\nPERL_CALLCONV int\tPerl_rsignal_restore(pTHX_ int i, Sigsave_t* t);\nPERL_CALLCONV int\tPerl_rsignal_save(pTHX_ int i, Sighandler_t t1, Sigsave_t* save);\n#define PERL_ARGS_ASSERT_RSIGNAL_SAVE\t\\\n\tassert(save)\nPERL_CALLCONV Sighandler_t\tPerl_rsignal_state(pTHX_ int i);\nPERL_CALLCONV int\tPerl_runops_debug(pTHX);\nPERL_CALLCONV int\tPerl_runops_standard(pTHX);\nPERL_CALLCONV CV*\tPerl_rv2cv_op_cv(pTHX_ OP *cvop, U32 flags);\n#define PERL_ARGS_ASSERT_RV2CV_OP_CV\t\\\n\tassert(cvop)\nPERL_CALLCONV void\tPerl_rxres_save(pTHX_ void **rsp, REGEXP *rx);\n#define PERL_ARGS_ASSERT_RXRES_SAVE\t\\\n\tassert(rsp); assert(rx)\nPERL_CALLCONV Malloc_t\tPerl_safesyscalloc(MEM_SIZE elements, MEM_SIZE size)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV Free_t\tPerl_safesysfree(Malloc_t where);\nPERL_CALLCONV Malloc_t\tPerl_safesysmalloc(MEM_SIZE nbytes)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV Malloc_t\tPerl_safesysrealloc(Malloc_t where, MEM_SIZE nbytes)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_save_I16(pTHX_ I16* intp);\n#define PERL_ARGS_ASSERT_SAVE_I16\t\\\n\tassert(intp)\nPERL_CALLCONV void\tPerl_save_I32(pTHX_ I32* intp);\n#define PERL_ARGS_ASSERT_SAVE_I32\t\\\n\tassert(intp)\nPERL_CALLCONV void\tPerl_save_I8(pTHX_ I8* bytep);\n#define PERL_ARGS_ASSERT_SAVE_I8\t\\\n\tassert(bytep)\nPERL_CALLCONV void\tPerl_save_adelete(pTHX_ AV *av, SSize_t key);\n#define PERL_ARGS_ASSERT_SAVE_ADELETE\t\\\n\tassert(av)\n/* PERL_CALLCONV void\tPerl_save_aelem(pTHX_ AV* av, SSize_t idx, SV **sptr); */\nPERL_CALLCONV void\tPerl_save_aelem_flags(pTHX_ AV* av, SSize_t idx, SV **sptr, const U32 flags);\n#define PERL_ARGS_ASSERT_SAVE_AELEM_FLAGS\t\\\n\tassert(av); assert(sptr)\nPERL_CALLCONV I32\tPerl_save_alloc(pTHX_ I32 size, I32 pad);\nPERL_CALLCONV void\tPerl_save_aptr(pTHX_ AV** aptr);\n#define PERL_ARGS_ASSERT_SAVE_APTR\t\\\n\tassert(aptr)\nPERL_CALLCONV AV*\tPerl_save_ary(pTHX_ GV* gv);\n#define PERL_ARGS_ASSERT_SAVE_ARY\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_save_bool(pTHX_ bool* boolp);\n#define PERL_ARGS_ASSERT_SAVE_BOOL\t\\\n\tassert(boolp)\nPERL_CALLCONV void\tPerl_save_clearsv(pTHX_ SV** svp);\n#define PERL_ARGS_ASSERT_SAVE_CLEARSV\t\\\n\tassert(svp)\nPERL_CALLCONV void\tPerl_save_delete(pTHX_ HV *hv, char *key, I32 klen);\n#define PERL_ARGS_ASSERT_SAVE_DELETE\t\\\n\tassert(hv); assert(key)\nPERL_CALLCONV void\tPerl_save_destructor(pTHX_ DESTRUCTORFUNC_NOCONTEXT_t f, void* p);\n#define PERL_ARGS_ASSERT_SAVE_DESTRUCTOR\t\\\n\tassert(p)\nPERL_CALLCONV void\tPerl_save_destructor_x(pTHX_ DESTRUCTORFUNC_t f, void* p);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_freeop(pTHX_ OP* o);\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_freepv(pTHX_ char* pv);\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_freesv(pTHX_ SV* sv);\n#endif\nPERL_CALLCONV void\tPerl_save_generic_pvref(pTHX_ char** str);\n#define PERL_ARGS_ASSERT_SAVE_GENERIC_PVREF\t\\\n\tassert(str)\nPERL_CALLCONV void\tPerl_save_generic_svref(pTHX_ SV** sptr);\n#define PERL_ARGS_ASSERT_SAVE_GENERIC_SVREF\t\\\n\tassert(sptr)\nPERL_CALLCONV void\tPerl_save_gp(pTHX_ GV* gv, I32 empty);\n#define PERL_ARGS_ASSERT_SAVE_GP\t\\\n\tassert(gv)\nPERL_CALLCONV HV*\tPerl_save_hash(pTHX_ GV* gv);\n#define PERL_ARGS_ASSERT_SAVE_HASH\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_save_hdelete(pTHX_ HV *hv, SV *keysv);\n#define PERL_ARGS_ASSERT_SAVE_HDELETE\t\\\n\tassert(hv); assert(keysv)\n/* PERL_CALLCONV void\tPerl_save_helem(pTHX_ HV *hv, SV *key, SV **sptr); */\nPERL_CALLCONV void\tPerl_save_helem_flags(pTHX_ HV *hv, SV *key, SV **sptr, const U32 flags);\n#define PERL_ARGS_ASSERT_SAVE_HELEM_FLAGS\t\\\n\tassert(hv); assert(key); assert(sptr)\nPERL_CALLCONV void\tPerl_save_hints(pTHX);\nPERL_CALLCONV void\tPerl_save_hptr(pTHX_ HV** hptr);\n#define PERL_ARGS_ASSERT_SAVE_HPTR\t\\\n\tassert(hptr)\nPERL_CALLCONV void\tPerl_save_int(pTHX_ int* intp);\n#define PERL_ARGS_ASSERT_SAVE_INT\t\\\n\tassert(intp)\nPERL_CALLCONV void\tPerl_save_item(pTHX_ SV* item);\n#define PERL_ARGS_ASSERT_SAVE_ITEM\t\\\n\tassert(item)\nPERL_CALLCONV void\tPerl_save_iv(pTHX_ IV *ivp);\n#define PERL_ARGS_ASSERT_SAVE_IV\t\\\n\tassert(ivp)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_list(pTHX_ SV** sarg, I32 maxsarg);\n#define PERL_ARGS_ASSERT_SAVE_LIST\t\\\n\tassert(sarg)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_long(pTHX_ long* longp);\n#define PERL_ARGS_ASSERT_SAVE_LONG\t\\\n\tassert(longp)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_mortalizesv(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_SAVE_MORTALIZESV\t\\\n\tassert(sv)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_nogv(pTHX_ GV* gv);\n#define PERL_ARGS_ASSERT_SAVE_NOGV\t\\\n\tassert(gv)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_op(pTHX);\n#endif\nPERL_CALLCONV void\tPerl_save_padsv_and_mortalize(pTHX_ PADOFFSET off);\nPERL_CALLCONV void\tPerl_save_pptr(pTHX_ char** pptr);\n#define PERL_ARGS_ASSERT_SAVE_PPTR\t\\\n\tassert(pptr)\nPERL_CALLCONV void\tPerl_save_pushi32ptr(pTHX_ const I32 i, void *const ptr, const int type);\nPERL_CALLCONV void\tPerl_save_pushptr(pTHX_ void *const ptr, const int type);\nPERL_CALLCONV void\tPerl_save_pushptrptr(pTHX_ void *const ptr1, void *const ptr2, const int type);\nPERL_CALLCONV void\tPerl_save_re_context(pTHX);\nPERL_CALLCONV SV*\tPerl_save_scalar(pTHX_ GV* gv);\n#define PERL_ARGS_ASSERT_SAVE_SCALAR\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_save_set_svflags(pTHX_ SV *sv, U32 mask, U32 val);\n#define PERL_ARGS_ASSERT_SAVE_SET_SVFLAGS\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_save_shared_pvref(pTHX_ char** str);\n#define PERL_ARGS_ASSERT_SAVE_SHARED_PVREF\t\\\n\tassert(str)\nPERL_CALLCONV void\tPerl_save_sptr(pTHX_ SV** sptr);\n#define PERL_ARGS_ASSERT_SAVE_SPTR\t\\\n\tassert(sptr)\nPERL_CALLCONV void\tPerl_save_strlen(pTHX_ STRLEN* ptr);\n#define PERL_ARGS_ASSERT_SAVE_STRLEN\t\\\n\tassert(ptr)\nPERL_CALLCONV SV*\tPerl_save_svref(pTHX_ SV** sptr);\n#define PERL_ARGS_ASSERT_SAVE_SVREF\t\\\n\tassert(sptr)\nPERL_CALLCONV void\tPerl_save_vptr(pTHX_ void *ptr);\n#define PERL_ARGS_ASSERT_SAVE_VPTR\t\\\n\tassert(ptr)\nPERL_CALLCONV char*\tPerl_savepv(pTHX_ const char* pv)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV char*\tPerl_savepvn(pTHX_ const char* pv, I32 len)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV char*\tPerl_savesharedpv(pTHX_ const char* pv)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV char*\tPerl_savesharedpvn(pTHX_ const char *const pv, const STRLEN len)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV char*\tPerl_savesharedsvpv(pTHX_ SV *sv)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SAVESHAREDSVPV\t\\\n\tassert(sv)\n\nPERL_CALLCONV void\tPerl_savestack_grow(pTHX);\nPERL_CALLCONV void\tPerl_savestack_grow_cnt(pTHX_ I32 need);\nPERL_CALLCONV char*\tPerl_savesvpv(pTHX_ SV* sv)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SAVESVPV\t\\\n\tassert(sv)\n\nPERL_CALLCONV void\tPerl_savetmps(pTHX);\nPERL_CALLCONV OP*\tPerl_sawparens(pTHX_ OP* o);\nPERL_CALLCONV OP*\tPerl_scalar(pTHX_ OP* o);\nPERL_CALLCONV OP*\tPerl_scalarvoid(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_SCALARVOID\t\\\n\tassert(o)\nPERL_CALLCONV NV\tPerl_scan_bin(pTHX_ const char* start, STRLEN len, STRLEN* retlen);\n#define PERL_ARGS_ASSERT_SCAN_BIN\t\\\n\tassert(start); assert(retlen)\nPERL_CALLCONV NV\tPerl_scan_hex(pTHX_ const char* start, STRLEN len, STRLEN* retlen);\n#define PERL_ARGS_ASSERT_SCAN_HEX\t\\\n\tassert(start); assert(retlen)\nPERL_CALLCONV char*\tPerl_scan_num(pTHX_ const char* s, YYSTYPE *lvalp);\n#define PERL_ARGS_ASSERT_SCAN_NUM\t\\\n\tassert(s); assert(lvalp)\nPERL_CALLCONV NV\tPerl_scan_oct(pTHX_ const char* start, STRLEN len, STRLEN* retlen);\n#define PERL_ARGS_ASSERT_SCAN_OCT\t\\\n\tassert(start); assert(retlen)\nPERL_CALLCONV char*\tPerl_scan_str(pTHX_ char *start, int keep_quoted, int keep_delims, int re_reparse, char **delimp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_STR\t\\\n\tassert(start)\n\nPERL_CALLCONV const char*\tPerl_scan_version(pTHX_ const char *s, SV *rv, bool qv);\n#define PERL_ARGS_ASSERT_SCAN_VERSION\t\\\n\tassert(s); assert(rv)\nPERL_CALLCONV char*\tPerl_scan_vstring(pTHX_ const char *s, const char *const e, SV *sv);\n#define PERL_ARGS_ASSERT_SCAN_VSTRING\t\\\n\tassert(s); assert(e); assert(sv)\nPERL_CALLCONV char*\tPerl_scan_word(pTHX_ char *s, char *dest, STRLEN destlen, int allow_package, STRLEN *slp);\n#define PERL_ARGS_ASSERT_SCAN_WORD\t\\\n\tassert(s); assert(dest); assert(slp)\nPERL_CALLCONV U32\tPerl_seed(pTHX);\nPERL_CALLCONV void\tPerl_set_caret_X(pTHX);\nPERL_CALLCONV void\tPerl_set_context(void *t);\n#define PERL_ARGS_ASSERT_SET_CONTEXT\t\\\n\tassert(t)\nPERL_CALLCONV void\tPerl_set_numeric_standard(pTHX);\nPERL_CALLCONV void\tPerl_set_numeric_underlying(pTHX);\nPERL_CALLCONV void\tPerl_setdefout(pTHX_ GV* gv);\n#define PERL_ARGS_ASSERT_SETDEFOUT\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_setfd_cloexec(int fd);\nPERL_CALLCONV void\tPerl_setfd_cloexec_for_nonsysfd(pTHX_ int fd);\nPERL_CALLCONV void\tPerl_setfd_cloexec_or_inhexec_by_sysfdness(pTHX_ int fd);\nPERL_CALLCONV void\tPerl_setfd_inhexec(int fd);\nPERL_CALLCONV void\tPerl_setfd_inhexec_for_sysfd(pTHX_ int fd);\nPERL_CALLCONV HEK*\tPerl_share_hek(pTHX_ const char* str, SSize_t len, U32 hash);\n#define PERL_ARGS_ASSERT_SHARE_HEK\t\\\n\tassert(str)\nPERL_CALLCONV char*\tPerl_skipspace_flags(pTHX_ char *s, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SKIPSPACE_FLAGS\t\\\n\tassert(s)\n\nPERL_CALLCONV void\tPerl_sortsv(pTHX_ SV** array, size_t num_elts, SVCOMPARE_t cmp);\n#define PERL_ARGS_ASSERT_SORTSV\t\\\n\tassert(cmp)\nPERL_CALLCONV void\tPerl_sortsv_flags(pTHX_ SV** array, size_t num_elts, SVCOMPARE_t cmp, U32 flags);\n#define PERL_ARGS_ASSERT_SORTSV_FLAGS\t\\\n\tassert(cmp)\nPERL_CALLCONV SV**\tPerl_stack_grow(pTHX_ SV** sp, SV** p, SSize_t n);\n#define PERL_ARGS_ASSERT_STACK_GROW\t\\\n\tassert(sp); assert(p)\nPERL_CALLCONV PerlIO*\tPerl_start_glob(pTHX_ SV *tmpglob, IO *io);\n#define PERL_ARGS_ASSERT_START_GLOB\t\\\n\tassert(tmpglob); assert(io)\nPERL_CALLCONV I32\tPerl_start_subparse(pTHX_ I32 is_format, U32 flags);\nPERL_CALLCONV NV\tPerl_str_to_version(pTHX_ SV *sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_STR_TO_VERSION\t\\\n\tassert(sv)\n\nPERL_CALLCONV void\tPerl_sub_crush_depth(pTHX_ CV* cv);\n#define PERL_ARGS_ASSERT_SUB_CRUSH_DEPTH\t\\\n\tassert(cv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_sv_2bool(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_2BOOL\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV bool\tPerl_sv_2bool_flags(pTHX_ SV *sv, I32 flags);\n#define PERL_ARGS_ASSERT_SV_2BOOL_FLAGS\t\\\n\tassert(sv)\nPERL_CALLCONV CV*\tPerl_sv_2cv(pTHX_ SV* sv, HV **const st, GV **const gvp, const I32 lref);\n#define PERL_ARGS_ASSERT_SV_2CV\t\\\n\tassert(st); assert(gvp)\nPERL_CALLCONV IO*\tPerl_sv_2io(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_2IO\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV IV\tPerl_sv_2iv(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_2IV\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV IV\tPerl_sv_2iv_flags(pTHX_ SV *const sv, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_2IV_FLAGS\t\\\n\tassert(sv)\nPERL_CALLCONV SV*\tPerl_sv_2mortal(pTHX_ SV *const sv);\nPERL_CALLCONV SV*\tPerl_sv_2num(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_2NUM\t\\\n\tassert(sv)\nPERL_CALLCONV NV\tPerl_sv_2nv_flags(pTHX_ SV *const sv, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_2NV_FLAGS\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_2pv(pTHX_ SV *sv, STRLEN *lp);\n#define PERL_ARGS_ASSERT_SV_2PV\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV char*\tPerl_sv_2pv_flags(pTHX_ SV *const sv, STRLEN *const lp, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_2PV_FLAGS\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_2pv_nolen(pTHX_ SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_2PV_NOLEN\t\\\n\tassert(sv)\n#endif\n\nPERL_CALLCONV char*\tPerl_sv_2pvbyte(pTHX_ SV *sv, STRLEN *const lp);\n#define PERL_ARGS_ASSERT_SV_2PVBYTE\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_2pvbyte_nolen(pTHX_ SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_2PVBYTE_NOLEN\t\\\n\tassert(sv)\n#endif\n\nPERL_CALLCONV char*\tPerl_sv_2pvutf8(pTHX_ SV *sv, STRLEN *const lp);\n#define PERL_ARGS_ASSERT_SV_2PVUTF8\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_2pvutf8_nolen(pTHX_ SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_2PVUTF8_NOLEN\t\\\n\tassert(sv)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_sv_2uv(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_2UV\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV UV\tPerl_sv_2uv_flags(pTHX_ SV *const sv, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_2UV_FLAGS\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_backoff(SV *const sv);\n#define PERL_ARGS_ASSERT_SV_BACKOFF\t\\\n\tassert(sv)\nPERL_CALLCONV SV*\tPerl_sv_bless(pTHX_ SV *const sv, HV *const stash);\n#define PERL_ARGS_ASSERT_SV_BLESS\t\\\n\tassert(sv); assert(stash)\nPERL_CALLCONV bool\tPerl_sv_cat_decode(pTHX_ SV* dsv, SV *encoding, SV *ssv, int *offset, char* tstr, int tlen);\n#define PERL_ARGS_ASSERT_SV_CAT_DECODE\t\\\n\tassert(dsv); assert(encoding); assert(ssv); assert(offset); assert(tstr)\nPERL_CALLCONV void\tPerl_sv_catpv(pTHX_ SV *const sv, const char* ptr);\n#define PERL_ARGS_ASSERT_SV_CATPV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_catpv_flags(pTHX_ SV *dstr, const char *sstr, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_CATPV_FLAGS\t\\\n\tassert(dstr); assert(sstr)\nPERL_CALLCONV void\tPerl_sv_catpv_mg(pTHX_ SV *const sv, const char *const ptr);\n#define PERL_ARGS_ASSERT_SV_CATPV_MG\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_catpvf(pTHX_ SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_2,pTHX_3);\n#define PERL_ARGS_ASSERT_SV_CATPVF\t\\\n\tassert(sv); assert(pat)\n\nPERL_CALLCONV void\tPerl_sv_catpvf_mg(pTHX_ SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_2,pTHX_3);\n#define PERL_ARGS_ASSERT_SV_CATPVF_MG\t\\\n\tassert(sv); assert(pat)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_catpvn(pTHX_ SV *dsv, const char *sstr, STRLEN len);\n#define PERL_ARGS_ASSERT_SV_CATPVN\t\\\n\tassert(dsv); assert(sstr)\n#endif\nPERL_CALLCONV void\tPerl_sv_catpvn_flags(pTHX_ SV *const dstr, const char *sstr, const STRLEN len, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_CATPVN_FLAGS\t\\\n\tassert(dstr); assert(sstr)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_catpvn_mg(pTHX_ SV *sv, const char *ptr, STRLEN len);\n#define PERL_ARGS_ASSERT_SV_CATPVN_MG\t\\\n\tassert(sv); assert(ptr)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_catsv(pTHX_ SV *dstr, SV *sstr);\n#define PERL_ARGS_ASSERT_SV_CATSV\t\\\n\tassert(dstr)\n#endif\nPERL_CALLCONV void\tPerl_sv_catsv_flags(pTHX_ SV *const dsv, SV *const ssv, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_CATSV_FLAGS\t\\\n\tassert(dsv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_catsv_mg(pTHX_ SV *dsv, SV *ssv);\n#define PERL_ARGS_ASSERT_SV_CATSV_MG\t\\\n\tassert(dsv)\n#endif\nPERL_CALLCONV void\tPerl_sv_chop(pTHX_ SV *const sv, const char *const ptr);\n#define PERL_ARGS_ASSERT_SV_CHOP\t\\\n\tassert(sv)\nPERL_CALLCONV I32\tPerl_sv_clean_all(pTHX);\nPERL_CALLCONV void\tPerl_sv_clean_objs(pTHX);\nPERL_CALLCONV void\tPerl_sv_clear(pTHX_ SV *const orig_sv);\n#define PERL_ARGS_ASSERT_SV_CLEAR\t\\\n\tassert(orig_sv)\nPERL_CALLCONV I32\tPerl_sv_cmp(pTHX_ SV *const sv1, SV *const sv2);\nPERL_CALLCONV I32\tPerl_sv_cmp_flags(pTHX_ SV *const sv1, SV *const sv2, const U32 flags);\nPERL_CALLCONV I32\tPerl_sv_cmp_locale(pTHX_ SV *const sv1, SV *const sv2);\nPERL_CALLCONV I32\tPerl_sv_cmp_locale_flags(pTHX_ SV *const sv1, SV *const sv2, const U32 flags);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_copypv(pTHX_ SV *const dsv, SV *const ssv);\n#define PERL_ARGS_ASSERT_SV_COPYPV\t\\\n\tassert(dsv); assert(ssv)\n#endif\nPERL_CALLCONV void\tPerl_sv_copypv_flags(pTHX_ SV *const dsv, SV *const ssv, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_COPYPV_FLAGS\t\\\n\tassert(dsv); assert(ssv)\n/* PERL_CALLCONV void\tPerl_sv_copypv_nomg(pTHX_ SV *const dsv, SV *const ssv); */\nPERL_CALLCONV void\tPerl_sv_dec(pTHX_ SV *const sv);\nPERL_CALLCONV void\tPerl_sv_dec_nomg(pTHX_ SV *const sv);\nPERL_CALLCONV void\tPerl_sv_del_backref(pTHX_ SV *const tsv, SV *const sv);\n#define PERL_ARGS_ASSERT_SV_DEL_BACKREF\t\\\n\tassert(tsv); assert(sv)\nPERL_CALLCONV bool\tPerl_sv_derived_from(pTHX_ SV* sv, const char *const name)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DERIVED_FROM\t\\\n\tassert(sv); assert(name)\n\nPERL_CALLCONV bool\tPerl_sv_derived_from_pv(pTHX_ SV* sv, const char *const name, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DERIVED_FROM_PV\t\\\n\tassert(sv); assert(name)\n\nPERL_CALLCONV bool\tPerl_sv_derived_from_pvn(pTHX_ SV* sv, const char *const name, const STRLEN len, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DERIVED_FROM_PVN\t\\\n\tassert(sv); assert(name)\n\nPERL_CALLCONV bool\tPerl_sv_derived_from_sv(pTHX_ SV* sv, SV *namesv, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DERIVED_FROM_SV\t\\\n\tassert(sv); assert(namesv)\n\nPERL_CALLCONV bool\tPerl_sv_destroyable(pTHX_ SV *sv);\nPERL_CALLCONV bool\tPerl_sv_does(pTHX_ SV* sv, const char *const name)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DOES\t\\\n\tassert(sv); assert(name)\n\nPERL_CALLCONV bool\tPerl_sv_does_pv(pTHX_ SV* sv, const char *const name, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DOES_PV\t\\\n\tassert(sv); assert(name)\n\nPERL_CALLCONV bool\tPerl_sv_does_pvn(pTHX_ SV* sv, const char *const name, const STRLEN len, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DOES_PVN\t\\\n\tassert(sv); assert(name)\n\nPERL_CALLCONV bool\tPerl_sv_does_sv(pTHX_ SV* sv, SV* namesv, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DOES_SV\t\\\n\tassert(sv); assert(namesv)\n\nPERL_CALLCONV void\tPerl_sv_dump(pTHX_ SV* sv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV I32\tPerl_sv_eq(pTHX_ SV* sv1, SV* sv2);\n#endif\nPERL_CALLCONV I32\tPerl_sv_eq_flags(pTHX_ SV* sv1, SV* sv2, const U32 flags);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_force_normal(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_FORCE_NORMAL\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV void\tPerl_sv_force_normal_flags(pTHX_ SV *const sv, const U32 flags);\n#define PERL_ARGS_ASSERT_SV_FORCE_NORMAL_FLAGS\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_free(pTHX_ SV *const sv);\nPERL_CALLCONV void\tPerl_sv_free2(pTHX_ SV *const sv, const U32 refcnt);\n#define PERL_ARGS_ASSERT_SV_FREE2\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_free_arenas(pTHX);\nPERL_CALLCONV SV*\tPerl_sv_get_backrefs(SV *const sv);\n#define PERL_ARGS_ASSERT_SV_GET_BACKREFS\t\\\n\tassert(sv)\nPERL_CALLCONV char*\tPerl_sv_gets(pTHX_ SV *const sv, PerlIO *const fp, I32 append);\n#define PERL_ARGS_ASSERT_SV_GETS\t\\\n\tassert(sv); assert(fp)\nPERL_CALLCONV char*\tPerl_sv_grow(pTHX_ SV *const sv, STRLEN newlen);\n#define PERL_ARGS_ASSERT_SV_GROW\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_inc(pTHX_ SV *const sv);\nPERL_CALLCONV void\tPerl_sv_inc_nomg(pTHX_ SV *const sv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_insert(pTHX_ SV *const bigstr, const STRLEN offset, const STRLEN len, const char *const little, const STRLEN littlelen);\n#define PERL_ARGS_ASSERT_SV_INSERT\t\\\n\tassert(bigstr); assert(little)\n#endif\nPERL_CALLCONV void\tPerl_sv_insert_flags(pTHX_ SV *const bigstr, const STRLEN offset, const STRLEN len, const char *little, const STRLEN littlelen, const U32 flags);\n#define PERL_ARGS_ASSERT_SV_INSERT_FLAGS\t\\\n\tassert(bigstr); assert(little)\nPERL_CALLCONV int\tPerl_sv_isa(pTHX_ SV* sv, const char *const name);\n#define PERL_ARGS_ASSERT_SV_ISA\t\\\n\tassert(name)\nPERL_CALLCONV int\tPerl_sv_isobject(pTHX_ SV* sv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV IV\tPerl_sv_iv(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_SV_IV\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV STRLEN\tPerl_sv_len(pTHX_ SV *const sv);\nPERL_CALLCONV STRLEN\tPerl_sv_len_utf8(pTHX_ SV *const sv);\nPERL_CALLCONV STRLEN\tPerl_sv_len_utf8_nomg(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_LEN_UTF8_NOMG\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_magic(pTHX_ SV *const sv, SV *const obj, const int how, const char *const name, const I32 namlen);\n#define PERL_ARGS_ASSERT_SV_MAGIC\t\\\n\tassert(sv)\nPERL_CALLCONV MAGIC *\tPerl_sv_magicext(pTHX_ SV *const sv, SV *const obj, const int how, const MGVTBL *const vtbl, const char *const name, const I32 namlen);\n#define PERL_ARGS_ASSERT_SV_MAGICEXT\t\\\n\tassert(sv)\nPERL_CALLCONV MAGIC *\tPerl_sv_magicext_mglob(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_MAGICEXT_MGLOB\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV SV*\tPerl_sv_mortalcopy(pTHX_ SV *const oldsv)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV SV*\tPerl_sv_mortalcopy_flags(pTHX_ SV *const oldsv, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_sv_newmortal(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_sv_newref(pTHX_ SV *const sv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_nolocking(pTHX_ SV *sv);\n#endif\nPERL_CALLCONV void\tPerl_sv_nosharing(pTHX_ SV *sv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_nounlocking(pTHX_ SV *sv);\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV NV\tPerl_sv_nv(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_SV_NV\t\\\n\tassert(sv)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_sv_only_taint_gmagic(SV *sv);\n#define PERL_ARGS_ASSERT_SV_ONLY_TAINT_GMAGIC\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV char*\tPerl_sv_peek(pTHX_ SV* sv);\nPERL_CALLCONV void\tPerl_sv_pos_b2u(pTHX_ SV *const sv, I32 *const offsetp);\n#define PERL_ARGS_ASSERT_SV_POS_B2U\t\\\n\tassert(offsetp)\nPERL_CALLCONV STRLEN\tPerl_sv_pos_b2u_flags(pTHX_ SV *const sv, STRLEN const offset, U32 flags);\n#define PERL_ARGS_ASSERT_SV_POS_B2U_FLAGS\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_pos_u2b(pTHX_ SV *const sv, I32 *const offsetp, I32 *const lenp);\n#define PERL_ARGS_ASSERT_SV_POS_U2B\t\\\n\tassert(offsetp)\nPERL_CALLCONV STRLEN\tPerl_sv_pos_u2b_flags(pTHX_ SV *const sv, STRLEN uoffset, STRLEN *const lenp, U32 flags);\n#define PERL_ARGS_ASSERT_SV_POS_U2B_FLAGS\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pv(pTHX_ SV *sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_PV\t\\\n\tassert(sv)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pvbyte(pTHX_ SV *sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_PVBYTE\t\\\n\tassert(sv)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pvbyten(pTHX_ SV *sv, STRLEN *lp);\n#define PERL_ARGS_ASSERT_SV_PVBYTEN\t\\\n\tassert(sv); assert(lp)\n#endif\nPERL_CALLCONV char*\tPerl_sv_pvbyten_force(pTHX_ SV *const sv, STRLEN *const lp);\n#define PERL_ARGS_ASSERT_SV_PVBYTEN_FORCE\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pvn(pTHX_ SV *sv, STRLEN *lp);\n#define PERL_ARGS_ASSERT_SV_PVN\t\\\n\tassert(sv); assert(lp)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pvn_force(pTHX_ SV* sv, STRLEN* lp);\n#define PERL_ARGS_ASSERT_SV_PVN_FORCE\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV char*\tPerl_sv_pvn_force_flags(pTHX_ SV *const sv, STRLEN *const lp, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_PVN_FORCE_FLAGS\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pvn_nomg(pTHX_ SV* sv, STRLEN* lp);\n#define PERL_ARGS_ASSERT_SV_PVN_NOMG\t\\\n\tassert(sv)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pvutf8(pTHX_ SV *sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_PVUTF8\t\\\n\tassert(sv)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pvutf8n(pTHX_ SV *sv, STRLEN *lp);\n#define PERL_ARGS_ASSERT_SV_PVUTF8N\t\\\n\tassert(sv); assert(lp)\n#endif\nPERL_CALLCONV char*\tPerl_sv_pvutf8n_force(pTHX_ SV *const sv, STRLEN *const lp);\n#define PERL_ARGS_ASSERT_SV_PVUTF8N_FORCE\t\\\n\tassert(sv)\nPERL_CALLCONV char*\tPerl_sv_recode_to_utf8(pTHX_ SV* sv, SV *encoding);\n#define PERL_ARGS_ASSERT_SV_RECODE_TO_UTF8\t\\\n\tassert(sv); assert(encoding)\nPERL_CALLCONV SV*\tPerl_sv_ref(pTHX_ SV *dst, const SV *const sv, const int ob);\n#define PERL_ARGS_ASSERT_SV_REF\t\\\n\tassert(sv)\nPERL_CALLCONV const char*\tPerl_sv_reftype(pTHX_ const SV *const sv, const int ob)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_REFTYPE\t\\\n\tassert(sv)\n\nPERL_CALLCONV void\tPerl_sv_replace(pTHX_ SV *const sv, SV *const nsv);\n#define PERL_ARGS_ASSERT_SV_REPLACE\t\\\n\tassert(sv); assert(nsv)\nPERL_CALLCONV void\tPerl_sv_report_used(pTHX);\nPERL_CALLCONV void\tPerl_sv_reset(pTHX_ const char* s, HV *const stash);\n#define PERL_ARGS_ASSERT_SV_RESET\t\\\n\tassert(s)\nPERL_CALLCONV void\tPerl_sv_resetpvn(pTHX_ const char* s, STRLEN len, HV *const stash);\nPERL_CALLCONV SV*\tPerl_sv_rvunweaken(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_RVUNWEAKEN\t\\\n\tassert(sv)\nPERL_CALLCONV SV*\tPerl_sv_rvweaken(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_RVWEAKEN\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_set_undef(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_SET_UNDEF\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_sethek(pTHX_ SV *const sv, const HEK *const hek);\n#define PERL_ARGS_ASSERT_SV_SETHEK\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setiv(pTHX_ SV *const sv, const IV num);\n#define PERL_ARGS_ASSERT_SV_SETIV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setiv_mg(pTHX_ SV *const sv, const IV i);\n#define PERL_ARGS_ASSERT_SV_SETIV_MG\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setnv(pTHX_ SV *const sv, const NV num);\n#define PERL_ARGS_ASSERT_SV_SETNV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setnv_mg(pTHX_ SV *const sv, const NV num);\n#define PERL_ARGS_ASSERT_SV_SETNV_MG\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setpv(pTHX_ SV *const sv, const char *const ptr);\n#define PERL_ARGS_ASSERT_SV_SETPV\t\\\n\tassert(sv)\nPERL_CALLCONV char  *\tPerl_sv_setpv_bufsize(pTHX_ SV *const sv, const STRLEN cur, const STRLEN len);\n#define PERL_ARGS_ASSERT_SV_SETPV_BUFSIZE\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setpv_mg(pTHX_ SV *const sv, const char *const ptr);\n#define PERL_ARGS_ASSERT_SV_SETPV_MG\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setpvf(pTHX_ SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_2,pTHX_3);\n#define PERL_ARGS_ASSERT_SV_SETPVF\t\\\n\tassert(sv); assert(pat)\n\nPERL_CALLCONV void\tPerl_sv_setpvf_mg(pTHX_ SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_2,pTHX_3);\n#define PERL_ARGS_ASSERT_SV_SETPVF_MG\t\\\n\tassert(sv); assert(pat)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_setpviv(pTHX_ SV *const sv, const IV num);\n#define PERL_ARGS_ASSERT_SV_SETPVIV\t\\\n\tassert(sv)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_setpviv_mg(pTHX_ SV *const sv, const IV iv);\n#define PERL_ARGS_ASSERT_SV_SETPVIV_MG\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV void\tPerl_sv_setpvn(pTHX_ SV *const sv, const char *const ptr, const STRLEN len);\n#define PERL_ARGS_ASSERT_SV_SETPVN\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setpvn_mg(pTHX_ SV *const sv, const char *const ptr, const STRLEN len);\n#define PERL_ARGS_ASSERT_SV_SETPVN_MG\t\\\n\tassert(sv); assert(ptr)\nPERL_CALLCONV SV*\tPerl_sv_setref_iv(pTHX_ SV *const rv, const char *const classname, const IV iv);\n#define PERL_ARGS_ASSERT_SV_SETREF_IV\t\\\n\tassert(rv)\nPERL_CALLCONV SV*\tPerl_sv_setref_nv(pTHX_ SV *const rv, const char *const classname, const NV nv);\n#define PERL_ARGS_ASSERT_SV_SETREF_NV\t\\\n\tassert(rv)\nPERL_CALLCONV SV*\tPerl_sv_setref_pv(pTHX_ SV *const rv, const char *const classname, void *const pv);\n#define PERL_ARGS_ASSERT_SV_SETREF_PV\t\\\n\tassert(rv)\nPERL_CALLCONV SV*\tPerl_sv_setref_pvn(pTHX_ SV *const rv, const char *const classname, const char *const pv, const STRLEN n);\n#define PERL_ARGS_ASSERT_SV_SETREF_PVN\t\\\n\tassert(rv); assert(pv)\nPERL_CALLCONV SV*\tPerl_sv_setref_uv(pTHX_ SV *const rv, const char *const classname, const UV uv);\n#define PERL_ARGS_ASSERT_SV_SETREF_UV\t\\\n\tassert(rv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_setsv(pTHX_ SV *dstr, SV *sstr);\n#define PERL_ARGS_ASSERT_SV_SETSV\t\\\n\tassert(dstr)\n#endif\nPERL_CALLCONV void\tPerl_sv_setsv_flags(pTHX_ SV *dstr, SV *sstr, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_SETSV_FLAGS\t\\\n\tassert(dstr)\nPERL_CALLCONV void\tPerl_sv_setsv_mg(pTHX_ SV *const dstr, SV *const sstr);\n#define PERL_ARGS_ASSERT_SV_SETSV_MG\t\\\n\tassert(dstr)\nPERL_CALLCONV void\tPerl_sv_setuv(pTHX_ SV *const sv, const UV num);\n#define PERL_ARGS_ASSERT_SV_SETUV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setuv_mg(pTHX_ SV *const sv, const UV u);\n#define PERL_ARGS_ASSERT_SV_SETUV_MG\t\\\n\tassert(sv)\nPERL_CALLCONV SV*\tPerl_sv_string_from_errnum(pTHX_ int errnum, SV* tgtsv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_taint(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_SV_TAINT\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV bool\tPerl_sv_tainted(pTHX_ SV *const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_TAINTED\t\\\n\tassert(sv)\n\nPERL_CALLCONV I32\tPerl_sv_true(pTHX_ SV *const sv);\nPERL_CALLCONV char*\tPerl_sv_uni_display(pTHX_ SV *dsv, SV *ssv, STRLEN pvlim, UV flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_UNI_DISPLAY\t\\\n\tassert(dsv); assert(ssv)\n\nPERL_CALLCONV int\tPerl_sv_unmagic(pTHX_ SV *const sv, const int type);\n#define PERL_ARGS_ASSERT_SV_UNMAGIC\t\\\n\tassert(sv)\nPERL_CALLCONV int\tPerl_sv_unmagicext(pTHX_ SV *const sv, const int type, MGVTBL *vtbl);\n#define PERL_ARGS_ASSERT_SV_UNMAGICEXT\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_unref(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_SV_UNREF\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV void\tPerl_sv_unref_flags(pTHX_ SV *const ref, const U32 flags);\n#define PERL_ARGS_ASSERT_SV_UNREF_FLAGS\t\\\n\tassert(ref)\nPERL_CALLCONV void\tPerl_sv_untaint(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_UNTAINT\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_upgrade(pTHX_ SV *const sv, svtype new_type);\n#define PERL_ARGS_ASSERT_SV_UPGRADE\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_usepvn(pTHX_ SV* sv, char* ptr, STRLEN len);\n#define PERL_ARGS_ASSERT_SV_USEPVN\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV void\tPerl_sv_usepvn_flags(pTHX_ SV *const sv, char* ptr, const STRLEN len, const U32 flags);\n#define PERL_ARGS_ASSERT_SV_USEPVN_FLAGS\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_usepvn_mg(pTHX_ SV *sv, char *ptr, STRLEN len);\n#define PERL_ARGS_ASSERT_SV_USEPVN_MG\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV bool\tPerl_sv_utf8_decode(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_UTF8_DECODE\t\\\n\tassert(sv)\nPERL_CALLCONV bool\tPerl_sv_utf8_downgrade(pTHX_ SV *const sv, const bool fail_ok);\n#define PERL_ARGS_ASSERT_SV_UTF8_DOWNGRADE\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_utf8_encode(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_UTF8_ENCODE\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV STRLEN\tPerl_sv_utf8_upgrade(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_UTF8_UPGRADE\t\\\n\tassert(sv)\n#endif\n/* PERL_CALLCONV STRLEN\tPerl_sv_utf8_upgrade_flags(pTHX_ SV *const sv, const I32 flags); */\nPERL_CALLCONV STRLEN\tPerl_sv_utf8_upgrade_flags_grow(pTHX_ SV *const sv, const I32 flags, STRLEN extra);\n#define PERL_ARGS_ASSERT_SV_UTF8_UPGRADE_FLAGS_GROW\t\\\n\tassert(sv)\n/* PERL_CALLCONV STRLEN\tsv_utf8_upgrade_nomg(pTHX_ SV *sv); */\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_sv_uv(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_SV_UV\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV void\tPerl_sv_vcatpvf(pTHX_ SV *const sv, const char *const pat, va_list *const args);\n#define PERL_ARGS_ASSERT_SV_VCATPVF\t\\\n\tassert(sv); assert(pat)\nPERL_CALLCONV void\tPerl_sv_vcatpvf_mg(pTHX_ SV *const sv, const char *const pat, va_list *const args);\n#define PERL_ARGS_ASSERT_SV_VCATPVF_MG\t\\\n\tassert(sv); assert(pat)\nPERL_CALLCONV void\tPerl_sv_vcatpvfn(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen, va_list *const args, SV **const svargs, const Size_t sv_count, bool *const maybe_tainted);\n#define PERL_ARGS_ASSERT_SV_VCATPVFN\t\\\n\tassert(sv); assert(pat)\nPERL_CALLCONV void\tPerl_sv_vcatpvfn_flags(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen, va_list *const args, SV **const svargs, const Size_t sv_count, bool *const maybe_tainted, const U32 flags);\n#define PERL_ARGS_ASSERT_SV_VCATPVFN_FLAGS\t\\\n\tassert(sv); assert(pat)\nPERL_CALLCONV void\tPerl_sv_vsetpvf(pTHX_ SV *const sv, const char *const pat, va_list *const args);\n#define PERL_ARGS_ASSERT_SV_VSETPVF\t\\\n\tassert(sv); assert(pat)\nPERL_CALLCONV void\tPerl_sv_vsetpvf_mg(pTHX_ SV *const sv, const char *const pat, va_list *const args);\n#define PERL_ARGS_ASSERT_SV_VSETPVF_MG\t\\\n\tassert(sv); assert(pat)\nPERL_CALLCONV void\tPerl_sv_vsetpvfn(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen, va_list *const args, SV **const svargs, const Size_t sv_count, bool *const maybe_tainted);\n#define PERL_ARGS_ASSERT_SV_VSETPVFN\t\\\n\tassert(sv); assert(pat)\nPERL_CALLCONV UV\tPerl_swash_fetch(pTHX_ SV *swash, const U8 *ptr, bool do_utf8);\n#define PERL_ARGS_ASSERT_SWASH_FETCH\t\\\n\tassert(swash); assert(ptr)\nPERL_CALLCONV SV*\tPerl_swash_init(pTHX_ const char* pkg, const char* name, SV* listsv, I32 minbits, I32 none)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SWASH_INIT\t\\\n\tassert(pkg); assert(name); assert(listsv)\n\nPERL_CALLCONV void\tPerl_switch_to_global_locale(void);\nPERL_CALLCONV bool\tPerl_sync_locale(void);\nPERL_CALLCONV void\tPerl_sys_init(int* argc, char*** argv);\n#define PERL_ARGS_ASSERT_SYS_INIT\t\\\n\tassert(argc); assert(argv)\nPERL_CALLCONV void\tPerl_sys_init3(int* argc, char*** argv, char*** env);\n#define PERL_ARGS_ASSERT_SYS_INIT3\t\\\n\tassert(argc); assert(argv); assert(env)\nPERL_CALLCONV void\tPerl_sys_term(void);\nPERL_CALLCONV void\tPerl_taint_env(pTHX);\nPERL_CALLCONV void\tPerl_taint_proper(pTHX_ const char* f, const char *const s);\n#define PERL_ARGS_ASSERT_TAINT_PROPER\t\\\n\tassert(s)\nPERL_CALLCONV void\tPerl_thread_locale_init(void);\nPERL_CALLCONV void\tPerl_thread_locale_term(void);\nPERL_CALLCONV OP *\tPerl_tied_method(pTHX_ SV *methname, SV **sp, SV *const sv, const MAGIC *const mg, const U32 flags, U32 argc, ...);\n#define PERL_ARGS_ASSERT_TIED_METHOD\t\\\n\tassert(methname); assert(sp); assert(sv); assert(mg)\nPERL_CALLCONV SSize_t\tPerl_tmps_grow_p(pTHX_ SSize_t ix);\n/* PERL_CALLCONV UV\tPerl_to_uni_fold(pTHX_ UV c, U8 *p, STRLEN *lenp); */\nPERL_CALLCONV UV\tPerl_to_uni_lower(pTHX_ UV c, U8 *p, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_TO_UNI_LOWER\t\\\n\tassert(p); assert(lenp)\n#ifndef NO_MATHOMS\nPERL_CALLCONV U32\tPerl_to_uni_lower_lc(pTHX_ U32 c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV UV\tPerl_to_uni_title(pTHX_ UV c, U8 *p, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_TO_UNI_TITLE\t\\\n\tassert(p); assert(lenp)\n#ifndef NO_MATHOMS\nPERL_CALLCONV U32\tPerl_to_uni_title_lc(pTHX_ U32 c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV UV\tPerl_to_uni_upper(pTHX_ UV c, U8 *p, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_TO_UNI_UPPER\t\\\n\tassert(p); assert(lenp)\n#ifndef NO_MATHOMS\nPERL_CALLCONV U32\tPerl_to_uni_upper_lc(pTHX_ U32 c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_to_utf8_fold(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_TO_UTF8_FOLD\t\\\n\tassert(p); assert(ustrp)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_to_utf8_lower(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_TO_UTF8_LOWER\t\\\n\tassert(p); assert(ustrp)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_to_utf8_title(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_TO_UTF8_TITLE\t\\\n\tassert(p); assert(ustrp)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_to_utf8_upper(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_TO_UTF8_UPPER\t\\\n\tassert(p); assert(ustrp)\n#endif\n\nPERL_CALLCONV bool\tPerl_try_amagic_bin(pTHX_ int method, int flags);\nPERL_CALLCONV bool\tPerl_try_amagic_un(pTHX_ int method, int flags);\n#ifndef NO_MATHOMS\nPERL_CALLCONV SSize_t\tPerl_unpack_str(pTHX_ const char *pat, const char *patend, const char *s, const char *strbeg, const char *strend, char **new_s, I32 ocnt, U32 flags);\n#define PERL_ARGS_ASSERT_UNPACK_STR\t\\\n\tassert(pat); assert(patend); assert(s); assert(strend)\n#endif\nPERL_CALLCONV SSize_t\tPerl_unpackstring(pTHX_ const char *pat, const char *patend, const char *s, const char *strend, U32 flags);\n#define PERL_ARGS_ASSERT_UNPACKSTRING\t\\\n\tassert(pat); assert(patend); assert(s); assert(strend)\nPERL_CALLCONV void\tPerl_unshare_hek(pTHX_ HEK* hek);\nPERL_CALLCONV void\tPerl_unsharepvn(pTHX_ const char* sv, I32 len, U32 hash);\nPERL_CALLCONV SV*\tPerl_upg_version(pTHX_ SV *ver, bool qv);\n#define PERL_ARGS_ASSERT_UPG_VERSION\t\\\n\tassert(ver)\nPERL_CALLCONV U8*\tPerl_utf16_to_utf8(pTHX_ U8* p, U8 *d, I32 bytelen, I32 *newlen);\n#define PERL_ARGS_ASSERT_UTF16_TO_UTF8\t\\\n\tassert(p); assert(d); assert(newlen)\nPERL_CALLCONV U8*\tPerl_utf16_to_utf8_reversed(pTHX_ U8* p, U8 *d, I32 bytelen, I32 *newlen);\n#define PERL_ARGS_ASSERT_UTF16_TO_UTF8_REVERSED\t\\\n\tassert(p); assert(d); assert(newlen)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE IV\tPerl_utf8_distance(pTHX_ const U8 *a, const U8 *b)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UTF8_DISTANCE\t\\\n\tassert(a); assert(b)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE U8*\tPerl_utf8_hop(const U8 *s, SSize_t off)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UTF8_HOP\t\\\n\tassert(s)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE U8*\tPerl_utf8_hop_back(const U8 *s, SSize_t off, const U8 *start)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UTF8_HOP_BACK\t\\\n\tassert(s); assert(start)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE U8*\tPerl_utf8_hop_forward(const U8 *s, SSize_t off, const U8 *end)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UTF8_HOP_FORWARD\t\\\n\tassert(s); assert(end)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE U8*\tPerl_utf8_hop_safe(const U8 *s, SSize_t off, const U8 *start, const U8 *end)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UTF8_HOP_SAFE\t\\\n\tassert(s); assert(start); assert(end)\n#endif\n\nPERL_CALLCONV STRLEN\tPerl_utf8_length(pTHX_ const U8* s, const U8 *e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UTF8_LENGTH\t\\\n\tassert(s); assert(e)\n\nPERL_CALLCONV U8*\tPerl_utf8_to_bytes(pTHX_ U8 *s, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_UTF8_TO_BYTES\t\\\n\tassert(s); assert(lenp)\nPERL_CALLCONV UV\tPerl_utf8_to_uvchr(pTHX_ const U8 *s, STRLEN *retlen)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_UTF8_TO_UVCHR\t\\\n\tassert(s)\n\nPERL_CALLCONV UV\tPerl_utf8_to_uvchr_buf(pTHX_ const U8 *s, const U8 *send, STRLEN *retlen);\n#define PERL_ARGS_ASSERT_UTF8_TO_UVCHR_BUF\t\\\n\tassert(s); assert(send)\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_utf8_to_uvuni(pTHX_ const U8 *s, STRLEN *retlen)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_UTF8_TO_UVUNI\t\\\n\tassert(s)\n#endif\n\nPERL_CALLCONV UV\tPerl_utf8_to_uvuni_buf(pTHX_ const U8 *s, const U8 *send, STRLEN *retlen)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_UTF8_TO_UVUNI_BUF\t\\\n\tassert(s); assert(send)\n\nPERL_CALLCONV UV\tPerl_utf8n_to_uvchr(const U8 *s, STRLEN curlen, STRLEN *retlen, const U32 flags);\n#define PERL_ARGS_ASSERT_UTF8N_TO_UVCHR\t\\\n\tassert(s)\nPERL_CALLCONV UV\tPerl_utf8n_to_uvchr_error(const U8 *s, STRLEN curlen, STRLEN *retlen, const U32 flags, U32 * errors);\n#define PERL_ARGS_ASSERT_UTF8N_TO_UVCHR_ERROR\t\\\n\tassert(s)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE UV\tS_utf8n_to_uvchr_msgs(const U8 *s, STRLEN curlen, STRLEN *retlen, const U32 flags, U32 * errors, AV ** msgs);\n#define PERL_ARGS_ASSERT_UTF8N_TO_UVCHR_MSGS\t\\\n\tassert(s)\n#endif\nPERL_CALLCONV UV\tPerl_utf8n_to_uvuni(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags);\n#define PERL_ARGS_ASSERT_UTF8N_TO_UVUNI\t\\\n\tassert(s)\nPERL_CALLCONV void\tPerl_utilize(pTHX_ int aver, I32 floor, OP* version, OP* idop, OP* arg);\n#define PERL_ARGS_ASSERT_UTILIZE\t\\\n\tassert(idop)\n/* PERL_CALLCONV U8*\tuvchr_to_utf8(pTHX_ U8 *d, UV uv); */\n/* PERL_CALLCONV U8*\tuvchr_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags); */\n/* PERL_CALLCONV U8*\tuvchr_to_utf8_flags_msgs(pTHX_ U8 *d, UV uv, UV flags, HV ** msgs); */\nPERL_CALLCONV U8*\tPerl_uvoffuni_to_utf8_flags(pTHX_ U8 *d, UV uv, const UV flags);\n#define PERL_ARGS_ASSERT_UVOFFUNI_TO_UTF8_FLAGS\t\\\n\tassert(d)\nPERL_CALLCONV U8*\tPerl_uvoffuni_to_utf8_flags_msgs(pTHX_ U8 *d, UV uv, const UV flags, HV** msgs);\n#define PERL_ARGS_ASSERT_UVOFFUNI_TO_UTF8_FLAGS_MSGS\t\\\n\tassert(d)\nPERL_CALLCONV U8*\tPerl_uvuni_to_utf8(pTHX_ U8 *d, UV uv);\n#define PERL_ARGS_ASSERT_UVUNI_TO_UTF8\t\\\n\tassert(d)\nPERL_CALLCONV U8*\tPerl_uvuni_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags);\n#define PERL_ARGS_ASSERT_UVUNI_TO_UTF8_FLAGS\t\\\n\tassert(d)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE UV\tPerl_valid_utf8_to_uvchr(const U8 *s, STRLEN *retlen)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_VALID_UTF8_TO_UVCHR\t\\\n\tassert(s)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_valid_utf8_to_uvuni(pTHX_ const U8 *s, STRLEN *retlen)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_VALID_UTF8_TO_UVUNI\t\\\n\tassert(s)\n#endif\n\nPERL_CALLCONV bool\tPerl_validate_proto(pTHX_ SV *name, SV *proto, bool warn, bool curstash);\n#define PERL_ARGS_ASSERT_VALIDATE_PROTO\t\\\n\tassert(name)\nPERL_CALLCONV int\tPerl_vcmp(pTHX_ SV *lhv, SV *rhv);\n#define PERL_ARGS_ASSERT_VCMP\t\\\n\tassert(lhv); assert(rhv)\nPERL_CALLCONV_NO_RET void\tPerl_vcroak(pTHX_ const char* pat, va_list* args)\n\t\t\t__attribute__noreturn__;\n\nPERL_CALLCONV void\tPerl_vdeb(pTHX_ const char* pat, va_list* args);\n#define PERL_ARGS_ASSERT_VDEB\t\\\n\tassert(pat)\nPERL_CALLCONV char*\tPerl_vform(pTHX_ const char* pat, va_list* args);\n#define PERL_ARGS_ASSERT_VFORM\t\\\n\tassert(pat)\nPERL_CALLCONV void\tPerl_vivify_defelem(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_VIVIFY_DEFELEM\t\\\n\tassert(sv)\nPERL_CALLCONV SV*\tPerl_vivify_ref(pTHX_ SV* sv, U32 to_what)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_VIVIFY_REF\t\\\n\tassert(sv)\n\nPERL_CALLCONV void\tPerl_vload_module(pTHX_ U32 flags, SV* name, SV* ver, va_list* args);\n#define PERL_ARGS_ASSERT_VLOAD_MODULE\t\\\n\tassert(name)\nPERL_CALLCONV SV*\tPerl_vmess(pTHX_ const char* pat, va_list* args);\n#define PERL_ARGS_ASSERT_VMESS\t\\\n\tassert(pat)\nPERL_CALLCONV SV*\tPerl_vnewSVpvf(pTHX_ const char *const pat, va_list *const args)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_VNEWSVPVF\t\\\n\tassert(pat)\n\nPERL_CALLCONV SV*\tPerl_vnormal(pTHX_ SV *vs);\n#define PERL_ARGS_ASSERT_VNORMAL\t\\\n\tassert(vs)\nPERL_CALLCONV SV*\tPerl_vnumify(pTHX_ SV *vs);\n#define PERL_ARGS_ASSERT_VNUMIFY\t\\\n\tassert(vs)\nPERL_CALLCONV SV*\tPerl_vstringify(pTHX_ SV *vs);\n#define PERL_ARGS_ASSERT_VSTRINGIFY\t\\\n\tassert(vs)\nPERL_CALLCONV SV*\tPerl_vverify(pTHX_ SV *vs);\n#define PERL_ARGS_ASSERT_VVERIFY\t\\\n\tassert(vs)\nPERL_CALLCONV void\tPerl_vwarn(pTHX_ const char* pat, va_list* args);\n#define PERL_ARGS_ASSERT_VWARN\t\\\n\tassert(pat)\nPERL_CALLCONV void\tPerl_vwarner(pTHX_ U32 err, const char* pat, va_list* args);\n#define PERL_ARGS_ASSERT_VWARNER\t\\\n\tassert(pat)\nPERL_CALLCONV I32\tPerl_wait4pid(pTHX_ Pid_t pid, int* statusp, int flags);\n#define PERL_ARGS_ASSERT_WAIT4PID\t\\\n\tassert(statusp)\nPERL_CALLCONV void\tPerl_warn(pTHX_ const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_1,pTHX_2);\n#define PERL_ARGS_ASSERT_WARN\t\\\n\tassert(pat)\n\nPERL_CALLCONV void\tPerl_warn_sv(pTHX_ SV *baseex);\n#define PERL_ARGS_ASSERT_WARN_SV\t\\\n\tassert(baseex)\nPERL_CALLCONV void\tPerl_warner(pTHX_ U32 err, const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_2,pTHX_3);\n#define PERL_ARGS_ASSERT_WARNER\t\\\n\tassert(pat)\n\nPERL_CALLCONV I32\tPerl_was_lvalue_sub(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_watch(pTHX_ char** addr);\n#define PERL_ARGS_ASSERT_WATCH\t\\\n\tassert(addr)\n/* PERL_CALLCONV I32\twhichsig(pTHX_ const char* sig); */\nPERL_CALLCONV I32\tPerl_whichsig_pv(pTHX_ const char* sig);\n#define PERL_ARGS_ASSERT_WHICHSIG_PV\t\\\n\tassert(sig)\nPERL_CALLCONV I32\tPerl_whichsig_pvn(pTHX_ const char* sig, STRLEN len);\n#define PERL_ARGS_ASSERT_WHICHSIG_PVN\t\\\n\tassert(sig)\nPERL_CALLCONV I32\tPerl_whichsig_sv(pTHX_ SV* sigsv);\n#define PERL_ARGS_ASSERT_WHICHSIG_SV\t\\\n\tassert(sigsv)\nPERL_CALLCONV void\tPerl_wrap_keyword_plugin(pTHX_ Perl_keyword_plugin_t new_plugin, Perl_keyword_plugin_t *old_plugin_p);\n#define PERL_ARGS_ASSERT_WRAP_KEYWORD_PLUGIN\t\\\n\tassert(new_plugin); assert(old_plugin_p)\nPERL_CALLCONV void\tPerl_wrap_op_checker(pTHX_ Optype opcode, Perl_check_t new_checker, Perl_check_t *old_checker_p);\n#define PERL_ARGS_ASSERT_WRAP_OP_CHECKER\t\\\n\tassert(new_checker); assert(old_checker_p)\nPERL_CALLCONV void\tPerl_write_to_stderr(pTHX_ SV* msv);\n#define PERL_ARGS_ASSERT_WRITE_TO_STDERR\t\\\n\tassert(msv)\nPERL_CALLCONV void\tPerl_xs_boot_epilog(pTHX_ const I32 ax);\nPERL_CALLCONV I32\tPerl_xs_handshake(const U32 key, void * v_my_perl, const char * file, ...);\n#define PERL_ARGS_ASSERT_XS_HANDSHAKE\t\\\n\tassert(v_my_perl); assert(file)\nPERL_CALLCONV int\tPerl_yyerror(pTHX_ const char *const s);\n#define PERL_ARGS_ASSERT_YYERROR\t\\\n\tassert(s)\nPERL_CALLCONV int\tPerl_yyerror_pv(pTHX_ const char *const s, U32 flags);\n#define PERL_ARGS_ASSERT_YYERROR_PV\t\\\n\tassert(s)\nPERL_CALLCONV int\tPerl_yyerror_pvn(pTHX_ const char *const s, STRLEN len, U32 flags);\nPERL_CALLCONV int\tPerl_yylex(pTHX);\nPERL_CALLCONV int\tPerl_yyparse(pTHX_ int gramtype);\nPERL_CALLCONV void\tPerl_yyquit(pTHX);\nPERL_CALLCONV void\tPerl_yyunlex(pTHX);\n#if ! defined(HAS_MEMRCHR) && (defined(PERL_CORE) || defined(PERL_EXT))\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void *\tS_my_memrchr(const char * s, const char c, const STRLEN len);\n#define PERL_ARGS_ASSERT_MY_MEMRCHR\t\\\n\tassert(s)\n#endif\n#endif\n#if !(defined(DEBUGGING))\n#  if !defined(NV_PRESERVES_UV)\n#    if defined(PERL_IN_SV_C)\nSTATIC int\tS_sv_2iuv_non_preserve(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_2IUV_NON_PRESERVE\t\\\n\tassert(sv)\n#    endif\n#  endif\n#endif\n#if !(defined(HAS_MEMMEM))\nPERL_CALLCONV char*\tPerl_ninstr(const char* big, const char* bigend, const char* little, const char* lend)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#define PERL_ARGS_ASSERT_NINSTR\t\\\n\tassert(big); assert(bigend); assert(little); assert(lend)\n\n#endif\n#if !(defined(HAS_NL_LANGINFO) && defined(PERL_LANGINFO_H))\nPERL_CALLCONV const char*\tPerl_langinfo(const int item);\n#endif\n#if !(defined(HAS_NL_LANGINFO))\n#  if defined(PERL_IN_LOCALE_C)\nSTATIC const char*\tS_my_nl_langinfo(const int item, bool toggle);\n#  endif\n#endif\n#if !(defined(HAS_SIGACTION) && defined(SA_SIGINFO))\nPERL_CALLCONV Signal_t\tPerl_csighandler(int sig);\nPERL_CALLCONV Signal_t\tPerl_sighandler(int sig);\n#endif\n#if !(defined(PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION))\nPERL_CALLCONV bool\tPerl_do_exec(pTHX_ const char* cmd);\n#define PERL_ARGS_ASSERT_DO_EXEC\t\\\n\tassert(cmd)\n#endif\n#if !(defined(PERL_GLOBAL_STRUCT_PRIVATE))\n#  if defined(PERL_IMPLICIT_CONTEXT)\nPERL_CALLCONV void*\tPerl_my_cxt_init(pTHX_ int *indexp, size_t size);\n#define PERL_ARGS_ASSERT_MY_CXT_INIT\t\\\n\tassert(indexp)\n#  endif\n#endif\n#if !(defined(_MSC_VER))\nPERL_CALLCONV_NO_RET int\tPerl_magic_regdatum_set(pTHX_ SV* sv, MAGIC* mg)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_MAGIC_REGDATUM_SET\t\\\n\tassert(sv); assert(mg)\n\n#endif\n#if !defined(EBCDIC)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE unsigned int\tS__variant_byte_number(PERL_UINTMAX_T word)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#endif\n#if !defined(HAS_GETENV_LEN)\nPERL_CALLCONV char*\tPerl_getenv_len(pTHX_ const char *env_elem, unsigned long *len);\n#define PERL_ARGS_ASSERT_GETENV_LEN\t\\\n\tassert(env_elem); assert(len)\n#endif\n#if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)\n#  if defined(PERL_IN_PP_SYS_C)\nSTATIC int\tS_dooneliner(pTHX_ const char *cmd, const char *filename)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DOONELINER\t\\\n\tassert(cmd); assert(filename)\n\n#  endif\n#endif\n#if !defined(HAS_MKOSTEMP)\nPERL_CALLCONV int\tPerl_my_mkostemp(char *templte, int flags);\n#define PERL_ARGS_ASSERT_MY_MKOSTEMP\t\\\n\tassert(templte)\n#endif\n#if !defined(HAS_MKSTEMP)\nPERL_CALLCONV int\tPerl_my_mkstemp(char *templte);\n#define PERL_ARGS_ASSERT_MY_MKSTEMP\t\\\n\tassert(templte)\n#endif\n#if !defined(HAS_RENAME)\nPERL_CALLCONV I32\tPerl_same_dirent(pTHX_ const char* a, const char* b);\n#define PERL_ARGS_ASSERT_SAME_DIRENT\t\\\n\tassert(a); assert(b)\n#endif\n#if !defined(HAS_SIGNBIT)\nPERL_CALLCONV int\tPerl_signbit(NV f)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\n#endif\n#if !defined(HAS_STRLCAT)\nPERL_CALLCONV Size_t\tPerl_my_strlcat(char *dst, const char *src, Size_t size);\n#endif\n#if !defined(HAS_STRLCPY)\nPERL_CALLCONV Size_t\tPerl_my_strlcpy(char *dst, const char *src, Size_t size);\n#endif\n#if !defined(HAS_STRNLEN)\nPERL_CALLCONV Size_t\tPerl_my_strnlen(const char *str, Size_t maxlen);\n#define PERL_ARGS_ASSERT_MY_STRNLEN\t\\\n\tassert(str)\n#endif\n#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)\nPERL_CALLCONV I32\tPerl_my_chsize(pTHX_ int fd, Off_t length)\n\t\t\t__attribute__warn_unused_result__;\n\n#endif\n#if !defined(NV_PRESERVES_UV)\n#  if defined(DEBUGGING)\n#    if defined(PERL_IN_SV_C)\nSTATIC int\tS_sv_2iuv_non_preserve(pTHX_ SV *const sv, I32 numtype);\n#define PERL_ARGS_ASSERT_SV_2IUV_NON_PRESERVE\t\\\n\tassert(sv)\n#    endif\n#  endif\n#endif\n#if !defined(PERL_DISABLE_PMC)\n#  if defined(PERL_IN_PP_CTL_C)\nSTATIC PerlIO *\tS_doopen_pm(pTHX_ SV *name)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DOOPEN_PM\t\\\n\tassert(name)\n\n#  endif\n#endif\n#if !defined(PERL_EXT_RE_BUILD)\n#  if defined(PERL_IN_REGCOMP_C)\nSTATIC void\tS__append_range_to_invlist(pTHX_ SV* const invlist, const UV start, const UV end);\n#define PERL_ARGS_ASSERT__APPEND_RANGE_TO_INVLIST\t\\\n\tassert(invlist)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE UV*\tS__invlist_array_init(SV* const invlist, const bool will_have_0)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__INVLIST_ARRAY_INIT\t\\\n\tassert(invlist)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE IV*\tS_get_invlist_previous_index_addr(SV* invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_INVLIST_PREVIOUS_INDEX_ADDR\t\\\n\tassert(invlist)\n#endif\n\nSTATIC void\tS_initialize_invlist_guts(pTHX_ SV* invlist, const Size_t initial_size);\n#define PERL_ARGS_ASSERT_INITIALIZE_INVLIST_GUTS\t\\\n\tassert(invlist)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_invlist_clear(pTHX_ SV* invlist);\n#define PERL_ARGS_ASSERT_INVLIST_CLEAR\t\\\n\tassert(invlist)\n#endif\nSTATIC void\tS_invlist_extend(pTHX_ SV* const invlist, const UV len);\n#define PERL_ARGS_ASSERT_INVLIST_EXTEND\t\\\n\tassert(invlist)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE UV\tS_invlist_max(SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_INVLIST_MAX\t\\\n\tassert(invlist)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE IV\tS_invlist_previous_index(SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX\t\\\n\tassert(invlist)\n#endif\n\nSTATIC void\tS_invlist_replace_list_destroys_src(pTHX_ SV *dest, SV *src);\n#define PERL_ARGS_ASSERT_INVLIST_REPLACE_LIST_DESTROYS_SRC\t\\\n\tassert(dest); assert(src)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_invlist_set_len(pTHX_ SV* const invlist, const UV len, const bool offset);\n#define PERL_ARGS_ASSERT_INVLIST_SET_LEN\t\\\n\tassert(invlist)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_invlist_set_previous_index(SV* const invlist, const IV index);\n#define PERL_ARGS_ASSERT_INVLIST_SET_PREVIOUS_INDEX\t\\\n\tassert(invlist)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_invlist_trim(SV* invlist);\n#define PERL_ARGS_ASSERT_INVLIST_TRIM\t\\\n\tassert(invlist)\n#endif\n#  endif\n#endif\n#if !defined(PERL_IMPLICIT_SYS)\nPERL_CALLCONV I32\tPerl_my_pclose(pTHX_ PerlIO* ptr);\nPERL_CALLCONV PerlIO*\tPerl_my_popen(pTHX_ const char* cmd, const char* mode);\n#define PERL_ARGS_ASSERT_MY_POPEN\t\\\n\tassert(cmd); assert(mode)\n#endif\n#if !defined(PERL_IS_MINIPERL)\n#  if defined(PERL_IN_PERL_C)\nSTATIC SV *\tS_incpush_if_exists(pTHX_ AV *const av, SV *dir, SV *const stem);\n#define PERL_ARGS_ASSERT_INCPUSH_IF_EXISTS\t\\\n\tassert(av); assert(dir); assert(stem)\n#  endif\n#endif\n#if !defined(PERL_NO_INLINE_FUNCTIONS)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popblock(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPBLOCK\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popeval(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPEVAL\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popformat(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPFORMAT\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popgiven(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPGIVEN\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_poploop(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPLOOP\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popsub(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPSUB\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popsub_args(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPSUB_ARGS\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popsub_common(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPSUB_COMMON\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popwhen(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPWHEN\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE PERL_CONTEXT *\tS_cx_pushblock(pTHX_ U8 type, U8 gimme, SV** sp, I32 saveix);\n#define PERL_ARGS_ASSERT_CX_PUSHBLOCK\t\\\n\tassert(sp)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_pusheval(pTHX_ PERL_CONTEXT *cx, OP *retop, SV *namesv);\n#define PERL_ARGS_ASSERT_CX_PUSHEVAL\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_pushformat(pTHX_ PERL_CONTEXT *cx, CV *cv, OP *retop, GV *gv);\n#define PERL_ARGS_ASSERT_CX_PUSHFORMAT\t\\\n\tassert(cx); assert(cv)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_pushgiven(pTHX_ PERL_CONTEXT *cx, SV *orig_defsv);\n#define PERL_ARGS_ASSERT_CX_PUSHGIVEN\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_pushloop_for(pTHX_ PERL_CONTEXT *cx, void *itervarp, SV *itersave);\n#define PERL_ARGS_ASSERT_CX_PUSHLOOP_FOR\t\\\n\tassert(cx); assert(itervarp)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_pushloop_plain(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_PUSHLOOP_PLAIN\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_pushsub(pTHX_ PERL_CONTEXT *cx, CV *cv, OP *retop, bool hasargs);\n#define PERL_ARGS_ASSERT_CX_PUSHSUB\t\\\n\tassert(cx); assert(cv)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_pushwhen(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_PUSHWHEN\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_topblock(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_TOPBLOCK\t\\\n\tassert(cx)\n#endif\n#endif\n#if !defined(PERL_NO_UTF16_FILTER)\n#  if defined(PERL_IN_TOKE_C)\nSTATIC U8*\tS_add_utf16_textfilter(pTHX_ U8 *const s, bool reversed);\n#define PERL_ARGS_ASSERT_ADD_UTF16_TEXTFILTER\t\\\n\tassert(s)\nSTATIC I32\tS_utf16_textfilter(pTHX_ int idx, SV *sv, int maxlen);\n#define PERL_ARGS_ASSERT_UTF16_TEXTFILTER\t\\\n\tassert(sv)\n#  endif\n#endif\n#if !defined(SETUID_SCRIPTS_ARE_SECURE_NOW)\n#  if defined(PERL_IN_PERL_C)\nSTATIC void\tS_validate_suid(pTHX_ PerlIO *rsfp);\n#define PERL_ARGS_ASSERT_VALIDATE_SUID\t\\\n\tassert(rsfp)\n#  endif\n#endif\n#if !defined(UV_IS_QUAD)\n#  if defined(PERL_IN_UTF8_C)\nSTATIC int\tS_is_utf8_cp_above_31_bits(const U8 * const s, const U8 * const e, const bool consider_overlongs)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_CP_ABOVE_31_BITS\t\\\n\tassert(s); assert(e)\n\n#  endif\n#endif\n#if !defined(WIN32)\nPERL_CALLCONV bool\tPerl_do_exec3(pTHX_ const char *incmd, int fd, int do_report);\n#define PERL_ARGS_ASSERT_DO_EXEC3\t\\\n\tassert(incmd)\n#endif\n#if defined (HAS_SOCKETPAIR) ||     (defined (HAS_SOCKET) && defined(SOCK_DGRAM) && \tdefined(AF_INET) && defined(PF_INET))\nPERL_CALLCONV int\tPerl_PerlSock_socketpair_cloexec(pTHX_ int domain, int type, int protocol, int *pairfd)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PERLSOCK_SOCKETPAIR_CLOEXEC\t\\\n\tassert(pairfd)\n\n#endif\n#if defined(DEBUGGING)\nPERL_CALLCONV int\tPerl_get_debug_opts(pTHX_ const char **s, bool givehelp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_DEBUG_OPTS\t\\\n\tassert(s)\n\nPERL_CALLCONV void\tPerl_hv_assert(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_HV_ASSERT\t\\\n\tassert(hv)\nPERL_CALLCONV void\tPerl_pad_setsv(pTHX_ PADOFFSET po, SV* sv);\n#define PERL_ARGS_ASSERT_PAD_SETSV\t\\\n\tassert(sv)\nPERL_CALLCONV SV*\tPerl_pad_sv(pTHX_ PADOFFSET po);\nPERL_CALLCONV void\tPerl_set_padlist(CV * cv, PADLIST * padlist);\n#define PERL_ARGS_ASSERT_SET_PADLIST\t\\\n\tassert(cv)\n#  if defined(PERL_IN_LOCALE_C)\n#    if defined(USE_LOCALE)\nSTATIC void\tS_print_bytes_for_locale(pTHX_ const char * const s, const char * const e, const bool is_utf8);\n#define PERL_ARGS_ASSERT_PRINT_BYTES_FOR_LOCALE\t\\\n\tassert(s); assert(e)\nSTATIC void\tS_print_collxfrm_input_and_return(pTHX_ const char * const s, const char * const e, const STRLEN * const xlen, const bool is_utf8);\n#define PERL_ARGS_ASSERT_PRINT_COLLXFRM_INPUT_AND_RETURN\t\\\n\tassert(s); assert(e)\nSTATIC char *\tS_setlocale_debug_string(const int category, const char* const locale, const char* const retval)\n\t\t\t__attribute__warn_unused_result__;\n\n#    endif\n#  endif\n#  if defined(PERL_IN_PAD_C)\nSTATIC void\tS_cv_dump(pTHX_ const CV *cv, const char *title);\n#define PERL_ARGS_ASSERT_CV_DUMP\t\\\n\tassert(cv); assert(title)\n#  endif\n#  if defined(PERL_IN_REGCOMP_C)\nSTATIC void\tS_dump_trie(pTHX_ const struct _reg_trie_data *trie, HV* widecharmap, AV *revcharmap, U32 depth);\n#define PERL_ARGS_ASSERT_DUMP_TRIE\t\\\n\tassert(trie); assert(revcharmap)\nSTATIC void\tS_dump_trie_interim_list(pTHX_ const struct _reg_trie_data *trie, HV* widecharmap, AV *revcharmap, U32 next_alloc, U32 depth);\n#define PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_LIST\t\\\n\tassert(trie); assert(revcharmap)\nSTATIC void\tS_dump_trie_interim_table(pTHX_ const struct _reg_trie_data *trie, HV* widecharmap, AV *revcharmap, U32 next_alloc, U32 depth);\n#define PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_TABLE\t\\\n\tassert(trie); assert(revcharmap)\nSTATIC const regnode*\tS_dumpuntil(pTHX_ const regexp *r, const regnode *start, const regnode *node, const regnode *last, const regnode *plast, SV* sv, I32 indent, U32 depth);\n#define PERL_ARGS_ASSERT_DUMPUNTIL\t\\\n\tassert(r); assert(start); assert(node); assert(sv)\nSTATIC bool\tS_put_charclass_bitmap_innards(pTHX_ SV* sv, char* bitmap, SV* nonbitmap_invlist, SV* only_utf8_locale_invlist, const regnode * const node, const bool force_as_is_display);\n#define PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS\t\\\n\tassert(sv)\nSTATIC SV*\tS_put_charclass_bitmap_innards_common(pTHX_ SV* invlist, SV* posixes, SV* only_utf8, SV* not_utf8, SV* only_utf8_locale, const bool invert);\n#define PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_COMMON\t\\\n\tassert(invlist)\nSTATIC void\tS_put_charclass_bitmap_innards_invlist(pTHX_ SV *sv, SV* invlist);\n#define PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_INVLIST\t\\\n\tassert(sv); assert(invlist)\nSTATIC void\tS_put_code_point(pTHX_ SV* sv, UV c);\n#define PERL_ARGS_ASSERT_PUT_CODE_POINT\t\\\n\tassert(sv)\nSTATIC void\tS_put_range(pTHX_ SV* sv, UV start, const UV end, const bool allow_literals);\n#define PERL_ARGS_ASSERT_PUT_RANGE\t\\\n\tassert(sv)\nPERL_CALLCONV int\tPerl_re_indentf(pTHX_ const char *fmt, U32 depth, ...);\n#define PERL_ARGS_ASSERT_RE_INDENTF\t\\\n\tassert(fmt)\nSTATIC void\tS_regdump_extflags(pTHX_ const char *lead, const U32 flags);\nSTATIC void\tS_regdump_intflags(pTHX_ const char *lead, const U32 flags);\nSTATIC bool\tS_regtail_study(pTHX_ RExC_state_t *pRExC_state, regnode_offset p, const regnode_offset val, U32 depth)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGTAIL_STUDY\t\\\n\tassert(pRExC_state); assert(p); assert(val)\n\n#  endif\n#  if defined(PERL_IN_REGEXEC_C)\nSTATIC void\tS_debug_start_match(pTHX_ const REGEXP *prog, const bool do_utf8, const char *start, const char *end, const char *blurb);\n#define PERL_ARGS_ASSERT_DEBUG_START_MATCH\t\\\n\tassert(prog); assert(start); assert(end); assert(blurb)\nSTATIC void\tS_dump_exec_pos(pTHX_ const char *locinput, const regnode *scan, const char *loc_regeol, const char *loc_bostr, const char *loc_reg_starttry, const bool do_utf8, const U32 depth);\n#define PERL_ARGS_ASSERT_DUMP_EXEC_POS\t\\\n\tassert(locinput); assert(scan); assert(loc_regeol); assert(loc_bostr); assert(loc_reg_starttry)\nPERL_CALLCONV int\tPerl_re_exec_indentf(pTHX_ const char *fmt, U32 depth, ...);\n#define PERL_ARGS_ASSERT_RE_EXEC_INDENTF\t\\\n\tassert(fmt)\n#  endif\n#  if defined(PERL_IN_SV_C)\nSTATIC void\tS_del_sv(pTHX_ SV *p);\n#define PERL_ARGS_ASSERT_DEL_SV\t\\\n\tassert(p)\n#  endif\n#  if defined(PERL_IN_TOKE_C)\nSTATIC void\tS_printbuf(pTHX_ const char *const fmt, const char *const s)\n\t\t\t__attribute__format__(__printf__,pTHX_1,0);\n#define PERL_ARGS_ASSERT_PRINTBUF\t\\\n\tassert(fmt); assert(s)\n\nSTATIC int\tS_tokereport(pTHX_ I32 rv, const YYSTYPE* lvalp);\n#define PERL_ARGS_ASSERT_TOKEREPORT\t\\\n\tassert(lvalp)\n#  endif\n#endif\n#if defined(DEBUGGING) && defined(ENABLE_REGEX_SETS_DEBUGGING)\n#  if defined(PERL_IN_REGCOMP_C)\nSTATIC void\tS_dump_regex_sets_structures(pTHX_ RExC_state_t *pRExC_state, AV * stack, const IV fence, AV * fence_stack);\n#define PERL_ARGS_ASSERT_DUMP_REGEX_SETS_STRUCTURES\t\\\n\tassert(pRExC_state); assert(stack); assert(fence_stack)\n#  endif\n#endif\n#if defined(DEBUG_LEAKING_SCALARS_FORK_DUMP)\nPERL_CALLCONV void\tPerl_dump_sv_child(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_DUMP_SV_CHILD\t\\\n\tassert(sv)\n#endif\n#if defined(HAS_MEMMEM)\nPERL_CALLCONV char*\tPerl_ninstr(const char* big, const char* bigend, const char* little, const char* lend)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#define PERL_ARGS_ASSERT_NINSTR\t\\\n\tassert(big); assert(bigend); assert(little); assert(lend)\n\n#endif\n#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)\nPERL_CALLCONV I32\tPerl_do_ipcctl(pTHX_ I32 optype, SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_IPCCTL\t\\\n\tassert(mark); assert(sp)\nPERL_CALLCONV I32\tPerl_do_ipcget(pTHX_ I32 optype, SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_IPCGET\t\\\n\tassert(mark); assert(sp)\nPERL_CALLCONV I32\tPerl_do_msgrcv(pTHX_ SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_MSGRCV\t\\\n\tassert(mark); assert(sp)\nPERL_CALLCONV I32\tPerl_do_msgsnd(pTHX_ SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_MSGSND\t\\\n\tassert(mark); assert(sp)\nPERL_CALLCONV I32\tPerl_do_semop(pTHX_ SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_SEMOP\t\\\n\tassert(mark); assert(sp)\nPERL_CALLCONV I32\tPerl_do_shmio(pTHX_ I32 optype, SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_SHMIO\t\\\n\tassert(mark); assert(sp)\n#endif\n#if defined(HAS_NL_LANGINFO)\n#  if defined(PERL_IN_LOCALE_C)\nSTATIC const char*\tS_my_nl_langinfo(const nl_item item, bool toggle);\n#  endif\n#endif\n#if defined(HAS_NL_LANGINFO) && defined(PERL_LANGINFO_H)\nPERL_CALLCONV const char*\tPerl_langinfo(const nl_item item);\n#endif\n#if defined(HAS_PIPE)\nPERL_CALLCONV int\tPerl_PerlProc_pipe_cloexec(pTHX_ int *pipefd)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PERLPROC_PIPE_CLOEXEC\t\\\n\tassert(pipefd)\n\n#endif\n#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)\nPERL_CALLCONV Signal_t\tPerl_csighandler(int sig, siginfo_t *info, void *uap);\nPERL_CALLCONV Signal_t\tPerl_sighandler(int sig, siginfo_t *info, void *uap);\n#endif\n#if defined(HAS_SOCKET)\nPERL_CALLCONV int\tPerl_PerlSock_accept_cloexec(pTHX_ int listenfd, struct sockaddr *addr, Sock_size_t *addrlen)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV int\tPerl_PerlSock_socket_cloexec(pTHX_ int domain, int type, int protocol)\n\t\t\t__attribute__warn_unused_result__;\n\n#endif\n#if defined(HAVE_INTERP_INTERN)\nPERL_CALLCONV void\tPerl_sys_intern_clear(pTHX);\nPERL_CALLCONV void\tPerl_sys_intern_init(pTHX);\n#  if defined(USE_ITHREADS)\nPERL_CALLCONV void\tPerl_sys_intern_dup(pTHX_ struct interp_intern* src, struct interp_intern* dst);\n#define PERL_ARGS_ASSERT_SYS_INTERN_DUP\t\\\n\tassert(src); assert(dst)\n#  endif\n#endif\n#if defined(MYMALLOC)\nPERL_CALLCONV void\tPerl_dump_mstats(pTHX_ const char* s);\n#define PERL_ARGS_ASSERT_DUMP_MSTATS\t\\\n\tassert(s)\nPERL_CALLCONV int\tPerl_get_mstats(pTHX_ perl_mstats_t *buf, int buflen, int level);\n#define PERL_ARGS_ASSERT_GET_MSTATS\t\\\n\tassert(buf)\nPERL_CALLCONV MEM_SIZE\tPerl_malloc_good_size(size_t nbytes)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV MEM_SIZE\tPerl_malloced_size(void *p)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MALLOCED_SIZE\t\\\n\tassert(p)\n\n#endif\n#if defined(PERL_ANY_COW)\nPERL_CALLCONV SV*\tPerl_sv_setsv_cow(pTHX_ SV* dstr, SV* sstr);\n#define PERL_ARGS_ASSERT_SV_SETSV_COW\t\\\n\tassert(sstr)\n#endif\n#if defined(PERL_CORE)\nPERL_CALLCONV void\tPerl_opslab_force_free(pTHX_ OPSLAB *slab);\n#define PERL_ARGS_ASSERT_OPSLAB_FORCE_FREE\t\\\n\tassert(slab)\nPERL_CALLCONV void\tPerl_opslab_free(pTHX_ OPSLAB *slab);\n#define PERL_ARGS_ASSERT_OPSLAB_FREE\t\\\n\tassert(slab)\nPERL_CALLCONV void\tPerl_opslab_free_nopad(pTHX_ OPSLAB *slab);\n#define PERL_ARGS_ASSERT_OPSLAB_FREE_NOPAD\t\\\n\tassert(slab)\nPERL_CALLCONV void\tPerl_parser_free_nexttoke_ops(pTHX_ yy_parser *parser, OPSLAB *slab);\n#define PERL_ARGS_ASSERT_PARSER_FREE_NEXTTOKE_OPS\t\\\n\tassert(parser); assert(slab)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_should_warn_nl(const char *pv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SHOULD_WARN_NL\t\\\n\tassert(pv)\n#endif\n\n#  if defined(PERL_DEBUG_READONLY_OPS)\nPERL_CALLCONV void\tPerl_Slab_to_ro(pTHX_ OPSLAB *slab);\n#define PERL_ARGS_ASSERT_SLAB_TO_RO\t\\\n\tassert(slab)\nPERL_CALLCONV void\tPerl_Slab_to_rw(pTHX_ OPSLAB *const slab);\n#define PERL_ARGS_ASSERT_SLAB_TO_RW\t\\\n\tassert(slab)\n#  endif\n#endif\n#if defined(PERL_CORE) || defined (PERL_EXT)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_non_invariant_string(const U8* const s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_NON_INVARIANT_STRING\t\\\n\tassert(s)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE STRLEN\tS_sv_or_pv_pos_u2b(pTHX_ SV *sv, const char *pv, STRLEN pos, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_SV_OR_PV_POS_U2B\t\\\n\tassert(sv); assert(pv)\n#endif\n#endif\n#if defined(PERL_CORE) || defined(PERL_EXT)\nPERL_CALLCONV bool\tPerl_isSCRIPT_RUN(pTHX_ const U8 *s, const U8 *send, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISSCRIPT_RUN\t\\\n\tassert(s); assert(send)\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE Size_t\tS_variant_under_utf8_count(const U8* const s, const U8* const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_VARIANT_UNDER_UTF8_COUNT\t\\\n\tassert(s); assert(e)\n#endif\n\n#endif\n#if defined(PERL_CR_FILTER)\n#  if defined(PERL_IN_TOKE_C)\nSTATIC I32\tS_cr_textfilter(pTHX_ int idx, SV *sv, int maxlen);\nSTATIC void\tS_strip_return(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_STRIP_RETURN\t\\\n\tassert(sv)\n#  endif\n#endif\n#if defined(PERL_DEBUG_READONLY_COW)\nPERL_CALLCONV void\tPerl_sv_buf_to_ro(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_BUF_TO_RO\t\\\n\tassert(sv)\n#  if defined(PERL_IN_SV_C)\nSTATIC void\tS_sv_buf_to_rw(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_BUF_TO_RW\t\\\n\tassert(sv)\n#  endif\n#endif\n#if defined(PERL_DEBUG_READONLY_OPS)\nPERL_CALLCONV PADOFFSET\tPerl_op_refcnt_dec(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_OP_REFCNT_DEC\t\\\n\tassert(o)\nPERL_CALLCONV OP *\tPerl_op_refcnt_inc(pTHX_ OP *o);\n#endif\n#if defined(PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION)\n/* PERL_CALLCONV bool\tPerl_do_exec(pTHX_ const char* cmd); */\n#endif\n#if defined(PERL_DONT_CREATE_GVSV)\n#ifndef NO_MATHOMS\nPERL_CALLCONV GV*\tPerl_gv_SVadd(pTHX_ GV *gv);\n#endif\n#endif\n#if defined(PERL_GLOBAL_STRUCT)\nPERL_CALLCONV struct perl_vars *\tPerl_GetVars(pTHX);\nPERL_CALLCONV void\tPerl_free_global_struct(pTHX_ struct perl_vars *plvarsp);\n#define PERL_ARGS_ASSERT_FREE_GLOBAL_STRUCT\t\\\n\tassert(plvarsp)\nPERL_CALLCONV struct perl_vars*\tPerl_init_global_struct(pTHX);\n#endif\n#if defined(PERL_GLOBAL_STRUCT_PRIVATE)\n#  if defined(PERL_IMPLICIT_CONTEXT)\nPERL_CALLCONV int\tPerl_my_cxt_index(pTHX_ const char *my_cxt_key);\n#define PERL_ARGS_ASSERT_MY_CXT_INDEX\t\\\n\tassert(my_cxt_key)\nPERL_CALLCONV void*\tPerl_my_cxt_init(pTHX_ const char *my_cxt_key, size_t size);\n#define PERL_ARGS_ASSERT_MY_CXT_INIT\t\\\n\tassert(my_cxt_key)\n#  endif\n#endif\n#if defined(PERL_IMPLICIT_CONTEXT)\nPERL_CALLCONV_NO_RET void\tPerl_croak_nocontext(const char* pat, ...)\n\t\t\t__attribute__noreturn__\n\t\t\t__attribute__format__null_ok__(__printf__,1,2);\n\nPERL_CALLCONV void\tPerl_deb_nocontext(const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,1,2);\n#define PERL_ARGS_ASSERT_DEB_NOCONTEXT\t\\\n\tassert(pat)\n\nPERL_CALLCONV_NO_RET OP*\tPerl_die_nocontext(const char* pat, ...)\n\t\t\t__attribute__noreturn__\n\t\t\t__attribute__format__null_ok__(__printf__,1,2);\n\nPERL_CALLCONV char*\tPerl_form_nocontext(const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,1,2);\n#define PERL_ARGS_ASSERT_FORM_NOCONTEXT\t\\\n\tassert(pat)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV int\tPerl_fprintf_nocontext(PerlIO *stream, const char *format, ...)\n\t\t\t__attribute__format__(__printf__,2,3);\n#define PERL_ARGS_ASSERT_FPRINTF_NOCONTEXT\t\\\n\tassert(stream); assert(format)\n#endif\n\nPERL_CALLCONV void\tPerl_load_module_nocontext(U32 flags, SV* name, SV* ver, ...);\n#define PERL_ARGS_ASSERT_LOAD_MODULE_NOCONTEXT\t\\\n\tassert(name)\nPERL_CALLCONV SV*\tPerl_mess_nocontext(const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,1,2);\n#define PERL_ARGS_ASSERT_MESS_NOCONTEXT\t\\\n\tassert(pat)\n\nPERL_CALLCONV SV*\tPerl_newSVpvf_nocontext(const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,1,2);\n#define PERL_ARGS_ASSERT_NEWSVPVF_NOCONTEXT\t\\\n\tassert(pat)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV int\tPerl_printf_nocontext(const char *format, ...)\n\t\t\t__attribute__format__(__printf__,1,2);\n#define PERL_ARGS_ASSERT_PRINTF_NOCONTEXT\t\\\n\tassert(format)\n#endif\n\nPERL_CALLCONV void\tPerl_sv_catpvf_mg_nocontext(SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,2,3);\n#define PERL_ARGS_ASSERT_SV_CATPVF_MG_NOCONTEXT\t\\\n\tassert(sv); assert(pat)\n\nPERL_CALLCONV void\tPerl_sv_catpvf_nocontext(SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,2,3);\n#define PERL_ARGS_ASSERT_SV_CATPVF_NOCONTEXT\t\\\n\tassert(sv); assert(pat)\n\nPERL_CALLCONV void\tPerl_sv_setpvf_mg_nocontext(SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,2,3);\n#define PERL_ARGS_ASSERT_SV_SETPVF_MG_NOCONTEXT\t\\\n\tassert(sv); assert(pat)\n\nPERL_CALLCONV void\tPerl_sv_setpvf_nocontext(SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,2,3);\n#define PERL_ARGS_ASSERT_SV_SETPVF_NOCONTEXT\t\\\n\tassert(sv); assert(pat)\n\nPERL_CALLCONV void\tPerl_warn_nocontext(const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,1,2);\n#define PERL_ARGS_ASSERT_WARN_NOCONTEXT\t\\\n\tassert(pat)\n\nPERL_CALLCONV void\tPerl_warner_nocontext(U32 err, const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,2,3);\n#define PERL_ARGS_ASSERT_WARNER_NOCONTEXT\t\\\n\tassert(pat)\n\n#endif\n#if defined(PERL_IMPLICIT_SYS)\nPERL_CALLCONV PerlInterpreter*\tperl_alloc_using(struct IPerlMem *ipM, struct IPerlMem *ipMS, struct IPerlMem *ipMP, struct IPerlEnv *ipE, struct IPerlStdIO *ipStd, struct IPerlLIO *ipLIO, struct IPerlDir *ipD, struct IPerlSock *ipS, struct IPerlProc *ipP);\n#define PERL_ARGS_ASSERT_PERL_ALLOC_USING\t\\\n\tassert(ipM); assert(ipMS); assert(ipMP); assert(ipE); assert(ipStd); assert(ipLIO); assert(ipD); assert(ipS); assert(ipP)\n#  if defined(USE_ITHREADS)\nPERL_CALLCONV PerlInterpreter*\tperl_clone_using(PerlInterpreter *proto_perl, UV flags, struct IPerlMem* ipM, struct IPerlMem* ipMS, struct IPerlMem* ipMP, struct IPerlEnv* ipE, struct IPerlStdIO* ipStd, struct IPerlLIO* ipLIO, struct IPerlDir* ipD, struct IPerlSock* ipS, struct IPerlProc* ipP);\n#define PERL_ARGS_ASSERT_PERL_CLONE_USING\t\\\n\tassert(proto_perl); assert(ipM); assert(ipMS); assert(ipMP); assert(ipE); assert(ipStd); assert(ipLIO); assert(ipD); assert(ipS); assert(ipP)\n#  endif\n#endif\n#if defined(PERL_IN_AV_C)\nSTATIC MAGIC*\tS_get_aux_mg(pTHX_ AV *av);\n#define PERL_ARGS_ASSERT_GET_AUX_MG\t\\\n\tassert(av)\n#endif\n#if defined(PERL_IN_DEB_C)\nSTATIC void\tS_deb_stack_n(pTHX_ SV** stack_base, I32 stack_min, I32 stack_max, I32 mark_min, I32 mark_max);\n#define PERL_ARGS_ASSERT_DEB_STACK_N\t\\\n\tassert(stack_base)\n#endif\n#if defined(PERL_IN_DOIO_C)\nSTATIC bool\tS_argvout_final(pTHX_ MAGIC *mg, IO *io, bool not_implicit);\n#define PERL_ARGS_ASSERT_ARGVOUT_FINAL\t\\\n\tassert(mg); assert(io)\nSTATIC void\tS_exec_failed(pTHX_ const char *cmd, int fd, int do_report);\n#define PERL_ARGS_ASSERT_EXEC_FAILED\t\\\n\tassert(cmd)\nSTATIC bool\tS_ingroup(pTHX_ Gid_t testgid, bool effective)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC bool\tS_openn_cleanup(pTHX_ GV *gv, IO *io, PerlIO *fp, char *mode, const char *oname, PerlIO *saveifp, PerlIO *saveofp, int savefd, char savetype, int writing, bool was_fdopen, const char *type, Stat_t *statbufp);\n#define PERL_ARGS_ASSERT_OPENN_CLEANUP\t\\\n\tassert(gv); assert(io); assert(mode); assert(oname)\nSTATIC IO *\tS_openn_setup(pTHX_ GV *gv, char *mode, PerlIO **saveifp, PerlIO **saveofp, int *savefd, char *savetype);\n#define PERL_ARGS_ASSERT_OPENN_SETUP\t\\\n\tassert(gv); assert(mode); assert(saveifp); assert(saveofp); assert(savefd); assert(savetype)\n#endif\n#if defined(PERL_IN_DOOP_C)\nSTATIC Size_t\tS_do_trans_complex(pTHX_ SV * const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_TRANS_COMPLEX\t\\\n\tassert(sv)\n\nSTATIC Size_t\tS_do_trans_complex_utf8(pTHX_ SV * const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_TRANS_COMPLEX_UTF8\t\\\n\tassert(sv)\n\nSTATIC Size_t\tS_do_trans_count(pTHX_ SV * const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_TRANS_COUNT\t\\\n\tassert(sv)\n\nSTATIC Size_t\tS_do_trans_count_utf8(pTHX_ SV * const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_TRANS_COUNT_UTF8\t\\\n\tassert(sv)\n\nSTATIC Size_t\tS_do_trans_simple(pTHX_ SV * const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_TRANS_SIMPLE\t\\\n\tassert(sv)\n\nSTATIC Size_t\tS_do_trans_simple_utf8(pTHX_ SV * const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_TRANS_SIMPLE_UTF8\t\\\n\tassert(sv)\n\n#endif\n#if defined(PERL_IN_DUMP_C)\nSTATIC CV*\tS_deb_curcv(pTHX_ I32 ix);\nSTATIC void\tS_debprof(pTHX_ const OP *o);\n#define PERL_ARGS_ASSERT_DEBPROF\t\\\n\tassert(o)\nSTATIC SV*\tS_pm_description(pTHX_ const PMOP *pm);\n#define PERL_ARGS_ASSERT_PM_DESCRIPTION\t\\\n\tassert(pm)\nSTATIC UV\tS_sequence_num(pTHX_ const OP *o);\n#endif\n#if defined(PERL_IN_DUMP_C) || defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_SCOPE_C)\nPERL_CALLCONV void\tPerl_hv_kill_backrefs(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_HV_KILL_BACKREFS\t\\\n\tassert(hv)\n#endif\n#if defined(PERL_IN_GV_C)\nSTATIC bool\tS_find_default_stash(pTHX_ HV **stash, const char *name, STRLEN len, const U32 is_utf8, const I32 add, const svtype sv_type);\n#define PERL_ARGS_ASSERT_FIND_DEFAULT_STASH\t\\\n\tassert(stash); assert(name)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE GV*\tS_gv_fetchmeth_internal(pTHX_ HV* stash, SV* meth, const char* name, STRLEN len, I32 level, U32 flags);\n#endif\nSTATIC void\tS_gv_init_svtype(pTHX_ GV *gv, const svtype sv_type);\n#define PERL_ARGS_ASSERT_GV_INIT_SVTYPE\t\\\n\tassert(gv)\nSTATIC bool\tS_gv_is_in_main(pTHX_ const char *name, STRLEN len, const U32 is_utf8);\n#define PERL_ARGS_ASSERT_GV_IS_IN_MAIN\t\\\n\tassert(name)\nSTATIC bool\tS_gv_magicalize(pTHX_ GV *gv, HV *stash, const char *name, STRLEN len, const svtype sv_type);\n#define PERL_ARGS_ASSERT_GV_MAGICALIZE\t\\\n\tassert(gv); assert(stash); assert(name)\nSTATIC void\tS_gv_magicalize_isa(pTHX_ GV *gv);\n#define PERL_ARGS_ASSERT_GV_MAGICALIZE_ISA\t\\\n\tassert(gv)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE HV*\tS_gv_stashpvn_internal(pTHX_ const char* name, U32 namelen, I32 flags);\n#define PERL_ARGS_ASSERT_GV_STASHPVN_INTERNAL\t\\\n\tassert(name)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE HV*\tS_gv_stashsvpvn_cached(pTHX_ SV *namesv, const char* name, U32 namelen, I32 flags);\n#endif\nSTATIC void\tS_maybe_multimagic_gv(pTHX_ GV *gv, const char *name, const svtype sv_type);\n#define PERL_ARGS_ASSERT_MAYBE_MULTIMAGIC_GV\t\\\n\tassert(gv); assert(name)\nSTATIC bool\tS_parse_gv_stash_name(pTHX_ HV **stash, GV **gv, const char **name, STRLEN *len, const char *nambeg, STRLEN full_len, const U32 is_utf8, const I32 add);\n#define PERL_ARGS_ASSERT_PARSE_GV_STASH_NAME\t\\\n\tassert(stash); assert(gv); assert(name); assert(len); assert(nambeg)\nSTATIC void\tS_require_tie_mod(pTHX_ GV *gv, const char varname, const char * name, STRLEN len, const U32 flags);\n#define PERL_ARGS_ASSERT_REQUIRE_TIE_MOD\t\\\n\tassert(gv); assert(varname); assert(name)\n#endif\n#if defined(PERL_IN_GV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_PAD_C) || defined(PERL_IN_OP_C)\nPERL_CALLCONV void\tPerl_sv_add_backref(pTHX_ SV *const tsv, SV *const sv);\n#define PERL_ARGS_ASSERT_SV_ADD_BACKREF\t\\\n\tassert(tsv); assert(sv)\n#endif\n#if defined(PERL_IN_HV_C)\nSTATIC void\tS_clear_placeholders(pTHX_ HV *hv, U32 items);\n#define PERL_ARGS_ASSERT_CLEAR_PLACEHOLDERS\t\\\n\tassert(hv)\nSTATIC void\tS_hsplit(pTHX_ HV *hv, STRLEN const oldsize, STRLEN newsize);\n#define PERL_ARGS_ASSERT_HSPLIT\t\\\n\tassert(hv)\nSTATIC struct xpvhv_aux*\tS_hv_auxinit(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_HV_AUXINIT\t\\\n\tassert(hv)\nSTATIC struct xpvhv_aux*\tS_hv_auxinit_internal(struct xpvhv_aux *iter);\n#define PERL_ARGS_ASSERT_HV_AUXINIT_INTERNAL\t\\\n\tassert(iter)\nSTATIC SV*\tS_hv_delete_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen, int k_flags, I32 d_flags, U32 hash);\nSTATIC SV*\tS_hv_free_ent_ret(pTHX_ HV *hv, HE *entry);\n#define PERL_ARGS_ASSERT_HV_FREE_ENT_RET\t\\\n\tassert(hv); assert(entry)\nSTATIC void\tS_hv_free_entries(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_HV_FREE_ENTRIES\t\\\n\tassert(hv)\nSTATIC void\tS_hv_magic_check(HV *hv, bool *needs_copy, bool *needs_store);\n#define PERL_ARGS_ASSERT_HV_MAGIC_CHECK\t\\\n\tassert(hv); assert(needs_copy); assert(needs_store)\nPERL_STATIC_NO_RET void\tS_hv_notallowed(pTHX_ int flags, const char *key, I32 klen, const char *msg)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_HV_NOTALLOWED\t\\\n\tassert(key); assert(msg)\n\nSTATIC HE*\tS_new_he(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE U32\tS_ptr_hash(PTRV u);\n#endif\nSTATIC SV *\tS_refcounted_he_value(pTHX_ const struct refcounted_he *he);\n#define PERL_ARGS_ASSERT_REFCOUNTED_HE_VALUE\t\\\n\tassert(he)\nSTATIC HEK*\tS_save_hek_flags(const char *str, I32 len, U32 hash, int flags)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SAVE_HEK_FLAGS\t\\\n\tassert(str)\n\nSTATIC HEK*\tS_share_hek_flags(pTHX_ const char *str, STRLEN len, U32 hash, int flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SHARE_HEK_FLAGS\t\\\n\tassert(str)\n\nSTATIC void\tS_unshare_hek_or_pvn(pTHX_ const HEK* hek, const char* str, I32 len, U32 hash);\n#endif\n#if defined(PERL_IN_HV_C) || defined(PERL_IN_MG_C) || defined(PERL_IN_SV_C)\nPERL_CALLCONV void\tPerl_sv_kill_backrefs(pTHX_ SV *const sv, AV *const av);\n#define PERL_ARGS_ASSERT_SV_KILL_BACKREFS\t\\\n\tassert(sv)\n#endif\n#if defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C)\nPERL_CALLCONV SV*\tPerl_hfree_next_entry(pTHX_ HV *hv, STRLEN *indexp);\n#define PERL_ARGS_ASSERT_HFREE_NEXT_ENTRY\t\\\n\tassert(hv); assert(indexp)\n#endif\n#if defined(PERL_IN_LOCALE_C)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE const char *\tS_save_to_buffer(const char * string, char **buf, Size_t *buf_size, const Size_t offset)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SAVE_TO_BUFFER\t\\\n\tassert(buf_size)\n#endif\n\n#  if defined(USE_LOCALE)\nSTATIC const char*\tS_category_name(const int category);\nSTATIC void\tS_new_collate(pTHX_ const char* newcoll);\nSTATIC void\tS_new_ctype(pTHX_ const char* newctype);\n#define PERL_ARGS_ASSERT_NEW_CTYPE\t\\\n\tassert(newctype)\nSTATIC void\tS_new_numeric(pTHX_ const char* newnum);\nSTATIC void\tS_restore_switched_locale(pTHX_ const int category, const char * const original_locale);\nSTATIC void\tS_set_numeric_radix(pTHX_ const bool use_locale);\nSTATIC char*\tS_stdize_locale(pTHX_ char* locs);\n#define PERL_ARGS_ASSERT_STDIZE_LOCALE\t\\\n\tassert(locs)\nSTATIC const char*\tS_switch_category_locale_to_template(pTHX_ const int switch_category, const int template_category, const char * template_locale);\n#    if defined(USE_POSIX_2008_LOCALE)\nSTATIC const char*\tS_emulate_setlocale(const int category, const char* locale, unsigned int index, const bool is_index_valid);\n#    endif\n#    if defined(WIN32)\nSTATIC char*\tS_win32_setlocale(pTHX_ int category, const char* locale);\n#    endif\n#  endif\n#endif\n#if defined(PERL_IN_LOCALE_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_MATHOMS_C)\n#  if defined(USE_LOCALE_COLLATE)\nPERL_CALLCONV char*\tPerl__mem_collxfrm(pTHX_ const char* input_string, STRLEN len, STRLEN* xlen, bool utf8);\n#define PERL_ARGS_ASSERT__MEM_COLLXFRM\t\\\n\tassert(input_string); assert(xlen)\n#  endif\n#endif\n#if defined(PERL_IN_MALLOC_C)\nSTATIC int\tS_adjust_size_and_find_bucket(size_t *nbytes_p);\n#define PERL_ARGS_ASSERT_ADJUST_SIZE_AND_FIND_BUCKET\t\\\n\tassert(nbytes_p)\n#endif\n#if defined(PERL_IN_MG_C)\nSTATIC void\tS_fixup_errno_string(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_FIXUP_ERRNO_STRING\t\\\n\tassert(sv)\nSTATIC SV*\tS_magic_methcall1(pTHX_ SV *sv, const MAGIC *mg, SV *meth, U32 flags, int n, SV *val);\n#define PERL_ARGS_ASSERT_MAGIC_METHCALL1\t\\\n\tassert(sv); assert(mg); assert(meth)\nSTATIC int\tS_magic_methpack(pTHX_ SV *sv, const MAGIC *mg, SV *meth);\n#define PERL_ARGS_ASSERT_MAGIC_METHPACK\t\\\n\tassert(sv); assert(mg); assert(meth)\nSTATIC void\tS_restore_magic(pTHX_ const void *p);\nSTATIC void\tS_save_magic_flags(pTHX_ I32 mgs_ix, SV *sv, U32 flags);\n#define PERL_ARGS_ASSERT_SAVE_MAGIC_FLAGS\t\\\n\tassert(sv)\nSTATIC void\tS_unwind_handler_stack(pTHX_ const void *p);\n#endif\n#if defined(PERL_IN_MG_C) || defined(PERL_IN_PP_C)\nPERL_CALLCONV bool\tPerl_translate_substr_offsets(STRLEN curlen, IV pos1_iv, bool pos1_is_uv, IV len_iv, bool len_is_uv, STRLEN *posp, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_TRANSLATE_SUBSTR_OFFSETS\t\\\n\tassert(posp); assert(lenp)\n#endif\n#if defined(PERL_IN_MRO_C)\nSTATIC void\tS_mro_clean_isarev(pTHX_ HV * const isa, const char * const name, const STRLEN len, HV * const exceptions, U32 hash, U32 flags);\n#define PERL_ARGS_ASSERT_MRO_CLEAN_ISAREV\t\\\n\tassert(isa); assert(name)\nSTATIC void\tS_mro_gather_and_rename(pTHX_ HV * const stashes, HV * const seen_stashes, HV *stash, HV *oldstash, SV *namesv);\n#define PERL_ARGS_ASSERT_MRO_GATHER_AND_RENAME\t\\\n\tassert(stashes); assert(seen_stashes); assert(namesv)\nSTATIC AV*\tS_mro_get_linear_isa_dfs(pTHX_ HV* stash, U32 level);\n#define PERL_ARGS_ASSERT_MRO_GET_LINEAR_ISA_DFS\t\\\n\tassert(stash)\n#endif\n#if defined(PERL_IN_OP_C)\nSTATIC void\tS_apply_attrs(pTHX_ HV *stash, SV *target, OP *attrs);\n#define PERL_ARGS_ASSERT_APPLY_ATTRS\t\\\n\tassert(stash); assert(target)\nSTATIC void\tS_apply_attrs_my(pTHX_ HV *stash, OP *target, OP *attrs, OP **imopsp);\n#define PERL_ARGS_ASSERT_APPLY_ATTRS_MY\t\\\n\tassert(stash); assert(target); assert(imopsp)\nSTATIC I32\tS_assignment_type(pTHX_ const OP *o)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC void\tS_bad_type_gv(pTHX_ I32 n, GV *gv, const OP *kid, const char *t);\n#define PERL_ARGS_ASSERT_BAD_TYPE_GV\t\\\n\tassert(gv); assert(kid); assert(t)\nSTATIC void\tS_bad_type_pv(pTHX_ I32 n, const char *t, const OP *o, const OP *kid);\n#define PERL_ARGS_ASSERT_BAD_TYPE_PV\t\\\n\tassert(t); assert(o); assert(kid)\nSTATIC void\tS_clear_special_blocks(pTHX_ const char *const fullname, GV *const gv, CV *const cv);\n#define PERL_ARGS_ASSERT_CLEAR_SPECIAL_BLOCKS\t\\\n\tassert(fullname); assert(gv); assert(cv)\nSTATIC void\tS_cop_free(pTHX_ COP *cop);\n#define PERL_ARGS_ASSERT_COP_FREE\t\\\n\tassert(cop)\nSTATIC OP *\tS_dup_attrlist(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_DUP_ATTRLIST\t\\\n\tassert(o)\nSTATIC void\tS_finalize_op(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_FINALIZE_OP\t\\\n\tassert(o)\nSTATIC void\tS_find_and_forget_pmops(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_FIND_AND_FORGET_PMOPS\t\\\n\tassert(o)\nSTATIC OP*\tS_fold_constants(pTHX_ OP * const o);\n#define PERL_ARGS_ASSERT_FOLD_CONSTANTS\t\\\n\tassert(o)\nSTATIC OP*\tS_force_list(pTHX_ OP* arg, bool nullit);\nSTATIC void\tS_forget_pmop(pTHX_ PMOP *const o);\n#define PERL_ARGS_ASSERT_FORGET_PMOP\t\\\n\tassert(o)\nSTATIC OP*\tS_gen_constant_list(pTHX_ OP* o);\nSTATIC void\tS_inplace_aassign(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_INPLACE_AASSIGN\t\\\n\tassert(o)\nSTATIC bool\tS_is_handle_constructor(const OP *o, I32 numargs)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_HANDLE_CONSTRUCTOR\t\\\n\tassert(o)\n\nSTATIC OP*\tS_listkids(pTHX_ OP* o);\nSTATIC bool\tS_looks_like_bool(pTHX_ const OP* o);\n#define PERL_ARGS_ASSERT_LOOKS_LIKE_BOOL\t\\\n\tassert(o)\nSTATIC OP*\tS_modkids(pTHX_ OP *o, I32 type);\nSTATIC void\tS_move_proto_attr(pTHX_ OP **proto, OP **attrs, const GV *name, bool curstash);\n#define PERL_ARGS_ASSERT_MOVE_PROTO_ATTR\t\\\n\tassert(proto); assert(attrs); assert(name)\nSTATIC OP *\tS_my_kid(pTHX_ OP *o, OP *attrs, OP **imopsp);\n#define PERL_ARGS_ASSERT_MY_KID\t\\\n\tassert(imopsp)\nSTATIC OP*\tS_newGIVWHENOP(pTHX_ OP* cond, OP *block, I32 enter_opcode, I32 leave_opcode, PADOFFSET entertarg);\n#define PERL_ARGS_ASSERT_NEWGIVWHENOP\t\\\n\tassert(block)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE OP*\tS_newMETHOP_internal(pTHX_ I32 type, I32 flags, OP* dynamic_meth, SV* const_meth);\n#endif\nSTATIC OP*\tS_new_logop(pTHX_ I32 type, I32 flags, OP **firstp, OP **otherp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEW_LOGOP\t\\\n\tassert(firstp); assert(otherp)\n\nSTATIC void\tS_no_bareword_allowed(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_NO_BAREWORD_ALLOWED\t\\\n\tassert(o)\nSTATIC OP*\tS_no_fh_allowed(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NO_FH_ALLOWED\t\\\n\tassert(o)\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE OP*\tS_op_integerize(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_OP_INTEGERIZE\t\\\n\tassert(o)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE OP*\tS_op_std_init(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_OP_STD_INIT\t\\\n\tassert(o)\n#endif\nSTATIC void\tS_optimize_op(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_OPTIMIZE_OP\t\\\n\tassert(o)\nSTATIC OP*\tS_pmtrans(pTHX_ OP* o, OP* expr, OP* repl);\n#define PERL_ARGS_ASSERT_PMTRANS\t\\\n\tassert(o); assert(expr); assert(repl)\nSTATIC bool\tS_process_special_blocks(pTHX_ I32 floor, const char *const fullname, GV *const gv, CV *const cv);\n#define PERL_ARGS_ASSERT_PROCESS_SPECIAL_BLOCKS\t\\\n\tassert(fullname); assert(gv); assert(cv)\nSTATIC OP*\tS_ref_array_or_hash(pTHX_ OP* cond);\nSTATIC OP*\tS_refkids(pTHX_ OP* o, I32 type);\nSTATIC bool\tS_scalar_mod_type(const OP *o, I32 type)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC OP*\tS_scalarboolean(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_SCALARBOOLEAN\t\\\n\tassert(o)\nSTATIC OP*\tS_scalarkids(pTHX_ OP* o);\nSTATIC OP*\tS_scalarseq(pTHX_ OP* o);\nSTATIC OP*\tS_search_const(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SEARCH_CONST\t\\\n\tassert(o)\n\nSTATIC void\tS_simplify_sort(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_SIMPLIFY_SORT\t\\\n\tassert(o)\nSTATIC OP*\tS_too_few_arguments_pv(pTHX_ OP *o, const char* name, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_TOO_FEW_ARGUMENTS_PV\t\\\n\tassert(o); assert(name)\n\nSTATIC OP*\tS_too_many_arguments_pv(pTHX_ OP *o, const char* name, U32 flags);\n#define PERL_ARGS_ASSERT_TOO_MANY_ARGUMENTS_PV\t\\\n\tassert(o); assert(name)\nSTATIC OP*\tS_traverse_op_tree(pTHX_ OP* top, OP* o);\n#define PERL_ARGS_ASSERT_TRAVERSE_OP_TREE\t\\\n\tassert(top); assert(o)\n#  if defined(USE_ITHREADS)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_op_relocate_sv(pTHX_ SV** svp, PADOFFSET* targp);\n#define PERL_ARGS_ASSERT_OP_RELOCATE_SV\t\\\n\tassert(svp); assert(targp)\n#endif\n#  endif\n#endif\n#if defined(PERL_IN_OP_C) || defined(PERL_IN_SV_C)\nPERL_CALLCONV void\tPerl_report_redefined_cv(pTHX_ const SV *name, const CV *old_cv, SV * const *new_const_svp);\n#define PERL_ARGS_ASSERT_REPORT_REDEFINED_CV\t\\\n\tassert(name); assert(old_cv)\n#endif\n#if defined(PERL_IN_PAD_C)\nSTATIC PADOFFSET\tS_pad_alloc_name(pTHX_ PADNAME *name, U32 flags, HV *typestash, HV *ourstash);\n#define PERL_ARGS_ASSERT_PAD_ALLOC_NAME\t\\\n\tassert(name)\nSTATIC void\tS_pad_check_dup(pTHX_ PADNAME *name, U32 flags, const HV *ourstash);\n#define PERL_ARGS_ASSERT_PAD_CHECK_DUP\t\\\n\tassert(name)\nSTATIC PADOFFSET\tS_pad_findlex(pTHX_ const char *namepv, STRLEN namelen, U32 flags, const CV* cv, U32 seq, int warn, SV** out_capture, PADNAME** out_name, int *out_flags);\n#define PERL_ARGS_ASSERT_PAD_FINDLEX\t\\\n\tassert(namepv); assert(cv); assert(out_name); assert(out_flags)\nSTATIC void\tS_pad_reset(pTHX);\n#endif\n#if defined(PERL_IN_PERL_C)\nSTATIC void\tS_find_beginning(pTHX_ SV* linestr_sv, PerlIO *rsfp);\n#define PERL_ARGS_ASSERT_FIND_BEGINNING\t\\\n\tassert(linestr_sv); assert(rsfp)\nSTATIC void\tS_forbid_setid(pTHX_ const char flag, const bool suidscript);\nSTATIC void\tS_incpush(pTHX_ const char *const dir, STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_INCPUSH\t\\\n\tassert(dir)\nSTATIC void\tS_incpush_use_sep(pTHX_ const char *p, STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_INCPUSH_USE_SEP\t\\\n\tassert(p)\nSTATIC void\tS_init_ids(pTHX);\nSTATIC void\tS_init_interp(pTHX);\nSTATIC void\tS_init_main_stash(pTHX);\nSTATIC void\tS_init_perllib(pTHX);\nSTATIC void\tS_init_postdump_symbols(pTHX_ int argc, char **argv, char **env);\n#define PERL_ARGS_ASSERT_INIT_POSTDUMP_SYMBOLS\t\\\n\tassert(argv)\nSTATIC void\tS_init_predump_symbols(pTHX);\nSTATIC SV*\tS_mayberelocate(pTHX_ const char *const dir, STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_MAYBERELOCATE\t\\\n\tassert(dir)\nPERL_STATIC_NO_RET void\tS_minus_v(pTHX)\n\t\t\t__attribute__noreturn__;\n\nPERL_STATIC_NO_RET void\tS_my_exit_jump(pTHX)\n\t\t\t__attribute__noreturn__;\n\nSTATIC void\tS_nuke_stacks(pTHX);\nSTATIC PerlIO *\tS_open_script(pTHX_ const char *scriptname, bool dosearch, bool *suidscript);\n#define PERL_ARGS_ASSERT_OPEN_SCRIPT\t\\\n\tassert(scriptname); assert(suidscript)\nSTATIC void*\tS_parse_body(pTHX_ char **env, XSINIT_t xsinit);\nPERL_STATIC_NO_RET void\tS_run_body(pTHX_ I32 oldscope)\n\t\t\t__attribute__noreturn__;\n\nPERL_STATIC_NO_RET void\tS_usage(pTHX)\n\t\t\t__attribute__noreturn__;\n\n#endif\n#if defined(PERL_IN_PP_C)\nSTATIC size_t\tS_do_chomp(pTHX_ SV *retval, SV *sv, bool chomping);\n#define PERL_ARGS_ASSERT_DO_CHOMP\t\\\n\tassert(retval); assert(sv)\nSTATIC OP*\tS_do_delete_local(pTHX);\nSTATIC SV*\tS_refto(pTHX_ SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REFTO\t\\\n\tassert(sv)\n\n#endif\n#if defined(PERL_IN_PP_C) || defined(PERL_IN_PP_HOT_C)\nPERL_CALLCONV GV*\tPerl_softref2xv(pTHX_ SV *const sv, const char *const what, const svtype type, SV ***spp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SOFTREF2XV\t\\\n\tassert(sv); assert(what); assert(spp)\n\n#endif\n#if defined(PERL_IN_PP_CTL_C)\nSTATIC PerlIO *\tS_check_type_and_open(pTHX_ SV *name)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CHECK_TYPE_AND_OPEN\t\\\n\tassert(name)\n\nSTATIC void\tS_destroy_matcher(pTHX_ PMOP* matcher);\n#define PERL_ARGS_ASSERT_DESTROY_MATCHER\t\\\n\tassert(matcher)\nSTATIC OP*\tS_do_smartmatch(pTHX_ HV* seen_this, HV* seen_other, const bool copied);\nSTATIC OP*\tS_docatch(pTHX_ Perl_ppaddr_t firstpp)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC bool\tS_doeval_compile(pTHX_ U8 gimme, CV* outside, U32 seq, HV* hh);\nSTATIC OP*\tS_dofindlabel(pTHX_ OP *o, const char *label, STRLEN len, U32 flags, OP **opstack, OP **oplimit)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DOFINDLABEL\t\\\n\tassert(o); assert(label); assert(opstack); assert(oplimit)\n\nSTATIC MAGIC *\tS_doparseform(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_DOPARSEFORM\t\\\n\tassert(sv)\nSTATIC I32\tS_dopoptoeval(pTHX_ I32 startingblock)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC I32\tS_dopoptogivenfor(pTHX_ I32 startingblock)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC I32\tS_dopoptolabel(pTHX_ const char *label, STRLEN len, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DOPOPTOLABEL\t\\\n\tassert(label)\n\nSTATIC I32\tS_dopoptoloop(pTHX_ I32 startingblock)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC I32\tS_dopoptosub_at(pTHX_ const PERL_CONTEXT* cxstk, I32 startingblock)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DOPOPTOSUB_AT\t\\\n\tassert(cxstk)\n\nSTATIC I32\tS_dopoptowhen(pTHX_ I32 startingblock)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC PMOP*\tS_make_matcher(pTHX_ REGEXP* re)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MAKE_MATCHER\t\\\n\tassert(re)\n\nSTATIC bool\tS_matcher_matches_sv(pTHX_ PMOP* matcher, SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MATCHER_MATCHES_SV\t\\\n\tassert(matcher); assert(sv)\n\nSTATIC bool\tS_num_overflow(NV value, I32 fldsize, I32 frcsize)\n\t\t\t__attribute__warn_unused_result__;\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_path_is_searchable(const char *name)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PATH_IS_SEARCHABLE\t\\\n\tassert(name)\n#endif\n\nSTATIC I32\tS_run_user_filter(pTHX_ int idx, SV *buf_sv, int maxlen)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_RUN_USER_FILTER\t\\\n\tassert(buf_sv)\n\nSTATIC void\tS_rxres_free(pTHX_ void** rsp);\n#define PERL_ARGS_ASSERT_RXRES_FREE\t\\\n\tassert(rsp)\nSTATIC void\tS_rxres_restore(pTHX_ void **rsp, REGEXP *rx);\n#define PERL_ARGS_ASSERT_RXRES_RESTORE\t\\\n\tassert(rsp); assert(rx)\nSTATIC void\tS_save_lines(pTHX_ AV *array, SV *sv);\n#define PERL_ARGS_ASSERT_SAVE_LINES\t\\\n\tassert(sv)\n#endif\n#if defined(PERL_IN_PP_HOT_C)\nSTATIC void\tS_do_oddball(pTHX_ SV **oddkey, SV **firstkey);\n#define PERL_ARGS_ASSERT_DO_ODDBALL\t\\\n\tassert(oddkey); assert(firstkey)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE HV*\tS_opmethod_stash(pTHX_ SV* meth);\n#define PERL_ARGS_ASSERT_OPMETHOD_STASH\t\\\n\tassert(meth)\n#endif\n#endif\n#if defined(PERL_IN_PP_PACK_C)\nSTATIC int\tS_div128(pTHX_ SV *pnum, bool *done);\n#define PERL_ARGS_ASSERT_DIV128\t\\\n\tassert(pnum); assert(done)\nSTATIC char\tS_first_symbol(const char *pat, const char *patend);\n#define PERL_ARGS_ASSERT_FIRST_SYMBOL\t\\\n\tassert(pat); assert(patend)\nSTATIC const char *\tS_get_num(pTHX_ const char *patptr, SSize_t *lenptr)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_NUM\t\\\n\tassert(patptr); assert(lenptr)\n\nSTATIC const char *\tS_group_end(pTHX_ const char *patptr, const char *patend, char ender);\n#define PERL_ARGS_ASSERT_GROUP_END\t\\\n\tassert(patptr); assert(patend)\nSTATIC SV*\tS_is_an_int(pTHX_ const char *s, STRLEN l)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_AN_INT\t\\\n\tassert(s)\n\nSTATIC SSize_t\tS_measure_struct(pTHX_ struct tempsym* symptr);\n#define PERL_ARGS_ASSERT_MEASURE_STRUCT\t\\\n\tassert(symptr)\nSTATIC SV*\tS_mul128(pTHX_ SV *sv, U8 m);\n#define PERL_ARGS_ASSERT_MUL128\t\\\n\tassert(sv)\nSTATIC char *\tS_my_bytes_to_utf8(const U8 *start, STRLEN len, char *dest, const bool needs_swap)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MY_BYTES_TO_UTF8\t\\\n\tassert(start); assert(dest)\n\nSTATIC bool\tS_need_utf8(const char *pat, const char *patend);\n#define PERL_ARGS_ASSERT_NEED_UTF8\t\\\n\tassert(pat); assert(patend)\nSTATIC bool\tS_next_symbol(pTHX_ struct tempsym* symptr);\n#define PERL_ARGS_ASSERT_NEXT_SYMBOL\t\\\n\tassert(symptr)\nSTATIC SV **\tS_pack_rec(pTHX_ SV *cat, struct tempsym* symptr, SV **beglist, SV **endlist);\n#define PERL_ARGS_ASSERT_PACK_REC\t\\\n\tassert(cat); assert(symptr); assert(beglist); assert(endlist)\nSTATIC char *\tS_sv_exp_grow(pTHX_ SV *sv, STRLEN needed)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_EXP_GROW\t\\\n\tassert(sv)\n\nSTATIC SSize_t\tS_unpack_rec(pTHX_ struct tempsym* symptr, const char *s, const char *strbeg, const char *strend, const char **new_s);\n#define PERL_ARGS_ASSERT_UNPACK_REC\t\\\n\tassert(symptr); assert(s); assert(strbeg); assert(strend)\n#endif\n#if defined(PERL_IN_PP_SORT_C)\nSTATIC I32\tS_amagic_cmp(pTHX_ SV *const str1, SV *const str2);\n#define PERL_ARGS_ASSERT_AMAGIC_CMP\t\\\n\tassert(str1); assert(str2)\nSTATIC I32\tS_amagic_i_ncmp(pTHX_ SV *const a, SV *const b);\n#define PERL_ARGS_ASSERT_AMAGIC_I_NCMP\t\\\n\tassert(a); assert(b)\nSTATIC I32\tS_amagic_ncmp(pTHX_ SV *const a, SV *const b);\n#define PERL_ARGS_ASSERT_AMAGIC_NCMP\t\\\n\tassert(a); assert(b)\nSTATIC I32\tS_sortcv(pTHX_ SV *const a, SV *const b);\n#define PERL_ARGS_ASSERT_SORTCV\t\\\n\tassert(a); assert(b)\nSTATIC I32\tS_sortcv_stacked(pTHX_ SV *const a, SV *const b);\n#define PERL_ARGS_ASSERT_SORTCV_STACKED\t\\\n\tassert(a); assert(b)\nSTATIC I32\tS_sortcv_xsub(pTHX_ SV *const a, SV *const b);\n#define PERL_ARGS_ASSERT_SORTCV_XSUB\t\\\n\tassert(a); assert(b)\nSTATIC I32\tS_sv_i_ncmp(pTHX_ SV *const a, SV *const b);\n#define PERL_ARGS_ASSERT_SV_I_NCMP\t\\\n\tassert(a); assert(b)\nSTATIC I32\tS_sv_ncmp(pTHX_ SV *const a, SV *const b);\n#define PERL_ARGS_ASSERT_SV_NCMP\t\\\n\tassert(a); assert(b)\n#  if defined(USE_LOCALE_COLLATE)\nSTATIC I32\tS_amagic_cmp_locale(pTHX_ SV *const str1, SV *const str2);\n#define PERL_ARGS_ASSERT_AMAGIC_CMP_LOCALE\t\\\n\tassert(str1); assert(str2)\n#  endif\n#endif\n#if defined(PERL_IN_PP_SYS_C)\nSTATIC OP*\tS_doform(pTHX_ CV *cv, GV *gv, OP *retop);\n#define PERL_ARGS_ASSERT_DOFORM\t\\\n\tassert(cv); assert(gv)\nSTATIC SV *\tS_space_join_names_mortal(pTHX_ char *const *array);\n#endif\n#if defined(PERL_IN_REGCOMP_C)\nSTATIC SV*\tS__make_exactf_invlist(pTHX_ RExC_state_t *pRExC_state, regnode *node)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__MAKE_EXACTF_INVLIST\t\\\n\tassert(pRExC_state); assert(node)\n\nSTATIC void\tS_add_above_Latin1_folds(pTHX_ RExC_state_t *pRExC_state, const U8 cp, SV** invlist);\n#define PERL_ARGS_ASSERT_ADD_ABOVE_LATIN1_FOLDS\t\\\n\tassert(pRExC_state); assert(invlist)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE SV*\tS_add_cp_to_invlist(pTHX_ SV* invlist, const UV cp)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nSTATIC U32\tS_add_data(RExC_state_t* const pRExC_state, const char* const s, const U32 n)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ADD_DATA\t\\\n\tassert(pRExC_state); assert(s)\n\nSTATIC AV*\tS_add_multi_match(pTHX_ AV* multi_char_matches, SV* multi_string, const STRLEN cp_count);\n#define PERL_ARGS_ASSERT_ADD_MULTI_MATCH\t\\\n\tassert(multi_string)\nSTATIC void\tS_change_engine_size(pTHX_ RExC_state_t *pRExC_state, const Ptrdiff_t size);\n#define PERL_ARGS_ASSERT_CHANGE_ENGINE_SIZE\t\\\n\tassert(pRExC_state)\nSTATIC const char *\tS_cntrl_to_mnemonic(const U8 c)\n\t\t\t__attribute__warn_unused_result__;\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE U8\tS_compute_EXACTish(RExC_state_t *pRExC_state);\n#define PERL_ARGS_ASSERT_COMPUTE_EXACTISH\t\\\n\tassert(pRExC_state)\n#endif\nSTATIC regnode *\tS_construct_ahocorasick_from_trie(pTHX_ RExC_state_t *pRExC_state, regnode *source, U32 depth);\n#define PERL_ARGS_ASSERT_CONSTRUCT_AHOCORASICK_FROM_TRIE\t\\\n\tassert(pRExC_state); assert(source)\nSTATIC int\tS_edit_distance(const UV *src, const UV *tgt, const STRLEN x, const STRLEN y, const SSize_t maxDistance)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_EDIT_DISTANCE\t\\\n\tassert(src); assert(tgt)\n\nSTATIC SV *\tS_get_ANYOFM_contents(pTHX_ const regnode * n)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_ANYOFM_CONTENTS\t\\\n\tassert(n)\n\nSTATIC SV*\tS_get_ANYOF_cp_list_for_ssc(pTHX_ const RExC_state_t *pRExC_state, const regnode_charclass* const node);\n#define PERL_ARGS_ASSERT_GET_ANYOF_CP_LIST_FOR_SSC\t\\\n\tassert(pRExC_state); assert(node)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE STRLEN*\tS_get_invlist_iter_addr(SV* invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_INVLIST_ITER_ADDR\t\\\n\tassert(invlist)\n#endif\n\nSTATIC bool\tS_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state, regnode_offset* nodep, UV *code_point_p, int* cp_count, I32 *flagp, const bool strict, const U32 depth);\n#define PERL_ARGS_ASSERT_GROK_BSLASH_N\t\\\n\tassert(pRExC_state); assert(flagp)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE regnode_offset\tS_handle_named_backref(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, char * parse_start, char ch);\n#define PERL_ARGS_ASSERT_HANDLE_NAMED_BACKREF\t\\\n\tassert(pRExC_state); assert(flagp); assert(parse_start)\n#endif\nSTATIC int\tS_handle_possible_posix(pTHX_ RExC_state_t *pRExC_state, const char* const s, char ** updated_parse_ptr, AV** posix_warnings, const bool check_only);\n#define PERL_ARGS_ASSERT_HANDLE_POSSIBLE_POSIX\t\\\n\tassert(pRExC_state); assert(s)\nSTATIC regnode_offset\tS_handle_regex_sets(pTHX_ RExC_state_t *pRExC_state, SV ** return_invlist, I32 *flagp, U32 depth, char * const oregcomp_parse);\n#define PERL_ARGS_ASSERT_HANDLE_REGEX_SETS\t\\\n\tassert(pRExC_state); assert(flagp); assert(oregcomp_parse)\nPERL_CALLCONV SV *\tPerl_handle_user_defined_property(pTHX_ const char * name, const STRLEN name_len, const bool is_utf8, const bool to_fold, const bool runtime, const bool deferrable, SV* contents, bool *user_defined_ptr, SV * msg, const STRLEN level);\n#define PERL_ARGS_ASSERT_HANDLE_USER_DEFINED_PROPERTY\t\\\n\tassert(name); assert(contents); assert(user_defined_ptr); assert(msg)\nSTATIC SV*\tS_invlist_contents(pTHX_ SV* const invlist, const bool traditional_style)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_INVLIST_CONTENTS\t\\\n\tassert(invlist)\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE UV\tS_invlist_highest(SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_INVLIST_HIGHEST\t\\\n\tassert(invlist)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_invlist_is_iterating(SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_INVLIST_IS_ITERATING\t\\\n\tassert(invlist)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_invlist_iterfinish(SV* invlist);\n#define PERL_ARGS_ASSERT_INVLIST_ITERFINISH\t\\\n\tassert(invlist)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_invlist_iterinit(SV* invlist);\n#define PERL_ARGS_ASSERT_INVLIST_ITERINIT\t\\\n\tassert(invlist)\n#endif\nSTATIC bool\tS_invlist_iternext(SV* invlist, UV* start, UV* end)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_INVLIST_ITERNEXT\t\\\n\tassert(invlist); assert(start); assert(end)\n\nSTATIC bool\tS_is_ssc_worth_it(const RExC_state_t * pRExC_state, const regnode_ssc * ssc);\n#define PERL_ARGS_ASSERT_IS_SSC_WORTH_IT\t\\\n\tassert(pRExC_state); assert(ssc)\nSTATIC U32\tS_join_exact(pTHX_ RExC_state_t *pRExC_state, regnode *scan, UV *min_subtract, bool *unfolded_multi_char, U32 flags, regnode *val, U32 depth);\n#define PERL_ARGS_ASSERT_JOIN_EXACT\t\\\n\tassert(pRExC_state); assert(scan); assert(min_subtract); assert(unfolded_multi_char)\nSTATIC I32\tS_make_trie(pTHX_ RExC_state_t *pRExC_state, regnode *startbranch, regnode *first, regnode *last, regnode *tail, U32 word_count, U32 flags, U32 depth);\n#define PERL_ARGS_ASSERT_MAKE_TRIE\t\\\n\tassert(pRExC_state); assert(startbranch); assert(first); assert(last); assert(tail)\nSTATIC bool\tS_new_regcurly(const char *s, const char *e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEW_REGCURLY\t\\\n\tassert(s); assert(e)\n\nSTATIC void\tS_nextchar(pTHX_ RExC_state_t *pRExC_state);\n#define PERL_ARGS_ASSERT_NEXTCHAR\t\\\n\tassert(pRExC_state)\nSTATIC void\tS_output_posix_warnings(pTHX_ RExC_state_t *pRExC_state, AV* posix_warnings);\n#define PERL_ARGS_ASSERT_OUTPUT_POSIX_WARNINGS\t\\\n\tassert(pRExC_state); assert(posix_warnings)\nSTATIC void\tS_parse_lparen_question_flags(pTHX_ RExC_state_t *pRExC_state);\n#define PERL_ARGS_ASSERT_PARSE_LPAREN_QUESTION_FLAGS\t\\\n\tassert(pRExC_state)\nPERL_CALLCONV SV *\tPerl_parse_uniprop_string(pTHX_ const char * const name, const Size_t name_len, const bool is_utf8, const bool to_fold, const bool runtime, const bool deferrable, bool * user_defined_ptr, SV * msg, const STRLEN level);\n#define PERL_ARGS_ASSERT_PARSE_UNIPROP_STRING\t\\\n\tassert(name); assert(user_defined_ptr); assert(msg)\nSTATIC void\tS_populate_ANYOF_from_invlist(pTHX_ regnode *node, SV** invlist_ptr);\n#define PERL_ARGS_ASSERT_POPULATE_ANYOF_FROM_INVLIST\t\\\n\tassert(node); assert(invlist_ptr)\nSTATIC void\tS_rck_elide_nothing(pTHX_ regnode *node);\n#define PERL_ARGS_ASSERT_RCK_ELIDE_NOTHING\t\\\n\tassert(node)\nPERL_STATIC_NO_RET void\tS_re_croak2(pTHX_ bool utf8, const char* pat1, const char* pat2, ...)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_RE_CROAK2\t\\\n\tassert(pat1); assert(pat2)\n\nSTATIC regnode_offset\tS_reg(pTHX_ RExC_state_t *pRExC_state, I32 paren, I32 *flagp, U32 depth);\n#define PERL_ARGS_ASSERT_REG\t\\\n\tassert(pRExC_state); assert(flagp)\nSTATIC regnode_offset\tS_reg2Lanode(pTHX_ RExC_state_t *pRExC_state, const U8 op, const U32 arg1, const I32 arg2);\n#define PERL_ARGS_ASSERT_REG2LANODE\t\\\n\tassert(pRExC_state)\nSTATIC regnode_offset\tS_reg_node(pTHX_ RExC_state_t *pRExC_state, U8 op);\n#define PERL_ARGS_ASSERT_REG_NODE\t\\\n\tassert(pRExC_state)\nSTATIC SV *\tS_reg_scan_name(pTHX_ RExC_state_t *pRExC_state, U32 flags);\n#define PERL_ARGS_ASSERT_REG_SCAN_NAME\t\\\n\tassert(pRExC_state)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE char *\tS_reg_skipcomment(RExC_state_t *pRExC_state, char * p);\n#define PERL_ARGS_ASSERT_REG_SKIPCOMMENT\t\\\n\tassert(pRExC_state); assert(p)\n#endif\nSTATIC regnode_offset\tS_reganode(pTHX_ RExC_state_t *pRExC_state, U8 op, U32 arg);\n#define PERL_ARGS_ASSERT_REGANODE\t\\\n\tassert(pRExC_state)\nSTATIC regnode_offset\tS_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth);\n#define PERL_ARGS_ASSERT_REGATOM\t\\\n\tassert(pRExC_state); assert(flagp)\nSTATIC regnode_offset\tS_regbranch(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, I32 first, U32 depth);\n#define PERL_ARGS_ASSERT_REGBRANCH\t\\\n\tassert(pRExC_state); assert(flagp)\nSTATIC regnode_offset\tS_regclass(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth, const bool stop_at_1, bool allow_multi_fold, const bool silence_non_portable, const bool strict, bool optimizable, SV** ret_invlist);\n#define PERL_ARGS_ASSERT_REGCLASS\t\\\n\tassert(pRExC_state); assert(flagp)\nSTATIC unsigned int\tS_regex_set_precedence(const U8 my_operator)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC void\tS_reginsert(pTHX_ RExC_state_t *pRExC_state, const U8 op, const regnode_offset operand, const U32 depth);\n#define PERL_ARGS_ASSERT_REGINSERT\t\\\n\tassert(pRExC_state)\nSTATIC regnode_offset\tS_regnode_guts(pTHX_ RExC_state_t *pRExC_state, const U8 op, const STRLEN extra_len, const char* const name);\n#define PERL_ARGS_ASSERT_REGNODE_GUTS\t\\\n\tassert(pRExC_state); assert(name)\nSTATIC regnode_offset\tS_regpiece(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth);\n#define PERL_ARGS_ASSERT_REGPIECE\t\\\n\tassert(pRExC_state); assert(flagp)\nSTATIC bool\tS_regtail(pTHX_ RExC_state_t * pRExC_state, const regnode_offset p, const regnode_offset val, const U32 depth)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGTAIL\t\\\n\tassert(pRExC_state); assert(p); assert(val)\n\nSTATIC void\tS_scan_commit(pTHX_ const RExC_state_t *pRExC_state, struct scan_data_t *data, SSize_t *minlenp, int is_inf);\n#define PERL_ARGS_ASSERT_SCAN_COMMIT\t\\\n\tassert(pRExC_state); assert(data); assert(minlenp)\nSTATIC void\tS_set_ANYOF_arg(pTHX_ RExC_state_t* const pRExC_state, regnode* const node, SV* const cp_list, SV* const runtime_defns, SV* const only_utf8_locale_list);\n#define PERL_ARGS_ASSERT_SET_ANYOF_ARG\t\\\n\tassert(pRExC_state); assert(node)\nSTATIC void\tS_set_regex_pv(pTHX_ RExC_state_t *pRExC_state, REGEXP *Rx);\n#define PERL_ARGS_ASSERT_SET_REGEX_PV\t\\\n\tassert(pRExC_state); assert(Rx)\nSTATIC void\tS_skip_to_be_ignored_text(pTHX_ RExC_state_t *pRExC_state, char ** p, const bool force_to_xmod);\n#define PERL_ARGS_ASSERT_SKIP_TO_BE_IGNORED_TEXT\t\\\n\tassert(pRExC_state); assert(p)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_ssc_add_range(pTHX_ regnode_ssc *ssc, UV const start, UV const end);\n#define PERL_ARGS_ASSERT_SSC_ADD_RANGE\t\\\n\tassert(ssc)\n#endif\nSTATIC void\tS_ssc_and(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc, const regnode_charclass *and_with);\n#define PERL_ARGS_ASSERT_SSC_AND\t\\\n\tassert(pRExC_state); assert(ssc); assert(and_with)\nSTATIC void\tS_ssc_anything(pTHX_ regnode_ssc *ssc);\n#define PERL_ARGS_ASSERT_SSC_ANYTHING\t\\\n\tassert(ssc)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_ssc_clear_locale(regnode_ssc *ssc);\n#define PERL_ARGS_ASSERT_SSC_CLEAR_LOCALE\t\\\n\tassert(ssc)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_ssc_cp_and(pTHX_ regnode_ssc *ssc, UV const cp);\n#define PERL_ARGS_ASSERT_SSC_CP_AND\t\\\n\tassert(ssc)\n#endif\nSTATIC void\tS_ssc_finalize(pTHX_ RExC_state_t *pRExC_state, regnode_ssc *ssc);\n#define PERL_ARGS_ASSERT_SSC_FINALIZE\t\\\n\tassert(pRExC_state); assert(ssc)\nSTATIC void\tS_ssc_init(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc);\n#define PERL_ARGS_ASSERT_SSC_INIT\t\\\n\tassert(pRExC_state); assert(ssc)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_ssc_intersection(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert_2nd);\n#define PERL_ARGS_ASSERT_SSC_INTERSECTION\t\\\n\tassert(ssc); assert(invlist)\n#endif\nSTATIC int\tS_ssc_is_anything(const regnode_ssc *ssc)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SSC_IS_ANYTHING\t\\\n\tassert(ssc)\n\nSTATIC int\tS_ssc_is_cp_posixl_init(const RExC_state_t *pRExC_state, const regnode_ssc *ssc)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SSC_IS_CP_POSIXL_INIT\t\\\n\tassert(pRExC_state); assert(ssc)\n\nSTATIC void\tS_ssc_or(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc, const regnode_charclass *or_with);\n#define PERL_ARGS_ASSERT_SSC_OR\t\\\n\tassert(pRExC_state); assert(ssc); assert(or_with)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_ssc_union(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert_2nd);\n#define PERL_ARGS_ASSERT_SSC_UNION\t\\\n\tassert(ssc); assert(invlist)\n#endif\nSTATIC SSize_t\tS_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp, SSize_t *minlenp, SSize_t *deltap, regnode *last, struct scan_data_t *data, I32 stopparen, U32 recursed_depth, regnode_ssc *and_withp, U32 flags, U32 depth);\n#define PERL_ARGS_ASSERT_STUDY_CHUNK\t\\\n\tassert(pRExC_state); assert(scanp); assert(minlenp); assert(deltap); assert(last)\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined (PERL_IN_DUMP_C)\nPERL_CALLCONV void\tPerl__invlist_dump(pTHX_ PerlIO *file, I32 level, const char* const indent, SV* const invlist);\n#define PERL_ARGS_ASSERT__INVLIST_DUMP\t\\\n\tassert(file); assert(indent); assert(invlist)\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_PERL_C) || defined(PERL_IN_UTF8_C)\nPERL_CALLCONV bool\tPerl__invlistEQ(pTHX_ SV* const a, SV* const b, const bool complement_b);\n#define PERL_ARGS_ASSERT__INVLISTEQ\t\\\n\tassert(a); assert(b)\nPERL_CALLCONV SV*\tPerl__new_invlist_C_array(pTHX_ const UV* const list)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__NEW_INVLIST_C_ARRAY\t\\\n\tassert(list)\n\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)\nPERL_CALLCONV SV*\tPerl__get_regclass_nonbitmap_data(pTHX_ const regexp *prog, const struct regnode *node, bool doinit, SV **listsvp, SV **lonly_utf8_locale, SV **output_invlist);\n#define PERL_ARGS_ASSERT__GET_REGCLASS_NONBITMAP_DATA\t\\\n\tassert(node)\nPERL_CALLCONV int\tPerl_re_printf(pTHX_ const char *fmt, ...);\n#define PERL_ARGS_ASSERT_RE_PRINTF\t\\\n\tassert(fmt)\nPERL_CALLCONV void\tPerl_regprop(pTHX_ const regexp *prog, SV* sv, const regnode* o, const regmatch_info *reginfo, const RExC_state_t *pRExC_state);\n#define PERL_ARGS_ASSERT_REGPROP\t\\\n\tassert(sv); assert(o)\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_TOKE_C) || defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS__invlist_contains_cp(SV* const invlist, const UV cp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__INVLIST_CONTAINS_CP\t\\\n\tassert(invlist)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE UV\tS__invlist_len(SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__INVLIST_LEN\t\\\n\tassert(invlist)\n#endif\n\nPERL_CALLCONV SSize_t\tPerl__invlist_search(SV* const invlist, const UV cp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__INVLIST_SEARCH\t\\\n\tassert(invlist)\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool*\tS_get_invlist_offset_addr(SV* invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_INVLIST_OFFSET_ADDR\t\\\n\tassert(invlist)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE UV*\tS_invlist_array(SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_INVLIST_ARRAY\t\\\n\tassert(invlist)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_invlist(SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_SV_C)\nPERL_CALLCONV SV*\tPerl_invlist_clone(pTHX_ SV* const invlist, SV* newlist);\n#define PERL_ARGS_ASSERT_INVLIST_CLONE\t\\\n\tassert(invlist)\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_TOKE_C) || defined(PERL_IN_DQUOTE_C)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE char*\tS_form_short_octal_warning(pTHX_ const char * const s, const STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FORM_SHORT_OCTAL_WARNING\t\\\n\tassert(s)\n#endif\n\nPERL_CALLCONV char\tPerl_grok_bslash_c(pTHX_ const char source, const bool output_warning)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl_grok_bslash_o(pTHX_ char** s, const char* const send, UV* uv, const char** error_msg, const bool output_warning, const bool strict, const bool silence_non_portable, const bool utf8)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GROK_BSLASH_O\t\\\n\tassert(s); assert(send); assert(uv); assert(error_msg)\n\nPERL_CALLCONV bool\tPerl_grok_bslash_x(pTHX_ char** s, const char* const send, UV* uv, const char** error_msg, const bool output_warning, const bool strict, const bool silence_non_portable, const bool utf8)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GROK_BSLASH_X\t\\\n\tassert(s); assert(send); assert(uv); assert(error_msg)\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE I32\tS_regcurly(const char *s)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGCURLY\t\\\n\tassert(s)\n#endif\n\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_UTF8_C)\nPERL_CALLCONV SV*\tPerl__add_range_to_invlist(pTHX_ SV* invlist, UV start, UV end)\n\t\t\t__attribute__warn_unused_result__;\n\n/* PERL_CALLCONV void\t_invlist_intersection(pTHX_ SV* const a, SV* const b, SV** i); */\nPERL_CALLCONV void\tPerl__invlist_intersection_maybe_complement_2nd(pTHX_ SV* const a, SV* const b, const bool complement_b, SV** i);\n#define PERL_ARGS_ASSERT__INVLIST_INTERSECTION_MAYBE_COMPLEMENT_2ND\t\\\n\tassert(b); assert(i)\nPERL_CALLCONV void\tPerl__invlist_invert(pTHX_ SV* const invlist);\n#define PERL_ARGS_ASSERT__INVLIST_INVERT\t\\\n\tassert(invlist)\n/* PERL_CALLCONV void\t_invlist_subtract(pTHX_ SV* const a, SV* const b, SV** result); */\n/* PERL_CALLCONV void\t_invlist_union(pTHX_ SV* const a, SV* const b, SV** output); */\nPERL_CALLCONV void\tPerl__invlist_union_maybe_complement_2nd(pTHX_ SV* const a, SV* const b, const bool complement_b, SV** output);\n#define PERL_ARGS_ASSERT__INVLIST_UNION_MAYBE_COMPLEMENT_2ND\t\\\n\tassert(b); assert(output)\nPERL_CALLCONV SV*\tPerl__new_invlist(pTHX_ IV initial_size)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl__setup_canned_invlist(pTHX_ const STRLEN size, const UV element0, UV** other_elements_ptr)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__SETUP_CANNED_INVLIST\t\\\n\tassert(other_elements_ptr)\n\n#endif\n#if defined(PERL_IN_REGEXEC_C)\nSTATIC LB_enum\tS_advance_one_LB(pTHX_ U8 ** curpos, const U8 * const strend, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ADVANCE_ONE_LB\t\\\n\tassert(curpos); assert(strend)\n\nSTATIC SB_enum\tS_advance_one_SB(pTHX_ U8 ** curpos, const U8 * const strend, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ADVANCE_ONE_SB\t\\\n\tassert(curpos); assert(strend)\n\nSTATIC WB_enum\tS_advance_one_WB(pTHX_ U8 ** curpos, const U8 * const strend, const bool utf8_target, const bool skip_Extend_Format)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ADVANCE_ONE_WB\t\\\n\tassert(curpos); assert(strend)\n\nSTATIC GCB_enum\tS_backup_one_GCB(pTHX_ const U8 * const strbeg, U8 ** curpos, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_BACKUP_ONE_GCB\t\\\n\tassert(strbeg); assert(curpos)\n\nSTATIC LB_enum\tS_backup_one_LB(pTHX_ const U8 * const strbeg, U8 ** curpos, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_BACKUP_ONE_LB\t\\\n\tassert(strbeg); assert(curpos)\n\nSTATIC SB_enum\tS_backup_one_SB(pTHX_ const U8 * const strbeg, U8 ** curpos, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_BACKUP_ONE_SB\t\\\n\tassert(strbeg); assert(curpos)\n\nSTATIC WB_enum\tS_backup_one_WB(pTHX_ WB_enum * previous, const U8 * const strbeg, U8 ** curpos, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_BACKUP_ONE_WB\t\\\n\tassert(previous); assert(strbeg); assert(curpos)\n\nSTATIC char*\tS_find_byclass(pTHX_ regexp * prog, const regnode *c, char *s, const char *strend, regmatch_info *reginfo)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FIND_BYCLASS\t\\\n\tassert(prog); assert(c); assert(s); assert(strend)\n\nSTATIC U8 *\tS_find_next_masked(U8 * s, const U8 * send, const U8 byte, const U8 mask)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FIND_NEXT_MASKED\t\\\n\tassert(s); assert(send)\n\nSTATIC U8 *\tS_find_span_end(U8* s, const U8 * send, const U8 span_byte)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FIND_SPAN_END\t\\\n\tassert(s); assert(send)\n\nSTATIC U8 *\tS_find_span_end_mask(U8 * s, const U8 * send, const U8 span_byte, const U8 mask)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FIND_SPAN_END_MASK\t\\\n\tassert(s); assert(send)\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE I32\tS_foldEQ_latin1_s2_folded(const char* a, const char* b, I32 len);\n#define PERL_ARGS_ASSERT_FOLDEQ_LATIN1_S2_FOLDED\t\\\n\tassert(a); assert(b)\n#endif\nSTATIC bool\tS_isFOO_utf8_lc(pTHX_ const U8 classnum, const U8* character, const U8* e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISFOO_UTF8_LC\t\\\n\tassert(character); assert(e)\n\nSTATIC bool\tS_isGCB(pTHX_ const GCB_enum before, const GCB_enum after, const U8 * const strbeg, const U8 * const curpos, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISGCB\t\\\n\tassert(strbeg); assert(curpos)\n\nSTATIC bool\tS_isLB(pTHX_ LB_enum before, LB_enum after, const U8 * const strbeg, const U8 * const curpos, const U8 * const strend, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISLB\t\\\n\tassert(strbeg); assert(curpos); assert(strend)\n\nSTATIC bool\tS_isSB(pTHX_ SB_enum before, SB_enum after, const U8 * const strbeg, const U8 * const curpos, const U8 * const strend, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISSB\t\\\n\tassert(strbeg); assert(curpos); assert(strend)\n\nSTATIC bool\tS_isWB(pTHX_ WB_enum previous, WB_enum before, WB_enum after, const U8 * const strbeg, const U8 * const curpos, const U8 * const strend, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISWB\t\\\n\tassert(strbeg); assert(curpos); assert(strend)\n\nSTATIC I32\tS_reg_check_named_buff_matched(const regexp *rex, const regnode *scan)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REG_CHECK_NAMED_BUFF_MATCHED\t\\\n\tassert(rex); assert(scan)\n\nSTATIC void\tS_regcp_restore(pTHX_ regexp *rex, I32 ix, U32 *maxopenparen_p _pDEPTH);\n#define PERL_ARGS_ASSERT_REGCP_RESTORE\t\\\n\tassert(rex); assert(maxopenparen_p)\nSTATIC void\tS_regcppop(pTHX_ regexp *rex, U32 *maxopenparen_p _pDEPTH);\n#define PERL_ARGS_ASSERT_REGCPPOP\t\\\n\tassert(rex); assert(maxopenparen_p)\nSTATIC CHECKPOINT\tS_regcppush(pTHX_ const regexp *rex, I32 parenfloor, U32 maxopenparen _pDEPTH);\n#define PERL_ARGS_ASSERT_REGCPPUSH\t\\\n\tassert(rex)\nSTATIC U8*\tS_reghop3(U8 *s, SSize_t off, const U8 *lim)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGHOP3\t\\\n\tassert(s); assert(lim)\n\nSTATIC U8*\tS_reghop4(U8 *s, SSize_t off, const U8 *llim, const U8 *rlim)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGHOP4\t\\\n\tassert(s); assert(llim); assert(rlim)\n\nSTATIC U8*\tS_reghopmaybe3(U8 *s, SSize_t off, const U8 * const lim)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGHOPMAYBE3\t\\\n\tassert(s); assert(lim)\n\nSTATIC bool\tS_reginclass(pTHX_ regexp * const prog, const regnode * const n, const U8 * const p, const U8 * const p_end, bool const utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGINCLASS\t\\\n\tassert(n); assert(p); assert(p_end)\n\nSTATIC SSize_t\tS_regmatch(pTHX_ regmatch_info *reginfo, char *startpos, regnode *prog)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGMATCH\t\\\n\tassert(reginfo); assert(startpos); assert(prog)\n\nSTATIC I32\tS_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p, char *loceol, regmatch_info *const reginfo, I32 max _pDEPTH)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGREPEAT\t\\\n\tassert(prog); assert(startposp); assert(p); assert(loceol); assert(reginfo)\n\nSTATIC bool\tS_regtry(pTHX_ regmatch_info *reginfo, char **startposp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGTRY\t\\\n\tassert(reginfo); assert(startposp)\n\nSTATIC bool\tS_to_byte_substr(pTHX_ regexp * prog);\n#define PERL_ARGS_ASSERT_TO_BYTE_SUBSTR\t\\\n\tassert(prog)\nSTATIC void\tS_to_utf8_substr(pTHX_ regexp * prog);\n#define PERL_ARGS_ASSERT_TO_UTF8_SUBSTR\t\\\n\tassert(prog)\n#endif\n#if defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_TOKE_C)\nPERL_CALLCONV bool\tPerl__is_grapheme(pTHX_ const U8 * strbeg, const U8 * s, const U8 *strend, const UV cp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_GRAPHEME\t\\\n\tassert(strbeg); assert(s); assert(strend)\n\n#endif\n#if defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C)\nPERL_CALLCONV bool\tPerl_isFOO_lc(pTHX_ const U8 classnum, const U8 character)\n\t\t\t__attribute__warn_unused_result__;\n\n#endif\n#if defined(PERL_IN_SCOPE_C)\nSTATIC void\tS_save_pushptri32ptr(pTHX_ void *const ptr1, const I32 i, void *const ptr2, const int type);\nSTATIC SV*\tS_save_scalar_at(pTHX_ SV **sptr, const U32 flags);\n#define PERL_ARGS_ASSERT_SAVE_SCALAR_AT\t\\\n\tassert(sptr)\n#endif\n#if defined(PERL_IN_SV_C)\nSTATIC char *\tS_F0convert(NV nv, char *const endbuf, STRLEN *const len);\n#define PERL_ARGS_ASSERT_F0CONVERT\t\\\n\tassert(endbuf); assert(len)\nSTATIC void\tS_anonymise_cv_maybe(pTHX_ GV *gv, CV *cv);\n#define PERL_ARGS_ASSERT_ANONYMISE_CV_MAYBE\t\\\n\tassert(gv); assert(cv)\nSTATIC void\tS_assert_uft8_cache_coherent(pTHX_ const char *const func, STRLEN from_cache, STRLEN real, SV *const sv);\n#define PERL_ARGS_ASSERT_ASSERT_UFT8_CACHE_COHERENT\t\\\n\tassert(func); assert(sv)\nSTATIC bool\tS_curse(pTHX_ SV * const sv, const bool check_refcnt);\n#define PERL_ARGS_ASSERT_CURSE\t\\\n\tassert(sv)\nSTATIC STRLEN\tS_expect_number(pTHX_ const char **const pattern)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_EXPECT_NUMBER\t\\\n\tassert(pattern)\n\nSTATIC SSize_t\tS_find_array_subscript(pTHX_ const AV *const av, const SV *const val);\n#define PERL_ARGS_ASSERT_FIND_ARRAY_SUBSCRIPT\t\\\n\tassert(val)\nSTATIC SV *\tS_find_hash_subscript(pTHX_ const HV *const hv, const SV *const val);\n#define PERL_ARGS_ASSERT_FIND_HASH_SUBSCRIPT\t\\\n\tassert(val)\nSTATIC SV*\tS_find_uninit_var(pTHX_ const OP *const obase, const SV *const uninit_sv, bool match, const char **desc_p);\n#define PERL_ARGS_ASSERT_FIND_UNINIT_VAR\t\\\n\tassert(desc_p)\nSTATIC bool\tS_glob_2number(pTHX_ GV* const gv);\n#define PERL_ARGS_ASSERT_GLOB_2NUMBER\t\\\n\tassert(gv)\nSTATIC void\tS_glob_assign_glob(pTHX_ SV *const dstr, SV *const sstr, const int dtype);\n#define PERL_ARGS_ASSERT_GLOB_ASSIGN_GLOB\t\\\n\tassert(dstr); assert(sstr)\nSTATIC SV *\tS_more_sv(pTHX);\nSTATIC void\tS_not_a_number(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_NOT_A_NUMBER\t\\\n\tassert(sv)\nSTATIC void\tS_not_incrementable(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_NOT_INCREMENTABLE\t\\\n\tassert(sv)\nSTATIC PTR_TBL_ENT_t *\tS_ptr_table_find(PTR_TBL_t *const tbl, const void *const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PTR_TABLE_FIND\t\\\n\tassert(tbl)\n\nSTATIC bool\tS_sv_2iuv_common(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_2IUV_COMMON\t\\\n\tassert(sv)\nSTATIC void\tS_sv_add_arena(pTHX_ char *const ptr, const U32 size, const U32 flags);\n#define PERL_ARGS_ASSERT_SV_ADD_ARENA\t\\\n\tassert(ptr)\nSTATIC const char *\tS_sv_display(pTHX_ SV *const sv, char *tmpbuf, STRLEN tmpbuf_size);\n#define PERL_ARGS_ASSERT_SV_DISPLAY\t\\\n\tassert(sv); assert(tmpbuf)\nSTATIC STRLEN\tS_sv_pos_b2u_midway(pTHX_ const U8 *const s, const U8 *const target, const U8 *end, STRLEN endu);\n#define PERL_ARGS_ASSERT_SV_POS_B2U_MIDWAY\t\\\n\tassert(s); assert(target); assert(end)\nSTATIC STRLEN\tS_sv_pos_u2b_cached(pTHX_ SV *const sv, MAGIC **const mgp, const U8 *const start, const U8 *const send, STRLEN uoffset, STRLEN uoffset0, STRLEN boffset0);\n#define PERL_ARGS_ASSERT_SV_POS_U2B_CACHED\t\\\n\tassert(sv); assert(mgp); assert(start); assert(send)\nSTATIC STRLEN\tS_sv_pos_u2b_forwards(const U8 *const start, const U8 *const send, STRLEN *const uoffset, bool *const at_end);\n#define PERL_ARGS_ASSERT_SV_POS_U2B_FORWARDS\t\\\n\tassert(start); assert(send); assert(uoffset); assert(at_end)\nSTATIC STRLEN\tS_sv_pos_u2b_midway(const U8 *const start, const U8 *send, STRLEN uoffset, const STRLEN uend);\n#define PERL_ARGS_ASSERT_SV_POS_U2B_MIDWAY\t\\\n\tassert(start); assert(send)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_sv_unglob(pTHX_ SV *const sv, U32 flags);\n#define PERL_ARGS_ASSERT_SV_UNGLOB\t\\\n\tassert(sv)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE char *\tS_uiv_2buf(char *const buf, const IV iv, UV uv, const int is_uv, char **const peob)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UIV_2BUF\t\\\n\tassert(buf); assert(peob)\n#endif\n\nSTATIC void\tS_utf8_mg_len_cache_update(pTHX_ SV *const sv, MAGIC **const mgp, const STRLEN ulen);\n#define PERL_ARGS_ASSERT_UTF8_MG_LEN_CACHE_UPDATE\t\\\n\tassert(sv); assert(mgp)\nSTATIC void\tS_utf8_mg_pos_cache_update(pTHX_ SV *const sv, MAGIC **const mgp, const STRLEN byte, const STRLEN utf8, const STRLEN blen);\n#define PERL_ARGS_ASSERT_UTF8_MG_POS_CACHE_UPDATE\t\\\n\tassert(sv); assert(mgp)\nSTATIC I32\tS_visit(pTHX_ SVFUNC_t f, const U32 flags, const U32 mask);\n#define PERL_ARGS_ASSERT_VISIT\t\\\n\tassert(f)\n#  if defined(USE_ITHREADS)\nSTATIC SV*\tS_sv_dup_common(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DUP_COMMON\t\\\n\tassert(sstr); assert(param)\n\nSTATIC SV **\tS_sv_dup_inc_multiple(pTHX_ SV *const *source, SV **dest, SSize_t items, CLONE_PARAMS *const param);\n#define PERL_ARGS_ASSERT_SV_DUP_INC_MULTIPLE\t\\\n\tassert(source); assert(dest); assert(param)\nSTATIC void\tS_unreferenced_to_tmp_stack(pTHX_ AV *const unreferenced);\n#define PERL_ARGS_ASSERT_UNREFERENCED_TO_TMP_STACK\t\\\n\tassert(unreferenced)\n#  endif\n#endif\n#if defined(PERL_IN_SV_C) || defined (PERL_IN_OP_C)\nPERL_CALLCONV SV *\tPerl_varname(pTHX_ const GV *const gv, const char gvtype, PADOFFSET targ, const SV *const keyname, SSize_t aindex, int subscript_type)\n\t\t\t__attribute__warn_unused_result__;\n\n#endif\n#if defined(PERL_IN_TOKE_C)\nSTATIC int\tS_ao(pTHX_ int toketype);\nSTATIC void\tS_check_uni(pTHX);\nSTATIC void\tS_checkcomma(pTHX_ const char *s, const char *name, const char *what);\n#define PERL_ARGS_ASSERT_CHECKCOMMA\t\\\n\tassert(s); assert(name); assert(what)\nSTATIC char *\tS_filter_gets(pTHX_ SV *sv, STRLEN append)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FILTER_GETS\t\\\n\tassert(sv)\n\nSTATIC HV *\tS_find_in_my_stash(pTHX_ const char *pkgname, STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FIND_IN_MY_STASH\t\\\n\tassert(pkgname)\n\nSTATIC void\tS_force_ident(pTHX_ const char *s, int kind);\n#define PERL_ARGS_ASSERT_FORCE_IDENT\t\\\n\tassert(s)\nSTATIC void\tS_force_ident_maybe_lex(pTHX_ char pit);\nSTATIC void\tS_force_next(pTHX_ I32 type);\nSTATIC char*\tS_force_strict_version(pTHX_ char *s);\n#define PERL_ARGS_ASSERT_FORCE_STRICT_VERSION\t\\\n\tassert(s)\nSTATIC char*\tS_force_version(pTHX_ char *s, int guessing);\n#define PERL_ARGS_ASSERT_FORCE_VERSION\t\\\n\tassert(s)\nSTATIC char*\tS_force_word(pTHX_ char *start, int token, int check_keyword, int allow_pack);\n#define PERL_ARGS_ASSERT_FORCE_WORD\t\\\n\tassert(start)\nSTATIC SV*\tS_get_and_check_backslash_N_name_wrapper(pTHX_ const char* s, const char* const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_AND_CHECK_BACKSLASH_N_NAME_WRAPPER\t\\\n\tassert(s); assert(e)\n\nSTATIC void\tS_incline(pTHX_ const char *s, const char *end);\n#define PERL_ARGS_ASSERT_INCLINE\t\\\n\tassert(s); assert(end)\nSTATIC int\tS_intuit_method(pTHX_ char *s, SV *ioname, CV *cv);\n#define PERL_ARGS_ASSERT_INTUIT_METHOD\t\\\n\tassert(s)\nSTATIC int\tS_intuit_more(pTHX_ char *s, char *e);\n#define PERL_ARGS_ASSERT_INTUIT_MORE\t\\\n\tassert(s); assert(e)\nSTATIC I32\tS_lop(pTHX_ I32 f, U8 x, char *s);\n#define PERL_ARGS_ASSERT_LOP\t\\\n\tassert(s)\nPERL_STATIC_NO_RET void\tS_missingterm(pTHX_ char *s, STRLEN len)\n\t\t\t__attribute__noreturn__;\n\nSTATIC SV*\tS_new_constant(pTHX_ const char *s, STRLEN len, const char *key, STRLEN keylen, SV *sv, SV *pv, const char *type, STRLEN typelen, const char ** error_msg);\n#define PERL_ARGS_ASSERT_NEW_CONSTANT\t\\\n\tassert(key); assert(sv)\nSTATIC void\tS_no_op(pTHX_ const char *const what, char *s);\n#define PERL_ARGS_ASSERT_NO_OP\t\\\n\tassert(what)\nSTATIC void\tS_parse_ident(pTHX_ char **s, char **d, char * const e, int allow_package, bool is_utf8, bool check_dollar, bool tick_warn);\n#define PERL_ARGS_ASSERT_PARSE_IDENT\t\\\n\tassert(s); assert(d); assert(e)\nSTATIC int\tS_pending_ident(pTHX);\nSTATIC char*\tS_scan_const(pTHX_ char *start)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_CONST\t\\\n\tassert(start)\n\nSTATIC char*\tS_scan_formline(pTHX_ char *s)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_FORMLINE\t\\\n\tassert(s)\n\nSTATIC char*\tS_scan_heredoc(pTHX_ char *s)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_HEREDOC\t\\\n\tassert(s)\n\nSTATIC char*\tS_scan_ident(pTHX_ char *s, char *dest, STRLEN destlen, I32 ck_uni);\n#define PERL_ARGS_ASSERT_SCAN_IDENT\t\\\n\tassert(s); assert(dest)\nSTATIC char*\tS_scan_inputsymbol(pTHX_ char *start)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_INPUTSYMBOL\t\\\n\tassert(start)\n\nSTATIC char*\tS_scan_pat(pTHX_ char *start, I32 type)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_PAT\t\\\n\tassert(start)\n\nSTATIC char*\tS_scan_subst(pTHX_ char *start)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_SUBST\t\\\n\tassert(start)\n\nSTATIC char*\tS_scan_trans(pTHX_ char *start)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_TRANS\t\\\n\tassert(start)\n\nSTATIC I32\tS_sublex_done(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC I32\tS_sublex_push(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC I32\tS_sublex_start(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC char*\tS_swallow_bom(pTHX_ U8 *s)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SWALLOW_BOM\t\\\n\tassert(s)\n\nSTATIC char *\tS_tokenize_use(pTHX_ int is_use, char *s)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_TOKENIZE_USE\t\\\n\tassert(s)\n\nSTATIC SV*\tS_tokeq(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_TOKEQ\t\\\n\tassert(sv)\nSTATIC void\tS_update_debugger_info(pTHX_ SV *orig_sv, const char *const buf, STRLEN len);\nSTATIC int\tS_yywarn(pTHX_ const char *const s, U32 flags);\n#define PERL_ARGS_ASSERT_YYWARN\t\\\n\tassert(s)\n#endif\n#if defined(PERL_IN_UNIVERSAL_C)\nSTATIC bool\tS_isa_lookup(pTHX_ HV *stash, const char * const name, STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_ISA_LOOKUP\t\\\n\tassert(stash); assert(name)\n#endif\n#if defined(PERL_IN_UTF8_C)\nSTATIC UV\tS__to_utf8_case(pTHX_ const UV uv1, const U8 *p, U8* ustrp, STRLEN *lenp, SV *invlist, const int * const invmap, const unsigned int * const * const aux_tables, const U8 * const aux_table_lengths, const char * const normal);\n#define PERL_ARGS_ASSERT__TO_UTF8_CASE\t\\\n\tassert(ustrp); assert(lenp); assert(invlist); assert(invmap); assert(normal)\nSTATIC U32\tS_check_and_deprecate(pTHX_ const U8 * p, const U8 ** e, const unsigned type, const bool use_locale, const char * const file, const unsigned line);\n#define PERL_ARGS_ASSERT_CHECK_AND_DEPRECATE\t\\\n\tassert(p); assert(e); assert(file)\nSTATIC UV\tS_check_locale_boundary_crossing(pTHX_ const U8* const p, const UV result, U8* const ustrp, STRLEN *lenp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CHECK_LOCALE_BOUNDARY_CROSSING\t\\\n\tassert(p); assert(ustrp); assert(lenp)\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE int\tS_does_utf8_overflow(const U8 * const s, const U8 * e, const bool consider_overlongs)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DOES_UTF8_OVERFLOW\t\\\n\tassert(s); assert(e)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE int\tS_isFF_OVERLONG(const U8 * const s, const STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISFF_OVERLONG\t\\\n\tassert(s)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_common(pTHX_ const U8 *const p, SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_COMMON\t\\\n\tassert(p)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_common_with_len(pTHX_ const U8 *const p, const U8 *const e, SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_COMMON_WITH_LEN\t\\\n\tassert(p); assert(e)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE int\tS_is_utf8_overlong_given_start_byte_ok(const U8 * const s, const STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_OVERLONG_GIVEN_START_BYTE_OK\t\\\n\tassert(s)\n#endif\n\nSTATIC HV *\tS_new_msg_hv(pTHX_ const char * const message, U32 categories, U32 flag)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEW_MSG_HV\t\\\n\tassert(message)\n\nSTATIC U8*\tS_swash_scan_list_line(pTHX_ U8* l, U8* const lend, UV* min, UV* max, UV* val, const bool wants_value, const U8* const typestr)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SWASH_SCAN_LIST_LINE\t\\\n\tassert(l); assert(lend); assert(min); assert(max); assert(val); assert(typestr)\n\nSTATIC SV*\tS_swatch_get(pTHX_ SV* swash, UV start, UV span)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SWATCH_GET\t\\\n\tassert(swash)\n\nSTATIC U8\tS_to_lower_latin1(const U8 c, U8 *p, STRLEN *lenp, const char dummy)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC UV\tS_turkic_fc(pTHX_ const U8 * const p, const U8 * const e, U8* ustrp, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_TURKIC_FC\t\\\n\tassert(p); assert(e); assert(ustrp); assert(lenp)\nSTATIC UV\tS_turkic_lc(pTHX_ const U8 * const p0, const U8 * const e, U8* ustrp, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_TURKIC_LC\t\\\n\tassert(p0); assert(e); assert(ustrp); assert(lenp)\nSTATIC UV\tS_turkic_uc(pTHX_ const U8 * const p, const U8 * const e, U8* ustrp, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_TURKIC_UC\t\\\n\tassert(p); assert(e); assert(ustrp); assert(lenp)\nSTATIC char *\tS_unexpected_non_continuation_text(pTHX_ const U8 * const s, STRLEN print_len, const STRLEN non_cont_byte_pos, const STRLEN expect_len)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UNEXPECTED_NON_CONTINUATION_TEXT\t\\\n\tassert(s)\n\nSTATIC void\tS_warn_on_first_deprecated_use(pTHX_ const char * const name, const char * const alternative, const bool use_locale, const char * const file, const unsigned line);\n#define PERL_ARGS_ASSERT_WARN_ON_FIRST_DEPRECATED_USE\t\\\n\tassert(name); assert(alternative); assert(file)\n#endif\n#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)\nPERL_CALLCONV UV\tPerl__to_upper_title_latin1(pTHX_ const U8 c, U8 *p, STRLEN *lenp, const char S_or_s);\n#define PERL_ARGS_ASSERT__TO_UPPER_TITLE_LATIN1\t\\\n\tassert(p); assert(lenp)\n#endif\n#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)\nPERL_CALLCONV UV\tPerl__to_fold_latin1(const U8 c, U8 *p, STRLEN *lenp, const unsigned int flags);\n#define PERL_ARGS_ASSERT__TO_FOLD_LATIN1\t\\\n\tassert(p); assert(lenp)\n#endif\n#if defined(PERL_IN_UTIL_C)\nSTATIC bool\tS_ckwarn_common(pTHX_ U32 w);\nSTATIC bool\tS_invoke_exception_hook(pTHX_ SV *ex, bool warn);\nSTATIC SV*\tS_mess_alloc(pTHX);\nSTATIC SV *\tS_with_queued_errors(pTHX_ SV *ex);\n#define PERL_ARGS_ASSERT_WITH_QUEUED_ERRORS\t\\\n\tassert(ex)\nSTATIC void\tS_xs_version_bootcheck(pTHX_ U32 items, U32 ax, const char *xs_p, STRLEN xs_len);\n#define PERL_ARGS_ASSERT_XS_VERSION_BOOTCHECK\t\\\n\tassert(xs_p)\n#  if defined(PERL_MEM_LOG) && !defined(PERL_MEM_LOG_NOIMPL)\nSTATIC void\tS_mem_log_common(enum mem_log_type mlt, const UV n, const UV typesize, const char *type_name, const SV *sv, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);\n#define PERL_ARGS_ASSERT_MEM_LOG_COMMON\t\\\n\tassert(type_name); assert(filename); assert(funcname)\n#  endif\n#endif\n#if defined(PERL_MEM_LOG)\nPERL_CALLCONV Malloc_t\tPerl_mem_log_alloc(const UV nconst, UV typesize, const char *type_name, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);\n#define PERL_ARGS_ASSERT_MEM_LOG_ALLOC\t\\\n\tassert(type_name); assert(filename); assert(funcname)\nPERL_CALLCONV Malloc_t\tPerl_mem_log_free(Malloc_t oldalloc, const char *filename, const int linenumber, const char *funcname);\n#define PERL_ARGS_ASSERT_MEM_LOG_FREE\t\\\n\tassert(filename); assert(funcname)\nPERL_CALLCONV Malloc_t\tPerl_mem_log_realloc(const UV n, const UV typesize, const char *type_name, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);\n#define PERL_ARGS_ASSERT_MEM_LOG_REALLOC\t\\\n\tassert(type_name); assert(filename); assert(funcname)\n#endif\n#if defined(PERL_USES_PL_PIDSTATUS) && defined(PERL_IN_UTIL_C)\nSTATIC void\tS_pidgone(pTHX_ Pid_t pid, int status);\n#endif\n#if defined(UNLINK_ALL_VERSIONS)\nPERL_CALLCONV I32\tPerl_unlnk(pTHX_ const char* f);\n#define PERL_ARGS_ASSERT_UNLNK\t\\\n\tassert(f)\n#endif\n#if defined(USE_C_BACKTRACE)\nPERL_CALLCONV bool\tPerl_dump_c_backtrace(pTHX_ PerlIO* fp, int max_depth, int skip);\n#define PERL_ARGS_ASSERT_DUMP_C_BACKTRACE\t\\\n\tassert(fp)\n/* PERL_CALLCONV void\tfree_c_backtrace(pTHX_ Perl_c_backtrace* bt); */\nPERL_CALLCONV Perl_c_backtrace*\tPerl_get_c_backtrace(pTHX_ int max_depth, int skip);\nPERL_CALLCONV SV*\tPerl_get_c_backtrace_dump(pTHX_ int max_depth, int skip);\n#endif\n#if defined(USE_DTRACE)\nPERL_CALLCONV void\tPerl_dtrace_probe_call(pTHX_ CV *cv, bool is_call);\n#define PERL_ARGS_ASSERT_DTRACE_PROBE_CALL\t\\\n\tassert(cv)\nPERL_CALLCONV void\tPerl_dtrace_probe_load(pTHX_ const char *name, bool is_loading);\n#define PERL_ARGS_ASSERT_DTRACE_PROBE_LOAD\t\\\n\tassert(name)\nPERL_CALLCONV void\tPerl_dtrace_probe_op(pTHX_ const OP *op);\n#define PERL_ARGS_ASSERT_DTRACE_PROBE_OP\t\\\n\tassert(op)\nPERL_CALLCONV void\tPerl_dtrace_probe_phase(pTHX_ enum perl_phase phase);\n#endif\n#if defined(USE_ITHREADS)\nPERL_CALLCONV PADOFFSET\tPerl_alloccopstash(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_ALLOCCOPSTASH\t\\\n\tassert(hv)\nPERL_CALLCONV void*\tPerl_any_dup(pTHX_ void* v, const PerlInterpreter* proto_perl)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ANY_DUP\t\\\n\tassert(proto_perl)\n\nPERL_CALLCONV void\tPerl_clone_params_del(CLONE_PARAMS *param);\n#define PERL_ARGS_ASSERT_CLONE_PARAMS_DEL\t\\\n\tassert(param)\nPERL_CALLCONV CLONE_PARAMS *\tPerl_clone_params_new(PerlInterpreter *const from, PerlInterpreter *const to)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CLONE_PARAMS_NEW\t\\\n\tassert(from); assert(to)\n\nPERL_CALLCONV PERL_CONTEXT*\tPerl_cx_dup(pTHX_ PERL_CONTEXT* cx, I32 ix, I32 max, CLONE_PARAMS* param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CX_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV DIR*\tPerl_dirp_dup(pTHX_ DIR *const dp, CLONE_PARAMS *const param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DIRP_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV PerlIO*\tPerl_fp_dup(pTHX_ PerlIO *const fp, const char type, CLONE_PARAMS *const param);\n#define PERL_ARGS_ASSERT_FP_DUP\t\\\n\tassert(param)\nPERL_CALLCONV GP*\tPerl_gp_dup(pTHX_ GP *const gp, CLONE_PARAMS *const param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GP_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV HE*\tPerl_he_dup(pTHX_ const HE* e, bool shared, CLONE_PARAMS* param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HE_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV HEK*\tPerl_hek_dup(pTHX_ HEK* e, CLONE_PARAMS* param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HEK_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV MAGIC*\tPerl_mg_dup(pTHX_ MAGIC *mg, CLONE_PARAMS *const param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MG_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV struct mro_meta*\tPerl_mro_meta_dup(pTHX_ struct mro_meta* smeta, CLONE_PARAMS* param);\n#define PERL_ARGS_ASSERT_MRO_META_DUP\t\\\n\tassert(smeta); assert(param)\nPERL_CALLCONV OP*\tPerl_newPADOP(pTHX_ I32 type, I32 flags, SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWPADOP\t\\\n\tassert(sv)\n\nPERL_CALLCONV PADLIST *\tPerl_padlist_dup(pTHX_ PADLIST *srcpad, CLONE_PARAMS *param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PADLIST_DUP\t\\\n\tassert(srcpad); assert(param)\n\nPERL_CALLCONV PADNAME *\tPerl_padname_dup(pTHX_ PADNAME *src, CLONE_PARAMS *param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PADNAME_DUP\t\\\n\tassert(src); assert(param)\n\nPERL_CALLCONV PADNAMELIST *\tPerl_padnamelist_dup(pTHX_ PADNAMELIST *srcpad, CLONE_PARAMS *param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PADNAMELIST_DUP\t\\\n\tassert(srcpad); assert(param)\n\nPERL_CALLCONV yy_parser*\tPerl_parser_dup(pTHX_ const yy_parser *const proto, CLONE_PARAMS *const param);\n#define PERL_ARGS_ASSERT_PARSER_DUP\t\\\n\tassert(param)\nPERL_CALLCONV PerlInterpreter*\tperl_clone(PerlInterpreter *proto_perl, UV flags);\n#define PERL_ARGS_ASSERT_PERL_CLONE\t\\\n\tassert(proto_perl)\nPERL_CALLCONV void\tPerl_re_dup_guts(pTHX_ const REGEXP *sstr, REGEXP *dstr, CLONE_PARAMS* param);\n#define PERL_ARGS_ASSERT_RE_DUP_GUTS\t\\\n\tassert(sstr); assert(dstr); assert(param)\nPERL_CALLCONV void*\tPerl_regdupe_internal(pTHX_ REGEXP * const r, CLONE_PARAMS* param);\n#define PERL_ARGS_ASSERT_REGDUPE_INTERNAL\t\\\n\tassert(r); assert(param)\nPERL_CALLCONV void\tPerl_rvpv_dup(pTHX_ SV *const dstr, const SV *const sstr, CLONE_PARAMS *const param);\n#define PERL_ARGS_ASSERT_RVPV_DUP\t\\\n\tassert(dstr); assert(sstr); assert(param)\nPERL_CALLCONV PERL_SI*\tPerl_si_dup(pTHX_ PERL_SI* si, CLONE_PARAMS* param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SI_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV ANY*\tPerl_ss_dup(pTHX_ PerlInterpreter* proto_perl, CLONE_PARAMS* param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SS_DUP\t\\\n\tassert(proto_perl); assert(param)\n\nPERL_CALLCONV SV*\tPerl_sv_dup(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV SV*\tPerl_sv_dup_inc(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DUP_INC\t\\\n\tassert(param)\n\n#endif\n#if defined(USE_LOCALE)\t\t    && (   defined(PERL_IN_LOCALE_C)\t        || defined(PERL_IN_MG_C)\t\t|| defined (PERL_EXT_POSIX)\t\t|| defined (PERL_EXT_LANGINFO))\nPERL_CALLCONV bool\tPerl__is_cur_LC_category_utf8(pTHX_ int category);\n#endif\n#if defined(USE_LOCALE_COLLATE)\nPERL_CALLCONV int\tPerl_magic_setcollxfrm(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETCOLLXFRM\t\\\n\tassert(sv); assert(mg)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_mem_collxfrm(pTHX_ const char* input_string, STRLEN len, STRLEN* xlen);\n#define PERL_ARGS_ASSERT_MEM_COLLXFRM\t\\\n\tassert(input_string); assert(xlen)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_collxfrm(pTHX_ SV *const sv, STRLEN *const nxp);\n#define PERL_ARGS_ASSERT_SV_COLLXFRM\t\\\n\tassert(sv); assert(nxp)\n#endif\nPERL_CALLCONV char*\tPerl_sv_collxfrm_flags(pTHX_ SV *const sv, STRLEN *const nxp, I32 const flags);\n#define PERL_ARGS_ASSERT_SV_COLLXFRM_FLAGS\t\\\n\tassert(sv); assert(nxp)\n#endif\n#if defined(USE_PERLIO)\nPERL_CALLCONV void\tPerl_PerlIO_clearerr(pTHX_ PerlIO *f);\nPERL_CALLCONV int\tPerl_PerlIO_close(pTHX_ PerlIO *f);\nPERL_CALLCONV int\tPerl_PerlIO_eof(pTHX_ PerlIO *f);\nPERL_CALLCONV int\tPerl_PerlIO_error(pTHX_ PerlIO *f);\nPERL_CALLCONV int\tPerl_PerlIO_fileno(pTHX_ PerlIO *f);\nPERL_CALLCONV int\tPerl_PerlIO_fill(pTHX_ PerlIO *f);\nPERL_CALLCONV int\tPerl_PerlIO_flush(pTHX_ PerlIO *f);\nPERL_CALLCONV STDCHAR *\tPerl_PerlIO_get_base(pTHX_ PerlIO *f);\nPERL_CALLCONV SSize_t\tPerl_PerlIO_get_bufsiz(pTHX_ PerlIO *f)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SSize_t\tPerl_PerlIO_get_cnt(pTHX_ PerlIO *f)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV STDCHAR *\tPerl_PerlIO_get_ptr(pTHX_ PerlIO *f);\nPERL_CALLCONV SSize_t\tPerl_PerlIO_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);\n#define PERL_ARGS_ASSERT_PERLIO_READ\t\\\n\tassert(vbuf)\nPERL_CALLCONV void\tPerl_PerlIO_restore_errno(pTHX_ PerlIO *f);\nPERL_CALLCONV void\tPerl_PerlIO_save_errno(pTHX_ PerlIO *f);\nPERL_CALLCONV int\tPerl_PerlIO_seek(pTHX_ PerlIO *f, Off_t offset, int whence);\nPERL_CALLCONV void\tPerl_PerlIO_set_cnt(pTHX_ PerlIO *f, SSize_t cnt);\nPERL_CALLCONV void\tPerl_PerlIO_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR *ptr, SSize_t cnt);\nPERL_CALLCONV void\tPerl_PerlIO_setlinebuf(pTHX_ PerlIO *f);\nPERL_CALLCONV PerlIO *\tPerl_PerlIO_stderr(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV PerlIO *\tPerl_PerlIO_stdin(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV PerlIO *\tPerl_PerlIO_stdout(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV Off_t\tPerl_PerlIO_tell(pTHX_ PerlIO *f);\nPERL_CALLCONV SSize_t\tPerl_PerlIO_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);\n#define PERL_ARGS_ASSERT_PERLIO_UNREAD\t\\\n\tassert(vbuf)\nPERL_CALLCONV SSize_t\tPerl_PerlIO_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);\n#define PERL_ARGS_ASSERT_PERLIO_WRITE\t\\\n\tassert(vbuf)\n#endif\n#if defined(USE_QUADMATH)\nPERL_CALLCONV bool\tPerl_quadmath_format_needed(const char* format);\n#define PERL_ARGS_ASSERT_QUADMATH_FORMAT_NEEDED\t\\\n\tassert(format)\nPERL_CALLCONV const char*\tPerl_quadmath_format_single(const char* format);\n#define PERL_ARGS_ASSERT_QUADMATH_FORMAT_SINGLE\t\\\n\tassert(format)\n#endif\n#if defined(WIN32)\nPERL_CALLCONV_NO_RET void\twin32_croak_not_implemented(const char * fname)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_WIN32_CROAK_NOT_IMPLEMENTED\t\\\n\tassert(fname)\n\n#endif\n#if defined(WIN32) || defined(__SYMBIAN32__) || defined(VMS)\nPERL_CALLCONV int\tPerl_do_aspawn(pTHX_ SV* really, SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_ASPAWN\t\\\n\tassert(mark); assert(sp)\nPERL_CALLCONV int\tPerl_do_spawn(pTHX_ char* cmd);\n#define PERL_ARGS_ASSERT_DO_SPAWN\t\\\n\tassert(cmd)\nPERL_CALLCONV int\tPerl_do_spawn_nowait(pTHX_ char* cmd);\n#define PERL_ARGS_ASSERT_DO_SPAWN_NOWAIT\t\\\n\tassert(cmd)\n#endif\n#if defined(_MSC_VER)\nPERL_CALLCONV int\tPerl_magic_regdatum_set(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_REGDATUM_SET\t\\\n\tassert(sv); assert(mg)\n#endif\n#ifdef PERL_CORE\n#  include \"pp_proto.h\"\n#endif\nEND_EXTERN_C\n\n/* ex: set ro: */\n", "/*    regcomp.c\n */\n\n/*\n * 'A fair jaw-cracker dwarf-language must be.'            --Samwise Gamgee\n *\n *     [p.285 of _The Lord of the Rings_, II/iii: \"The Ring Goes South\"]\n */\n\n/* This file contains functions for compiling a regular expression.  See\n * also regexec.c which funnily enough, contains functions for executing\n * a regular expression.\n *\n * This file is also copied at build time to ext/re/re_comp.c, where\n * it's built with -DPERL_EXT_RE_BUILD -DPERL_EXT_RE_DEBUG -DPERL_EXT.\n * This causes the main functions to be compiled under new names and with\n * debugging support added, which makes \"use re 'debug'\" work.\n */\n\n/* NOTE: this is derived from Henry Spencer's regexp code, and should not\n * confused with the original package (see point 3 below).  Thanks, Henry!\n */\n\n/* Additional note: this code is very heavily munged from Henry's version\n * in places.  In some spots I've traded clarity for efficiency, so don't\n * blame Henry for some of the lack of readability.\n */\n\n/* The names of the functions have been changed from regcomp and\n * regexec to pregcomp and pregexec in order to avoid conflicts\n * with the POSIX routines of the same names.\n*/\n\n#ifdef PERL_EXT_RE_BUILD\n#include \"re_top.h\"\n#endif\n\n/*\n * pregcomp and pregexec -- regsub and regerror are not used in perl\n *\n *\tCopyright (c) 1986 by University of Toronto.\n *\tWritten by Henry Spencer.  Not derived from licensed software.\n *\n *\tPermission is granted to anyone to use this software for any\n *\tpurpose on any computer system, and to redistribute it freely,\n *\tsubject to the following restrictions:\n *\n *\t1. The author is not responsible for the consequences of use of\n *\t\tthis software, no matter how awful, even if they arise\n *\t\tfrom defects in it.\n *\n *\t2. The origin of this software must not be misrepresented, either\n *\t\tby explicit claim or by omission.\n *\n *\t3. Altered versions must be plainly marked as such, and must not\n *\t\tbe misrepresented as being the original software.\n *\n *\n ****    Alterations to Henry's code are...\n ****\n ****    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n ****    by Larry Wall and others\n ****\n ****    You may distribute under the terms of either the GNU General Public\n ****    License or the Artistic License, as specified in the README file.\n\n *\n * Beware that some of this code is subtly aware of the way operator\n * precedence is structured in regular expressions.  Serious changes in\n * regular-expression syntax might require a total rethink.\n */\n#include \"EXTERN.h\"\n#define PERL_IN_REGCOMP_C\n#include \"perl.h\"\n\n#define REG_COMP_C\n#ifdef PERL_IN_XSUB_RE\n#  include \"re_comp.h\"\nEXTERN_C const struct regexp_engine my_reg_engine;\n#else\n#  include \"regcomp.h\"\n#endif\n\n#include \"dquote_inline.h\"\n#include \"invlist_inline.h\"\n#include \"unicode_constants.h\"\n\n#define HAS_NONLATIN1_FOLD_CLOSURE(i) \\\n _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)\n#define HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(i) \\\n _HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)\n#define IS_NON_FINAL_FOLD(c) _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)\n#define IS_IN_SOME_FOLD_L1(c) _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)\n\n#ifndef STATIC\n#define\tSTATIC\tstatic\n#endif\n\n/* this is a chain of data about sub patterns we are processing that\n   need to be handled separately/specially in study_chunk. Its so\n   we can simulate recursion without losing state.  */\nstruct scan_frame;\ntypedef struct scan_frame {\n    regnode *last_regnode;      /* last node to process in this frame */\n    regnode *next_regnode;      /* next node to process when last is reached */\n    U32 prev_recursed_depth;\n    I32 stopparen;              /* what stopparen do we use */\n\n    struct scan_frame *this_prev_frame; /* this previous frame */\n    struct scan_frame *prev_frame;      /* previous frame */\n    struct scan_frame *next_frame;      /* next frame */\n} scan_frame;\n\n/* Certain characters are output as a sequence with the first being a\n * backslash. */\n#define isBACKSLASHED_PUNCT(c)  strchr(\"-[]\\\\^\", c)\n\n\nstruct RExC_state_t {\n    U32\t\tflags;\t\t\t/* RXf_* are we folding, multilining? */\n    U32\t\tpm_flags;\t\t/* PMf_* stuff from the calling PMOP */\n    char\t*precomp;\t\t/* uncompiled string. */\n    char\t*precomp_end;\t\t/* pointer to end of uncompiled string. */\n    REGEXP\t*rx_sv;\t\t\t/* The SV that is the regexp. */\n    regexp\t*rx;                    /* perl core regexp structure */\n    regexp_internal\t*rxi;           /* internal data for regexp object\n                                           pprivate field */\n    char\t*start;\t\t\t/* Start of input for compile */\n    char\t*end;\t\t\t/* End of input for compile */\n    char\t*parse;\t\t\t/* Input-scan pointer. */\n    char        *copy_start;            /* start of copy of input within\n                                           constructed parse string */\n    char        *save_copy_start;       /* Provides one level of saving\n                                           and restoring 'copy_start' */\n    char        *copy_start_in_input;   /* Position in input string\n                                           corresponding to copy_start */\n    SSize_t\twhilem_seen;\t\t/* number of WHILEM in this expr */\n    regnode\t*emit_start;\t\t/* Start of emitted-code area */\n    regnode_offset emit;\t\t/* Code-emit pointer */\n    I32\t\tnaughty;\t\t/* How bad is this pattern? */\n    I32\t\tsawback;\t\t/* Did we see \\1, ...? */\n    U32\t\tseen;\n    SSize_t\tsize;\t\t\t/* Number of regnode equivalents in\n                                           pattern */\n\n    /* position beyond 'precomp' of the warning message furthest away from\n     * 'precomp'.  During the parse, no warnings are raised for any problems\n     * earlier in the parse than this position.  This works if warnings are\n     * raised the first time a given spot is parsed, and if only one\n     * independent warning is raised for any given spot */\n    Size_t\tlatest_warn_offset;\n\n    I32         npar;                   /* Capture buffer count so far in the\n                                           parse, (OPEN) plus one. (\"par\" 0 is\n                                           the whole pattern)*/\n    I32         total_par;              /* During initial parse, is either 0,\n                                           or -1; the latter indicating a\n                                           reparse is needed.  After that pass,\n                                           it is what 'npar' became after the\n                                           pass.  Hence, it being > 0 indicates\n                                           we are in a reparse situation */\n    I32\t\tnestroot;\t\t/* root parens we are in - used by\n                                           accept */\n    I32\t\tseen_zerolen;\n    regnode_offset *open_parens;\t/* offsets to open parens */\n    regnode_offset *close_parens;\t/* offsets to close parens */\n    I32      parens_buf_size;           /* #slots malloced open/close_parens */\n    regnode     *end_op;                /* END node in program */\n    I32\t\tutf8;\t\t/* whether the pattern is utf8 or not */\n    I32\t\torig_utf8;\t/* whether the pattern was originally in utf8 */\n\t\t\t\t/* XXX use this for future optimisation of case\n\t\t\t\t * where pattern must be upgraded to utf8. */\n    I32\t\tuni_semantics;\t/* If a d charset modifier should use unicode\n\t\t\t\t   rules, even if the pattern is not in\n\t\t\t\t   utf8 */\n    HV\t\t*paren_names;\t\t/* Paren names */\n\n    regnode\t**recurse;\t\t/* Recurse regops */\n    I32         recurse_count;          /* Number of recurse regops we have generated */\n    U8          *study_chunk_recursed;  /* bitmap of which subs we have moved\n                                           through */\n    U32         study_chunk_recursed_bytes;  /* bytes in bitmap */\n    I32\t\tin_lookbehind;\n    I32\t\tcontains_locale;\n    I32\t\toverride_recoding;\n#ifdef EBCDIC\n    I32\t\trecode_x_to_native;\n#endif\n    I32\t\tin_multi_char_class;\n    struct reg_code_blocks *code_blocks;/* positions of literal (?{})\n\t\t\t\t\t    within pattern */\n    int\t\tcode_index;\t\t/* next code_blocks[] slot */\n    SSize_t     maxlen;                        /* mininum possible number of chars in string to match */\n    scan_frame *frame_head;\n    scan_frame *frame_last;\n    U32         frame_count;\n    AV         *warn_text;\n    HV         *unlexed_names;\n#ifdef ADD_TO_REGEXEC\n    char \t*starttry;\t\t/* -Dr: where regtry was called. */\n#define RExC_starttry\t(pRExC_state->starttry)\n#endif\n    SV\t\t*runtime_code_qr;\t/* qr with the runtime code blocks */\n#ifdef DEBUGGING\n    const char  *lastparse;\n    I32         lastnum;\n    AV          *paren_name_list;       /* idx -> name */\n    U32         study_chunk_recursed_count;\n    SV          *mysv1;\n    SV          *mysv2;\n\n#define RExC_lastparse\t(pRExC_state->lastparse)\n#define RExC_lastnum\t(pRExC_state->lastnum)\n#define RExC_paren_name_list    (pRExC_state->paren_name_list)\n#define RExC_study_chunk_recursed_count    (pRExC_state->study_chunk_recursed_count)\n#define RExC_mysv\t(pRExC_state->mysv1)\n#define RExC_mysv1\t(pRExC_state->mysv1)\n#define RExC_mysv2\t(pRExC_state->mysv2)\n\n#endif\n    bool        seen_d_op;\n    bool        strict;\n    bool        study_started;\n    bool        in_script_run;\n    bool        use_BRANCHJ;\n};\n\n#define RExC_flags\t(pRExC_state->flags)\n#define RExC_pm_flags\t(pRExC_state->pm_flags)\n#define RExC_precomp\t(pRExC_state->precomp)\n#define RExC_copy_start_in_input (pRExC_state->copy_start_in_input)\n#define RExC_copy_start_in_constructed  (pRExC_state->copy_start)\n#define RExC_save_copy_start_in_constructed  (pRExC_state->save_copy_start)\n#define RExC_precomp_end (pRExC_state->precomp_end)\n#define RExC_rx_sv\t(pRExC_state->rx_sv)\n#define RExC_rx\t\t(pRExC_state->rx)\n#define RExC_rxi\t(pRExC_state->rxi)\n#define RExC_start\t(pRExC_state->start)\n#define RExC_end\t(pRExC_state->end)\n#define RExC_parse\t(pRExC_state->parse)\n#define RExC_latest_warn_offset (pRExC_state->latest_warn_offset )\n#define RExC_whilem_seen\t(pRExC_state->whilem_seen)\n#define RExC_seen_d_op (pRExC_state->seen_d_op) /* Seen something that differs\n                                                   under /d from /u ? */\n\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n#  define RExC_offsets\t(RExC_rxi->u.offsets) /* I am not like the\n                                                         others */\n#endif\n#define RExC_emit\t(pRExC_state->emit)\n#define RExC_emit_start\t(pRExC_state->emit_start)\n#define RExC_sawback\t(pRExC_state->sawback)\n#define RExC_seen\t(pRExC_state->seen)\n#define RExC_size\t(pRExC_state->size)\n#define RExC_maxlen        (pRExC_state->maxlen)\n#define RExC_npar\t(pRExC_state->npar)\n#define RExC_total_parens\t(pRExC_state->total_par)\n#define RExC_parens_buf_size\t(pRExC_state->parens_buf_size)\n#define RExC_nestroot   (pRExC_state->nestroot)\n#define RExC_seen_zerolen\t(pRExC_state->seen_zerolen)\n#define RExC_utf8\t(pRExC_state->utf8)\n#define RExC_uni_semantics\t(pRExC_state->uni_semantics)\n#define RExC_orig_utf8\t(pRExC_state->orig_utf8)\n#define RExC_open_parens\t(pRExC_state->open_parens)\n#define RExC_close_parens\t(pRExC_state->close_parens)\n#define RExC_end_op\t(pRExC_state->end_op)\n#define RExC_paren_names\t(pRExC_state->paren_names)\n#define RExC_recurse\t(pRExC_state->recurse)\n#define RExC_recurse_count\t(pRExC_state->recurse_count)\n#define RExC_study_chunk_recursed        (pRExC_state->study_chunk_recursed)\n#define RExC_study_chunk_recursed_bytes  \\\n                                   (pRExC_state->study_chunk_recursed_bytes)\n#define RExC_in_lookbehind\t(pRExC_state->in_lookbehind)\n#define RExC_contains_locale\t(pRExC_state->contains_locale)\n#ifdef EBCDIC\n#   define RExC_recode_x_to_native (pRExC_state->recode_x_to_native)\n#endif\n#define RExC_in_multi_char_class (pRExC_state->in_multi_char_class)\n#define RExC_frame_head (pRExC_state->frame_head)\n#define RExC_frame_last (pRExC_state->frame_last)\n#define RExC_frame_count (pRExC_state->frame_count)\n#define RExC_strict (pRExC_state->strict)\n#define RExC_study_started      (pRExC_state->study_started)\n#define RExC_warn_text (pRExC_state->warn_text)\n#define RExC_in_script_run      (pRExC_state->in_script_run)\n#define RExC_use_BRANCHJ        (pRExC_state->use_BRANCHJ)\n#define RExC_unlexed_names (pRExC_state->unlexed_names)\n\n/* Heuristic check on the complexity of the pattern: if TOO_NAUGHTY, we set\n * a flag to disable back-off on the fixed/floating substrings - if it's\n * a high complexity pattern we assume the benefit of avoiding a full match\n * is worth the cost of checking for the substrings even if they rarely help.\n */\n#define RExC_naughty\t(pRExC_state->naughty)\n#define TOO_NAUGHTY (10)\n#define MARK_NAUGHTY(add) \\\n    if (RExC_naughty < TOO_NAUGHTY) \\\n        RExC_naughty += (add)\n#define MARK_NAUGHTY_EXP(exp, add) \\\n    if (RExC_naughty < TOO_NAUGHTY) \\\n        RExC_naughty += RExC_naughty / (exp) + (add)\n\n#define\tISMULT1(c)\t((c) == '*' || (c) == '+' || (c) == '?')\n#define\tISMULT2(s)\t((*s) == '*' || (*s) == '+' || (*s) == '?' || \\\n\t((*s) == '{' && regcurly(s)))\n\n/*\n * Flags to be passed up and down.\n */\n#define\tWORST\t\t0\t/* Worst case. */\n#define\tHASWIDTH\t0x01\t/* Known to not match null strings, could match\n                                   non-null ones. */\n\n/* Simple enough to be STAR/PLUS operand; in an EXACTish node must be a single\n * character.  (There needs to be a case: in the switch statement in regexec.c\n * for any node marked SIMPLE.)  Note that this is not the same thing as\n * REGNODE_SIMPLE */\n#define\tSIMPLE\t\t0x02\n#define\tSPSTART\t\t0x04\t/* Starts with * or + */\n#define POSTPONED\t0x08    /* (?1),(?&name), (??{...}) or similar */\n#define TRYAGAIN\t0x10\t/* Weeded out a declaration. */\n#define RESTART_PARSE   0x20    /* Need to redo the parse */\n#define NEED_UTF8       0x40    /* In conjunction with RESTART_PARSE, need to\n                                   calcuate sizes as UTF-8 */\n\n#define REG_NODE_NUM(x) ((x) ? (int)((x)-RExC_emit_start) : -1)\n\n/* whether trie related optimizations are enabled */\n#if PERL_ENABLE_EXTENDED_TRIE_OPTIMISATION\n#define TRIE_STUDY_OPT\n#define FULL_TRIE_STUDY\n#define TRIE_STCLASS\n#endif\n\n\n\n#define PBYTE(u8str,paren) ((U8*)(u8str))[(paren) >> 3]\n#define PBITVAL(paren) (1 << ((paren) & 7))\n#define PAREN_TEST(u8str,paren) ( PBYTE(u8str,paren) & PBITVAL(paren))\n#define PAREN_SET(u8str,paren) PBYTE(u8str,paren) |= PBITVAL(paren)\n#define PAREN_UNSET(u8str,paren) PBYTE(u8str,paren) &= (~PBITVAL(paren))\n\n#define REQUIRE_UTF8(flagp) STMT_START {                                   \\\n                                     if (!UTF) {                           \\\n                                         *flagp = RESTART_PARSE|NEED_UTF8; \\\n                                         return 0;                         \\\n                                     }                                     \\\n                             } STMT_END\n\n/* Change from /d into /u rules, and restart the parse.  RExC_uni_semantics is\n * a flag that indicates we need to override /d with /u as a result of\n * something in the pattern.  It should only be used in regards to calling\n * set_regex_charset() or get_regex_charse() */\n#define REQUIRE_UNI_RULES(flagp, restart_retval)                            \\\n    STMT_START {                                                            \\\n            if (DEPENDS_SEMANTICS) {                                        \\\n                set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);      \\\n                RExC_uni_semantics = 1;                                     \\\n                if (RExC_seen_d_op && LIKELY(! IN_PARENS_PASS)) {           \\\n                    /* No need to restart the parse if we haven't seen      \\\n                     * anything that differs between /u and /d, and no need \\\n                     * to restart immediately if we're going to reparse     \\\n                     * anyway to count parens */                            \\\n                    *flagp |= RESTART_PARSE;                                \\\n                    return restart_retval;                                  \\\n                }                                                           \\\n            }                                                               \\\n    } STMT_END\n\n#define REQUIRE_BRANCHJ(flagp, restart_retval)                              \\\n    STMT_START {                                                            \\\n                RExC_use_BRANCHJ = 1;                                       \\\n                *flagp |= RESTART_PARSE;                                    \\\n                return restart_retval;                                      \\\n    } STMT_END\n\n/* Until we have completed the parse, we leave RExC_total_parens at 0 or\n * less.  After that, it must always be positive, because the whole re is\n * considered to be surrounded by virtual parens.  Setting it to negative\n * indicates there is some construct that needs to know the actual number of\n * parens to be properly handled.  And that means an extra pass will be\n * required after we've counted them all */\n#define ALL_PARENS_COUNTED (RExC_total_parens > 0)\n#define REQUIRE_PARENS_PASS                                                 \\\n    STMT_START {  /* No-op if have completed a pass */                      \\\n                    if (! ALL_PARENS_COUNTED) RExC_total_parens = -1;       \\\n    } STMT_END\n#define IN_PARENS_PASS (RExC_total_parens < 0)\n\n\n/* This is used to return failure (zero) early from the calling function if\n * various flags in 'flags' are set.  Two flags always cause a return:\n * 'RESTART_PARSE' and 'NEED_UTF8'.   'extra' can be used to specify any\n * additional flags that should cause a return; 0 if none.  If the return will\n * be done, '*flagp' is first set to be all of the flags that caused the\n * return. */\n#define RETURN_FAIL_ON_RESTART_OR_FLAGS(flags,flagp,extra)                  \\\n    STMT_START {                                                            \\\n            if ((flags) & (RESTART_PARSE|NEED_UTF8|(extra))) {              \\\n                *(flagp) = (flags) & (RESTART_PARSE|NEED_UTF8|(extra));     \\\n                return 0;                                                   \\\n            }                                                               \\\n    } STMT_END\n\n#define MUST_RESTART(flags) ((flags) & (RESTART_PARSE))\n\n#define RETURN_FAIL_ON_RESTART(flags,flagp)                                 \\\n                        RETURN_FAIL_ON_RESTART_OR_FLAGS( flags, flagp, 0)\n#define RETURN_FAIL_ON_RESTART_FLAGP(flagp)                                 \\\n                                    if (MUST_RESTART(*(flagp))) return 0\n\n/* This converts the named class defined in regcomp.h to its equivalent class\n * number defined in handy.h. */\n#define namedclass_to_classnum(class)  ((int) ((class) / 2))\n#define classnum_to_namedclass(classnum)  ((classnum) * 2)\n\n#define _invlist_union_complement_2nd(a, b, output) \\\n                        _invlist_union_maybe_complement_2nd(a, b, TRUE, output)\n#define _invlist_intersection_complement_2nd(a, b, output) \\\n                 _invlist_intersection_maybe_complement_2nd(a, b, TRUE, output)\n\n/* About scan_data_t.\n\n  During optimisation we recurse through the regexp program performing\n  various inplace (keyhole style) optimisations. In addition study_chunk\n  and scan_commit populate this data structure with information about\n  what strings MUST appear in the pattern. We look for the longest\n  string that must appear at a fixed location, and we look for the\n  longest string that may appear at a floating location. So for instance\n  in the pattern:\n\n    /FOO[xX]A.*B[xX]BAR/\n\n  Both 'FOO' and 'A' are fixed strings. Both 'B' and 'BAR' are floating\n  strings (because they follow a .* construct). study_chunk will identify\n  both FOO and BAR as being the longest fixed and floating strings respectively.\n\n  The strings can be composites, for instance\n\n     /(f)(o)(o)/\n\n  will result in a composite fixed substring 'foo'.\n\n  For each string some basic information is maintained:\n\n  - min_offset\n    This is the position the string must appear at, or not before.\n    It also implicitly (when combined with minlenp) tells us how many\n    characters must match before the string we are searching for.\n    Likewise when combined with minlenp and the length of the string it\n    tells us how many characters must appear after the string we have\n    found.\n\n  - max_offset\n    Only used for floating strings. This is the rightmost point that\n    the string can appear at. If set to SSize_t_MAX it indicates that the\n    string can occur infinitely far to the right.\n    For fixed strings, it is equal to min_offset.\n\n  - minlenp\n    A pointer to the minimum number of characters of the pattern that the\n    string was found inside. This is important as in the case of positive\n    lookahead or positive lookbehind we can have multiple patterns\n    involved. Consider\n\n    /(?=FOO).*F/\n\n    The minimum length of the pattern overall is 3, the minimum length\n    of the lookahead part is 3, but the minimum length of the part that\n    will actually match is 1. So 'FOO's minimum length is 3, but the\n    minimum length for the F is 1. This is important as the minimum length\n    is used to determine offsets in front of and behind the string being\n    looked for.  Since strings can be composites this is the length of the\n    pattern at the time it was committed with a scan_commit. Note that\n    the length is calculated by study_chunk, so that the minimum lengths\n    are not known until the full pattern has been compiled, thus the\n    pointer to the value.\n\n  - lookbehind\n\n    In the case of lookbehind the string being searched for can be\n    offset past the start point of the final matching string.\n    If this value was just blithely removed from the min_offset it would\n    invalidate some of the calculations for how many chars must match\n    before or after (as they are derived from min_offset and minlen and\n    the length of the string being searched for).\n    When the final pattern is compiled and the data is moved from the\n    scan_data_t structure into the regexp structure the information\n    about lookbehind is factored in, with the information that would\n    have been lost precalculated in the end_shift field for the\n    associated string.\n\n  The fields pos_min and pos_delta are used to store the minimum offset\n  and the delta to the maximum offset at the current point in the pattern.\n\n*/\n\nstruct scan_data_substrs {\n    SV      *str;       /* longest substring found in pattern */\n    SSize_t min_offset; /* earliest point in string it can appear */\n    SSize_t max_offset; /* latest point in string it can appear */\n    SSize_t *minlenp;   /* pointer to the minlen relevant to the string */\n    SSize_t lookbehind; /* is the pos of the string modified by LB */\n    I32 flags;          /* per substring SF_* and SCF_* flags */\n};\n\ntypedef struct scan_data_t {\n    /*I32 len_min;      unused */\n    /*I32 len_delta;    unused */\n    SSize_t pos_min;\n    SSize_t pos_delta;\n    SV *last_found;\n    SSize_t last_end;\t    /* min value, <0 unless valid. */\n    SSize_t last_start_min;\n    SSize_t last_start_max;\n    U8      cur_is_floating; /* whether the last_* values should be set as\n                              * the next fixed (0) or floating (1)\n                              * substring */\n\n    /* [0] is longest fixed substring so far, [1] is longest float so far */\n    struct scan_data_substrs  substrs[2];\n\n    I32 flags;             /* common SF_* and SCF_* flags */\n    I32 whilem_c;\n    SSize_t *last_closep;\n    regnode_ssc *start_class;\n} scan_data_t;\n\n/*\n * Forward declarations for pregcomp()'s friends.\n */\n\nstatic const scan_data_t zero_scan_data = {\n    0, 0, NULL, 0, 0, 0, 0,\n    {\n        { NULL, 0, 0, 0, 0, 0 },\n        { NULL, 0, 0, 0, 0, 0 },\n    },\n    0, 0, NULL, NULL\n};\n\n/* study flags */\n\n#define SF_BEFORE_SEOL\t\t0x0001\n#define SF_BEFORE_MEOL\t\t0x0002\n#define SF_BEFORE_EOL\t\t(SF_BEFORE_SEOL|SF_BEFORE_MEOL)\n\n#define SF_IS_INF\t\t0x0040\n#define SF_HAS_PAR\t\t0x0080\n#define SF_IN_PAR\t\t0x0100\n#define SF_HAS_EVAL\t\t0x0200\n\n\n/* SCF_DO_SUBSTR is the flag that tells the regexp analyzer to track the\n * longest substring in the pattern. When it is not set the optimiser keeps\n * track of position, but does not keep track of the actual strings seen,\n *\n * So for instance /foo/ will be parsed with SCF_DO_SUBSTR being true, but\n * /foo/i will not.\n *\n * Similarly, /foo.*(blah|erm|huh).*fnorble/ will have \"foo\" and \"fnorble\"\n * parsed with SCF_DO_SUBSTR on, but while processing the (...) it will be\n * turned off because of the alternation (BRANCH). */\n#define SCF_DO_SUBSTR\t\t0x0400\n\n#define SCF_DO_STCLASS_AND\t0x0800\n#define SCF_DO_STCLASS_OR\t0x1000\n#define SCF_DO_STCLASS\t\t(SCF_DO_STCLASS_AND|SCF_DO_STCLASS_OR)\n#define SCF_WHILEM_VISITED_POS\t0x2000\n\n#define SCF_TRIE_RESTUDY        0x4000 /* Do restudy? */\n#define SCF_SEEN_ACCEPT         0x8000\n#define SCF_TRIE_DOING_RESTUDY 0x10000\n#define SCF_IN_DEFINE          0x20000\n\n\n\n\n#define UTF cBOOL(RExC_utf8)\n\n/* The enums for all these are ordered so things work out correctly */\n#define LOC (get_regex_charset(RExC_flags) == REGEX_LOCALE_CHARSET)\n#define DEPENDS_SEMANTICS (get_regex_charset(RExC_flags)                    \\\n                                                     == REGEX_DEPENDS_CHARSET)\n#define UNI_SEMANTICS (get_regex_charset(RExC_flags) == REGEX_UNICODE_CHARSET)\n#define AT_LEAST_UNI_SEMANTICS (get_regex_charset(RExC_flags)                \\\n                                                     >= REGEX_UNICODE_CHARSET)\n#define ASCII_RESTRICTED (get_regex_charset(RExC_flags)                      \\\n                                            == REGEX_ASCII_RESTRICTED_CHARSET)\n#define AT_LEAST_ASCII_RESTRICTED (get_regex_charset(RExC_flags)             \\\n                                            >= REGEX_ASCII_RESTRICTED_CHARSET)\n#define ASCII_FOLD_RESTRICTED (get_regex_charset(RExC_flags)                 \\\n                                        == REGEX_ASCII_MORE_RESTRICTED_CHARSET)\n\n#define FOLD cBOOL(RExC_flags & RXf_PMf_FOLD)\n\n/* For programs that want to be strictly Unicode compatible by dying if any\n * attempt is made to match a non-Unicode code point against a Unicode\n * property.  */\n#define ALWAYS_WARN_SUPER  ckDEAD(packWARN(WARN_NON_UNICODE))\n\n#define OOB_NAMEDCLASS\t\t-1\n\n/* There is no code point that is out-of-bounds, so this is problematic.  But\n * its only current use is to initialize a variable that is always set before\n * looked at. */\n#define OOB_UNICODE\t\t0xDEADBEEF\n\n#define CHR_SVLEN(sv) (UTF ? sv_len_utf8(sv) : SvCUR(sv))\n\n\n/* length of regex to show in messages that don't mark a position within */\n#define RegexLengthToShowInErrorMessages 127\n\n/*\n * If MARKER[12] are adjusted, be sure to adjust the constants at the top\n * of t/op/regmesg.t, the tests in t/op/re_tests, and those in\n * op/pragma/warn/regcomp.\n */\n#define MARKER1 \"<-- HERE\"    /* marker as it appears in the description */\n#define MARKER2 \" <-- HERE \"  /* marker as it appears within the regex */\n\n#define REPORT_LOCATION \" in regex; marked by \" MARKER1    \\\n                        \" in m/%\" UTF8f MARKER2 \"%\" UTF8f \"/\"\n\n/* The code in this file in places uses one level of recursion with parsing\n * rebased to an alternate string constructed by us in memory.  This can take\n * the form of something that is completely different from the input, or\n * something that uses the input as part of the alternate.  In the first case,\n * there should be no possibility of an error, as we are in complete control of\n * the alternate string.  But in the second case we don't completely control\n * the input portion, so there may be errors in that.  Here's an example:\n *      /[abc\\x{DF}def]/ui\n * is handled specially because \\x{df} folds to a sequence of more than one\n * character: 'ss'.  What is done is to create and parse an alternate string,\n * which looks like this:\n *      /(?:\\x{DF}|[abc\\x{DF}def])/ui\n * where it uses the input unchanged in the middle of something it constructs,\n * which is a branch for the DF outside the character class, and clustering\n * parens around the whole thing. (It knows enough to skip the DF inside the\n * class while in this substitute parse.) 'abc' and 'def' may have errors that\n * need to be reported.  The general situation looks like this:\n *\n *                                       |<------- identical ------>|\n *              sI                       tI               xI       eI\n * Input:       ---------------------------------------------------------------\n * Constructed:         ---------------------------------------------------\n *                      sC               tC               xC       eC     EC\n *                                       |<------- identical ------>|\n *\n * sI..eI   is the portion of the input pattern we are concerned with here.\n * sC..EC   is the constructed substitute parse string.\n *  sC..tC  is constructed by us\n *  tC..eC  is an exact duplicate of the portion of the input pattern tI..eI.\n *          In the diagram, these are vertically aligned.\n *  eC..EC  is also constructed by us.\n * xC       is the position in the substitute parse string where we found a\n *          problem.\n * xI       is the position in the original pattern corresponding to xC.\n *\n * We want to display a message showing the real input string.  Thus we need to\n * translate from xC to xI.  We know that xC >= tC, since the portion of the\n * string sC..tC has been constructed by us, and so shouldn't have errors.  We\n * get:\n *      xI = tI + (xC - tC)\n *\n * When the substitute parse is constructed, the code needs to set:\n *      RExC_start (sC)\n *      RExC_end (eC)\n *      RExC_copy_start_in_input  (tI)\n *      RExC_copy_start_in_constructed (tC)\n * and restore them when done.\n *\n * During normal processing of the input pattern, both\n * 'RExC_copy_start_in_input' and 'RExC_copy_start_in_constructed' are set to\n * sI, so that xC equals xI.\n */\n\n#define sI              RExC_precomp\n#define eI              RExC_precomp_end\n#define sC              RExC_start\n#define eC              RExC_end\n#define tI              RExC_copy_start_in_input\n#define tC              RExC_copy_start_in_constructed\n#define xI(xC)          (tI + (xC - tC))\n#define xI_offset(xC)   (xI(xC) - sI)\n\n#define REPORT_LOCATION_ARGS(xC)                                            \\\n    UTF8fARG(UTF,                                                           \\\n             (xI(xC) > eI) /* Don't run off end */                          \\\n              ? eI - sI   /* Length before the <--HERE */                   \\\n              : ((xI_offset(xC) >= 0)                                       \\\n                 ? xI_offset(xC)                                            \\\n                 : (Perl_croak(aTHX_ \"panic: %s: %d: negative offset: %\"    \\\n                                    IVdf \" trying to output message for \"   \\\n                                    \" pattern %.*s\",                        \\\n                                    __FILE__, __LINE__, (IV) xI_offset(xC), \\\n                                    ((int) (eC - sC)), sC), 0)),            \\\n             sI),         /* The input pattern printed up to the <--HERE */ \\\n    UTF8fARG(UTF,                                                           \\\n             (xI(xC) > eI) ? 0 : eI - xI(xC), /* Length after <--HERE */    \\\n             (xI(xC) > eI) ? eI : xI(xC))     /* pattern after <--HERE */\n\n/* Used to point after bad bytes for an error message, but avoid skipping\n * past a nul byte. */\n#define SKIP_IF_CHAR(s, e) (!*(s) ? 0 : UTF ? UTF8_SAFE_SKIP(s, e) : 1)\n\n/* Set up to clean up after our imminent demise */\n#define PREPARE_TO_DIE                                                      \\\n    STMT_START {\t\t\t\t\t                    \\\n        if (RExC_rx_sv)                                                     \\\n            SAVEFREESV(RExC_rx_sv);                                         \\\n        if (RExC_open_parens)                                               \\\n            SAVEFREEPV(RExC_open_parens);                                   \\\n        if (RExC_close_parens)                                              \\\n            SAVEFREEPV(RExC_close_parens);                                  \\\n    } STMT_END\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then calls Perl_croak with the given\n * arg. Show regex, up to a maximum length. If it's too long, chop and add\n * \"...\".\n */\n#define _FAIL(code) STMT_START {\t\t\t\t\t\\\n    const char *ellipses = \"\";\t\t\t\t\t\t\\\n    IV len = RExC_precomp_end - RExC_precomp;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    PREPARE_TO_DIE;\t\t\t\t\t\t        \\\n    if (len > RegexLengthToShowInErrorMessages) {\t\t\t\\\n\t/* chop 10 shorter than the max, to ensure meaning of \"...\" */\t\\\n\tlen = RegexLengthToShowInErrorMessages - 10;\t\t\t\\\n\tellipses = \"...\";\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n    code;                                                               \\\n} STMT_END\n\n#define\tFAIL(msg) _FAIL(\t\t\t    \\\n    Perl_croak(aTHX_ \"%s in regex m/%\" UTF8f \"%s/\",\t    \\\n\t    msg, UTF8fARG(UTF, len, RExC_precomp), ellipses))\n\n#define\tFAIL2(msg,arg) _FAIL(\t\t\t    \\\n    Perl_croak(aTHX_ msg \" in regex m/%\" UTF8f \"%s/\",\t    \\\n\t    arg, UTF8fARG(UTF, len, RExC_precomp), ellipses))\n\n/*\n * Simple_vFAIL -- like FAIL, but marks the current location in the scan\n */\n#define\tSimple_vFAIL(m) STMT_START {\t\t\t\t\t\\\n    Perl_croak(aTHX_ \"%s\" REPORT_LOCATION,\t\t\t\t\\\n\t    m, REPORT_LOCATION_ARGS(RExC_parse));\t                \\\n} STMT_END\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL()\n */\n#define\tvFAIL(m) STMT_START {\t\t\t\t\\\n    PREPARE_TO_DIE;                                     \\\n    Simple_vFAIL(m);\t\t\t\t\t\\\n} STMT_END\n\n/*\n * Like Simple_vFAIL(), but accepts two arguments.\n */\n#define\tSimple_vFAIL2(m,a1) STMT_START {\t\t\t\\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1,\t\t\\\n                      REPORT_LOCATION_ARGS(RExC_parse));\t\\\n} STMT_END\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL2().\n */\n#define\tvFAIL2(m,a1) STMT_START {\t\t\t\\\n    PREPARE_TO_DIE;                                     \\\n    Simple_vFAIL2(m, a1);\t\t\t\t\\\n} STMT_END\n\n\n/*\n * Like Simple_vFAIL(), but accepts three arguments.\n */\n#define\tSimple_vFAIL3(m, a1, a2) STMT_START {\t\t\t\\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2,\t\t\\\n\t    REPORT_LOCATION_ARGS(RExC_parse));\t                \\\n} STMT_END\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL3().\n */\n#define\tvFAIL3(m,a1,a2) STMT_START {\t\t\t\\\n    PREPARE_TO_DIE;                                     \\\n    Simple_vFAIL3(m, a1, a2);\t\t\t\t\\\n} STMT_END\n\n/*\n * Like Simple_vFAIL(), but accepts four arguments.\n */\n#define\tSimple_vFAIL4(m, a1, a2, a3) STMT_START {\t\t\\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2, a3,\t\\\n\t    REPORT_LOCATION_ARGS(RExC_parse));\t                \\\n} STMT_END\n\n#define\tvFAIL4(m,a1,a2,a3) STMT_START {\t\t\t\\\n    PREPARE_TO_DIE;                                     \\\n    Simple_vFAIL4(m, a1, a2, a3);\t\t\t\\\n} STMT_END\n\n/* A specialized version of vFAIL2 that works with UTF8f */\n#define vFAIL2utf8f(m, a1) STMT_START {             \\\n    PREPARE_TO_DIE;                                 \\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1,  \\\n            REPORT_LOCATION_ARGS(RExC_parse));      \\\n} STMT_END\n\n#define vFAIL3utf8f(m, a1, a2) STMT_START {             \\\n    PREPARE_TO_DIE;                                     \\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2,  \\\n            REPORT_LOCATION_ARGS(RExC_parse));          \\\n} STMT_END\n\n/* Setting this to NULL is a signal to not output warnings */\n#define TURN_OFF_WARNINGS_IN_SUBSTITUTE_PARSE                               \\\n    STMT_START {                                                            \\\n      RExC_save_copy_start_in_constructed  = RExC_copy_start_in_constructed;\\\n      RExC_copy_start_in_constructed = NULL;                                \\\n    } STMT_END\n#define RESTORE_WARNINGS                                                    \\\n    RExC_copy_start_in_constructed = RExC_save_copy_start_in_constructed\n\n/* Since a warning can be generated multiple times as the input is reparsed, we\n * output it the first time we come to that point in the parse, but suppress it\n * otherwise.  'RExC_copy_start_in_constructed' being NULL is a flag to not\n * generate any warnings */\n#define TO_OUTPUT_WARNINGS(loc)                                         \\\n  (   RExC_copy_start_in_constructed                                    \\\n   && ((xI(loc)) - RExC_precomp) > (Ptrdiff_t) RExC_latest_warn_offset)\n\n/* After we've emitted a warning, we save the position in the input so we don't\n * output it again */\n#define UPDATE_WARNINGS_LOC(loc)                                        \\\n    STMT_START {                                                        \\\n        if (TO_OUTPUT_WARNINGS(loc)) {                                  \\\n            RExC_latest_warn_offset = MAX(sI, MIN(eI, xI(loc)))         \\\n                                                       - RExC_precomp;  \\\n        }                                                               \\\n    } STMT_END\n\n/* 'warns' is the output of the packWARNx macro used in 'code' */\n#define _WARN_HELPER(loc, warns, code)                                  \\\n    STMT_START {                                                        \\\n        if (! RExC_copy_start_in_constructed) {                         \\\n            Perl_croak( aTHX_ \"panic! %s: %d: Tried to warn when none\"  \\\n                              \" expected at '%s'\",                      \\\n                              __FILE__, __LINE__, loc);                 \\\n        }                                                               \\\n        if (TO_OUTPUT_WARNINGS(loc)) {                                  \\\n            if (ckDEAD(warns))                                          \\\n                PREPARE_TO_DIE;                                         \\\n            code;                                                       \\\n            UPDATE_WARNINGS_LOC(loc);                                   \\\n        }                                                               \\\n    } STMT_END\n\n/* m is not necessarily a \"literal string\", in this macro */\n#define reg_warn_non_literal_string(loc, m)                             \\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                            \\\n                      Perl_warner(aTHX_ packWARN(WARN_REGEXP),          \\\n                                       \"%s\" REPORT_LOCATION,            \\\n                                  m, REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARNreg(loc,m) \t\t\t\t\t        \\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                            \\\n                      Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),       \\\n                                          m REPORT_LOCATION,\t        \\\n\t                                  REPORT_LOCATION_ARGS(loc)))\n\n#define\tvWARN(loc, m)           \t\t\t\t        \\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                            \\\n                      Perl_warner(aTHX_ packWARN(WARN_REGEXP),          \\\n                                       m REPORT_LOCATION,               \\\n                                       REPORT_LOCATION_ARGS(loc)))      \\\n\n#define\tvWARN_dep(loc, m)           \t\t\t\t        \\\n    _WARN_HELPER(loc, packWARN(WARN_DEPRECATED),                        \\\n                      Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),      \\\n                                       m REPORT_LOCATION,               \\\n\t                               REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARNdep(loc,m)            \t\t\t\t        \\\n    _WARN_HELPER(loc, packWARN(WARN_DEPRECATED),                        \\\n                      Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED), \\\n\t                                    m REPORT_LOCATION,          \\\n\t                                    REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARNregdep(loc,m)             \t\t\t\t    \\\n    _WARN_HELPER(loc, packWARN2(WARN_DEPRECATED, WARN_REGEXP),              \\\n                      Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED,     \\\n                                                      WARN_REGEXP),         \\\n\t                                     m REPORT_LOCATION,             \\\n\t                                     REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARN2reg_d(loc,m, a1)             \t\t\t\t    \\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                                \\\n                      Perl_ck_warner_d(aTHX_ packWARN(WARN_REGEXP),         \\\n\t                                    m REPORT_LOCATION,              \\\n\t                                    a1, REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARN2reg(loc, m, a1)                                              \\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                                \\\n                      Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),           \\\n                                          m REPORT_LOCATION,\t            \\\n                                          a1, REPORT_LOCATION_ARGS(loc)))\n\n#define\tvWARN3(loc, m, a1, a2)          \t\t\t\t    \\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                                \\\n                      Perl_warner(aTHX_ packWARN(WARN_REGEXP),              \\\n                                       m REPORT_LOCATION,                   \\\n\t                               a1, a2, REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARN3reg(loc, m, a1, a2)          \t\t\t\t    \\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                                \\\n                      Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),           \\\n                                          m REPORT_LOCATION,                \\\n\t                                  a1, a2,                           \\\n                                          REPORT_LOCATION_ARGS(loc)))\n\n#define\tvWARN4(loc, m, a1, a2, a3)          \t\t\t\t\\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                            \\\n                      Perl_warner(aTHX_ packWARN(WARN_REGEXP),          \\\n                                       m REPORT_LOCATION,               \\\n\t                               a1, a2, a3,                      \\\n                                       REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARN4reg(loc, m, a1, a2, a3)          \t\t\t\\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                            \\\n                      Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),       \\\n                                          m REPORT_LOCATION,            \\\n\t                                  a1, a2, a3,                   \\\n                                          REPORT_LOCATION_ARGS(loc)))\n\n#define\tvWARN5(loc, m, a1, a2, a3, a4)          \t\t\t\\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                            \\\n                      Perl_warner(aTHX_ packWARN(WARN_REGEXP),          \\\n                                       m REPORT_LOCATION,\t\t\\\n\t                               a1, a2, a3, a4,                  \\\n                                       REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARNexperimental(loc, class, m)                               \\\n    _WARN_HELPER(loc, packWARN(class),                                  \\\n                      Perl_ck_warner_d(aTHX_ packWARN(class),           \\\n                                            m REPORT_LOCATION,          \\\n                                            REPORT_LOCATION_ARGS(loc)))\n\n/* Convert between a pointer to a node and its offset from the beginning of the\n * program */\n#define REGNODE_p(offset)    (RExC_emit_start + (offset))\n#define REGNODE_OFFSET(node) ((node) - RExC_emit_start)\n\n/* Macros for recording node offsets.   20001227 mjd@plover.com\n * Nodes are numbered 1, 2, 3, 4.  Node #n's position is recorded in\n * element 2*n-1 of the array.  Element #2n holds the byte length node #n.\n * Element 0 holds the number n.\n * Position is 1 indexed.\n */\n#ifndef RE_TRACK_PATTERN_OFFSETS\n#define Set_Node_Offset_To_R(offset,byte)\n#define Set_Node_Offset(node,byte)\n#define Set_Cur_Node_Offset\n#define Set_Node_Length_To_R(node,len)\n#define Set_Node_Length(node,len)\n#define Set_Node_Cur_Length(node,start)\n#define Node_Offset(n)\n#define Node_Length(n)\n#define Set_Node_Offset_Length(node,offset,len)\n#define ProgLen(ri) ri->u.proglen\n#define SetProgLen(ri,x) ri->u.proglen = x\n#define Track_Code(code)\n#else\n#define ProgLen(ri) ri->u.offsets[0]\n#define SetProgLen(ri,x) ri->u.offsets[0] = x\n#define Set_Node_Offset_To_R(offset,byte) STMT_START {\t\t\t\\\n\tMJD_OFFSET_DEBUG((\"** (%d) offset of node %d is %d.\\n\",\t\t\\\n\t\t    __LINE__, (int)(offset), (int)(byte)));\t\t\\\n\tif((offset) < 0) {\t\t\t\t\t\t\\\n\t    Perl_croak(aTHX_ \"value of node is %d in Offset macro\",     \\\n                                         (int)(offset));                \\\n\t} else {\t\t\t\t\t\t\t\\\n            RExC_offsets[2*(offset)-1] = (byte);\t                \\\n\t}\t\t\t\t\t\t\t\t\\\n} STMT_END\n\n#define Set_Node_Offset(node,byte)                                      \\\n    Set_Node_Offset_To_R(REGNODE_OFFSET(node), (byte)-RExC_start)\n#define Set_Cur_Node_Offset Set_Node_Offset(RExC_emit, RExC_parse)\n\n#define Set_Node_Length_To_R(node,len) STMT_START {\t\t\t\\\n\tMJD_OFFSET_DEBUG((\"** (%d) size of node %d is %d.\\n\",\t\t\\\n\t\t__LINE__, (int)(node), (int)(len)));\t\t\t\\\n\tif((node) < 0) {\t\t\t\t\t\t\\\n\t    Perl_croak(aTHX_ \"value of node is %d in Length macro\",     \\\n                                         (int)(node));                  \\\n\t} else {\t\t\t\t\t\t\t\\\n\t    RExC_offsets[2*(node)] = (len);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} STMT_END\n\n#define Set_Node_Length(node,len) \\\n    Set_Node_Length_To_R(REGNODE_OFFSET(node), len)\n#define Set_Node_Cur_Length(node, start)                \\\n    Set_Node_Length(node, RExC_parse - start)\n\n/* Get offsets and lengths */\n#define Node_Offset(n) (RExC_offsets[2*(REGNODE_OFFSET(n))-1])\n#define Node_Length(n) (RExC_offsets[2*(REGNODE_OFFSET(n))])\n\n#define Set_Node_Offset_Length(node,offset,len) STMT_START {\t\\\n    Set_Node_Offset_To_R(REGNODE_OFFSET(node), (offset));\t\\\n    Set_Node_Length_To_R(REGNODE_OFFSET(node), (len));\t\\\n} STMT_END\n\n#define Track_Code(code) STMT_START { code } STMT_END\n#endif\n\n#if PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS\n#define EXPERIMENTAL_INPLACESCAN\n#endif /*PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS*/\n\n#ifdef DEBUGGING\nint\nPerl_re_printf(pTHX_ const char *fmt, ...)\n{\n    va_list ap;\n    int result;\n    PerlIO *f= Perl_debug_log;\n    PERL_ARGS_ASSERT_RE_PRINTF;\n    va_start(ap, fmt);\n    result = PerlIO_vprintf(f, fmt, ap);\n    va_end(ap);\n    return result;\n}\n\nint\nPerl_re_indentf(pTHX_ const char *fmt, U32 depth, ...)\n{\n    va_list ap;\n    int result;\n    PerlIO *f= Perl_debug_log;\n    PERL_ARGS_ASSERT_RE_INDENTF;\n    va_start(ap, depth);\n    PerlIO_printf(f, \"%*s\", ( (int)depth % 20 ) * 2, \"\");\n    result = PerlIO_vprintf(f, fmt, ap);\n    va_end(ap);\n    return result;\n}\n#endif /* DEBUGGING */\n\n#define DEBUG_RExC_seen()                                                   \\\n        DEBUG_OPTIMISE_MORE_r({                                             \\\n            Perl_re_printf( aTHX_ \"RExC_seen: \");                           \\\n                                                                            \\\n            if (RExC_seen & REG_ZERO_LEN_SEEN)                              \\\n                Perl_re_printf( aTHX_ \"REG_ZERO_LEN_SEEN \");                \\\n                                                                            \\\n            if (RExC_seen & REG_LOOKBEHIND_SEEN)                            \\\n                Perl_re_printf( aTHX_ \"REG_LOOKBEHIND_SEEN \");              \\\n                                                                            \\\n            if (RExC_seen & REG_GPOS_SEEN)                                  \\\n                Perl_re_printf( aTHX_ \"REG_GPOS_SEEN \");                    \\\n                                                                            \\\n            if (RExC_seen & REG_RECURSE_SEEN)                               \\\n                Perl_re_printf( aTHX_ \"REG_RECURSE_SEEN \");                 \\\n                                                                            \\\n            if (RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)                    \\\n                Perl_re_printf( aTHX_ \"REG_TOP_LEVEL_BRANCHES_SEEN \");      \\\n                                                                            \\\n            if (RExC_seen & REG_VERBARG_SEEN)                               \\\n                Perl_re_printf( aTHX_ \"REG_VERBARG_SEEN \");                 \\\n                                                                            \\\n            if (RExC_seen & REG_CUTGROUP_SEEN)                              \\\n                Perl_re_printf( aTHX_ \"REG_CUTGROUP_SEEN \");                \\\n                                                                            \\\n            if (RExC_seen & REG_RUN_ON_COMMENT_SEEN)                        \\\n                Perl_re_printf( aTHX_ \"REG_RUN_ON_COMMENT_SEEN \");          \\\n                                                                            \\\n            if (RExC_seen & REG_UNFOLDED_MULTI_SEEN)                        \\\n                Perl_re_printf( aTHX_ \"REG_UNFOLDED_MULTI_SEEN \");          \\\n                                                                            \\\n            if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)                  \\\n                Perl_re_printf( aTHX_ \"REG_UNBOUNDED_QUANTIFIER_SEEN \");    \\\n                                                                            \\\n            Perl_re_printf( aTHX_ \"\\n\");                                    \\\n        });\n\n#define DEBUG_SHOW_STUDY_FLAG(flags,flag) \\\n  if ((flags) & flag) Perl_re_printf( aTHX_  \"%s \", #flag)\n\n\n#ifdef DEBUGGING\nstatic void\nS_debug_show_study_flags(pTHX_ U32 flags, const char *open_str,\n                                    const char *close_str)\n{\n    if (!flags)\n        return;\n\n    Perl_re_printf( aTHX_  \"%s\", open_str);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_BEFORE_SEOL);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_BEFORE_MEOL);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_IS_INF);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_HAS_PAR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_IN_PAR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_HAS_EVAL);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_SUBSTR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_STCLASS_AND);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_STCLASS_OR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_STCLASS);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_WHILEM_VISITED_POS);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_TRIE_RESTUDY);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_SEEN_ACCEPT);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_TRIE_DOING_RESTUDY);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_IN_DEFINE);\n    Perl_re_printf( aTHX_  \"%s\", close_str);\n}\n\n\nstatic void\nS_debug_studydata(pTHX_ const char *where, scan_data_t *data,\n                    U32 depth, int is_inf)\n{\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    DEBUG_OPTIMISE_MORE_r({\n        if (!data)\n            return;\n        Perl_re_indentf(aTHX_  \"%s: Pos:%\" IVdf \"/%\" IVdf \" Flags: 0x%\" UVXf,\n            depth,\n            where,\n            (IV)data->pos_min,\n            (IV)data->pos_delta,\n            (UV)data->flags\n        );\n\n        S_debug_show_study_flags(aTHX_ data->flags,\" [\",\"]\");\n\n        Perl_re_printf( aTHX_\n            \" Whilem_c: %\" IVdf \" Lcp: %\" IVdf \" %s\",\n            (IV)data->whilem_c,\n            (IV)(data->last_closep ? *((data)->last_closep) : -1),\n            is_inf ? \"INF \" : \"\"\n        );\n\n        if (data->last_found) {\n            int i;\n            Perl_re_printf(aTHX_\n                \"Last:'%s' %\" IVdf \":%\" IVdf \"/%\" IVdf,\n                    SvPVX_const(data->last_found),\n                    (IV)data->last_end,\n                    (IV)data->last_start_min,\n                    (IV)data->last_start_max\n            );\n\n            for (i = 0; i < 2; i++) {\n                Perl_re_printf(aTHX_\n                    \" %s%s: '%s' @ %\" IVdf \"/%\" IVdf,\n                    data->cur_is_floating == i ? \"*\" : \"\",\n                    i ? \"Float\" : \"Fixed\",\n                    SvPVX_const(data->substrs[i].str),\n                    (IV)data->substrs[i].min_offset,\n                    (IV)data->substrs[i].max_offset\n                );\n                S_debug_show_study_flags(aTHX_ data->substrs[i].flags,\" [\",\"]\");\n            }\n        }\n\n        Perl_re_printf( aTHX_ \"\\n\");\n    });\n}\n\n\nstatic void\nS_debug_peep(pTHX_ const char *str, const RExC_state_t *pRExC_state,\n                regnode *scan, U32 depth, U32 flags)\n{\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    DEBUG_OPTIMISE_r({\n        regnode *Next;\n\n        if (!scan)\n            return;\n        Next = regnext(scan);\n        regprop(RExC_rx, RExC_mysv, scan, NULL, pRExC_state);\n        Perl_re_indentf( aTHX_   \"%s>%3d: %s (%d)\",\n            depth,\n            str,\n            REG_NODE_NUM(scan), SvPV_nolen_const(RExC_mysv),\n            Next ? (REG_NODE_NUM(Next)) : 0 );\n        S_debug_show_study_flags(aTHX_ flags,\" [ \",\"]\");\n        Perl_re_printf( aTHX_  \"\\n\");\n   });\n}\n\n\n#  define DEBUG_STUDYDATA(where, data, depth, is_inf) \\\n                    S_debug_studydata(aTHX_ where, data, depth, is_inf)\n\n#  define DEBUG_PEEP(str, scan, depth, flags)   \\\n                    S_debug_peep(aTHX_ str, pRExC_state, scan, depth, flags)\n\n#else\n#  define DEBUG_STUDYDATA(where, data, depth, is_inf) NOOP\n#  define DEBUG_PEEP(str, scan, depth, flags)         NOOP\n#endif\n\n\n/* =========================================================\n * BEGIN edit_distance stuff.\n *\n * This calculates how many single character changes of any type are needed to\n * transform a string into another one.  It is taken from version 3.1 of\n *\n * https://metacpan.org/pod/Text::Levenshtein::Damerau::XS\n */\n\n/* Our unsorted dictionary linked list.   */\n/* Note we use UVs, not chars. */\n\nstruct dictionary{\n  UV key;\n  UV value;\n  struct dictionary* next;\n};\ntypedef struct dictionary item;\n\n\nPERL_STATIC_INLINE item*\npush(UV key, item* curr)\n{\n    item* head;\n    Newx(head, 1, item);\n    head->key = key;\n    head->value = 0;\n    head->next = curr;\n    return head;\n}\n\n\nPERL_STATIC_INLINE item*\nfind(item* head, UV key)\n{\n    item* iterator = head;\n    while (iterator){\n        if (iterator->key == key){\n            return iterator;\n        }\n        iterator = iterator->next;\n    }\n\n    return NULL;\n}\n\nPERL_STATIC_INLINE item*\nuniquePush(item* head, UV key)\n{\n    item* iterator = head;\n\n    while (iterator){\n        if (iterator->key == key) {\n            return head;\n        }\n        iterator = iterator->next;\n    }\n\n    return push(key, head);\n}\n\nPERL_STATIC_INLINE void\ndict_free(item* head)\n{\n    item* iterator = head;\n\n    while (iterator) {\n        item* temp = iterator;\n        iterator = iterator->next;\n        Safefree(temp);\n    }\n\n    head = NULL;\n}\n\n/* End of Dictionary Stuff */\n\n/* All calculations/work are done here */\nSTATIC int\nS_edit_distance(const UV* src,\n                const UV* tgt,\n                const STRLEN x,             /* length of src[] */\n                const STRLEN y,             /* length of tgt[] */\n                const SSize_t maxDistance\n)\n{\n    item *head = NULL;\n    UV swapCount, swapScore, targetCharCount, i, j;\n    UV *scores;\n    UV score_ceil = x + y;\n\n    PERL_ARGS_ASSERT_EDIT_DISTANCE;\n\n    /* intialize matrix start values */\n    Newx(scores, ( (x + 2) * (y + 2)), UV);\n    scores[0] = score_ceil;\n    scores[1 * (y + 2) + 0] = score_ceil;\n    scores[0 * (y + 2) + 1] = score_ceil;\n    scores[1 * (y + 2) + 1] = 0;\n    head = uniquePush(uniquePush(head, src[0]), tgt[0]);\n\n    /* work loops    */\n    /* i = src index */\n    /* j = tgt index */\n    for (i=1;i<=x;i++) {\n        if (i < x)\n            head = uniquePush(head, src[i]);\n        scores[(i+1) * (y + 2) + 1] = i;\n        scores[(i+1) * (y + 2) + 0] = score_ceil;\n        swapCount = 0;\n\n        for (j=1;j<=y;j++) {\n            if (i == 1) {\n                if(j < y)\n                head = uniquePush(head, tgt[j]);\n                scores[1 * (y + 2) + (j + 1)] = j;\n                scores[0 * (y + 2) + (j + 1)] = score_ceil;\n            }\n\n            targetCharCount = find(head, tgt[j-1])->value;\n            swapScore = scores[targetCharCount * (y + 2) + swapCount] + i - targetCharCount - 1 + j - swapCount;\n\n            if (src[i-1] != tgt[j-1]){\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(swapScore,(MIN(scores[i * (y + 2) + j], MIN(scores[(i+1) * (y + 2) + j], scores[i * (y + 2) + (j + 1)])) + 1));\n            }\n            else {\n                swapCount = j;\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(scores[i * (y + 2) + j], swapScore);\n            }\n        }\n\n        find(head, src[i-1])->value = i;\n    }\n\n    {\n        IV score = scores[(x+1) * (y + 2) + (y + 1)];\n        dict_free(head);\n        Safefree(scores);\n        return (maxDistance != 0 && maxDistance < score)?(-1):score;\n    }\n}\n\n/* END of edit_distance() stuff\n * ========================================================= */\n\n/* is c a control character for which we have a mnemonic? */\n#define isMNEMONIC_CNTRL(c) _IS_MNEMONIC_CNTRL_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)\n\nSTATIC const char *\nS_cntrl_to_mnemonic(const U8 c)\n{\n    /* Returns the mnemonic string that represents character 'c', if one\n     * exists; NULL otherwise.  The only ones that exist for the purposes of\n     * this routine are a few control characters */\n\n    switch (c) {\n        case '\\a':       return \"\\\\a\";\n        case '\\b':       return \"\\\\b\";\n        case ESC_NATIVE: return \"\\\\e\";\n        case '\\f':       return \"\\\\f\";\n        case '\\n':       return \"\\\\n\";\n        case '\\r':       return \"\\\\r\";\n        case '\\t':       return \"\\\\t\";\n    }\n\n    return NULL;\n}\n\n/* Mark that we cannot extend a found fixed substring at this point.\n   Update the longest found anchored substring or the longest found\n   floating substrings if needed. */\n\nSTATIC void\nS_scan_commit(pTHX_ const RExC_state_t *pRExC_state, scan_data_t *data,\n                    SSize_t *minlenp, int is_inf)\n{\n    const STRLEN l = CHR_SVLEN(data->last_found);\n    SV * const longest_sv = data->substrs[data->cur_is_floating].str;\n    const STRLEN old_l = CHR_SVLEN(longest_sv);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_SCAN_COMMIT;\n\n    if ((l >= old_l) && ((l > old_l) || (data->flags & SF_BEFORE_EOL))) {\n        const U8 i = data->cur_is_floating;\n\tSvSetMagicSV(longest_sv, data->last_found);\n        data->substrs[i].min_offset = l ? data->last_start_min : data->pos_min;\n\n\tif (!i) /* fixed */\n\t    data->substrs[0].max_offset = data->substrs[0].min_offset;\n\telse { /* float */\n\t    data->substrs[1].max_offset = (l\n                          ? data->last_start_max\n                          : (data->pos_delta > SSize_t_MAX - data->pos_min\n\t\t\t\t\t ? SSize_t_MAX\n\t\t\t\t\t : data->pos_min + data->pos_delta));\n\t    if (is_inf\n\t\t || (STRLEN)data->substrs[1].max_offset > (STRLEN)SSize_t_MAX)\n\t\tdata->substrs[1].max_offset = SSize_t_MAX;\n        }\n\n        if (data->flags & SF_BEFORE_EOL)\n            data->substrs[i].flags |= (data->flags & SF_BEFORE_EOL);\n        else\n            data->substrs[i].flags &= ~SF_BEFORE_EOL;\n        data->substrs[i].minlenp = minlenp;\n        data->substrs[i].lookbehind = 0;\n    }\n\n    SvCUR_set(data->last_found, 0);\n    {\n\tSV * const sv = data->last_found;\n\tif (SvUTF8(sv) && SvMAGICAL(sv)) {\n\t    MAGIC * const mg = mg_find(sv, PERL_MAGIC_utf8);\n\t    if (mg)\n\t\tmg->mg_len = 0;\n\t}\n    }\n    data->last_end = -1;\n    data->flags &= ~SF_BEFORE_EOL;\n    DEBUG_STUDYDATA(\"commit\", data, 0, is_inf);\n}\n\n/* An SSC is just a regnode_charclass_posix with an extra field: the inversion\n * list that describes which code points it matches */\n\nSTATIC void\nS_ssc_anything(pTHX_ regnode_ssc *ssc)\n{\n    /* Set the SSC 'ssc' to match an empty string or any code point */\n\n    PERL_ARGS_ASSERT_SSC_ANYTHING;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* mortalize so won't leak */\n    ssc->invlist = sv_2mortal(_add_range_to_invlist(NULL, 0, UV_MAX));\n    ANYOF_FLAGS(ssc) |= SSC_MATCHES_EMPTY_STRING;  /* Plus matches empty */\n}\n\nSTATIC int\nS_ssc_is_anything(const regnode_ssc *ssc)\n{\n    /* Returns TRUE if the SSC 'ssc' can match the empty string and any code\n     * point; FALSE otherwise.  Thus, this is used to see if using 'ssc' buys\n     * us anything: if the function returns TRUE, 'ssc' hasn't been restricted\n     * in any way, so there's no point in using it */\n\n    UV start, end;\n    bool ret;\n\n    PERL_ARGS_ASSERT_SSC_IS_ANYTHING;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    if (! (ANYOF_FLAGS(ssc) & SSC_MATCHES_EMPTY_STRING)) {\n        return FALSE;\n    }\n\n    /* See if the list consists solely of the range 0 - Infinity */\n    invlist_iterinit(ssc->invlist);\n    ret = invlist_iternext(ssc->invlist, &start, &end)\n          && start == 0\n          && end == UV_MAX;\n\n    invlist_iterfinish(ssc->invlist);\n\n    if (ret) {\n        return TRUE;\n    }\n\n    /* If e.g., both \\w and \\W are set, matches everything */\n    if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n        int i;\n        for (i = 0; i < ANYOF_POSIXL_MAX; i += 2) {\n            if (ANYOF_POSIXL_TEST(ssc, i) && ANYOF_POSIXL_TEST(ssc, i+1)) {\n                return TRUE;\n            }\n        }\n    }\n\n    return FALSE;\n}\n\nSTATIC void\nS_ssc_init(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc)\n{\n    /* Initializes the SSC 'ssc'.  This includes setting it to match an empty\n     * string, any code point, or any posix class under locale */\n\n    PERL_ARGS_ASSERT_SSC_INIT;\n\n    Zero(ssc, 1, regnode_ssc);\n    set_ANYOF_SYNTHETIC(ssc);\n    ARG_SET(ssc, ANYOF_ONLY_HAS_BITMAP);\n    ssc_anything(ssc);\n\n    /* If any portion of the regex is to operate under locale rules that aren't\n     * fully known at compile time, initialization includes it.  The reason\n     * this isn't done for all regexes is that the optimizer was written under\n     * the assumption that locale was all-or-nothing.  Given the complexity and\n     * lack of documentation in the optimizer, and that there are inadequate\n     * test cases for locale, many parts of it may not work properly, it is\n     * safest to avoid locale unless necessary. */\n    if (RExC_contains_locale) {\n\tANYOF_POSIXL_SETALL(ssc);\n    }\n    else {\n\tANYOF_POSIXL_ZERO(ssc);\n    }\n}\n\nSTATIC int\nS_ssc_is_cp_posixl_init(const RExC_state_t *pRExC_state,\n                        const regnode_ssc *ssc)\n{\n    /* Returns TRUE if the SSC 'ssc' is in its initial state with regard only\n     * to the list of code points matched, and locale posix classes; hence does\n     * not check its flags) */\n\n    UV start, end;\n    bool ret;\n\n    PERL_ARGS_ASSERT_SSC_IS_CP_POSIXL_INIT;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    invlist_iterinit(ssc->invlist);\n    ret = invlist_iternext(ssc->invlist, &start, &end)\n          && start == 0\n          && end == UV_MAX;\n\n    invlist_iterfinish(ssc->invlist);\n\n    if (! ret) {\n        return FALSE;\n    }\n\n    if (RExC_contains_locale && ! ANYOF_POSIXL_SSC_TEST_ALL_SET(ssc)) {\n        return FALSE;\n    }\n\n    return TRUE;\n}\n\n#define INVLIST_INDEX 0\n#define ONLY_LOCALE_MATCHES_INDEX 1\n#define DEFERRED_USER_DEFINED_INDEX 2\n\nSTATIC SV*\nS_get_ANYOF_cp_list_for_ssc(pTHX_ const RExC_state_t *pRExC_state,\n                               const regnode_charclass* const node)\n{\n    /* Returns a mortal inversion list defining which code points are matched\n     * by 'node', which is of type ANYOF.  Handles complementing the result if\n     * appropriate.  If some code points aren't knowable at this time, the\n     * returned list must, and will, contain every code point that is a\n     * possibility. */\n\n    dVAR;\n    SV* invlist = NULL;\n    SV* only_utf8_locale_invlist = NULL;\n    unsigned int i;\n    const U32 n = ARG(node);\n    bool new_node_has_latin1 = FALSE;\n    const U8 flags = OP(node) == ANYOFH ? 0 : ANYOF_FLAGS(node);\n\n    PERL_ARGS_ASSERT_GET_ANYOF_CP_LIST_FOR_SSC;\n\n    /* Look at the data structure created by S_set_ANYOF_arg() */\n    if (n != ANYOF_ONLY_HAS_BITMAP) {\n        SV * const rv = MUTABLE_SV(RExC_rxi->data->data[n]);\n        AV * const av = MUTABLE_AV(SvRV(rv));\n        SV **const ary = AvARRAY(av);\n        assert(RExC_rxi->data->what[n] == 's');\n\n        if (av_tindex_skip_len_mg(av) >= DEFERRED_USER_DEFINED_INDEX) {\n\n            /* Here there are things that won't be known until runtime -- we\n             * have to assume it could be anything */\n            invlist = sv_2mortal(_new_invlist(1));\n            return _add_range_to_invlist(invlist, 0, UV_MAX);\n        }\n        else if (ary[INVLIST_INDEX]) {\n\n            /* Use the node's inversion list */\n            invlist = sv_2mortal(invlist_clone(ary[INVLIST_INDEX], NULL));\n        }\n\n        /* Get the code points valid only under UTF-8 locales */\n        if (   (flags & ANYOFL_FOLD)\n            &&  av_tindex_skip_len_mg(av) >= ONLY_LOCALE_MATCHES_INDEX)\n        {\n            only_utf8_locale_invlist = ary[ONLY_LOCALE_MATCHES_INDEX];\n        }\n    }\n\n    if (! invlist) {\n        invlist = sv_2mortal(_new_invlist(0));\n    }\n\n    /* An ANYOF node contains a bitmap for the first NUM_ANYOF_CODE_POINTS\n     * code points, and an inversion list for the others, but if there are code\n     * points that should match only conditionally on the target string being\n     * UTF-8, those are placed in the inversion list, and not the bitmap.\n     * Since there are circumstances under which they could match, they are\n     * included in the SSC.  But if the ANYOF node is to be inverted, we have\n     * to exclude them here, so that when we invert below, the end result\n     * actually does include them.  (Think about \"\\xe0\" =~ /[^\\xc0]/di;).  We\n     * have to do this here before we add the unconditionally matched code\n     * points */\n    if (flags & ANYOF_INVERT) {\n        _invlist_intersection_complement_2nd(invlist,\n                                             PL_UpperLatin1,\n                                             &invlist);\n    }\n\n    /* Add in the points from the bit map */\n    if (OP(node) != ANYOFH) {\n        for (i = 0; i < NUM_ANYOF_CODE_POINTS; i++) {\n            if (ANYOF_BITMAP_TEST(node, i)) {\n                unsigned int start = i++;\n\n                for (;    i < NUM_ANYOF_CODE_POINTS\n                       && ANYOF_BITMAP_TEST(node, i); ++i)\n                {\n                    /* empty */\n                }\n                invlist = _add_range_to_invlist(invlist, start, i-1);\n                new_node_has_latin1 = TRUE;\n            }\n        }\n    }\n\n    /* If this can match all upper Latin1 code points, have to add them\n     * as well.  But don't add them if inverting, as when that gets done below,\n     * it would exclude all these characters, including the ones it shouldn't\n     * that were added just above */\n    if (! (flags & ANYOF_INVERT) && OP(node) == ANYOFD\n        && (flags & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER))\n    {\n        _invlist_union(invlist, PL_UpperLatin1, &invlist);\n    }\n\n    /* Similarly for these */\n    if (flags & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {\n        _invlist_union_complement_2nd(invlist, PL_InBitmap, &invlist);\n    }\n\n    if (flags & ANYOF_INVERT) {\n        _invlist_invert(invlist);\n    }\n    else if (flags & ANYOFL_FOLD) {\n        if (new_node_has_latin1) {\n\n            /* Under /li, any 0-255 could fold to any other 0-255, depending on\n             * the locale.  We can skip this if there are no 0-255 at all. */\n            _invlist_union(invlist, PL_Latin1, &invlist);\n\n            invlist = add_cp_to_invlist(invlist, LATIN_SMALL_LETTER_DOTLESS_I);\n            invlist = add_cp_to_invlist(invlist, LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE);\n        }\n        else {\n            if (_invlist_contains_cp(invlist, LATIN_SMALL_LETTER_DOTLESS_I)) {\n                invlist = add_cp_to_invlist(invlist, 'I');\n            }\n            if (_invlist_contains_cp(invlist,\n                                        LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE))\n            {\n                invlist = add_cp_to_invlist(invlist, 'i');\n            }\n        }\n    }\n\n    /* Similarly add the UTF-8 locale possible matches.  These have to be\n     * deferred until after the non-UTF-8 locale ones are taken care of just\n     * above, or it leads to wrong results under ANYOF_INVERT */\n    if (only_utf8_locale_invlist) {\n        _invlist_union_maybe_complement_2nd(invlist,\n                                            only_utf8_locale_invlist,\n                                            flags & ANYOF_INVERT,\n                                            &invlist);\n    }\n\n    return invlist;\n}\n\n/* These two functions currently do the exact same thing */\n#define ssc_init_zero\t\tssc_init\n\n#define ssc_add_cp(ssc, cp)   ssc_add_range((ssc), (cp), (cp))\n#define ssc_match_all_cp(ssc) ssc_add_range(ssc, 0, UV_MAX)\n\n/* 'AND' a given class with another one.  Can create false positives.  'ssc'\n * should not be inverted.  'and_with->flags & ANYOF_MATCHES_POSIXL' should be\n * 0 if 'and_with' is a regnode_charclass instead of a regnode_ssc. */\n\nSTATIC void\nS_ssc_and(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc,\n                const regnode_charclass *and_with)\n{\n    /* Accumulate into SSC 'ssc' its 'AND' with 'and_with', which is either\n     * another SSC or a regular ANYOF class.  Can create false positives. */\n\n    SV* anded_cp_list;\n    U8  and_with_flags = (OP(and_with) == ANYOFH) ? 0 : ANYOF_FLAGS(and_with);\n    U8  anded_flags;\n\n    PERL_ARGS_ASSERT_SSC_AND;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* 'and_with' is used as-is if it too is an SSC; otherwise have to extract\n     * the code point inversion list and just the relevant flags */\n    if (is_ANYOF_SYNTHETIC(and_with)) {\n        anded_cp_list = ((regnode_ssc *)and_with)->invlist;\n        anded_flags = and_with_flags;\n\n        /* XXX This is a kludge around what appears to be deficiencies in the\n         * optimizer.  If we make S_ssc_anything() add in the WARN_SUPER flag,\n         * there are paths through the optimizer where it doesn't get weeded\n         * out when it should.  And if we don't make some extra provision for\n         * it like the code just below, it doesn't get added when it should.\n         * This solution is to add it only when AND'ing, which is here, and\n         * only when what is being AND'ed is the pristine, original node\n         * matching anything.  Thus it is like adding it to ssc_anything() but\n         * only when the result is to be AND'ed.  Probably the same solution\n         * could be adopted for the same problem we have with /l matching,\n         * which is solved differently in S_ssc_init(), and that would lead to\n         * fewer false positives than that solution has.  But if this solution\n         * creates bugs, the consequences are only that a warning isn't raised\n         * that should be; while the consequences for having /l bugs is\n         * incorrect matches */\n        if (ssc_is_anything((regnode_ssc *)and_with)) {\n            anded_flags |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;\n        }\n    }\n    else {\n        anded_cp_list = get_ANYOF_cp_list_for_ssc(pRExC_state, and_with);\n        if (OP(and_with) == ANYOFD) {\n            anded_flags = and_with_flags & ANYOF_COMMON_FLAGS;\n        }\n        else {\n            anded_flags = and_with_flags\n            &( ANYOF_COMMON_FLAGS\n              |ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER\n              |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP);\n            if (ANYOFL_UTF8_LOCALE_REQD(and_with_flags)) {\n                anded_flags &=\n                    ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n            }\n        }\n    }\n\n    ANYOF_FLAGS(ssc) &= anded_flags;\n\n    /* Below, C1 is the list of code points in 'ssc'; P1, its posix classes.\n     * C2 is the list of code points in 'and-with'; P2, its posix classes.\n     * 'and_with' may be inverted.  When not inverted, we have the situation of\n     * computing:\n     *  (C1 | P1) & (C2 | P2)\n     *                     =  (C1 & (C2 | P2)) | (P1 & (C2 | P2))\n     *                     =  ((C1 & C2) | (C1 & P2)) | ((P1 & C2) | (P1 & P2))\n     *                    <=  ((C1 & C2) |       P2)) | ( P1       | (P1 & P2))\n     *                    <=  ((C1 & C2) | P1 | P2)\n     * Alternatively, the last few steps could be:\n     *                     =  ((C1 & C2) | (C1 & P2)) | ((P1 & C2) | (P1 & P2))\n     *                    <=  ((C1 & C2) |  C1      ) | (      C2  | (P1 & P2))\n     *                    <=  (C1 | C2 | (P1 & P2))\n     * We favor the second approach if either P1 or P2 is non-empty.  This is\n     * because these components are a barrier to doing optimizations, as what\n     * they match cannot be known until the moment of matching as they are\n     * dependent on the current locale, 'AND\"ing them likely will reduce or\n     * eliminate them.\n     * But we can do better if we know that C1,P1 are in their initial state (a\n     * frequent occurrence), each matching everything:\n     *  (<everything>) & (C2 | P2) =  C2 | P2\n     * Similarly, if C2,P2 are in their initial state (again a frequent\n     * occurrence), the result is a no-op\n     *  (C1 | P1) & (<everything>) =  C1 | P1\n     *\n     * Inverted, we have\n     *  (C1 | P1) & ~(C2 | P2)  =  (C1 | P1) & (~C2 & ~P2)\n     *                          =  (C1 & (~C2 & ~P2)) | (P1 & (~C2 & ~P2))\n     *                         <=  (C1 & ~C2) | (P1 & ~P2)\n     * */\n\n    if ((and_with_flags & ANYOF_INVERT)\n        && ! is_ANYOF_SYNTHETIC(and_with))\n    {\n        unsigned int i;\n\n        ssc_intersection(ssc,\n                         anded_cp_list,\n                         FALSE /* Has already been inverted */\n                         );\n\n        /* If either P1 or P2 is empty, the intersection will be also; can skip\n         * the loop */\n        if (! (and_with_flags & ANYOF_MATCHES_POSIXL)) {\n            ANYOF_POSIXL_ZERO(ssc);\n        }\n        else if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n\n            /* Note that the Posix class component P from 'and_with' actually\n             * looks like:\n             *      P = Pa | Pb | ... | Pn\n             * where each component is one posix class, such as in [\\w\\s].\n             * Thus\n             *      ~P = ~(Pa | Pb | ... | Pn)\n             *         = ~Pa & ~Pb & ... & ~Pn\n             *        <= ~Pa | ~Pb | ... | ~Pn\n             * The last is something we can easily calculate, but unfortunately\n             * is likely to have many false positives.  We could do better\n             * in some (but certainly not all) instances if two classes in\n             * P have known relationships.  For example\n             *      :lower: <= :alpha: <= :alnum: <= \\w <= :graph: <= :print:\n             * So\n             *      :lower: & :print: = :lower:\n             * And similarly for classes that must be disjoint.  For example,\n             * since \\s and \\w can have no elements in common based on rules in\n             * the POSIX standard,\n             *      \\w & ^\\S = nothing\n             * Unfortunately, some vendor locales do not meet the Posix\n             * standard, in particular almost everything by Microsoft.\n             * The loop below just changes e.g., \\w into \\W and vice versa */\n\n            regnode_charclass_posixl temp;\n            int add = 1;    /* To calculate the index of the complement */\n\n            Zero(&temp, 1, regnode_charclass_posixl);\n            ANYOF_POSIXL_ZERO(&temp);\n            for (i = 0; i < ANYOF_MAX; i++) {\n                assert(i % 2 != 0\n                       || ! ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i)\n                       || ! ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i + 1));\n\n                if (ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i)) {\n                    ANYOF_POSIXL_SET(&temp, i + add);\n                }\n                add = 0 - add; /* 1 goes to -1; -1 goes to 1 */\n            }\n            ANYOF_POSIXL_AND(&temp, ssc);\n\n        } /* else ssc already has no posixes */\n    } /* else: Not inverted.  This routine is a no-op if 'and_with' is an SSC\n         in its initial state */\n    else if (! is_ANYOF_SYNTHETIC(and_with)\n             || ! ssc_is_cp_posixl_init(pRExC_state, (regnode_ssc *)and_with))\n    {\n        /* But if 'ssc' is in its initial state, the result is just 'and_with';\n         * copy it over 'ssc' */\n        if (ssc_is_cp_posixl_init(pRExC_state, ssc)) {\n            if (is_ANYOF_SYNTHETIC(and_with)) {\n                StructCopy(and_with, ssc, regnode_ssc);\n            }\n            else {\n                ssc->invlist = anded_cp_list;\n                ANYOF_POSIXL_ZERO(ssc);\n                if (and_with_flags & ANYOF_MATCHES_POSIXL) {\n                    ANYOF_POSIXL_OR((regnode_charclass_posixl*) and_with, ssc);\n                }\n            }\n        }\n        else if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)\n                 || (and_with_flags & ANYOF_MATCHES_POSIXL))\n        {\n            /* One or the other of P1, P2 is non-empty. */\n            if (and_with_flags & ANYOF_MATCHES_POSIXL) {\n                ANYOF_POSIXL_AND((regnode_charclass_posixl*) and_with, ssc);\n            }\n            ssc_union(ssc, anded_cp_list, FALSE);\n        }\n        else { /* P1 = P2 = empty */\n            ssc_intersection(ssc, anded_cp_list, FALSE);\n        }\n    }\n}\n\nSTATIC void\nS_ssc_or(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc,\n               const regnode_charclass *or_with)\n{\n    /* Accumulate into SSC 'ssc' its 'OR' with 'or_with', which is either\n     * another SSC or a regular ANYOF class.  Can create false positives if\n     * 'or_with' is to be inverted. */\n\n    SV* ored_cp_list;\n    U8 ored_flags;\n    U8  or_with_flags = (OP(or_with) == ANYOFH) ? 0 : ANYOF_FLAGS(or_with);\n\n    PERL_ARGS_ASSERT_SSC_OR;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* 'or_with' is used as-is if it too is an SSC; otherwise have to extract\n     * the code point inversion list and just the relevant flags */\n    if (is_ANYOF_SYNTHETIC(or_with)) {\n        ored_cp_list = ((regnode_ssc*) or_with)->invlist;\n        ored_flags = or_with_flags;\n    }\n    else {\n        ored_cp_list = get_ANYOF_cp_list_for_ssc(pRExC_state, or_with);\n        ored_flags = or_with_flags & ANYOF_COMMON_FLAGS;\n        if (OP(or_with) != ANYOFD) {\n            ored_flags\n            |= or_with_flags\n             & ( ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER\n                |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP);\n            if (ANYOFL_UTF8_LOCALE_REQD(or_with_flags)) {\n                ored_flags |=\n                    ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n            }\n        }\n    }\n\n    ANYOF_FLAGS(ssc) |= ored_flags;\n\n    /* Below, C1 is the list of code points in 'ssc'; P1, its posix classes.\n     * C2 is the list of code points in 'or-with'; P2, its posix classes.\n     * 'or_with' may be inverted.  When not inverted, we have the simple\n     * situation of computing:\n     *  (C1 | P1) | (C2 | P2)  =  (C1 | C2) | (P1 | P2)\n     * If P1|P2 yields a situation with both a class and its complement are\n     * set, like having both \\w and \\W, this matches all code points, and we\n     * can delete these from the P component of the ssc going forward.  XXX We\n     * might be able to delete all the P components, but I (khw) am not certain\n     * about this, and it is better to be safe.\n     *\n     * Inverted, we have\n     *  (C1 | P1) | ~(C2 | P2)  =  (C1 | P1) | (~C2 & ~P2)\n     *                         <=  (C1 | P1) | ~C2\n     *                         <=  (C1 | ~C2) | P1\n     * (which results in actually simpler code than the non-inverted case)\n     * */\n\n    if ((or_with_flags & ANYOF_INVERT)\n        && ! is_ANYOF_SYNTHETIC(or_with))\n    {\n        /* We ignore P2, leaving P1 going forward */\n    }   /* else  Not inverted */\n    else if (or_with_flags & ANYOF_MATCHES_POSIXL) {\n        ANYOF_POSIXL_OR((regnode_charclass_posixl*)or_with, ssc);\n        if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n            unsigned int i;\n            for (i = 0; i < ANYOF_MAX; i += 2) {\n                if (ANYOF_POSIXL_TEST(ssc, i) && ANYOF_POSIXL_TEST(ssc, i + 1))\n                {\n                    ssc_match_all_cp(ssc);\n                    ANYOF_POSIXL_CLEAR(ssc, i);\n                    ANYOF_POSIXL_CLEAR(ssc, i+1);\n                }\n            }\n        }\n    }\n\n    ssc_union(ssc,\n              ored_cp_list,\n              FALSE /* Already has been inverted */\n              );\n}\n\nPERL_STATIC_INLINE void\nS_ssc_union(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert2nd)\n{\n    PERL_ARGS_ASSERT_SSC_UNION;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    _invlist_union_maybe_complement_2nd(ssc->invlist,\n                                        invlist,\n                                        invert2nd,\n                                        &ssc->invlist);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_intersection(pTHX_ regnode_ssc *ssc,\n                         SV* const invlist,\n                         const bool invert2nd)\n{\n    PERL_ARGS_ASSERT_SSC_INTERSECTION;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    _invlist_intersection_maybe_complement_2nd(ssc->invlist,\n                                               invlist,\n                                               invert2nd,\n                                               &ssc->invlist);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_add_range(pTHX_ regnode_ssc *ssc, const UV start, const UV end)\n{\n    PERL_ARGS_ASSERT_SSC_ADD_RANGE;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    ssc->invlist = _add_range_to_invlist(ssc->invlist, start, end);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_cp_and(pTHX_ regnode_ssc *ssc, const UV cp)\n{\n    /* AND just the single code point 'cp' into the SSC 'ssc' */\n\n    SV* cp_list = _new_invlist(2);\n\n    PERL_ARGS_ASSERT_SSC_CP_AND;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    cp_list = add_cp_to_invlist(cp_list, cp);\n    ssc_intersection(ssc, cp_list,\n                     FALSE /* Not inverted */\n                     );\n    SvREFCNT_dec_NN(cp_list);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_clear_locale(regnode_ssc *ssc)\n{\n    /* Set the SSC 'ssc' to not match any locale things */\n    PERL_ARGS_ASSERT_SSC_CLEAR_LOCALE;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    ANYOF_POSIXL_ZERO(ssc);\n    ANYOF_FLAGS(ssc) &= ~ANYOF_LOCALE_FLAGS;\n}\n\n#define NON_OTHER_COUNT   NON_OTHER_COUNT_FOR_USE_ONLY_BY_REGCOMP_DOT_C\n\nSTATIC bool\nS_is_ssc_worth_it(const RExC_state_t * pRExC_state, const regnode_ssc * ssc)\n{\n    /* The synthetic start class is used to hopefully quickly winnow down\n     * places where a pattern could start a match in the target string.  If it\n     * doesn't really narrow things down that much, there isn't much point to\n     * having the overhead of using it.  This function uses some very crude\n     * heuristics to decide if to use the ssc or not.\n     *\n     * It returns TRUE if 'ssc' rules out more than half what it considers to\n     * be the \"likely\" possible matches, but of course it doesn't know what the\n     * actual things being matched are going to be; these are only guesses\n     *\n     * For /l matches, it assumes that the only likely matches are going to be\n     *      in the 0-255 range, uniformly distributed, so half of that is 127\n     * For /a and /d matches, it assumes that the likely matches will be just\n     *      the ASCII range, so half of that is 63\n     * For /u and there isn't anything matching above the Latin1 range, it\n     *      assumes that that is the only range likely to be matched, and uses\n     *      half that as the cut-off: 127.  If anything matches above Latin1,\n     *      it assumes that all of Unicode could match (uniformly), except for\n     *      non-Unicode code points and things in the General Category \"Other\"\n     *      (unassigned, private use, surrogates, controls and formats).  This\n     *      is a much large number. */\n\n    U32 count = 0;      /* Running total of number of code points matched by\n                           'ssc' */\n    UV start, end;      /* Start and end points of current range in inversion\n                           XXX outdated.  UTF-8 locales are common, what about invert? list */\n    const U32 max_code_points = (LOC)\n                                ?  256\n                                : ((  ! UNI_SEMANTICS\n                                    ||  invlist_highest(ssc->invlist) < 256)\n                                  ? 128\n                                  : NON_OTHER_COUNT);\n    const U32 max_match = max_code_points / 2;\n\n    PERL_ARGS_ASSERT_IS_SSC_WORTH_IT;\n\n    invlist_iterinit(ssc->invlist);\n    while (invlist_iternext(ssc->invlist, &start, &end)) {\n        if (start >= max_code_points) {\n            break;\n        }\n        end = MIN(end, max_code_points - 1);\n        count += end - start + 1;\n        if (count >= max_match) {\n            invlist_iterfinish(ssc->invlist);\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}\n\n\nSTATIC void\nS_ssc_finalize(pTHX_ RExC_state_t *pRExC_state, regnode_ssc *ssc)\n{\n    /* The inversion list in the SSC is marked mortal; now we need a more\n     * permanent copy, which is stored the same way that is done in a regular\n     * ANYOF node, with the first NUM_ANYOF_CODE_POINTS code points in a bit\n     * map */\n\n    SV* invlist = invlist_clone(ssc->invlist, NULL);\n\n    PERL_ARGS_ASSERT_SSC_FINALIZE;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* The code in this file assumes that all but these flags aren't relevant\n     * to the SSC, except SSC_MATCHES_EMPTY_STRING, which should be cleared\n     * by the time we reach here */\n    assert(! (ANYOF_FLAGS(ssc)\n        & ~( ANYOF_COMMON_FLAGS\n            |ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER\n            |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP)));\n\n    populate_ANYOF_from_invlist( (regnode *) ssc, &invlist);\n\n    set_ANYOF_arg(pRExC_state, (regnode *) ssc, invlist, NULL, NULL);\n\n    /* Make sure is clone-safe */\n    ssc->invlist = NULL;\n\n    if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n        ANYOF_FLAGS(ssc) |= ANYOF_MATCHES_POSIXL;\n        OP(ssc) = ANYOFPOSIXL;\n    }\n    else if (RExC_contains_locale) {\n        OP(ssc) = ANYOFL;\n    }\n\n    assert(! (ANYOF_FLAGS(ssc) & ANYOF_LOCALE_FLAGS) || RExC_contains_locale);\n}\n\n#define TRIE_LIST_ITEM(state,idx) (trie->states[state].trans.list)[ idx ]\n#define TRIE_LIST_CUR(state)  ( TRIE_LIST_ITEM( state, 0 ).forid )\n#define TRIE_LIST_LEN(state) ( TRIE_LIST_ITEM( state, 0 ).newstate )\n#define TRIE_LIST_USED(idx)  ( trie->states[state].trans.list         \\\n                               ? (TRIE_LIST_CUR( idx ) - 1)           \\\n                               : 0 )\n\n\n#ifdef DEBUGGING\n/*\n   dump_trie(trie,widecharmap,revcharmap)\n   dump_trie_interim_list(trie,widecharmap,revcharmap,next_alloc)\n   dump_trie_interim_table(trie,widecharmap,revcharmap,next_alloc)\n\n   These routines dump out a trie in a somewhat readable format.\n   The _interim_ variants are used for debugging the interim\n   tables that are used to generate the final compressed\n   representation which is what dump_trie expects.\n\n   Part of the reason for their existence is to provide a form\n   of documentation as to how the different representations function.\n\n*/\n\n/*\n  Dumps the final compressed table form of the trie to Perl_debug_log.\n  Used for debugging make_trie().\n*/\n\nSTATIC void\nS_dump_trie(pTHX_ const struct _reg_trie_data *trie, HV *widecharmap,\n\t    AV *revcharmap, U32 depth)\n{\n    U32 state;\n    SV *sv=sv_newmortal();\n    int colwidth= widecharmap ? 6 : 4;\n    U16 word;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMP_TRIE;\n\n    Perl_re_indentf( aTHX_  \"Char : %-6s%-6s%-4s \",\n        depth+1, \"Match\",\"Base\",\"Ofs\" );\n\n    for( state = 0 ; state < trie->uniquecharcount ; state++ ) {\n\tSV ** const tmp = av_fetch( revcharmap, state, 0);\n        if ( tmp ) {\n            Perl_re_printf( aTHX_  \"%*s\",\n                colwidth,\n                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth,\n\t                    PL_colors[0], PL_colors[1],\n\t                    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |\n\t                    PERL_PV_ESCAPE_FIRSTCHAR\n                )\n            );\n        }\n    }\n    Perl_re_printf( aTHX_  \"\\n\");\n    Perl_re_indentf( aTHX_ \"State|-----------------------\", depth+1);\n\n    for( state = 0 ; state < trie->uniquecharcount ; state++ )\n        Perl_re_printf( aTHX_  \"%.*s\", colwidth, \"--------\");\n    Perl_re_printf( aTHX_  \"\\n\");\n\n    for( state = 1 ; state < trie->statecount ; state++ ) {\n\tconst U32 base = trie->states[ state ].trans.base;\n\n        Perl_re_indentf( aTHX_  \"#%4\" UVXf \"|\", depth+1, (UV)state);\n\n        if ( trie->states[ state ].wordnum ) {\n            Perl_re_printf( aTHX_  \" W%4X\", trie->states[ state ].wordnum );\n        } else {\n            Perl_re_printf( aTHX_  \"%6s\", \"\" );\n        }\n\n        Perl_re_printf( aTHX_  \" @%4\" UVXf \" \", (UV)base );\n\n        if ( base ) {\n            U32 ofs = 0;\n\n            while( ( base + ofs  < trie->uniquecharcount ) ||\n                   ( base + ofs - trie->uniquecharcount < trie->lasttrans\n                     && trie->trans[ base + ofs - trie->uniquecharcount ].check\n                                                                    != state))\n                    ofs++;\n\n            Perl_re_printf( aTHX_  \"+%2\" UVXf \"[ \", (UV)ofs);\n\n            for ( ofs = 0 ; ofs < trie->uniquecharcount ; ofs++ ) {\n                if ( ( base + ofs >= trie->uniquecharcount )\n                        && ( base + ofs - trie->uniquecharcount\n                                                        < trie->lasttrans )\n                        && trie->trans[ base + ofs\n                                    - trie->uniquecharcount ].check == state )\n                {\n                   Perl_re_printf( aTHX_  \"%*\" UVXf, colwidth,\n                    (UV)trie->trans[ base + ofs - trie->uniquecharcount ].next\n                   );\n                } else {\n                    Perl_re_printf( aTHX_  \"%*s\", colwidth,\"   .\" );\n                }\n            }\n\n            Perl_re_printf( aTHX_  \"]\");\n\n        }\n        Perl_re_printf( aTHX_  \"\\n\" );\n    }\n    Perl_re_indentf( aTHX_  \"word_info N:(prev,len)=\",\n                                depth);\n    for (word=1; word <= trie->wordcount; word++) {\n        Perl_re_printf( aTHX_  \" %d:(%d,%d)\",\n\t    (int)word, (int)(trie->wordinfo[word].prev),\n\t    (int)(trie->wordinfo[word].len));\n    }\n    Perl_re_printf( aTHX_  \"\\n\" );\n}\n/*\n  Dumps a fully constructed but uncompressed trie in list form.\n  List tries normally only are used for construction when the number of\n  possible chars (trie->uniquecharcount) is very high.\n  Used for debugging make_trie().\n*/\nSTATIC void\nS_dump_trie_interim_list(pTHX_ const struct _reg_trie_data *trie,\n\t\t\t HV *widecharmap, AV *revcharmap, U32 next_alloc,\n\t\t\t U32 depth)\n{\n    U32 state;\n    SV *sv=sv_newmortal();\n    int colwidth= widecharmap ? 6 : 4;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_LIST;\n\n    /* print out the table precompression.  */\n    Perl_re_indentf( aTHX_  \"State :Word | Transition Data\\n\",\n            depth+1 );\n    Perl_re_indentf( aTHX_  \"%s\",\n            depth+1, \"------:-----+-----------------\\n\" );\n\n    for( state=1 ; state < next_alloc ; state ++ ) {\n        U16 charid;\n\n        Perl_re_indentf( aTHX_  \" %4\" UVXf \" :\",\n            depth+1, (UV)state  );\n        if ( ! trie->states[ state ].wordnum ) {\n            Perl_re_printf( aTHX_  \"%5s| \",\"\");\n        } else {\n            Perl_re_printf( aTHX_  \"W%4x| \",\n                trie->states[ state ].wordnum\n            );\n        }\n        for( charid = 1 ; charid <= TRIE_LIST_USED( state ) ; charid++ ) {\n\t    SV ** const tmp = av_fetch( revcharmap,\n                                        TRIE_LIST_ITEM(state, charid).forid, 0);\n\t    if ( tmp ) {\n                Perl_re_printf( aTHX_  \"%*s:%3X=%4\" UVXf \" | \",\n                    colwidth,\n                    pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp),\n                              colwidth,\n                              PL_colors[0], PL_colors[1],\n                              (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0)\n                              | PERL_PV_ESCAPE_FIRSTCHAR\n                    ) ,\n                    TRIE_LIST_ITEM(state, charid).forid,\n                    (UV)TRIE_LIST_ITEM(state, charid).newstate\n                );\n                if (!(charid % 10))\n                    Perl_re_printf( aTHX_  \"\\n%*s| \",\n                        (int)((depth * 2) + 14), \"\");\n            }\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    }\n}\n\n/*\n  Dumps a fully constructed but uncompressed trie in table form.\n  This is the normal DFA style state transition table, with a few\n  twists to facilitate compression later.\n  Used for debugging make_trie().\n*/\nSTATIC void\nS_dump_trie_interim_table(pTHX_ const struct _reg_trie_data *trie,\n\t\t\t  HV *widecharmap, AV *revcharmap, U32 next_alloc,\n\t\t\t  U32 depth)\n{\n    U32 state;\n    U16 charid;\n    SV *sv=sv_newmortal();\n    int colwidth= widecharmap ? 6 : 4;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_TABLE;\n\n    /*\n       print out the table precompression so that we can do a visual check\n       that they are identical.\n     */\n\n    Perl_re_indentf( aTHX_  \"Char : \", depth+1 );\n\n    for( charid = 0 ; charid < trie->uniquecharcount ; charid++ ) {\n\tSV ** const tmp = av_fetch( revcharmap, charid, 0);\n        if ( tmp ) {\n            Perl_re_printf( aTHX_  \"%*s\",\n                colwidth,\n                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth,\n\t                    PL_colors[0], PL_colors[1],\n\t                    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |\n\t                    PERL_PV_ESCAPE_FIRSTCHAR\n                )\n            );\n        }\n    }\n\n    Perl_re_printf( aTHX_ \"\\n\");\n    Perl_re_indentf( aTHX_  \"State+-\", depth+1 );\n\n    for( charid=0 ; charid < trie->uniquecharcount ; charid++ ) {\n        Perl_re_printf( aTHX_  \"%.*s\", colwidth,\"--------\");\n    }\n\n    Perl_re_printf( aTHX_  \"\\n\" );\n\n    for( state=1 ; state < next_alloc ; state += trie->uniquecharcount ) {\n\n        Perl_re_indentf( aTHX_  \"%4\" UVXf \" : \",\n            depth+1,\n            (UV)TRIE_NODENUM( state ) );\n\n        for( charid = 0 ; charid < trie->uniquecharcount ; charid++ ) {\n            UV v=(UV)SAFE_TRIE_NODENUM( trie->trans[ state + charid ].next );\n            if (v)\n                Perl_re_printf( aTHX_  \"%*\" UVXf, colwidth, v );\n            else\n                Perl_re_printf( aTHX_  \"%*s\", colwidth, \".\" );\n        }\n        if ( ! trie->states[ TRIE_NODENUM( state ) ].wordnum ) {\n            Perl_re_printf( aTHX_  \" (%4\" UVXf \")\\n\",\n                                            (UV)trie->trans[ state ].check );\n        } else {\n            Perl_re_printf( aTHX_  \" (%4\" UVXf \") W%4X\\n\",\n                                            (UV)trie->trans[ state ].check,\n            trie->states[ TRIE_NODENUM( state ) ].wordnum );\n        }\n    }\n}\n\n#endif\n\n\n/* make_trie(startbranch,first,last,tail,word_count,flags,depth)\n  startbranch: the first branch in the whole branch sequence\n  first      : start branch of sequence of branch-exact nodes.\n\t       May be the same as startbranch\n  last       : Thing following the last branch.\n\t       May be the same as tail.\n  tail       : item following the branch sequence\n  count      : words in the sequence\n  flags      : currently the OP() type we will be building one of /EXACT(|F|FA|FU|FU_SS|L|FLU8)/\n  depth      : indent depth\n\nInplace optimizes a sequence of 2 or more Branch-Exact nodes into a TRIE node.\n\nA trie is an N'ary tree where the branches are determined by digital\ndecomposition of the key. IE, at the root node you look up the 1st character and\nfollow that branch repeat until you find the end of the branches. Nodes can be\nmarked as \"accepting\" meaning they represent a complete word. Eg:\n\n  /he|she|his|hers/\n\nwould convert into the following structure. Numbers represent states, letters\nfollowing numbers represent valid transitions on the letter from that state, if\nthe number is in square brackets it represents an accepting state, otherwise it\nwill be in parenthesis.\n\n      +-h->+-e->[3]-+-r->(8)-+-s->[9]\n      |    |\n      |   (2)\n      |    |\n     (1)   +-i->(6)-+-s->[7]\n      |\n      +-s->(3)-+-h->(4)-+-e->[5]\n\n      Accept Word Mapping: 3=>1 (he),5=>2 (she), 7=>3 (his), 9=>4 (hers)\n\nThis shows that when matching against the string 'hers' we will begin at state 1\nread 'h' and move to state 2, read 'e' and move to state 3 which is accepting,\nthen read 'r' and go to state 8 followed by 's' which takes us to state 9 which\nis also accepting. Thus we know that we can match both 'he' and 'hers' with a\nsingle traverse. We store a mapping from accepting to state to which word was\nmatched, and then when we have multiple possibilities we try to complete the\nrest of the regex in the order in which they occurred in the alternation.\n\nThe only prior NFA like behaviour that would be changed by the TRIE support is\nthe silent ignoring of duplicate alternations which are of the form:\n\n / (DUPE|DUPE) X? (?{ ... }) Y /x\n\nThus EVAL blocks following a trie may be called a different number of times with\nand without the optimisation. With the optimisations dupes will be silently\nignored. This inconsistent behaviour of EVAL type nodes is well established as\nthe following demonstrates:\n\n 'words'=~/(word|word|word)(?{ print $1 })[xyz]/\n\nwhich prints out 'word' three times, but\n\n 'words'=~/(word|word|word)(?{ print $1 })S/\n\nwhich doesnt print it out at all. This is due to other optimisations kicking in.\n\nExample of what happens on a structural level:\n\nThe regexp /(ac|ad|ab)+/ will produce the following debug output:\n\n   1: CURLYM[1] {1,32767}(18)\n   5:   BRANCH(8)\n   6:     EXACT <ac>(16)\n   8:   BRANCH(11)\n   9:     EXACT <ad>(16)\n  11:   BRANCH(14)\n  12:     EXACT <ab>(16)\n  16:   SUCCEED(0)\n  17:   NOTHING(18)\n  18: END(0)\n\nThis would be optimizable with startbranch=5, first=5, last=16, tail=16\nand should turn into:\n\n   1: CURLYM[1] {1,32767}(18)\n   5:   TRIE(16)\n\t[Words:3 Chars Stored:6 Unique Chars:4 States:5 NCP:1]\n\t  <ac>\n\t  <ad>\n\t  <ab>\n  16:   SUCCEED(0)\n  17:   NOTHING(18)\n  18: END(0)\n\nCases where tail != last would be like /(?foo|bar)baz/:\n\n   1: BRANCH(4)\n   2:   EXACT <foo>(8)\n   4: BRANCH(7)\n   5:   EXACT <bar>(8)\n   7: TAIL(8)\n   8: EXACT <baz>(10)\n  10: END(0)\n\nwhich would be optimizable with startbranch=1, first=1, last=7, tail=8\nand would end up looking like:\n\n    1: TRIE(8)\n      [Words:2 Chars Stored:6 Unique Chars:5 States:7 NCP:1]\n\t<foo>\n\t<bar>\n   7: TAIL(8)\n   8: EXACT <baz>(10)\n  10: END(0)\n\n    d = uvchr_to_utf8_flags(d, uv, 0);\n\nis the recommended Unicode-aware way of saying\n\n    *(d++) = uv;\n*/\n\n#define TRIE_STORE_REVCHAR(val)                                            \\\n    STMT_START {                                                           \\\n\tif (UTF) {\t\t\t\t\t\t\t   \\\n            SV *zlopp = newSV(UTF8_MAXBYTES);\t\t\t\t   \\\n\t    unsigned char *flrbbbbb = (unsigned char *) SvPVX(zlopp);\t   \\\n            unsigned const char *const kapow = uvchr_to_utf8(flrbbbbb, val); \\\n\t    SvCUR_set(zlopp, kapow - flrbbbbb);\t\t\t\t   \\\n\t    SvPOK_on(zlopp);\t\t\t\t\t\t   \\\n\t    SvUTF8_on(zlopp);\t\t\t\t\t\t   \\\n\t    av_push(revcharmap, zlopp);\t\t\t\t\t   \\\n\t} else {\t\t\t\t\t\t\t   \\\n            char ooooff = (char)val;                                           \\\n\t    av_push(revcharmap, newSVpvn(&ooooff, 1));\t\t\t   \\\n\t}\t\t\t\t\t\t\t\t   \\\n        } STMT_END\n\n/* This gets the next character from the input, folding it if not already\n * folded. */\n#define TRIE_READ_CHAR STMT_START {                                           \\\n    wordlen++;                                                                \\\n    if ( UTF ) {                                                              \\\n        /* if it is UTF then it is either already folded, or does not need    \\\n         * folding */                                                         \\\n        uvc = valid_utf8_to_uvchr( (const U8*) uc, &len);                     \\\n    }                                                                         \\\n    else if (folder == PL_fold_latin1) {                                      \\\n        /* This folder implies Unicode rules, which in the range expressible  \\\n         *  by not UTF is the lower case, with the two exceptions, one of     \\\n         *  which should have been taken care of before calling this */       \\\n        assert(*uc != LATIN_SMALL_LETTER_SHARP_S);                            \\\n        uvc = toLOWER_L1(*uc);                                                \\\n        if (UNLIKELY(uvc == MICRO_SIGN)) uvc = GREEK_SMALL_LETTER_MU;         \\\n        len = 1;                                                              \\\n    } else {                                                                  \\\n        /* raw data, will be folded later if needed */                        \\\n        uvc = (U32)*uc;                                                       \\\n        len = 1;                                                              \\\n    }                                                                         \\\n} STMT_END\n\n\n\n#define TRIE_LIST_PUSH(state,fid,ns) STMT_START {               \\\n    if ( TRIE_LIST_CUR( state ) >=TRIE_LIST_LEN( state ) ) {    \\\n\tU32 ging = TRIE_LIST_LEN( state ) * 2;                  \\\n\tRenew( trie->states[ state ].trans.list, ging, reg_trie_trans_le ); \\\n        TRIE_LIST_LEN( state ) = ging;                          \\\n    }                                                           \\\n    TRIE_LIST_ITEM( state, TRIE_LIST_CUR( state ) ).forid = fid;     \\\n    TRIE_LIST_ITEM( state, TRIE_LIST_CUR( state ) ).newstate = ns;   \\\n    TRIE_LIST_CUR( state )++;                                   \\\n} STMT_END\n\n#define TRIE_LIST_NEW(state) STMT_START {                       \\\n    Newx( trie->states[ state ].trans.list,                     \\\n\t4, reg_trie_trans_le );                                 \\\n     TRIE_LIST_CUR( state ) = 1;                                \\\n     TRIE_LIST_LEN( state ) = 4;                                \\\n} STMT_END\n\n#define TRIE_HANDLE_WORD(state) STMT_START {                    \\\n    U16 dupe= trie->states[ state ].wordnum;                    \\\n    regnode * const noper_next = regnext( noper );              \\\n                                                                \\\n    DEBUG_r({                                                   \\\n        /* store the word for dumping */                        \\\n        SV* tmp;                                                \\\n        if (OP(noper) != NOTHING)                               \\\n            tmp = newSVpvn_utf8(STRING(noper), STR_LEN(noper), UTF);\t\\\n        else                                                    \\\n            tmp = newSVpvn_utf8( \"\", 0, UTF );\t\t\t\\\n        av_push( trie_words, tmp );                             \\\n    });                                                         \\\n                                                                \\\n    curword++;                                                  \\\n    trie->wordinfo[curword].prev   = 0;                         \\\n    trie->wordinfo[curword].len    = wordlen;                   \\\n    trie->wordinfo[curword].accept = state;                     \\\n                                                                \\\n    if ( noper_next < tail ) {                                  \\\n        if (!trie->jump)                                        \\\n            trie->jump = (U16 *) PerlMemShared_calloc( word_count + 1, \\\n                                                 sizeof(U16) ); \\\n        trie->jump[curword] = (U16)(noper_next - convert);      \\\n        if (!jumper)                                            \\\n            jumper = noper_next;                                \\\n        if (!nextbranch)                                        \\\n            nextbranch= regnext(cur);                           \\\n    }                                                           \\\n                                                                \\\n    if ( dupe ) {                                               \\\n        /* It's a dupe. Pre-insert into the wordinfo[].prev   */\\\n        /* chain, so that when the bits of chain are later    */\\\n        /* linked together, the dups appear in the chain      */\\\n\ttrie->wordinfo[curword].prev = trie->wordinfo[dupe].prev; \\\n\ttrie->wordinfo[dupe].prev = curword;                    \\\n    } else {                                                    \\\n        /* we haven't inserted this word yet.                */ \\\n        trie->states[ state ].wordnum = curword;                \\\n    }                                                           \\\n} STMT_END\n\n\n#define TRIE_TRANS_STATE(state,base,ucharcount,charid,special)\t\t\\\n     ( ( base + charid >=  ucharcount\t\t\t\t\t\\\n         && base + charid < ubound\t\t\t\t\t\\\n         && state == trie->trans[ base - ucharcount + charid ].check\t\\\n         && trie->trans[ base - ucharcount + charid ].next )\t\t\\\n           ? trie->trans[ base - ucharcount + charid ].next\t\t\\\n           : ( state==1 ? special : 0 )\t\t\t\t\t\\\n      )\n\n#define TRIE_BITMAP_SET_FOLDED(trie, uvc, folder)           \\\nSTMT_START {                                                \\\n    TRIE_BITMAP_SET(trie, uvc);                             \\\n    /* store the folded codepoint */                        \\\n    if ( folder )                                           \\\n        TRIE_BITMAP_SET(trie, folder[(U8) uvc ]);           \\\n                                                            \\\n    if ( !UTF ) {                                           \\\n        /* store first byte of utf8 representation of */    \\\n        /* variant codepoints */                            \\\n        if (! UVCHR_IS_INVARIANT(uvc)) {                    \\\n            TRIE_BITMAP_SET(trie, UTF8_TWO_BYTE_HI(uvc));   \\\n        }                                                   \\\n    }                                                       \\\n} STMT_END\n#define MADE_TRIE       1\n#define MADE_JUMP_TRIE  2\n#define MADE_EXACT_TRIE 4\n\nSTATIC I32\nS_make_trie(pTHX_ RExC_state_t *pRExC_state, regnode *startbranch,\n                  regnode *first, regnode *last, regnode *tail,\n                  U32 word_count, U32 flags, U32 depth)\n{\n    /* first pass, loop through and scan words */\n    reg_trie_data *trie;\n    HV *widecharmap = NULL;\n    AV *revcharmap = newAV();\n    regnode *cur;\n    STRLEN len = 0;\n    UV uvc = 0;\n    U16 curword = 0;\n    U32 next_alloc = 0;\n    regnode *jumper = NULL;\n    regnode *nextbranch = NULL;\n    regnode *convert = NULL;\n    U32 *prev_states; /* temp array mapping each state to previous one */\n    /* we just use folder as a flag in utf8 */\n    const U8 * folder = NULL;\n\n    /* in the below add_data call we are storing either 'tu' or 'tuaa'\n     * which stands for one trie structure, one hash, optionally followed\n     * by two arrays */\n#ifdef DEBUGGING\n    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN(\"tuaa\"));\n    AV *trie_words = NULL;\n    /* along with revcharmap, this only used during construction but both are\n     * useful during debugging so we store them in the struct when debugging.\n     */\n#else\n    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN(\"tu\"));\n    STRLEN trie_charcount=0;\n#endif\n    SV *re_trie_maxbuff;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_MAKE_TRIE;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    switch (flags) {\n        case EXACT: case EXACT_ONLY8: case EXACTL: break;\n\tcase EXACTFAA:\n        case EXACTFUP:\n\tcase EXACTFU:\n\tcase EXACTFLU8: folder = PL_fold_latin1; break;\n\tcase EXACTF:  folder = PL_fold; break;\n        default: Perl_croak( aTHX_ \"panic! In trie construction, unknown node type %u %s\", (unsigned) flags, PL_reg_name[flags] );\n    }\n\n    trie = (reg_trie_data *) PerlMemShared_calloc( 1, sizeof(reg_trie_data) );\n    trie->refcount = 1;\n    trie->startstate = 1;\n    trie->wordcount = word_count;\n    RExC_rxi->data->data[ data_slot ] = (void*)trie;\n    trie->charmap = (U16 *) PerlMemShared_calloc( 256, sizeof(U16) );\n    if (flags == EXACT || flags == EXACT_ONLY8 || flags == EXACTL)\n\ttrie->bitmap = (char *) PerlMemShared_calloc( ANYOF_BITMAP_SIZE, 1 );\n    trie->wordinfo = (reg_trie_wordinfo *) PerlMemShared_calloc(\n                       trie->wordcount+1, sizeof(reg_trie_wordinfo));\n\n    DEBUG_r({\n        trie_words = newAV();\n    });\n\n    re_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, GV_ADD);\n    assert(re_trie_maxbuff);\n    if (!SvIOK(re_trie_maxbuff)) {\n        sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);\n    }\n    DEBUG_TRIE_COMPILE_r({\n        Perl_re_indentf( aTHX_\n          \"make_trie start==%d, first==%d, last==%d, tail==%d depth=%d\\n\",\n          depth+1,\n          REG_NODE_NUM(startbranch), REG_NODE_NUM(first),\n          REG_NODE_NUM(last), REG_NODE_NUM(tail), (int)depth);\n    });\n\n   /* Find the node we are going to overwrite */\n    if ( first == startbranch && OP( last ) != BRANCH ) {\n        /* whole branch chain */\n        convert = first;\n    } else {\n        /* branch sub-chain */\n        convert = NEXTOPER( first );\n    }\n\n    /*  -- First loop and Setup --\n\n       We first traverse the branches and scan each word to determine if it\n       contains widechars, and how many unique chars there are, this is\n       important as we have to build a table with at least as many columns as we\n       have unique chars.\n\n       We use an array of integers to represent the character codes 0..255\n       (trie->charmap) and we use a an HV* to store Unicode characters. We use\n       the native representation of the character value as the key and IV's for\n       the coded index.\n\n       *TODO* If we keep track of how many times each character is used we can\n       remap the columns so that the table compression later on is more\n       efficient in terms of memory by ensuring the most common value is in the\n       middle and the least common are on the outside.  IMO this would be better\n       than a most to least common mapping as theres a decent chance the most\n       common letter will share a node with the least common, meaning the node\n       will not be compressible. With a middle is most common approach the worst\n       case is when we have the least common nodes twice.\n\n     */\n\n    for ( cur = first ; cur < last ; cur = regnext( cur ) ) {\n        regnode *noper = NEXTOPER( cur );\n        const U8 *uc;\n        const U8 *e;\n        int foldlen = 0;\n        U32 wordlen      = 0;         /* required init */\n        STRLEN minchars = 0;\n        STRLEN maxchars = 0;\n        bool set_bit = trie->bitmap ? 1 : 0; /*store the first char in the\n                                               bitmap?*/\n\n        if (OP(noper) == NOTHING) {\n            /* skip past a NOTHING at the start of an alternation\n             * eg, /(?:)a|(?:b)/ should be the same as /a|b/\n             *\n             * If the next node is not something we are supposed to process\n             * we will just ignore it due to the condition guarding the\n             * next block.\n             */\n\n            regnode *noper_next= regnext(noper);\n            if (noper_next < tail)\n                noper= noper_next;\n        }\n\n        if (    noper < tail\n            && (    OP(noper) == flags\n                || (flags == EXACT && OP(noper) == EXACT_ONLY8)\n                || (flags == EXACTFU && (   OP(noper) == EXACTFU_ONLY8\n                                         || OP(noper) == EXACTFUP))))\n        {\n            uc= (U8*)STRING(noper);\n            e= uc + STR_LEN(noper);\n        } else {\n            trie->minlen= 0;\n            continue;\n        }\n\n\n        if ( set_bit ) { /* bitmap only alloced when !(UTF&&Folding) */\n            TRIE_BITMAP_SET(trie,*uc); /* store the raw first byte\n                                          regardless of encoding */\n            if (OP( noper ) == EXACTFUP) {\n                /* false positives are ok, so just set this */\n                TRIE_BITMAP_SET(trie, LATIN_SMALL_LETTER_SHARP_S);\n            }\n        }\n\n        for ( ; uc < e ; uc += len ) {  /* Look at each char in the current\n                                           branch */\n            TRIE_CHARCOUNT(trie)++;\n            TRIE_READ_CHAR;\n\n            /* TRIE_READ_CHAR returns the current character, or its fold if /i\n             * is in effect.  Under /i, this character can match itself, or\n             * anything that folds to it.  If not under /i, it can match just\n             * itself.  Most folds are 1-1, for example k, K, and KELVIN SIGN\n             * all fold to k, and all are single characters.   But some folds\n             * expand to more than one character, so for example LATIN SMALL\n             * LIGATURE FFI folds to the three character sequence 'ffi'.  If\n             * the string beginning at 'uc' is 'ffi', it could be matched by\n             * three characters, or just by the one ligature character. (It\n             * could also be matched by two characters: LATIN SMALL LIGATURE FF\n             * followed by 'i', or by 'f' followed by LATIN SMALL LIGATURE FI).\n             * (Of course 'I' and/or 'F' instead of 'i' and 'f' can also\n             * match.)  The trie needs to know the minimum and maximum number\n             * of characters that could match so that it can use size alone to\n             * quickly reject many match attempts.  The max is simple: it is\n             * the number of folded characters in this branch (since a fold is\n             * never shorter than what folds to it. */\n\n            maxchars++;\n\n            /* And the min is equal to the max if not under /i (indicated by\n             * 'folder' being NULL), or there are no multi-character folds.  If\n             * there is a multi-character fold, the min is incremented just\n             * once, for the character that folds to the sequence.  Each\n             * character in the sequence needs to be added to the list below of\n             * characters in the trie, but we count only the first towards the\n             * min number of characters needed.  This is done through the\n             * variable 'foldlen', which is returned by the macros that look\n             * for these sequences as the number of bytes the sequence\n             * occupies.  Each time through the loop, we decrement 'foldlen' by\n             * how many bytes the current char occupies.  Only when it reaches\n             * 0 do we increment 'minchars' or look for another multi-character\n             * sequence. */\n            if (folder == NULL) {\n                minchars++;\n            }\n            else if (foldlen > 0) {\n                foldlen -= (UTF) ? UTF8SKIP(uc) : 1;\n            }\n            else {\n                minchars++;\n\n                /* See if *uc is the beginning of a multi-character fold.  If\n                 * so, we decrement the length remaining to look at, to account\n                 * for the current character this iteration.  (We can use 'uc'\n                 * instead of the fold returned by TRIE_READ_CHAR because for\n                 * non-UTF, the latin1_safe macro is smart enough to account\n                 * for all the unfolded characters, and because for UTF, the\n                 * string will already have been folded earlier in the\n                 * compilation process */\n                if (UTF) {\n                    if ((foldlen = is_MULTI_CHAR_FOLD_utf8_safe(uc, e))) {\n                        foldlen -= UTF8SKIP(uc);\n                    }\n                }\n                else if ((foldlen = is_MULTI_CHAR_FOLD_latin1_safe(uc, e))) {\n                    foldlen--;\n                }\n            }\n\n            /* The current character (and any potential folds) should be added\n             * to the possible matching characters for this position in this\n             * branch */\n            if ( uvc < 256 ) {\n                if ( folder ) {\n                    U8 folded= folder[ (U8) uvc ];\n                    if ( !trie->charmap[ folded ] ) {\n                        trie->charmap[ folded ]=( ++trie->uniquecharcount );\n                        TRIE_STORE_REVCHAR( folded );\n                    }\n                }\n                if ( !trie->charmap[ uvc ] ) {\n                    trie->charmap[ uvc ]=( ++trie->uniquecharcount );\n                    TRIE_STORE_REVCHAR( uvc );\n                }\n                if ( set_bit ) {\n\t\t    /* store the codepoint in the bitmap, and its folded\n\t\t     * equivalent. */\n                    TRIE_BITMAP_SET_FOLDED(trie, uvc, folder);\n                    set_bit = 0; /* We've done our bit :-) */\n                }\n            } else {\n\n                /* XXX We could come up with the list of code points that fold\n                 * to this using PL_utf8_foldclosures, except not for\n                 * multi-char folds, as there may be multiple combinations\n                 * there that could work, which needs to wait until runtime to\n                 * resolve (The comment about LIGATURE FFI above is such an\n                 * example */\n\n                SV** svpp;\n                if ( !widecharmap )\n                    widecharmap = newHV();\n\n                svpp = hv_fetch( widecharmap, (char*)&uvc, sizeof( UV ), 1 );\n\n                if ( !svpp )\n                    Perl_croak( aTHX_ \"error creating/fetching widecharmap entry for 0x%\" UVXf, uvc );\n\n                if ( !SvTRUE( *svpp ) ) {\n                    sv_setiv( *svpp, ++trie->uniquecharcount );\n                    TRIE_STORE_REVCHAR(uvc);\n                }\n            }\n        } /* end loop through characters in this branch of the trie */\n\n        /* We take the min and max for this branch and combine to find the min\n         * and max for all branches processed so far */\n        if( cur == first ) {\n            trie->minlen = minchars;\n            trie->maxlen = maxchars;\n        } else if (minchars < trie->minlen) {\n            trie->minlen = minchars;\n        } else if (maxchars > trie->maxlen) {\n            trie->maxlen = maxchars;\n        }\n    } /* end first pass */\n    DEBUG_TRIE_COMPILE_r(\n        Perl_re_indentf( aTHX_\n                \"TRIE(%s): W:%d C:%d Uq:%d Min:%d Max:%d\\n\",\n                depth+1,\n                ( widecharmap ? \"UTF8\" : \"NATIVE\" ), (int)word_count,\n\t\t(int)TRIE_CHARCOUNT(trie), trie->uniquecharcount,\n\t\t(int)trie->minlen, (int)trie->maxlen )\n    );\n\n    /*\n        We now know what we are dealing with in terms of unique chars and\n        string sizes so we can calculate how much memory a naive\n        representation using a flat table  will take. If it's over a reasonable\n        limit (as specified by ${^RE_TRIE_MAXBUF}) we use a more memory\n        conservative but potentially much slower representation using an array\n        of lists.\n\n        At the end we convert both representations into the same compressed\n        form that will be used in regexec.c for matching with. The latter\n        is a form that cannot be used to construct with but has memory\n        properties similar to the list form and access properties similar\n        to the table form making it both suitable for fast searches and\n        small enough that its feasable to store for the duration of a program.\n\n        See the comment in the code where the compressed table is produced\n        inplace from the flat tabe representation for an explanation of how\n        the compression works.\n\n    */\n\n\n    Newx(prev_states, TRIE_CHARCOUNT(trie) + 2, U32);\n    prev_states[1] = 0;\n\n    if ( (IV)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount + 1)\n                                                    > SvIV(re_trie_maxbuff) )\n    {\n        /*\n            Second Pass -- Array Of Lists Representation\n\n            Each state will be represented by a list of charid:state records\n            (reg_trie_trans_le) the first such element holds the CUR and LEN\n            points of the allocated array. (See defines above).\n\n            We build the initial structure using the lists, and then convert\n            it into the compressed table form which allows faster lookups\n            (but cant be modified once converted).\n        */\n\n        STRLEN transcount = 1;\n\n        DEBUG_TRIE_COMPILE_MORE_r( Perl_re_indentf( aTHX_  \"Compiling trie using list compiler\\n\",\n            depth+1));\n\n\ttrie->states = (reg_trie_state *)\n\t    PerlMemShared_calloc( TRIE_CHARCOUNT(trie) + 2,\n\t\t\t\t  sizeof(reg_trie_state) );\n        TRIE_LIST_NEW(1);\n        next_alloc = 2;\n\n        for ( cur = first ; cur < last ; cur = regnext( cur ) ) {\n\n            regnode *noper   = NEXTOPER( cur );\n\t    U32 state        = 1;         /* required init */\n\t    U16 charid       = 0;         /* sanity init */\n            U32 wordlen      = 0;         /* required init */\n\n            if (OP(noper) == NOTHING) {\n                regnode *noper_next= regnext(noper);\n                if (noper_next < tail)\n                    noper= noper_next;\n                /* we will undo this assignment if noper does not\n                 * point at a trieable type in the else clause of\n                 * the following statement. */\n            }\n\n            if (    noper < tail\n                && (    OP(noper) == flags\n                    || (flags == EXACT && OP(noper) == EXACT_ONLY8)\n                    || (flags == EXACTFU && (   OP(noper) == EXACTFU_ONLY8\n                                             || OP(noper) == EXACTFUP))))\n            {\n                const U8 *uc= (U8*)STRING(noper);\n                const U8 *e= uc + STR_LEN(noper);\n\n                for ( ; uc < e ; uc += len ) {\n\n                    TRIE_READ_CHAR;\n\n                    if ( uvc < 256 ) {\n                        charid = trie->charmap[ uvc ];\n\t\t    } else {\n                        SV** const svpp = hv_fetch( widecharmap,\n                                                    (char*)&uvc,\n                                                    sizeof( UV ),\n                                                    0);\n                        if ( !svpp ) {\n                            charid = 0;\n                        } else {\n                            charid=(U16)SvIV( *svpp );\n                        }\n\t\t    }\n                    /* charid is now 0 if we dont know the char read, or\n                     * nonzero if we do */\n                    if ( charid ) {\n\n                        U16 check;\n                        U32 newstate = 0;\n\n                        charid--;\n                        if ( !trie->states[ state ].trans.list ) {\n                            TRIE_LIST_NEW( state );\n\t\t\t}\n                        for ( check = 1;\n                              check <= TRIE_LIST_USED( state );\n                              check++ )\n                        {\n                            if ( TRIE_LIST_ITEM( state, check ).forid\n                                                                    == charid )\n                            {\n                                newstate = TRIE_LIST_ITEM( state, check ).newstate;\n                                break;\n                            }\n                        }\n                        if ( ! newstate ) {\n                            newstate = next_alloc++;\n\t\t\t    prev_states[newstate] = state;\n                            TRIE_LIST_PUSH( state, charid, newstate );\n                            transcount++;\n                        }\n                        state = newstate;\n                    } else {\n                        Perl_croak( aTHX_ \"panic! In trie construction, no char mapping for %\" IVdf, uvc );\n\t\t    }\n\t\t}\n            } else {\n                /* If we end up here it is because we skipped past a NOTHING, but did not end up\n                 * on a trieable type. So we need to reset noper back to point at the first regop\n                 * in the branch before we call TRIE_HANDLE_WORD()\n                */\n                noper= NEXTOPER(cur);\n            }\n            TRIE_HANDLE_WORD(state);\n\n        } /* end second pass */\n\n        /* next alloc is the NEXT state to be allocated */\n        trie->statecount = next_alloc;\n        trie->states = (reg_trie_state *)\n\t    PerlMemShared_realloc( trie->states,\n\t\t\t\t   next_alloc\n\t\t\t\t   * sizeof(reg_trie_state) );\n\n        /* and now dump it out before we compress it */\n        DEBUG_TRIE_COMPILE_MORE_r(dump_trie_interim_list(trie, widecharmap,\n\t\t\t\t\t\t\t revcharmap, next_alloc,\n\t\t\t\t\t\t\t depth+1)\n        );\n\n        trie->trans = (reg_trie_trans *)\n\t    PerlMemShared_calloc( transcount, sizeof(reg_trie_trans) );\n        {\n            U32 state;\n            U32 tp = 0;\n            U32 zp = 0;\n\n\n            for( state=1 ; state < next_alloc ; state ++ ) {\n                U32 base=0;\n\n                /*\n                DEBUG_TRIE_COMPILE_MORE_r(\n                    Perl_re_printf( aTHX_  \"tp: %d zp: %d \",tp,zp)\n                );\n                */\n\n                if (trie->states[state].trans.list) {\n                    U16 minid=TRIE_LIST_ITEM( state, 1).forid;\n                    U16 maxid=minid;\n\t\t    U16 idx;\n\n                    for( idx = 2 ; idx <= TRIE_LIST_USED( state ) ; idx++ ) {\n\t\t\tconst U16 forid = TRIE_LIST_ITEM( state, idx).forid;\n\t\t\tif ( forid < minid ) {\n\t\t\t    minid=forid;\n\t\t\t} else if ( forid > maxid ) {\n\t\t\t    maxid=forid;\n\t\t\t}\n                    }\n                    if ( transcount < tp + maxid - minid + 1) {\n                        transcount *= 2;\n\t\t\ttrie->trans = (reg_trie_trans *)\n\t\t\t    PerlMemShared_realloc( trie->trans,\n\t\t\t\t\t\t     transcount\n\t\t\t\t\t\t     * sizeof(reg_trie_trans) );\n                        Zero( trie->trans + (transcount / 2),\n                              transcount / 2,\n                              reg_trie_trans );\n                    }\n                    base = trie->uniquecharcount + tp - minid;\n                    if ( maxid == minid ) {\n                        U32 set = 0;\n                        for ( ; zp < tp ; zp++ ) {\n                            if ( ! trie->trans[ zp ].next ) {\n                                base = trie->uniquecharcount + zp - minid;\n                                trie->trans[ zp ].next = TRIE_LIST_ITEM( state,\n                                                                   1).newstate;\n                                trie->trans[ zp ].check = state;\n                                set = 1;\n                                break;\n                            }\n                        }\n                        if ( !set ) {\n                            trie->trans[ tp ].next = TRIE_LIST_ITEM( state,\n                                                                   1).newstate;\n                            trie->trans[ tp ].check = state;\n                            tp++;\n                            zp = tp;\n                        }\n                    } else {\n                        for ( idx=1; idx <= TRIE_LIST_USED( state ) ; idx++ ) {\n                            const U32 tid = base\n                                           - trie->uniquecharcount\n                                           + TRIE_LIST_ITEM( state, idx ).forid;\n                            trie->trans[ tid ].next = TRIE_LIST_ITEM( state,\n                                                                idx ).newstate;\n                            trie->trans[ tid ].check = state;\n                        }\n                        tp += ( maxid - minid + 1 );\n                    }\n                    Safefree(trie->states[ state ].trans.list);\n                }\n                /*\n                DEBUG_TRIE_COMPILE_MORE_r(\n                    Perl_re_printf( aTHX_  \" base: %d\\n\",base);\n                );\n                */\n                trie->states[ state ].trans.base=base;\n            }\n            trie->lasttrans = tp + 1;\n        }\n    } else {\n        /*\n           Second Pass -- Flat Table Representation.\n\n           we dont use the 0 slot of either trans[] or states[] so we add 1 to\n           each.  We know that we will need Charcount+1 trans at most to store\n           the data (one row per char at worst case) So we preallocate both\n           structures assuming worst case.\n\n           We then construct the trie using only the .next slots of the entry\n           structs.\n\n           We use the .check field of the first entry of the node temporarily\n           to make compression both faster and easier by keeping track of how\n           many non zero fields are in the node.\n\n           Since trans are numbered from 1 any 0 pointer in the table is a FAIL\n           transition.\n\n           There are two terms at use here: state as a TRIE_NODEIDX() which is\n           a number representing the first entry of the node, and state as a\n           TRIE_NODENUM() which is the trans number. state 1 is TRIE_NODEIDX(1)\n           and TRIE_NODENUM(1), state 2 is TRIE_NODEIDX(2) and TRIE_NODENUM(3)\n           if there are 2 entrys per node. eg:\n\n             A B       A B\n          1. 2 4    1. 3 7\n          2. 0 3    3. 0 5\n          3. 0 0    5. 0 0\n          4. 0 0    7. 0 0\n\n           The table is internally in the right hand, idx form. However as we\n           also have to deal with the states array which is indexed by nodenum\n           we have to use TRIE_NODENUM() to convert.\n\n        */\n        DEBUG_TRIE_COMPILE_MORE_r( Perl_re_indentf( aTHX_  \"Compiling trie using table compiler\\n\",\n            depth+1));\n\n\ttrie->trans = (reg_trie_trans *)\n\t    PerlMemShared_calloc( ( TRIE_CHARCOUNT(trie) + 1 )\n\t\t\t\t  * trie->uniquecharcount + 1,\n\t\t\t\t  sizeof(reg_trie_trans) );\n        trie->states = (reg_trie_state *)\n\t    PerlMemShared_calloc( TRIE_CHARCOUNT(trie) + 2,\n\t\t\t\t  sizeof(reg_trie_state) );\n        next_alloc = trie->uniquecharcount + 1;\n\n\n        for ( cur = first ; cur < last ; cur = regnext( cur ) ) {\n\n            regnode *noper   = NEXTOPER( cur );\n\n            U32 state        = 1;         /* required init */\n\n            U16 charid       = 0;         /* sanity init */\n            U32 accept_state = 0;         /* sanity init */\n\n            U32 wordlen      = 0;         /* required init */\n\n            if (OP(noper) == NOTHING) {\n                regnode *noper_next= regnext(noper);\n                if (noper_next < tail)\n                    noper= noper_next;\n                /* we will undo this assignment if noper does not\n                 * point at a trieable type in the else clause of\n                 * the following statement. */\n            }\n\n            if (    noper < tail\n                && (    OP(noper) == flags\n                    || (flags == EXACT && OP(noper) == EXACT_ONLY8)\n                    || (flags == EXACTFU && (   OP(noper) == EXACTFU_ONLY8\n                                             || OP(noper) == EXACTFUP))))\n            {\n                const U8 *uc= (U8*)STRING(noper);\n                const U8 *e= uc + STR_LEN(noper);\n\n                for ( ; uc < e ; uc += len ) {\n\n                    TRIE_READ_CHAR;\n\n                    if ( uvc < 256 ) {\n                        charid = trie->charmap[ uvc ];\n                    } else {\n                        SV* const * const svpp = hv_fetch( widecharmap,\n                                                           (char*)&uvc,\n                                                           sizeof( UV ),\n                                                           0);\n                        charid = svpp ? (U16)SvIV(*svpp) : 0;\n                    }\n                    if ( charid ) {\n                        charid--;\n                        if ( !trie->trans[ state + charid ].next ) {\n                            trie->trans[ state + charid ].next = next_alloc;\n                            trie->trans[ state ].check++;\n\t\t\t    prev_states[TRIE_NODENUM(next_alloc)]\n\t\t\t\t    = TRIE_NODENUM(state);\n                            next_alloc += trie->uniquecharcount;\n                        }\n                        state = trie->trans[ state + charid ].next;\n                    } else {\n                        Perl_croak( aTHX_ \"panic! In trie construction, no char mapping for %\" IVdf, uvc );\n                    }\n                    /* charid is now 0 if we dont know the char read, or\n                     * nonzero if we do */\n                }\n            } else {\n                /* If we end up here it is because we skipped past a NOTHING, but did not end up\n                 * on a trieable type. So we need to reset noper back to point at the first regop\n                 * in the branch before we call TRIE_HANDLE_WORD().\n                */\n                noper= NEXTOPER(cur);\n            }\n            accept_state = TRIE_NODENUM( state );\n            TRIE_HANDLE_WORD(accept_state);\n\n        } /* end second pass */\n\n        /* and now dump it out before we compress it */\n        DEBUG_TRIE_COMPILE_MORE_r(dump_trie_interim_table(trie, widecharmap,\n\t\t\t\t\t\t\t  revcharmap,\n\t\t\t\t\t\t\t  next_alloc, depth+1));\n\n        {\n        /*\n           * Inplace compress the table.*\n\n           For sparse data sets the table constructed by the trie algorithm will\n           be mostly 0/FAIL transitions or to put it another way mostly empty.\n           (Note that leaf nodes will not contain any transitions.)\n\n           This algorithm compresses the tables by eliminating most such\n           transitions, at the cost of a modest bit of extra work during lookup:\n\n           - Each states[] entry contains a .base field which indicates the\n           index in the state[] array wheres its transition data is stored.\n\n           - If .base is 0 there are no valid transitions from that node.\n\n           - If .base is nonzero then charid is added to it to find an entry in\n           the trans array.\n\n           -If trans[states[state].base+charid].check!=state then the\n           transition is taken to be a 0/Fail transition. Thus if there are fail\n           transitions at the front of the node then the .base offset will point\n           somewhere inside the previous nodes data (or maybe even into a node\n           even earlier), but the .check field determines if the transition is\n           valid.\n\n           XXX - wrong maybe?\n           The following process inplace converts the table to the compressed\n           table: We first do not compress the root node 1,and mark all its\n           .check pointers as 1 and set its .base pointer as 1 as well. This\n           allows us to do a DFA construction from the compressed table later,\n           and ensures that any .base pointers we calculate later are greater\n           than 0.\n\n           - We set 'pos' to indicate the first entry of the second node.\n\n           - We then iterate over the columns of the node, finding the first and\n           last used entry at l and m. We then copy l..m into pos..(pos+m-l),\n           and set the .check pointers accordingly, and advance pos\n           appropriately and repreat for the next node. Note that when we copy\n           the next pointers we have to convert them from the original\n           NODEIDX form to NODENUM form as the former is not valid post\n           compression.\n\n           - If a node has no transitions used we mark its base as 0 and do not\n           advance the pos pointer.\n\n           - If a node only has one transition we use a second pointer into the\n           structure to fill in allocated fail transitions from other states.\n           This pointer is independent of the main pointer and scans forward\n           looking for null transitions that are allocated to a state. When it\n           finds one it writes the single transition into the \"hole\".  If the\n           pointer doesnt find one the single transition is appended as normal.\n\n           - Once compressed we can Renew/realloc the structures to release the\n           excess space.\n\n           See \"Table-Compression Methods\" in sec 3.9 of the Red Dragon,\n           specifically Fig 3.47 and the associated pseudocode.\n\n           demq\n        */\n        const U32 laststate = TRIE_NODENUM( next_alloc );\n\tU32 state, charid;\n        U32 pos = 0, zp=0;\n        trie->statecount = laststate;\n\n        for ( state = 1 ; state < laststate ; state++ ) {\n            U8 flag = 0;\n\t    const U32 stateidx = TRIE_NODEIDX( state );\n\t    const U32 o_used = trie->trans[ stateidx ].check;\n\t    U32 used = trie->trans[ stateidx ].check;\n            trie->trans[ stateidx ].check = 0;\n\n            for ( charid = 0;\n                  used && charid < trie->uniquecharcount;\n                  charid++ )\n            {\n                if ( flag || trie->trans[ stateidx + charid ].next ) {\n                    if ( trie->trans[ stateidx + charid ].next ) {\n                        if (o_used == 1) {\n                            for ( ; zp < pos ; zp++ ) {\n                                if ( ! trie->trans[ zp ].next ) {\n                                    break;\n                                }\n                            }\n                            trie->states[ state ].trans.base\n                                                    = zp\n                                                      + trie->uniquecharcount\n                                                      - charid ;\n                            trie->trans[ zp ].next\n                                = SAFE_TRIE_NODENUM( trie->trans[ stateidx\n                                                             + charid ].next );\n                            trie->trans[ zp ].check = state;\n                            if ( ++zp > pos ) pos = zp;\n                            break;\n                        }\n                        used--;\n                    }\n                    if ( !flag ) {\n                        flag = 1;\n                        trie->states[ state ].trans.base\n                                       = pos + trie->uniquecharcount - charid ;\n                    }\n                    trie->trans[ pos ].next\n                        = SAFE_TRIE_NODENUM(\n                                       trie->trans[ stateidx + charid ].next );\n                    trie->trans[ pos ].check = state;\n                    pos++;\n                }\n            }\n        }\n        trie->lasttrans = pos + 1;\n        trie->states = (reg_trie_state *)\n\t    PerlMemShared_realloc( trie->states, laststate\n\t\t\t\t   * sizeof(reg_trie_state) );\n        DEBUG_TRIE_COMPILE_MORE_r(\n            Perl_re_indentf( aTHX_  \"Alloc: %d Orig: %\" IVdf \" elements, Final:%\" IVdf \". Savings of %%%5.2f\\n\",\n                depth+1,\n                (int)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount\n                       + 1 ),\n                (IV)next_alloc,\n                (IV)pos,\n                ( ( next_alloc - pos ) * 100 ) / (double)next_alloc );\n            );\n\n        } /* end table compress */\n    }\n    DEBUG_TRIE_COMPILE_MORE_r(\n            Perl_re_indentf( aTHX_  \"Statecount:%\" UVxf \" Lasttrans:%\" UVxf \"\\n\",\n                depth+1,\n                (UV)trie->statecount,\n                (UV)trie->lasttrans)\n    );\n    /* resize the trans array to remove unused space */\n    trie->trans = (reg_trie_trans *)\n\tPerlMemShared_realloc( trie->trans, trie->lasttrans\n\t\t\t       * sizeof(reg_trie_trans) );\n\n    {   /* Modify the program and insert the new TRIE node */\n        U8 nodetype =(U8)(flags & 0xFF);\n        char *str=NULL;\n\n#ifdef DEBUGGING\n        regnode *optimize = NULL;\n#ifdef RE_TRACK_PATTERN_OFFSETS\n\n        U32 mjd_offset = 0;\n        U32 mjd_nodelen = 0;\n#endif /* RE_TRACK_PATTERN_OFFSETS */\n#endif /* DEBUGGING */\n        /*\n           This means we convert either the first branch or the first Exact,\n           depending on whether the thing following (in 'last') is a branch\n           or not and whther first is the startbranch (ie is it a sub part of\n           the alternation or is it the whole thing.)\n           Assuming its a sub part we convert the EXACT otherwise we convert\n           the whole branch sequence, including the first.\n         */\n        /* Find the node we are going to overwrite */\n        if ( first != startbranch || OP( last ) == BRANCH ) {\n            /* branch sub-chain */\n            NEXT_OFF( first ) = (U16)(last - first);\n#ifdef RE_TRACK_PATTERN_OFFSETS\n            DEBUG_r({\n                mjd_offset= Node_Offset((convert));\n                mjd_nodelen= Node_Length((convert));\n            });\n#endif\n            /* whole branch chain */\n        }\n#ifdef RE_TRACK_PATTERN_OFFSETS\n        else {\n            DEBUG_r({\n                const  regnode *nop = NEXTOPER( convert );\n                mjd_offset= Node_Offset((nop));\n                mjd_nodelen= Node_Length((nop));\n            });\n        }\n        DEBUG_OPTIMISE_r(\n            Perl_re_indentf( aTHX_  \"MJD offset:%\" UVuf \" MJD length:%\" UVuf \"\\n\",\n                depth+1,\n                (UV)mjd_offset, (UV)mjd_nodelen)\n        );\n#endif\n        /* But first we check to see if there is a common prefix we can\n           split out as an EXACT and put in front of the TRIE node.  */\n        trie->startstate= 1;\n        if ( trie->bitmap && !widecharmap && !trie->jump  ) {\n            /* we want to find the first state that has more than\n             * one transition, if that state is not the first state\n             * then we have a common prefix which we can remove.\n             */\n            U32 state;\n            for ( state = 1 ; state < trie->statecount-1 ; state++ ) {\n                U32 ofs = 0;\n                I32 first_ofs = -1; /* keeps track of the ofs of the first\n                                       transition, -1 means none */\n                U32 count = 0;\n                const U32 base = trie->states[ state ].trans.base;\n\n                /* does this state terminate an alternation? */\n                if ( trie->states[state].wordnum )\n                        count = 1;\n\n                for ( ofs = 0 ; ofs < trie->uniquecharcount ; ofs++ ) {\n                    if ( ( base + ofs >= trie->uniquecharcount ) &&\n                         ( base + ofs - trie->uniquecharcount < trie->lasttrans ) &&\n                         trie->trans[ base + ofs - trie->uniquecharcount ].check == state )\n                    {\n                        if ( ++count > 1 ) {\n                            /* we have more than one transition */\n                            SV **tmp;\n                            U8 *ch;\n                            /* if this is the first state there is no common prefix\n                             * to extract, so we can exit */\n                            if ( state == 1 ) break;\n                            tmp = av_fetch( revcharmap, ofs, 0);\n                            ch = (U8*)SvPV_nolen_const( *tmp );\n\n                            /* if we are on count 2 then we need to initialize the\n                             * bitmap, and store the previous char if there was one\n                             * in it*/\n                            if ( count == 2 ) {\n                                /* clear the bitmap */\n                                Zero(trie->bitmap, ANYOF_BITMAP_SIZE, char);\n                                DEBUG_OPTIMISE_r(\n                                    Perl_re_indentf( aTHX_  \"New Start State=%\" UVuf \" Class: [\",\n                                        depth+1,\n                                        (UV)state));\n                                if (first_ofs >= 0) {\n                                    SV ** const tmp = av_fetch( revcharmap, first_ofs, 0);\n\t\t\t\t    const U8 * const ch = (U8*)SvPV_nolen_const( *tmp );\n\n                                    TRIE_BITMAP_SET_FOLDED(trie,*ch, folder);\n                                    DEBUG_OPTIMISE_r(\n                                        Perl_re_printf( aTHX_  \"%s\", (char*)ch)\n                                    );\n\t\t\t\t}\n\t\t\t    }\n                            /* store the current firstchar in the bitmap */\n                            TRIE_BITMAP_SET_FOLDED(trie,*ch, folder);\n                            DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"%s\", ch));\n\t\t\t}\n                        first_ofs = ofs;\n\t\t    }\n                }\n                if ( count == 1 ) {\n                    /* This state has only one transition, its transition is part\n                     * of a common prefix - we need to concatenate the char it\n                     * represents to what we have so far. */\n                    SV **tmp = av_fetch( revcharmap, first_ofs, 0);\n                    STRLEN len;\n                    char *ch = SvPV( *tmp, len );\n                    DEBUG_OPTIMISE_r({\n                        SV *sv=sv_newmortal();\n                        Perl_re_indentf( aTHX_  \"Prefix State: %\" UVuf \" Ofs:%\" UVuf \" Char='%s'\\n\",\n                            depth+1,\n                            (UV)state, (UV)first_ofs,\n                            pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), 6,\n\t                        PL_colors[0], PL_colors[1],\n\t                        (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |\n\t                        PERL_PV_ESCAPE_FIRSTCHAR\n                            )\n                        );\n                    });\n                    if ( state==1 ) {\n                        OP( convert ) = nodetype;\n                        str=STRING(convert);\n                        STR_LEN(convert)=0;\n                    }\n                    STR_LEN(convert) += len;\n                    while (len--)\n                        *str++ = *ch++;\n\t\t} else {\n#ifdef DEBUGGING\n\t\t    if (state>1)\n                        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"]\\n\"));\n#endif\n\t\t    break;\n\t\t}\n\t    }\n\t    trie->prefixlen = (state-1);\n            if (str) {\n                regnode *n = convert+NODE_SZ_STR(convert);\n                NEXT_OFF(convert) = NODE_SZ_STR(convert);\n                trie->startstate = state;\n                trie->minlen -= (state - 1);\n                trie->maxlen -= (state - 1);\n#ifdef DEBUGGING\n               /* At least the UNICOS C compiler choked on this\n                * being argument to DEBUG_r(), so let's just have\n                * it right here. */\n               if (\n#ifdef PERL_EXT_RE_BUILD\n                   1\n#else\n                   DEBUG_r_TEST\n#endif\n                   ) {\n                   regnode *fix = convert;\n                   U32 word = trie->wordcount;\n#ifdef RE_TRACK_PATTERN_OFFSETS\n                   mjd_nodelen++;\n#endif\n                   Set_Node_Offset_Length(convert, mjd_offset, state - 1);\n                   while( ++fix < n ) {\n                       Set_Node_Offset_Length(fix, 0, 0);\n                   }\n                   while (word--) {\n                       SV ** const tmp = av_fetch( trie_words, word, 0 );\n                       if (tmp) {\n                           if ( STR_LEN(convert) <= SvCUR(*tmp) )\n                               sv_chop(*tmp, SvPV_nolen(*tmp) + STR_LEN(convert));\n                           else\n                               sv_chop(*tmp, SvPV_nolen(*tmp) + SvCUR(*tmp));\n                       }\n                   }\n               }\n#endif\n                if (trie->maxlen) {\n                    convert = n;\n\t\t} else {\n                    NEXT_OFF(convert) = (U16)(tail - convert);\n                    DEBUG_r(optimize= n);\n                }\n            }\n        }\n        if (!jumper)\n            jumper = last;\n        if ( trie->maxlen ) {\n\t    NEXT_OFF( convert ) = (U16)(tail - convert);\n\t    ARG_SET( convert, data_slot );\n\t    /* Store the offset to the first unabsorbed branch in\n\t       jump[0], which is otherwise unused by the jump logic.\n\t       We use this when dumping a trie and during optimisation. */\n\t    if (trie->jump)\n\t        trie->jump[0] = (U16)(nextbranch - convert);\n\n            /* If the start state is not accepting (meaning there is no empty string/NOTHING)\n\t     *   and there is a bitmap\n\t     *   and the first \"jump target\" node we found leaves enough room\n\t     * then convert the TRIE node into a TRIEC node, with the bitmap\n\t     * embedded inline in the opcode - this is hypothetically faster.\n\t     */\n            if ( !trie->states[trie->startstate].wordnum\n\t\t && trie->bitmap\n\t\t && ( (char *)jumper - (char *)convert) >= (int)sizeof(struct regnode_charclass) )\n            {\n                OP( convert ) = TRIEC;\n                Copy(trie->bitmap, ((struct regnode_charclass *)convert)->bitmap, ANYOF_BITMAP_SIZE, char);\n                PerlMemShared_free(trie->bitmap);\n                trie->bitmap= NULL;\n            } else\n                OP( convert ) = TRIE;\n\n            /* store the type in the flags */\n            convert->flags = nodetype;\n            DEBUG_r({\n            optimize = convert\n                      + NODE_STEP_REGNODE\n                      + regarglen[ OP( convert ) ];\n            });\n            /* XXX We really should free up the resource in trie now,\n                   as we won't use them - (which resources?) dmq */\n        }\n        /* needed for dumping*/\n        DEBUG_r(if (optimize) {\n            regnode *opt = convert;\n\n            while ( ++opt < optimize) {\n                Set_Node_Offset_Length(opt, 0, 0);\n            }\n            /*\n                Try to clean up some of the debris left after the\n                optimisation.\n             */\n            while( optimize < jumper ) {\n                Track_Code( mjd_nodelen += Node_Length((optimize)); );\n                OP( optimize ) = OPTIMIZED;\n                Set_Node_Offset_Length(optimize, 0, 0);\n                optimize++;\n            }\n            Set_Node_Offset_Length(convert, mjd_offset, mjd_nodelen);\n        });\n    } /* end node insert */\n\n    /*  Finish populating the prev field of the wordinfo array.  Walk back\n     *  from each accept state until we find another accept state, and if\n     *  so, point the first word's .prev field at the second word. If the\n     *  second already has a .prev field set, stop now. This will be the\n     *  case either if we've already processed that word's accept state,\n     *  or that state had multiple words, and the overspill words were\n     *  already linked up earlier.\n     */\n    {\n\tU16 word;\n\tU32 state;\n\tU16 prev;\n\n\tfor (word=1; word <= trie->wordcount; word++) {\n\t    prev = 0;\n\t    if (trie->wordinfo[word].prev)\n\t\tcontinue;\n\t    state = trie->wordinfo[word].accept;\n\t    while (state) {\n\t\tstate = prev_states[state];\n\t\tif (!state)\n\t\t    break;\n\t\tprev = trie->states[state].wordnum;\n\t\tif (prev)\n\t\t    break;\n\t    }\n\t    trie->wordinfo[word].prev = prev;\n\t}\n\tSafefree(prev_states);\n    }\n\n\n    /* and now dump out the compressed format */\n    DEBUG_TRIE_COMPILE_r(dump_trie(trie, widecharmap, revcharmap, depth+1));\n\n    RExC_rxi->data->data[ data_slot + 1 ] = (void*)widecharmap;\n#ifdef DEBUGGING\n    RExC_rxi->data->data[ data_slot + TRIE_WORDS_OFFSET ] = (void*)trie_words;\n    RExC_rxi->data->data[ data_slot + 3 ] = (void*)revcharmap;\n#else\n    SvREFCNT_dec_NN(revcharmap);\n#endif\n    return trie->jump\n           ? MADE_JUMP_TRIE\n           : trie->startstate>1\n             ? MADE_EXACT_TRIE\n             : MADE_TRIE;\n}\n\nSTATIC regnode *\nS_construct_ahocorasick_from_trie(pTHX_ RExC_state_t *pRExC_state, regnode *source, U32 depth)\n{\n/* The Trie is constructed and compressed now so we can build a fail array if\n * it's needed\n\n   This is basically the Aho-Corasick algorithm. Its from exercise 3.31 and\n   3.32 in the\n   \"Red Dragon\" -- Compilers, principles, techniques, and tools. Aho, Sethi,\n   Ullman 1985/88\n   ISBN 0-201-10088-6\n\n   We find the fail state for each state in the trie, this state is the longest\n   proper suffix of the current state's 'word' that is also a proper prefix of\n   another word in our trie. State 1 represents the word '' and is thus the\n   default fail state. This allows the DFA not to have to restart after its\n   tried and failed a word at a given point, it simply continues as though it\n   had been matching the other word in the first place.\n   Consider\n      'abcdgu'=~/abcdefg|cdgu/\n   When we get to 'd' we are still matching the first word, we would encounter\n   'g' which would fail, which would bring us to the state representing 'd' in\n   the second word where we would try 'g' and succeed, proceeding to match\n   'cdgu'.\n */\n /* add a fail transition */\n    const U32 trie_offset = ARG(source);\n    reg_trie_data *trie=(reg_trie_data *)RExC_rxi->data->data[trie_offset];\n    U32 *q;\n    const U32 ucharcount = trie->uniquecharcount;\n    const U32 numstates = trie->statecount;\n    const U32 ubound = trie->lasttrans + ucharcount;\n    U32 q_read = 0;\n    U32 q_write = 0;\n    U32 charid;\n    U32 base = trie->states[ 1 ].trans.base;\n    U32 *fail;\n    reg_ac_data *aho;\n    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN(\"T\"));\n    regnode *stclass;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_CONSTRUCT_AHOCORASICK_FROM_TRIE;\n    PERL_UNUSED_CONTEXT;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    if ( OP(source) == TRIE ) {\n        struct regnode_1 *op = (struct regnode_1 *)\n            PerlMemShared_calloc(1, sizeof(struct regnode_1));\n        StructCopy(source, op, struct regnode_1);\n        stclass = (regnode *)op;\n    } else {\n        struct regnode_charclass *op = (struct regnode_charclass *)\n            PerlMemShared_calloc(1, sizeof(struct regnode_charclass));\n        StructCopy(source, op, struct regnode_charclass);\n        stclass = (regnode *)op;\n    }\n    OP(stclass)+=2; /* convert the TRIE type to its AHO-CORASICK equivalent */\n\n    ARG_SET( stclass, data_slot );\n    aho = (reg_ac_data *) PerlMemShared_calloc( 1, sizeof(reg_ac_data) );\n    RExC_rxi->data->data[ data_slot ] = (void*)aho;\n    aho->trie=trie_offset;\n    aho->states=(reg_trie_state *)PerlMemShared_malloc( numstates * sizeof(reg_trie_state) );\n    Copy( trie->states, aho->states, numstates, reg_trie_state );\n    Newx( q, numstates, U32);\n    aho->fail = (U32 *) PerlMemShared_calloc( numstates, sizeof(U32) );\n    aho->refcount = 1;\n    fail = aho->fail;\n    /* initialize fail[0..1] to be 1 so that we always have\n       a valid final fail state */\n    fail[ 0 ] = fail[ 1 ] = 1;\n\n    for ( charid = 0; charid < ucharcount ; charid++ ) {\n\tconst U32 newstate = TRIE_TRANS_STATE( 1, base, ucharcount, charid, 0 );\n\tif ( newstate ) {\n            q[ q_write ] = newstate;\n            /* set to point at the root */\n            fail[ q[ q_write++ ] ]=1;\n        }\n    }\n    while ( q_read < q_write) {\n\tconst U32 cur = q[ q_read++ % numstates ];\n        base = trie->states[ cur ].trans.base;\n\n        for ( charid = 0 ; charid < ucharcount ; charid++ ) {\n\t    const U32 ch_state = TRIE_TRANS_STATE( cur, base, ucharcount, charid, 1 );\n\t    if (ch_state) {\n                U32 fail_state = cur;\n                U32 fail_base;\n                do {\n                    fail_state = fail[ fail_state ];\n                    fail_base = aho->states[ fail_state ].trans.base;\n                } while ( !TRIE_TRANS_STATE( fail_state, fail_base, ucharcount, charid, 1 ) );\n\n                fail_state = TRIE_TRANS_STATE( fail_state, fail_base, ucharcount, charid, 1 );\n                fail[ ch_state ] = fail_state;\n                if ( !aho->states[ ch_state ].wordnum && aho->states[ fail_state ].wordnum )\n                {\n                        aho->states[ ch_state ].wordnum =  aho->states[ fail_state ].wordnum;\n                }\n                q[ q_write++ % numstates] = ch_state;\n            }\n        }\n    }\n    /* restore fail[0..1] to 0 so that we \"fall out\" of the AC loop\n       when we fail in state 1, this allows us to use the\n       charclass scan to find a valid start char. This is based on the principle\n       that theres a good chance the string being searched contains lots of stuff\n       that cant be a start char.\n     */\n    fail[ 0 ] = fail[ 1 ] = 0;\n    DEBUG_TRIE_COMPILE_r({\n        Perl_re_indentf( aTHX_  \"Stclass Failtable (%\" UVuf \" states): 0\",\n                      depth, (UV)numstates\n        );\n        for( q_read=1; q_read<numstates; q_read++ ) {\n            Perl_re_printf( aTHX_  \", %\" UVuf, (UV)fail[q_read]);\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    });\n    Safefree(q);\n    /*RExC_seen |= REG_TRIEDFA_SEEN;*/\n    return stclass;\n}\n\n\n/* The below joins as many adjacent EXACTish nodes as possible into a single\n * one.  The regop may be changed if the node(s) contain certain sequences that\n * require special handling.  The joining is only done if:\n * 1) there is room in the current conglomerated node to entirely contain the\n *    next one.\n * 2) they are compatible node types\n *\n * The adjacent nodes actually may be separated by NOTHING-kind nodes, and\n * these get optimized out\n *\n * XXX khw thinks this should be enhanced to fill EXACT (at least) nodes as full\n * as possible, even if that means splitting an existing node so that its first\n * part is moved to the preceeding node.  This would maximise the efficiency of\n * memEQ during matching.\n *\n * If a node is to match under /i (folded), the number of characters it matches\n * can be different than its character length if it contains a multi-character\n * fold.  *min_subtract is set to the total delta number of characters of the\n * input nodes.\n *\n * And *unfolded_multi_char is set to indicate whether or not the node contains\n * an unfolded multi-char fold.  This happens when it won't be known until\n * runtime whether the fold is valid or not; namely\n *  1) for EXACTF nodes that contain LATIN SMALL LETTER SHARP S, as only if the\n *      target string being matched against turns out to be UTF-8 is that fold\n *      valid; or\n *  2) for EXACTFL nodes whose folding rules depend on the locale in force at\n *      runtime.\n * (Multi-char folds whose components are all above the Latin1 range are not\n * run-time locale dependent, and have already been folded by the time this\n * function is called.)\n *\n * This is as good a place as any to discuss the design of handling these\n * multi-character fold sequences.  It's been wrong in Perl for a very long\n * time.  There are three code points in Unicode whose multi-character folds\n * were long ago discovered to mess things up.  The previous designs for\n * dealing with these involved assigning a special node for them.  This\n * approach doesn't always work, as evidenced by this example:\n *      \"\\xDFs\" =~ /s\\xDF/ui    # Used to fail before these patches\n * Both sides fold to \"sss\", but if the pattern is parsed to create a node that\n * would match just the \\xDF, it won't be able to handle the case where a\n * successful match would have to cross the node's boundary.  The new approach\n * that hopefully generally solves the problem generates an EXACTFUP node\n * that is \"sss\" in this case.\n *\n * It turns out that there are problems with all multi-character folds, and not\n * just these three.  Now the code is general, for all such cases.  The\n * approach taken is:\n * 1)   This routine examines each EXACTFish node that could contain multi-\n *      character folded sequences.  Since a single character can fold into\n *      such a sequence, the minimum match length for this node is less than\n *      the number of characters in the node.  This routine returns in\n *      *min_subtract how many characters to subtract from the the actual\n *      length of the string to get a real minimum match length; it is 0 if\n *      there are no multi-char foldeds.  This delta is used by the caller to\n *      adjust the min length of the match, and the delta between min and max,\n *      so that the optimizer doesn't reject these possibilities based on size\n *      constraints.\n *\n * 2)   For the sequence involving the LATIN SMALL LETTER SHARP S (U+00DF)\n *      under /u, we fold it to 'ss' in regatom(), and in this routine, after\n *      joining, we scan for occurrences of the sequence 'ss' in non-UTF-8\n *      EXACTFU nodes.  The node type of such nodes is then changed to\n *      EXACTFUP, indicating it is problematic, and needs careful handling.\n *      (The procedures in step 1) above are sufficient to handle this case in\n *      UTF-8 encoded nodes.)  The reason this is problematic is that this is\n *      the only case where there is a possible fold length change in non-UTF-8\n *      patterns.  By reserving a special node type for problematic cases, the\n *      far more common regular EXACTFU nodes can be processed faster.\n *      regexec.c takes advantage of this.\n *\n *      EXACTFUP has been created as a grab-bag for (hopefully uncommon)\n *      problematic cases.   These all only occur when the pattern is not\n *      UTF-8.  In addition to the 'ss' sequence where there is a possible fold\n *      length change, it handles the situation where the string cannot be\n *      entirely folded.  The strings in an EXACTFish node are folded as much\n *      as possible during compilation in regcomp.c.  This saves effort in\n *      regex matching.  By using an EXACTFUP node when it is not possible to\n *      fully fold at compile time, regexec.c can know that everything in an\n *      EXACTFU node is folded, so folding can be skipped at runtime.  The only\n *      case where folding in EXACTFU nodes can't be done at compile time is\n *      the presumably uncommon MICRO SIGN, when the pattern isn't UTF-8.  This\n *      is because its fold requires UTF-8 to represent.  Thus EXACTFUP nodes\n *      handle two very different cases.  Alternatively, there could have been\n *      a node type where there are length changes, one for unfolded, and one\n *      for both.  If yet another special case needed to be created, the number\n *      of required node types would have to go to 7.  khw figures that even\n *      though there are plenty of node types to spare, that the maintenance\n *      cost wasn't worth the small speedup of doing it that way, especially\n *      since he thinks the MICRO SIGN is rarely encountered in practice.\n *\n *      There are other cases where folding isn't done at compile time, but\n *      none of them are under /u, and hence not for EXACTFU nodes.  The folds\n *      in EXACTFL nodes aren't known until runtime, and vary as the locale\n *      changes.  Some folds in EXACTF depend on if the runtime target string\n *      is UTF-8 or not.  (regatom() will create an EXACTFU node even under /di\n *      when no fold in it depends on the UTF-8ness of the target string.)\n *\n * 3)   A problem remains for unfolded multi-char folds. (These occur when the\n *      validity of the fold won't be known until runtime, and so must remain\n *      unfolded for now.  This happens for the sharp s in EXACTF and EXACTFAA\n *      nodes when the pattern isn't in UTF-8.  (Note, BTW, that there cannot\n *      be an EXACTF node with a UTF-8 pattern.)  They also occur for various\n *      folds in EXACTFL nodes, regardless of the UTF-ness of the pattern.)\n *      The reason this is a problem is that the optimizer part of regexec.c\n *      (probably unwittingly, in Perl_regexec_flags()) makes an assumption\n *      that a character in the pattern corresponds to at most a single\n *      character in the target string.  (And I do mean character, and not byte\n *      here, unlike other parts of the documentation that have never been\n *      updated to account for multibyte Unicode.)  Sharp s in EXACTF and\n *      EXACTFL nodes can match the two character string 'ss'; in EXACTFAA\n *      nodes it can match \"\\x{17F}\\x{17F}\".  These, along with other ones in\n *      EXACTFL nodes, violate the assumption, and they are the only instances\n *      where it is violated.  I'm reluctant to try to change the assumption,\n *      as the code involved is impenetrable to me (khw), so instead the code\n *      here punts.  This routine examines EXACTFL nodes, and (when the pattern\n *      isn't UTF-8) EXACTF and EXACTFAA for such unfolded folds, and returns a\n *      boolean indicating whether or not the node contains such a fold.  When\n *      it is true, the caller sets a flag that later causes the optimizer in\n *      this file to not set values for the floating and fixed string lengths,\n *      and thus avoids the optimizer code in regexec.c that makes the invalid\n *      assumption.  Thus, there is no optimization based on string lengths for\n *      EXACTFL nodes that contain these few folds, nor for non-UTF8-pattern\n *      EXACTF and EXACTFAA nodes that contain the sharp s.  (The reason the\n *      assumption is wrong only in these cases is that all other non-UTF-8\n *      folds are 1-1; and, for UTF-8 patterns, we pre-fold all other folds to\n *      their expanded versions.  (Again, we can't prefold sharp s to 'ss' in\n *      EXACTF nodes because we don't know at compile time if it actually\n *      matches 'ss' or not.  For EXACTF nodes it will match iff the target\n *      string is in UTF-8.  This is in contrast to EXACTFU nodes, where it\n *      always matches; and EXACTFAA where it never does.  In an EXACTFAA node\n *      in a UTF-8 pattern, sharp s is folded to \"\\x{17F}\\x{17F}, avoiding the\n *      problem; but in a non-UTF8 pattern, folding it to that above-Latin1\n *      string would require the pattern to be forced into UTF-8, the overhead\n *      of which we want to avoid.  Similarly the unfolded multi-char folds in\n *      EXACTFL nodes will match iff the locale at the time of match is a UTF-8\n *      locale.)\n *\n *      Similarly, the code that generates tries doesn't currently handle\n *      not-already-folded multi-char folds, and it looks like a pain to change\n *      that.  Therefore, trie generation of EXACTFAA nodes with the sharp s\n *      doesn't work.  Instead, such an EXACTFAA is turned into a new regnode,\n *      EXACTFAA_NO_TRIE, which the trie code knows not to handle.  Most people\n *      using /iaa matching will be doing so almost entirely with ASCII\n *      strings, so this should rarely be encountered in practice */\n\n#define JOIN_EXACT(scan,min_subtract,unfolded_multi_char, flags) \\\n    if (PL_regkind[OP(scan)] == EXACT) \\\n        join_exact(pRExC_state,(scan),(min_subtract),unfolded_multi_char, (flags), NULL, depth+1)\n\nSTATIC U32\nS_join_exact(pTHX_ RExC_state_t *pRExC_state, regnode *scan,\n                   UV *min_subtract, bool *unfolded_multi_char,\n                   U32 flags, regnode *val, U32 depth)\n{\n    /* Merge several consecutive EXACTish nodes into one. */\n\n    regnode *n = regnext(scan);\n    U32 stringok = 1;\n    regnode *next = scan + NODE_SZ_STR(scan);\n    U32 merged = 0;\n    U32 stopnow = 0;\n#ifdef DEBUGGING\n    regnode *stop = scan;\n    GET_RE_DEBUG_FLAGS_DECL;\n#else\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    PERL_ARGS_ASSERT_JOIN_EXACT;\n#ifndef EXPERIMENTAL_INPLACESCAN\n    PERL_UNUSED_ARG(flags);\n    PERL_UNUSED_ARG(val);\n#endif\n    DEBUG_PEEP(\"join\", scan, depth, 0);\n\n    assert(PL_regkind[OP(scan)] == EXACT);\n\n    /* Look through the subsequent nodes in the chain.  Skip NOTHING, merge\n     * EXACT ones that are mergeable to the current one. */\n    while (    n\n           && (    PL_regkind[OP(n)] == NOTHING\n               || (stringok && PL_regkind[OP(n)] == EXACT))\n           && NEXT_OFF(n)\n           && NEXT_OFF(scan) + NEXT_OFF(n) < I16_MAX)\n    {\n\n        if (OP(n) == TAIL || n > next)\n            stringok = 0;\n        if (PL_regkind[OP(n)] == NOTHING) {\n            DEBUG_PEEP(\"skip:\", n, depth, 0);\n            NEXT_OFF(scan) += NEXT_OFF(n);\n            next = n + NODE_STEP_REGNODE;\n#ifdef DEBUGGING\n            if (stringok)\n                stop = n;\n#endif\n            n = regnext(n);\n        }\n        else if (stringok) {\n            const unsigned int oldl = STR_LEN(scan);\n            regnode * const nnext = regnext(n);\n\n            /* XXX I (khw) kind of doubt that this works on platforms (should\n             * Perl ever run on one) where U8_MAX is above 255 because of lots\n             * of other assumptions */\n            /* Don't join if the sum can't fit into a single node */\n            if (oldl + STR_LEN(n) > U8_MAX)\n                break;\n\n            /* Joining something that requires UTF-8 with something that\n             * doesn't, means the result requires UTF-8. */\n            if (OP(scan) == EXACT && (OP(n) == EXACT_ONLY8)) {\n                OP(scan) = EXACT_ONLY8;\n            }\n            else if (OP(scan) == EXACT_ONLY8 && (OP(n) == EXACT)) {\n                ;   /* join is compatible, no need to change OP */\n            }\n            else if ((OP(scan) == EXACTFU) && (OP(n) == EXACTFU_ONLY8)) {\n                OP(scan) = EXACTFU_ONLY8;\n            }\n            else if ((OP(scan) == EXACTFU_ONLY8) && (OP(n) == EXACTFU)) {\n                ;   /* join is compatible, no need to change OP */\n            }\n            else if (OP(scan) == EXACTFU && OP(n) == EXACTFU) {\n                ;   /* join is compatible, no need to change OP */\n            }\n            else if (OP(scan) == EXACTFU && OP(n) == EXACTFU_S_EDGE) {\n\n                 /* Under /di, temporary EXACTFU_S_EDGE nodes are generated,\n                  * which can join with EXACTFU ones.  We check for this case\n                  * here.  These need to be resolved to either EXACTFU or\n                  * EXACTF at joining time.  They have nothing in them that\n                  * would forbid them from being the more desirable EXACTFU\n                  * nodes except that they begin and/or end with a single [Ss].\n                  * The reason this is problematic is because they could be\n                  * joined in this loop with an adjacent node that ends and/or\n                  * begins with [Ss] which would then form the sequence 'ss',\n                  * which matches differently under /di than /ui, in which case\n                  * EXACTFU can't be used.  If the 'ss' sequence doesn't get\n                  * formed, the nodes get absorbed into any adjacent EXACTFU\n                  * node.  And if the only adjacent node is EXACTF, they get\n                  * absorbed into that, under the theory that a longer node is\n                  * better than two shorter ones, even if one is EXACTFU.  Note\n                  * that EXACTFU_ONLY8 is generated only for UTF-8 patterns,\n                  * and the EXACTFU_S_EDGE ones only for non-UTF-8.  */\n\n                if (STRING(n)[STR_LEN(n)-1] == 's') {\n\n                    /* Here the joined node would end with 's'.  If the node\n                     * following the combination is an EXACTF one, it's better to\n                     * join this trailing edge 's' node with that one, leaving the\n                     * current one in 'scan' be the more desirable EXACTFU */\n                    if (OP(nnext) == EXACTF) {\n                        break;\n                    }\n\n                    OP(scan) = EXACTFU_S_EDGE;\n\n                }   /* Otherwise, the beginning 's' of the 2nd node just\n                       becomes an interior 's' in 'scan' */\n            }\n            else if (OP(scan) == EXACTF && OP(n) == EXACTF) {\n                ;   /* join is compatible, no need to change OP */\n            }\n            else if (OP(scan) == EXACTF && OP(n) == EXACTFU_S_EDGE) {\n\n                /* EXACTF nodes are compatible for joining with EXACTFU_S_EDGE\n                 * nodes.  But the latter nodes can be also joined with EXACTFU\n                 * ones, and that is a better outcome, so if the node following\n                 * 'n' is EXACTFU, quit now so that those two can be joined\n                 * later */\n                if (OP(nnext) == EXACTFU) {\n                    break;\n                }\n\n                /* The join is compatible, and the combined node will be\n                 * EXACTF.  (These don't care if they begin or end with 's' */\n            }\n            else if (OP(scan) == EXACTFU_S_EDGE && OP(n) == EXACTFU_S_EDGE) {\n                if (   STRING(scan)[STR_LEN(scan)-1] == 's'\n                    && STRING(n)[0] == 's')\n                {\n                    /* When combined, we have the sequence 'ss', which means we\n                     * have to remain /di */\n                    OP(scan) = EXACTF;\n                }\n            }\n            else if (OP(scan) == EXACTFU_S_EDGE && OP(n) == EXACTFU) {\n                if (STRING(n)[0] == 's') {\n                    ;   /* Here the join is compatible and the combined node\n                           starts with 's', no need to change OP */\n                }\n                else {  /* Now the trailing 's' is in the interior */\n                    OP(scan) = EXACTFU;\n                }\n            }\n            else if (OP(scan) == EXACTFU_S_EDGE && OP(n) == EXACTF) {\n\n                /* The join is compatible, and the combined node will be\n                 * EXACTF.  (These don't care if they begin or end with 's' */\n                OP(scan) = EXACTF;\n            }\n            else if (OP(scan) != OP(n)) {\n\n                /* The only other compatible joinings are the same node type */\n                break;\n            }\n\n            DEBUG_PEEP(\"merg\", n, depth, 0);\n            merged++;\n\n            NEXT_OFF(scan) += NEXT_OFF(n);\n            STR_LEN(scan) += STR_LEN(n);\n            next = n + NODE_SZ_STR(n);\n            /* Now we can overwrite *n : */\n            Move(STRING(n), STRING(scan) + oldl, STR_LEN(n), char);\n#ifdef DEBUGGING\n            stop = next - 1;\n#endif\n            n = nnext;\n            if (stopnow) break;\n        }\n\n#ifdef EXPERIMENTAL_INPLACESCAN\n\tif (flags && !NEXT_OFF(n)) {\n\t    DEBUG_PEEP(\"atch\", val, depth, 0);\n\t    if (reg_off_by_arg[OP(n)]) {\n\t\tARG_SET(n, val - n);\n\t    }\n\t    else {\n\t\tNEXT_OFF(n) = val - n;\n\t    }\n\t    stopnow = 1;\n\t}\n#endif\n    }\n\n    /* This temporary node can now be turned into EXACTFU, and must, as\n     * regexec.c doesn't handle it */\n    if (OP(scan) == EXACTFU_S_EDGE) {\n        OP(scan) = EXACTFU;\n    }\n\n    *min_subtract = 0;\n    *unfolded_multi_char = FALSE;\n\n    /* Here, all the adjacent mergeable EXACTish nodes have been merged.  We\n     * can now analyze for sequences of problematic code points.  (Prior to\n     * this final joining, sequences could have been split over boundaries, and\n     * hence missed).  The sequences only happen in folding, hence for any\n     * non-EXACT EXACTish node */\n    if (OP(scan) != EXACT && OP(scan) != EXACT_ONLY8 && OP(scan) != EXACTL) {\n        U8* s0 = (U8*) STRING(scan);\n        U8* s = s0;\n        U8* s_end = s0 + STR_LEN(scan);\n\n        int total_count_delta = 0;  /* Total delta number of characters that\n                                       multi-char folds expand to */\n\n\t/* One pass is made over the node's string looking for all the\n\t * possibilities.  To avoid some tests in the loop, there are two main\n\t * cases, for UTF-8 patterns (which can't have EXACTF nodes) and\n\t * non-UTF-8 */\n\tif (UTF) {\n            U8* folded = NULL;\n\n            if (OP(scan) == EXACTFL) {\n                U8 *d;\n\n                /* An EXACTFL node would already have been changed to another\n                 * node type unless there is at least one character in it that\n                 * is problematic; likely a character whose fold definition\n                 * won't be known until runtime, and so has yet to be folded.\n                 * For all but the UTF-8 locale, folds are 1-1 in length, but\n                 * to handle the UTF-8 case, we need to create a temporary\n                 * folded copy using UTF-8 locale rules in order to analyze it.\n                 * This is because our macros that look to see if a sequence is\n                 * a multi-char fold assume everything is folded (otherwise the\n                 * tests in those macros would be too complicated and slow).\n                 * Note that here, the non-problematic folds will have already\n                 * been done, so we can just copy such characters.  We actually\n                 * don't completely fold the EXACTFL string.  We skip the\n                 * unfolded multi-char folds, as that would just create work\n                 * below to figure out the size they already are */\n\n                Newx(folded, UTF8_MAX_FOLD_CHAR_EXPAND * STR_LEN(scan) + 1, U8);\n                d = folded;\n                while (s < s_end) {\n                    STRLEN s_len = UTF8SKIP(s);\n                    if (! is_PROBLEMATIC_LOCALE_FOLD_utf8(s)) {\n                        Copy(s, d, s_len, U8);\n                        d += s_len;\n                    }\n                    else if (is_FOLDS_TO_MULTI_utf8(s)) {\n                        *unfolded_multi_char = TRUE;\n                        Copy(s, d, s_len, U8);\n                        d += s_len;\n                    }\n                    else if (isASCII(*s)) {\n                        *(d++) = toFOLD(*s);\n                    }\n                    else {\n                        STRLEN len;\n                        _toFOLD_utf8_flags(s, s_end, d, &len, FOLD_FLAGS_FULL);\n                        d += len;\n                    }\n                    s += s_len;\n                }\n\n                /* Point the remainder of the routine to look at our temporary\n                 * folded copy */\n                s = folded;\n                s_end = d;\n            } /* End of creating folded copy of EXACTFL string */\n\n            /* Examine the string for a multi-character fold sequence.  UTF-8\n             * patterns have all characters pre-folded by the time this code is\n             * executed */\n            while (s < s_end - 1) /* Can stop 1 before the end, as minimum\n                                     length sequence we are looking for is 2 */\n\t    {\n                int count = 0;  /* How many characters in a multi-char fold */\n                int len = is_MULTI_CHAR_FOLD_utf8_safe(s, s_end);\n                if (! len) {    /* Not a multi-char fold: get next char */\n                    s += UTF8SKIP(s);\n                    continue;\n                }\n\n                { /* Here is a generic multi-char fold. */\n                    U8* multi_end  = s + len;\n\n                    /* Count how many characters are in it.  In the case of\n                     * /aa, no folds which contain ASCII code points are\n                     * allowed, so check for those, and skip if found. */\n                    if (OP(scan) != EXACTFAA && OP(scan) != EXACTFAA_NO_TRIE) {\n                        count = utf8_length(s, multi_end);\n                        s = multi_end;\n                    }\n                    else {\n                        while (s < multi_end) {\n                            if (isASCII(*s)) {\n                                s++;\n                                goto next_iteration;\n                            }\n                            else {\n                                s += UTF8SKIP(s);\n                            }\n                            count++;\n                        }\n                    }\n                }\n\n                /* The delta is how long the sequence is minus 1 (1 is how long\n                 * the character that folds to the sequence is) */\n                total_count_delta += count - 1;\n              next_iteration: ;\n\t    }\n\n            /* We created a temporary folded copy of the string in EXACTFL\n             * nodes.  Therefore we need to be sure it doesn't go below zero,\n             * as the real string could be shorter */\n            if (OP(scan) == EXACTFL) {\n                int total_chars = utf8_length((U8*) STRING(scan),\n                                           (U8*) STRING(scan) + STR_LEN(scan));\n                if (total_count_delta > total_chars) {\n                    total_count_delta = total_chars;\n                }\n            }\n\n            *min_subtract += total_count_delta;\n            Safefree(folded);\n\t}\n\telse if (OP(scan) == EXACTFAA) {\n\n            /* Non-UTF-8 pattern, EXACTFAA node.  There can't be a multi-char\n             * fold to the ASCII range (and there are no existing ones in the\n             * upper latin1 range).  But, as outlined in the comments preceding\n             * this function, we need to flag any occurrences of the sharp s.\n             * This character forbids trie formation (because of added\n             * complexity) */\n#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \\\n   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \\\n                                      || UNICODE_DOT_DOT_VERSION > 0)\n\t    while (s < s_end) {\n                if (*s == LATIN_SMALL_LETTER_SHARP_S) {\n                    OP(scan) = EXACTFAA_NO_TRIE;\n                    *unfolded_multi_char = TRUE;\n                    break;\n                }\n                s++;\n            }\n        }\n\telse {\n\n            /* Non-UTF-8 pattern, not EXACTFAA node.  Look for the multi-char\n             * folds that are all Latin1.  As explained in the comments\n             * preceding this function, we look also for the sharp s in EXACTF\n             * and EXACTFL nodes; it can be in the final position.  Otherwise\n             * we can stop looking 1 byte earlier because have to find at least\n             * two characters for a multi-fold */\n\t    const U8* upper = (OP(scan) == EXACTF || OP(scan) == EXACTFL)\n                              ? s_end\n                              : s_end -1;\n\n\t    while (s < upper) {\n                int len = is_MULTI_CHAR_FOLD_latin1_safe(s, s_end);\n                if (! len) {    /* Not a multi-char fold. */\n                    if (*s == LATIN_SMALL_LETTER_SHARP_S\n                        && (OP(scan) == EXACTF || OP(scan) == EXACTFL))\n                    {\n                        *unfolded_multi_char = TRUE;\n                    }\n                    s++;\n                    continue;\n                }\n\n                if (len == 2\n                    && isALPHA_FOLD_EQ(*s, 's')\n                    && isALPHA_FOLD_EQ(*(s+1), 's'))\n                {\n\n                    /* EXACTF nodes need to know that the minimum length\n                     * changed so that a sharp s in the string can match this\n                     * ss in the pattern, but they remain EXACTF nodes, as they\n                     * won't match this unless the target string is is UTF-8,\n                     * which we don't know until runtime.  EXACTFL nodes can't\n                     * transform into EXACTFU nodes */\n                    if (OP(scan) != EXACTF && OP(scan) != EXACTFL) {\n                        OP(scan) = EXACTFUP;\n                    }\n\t\t}\n\n                *min_subtract += len - 1;\n                s += len;\n\t    }\n#endif\n\t}\n\n        if (     STR_LEN(scan) == 1\n            &&   isALPHA_A(* STRING(scan))\n            &&  (         OP(scan) == EXACTFAA\n                 || (     OP(scan) == EXACTFU\n                     && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(* STRING(scan)))))\n        {\n            U8 mask = ~ ('A' ^ 'a'); /* These differ in just one bit */\n\n            /* Replace a length 1 ASCII fold pair node with an ANYOFM node,\n             * with the mask set to the complement of the bit that differs\n             * between upper and lower case, and the lowest code point of the\n             * pair (which the '&' forces) */\n            OP(scan) = ANYOFM;\n            ARG_SET(scan, *STRING(scan) & mask);\n            FLAGS(scan) = mask;\n        }\n    }\n\n#ifdef DEBUGGING\n    /* Allow dumping but overwriting the collection of skipped\n     * ops and/or strings with fake optimized ops */\n    n = scan + NODE_SZ_STR(scan);\n    while (n <= stop) {\n\tOP(n) = OPTIMIZED;\n\tFLAGS(n) = 0;\n\tNEXT_OFF(n) = 0;\n        n++;\n    }\n#endif\n    DEBUG_OPTIMISE_r(if (merged){DEBUG_PEEP(\"finl\", scan, depth, 0);});\n    return stopnow;\n}\n\n/* REx optimizer.  Converts nodes into quicker variants \"in place\".\n   Finds fixed substrings.  */\n\n/* Stops at toplevel WHILEM as well as at \"last\". At end *scanp is set\n   to the position after last scanned or to NULL. */\n\n#define INIT_AND_WITHP \\\n    assert(!and_withp); \\\n    Newx(and_withp, 1, regnode_ssc); \\\n    SAVEFREEPV(and_withp)\n\n\nstatic void\nS_unwind_scan_frames(pTHX_ const void *p)\n{\n    scan_frame *f= (scan_frame *)p;\n    do {\n        scan_frame *n= f->next_frame;\n        Safefree(f);\n        f= n;\n    } while (f);\n}\n\n/* Follow the next-chain of the current node and optimize away\n   all the NOTHINGs from it.\n */\nSTATIC void\nS_rck_elide_nothing(pTHX_ regnode *node)\n{\n    dVAR;\n\n    PERL_ARGS_ASSERT_RCK_ELIDE_NOTHING;\n\n    if (OP(node) != CURLYX) {\n        const int max = (reg_off_by_arg[OP(node)]\n                        ? I32_MAX\n                          /* I32 may be smaller than U16 on CRAYs! */\n                        : (I32_MAX < U16_MAX ? I32_MAX : U16_MAX));\n        int off = (reg_off_by_arg[OP(node)] ? ARG(node) : NEXT_OFF(node));\n        int noff;\n        regnode *n = node;\n\n        /* Skip NOTHING and LONGJMP. */\n        while (\n            (n = regnext(n))\n            && (\n                (PL_regkind[OP(n)] == NOTHING && (noff = NEXT_OFF(n)))\n                || ((OP(n) == LONGJMP) && (noff = ARG(n)))\n            )\n            && off + noff < max\n        ) {\n            off += noff;\n        }\n        if (reg_off_by_arg[OP(node)])\n            ARG(node) = off;\n        else\n            NEXT_OFF(node) = off;\n    }\n    return;\n}\n\n/* the return from this sub is the minimum length that could possibly match */\nSTATIC SSize_t\nS_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp,\n                        SSize_t *minlenp, SSize_t *deltap,\n\t\t\tregnode *last,\n\t\t\tscan_data_t *data,\n\t\t\tI32 stopparen,\n                        U32 recursed_depth,\n\t\t\tregnode_ssc *and_withp,\n\t\t\tU32 flags, U32 depth)\n\t\t\t/* scanp: Start here (read-write). */\n\t\t\t/* deltap: Write maxlen-minlen here. */\n\t\t\t/* last: Stop before this one. */\n\t\t\t/* data: string data about the pattern */\n\t\t\t/* stopparen: treat close N as END */\n\t\t\t/* recursed: which subroutines have we recursed into */\n\t\t\t/* and_withp: Valid if flags & SCF_DO_STCLASS_OR */\n{\n    dVAR;\n    /* There must be at least this number of characters to match */\n    SSize_t min = 0;\n    I32 pars = 0, code;\n    regnode *scan = *scanp, *next;\n    SSize_t delta = 0;\n    int is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);\n    int is_inf_internal = 0;\t\t/* The studied chunk is infinite */\n    I32 is_par = OP(scan) == OPEN ? ARG(scan) : 0;\n    scan_data_t data_fake;\n    SV *re_trie_maxbuff = NULL;\n    regnode *first_non_open = scan;\n    SSize_t stopmin = SSize_t_MAX;\n    scan_frame *frame = NULL;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_STUDY_CHUNK;\n    RExC_study_started= 1;\n\n    Zero(&data_fake, 1, scan_data_t);\n\n    if ( depth == 0 ) {\n        while (first_non_open && OP(first_non_open) == OPEN)\n            first_non_open=regnext(first_non_open);\n    }\n\n\n  fake_study_recurse:\n    DEBUG_r(\n        RExC_study_chunk_recursed_count++;\n    );\n    DEBUG_OPTIMISE_MORE_r(\n    {\n        Perl_re_indentf( aTHX_  \"study_chunk stopparen=%ld recursed_count=%lu depth=%lu recursed_depth=%lu scan=%p last=%p\",\n            depth, (long)stopparen,\n            (unsigned long)RExC_study_chunk_recursed_count,\n            (unsigned long)depth, (unsigned long)recursed_depth,\n            scan,\n            last);\n        if (recursed_depth) {\n            U32 i;\n            U32 j;\n            for ( j = 0 ; j < recursed_depth ; j++ ) {\n                for ( i = 0 ; i < (U32)RExC_total_parens ; i++ ) {\n                    if (\n                        PAREN_TEST(RExC_study_chunk_recursed +\n                                   ( j * RExC_study_chunk_recursed_bytes), i )\n                        && (\n                            !j ||\n                            !PAREN_TEST(RExC_study_chunk_recursed +\n                                   (( j - 1 ) * RExC_study_chunk_recursed_bytes), i)\n                        )\n                    ) {\n                        Perl_re_printf( aTHX_ \" %d\",(int)i);\n                        break;\n                    }\n                }\n                if ( j + 1 < recursed_depth ) {\n                    Perl_re_printf( aTHX_  \",\");\n                }\n            }\n        }\n        Perl_re_printf( aTHX_ \"\\n\");\n    }\n    );\n    while ( scan && OP(scan) != END && scan < last ){\n        UV min_subtract = 0;    /* How mmany chars to subtract from the minimum\n                                   node length to get a real minimum (because\n                                   the folded version may be shorter) */\n\tbool unfolded_multi_char = FALSE;\n\t/* Peephole optimizer: */\n        DEBUG_STUDYDATA(\"Peep\", data, depth, is_inf);\n        DEBUG_PEEP(\"Peep\", scan, depth, flags);\n\n\n        /* The reason we do this here is that we need to deal with things like\n         * /(?:f)(?:o)(?:o)/ which cant be dealt with by the normal EXACT\n         * parsing code, as each (?:..) is handled by a different invocation of\n         * reg() -- Yves\n         */\n        JOIN_EXACT(scan,&min_subtract, &unfolded_multi_char, 0);\n\n        /* Follow the next-chain of the current node and optimize\n           away all the NOTHINGs from it.\n         */\n        rck_elide_nothing(scan);\n\n\t/* The principal pseudo-switch.  Cannot be a switch, since we\n\t   look into several different things.  */\n        if ( OP(scan) == DEFINEP ) {\n            SSize_t minlen = 0;\n            SSize_t deltanext = 0;\n            SSize_t fake_last_close = 0;\n            I32 f = SCF_IN_DEFINE;\n\n            StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n            scan = regnext(scan);\n            assert( OP(scan) == IFTHEN );\n            DEBUG_PEEP(\"expect IFTHEN\", scan, depth, flags);\n\n            data_fake.last_closep= &fake_last_close;\n            minlen = *minlenp;\n            next = regnext(scan);\n            scan = NEXTOPER(NEXTOPER(scan));\n            DEBUG_PEEP(\"scan\", scan, depth, flags);\n            DEBUG_PEEP(\"next\", next, depth, flags);\n\n            /* we suppose the run is continuous, last=next...\n             * NOTE we dont use the return here! */\n            /* DEFINEP study_chunk() recursion */\n            (void)study_chunk(pRExC_state, &scan, &minlen,\n                              &deltanext, next, &data_fake, stopparen,\n                              recursed_depth, NULL, f, depth+1);\n\n            scan = next;\n        } else\n        if (\n            OP(scan) == BRANCH  ||\n            OP(scan) == BRANCHJ ||\n            OP(scan) == IFTHEN\n        ) {\n\t    next = regnext(scan);\n\t    code = OP(scan);\n\n            /* The op(next)==code check below is to see if we\n             * have \"BRANCH-BRANCH\", \"BRANCHJ-BRANCHJ\", \"IFTHEN-IFTHEN\"\n             * IFTHEN is special as it might not appear in pairs.\n             * Not sure whether BRANCH-BRANCHJ is possible, regardless\n             * we dont handle it cleanly. */\n\t    if (OP(next) == code || code == IFTHEN) {\n                /* NOTE - There is similar code to this block below for\n                 * handling TRIE nodes on a re-study.  If you change stuff here\n                 * check there too. */\n\t\tSSize_t max1 = 0, min1 = SSize_t_MAX, num = 0;\n\t\tregnode_ssc accum;\n\t\tregnode * const startbranch=scan;\n\n                if (flags & SCF_DO_SUBSTR) {\n                    /* Cannot merge strings after this. */\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n                }\n\n                if (flags & SCF_DO_STCLASS)\n\t\t    ssc_init_zero(pRExC_state, &accum);\n\n\t\twhile (OP(scan) == code) {\n\t\t    SSize_t deltanext, minnext, fake;\n\t\t    I32 f = 0;\n\t\t    regnode_ssc this_class;\n\n                    DEBUG_PEEP(\"Branch\", scan, depth, flags);\n\n\t\t    num++;\n                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n\t\t    if (data) {\n\t\t\tdata_fake.whilem_c = data->whilem_c;\n\t\t\tdata_fake.last_closep = data->last_closep;\n\t\t    }\n\t\t    else\n\t\t\tdata_fake.last_closep = &fake;\n\n\t\t    data_fake.pos_delta = delta;\n\t\t    next = regnext(scan);\n\n                    scan = NEXTOPER(scan); /* everything */\n                    if (code != BRANCH)    /* everything but BRANCH */\n\t\t\tscan = NEXTOPER(scan);\n\n\t\t    if (flags & SCF_DO_STCLASS) {\n\t\t\tssc_init(pRExC_state, &this_class);\n\t\t\tdata_fake.start_class = &this_class;\n\t\t\tf = SCF_DO_STCLASS_AND;\n\t\t    }\n\t\t    if (flags & SCF_WHILEM_VISITED_POS)\n\t\t\tf |= SCF_WHILEM_VISITED_POS;\n\n\t\t    /* we suppose the run is continuous, last=next...*/\n                    /* recurse study_chunk() for each BRANCH in an alternation */\n\t\t    minnext = study_chunk(pRExC_state, &scan, minlenp,\n                                      &deltanext, next, &data_fake, stopparen,\n                                      recursed_depth, NULL, f, depth+1);\n\n\t\t    if (min1 > minnext)\n\t\t\tmin1 = minnext;\n\t\t    if (deltanext == SSize_t_MAX) {\n\t\t\tis_inf = is_inf_internal = 1;\n\t\t\tmax1 = SSize_t_MAX;\n\t\t    } else if (max1 < minnext + deltanext)\n\t\t\tmax1 = minnext + deltanext;\n\t\t    scan = next;\n\t\t    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n\t\t\tpars++;\n\t            if (data_fake.flags & SCF_SEEN_ACCEPT) {\n\t                if ( stopmin > minnext)\n\t                    stopmin = min + min1;\n\t                flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n\t\t    if (data) {\n\t\t\tif (data_fake.flags & SF_HAS_EVAL)\n\t\t\t    data->flags |= SF_HAS_EVAL;\n\t\t\tdata->whilem_c = data_fake.whilem_c;\n\t\t    }\n\t\t    if (flags & SCF_DO_STCLASS)\n\t\t\tssc_or(pRExC_state, &accum, (regnode_charclass*)&this_class);\n\t\t}\n\t\tif (code == IFTHEN && num < 2) /* Empty ELSE branch */\n\t\t    min1 = 0;\n\t\tif (flags & SCF_DO_SUBSTR) {\n\t\t    data->pos_min += min1;\n\t\t    if (data->pos_delta >= SSize_t_MAX - (max1 - min1))\n\t\t        data->pos_delta = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += max1 - min1;\n\t\t    if (max1 != min1 || is_inf)\n\t\t\tdata->cur_is_floating = 1;\n\t\t}\n\t\tmin += min1;\n\t\tif (delta == SSize_t_MAX\n\t\t || SSize_t_MAX - delta - (max1 - min1) < 0)\n\t\t    delta = SSize_t_MAX;\n\t\telse\n\t\t    delta += max1 - min1;\n\t\tif (flags & SCF_DO_STCLASS_OR) {\n\t\t    ssc_or(pRExC_state, data->start_class, (regnode_charclass*) &accum);\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t}\n\t\telse if (flags & SCF_DO_STCLASS_AND) {\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t    else {\n\t\t\t/* Switch to OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\t\t\tStructCopy(&accum, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n\t\t    }\n\t\t}\n\n                if (PERL_ENABLE_TRIE_OPTIMISATION &&\n                        OP( startbranch ) == BRANCH )\n                {\n\t\t/* demq.\n\n                   Assuming this was/is a branch we are dealing with: 'scan'\n                   now points at the item that follows the branch sequence,\n                   whatever it is. We now start at the beginning of the\n                   sequence and look for subsequences of\n\n\t\t   BRANCH->EXACT=>x1\n\t\t   BRANCH->EXACT=>x2\n\t\t   tail\n\n                   which would be constructed from a pattern like\n                   /A|LIST|OF|WORDS/\n\n\t\t   If we can find such a subsequence we need to turn the first\n\t\t   element into a trie and then add the subsequent branch exact\n\t\t   strings to the trie.\n\n\t\t   We have two cases\n\n                     1. patterns where the whole set of branches can be\n                        converted.\n\n\t\t     2. patterns where only a subset can be converted.\n\n\t\t   In case 1 we can replace the whole set with a single regop\n\t\t   for the trie. In case 2 we need to keep the start and end\n\t\t   branches so\n\n\t\t     'BRANCH EXACT; BRANCH EXACT; BRANCH X'\n\t\t     becomes BRANCH TRIE; BRANCH X;\n\n\t\t  There is an additional case, that being where there is a\n\t\t  common prefix, which gets split out into an EXACT like node\n\t\t  preceding the TRIE node.\n\n\t\t  If x(1..n)==tail then we can do a simple trie, if not we make\n\t\t  a \"jump\" trie, such that when we match the appropriate word\n\t\t  we \"jump\" to the appropriate tail node. Essentially we turn\n\t\t  a nested if into a case structure of sorts.\n\n\t\t*/\n\n\t\t    int made=0;\n\t\t    if (!re_trie_maxbuff) {\n\t\t\tre_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1);\n\t\t\tif (!SvIOK(re_trie_maxbuff))\n\t\t\t    sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);\n\t\t    }\n                    if ( SvIV(re_trie_maxbuff)>=0  ) {\n                        regnode *cur;\n                        regnode *first = (regnode *)NULL;\n                        regnode *last = (regnode *)NULL;\n                        regnode *tail = scan;\n                        U8 trietype = 0;\n                        U32 count=0;\n\n                        /* var tail is used because there may be a TAIL\n                           regop in the way. Ie, the exacts will point to the\n                           thing following the TAIL, but the last branch will\n                           point at the TAIL. So we advance tail. If we\n                           have nested (?:) we may have to move through several\n                           tails.\n                         */\n\n                        while ( OP( tail ) == TAIL ) {\n                            /* this is the TAIL generated by (?:) */\n                            tail = regnext( tail );\n                        }\n\n\n                        DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx, RExC_mysv, tail, NULL, pRExC_state);\n                            Perl_re_indentf( aTHX_  \"%s %\" UVuf \":%s\\n\",\n                              depth+1,\n                              \"Looking for TRIE'able sequences. Tail node is \",\n                              (UV) REGNODE_OFFSET(tail),\n                              SvPV_nolen_const( RExC_mysv )\n                            );\n                        });\n\n                        /*\n\n                            Step through the branches\n                                cur represents each branch,\n                                noper is the first thing to be matched as part\n                                      of that branch\n                                noper_next is the regnext() of that node.\n\n                            We normally handle a case like this\n                            /FOO[xyz]|BAR[pqr]/ via a \"jump trie\" but we also\n                            support building with NOJUMPTRIE, which restricts\n                            the trie logic to structures like /FOO|BAR/.\n\n                            If noper is a trieable nodetype then the branch is\n                            a possible optimization target. If we are building\n                            under NOJUMPTRIE then we require that noper_next is\n                            the same as scan (our current position in the regex\n                            program).\n\n                            Once we have two or more consecutive such branches\n                            we can create a trie of the EXACT's contents and\n                            stitch it in place into the program.\n\n                            If the sequence represents all of the branches in\n                            the alternation we replace the entire thing with a\n                            single TRIE node.\n\n                            Otherwise when it is a subsequence we need to\n                            stitch it in place and replace only the relevant\n                            branches. This means the first branch has to remain\n                            as it is used by the alternation logic, and its\n                            next pointer, and needs to be repointed at the item\n                            on the branch chain following the last branch we\n                            have optimized away.\n\n                            This could be either a BRANCH, in which case the\n                            subsequence is internal, or it could be the item\n                            following the branch sequence in which case the\n                            subsequence is at the end (which does not\n                            necessarily mean the first node is the start of the\n                            alternation).\n\n                            TRIE_TYPE(X) is a define which maps the optype to a\n                            trietype.\n\n                                optype          |  trietype\n                                ----------------+-----------\n                                NOTHING         | NOTHING\n                                EXACT           | EXACT\n                                EXACT_ONLY8     | EXACT\n                                EXACTFU         | EXACTFU\n                                EXACTFU_ONLY8   | EXACTFU\n                                EXACTFUP        | EXACTFU\n                                EXACTFAA        | EXACTFAA\n                                EXACTL          | EXACTL\n                                EXACTFLU8       | EXACTFLU8\n\n\n                        */\n#define TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \\\n                       ? NOTHING                                            \\\n                       : ( EXACT == (X) || EXACT_ONLY8 == (X) )             \\\n                         ? EXACT                                            \\\n                         : (     EXACTFU == (X)                             \\\n                              || EXACTFU_ONLY8 == (X)                       \\\n                              || EXACTFUP == (X) )                          \\\n                           ? EXACTFU                                        \\\n                           : ( EXACTFAA == (X) )                            \\\n                             ? EXACTFAA                                     \\\n                             : ( EXACTL == (X) )                            \\\n                               ? EXACTL                                     \\\n                               : ( EXACTFLU8 == (X) )                       \\\n                                 ? EXACTFLU8                                \\\n                                 : 0 )\n\n                        /* dont use tail as the end marker for this traverse */\n                        for ( cur = startbranch ; cur != scan ; cur = regnext( cur ) ) {\n                            regnode * const noper = NEXTOPER( cur );\n                            U8 noper_type = OP( noper );\n                            U8 noper_trietype = TRIE_TYPE( noper_type );\n#if defined(DEBUGGING) || defined(NOJUMPTRIE)\n                            regnode * const noper_next = regnext( noper );\n                            U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n                            U8 noper_next_trietype = (noper_next && noper_next < tail) ? TRIE_TYPE( noper_next_type ) :0;\n#endif\n\n                            DEBUG_TRIE_COMPILE_r({\n                                regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                Perl_re_indentf( aTHX_  \"- %d:%s (%d)\",\n                                   depth+1,\n                                   REG_NODE_NUM(cur), SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur) );\n\n                                regprop(RExC_rx, RExC_mysv, noper, NULL, pRExC_state);\n                                Perl_re_printf( aTHX_  \" -> %d:%s\",\n                                    REG_NODE_NUM(noper), SvPV_nolen_const(RExC_mysv));\n\n                                if ( noper_next ) {\n                                  regprop(RExC_rx, RExC_mysv, noper_next, NULL, pRExC_state);\n                                  Perl_re_printf( aTHX_ \"\\t=> %d:%s\\t\",\n                                    REG_NODE_NUM(noper_next), SvPV_nolen_const(RExC_mysv));\n                                }\n                                Perl_re_printf( aTHX_  \"(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\\n\",\n                                   REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n\t\t\t\t   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype]\n\t\t\t\t);\n                            });\n\n                            /* Is noper a trieable nodetype that can be merged\n                             * with the current trie (if there is one)? */\n                            if ( noper_trietype\n                                  &&\n                                  (\n                                        ( noper_trietype == NOTHING )\n                                        || ( trietype == NOTHING )\n                                        || ( trietype == noper_trietype )\n                                  )\n#ifdef NOJUMPTRIE\n                                  && noper_next >= tail\n#endif\n                                  && count < U16_MAX)\n                            {\n                                /* Handle mergable triable node Either we are\n                                 * the first node in a new trieable sequence,\n                                 * in which case we do some bookkeeping,\n                                 * otherwise we update the end pointer. */\n                                if ( !first ) {\n                                    first = cur;\n\t\t\t\t    if ( noper_trietype == NOTHING ) {\n#if !defined(DEBUGGING) && !defined(NOJUMPTRIE)\n\t\t\t\t\tregnode * const noper_next = regnext( noper );\n                                        U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n\t\t\t\t\tU8 noper_next_trietype = noper_next_type ? TRIE_TYPE( noper_next_type ) :0;\n#endif\n\n                                        if ( noper_next_trietype ) {\n\t\t\t\t\t    trietype = noper_next_trietype;\n                                        } else if (noper_next_type)  {\n                                            /* a NOTHING regop is 1 regop wide.\n                                             * We need at least two for a trie\n                                             * so we can't merge this in */\n                                            first = NULL;\n                                        }\n                                    } else {\n                                        trietype = noper_trietype;\n                                    }\n                                } else {\n                                    if ( trietype == NOTHING )\n                                        trietype = noper_trietype;\n                                    last = cur;\n                                }\n\t\t\t\tif (first)\n\t\t\t\t    count++;\n                            } /* end handle mergable triable node */\n                            else {\n                                /* handle unmergable node -\n                                 * noper may either be a triable node which can\n                                 * not be tried together with the current trie,\n                                 * or a non triable node */\n                                if ( last ) {\n                                    /* If last is set and trietype is not\n                                     * NOTHING then we have found at least two\n                                     * triable branch sequences in a row of a\n                                     * similar trietype so we can turn them\n                                     * into a trie. If/when we allow NOTHING to\n                                     * start a trie sequence this condition\n                                     * will be required, and it isn't expensive\n                                     * so we leave it in for now. */\n                                    if ( trietype && trietype != NOTHING )\n                                        make_trie( pRExC_state,\n                                                startbranch, first, cur, tail,\n                                                count, trietype, depth+1 );\n                                    last = NULL; /* note: we clear/update\n                                                    first, trietype etc below,\n                                                    so we dont do it here */\n                                }\n                                if ( noper_trietype\n#ifdef NOJUMPTRIE\n                                     && noper_next >= tail\n#endif\n                                ){\n                                    /* noper is triable, so we can start a new\n                                     * trie sequence */\n                                    count = 1;\n                                    first = cur;\n                                    trietype = noper_trietype;\n                                } else if (first) {\n                                    /* if we already saw a first but the\n                                     * current node is not triable then we have\n                                     * to reset the first information. */\n                                    count = 0;\n                                    first = NULL;\n                                    trietype = 0;\n                                }\n                            } /* end handle unmergable node */\n                        } /* loop over branches */\n                        DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                            Perl_re_indentf( aTHX_  \"- %s (%d) <SCAN FINISHED> \",\n                              depth+1, SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n                            Perl_re_printf( aTHX_  \"(First==%d, Last==%d, Cur==%d, tt==%s)\\n\",\n                               REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n                               PL_reg_name[trietype]\n                            );\n\n                        });\n                        if ( last && trietype ) {\n                            if ( trietype != NOTHING ) {\n                                /* the last branch of the sequence was part of\n                                 * a trie, so we have to construct it here\n                                 * outside of the loop */\n                                made= make_trie( pRExC_state, startbranch,\n                                                 first, scan, tail, count,\n                                                 trietype, depth+1 );\n#ifdef TRIE_STUDY_OPT\n                                if ( ((made == MADE_EXACT_TRIE &&\n                                     startbranch == first)\n                                     || ( first_non_open == first )) &&\n                                     depth==0 ) {\n                                    flags |= SCF_TRIE_RESTUDY;\n                                    if ( startbranch == first\n                                         && scan >= tail )\n                                    {\n                                        RExC_seen &=~REG_TOP_LEVEL_BRANCHES_SEEN;\n                                    }\n                                }\n#endif\n                            } else {\n                                /* at this point we know whatever we have is a\n                                 * NOTHING sequence/branch AND if 'startbranch'\n                                 * is 'first' then we can turn the whole thing\n                                 * into a NOTHING\n                                 */\n                                if ( startbranch == first ) {\n                                    regnode *opt;\n                                    /* the entire thing is a NOTHING sequence,\n                                     * something like this: (?:|) So we can\n                                     * turn it into a plain NOTHING op. */\n                                    DEBUG_TRIE_COMPILE_r({\n                                        regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                        Perl_re_indentf( aTHX_  \"- %s (%d) <NOTHING BRANCH SEQUENCE>\\n\",\n                                          depth+1,\n                                          SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n\n                                    });\n                                    OP(startbranch)= NOTHING;\n                                    NEXT_OFF(startbranch)= tail - startbranch;\n                                    for ( opt= startbranch + 1; opt < tail ; opt++ )\n                                        OP(opt)= OPTIMIZED;\n                                }\n                            }\n                        } /* end if ( last) */\n                    } /* TRIE_MAXBUF is non zero */\n\n                } /* do trie */\n\n\t    }\n\t    else if ( code == BRANCHJ ) {  /* single branch is optimized. */\n\t\tscan = NEXTOPER(NEXTOPER(scan));\n\t    } else\t\t\t/* single branch is optimized. */\n\t\tscan = NEXTOPER(scan);\n\t    continue;\n        } else if (OP(scan) == SUSPEND || OP(scan) == GOSUB) {\n            I32 paren = 0;\n            regnode *start = NULL;\n            regnode *end = NULL;\n            U32 my_recursed_depth= recursed_depth;\n\n            if (OP(scan) != SUSPEND) { /* GOSUB */\n                /* Do setup, note this code has side effects beyond\n                 * the rest of this block. Specifically setting\n                 * RExC_recurse[] must happen at least once during\n                 * study_chunk(). */\n                paren = ARG(scan);\n                RExC_recurse[ARG2L(scan)] = scan;\n                start = REGNODE_p(RExC_open_parens[paren]);\n                end   = REGNODE_p(RExC_close_parens[paren]);\n\n                /* NOTE we MUST always execute the above code, even\n                 * if we do nothing with a GOSUB */\n                if (\n                    ( flags & SCF_IN_DEFINE )\n                    ||\n                    (\n                        (is_inf_internal || is_inf || (data && data->flags & SF_IS_INF))\n                        &&\n                        ( (flags & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )\n                    )\n                ) {\n                    /* no need to do anything here if we are in a define. */\n                    /* or we are after some kind of infinite construct\n                     * so we can skip recursing into this item.\n                     * Since it is infinite we will not change the maxlen\n                     * or delta, and if we miss something that might raise\n                     * the minlen it will merely pessimise a little.\n                     *\n                     * Iow /(?(DEFINE)(?<foo>foo|food))a+(?&foo)/\n                     * might result in a minlen of 1 and not of 4,\n                     * but this doesn't make us mismatch, just try a bit\n                     * harder than we should.\n                     * */\n                    scan= regnext(scan);\n                    continue;\n                }\n\n                if (\n                    !recursed_depth\n                    ||\n                    !PAREN_TEST(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes), paren)\n                ) {\n                    /* it is quite possible that there are more efficient ways\n                     * to do this. We maintain a bitmap per level of recursion\n                     * of which patterns we have entered so we can detect if a\n                     * pattern creates a possible infinite loop. When we\n                     * recurse down a level we copy the previous levels bitmap\n                     * down. When we are at recursion level 0 we zero the top\n                     * level bitmap. It would be nice to implement a different\n                     * more efficient way of doing this. In particular the top\n                     * level bitmap may be unnecessary.\n                     */\n                    if (!recursed_depth) {\n                        Zero(RExC_study_chunk_recursed, RExC_study_chunk_recursed_bytes, U8);\n                    } else {\n                        Copy(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes),\n                             RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes),\n                             RExC_study_chunk_recursed_bytes, U8);\n                    }\n                    /* we havent recursed into this paren yet, so recurse into it */\n                    DEBUG_STUDYDATA(\"gosub-set\", data, depth, is_inf);\n                    PAREN_SET(RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes), paren);\n                    my_recursed_depth= recursed_depth + 1;\n                } else {\n                    DEBUG_STUDYDATA(\"gosub-inf\", data, depth, is_inf);\n                    /* some form of infinite recursion, assume infinite length\n                     * */\n                    if (flags & SCF_DO_SUBSTR) {\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n                        data->cur_is_floating = 1;\n                    }\n                    is_inf = is_inf_internal = 1;\n                    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n                        ssc_anything(data->start_class);\n                    flags &= ~SCF_DO_STCLASS;\n\n                    start= NULL; /* reset start so we dont recurse later on. */\n\t        }\n            } else {\n\t        paren = stopparen;\n                start = scan + 2;\n\t        end = regnext(scan);\n\t    }\n            if (start) {\n                scan_frame *newframe;\n                assert(end);\n                if (!RExC_frame_last) {\n                    Newxz(newframe, 1, scan_frame);\n                    SAVEDESTRUCTOR_X(S_unwind_scan_frames, newframe);\n                    RExC_frame_head= newframe;\n                    RExC_frame_count++;\n                } else if (!RExC_frame_last->next_frame) {\n                    Newxz(newframe, 1, scan_frame);\n                    RExC_frame_last->next_frame= newframe;\n                    newframe->prev_frame= RExC_frame_last;\n                    RExC_frame_count++;\n                } else {\n                    newframe= RExC_frame_last->next_frame;\n                }\n                RExC_frame_last= newframe;\n\n                newframe->next_regnode = regnext(scan);\n                newframe->last_regnode = last;\n                newframe->stopparen = stopparen;\n                newframe->prev_recursed_depth = recursed_depth;\n                newframe->this_prev_frame= frame;\n\n                DEBUG_STUDYDATA(\"frame-new\", data, depth, is_inf);\n                DEBUG_PEEP(\"fnew\", scan, depth, flags);\n\n\t        frame = newframe;\n\t        scan =  start;\n\t        stopparen = paren;\n\t        last = end;\n                depth = depth + 1;\n                recursed_depth= my_recursed_depth;\n\n\t        continue;\n\t    }\n\t}\n\telse if (   OP(scan) == EXACT\n                 || OP(scan) == EXACT_ONLY8\n                 || OP(scan) == EXACTL)\n        {\n\t    SSize_t l = STR_LEN(scan);\n\t    UV uc;\n            assert(l);\n\t    if (UTF) {\n\t\tconst U8 * const s = (U8*)STRING(scan);\n\t\tuc = utf8_to_uvchr_buf(s, s + l, NULL);\n\t\tl = utf8_length(s, s + l);\n\t    } else {\n\t\tuc = *((U8*)STRING(scan));\n\t    }\n\t    min += l;\n\t    if (flags & SCF_DO_SUBSTR) { /* Update longest substr. */\n\t\t/* The code below prefers earlier match for fixed\n\t\t   offset, later match for variable offset.  */\n\t\tif (data->last_end == -1) { /* Update the start info. */\n\t\t    data->last_start_min = data->pos_min;\n \t\t    data->last_start_max = is_inf\n \t\t\t? SSize_t_MAX : data->pos_min + data->pos_delta;\n\t\t}\n\t\tsv_catpvn(data->last_found, STRING(scan), STR_LEN(scan));\n\t\tif (UTF)\n\t\t    SvUTF8_on(data->last_found);\n\t\t{\n\t\t    SV * const sv = data->last_found;\n\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\t\t    if (mg && mg->mg_len >= 0)\n\t\t\tmg->mg_len += utf8_length((U8*)STRING(scan),\n                                              (U8*)STRING(scan)+STR_LEN(scan));\n\t\t}\n\t\tdata->last_end = data->pos_min + l;\n\t\tdata->pos_min += l; /* As in the first entry. */\n\t\tdata->flags &= ~SF_BEFORE_EOL;\n\t    }\n\n            /* ANDing the code point leaves at most it, and not in locale, and\n             * can't match null string */\n\t    if (flags & SCF_DO_STCLASS_AND) {\n                ssc_cp_and(data->start_class, uc);\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                ssc_clear_locale(data->start_class);\n\t    }\n\t    else if (flags & SCF_DO_STCLASS_OR) {\n                ssc_add_cp(data->start_class, uc);\n\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\t    }\n\t    flags &= ~SCF_DO_STCLASS;\n\t}\n        else if (PL_regkind[OP(scan)] == EXACT) {\n            /* But OP != EXACT!, so is EXACTFish */\n\t    SSize_t l = STR_LEN(scan);\n            const U8 * s = (U8*)STRING(scan);\n\n\t    /* Search for fixed substrings supports EXACT only. */\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tassert(data);\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t    }\n\t    if (UTF) {\n\t\tl = utf8_length(s, s + l);\n\t    }\n\t    if (unfolded_multi_char) {\n                RExC_seen |= REG_UNFOLDED_MULTI_SEEN;\n\t    }\n\t    min += l - min_subtract;\n            assert (min >= 0);\n            delta += min_subtract;\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tdata->pos_min += l - min_subtract;\n\t\tif (data->pos_min < 0) {\n                    data->pos_min = 0;\n                }\n                data->pos_delta += min_subtract;\n\t\tif (min_subtract) {\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t    }\n\n            if (flags & SCF_DO_STCLASS) {\n                SV* EXACTF_invlist = _make_exactf_invlist(pRExC_state, scan);\n\n                assert(EXACTF_invlist);\n                if (flags & SCF_DO_STCLASS_AND) {\n                    if (OP(scan) != EXACTFL)\n                        ssc_clear_locale(data->start_class);\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                    ANYOF_POSIXL_ZERO(data->start_class);\n                    ssc_intersection(data->start_class, EXACTF_invlist, FALSE);\n                }\n                else {  /* SCF_DO_STCLASS_OR */\n                    ssc_union(data->start_class, EXACTF_invlist, FALSE);\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                    /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                flags &= ~SCF_DO_STCLASS;\n                SvREFCNT_dec(EXACTF_invlist);\n            }\n\t}\n\telse if (REGNODE_VARIES(OP(scan))) {\n\t    SSize_t mincount, maxcount, minnext, deltanext, pos_before = 0;\n\t    I32 fl = 0, f = flags;\n\t    regnode * const oscan = scan;\n\t    regnode_ssc this_class;\n\t    regnode_ssc *oclass = NULL;\n\t    I32 next_is_eval = 0;\n\n\t    switch (PL_regkind[OP(scan)]) {\n\t    case WHILEM:\t\t/* End of (?:...)* . */\n\t\tscan = NEXTOPER(scan);\n\t\tgoto finish;\n\t    case PLUS:\n\t\tif (flags & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) {\n\t\t    next = NEXTOPER(scan);\n\t\t    if (   OP(next) == EXACT\n                        || OP(next) == EXACT_ONLY8\n                        || OP(next) == EXACTL\n                        || (flags & SCF_DO_STCLASS))\n                    {\n\t\t\tmincount = 1;\n\t\t\tmaxcount = REG_INFTY;\n\t\t\tnext = regnext(scan);\n\t\t\tscan = NEXTOPER(scan);\n\t\t\tgoto do_curly;\n\t\t    }\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR)\n\t\t    data->pos_min++;\n\t\tmin++;\n\t\t/* FALLTHROUGH */\n\t    case STAR:\n                next = NEXTOPER(scan);\n\n                /* This temporary node can now be turned into EXACTFU, and\n                 * must, as regexec.c doesn't handle it */\n                if (OP(next) == EXACTFU_S_EDGE) {\n                    OP(next) = EXACTFU;\n                }\n\n                if (     STR_LEN(next) == 1\n                    &&   isALPHA_A(* STRING(next))\n                    && (         OP(next) == EXACTFAA\n                        || (     OP(next) == EXACTFU\n                            && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(* STRING(next)))))\n                {\n                    /* These differ in just one bit */\n                    U8 mask = ~ ('A' ^ 'a');\n\n                    assert(isALPHA_A(* STRING(next)));\n\n                    /* Then replace it by an ANYOFM node, with\n                    * the mask set to the complement of the\n                    * bit that differs between upper and lower\n                    * case, and the lowest code point of the\n                    * pair (which the '&' forces) */\n                    OP(next) = ANYOFM;\n                    ARG_SET(next, *STRING(next) & mask);\n                    FLAGS(next) = mask;\n                }\n\n\t\tif (flags & SCF_DO_STCLASS) {\n\t\t    mincount = 0;\n\t\t    maxcount = REG_INFTY;\n\t\t    next = regnext(scan);\n\t\t    scan = NEXTOPER(scan);\n\t\t    goto do_curly;\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n                is_inf = is_inf_internal = 1;\n                scan = regnext(scan);\n\t\tgoto optimize_curly_tail;\n\t    case CURLY:\n\t        if (stopparen>0 && (OP(scan)==CURLYN || OP(scan)==CURLYM)\n\t            && (scan->flags == stopparen))\n\t\t{\n\t\t    mincount = 1;\n\t\t    maxcount = 1;\n\t\t} else {\n\t\t    mincount = ARG1(scan);\n\t\t    maxcount = ARG2(scan);\n\t\t}\n\t\tnext = regnext(scan);\n\t\tif (OP(scan) == CURLYX) {\n\t\t    I32 lp = (data ? *(data->last_closep) : 0);\n\t\t    scan->flags = ((lp <= (I32)U8_MAX) ? (U8)lp : U8_MAX);\n\t\t}\n\t\tscan = NEXTOPER(scan) + EXTRA_STEP_2ARGS;\n\t\tnext_is_eval = (OP(scan) == EVAL);\n\t      do_curly:\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    if (mincount == 0)\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t    pos_before = data->pos_min;\n\t\t}\n\t\tif (data) {\n\t\t    fl = data->flags;\n\t\t    data->flags &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL);\n\t\t    if (is_inf)\n\t\t\tdata->flags |= SF_IS_INF;\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS) {\n\t\t    ssc_init(pRExC_state, &this_class);\n\t\t    oclass = data->start_class;\n\t\t    data->start_class = &this_class;\n\t\t    f |= SCF_DO_STCLASS_AND;\n\t\t    f &= ~SCF_DO_STCLASS_OR;\n\t\t}\n\t        /* Exclude from super-linear cache processing any {n,m}\n\t\t   regops for which the combination of input pos and regex\n\t\t   pos is not enough information to determine if a match\n\t\t   will be possible.\n\n\t\t   For example, in the regex /foo(bar\\s*){4,8}baz/ with the\n\t\t   regex pos at the \\s*, the prospects for a match depend not\n\t\t   only on the input position but also on how many (bar\\s*)\n\t\t   repeats into the {4,8} we are. */\n               if ((mincount > 1) || (maxcount > 1 && maxcount != REG_INFTY))\n\t\t    f &= ~SCF_WHILEM_VISITED_POS;\n\n\t\t/* This will finish on WHILEM, setting scan, or on NULL: */\n                /* recurse study_chunk() on loop bodies */\n\t\tminnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext,\n                                  last, data, stopparen, recursed_depth, NULL,\n                                  (mincount == 0\n                                   ? (f & ~SCF_DO_SUBSTR)\n                                   : f)\n                                  ,depth+1);\n\n\t\tif (flags & SCF_DO_STCLASS)\n\t\t    data->start_class = oclass;\n\t\tif (mincount == 0 || minnext == 0) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND) {\n\t\t\t/* Switch to OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\t\t\tStructCopy(&this_class, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n                        ANYOF_FLAGS(data->start_class)\n                                                |= SSC_MATCHES_EMPTY_STRING;\n\t\t    }\n\t\t} else {\t\t/* Non-zero len */\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t    flags &= ~SCF_DO_STCLASS;\n\t\t}\n\t\tif (!scan) \t\t/* It was not CURLYX, but CURLY. */\n\t\t    scan = next;\n\t\tif (((flags & (SCF_TRIE_DOING_RESTUDY|SCF_DO_SUBSTR))==SCF_DO_SUBSTR)\n\t\t    /* ? quantifier ok, except for (?{ ... }) */\n\t\t    && (next_is_eval || !(mincount == 0 && maxcount == 1))\n\t\t    && (minnext == 0) && (deltanext == 0)\n\t\t    && data && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))\n                    && maxcount <= REG_INFTY/3) /* Complement check for big\n                                                   count */\n\t\t{\n\t\t    _WARN_HELPER(RExC_precomp_end, packWARN(WARN_REGEXP),\n                        Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),\n                            \"Quantifier unexpected on zero-length expression \"\n                            \"in regex m/%\" UTF8f \"/\",\n\t\t\t     UTF8fARG(UTF, RExC_precomp_end - RExC_precomp,\n\t\t\t\t  RExC_precomp)));\n                }\n\n                if ( ( minnext > 0 && mincount >= SSize_t_MAX / minnext )\n                    || min >= SSize_t_MAX - minnext * mincount )\n                {\n                    FAIL(\"Regexp out of space\");\n                }\n\n\t\tmin += minnext * mincount;\n\t\tis_inf_internal |= deltanext == SSize_t_MAX\n                         || (maxcount == REG_INFTY && minnext + deltanext > 0);\n\t\tis_inf |= is_inf_internal;\n                if (is_inf) {\n\t\t    delta = SSize_t_MAX;\n                } else {\n\t\t    delta += (minnext + deltanext) * maxcount\n                             - minnext * mincount;\n                }\n\t\t/* Try powerful optimization CURLYX => CURLYN. */\n\t\tif (  OP(oscan) == CURLYX && data\n\t\t      && data->flags & SF_IN_PAR\n\t\t      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext && minnext == 1 ) {\n\t\t    /* Try to optimize to CURLYN.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;\n\t\t    regnode * const nxt1 = nxt;\n#ifdef DEBUGGING\n\t\t    regnode *nxt2;\n#endif\n\n\t\t    /* Skip open. */\n\t\t    nxt = regnext(nxt);\n\t\t    if (!REGNODE_SIMPLE(OP(nxt))\n\t\t\t&& !(PL_regkind[OP(nxt)] == EXACT\n\t\t\t     && STR_LEN(nxt) == 1))\n\t\t\tgoto nogo;\n#ifdef DEBUGGING\n\t\t    nxt2 = nxt;\n#endif\n\t\t    nxt = regnext(nxt);\n\t\t    if (OP(nxt) != CLOSE)\n\t\t\tgoto nogo;\n\t\t    if (RExC_open_parens) {\n\n                        /*open->CURLYM*/\n                        RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n\n                        /*close->while*/\n                        RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt) + 2;\n\t\t    }\n\t\t    /* Now we know that nxt2 is the only contents: */\n\t\t    oscan->flags = (U8)ARG(nxt);\n\t\t    OP(oscan) = CURLYN;\n\t\t    OP(nxt1) = NOTHING;\t/* was OPEN. */\n\n#ifdef DEBUGGING\n\t\t    OP(nxt1 + 1) = OPTIMIZED; /* was count. */\n\t\t    NEXT_OFF(nxt1+ 1) = 0; /* just for consistency. */\n\t\t    NEXT_OFF(nxt2) = 0;\t/* just for consistency with CURLY. */\n\t\t    OP(nxt) = OPTIMIZED;\t/* was CLOSE. */\n\t\t    OP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t    NEXT_OFF(nxt+ 1) = 0; /* just for consistency. */\n#endif\n\t\t}\n\t      nogo:\n\n\t\t/* Try optimization CURLYX => CURLYM. */\n\t\tif (  OP(oscan) == CURLYX && data\n\t\t      && !(data->flags & SF_HAS_PAR)\n\t\t      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext\t/* atom is fixed width */\n\t\t      && minnext != 0\t/* CURLYM can't handle zero width */\n\n                         /* Nor characters whose fold at run-time may be\n                          * multi-character */\n                      && ! (RExC_seen & REG_UNFOLDED_MULTI_SEEN)\n\t\t) {\n\t\t    /* XXXX How to optimize if data == 0? */\n\t\t    /* Optimize to a simpler form.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN */\n\t\t    regnode *nxt2;\n\n\t\t    OP(oscan) = CURLYM;\n\t\t    while ( (nxt2 = regnext(nxt)) /* skip over embedded stuff*/\n\t\t\t    && (OP(nxt2) != WHILEM))\n\t\t\tnxt = nxt2;\n\t\t    OP(nxt2)  = SUCCEED; /* Whas WHILEM */\n\t\t    /* Need to optimize away parenths. */\n\t\t    if ((data->flags & SF_IN_PAR) && OP(nxt) == CLOSE) {\n\t\t\t/* Set the parenth number.  */\n\t\t\tregnode *nxt1 = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN*/\n\n\t\t\toscan->flags = (U8)ARG(nxt);\n\t\t\tif (RExC_open_parens) {\n                             /*open->CURLYM*/\n                            RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n\n                            /*close->NOTHING*/\n                            RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt2)\n                                                         + 1;\n\t\t\t}\n\t\t\tOP(nxt1) = OPTIMIZED;\t/* was OPEN. */\n\t\t\tOP(nxt) = OPTIMIZED;\t/* was CLOSE. */\n\n#ifdef DEBUGGING\n\t\t\tOP(nxt1 + 1) = OPTIMIZED; /* was count. */\n\t\t\tOP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t\tNEXT_OFF(nxt1 + 1) = 0; /* just for consistency. */\n\t\t\tNEXT_OFF(nxt + 1) = 0; /* just for consistency. */\n#endif\n#if 0\n\t\t\twhile ( nxt1 && (OP(nxt1) != WHILEM)) {\n\t\t\t    regnode *nnxt = regnext(nxt1);\n\t\t\t    if (nnxt == nxt) {\n\t\t\t\tif (reg_off_by_arg[OP(nxt1)])\n\t\t\t\t    ARG_SET(nxt1, nxt2 - nxt1);\n\t\t\t\telse if (nxt2 - nxt1 < U16_MAX)\n\t\t\t\t    NEXT_OFF(nxt1) = nxt2 - nxt1;\n\t\t\t\telse\n\t\t\t\t    OP(nxt) = NOTHING;\t/* Cannot beautify */\n\t\t\t    }\n\t\t\t    nxt1 = nnxt;\n\t\t\t}\n#endif\n\t\t\t/* Optimize again: */\n                        /* recurse study_chunk() on optimised CURLYX => CURLYM */\n\t\t\tstudy_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,\n                                    NULL, stopparen, recursed_depth, NULL, 0,\n                                    depth+1);\n\t\t    }\n\t\t    else\n\t\t\toscan->flags = 0;\n\t\t}\n\t\telse if ((OP(oscan) == CURLYX)\n\t\t\t && (flags & SCF_WHILEM_VISITED_POS)\n\t\t\t /* See the comment on a similar expression above.\n\t\t\t    However, this time it's not a subexpression\n\t\t\t    we care about, but the expression itself. */\n\t\t\t && (maxcount == REG_INFTY)\n\t\t\t && data) {\n\t\t    /* This stays as CURLYX, we can put the count/of pair. */\n\t\t    /* Find WHILEM (as in regexec.c) */\n\t\t    regnode *nxt = oscan + NEXT_OFF(oscan);\n\n\t\t    if (OP(PREVOPER(nxt)) == NOTHING) /* LONGJMP */\n\t\t\tnxt += ARG(nxt);\n                    nxt = PREVOPER(nxt);\n                    if (nxt->flags & 0xf) {\n                        /* we've already set whilem count on this node */\n                    } else if (++data->whilem_c < 16) {\n                        assert(data->whilem_c <= RExC_whilem_seen);\n                        nxt->flags = (U8)(data->whilem_c\n                            | (RExC_whilem_seen << 4)); /* On WHILEM */\n                    }\n\t\t}\n\t\tif (data && fl & (SF_HAS_PAR|SF_IN_PAR))\n\t\t    pars++;\n\t\tif (flags & SCF_DO_SUBSTR) {\n\t\t    SV *last_str = NULL;\n                    STRLEN last_chrs = 0;\n\t\t    int counted = mincount != 0;\n\n                    if (data->last_end > 0 && mincount != 0) { /* Ends with a\n                                                                  string. */\n\t\t\tSSize_t b = pos_before >= data->last_start_min\n\t\t\t    ? pos_before : data->last_start_min;\n\t\t\tSTRLEN l;\n\t\t\tconst char * const s = SvPV_const(data->last_found, l);\n\t\t\tSSize_t old = b - data->last_start_min;\n                        assert(old >= 0);\n\n\t\t\tif (UTF)\n\t\t\t    old = utf8_hop_forward((U8*)s, old,\n                                               (U8 *) SvEND(data->last_found))\n                                - (U8*)s;\n\t\t\tl -= old;\n\t\t\t/* Get the added string: */\n\t\t\tlast_str = newSVpvn_utf8(s  + old, l, UTF);\n                        last_chrs = UTF ? utf8_length((U8*)(s + old),\n                                            (U8*)(s + old + l)) : l;\n\t\t\tif (deltanext == 0 && pos_before == b) {\n\t\t\t    /* What was added is a constant string */\n\t\t\t    if (mincount > 1) {\n\n\t\t\t\tSvGROW(last_str, (mincount * l) + 1);\n\t\t\t\trepeatcpy(SvPVX(last_str) + l,\n\t\t\t\t\t  SvPVX_const(last_str), l,\n                                          mincount - 1);\n\t\t\t\tSvCUR_set(last_str, SvCUR(last_str) * mincount);\n\t\t\t\t/* Add additional parts. */\n\t\t\t\tSvCUR_set(data->last_found,\n\t\t\t\t\t  SvCUR(data->last_found) - l);\n\t\t\t\tsv_catsv(data->last_found, last_str);\n\t\t\t\t{\n\t\t\t\t    SV * sv = data->last_found;\n\t\t\t\t    MAGIC *mg =\n\t\t\t\t\tSvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\t\t\t\t    if (mg && mg->mg_len >= 0)\n\t\t\t\t\tmg->mg_len += last_chrs * (mincount-1);\n\t\t\t\t}\n                                last_chrs *= mincount;\n\t\t\t\tdata->last_end += l * (mincount - 1);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    /* start offset must point into the last copy */\n\t\t\t    data->last_start_min += minnext * (mincount - 1);\n\t\t\t    data->last_start_max =\n                              is_inf\n                               ? SSize_t_MAX\n\t\t\t       : data->last_start_max +\n                                 (maxcount - 1) * (minnext + data->pos_delta);\n\t\t\t}\n\t\t    }\n\t\t    /* It is counted once already... */\n\t\t    data->pos_min += minnext * (mincount - counted);\n#if 0\nPerl_re_printf( aTHX_  \"counted=%\" UVuf \" deltanext=%\" UVuf\n                              \" SSize_t_MAX=%\" UVuf \" minnext=%\" UVuf\n                              \" maxcount=%\" UVuf \" mincount=%\" UVuf \"\\n\",\n    (UV)counted, (UV)deltanext, (UV)SSize_t_MAX, (UV)minnext, (UV)maxcount,\n    (UV)mincount);\nif (deltanext != SSize_t_MAX)\nPerl_re_printf( aTHX_  \"LHS=%\" UVuf \" RHS=%\" UVuf \"\\n\",\n    (UV)(-counted * deltanext + (minnext + deltanext) * maxcount\n          - minnext * mincount), (UV)(SSize_t_MAX - data->pos_delta));\n#endif\n\t\t    if (deltanext == SSize_t_MAX\n                        || -counted * deltanext + (minnext + deltanext) * maxcount - minnext * mincount >= SSize_t_MAX - data->pos_delta)\n\t\t        data->pos_delta = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += - counted * deltanext +\n\t\t\t(minnext + deltanext) * maxcount - minnext * mincount;\n\t\t    if (mincount != maxcount) {\n\t\t\t /* Cannot extend fixed substrings found inside\n\t\t\t    the group.  */\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t\tif (mincount && last_str) {\n\t\t\t    SV * const sv = data->last_found;\n\t\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\n\t\t\t    if (mg)\n\t\t\t\tmg->mg_len = -1;\n\t\t\t    sv_setsv(sv, last_str);\n\t\t\t    data->last_end = data->pos_min;\n\t\t\t    data->last_start_min = data->pos_min - last_chrs;\n\t\t\t    data->last_start_max = is_inf\n\t\t\t\t? SSize_t_MAX\n\t\t\t\t: data->pos_min + data->pos_delta - last_chrs;\n\t\t\t}\n\t\t\tdata->cur_is_floating = 1; /* float */\n\t\t    }\n\t\t    SvREFCNT_dec(last_str);\n\t\t}\n\t\tif (data && (fl & SF_HAS_EVAL))\n\t\t    data->flags |= SF_HAS_EVAL;\n\t      optimize_curly_tail:\n\t\trck_elide_nothing(oscan);\n\t\tcontinue;\n\n\t    default:\n#ifdef DEBUGGING\n                Perl_croak(aTHX_ \"panic: unexpected varying REx opcode %d\",\n                                                                    OP(scan));\n#endif\n            case REF:\n            case CLUMP:\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    /* Cannot expect anything... */\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) {\n                    if (OP(scan) == CLUMP) {\n                        /* Actually is any start char, but very few code points\n                         * aren't start characters */\n                        ssc_match_all_cp(data->start_class);\n                    }\n                    else {\n                        ssc_anything(data->start_class);\n                    }\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n\t\tbreak;\n\t    }\n\t}\n\telse if (OP(scan) == LNBREAK) {\n\t    if (flags & SCF_DO_STCLASS) {\n    \t        if (flags & SCF_DO_STCLASS_AND) {\n                    ssc_intersection(data->start_class,\n                                    PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);\n                    ssc_clear_locale(data->start_class);\n                    ANYOF_FLAGS(data->start_class)\n                                                &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                else if (flags & SCF_DO_STCLASS_OR) {\n                    ssc_union(data->start_class,\n                              PL_XPosix_ptrs[_CC_VERTSPACE],\n                              FALSE);\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                    /* See commit msg for\n                     * 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class)\n                                                &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n            }\n\t    min++;\n            if (delta != SSize_t_MAX)\n                delta++;    /* Because of the 2 char string cr-lf */\n            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything... */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t        data->pos_min += 1;\n                if (data->pos_delta != SSize_t_MAX) {\n                    data->pos_delta += 1;\n                }\n\t\tdata->cur_is_floating = 1; /* float */\n    \t    }\n\t}\n\telse if (REGNODE_SIMPLE(OP(scan))) {\n\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tdata->pos_min++;\n\t    }\n\t    min++;\n\t    if (flags & SCF_DO_STCLASS) {\n                bool invert = 0;\n                SV* my_invlist = NULL;\n                U8 namedclass;\n\n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\n\t\t/* Some of the logic below assumes that switching\n\t\t   locale on will only add false positives. */\n\t\tswitch (OP(scan)) {\n\n\t\tdefault:\n#ifdef DEBUGGING\n                   Perl_croak(aTHX_ \"panic: unexpected simple REx opcode %d\",\n                                                                     OP(scan));\n#endif\n\t\tcase SANY:\n\t\t    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n\t\t\tssc_match_all_cp(data->start_class);\n\t\t    break;\n\n\t\tcase REG_ANY:\n                    {\n                        SV* REG_ANY_invlist = _new_invlist(2);\n                        REG_ANY_invlist = add_cp_to_invlist(REG_ANY_invlist,\n                                                            '\\n');\n                        if (flags & SCF_DO_STCLASS_OR) {\n                            ssc_union(data->start_class,\n                                      REG_ANY_invlist,\n                                      TRUE /* TRUE => invert, hence all but \\n\n                                            */\n                                      );\n                        }\n                        else if (flags & SCF_DO_STCLASS_AND) {\n                            ssc_intersection(data->start_class,\n                                             REG_ANY_invlist,\n                                             TRUE  /* TRUE => invert */\n                                             );\n                            ssc_clear_locale(data->start_class);\n                        }\n                        SvREFCNT_dec_NN(REG_ANY_invlist);\n\t\t    }\n\t\t    break;\n\n                case ANYOFD:\n                case ANYOFL:\n                case ANYOFPOSIXL:\n                case ANYOFH:\n                case ANYOF:\n\t\t    if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state, data->start_class,\n                                (regnode_charclass *) scan);\n\t\t    else\n\t\t\tssc_or(pRExC_state, data->start_class,\n                                                          (regnode_charclass *) scan);\n\t\t    break;\n\n                case NANYOFM:\n                case ANYOFM:\n                  {\n                    SV* cp_list = get_ANYOFM_contents(scan);\n\n                    if (flags & SCF_DO_STCLASS_OR) {\n                        ssc_union(data->start_class, cp_list, invert);\n                    }\n                    else if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class, cp_list, invert);\n                    }\n\n                    SvREFCNT_dec_NN(cp_list);\n                    break;\n                  }\n\n\t\tcase NPOSIXL:\n                    invert = 1;\n                    /* FALLTHROUGH */\n\n\t\tcase POSIXL:\n                    namedclass = classnum_to_namedclass(FLAGS(scan)) + invert;\n                    if (flags & SCF_DO_STCLASS_AND) {\n                        bool was_there = cBOOL(\n                                          ANYOF_POSIXL_TEST(data->start_class,\n                                                                 namedclass));\n                        ANYOF_POSIXL_ZERO(data->start_class);\n                        if (was_there) {    /* Do an AND */\n                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n                        }\n                        /* No individual code points can now match */\n                        data->start_class->invlist\n                                                = sv_2mortal(_new_invlist(0));\n                    }\n                    else {\n                        int complement = namedclass + ((invert) ? -1 : 1);\n\n                        assert(flags & SCF_DO_STCLASS_OR);\n\n                        /* If the complement of this class was already there,\n                         * the result is that they match all code points,\n                         * (\\d + \\D == everything).  Remove the classes from\n                         * future consideration.  Locale is not relevant in\n                         * this case */\n                        if (ANYOF_POSIXL_TEST(data->start_class, complement)) {\n                            ssc_match_all_cp(data->start_class);\n                            ANYOF_POSIXL_CLEAR(data->start_class, namedclass);\n                            ANYOF_POSIXL_CLEAR(data->start_class, complement);\n                        }\n                        else {  /* The usual case; just add this class to the\n                                   existing set */\n                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n                        }\n                    }\n                    break;\n\n                case NPOSIXA:   /* For these, we always know the exact set of\n                                   what's matched */\n                    invert = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXA:\n                    my_invlist = invlist_clone(PL_Posix_ptrs[FLAGS(scan)], NULL);\n                    goto join_posix_and_ascii;\n\n\t\tcase NPOSIXD:\n\t\tcase NPOSIXU:\n                    invert = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXD:\n\t\tcase POSIXU:\n                    my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(scan)], NULL);\n\n                    /* NPOSIXD matches all upper Latin1 code points unless the\n                     * target string being matched is UTF-8, which is\n                     * unknowable until match time.  Since we are going to\n                     * invert, we want to get rid of all of them so that the\n                     * inversion will match all */\n                    if (OP(scan) == NPOSIXD) {\n                        _invlist_subtract(my_invlist, PL_UpperLatin1,\n                                          &my_invlist);\n                    }\n\n                  join_posix_and_ascii:\n\n                    if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class, my_invlist, invert);\n                        ssc_clear_locale(data->start_class);\n                    }\n                    else {\n                        assert(flags & SCF_DO_STCLASS_OR);\n                        ssc_union(data->start_class, my_invlist, invert);\n                    }\n                    SvREFCNT_dec(my_invlist);\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS_OR)\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t    }\n\t}\n\telse if (PL_regkind[OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {\n\t    data->flags |= (OP(scan) == MEOL\n\t\t\t    ? SF_BEFORE_MEOL\n\t\t\t    : SF_BEFORE_SEOL);\n            scan_commit(pRExC_state, data, minlenp, is_inf);\n\n\t}\n\telse if (  PL_regkind[OP(scan)] == BRANCHJ\n\t\t /* Lookbehind, or need to calculate parens/evals/stclass: */\n\t\t   && (scan->flags || data || (flags & SCF_DO_STCLASS))\n\t\t   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM))\n        {\n            if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n                || OP(scan) == UNLESSM )\n            {\n                /* Negative Lookahead/lookbehind\n                   In this case we can't do fixed string optimisation.\n                */\n\n                SSize_t deltanext, minnext, fake = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n                int f = 0;\n\n                StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                if (data) {\n                    data_fake.whilem_c = data->whilem_c;\n                    data_fake.last_closep = data->last_closep;\n\t\t}\n                else\n                    data_fake.last_closep = &fake;\n\t\tdata_fake.pos_delta = delta;\n                if ( flags & SCF_DO_STCLASS && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state, &intrnl);\n                    data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n\t\t}\n                if (flags & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* recurse study_chunk() for lookahead body */\n                minnext = study_chunk(pRExC_state, &nscan, minlenp, &deltanext,\n                                      last, &data_fake, stopparen,\n                                      recursed_depth, NULL, f, depth+1);\n                if (scan->flags) {\n                    if (   deltanext < 0\n                        || deltanext > (I32) U8_MAX\n                        || minnext > (I32)U8_MAX\n                        || minnext + deltanext > (I32)U8_MAX)\n                    {\n\t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                              (UV)U8_MAX);\n                    }\n\n                    /* The 'next_off' field has been repurposed to count the\n                     * additional starting positions to try beyond the initial\n                     * one.  (This leaves it at 0 for non-variable length\n                     * matches to avoid breakage for those not using this\n                     * extension) */\n                    if (deltanext) {\n                        scan->next_off = deltanext;\n                        ckWARNexperimental(RExC_parse,\n                            WARN_EXPERIMENTAL__VLB,\n                            \"Variable length lookbehind is experimental\");\n                    }\n                    scan->flags = (U8)minnext + deltanext;\n                }\n                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c = data_fake.whilem_c;\n                }\n                if (f & SCF_DO_STCLASS_AND) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\t/* OR before, AND after: ideally we would recurse with\n\t\t\t * data_fake to get the AND applied by study of the\n\t\t\t * remainder of the pattern, and then derecurse;\n\t\t\t * *** HACK *** for now just treat as \"no information\".\n\t\t\t * See [perl #56690].\n\t\t\t */\n\t\t\tssc_init(pRExC_state, data->start_class);\n\t\t    }  else {\n                        /* AND before and after: combine and continue.  These\n                         * assertions are zero-length, so can match an EMPTY\n                         * string */\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                        ANYOF_FLAGS(data->start_class)\n                                                   |= SSC_MATCHES_EMPTY_STRING;\n\t\t    }\n                }\n\t    }\n#if PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n            else {\n                /* Positive Lookahead/lookbehind\n                   In this case we can do fixed string optimisation,\n                   but we must be careful about it. Note in the case of\n                   lookbehind the positions will be offset by the minimum\n                   length of the pattern, something we won't know about\n                   until after the recurse.\n                */\n                SSize_t deltanext, fake = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n                int f = 0;\n                /* We use SAVEFREEPV so that when the full compile\n                    is finished perl will clean up the allocated\n                    minlens when it's all done. This way we don't\n                    have to worry about freeing them when we know\n                    they wont be used, which would be a pain.\n                 */\n                SSize_t *minnextp;\n                Newx( minnextp, 1, SSize_t );\n                SAVEFREEPV(minnextp);\n\n                if (data) {\n                    StructCopy(data, &data_fake, scan_data_t);\n                    if ((flags & SCF_DO_SUBSTR) && data->last_found) {\n                        f |= SCF_DO_SUBSTR;\n                        if (scan->flags)\n                            scan_commit(pRExC_state, &data_fake, minlenp, is_inf);\n                        data_fake.last_found=newSVsv(data->last_found);\n                    }\n                }\n                else\n                    data_fake.last_closep = &fake;\n                data_fake.flags = 0;\n                data_fake.substrs[0].flags = 0;\n                data_fake.substrs[1].flags = 0;\n\t\tdata_fake.pos_delta = delta;\n                if (is_inf)\n\t            data_fake.flags |= SF_IS_INF;\n                if ( flags & SCF_DO_STCLASS && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state, &intrnl);\n                    data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n                }\n                if (flags & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* positive lookahead study_chunk() recursion */\n                *minnextp = study_chunk(pRExC_state, &nscan, minnextp,\n                                        &deltanext, last, &data_fake,\n                                        stopparen, recursed_depth, NULL,\n                                        f, depth+1);\n                if (scan->flags) {\n                    assert(0);  /* This code has never been tested since this\n                                   is normally not compiled */\n                    if (   deltanext < 0\n                        || deltanext > (I32) U8_MAX\n                        || *minnextp > (I32)U8_MAX\n                        || *minnextp + deltanext > (I32)U8_MAX)\n                    {\n\t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                              (UV)U8_MAX);\n                    }\n\n                    if (deltanext) {\n                        scan->next_off = deltanext;\n                    }\n                    scan->flags = (U8)*minnextp + deltanext;\n                }\n\n                *minnextp += min;\n\n                if (f & SCF_DO_STCLASS_AND) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                    ANYOF_FLAGS(data->start_class) |= SSC_MATCHES_EMPTY_STRING;\n                }\n                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c = data_fake.whilem_c;\n                    if ((flags & SCF_DO_SUBSTR) && data_fake.last_found) {\n                        int i;\n                        if (RExC_rx->minlen<*minnextp)\n                            RExC_rx->minlen=*minnextp;\n                        scan_commit(pRExC_state, &data_fake, minnextp, is_inf);\n                        SvREFCNT_dec_NN(data_fake.last_found);\n\n                        for (i = 0; i < 2; i++) {\n                            if (data_fake.substrs[i].minlenp != minlenp) {\n                                data->substrs[i].min_offset =\n                                            data_fake.substrs[i].min_offset;\n                                data->substrs[i].max_offset =\n                                            data_fake.substrs[i].max_offset;\n                                data->substrs[i].minlenp =\n                                            data_fake.substrs[i].minlenp;\n                                data->substrs[i].lookbehind += scan->flags;\n                            }\n                        }\n                    }\n                }\n\t    }\n#endif\n\t}\n\n\telse if (OP(scan) == OPEN) {\n\t    if (stopparen != (I32)ARG(scan))\n\t        pars++;\n\t}\n\telse if (OP(scan) == CLOSE) {\n\t    if (stopparen == (I32)ARG(scan)) {\n\t        break;\n\t    }\n\t    if ((I32)ARG(scan) == is_par) {\n\t\tnext = regnext(scan);\n\n\t\tif ( next && (OP(next) != WHILEM) && next < last)\n\t\t    is_par = 0;\t\t/* Disable optimization */\n\t    }\n\t    if (data)\n\t\t*(data->last_closep) = ARG(scan);\n\t}\n\telse if (OP(scan) == EVAL) {\n\t\tif (data)\n\t\t    data->flags |= SF_HAS_EVAL;\n\t}\n\telse if ( PL_regkind[OP(scan)] == ENDLIKE ) {\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tflags &= ~SCF_DO_SUBSTR;\n\t    }\n\t    if (data && OP(scan)==ACCEPT) {\n\t        data->flags |= SCF_SEEN_ACCEPT;\n\t        if (stopmin > min)\n\t            stopmin = min;\n\t    }\n\t}\n\telse if (OP(scan) == LOGICAL && scan->flags == 2) /* Embedded follows */\n\t{\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n\t\t    ssc_anything(data->start_class);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t}\n\telse if (OP(scan) == GPOS) {\n            if (!(RExC_rx->intflags & PREGf_GPOS_FLOAT) &&\n\t        !(delta || is_inf || (data && data->pos_delta)))\n\t    {\n                if (!(RExC_rx->intflags & PREGf_ANCH) && (flags & SCF_DO_SUBSTR))\n                    RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t        if (RExC_rx->gofs < (STRLEN)min)\n\t\t    RExC_rx->gofs = min;\n            } else {\n                RExC_rx->intflags |= PREGf_GPOS_FLOAT;\n                RExC_rx->gofs = 0;\n            }\n\t}\n#ifdef TRIE_STUDY_OPT\n#ifdef FULL_TRIE_STUDY\n        else if (PL_regkind[OP(scan)] == TRIE) {\n            /* NOTE - There is similar code to this block above for handling\n               BRANCH nodes on the initial study.  If you change stuff here\n               check there too. */\n            regnode *trie_node= scan;\n            regnode *tail= regnext(scan);\n            reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n            SSize_t max1 = 0, min1 = SSize_t_MAX;\n            regnode_ssc accum;\n\n            if (flags & SCF_DO_SUBSTR) { /* XXXX Add !SUSPEND? */\n                /* Cannot merge strings after this. */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n            }\n            if (flags & SCF_DO_STCLASS)\n                ssc_init_zero(pRExC_state, &accum);\n\n            if (!trie->jump) {\n                min1= trie->minlen;\n                max1= trie->maxlen;\n            } else {\n                const regnode *nextbranch= NULL;\n                U32 word;\n\n                for ( word=1 ; word <= trie->wordcount ; word++)\n                {\n                    SSize_t deltanext=0, minnext=0, f = 0, fake;\n                    regnode_ssc this_class;\n\n                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                    if (data) {\n                        data_fake.whilem_c = data->whilem_c;\n                        data_fake.last_closep = data->last_closep;\n                    }\n                    else\n                        data_fake.last_closep = &fake;\n\t\t    data_fake.pos_delta = delta;\n                    if (flags & SCF_DO_STCLASS) {\n                        ssc_init(pRExC_state, &this_class);\n                        data_fake.start_class = &this_class;\n                        f = SCF_DO_STCLASS_AND;\n                    }\n                    if (flags & SCF_WHILEM_VISITED_POS)\n                        f |= SCF_WHILEM_VISITED_POS;\n\n                    if (trie->jump[word]) {\n                        if (!nextbranch)\n                            nextbranch = trie_node + trie->jump[0];\n                        scan= trie_node + trie->jump[word];\n                        /* We go from the jump point to the branch that follows\n                           it. Note this means we need the vestigal unused\n                           branches even though they arent otherwise used. */\n                        /* optimise study_chunk() for TRIE */\n                        minnext = study_chunk(pRExC_state, &scan, minlenp,\n                            &deltanext, (regnode *)nextbranch, &data_fake,\n                            stopparen, recursed_depth, NULL, f, depth+1);\n                    }\n                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n                        nextbranch= regnext((regnode*)nextbranch);\n\n                    if (min1 > (SSize_t)(minnext + trie->minlen))\n                        min1 = minnext + trie->minlen;\n                    if (deltanext == SSize_t_MAX) {\n                        is_inf = is_inf_internal = 1;\n                        max1 = SSize_t_MAX;\n                    } else if (max1 < (SSize_t)(minnext + deltanext + trie->maxlen))\n                        max1 = minnext + deltanext + trie->maxlen;\n\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SCF_SEEN_ACCEPT) {\n                        if ( stopmin > min + min1)\n\t                    stopmin = min + min1;\n\t                flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n                    if (data) {\n                        if (data_fake.flags & SF_HAS_EVAL)\n                            data->flags |= SF_HAS_EVAL;\n                        data->whilem_c = data_fake.whilem_c;\n                    }\n                    if (flags & SCF_DO_STCLASS)\n                        ssc_or(pRExC_state, &accum, (regnode_charclass *) &this_class);\n                }\n            }\n            if (flags & SCF_DO_SUBSTR) {\n                data->pos_min += min1;\n                data->pos_delta += max1 - min1;\n                if (max1 != min1 || is_inf)\n                    data->cur_is_floating = 1; /* float */\n            }\n            min += min1;\n            if (delta != SSize_t_MAX) {\n                if (SSize_t_MAX - (max1 - min1) >= delta)\n                    delta += max1 - min1;\n                else\n                    delta = SSize_t_MAX;\n            }\n            if (flags & SCF_DO_STCLASS_OR) {\n                ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                if (min1) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n                    flags &= ~SCF_DO_STCLASS;\n                }\n            }\n            else if (flags & SCF_DO_STCLASS_AND) {\n                if (min1) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                    flags &= ~SCF_DO_STCLASS;\n                }\n                else {\n                    /* Switch to OR mode: cache the old value of\n                     * data->start_class */\n\t\t    INIT_AND_WITHP;\n                    StructCopy(data->start_class, and_withp, regnode_ssc);\n                    flags &= ~SCF_DO_STCLASS_AND;\n                    StructCopy(&accum, data->start_class, regnode_ssc);\n                    flags |= SCF_DO_STCLASS_OR;\n                }\n            }\n            scan= tail;\n            continue;\n        }\n#else\n\telse if (PL_regkind[OP(scan)] == TRIE) {\n\t    reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n\t    U8*bang=NULL;\n\n\t    min += trie->minlen;\n\t    delta += (trie->maxlen - trie->minlen);\n\t    flags &= ~SCF_DO_STCLASS; /* xxx */\n            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything... */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t        data->pos_min += trie->minlen;\n    \t        data->pos_delta += (trie->maxlen - trie->minlen);\n\t\tif (trie->maxlen != trie->minlen)\n\t\t    data->cur_is_floating = 1; /* float */\n    \t    }\n    \t    if (trie->jump) /* no more substrings -- for now /grr*/\n               flags &= ~SCF_DO_SUBSTR;\n\t}\n#endif /* old or new */\n#endif /* TRIE_STUDY_OPT */\n\n\t/* Else: zero-length, ignore. */\n\tscan = regnext(scan);\n    }\n\n  finish:\n    if (frame) {\n        /* we need to unwind recursion. */\n        depth = depth - 1;\n\n        DEBUG_STUDYDATA(\"frame-end\", data, depth, is_inf);\n        DEBUG_PEEP(\"fend\", scan, depth, flags);\n\n        /* restore previous context */\n        last = frame->last_regnode;\n        scan = frame->next_regnode;\n        stopparen = frame->stopparen;\n        recursed_depth = frame->prev_recursed_depth;\n\n        RExC_frame_last = frame->prev_frame;\n        frame = frame->this_prev_frame;\n        goto fake_study_recurse;\n    }\n\n    assert(!frame);\n    DEBUG_STUDYDATA(\"pre-fin\", data, depth, is_inf);\n\n    *scanp = scan;\n    *deltap = is_inf_internal ? SSize_t_MAX : delta;\n\n    if (flags & SCF_DO_SUBSTR && is_inf)\n\tdata->pos_delta = SSize_t_MAX - data->pos_min;\n    if (is_par > (I32)U8_MAX)\n\tis_par = 0;\n    if (is_par && pars==1 && data) {\n\tdata->flags |= SF_IN_PAR;\n\tdata->flags &= ~SF_HAS_PAR;\n    }\n    else if (pars && data) {\n\tdata->flags |= SF_HAS_PAR;\n\tdata->flags &= ~SF_IN_PAR;\n    }\n    if (flags & SCF_DO_STCLASS_OR)\n\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n    if (flags & SCF_TRIE_RESTUDY)\n        data->flags |= \tSCF_TRIE_RESTUDY;\n\n    DEBUG_STUDYDATA(\"post-fin\", data, depth, is_inf);\n\n    {\n        SSize_t final_minlen= min < stopmin ? min : stopmin;\n\n        if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)) {\n            if (final_minlen > SSize_t_MAX - delta)\n                RExC_maxlen = SSize_t_MAX;\n            else if (RExC_maxlen < final_minlen + delta)\n                RExC_maxlen = final_minlen + delta;\n        }\n        return final_minlen;\n    }\n    NOT_REACHED; /* NOTREACHED */\n}\n\nSTATIC U32\nS_add_data(RExC_state_t* const pRExC_state, const char* const s, const U32 n)\n{\n    U32 count = RExC_rxi->data ? RExC_rxi->data->count : 0;\n\n    PERL_ARGS_ASSERT_ADD_DATA;\n\n    Renewc(RExC_rxi->data,\n\t   sizeof(*RExC_rxi->data) + sizeof(void*) * (count + n - 1),\n\t   char, struct reg_data);\n    if(count)\n\tRenew(RExC_rxi->data->what, count + n, U8);\n    else\n\tNewx(RExC_rxi->data->what, n, U8);\n    RExC_rxi->data->count = count + n;\n    Copy(s, RExC_rxi->data->what + count, n, U8);\n    return count;\n}\n\n/*XXX: todo make this not included in a non debugging perl, but appears to be\n * used anyway there, in 'use re' */\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_reginitcolors(pTHX)\n{\n    const char * const s = PerlEnv_getenv(\"PERL_RE_COLORS\");\n    if (s) {\n\tchar *t = savepv(s);\n\tint i = 0;\n\tPL_colors[0] = t;\n\twhile (++i < 6) {\n\t    t = strchr(t, '\\t');\n\t    if (t) {\n\t\t*t = '\\0';\n\t\tPL_colors[i] = ++t;\n\t    }\n\t    else\n\t\tPL_colors[i] = t = (char *)\"\";\n\t}\n    } else {\n\tint i = 0;\n\twhile (i < 6)\n\t    PL_colors[i++] = (char *)\"\";\n    }\n    PL_colorset = 1;\n}\n#endif\n\n\n#ifdef TRIE_STUDY_OPT\n#define CHECK_RESTUDY_GOTO_butfirst(dOsomething)            \\\n    STMT_START {                                            \\\n        if (                                                \\\n              (data.flags & SCF_TRIE_RESTUDY)               \\\n              && ! restudied++                              \\\n        ) {                                                 \\\n            dOsomething;                                    \\\n            goto reStudy;                                   \\\n        }                                                   \\\n    } STMT_END\n#else\n#define CHECK_RESTUDY_GOTO_butfirst\n#endif\n\n/*\n * pregcomp - compile a regular expression into internal code\n *\n * Decides which engine's compiler to call based on the hint currently in\n * scope\n */\n\n#ifndef PERL_IN_XSUB_RE\n\n/* return the currently in-scope regex engine (or the default if none)  */\n\nregexp_engine const *\nPerl_current_re_engine(pTHX)\n{\n    if (IN_PERL_COMPILETIME) {\n\tHV * const table = GvHV(PL_hintgv);\n\tSV **ptr;\n\n\tif (!table || !(PL_hints & HINT_LOCALIZE_HH))\n\t    return &PL_core_reg_engine;\n\tptr = hv_fetchs(table, \"regcomp\", FALSE);\n\tif ( !(ptr && SvIOK(*ptr) && SvIV(*ptr)))\n\t    return &PL_core_reg_engine;\n\treturn INT2PTR(regexp_engine*, SvIV(*ptr));\n    }\n    else {\n\tSV *ptr;\n\tif (!PL_curcop->cop_hints_hash)\n\t    return &PL_core_reg_engine;\n\tptr = cop_hints_fetch_pvs(PL_curcop, \"regcomp\", 0);\n\tif ( !(ptr && SvIOK(ptr) && SvIV(ptr)))\n\t    return &PL_core_reg_engine;\n\treturn INT2PTR(regexp_engine*, SvIV(ptr));\n    }\n}\n\n\nREGEXP *\nPerl_pregcomp(pTHX_ SV * const pattern, const U32 flags)\n{\n    regexp_engine const *eng = current_re_engine();\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_PREGCOMP;\n\n    /* Dispatch a request to compile a regexp to correct regexp engine. */\n    DEBUG_COMPILE_r({\n        Perl_re_printf( aTHX_  \"Using engine %\" UVxf \"\\n\",\n\t\t\tPTR2UV(eng));\n    });\n    return CALLREGCOMP_ENG(eng, pattern, flags);\n}\n#endif\n\n/* public(ish) entry point for the perl core's own regex compiling code.\n * It's actually a wrapper for Perl_re_op_compile that only takes an SV\n * pattern rather than a list of OPs, and uses the internal engine rather\n * than the current one */\n\nREGEXP *\nPerl_re_compile(pTHX_ SV * const pattern, U32 rx_flags)\n{\n    SV *pat = pattern; /* defeat constness! */\n    PERL_ARGS_ASSERT_RE_COMPILE;\n    return Perl_re_op_compile(aTHX_ &pat, 1, NULL,\n#ifdef PERL_IN_XSUB_RE\n                                &my_reg_engine,\n#else\n                                &PL_core_reg_engine,\n#endif\n                                NULL, NULL, rx_flags, 0);\n}\n\n\nstatic void\nS_free_codeblocks(pTHX_ struct reg_code_blocks *cbs)\n{\n    int n;\n\n    if (--cbs->refcnt > 0)\n        return;\n    for (n = 0; n < cbs->count; n++) {\n        REGEXP *rx = cbs->cb[n].src_regex;\n        if (rx) {\n            cbs->cb[n].src_regex = NULL;\n            SvREFCNT_dec_NN(rx);\n        }\n    }\n    Safefree(cbs->cb);\n    Safefree(cbs);\n}\n\n\nstatic struct reg_code_blocks *\nS_alloc_code_blocks(pTHX_  int ncode)\n{\n     struct reg_code_blocks *cbs;\n    Newx(cbs, 1, struct reg_code_blocks);\n    cbs->count = ncode;\n    cbs->refcnt = 1;\n    SAVEDESTRUCTOR_X(S_free_codeblocks, cbs);\n    if (ncode)\n        Newx(cbs->cb, ncode, struct reg_code_block);\n    else\n        cbs->cb = NULL;\n    return cbs;\n}\n\n\n/* upgrade pattern pat_p of length plen_p to UTF8, and if there are code\n * blocks, recalculate the indices. Update pat_p and plen_p in-place to\n * point to the realloced string and length.\n *\n * This is essentially a copy of Perl_bytes_to_utf8() with the code index\n * stuff added */\n\nstatic void\nS_pat_upgrade_to_utf8(pTHX_ RExC_state_t * const pRExC_state,\n\t\t    char **pat_p, STRLEN *plen_p, int num_code_blocks)\n{\n    U8 *const src = (U8*)*pat_p;\n    U8 *dst, *d;\n    int n=0;\n    STRLEN s = 0;\n    bool do_end = 0;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    DEBUG_PARSE_r(Perl_re_printf( aTHX_\n        \"UTF8 mismatch! Converting to utf8 for resizing and compile\\n\"));\n\n    /* 1 for each byte + 1 for each byte that expands to two, + trailing NUL */\n    Newx(dst, *plen_p + variant_under_utf8_count(src, src + *plen_p) + 1, U8);\n    d = dst;\n\n    while (s < *plen_p) {\n        append_utf8_from_native_byte(src[s], &d);\n\n        if (n < num_code_blocks) {\n            assert(pRExC_state->code_blocks);\n            if (!do_end && pRExC_state->code_blocks->cb[n].start == s) {\n                pRExC_state->code_blocks->cb[n].start = d - dst - 1;\n                assert(*(d - 1) == '(');\n                do_end = 1;\n            }\n            else if (do_end && pRExC_state->code_blocks->cb[n].end == s) {\n                pRExC_state->code_blocks->cb[n].end = d - dst - 1;\n                assert(*(d - 1) == ')');\n                do_end = 0;\n                n++;\n            }\n        }\n        s++;\n    }\n    *d = '\\0';\n    *plen_p = d - dst;\n    *pat_p = (char*) dst;\n    SAVEFREEPV(*pat_p);\n    RExC_orig_utf8 = RExC_utf8 = 1;\n}\n\n\n\n/* S_concat_pat(): concatenate a list of args to the pattern string pat,\n * while recording any code block indices, and handling overloading,\n * nested qr// objects etc.  If pat is null, it will allocate a new\n * string, or just return the first arg, if there's only one.\n *\n * Returns the malloced/updated pat.\n * patternp and pat_count is the array of SVs to be concatted;\n * oplist is the optional list of ops that generated the SVs;\n * recompile_p is a pointer to a boolean that will be set if\n *   the regex will need to be recompiled.\n * delim, if non-null is an SV that will be inserted between each element\n */\n\nstatic SV*\nS_concat_pat(pTHX_ RExC_state_t * const pRExC_state,\n                SV *pat, SV ** const patternp, int pat_count,\n                OP *oplist, bool *recompile_p, SV *delim)\n{\n    SV **svp;\n    int n = 0;\n    bool use_delim = FALSE;\n    bool alloced = FALSE;\n\n    /* if we know we have at least two args, create an empty string,\n     * then concatenate args to that. For no args, return an empty string */\n    if (!pat && pat_count != 1) {\n        pat = newSVpvs(\"\");\n        SAVEFREESV(pat);\n        alloced = TRUE;\n    }\n\n    for (svp = patternp; svp < patternp + pat_count; svp++) {\n        SV *sv;\n        SV *rx  = NULL;\n        STRLEN orig_patlen = 0;\n        bool code = 0;\n        SV *msv = use_delim ? delim : *svp;\n        if (!msv) msv = &PL_sv_undef;\n\n        /* if we've got a delimiter, we go round the loop twice for each\n         * svp slot (except the last), using the delimiter the second\n         * time round */\n        if (use_delim) {\n            svp--;\n            use_delim = FALSE;\n        }\n        else if (delim)\n            use_delim = TRUE;\n\n        if (SvTYPE(msv) == SVt_PVAV) {\n            /* we've encountered an interpolated array within\n             * the pattern, e.g. /...@a..../. Expand the list of elements,\n             * then recursively append elements.\n             * The code in this block is based on S_pushav() */\n\n            AV *const av = (AV*)msv;\n            const SSize_t maxarg = AvFILL(av) + 1;\n            SV **array;\n\n            if (oplist) {\n                assert(oplist->op_type == OP_PADAV\n                    || oplist->op_type == OP_RV2AV);\n                oplist = OpSIBLING(oplist);\n            }\n\n            if (SvRMAGICAL(av)) {\n                SSize_t i;\n\n                Newx(array, maxarg, SV*);\n                SAVEFREEPV(array);\n                for (i=0; i < maxarg; i++) {\n                    SV ** const svp = av_fetch(av, i, FALSE);\n                    array[i] = svp ? *svp : &PL_sv_undef;\n                }\n            }\n            else\n                array = AvARRAY(av);\n\n            pat = S_concat_pat(aTHX_ pRExC_state, pat,\n                                array, maxarg, NULL, recompile_p,\n                                /* $\" */\n                                GvSV((gv_fetchpvs(\"\\\"\", GV_ADDMULTI, SVt_PV))));\n\n            continue;\n        }\n\n\n        /* we make the assumption here that each op in the list of\n         * op_siblings maps to one SV pushed onto the stack,\n         * except for code blocks, with have both an OP_NULL and\n         * and OP_CONST.\n         * This allows us to match up the list of SVs against the\n         * list of OPs to find the next code block.\n         *\n         * Note that       PUSHMARK PADSV PADSV ..\n         * is optimised to\n         *                 PADRANGE PADSV  PADSV  ..\n         * so the alignment still works. */\n\n        if (oplist) {\n            if (oplist->op_type == OP_NULL\n                && (oplist->op_flags & OPf_SPECIAL))\n            {\n                assert(n < pRExC_state->code_blocks->count);\n                pRExC_state->code_blocks->cb[n].start = pat ? SvCUR(pat) : 0;\n                pRExC_state->code_blocks->cb[n].block = oplist;\n                pRExC_state->code_blocks->cb[n].src_regex = NULL;\n                n++;\n                code = 1;\n                oplist = OpSIBLING(oplist); /* skip CONST */\n                assert(oplist);\n            }\n            oplist = OpSIBLING(oplist);;\n        }\n\n\t/* apply magic and QR overloading to arg */\n\n        SvGETMAGIC(msv);\n        if (SvROK(msv) && SvAMAGIC(msv)) {\n            SV *sv = AMG_CALLunary(msv, regexp_amg);\n            if (sv) {\n                if (SvROK(sv))\n                    sv = SvRV(sv);\n                if (SvTYPE(sv) != SVt_REGEXP)\n                    Perl_croak(aTHX_ \"Overloaded qr did not return a REGEXP\");\n                msv = sv;\n            }\n        }\n\n        /* try concatenation overload ... */\n        if (pat && (SvAMAGIC(pat) || SvAMAGIC(msv)) &&\n                (sv = amagic_call(pat, msv, concat_amg, AMGf_assign)))\n        {\n            sv_setsv(pat, sv);\n            /* overloading involved: all bets are off over literal\n             * code. Pretend we haven't seen it */\n            if (n)\n                pRExC_state->code_blocks->count -= n;\n            n = 0;\n        }\n        else  {\n            /* ... or failing that, try \"\" overload */\n            while (SvAMAGIC(msv)\n                    && (sv = AMG_CALLunary(msv, string_amg))\n                    && sv != msv\n                    &&  !(   SvROK(msv)\n                          && SvROK(sv)\n                          && SvRV(msv) == SvRV(sv))\n            ) {\n                msv = sv;\n                SvGETMAGIC(msv);\n            }\n            if (SvROK(msv) && SvTYPE(SvRV(msv)) == SVt_REGEXP)\n                msv = SvRV(msv);\n\n            if (pat) {\n                /* this is a partially unrolled\n                 *     sv_catsv_nomg(pat, msv);\n                 * that allows us to adjust code block indices if\n                 * needed */\n                STRLEN dlen;\n                char *dst = SvPV_force_nomg(pat, dlen);\n                orig_patlen = dlen;\n                if (SvUTF8(msv) && !SvUTF8(pat)) {\n                    S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &dst, &dlen, n);\n                    sv_setpvn(pat, dst, dlen);\n                    SvUTF8_on(pat);\n                }\n                sv_catsv_nomg(pat, msv);\n                rx = msv;\n            }\n            else {\n                /* We have only one SV to process, but we need to verify\n                 * it is properly null terminated or we will fail asserts\n                 * later. In theory we probably shouldn't get such SV's,\n                 * but if we do we should handle it gracefully. */\n                if ( SvTYPE(msv) != SVt_PV || (SvLEN(msv) > SvCUR(msv) && *(SvEND(msv)) == 0) || SvIsCOW_shared_hash(msv) ) {\n                    /* not a string, or a string with a trailing null */\n                    pat = msv;\n                } else {\n                    /* a string with no trailing null, we need to copy it\n                     * so it has a trailing null */\n                    pat = sv_2mortal(newSVsv(msv));\n                }\n            }\n\n            if (code)\n                pRExC_state->code_blocks->cb[n-1].end = SvCUR(pat)-1;\n        }\n\n        /* extract any code blocks within any embedded qr//'s */\n        if (rx && SvTYPE(rx) == SVt_REGEXP\n            && RX_ENGINE((REGEXP*)rx)->op_comp)\n        {\n\n            RXi_GET_DECL(ReANY((REGEXP *)rx), ri);\n            if (ri->code_blocks && ri->code_blocks->count) {\n                int i;\n                /* the presence of an embedded qr// with code means\n                 * we should always recompile: the text of the\n                 * qr// may not have changed, but it may be a\n                 * different closure than last time */\n                *recompile_p = 1;\n                if (pRExC_state->code_blocks) {\n                    int new_count = pRExC_state->code_blocks->count\n                            + ri->code_blocks->count;\n                    Renew(pRExC_state->code_blocks->cb,\n                            new_count, struct reg_code_block);\n                    pRExC_state->code_blocks->count = new_count;\n                }\n                else\n                    pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_\n                                                    ri->code_blocks->count);\n\n                for (i=0; i < ri->code_blocks->count; i++) {\n                    struct reg_code_block *src, *dst;\n                    STRLEN offset =  orig_patlen\n                        + ReANY((REGEXP *)rx)->pre_prefix;\n                    assert(n < pRExC_state->code_blocks->count);\n                    src = &ri->code_blocks->cb[i];\n                    dst = &pRExC_state->code_blocks->cb[n];\n                    dst->start\t    = src->start + offset;\n                    dst->end\t    = src->end   + offset;\n                    dst->block\t    = src->block;\n                    dst->src_regex  = (REGEXP*) SvREFCNT_inc( (SV*)\n                                            src->src_regex\n                                                ? src->src_regex\n                                                : (REGEXP*)rx);\n                    n++;\n                }\n            }\n        }\n    }\n    /* avoid calling magic multiple times on a single element e.g. =~ $qr */\n    if (alloced)\n        SvSETMAGIC(pat);\n\n    return pat;\n}\n\n\n\n/* see if there are any run-time code blocks in the pattern.\n * False positives are allowed */\n\nstatic bool\nS_has_runtime_code(pTHX_ RExC_state_t * const pRExC_state,\n\t\t    char *pat, STRLEN plen)\n{\n    int n = 0;\n    STRLEN s;\n\n    PERL_UNUSED_CONTEXT;\n\n    for (s = 0; s < plen; s++) {\n\tif (   pRExC_state->code_blocks\n            && n < pRExC_state->code_blocks->count\n\t    && s == pRExC_state->code_blocks->cb[n].start)\n\t{\n\t    s = pRExC_state->code_blocks->cb[n].end;\n\t    n++;\n\t    continue;\n\t}\n\t/* TODO ideally should handle [..], (#..), /#.../x to reduce false\n\t * positives here */\n\tif (pat[s] == '(' && s+2 <= plen && pat[s+1] == '?' &&\n\t    (pat[s+2] == '{'\n                || (s + 2 <= plen && pat[s+2] == '?' && pat[s+3] == '{'))\n\t)\n\t    return 1;\n    }\n    return 0;\n}\n\n/* Handle run-time code blocks. We will already have compiled any direct\n * or indirect literal code blocks. Now, take the pattern 'pat' and make a\n * copy of it, but with any literal code blocks blanked out and\n * appropriate chars escaped; then feed it into\n *\n *    eval \"qr'modified_pattern'\"\n *\n * For example,\n *\n *       a\\bc(?{\"this was literal\"})def'ghi\\\\jkl(?{\"this is runtime\"})mno\n *\n * becomes\n *\n *    qr'a\\\\bc_______________________def\\'ghi\\\\\\\\jkl(?{\"this is runtime\"})mno'\n *\n * After eval_sv()-ing that, grab any new code blocks from the returned qr\n * and merge them with any code blocks of the original regexp.\n *\n * If the pat is non-UTF8, while the evalled qr is UTF8, don't merge;\n * instead, just save the qr and return FALSE; this tells our caller that\n * the original pattern needs upgrading to utf8.\n */\n\nstatic bool\nS_compile_runtime_code(pTHX_ RExC_state_t * const pRExC_state,\n    char *pat, STRLEN plen)\n{\n    SV *qr;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    if (pRExC_state->runtime_code_qr) {\n\t/* this is the second time we've been called; this should\n\t * only happen if the main pattern got upgraded to utf8\n\t * during compilation; re-use the qr we compiled first time\n\t * round (which should be utf8 too)\n\t */\n\tqr = pRExC_state->runtime_code_qr;\n\tpRExC_state->runtime_code_qr = NULL;\n\tassert(RExC_utf8 && SvUTF8(qr));\n    }\n    else {\n\tint n = 0;\n\tSTRLEN s;\n\tchar *p, *newpat;\n\tint newlen = plen + 7; /* allow for \"qr''xx\\0\" extra chars */\n\tSV *sv, *qr_ref;\n\tdSP;\n\n\t/* determine how many extra chars we need for ' and \\ escaping */\n\tfor (s = 0; s < plen; s++) {\n\t    if (pat[s] == '\\'' || pat[s] == '\\\\')\n\t\tnewlen++;\n\t}\n\n\tNewx(newpat, newlen, char);\n\tp = newpat;\n\t*p++ = 'q'; *p++ = 'r'; *p++ = '\\'';\n\n\tfor (s = 0; s < plen; s++) {\n\t    if (   pRExC_state->code_blocks\n\t        && n < pRExC_state->code_blocks->count\n\t\t&& s == pRExC_state->code_blocks->cb[n].start)\n\t    {\n\t\t/* blank out literal code block so that they aren't\n                 * recompiled: eg change from/to:\n                 *     /(?{xyz})/\n                 *     /(?=====)/\n                 * and\n                 *     /(??{xyz})/\n                 *     /(?======)/\n                 * and\n                 *     /(?(?{xyz}))/\n                 *     /(?(?=====))/\n                */\n\t\tassert(pat[s]   == '(');\n\t\tassert(pat[s+1] == '?');\n                *p++ = '(';\n                *p++ = '?';\n                s += 2;\n\t\twhile (s < pRExC_state->code_blocks->cb[n].end) {\n\t\t    *p++ = '=';\n\t\t    s++;\n\t\t}\n                *p++ = ')';\n\t\tn++;\n\t\tcontinue;\n\t    }\n\t    if (pat[s] == '\\'' || pat[s] == '\\\\')\n\t\t*p++ = '\\\\';\n\t    *p++ = pat[s];\n\t}\n\t*p++ = '\\'';\n\tif (pRExC_state->pm_flags & RXf_PMf_EXTENDED) {\n\t    *p++ = 'x';\n            if (pRExC_state->pm_flags & RXf_PMf_EXTENDED_MORE) {\n                *p++ = 'x';\n            }\n        }\n\t*p++ = '\\0';\n\tDEBUG_COMPILE_r({\n            Perl_re_printf( aTHX_\n\t\t\"%sre-parsing pattern for runtime code:%s %s\\n\",\n\t\tPL_colors[4], PL_colors[5], newpat);\n\t});\n\n\tsv = newSVpvn_flags(newpat, p-newpat-1, RExC_utf8 ? SVf_UTF8 : 0);\n\tSafefree(newpat);\n\n\tENTER;\n\tSAVETMPS;\n\tsave_re_context();\n\tPUSHSTACKi(PERLSI_REQUIRE);\n        /* G_RE_REPARSING causes the toker to collapse \\\\ into \\ when\n         * parsing qr''; normally only q'' does this. It also alters\n         * hints handling */\n\teval_sv(sv, G_SCALAR|G_RE_REPARSING);\n\tSvREFCNT_dec_NN(sv);\n\tSPAGAIN;\n\tqr_ref = POPs;\n\tPUTBACK;\n\t{\n\t    SV * const errsv = ERRSV;\n\t    if (SvTRUE_NN(errsv))\n                /* use croak_sv ? */\n\t\tPerl_croak_nocontext(\"%\" SVf, SVfARG(errsv));\n\t}\n\tassert(SvROK(qr_ref));\n\tqr = SvRV(qr_ref);\n\tassert(SvTYPE(qr) == SVt_REGEXP && RX_ENGINE((REGEXP*)qr)->op_comp);\n\t/* the leaving below frees the tmp qr_ref.\n\t * Give qr a life of its own */\n\tSvREFCNT_inc(qr);\n\tPOPSTACK;\n\tFREETMPS;\n\tLEAVE;\n\n    }\n\n    if (!RExC_utf8 && SvUTF8(qr)) {\n\t/* first time through; the pattern got upgraded; save the\n\t * qr for the next time through */\n\tassert(!pRExC_state->runtime_code_qr);\n\tpRExC_state->runtime_code_qr = qr;\n\treturn 0;\n    }\n\n\n    /* extract any code blocks within the returned qr//  */\n\n\n    /* merge the main (r1) and run-time (r2) code blocks into one */\n    {\n\tRXi_GET_DECL(ReANY((REGEXP *)qr), r2);\n\tstruct reg_code_block *new_block, *dst;\n\tRExC_state_t * const r1 = pRExC_state; /* convenient alias */\n\tint i1 = 0, i2 = 0;\n        int r1c, r2c;\n\n\tif (!r2->code_blocks || !r2->code_blocks->count) /* we guessed wrong */\n\t{\n\t    SvREFCNT_dec_NN(qr);\n\t    return 1;\n\t}\n\n        if (!r1->code_blocks)\n            r1->code_blocks = S_alloc_code_blocks(aTHX_ 0);\n\n        r1c = r1->code_blocks->count;\n        r2c = r2->code_blocks->count;\n\n\tNewx(new_block, r1c + r2c, struct reg_code_block);\n\n\tdst = new_block;\n\n\twhile (i1 < r1c || i2 < r2c) {\n\t    struct reg_code_block *src;\n\t    bool is_qr = 0;\n\n\t    if (i1 == r1c) {\n\t\tsrc = &r2->code_blocks->cb[i2++];\n\t\tis_qr = 1;\n\t    }\n\t    else if (i2 == r2c)\n\t\tsrc = &r1->code_blocks->cb[i1++];\n\t    else if (  r1->code_blocks->cb[i1].start\n\t             < r2->code_blocks->cb[i2].start)\n\t    {\n\t\tsrc = &r1->code_blocks->cb[i1++];\n\t\tassert(src->end < r2->code_blocks->cb[i2].start);\n\t    }\n\t    else {\n\t\tassert(  r1->code_blocks->cb[i1].start\n\t\t       > r2->code_blocks->cb[i2].start);\n\t\tsrc = &r2->code_blocks->cb[i2++];\n\t\tis_qr = 1;\n\t\tassert(src->end < r1->code_blocks->cb[i1].start);\n\t    }\n\n\t    assert(pat[src->start] == '(');\n\t    assert(pat[src->end]   == ')');\n\t    dst->start\t    = src->start;\n\t    dst->end\t    = src->end;\n\t    dst->block\t    = src->block;\n\t    dst->src_regex  = is_qr ? (REGEXP*) SvREFCNT_inc( (SV*) qr)\n\t\t\t\t    : src->src_regex;\n\t    dst++;\n\t}\n\tr1->code_blocks->count += r2c;\n\tSafefree(r1->code_blocks->cb);\n\tr1->code_blocks->cb = new_block;\n    }\n\n    SvREFCNT_dec_NN(qr);\n    return 1;\n}\n\n\nSTATIC bool\nS_setup_longest(pTHX_ RExC_state_t *pRExC_state,\n                      struct reg_substr_datum  *rsd,\n                      struct scan_data_substrs *sub,\n                      STRLEN longest_length)\n{\n    /* This is the common code for setting up the floating and fixed length\n     * string data extracted from Perl_re_op_compile() below.  Returns a boolean\n     * as to whether succeeded or not */\n\n    I32 t;\n    SSize_t ml;\n    bool eol  = cBOOL(sub->flags & SF_BEFORE_EOL);\n    bool meol = cBOOL(sub->flags & SF_BEFORE_MEOL);\n\n    if (! (longest_length\n           || (eol /* Can't have SEOL and MULTI */\n               && (! meol || (RExC_flags & RXf_PMf_MULTILINE)))\n          )\n            /* See comments for join_exact for why REG_UNFOLDED_MULTI_SEEN */\n        || (RExC_seen & REG_UNFOLDED_MULTI_SEEN))\n    {\n        return FALSE;\n    }\n\n    /* copy the information about the longest from the reg_scan_data\n        over to the program. */\n    if (SvUTF8(sub->str)) {\n        rsd->substr      = NULL;\n        rsd->utf8_substr = sub->str;\n    } else {\n        rsd->substr      = sub->str;\n        rsd->utf8_substr = NULL;\n    }\n    /* end_shift is how many chars that must be matched that\n        follow this item. We calculate it ahead of time as once the\n        lookbehind offset is added in we lose the ability to correctly\n        calculate it.*/\n    ml = sub->minlenp ? *(sub->minlenp) : (SSize_t)longest_length;\n    rsd->end_shift = ml - sub->min_offset\n        - longest_length\n            /* XXX SvTAIL is always false here - did you mean FBMcf_TAIL\n             * intead? - DAPM\n            + (SvTAIL(sub->str) != 0)\n            */\n        + sub->lookbehind;\n\n    t = (eol/* Can't have SEOL and MULTI */\n         && (! meol || (RExC_flags & RXf_PMf_MULTILINE)));\n    fbm_compile(sub->str, t ? FBMcf_TAIL : 0);\n\n    return TRUE;\n}\n\nSTATIC void\nS_set_regex_pv(pTHX_ RExC_state_t *pRExC_state, REGEXP *Rx)\n{\n    /* Calculates and sets in the compiled pattern 'Rx' the string to compile,\n     * properly wrapped with the right modifiers */\n\n    bool has_p     = ((RExC_rx->extflags & RXf_PMf_KEEPCOPY) == RXf_PMf_KEEPCOPY);\n    bool has_charset = RExC_utf8 || (get_regex_charset(RExC_rx->extflags)\n                                                != REGEX_DEPENDS_CHARSET);\n\n    /* The caret is output if there are any defaults: if not all the STD\n        * flags are set, or if no character set specifier is needed */\n    bool has_default =\n                (((RExC_rx->extflags & RXf_PMf_STD_PMMOD) != RXf_PMf_STD_PMMOD)\n                || ! has_charset);\n    bool has_runon = ((RExC_seen & REG_RUN_ON_COMMENT_SEEN)\n                                                == REG_RUN_ON_COMMENT_SEEN);\n    U8 reganch = (U8)((RExC_rx->extflags & RXf_PMf_STD_PMMOD)\n                        >> RXf_PMf_STD_PMMOD_SHIFT);\n    const char *fptr = STD_PAT_MODS;        /*\"msixxn\"*/\n    char *p;\n    STRLEN pat_len = RExC_precomp_end - RExC_precomp;\n\n    /* We output all the necessary flags; we never output a minus, as all\n        * those are defaults, so are\n        * covered by the caret */\n    const STRLEN wraplen = pat_len + has_p + has_runon\n        + has_default       /* If needs a caret */\n        + PL_bitcount[reganch] /* 1 char for each set standard flag */\n\n            /* If needs a character set specifier */\n        + ((has_charset) ? MAX_CHARSET_NAME_LENGTH : 0)\n        + (sizeof(\"(?:)\") - 1);\n\n    PERL_ARGS_ASSERT_SET_REGEX_PV;\n\n    /* make sure PL_bitcount bounds not exceeded */\n    assert(sizeof(STD_PAT_MODS) <= 8);\n\n    p = sv_grow(MUTABLE_SV(Rx), wraplen + 1); /* +1 for the ending NUL */\n    SvPOK_on(Rx);\n    if (RExC_utf8)\n        SvFLAGS(Rx) |= SVf_UTF8;\n    *p++='('; *p++='?';\n\n    /* If a default, cover it using the caret */\n    if (has_default) {\n        *p++= DEFAULT_PAT_MOD;\n    }\n    if (has_charset) {\n        STRLEN len;\n        const char* name;\n\n        name = get_regex_charset_name(RExC_rx->extflags, &len);\n        if strEQ(name, DEPENDS_PAT_MODS) {  /* /d under UTF-8 => /u */\n            assert(RExC_utf8);\n            name = UNICODE_PAT_MODS;\n            len = sizeof(UNICODE_PAT_MODS) - 1;\n        }\n        Copy(name, p, len, char);\n        p += len;\n    }\n    if (has_p)\n        *p++ = KEEPCOPY_PAT_MOD; /*'p'*/\n    {\n        char ch;\n        while((ch = *fptr++)) {\n            if(reganch & 1)\n                *p++ = ch;\n            reganch >>= 1;\n        }\n    }\n\n    *p++ = ':';\n    Copy(RExC_precomp, p, pat_len, char);\n    assert ((RX_WRAPPED(Rx) - p) < 16);\n    RExC_rx->pre_prefix = p - RX_WRAPPED(Rx);\n    p += pat_len;\n\n    /* Adding a trailing \\n causes this to compile properly:\n            my $R = qr / A B C # D E/x; /($R)/\n        Otherwise the parens are considered part of the comment */\n    if (has_runon)\n        *p++ = '\\n';\n    *p++ = ')';\n    *p = 0;\n    SvCUR_set(Rx, p - RX_WRAPPED(Rx));\n}\n\n/*\n * Perl_re_op_compile - the perl internal RE engine's function to compile a\n * regular expression into internal code.\n * The pattern may be passed either as:\n *    a list of SVs (patternp plus pat_count)\n *    a list of OPs (expr)\n * If both are passed, the SV list is used, but the OP list indicates\n * which SVs are actually pre-compiled code blocks\n *\n * The SVs in the list have magic and qr overloading applied to them (and\n * the list may be modified in-place with replacement SVs in the latter\n * case).\n *\n * If the pattern hasn't changed from old_re, then old_re will be\n * returned.\n *\n * eng is the current engine. If that engine has an op_comp method, then\n * handle directly (i.e. we assume that op_comp was us); otherwise, just\n * do the initial concatenation of arguments and pass on to the external\n * engine.\n *\n * If is_bare_re is not null, set it to a boolean indicating whether the\n * arg list reduced (after overloading) to a single bare regex which has\n * been returned (i.e. /$qr/).\n *\n * orig_rx_flags contains RXf_* flags. See perlreapi.pod for more details.\n *\n * pm_flags contains the PMf_* flags, typically based on those from the\n * pm_flags field of the related PMOP. Currently we're only interested in\n * PMf_HAS_CV, PMf_IS_QR, PMf_USE_RE_EVAL.\n *\n * For many years this code had an initial sizing pass that calculated\n * (sometimes incorrectly, leading to security holes) the size needed for the\n * compiled pattern.  That was changed by commit\n * 7c932d07cab18751bfc7515b4320436273a459e2 in 5.29, which reallocs the size, a\n * node at a time, as parsing goes along.  Patches welcome to fix any obsolete\n * references to this sizing pass.\n *\n * Now, an initial crude guess as to the size needed is made, based on the\n * length of the pattern.  Patches welcome to improve that guess.  That amount\n * of space is malloc'd and then immediately freed, and then clawed back node\n * by node.  This design is to minimze, to the extent possible, memory churn\n * when doing the the reallocs.\n *\n * A separate parentheses counting pass may be needed in some cases.\n * (Previously the sizing pass did this.)  Patches welcome to reduce the number\n * of these cases.\n *\n * The existence of a sizing pass necessitated design decisions that are no\n * longer needed.  There are potential areas of simplification.\n *\n * Beware that the optimization-preparation code in here knows about some\n * of the structure of the compiled regexp.  [I'll say.]\n */\n\nREGEXP *\nPerl_re_op_compile(pTHX_ SV ** const patternp, int pat_count,\n\t\t    OP *expr, const regexp_engine* eng, REGEXP *old_re,\n\t\t     bool *is_bare_re, const U32 orig_rx_flags, const U32 pm_flags)\n{\n    dVAR;\n    REGEXP *Rx;         /* Capital 'R' means points to a REGEXP */\n    STRLEN plen;\n    char *exp;\n    regnode *scan;\n    I32 flags;\n    SSize_t minlen = 0;\n    U32 rx_flags;\n    SV *pat;\n    SV** new_patternp = patternp;\n\n    /* these are all flags - maybe they should be turned\n     * into a single int with different bit masks */\n    I32 sawlookahead = 0;\n    I32 sawplus = 0;\n    I32 sawopen = 0;\n    I32 sawminmod = 0;\n\n    regex_charset initial_charset = get_regex_charset(orig_rx_flags);\n    bool recompile = 0;\n    bool runtime_code = 0;\n    scan_data_t data;\n    RExC_state_t RExC_state;\n    RExC_state_t * const pRExC_state = &RExC_state;\n#ifdef TRIE_STUDY_OPT\n    int restudied = 0;\n    RExC_state_t copyRExC_state;\n#endif\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_RE_OP_COMPILE;\n\n    DEBUG_r(if (!PL_colorset) reginitcolors());\n\n    /* Initialize these here instead of as-needed, as is quick and avoids\n     * having to test them each time otherwise */\n    if (! PL_InBitmap) {\n#ifdef DEBUGGING\n        char * dump_len_string;\n#endif\n\n        /* This is calculated here, because the Perl program that generates the\n         * static global ones doesn't currently have access to\n         * NUM_ANYOF_CODE_POINTS */\n\tPL_InBitmap = _new_invlist(2);\n\tPL_InBitmap = _add_range_to_invlist(PL_InBitmap, 0,\n                                                    NUM_ANYOF_CODE_POINTS - 1);\n#ifdef DEBUGGING\n        dump_len_string = PerlEnv_getenv(\"PERL_DUMP_RE_MAX_LEN\");\n        if (   ! dump_len_string\n            || ! grok_atoUV(dump_len_string, (UV *)&PL_dump_re_max_len, NULL))\n        {\n            PL_dump_re_max_len = 60;    /* A reasonable default */\n        }\n#endif\n    }\n\n    pRExC_state->warn_text = NULL;\n    pRExC_state->unlexed_names = NULL;\n    pRExC_state->code_blocks = NULL;\n\n    if (is_bare_re)\n\t*is_bare_re = FALSE;\n\n    if (expr && (expr->op_type == OP_LIST ||\n\t\t(expr->op_type == OP_NULL && expr->op_targ == OP_LIST))) {\n\t/* allocate code_blocks if needed */\n\tOP *o;\n\tint ncode = 0;\n\n\tfor (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o))\n\t    if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL))\n\t\tncode++; /* count of DO blocks */\n\n\tif (ncode)\n            pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_ ncode);\n    }\n\n    if (!pat_count) {\n        /* compile-time pattern with just OP_CONSTs and DO blocks */\n\n        int n;\n        OP *o;\n\n        /* find how many CONSTs there are */\n        assert(expr);\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            n = 1;\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    n++;\n            }\n\n        /* fake up an SV array */\n\n        assert(!new_patternp);\n        Newx(new_patternp, n, SV*);\n        SAVEFREEPV(new_patternp);\n        pat_count = n;\n\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            new_patternp[n] = cSVOPx_sv(expr);\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    new_patternp[n++] = cSVOPo_sv;\n            }\n\n    }\n\n    DEBUG_PARSE_r(Perl_re_printf( aTHX_\n        \"Assembling pattern from %d elements%s\\n\", pat_count,\n            orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n    /* set expr to the first arg op */\n\n    if (pRExC_state->code_blocks && pRExC_state->code_blocks->count\n         && expr->op_type != OP_CONST)\n    {\n            expr = cLISTOPx(expr)->op_first;\n            assert(   expr->op_type == OP_PUSHMARK\n                   || (expr->op_type == OP_NULL && expr->op_targ == OP_PUSHMARK)\n                   || expr->op_type == OP_PADRANGE);\n            expr = OpSIBLING(expr);\n    }\n\n    pat = S_concat_pat(aTHX_ pRExC_state, NULL, new_patternp, pat_count,\n                        expr, &recompile, NULL);\n\n    /* handle bare (possibly after overloading) regex: foo =~ $re */\n    {\n        SV *re = pat;\n        if (SvROK(re))\n            re = SvRV(re);\n        if (SvTYPE(re) == SVt_REGEXP) {\n            if (is_bare_re)\n                *is_bare_re = TRUE;\n            SvREFCNT_inc(re);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_\n                \"Precompiled pattern%s\\n\",\n                    orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n            return (REGEXP*)re;\n        }\n    }\n\n    exp = SvPV_nomg(pat, plen);\n\n    if (!eng->op_comp) {\n\tif ((SvUTF8(pat) && IN_BYTES)\n\t\t|| SvGMAGICAL(pat) || SvAMAGIC(pat))\n\t{\n\t    /* make a temporary copy; either to convert to bytes,\n\t     * or to avoid repeating get-magic / overloaded stringify */\n\t    pat = newSVpvn_flags(exp, plen, SVs_TEMP |\n\t\t\t\t\t(IN_BYTES ? 0 : SvUTF8(pat)));\n\t}\n\treturn CALLREGCOMP_ENG(eng, pat, orig_rx_flags);\n    }\n\n    /* ignore the utf8ness if the pattern is 0 length */\n    RExC_utf8 = RExC_orig_utf8 = (plen == 0 || IN_BYTES) ? 0 : SvUTF8(pat);\n    RExC_uni_semantics = 0;\n    RExC_contains_locale = 0;\n    RExC_strict = cBOOL(pm_flags & RXf_PMf_STRICT);\n    RExC_in_script_run = 0;\n    RExC_study_started = 0;\n    pRExC_state->runtime_code_qr = NULL;\n    RExC_frame_head= NULL;\n    RExC_frame_last= NULL;\n    RExC_frame_count= 0;\n    RExC_latest_warn_offset = 0;\n    RExC_use_BRANCHJ = 0;\n    RExC_total_parens = 0;\n    RExC_open_parens = NULL;\n    RExC_close_parens = NULL;\n    RExC_paren_names = NULL;\n    RExC_size = 0;\n    RExC_seen_d_op = FALSE;\n#ifdef DEBUGGING\n    RExC_paren_name_list = NULL;\n#endif\n\n    DEBUG_r({\n        RExC_mysv1= sv_newmortal();\n        RExC_mysv2= sv_newmortal();\n    });\n\n    DEBUG_COMPILE_r({\n            SV *dsv= sv_newmortal();\n            RE_PV_QUOTED_DECL(s, RExC_utf8, dsv, exp, plen, PL_dump_re_max_len);\n            Perl_re_printf( aTHX_  \"%sCompiling REx%s %s\\n\",\n                          PL_colors[4], PL_colors[5], s);\n        });\n\n    /* we jump here if we have to recompile, e.g., from upgrading the pattern\n     * to utf8 */\n\n    if ((pm_flags & PMf_USE_RE_EVAL)\n\t\t/* this second condition covers the non-regex literal case,\n\t\t * i.e.  $foo =~ '(?{})'. */\n\t\t|| (IN_PERL_COMPILETIME && (PL_hints & HINT_RE_EVAL))\n    )\n\truntime_code = S_has_runtime_code(aTHX_ pRExC_state, exp, plen);\n\n  redo_parse:\n    /* return old regex if pattern hasn't changed */\n    /* XXX: note in the below we have to check the flags as well as the\n     * pattern.\n     *\n     * Things get a touch tricky as we have to compare the utf8 flag\n     * independently from the compile flags.  */\n\n    if (   old_re\n        && !recompile\n        && !!RX_UTF8(old_re) == !!RExC_utf8\n        && ( RX_COMPFLAGS(old_re) == ( orig_rx_flags & RXf_PMf_FLAGCOPYMASK ) )\n\t&& RX_PRECOMP(old_re)\n\t&& RX_PRELEN(old_re) == plen\n        && memEQ(RX_PRECOMP(old_re), exp, plen)\n\t&& !runtime_code /* with runtime code, always recompile */ )\n    {\n        return old_re;\n    }\n\n    /* Allocate the pattern's SV */\n    RExC_rx_sv = Rx = (REGEXP*) newSV_type(SVt_REGEXP);\n    RExC_rx = ReANY(Rx);\n    if ( RExC_rx == NULL )\n        FAIL(\"Regexp out of space\");\n\n    rx_flags = orig_rx_flags;\n\n    if (   (UTF || RExC_uni_semantics)\n        && initial_charset == REGEX_DEPENDS_CHARSET)\n    {\n\n\t/* Set to use unicode semantics if the pattern is in utf8 and has the\n\t * 'depends' charset specified, as it means unicode when utf8  */\n\tset_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);\n        RExC_uni_semantics = 1;\n    }\n\n    RExC_pm_flags = pm_flags;\n\n    if (runtime_code) {\n        assert(TAINTING_get || !TAINT_get);\n\tif (TAINT_get)\n\t    Perl_croak(aTHX_ \"Eval-group in insecure regular expression\");\n\n\tif (!S_compile_runtime_code(aTHX_ pRExC_state, exp, plen)) {\n\t    /* whoops, we have a non-utf8 pattern, whilst run-time code\n\t     * got compiled as utf8. Try again with a utf8 pattern */\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n                pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            goto redo_parse;\n\t}\n    }\n    assert(!pRExC_state->runtime_code_qr);\n\n    RExC_sawback = 0;\n\n    RExC_seen = 0;\n    RExC_maxlen = 0;\n    RExC_in_lookbehind = 0;\n    RExC_seen_zerolen = *exp == '^' ? -1 : 0;\n#ifdef EBCDIC\n    RExC_recode_x_to_native = 0;\n#endif\n    RExC_in_multi_char_class = 0;\n\n    RExC_start = RExC_copy_start_in_constructed = RExC_copy_start_in_input = RExC_precomp = exp;\n    RExC_precomp_end = RExC_end = exp + plen;\n    RExC_nestroot = 0;\n    RExC_whilem_seen = 0;\n    RExC_end_op = NULL;\n    RExC_recurse = NULL;\n    RExC_study_chunk_recursed = NULL;\n    RExC_study_chunk_recursed_bytes= 0;\n    RExC_recurse_count = 0;\n    pRExC_state->code_index = 0;\n\n    /* Initialize the string in the compiled pattern.  This is so that there is\n     * something to output if necessary */\n    set_regex_pv(pRExC_state, Rx);\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Starting parse and generation\\n\");\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n    /* Allocate space and zero-initialize. Note, the two step process\n       of zeroing when in debug mode, thus anything assigned has to\n       happen after that */\n    if (!  RExC_size) {\n\n        /* On the first pass of the parse, we guess how big this will be.  Then\n         * we grow in one operation to that amount and then give it back.  As\n         * we go along, we re-allocate what we need.\n         *\n         * XXX Currently the guess is essentially that the pattern will be an\n         * EXACT node with one byte input, one byte output.  This is crude, and\n         * better heuristics are welcome.\n         *\n         * On any subsequent passes, we guess what we actually computed in the\n         * latest earlier pass.  Such a pass probably didn't complete so is\n         * missing stuff.  We could improve those guesses by knowing where the\n         * parse stopped, and use the length so far plus apply the above\n         * assumption to what's left. */\n        RExC_size = STR_SZ(RExC_end - RExC_start);\n    }\n\n    Newxc(RExC_rxi, sizeof(regexp_internal) + RExC_size, char, regexp_internal);\n    if ( RExC_rxi == NULL )\n        FAIL(\"Regexp out of space\");\n\n    Zero(RExC_rxi, sizeof(regexp_internal) + RExC_size, char);\n    RXi_SET( RExC_rx, RExC_rxi );\n\n    /* We start from 0 (over from 0 in the case this is a reparse.  The first\n     * node parsed will give back any excess memory we have allocated so far).\n     * */\n    RExC_size = 0;\n\n    /* non-zero initialization begins here */\n    RExC_rx->engine= eng;\n    RExC_rx->extflags = rx_flags;\n    RXp_COMPFLAGS(RExC_rx) = orig_rx_flags & RXf_PMf_FLAGCOPYMASK;\n\n    if (pm_flags & PMf_IS_QR) {\n\tRExC_rxi->code_blocks = pRExC_state->code_blocks;\n        if (RExC_rxi->code_blocks) {\n            RExC_rxi->code_blocks->refcnt++;\n        }\n    }\n\n    RExC_rx->intflags = 0;\n\n    RExC_flags = rx_flags;\t/* don't let top level (?i) bleed */\n    RExC_parse = exp;\n\n    /* This NUL is guaranteed because the pattern comes from an SV*, and the sv\n     * code makes sure the final byte is an uncounted NUL.  But should this\n     * ever not be the case, lots of things could read beyond the end of the\n     * buffer: loops like\n     *      while(isFOO(*RExC_parse)) RExC_parse++;\n     *      strchr(RExC_parse, \"foo\");\n     * etc.  So it is worth noting. */\n    assert(*RExC_end == '\\0');\n\n    RExC_naughty = 0;\n    RExC_npar = 1;\n    RExC_parens_buf_size = 0;\n    RExC_emit_start = RExC_rxi->program;\n    pRExC_state->code_index = 0;\n\n    *((char*) RExC_emit_start) = (char) REG_MAGIC;\n    RExC_emit = 1;\n\n    /* Do the parse */\n    if (reg(pRExC_state, 0, &flags, 1)) {\n\n        /* Success!, But we may need to redo the parse knowing how many parens\n         * there actually are */\n        if (IN_PARENS_PASS) {\n            flags |= RESTART_PARSE;\n        }\n\n        /* We have that number in RExC_npar */\n        RExC_total_parens = RExC_npar;\n\n        /* XXX For backporting, use long jumps if there is any possibility of\n         * overflow */\n        if (RExC_size > U16_MAX && ! RExC_use_BRANCHJ) {\n            RExC_use_BRANCHJ = TRUE;\n            flags |= RESTART_PARSE;\n        }\n    }\n    else if (! MUST_RESTART(flags)) {\n\tReREFCNT_dec(Rx);\n        Perl_croak(aTHX_ \"panic: reg returned failure to re_op_compile, flags=%#\" UVxf, (UV) flags);\n    }\n\n    /* Here, we either have success, or we have to redo the parse for some reason */\n    if (MUST_RESTART(flags)) {\n\n        /* It's possible to write a regexp in ascii that represents Unicode\n        codepoints outside of the byte range, such as via \\x{100}. If we\n        detect such a sequence we have to convert the entire pattern to utf8\n        and then recompile, as our sizing calculation will have been based\n        on 1 byte == 1 character, but we will need to use utf8 to encode\n        at least some part of the pattern, and therefore must convert the whole\n        thing.\n        -- dmq */\n        if (flags & NEED_UTF8) {\n\n            /* We have stored the offset of the final warning output so far.\n             * That must be adjusted.  Any variant characters between the start\n             * of the pattern and this warning count for 2 bytes in the final,\n             * so just add them again */\n            if (UNLIKELY(RExC_latest_warn_offset > 0)) {\n                RExC_latest_warn_offset +=\n                            variant_under_utf8_count((U8 *) exp, (U8 *) exp\n                                                + RExC_latest_warn_offset);\n            }\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n            pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse after upgrade\\n\"));\n        }\n        else {\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse\\n\"));\n        }\n\n        if (ALL_PARENS_COUNTED) {\n            /* Make enough room for all the known parens, and zero it */\n            Renew(RExC_open_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_open_parens, RExC_total_parens, regnode_offset);\n            RExC_open_parens[0] = 1;    /* +1 for REG_MAGIC */\n\n            Renew(RExC_close_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_close_parens, RExC_total_parens, regnode_offset);\n        }\n        else { /* Parse did not complete.  Reinitialize the parentheses\n                  structures */\n            RExC_total_parens = 0;\n            if (RExC_open_parens) {\n                Safefree(RExC_open_parens);\n                RExC_open_parens = NULL;\n            }\n            if (RExC_close_parens) {\n                Safefree(RExC_close_parens);\n                RExC_close_parens = NULL;\n            }\n        }\n\n        /* Clean up what we did in this parse */\n        SvREFCNT_dec_NN(RExC_rx_sv);\n\n        goto redo_parse;\n    }\n\n    /* Here, we have successfully parsed and generated the pattern's program\n     * for the regex engine.  We are ready to finish things up and look for\n     * optimizations. */\n\n    /* Update the string to compile, with correct modifiers, etc */\n    set_regex_pv(pRExC_state, Rx);\n\n    RExC_rx->nparens = RExC_total_parens - 1;\n\n    /* Uses the upper 4 bits of the FLAGS field, so keep within that size */\n    if (RExC_whilem_seen > 15)\n        RExC_whilem_seen = 15;\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Required size %\" IVdf \" nodes\\n\", (IV)RExC_size);\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    DEBUG_OFFSETS_r(Perl_re_printf( aTHX_\n                          \"%s %\" UVuf \" bytes for offset annotations.\\n\",\n                          RExC_offsets ? \"Got\" : \"Couldn't get\",\n                          (UV)((RExC_offsets[0] * 2 + 1))));\n    DEBUG_OFFSETS_r(if (RExC_offsets) {\n        const STRLEN len = RExC_offsets[0];\n        STRLEN i;\n        GET_RE_DEBUG_FLAGS_DECL;\n        Perl_re_printf( aTHX_\n                      \"Offsets: [%\" UVuf \"]\\n\\t\", (UV)RExC_offsets[0]);\n        for (i = 1; i <= len; i++) {\n            if (RExC_offsets[i*2-1] || RExC_offsets[i*2])\n                Perl_re_printf( aTHX_  \"%\" UVuf \":%\" UVuf \"[%\" UVuf \"] \",\n                (UV)i, (UV)RExC_offsets[i*2-1], (UV)RExC_offsets[i*2]);\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    });\n\n#else\n    SetProgLen(RExC_rxi,RExC_size);\n#endif\n\n    DEBUG_OPTIMISE_r(\n        Perl_re_printf( aTHX_  \"Starting post parse optimization\\n\");\n    );\n\n    /* XXXX To minimize changes to RE engine we always allocate\n       3-units-long substrs field. */\n    Newx(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_recurse_count) {\n        Newx(RExC_recurse, RExC_recurse_count, regnode *);\n        SAVEFREEPV(RExC_recurse);\n    }\n\n    if (RExC_seen & REG_RECURSE_SEEN) {\n        /* Note, RExC_total_parens is 1 + the number of parens in a pattern.\n         * So its 1 if there are no parens. */\n        RExC_study_chunk_recursed_bytes= (RExC_total_parens >> 3) +\n                                         ((RExC_total_parens & 0x07) != 0);\n        Newx(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n        SAVEFREEPV(RExC_study_chunk_recursed);\n    }\n\n  reStudy:\n    RExC_rx->minlen = minlen = sawlookahead = sawplus = sawopen = sawminmod = 0;\n    DEBUG_r(\n        RExC_study_chunk_recursed_count= 0;\n    );\n    Zero(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_study_chunk_recursed) {\n        Zero(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n    }\n\n\n#ifdef TRIE_STUDY_OPT\n    if (!restudied) {\n        StructCopy(&zero_scan_data, &data, scan_data_t);\n        copyRExC_state = RExC_state;\n    } else {\n        U32 seen=RExC_seen;\n        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"Restudying\\n\"));\n\n        RExC_state = copyRExC_state;\n        if (seen & REG_TOP_LEVEL_BRANCHES_SEEN)\n            RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;\n        else\n            RExC_seen &= ~REG_TOP_LEVEL_BRANCHES_SEEN;\n\tStructCopy(&zero_scan_data, &data, scan_data_t);\n    }\n#else\n    StructCopy(&zero_scan_data, &data, scan_data_t);\n#endif\n\n    /* Dig out information for optimizations. */\n    RExC_rx->extflags = RExC_flags; /* was pm_op */\n    /*dmq: removed as part of de-PMOP: pm->op_pmflags = RExC_flags; */\n\n    if (UTF)\n\tSvUTF8_on(Rx);\t/* Unicode in it? */\n    RExC_rxi->regstclass = NULL;\n    if (RExC_naughty >= TOO_NAUGHTY)\t/* Probably an expensive pattern. */\n\tRExC_rx->intflags |= PREGf_NAUGHTY;\n    scan = RExC_rxi->program + 1;\t\t/* First BRANCH. */\n\n    /* testing for BRANCH here tells us whether there is \"must appear\"\n       data in the pattern. If there is then we can use it for optimisations */\n    if (!(RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)) { /*  Only one top-level choice.\n                                                  */\n\tSSize_t fake;\n\tSTRLEN longest_length[2];\n\tregnode_ssc ch_class; /* pointed to by data */\n\tint stclass_flag;\n\tSSize_t last_close = 0; /* pointed to by data */\n        regnode *first= scan;\n        regnode *first_next= regnext(first);\n        int i;\n\n\t/*\n\t * Skip introductions and multiplicators >= 1\n\t * so that we can extract the 'meat' of the pattern that must\n\t * match in the large if() sequence following.\n\t * NOTE that EXACT is NOT covered here, as it is normally\n\t * picked up by the optimiser separately.\n\t *\n\t * This is unfortunate as the optimiser isnt handling lookahead\n\t * properly currently.\n\t *\n\t */\n\twhile ((OP(first) == OPEN && (sawopen = 1)) ||\n\t       /* An OR of *one* alternative - should not happen now. */\n\t    (OP(first) == BRANCH && OP(first_next) != BRANCH) ||\n\t    /* for now we can't handle lookbehind IFMATCH*/\n\t    (OP(first) == IFMATCH && !first->flags && (sawlookahead = 1)) ||\n\t    (OP(first) == PLUS) ||\n\t    (OP(first) == MINMOD) ||\n\t       /* An {n,m} with n>0 */\n\t    (PL_regkind[OP(first)] == CURLY && ARG1(first) > 0) ||\n\t    (OP(first) == NOTHING && PL_regkind[OP(first_next)] != END ))\n\t{\n\t\t/*\n\t\t * the only op that could be a regnode is PLUS, all the rest\n\t\t * will be regnode_1 or regnode_2.\n\t\t *\n                 * (yves doesn't think this is true)\n\t\t */\n\t\tif (OP(first) == PLUS)\n\t\t    sawplus = 1;\n                else {\n                    if (OP(first) == MINMOD)\n                        sawminmod = 1;\n\t\t    first += regarglen[OP(first)];\n                }\n\t\tfirst = NEXTOPER(first);\n\t\tfirst_next= regnext(first);\n\t}\n\n\t/* Starting-point info. */\n      again:\n        DEBUG_PEEP(\"first:\", first, 0, 0);\n        /* Ignore EXACT as we deal with it later. */\n\tif (PL_regkind[OP(first)] == EXACT) {\n\t    if (   OP(first) == EXACT\n                || OP(first) == EXACT_ONLY8\n                || OP(first) == EXACTL)\n            {\n\t\tNOOP;\t/* Empty, get anchored substr later. */\n            }\n\t    else\n\t\tRExC_rxi->regstclass = first;\n\t}\n#ifdef TRIE_STCLASS\n\telse if (PL_regkind[OP(first)] == TRIE &&\n\t        ((reg_trie_data *)RExC_rxi->data->data[ ARG(first) ])->minlen>0)\n\t{\n            /* this can happen only on restudy */\n            RExC_rxi->regstclass = construct_ahocorasick_from_trie(pRExC_state, (regnode *)first, 0);\n\t}\n#endif\n\telse if (REGNODE_SIMPLE(OP(first)))\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOUND ||\n\t\t PL_regkind[OP(first)] == NBOUND)\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOL) {\n            RExC_rx->intflags |= (OP(first) == MBOL\n                           ? PREGf_ANCH_MBOL\n                           : PREGf_ANCH_SBOL);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if (OP(first) == GPOS) {\n            RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if ((!sawopen || !RExC_sawback) &&\n            !sawlookahead &&\n\t    (OP(first) == STAR &&\n\t    PL_regkind[OP(NEXTOPER(first))] == REG_ANY) &&\n            !(RExC_rx->intflags & PREGf_ANCH) && !pRExC_state->code_blocks)\n\t{\n\t    /* turn .* into ^.* with an implied $*=1 */\n\t    const int type =\n\t\t(OP(NEXTOPER(first)) == REG_ANY)\n                    ? PREGf_ANCH_MBOL\n                    : PREGf_ANCH_SBOL;\n            RExC_rx->intflags |= (type | PREGf_IMPLICIT);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n        if (sawplus && !sawminmod && !sawlookahead\n            && (!sawopen || !RExC_sawback)\n\t    && !pRExC_state->code_blocks) /* May examine pos and $& */\n\t    /* x+ must match at the 1st pos of run of x's */\n\t    RExC_rx->intflags |= PREGf_SKIP;\n\n\t/* Scan is after the zeroth branch, first is atomic matcher. */\n#ifdef TRIE_STUDY_OPT\n\tDEBUG_PARSE_r(\n\t    if (!restudied)\n                Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t\t\t      (IV)(first - scan + 1))\n        );\n#else\n\tDEBUG_PARSE_r(\n            Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t        (IV)(first - scan + 1))\n        );\n#endif\n\n\n\t/*\n\t* If there's something expensive in the r.e., find the\n\t* longest literal string that must appear and make it the\n\t* regmust.  Resolve ties in favor of later strings, since\n\t* the regstart check works with the beginning of the r.e.\n\t* and avoiding duplication strengthens checking.  Not a\n\t* strong reason, but sufficient in the absence of others.\n\t* [Now we resolve ties in favor of the earlier string if\n\t* it happens that c_offset_min has been invalidated, since the\n\t* earlier string may buy us something the later one won't.]\n\t*/\n\n\tdata.substrs[0].str = newSVpvs(\"\");\n\tdata.substrs[1].str = newSVpvs(\"\");\n\tdata.last_found = newSVpvs(\"\");\n\tdata.cur_is_floating = 0; /* initially any found substring is fixed */\n\tENTER_with_name(\"study_chunk\");\n\tSAVEFREESV(data.substrs[0].str);\n\tSAVEFREESV(data.substrs[1].str);\n\tSAVEFREESV(data.last_found);\n\tfirst = scan;\n\tif (!RExC_rxi->regstclass) {\n\t    ssc_init(pRExC_state, &ch_class);\n\t    data.start_class = &ch_class;\n\t    stclass_flag = SCF_DO_STCLASS_AND;\n\t} else\t\t\t\t/* XXXX Check for BOUND? */\n\t    stclass_flag = 0;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/PATTERN/\n         * (NO top level branches)\n         */\n\tminlen = study_chunk(pRExC_state, &first, &minlen, &fake,\n                             scan + RExC_size, /* Up to end */\n            &data, -1, 0, NULL,\n            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag\n                          | (restudied ? SCF_TRIE_DOING_RESTUDY : 0),\n            0);\n\n\n        CHECK_RESTUDY_GOTO_butfirst(LEAVE_with_name(\"study_chunk\"));\n\n\n\tif ( RExC_total_parens == 1 && !data.cur_is_floating\n\t     && data.last_start_min == 0 && data.last_end > 0\n\t     && !RExC_seen_zerolen\n             && !(RExC_seen & REG_VERBARG_SEEN)\n             && !(RExC_seen & REG_GPOS_SEEN)\n        ){\n\t    RExC_rx->extflags |= RXf_CHECK_ALL;\n        }\n\tscan_commit(pRExC_state, &data,&minlen, 0);\n\n\n        /* XXX this is done in reverse order because that's the way the\n         * code was before it was parameterised. Don't know whether it\n         * actually needs doing in reverse order. DAPM */\n        for (i = 1; i >= 0; i--) {\n            longest_length[i] = CHR_SVLEN(data.substrs[i].str);\n\n            if (   !(   i\n                     && SvCUR(data.substrs[0].str)  /* ok to leave SvCUR */\n                     &&    data.substrs[0].min_offset\n                        == data.substrs[1].min_offset\n                     &&    SvCUR(data.substrs[0].str)\n                        == SvCUR(data.substrs[1].str)\n                    )\n                && S_setup_longest (aTHX_ pRExC_state,\n                                        &(RExC_rx->substrs->data[i]),\n                                        &(data.substrs[i]),\n                                        longest_length[i]))\n            {\n                RExC_rx->substrs->data[i].min_offset =\n                        data.substrs[i].min_offset - data.substrs[i].lookbehind;\n\n                RExC_rx->substrs->data[i].max_offset = data.substrs[i].max_offset;\n                /* Don't offset infinity */\n                if (data.substrs[i].max_offset < SSize_t_MAX)\n                    RExC_rx->substrs->data[i].max_offset -= data.substrs[i].lookbehind;\n                SvREFCNT_inc_simple_void_NN(data.substrs[i].str);\n            }\n            else {\n                RExC_rx->substrs->data[i].substr      = NULL;\n                RExC_rx->substrs->data[i].utf8_substr = NULL;\n                longest_length[i] = 0;\n            }\n        }\n\n\tLEAVE_with_name(\"study_chunk\");\n\n\tif (RExC_rxi->regstclass\n\t    && (OP(RExC_rxi->regstclass) == REG_ANY || OP(RExC_rxi->regstclass) == SANY))\n\t    RExC_rxi->regstclass = NULL;\n\n\tif ((!(RExC_rx->substrs->data[0].substr || RExC_rx->substrs->data[0].utf8_substr)\n              || RExC_rx->substrs->data[0].min_offset)\n\t    && stclass_flag\n            && ! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n\t{\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV *sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n\n        /* A temporary algorithm prefers floated substr to fixed one of\n         * same length to dig more info. */\n\ti = (longest_length[0] <= longest_length[1]);\n        RExC_rx->substrs->check_ix = i;\n        RExC_rx->check_end_shift  = RExC_rx->substrs->data[i].end_shift;\n        RExC_rx->check_substr     = RExC_rx->substrs->data[i].substr;\n        RExC_rx->check_utf8       = RExC_rx->substrs->data[i].utf8_substr;\n        RExC_rx->check_offset_min = RExC_rx->substrs->data[i].min_offset;\n        RExC_rx->check_offset_max = RExC_rx->substrs->data[i].max_offset;\n        if (!i && (RExC_rx->intflags & (PREGf_ANCH_SBOL|PREGf_ANCH_GPOS)))\n            RExC_rx->intflags |= PREGf_NOSCAN;\n\n\tif ((RExC_rx->check_substr || RExC_rx->check_utf8) ) {\n\t    RExC_rx->extflags |= RXf_USE_INTUIT;\n\t    if (SvTAIL(RExC_rx->check_substr ? RExC_rx->check_substr : RExC_rx->check_utf8))\n\t\tRExC_rx->extflags |= RXf_INTUIT_TAIL;\n\t}\n\n\t/* XXX Unneeded? dmq (shouldn't as this is handled elsewhere)\n\tif ( (STRLEN)minlen < longest_length[1] )\n            minlen= longest_length[1];\n        if ( (STRLEN)minlen < longest_length[0] )\n            minlen= longest_length[0];\n        */\n    }\n    else {\n\t/* Several toplevels. Best we can is to set minlen. */\n\tSSize_t fake;\n\tregnode_ssc ch_class;\n\tSSize_t last_close = 0;\n\n        DEBUG_PARSE_r(Perl_re_printf( aTHX_  \"\\nMulti Top Level\\n\"));\n\n\tscan = RExC_rxi->program + 1;\n\tssc_init(pRExC_state, &ch_class);\n\tdata.start_class = &ch_class;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/P1|P2|.../\n         * (patterns WITH top level branches)\n         */\n\tminlen = study_chunk(pRExC_state,\n            &scan, &minlen, &fake, scan + RExC_size, &data, -1, 0, NULL,\n            SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS|(restudied\n                                                      ? SCF_TRIE_DOING_RESTUDY\n                                                      : 0),\n            0);\n\n        CHECK_RESTUDY_GOTO_butfirst(NOOP);\n\n\tRExC_rx->check_substr = NULL;\n        RExC_rx->check_utf8 = NULL;\n        RExC_rx->substrs->data[0].substr      = NULL;\n        RExC_rx->substrs->data[0].utf8_substr = NULL;\n        RExC_rx->substrs->data[1].substr      = NULL;\n        RExC_rx->substrs->data[1].utf8_substr = NULL;\n\n        if (! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n        {\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV* sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n    }\n\n    if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN) {\n        RExC_rx->extflags |= RXf_UNBOUNDED_QUANTIFIER_SEEN;\n        RExC_rx->maxlen = REG_INFTY;\n    }\n    else {\n        RExC_rx->maxlen = RExC_maxlen;\n    }\n\n    /* Guard against an embedded (?=) or (?<=) with a longer minlen than\n       the \"real\" pattern. */\n    DEBUG_OPTIMISE_r({\n        Perl_re_printf( aTHX_ \"minlen: %\" IVdf \" RExC_rx->minlen:%\" IVdf \" maxlen:%\" IVdf \"\\n\",\n                      (IV)minlen, (IV)RExC_rx->minlen, (IV)RExC_maxlen);\n    });\n    RExC_rx->minlenret = minlen;\n    if (RExC_rx->minlen < minlen)\n        RExC_rx->minlen = minlen;\n\n    if (RExC_seen & REG_RECURSE_SEEN ) {\n        RExC_rx->intflags |= PREGf_RECURSE_SEEN;\n        Newx(RExC_rx->recurse_locinput, RExC_rx->nparens + 1, char *);\n    }\n    if (RExC_seen & REG_GPOS_SEEN)\n        RExC_rx->intflags |= PREGf_GPOS_SEEN;\n    if (RExC_seen & REG_LOOKBEHIND_SEEN)\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* inplace might break the\n                                                lookbehind */\n    if (pRExC_state->code_blocks)\n\tRExC_rx->extflags |= RXf_EVAL_SEEN;\n    if (RExC_seen & REG_VERBARG_SEEN)\n    {\n\tRExC_rx->intflags |= PREGf_VERBARG_SEEN;\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* don't understand this! Yves */\n    }\n    if (RExC_seen & REG_CUTGROUP_SEEN)\n\tRExC_rx->intflags |= PREGf_CUTGROUP_SEEN;\n    if (pm_flags & PMf_USE_RE_EVAL)\n\tRExC_rx->intflags |= PREGf_USE_RE_EVAL;\n    if (RExC_paren_names)\n        RXp_PAREN_NAMES(RExC_rx) = MUTABLE_HV(SvREFCNT_inc(RExC_paren_names));\n    else\n        RXp_PAREN_NAMES(RExC_rx) = NULL;\n\n    /* If we have seen an anchor in our pattern then we set the extflag RXf_IS_ANCHORED\n     * so it can be used in pp.c */\n    if (RExC_rx->intflags & PREGf_ANCH)\n        RExC_rx->extflags |= RXf_IS_ANCHORED;\n\n\n    {\n        /* this is used to identify \"special\" patterns that might result\n         * in Perl NOT calling the regex engine and instead doing the match \"itself\",\n         * particularly special cases in split//. By having the regex compiler\n         * do this pattern matching at a regop level (instead of by inspecting the pattern)\n         * we avoid weird issues with equivalent patterns resulting in different behavior,\n         * AND we allow non Perl engines to get the same optimizations by the setting the\n         * flags appropriately - Yves */\n        regnode *first = RExC_rxi->program + 1;\n        U8 fop = OP(first);\n        regnode *next = regnext(first);\n        U8 nop = OP(next);\n\n        if (PL_regkind[fop] == NOTHING && nop == END)\n            RExC_rx->extflags |= RXf_NULL;\n        else if ((fop == MBOL || (fop == SBOL && !first->flags)) && nop == END)\n            /* when fop is SBOL first->flags will be true only when it was\n             * produced by parsing /\\A/, and not when parsing /^/. This is\n             * very important for the split code as there we want to\n             * treat /^/ as /^/m, but we do not want to treat /\\A/ as /^/m.\n             * See rt #122761 for more details. -- Yves */\n            RExC_rx->extflags |= RXf_START_ONLY;\n        else if (fop == PLUS\n                 && PL_regkind[nop] == POSIXD && FLAGS(next) == _CC_SPACE\n                 && nop == END)\n            RExC_rx->extflags |= RXf_WHITE;\n        else if ( RExC_rx->extflags & RXf_SPLIT\n                  && (fop == EXACT || fop == EXACT_ONLY8 || fop == EXACTL)\n                  && STR_LEN(first) == 1\n                  && *(STRING(first)) == ' '\n                  && nop == END )\n            RExC_rx->extflags |= (RXf_SKIPWHITE|RXf_WHITE);\n\n    }\n\n    if (RExC_contains_locale) {\n        RXp_EXTFLAGS(RExC_rx) |= RXf_TAINTED;\n    }\n\n#ifdef DEBUGGING\n    if (RExC_paren_names) {\n        RExC_rxi->name_list_idx = add_data( pRExC_state, STR_WITH_LEN(\"a\"));\n        RExC_rxi->data->data[RExC_rxi->name_list_idx]\n                                   = (void*)SvREFCNT_inc(RExC_paren_name_list);\n    } else\n#endif\n    RExC_rxi->name_list_idx = 0;\n\n    while ( RExC_recurse_count > 0 ) {\n        const regnode *scan = RExC_recurse[ --RExC_recurse_count ];\n        /*\n         * This data structure is set up in study_chunk() and is used\n         * to calculate the distance between a GOSUB regopcode and\n         * the OPEN/CURLYM (CURLYM's are special and can act like OPEN's)\n         * it refers to.\n         *\n         * If for some reason someone writes code that optimises\n         * away a GOSUB opcode then the assert should be changed to\n         * an if(scan) to guard the ARG2L_SET() - Yves\n         *\n         */\n        assert(scan && OP(scan) == GOSUB);\n        ARG2L_SET( scan, RExC_open_parens[ARG(scan)] - REGNODE_OFFSET(scan));\n    }\n\n    Newxz(RExC_rx->offs, RExC_total_parens, regexp_paren_pair);\n    /* assume we don't need to swap parens around before we match */\n    DEBUG_TEST_r({\n        Perl_re_printf( aTHX_ \"study_chunk_recursed_count: %lu\\n\",\n            (unsigned long)RExC_study_chunk_recursed_count);\n    });\n    DEBUG_DUMP_r({\n        DEBUG_RExC_seen();\n        Perl_re_printf( aTHX_ \"Final program:\\n\");\n        regdump(RExC_rx);\n    });\n\n    if (RExC_open_parens) {\n        Safefree(RExC_open_parens);\n        RExC_open_parens = NULL;\n    }\n    if (RExC_close_parens) {\n        Safefree(RExC_close_parens);\n        RExC_close_parens = NULL;\n    }\n\n#ifdef USE_ITHREADS\n    /* under ithreads the ?pat? PMf_USED flag on the pmop is simulated\n     * by setting the regexp SV to readonly-only instead. If the\n     * pattern's been recompiled, the USEDness should remain. */\n    if (old_re && SvREADONLY(old_re))\n        SvREADONLY_on(Rx);\n#endif\n    return Rx;\n}\n\n\nSV*\nPerl_reg_named_buff(pTHX_ REGEXP * const rx, SV * const key, SV * const value,\n                    const U32 flags)\n{\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF;\n\n    PERL_UNUSED_ARG(value);\n\n    if (flags & RXapif_FETCH) {\n        return reg_named_buff_fetch(rx, key, flags);\n    } else if (flags & (RXapif_STORE | RXapif_DELETE | RXapif_CLEAR)) {\n        Perl_croak_no_modify();\n        return NULL;\n    } else if (flags & RXapif_EXISTS) {\n        return reg_named_buff_exists(rx, key, flags)\n            ? &PL_sv_yes\n            : &PL_sv_no;\n    } else if (flags & RXapif_REGNAMES) {\n        return reg_named_buff_all(rx, flags);\n    } else if (flags & (RXapif_SCALAR | RXapif_REGNAMES_COUNT)) {\n        return reg_named_buff_scalar(rx, flags);\n    } else {\n        Perl_croak(aTHX_ \"panic: Unknown flags %d in named_buff\", (int)flags);\n        return NULL;\n    }\n}\n\nSV*\nPerl_reg_named_buff_iter(pTHX_ REGEXP * const rx, const SV * const lastkey,\n                         const U32 flags)\n{\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_ITER;\n    PERL_UNUSED_ARG(lastkey);\n\n    if (flags & RXapif_FIRSTKEY)\n        return reg_named_buff_firstkey(rx, flags);\n    else if (flags & RXapif_NEXTKEY)\n        return reg_named_buff_nextkey(rx, flags);\n    else {\n        Perl_croak(aTHX_ \"panic: Unknown flags %d in named_buff_iter\",\n                                            (int)flags);\n        return NULL;\n    }\n}\n\nSV*\nPerl_reg_named_buff_fetch(pTHX_ REGEXP * const r, SV * const namesv,\n\t\t\t  const U32 flags)\n{\n    SV *ret;\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_FETCH;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HE *he_str = hv_fetch_ent( RXp_PAREN_NAMES(rx), namesv, 0, 0 );\n        if (he_str) {\n            IV i;\n            SV* sv_dat=HeVAL(he_str);\n            I32 *nums=(I32*)SvPVX(sv_dat);\n            AV * const retarray = (flags & RXapif_ALL) ? newAV() : NULL;\n            for ( i=0; i<SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->nparens) >= nums[i]\n                    && rx->offs[nums[i]].start != -1\n                    && rx->offs[nums[i]].end != -1)\n                {\n                    ret = newSVpvs(\"\");\n                    CALLREG_NUMBUF_FETCH(r, nums[i], ret);\n                    if (!retarray)\n                        return ret;\n                } else {\n                    if (retarray)\n                        ret = newSVsv(&PL_sv_undef);\n                }\n                if (retarray)\n                    av_push(retarray, ret);\n            }\n            if (retarray)\n                return newRV_noinc(MUTABLE_SV(retarray));\n        }\n    }\n    return NULL;\n}\n\nbool\nPerl_reg_named_buff_exists(pTHX_ REGEXP * const r, SV * const key,\n                           const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_EXISTS;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        if (flags & RXapif_ALL) {\n            return hv_exists_ent(RXp_PAREN_NAMES(rx), key, 0);\n        } else {\n\t    SV *sv = CALLREG_NAMED_BUFF_FETCH(r, key, flags);\n            if (sv) {\n\t\tSvREFCNT_dec_NN(sv);\n                return TRUE;\n            } else {\n                return FALSE;\n            }\n        }\n    } else {\n        return FALSE;\n    }\n}\n\nSV*\nPerl_reg_named_buff_firstkey(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_FIRSTKEY;\n\n    if ( rx && RXp_PAREN_NAMES(rx) ) {\n\t(void)hv_iterinit(RXp_PAREN_NAMES(rx));\n\n\treturn CALLREG_NAMED_BUFF_NEXTKEY(r, NULL, flags & ~RXapif_FIRSTKEY);\n    } else {\n\treturn FALSE;\n    }\n}\n\nSV*\nPerl_reg_named_buff_nextkey(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_NEXTKEY;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HV *hv = RXp_PAREN_NAMES(rx);\n        HE *temphe;\n        while ( (temphe = hv_iternext_flags(hv, 0)) ) {\n            IV i;\n            IV parno = 0;\n            SV* sv_dat = HeVAL(temphe);\n            I32 *nums = (I32*)SvPVX(sv_dat);\n            for ( i = 0; i < SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->lastparen) >= nums[i] &&\n                    rx->offs[nums[i]].start != -1 &&\n                    rx->offs[nums[i]].end != -1)\n                {\n                    parno = nums[i];\n                    break;\n                }\n            }\n            if (parno || flags & RXapif_ALL) {\n\t\treturn newSVhek(HeKEY_hek(temphe));\n            }\n        }\n    }\n    return NULL;\n}\n\nSV*\nPerl_reg_named_buff_scalar(pTHX_ REGEXP * const r, const U32 flags)\n{\n    SV *ret;\n    AV *av;\n    SSize_t length;\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_SCALAR;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        if (flags & (RXapif_ALL | RXapif_REGNAMES_COUNT)) {\n            return newSViv(HvTOTALKEYS(RXp_PAREN_NAMES(rx)));\n        } else if (flags & RXapif_ONE) {\n            ret = CALLREG_NAMED_BUFF_ALL(r, (flags | RXapif_REGNAMES));\n            av = MUTABLE_AV(SvRV(ret));\n            length = av_tindex(av);\n\t    SvREFCNT_dec_NN(ret);\n            return newSViv(length + 1);\n        } else {\n            Perl_croak(aTHX_ \"panic: Unknown flags %d in named_buff_scalar\",\n                                                (int)flags);\n            return NULL;\n        }\n    }\n    return &PL_sv_undef;\n}\n\nSV*\nPerl_reg_named_buff_all(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n    AV *av = newAV();\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_ALL;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HV *hv= RXp_PAREN_NAMES(rx);\n        HE *temphe;\n        (void)hv_iterinit(hv);\n        while ( (temphe = hv_iternext_flags(hv, 0)) ) {\n            IV i;\n            IV parno = 0;\n            SV* sv_dat = HeVAL(temphe);\n            I32 *nums = (I32*)SvPVX(sv_dat);\n            for ( i = 0; i < SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->lastparen) >= nums[i] &&\n                    rx->offs[nums[i]].start != -1 &&\n                    rx->offs[nums[i]].end != -1)\n                {\n                    parno = nums[i];\n                    break;\n                }\n            }\n            if (parno || flags & RXapif_ALL) {\n                av_push(av, newSVhek(HeKEY_hek(temphe)));\n            }\n        }\n    }\n\n    return newRV_noinc(MUTABLE_SV(av));\n}\n\nvoid\nPerl_reg_numbered_buff_fetch(pTHX_ REGEXP * const r, const I32 paren,\n\t\t\t     SV * const sv)\n{\n    struct regexp *const rx = ReANY(r);\n    char *s = NULL;\n    SSize_t i = 0;\n    SSize_t s1, t1;\n    I32 n = paren;\n\n    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_FETCH;\n\n    if (      n == RX_BUFF_IDX_CARET_PREMATCH\n           || n == RX_BUFF_IDX_CARET_FULLMATCH\n           || n == RX_BUFF_IDX_CARET_POSTMATCH\n       )\n    {\n        bool keepcopy = cBOOL(rx->extflags & RXf_PMf_KEEPCOPY);\n        if (!keepcopy) {\n            /* on something like\n             *    $r = qr/.../;\n             *    /$qr/p;\n             * the KEEPCOPY is set on the PMOP rather than the regex */\n            if (PL_curpm && r == PM_GETRE(PL_curpm))\n                 keepcopy = cBOOL(PL_curpm->op_pmflags & PMf_KEEPCOPY);\n        }\n        if (!keepcopy)\n            goto ret_undef;\n    }\n\n    if (!rx->subbeg)\n        goto ret_undef;\n\n    if (n == RX_BUFF_IDX_CARET_FULLMATCH)\n        /* no need to distinguish between them any more */\n        n = RX_BUFF_IDX_FULLMATCH;\n\n    if ((n == RX_BUFF_IDX_PREMATCH || n == RX_BUFF_IDX_CARET_PREMATCH)\n        && rx->offs[0].start != -1)\n    {\n        /* $`, ${^PREMATCH} */\n\ti = rx->offs[0].start;\n\ts = rx->subbeg;\n    }\n    else\n    if ((n == RX_BUFF_IDX_POSTMATCH || n == RX_BUFF_IDX_CARET_POSTMATCH)\n        && rx->offs[0].end != -1)\n    {\n        /* $', ${^POSTMATCH} */\n\ts = rx->subbeg - rx->suboffset + rx->offs[0].end;\n\ti = rx->sublen + rx->suboffset - rx->offs[0].end;\n    }\n    else\n    if ( 0 <= n && n <= (I32)rx->nparens &&\n        (s1 = rx->offs[n].start) != -1 &&\n        (t1 = rx->offs[n].end) != -1)\n    {\n        /* $&, ${^MATCH},  $1 ... */\n        i = t1 - s1;\n        s = rx->subbeg + s1 - rx->suboffset;\n    } else {\n        goto ret_undef;\n    }\n\n    assert(s >= rx->subbeg);\n    assert((STRLEN)rx->sublen >= (STRLEN)((s - rx->subbeg) + i) );\n    if (i >= 0) {\n#ifdef NO_TAINT_SUPPORT\n        sv_setpvn(sv, s, i);\n#else\n        const int oldtainted = TAINT_get;\n        TAINT_NOT;\n        sv_setpvn(sv, s, i);\n        TAINT_set(oldtainted);\n#endif\n        if (RXp_MATCH_UTF8(rx))\n            SvUTF8_on(sv);\n        else\n            SvUTF8_off(sv);\n        if (TAINTING_get) {\n            if (RXp_MATCH_TAINTED(rx)) {\n                if (SvTYPE(sv) >= SVt_PVMG) {\n                    MAGIC* const mg = SvMAGIC(sv);\n                    MAGIC* mgt;\n                    TAINT;\n                    SvMAGIC_set(sv, mg->mg_moremagic);\n                    SvTAINT(sv);\n                    if ((mgt = SvMAGIC(sv))) {\n                        mg->mg_moremagic = mgt;\n                        SvMAGIC_set(sv, mg);\n                    }\n                } else {\n                    TAINT;\n                    SvTAINT(sv);\n                }\n            } else\n                SvTAINTED_off(sv);\n        }\n    } else {\n      ret_undef:\n        sv_set_undef(sv);\n        return;\n    }\n}\n\nvoid\nPerl_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren,\n\t\t\t\t\t\t\t SV const * const value)\n{\n    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_STORE;\n\n    PERL_UNUSED_ARG(rx);\n    PERL_UNUSED_ARG(paren);\n    PERL_UNUSED_ARG(value);\n\n    if (!PL_localizing)\n        Perl_croak_no_modify();\n}\n\nI32\nPerl_reg_numbered_buff_length(pTHX_ REGEXP * const r, const SV * const sv,\n                              const I32 paren)\n{\n    struct regexp *const rx = ReANY(r);\n    I32 i;\n    I32 s1, t1;\n\n    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_LENGTH;\n\n    if (   paren == RX_BUFF_IDX_CARET_PREMATCH\n        || paren == RX_BUFF_IDX_CARET_FULLMATCH\n        || paren == RX_BUFF_IDX_CARET_POSTMATCH\n    )\n    {\n        bool keepcopy = cBOOL(rx->extflags & RXf_PMf_KEEPCOPY);\n        if (!keepcopy) {\n            /* on something like\n             *    $r = qr/.../;\n             *    /$qr/p;\n             * the KEEPCOPY is set on the PMOP rather than the regex */\n            if (PL_curpm && r == PM_GETRE(PL_curpm))\n                 keepcopy = cBOOL(PL_curpm->op_pmflags & PMf_KEEPCOPY);\n        }\n        if (!keepcopy)\n            goto warn_undef;\n    }\n\n    /* Some of this code was originally in C<Perl_magic_len> in F<mg.c> */\n    switch (paren) {\n      case RX_BUFF_IDX_CARET_PREMATCH: /* ${^PREMATCH} */\n      case RX_BUFF_IDX_PREMATCH:       /* $` */\n        if (rx->offs[0].start != -1) {\n\t\t\ti = rx->offs[0].start;\n\t\t\tif (i > 0) {\n\t\t\t\ts1 = 0;\n\t\t\t\tt1 = i;\n\t\t\t\tgoto getlen;\n\t\t\t}\n\t    }\n        return 0;\n\n      case RX_BUFF_IDX_CARET_POSTMATCH: /* ${^POSTMATCH} */\n      case RX_BUFF_IDX_POSTMATCH:       /* $' */\n\t    if (rx->offs[0].end != -1) {\n\t\t\ti = rx->sublen - rx->offs[0].end;\n\t\t\tif (i > 0) {\n\t\t\t\ts1 = rx->offs[0].end;\n\t\t\t\tt1 = rx->sublen;\n\t\t\t\tgoto getlen;\n\t\t\t}\n\t    }\n        return 0;\n\n      default: /* $& / ${^MATCH}, $1, $2, ... */\n\t    if (paren <= (I32)rx->nparens &&\n            (s1 = rx->offs[paren].start) != -1 &&\n            (t1 = rx->offs[paren].end) != -1)\n\t    {\n            i = t1 - s1;\n            goto getlen;\n        } else {\n          warn_undef:\n            if (ckWARN(WARN_UNINITIALIZED))\n                report_uninit((const SV *)sv);\n            return 0;\n        }\n    }\n  getlen:\n    if (i > 0 && RXp_MATCH_UTF8(rx)) {\n        const char * const s = rx->subbeg - rx->suboffset + s1;\n        const U8 *ep;\n        STRLEN el;\n\n        i = t1 - s1;\n        if (is_utf8_string_loclen((U8*)s, i, &ep, &el))\n\t\t\ti = el;\n    }\n    return i;\n}\n\nSV*\nPerl_reg_qr_package(pTHX_ REGEXP * const rx)\n{\n    PERL_ARGS_ASSERT_REG_QR_PACKAGE;\n\tPERL_UNUSED_ARG(rx);\n\tif (0)\n\t    return NULL;\n\telse\n\t    return newSVpvs(\"Regexp\");\n}\n\n/* Scans the name of a named buffer from the pattern.\n * If flags is REG_RSN_RETURN_NULL returns null.\n * If flags is REG_RSN_RETURN_NAME returns an SV* containing the name\n * If flags is REG_RSN_RETURN_DATA returns the data SV* corresponding\n * to the parsed name as looked up in the RExC_paren_names hash.\n * If there is an error throws a vFAIL().. type exception.\n */\n\n#define REG_RSN_RETURN_NULL    0\n#define REG_RSN_RETURN_NAME    1\n#define REG_RSN_RETURN_DATA    2\n\nSTATIC SV*\nS_reg_scan_name(pTHX_ RExC_state_t *pRExC_state, U32 flags)\n{\n    char *name_start = RExC_parse;\n    SV* sv_name;\n\n    PERL_ARGS_ASSERT_REG_SCAN_NAME;\n\n    assert (RExC_parse <= RExC_end);\n    if (RExC_parse == RExC_end) NOOP;\n    else if (isIDFIRST_lazy_if_safe(RExC_parse, RExC_end, UTF)) {\n         /* Note that the code here assumes well-formed UTF-8.  Skip IDFIRST by\n          * using do...while */\n\tif (UTF)\n\t    do {\n\t\tRExC_parse += UTF8SKIP(RExC_parse);\n\t    } while (   RExC_parse < RExC_end\n                     && isWORDCHAR_utf8_safe((U8*)RExC_parse, (U8*) RExC_end));\n\telse\n\t    do {\n\t\tRExC_parse++;\n\t    } while (RExC_parse < RExC_end && isWORDCHAR(*RExC_parse));\n    } else {\n        RExC_parse++; /* so the <- from the vFAIL is after the offending\n                         character */\n        vFAIL(\"Group name must start with a non-digit word character\");\n    }\n    sv_name = newSVpvn_flags(name_start, (int)(RExC_parse - name_start),\n\t\t\t     SVs_TEMP | (UTF ? SVf_UTF8 : 0));\n    if ( flags == REG_RSN_RETURN_NAME)\n        return sv_name;\n    else if (flags==REG_RSN_RETURN_DATA) {\n        HE *he_str = NULL;\n        SV *sv_dat = NULL;\n        if ( ! sv_name )      /* should not happen*/\n            Perl_croak(aTHX_ \"panic: no svname in reg_scan_name\");\n        if (RExC_paren_names)\n            he_str = hv_fetch_ent( RExC_paren_names, sv_name, 0, 0 );\n        if ( he_str )\n            sv_dat = HeVAL(he_str);\n        if ( ! sv_dat ) {   /* Didn't find group */\n\n            /* It might be a forward reference; we can't fail until we\n                * know, by completing the parse to get all the groups, and\n                * then reparsing */\n            if (ALL_PARENS_COUNTED)  {\n                vFAIL(\"Reference to nonexistent named group\");\n            }\n            else {\n                REQUIRE_PARENS_PASS;\n            }\n        }\n        return sv_dat;\n    }\n\n    Perl_croak(aTHX_ \"panic: bad flag %lx in reg_scan_name\",\n                     (unsigned long) flags);\n}\n\n#define DEBUG_PARSE_MSG(funcname)     DEBUG_PARSE_r({           \\\n    if (RExC_lastparse!=RExC_parse) {                           \\\n        Perl_re_printf( aTHX_  \"%s\",                            \\\n            Perl_pv_pretty(aTHX_ RExC_mysv1, RExC_parse,        \\\n                RExC_end - RExC_parse, 16,                      \\\n                \"\", \"\",                                         \\\n                PERL_PV_ESCAPE_UNI_DETECT |                     \\\n                PERL_PV_PRETTY_ELLIPSES   |                     \\\n                PERL_PV_PRETTY_LTGT       |                     \\\n                PERL_PV_ESCAPE_RE         |                     \\\n                PERL_PV_PRETTY_EXACTSIZE                        \\\n            )                                                   \\\n        );                                                      \\\n    } else                                                      \\\n        Perl_re_printf( aTHX_ \"%16s\",\"\");                       \\\n                                                                \\\n    if (RExC_lastnum!=RExC_emit)                                \\\n       Perl_re_printf( aTHX_ \"|%4d\", RExC_emit);                \\\n    else                                                        \\\n       Perl_re_printf( aTHX_ \"|%4s\",\"\");                        \\\n    Perl_re_printf( aTHX_ \"|%*s%-4s\",                           \\\n        (int)((depth*2)), \"\",                                   \\\n        (funcname)                                              \\\n    );                                                          \\\n    RExC_lastnum=RExC_emit;                                     \\\n    RExC_lastparse=RExC_parse;                                  \\\n})\n\n\n\n#define DEBUG_PARSE(funcname)     DEBUG_PARSE_r({           \\\n    DEBUG_PARSE_MSG((funcname));                            \\\n    Perl_re_printf( aTHX_ \"%4s\",\"\\n\");                                  \\\n})\n#define DEBUG_PARSE_FMT(funcname,fmt,args)     DEBUG_PARSE_r({\\\n    DEBUG_PARSE_MSG((funcname));                            \\\n    Perl_re_printf( aTHX_ fmt \"\\n\",args);                               \\\n})\n\n/* This section of code defines the inversion list object and its methods.  The\n * interfaces are highly subject to change, so as much as possible is static to\n * this file.  An inversion list is here implemented as a malloc'd C UV array\n * as an SVt_INVLIST scalar.\n *\n * An inversion list for Unicode is an array of code points, sorted by ordinal\n * number.  Each element gives the code point that begins a range that extends\n * up-to but not including the code point given by the next element.  The final\n * element gives the first code point of a range that extends to the platform's\n * infinity.  The even-numbered elements (invlist[0], invlist[2], invlist[4],\n * ...) give ranges whose code points are all in the inversion list.  We say\n * that those ranges are in the set.  The odd-numbered elements give ranges\n * whose code points are not in the inversion list, and hence not in the set.\n * Thus, element [0] is the first code point in the list.  Element [1]\n * is the first code point beyond that not in the list; and element [2] is the\n * first code point beyond that that is in the list.  In other words, the first\n * range is invlist[0]..(invlist[1]-1), and all code points in that range are\n * in the inversion list.  The second range is invlist[1]..(invlist[2]-1), and\n * all code points in that range are not in the inversion list.  The third\n * range invlist[2]..(invlist[3]-1) gives code points that are in the inversion\n * list, and so forth.  Thus every element whose index is divisible by two\n * gives the beginning of a range that is in the list, and every element whose\n * index is not divisible by two gives the beginning of a range not in the\n * list.  If the final element's index is divisible by two, the inversion list\n * extends to the platform's infinity; otherwise the highest code point in the\n * inversion list is the contents of that element minus 1.\n *\n * A range that contains just a single code point N will look like\n *  invlist[i]   == N\n *  invlist[i+1] == N+1\n *\n * If N is UV_MAX (the highest representable code point on the machine), N+1 is\n * impossible to represent, so element [i+1] is omitted.  The single element\n * inversion list\n *  invlist[0] == UV_MAX\n * contains just UV_MAX, but is interpreted as matching to infinity.\n *\n * Taking the complement (inverting) an inversion list is quite simple, if the\n * first element is 0, remove it; otherwise add a 0 element at the beginning.\n * This implementation reserves an element at the beginning of each inversion\n * list to always contain 0; there is an additional flag in the header which\n * indicates if the list begins at the 0, or is offset to begin at the next\n * element.  This means that the inversion list can be inverted without any\n * copying; just flip the flag.\n *\n * More about inversion lists can be found in \"Unicode Demystified\"\n * Chapter 13 by Richard Gillam, published by Addison-Wesley.\n *\n * The inversion list data structure is currently implemented as an SV pointing\n * to an array of UVs that the SV thinks are bytes.  This allows us to have an\n * array of UV whose memory management is automatically handled by the existing\n * facilities for SV's.\n *\n * Some of the methods should always be private to the implementation, and some\n * should eventually be made public */\n\n/* The header definitions are in F<invlist_inline.h> */\n\n#ifndef PERL_IN_XSUB_RE\n\nPERL_STATIC_INLINE UV*\nS__invlist_array_init(SV* const invlist, const bool will_have_0)\n{\n    /* Returns a pointer to the first element in the inversion list's array.\n     * This is called upon initialization of an inversion list.  Where the\n     * array begins depends on whether the list has the code point U+0000 in it\n     * or not.  The other parameter tells it whether the code that follows this\n     * call is about to put a 0 in the inversion list or not.  The first\n     * element is either the element reserved for 0, if TRUE, or the element\n     * after it, if FALSE */\n\n    bool* offset = get_invlist_offset_addr(invlist);\n    UV* zero_addr = (UV *) SvPVX(invlist);\n\n    PERL_ARGS_ASSERT__INVLIST_ARRAY_INIT;\n\n    /* Must be empty */\n    assert(! _invlist_len(invlist));\n\n    *zero_addr = 0;\n\n    /* 1^1 = 0; 1^0 = 1 */\n    *offset = 1 ^ will_have_0;\n    return zero_addr + *offset;\n}\n\nPERL_STATIC_INLINE void\nS_invlist_set_len(pTHX_ SV* const invlist, const UV len, const bool offset)\n{\n    /* Sets the current number of elements stored in the inversion list.\n     * Updates SvCUR correspondingly */\n    PERL_UNUSED_CONTEXT;\n    PERL_ARGS_ASSERT_INVLIST_SET_LEN;\n\n    assert(is_invlist(invlist));\n\n    SvCUR_set(invlist,\n              (len == 0)\n               ? 0\n               : TO_INTERNAL_SIZE(len + offset));\n    assert(SvLEN(invlist) == 0 || SvCUR(invlist) <= SvLEN(invlist));\n}\n\nSTATIC void\nS_invlist_replace_list_destroys_src(pTHX_ SV * dest, SV * src)\n{\n    /* Replaces the inversion list in 'dest' with the one from 'src'.  It\n     * steals the list from 'src', so 'src' is made to have a NULL list.  This\n     * is similar to what SvSetMagicSV() would do, if it were implemented on\n     * inversion lists, though this routine avoids a copy */\n\n    const UV src_len          = _invlist_len(src);\n    const bool src_offset     = *get_invlist_offset_addr(src);\n    const STRLEN src_byte_len = SvLEN(src);\n    char * array              = SvPVX(src);\n\n    const int oldtainted = TAINT_get;\n\n    PERL_ARGS_ASSERT_INVLIST_REPLACE_LIST_DESTROYS_SRC;\n\n    assert(is_invlist(src));\n    assert(is_invlist(dest));\n    assert(! invlist_is_iterating(src));\n    assert(SvCUR(src) == 0 || SvCUR(src) < SvLEN(src));\n\n    /* Make sure it ends in the right place with a NUL, as our inversion list\n     * manipulations aren't careful to keep this true, but sv_usepvn_flags()\n     * asserts it */\n    array[src_byte_len - 1] = '\\0';\n\n    TAINT_NOT;      /* Otherwise it breaks */\n    sv_usepvn_flags(dest,\n                    (char *) array,\n                    src_byte_len - 1,\n\n                    /* This flag is documented to cause a copy to be avoided */\n                    SV_HAS_TRAILING_NUL);\n    TAINT_set(oldtainted);\n    SvPV_set(src, 0);\n    SvLEN_set(src, 0);\n    SvCUR_set(src, 0);\n\n    /* Finish up copying over the other fields in an inversion list */\n    *get_invlist_offset_addr(dest) = src_offset;\n    invlist_set_len(dest, src_len, src_offset);\n    *get_invlist_previous_index_addr(dest) = 0;\n    invlist_iterfinish(dest);\n}\n\nPERL_STATIC_INLINE IV*\nS_get_invlist_previous_index_addr(SV* invlist)\n{\n    /* Return the address of the IV that is reserved to hold the cached index\n     * */\n    PERL_ARGS_ASSERT_GET_INVLIST_PREVIOUS_INDEX_ADDR;\n\n    assert(is_invlist(invlist));\n\n    return &(((XINVLIST*) SvANY(invlist))->prev_index);\n}\n\nPERL_STATIC_INLINE IV\nS_invlist_previous_index(SV* const invlist)\n{\n    /* Returns cached index of previous search */\n\n    PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;\n\n    return *get_invlist_previous_index_addr(invlist);\n}\n\nPERL_STATIC_INLINE void\nS_invlist_set_previous_index(SV* const invlist, const IV index)\n{\n    /* Caches <index> for later retrieval */\n\n    PERL_ARGS_ASSERT_INVLIST_SET_PREVIOUS_INDEX;\n\n    assert(index == 0 || index < (int) _invlist_len(invlist));\n\n    *get_invlist_previous_index_addr(invlist) = index;\n}\n\nPERL_STATIC_INLINE void\nS_invlist_trim(SV* invlist)\n{\n    /* Free the not currently-being-used space in an inversion list */\n\n    /* But don't free up the space needed for the 0 UV that is always at the\n     * beginning of the list, nor the trailing NUL */\n    const UV min_size = TO_INTERNAL_SIZE(1) + 1;\n\n    PERL_ARGS_ASSERT_INVLIST_TRIM;\n\n    assert(is_invlist(invlist));\n\n    SvPV_renew(invlist, MAX(min_size, SvCUR(invlist) + 1));\n}\n\nPERL_STATIC_INLINE void\nS_invlist_clear(pTHX_ SV* invlist)    /* Empty the inversion list */\n{\n    PERL_ARGS_ASSERT_INVLIST_CLEAR;\n\n    assert(is_invlist(invlist));\n\n    invlist_set_len(invlist, 0, 0);\n    invlist_trim(invlist);\n}\n\n#endif /* ifndef PERL_IN_XSUB_RE */\n\nPERL_STATIC_INLINE bool\nS_invlist_is_iterating(SV* const invlist)\n{\n    PERL_ARGS_ASSERT_INVLIST_IS_ITERATING;\n\n    return *(get_invlist_iter_addr(invlist)) < (STRLEN) UV_MAX;\n}\n\n#ifndef PERL_IN_XSUB_RE\n\nPERL_STATIC_INLINE UV\nS_invlist_max(SV* const invlist)\n{\n    /* Returns the maximum number of elements storable in the inversion list's\n     * array, without having to realloc() */\n\n    PERL_ARGS_ASSERT_INVLIST_MAX;\n\n    assert(is_invlist(invlist));\n\n    /* Assumes worst case, in which the 0 element is not counted in the\n     * inversion list, so subtracts 1 for that */\n    return SvLEN(invlist) == 0  /* This happens under _new_invlist_C_array */\n           ? FROM_INTERNAL_SIZE(SvCUR(invlist)) - 1\n           : FROM_INTERNAL_SIZE(SvLEN(invlist)) - 1;\n}\n\nSTATIC void\nS_initialize_invlist_guts(pTHX_ SV* invlist, const Size_t initial_size)\n{\n    PERL_ARGS_ASSERT_INITIALIZE_INVLIST_GUTS;\n\n    /* First 1 is in case the zero element isn't in the list; second 1 is for\n     * trailing NUL */\n    SvGROW(invlist, TO_INTERNAL_SIZE(initial_size + 1) + 1);\n    invlist_set_len(invlist, 0, 0);\n\n    /* Force iterinit() to be used to get iteration to work */\n    invlist_iterfinish(invlist);\n\n    *get_invlist_previous_index_addr(invlist) = 0;\n}\n\nSV*\nPerl__new_invlist(pTHX_ IV initial_size)\n{\n\n    /* Return a pointer to a newly constructed inversion list, with enough\n     * space to store 'initial_size' elements.  If that number is negative, a\n     * system default is used instead */\n\n    SV* new_list;\n\n    if (initial_size < 0) {\n\tinitial_size = 10;\n    }\n\n    new_list = newSV_type(SVt_INVLIST);\n    initialize_invlist_guts(new_list, initial_size);\n\n    return new_list;\n}\n\nSV*\nPerl__new_invlist_C_array(pTHX_ const UV* const list)\n{\n    /* Return a pointer to a newly constructed inversion list, initialized to\n     * point to <list>, which has to be in the exact correct inversion list\n     * form, including internal fields.  Thus this is a dangerous routine that\n     * should not be used in the wrong hands.  The passed in 'list' contains\n     * several header fields at the beginning that are not part of the\n     * inversion list body proper */\n\n    const STRLEN length = (STRLEN) list[0];\n    const UV version_id =          list[1];\n    const bool offset   =    cBOOL(list[2]);\n#define HEADER_LENGTH 3\n    /* If any of the above changes in any way, you must change HEADER_LENGTH\n     * (if appropriate) and regenerate INVLIST_VERSION_ID by running\n     *      perl -E 'say int(rand 2**31-1)'\n     */\n#define INVLIST_VERSION_ID 148565664 /* This is a combination of a version and\n                                        data structure type, so that one being\n                                        passed in can be validated to be an\n                                        inversion list of the correct vintage.\n                                       */\n\n    SV* invlist = newSV_type(SVt_INVLIST);\n\n    PERL_ARGS_ASSERT__NEW_INVLIST_C_ARRAY;\n\n    if (version_id != INVLIST_VERSION_ID) {\n        Perl_croak(aTHX_ \"panic: Incorrect version for previously generated inversion list\");\n    }\n\n    /* The generated array passed in includes header elements that aren't part\n     * of the list proper, so start it just after them */\n    SvPV_set(invlist, (char *) (list + HEADER_LENGTH));\n\n    SvLEN_set(invlist, 0);  /* Means we own the contents, and the system\n\t\t\t       shouldn't touch it */\n\n    *(get_invlist_offset_addr(invlist)) = offset;\n\n    /* The 'length' passed to us is the physical number of elements in the\n     * inversion list.  But if there is an offset the logical number is one\n     * less than that */\n    invlist_set_len(invlist, length  - offset, offset);\n\n    invlist_set_previous_index(invlist, 0);\n\n    /* Initialize the iteration pointer. */\n    invlist_iterfinish(invlist);\n\n    SvREADONLY_on(invlist);\n\n    return invlist;\n}\n\nSTATIC void\nS_invlist_extend(pTHX_ SV* const invlist, const UV new_max)\n{\n    /* Grow the maximum size of an inversion list */\n\n    PERL_ARGS_ASSERT_INVLIST_EXTEND;\n\n    assert(is_invlist(invlist));\n\n    /* Add one to account for the zero element at the beginning which may not\n     * be counted by the calling parameters */\n    SvGROW((SV *)invlist, TO_INTERNAL_SIZE(new_max + 1));\n}\n\nSTATIC void\nS__append_range_to_invlist(pTHX_ SV* const invlist,\n                                 const UV start, const UV end)\n{\n   /* Subject to change or removal.  Append the range from 'start' to 'end' at\n    * the end of the inversion list.  The range must be above any existing\n    * ones. */\n\n    UV* array;\n    UV max = invlist_max(invlist);\n    UV len = _invlist_len(invlist);\n    bool offset;\n\n    PERL_ARGS_ASSERT__APPEND_RANGE_TO_INVLIST;\n\n    if (len == 0) { /* Empty lists must be initialized */\n        offset = start != 0;\n        array = _invlist_array_init(invlist, ! offset);\n    }\n    else {\n\t/* Here, the existing list is non-empty. The current max entry in the\n\t * list is generally the first value not in the set, except when the\n\t * set extends to the end of permissible values, in which case it is\n\t * the first entry in that final set, and so this call is an attempt to\n\t * append out-of-order */\n\n\tUV final_element = len - 1;\n\tarray = invlist_array(invlist);\n\tif (   array[final_element] > start\n\t    || ELEMENT_RANGE_MATCHES_INVLIST(final_element))\n\t{\n\t    Perl_croak(aTHX_ \"panic: attempting to append to an inversion list, but wasn't at the end of the list, final=%\" UVuf \", start=%\" UVuf \", match=%c\",\n\t\t     array[final_element], start,\n\t\t     ELEMENT_RANGE_MATCHES_INVLIST(final_element) ? 't' : 'f');\n\t}\n\n        /* Here, it is a legal append.  If the new range begins 1 above the end\n         * of the range below it, it is extending the range below it, so the\n         * new first value not in the set is one greater than the newly\n         * extended range.  */\n        offset = *get_invlist_offset_addr(invlist);\n\tif (array[final_element] == start) {\n\t    if (end != UV_MAX) {\n\t\tarray[final_element] = end + 1;\n\t    }\n\t    else {\n\t\t/* But if the end is the maximum representable on the machine,\n                 * assume that infinity was actually what was meant.  Just let\n                 * the range that this would extend to have no end */\n\t\tinvlist_set_len(invlist, len - 1, offset);\n\t    }\n\t    return;\n\t}\n    }\n\n    /* Here the new range doesn't extend any existing set.  Add it */\n\n    len += 2;\t/* Includes an element each for the start and end of range */\n\n    /* If wll overflow the existing space, extend, which may cause the array to\n     * be moved */\n    if (max < len) {\n\tinvlist_extend(invlist, len);\n\n        /* Have to set len here to avoid assert failure in invlist_array() */\n        invlist_set_len(invlist, len, offset);\n\n\tarray = invlist_array(invlist);\n    }\n    else {\n\tinvlist_set_len(invlist, len, offset);\n    }\n\n    /* The next item on the list starts the range, the one after that is\n     * one past the new range.  */\n    array[len - 2] = start;\n    if (end != UV_MAX) {\n\tarray[len - 1] = end + 1;\n    }\n    else {\n\t/* But if the end is the maximum representable on the machine, just let\n\t * the range have no end */\n\tinvlist_set_len(invlist, len - 1, offset);\n    }\n}\n\nSSize_t\nPerl__invlist_search(SV* const invlist, const UV cp)\n{\n    /* Searches the inversion list for the entry that contains the input code\n     * point <cp>.  If <cp> is not in the list, -1 is returned.  Otherwise, the\n     * return value is the index into the list's array of the range that\n     * contains <cp>, that is, 'i' such that\n     *\tarray[i] <= cp < array[i+1]\n     */\n\n    IV low = 0;\n    IV mid;\n    IV high = _invlist_len(invlist);\n    const IV highest_element = high - 1;\n    const UV* array;\n\n    PERL_ARGS_ASSERT__INVLIST_SEARCH;\n\n    /* If list is empty, return failure. */\n    if (high == 0) {\n\treturn -1;\n    }\n\n    /* (We can't get the array unless we know the list is non-empty) */\n    array = invlist_array(invlist);\n\n    mid = invlist_previous_index(invlist);\n    assert(mid >=0);\n    if (mid > highest_element) {\n        mid = highest_element;\n    }\n\n    /* <mid> contains the cache of the result of the previous call to this\n     * function (0 the first time).  See if this call is for the same result,\n     * or if it is for mid-1.  This is under the theory that calls to this\n     * function will often be for related code points that are near each other.\n     * And benchmarks show that caching gives better results.  We also test\n     * here if the code point is within the bounds of the list.  These tests\n     * replace others that would have had to be made anyway to make sure that\n     * the array bounds were not exceeded, and these give us extra information\n     * at the same time */\n    if (cp >= array[mid]) {\n        if (cp >= array[highest_element]) {\n            return highest_element;\n        }\n\n        /* Here, array[mid] <= cp < array[highest_element].  This means that\n         * the final element is not the answer, so can exclude it; it also\n         * means that <mid> is not the final element, so can refer to 'mid + 1'\n         * safely */\n        if (cp < array[mid + 1]) {\n            return mid;\n        }\n        high--;\n        low = mid + 1;\n    }\n    else { /* cp < aray[mid] */\n        if (cp < array[0]) { /* Fail if outside the array */\n            return -1;\n        }\n        high = mid;\n        if (cp >= array[mid - 1]) {\n            goto found_entry;\n        }\n    }\n\n    /* Binary search.  What we are looking for is <i> such that\n     *\tarray[i] <= cp < array[i+1]\n     * The loop below converges on the i+1.  Note that there may not be an\n     * (i+1)th element in the array, and things work nonetheless */\n    while (low < high) {\n\tmid = (low + high) / 2;\n        assert(mid <= highest_element);\n\tif (array[mid] <= cp) { /* cp >= array[mid] */\n\t    low = mid + 1;\n\n\t    /* We could do this extra test to exit the loop early.\n\t    if (cp < array[low]) {\n\t\treturn mid;\n\t    }\n\t    */\n\t}\n\telse { /* cp < array[mid] */\n\t    high = mid;\n\t}\n    }\n\n  found_entry:\n    high--;\n    invlist_set_previous_index(invlist, high);\n    return high;\n}\n\nvoid\nPerl__invlist_union_maybe_complement_2nd(pTHX_ SV* const a, SV* const b,\n                                         const bool complement_b, SV** output)\n{\n    /* Take the union of two inversion lists and point '*output' to it.  On\n     * input, '*output' MUST POINT TO NULL OR TO AN SV* INVERSION LIST (possibly\n     * even 'a' or 'b').  If to an inversion list, the contents of the original\n     * list will be replaced by the union.  The first list, 'a', may be\n     * NULL, in which case a copy of the second list is placed in '*output'.\n     * If 'complement_b' is TRUE, the union is taken of the complement\n     * (inversion) of 'b' instead of b itself.\n     *\n     * The basis for this comes from \"Unicode Demystified\" Chapter 13 by\n     * Richard Gillam, published by Addison-Wesley, and explained at some\n     * length there.  The preface says to incorporate its examples into your\n     * code at your own risk.\n     *\n     * The algorithm is like a merge sort. */\n\n    const UV* array_a;    /* a's array */\n    const UV* array_b;\n    UV len_a;\t    /* length of a's array */\n    UV len_b;\n\n    SV* u;\t\t\t/* the resulting union */\n    UV* array_u;\n    UV len_u = 0;\n\n    UV i_a = 0;\t\t    /* current index into a's array */\n    UV i_b = 0;\n    UV i_u = 0;\n\n    /* running count, as explained in the algorithm source book; items are\n     * stopped accumulating and are output when the count changes to/from 0.\n     * The count is incremented when we start a range that's in an input's set,\n     * and decremented when we start a range that's not in a set.  So this\n     * variable can be 0, 1, or 2.  When it is 0 neither input is in their set,\n     * and hence nothing goes into the union; 1, just one of the inputs is in\n     * its set (and its current range gets added to the union); and 2 when both\n     * inputs are in their sets.  */\n    UV count = 0;\n\n    PERL_ARGS_ASSERT__INVLIST_UNION_MAYBE_COMPLEMENT_2ND;\n    assert(a != b);\n    assert(*output == NULL || is_invlist(*output));\n\n    len_b = _invlist_len(b);\n    if (len_b == 0) {\n\n        /* Here, 'b' is empty, hence it's complement is all possible code\n         * points.  So if the union includes the complement of 'b', it includes\n         * everything, and we need not even look at 'a'.  It's easiest to\n         * create a new inversion list that matches everything.  */\n        if (complement_b) {\n            SV* everything = _add_range_to_invlist(NULL, 0, UV_MAX);\n\n            if (*output == NULL) { /* If the output didn't exist, just point it\n                                      at the new list */\n                *output = everything;\n            }\n            else { /* Otherwise, replace its contents with the new list */\n                invlist_replace_list_destroys_src(*output, everything);\n                SvREFCNT_dec_NN(everything);\n            }\n\n            return;\n        }\n\n        /* Here, we don't want the complement of 'b', and since 'b' is empty,\n         * the union will come entirely from 'a'.  If 'a' is NULL or empty, the\n         * output will be empty */\n\n        if (a == NULL || _invlist_len(a) == 0) {\n            if (*output == NULL) {\n                *output = _new_invlist(0);\n            }\n            else {\n                invlist_clear(*output);\n            }\n            return;\n        }\n\n        /* Here, 'a' is not empty, but 'b' is, so 'a' entirely determines the\n         * union.  We can just return a copy of 'a' if '*output' doesn't point\n         * to an existing list */\n        if (*output == NULL) {\n            *output = invlist_clone(a, NULL);\n            return;\n        }\n\n        /* If the output is to overwrite 'a', we have a no-op, as it's\n         * already in 'a' */\n        if (*output == a) {\n            return;\n        }\n\n        /* Here, '*output' is to be overwritten by 'a' */\n        u = invlist_clone(a, NULL);\n        invlist_replace_list_destroys_src(*output, u);\n        SvREFCNT_dec_NN(u);\n\n        return;\n    }\n\n    /* Here 'b' is not empty.  See about 'a' */\n\n    if (a == NULL || ((len_a = _invlist_len(a)) == 0)) {\n\n        /* Here, 'a' is empty (and b is not).  That means the union will come\n         * entirely from 'b'.  If '*output' is NULL, we can directly return a\n         * clone of 'b'.  Otherwise, we replace the contents of '*output' with\n         * the clone */\n\n        SV ** dest = (*output == NULL) ? output : &u;\n        *dest = invlist_clone(b, NULL);\n        if (complement_b) {\n            _invlist_invert(*dest);\n        }\n\n        if (dest == &u) {\n            invlist_replace_list_destroys_src(*output, u);\n            SvREFCNT_dec_NN(u);\n        }\n\n\treturn;\n    }\n\n    /* Here both lists exist and are non-empty */\n    array_a = invlist_array(a);\n    array_b = invlist_array(b);\n\n    /* If are to take the union of 'a' with the complement of b, set it\n     * up so are looking at b's complement. */\n    if (complement_b) {\n\n\t/* To complement, we invert: if the first element is 0, remove it.  To\n\t * do this, we just pretend the array starts one later */\n        if (array_b[0] == 0) {\n            array_b++;\n            len_b--;\n        }\n        else {\n\n            /* But if the first element is not zero, we pretend the list starts\n             * at the 0 that is always stored immediately before the array. */\n            array_b--;\n            len_b++;\n        }\n    }\n\n    /* Size the union for the worst case: that the sets are completely\n     * disjoint */\n    u = _new_invlist(len_a + len_b);\n\n    /* Will contain U+0000 if either component does */\n    array_u = _invlist_array_init(u, (    len_a > 0 && array_a[0] == 0)\n                                      || (len_b > 0 && array_b[0] == 0));\n\n    /* Go through each input list item by item, stopping when have exhausted\n     * one of them */\n    while (i_a < len_a && i_b < len_b) {\n\tUV cp;\t    /* The element to potentially add to the union's array */\n\tbool cp_in_set;   /* is it in the the input list's set or not */\n\n\t/* We need to take one or the other of the two inputs for the union.\n\t * Since we are merging two sorted lists, we take the smaller of the\n         * next items.  In case of a tie, we take first the one that is in its\n         * set.  If we first took the one not in its set, it would decrement\n         * the count, possibly to 0 which would cause it to be output as ending\n         * the range, and the next time through we would take the same number,\n         * and output it again as beginning the next range.  By doing it the\n         * opposite way, there is no possibility that the count will be\n         * momentarily decremented to 0, and thus the two adjoining ranges will\n         * be seamlessly merged.  (In a tie and both are in the set or both not\n         * in the set, it doesn't matter which we take first.) */\n\tif (       array_a[i_a] < array_b[i_b]\n\t    || (   array_a[i_a] == array_b[i_b]\n\t\t&& ELEMENT_RANGE_MATCHES_INVLIST(i_a)))\n\t{\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_a);\n\t    cp = array_a[i_a++];\n\t}\n\telse {\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_b);\n\t    cp = array_b[i_b++];\n\t}\n\n\t/* Here, have chosen which of the two inputs to look at.  Only output\n\t * if the running count changes to/from 0, which marks the\n\t * beginning/end of a range that's in the set */\n\tif (cp_in_set) {\n\t    if (count == 0) {\n\t\tarray_u[i_u++] = cp;\n\t    }\n\t    count++;\n\t}\n\telse {\n\t    count--;\n\t    if (count == 0) {\n\t\tarray_u[i_u++] = cp;\n\t    }\n\t}\n    }\n\n\n    /* The loop above increments the index into exactly one of the input lists\n     * each iteration, and ends when either index gets to its list end.  That\n     * means the other index is lower than its end, and so something is\n     * remaining in that one.  We decrement 'count', as explained below, if\n     * that list is in its set.  (i_a and i_b each currently index the element\n     * beyond the one we care about.) */\n    if (   (i_a != len_a && PREV_RANGE_MATCHES_INVLIST(i_a))\n\t|| (i_b != len_b && PREV_RANGE_MATCHES_INVLIST(i_b)))\n    {\n\tcount--;\n    }\n\n    /* Above we decremented 'count' if the list that had unexamined elements in\n     * it was in its set.  This has made it so that 'count' being non-zero\n     * means there isn't anything left to output; and 'count' equal to 0 means\n     * that what is left to output is precisely that which is left in the\n     * non-exhausted input list.\n     *\n     * To see why, note first that the exhausted input obviously has nothing\n     * left to add to the union.  If it was in its set at its end, that means\n     * the set extends from here to the platform's infinity, and hence so does\n     * the union and the non-exhausted set is irrelevant.  The exhausted set\n     * also contributed 1 to 'count'.  If 'count' was 2, it got decremented to\n     * 1, but if it was 1, the non-exhausted set wasn't in its set, and so\n     * 'count' remains at 1.  This is consistent with the decremented 'count'\n     * != 0 meaning there's nothing left to add to the union.\n     *\n     * But if the exhausted input wasn't in its set, it contributed 0 to\n     * 'count', and the rest of the union will be whatever the other input is.\n     * If 'count' was 0, neither list was in its set, and 'count' remains 0;\n     * otherwise it gets decremented to 0.  This is consistent with 'count'\n     * == 0 meaning the remainder of the union is whatever is left in the\n     * non-exhausted list. */\n    if (count != 0) {\n        len_u = i_u;\n    }\n    else {\n        IV copy_count = len_a - i_a;\n        if (copy_count > 0) {   /* The non-exhausted input is 'a' */\n\t    Copy(array_a + i_a, array_u + i_u, copy_count, UV);\n        }\n        else { /* The non-exhausted input is b */\n            copy_count = len_b - i_b;\n\t    Copy(array_b + i_b, array_u + i_u, copy_count, UV);\n        }\n        len_u = i_u + copy_count;\n    }\n\n    /* Set the result to the final length, which can change the pointer to\n     * array_u, so re-find it.  (Note that it is unlikely that this will\n     * change, as we are shrinking the space, not enlarging it) */\n    if (len_u != _invlist_len(u)) {\n\tinvlist_set_len(u, len_u, *get_invlist_offset_addr(u));\n\tinvlist_trim(u);\n\tarray_u = invlist_array(u);\n    }\n\n    if (*output == NULL) {  /* Simply return the new inversion list */\n        *output = u;\n    }\n    else {\n        /* Otherwise, overwrite the inversion list that was in '*output'.  We\n         * could instead free '*output', and then set it to 'u', but experience\n         * has shown [perl #127392] that if the input is a mortal, we can get a\n         * huge build-up of these during regex compilation before they get\n         * freed. */\n        invlist_replace_list_destroys_src(*output, u);\n        SvREFCNT_dec_NN(u);\n    }\n\n    return;\n}\n\nvoid\nPerl__invlist_intersection_maybe_complement_2nd(pTHX_ SV* const a, SV* const b,\n                                               const bool complement_b, SV** i)\n{\n    /* Take the intersection of two inversion lists and point '*i' to it.  On\n     * input, '*i' MUST POINT TO NULL OR TO AN SV* INVERSION LIST (possibly\n     * even 'a' or 'b').  If to an inversion list, the contents of the original\n     * list will be replaced by the intersection.  The first list, 'a', may be\n     * NULL, in which case '*i' will be an empty list.  If 'complement_b' is\n     * TRUE, the result will be the intersection of 'a' and the complement (or\n     * inversion) of 'b' instead of 'b' directly.\n     *\n     * The basis for this comes from \"Unicode Demystified\" Chapter 13 by\n     * Richard Gillam, published by Addison-Wesley, and explained at some\n     * length there.  The preface says to incorporate its examples into your\n     * code at your own risk.  In fact, it had bugs\n     *\n     * The algorithm is like a merge sort, and is essentially the same as the\n     * union above\n     */\n\n    const UV* array_a;\t\t/* a's array */\n    const UV* array_b;\n    UV len_a;\t/* length of a's array */\n    UV len_b;\n\n    SV* r;\t\t     /* the resulting intersection */\n    UV* array_r;\n    UV len_r = 0;\n\n    UV i_a = 0;\t\t    /* current index into a's array */\n    UV i_b = 0;\n    UV i_r = 0;\n\n    /* running count of how many of the two inputs are postitioned at ranges\n     * that are in their sets.  As explained in the algorithm source book,\n     * items are stopped accumulating and are output when the count changes\n     * to/from 2.  The count is incremented when we start a range that's in an\n     * input's set, and decremented when we start a range that's not in a set.\n     * Only when it is 2 are we in the intersection. */\n    UV count = 0;\n\n    PERL_ARGS_ASSERT__INVLIST_INTERSECTION_MAYBE_COMPLEMENT_2ND;\n    assert(a != b);\n    assert(*i == NULL || is_invlist(*i));\n\n    /* Special case if either one is empty */\n    len_a = (a == NULL) ? 0 : _invlist_len(a);\n    if ((len_a == 0) || ((len_b = _invlist_len(b)) == 0)) {\n        if (len_a != 0 && complement_b) {\n\n            /* Here, 'a' is not empty, therefore from the enclosing 'if', 'b'\n             * must be empty.  Here, also we are using 'b's complement, which\n             * hence must be every possible code point.  Thus the intersection\n             * is simply 'a'. */\n\n            if (*i == a) {  /* No-op */\n                return;\n            }\n\n            if (*i == NULL) {\n                *i = invlist_clone(a, NULL);\n                return;\n            }\n\n            r = invlist_clone(a, NULL);\n            invlist_replace_list_destroys_src(*i, r);\n            SvREFCNT_dec_NN(r);\n            return;\n        }\n\n        /* Here, 'a' or 'b' is empty and not using the complement of 'b'.  The\n         * intersection must be empty */\n        if (*i == NULL) {\n            *i = _new_invlist(0);\n            return;\n        }\n\n        invlist_clear(*i);\n\treturn;\n    }\n\n    /* Here both lists exist and are non-empty */\n    array_a = invlist_array(a);\n    array_b = invlist_array(b);\n\n    /* If are to take the intersection of 'a' with the complement of b, set it\n     * up so are looking at b's complement. */\n    if (complement_b) {\n\n\t/* To complement, we invert: if the first element is 0, remove it.  To\n\t * do this, we just pretend the array starts one later */\n        if (array_b[0] == 0) {\n            array_b++;\n            len_b--;\n        }\n        else {\n\n            /* But if the first element is not zero, we pretend the list starts\n             * at the 0 that is always stored immediately before the array. */\n            array_b--;\n            len_b++;\n        }\n    }\n\n    /* Size the intersection for the worst case: that the intersection ends up\n     * fragmenting everything to be completely disjoint */\n    r= _new_invlist(len_a + len_b);\n\n    /* Will contain U+0000 iff both components do */\n    array_r = _invlist_array_init(r,    len_a > 0 && array_a[0] == 0\n                                     && len_b > 0 && array_b[0] == 0);\n\n    /* Go through each list item by item, stopping when have exhausted one of\n     * them */\n    while (i_a < len_a && i_b < len_b) {\n\tUV cp;\t    /* The element to potentially add to the intersection's\n\t\t       array */\n\tbool cp_in_set;\t/* Is it in the input list's set or not */\n\n\t/* We need to take one or the other of the two inputs for the\n\t * intersection.  Since we are merging two sorted lists, we take the\n         * smaller of the next items.  In case of a tie, we take first the one\n         * that is not in its set (a difference from the union algorithm).  If\n         * we first took the one in its set, it would increment the count,\n         * possibly to 2 which would cause it to be output as starting a range\n         * in the intersection, and the next time through we would take that\n         * same number, and output it again as ending the set.  By doing the\n         * opposite of this, there is no possibility that the count will be\n         * momentarily incremented to 2.  (In a tie and both are in the set or\n         * both not in the set, it doesn't matter which we take first.) */\n\tif (       array_a[i_a] < array_b[i_b]\n\t    || (   array_a[i_a] == array_b[i_b]\n\t\t&& ! ELEMENT_RANGE_MATCHES_INVLIST(i_a)))\n\t{\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_a);\n\t    cp = array_a[i_a++];\n\t}\n\telse {\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_b);\n\t    cp= array_b[i_b++];\n\t}\n\n\t/* Here, have chosen which of the two inputs to look at.  Only output\n\t * if the running count changes to/from 2, which marks the\n\t * beginning/end of a range that's in the intersection */\n\tif (cp_in_set) {\n\t    count++;\n\t    if (count == 2) {\n\t\tarray_r[i_r++] = cp;\n\t    }\n\t}\n\telse {\n\t    if (count == 2) {\n\t\tarray_r[i_r++] = cp;\n\t    }\n\t    count--;\n\t}\n\n    }\n\n    /* The loop above increments the index into exactly one of the input lists\n     * each iteration, and ends when either index gets to its list end.  That\n     * means the other index is lower than its end, and so something is\n     * remaining in that one.  We increment 'count', as explained below, if the\n     * exhausted list was in its set.  (i_a and i_b each currently index the\n     * element beyond the one we care about.) */\n    if (   (i_a == len_a && PREV_RANGE_MATCHES_INVLIST(i_a))\n        || (i_b == len_b && PREV_RANGE_MATCHES_INVLIST(i_b)))\n    {\n\tcount++;\n    }\n\n    /* Above we incremented 'count' if the exhausted list was in its set.  This\n     * has made it so that 'count' being below 2 means there is nothing left to\n     * output; otheriwse what's left to add to the intersection is precisely\n     * that which is left in the non-exhausted input list.\n     *\n     * To see why, note first that the exhausted input obviously has nothing\n     * left to affect the intersection.  If it was in its set at its end, that\n     * means the set extends from here to the platform's infinity, and hence\n     * anything in the non-exhausted's list will be in the intersection, and\n     * anything not in it won't be.  Hence, the rest of the intersection is\n     * precisely what's in the non-exhausted list  The exhausted set also\n     * contributed 1 to 'count', meaning 'count' was at least 1.  Incrementing\n     * it means 'count' is now at least 2.  This is consistent with the\n     * incremented 'count' being >= 2 means to add the non-exhausted list to\n     * the intersection.\n     *\n     * But if the exhausted input wasn't in its set, it contributed 0 to\n     * 'count', and the intersection can't include anything further; the\n     * non-exhausted set is irrelevant.  'count' was at most 1, and doesn't get\n     * incremented.  This is consistent with 'count' being < 2 meaning nothing\n     * further to add to the intersection. */\n    if (count < 2) { /* Nothing left to put in the intersection. */\n        len_r = i_r;\n    }\n    else { /* copy the non-exhausted list, unchanged. */\n        IV copy_count = len_a - i_a;\n        if (copy_count > 0) {   /* a is the one with stuff left */\n\t    Copy(array_a + i_a, array_r + i_r, copy_count, UV);\n        }\n        else {  /* b is the one with stuff left */\n            copy_count = len_b - i_b;\n\t    Copy(array_b + i_b, array_r + i_r, copy_count, UV);\n        }\n        len_r = i_r + copy_count;\n    }\n\n    /* Set the result to the final length, which can change the pointer to\n     * array_r, so re-find it.  (Note that it is unlikely that this will\n     * change, as we are shrinking the space, not enlarging it) */\n    if (len_r != _invlist_len(r)) {\n\tinvlist_set_len(r, len_r, *get_invlist_offset_addr(r));\n\tinvlist_trim(r);\n\tarray_r = invlist_array(r);\n    }\n\n    if (*i == NULL) { /* Simply return the calculated intersection */\n        *i = r;\n    }\n    else { /* Otherwise, replace the existing inversion list in '*i'.  We could\n              instead free '*i', and then set it to 'r', but experience has\n              shown [perl #127392] that if the input is a mortal, we can get a\n              huge build-up of these during regex compilation before they get\n              freed. */\n        if (len_r) {\n            invlist_replace_list_destroys_src(*i, r);\n        }\n        else {\n            invlist_clear(*i);\n        }\n        SvREFCNT_dec_NN(r);\n    }\n\n    return;\n}\n\nSV*\nPerl__add_range_to_invlist(pTHX_ SV* invlist, UV start, UV end)\n{\n    /* Add the range from 'start' to 'end' inclusive to the inversion list's\n     * set.  A pointer to the inversion list is returned.  This may actually be\n     * a new list, in which case the passed in one has been destroyed.  The\n     * passed-in inversion list can be NULL, in which case a new one is created\n     * with just the one range in it.  The new list is not necessarily\n     * NUL-terminated.  Space is not freed if the inversion list shrinks as a\n     * result of this function.  The gain would not be large, and in many\n     * cases, this is called multiple times on a single inversion list, so\n     * anything freed may almost immediately be needed again.\n     *\n     * This used to mostly call the 'union' routine, but that is much more\n     * heavyweight than really needed for a single range addition */\n\n    UV* array;              /* The array implementing the inversion list */\n    UV len;                 /* How many elements in 'array' */\n    SSize_t i_s;            /* index into the invlist array where 'start'\n                               should go */\n    SSize_t i_e = 0;        /* And the index where 'end' should go */\n    UV cur_highest;         /* The highest code point in the inversion list\n                               upon entry to this function */\n\n    /* This range becomes the whole inversion list if none already existed */\n    if (invlist == NULL) {\n\tinvlist = _new_invlist(2);\n        _append_range_to_invlist(invlist, start, end);\n        return invlist;\n    }\n\n    /* Likewise, if the inversion list is currently empty */\n    len = _invlist_len(invlist);\n    if (len == 0) {\n        _append_range_to_invlist(invlist, start, end);\n        return invlist;\n    }\n\n    /* Starting here, we have to know the internals of the list */\n    array = invlist_array(invlist);\n\n    /* If the new range ends higher than the current highest ... */\n    cur_highest = invlist_highest(invlist);\n    if (end > cur_highest) {\n\n        /* If the whole range is higher, we can just append it */\n        if (start > cur_highest) {\n            _append_range_to_invlist(invlist, start, end);\n            return invlist;\n        }\n\n        /* Otherwise, add the portion that is higher ... */\n        _append_range_to_invlist(invlist, cur_highest + 1, end);\n\n        /* ... and continue on below to handle the rest.  As a result of the\n         * above append, we know that the index of the end of the range is the\n         * final even numbered one of the array.  Recall that the final element\n         * always starts a range that extends to infinity.  If that range is in\n         * the set (meaning the set goes from here to infinity), it will be an\n         * even index, but if it isn't in the set, it's odd, and the final\n         * range in the set is one less, which is even. */\n        if (end == UV_MAX) {\n            i_e = len;\n        }\n        else {\n            i_e = len - 2;\n        }\n    }\n\n    /* We have dealt with appending, now see about prepending.  If the new\n     * range starts lower than the current lowest ... */\n    if (start < array[0]) {\n\n        /* Adding something which has 0 in it is somewhat tricky, and uncommon.\n         * Let the union code handle it, rather than having to know the\n         * trickiness in two code places.  */\n        if (UNLIKELY(start == 0)) {\n            SV* range_invlist;\n\n            range_invlist = _new_invlist(2);\n            _append_range_to_invlist(range_invlist, start, end);\n\n            _invlist_union(invlist, range_invlist, &invlist);\n\n            SvREFCNT_dec_NN(range_invlist);\n\n            return invlist;\n        }\n\n        /* If the whole new range comes before the first entry, and doesn't\n         * extend it, we have to insert it as an additional range */\n        if (end < array[0] - 1) {\n            i_s = i_e = -1;\n            goto splice_in_new_range;\n        }\n\n        /* Here the new range adjoins the existing first range, extending it\n         * downwards. */\n        array[0] = start;\n\n        /* And continue on below to handle the rest.  We know that the index of\n         * the beginning of the range is the first one of the array */\n        i_s = 0;\n    }\n    else { /* Not prepending any part of the new range to the existing list.\n            * Find where in the list it should go.  This finds i_s, such that:\n            *     invlist[i_s] <= start < array[i_s+1]\n            */\n        i_s = _invlist_search(invlist, start);\n    }\n\n    /* At this point, any extending before the beginning of the inversion list\n     * and/or after the end has been done.  This has made it so that, in the\n     * code below, each endpoint of the new range is either in a range that is\n     * in the set, or is in a gap between two ranges that are.  This means we\n     * don't have to worry about exceeding the array bounds.\n     *\n     * Find where in the list the new range ends (but we can skip this if we\n     * have already determined what it is, or if it will be the same as i_s,\n     * which we already have computed) */\n    if (i_e == 0) {\n        i_e = (start == end)\n              ? i_s\n              : _invlist_search(invlist, end);\n    }\n\n    /* Here generally invlist[i_e] <= end < array[i_e+1].  But if invlist[i_e]\n     * is a range that goes to infinity there is no element at invlist[i_e+1],\n     * so only the first relation holds. */\n\n    if ( ! ELEMENT_RANGE_MATCHES_INVLIST(i_s)) {\n\n        /* Here, the ranges on either side of the beginning of the new range\n         * are in the set, and this range starts in the gap between them.\n         *\n         * The new range extends the range above it downwards if the new range\n         * ends at or above that range's start */\n        const bool extends_the_range_above = (   end == UV_MAX\n                                              || end + 1 >= array[i_s+1]);\n\n        /* The new range extends the range below it upwards if it begins just\n         * after where that range ends */\n        if (start == array[i_s]) {\n\n            /* If the new range fills the entire gap between the other ranges,\n             * they will get merged together.  Other ranges may also get\n             * merged, depending on how many of them the new range spans.  In\n             * the general case, we do the merge later, just once, after we\n             * figure out how many to merge.  But in the case where the new\n             * range exactly spans just this one gap (possibly extending into\n             * the one above), we do the merge here, and an early exit.  This\n             * is done here to avoid having to special case later. */\n            if (i_e - i_s <= 1) {\n\n                /* If i_e - i_s == 1, it means that the new range terminates\n                 * within the range above, and hence 'extends_the_range_above'\n                 * must be true.  (If the range above it extends to infinity,\n                 * 'i_s+2' will be above the array's limit, but 'len-i_s-2'\n                 * will be 0, so no harm done.) */\n                if (extends_the_range_above) {\n                    Move(array + i_s + 2, array + i_s, len - i_s - 2, UV);\n                    invlist_set_len(invlist,\n                                    len - 2,\n                                    *(get_invlist_offset_addr(invlist)));\n                    return invlist;\n                }\n\n                /* Here, i_e must == i_s.  We keep them in sync, as they apply\n                 * to the same range, and below we are about to decrement i_s\n                 * */\n                i_e--;\n            }\n\n            /* Here, the new range is adjacent to the one below.  (It may also\n             * span beyond the range above, but that will get resolved later.)\n             * Extend the range below to include this one. */\n            array[i_s] = (end == UV_MAX) ? UV_MAX : end + 1;\n            i_s--;\n            start = array[i_s];\n        }\n        else if (extends_the_range_above) {\n\n            /* Here the new range only extends the range above it, but not the\n             * one below.  It merges with the one above.  Again, we keep i_e\n             * and i_s in sync if they point to the same range */\n            if (i_e == i_s) {\n                i_e++;\n            }\n            i_s++;\n            array[i_s] = start;\n        }\n    }\n\n    /* Here, we've dealt with the new range start extending any adjoining\n     * existing ranges.\n     *\n     * If the new range extends to infinity, it is now the final one,\n     * regardless of what was there before */\n    if (UNLIKELY(end == UV_MAX)) {\n        invlist_set_len(invlist, i_s + 1, *(get_invlist_offset_addr(invlist)));\n        return invlist;\n    }\n\n    /* If i_e started as == i_s, it has also been dealt with,\n     * and been updated to the new i_s, which will fail the following if */\n    if (! ELEMENT_RANGE_MATCHES_INVLIST(i_e)) {\n\n        /* Here, the ranges on either side of the end of the new range are in\n         * the set, and this range ends in the gap between them.\n         *\n         * If this range is adjacent to (hence extends) the range above it, it\n         * becomes part of that range; likewise if it extends the range below,\n         * it becomes part of that range */\n        if (end + 1 == array[i_e+1]) {\n            i_e++;\n            array[i_e] = start;\n        }\n        else if (start <= array[i_e]) {\n            array[i_e] = end + 1;\n            i_e--;\n        }\n    }\n\n    if (i_s == i_e) {\n\n        /* If the range fits entirely in an existing range (as possibly already\n         * extended above), it doesn't add anything new */\n        if (ELEMENT_RANGE_MATCHES_INVLIST(i_s)) {\n            return invlist;\n        }\n\n        /* Here, no part of the range is in the list.  Must add it.  It will\n         * occupy 2 more slots */\n      splice_in_new_range:\n\n        invlist_extend(invlist, len + 2);\n        array = invlist_array(invlist);\n        /* Move the rest of the array down two slots. Don't include any\n         * trailing NUL */\n        Move(array + i_e + 1, array + i_e + 3, len - i_e - 1, UV);\n\n        /* Do the actual splice */\n        array[i_e+1] = start;\n        array[i_e+2] = end + 1;\n        invlist_set_len(invlist, len + 2, *(get_invlist_offset_addr(invlist)));\n        return invlist;\n    }\n\n    /* Here the new range crossed the boundaries of a pre-existing range.  The\n     * code above has adjusted things so that both ends are in ranges that are\n     * in the set.  This means everything in between must also be in the set.\n     * Just squash things together */\n    Move(array + i_e + 1, array + i_s + 1, len - i_e - 1, UV);\n    invlist_set_len(invlist,\n                    len - i_e + i_s,\n                    *(get_invlist_offset_addr(invlist)));\n\n    return invlist;\n}\n\nSV*\nPerl__setup_canned_invlist(pTHX_ const STRLEN size, const UV element0,\n                                 UV** other_elements_ptr)\n{\n    /* Create and return an inversion list whose contents are to be populated\n     * by the caller.  The caller gives the number of elements (in 'size') and\n     * the very first element ('element0').  This function will set\n     * '*other_elements_ptr' to an array of UVs, where the remaining elements\n     * are to be placed.\n     *\n     * Obviously there is some trust involved that the caller will properly\n     * fill in the other elements of the array.\n     *\n     * (The first element needs to be passed in, as the underlying code does\n     * things differently depending on whether it is zero or non-zero) */\n\n    SV* invlist = _new_invlist(size);\n    bool offset;\n\n    PERL_ARGS_ASSERT__SETUP_CANNED_INVLIST;\n\n    invlist = add_cp_to_invlist(invlist, element0);\n    offset = *get_invlist_offset_addr(invlist);\n\n    invlist_set_len(invlist, size, offset);\n    *other_elements_ptr = invlist_array(invlist) + 1;\n    return invlist;\n}\n\n#endif\n\nPERL_STATIC_INLINE SV*\nS_add_cp_to_invlist(pTHX_ SV* invlist, const UV cp) {\n    return _add_range_to_invlist(invlist, cp, cp);\n}\n\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl__invlist_invert(pTHX_ SV* const invlist)\n{\n    /* Complement the input inversion list.  This adds a 0 if the list didn't\n     * have a zero; removes it otherwise.  As described above, the data\n     * structure is set up so that this is very efficient */\n\n    PERL_ARGS_ASSERT__INVLIST_INVERT;\n\n    assert(! invlist_is_iterating(invlist));\n\n    /* The inverse of matching nothing is matching everything */\n    if (_invlist_len(invlist) == 0) {\n\t_append_range_to_invlist(invlist, 0, UV_MAX);\n\treturn;\n    }\n\n    *get_invlist_offset_addr(invlist) = ! *get_invlist_offset_addr(invlist);\n}\n\nSV*\nPerl_invlist_clone(pTHX_ SV* const invlist, SV* new_invlist)\n{\n    /* Return a new inversion list that is a copy of the input one, which is\n     * unchanged.  The new list will not be mortal even if the old one was. */\n\n    const STRLEN nominal_length = _invlist_len(invlist);\n    const STRLEN physical_length = SvCUR(invlist);\n    const bool offset = *(get_invlist_offset_addr(invlist));\n\n    PERL_ARGS_ASSERT_INVLIST_CLONE;\n\n    if (new_invlist == NULL) {\n        new_invlist = _new_invlist(nominal_length);\n    }\n    else {\n        sv_upgrade(new_invlist, SVt_INVLIST);\n        initialize_invlist_guts(new_invlist, nominal_length);\n    }\n\n    *(get_invlist_offset_addr(new_invlist)) = offset;\n    invlist_set_len(new_invlist, nominal_length, offset);\n    Copy(SvPVX(invlist), SvPVX(new_invlist), physical_length, char);\n\n    return new_invlist;\n}\n\n#endif\n\nPERL_STATIC_INLINE STRLEN*\nS_get_invlist_iter_addr(SV* invlist)\n{\n    /* Return the address of the UV that contains the current iteration\n     * position */\n\n    PERL_ARGS_ASSERT_GET_INVLIST_ITER_ADDR;\n\n    assert(is_invlist(invlist));\n\n    return &(((XINVLIST*) SvANY(invlist))->iterator);\n}\n\nPERL_STATIC_INLINE void\nS_invlist_iterinit(SV* invlist)\t/* Initialize iterator for invlist */\n{\n    PERL_ARGS_ASSERT_INVLIST_ITERINIT;\n\n    *get_invlist_iter_addr(invlist) = 0;\n}\n\nPERL_STATIC_INLINE void\nS_invlist_iterfinish(SV* invlist)\n{\n    /* Terminate iterator for invlist.  This is to catch development errors.\n     * Any iteration that is interrupted before completed should call this\n     * function.  Functions that add code points anywhere else but to the end\n     * of an inversion list assert that they are not in the middle of an\n     * iteration.  If they were, the addition would make the iteration\n     * problematical: if the iteration hadn't reached the place where things\n     * were being added, it would be ok */\n\n    PERL_ARGS_ASSERT_INVLIST_ITERFINISH;\n\n    *get_invlist_iter_addr(invlist) = (STRLEN) UV_MAX;\n}\n\nSTATIC bool\nS_invlist_iternext(SV* invlist, UV* start, UV* end)\n{\n    /* An C<invlist_iterinit> call on <invlist> must be used to set this up.\n     * This call sets in <*start> and <*end>, the next range in <invlist>.\n     * Returns <TRUE> if successful and the next call will return the next\n     * range; <FALSE> if was already at the end of the list.  If the latter,\n     * <*start> and <*end> are unchanged, and the next call to this function\n     * will start over at the beginning of the list */\n\n    STRLEN* pos = get_invlist_iter_addr(invlist);\n    UV len = _invlist_len(invlist);\n    UV *array;\n\n    PERL_ARGS_ASSERT_INVLIST_ITERNEXT;\n\n    if (*pos >= len) {\n\t*pos = (STRLEN) UV_MAX;\t/* Force iterinit() to be required next time */\n\treturn FALSE;\n    }\n\n    array = invlist_array(invlist);\n\n    *start = array[(*pos)++];\n\n    if (*pos >= len) {\n\t*end = UV_MAX;\n    }\n    else {\n\t*end = array[(*pos)++] - 1;\n    }\n\n    return TRUE;\n}\n\nPERL_STATIC_INLINE UV\nS_invlist_highest(SV* const invlist)\n{\n    /* Returns the highest code point that matches an inversion list.  This API\n     * has an ambiguity, as it returns 0 under either the highest is actually\n     * 0, or if the list is empty.  If this distinction matters to you, check\n     * for emptiness before calling this function */\n\n    UV len = _invlist_len(invlist);\n    UV *array;\n\n    PERL_ARGS_ASSERT_INVLIST_HIGHEST;\n\n    if (len == 0) {\n\treturn 0;\n    }\n\n    array = invlist_array(invlist);\n\n    /* The last element in the array in the inversion list always starts a\n     * range that goes to infinity.  That range may be for code points that are\n     * matched in the inversion list, or it may be for ones that aren't\n     * matched.  In the latter case, the highest code point in the set is one\n     * less than the beginning of this range; otherwise it is the final element\n     * of this range: infinity */\n    return (ELEMENT_RANGE_MATCHES_INVLIST(len - 1))\n           ? UV_MAX\n           : array[len - 1] - 1;\n}\n\nSTATIC SV *\nS_invlist_contents(pTHX_ SV* const invlist, const bool traditional_style)\n{\n    /* Get the contents of an inversion list into a string SV so that they can\n     * be printed out.  If 'traditional_style' is TRUE, it uses the format\n     * traditionally done for debug tracing; otherwise it uses a format\n     * suitable for just copying to the output, with blanks between ranges and\n     * a dash between range components */\n\n    UV start, end;\n    SV* output;\n    const char intra_range_delimiter = (traditional_style ? '\\t' : '-');\n    const char inter_range_delimiter = (traditional_style ? '\\n' : ' ');\n\n    if (traditional_style) {\n        output = newSVpvs(\"\\n\");\n    }\n    else {\n        output = newSVpvs(\"\");\n    }\n\n    PERL_ARGS_ASSERT_INVLIST_CONTENTS;\n\n    assert(! invlist_is_iterating(invlist));\n\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n\tif (end == UV_MAX) {\n\t    Perl_sv_catpvf(aTHX_ output, \"%04\" UVXf \"%cINFTY%c\",\n                                          start, intra_range_delimiter,\n                                                 inter_range_delimiter);\n\t}\n\telse if (end != start) {\n\t    Perl_sv_catpvf(aTHX_ output, \"%04\" UVXf \"%c%04\" UVXf \"%c\",\n\t\t                          start,\n                                                   intra_range_delimiter,\n                                                  end, inter_range_delimiter);\n\t}\n\telse {\n\t    Perl_sv_catpvf(aTHX_ output, \"%04\" UVXf \"%c\",\n                                          start, inter_range_delimiter);\n\t}\n    }\n\n    if (SvCUR(output) && ! traditional_style) {/* Get rid of trailing blank */\n        SvCUR_set(output, SvCUR(output) - 1);\n    }\n\n    return output;\n}\n\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl__invlist_dump(pTHX_ PerlIO *file, I32 level,\n                         const char * const indent, SV* const invlist)\n{\n    /* Designed to be called only by do_sv_dump().  Dumps out the ranges of the\n     * inversion list 'invlist' to 'file' at 'level'  Each line is prefixed by\n     * the string 'indent'.  The output looks like this:\n         [0] 0x000A .. 0x000D\n         [2] 0x0085\n         [4] 0x2028 .. 0x2029\n         [6] 0x3104 .. INFTY\n     * This means that the first range of code points matched by the list are\n     * 0xA through 0xD; the second range contains only the single code point\n     * 0x85, etc.  An inversion list is an array of UVs.  Two array elements\n     * are used to define each range (except if the final range extends to\n     * infinity, only a single element is needed).  The array index of the\n     * first element for the corresponding range is given in brackets. */\n\n    UV start, end;\n    STRLEN count = 0;\n\n    PERL_ARGS_ASSERT__INVLIST_DUMP;\n\n    if (invlist_is_iterating(invlist)) {\n        Perl_dump_indent(aTHX_ level, file,\n             \"%sCan't dump inversion list because is in middle of iterating\\n\",\n             indent);\n        return;\n    }\n\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n\tif (end == UV_MAX) {\n\t    Perl_dump_indent(aTHX_ level, file,\n                                       \"%s[%\" UVuf \"] 0x%04\" UVXf \" .. INFTY\\n\",\n                                   indent, (UV)count, start);\n\t}\n\telse if (end != start) {\n\t    Perl_dump_indent(aTHX_ level, file,\n                                    \"%s[%\" UVuf \"] 0x%04\" UVXf \" .. 0x%04\" UVXf \"\\n\",\n\t\t                indent, (UV)count, start,         end);\n\t}\n\telse {\n\t    Perl_dump_indent(aTHX_ level, file, \"%s[%\" UVuf \"] 0x%04\" UVXf \"\\n\",\n                                            indent, (UV)count, start);\n\t}\n        count += 2;\n    }\n}\n\n#endif\n\n#if defined(PERL_ARGS_ASSERT__INVLISTEQ) && !defined(PERL_IN_XSUB_RE)\nbool\nPerl__invlistEQ(pTHX_ SV* const a, SV* const b, const bool complement_b)\n{\n    /* Return a boolean as to if the two passed in inversion lists are\n     * identical.  The final argument, if TRUE, says to take the complement of\n     * the second inversion list before doing the comparison */\n\n    const UV len_a = _invlist_len(a);\n    UV len_b = _invlist_len(b);\n\n    const UV* array_a = NULL;\n    const UV* array_b = NULL;\n\n    PERL_ARGS_ASSERT__INVLISTEQ;\n\n    /* This code avoids accessing the arrays unless it knows the length is\n     * non-zero */\n\n    if (len_a == 0) {\n        if (len_b == 0) {\n            return ! complement_b;\n        }\n    }\n    else {\n        array_a = invlist_array(a);\n    }\n\n    if (len_b != 0) {\n        array_b = invlist_array(b);\n    }\n\n    /* If are to compare 'a' with the complement of b, set it\n     * up so are looking at b's complement. */\n    if (complement_b) {\n\n        /* The complement of nothing is everything, so <a> would have to have\n         * just one element, starting at zero (ending at infinity) */\n        if (len_b == 0) {\n            return (len_a == 1 && array_a[0] == 0);\n        }\n        if (array_b[0] == 0) {\n\n            /* Otherwise, to complement, we invert.  Here, the first element is\n             * 0, just remove it.  To do this, we just pretend the array starts\n             * one later */\n\n            array_b++;\n            len_b--;\n        }\n        else {\n\n            /* But if the first element is not zero, we pretend the list starts\n             * at the 0 that is always stored immediately before the array. */\n            array_b--;\n            len_b++;\n        }\n    }\n\n    return    len_a == len_b\n           && memEQ(array_a, array_b, len_a * sizeof(array_a[0]));\n\n}\n#endif\n\n/*\n * As best we can, determine the characters that can match the start of\n * the given EXACTF-ish node.  This is for use in creating ssc nodes, so there\n * can be false positive matches\n *\n * Returns the invlist as a new SV*; it is the caller's responsibility to\n * call SvREFCNT_dec() when done with it.\n */\nSTATIC SV*\nS__make_exactf_invlist(pTHX_ RExC_state_t *pRExC_state, regnode *node)\n{\n    dVAR;\n    const U8 * s = (U8*)STRING(node);\n    SSize_t bytelen = STR_LEN(node);\n    UV uc;\n    /* Start out big enough for 2 separate code points */\n    SV* invlist = _new_invlist(4);\n\n    PERL_ARGS_ASSERT__MAKE_EXACTF_INVLIST;\n\n    if (! UTF) {\n        uc = *s;\n\n        /* We punt and assume can match anything if the node begins\n         * with a multi-character fold.  Things are complicated.  For\n         * example, /ffi/i could match any of:\n         *  \"\\N{LATIN SMALL LIGATURE FFI}\"\n         *  \"\\N{LATIN SMALL LIGATURE FF}I\"\n         *  \"F\\N{LATIN SMALL LIGATURE FI}\"\n         *  plus several other things; and making sure we have all the\n         *  possibilities is hard. */\n        if (is_MULTI_CHAR_FOLD_latin1_safe(s, s + bytelen)) {\n            invlist = _add_range_to_invlist(invlist, 0, UV_MAX);\n        }\n        else {\n            /* Any Latin1 range character can potentially match any\n             * other depending on the locale, and in Turkic locales, U+130 and\n             * U+131 */\n            if (OP(node) == EXACTFL) {\n                _invlist_union(invlist, PL_Latin1, &invlist);\n                invlist = add_cp_to_invlist(invlist,\n                                                LATIN_SMALL_LETTER_DOTLESS_I);\n                invlist = add_cp_to_invlist(invlist,\n                                        LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE);\n            }\n            else {\n                /* But otherwise, it matches at least itself.  We can\n                 * quickly tell if it has a distinct fold, and if so,\n                 * it matches that as well */\n                invlist = add_cp_to_invlist(invlist, uc);\n                if (IS_IN_SOME_FOLD_L1(uc))\n                    invlist = add_cp_to_invlist(invlist, PL_fold_latin1[uc]);\n            }\n\n            /* Some characters match above-Latin1 ones under /i.  This\n             * is true of EXACTFL ones when the locale is UTF-8 */\n            if (HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(uc)\n                && (! isASCII(uc) || (OP(node) != EXACTFAA\n                                    && OP(node) != EXACTFAA_NO_TRIE)))\n            {\n                add_above_Latin1_folds(pRExC_state, (U8) uc, &invlist);\n            }\n        }\n    }\n    else {  /* Pattern is UTF-8 */\n        U8 folded[UTF8_MAX_FOLD_CHAR_EXPAND * UTF8_MAXBYTES_CASE + 1] = { '\\0' };\n        const U8* e = s + bytelen;\n        IV fc;\n\n        fc = uc = utf8_to_uvchr_buf(s, s + bytelen, NULL);\n\n        /* The only code points that aren't folded in a UTF EXACTFish\n         * node are are the problematic ones in EXACTFL nodes */\n        if (OP(node) == EXACTFL && is_PROBLEMATIC_LOCALE_FOLDEDS_START_cp(uc)) {\n            /* We need to check for the possibility that this EXACTFL\n             * node begins with a multi-char fold.  Therefore we fold\n             * the first few characters of it so that we can make that\n             * check */\n            U8 *d = folded;\n            int i;\n\n            fc = -1;\n            for (i = 0; i < UTF8_MAX_FOLD_CHAR_EXPAND && s < e; i++) {\n                if (isASCII(*s)) {\n                    *(d++) = (U8) toFOLD(*s);\n                    if (fc < 0) {       /* Save the first fold */\n                        fc = *(d-1);\n                    }\n                    s++;\n                }\n                else {\n                    STRLEN len;\n                    UV fold = toFOLD_utf8_safe(s, e, d, &len);\n                    if (fc < 0) {       /* Save the first fold */\n                        fc = fold;\n                    }\n                    d += len;\n                    s += UTF8SKIP(s);\n                }\n            }\n\n            /* And set up so the code below that looks in this folded\n             * buffer instead of the node's string */\n            e = d;\n            s = folded;\n        }\n\n        /* When we reach here 's' points to the fold of the first\n         * character(s) of the node; and 'e' points to far enough along\n         * the folded string to be just past any possible multi-char\n         * fold.\n         *\n         * Unlike the non-UTF-8 case, the macro for determining if a\n         * string is a multi-char fold requires all the characters to\n         * already be folded.  This is because of all the complications\n         * if not.  Note that they are folded anyway, except in EXACTFL\n         * nodes.  Like the non-UTF case above, we punt if the node\n         * begins with a multi-char fold  */\n\n        if (is_MULTI_CHAR_FOLD_utf8_safe(s, e)) {\n            invlist = _add_range_to_invlist(invlist, 0, UV_MAX);\n        }\n        else {  /* Single char fold */\n            unsigned int k;\n            unsigned int first_fold;\n            const unsigned int * remaining_folds;\n            Size_t folds_count;\n\n            /* It matches itself */\n            invlist = add_cp_to_invlist(invlist, fc);\n\n            /* ... plus all the things that fold to it, which are found in\n             * PL_utf8_foldclosures */\n            folds_count = _inverse_folds(fc, &first_fold,\n                                                &remaining_folds);\n            for (k = 0; k < folds_count; k++) {\n                UV c = (k == 0) ? first_fold : remaining_folds[k-1];\n\n                /* /aa doesn't allow folds between ASCII and non- */\n                if (   (OP(node) == EXACTFAA || OP(node) == EXACTFAA_NO_TRIE)\n                    && isASCII(c) != isASCII(fc))\n                {\n                    continue;\n                }\n\n                invlist = add_cp_to_invlist(invlist, c);\n            }\n\n            if (OP(node) == EXACTFL) {\n\n                /* If either [iI] are present in an EXACTFL node the above code\n                 * should have added its normal case pair, but under a Turkish\n                 * locale they could match instead the case pairs from it.  Add\n                 * those as potential matches as well */\n                if (isALPHA_FOLD_EQ(fc, 'I')) {\n                    invlist = add_cp_to_invlist(invlist,\n                                                LATIN_SMALL_LETTER_DOTLESS_I);\n                    invlist = add_cp_to_invlist(invlist,\n                                        LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE);\n                }\n                else if (fc == LATIN_SMALL_LETTER_DOTLESS_I) {\n                    invlist = add_cp_to_invlist(invlist, 'I');\n                }\n                else if (fc == LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE) {\n                    invlist = add_cp_to_invlist(invlist, 'i');\n                }\n            }\n        }\n    }\n\n    return invlist;\n}\n\n#undef HEADER_LENGTH\n#undef TO_INTERNAL_SIZE\n#undef FROM_INTERNAL_SIZE\n#undef INVLIST_VERSION_ID\n\n/* End of inversion list object */\n\nSTATIC void\nS_parse_lparen_question_flags(pTHX_ RExC_state_t *pRExC_state)\n{\n    /* This parses the flags that are in either the '(?foo)' or '(?foo:bar)'\n     * constructs, and updates RExC_flags with them.  On input, RExC_parse\n     * should point to the first flag; it is updated on output to point to the\n     * final ')' or ':'.  There needs to be at least one flag, or this will\n     * abort */\n\n    /* for (?g), (?gc), and (?o) warnings; warning\n       about (?c) will warn about (?g) -- japhy    */\n\n#define WASTED_O  0x01\n#define WASTED_G  0x02\n#define WASTED_C  0x04\n#define WASTED_GC (WASTED_G|WASTED_C)\n    I32 wastedflags = 0x00;\n    U32 posflags = 0, negflags = 0;\n    U32 *flagsp = &posflags;\n    char has_charset_modifier = '\\0';\n    regex_charset cs;\n    bool has_use_defaults = FALSE;\n    const char* const seqstart = RExC_parse - 1; /* Point to the '?' */\n    int x_mod_count = 0;\n\n    PERL_ARGS_ASSERT_PARSE_LPAREN_QUESTION_FLAGS;\n\n    /* '^' as an initial flag sets certain defaults */\n    if (UCHARAT(RExC_parse) == '^') {\n        RExC_parse++;\n        has_use_defaults = TRUE;\n        STD_PMMOD_FLAGS_CLEAR(&RExC_flags);\n        cs = (RExC_uni_semantics)\n             ? REGEX_UNICODE_CHARSET\n             : REGEX_DEPENDS_CHARSET;\n        set_regex_charset(&RExC_flags, cs);\n    }\n    else {\n        cs = get_regex_charset(RExC_flags);\n        if (   cs == REGEX_DEPENDS_CHARSET\n            && RExC_uni_semantics)\n        {\n            cs = REGEX_UNICODE_CHARSET;\n        }\n    }\n\n    while (RExC_parse < RExC_end) {\n        /* && strchr(\"iogcmsx\", *RExC_parse) */\n        /* (?g), (?gc) and (?o) are useless here\n           and must be globally applied -- japhy */\n        switch (*RExC_parse) {\n\n            /* Code for the imsxn flags */\n            CASE_STD_PMMOD_FLAGS_PARSE_SET(flagsp, x_mod_count);\n\n            case LOCALE_PAT_MOD:\n                if (has_charset_modifier) {\n                    goto excess_modifier;\n                }\n                else if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                cs = REGEX_LOCALE_CHARSET;\n                has_charset_modifier = LOCALE_PAT_MOD;\n                break;\n            case UNICODE_PAT_MOD:\n                if (has_charset_modifier) {\n                    goto excess_modifier;\n                }\n                else if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                cs = REGEX_UNICODE_CHARSET;\n                has_charset_modifier = UNICODE_PAT_MOD;\n                break;\n            case ASCII_RESTRICT_PAT_MOD:\n                if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                if (has_charset_modifier) {\n                    if (cs != REGEX_ASCII_RESTRICTED_CHARSET) {\n                        goto excess_modifier;\n                    }\n                    /* Doubled modifier implies more restricted */\n                    cs = REGEX_ASCII_MORE_RESTRICTED_CHARSET;\n                }\n                else {\n                    cs = REGEX_ASCII_RESTRICTED_CHARSET;\n                }\n                has_charset_modifier = ASCII_RESTRICT_PAT_MOD;\n                break;\n            case DEPENDS_PAT_MOD:\n                if (has_use_defaults) {\n                    goto fail_modifiers;\n                }\n                else if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                else if (has_charset_modifier) {\n                    goto excess_modifier;\n                }\n\n                /* The dual charset means unicode semantics if the\n                 * pattern (or target, not known until runtime) are\n                 * utf8, or something in the pattern indicates unicode\n                 * semantics */\n                cs = (RExC_uni_semantics)\n                     ? REGEX_UNICODE_CHARSET\n                     : REGEX_DEPENDS_CHARSET;\n                has_charset_modifier = DEPENDS_PAT_MOD;\n                break;\n              excess_modifier:\n                RExC_parse++;\n                if (has_charset_modifier == ASCII_RESTRICT_PAT_MOD) {\n                    vFAIL2(\"Regexp modifier \\\"%c\\\" may appear a maximum of twice\", ASCII_RESTRICT_PAT_MOD);\n                }\n                else if (has_charset_modifier == *(RExC_parse - 1)) {\n                    vFAIL2(\"Regexp modifier \\\"%c\\\" may not appear twice\",\n                                        *(RExC_parse - 1));\n                }\n                else {\n                    vFAIL3(\"Regexp modifiers \\\"%c\\\" and \\\"%c\\\" are mutually exclusive\", has_charset_modifier, *(RExC_parse - 1));\n                }\n                NOT_REACHED; /*NOTREACHED*/\n              neg_modifier:\n                RExC_parse++;\n                vFAIL2(\"Regexp modifier \\\"%c\\\" may not appear after the \\\"-\\\"\",\n                                    *(RExC_parse - 1));\n                NOT_REACHED; /*NOTREACHED*/\n            case ONCE_PAT_MOD: /* 'o' */\n            case GLOBAL_PAT_MOD: /* 'g' */\n                if (ckWARN(WARN_REGEXP)) {\n                    const I32 wflagbit = *RExC_parse == 'o'\n                                         ? WASTED_O\n                                         : WASTED_G;\n                    if (! (wastedflags & wflagbit) ) {\n                        wastedflags |= wflagbit;\n\t\t\t/* diag_listed_as: Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in m/%s/ */\n                        vWARN5(\n                            RExC_parse + 1,\n                            \"Useless (%s%c) - %suse /%c modifier\",\n                            flagsp == &negflags ? \"?-\" : \"?\",\n                            *RExC_parse,\n                            flagsp == &negflags ? \"don't \" : \"\",\n                            *RExC_parse\n                        );\n                    }\n                }\n                break;\n\n            case CONTINUE_PAT_MOD: /* 'c' */\n                if (ckWARN(WARN_REGEXP)) {\n                    if (! (wastedflags & WASTED_C) ) {\n                        wastedflags |= WASTED_GC;\n\t\t\t/* diag_listed_as: Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in m/%s/ */\n                        vWARN3(\n                            RExC_parse + 1,\n                            \"Useless (%sc) - %suse /gc modifier\",\n                            flagsp == &negflags ? \"?-\" : \"?\",\n                            flagsp == &negflags ? \"don't \" : \"\"\n                        );\n                    }\n                }\n                break;\n            case KEEPCOPY_PAT_MOD: /* 'p' */\n                if (flagsp == &negflags) {\n                    ckWARNreg(RExC_parse + 1,\"Useless use of (?-p)\");\n                } else {\n                    *flagsp |= RXf_PMf_KEEPCOPY;\n                }\n                break;\n            case '-':\n                /* A flag is a default iff it is following a minus, so\n                 * if there is a minus, it means will be trying to\n                 * re-specify a default which is an error */\n                if (has_use_defaults || flagsp == &negflags) {\n                    goto fail_modifiers;\n                }\n                flagsp = &negflags;\n                wastedflags = 0;  /* reset so (?g-c) warns twice */\n                x_mod_count = 0;\n                break;\n            case ':':\n            case ')':\n\n                if ((posflags & (RXf_PMf_EXTENDED|RXf_PMf_EXTENDED_MORE)) == RXf_PMf_EXTENDED) {\n                    negflags |= RXf_PMf_EXTENDED_MORE;\n                }\n                RExC_flags |= posflags;\n\n                if (negflags & RXf_PMf_EXTENDED) {\n                    negflags |= RXf_PMf_EXTENDED_MORE;\n                }\n                RExC_flags &= ~negflags;\n                set_regex_charset(&RExC_flags, cs);\n\n                return;\n            default:\n              fail_modifiers:\n                RExC_parse += SKIP_IF_CHAR(RExC_parse, RExC_end);\n\t\t/* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */\n                vFAIL2utf8f(\"Sequence (%\" UTF8f \"...) not recognized\",\n                      UTF8fARG(UTF, RExC_parse-seqstart, seqstart));\n                NOT_REACHED; /*NOTREACHED*/\n        }\n\n        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n    }\n\n    vFAIL(\"Sequence (?... not terminated\");\n}\n\n/*\n - reg - regular expression, i.e. main body or parenthesized thing\n *\n * Caller must absorb opening parenthesis.\n *\n * Combining parenthesis handling with the base level of regular expression\n * is a trifle forced, but the need to tie the tails of the branches to what\n * follows makes it hard to avoid.\n */\n#define REGTAIL(x,y,z) regtail((x),(y),(z),depth+1)\n#ifdef DEBUGGING\n#define REGTAIL_STUDY(x,y,z) regtail_study((x),(y),(z),depth+1)\n#else\n#define REGTAIL_STUDY(x,y,z) regtail((x),(y),(z),depth+1)\n#endif\n\nPERL_STATIC_INLINE regnode_offset\nS_handle_named_backref(pTHX_ RExC_state_t *pRExC_state,\n                             I32 *flagp,\n                             char * parse_start,\n                             char ch\n                      )\n{\n    regnode_offset ret;\n    char* name_start = RExC_parse;\n    U32 num = 0;\n    SV *sv_dat = reg_scan_name(pRExC_state, REG_RSN_RETURN_DATA);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_HANDLE_NAMED_BACKREF;\n\n    if (RExC_parse == name_start || *RExC_parse != ch) {\n        /* diag_listed_as: Sequence \\%s... not terminated in regex; marked by <-- HERE in m/%s/ */\n        vFAIL2(\"Sequence %.3s... not terminated\", parse_start);\n    }\n\n    if (sv_dat) {\n        num = add_data( pRExC_state, STR_WITH_LEN(\"S\"));\n        RExC_rxi->data->data[num]=(void*)sv_dat;\n        SvREFCNT_inc_simple_void_NN(sv_dat);\n    }\n    RExC_sawback = 1;\n    ret = reganode(pRExC_state,\n                   ((! FOLD)\n                     ? NREF\n                     : (ASCII_FOLD_RESTRICTED)\n                       ? NREFFA\n                       : (AT_LEAST_UNI_SEMANTICS)\n                         ? NREFFU\n                         : (LOC)\n                           ? NREFFL\n                           : NREFF),\n                    num);\n    *flagp |= HASWIDTH;\n\n    Set_Node_Offset(REGNODE_p(ret), parse_start+1);\n    Set_Node_Cur_Length(REGNODE_p(ret), parse_start);\n\n    nextchar(pRExC_state);\n    return ret;\n}\n\n/* On success, returns the offset at which any next node should be placed into\n * the regex engine program being compiled.\n *\n * Returns 0 otherwise, with *flagp set to indicate why:\n *  TRYAGAIN        at the end of (?) that only sets flags.\n *  RESTART_PARSE   if the parse needs to be restarted, or'd with\n *                  NEED_UTF8 if the pattern needs to be upgraded to UTF-8.\n *  Otherwise would only return 0 if regbranch() returns 0, which cannot\n *  happen.  */\nSTATIC regnode_offset\nS_reg(pTHX_ RExC_state_t *pRExC_state, I32 paren, I32 *flagp, U32 depth)\n    /* paren: Parenthesized? 0=top; 1,2=inside '(': changed to letter.\n     * 2 is like 1, but indicates that nextchar() has been called to advance\n     * RExC_parse beyond the '('.  Things like '(?' are indivisible tokens, and\n     * this flag alerts us to the need to check for that */\n{\n    regnode_offset ret = 0;    /* Will be the head of the group. */\n    regnode_offset br;\n    regnode_offset lastbr;\n    regnode_offset ender = 0;\n    I32 parno = 0;\n    I32 flags;\n    U32 oregflags = RExC_flags;\n    bool have_branch = 0;\n    bool is_open = 0;\n    I32 freeze_paren = 0;\n    I32 after_freeze = 0;\n    I32 num; /* numeric backreferences */\n    SV * max_open;  /* Max number of unclosed parens */\n\n    char * parse_start = RExC_parse; /* MJD */\n    char * const oregcomp_parse = RExC_parse;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REG;\n    DEBUG_PARSE(\"reg \");\n\n\n    max_open = get_sv(RE_COMPILE_RECURSION_LIMIT, GV_ADD);\n    assert(max_open);\n    if (!SvIOK(max_open)) {\n        sv_setiv(max_open, RE_COMPILE_RECURSION_INIT);\n    }\n    if (depth > 4 * (UV) SvIV(max_open)) { /* We increase depth by 4 for each\n                                              open paren */\n        vFAIL(\"Too many nested open parens\");\n    }\n\n    *flagp = 0;\t\t\t\t/* Tentatively. */\n\n    /* Having this true makes it feasible to have a lot fewer tests for the\n     * parse pointer being in scope.  For example, we can write\n     *      while(isFOO(*RExC_parse)) RExC_parse++;\n     * instead of\n     *      while(RExC_parse < RExC_end && isFOO(*RExC_parse)) RExC_parse++;\n     */\n    assert(*RExC_end == '\\0');\n\n    /* Make an OPEN node, if parenthesized. */\n    if (paren) {\n\n        /* Under /x, space and comments can be gobbled up between the '(' and\n         * here (if paren ==2).  The forms '(*VERB' and '(?...' disallow such\n         * intervening space, as the sequence is a token, and a token should be\n         * indivisible */\n        bool has_intervening_patws = (paren == 2)\n                                  && *(RExC_parse - 1) != '(';\n\n        if (RExC_parse >= RExC_end) {\n\t    vFAIL(\"Unmatched (\");\n        }\n\n        if (paren == 'r') {     /* Atomic script run */\n            paren = '>';\n            goto parse_rest;\n        }\n        else if ( *RExC_parse == '*') { /* (*VERB:ARG), (*construct:...) */\n\t    char *start_verb = RExC_parse + 1;\n\t    STRLEN verb_len;\n\t    char *start_arg = NULL;\n\t    unsigned char op = 0;\n            int arg_required = 0;\n            int internal_argval = -1; /* if >-1 we are not allowed an argument*/\n            bool has_upper = FALSE;\n\n            if (has_intervening_patws) {\n                RExC_parse++;   /* past the '*' */\n\n                /* For strict backwards compatibility, don't change the message\n                 * now that we also have lowercase operands */\n                if (isUPPER(*RExC_parse)) {\n                    vFAIL(\"In '(*VERB...)', the '(' and '*' must be adjacent\");\n                }\n                else {\n                    vFAIL(\"In '(*...)', the '(' and '*' must be adjacent\");\n                }\n            }\n\t    while (RExC_parse < RExC_end && *RExC_parse != ')' ) {\n\t        if ( *RExC_parse == ':' ) {\n\t            start_arg = RExC_parse + 1;\n\t            break;\n\t        }\n                else if (! UTF) {\n                    if (isUPPER(*RExC_parse)) {\n                        has_upper = TRUE;\n                    }\n                    RExC_parse++;\n                }\n                else {\n                    RExC_parse += UTF8SKIP(RExC_parse);\n                }\n\t    }\n\t    verb_len = RExC_parse - start_verb;\n\t    if ( start_arg ) {\n                if (RExC_parse >= RExC_end) {\n                    goto unterminated_verb_pattern;\n                }\n\n\t        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n\t        while ( RExC_parse < RExC_end && *RExC_parse != ')' ) {\n                    RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n                }\n\t        if ( RExC_parse >= RExC_end || *RExC_parse != ')' ) {\n                  unterminated_verb_pattern:\n                    if (has_upper) {\n                        vFAIL(\"Unterminated verb pattern argument\");\n                    }\n                    else {\n                        vFAIL(\"Unterminated '(*...' argument\");\n                    }\n                }\n\t    } else {\n\t        if ( RExC_parse >= RExC_end || *RExC_parse != ')' ) {\n                    if (has_upper) {\n                        vFAIL(\"Unterminated verb pattern\");\n                    }\n                    else {\n                        vFAIL(\"Unterminated '(*...' construct\");\n                    }\n                }\n\t    }\n\n            /* Here, we know that RExC_parse < RExC_end */\n\n\t    switch ( *start_verb ) {\n            case 'A':  /* (*ACCEPT) */\n                if ( memEQs(start_verb, verb_len,\"ACCEPT\") ) {\n\t\t    op = ACCEPT;\n\t\t    internal_argval = RExC_nestroot;\n\t\t}\n\t\tbreak;\n            case 'C':  /* (*COMMIT) */\n                if ( memEQs(start_verb, verb_len,\"COMMIT\") )\n                    op = COMMIT;\n                break;\n            case 'F':  /* (*FAIL) */\n                if ( verb_len==1 || memEQs(start_verb, verb_len,\"FAIL\") ) {\n\t\t    op = OPFAIL;\n\t\t}\n\t\tbreak;\n            case ':':  /* (*:NAME) */\n\t    case 'M':  /* (*MARK:NAME) */\n\t        if ( verb_len==0 || memEQs(start_verb, verb_len,\"MARK\") ) {\n                    op = MARKPOINT;\n                    arg_required = 1;\n                }\n                break;\n            case 'P':  /* (*PRUNE) */\n                if ( memEQs(start_verb, verb_len,\"PRUNE\") )\n                    op = PRUNE;\n                break;\n            case 'S':   /* (*SKIP) */\n                if ( memEQs(start_verb, verb_len,\"SKIP\") )\n                    op = SKIP;\n                break;\n            case 'T':  /* (*THEN) */\n                /* [19:06] <TimToady> :: is then */\n                if ( memEQs(start_verb, verb_len,\"THEN\") ) {\n                    op = CUTGROUP;\n                    RExC_seen |= REG_CUTGROUP_SEEN;\n                }\n                break;\n            case 'a':\n                if (   memEQs(start_verb, verb_len, \"asr\")\n                    || memEQs(start_verb, verb_len, \"atomic_script_run\"))\n                {\n                    paren = 'r';        /* Mnemonic: recursed run */\n                    goto script_run;\n                }\n                else if (memEQs(start_verb, verb_len, \"atomic\")) {\n                    paren = 't';    /* AtOMIC */\n                    goto alpha_assertions;\n                }\n                break;\n            case 'p':\n                if (   memEQs(start_verb, verb_len, \"plb\")\n                    || memEQs(start_verb, verb_len, \"positive_lookbehind\"))\n                {\n                    paren = 'b';\n                    goto lookbehind_alpha_assertions;\n                }\n                else if (   memEQs(start_verb, verb_len, \"pla\")\n                         || memEQs(start_verb, verb_len, \"positive_lookahead\"))\n                {\n                    paren = 'a';\n                    goto alpha_assertions;\n                }\n                break;\n            case 'n':\n                if (   memEQs(start_verb, verb_len, \"nlb\")\n                    || memEQs(start_verb, verb_len, \"negative_lookbehind\"))\n                {\n                    paren = 'B';\n                    goto lookbehind_alpha_assertions;\n                }\n                else if (   memEQs(start_verb, verb_len, \"nla\")\n                         || memEQs(start_verb, verb_len, \"negative_lookahead\"))\n                {\n                    paren = 'A';\n                    goto alpha_assertions;\n                }\n                break;\n            case 's':\n                if (   memEQs(start_verb, verb_len, \"sr\")\n                    || memEQs(start_verb, verb_len, \"script_run\"))\n                {\n                    regnode_offset atomic;\n\n                    paren = 's';\n\n                   script_run:\n\n                    /* This indicates Unicode rules. */\n                    REQUIRE_UNI_RULES(flagp, 0);\n\n                    if (! start_arg) {\n                        goto no_colon;\n                    }\n\n                    RExC_parse = start_arg;\n\n                    if (RExC_in_script_run) {\n\n                        /*  Nested script runs are treated as no-ops, because\n                         *  if the nested one fails, the outer one must as\n                         *  well.  It could fail sooner, and avoid (??{} with\n                         *  side effects, but that is explicitly documented as\n                         *  undefined behavior. */\n\n                        ret = 0;\n\n                        if (paren == 's') {\n                            paren = ':';\n                            goto parse_rest;\n                        }\n\n                        /* But, the atomic part of a nested atomic script run\n                         * isn't a no-op, but can be treated just like a '(?>'\n                         * */\n                        paren = '>';\n                        goto parse_rest;\n                    }\n\n                    /* By doing this here, we avoid extra warnings for nested\n                     * script runs */\n                    ckWARNexperimental(RExC_parse,\n                        WARN_EXPERIMENTAL__SCRIPT_RUN,\n                        \"The script_run feature is experimental\");\n\n                    if (paren == 's') {\n                        /* Here, we're starting a new regular script run */\n                        ret = reg_node(pRExC_state, SROPEN);\n                        RExC_in_script_run = 1;\n                        is_open = 1;\n                        goto parse_rest;\n                    }\n\n                    /* Here, we are starting an atomic script run.  This is\n                     * handled by recursing to deal with the atomic portion\n                     * separately, enclosed in SROPEN ... SRCLOSE nodes */\n\n                    ret = reg_node(pRExC_state, SROPEN);\n\n                    RExC_in_script_run = 1;\n\n                    atomic = reg(pRExC_state, 'r', &flags, depth);\n                    if (flags & (RESTART_PARSE|NEED_UTF8)) {\n                        *flagp = flags & (RESTART_PARSE|NEED_UTF8);\n                        return 0;\n                    }\n\n                    if (! REGTAIL(pRExC_state, ret, atomic)) {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n\n                    if (! REGTAIL(pRExC_state, atomic, reg_node(pRExC_state,\n                                                                SRCLOSE)))\n                    {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n\n                    RExC_in_script_run = 0;\n                    return ret;\n                }\n\n                break;\n\n            lookbehind_alpha_assertions:\n                RExC_seen |= REG_LOOKBEHIND_SEEN;\n                RExC_in_lookbehind++;\n                /*FALLTHROUGH*/\n\n            alpha_assertions:\n                ckWARNexperimental(RExC_parse,\n                        WARN_EXPERIMENTAL__ALPHA_ASSERTIONS,\n                        \"The alpha_assertions feature is experimental\");\n\n                RExC_seen_zerolen++;\n\n                if (! start_arg) {\n                    goto no_colon;\n                }\n\n                /* An empty negative lookahead assertion simply is failure */\n                if (paren == 'A' && RExC_parse == start_arg) {\n                    ret=reganode(pRExC_state, OPFAIL, 0);\n                    nextchar(pRExC_state);\n                    return ret;\n\t        }\n\n                RExC_parse = start_arg;\n                goto parse_rest;\n\n              no_colon:\n                vFAIL2utf8f(\n                \"'(*%\" UTF8f \"' requires a terminating ':'\",\n                UTF8fARG(UTF, verb_len, start_verb));\n\t\tNOT_REACHED; /*NOTREACHED*/\n\n\t    } /* End of switch */\n\t    if ( ! op ) {\n\t        RExC_parse += UTF\n                              ? UTF8_SAFE_SKIP(RExC_parse, RExC_end)\n                              : 1;\n                if (has_upper || verb_len == 0) {\n                    vFAIL2utf8f(\n                    \"Unknown verb pattern '%\" UTF8f \"'\",\n                    UTF8fARG(UTF, verb_len, start_verb));\n                }\n                else {\n                    vFAIL2utf8f(\n                    \"Unknown '(*...)' construct '%\" UTF8f \"'\",\n                    UTF8fARG(UTF, verb_len, start_verb));\n                }\n\t    }\n            if ( RExC_parse == start_arg ) {\n                start_arg = NULL;\n            }\n            if ( arg_required && !start_arg ) {\n                vFAIL3(\"Verb pattern '%.*s' has a mandatory argument\",\n                    verb_len, start_verb);\n            }\n            if (internal_argval == -1) {\n                ret = reganode(pRExC_state, op, 0);\n            } else {\n                ret = reg2Lanode(pRExC_state, op, 0, internal_argval);\n            }\n            RExC_seen |= REG_VERBARG_SEEN;\n            if (start_arg) {\n                SV *sv = newSVpvn( start_arg,\n                                    RExC_parse - start_arg);\n                ARG(REGNODE_p(ret)) = add_data( pRExC_state,\n                                        STR_WITH_LEN(\"S\"));\n                RExC_rxi->data->data[ARG(REGNODE_p(ret))]=(void*)sv;\n                FLAGS(REGNODE_p(ret)) = 1;\n            } else {\n                FLAGS(REGNODE_p(ret)) = 0;\n            }\n            if ( internal_argval != -1 )\n                ARG2L_SET(REGNODE_p(ret), internal_argval);\n\t    nextchar(pRExC_state);\n\t    return ret;\n        }\n        else if (*RExC_parse == '?') { /* (?...) */\n\t    bool is_logical = 0;\n\t    const char * const seqstart = RExC_parse;\n            const char * endptr;\n            if (has_intervening_patws) {\n                RExC_parse++;\n                vFAIL(\"In '(?...)', the '(' and '?' must be adjacent\");\n            }\n\n\t    RExC_parse++;           /* past the '?' */\n            paren = *RExC_parse;    /* might be a trailing NUL, if not\n                                       well-formed */\n            RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n            if (RExC_parse > RExC_end) {\n                paren = '\\0';\n            }\n\t    ret = 0;\t\t\t/* For look-ahead/behind. */\n\t    switch (paren) {\n\n\t    case 'P':\t/* (?P...) variants for those used to PCRE/Python */\n\t        paren = *RExC_parse;\n\t\tif ( paren == '<') {    /* (?P<...>) named capture */\n                    RExC_parse++;\n                    if (RExC_parse >= RExC_end) {\n                        vFAIL(\"Sequence (?P<... not terminated\");\n                    }\n\t\t    goto named_capture;\n                }\n                else if (paren == '>') {   /* (?P>name) named recursion */\n                    RExC_parse++;\n                    if (RExC_parse >= RExC_end) {\n                        vFAIL(\"Sequence (?P>... not terminated\");\n                    }\n                    goto named_recursion;\n                }\n                else if (paren == '=') {   /* (?P=...)  named backref */\n                    RExC_parse++;\n                    return handle_named_backref(pRExC_state, flagp,\n                                                parse_start, ')');\n                }\n                RExC_parse += SKIP_IF_CHAR(RExC_parse, RExC_end);\n                /* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */\n\t\tvFAIL3(\"Sequence (%.*s...) not recognized\",\n                                RExC_parse-seqstart, seqstart);\n\t\tNOT_REACHED; /*NOTREACHED*/\n            case '<':           /* (?<...) */\n\t\tif (*RExC_parse == '!')\n\t\t    paren = ',';\n\t\telse if (*RExC_parse != '=')\n              named_capture:\n\t\t{               /* (?<...>) */\n\t\t    char *name_start;\n\t\t    SV *svname;\n\t\t    paren= '>';\n                /* FALLTHROUGH */\n            case '\\'':          /* (?'...') */\n                    name_start = RExC_parse;\n                    svname = reg_scan_name(pRExC_state, REG_RSN_RETURN_NAME);\n\t\t    if (   RExC_parse == name_start\n                        || RExC_parse >= RExC_end\n                        || *RExC_parse != paren)\n                    {\n\t\t        vFAIL2(\"Sequence (?%c... not terminated\",\n\t\t            paren=='>' ? '<' : paren);\n                    }\n\t\t    {\n\t\t\tHE *he_str;\n\t\t\tSV *sv_dat = NULL;\n                        if (!svname) /* shouldn't happen */\n                            Perl_croak(aTHX_\n                                \"panic: reg_scan_name returned NULL\");\n                        if (!RExC_paren_names) {\n                            RExC_paren_names= newHV();\n                            sv_2mortal(MUTABLE_SV(RExC_paren_names));\n#ifdef DEBUGGING\n                            RExC_paren_name_list= newAV();\n                            sv_2mortal(MUTABLE_SV(RExC_paren_name_list));\n#endif\n                        }\n                        he_str = hv_fetch_ent( RExC_paren_names, svname, 1, 0 );\n                        if ( he_str )\n                            sv_dat = HeVAL(he_str);\n                        if ( ! sv_dat ) {\n                            /* croak baby croak */\n                            Perl_croak(aTHX_\n                                \"panic: paren_name hash element allocation failed\");\n                        } else if ( SvPOK(sv_dat) ) {\n                            /* (?|...) can mean we have dupes so scan to check\n                               its already been stored. Maybe a flag indicating\n                               we are inside such a construct would be useful,\n                               but the arrays are likely to be quite small, so\n                               for now we punt -- dmq */\n                            IV count = SvIV(sv_dat);\n                            I32 *pv = (I32*)SvPVX(sv_dat);\n                            IV i;\n                            for ( i = 0 ; i < count ; i++ ) {\n                                if ( pv[i] == RExC_npar ) {\n                                    count = 0;\n                                    break;\n                                }\n                            }\n                            if ( count ) {\n                                pv = (I32*)SvGROW(sv_dat,\n                                                SvCUR(sv_dat) + sizeof(I32)+1);\n                                SvCUR_set(sv_dat, SvCUR(sv_dat) + sizeof(I32));\n                                pv[count] = RExC_npar;\n                                SvIV_set(sv_dat, SvIVX(sv_dat) + 1);\n                            }\n                        } else {\n                            (void)SvUPGRADE(sv_dat, SVt_PVNV);\n                            sv_setpvn(sv_dat, (char *)&(RExC_npar),\n                                                                sizeof(I32));\n                            SvIOK_on(sv_dat);\n                            SvIV_set(sv_dat, 1);\n                        }\n#ifdef DEBUGGING\n                        /* Yes this does cause a memory leak in debugging Perls\n                         * */\n                        if (!av_store(RExC_paren_name_list,\n                                      RExC_npar, SvREFCNT_inc_NN(svname)))\n                            SvREFCNT_dec_NN(svname);\n#endif\n\n                        /*sv_dump(sv_dat);*/\n                    }\n                    nextchar(pRExC_state);\n\t\t    paren = 1;\n\t\t    goto capturing_parens;\n\t\t}\n\n                RExC_seen |= REG_LOOKBEHIND_SEEN;\n\t\tRExC_in_lookbehind++;\n\t\tRExC_parse++;\n                if (RExC_parse >= RExC_end) {\n                    vFAIL(\"Sequence (?... not terminated\");\n                }\n\n                /* FALLTHROUGH */\n\t    case '=':           /* (?=...) */\n\t\tRExC_seen_zerolen++;\n                break;\n\t    case '!':           /* (?!...) */\n\t\tRExC_seen_zerolen++;\n\t\t/* check if we're really just a \"FAIL\" assertion */\n                skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                        FALSE /* Don't force to /x */ );\n\t        if (*RExC_parse == ')') {\n                    ret=reganode(pRExC_state, OPFAIL, 0);\n\t            nextchar(pRExC_state);\n\t            return ret;\n\t        }\n\t        break;\n\t    case '|':           /* (?|...) */\n\t        /* branch reset, behave like a (?:...) except that\n\t           buffers in alternations share the same numbers */\n\t        paren = ':';\n\t        after_freeze = freeze_paren = RExC_npar;\n\n                /* XXX This construct currently requires an extra pass.\n                 * Investigation would be required to see if that could be\n                 * changed */\n                REQUIRE_PARENS_PASS;\n\t        break;\n\t    case ':':           /* (?:...) */\n\t    case '>':           /* (?>...) */\n\t\tbreak;\n\t    case '$':           /* (?$...) */\n\t    case '@':           /* (?@...) */\n\t\tvFAIL2(\"Sequence (?%c...) not implemented\", (int)paren);\n\t\tbreak;\n\t    case '0' :           /* (?0) */\n\t    case 'R' :           /* (?R) */\n                if (RExC_parse == RExC_end || *RExC_parse != ')')\n\t\t    FAIL(\"Sequence (?R) not terminated\");\n                num = 0;\n                RExC_seen |= REG_RECURSE_SEEN;\n\n                /* XXX These constructs currently require an extra pass.\n                 * It probably could be changed */\n                REQUIRE_PARENS_PASS;\n\n\t\t*flagp |= POSTPONED;\n                goto gen_recurse_regop;\n\t\t/*notreached*/\n            /* named and numeric backreferences */\n            case '&':            /* (?&NAME) */\n                parse_start = RExC_parse - 1;\n              named_recursion:\n                {\n                    SV *sv_dat = reg_scan_name(pRExC_state,\n                                               REG_RSN_RETURN_DATA);\n                   num = sv_dat ? *((I32 *)SvPVX(sv_dat)) : 0;\n                }\n                if (RExC_parse >= RExC_end || *RExC_parse != ')')\n                    vFAIL(\"Sequence (?&... not terminated\");\n                goto gen_recurse_regop;\n                /* NOTREACHED */\n            case '+':\n                if (! inRANGE(RExC_parse[0], '1', '9')) {\n                    RExC_parse++;\n                    vFAIL(\"Illegal pattern\");\n                }\n                goto parse_recursion;\n                /* NOTREACHED*/\n            case '-': /* (?-1) */\n                if (! inRANGE(RExC_parse[0], '1', '9')) {\n                    RExC_parse--; /* rewind to let it be handled later */\n                    goto parse_flags;\n                }\n                /* FALLTHROUGH */\n            case '1': case '2': case '3': case '4': /* (?1) */\n\t    case '5': case '6': case '7': case '8': case '9':\n\t        RExC_parse = (char *) seqstart + 1;  /* Point to the digit */\n              parse_recursion:\n                {\n                    bool is_neg = FALSE;\n                    UV unum;\n                    parse_start = RExC_parse - 1; /* MJD */\n                    if (*RExC_parse == '-') {\n                        RExC_parse++;\n                        is_neg = TRUE;\n                    }\n                    endptr = RExC_end;\n                    if (grok_atoUV(RExC_parse, &unum, &endptr)\n                        && unum <= I32_MAX\n                    ) {\n                        num = (I32)unum;\n                        RExC_parse = (char*)endptr;\n                    } else\n                        num = I32_MAX;\n                    if (is_neg) {\n                        /* Some limit for num? */\n                        num = -num;\n                    }\n                }\n\t        if (*RExC_parse!=')')\n\t            vFAIL(\"Expecting close bracket\");\n\n              gen_recurse_regop:\n                if ( paren == '-' ) {\n                    /*\n                    Diagram of capture buffer numbering.\n                    Top line is the normal capture buffer numbers\n                    Bottom line is the negative indexing as from\n                    the X (the (?-2))\n\n                    +   1 2    3 4 5 X          6 7\n                       /(a(x)y)(a(b(c(?-2)d)e)f)(g(h))/\n                    -   5 4    3 2 1 X          x x\n\n                    */\n                    num = RExC_npar + num;\n                    if (num < 1)  {\n\n                        /* It might be a forward reference; we can't fail until\n                         * we know, by completing the parse to get all the\n                         * groups, and then reparsing */\n                        if (ALL_PARENS_COUNTED)  {\n                            RExC_parse++;\n                            vFAIL(\"Reference to nonexistent group\");\n                        }\n                        else {\n                            REQUIRE_PARENS_PASS;\n                        }\n                    }\n                } else if ( paren == '+' ) {\n                    num = RExC_npar + num - 1;\n                }\n                /* We keep track how many GOSUB items we have produced.\n                   To start off the ARG2L() of the GOSUB holds its \"id\",\n                   which is used later in conjunction with RExC_recurse\n                   to calculate the offset we need to jump for the GOSUB,\n                   which it will store in the final representation.\n                   We have to defer the actual calculation until much later\n                   as the regop may move.\n                 */\n\n                ret = reg2Lanode(pRExC_state, GOSUB, num, RExC_recurse_count);\n                if (num >= RExC_npar) {\n\n                    /* It might be a forward reference; we can't fail until we\n                     * know, by completing the parse to get all the groups, and\n                     * then reparsing */\n                    if (ALL_PARENS_COUNTED)  {\n                        if (num >= RExC_total_parens) {\n                            RExC_parse++;\n                            vFAIL(\"Reference to nonexistent group\");\n                        }\n                    }\n                    else {\n                        REQUIRE_PARENS_PASS;\n                    }\n                }\n                RExC_recurse_count++;\n                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                    \"%*s%*s Recurse #%\" UVuf \" to %\" IVdf \"\\n\",\n                            22, \"|    |\", (int)(depth * 2 + 1), \"\",\n                            (UV)ARG(REGNODE_p(ret)),\n                            (IV)ARG2L(REGNODE_p(ret))));\n                RExC_seen |= REG_RECURSE_SEEN;\n\n                Set_Node_Length(REGNODE_p(ret),\n                                1 + regarglen[OP(REGNODE_p(ret))]); /* MJD */\n\t\tSet_Node_Offset(REGNODE_p(ret), parse_start); /* MJD */\n\n                *flagp |= POSTPONED;\n                assert(*RExC_parse == ')');\n                nextchar(pRExC_state);\n                return ret;\n\n            /* NOTREACHED */\n\n\t    case '?':           /* (??...) */\n\t\tis_logical = 1;\n\t\tif (*RExC_parse != '{') {\n                    RExC_parse += SKIP_IF_CHAR(RExC_parse, RExC_end);\n                    /* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */\n                    vFAIL2utf8f(\n                        \"Sequence (%\" UTF8f \"...) not recognized\",\n                        UTF8fARG(UTF, RExC_parse-seqstart, seqstart));\n\t\t    NOT_REACHED; /*NOTREACHED*/\n\t\t}\n\t\t*flagp |= POSTPONED;\n\t\tparen = '{';\n                RExC_parse++;\n\t\t/* FALLTHROUGH */\n\t    case '{':           /* (?{...}) */\n\t    {\n\t\tU32 n = 0;\n\t\tstruct reg_code_block *cb;\n                OP * o;\n\n\t\tRExC_seen_zerolen++;\n\n\t\tif (   !pRExC_state->code_blocks\n\t\t    || pRExC_state->code_index\n                                        >= pRExC_state->code_blocks->count\n\t\t    || pRExC_state->code_blocks->cb[pRExC_state->code_index].start\n\t\t\t!= (STRLEN)((RExC_parse -3 - (is_logical ? 1 : 0))\n\t\t\t    - RExC_start)\n\t\t) {\n\t\t    if (RExC_pm_flags & PMf_USE_RE_EVAL)\n\t\t\tFAIL(\"panic: Sequence (?{...}): no code block found\\n\");\n\t\t    FAIL(\"Eval-group not allowed at runtime, use re 'eval'\");\n\t\t}\n\t\t/* this is a pre-compiled code block (?{...}) */\n\t\tcb = &pRExC_state->code_blocks->cb[pRExC_state->code_index];\n\t\tRExC_parse = RExC_start + cb->end;\n\t\to = cb->block;\n                if (cb->src_regex) {\n                    n = add_data(pRExC_state, STR_WITH_LEN(\"rl\"));\n                    RExC_rxi->data->data[n] =\n                        (void*)SvREFCNT_inc((SV*)cb->src_regex);\n                    RExC_rxi->data->data[n+1] = (void*)o;\n                }\n                else {\n                    n = add_data(pRExC_state,\n                            (RExC_pm_flags & PMf_HAS_CV) ? \"L\" : \"l\", 1);\n                    RExC_rxi->data->data[n] = (void*)o;\n                }\n\t\tpRExC_state->code_index++;\n\t\tnextchar(pRExC_state);\n\n\t\tif (is_logical) {\n                    regnode_offset eval;\n\t\t    ret = reg_node(pRExC_state, LOGICAL);\n\n                    eval = reg2Lanode(pRExC_state, EVAL,\n                                       n,\n\n                                       /* for later propagation into (??{})\n                                        * return value */\n                                       RExC_flags & RXf_PMf_COMPILETIME\n                                      );\n                    FLAGS(REGNODE_p(ret)) = 2;\n                    if (! REGTAIL(pRExC_state, ret, eval)) {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n                    /* deal with the length of this later - MJD */\n\t\t    return ret;\n\t\t}\n\t\tret = reg2Lanode(pRExC_state, EVAL, n, 0);\n\t\tSet_Node_Length(REGNODE_p(ret), RExC_parse - parse_start + 1);\n\t\tSet_Node_Offset(REGNODE_p(ret), parse_start);\n\t\treturn ret;\n\t    }\n\t    case '(':           /* (?(?{...})...) and (?(?=...)...) */\n\t    {\n\t        int is_define= 0;\n                const int DEFINE_len = sizeof(\"DEFINE\") - 1;\n\t\tif (    RExC_parse < RExC_end - 1\n                    && (   (       RExC_parse[0] == '?'        /* (?(?...)) */\n                            && (   RExC_parse[1] == '='\n                                || RExC_parse[1] == '!'\n                                || RExC_parse[1] == '<'\n                                || RExC_parse[1] == '{'))\n\t\t        || (       RExC_parse[0] == '*'        /* (?(*...)) */\n                            && (   memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"pla:\")\n                                || memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"plb:\")\n                                || memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"nla:\")\n                                || memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"nlb:\")\n                                || memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"positive_lookahead:\")\n                                || memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"positive_lookbehind:\")\n                                || memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"negative_lookahead:\")\n                                || memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"negative_lookbehind:\"))))\n                ) { /* Lookahead or eval. */\n                    I32 flag;\n                    regnode_offset tail;\n\n                    ret = reg_node(pRExC_state, LOGICAL);\n                    FLAGS(REGNODE_p(ret)) = 1;\n\n                    tail = reg(pRExC_state, 1, &flag, depth+1);\n                    RETURN_FAIL_ON_RESTART(flag, flagp);\n                    if (! REGTAIL(pRExC_state, ret, tail)) {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n                    goto insert_if;\n                }\n\t\telse if (   RExC_parse[0] == '<'     /* (?(<NAME>)...) */\n\t\t         || RExC_parse[0] == '\\'' ) /* (?('NAME')...) */\n\t        {\n\t            char ch = RExC_parse[0] == '<' ? '>' : '\\'';\n\t            char *name_start= RExC_parse++;\n\t            U32 num = 0;\n\t            SV *sv_dat=reg_scan_name(pRExC_state, REG_RSN_RETURN_DATA);\n\t            if (   RExC_parse == name_start\n                        || RExC_parse >= RExC_end\n                        || *RExC_parse != ch)\n                    {\n                        vFAIL2(\"Sequence (?(%c... not terminated\",\n                            (ch == '>' ? '<' : ch));\n                    }\n                    RExC_parse++;\n                    if (sv_dat) {\n                        num = add_data( pRExC_state, STR_WITH_LEN(\"S\"));\n                        RExC_rxi->data->data[num]=(void*)sv_dat;\n                        SvREFCNT_inc_simple_void_NN(sv_dat);\n                    }\n                    ret = reganode(pRExC_state, NGROUPP, num);\n                    goto insert_if_check_paren;\n\t\t}\n\t\telse if (memBEGINs(RExC_parse,\n                                   (STRLEN) (RExC_end - RExC_parse),\n                                   \"DEFINE\"))\n                {\n\t\t    ret = reganode(pRExC_state, DEFINEP, 0);\n\t\t    RExC_parse += DEFINE_len;\n\t\t    is_define = 1;\n\t\t    goto insert_if_check_paren;\n\t\t}\n\t\telse if (RExC_parse[0] == 'R') {\n\t\t    RExC_parse++;\n                    /* parno == 0 => /(?(R)YES|NO)/  \"in any form of recursion OR eval\"\n                     * parno == 1 => /(?(R0)YES|NO)/ \"in GOSUB (?0) / (?R)\"\n                     * parno == 2 => /(?(R1)YES|NO)/ \"in GOSUB (?1) (parno-1)\"\n                     */\n\t\t    parno = 0;\n                    if (RExC_parse[0] == '0') {\n                        parno = 1;\n                        RExC_parse++;\n                    }\n                    else if (inRANGE(RExC_parse[0], '1', '9')) {\n                        UV uv;\n                        endptr = RExC_end;\n                        if (grok_atoUV(RExC_parse, &uv, &endptr)\n                            && uv <= I32_MAX\n                        ) {\n                            parno = (I32)uv + 1;\n                            RExC_parse = (char*)endptr;\n                        }\n                        /* else \"Switch condition not recognized\" below */\n\t\t    } else if (RExC_parse[0] == '&') {\n\t\t        SV *sv_dat;\n\t\t        RExC_parse++;\n\t\t        sv_dat = reg_scan_name(pRExC_state,\n                                               REG_RSN_RETURN_DATA);\n                        if (sv_dat)\n                            parno = 1 + *((I32 *)SvPVX(sv_dat));\n\t\t    }\n\t\t    ret = reganode(pRExC_state, INSUBP, parno);\n\t\t    goto insert_if_check_paren;\n\t\t}\n                else if (inRANGE(RExC_parse[0], '1', '9')) {\n                    /* (?(1)...) */\n\t\t    char c;\n                    UV uv;\n                    endptr = RExC_end;\n                    if (grok_atoUV(RExC_parse, &uv, &endptr)\n                        && uv <= I32_MAX\n                    ) {\n                        parno = (I32)uv;\n                        RExC_parse = (char*)endptr;\n                    }\n                    else {\n                        vFAIL(\"panic: grok_atoUV returned FALSE\");\n                    }\n                    ret = reganode(pRExC_state, GROUPP, parno);\n\n                 insert_if_check_paren:\n\t\t    if (UCHARAT(RExC_parse) != ')') {\n                        RExC_parse += UTF\n                                      ? UTF8_SAFE_SKIP(RExC_parse, RExC_end)\n                                      : 1;\n\t\t\tvFAIL(\"Switch condition not recognized\");\n\t\t    }\n\t\t    nextchar(pRExC_state);\n\t\t  insert_if:\n                    if (! REGTAIL(pRExC_state, ret, reganode(pRExC_state,\n                                                             IFTHEN, 0)))\n                    {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n                    br = regbranch(pRExC_state, &flags, 1, depth+1);\n\t\t    if (br == 0) {\n                        RETURN_FAIL_ON_RESTART(flags,flagp);\n                        FAIL2(\"panic: regbranch returned failure, flags=%#\" UVxf,\n                              (UV) flags);\n                    } else\n                    if (! REGTAIL(pRExC_state, br, reganode(pRExC_state,\n                                                             LONGJMP, 0)))\n                    {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n\t\t    c = UCHARAT(RExC_parse);\n                    nextchar(pRExC_state);\n\t\t    if (flags&HASWIDTH)\n\t\t\t*flagp |= HASWIDTH;\n\t\t    if (c == '|') {\n\t\t        if (is_define)\n\t\t            vFAIL(\"(?(DEFINE)....) does not allow branches\");\n\n                        /* Fake one for optimizer.  */\n                        lastbr = reganode(pRExC_state, IFTHEN, 0);\n\n                        if (!regbranch(pRExC_state, &flags, 1, depth+1)) {\n                            RETURN_FAIL_ON_RESTART(flags, flagp);\n                            FAIL2(\"panic: regbranch returned failure, flags=%#\" UVxf,\n                                  (UV) flags);\n                        }\n                        if (! REGTAIL(pRExC_state, ret, lastbr)) {\n                            REQUIRE_BRANCHJ(flagp, 0);\n                        }\n\t\t \tif (flags&HASWIDTH)\n\t\t\t    *flagp |= HASWIDTH;\n                        c = UCHARAT(RExC_parse);\n                        nextchar(pRExC_state);\n\t\t    }\n\t\t    else\n\t\t\tlastbr = 0;\n                    if (c != ')') {\n                        if (RExC_parse >= RExC_end)\n                            vFAIL(\"Switch (?(condition)... not terminated\");\n                        else\n                            vFAIL(\"Switch (?(condition)... contains too many branches\");\n                    }\n\t\t    ender = reg_node(pRExC_state, TAIL);\n                    if (! REGTAIL(pRExC_state, br, ender)) {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n\t\t    if (lastbr) {\n                        if (! REGTAIL(pRExC_state, lastbr, ender)) {\n                            REQUIRE_BRANCHJ(flagp, 0);\n                        }\n                        if (! REGTAIL(pRExC_state,\n                                      REGNODE_OFFSET(\n                                                 NEXTOPER(\n                                                 NEXTOPER(REGNODE_p(lastbr)))),\n                                      ender))\n                        {\n                            REQUIRE_BRANCHJ(flagp, 0);\n                        }\n\t\t    }\n\t\t    else\n                        if (! REGTAIL(pRExC_state, ret, ender)) {\n                            REQUIRE_BRANCHJ(flagp, 0);\n                        }\n#if 0  /* Removing this doesn't cause failures in the test suite -- khw */\n                    RExC_size++; /* XXX WHY do we need this?!!\n                                    For large programs it seems to be required\n                                    but I can't figure out why. -- dmq*/\n#endif\n\t\t    return ret;\n\t\t}\n                RExC_parse += UTF\n                              ? UTF8_SAFE_SKIP(RExC_parse, RExC_end)\n                              : 1;\n                vFAIL(\"Unknown switch condition (?(...))\");\n\t    }\n\t    case '[':           /* (?[ ... ]) */\n                return handle_regex_sets(pRExC_state, NULL, flagp, depth+1,\n                                         oregcomp_parse);\n            case 0: /* A NUL */\n\t\tRExC_parse--; /* for vFAIL to print correctly */\n                vFAIL(\"Sequence (? incomplete\");\n                break;\n\n            case ')':\n                if (RExC_strict) {  /* [perl #132851] */\n                    ckWARNreg(RExC_parse, \"Empty (?) without any modifiers\");\n                }\n                /* FALLTHROUGH */\n\t    default: /* e.g., (?i) */\n\t        RExC_parse = (char *) seqstart + 1;\n              parse_flags:\n\t\tparse_lparen_question_flags(pRExC_state);\n                if (UCHARAT(RExC_parse) != ':') {\n                    if (RExC_parse < RExC_end)\n                        nextchar(pRExC_state);\n                    *flagp = TRYAGAIN;\n                    return 0;\n                }\n                paren = ':';\n                nextchar(pRExC_state);\n                ret = 0;\n                goto parse_rest;\n            } /* end switch */\n\t}\n\telse {\n            if (*RExC_parse == '{') {\n                ckWARNregdep(RExC_parse + 1,\n                            \"Unescaped left brace in regex is \"\n                            \"deprecated here (and will be fatal \"\n                            \"in Perl 5.32), passed through\");\n            }\n            /* Not bothering to indent here, as the above 'else' is temporary\n             * */\n        if (!(RExC_flags & RXf_PMf_NOCAPTURE)) {   /* (...) */\n\t  capturing_parens:\n\t    parno = RExC_npar;\n\t    RExC_npar++;\n            if (! ALL_PARENS_COUNTED) {\n                /* If we are in our first pass through (and maybe only pass),\n                 * we  need to allocate memory for the capturing parentheses\n                 * data structures.\n                 */\n\n                if (!RExC_parens_buf_size) {\n                    /* first guess at number of parens we might encounter */\n                    RExC_parens_buf_size = 10;\n\n                    /* setup RExC_open_parens, which holds the address of each\n                     * OPEN tag, and to make things simpler for the 0 index the\n                     * start of the program - this is used later for offsets */\n                    Newxz(RExC_open_parens, RExC_parens_buf_size,\n                            regnode_offset);\n                    RExC_open_parens[0] = 1;    /* +1 for REG_MAGIC */\n\n                    /* setup RExC_close_parens, which holds the address of each\n                     * CLOSE tag, and to make things simpler for the 0 index\n                     * the end of the program - this is used later for offsets\n                     * */\n                    Newxz(RExC_close_parens, RExC_parens_buf_size,\n                            regnode_offset);\n                    /* we dont know where end op starts yet, so we dont need to\n                     * set RExC_close_parens[0] like we do RExC_open_parens[0]\n                     * above */\n                }\n                else if (RExC_npar > RExC_parens_buf_size) {\n                    I32 old_size = RExC_parens_buf_size;\n\n                    RExC_parens_buf_size *= 2;\n\n                    Renew(RExC_open_parens, RExC_parens_buf_size,\n                            regnode_offset);\n                    Zero(RExC_open_parens + old_size,\n                            RExC_parens_buf_size - old_size, regnode_offset);\n\n                    Renew(RExC_close_parens, RExC_parens_buf_size,\n                            regnode_offset);\n                    Zero(RExC_close_parens + old_size,\n                            RExC_parens_buf_size - old_size, regnode_offset);\n                }\n            }\n\n\t    ret = reganode(pRExC_state, OPEN, parno);\n            if (!RExC_nestroot)\n                RExC_nestroot = parno;\n            if (RExC_open_parens && !RExC_open_parens[parno])\n            {\n                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                    \"%*s%*s Setting open paren #%\" IVdf \" to %d\\n\",\n                    22, \"|    |\", (int)(depth * 2 + 1), \"\",\n                    (IV)parno, ret));\n                RExC_open_parens[parno]= ret;\n            }\n\n            Set_Node_Length(REGNODE_p(ret), 1); /* MJD */\n            Set_Node_Offset(REGNODE_p(ret), RExC_parse); /* MJD */\n\t    is_open = 1;\n\t} else {\n            /* with RXf_PMf_NOCAPTURE treat (...) as (?:...) */\n            paren = ':';\n\t    ret = 0;\n\t}\n        }\n    }\n    else                        /* ! paren */\n\tret = 0;\n\n   parse_rest:\n    /* Pick up the branches, linking them together. */\n    parse_start = RExC_parse;   /* MJD */\n    br = regbranch(pRExC_state, &flags, 1, depth+1);\n\n    /*     branch_len = (paren != 0); */\n\n    if (br == 0) {\n        RETURN_FAIL_ON_RESTART(flags, flagp);\n        FAIL2(\"panic: regbranch returned failure, flags=%#\" UVxf, (UV) flags);\n    }\n    if (*RExC_parse == '|') {\n\tif (RExC_use_BRANCHJ) {\n\t    reginsert(pRExC_state, BRANCHJ, br, depth+1);\n\t}\n\telse {                  /* MJD */\n\t    reginsert(pRExC_state, BRANCH, br, depth+1);\n            Set_Node_Length(REGNODE_p(br), paren != 0);\n            Set_Node_Offset_To_R(br, parse_start-RExC_start);\n        }\n\thave_branch = 1;\n    }\n    else if (paren == ':') {\n\t*flagp |= flags&SIMPLE;\n    }\n    if (is_open) {\t\t\t\t/* Starts with OPEN. */\n        if (! REGTAIL(pRExC_state, ret, br)) {  /* OPEN -> first. */\n            REQUIRE_BRANCHJ(flagp, 0);\n        }\n    }\n    else if (paren != '?')\t\t/* Not Conditional */\n\tret = br;\n    *flagp |= flags & (SPSTART | HASWIDTH | POSTPONED);\n    lastbr = br;\n    while (*RExC_parse == '|') {\n\tif (RExC_use_BRANCHJ) {\n            bool shut_gcc_up;\n\n\t    ender = reganode(pRExC_state, LONGJMP, 0);\n\n            /* Append to the previous. */\n            shut_gcc_up = REGTAIL(pRExC_state,\n                         REGNODE_OFFSET(NEXTOPER(NEXTOPER(REGNODE_p(lastbr)))),\n                         ender);\n            PERL_UNUSED_VAR(shut_gcc_up);\n\t}\n\tnextchar(pRExC_state);\n\tif (freeze_paren) {\n\t    if (RExC_npar > after_freeze)\n\t        after_freeze = RExC_npar;\n            RExC_npar = freeze_paren;\n        }\n        br = regbranch(pRExC_state, &flags, 0, depth+1);\n\n\tif (br == 0) {\n            RETURN_FAIL_ON_RESTART(flags, flagp);\n            FAIL2(\"panic: regbranch returned failure, flags=%#\" UVxf, (UV) flags);\n        }\n        if (!  REGTAIL(pRExC_state, lastbr, br)) {  /* BRANCH -> BRANCH. */\n            REQUIRE_BRANCHJ(flagp, 0);\n        }\n\tlastbr = br;\n\t*flagp |= flags & (SPSTART | HASWIDTH | POSTPONED);\n    }\n\n    if (have_branch || paren != ':') {\n        regnode * br;\n\n\t/* Make a closing node, and hook it on the end. */\n\tswitch (paren) {\n\tcase ':':\n\t    ender = reg_node(pRExC_state, TAIL);\n\t    break;\n\tcase 1: case 2:\n\t    ender = reganode(pRExC_state, CLOSE, parno);\n            if ( RExC_close_parens ) {\n                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                        \"%*s%*s Setting close paren #%\" IVdf \" to %d\\n\",\n                        22, \"|    |\", (int)(depth * 2 + 1), \"\",\n                        (IV)parno, ender));\n                RExC_close_parens[parno]= ender;\n\t        if (RExC_nestroot == parno)\n\t            RExC_nestroot = 0;\n\t    }\n            Set_Node_Offset(REGNODE_p(ender), RExC_parse+1); /* MJD */\n            Set_Node_Length(REGNODE_p(ender), 1); /* MJD */\n\t    break;\n\tcase 's':\n\t    ender = reg_node(pRExC_state, SRCLOSE);\n            RExC_in_script_run = 0;\n\t    break;\n\tcase '<':\n        case 'a':\n        case 'A':\n        case 'b':\n        case 'B':\n\tcase ',':\n\tcase '=':\n\tcase '!':\n\t    *flagp &= ~HASWIDTH;\n\t    /* FALLTHROUGH */\n        case 't':   /* aTomic */\n\tcase '>':\n\t    ender = reg_node(pRExC_state, SUCCEED);\n\t    break;\n\tcase 0:\n\t    ender = reg_node(pRExC_state, END);\n            assert(!RExC_end_op); /* there can only be one! */\n            RExC_end_op = REGNODE_p(ender);\n            if (RExC_close_parens) {\n                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                    \"%*s%*s Setting close paren #0 (END) to %d\\n\",\n                    22, \"|    |\", (int)(depth * 2 + 1), \"\",\n                    ender));\n\n                RExC_close_parens[0]= ender;\n            }\n\t    break;\n\t}\n        DEBUG_PARSE_r({\n            DEBUG_PARSE_MSG(\"lsbr\");\n            regprop(RExC_rx, RExC_mysv1, REGNODE_p(lastbr), NULL, pRExC_state);\n            regprop(RExC_rx, RExC_mysv2, REGNODE_p(ender), NULL, pRExC_state);\n            Perl_re_printf( aTHX_  \"~ tying lastbr %s (%\" IVdf \") to ender %s (%\" IVdf \") offset %\" IVdf \"\\n\",\n                          SvPV_nolen_const(RExC_mysv1),\n                          (IV)lastbr,\n                          SvPV_nolen_const(RExC_mysv2),\n                          (IV)ender,\n                          (IV)(ender - lastbr)\n            );\n        });\n        if (! REGTAIL(pRExC_state, lastbr, ender)) {\n            REQUIRE_BRANCHJ(flagp, 0);\n        }\n\n\tif (have_branch) {\n            char is_nothing= 1;\n\t    if (depth==1)\n                RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;\n\n\t    /* Hook the tails of the branches to the closing node. */\n\t    for (br = REGNODE_p(ret); br; br = regnext(br)) {\n\t\tconst U8 op = PL_regkind[OP(br)];\n\t\tif (op == BRANCH) {\n                    if (! REGTAIL_STUDY(pRExC_state,\n                                        REGNODE_OFFSET(NEXTOPER(br)),\n                                        ender))\n                    {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n                    if ( OP(NEXTOPER(br)) != NOTHING\n                         || regnext(NEXTOPER(br)) != REGNODE_p(ender))\n                        is_nothing= 0;\n\t\t}\n\t\telse if (op == BRANCHJ) {\n                    bool shut_gcc_up = REGTAIL_STUDY(pRExC_state,\n                                        REGNODE_OFFSET(NEXTOPER(NEXTOPER(br))),\n                                        ender);\n                    PERL_UNUSED_VAR(shut_gcc_up);\n                    /* for now we always disable this optimisation * /\n                    if ( OP(NEXTOPER(NEXTOPER(br))) != NOTHING\n                         || regnext(NEXTOPER(NEXTOPER(br))) != REGNODE_p(ender))\n                    */\n                        is_nothing= 0;\n\t\t}\n\t    }\n            if (is_nothing) {\n                regnode * ret_as_regnode = REGNODE_p(ret);\n                br= PL_regkind[OP(ret_as_regnode)] != BRANCH\n                               ? regnext(ret_as_regnode)\n                               : ret_as_regnode;\n                DEBUG_PARSE_r({\n                    DEBUG_PARSE_MSG(\"NADA\");\n                    regprop(RExC_rx, RExC_mysv1, ret_as_regnode,\n                                     NULL, pRExC_state);\n                    regprop(RExC_rx, RExC_mysv2, REGNODE_p(ender),\n                                     NULL, pRExC_state);\n                    Perl_re_printf( aTHX_  \"~ converting ret %s (%\" IVdf \") to ender %s (%\" IVdf \") offset %\" IVdf \"\\n\",\n                                  SvPV_nolen_const(RExC_mysv1),\n                                  (IV)REG_NODE_NUM(ret_as_regnode),\n                                  SvPV_nolen_const(RExC_mysv2),\n                                  (IV)ender,\n                                  (IV)(ender - ret)\n                    );\n                });\n                OP(br)= NOTHING;\n                if (OP(REGNODE_p(ender)) == TAIL) {\n                    NEXT_OFF(br)= 0;\n                    RExC_emit= REGNODE_OFFSET(br) + 1;\n                } else {\n                    regnode *opt;\n                    for ( opt= br + 1; opt < REGNODE_p(ender) ; opt++ )\n                        OP(opt)= OPTIMIZED;\n                    NEXT_OFF(br)= REGNODE_p(ender) - br;\n                }\n            }\n\t}\n    }\n\n    {\n        const char *p;\n         /* Even/odd or x=don't care: 010101x10x */\n        static const char parens[] = \"=!aA<,>Bbt\";\n         /* flag below is set to 0 up through 'A'; 1 for larger */\n\n\tif (paren && (p = strchr(parens, paren))) {\n\t    U8 node = ((p - parens) % 2) ? UNLESSM : IFMATCH;\n\t    int flag = (p - parens) > 3;\n\n\t    if (paren == '>' || paren == 't') {\n\t\tnode = SUSPEND, flag = 0;\n            }\n\n\t    reginsert(pRExC_state, node, ret, depth+1);\n            Set_Node_Cur_Length(REGNODE_p(ret), parse_start);\n\t    Set_Node_Offset(REGNODE_p(ret), parse_start + 1);\n\t    FLAGS(REGNODE_p(ret)) = flag;\n            if (! REGTAIL_STUDY(pRExC_state, ret, reg_node(pRExC_state, TAIL)))\n            {\n                REQUIRE_BRANCHJ(flagp, 0);\n            }\n\t}\n    }\n\n    /* Check for proper termination. */\n    if (paren) {\n        /* restore original flags, but keep (?p) and, if we've encountered\n         * something in the parse that changes /d rules into /u, keep the /u */\n\tRExC_flags = oregflags | (RExC_flags & RXf_PMf_KEEPCOPY);\n        if (DEPENDS_SEMANTICS && RExC_uni_semantics) {\n            set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);\n        }\n\tif (RExC_parse >= RExC_end || UCHARAT(RExC_parse) != ')') {\n\t    RExC_parse = oregcomp_parse;\n\t    vFAIL(\"Unmatched (\");\n\t}\n\tnextchar(pRExC_state);\n    }\n    else if (!paren && RExC_parse < RExC_end) {\n\tif (*RExC_parse == ')') {\n\t    RExC_parse++;\n\t    vFAIL(\"Unmatched )\");\n\t}\n\telse\n\t    FAIL(\"Junk on end of regexp\");\t/* \"Can't happen\". */\n\tNOT_REACHED; /* NOTREACHED */\n    }\n\n    if (RExC_in_lookbehind) {\n\tRExC_in_lookbehind--;\n    }\n    if (after_freeze > RExC_npar)\n        RExC_npar = after_freeze;\n    return(ret);\n}\n\n/*\n - regbranch - one alternative of an | operator\n *\n * Implements the concatenation operator.\n *\n * On success, returns the offset at which any next node should be placed into\n * the regex engine program being compiled.\n *\n * Returns 0 otherwise, setting flagp to RESTART_PARSE if the parse needs\n * to be restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to\n * UTF-8\n */\nSTATIC regnode_offset\nS_regbranch(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, I32 first, U32 depth)\n{\n    regnode_offset ret;\n    regnode_offset chain = 0;\n    regnode_offset latest;\n    I32 flags = 0, c = 0;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGBRANCH;\n\n    DEBUG_PARSE(\"brnc\");\n\n    if (first)\n\tret = 0;\n    else {\n\tif (RExC_use_BRANCHJ)\n\t    ret = reganode(pRExC_state, BRANCHJ, 0);\n\telse {\n\t    ret = reg_node(pRExC_state, BRANCH);\n            Set_Node_Length(REGNODE_p(ret), 1);\n        }\n    }\n\n    *flagp = WORST;\t\t\t/* Tentatively. */\n\n    skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                            FALSE /* Don't force to /x */ );\n    while (RExC_parse < RExC_end && *RExC_parse != '|' && *RExC_parse != ')') {\n\tflags &= ~TRYAGAIN;\n        latest = regpiece(pRExC_state, &flags, depth+1);\n\tif (latest == 0) {\n\t    if (flags & TRYAGAIN)\n\t\tcontinue;\n            RETURN_FAIL_ON_RESTART(flags, flagp);\n            FAIL2(\"panic: regpiece returned failure, flags=%#\" UVxf, (UV) flags);\n\t}\n\telse if (ret == 0)\n            ret = latest;\n\t*flagp |= flags&(HASWIDTH|POSTPONED);\n\tif (chain == 0) \t/* First piece. */\n\t    *flagp |= flags&SPSTART;\n\telse {\n\t    /* FIXME adding one for every branch after the first is probably\n\t     * excessive now we have TRIE support. (hv) */\n\t    MARK_NAUGHTY(1);\n            if (! REGTAIL(pRExC_state, chain, latest)) {\n                /* XXX We could just redo this branch, but figuring out what\n                 * bookkeeping needs to be reset is a pain, and it's likely\n                 * that other branches that goto END will also be too large */\n                REQUIRE_BRANCHJ(flagp, 0);\n            }\n\t}\n\tchain = latest;\n\tc++;\n    }\n    if (chain == 0) {\t/* Loop ran zero times. */\n\tchain = reg_node(pRExC_state, NOTHING);\n\tif (ret == 0)\n\t    ret = chain;\n    }\n    if (c == 1) {\n\t*flagp |= flags&SIMPLE;\n    }\n\n    return ret;\n}\n\n/*\n - regpiece - something followed by possible quantifier * + ? {n,m}\n *\n * Note that the branching code sequences used for ? and the general cases\n * of * and + are somewhat optimized:  they use the same NOTHING node as\n * both the endmarker for their branch list and the body of the last branch.\n * It might seem that this node could be dispensed with entirely, but the\n * endmarker role is not redundant.\n *\n * On success, returns the offset at which any next node should be placed into\n * the regex engine program being compiled.\n *\n * Returns 0 otherwise, with *flagp set to indicate why:\n *  TRYAGAIN        if regatom() returns 0 with TRYAGAIN.\n *  RESTART_PARSE   if the parse needs to be restarted, or'd with\n *                  NEED_UTF8 if the pattern needs to be upgraded to UTF-8.\n */\nSTATIC regnode_offset\nS_regpiece(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)\n{\n    regnode_offset ret;\n    char op;\n    char *next;\n    I32 flags;\n    const char * const origparse = RExC_parse;\n    I32 min;\n    I32 max = REG_INFTY;\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    char *parse_start;\n#endif\n    const char *maxpos = NULL;\n    UV uv;\n\n    /* Save the original in case we change the emitted regop to a FAIL. */\n    const regnode_offset orig_emit = RExC_emit;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGPIECE;\n\n    DEBUG_PARSE(\"piec\");\n\n    ret = regatom(pRExC_state, &flags, depth+1);\n    if (ret == 0) {\n        RETURN_FAIL_ON_RESTART_OR_FLAGS(flags, flagp, TRYAGAIN);\n        FAIL2(\"panic: regatom returned failure, flags=%#\" UVxf, (UV) flags);\n    }\n\n    op = *RExC_parse;\n\n    if (op == '{' && regcurly(RExC_parse)) {\n\tmaxpos = NULL;\n#ifdef RE_TRACK_PATTERN_OFFSETS\n        parse_start = RExC_parse; /* MJD */\n#endif\n\tnext = RExC_parse + 1;\n\twhile (isDIGIT(*next) || *next == ',') {\n\t    if (*next == ',') {\n\t\tif (maxpos)\n\t\t    break;\n\t\telse\n\t\t    maxpos = next;\n\t    }\n\t    next++;\n\t}\n\tif (*next == '}') {\t\t/* got one */\n            const char* endptr;\n\t    if (!maxpos)\n\t\tmaxpos = next;\n\t    RExC_parse++;\n            if (isDIGIT(*RExC_parse)) {\n                endptr = RExC_end;\n                if (!grok_atoUV(RExC_parse, &uv, &endptr))\n                    vFAIL(\"Invalid quantifier in {,}\");\n                if (uv >= REG_INFTY)\n                    vFAIL2(\"Quantifier in {,} bigger than %d\", REG_INFTY - 1);\n                min = (I32)uv;\n            } else {\n                min = 0;\n            }\n\t    if (*maxpos == ',')\n\t\tmaxpos++;\n\t    else\n\t\tmaxpos = RExC_parse;\n            if (isDIGIT(*maxpos)) {\n                endptr = RExC_end;\n                if (!grok_atoUV(maxpos, &uv, &endptr))\n                    vFAIL(\"Invalid quantifier in {,}\");\n                if (uv >= REG_INFTY)\n                    vFAIL2(\"Quantifier in {,} bigger than %d\", REG_INFTY - 1);\n                max = (I32)uv;\n            } else {\n\t\tmax = REG_INFTY;\t\t/* meaning \"infinity\" */\n            }\n\t    RExC_parse = next;\n\t    nextchar(pRExC_state);\n            if (max < min) {    /* If can't match, warn and optimize to fail\n                                   unconditionally */\n                reginsert(pRExC_state, OPFAIL, orig_emit, depth+1);\n                ckWARNreg(RExC_parse, \"Quantifier {n,m} with n > m can't match\");\n                NEXT_OFF(REGNODE_p(orig_emit)) =\n                                    regarglen[OPFAIL] + NODE_STEP_REGNODE;\n                return ret;\n            }\n            else if (min == max && *RExC_parse == '?')\n            {\n                ckWARN2reg(RExC_parse + 1,\n                           \"Useless use of greediness modifier '%c'\",\n                           *RExC_parse);\n            }\n\n\t  do_curly:\n\t    if ((flags&SIMPLE)) {\n                if (min == 0 && max == REG_INFTY) {\n                    reginsert(pRExC_state, STAR, ret, depth+1);\n                    MARK_NAUGHTY(4);\n                    RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;\n                    goto nest_check;\n                }\n                if (min == 1 && max == REG_INFTY) {\n                    reginsert(pRExC_state, PLUS, ret, depth+1);\n                    MARK_NAUGHTY(3);\n                    RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;\n                    goto nest_check;\n                }\n                MARK_NAUGHTY_EXP(2, 2);\n\t\treginsert(pRExC_state, CURLY, ret, depth+1);\n                Set_Node_Offset(REGNODE_p(ret), parse_start+1); /* MJD */\n                Set_Node_Cur_Length(REGNODE_p(ret), parse_start);\n\t    }\n\t    else {\n\t\tconst regnode_offset w = reg_node(pRExC_state, WHILEM);\n\n\t\tFLAGS(REGNODE_p(w)) = 0;\n                if (!  REGTAIL(pRExC_state, ret, w)) {\n                    REQUIRE_BRANCHJ(flagp, 0);\n                }\n\t\tif (RExC_use_BRANCHJ) {\n\t\t    reginsert(pRExC_state, LONGJMP, ret, depth+1);\n\t\t    reginsert(pRExC_state, NOTHING, ret, depth+1);\n\t\t    NEXT_OFF(REGNODE_p(ret)) = 3;\t/* Go over LONGJMP. */\n\t\t}\n\t\treginsert(pRExC_state, CURLYX, ret, depth+1);\n                                /* MJD hk */\n                Set_Node_Offset(REGNODE_p(ret), parse_start+1);\n                Set_Node_Length(REGNODE_p(ret),\n                                op == '{' ? (RExC_parse - parse_start) : 1);\n\n\t\tif (RExC_use_BRANCHJ)\n                    NEXT_OFF(REGNODE_p(ret)) = 3;   /* Go over NOTHING to\n                                                       LONGJMP. */\n                if (! REGTAIL(pRExC_state, ret, reg_node(pRExC_state,\n                                                          NOTHING)))\n                {\n                    REQUIRE_BRANCHJ(flagp, 0);\n                }\n                RExC_whilem_seen++;\n                MARK_NAUGHTY_EXP(1, 4);     /* compound interest */\n\t    }\n\t    FLAGS(REGNODE_p(ret)) = 0;\n\n\t    if (min > 0)\n\t\t*flagp = WORST;\n\t    if (max > 0)\n\t\t*flagp |= HASWIDTH;\n            ARG1_SET(REGNODE_p(ret), (U16)min);\n            ARG2_SET(REGNODE_p(ret), (U16)max);\n            if (max == REG_INFTY)\n                RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;\n\n\t    goto nest_check;\n\t}\n    }\n\n    if (!ISMULT1(op)) {\n\t*flagp = flags;\n\treturn(ret);\n    }\n\n#if 0\t\t\t\t/* Now runtime fix should be reliable. */\n\n    /* if this is reinstated, don't forget to put this back into perldiag:\n\n\t    =item Regexp *+ operand could be empty at {#} in regex m/%s/\n\n\t   (F) The part of the regexp subject to either the * or + quantifier\n           could match an empty string. The {#} shows in the regular\n           expression about where the problem was discovered.\n\n    */\n\n    if (!(flags&HASWIDTH) && op != '?')\n      vFAIL(\"Regexp *+ operand could be empty\");\n#endif\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    parse_start = RExC_parse;\n#endif\n    nextchar(pRExC_state);\n\n    *flagp = (op != '+') ? (WORST|SPSTART|HASWIDTH) : (WORST|HASWIDTH);\n\n    if (op == '*') {\n\tmin = 0;\n\tgoto do_curly;\n    }\n    else if (op == '+') {\n\tmin = 1;\n\tgoto do_curly;\n    }\n    else if (op == '?') {\n\tmin = 0; max = 1;\n\tgoto do_curly;\n    }\n  nest_check:\n    if (!(flags&(HASWIDTH|POSTPONED)) && max > REG_INFTY/3) {\n\tckWARN2reg(RExC_parse,\n\t\t   \"%\" UTF8f \" matches null string many times\",\n\t\t   UTF8fARG(UTF, (RExC_parse >= origparse\n                                 ? RExC_parse - origparse\n                                 : 0),\n\t\t   origparse));\n    }\n\n    if (*RExC_parse == '?') {\n\tnextchar(pRExC_state);\n\treginsert(pRExC_state, MINMOD, ret, depth+1);\n        if (! REGTAIL(pRExC_state, ret, ret + NODE_STEP_REGNODE)) {\n            REQUIRE_BRANCHJ(flagp, 0);\n        }\n    }\n    else if (*RExC_parse == '+') {\n        regnode_offset ender;\n        nextchar(pRExC_state);\n        ender = reg_node(pRExC_state, SUCCEED);\n        if (! REGTAIL(pRExC_state, ret, ender)) {\n            REQUIRE_BRANCHJ(flagp, 0);\n        }\n        reginsert(pRExC_state, SUSPEND, ret, depth+1);\n        ender = reg_node(pRExC_state, TAIL);\n        if (! REGTAIL(pRExC_state, ret, ender)) {\n            REQUIRE_BRANCHJ(flagp, 0);\n        }\n    }\n\n    if (ISMULT2(RExC_parse)) {\n\tRExC_parse++;\n\tvFAIL(\"Nested quantifiers\");\n    }\n\n    return(ret);\n}\n\nSTATIC bool\nS_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state,\n                regnode_offset * node_p,\n                UV * code_point_p,\n                int * cp_count,\n                I32 * flagp,\n                const bool strict,\n                const U32 depth\n    )\n{\n /* This routine teases apart the various meanings of \\N and returns\n  * accordingly.  The input parameters constrain which meaning(s) is/are valid\n  * in the current context.\n  *\n  * Exactly one of <node_p> and <code_point_p> must be non-NULL.\n  *\n  * If <code_point_p> is not NULL, the context is expecting the result to be a\n  * single code point.  If this \\N instance turns out to a single code point,\n  * the function returns TRUE and sets *code_point_p to that code point.\n  *\n  * If <node_p> is not NULL, the context is expecting the result to be one of\n  * the things representable by a regnode.  If this \\N instance turns out to be\n  * one such, the function generates the regnode, returns TRUE and sets *node_p\n  * to point to the offset of that regnode into the regex engine program being\n  * compiled.\n  *\n  * If this instance of \\N isn't legal in any context, this function will\n  * generate a fatal error and not return.\n  *\n  * On input, RExC_parse should point to the first char following the \\N at the\n  * time of the call.  On successful return, RExC_parse will have been updated\n  * to point to just after the sequence identified by this routine.  Also\n  * *flagp has been updated as needed.\n  *\n  * When there is some problem with the current context and this \\N instance,\n  * the function returns FALSE, without advancing RExC_parse, nor setting\n  * *node_p, nor *code_point_p, nor *flagp.\n  *\n  * If <cp_count> is not NULL, the caller wants to know the length (in code\n  * points) that this \\N sequence matches.  This is set, and the input is\n  * parsed for errors, even if the function returns FALSE, as detailed below.\n  *\n  * There are 6 possibilities here, as detailed in the next 6 paragraphs.\n  *\n  * Probably the most common case is for the \\N to specify a single code point.\n  * *cp_count will be set to 1, and *code_point_p will be set to that code\n  * point.\n  *\n  * Another possibility is for the input to be an empty \\N{}.  This is no\n  * longer accepted, and will generate a fatal error.\n  *\n  * Another possibility is for a custom charnames handler to be in effect which\n  * translates the input name to an empty string.  *cp_count will be set to 0.\n  * *node_p will be set to a generated NOTHING node.\n  *\n  * Still another possibility is for the \\N to mean [^\\n]. *cp_count will be\n  * set to 0. *node_p will be set to a generated REG_ANY node.\n  *\n  * The fifth possibility is that \\N resolves to a sequence of more than one\n  * code points.  *cp_count will be set to the number of code points in the\n  * sequence. *node_p will be set to a generated node returned by this\n  * function calling S_reg().\n  *\n  * The final possibility is that it is premature to be calling this function;\n  * the parse needs to be restarted.  This can happen when this changes from\n  * /d to /u rules, or when the pattern needs to be upgraded to UTF-8.  The\n  * latter occurs only when the fifth possibility would otherwise be in\n  * effect, and is because one of those code points requires the pattern to be\n  * recompiled as UTF-8.  The function returns FALSE, and sets the\n  * RESTART_PARSE and NEED_UTF8 flags in *flagp, as appropriate.  When this\n  * happens, the caller needs to desist from continuing parsing, and return\n  * this information to its caller.  This is not set for when there is only one\n  * code point, as this can be called as part of an ANYOF node, and they can\n  * store above-Latin1 code points without the pattern having to be in UTF-8.\n  *\n  * For non-single-quoted regexes, the tokenizer has resolved character and\n  * sequence names inside \\N{...} into their Unicode values, normalizing the\n  * result into what we should see here: '\\N{U+c1.c2...}', where c1... are the\n  * hex-represented code points in the sequence.  This is done there because\n  * the names can vary based on what charnames pragma is in scope at the time,\n  * so we need a way to take a snapshot of what they resolve to at the time of\n  * the original parse. [perl #56444].\n  *\n  * That parsing is skipped for single-quoted regexes, so here we may get\n  * '\\N{NAME}', which is parsed now.  If the single-quoted regex is something\n  * like '\\N{U+41}', that code point is Unicode, and has to be translated into\n  * the native character set for non-ASCII platforms.  The other possibilities\n  * are already native, so no translation is done. */\n\n    char * endbrace;    /* points to '}' following the name */\n    char* p = RExC_parse; /* Temporary */\n\n    SV * substitute_parse = NULL;\n    char *orig_end;\n    char *save_start;\n    I32 flags;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_GROK_BSLASH_N;\n\n    GET_RE_DEBUG_FLAGS;\n\n    assert(cBOOL(node_p) ^ cBOOL(code_point_p));  /* Exactly one should be set */\n    assert(! (node_p && cp_count));               /* At most 1 should be set */\n\n    if (cp_count) {     /* Initialize return for the most common case */\n        *cp_count = 1;\n    }\n\n    /* The [^\\n] meaning of \\N ignores spaces and comments under the /x\n     * modifier.  The other meanings do not, so use a temporary until we find\n     * out which we are being called with */\n    skip_to_be_ignored_text(pRExC_state, &p,\n                            FALSE /* Don't force to /x */ );\n\n    /* Disambiguate between \\N meaning a named character versus \\N meaning\n     * [^\\n].  The latter is assumed when the {...} following the \\N is a legal\n     * quantifier, or if there is no '{' at all */\n    if (*p != '{' || regcurly(p)) {\n        RExC_parse = p;\n        if (cp_count) {\n            *cp_count = -1;\n        }\n\n        if (! node_p) {\n            return FALSE;\n        }\n\n        *node_p = reg_node(pRExC_state, REG_ANY);\n        *flagp |= HASWIDTH|SIMPLE;\n        MARK_NAUGHTY(1);\n        Set_Node_Length(REGNODE_p(*(node_p)), 1); /* MJD */\n        return TRUE;\n    }\n\n    /* The test above made sure that the next real character is a '{', but\n     * under the /x modifier, it could be separated by space (or a comment and\n     * \\n) and this is not allowed (for consistency with \\x{...} and the\n     * tokenizer handling of \\N{NAME}). */\n    if (*RExC_parse != '{') {\n        vFAIL(\"Missing braces on \\\\N{}\");\n    }\n\n    RExC_parse++;       /* Skip past the '{' */\n\n    endbrace = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n    if (! endbrace) { /* no trailing brace */\n        vFAIL2(\"Missing right brace on \\\\%c{}\", 'N');\n    }\n\n    /* Here, we have decided it should be a named character or sequence.  These\n     * imply Unicode semantics */\n    REQUIRE_UNI_RULES(flagp, FALSE);\n\n    /* \\N{_} is what toke.c returns to us to indicate a name that evaluates to\n     * nothing at all (not allowed under strict) */\n    if (endbrace - RExC_parse == 1 && *RExC_parse == '_') {\n        RExC_parse = endbrace;\n        if (strict) {\n            RExC_parse++;   /* Position after the \"}\" */\n            vFAIL(\"Zero length \\\\N{}\");\n        }\n\n        if (cp_count) {\n            *cp_count = 0;\n        }\n        nextchar(pRExC_state);\n        if (! node_p) {\n            return FALSE;\n        }\n\n        *node_p = reg_node(pRExC_state, NOTHING);\n        return TRUE;\n    }\n\n    if (endbrace - RExC_parse < 2 || ! strBEGINs(RExC_parse, \"U+\")) {\n\n        /* Here, the name isn't of the form  U+....  This can happen if the\n         * pattern is single-quoted, so didn't get evaluated in toke.c.  Now\n         * is the time to find out what the name means */\n\n        const STRLEN name_len = endbrace - RExC_parse;\n        SV *  value_sv;     /* What does this name evaluate to */\n        SV ** value_svp;\n        const U8 * value;   /* string of name's value */\n        STRLEN value_len;   /* and its length */\n\n        /*  RExC_unlexed_names is a hash of names that weren't evaluated by\n         *  toke.c, and their values. Make sure is initialized */\n        if (! RExC_unlexed_names) {\n            RExC_unlexed_names = newHV();\n        }\n\n        /* If we have already seen this name in this pattern, use that.  This\n         * allows us to only call the charnames handler once per name per\n         * pattern.  A broken or malicious handler could return something\n         * different each time, which could cause the results to vary depending\n         * on if something gets added or subtracted from the pattern that\n         * causes the number of passes to change, for example */\n        if ((value_svp = hv_fetch(RExC_unlexed_names, RExC_parse,\n                                                      name_len, 0)))\n        {\n            value_sv = *value_svp;\n        }\n        else { /* Otherwise we have to go out and get the name */\n            const char * error_msg = NULL;\n            value_sv = get_and_check_backslash_N_name(RExC_parse, endbrace,\n                                                      UTF,\n                                                      &error_msg);\n            if (error_msg) {\n                RExC_parse = endbrace;\n                vFAIL(error_msg);\n            }\n\n            /* If no error message, should have gotten a valid return */\n            assert (value_sv);\n\n            /* Save the name's meaning for later use */\n            if (! hv_store(RExC_unlexed_names, RExC_parse, name_len,\n                           value_sv, 0))\n            {\n                Perl_croak(aTHX_ \"panic: hv_store() unexpectedly failed\");\n            }\n        }\n\n        /* Here, we have the value the name evaluates to in 'value_sv' */\n        value = (U8 *) SvPV(value_sv, value_len);\n\n        /* See if the result is one code point vs 0 or multiple */\n        if (value_len > 0 && value_len <= (UV) ((SvUTF8(value_sv))\n                                               ? UTF8SKIP(value)\n                                               : 1))\n        {\n            /* Here, exactly one code point.  If that isn't what is wanted,\n             * fail */\n            if (! code_point_p) {\n                RExC_parse = p;\n                return FALSE;\n            }\n\n            /* Convert from string to numeric code point */\n            *code_point_p = (SvUTF8(value_sv))\n                            ? valid_utf8_to_uvchr(value, NULL)\n                            : *value;\n\n            /* Have parsed this entire single code point \\N{...}.  *cp_count\n             * has already been set to 1, so don't do it again. */\n            RExC_parse = endbrace;\n            nextchar(pRExC_state);\n            return TRUE;\n        } /* End of is a single code point */\n\n        /* Count the code points, if caller desires.  The API says to do this\n         * even if we will later return FALSE */\n        if (cp_count) {\n            *cp_count = 0;\n\n            *cp_count = (SvUTF8(value_sv))\n                        ? utf8_length(value, value + value_len)\n                        : value_len;\n        }\n\n        /* Fail if caller doesn't want to handle a multi-code-point sequence.\n         * But don't back the pointer up if the caller wants to know how many\n         * code points there are (they need to handle it themselves in this\n         * case).  */\n        if (! node_p) {\n            if (! cp_count) {\n                RExC_parse = p;\n            }\n            return FALSE;\n        }\n\n        /* Convert this to a sub-pattern of the form \"(?: ... )\", and then call\n         * reg recursively to parse it.  That way, it retains its atomicness,\n         * while not having to worry about any special handling that some code\n         * points may have. */\n\n        substitute_parse = newSVpvs(\"?:\");\n        sv_catsv(substitute_parse, value_sv);\n        sv_catpv(substitute_parse, \")\");\n\n#ifdef EBCDIC\n        /* The value should already be native, so no need to convert on EBCDIC\n         * platforms.*/\n        assert(! RExC_recode_x_to_native);\n#endif\n\n    }\n    else {   /* \\N{U+...} */\n        Size_t count = 0;   /* code point count kept internally */\n\n        /* We can get to here when the input is \\N{U+...} or when toke.c has\n         * converted a name to the \\N{U+...} form.  This include changing a\n         * name that evaluates to multiple code points to \\N{U+c1.c2.c3 ...} */\n\n        RExC_parse += 2;    /* Skip past the 'U+' */\n\n        /* Code points are separated by dots.  The '}' terminates the whole\n         * thing. */\n\n        do {    /* Loop until the ending brace */\n            UV cp = 0;\n            char * start_digit;     /* The first of the current code point */\n            if (! isXDIGIT(*RExC_parse)) {\n                RExC_parse++;\n                vFAIL(\"Invalid hexadecimal number in \\\\N{U+...}\");\n            }\n\n            start_digit = RExC_parse;\n            count++;\n\n            /* Loop through the hex digits of the current code point */\n            do {\n                /* Adding this digit will shift the result 4 bits.  If that\n                 * result would be above the legal max, it's overflow */\n                if (cp > MAX_LEGAL_CP >> 4) {\n\n                    /* Find the end of the code point */\n                    do {\n                        RExC_parse ++;\n                    } while (isXDIGIT(*RExC_parse) || *RExC_parse == '_');\n\n                    /* Be sure to synchronize this message with the similar one\n                     * in utf8.c */\n                    vFAIL4(\"Use of code point 0x%.*s is not allowed; the\"\n                        \" permissible max is 0x%\" UVxf,\n                        (int) (RExC_parse - start_digit), start_digit,\n                        MAX_LEGAL_CP);\n                }\n\n                /* Accumulate this (valid) digit into the running total */\n                cp  = (cp << 4) + READ_XDIGIT(RExC_parse);\n\n                /* READ_XDIGIT advanced the input pointer.  Ignore a single\n                 * underscore separator */\n                if (*RExC_parse == '_' && isXDIGIT(RExC_parse[1])) {\n                    RExC_parse++;\n                }\n            } while (isXDIGIT(*RExC_parse));\n\n            /* Here, have accumulated the next code point */\n            if (RExC_parse >= endbrace) {   /* If done ... */\n                if (count != 1) {\n                    goto do_concat;\n                }\n\n                /* Here, is a single code point; fail if doesn't want that */\n                if (! code_point_p) {\n                    RExC_parse = p;\n                    return FALSE;\n                }\n\n                /* A single code point is easy to handle; just return it */\n                *code_point_p = UNI_TO_NATIVE(cp);\n                RExC_parse = endbrace;\n                nextchar(pRExC_state);\n                return TRUE;\n            }\n\n            /* Here, the only legal thing would be a multiple character\n             * sequence (of the form \"\\N{U+c1.c2. ... }\".   So the next\n             * character must be a dot (and the one after that can't be the\n             * endbrace, or we'd have something like \\N{U+100.} ) */\n            if (*RExC_parse != '.' || RExC_parse + 1 >= endbrace) {\n                RExC_parse += (RExC_orig_utf8)  /* point to after 1st invalid */\n                                ? UTF8SKIP(RExC_parse)\n                                : 1;\n                if (RExC_parse >= endbrace) { /* Guard against malformed utf8 */\n                    RExC_parse = endbrace;\n                }\n                vFAIL(\"Invalid hexadecimal number in \\\\N{U+...}\");\n            }\n\n            /* Here, looks like its really a multiple character sequence.  Fail\n             * if that's not what the caller wants.  But continue with counting\n             * and error checking if they still want a count */\n            if (! node_p && ! cp_count) {\n                return FALSE;\n            }\n\n            /* What is done here is to convert this to a sub-pattern of the\n             * form \\x{char1}\\x{char2}...  and then call reg recursively to\n             * parse it (enclosing in \"(?: ... )\" ).  That way, it retains its\n             * atomicness, while not having to worry about special handling\n             * that some code points may have.  We don't create a subpattern,\n             * but go through the motions of code point counting and error\n             * checking, if the caller doesn't want a node returned. */\n\n            if (node_p && count == 1) {\n                substitute_parse = newSVpvs(\"?:\");\n            }\n\n          do_concat:\n\n            if (node_p) {\n                /* Convert to notation the rest of the code understands */\n                sv_catpvs(substitute_parse, \"\\\\x{\");\n                sv_catpvn(substitute_parse, start_digit,\n                                            RExC_parse - start_digit);\n                sv_catpvs(substitute_parse, \"}\");\n            }\n\n            /* Move to after the dot (or ending brace the final time through.)\n             * */\n            RExC_parse++;\n            count++;\n\n        } while (RExC_parse < endbrace);\n\n        if (! node_p) { /* Doesn't want the node */\n            assert (cp_count);\n\n            *cp_count = count;\n            return FALSE;\n        }\n\n        sv_catpvs(substitute_parse, \")\");\n\n#ifdef EBCDIC\n        /* The values are Unicode, and therefore have to be converted to native\n         * on a non-Unicode (meaning non-ASCII) platform. */\n        RExC_recode_x_to_native = 1;\n#endif\n\n    }\n\n    /* Here, we have the string the name evaluates to, ready to be parsed,\n     * stored in 'substitute_parse' as a series of valid \"\\x{...}\\x{...}\"\n     * constructs.  This can be called from within a substitute parse already.\n     * The error reporting mechanism doesn't work for 2 levels of this, but the\n     * code above has validated this new construct, so there should be no\n     * errors generated by the below.  And this isn' an exact copy, so the\n     * mechanism to seamlessly deal with this won't work, so turn off warnings\n     * during it */\n    save_start = RExC_start;\n    orig_end = RExC_end;\n\n    RExC_parse = RExC_start = SvPVX(substitute_parse);\n    RExC_end = RExC_parse + SvCUR(substitute_parse);\n    TURN_OFF_WARNINGS_IN_SUBSTITUTE_PARSE;\n\n    *node_p = reg(pRExC_state, 1, &flags, depth+1);\n\n    /* Restore the saved values */\n    RESTORE_WARNINGS;\n    RExC_start = save_start;\n    RExC_parse = endbrace;\n    RExC_end = orig_end;\n#ifdef EBCDIC\n    RExC_recode_x_to_native = 0;\n#endif\n\n    SvREFCNT_dec_NN(substitute_parse);\n\n    if (! *node_p) {\n        RETURN_FAIL_ON_RESTART(flags, flagp);\n        FAIL2(\"panic: reg returned failure to grok_bslash_N, flags=%#\" UVxf,\n            (UV) flags);\n    }\n    *flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);\n\n    nextchar(pRExC_state);\n\n    return TRUE;\n}\n\n\nPERL_STATIC_INLINE U8\nS_compute_EXACTish(RExC_state_t *pRExC_state)\n{\n    U8 op;\n\n    PERL_ARGS_ASSERT_COMPUTE_EXACTISH;\n\n    if (! FOLD) {\n        return (LOC)\n                ? EXACTL\n                : EXACT;\n    }\n\n    op = get_regex_charset(RExC_flags);\n    if (op >= REGEX_ASCII_RESTRICTED_CHARSET) {\n        op--; /* /a is same as /u, and map /aa's offset to what /a's would have\n                 been, so there is no hole */\n    }\n\n    return op + EXACTF;\n}\n\nSTATIC bool\nS_new_regcurly(const char *s, const char *e)\n{\n    /* This is a temporary function designed to match the most lenient form of\n     * a {m,n} quantifier we ever envision, with either number omitted, and\n     * spaces anywhere between/before/after them.\n     *\n     * If this function fails, then the string it matches is very unlikely to\n     * ever be considered a valid quantifier, so we can allow the '{' that\n     * begins it to be considered as a literal */\n\n    bool has_min = FALSE;\n    bool has_max = FALSE;\n\n    PERL_ARGS_ASSERT_NEW_REGCURLY;\n\n    if (s >= e || *s++ != '{')\n\treturn FALSE;\n\n    while (s < e && isSPACE(*s)) {\n        s++;\n    }\n    while (s < e && isDIGIT(*s)) {\n        has_min = TRUE;\n        s++;\n    }\n    while (s < e && isSPACE(*s)) {\n        s++;\n    }\n\n    if (*s == ',') {\n\ts++;\n        while (s < e && isSPACE(*s)) {\n            s++;\n        }\n        while (s < e && isDIGIT(*s)) {\n            has_max = TRUE;\n            s++;\n        }\n        while (s < e && isSPACE(*s)) {\n            s++;\n        }\n    }\n\n    return s < e && *s == '}' && (has_min || has_max);\n}\n\n/* Parse backref decimal value, unless it's too big to sensibly be a backref,\n * in which case return I32_MAX (rather than possibly 32-bit wrapping) */\n\nstatic I32\nS_backref_value(char *p, char *e)\n{\n    const char* endptr = e;\n    UV val;\n    if (grok_atoUV(p, &val, &endptr) && val <= I32_MAX)\n        return (I32)val;\n    return I32_MAX;\n}\n\n\n/*\n - regatom - the lowest level\n\n   Try to identify anything special at the start of the current parse position.\n   If there is, then handle it as required. This may involve generating a\n   single regop, such as for an assertion; or it may involve recursing, such as\n   to handle a () structure.\n\n   If the string doesn't start with something special then we gobble up\n   as much literal text as we can.  If we encounter a quantifier, we have to\n   back off the final literal character, as that quantifier applies to just it\n   and not to the whole string of literals.\n\n   Once we have been able to handle whatever type of thing started the\n   sequence, we return the offset into the regex engine program being compiled\n   at which any  next regnode should be placed.\n\n   Returns 0, setting *flagp to TRYAGAIN if reg() returns 0 with TRYAGAIN.\n   Returns 0, setting *flagp to RESTART_PARSE if the parse needs to be\n   restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to UTF-8\n   Otherwise does not return 0.\n\n   Note: we have to be careful with escapes, as they can be both literal\n   and special, and in the case of \\10 and friends, context determines which.\n\n   A summary of the code structure is:\n\n   switch (first_byte) {\n\tcases for each special:\n\t    handle this special;\n\t    break;\n\tcase '\\\\':\n\t    switch (2nd byte) {\n\t\tcases for each unambiguous special:\n\t\t    handle this special;\n\t\t    break;\n\t\tcases for each ambigous special/literal:\n\t\t    disambiguate;\n\t\t    if (special)  handle here\n\t\t    else goto defchar;\n\t\tdefault: // unambiguously literal:\n\t\t    goto defchar;\n\t    }\n\tdefault:  // is a literal char\n\t    // FALL THROUGH\n\tdefchar:\n\t    create EXACTish node for literal;\n\t    while (more input and node isn't full) {\n\t\tswitch (input_byte) {\n\t\t   cases for each special;\n                       make sure parse pointer is set so that the next call to\n                           regatom will see this special first\n                       goto loopdone; // EXACTish node terminated by prev. char\n\t\t   default:\n\t\t       append char to EXACTISH node;\n\t\t}\n\t        get next input byte;\n\t    }\n        loopdone:\n   }\n   return the generated node;\n\n   Specifically there are two separate switches for handling\n   escape sequences, with the one for handling literal escapes requiring\n   a dummy entry for all of the special escapes that are actually handled\n   by the other.\n\n*/\n\nSTATIC regnode_offset\nS_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)\n{\n    dVAR;\n    regnode_offset ret = 0;\n    I32 flags = 0;\n    char *parse_start;\n    U8 op;\n    int invert = 0;\n    U8 arg;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    *flagp = WORST;\t\t/* Tentatively. */\n\n    DEBUG_PARSE(\"atom\");\n\n    PERL_ARGS_ASSERT_REGATOM;\n\n  tryagain:\n    parse_start = RExC_parse;\n    assert(RExC_parse < RExC_end);\n    switch ((U8)*RExC_parse) {\n    case '^':\n\tRExC_seen_zerolen++;\n\tnextchar(pRExC_state);\n\tif (RExC_flags & RXf_PMf_MULTILINE)\n\t    ret = reg_node(pRExC_state, MBOL);\n\telse\n\t    ret = reg_node(pRExC_state, SBOL);\n        Set_Node_Length(REGNODE_p(ret), 1); /* MJD */\n\tbreak;\n    case '$':\n\tnextchar(pRExC_state);\n\tif (*RExC_parse)\n\t    RExC_seen_zerolen++;\n\tif (RExC_flags & RXf_PMf_MULTILINE)\n\t    ret = reg_node(pRExC_state, MEOL);\n\telse\n\t    ret = reg_node(pRExC_state, SEOL);\n        Set_Node_Length(REGNODE_p(ret), 1); /* MJD */\n\tbreak;\n    case '.':\n\tnextchar(pRExC_state);\n\tif (RExC_flags & RXf_PMf_SINGLELINE)\n\t    ret = reg_node(pRExC_state, SANY);\n\telse\n\t    ret = reg_node(pRExC_state, REG_ANY);\n\t*flagp |= HASWIDTH|SIMPLE;\n\tMARK_NAUGHTY(1);\n        Set_Node_Length(REGNODE_p(ret), 1); /* MJD */\n\tbreak;\n    case '[':\n    {\n\tchar * const oregcomp_parse = ++RExC_parse;\n        ret = regclass(pRExC_state, flagp, depth+1,\n                       FALSE, /* means parse the whole char class */\n                       TRUE, /* allow multi-char folds */\n                       FALSE, /* don't silence non-portable warnings. */\n                       (bool) RExC_strict,\n                       TRUE, /* Allow an optimized regnode result */\n                       NULL);\n        if (ret == 0) {\n            RETURN_FAIL_ON_RESTART_FLAGP(flagp);\n            FAIL2(\"panic: regclass returned failure to regatom, flags=%#\" UVxf,\n                  (UV) *flagp);\n        }\n\tif (*RExC_parse != ']') {\n\t    RExC_parse = oregcomp_parse;\n\t    vFAIL(\"Unmatched [\");\n\t}\n\tnextchar(pRExC_state);\n        Set_Node_Length(REGNODE_p(ret), RExC_parse - oregcomp_parse + 1); /* MJD */\n\tbreak;\n    }\n    case '(':\n\tnextchar(pRExC_state);\n        ret = reg(pRExC_state, 2, &flags, depth+1);\n\tif (ret == 0) {\n\t\tif (flags & TRYAGAIN) {\n\t\t    if (RExC_parse >= RExC_end) {\n\t\t\t /* Make parent create an empty node if needed. */\n\t\t\t*flagp |= TRYAGAIN;\n\t\t\treturn(0);\n\t\t    }\n\t\t    goto tryagain;\n\t\t}\n                RETURN_FAIL_ON_RESTART(flags, flagp);\n                FAIL2(\"panic: reg returned failure to regatom, flags=%#\" UVxf,\n                                                                 (UV) flags);\n\t}\n\t*flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);\n\tbreak;\n    case '|':\n    case ')':\n\tif (flags & TRYAGAIN) {\n\t    *flagp |= TRYAGAIN;\n\t    return 0;\n\t}\n\tvFAIL(\"Internal urp\");\n\t\t\t\t/* Supposed to be caught earlier. */\n\tbreak;\n    case '?':\n    case '+':\n    case '*':\n\tRExC_parse++;\n\tvFAIL(\"Quantifier follows nothing\");\n\tbreak;\n    case '\\\\':\n\t/* Special Escapes\n\n\t   This switch handles escape sequences that resolve to some kind\n\t   of special regop and not to literal text. Escape sequences that\n\t   resolve to literal text are handled below in the switch marked\n\t   \"Literal Escapes\".\n\n\t   Every entry in this switch *must* have a corresponding entry\n\t   in the literal escape switch. However, the opposite is not\n\t   required, as the default for this switch is to jump to the\n\t   literal text handling code.\n\t*/\n\tRExC_parse++;\n\tswitch ((U8)*RExC_parse) {\n\t/* Special Escapes */\n\tcase 'A':\n\t    RExC_seen_zerolen++;\n\t    ret = reg_node(pRExC_state, SBOL);\n            /* SBOL is shared with /^/ so we set the flags so we can tell\n             * /\\A/ from /^/ in split. */\n            FLAGS(REGNODE_p(ret)) = 1;\n\t    *flagp |= SIMPLE;\n\t    goto finish_meta_pat;\n\tcase 'G':\n\t    ret = reg_node(pRExC_state, GPOS);\n            RExC_seen |= REG_GPOS_SEEN;\n\t    *flagp |= SIMPLE;\n\t    goto finish_meta_pat;\n\tcase 'K':\n\t    RExC_seen_zerolen++;\n\t    ret = reg_node(pRExC_state, KEEPS);\n\t    *flagp |= SIMPLE;\n\t    /* XXX:dmq : disabling in-place substitution seems to\n\t     * be necessary here to avoid cases of memory corruption, as\n\t     * with: C<$_=\"x\" x 80; s/x\\K/y/> -- rgs\n\t     */\n            RExC_seen |= REG_LOOKBEHIND_SEEN;\n\t    goto finish_meta_pat;\n\tcase 'Z':\n\t    ret = reg_node(pRExC_state, SEOL);\n\t    *flagp |= SIMPLE;\n\t    RExC_seen_zerolen++;\t\t/* Do not optimize RE away */\n\t    goto finish_meta_pat;\n\tcase 'z':\n\t    ret = reg_node(pRExC_state, EOS);\n\t    *flagp |= SIMPLE;\n\t    RExC_seen_zerolen++;\t\t/* Do not optimize RE away */\n\t    goto finish_meta_pat;\n\tcase 'C':\n\t    vFAIL(\"\\\\C no longer supported\");\n\tcase 'X':\n\t    ret = reg_node(pRExC_state, CLUMP);\n\t    *flagp |= HASWIDTH;\n\t    goto finish_meta_pat;\n\n\tcase 'W':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'w':\n            arg = ANYOF_WORDCHAR;\n            goto join_posix;\n\n\tcase 'B':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'b':\n          {\n            U8 flags = 0;\n\t    regex_charset charset = get_regex_charset(RExC_flags);\n\n\t    RExC_seen_zerolen++;\n            RExC_seen |= REG_LOOKBEHIND_SEEN;\n\t    op = BOUND + charset;\n\n\t    if (RExC_parse >= RExC_end || *(RExC_parse + 1) != '{') {\n                flags = TRADITIONAL_BOUND;\n                if (op > BOUNDA) {  /* /aa is same as /a */\n                    op = BOUNDA;\n                }\n            }\n            else {\n                STRLEN length;\n                char name = *RExC_parse;\n                char * endbrace = NULL;\n                RExC_parse += 2;\n                endbrace = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n\n                if (! endbrace) {\n                    vFAIL2(\"Missing right brace on \\\\%c{}\", name);\n                }\n                /* XXX Need to decide whether to take spaces or not.  Should be\n                 * consistent with \\p{}, but that currently is SPACE, which\n                 * means vertical too, which seems wrong\n                 * while (isBLANK(*RExC_parse)) {\n                    RExC_parse++;\n                }*/\n                if (endbrace == RExC_parse) {\n                    RExC_parse++;  /* After the '}' */\n                    vFAIL2(\"Empty \\\\%c{}\", name);\n                }\n                length = endbrace - RExC_parse;\n                /*while (isBLANK(*(RExC_parse + length - 1))) {\n                    length--;\n                }*/\n                switch (*RExC_parse) {\n                    case 'g':\n                        if (    length != 1\n                            && (memNEs(RExC_parse + 1, length - 1, \"cb\")))\n                        {\n                            goto bad_bound_type;\n                        }\n                        flags = GCB_BOUND;\n                        break;\n                    case 'l':\n                        if (length != 2 || *(RExC_parse + 1) != 'b') {\n                            goto bad_bound_type;\n                        }\n                        flags = LB_BOUND;\n                        break;\n                    case 's':\n                        if (length != 2 || *(RExC_parse + 1) != 'b') {\n                            goto bad_bound_type;\n                        }\n                        flags = SB_BOUND;\n                        break;\n                    case 'w':\n                        if (length != 2 || *(RExC_parse + 1) != 'b') {\n                            goto bad_bound_type;\n                        }\n                        flags = WB_BOUND;\n                        break;\n                    default:\n                      bad_bound_type:\n                        RExC_parse = endbrace;\n\t\t\tvFAIL2utf8f(\n                            \"'%\" UTF8f \"' is an unknown bound type\",\n\t\t\t    UTF8fARG(UTF, length, endbrace - length));\n                        NOT_REACHED; /*NOTREACHED*/\n                }\n                RExC_parse = endbrace;\n                REQUIRE_UNI_RULES(flagp, 0);\n\n                if (op == BOUND) {\n                    op = BOUNDU;\n                }\n                else if (op >= BOUNDA) {  /* /aa is same as /a */\n                    op = BOUNDU;\n                    length += 4;\n\n                    /* Don't have to worry about UTF-8, in this message because\n                     * to get here the contents of the \\b must be ASCII */\n                    ckWARN4reg(RExC_parse + 1,  /* Include the '}' in msg */\n                              \"Using /u for '%.*s' instead of /%s\",\n                              (unsigned) length,\n                              endbrace - length + 1,\n                              (charset == REGEX_ASCII_RESTRICTED_CHARSET)\n                              ? ASCII_RESTRICT_PAT_MODS\n                              : ASCII_MORE_RESTRICT_PAT_MODS);\n                }\n\t    }\n\n            if (op == BOUND) {\n                RExC_seen_d_op = TRUE;\n            }\n            else if (op == BOUNDL) {\n                RExC_contains_locale = 1;\n            }\n\n            if (invert) {\n                op += NBOUND - BOUND;\n            }\n\n\t    ret = reg_node(pRExC_state, op);\n            FLAGS(REGNODE_p(ret)) = flags;\n\n\t    *flagp |= SIMPLE;\n\n\t    goto finish_meta_pat;\n          }\n\n\tcase 'D':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'd':\n            arg = ANYOF_DIGIT;\n            if (! DEPENDS_SEMANTICS) {\n                goto join_posix;\n            }\n\n            /* \\d doesn't have any matches in the upper Latin1 range, hence /d\n             * is equivalent to /u.  Changing to /u saves some branches at\n             * runtime */\n            op = POSIXU;\n            goto join_posix_op_known;\n\n\tcase 'R':\n\t    ret = reg_node(pRExC_state, LNBREAK);\n\t    *flagp |= HASWIDTH|SIMPLE;\n\t    goto finish_meta_pat;\n\n\tcase 'H':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'h':\n\t    arg = ANYOF_BLANK;\n            op = POSIXU;\n            goto join_posix_op_known;\n\n\tcase 'V':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'v':\n\t    arg = ANYOF_VERTWS;\n            op = POSIXU;\n            goto join_posix_op_known;\n\n\tcase 'S':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 's':\n            arg = ANYOF_SPACE;\n\n          join_posix:\n\n\t    op = POSIXD + get_regex_charset(RExC_flags);\n            if (op > POSIXA) {  /* /aa is same as /a */\n                op = POSIXA;\n            }\n            else if (op == POSIXL) {\n                RExC_contains_locale = 1;\n            }\n            else if (op == POSIXD) {\n                RExC_seen_d_op = TRUE;\n            }\n\n          join_posix_op_known:\n\n            if (invert) {\n                op += NPOSIXD - POSIXD;\n            }\n\n\t    ret = reg_node(pRExC_state, op);\n            FLAGS(REGNODE_p(ret)) = namedclass_to_classnum(arg);\n\n\t    *flagp |= HASWIDTH|SIMPLE;\n            /* FALLTHROUGH */\n\n          finish_meta_pat:\n            if (   UCHARAT(RExC_parse + 1) == '{'\n                && UNLIKELY(! new_regcurly(RExC_parse + 1, RExC_end)))\n            {\n                RExC_parse += 2;\n                vFAIL(\"Unescaped left brace in regex is illegal here\");\n            }\n\t    nextchar(pRExC_state);\n            Set_Node_Length(REGNODE_p(ret), 2); /* MJD */\n\t    break;\n\tcase 'p':\n\tcase 'P':\n            RExC_parse--;\n\n            ret = regclass(pRExC_state, flagp, depth+1,\n                           TRUE, /* means just parse this element */\n                           FALSE, /* don't allow multi-char folds */\n                           FALSE, /* don't silence non-portable warnings.  It\n                                     would be a bug if these returned\n                                     non-portables */\n                           (bool) RExC_strict,\n                           TRUE, /* Allow an optimized regnode result */\n                           NULL);\n            RETURN_FAIL_ON_RESTART_FLAGP(flagp);\n            /* regclass() can only return RESTART_PARSE and NEED_UTF8 if\n             * multi-char folds are allowed.  */\n            if (!ret)\n                FAIL2(\"panic: regclass returned failure to regatom, flags=%#\" UVxf,\n                      (UV) *flagp);\n\n            RExC_parse--;\n\n            Set_Node_Offset(REGNODE_p(ret), parse_start);\n            Set_Node_Cur_Length(REGNODE_p(ret), parse_start - 2);\n            nextchar(pRExC_state);\n\t    break;\n        case 'N':\n            /* Handle \\N, \\N{} and \\N{NAMED SEQUENCE} (the latter meaning the\n             * \\N{...} evaluates to a sequence of more than one code points).\n             * The function call below returns a regnode, which is our result.\n             * The parameters cause it to fail if the \\N{} evaluates to a\n             * single code point; we handle those like any other literal.  The\n             * reason that the multicharacter case is handled here and not as\n             * part of the EXACtish code is because of quantifiers.  In\n             * /\\N{BLAH}+/, the '+' applies to the whole thing, and doing it\n             * this way makes that Just Happen. dmq.\n             * join_exact() will join this up with adjacent EXACTish nodes\n             * later on, if appropriate. */\n            ++RExC_parse;\n            if (grok_bslash_N(pRExC_state,\n                              &ret,     /* Want a regnode returned */\n                              NULL,     /* Fail if evaluates to a single code\n                                           point */\n                              NULL,     /* Don't need a count of how many code\n                                           points */\n                              flagp,\n                              RExC_strict,\n                              depth)\n            ) {\n                break;\n            }\n\n            RETURN_FAIL_ON_RESTART_FLAGP(flagp);\n\n            /* Here, evaluates to a single code point.  Go get that */\n            RExC_parse = parse_start;\n            goto defchar;\n\n\tcase 'k':    /* Handle \\k<NAME> and \\k'NAME' */\n      parse_named_seq:\n        {\n            char ch;\n            if (   RExC_parse >= RExC_end - 1\n                || ((   ch = RExC_parse[1]) != '<'\n                                      && ch != '\\''\n                                      && ch != '{'))\n            {\n\t        RExC_parse++;\n\t\t/* diag_listed_as: Sequence \\%s... not terminated in regex; marked by <-- HERE in m/%s/ */\n\t        vFAIL2(\"Sequence %.2s... not terminated\", parse_start);\n\t    } else {\n\t\tRExC_parse += 2;\n                ret = handle_named_backref(pRExC_state,\n                                           flagp,\n                                           parse_start,\n                                           (ch == '<')\n                                           ? '>'\n                                           : (ch == '{')\n                                             ? '}'\n                                             : '\\'');\n            }\n            break;\n\t}\n\tcase 'g':\n\tcase '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t    {\n\t\tI32 num;\n\t\tbool hasbrace = 0;\n\n\t\tif (*RExC_parse == 'g') {\n                    bool isrel = 0;\n\n\t\t    RExC_parse++;\n\t\t    if (*RExC_parse == '{') {\n\t\t        RExC_parse++;\n\t\t        hasbrace = 1;\n\t\t    }\n\t\t    if (*RExC_parse == '-') {\n\t\t        RExC_parse++;\n\t\t        isrel = 1;\n\t\t    }\n\t\t    if (hasbrace && !isDIGIT(*RExC_parse)) {\n\t\t        if (isrel) RExC_parse--;\n                        RExC_parse -= 2;\n\t\t        goto parse_named_seq;\n                    }\n\n                    if (RExC_parse >= RExC_end) {\n                        goto unterminated_g;\n                    }\n                    num = S_backref_value(RExC_parse, RExC_end);\n                    if (num == 0)\n                        vFAIL(\"Reference to invalid group 0\");\n                    else if (num == I32_MAX) {\n                         if (isDIGIT(*RExC_parse))\n\t\t\t    vFAIL(\"Reference to nonexistent group\");\n                        else\n                          unterminated_g:\n                            vFAIL(\"Unterminated \\\\g... pattern\");\n                    }\n\n                    if (isrel) {\n                        num = RExC_npar - num;\n                        if (num < 1)\n                            vFAIL(\"Reference to nonexistent or unclosed group\");\n                    }\n                }\n                else {\n                    num = S_backref_value(RExC_parse, RExC_end);\n                    /* bare \\NNN might be backref or octal - if it is larger\n                     * than or equal RExC_npar then it is assumed to be an\n                     * octal escape. Note RExC_npar is +1 from the actual\n                     * number of parens. */\n                    /* Note we do NOT check if num == I32_MAX here, as that is\n                     * handled by the RExC_npar check */\n\n                    if (\n                        /* any numeric escape < 10 is always a backref */\n                        num > 9\n                        /* any numeric escape < RExC_npar is a backref */\n                        && num >= RExC_npar\n                        /* cannot be an octal escape if it starts with 8 */\n                        && *RExC_parse != '8'\n                        /* cannot be an octal escape it it starts with 9 */\n                        && *RExC_parse != '9'\n                    ) {\n                        /* Probably not meant to be a backref, instead likely\n                         * to be an octal character escape, e.g. \\35 or \\777.\n                         * The above logic should make it obvious why using\n                         * octal escapes in patterns is problematic. - Yves */\n                        RExC_parse = parse_start;\n                        goto defchar;\n                    }\n                }\n\n                /* At this point RExC_parse points at a numeric escape like\n                 * \\12 or \\88 or something similar, which we should NOT treat\n                 * as an octal escape. It may or may not be a valid backref\n                 * escape. For instance \\88888888 is unlikely to be a valid\n                 * backref. */\n                while (isDIGIT(*RExC_parse))\n                    RExC_parse++;\n                if (hasbrace) {\n                    if (*RExC_parse != '}')\n                        vFAIL(\"Unterminated \\\\g{...} pattern\");\n                    RExC_parse++;\n                }\n                if (num >= (I32)RExC_npar) {\n\n                    /* It might be a forward reference; we can't fail until we\n                     * know, by completing the parse to get all the groups, and\n                     * then reparsing */\n                    if (ALL_PARENS_COUNTED)  {\n                        if (num >= RExC_total_parens)  {\n                            vFAIL(\"Reference to nonexistent group\");\n                        }\n                    }\n                    else {\n                        REQUIRE_PARENS_PASS;\n                    }\n                }\n                RExC_sawback = 1;\n                ret = reganode(pRExC_state,\n                               ((! FOLD)\n                                 ? REF\n                                 : (ASCII_FOLD_RESTRICTED)\n                                   ? REFFA\n                                   : (AT_LEAST_UNI_SEMANTICS)\n                                     ? REFFU\n                                     : (LOC)\n                                       ? REFFL\n                                       : REFF),\n                                num);\n                if (OP(REGNODE_p(ret)) == REFF) {\n                    RExC_seen_d_op = TRUE;\n                }\n                *flagp |= HASWIDTH;\n\n                /* override incorrect value set in reganode MJD */\n                Set_Node_Offset(REGNODE_p(ret), parse_start);\n                Set_Node_Cur_Length(REGNODE_p(ret), parse_start-1);\n                skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                        FALSE /* Don't force to /x */ );\n\t    }\n\t    break;\n\tcase '\\0':\n\t    if (RExC_parse >= RExC_end)\n\t\tFAIL(\"Trailing \\\\\");\n\t    /* FALLTHROUGH */\n\tdefault:\n\t    /* Do not generate \"unrecognized\" warnings here, we fall\n\t       back into the quick-grab loop below */\n            RExC_parse = parse_start;\n\t    goto defchar;\n\t} /* end of switch on a \\foo sequence */\n\tbreak;\n\n    case '#':\n\n        /* '#' comments should have been spaced over before this function was\n         * called */\n        assert((RExC_flags & RXf_PMf_EXTENDED) == 0);\n\t/*\n        if (RExC_flags & RXf_PMf_EXTENDED) {\n\t    RExC_parse = reg_skipcomment( pRExC_state, RExC_parse );\n\t    if (RExC_parse < RExC_end)\n\t\tgoto tryagain;\n\t}\n        */\n\n\t/* FALLTHROUGH */\n\n    default:\n\t  defchar: {\n\n            /* Here, we have determined that the next thing is probably a\n             * literal character.  RExC_parse points to the first byte of its\n             * definition.  (It still may be an escape sequence that evaluates\n             * to a single character) */\n\n\t    STRLEN len = 0;\n\t    UV ender = 0;\n\t    char *p;\n\t    char *s;\n\n/* This allows us to fill a node with just enough spare so that if the final\n * character folds, its expansion is guaranteed to fit */\n#define MAX_NODE_STRING_SIZE (255-UTF8_MAXBYTES_CASE)\n\n\t    char *s0;\n\t    U8 upper_parse = MAX_NODE_STRING_SIZE;\n\n            /* We start out as an EXACT node, even if under /i, until we find a\n             * character which is in a fold.  The algorithm now segregates into\n             * separate nodes, characters that fold from those that don't under\n             * /i.  (This hopefully will create nodes that are fixed strings\n             * even under /i, giving the optimizer something to grab on to.)\n             * So, if a node has something in it and the next character is in\n             * the opposite category, that node is closed up, and the function\n             * returns.  Then regatom is called again, and a new node is\n             * created for the new category. */\n            U8 node_type = EXACT;\n\n            /* Assume the node will be fully used; the excess is given back at\n             * the end.  We can't make any other length assumptions, as a byte\n             * input sequence could shrink down. */\n            Ptrdiff_t initial_size = STR_SZ(256);\n\n            bool next_is_quantifier;\n            char * oldp = NULL;\n\n            /* We can convert EXACTF nodes to EXACTFU if they contain only\n             * characters that match identically regardless of the target\n             * string's UTF8ness.  The reason to do this is that EXACTF is not\n             * trie-able, EXACTFU is, and EXACTFU requires fewer operations at\n             * runtime.\n             *\n             * Similarly, we can convert EXACTFL nodes to EXACTFLU8 if they\n             * contain only above-Latin1 characters (hence must be in UTF8),\n             * which don't participate in folds with Latin1-range characters,\n             * as the latter's folds aren't known until runtime. */\n            bool maybe_exactfu = FOLD && (DEPENDS_SEMANTICS || LOC);\n\n            /* Single-character EXACTish nodes are almost always SIMPLE.  This\n             * allows us to override this as encountered */\n            U8 maybe_SIMPLE = SIMPLE;\n\n            /* Does this node contain something that can't match unless the\n             * target string is (also) in UTF-8 */\n            bool requires_utf8_target = FALSE;\n\n            /* The sequence 'ss' is problematic in non-UTF-8 patterns. */\n            bool has_ss = FALSE;\n\n            /* So is the MICRO SIGN */\n            bool has_micro_sign = FALSE;\n\n            /* Allocate an EXACT node.  The node_type may change below to\n             * another EXACTish node, but since the size of the node doesn't\n             * change, it works */\n            ret = regnode_guts(pRExC_state, node_type, initial_size, \"exact\");\n            FILL_NODE(ret, node_type);\n            RExC_emit++;\n\n\t    s = STRING(REGNODE_p(ret));\n\n            s0 = s;\n\n\t  reparse:\n\n            /* This breaks under rare circumstances.  If folding, we do not\n             * want to split a node at a character that is a non-final in a\n             * multi-char fold, as an input string could just happen to want to\n             * match across the node boundary.  The code at the end of the loop\n             * looks for this, and backs off until it finds not such a\n             * character, but it is possible (though extremely, extremely\n             * unlikely) for all characters in the node to be non-final fold\n             * ones, in which case we just leave the node fully filled, and\n             * hope that it doesn't match the string in just the wrong place */\n\n            assert( ! UTF     /* Is at the beginning of a character */\n                   || UTF8_IS_INVARIANT(UCHARAT(RExC_parse))\n                   || UTF8_IS_START(UCHARAT(RExC_parse)));\n\n            /* Here, we have a literal character.  Find the maximal string of\n             * them in the input that we can fit into a single EXACTish node.\n             * We quit at the first non-literal or when the node gets full, or\n             * under /i the categorization of folding/non-folding character\n             * changes */\n\t    for (p = RExC_parse; len < upper_parse && p < RExC_end; ) {\n\n                /* In most cases each iteration adds one byte to the output.\n                 * The exceptions override this */\n                Size_t added_len = 1;\n\n\t\toldp = p;\n\n                /* White space has already been ignored */\n                assert(   (RExC_flags & RXf_PMf_EXTENDED) == 0\n                       || ! is_PATWS_safe((p), RExC_end, UTF));\n\n\t\tswitch ((U8)*p) {\n\t\tcase '^':\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '[':\n\t\tcase '(':\n\t\tcase ')':\n\t\tcase '|':\n\t\t    goto loopdone;\n\t\tcase '\\\\':\n\t\t    /* Literal Escapes Switch\n\n\t\t       This switch is meant to handle escape sequences that\n\t\t       resolve to a literal character.\n\n\t\t       Every escape sequence that represents something\n\t\t       else, like an assertion or a char class, is handled\n\t\t       in the switch marked 'Special Escapes' above in this\n\t\t       routine, but also has an entry here as anything that\n\t\t       isn't explicitly mentioned here will be treated as\n\t\t       an unescaped equivalent literal.\n\t\t    */\n\n\t\t    switch ((U8)*++p) {\n\n\t\t    /* These are all the special escapes. */\n\t\t    case 'A':             /* Start assertion */\n\t\t    case 'b': case 'B':   /* Word-boundary assertion*/\n\t\t    case 'C':             /* Single char !DANGEROUS! */\n\t\t    case 'd': case 'D':   /* digit class */\n\t\t    case 'g': case 'G':   /* generic-backref, pos assertion */\n\t\t    case 'h': case 'H':   /* HORIZWS */\n\t\t    case 'k': case 'K':   /* named backref, keep marker */\n\t\t    case 'p': case 'P':   /* Unicode property */\n\t\t              case 'R':   /* LNBREAK */\n\t\t    case 's': case 'S':   /* space class */\n\t\t    case 'v': case 'V':   /* VERTWS */\n\t\t    case 'w': case 'W':   /* word class */\n                    case 'X':             /* eXtended Unicode \"combining\n                                             character sequence\" */\n\t\t    case 'z': case 'Z':   /* End of line/string assertion */\n\t\t\t--p;\n\t\t\tgoto loopdone;\n\n\t            /* Anything after here is an escape that resolves to a\n\t               literal. (Except digits, which may or may not)\n\t             */\n\t\t    case 'n':\n\t\t\tender = '\\n';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'N': /* Handle a single-code point named character. */\n                        RExC_parse = p + 1;\n                        if (! grok_bslash_N(pRExC_state,\n                                            NULL,   /* Fail if evaluates to\n                                                       anything other than a\n                                                       single code point */\n                                            &ender, /* The returned single code\n                                                       point */\n                                            NULL,   /* Don't need a count of\n                                                       how many code points */\n                                            flagp,\n                                            RExC_strict,\n                                            depth)\n                        ) {\n                            if (*flagp & NEED_UTF8)\n                                FAIL(\"panic: grok_bslash_N set NEED_UTF8\");\n                            RETURN_FAIL_ON_RESTART_FLAGP(flagp);\n\n                            /* Here, it wasn't a single code point.  Go close\n                             * up this EXACTish node.  The switch() prior to\n                             * this switch handles the other cases */\n                            RExC_parse = p = oldp;\n                            goto loopdone;\n                        }\n                        p = RExC_parse;\n                        RExC_parse = parse_start;\n\n                        /* The \\N{} means the pattern, if previously /d,\n                         * becomes /u.  That means it can't be an EXACTF node,\n                         * but an EXACTFU */\n                        if (node_type == EXACTF) {\n                            node_type = EXACTFU;\n\n                            /* If the node already contains something that\n                             * differs between EXACTF and EXACTFU, reparse it\n                             * as EXACTFU */\n                            if (! maybe_exactfu) {\n                                len = 0;\n                                s = s0;\n                                goto reparse;\n                            }\n                        }\n\n                        break;\n\t\t    case 'r':\n\t\t\tender = '\\r';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 't':\n\t\t\tender = '\\t';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'f':\n\t\t\tender = '\\f';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'e':\n\t\t\tender = ESC_NATIVE;\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'a':\n\t\t\tender = '\\a';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'o':\n\t\t\t{\n\t\t\t    UV result;\n\t\t\t    const char* error_msg;\n\n\t\t\t    bool valid = grok_bslash_o(&p,\n                                                       RExC_end,\n\t\t\t\t\t\t       &result,\n\t\t\t\t\t\t       &error_msg,\n\t\t\t\t\t\t       TO_OUTPUT_WARNINGS(p),\n                                                       (bool) RExC_strict,\n                                                       TRUE, /* Output warnings\n                                                                for non-\n                                                                portables */\n                                                       UTF);\n\t\t\t    if (! valid) {\n\t\t\t\tRExC_parse = p;\t/* going to die anyway; point\n\t\t\t\t\t\t   to exact spot of failure */\n\t\t\t\tvFAIL(error_msg);\n\t\t\t    }\n                            UPDATE_WARNINGS_LOC(p - 1);\n                            ender = result;\n\t\t\t    break;\n\t\t\t}\n\t\t    case 'x':\n\t\t\t{\n                            UV result = UV_MAX; /* initialize to erroneous\n                                                   value */\n\t\t\t    const char* error_msg;\n\n\t\t\t    bool valid = grok_bslash_x(&p,\n                                                       RExC_end,\n\t\t\t\t\t\t       &result,\n\t\t\t\t\t\t       &error_msg,\n                                                       TO_OUTPUT_WARNINGS(p),\n                                                       (bool) RExC_strict,\n                                                       TRUE, /* Silence warnings\n                                                                for non-\n                                                                portables */\n                                                       UTF);\n\t\t\t    if (! valid) {\n\t\t\t\tRExC_parse = p;\t/* going to die anyway; point\n\t\t\t\t\t\t   to exact spot of failure */\n\t\t\t\tvFAIL(error_msg);\n\t\t\t    }\n                            UPDATE_WARNINGS_LOC(p - 1);\n                            ender = result;\n\n                            if (ender < 0x100) {\n#ifdef EBCDIC\n                                if (RExC_recode_x_to_native) {\n                                    ender = LATIN1_TO_NATIVE(ender);\n                                }\n#endif\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t    case 'c':\n\t\t\tp++;\n\t\t\tender = grok_bslash_c(*p, TO_OUTPUT_WARNINGS(p));\n                        UPDATE_WARNINGS_LOC(p);\n                        p++;\n\t\t\tbreak;\n                    case '8': case '9': /* must be a backreference */\n                        --p;\n                        /* we have an escape like \\8 which cannot be an octal escape\n                         * so we exit the loop, and let the outer loop handle this\n                         * escape which may or may not be a legitimate backref. */\n                        goto loopdone;\n                    case '1': case '2': case '3':case '4':\n\t\t    case '5': case '6': case '7':\n                        /* When we parse backslash escapes there is ambiguity\n                         * between backreferences and octal escapes. Any escape\n                         * from \\1 - \\9 is a backreference, any multi-digit\n                         * escape which does not start with 0 and which when\n                         * evaluated as decimal could refer to an already\n                         * parsed capture buffer is a back reference. Anything\n                         * else is octal.\n                         *\n                         * Note this implies that \\118 could be interpreted as\n                         * 118 OR as \"\\11\" . \"8\" depending on whether there\n                         * were 118 capture buffers defined already in the\n                         * pattern.  */\n\n                        /* NOTE, RExC_npar is 1 more than the actual number of\n                         * parens we have seen so far, hence the \"<\" as opposed\n                         * to \"<=\" */\n                        if ( !isDIGIT(p[1]) || S_backref_value(p, RExC_end) < RExC_npar)\n                        {  /* Not to be treated as an octal constant, go\n                                   find backref */\n                            --p;\n                            goto loopdone;\n                        }\n                        /* FALLTHROUGH */\n                    case '0':\n\t\t\t{\n\t\t\t    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;\n\t\t\t    STRLEN numlen = 3;\n\t\t\t    ender = grok_oct(p, &numlen, &flags, NULL);\n\t\t\t    p += numlen;\n                            if (   isDIGIT(*p)  /* like \\08, \\178 */\n                                && ckWARN(WARN_REGEXP)\n                                && numlen < 3)\n                            {\n\t\t\t\treg_warn_non_literal_string(\n                                         p + 1,\n                                         form_short_octal_warning(p, numlen));\n                            }\n\t\t\t}\n\t\t\tbreak;\n\t\t    case '\\0':\n\t\t\tif (p >= RExC_end)\n\t\t\t    FAIL(\"Trailing \\\\\");\n\t\t\t/* FALLTHROUGH */\n\t\t    default:\n\t\t\tif (isALPHANUMERIC(*p)) {\n                            /* An alpha followed by '{' is going to fail next\n                             * iteration, so don't output this warning in that\n                             * case */\n                            if (! isALPHA(*p) || *(p + 1) != '{') {\n                                ckWARN2reg(p + 1, \"Unrecognized escape \\\\%.1s\"\n                                                  \" passed through\", p);\n                            }\n\t\t\t}\n\t\t\tgoto normal_default;\n\t\t    } /* End of switch on '\\' */\n\t\t    break;\n\t\tcase '{':\n                    /* Trying to gain new uses for '{' without breaking too\n                     * much existing code is hard.  The solution currently\n                     * adopted is:\n                     *  1)  If there is no ambiguity that a '{' should always\n                     *      be taken literally, at the start of a construct, we\n                     *      just do so.\n                     *  2)  If the literal '{' conflicts with our desired use\n                     *      of it as a metacharacter, we die.  The deprecation\n                     *      cycles for this have come and gone.\n                     *  3)  If there is ambiguity, we raise a simple warning.\n                     *      This could happen, for example, if the user\n                     *      intended it to introduce a quantifier, but slightly\n                     *      misspelled the quantifier.  Without this warning,\n                     *      the quantifier would silently be taken as a literal\n                     *      string of characters instead of a meta construct */\n\t\t    if (len || (p > RExC_start && isALPHA_A(*(p - 1)))) {\n                        if (      RExC_strict\n                            || (  p > parse_start + 1\n                                && isALPHA_A(*(p - 1))\n                                && *(p - 2) == '\\\\')\n                            || new_regcurly(p, RExC_end))\n                        {\n                            RExC_parse = p + 1;\n                            vFAIL(\"Unescaped left brace in regex is \"\n                                  \"illegal here\");\n                        }\n                        ckWARNreg(p + 1, \"Unescaped left brace in regex is\"\n                                         \" passed through\");\n\t\t    }\n\t\t    goto normal_default;\n                case '}':\n                case ']':\n                    if (p > RExC_parse && RExC_strict) {\n                        ckWARN2reg(p + 1, \"Unescaped literal '%c'\", *p);\n                    }\n\t\t    /*FALLTHROUGH*/\n\t\tdefault:    /* A literal character */\n\t\t  normal_default:\n\t\t    if (! UTF8_IS_INVARIANT(*p) && UTF) {\n\t\t\tSTRLEN numlen;\n\t\t\tender = utf8n_to_uvchr((U8*)p, RExC_end - p,\n\t\t\t\t\t       &numlen, UTF8_ALLOW_DEFAULT);\n\t\t\tp += numlen;\n\t\t    }\n\t\t    else\n\t\t\tender = (U8) *p++;\n\t\t    break;\n\t\t} /* End of switch on the literal */\n\n\t\t/* Here, have looked at the literal character, and <ender>\n                 * contains its ordinal; <p> points to the character after it.\n                 * */\n\n                if (ender > 255) {\n                    REQUIRE_UTF8(flagp);\n                }\n\n                /* We need to check if the next non-ignored thing is a\n                 * quantifier.  Move <p> to after anything that should be\n                 * ignored, which, as a side effect, positions <p> for the next\n                 * loop iteration */\n                skip_to_be_ignored_text(pRExC_state, &p,\n                                        FALSE /* Don't force to /x */ );\n\n                /* If the next thing is a quantifier, it applies to this\n                 * character only, which means that this character has to be in\n                 * its own node and can't just be appended to the string in an\n                 * existing node, so if there are already other characters in\n                 * the node, close the node with just them, and set up to do\n                 * this character again next time through, when it will be the\n                 * only thing in its new node */\n\n                next_is_quantifier =    LIKELY(p < RExC_end)\n                                     && UNLIKELY(ISMULT2(p));\n\n                if (next_is_quantifier && LIKELY(len)) {\n                    p = oldp;\n                    goto loopdone;\n                }\n\n                /* Ready to add 'ender' to the node */\n\n                if (! FOLD) {  /* The simple case, just append the literal */\n\n                      not_fold_common:\n                        if (UVCHR_IS_INVARIANT(ender) || ! UTF) {\n                            *(s++) = (char) ender;\n                        }\n                        else {\n                            U8 * new_s = uvchr_to_utf8((U8*)s, ender);\n                            added_len = (char *) new_s - s;\n                            s = (char *) new_s;\n\n                            if (ender > 255)  {\n                                requires_utf8_target = TRUE;\n                            }\n                        }\n                }\n                else if (LOC && is_PROBLEMATIC_LOCALE_FOLD_cp(ender)) {\n\n                    /* Here are folding under /l, and the code point is\n                     * problematic.  If this is the first character in the\n                     * node, change the node type to folding.   Otherwise, if\n                     * this is the first problematic character, close up the\n                     * existing node, so can start a new node with this one */\n                    if (! len) {\n                        node_type = EXACTFL;\n                        RExC_contains_locale = 1;\n                    }\n                    else if (node_type == EXACT) {\n                        p = oldp;\n                        goto loopdone;\n                    }\n\n                    /* This problematic code point means we can't simplify\n                     * things */\n                    maybe_exactfu = FALSE;\n\n                    /* Here, we are adding a problematic fold character.\n                     * \"Problematic\" in this context means that its fold isn't\n                     * known until runtime.  (The non-problematic code points\n                     * are the above-Latin1 ones that fold to also all\n                     * above-Latin1.  Their folds don't vary no matter what the\n                     * locale is.) But here we have characters whose fold\n                     * depends on the locale.  We just add in the unfolded\n                     * character, and wait until runtime to fold it */\n                    goto not_fold_common;\n                }\n                else /* regular fold; see if actually is in a fold */\n                     if (   (ender < 256 && ! IS_IN_SOME_FOLD_L1(ender))\n                         || (ender > 255\n                            && ! _invlist_contains_cp(PL_in_some_fold, ender)))\n                {\n                    /* Here, folding, but the character isn't in a fold.\n                     *\n                     * Start a new node if previous characters in the node were\n                     * folded */\n                    if (len && node_type != EXACT) {\n                        p = oldp;\n                        goto loopdone;\n                    }\n\n                    /* Here, continuing a node with non-folded characters.  Add\n                     * this one */\n                    goto not_fold_common;\n                }\n                else {  /* Here, does participate in some fold */\n\n                    /* If this is the first character in the node, change its\n                     * type to folding.  Otherwise, if this is the first\n                     * folding character in the node, close up the existing\n                     * node, so can start a new node with this one.  */\n                    if (! len) {\n                        node_type = compute_EXACTish(pRExC_state);\n                    }\n                    else if (node_type == EXACT) {\n                        p = oldp;\n                        goto loopdone;\n                    }\n\n                    if (UTF) {  /* Use the folded value */\n                        if (UVCHR_IS_INVARIANT(ender)) {\n                            *(s)++ = (U8) toFOLD(ender);\n                        }\n                        else {\n                            ender = _to_uni_fold_flags(\n                                    ender,\n                                    (U8 *) s,\n                                    &added_len,\n                                    FOLD_FLAGS_FULL | ((ASCII_FOLD_RESTRICTED)\n                                                    ? FOLD_FLAGS_NOMIX_ASCII\n                                                    : 0));\n                            s += added_len;\n\n                            if (   ender > 255\n                                && LIKELY(ender != GREEK_SMALL_LETTER_MU))\n                            {\n                                /* U+B5 folds to the MU, so its possible for a\n                                 * non-UTF-8 target to match it */\n                                requires_utf8_target = TRUE;\n                            }\n                        }\n                    }\n                    else {\n\n                        /* Here is non-UTF8.  First, see if the character's\n                         * fold differs between /d and /u. */\n                        if (PL_fold[ender] != PL_fold_latin1[ender]) {\n                            maybe_exactfu = FALSE;\n                        }\n\n#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \\\n   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \\\n                                      || UNICODE_DOT_DOT_VERSION > 0)\n\n                        /* On non-ancient Unicode versions, this includes the\n                         * multi-char fold SHARP S to 'ss' */\n\n                        if (   UNLIKELY(ender == LATIN_SMALL_LETTER_SHARP_S)\n                                 || (   isALPHA_FOLD_EQ(ender, 's')\n                                     && len > 0\n                                     && isALPHA_FOLD_EQ(*(s-1), 's')))\n                        {\n                            /* Here, we have one of the following:\n                             *  a)  a SHARP S.  This folds to 'ss' only under\n                             *      /u rules.  If we are in that situation,\n                             *      fold the SHARP S to 'ss'.  See the comments\n                             *      for join_exact() as to why we fold this\n                             *      non-UTF at compile time, and no others.\n                             *  b)  'ss'.  When under /u, there's nothing\n                             *      special needed to be done here.  The\n                             *      previous iteration handled the first 's',\n                             *      and this iteration will handle the second.\n                             *      If, on the otherhand it's not /u, we have\n                             *      to exclude the possibility of moving to /u,\n                             *      so that we won't generate an unwanted\n                             *      match, unless, at runtime, the target\n                             *      string is in UTF-8.\n                             * */\n\n                            has_ss = TRUE;\n                            maybe_exactfu = FALSE;  /* Can't generate an\n                                                       EXACTFU node (unless we\n                                                       already are in one) */\n                            if (UNLIKELY(ender == LATIN_SMALL_LETTER_SHARP_S)) {\n                                maybe_SIMPLE = 0;\n                                if (node_type == EXACTFU) {\n                                    *(s++) = 's';\n\n                                    /* Let the code below add in the extra 's' */\n                                    ender = 's';\n                                    added_len = 2;\n                                }\n                            }\n                        }\n#endif\n\n                        else if (UNLIKELY(ender == MICRO_SIGN)) {\n                            has_micro_sign = TRUE;\n                        }\n\n                        *(s++) = (DEPENDS_SEMANTICS)\n                                 ? (char) toFOLD(ender)\n\n                                   /* Under /u, the fold of any character in\n                                    * the 0-255 range happens to be its\n                                    * lowercase equivalent, except for LATIN\n                                    * SMALL LETTER SHARP S, which was handled\n                                    * above, and the MICRO SIGN, whose fold\n                                    * requires UTF-8 to represent.  */\n                                 : (char) toLOWER_L1(ender);\n                    }\n\t\t} /* End of adding current character to the node */\n\n                len += added_len;\n\n\t\tif (next_is_quantifier) {\n\n                    /* Here, the next input is a quantifier, and to get here,\n                     * the current character is the only one in the node. */\n                    goto loopdone;\n\t\t}\n\n\t    } /* End of loop through literal characters */\n\n            /* Here we have either exhausted the input or ran out of room in\n             * the node.  (If we encountered a character that can't be in the\n             * node, transfer is made directly to <loopdone>, and so we\n             * wouldn't have fallen off the end of the loop.)  In the latter\n             * case, we artificially have to split the node into two, because\n             * we just don't have enough space to hold everything.  This\n             * creates a problem if the final character participates in a\n             * multi-character fold in the non-final position, as a match that\n             * should have occurred won't, due to the way nodes are matched,\n             * and our artificial boundary.  So back off until we find a non-\n             * problematic character -- one that isn't at the beginning or\n             * middle of such a fold.  (Either it doesn't participate in any\n             * folds, or appears only in the final position of all the folds it\n             * does participate in.)  A better solution with far fewer false\n             * positives, and that would fill the nodes more completely, would\n             * be to actually have available all the multi-character folds to\n             * test against, and to back-off only far enough to be sure that\n             * this node isn't ending with a partial one.  <upper_parse> is set\n             * further below (if we need to reparse the node) to include just\n             * up through that final non-problematic character that this code\n             * identifies, so when it is set to less than the full node, we can\n             * skip the rest of this */\n            if (FOLD && p < RExC_end && upper_parse == MAX_NODE_STRING_SIZE) {\n                PERL_UINT_FAST8_T backup_count = 0;\n\n                const STRLEN full_len = len;\n\n\t\tassert(len >= MAX_NODE_STRING_SIZE);\n\n                /* Here, <s> points to just beyond where we have output the\n                 * final character of the node.  Look backwards through the\n                 * string until find a non- problematic character */\n\n\t\tif (! UTF) {\n\n                    /* This has no multi-char folds to non-UTF characters */\n                    if (ASCII_FOLD_RESTRICTED) {\n                        goto loopdone;\n                    }\n\n                    while (--s >= s0 && IS_NON_FINAL_FOLD(*s)) {\n                        backup_count++;\n                    }\n                    len = s - s0 + 1;\n\t\t}\n                else {\n\n                    /* Point to the first byte of the final character */\n                    s = (char *) utf8_hop_back((U8 *) s, -1, (U8 *) s0);\n\n                    while (s >= s0) {   /* Search backwards until find\n                                           a non-problematic char */\n                        if (UTF8_IS_INVARIANT(*s)) {\n\n                            /* There are no ascii characters that participate\n                             * in multi-char folds under /aa.  In EBCDIC, the\n                             * non-ascii invariants are all control characters,\n                             * so don't ever participate in any folds. */\n                            if (ASCII_FOLD_RESTRICTED\n                                || ! IS_NON_FINAL_FOLD(*s))\n                            {\n                                break;\n                            }\n                        }\n                        else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {\n                            if (! IS_NON_FINAL_FOLD(EIGHT_BIT_UTF8_TO_NATIVE(\n                                                                  *s, *(s+1))))\n                            {\n                                break;\n                            }\n                        }\n                        else if (! _invlist_contains_cp(\n                                        PL_NonFinalFold,\n                                        valid_utf8_to_uvchr((U8 *) s, NULL)))\n                        {\n                            break;\n                        }\n\n                        /* Here, the current character is problematic in that\n                         * it does occur in the non-final position of some\n                         * fold, so try the character before it, but have to\n                         * special case the very first byte in the string, so\n                         * we don't read outside the string */\n                        s = (s == s0) ? s -1 : (char *) utf8_hop((U8 *) s, -1);\n                        backup_count++;\n                    } /* End of loop backwards through the string */\n\n                    /* If there were only problematic characters in the string,\n                     * <s> will point to before s0, in which case the length\n                     * should be 0, otherwise include the length of the\n                     * non-problematic character just found */\n                    len = (s < s0) ? 0 : s - s0 + UTF8SKIP(s);\n\t\t}\n\n                /* Here, have found the final character, if any, that is\n                 * non-problematic as far as ending the node without splitting\n                 * it across a potential multi-char fold.  <len> contains the\n                 * number of bytes in the node up-to and including that\n                 * character, or is 0 if there is no such character, meaning\n                 * the whole node contains only problematic characters.  In\n                 * this case, give up and just take the node as-is.  We can't\n                 * do any better */\n                if (len == 0) {\n                    len = full_len;\n\n                } else {\n\n                    /* Here, the node does contain some characters that aren't\n                     * problematic.  If we didn't have to backup any, then the\n                     * final character in the node is non-problematic, and we\n                     * can take the node as-is */\n                    if (backup_count == 0) {\n                        goto loopdone;\n                    }\n                    else if (backup_count == 1) {\n\n                        /* If the final character is problematic, but the\n                         * penultimate is not, back-off that last character to\n                         * later start a new node with it */\n                        p = oldp;\n                        goto loopdone;\n                    }\n\n                    /* Here, the final non-problematic character is earlier\n                     * in the input than the penultimate character.  What we do\n                     * is reparse from the beginning, going up only as far as\n                     * this final ok one, thus guaranteeing that the node ends\n                     * in an acceptable character.  The reason we reparse is\n                     * that we know how far in the character is, but we don't\n                     * know how to correlate its position with the input parse.\n                     * An alternate implementation would be to build that\n                     * correlation as we go along during the original parse,\n                     * but that would entail extra work for every node, whereas\n                     * this code gets executed only when the string is too\n                     * large for the node, and the final two characters are\n                     * problematic, an infrequent occurrence.  Yet another\n                     * possible strategy would be to save the tail of the\n                     * string, and the next time regatom is called, initialize\n                     * with that.  The problem with this is that unless you\n                     * back off one more character, you won't be guaranteed\n                     * regatom will get called again, unless regbranch,\n                     * regpiece ... are also changed.  If you do back off that\n                     * extra character, so that there is input guaranteed to\n                     * force calling regatom, you can't handle the case where\n                     * just the first character in the node is acceptable.  I\n                     * (khw) decided to try this method which doesn't have that\n                     * pitfall; if performance issues are found, we can do a\n                     * combination of the current approach plus that one */\n                    upper_parse = len;\n                    len = 0;\n                    s = s0;\n                    goto reparse;\n                }\n\t    }   /* End of verifying node ends with an appropriate char */\n\n          loopdone:   /* Jumped to when encounters something that shouldn't be\n                         in the node */\n\n            /* Free up any over-allocated space; cast is to silence bogus\n             * warning in MS VC */\n            change_engine_size(pRExC_state,\n                                - (Ptrdiff_t) (initial_size - STR_SZ(len)));\n\n            /* I (khw) don't know if you can get here with zero length, but the\n             * old code handled this situation by creating a zero-length EXACT\n             * node.  Might as well be NOTHING instead */\n            if (len == 0) {\n                OP(REGNODE_p(ret)) = NOTHING;\n            }\n            else {\n\n                /* If the node type is EXACT here, check to see if it\n                 * should be EXACTL, or EXACT_ONLY8. */\n                if (node_type == EXACT) {\n                    if (LOC) {\n                        node_type = EXACTL;\n                    }\n                    else if (requires_utf8_target) {\n                        node_type = EXACT_ONLY8;\n                    }\n                } else if (FOLD) {\n                    if (    UNLIKELY(has_micro_sign || has_ss)\n                        && (node_type == EXACTFU || (   node_type == EXACTF\n                                                     && maybe_exactfu)))\n                    {   /* These two conditions are problematic in non-UTF-8\n                           EXACTFU nodes. */\n                        assert(! UTF);\n                        node_type = EXACTFUP;\n                    }\n                    else if (node_type == EXACTFL) {\n\n                        /* 'maybe_exactfu' is deliberately set above to\n                         * indicate this node type, where all code points in it\n                         * are above 255 */\n                        if (maybe_exactfu) {\n                            node_type = EXACTFLU8;\n                        }\n                        else if (UNLIKELY(\n                             _invlist_contains_cp(PL_HasMultiCharFold, ender)))\n                        {\n                            /* A character that folds to more than one will\n                             * match multiple characters, so can't be SIMPLE.\n                             * We don't have to worry about this with EXACTFLU8\n                             * nodes just above, as they have already been\n                             * folded (since the fold doesn't vary at run\n                             * time).  Here, if the final character in the node\n                             * folds to multiple, it can't be simple.  (This\n                             * only has an effect if the node has only a single\n                             * character, hence the final one, as elsewhere we\n                             * turn off simple for nodes whose length > 1 */\n                            maybe_SIMPLE = 0;\n                        }\n                    }\n                    else if (node_type == EXACTF) {  /* Means is /di */\n\n                        /* If 'maybe_exactfu' is clear, then we need to stay\n                         * /di.  If it is set, it means there are no code\n                         * points that match differently depending on UTF8ness\n                         * of the target string, so it can become an EXACTFU\n                         * node */\n                        if (! maybe_exactfu) {\n                            RExC_seen_d_op = TRUE;\n                        }\n                        else if (   isALPHA_FOLD_EQ(* STRING(REGNODE_p(ret)), 's')\n                                 || isALPHA_FOLD_EQ(ender, 's'))\n                        {\n                            /* But, if the node begins or ends in an 's' we\n                             * have to defer changing it into an EXACTFU, as\n                             * the node could later get joined with another one\n                             * that ends or begins with 's' creating an 'ss'\n                             * sequence which would then wrongly match the\n                             * sharp s without the target being UTF-8.  We\n                             * create a special node that we resolve later when\n                             * we join nodes together */\n\n                            node_type = EXACTFU_S_EDGE;\n                        }\n                        else {\n                            node_type = EXACTFU;\n                        }\n                    }\n\n                    if (requires_utf8_target && node_type == EXACTFU) {\n                        node_type = EXACTFU_ONLY8;\n                    }\n                }\n\n                OP(REGNODE_p(ret)) = node_type;\n                STR_LEN(REGNODE_p(ret)) = len;\n                RExC_emit += STR_SZ(len);\n\n                /* If the node isn't a single character, it can't be SIMPLE */\n                if (len > (Size_t) ((UTF) ? UVCHR_SKIP(ender) : 1)) {\n                    maybe_SIMPLE = 0;\n                }\n\n                *flagp |= HASWIDTH | maybe_SIMPLE;\n            }\n\n            Set_Node_Length(REGNODE_p(ret), p - parse_start - 1);\n            RExC_parse = p;\n\n\t    {\n\t\t/* len is STRLEN which is unsigned, need to copy to signed */\n\t\tIV iv = len;\n\t\tif (iv < 0)\n\t\t    vFAIL(\"Internal disaster\");\n\t    }\n\n\t} /* End of label 'defchar:' */\n\tbreak;\n    } /* End of giant switch on input character */\n\n    /* Position parse to next real character */\n    skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                            FALSE /* Don't force to /x */ );\n    if (   *RExC_parse == '{'\n        && OP(REGNODE_p(ret)) != SBOL && ! regcurly(RExC_parse))\n    {\n        if (RExC_strict || new_regcurly(RExC_parse, RExC_end)) {\n            RExC_parse++;\n            vFAIL(\"Unescaped left brace in regex is illegal here\");\n        }\n        ckWARNreg(RExC_parse + 1, \"Unescaped left brace in regex is\"\n                                  \" passed through\");\n    }\n\n    return(ret);\n}\n\n\nSTATIC void\nS_populate_ANYOF_from_invlist(pTHX_ regnode *node, SV** invlist_ptr)\n{\n    /* Uses the inversion list '*invlist_ptr' to populate the ANYOF 'node'.  It\n     * sets up the bitmap and any flags, removing those code points from the\n     * inversion list, setting it to NULL should it become completely empty */\n\n    dVAR;\n\n    PERL_ARGS_ASSERT_POPULATE_ANYOF_FROM_INVLIST;\n    assert(PL_regkind[OP(node)] == ANYOF);\n\n    /* There is no bitmap for this node type */\n    if (OP(node) == ANYOFH) {\n        return;\n    }\n\n    ANYOF_BITMAP_ZERO(node);\n    if (*invlist_ptr) {\n\n\t/* This gets set if we actually need to modify things */\n\tbool change_invlist = FALSE;\n\n\tUV start, end;\n\n\t/* Start looking through *invlist_ptr */\n\tinvlist_iterinit(*invlist_ptr);\n\twhile (invlist_iternext(*invlist_ptr, &start, &end)) {\n\t    UV high;\n\t    int i;\n\n            if (end == UV_MAX && start <= NUM_ANYOF_CODE_POINTS) {\n                ANYOF_FLAGS(node) |= ANYOF_MATCHES_ALL_ABOVE_BITMAP;\n            }\n\n\t    /* Quit if are above what we should change */\n\t    if (start >= NUM_ANYOF_CODE_POINTS) {\n\t\tbreak;\n\t    }\n\n\t    change_invlist = TRUE;\n\n\t    /* Set all the bits in the range, up to the max that we are doing */\n\t    high = (end < NUM_ANYOF_CODE_POINTS - 1)\n                   ? end\n                   : NUM_ANYOF_CODE_POINTS - 1;\n\t    for (i = start; i <= (int) high; i++) {\n\t\tif (! ANYOF_BITMAP_TEST(node, i)) {\n\t\t    ANYOF_BITMAP_SET(node, i);\n\t\t}\n\t    }\n\t}\n\tinvlist_iterfinish(*invlist_ptr);\n\n        /* Done with loop; remove any code points that are in the bitmap from\n         * *invlist_ptr; similarly for code points above the bitmap if we have\n         * a flag to match all of them anyways */\n\tif (change_invlist) {\n\t    _invlist_subtract(*invlist_ptr, PL_InBitmap, invlist_ptr);\n\t}\n        if (ANYOF_FLAGS(node) & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {\n\t    _invlist_intersection(*invlist_ptr, PL_InBitmap, invlist_ptr);\n\t}\n\n\t/* If have completely emptied it, remove it completely */\n\tif (_invlist_len(*invlist_ptr) == 0) {\n\t    SvREFCNT_dec_NN(*invlist_ptr);\n\t    *invlist_ptr = NULL;\n\t}\n    }\n}\n\n/* Parse POSIX character classes: [[:foo:]], [[=foo=]], [[.foo.]].\n   Character classes ([:foo:]) can also be negated ([:^foo:]).\n   Returns a named class id (ANYOF_XXX) if successful, -1 otherwise.\n   Equivalence classes ([=foo=]) and composites ([.foo.]) are parsed,\n   but trigger failures because they are currently unimplemented. */\n\n#define POSIXCC_DONE(c)   ((c) == ':')\n#define POSIXCC_NOTYET(c) ((c) == '=' || (c) == '.')\n#define POSIXCC(c) (POSIXCC_DONE(c) || POSIXCC_NOTYET(c))\n#define MAYBE_POSIXCC(c) (POSIXCC(c) || (c) == '^' || (c) == ';')\n\n#define WARNING_PREFIX              \"Assuming NOT a POSIX class since \"\n#define NO_BLANKS_POSIX_WARNING     \"no blanks are allowed in one\"\n#define SEMI_COLON_POSIX_WARNING    \"a semi-colon was found instead of a colon\"\n\n#define NOT_MEANT_TO_BE_A_POSIX_CLASS (OOB_NAMEDCLASS - 1)\n\n/* 'posix_warnings' and 'warn_text' are names of variables in the following\n * routine. q.v. */\n#define ADD_POSIX_WARNING(p, text)  STMT_START {                            \\\n        if (posix_warnings) {                                               \\\n            if (! RExC_warn_text ) RExC_warn_text =                         \\\n                                         (AV *) sv_2mortal((SV *) newAV()); \\\n            av_push(RExC_warn_text, Perl_newSVpvf(aTHX_                     \\\n                                             WARNING_PREFIX                 \\\n                                             text                           \\\n                                             REPORT_LOCATION,               \\\n                                             REPORT_LOCATION_ARGS(p)));     \\\n        }                                                                   \\\n    } STMT_END\n#define CLEAR_POSIX_WARNINGS()                                              \\\n    STMT_START {                                                            \\\n        if (posix_warnings && RExC_warn_text)                               \\\n            av_clear(RExC_warn_text);                                       \\\n    } STMT_END\n\n#define CLEAR_POSIX_WARNINGS_AND_RETURN(ret)                                \\\n    STMT_START {                                                            \\\n        CLEAR_POSIX_WARNINGS();                                             \\\n        return ret;                                                         \\\n    } STMT_END\n\nSTATIC int\nS_handle_possible_posix(pTHX_ RExC_state_t *pRExC_state,\n\n    const char * const s,      /* Where the putative posix class begins.\n                                  Normally, this is one past the '['.  This\n                                  parameter exists so it can be somewhere\n                                  besides RExC_parse. */\n    char ** updated_parse_ptr, /* Where to set the updated parse pointer, or\n                                  NULL */\n    AV ** posix_warnings,      /* Where to place any generated warnings, or\n                                  NULL */\n    const bool check_only      /* Don't die if error */\n)\n{\n    /* This parses what the caller thinks may be one of the three POSIX\n     * constructs:\n     *  1) a character class, like [:blank:]\n     *  2) a collating symbol, like [. .]\n     *  3) an equivalence class, like [= =]\n     * In the latter two cases, it croaks if it finds a syntactically legal\n     * one, as these are not handled by Perl.\n     *\n     * The main purpose is to look for a POSIX character class.  It returns:\n     *  a) the class number\n     *      if it is a completely syntactically and semantically legal class.\n     *      'updated_parse_ptr', if not NULL, is set to point to just after the\n     *      closing ']' of the class\n     *  b) OOB_NAMEDCLASS\n     *      if it appears that one of the three POSIX constructs was meant, but\n     *      its specification was somehow defective.  'updated_parse_ptr', if\n     *      not NULL, is set to point to the character just after the end\n     *      character of the class.  See below for handling of warnings.\n     *  c) NOT_MEANT_TO_BE_A_POSIX_CLASS\n     *      if it  doesn't appear that a POSIX construct was intended.\n     *      'updated_parse_ptr' is not changed.  No warnings nor errors are\n     *      raised.\n     *\n     * In b) there may be errors or warnings generated.  If 'check_only' is\n     * TRUE, then any errors are discarded.  Warnings are returned to the\n     * caller via an AV* created into '*posix_warnings' if it is not NULL.  If\n     * instead it is NULL, warnings are suppressed.\n     *\n     * The reason for this function, and its complexity is that a bracketed\n     * character class can contain just about anything.  But it's easy to\n     * mistype the very specific posix class syntax but yielding a valid\n     * regular bracketed class, so it silently gets compiled into something\n     * quite unintended.\n     *\n     * The solution adopted here maintains backward compatibility except that\n     * it adds a warning if it looks like a posix class was intended but\n     * improperly specified.  The warning is not raised unless what is input\n     * very closely resembles one of the 14 legal posix classes.  To do this,\n     * it uses fuzzy parsing.  It calculates how many single-character edits it\n     * would take to transform what was input into a legal posix class.  Only\n     * if that number is quite small does it think that the intention was a\n     * posix class.  Obviously these are heuristics, and there will be cases\n     * where it errs on one side or another, and they can be tweaked as\n     * experience informs.\n     *\n     * The syntax for a legal posix class is:\n     *\n     * qr/(?xa: \\[ : \\^? [[:lower:]]{4,6} : \\] )/\n     *\n     * What this routine considers syntactically to be an intended posix class\n     * is this (the comments indicate some restrictions that the pattern\n     * doesn't show):\n     *\n     *  qr/(?x: \\[?                         # The left bracket, possibly\n     *                                      # omitted\n     *          \\h*                         # possibly followed by blanks\n     *          (?: \\^ \\h* )?               # possibly a misplaced caret\n     *          [:;]?                       # The opening class character,\n     *                                      # possibly omitted.  A typo\n     *                                      # semi-colon can also be used.\n     *          \\h*\n     *          \\^?                         # possibly a correctly placed\n     *                                      # caret, but not if there was also\n     *                                      # a misplaced one\n     *          \\h*\n     *          .{3,15}                     # The class name.  If there are\n     *                                      # deviations from the legal syntax,\n     *                                      # its edit distance must be close\n     *                                      # to a real class name in order\n     *                                      # for it to be considered to be\n     *                                      # an intended posix class.\n     *          \\h*\n     *          [[:punct:]]?                # The closing class character,\n     *                                      # possibly omitted.  If not a colon\n     *                                      # nor semi colon, the class name\n     *                                      # must be even closer to a valid\n     *                                      # one\n     *          \\h*\n     *          \\]?                         # The right bracket, possibly\n     *                                      # omitted.\n     *     )/\n     *\n     * In the above, \\h must be ASCII-only.\n     *\n     * These are heuristics, and can be tweaked as field experience dictates.\n     * There will be cases when someone didn't intend to specify a posix class\n     * that this warns as being so.  The goal is to minimize these, while\n     * maximizing the catching of things intended to be a posix class that\n     * aren't parsed as such.\n     */\n\n    const char* p             = s;\n    const char * const e      = RExC_end;\n    unsigned complement       = 0;      /* If to complement the class */\n    bool found_problem        = FALSE;  /* Assume OK until proven otherwise */\n    bool has_opening_bracket  = FALSE;\n    bool has_opening_colon    = FALSE;\n    int class_number          = OOB_NAMEDCLASS; /* Out-of-bounds until find\n                                                   valid class */\n    const char * possible_end = NULL;   /* used for a 2nd parse pass */\n    const char* name_start;             /* ptr to class name first char */\n\n    /* If the number of single-character typos the input name is away from a\n     * legal name is no more than this number, it is considered to have meant\n     * the legal name */\n    int max_distance          = 2;\n\n    /* to store the name.  The size determines the maximum length before we\n     * decide that no posix class was intended.  Should be at least\n     * sizeof(\"alphanumeric\") */\n    UV input_text[15];\n    STATIC_ASSERT_DECL(C_ARRAY_LENGTH(input_text) >= sizeof \"alphanumeric\");\n\n    PERL_ARGS_ASSERT_HANDLE_POSSIBLE_POSIX;\n\n    CLEAR_POSIX_WARNINGS();\n\n    if (p >= e) {\n        return NOT_MEANT_TO_BE_A_POSIX_CLASS;\n    }\n\n    if (*(p - 1) != '[') {\n        ADD_POSIX_WARNING(p, \"it doesn't start with a '['\");\n        found_problem = TRUE;\n    }\n    else {\n        has_opening_bracket = TRUE;\n    }\n\n    /* They could be confused and think you can put spaces between the\n     * components */\n    if (isBLANK(*p)) {\n        found_problem = TRUE;\n\n        do {\n            p++;\n        } while (p < e && isBLANK(*p));\n\n        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n    }\n\n    /* For [. .] and [= =].  These are quite different internally from [: :],\n     * so they are handled separately.  */\n    if (POSIXCC_NOTYET(*p) && p < e - 3) /* 1 for the close, and 1 for the ']'\n                                            and 1 for at least one char in it\n                                          */\n    {\n        const char open_char  = *p;\n        const char * temp_ptr = p + 1;\n\n        /* These two constructs are not handled by perl, and if we find a\n         * syntactically valid one, we croak.  khw, who wrote this code, finds\n         * this explanation of them very unclear:\n         * http://pubs.opengroup.org/onlinepubs/009696899/basedefs/xbd_chap09.html\n         * And searching the rest of the internet wasn't very helpful either.\n         * It looks like just about any byte can be in these constructs,\n         * depending on the locale.  But unless the pattern is being compiled\n         * under /l, which is very rare, Perl runs under the C or POSIX locale.\n         * In that case, it looks like [= =] isn't allowed at all, and that\n         * [. .] could be any single code point, but for longer strings the\n         * constituent characters would have to be the ASCII alphabetics plus\n         * the minus-hyphen.  Any sensible locale definition would limit itself\n         * to these.  And any portable one definitely should.  Trying to parse\n         * the general case is a nightmare (see [perl #127604]).  So, this code\n         * looks only for interiors of these constructs that match:\n         *      qr/.|[-\\w]{2,}/\n         * Using \\w relaxes the apparent rules a little, without adding much\n         * danger of mistaking something else for one of these constructs.\n         *\n         * [. .] in some implementations described on the internet is usable to\n         * escape a character that otherwise is special in bracketed character\n         * classes.  For example [.].] means a literal right bracket instead of\n         * the ending of the class\n         *\n         * [= =] can legitimately contain a [. .] construct, but we don't\n         * handle this case, as that [. .] construct will later get parsed\n         * itself and croak then.  And [= =] is checked for even when not under\n         * /l, as Perl has long done so.\n         *\n         * The code below relies on there being a trailing NUL, so it doesn't\n         * have to keep checking if the parse ptr < e.\n         */\n        if (temp_ptr[1] == open_char) {\n            temp_ptr++;\n        }\n        else while (    temp_ptr < e\n                    && (isWORDCHAR(*temp_ptr) || *temp_ptr == '-'))\n        {\n            temp_ptr++;\n        }\n\n        if (*temp_ptr == open_char) {\n            temp_ptr++;\n            if (*temp_ptr == ']') {\n                temp_ptr++;\n                if (! found_problem && ! check_only) {\n                    RExC_parse = (char *) temp_ptr;\n                    vFAIL3(\"POSIX syntax [%c %c] is reserved for future \"\n                            \"extensions\", open_char, open_char);\n                }\n\n                /* Here, the syntax wasn't completely valid, or else the call\n                 * is to check-only */\n                if (updated_parse_ptr) {\n                    *updated_parse_ptr = (char *) temp_ptr;\n                }\n\n                CLEAR_POSIX_WARNINGS_AND_RETURN(OOB_NAMEDCLASS);\n            }\n        }\n\n        /* If we find something that started out to look like one of these\n         * constructs, but isn't, we continue below so that it can be checked\n         * for being a class name with a typo of '.' or '=' instead of a colon.\n         * */\n    }\n\n    /* Here, we think there is a possibility that a [: :] class was meant, and\n     * we have the first real character.  It could be they think the '^' comes\n     * first */\n    if (*p == '^') {\n        found_problem = TRUE;\n        ADD_POSIX_WARNING(p + 1, \"the '^' must come after the colon\");\n        complement = 1;\n        p++;\n\n        if (isBLANK(*p)) {\n            found_problem = TRUE;\n\n            do {\n                p++;\n            } while (p < e && isBLANK(*p));\n\n            ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n        }\n    }\n\n    /* But the first character should be a colon, which they could have easily\n     * mistyped on a qwerty keyboard as a semi-colon (and which may be hard to\n     * distinguish from a colon, so treat that as a colon).  */\n    if (*p == ':') {\n        p++;\n        has_opening_colon = TRUE;\n    }\n    else if (*p == ';') {\n        found_problem = TRUE;\n        p++;\n        ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);\n        has_opening_colon = TRUE;\n    }\n    else {\n        found_problem = TRUE;\n        ADD_POSIX_WARNING(p, \"there must be a starting ':'\");\n\n        /* Consider an initial punctuation (not one of the recognized ones) to\n         * be a left terminator */\n        if (*p != '^' && *p != ']' && isPUNCT(*p)) {\n            p++;\n        }\n    }\n\n    /* They may think that you can put spaces between the components */\n    if (isBLANK(*p)) {\n        found_problem = TRUE;\n\n        do {\n            p++;\n        } while (p < e && isBLANK(*p));\n\n        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n    }\n\n    if (*p == '^') {\n\n        /* We consider something like [^:^alnum:]] to not have been intended to\n         * be a posix class, but XXX maybe we should */\n        if (complement) {\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        complement = 1;\n        p++;\n    }\n\n    /* Again, they may think that you can put spaces between the components */\n    if (isBLANK(*p)) {\n        found_problem = TRUE;\n\n        do {\n            p++;\n        } while (p < e && isBLANK(*p));\n\n        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n    }\n\n    if (*p == ']') {\n\n        /* XXX This ']' may be a typo, and something else was meant.  But\n         * treating it as such creates enough complications, that that\n         * possibility isn't currently considered here.  So we assume that the\n         * ']' is what is intended, and if we've already found an initial '[',\n         * this leaves this construct looking like [:] or [:^], which almost\n         * certainly weren't intended to be posix classes */\n        if (has_opening_bracket) {\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* But this function can be called when we parse the colon for\n         * something like qr/[alpha:]]/, so we back up to look for the\n         * beginning */\n        p--;\n\n        if (*p == ';') {\n            found_problem = TRUE;\n            ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);\n        }\n        else if (*p != ':') {\n\n            /* XXX We are currently very restrictive here, so this code doesn't\n             * consider the possibility that, say, /[alpha.]]/ was intended to\n             * be a posix class. */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* Here we have something like 'foo:]'.  There was no initial colon,\n         * and we back up over 'foo.  XXX Unlike the going forward case, we\n         * don't handle typos of non-word chars in the middle */\n        has_opening_colon = FALSE;\n        p--;\n\n        while (p > RExC_start && isWORDCHAR(*p)) {\n            p--;\n        }\n        p++;\n\n        /* Here, we have positioned ourselves to where we think the first\n         * character in the potential class is */\n    }\n\n    /* Now the interior really starts.  There are certain key characters that\n     * can end the interior, or these could just be typos.  To catch both\n     * cases, we may have to do two passes.  In the first pass, we keep on\n     * going unless we come to a sequence that matches\n     *      qr/ [[:punct:]] [[:blank:]]* \\] /xa\n     * This means it takes a sequence to end the pass, so two typos in a row if\n     * that wasn't what was intended.  If the class is perfectly formed, just\n     * this one pass is needed.  We also stop if there are too many characters\n     * being accumulated, but this number is deliberately set higher than any\n     * real class.  It is set high enough so that someone who thinks that\n     * 'alphanumeric' is a correct name would get warned that it wasn't.\n     * While doing the pass, we keep track of where the key characters were in\n     * it.  If we don't find an end to the class, and one of the key characters\n     * was found, we redo the pass, but stop when we get to that character.\n     * Thus the key character was considered a typo in the first pass, but a\n     * terminator in the second.  If two key characters are found, we stop at\n     * the second one in the first pass.  Again this can miss two typos, but\n     * catches a single one\n     *\n     * In the first pass, 'possible_end' starts as NULL, and then gets set to\n     * point to the first key character.  For the second pass, it starts as -1.\n     * */\n\n    name_start = p;\n  parse_name:\n    {\n        bool has_blank               = FALSE;\n        bool has_upper               = FALSE;\n        bool has_terminating_colon   = FALSE;\n        bool has_terminating_bracket = FALSE;\n        bool has_semi_colon          = FALSE;\n        unsigned int name_len        = 0;\n        int punct_count              = 0;\n\n        while (p < e) {\n\n            /* Squeeze out blanks when looking up the class name below */\n            if (isBLANK(*p) ) {\n                has_blank = TRUE;\n                found_problem = TRUE;\n                p++;\n                continue;\n            }\n\n            /* The name will end with a punctuation */\n            if (isPUNCT(*p)) {\n                const char * peek = p + 1;\n\n                /* Treat any non-']' punctuation followed by a ']' (possibly\n                 * with intervening blanks) as trying to terminate the class.\n                 * ']]' is very likely to mean a class was intended (but\n                 * missing the colon), but the warning message that gets\n                 * generated shows the error position better if we exit the\n                 * loop at the bottom (eventually), so skip it here. */\n                if (*p != ']') {\n                    if (peek < e && isBLANK(*peek)) {\n                        has_blank = TRUE;\n                        found_problem = TRUE;\n                        do {\n                            peek++;\n                        } while (peek < e && isBLANK(*peek));\n                    }\n\n                    if (peek < e && *peek == ']') {\n                        has_terminating_bracket = TRUE;\n                        if (*p == ':') {\n                            has_terminating_colon = TRUE;\n                        }\n                        else if (*p == ';') {\n                            has_semi_colon = TRUE;\n                            has_terminating_colon = TRUE;\n                        }\n                        else {\n                            found_problem = TRUE;\n                        }\n                        p = peek + 1;\n                        goto try_posix;\n                    }\n                }\n\n                /* Here we have punctuation we thought didn't end the class.\n                 * Keep track of the position of the key characters that are\n                 * more likely to have been class-enders */\n                if (*p == ']' || *p == '[' || *p == ':' || *p == ';') {\n\n                    /* Allow just one such possible class-ender not actually\n                     * ending the class. */\n                    if (possible_end) {\n                        break;\n                    }\n                    possible_end = p;\n                }\n\n                /* If we have too many punctuation characters, no use in\n                 * keeping going */\n                if (++punct_count > max_distance) {\n                    break;\n                }\n\n                /* Treat the punctuation as a typo. */\n                input_text[name_len++] = *p;\n                p++;\n            }\n            else if (isUPPER(*p)) { /* Use lowercase for lookup */\n                input_text[name_len++] = toLOWER(*p);\n                has_upper = TRUE;\n                found_problem = TRUE;\n                p++;\n            } else if (! UTF || UTF8_IS_INVARIANT(*p)) {\n                input_text[name_len++] = *p;\n                p++;\n            }\n            else {\n                input_text[name_len++] = utf8_to_uvchr_buf((U8 *) p, e, NULL);\n                p+= UTF8SKIP(p);\n            }\n\n            /* The declaration of 'input_text' is how long we allow a potential\n             * class name to be, before saying they didn't mean a class name at\n             * all */\n            if (name_len >= C_ARRAY_LENGTH(input_text)) {\n                break;\n            }\n        }\n\n        /* We get to here when the possible class name hasn't been properly\n         * terminated before:\n         *   1) we ran off the end of the pattern; or\n         *   2) found two characters, each of which might have been intended to\n         *      be the name's terminator\n         *   3) found so many punctuation characters in the purported name,\n         *      that the edit distance to a valid one is exceeded\n         *   4) we decided it was more characters than anyone could have\n         *      intended to be one. */\n\n        found_problem = TRUE;\n\n        /* In the final two cases, we know that looking up what we've\n         * accumulated won't lead to a match, even a fuzzy one. */\n        if (   name_len >= C_ARRAY_LENGTH(input_text)\n            || punct_count > max_distance)\n        {\n            /* If there was an intermediate key character that could have been\n             * an intended end, redo the parse, but stop there */\n            if (possible_end && possible_end != (char *) -1) {\n                possible_end = (char *) -1; /* Special signal value to say\n                                               we've done a first pass */\n                p = name_start;\n                goto parse_name;\n            }\n\n            /* Otherwise, it can't have meant to have been a class */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* If we ran off the end, and the final character was a punctuation\n         * one, back up one, to look at that final one just below.  Later, we\n         * will restore the parse pointer if appropriate */\n        if (name_len && p == e && isPUNCT(*(p-1))) {\n            p--;\n            name_len--;\n        }\n\n        if (p < e && isPUNCT(*p)) {\n            if (*p == ']') {\n                has_terminating_bracket = TRUE;\n\n                /* If this is a 2nd ']', and the first one is just below this\n                 * one, consider that to be the real terminator.  This gives a\n                 * uniform and better positioning for the warning message  */\n                if (   possible_end\n                    && possible_end != (char *) -1\n                    && *possible_end == ']'\n                    && name_len && input_text[name_len - 1] == ']')\n                {\n                    name_len--;\n                    p = possible_end;\n\n                    /* And this is actually equivalent to having done the 2nd\n                     * pass now, so set it to not try again */\n                    possible_end = (char *) -1;\n                }\n            }\n            else {\n                if (*p == ':') {\n                    has_terminating_colon = TRUE;\n                }\n                else if (*p == ';') {\n                    has_semi_colon = TRUE;\n                    has_terminating_colon = TRUE;\n                }\n                p++;\n            }\n        }\n\n    try_posix:\n\n        /* Here, we have a class name to look up.  We can short circuit the\n         * stuff below for short names that can't possibly be meant to be a\n         * class name.  (We can do this on the first pass, as any second pass\n         * will yield an even shorter name) */\n        if (name_len < 3) {\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* Find which class it is.  Initially switch on the length of the name.\n         * */\n        switch (name_len) {\n            case 4:\n                if (memEQs(name_start, 4, \"word\")) {\n                    /* this is not POSIX, this is the Perl \\w */\n                    class_number = ANYOF_WORDCHAR;\n                }\n                break;\n            case 5:\n                /* Names all of length 5: alnum alpha ascii blank cntrl digit\n                 *                        graph lower print punct space upper\n                 * Offset 4 gives the best switch position.  */\n                switch (name_start[4]) {\n                    case 'a':\n                        if (memBEGINs(name_start, 5, \"alph\")) /* alpha */\n                            class_number = ANYOF_ALPHA;\n                        break;\n                    case 'e':\n                        if (memBEGINs(name_start, 5, \"spac\")) /* space */\n                            class_number = ANYOF_SPACE;\n                        break;\n                    case 'h':\n                        if (memBEGINs(name_start, 5, \"grap\")) /* graph */\n                            class_number = ANYOF_GRAPH;\n                        break;\n                    case 'i':\n                        if (memBEGINs(name_start, 5, \"asci\")) /* ascii */\n                            class_number = ANYOF_ASCII;\n                        break;\n                    case 'k':\n                        if (memBEGINs(name_start, 5, \"blan\")) /* blank */\n                            class_number = ANYOF_BLANK;\n                        break;\n                    case 'l':\n                        if (memBEGINs(name_start, 5, \"cntr\")) /* cntrl */\n                            class_number = ANYOF_CNTRL;\n                        break;\n                    case 'm':\n                        if (memBEGINs(name_start, 5, \"alnu\")) /* alnum */\n                            class_number = ANYOF_ALPHANUMERIC;\n                        break;\n                    case 'r':\n                        if (memBEGINs(name_start, 5, \"lowe\")) /* lower */\n                            class_number = (FOLD) ? ANYOF_CASED : ANYOF_LOWER;\n                        else if (memBEGINs(name_start, 5, \"uppe\")) /* upper */\n                            class_number = (FOLD) ? ANYOF_CASED : ANYOF_UPPER;\n                        break;\n                    case 't':\n                        if (memBEGINs(name_start, 5, \"digi\")) /* digit */\n                            class_number = ANYOF_DIGIT;\n                        else if (memBEGINs(name_start, 5, \"prin\")) /* print */\n                            class_number = ANYOF_PRINT;\n                        else if (memBEGINs(name_start, 5, \"punc\")) /* punct */\n                            class_number = ANYOF_PUNCT;\n                        break;\n                }\n                break;\n            case 6:\n                if (memEQs(name_start, 6, \"xdigit\"))\n                    class_number = ANYOF_XDIGIT;\n                break;\n        }\n\n        /* If the name exactly matches a posix class name the class number will\n         * here be set to it, and the input almost certainly was meant to be a\n         * posix class, so we can skip further checking.  If instead the syntax\n         * is exactly correct, but the name isn't one of the legal ones, we\n         * will return that as an error below.  But if neither of these apply,\n         * it could be that no posix class was intended at all, or that one\n         * was, but there was a typo.  We tease these apart by doing fuzzy\n         * matching on the name */\n        if (class_number == OOB_NAMEDCLASS && found_problem) {\n            const UV posix_names[][6] = {\n                                                { 'a', 'l', 'n', 'u', 'm' },\n                                                { 'a', 'l', 'p', 'h', 'a' },\n                                                { 'a', 's', 'c', 'i', 'i' },\n                                                { 'b', 'l', 'a', 'n', 'k' },\n                                                { 'c', 'n', 't', 'r', 'l' },\n                                                { 'd', 'i', 'g', 'i', 't' },\n                                                { 'g', 'r', 'a', 'p', 'h' },\n                                                { 'l', 'o', 'w', 'e', 'r' },\n                                                { 'p', 'r', 'i', 'n', 't' },\n                                                { 'p', 'u', 'n', 'c', 't' },\n                                                { 's', 'p', 'a', 'c', 'e' },\n                                                { 'u', 'p', 'p', 'e', 'r' },\n                                                { 'w', 'o', 'r', 'd' },\n                                                { 'x', 'd', 'i', 'g', 'i', 't' }\n                                            };\n            /* The names of the above all have added NULs to make them the same\n             * size, so we need to also have the real lengths */\n            const UV posix_name_lengths[] = {\n                                                sizeof(\"alnum\") - 1,\n                                                sizeof(\"alpha\") - 1,\n                                                sizeof(\"ascii\") - 1,\n                                                sizeof(\"blank\") - 1,\n                                                sizeof(\"cntrl\") - 1,\n                                                sizeof(\"digit\") - 1,\n                                                sizeof(\"graph\") - 1,\n                                                sizeof(\"lower\") - 1,\n                                                sizeof(\"print\") - 1,\n                                                sizeof(\"punct\") - 1,\n                                                sizeof(\"space\") - 1,\n                                                sizeof(\"upper\") - 1,\n                                                sizeof(\"word\")  - 1,\n                                                sizeof(\"xdigit\")- 1\n                                            };\n            unsigned int i;\n            int temp_max = max_distance;    /* Use a temporary, so if we\n                                               reparse, we haven't changed the\n                                               outer one */\n\n            /* Use a smaller max edit distance if we are missing one of the\n             * delimiters */\n            if (   has_opening_bracket + has_opening_colon < 2\n                || has_terminating_bracket + has_terminating_colon < 2)\n            {\n                temp_max--;\n            }\n\n            /* See if the input name is close to a legal one */\n            for (i = 0; i < C_ARRAY_LENGTH(posix_names); i++) {\n\n                /* Short circuit call if the lengths are too far apart to be\n                 * able to match */\n                if (abs( (int) (name_len - posix_name_lengths[i]))\n                    > temp_max)\n                {\n                    continue;\n                }\n\n                if (edit_distance(input_text,\n                                  posix_names[i],\n                                  name_len,\n                                  posix_name_lengths[i],\n                                  temp_max\n                                 )\n                    > -1)\n                { /* If it is close, it probably was intended to be a class */\n                    goto probably_meant_to_be;\n                }\n            }\n\n            /* Here the input name is not close enough to a valid class name\n             * for us to consider it to be intended to be a posix class.  If\n             * we haven't already done so, and the parse found a character that\n             * could have been terminators for the name, but which we absorbed\n             * as typos during the first pass, repeat the parse, signalling it\n             * to stop at that character */\n            if (possible_end && possible_end != (char *) -1) {\n                possible_end = (char *) -1;\n                p = name_start;\n                goto parse_name;\n            }\n\n            /* Here neither pass found a close-enough class name */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n    probably_meant_to_be:\n\n        /* Here we think that a posix specification was intended.  Update any\n         * parse pointer */\n        if (updated_parse_ptr) {\n            *updated_parse_ptr = (char *) p;\n        }\n\n        /* If a posix class name was intended but incorrectly specified, we\n         * output or return the warnings */\n        if (found_problem) {\n\n            /* We set flags for these issues in the parse loop above instead of\n             * adding them to the list of warnings, because we can parse it\n             * twice, and we only want one warning instance */\n            if (has_upper) {\n                ADD_POSIX_WARNING(p, \"the name must be all lowercase letters\");\n            }\n            if (has_blank) {\n                ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n            }\n            if (has_semi_colon) {\n                ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);\n            }\n            else if (! has_terminating_colon) {\n                ADD_POSIX_WARNING(p, \"there is no terminating ':'\");\n            }\n            if (! has_terminating_bracket) {\n                ADD_POSIX_WARNING(p, \"there is no terminating ']'\");\n            }\n\n            if (   posix_warnings\n                && RExC_warn_text\n                && av_top_index(RExC_warn_text) > -1)\n            {\n                *posix_warnings = RExC_warn_text;\n            }\n        }\n        else if (class_number != OOB_NAMEDCLASS) {\n            /* If it is a known class, return the class.  The class number\n             * #defines are structured so each complement is +1 to the normal\n             * one */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(class_number + complement);\n        }\n        else if (! check_only) {\n\n            /* Here, it is an unrecognized class.  This is an error (unless the\n            * call is to check only, which we've already handled above) */\n            const char * const complement_string = (complement)\n                                                   ? \"^\"\n                                                   : \"\";\n            RExC_parse = (char *) p;\n            vFAIL3utf8f(\"POSIX class [:%s%\" UTF8f \":] unknown\",\n                        complement_string,\n                        UTF8fARG(UTF, RExC_parse - name_start - 2, name_start));\n        }\n    }\n\n    return OOB_NAMEDCLASS;\n}\n#undef ADD_POSIX_WARNING\n\nSTATIC unsigned  int\nS_regex_set_precedence(const U8 my_operator) {\n\n    /* Returns the precedence in the (?[...]) construct of the input operator,\n     * specified by its character representation.  The precedence follows\n     * general Perl rules, but it extends this so that ')' and ']' have (low)\n     * precedence even though they aren't really operators */\n\n    switch (my_operator) {\n        case '!':\n            return 5;\n        case '&':\n            return 4;\n        case '^':\n        case '|':\n        case '+':\n        case '-':\n            return 3;\n        case ')':\n            return 2;\n        case ']':\n            return 1;\n    }\n\n    NOT_REACHED; /* NOTREACHED */\n    return 0;   /* Silence compiler warning */\n}\n\nSTATIC regnode_offset\nS_handle_regex_sets(pTHX_ RExC_state_t *pRExC_state, SV** return_invlist,\n                    I32 *flagp, U32 depth,\n                    char * const oregcomp_parse)\n{\n    /* Handle the (?[...]) construct to do set operations */\n\n    U8 curchar;                     /* Current character being parsed */\n    UV start, end;\t            /* End points of code point ranges */\n    SV* final = NULL;               /* The end result inversion list */\n    SV* result_string;              /* 'final' stringified */\n    AV* stack;                      /* stack of operators and operands not yet\n                                       resolved */\n    AV* fence_stack = NULL;         /* A stack containing the positions in\n                                       'stack' of where the undealt-with left\n                                       parens would be if they were actually\n                                       put there */\n    /* The 'volatile' is a workaround for an optimiser bug\n     * in Solaris Studio 12.3. See RT #127455 */\n    volatile IV fence = 0;          /* Position of where most recent undealt-\n                                       with left paren in stack is; -1 if none.\n                                     */\n    STRLEN len;                     /* Temporary */\n    regnode_offset node;                  /* Temporary, and final regnode returned by\n                                       this function */\n    const bool save_fold = FOLD;    /* Temporary */\n    char *save_end, *save_parse;    /* Temporaries */\n    const bool in_locale = LOC;     /* we turn off /l during processing */\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_HANDLE_REGEX_SETS;\n\n    DEBUG_PARSE(\"xcls\");\n\n    if (in_locale) {\n        set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);\n    }\n\n    /* The use of this operator implies /u.  This is required so that the\n     * compile time values are valid in all runtime cases */\n    REQUIRE_UNI_RULES(flagp, 0);\n\n    ckWARNexperimental(RExC_parse,\n                       WARN_EXPERIMENTAL__REGEX_SETS,\n                       \"The regex_sets feature is experimental\");\n\n    /* Everything in this construct is a metacharacter.  Operands begin with\n     * either a '\\' (for an escape sequence), or a '[' for a bracketed\n     * character class.  Any other character should be an operator, or\n     * parenthesis for grouping.  Both types of operands are handled by calling\n     * regclass() to parse them.  It is called with a parameter to indicate to\n     * return the computed inversion list.  The parsing here is implemented via\n     * a stack.  Each entry on the stack is a single character representing one\n     * of the operators; or else a pointer to an operand inversion list. */\n\n#define IS_OPERATOR(a) SvIOK(a)\n#define IS_OPERAND(a)  (! IS_OPERATOR(a))\n\n    /* The stack is kept in \u0141ukasiewicz order.  (That's pronounced similar\n     * to luke-a-shave-itch (or -itz), but people who didn't want to bother\n     * with pronouncing it called it Reverse Polish instead, but now that YOU\n     * know how to pronounce it you can use the correct term, thus giving due\n     * credit to the person who invented it, and impressing your geek friends.\n     * Wikipedia says that the pronounciation of \"\u0141\" has been changing so that\n     * it is now more like an English initial W (as in wonk) than an L.)\n     *\n     * This means that, for example, 'a | b & c' is stored on the stack as\n     *\n     * c  [4]\n     * b  [3]\n     * &  [2]\n     * a  [1]\n     * |  [0]\n     *\n     * where the numbers in brackets give the stack [array] element number.\n     * In this implementation, parentheses are not stored on the stack.\n     * Instead a '(' creates a \"fence\" so that the part of the stack below the\n     * fence is invisible except to the corresponding ')' (this allows us to\n     * replace testing for parens, by using instead subtraction of the fence\n     * position).  As new operands are processed they are pushed onto the stack\n     * (except as noted in the next paragraph).  New operators of higher\n     * precedence than the current final one are inserted on the stack before\n     * the lhs operand (so that when the rhs is pushed next, everything will be\n     * in the correct positions shown above.  When an operator of equal or\n     * lower precedence is encountered in parsing, all the stacked operations\n     * of equal or higher precedence are evaluated, leaving the result as the\n     * top entry on the stack.  This makes higher precedence operations\n     * evaluate before lower precedence ones, and causes operations of equal\n     * precedence to left associate.\n     *\n     * The only unary operator '!' is immediately pushed onto the stack when\n     * encountered.  When an operand is encountered, if the top of the stack is\n     * a '!\", the complement is immediately performed, and the '!' popped.  The\n     * resulting value is treated as a new operand, and the logic in the\n     * previous paragraph is executed.  Thus in the expression\n     *      [a] + ! [b]\n     * the stack looks like\n     *\n     * !\n     * a\n     * +\n     *\n     * as 'b' gets parsed, the latter gets evaluated to '!b', and the stack\n     * becomes\n     *\n     * !b\n     * a\n     * +\n     *\n     * A ')' is treated as an operator with lower precedence than all the\n     * aforementioned ones, which causes all operations on the stack above the\n     * corresponding '(' to be evaluated down to a single resultant operand.\n     * Then the fence for the '(' is removed, and the operand goes through the\n     * algorithm above, without the fence.\n     *\n     * A separate stack is kept of the fence positions, so that the position of\n     * the latest so-far unbalanced '(' is at the top of it.\n     *\n     * The ']' ending the construct is treated as the lowest operator of all,\n     * so that everything gets evaluated down to a single operand, which is the\n     * result */\n\n    sv_2mortal((SV *)(stack = newAV()));\n    sv_2mortal((SV *)(fence_stack = newAV()));\n\n    while (RExC_parse < RExC_end) {\n        I32 top_index;              /* Index of top-most element in 'stack' */\n        SV** top_ptr;               /* Pointer to top 'stack' element */\n        SV* current = NULL;         /* To contain the current inversion list\n                                       operand */\n        SV* only_to_avoid_leaks;\n\n        skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                TRUE /* Force /x */ );\n        if (RExC_parse >= RExC_end) {   /* Fail */\n            break;\n        }\n\n        curchar = UCHARAT(RExC_parse);\n\nredo_curchar:\n\n#ifdef ENABLE_REGEX_SETS_DEBUGGING\n                    /* Enable with -Accflags=-DENABLE_REGEX_SETS_DEBUGGING */\n        DEBUG_U(dump_regex_sets_structures(pRExC_state,\n                                           stack, fence, fence_stack));\n#endif\n\n        top_index = av_tindex_skip_len_mg(stack);\n\n        switch (curchar) {\n            SV** stacked_ptr;       /* Ptr to something already on 'stack' */\n            char stacked_operator;  /* The topmost operator on the 'stack'. */\n            SV* lhs;                /* Operand to the left of the operator */\n            SV* rhs;                /* Operand to the right of the operator */\n            SV* fence_ptr;          /* Pointer to top element of the fence\n                                       stack */\n\n            case '(':\n\n                if (   RExC_parse < RExC_end - 2\n                    && UCHARAT(RExC_parse + 1) == '?'\n                    && UCHARAT(RExC_parse + 2) == '^')\n                {\n                    /* If is a '(?', could be an embedded '(?^flags:(?[...])'.\n                     * This happens when we have some thing like\n                     *\n                     *   my $thai_or_lao = qr/(?[ \\p{Thai} + \\p{Lao} ])/;\n                     *   ...\n                     *   qr/(?[ \\p{Digit} & $thai_or_lao ])/;\n                     *\n                     * Here we would be handling the interpolated\n                     * '$thai_or_lao'.  We handle this by a recursive call to\n                     * ourselves which returns the inversion list the\n                     * interpolated expression evaluates to.  We use the flags\n                     * from the interpolated pattern. */\n                    U32 save_flags = RExC_flags;\n                    const char * save_parse;\n\n                    RExC_parse += 2;        /* Skip past the '(?' */\n                    save_parse = RExC_parse;\n\n                    /* Parse the flags for the '(?'.  We already know the first\n                     * flag to parse is a '^' */\n                    parse_lparen_question_flags(pRExC_state);\n\n                    if (   RExC_parse >= RExC_end - 4\n                        || UCHARAT(RExC_parse) != ':'\n                        || UCHARAT(++RExC_parse) != '('\n                        || UCHARAT(++RExC_parse) != '?'\n                        || UCHARAT(++RExC_parse) != '[')\n                    {\n\n                        /* In combination with the above, this moves the\n                         * pointer to the point just after the first erroneous\n                         * character. */\n                        if (RExC_parse >= RExC_end - 4) {\n                            RExC_parse = RExC_end;\n                        }\n                        else if (RExC_parse != save_parse) {\n                            RExC_parse += (UTF)\n                                          ? UTF8_SAFE_SKIP(RExC_parse, RExC_end)\n                                          : 1;\n                        }\n                        vFAIL(\"Expecting '(?flags:(?[...'\");\n                    }\n\n                    /* Recurse, with the meat of the embedded expression */\n                    RExC_parse++;\n                    if (! handle_regex_sets(pRExC_state, &current, flagp,\n                                                    depth+1, oregcomp_parse))\n                    {\n                        RETURN_FAIL_ON_RESTART(*flagp, flagp);\n                    }\n\n                    /* Here, 'current' contains the embedded expression's\n                     * inversion list, and RExC_parse points to the trailing\n                     * ']'; the next character should be the ')' */\n                    RExC_parse++;\n                    if (UCHARAT(RExC_parse) != ')')\n                        vFAIL(\"Expecting close paren for nested extended charclass\");\n\n                    /* Then the ')' matching the original '(' handled by this\n                     * case: statement */\n                    RExC_parse++;\n                    if (UCHARAT(RExC_parse) != ')')\n                        vFAIL(\"Expecting close paren for wrapper for nested extended charclass\");\n\n                    RExC_flags = save_flags;\n                    goto handle_operand;\n                }\n\n                /* A regular '('.  Look behind for illegal syntax */\n                if (top_index - fence >= 0) {\n                    /* If the top entry on the stack is an operator, it had\n                     * better be a '!', otherwise the entry below the top\n                     * operand should be an operator */\n                    if (   ! (top_ptr = av_fetch(stack, top_index, FALSE))\n                        || (IS_OPERATOR(*top_ptr) && SvUV(*top_ptr) != '!')\n                        || (   IS_OPERAND(*top_ptr)\n                            && (   top_index - fence < 1\n                                || ! (stacked_ptr = av_fetch(stack,\n                                                             top_index - 1,\n                                                             FALSE))\n                                || ! IS_OPERATOR(*stacked_ptr))))\n                    {\n                        RExC_parse++;\n                        vFAIL(\"Unexpected '(' with no preceding operator\");\n                    }\n                }\n\n                /* Stack the position of this undealt-with left paren */\n                av_push(fence_stack, newSViv(fence));\n                fence = top_index + 1;\n                break;\n\n            case '\\\\':\n                /* regclass() can only return RESTART_PARSE and NEED_UTF8 if\n                 * multi-char folds are allowed.  */\n                if (!regclass(pRExC_state, flagp, depth+1,\n                              TRUE, /* means parse just the next thing */\n                              FALSE, /* don't allow multi-char folds */\n                              FALSE, /* don't silence non-portable warnings.  */\n                              TRUE,  /* strict */\n                              FALSE, /* Require return to be an ANYOF */\n                              &current))\n                {\n                    RETURN_FAIL_ON_RESTART(*flagp, flagp);\n                    goto regclass_failed;\n                }\n\n                /* regclass() will return with parsing just the \\ sequence,\n                 * leaving the parse pointer at the next thing to parse */\n                RExC_parse--;\n                goto handle_operand;\n\n            case '[':   /* Is a bracketed character class */\n            {\n                /* See if this is a [:posix:] class. */\n                bool is_posix_class = (OOB_NAMEDCLASS\n                            < handle_possible_posix(pRExC_state,\n                                                RExC_parse + 1,\n                                                NULL,\n                                                NULL,\n                                                TRUE /* checking only */));\n                /* If it is a posix class, leave the parse pointer at the '['\n                 * to fool regclass() into thinking it is part of a\n                 * '[[:posix:]]'. */\n                if (! is_posix_class) {\n                    RExC_parse++;\n                }\n\n                /* regclass() can only return RESTART_PARSE and NEED_UTF8 if\n                 * multi-char folds are allowed.  */\n                if (!regclass(pRExC_state, flagp, depth+1,\n                                is_posix_class, /* parse the whole char\n                                                    class only if not a\n                                                    posix class */\n                                FALSE, /* don't allow multi-char folds */\n                                TRUE, /* silence non-portable warnings. */\n                                TRUE, /* strict */\n                                FALSE, /* Require return to be an ANYOF */\n                                &current))\n                {\n                    RETURN_FAIL_ON_RESTART(*flagp, flagp);\n                    goto regclass_failed;\n                }\n\n                if (! current) {\n                    break;\n                }\n\n                /* function call leaves parse pointing to the ']', except if we\n                 * faked it */\n                if (is_posix_class) {\n                    RExC_parse--;\n                }\n\n                goto handle_operand;\n            }\n\n            case ']':\n                if (top_index >= 1) {\n                    goto join_operators;\n                }\n\n                /* Only a single operand on the stack: are done */\n                goto done;\n\n            case ')':\n                if (av_tindex_skip_len_mg(fence_stack) < 0) {\n                    if (UCHARAT(RExC_parse - 1) == ']')  {\n                        break;\n                    }\n                    RExC_parse++;\n                    vFAIL(\"Unexpected ')'\");\n                }\n\n                /* If nothing after the fence, is missing an operand */\n                if (top_index - fence < 0) {\n                    RExC_parse++;\n                    goto bad_syntax;\n                }\n                /* If at least two things on the stack, treat this as an\n                  * operator */\n                if (top_index - fence >= 1) {\n                    goto join_operators;\n                }\n\n                /* Here only a single thing on the fenced stack, and there is a\n                 * fence.  Get rid of it */\n                fence_ptr = av_pop(fence_stack);\n                assert(fence_ptr);\n                fence = SvIV(fence_ptr);\n                SvREFCNT_dec_NN(fence_ptr);\n                fence_ptr = NULL;\n\n                if (fence < 0) {\n                    fence = 0;\n                }\n\n                /* Having gotten rid of the fence, we pop the operand at the\n                 * stack top and process it as a newly encountered operand */\n                current = av_pop(stack);\n                if (IS_OPERAND(current)) {\n                    goto handle_operand;\n                }\n\n                RExC_parse++;\n                goto bad_syntax;\n\n            case '&':\n            case '|':\n            case '+':\n            case '-':\n            case '^':\n\n                /* These binary operators should have a left operand already\n                 * parsed */\n                if (   top_index - fence < 0\n                    || top_index - fence == 1\n                    || ( ! (top_ptr = av_fetch(stack, top_index, FALSE)))\n                    || ! IS_OPERAND(*top_ptr))\n                {\n                    goto unexpected_binary;\n                }\n\n                /* If only the one operand is on the part of the stack visible\n                 * to us, we just place this operator in the proper position */\n                if (top_index - fence < 2) {\n\n                    /* Place the operator before the operand */\n\n                    SV* lhs = av_pop(stack);\n                    av_push(stack, newSVuv(curchar));\n                    av_push(stack, lhs);\n                    break;\n                }\n\n                /* But if there is something else on the stack, we need to\n                 * process it before this new operator if and only if the\n                 * stacked operation has equal or higher precedence than the\n                 * new one */\n\n             join_operators:\n\n                /* The operator on the stack is supposed to be below both its\n                 * operands */\n                if (   ! (stacked_ptr = av_fetch(stack, top_index - 2, FALSE))\n                    || IS_OPERAND(*stacked_ptr))\n                {\n                    /* But if not, it's legal and indicates we are completely\n                     * done if and only if we're currently processing a ']',\n                     * which should be the final thing in the expression */\n                    if (curchar == ']') {\n                        goto done;\n                    }\n\n                  unexpected_binary:\n                    RExC_parse++;\n                    vFAIL2(\"Unexpected binary operator '%c' with no \"\n                           \"preceding operand\", curchar);\n                }\n                stacked_operator = (char) SvUV(*stacked_ptr);\n\n                if (regex_set_precedence(curchar)\n                    > regex_set_precedence(stacked_operator))\n                {\n                    /* Here, the new operator has higher precedence than the\n                     * stacked one.  This means we need to add the new one to\n                     * the stack to await its rhs operand (and maybe more\n                     * stuff).  We put it before the lhs operand, leaving\n                     * untouched the stacked operator and everything below it\n                     * */\n                    lhs = av_pop(stack);\n                    assert(IS_OPERAND(lhs));\n\n                    av_push(stack, newSVuv(curchar));\n                    av_push(stack, lhs);\n                    break;\n                }\n\n                /* Here, the new operator has equal or lower precedence than\n                 * what's already there.  This means the operation already\n                 * there should be performed now, before the new one. */\n\n                rhs = av_pop(stack);\n                if (! IS_OPERAND(rhs)) {\n\n                    /* This can happen when a ! is not followed by an operand,\n                     * like in /(?[\\t &!])/ */\n                    goto bad_syntax;\n                }\n\n                lhs = av_pop(stack);\n\n                if (! IS_OPERAND(lhs)) {\n\n                    /* This can happen when there is an empty (), like in\n                     * /(?[[0]+()+])/ */\n                    goto bad_syntax;\n                }\n\n                switch (stacked_operator) {\n                    case '&':\n                        _invlist_intersection(lhs, rhs, &rhs);\n                        break;\n\n                    case '|':\n                    case '+':\n                        _invlist_union(lhs, rhs, &rhs);\n                        break;\n\n                    case '-':\n                        _invlist_subtract(lhs, rhs, &rhs);\n                        break;\n\n                    case '^':   /* The union minus the intersection */\n                    {\n                        SV* i = NULL;\n                        SV* u = NULL;\n\n                        _invlist_union(lhs, rhs, &u);\n                        _invlist_intersection(lhs, rhs, &i);\n                        _invlist_subtract(u, i, &rhs);\n                        SvREFCNT_dec_NN(i);\n                        SvREFCNT_dec_NN(u);\n                        break;\n                    }\n                }\n                SvREFCNT_dec(lhs);\n\n                /* Here, the higher precedence operation has been done, and the\n                 * result is in 'rhs'.  We overwrite the stacked operator with\n                 * the result.  Then we redo this code to either push the new\n                 * operator onto the stack or perform any higher precedence\n                 * stacked operation */\n                only_to_avoid_leaks = av_pop(stack);\n                SvREFCNT_dec(only_to_avoid_leaks);\n                av_push(stack, rhs);\n                goto redo_curchar;\n\n            case '!':   /* Highest priority, right associative */\n\n                /* If what's already at the top of the stack is another '!\",\n                 * they just cancel each other out */\n                if (   (top_ptr = av_fetch(stack, top_index, FALSE))\n                    && (IS_OPERATOR(*top_ptr) && SvUV(*top_ptr) == '!'))\n                {\n                    only_to_avoid_leaks = av_pop(stack);\n                    SvREFCNT_dec(only_to_avoid_leaks);\n                }\n                else { /* Otherwise, since it's right associative, just push\n                          onto the stack */\n                    av_push(stack, newSVuv(curchar));\n                }\n                break;\n\n            default:\n                RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n                if (RExC_parse >= RExC_end) {\n                    break;\n                }\n                vFAIL(\"Unexpected character\");\n\n          handle_operand:\n\n            /* Here 'current' is the operand.  If something is already on the\n             * stack, we have to check if it is a !.  But first, the code above\n             * may have altered the stack in the time since we earlier set\n             * 'top_index'.  */\n\n            top_index = av_tindex_skip_len_mg(stack);\n            if (top_index - fence >= 0) {\n                /* If the top entry on the stack is an operator, it had better\n                 * be a '!', otherwise the entry below the top operand should\n                 * be an operator */\n                top_ptr = av_fetch(stack, top_index, FALSE);\n                assert(top_ptr);\n                if (IS_OPERATOR(*top_ptr)) {\n\n                    /* The only permissible operator at the top of the stack is\n                     * '!', which is applied immediately to this operand. */\n                    curchar = (char) SvUV(*top_ptr);\n                    if (curchar != '!') {\n                        SvREFCNT_dec(current);\n                        vFAIL2(\"Unexpected binary operator '%c' with no \"\n                                \"preceding operand\", curchar);\n                    }\n\n                    _invlist_invert(current);\n\n                    only_to_avoid_leaks = av_pop(stack);\n                    SvREFCNT_dec(only_to_avoid_leaks);\n\n                    /* And we redo with the inverted operand.  This allows\n                     * handling multiple ! in a row */\n                    goto handle_operand;\n                }\n                          /* Single operand is ok only for the non-binary ')'\n                           * operator */\n                else if ((top_index - fence == 0 && curchar != ')')\n                         || (top_index - fence > 0\n                             && (! (stacked_ptr = av_fetch(stack,\n                                                           top_index - 1,\n                                                           FALSE))\n                                 || IS_OPERAND(*stacked_ptr))))\n                {\n                    SvREFCNT_dec(current);\n                    vFAIL(\"Operand with no preceding operator\");\n                }\n            }\n\n            /* Here there was nothing on the stack or the top element was\n             * another operand.  Just add this new one */\n            av_push(stack, current);\n\n        } /* End of switch on next parse token */\n\n        RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n    } /* End of loop parsing through the construct */\n\n    vFAIL(\"Syntax error in (?[...])\");\n\n  done:\n\n    if (RExC_parse >= RExC_end || RExC_parse[1] != ')') {\n        if (RExC_parse < RExC_end) {\n            RExC_parse++;\n        }\n\n        vFAIL(\"Unexpected ']' with no following ')' in (?[...\");\n    }\n\n    if (av_tindex_skip_len_mg(fence_stack) >= 0) {\n        vFAIL(\"Unmatched (\");\n    }\n\n    if (av_tindex_skip_len_mg(stack) < 0   /* Was empty */\n        || ((final = av_pop(stack)) == NULL)\n        || ! IS_OPERAND(final)\n        || ! is_invlist(final)\n        || av_tindex_skip_len_mg(stack) >= 0)  /* More left on stack */\n    {\n      bad_syntax:\n        SvREFCNT_dec(final);\n        vFAIL(\"Incomplete expression within '(?[ ])'\");\n    }\n\n    /* Here, 'final' is the resultant inversion list from evaluating the\n     * expression.  Return it if so requested */\n    if (return_invlist) {\n        *return_invlist = final;\n        return END;\n    }\n\n    /* Otherwise generate a resultant node, based on 'final'.  regclass() is\n     * expecting a string of ranges and individual code points */\n    invlist_iterinit(final);\n    result_string = newSVpvs(\"\");\n    while (invlist_iternext(final, &start, &end)) {\n        if (start == end) {\n            Perl_sv_catpvf(aTHX_ result_string, \"\\\\x{%\" UVXf \"}\", start);\n        }\n        else {\n            Perl_sv_catpvf(aTHX_ result_string, \"\\\\x{%\" UVXf \"}-\\\\x{%\" UVXf \"}\",\n                                                     start,          end);\n        }\n    }\n\n    /* About to generate an ANYOF (or similar) node from the inversion list we\n     * have calculated */\n    save_parse = RExC_parse;\n    RExC_parse = SvPV(result_string, len);\n    save_end = RExC_end;\n    RExC_end = RExC_parse + len;\n    TURN_OFF_WARNINGS_IN_SUBSTITUTE_PARSE;\n\n    /* We turn off folding around the call, as the class we have constructed\n     * already has all folding taken into consideration, and we don't want\n     * regclass() to add to that */\n    RExC_flags &= ~RXf_PMf_FOLD;\n    /* regclass() can only return RESTART_PARSE and NEED_UTF8 if multi-char\n     * folds are allowed.  */\n    node = regclass(pRExC_state, flagp, depth+1,\n                    FALSE, /* means parse the whole char class */\n                    FALSE, /* don't allow multi-char folds */\n                    TRUE, /* silence non-portable warnings.  The above may very\n                             well have generated non-portable code points, but\n                             they're valid on this machine */\n                    FALSE, /* similarly, no need for strict */\n                    FALSE, /* Require return to be an ANYOF */\n                    NULL\n                );\n\n    RESTORE_WARNINGS;\n    RExC_parse = save_parse + 1;\n    RExC_end = save_end;\n    SvREFCNT_dec_NN(final);\n    SvREFCNT_dec_NN(result_string);\n\n    if (save_fold) {\n        RExC_flags |= RXf_PMf_FOLD;\n    }\n\n    if (!node) {\n        RETURN_FAIL_ON_RESTART(*flagp, flagp);\n        goto regclass_failed;\n    }\n\n    /* Fix up the node type if we are in locale.  (We have pretended we are\n     * under /u for the purposes of regclass(), as this construct will only\n     * work under UTF-8 locales.  But now we change the opcode to be ANYOFL (so\n     * as to cause any warnings about bad locales to be output in regexec.c),\n     * and add the flag that indicates to check if not in a UTF-8 locale.  The\n     * reason we above forbid optimization into something other than an ANYOF\n     * node is simply to minimize the number of code changes in regexec.c.\n     * Otherwise we would have to create new EXACTish node types and deal with\n     * them.  This decision could be revisited should this construct become\n     * popular.\n     *\n     * (One might think we could look at the resulting ANYOF node and suppress\n     * the flag if everything is above 255, as those would be UTF-8 only,\n     * but this isn't true, as the components that led to that result could\n     * have been locale-affected, and just happen to cancel each other out\n     * under UTF-8 locales.) */\n    if (in_locale) {\n        set_regex_charset(&RExC_flags, REGEX_LOCALE_CHARSET);\n\n        assert(OP(REGNODE_p(node)) == ANYOF);\n\n        OP(REGNODE_p(node)) = ANYOFL;\n        ANYOF_FLAGS(REGNODE_p(node))\n                |= ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n    }\n\n    nextchar(pRExC_state);\n    Set_Node_Length(REGNODE_p(node), RExC_parse - oregcomp_parse + 1); /* MJD */\n    return node;\n\n  regclass_failed:\n    FAIL2(\"panic: regclass returned failure to handle_sets, \" \"flags=%#\" UVxf,\n                                                                (UV) *flagp);\n}\n\n#ifdef ENABLE_REGEX_SETS_DEBUGGING\n\nSTATIC void\nS_dump_regex_sets_structures(pTHX_ RExC_state_t *pRExC_state,\n                             AV * stack, const IV fence, AV * fence_stack)\n{   /* Dumps the stacks in handle_regex_sets() */\n\n    const SSize_t stack_top = av_tindex_skip_len_mg(stack);\n    const SSize_t fence_stack_top = av_tindex_skip_len_mg(fence_stack);\n    SSize_t i;\n\n    PERL_ARGS_ASSERT_DUMP_REGEX_SETS_STRUCTURES;\n\n    PerlIO_printf(Perl_debug_log, \"\\nParse position is:%s\\n\", RExC_parse);\n\n    if (stack_top < 0) {\n        PerlIO_printf(Perl_debug_log, \"Nothing on stack\\n\");\n    }\n    else {\n        PerlIO_printf(Perl_debug_log, \"Stack: (fence=%d)\\n\", (int) fence);\n        for (i = stack_top; i >= 0; i--) {\n            SV ** element_ptr = av_fetch(stack, i, FALSE);\n            if (! element_ptr) {\n            }\n\n            if (IS_OPERATOR(*element_ptr)) {\n                PerlIO_printf(Perl_debug_log, \"[%d]: %c\\n\",\n                                            (int) i, (int) SvIV(*element_ptr));\n            }\n            else {\n                PerlIO_printf(Perl_debug_log, \"[%d] \", (int) i);\n                sv_dump(*element_ptr);\n            }\n        }\n    }\n\n    if (fence_stack_top < 0) {\n        PerlIO_printf(Perl_debug_log, \"Nothing on fence_stack\\n\");\n    }\n    else {\n        PerlIO_printf(Perl_debug_log, \"Fence_stack: \\n\");\n        for (i = fence_stack_top; i >= 0; i--) {\n            SV ** element_ptr = av_fetch(fence_stack, i, FALSE);\n            if (! element_ptr) {\n            }\n\n            PerlIO_printf(Perl_debug_log, \"[%d]: %d\\n\",\n                                            (int) i, (int) SvIV(*element_ptr));\n        }\n    }\n}\n\n#endif\n\n#undef IS_OPERATOR\n#undef IS_OPERAND\n\nSTATIC void\nS_add_above_Latin1_folds(pTHX_ RExC_state_t *pRExC_state, const U8 cp, SV** invlist)\n{\n    /* This adds the Latin1/above-Latin1 folding rules.\n     *\n     * This should be called only for a Latin1-range code points, cp, which is\n     * known to be involved in a simple fold with other code points above\n     * Latin1.  It would give false results if /aa has been specified.\n     * Multi-char folds are outside the scope of this, and must be handled\n     * specially. */\n\n    PERL_ARGS_ASSERT_ADD_ABOVE_LATIN1_FOLDS;\n\n    assert(HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(cp));\n\n    /* The rules that are valid for all Unicode versions are hard-coded in */\n    switch (cp) {\n        case 'k':\n        case 'K':\n          *invlist =\n             add_cp_to_invlist(*invlist, KELVIN_SIGN);\n            break;\n        case 's':\n        case 'S':\n          *invlist = add_cp_to_invlist(*invlist, LATIN_SMALL_LETTER_LONG_S);\n            break;\n        case MICRO_SIGN:\n          *invlist = add_cp_to_invlist(*invlist, GREEK_CAPITAL_LETTER_MU);\n          *invlist = add_cp_to_invlist(*invlist, GREEK_SMALL_LETTER_MU);\n            break;\n        case LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE:\n        case LATIN_SMALL_LETTER_A_WITH_RING_ABOVE:\n          *invlist = add_cp_to_invlist(*invlist, ANGSTROM_SIGN);\n            break;\n        case LATIN_SMALL_LETTER_Y_WITH_DIAERESIS:\n          *invlist = add_cp_to_invlist(*invlist,\n                                        LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS);\n            break;\n\n        default:    /* Other code points are checked against the data for the\n                       current Unicode version */\n          {\n            Size_t folds_count;\n            unsigned int first_fold;\n            const unsigned int * remaining_folds;\n            UV folded_cp;\n\n            if (isASCII(cp)) {\n                folded_cp = toFOLD(cp);\n            }\n            else {\n                U8 dummy_fold[UTF8_MAXBYTES_CASE+1];\n                Size_t dummy_len;\n                folded_cp = _to_fold_latin1(cp, dummy_fold, &dummy_len, 0);\n            }\n\n            if (folded_cp > 255) {\n                *invlist = add_cp_to_invlist(*invlist, folded_cp);\n            }\n\n            folds_count = _inverse_folds(folded_cp, &first_fold,\n                                                    &remaining_folds);\n            if (folds_count == 0) {\n\n                /* Use deprecated warning to increase the chances of this being\n                 * output */\n                ckWARN2reg_d(RExC_parse,\n                        \"Perl folding rules are not up-to-date for 0x%02X;\"\n                        \" please use the perlbug utility to report;\", cp);\n            }\n            else {\n                unsigned int i;\n\n                if (first_fold > 255) {\n                    *invlist = add_cp_to_invlist(*invlist, first_fold);\n                }\n                for (i = 0; i < folds_count - 1; i++) {\n                    if (remaining_folds[i] > 255) {\n                        *invlist = add_cp_to_invlist(*invlist,\n                                                    remaining_folds[i]);\n                    }\n                }\n            }\n            break;\n         }\n    }\n}\n\nSTATIC void\nS_output_posix_warnings(pTHX_ RExC_state_t *pRExC_state, AV* posix_warnings)\n{\n    /* Output the elements of the array given by '*posix_warnings' as REGEXP\n     * warnings. */\n\n    SV * msg;\n    const bool first_is_fatal = ckDEAD(packWARN(WARN_REGEXP));\n\n    PERL_ARGS_ASSERT_OUTPUT_POSIX_WARNINGS;\n\n    if (! TO_OUTPUT_WARNINGS(RExC_parse)) {\n        return;\n    }\n\n    while ((msg = av_shift(posix_warnings)) != &PL_sv_undef) {\n        if (first_is_fatal) {           /* Avoid leaking this */\n            av_undef(posix_warnings);   /* This isn't necessary if the\n                                            array is mortal, but is a\n                                            fail-safe */\n            (void) sv_2mortal(msg);\n            PREPARE_TO_DIE;\n        }\n        Perl_warner(aTHX_ packWARN(WARN_REGEXP), \"%s\", SvPVX(msg));\n        SvREFCNT_dec_NN(msg);\n    }\n\n    UPDATE_WARNINGS_LOC(RExC_parse);\n}\n\nSTATIC AV *\nS_add_multi_match(pTHX_ AV* multi_char_matches, SV* multi_string, const STRLEN cp_count)\n{\n    /* This adds the string scalar <multi_string> to the array\n     * <multi_char_matches>.  <multi_string> is known to have exactly\n     * <cp_count> code points in it.  This is used when constructing a\n     * bracketed character class and we find something that needs to match more\n     * than a single character.\n     *\n     * <multi_char_matches> is actually an array of arrays.  Each top-level\n     * element is an array that contains all the strings known so far that are\n     * the same length.  And that length (in number of code points) is the same\n     * as the index of the top-level array.  Hence, the [2] element is an\n     * array, each element thereof is a string containing TWO code points;\n     * while element [3] is for strings of THREE characters, and so on.  Since\n     * this is for multi-char strings there can never be a [0] nor [1] element.\n     *\n     * When we rewrite the character class below, we will do so such that the\n     * longest strings are written first, so that it prefers the longest\n     * matching strings first.  This is done even if it turns out that any\n     * quantifier is non-greedy, out of this programmer's (khw) laziness.  Tom\n     * Christiansen has agreed that this is ok.  This makes the test for the\n     * ligature 'ffi' come before the test for 'ff', for example */\n\n    AV* this_array;\n    AV** this_array_ptr;\n\n    PERL_ARGS_ASSERT_ADD_MULTI_MATCH;\n\n    if (! multi_char_matches) {\n        multi_char_matches = newAV();\n    }\n\n    if (av_exists(multi_char_matches, cp_count)) {\n        this_array_ptr = (AV**) av_fetch(multi_char_matches, cp_count, FALSE);\n        this_array = *this_array_ptr;\n    }\n    else {\n        this_array = newAV();\n        av_store(multi_char_matches, cp_count,\n                 (SV*) this_array);\n    }\n    av_push(this_array, multi_string);\n\n    return multi_char_matches;\n}\n\n/* The names of properties whose definitions are not known at compile time are\n * stored in this SV, after a constant heading.  So if the length has been\n * changed since initialization, then there is a run-time definition. */\n#define HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION                            \\\n                                        (SvCUR(listsv) != initial_listsv_len)\n\n/* There is a restricted set of white space characters that are legal when\n * ignoring white space in a bracketed character class.  This generates the\n * code to skip them.\n *\n * There is a line below that uses the same white space criteria but is outside\n * this macro.  Both here and there must use the same definition */\n#define SKIP_BRACKETED_WHITE_SPACE(do_skip, p)                          \\\n    STMT_START {                                                        \\\n        if (do_skip) {                                                  \\\n            while (isBLANK_A(UCHARAT(p)))                               \\\n            {                                                           \\\n                p++;                                                    \\\n            }                                                           \\\n        }                                                               \\\n    } STMT_END\n\nSTATIC regnode_offset\nS_regclass(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth,\n                 const bool stop_at_1,  /* Just parse the next thing, don't\n                                           look for a full character class */\n                 bool allow_mutiple_chars,\n                 const bool silence_non_portable,   /* Don't output warnings\n                                                       about too large\n                                                       characters */\n                 const bool strict,\n                 bool optimizable,                  /* ? Allow a non-ANYOF return\n                                                       node */\n                 SV** ret_invlist  /* Return an inversion list, not a node */\n          )\n{\n    /* parse a bracketed class specification.  Most of these will produce an\n     * ANYOF node; but something like [a] will produce an EXACT node; [aA], an\n     * EXACTFish node; [[:ascii:]], a POSIXA node; etc.  It is more complex\n     * under /i with multi-character folds: it will be rewritten following the\n     * paradigm of this example, where the <multi-fold>s are characters which\n     * fold to multiple character sequences:\n     *      /[abc\\x{multi-fold1}def\\x{multi-fold2}ghi]/i\n     * gets effectively rewritten as:\n     *      /(?:\\x{multi-fold1}|\\x{multi-fold2}|[abcdefghi]/i\n     * reg() gets called (recursively) on the rewritten version, and this\n     * function will return what it constructs.  (Actually the <multi-fold>s\n     * aren't physically removed from the [abcdefghi], it's just that they are\n     * ignored in the recursion by means of a flag:\n     * <RExC_in_multi_char_class>.)\n     *\n     * ANYOF nodes contain a bit map for the first NUM_ANYOF_CODE_POINTS\n     * characters, with the corresponding bit set if that character is in the\n     * list.  For characters above this, an inversion list is used.  There\n     * are extra bits for \\w, etc. in locale ANYOFs, as what these match is not\n     * determinable at compile time\n     *\n     * On success, returns the offset at which any next node should be placed\n     * into the regex engine program being compiled.\n     *\n     * Returns 0 otherwise, setting flagp to RESTART_PARSE if the parse needs\n     * to be restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to\n     * UTF-8\n     */\n\n    dVAR;\n    UV prevvalue = OOB_UNICODE, save_prevvalue = OOB_UNICODE;\n    IV range = 0;\n    UV value = OOB_UNICODE, save_value = OOB_UNICODE;\n    regnode_offset ret = -1;    /* Initialized to an illegal value */\n    STRLEN numlen;\n    int namedclass = OOB_NAMEDCLASS;\n    char *rangebegin = NULL;\n    SV *listsv = NULL;      /* List of \\p{user-defined} whose definitions\n                               aren't available at the time this was called */\n    STRLEN initial_listsv_len = 0; /* Kind of a kludge to see if it is more\n\t\t\t\t      than just initialized.  */\n    SV* properties = NULL;    /* Code points that match \\p{} \\P{} */\n    SV* posixes = NULL;     /* Code points that match classes like [:word:],\n                               extended beyond the Latin1 range.  These have to\n                               be kept separate from other code points for much\n                               of this function because their handling  is\n                               different under /i, and for most classes under\n                               /d as well */\n    SV* nposixes = NULL;    /* Similarly for [:^word:].  These are kept\n                               separate for a while from the non-complemented\n                               versions because of complications with /d\n                               matching */\n    SV* simple_posixes = NULL; /* But under some conditions, the classes can be\n                                  treated more simply than the general case,\n                                  leading to less compilation and execution\n                                  work */\n    UV element_count = 0;   /* Number of distinct elements in the class.\n\t\t\t       Optimizations may be possible if this is tiny */\n    AV * multi_char_matches = NULL; /* Code points that fold to more than one\n                                       character; used under /i */\n    UV n;\n    char * stop_ptr = RExC_end;    /* where to stop parsing */\n\n    /* ignore unescaped whitespace? */\n    const bool skip_white = cBOOL(   ret_invlist\n                                  || (RExC_flags & RXf_PMf_EXTENDED_MORE));\n\n    /* inversion list of code points this node matches only when the target\n     * string is in UTF-8.  These are all non-ASCII, < 256.  (Because is under\n     * /d) */\n    SV* upper_latin1_only_utf8_matches = NULL;\n\n    /* Inversion list of code points this node matches regardless of things\n     * like locale, folding, utf8ness of the target string */\n    SV* cp_list = NULL;\n\n    /* Like cp_list, but code points on this list need to be checked for things\n     * that fold to/from them under /i */\n    SV* cp_foldable_list = NULL;\n\n    /* Like cp_list, but code points on this list are valid only when the\n     * runtime locale is UTF-8 */\n    SV* only_utf8_locale_list = NULL;\n\n    /* In a range, if one of the endpoints is non-character-set portable,\n     * meaning that it hard-codes a code point that may mean a different\n     * charactger in ASCII vs. EBCDIC, as opposed to, say, a literal 'A' or a\n     * mnemonic '\\t' which each mean the same character no matter which\n     * character set the platform is on. */\n    unsigned int non_portable_endpoint = 0;\n\n    /* Is the range unicode? which means on a platform that isn't 1-1 native\n     * to Unicode (i.e. non-ASCII), each code point in it should be considered\n     * to be a Unicode value.  */\n    bool unicode_range = FALSE;\n    bool invert = FALSE;    /* Is this class to be complemented */\n\n    bool warn_super = ALWAYS_WARN_SUPER;\n\n    const char * orig_parse = RExC_parse;\n\n    /* This variable is used to mark where the end in the input is of something\n     * that looks like a POSIX construct but isn't.  During the parse, when\n     * something looks like it could be such a construct is encountered, it is\n     * checked for being one, but not if we've already checked this area of the\n     * input.  Only after this position is reached do we check again */\n    char *not_posix_region_end = RExC_parse - 1;\n\n    AV* posix_warnings = NULL;\n    const bool do_posix_warnings = ckWARN(WARN_REGEXP);\n    U8 op = END;    /* The returned node-type, initialized to an impossible\n                       one.  */\n    U8 anyof_flags = 0;   /* flag bits if the node is an ANYOF-type */\n    U32 posixl = 0;       /* bit field of posix classes matched under /l */\n\n\n/* Flags as to what things aren't knowable until runtime.  (Note that these are\n * mutually exclusive.) */\n#define HAS_USER_DEFINED_PROPERTY 0x01   /* /u any user-defined properties that\n                                            haven't been defined as of yet */\n#define HAS_D_RUNTIME_DEPENDENCY  0x02   /* /d if the target being matched is\n                                            UTF-8 or not */\n#define HAS_L_RUNTIME_DEPENDENCY   0x04 /* /l what the posix classes match and\n                                            what gets folded */\n    U32 has_runtime_dependency = 0;     /* OR of the above flags */\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGCLASS;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n\n    /* If wants an inversion list returned, we can't optimize to something\n     * else. */\n    if (ret_invlist) {\n        optimizable = FALSE;\n    }\n\n    DEBUG_PARSE(\"clas\");\n\n#if UNICODE_MAJOR_VERSION < 3 /* no multifolds in early Unicode */      \\\n    || (UNICODE_MAJOR_VERSION == 3 && UNICODE_DOT_VERSION == 0          \\\n                                   && UNICODE_DOT_DOT_VERSION == 0)\n    allow_mutiple_chars = FALSE;\n#endif\n\n    /* We include the /i status at the beginning of this so that we can\n     * know it at runtime */\n    listsv = sv_2mortal(Perl_newSVpvf(aTHX_ \"#%d\\n\", cBOOL(FOLD)));\n    initial_listsv_len = SvCUR(listsv);\n    SvTEMP_off(listsv); /* Grr, TEMPs and mortals are conflated.  */\n\n    SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n\n    assert(RExC_parse <= RExC_end);\n\n    if (UCHARAT(RExC_parse) == '^') {\t/* Complement the class */\n\tRExC_parse++;\n        invert = TRUE;\n        allow_mutiple_chars = FALSE;\n        MARK_NAUGHTY(1);\n        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n    }\n\n    /* Check that they didn't say [:posix:] instead of [[:posix:]] */\n    if (! ret_invlist && MAYBE_POSIXCC(UCHARAT(RExC_parse))) {\n        int maybe_class = handle_possible_posix(pRExC_state,\n                                                RExC_parse,\n                                                &not_posix_region_end,\n                                                NULL,\n                                                TRUE /* checking only */);\n        if (maybe_class >= OOB_NAMEDCLASS && do_posix_warnings) {\n            ckWARN4reg(not_posix_region_end,\n                    \"POSIX syntax [%c %c] belongs inside character classes%s\",\n                    *RExC_parse, *RExC_parse,\n                    (maybe_class == OOB_NAMEDCLASS)\n                    ? ((POSIXCC_NOTYET(*RExC_parse))\n                        ? \" (but this one isn't implemented)\"\n                        : \" (but this one isn't fully valid)\")\n                    : \"\"\n                    );\n        }\n    }\n\n    /* If the caller wants us to just parse a single element, accomplish this\n     * by faking the loop ending condition */\n    if (stop_at_1 && RExC_end > RExC_parse) {\n        stop_ptr = RExC_parse + 1;\n    }\n\n    /* allow 1st char to be ']' (allowing it to be '-' is dealt with later) */\n    if (UCHARAT(RExC_parse) == ']')\n\tgoto charclassloop;\n\n    while (1) {\n\n        if (   posix_warnings\n            && av_tindex_skip_len_mg(posix_warnings) >= 0\n            && RExC_parse > not_posix_region_end)\n        {\n            /* Warnings about posix class issues are considered tentative until\n             * we are far enough along in the parse that we can no longer\n             * change our mind, at which point we output them.  This is done\n             * each time through the loop so that a later class won't zap them\n             * before they have been dealt with. */\n            output_posix_warnings(pRExC_state, posix_warnings);\n        }\n\n        if  (RExC_parse >= stop_ptr) {\n            break;\n        }\n\n        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n\n        if  (UCHARAT(RExC_parse) == ']') {\n            break;\n        }\n\n      charclassloop:\n\n\tnamedclass = OOB_NAMEDCLASS; /* initialize as illegal */\n        save_value = value;\n        save_prevvalue = prevvalue;\n\n\tif (!range) {\n\t    rangebegin = RExC_parse;\n\t    element_count++;\n            non_portable_endpoint = 0;\n\t}\n\tif (UTF && ! UTF8_IS_INVARIANT(* RExC_parse)) {\n\t    value = utf8n_to_uvchr((U8*)RExC_parse,\n\t\t\t\t   RExC_end - RExC_parse,\n\t\t\t\t   &numlen, UTF8_ALLOW_DEFAULT);\n\t    RExC_parse += numlen;\n\t}\n\telse\n\t    value = UCHARAT(RExC_parse++);\n\n        if (value == '[') {\n            char * posix_class_end;\n            namedclass = handle_possible_posix(pRExC_state,\n                                               RExC_parse,\n                                               &posix_class_end,\n                                               do_posix_warnings ? &posix_warnings : NULL,\n                                               FALSE    /* die if error */);\n            if (namedclass > OOB_NAMEDCLASS) {\n\n                /* If there was an earlier attempt to parse this particular\n                 * posix class, and it failed, it was a false alarm, as this\n                 * successful one proves */\n                if (   posix_warnings\n                    && av_tindex_skip_len_mg(posix_warnings) >= 0\n                    && not_posix_region_end >= RExC_parse\n                    && not_posix_region_end <= posix_class_end)\n                {\n                    av_undef(posix_warnings);\n                }\n\n                RExC_parse = posix_class_end;\n            }\n            else if (namedclass == OOB_NAMEDCLASS) {\n                not_posix_region_end = posix_class_end;\n            }\n            else {\n                namedclass = OOB_NAMEDCLASS;\n            }\n        }\n        else if (   RExC_parse - 1 > not_posix_region_end\n                 && MAYBE_POSIXCC(value))\n        {\n            (void) handle_possible_posix(\n                        pRExC_state,\n                        RExC_parse - 1,  /* -1 because parse has already been\n                                            advanced */\n                        &not_posix_region_end,\n                        do_posix_warnings ? &posix_warnings : NULL,\n                        TRUE /* checking only */);\n        }\n        else if (  strict && ! skip_white\n                 && (   _generic_isCC(value, _CC_VERTSPACE)\n                     || is_VERTWS_cp_high(value)))\n        {\n            vFAIL(\"Literal vertical space in [] is illegal except under /x\");\n        }\n        else if (value == '\\\\') {\n            /* Is a backslash; get the code point of the char after it */\n\n            if (RExC_parse >= RExC_end) {\n                vFAIL(\"Unmatched [\");\n            }\n\n\t    if (UTF && ! UTF8_IS_INVARIANT(UCHARAT(RExC_parse))) {\n\t\tvalue = utf8n_to_uvchr((U8*)RExC_parse,\n\t\t\t\t   RExC_end - RExC_parse,\n\t\t\t\t   &numlen, UTF8_ALLOW_DEFAULT);\n\t\tRExC_parse += numlen;\n\t    }\n\t    else\n\t\tvalue = UCHARAT(RExC_parse++);\n\n\t    /* Some compilers cannot handle switching on 64-bit integer\n\t     * values, therefore value cannot be an UV.  Yes, this will\n\t     * be a problem later if we want switch on Unicode.\n\t     * A similar issue a little bit later when switching on\n\t     * namedclass. --jhi */\n\n            /* If the \\ is escaping white space when white space is being\n             * skipped, it means that that white space is wanted literally, and\n             * is already in 'value'.  Otherwise, need to translate the escape\n             * into what it signifies. */\n            if (! skip_white || ! isBLANK_A(value)) switch ((I32)value) {\n\n\t    case 'w':\tnamedclass = ANYOF_WORDCHAR;\tbreak;\n\t    case 'W':\tnamedclass = ANYOF_NWORDCHAR;\tbreak;\n\t    case 's':\tnamedclass = ANYOF_SPACE;\tbreak;\n\t    case 'S':\tnamedclass = ANYOF_NSPACE;\tbreak;\n\t    case 'd':\tnamedclass = ANYOF_DIGIT;\tbreak;\n\t    case 'D':\tnamedclass = ANYOF_NDIGIT;\tbreak;\n\t    case 'v':\tnamedclass = ANYOF_VERTWS;\tbreak;\n\t    case 'V':\tnamedclass = ANYOF_NVERTWS;\tbreak;\n\t    case 'h':\tnamedclass = ANYOF_HORIZWS;\tbreak;\n\t    case 'H':\tnamedclass = ANYOF_NHORIZWS;\tbreak;\n            case 'N':  /* Handle \\N{NAME} in class */\n                {\n                    const char * const backslash_N_beg = RExC_parse - 2;\n                    int cp_count;\n\n                    if (! grok_bslash_N(pRExC_state,\n                                        NULL,      /* No regnode */\n                                        &value,    /* Yes single value */\n                                        &cp_count, /* Multiple code pt count */\n                                        flagp,\n                                        strict,\n                                        depth)\n                    ) {\n\n                        if (*flagp & NEED_UTF8)\n                            FAIL(\"panic: grok_bslash_N set NEED_UTF8\");\n\n                        RETURN_FAIL_ON_RESTART_FLAGP(flagp);\n\n                        if (cp_count < 0) {\n                            vFAIL(\"\\\\N in a character class must be a named character: \\\\N{...}\");\n                        }\n                        else if (cp_count == 0) {\n                            ckWARNreg(RExC_parse,\n                              \"Ignoring zero length \\\\N{} in character class\");\n                        }\n                        else { /* cp_count > 1 */\n                            assert(cp_count > 1);\n                            if (! RExC_in_multi_char_class) {\n                                if ( ! allow_mutiple_chars\n                                    || invert\n                                    || range\n                                    || *RExC_parse == '-')\n                                {\n                                    if (strict) {\n                                        RExC_parse--;\n                                        vFAIL(\"\\\\N{} in inverted character class or as a range end-point is restricted to one character\");\n                                    }\n                                    ckWARNreg(RExC_parse, \"Using just the first character returned by \\\\N{} in character class\");\n                                    break; /* <value> contains the first code\n                                              point. Drop out of the switch to\n                                              process it */\n                                }\n                                else {\n                                    SV * multi_char_N = newSVpvn(backslash_N_beg,\n                                                 RExC_parse - backslash_N_beg);\n                                    multi_char_matches\n                                        = add_multi_match(multi_char_matches,\n                                                          multi_char_N,\n                                                          cp_count);\n                                }\n                            }\n                        } /* End of cp_count != 1 */\n\n                        /* This element should not be processed further in this\n                         * class */\n                        element_count--;\n                        value = save_value;\n                        prevvalue = save_prevvalue;\n                        continue;   /* Back to top of loop to get next char */\n                    }\n\n                    /* Here, is a single code point, and <value> contains it */\n                    unicode_range = TRUE;   /* \\N{} are Unicode */\n                }\n                break;\n\t    case 'p':\n\t    case 'P':\n\t\t{\n\t\tchar *e;\n\n\t\t/* \\p means they want Unicode semantics */\n\t\tREQUIRE_UNI_RULES(flagp, 0);\n\n\t\tif (RExC_parse >= RExC_end)\n\t\t    vFAIL2(\"Empty \\\\%c\", (U8)value);\n\t\tif (*RExC_parse == '{') {\n\t\t    const U8 c = (U8)value;\n\t\t    e = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n                    if (!e) {\n                        RExC_parse++;\n                        vFAIL2(\"Missing right brace on \\\\%c{}\", c);\n                    }\n\n                    RExC_parse++;\n\n                    /* White space is allowed adjacent to the braces and after\n                     * any '^', even when not under /x */\n                    while (isSPACE(*RExC_parse)) {\n                         RExC_parse++;\n\t\t    }\n\n\t\t    if (UCHARAT(RExC_parse) == '^') {\n\n                        /* toggle.  (The rhs xor gets the single bit that\n                         * differs between P and p; the other xor inverts just\n                         * that bit) */\n                        value ^= 'P' ^ 'p';\n\n                        RExC_parse++;\n                        while (isSPACE(*RExC_parse)) {\n                            RExC_parse++;\n                        }\n                    }\n\n                    if (e == RExC_parse)\n                        vFAIL2(\"Empty \\\\%c{}\", c);\n\n\t\t    n = e - RExC_parse;\n\t\t    while (isSPACE(*(RExC_parse + n - 1)))\n\t\t        n--;\n\n\t\t}   /* The \\p isn't immediately followed by a '{' */\n\t\telse if (! isALPHA(*RExC_parse)) {\n                    RExC_parse += (UTF)\n                                  ? UTF8_SAFE_SKIP(RExC_parse, RExC_end)\n                                  : 1;\n                    vFAIL2(\"Character following \\\\%c must be '{' or a \"\n                           \"single-character Unicode property name\",\n                           (U8) value);\n                }\n                else {\n\t\t    e = RExC_parse;\n\t\t    n = 1;\n\t\t}\n\t\t{\n                    char* name = RExC_parse;\n\n                    /* Any message returned about expanding the definition */\n                    SV* msg = newSVpvs_flags(\"\", SVs_TEMP);\n\n                    /* If set TRUE, the property is user-defined as opposed to\n                     * official Unicode */\n                    bool user_defined = FALSE;\n\n                    SV * prop_definition = parse_uniprop_string(\n                                            name, n, UTF, FOLD,\n                                            FALSE, /* This is compile-time */\n\n                                            /* We can't defer this defn when\n                                             * the full result is required in\n                                             * this call */\n                                            ! cBOOL(ret_invlist),\n\n                                            &user_defined,\n                                            msg,\n                                            0 /* Base level */\n                                           );\n                    if (SvCUR(msg)) {   /* Assumes any error causes a msg */\n                        assert(prop_definition == NULL);\n                        RExC_parse = e + 1;\n                        if (SvUTF8(msg)) {  /* msg being UTF-8 makes the whole\n                                               thing so, or else the display is\n                                               mojibake */\n                            RExC_utf8 = TRUE;\n                        }\n\t\t\t/* diag_listed_as: Can't find Unicode property definition \"%s\" in regex; marked by <-- HERE in m/%s/ */\n                        vFAIL2utf8f(\"%\" UTF8f, UTF8fARG(SvUTF8(msg),\n                                    SvCUR(msg), SvPVX(msg)));\n                    }\n\n                    if (! is_invlist(prop_definition)) {\n\n                        /* Here, the definition isn't known, so we have gotten\n                         * returned a string that will be evaluated if and when\n                         * encountered at runtime.  We add it to the list of\n                         * such properties, along with whether it should be\n                         * complemented or not */\n                        if (value == 'P') {\n                            sv_catpvs(listsv, \"!\");\n                        }\n                        else {\n                            sv_catpvs(listsv, \"+\");\n                        }\n                        sv_catsv(listsv, prop_definition);\n\n                        has_runtime_dependency |= HAS_USER_DEFINED_PROPERTY;\n\n                        /* We don't know yet what this matches, so have to flag\n                         * it */\n                        anyof_flags |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;\n                    }\n                    else {\n                        assert (prop_definition && is_invlist(prop_definition));\n\n                        /* Here we do have the complete property definition\n                         *\n                         * Temporary workaround for [perl #133136].  For this\n                         * precise input that is in the .t that is failing,\n                         * load utf8.pm, which is what the test wants, so that\n                         * that .t passes */\n                        if (     memEQs(RExC_start, e + 1 - RExC_start,\n                                        \"foo\\\\p{Alnum}\")\n                            && ! hv_common(GvHVn(PL_incgv),\n                                           NULL,\n                                           \"utf8.pm\", sizeof(\"utf8.pm\") - 1,\n                                           0, HV_FETCH_ISEXISTS, NULL, 0))\n                        {\n                            require_pv(\"utf8.pm\");\n                        }\n\n                        if (! user_defined &&\n                            /* We warn on matching an above-Unicode code point\n                             * if the match would return true, except don't\n                             * warn for \\p{All}, which has exactly one element\n                             * = 0 */\n                            (_invlist_contains_cp(prop_definition, 0x110000)\n                                && (! (_invlist_len(prop_definition) == 1\n                                       && *invlist_array(prop_definition) == 0))))\n                        {\n                            warn_super = TRUE;\n                        }\n\n                        /* Invert if asking for the complement */\n                        if (value == 'P') {\n\t\t\t    _invlist_union_complement_2nd(properties,\n                                                          prop_definition,\n                                                          &properties);\n                        }\n                        else {\n                            _invlist_union(properties, prop_definition, &properties);\n\t\t\t}\n                    }\n                }\n\n\t\tRExC_parse = e + 1;\n                namedclass = ANYOF_UNIPROP;  /* no official name, but it's\n                                                named */\n\t\t}\n\t\tbreak;\n\t    case 'n':\tvalue = '\\n';\t\t\tbreak;\n\t    case 'r':\tvalue = '\\r';\t\t\tbreak;\n\t    case 't':\tvalue = '\\t';\t\t\tbreak;\n\t    case 'f':\tvalue = '\\f';\t\t\tbreak;\n\t    case 'b':\tvalue = '\\b';\t\t\tbreak;\n\t    case 'e':\tvalue = ESC_NATIVE;             break;\n\t    case 'a':\tvalue = '\\a';                   break;\n\t    case 'o':\n\t\tRExC_parse--;\t/* function expects to be pointed at the 'o' */\n\t\t{\n\t\t    const char* error_msg;\n\t\t    bool valid = grok_bslash_o(&RExC_parse,\n                                               RExC_end,\n\t\t\t\t\t       &value,\n\t\t\t\t\t       &error_msg,\n                                               TO_OUTPUT_WARNINGS(RExC_parse),\n                                               strict,\n                                               silence_non_portable,\n                                               UTF);\n\t\t    if (! valid) {\n\t\t\tvFAIL(error_msg);\n\t\t    }\n                    UPDATE_WARNINGS_LOC(RExC_parse - 1);\n\t\t}\n                non_portable_endpoint++;\n\t\tbreak;\n\t    case 'x':\n\t\tRExC_parse--;\t/* function expects to be pointed at the 'x' */\n\t\t{\n\t\t    const char* error_msg;\n\t\t    bool valid = grok_bslash_x(&RExC_parse,\n                                               RExC_end,\n\t\t\t\t\t       &value,\n\t\t\t\t\t       &error_msg,\n\t\t\t\t\t       TO_OUTPUT_WARNINGS(RExC_parse),\n                                               strict,\n                                               silence_non_portable,\n                                               UTF);\n                    if (! valid) {\n\t\t\tvFAIL(error_msg);\n\t\t    }\n                    UPDATE_WARNINGS_LOC(RExC_parse - 1);\n\t\t}\n                non_portable_endpoint++;\n\t\tbreak;\n\t    case 'c':\n\t\tvalue = grok_bslash_c(*RExC_parse, TO_OUTPUT_WARNINGS(RExC_parse));\n                UPDATE_WARNINGS_LOC(RExC_parse);\n\t\tRExC_parse++;\n                non_portable_endpoint++;\n\t\tbreak;\n\t    case '0': case '1': case '2': case '3': case '4':\n\t    case '5': case '6': case '7':\n\t\t{\n\t\t    /* Take 1-3 octal digits */\n\t\t    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;\n                    numlen = (strict) ? 4 : 3;\n                    value = grok_oct(--RExC_parse, &numlen, &flags, NULL);\n\t\t    RExC_parse += numlen;\n                    if (numlen != 3) {\n                        if (strict) {\n                            RExC_parse += (UTF)\n                                          ? UTF8_SAFE_SKIP(RExC_parse, RExC_end)\n                                          : 1;\n                            vFAIL(\"Need exactly 3 octal digits\");\n                        }\n                        else if (   numlen < 3 /* like \\08, \\178 */\n                                 && RExC_parse < RExC_end\n                                 && isDIGIT(*RExC_parse)\n                                 && ckWARN(WARN_REGEXP))\n                        {\n                            reg_warn_non_literal_string(\n                                 RExC_parse + 1,\n                                 form_short_octal_warning(RExC_parse, numlen));\n                        }\n                    }\n                    non_portable_endpoint++;\n\t\t    break;\n\t\t}\n\t    default:\n\t\t/* Allow \\_ to not give an error */\n\t\tif (isWORDCHAR(value) && value != '_') {\n                    if (strict) {\n                        vFAIL2(\"Unrecognized escape \\\\%c in character class\",\n                               (int)value);\n                    }\n                    else {\n                        ckWARN2reg(RExC_parse,\n                            \"Unrecognized escape \\\\%c in character class passed through\",\n                            (int)value);\n                    }\n\t\t}\n\t\tbreak;\n\t    }   /* End of switch on char following backslash */\n\t} /* end of handling backslash escape sequences */\n\n        /* Here, we have the current token in 'value' */\n\n\tif (namedclass > OOB_NAMEDCLASS) { /* this is a named class \\blah */\n            U8 classnum;\n\n\t    /* a bad range like a-\\d, a-[:digit:].  The '-' is taken as a\n\t     * literal, as is the character that began the false range, i.e.\n\t     * the 'a' in the examples */\n\t    if (range) {\n                const int w = (RExC_parse >= rangebegin)\n                                ? RExC_parse - rangebegin\n                                : 0;\n                if (strict) {\n                    vFAIL2utf8f(\n                        \"False [] range \\\"%\" UTF8f \"\\\"\",\n                        UTF8fARG(UTF, w, rangebegin));\n                }\n                else {\n                    ckWARN2reg(RExC_parse,\n                        \"False [] range \\\"%\" UTF8f \"\\\"\",\n                        UTF8fARG(UTF, w, rangebegin));\n                    cp_list = add_cp_to_invlist(cp_list, '-');\n                    cp_foldable_list = add_cp_to_invlist(cp_foldable_list,\n                                                            prevvalue);\n                }\n\n\t\trange = 0; /* this was not a true range */\n                element_count += 2; /* So counts for three values */\n\t    }\n\n            classnum = namedclass_to_classnum(namedclass);\n\n\t    if (LOC && namedclass < ANYOF_POSIXL_MAX\n#ifndef HAS_ISASCII\n                && classnum != _CC_ASCII\n#endif\n            ) {\n                SV* scratch_list = NULL;\n\n                /* What the Posix classes (like \\w, [:space:]) match isn't\n                 * generally knowable under locale until actual match time.  A\n                 * special node is used for these which has extra space for a\n                 * bitmap, with a bit reserved for each named class that is to\n                 * be matched against.  (This isn't needed for \\p{} and\n                 * pseudo-classes, as they are not affected by locale, and\n                 * hence are dealt with separately.)  However, if a named class\n                 * and its complement are both present, then it matches\n                 * everything, and there is no runtime dependency.  Odd numbers\n                 * are the complements of the next lower number, so xor works.\n                 * (Note that something like [\\w\\D] should match everything,\n                 * because \\d should be a proper subset of \\w.  But rather than\n                 * trust that the locale is well behaved, we leave this to\n                 * runtime to sort out) */\n                if (POSIXL_TEST(posixl, namedclass ^ 1)) {\n                    cp_list = _add_range_to_invlist(cp_list, 0, UV_MAX);\n                    POSIXL_ZERO(posixl);\n                    has_runtime_dependency &= ~HAS_L_RUNTIME_DEPENDENCY;\n                    anyof_flags &= ~ANYOF_MATCHES_POSIXL;\n                    continue;   /* We could ignore the rest of the class, but\n                                   best to parse it for any errors */\n                }\n                else { /* Here, isn't the complement of any already parsed\n                          class */\n                    POSIXL_SET(posixl, namedclass);\n                    has_runtime_dependency |= HAS_L_RUNTIME_DEPENDENCY;\n                    anyof_flags |= ANYOF_MATCHES_POSIXL;\n\n                    /* The above-Latin1 characters are not subject to locale\n                     * rules.  Just add them to the unconditionally-matched\n                     * list */\n\n                    /* Get the list of the above-Latin1 code points this\n                     * matches */\n                    _invlist_intersection_maybe_complement_2nd(PL_AboveLatin1,\n                                            PL_XPosix_ptrs[classnum],\n\n                                            /* Odd numbers are complements,\n                                             * like NDIGIT, NASCII, ... */\n                                            namedclass % 2 != 0,\n                                            &scratch_list);\n                    /* Checking if 'cp_list' is NULL first saves an extra\n                     * clone.  Its reference count will be decremented at the\n                     * next union, etc, or if this is the only instance, at the\n                     * end of the routine */\n                    if (! cp_list) {\n                        cp_list = scratch_list;\n                    }\n                    else {\n                        _invlist_union(cp_list, scratch_list, &cp_list);\n                        SvREFCNT_dec_NN(scratch_list);\n                    }\n                    continue;   /* Go get next character */\n                }\n            }\n            else {\n\n                /* Here, is not /l, or is a POSIX class for which /l doesn't\n                 * matter (or is a Unicode property, which is skipped here). */\n                if (namedclass >= ANYOF_POSIXL_MAX) {  /* If a special class */\n                    if (namedclass != ANYOF_UNIPROP) { /* UNIPROP = \\p and \\P */\n\n                        /* Here, should be \\h, \\H, \\v, or \\V.  None of /d, /i\n                         * nor /l make a difference in what these match,\n                         * therefore we just add what they match to cp_list. */\n                        if (classnum != _CC_VERTSPACE) {\n                            assert(   namedclass == ANYOF_HORIZWS\n                                   || namedclass == ANYOF_NHORIZWS);\n\n                            /* It turns out that \\h is just a synonym for\n                             * XPosixBlank */\n                            classnum = _CC_BLANK;\n                        }\n\n                        _invlist_union_maybe_complement_2nd(\n                                cp_list,\n                                PL_XPosix_ptrs[classnum],\n                                namedclass % 2 != 0,    /* Complement if odd\n                                                          (NHORIZWS, NVERTWS)\n                                                        */\n                                &cp_list);\n                    }\n                }\n                else if (   AT_LEAST_UNI_SEMANTICS\n                         || classnum == _CC_ASCII\n                         || (DEPENDS_SEMANTICS && (   classnum == _CC_DIGIT\n                                                   || classnum == _CC_XDIGIT)))\n                {\n                    /* We usually have to worry about /d affecting what POSIX\n                     * classes match, with special code needed because we won't\n                     * know until runtime what all matches.  But there is no\n                     * extra work needed under /u and /a; and [:ascii:] is\n                     * unaffected by /d; and :digit: and :xdigit: don't have\n                     * runtime differences under /d.  So we can special case\n                     * these, and avoid some extra work below, and at runtime.\n                     * */\n                    _invlist_union_maybe_complement_2nd(\n                                                     simple_posixes,\n                                                      ((AT_LEAST_ASCII_RESTRICTED)\n                                                       ? PL_Posix_ptrs[classnum]\n                                                       : PL_XPosix_ptrs[classnum]),\n                                                     namedclass % 2 != 0,\n                                                     &simple_posixes);\n                }\n                else {  /* Garden variety class.  If is NUPPER, NALPHA, ...\n                           complement and use nposixes */\n                    SV** posixes_ptr = namedclass % 2 == 0\n                                       ? &posixes\n                                       : &nposixes;\n                    _invlist_union_maybe_complement_2nd(\n                                                     *posixes_ptr,\n                                                     PL_XPosix_ptrs[classnum],\n                                                     namedclass % 2 != 0,\n                                                     posixes_ptr);\n                }\n\t    }\n\t} /* end of namedclass \\blah */\n\n        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n\n        /* If 'range' is set, 'value' is the ending of a range--check its\n         * validity.  (If value isn't a single code point in the case of a\n         * range, we should have figured that out above in the code that\n         * catches false ranges).  Later, we will handle each individual code\n         * point in the range.  If 'range' isn't set, this could be the\n         * beginning of a range, so check for that by looking ahead to see if\n         * the next real character to be processed is the range indicator--the\n         * minus sign */\n\n\tif (range) {\n#ifdef EBCDIC\n            /* For unicode ranges, we have to test that the Unicode as opposed\n             * to the native values are not decreasing.  (Above 255, there is\n             * no difference between native and Unicode) */\n\t    if (unicode_range && prevvalue < 255 && value < 255) {\n                if (NATIVE_TO_LATIN1(prevvalue) > NATIVE_TO_LATIN1(value)) {\n                    goto backwards_range;\n                }\n            }\n            else\n#endif\n\t    if (prevvalue > value) /* b-a */ {\n\t\tint w;\n#ifdef EBCDIC\n              backwards_range:\n#endif\n                w = RExC_parse - rangebegin;\n                vFAIL2utf8f(\n                    \"Invalid [] range \\\"%\" UTF8f \"\\\"\",\n                    UTF8fARG(UTF, w, rangebegin));\n                NOT_REACHED; /* NOTREACHED */\n\t    }\n\t}\n\telse {\n            prevvalue = value; /* save the beginning of the potential range */\n            if (! stop_at_1     /* Can't be a range if parsing just one thing */\n                && *RExC_parse == '-')\n            {\n                char* next_char_ptr = RExC_parse + 1;\n\n                /* Get the next real char after the '-' */\n                SKIP_BRACKETED_WHITE_SPACE(skip_white, next_char_ptr);\n\n                /* If the '-' is at the end of the class (just before the ']',\n                 * it is a literal minus; otherwise it is a range */\n                if (next_char_ptr < RExC_end && *next_char_ptr != ']') {\n                    RExC_parse = next_char_ptr;\n\n                    /* a bad range like \\w-, [:word:]- ? */\n                    if (namedclass > OOB_NAMEDCLASS) {\n                        if (strict || ckWARN(WARN_REGEXP)) {\n                            const int w = RExC_parse >= rangebegin\n                                          ?  RExC_parse - rangebegin\n                                          : 0;\n                            if (strict) {\n                                vFAIL4(\"False [] range \\\"%*.*s\\\"\",\n                                    w, w, rangebegin);\n                            }\n                            else {\n                                vWARN4(RExC_parse,\n                                    \"False [] range \\\"%*.*s\\\"\",\n                                    w, w, rangebegin);\n                            }\n                        }\n                        cp_list = add_cp_to_invlist(cp_list, '-');\n                        element_count++;\n                    } else\n                        range = 1;\t/* yeah, it's a range! */\n                    continue;\t/* but do it the next time */\n                }\n\t    }\n\t}\n\n        if (namedclass > OOB_NAMEDCLASS) {\n            continue;\n        }\n\n        /* Here, we have a single value this time through the loop, and\n         * <prevvalue> is the beginning of the range, if any; or <value> if\n         * not. */\n\n\t/* non-Latin1 code point implies unicode semantics. */\n\tif (value > 255) {\n            REQUIRE_UNI_RULES(flagp, 0);\n\t}\n\n        /* Ready to process either the single value, or the completed range.\n         * For single-valued non-inverted ranges, we consider the possibility\n         * of multi-char folds.  (We made a conscious decision to not do this\n         * for the other cases because it can often lead to non-intuitive\n         * results.  For example, you have the peculiar case that:\n         *  \"s s\" =~ /^[^\\xDF]+$/i => Y\n         *  \"ss\"  =~ /^[^\\xDF]+$/i => N\n         *\n         * See [perl #89750] */\n        if (FOLD && allow_mutiple_chars && value == prevvalue) {\n            if (    value == LATIN_SMALL_LETTER_SHARP_S\n                || (value > 255 && _invlist_contains_cp(PL_HasMultiCharFold,\n                                                        value)))\n            {\n                /* Here <value> is indeed a multi-char fold.  Get what it is */\n\n                U8 foldbuf[UTF8_MAXBYTES_CASE+1];\n                STRLEN foldlen;\n\n                UV folded = _to_uni_fold_flags(\n                                value,\n                                foldbuf,\n                                &foldlen,\n                                FOLD_FLAGS_FULL | (ASCII_FOLD_RESTRICTED\n                                                   ? FOLD_FLAGS_NOMIX_ASCII\n                                                   : 0)\n                                );\n\n                /* Here, <folded> should be the first character of the\n                 * multi-char fold of <value>, with <foldbuf> containing the\n                 * whole thing.  But, if this fold is not allowed (because of\n                 * the flags), <fold> will be the same as <value>, and should\n                 * be processed like any other character, so skip the special\n                 * handling */\n                if (folded != value) {\n\n                    /* Skip if we are recursed, currently parsing the class\n                     * again.  Otherwise add this character to the list of\n                     * multi-char folds. */\n                    if (! RExC_in_multi_char_class) {\n                        STRLEN cp_count = utf8_length(foldbuf,\n                                                      foldbuf + foldlen);\n                        SV* multi_fold = sv_2mortal(newSVpvs(\"\"));\n\n                        Perl_sv_catpvf(aTHX_ multi_fold, \"\\\\x{%\" UVXf \"}\", value);\n\n                        multi_char_matches\n                                        = add_multi_match(multi_char_matches,\n                                                          multi_fold,\n                                                          cp_count);\n\n                    }\n\n                    /* This element should not be processed further in this\n                     * class */\n                    element_count--;\n                    value = save_value;\n                    prevvalue = save_prevvalue;\n                    continue;\n                }\n            }\n        }\n\n        if (strict && ckWARN(WARN_REGEXP)) {\n            if (range) {\n\n                /* If the range starts above 255, everything is portable and\n                 * likely to be so for any forseeable character set, so don't\n                 * warn. */\n                if (unicode_range && non_portable_endpoint && prevvalue < 256) {\n                    vWARN(RExC_parse, \"Both or neither range ends should be Unicode\");\n                }\n                else if (prevvalue != value) {\n\n                    /* Under strict, ranges that stop and/or end in an ASCII\n                     * printable should have each end point be a portable value\n                     * for it (preferably like 'A', but we don't warn if it is\n                     * a (portable) Unicode name or code point), and the range\n                     * must be be all digits or all letters of the same case.\n                     * Otherwise, the range is non-portable and unclear as to\n                     * what it contains */\n                    if (             (isPRINT_A(prevvalue) || isPRINT_A(value))\n                        && (          non_portable_endpoint\n                            || ! (   (isDIGIT_A(prevvalue) && isDIGIT_A(value))\n                                  || (isLOWER_A(prevvalue) && isLOWER_A(value))\n                                  || (isUPPER_A(prevvalue) && isUPPER_A(value))\n                    ))) {\n                        vWARN(RExC_parse, \"Ranges of ASCII printables should\"\n                                          \" be some subset of \\\"0-9\\\",\"\n                                          \" \\\"A-Z\\\", or \\\"a-z\\\"\");\n                    }\n                    else if (prevvalue >= FIRST_NON_ASCII_DECIMAL_DIGIT) {\n                        SSize_t index_start;\n                        SSize_t index_final;\n\n                        /* But the nature of Unicode and languages mean we\n                         * can't do the same checks for above-ASCII ranges,\n                         * except in the case of digit ones.  These should\n                         * contain only digits from the same group of 10.  The\n                         * ASCII case is handled just above.  Hence here, the\n                         * range could be a range of digits.  First some\n                         * unlikely special cases.  Grandfather in that a range\n                         * ending in 19DA (NEW TAI LUE THAM DIGIT ONE) is bad\n                         * if its starting value is one of the 10 digits prior\n                         * to it.  This is because it is an alternate way of\n                         * writing 19D1, and some people may expect it to be in\n                         * that group.  But it is bad, because it won't give\n                         * the expected results.  In Unicode 5.2 it was\n                         * considered to be in that group (of 11, hence), but\n                         * this was fixed in the next version */\n\n                        if (UNLIKELY(value == 0x19DA && prevvalue >= 0x19D0)) {\n                            goto warn_bad_digit_range;\n                        }\n                        else if (UNLIKELY(   prevvalue >= 0x1D7CE\n                                          &&     value <= 0x1D7FF))\n                        {\n                            /* This is the only other case currently in Unicode\n                             * where the algorithm below fails.  The code\n                             * points just above are the end points of a single\n                             * range containing only decimal digits.  It is 5\n                             * different series of 0-9.  All other ranges of\n                             * digits currently in Unicode are just a single\n                             * series.  (And mktables will notify us if a later\n                             * Unicode version breaks this.)\n                             *\n                             * If the range being checked is at most 9 long,\n                             * and the digit values represented are in\n                             * numerical order, they are from the same series.\n                             * */\n                            if (         value - prevvalue > 9\n                                ||    (((    value - 0x1D7CE) % 10)\n                                     <= (prevvalue - 0x1D7CE) % 10))\n                            {\n                                goto warn_bad_digit_range;\n                            }\n                        }\n                        else {\n\n                            /* For all other ranges of digits in Unicode, the\n                             * algorithm is just to check if both end points\n                             * are in the same series, which is the same range.\n                             * */\n                            index_start = _invlist_search(\n                                                    PL_XPosix_ptrs[_CC_DIGIT],\n                                                    prevvalue);\n\n                            /* Warn if the range starts and ends with a digit,\n                             * and they are not in the same group of 10. */\n                            if (   index_start >= 0\n                                && ELEMENT_RANGE_MATCHES_INVLIST(index_start)\n                                && (index_final =\n                                    _invlist_search(PL_XPosix_ptrs[_CC_DIGIT],\n                                                    value)) != index_start\n                                && index_final >= 0\n                                && ELEMENT_RANGE_MATCHES_INVLIST(index_final))\n                            {\n                              warn_bad_digit_range:\n                                vWARN(RExC_parse, \"Ranges of digits should be\"\n                                                  \" from the same group of\"\n                                                  \" 10\");\n                            }\n                        }\n                    }\n                }\n            }\n            if ((! range || prevvalue == value) && non_portable_endpoint) {\n                if (isPRINT_A(value)) {\n                    char literal[3];\n                    unsigned d = 0;\n                    if (isBACKSLASHED_PUNCT(value)) {\n                        literal[d++] = '\\\\';\n                    }\n                    literal[d++] = (char) value;\n                    literal[d++] = '\\0';\n\n                    vWARN4(RExC_parse,\n                           \"\\\"%.*s\\\" is more clearly written simply as \\\"%s\\\"\",\n                           (int) (RExC_parse - rangebegin),\n                           rangebegin,\n                           literal\n                        );\n                }\n                else if isMNEMONIC_CNTRL(value) {\n                    vWARN4(RExC_parse,\n                           \"\\\"%.*s\\\" is more clearly written simply as \\\"%s\\\"\",\n                           (int) (RExC_parse - rangebegin),\n                           rangebegin,\n                           cntrl_to_mnemonic((U8) value)\n                        );\n                }\n            }\n        }\n\n        /* Deal with this element of the class */\n\n#ifndef EBCDIC\n        cp_foldable_list = _add_range_to_invlist(cp_foldable_list,\n                                                    prevvalue, value);\n#else\n        /* On non-ASCII platforms, for ranges that span all of 0..255, and ones\n         * that don't require special handling, we can just add the range like\n         * we do for ASCII platforms */\n        if ((UNLIKELY(prevvalue == 0) && value >= 255)\n            || ! (prevvalue < 256\n                    && (unicode_range\n                        || (! non_portable_endpoint\n                            && ((isLOWER_A(prevvalue) && isLOWER_A(value))\n                                || (isUPPER_A(prevvalue)\n                                    && isUPPER_A(value)))))))\n        {\n            cp_foldable_list = _add_range_to_invlist(cp_foldable_list,\n                                                        prevvalue, value);\n        }\n        else {\n            /* Here, requires special handling.  This can be because it is a\n             * range whose code points are considered to be Unicode, and so\n             * must be individually translated into native, or because its a\n             * subrange of 'A-Z' or 'a-z' which each aren't contiguous in\n             * EBCDIC, but we have defined them to include only the \"expected\"\n             * upper or lower case ASCII alphabetics.  Subranges above 255 are\n             * the same in native and Unicode, so can be added as a range */\n            U8 start = NATIVE_TO_LATIN1(prevvalue);\n            unsigned j;\n            U8 end = (value < 256) ? NATIVE_TO_LATIN1(value) : 255;\n            for (j = start; j <= end; j++) {\n                cp_foldable_list = add_cp_to_invlist(cp_foldable_list, LATIN1_TO_NATIVE(j));\n            }\n            if (value > 255) {\n                cp_foldable_list = _add_range_to_invlist(cp_foldable_list,\n                                                            256, value);\n            }\n        }\n#endif\n\n\trange = 0; /* this range (if it was one) is done now */\n    } /* End of loop through all the text within the brackets */\n\n    if (   posix_warnings && av_tindex_skip_len_mg(posix_warnings) >= 0) {\n        output_posix_warnings(pRExC_state, posix_warnings);\n    }\n\n    /* If anything in the class expands to more than one character, we have to\n     * deal with them by building up a substitute parse string, and recursively\n     * calling reg() on it, instead of proceeding */\n    if (multi_char_matches) {\n\tSV * substitute_parse = newSVpvn_flags(\"?:\", 2, SVs_TEMP);\n        I32 cp_count;\n\tSTRLEN len;\n\tchar *save_end = RExC_end;\n\tchar *save_parse = RExC_parse;\n\tchar *save_start = RExC_start;\n        Size_t constructed_prefix_len = 0; /* This gives the length of the\n                                              constructed portion of the\n                                              substitute parse. */\n        bool first_time = TRUE;     /* First multi-char occurrence doesn't get\n                                       a \"|\" */\n        I32 reg_flags;\n\n        assert(! invert);\n        /* Only one level of recursion allowed */\n        assert(RExC_copy_start_in_constructed == RExC_precomp);\n\n#if 0   /* Have decided not to deal with multi-char folds in inverted classes,\n           because too confusing */\n        if (invert) {\n            sv_catpvs(substitute_parse, \"(?:\");\n        }\n#endif\n\n        /* Look at the longest folds first */\n        for (cp_count = av_tindex_skip_len_mg(multi_char_matches);\n                        cp_count > 0;\n                        cp_count--)\n        {\n\n            if (av_exists(multi_char_matches, cp_count)) {\n                AV** this_array_ptr;\n                SV* this_sequence;\n\n                this_array_ptr = (AV**) av_fetch(multi_char_matches,\n                                                 cp_count, FALSE);\n                while ((this_sequence = av_pop(*this_array_ptr)) !=\n                                                                &PL_sv_undef)\n                {\n                    if (! first_time) {\n                        sv_catpvs(substitute_parse, \"|\");\n                    }\n                    first_time = FALSE;\n\n                    sv_catpv(substitute_parse, SvPVX(this_sequence));\n                }\n            }\n        }\n\n        /* If the character class contains anything else besides these\n         * multi-character folds, have to include it in recursive parsing */\n        if (element_count) {\n            sv_catpvs(substitute_parse, \"|[\");\n            constructed_prefix_len = SvCUR(substitute_parse);\n            sv_catpvn(substitute_parse, orig_parse, RExC_parse - orig_parse);\n\n            /* Put in a closing ']' only if not going off the end, as otherwise\n             * we are adding something that really isn't there */\n            if (RExC_parse < RExC_end) {\n                sv_catpvs(substitute_parse, \"]\");\n            }\n        }\n\n        sv_catpvs(substitute_parse, \")\");\n#if 0\n        if (invert) {\n            /* This is a way to get the parse to skip forward a whole named\n             * sequence instead of matching the 2nd character when it fails the\n             * first */\n            sv_catpvs(substitute_parse, \"(*THEN)(*SKIP)(*FAIL)|.)\");\n        }\n#endif\n\n        /* Set up the data structure so that any errors will be properly\n         * reported.  See the comments at the definition of\n         * REPORT_LOCATION_ARGS for details */\n        RExC_copy_start_in_input = (char *) orig_parse;\n\tRExC_start = RExC_parse = SvPV(substitute_parse, len);\n        RExC_copy_start_in_constructed = RExC_start + constructed_prefix_len;\n\tRExC_end = RExC_parse + len;\n        RExC_in_multi_char_class = 1;\n\n\tret = reg(pRExC_state, 1, &reg_flags, depth+1);\n\n        *flagp |= reg_flags & (HASWIDTH|SIMPLE|SPSTART|POSTPONED|RESTART_PARSE|NEED_UTF8);\n\n        /* And restore so can parse the rest of the pattern */\n        RExC_parse = save_parse;\n\tRExC_start = RExC_copy_start_in_constructed = RExC_copy_start_in_input = save_start;\n\tRExC_end = save_end;\n\tRExC_in_multi_char_class = 0;\n        SvREFCNT_dec_NN(multi_char_matches);\n        return ret;\n    }\n\n    /* If folding, we calculate all characters that could fold to or from the\n     * ones already on the list */\n    if (cp_foldable_list) {\n        if (FOLD) {\n            UV start, end;\t/* End points of code point ranges */\n\n            SV* fold_intersection = NULL;\n            SV** use_list;\n\n            /* Our calculated list will be for Unicode rules.  For locale\n             * matching, we have to keep a separate list that is consulted at\n             * runtime only when the locale indicates Unicode rules (and we\n             * don't include potential matches in the ASCII/Latin1 range, as\n             * any code point could fold to any other, based on the run-time\n             * locale).   For non-locale, we just use the general list */\n            if (LOC) {\n                use_list = &only_utf8_locale_list;\n            }\n            else {\n                use_list = &cp_list;\n            }\n\n            /* Only the characters in this class that participate in folds need\n             * be checked.  Get the intersection of this class and all the\n             * possible characters that are foldable.  This can quickly narrow\n             * down a large class */\n            _invlist_intersection(PL_in_some_fold, cp_foldable_list,\n                                  &fold_intersection);\n\n            /* Now look at the foldable characters in this class individually */\n            invlist_iterinit(fold_intersection);\n            while (invlist_iternext(fold_intersection, &start, &end)) {\n                UV j;\n                UV folded;\n\n                /* Look at every character in the range */\n                for (j = start; j <= end; j++) {\n                    U8 foldbuf[UTF8_MAXBYTES_CASE+1];\n                    STRLEN foldlen;\n                    unsigned int k;\n                    Size_t folds_count;\n                    unsigned int first_fold;\n                    const unsigned int * remaining_folds;\n\n                    if (j < 256) {\n\n                        /* Under /l, we don't know what code points below 256\n                         * fold to, except we do know the MICRO SIGN folds to\n                         * an above-255 character if the locale is UTF-8, so we\n                         * add it to the special list (in *use_list)  Otherwise\n                         * we know now what things can match, though some folds\n                         * are valid under /d only if the target is UTF-8.\n                         * Those go in a separate list */\n                        if (      IS_IN_SOME_FOLD_L1(j)\n                            && ! (LOC && j != MICRO_SIGN))\n                        {\n\n                            /* ASCII is always matched; non-ASCII is matched\n                             * only under Unicode rules (which could happen\n                             * under /l if the locale is a UTF-8 one */\n                            if (isASCII(j) || ! DEPENDS_SEMANTICS) {\n                                *use_list = add_cp_to_invlist(*use_list,\n                                                            PL_fold_latin1[j]);\n                            }\n                            else if (j != PL_fold_latin1[j]) {\n                                upper_latin1_only_utf8_matches\n                                        = add_cp_to_invlist(\n                                                upper_latin1_only_utf8_matches,\n                                                PL_fold_latin1[j]);\n                            }\n                        }\n\n                        if (HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(j)\n                            && (! isASCII(j) || ! ASCII_FOLD_RESTRICTED))\n                        {\n                            add_above_Latin1_folds(pRExC_state,\n                                                   (U8) j,\n                                                   use_list);\n                        }\n                        continue;\n                    }\n\n                    /* Here is an above Latin1 character.  We don't have the\n                     * rules hard-coded for it.  First, get its fold.  This is\n                     * the simple fold, as the multi-character folds have been\n                     * handled earlier and separated out */\n                    folded = _to_uni_fold_flags(j, foldbuf, &foldlen,\n                                                        (ASCII_FOLD_RESTRICTED)\n                                                        ? FOLD_FLAGS_NOMIX_ASCII\n                                                        : 0);\n\n                    /* Single character fold of above Latin1.  Add everything\n                     * in its fold closure to the list that this node should\n                     * match. */\n                    folds_count = _inverse_folds(folded, &first_fold,\n                                                    &remaining_folds);\n                    for (k = 0; k <= folds_count; k++) {\n                        UV c = (k == 0)     /* First time through use itself */\n                                ? folded\n                                : (k == 1)  /* 2nd time use, the first fold */\n                                   ? first_fold\n\n                                     /* Then the remaining ones */\n                                   : remaining_folds[k-2];\n\n                        /* /aa doesn't allow folds between ASCII and non- */\n                        if ((   ASCII_FOLD_RESTRICTED\n                            && (isASCII(c) != isASCII(j))))\n                        {\n                            continue;\n                        }\n\n                        /* Folds under /l which cross the 255/256 boundary are\n                         * added to a separate list.  (These are valid only\n                         * when the locale is UTF-8.) */\n                        if (c < 256 && LOC) {\n                            *use_list = add_cp_to_invlist(*use_list, c);\n                            continue;\n                        }\n\n                        if (isASCII(c) || c > 255 || AT_LEAST_UNI_SEMANTICS)\n                        {\n                            cp_list = add_cp_to_invlist(cp_list, c);\n                        }\n                        else {\n                            /* Similarly folds involving non-ascii Latin1\n                             * characters under /d are added to their list */\n                            upper_latin1_only_utf8_matches\n                                    = add_cp_to_invlist(\n                                                upper_latin1_only_utf8_matches,\n                                                c);\n                        }\n                    }\n                }\n            }\n            SvREFCNT_dec_NN(fold_intersection);\n        }\n\n        /* Now that we have finished adding all the folds, there is no reason\n         * to keep the foldable list separate */\n        _invlist_union(cp_list, cp_foldable_list, &cp_list);\n\tSvREFCNT_dec_NN(cp_foldable_list);\n    }\n\n    /* And combine the result (if any) with any inversion lists from posix\n     * classes.  The lists are kept separate up to now because we don't want to\n     * fold the classes */\n    if (simple_posixes) {   /* These are the classes known to be unaffected by\n                               /a, /aa, and /d */\n        if (cp_list) {\n            _invlist_union(cp_list, simple_posixes, &cp_list);\n            SvREFCNT_dec_NN(simple_posixes);\n        }\n        else {\n            cp_list = simple_posixes;\n        }\n    }\n    if (posixes || nposixes) {\n        if (! DEPENDS_SEMANTICS) {\n\n            /* For everything but /d, we can just add the current 'posixes' and\n             * 'nposixes' to the main list */\n            if (posixes) {\n                if (cp_list) {\n                    _invlist_union(cp_list, posixes, &cp_list);\n                    SvREFCNT_dec_NN(posixes);\n                }\n                else {\n                    cp_list = posixes;\n                }\n            }\n            if (nposixes) {\n                if (cp_list) {\n                    _invlist_union(cp_list, nposixes, &cp_list);\n                    SvREFCNT_dec_NN(nposixes);\n                }\n                else {\n                    cp_list = nposixes;\n                }\n            }\n        }\n        else {\n            /* Under /d, things like \\w match upper Latin1 characters only if\n             * the target string is in UTF-8.  But things like \\W match all the\n             * upper Latin1 characters if the target string is not in UTF-8.\n             *\n             * Handle the case with something like \\W separately */\n            if (nposixes) {\n                SV* only_non_utf8_list = invlist_clone(PL_UpperLatin1, NULL);\n\n                /* A complemented posix class matches all upper Latin1\n                 * characters if not in UTF-8.  And it matches just certain\n                 * ones when in UTF-8.  That means those certain ones are\n                 * matched regardless, so can just be added to the\n                 * unconditional list */\n                if (cp_list) {\n                    _invlist_union(cp_list, nposixes, &cp_list);\n                    SvREFCNT_dec_NN(nposixes);\n                    nposixes = NULL;\n                }\n                else {\n                    cp_list = nposixes;\n                }\n\n                /* Likewise for 'posixes' */\n                _invlist_union(posixes, cp_list, &cp_list);\n                SvREFCNT_dec(posixes);\n\n                /* Likewise for anything else in the range that matched only\n                 * under UTF-8 */\n                if (upper_latin1_only_utf8_matches) {\n                    _invlist_union(cp_list,\n                                   upper_latin1_only_utf8_matches,\n                                   &cp_list);\n                    SvREFCNT_dec_NN(upper_latin1_only_utf8_matches);\n                    upper_latin1_only_utf8_matches = NULL;\n                }\n\n                /* If we don't match all the upper Latin1 characters regardless\n                 * of UTF-8ness, we have to set a flag to match the rest when\n                 * not in UTF-8 */\n                _invlist_subtract(only_non_utf8_list, cp_list,\n                                  &only_non_utf8_list);\n                if (_invlist_len(only_non_utf8_list) != 0) {\n                    anyof_flags |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;\n                }\n                SvREFCNT_dec_NN(only_non_utf8_list);\n            }\n            else {\n                /* Here there were no complemented posix classes.  That means\n                 * the upper Latin1 characters in 'posixes' match only when the\n                 * target string is in UTF-8.  So we have to add them to the\n                 * list of those types of code points, while adding the\n                 * remainder to the unconditional list.\n                 *\n                 * First calculate what they are */\n                SV* nonascii_but_latin1_properties = NULL;\n                _invlist_intersection(posixes, PL_UpperLatin1,\n                                      &nonascii_but_latin1_properties);\n\n                /* And add them to the final list of such characters. */\n                _invlist_union(upper_latin1_only_utf8_matches,\n                               nonascii_but_latin1_properties,\n                               &upper_latin1_only_utf8_matches);\n\n                /* Remove them from what now becomes the unconditional list */\n                _invlist_subtract(posixes, nonascii_but_latin1_properties,\n                                  &posixes);\n\n                /* And add those unconditional ones to the final list */\n                if (cp_list) {\n                    _invlist_union(cp_list, posixes, &cp_list);\n                    SvREFCNT_dec_NN(posixes);\n                    posixes = NULL;\n                }\n                else {\n                    cp_list = posixes;\n                }\n\n                SvREFCNT_dec(nonascii_but_latin1_properties);\n\n                /* Get rid of any characters from the conditional list that we\n                 * now know are matched unconditionally, which may make that\n                 * list empty */\n                _invlist_subtract(upper_latin1_only_utf8_matches,\n                                  cp_list,\n                                  &upper_latin1_only_utf8_matches);\n                if (_invlist_len(upper_latin1_only_utf8_matches) == 0) {\n                    SvREFCNT_dec_NN(upper_latin1_only_utf8_matches);\n                    upper_latin1_only_utf8_matches = NULL;\n                }\n            }\n        }\n    }\n\n    /* And combine the result (if any) with any inversion list from properties.\n     * The lists are kept separate up to now so that we can distinguish the two\n     * in regards to matching above-Unicode.  A run-time warning is generated\n     * if a Unicode property is matched against a non-Unicode code point. But,\n     * we allow user-defined properties to match anything, without any warning,\n     * and we also suppress the warning if there is a portion of the character\n     * class that isn't a Unicode property, and which matches above Unicode, \\W\n     * or [\\x{110000}] for example.\n     * (Note that in this case, unlike the Posix one above, there is no\n     * <upper_latin1_only_utf8_matches>, because having a Unicode property\n     * forces Unicode semantics */\n    if (properties) {\n        if (cp_list) {\n\n            /* If it matters to the final outcome, see if a non-property\n             * component of the class matches above Unicode.  If so, the\n             * warning gets suppressed.  This is true even if just a single\n             * such code point is specified, as, though not strictly correct if\n             * another such code point is matched against, the fact that they\n             * are using above-Unicode code points indicates they should know\n             * the issues involved */\n            if (warn_super) {\n                warn_super = ! (invert\n                               ^ (invlist_highest(cp_list) > PERL_UNICODE_MAX));\n            }\n\n            _invlist_union(properties, cp_list, &cp_list);\n            SvREFCNT_dec_NN(properties);\n        }\n        else {\n            cp_list = properties;\n        }\n\n        if (warn_super) {\n            anyof_flags\n             |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;\n\n            /* Because an ANYOF node is the only one that warns, this node\n             * can't be optimized into something else */\n            optimizable = FALSE;\n        }\n    }\n\n    /* Here, we have calculated what code points should be in the character\n     * class.\n     *\n     * Now we can see about various optimizations.  Fold calculation (which we\n     * did above) needs to take place before inversion.  Otherwise /[^k]/i\n     * would invert to include K, which under /i would match k, which it\n     * shouldn't.  Therefore we can't invert folded locale now, as it won't be\n     * folded until runtime */\n\n    /* If we didn't do folding, it's because some information isn't available\n     * until runtime; set the run-time fold flag for these  We know to set the\n     * flag if we have a non-NULL list for UTF-8 locales, or the class matches\n     * at least one 0-255 range code point */\n    if (LOC && FOLD) {\n\n        /* Some things on the list might be unconditionally included because of\n         * other components.  Remove them, and clean up the list if it goes to\n         * 0 elements */\n        if (only_utf8_locale_list && cp_list) {\n            _invlist_subtract(only_utf8_locale_list, cp_list,\n                              &only_utf8_locale_list);\n\n            if (_invlist_len(only_utf8_locale_list) == 0) {\n                SvREFCNT_dec_NN(only_utf8_locale_list);\n                only_utf8_locale_list = NULL;\n            }\n        }\n        if (    only_utf8_locale_list\n            || (cp_list && (   _invlist_contains_cp(cp_list, LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE)\n                            || _invlist_contains_cp(cp_list, LATIN_SMALL_LETTER_DOTLESS_I))))\n        {\n            has_runtime_dependency |= HAS_L_RUNTIME_DEPENDENCY;\n            anyof_flags\n                 |= ANYOFL_FOLD\n                 |  ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n        }\n        else if (cp_list) { /* Look to see if a 0-255 code point is in list */\n            UV start, end;\n            invlist_iterinit(cp_list);\n            if (invlist_iternext(cp_list, &start, &end) && start < 256) {\n                anyof_flags |= ANYOFL_FOLD;\n                has_runtime_dependency |= HAS_L_RUNTIME_DEPENDENCY;\n            }\n            invlist_iterfinish(cp_list);\n        }\n    }\n    else if (   DEPENDS_SEMANTICS\n             && (    upper_latin1_only_utf8_matches\n                 || (anyof_flags & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER)))\n    {\n        RExC_seen_d_op = TRUE;\n        has_runtime_dependency |= HAS_D_RUNTIME_DEPENDENCY;\n    }\n\n    /* Optimize inverted patterns (e.g. [^a-z]) when everything is known at\n     * compile time. */\n    if (     cp_list\n        &&   invert\n        && ! has_runtime_dependency)\n    {\n        _invlist_invert(cp_list);\n\n\t/* Clear the invert flag since have just done it here */\n\tinvert = FALSE;\n    }\n\n    if (ret_invlist) {\n        *ret_invlist = cp_list;\n\n        return RExC_emit;\n    }\n\n    /* All possible optimizations below still have these characteristics.\n     * (Multi-char folds aren't SIMPLE, but they don't get this far in this\n     * routine) */\n    *flagp |= HASWIDTH|SIMPLE;\n\n    if (anyof_flags & ANYOF_LOCALE_FLAGS) {\n        RExC_contains_locale = 1;\n    }\n\n    /* Some character classes are equivalent to other nodes.  Such nodes take\n     * up less room, and some nodes require fewer operations to execute, than\n     * ANYOF nodes.  EXACTish nodes may be joinable with adjacent nodes to\n     * improve efficiency. */\n\n    if (optimizable) {\n        PERL_UINT_FAST8_T i;\n        Size_t partial_cp_count = 0;\n        UV start[MAX_FOLD_FROMS+1] = { 0 }; /* +1 for the folded-to char */\n        UV   end[MAX_FOLD_FROMS+1] = { 0 };\n\n        if (cp_list) { /* Count the code points in enough ranges that we would\n                          see all the ones possible in any fold in this version\n                          of Unicode */\n\n            invlist_iterinit(cp_list);\n            for (i = 0; i <= MAX_FOLD_FROMS; i++) {\n                if (! invlist_iternext(cp_list, &start[i], &end[i])) {\n                    break;\n                }\n                partial_cp_count += end[i] - start[i] + 1;\n            }\n\n            invlist_iterfinish(cp_list);\n        }\n\n        /* If we know at compile time that this matches every possible code\n         * point, any run-time dependencies don't matter */\n        if (start[0] == 0 && end[0] == UV_MAX) {\n            if (invert) {\n                ret = reganode(pRExC_state, OPFAIL, 0);\n            }\n            else {\n                ret = reg_node(pRExC_state, SANY);\n                MARK_NAUGHTY(1);\n            }\n            goto not_anyof;\n        }\n\n        /* Similarly, for /l posix classes, if both a class and its\n         * complement match, any run-time dependencies don't matter */\n        if (posixl) {\n            for (namedclass = 0; namedclass < ANYOF_POSIXL_MAX;\n                                                        namedclass += 2)\n            {\n                if (   POSIXL_TEST(posixl, namedclass)      /* class */\n                    && POSIXL_TEST(posixl, namedclass + 1)) /* its complement */\n                {\n                    if (invert) {\n                        ret = reganode(pRExC_state, OPFAIL, 0);\n                    }\n                    else {\n                        ret = reg_node(pRExC_state, SANY);\n                        MARK_NAUGHTY(1);\n                    }\n                    goto not_anyof;\n                }\n            }\n            /* For well-behaved locales, some classes are subsets of others,\n             * so complementing the subset and including the non-complemented\n             * superset should match everything, like [\\D[:alnum:]], and\n             * [[:^alpha:][:alnum:]], but some implementations of locales are\n             * buggy, and khw thinks its a bad idea to have optimization change\n             * behavior, even if it avoids an OS bug in a given case */\n\n#define isSINGLE_BIT_SET(n) isPOWER_OF_2(n)\n\n            /* If is a single posix /l class, can optimize to just that op.\n             * Such a node will not match anything in the Latin1 range, as that\n             * is not determinable until runtime, but will match whatever the\n             * class does outside that range.  (Note that some classes won't\n             * match anything outside the range, like [:ascii:]) */\n            if (    isSINGLE_BIT_SET(posixl)\n                && (partial_cp_count == 0 || start[0] > 255))\n            {\n                U8 classnum;\n                SV * class_above_latin1 = NULL;\n                bool already_inverted;\n                bool are_equivalent;\n\n                /* Compute which bit is set, which is the same thing as, e.g.,\n                 * ANYOF_CNTRL.  From\n                 * https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogDeBruijn\n                 * */\n                static const int MultiplyDeBruijnBitPosition2[32] =\n                    {\n                    0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,\n                    31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9\n                    };\n\n                namedclass = MultiplyDeBruijnBitPosition2[(posixl\n                                                          * 0x077CB531U) >> 27];\n                classnum = namedclass_to_classnum(namedclass);\n\n                /* The named classes are such that the inverted number is one\n                 * larger than the non-inverted one */\n                already_inverted = namedclass\n                                 - classnum_to_namedclass(classnum);\n\n                /* Create an inversion list of the official property, inverted\n                 * if the constructed node list is inverted, and restricted to\n                 * only the above latin1 code points, which are the only ones\n                 * known at compile time */\n                _invlist_intersection_maybe_complement_2nd(\n                                                    PL_AboveLatin1,\n                                                    PL_XPosix_ptrs[classnum],\n                                                    already_inverted,\n                                                    &class_above_latin1);\n                are_equivalent = _invlistEQ(class_above_latin1, cp_list,\n                                                                        FALSE);\n                SvREFCNT_dec_NN(class_above_latin1);\n\n                if (are_equivalent) {\n\n                    /* Resolve the run-time inversion flag with this possibly\n                     * inverted class */\n                    invert = invert ^ already_inverted;\n\n                    ret = reg_node(pRExC_state,\n                                   POSIXL + invert * (NPOSIXL - POSIXL));\n                    FLAGS(REGNODE_p(ret)) = classnum;\n                    goto not_anyof;\n                }\n            }\n        }\n\n        /* khw can't think of any other possible transformation involving\n         * these. */\n        if (has_runtime_dependency & HAS_USER_DEFINED_PROPERTY) {\n            goto is_anyof;\n        }\n\n        if (! has_runtime_dependency) {\n\n            /* If the list is empty, nothing matches.  This happens, for\n             * example, when a Unicode property that doesn't match anything is\n             * the only element in the character class (perluniprops.pod notes\n             * such properties). */\n            if (partial_cp_count == 0) {\n                if (invert) {\n                    ret = reg_node(pRExC_state, SANY);\n                }\n                else {\n                    ret = reganode(pRExC_state, OPFAIL, 0);\n                }\n\n                goto not_anyof;\n            }\n\n            /* If matches everything but \\n */\n            if (   start[0] == 0 && end[0] == '\\n' - 1\n                && start[1] == '\\n' + 1 && end[1] == UV_MAX)\n            {\n                assert (! invert);\n                ret = reg_node(pRExC_state, REG_ANY);\n                MARK_NAUGHTY(1);\n                goto not_anyof;\n            }\n        }\n\n        /* Next see if can optimize classes that contain just a few code points\n         * into an EXACTish node.  The reason to do this is to let the\n         * optimizer join this node with adjacent EXACTish ones.\n         *\n         * An EXACTFish node can be generated even if not under /i, and vice\n         * versa.  But care must be taken.  An EXACTFish node has to be such\n         * that it only matches precisely the code points in the class, but we\n         * want to generate the least restrictive one that does that, to\n         * increase the odds of being able to join with an adjacent node.  For\n         * example, if the class contains [kK], we have to make it an EXACTFAA\n         * node to prevent the KELVIN SIGN from matching.  Whether we are under\n         * /i or not is irrelevant in this case.  Less obvious is the pattern\n         * qr/[\\x{02BC}]n/i.  U+02BC is MODIFIER LETTER APOSTROPHE. That is\n         * supposed to match the single character U+0149 LATIN SMALL LETTER N\n         * PRECEDED BY APOSTROPHE.  And so even though there is no simple fold\n         * that includes \\X{02BC}, there is a multi-char fold that does, and so\n         * the node generated for it must be an EXACTFish one.  On the other\n         * hand qr/:/i should generate a plain EXACT node since the colon\n         * participates in no fold whatsoever, and having it EXACT tells the\n         * optimizer the target string cannot match unless it has a colon in\n         * it.\n         *\n         * We don't typically generate an EXACTish node if doing so would\n         * require changing the pattern to UTF-8, as that affects /d and\n         * otherwise is slower.  However, under /i, not changing to UTF-8 can\n         * miss some potential multi-character folds.  We calculate the\n         * EXACTish node, and then decide if something would be missed if we\n         * don't upgrade */\n        if (   ! posixl\n            && ! invert\n\n                /* Only try if there are no more code points in the class than\n                 * in the max possible fold */\n            &&   partial_cp_count > 0 && partial_cp_count <= MAX_FOLD_FROMS + 1\n\n            && (start[0] < 256 || UTF || FOLD))\n        {\n            if (partial_cp_count == 1 && ! upper_latin1_only_utf8_matches)\n            {\n                /* We can always make a single code point class into an\n                 * EXACTish node. */\n\n                if (LOC) {\n\n                    /* Here is /l:  Use EXACTL, except /li indicates EXACTFL,\n                     * as that means there is a fold not known until runtime so\n                     * shows as only a single code point here. */\n                    op = (FOLD) ? EXACTFL : EXACTL;\n                }\n                else if (! FOLD) { /* Not /l and not /i */\n                    op = (start[0] < 256) ? EXACT : EXACT_ONLY8;\n                }\n                else if (start[0] < 256) { /* /i, not /l, and the code point is\n                                              small */\n\n                    /* Under /i, it gets a little tricky.  A code point that\n                     * doesn't participate in a fold should be an EXACT node.\n                     * We know this one isn't the result of a simple fold, or\n                     * there'd be more than one code point in the list, but it\n                     * could be part of a multi- character fold.  In that case\n                     * we better not create an EXACT node, as we would wrongly\n                     * be telling the optimizer that this code point must be in\n                     * the target string, and that is wrong.  This is because\n                     * if the sequence around this code point forms a\n                     * multi-char fold, what needs to be in the string could be\n                     * the code point that folds to the sequence.\n                     *\n                     * This handles the case of below-255 code points, as we\n                     * have an easy look up for those.  The next clause handles\n                     * the above-256 one */\n                    op = IS_IN_SOME_FOLD_L1(start[0])\n                         ? EXACTFU\n                         : EXACT;\n                }\n                else {  /* /i, larger code point.  Since we are under /i, and\n                           have just this code point, we know that it can't\n                           fold to something else, so PL_InMultiCharFold\n                           applies to it */\n                    op = _invlist_contains_cp(PL_InMultiCharFold,\n                                              start[0])\n                         ? EXACTFU_ONLY8\n                         : EXACT_ONLY8;\n                }\n\n                value = start[0];\n            }\n            else if (  ! (has_runtime_dependency & ~HAS_D_RUNTIME_DEPENDENCY)\n                     && _invlist_contains_cp(PL_in_some_fold, start[0]))\n            {\n                /* Here, the only runtime dependency, if any, is from /d, and\n                 * the class matches more than one code point, and the lowest\n                 * code point participates in some fold.  It might be that the\n                 * other code points are /i equivalent to this one, and hence\n                 * they would representable by an EXACTFish node.  Above, we\n                 * eliminated classes that contain too many code points to be\n                 * EXACTFish, with the test for MAX_FOLD_FROMS\n                 *\n                 * First, special case the ASCII fold pairs, like 'B' and 'b'.\n                 * We do this because we have EXACTFAA at our disposal for the\n                 * ASCII range */\n                if (partial_cp_count == 2 && isASCII(start[0])) {\n\n                    /* The only ASCII characters that participate in folds are\n                     * alphabetics */\n                    assert(isALPHA(start[0]));\n                    if (   end[0] == start[0]   /* First range is a single\n                                                   character, so 2nd exists */\n                        && isALPHA_FOLD_EQ(start[0], start[1]))\n                    {\n\n                        /* Here, is part of an ASCII fold pair */\n\n                        if (   ASCII_FOLD_RESTRICTED\n                            || HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(start[0]))\n                        {\n                            /* If the second clause just above was true, it\n                             * means we can't be under /i, or else the list\n                             * would have included more than this fold pair.\n                             * Therefore we have to exclude the possibility of\n                             * whatever else it is that folds to these, by\n                             * using EXACTFAA */\n                            op = EXACTFAA;\n                        }\n                        else if (HAS_NONLATIN1_FOLD_CLOSURE(start[0])) {\n\n                            /* Here, there's no simple fold that start[0] is part\n                             * of, but there is a multi-character one.  If we\n                             * are not under /i, we want to exclude that\n                             * possibility; if under /i, we want to include it\n                             * */\n                            op = (FOLD) ? EXACTFU : EXACTFAA;\n                        }\n                        else {\n\n                            /* Here, the only possible fold start[0] particpates in\n                             * is with start[1].  /i or not isn't relevant */\n                            op = EXACTFU;\n                        }\n\n                        value = toFOLD(start[0]);\n                    }\n                }\n                else if (  ! upper_latin1_only_utf8_matches\n                         || (   _invlist_len(upper_latin1_only_utf8_matches)\n                                                                          == 2\n                             && PL_fold_latin1[\n                               invlist_highest(upper_latin1_only_utf8_matches)]\n                             == start[0]))\n                {\n                    /* Here, the smallest character is non-ascii or there are\n                     * more than 2 code points matched by this node.  Also, we\n                     * either don't have /d UTF-8 dependent matches, or if we\n                     * do, they look like they could be a single character that\n                     * is the fold of the lowest one in the always-match list.\n                     * This test quickly excludes most of the false positives\n                     * when there are /d UTF-8 depdendent matches.  These are\n                     * like LATIN CAPITAL LETTER A WITH GRAVE matching LATIN\n                     * SMALL LETTER A WITH GRAVE iff the target string is\n                     * UTF-8.  (We don't have to worry above about exceeding\n                     * the array bounds of PL_fold_latin1[] because any code\n                     * point in 'upper_latin1_only_utf8_matches' is below 256.)\n                     *\n                     * EXACTFAA would apply only to pairs (hence exactly 2 code\n                     * points) in the ASCII range, so we can't use it here to\n                     * artificially restrict the fold domain, so we check if\n                     * the class does or does not match some EXACTFish node.\n                     * Further, if we aren't under /i, and and the folded-to\n                     * character is part of a multi-character fold, we can't do\n                     * this optimization, as the sequence around it could be\n                     * that multi-character fold, and we don't here know the\n                     * context, so we have to assume it is that multi-char\n                     * fold, to prevent potential bugs.\n                     *\n                     * To do the general case, we first find the fold of the\n                     * lowest code point (which may be higher than the lowest\n                     * one), then find everything that folds to it.  (The data\n                     * structure we have only maps from the folded code points,\n                     * so we have to do the earlier step.) */\n\n                    Size_t foldlen;\n                    U8 foldbuf[UTF8_MAXBYTES_CASE];\n                    UV folded = _to_uni_fold_flags(start[0],\n                                                        foldbuf, &foldlen, 0);\n                    unsigned int first_fold;\n                    const unsigned int * remaining_folds;\n                    Size_t folds_to_this_cp_count = _inverse_folds(\n                                                            folded,\n                                                            &first_fold,\n                                                            &remaining_folds);\n                    Size_t folds_count = folds_to_this_cp_count + 1;\n                    SV * fold_list = _new_invlist(folds_count);\n                    unsigned int i;\n\n                    /* If there are UTF-8 dependent matches, create a temporary\n                     * list of what this node matches, including them. */\n                    SV * all_cp_list = NULL;\n                    SV ** use_this_list = &cp_list;\n\n                    if (upper_latin1_only_utf8_matches) {\n                        all_cp_list = _new_invlist(0);\n                        use_this_list = &all_cp_list;\n                        _invlist_union(cp_list,\n                                       upper_latin1_only_utf8_matches,\n                                       use_this_list);\n                    }\n\n                    /* Having gotten everything that participates in the fold\n                     * containing the lowest code point, we turn that into an\n                     * inversion list, making sure everything is included. */\n                    fold_list = add_cp_to_invlist(fold_list, start[0]);\n                    fold_list = add_cp_to_invlist(fold_list, folded);\n                    if (folds_to_this_cp_count > 0) {\n                        fold_list = add_cp_to_invlist(fold_list, first_fold);\n                        for (i = 0; i + 1 < folds_to_this_cp_count; i++) {\n                            fold_list = add_cp_to_invlist(fold_list,\n                                                        remaining_folds[i]);\n                        }\n                    }\n\n                    /* If the fold list is identical to what's in this ANYOF\n                     * node, the node can be represented by an EXACTFish one\n                     * instead */\n                    if (_invlistEQ(*use_this_list, fold_list,\n                                   0 /* Don't complement */ )\n                    ) {\n\n                        /* But, we have to be careful, as mentioned above.\n                         * Just the right sequence of characters could match\n                         * this if it is part of a multi-character fold.  That\n                         * IS what we want if we are under /i.  But it ISN'T\n                         * what we want if not under /i, as it could match when\n                         * it shouldn't.  So, when we aren't under /i and this\n                         * character participates in a multi-char fold, we\n                         * don't optimize into an EXACTFish node.  So, for each\n                         * case below we have to check if we are folding\n                         * and if not, if it is not part of a multi-char fold.\n                         * */\n                        if (start[0] > 255) {    /* Highish code point */\n                            if (FOLD || ! _invlist_contains_cp(\n                                            PL_InMultiCharFold, folded))\n                            {\n                                op = (LOC)\n                                     ? EXACTFLU8\n                                     : (ASCII_FOLD_RESTRICTED)\n                                       ? EXACTFAA\n                                       : EXACTFU_ONLY8;\n                                value = folded;\n                            }\n                        }   /* Below, the lowest code point < 256 */\n                        else if (    FOLD\n                                 &&  folded == 's'\n                                 &&  DEPENDS_SEMANTICS)\n                        {   /* An EXACTF node containing a single character\n                                's', can be an EXACTFU if it doesn't get\n                                joined with an adjacent 's' */\n                            op = EXACTFU_S_EDGE;\n                            value = folded;\n                        }\n                        else if (    FOLD\n                                || ! HAS_NONLATIN1_FOLD_CLOSURE(start[0]))\n                        {\n                            if (upper_latin1_only_utf8_matches) {\n                                op = EXACTF;\n\n                                /* We can't use the fold, as that only matches\n                                 * under UTF-8 */\n                                value = start[0];\n                            }\n                            else if (     UNLIKELY(start[0] == MICRO_SIGN)\n                                     && ! UTF)\n                            {   /* EXACTFUP is a special node for this\n                                   character */\n                                op = (ASCII_FOLD_RESTRICTED)\n                                     ? EXACTFAA\n                                     : EXACTFUP;\n                                value = MICRO_SIGN;\n                            }\n                            else if (     ASCII_FOLD_RESTRICTED\n                                     && ! isASCII(start[0]))\n                            {   /* For ASCII under /iaa, we can use EXACTFU\n                                   below */\n                                op = EXACTFAA;\n                                value = folded;\n                            }\n                            else {\n                                op = EXACTFU;\n                                value = folded;\n                            }\n                        }\n                    }\n\n                    SvREFCNT_dec_NN(fold_list);\n                    SvREFCNT_dec(all_cp_list);\n                }\n            }\n\n            if (op != END) {\n\n                /* Here, we have calculated what EXACTish node we would use.\n                 * But we don't use it if it would require converting the\n                 * pattern to UTF-8, unless not using it could cause us to miss\n                 * some folds (hence be buggy) */\n\n                if (! UTF && value > 255) {\n                    SV * in_multis = NULL;\n\n                    assert(FOLD);\n\n                    /* If there is no code point that is part of a multi-char\n                     * fold, then there aren't any matches, so we don't do this\n                     * optimization.  Otherwise, it could match depending on\n                     * the context around us, so we do upgrade */\n                    _invlist_intersection(PL_InMultiCharFold, cp_list, &in_multis);\n                    if (UNLIKELY(_invlist_len(in_multis) != 0)) {\n                        REQUIRE_UTF8(flagp);\n                    }\n                    else {\n                        op = END;\n                    }\n                }\n\n                if (op != END) {\n                    U8 len = (UTF) ? UVCHR_SKIP(value) : 1;\n\n                    ret = regnode_guts(pRExC_state, op, len, \"exact\");\n                    FILL_NODE(ret, op);\n                    RExC_emit += 1 + STR_SZ(len);\n                    STR_LEN(REGNODE_p(ret)) = len;\n                    if (len == 1) {\n                        *STRING(REGNODE_p(ret)) = (U8) value;\n                    }\n                    else {\n                        uvchr_to_utf8((U8 *) STRING(REGNODE_p(ret)), value);\n                    }\n                    goto not_anyof;\n                }\n            }\n        }\n\n        if (! has_runtime_dependency) {\n\n            /* See if this can be turned into an ANYOFM node.  Think about the\n             * bit patterns in two different bytes.  In some positions, the\n             * bits in each will be 1; and in other positions both will be 0;\n             * and in some positions the bit will be 1 in one byte, and 0 in\n             * the other.  Let 'n' be the number of positions where the bits\n             * differ.  We create a mask which has exactly 'n' 0 bits, each in\n             * a position where the two bytes differ.  Now take the set of all\n             * bytes that when ANDed with the mask yield the same result.  That\n             * set has 2**n elements, and is representable by just two 8 bit\n             * numbers: the result and the mask.  Importantly, matching the set\n             * can be vectorized by creating a word full of the result bytes,\n             * and a word full of the mask bytes, yielding a significant speed\n             * up.  Here, see if this node matches such a set.  As a concrete\n             * example consider [01], and the byte representing '0' which is\n             * 0x30 on ASCII machines.  It has the bits 0011 0000.  Take the\n             * mask 1111 1110.  If we AND 0x31 and 0x30 with that mask we get\n             * 0x30.  Any other bytes ANDed yield something else.  So [01],\n             * which is a common usage, is optimizable into ANYOFM, and can\n             * benefit from the speed up.  We can only do this on UTF-8\n             * invariant bytes, because they have the same bit patterns under\n             * UTF-8 as not. */\n            PERL_UINT_FAST8_T inverted = 0;\n#ifdef EBCDIC\n            const PERL_UINT_FAST8_T max_permissible = 0xFF;\n#else\n            const PERL_UINT_FAST8_T max_permissible = 0x7F;\n#endif\n            /* If doesn't fit the criteria for ANYOFM, invert and try again.\n             * If that works we will instead later generate an NANYOFM, and\n             * invert back when through */\n            if (invlist_highest(cp_list) > max_permissible) {\n                _invlist_invert(cp_list);\n                inverted = 1;\n            }\n\n            if (invlist_highest(cp_list) <= max_permissible) {\n                UV this_start, this_end;\n                UV lowest_cp = UV_MAX;  /* inited to suppress compiler warn */\n                U8 bits_differing = 0;\n                Size_t full_cp_count = 0;\n                bool first_time = TRUE;\n\n                /* Go through the bytes and find the bit positions that differ\n                 * */\n                invlist_iterinit(cp_list);\n                while (invlist_iternext(cp_list, &this_start, &this_end)) {\n                    unsigned int i = this_start;\n\n                    if (first_time) {\n                        if (! UVCHR_IS_INVARIANT(i)) {\n                            goto done_anyofm;\n                        }\n\n                        first_time = FALSE;\n                        lowest_cp = this_start;\n\n                        /* We have set up the code point to compare with.\n                         * Don't compare it with itself */\n                        i++;\n                    }\n\n                    /* Find the bit positions that differ from the lowest code\n                     * point in the node.  Keep track of all such positions by\n                     * OR'ing */\n                    for (; i <= this_end; i++) {\n                        if (! UVCHR_IS_INVARIANT(i)) {\n                            goto done_anyofm;\n                        }\n\n                        bits_differing  |= i ^ lowest_cp;\n                    }\n\n                    full_cp_count += this_end - this_start + 1;\n                }\n                invlist_iterfinish(cp_list);\n\n                /* At the end of the loop, we count how many bits differ from\n                 * the bits in lowest code point, call the count 'd'.  If the\n                 * set we found contains 2**d elements, it is the closure of\n                 * all code points that differ only in those bit positions.  To\n                 * convince yourself of that, first note that the number in the\n                 * closure must be a power of 2, which we test for.  The only\n                 * way we could have that count and it be some differing set,\n                 * is if we got some code points that don't differ from the\n                 * lowest code point in any position, but do differ from each\n                 * other in some other position.  That means one code point has\n                 * a 1 in that position, and another has a 0.  But that would\n                 * mean that one of them differs from the lowest code point in\n                 * that position, which possibility we've already excluded.  */\n                if (  (inverted || full_cp_count > 1)\n                    && full_cp_count == 1U << PL_bitcount[bits_differing])\n                {\n                    U8 ANYOFM_mask;\n\n                    op = ANYOFM + inverted;;\n\n                    /* We need to make the bits that differ be 0's */\n                    ANYOFM_mask = ~ bits_differing; /* This goes into FLAGS */\n\n                    /* The argument is the lowest code point */\n                    ret = reganode(pRExC_state, op, lowest_cp);\n                    FLAGS(REGNODE_p(ret)) = ANYOFM_mask;\n                }\n            }\n          done_anyofm:\n\n            if (inverted) {\n                _invlist_invert(cp_list);\n            }\n\n            if (op != END) {\n                goto not_anyof;\n            }\n        }\n\n        if (! (anyof_flags & ANYOF_LOCALE_FLAGS)) {\n            PERL_UINT_FAST8_T type;\n            SV * intersection = NULL;\n            SV* d_invlist = NULL;\n\n            /* See if this matches any of the POSIX classes.  The POSIXA and\n             * POSIXD ones are about the same speed as ANYOF ops, but take less\n             * room; the ones that have above-Latin1 code point matches are\n             * somewhat faster than ANYOF.  */\n\n            for (type = POSIXA; type >= POSIXD; type--) {\n                int posix_class;\n\n                if (type == POSIXL) {   /* But not /l posix classes */\n                    continue;\n                }\n\n                for (posix_class = 0;\n                     posix_class <= _HIGHEST_REGCOMP_DOT_H_SYNC;\n                     posix_class++)\n                {\n                    SV** our_code_points = &cp_list;\n                    SV** official_code_points;\n                    int try_inverted;\n\n                    if (type == POSIXA) {\n                        official_code_points = &PL_Posix_ptrs[posix_class];\n                    }\n                    else {\n                        official_code_points = &PL_XPosix_ptrs[posix_class];\n                    }\n\n                    /* Skip non-existent classes of this type.  e.g. \\v only\n                     * has an entry in PL_XPosix_ptrs */\n                    if (! *official_code_points) {\n                        continue;\n                    }\n\n                    /* Try both the regular class, and its inversion */\n                    for (try_inverted = 0; try_inverted < 2; try_inverted++) {\n                        bool this_inverted = invert ^ try_inverted;\n\n                        if (type != POSIXD) {\n\n                            /* This class that isn't /d can't match if we have\n                             * /d dependencies */\n                            if (has_runtime_dependency\n                                                    & HAS_D_RUNTIME_DEPENDENCY)\n                            {\n                                continue;\n                            }\n                        }\n                        else /* is /d */ if (! this_inverted) {\n\n                            /* /d classes don't match anything non-ASCII below\n                             * 256 unconditionally (which cp_list contains) */\n                            _invlist_intersection(cp_list, PL_UpperLatin1,\n                                                           &intersection);\n                            if (_invlist_len(intersection) != 0) {\n                                continue;\n                            }\n\n                            SvREFCNT_dec(d_invlist);\n                            d_invlist = invlist_clone(cp_list, NULL);\n\n                            /* But under UTF-8 it turns into using /u rules.\n                             * Add the things it matches under these conditions\n                             * so that we check below that these are identical\n                             * to what the tested class should match */\n                            if (upper_latin1_only_utf8_matches) {\n                                _invlist_union(\n                                            d_invlist,\n                                            upper_latin1_only_utf8_matches,\n                                            &d_invlist);\n                            }\n                            our_code_points = &d_invlist;\n                        }\n                        else {  /* POSIXD, inverted.  If this doesn't have this\n                                   flag set, it isn't /d. */\n                            if (! (anyof_flags & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER))\n                            {\n                                continue;\n                            }\n                            our_code_points = &cp_list;\n                        }\n\n                        /* Here, have weeded out some things.  We want to see\n                         * if the list of characters this node contains\n                         * ('*our_code_points') precisely matches those of the\n                         * class we are currently checking against\n                         * ('*official_code_points'). */\n                        if (_invlistEQ(*our_code_points,\n                                       *official_code_points,\n                                       try_inverted))\n                        {\n                            /* Here, they precisely match.  Optimize this ANYOF\n                             * node into its equivalent POSIX one of the\n                             * correct type, possibly inverted */\n                            ret = reg_node(pRExC_state, (try_inverted)\n                                                        ? type + NPOSIXA\n                                                                - POSIXA\n                                                        : type);\n                            FLAGS(REGNODE_p(ret)) = posix_class;\n                            SvREFCNT_dec(d_invlist);\n                            SvREFCNT_dec(intersection);\n                            goto not_anyof;\n                        }\n                    }\n                }\n            }\n            SvREFCNT_dec(d_invlist);\n            SvREFCNT_dec(intersection);\n        }\n\n        /* If didn't find an optimization and there is no need for a\n        * bitmap, optimize to indicate that */\n        if (     start[0] >= NUM_ANYOF_CODE_POINTS\n            && ! LOC\n            && ! upper_latin1_only_utf8_matches\n            &&   anyof_flags == 0)\n        {\n            UV highest_cp = invlist_highest(cp_list);\n\n            /* If the lowest and highest code point in the class have the same\n             * UTF-8 first byte, then all do, and we can store that byte for\n             * regexec.c to use so that it can more quickly scan the target\n             * string for potential matches for this class.  We co-opt the the\n             * flags field for this.  Zero means, they don't have the same\n             * first byte.  We do accept here very large code points (for\n             * future use), but don't bother with this optimization for them,\n             * as it would cause other complications */\n            if (highest_cp > IV_MAX) {\n                anyof_flags = 0;\n            }\n            else {\n                U8 low_utf8[UTF8_MAXBYTES+1];\n                U8 high_utf8[UTF8_MAXBYTES+1];\n\n                (void) uvchr_to_utf8(low_utf8, start[0]);\n                (void) uvchr_to_utf8(high_utf8, invlist_highest(cp_list));\n\n                anyof_flags = (low_utf8[0] == high_utf8[0])\n                            ? low_utf8[0]\n                            : 0;\n            }\n\n            op = ANYOFH;\n        }\n    }   /* End of seeing if can optimize it into a different node */\n\n  is_anyof: /* It's going to be an ANYOF node. */\n    if (op != ANYOFH) {\n        op = (has_runtime_dependency & HAS_D_RUNTIME_DEPENDENCY)\n             ? ANYOFD\n             : ((posixl)\n                ? ANYOFPOSIXL\n                : ((LOC)\n                   ? ANYOFL\n                   : ANYOF));\n    }\n\n    ret = regnode_guts(pRExC_state, op, regarglen[op], \"anyof\");\n    FILL_NODE(ret, op);        /* We set the argument later */\n    RExC_emit += 1 + regarglen[op];\n    ANYOF_FLAGS(REGNODE_p(ret)) = anyof_flags;\n\n    /* Here, <cp_list> contains all the code points we can determine at\n     * compile time that match under all conditions.  Go through it, and\n     * for things that belong in the bitmap, put them there, and delete from\n     * <cp_list>.  While we are at it, see if everything above 255 is in the\n     * list, and if so, set a flag to speed up execution */\n\n    populate_ANYOF_from_invlist(REGNODE_p(ret), &cp_list);\n\n    if (posixl) {\n        ANYOF_POSIXL_SET_TO_BITMAP(REGNODE_p(ret), posixl);\n    }\n\n    if (invert) {\n        ANYOF_FLAGS(REGNODE_p(ret)) |= ANYOF_INVERT;\n    }\n\n    /* Here, the bitmap has been populated with all the Latin1 code points that\n     * always match.  Can now add to the overall list those that match only\n     * when the target string is UTF-8 (<upper_latin1_only_utf8_matches>).\n     * */\n    if (upper_latin1_only_utf8_matches) {\n\tif (cp_list) {\n\t    _invlist_union(cp_list,\n                           upper_latin1_only_utf8_matches,\n                           &cp_list);\n\t    SvREFCNT_dec_NN(upper_latin1_only_utf8_matches);\n\t}\n\telse {\n\t    cp_list = upper_latin1_only_utf8_matches;\n\t}\n        ANYOF_FLAGS(REGNODE_p(ret)) |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;\n    }\n\n    set_ANYOF_arg(pRExC_state, REGNODE_p(ret), cp_list,\n                  (HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)\n                   ? listsv : NULL,\n                  only_utf8_locale_list);\n    return ret;\n\n  not_anyof:\n\n    /* Here, the node is getting optimized into something that's not an ANYOF\n     * one.  Finish up. */\n\n    Set_Node_Offset_Length(REGNODE_p(ret), orig_parse - RExC_start,\n                                           RExC_parse - orig_parse);;\n    SvREFCNT_dec(cp_list);;\n    return ret;\n}\n\n#undef HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION\n\nSTATIC void\nS_set_ANYOF_arg(pTHX_ RExC_state_t* const pRExC_state,\n                regnode* const node,\n                SV* const cp_list,\n                SV* const runtime_defns,\n                SV* const only_utf8_locale_list)\n{\n    /* Sets the arg field of an ANYOF-type node 'node', using information about\n     * the node passed-in.  If there is nothing outside the node's bitmap, the\n     * arg is set to ANYOF_ONLY_HAS_BITMAP.  Otherwise, it sets the argument to\n     * the count returned by add_data(), having allocated and stored an array,\n     * av, as follows:\n     *\n     *  av[0] stores the inversion list defining this class as far as known at\n     *        this time, or PL_sv_undef if nothing definite is now known.\n     *  av[1] stores the inversion list of code points that match only if the\n     *        current locale is UTF-8, or if none, PL_sv_undef if there is an\n     *        av[2], or no entry otherwise.\n     *  av[2] stores the list of user-defined properties whose subroutine\n     *        definitions aren't known at this time, or no entry if none. */\n\n    UV n;\n\n    PERL_ARGS_ASSERT_SET_ANYOF_ARG;\n\n    if (! cp_list && ! runtime_defns && ! only_utf8_locale_list) {\n        assert(! (ANYOF_FLAGS(node)\n                & ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP));\n\tARG_SET(node, ANYOF_ONLY_HAS_BITMAP);\n    }\n    else {\n\tAV * const av = newAV();\n\tSV *rv;\n\n        if (cp_list) {\n            av_store(av, INVLIST_INDEX, cp_list);\n        }\n\n        if (only_utf8_locale_list) {\n            av_store(av, ONLY_LOCALE_MATCHES_INDEX, only_utf8_locale_list);\n        }\n\n        if (runtime_defns) {\n            av_store(av, DEFERRED_USER_DEFINED_INDEX, SvREFCNT_inc(runtime_defns));\n        }\n\n\trv = newRV_noinc(MUTABLE_SV(av));\n\tn = add_data(pRExC_state, STR_WITH_LEN(\"s\"));\n\tRExC_rxi->data->data[n] = (void*)rv;\n\tARG_SET(node, n);\n    }\n}\n\n#if !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION)\nSV *\nPerl__get_regclass_nonbitmap_data(pTHX_ const regexp *prog,\n                                        const regnode* node,\n                                        bool doinit,\n                                        SV** listsvp,\n                                        SV** only_utf8_locale_ptr,\n                                        SV** output_invlist)\n\n{\n    /* For internal core use only.\n     * Returns the inversion list for the input 'node' in the regex 'prog'.\n     * If <doinit> is 'true', will attempt to create the inversion list if not\n     *    already done.\n     * If <listsvp> is non-null, will return the printable contents of the\n     *    property definition.  This can be used to get debugging information\n     *    even before the inversion list exists, by calling this function with\n     *    'doinit' set to false, in which case the components that will be used\n     *    to eventually create the inversion list are returned  (in a printable\n     *    form).\n     * If <only_utf8_locale_ptr> is not NULL, it is where this routine is to\n     *    store an inversion list of code points that should match only if the\n     *    execution-time locale is a UTF-8 one.\n     * If <output_invlist> is not NULL, it is where this routine is to store an\n     *    inversion list of the code points that would be instead returned in\n     *    <listsvp> if this were NULL.  Thus, what gets output in <listsvp>\n     *    when this parameter is used, is just the non-code point data that\n     *    will go into creating the inversion list.  This currently should be just\n     *    user-defined properties whose definitions were not known at compile\n     *    time.  Using this parameter allows for easier manipulation of the\n     *    inversion list's data by the caller.  It is illegal to call this\n     *    function with this parameter set, but not <listsvp>\n     *\n     * Tied intimately to how S_set_ANYOF_arg sets up the data structure.  Note\n     * that, in spite of this function's name, the inversion list it returns\n     * may include the bitmap data as well */\n\n    SV *si  = NULL;         /* Input initialization string */\n    SV* invlist = NULL;\n\n    RXi_GET_DECL(prog, progi);\n    const struct reg_data * const data = prog ? progi->data : NULL;\n\n    PERL_ARGS_ASSERT__GET_REGCLASS_NONBITMAP_DATA;\n    assert(! output_invlist || listsvp);\n\n    if (data && data->count) {\n\tconst U32 n = ARG(node);\n\n\tif (data->what[n] == 's') {\n\t    SV * const rv = MUTABLE_SV(data->data[n]);\n\t    AV * const av = MUTABLE_AV(SvRV(rv));\n\t    SV **const ary = AvARRAY(av);\n\n            invlist = ary[INVLIST_INDEX];\n\n            if (av_tindex_skip_len_mg(av) >= ONLY_LOCALE_MATCHES_INDEX) {\n                *only_utf8_locale_ptr = ary[ONLY_LOCALE_MATCHES_INDEX];\n            }\n\n            if (av_tindex_skip_len_mg(av) >= DEFERRED_USER_DEFINED_INDEX) {\n                si = ary[DEFERRED_USER_DEFINED_INDEX];\n            }\n\n\t    if (doinit && (si || invlist)) {\n                if (si) {\n                    bool user_defined;\n                    SV * msg = newSVpvs_flags(\"\", SVs_TEMP);\n\n                    SV * prop_definition = handle_user_defined_property(\n                            \"\", 0, FALSE,   /* There is no \\p{}, \\P{} */\n                            SvPVX_const(si)[1] - '0',   /* /i or not has been\n                                                           stored here for just\n                                                           this occasion */\n                            TRUE,           /* run time */\n                            FALSE,          /* This call must find the defn */\n                            si,             /* The property definition  */\n                            &user_defined,\n                            msg,\n                            0               /* base level call */\n                           );\n\n                    if (SvCUR(msg)) {\n                        assert(prop_definition == NULL);\n\n                        Perl_croak(aTHX_ \"%\" UTF8f,\n                                UTF8fARG(SvUTF8(msg), SvCUR(msg), SvPVX(msg)));\n                    }\n\n                    if (invlist) {\n                        _invlist_union(invlist, prop_definition, &invlist);\n                        SvREFCNT_dec_NN(prop_definition);\n                    }\n                    else {\n                        invlist = prop_definition;\n                    }\n\n                    STATIC_ASSERT_STMT(ONLY_LOCALE_MATCHES_INDEX == 1 + INVLIST_INDEX);\n                    STATIC_ASSERT_STMT(DEFERRED_USER_DEFINED_INDEX == 1 + ONLY_LOCALE_MATCHES_INDEX);\n\n                    av_store(av, INVLIST_INDEX, invlist);\n                    av_fill(av, (ary[ONLY_LOCALE_MATCHES_INDEX])\n                                 ? ONLY_LOCALE_MATCHES_INDEX:\n                                 INVLIST_INDEX);\n                    si = NULL;\n                }\n\t    }\n\t}\n    }\n\n    /* If requested, return a printable version of what this ANYOF node matches\n     * */\n    if (listsvp) {\n\tSV* matches_string = NULL;\n\n        /* This function can be called at compile-time, before everything gets\n         * resolved, in which case we return the currently best available\n         * information, which is the string that will eventually be used to do\n         * that resolving, 'si' */\n\tif (si) {\n            /* Here, we only have 'si' (and possibly some passed-in data in\n             * 'invlist', which is handled below)  If the caller only wants\n             * 'si', use that.  */\n            if (! output_invlist) {\n                matches_string = newSVsv(si);\n            }\n            else {\n                /* But if the caller wants an inversion list of the node, we\n                 * need to parse 'si' and place as much as possible in the\n                 * desired output inversion list, making 'matches_string' only\n                 * contain the currently unresolvable things */\n                const char *si_string = SvPVX(si);\n                STRLEN remaining = SvCUR(si);\n                UV prev_cp = 0;\n                U8 count = 0;\n\n                /* Ignore everything before the first new-line */\n                while (*si_string != '\\n' && remaining > 0) {\n                    si_string++;\n                    remaining--;\n                }\n                assert(remaining > 0);\n\n                si_string++;\n                remaining--;\n\n                while (remaining > 0) {\n\n                    /* The data consists of just strings defining user-defined\n                     * property names, but in prior incarnations, and perhaps\n                     * somehow from pluggable regex engines, it could still\n                     * hold hex code point definitions.  Each component of a\n                     * range would be separated by a tab, and each range by a\n                     * new-line.  If these are found, instead add them to the\n                     * inversion list */\n                    I32 grok_flags =  PERL_SCAN_SILENT_ILLDIGIT\n                                     |PERL_SCAN_SILENT_NON_PORTABLE;\n                    STRLEN len = remaining;\n                    UV cp = grok_hex(si_string, &len, &grok_flags, NULL);\n\n                    /* If the hex decode routine found something, it should go\n                     * up to the next \\n */\n                    if (   *(si_string + len) == '\\n') {\n                        if (count) {    /* 2nd code point on line */\n                            *output_invlist = _add_range_to_invlist(*output_invlist, prev_cp, cp);\n                        }\n                        else {\n                            *output_invlist = add_cp_to_invlist(*output_invlist, cp);\n                        }\n                        count = 0;\n                        goto prepare_for_next_iteration;\n                    }\n\n                    /* If the hex decode was instead for the lower range limit,\n                     * save it, and go parse the upper range limit */\n                    if (*(si_string + len) == '\\t') {\n                        assert(count == 0);\n\n                        prev_cp = cp;\n                        count = 1;\n                      prepare_for_next_iteration:\n                        si_string += len + 1;\n                        remaining -= len + 1;\n                        continue;\n                    }\n\n                    /* Here, didn't find a legal hex number.  Just add it from\n                     * here to the next \\n */\n\n                    remaining -= len;\n                    while (*(si_string + len) != '\\n' && remaining > 0) {\n                        remaining--;\n                        len++;\n                    }\n                    if (*(si_string + len) == '\\n') {\n                        len++;\n                        remaining--;\n                    }\n                    if (matches_string) {\n                        sv_catpvn(matches_string, si_string, len - 1);\n                    }\n                    else {\n                        matches_string = newSVpvn(si_string, len - 1);\n                    }\n                    si_string += len;\n                    sv_catpvs(matches_string, \" \");\n                } /* end of loop through the text */\n\n                assert(matches_string);\n                if (SvCUR(matches_string)) {  /* Get rid of trailing blank */\n                    SvCUR_set(matches_string, SvCUR(matches_string) - 1);\n                }\n            } /* end of has an 'si' */\n\t}\n\n        /* Add the stuff that's already known */\n        if (invlist) {\n\n            /* Again, if the caller doesn't want the output inversion list, put\n             * everything in 'matches-string' */\n            if (! output_invlist) {\n                if ( ! matches_string) {\n                    matches_string = newSVpvs(\"\\n\");\n                }\n                sv_catsv(matches_string, invlist_contents(invlist,\n                                                  TRUE /* traditional style */\n                                                  ));\n            }\n            else if (! *output_invlist) {\n                *output_invlist = invlist_clone(invlist, NULL);\n            }\n            else {\n                _invlist_union(*output_invlist, invlist, output_invlist);\n            }\n        }\n\n\t*listsvp = matches_string;\n    }\n\n    return invlist;\n}\n#endif /* !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION) */\n\n/* reg_skipcomment()\n\n   Absorbs an /x style # comment from the input stream,\n   returning a pointer to the first character beyond the comment, or if the\n   comment terminates the pattern without anything following it, this returns\n   one past the final character of the pattern (in other words, RExC_end) and\n   sets the REG_RUN_ON_COMMENT_SEEN flag.\n\n   Note it's the callers responsibility to ensure that we are\n   actually in /x mode\n\n*/\n\nPERL_STATIC_INLINE char*\nS_reg_skipcomment(RExC_state_t *pRExC_state, char* p)\n{\n    PERL_ARGS_ASSERT_REG_SKIPCOMMENT;\n\n    assert(*p == '#');\n\n    while (p < RExC_end) {\n        if (*(++p) == '\\n') {\n            return p+1;\n        }\n    }\n\n    /* we ran off the end of the pattern without ending the comment, so we have\n     * to add an \\n when wrapping */\n    RExC_seen |= REG_RUN_ON_COMMENT_SEEN;\n    return p;\n}\n\nSTATIC void\nS_skip_to_be_ignored_text(pTHX_ RExC_state_t *pRExC_state,\n                                char ** p,\n                                const bool force_to_xmod\n                         )\n{\n    /* If the text at the current parse position '*p' is a '(?#...)' comment,\n     * or if we are under /x or 'force_to_xmod' is TRUE, and the text at '*p'\n     * is /x whitespace, advance '*p' so that on exit it points to the first\n     * byte past all such white space and comments */\n\n    const bool use_xmod = force_to_xmod || (RExC_flags & RXf_PMf_EXTENDED);\n\n    PERL_ARGS_ASSERT_SKIP_TO_BE_IGNORED_TEXT;\n\n    assert( ! UTF || UTF8_IS_INVARIANT(**p) || UTF8_IS_START(**p));\n\n    for (;;) {\n\tif (RExC_end - (*p) >= 3\n\t    && *(*p)     == '('\n\t    && *(*p + 1) == '?'\n\t    && *(*p + 2) == '#')\n\t{\n\t    while (*(*p) != ')') {\n\t\tif ((*p) == RExC_end)\n\t\t    FAIL(\"Sequence (?#... not terminated\");\n\t\t(*p)++;\n\t    }\n\t    (*p)++;\n\t    continue;\n\t}\n\n\tif (use_xmod) {\n            const char * save_p = *p;\n            while ((*p) < RExC_end) {\n                STRLEN len;\n                if ((len = is_PATWS_safe((*p), RExC_end, UTF))) {\n                    (*p) += len;\n                }\n                else if (*(*p) == '#') {\n                    (*p) = reg_skipcomment(pRExC_state, (*p));\n                }\n                else {\n                    break;\n                }\n            }\n            if (*p != save_p) {\n                continue;\n            }\n\t}\n\n        break;\n    }\n\n    return;\n}\n\n/* nextchar()\n\n   Advances the parse position by one byte, unless that byte is the beginning\n   of a '(?#...)' style comment, or is /x whitespace and /x is in effect.  In\n   those two cases, the parse position is advanced beyond all such comments and\n   white space.\n\n   This is the UTF, (?#...), and /x friendly way of saying RExC_parse++.\n*/\n\nSTATIC void\nS_nextchar(pTHX_ RExC_state_t *pRExC_state)\n{\n    PERL_ARGS_ASSERT_NEXTCHAR;\n\n    if (RExC_parse < RExC_end) {\n        assert(   ! UTF\n               || UTF8_IS_INVARIANT(*RExC_parse)\n               || UTF8_IS_START(*RExC_parse));\n\n        RExC_parse += (UTF)\n                      ? UTF8_SAFE_SKIP(RExC_parse, RExC_end)\n                      : 1;\n\n        skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                FALSE /* Don't force /x */ );\n    }\n}\n\nSTATIC void\nS_change_engine_size(pTHX_ RExC_state_t *pRExC_state, const Ptrdiff_t size)\n{\n    /* 'size' is the delta to add or subtract from the current memory allocated\n     * to the regex engine being constructed */\n\n    PERL_ARGS_ASSERT_CHANGE_ENGINE_SIZE;\n\n    RExC_size += size;\n\n    Renewc(RExC_rxi,\n           sizeof(regexp_internal) + (RExC_size + 1) * sizeof(regnode),\n                                                /* +1 for REG_MAGIC */\n           char,\n           regexp_internal);\n    if ( RExC_rxi == NULL )\n\tFAIL(\"Regexp out of space\");\n    RXi_SET(RExC_rx, RExC_rxi);\n\n    RExC_emit_start = RExC_rxi->program;\n    if (size > 0) {\n        Zero(REGNODE_p(RExC_emit), size, regnode);\n    }\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    Renew(RExC_offsets, 2*RExC_size+1, U32);\n    if (size > 0) {\n        Zero(RExC_offsets + 2*(RExC_size - size) + 1, 2 * size, U32);\n    }\n    RExC_offsets[0] = RExC_size;\n#endif\n}\n\nSTATIC regnode_offset\nS_regnode_guts(pTHX_ RExC_state_t *pRExC_state, const U8 op, const STRLEN extra_size, const char* const name)\n{\n    /* Allocate a regnode for 'op', with 'extra_size' extra space.  It aligns\n     * and increments RExC_size and RExC_emit\n     *\n     * It returns the regnode's offset into the regex engine program */\n\n    const regnode_offset ret = RExC_emit;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGNODE_GUTS;\n\n    SIZE_ALIGN(RExC_size);\n    change_engine_size(pRExC_state, (Ptrdiff_t) 1 + extra_size);\n    NODE_ALIGN_FILL(REGNODE_p(ret));\n#ifndef RE_TRACK_PATTERN_OFFSETS\n    PERL_UNUSED_ARG(name);\n    PERL_UNUSED_ARG(op);\n#else\n    assert(extra_size >= regarglen[op] || PL_regkind[op] == ANYOF);\n\n    if (RExC_offsets) {         /* MJD */\n\tMJD_OFFSET_DEBUG(\n              (\"%s:%d: (op %s) %s %\" UVuf \" (len %\" UVuf \") (max %\" UVuf \").\\n\",\n              name, __LINE__,\n              PL_reg_name[op],\n              (UV)(RExC_emit) > RExC_offsets[0]\n\t\t? \"Overwriting end of array!\\n\" : \"OK\",\n              (UV)(RExC_emit),\n              (UV)(RExC_parse - RExC_start),\n              (UV)RExC_offsets[0]));\n\tSet_Node_Offset(REGNODE_p(RExC_emit), RExC_parse + (op == END));\n    }\n#endif\n    return(ret);\n}\n\n/*\n- reg_node - emit a node\n*/\nSTATIC regnode_offset /* Location. */\nS_reg_node(pTHX_ RExC_state_t *pRExC_state, U8 op)\n{\n    const regnode_offset ret = regnode_guts(pRExC_state, op, regarglen[op], \"reg_node\");\n    regnode_offset ptr = ret;\n\n    PERL_ARGS_ASSERT_REG_NODE;\n\n    assert(regarglen[op] == 0);\n\n    FILL_ADVANCE_NODE(ptr, op);\n    RExC_emit = ptr;\n    return(ret);\n}\n\n/*\n- reganode - emit a node with an argument\n*/\nSTATIC regnode_offset /* Location. */\nS_reganode(pTHX_ RExC_state_t *pRExC_state, U8 op, U32 arg)\n{\n    const regnode_offset ret = regnode_guts(pRExC_state, op, regarglen[op], \"reganode\");\n    regnode_offset ptr = ret;\n\n    PERL_ARGS_ASSERT_REGANODE;\n\n    /* ANYOF are special cased to allow non-length 1 args */\n    assert(regarglen[op] == 1);\n\n    FILL_ADVANCE_NODE_ARG(ptr, op, arg);\n    RExC_emit = ptr;\n    return(ret);\n}\n\nSTATIC regnode_offset\nS_reg2Lanode(pTHX_ RExC_state_t *pRExC_state, const U8 op, const U32 arg1, const I32 arg2)\n{\n    /* emit a node with U32 and I32 arguments */\n\n    const regnode_offset ret = regnode_guts(pRExC_state, op, regarglen[op], \"reg2Lanode\");\n    regnode_offset ptr = ret;\n\n    PERL_ARGS_ASSERT_REG2LANODE;\n\n    assert(regarglen[op] == 2);\n\n    FILL_ADVANCE_NODE_2L_ARG(ptr, op, arg1, arg2);\n    RExC_emit = ptr;\n    return(ret);\n}\n\n/*\n- reginsert - insert an operator in front of already-emitted operand\n*\n* That means that on exit 'operand' is the offset of the newly inserted\n* operator, and the original operand has been relocated.\n*\n* IMPORTANT NOTE - it is the *callers* responsibility to correctly\n* set up NEXT_OFF() of the inserted node if needed. Something like this:\n*\n*   reginsert(pRExC, OPFAIL, orig_emit, depth+1);\n*   NEXT_OFF(orig_emit) = regarglen[OPFAIL] + NODE_STEP_REGNODE;\n*\n* ALSO NOTE - FLAGS(newly-inserted-operator) will be set to 0 as well.\n*/\nSTATIC void\nS_reginsert(pTHX_ RExC_state_t *pRExC_state, const U8 op,\n                  const regnode_offset operand, const U32 depth)\n{\n    regnode *src;\n    regnode *dst;\n    regnode *place;\n    const int offset = regarglen[(U8)op];\n    const int size = NODE_STEP_REGNODE + offset;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGINSERT;\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(depth);\n/* (PL_regkind[(U8)op] == CURLY ? EXTRA_STEP_2ARGS : 0); */\n    DEBUG_PARSE_FMT(\"inst\",\" - %s\", PL_reg_name[op]);\n    assert(!RExC_study_started); /* I believe we should never use reginsert once we have started\n                                    studying. If this is wrong then we need to adjust RExC_recurse\n                                    below like we do with RExC_open_parens/RExC_close_parens. */\n    change_engine_size(pRExC_state, (Ptrdiff_t) size);\n    src = REGNODE_p(RExC_emit);\n    RExC_emit += size;\n    dst = REGNODE_p(RExC_emit);\n\n    /* If we are in a \"count the parentheses\" pass, the numbers are unreliable,\n     * and [perl #133871] shows this can lead to problems, so skip this\n     * realignment of parens until a later pass when they are reliable */\n    if (! IN_PARENS_PASS && RExC_open_parens) {\n        int paren;\n        /*DEBUG_PARSE_FMT(\"inst\",\" - %\" IVdf, (IV)RExC_npar);*/\n        /* remember that RExC_npar is rex->nparens + 1,\n         * iow it is 1 more than the number of parens seen in\n         * the pattern so far. */\n        for ( paren=0 ; paren < RExC_npar ; paren++ ) {\n            /* note, RExC_open_parens[0] is the start of the\n             * regex, it can't move. RExC_close_parens[0] is the end\n             * of the regex, it *can* move. */\n            if ( paren && RExC_open_parens[paren] >= operand ) {\n                /*DEBUG_PARSE_FMT(\"open\",\" - %d\", size);*/\n                RExC_open_parens[paren] += size;\n            } else {\n                /*DEBUG_PARSE_FMT(\"open\",\" - %s\",\"ok\");*/\n            }\n            if ( RExC_close_parens[paren] >= operand ) {\n                /*DEBUG_PARSE_FMT(\"close\",\" - %d\", size);*/\n                RExC_close_parens[paren] += size;\n            } else {\n                /*DEBUG_PARSE_FMT(\"close\",\" - %s\",\"ok\");*/\n            }\n        }\n    }\n    if (RExC_end_op)\n        RExC_end_op += size;\n\n    while (src > REGNODE_p(operand)) {\n\tStructCopy(--src, --dst, regnode);\n#ifdef RE_TRACK_PATTERN_OFFSETS\n        if (RExC_offsets) {     /* MJD 20010112 */\n\t    MJD_OFFSET_DEBUG(\n                 (\"%s(%d): (op %s) %s copy %\" UVuf \" -> %\" UVuf \" (max %\" UVuf \").\\n\",\n                  \"reginsert\",\n\t\t  __LINE__,\n\t\t  PL_reg_name[op],\n                  (UV)(REGNODE_OFFSET(dst)) > RExC_offsets[0]\n\t\t    ? \"Overwriting end of array!\\n\" : \"OK\",\n                  (UV)REGNODE_OFFSET(src),\n                  (UV)REGNODE_OFFSET(dst),\n                  (UV)RExC_offsets[0]));\n\t    Set_Node_Offset_To_R(REGNODE_OFFSET(dst), Node_Offset(src));\n\t    Set_Node_Length_To_R(REGNODE_OFFSET(dst), Node_Length(src));\n        }\n#endif\n    }\n\n    place = REGNODE_p(operand);\t/* Op node, where operand used to be. */\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    if (RExC_offsets) {         /* MJD */\n\tMJD_OFFSET_DEBUG(\n              (\"%s(%d): (op %s) %s %\" UVuf \" <- %\" UVuf \" (max %\" UVuf \").\\n\",\n              \"reginsert\",\n\t      __LINE__,\n\t      PL_reg_name[op],\n              (UV)REGNODE_OFFSET(place) > RExC_offsets[0]\n              ? \"Overwriting end of array!\\n\" : \"OK\",\n              (UV)REGNODE_OFFSET(place),\n              (UV)(RExC_parse - RExC_start),\n              (UV)RExC_offsets[0]));\n\tSet_Node_Offset(place, RExC_parse);\n\tSet_Node_Length(place, 1);\n    }\n#endif\n    src = NEXTOPER(place);\n    FLAGS(place) = 0;\n    FILL_NODE(operand, op);\n\n    /* Zero out any arguments in the new node */\n    Zero(src, offset, regnode);\n}\n\n/*\n- regtail - set the next-pointer at the end of a node chain of p to val.  If\n            that value won't fit in the space available, instead returns FALSE.\n            (Except asserts if we can't fit in the largest space the regex\n            engine is designed for.)\n- SEE ALSO: regtail_study\n*/\nSTATIC bool\nS_regtail(pTHX_ RExC_state_t * pRExC_state,\n                const regnode_offset p,\n                const regnode_offset val,\n                const U32 depth)\n{\n    regnode_offset scan;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGTAIL;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    /* Find last node. */\n    scan = (regnode_offset) p;\n    for (;;) {\n\tregnode * const temp = regnext(REGNODE_p(scan));\n        DEBUG_PARSE_r({\n            DEBUG_PARSE_MSG((scan==p ? \"tail\" : \"\"));\n            regprop(RExC_rx, RExC_mysv, REGNODE_p(scan), NULL, pRExC_state);\n            Perl_re_printf( aTHX_  \"~ %s (%d) %s %s\\n\",\n                SvPV_nolen_const(RExC_mysv), scan,\n                    (temp == NULL ? \"->\" : \"\"),\n                    (temp == NULL ? PL_reg_name[OP(REGNODE_p(val))] : \"\")\n            );\n        });\n        if (temp == NULL)\n            break;\n        scan = REGNODE_OFFSET(temp);\n    }\n\n    if (reg_off_by_arg[OP(REGNODE_p(scan))]) {\n        assert((UV) (val - scan) <= U32_MAX);\n        ARG_SET(REGNODE_p(scan), val - scan);\n    }\n    else {\n        if (val - scan > U16_MAX) {\n            /* Populate this with something that won't loop and will likely\n             * lead to a crash if the caller ignores the failure return, and\n             * execution continues */\n            NEXT_OFF(REGNODE_p(scan)) = U16_MAX;\n            return FALSE;\n        }\n        NEXT_OFF(REGNODE_p(scan)) = val - scan;\n    }\n\n    return TRUE;\n}\n\n#ifdef DEBUGGING\n/*\n- regtail_study - set the next-pointer at the end of a node chain of p to val.\n- Look for optimizable sequences at the same time.\n- currently only looks for EXACT chains.\n\nThis is experimental code. The idea is to use this routine to perform\nin place optimizations on branches and groups as they are constructed,\nwith the long term intention of removing optimization from study_chunk so\nthat it is purely analytical.\n\nCurrently only used when in DEBUG mode. The macro REGTAIL_STUDY() is used\nto control which is which.\n\nThis used to return a value that was ignored.  It was a problem that it is\n#ifdef'd to be another function that didn't return a value.  khw has changed it\nso both currently return a pass/fail return.\n\n*/\n/* TODO: All four parms should be const */\n\nSTATIC bool\nS_regtail_study(pTHX_ RExC_state_t *pRExC_state, regnode_offset p,\n                      const regnode_offset val, U32 depth)\n{\n    regnode_offset scan;\n    U8 exact = PSEUDO;\n#ifdef EXPERIMENTAL_INPLACESCAN\n    I32 min = 0;\n#endif\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGTAIL_STUDY;\n\n\n    /* Find last node. */\n\n    scan = p;\n    for (;;) {\n        regnode * const temp = regnext(REGNODE_p(scan));\n#ifdef EXPERIMENTAL_INPLACESCAN\n        if (PL_regkind[OP(REGNODE_p(scan))] == EXACT) {\n\t    bool unfolded_multi_char;\t/* Unexamined in this routine */\n            if (join_exact(pRExC_state, scan, &min,\n                           &unfolded_multi_char, 1, REGNODE_p(val), depth+1))\n                return TRUE; /* Was return EXACT */\n\t}\n#endif\n        if ( exact ) {\n            switch (OP(REGNODE_p(scan))) {\n                case EXACT:\n                case EXACT_ONLY8:\n                case EXACTL:\n                case EXACTF:\n                case EXACTFU_S_EDGE:\n                case EXACTFAA_NO_TRIE:\n                case EXACTFAA:\n                case EXACTFU:\n                case EXACTFU_ONLY8:\n                case EXACTFLU8:\n                case EXACTFUP:\n                case EXACTFL:\n                        if( exact == PSEUDO )\n                            exact= OP(REGNODE_p(scan));\n                        else if ( exact != OP(REGNODE_p(scan)) )\n                            exact= 0;\n                case NOTHING:\n                    break;\n                default:\n                    exact= 0;\n            }\n        }\n        DEBUG_PARSE_r({\n            DEBUG_PARSE_MSG((scan==p ? \"tsdy\" : \"\"));\n            regprop(RExC_rx, RExC_mysv, REGNODE_p(scan), NULL, pRExC_state);\n            Perl_re_printf( aTHX_  \"~ %s (%d) -> %s\\n\",\n                SvPV_nolen_const(RExC_mysv),\n                scan,\n                PL_reg_name[exact]);\n        });\n\tif (temp == NULL)\n\t    break;\n\tscan = REGNODE_OFFSET(temp);\n    }\n    DEBUG_PARSE_r({\n        DEBUG_PARSE_MSG(\"\");\n        regprop(RExC_rx, RExC_mysv, REGNODE_p(val), NULL, pRExC_state);\n        Perl_re_printf( aTHX_\n                      \"~ attach to %s (%\" IVdf \") offset to %\" IVdf \"\\n\",\n\t\t      SvPV_nolen_const(RExC_mysv),\n\t\t      (IV)val,\n\t\t      (IV)(val - scan)\n        );\n    });\n    if (reg_off_by_arg[OP(REGNODE_p(scan))]) {\n        assert((UV) (val - scan) <= U32_MAX);\n\tARG_SET(REGNODE_p(scan), val - scan);\n    }\n    else {\n        if (val - scan > U16_MAX) {\n            /* Populate this with something that won't loop and will likely\n             * lead to a crash if the caller ignores the failure return, and\n             * execution continues */\n            NEXT_OFF(REGNODE_p(scan)) = U16_MAX;\n            return FALSE;\n        }\n\tNEXT_OFF(REGNODE_p(scan)) = val - scan;\n    }\n\n    return TRUE; /* Was 'return exact' */\n}\n#endif\n\nSTATIC SV*\nS_get_ANYOFM_contents(pTHX_ const regnode * n) {\n\n    /* Returns an inversion list of all the code points matched by the\n     * ANYOFM/NANYOFM node 'n' */\n\n    SV * cp_list = _new_invlist(-1);\n    const U8 lowest = (U8) ARG(n);\n    unsigned int i;\n    U8 count = 0;\n    U8 needed = 1U << PL_bitcount[ (U8) ~ FLAGS(n)];\n\n    PERL_ARGS_ASSERT_GET_ANYOFM_CONTENTS;\n\n    /* Starting with the lowest code point, any code point that ANDed with the\n     * mask yields the lowest code point is in the set */\n    for (i = lowest; i <= 0xFF; i++) {\n        if ((i & FLAGS(n)) == ARG(n)) {\n            cp_list = add_cp_to_invlist(cp_list, i);\n            count++;\n\n            /* We know how many code points (a power of two) that are in the\n             * set.  No use looking once we've got that number */\n            if (count >= needed) break;\n        }\n    }\n\n    if (OP(n) == NANYOFM) {\n        _invlist_invert(cp_list);\n    }\n    return cp_list;\n}\n\n/*\n - regdump - dump a regexp onto Perl_debug_log in vaguely comprehensible form\n */\n#ifdef DEBUGGING\n\nstatic void\nS_regdump_intflags(pTHX_ const char *lead, const U32 flags)\n{\n    int bit;\n    int set=0;\n\n    ASSUME(REG_INTFLAGS_NAME_SIZE <= sizeof(flags)*8);\n\n    for (bit=0; bit<REG_INTFLAGS_NAME_SIZE; bit++) {\n        if (flags & (1<<bit)) {\n            if (!set++ && lead)\n                Perl_re_printf( aTHX_  \"%s\", lead);\n            Perl_re_printf( aTHX_  \"%s \", PL_reg_intflags_name[bit]);\n        }\n    }\n    if (lead)  {\n        if (set)\n            Perl_re_printf( aTHX_  \"\\n\");\n        else\n            Perl_re_printf( aTHX_  \"%s[none-set]\\n\", lead);\n    }\n}\n\nstatic void\nS_regdump_extflags(pTHX_ const char *lead, const U32 flags)\n{\n    int bit;\n    int set=0;\n    regex_charset cs;\n\n    ASSUME(REG_EXTFLAGS_NAME_SIZE <= sizeof(flags)*8);\n\n    for (bit=0; bit<REG_EXTFLAGS_NAME_SIZE; bit++) {\n        if (flags & (1<<bit)) {\n\t    if ((1<<bit) & RXf_PMf_CHARSET) {\t/* Output separately, below */\n\t\tcontinue;\n\t    }\n            if (!set++ && lead)\n                Perl_re_printf( aTHX_  \"%s\", lead);\n            Perl_re_printf( aTHX_  \"%s \", PL_reg_extflags_name[bit]);\n        }\n    }\n    if ((cs = get_regex_charset(flags)) != REGEX_DEPENDS_CHARSET) {\n            if (!set++ && lead) {\n                Perl_re_printf( aTHX_  \"%s\", lead);\n            }\n            switch (cs) {\n                case REGEX_UNICODE_CHARSET:\n                    Perl_re_printf( aTHX_  \"UNICODE\");\n                    break;\n                case REGEX_LOCALE_CHARSET:\n                    Perl_re_printf( aTHX_  \"LOCALE\");\n                    break;\n                case REGEX_ASCII_RESTRICTED_CHARSET:\n                    Perl_re_printf( aTHX_  \"ASCII-RESTRICTED\");\n                    break;\n                case REGEX_ASCII_MORE_RESTRICTED_CHARSET:\n                    Perl_re_printf( aTHX_  \"ASCII-MORE_RESTRICTED\");\n                    break;\n                default:\n                    Perl_re_printf( aTHX_  \"UNKNOWN CHARACTER SET\");\n                    break;\n            }\n    }\n    if (lead)  {\n        if (set)\n            Perl_re_printf( aTHX_  \"\\n\");\n        else\n            Perl_re_printf( aTHX_  \"%s[none-set]\\n\", lead);\n    }\n}\n#endif\n\nvoid\nPerl_regdump(pTHX_ const regexp *r)\n{\n#ifdef DEBUGGING\n    int i;\n    SV * const sv = sv_newmortal();\n    SV *dsv= sv_newmortal();\n    RXi_GET_DECL(r, ri);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGDUMP;\n\n    (void)dumpuntil(r, ri->program, ri->program + 1, NULL, NULL, sv, 0, 0);\n\n    /* Header fields of interest. */\n    for (i = 0; i < 2; i++) {\n        if (r->substrs->data[i].substr) {\n            RE_PV_QUOTED_DECL(s, 0, dsv,\n                            SvPVX_const(r->substrs->data[i].substr),\n                            RE_SV_DUMPLEN(r->substrs->data[i].substr),\n                            PL_dump_re_max_len);\n            Perl_re_printf( aTHX_\n                          \"%s %s%s at %\" IVdf \"..%\" UVuf \" \",\n                          i ? \"floating\" : \"anchored\",\n                          s,\n                          RE_SV_TAIL(r->substrs->data[i].substr),\n                          (IV)r->substrs->data[i].min_offset,\n                          (UV)r->substrs->data[i].max_offset);\n        }\n        else if (r->substrs->data[i].utf8_substr) {\n            RE_PV_QUOTED_DECL(s, 1, dsv,\n                            SvPVX_const(r->substrs->data[i].utf8_substr),\n                            RE_SV_DUMPLEN(r->substrs->data[i].utf8_substr),\n                            30);\n            Perl_re_printf( aTHX_\n                          \"%s utf8 %s%s at %\" IVdf \"..%\" UVuf \" \",\n                          i ? \"floating\" : \"anchored\",\n                          s,\n                          RE_SV_TAIL(r->substrs->data[i].utf8_substr),\n                          (IV)r->substrs->data[i].min_offset,\n                          (UV)r->substrs->data[i].max_offset);\n        }\n    }\n\n    if (r->check_substr || r->check_utf8)\n        Perl_re_printf( aTHX_\n\t\t      (const char *)\n\t\t      (   r->check_substr == r->substrs->data[1].substr\n\t\t       && r->check_utf8   == r->substrs->data[1].utf8_substr\n\t\t       ? \"(checking floating\" : \"(checking anchored\"));\n    if (r->intflags & PREGf_NOSCAN)\n        Perl_re_printf( aTHX_  \" noscan\");\n    if (r->extflags & RXf_CHECK_ALL)\n        Perl_re_printf( aTHX_  \" isall\");\n    if (r->check_substr || r->check_utf8)\n        Perl_re_printf( aTHX_  \") \");\n\n    if (ri->regstclass) {\n        regprop(r, sv, ri->regstclass, NULL, NULL);\n        Perl_re_printf( aTHX_  \"stclass %s \", SvPVX_const(sv));\n    }\n    if (r->intflags & PREGf_ANCH) {\n        Perl_re_printf( aTHX_  \"anchored\");\n        if (r->intflags & PREGf_ANCH_MBOL)\n            Perl_re_printf( aTHX_  \"(MBOL)\");\n        if (r->intflags & PREGf_ANCH_SBOL)\n            Perl_re_printf( aTHX_  \"(SBOL)\");\n        if (r->intflags & PREGf_ANCH_GPOS)\n            Perl_re_printf( aTHX_  \"(GPOS)\");\n        Perl_re_printf( aTHX_ \" \");\n    }\n    if (r->intflags & PREGf_GPOS_SEEN)\n        Perl_re_printf( aTHX_  \"GPOS:%\" UVuf \" \", (UV)r->gofs);\n    if (r->intflags & PREGf_SKIP)\n        Perl_re_printf( aTHX_  \"plus \");\n    if (r->intflags & PREGf_IMPLICIT)\n        Perl_re_printf( aTHX_  \"implicit \");\n    Perl_re_printf( aTHX_  \"minlen %\" IVdf \" \", (IV)r->minlen);\n    if (r->extflags & RXf_EVAL_SEEN)\n        Perl_re_printf( aTHX_  \"with eval \");\n    Perl_re_printf( aTHX_  \"\\n\");\n    DEBUG_FLAGS_r({\n        regdump_extflags(\"r->extflags: \", r->extflags);\n        regdump_intflags(\"r->intflags: \", r->intflags);\n    });\n#else\n    PERL_ARGS_ASSERT_REGDUMP;\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(r);\n#endif\t/* DEBUGGING */\n}\n\n/* Should be synchronized with ANYOF_ #defines in regcomp.h */\n#ifdef DEBUGGING\n\n#  if   _CC_WORDCHAR != 0 || _CC_DIGIT != 1        || _CC_ALPHA != 2    \\\n     || _CC_LOWER != 3    || _CC_UPPER != 4        || _CC_PUNCT != 5    \\\n     || _CC_PRINT != 6    || _CC_ALPHANUMERIC != 7 || _CC_GRAPH != 8    \\\n     || _CC_CASED != 9    || _CC_SPACE != 10       || _CC_BLANK != 11   \\\n     || _CC_XDIGIT != 12  || _CC_CNTRL != 13       || _CC_ASCII != 14   \\\n     || _CC_VERTSPACE != 15\n#   error Need to adjust order of anyofs[]\n#  endif\nstatic const char * const anyofs[] = {\n    \"\\\\w\",\n    \"\\\\W\",\n    \"\\\\d\",\n    \"\\\\D\",\n    \"[:alpha:]\",\n    \"[:^alpha:]\",\n    \"[:lower:]\",\n    \"[:^lower:]\",\n    \"[:upper:]\",\n    \"[:^upper:]\",\n    \"[:punct:]\",\n    \"[:^punct:]\",\n    \"[:print:]\",\n    \"[:^print:]\",\n    \"[:alnum:]\",\n    \"[:^alnum:]\",\n    \"[:graph:]\",\n    \"[:^graph:]\",\n    \"[:cased:]\",\n    \"[:^cased:]\",\n    \"\\\\s\",\n    \"\\\\S\",\n    \"[:blank:]\",\n    \"[:^blank:]\",\n    \"[:xdigit:]\",\n    \"[:^xdigit:]\",\n    \"[:cntrl:]\",\n    \"[:^cntrl:]\",\n    \"[:ascii:]\",\n    \"[:^ascii:]\",\n    \"\\\\v\",\n    \"\\\\V\"\n};\n#endif\n\n/*\n- regprop - printable representation of opcode, with run time support\n*/\n\nvoid\nPerl_regprop(pTHX_ const regexp *prog, SV *sv, const regnode *o, const regmatch_info *reginfo, const RExC_state_t *pRExC_state)\n{\n#ifdef DEBUGGING\n    dVAR;\n    int k;\n    RXi_GET_DECL(prog, progi);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGPROP;\n\n    SvPVCLEAR(sv);\n\n    if (OP(o) > REGNODE_MAX)\t\t/* regnode.type is unsigned */\n\t/* It would be nice to FAIL() here, but this may be called from\n\t   regexec.c, and it would be hard to supply pRExC_state. */\n\tPerl_croak(aTHX_ \"Corrupted regexp opcode %d > %d\",\n                                              (int)OP(o), (int)REGNODE_MAX);\n    sv_catpv(sv, PL_reg_name[OP(o)]); /* Take off const! */\n\n    k = PL_regkind[OP(o)];\n\n    if (k == EXACT) {\n\tsv_catpvs(sv, \" \");\n\t/* Using is_utf8_string() (via PERL_PV_UNI_DETECT)\n\t * is a crude hack but it may be the best for now since\n\t * we have no flag \"this EXACTish node was UTF-8\"\n\t * --jhi */\n\tpv_pretty(sv, STRING(o), STR_LEN(o), PL_dump_re_max_len,\n                  PL_colors[0], PL_colors[1],\n\t\t  PERL_PV_ESCAPE_UNI_DETECT |\n\t\t  PERL_PV_ESCAPE_NONASCII   |\n\t\t  PERL_PV_PRETTY_ELLIPSES   |\n\t\t  PERL_PV_PRETTY_LTGT       |\n\t\t  PERL_PV_PRETTY_NOCLEAR\n\t\t  );\n    } else if (k == TRIE) {\n\t/* print the details of the trie in dumpuntil instead, as\n\t * progi->data isn't available here */\n        const char op = OP(o);\n        const U32 n = ARG(o);\n        const reg_ac_data * const ac = IS_TRIE_AC(op) ?\n               (reg_ac_data *)progi->data->data[n] :\n               NULL;\n        const reg_trie_data * const trie\n\t    = (reg_trie_data*)progi->data->data[!IS_TRIE_AC(op) ? n : ac->trie];\n\n        Perl_sv_catpvf(aTHX_ sv, \"-%s\", PL_reg_name[o->flags]);\n        DEBUG_TRIE_COMPILE_r({\n          if (trie->jump)\n            sv_catpvs(sv, \"(JUMP)\");\n          Perl_sv_catpvf(aTHX_ sv,\n            \"<S:%\" UVuf \"/%\" IVdf \" W:%\" UVuf \" L:%\" UVuf \"/%\" UVuf \" C:%\" UVuf \"/%\" UVuf \">\",\n            (UV)trie->startstate,\n            (IV)trie->statecount-1, /* -1 because of the unused 0 element */\n            (UV)trie->wordcount,\n            (UV)trie->minlen,\n            (UV)trie->maxlen,\n            (UV)TRIE_CHARCOUNT(trie),\n            (UV)trie->uniquecharcount\n          );\n        });\n        if ( IS_ANYOF_TRIE(op) || trie->bitmap ) {\n            sv_catpvs(sv, \"[\");\n            (void) put_charclass_bitmap_innards(sv,\n                                                ((IS_ANYOF_TRIE(op))\n                                                 ? ANYOF_BITMAP(o)\n                                                 : TRIE_BITMAP(trie)),\n                                                NULL,\n                                                NULL,\n                                                NULL,\n                                                FALSE\n                                               );\n            sv_catpvs(sv, \"]\");\n        }\n    } else if (k == CURLY) {\n        U32 lo = ARG1(o), hi = ARG2(o);\n\tif (OP(o) == CURLYM || OP(o) == CURLYN || OP(o) == CURLYX)\n\t    Perl_sv_catpvf(aTHX_ sv, \"[%d]\", o->flags); /* Parenth number */\n        Perl_sv_catpvf(aTHX_ sv, \"{%u,\", (unsigned) lo);\n        if (hi == REG_INFTY)\n            sv_catpvs(sv, \"INFTY\");\n        else\n            Perl_sv_catpvf(aTHX_ sv, \"%u\", (unsigned) hi);\n        sv_catpvs(sv, \"}\");\n    }\n    else if (k == WHILEM && o->flags)\t\t\t/* Ordinal/of */\n\tPerl_sv_catpvf(aTHX_ sv, \"[%d/%d]\", o->flags & 0xf, o->flags>>4);\n    else if (k == REF || k == OPEN || k == CLOSE\n             || k == GROUPP || OP(o)==ACCEPT)\n    {\n        AV *name_list= NULL;\n        U32 parno= OP(o) == ACCEPT ? (U32)ARG2L(o) : ARG(o);\n        Perl_sv_catpvf(aTHX_ sv, \"%\" UVuf, (UV)parno);        /* Parenth number */\n\tif ( RXp_PAREN_NAMES(prog) ) {\n            name_list= MUTABLE_AV(progi->data->data[progi->name_list_idx]);\n        } else if ( pRExC_state ) {\n            name_list= RExC_paren_name_list;\n        }\n        if (name_list) {\n            if ( k != REF || (OP(o) < NREF)) {\n                SV **name= av_fetch(name_list, parno, 0 );\n\t        if (name)\n\t            Perl_sv_catpvf(aTHX_ sv, \" '%\" SVf \"'\", SVfARG(*name));\n            }\n            else {\n                SV *sv_dat= MUTABLE_SV(progi->data->data[ parno ]);\n                I32 *nums=(I32*)SvPVX(sv_dat);\n                SV **name= av_fetch(name_list, nums[0], 0 );\n                I32 n;\n                if (name) {\n                    for ( n=0; n<SvIVX(sv_dat); n++ ) {\n                        Perl_sv_catpvf(aTHX_ sv, \"%s%\" IVdf,\n\t\t\t   \t    (n ? \",\" : \"\"), (IV)nums[n]);\n                    }\n                    Perl_sv_catpvf(aTHX_ sv, \" '%\" SVf \"'\", SVfARG(*name));\n                }\n            }\n        }\n        if ( k == REF && reginfo) {\n            U32 n = ARG(o);  /* which paren pair */\n            I32 ln = prog->offs[n].start;\n            if (prog->lastparen < n || ln == -1 || prog->offs[n].end == -1)\n                Perl_sv_catpvf(aTHX_ sv, \": FAIL\");\n            else if (ln == prog->offs[n].end)\n                Perl_sv_catpvf(aTHX_ sv, \": ACCEPT - EMPTY STRING\");\n            else {\n                const char *s = reginfo->strbeg + ln;\n                Perl_sv_catpvf(aTHX_ sv, \": \");\n                Perl_pv_pretty( aTHX_ sv, s, prog->offs[n].end - prog->offs[n].start, 32, 0, 0,\n                    PERL_PV_ESCAPE_UNI_DETECT|PERL_PV_PRETTY_NOCLEAR|PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_QUOTE );\n            }\n        }\n    } else if (k == GOSUB) {\n        AV *name_list= NULL;\n        if ( RXp_PAREN_NAMES(prog) ) {\n            name_list= MUTABLE_AV(progi->data->data[progi->name_list_idx]);\n        } else if ( pRExC_state ) {\n            name_list= RExC_paren_name_list;\n        }\n\n        /* Paren and offset */\n        Perl_sv_catpvf(aTHX_ sv, \"%d[%+d:%d]\", (int)ARG(o),(int)ARG2L(o),\n                (int)((o + (int)ARG2L(o)) - progi->program) );\n        if (name_list) {\n            SV **name= av_fetch(name_list, ARG(o), 0 );\n            if (name)\n                Perl_sv_catpvf(aTHX_ sv, \" '%\" SVf \"'\", SVfARG(*name));\n        }\n    }\n    else if (k == LOGICAL)\n        /* 2: embedded, otherwise 1 */\n\tPerl_sv_catpvf(aTHX_ sv, \"[%d]\", o->flags);\n    else if (k == ANYOF) {\n\tconst U8 flags = (OP(o) == ANYOFH) ? 0 : ANYOF_FLAGS(o);\n        bool do_sep = FALSE;    /* Do we need to separate various components of\n                                   the output? */\n        /* Set if there is still an unresolved user-defined property */\n        SV *unresolved                = NULL;\n\n        /* Things that are ignored except when the runtime locale is UTF-8 */\n        SV *only_utf8_locale_invlist = NULL;\n\n        /* Code points that don't fit in the bitmap */\n        SV *nonbitmap_invlist = NULL;\n\n        /* And things that aren't in the bitmap, but are small enough to be */\n        SV* bitmap_range_not_in_bitmap = NULL;\n\n        const bool inverted = flags & ANYOF_INVERT;\n\n\tif (OP(o) == ANYOFL || OP(o) == ANYOFPOSIXL) {\n            if (ANYOFL_UTF8_LOCALE_REQD(flags)) {\n                sv_catpvs(sv, \"{utf8-locale-reqd}\");\n            }\n            if (flags & ANYOFL_FOLD) {\n                sv_catpvs(sv, \"{i}\");\n            }\n        }\n\n        /* If there is stuff outside the bitmap, get it */\n        if (ARG(o) != ANYOF_ONLY_HAS_BITMAP) {\n            (void) _get_regclass_nonbitmap_data(prog, o, FALSE,\n                                                &unresolved,\n                                                &only_utf8_locale_invlist,\n                                                &nonbitmap_invlist);\n            /* The non-bitmap data may contain stuff that could fit in the\n             * bitmap.  This could come from a user-defined property being\n             * finally resolved when this call was done; or much more likely\n             * because there are matches that require UTF-8 to be valid, and so\n             * aren't in the bitmap.  This is teased apart later */\n            _invlist_intersection(nonbitmap_invlist,\n                                  PL_InBitmap,\n                                  &bitmap_range_not_in_bitmap);\n            /* Leave just the things that don't fit into the bitmap */\n            _invlist_subtract(nonbitmap_invlist,\n                              PL_InBitmap,\n                              &nonbitmap_invlist);\n        }\n\n        /* Obey this flag to add all above-the-bitmap code points */\n        if (flags & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {\n            nonbitmap_invlist = _add_range_to_invlist(nonbitmap_invlist,\n                                                      NUM_ANYOF_CODE_POINTS,\n                                                      UV_MAX);\n        }\n\n        /* Ready to start outputting.  First, the initial left bracket */\n\tPerl_sv_catpvf(aTHX_ sv, \"[%s\", PL_colors[0]);\n\n        if (OP(o) != ANYOFH) {\n            /* Then all the things that could fit in the bitmap */\n            do_sep = put_charclass_bitmap_innards(sv,\n                                                  ANYOF_BITMAP(o),\n                                                  bitmap_range_not_in_bitmap,\n                                                  only_utf8_locale_invlist,\n                                                  o,\n\n                                                  /* Can't try inverting for a\n                                                   * better display if there\n                                                   * are things that haven't\n                                                   * been resolved */\n                                                  unresolved != NULL);\n            SvREFCNT_dec(bitmap_range_not_in_bitmap);\n\n            /* If there are user-defined properties which haven't been defined\n             * yet, output them.  If the result is not to be inverted, it is\n             * clearest to output them in a separate [] from the bitmap range\n             * stuff.  If the result is to be complemented, we have to show\n             * everything in one [], as the inversion applies to the whole\n             * thing.  Use {braces} to separate them from anything in the\n             * bitmap and anything above the bitmap. */\n            if (unresolved) {\n                if (inverted) {\n                    if (! do_sep) { /* If didn't output anything in the bitmap\n                                     */\n                        sv_catpvs(sv, \"^\");\n                    }\n                    sv_catpvs(sv, \"{\");\n                }\n                else if (do_sep) {\n                    Perl_sv_catpvf(aTHX_ sv,\"%s][%s\", PL_colors[1],\n                                                      PL_colors[0]);\n                }\n                sv_catsv(sv, unresolved);\n                if (inverted) {\n                    sv_catpvs(sv, \"}\");\n                }\n                do_sep = ! inverted;\n            }\n        }\n\n        /* And, finally, add the above-the-bitmap stuff */\n        if (nonbitmap_invlist && _invlist_len(nonbitmap_invlist)) {\n            SV* contents;\n\n            /* See if truncation size is overridden */\n            const STRLEN dump_len = (PL_dump_re_max_len > 256)\n                                    ? PL_dump_re_max_len\n                                    : 256;\n\n            /* This is output in a separate [] */\n            if (do_sep) {\n                Perl_sv_catpvf(aTHX_ sv,\"%s][%s\", PL_colors[1], PL_colors[0]);\n            }\n\n            /* And, for easy of understanding, it is shown in the\n             * uncomplemented form if possible.  The one exception being if\n             * there are unresolved items, where the inversion has to be\n             * delayed until runtime */\n            if (inverted && ! unresolved) {\n                _invlist_invert(nonbitmap_invlist);\n                _invlist_subtract(nonbitmap_invlist, PL_InBitmap, &nonbitmap_invlist);\n            }\n\n            contents = invlist_contents(nonbitmap_invlist,\n                                        FALSE /* output suitable for catsv */\n                                       );\n\n            /* If the output is shorter than the permissible maximum, just do it. */\n            if (SvCUR(contents) <= dump_len) {\n                sv_catsv(sv, contents);\n            }\n            else {\n                const char * contents_string = SvPVX(contents);\n                STRLEN i = dump_len;\n\n                /* Otherwise, start at the permissible max and work back to the\n                 * first break possibility */\n                while (i > 0 && contents_string[i] != ' ') {\n                    i--;\n                }\n                if (i == 0) {       /* Fail-safe.  Use the max if we couldn't\n                                       find a legal break */\n                    i = dump_len;\n                }\n\n                sv_catpvn(sv, contents_string, i);\n                sv_catpvs(sv, \"...\");\n            }\n\n            SvREFCNT_dec_NN(contents);\n            SvREFCNT_dec_NN(nonbitmap_invlist);\n        }\n\n        /* And finally the matching, closing ']' */\n\tPerl_sv_catpvf(aTHX_ sv, \"%s]\", PL_colors[1]);\n\n        if (OP(o) == ANYOFH && FLAGS(o) != 0) {\n            Perl_sv_catpvf(aTHX_ sv, \" (First UTF-8 byte=\\\\x%02x)\", FLAGS(o));\n        }\n\n\n        SvREFCNT_dec(unresolved);\n    }\n    else if (k == ANYOFM) {\n        SV * cp_list = get_ANYOFM_contents(o);\n\n\tPerl_sv_catpvf(aTHX_ sv, \"[%s\", PL_colors[0]);\n        if (OP(o) == NANYOFM) {\n            _invlist_invert(cp_list);\n        }\n\n        put_charclass_bitmap_innards(sv, NULL, cp_list, NULL, NULL, TRUE);\n\tPerl_sv_catpvf(aTHX_ sv, \"%s]\", PL_colors[1]);\n\n        SvREFCNT_dec(cp_list);\n    }\n    else if (k == POSIXD || k == NPOSIXD) {\n        U8 index = FLAGS(o) * 2;\n        if (index < C_ARRAY_LENGTH(anyofs)) {\n            if (*anyofs[index] != '[')  {\n                sv_catpvs(sv, \"[\");\n            }\n            sv_catpv(sv, anyofs[index]);\n            if (*anyofs[index] != '[')  {\n                sv_catpvs(sv, \"]\");\n            }\n        }\n        else {\n            Perl_sv_catpvf(aTHX_ sv, \"[illegal type=%d])\", index);\n        }\n    }\n    else if (k == BOUND || k == NBOUND) {\n        /* Must be synced with order of 'bound_type' in regcomp.h */\n        const char * const bounds[] = {\n            \"\",      /* Traditional */\n            \"{gcb}\",\n            \"{lb}\",\n            \"{sb}\",\n            \"{wb}\"\n        };\n        assert(FLAGS(o) < C_ARRAY_LENGTH(bounds));\n        sv_catpv(sv, bounds[FLAGS(o)]);\n    }\n    else if (k == BRANCHJ && (OP(o) == UNLESSM || OP(o) == IFMATCH)) {\n\tPerl_sv_catpvf(aTHX_ sv, \"[%d\", -(o->flags));\n        if (o->next_off) {\n            Perl_sv_catpvf(aTHX_ sv, \"..-%d\", o->flags - o->next_off);\n        }\n\tPerl_sv_catpvf(aTHX_ sv, \"]\");\n    }\n    else if (OP(o) == SBOL)\n        Perl_sv_catpvf(aTHX_ sv, \" /%s/\", o->flags ? \"\\\\A\" : \"^\");\n\n    /* add on the verb argument if there is one */\n    if ( ( k == VERB || OP(o) == ACCEPT || OP(o) == OPFAIL ) && o->flags) {\n        if ( ARG(o) )\n            Perl_sv_catpvf(aTHX_ sv, \":%\" SVf,\n                       SVfARG((MUTABLE_SV(progi->data->data[ ARG( o ) ]))));\n        else\n            sv_catpvs(sv, \":NULL\");\n    }\n#else\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(sv);\n    PERL_UNUSED_ARG(o);\n    PERL_UNUSED_ARG(prog);\n    PERL_UNUSED_ARG(reginfo);\n    PERL_UNUSED_ARG(pRExC_state);\n#endif\t/* DEBUGGING */\n}\n\n\n\nSV *\nPerl_re_intuit_string(pTHX_ REGEXP * const r)\n{\t\t\t\t/* Assume that RE_INTUIT is set */\n    struct regexp *const prog = ReANY(r);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_RE_INTUIT_STRING;\n    PERL_UNUSED_CONTEXT;\n\n    DEBUG_COMPILE_r(\n\t{\n\t    const char * const s = SvPV_nolen_const(RX_UTF8(r)\n\t\t      ? prog->check_utf8 : prog->check_substr);\n\n\t    if (!PL_colorset) reginitcolors();\n            Perl_re_printf( aTHX_\n\t\t      \"%sUsing REx %ssubstr:%s \\\"%s%.60s%s%s\\\"\\n\",\n\t\t      PL_colors[4],\n\t\t      RX_UTF8(r) ? \"utf8 \" : \"\",\n\t\t      PL_colors[5], PL_colors[0],\n\t\t      s,\n\t\t      PL_colors[1],\n\t\t      (strlen(s) > PL_dump_re_max_len ? \"...\" : \"\"));\n\t} );\n\n    /* use UTF8 check substring if regexp pattern itself is in UTF8 */\n    return RX_UTF8(r) ? prog->check_utf8 : prog->check_substr;\n}\n\n/*\n   pregfree()\n\n   handles refcounting and freeing the perl core regexp structure. When\n   it is necessary to actually free the structure the first thing it\n   does is call the 'free' method of the regexp_engine associated to\n   the regexp, allowing the handling of the void *pprivate; member\n   first. (This routine is not overridable by extensions, which is why\n   the extensions free is called first.)\n\n   See regdupe and regdupe_internal if you change anything here.\n*/\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_pregfree(pTHX_ REGEXP *r)\n{\n    SvREFCNT_dec(r);\n}\n\nvoid\nPerl_pregfree2(pTHX_ REGEXP *rx)\n{\n    struct regexp *const r = ReANY(rx);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_PREGFREE2;\n\n    if (! r)\n        return;\n\n    if (r->mother_re) {\n        ReREFCNT_dec(r->mother_re);\n    } else {\n        CALLREGFREE_PVT(rx); /* free the private data */\n        SvREFCNT_dec(RXp_PAREN_NAMES(r));\n    }\n    if (r->substrs) {\n        int i;\n        for (i = 0; i < 2; i++) {\n            SvREFCNT_dec(r->substrs->data[i].substr);\n            SvREFCNT_dec(r->substrs->data[i].utf8_substr);\n        }\n\tSafefree(r->substrs);\n    }\n    RX_MATCH_COPY_FREE(rx);\n#ifdef PERL_ANY_COW\n    SvREFCNT_dec(r->saved_copy);\n#endif\n    Safefree(r->offs);\n    SvREFCNT_dec(r->qr_anoncv);\n    if (r->recurse_locinput)\n        Safefree(r->recurse_locinput);\n}\n\n\n/*  reg_temp_copy()\n\n    Copy ssv to dsv, both of which should of type SVt_REGEXP or SVt_PVLV,\n    except that dsv will be created if NULL.\n\n    This function is used in two main ways. First to implement\n        $r = qr/....; $s = $$r;\n\n    Secondly, it is used as a hacky workaround to the structural issue of\n    match results\n    being stored in the regexp structure which is in turn stored in\n    PL_curpm/PL_reg_curpm. The problem is that due to qr// the pattern\n    could be PL_curpm in multiple contexts, and could require multiple\n    result sets being associated with the pattern simultaneously, such\n    as when doing a recursive match with (??{$qr})\n\n    The solution is to make a lightweight copy of the regexp structure\n    when a qr// is returned from the code executed by (??{$qr}) this\n    lightweight copy doesn't actually own any of its data except for\n    the starp/end and the actual regexp structure itself.\n\n*/\n\n\nREGEXP *\nPerl_reg_temp_copy(pTHX_ REGEXP *dsv, REGEXP *ssv)\n{\n    struct regexp *drx;\n    struct regexp *const srx = ReANY(ssv);\n    const bool islv = dsv && SvTYPE(dsv) == SVt_PVLV;\n\n    PERL_ARGS_ASSERT_REG_TEMP_COPY;\n\n    if (!dsv)\n\tdsv = (REGEXP*) newSV_type(SVt_REGEXP);\n    else {\n        assert(SvTYPE(dsv) == SVt_REGEXP || (SvTYPE(dsv) == SVt_PVLV));\n\n        /* our only valid caller, sv_setsv_flags(), should have done\n         * a SV_CHECK_THINKFIRST_COW_DROP() by now */\n        assert(!SvOOK(dsv));\n        assert(!SvIsCOW(dsv));\n        assert(!SvROK(dsv));\n\n        if (SvPVX_const(dsv)) {\n            if (SvLEN(dsv))\n                Safefree(SvPVX(dsv));\n            SvPVX(dsv) = NULL;\n        }\n        SvLEN_set(dsv, 0);\n        SvCUR_set(dsv, 0);\n\tSvOK_off((SV *)dsv);\n\n\tif (islv) {\n\t    /* For PVLVs, the head (sv_any) points to an XPVLV, while\n             * the LV's xpvlenu_rx will point to a regexp body, which\n             * we allocate here */\n\t    REGEXP *temp = (REGEXP *)newSV_type(SVt_REGEXP);\n\t    assert(!SvPVX(dsv));\n            ((XPV*)SvANY(dsv))->xpv_len_u.xpvlenu_rx = temp->sv_any;\n\t    temp->sv_any = NULL;\n\t    SvFLAGS(temp) = (SvFLAGS(temp) & ~SVTYPEMASK) | SVt_NULL;\n\t    SvREFCNT_dec_NN(temp);\n\t    /* SvCUR still resides in the xpvlv struct, so the regexp copy-\n\t       ing below will not set it. */\n\t    SvCUR_set(dsv, SvCUR(ssv));\n\t}\n    }\n    /* This ensures that SvTHINKFIRST(sv) is true, and hence that\n       sv_force_normal(sv) is called.  */\n    SvFAKE_on(dsv);\n    drx = ReANY(dsv);\n\n    SvFLAGS(dsv) |= SvFLAGS(ssv) & (SVf_POK|SVp_POK|SVf_UTF8);\n    SvPV_set(dsv, RX_WRAPPED(ssv));\n    /* We share the same string buffer as the original regexp, on which we\n       hold a reference count, incremented when mother_re is set below.\n       The string pointer is copied here, being part of the regexp struct.\n     */\n    memcpy(&(drx->xpv_cur), &(srx->xpv_cur),\n\t   sizeof(regexp) - STRUCT_OFFSET(regexp, xpv_cur));\n    if (!islv)\n        SvLEN_set(dsv, 0);\n    if (srx->offs) {\n        const I32 npar = srx->nparens+1;\n        Newx(drx->offs, npar, regexp_paren_pair);\n        Copy(srx->offs, drx->offs, npar, regexp_paren_pair);\n    }\n    if (srx->substrs) {\n        int i;\n        Newx(drx->substrs, 1, struct reg_substr_data);\n\tStructCopy(srx->substrs, drx->substrs, struct reg_substr_data);\n\n        for (i = 0; i < 2; i++) {\n            SvREFCNT_inc_void(drx->substrs->data[i].substr);\n            SvREFCNT_inc_void(drx->substrs->data[i].utf8_substr);\n        }\n\n\t/* check_substr and check_utf8, if non-NULL, point to either their\n\t   anchored or float namesakes, and don't hold a second reference.  */\n    }\n    RX_MATCH_COPIED_off(dsv);\n#ifdef PERL_ANY_COW\n    drx->saved_copy = NULL;\n#endif\n    drx->mother_re = ReREFCNT_inc(srx->mother_re ? srx->mother_re : ssv);\n    SvREFCNT_inc_void(drx->qr_anoncv);\n    if (srx->recurse_locinput)\n        Newx(drx->recurse_locinput, srx->nparens + 1, char *);\n\n    return dsv;\n}\n#endif\n\n\n/* regfree_internal()\n\n   Free the private data in a regexp. This is overloadable by\n   extensions. Perl takes care of the regexp structure in pregfree(),\n   this covers the *pprivate pointer which technically perl doesn't\n   know about, however of course we have to handle the\n   regexp_internal structure when no extension is in use.\n\n   Note this is called before freeing anything in the regexp\n   structure.\n */\n\nvoid\nPerl_regfree_internal(pTHX_ REGEXP * const rx)\n{\n    struct regexp *const r = ReANY(rx);\n    RXi_GET_DECL(r, ri);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGFREE_INTERNAL;\n\n    if (! ri) {\n        return;\n    }\n\n    DEBUG_COMPILE_r({\n\tif (!PL_colorset)\n\t    reginitcolors();\n\t{\n\t    SV *dsv= sv_newmortal();\n            RE_PV_QUOTED_DECL(s, RX_UTF8(rx),\n                dsv, RX_PRECOMP(rx), RX_PRELEN(rx), PL_dump_re_max_len);\n            Perl_re_printf( aTHX_ \"%sFreeing REx:%s %s\\n\",\n                PL_colors[4], PL_colors[5], s);\n        }\n    });\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    if (ri->u.offsets)\n        Safefree(ri->u.offsets);             /* 20010421 MJD */\n#endif\n    if (ri->code_blocks)\n        S_free_codeblocks(aTHX_ ri->code_blocks);\n\n    if (ri->data) {\n\tint n = ri->data->count;\n\n\twhile (--n >= 0) {\n          /* If you add a ->what type here, update the comment in regcomp.h */\n\t    switch (ri->data->what[n]) {\n\t    case 'a':\n\t    case 'r':\n\t    case 's':\n\t    case 'S':\n\t    case 'u':\n\t\tSvREFCNT_dec(MUTABLE_SV(ri->data->data[n]));\n\t\tbreak;\n\t    case 'f':\n\t\tSafefree(ri->data->data[n]);\n\t\tbreak;\n\t    case 'l':\n\t    case 'L':\n\t        break;\n            case 'T':\n                { /* Aho Corasick add-on structure for a trie node.\n                     Used in stclass optimization only */\n                    U32 refcount;\n                    reg_ac_data *aho=(reg_ac_data*)ri->data->data[n];\n#ifdef USE_ITHREADS\n                    dVAR;\n#endif\n                    OP_REFCNT_LOCK;\n                    refcount = --aho->refcount;\n                    OP_REFCNT_UNLOCK;\n                    if ( !refcount ) {\n                        PerlMemShared_free(aho->states);\n                        PerlMemShared_free(aho->fail);\n\t\t\t /* do this last!!!! */\n                        PerlMemShared_free(ri->data->data[n]);\n                        /* we should only ever get called once, so\n                         * assert as much, and also guard the free\n                         * which /might/ happen twice. At the least\n                         * it will make code anlyzers happy and it\n                         * doesn't cost much. - Yves */\n                        assert(ri->regstclass);\n                        if (ri->regstclass) {\n                            PerlMemShared_free(ri->regstclass);\n                            ri->regstclass = 0;\n                        }\n                    }\n                }\n                break;\n\t    case 't':\n\t        {\n\t            /* trie structure. */\n\t            U32 refcount;\n\t            reg_trie_data *trie=(reg_trie_data*)ri->data->data[n];\n#ifdef USE_ITHREADS\n                    dVAR;\n#endif\n                    OP_REFCNT_LOCK;\n                    refcount = --trie->refcount;\n                    OP_REFCNT_UNLOCK;\n                    if ( !refcount ) {\n                        PerlMemShared_free(trie->charmap);\n                        PerlMemShared_free(trie->states);\n                        PerlMemShared_free(trie->trans);\n                        if (trie->bitmap)\n                            PerlMemShared_free(trie->bitmap);\n                        if (trie->jump)\n                            PerlMemShared_free(trie->jump);\n\t\t\tPerlMemShared_free(trie->wordinfo);\n                        /* do this last!!!! */\n                        PerlMemShared_free(ri->data->data[n]);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    default:\n\t\tPerl_croak(aTHX_ \"panic: regfree data code '%c'\",\n                                                    ri->data->what[n]);\n\t    }\n\t}\n\tSafefree(ri->data->what);\n\tSafefree(ri->data);\n    }\n\n    Safefree(ri);\n}\n\n#define av_dup_inc(s, t)\tMUTABLE_AV(sv_dup_inc((const SV *)s, t))\n#define hv_dup_inc(s, t)\tMUTABLE_HV(sv_dup_inc((const SV *)s, t))\n#define SAVEPVN(p, n)\t((p) ? savepvn(p, n) : NULL)\n\n/*\n   re_dup_guts - duplicate a regexp.\n\n   This routine is expected to clone a given regexp structure. It is only\n   compiled under USE_ITHREADS.\n\n   After all of the core data stored in struct regexp is duplicated\n   the regexp_engine.dupe method is used to copy any private data\n   stored in the *pprivate pointer. This allows extensions to handle\n   any duplication it needs to do.\n\n   See pregfree() and regfree_internal() if you change anything here.\n*/\n#if defined(USE_ITHREADS)\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_re_dup_guts(pTHX_ const REGEXP *sstr, REGEXP *dstr, CLONE_PARAMS *param)\n{\n    dVAR;\n    I32 npar;\n    const struct regexp *r = ReANY(sstr);\n    struct regexp *ret = ReANY(dstr);\n\n    PERL_ARGS_ASSERT_RE_DUP_GUTS;\n\n    npar = r->nparens+1;\n    Newx(ret->offs, npar, regexp_paren_pair);\n    Copy(r->offs, ret->offs, npar, regexp_paren_pair);\n\n    if (ret->substrs) {\n\t/* Do it this way to avoid reading from *r after the StructCopy().\n\t   That way, if any of the sv_dup_inc()s dislodge *r from the L1\n\t   cache, it doesn't matter.  */\n        int i;\n\tconst bool anchored = r->check_substr\n\t    ? r->check_substr == r->substrs->data[0].substr\n\t    : r->check_utf8   == r->substrs->data[0].utf8_substr;\n        Newx(ret->substrs, 1, struct reg_substr_data);\n\tStructCopy(r->substrs, ret->substrs, struct reg_substr_data);\n\n        for (i = 0; i < 2; i++) {\n            ret->substrs->data[i].substr =\n                        sv_dup_inc(ret->substrs->data[i].substr, param);\n            ret->substrs->data[i].utf8_substr =\n                        sv_dup_inc(ret->substrs->data[i].utf8_substr, param);\n        }\n\n\t/* check_substr and check_utf8, if non-NULL, point to either their\n\t   anchored or float namesakes, and don't hold a second reference.  */\n\n\tif (ret->check_substr) {\n\t    if (anchored) {\n\t\tassert(r->check_utf8 == r->substrs->data[0].utf8_substr);\n\n\t\tret->check_substr = ret->substrs->data[0].substr;\n\t\tret->check_utf8   = ret->substrs->data[0].utf8_substr;\n\t    } else {\n\t\tassert(r->check_substr == r->substrs->data[1].substr);\n\t\tassert(r->check_utf8   == r->substrs->data[1].utf8_substr);\n\n\t\tret->check_substr = ret->substrs->data[1].substr;\n\t\tret->check_utf8   = ret->substrs->data[1].utf8_substr;\n\t    }\n\t} else if (ret->check_utf8) {\n\t    if (anchored) {\n\t\tret->check_utf8 = ret->substrs->data[0].utf8_substr;\n\t    } else {\n\t\tret->check_utf8 = ret->substrs->data[1].utf8_substr;\n\t    }\n\t}\n    }\n\n    RXp_PAREN_NAMES(ret) = hv_dup_inc(RXp_PAREN_NAMES(ret), param);\n    ret->qr_anoncv = MUTABLE_CV(sv_dup_inc((const SV *)ret->qr_anoncv, param));\n    if (r->recurse_locinput)\n        Newx(ret->recurse_locinput, r->nparens + 1, char *);\n\n    if (ret->pprivate)\n\tRXi_SET(ret, CALLREGDUPE_PVT(dstr, param));\n\n    if (RX_MATCH_COPIED(dstr))\n\tret->subbeg  = SAVEPVN(ret->subbeg, ret->sublen);\n    else\n\tret->subbeg = NULL;\n#ifdef PERL_ANY_COW\n    ret->saved_copy = NULL;\n#endif\n\n    /* Whether mother_re be set or no, we need to copy the string.  We\n       cannot refrain from copying it when the storage points directly to\n       our mother regexp, because that's\n\t       1: a buffer in a different thread\n\t       2: something we no longer hold a reference on\n\t       so we need to copy it locally.  */\n    RX_WRAPPED(dstr) = SAVEPVN(RX_WRAPPED_const(sstr), SvCUR(sstr)+1);\n    /* set malloced length to a non-zero value so it will be freed\n     * (otherwise in combination with SVf_FAKE it looks like an alien\n     * buffer). It doesn't have to be the actual malloced size, since it\n     * should never be grown */\n    SvLEN_set(dstr, SvCUR(sstr)+1);\n    ret->mother_re   = NULL;\n}\n#endif /* PERL_IN_XSUB_RE */\n\n/*\n   regdupe_internal()\n\n   This is the internal complement to regdupe() which is used to copy\n   the structure pointed to by the *pprivate pointer in the regexp.\n   This is the core version of the extension overridable cloning hook.\n   The regexp structure being duplicated will be copied by perl prior\n   to this and will be provided as the regexp *r argument, however\n   with the /old/ structures pprivate pointer value. Thus this routine\n   may override any copying normally done by perl.\n\n   It returns a pointer to the new regexp_internal structure.\n*/\n\nvoid *\nPerl_regdupe_internal(pTHX_ REGEXP * const rx, CLONE_PARAMS *param)\n{\n    dVAR;\n    struct regexp *const r = ReANY(rx);\n    regexp_internal *reti;\n    int len;\n    RXi_GET_DECL(r, ri);\n\n    PERL_ARGS_ASSERT_REGDUPE_INTERNAL;\n\n    len = ProgLen(ri);\n\n    Newxc(reti, sizeof(regexp_internal) + len*sizeof(regnode),\n          char, regexp_internal);\n    Copy(ri->program, reti->program, len+1, regnode);\n\n\n    if (ri->code_blocks) {\n\tint n;\n\tNewx(reti->code_blocks, 1, struct reg_code_blocks);\n\tNewx(reti->code_blocks->cb, ri->code_blocks->count,\n                    struct reg_code_block);\n\tCopy(ri->code_blocks->cb, reti->code_blocks->cb,\n             ri->code_blocks->count, struct reg_code_block);\n\tfor (n = 0; n < ri->code_blocks->count; n++)\n\t     reti->code_blocks->cb[n].src_regex = (REGEXP*)\n\t\t    sv_dup_inc((SV*)(ri->code_blocks->cb[n].src_regex), param);\n        reti->code_blocks->count = ri->code_blocks->count;\n        reti->code_blocks->refcnt = 1;\n    }\n    else\n\treti->code_blocks = NULL;\n\n    reti->regstclass = NULL;\n\n    if (ri->data) {\n\tstruct reg_data *d;\n        const int count = ri->data->count;\n\tint i;\n\n\tNewxc(d, sizeof(struct reg_data) + count*sizeof(void *),\n\t\tchar, struct reg_data);\n\tNewx(d->what, count, U8);\n\n\td->count = count;\n\tfor (i = 0; i < count; i++) {\n\t    d->what[i] = ri->data->what[i];\n\t    switch (d->what[i]) {\n\t        /* see also regcomp.h and regfree_internal() */\n            case 'a': /* actually an AV, but the dup function is identical.\n                         values seem to be \"plain sv's\" generally. */\n            case 'r': /* a compiled regex (but still just another SV) */\n            case 's': /* an RV (currently only used for an RV to an AV by the ANYOF code)\n                         this use case should go away, the code could have used\n                         'a' instead - see S_set_ANYOF_arg() for array contents. */\n            case 'S': /* actually an SV, but the dup function is identical.  */\n            case 'u': /* actually an HV, but the dup function is identical.\n                         values are \"plain sv's\" */\n\t\td->data[i] = sv_dup_inc((const SV *)ri->data->data[i], param);\n\t\tbreak;\n\t    case 'f':\n                /* Synthetic Start Class - \"Fake\" charclass we generate to optimize\n                 * patterns which could start with several different things. Pre-TRIE\n                 * this was more important than it is now, however this still helps\n                 * in some places, for instance /x?a+/ might produce a SSC equivalent\n                 * to [xa]. This is used by Perl_re_intuit_start() and S_find_byclass()\n                 * in regexec.c\n                 */\n\t\t/* This is cheating. */\n\t\tNewx(d->data[i], 1, regnode_ssc);\n\t\tStructCopy(ri->data->data[i], d->data[i], regnode_ssc);\n\t\treti->regstclass = (regnode*)d->data[i];\n\t\tbreak;\n\t    case 'T':\n                /* AHO-CORASICK fail table */\n                /* Trie stclasses are readonly and can thus be shared\n\t\t * without duplication. We free the stclass in pregfree\n\t\t * when the corresponding reg_ac_data struct is freed.\n\t\t */\n\t\treti->regstclass= ri->regstclass;\n\t\t/* FALLTHROUGH */\n\t    case 't':\n                /* TRIE transition table */\n\t\tOP_REFCNT_LOCK;\n\t\t((reg_trie_data*)ri->data->data[i])->refcount++;\n\t\tOP_REFCNT_UNLOCK;\n\t\t/* FALLTHROUGH */\n            case 'l': /* (?{...}) or (??{ ... }) code (cb->block) */\n            case 'L': /* same when RExC_pm_flags & PMf_HAS_CV and code\n                         is not from another regexp */\n\t\td->data[i] = ri->data->data[i];\n\t\tbreak;\n            default:\n                Perl_croak(aTHX_ \"panic: re_dup_guts unknown data code '%c'\",\n                                                           ri->data->what[i]);\n\t    }\n\t}\n\n\treti->data = d;\n    }\n    else\n\treti->data = NULL;\n\n    reti->name_list_idx = ri->name_list_idx;\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    if (ri->u.offsets) {\n        Newx(reti->u.offsets, 2*len+1, U32);\n        Copy(ri->u.offsets, reti->u.offsets, 2*len+1, U32);\n    }\n#else\n    SetProgLen(reti, len);\n#endif\n\n    return (void*)reti;\n}\n\n#endif    /* USE_ITHREADS */\n\n#ifndef PERL_IN_XSUB_RE\n\n/*\n - regnext - dig the \"next\" pointer out of a node\n */\nregnode *\nPerl_regnext(pTHX_ regnode *p)\n{\n    I32 offset;\n\n    if (!p)\n\treturn(NULL);\n\n    if (OP(p) > REGNODE_MAX) {\t\t/* regnode.type is unsigned */\n\tPerl_croak(aTHX_ \"Corrupted regexp opcode %d > %d\",\n                                                (int)OP(p), (int)REGNODE_MAX);\n    }\n\n    offset = (reg_off_by_arg[OP(p)] ? ARG(p) : NEXT_OFF(p));\n    if (offset == 0)\n\treturn(NULL);\n\n    return(p+offset);\n}\n\n#endif\n\nSTATIC void\nS_re_croak2(pTHX_ bool utf8, const char* pat1, const char* pat2,...)\n{\n    va_list args;\n    STRLEN l1 = strlen(pat1);\n    STRLEN l2 = strlen(pat2);\n    char buf[512];\n    SV *msv;\n    const char *message;\n\n    PERL_ARGS_ASSERT_RE_CROAK2;\n\n    if (l1 > 510)\n\tl1 = 510;\n    if (l1 + l2 > 510)\n\tl2 = 510 - l1;\n    Copy(pat1, buf, l1 , char);\n    Copy(pat2, buf + l1, l2 , char);\n    buf[l1 + l2] = '\\n';\n    buf[l1 + l2 + 1] = '\\0';\n    va_start(args, pat2);\n    msv = vmess(buf, &args);\n    va_end(args);\n    message = SvPV_const(msv, l1);\n    if (l1 > 512)\n\tl1 = 512;\n    Copy(message, buf, l1 , char);\n    /* l1-1 to avoid \\n */\n    Perl_croak(aTHX_ \"%\" UTF8f, UTF8fARG(utf8, l1-1, buf));\n}\n\n/* XXX Here's a total kludge.  But we need to re-enter for swash routines. */\n\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_save_re_context(pTHX)\n{\n    I32 nparens = -1;\n    I32 i;\n\n    /* Save $1..$n (#18107: UTF-8 s/(\\w+)/uc($1)/e); AMS 20021106. */\n\n    if (PL_curpm) {\n\tconst REGEXP * const rx = PM_GETRE(PL_curpm);\n\tif (rx)\n            nparens = RX_NPARENS(rx);\n    }\n\n    /* RT #124109. This is a complete hack; in the SWASHNEW case we know\n     * that PL_curpm will be null, but that utf8.pm and the modules it\n     * loads will only use $1..$3.\n     * The t/porting/re_context.t test file checks this assumption.\n     */\n    if (nparens == -1)\n        nparens = 3;\n\n    for (i = 1; i <= nparens; i++) {\n        char digits[TYPE_CHARS(long)];\n        const STRLEN len = my_snprintf(digits, sizeof(digits),\n                                       \"%lu\", (long)i);\n        GV *const *const gvp\n            = (GV**)hv_fetch(PL_defstash, digits, len, 0);\n\n        if (gvp) {\n            GV * const gv = *gvp;\n            if (SvTYPE(gv) == SVt_PVGV && GvSV(gv))\n                save_scalar(gv);\n        }\n    }\n}\n#endif\n\n#ifdef DEBUGGING\n\nSTATIC void\nS_put_code_point(pTHX_ SV *sv, UV c)\n{\n    PERL_ARGS_ASSERT_PUT_CODE_POINT;\n\n    if (c > 255) {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x{%04\" UVXf \"}\", c);\n    }\n    else if (isPRINT(c)) {\n\tconst char string = (char) c;\n\n        /* We use {phrase} as metanotation in the class, so also escape literal\n         * braces */\n\tif (isBACKSLASHED_PUNCT(c) || c == '{' || c == '}')\n\t    sv_catpvs(sv, \"\\\\\");\n\tsv_catpvn(sv, &string, 1);\n    }\n    else if (isMNEMONIC_CNTRL(c)) {\n        Perl_sv_catpvf(aTHX_ sv, \"%s\", cntrl_to_mnemonic((U8) c));\n    }\n    else {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x%02X\", (U8) c);\n    }\n}\n\n#define MAX_PRINT_A MAX_PRINT_A_FOR_USE_ONLY_BY_REGCOMP_DOT_C\n\nSTATIC void\nS_put_range(pTHX_ SV *sv, UV start, const UV end, const bool allow_literals)\n{\n    /* Appends to 'sv' a displayable version of the range of code points from\n     * 'start' to 'end'.  Mnemonics (like '\\r') are used for the few controls\n     * that have them, when they occur at the beginning or end of the range.\n     * It uses hex to output the remaining code points, unless 'allow_literals'\n     * is true, in which case the printable ASCII ones are output as-is (though\n     * some of these will be escaped by put_code_point()).\n     *\n     * NOTE:  This is designed only for printing ranges of code points that fit\n     *        inside an ANYOF bitmap.  Higher code points are simply suppressed\n     */\n\n    const unsigned int min_range_count = 3;\n\n    assert(start <= end);\n\n    PERL_ARGS_ASSERT_PUT_RANGE;\n\n    while (start <= end) {\n        UV this_end;\n        const char * format;\n\n        if (end - start < min_range_count) {\n\n            /* Output chars individually when they occur in short ranges */\n            for (; start <= end; start++) {\n                put_code_point(sv, start);\n            }\n            break;\n        }\n\n        /* If permitted by the input options, and there is a possibility that\n         * this range contains a printable literal, look to see if there is\n         * one. */\n        if (allow_literals && start <= MAX_PRINT_A) {\n\n            /* If the character at the beginning of the range isn't an ASCII\n             * printable, effectively split the range into two parts:\n             *  1) the portion before the first such printable,\n             *  2) the rest\n             * and output them separately. */\n            if (! isPRINT_A(start)) {\n                UV temp_end = start + 1;\n\n                /* There is no point looking beyond the final possible\n                 * printable, in MAX_PRINT_A */\n                UV max = MIN(end, MAX_PRINT_A);\n\n                while (temp_end <= max && ! isPRINT_A(temp_end)) {\n                    temp_end++;\n                }\n\n                /* Here, temp_end points to one beyond the first printable if\n                 * found, or to one beyond 'max' if not.  If none found, make\n                 * sure that we use the entire range */\n                if (temp_end > MAX_PRINT_A) {\n                    temp_end = end + 1;\n                }\n\n                /* Output the first part of the split range: the part that\n                 * doesn't have printables, with the parameter set to not look\n                 * for literals (otherwise we would infinitely recurse) */\n                put_range(sv, start, temp_end - 1, FALSE);\n\n                /* The 2nd part of the range (if any) starts here. */\n                start = temp_end;\n\n                /* We do a continue, instead of dropping down, because even if\n                 * the 2nd part is non-empty, it could be so short that we want\n                 * to output it as individual characters, as tested for at the\n                 * top of this loop.  */\n                continue;\n            }\n\n            /* Here, 'start' is a printable ASCII.  If it is an alphanumeric,\n             * output a sub-range of just the digits or letters, then process\n             * the remaining portion as usual. */\n            if (isALPHANUMERIC_A(start)) {\n                UV mask = (isDIGIT_A(start))\n                           ? _CC_DIGIT\n                             : isUPPER_A(start)\n                               ? _CC_UPPER\n                               : _CC_LOWER;\n                UV temp_end = start + 1;\n\n                /* Find the end of the sub-range that includes just the\n                 * characters in the same class as the first character in it */\n                while (temp_end <= end && _generic_isCC_A(temp_end, mask)) {\n                    temp_end++;\n                }\n                temp_end--;\n\n                /* For short ranges, don't duplicate the code above to output\n                 * them; just call recursively */\n                if (temp_end - start < min_range_count) {\n                    put_range(sv, start, temp_end, FALSE);\n                }\n                else {  /* Output as a range */\n                    put_code_point(sv, start);\n                    sv_catpvs(sv, \"-\");\n                    put_code_point(sv, temp_end);\n                }\n                start = temp_end + 1;\n                continue;\n            }\n\n            /* We output any other printables as individual characters */\n            if (isPUNCT_A(start) || isSPACE_A(start)) {\n                while (start <= end && (isPUNCT_A(start)\n                                        || isSPACE_A(start)))\n                {\n                    put_code_point(sv, start);\n                    start++;\n                }\n                continue;\n            }\n        } /* End of looking for literals */\n\n        /* Here is not to output as a literal.  Some control characters have\n         * mnemonic names.  Split off any of those at the beginning and end of\n         * the range to print mnemonically.  It isn't possible for many of\n         * these to be in a row, so this won't overwhelm with output */\n        if (   start <= end\n            && (isMNEMONIC_CNTRL(start) || isMNEMONIC_CNTRL(end)))\n        {\n            while (isMNEMONIC_CNTRL(start) && start <= end) {\n                put_code_point(sv, start);\n                start++;\n            }\n\n            /* If this didn't take care of the whole range ... */\n            if (start <= end) {\n\n                /* Look backwards from the end to find the final non-mnemonic\n                 * */\n                UV temp_end = end;\n                while (isMNEMONIC_CNTRL(temp_end)) {\n                    temp_end--;\n                }\n\n                /* And separately output the interior range that doesn't start\n                 * or end with mnemonics */\n                put_range(sv, start, temp_end, FALSE);\n\n                /* Then output the mnemonic trailing controls */\n                start = temp_end + 1;\n                while (start <= end) {\n                    put_code_point(sv, start);\n                    start++;\n                }\n                break;\n            }\n        }\n\n        /* As a final resort, output the range or subrange as hex. */\n\n        this_end = (end < NUM_ANYOF_CODE_POINTS)\n                    ? end\n                    : NUM_ANYOF_CODE_POINTS - 1;\n#if NUM_ANYOF_CODE_POINTS > 256\n        format = (this_end < 256)\n                 ? \"\\\\x%02\" UVXf \"-\\\\x%02\" UVXf\n                 : \"\\\\x{%04\" UVXf \"}-\\\\x{%04\" UVXf \"}\";\n#else\n        format = \"\\\\x%02\" UVXf \"-\\\\x%02\" UVXf;\n#endif\n        GCC_DIAG_IGNORE_STMT(-Wformat-nonliteral);\n        Perl_sv_catpvf(aTHX_ sv, format, start, this_end);\n        GCC_DIAG_RESTORE_STMT;\n        break;\n    }\n}\n\nSTATIC void\nS_put_charclass_bitmap_innards_invlist(pTHX_ SV *sv, SV* invlist)\n{\n    /* Concatenate onto the PV in 'sv' a displayable form of the inversion list\n     * 'invlist' */\n\n    UV start, end;\n    bool allow_literals = TRUE;\n\n    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_INVLIST;\n\n    /* Generally, it is more readable if printable characters are output as\n     * literals, but if a range (nearly) spans all of them, it's best to output\n     * it as a single range.  This code will use a single range if all but 2\n     * ASCII printables are in it */\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n\n        /* If the range starts beyond the final printable, it doesn't have any\n         * in it */\n        if (start > MAX_PRINT_A) {\n            break;\n        }\n\n        /* In both ASCII and EBCDIC, a SPACE is the lowest printable.  To span\n         * all but two, the range must start and end no later than 2 from\n         * either end */\n        if (start < ' ' + 2 && end > MAX_PRINT_A - 2) {\n            if (end > MAX_PRINT_A) {\n                end = MAX_PRINT_A;\n            }\n            if (start < ' ') {\n                start = ' ';\n            }\n            if (end - start >= MAX_PRINT_A - ' ' - 2) {\n                allow_literals = FALSE;\n            }\n            break;\n        }\n    }\n    invlist_iterfinish(invlist);\n\n    /* Here we have figured things out.  Output each range */\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n        if (start >= NUM_ANYOF_CODE_POINTS) {\n            break;\n        }\n        put_range(sv, start, end, allow_literals);\n    }\n    invlist_iterfinish(invlist);\n\n    return;\n}\n\nSTATIC SV*\nS_put_charclass_bitmap_innards_common(pTHX_\n        SV* invlist,            /* The bitmap */\n        SV* posixes,            /* Under /l, things like [:word:], \\S */\n        SV* only_utf8,          /* Under /d, matches iff the target is UTF-8 */\n        SV* not_utf8,           /* /d, matches iff the target isn't UTF-8 */\n        SV* only_utf8_locale,   /* Under /l, matches if the locale is UTF-8 */\n        const bool invert       /* Is the result to be inverted? */\n)\n{\n    /* Create and return an SV containing a displayable version of the bitmap\n     * and associated information determined by the input parameters.  If the\n     * output would have been only the inversion indicator '^', NULL is instead\n     * returned. */\n\n    dVAR;\n    SV * output;\n\n    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_COMMON;\n\n    if (invert) {\n        output = newSVpvs(\"^\");\n    }\n    else {\n        output = newSVpvs(\"\");\n    }\n\n    /* First, the code points in the bitmap that are unconditionally there */\n    put_charclass_bitmap_innards_invlist(output, invlist);\n\n    /* Traditionally, these have been placed after the main code points */\n    if (posixes) {\n        sv_catsv(output, posixes);\n    }\n\n    if (only_utf8 && _invlist_len(only_utf8)) {\n        Perl_sv_catpvf(aTHX_ output, \"%s{utf8}%s\", PL_colors[1], PL_colors[0]);\n        put_charclass_bitmap_innards_invlist(output, only_utf8);\n    }\n\n    if (not_utf8 && _invlist_len(not_utf8)) {\n        Perl_sv_catpvf(aTHX_ output, \"%s{not utf8}%s\", PL_colors[1], PL_colors[0]);\n        put_charclass_bitmap_innards_invlist(output, not_utf8);\n    }\n\n    if (only_utf8_locale && _invlist_len(only_utf8_locale)) {\n        Perl_sv_catpvf(aTHX_ output, \"%s{utf8 locale}%s\", PL_colors[1], PL_colors[0]);\n        put_charclass_bitmap_innards_invlist(output, only_utf8_locale);\n\n        /* This is the only list in this routine that can legally contain code\n         * points outside the bitmap range.  The call just above to\n         * 'put_charclass_bitmap_innards_invlist' will simply suppress them, so\n         * output them here.  There's about a half-dozen possible, and none in\n         * contiguous ranges longer than 2 */\n        if (invlist_highest(only_utf8_locale) >= NUM_ANYOF_CODE_POINTS) {\n            UV start, end;\n            SV* above_bitmap = NULL;\n\n            _invlist_subtract(only_utf8_locale, PL_InBitmap, &above_bitmap);\n\n            invlist_iterinit(above_bitmap);\n            while (invlist_iternext(above_bitmap, &start, &end)) {\n                UV i;\n\n                for (i = start; i <= end; i++) {\n                    put_code_point(output, i);\n                }\n            }\n            invlist_iterfinish(above_bitmap);\n            SvREFCNT_dec_NN(above_bitmap);\n        }\n    }\n\n    if (invert && SvCUR(output) == 1) {\n        return NULL;\n    }\n\n    return output;\n}\n\nSTATIC bool\nS_put_charclass_bitmap_innards(pTHX_ SV *sv,\n                                     char *bitmap,\n                                     SV *nonbitmap_invlist,\n                                     SV *only_utf8_locale_invlist,\n                                     const regnode * const node,\n                                     const bool force_as_is_display)\n{\n    /* Appends to 'sv' a displayable version of the innards of the bracketed\n     * character class defined by the other arguments:\n     *  'bitmap' points to the bitmap, or NULL if to ignore that.\n     *  'nonbitmap_invlist' is an inversion list of the code points that are in\n     *      the bitmap range, but for some reason aren't in the bitmap; NULL if\n     *      none.  The reasons for this could be that they require some\n     *      condition such as the target string being or not being in UTF-8\n     *      (under /d), or because they came from a user-defined property that\n     *      was not resolved at the time of the regex compilation (under /u)\n     *  'only_utf8_locale_invlist' is an inversion list of the code points that\n     *      are valid only if the runtime locale is a UTF-8 one; NULL if none\n     *  'node' is the regex pattern ANYOF node.  It is needed only when the\n     *      above two parameters are not null, and is passed so that this\n     *      routine can tease apart the various reasons for them.\n     *  'force_as_is_display' is TRUE if this routine should definitely NOT try\n     *      to invert things to see if that leads to a cleaner display.  If\n     *      FALSE, this routine is free to use its judgment about doing this.\n     *\n     * It returns TRUE if there was actually something output.  (It may be that\n     * the bitmap, etc is empty.)\n     *\n     * When called for outputting the bitmap of a non-ANYOF node, just pass the\n     * bitmap, with the succeeding parameters set to NULL, and the final one to\n     * FALSE.\n     */\n\n    /* In general, it tries to display the 'cleanest' representation of the\n     * innards, choosing whether to display them inverted or not, regardless of\n     * whether the class itself is to be inverted.  However,  there are some\n     * cases where it can't try inverting, as what actually matches isn't known\n     * until runtime, and hence the inversion isn't either. */\n\n    dVAR;\n    bool inverting_allowed = ! force_as_is_display;\n\n    int i;\n    STRLEN orig_sv_cur = SvCUR(sv);\n\n    SV* invlist;            /* Inversion list we accumulate of code points that\n                               are unconditionally matched */\n    SV* only_utf8 = NULL;   /* Under /d, list of matches iff the target is\n                               UTF-8 */\n    SV* not_utf8 =  NULL;   /* /d, list of matches iff the target isn't UTF-8\n                             */\n    SV* posixes = NULL;     /* Under /l, string of things like [:word:], \\D */\n    SV* only_utf8_locale = NULL;    /* Under /l, list of matches if the locale\n                                       is UTF-8 */\n\n    SV* as_is_display;      /* The output string when we take the inputs\n                               literally */\n    SV* inverted_display;   /* The output string when we invert the inputs */\n\n    U8 flags = (node) ? ANYOF_FLAGS(node) : 0;\n\n    bool invert = cBOOL(flags & ANYOF_INVERT);  /* Is the input to be inverted\n                                                   to match? */\n    /* We are biased in favor of displaying things without them being inverted,\n     * as that is generally easier to understand */\n    const int bias = 5;\n\n    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS;\n\n    /* Start off with whatever code points are passed in.  (We clone, so we\n     * don't change the caller's list) */\n    if (nonbitmap_invlist) {\n        assert(invlist_highest(nonbitmap_invlist) < NUM_ANYOF_CODE_POINTS);\n        invlist = invlist_clone(nonbitmap_invlist, NULL);\n    }\n    else {  /* Worst case size is every other code point is matched */\n        invlist = _new_invlist(NUM_ANYOF_CODE_POINTS / 2);\n    }\n\n    if (flags) {\n        if (OP(node) == ANYOFD) {\n\n            /* This flag indicates that the code points below 0x100 in the\n             * nonbitmap list are precisely the ones that match only when the\n             * target is UTF-8 (they should all be non-ASCII). */\n            if (flags & ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP)\n            {\n                _invlist_intersection(invlist, PL_UpperLatin1, &only_utf8);\n                _invlist_subtract(invlist, only_utf8, &invlist);\n            }\n\n            /* And this flag for matching all non-ASCII 0xFF and below */\n            if (flags & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER)\n            {\n                not_utf8 = invlist_clone(PL_UpperLatin1, NULL);\n            }\n        }\n        else if (OP(node) == ANYOFL || OP(node) == ANYOFPOSIXL) {\n\n            /* If either of these flags are set, what matches isn't\n             * determinable except during execution, so don't know enough here\n             * to invert */\n            if (flags & (ANYOFL_FOLD|ANYOF_MATCHES_POSIXL)) {\n                inverting_allowed = FALSE;\n            }\n\n            /* What the posix classes match also varies at runtime, so these\n             * will be output symbolically. */\n            if (ANYOF_POSIXL_TEST_ANY_SET(node)) {\n                int i;\n\n                posixes = newSVpvs(\"\");\n                for (i = 0; i < ANYOF_POSIXL_MAX; i++) {\n                    if (ANYOF_POSIXL_TEST(node, i)) {\n                        sv_catpv(posixes, anyofs[i]);\n                    }\n                }\n            }\n        }\n    }\n\n    /* Accumulate the bit map into the unconditional match list */\n    if (bitmap) {\n        for (i = 0; i < NUM_ANYOF_CODE_POINTS; i++) {\n            if (BITMAP_TEST(bitmap, i)) {\n                int start = i++;\n                for (;\n                     i < NUM_ANYOF_CODE_POINTS && BITMAP_TEST(bitmap, i);\n                     i++)\n                { /* empty */ }\n                invlist = _add_range_to_invlist(invlist, start, i-1);\n            }\n        }\n    }\n\n    /* Make sure that the conditional match lists don't have anything in them\n     * that match unconditionally; otherwise the output is quite confusing.\n     * This could happen if the code that populates these misses some\n     * duplication. */\n    if (only_utf8) {\n        _invlist_subtract(only_utf8, invlist, &only_utf8);\n    }\n    if (not_utf8) {\n        _invlist_subtract(not_utf8, invlist, &not_utf8);\n    }\n\n    if (only_utf8_locale_invlist) {\n\n        /* Since this list is passed in, we have to make a copy before\n         * modifying it */\n        only_utf8_locale = invlist_clone(only_utf8_locale_invlist, NULL);\n\n        _invlist_subtract(only_utf8_locale, invlist, &only_utf8_locale);\n\n        /* And, it can get really weird for us to try outputting an inverted\n         * form of this list when it has things above the bitmap, so don't even\n         * try */\n        if (invlist_highest(only_utf8_locale) >= NUM_ANYOF_CODE_POINTS) {\n            inverting_allowed = FALSE;\n        }\n    }\n\n    /* Calculate what the output would be if we take the input as-is */\n    as_is_display = put_charclass_bitmap_innards_common(invlist,\n                                                    posixes,\n                                                    only_utf8,\n                                                    not_utf8,\n                                                    only_utf8_locale,\n                                                    invert);\n\n    /* If have to take the output as-is, just do that */\n    if (! inverting_allowed) {\n        if (as_is_display) {\n            sv_catsv(sv, as_is_display);\n            SvREFCNT_dec_NN(as_is_display);\n        }\n    }\n    else { /* But otherwise, create the output again on the inverted input, and\n              use whichever version is shorter */\n\n        int inverted_bias, as_is_bias;\n\n        /* We will apply our bias to whichever of the the results doesn't have\n         * the '^' */\n        if (invert) {\n            invert = FALSE;\n            as_is_bias = bias;\n            inverted_bias = 0;\n        }\n        else {\n            invert = TRUE;\n            as_is_bias = 0;\n            inverted_bias = bias;\n        }\n\n        /* Now invert each of the lists that contribute to the output,\n         * excluding from the result things outside the possible range */\n\n        /* For the unconditional inversion list, we have to add in all the\n         * conditional code points, so that when inverted, they will be gone\n         * from it */\n        _invlist_union(only_utf8, invlist, &invlist);\n        _invlist_union(not_utf8, invlist, &invlist);\n        _invlist_union(only_utf8_locale, invlist, &invlist);\n        _invlist_invert(invlist);\n        _invlist_intersection(invlist, PL_InBitmap, &invlist);\n\n        if (only_utf8) {\n            _invlist_invert(only_utf8);\n            _invlist_intersection(only_utf8, PL_UpperLatin1, &only_utf8);\n        }\n        else if (not_utf8) {\n\n            /* If a code point matches iff the target string is not in UTF-8,\n             * then complementing the result has it not match iff not in UTF-8,\n             * which is the same thing as matching iff it is UTF-8. */\n            only_utf8 = not_utf8;\n            not_utf8 = NULL;\n        }\n\n        if (only_utf8_locale) {\n            _invlist_invert(only_utf8_locale);\n            _invlist_intersection(only_utf8_locale,\n                                  PL_InBitmap,\n                                  &only_utf8_locale);\n        }\n\n        inverted_display = put_charclass_bitmap_innards_common(\n                                            invlist,\n                                            posixes,\n                                            only_utf8,\n                                            not_utf8,\n                                            only_utf8_locale, invert);\n\n        /* Use the shortest representation, taking into account our bias\n         * against showing it inverted */\n        if (   inverted_display\n            && (   ! as_is_display\n                || (  SvCUR(inverted_display) + inverted_bias\n                    < SvCUR(as_is_display)    + as_is_bias)))\n        {\n\t    sv_catsv(sv, inverted_display);\n        }\n        else if (as_is_display) {\n\t    sv_catsv(sv, as_is_display);\n        }\n\n        SvREFCNT_dec(as_is_display);\n        SvREFCNT_dec(inverted_display);\n    }\n\n    SvREFCNT_dec_NN(invlist);\n    SvREFCNT_dec(only_utf8);\n    SvREFCNT_dec(not_utf8);\n    SvREFCNT_dec(posixes);\n    SvREFCNT_dec(only_utf8_locale);\n\n    return SvCUR(sv) > orig_sv_cur;\n}\n\n#define CLEAR_OPTSTART                                                       \\\n    if (optstart) STMT_START {                                               \\\n        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_                                           \\\n                              \" (%\" IVdf \" nodes)\\n\", (IV)(node - optstart))); \\\n        optstart=NULL;                                                       \\\n    } STMT_END\n\n#define DUMPUNTIL(b,e)                                                       \\\n                    CLEAR_OPTSTART;                                          \\\n                    node=dumpuntil(r,start,(b),(e),last,sv,indent+1,depth+1);\n\nSTATIC const regnode *\nS_dumpuntil(pTHX_ const regexp *r, const regnode *start, const regnode *node,\n\t    const regnode *last, const regnode *plast,\n\t    SV* sv, I32 indent, U32 depth)\n{\n    U8 op = PSEUDO;\t/* Arbitrary non-END op. */\n    const regnode *next;\n    const regnode *optstart= NULL;\n\n    RXi_GET_DECL(r, ri);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMPUNTIL;\n\n#ifdef DEBUG_DUMPUNTIL\n    Perl_re_printf( aTHX_  \"--- %d : %d - %d - %d\\n\", indent, node-start,\n        last ? last-start : 0, plast ? plast-start : 0);\n#endif\n\n    if (plast && plast < last)\n        last= plast;\n\n    while (PL_regkind[op] != END && (!last || node < last)) {\n        assert(node);\n\t/* While that wasn't END last time... */\n\tNODE_ALIGN(node);\n\top = OP(node);\n\tif (op == CLOSE || op == SRCLOSE || op == WHILEM)\n\t    indent--;\n\tnext = regnext((regnode *)node);\n\n\t/* Where, what. */\n\tif (OP(node) == OPTIMIZED) {\n\t    if (!optstart && RE_DEBUG_FLAG(RE_DEBUG_COMPILE_OPTIMISE))\n\t        optstart = node;\n\t    else\n\t\tgoto after_print;\n\t} else\n\t    CLEAR_OPTSTART;\n\n        regprop(r, sv, node, NULL, NULL);\n        Perl_re_printf( aTHX_  \"%4\" IVdf \":%*s%s\", (IV)(node - start),\n\t\t      (int)(2*indent + 1), \"\", SvPVX_const(sv));\n\n        if (OP(node) != OPTIMIZED) {\n            if (next == NULL)\t\t/* Next ptr. */\n                Perl_re_printf( aTHX_  \" (0)\");\n            else if (PL_regkind[(U8)op] == BRANCH\n                     && PL_regkind[OP(next)] != BRANCH )\n                Perl_re_printf( aTHX_  \" (FAIL)\");\n            else\n                Perl_re_printf( aTHX_  \" (%\" IVdf \")\", (IV)(next - start));\n            Perl_re_printf( aTHX_ \"\\n\");\n        }\n\n      after_print:\n\tif (PL_regkind[(U8)op] == BRANCHJ) {\n\t    assert(next);\n\t    {\n                const regnode *nnode = (OP(next) == LONGJMP\n                                       ? regnext((regnode *)next)\n                                       : next);\n                if (last && nnode > last)\n                    nnode = last;\n                DUMPUNTIL(NEXTOPER(NEXTOPER(node)), nnode);\n\t    }\n\t}\n\telse if (PL_regkind[(U8)op] == BRANCH) {\n\t    assert(next);\n\t    DUMPUNTIL(NEXTOPER(node), next);\n\t}\n\telse if ( PL_regkind[(U8)op]  == TRIE ) {\n\t    const regnode *this_trie = node;\n\t    const char op = OP(node);\n            const U32 n = ARG(node);\n\t    const reg_ac_data * const ac = op>=AHOCORASICK ?\n               (reg_ac_data *)ri->data->data[n] :\n               NULL;\n\t    const reg_trie_data * const trie =\n\t        (reg_trie_data*)ri->data->data[op<AHOCORASICK ? n : ac->trie];\n#ifdef DEBUGGING\n\t    AV *const trie_words\n                           = MUTABLE_AV(ri->data->data[n + TRIE_WORDS_OFFSET]);\n#endif\n\t    const regnode *nextbranch= NULL;\n\t    I32 word_idx;\n            SvPVCLEAR(sv);\n\t    for (word_idx= 0; word_idx < (I32)trie->wordcount; word_idx++) {\n\t\tSV ** const elem_ptr = av_fetch(trie_words, word_idx, 0);\n\n                Perl_re_indentf( aTHX_  \"%s \",\n                    indent+3,\n                    elem_ptr\n                    ? pv_pretty(sv, SvPV_nolen_const(*elem_ptr),\n                                SvCUR(*elem_ptr), PL_dump_re_max_len,\n                                PL_colors[0], PL_colors[1],\n                                (SvUTF8(*elem_ptr)\n                                 ? PERL_PV_ESCAPE_UNI\n                                 : 0)\n                                | PERL_PV_PRETTY_ELLIPSES\n                                | PERL_PV_PRETTY_LTGT\n                            )\n                    : \"???\"\n                );\n                if (trie->jump) {\n                    U16 dist= trie->jump[word_idx+1];\n                    Perl_re_printf( aTHX_  \"(%\" UVuf \")\\n\",\n                               (UV)((dist ? this_trie + dist : next) - start));\n                    if (dist) {\n                        if (!nextbranch)\n                            nextbranch= this_trie + trie->jump[0];\n\t\t\tDUMPUNTIL(this_trie + dist, nextbranch);\n                    }\n                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n                        nextbranch= regnext((regnode *)nextbranch);\n                } else {\n                    Perl_re_printf( aTHX_  \"\\n\");\n\t\t}\n\t    }\n\t    if (last && next > last)\n\t        node= last;\n\t    else\n\t        node= next;\n\t}\n\telse if ( op == CURLY ) {   /* \"next\" might be very big: optimizer */\n\t    DUMPUNTIL(NEXTOPER(node) + EXTRA_STEP_2ARGS,\n                    NEXTOPER(node) + EXTRA_STEP_2ARGS + 1);\n\t}\n\telse if (PL_regkind[(U8)op] == CURLY && op != CURLYX) {\n\t    assert(next);\n\t    DUMPUNTIL(NEXTOPER(node) + EXTRA_STEP_2ARGS, next);\n\t}\n\telse if ( op == PLUS || op == STAR) {\n\t    DUMPUNTIL(NEXTOPER(node), NEXTOPER(node) + 1);\n\t}\n\telse if (PL_regkind[(U8)op] == EXACT) {\n            /* Literal string, where present. */\n\t    node += NODE_SZ_STR(node) - 1;\n\t    node = NEXTOPER(node);\n\t}\n\telse {\n\t    node = NEXTOPER(node);\n\t    node += regarglen[(U8)op];\n\t}\n\tif (op == CURLYX || op == OPEN || op == SROPEN)\n\t    indent++;\n    }\n    CLEAR_OPTSTART;\n#ifdef DEBUG_DUMPUNTIL\n    Perl_re_printf( aTHX_  \"--- %d\\n\", (int)indent);\n#endif\n    return node;\n}\n\n#endif\t/* DEBUGGING */\n\n#ifndef PERL_IN_XSUB_RE\n\n#include \"uni_keywords.h\"\n\nvoid\nPerl_init_uniprops(pTHX)\n{\n    dVAR;\n\n    PL_user_def_props = newHV();\n\n#ifdef USE_ITHREADS\n\n    HvSHAREKEYS_off(PL_user_def_props);\n    PL_user_def_props_aTHX = aTHX;\n\n#endif\n\n    /* Set up the inversion list global variables */\n\n    PL_XPosix_ptrs[_CC_ASCII] = _new_invlist_C_array(uni_prop_ptrs[UNI_ASCII]);\n    PL_XPosix_ptrs[_CC_ALPHANUMERIC] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXALNUM]);\n    PL_XPosix_ptrs[_CC_ALPHA] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXALPHA]);\n    PL_XPosix_ptrs[_CC_BLANK] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXBLANK]);\n    PL_XPosix_ptrs[_CC_CASED] =  _new_invlist_C_array(uni_prop_ptrs[UNI_CASED]);\n    PL_XPosix_ptrs[_CC_CNTRL] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXCNTRL]);\n    PL_XPosix_ptrs[_CC_DIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXDIGIT]);\n    PL_XPosix_ptrs[_CC_GRAPH] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXGRAPH]);\n    PL_XPosix_ptrs[_CC_LOWER] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXLOWER]);\n    PL_XPosix_ptrs[_CC_PRINT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXPRINT]);\n    PL_XPosix_ptrs[_CC_PUNCT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXPUNCT]);\n    PL_XPosix_ptrs[_CC_SPACE] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXSPACE]);\n    PL_XPosix_ptrs[_CC_UPPER] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXUPPER]);\n    PL_XPosix_ptrs[_CC_VERTSPACE] = _new_invlist_C_array(uni_prop_ptrs[UNI_VERTSPACE]);\n    PL_XPosix_ptrs[_CC_WORDCHAR] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXWORD]);\n    PL_XPosix_ptrs[_CC_XDIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXXDIGIT]);\n\n    PL_Posix_ptrs[_CC_ASCII] = _new_invlist_C_array(uni_prop_ptrs[UNI_ASCII]);\n    PL_Posix_ptrs[_CC_ALPHANUMERIC] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXALNUM]);\n    PL_Posix_ptrs[_CC_ALPHA] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXALPHA]);\n    PL_Posix_ptrs[_CC_BLANK] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXBLANK]);\n    PL_Posix_ptrs[_CC_CASED] = PL_Posix_ptrs[_CC_ALPHA];\n    PL_Posix_ptrs[_CC_CNTRL] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXCNTRL]);\n    PL_Posix_ptrs[_CC_DIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXDIGIT]);\n    PL_Posix_ptrs[_CC_GRAPH] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXGRAPH]);\n    PL_Posix_ptrs[_CC_LOWER] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXLOWER]);\n    PL_Posix_ptrs[_CC_PRINT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXPRINT]);\n    PL_Posix_ptrs[_CC_PUNCT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXPUNCT]);\n    PL_Posix_ptrs[_CC_SPACE] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXSPACE]);\n    PL_Posix_ptrs[_CC_UPPER] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXUPPER]);\n    PL_Posix_ptrs[_CC_VERTSPACE] = NULL;\n    PL_Posix_ptrs[_CC_WORDCHAR] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXWORD]);\n    PL_Posix_ptrs[_CC_XDIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXXDIGIT]);\n\n    PL_GCB_invlist = _new_invlist_C_array(_Perl_GCB_invlist);\n    PL_SB_invlist = _new_invlist_C_array(_Perl_SB_invlist);\n    PL_WB_invlist = _new_invlist_C_array(_Perl_WB_invlist);\n    PL_LB_invlist = _new_invlist_C_array(_Perl_LB_invlist);\n    PL_SCX_invlist = _new_invlist_C_array(_Perl_SCX_invlist);\n\n    PL_AboveLatin1 = _new_invlist_C_array(AboveLatin1_invlist);\n    PL_Latin1 = _new_invlist_C_array(Latin1_invlist);\n    PL_UpperLatin1 = _new_invlist_C_array(UpperLatin1_invlist);\n\n    PL_Assigned_invlist = _new_invlist_C_array(uni_prop_ptrs[UNI_ASSIGNED]);\n\n    PL_utf8_perl_idstart = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_IDSTART]);\n    PL_utf8_perl_idcont = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_IDCONT]);\n\n    PL_utf8_charname_begin = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_CHARNAME_BEGIN]);\n    PL_utf8_charname_continue = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_CHARNAME_CONTINUE]);\n\n    PL_in_some_fold = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_ANY_FOLDS]);\n    PL_HasMultiCharFold = _new_invlist_C_array(uni_prop_ptrs[\n                                            UNI__PERL_FOLDS_TO_MULTI_CHAR]);\n    PL_InMultiCharFold = _new_invlist_C_array(uni_prop_ptrs[\n                                            UNI__PERL_IS_IN_MULTI_CHAR_FOLD]);\n    PL_NonFinalFold = _new_invlist_C_array(uni_prop_ptrs[\n                                            UNI__PERL_NON_FINAL_FOLDS]);\n\n    PL_utf8_toupper = _new_invlist_C_array(Uppercase_Mapping_invlist);\n    PL_utf8_tolower = _new_invlist_C_array(Lowercase_Mapping_invlist);\n    PL_utf8_totitle = _new_invlist_C_array(Titlecase_Mapping_invlist);\n    PL_utf8_tofold = _new_invlist_C_array(Case_Folding_invlist);\n    PL_utf8_tosimplefold = _new_invlist_C_array(Simple_Case_Folding_invlist);\n    PL_utf8_foldclosures = _new_invlist_C_array(_Perl_IVCF_invlist);\n    PL_utf8_mark = _new_invlist_C_array(uni_prop_ptrs[UNI_M]);\n    PL_CCC_non0_non230 = _new_invlist_C_array(_Perl_CCC_non0_non230_invlist);\n    PL_Private_Use = _new_invlist_C_array(uni_prop_ptrs[UNI_CO]);\n\n#ifdef UNI_XIDC\n    /* The below are used only by deprecated functions.  They could be removed */\n    PL_utf8_xidcont  = _new_invlist_C_array(uni_prop_ptrs[UNI_XIDC]);\n    PL_utf8_idcont   = _new_invlist_C_array(uni_prop_ptrs[UNI_IDC]);\n    PL_utf8_xidstart = _new_invlist_C_array(uni_prop_ptrs[UNI_XIDS]);\n#endif\n}\n\n#if 0\n\nThis code was mainly added for backcompat to give a warning for non-portable\ncode points in user-defined properties.  But experiments showed that the\nwarning in earlier perls were only omitted on overflow, which should be an\nerror, so there really isnt a backcompat issue, and actually adding the\nwarning when none was present before might cause breakage, for little gain.  So\nkhw left this code in, but not enabled.  Tests were never added.\n\nembed.fnc entry:\nEi\t|const char *|get_extended_utf8_msg|const UV cp\n\nPERL_STATIC_INLINE const char *\nS_get_extended_utf8_msg(pTHX_ const UV cp)\n{\n    U8 dummy[UTF8_MAXBYTES + 1];\n    HV *msgs;\n    SV **msg;\n\n    uvchr_to_utf8_flags_msgs(dummy, cp, UNICODE_WARN_PERL_EXTENDED,\n                             &msgs);\n\n    msg = hv_fetchs(msgs, \"text\", 0);\n    assert(msg);\n\n    (void) sv_2mortal((SV *) msgs);\n\n    return SvPVX(*msg);\n}\n\n#endif\n\nSV *\nPerl_handle_user_defined_property(pTHX_\n\n    /* Parses the contents of a user-defined property definition; returning the\n     * expanded definition if possible.  If so, the return is an inversion\n     * list.\n     *\n     * If there are subroutines that are part of the expansion and which aren't\n     * known at the time of the call to this function, this returns what\n     * parse_uniprop_string() returned for the first one encountered.\n     *\n     * If an error was found, NULL is returned, and 'msg' gets a suitable\n     * message appended to it.  (Appending allows the back trace of how we got\n     * to the faulty definition to be displayed through nested calls of\n     * user-defined subs.)\n     *\n     * The caller IS responsible for freeing any returned SV.\n     *\n     * The syntax of the contents is pretty much described in perlunicode.pod,\n     * but we also allow comments on each line */\n\n    const char * name,          /* Name of property */\n    const STRLEN name_len,      /* The name's length in bytes */\n    const bool is_utf8,         /* ? Is 'name' encoded in UTF-8 */\n    const bool to_fold,         /* ? Is this under /i */\n    const bool runtime,         /* ? Are we in compile- or run-time */\n    const bool deferrable,      /* Is it ok for this property's full definition\n                                   to be deferred until later? */\n    SV* contents,               /* The property's definition */\n    bool *user_defined_ptr,     /* This will be set TRUE as we wouldn't be\n                                   getting called unless this is thought to be\n                                   a user-defined property */\n    SV * msg,                   /* Any error or warning msg(s) are appended to\n                                   this */\n    const STRLEN level)         /* Recursion level of this call */\n{\n    STRLEN len;\n    const char * string         = SvPV_const(contents, len);\n    const char * const e        = string + len;\n    const bool is_contents_utf8 = cBOOL(SvUTF8(contents));\n    const STRLEN msgs_length_on_entry = SvCUR(msg);\n\n    const char * s0 = string;   /* Points to first byte in the current line\n                                   being parsed in 'string' */\n    const char overflow_msg[] = \"Code point too large in \\\"\";\n    SV* running_definition = NULL;\n\n    PERL_ARGS_ASSERT_HANDLE_USER_DEFINED_PROPERTY;\n\n    *user_defined_ptr = TRUE;\n\n    /* Look at each line */\n    while (s0 < e) {\n        const char * s;     /* Current byte */\n        char op = '+';      /* Default operation is 'union' */\n        IV   min = 0;       /* range begin code point */\n        IV   max = -1;      /* and range end */\n        SV* this_definition;\n\n        /* Skip comment lines */\n        if (*s0 == '#') {\n            s0 = strchr(s0, '\\n');\n            if (s0 == NULL) {\n                break;\n            }\n            s0++;\n            continue;\n        }\n\n        /* For backcompat, allow an empty first line */\n        if (*s0 == '\\n') {\n            s0++;\n            continue;\n        }\n\n        /* First character in the line may optionally be the operation */\n        if (   *s0 == '+'\n            || *s0 == '!'\n            || *s0 == '-'\n            || *s0 == '&')\n        {\n            op = *s0++;\n        }\n\n        /* If the line is one or two hex digits separated by blank space, its\n         * a range; otherwise it is either another user-defined property or an\n         * error */\n\n        s = s0;\n\n        if (! isXDIGIT(*s)) {\n            goto check_if_property;\n        }\n\n        do { /* Each new hex digit will add 4 bits. */\n            if (min > ( (IV) MAX_LEGAL_CP >> 4)) {\n                s = strchr(s, '\\n');\n                if (s == NULL) {\n                    s = e;\n                }\n                if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                sv_catpv(msg, overflow_msg);\n                Perl_sv_catpvf(aTHX_ msg, \"%\" UTF8f,\n                                     UTF8fARG(is_contents_utf8, s - s0, s0));\n                sv_catpvs(msg, \"\\\"\");\n                goto return_failure;\n            }\n\n            /* Accumulate this digit into the value */\n            min = (min << 4) + READ_XDIGIT(s);\n        } while (isXDIGIT(*s));\n\n        while (isBLANK(*s)) { s++; }\n\n        /* We allow comments at the end of the line */\n        if (*s == '#') {\n            s = strchr(s, '\\n');\n            if (s == NULL) {\n                s = e;\n            }\n            s++;\n        }\n        else if (s < e && *s != '\\n') {\n            if (! isXDIGIT(*s)) {\n                goto check_if_property;\n            }\n\n            /* Look for the high point of the range */\n            max = 0;\n            do {\n                if (max > ( (IV) MAX_LEGAL_CP >> 4)) {\n                    s = strchr(s, '\\n');\n                    if (s == NULL) {\n                        s = e;\n                    }\n                    if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                    sv_catpv(msg, overflow_msg);\n                    Perl_sv_catpvf(aTHX_ msg, \"%\" UTF8f,\n                                      UTF8fARG(is_contents_utf8, s - s0, s0));\n                    sv_catpvs(msg, \"\\\"\");\n                    goto return_failure;\n                }\n\n                max = (max << 4) + READ_XDIGIT(s);\n            } while (isXDIGIT(*s));\n\n            while (isBLANK(*s)) { s++; }\n\n            if (*s == '#') {\n                s = strchr(s, '\\n');\n                if (s == NULL) {\n                    s = e;\n                }\n            }\n            else if (s < e && *s != '\\n') {\n                goto check_if_property;\n            }\n        }\n\n        if (max == -1) {    /* The line only had one entry */\n            max = min;\n        }\n        else if (max < min) {\n            if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n            sv_catpvs(msg, \"Illegal range in \\\"\");\n            Perl_sv_catpvf(aTHX_ msg, \"%\" UTF8f,\n                                UTF8fARG(is_contents_utf8, s - s0, s0));\n            sv_catpvs(msg, \"\\\"\");\n            goto return_failure;\n        }\n\n#if 0   /* See explanation at definition above of get_extended_utf8_msg() */\n\n        if (   UNICODE_IS_PERL_EXTENDED(min)\n            || UNICODE_IS_PERL_EXTENDED(max))\n        {\n            if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n\n            /* If both code points are non-portable, warn only on the lower\n             * one. */\n            sv_catpv(msg, get_extended_utf8_msg(\n                                            (UNICODE_IS_PERL_EXTENDED(min))\n                                            ? min : max));\n            sv_catpvs(msg, \" in \\\"\");\n            Perl_sv_catpvf(aTHX_ msg, \"%\" UTF8f,\n                                 UTF8fARG(is_contents_utf8, s - s0, s0));\n            sv_catpvs(msg, \"\\\"\");\n        }\n\n#endif\n\n        /* Here, this line contains a legal range */\n        this_definition = sv_2mortal(_new_invlist(2));\n        this_definition = _add_range_to_invlist(this_definition, min, max);\n        goto calculate;\n\n      check_if_property:\n\n        /* Here it isn't a legal range line.  See if it is a legal property\n         * line.  First find the end of the meat of the line */\n        s = strpbrk(s, \"#\\n\");\n        if (s == NULL) {\n            s = e;\n        }\n\n        /* Ignore trailing blanks in keeping with the requirements of\n         * parse_uniprop_string() */\n        s--;\n        while (s > s0 && isBLANK_A(*s)) {\n            s--;\n        }\n        s++;\n\n        this_definition = parse_uniprop_string(s0, s - s0,\n                                               is_utf8, to_fold, runtime,\n                                               deferrable,\n                                               user_defined_ptr, msg,\n                                               (name_len == 0)\n                                                ? level /* Don't increase level\n                                                           if input is empty */\n                                                : level + 1\n                                              );\n        if (this_definition == NULL) {\n            goto return_failure;    /* 'msg' should have had the reason\n                                       appended to it by the above call */\n        }\n\n        if (! is_invlist(this_definition)) {    /* Unknown at this time */\n            return newSVsv(this_definition);\n        }\n\n        if (*s != '\\n') {\n            s = strchr(s, '\\n');\n            if (s == NULL) {\n                s = e;\n            }\n        }\n\n      calculate:\n\n        switch (op) {\n            case '+':\n                _invlist_union(running_definition, this_definition,\n                                                        &running_definition);\n                break;\n            case '-':\n                _invlist_subtract(running_definition, this_definition,\n                                                        &running_definition);\n                break;\n            case '&':\n                _invlist_intersection(running_definition, this_definition,\n                                                        &running_definition);\n                break;\n            case '!':\n                _invlist_union_complement_2nd(running_definition,\n                                        this_definition, &running_definition);\n                break;\n            default:\n                Perl_croak(aTHX_ \"panic: %s: %d: Unexpected operation %d\",\n                                 __FILE__, __LINE__, op);\n                break;\n        }\n\n        /* Position past the '\\n' */\n        s0 = s + 1;\n    }   /* End of loop through the lines of 'contents' */\n\n    /* Here, we processed all the lines in 'contents' without error.  If we\n     * didn't add any warnings, simply return success */\n    if (msgs_length_on_entry == SvCUR(msg)) {\n\n        /* If the expansion was empty, the answer isn't nothing: its an empty\n         * inversion list */\n        if (running_definition == NULL) {\n            running_definition = _new_invlist(1);\n        }\n\n        return running_definition;\n    }\n\n    /* Otherwise, add some explanatory text, but we will return success */\n    goto return_msg;\n\n  return_failure:\n    running_definition = NULL;\n\n  return_msg:\n\n    if (name_len > 0) {\n        sv_catpvs(msg, \" in expansion of \");\n        Perl_sv_catpvf(aTHX_ msg, \"%\" UTF8f, UTF8fARG(is_utf8, name_len, name));\n    }\n\n    return running_definition;\n}\n\n/* As explained below, certain operations need to take place in the first\n * thread created.  These macros switch contexts */\n#ifdef USE_ITHREADS\n#  define DECLARATION_FOR_GLOBAL_CONTEXT                                    \\\n                                        PerlInterpreter * save_aTHX = aTHX;\n#  define SWITCH_TO_GLOBAL_CONTEXT                                          \\\n                           PERL_SET_CONTEXT((aTHX = PL_user_def_props_aTHX))\n#  define RESTORE_CONTEXT  PERL_SET_CONTEXT((aTHX = save_aTHX));\n#  define CUR_CONTEXT      aTHX\n#  define ORIGINAL_CONTEXT save_aTHX\n#else\n#  define DECLARATION_FOR_GLOBAL_CONTEXT\n#  define SWITCH_TO_GLOBAL_CONTEXT          NOOP\n#  define RESTORE_CONTEXT                   NOOP\n#  define CUR_CONTEXT                       NULL\n#  define ORIGINAL_CONTEXT                  NULL\n#endif\n\nSTATIC void\nS_delete_recursion_entry(pTHX_ void *key)\n{\n    /* Deletes the entry used to detect recursion when expanding user-defined\n     * properties.  This is a function so it can be set up to be called even if\n     * the program unexpectedly quits */\n\n    dVAR;\n    SV ** current_entry;\n    const STRLEN key_len = strlen((const char *) key);\n    DECLARATION_FOR_GLOBAL_CONTEXT;\n\n    SWITCH_TO_GLOBAL_CONTEXT;\n\n    /* If the entry is one of these types, it is a permanent entry, and not the\n     * one used to detect recursions.  This function should delete only the\n     * recursion entry */\n    current_entry = hv_fetch(PL_user_def_props, (const char *) key, key_len, 0);\n    if (     current_entry\n        && ! is_invlist(*current_entry)\n        && ! SvPOK(*current_entry))\n    {\n        (void) hv_delete(PL_user_def_props, (const char *) key, key_len,\n                                                                    G_DISCARD);\n    }\n\n    RESTORE_CONTEXT;\n}\n\nSTATIC SV *\nS_get_fq_name(pTHX_\n              const char * const name,    /* The first non-blank in the \\p{}, \\P{} */\n              const Size_t name_len,      /* Its length in bytes, not including any trailing space */\n              const bool is_utf8,         /* ? Is 'name' encoded in UTF-8 */\n              const bool has_colon_colon\n             )\n{\n    /* Returns a mortal SV containing the fully qualified version of the input\n     * name */\n\n    SV * fq_name;\n\n    fq_name = newSVpvs_flags(\"\", SVs_TEMP);\n\n    /* Use the current package if it wasn't included in our input */\n    if (! has_colon_colon) {\n        const HV * pkg = (IN_PERL_COMPILETIME)\n                         ? PL_curstash\n                         : CopSTASH(PL_curcop);\n        const char* pkgname = HvNAME(pkg);\n\n        Perl_sv_catpvf(aTHX_ fq_name, \"%\" UTF8f,\n                      UTF8fARG(is_utf8, strlen(pkgname), pkgname));\n        sv_catpvs(fq_name, \"::\");\n    }\n\n    Perl_sv_catpvf(aTHX_ fq_name, \"%\" UTF8f,\n                         UTF8fARG(is_utf8, name_len, name));\n    return fq_name;\n}\n\nSV *\nPerl_parse_uniprop_string(pTHX_\n\n    /* Parse the interior of a \\p{}, \\P{}.  Returns its definition if knowable\n     * now.  If so, the return is an inversion list.\n     *\n     * If the property is user-defined, it is a subroutine, which in turn\n     * may call other subroutines.  This function will call the whole nest of\n     * them to get the definition they return; if some aren't known at the time\n     * of the call to this function, the fully qualified name of the highest\n     * level sub is returned.  It is an error to call this function at runtime\n     * without every sub defined.\n     *\n     * If an error was found, NULL is returned, and 'msg' gets a suitable\n     * message appended to it.  (Appending allows the back trace of how we got\n     * to the faulty definition to be displayed through nested calls of\n     * user-defined subs.)\n     *\n     * The caller should NOT try to free any returned inversion list.\n     *\n     * Other parameters will be set on return as described below */\n\n    const char * const name,    /* The first non-blank in the \\p{}, \\P{} */\n    const Size_t name_len,      /* Its length in bytes, not including any\n                                   trailing space */\n    const bool is_utf8,         /* ? Is 'name' encoded in UTF-8 */\n    const bool to_fold,         /* ? Is this under /i */\n    const bool runtime,         /* TRUE if this is being called at run time */\n    const bool deferrable,      /* TRUE if it's ok for the definition to not be\n                                   known at this call */\n    bool *user_defined_ptr,     /* Upon return from this function it will be\n                                   set to TRUE if any component is a\n                                   user-defined property */\n    SV * msg,                   /* Any error or warning msg(s) are appended to\n                                   this */\n   const STRLEN level)          /* Recursion level of this call */\n{\n    dVAR;\n    char* lookup_name;          /* normalized name for lookup in our tables */\n    unsigned lookup_len;        /* Its length */\n    bool stricter = FALSE;      /* Some properties have stricter name\n                                   normalization rules, which we decide upon\n                                   based on parsing */\n\n    /* nv= or numeric_value=, or possibly one of the cjk numeric properties\n     * (though it requires extra effort to download them from Unicode and\n     * compile perl to know about them) */\n    bool is_nv_type = FALSE;\n\n    unsigned int i, j = 0;\n    int equals_pos = -1;    /* Where the '=' is found, or negative if none */\n    int slash_pos  = -1;    /* Where the '/' is found, or negative if none */\n    int table_index = 0;    /* The entry number for this property in the table\n                               of all Unicode property names */\n    bool starts_with_In_or_Is = FALSE;  /* ? Does the name start with 'In' or\n                                             'Is' */\n    Size_t lookup_offset = 0;   /* Used to ignore the first few characters of\n                                   the normalized name in certain situations */\n    Size_t non_pkg_begin = 0;   /* Offset of first byte in 'name' that isn't\n                                   part of a package name */\n    bool could_be_user_defined = TRUE;  /* ? Could this be a user-defined\n                                             property rather than a Unicode\n                                             one. */\n    SV * prop_definition = NULL;  /* The returned definition of 'name' or NULL\n                                     if an error.  If it is an inversion list,\n                                     it is the definition.  Otherwise it is a\n                                     string containing the fully qualified sub\n                                     name of 'name' */\n    SV * fq_name = NULL;        /* For user-defined properties, the fully\n                                   qualified name */\n    bool invert_return = FALSE; /* ? Do we need to complement the result before\n                                     returning it */\n\n    PERL_ARGS_ASSERT_PARSE_UNIPROP_STRING;\n\n    /* The input will be normalized into 'lookup_name' */\n    Newx(lookup_name, name_len, char);\n    SAVEFREEPV(lookup_name);\n\n    /* Parse the input. */\n    for (i = 0; i < name_len; i++) {\n        char cur = name[i];\n\n        /* Most of the characters in the input will be of this ilk, being parts\n         * of a name */\n        if (isIDCONT_A(cur)) {\n\n            /* Case differences are ignored.  Our lookup routine assumes\n             * everything is lowercase, so normalize to that */\n            if (isUPPER_A(cur)) {\n                lookup_name[j++] = toLOWER_A(cur);\n                continue;\n            }\n\n            if (cur == '_') { /* Don't include these in the normalized name */\n                continue;\n            }\n\n            lookup_name[j++] = cur;\n\n            /* The first character in a user-defined name must be of this type.\n             * */\n            if (i - non_pkg_begin == 0 && ! isIDFIRST_A(cur)) {\n                could_be_user_defined = FALSE;\n            }\n\n            continue;\n        }\n\n        /* Here, the character is not something typically in a name,  But these\n         * two types of characters (and the '_' above) can be freely ignored in\n         * most situations.  Later it may turn out we shouldn't have ignored\n         * them, and we have to reparse, but we don't have enough information\n         * yet to make that decision */\n        if (cur == '-' || isSPACE_A(cur)) {\n            could_be_user_defined = FALSE;\n            continue;\n        }\n\n        /* An equals sign or single colon mark the end of the first part of\n         * the property name */\n        if (    cur == '='\n            || (cur == ':' && (i >= name_len - 1 || name[i+1] != ':')))\n        {\n            lookup_name[j++] = '='; /* Treat the colon as an '=' */\n            equals_pos = j; /* Note where it occurred in the input */\n            could_be_user_defined = FALSE;\n            break;\n        }\n\n        /* Otherwise, this character is part of the name. */\n        lookup_name[j++] = cur;\n\n        /* Here it isn't a single colon, so if it is a colon, it must be a\n         * double colon */\n        if (cur == ':') {\n\n            /* A double colon should be a package qualifier.  We note its\n             * position and continue.  Note that one could have\n             *      pkg1::pkg2::...::foo\n             * so that the position at the end of the loop will be just after\n             * the final qualifier */\n\n            i++;\n            non_pkg_begin = i + 1;\n            lookup_name[j++] = ':';\n        }\n        else { /* Only word chars (and '::') can be in a user-defined name */\n            could_be_user_defined = FALSE;\n        }\n    } /* End of parsing through the lhs of the property name (or all of it if\n         no rhs) */\n\n#define STRLENs(s)  (sizeof(\"\" s \"\") - 1)\n\n    /* If there is a single package name 'utf8::', it is ambiguous.  It could\n     * be for a user-defined property, or it could be a Unicode property, as\n     * all of them are considered to be for that package.  For the purposes of\n     * parsing the rest of the property, strip it off */\n    if (non_pkg_begin == STRLENs(\"utf8::\") && memBEGINPs(name, name_len, \"utf8::\")) {\n        lookup_name +=  STRLENs(\"utf8::\");\n        j -=  STRLENs(\"utf8::\");\n        equals_pos -=  STRLENs(\"utf8::\");\n    }\n\n    /* Here, we are either done with the whole property name, if it was simple;\n     * or are positioned just after the '=' if it is compound. */\n\n    if (equals_pos >= 0) {\n        assert(! stricter); /* We shouldn't have set this yet */\n\n        /* Space immediately after the '=' is ignored */\n        i++;\n        for (; i < name_len; i++) {\n            if (! isSPACE_A(name[i])) {\n                break;\n            }\n        }\n\n        /* Most punctuation after the equals indicates a subpattern, like\n         * \\p{foo=/bar/} */\n        if (   isPUNCT_A(name[i])\n            && name[i] != '-'\n            && name[i] != '+'\n            && name[i] != '_'\n            && name[i] != '{')\n        {\n            /* Find the property.  The table includes the equals sign, so we\n             * use 'j' as-is */\n            table_index = match_uniprop((U8 *) lookup_name, j);\n            if (table_index) {\n                const char * const * prop_values\n                                            = UNI_prop_value_ptrs[table_index];\n                SV * subpattern;\n                Size_t subpattern_len;\n                REGEXP * subpattern_re;\n                char open = name[i++];\n                char close;\n                const char * pos_in_brackets;\n                bool escaped = 0;\n\n                /* A backslash means the real delimitter is the next character.\n                 * */\n                if (open == '\\\\') {\n                    open = name[i++];\n                    escaped = 1;\n                }\n\n                /* This data structure is constructed so that the matching\n                 * closing bracket is 3 past its matching opening.  The second\n                 * set of closing is so that if the opening is something like\n                 * ']', the closing will be that as well.  Something similar is\n                 * done in toke.c */\n                pos_in_brackets = strchr(\"([<)]>)]>\", open);\n                close = (pos_in_brackets) ? pos_in_brackets[3] : open;\n\n                if (    i >= name_len\n                    ||  name[name_len-1] != close\n                    || (escaped && name[name_len-2] != '\\\\'))\n                {\n                    sv_catpvs(msg, \"Unicode property wildcard not terminated\");\n                    goto append_name_to_msg;\n                }\n\n                Perl_ck_warner_d(aTHX_\n                    packWARN(WARN_EXPERIMENTAL__UNIPROP_WILDCARDS),\n                    \"The Unicode property wildcards feature is experimental\");\n\n                /* Now create and compile the wildcard subpattern.  Use /iaa\n                 * because nothing outside of ASCII will match, and it the\n                 * property values should all match /i.  Note that when the\n                 * pattern fails to compile, our added text to the user's\n                 * pattern will be displayed to the user, which is not so\n                 * desirable. */\n                subpattern_len = name_len - i - 1 - escaped;\n                subpattern = Perl_newSVpvf(aTHX_ \"(?iaa:%.*s)\",\n                                              (unsigned) subpattern_len,\n                                              name + i);\n                subpattern = sv_2mortal(subpattern);\n                subpattern_re = re_compile(subpattern, 0);\n                assert(subpattern_re);  /* Should have died if didn't compile\n                                         successfully */\n\n                /* For each legal property value, see if the supplied pattern\n                 * matches it. */\n                while (*prop_values) {\n                    const char * const entry = *prop_values;\n                    const Size_t len = strlen(entry);\n                    SV* entry_sv = newSVpvn_flags(entry, len, SVs_TEMP);\n\n                    if (pregexec(subpattern_re,\n                                 (char *) entry,\n                                 (char *) entry + len,\n                                 (char *) entry, 0,\n                                 entry_sv,\n                                 0))\n                    { /* Here, matched.  Add to the returned list */\n                        Size_t total_len = j + len;\n                        SV * sub_invlist = NULL;\n                        char * this_string;\n\n                        /* We know this is a legal \\p{property=value}.  Call\n                         * the function to return the list of code points that\n                         * match it */\n                        Newxz(this_string, total_len + 1, char);\n                        Copy(lookup_name, this_string, j, char);\n                        my_strlcat(this_string, entry, total_len + 1);\n                        SAVEFREEPV(this_string);\n                        sub_invlist = parse_uniprop_string(this_string,\n                                                           total_len,\n                                                           is_utf8,\n                                                           to_fold,\n                                                           runtime,\n                                                           deferrable,\n                                                           user_defined_ptr,\n                                                           msg,\n                                                           level + 1);\n                        _invlist_union(prop_definition, sub_invlist,\n                                       &prop_definition);\n                    }\n\n                    prop_values++;  /* Next iteration, look at next propvalue */\n                } /* End of looking through property values; (the data\n                     structure is terminated by a NULL ptr) */\n\n                SvREFCNT_dec_NN(subpattern_re);\n\n                if (prop_definition) {\n                    return prop_definition;\n                }\n\n                sv_catpvs(msg, \"No Unicode property value wildcard matches:\");\n                goto append_name_to_msg;\n            }\n\n            /* Here's how khw thinks we should proceed to handle the properties\n             * not yet done:    Bidi Mirroring Glyph\n                                Bidi Paired Bracket\n                                Case Folding  (both full and simple)\n                                Decomposition Mapping\n                                Equivalent Unified Ideograph\n                                Name\n                                Name Alias\n                                Lowercase Mapping  (both full and simple)\n                                NFKC Case Fold\n                                Titlecase Mapping  (both full and simple)\n                                Uppercase Mapping  (both full and simple)\n             * Move the part that looks at the property values into a perl\n             * script, like utf8_heavy.pl is done.  This makes things somewhat\n             * easier, but most importantly, it avoids always adding all these\n             * strings to the memory usage when the feature is little-used.\n             *\n             * The property values would all be concatenated into a single\n             * string per property with each value on a separate line, and the\n             * code point it's for on alternating lines.  Then we match the\n             * user's input pattern m//mg, without having to worry about their\n             * uses of '^' and '$'.  Only the values that aren't the default\n             * would be in the strings.  Code points would be in UTF-8.  The\n             * search pattern that we would construct would look like\n             * (?: \\n (code-point_re) \\n (?aam: user-re ) \\n )\n             * And so $1 would contain the code point that matched the user-re.\n             * For properties where the default is the code point itself, such\n             * as any of the case changing mappings, the string would otherwise\n             * consist of all Unicode code points in UTF-8 strung together.\n             * This would be impractical.  So instead, examine their compiled\n             * pattern, looking at the ssc.  If none, reject the pattern as an\n             * error.  Otherwise run the pattern against every code point in\n             * the ssc.  The ssc is kind of like tr18's 3.9 Possible Match Sets\n             * And it might be good to create an API to return the ssc.\n             *\n             * For the name properties, a new function could be created in\n             * charnames which essentially does the same thing as above,\n             * sharing Name.pl with the other charname functions.  Don't know\n             * about loose name matching, or algorithmically determined names.\n             * Decomposition.pl similarly.\n             *\n             * It might be that a new pattern modifier would have to be\n             * created, like /t for resTricTed, which changed the behavior of\n             * some constructs in their subpattern, like \\A. */\n        } /* End of is a wildcard subppattern */\n\n\n        /* Certain properties whose values are numeric need special handling.\n         * They may optionally be prefixed by 'is'.  Ignore that prefix for the\n         * purposes of checking if this is one of those properties */\n        if (memBEGINPs(lookup_name, j, \"is\")) {\n            lookup_offset = 2;\n        }\n\n        /* Then check if it is one of these specially-handled properties.  The\n         * possibilities are hard-coded because easier this way, and the list\n         * is unlikely to change.\n         *\n         * All numeric value type properties are of this ilk, and are also\n         * special in a different way later on.  So find those first.  There\n         * are several numeric value type properties in the Unihan DB (which is\n         * unlikely to be compiled with perl, but we handle it here in case it\n         * does get compiled).  They all end with 'numeric'.  The interiors\n         * aren't checked for the precise property.  This would stop working if\n         * a cjk property were to be created that ended with 'numeric' and\n         * wasn't a numeric type */\n        is_nv_type = memEQs(lookup_name + lookup_offset,\n                       j - 1 - lookup_offset, \"numericvalue\")\n                  || memEQs(lookup_name + lookup_offset,\n                      j - 1 - lookup_offset, \"nv\")\n                  || (   memENDPs(lookup_name + lookup_offset,\n                            j - 1 - lookup_offset, \"numeric\")\n                      && (   memBEGINPs(lookup_name + lookup_offset,\n                                      j - 1 - lookup_offset, \"cjk\")\n                          || memBEGINPs(lookup_name + lookup_offset,\n                                      j - 1 - lookup_offset, \"k\")));\n        if (   is_nv_type\n            || memEQs(lookup_name + lookup_offset,\n                      j - 1 - lookup_offset, \"canonicalcombiningclass\")\n            || memEQs(lookup_name + lookup_offset,\n                      j - 1 - lookup_offset, \"ccc\")\n            || memEQs(lookup_name + lookup_offset,\n                      j - 1 - lookup_offset, \"age\")\n            || memEQs(lookup_name + lookup_offset,\n                      j - 1 - lookup_offset, \"in\")\n            || memEQs(lookup_name + lookup_offset,\n                      j - 1 - lookup_offset, \"presentin\"))\n        {\n            unsigned int k;\n\n            /* Since the stuff after the '=' is a number, we can't throw away\n             * '-' willy-nilly, as those could be a minus sign.  Other stricter\n             * rules also apply.  However, these properties all can have the\n             * rhs not be a number, in which case they contain at least one\n             * alphabetic.  In those cases, the stricter rules don't apply.\n             * But the numeric type properties can have the alphas [Ee] to\n             * signify an exponent, and it is still a number with stricter\n             * rules.  So look for an alpha that signifies not-strict */\n            stricter = TRUE;\n            for (k = i; k < name_len; k++) {\n                if (   isALPHA_A(name[k])\n                    && (! is_nv_type || ! isALPHA_FOLD_EQ(name[k], 'E')))\n                {\n                    stricter = FALSE;\n                    break;\n                }\n            }\n        }\n\n        if (stricter) {\n\n            /* A number may have a leading '+' or '-'.  The latter is retained\n             * */\n            if (name[i] == '+') {\n                i++;\n            }\n            else if (name[i] == '-') {\n                lookup_name[j++] = '-';\n                i++;\n            }\n\n            /* Skip leading zeros including single underscores separating the\n             * zeros, or between the final leading zero and the first other\n             * digit */\n            for (; i < name_len - 1; i++) {\n                if (    name[i] != '0'\n                    && (name[i] != '_' || ! isDIGIT_A(name[i+1])))\n                {\n                    break;\n                }\n            }\n        }\n    }\n    else {  /* No '=' */\n\n       /* Only a few properties without an '=' should be parsed with stricter\n        * rules.  The list is unlikely to change. */\n        if (   memBEGINPs(lookup_name, j, \"perl\")\n            && memNEs(lookup_name + 4, j - 4, \"space\")\n            && memNEs(lookup_name + 4, j - 4, \"word\"))\n        {\n            stricter = TRUE;\n\n            /* We set the inputs back to 0 and the code below will reparse,\n             * using strict */\n            i = j = 0;\n        }\n    }\n\n    /* Here, we have either finished the property, or are positioned to parse\n     * the remainder, and we know if stricter rules apply.  Finish out, if not\n     * already done */\n    for (; i < name_len; i++) {\n        char cur = name[i];\n\n        /* In all instances, case differences are ignored, and we normalize to\n         * lowercase */\n        if (isUPPER_A(cur)) {\n            lookup_name[j++] = toLOWER(cur);\n            continue;\n        }\n\n        /* An underscore is skipped, but not under strict rules unless it\n         * separates two digits */\n        if (cur == '_') {\n            if (    stricter\n                && (     i == 0 || (int) i == equals_pos || i == name_len- 1\n                    || ! isDIGIT_A(name[i-1]) || ! isDIGIT_A(name[i+1])))\n            {\n                lookup_name[j++] = '_';\n            }\n            continue;\n        }\n\n        /* Hyphens are skipped except under strict */\n        if (cur == '-' && ! stricter) {\n            continue;\n        }\n\n        /* XXX Bug in documentation.  It says white space skipped adjacent to\n         * non-word char.  Maybe we should, but shouldn't skip it next to a dot\n         * in a number */\n        if (isSPACE_A(cur) && ! stricter) {\n            continue;\n        }\n\n        lookup_name[j++] = cur;\n\n        /* Unless this is a non-trailing slash, we are done with it */\n        if (i >= name_len - 1 || cur != '/') {\n            continue;\n        }\n\n        slash_pos = j;\n\n        /* A slash in the 'numeric value' property indicates that what follows\n         * is a denominator.  It can have a leading '+' and '0's that should be\n         * skipped.  But we have never allowed a negative denominator, so treat\n         * a minus like every other character.  (No need to rule out a second\n         * '/', as that won't match anything anyway */\n        if (is_nv_type) {\n            i++;\n            if (i < name_len && name[i] == '+') {\n                i++;\n            }\n\n            /* Skip leading zeros including underscores separating digits */\n            for (; i < name_len - 1; i++) {\n                if (   name[i] != '0'\n                    && (name[i] != '_' || ! isDIGIT_A(name[i+1])))\n                {\n                    break;\n                }\n            }\n\n            /* Store the first real character in the denominator */\n            lookup_name[j++] = name[i];\n        }\n    }\n\n    /* Here are completely done parsing the input 'name', and 'lookup_name'\n     * contains a copy, normalized.\n     *\n     * This special case is grandfathered in: 'L_' and 'GC=L_' are accepted and\n     * different from without the underscores.  */\n    if (  (   UNLIKELY(memEQs(lookup_name, j, \"l\"))\n           || UNLIKELY(memEQs(lookup_name, j, \"gc=l\")))\n        && UNLIKELY(name[name_len-1] == '_'))\n    {\n        lookup_name[j++] = '&';\n    }\n\n    /* If the original input began with 'In' or 'Is', it could be a subroutine\n     * call to a user-defined property instead of a Unicode property name. */\n    if (    non_pkg_begin + name_len > 2\n        &&  name[non_pkg_begin+0] == 'I'\n        && (name[non_pkg_begin+1] == 'n' || name[non_pkg_begin+1] == 's'))\n    {\n        starts_with_In_or_Is = TRUE;\n    }\n    else {\n        could_be_user_defined = FALSE;\n    }\n\n    if (could_be_user_defined) {\n        CV* user_sub;\n\n        /* If the user defined property returns the empty string, it could\n         * easily be because the pattern is being compiled before the data it\n         * actually needs to compile is available.  This could be argued to be\n         * a bug in the perl code, but this is a change of behavior for Perl,\n         * so we handle it.  This means that intentionally returning nothing\n         * will not be resolved until runtime */\n        bool empty_return = FALSE;\n\n        /* Here, the name could be for a user defined property, which are\n         * implemented as subs. */\n        user_sub = get_cvn_flags(name, name_len, 0);\n        if (user_sub) {\n            const char insecure[] = \"Insecure user-defined property\";\n\n            /* Here, there is a sub by the correct name.  Normally we call it\n             * to get the property definition */\n            dSP;\n            SV * user_sub_sv = MUTABLE_SV(user_sub);\n            SV * error;     /* Any error returned by calling 'user_sub' */\n            SV * key;       /* The key into the hash of user defined sub names\n                             */\n            SV * placeholder;\n            SV ** saved_user_prop_ptr;      /* Hash entry for this property */\n\n            /* How many times to retry when another thread is in the middle of\n             * expanding the same definition we want */\n            PERL_INT_FAST8_T retry_countdown = 10;\n\n            DECLARATION_FOR_GLOBAL_CONTEXT;\n\n            /* If we get here, we know this property is user-defined */\n            *user_defined_ptr = TRUE;\n\n            /* We refuse to call a potentially tainted subroutine; returning an\n             * error instead */\n            if (TAINT_get) {\n                if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                sv_catpvn(msg, insecure, sizeof(insecure) - 1);\n                goto append_name_to_msg;\n            }\n\n            /* In principal, we only call each subroutine property definition\n             * once during the life of the program.  This guarantees that the\n             * property definition never changes.  The results of the single\n             * sub call are stored in a hash, which is used instead for future\n             * references to this property.  The property definition is thus\n             * immutable.  But, to allow the user to have a /i-dependent\n             * definition, we call the sub once for non-/i, and once for /i,\n             * should the need arise, passing the /i status as a parameter.\n             *\n             * We start by constructing the hash key name, consisting of the\n             * fully qualified subroutine name, preceded by the /i status, so\n             * that there is a key for /i and a different key for non-/i */\n            key = newSVpvn(((to_fold) ? \"1\" : \"0\"), 1);\n            fq_name = S_get_fq_name(aTHX_ name, name_len, is_utf8,\n                                          non_pkg_begin != 0);\n            sv_catsv(key, fq_name);\n            sv_2mortal(key);\n\n            /* We only call the sub once throughout the life of the program\n             * (with the /i, non-/i exception noted above).  That means the\n             * hash must be global and accessible to all threads.  It is\n             * created at program start-up, before any threads are created, so\n             * is accessible to all children.  But this creates some\n             * complications.\n             *\n             * 1) The keys can't be shared, or else problems arise; sharing is\n             *    turned off at hash creation time\n             * 2) All SVs in it are there for the remainder of the life of the\n             *    program, and must be created in the same interpreter context\n             *    as the hash, or else they will be freed from the wrong pool\n             *    at global destruction time.  This is handled by switching to\n             *    the hash's context to create each SV going into it, and then\n             *    immediately switching back\n             * 3) All accesses to the hash must be controlled by a mutex, to\n             *    prevent two threads from getting an unstable state should\n             *    they simultaneously be accessing it.  The code below is\n             *    crafted so that the mutex is locked whenever there is an\n             *    access and unlocked only when the next stable state is\n             *    achieved.\n             *\n             * The hash stores either the definition of the property if it was\n             * valid, or, if invalid, the error message that was raised.  We\n             * use the type of SV to distinguish.\n             *\n             * There's also the need to guard against the definition expansion\n             * from infinitely recursing.  This is handled by storing the aTHX\n             * of the expanding thread during the expansion.  Again the SV type\n             * is used to distinguish this from the other two cases.  If we\n             * come to here and the hash entry for this property is our aTHX,\n             * it means we have recursed, and the code assumes that we would\n             * infinitely recurse, so instead stops and raises an error.\n             * (Any recursion has always been treated as infinite recursion in\n             * this feature.)\n             *\n             * If instead, the entry is for a different aTHX, it means that\n             * that thread has gotten here first, and hasn't finished expanding\n             * the definition yet.  We just have to wait until it is done.  We\n             * sleep and retry a few times, returning an error if the other\n             * thread doesn't complete. */\n\n          re_fetch:\n            USER_PROP_MUTEX_LOCK;\n\n            /* If we have an entry for this key, the subroutine has already\n             * been called once with this /i status. */\n            saved_user_prop_ptr = hv_fetch(PL_user_def_props,\n                                                   SvPVX(key), SvCUR(key), 0);\n            if (saved_user_prop_ptr) {\n\n                /* If the saved result is an inversion list, it is the valid\n                 * definition of this property */\n                if (is_invlist(*saved_user_prop_ptr)) {\n                    prop_definition = *saved_user_prop_ptr;\n\n                    /* The SV in the hash won't be removed until global\n                     * destruction, so it is stable and we can unlock */\n                    USER_PROP_MUTEX_UNLOCK;\n\n                    /* The caller shouldn't try to free this SV */\n                    return prop_definition;\n                }\n\n                /* Otherwise, if it is a string, it is the error message\n                 * that was returned when we first tried to evaluate this\n                 * property.  Fail, and append the message */\n                if (SvPOK(*saved_user_prop_ptr)) {\n                    if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                    sv_catsv(msg, *saved_user_prop_ptr);\n\n                    /* The SV in the hash won't be removed until global\n                     * destruction, so it is stable and we can unlock */\n                    USER_PROP_MUTEX_UNLOCK;\n\n                    return NULL;\n                }\n\n                assert(SvIOK(*saved_user_prop_ptr));\n\n                /* Here, we have an unstable entry in the hash.  Either another\n                 * thread is in the middle of expanding the property's\n                 * definition, or we are ourselves recursing.  We use the aTHX\n                 * in it to distinguish */\n                if (SvIV(*saved_user_prop_ptr) != PTR2IV(CUR_CONTEXT)) {\n\n                    /* Here, it's another thread doing the expanding.  We've\n                     * looked as much as we are going to at the contents of the\n                     * hash entry.  It's safe to unlock. */\n                    USER_PROP_MUTEX_UNLOCK;\n\n                    /* Retry a few times */\n                    if (retry_countdown-- > 0) {\n                        PerlProc_sleep(1);\n                        goto re_fetch;\n                    }\n\n                    if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                    sv_catpvs(msg, \"Timeout waiting for another thread to \"\n                                   \"define\");\n                    goto append_name_to_msg;\n                }\n\n                /* Here, we are recursing; don't dig any deeper */\n                USER_PROP_MUTEX_UNLOCK;\n\n                if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                sv_catpvs(msg,\n                          \"Infinite recursion in user-defined property\");\n                goto append_name_to_msg;\n            }\n\n            /* Here, this thread has exclusive control, and there is no entry\n             * for this property in the hash.  So we have the go ahead to\n             * expand the definition ourselves. */\n\n            PUSHSTACKi(PERLSI_MAGIC);\n            ENTER;\n\n            /* Create a temporary placeholder in the hash to detect recursion\n             * */\n            SWITCH_TO_GLOBAL_CONTEXT;\n            placeholder= newSVuv(PTR2IV(ORIGINAL_CONTEXT));\n            (void) hv_store_ent(PL_user_def_props, key, placeholder, 0);\n            RESTORE_CONTEXT;\n\n            /* Now that we have a placeholder, we can let other threads\n             * continue */\n            USER_PROP_MUTEX_UNLOCK;\n\n            /* Make sure the placeholder always gets destroyed */\n            SAVEDESTRUCTOR_X(S_delete_recursion_entry, SvPVX(key));\n\n            PUSHMARK(SP);\n            SAVETMPS;\n\n            /* Call the user's function, with the /i status as a parameter.\n             * Note that we have gone to a lot of trouble to keep this call\n             * from being within the locked mutex region. */\n            XPUSHs(boolSV(to_fold));\n            PUTBACK;\n\n            /* The following block was taken from swash_init().  Presumably\n             * they apply to here as well, though we no longer use a swash --\n             * khw */\n            SAVEHINTS();\n            save_re_context();\n            /* We might get here via a subroutine signature which uses a utf8\n             * parameter name, at which point PL_subname will have been set\n             * but not yet used. */\n            save_item(PL_subname);\n\n            (void) call_sv(user_sub_sv, G_EVAL|G_SCALAR);\n\n            SPAGAIN;\n\n            error = ERRSV;\n            if (TAINT_get || SvTRUE(error)) {\n                if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                if (SvTRUE(error)) {\n                    sv_catpvs(msg, \"Error \\\"\");\n                    sv_catsv(msg, error);\n                    sv_catpvs(msg, \"\\\"\");\n                }\n                if (TAINT_get) {\n                    if (SvTRUE(error)) sv_catpvs(msg, \"; \");\n                    sv_catpvn(msg, insecure, sizeof(insecure) - 1);\n                }\n\n                if (name_len > 0) {\n                    sv_catpvs(msg, \" in expansion of \");\n                    Perl_sv_catpvf(aTHX_ msg, \"%\" UTF8f, UTF8fARG(is_utf8,\n                                                                  name_len,\n                                                                  name));\n                }\n\n                (void) POPs;\n                prop_definition = NULL;\n            }\n            else {  /* G_SCALAR guarantees a single return value */\n                SV * contents = POPs;\n\n                /* The contents is supposed to be the expansion of the property\n                 * definition.  If the definition is deferrable, and we got an\n                 * empty string back, set a flag to later defer it (after clean\n                 * up below). */\n                if (      deferrable\n                    && (! SvPOK(contents) || SvCUR(contents) == 0))\n                {\n                        empty_return = TRUE;\n                }\n                else { /* Otherwise, call a function to check for valid syntax,\n                          and handle it */\n\n                    prop_definition = handle_user_defined_property(\n                                                    name, name_len,\n                                                    is_utf8, to_fold, runtime,\n                                                    deferrable,\n                                                    contents, user_defined_ptr,\n                                                    msg,\n                                                    level);\n                }\n            }\n\n            /* Here, we have the results of the expansion.  Delete the\n             * placeholder, and if the definition is now known, replace it with\n             * that definition.  We need exclusive access to the hash, and we\n             * can't let anyone else in, between when we delete the placeholder\n             * and add the permanent entry */\n            USER_PROP_MUTEX_LOCK;\n\n            S_delete_recursion_entry(aTHX_ SvPVX(key));\n\n            if (    ! empty_return\n                && (! prop_definition || is_invlist(prop_definition)))\n            {\n                /* If we got success we use the inversion list defining the\n                 * property; otherwise use the error message */\n                SWITCH_TO_GLOBAL_CONTEXT;\n                (void) hv_store_ent(PL_user_def_props,\n                                    key,\n                                    ((prop_definition)\n                                     ? newSVsv(prop_definition)\n                                     : newSVsv(msg)),\n                                    0);\n                RESTORE_CONTEXT;\n            }\n\n            /* All done, and the hash now has a permanent entry for this\n             * property.  Give up exclusive control */\n            USER_PROP_MUTEX_UNLOCK;\n\n            FREETMPS;\n            LEAVE;\n            POPSTACK;\n\n            if (empty_return) {\n                goto definition_deferred;\n            }\n\n            if (prop_definition) {\n\n                /* If the definition is for something not known at this time,\n                 * we toss it, and go return the main property name, as that's\n                 * the one the user will be aware of */\n                if (! is_invlist(prop_definition)) {\n                    SvREFCNT_dec_NN(prop_definition);\n                    goto definition_deferred;\n                }\n\n                sv_2mortal(prop_definition);\n            }\n\n            /* And return */\n            return prop_definition;\n\n        }   /* End of calling the subroutine for the user-defined property */\n    }       /* End of it could be a user-defined property */\n\n    /* Here it wasn't a user-defined property that is known at this time.  See\n     * if it is a Unicode property */\n\n    lookup_len = j;     /* This is a more mnemonic name than 'j' */\n\n    /* Get the index into our pointer table of the inversion list corresponding\n     * to the property */\n    table_index = match_uniprop((U8 *) lookup_name, lookup_len);\n\n    /* If it didn't find the property ... */\n    if (table_index == 0) {\n\n        /* Try again stripping off any initial 'In' or 'Is' */\n        if (starts_with_In_or_Is) {\n            lookup_name += 2;\n            lookup_len -= 2;\n            equals_pos -= 2;\n            slash_pos -= 2;\n\n            table_index = match_uniprop((U8 *) lookup_name, lookup_len);\n        }\n\n        if (table_index == 0) {\n            char * canonical;\n\n            /* Here, we didn't find it.  If not a numeric type property, and\n             * can't be a user-defined one, it isn't a legal property */\n            if (! is_nv_type) {\n                if (! could_be_user_defined) {\n                    goto failed;\n                }\n\n                /* Here, the property name is legal as a user-defined one.   At\n                 * compile time, it might just be that the subroutine for that\n                 * property hasn't been encountered yet, but at runtime, it's\n                 * an error to try to use an undefined one */\n                if (! deferrable) {\n                    if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                    sv_catpvs(msg, \"Unknown user-defined property name\");\n                    goto append_name_to_msg;\n                }\n\n                goto definition_deferred;\n            } /* End of isn't a numeric type property */\n\n            /* The numeric type properties need more work to decide.  What we\n             * do is make sure we have the number in canonical form and look\n             * that up. */\n\n            if (slash_pos < 0) {    /* No slash */\n\n                /* When it isn't a rational, take the input, convert it to a\n                 * NV, then create a canonical string representation of that\n                 * NV. */\n\n                NV value;\n                SSize_t value_len = lookup_len - equals_pos;\n\n                /* Get the value */\n                if (   value_len <= 0\n                    || my_atof3(lookup_name + equals_pos, &value,\n                                value_len)\n                          != lookup_name + lookup_len)\n                {\n                    goto failed;\n                }\n\n                /* If the value is an integer, the canonical value is integral\n                 * */\n                if (Perl_ceil(value) == value) {\n                    canonical = Perl_form(aTHX_ \"%.*s%.0\" NVff,\n                                            equals_pos, lookup_name, value);\n                }\n                else {  /* Otherwise, it is %e with a known precision */\n                    char * exp_ptr;\n\n                    canonical = Perl_form(aTHX_ \"%.*s%.*\" NVef,\n                                                equals_pos, lookup_name,\n                                                PL_E_FORMAT_PRECISION, value);\n\n                    /* The exponent generated is expecting two digits, whereas\n                     * %e on some systems will generate three.  Remove leading\n                     * zeros in excess of 2 from the exponent.  We start\n                     * looking for them after the '=' */\n                    exp_ptr = strchr(canonical + equals_pos, 'e');\n                    if (exp_ptr) {\n                        char * cur_ptr = exp_ptr + 2; /* past the 'e[+-]' */\n                        SSize_t excess_exponent_len = strlen(cur_ptr) - 2;\n\n                        assert(*(cur_ptr - 1) == '-' || *(cur_ptr - 1) == '+');\n\n                        if (excess_exponent_len > 0) {\n                            SSize_t leading_zeros = strspn(cur_ptr, \"0\");\n                            SSize_t excess_leading_zeros\n                                    = MIN(leading_zeros, excess_exponent_len);\n                            if (excess_leading_zeros > 0) {\n                                Move(cur_ptr + excess_leading_zeros,\n                                     cur_ptr,\n                                     strlen(cur_ptr) - excess_leading_zeros\n                                       + 1,  /* Copy the NUL as well */\n                                     char);\n                            }\n                        }\n                    }\n                }\n            }\n            else {  /* Has a slash.  Create a rational in canonical form  */\n                UV numerator, denominator, gcd, trial;\n                const char * end_ptr;\n                const char * sign = \"\";\n\n                /* We can't just find the numerator, denominator, and do the\n                 * division, then use the method above, because that is\n                 * inexact.  And the input could be a rational that is within\n                 * epsilon (given our precision) of a valid rational, and would\n                 * then incorrectly compare valid.\n                 *\n                 * We're only interested in the part after the '=' */\n                const char * this_lookup_name = lookup_name + equals_pos;\n                lookup_len -= equals_pos;\n                slash_pos -= equals_pos;\n\n                /* Handle any leading minus */\n                if (this_lookup_name[0] == '-') {\n                    sign = \"-\";\n                    this_lookup_name++;\n                    lookup_len--;\n                    slash_pos--;\n                }\n\n                /* Convert the numerator to numeric */\n                end_ptr = this_lookup_name + slash_pos;\n                if (! grok_atoUV(this_lookup_name, &numerator, &end_ptr)) {\n                    goto failed;\n                }\n\n                /* It better have included all characters before the slash */\n                if (*end_ptr != '/') {\n                    goto failed;\n                }\n\n                /* Set to look at just the denominator */\n                this_lookup_name += slash_pos;\n                lookup_len -= slash_pos;\n                end_ptr = this_lookup_name + lookup_len;\n\n                /* Convert the denominator to numeric */\n                if (! grok_atoUV(this_lookup_name, &denominator, &end_ptr)) {\n                    goto failed;\n                }\n\n                /* It better be the rest of the characters, and don't divide by\n                 * 0 */\n                if (   end_ptr != this_lookup_name + lookup_len\n                    || denominator == 0)\n                {\n                    goto failed;\n                }\n\n                /* Get the greatest common denominator using\n                   http://en.wikipedia.org/wiki/Euclidean_algorithm */\n                gcd = numerator;\n                trial = denominator;\n                while (trial != 0) {\n                    UV temp = trial;\n                    trial = gcd % trial;\n                    gcd = temp;\n                }\n\n                /* If already in lowest possible terms, we have already tried\n                 * looking this up */\n                if (gcd == 1) {\n                    goto failed;\n                }\n\n                /* Reduce the rational, which should put it in canonical form\n                 * */\n                numerator /= gcd;\n                denominator /= gcd;\n\n                canonical = Perl_form(aTHX_ \"%.*s%s%\" UVuf \"/%\" UVuf,\n                        equals_pos, lookup_name, sign, numerator, denominator);\n            }\n\n            /* Here, we have the number in canonical form.  Try that */\n            table_index = match_uniprop((U8 *) canonical, strlen(canonical));\n            if (table_index == 0) {\n                goto failed;\n            }\n        }   /* End of still didn't find the property in our table */\n    }       /* End of       didn't find the property in our table */\n\n    /* Here, we have a non-zero return, which is an index into a table of ptrs.\n     * A negative return signifies that the real index is the absolute value,\n     * but the result needs to be inverted */\n    if (table_index < 0) {\n        invert_return = TRUE;\n        table_index = -table_index;\n    }\n\n    /* Out-of band indices indicate a deprecated property.  The proper index is\n     * modulo it with the table size.  And dividing by the table size yields\n     * an offset into a table constructed by regen/mk_invlists.pl to contain\n     * the corresponding warning message */\n    if (table_index > MAX_UNI_KEYWORD_INDEX) {\n        Size_t warning_offset = table_index / MAX_UNI_KEYWORD_INDEX;\n        table_index %= MAX_UNI_KEYWORD_INDEX;\n        Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),\n                \"Use of '%.*s' in \\\\p{} or \\\\P{} is deprecated because: %s\",\n                (int) name_len, name, deprecated_property_msgs[warning_offset]);\n    }\n\n    /* In a few properties, a different property is used under /i.  These are\n     * unlikely to change, so are hard-coded here. */\n    if (to_fold) {\n        if (   table_index == UNI_XPOSIXUPPER\n            || table_index == UNI_XPOSIXLOWER\n            || table_index == UNI_TITLE)\n        {\n            table_index = UNI_CASED;\n        }\n        else if (   table_index == UNI_UPPERCASELETTER\n                 || table_index == UNI_LOWERCASELETTER\n#  ifdef UNI_TITLECASELETTER   /* Missing from early Unicodes */\n                 || table_index == UNI_TITLECASELETTER\n#  endif\n        ) {\n            table_index = UNI_CASEDLETTER;\n        }\n        else if (  table_index == UNI_POSIXUPPER\n                || table_index == UNI_POSIXLOWER)\n        {\n            table_index = UNI_POSIXALPHA;\n        }\n    }\n\n    /* Create and return the inversion list */\n    prop_definition =_new_invlist_C_array(uni_prop_ptrs[table_index]);\n    sv_2mortal(prop_definition);\n\n\n    /* See if there is a private use override to add to this definition */\n    {\n        COPHH * hinthash = (IN_PERL_COMPILETIME)\n                           ? CopHINTHASH_get(&PL_compiling)\n                           : CopHINTHASH_get(PL_curcop);\n\tSV * pu_overrides = cophh_fetch_pv(hinthash, \"private_use\", 0, 0);\n\n        if (UNLIKELY(pu_overrides && SvPOK(pu_overrides))) {\n\n            /* See if there is an element in the hints hash for this table */\n            SV * pu_lookup = Perl_newSVpvf(aTHX_ \"%d=\", table_index);\n            const char * pos = strstr(SvPVX(pu_overrides), SvPVX(pu_lookup));\n\n            if (pos) {\n                bool dummy;\n                SV * pu_definition;\n                SV * pu_invlist;\n                SV * expanded_prop_definition =\n                            sv_2mortal(invlist_clone(prop_definition, NULL));\n\n                /* If so, it's definition is the string from here to the next\n                 * \\a character.  And its format is the same as a user-defined\n                 * property */\n                pos += SvCUR(pu_lookup);\n                pu_definition = newSVpvn(pos, strchr(pos, '\\a') - pos);\n                pu_invlist = handle_user_defined_property(lookup_name,\n                                                          lookup_len,\n                                                          0, /* Not UTF-8 */\n                                                          0, /* Not folded */\n                                                          runtime,\n                                                          deferrable,\n                                                          pu_definition,\n                                                          &dummy,\n                                                          msg,\n                                                          level);\n                if (TAINT_get) {\n                    if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                    sv_catpvs(msg, \"Insecure private-use override\");\n                    goto append_name_to_msg;\n                }\n\n                /* For now, as a safety measure, make sure that it doesn't\n                 * override non-private use code points */\n                _invlist_intersection(pu_invlist, PL_Private_Use, &pu_invlist);\n\n                /* Add it to the list to be returned */\n                _invlist_union(prop_definition, pu_invlist,\n                               &expanded_prop_definition);\n                prop_definition = expanded_prop_definition;\n                Perl_ck_warner_d(aTHX_ packWARN(WARN_EXPERIMENTAL__PRIVATE_USE), \"The private_use feature is experimental\");\n            }\n        }\n    }\n\n    if (invert_return) {\n        _invlist_invert(prop_definition);\n    }\n    return prop_definition;\n\n\n  failed:\n    if (non_pkg_begin != 0) {\n        if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n        sv_catpvs(msg, \"Illegal user-defined property name\");\n    }\n    else {\n        if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n        sv_catpvs(msg, \"Can't find Unicode property definition\");\n    }\n    /* FALLTHROUGH */\n\n  append_name_to_msg:\n    {\n        const char * prefix = (runtime && level == 0) ?  \" \\\\p{\" : \" \\\"\";\n        const char * suffix = (runtime && level == 0) ?  \"}\" : \"\\\"\";\n\n        sv_catpv(msg, prefix);\n        Perl_sv_catpvf(aTHX_ msg, \"%\" UTF8f, UTF8fARG(is_utf8, name_len, name));\n        sv_catpv(msg, suffix);\n    }\n\n    return NULL;\n\n  definition_deferred:\n\n    /* Here it could yet to be defined, so defer evaluation of this\n     * until its needed at runtime.  We need the fully qualified property name\n     * to avoid ambiguity, and a trailing newline */\n    if (! fq_name) {\n        fq_name = S_get_fq_name(aTHX_ name, name_len, is_utf8,\n                                      non_pkg_begin != 0 /* If has \"::\" */\n                               );\n    }\n    sv_catpvs(fq_name, \"\\n\");\n\n    *user_defined_ptr = TRUE;\n    return fq_name;\n}\n\n#endif\n\n/*\n * ex: set ts=8 sts=4 sw=4 et:\n */\n", "#!./perl\n#\n# This is a home for regular expression tests that don't fit into\n# the format supported by re/regexp.t.  If you want to add a test\n# that does fit that format, add it to re/re_tests, not here.\n\nuse strict;\nuse warnings;\nno warnings 'experimental::vlb';\nuse 5.010;\n\nsub run_tests;\n\n$| = 1;\n\n\nBEGIN {\n    chdir 't' if -d 't';\n    require Config; import Config;\n    require './test.pl'; require './charset_tools.pl';\n    require './loc_tools.pl';\n    set_up_inc('../lib', '.', '../ext/re');\n}\n\nskip_all('no re module') unless defined &DynaLoader::boot_DynaLoader;\nskip_all_without_unicode_tables();\n\nplan tests => 869;  # Update this when adding/deleting tests.\n\nrun_tests() unless caller;\n\n#\n# Tests start here.\n#\nsub run_tests {\n    my $sharp_s = uni_to_native(\"\\xdf\");\n\n    {\n        my $x = \"abc\\ndef\\n\";\n\t(my $x_pretty = $x) =~ s/\\n/\\\\n/g;\n\n        ok $x =~ /^abc/,  qq [\"$x_pretty\" =~ /^abc/];\n        ok $x !~ /^def/,  qq [\"$x_pretty\" !~ /^def/];\n\n        # used to be a test for $*\n        ok $x =~ /^def/m, qq [\"$x_pretty\" =~ /^def/m];\n\n        ok(!($x =~ /^xxx/), qq [\"$x_pretty\" =~ /^xxx/]);\n        ok(!($x !~ /^abc/), qq [\"$x_pretty\" !~ /^abc/]);\n\n         ok $x =~ /def/, qq [\"$x_pretty\" =~ /def/];\n        ok(!($x !~ /def/), qq [\"$x_pretty\" !~ /def/]);\n\n         ok $x !~ /.def/, qq [\"$x_pretty\" !~ /.def/];\n        ok(!($x =~ /.def/), qq [\"$x_pretty\" =~ /.def/]);\n\n         ok $x =~ /\\ndef/, qq [\"$x_pretty\" =~ /\\\\ndef/];\n        ok(!($x !~ /\\ndef/), qq [\"$x_pretty\" !~ /\\\\ndef/]);\n    }\n\n    {\n        $_ = '123';\n        ok /^([0-9][0-9]*)/, qq [\\$_ = '$_'; /^([0-9][0-9]*)/];\n    }\n\n    {\n        $_ = 'aaabbbccc';\n         ok /(a*b*)(c*)/ && $1 eq 'aaabbb' && $2 eq 'ccc',\n                                             qq [\\$_ = '$_'; /(a*b*)(c*)/];\n         ok /(a+b+c+)/ && $1 eq 'aaabbbccc', qq [\\$_ = '$_'; /(a+b+c+)/];\n        unlike($_, qr/a+b?c+/, qq [\\$_ = '$_'; /a+b?c+/]);\n\n        $_ = 'aaabccc';\n         ok /a+b?c+/, qq [\\$_ = '$_'; /a+b?c+/];\n         ok /a*b?c*/, qq [\\$_ = '$_'; /a*b?c*/];\n\n        $_ = 'aaaccc';\n         ok /a*b?c*/, qq [\\$_ = '$_'; /a*b?c*/];\n        unlike($_, qr/a*b+c*/, qq [\\$_ = '$_'; /a*b+c*/]);\n\n        $_ = 'abcdef';\n         ok /bcd|xyz/, qq [\\$_ = '$_'; /bcd|xyz/];\n         ok /xyz|bcd/, qq [\\$_ = '$_'; /xyz|bcd/];\n         ok m|bc/*d|,  qq [\\$_ = '$_'; m|bc/*d|];\n         ok /^$_$/,    qq [\\$_ = '$_'; /^\\$_\\$/];\n    }\n\n    {\n        # used to be a test for $*\n        ok \"ab\\ncd\\n\" =~ /^cd/m, q [\"ab\\ncd\\n\" =~ /^cd/m];\n    }\n\n    {\n        our %XXX = map {($_ => $_)} 123, 234, 345;\n\n        our @XXX = ('ok 1','not ok 1', 'ok 2','not ok 2','not ok 3');\n        while ($_ = shift(@XXX)) {\n            my $e = index ($_, 'not') >= 0 ? '' : 1;\n            my $r = m?(.*)?;\n            is($r, $e, \"?(.*)?\");\n            /not/ && reset;\n            if (/not ok 2/) {\n                if ($^O eq 'VMS') {\n                    $_ = shift(@XXX);\n                }\n                else {\n                    reset 'X';\n                }\n            }\n        }\n\n        SKIP: {\n            if ($^O eq 'VMS') {\n                skip \"Reset 'X'\", 1;\n            }\n            ok !keys %XXX, \"%XXX is empty\";\n        }\n\n    }\n\n    {\n        my $message = \"Test empty pattern\";\n        my $xyz = 'xyz';\n        my $cde = 'cde';\n\n        $cde =~ /[^ab]*/;\n        $xyz =~ //;\n        is($&, $xyz, $message);\n\n        my $foo = '[^ab]*';\n        $cde =~ /$foo/;\n        $xyz =~ //;\n        is($&, $xyz, $message);\n\n        $cde =~ /$foo/;\n        my $null;\n        no warnings 'uninitialized';\n        $xyz =~ /$null/;\n        is($&, $xyz, $message);\n\n        $null = \"\";\n        $xyz =~ /$null/;\n        is($&, $xyz, $message);\n\n        # each entry: regexp, match string, $&, //o match success\n        my @tests =\n          (\n           [ \"\", \"xy\", \"x\", 1 ],\n           [ \"y\", \"yz\", \"y\", !1 ],\n          );\n        for my $test (@tests) {\n            my ($re, $str, $matched, $omatch) = @$test;\n            $xyz =~ /x/o;\n            ok($str =~ /$re/, \"$str matches /$re/\");\n            is($&, $matched, \"on $matched\");\n            $xyz =~ /x/o;\n            is($str =~ /$re/o, $omatch, \"$str matches /$re/o (or not)\");\n        }\n    }\n\n    {\n        my $message = q !Check $`, $&, $'!;\n        $_ = 'abcdefghi';\n        /def/;        # optimized up to cmd\n        is(\"$`:$&:$'\", 'abc:def:ghi', $message);\n\n        no warnings 'void';\n        /cde/ + 0;    # optimized only to spat\n        is(\"$`:$&:$'\", 'ab:cde:fghi', $message);\n\n        /[d][e][f]/;    # not optimized\n        is(\"$`:$&:$'\", 'abc:def:ghi', $message);\n    }\n\n    {\n        $_ = 'now is the {time for all} good men to come to.';\n        / \\{([^}]*)}/;\n        is($1, 'time for all', \"Match braces\");\n    }\n\n    {\n        my $message = \"{N,M} quantifier\";\n        $_ = 'xxx {3,4}  yyy   zzz';\n        ok(/( {3,4})/, $message);\n        is($1, '   ', $message);\n        unlike($_, qr/( {4,})/, $message);\n        ok(/( {2,3}.)/, $message);\n        is($1, '  y', $message);\n        ok(/(y{2,3}.)/, $message);\n        is($1, 'yyy ', $message);\n        unlike($_, qr/x {3,4}/, $message);\n        unlike($_, qr/^xxx {3,4}/, $message);\n    }\n\n    {\n        my $message = \"Test /g\";\n        local $\" = \":\";\n        $_ = \"now is the time for all good men to come to.\";\n        my @words = /(\\w+)/g;\n        my $exp   = \"now:is:the:time:for:all:good:men:to:come:to\";\n\n        is(\"@words\", $exp, $message);\n\n        @words = ();\n        while (/\\w+/g) {\n            push (@words, $&);\n        }\n        is(\"@words\", $exp, $message);\n\n        @words = ();\n        pos = 0;\n        while (/to/g) {\n            push(@words, $&);\n        }\n        is(\"@words\", \"to:to\", $message);\n\n        pos $_ = 0;\n        @words = /to/g;\n        is(\"@words\", \"to:to\", $message);\n    }\n\n    {\n        $_ = \"abcdefghi\";\n\n        my $pat1 = 'def';\n        my $pat2 = '^def';\n        my $pat3 = '.def.';\n        my $pat4 = 'abc';\n        my $pat5 = '^abc';\n        my $pat6 = 'abc$';\n        my $pat7 = 'ghi';\n        my $pat8 = '\\w*ghi';\n        my $pat9 = 'ghi$';\n\n        my $t1 = my $t2 = my $t3 = my $t4 = my $t5 =\n        my $t6 = my $t7 = my $t8 = my $t9 = 0;\n\n        for my $iter (1 .. 5) {\n            $t1++ if /$pat1/o;\n            $t2++ if /$pat2/o;\n            $t3++ if /$pat3/o;\n            $t4++ if /$pat4/o;\n            $t5++ if /$pat5/o;\n            $t6++ if /$pat6/o;\n            $t7++ if /$pat7/o;\n            $t8++ if /$pat8/o;\n            $t9++ if /$pat9/o;\n        }\n        my $x = \"$t1$t2$t3$t4$t5$t6$t7$t8$t9\";\n        is($x, '505550555', \"Test /o\");\n    }\n\n    {\n        my $xyz = 'xyz';\n        ok \"abc\" =~ /^abc$|$xyz/, \"| after \\$\";\n\n        # perl 4.009 says \"unmatched ()\"\n        my $message = '$ inside ()';\n\n        my $result;\n        eval '\"abc\" =~ /a(bc$)|$xyz/; $result = \"$&:$1\"';\n        is($@, \"\", $message);\n        is($result, \"abc:bc\", $message);\n    }\n\n    {\n        my $message = \"Scalar /g\";\n        $_ = \"abcfooabcbar\";\n\n        ok( /abc/g && $` eq \"\", $message);\n        ok( /abc/g && $` eq \"abcfoo\", $message);\n        ok(!/abc/g, $message);\n\n        $message = \"Scalar /gi\";\n        pos = 0;\n        ok( /ABC/gi && $` eq \"\", $message);\n        ok( /ABC/gi && $` eq \"abcfoo\", $message);\n        ok(!/ABC/gi, $message);\n\n        $message = \"Scalar /g\";\n        pos = 0;\n        ok( /abc/g && $' eq \"fooabcbar\", $message);\n        ok( /abc/g && $' eq \"bar\", $message);\n\n        $_ .= '';\n        my @x = /abc/g;\n        is(@x, 2, \"/g reset after assignment\");\n    }\n\n    {\n        my $message = '/g, \\G and pos';\n        $_ = \"abdc\";\n        pos $_ = 2;\n        /\\Gc/gc;\n        is(pos $_, 2, $message);\n        /\\Gc/g;\n        is(pos $_, undef, $message);\n    }\n\n    {\n        my $message = '(?{ })';\n        our $out = 1;\n        'abc' =~ m'a(?{ $out = 2 })b';\n        is($out, 2, $message);\n\n        $out = 1;\n        'abc' =~ m'a(?{ $out = 3 })c';\n        is($out, 1, $message);\n    }\n\n    {\n        $_ = 'foobar1 bar2 foobar3 barfoobar5 foobar6';\n        my @out = /(?<!foo)bar./g;\n        is(\"@out\", 'bar2 barf', \"Negative lookbehind\");\n    }\n\n    {\n        my $message = \"REG_INFTY tests\";\n        # Tests which depend on REG_INFTY\n\n\t#  Defaults assumed if this fails\n\teval { require Config; };\n        $::reg_infty   = $Config::Config{reg_infty} // 65535;\n        $::reg_infty_m = $::reg_infty - 1;\n        $::reg_infty_p = $::reg_infty + 1;\n        $::reg_infty_m = $::reg_infty_m;   # Suppress warning.\n\n        # As well as failing if the pattern matches do unexpected things, the\n        # next three tests will fail if you should have picked up a lower-than-\n        # default value for $reg_infty from Config.pm, but have not.\n\n        is(eval q{('aaa' =~ /(a{1,$::reg_infty_m})/)[0]}, 'aaa', $message);\n        is($@, '', $message);\n        is(eval q{('a' x $::reg_infty_m) =~ /a{$::reg_infty_m}/}, 1, $message);\n        is($@, '', $message);\n        isnt(q{('a' x ($::reg_infty_m - 1)) !~ /a{$::reg_infty_m}/}, 1, $message);\n        is($@, '', $message);\n\n        eval \"'aaa' =~ /a{1,$::reg_infty}/\";\n        like($@, qr/^\\QQuantifier in {,} bigger than/, $message);\n        eval \"'aaa' =~ /a{1,$::reg_infty_p}/\";\n        like($@, qr/^\\QQuantifier in {,} bigger than/, $message);\n\n        # It should be 'a' x 2147483647, but that exhausts memory on\n        # reasonably sized modern machines\n        like('a' x $::reg_infty_p, qr/a{1,}/,\n             \"{1,} matches more times than REG_INFTY\");\n    }\n\n    {\n        # Poke a couple more parse failures\n        my $context = 'x' x 256;\n        eval qq(\"${context}y\" =~ /(?<=$context)y/);\n        ok $@ =~ /^\\QLookbehind longer than 255 not/, \"Lookbehind limit\";\n    }\n\n    {\n        # Long Monsters\n        for my $l (125, 140, 250, 270, 300000, 30) { # Ordered to free memory\n            my $a = 'a' x $l;\n\t    my $message = \"Long monster, length = $l\";\n\t    like(\"ba$a=\", qr/a$a=/, $message);\n            unlike(\"b$a=\", qr/a$a=/, $message);\n            like(\"b$a=\", qr/ba+=/, $message);\n\n\t    like(\"ba$a=\", qr/b(?:a|b)+=/, $message);\n        }\n    }\n\n    {\n        # 20000 nodes, each taking 3 words per string, and 1 per branch\n        my $long_constant_len = join '|', 12120 .. 32645;\n        my $long_var_len = join '|', 8120 .. 28645;\n        my %ans = ( 'ax13876y25677lbc' => 1,\n                    'ax13876y25677mcb' => 0, # not b.\n                    'ax13876y35677nbc' => 0, # Num too big\n                    'ax13876y25677y21378obc' => 1,\n                    'ax13876y25677y21378zbc' => 0,    # Not followed by [k-o]\n                    'ax13876y25677y21378y21378kbc' => 1,\n                    'ax13876y25677y21378y21378kcb' => 0, # Not b.\n                    'ax13876y25677y21378y21378y21378kbc' => 0, # 5 runs\n                  );\n\n        for (keys %ans) {\n\t    my $message = \"20000 nodes, const-len '$_'\";\n            ok !($ans{$_} xor /a(?=([yx]($long_constant_len)){2,4}[k-o]).*b./o), $message;\n\n\t    $message = \"20000 nodes, var-len '$_'\";\n            ok !($ans{$_} xor /a(?=([yx]($long_var_len)){2,4}[k-o]).*b./o,), $message;\n        }\n    }\n\n    {\n        my $message = \"Complicated backtracking\";\n        $_ = \" a (bla()) and x(y b((l)u((e))) and b(l(e)e)e\";\n        my $expect = \"(bla()) ((l)u((e))) (l(e)e)\";\n\n        our $c;\n        sub matchit {\n          m/\n             (\n               \\(\n               (?{ $c = 1 })    # Initialize\n               (?:\n                 (?(?{ $c == 0 })   # PREVIOUS iteration was OK, stop the loop\n                   (?!\n                   )        # Fail: will unwind one iteration back\n                 )\n                 (?:\n                   [^()]+        # Match a big chunk\n                   (?=\n                     [()]\n                   )        # Do not try to match subchunks\n                 |\n                   \\(\n                   (?{ ++$c })\n                 |\n                   \\)\n                   (?{ --$c })\n                 )\n               )+        # This may not match with different subblocks\n             )\n             (?(?{ $c != 0 })\n               (?!\n               )        # Fail\n             )            # Otherwise the chunk 1 may succeed with $c>0\n           /xg;\n        }\n\n        my @ans = ();\n        my $res;\n        push @ans, $res while $res = matchit;\n        is(\"@ans\", \"1 1 1\", $message);\n\n        @ans = matchit;\n        is(\"@ans\", $expect, $message);\n\n        $message = \"Recursion with (??{ })\";\n        our $matched;\n        $matched = qr/\\((?:(?>[^()]+)|(??{$matched}))*\\)/;\n\n        @ans = my @ans1 = ();\n        push (@ans, $res), push (@ans1, $&) while $res = m/$matched/g;\n\n        is(\"@ans\", \"1 1 1\", $message);\n        is(\"@ans1\", $expect, $message);\n\n        @ans = m/$matched/g;\n        is(\"@ans\", $expect, $message);\n\n    }\n\n    {\n        ok \"abc\" =~ /^(??{\"a\"})b/, '\"abc\" =~ /^(??{\"a\"})b/';\n    }\n\n    {\n        my @ans = ('a/b' =~ m%(.*/)?(.*)%);    # Stack may be bad\n        is(\"@ans\", 'a/ b', \"Stack may be bad\");\n    }\n\n    {\n        my $message = \"Eval-group not allowed at runtime\";\n        my $code = '{$blah = 45}';\n        our $blah = 12;\n        eval { /(?$code)/ };\n        ok($@ && $@ =~ /not allowed at runtime/ && $blah == 12, $message);\n\n\t$blah = 12;\n\tmy $res = eval { \"xx\" =~ /(?$code)/o };\n\t{\n\t    no warnings 'uninitialized';\n\t    chomp $@; my $message = \"$message '$@', '$res', '$blah'\";\n\t    ok($@ && $@ =~ /not allowed at runtime/ && $blah == 12, $message);\n\t}\n\n        $code = '=xx';\n\t$blah = 12;\n\t$res = eval { \"xx\" =~ /(?$code)/o };\n\t{\n\t    no warnings 'uninitialized';\n\t    my $message = \"$message '$@', '$res', '$blah'\";\n\t    ok(!$@ && $res, $message);\n\t}\n\n        $code = '{$blah = 45}';\n        $blah = 12;\n        eval \"/(?$code)/\";\n        is($blah, 45, $message);\n\n        $blah = 12;\n        /(?{$blah = 45})/;\n        is($blah, 45, $message);\n    }\n\n    {\n        my $message = \"Pos checks\";\n        my $x = 'banana';\n        $x =~ /.a/g;\n        is(pos $x, 2, $message);\n\n        $x =~ /.z/gc;\n        is(pos $x, 2, $message);\n\n        sub f {\n            my $p = $_[0];\n            return $p;\n        }\n\n        $x =~ /.a/g;\n        is(f (pos $x), 4, $message);\n    }\n\n    {\n        my $message = 'Checking $^R';\n        our $x = $^R = 67;\n        'foot' =~ /foo(?{$x = 12; 75})[t]/;\n        is($^R, 75, $message);\n\n        $x = $^R = 67;\n        'foot' =~ /foo(?{$x = 12; 75})[xy]/;\n        ok($^R eq '67' && $x eq '12', $message);\n\n        $x = $^R = 67;\n        'foot' =~ /foo(?{ $^R + 12 })((?{ $x = 12; $^R + 17 })[xy])?/;\n        ok($^R eq '79' && $x eq '12', $message);\n    }\n\n    {\n        is(qr/\\b\\v$/i,    '(?^i:\\b\\v$)', 'qr/\\b\\v$/i');\n        is(qr/\\b\\v$/s,    '(?^s:\\b\\v$)', 'qr/\\b\\v$/s');\n        is(qr/\\b\\v$/m,    '(?^m:\\b\\v$)', 'qr/\\b\\v$/m');\n        is(qr/\\b\\v$/x,    '(?^x:\\b\\v$)', 'qr/\\b\\v$/x');\n        is(qr/\\b\\v$/xism, '(?^msix:\\b\\v$)',  'qr/\\b\\v$/xism');\n        is(qr/\\b\\v$/,     '(?^:\\b\\v$)', 'qr/\\b\\v$/');\n    }\n\n    {   # Test that charset modifier work, and are interpolated\n        is(qr/\\b\\v$/, '(?^:\\b\\v$)', 'Verify no locale, no unicode_strings gives default modifier');\n        is(qr/(?l:\\b\\v$)/, '(?^:(?l:\\b\\v$))', 'Verify infix l modifier compiles');\n        is(qr/(?u:\\b\\v$)/, '(?^:(?u:\\b\\v$))', 'Verify infix u modifier compiles');\n        is(qr/(?l)\\b\\v$/, '(?^:(?l)\\b\\v$)', 'Verify (?l) compiles');\n        is(qr/(?u)\\b\\v$/, '(?^:(?u)\\b\\v$)', 'Verify (?u) compiles');\n\n        my $dual = qr/\\b\\v$/;\n        my $locale;\n\n      SKIP: {\n            skip 'Locales not available', 1 unless locales_enabled('LC_CTYPE');\n\n            use locale;\n            $locale = qr/\\b\\v$/;\n            is($locale,    '(?^l:\\b\\v$)', 'Verify has l modifier when compiled under use locale');\n            no locale;\n        }\n\n        use feature 'unicode_strings';\n        my $unicode = qr/\\b\\v$/;\n        is($unicode,    '(?^u:\\b\\v$)', 'Verify has u modifier when compiled under unicode_strings');\n        is(qr/abc$dual/,    '(?^u:abc(?^:\\b\\v$))', 'Verify retains d meaning when interpolated under locale');\n\n      SKIP: {\n            skip 'Locales not available', 1 unless locales_enabled('LC_CTYPE');\n\n            is(qr/abc$locale/,    '(?^u:abc(?^l:\\b\\v$))', 'Verify retains l when interpolated under unicode_strings');\n        }\n\n        no feature 'unicode_strings';\n      SKIP: {\n            skip 'Locales not available', 1 unless locales_enabled('LC_CTYPE');\n            is(qr/abc$locale/,    '(?^:abc(?^l:\\b\\v$))', 'Verify retains l when interpolated outside locale and unicode strings');\n        }\n\n        is(qr/def$unicode/,    '(?^:def(?^u:\\b\\v$))', 'Verify retains u when interpolated outside locale and unicode strings');\n\n      SKIP: {\n            skip 'Locales not available', 2 unless locales_enabled('LC_CTYPE');\n\n             use locale;\n            is(qr/abc$dual/,    '(?^l:abc(?^:\\b\\v$))', 'Verify retains d meaning when interpolated under locale');\n            is(qr/abc$unicode/,    '(?^l:abc(?^u:\\b\\v$))', 'Verify retains u when interpolated under locale');\n        }\n    }\n\n    {\n        my $message = \"Look around\";\n        $_ = 'xabcx';\n        foreach my $ans ('', 'c') {\n            ok(/(?<=(?=a)..)((?=c)|.)/g, $message);\n            is($1, $ans, $message);\n        }\n    }\n\n    {\n        my $message = \"Empty clause\";\n        $_ = 'a';\n        foreach my $ans ('', 'a', '') {\n            ok(/^|a|$/g, $message);\n            is($&, $ans, $message);\n        }\n    }\n\n    {\n        sub prefixify {\n        my $message = \"Prefixify\";\n            {\n                my ($v, $a, $b, $res) = @_;\n                ok($v =~ s/\\Q$a\\E/$b/, $message);\n                is($v, $res, $message);\n            }\n        }\n\n        prefixify ('/a/b/lib/arch', \"/a/b/lib\", 'X/lib', 'X/lib/arch');\n        prefixify ('/a/b/man/arch', \"/a/b/man\", 'X/man', 'X/man/arch');\n    }\n\n    {\n        $_ = 'var=\"foo\"';\n        /(\\\")/;\n        ok $1 && /$1/, \"Capture a quote\";\n    }\n\n    {\n        no warnings 'closure';\n        my $message = '(?{ $var } refers to package vars';\n        package aa;\n        our $c = 2;\n        $::c = 3;\n        '' =~ /(?{ $c = 4 })/;\n        main::is($c, 4, $message);\n        main::is($::c, 3, $message);\n    }\n\n    {\n        is(eval 'q(a:[b]:) =~ /[x[:foo:]]/', undef);\n\tlike ($@, qr/POSIX class \\[:[^:]+:\\] unknown in regex/,\n\t      'POSIX class [: :] must have valid name');\n\n        for my $d (qw [= .]) {\n            is(eval \"/[[${d}foo${d}]]/\", undef);\n\t    like ($@, qr/\\QPOSIX syntax [$d $d] is reserved for future extensions/,\n\t\t  \"POSIX syntax [[$d $d]] is an error\");\n        }\n    }\n\n    {\n        # test if failure of patterns returns empty list\n        my $message = \"Failed pattern returns empty list\";\n        $_ = 'aaa';\n        @_ = /bbb/;\n        is(\"@_\", \"\", $message);\n\n        @_ = /bbb/g;\n        is(\"@_\", \"\", $message);\n\n        @_ = /(bbb)/;\n        is(\"@_\", \"\", $message);\n\n        @_ = /(bbb)/g;\n        is(\"@_\", \"\", $message);\n    }\n\n    {\n        my $message = '@- and @+ and @{^CAPTURE} tests';\n\n        $_= \"ace\";\n        /c(?=.$)/;\n        is($#{^CAPTURE}, -1, $message);\n        is($#+, 0, $message);\n        is($#-, 0, $message);\n        is($+ [0], 2, $message);\n        is($- [0], 1, $message);\n        ok(!defined $+ [1] && !defined $- [1] &&\n           !defined $+ [2] && !defined $- [2], $message);\n\n        /a(c)(e)/;\n        is($#{^CAPTURE}, 1, $message); # one less than $#-\n        is($#+, 2, $message);\n        is($#-, 2, $message);\n        is($+ [0], 3, $message);\n        is($- [0], 0, $message);\n        is(${^CAPTURE}[0], \"c\", $message);\n        is($+ [1], 2, $message);\n        is($- [1], 1, $message);\n        is(${^CAPTURE}[1], \"e\", $message);\n        is($+ [2], 3, $message);\n        is($- [2], 2, $message);\n        ok(!defined $+ [3] && !defined $- [3] &&\n           !defined ${^CAPTURE}[2] && !defined ${^CAPTURE}[3] &&\n           !defined $+ [4] && !defined $- [4], $message);\n\n        # Exists has a special check for @-/@+ - bug 45147\n        ok(exists $-[0], $message);\n        ok(exists $+[0], $message);\n        ok(exists ${^CAPTURE}[0], $message);\n        ok(exists ${^CAPTURE}[1], $message);\n        ok(exists $-[2], $message);\n        ok(exists $+[2], $message);\n        ok(!exists ${^CAPTURE}[2], $message);\n        ok(!exists $-[3], $message);\n        ok(!exists $+[3], $message);\n        ok(exists ${^CAPTURE}[-1], $message);\n        ok(exists ${^CAPTURE}[-2], $message);\n        ok(exists $-[-1], $message);\n        ok(exists $+[-1], $message);\n        ok(exists $-[-3], $message);\n        ok(exists $+[-3], $message);\n        ok(!exists $-[-4], $message);\n        ok(!exists $+[-4], $message);\n        ok(!exists ${^CAPTURE}[-3], $message);\n\n\n        /.(c)(b)?(e)/;\n        is($#{^CAPTURE}, 2, $message); # one less than $#-\n        is($#+, 3, $message);\n        is($#-, 3, $message);\n        is(${^CAPTURE}[0], \"c\", $message);\n        is(${^CAPTURE}[2], \"e\", $message . \"[$1 $3]\");\n        is($+ [1], 2, $message);\n        is($- [1], 1, $message);\n        is($+ [3], 3, $message);\n        is($- [3], 2, $message);\n        ok(!defined $+ [2] && !defined $- [2] &&\n           !defined $+ [4] && !defined $- [4] &&\n           !defined ${^CAPTURE}[1], $message);\n\n        /.(c)/;\n        is($#{^CAPTURE}, 0, $message); # one less than $#-\n        is($#+, 1, $message);\n        is($#-, 1, $message);\n        is(${^CAPTURE}[0], \"c\", $message);\n        is($+ [0], 2, $message);\n        is($- [0], 0, $message);\n        is($+ [1], 2, $message);\n        is($- [1], 1, $message);\n        ok(!defined $+ [2] && !defined $- [2] &&\n           !defined $+ [3] && !defined $- [3] &&\n           !defined ${^CAPTURE}[1], $message);\n\n        /.(c)(ba*)?/;\n        is($#{^CAPTURE}, 0, $message); # one less than $#-\n        is($#+, 2, $message);\n        is($#-, 1, $message);\n\n        # Check that values don\u2019t stick\n        \"     \"=~/()()()(.)(..)/;\n        my($m,$p,$q) = (\\$-[5], \\$+[5], \\${^CAPTURE}[4]);\n        () = \"$$_\" for $m, $p, $q; # FETCH (or eqv.)\n        \" \" =~ /()/;\n        is $$m, undef, 'values do not stick to @- elements';\n        is $$p, undef, 'values do not stick to @+ elements';\n        is $$q, undef, 'values do not stick to @{^CAPTURE} elements';\n    }\n\n    foreach ('$+[0] = 13', '$-[0] = 13', '@+ = (7, 6, 5)',\n             '${^CAPTURE}[0] = 13',\n\t     '@- = qw (foo bar)', '$^N = 42') {\n\tis(eval $_, undef);\n        like($@, qr/^Modification of a read-only value attempted/,\n\t     '$^N, @- and @+ are read-only');\n    }\n\n    {\n        my $message = '\\G testing';\n        $_ = 'aaa';\n        pos = 1;\n        my @a = /\\Ga/g;\n        is(\"@a\", \"a a\", $message);\n\n        my $str = 'abcde';\n        pos $str = 2;\n        unlike($str, qr/^\\G/, $message);\n        unlike($str, qr/^.\\G/, $message);\n        like($str, qr/^..\\G/, $message);\n        unlike($str, qr/^...\\G/, $message);\n        ok($str =~ /\\G../ && $& eq 'cd', $message);\n        ok($str =~ /.\\G./ && $& eq 'bc', $message);\n\n    }\n\n    {\n        my $message = '\\G and intuit and anchoring';\n\t$_ = \"abcdef\";\n\tpos = 0;\n\tok($_ =~ /\\Gabc/, $message);\n\tok($_ =~ /^\\Gabc/, $message);\n\n\tpos = 3;\n\tok($_ =~ /\\Gdef/, $message);\n\tpos = 3;\n\tok($_ =~ /\\Gdef$/, $message);\n\tpos = 3;\n\tok($_ =~ /abc\\Gdef$/, $message);\n\tpos = 3;\n\tok($_ =~ /^abc\\Gdef$/, $message);\n\tpos = 3;\n\tok($_ =~ /c\\Gd/, $message);\n\tpos = 3;\n\tok($_ =~ /..\\GX?def/, $message);\n    }\n\n    {\n        my $s = '123';\n        pos($s) = 1;\n        my @a = $s =~ /(\\d)\\G/g; # this infinitely looped up till 5.19.1\n        is(\"@a\", \"1\", '\\G looping');\n    }\n\n\n    {\n        my $message = 'pos inside (?{ })';\n        my $str = 'abcde';\n        our ($foo, $bar);\n        like($str, qr/b(?{$foo = $_; $bar = pos})c/, $message);\n        is($foo, $str, $message);\n        is($bar, 2, $message);\n        is(pos $str, undef, $message);\n\n        undef $foo;\n        undef $bar;\n        pos $str = undef;\n        ok($str =~ /b(?{$foo = $_; $bar = pos})c/g, $message);\n        is($foo, $str, $message);\n        is($bar, 2, $message);\n        is(pos $str, 3, $message);\n\n        $_ = $str;\n        undef $foo;\n        undef $bar;\n        like($_, qr/b(?{$foo = $_; $bar = pos})c/, $message);\n        is($foo, $str, $message);\n        is($bar, 2, $message);\n\n        undef $foo;\n        undef $bar;\n        ok(/b(?{$foo = $_; $bar = pos})c/g, $message);\n        is($foo, $str, $message);\n        is($bar, 2, $message);\n        is(pos, 3, $message);\n\n        undef $foo;\n        undef $bar;\n        pos = undef;\n        1 while /b(?{$foo = $_; $bar = pos})c/g;\n        is($foo, $str, $message);\n        is($bar, 2, $message);\n        is(pos, undef, $message);\n\n        undef $foo;\n        undef $bar;\n        $_ = 'abcde|abcde';\n        ok(s/b(?{$foo = $_; $bar = pos})c/x/g, $message);\n        is($foo, 'abcde|abcde', $message);\n        is($bar, 8, $message);\n        is($_, 'axde|axde', $message);\n\n        # List context:\n        $_ = 'abcde|abcde';\n        our @res;\n        () = /([ace]).(?{push @res, $1,$2})([ce])(?{push @res, $1,$2})/g;\n        @res = map {defined $_ ? \"'$_'\" : 'undef'} @res;\n        is(\"@res\", \"'a' undef 'a' 'c' 'e' undef 'a' undef 'a' 'c'\", $message);\n\n        @res = ();\n        () = /([ace]).(?{push @res, $`,$&,$'})([ce])(?{push @res, $`,$&,$'})/g;\n        @res = map {defined $_ ? \"'$_'\" : 'undef'} @res;\n        is(\"@res\", \"'' 'ab' 'cde|abcde' \" .\n                     \"'' 'abc' 'de|abcde' \" .\n                     \"'abcd' 'e|' 'abcde' \" .\n                     \"'abcde|' 'ab' 'cde' \" .\n                     \"'abcde|' 'abc' 'de'\", $message);\n    }\n\n    {\n        my $message = '\\G anchor checks';\n        my $foo = 'aabbccddeeffgg';\n        pos ($foo) = 1;\n\n\tok($foo =~ /.\\G(..)/g, $message);\n\tis($1, 'ab', $message);\n\n\tpos ($foo) += 1;\n\tok($foo =~ /.\\G(..)/g, $message);\n\tis($1, 'cc', $message);\n\n\tpos ($foo) += 1;\n\tok($foo =~ /.\\G(..)/g, $message);\n\tis($1, 'de', $message);\n\n\tok($foo =~ /\\Gef/g, $message);\n\n        undef pos $foo;\n        ok($foo =~ /\\G(..)/g, $message);\n        is($1, 'aa', $message);\n\n        ok($foo =~ /\\G(..)/g, $message);\n        is($1, 'bb', $message);\n\n        pos ($foo) = 5;\n        ok($foo =~ /\\G(..)/g, $message);\n        is($1, 'cd', $message);\n    }\n\n    {\n        my $message = 'basic \\G floating checks';\n        my $foo = 'aabbccddeeffgg';\n        pos ($foo) = 1;\n\n\tok($foo =~ /a+\\G(..)/g, \"$message: a+\\\\G\");\n\tis($1, 'ab', \"$message: ab\");\n\n\tpos ($foo) += 1;\n\tok($foo =~ /b+\\G(..)/g, \"$message: b+\\\\G\");\n\tis($1, 'cc', \"$message: cc\");\n\n\tpos ($foo) += 1;\n\tok($foo =~ /d+\\G(..)/g, \"$message: d+\\\\G\");\n\tis($1, 'de', \"$message: de\");\n\n\tok($foo =~ /\\Gef/g, \"$message: \\\\Gef\");\n\n        pos ($foo) = 1;\n\n\tok($foo =~ /(?=a+\\G)(..)/g, \"$message: (?a+\\\\G)\");\n\tis($1, 'aa', \"$message: aa\");\n\n        pos ($foo) = 2;\n\n\tok($foo =~ /a(?=a+\\G)(..)/g, \"$message: a(?=a+\\\\G)\");\n\tis($1, 'ab', \"$message: ab\");\n\n    }\n\n    {\n        $_ = '123x123';\n        my @res = /(\\d*|x)/g;\n        local $\" = '|';\n        is(\"@res\", \"123||x|123|\", \"0 match in alternation\");\n    }\n\n    {\n        my $message = \"Match against temporaries (created via pp_helem())\" .\n                         \" is safe\";\n        ok({foo => \"bar\\n\" . $^X} -> {foo} =~ /^(.*)\\n/g, $message);\n        is($1, \"bar\", $message);\n    }\n\n    {\n        my $message = 'package $i inside (?{ }), ' .\n                         'saved substrings and changing $_';\n        our @a = qw [foo bar];\n        our @b = ();\n        s/(\\w)(?{push @b, $1})/,$1,/g for @a;\n        is(\"@b\", \"f o o b a r\", $message);\n        is(\"@a\", \",f,,o,,o, ,b,,a,,r,\", $message);\n\n        $message = 'lexical $i inside (?{ }), ' .\n                         'saved substrings and changing $_';\n        no warnings 'closure';\n        my @c = qw [foo bar];\n        my @d = ();\n        s/(\\w)(?{push @d, $1})/,$1,/g for @c;\n        is(\"@d\", \"f o o b a r\", $message);\n        is(\"@c\", \",f,,o,,o, ,b,,a,,r,\", $message);\n    }\n\n    {\n        my $message = 'Brackets';\n        our $brackets;\n        $brackets = qr {\n            {  (?> [^{}]+ | (??{ $brackets }) )* }\n        }x;\n\n        ok(\"{{}\" =~ $brackets, $message);\n        is($&, \"{}\", $message);\n        ok(\"something { long { and } hairy\" =~ $brackets, $message);\n        is($&, \"{ and }\", $message);\n        ok(\"something { long { and } hairy\" =~ m/((??{ $brackets }))/, $message);\n        is($&, \"{ and }\", $message);\n    }\n\n    {\n        $_ = \"a-a\\nxbb\";\n        pos = 1;\n        ok(!m/^-.*bb/mg, '$_ = \"a-a\\nxbb\"; m/^-.*bb/mg');\n    }\n\n    {\n        my $message = '\\G anchor checks';\n        my $text = \"aaXbXcc\";\n        pos ($text) = 0;\n        ok($text !~ /\\GXb*X/g, $message);\n    }\n\n    {\n        $_ = \"xA\\n\" x 500;\n        unlike($_, qr/^\\s*A/m, '$_ = \"xA\\n\" x 500; /^\\s*A/m\"');\n\n        my $text = \"abc dbf\";\n        my @res = ($text =~ /.*?(b).*?\\b/g);\n        is(\"@res\", \"b b\", '\\b is not special');\n    }\n\n    {\n        my $message = '\\S, [\\S], \\s, [\\s]';\n        my @a = map chr, 0 .. 255;\n        my @b = grep m/\\S/, @a;\n        my @c = grep m/[^\\s]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\S/, @a;\n        @c = grep /[\\S]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\s/, @a;\n        @c = grep /[^\\S]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\s/, @a;\n        @c = grep /[\\s]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        # Test an inverted posix class with a char also in the class.\n        my $nbsp = chr utf8::unicode_to_native(0xA0);\n        my $non_s = chr utf8::unicode_to_native(0xA1);\n        my $pat_string = \"[^\\\\S ]\";\n        unlike(\" \", qr/$pat_string/, \"Verify ' ' !~ /$pat_string/\");\n        like(\"\\t\", qr/$pat_string/, \"Verify '\\\\t =~ /$pat_string/\");\n        unlike($nbsp, qr/$pat_string/, \"Verify non-utf8-NBSP !~ /$pat_string/\");\n        utf8::upgrade($nbsp);\n        like($nbsp, qr/$pat_string/, \"Verify utf8-NBSP =~ /$pat_string/\");\n        unlike($non_s, qr/$pat_string/, \"Verify non-utf8-inverted-bang !~ /$pat_string/\");\n        utf8::upgrade($non_s);\n        unlike($non_s, qr/$pat_string/, \"Verify utf8-inverted-bang !~ /$pat_string/\");\n    }\n    {\n        my $message = '\\D, [\\D], \\d, [\\d]';\n        my @a = map chr, 0 .. 255;\n        my @b = grep /\\D/, @a;\n        my @c = grep /[^\\d]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\D/, @a;\n        @c = grep /[\\D]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\d/, @a;\n        @c = grep /[^\\D]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\d/, @a;\n        @c = grep /[\\d]/, @a;\n        is(\"@b\", \"@c\", $message);\n    }\n    {\n        my $message = '\\W, [\\W], \\w, [\\w]';\n        my @a = map chr, 0 .. 255;\n        my @b = grep /\\W/, @a;\n        my @c = grep /[^\\w]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\W/, @a;\n        @c = grep /[\\W]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\w/, @a;\n        @c = grep /[^\\W]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\w/, @a;\n        @c = grep /[\\w]/, @a;\n        is(\"@b\", \"@c\", $message);\n    }\n\n    {\n        # see if backtracking optimization works correctly\n        my $message = 'Backtrack optimization';\n        like(\"\\n\\n\", qr/\\n   $ \\n/x, $message);\n        like(\"\\n\\n\", qr/\\n*  $ \\n/x, $message);\n        like(\"\\n\\n\", qr/\\n+  $ \\n/x, $message);\n        like(\"\\n\\n\", qr/\\n?  $ \\n/x, $message);\n        like(\"\\n\\n\", qr/\\n*? $ \\n/x, $message);\n        like(\"\\n\\n\", qr/\\n+? $ \\n/x, $message);\n        like(\"\\n\\n\", qr/\\n?? $ \\n/x, $message);\n        unlike(\"\\n\\n\", qr/\\n*+ $ \\n/x, $message);\n        unlike(\"\\n\\n\", qr/\\n++ $ \\n/x, $message);\n        like(\"\\n\\n\", qr/\\n?+ $ \\n/x, $message);\n    }\n\n    {\n        package S;\n        use overload '\"\"' => sub {'Object S'};\n        sub new {bless []}\n\n        my $message  = \"Ref stringification\";\n      ::ok(do { \\my $v} =~ /^SCALAR/,   \"Scalar ref stringification\") or diag($message);\n      ::ok(do {\\\\my $v} =~ /^REF/,      \"Ref ref stringification\") or diag($message);\n      ::ok([]           =~ /^ARRAY/,    \"Array ref stringification\") or diag($message);\n      ::ok({}           =~ /^HASH/,     \"Hash ref stringification\") or diag($message);\n      ::ok('S' -> new   =~ /^Object S/, \"Object stringification\") or diag($message);\n    }\n\n    {\n        my $message = \"Test result of match used as match\";\n        ok('a1b' =~ ('xyz' =~ /y/), $message);\n        is($`, 'a', $message);\n        ok('a1b' =~ ('xyz' =~ /t/), $message);\n        is($`, 'a', $message);\n    }\n\n    {\n        my $message = '\"1\" is not \\s';\n        warning_is(sub {unlike(\"1\\n\" x 102, qr/^\\s*\\n/m, $message)},\n\t\t   undef, \"$message (did not warn)\");\n    }\n\n    {\n        my $message = '\\s, [[:space:]] and [[:blank:]]';\n        my %space = (spc   => \" \",\n                     tab   => \"\\t\",\n                     cr    => \"\\r\",\n                     lf    => \"\\n\",\n                     ff    => \"\\f\",\n        # There's no \\v but the vertical tabulator seems miraculously\n        # be 11 both in ASCII and EBCDIC.\n                     vt    => chr(11),\n                     false => \"space\");\n\n        my @space0 = sort grep {$space {$_} =~ /\\s/         } keys %space;\n        my @space1 = sort grep {$space {$_} =~ /[[:space:]]/} keys %space;\n        my @space2 = sort grep {$space {$_} =~ /[[:blank:]]/} keys %space;\n\n        is(\"@space0\", \"cr ff lf spc tab vt\", $message);\n        is(\"@space1\", \"cr ff lf spc tab vt\", $message);\n        is(\"@space2\", \"spc tab\", $message);\n    }\n\n    {\n        my $n= 50;\n        # this must be a high number and go from 0 to N, as the bug we are looking for doesn't\n        # seem to be predictable. Slight changes to the test make it fail earlier or later.\n        foreach my $i (0 .. $n)\n        {\n            my $str= \"\\n\" x $i;\n            ok $str=~/.*\\z/, \"implicit MBOL check string disable does not break things length=$i\";\n        }\n    }\n    {\n        # we are actually testing that we dont die when executing these patterns\n        use utf8;\n        my $e = \"B\u00f6ck\";\n        ok(utf8::is_utf8($e),\"got a unicode string - rt75680\");\n\n        ok($e !~ m/.*?[x]$/, \"unicode string against /.*?[x]\\$/ - rt75680\");\n        ok($e !~ m/.*?\\p{Space}$/i, \"unicode string against /.*?\\\\p{space}\\$/i - rt75680\");\n        ok($e !~ m/.*?[xyz]$/, \"unicode string against /.*?[xyz]\\$/ - rt75680\");\n        ok($e !~ m/(.*?)[,\\p{isSpace}]+((?:\\p{isAlpha}[\\p{isSpace}\\.]{1,2})+)\\p{isSpace}*$/, \"unicode string against big pattern - rt75680\");\n    }\n    {\n        # we are actually testing that we dont die when executing these patterns\n        my $e = \"B\" . uni_to_native(\"\\x{f6}\") . \"ck\";\n        ok(!utf8::is_utf8($e), \"got a latin string - rt75680\");\n\n        ok($e !~ m/.*?[x]$/, \"latin string against /.*?[x]\\$/ - rt75680\");\n        ok($e !~ m/.*?\\p{Space}$/i, \"latin string against /.*?\\\\p{space}\\$/i - rt75680\");\n        ok($e !~ m/.*?[xyz]$/,\"latin string against /.*?[xyz]\\$/ - rt75680\");\n        ok($e !~ m/(.*?)[,\\p{isSpace}]+((?:\\p{isAlpha}[\\p{isSpace}\\.]{1,2})+)\\p{isSpace}*$/,\"latin string against big pattern - rt75680\");\n    }\n\n    {\n        #\n        # Tests for bug 77414.\n        #\n\n        my $message = '\\p property after empty * match';\n        {\n            like(\"1\", qr/\\s*\\pN/, $message);\n            like(\"-\", qr/\\s*\\p{Dash}/, $message);\n            like(\" \", qr/\\w*\\p{Blank}/, $message);\n        }\n\n        like(\"1\", qr/\\s*\\pN+/, $message);\n        like(\"-\", qr/\\s*\\p{Dash}{1}/, $message);\n        like(\" \", qr/\\w*\\p{Blank}{1,4}/, $message);\n\n    }\n\n    {   # Some constructs with Latin1 characters cause a utf8 string not\n        # to match itself in non-utf8\n        my $c = uni_to_native(\"\\xc0\");\n        my $pattern = my $utf8_pattern = qr/(($c)+,?)/;\n        utf8::upgrade($utf8_pattern);\n        ok $c =~ $pattern, \"\\\\xc0 =~ $pattern; Neither pattern nor target utf8\";\n        ok $c =~ /$pattern/i, \"\\\\xc0 =~ /$pattern/i; Neither pattern nor target utf8\";\n        ok $c =~ $utf8_pattern, \"\\\\xc0 =~ $pattern; pattern utf8, target not\";\n        ok $c =~ /$utf8_pattern/i, \"\\\\xc0 =~ /$pattern/i; pattern utf8, target not\";\n        utf8::upgrade($c);\n        ok $c =~ $pattern, \"\\\\xc0 =~ $pattern; target utf8, pattern not\";\n        ok $c =~ /$pattern/i, \"\\\\xc0 =~ /$pattern/i; target utf8, pattern not\";\n        ok $c =~ $utf8_pattern, \"\\\\xc0 =~ $pattern; Both target and pattern utf8\";\n        ok $c =~ /$utf8_pattern/i, \"\\\\xc0 =~ /$pattern/i; Both target and pattern utf8\";\n    }\n\n    {   # Make sure can override the formatting\n        use feature 'unicode_strings';\n        ok uni_to_native(\"\\xc0\") =~ /\\w/, 'Under unicode_strings: \"\\xc0\" =~ /\\w/';\n        ok uni_to_native(\"\\xc0\") !~ /(?d:\\w)/, 'Under unicode_strings: \"\\xc0\" !~ /(?d:\\w)/';\n    }\n\n    {\n        my $str= \"\\x{100}\";\n        chop $str;\n        my $qr= qr/$str/;\n        is(\"$qr\", \"(?^:)\", \"Empty pattern qr// stringifies to (?^:) with unicode flag enabled - Bug #80212\");\n        $str= \"\";\n        $qr= qr/$str/;\n        is(\"$qr\", \"(?^:)\", \"Empty pattern qr// stringifies to (?^:) with unicode flag disabled - Bug #80212\");\n\n    }\n\n    {\n        local $::TODO = \"[perl #38133]\";\n\n        \"A\" =~ /(((?:A))?)+/;\n        my $first = $2;\n\n        \"A\" =~ /(((A))?)+/;\n        my $second = $2;\n\n        is($first, $second);\n    }\n\n    {\n\t# RT #3516: \\G in a m//g expression causes problems\n\tmy $count = 0;\n\twhile (\"abc\" =~ m/(\\G[ac])?/g) {\n\t    last if $count++ > 10;\n\t}\n\tok($count < 10, 'RT #3516 A');\n\n\t$count = 0;\n\twhile (\"abc\" =~ m/(\\G|.)[ac]/g) {\n\t    last if $count++ > 10;\n\t}\n\tok($count < 10, 'RT #3516 B');\n\n\t$count = 0;\n\twhile (\"abc\" =~ m/(\\G?[ac])?/g) {\n\t    last if $count++ > 10;\n\t}\n\tok($count < 10, 'RT #3516 C');\n    }\n    {\n        # RT #84294: Is this a bug in the simple Perl regex?\n        #          : Nested buffers and (?{...}) dont play nicely on partial matches\n        our @got= ();\n        ok(\"ab\" =~ /((\\w+)(?{ push @got, $2 })){2}/,\"RT #84294: Pattern should match\");\n        my $want= \"'ab', 'a', 'b'\";\n        my $got= join(\", \", map { defined($_) ? \"'$_'\" : \"undef\" } @got);\n        is($got,$want,'RT #84294: check that \"ab\" =~ /((\\w+)(?{ push @got, $2 })){2}/ leaves @got in the correct state');\n    }\n\n    {\n        # Suppress warnings, as the non-unicode one comes out even if turn off\n        # warnings here (because the execution is done in another scope).\n        local $SIG{__WARN__} = sub {};\n        my $str = \"\\x{110000}\";\n\n        unlike($str, qr/\\p{ASCII_Hex_Digit=True}/, \"Non-Unicode doesn't match \\\\p{AHEX=True}\");\n        like($str, qr/\\p{ASCII_Hex_Digit=False}/, \"Non-Unicode matches \\\\p{AHEX=False}\");\n        like($str, qr/\\P{ASCII_Hex_Digit=True}/, \"Non-Unicode matches \\\\P{AHEX=True}\");\n        unlike($str, qr/\\P{ASCII_Hex_Digit=False}/, \"Non-Unicode matches \\\\P{AHEX=FALSE}\");\n    }\n\n    {\n        # Test that IDstart works, but because the author (khw) knows\n        # regexes much better than the rest of the core, it is being done here\n        # in the context of a regex which relies on buffer names beginng with\n        # IDStarts.\n        use utf8;\n        my $str = \"abc\";\n        like($str, qr/(?<a>abc)/, \"'a' is legal IDStart\");\n        like($str, qr/(?<_>abc)/, \"'_' is legal IDStart\");\n        like($str, qr/(?<\u00df>abc)/, \"U+00DF is legal IDStart\");\n        like($str, qr/(?<\u2115>abc)/, \"U+2115' is legal IDStart\");\n\n        # This test works on Unicode 6.0 in which U+2118 and U+212E are legal\n        # IDStarts there, but are not Word characters, and therefore Perl\n        # doesn't allow them to be IDStarts.  But there is no guarantee that\n        # Unicode won't change things around in the future so that at some\n        # future Unicode revision these tests would need to be revised.\n        foreach my $char (\"%\", \"\u00d7\", chr(0x2118), chr(0x212E)) {\n            my $prog = <<\"EOP\";\nuse utf8;;\n\"abc\" =~ qr/(?<$char>abc)/;\nEOP\n            utf8::encode($prog);\n            fresh_perl_like($prog, qr!Group name must start with a non-digit word character!, {},\n                        sprintf(\"'U+%04X not legal IDFirst'\", ord($char)));\n        }\n    }\n\n    { # [perl #101710]\n        my $pat = \"b\";\n        utf8::upgrade($pat);\n        like(\"\\xffb\", qr/$pat/i, \"/i: utf8 pattern, non-utf8 string, latin1-char preceding matching char in string\");\n    }\n\n    { # Crash with @a =~ // warning\n\tlocal $SIG{__WARN__} = sub {\n             pass 'no crash for @a =~ // warning'\n        };\n\teval ' sub { my @a =~ // } ';\n    }\n\n    { # Concat overloading and qr// thingies\n\tmy @refs;\n\tmy $qr = qr//;\n        package Cat {\n            require overload;\n            overload->import(\n\t\t'\"\"' => sub { ${$_[0]} },\n\t\t'.' => sub {\n\t\t    push @refs, ref $_[1] if ref $_[1];\n\t\t    bless $_[2] ? \\\"$_[1]${$_[0]}\" : \\\"${$_[0]}$_[1]\"\n\t\t}\n            );\n\t}\n\tmy $s = \"foo\";\n\tmy $o = bless \\$s, Cat::;\n\t/$o$qr/;\n\tis \"@refs\", \"Regexp\", '/$o$qr/ passes qr ref to cat overload meth';\n    }\n\n    {\n        my $count=0;\n        my $str=\"\\n\";\n        $count++ while $str=~/.*/g;\n        is $count, 2, 'test that ANCH_MBOL works properly. We should get 2 from $count++ while \"\\n\"=~/.*/g';\n        my $class_count= 0;\n        $class_count++ while $str=~/[^\\n]*/g;\n        is $class_count, $count, 'while \"\\n\"=~/.*/g and while \"\\n\"=~/[^\\n]*/g should behave the same';\n        my $anch_count= 0;\n        $anch_count++ while $str=~/^.*/mg;\n        is $anch_count, 1, 'while \"\\n\"=~/^.*/mg should match only once';\n    }\n\n    { # [perl #111174]\n        use re '/u';\n        my $A_grave = uni_to_native(\"\\xc0\");\n        like uni_to_native(\"\\xe0\"), qr/(?i:$A_grave)/, \"(?i: shouldn't lose the passed in /u\";\n        use re '/a';\n        unlike \"\\x{100}\", qr/(?i:\\w)/, \"(?i: shouldn't lose the passed in /a\";\n        use re '/aa';\n        unlike 'k', qr/(?i:\\N{KELVIN SIGN})/, \"(?i: shouldn't lose the passed in /aa\";\n        unlike 'k', qr'(?i:\\N{KELVIN SIGN})', \"(?i: shouldn't lose the passed in /aa\";\n    }\n\n    {\n\t# the test for whether the pattern should be re-compiled should\n\t# consider the UTF8ness of the previous and current pattern\n\t# string, as well as the physical bytes of the pattern string\n\n\tfor my $s (byte_utf8a_to_utf8n(\"\\xc4\\x80\"), \"\\x{100}\") {\n\t    ok($s =~ /^$s$/, \"re-compile check is UTF8-aware\");\n\t}\n    }\n\n    #  #113682 more overloading and qr//\n    # when doing /foo$overloaded/, if $overloaded returns\n    # a qr/(?{})/ via qr or \"\" overloading, then 'use re 'eval'\n    # shouldn't be required. Via '.', it still is.\n    {\n        package Qr0;\n\tuse overload 'qr' => sub { qr/(??{50})/ };\n\n        package Qr1;\n\tuse overload '\"\"' => sub { qr/(??{51})/ };\n\n        package Qr2;\n\tuse overload '.'  => sub { $_[1] . qr/(??{52})/ };\n\n        package Qr3;\n\tuse overload '\"\"' => sub { qr/(??{7})/ },\n\t\t     '.'  => sub { $_[1] . qr/(??{53})/ };\n\n        package Qr_indirect;\n\tuse overload '\"\"'  => sub { $_[0][0] };\n\n\tpackage main;\n\n\tfor my $i (0..3) {\n\t    my $o = bless [], \"Qr$i\";\n\t    if ((0,0,1,1)[$i]) {\n\t\teval { \"A5$i\" =~ /^A$o$/ };\n\t\tlike($@, qr/Eval-group not allowed/, \"Qr$i\");\n\t\teval { \"5$i\" =~ /$o/ };\n\t\tlike($@, ($i == 3 ? qr/^$/ : qr/no method found,/),\n\t\t\t\"Qr$i bare\");\n\t\t{\n\t\t    use re 'eval';\n\t\t    ok(\"A5$i\" =~ /^A$o$/, \"Qr$i - with use re eval\");\n\t\t    eval { \"5$i\" =~ /$o/ };\n\t\t    like($@, ($i == 3 ? qr/^$/ : qr/no method found,/),\n\t\t\t    \"Qr$i bare - with use re eval\");\n\t\t}\n\t    }\n\t    else {\n\t\tok(\"A5$i\" =~ /^A$o$/, \"Qr$i\");\n\t\tok(\"5$i\" =~ /$o/, \"Qr$i bare\");\n\t    }\n\t}\n\n\tmy $o = bless [ bless [], \"Qr1\" ], 'Qr_indirect';\n\tok(\"A51\" =~ /^A$o/, \"Qr_indirect\");\n\tok(\"51\" =~ /$o/, \"Qr_indirect bare\");\n    }\n\n    {   # Various flags weren't being set when a [] is optimized into an\n        # EXACTish node\n        ok(\"\\x{017F}\\x{017F}\" =~ qr/^[$sharp_s]?$/i, \"[] to EXACTish optimization\");\n    }\n\n    {\n        for my $char (\":\", uni_to_native(\"\\x{f7}\"), \"\\x{2010}\") {\n            my $utf8_char = $char;\n            utf8::upgrade($utf8_char);\n            my $display = $char;\n            $display = display($display);\n            my $utf8_display = \"utf8::upgrade(\\\"$display\\\")\";\n\n            like($char, qr/^$char?$/, \"\\\"$display\\\" =~ /^$display?\\$/\");\n            like($char, qr/^$utf8_char?$/, \"my \\$p = \\\"$display\\\"; utf8::upgrade(\\$p); \\\"$display\\\" =~ /^\\$p?\\$/\");\n            like($utf8_char, qr/^$char?$/, \"my \\$c = \\\"$display\\\"; utf8::upgrade(\\$c); \\\"\\$c\\\" =~ /^$display?\\$/\");\n            like($utf8_char, qr/^$utf8_char?$/, \"my \\$c = \\\"$display\\\"; utf8::upgrade(\\$c); my \\$p = \\\"$display\\\"; utf8::upgrade(\\$p); \\\"\\$c\\\" =~ /^\\$p?\\$/\");\n        }\n    }\n\n    {\n\t# #116148: Pattern utf8ness sticks around globally\n\t# the utf8 in the first match was sticking around for the second\n\t# match\n\n\tuse feature 'unicode_strings';\n\n\tmy $x = \"\\x{263a}\";\n\t$x =~ /$x/;\n\n\tmy $text = \"Perl\";\n\tok(\"Perl\" =~ /P.*$/i, '#116148');\n    }\n\n    { # 118297: Mixing up- and down-graded strings in regex\n        utf8::upgrade(my $u = \"\\x{e5}\");\n        utf8::downgrade(my $d = \"\\x{e5}\");\n        my $warned;\n        local $SIG{__WARN__} = sub { $warned++ if $_[0] =~ /\\AMalformed UTF-8/ };\n        my $re = qr/$u$d/;\n        ok(!$warned, \"no warnings when interpolating mixed up-/downgraded strings in pattern\");\n        my $c = \"\\x{e5}\\x{e5}\";\n        utf8::downgrade($c);\n        like($c, $re, \"mixed up-/downgraded pattern matches downgraded string\");\n        utf8::upgrade($c);\n        like($c, $re, \"mixed up-/downgraded pattern matches upgraded string\");\n    }\n\n    {\n        # if we have 87 capture buffers defined then \\87 should refer to the 87th.\n        # test that this is true for 1..100\n        # Note that this test causes the engine to recurse at runtime, and\n        # hence use a lot of C stack.\n\n        # Compiling for all 100 nested captures blows the stack under\n        # clang and ASan; reduce.\n        my $max_captures = $Config{ccflags} =~ /sanitize/ ? 20 : 100;\n\n        for my $i (1..100) {\n            if ($i > $max_captures) {\n                pass(\"skipping $i buffers under ASan aa\");\n                pass(\"skipping $i buffers under ASan aba\");\n                next;\n            }\n            my $capture= \"a\";\n            $capture= \"($capture)\" for 1 .. $i;\n            for my $mid (\"\",\"b\") {\n                my $str= \"a${mid}a\";\n                my $backref= \"\\\\$i\";\n                eval {\n                    ok($str=~/$capture$mid$backref/,\"\\\\$i works with $i buffers '$str'=~/...$mid$backref/\");\n                    1;\n                } or do {\n                    is(\"$@\",\"\",\"\\\\$i works with $i buffers works with $i buffers '$str'=~/...$mid$backref/\");\n                };\n            }\n        }\n    }\n\n    # this mixture of readonly (not COWable) and COWable strings\n    # messed up the capture buffers under COW. The actual test results\n    # are incidental; the issue is was an AddressSanitizer failure\n    {\n\tmy $c ='AB';\n\tmy $res = '';\n\tfor ($c, 'C', $c, 'DE') {\n\t    ok(/(.)/, \"COWable match\");\n\t    $res .= $1;\n\t}\n\tis($res, \"ACAD\");\n    }\n\n\n    {\n\t# RT #45667\n\t# /[#$x]/x didn't interpolate the var $x.\n\tmy $b = 'cd';\n\tmy $s = 'abcd$%#&';\n\t$s =~ s/[a#$b%]/X/g;\n\tis ($s, 'XbXX$XX&', 'RT #45667 without /x');\n\t$s = 'abcd$%#&';\n\t$s =~ s/[a#$b%]/X/gx;\n\tis ($s, 'XbXX$XX&', 'RT #45667 with /x');\n    }\n\n    {\n\tno warnings \"uninitialized\";\n\tmy @a;\n\t$a[1]++;\n\t/@a/;\n\tpass('no crash with /@a/ when array has nonexistent elems');\n    }\n\n    {\n\tis runperl(prog => 'delete $::{qq-\\cR-}; //; print qq-ok\\n-'),\n\t   \"ok\\n\",\n\t   'deleting *^R does not result in crashes';\n\tno warnings 'once';\n\t*^R = *caretRglobwithnoscalar;\n\t\"\" =~ /(?{42})/;\n\tis $^R, 42, 'assigning to *^R does not result in a crash';\n\tis runperl(\n\t     stderr => 1,\n\t     prog => 'eval q|'\n\t            .' q-..- =~ /(??{undef *^R;q--})(?{42})/; '\n                    .' print qq-$^R\\n-'\n\t            .'|'\n\t   ),\n\t   \"42\\n\",\n\t   'undefining *^R within (??{}) does not result in a crash';\n    }\n\n    SKIP: {   # Test literal range end point special handling\n        unless ($::IS_EBCDIC) {\n            skip \"Valid only for EBCDIC\", 24;\n        }\n\n        like(\"\\x89\", qr/[i-j]/, '\"\\x89\" should match [i-j]');\n        unlike(\"\\x8A\", qr/[i-j]/, '\"\\x8A\" shouldnt match [i-j]');\n        unlike(\"\\x90\", qr/[i-j]/, '\"\\x90\" shouldnt match [i-j]');\n        like(\"\\x91\", qr/[i-j]/, '\"\\x91\" should match [i-j]');\n\n        like(\"\\x89\", qr/[i-\\N{LATIN SMALL LETTER J}]/, '\"\\x89\" should match [i-\\N{LATIN SMALL LETTER J}]');\n        unlike(\"\\x8A\", qr/[i-\\N{LATIN SMALL LETTER J}]/, '\"\\x8A\" shouldnt match [i-\\N{LATIN SMALL LETTER J}]');\n        unlike(\"\\x90\", qr/[i-\\N{LATIN SMALL LETTER J}]/, '\"\\x90\" shouldnt match [i-\\N{LATIN SMALL LETTER J}]');\n        like(\"\\x91\", qr/[i-\\N{LATIN SMALL LETTER J}]/, '\"\\x91\" should match [i-\\N{LATIN SMALL LETTER J}]');\n\n        like(\"\\x89\", qr/[i-\\N{U+6A}]/, '\"\\x89\" should match [i-\\N{U+6A}]');\n        unlike(\"\\x8A\", qr/[i-\\N{U+6A}]/, '\"\\x8A\" shouldnt match [i-\\N{U+6A}]');\n        unlike(\"\\x90\", qr/[i-\\N{U+6A}]/, '\"\\x90\" shouldnt match [i-\\N{U+6A}]');\n        like(\"\\x91\", qr/[i-\\N{U+6A}]/, '\"\\x91\" should match [i-\\N{U+6A}]');\n\n        like(\"\\x89\", qr/[\\N{U+69}-\\N{U+6A}]/, '\"\\x89\" should match [\\N{U+69}-\\N{U+6A}]');\n        unlike(\"\\x8A\", qr/[\\N{U+69}-\\N{U+6A}]/, '\"\\x8A\" shouldnt match [\\N{U+69}-\\N{U+6A}]');\n        unlike(\"\\x90\", qr/[\\N{U+69}-\\N{U+6A}]/, '\"\\x90\" shouldnt match [\\N{U+69}-\\N{U+6A}]');\n        like(\"\\x91\", qr/[\\N{U+69}-\\N{U+6A}]/, '\"\\x91\" should match [\\N{U+69}-\\N{U+6A}]');\n\n        like(\"\\x89\", qr/[i-\\x{91}]/, '\"\\x89\" should match [i-\\x{91}]');\n        like(\"\\x8A\", qr/[i-\\x{91}]/, '\"\\x8A\" should match [i-\\x{91}]');\n        like(\"\\x90\", qr/[i-\\x{91}]/, '\"\\x90\" should match [i-\\x{91}]');\n        like(\"\\x91\", qr/[i-\\x{91}]/, '\"\\x91\" should match [i-\\x{91}]');\n\n        # Need to use eval, because tries to compile on ASCII platforms even\n        # though the tests are skipped, and fails because 0x89-j is an illegal\n        # range there.\n        like(\"\\x89\", eval 'qr/[\\x{89}-j]/', '\"\\x89\" should match [\\x{89}-j]');\n        like(\"\\x8A\", eval 'qr/[\\x{89}-j]/', '\"\\x8A\" should match [\\x{89}-j]');\n        like(\"\\x90\", eval 'qr/[\\x{89}-j]/', '\"\\x90\" should match [\\x{89}-j]');\n        like(\"\\x91\", eval 'qr/[\\x{89}-j]/', '\"\\x91\" should match [\\x{89}-j]');\n    }\n\n    # These are based on looking at the code in regcomp.c\n    # We don't look for specific code, just the existence of an SSC\n    foreach my $re (qw(     qr/a?c/\n                            qr/a?c/i\n                            qr/[ab]?c/\n                            qr/\\R?c/\n                            qr/\\d?c/d\n                            qr/\\w?c/l\n                            qr/\\s?c/a\n                            qr/[[:lower:]]?c/u\n    )) {\n      SKIP: {\n        skip \"no re-debug under miniperl\" if is_miniperl;\n        my $prog = <<\"EOP\";\nuse re qw(Debug COMPILE);\n$re;\nEOP\n        fresh_perl_like($prog, qr/synthetic stclass/, { stderr=>1 }, \"$re generates a synthetic start class\");\n      }\n    }\n\n    {\n        like \"\\x{AA}\", qr/a?[\\W_]/d, \"\\\\W with /d synthetic start class works\";\n    }\n\n    SKIP: {\n        skip(\"Tests are ASCII-centric, some would fail on EBCDIC\", 12) if $::IS_EBCDIC;\n\n        # Verify that the very last Latin-1 U+00FF\n        # (LATIN SMALL LETTER Y WITH DIAERESIS)\n        # and its UPPER counterpart (U+0178 which is pure Unicode),\n        # and likewise for the very first pure Unicode\n        # (LATIN CAPITAL LETTER A WITH MACRON) fold-match properly,\n        # and there are no off-by-one logic errors in the transition zone.\n\n        ok(\"\\xFF\" =~ /\\xFF/i, \"Y WITH DIAERESIS l =~ l\");\n        ok(\"\\xFF\" =~ /\\x{178}/i, \"Y WITH DIAERESIS l =~ u\");\n        ok(\"\\x{178}\" =~ /\\xFF/i, \"Y WITH DIAERESIS u =~ l\");\n        ok(\"\\x{178}\" =~ /\\x{178}/i, \"Y WITH DIAERESIS u =~ u\");\n\n        # U+00FF with U+05D0 (non-casing Hebrew letter).\n        ok(\"\\xFF\\x{5D0}\" =~ /\\xFF\\x{5D0}/i, \"Y WITH DIAERESIS l =~ l\");\n        ok(\"\\xFF\\x{5D0}\" =~ /\\x{178}\\x{5D0}/i, \"Y WITH DIAERESIS l =~ u\");\n        ok(\"\\x{178}\\x{5D0}\" =~ /\\xFF\\x{5D0}/i, \"Y WITH DIAERESIS u =~ l\");\n        ok(\"\\x{178}\\x{5D0}\" =~ /\\x{178}\\x{5D0}/i, \"Y WITH DIAERESIS u =~ u\");\n\n        # U+0100.\n        ok(\"\\x{100}\" =~ /\\x{100}/i, \"A WITH MACRON u =~ u\");\n        ok(\"\\x{100}\" =~ /\\x{101}/i, \"A WITH MACRON u =~ l\");\n        ok(\"\\x{101}\" =~ /\\x{100}/i, \"A WITH MACRON l =~ u\");\n        ok(\"\\x{101}\" =~ /\\x{101}/i, \"A WITH MACRON l =~ l\");\n    }\n\n    {\n        use utf8;\n        ok(\"abc\" =~ /a\u0085b\u0085c/x, \"NEL is white-space under /x\");\n    }\n\n    {\n        ok('a(b)c' =~ qr(a\\(b\\)c), \"'\\\\(' is a literal in qr(...)\");\n        ok('a[b]c' =~ qr[a\\[b\\]c], \"'\\\\[' is a literal in qr[...]\");\n        ok('a{3}c' =~ qr{a\\{3\\}c},  # Only failed when { could be a meta\n              \"'\\\\{' is a literal in qr{...}, where it could be a quantifier\");\n\n        # This one is for completeness\n        ok('a<b>c' =~ qr<a\\<b\\>c>, \"'\\\\<' is a literal in qr<...>)\");\n    }\n\n    {   # Was getting optimized into EXACT (non-folding node)\n        my $x = qr/[x]/i;\n        utf8::upgrade($x);\n        like(\"X\", qr/$x/, \"UTF-8 of /[x]/i matches upper case\");\n    }\n\nSKIP: {   # make sure we get an error when \\p{} cannot load Unicode tables\n        skip(\"Unicode tables always now loaded\", 1);\n        fresh_perl_like(<<'        prog that cannot load uni tables',\n            BEGIN {\n                @INC = '../lib';\n                require utf8; require 'utf8_heavy.pl';\n                @INC = ();\n            }\n            $name = 'A B';\n            if ($name =~ /(\\p{IsUpper}) (\\p{IsUpper})/){\n                print \"It's good! >$1< >$2<\\n\";\n            } else {\n                print \"It's not good...\\n\";\n            }\n        prog that cannot load uni tables\n                  qr/^Can't locate unicore\\/Heavy\\.pl(?x:\n                   )|^Can't find Unicode property definition/,\n                  undef,\n                 '\\p{} should not fail silently when uni tables evanesce');\n    }\n\n    {   # Special handling of literal-ended ranges in [...] was breaking this\n        use utf8;\n        like(\"\u00ff\", qr/[\u00ff-\u00ff]/, \"\\\"\u00ff\\\" should match [\u00ff-\u00ff]\");\n    }\n\n    {\t# [perl #123539]\n        like(\"TffffffffffffTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff\", qr/TffffffffffffTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff/il, \"\");\n        like(\"TffffffffffffT\\x{100}TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff\", qr/TffffffffffffT\\x{100}TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff/il, \"\");\n    }\n\n\t{\t# [perl #123604]\n\t\tmy($s, $x, @x) = ('abc', 'a', 'd');\n\t\tmy $long = 'b' x 2000;\n\t\tmy $eval = q{$s =~ m{$x[bbb]c} ? 1 : 0};\n\t\t$eval =~ s{bbb}{$long};\n\t\tmy $match = eval $eval;\n\t\tok(1, \"did not crash\");\n\t\tok($match, \"[bbb...] resolved as character class, not subscript\");\n\t}\n\n\t{\t# [perl #123755]\n\t\tfor my $pat ('(??', '(?P', '(?i-') {\n\t\t\teval qq{ qr/$pat/ };\n\t\t\tok(1, \"qr/$pat/ did not crash\");\n\t\t\teval qq{ qr/${pat}\\x{123}/ };\n\t\t\tmy $e = $@;\n\t\t\tlike($e, qr{\\x{123}},\n\t\t\t\t\"qr/${pat}x/ shows x in error even if it's a wide character\");\n\t\t}\n\t}\n\n\t{\n\t\t# Expect one of these sizes to cause overflow and wrap to negative\n\t\tfor my $bits (32, 64) {\n\t\t\tmy $wrapneg = 2 ** ($bits - 2) * 3;\n\t\t\tfor my $sign ('', '-') {\n\t\t\t\tmy $pat = sprintf \"qr/(?%s%u)/\", $sign, $wrapneg;\n\t\t\t\teval $pat;\n\t\t\t\tok(1, \"big backref $pat did not crash\");\n\t\t\t}\n\t\t}\n\t}\n        {\n            # Test that we handle qr/\\8888888/ and variants without an infinite loop,\n            # we use a test within a test so we can todo it, and make sure we don't\n            # infinite loop our tests.\n            # NOTE - Do not put quotes in the code!\n            # NOTE - We have to triple escape the backref in the pattern below.\n            my $code='\n                BEGIN{require q(./test.pl);}\n                watchdog(3);\n                for my $len (1 .. 20) {\n                    my $eights= q(8) x $len;\n                    eval qq{ qr/\\\\\\\\$eights/ };\n                }\n                print q(No infinite loop here!);\n            ';\n            fresh_perl_is($code, \"No infinite loop here!\", {},\n                \"test that we handle things like m/\\\\888888888/ without infinite loops\" );\n        }\n\n        {   # Test that we handle some malformed UTF-8 without looping [perl\n            # #123562]\n\n            my $code='\n                BEGIN{require q(./test.pl);}\n                use Encode qw(_utf8_on);\n                # \\x80 and \\x41 are continuation bytes in their respective\n                # character sets\n                my $malformed = (ord(\"A\") == 65) ? \"a\\x80\\n\" : \"a\\x41\\n\";\n                utf8::downgrade($malformed);\n                _utf8_on($malformed);\n                watchdog(3);\n                $malformed =~ /(\\n\\r|\\r)$/;\n                print q(No infinite loop here!);\n            ';\n            fresh_perl_like($code, qr/Malformed UTF-8 character/, {},\n                \"test that we handle some UTF-8 malformations without looping\" );\n        }\n\n\t{\n\t\t# [perl #123843] hits SEGV trying to compile this pattern\n\t\tmy $match;\n\t\teval q{ ($match) = (\"xxyxxyxy\" =~ m{(x+(y(?1))*)}) };\n\t\tok(1, \"compiled GOSUB in CURLYM ok\");\n\t\tis($match, 'xxyxxyx', \"matched GOSUB in CURLYM\");\n\t}\n\n\t{\n\t\t# [perl #123852] doesn't avoid all the capture-related work with\n\t\t# //n, leading to possible memory corruption\n\t\teval q{ qr{()(?1)}n };\n\t\tmy $error = $@;\n\t\tok(1, \"qr{()(?1)}n didn't crash\");\n\t\tlike($error, qr{Reference to nonexistent group},\n\t\t\t\t'gave appropriate error for qr{()(?1)}n');\n\t}\n\n\t{\n            # [perl #126406] panic with unmatchable quantifier\n            my $code='\n                no warnings \"regexp\";\n                \"\" =~ m/(.0\\N{6,0}0\\N{6,0}000000000000000000000000000000000)/;\n            ';\n            fresh_perl_is($code, \"\", {},\n                            \"perl [#126406] panic\");\n\t}\n        {\n            my $bug=\"[perl #126182]\"; # test for infinite pattern recursion\n            for my $tuple (\n                    [ 'q(a)=~/(.(?2))((?<=(?=(?1)).))/', \"died\", \"look ahead left recursion fails fast\" ],\n                    [ 'q(aa)=~/(?R)a/', \"died\", \"left-recursion fails fast\", ],\n                    [ 'q(bbaa)=~/(?&x)(?(DEFINE)(?<x>(?&y)*a)(?<y>(?&x)*b))/',\n                        \"died\", \"inter-cyclic optional left recursion dies\" ],\n                    [ 'q(abc) =~ /a((?1)?)c/', \"died\", \"optional left recursion dies\" ],\n                    [ 'q(abc) =~ /a((?1)??)c/', \"died\", \"min mod left recursion dies\" ],\n                    [ 'q(abc) =~ /a((?1)*)c/', \"died\", \"* left recursion dies\" ],\n                    [ 'q(abc) =~ /a((?1)+)c/', \"died\", \"+ left recursion dies\" ],\n                    [ 'q(abc) =~ /a((?1){0,3})c/', \"died\", \"{0,3} left recursion fails fast\" ],\n\n                    [ 'q(aaabbb)=~/a(?R)?b/', \"matched\", \"optional self recursion works\" ],\n                    [ '\"((5maa-maa)(maa-3maa))\" =~ /(\\\\\\\\((?:[^()]++|(?0))*+\\\\\\\\))/', \"matched\",\n                        \"recursion and possessive captures\", \"((5maa-maa)(maa-3maa))\"],\n                    [ '\"((5maa-maa)(maa-3maa))\" =~ /(\\\\\\\\((?:[^()]++|(?1))*+\\\\\\\\))/', \"matched\",\n                        \"recursion and possessive captures\", \"((5maa-maa)(maa-3maa))\"],\n                    [ '\"((5maa-maa)(maa-3maa))\" =~ /(\\\\\\\\((?:[^()]+|(?0))*\\\\\\\\))/', \"matched\",\n                        \"recursion and possessive captures\", \"((5maa-maa)(maa-3maa))\"],\n                    [ '\"((5maa-maa)(maa-3maa))\" =~ /(\\\\\\\\((?:[^()]+|(?1))*\\\\\\\\))/', \"matched\",\n                        \"recursion and possessive captures\", \"((5maa-maa)(maa-3maa))\"],\n            ) {\n                my ($expr, $expect, $test_name, $cap1)= @$tuple;\n                # avoid quotes in this code!\n                my $code='\n                    BEGIN{require q(./test.pl);}\n                    watchdog(3);\n                    my $status= eval(q{ !(' . $expr . ') ? q(failed) : ' .\n                        ($cap1 ? '($1 ne q['.$cap1.']) ? qq(badmatch:$1) : ' : '') .\n                        ' q(matched) })\n                                || ( ( $@ =~ /Infinite recursion/ ) ? qq(died) : q(strange-death) );\n                    print $status;\n                ';\n                fresh_perl_is($code, $expect, {}, \"$bug - $test_name\" );\n            }\n        }\n        {\n            fresh_perl_is('\n                BEGIN{require q(test.pl);}\n                watchdog(3);\n                $SIG{ALRM} = sub {print \"Timeout\\n\"; exit(1)};\n                alarm 1;\n                $_ = \"a\" x 1000 . \"b\" x 1000 . \"c\" x 1000;\n                /.*a.*b.*c.*[de]/;\n            ',\"Timeout\",{},\"Test Perl 73464\")\n        }\n\n        {   # [perl #128686], crashed the the interpreter\n            my $AE = chr utf8::unicode_to_native(0xC6);\n            my $ae = chr utf8::unicode_to_native(0xE6);\n            my $re = qr/[$ae\\s]/i;\n            ok($AE !~ $re, '/[\\xE6\\s]/i doesn\\'t match \\xC6 when not in UTF-8');\n            utf8::upgrade $AE;\n            ok($AE =~ $re, '/[\\xE6\\s]/i matches \\xC6 when in UTF-8');\n        }\n\n        {\n            is(0+(\"\\n\" =~ m'\\n'), 1, q|m'\\n' should interpolate escapes|);\n        }\n\n        {\n            my $str = \"a\\xB6\";\n            ok( $str =~ m{^(a|a\\x{b6})$}, \"fix [perl #129950] - latin1 case\" );\n            utf8::upgrade($str);\n            ok( $str =~ m{^(a|a\\x{b6})$}, \"fix [perl #129950] - utf8 case\" );\n        }\n        {\n            my $got= run_perl( switches => [ '-l' ], prog => <<'EOF_CODE' );\n            my $died= !eval {\n                $_=qq(ab);\n                print;\n                my $p=qr/(?{ s!!x! })/;\n                /$p/;\n                print;\n                /a/;\n                /$p/;\n                print;\n                /b/;\n                /$p/;\n                print;\n                //;\n                1;\n            };\n            $error = $died ? ($@ || qq(Zombie)) : qq(none);\n            print $died ? qq(died) : qq(lived);\n            print qq(Error: $@);\nEOF_CODE\n            my @got= split /\\n/, $got;\n            is($got[0],\"ab\",\"empty pattern in regex codeblock: got expected start string\");\n            is($got[1],\"xab\",\n                \"empty pattern in regex codeblock: first subst with no last-match worked right\");\n            is($got[2],\"xxb\",\"empty pattern in regex codeblock: second subst worked right\");\n            is($got[3],\"xxx\",\"empty pattern in regex codeblock: third subst worked right\");\n            is($got[4],\"died\",\"empty pattern in regex codeblock: died as expected\");\n            like($got[5],qr/Error: Infinite recursion via empty pattern/,\n           \"empty pattern in regex codeblock: produced the right exception message\" );\n        }\n\n    # This test is based on the one directly above, which happened to\n    # leak. Repeat the test, but stripped down to the bare essentials\n    # of the leak, which is to die while executing a regex which is\n    # already the current regex, thus causing the saved outer set of\n    # capture offsets to leak. The test itself doesn't do anything\n    # except sit around hoping not to be triggered by ASan\n    {\n        eval {\n            my $s = \"abcd\";\n            $s =~ m{([abcd]) (?{ die if $1 eq 'd'; })}gx;\n            $s =~ //g;\n            $s =~ //g;\n            $s =~ //g;\n        };\n        pass(\"call to current regex doesn't leak\");\n    }\n\n\n\n    {\n        # [perl #130495] /x comment skipping stopped a byte short, leading\n        # to assertion failure or 'malformed utf-8 character\" warning\n        fresh_perl_is(\n            \"use utf8; m{a#\\x{124}}x\", '', {wide_chars => 1},\n            '[perl #130495] utf-8 character at end of /x comment should not misparse',\n        );\n    }\n    {\n        # [perl #130522] causes out-of-bounds read detected by clang with\n        # address=sanitized when length of the STCLASS string is greater than\n        # length of target string.\n        my $re = qr{(?=\\0z)\\0?z?$}i;\n        my($yes, $no) = (1, \"\");\n        for my $test (\n            [ $no,  undef,   '<undef>' ],\n            [ $no,  '',      '' ],\n            [ $no,  \"\\0\",    '\\0' ],\n            [ $yes, \"\\0z\",   '\\0z' ],\n            [ $no,  \"\\0z\\0\", '\\0z\\0' ],\n            [ $yes, \"\\0z\\n\", '\\0z\\n' ],\n        ) {\n            my($result, $target, $disp) = @$test;\n            no warnings qw/uninitialized/;\n            is($target =~ $re, $result, \"[perl #130522] with target '$disp'\");\n        }\n    }\n    {\n\t# [perl #129377] backref to an unmatched capture should not cause\n\t# reading before start of string.\n\tSKIP: {\n\t    skip \"no re-debug under miniperl\" if is_miniperl;\n\t    my $prog = <<'EOP';\nuse re qw(Debug EXECUTE);\n\"x\" =~ m{ () y | () \\1 }x;\nEOP\n\t    fresh_perl_like($prog, qr{\n\t\t\\A (?! .* ^ \\s+ - )\n\t    }msx, { stderr => 1 }, \"Offsets in debug output are not negative\");\n\t}\n    }\n    {\n        # buffer overflow\n\n        # This test also used to leak - fixed by the commit which added\n        # this line.\n\n        fresh_perl_is(\"BEGIN{\\$^H=0x200000}\\ns/[(?{//xx\",\n                      \"Unmatched [ in regex; marked by <-- HERE in m/[ <-- HERE (?{/ at (eval 1) line 1.\\n\",\n                      {}, \"buffer overflow for regexp component\");\n    }\n    {\n        # [perl #129281] buffer write overflow, detected by ASAN, valgrind\n        fresh_perl_is('/0(?0)|^*0(?0)|^*(^*())0|/', '', {}, \"don't bump whilem_c too much\");\n    }\n    {\n        # RT #131893 - fails with ASAN -fsanitize=undefined\n        fresh_perl_is('qr/0(0?(0||00*))|/', '', {}, \"integer overflow during compilation\");\n    }\n\n    {\n        # RT #131575 intuit skipping back from the end to find the highest\n        # possible start point, was potentially hopping back beyond pos()\n        # and crashing by calling fbm_instr with a negative length\n\n        my $text = \"=t=\\x{5000}\";\n        pos($text) = 3;\n        ok(scalar($text !~ m{(~*=[a-z]=)}g), \"RT #131575\");\n    }\n    {\n        fresh_perl_is('\"AA\" =~ m/AA{1,0}/','',{},\"handle OPFAIL insert properly\");\n    }\n    {\n        fresh_perl_is('$_=\"0\\x{1000000}\";/^000?\\0000/','',{},\"dont throw assert errors trying to fbm past end of string\");\n    }\n    {   # [perl $132227]\n        fresh_perl_is(\"('0ba' . ('ss' x 300)) =~ m/0B\\\\N{U+41}\" . $sharp_s x 150 . '/i and print \"1\\n\"',  1,{},\"Use of sharp s under /di that changes to /ui\");\n\n        # A variation, but as far as khw knows not part of 132227\n        fresh_perl_is(\"'0bssa' =~ m/0B\" . $sharp_s . \"\\\\N{U+41}\" . '/i and print \"1\\n\"',  1,{},\"Use of sharp s under /di that changes to /ui\");\n    }\n    {   # [perl $132164]\n        fresh_perl_is('m m0*0+\\Rm', \"\",{},\"Undefined behavior in address sanitizer\");\n    }\n    {   # [perl #133642]\n        fresh_perl_is('no warnings \"experimental::vlb\";\n                      m/((?<=(0?)))/', \"\",{},\"Was getting 'Double free'\");\n    }\n    {   # [perl #133782]\n        # this would panic on DEBUGGING builds\n        fresh_perl_is(<<'CODE', \"ok\\nok\\n\",{}, 'Bad length magic was left on $^R');\nwhile( \"\\N{U+100}bc\" =~ /(..?)(?{$^N})/g ) {\n  print \"ok\\n\" if length($^R)==length(\"$^R\");\n}\nCODE\n    }\n    {   # [perl #133871], ASAN/valgrind out-of-bounds access\n        fresh_perl_like('qr/(?|(())|())|//', qr/syntax error/, {}, \"[perl #133871]\");\n    }\n    {   # [perl #133871], ASAN/valgrind out-of-bounds access\n        fresh_perl_like('qr/\\p{nv:NAnq}/', qr/Can't find Unicode property definition/, {}, \"GH #17367\");\n    }\n    {   # GH #17370, ASAN/valgrind out-of-bounds access\n        fresh_perl_like('qr/\\p{nv:qnan}/', qr/Can't find Unicode property definition/, {}, \"GH #17370\");\n    }\n\n    {   # [perl #133921], segfault\n        fresh_perl_is('qr\u00040||\u00df+p00000F00000\u00f9\\Q00000\u00ff00000x00000x0c0e0\\Qx0\\Qx0\\x{0c!}\\;\\;\u00ee0\\x\u0000\u00ff\u00ff\u00ff\u00fe\u0000\u0000\u0000\u00f9\\Q`\\Qx`\u0000\u0001{0c!}\u0001e;\u0000\u0000\u0000\u00f9\\\u00f2`\\Qm`\\x{0c!}\\;\\;\u00ee\u00e7\u00ff \u0000\u007f\u00e7\u0000\u0000\u0000!\u0000F\u0005\u0000\u0000/;\u00ee\u00e7\u00ff\u00f9\\Q\u0000\u0001\u0000\u0000x\u0010\u00ff\u00ff\u00ff\u00ff\u0000\u0000\u0000\u00f9\u0000\u0000\u0000\u007f`x{0c!}\u0001e;\u0000\u0000\u0000\u00f9\\Q`\\Qx`\\x{c!}\\;\\;\u00ee\u00e7!}\\;\u00ee\u00e7\u00ff\u00f9\\Q\u0087 \\x\u0000\u00ff\u00ff\u00ff\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2`\\Qx`\\x{0c!};\\;\u00ee\u00e7\u00ff \u0000F\u0005\u0000n0t0\u0000c \u0000\u0080\u0001d;t \u0000\u0000\u0000\u00f9 \u0000\u007f\u00e7\u0080\u0000\u0000!00000000000000000000000m/00000000000000000000\u000e00000000000m/\u0010\u0010\u0010\u0010\\x{){} \u0010\u0010\u0010\u0010)|\u0010\u0010\u0004i', \"\", {}, \"[perl #133921]\");\n        fresh_perl_is('\u0004|\u00df+W0\u00fc0r0\\Qx0\\Qx0x0c0G00000000000000000O000000000x0x0x0c!}\\;\u00ee\u00e7\u00ff\u00f9\\Q0 \\x\u0000\u00ff\u00ff\u00ff\u00ff\u0000\u0000\u0000\u00f9\\Q`\\Qx`\u0000\u0001{0d ;\u0000\u0000\u0000\u00f9\\\u00f2`\\Qm`\\x{0c!}\\;\\;\u00ee\u00e7\u00ff \u0000\u007f\u00e7\u0000\u0000\u0000!\u0000F\u0005\u0000\u0000/;\u00ee\u00e7\u00ff\u00f9\\Q\u0000\u0001\u0000\u0000x\u0010\u00ff\u00ff\u00ff\u00ff\u0000\u0000\u0000\u00f9\u0000\u0000\u0000\u007f`x{0c!}\u0001;\u0000\u0000\u0000\u00f9\\Q`\\Qq`\\x{c!}\\;\\;\u00ee\u00e7!}\\;\u00ee\u00e7\u00ff\u00f9\\Q\u0087 \\x\u0000\u00ff\u00ff\u00ff\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2`\\Qx`\\x{0c!};\\;\u00ee\u00e7\u00ff \u00000000000F\u0005\u0000m0t0\u0000c \u0000\u0080\u0001d;t \u0000\u0000\u0000\u00f9 \u0000\u007f\u00e7\u0080\u0000\u0000!00000000000000000000000m/00000000000000000000\u000e00000000000m/\u0010\u0010\u0010\u0010\\x{){} \u0010\u0010\u0010\u0010)|\u0010\u0010\u0004\u0004i', \"\", {}, \"[perl #133921]\");\n\nfresh_perl_is('s\u0004|\u00df+W0\u00fc0f0\\Qx0\\Qx0x0c0G0xgive0000000000000O0h\u008d000x0 \\x\u00f2\u00ff\u00ff\u00ff\u0000\u0000\u00f9\\Q`\\Q\n\n\u001a\n\n\n\t\u00e7\n\n\n\n\n\n\n\n\n\n\n\n\n\u0005\n\n\nx{0c!}\\;\\;\u00e7\u00ff \u0000\u007fq0/i0/!\u0000F\u0005\u0000\u0000/;\u00ee\u00e7\u00ff\u00f9\\Q\u0000\u0001\u0000\u0000x\u0010\u00ff\u00ff\u00ff\u00ff\u0000\u0000\u0000\u00f9\u0000\u0000\u0000\u007f`x{0c!}\u0001e;\u0000\u0000\u0000\u00f9\\Q`\\Qx`\\x{0c!}\\;\u00ff\u00ff\u00ff\u00ff!}\\;\u00ee\u00e7\u00ff\u00f9\\Q\u0087\u0001\\x\u0000\u00ff\u00ff\u00ff\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2`\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2`\\Qx`\\x{0c!};\\;\u00ee\u00e7\u00ff \u0000u00000F\u0005\u0000000t0\u0000p \u0000\u0080\u0001d? \u0000\u0000\u0000\u00f9 \u0000\u007f\u00e7\u0080\u0000\u0000!00000000000000000000000m/00000000000000000000\u000e00000000000m/0\u0000\u0010\u0010\u0010\\\u0000\u0000\u0001\u0000} \u0010\u0010\u0010\u0010)|\u0010\u0010\u0004\u0004i', \"\", {}, \"[perl #133921]\");\n\n        fresh_perl_is('\u0004a a\u00fa\u0000\u0000\u00fav sWtrt\u0010\u0000\\\u00f3||\u00df+W\u000e\u00fc\u0016ef\u0000\u00f9\\Qx`\\Qx`\\x{1c!gGnuc given1111111111111O1111each\u008d111\\jx` \\x\u0000\u00f2\u00ff\u00ff\u00ff\u0000\u0000\u0000\u00f9\\Qx`\\Q\n\n\n\n\n\n\t\u00e7\n\n\n\n\n\n\n\n\n\n\n\n\n\u0005\n\n\nx{1c!}\\;\\;\u00ee\u00e7\u00ffp \u0000\u007fqr/elsif/!\u0000eF\u0005\u0000\u0000/;\u00ee\u00e7\u00ff\u00f9\\Q\u0000\u0001\u0000\u0000x\u0010\u00ff\u00ff\u00ff\u00ff\u0000\u0000\u0000\u00f9HQx\u0000\u0000\u0000\u007f`Lx{1c!}\u0001e;\u0000\u0000\u0000\u00f9\\Qx`\\Qx`\\x{1c!}\\;\u00ff\u00ff\u00ff\u00ffc!}\\;\u00ee\u00e7\u00ff\u00f9\\Qx\u0087\u0001\\x\u0000\u00ff\u00ff\u00ff\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2x`\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2x`\\Qx`\\x{1c!}8;\\;\u00ee\u00e7\u00ffp \u0000unshifteF\u0005\u0000normat0\u0000cmp \u0000\u0080\u0001d?not \u0000\u0000\u0000\u00f9p \u0000\u007f\u00e7\u0080\u0000\u0000!0000000000000000000000000m/000000000000000000000\u000e00000000000m/0R\u0000\u0010\u0010\u0010\\\u0000\u0000\u0001\u0000} \u0010\u0010\u0010\u0010)|\u0010\u0010\u0004\u0010\u0010\u0010\u0010\u0010\u0001\\a\u00ef||K??\u008fp\u0080\u00bf\u00ff\u00fff\u00fad{\\\u000e{\u0004gri\u0004\u0004{\\x{1x/}\u0000 \u00f0\u00b9Nunti\u00c0h', \"\", {}, \"[perl #133921]\");\n\n    fresh_perl_is('s\u0004|\u00df+W0\u00fc0f0\\Qx0\\Qx0x0c0g0c 000n0000000000000O0h\u008d000x0 \\x\u00f2\u00ff\u00ff\u00ff\u0000\u0000\u00f9\\Q`\\Q\n\n\n\n\n\n\t\u00e7\n\n\n\n\n\n\n\n\n\n\n\n\n\u0005\n\n\nx{0c!}\\;\\;\u00ee\u00e7\u00ff \u0000\u007f/0f/!\u0000F\u0005\u0000\u0000/;\u00ee\u00e7\u00ff\u00f9\\Q\u0000\u0001\u0000\u0000x\u0010\u00ff\u00ff\u00ff\u00ff\u0000\u0000\u0000\u00f9\u0000\u0000\u0000\u007f`x{0c!}\u0001;\u0000\u0000\u0000\u00f9\\Q`\\Qx`\\x{0c!}\\;\u00ff\u00ff\u00ff\u00ff!}\\;\u00ee\u00e7\u00ff\u00f9\\Q\u0087\u0001\\x\u0000\u00ff\u00ff\u00ff\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2`\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2`\\Qx`\\x{0c!};\\;\u00ee\u00e7\u00ff \u0000000t0F\u0005\u0000000t0\u0000p \u0000\u0080\u0001d?n \u0000\u0000\u0000\u00f9 \u0000\u007f\u00e7\u0080\u0000\u0000!00000000000000000000000m/00000000000000000000\u000e00000000000m/\u0000\u0010\u0010\u0010\\\u0000\u0000\u0001\u0000} \u0010\u0010\u0010\u0010)|\u0010\u0010\u0004\u0004i', \"\", {}, \"[perl #133933]\");\n    }\n\n    {   # perl #133998]\n        fresh_perl_is('print \"\\x{110000}\" =~ qr/(?l)|[^\\S\\pC\\s]/', 1, {},\n        '/[\\S\\s]/l works');\n    }\n\n    {   # perl #133995]\n        use utf8;\n        fresh_perl_is('\"\u03ad\u03b4\u03c9\u03c3\u03b1\u03bd \u03b5\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ae\u10d5\u10d4\" =~ m/[^0](?=0)0?/', \"\",\n                      {wide_chars => 1},\n                      '[^0] doesnt crash on UTF-8 target string');\n    }\n\n    {   # [perl #133992]  This is a tokenizer bug of parsing a pattern\n        fresh_perl_is(q:$z = do {\n                                use utf8;\n                                \"q!\u00d1\u0082\u00d0\u00b5\u00d1\u0081\u00d1\u0082! =~ m'\"\n                        };\n                        $z .= '\u00e8(?#\u0084';\n                        $z .= \"'\";\n                        eval $z;:, \"\", {}, 'foo');\n    }\n\n    {   # [perl #134325]\n        my $quote=\"\\\\Q\";\n        my $back=\"\\\\\\\\\";\n        my $ff=\"\\xff\";\n        my $s = sprintf \"/\\\\1|(|%s)%s%s   /i\",\n                        $quote x 8 . $back x 69,\n                        $quote x 5 . $back x 4,\n                        $ff x 48;\n        like(runperl(prog => \"$s\", stderr => 1), qr/Unmatched \\(/);\n   }\n\nSKIP:\n    {   # [perl #134334], Assertion failure\n        my $utf8_locale = find_utf8_ctype_locale();\n        skip \"no UTF-8 locale available\" unless $utf8_locale;\n        fresh_perl_like(\"use POSIX; POSIX::setlocale(&LC_CTYPE, '$utf8_locale'); 'ssss' =~ /\\xDF+?sX/il;\",\n                        qr/^$/,\n                        {},\n                        \"Assertion failure matching /il on single char folding to multi\");\n    }\n\n    # gh17490: test recursion check\n    {\n        my $eval = '(?{1})';\n        my $re = sprintf '(?&FOO)(?(DEFINE)(?<FOO>%sfoo))', $eval x 20;\n        my $result = eval qq{\"foo\" =~ /$re/};\n        is($@ // '', '', \"many evals did not die\");\n        ok($result, \"regexp correctly matched\");\n    }\n\n} # End of sub run_tests\n\n1;\n\n#\n# ex: set ts=8 sts=4 sw=4 et:\n#\n"], "fixing_code": [": BEGIN{die \"You meant to run regen/embed.pl\"} # Stop early if fed to perl.\n:\n: This file is processed by regen/embed.pl and autodoc.pl\n: It is used to declare the interfaces to the functions defined by perl.  All\n: non-static functions must have entries here.  Static functions need not, but\n: there is benefit to declaring them here, as it generally handles the thread\n: context parameter invisibly, as well as making sure a PERL_ARGS_ASSERT_foo\n: macro is defined, which can save you debugging time.\n:\n: Lines are of the form:\n:    flags|return_type|function_name|arg1|arg2|...|argN\n:\n: A line may be continued on another by ending it with a backslash.\n: Leading and trailing whitespace will be ignored in each component.\n:\n: The default without flags is to declare a function for internal perl-core use\n: only, not visible to XS code nor to Perl extensions.  Use the A and E flags to\n: modify this.  Most non-static functions should have the 'p' flag to avoid\n: namespace clashes with programs that embed perl.\n:\n: flags are single letters with following meanings:\n:\n:   A  Available fully everywhere (usually part of the public API):\n:\n:         add entry to the list of exported symbols (unless x or m);\n:         any doc entry goes in perlapi.pod rather than perlintern.pod.  If no\n:\t     documentation is furnished for this function, and M is also\n:\t     specified, the function is not listed as part of the public API.\n:\t     If M isn't specified, and no documentation is furnished, the\n:\t     function is listed in perlapi as existing and being undocumented\n:         makes '#define foo Perl_foo' scope not just for PERL_CORE/PERL_EXT\n:\n:      If the function is only exported for use in a public\n:      macro, see X.\n:\n:   a  Allocates memory a la malloc/calloc.  Also implies \"R\".\n:      This should only be on functions which returns 'empty' memory\n:      which has no other pointers to it, and which does not contain\n:      any pointers to other things. So for example realloc() can't be\n:      'a'.\n:\n:         proto.h: add __attribute__malloc__\n:\n:   b  Binary backward compatibility.  This is used for functions which are\n:      kept only to not have to change legacy applications that call them.  If\n:      there are no such legacy applications in a Perl installation for all\n:      functions flagged with this, the installation can run Configure with the\n:      -Accflags='-DNO_MATHOMS' parameter to not even compile them.  If there\n:      is a macro form of this function that provides equivalent functionality\n:      (using a different implementation), also specify the 'm' flag.  The 'b'\n:      functions are normally moved to mathoms.c, but if circumstances dictate\n:      otherwise, they can be anywhere, provided the whole function is wrapped\n:      with\n:       #ifndef NO_MATHOMS\n:       ...\n:       #endif\n:\n:      Note that this flag no longer automatically adds a 'Perl_' prefix to the\n:      name.  Additionally specify 'p' to do that.\n:\n:      For functions, like wrappers, whose macro shortcut doesn't call the\n:      function, but which, for whatever reason, aren't considered legacy-only,\n:      use the 'o' flag\n:\n:      This flag effectively causes nothing to happen if the perl interpreter\n:      is compiled with -DNO_MATHOMS; otherwise these happen:\n:         add entry to the list of exported symbols;\n:         create PERL_ARGS_ASSERT_foo;\n:\t  add embed.h entry (unless overridden by the 'm' flag)\n:\n:   D  Function is deprecated:\n:\n:         proto.h: add __attribute__deprecated__\n:\n:   d  Function has documentation (somewhere) in the source:\n:\n:         enables 'no docs for foo\" warning in autodoc.pl\n:\n:   E  Visible to extensions included in the Perl core:\n:\n:         in embed.h, change \"#ifdef PERL_CORE\"\n:         into               \"#if defined(PERL_CORE) || defined(PERL_EXT)\"\n:\n:      To be usable from dynamically loaded extensions, either:\n:\t  1) must be static to its containing file (\"i\" or \"s\" flag); or\n:         2) be combined with the \"X\" flag.\n:\n:   f  Function takes a format string. If the function name =~ qr/strftime/\n:      then its assumed to take a strftime-style format string as 1st arg;\n:      otherwise it's assumed to be a printf style format string, varargs\n:      (hence any entry that would otherwise go in embed.h is suppressed):\n:\n:         proto.h: add __attribute__format__ (or ...null_ok__)\n:\n:   i  Static inline: function in source code has a S_ prefix:\n:\n:         proto.h: function is declared as S_foo rather than foo unless the 'p'\n:\t\t   flag is also given in which case 'Perl_foo' is used,\n:                PERL_STATIC_INLINE is added to declaration;\n:         embed.h: \"#define foo S_foo\" or Perl_foo entries added\n:\n:   M  May change:\n:\n:         any doc entry is marked that function may change.  Also used to\n:\t  suppress making a doc entry if it would just be a placeholder.\n:\n:   m  Implemented as a macro:\n:\n:         suppress proto.h entry unless 'b' also specified (actually, not\n:\t\tsuppressed, but commented out)\n:         suppress entry in the list of exported symbols\n:         suppress embed.h entry\n:\n:   n  Has no implicit interpreter/thread context argument:\n:\n:         suppress the pTHX part of \"foo(pTHX...)\" in proto.h;\n:         In the PERL_IMPLICIT_SYS branch of embed.h, generates\n:             \"#define foo Perl_foo\",      rather than\n:             \"#define foo(a,b,c) Perl_foo(aTHX_ a,b,c)\n:\n:   O  Has a perl_ compatibility macro.\n:\n:      The really OLD name for API funcs\n:\n:   o  Has no Perl_foo or S_foo compatibility macro:\n:\n:\tThis can be used when you define a macro with this entry's name that\n:\tdoesn't call the function specified by this entry.  This is typically\n:\tdone for a function that effectively just wraps another one, and where\n:\tthe macro form calls the underlying function directly.  For these, also\n:\tspecify the 'm' flag.  Legacy-only functions should instead use 'b'.\n:\n:         embed.h: suppress \"#define foo Perl_foo\"\n:\n:   P  Pure function:\n:\n:\tA pure function has no effects except the return value, and the return\n:       value depends only on params and/or globals.  This is a hint to the\n:\tcompiler that it can optimize calls to this function out of common\n:\tsubexpressions.  Consequently if this flag is wrongly specified, it can\n:\tlead to subtle bugs that vary by platform, compiler, compiler version,\n:\tand optimization level.  Also, a future commit could easily change a\n:\tcurrently-pure function without even noticing this flag.  So it should\n:\tbe used sparingly, only for functions that are unlikely to ever become\n:\tnot pure by future commits.  It should not be used for static\n:\tfunctions, as the compiler already has the information needed to make\n:\tthe 'pure' determination and doesn't need any hint; so it doesn't add\n:\tvalue in those cases, and could be dangerous if it causes the compiler\n:\tto skip doing its own checks.  It should not be used on functions that\n:\ttouch SVs, as those can trigger unexpected magic.  Also implies \"R\":\n:\n:         proto.h: add __attribute__pure__\n:\n:   p  Function in source code has a Perl_ prefix:\n:\n:         proto.h: function is declared as Perl_foo rather than foo\n:         embed.h: \"#define foo Perl_foo\" entries added\n:\n:   R  Return value must not be ignored (also implied by 'a' and 'P' flags):\n:\n:        proto.h: add __attribute__warn_unused_result__\n:\n:   r  Function never returns:\n:\n:        proto.h: add __attribute__noreturn__\n:\n:   s  Static function: function in source code has a S_ prefix:\n:\n:         proto.h: function is declared as S_foo rather than foo,\n:                STATIC is added to declaration;\n:         embed.h: \"#define foo S_foo\" entries added\n:\n:   U  Suppress usage example in autogenerated documentation\n:\n:         (currently no effect)\n:\n:   W  Add a _pDEPTH argument to function prototypes, and an _aDEPTH\n:      argument to the function calls. This means that under DEBUGGING\n:      a depth argument is added to the functions, which is used for\n:      example by the regex engine for debugging and trace output.\n:      A non DEBUGGING build will not pass the unused argument.\n:      Currently restricted to functions with at least one argument.\n:\n:   X  Explicitly exported:\n:\n:         add entry to the list of exported symbols, unless x or m\n:\n:      This is often used for private functions that are used by public\n:      macros.  In those cases the macros must use the long form of the\n:      name (Perl_blah(aTHX_ ...)).\n:\n:   x  Not exported\n:\n:         suppress entry in the list of exported symbols\n:\n: (see also L<perlguts/Internal Functions> for those flags.)\n:\n: Pointer parameters that must not be passed NULLs should be prefixed with NN.\n:\n: Pointer parameters that may be NULL should be prefixed with NULLOK.  This has\n: no effect on output yet.  It's a notation for the maintainers to know \"I have\n: defined whether NULL is OK or not\" rather than having neither NULL or NULLOK,\n: which is ambiguous.\n:\n: Individual flags may be separated by whitespace.\n\n#if defined(PERL_IMPLICIT_SYS)\nAno\t|PerlInterpreter*|perl_alloc_using \\\n\t\t\t\t|NN struct IPerlMem *ipM \\\n\t\t\t\t|NN struct IPerlMem *ipMS \\\n\t\t\t\t|NN struct IPerlMem *ipMP \\\n\t\t\t\t|NN struct IPerlEnv *ipE \\\n\t\t\t\t|NN struct IPerlStdIO *ipStd \\\n\t\t\t\t|NN struct IPerlLIO *ipLIO \\\n\t\t\t\t|NN struct IPerlDir *ipD \\\n\t\t\t\t|NN struct IPerlSock *ipS \\\n\t\t\t\t|NN struct IPerlProc *ipP\n#endif\nAnod\t|PerlInterpreter*\t|perl_alloc\nAnod\t|void\t|perl_construct\t|NN PerlInterpreter *my_perl\nAnod\t|int\t|perl_destruct\t|NN PerlInterpreter *my_perl\nAnod\t|void\t|perl_free\t|NN PerlInterpreter *my_perl\nAnod\t|int\t|perl_run\t|NN PerlInterpreter *my_perl\nAnod\t|int\t|perl_parse\t|NN PerlInterpreter *my_perl|XSINIT_t xsinit \\\n\t\t\t\t|int argc|NULLOK char** argv|NULLOK char** env\nAnpR\t|bool\t|doing_taint\t|int argc|NULLOK char** argv|NULLOK char** env\n#if defined(USE_ITHREADS)\nAnod\t|PerlInterpreter*|perl_clone|NN PerlInterpreter *proto_perl|UV flags\n#  if defined(PERL_IMPLICIT_SYS)\nAno\t|PerlInterpreter*|perl_clone_using \\\n\t\t\t\t|NN PerlInterpreter *proto_perl \\\n\t\t\t\t|UV flags \\\n\t\t\t\t|NN struct IPerlMem* ipM \\\n\t\t\t\t|NN struct IPerlMem* ipMS \\\n\t\t\t\t|NN struct IPerlMem* ipMP \\\n\t\t\t\t|NN struct IPerlEnv* ipE \\\n\t\t\t\t|NN struct IPerlStdIO* ipStd \\\n\t\t\t\t|NN struct IPerlLIO* ipLIO \\\n\t\t\t\t|NN struct IPerlDir* ipD \\\n\t\t\t\t|NN struct IPerlSock* ipS \\\n\t\t\t\t|NN struct IPerlProc* ipP\n#  endif\n#endif\n\nAanop\t|Malloc_t|malloc\t|MEM_SIZE nbytes\nAanop\t|Malloc_t|calloc\t|MEM_SIZE elements|MEM_SIZE size\nARnop\t|Malloc_t|realloc\t|Malloc_t where|MEM_SIZE nbytes\nAnop\t|Free_t\t|mfree\t\t|Malloc_t where\n#if defined(MYMALLOC)\nnpR\t|MEM_SIZE|malloced_size\t|NN void *p\nnpR\t|MEM_SIZE|malloc_good_size\t|size_t nbytes\n#endif\n#if defined(PERL_IN_MALLOC_C)\nsn\t|int\t|adjust_size_and_find_bucket\t|NN size_t *nbytes_p\n#endif\n\nAnpR\t|void*\t|get_context\nAnp\t|void\t|set_context\t|NN void *t\n\nXEop\t|bool\t|try_amagic_bin\t|int method|int flags\nXEop\t|bool\t|try_amagic_un\t|int method|int flags\nAp\t|SV*\t|amagic_call\t|NN SV* left|NN SV* right|int method|int dir\nAp\t|SV *\t|amagic_deref_call|NN SV *ref|int method\np\t|bool\t|amagic_is_enabled|int method\nAp\t|int\t|Gv_AMupdate\t|NN HV* stash|bool destructing\nApR\t|CV*\t|gv_handler\t|NULLOK HV* stash|I32 id\nApd\t|OP*\t|op_append_elem\t|I32 optype|NULLOK OP* first|NULLOK OP* last\nApd\t|OP*\t|op_append_list\t|I32 optype|NULLOK OP* first|NULLOK OP* last\nApd\t|OP*\t|op_linklist\t|NN OP *o\nApd\t|OP*\t|op_prepend_elem|I32 optype|NULLOK OP* first|NULLOK OP* last\n: FIXME - this is only called by pp_chown. They should be merged.\np\t|I32\t|apply\t\t|I32 type|NN SV** mark|NN SV** sp\nApM\t|void\t|apply_attrs_string|NN const char *stashpv|NN CV *cv|NN const char *attrstr|STRLEN len\nApd\t|void\t|av_clear\t|NN AV *av\nApd\t|SV*\t|av_delete\t|NN AV *av|SSize_t key|I32 flags\nApdR\t|bool\t|av_exists\t|NN AV *av|SSize_t key\nApd\t|void\t|av_extend\t|NN AV *av|SSize_t key\np\t|void\t|av_extend_guts\t|NULLOK AV *av|SSize_t key \\\n\t\t\t\t|NN SSize_t *maxp \\\n\t\t\t\t|NN SV ***allocp|NN SV ***arrayp\nApdR\t|SV**\t|av_fetch\t|NN AV *av|SSize_t key|I32 lval\nApd\t|void\t|av_fill\t|NN AV *av|SSize_t fill\nApdR\t|SSize_t|av_len\t\t|NN AV *av\nApdR\t|AV*\t|av_make\t|SSize_t size|NN SV **strp\np\t|SV*\t|av_nonelem\t|NN AV *av|SSize_t ix\nApd\t|SV*\t|av_pop\t\t|NN AV *av\nApdoxM\t|void\t|av_create_and_push|NN AV **const avp|NN SV *const val\nApd\t|void\t|av_push\t|NN AV *av|NN SV *val\n: Used in scope.c, and by Data::Alias\nEXp\t|void\t|av_reify\t|NN AV *av\nApdR\t|SV*\t|av_shift\t|NN AV *av\nApd\t|SV**\t|av_store\t|NN AV *av|SSize_t key|NULLOK SV *val\nAidR\t|SSize_t|av_top_index\t|NN AV *av\nAmpdR\t|SSize_t|av_tindex\t|NN AV *av\nApd\t|void\t|av_undef\t|NN AV *av\nApdoxM\t|SV**\t|av_create_and_unshift_one|NN AV **const avp|NN SV *const val\nApd\t|void\t|av_unshift\t|NN AV *av|SSize_t num\nApo\t|SV**\t|av_arylen_p\t|NN AV *av\nApo\t|IV*\t|av_iter_p\t|NN AV *av\n#if defined(PERL_IN_AV_C)\ns\t|MAGIC*\t|get_aux_mg\t|NN AV *av\n#endif\n: Used in perly.y\npR\t|OP*\t|bind_match\t|I32 type|NN OP *left|NN OP *right\n: Used in perly.y\nApdR\t|OP*\t|block_end\t|I32 floor|NULLOK OP* seq\nApR\t|U8\t|block_gimme\n: Used in perly.y\nApdR\t|int\t|block_start\t|int full\nAodp\t|void\t|blockhook_register |NN BHK *hk\n: Used in perl.c\np\t|void\t|boot_core_UNIVERSAL\n: Used in perl.c\np\t|void\t|boot_core_PerlIO\nAp\t|void\t|call_list\t|I32 oldscope|NN AV *paramList\nApd\t|const PERL_CONTEXT *\t|caller_cx|I32 level \\\n\t\t\t\t|NULLOK const PERL_CONTEXT **dbcxp\n: Used in several source files\npR\t|bool\t|cando\t\t|Mode_t mode|bool effective|NN const Stat_t* statbufp\nApRn\t|U32\t|cast_ulong\t|NV f\nApRn\t|I32\t|cast_i32\t|NV f\nApRn\t|IV\t|cast_iv\t|NV f\nApRn\t|UV\t|cast_uv\t|NV f\n#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)\nApR\t|I32\t|my_chsize\t|int fd|Off_t length\n#endif\np\t|const COP*|closest_cop\t|NN const COP *cop|NULLOK const OP *o \\\n\t\t\t\t|NULLOK const OP *curop|bool opnext\n: Used in perly.y\nApdR\t|OP*\t|op_convert_list\t|I32 optype|I32 flags|NULLOK OP* o\n: Used in op.c and perl.c\npM\t|void\t|create_eval_scope|NULLOK OP *retop|U32 flags\nAprd\t|void\t|croak_sv\t|NN SV *baseex\n: croak()'s first parm can be NULL.  Otherwise, mod_perl breaks.\nAfprd\t|void\t|croak\t\t|NULLOK const char* pat|...\nAprd\t|void\t|vcroak\t\t|NULLOK const char* pat|NULLOK va_list* args\nAnprd\t|void\t|croak_no_modify\nAnprd\t|void\t|croak_xs_usage\t|NN const CV *const cv \\\n\t\t\t\t|NN const char *const params\nnpr\t|void\t|croak_no_mem\nnprX\t|void\t|croak_popstack\nfnrp\t|void\t|croak_caller|NULLOK const char* pat|...\nfnprx\t|void\t|noperl_die|NN const char* pat|...\n#if defined(WIN32)\nnorx\t|void\t|win32_croak_not_implemented|NN const char * fname\n#endif\n#if defined(PERL_IMPLICIT_CONTEXT)\nAfnrp\t|void\t|croak_nocontext|NULLOK const char* pat|...\nAfnrp\t|OP*    |die_nocontext  |NULLOK const char* pat|...\nAfnp\t|void\t|deb_nocontext\t|NN const char* pat|...\nAfnp\t|char*\t|form_nocontext\t|NN const char* pat|...\nAnp\t|void\t|load_module_nocontext|U32 flags|NN SV* name|NULLOK SV* ver|...\nAfnp\t|SV*\t|mess_nocontext\t|NN const char* pat|...\nAfnp\t|void\t|warn_nocontext\t|NN const char* pat|...\nAfnp\t|void\t|warner_nocontext|U32 err|NN const char* pat|...\nAfnp\t|SV*\t|newSVpvf_nocontext|NN const char *const pat|...\nAfnp\t|void\t|sv_catpvf_nocontext|NN SV *const sv|NN const char *const pat|...\nAfnp\t|void\t|sv_setpvf_nocontext|NN SV *const sv|NN const char *const pat|...\nAfnp\t|void\t|sv_catpvf_mg_nocontext|NN SV *const sv|NN const char *const pat|...\nAfnp\t|void\t|sv_setpvf_mg_nocontext|NN SV *const sv|NN const char *const pat|...\nAbfnp\t|int\t|fprintf_nocontext|NN PerlIO *stream|NN const char *format|...\nAbfnp\t|int\t|printf_nocontext|NN const char *format|...\n#endif\n: Used in pp.c\np\t|SV *\t|core_prototype\t|NULLOK SV *sv|NN const char *name \\\n\t\t\t\t|const int code|NULLOK int * const opnum\n: Used in gv.c\np\t|OP *\t|coresub_op\t|NN SV *const coreargssv|const int code \\\n\t\t\t\t|const int opnum\n: Used in sv.c\nEMXp\t|void\t|cv_ckproto_len_flags\t|NN const CV* cv|NULLOK const GV* gv\\\n\t\t\t\t|NULLOK const char* p|const STRLEN len \\\n                                |const U32 flags\n: Used in pp.c and pp_sys.c\nApdR\t|SV*\t|gv_const_sv\t|NN GV* gv\nApdRn\t|SV*\t|cv_const_sv\t|NULLOK const CV *const cv\npRn\t|SV*\t|cv_const_sv_or_av|NULLOK const CV *const cv\nApd\t|SV *\t|cv_name\t|NN CV *cv|NULLOK SV *sv|U32 flags\nApd\t|void\t|cv_undef\t|NN CV* cv\np\t|void\t|cv_undef_flags\t|NN CV* cv|U32 flags\np\t|void\t|cv_forget_slab\t|NULLOK CV *cv\nAp\t|void\t|cx_dump\t|NN PERL_CONTEXT* cx\nAp\t|SV*\t|filter_add\t|NULLOK filter_t funcp|NULLOK SV* datasv\nAp\t|void\t|filter_del\t|NN filter_t funcp\nApR\t|I32\t|filter_read\t|int idx|NN SV *buf_sv|int maxlen\nApPR\t|char**\t|get_op_descs\nApPR\t|char**\t|get_op_names\n: FIXME discussion on p5p\npPR\t|const char*\t|get_no_modify\n: FIXME discussion on p5p\npPR\t|U32*\t|get_opargs\nApPR\t|PPADDR_t*|get_ppaddr\n: Used by CXINC, which appears to be in widespread use\nApR\t|I32\t|cxinc\nAfp\t|void\t|deb\t\t|NN const char* pat|...\nAp\t|void\t|vdeb\t\t|NN const char* pat|NULLOK va_list* args\nAp\t|void\t|debprofdump\nEXp\t|SV*\t|multideref_stringify\t|NN const OP* o|NULLOK CV *cv\nEXp\t|SV*\t|multiconcat_stringify\t|NN const OP* o\nAp\t|I32\t|debop\t\t|NN const OP* o\nAp\t|I32\t|debstack\nAp\t|I32\t|debstackptrs\npR\t|SV *\t|defelem_target\t|NN SV *sv|NULLOK MAGIC *mg\nAnp\t|char*\t|delimcpy\t|NN char* to|NN const char* toend|NN const char* from \\\n\t\t\t\t|NN const char* fromend|int delim|NN I32* retlen\nnp\t|char*\t|delimcpy_no_escape|NN char* to|NN const char* toend \\\n\t\t\t\t   |NN const char* from \\\n\t\t\t\t   |NN const char* fromend|int delim \\\n\t\t\t\t   |NN I32* retlen\n: Used in op.c, perl.c\npM\t|void\t|delete_eval_scope\nAprd\t|OP*    |die_sv         |NN SV *baseex\nAfrpd\t|OP*    |die            |NULLOK const char* pat|...\n: Used in util.c\npr\t|void\t|die_unwind\t|NN SV* msv\nAp\t|void\t|dounwind\t|I32 cxix\n: FIXME\npmb\t|bool|do_aexec\t|NULLOK SV* really|NN SV** mark|NN SV** sp\n: Used in pp_sys.c\np\t|bool|do_aexec5\t|NULLOK SV* really|NN SV** mark|NN SV** sp|int fd|int do_report\nAbp\t|int\t|do_binmode\t|NN PerlIO *fp|int iotype|int mode\n: Used in pp.c\nAp\t|bool\t|do_close\t|NULLOK GV* gv|bool not_implicit\n: Defined in doio.c, used only in pp_sys.c\np\t|bool\t|do_eof\t\t|NN GV* gv\n\n#ifdef PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION\npm\t|bool|do_exec\t|NN const char* cmd\n#else\np\t|bool|do_exec\t|NN const char* cmd\n#endif\n\n#if defined(WIN32) || defined(__SYMBIAN32__) || defined(VMS)\nAp\t|int\t|do_aspawn\t|NULLOK SV* really|NN SV** mark|NN SV** sp\nAp\t|int\t|do_spawn\t|NN char* cmd\nAp\t|int\t|do_spawn_nowait|NN char* cmd\n#endif\n#if !defined(WIN32)\np\t|bool|do_exec3\t|NN const char *incmd|int fd|int do_report\n#endif\n#if defined(PERL_IN_DOIO_C)\ns\t|void\t|exec_failed\t|NN const char *cmd|int fd|int do_report\ns\t|bool\t|argvout_final\t|NN MAGIC *mg|NN IO *io|bool not_implicit\n#endif\n#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)\n: Defined in doio.c, used only in pp_sys.c\np\t|I32\t|do_ipcctl\t|I32 optype|NN SV** mark|NN SV** sp\n: Defined in doio.c, used only in pp_sys.c\np\t|I32\t|do_ipcget\t|I32 optype|NN SV** mark|NN SV** sp\n: Defined in doio.c, used only in pp_sys.c\np\t|I32\t|do_msgrcv\t|NN SV** mark|NN SV** sp\n: Defined in doio.c, used only in pp_sys.c\np\t|I32\t|do_msgsnd\t|NN SV** mark|NN SV** sp\n: Defined in doio.c, used only in pp_sys.c\np\t|I32\t|do_semop\t|NN SV** mark|NN SV** sp\n: Defined in doio.c, used only in pp_sys.c\np\t|I32\t|do_shmio\t|I32 optype|NN SV** mark|NN SV** sp\n#endif\nAp\t|void\t|do_join\t|NN SV *sv|NN SV *delim|NN SV **mark|NN SV **sp\n: Used in pp.c and pp_hot.c, prototype generated by regen/opcode.pl\n: p\t|OP*\t|do_kv\n: used in pp.c, pp_hot.c\npR\t|I32\t|do_ncmp\t|NN SV *const left|NN SV *const right\nApmb\t|bool\t|do_open\t|NN GV* gv|NN const char* name|I32 len|int as_raw \\\n\t\t\t\t|int rawmode|int rawperm|NULLOK PerlIO* supplied_fp\nAbp\t|bool\t|do_open9\t|NN GV *gv|NN const char *name|I32 len|int as_raw \\\n\t\t\t\t|int rawmode|int rawperm|NULLOK PerlIO *supplied_fp \\\n\t\t\t\t|NN SV *svs|I32 num\npn\t|void\t|setfd_cloexec|int fd\npn\t|void\t|setfd_inhexec|int fd\np\t|void\t|setfd_cloexec_for_nonsysfd|int fd\np\t|void\t|setfd_inhexec_for_sysfd|int fd\np\t|void\t|setfd_cloexec_or_inhexec_by_sysfdness|int fd\npR\t|int\t|PerlLIO_dup_cloexec|int oldfd\np\t|int\t|PerlLIO_dup2_cloexec|int oldfd|int newfd\npR\t|int\t|PerlLIO_open_cloexec|NN const char *file|int flag\npR\t|int\t|PerlLIO_open3_cloexec|NN const char *file|int flag|int perm\npnoR\t|int\t|my_mkstemp_cloexec|NN char *templte\n#ifdef HAS_PIPE\npR\t|int\t|PerlProc_pipe_cloexec|NN int *pipefd\n#endif\n#ifdef HAS_SOCKET\npR\t|int\t|PerlSock_socket_cloexec|int domain|int type|int protocol\npR\t|int\t|PerlSock_accept_cloexec|int listenfd \\\n\t\t\t\t|NULLOK struct sockaddr *addr \\\n\t\t\t\t|NULLOK Sock_size_t *addrlen\n#endif\n#if defined (HAS_SOCKETPAIR) || \\\n    (defined (HAS_SOCKET) && defined(SOCK_DGRAM) && \\\n\tdefined(AF_INET) && defined(PF_INET))\npR\t|int\t|PerlSock_socketpair_cloexec|int domain|int type|int protocol \\\n\t\t\t\t|NN int *pairfd\n#endif\n#if defined(PERL_IN_DOIO_C)\ns\t|IO *\t|openn_setup    |NN GV *gv|NN char *mode|NN PerlIO **saveifp \\\n\t\t\t\t|NN PerlIO **saveofp|NN int *savefd \\\n                                |NN char *savetype\ns\t|bool\t|openn_cleanup\t|NN GV *gv|NN IO *io|NULLOK PerlIO *fp \\\n\t\t\t\t|NN char *mode|NN const char *oname \\\n                                |NULLOK PerlIO *saveifp|NULLOK PerlIO *saveofp \\\n                                |int savefd|char savetype|int writing \\\n                                |bool was_fdopen|NULLOK const char *type \\\n                                |NULLOK Stat_t *statbufp\n#endif\nAp\t|bool\t|do_openn\t|NN GV *gv|NN const char *oname|I32 len \\\n\t\t\t\t|int as_raw|int rawmode|int rawperm \\\n\t\t\t\t|NULLOK PerlIO *supplied_fp|NULLOK SV **svp \\\n\t\t\t\t|I32 num\nMp\t|bool\t|do_open_raw\t|NN GV *gv|NN const char *oname|STRLEN len \\\n\t\t\t\t|int rawmode|int rawperm|NULLOK Stat_t *statbufp\nMp\t|bool\t|do_open6\t|NN GV *gv|NN const char *oname|STRLEN len \\\n\t\t\t\t|NULLOK PerlIO *supplied_fp|NULLOK SV **svp \\\n\t\t\t\t|U32 num\n: Used in pp_hot.c and pp_sys.c\np\t|bool\t|do_print\t|NULLOK SV* sv|NN PerlIO* fp\n: Used in pp_sys.c\npR\t|OP*\t|do_readline\n: Defined in doio.c, used only in pp_sys.c\np\t|bool\t|do_seek\t|NULLOK GV* gv|Off_t pos|int whence\nAp\t|void\t|do_sprintf\t|NN SV* sv|SSize_t len|NN SV** sarg\n: Defined in doio.c, used only in pp_sys.c\np\t|Off_t\t|do_sysseek\t|NN GV* gv|Off_t pos|int whence\n: Defined in doio.c, used only in pp_sys.c\npR\t|Off_t\t|do_tell\t|NN GV* gv\n: Defined in doop.c, used only in pp.c\np\t|Size_t\t|do_trans\t|NN SV* sv\n: Used in my.c and pp.c\np\t|UV\t|do_vecget\t|NN SV* sv|STRLEN offset|int size\n: Defined in doop.c, used only in mg.c (with /* XXX slurp this routine */)\np\t|void\t|do_vecset\t|NN SV* sv\n: Defined in doop.c, used only in pp.c\np\t|void\t|do_vop\t\t|I32 optype|NN SV* sv|NN SV* left|NN SV* right\n: Used in perly.y\np\t|OP*\t|dofile\t\t|NN OP* term|I32 force_builtin\nApR\t|U8\t|dowantarray\nAp\t|void\t|dump_all\np\t|void\t|dump_all_perl\t|bool justperl\nAp\t|void\t|dump_eval\nAp\t|void\t|dump_form\t|NN const GV* gv\nAp\t|void\t|gv_dump\t|NULLOK GV* gv\nApd\t|OPclass|op_class\t|NULLOK const OP *o\nAp\t|void\t|op_dump\t|NN const OP *o\nAp\t|void\t|pmop_dump\t|NULLOK PMOP* pm\nAp\t|void\t|dump_packsubs\t|NN const HV* stash\np\t|void\t|dump_packsubs_perl\t|NN const HV* stash|bool justperl\nAp\t|void\t|dump_sub\t|NN const GV* gv\np\t|void\t|dump_sub_perl\t|NN const GV* gv|bool justperl\nApd\t|void\t|fbm_compile\t|NN SV* sv|U32 flags\nApdR\t|char*\t|fbm_instr\t|NN unsigned char* big|NN unsigned char* bigend \\\n\t\t\t\t|NN SV* littlestr|U32 flags\np\t|CV *\t|find_lexical_cv|PADOFFSET off\n: Defined in util.c, used only in perl.c\np\t|char*\t|find_script\t|NN const char *scriptname|bool dosearch \\\n\t\t\t\t|NULLOK const char *const *const search_ext|I32 flags\n#if defined(PERL_IN_OP_C)\ns\t|OP*\t|force_list\t|NULLOK OP* arg|bool nullit\ni\t|OP*\t|op_integerize\t|NN OP *o\ni\t|OP*\t|op_std_init\t|NN OP *o\n#if defined(USE_ITHREADS)\ni\t|void\t|op_relocate_sv\t|NN SV** svp|NN PADOFFSET* targp\n#endif\ni\t|OP*\t|newMETHOP_internal\t|I32 type|I32 flags|NULLOK OP* dynamic_meth \\\n\t\t\t\t\t|NULLOK SV* const_meth\n: FIXME\ns\t|OP*\t|fold_constants\t|NN OP * const o\ns\t|OP*\t|traverse_op_tree|NN OP* top|NN OP* o\n#endif\nAfpd\t|char*\t|form\t\t|NN const char* pat|...\nAp\t|char*\t|vform\t\t|NN const char* pat|NULLOK va_list* args\nAp\t|void\t|free_tmps\n#if defined(PERL_IN_OP_C)\ns\t|OP*\t|gen_constant_list|NULLOK OP* o\n#endif\n#if !defined(HAS_GETENV_LEN)\n: Used in hv.c\np\t|char*\t|getenv_len\t|NN const char *env_elem|NN unsigned long *len\n#endif\n: Used in pp_ctl.c and pp_hot.c\npox\t|void\t|get_db_sub\t|NULLOK SV **svp|NN CV *cv\nAp\t|void\t|gp_free\t|NULLOK GV* gv\nAp\t|GP*\t|gp_ref\t\t|NULLOK GP* gp\nAp\t|GV*\t|gv_add_by_type\t|NULLOK GV *gv|svtype type\nApmb\t|GV*\t|gv_AVadd\t|NULLOK GV *gv\nApmb\t|GV*\t|gv_HVadd\t|NULLOK GV *gv\nApmb\t|GV*\t|gv_IOadd\t|NULLOK GV* gv\nAmR\t|GV*\t|gv_autoload4\t|NULLOK HV* stash|NN const char* name \\\n\t\t\t\t|STRLEN len|I32 method\nApR\t|GV*\t|gv_autoload_sv\t|NULLOK HV* stash|NN SV* namesv|U32 flags\nApR\t|GV*\t|gv_autoload_pv\t|NULLOK HV* stash|NN const char* namepv \\\n                                |U32 flags\nApR\t|GV*\t|gv_autoload_pvn\t|NULLOK HV* stash|NN const char* name \\\n                                        |STRLEN len|U32 flags\nAp\t|void\t|gv_check\t|NN HV* stash\nAbp\t|void\t|gv_efullname\t|NN SV* sv|NN const GV* gv\nApmb\t|void\t|gv_efullname3\t|NN SV* sv|NN const GV* gv|NULLOK const char* prefix\nAp\t|void\t|gv_efullname4\t|NN SV* sv|NN const GV* gv|NULLOK const char* prefix|bool keepmain\nAp\t|GV*\t|gv_fetchfile\t|NN const char* name\nAp\t|GV*\t|gv_fetchfile_flags|NN const char *const name|const STRLEN len\\\n\t\t\t\t|const U32 flags\nAmd\t|GV*\t|gv_fetchmeth\t|NULLOK HV* stash|NN const char* name \\\n\t\t\t\t|STRLEN len|I32 level\nApd\t|GV*\t|gv_fetchmeth_sv\t|NULLOK HV* stash|NN SV* namesv|I32 level|U32 flags\nApd\t|GV*\t|gv_fetchmeth_pv\t|NULLOK HV* stash|NN const char* name \\\n                                        |I32 level|U32 flags\nApd\t|GV*\t|gv_fetchmeth_pvn\t|NULLOK HV* stash|NN const char* name \\\n                                        |STRLEN len|I32 level|U32 flags\nAmd\t|GV*\t|gv_fetchmeth_autoload\t|NULLOK HV* stash \\\n\t\t\t\t\t|NN const char* name|STRLEN len \\\n\t\t\t\t\t|I32 level\nApd\t|GV*\t|gv_fetchmeth_sv_autoload\t|NULLOK HV* stash|NN SV* namesv|I32 level|U32 flags\nApd\t|GV*\t|gv_fetchmeth_pv_autoload\t|NULLOK HV* stash|NN const char* name \\\n                                        |I32 level|U32 flags\nApd\t|GV*\t|gv_fetchmeth_pvn_autoload\t|NULLOK HV* stash|NN const char* name \\\n                                        |STRLEN len|I32 level|U32 flags\nApdmb\t|GV*\t|gv_fetchmethod\t|NN HV* stash|NN const char* name\nApd\t|GV*\t|gv_fetchmethod_autoload|NN HV* stash|NN const char* name \\\n\t\t\t\t|I32 autoload\nApM\t|GV*\t|gv_fetchmethod_sv_flags|NN HV* stash|NN SV* namesv|U32 flags\nApM\t|GV*\t|gv_fetchmethod_pv_flags|NN HV* stash|NN const char* name \\\n \t\t\t\t|U32 flags\nApM\t|GV*\t|gv_fetchmethod_pvn_flags|NN HV* stash|NN const char* name \\\n\t\t\t\t|const STRLEN len|U32 flags\nAp\t|GV*\t|gv_fetchpv\t|NN const char *nambeg|I32 add|const svtype sv_type\nAbp\t|void\t|gv_fullname\t|NN SV* sv|NN const GV* gv\nApmb\t|void\t|gv_fullname3\t|NN SV* sv|NN const GV* gv|NULLOK const char* prefix\nAp\t|void\t|gv_fullname4\t|NN SV* sv|NN const GV* gv|NULLOK const char* prefix|bool keepmain\n: Used in scope.c\npMox\t|GP *\t|newGP\t\t|NN GV *const gv\npX\t|void\t|cvgv_set\t|NN CV* cv|NULLOK GV* gv\npoX\t|GV *\t|cvgv_from_hek\t|NN CV* cv\npX\t|void\t|cvstash_set\t|NN CV* cv|NULLOK HV* stash\nAmd\t|void\t|gv_init\t|NN GV* gv|NULLOK HV* stash \\\n                                |NN const char* name|STRLEN len|int multi\nAp\t|void\t|gv_init_sv\t|NN GV* gv|NULLOK HV* stash|NN SV* namesv|U32 flags\nAp\t|void\t|gv_init_pv\t|NN GV* gv|NULLOK HV* stash|NN const char* name \\\n                                |U32 flags\nAp\t|void\t|gv_init_pvn\t|NN GV* gv|NULLOK HV* stash|NN const char* name \\\n                                |STRLEN len|U32 flags\nAp\t|void\t|gv_name_set\t|NN GV* gv|NN const char *name|U32 len|U32 flags\npx\t|GV *\t|gv_override\t|NN const char * const name \\\n\t\t\t\t|const STRLEN len\nXMpd\t|void\t|gv_try_downgrade|NN GV* gv\np\t|void\t|gv_setref\t|NN SV *const dstr|NN SV *const sstr\nApd\t|HV*\t|gv_stashpv\t|NN const char* name|I32 flags\nApd\t|HV*\t|gv_stashpvn\t|NN const char* name|U32 namelen|I32 flags\n#if defined(PERL_IN_GV_C)\ni\t|HV*\t|gv_stashpvn_internal\t|NN const char* name|U32 namelen|I32 flags\ni\t|HV*\t|gv_stashsvpvn_cached\t|NULLOK SV *namesv|NULLOK const char* name|U32 namelen|I32 flags\ni\t|GV*\t|gv_fetchmeth_internal\t|NULLOK HV* stash|NULLOK SV* meth|NULLOK const char* name \\\n\t\t\t\t\t|STRLEN len|I32 level|U32 flags\n#endif\nApd\t|HV*\t|gv_stashsv\t|NN SV* sv|I32 flags\nApd\t|void\t|hv_clear\t|NULLOK HV *hv\n: used in SAVEHINTS() and op.c\nApdR\t|HV *\t|hv_copy_hints_hv|NULLOK HV *const ohv\nAp\t|void\t|hv_delayfree_ent|NN HV *hv|NULLOK HE *entry\nAbmdp\t|SV*\t|hv_delete\t|NULLOK HV *hv|NN const char *key|I32 klen \\\n\t\t\t\t|I32 flags\nAbmdp\t|SV*\t|hv_delete_ent\t|NULLOK HV *hv|NN SV *keysv|I32 flags|U32 hash\nAbmdRp\t|bool\t|hv_exists\t|NULLOK HV *hv|NN const char *key|I32 klen\nAbmdRp\t|bool\t|hv_exists_ent\t|NULLOK HV *hv|NN SV *keysv|U32 hash\nAbmdp\t|SV**\t|hv_fetch\t|NULLOK HV *hv|NN const char *key|I32 klen \\\n\t\t\t\t|I32 lval\nAbmdp\t|HE*\t|hv_fetch_ent\t|NULLOK HV *hv|NN SV *keysv|I32 lval|U32 hash\nAp\t|void*\t|hv_common\t|NULLOK HV *hv|NULLOK SV *keysv \\\n\t\t\t\t|NULLOK const char* key|STRLEN klen|int flags \\\n\t\t\t\t|int action|NULLOK SV *val|U32 hash\nAp\t|void*\t|hv_common_key_len|NULLOK HV *hv|NN const char *key \\\n\t\t\t\t|I32 klen_i32|const int action|NULLOK SV *val \\\n\t\t\t\t|const U32 hash\nApod\t|STRLEN\t|hv_fill\t|NN HV *const hv\nAp\t|void\t|hv_free_ent\t|NN HV *hv|NULLOK HE *entry\nApd\t|I32\t|hv_iterinit\t|NN HV *hv\nApdR\t|char*\t|hv_iterkey\t|NN HE* entry|NN I32* retlen\nApdR\t|SV*\t|hv_iterkeysv\t|NN HE* entry\nApdRbm\t|HE*\t|hv_iternext\t|NN HV *hv\nApdR\t|SV*\t|hv_iternextsv\t|NN HV *hv|NN char **key|NN I32 *retlen\nApMdR\t|HE*\t|hv_iternext_flags|NN HV *hv|I32 flags\nApdR\t|SV*\t|hv_iterval\t|NN HV *hv|NN HE *entry\nAp\t|void\t|hv_ksplit\t|NN HV *hv|IV newmax\nApdbm\t|void\t|hv_magic\t|NN HV *hv|NULLOK GV *gv|int how\n#if defined(PERL_IN_HV_C)\ns\t|SV *\t|refcounted_he_value\t|NN const struct refcounted_he *he\n#endif\nXpd\t|HV *\t|refcounted_he_chain_2hv|NULLOK const struct refcounted_he *c|U32 flags\nXpd\t|SV *\t|refcounted_he_fetch_pvn|NULLOK const struct refcounted_he *chain \\\n\t\t\t\t|NN const char *keypv|STRLEN keylen|U32 hash|U32 flags\nXpd\t|SV *\t|refcounted_he_fetch_pv|NULLOK const struct refcounted_he *chain \\\n\t\t\t\t|NN const char *key|U32 hash|U32 flags\nXpd\t|SV *\t|refcounted_he_fetch_sv|NULLOK const struct refcounted_he *chain \\\n\t\t\t\t|NN SV *key|U32 hash|U32 flags\nXpd\t|struct refcounted_he *|refcounted_he_new_pvn \\\n\t\t\t\t|NULLOK struct refcounted_he *parent \\\n\t\t\t\t|NN const char *keypv|STRLEN keylen \\\n\t\t\t\t|U32 hash|NULLOK SV *value|U32 flags\nXpd\t|struct refcounted_he *|refcounted_he_new_pv \\\n\t\t\t\t|NULLOK struct refcounted_he *parent \\\n\t\t\t\t|NN const char *key \\\n\t\t\t\t|U32 hash|NULLOK SV *value|U32 flags\nXpd\t|struct refcounted_he *|refcounted_he_new_sv \\\n\t\t\t\t|NULLOK struct refcounted_he *parent \\\n\t\t\t\t|NN SV *key \\\n\t\t\t\t|U32 hash|NULLOK SV *value|U32 flags\nXpd\t|void\t|refcounted_he_free|NULLOK struct refcounted_he *he\nXpd\t|struct refcounted_he *|refcounted_he_inc|NULLOK struct refcounted_he *he\nApbmd\t|SV**\t|hv_store\t|NULLOK HV *hv|NULLOK const char *key \\\n\t\t\t\t|I32 klen|NULLOK SV *val|U32 hash\nApbmd\t|HE*\t|hv_store_ent\t|NULLOK HV *hv|NULLOK SV *key|NULLOK SV *val\\\n\t\t\t\t|U32 hash\nApbmM\t|SV**\t|hv_store_flags\t|NULLOK HV *hv|NULLOK const char *key \\\n\t\t\t\t|I32 klen|NULLOK SV *val|U32 hash|int flags\nAmd\t|void\t|hv_undef\t|NULLOK HV *hv\npoX\t|void\t|hv_undef_flags\t|NULLOK HV *hv|U32 flags\nAmP\t|I32\t|ibcmp\t\t|NN const char* a|NN const char* b|I32 len\nAinp\t|I32\t|foldEQ\t\t|NN const char* a|NN const char* b|I32 len\nAmP\t|I32\t|ibcmp_locale\t|NN const char* a|NN const char* b|I32 len\nAinp\t|I32\t|foldEQ_locale\t|NN const char* a|NN const char* b|I32 len\nAm\t|I32\t|ibcmp_utf8\t|NN const char *s1|NULLOK char **pe1|UV l1 \\\n\t\t\t\t|bool u1|NN const char *s2|NULLOK char **pe2 \\\n\t\t\t\t|UV l2|bool u2\nAmd\t|I32\t|foldEQ_utf8\t|NN const char *s1|NULLOK char **pe1|UV l1 \\\n\t\t\t\t|bool u1|NN const char *s2|NULLOK char **pe2 \\\n\t\t\t\t|UV l2|bool u2\nAMp\t|I32\t|foldEQ_utf8_flags |NN const char *s1|NULLOK char **pe1|UV l1 \\\n\t\t\t\t|bool u1|NN const char *s2|NULLOK char **pe2 \\\n\t\t\t\t|UV l2|bool u2|U32 flags\nAinp\t|I32\t|foldEQ_latin1\t|NN const char* a|NN const char* b|I32 len\n#if defined(PERL_IN_DOIO_C)\nsR\t|bool\t|ingroup\t|Gid_t testgid|bool effective\n#endif\n: Used in toke.c\np\t|void\t|init_argv_symbols|int argc|NN char **argv\n: Used in pp_ctl.c\npo\t|void\t|init_dbargs\n: Used in mg.c\np\t|void\t|init_debugger\nAp\t|void\t|init_stacks\nAp\t|void\t|init_tm\t|NN struct tm *ptm\n: Used in perly.y\nAbmnpPR\t|char*\t|instr\t\t|NN const char* big|NN const char* little\n: Used in sv.c\np\t|bool\t|io_close\t|NN IO* io|NULLOK GV *gv \\\n\t\t\t\t|bool not_implicit|bool warn_on_fail\n: Used in perly.y\npR\t|OP*\t|invert\t\t|NULLOK OP* cmd\nApR\t|I32\t|is_lvalue_sub\n: Used in cop.h\nXopR\t|I32\t|was_lvalue_sub\nApMRnP\t|STRLEN\t|_is_utf8_char_helper|NN const U8 * const s|NN const U8 * e|const U32 flags\nAbDMpR\t|U32\t|to_uni_upper_lc|U32 c\nAbDMpR\t|U32\t|to_uni_title_lc|U32 c\nAbDMpR\t|U32\t|to_uni_lower_lc|U32 c\nAbDMpR\t|bool\t|is_uni_alnum\t|UV c\nAbDMpR\t|bool\t|is_uni_alnumc\t|UV c\nAbDMpR\t|bool\t|is_uni_idfirst\t|UV c\nAbDMpR\t|bool\t|is_uni_alpha\t|UV c\nAbDMpPR\t|bool\t|is_uni_ascii\t|UV c\nAbDMpPR\t|bool\t|is_uni_blank\t|UV c\nAbDMpPR\t|bool\t|is_uni_space\t|UV c\nAbDMpPR\t|bool\t|is_uni_cntrl\t|UV c\nAbDMpR\t|bool\t|is_uni_graph\t|UV c\nAbDMpR\t|bool\t|is_uni_digit\t|UV c\nAbDMpR\t|bool\t|is_uni_upper\t|UV c\nAbDMpR\t|bool\t|is_uni_lower\t|UV c\nAbDMpR\t|bool\t|is_uni_print\t|UV c\nAbDMpR\t|bool\t|is_uni_punct\t|UV c\nAbDMpPR\t|bool\t|is_uni_xdigit\t|UV c\nAMp\t|UV\t|to_uni_upper\t|UV c|NN U8 *p|NN STRLEN *lenp\nAMp\t|UV\t|to_uni_title\t|UV c|NN U8 *p|NN STRLEN *lenp\nAbDMpR\t|bool\t|isIDFIRST_lazy\t|NN const char* p\nAbDMpR\t|bool\t|isALNUM_lazy\t|NN const char* p\np\t|void\t|init_uniprops\n#ifdef PERL_IN_UTF8_C\nsnR\t|U8\t|to_lower_latin1|const U8 c|NULLOK U8 *p|NULLOK STRLEN *lenp  \\\n\t\t|const char dummy\n#  ifndef UV_IS_QUAD\nsnR\t|int\t|is_utf8_cp_above_31_bits|NN const U8 * const s\t\t    \\\n\t\t\t\t\t |NN const U8 * const e\t\t    \\\n\t\t\t\t\t |const bool consider_overlongs\n#  endif\n#endif\n#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)\nEXnp\t|UV        |_to_fold_latin1|const U8 c|NN U8 *p|NN STRLEN *lenp|const unsigned int flags\n#endif\n#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)\np\t|UV\t|_to_upper_title_latin1|const U8 c|NN U8 *p|NN STRLEN *lenp|const char S_or_s\n#endif\nAMp\t|UV\t|to_uni_lower\t|UV c|NN U8 *p|NN STRLEN *lenp\nAMmp\t|UV\t|to_uni_fold\t|UV c|NN U8 *p|NN STRLEN *lenp\nAMp\t|UV\t|_to_uni_fold_flags|UV c|NN U8 *p|NN STRLEN *lenp|U8 flags\nAbDMpR\t|bool\t|is_uni_alnum_lc|UV c\nAbDMpR\t|bool\t|is_uni_alnumc_lc|UV c\nAbDMpR\t|bool\t|is_uni_idfirst_lc|UV c\nAMpR\t|bool\t|_is_uni_perl_idcont|UV c\nAMpR\t|bool\t|_is_uni_perl_idstart|UV c\nAbDMpR\t|bool\t|is_uni_alpha_lc|UV c\nAbDMpPR\t|bool\t|is_uni_ascii_lc|UV c\nAbDMpPR\t|bool\t|is_uni_space_lc|UV c\nAbDMpPR\t|bool\t|is_uni_blank_lc|UV c\nAbDMpPR\t|bool\t|is_uni_cntrl_lc|UV c\nAbDMpR\t|bool\t|is_uni_graph_lc|UV c\nAbDMpR\t|bool\t|is_uni_digit_lc|UV c\nAbDMpR\t|bool\t|is_uni_upper_lc|UV c\nAbDMpR\t|bool\t|is_uni_lower_lc|UV c\nAbDMpR\t|bool\t|is_uni_print_lc|UV c\nAbDMpR\t|bool\t|is_uni_punct_lc|UV c\nAbDMpPR\t|bool\t|is_uni_xdigit_lc|UV c\nAndmoR\t|bool\t|is_utf8_invariant_string|NN const U8* const s\t\t    \\\n\t\t|STRLEN len\nAnidR\t|bool\t|is_utf8_invariant_string_loc|NN const U8* const s\t    \\\n\t\t|STRLEN len\t\t\t\t\t\t    \\\n\t\t|NULLOK const U8 ** ep\n#ifndef EBCDIC\nAniR\t|unsigned int|_variant_byte_number|PERL_UINTMAX_T word\n#endif\n#if defined(PERL_CORE) || defined(PERL_EXT)\nEinR\t|Size_t\t|variant_under_utf8_count|NN const U8* const s\t\t    \\\n\t\t|NN const U8* const e\n#endif\nAmnpdRP\t|bool\t|is_ascii_string|NN const U8* const s|STRLEN len\nAmnpdRP\t|bool\t|is_invariant_string|NN const U8* const s|STRLEN len\n#if defined(PERL_CORE) || defined (PERL_EXT)\nEXnidR\t|bool\t|is_utf8_non_invariant_string|NN const U8* const s\t    \\\n\t\t|STRLEN len\n#endif\nAbnpdD\t|STRLEN\t|is_utf8_char\t|NN const U8 *s\nAbmnpd\t|STRLEN\t|is_utf8_char_buf|NN const U8 *buf|NN const U8 *buf_end\nAnidR\t|Size_t\t|isUTF8_CHAR|NN const U8 * const s0\t\t\t    \\\n\t\t\t    |NN const U8 * const e\nAnidR\t|Size_t\t|isSTRICT_UTF8_CHAR |NN const U8 * const s0\t\t    \\\n\t\t\t\t    |NN const U8 * const e\nAnidR\t|Size_t\t|isC9_STRICT_UTF8_CHAR |NN const U8 * const s0\t\t    \\\n\t\t\t\t       |NN const U8 * const e\nAnmdpR\t|bool\t|is_utf8_string\t|NN const U8 *s|STRLEN len\nAnidR\t|bool\t|is_utf8_string_flags\t\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|const U32 flags\nAnmdpR\t|bool\t|is_strict_utf8_string|NN const U8 *s|STRLEN len\nAnmdpR\t|bool\t|is_c9strict_utf8_string|NN const U8 *s|STRLEN len\nAnpdmb\t|bool\t|is_utf8_string_loc\t\t\t\t\t    \\\n\t\t|NN const U8 *s|const STRLEN len|NN const U8 **ep\nAndm\t|bool\t|is_utf8_string_loc_flags\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|NN const U8 **ep\t\t    \\\n\t\t|const U32 flags\nAndm\t|bool\t|is_strict_utf8_string_loc\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|NN const U8 **ep\nAndm\t|bool\t|is_c9strict_utf8_string_loc\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|NN const U8 **ep\nAnipd\t|bool\t|is_utf8_string_loclen\t\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|NULLOK const U8 **ep\t\t    \\\n\t\t|NULLOK STRLEN *el\nAnid\t|bool\t|is_utf8_string_loclen_flags\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|NULLOK const U8 **ep\t\t    \\\n\t\t|NULLOK STRLEN *el|const U32 flags\nAnid\t|bool\t|is_strict_utf8_string_loclen\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|NULLOK const U8 **ep\t    \\\n\t\t|NULLOK STRLEN *el\nAnid\t|bool\t|is_c9strict_utf8_string_loclen\t\t\t\t    \\\n\t\t|NN const U8 *s|STRLEN len|NULLOK const U8 **ep\t    \\\n\t\t|NULLOK STRLEN *el\nAmnd\t|bool\t|is_utf8_fixed_width_buf_flags\t\t\t\t    \\\n\t\t|NN const U8 * const s|STRLEN len|const U32 flags\nAmnd\t|bool\t|is_utf8_fixed_width_buf_loc_flags\t\t\t    \\\n\t\t|NN const U8 * const s|STRLEN len\t\t\t    \\\n\t\t|NULLOK const U8 **ep|const U32 flags\nAnid\t|bool\t|is_utf8_fixed_width_buf_loclen_flags\t\t\t    \\\n\t\t|NN const U8 * const s|STRLEN len\t\t\t    \\\n\t\t|NULLOK const U8 **ep|NULLOK STRLEN *el|const U32 flags\nAmndP\t|bool\t|is_utf8_valid_partial_char\t\t\t\t    \\\n\t\t|NN const U8 * const s|NN const U8 * const e\nAnidR\t|bool\t|is_utf8_valid_partial_char_flags\t\t\t    \\\n\t\t|NN const U8 * const s|NN const U8 * const e|const U32 flags\nAMpR\t|bool\t|_is_uni_FOO|const U8 classnum|const UV c\nAMpR\t|bool\t|_is_utf8_FOO|U8 classnum|NN const U8 * const p\t\t    \\\n\t\t|NN const char * const name\t\t\t\t    \\\n\t\t|NN const char * const alternative\t\t\t    \\\n\t\t|const bool use_utf8|const bool use_locale\t\t    \\\n\t\t|NN const char * const file|const unsigned line\nAMpR\t|bool\t|_is_utf8_FOO_with_len|const U8 classnum|NN const U8 *p\t    \\\n\t\t|NN const U8 * const e\nAbDMpR\t|bool\t|is_utf8_alnum\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_alnumc\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_idfirst|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_xidfirst|NN const U8 *p\nAMpR\t|bool\t|_is_utf8_idcont|NN const U8 *p\nAMpR\t|bool\t|_is_utf8_idstart|NN const U8 *p\nAMpR\t|bool\t|_is_utf8_xidcont|NN const U8 *p\nAMpR\t|bool\t|_is_utf8_xidstart|NN const U8 *p\nAMpR\t|bool\t|_is_utf8_perl_idcont_with_len|NN const U8 *p\t\t    \\\n\t\t|NN const U8 * const e\nAMpR\t|bool\t|_is_utf8_perl_idstart_with_len|NN const U8 *p\t\t    \\\n\t\t|NN const U8 * const e\nAbDMpR\t|bool\t|is_utf8_idcont\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_xidcont\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_alpha\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_ascii\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_blank\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_space\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_perl_space\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_perl_word\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_cntrl\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_digit\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_posix_digit\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_graph\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_upper\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_lower\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_print\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_punct\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_xdigit\t|NN const U8 *p\nAMpR\t|bool\t|_is_utf8_mark\t|NN const U8 *p\nAbDMpR\t|bool\t|is_utf8_mark\t|NN const U8 *p\n#if defined(PERL_CORE) || defined(PERL_EXT)\nEXdpR\t|bool\t|isSCRIPT_RUN\t|NN const U8 *s|NN const U8 *send   \\\n\t\t\t\t|const bool utf8_target\n#endif\n: Used in perly.y\np\t|OP*\t|jmaybe\t\t|NN OP *o\n: Used in pp.c \npP\t|I32\t|keyword\t|NN const char *name|I32 len|bool all_keywords\n#if defined(PERL_IN_OP_C)\ns\t|void\t|inplace_aassign\t|NN OP* o\n#endif\nAp\t|void\t|leave_scope\t|I32 base\np\t|void\t|notify_parser_that_changed_to_utf8\n: Public lexer API\nAMpd\t|void\t|lex_start\t|NULLOK SV* line|NULLOK PerlIO *rsfp|U32 flags\nAMpd\t|bool\t|lex_bufutf8\nAMpd\t|char*\t|lex_grow_linestr|STRLEN len\nAMpd\t|void\t|lex_stuff_pvn\t|NN const char* pv|STRLEN len|U32 flags\nAMpd\t|void\t|lex_stuff_pv\t|NN const char* pv|U32 flags\nAMpd\t|void\t|lex_stuff_sv\t|NN SV* sv|U32 flags\nAMpd\t|void\t|lex_unstuff\t|NN char* ptr\nAMpd\t|void\t|lex_read_to\t|NN char* ptr\nAMpd\t|void\t|lex_discard_to\t|NN char* ptr\nAMpd\t|bool\t|lex_next_chunk\t|U32 flags\nAMpd\t|I32\t|lex_peek_unichar|U32 flags\nAMpd\t|I32\t|lex_read_unichar|U32 flags\nAMpd\t|void\t|lex_read_space\t|U32 flags\n: Public parser API\nAMpd\t|OP*\t|parse_arithexpr|U32 flags\nAMpd\t|OP*\t|parse_termexpr\t|U32 flags\nAMpd\t|OP*\t|parse_listexpr\t|U32 flags\nAMpd\t|OP*\t|parse_fullexpr\t|U32 flags\nAMpd\t|OP*\t|parse_block\t|U32 flags\nAMpd\t|OP*\t|parse_barestmt\t|U32 flags\nAMpd\t|SV*\t|parse_label\t|U32 flags\nAMpd\t|OP*\t|parse_fullstmt\t|U32 flags\nAMpd\t|OP*\t|parse_stmtseq\t|U32 flags\n: Used in various files\nApd\t|void\t|op_null\t|NN OP* o\n: FIXME. Used by Data::Alias\nEXp\t|void\t|op_clear\t|NN OP* o\nAp\t|void\t|op_refcnt_lock\nAp\t|void\t|op_refcnt_unlock\nApdn\t|OP*\t|op_sibling_splice|NULLOK OP *parent|NULLOK OP *start \\\n\t\t|int del_count|NULLOK OP* insert\nApdn\t|OP*\t|op_parent|NN OP *o\n#if defined(PERL_IN_OP_C)\ns\t|OP*\t|listkids\t|NULLOK OP* o\n#endif\np\t|OP*\t|list\t\t|NULLOK OP* o\nApd\t|void\t|load_module|U32 flags|NN SV* name|NULLOK SV* ver|...\nAp\t|void\t|vload_module|U32 flags|NN SV* name|NULLOK SV* ver|NULLOK va_list* args\n: Used in perly.y\np\t|OP*\t|localize\t|NN OP *o|I32 lex\nApdR\t|I32\t|looks_like_number|NN SV *const sv\nApd\t|UV\t|grok_bin\t|NN const char* start|NN STRLEN* len_p|NN I32* flags|NULLOK NV *result\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_TOKE_C) || defined(PERL_IN_DQUOTE_C)\nEMpRX\t|bool\t|grok_bslash_x\t|NN char** s\t\t \\\n\t\t\t\t|NN const char* const send\t \\\n\t\t\t\t|NN UV* uv\t\t\t \\\n\t\t\t\t|NN const char** error_msg       \\\n\t\t\t\t|const bool output_warning       \\\n\t\t\t\t|const bool strict               \\\n\t\t\t\t|const bool silence_non_portable \\\n\t\t\t\t|const bool utf8\nEMpRX\t|char\t|grok_bslash_c\t|const char source|const bool output_warning\nEMpRX\t|bool\t|grok_bslash_o\t|NN char** s\t\t \\\n\t\t\t\t|NN const char* const send\t \\\n\t\t\t\t|NN UV* uv\t\t\t \\\n\t\t\t\t|NN const char** error_msg       \\\n\t\t\t\t|const bool output_warning       \\\n\t\t\t\t|const bool strict               \\\n\t\t\t\t|const bool silence_non_portable \\\n\t\t\t\t|const bool utf8\nEMiR\t|char*|form_short_octal_warning|NN const char * const s  \\\n\t\t\t\t|const STRLEN len\nEiRn\t|I32\t|regcurly\t|NN const char *s\n#endif\nApd\t|UV\t|grok_hex\t|NN const char* start|NN STRLEN* len_p|NN I32* flags|NULLOK NV *result\nApd\t|int\t|grok_infnan\t|NN const char** sp|NN const char *send\nApd\t|int\t|grok_number\t|NN const char *pv|STRLEN len|NULLOK UV *valuep\nApd\t|int\t|grok_number_flags|NN const char *pv|STRLEN len|NULLOK UV *valuep|U32 flags\nApdR\t|bool\t|grok_numeric_radix|NN const char **sp|NN const char *send\nApd\t|UV\t|grok_oct\t|NN const char* start|NN STRLEN* len_p|NN I32* flags|NULLOK NV *result\nEXpn\t|bool\t|grok_atoUV\t|NN const char* pv|NN UV* valptr|NULLOK const char** endptr\n: These are all indirectly referenced by globals.c. This is somewhat annoying.\np\t|int\t|magic_clearenv\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_clear_all_env|NN SV* sv|NN MAGIC* mg\ndp\t|int\t|magic_clearhint|NN SV* sv|NN MAGIC* mg\ndp\t|int\t|magic_clearhints|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_clearisa\t|NULLOK SV* sv|NN MAGIC* mg\np\t|int\t|magic_clearpack|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_clearsig\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_copycallchecker|NN SV* sv|NN MAGIC *mg|NN SV *nsv \\\n\t\t\t\t      |NULLOK const char *name|I32 namlen\np\t|int\t|magic_existspack|NN SV* sv|NN const MAGIC* mg\np\t|int\t|magic_freeovrld|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_get\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getarylen|NN SV* sv|NN const MAGIC* mg\np\t|int\t|magic_getdefelem|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getdebugvar|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getnkeys\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getpack\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getpos\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getsig\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getsubstr|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_gettaint\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getuvar\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_getvec\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_nextpack\t|NN SV *sv|NN MAGIC *mg|NN SV *key\np\t|U32\t|magic_regdata_cnt|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_regdatum_get|NN SV* sv|NN MAGIC* mg\n:removing noreturn to silence a warning for this function resulted in no\n:change to the interpreter DLL image under VS 2003 -O1 -GL 32 bits only because\n:this is used in a magic vtable, do not use this on conventionally called funcs\n#ifdef _MSC_VER\np\t|int\t|magic_regdatum_set|NN SV* sv|NN MAGIC* mg\n#else\npr\t|int\t|magic_regdatum_set|NN SV* sv|NN MAGIC* mg\n#endif\np\t|int\t|magic_set\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setarylen|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_cleararylen_p|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_freearylen_p|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setdbline|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setdebugvar|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setdefelem|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setnonelem|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setenv\t|NN SV* sv|NN MAGIC* mg\ndp\t|int\t|magic_sethint\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setisa\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setlvref\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setmglob\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setnkeys\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setpack\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setpos\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setregexp|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setsig\t|NULLOK SV* sv|NN MAGIC* mg\np\t|int\t|magic_setsubstr|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_settaint\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setuvar\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setvec\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_setutf8\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_set_all_env|NN SV* sv|NN MAGIC* mg\np\t|U32\t|magic_sizepack\t|NN SV* sv|NN MAGIC* mg\np\t|int\t|magic_wipepack\t|NN SV* sv|NN MAGIC* mg\npod\t|SV*\t|magic_methcall\t|NN SV *sv|NN const MAGIC *mg \\\n\t\t\t\t|NN SV *meth|U32 flags \\\n\t\t\t\t|U32 argc|...\nAp\t|I32 *\t|markstack_grow\n#if defined(USE_LOCALE_COLLATE)\np\t|int\t|magic_setcollxfrm|NN SV* sv|NN MAGIC* mg\npb\t|char*\t|mem_collxfrm\t|NN const char* input_string|STRLEN len|NN STRLEN* xlen\n: Defined in locale.c, used only in sv.c\n#   if defined(PERL_IN_LOCALE_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_MATHOMS_C)\npM\t|char*\t|_mem_collxfrm\t|NN const char* input_string\t\\\n\t\t\t\t|STRLEN len\t\t\t\\\n\t\t\t\t|NN STRLEN* xlen\t\t\\\n\t\t\t\t|bool utf8\n#   endif\n#endif\nAfpd\t|SV*\t|mess\t\t|NN const char* pat|...\nApd\t|SV*\t|mess_sv\t|NN SV* basemsg|bool consume\nApd\t|SV*\t|vmess\t\t|NN const char* pat|NULLOK va_list* args\n: FIXME - either make it public, or stop exporting it. (Data::Alias uses this)\n: Used in gv.c, op.c, toke.c\nEXp\t|void\t|qerror\t\t|NN SV* err\nApd\t|void\t|sortsv\t\t|NULLOK SV** array|size_t num_elts|NN SVCOMPARE_t cmp\nApd\t|void\t|sortsv_flags\t|NULLOK SV** array|size_t num_elts|NN SVCOMPARE_t cmp|U32 flags\nApd\t|int\t|mg_clear\t|NN SV* sv\nApd\t|int\t|mg_copy\t|NN SV *sv|NN SV *nsv|NULLOK const char *key \\\n\t\t\t\t|I32 klen\n: Defined in mg.c, used only in scope.c\npd\t|void\t|mg_localize\t|NN SV* sv|NN SV* nsv|bool setmagic\nApd\t|SV*\t|sv_string_from_errnum|int errnum|NULLOK SV* tgtsv\nApdRn\t|MAGIC*\t|mg_find\t|NULLOK const SV* sv|int type\nApdRn\t|MAGIC*\t|mg_findext\t|NULLOK const SV* sv|int type|NULLOK const MGVTBL *vtbl\n: exported for re.pm\nEXpR\t|MAGIC*\t|mg_find_mglob\t|NN SV* sv\nApd\t|int\t|mg_free\t|NN SV* sv\nApd\t|void\t|mg_free_type\t|NN SV* sv|int how\nApd\t|void\t|mg_freeext\t|NN SV* sv|int how|NULLOK const MGVTBL *vtbl\nApd\t|int\t|mg_get\t\t|NN SV* sv\nApdD\t|U32\t|mg_length\t|NN SV* sv\nApdn\t|void\t|mg_magical\t|NN SV* sv\nApd\t|int\t|mg_set\t\t|NN SV* sv\nAp\t|I32\t|mg_size\t|NN SV* sv\nApn\t|void\t|mini_mktime\t|NN struct tm *ptm\nAMmd\t|OP*\t|op_lvalue\t|NULLOK OP* o|I32 type\npoX\t|OP*\t|op_lvalue_flags|NULLOK OP* o|I32 type|U32 flags\np\t|void\t|finalize_optree\t\t|NN OP* o\np\t|void\t|optimize_optree|NN OP* o\n#if defined(PERL_IN_OP_C)\ns\t|void\t|optimize_op\t|NN OP* o\ns\t|void\t|finalize_op\t|NN OP* o\ns\t|void\t|move_proto_attr|NN OP **proto|NN OP **attrs \\\n\t\t\t\t|NN const GV *name|bool curstash\n#endif\n: Used in op.c and pp_sys.c\np\t|int\t|mode_from_discipline|NULLOK const char* s|STRLEN len\nAp\t|const char*\t|moreswitches\t|NN const char* s\nAp\t|NV\t|my_atof\t|NN const char *s\nAnpR\t|NV\t|my_strtod\t|NN const char * const s|NULLOK char ** e\nApr\t|void\t|my_exit\t|U32 status\nApr\t|void\t|my_failure_exit\nAp\t|I32\t|my_fflush_all\nAnp\t|Pid_t\t|my_fork\nAnp\t|void\t|atfork_lock\nAnp\t|void\t|atfork_unlock\nApmb\t|I32\t|my_lstat\npX\t|I32\t|my_lstat_flags\t|NULLOK const U32 flags\n#if ! defined(HAS_MEMRCHR) && (defined(PERL_CORE) || defined(PERL_EXT))\nExin\t|void *\t|my_memrchr\t|NN const char * s|const char c|const STRLEN len\n#endif\n#if !defined(PERL_IMPLICIT_SYS)\nAp\t|I32\t|my_pclose\t|NULLOK PerlIO* ptr\nAp\t|PerlIO*|my_popen\t|NN const char* cmd|NN const char* mode\n#endif\nAp\t|PerlIO*|my_popen_list\t|NN const char* mode|int n|NN SV ** args\nAp\t|void\t|my_setenv\t|NULLOK const char* nam|NULLOK const char* val\nApmb\t|I32\t|my_stat\npX\t|I32\t|my_stat_flags\t|NULLOK const U32 flags\nAfp\t|char *\t|my_strftime\t|NN const char *fmt|int sec|int min|int hour|int mday|int mon|int year|int wday|int yday|int isdst\n: Used in pp_ctl.c\np\t|void\t|my_unexec\nAbDMnPR\t|UV\t|NATIVE_TO_NEED\t|const UV enc|const UV ch\nAbDMnPR\t|UV\t|ASCII_TO_NEED\t|const UV enc|const UV ch\nApR\t|OP*\t|newANONLIST\t|NULLOK OP* o\nApR\t|OP*\t|newANONHASH\t|NULLOK OP* o\nAp\t|OP*\t|newANONSUB\t|I32 floor|NULLOK OP* proto|NULLOK OP* block\nApdR\t|OP*\t|newASSIGNOP\t|I32 flags|NULLOK OP* left|I32 optype|NULLOK OP* right\nApdR\t|OP*\t|newCONDOP\t|I32 flags|NN OP* first|NULLOK OP* trueop|NULLOK OP* falseop\nApd\t|CV*\t|newCONSTSUB\t|NULLOK HV* stash|NULLOK const char* name|NULLOK SV* sv\nApd\t|CV*\t|newCONSTSUB_flags|NULLOK HV* stash \\\n\t\t\t\t  |NULLOK const char* name|STRLEN len \\\n\t\t\t\t  |U32 flags|NULLOK SV* sv\nAp\t|void\t|newFORM\t|I32 floor|NULLOK OP* o|NULLOK OP* block\nApdR\t|OP*\t|newFOROP\t|I32 flags|NULLOK OP* sv|NN OP* expr|NULLOK OP* block|NULLOK OP* cont\nApdR\t|OP*\t|newGIVENOP\t|NN OP* cond|NN OP* block|PADOFFSET defsv_off\nApdR\t|OP*\t|newLOGOP\t|I32 optype|I32 flags|NN OP *first|NN OP *other\npM\t|LOGOP*\t|alloc_LOGOP\t|I32 type|NULLOK OP *first|NULLOK OP *other\nApdR\t|OP*\t|newLOOPEX\t|I32 type|NN OP* label\nApdR\t|OP*\t|newLOOPOP\t|I32 flags|I32 debuggable|NULLOK OP* expr|NULLOK OP* block\nApdR\t|OP*\t|newNULLLIST\nApdR\t|OP*\t|newOP\t\t|I32 optype|I32 flags\nAp\t|void\t|newPROG\t|NN OP* o\nApdR\t|OP*\t|newRANGE\t|I32 flags|NN OP* left|NN OP* right\nApdR\t|OP*\t|newSLICEOP\t|I32 flags|NULLOK OP* subscript|NULLOK OP* listop\nApdR\t|OP*\t|newSTATEOP\t|I32 flags|NULLOK char* label|NULLOK OP* o\nApbm\t|CV*\t|newSUB\t\t|I32 floor|NULLOK OP* o|NULLOK OP* proto \\\n\t\t\t\t|NULLOK OP* block\npd\t|CV *\t|newXS_len_flags|NULLOK const char *name|STRLEN len \\\n\t\t\t\t|NN XSUBADDR_t subaddr\\\n\t\t\t\t|NULLOK const char *const filename \\\n\t\t\t\t|NULLOK const char *const proto \\\n\t\t\t\t|NULLOK SV **const_svp|U32 flags\npX\t|CV *\t|newXS_deffile\t|NN const char *name|NN XSUBADDR_t subaddr\nApM\t|CV *\t|newXS_flags\t|NULLOK const char *name|NN XSUBADDR_t subaddr\\\n\t\t\t\t|NN const char *const filename \\\n\t\t\t\t|NULLOK const char *const proto|U32 flags\nApd\t|CV*\t|newXS\t\t|NULLOK const char *name|NN XSUBADDR_t subaddr\\\n\t\t\t\t|NN const char *filename\nApmdbR\t|AV*\t|newAV\nApR\t|OP*\t|newAVREF\t|NN OP* o\nApdR\t|OP*\t|newBINOP\t|I32 type|I32 flags|NULLOK OP* first|NULLOK OP* last\nApR\t|OP*\t|newCVREF\t|I32 flags|NULLOK OP* o\nApdR\t|OP*\t|newGVOP\t|I32 type|I32 flags|NN GV* gv\nAm\t|GV*\t|newGVgen\t|NN const char* pack\nApR\t|GV*\t|newGVgen_flags\t|NN const char* pack|U32 flags\nApR\t|OP*\t|newGVREF\t|I32 type|NULLOK OP* o\nApR\t|OP*\t|newHVREF\t|NN OP* o\nApmdbR\t|HV*\t|newHV\nApR\t|HV*\t|newHVhv\t|NULLOK HV *hv\nApRbm\t|IO*\t|newIO\nApdR\t|OP*\t|newLISTOP\t|I32 type|I32 flags|NULLOK OP* first|NULLOK OP* last\nAMpdRn\t|PADNAME *|newPADNAMEouter|NN PADNAME *outer\nAMpdRn\t|PADNAME *|newPADNAMEpvn|NN const char *s|STRLEN len\nAMpdRn\t|PADNAMELIST *|newPADNAMELIST|size_t max\n#ifdef USE_ITHREADS\nApdR\t|OP*\t|newPADOP\t|I32 type|I32 flags|NN SV* sv\n#endif\nApdR\t|OP*\t|newPMOP\t|I32 type|I32 flags\nApdR\t|OP*\t|newPVOP\t|I32 type|I32 flags|NULLOK char* pv\nApR\t|SV*\t|newRV\t\t|NN SV *const sv\nApdR\t|SV*\t|newRV_noinc\t|NN SV *const tmpRef\nApdR\t|SV*\t|newSV\t\t|const STRLEN len\nApR\t|OP*\t|newSVREF\t|NN OP* o\nApdR\t|OP*\t|newSVOP\t|I32 type|I32 flags|NN SV* sv\nApdR\t|OP*\t|newDEFSVOP\npR\t|SV*\t|newSVavdefelem\t|NN AV *av|SSize_t ix|bool extendible\nApdR\t|SV*\t|newSViv\t|const IV i\nApdR\t|SV*\t|newSVuv\t|const UV u\nApdR\t|SV*\t|newSVnv\t|const NV n\nApdR\t|SV*\t|newSVpv\t|NULLOK const char *const s|const STRLEN len\nApdR\t|SV*\t|newSVpvn\t|NULLOK const char *const buffer|const STRLEN len\nApdR\t|SV*\t|newSVpvn_flags\t|NULLOK const char *const s|const STRLEN len|const U32 flags\nApdR\t|SV*\t|newSVhek\t|NULLOK const HEK *const hek\nApdR\t|SV*\t|newSVpvn_share\t|NULLOK const char* s|I32 len|U32 hash\nApdR\t|SV*\t|newSVpv_share\t|NULLOK const char* s|U32 hash\nAfpdR\t|SV*\t|newSVpvf\t|NN const char *const pat|...\nApR\t|SV*\t|vnewSVpvf\t|NN const char *const pat|NULLOK va_list *const args\nApd\t|SV*\t|newSVrv\t|NN SV *const rv|NULLOK const char *const classname\nApmbdR\t|SV*\t|newSVsv\t|NULLOK SV *const old\nApmdR\t|SV*\t|newSVsv_nomg\t|NULLOK SV *const old\nApR\t|SV*\t|newSVsv_flags\t|NULLOK SV *const old|I32 flags\nApdR\t|SV*\t|newSV_type\t|const svtype type\nApdR\t|OP*\t|newUNOP\t|I32 type|I32 flags|NULLOK OP* first\nApdR\t|OP*\t|newUNOP_AUX\t|I32 type|I32 flags|NULLOK OP* first \\\n\t\t\t\t|NULLOK UNOP_AUX_item *aux\nApdR\t|OP*\t|newWHENOP\t|NULLOK OP* cond|NN OP* block\nApdR\t|OP*\t|newWHILEOP\t|I32 flags|I32 debuggable|NULLOK LOOP* loop \\\n\t\t\t\t|NULLOK OP* expr|NULLOK OP* block|NULLOK OP* cont \\\n\t\t\t\t|I32 has_my\nApdR\t|OP*\t|newMETHOP\t|I32 type|I32 flags|NN OP* dynamic_meth\nApdR\t|OP*\t|newMETHOP_named|I32 type|I32 flags|NN SV* const_meth\nApd\t|CV*\t|rv2cv_op_cv\t|NN OP *cvop|U32 flags\nApd\t|OP*\t|ck_entersub_args_list|NN OP *entersubop\nApd\t|OP*\t|ck_entersub_args_proto|NN OP *entersubop|NN GV *namegv|NN SV *protosv\nApd\t|OP*\t|ck_entersub_args_proto_or_list|NN OP *entersubop|NN GV *namegv|NN SV *protosv\npo\t|OP*\t|ck_entersub_args_core|NN OP *entersubop|NN GV *namegv \\\n\t\t\t\t      |NN SV *protosv\nApd\t|void\t|cv_get_call_checker|NN CV *cv|NN Perl_call_checker *ckfun_p|NN SV **ckobj_p\nApd\t|void\t|cv_get_call_checker_flags|NN CV *cv|U32 gflags|NN Perl_call_checker *ckfun_p|NN SV **ckobj_p|NN U32 *ckflags_p\nApd\t|void\t|cv_set_call_checker|NN CV *cv|NN Perl_call_checker ckfun|NN SV *ckobj\nApd\t|void\t|cv_set_call_checker_flags|NN CV *cv \\\n\t\t\t\t\t  |NN Perl_call_checker ckfun \\\n\t\t\t\t\t  |NN SV *ckobj|U32 ckflags\nApd\t|void\t|wrap_op_checker|Optype opcode|NN Perl_check_t new_checker|NN Perl_check_t *old_checker_p\nAMpd\t|void\t|wrap_keyword_plugin|NN Perl_keyword_plugin_t new_plugin|NN Perl_keyword_plugin_t *old_plugin_p\nApR\t|PERL_SI*|new_stackinfo|I32 stitems|I32 cxitems\nAp\t|char*\t|scan_vstring\t|NN const char *s|NN const char *const e \\\n\t\t\t\t|NN SV *sv\nApd\t|const char*\t|scan_version\t|NN const char *s|NN SV *rv|bool qv\nApd\t|const char*\t|prescan_version\t|NN const char *s\\\n\t|bool strict|NULLOK const char** errstr|NULLOK bool *sqv\\\n\t|NULLOK int *ssaw_decimal|NULLOK int *swidth|NULLOK bool *salpha\nApd\t|SV*\t|new_version\t|NN SV *ver\nApd\t|SV*\t|upg_version\t|NN SV *ver|bool qv\nApd\t|SV*\t|vverify\t|NN SV *vs\nApd\t|SV*\t|vnumify\t|NN SV *vs\nApd\t|SV*\t|vnormal\t|NN SV *vs\nApd\t|SV*\t|vstringify\t|NN SV *vs\nApd\t|int\t|vcmp\t\t|NN SV *lhv|NN SV *rhv\n: Used in pp_hot.c and pp_sys.c\np\t|PerlIO*|nextargv\t|NN GV* gv|bool nomagicopen\n#ifdef HAS_MEMMEM\nAdnopP\t|char*\t|ninstr\t\t|NN const char* big|NN const char* bigend \\\n\t\t\t\t|NN const char* little|NN const char* lend\n#else\nAdnpP\t|char*\t|ninstr\t\t|NN const char* big|NN const char* bigend \\\n\t\t\t\t|NN const char* little|NN const char* lend\n#endif\nApd\t|void\t|op_free\t|NULLOK OP* arg\nMp\t|OP*\t|op_unscope\t|NULLOK OP* o\n#ifdef PERL_CORE\np\t|void\t|opslab_free\t|NN OPSLAB *slab\np\t|void\t|opslab_free_nopad|NN OPSLAB *slab\np\t|void\t|opslab_force_free|NN OPSLAB *slab\n#endif\n: Used in perly.y\np\t|void\t|package\t|NN OP* o\n: Used in perly.y\np\t|void\t|package_version|NN OP* v\n: Used in toke.c and perly.y\np\t|PADOFFSET|allocmy\t|NN const char *const name|const STRLEN len\\\n\t\t\t\t|const U32 flags\n#ifdef USE_ITHREADS\nAMp\t|PADOFFSET|alloccopstash|NN HV *hv\n#endif\n: Used in perly.y\npR\t|OP*\t|oopsAV\t\t|NN OP* o\n: Used in perly.y\npR\t|OP*\t|oopsHV\t\t|NN OP* o\n\n: peephole optimiser\np\t|void\t|peep\t\t|NULLOK OP* o\np\t|void\t|rpeep\t\t|NULLOK OP* o\n: Defined in doio.c, used only in pp_hot.c\ndopM\t|PerlIO*|start_glob\t|NN SV *tmpglob|NN IO *io\n\nAp\t|void\t|reentrant_size\nAp\t|void\t|reentrant_init\nAp\t|void\t|reentrant_free\nAnp\t|void*\t|reentrant_retry|NN const char *f|...\n\n: \"Very\" special - can't use the O flag for this one:\n: (The rename from perl_atexit to Perl_call_atexit was in 864dbfa3ca8032ef)\nAp\t|void\t|call_atexit\t|ATEXIT_t fn|NULLOK void *ptr\nApdO\t|I32\t|call_argv\t|NN const char* sub_name|I32 flags|NN char** argv\nApdO\t|I32\t|call_method\t|NN const char* methname|I32 flags\nApdO\t|I32\t|call_pv\t|NN const char* sub_name|I32 flags\nApdO\t|I32\t|call_sv\t|NN SV* sv|volatile I32 flags\nAp\t|void\t|despatch_signals\nAp\t|OP *\t|doref\t\t|NN OP *o|I32 type|bool set_op_ref\nApdO\t|SV*\t|eval_pv\t|NN const char* p|I32 croak_on_error\nApdO\t|I32\t|eval_sv\t|NN SV* sv|I32 flags\nApdO\t|SV*\t|get_sv\t\t|NN const char *name|I32 flags\nApdO\t|AV*\t|get_av\t\t|NN const char *name|I32 flags\nApdO\t|HV*\t|get_hv\t\t|NN const char *name|I32 flags\nApdO\t|CV*\t|get_cv\t\t|NN const char* name|I32 flags\nApd\t|CV*\t|get_cvn_flags\t|NN const char* name|STRLEN len|I32 flags\nAndo\t|const char*|Perl_setlocale|const int category|NULLOK const char* locale\n#if defined(HAS_NL_LANGINFO) && defined(PERL_LANGINFO_H)\nAndo\t|const char*|Perl_langinfo|const nl_item item\n#else\nAndo\t|const char*|Perl_langinfo|const int item\n#endif\nApOM\t|int\t|init_i18nl10n\t|int printwarn\nAbpOM\t|int\t|init_i18nl14n\t|int printwarn\np\t|char*\t|my_strerror\t|const int errnum\nXpn\t|void\t|_warn_problematic_locale\nXp\t|void\t|set_numeric_underlying\nXp\t|void\t|set_numeric_standard\nXp\t|bool\t|_is_in_locale_category|const bool compiling|const int category\nApdn\t|void\t|switch_to_global_locale\nApdn\t|bool\t|sync_locale\nApMn\t|void\t|thread_locale_init\nApMn\t|void\t|thread_locale_term\nApdO\t|void\t|require_pv\t|NN const char* pv\nAbpd\t|void\t|pack_cat\t|NN SV *cat|NN const char *pat|NN const char *patend \\\n\t\t\t\t|NN SV **beglist|NN SV **endlist|NN SV ***next_in_list|U32 flags\nApd\t|void\t|packlist \t|NN SV *cat|NN const char *pat|NN const char *patend|NN SV **beglist|NN SV **endlist\n#if defined(PERL_USES_PL_PIDSTATUS) && defined(PERL_IN_UTIL_C)\ns\t|void\t|pidgone\t|Pid_t pid|int status\n#endif\n: Used in perly.y\np\t|OP*\t|pmruntime\t|NN OP *o|NN OP *expr|NULLOK OP *repl \\\n\t\t\t\t|UV flags|I32 floor\n#if defined(PERL_IN_OP_C)\ns\t|OP*\t|pmtrans\t|NN OP* o|NN OP* expr|NN OP* repl\n#endif\nAp\t|void\t|pop_scope\nAp\t|void\t|push_scope\nApmb\t|OP*\t|ref\t\t|NULLOK OP* o|I32 type\n#if defined(PERL_IN_OP_C)\ns\t|OP*\t|refkids\t|NULLOK OP* o|I32 type\n#endif\nAp\t|void\t|regdump\t|NN const regexp* r\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_PERL_C) || defined(PERL_IN_UTF8_C)\nEXpR\t|SV*\t|_new_invlist_C_array|NN const UV* const list\nEXMp\t|bool\t|_invlistEQ\t|NN SV* const a|NN SV* const b|const bool complement_b\n#endif\nAp\t|I32\t|pregexec\t|NN REGEXP * const prog|NN char* stringarg \\\n\t\t\t\t|NN char* strend|NN char* strbeg \\\n\t\t\t\t|SSize_t minend |NN SV* screamer|U32 nosave\nAp\t|void\t|pregfree\t|NULLOK REGEXP* r\nAp\t|void\t|pregfree2\t|NN REGEXP *rx\n: FIXME - is anything in re using this now?\nEXp\t|REGEXP*|reg_temp_copy\t|NULLOK REGEXP* dsv|NN REGEXP* ssv\nAp\t|void\t|regfree_internal|NN REGEXP *const rx\n#if defined(USE_ITHREADS)\nAp\t|void*\t|regdupe_internal|NN REGEXP * const r|NN CLONE_PARAMS* param\n#endif\nEXp\t|regexp_engine const *|current_re_engine\nAp\t|REGEXP*|pregcomp\t|NN SV * const pattern|const U32 flags\np\t|REGEXP*|re_op_compile\t|NULLOK SV ** const patternp \\\n\t\t\t\t|int pat_count|NULLOK OP *expr \\\n\t\t\t\t|NN const regexp_engine* eng \\\n\t\t\t\t|NULLOK REGEXP *old_re \\\n\t\t\t\t|NULLOK bool *is_bare_re \\\n\t\t\t\t|const U32 rx_flags|const U32 pm_flags\nAp\t|REGEXP*|re_compile\t|NN SV * const pattern|U32 orig_rx_flags\nAp\t|char*\t|re_intuit_start|NN REGEXP * const rx \\\n\t\t\t\t|NULLOK SV* sv \\\n\t\t\t\t|NN const char* const strbeg \\\n\t\t\t\t|NN char* strpos \\\n\t\t\t\t|NN char* strend \\\n\t\t\t\t|const U32 flags \\\n\t\t\t\t|NULLOK re_scream_pos_data *data\nAp\t|SV*\t|re_intuit_string|NN REGEXP  *const r\nAp\t|I32\t|regexec_flags\t|NN REGEXP *const rx|NN char *stringarg \\\n\t\t\t\t|NN char *strend|NN char *strbeg \\\n\t\t\t\t|SSize_t minend|NN SV *sv \\\n\t\t\t\t|NULLOK void *data|U32 flags\nApR\t|regnode*|regnext\t|NULLOK regnode* p\nEXp\t|SV*|reg_named_buff          |NN REGEXP * const rx|NULLOK SV * const key \\\n                                 |NULLOK SV * const value|const U32 flags\nEXp\t|SV*|reg_named_buff_iter     |NN REGEXP * const rx|NULLOK const SV * const lastkey \\\n                                 |const U32 flags\nAp\t|SV*|reg_named_buff_fetch    |NN REGEXP * const rx|NN SV * const namesv|const U32 flags\nAp\t|bool|reg_named_buff_exists  |NN REGEXP * const rx|NN SV * const key|const U32 flags\nAp\t|SV*|reg_named_buff_firstkey |NN REGEXP * const rx|const U32 flags\nAp\t|SV*|reg_named_buff_nextkey  |NN REGEXP * const rx|const U32 flags\nAp\t|SV*|reg_named_buff_scalar   |NN REGEXP * const rx|const U32 flags\nAp\t|SV*|reg_named_buff_all      |NN REGEXP * const rx|const U32 flags\n\n: FIXME - is anything in re using this now?\nEXp\t|void|reg_numbered_buff_fetch|NN REGEXP * const rx|const I32 paren|NULLOK SV * const sv\n: FIXME - is anything in re using this now?\nEXp\t|void|reg_numbered_buff_store|NN REGEXP * const rx|const I32 paren|NULLOK SV const * const value\n: FIXME - is anything in re using this now?\nEXp\t|I32|reg_numbered_buff_length|NN REGEXP * const rx|NN const SV * const sv|const I32 paren\n\n: FIXME - is anything in re using this now?\nEXp\t|SV*|reg_qr_package|NN REGEXP * const rx\n\nAnp\t|void\t|repeatcpy\t|NN char* to|NN const char* from|I32 len|IV count\nAdnpP\t|char*\t|rninstr\t|NN const char* big|NN const char* bigend \\\n\t\t\t\t|NN const char* little|NN const char* lend\nAp\t|Sighandler_t|rsignal\t|int i|Sighandler_t t\n: Used in pp_sys.c\np\t|int\t|rsignal_restore|int i|NULLOK Sigsave_t* t\n: Used in pp_sys.c\np\t|int\t|rsignal_save\t|int i|Sighandler_t t1|NN Sigsave_t* save\nAp\t|Sighandler_t|rsignal_state|int i\n#if defined(PERL_IN_PP_CTL_C)\ns\t|void\t|rxres_free\t|NN void** rsp\ns\t|void\t|rxres_restore\t|NN void **rsp|NN REGEXP *rx\n#endif\n: Used in pp_hot.c\np\t|void\t|rxres_save\t|NN void **rsp|NN REGEXP *rx\n#if !defined(HAS_RENAME)\n: Used in pp_sys.c\np\t|I32\t|same_dirent\t|NN const char* a|NN const char* b\n#endif\nApda\t|char*\t|savepv\t\t|NULLOK const char* pv\nApda\t|char*\t|savepvn\t|NULLOK const char* pv|I32 len\nApda\t|char*\t|savesharedpv\t|NULLOK const char* pv\n\n: NULLOK only to suppress a compiler warning\nApda\t|char*\t|savesharedpvn\t|NULLOK const char *const pv \\\n\t\t\t\t|const STRLEN len\nApda\t|char*\t|savesharedsvpv\t|NN SV *sv\nApda\t|char*\t|savesvpv\t|NN SV* sv\nAp\t|void\t|savestack_grow\nAp\t|void\t|savestack_grow_cnt\t|I32 need\nAmp\t|void\t|save_aelem\t|NN AV* av|SSize_t idx|NN SV **sptr\nAp\t|void\t|save_aelem_flags|NN AV* av|SSize_t idx|NN SV **sptr \\\n\t\t\t\t |const U32 flags\nAp\t|I32\t|save_alloc\t|I32 size|I32 pad\nAp\t|void\t|save_aptr\t|NN AV** aptr\nAp\t|AV*\t|save_ary\t|NN GV* gv\nAp\t|void\t|save_bool\t|NN bool* boolp\nAp\t|void\t|save_clearsv\t|NN SV** svp\nAp\t|void\t|save_delete\t|NN HV *hv|NN char *key|I32 klen\nAp\t|void\t|save_hdelete\t|NN HV *hv|NN SV *keysv\nAp\t|void\t|save_adelete\t|NN AV *av|SSize_t key\nAp\t|void\t|save_destructor|DESTRUCTORFUNC_NOCONTEXT_t f|NN void* p\nAp\t|void\t|save_destructor_x|DESTRUCTORFUNC_t f|NULLOK void* p\nApmb\t|void\t|save_freesv\t|NULLOK SV* sv\n: Used in SAVEFREOP(), used in op.c, pp_ctl.c\nApmb\t|void\t|save_freeop\t|NULLOK OP* o\nApmb\t|void\t|save_freepv\t|NULLOK char* pv\nAp\t|void\t|save_generic_svref|NN SV** sptr\nAp\t|void\t|save_generic_pvref|NN char** str\nAp\t|void\t|save_shared_pvref|NN char** str\nAdp\t|void\t|save_gp\t|NN GV* gv|I32 empty\nAp\t|HV*\t|save_hash\t|NN GV* gv\nAp\t|void\t|save_hints\nAmp\t|void\t|save_helem\t|NN HV *hv|NN SV *key|NN SV **sptr\nAp\t|void\t|save_helem_flags|NN HV *hv|NN SV *key|NN SV **sptr|const U32 flags\nAp\t|void\t|save_hptr\t|NN HV** hptr\nAp\t|void\t|save_I16\t|NN I16* intp\nAp\t|void\t|save_I32\t|NN I32* intp\nAp\t|void\t|save_I8\t|NN I8* bytep\nAp\t|void\t|save_int\t|NN int* intp\nAp\t|void\t|save_item\t|NN SV* item\nAp\t|void\t|save_iv\t|NN IV *ivp\nAbp\t|void\t|save_list\t|NN SV** sarg|I32 maxsarg\nAbp\t|void\t|save_long\t|NN long* longp\nApmb\t|void\t|save_mortalizesv|NN SV* sv\nAbp\t|void\t|save_nogv\t|NN GV* gv\n: Used in SAVEFREOP(), used in gv.c, op.c, perl.c, pp_ctl.c, pp_sort.c\nApmb\t|void\t|save_op\nAp\t|SV*\t|save_scalar\t|NN GV* gv\nAp\t|void\t|save_pptr\t|NN char** pptr\nAp\t|void\t|save_vptr\t|NN void *ptr\nAp\t|void\t|save_re_context\nAp\t|void\t|save_padsv_and_mortalize|PADOFFSET off\nAp\t|void\t|save_sptr\t|NN SV** sptr\nXp\t|void\t|save_strlen\t|NN STRLEN* ptr\nAp\t|SV*\t|save_svref\t|NN SV** sptr\nAMpo\t|void\t|savetmps\nAp\t|void\t|save_pushptr\t|NULLOK void *const ptr|const int type\nAp\t|void\t|save_pushi32ptr|const I32 i|NULLOK void *const ptr|const int type\n: Used by SAVESWITCHSTACK() in pp.c\nAp\t|void\t|save_pushptrptr|NULLOK void *const ptr1 \\\n\t\t\t\t|NULLOK void *const ptr2|const int type\n#if defined(PERL_IN_SCOPE_C)\ns\t|void\t|save_pushptri32ptr|NULLOK void *const ptr1|const I32 i \\\n\t\t\t\t|NULLOK void *const ptr2|const int type\n#endif\n: Used in perly.y\np\t|OP*\t|sawparens\t|NULLOK OP* o\nApd\t|OP*\t|op_contextualize|NN OP* o|I32 context\n: Used in perly.y\np\t|OP*\t|scalar\t\t|NULLOK OP* o\n#if defined(PERL_IN_OP_C)\ns\t|OP*\t|scalarkids\t|NULLOK OP* o\ns\t|OP*\t|scalarseq\t|NULLOK OP* o\n#endif\n: Used in pp_ctl.c\np\t|OP*\t|scalarvoid\t|NN OP* o\nApd\t|NV\t|scan_bin\t|NN const char* start|STRLEN len|NN STRLEN* retlen\nApd\t|NV\t|scan_hex\t|NN const char* start|STRLEN len|NN STRLEN* retlen\nAp\t|char*\t|scan_num\t|NN const char* s|NN YYSTYPE *lvalp\nApd\t|NV\t|scan_oct\t|NN const char* start|STRLEN len|NN STRLEN* retlen\nAMpd\t|OP*\t|op_scope\t|NULLOK OP* o\n: Only used by perl.c/miniperl.c, but defined in caretx.c\npx\t|void\t|set_caret_X\nApd\t|void\t|setdefout\t|NN GV* gv\nAp\t|HEK*\t|share_hek\t|NN const char* str|SSize_t len|U32 hash\n#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)\n: Used in perl.c\nnp\t|Signal_t |sighandler\t|int sig|NULLOK siginfo_t *info|NULLOK void *uap\nAnp\t|Signal_t |csighandler\t|int sig|NULLOK siginfo_t *info|NULLOK void *uap\n#else\nnp\t|Signal_t |sighandler\t|int sig\nAnp\t|Signal_t |csighandler\t|int sig\n#endif\nAp\t|SV**\t|stack_grow\t|NN SV** sp|NN SV** p|SSize_t n\nAp\t|I32\t|start_subparse\t|I32 is_format|U32 flags\nXp\t|void\t|init_named_cv\t|NN CV *cv|NN OP *nameop\n: Used in pp_ctl.c\np\t|void\t|sub_crush_depth|NN CV* cv\nApbmd\t|bool\t|sv_2bool\t|NN SV *const sv\nApd\t|bool\t|sv_2bool_flags\t|NN SV *sv|I32 flags\nApd\t|CV*\t|sv_2cv\t\t|NULLOK SV* sv|NN HV **const st|NN GV **const gvp \\\n\t\t\t\t|const I32 lref\nApd\t|IO*\t|sv_2io\t\t|NN SV *const sv\n#if defined(PERL_IN_SV_C)\ns\t|bool\t|glob_2number\t|NN GV* const gv\n#endif\nApmb\t|IV\t|sv_2iv\t\t|NN SV *sv\nApd\t|IV\t|sv_2iv_flags\t|NN SV *const sv|const I32 flags\nApd\t|SV*\t|sv_2mortal\t|NULLOK SV *const sv\nApd\t|NV\t|sv_2nv_flags\t|NN SV *const sv|const I32 flags\n: Used in pp.c, pp_hot.c, sv.c\npMd\t|SV*\t|sv_2num\t|NN SV *const sv\nApmb\t|char*\t|sv_2pv\t\t|NN SV *sv|NULLOK STRLEN *lp\nApd\t|char*\t|sv_2pv_flags\t|NN SV *const sv|NULLOK STRLEN *const lp|const I32 flags\nApd\t|char*\t|sv_2pvutf8\t|NN SV *sv|NULLOK STRLEN *const lp\nApd\t|char*\t|sv_2pvbyte\t|NN SV *sv|NULLOK STRLEN *const lp\nAbp\t|char*\t|sv_pvn_nomg\t|NN SV* sv|NULLOK STRLEN* lp\nApmb\t|UV\t|sv_2uv\t\t|NN SV *sv\nApd\t|UV\t|sv_2uv_flags\t|NN SV *const sv|const I32 flags\nAbpd\t|IV\t|sv_iv\t\t|NN SV* sv\nAbpd\t|UV\t|sv_uv\t\t|NN SV* sv\nAbpd\t|NV\t|sv_nv\t\t|NN SV* sv\nAbpd\t|char*\t|sv_pvn\t\t|NN SV *sv|NN STRLEN *lp\nAbpd\t|char*\t|sv_pvutf8n\t|NN SV *sv|NN STRLEN *lp\nAbpd\t|char*\t|sv_pvbyten\t|NN SV *sv|NN STRLEN *lp\nApd\t|I32\t|sv_true\t|NULLOK SV *const sv\n#if defined(PERL_IN_SV_C)\nsd\t|void\t|sv_add_arena\t|NN char *const ptr|const U32 size \\\n\t\t\t\t|const U32 flags\n#endif\nApdn\t|void\t|sv_backoff\t|NN SV *const sv\nApd\t|SV*\t|sv_bless\t|NN SV *const sv|NN HV *const stash\n#if defined(PERL_DEBUG_READONLY_COW)\np\t|void\t|sv_buf_to_ro\t|NN SV *sv\n# if defined(PERL_IN_SV_C)\ns\t|void\t|sv_buf_to_rw\t|NN SV *sv\n# endif\n#endif\nAfpd\t|void\t|sv_catpvf\t|NN SV *const sv|NN const char *const pat|...\nApd\t|void\t|sv_vcatpvf\t|NN SV *const sv|NN const char *const pat \\\n\t\t\t\t|NULLOK va_list *const args\nApd\t|void\t|sv_catpv\t|NN SV *const sv|NULLOK const char* ptr\nApmdb\t|void\t|sv_catpvn\t|NN SV *dsv|NN const char *sstr|STRLEN len\nApmdb\t|void\t|sv_catsv\t|NN SV *dstr|NULLOK SV *sstr\nApd\t|void\t|sv_chop\t|NN SV *const sv|NULLOK const char *const ptr\n: Used only in perl.c\npd\t|I32\t|sv_clean_all\n: Used only in perl.c\npd\t|void\t|sv_clean_objs\nApd\t|void\t|sv_clear\t|NN SV *const orig_sv\n#if defined(PERL_IN_SV_C)\ns\t|bool\t|curse\t\t|NN SV * const sv|const bool check_refcnt\n#endif\nAopd\t|I32\t|sv_cmp\t\t|NULLOK SV *const sv1|NULLOK SV *const sv2\nApd\t|I32\t|sv_cmp_flags\t|NULLOK SV *const sv1|NULLOK SV *const sv2 \\\n\t\t\t\t|const U32 flags\nAopd\t|I32\t|sv_cmp_locale\t|NULLOK SV *const sv1|NULLOK SV *const sv2\nApd\t|I32\t|sv_cmp_locale_flags\t|NULLOK SV *const sv1 \\\n\t\t\t\t|NULLOK SV *const sv2|const U32 flags\n#if defined(USE_LOCALE_COLLATE)\nApbmd\t|char*\t|sv_collxfrm\t|NN SV *const sv|NN STRLEN *const nxp\nApd\t|char*\t|sv_collxfrm_flags\t|NN SV *const sv|NN STRLEN *const nxp|I32 const flags\n#endif\nApd\t|int\t|getcwd_sv\t|NN SV* sv\nApd\t|void\t|sv_dec\t\t|NULLOK SV *const sv\nApd\t|void\t|sv_dec_nomg\t|NULLOK SV *const sv\nAp\t|void\t|sv_dump\t|NULLOK SV* sv\nApdR\t|bool\t|sv_derived_from|NN SV* sv|NN const char *const name\nApdR\t|bool\t|sv_derived_from_sv|NN SV* sv|NN SV *namesv|U32 flags\nApdR\t|bool\t|sv_derived_from_pv|NN SV* sv|NN const char *const name|U32 flags\nApdR\t|bool\t|sv_derived_from_pvn|NN SV* sv|NN const char *const name \\\n                                    |const STRLEN len|U32 flags\nApdR\t|bool\t|sv_does\t|NN SV* sv|NN const char *const name\nApdR\t|bool\t|sv_does_sv\t|NN SV* sv|NN SV* namesv|U32 flags\nApdR\t|bool\t|sv_does_pv\t|NN SV* sv|NN const char *const name|U32 flags\nApdR\t|bool\t|sv_does_pvn\t|NN SV* sv|NN const char *const name|const STRLEN len \\\n                                |U32 flags\nApbmd\t|I32\t|sv_eq\t\t|NULLOK SV* sv1|NULLOK SV* sv2\nApd\t|I32\t|sv_eq_flags\t|NULLOK SV* sv1|NULLOK SV* sv2|const U32 flags\nApd\t|void\t|sv_free\t|NULLOK SV *const sv\npoMX\t|void\t|sv_free2\t|NN SV *const sv|const U32 refcnt\n: Used only in perl.c\npd\t|void\t|sv_free_arenas\nApd\t|char*\t|sv_gets\t|NN SV *const sv|NN PerlIO *const fp|I32 append\nApd\t|char*\t|sv_grow\t|NN SV *const sv|STRLEN newlen\nApd\t|void\t|sv_inc\t\t|NULLOK SV *const sv\nApd\t|void\t|sv_inc_nomg\t|NULLOK SV *const sv\nApmdb\t|void\t|sv_insert\t|NN SV *const bigstr|const STRLEN offset \\\n\t\t\t\t|const STRLEN len|NN const char *const little \\\n\t\t\t\t|const STRLEN littlelen\nApd\t|void\t|sv_insert_flags|NN SV *const bigstr|const STRLEN offset|const STRLEN len \\\n\t\t\t\t|NN const char *little|const STRLEN littlelen|const U32 flags\nApd\t|int\t|sv_isa\t\t|NULLOK SV* sv|NN const char *const name\nApd\t|int\t|sv_isobject\t|NULLOK SV* sv\nApd\t|STRLEN\t|sv_len\t\t|NULLOK SV *const sv\nApd\t|STRLEN\t|sv_len_utf8\t|NULLOK SV *const sv\np\t|STRLEN\t|sv_len_utf8_nomg|NN SV *const sv\nApd\t|void\t|sv_magic\t|NN SV *const sv|NULLOK SV *const obj|const int how \\\n\t\t\t\t|NULLOK const char *const name|const I32 namlen\nApd\t|MAGIC *|sv_magicext\t|NN SV *const sv|NULLOK SV *const obj|const int how \\\n\t\t\t\t|NULLOK const MGVTBL *const vtbl|NULLOK const char *const name \\\n\t\t\t\t|const I32 namlen\nEin\t|bool\t|sv_only_taint_gmagic|NN SV *sv\n: exported for re.pm\nEXp\t|MAGIC *|sv_magicext_mglob|NN SV *sv\nApdbmR\t|SV*\t|sv_mortalcopy\t|NULLOK SV *const oldsv\nXpR\t|SV*\t|sv_mortalcopy_flags|NULLOK SV *const oldsv|U32 flags\nApdR\t|SV*\t|sv_newmortal\nApd\t|SV*\t|sv_newref\t|NULLOK SV *const sv\nAp\t|char*\t|sv_peek\t|NULLOK SV* sv\nApd\t|void\t|sv_pos_u2b\t|NULLOK SV *const sv|NN I32 *const offsetp|NULLOK I32 *const lenp\nApd\t|STRLEN\t|sv_pos_u2b_flags|NN SV *const sv|STRLEN uoffset \\\n\t\t\t\t|NULLOK STRLEN *const lenp|U32 flags\nApd\t|void\t|sv_pos_b2u\t|NULLOK SV *const sv|NN I32 *const offsetp\nApd\t|STRLEN\t|sv_pos_b2u_flags|NN SV *const sv|STRLEN const offset \\\n\t\t\t\t |U32 flags\nApmdb\t|char*\t|sv_pvn_force\t|NN SV* sv|NULLOK STRLEN* lp\nApd\t|char*\t|sv_pvutf8n_force|NN SV *const sv|NULLOK STRLEN *const lp\nApd\t|char*\t|sv_pvbyten_force|NN SV *const sv|NULLOK STRLEN *const lp\nApd\t|char*\t|sv_recode_to_utf8\t|NN SV* sv|NN SV *encoding\nApd\t|bool\t|sv_cat_decode\t|NN SV* dsv|NN SV *encoding|NN SV *ssv|NN int *offset \\\n\t\t\t\t|NN char* tstr|int tlen\nApdR\t|const char*\t|sv_reftype\t|NN const SV *const sv|const int ob\nApd\t|SV*\t|sv_ref\t|NULLOK SV *dst|NN const SV *const sv|const int ob\nApd\t|void\t|sv_replace\t|NN SV *const sv|NN SV *const nsv\nApd\t|void\t|sv_report_used\nApd\t|void\t|sv_reset\t|NN const char* s|NULLOK HV *const stash\np\t|void\t|sv_resetpvn\t|NULLOK const char* s|STRLEN len \\\n\t\t\t\t|NULLOK HV *const stash\nAfpd\t|void\t|sv_setpvf\t|NN SV *const sv|NN const char *const pat|...\nApd\t|void\t|sv_vsetpvf\t|NN SV *const sv|NN const char *const pat|NULLOK va_list *const args\nApd\t|void\t|sv_setiv\t|NN SV *const sv|const IV num\nApdb\t|void\t|sv_setpviv\t|NN SV *const sv|const IV num\nApd\t|void\t|sv_setuv\t|NN SV *const sv|const UV num\nApd\t|void\t|sv_setnv\t|NN SV *const sv|const NV num\nApd\t|SV*\t|sv_setref_iv\t|NN SV *const rv|NULLOK const char *const classname|const IV iv\nApd\t|SV*\t|sv_setref_uv\t|NN SV *const rv|NULLOK const char *const classname|const UV uv\nApd\t|SV*\t|sv_setref_nv\t|NN SV *const rv|NULLOK const char *const classname|const NV nv\nApd\t|SV*\t|sv_setref_pv\t|NN SV *const rv|NULLOK const char *const classname \\\n\t\t\t\t|NULLOK void *const pv\nApd\t|SV*\t|sv_setref_pvn\t|NN SV *const rv|NULLOK const char *const classname \\\n\t\t\t\t|NN const char *const pv|const STRLEN n\nApd\t|void\t|sv_setpv\t|NN SV *const sv|NULLOK const char *const ptr\nApd\t|void\t|sv_setpvn\t|NN SV *const sv|NULLOK const char *const ptr|const STRLEN len\nApd\t|char  *|sv_setpv_bufsize|NN SV *const sv|const STRLEN cur|const STRLEN len\nXp\t|void\t|sv_sethek\t|NN SV *const sv|NULLOK const HEK *const hek\nApmdb\t|void\t|sv_setsv\t|NN SV *dstr|NULLOK SV *sstr\nApmdb\t|void\t|sv_taint\t|NN SV* sv\nApdR\t|bool\t|sv_tainted\t|NN SV *const sv\nApd\t|int\t|sv_unmagic\t|NN SV *const sv|const int type\nApd\t|int\t|sv_unmagicext\t|NN SV *const sv|const int type|NULLOK MGVTBL *vtbl\nApdmb\t|void\t|sv_unref\t|NN SV* sv\nApd\t|void\t|sv_unref_flags\t|NN SV *const ref|const U32 flags\nApd\t|void\t|sv_untaint\t|NN SV *const sv\nApd\t|void\t|sv_upgrade\t|NN SV *const sv|svtype new_type\nApdmb\t|void\t|sv_usepvn\t|NN SV* sv|NULLOK char* ptr|STRLEN len\nApd\t|void\t|sv_usepvn_flags|NN SV *const sv|NULLOK char* ptr|const STRLEN len\\\n\t\t\t\t|const U32 flags\nApd\t|void\t|sv_vcatpvfn\t|NN SV *const sv|NN const char *const pat|const STRLEN patlen \\\n\t\t\t\t|NULLOK va_list *const args|NULLOK SV **const svargs|const Size_t sv_count \\\n\t\t\t\t|NULLOK bool *const maybe_tainted\nApd\t|void\t|sv_vcatpvfn_flags|NN SV *const sv|NN const char *const pat|const STRLEN patlen \\\n\t\t\t\t|NULLOK va_list *const args|NULLOK SV **const svargs|const Size_t sv_count \\\n\t\t\t\t|NULLOK bool *const maybe_tainted|const U32 flags\nApd\t|void\t|sv_vsetpvfn\t|NN SV *const sv|NN const char *const pat|const STRLEN patlen \\\n\t\t\t\t|NULLOK va_list *const args|NULLOK SV **const svargs \\\n\t\t\t\t|const Size_t sv_count|NULLOK bool *const maybe_tainted\nApR\t|NV\t|str_to_version\t|NN SV *sv\nEXpRM\t|SV*\t|swash_init\t|NN const char* pkg|NN const char* name|NN SV* listsv|I32 minbits|I32 none\nEXpM\t|UV\t|swash_fetch\t|NN SV *swash|NN const U8 *ptr|bool do_utf8\n#ifdef PERL_IN_REGCOMP_C\nEiMR\t|SV*\t|add_cp_to_invlist\t|NULLOK SV* invlist|const UV cp\nEiMRn\t|bool\t|invlist_is_iterating|NN SV* const invlist\n#ifndef PERL_EXT_RE_BUILD\nEiMRn\t|UV*\t|_invlist_array_init\t|NN SV* const invlist|const bool will_have_0\nEiMRn\t|UV\t|invlist_max\t|NN SV* const invlist\nEsM\t|void\t|_append_range_to_invlist   |NN SV* const invlist|const UV start|const UV end\nEsM\t|void\t|invlist_extend    |NN SV* const invlist|const UV len\nEsM\t|void\t|invlist_replace_list_destroys_src|NN SV *dest|NN SV *src\nEiMRn\t|IV*\t|get_invlist_previous_index_addr|NN SV* invlist\nEiM\t|void\t|invlist_set_len|NN SV* const invlist|const UV len|const bool offset\nEiMn\t|void\t|invlist_set_previous_index|NN SV* const invlist|const IV index\nEiMRn\t|IV\t|invlist_previous_index|NN SV* const invlist\nEiMn\t|void\t|invlist_trim\t|NN SV* invlist\nEiM\t|void\t|invlist_clear\t|NN SV* invlist\nsM\t|void\t|initialize_invlist_guts|NN SV* invlist|const Size_t initial_size\n#endif\nEiMRn\t|STRLEN*|get_invlist_iter_addr\t|NN SV* invlist\nEiMn\t|void\t|invlist_iterinit|NN SV* invlist\nEsMRn\t|bool\t|invlist_iternext|NN SV* invlist|NN UV* start|NN UV* end\nEiMn\t|void\t|invlist_iterfinish|NN SV* invlist\nEiMRn\t|UV\t|invlist_highest|NN SV* const invlist\nEMRs\t|SV*\t|_make_exactf_invlist\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t\t|NN regnode *node\nEsMR\t|SV*\t|invlist_contents|NN SV* const invlist\t\t    \\\n\t\t\t\t |const bool traditional_style\nEsRn\t|bool\t|new_regcurly\t|NN const char *s|NN const char *e\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_UTF8_C)\nEXmM\t|void\t|_invlist_intersection\t|NN SV* const a|NN SV* const b|NN SV** i\nEXpM\t|void\t|_invlist_intersection_maybe_complement_2nd \\\n\t\t|NULLOK SV* const a|NN SV* const b          \\\n\t\t|const bool complement_b|NN SV** i\nEXmM\t|void\t|_invlist_union\t|NULLOK SV* const a|NN SV* const b|NN SV** output\nEXpM\t|void\t|_invlist_union_maybe_complement_2nd        \\\n\t\t|NULLOK SV* const a|NN SV* const b          \\\n\t\t|const bool complement_b|NN SV** output\nEXmM\t|void\t|_invlist_subtract|NN SV* const a|NN SV* const b|NN SV** result\nEXpM\t|void\t|_invlist_invert|NN SV* const invlist\nEXMpR\t|SV*\t|_new_invlist\t|IV initial_size\nEXMpR\t|SV*\t|_add_range_to_invlist\t|NULLOK SV* invlist|UV start|UV end\nEXMpR\t|SV*\t|_setup_canned_invlist|const STRLEN size|const UV element0|NN UV** other_elements_ptr\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_SV_C)\nEMpX\t|SV*\t|invlist_clone\t|NN SV* const invlist|NULLOK SV* newlist\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_TOKE_C) || defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)\nEiMRn\t|UV*\t|invlist_array\t|NN SV* const invlist\nEiMRn\t|bool\t|is_invlist\t|NULLOK SV* const invlist\nEiMRn\t|bool*\t|get_invlist_offset_addr|NN SV* invlist\nEiMRn\t|UV\t|_invlist_len\t|NN SV* const invlist\nEMiRn\t|bool\t|_invlist_contains_cp|NN SV* const invlist|const UV cp\nEXpMRn\t|SSize_t|_invlist_search\t|NN SV* const invlist|const UV cp\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)\nEXpM\t|SV*\t|_get_regclass_nonbitmap_data\t\t\t\t   \\\n\t\t\t\t|NULLOK const regexp *prog\t\t   \\\n\t\t\t\t|NN const struct regnode *node\t\t   \\\n\t\t\t\t|bool doinit\t\t\t\t   \\\n\t\t\t\t|NULLOK SV **listsvp\t\t\t   \\\n\t\t\t\t|NULLOK SV **lonly_utf8_locale\t\t   \\\n\t\t\t\t|NULLOK SV **output_invlist\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined (PERL_IN_DUMP_C)\nEXMp\t|void\t|_invlist_dump\t|NN PerlIO *file|I32 level   \\\n\t\t\t\t|NN const char* const indent \\\n\t\t\t\t|NN SV* const invlist\n#endif\nAp\t|void\t|taint_env\nAp\t|void\t|taint_proper\t|NULLOK const char* f|NN const char *const s\nEpM\t|char *\t|_byte_dump_string\t\t\t\t\t\\\n\t\t\t\t|NN const U8 * const start\t\t\\\n\t\t\t\t|const STRLEN len\t\t\t\\\n\t\t\t\t|const bool format\n#if defined(PERL_IN_UTF8_C)\ninR\t|int\t|does_utf8_overflow|NN const U8 * const s\t\t\\\n\t\t\t\t   |NN const U8 * e\t\t\t\\\n\t\t\t\t   |const bool consider_overlongs\ninR\t|int\t|is_utf8_overlong_given_start_byte_ok|NN const U8 * const s \\\n\t\t\t\t\t\t     |const STRLEN len\ninR\t|int\t|isFF_OVERLONG\t|NN const U8 * const s|const STRLEN len\nsMR\t|char *\t|unexpected_non_continuation_text\t\t\t\\\n\t\t|NN const U8 * const s\t\t\t\t\t\\\n\t\t|STRLEN print_len\t\t\t\t\t\\\n\t\t|const STRLEN non_cont_byte_pos\t\t\t\t\\\n\t\t|const STRLEN expect_len\ns\t|void\t|warn_on_first_deprecated_use\t\t\t\t    \\\n\t\t\t\t|NN const char * const name\t\t    \\\n\t\t\t\t|NN const char * const alternative\t    \\\n\t\t\t\t|const bool use_locale\t\t\t    \\\n\t\t\t\t|NN const char * const file\t\t    \\\n\t\t\t\t|const unsigned line\ns\t|U32\t|check_and_deprecate\t\t\t\t\t    \\\n\t\t\t\t|NN const U8 * p\t\t\t    \\\n\t\t\t\t|NN const U8 ** e\t\t\t    \\\n\t\t\t\t|const unsigned type\t\t\t    \\\n\t\t\t\t|const bool use_locale\t\t\t    \\\n\t\t\t\t|NN const char * const file\t\t    \\\n\t\t\t\t|const unsigned line\ns\t|UV\t|_to_utf8_case  |const UV uv1\t\t\t\t\t\\\n\t\t\t\t|NULLOK const U8 *p\t\t\t\t\\\n\t\t\t\t|NN U8* ustrp\t\t\t\t\t\\\n\t\t\t\t|NN STRLEN *lenp\t\t\t\t\\\n\t\t\t\t|NN SV *invlist\t\t\t\t\t\\\n\t\t\t\t|NN const int * const invmap\t\t\t\\\n\t\t\t\t|NULLOK const unsigned int * const * const aux_tables\t\\\n\t\t\t\t|NULLOK const U8 * const aux_table_lengths\t\\\n\t\t\t\t|NN const char * const normal\ns\t|UV\t|turkic_fc\t|NN const U8 * const p |NN const U8 * const e|NN U8* ustrp|NN STRLEN *lenp\ns\t|UV\t|turkic_lc\t|NN const U8 * const p0|NN const U8 * const e|NN U8* ustrp|NN STRLEN *lenp\ns\t|UV\t|turkic_uc\t|NN const U8 * const p |NN const U8 * const e|NN U8* ustrp|NN STRLEN *lenp\n#endif\nApbmdD\t|UV\t|to_utf8_lower\t|NN const U8 *p|NN U8* ustrp|NULLOK STRLEN *lenp\nAMp\t|UV\t|_to_utf8_lower_flags|NN const U8 *p|NULLOK const U8* e\t\t\\\n\t\t\t\t|NN U8* ustrp|NULLOK STRLEN *lenp|bool flags\t\\\n\t\t\t\t|NN const char * const file|const int line\nApbmdD\t|UV\t|to_utf8_upper\t|NN const U8 *p|NN U8* ustrp|NULLOK STRLEN *lenp\nAMp\t|UV\t|_to_utf8_upper_flags\t|NN const U8 *p|NULLOK const U8 *e\t\\\n\t\t\t\t|NN U8* ustrp|NULLOK STRLEN *lenp|bool flags\t\\\n\t\t\t\t|NN const char * const file|const int line\nApbmdD\t|UV\t|to_utf8_title\t|NN const U8 *p|NN U8* ustrp|NULLOK STRLEN *lenp\nAMp\t|UV\t|_to_utf8_title_flags\t|NN const U8 *p|NULLOK const U8* e\t\\\n\t\t\t\t|NN U8* ustrp|NULLOK STRLEN *lenp|bool flags\t\\\n\t\t\t\t|NN const char * const file|const int line\nApbmdD\t|UV\t|to_utf8_fold\t|NN const U8 *p|NN U8* ustrp|NULLOK STRLEN *lenp\nAMp\t|UV\t|_to_utf8_fold_flags|NN const U8 *p|NULLOK const U8 *e\t\t\\\n\t\t\t\t|NN U8* ustrp|NULLOK STRLEN *lenp|U8 flags  \\\n\t\t\t\t|NN const char * const file|const int line\n#if defined(PERL_IN_MG_C) || defined(PERL_IN_PP_C)\npn\t|bool\t|translate_substr_offsets|STRLEN curlen|IV pos1_iv \\\n\t\t\t\t\t |bool pos1_is_uv|IV len_iv \\\n\t\t\t\t\t |bool len_is_uv|NN STRLEN *posp \\\n\t\t\t\t\t |NN STRLEN *lenp\n#endif\n#if defined(UNLINK_ALL_VERSIONS)\nAp\t|I32\t|unlnk\t\t|NN const char* f\n#endif\nAbpd\t|SSize_t|unpack_str\t|NN const char *pat|NN const char *patend|NN const char *s \\\n\t\t\t\t|NULLOK const char *strbeg|NN const char *strend|NULLOK char **new_s \\\n\t\t\t\t|I32 ocnt|U32 flags\nApd\t|SSize_t|unpackstring\t|NN const char *pat|NN const char *patend|NN const char *s \\\n\t\t\t\t|NN const char *strend|U32 flags\nAp\t|void\t|unsharepvn\t|NULLOK const char* sv|I32 len|U32 hash\n: Used in gv.c, hv.c\np\t|void\t|unshare_hek\t|NULLOK HEK* hek\n: Used in perly.y\np\t|void\t|utilize\t|int aver|I32 floor|NULLOK OP* version|NN OP* idop|NULLOK OP* arg\nApM\t|void\t|_force_out_malformed_utf8_message\t\t\t    \\\n\t\t|NN const U8 *const p|NN const U8 * const e|const U32 flags \\\n\t\t|const bool die_here\nEXp\t|U8*\t|utf16_to_utf8\t|NN U8* p|NN U8 *d|I32 bytelen|NN I32 *newlen\nEXp\t|U8*\t|utf16_to_utf8_reversed|NN U8* p|NN U8 *d|I32 bytelen|NN I32 *newlen\nAdpR\t|STRLEN\t|utf8_length\t|NN const U8* s|NN const U8 *e\nAipdR\t|IV\t|utf8_distance\t|NN const U8 *a|NN const U8 *b\nAipdRn\t|U8*\t|utf8_hop\t|NN const U8 *s|SSize_t off\nAipdRn\t|U8*\t|utf8_hop_back|NN const U8 *s|SSize_t off|NN const U8 *start\nAipdRn\t|U8*\t|utf8_hop_forward|NN const U8 *s|SSize_t off|NN const U8 *end\nAipdRn\t|U8*\t|utf8_hop_safe\t|NN const U8 *s|SSize_t off|NN const U8 *start|NN const U8 *end\nApMd\t|U8*\t|utf8_to_bytes\t|NN U8 *s|NN STRLEN *lenp\nApd\t|int\t|bytes_cmp_utf8\t|NN const U8 *b|STRLEN blen|NN const U8 *u \\\n\t\t\t\t|STRLEN ulen\nAModp\t|U8*\t|bytes_from_utf8|NN const U8 *s|NN STRLEN *lenp|NN bool *is_utf8p\nAMnp\t|U8*\t|bytes_from_utf8_loc|NN const U8 *s\t\t\t    \\\n\t\t\t\t    |NN STRLEN *lenp\t\t\t    \\\n\t\t\t\t    |NN bool *is_utf8p\t\t\t    \\\n\t\t\t\t    |NULLOK const U8 ** first_unconverted\nApMd\t|U8*\t|bytes_to_utf8\t|NN const U8 *s|NN STRLEN *lenp\nApdD\t|UV\t|utf8_to_uvchr\t|NN const U8 *s|NULLOK STRLEN *retlen\nAbpdD\t|UV\t|utf8_to_uvuni\t|NN const U8 *s|NULLOK STRLEN *retlen\nAbpMD\t|UV\t|valid_utf8_to_uvuni\t|NN const U8 *s|NULLOK STRLEN *retlen\nAopd\t|UV\t|utf8_to_uvchr_buf\t|NN const U8 *s|NN const U8 *send|NULLOK STRLEN *retlen\nApdD\t|UV\t|utf8_to_uvuni_buf\t|NN const U8 *s|NN const U8 *send|NULLOK STRLEN *retlen\npM\t|bool\t|check_utf8_print\t|NN const U8 *s|const STRLEN len\n\nAdnop\t|UV\t|utf8n_to_uvchr\t|NN const U8 *s\t\t\t\t    \\\n\t\t\t\t|STRLEN curlen\t\t\t\t    \\\n\t\t\t\t|NULLOK STRLEN *retlen\t\t\t    \\\n\t\t\t\t|const U32 flags\nAdnop\t|UV\t|utf8n_to_uvchr_error|NN const U8 *s\t\t\t    \\\n\t\t\t\t|STRLEN curlen\t\t\t\t    \\\n\t\t\t\t|NULLOK STRLEN *retlen\t\t\t    \\\n\t\t\t\t|const U32 flags\t\t\t    \\\n\t\t\t\t|NULLOK U32 * errors\nAMndi\t|UV\t|utf8n_to_uvchr_msgs|NN const U8 *s\t\t\t    \\\n\t\t\t\t|STRLEN curlen\t\t\t\t    \\\n\t\t\t\t|NULLOK STRLEN *retlen\t\t\t    \\\n\t\t\t\t|const U32 flags\t\t\t    \\\n\t\t\t\t|NULLOK U32 * errors\t\t\t    \\\n\t\t\t\t|NULLOK AV ** msgs\nAMnp\t|UV\t|_utf8n_to_uvchr_msgs_helper\t\t\t\t    \\\n\t\t\t\t|NN const U8 *s\t\t\t\t    \\\n\t\t\t\t|STRLEN curlen\t\t\t\t    \\\n\t\t\t\t|NULLOK STRLEN *retlen\t\t\t    \\\n\t\t\t\t|const U32 flags\t\t\t    \\\n\t\t\t\t|NULLOK U32 * errors\t\t\t    \\\n\t\t\t\t|NULLOK AV ** msgs\nAipnR\t|UV\t|valid_utf8_to_uvchr\t|NN const U8 *s|NULLOK STRLEN *retlen\nAp\t|UV\t|utf8n_to_uvuni|NN const U8 *s|STRLEN curlen|NULLOK STRLEN *retlen|U32 flags\n\nAdm\t|U8*\t|uvchr_to_utf8\t|NN U8 *d|UV uv\nAp\t|U8*\t|uvuni_to_utf8\t|NN U8 *d|UV uv\nAdm\t|U8*\t|uvchr_to_utf8_flags\t|NN U8 *d|UV uv|UV flags\nAdmM\t|U8*\t|uvchr_to_utf8_flags_msgs|NN U8 *d|UV uv|UV flags|NULLOK HV ** msgs\nApod\t|U8*\t|uvoffuni_to_utf8_flags\t|NN U8 *d|UV uv|const UV flags\nApM\t|U8*\t|uvoffuni_to_utf8_flags_msgs|NN U8 *d|UV uv|const UV flags|NULLOK HV** msgs\nAp\t|U8*\t|uvuni_to_utf8_flags\t|NN U8 *d|UV uv|UV flags\nApd\t|char*\t|pv_uni_display\t|NN SV *dsv|NN const U8 *spv|STRLEN len|STRLEN pvlim|UV flags\nApdR\t|char*\t|sv_uni_display\t|NN SV *dsv|NN SV *ssv|STRLEN pvlim|UV flags\nEXpR\t|Size_t\t|_inverse_folds\t|const UV cp\t\t\t\t    \\\n\t\t\t\t|NN unsigned int * first_folds_to\t    \\\n\t\t\t\t|NN const unsigned int ** remaining_folds_to\n: Used by Data::Alias\nEXp\t|void\t|vivify_defelem\t|NN SV* sv\n: Used in pp.c\npR\t|SV*\t|vivify_ref\t|NN SV* sv|U32 to_what\n: Used in pp_sys.c\np\t|I32\t|wait4pid\t|Pid_t pid|NN int* statusp|int flags\n: Used in locale.c and perl.c\np\t|U32\t|parse_unicode_opts|NN const char **popt\nAp\t|U32\t|seed\nXpno\t|double\t|drand48_r\t|NN perl_drand48_t *random_state\nXpno\t|void\t|drand48_init_r |NN perl_drand48_t *random_state|U32 seed\n: Only used in perl.c\np\t|void\t|get_hash_seed        |NN unsigned char * const seed_buffer\n: Used in doio.c, pp_hot.c, pp_sys.c\np\t|void\t|report_evil_fh\t|NULLOK const GV *gv\n: Used in doio.c, pp_hot.c, pp_sys.c\np\t|void\t|report_wrongway_fh|NULLOK const GV *gv|const char have\n: Used in mg.c, pp.c, pp_hot.c, regcomp.c\nXEpd\t|void\t|report_uninit\t|NULLOK const SV *uninit_sv\n#if defined(PERL_IN_OP_C) || defined(PERL_IN_SV_C)\np\t|void\t|report_redefined_cv|NN const SV *name \\\n\t\t\t\t    |NN const CV *old_cv \\\n\t\t\t\t    |NULLOK SV * const *new_const_svp\n#endif\nApd\t|void\t|warn_sv\t|NN SV *baseex\nAfpd\t|void\t|warn\t\t|NN const char* pat|...\nApd\t|void\t|vwarn\t\t|NN const char* pat|NULLOK va_list* args\nAfp\t|void\t|warner\t\t|U32 err|NN const char* pat|...\nAfp\t|void\t|ck_warner\t|U32 err|NN const char* pat|...\nAfp\t|void\t|ck_warner_d\t|U32 err|NN const char* pat|...\nAp\t|void\t|vwarner\t|U32 err|NN const char* pat|NULLOK va_list* args\n#ifdef USE_C_BACKTRACE\npd\t|Perl_c_backtrace*|get_c_backtrace|int max_depth|int skip\ndm\t|void\t|free_c_backtrace|NN Perl_c_backtrace* bt\nApd\t|SV*\t|get_c_backtrace_dump|int max_depth|int skip\nApd\t|bool\t|dump_c_backtrace|NN PerlIO* fp|int max_depth|int skip\n#endif\n: FIXME\np\t|void\t|watch\t\t|NN char** addr\nAm\t|I32\t|whichsig\t|NN const char* sig\nAp\t|I32    |whichsig_sv    |NN SV* sigsv\nAp\t|I32    |whichsig_pv    |NN const char* sig\nAp\t|I32    |whichsig_pvn   |NN const char* sig|STRLEN len\n: used to check for NULs in pathnames and other names\nAiR\t|bool\t|is_safe_syscall|NN const char *pv|STRLEN len|NN const char *what|NN const char *op_name\n#ifdef PERL_CORE\ninR\t|bool\t|should_warn_nl|NN const char *pv\n#endif\n: Used in pp_ctl.c\np\t|void\t|write_to_stderr|NN SV* msv\n: Used in op.c\np\t|int\t|yyerror\t|NN const char *const s\np\t|void\t|yyquit\npr\t|void\t|abort_execution|NN const char * const msg|NN const char * const name\np\t|int\t|yyerror_pv\t|NN const char *const s|U32 flags\np\t|int\t|yyerror_pvn\t|NULLOK const char *const s|STRLEN len|U32 flags\n: Used in perly.y, and by Data::Alias\nEXp\t|int\t|yylex\np\t|void\t|yyunlex\n: Used in perl.c, pp_ctl.c\np\t|int\t|yyparse\t|int gramtype\n: Only used in scope.c\np\t|void\t|parser_free\t|NN const yy_parser *parser\n#ifdef PERL_CORE\np\t|void\t|parser_free_nexttoke_ops|NN yy_parser *parser \\\n\t\t\t\t\t |NN OPSLAB *slab\n#endif\n#if defined(PERL_IN_TOKE_C)\ns\t|int\t|yywarn\t\t|NN const char *const s|U32 flags\n#endif\n#if defined(MYMALLOC)\nAp\t|void\t|dump_mstats\t|NN const char* s\nAp\t|int\t|get_mstats\t|NN perl_mstats_t *buf|int buflen|int level\n#endif\nAnpa\t|Malloc_t|safesysmalloc\t|MEM_SIZE nbytes\nAnpa\t|Malloc_t|safesyscalloc\t|MEM_SIZE elements|MEM_SIZE size\nAnpR\t|Malloc_t|safesysrealloc|Malloc_t where|MEM_SIZE nbytes\nAnp\t|Free_t\t|safesysfree\t|Malloc_t where\nAsrnx\t|void\t|croak_memory_wrap\n#if defined(PERL_GLOBAL_STRUCT)\nAp\t|struct perl_vars *|GetVars\nAp\t|struct perl_vars*|init_global_struct\nAp\t|void\t|free_global_struct|NN struct perl_vars *plvarsp\n#endif\nAp\t|int\t|runops_standard\nAp\t|int\t|runops_debug\nAfpd\t|void\t|sv_catpvf_mg\t|NN SV *const sv|NN const char *const pat|...\nApd\t|void\t|sv_vcatpvf_mg\t|NN SV *const sv|NN const char *const pat \\\n\t\t\t\t|NULLOK va_list *const args\nApd\t|void\t|sv_catpv_mg\t|NN SV *const sv|NULLOK const char *const ptr\nApdbm\t|void\t|sv_catpvn_mg\t|NN SV *sv|NN const char *ptr|STRLEN len\nApdbm\t|void\t|sv_catsv_mg\t|NN SV *dsv|NULLOK SV *ssv\nAfpd\t|void\t|sv_setpvf_mg\t|NN SV *const sv|NN const char *const pat|...\nApd\t|void\t|sv_vsetpvf_mg\t|NN SV *const sv|NN const char *const pat \\\n\t\t\t\t|NULLOK va_list *const args\nApd\t|void\t|sv_setiv_mg\t|NN SV *const sv|const IV i\nApdb\t|void\t|sv_setpviv_mg\t|NN SV *const sv|const IV iv\nApd\t|void\t|sv_setuv_mg\t|NN SV *const sv|const UV u\nApd\t|void\t|sv_setnv_mg\t|NN SV *const sv|const NV num\nApd\t|void\t|sv_setpv_mg\t|NN SV *const sv|NULLOK const char *const ptr\nApd\t|void\t|sv_setpvn_mg\t|NN SV *const sv|NN const char *const ptr|const STRLEN len\nApd\t|void\t|sv_setsv_mg\t|NN SV *const dstr|NULLOK SV *const sstr\nApdbm\t|void\t|sv_usepvn_mg\t|NN SV *sv|NULLOK char *ptr|STRLEN len\nApR\t|MGVTBL*|get_vtbl\t|int vtbl_id\nApd\t|char*\t|pv_display\t|NN SV *dsv|NN const char *pv|STRLEN cur|STRLEN len \\\n\t\t\t\t|STRLEN pvlim\nApd\t|char*\t|pv_escape\t|NULLOK SV *dsv|NN char const * const str\\\n                                |const STRLEN count|const STRLEN max\\\n                                |NULLOK STRLEN * const escaped\\\n                                |const U32 flags\t\t\t\t\nApd\t|char*  |pv_pretty      |NN SV *dsv|NN char const * const str\\\n                                |const STRLEN count|const STRLEN max\\\n                                |NULLOK char const * const start_color\\\n                                |NULLOK char const * const end_color\\\n                                |const U32 flags\t\t\t\t\nAfp\t|void\t|dump_indent\t|I32 level|NN PerlIO *file|NN const char* pat|...\nAp\t|void\t|dump_vindent\t|I32 level|NN PerlIO *file|NN const char* pat \\\n\t\t\t\t|NULLOK va_list *args\nAp\t|void\t|do_gv_dump\t|I32 level|NN PerlIO *file|NN const char *name\\\n\t\t\t\t|NULLOK GV *sv\nAp\t|void\t|do_gvgv_dump\t|I32 level|NN PerlIO *file|NN const char *name\\\n\t\t\t\t|NULLOK GV *sv\nAp\t|void\t|do_hv_dump\t|I32 level|NN PerlIO *file|NN const char *name\\\n\t\t\t\t|NULLOK HV *sv\nAp\t|void\t|do_magic_dump\t|I32 level|NN PerlIO *file|NULLOK const MAGIC *mg|I32 nest \\\n\t\t\t\t|I32 maxnest|bool dumpops|STRLEN pvlim\nAp\t|void\t|do_op_dump\t|I32 level|NN PerlIO *file|NULLOK const OP *o\nAp\t|void\t|do_pmop_dump\t|I32 level|NN PerlIO *file|NULLOK const PMOP *pm\nAp\t|void\t|do_sv_dump\t|I32 level|NN PerlIO *file|NULLOK SV *sv|I32 nest \\\n\t\t\t\t|I32 maxnest|bool dumpops|STRLEN pvlim\nAp\t|void\t|magic_dump\t|NULLOK const MAGIC *mg\nAp\t|void\t|reginitcolors\nApdRmb\t|char*\t|sv_2pv_nolen\t|NN SV* sv\nApdRmb\t|char*\t|sv_2pvutf8_nolen|NN SV* sv\nApdRmb\t|char*\t|sv_2pvbyte_nolen|NN SV* sv\nApmdbR\t|char*\t|sv_pv\t\t|NN SV *sv\nApmdbR\t|char*\t|sv_pvutf8\t|NN SV *sv\nApmdbR\t|char*\t|sv_pvbyte\t|NN SV *sv\nApmdb\t|STRLEN\t|sv_utf8_upgrade|NN SV *sv\nAmd\t|STRLEN\t|sv_utf8_upgrade_nomg|NN SV *sv\nApd\t|bool\t|sv_utf8_downgrade|NN SV *const sv|const bool fail_ok\nApd\t|void\t|sv_utf8_encode |NN SV *const sv\nApd\t|bool\t|sv_utf8_decode |NN SV *const sv\nApdmb\t|void\t|sv_force_normal|NN SV *sv\nApd\t|void\t|sv_force_normal_flags|NN SV *const sv|const U32 flags\npX\t|SSize_t|tmps_grow_p\t|SSize_t ix\nApd\t|SV*\t|sv_rvweaken\t|NN SV *const sv\nApd\t|SV*\t|sv_rvunweaken\t|NN SV *const sv\nAnpMd\t|SV*\t|sv_get_backrefs|NN SV *const sv\n: This is indirectly referenced by globals.c. This is somewhat annoying.\np\t|int\t|magic_killbackrefs|NN SV *sv|NN MAGIC *mg\nAp\t|OP*\t|newANONATTRSUB\t|I32 floor|NULLOK OP *proto|NULLOK OP *attrs|NULLOK OP *block\nAm\t|CV*\t|newATTRSUB\t|I32 floor|NULLOK OP *o|NULLOK OP *proto|NULLOK OP *attrs|NULLOK OP *block\npdX\t|CV*\t|newATTRSUB_x\t|I32 floor|NULLOK OP *o|NULLOK OP *proto \\\n\t\t\t\t |NULLOK OP *attrs|NULLOK OP *block \\\n\t\t\t\t |bool o_is_gv\nAp\t|CV *\t|newMYSUB\t|I32 floor|NN OP *o|NULLOK OP *proto \\\n\t\t\t\t|NULLOK OP *attrs|NULLOK OP *block\np\t|CV*\t|newSTUB\t|NN GV *gv|bool fake\n: Used in perly.y\np\t|OP *\t|my_attrs\t|NN OP *o|NULLOK OP *attrs\n#if defined(USE_ITHREADS)\nApR\t|PERL_CONTEXT*|cx_dup\t|NULLOK PERL_CONTEXT* cx|I32 ix|I32 max|NN CLONE_PARAMS* param\nApR\t|PERL_SI*|si_dup\t|NULLOK PERL_SI* si|NN CLONE_PARAMS* param\nApR\t|ANY*\t|ss_dup\t\t|NN PerlInterpreter* proto_perl|NN CLONE_PARAMS* param\nApR\t|void*\t|any_dup\t|NULLOK void* v|NN const PerlInterpreter* proto_perl\nApR\t|HE*\t|he_dup\t\t|NULLOK const HE* e|bool shared|NN CLONE_PARAMS* param\nApR\t|HEK*\t|hek_dup\t|NULLOK HEK* e|NN CLONE_PARAMS* param\nAp\t|void\t|re_dup_guts\t|NN const REGEXP *sstr|NN REGEXP *dstr \\\n\t\t\t\t|NN CLONE_PARAMS* param\nAp\t|PerlIO*|fp_dup\t\t|NULLOK PerlIO *const fp|const char type|NN CLONE_PARAMS *const param\nApR\t|DIR*\t|dirp_dup\t|NULLOK DIR *const dp|NN CLONE_PARAMS *const param\nApR\t|GP*\t|gp_dup\t\t|NULLOK GP *const gp|NN CLONE_PARAMS *const param\nApR\t|MAGIC*\t|mg_dup\t\t|NULLOK MAGIC *mg|NN CLONE_PARAMS *const param\n#if defined(PERL_IN_SV_C)\ns\t|SV **\t|sv_dup_inc_multiple|NN SV *const *source|NN SV **dest \\\n\t\t\t\t|SSize_t items|NN CLONE_PARAMS *const param\nsR\t|SV*\t|sv_dup_common\t|NN const SV *const sstr \\\n\t\t\t\t|NN CLONE_PARAMS *const param\n#endif\nApR\t|SV*\t|sv_dup\t\t|NULLOK const SV *const sstr|NN CLONE_PARAMS *const param\nApR\t|SV*\t|sv_dup_inc\t|NULLOK const SV *const sstr \\\n\t\t\t\t|NN CLONE_PARAMS *const param\nAp\t|void\t|rvpv_dup\t|NN SV *const dstr|NN const SV *const sstr|NN CLONE_PARAMS *const param\nAp\t|yy_parser*|parser_dup\t|NULLOK const yy_parser *const proto|NN CLONE_PARAMS *const param\n#endif\nApR\t|PTR_TBL_t*|ptr_table_new\nApR\t|void*\t|ptr_table_fetch|NN PTR_TBL_t *const tbl|NULLOK const void *const sv\nAp\t|void\t|ptr_table_store|NN PTR_TBL_t *const tbl|NULLOK const void *const oldsv \\\n\t\t\t\t|NN void *const newsv\nAp\t|void\t|ptr_table_split|NN PTR_TBL_t *const tbl\nApD\t|void\t|ptr_table_clear|NULLOK PTR_TBL_t *const tbl\nAp\t|void\t|ptr_table_free|NULLOK PTR_TBL_t *const tbl\n#if defined(HAVE_INTERP_INTERN)\nAp\t|void\t|sys_intern_clear\nAp\t|void\t|sys_intern_init\n#  if defined(USE_ITHREADS)\nAp\t|void\t|sys_intern_dup\t|NN struct interp_intern* src|NN struct interp_intern* dst\n#  endif\n#endif\n\nAmop\t|const XOP *\t|custom_op_xop\t|NN const OP *o\nAbpR\t|const char *\t|custom_op_name\t|NN const OP *o\nAbpR\t|const char *\t|custom_op_desc\t|NN const OP *o\npRX\t|XOPRETANY\t|custom_op_get_field\t|NN const OP *o|const xop_flags_enum field\nAop\t|void\t|custom_op_register\t|NN Perl_ppaddr_t ppaddr \\\n\t\t\t|NN const XOP *xop\n\nAdp\t|void\t|sv_nosharing\t|NULLOK SV *sv\nAdpbm\t|void\t|sv_nolocking\t|NULLOK SV *sv\nAdp\t|bool\t|sv_destroyable\t|NULLOK SV *sv\nAdpb\t|void\t|sv_nounlocking\t|NULLOK SV *sv\nAdp\t|int\t|nothreadhook\np\t|void\t|init_constants\n\n#if defined(PERL_IN_DOOP_C)\nsR\t|Size_t\t|do_trans_simple\t|NN SV * const sv\nsR\t|Size_t\t|do_trans_count\t\t|NN SV * const sv\nsR\t|Size_t\t|do_trans_complex\t|NN SV * const sv\nsR\t|Size_t\t|do_trans_simple_utf8\t|NN SV * const sv\nsR\t|Size_t\t|do_trans_count_utf8\t|NN SV * const sv\nsR\t|Size_t\t|do_trans_complex_utf8\t|NN SV * const sv\n#endif\n\n#if defined(PERL_IN_GV_C)\ns\t|void\t|gv_init_svtype\t|NN GV *gv|const svtype sv_type\ns\t|void\t|gv_magicalize_isa\t|NN GV *gv\ns\t|bool|parse_gv_stash_name|NN HV **stash|NN GV **gv \\\n                     |NN const char **name|NN STRLEN *len \\\n                     |NN const char *nambeg|STRLEN full_len \\\n                     |const U32 is_utf8|const I32 add\ns\t|bool|find_default_stash|NN HV **stash|NN const char *name \\\n                     |STRLEN len|const U32 is_utf8|const I32 add \\\n                     |const svtype sv_type\ns\t|bool|gv_magicalize|NN GV *gv|NN HV *stash|NN const char *name \\\n                     |STRLEN len \\\n                     |const svtype sv_type\ns\t|void|maybe_multimagic_gv|NN GV *gv|NN const char *name|const svtype sv_type\ns\t|bool|gv_is_in_main|NN const char *name|STRLEN len \\\n                      |const U32 is_utf8\ns\t|void\t|require_tie_mod|NN GV *gv|NN const char varname \\\n\t\t\t\t|NN const char * name|STRLEN len \\\n\t\t\t\t|const U32 flags\n#endif\n\n#if defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C)\npo\t|SV*\t|hfree_next_entry\t|NN HV *hv|NN STRLEN *indexp\n#endif\n\n#if defined(PERL_IN_HV_C)\ns\t|void\t|hsplit\t\t|NN HV *hv|STRLEN const oldsize|STRLEN newsize\ns\t|void\t|hv_free_entries|NN HV *hv\ns\t|SV*\t|hv_free_ent_ret|NN HV *hv|NN HE *entry\nsR\t|HE*\t|new_he\nsanR\t|HEK*\t|save_hek_flags\t|NN const char *str|I32 len|U32 hash|int flags\nsn\t|void\t|hv_magic_check\t|NN HV *hv|NN bool *needs_copy|NN bool *needs_store\ns\t|void\t|unshare_hek_or_pvn|NULLOK const HEK* hek|NULLOK const char* str|I32 len|U32 hash\nsR\t|HEK*\t|share_hek_flags|NN const char *str|STRLEN len|U32 hash|int flags\nrs\t|void\t|hv_notallowed\t|int flags|NN const char *key|I32 klen|NN const char *msg\nin\t|U32|ptr_hash|PTRV u\ns\t|struct xpvhv_aux*|hv_auxinit|NN HV *hv\nsn\t|struct xpvhv_aux*|hv_auxinit_internal|NN struct xpvhv_aux *iter\nsM\t|SV*\t|hv_delete_common|NULLOK HV *hv|NULLOK SV *keysv \\\n\t\t|NULLOK const char *key|STRLEN klen|int k_flags|I32 d_flags \\\n\t\t|U32 hash\nsM\t|void\t|clear_placeholders\t|NN HV *hv|U32 items\n#endif\n\n#if defined(PERL_IN_MG_C)\ns\t|void\t|save_magic_flags|I32 mgs_ix|NN SV *sv|U32 flags\ns\t|int\t|magic_methpack\t|NN SV *sv|NN const MAGIC *mg|NN SV *meth\ns\t|SV*\t|magic_methcall1|NN SV *sv|NN const MAGIC *mg \\\n\t\t\t\t|NN SV *meth|U32 flags \\\n\t\t\t\t|int n|NULLOK SV *val\ns\t|void\t|restore_magic\t|NULLOK const void *p\ns\t|void\t|unwind_handler_stack|NULLOK const void *p\ns\t|void\t|fixup_errno_string|NN SV* sv\n\n#endif\n\n#if defined(PERL_IN_OP_C)\nsRn\t|bool\t|is_handle_constructor|NN const OP *o|I32 numargs\nsR\t|I32\t|assignment_type|NULLOK const OP *o\ns\t|void\t|forget_pmop\t|NN PMOP *const o\ns\t|void\t|find_and_forget_pmops\t|NN OP *o\ns\t|void\t|cop_free\t|NN COP *cop\ns\t|OP*\t|modkids\t|NULLOK OP *o|I32 type\ns\t|OP*\t|scalarboolean\t|NN OP *o\nsR\t|OP*\t|search_const\t|NN OP *o\nsR\t|OP*\t|new_logop\t|I32 type|I32 flags|NN OP **firstp|NN OP **otherp\ns\t|void\t|simplify_sort\t|NN OP *o\nsRn\t|bool\t|scalar_mod_type|NULLOK const OP *o|I32 type\ns\t|OP *\t|my_kid\t\t|NULLOK OP *o|NULLOK OP *attrs|NN OP **imopsp\ns\t|OP *\t|dup_attrlist\t|NN OP *o\ns\t|void\t|apply_attrs\t|NN HV *stash|NN SV *target|NULLOK OP *attrs\ns\t|void\t|apply_attrs_my\t|NN HV *stash|NN OP *target|NULLOK OP *attrs|NN OP **imopsp\ns\t|void\t|bad_type_pv\t|I32 n|NN const char *t|NN const OP *o|NN const OP *kid\ns\t|void\t|bad_type_gv\t|I32 n|NN GV *gv|NN const OP *kid|NN const char *t\ns\t|void\t|no_bareword_allowed|NN OP *o\nsR\t|OP*\t|no_fh_allowed|NN OP *o\nsR\t|OP*\t|too_few_arguments_pv|NN OP *o|NN const char* name|U32 flags\ns\t|OP*\t|too_many_arguments_pv|NN OP *o|NN const char* name|U32 flags\ns\t|bool\t|looks_like_bool|NN const OP* o\ns\t|OP*\t|newGIVWHENOP\t|NULLOK OP* cond|NN OP *block \\\n\t\t\t\t|I32 enter_opcode|I32 leave_opcode \\\n\t\t\t\t|PADOFFSET entertarg\ns\t|OP*\t|ref_array_or_hash|NULLOK OP* cond\ns\t|bool\t|process_special_blocks\t|I32 floor \\\n\t\t\t\t\t|NN const char *const fullname\\\n\t\t\t\t\t|NN GV *const gv|NN CV *const cv\ns\t|void\t|clear_special_blocks\t|NN const char *const fullname\\\n\t\t\t\t\t|NN GV *const gv|NN CV *const cv\n#endif\nXpR\t|void*\t|Slab_Alloc\t|size_t sz\nXp\t|void\t|Slab_Free\t|NN void *op\n#if defined(PERL_DEBUG_READONLY_OPS)\n#    if defined(PERL_CORE)\npx\t|void\t|Slab_to_ro\t|NN OPSLAB *slab\npx\t|void\t|Slab_to_rw\t|NN OPSLAB *const slab\n#    endif\n: Used in OpREFCNT_inc() in sv.c\npoxM\t|OP *\t|op_refcnt_inc\t|NULLOK OP *o\n: FIXME - can be static.\npoxM\t|PADOFFSET\t|op_refcnt_dec\t|NN OP *o\n#endif\n\n#if defined(PERL_IN_PERL_C)\ns\t|void\t|find_beginning\t|NN SV* linestr_sv|NN PerlIO *rsfp\ns\t|void\t|forbid_setid\t|const char flag|const bool suidscript\ns\t|void\t|incpush\t|NN const char *const dir|STRLEN len \\\n\t\t\t\t|U32 flags\ns\t|SV*\t|mayberelocate\t|NN const char *const dir|STRLEN len \\\n\t\t\t\t|U32 flags\ns\t|void\t|incpush_use_sep|NN const char *p|STRLEN len|U32 flags\ns\t|void\t|init_interp\ns\t|void\t|init_ids\ns\t|void\t|init_main_stash\ns\t|void\t|init_perllib\ns\t|void\t|init_postdump_symbols|int argc|NN char **argv|NULLOK char **env\ns\t|void\t|init_predump_symbols\nrs\t|void\t|my_exit_jump\ns\t|void\t|nuke_stacks\ns\t|PerlIO *|open_script\t|NN const char *scriptname|bool dosearch \\\n\t\t\t\t|NN bool *suidscript\nsr\t|void\t|usage\n#ifndef SETUID_SCRIPTS_ARE_SECURE_NOW\nso\t|void\t|validate_suid\t|NN PerlIO *rsfp\n#endif\nsr\t|void\t|minus_v\n\ns\t|void*\t|parse_body\t|NULLOK char **env|XSINIT_t xsinit\nrs\t|void\t|run_body\t|I32 oldscope\n#  ifndef PERL_IS_MINIPERL\ns\t|SV *\t|incpush_if_exists|NN AV *const av|NN SV *dir|NN SV *const stem\n#  endif\n#endif\n\n#if defined(PERL_IN_PP_C)\ns\t|size_t\t|do_chomp\t|NN SV *retval|NN SV *sv|bool chomping\ns\t|OP*\t|do_delete_local\nsR\t|SV*\t|refto\t\t|NN SV* sv\n#endif\n#if defined(PERL_IN_PP_C) || defined(PERL_IN_PP_HOT_C)\n: Used in pp_hot.c\npRxo\t|GV*\t|softref2xv\t|NN SV *const sv|NN const char *const what \\\n\t\t\t\t|const svtype type|NN SV ***spp\n#endif\n\n#if defined(PERL_IN_PP_PACK_C)\ns\t|SSize_t|unpack_rec\t|NN struct tempsym* symptr|NN const char *s \\\n\t\t\t\t|NN const char *strbeg|NN const char *strend|NULLOK const char **new_s\ns\t|SV **\t|pack_rec\t|NN SV *cat|NN struct tempsym* symptr|NN SV **beglist|NN SV **endlist\ns\t|SV*\t|mul128\t\t|NN SV *sv|U8 m\ns\t|SSize_t|measure_struct\t|NN struct tempsym* symptr\ns\t|bool\t|next_symbol\t|NN struct tempsym* symptr\nsR\t|SV*\t|is_an_int\t|NN const char *s|STRLEN l\ns\t|int\t|div128\t\t|NN SV *pnum|NN bool *done\ns\t|const char *|group_end\t|NN const char *patptr|NN const char *patend \\\n\t\t\t\t|char ender\nsR\t|const char *|get_num\t|NN const char *patptr|NN SSize_t *lenptr\nns\t|bool\t|need_utf8\t|NN const char *pat|NN const char *patend\nns\t|char\t|first_symbol\t|NN const char *pat|NN const char *patend\nsR\t|char *\t|sv_exp_grow\t|NN SV *sv|STRLEN needed\nsnR\t|char *\t|my_bytes_to_utf8|NN const U8 *start|STRLEN len|NN char *dest \\\n\t      \t\t\t|const bool needs_swap\n#endif\n\n#if defined(PERL_IN_PP_CTL_C)\nsR\t|OP*\t|docatch\t|Perl_ppaddr_t firstpp\nsR\t|OP*\t|dofindlabel\t|NN OP *o|NN const char *label|STRLEN len \\\n                                |U32 flags|NN OP **opstack|NN OP **oplimit\ns\t|MAGIC *|doparseform\t|NN SV *sv\nsnR\t|bool\t|num_overflow\t|NV value|I32 fldsize|I32 frcsize\nsR\t|I32\t|dopoptoeval\t|I32 startingblock\nsR\t|I32\t|dopoptogivenfor|I32 startingblock\nsR\t|I32\t|dopoptolabel\t|NN const char *label|STRLEN len|U32 flags\nsR\t|I32\t|dopoptoloop\t|I32 startingblock\nsR\t|I32\t|dopoptosub_at\t|NN const PERL_CONTEXT* cxstk|I32 startingblock\nsR\t|I32\t|dopoptowhen\t|I32 startingblock\ns\t|void\t|save_lines\t|NULLOK AV *array|NN SV *sv\ns\t|bool\t|doeval_compile\t|U8 gimme \\\n\t\t\t\t|NULLOK CV* outside|U32 seq|NULLOK HV* hh\nsR\t|PerlIO *|check_type_and_open|NN SV *name\n#ifndef PERL_DISABLE_PMC\nsR\t|PerlIO *|doopen_pm\t|NN SV *name\n#endif\niRn\t|bool\t|path_is_searchable|NN const char *name\nsR\t|I32\t|run_user_filter|int idx|NN SV *buf_sv|int maxlen\nsR\t|PMOP*\t|make_matcher\t|NN REGEXP* re\nsR\t|bool\t|matcher_matches_sv|NN PMOP* matcher|NN SV* sv\ns\t|void\t|destroy_matcher|NN PMOP* matcher\ns\t|OP*\t|do_smartmatch\t|NULLOK HV* seen_this \\\n\t\t\t\t|NULLOK HV* seen_other|const bool copied\n#endif\n\n#if defined(PERL_IN_PP_HOT_C)\ns\t|void\t|do_oddball\t|NN SV **oddkey|NN SV **firstkey\ni\t|HV*\t|opmethod_stash\t|NN SV* meth\n#endif\n\n#if defined(PERL_IN_PP_SORT_C)\ns\t|I32\t|sv_ncmp\t|NN SV *const a|NN SV *const b\ns\t|I32\t|sv_i_ncmp\t|NN SV *const a|NN SV *const b\ns\t|I32\t|amagic_ncmp\t|NN SV *const a|NN SV *const b\ns\t|I32\t|amagic_i_ncmp\t|NN SV *const a|NN SV *const b\ns\t|I32\t|amagic_cmp\t|NN SV *const str1|NN SV *const str2\n#  ifdef USE_LOCALE_COLLATE\ns\t|I32\t|amagic_cmp_locale|NN SV *const str1|NN SV *const str2\n#  endif\ns\t|I32\t|sortcv\t\t|NN SV *const a|NN SV *const b\ns\t|I32\t|sortcv_xsub\t|NN SV *const a|NN SV *const b\ns\t|I32\t|sortcv_stacked\t|NN SV *const a|NN SV *const b\n#endif\n\n#if defined(PERL_IN_PP_SYS_C)\ns\t|OP*\t|doform\t\t|NN CV *cv|NN GV *gv|NULLOK OP *retop\n#  if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)\nsR\t|int\t|dooneliner\t|NN const char *cmd|NN const char *filename\n#  endif\ns\t|SV *\t|space_join_names_mortal|NULLOK char *const *array\n#endif\np\t|OP *\t|tied_method|NN SV *methname|NN SV **sp \\\n\t\t\t\t|NN SV *const sv|NN const MAGIC *const mg \\\n\t\t\t\t|const U32 flags|U32 argc|...\n\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)\nEp\t|void\t|regprop\t|NULLOK const regexp *prog|NN SV* sv|NN const regnode* o|NULLOK const regmatch_info *reginfo \\\n\t\t\t\t|NULLOK const RExC_state_t *pRExC_state\nEp\t|int\t|re_printf\t|NN const char *fmt|...\n#endif\n#if defined(PERL_IN_REGCOMP_C)\nEs\t|regnode_offset|reg\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|I32 paren|NN I32 *flagp|U32 depth\nEs\t|regnode_offset|regnode_guts|NN RExC_state_t *pRExC_state          \\\n\t\t\t\t|const U8 op\t\t\t\t   \\\n\t\t\t\t|const STRLEN extra_len\t\t\t   \\\n\t\t\t\t|NN const char* const name\nEs\t|void\t|change_engine_size|NN RExC_state_t *pRExC_state|const Ptrdiff_t size\nEs\t|regnode_offset|reganode|NN RExC_state_t *pRExC_state|U8 op \\\n\t\t\t\t|U32 arg\nEs\t|regnode_offset|reg2Lanode|NN RExC_state_t *pRExC_state\t\t   \\\n\t\t\t\t|const U8 op\t\t\t\t   \\\n\t\t\t\t|const U32 arg1\t\t\t\t   \\\n\t\t\t\t|const I32 arg2\nEs\t|regnode_offset|regatom\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN I32 *flagp|U32 depth\nEs\t|regnode_offset|regbranch\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN I32 *flagp|I32 first|U32 depth\nEs\t|void\t |set_ANYOF_arg\t|NN RExC_state_t* const pRExC_state \\\n\t\t\t\t|NN regnode* const node                    \\\n\t\t\t\t|NULLOK SV* const cp_list                  \\\n\t\t\t\t|NULLOK SV* const runtime_defns\t\t   \\\n\t\t\t\t|NULLOK SV* const only_utf8_locale_list\nEs\t|void\t|output_posix_warnings\t\t\t\t\t    \\\n\t\t\t\t|NN RExC_state_t *pRExC_state\t\t    \\\n\t\t\t\t|NN AV* posix_warnings\nEs\t|AV*\t |add_multi_match|NULLOK AV* multi_char_matches\t\t    \\\n\t\t\t\t|NN SV* multi_string\t\t\t    \\\n\t\t\t\t|const STRLEN cp_count\nEs\t|regnode_offset|regclass|NN RExC_state_t *pRExC_state                 \\\n\t\t\t\t|NN I32 *flagp|U32 depth|const bool stop_at_1 \\\n\t\t\t\t|bool allow_multi_fold                        \\\n\t\t\t\t|const bool silence_non_portable              \\\n\t\t\t\t|const bool strict                            \\\n\t\t\t\t|bool optimizable\t\t\t      \\\n\t\t\t\t|NULLOK SV** ret_invlist\nEs\t|void|add_above_Latin1_folds|NN RExC_state_t *pRExC_state|const U8 cp \\\n\t\t\t\t|NN SV** invlist\nEi\t|regnode_offset|handle_named_backref|NN RExC_state_t *pRExC_state   \\\n\t\t\t\t|NN I32 *flagp\t\t\t\t    \\\n\t\t\t\t|NN char * parse_start\t\t\t    \\\n\t\t\t\t|char ch\nEsnR\t|unsigned int|regex_set_precedence|const U8 my_operator\nEs\t|regnode_offset|handle_regex_sets|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NULLOK SV ** return_invlist            \\\n\t\t\t\t|NN I32 *flagp|U32 depth                \\\n\t\t\t\t|NN char * const oregcomp_parse\nEs\t|void\t|set_regex_pv\t|NN RExC_state_t *pRExC_state|NN REGEXP *Rx\n#if defined(DEBUGGING) && defined(ENABLE_REGEX_SETS_DEBUGGING)\nEs\t|void\t|dump_regex_sets_structures\t\t\t\t    \\\n\t\t\t\t|NN RExC_state_t *pRExC_state\t\t    \\\n\t\t\t\t|NN AV * stack\t\t\t\t    \\\n\t\t\t\t|const IV fence|NN AV * fence_stack\n#endif\nEs\t|void|parse_lparen_question_flags|NN RExC_state_t *pRExC_state\nEs\t|regnode_offset|reg_node|NN RExC_state_t *pRExC_state|U8 op\nEs\t|regnode_offset|regpiece|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN I32 *flagp|U32 depth\nEs\t|bool\t|grok_bslash_N\t|NN RExC_state_t *pRExC_state\t\t    \\\n\t\t\t\t|NULLOK regnode_offset* nodep\t\t    \\\n\t\t\t\t|NULLOK UV *code_point_p\t\t    \\\n\t\t\t\t|NULLOK int* cp_count\t\t\t    \\\n\t\t\t\t|NN I32 *flagp\t\t\t\t    \\\n\t\t\t\t|const bool strict\t\t\t    \\\n\t\t\t\t|const U32 depth\nEs\t|void\t|reginsert\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|const U8 op\t\t\t\t    \\\n\t\t\t\t|const regnode_offset operand\t\t    \\\n\t\t\t\t|const U32 depth\nEsR\t|bool\t|regtail\t|NN RExC_state_t * pRExC_state\t\t    \\\n\t\t\t\t|NN const regnode_offset p\t\t    \\\n\t\t\t\t|NN const regnode_offset val\t\t    \\\n\t\t\t\t|const U32 depth\nEs\t|SV *\t|reg_scan_name\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|U32 flags\nEs\t|U32\t|join_exact\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode *scan|NN UV *min_subtract  \\\n\t\t\t\t|NN bool *unfolded_multi_char          \\\n\t\t\t\t|U32 flags|NULLOK regnode *val|U32 depth\nEin\t|U8   |compute_EXACTish|NN RExC_state_t *pRExC_state\nEs\t|void\t|nextchar\t|NN RExC_state_t *pRExC_state\nEs\t|void\t|skip_to_be_ignored_text|NN RExC_state_t *pRExC_state  \\\n\t\t\t\t|NN char ** p\t\t\t    \\\n\t\t\t\t|const bool force_to_xmod\nEin\t|char *\t|reg_skipcomment|NN RExC_state_t *pRExC_state|NN char * p\nEs\t|void\t|scan_commit\t|NN const RExC_state_t *pRExC_state \\\n\t\t\t\t|NN struct scan_data_t *data        \\\n\t\t\t\t|NN SSize_t *minlenp\t\t    \\\n\t\t\t\t|int is_inf\nEs\t|void\t|populate_ANYOF_from_invlist|NN regnode *node|NN SV** invlist_ptr\nEs\t|void\t|ssc_anything\t|NN regnode_ssc *ssc\nEsRn\t|int\t|ssc_is_anything|NN const regnode_ssc *ssc\nEs\t|void\t|ssc_init\t|NN const RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode_ssc *ssc\nEsRn\t|int\t|ssc_is_cp_posixl_init|NN const RExC_state_t *pRExC_state \\\n\t\t\t\t|NN const regnode_ssc *ssc\nEs\t|void\t|ssc_and\t|NN const RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode_ssc *ssc                \\\n\t\t\t\t|NN const regnode_charclass *and_with\nEs\t|void\t|ssc_or\t\t|NN const RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode_ssc *ssc \\\n\t\t\t\t|NN const regnode_charclass *or_with\nEs\t|SV*\t|get_ANYOF_cp_list_for_ssc                                 \\\n\t\t\t\t|NN const RExC_state_t *pRExC_state \\\n\t\t\t\t|NN const regnode_charclass* const node\nEi\t|void\t|ssc_intersection|NN regnode_ssc *ssc \\\n\t\t\t\t|NN SV* const invlist|const bool invert_2nd\nEi\t|void\t|ssc_union\t|NN regnode_ssc *ssc \\\n\t\t\t\t|NN SV* const invlist|const bool invert_2nd\nEi\t|void\t|ssc_add_range\t|NN regnode_ssc *ssc \\\n\t\t\t\t|UV const start|UV const end\nEi\t|void\t|ssc_cp_and\t|NN regnode_ssc *ssc \\\n\t\t\t\t|UV const cp\nEin\t|void\t|ssc_clear_locale|NN regnode_ssc *ssc\nEns\t|bool\t|is_ssc_worth_it|NN const RExC_state_t * pRExC_state \\\n\t\t\t\t|NN const regnode_ssc * ssc\nEs\t|void\t|ssc_finalize\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode_ssc *ssc\nEs\t|SSize_t|study_chunk\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode **scanp|NN SSize_t *minlenp \\\n\t\t\t\t|NN SSize_t *deltap|NN regnode *last \\\n\t\t\t\t|NULLOK struct scan_data_t *data \\\n                                |I32 stopparen|U32 recursed_depth \\\n\t\t\t\t|NULLOK regnode_ssc *and_withp \\\n\t\t\t\t|U32 flags|U32 depth|bool was_mutate_ok\nEs\t|void\t|rck_elide_nothing|NN regnode *node\nEsR\t|SV *\t|get_ANYOFM_contents|NN const regnode * n\nEsRn\t|U32\t|add_data\t|NN RExC_state_t* const pRExC_state \\\n\t\t\t\t|NN const char* const s|const U32 n\nrs\t|void\t|re_croak2\t|bool utf8|NN const char* pat1|NN const char* pat2|...\nEs\t|int\t|handle_possible_posix\t\t\t\t\t    \\\n\t\t\t\t|NN RExC_state_t *pRExC_state\t\t    \\\n\t\t\t\t|NN const char* const s\t\t\t    \\\n\t\t\t\t|NULLOK char ** updated_parse_ptr\t    \\\n\t\t\t\t|NULLOK AV** posix_warnings\t\t    \\\n\t\t\t\t|const bool check_only\nEs\t|I32\t|make_trie\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode *startbranch|NN regnode *first \\\n\t\t\t\t|NN regnode *last|NN regnode *tail \\\n\t\t\t\t|U32 word_count|U32 flags|U32 depth\nEs\t|regnode *|construct_ahocorasick_from_trie|NN RExC_state_t *pRExC_state \\\n                                |NN regnode *source|U32 depth\nEnsR\t|const char *|cntrl_to_mnemonic|const U8 c\nEnsR\t|int\t|edit_distance\t|NN const UV *src\t\t    \\\n\t\t\t\t|NN const UV *tgt\t\t    \\\n\t\t\t\t|const STRLEN x\t\t\t    \\\n\t\t\t\t|const STRLEN y\t\t\t    \\\n\t\t\t\t|const SSize_t maxDistance\nEpX\t|SV *\t|parse_uniprop_string|NN const char * const name\t    \\\n\t\t\t\t     |const Size_t name_len\t\t    \\\n\t\t\t\t     |const bool is_utf8\t\t    \\\n\t\t\t\t     |const bool to_fold\t\t    \\\n\t\t\t\t     |const bool runtime\t\t    \\\n\t\t\t\t     |const bool deferrable\t\t    \\\n\t\t\t\t     |NN bool * user_defined_ptr\t    \\\n\t\t\t\t     |NN SV * msg\t\t\t    \\\n\t\t\t\t     |const STRLEN level\nEXp\t|SV *\t|handle_user_defined_property|NN const char * name\t    \\\n\t\t\t\t\t     |const STRLEN name_len\t    \\\n\t\t\t\t\t     |const bool is_utf8\t    \\\n\t\t\t\t\t     |const bool to_fold\t    \\\n\t\t\t\t\t     |const bool runtime\t    \\\n\t\t\t\t\t     |const bool deferrable\t    \\\n\t\t\t\t\t     |NN SV* contents\t\t    \\\n\t\t\t\t\t     |NN bool *user_defined_ptr\t    \\\n\t\t\t\t\t     |NN SV * msg\t\t    \\\n\t\t\t\t\t     |const STRLEN level\n#  ifdef DEBUGGING\nEp\t|int\t|re_indentf\t|NN const char *fmt|U32 depth|...\nEs\t|void        |regdump_intflags|NULLOK const char *lead| const U32 flags\nEs\t|void\t|regdump_extflags|NULLOK const char *lead| const U32 flags\nEs\t|const regnode*|dumpuntil|NN const regexp *r|NN const regnode *start \\\n\t\t\t\t|NN const regnode *node \\\n\t\t\t\t|NULLOK const regnode *last \\\n\t\t\t\t|NULLOK const regnode *plast \\\n\t\t\t\t|NN SV* sv|I32 indent|U32 depth\nEs\t|void\t|put_code_point\t|NN SV* sv|UV c\nEs\t|bool\t|put_charclass_bitmap_innards|NN SV* sv\t\t    \\\n\t\t\t\t|NULLOK char* bitmap\t\t    \\\n\t\t\t\t|NULLOK SV* nonbitmap_invlist\t    \\\n\t\t\t\t|NULLOK SV* only_utf8_locale_invlist\\\n\t\t\t\t|NULLOK const regnode * const node  \\\n\t\t\t\t|const bool force_as_is_display\nEs\t|SV*\t|put_charclass_bitmap_innards_common\t\t    \\\n\t\t\t\t|NN SV* invlist\t\t\t    \\\n\t\t\t\t|NULLOK SV* posixes\t\t    \\\n\t\t\t\t|NULLOK SV* only_utf8\t\t    \\\n\t\t\t\t|NULLOK SV* not_utf8\t\t    \\\n\t\t\t\t|NULLOK SV* only_utf8_locale\t    \\\n\t\t\t\t|const bool invert\nEs\t|void\t|put_charclass_bitmap_innards_invlist\t\t    \\\n\t\t\t\t|NN SV *sv\t\t\t    \\\n\t\t\t\t|NN SV* invlist\nEs\t|void\t|put_range\t|NN SV* sv|UV start|const UV end    \\\n\t\t\t\t|const bool allow_literals\nEs\t|void\t|dump_trie\t|NN const struct _reg_trie_data *trie\\\n\t\t\t\t|NULLOK HV* widecharmap|NN AV *revcharmap\\\n\t\t\t\t|U32 depth\nEs\t|void\t|dump_trie_interim_list|NN const struct _reg_trie_data *trie\\\n\t\t\t\t|NULLOK HV* widecharmap|NN AV *revcharmap\\\n\t\t\t\t|U32 next_alloc|U32 depth\nEs\t|void\t|dump_trie_interim_table|NN const struct _reg_trie_data *trie\\\n\t\t\t\t|NULLOK HV* widecharmap|NN AV *revcharmap\\\n\t\t\t\t|U32 next_alloc|U32 depth\nEsR\t|bool\t|regtail_study\t|NN RExC_state_t *pRExC_state \\\n\t\t\t\t|NN regnode_offset p|NN const regnode_offset val|U32 depth\n#  endif\n#endif\n\n#if defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C)\nEXRpM\t|bool\t|isFOO_lc\t|const U8 classnum|const U8 character\n#endif\n\n#if defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_TOKE_C)\nERp\t|bool\t|_is_grapheme\t|NN const U8 * strbeg|NN const U8 * s|NN const U8 *strend|const UV cp\n#endif\n\n#if defined(PERL_IN_REGEXEC_C)\nERs\t|bool\t|isFOO_utf8_lc\t|const U8 classnum|NN const U8* character|NN const U8* e\nERns\t|U8 *\t|find_next_masked|NN U8 * s\t\t\t\t\\\n\t\t\t\t |NN const U8 * send\t\t\t\\\n\t\t\t\t |const U8 byte|const U8 mask\nERns\t|U8 *|find_span_end\t|NN U8* s|NN const U8 * send|const U8 span_byte\nERns\t|U8 *|find_span_end_mask|NN U8 * s|NN const U8 * send\t\\\n\t\t\t\t|const U8 span_byte|const U8 mask\nERs\t|SSize_t|regmatch\t|NN regmatch_info *reginfo|NN char *startpos|NN regnode *prog\nWERs\t|I32\t|regrepeat\t|NN regexp *prog|NN char **startposp \\\n\t\t\t\t|NN const regnode *p \\\n\t\t\t\t|NN char *loceol\t\t\\\n\t\t\t\t|NN regmatch_info *const reginfo \\\n\t\t\t\t|I32 max\nERs\t|bool\t|regtry\t\t|NN regmatch_info *reginfo|NN char **startposp\nERs\t|bool\t|reginclass\t|NULLOK regexp * const prog  \\\n\t\t\t\t|NN const regnode * const n  \\\n\t\t\t\t|NN const U8 * const p       \\\n\t\t\t\t|NN const U8 * const p_end   \\\n\t\t\t\t|bool const utf8_target\nWEs\t|CHECKPOINT|regcppush\t|NN const regexp *rex|I32 parenfloor\\\n\t\t\t\t|U32 maxopenparen\nWEs\t|void\t|regcppop\t|NN regexp *rex|NN U32 *maxopenparen_p\nWEs\t|void\t|regcp_restore\t|NN regexp *rex|I32 ix|NN U32 *maxopenparen_p\nERsn\t|U8*\t|reghop3\t|NN U8 *s|SSize_t off|NN const U8 *lim\nERsn\t|U8*\t|reghop4\t|NN U8 *s|SSize_t off|NN const U8 *llim \\\n\t\t\t\t|NN const U8 *rlim\nERsn\t|U8*\t|reghopmaybe3\t|NN U8 *s|SSize_t off|NN const U8 * const lim\nERs\t|char*\t|find_byclass\t|NN regexp * prog|NN const regnode *c \\\n\t\t\t\t|NN char *s|NN const char *strend \\\n\t\t\t\t|NULLOK regmatch_info *reginfo\nEs\t|void\t|to_utf8_substr\t|NN regexp * prog\nEs\t|bool\t|to_byte_substr\t|NN regexp * prog\nERsn\t|I32\t|reg_check_named_buff_matched\t|NN const regexp *rex \\\n\t\t\t\t\t\t|NN const regnode *scan\nEsR\t|bool\t|isGCB\t\t|const GCB_enum before\t\t\t\\\n\t\t\t\t|const GCB_enum after\t\t\t\\\n\t\t\t\t|NN const U8 * const strbeg\t\t\\\n\t\t\t\t|NN const U8 * const curpos\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|GCB_enum|backup_one_GCB|NN const U8 * const strbeg\t\t\t\\\n\t\t\t\t|NN U8 ** curpos\t\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|bool\t|isLB\t\t|LB_enum before\t\t\t\t\\\n\t\t\t\t|LB_enum after\t\t\t\t\\\n\t\t\t\t|NN const U8 * const strbeg\t\t\\\n\t\t\t\t|NN const U8 * const curpos\t\t\\\n\t\t\t\t|NN const U8 * const strend\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|LB_enum|advance_one_LB |NN U8 ** curpos\t\t\t\t\\\n\t\t\t\t|NN const U8 * const strend\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|LB_enum|backup_one_LB  |NN const U8 * const strbeg\t\t\t\\\n\t\t\t\t|NN U8 ** curpos\t\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|bool\t|isSB\t\t|SB_enum before\t\t\t\t\\\n\t\t\t\t|SB_enum after\t\t\t\t\\\n\t\t\t\t|NN const U8 * const strbeg\t\t\t\\\n\t\t\t\t|NN const U8 * const curpos\t\t\t\\\n\t\t\t\t|NN const U8 * const strend\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|SB_enum|advance_one_SB |NN U8 ** curpos\t\t\t\t\\\n\t\t\t\t|NN const U8 * const strend\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|SB_enum|backup_one_SB  |NN const U8 * const strbeg\t\t\t\\\n\t\t\t\t|NN U8 ** curpos\t\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|bool\t|isWB\t\t|WB_enum previous\t\t\t\t\\\n\t\t\t\t|WB_enum before\t\t\t\t\\\n\t\t\t\t|WB_enum after\t\t\t\t\\\n\t\t\t\t|NN const U8 * const strbeg\t\t\t\\\n\t\t\t\t|NN const U8 * const curpos\t\t\t\\\n\t\t\t\t|NN const U8 * const strend\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEsR\t|WB_enum|advance_one_WB |NN U8 ** curpos\t\t\t\t\\\n\t\t\t\t|NN const U8 * const strend\t\t\t\\\n\t\t\t\t|const bool utf8_target\t\t\t\t\\\n\t\t\t\t|const bool skip_Extend_Format\nEsR\t|WB_enum|backup_one_WB  |NN WB_enum * previous\t\t\t\\\n\t\t\t\t|NN const U8 * const strbeg\t\t\t\\\n\t\t\t\t|NN U8 ** curpos\t\t\t\t\\\n\t\t\t\t|const bool utf8_target\nEin\t|I32\t|foldEQ_latin1_s2_folded|NN const char* a|NN const char* b|I32 len\n#  ifdef DEBUGGING\nEs\t|void\t|dump_exec_pos\t|NN const char *locinput|NN const regnode *scan|NN const char *loc_regeol\\\n\t\t\t\t|NN const char *loc_bostr|NN const char *loc_reg_starttry|const bool do_utf8|const U32 depth\nEs\t|void\t|debug_start_match|NN const REGEXP *prog|const bool do_utf8\\\n\t\t\t\t|NN const char *start|NN const char *end\\\n\t\t\t\t|NN const char *blurb\n\nEp\t|int\t|re_exec_indentf\t|NN const char *fmt|U32 depth|...\n#  endif\n#endif\n\n#if defined(PERL_IN_DUMP_C)\ns\t|CV*\t|deb_curcv\t|I32 ix\ns\t|void\t|debprof\t|NN const OP *o\ns\t|UV\t|sequence_num\t|NULLOK const OP *o\ns\t|SV*\t|pm_description\t|NN const PMOP *pm\n#endif\n\n#if defined(PERL_IN_SCOPE_C)\ns\t|SV*\t|save_scalar_at\t|NN SV **sptr|const U32 flags\n#endif\n\n#if defined(PERL_IN_GV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_PAD_C) || defined(PERL_IN_OP_C)\n: Used in gv.c\npo\t|void\t|sv_add_backref\t|NN SV *const tsv|NN SV *const sv\n#endif\n\n#if defined(PERL_IN_HV_C) || defined(PERL_IN_MG_C) || defined(PERL_IN_SV_C)\n: Used in hv.c and mg.c\npoM\t|void\t|sv_kill_backrefs\t|NN SV *const sv|NULLOK AV *const av\n#endif\n\n#if defined(PERL_IN_SV_C) || defined (PERL_IN_OP_C)\npR\t|SV *\t|varname\t|NULLOK const GV *const gv|const char gvtype \\\n\t\t\t\t|PADOFFSET targ|NULLOK const SV *const keyname \\\n\t\t\t\t|SSize_t aindex|int subscript_type\n#endif\n\npX\t|void\t|sv_del_backref\t|NN SV *const tsv|NN SV *const sv\n#if defined(PERL_IN_SV_C)\nniR\t|char *\t|uiv_2buf\t|NN char *const buf|const IV iv|UV uv|const int is_uv|NN char **const peob\ni\t|void\t|sv_unglob\t|NN SV *const sv|U32 flags\ns\t|const char *|sv_display\t|NN SV *const sv|NN char *tmpbuf|STRLEN tmpbuf_size\ns\t|void\t|not_a_number\t|NN SV *const sv\ns\t|void\t|not_incrementable\t|NN SV *const sv\ns\t|I32\t|visit\t\t|NN SVFUNC_t f|const U32 flags|const U32 mask\n#  ifdef DEBUGGING\ns\t|void\t|del_sv\t|NN SV *p\n#  endif\n#  if !defined(NV_PRESERVES_UV)\n#    ifdef DEBUGGING\ns\t|int\t|sv_2iuv_non_preserve\t|NN SV *const sv|I32 numtype\n#    else\ns\t|int\t|sv_2iuv_non_preserve\t|NN SV *const sv\n#    endif\n#  endif\nsR\t|STRLEN\t|expect_number\t|NN const char **const pattern\nsn\t|STRLEN\t|sv_pos_u2b_forwards|NN const U8 *const start \\\n\t\t|NN const U8 *const send|NN STRLEN *const uoffset \\\n\t\t|NN bool *const at_end\nsn\t|STRLEN\t|sv_pos_u2b_midway|NN const U8 *const start \\\n\t\t|NN const U8 *send|STRLEN uoffset|const STRLEN uend\ns\t|STRLEN\t|sv_pos_u2b_cached|NN SV *const sv|NN MAGIC **const mgp \\\n\t\t|NN const U8 *const start|NN const U8 *const send \\\n\t\t|STRLEN uoffset|STRLEN uoffset0|STRLEN boffset0\ns\t|void\t|utf8_mg_len_cache_update|NN SV *const sv|NN MAGIC **const mgp \\\n\t\t|const STRLEN ulen\ns\t|void\t|utf8_mg_pos_cache_update|NN SV *const sv|NN MAGIC **const mgp \\\n\t\t|const STRLEN byte|const STRLEN utf8|const STRLEN blen\ns\t|STRLEN\t|sv_pos_b2u_midway|NN const U8 *const s|NN const U8 *const target \\\n\t\t|NN const U8 *end|STRLEN endu\ns\t|void\t|assert_uft8_cache_coherent|NN const char *const func \\\n\t\t|STRLEN from_cache|STRLEN real|NN SV *const sv\nsn\t|char *\t|F0convert\t|NV nv|NN char *const endbuf|NN STRLEN *const len\ns\t|SV *\t|more_sv\ns\t|bool\t|sv_2iuv_common\t|NN SV *const sv\ns\t|void\t|glob_assign_glob|NN SV *const dstr|NN SV *const sstr \\\n\t\t|const int dtype\nsRn\t|PTR_TBL_ENT_t *|ptr_table_find|NN PTR_TBL_t *const tbl|NULLOK const void *const sv\ns\t|void\t|anonymise_cv_maybe\t|NN GV *gv|NN CV *cv\n#endif\n\n: Used in sv.c and hv.c\npo\t|void *\t|more_bodies\t|const svtype sv_type|const size_t body_size \\\n\t\t\t\t|const size_t arena_size\nEXpR\t|SV*\t|get_and_check_backslash_N_name|NN const char* s\t\\\n\t\t\t\t|NN const char* const e\t\t\t\\\n\t\t\t\t|const bool is_utf8\t\t\t\\\n\t\t\t\t|NN const char** error_msg\n\n: For use ONLY in B::Hooks::Parser, by special dispensation\nEXpMR\t|char*\t|scan_str\t|NN char *start|int keep_quoted \\\n\t\t\t\t|int keep_delims|int re_reparse \\\n\t\t\t\t|NULLOK char **delimp\nEXpM\t|char*\t|scan_word\t|NN char *s|NN char *dest|STRLEN destlen \\\n\t\t\t\t|int allow_package|NN STRLEN *slp\nEXpMR\t|char*\t|skipspace_flags|NN char *s|U32 flags\n#if defined(PERL_IN_TOKE_C)\ns\t|void\t|check_uni\ns\t|void\t|force_next\t|I32 type\ns\t|char*\t|force_version\t|NN char *s|int guessing\ns\t|char*\t|force_strict_version\t|NN char *s\ns\t|char*\t|force_word\t|NN char *start|int token|int check_keyword \\\n\t\t\t\t|int allow_pack\ns\t|SV*\t|tokeq\t\t|NN SV *sv\nsR\t|char*\t|scan_const\t|NN char *start\nsR\t|SV*\t|get_and_check_backslash_N_name_wrapper|NN const char* s \\\n\t\t\t\t|NN const char* const e\nsR\t|char*\t|scan_formline\t|NN char *s\nsR\t|char*\t|scan_heredoc\t|NN char *s\ns\t|char*\t|scan_ident\t|NN char *s|NN char *dest\t\\\n\t\t\t\t|STRLEN destlen|I32 ck_uni\nsR\t|char*\t|scan_inputsymbol|NN char *start\nsR\t|char*\t|scan_pat\t|NN char *start|I32 type\nsR\t|char*\t|scan_subst\t|NN char *start\nsR\t|char*\t|scan_trans\t|NN char *start\ns\t|void\t|update_debugger_info|NULLOK SV *orig_sv \\\n\t\t\t\t|NULLOK const char *const buf|STRLEN len\nsR\t|char*\t|swallow_bom\t|NN U8 *s\n#ifndef PERL_NO_UTF16_FILTER\ns\t|I32\t|utf16_textfilter|int idx|NN SV *sv|int maxlen\ns\t|U8*\t|add_utf16_textfilter|NN U8 *const s|bool reversed\n#endif\ns\t|void\t|checkcomma\t|NN const char *s|NN const char *name \\\n\t\t\t\t|NN const char *what\ns\t|void\t|force_ident\t|NN const char *s|int kind\ns\t|void\t|force_ident_maybe_lex|char pit\ns\t|void\t|incline\t|NN const char *s|NN const char *end\ns\t|int\t|intuit_method\t|NN char *s|NULLOK SV *ioname|NULLOK CV *cv\ns\t|int\t|intuit_more\t|NN char *s|NN char *e\ns\t|I32\t|lop\t\t|I32 f|U8 x|NN char *s\nrs\t|void\t|missingterm\t|NULLOK char *s|STRLEN len\ns\t|void\t|no_op\t\t|NN const char *const what|NULLOK char *s\ns\t|int\t|pending_ident\nsR\t|I32\t|sublex_done\nsR\t|I32\t|sublex_push\nsR\t|I32\t|sublex_start\nsR\t|char *\t|filter_gets\t|NN SV *sv|STRLEN append\nsR\t|HV *\t|find_in_my_stash|NN const char *pkgname|STRLEN len\nsR\t|char *\t|tokenize_use\t|int is_use|NN char *s\nso\t|SV*\t|new_constant\t|NULLOK const char *s|STRLEN len\t    \\\n\t\t\t\t|NN const char *key|STRLEN keylen|NN SV *sv \\\n\t\t\t\t|NULLOK SV *pv|NULLOK const char *type\t    \\\n\t\t\t\t|STRLEN typelen\t\t\t\t    \\\n\t\t\t\t|NULLOK const char ** error_msg\ns\t|int\t|ao\t\t|int toketype\ns\t|void|parse_ident|NN char **s|NN char **d \\\n                     |NN char * const e|int allow_package \\\n\t\t\t\t|bool is_utf8|bool check_dollar \\\n\t\t\t\t|bool tick_warn\n#  if defined(PERL_CR_FILTER)\ns\t|I32\t|cr_textfilter\t|int idx|NULLOK SV *sv|int maxlen\ns\t|void\t|strip_return\t|NN SV *sv\n#  endif\n#  if defined(DEBUGGING)\ns\t|int\t|tokereport\t|I32 rv|NN const YYSTYPE* lvalp\nsf\t|void\t|printbuf\t|NN const char *const fmt|NN const char *const s\n#  endif\n#endif\nEXMp\t|bool\t|validate_proto\t|NN SV *name|NULLOK SV *proto|bool warn \\\n\t\t|bool curstash\n\n#if defined(PERL_IN_UNIVERSAL_C)\ns\t|bool\t|isa_lookup\t|NN HV *stash|NN const char * const name \\\n                                        |STRLEN len|U32 flags\n#endif\n\n#if defined(PERL_IN_LOCALE_C)\n#  ifdef USE_LOCALE\nsn\t|const char*|category_name |const int category\ns\t|const char*|switch_category_locale_to_template|const int switch_category|const int template_category|NULLOK const char * template_locale\ns\t|void\t|restore_switched_locale|const int category|NULLOK const char * const original_locale\n#  endif\n#  ifdef HAS_NL_LANGINFO\nsn\t|const char*|my_nl_langinfo|const nl_item item|bool toggle\n#  else\nsn\t|const char*|my_nl_langinfo|const int item|bool toggle\n#  endif\ninR\t|const char *|save_to_buffer|NULLOK const char * string\t\\\n\t\t\t\t    |NULLOK char **buf\t\t\\\n\t\t\t\t    |NN Size_t *buf_size\t\\\n\t\t\t\t    |const Size_t offset\n#  if defined(USE_LOCALE)\ns\t|char*\t|stdize_locale\t|NN char* locs\ns\t|void\t|new_collate\t|NULLOK const char* newcoll\ns\t|void\t|new_ctype\t|NN const char* newctype\ns\t|void\t|set_numeric_radix|const bool use_locale\ns\t|void\t|new_numeric\t|NULLOK const char* newnum\n#    ifdef USE_POSIX_2008_LOCALE\nsn\t|const char*|emulate_setlocale|const int category\t\t\\\n\t\t\t\t    |NULLOK const char* locale\t\t\\\n\t\t\t\t    |unsigned int index\t\t\t\\\n\t\t\t\t    |const bool is_index_valid\n#    endif\n#    ifdef WIN32\ns\t|char*\t|win32_setlocale|int category|NULLOK const char* locale\n#    endif\n#    ifdef DEBUGGING\ns\t|void\t|print_collxfrm_input_and_return\t\t\\\n\t\t\t    |NN const char * const s\t\t\\\n\t\t\t    |NN const char * const e\t\t\\\n\t\t\t    |NULLOK const STRLEN * const xlen\t\\\n\t\t\t    |const bool is_utf8\ns\t|void\t|print_bytes_for_locale\t|NN const char * const s\t\\\n\t\t\t\t\t|NN const char * const e\t\\\n\t\t\t\t\t|const bool is_utf8\nsnR\t|char *\t|setlocale_debug_string\t|const int category\t\t    \\\n\t\t\t\t\t|NULLOK const char* const locale    \\\n\t\t\t\t\t|NULLOK const char* const retval\n#    endif\n#  endif\n#endif\n\n#if        defined(USE_LOCALE)\t\t\\\n    && (   defined(PERL_IN_LOCALE_C)\t\\\n        || defined(PERL_IN_MG_C)\t\\\n\t|| defined (PERL_EXT_POSIX)\t\\\n\t|| defined (PERL_EXT_LANGINFO))\nApM\t|bool\t|_is_cur_LC_category_utf8|int category\n#endif\n\n\n#if defined(PERL_IN_UTIL_C)\ns\t|SV*\t|mess_alloc\ns\t|SV *\t|with_queued_errors|NN SV *ex\ns\t|bool\t|invoke_exception_hook|NULLOK SV *ex|bool warn\n#if defined(PERL_MEM_LOG) && !defined(PERL_MEM_LOG_NOIMPL)\nsn\t|void\t|mem_log_common\t|enum mem_log_type mlt|const UV n|const UV typesize \\\n\t\t\t\t|NN const char *type_name|NULLOK const SV *sv \\\n\t\t\t\t|Malloc_t oldalloc|Malloc_t newalloc \\\n\t\t\t\t|NN const char *filename|const int linenumber \\\n\t\t\t\t|NN const char *funcname\n#endif\n#endif\n\n#if defined(PERL_MEM_LOG)\npn\t|Malloc_t\t|mem_log_alloc\t|const UV nconst|UV typesize|NN const char *type_name|Malloc_t newalloc|NN const char *filename|const int linenumber|NN const char *funcname\npn\t|Malloc_t\t|mem_log_realloc\t|const UV n|const UV typesize|NN const char *type_name|Malloc_t oldalloc|Malloc_t newalloc|NN const char *filename|const int linenumber|NN const char *funcname\npn\t|Malloc_t\t|mem_log_free\t|Malloc_t oldalloc|NN const char *filename|const int linenumber|NN const char *funcname\n#endif\n\n#if defined(PERL_IN_UTF8_C)\nsR\t|HV *\t|new_msg_hv |NN const char * const message\t\t    \\\n\t\t\t    |U32 categories\t\t\t\t    \\\n\t\t\t    |U32 flag\nsRM\t|UV\t|check_locale_boundary_crossing\t\t\t\t    \\\n\t\t|NN const U8* const p\t\t\t\t\t    \\\n\t\t|const UV result\t\t\t\t\t    \\\n\t\t|NN U8* const ustrp\t\t\t\t\t    \\\n\t\t|NN STRLEN *lenp\niR\t|bool\t|is_utf8_common\t|NN const U8 *const p\t\t\t    \\\n\t\t\t\t|NULLOK SV* const invlist\niR\t|bool\t|is_utf8_common_with_len|NN const U8 *const p\t\t    \\\n\t\t\t\t\t|NN const U8 *const e\t\t    \\\n\t\t\t\t\t|NULLOK SV* const invlist\nsR\t|SV*\t|swatch_get\t|NN SV* swash|UV start|UV span\nsRM\t|U8*\t|swash_scan_list_line|NN U8* l|NN U8* const lend|NN UV* min \\\n\t\t|NN UV* max|NN UV* val|const bool wants_value\t\t    \\\n\t\t|NN const U8* const typestr\n#endif\n\nEXiMn\t|void\t|append_utf8_from_native_byte|const U8 byte|NN U8** dest\n\nApd\t|void\t|sv_set_undef\t|NN SV *sv\nApd\t|void\t|sv_setsv_flags\t|NN SV *dstr|NULLOK SV *sstr|const I32 flags\nApd\t|void\t|sv_catpvn_flags|NN SV *const dstr|NN const char *sstr|const STRLEN len \\\n\t\t\t\t|const I32 flags\nApd\t|void\t|sv_catpv_flags\t|NN SV *dstr|NN const char *sstr \\\n\t\t\t\t|const I32 flags\nApd\t|void\t|sv_catsv_flags\t|NN SV *const dsv|NULLOK SV *const ssv|const I32 flags\nApmd\t|STRLEN\t|sv_utf8_upgrade_flags|NN SV *const sv|const I32 flags\nAp\t|STRLEN\t|sv_utf8_upgrade_flags_grow|NN SV *const sv|const I32 flags|STRLEN extra\nApd\t|char*\t|sv_pvn_force_flags|NN SV *const sv|NULLOK STRLEN *const lp|const I32 flags\nApmb\t|void\t|sv_copypv\t|NN SV *const dsv|NN SV *const ssv\nApmd\t|void\t|sv_copypv_nomg\t|NN SV *const dsv|NN SV *const ssv\nApd\t|void\t|sv_copypv_flags\t|NN SV *const dsv|NN SV *const ssv|const I32 flags\nApo\t|char*\t|my_atof2\t|NN const char *orig|NN NV* value\nAp\t|char*\t|my_atof3\t|NN const char *orig|NN NV* value|const STRLEN len\nApn\t|int\t|my_socketpair\t|int family|int type|int protocol|int fd[2]\nApn\t|int\t|my_dirfd\t|NULLOK DIR* dir\n#ifdef PERL_ANY_COW\n: Used in pp_hot.c and regexec.c\npMXE\t|SV*\t|sv_setsv_cow\t|NULLOK SV* dstr|NN SV* sstr\n#endif\n\nAop\t|const char *|PerlIO_context_layers|NULLOK const char *mode\n\n#if defined(USE_PERLIO)\nAp\t|int\t|PerlIO_close\t\t|NULLOK PerlIO *f\nAp\t|int\t|PerlIO_fill\t\t|NULLOK PerlIO *f\nAp\t|int\t|PerlIO_fileno\t\t|NULLOK PerlIO *f\nAp\t|int\t|PerlIO_eof\t\t|NULLOK PerlIO *f\nAp\t|int\t|PerlIO_error\t\t|NULLOK PerlIO *f\nAp\t|int\t|PerlIO_flush\t\t|NULLOK PerlIO *f\nAp\t|void\t|PerlIO_clearerr\t|NULLOK PerlIO *f\nAp\t|void\t|PerlIO_set_cnt\t\t|NULLOK PerlIO *f|SSize_t cnt\nAp\t|void\t|PerlIO_set_ptrcnt\t|NULLOK PerlIO *f|NULLOK STDCHAR *ptr \\\n\t\t\t\t\t|SSize_t cnt\nAp\t|void\t|PerlIO_setlinebuf\t|NULLOK PerlIO *f\nAp\t|SSize_t|PerlIO_read\t\t|NULLOK PerlIO *f|NN void *vbuf \\\n\t\t\t\t\t|Size_t count\nAp\t|SSize_t|PerlIO_write\t\t|NULLOK PerlIO *f|NN const void *vbuf \\\n\t\t\t\t\t|Size_t count\nAp\t|SSize_t|PerlIO_unread\t\t|NULLOK PerlIO *f|NN const void *vbuf \\\n\t\t\t\t\t|Size_t count\nAp\t|Off_t\t|PerlIO_tell\t\t|NULLOK PerlIO *f\nAp\t|int\t|PerlIO_seek\t\t|NULLOK PerlIO *f|Off_t offset|int whence\nXp\t|void\t|PerlIO_save_errno\t|NULLOK PerlIO *f\nXp\t|void\t|PerlIO_restore_errno\t|NULLOK PerlIO *f\n\nAp\t|STDCHAR *|PerlIO_get_base\t|NULLOK PerlIO *f\nAp\t|STDCHAR *|PerlIO_get_ptr\t|NULLOK PerlIO *f\nApR\t|SSize_t\t  |PerlIO_get_bufsiz\t|NULLOK PerlIO *f\nApR\t|SSize_t\t  |PerlIO_get_cnt\t|NULLOK PerlIO *f\n\nApR\t|PerlIO *|PerlIO_stdin\nApR\t|PerlIO *|PerlIO_stdout\nApR\t|PerlIO *|PerlIO_stderr\n#endif /* USE_PERLIO */\n\n: Only used in dump.c\np\t|void\t|deb_stack_all\n#if defined(PERL_IN_DEB_C)\ns\t|void\t|deb_stack_n\t|NN SV** stack_base|I32 stack_min \\\n\t\t\t\t|I32 stack_max|I32 mark_min|I32 mark_max\n#endif\n\n: pad API\nApdR\t|PADLIST*|pad_new\t|int flags\n#ifdef DEBUGGING\npnX\t|void|set_padlist| NN CV * cv | NULLOK PADLIST * padlist\n#endif\n#if defined(PERL_IN_PAD_C)\ns\t|PADOFFSET|pad_alloc_name|NN PADNAME *name|U32 flags \\\n\t\t\t\t|NULLOK HV *typestash|NULLOK HV *ourstash\n#endif\nApd\t|PADOFFSET|pad_add_name_pvn|NN const char *namepv|STRLEN namelen\\\n\t\t\t\t|U32 flags|NULLOK HV *typestash\\\n\t\t\t\t|NULLOK HV *ourstash\nApd\t|PADOFFSET|pad_add_name_pv|NN const char *name\\\n\t\t\t\t|const U32 flags|NULLOK HV *typestash\\\n\t\t\t\t|NULLOK HV *ourstash\nApd\t|PADOFFSET|pad_add_name_sv|NN SV *name\\\n\t\t\t\t|U32 flags|NULLOK HV *typestash\\\n\t\t\t\t|NULLOK HV *ourstash\nAMpd\t|PADOFFSET|pad_alloc\t|I32 optype|U32 tmptype\nApd\t|PADOFFSET|pad_add_anon\t|NN CV* func|I32 optype\np\t|void\t|pad_add_weakref|NN CV* func\n#if defined(PERL_IN_PAD_C)\nsd\t|void\t|pad_check_dup\t|NN PADNAME *name|U32 flags \\\n\t\t\t\t|NULLOK const HV *ourstash\n#endif\nApd\t|PADOFFSET|pad_findmy_pvn|NN const char* namepv|STRLEN namelen|U32 flags\nApd\t|PADOFFSET|pad_findmy_pv|NN const char* name|U32 flags\nApd\t|PADOFFSET|pad_findmy_sv|NN SV* name|U32 flags\nApdD\t|PADOFFSET|find_rundefsvoffset\t|\nApd\t|SV*\t|find_rundefsv\t|\n#if defined(PERL_IN_PAD_C)\nsd\t|PADOFFSET|pad_findlex\t|NN const char *namepv|STRLEN namelen|U32 flags \\\n\t\t\t\t|NN const CV* cv|U32 seq|int warn \\\n\t\t\t\t|NULLOK SV** out_capture \\\n\t\t\t\t|NN PADNAME** out_name|NN int *out_flags\n#endif\n#ifdef DEBUGGING\nApd\t|SV*\t|pad_sv\t\t|PADOFFSET po\nApd\t|void\t|pad_setsv\t|PADOFFSET po|NN SV* sv\n#endif\npd\t|void\t|pad_block_start|int full\nApd\t|U32\t|intro_my\npd\t|OP *\t|pad_leavemy\npd\t|void\t|pad_swipe\t|PADOFFSET po|bool refadjust\n#if defined(PERL_IN_PAD_C)\nsd\t|void\t|pad_reset\n#endif\nAMpd\t|void\t|pad_tidy\t|padtidy_type type\npd\t|void\t|pad_free\t|PADOFFSET po\npd\t|void\t|do_dump_pad\t|I32 level|NN PerlIO *file|NULLOK PADLIST *padlist|int full\n#if defined(PERL_IN_PAD_C)\n#  if defined(DEBUGGING)\nsd\t|void\t|cv_dump\t|NN const CV *cv|NN const char *title\n#  endif\n#endif\nApd\t|CV*\t|cv_clone\t|NN CV* proto\np\t|CV*\t|cv_clone_into\t|NN CV* proto|NN CV *target\npd\t|void\t|pad_fixup_inner_anons|NN PADLIST *padlist|NN CV *old_cv|NN CV *new_cv\npdX\t|void\t|pad_push\t|NN PADLIST *padlist|int depth\nApbdR\t|HV*\t|pad_compname_type|const PADOFFSET po\nAMpdRn\t|PADNAME *|padnamelist_fetch|NN PADNAMELIST *pnl|SSize_t key\nXop\t|void\t|padnamelist_free|NN PADNAMELIST *pnl\nAMpd\t|PADNAME **|padnamelist_store|NN PADNAMELIST *pnl|SSize_t key \\\n\t\t\t\t     |NULLOK PADNAME *val\nXop\t|void\t|padname_free\t|NN PADNAME *pn\n#if defined(USE_ITHREADS)\npdR\t|PADNAME *|padname_dup\t|NN PADNAME *src|NN CLONE_PARAMS *param\npR\t|PADNAMELIST *|padnamelist_dup|NN PADNAMELIST *srcpad \\\n\t\t\t\t      |NN CLONE_PARAMS *param\npdR\t|PADLIST *|padlist_dup\t|NN PADLIST *srcpad \\\n\t\t\t\t|NN CLONE_PARAMS *param\n#endif\np\t|PAD **\t|padlist_store\t|NN PADLIST *padlist|I32 key \\\n\t\t\t\t|NULLOK PAD *val\n\nApdR\t|CV*\t|find_runcv\t|NULLOK U32 *db_seqp\npR\t|CV*\t|find_runcv_where|U8 cond|IV arg \\\n\t\t\t\t |NULLOK U32 *db_seqp\n: Only used in perl.c\np\t|void\t|free_tied_hv_pool\n#if defined(DEBUGGING)\n: Used in mg.c\npR\t|int\t|get_debug_opts\t|NN const char **s|bool givehelp\n#endif\nAp\t|void\t|save_set_svflags|NN SV *sv|U32 mask|U32 val\n#ifdef DEBUGGING\nApod\t|void\t|hv_assert\t|NN HV *hv\n#endif\n\nApdR\t|SV*\t|hv_scalar\t|NN HV *hv\np\t|void\t|hv_pushkv\t|NN HV *hv|U32 flags\nApdRM\t|SV*\t|hv_bucket_ratio|NN HV *hv\nApoR\t|I32*\t|hv_riter_p\t|NN HV *hv\nApoR\t|HE**\t|hv_eiter_p\t|NN HV *hv\nApo\t|void\t|hv_riter_set\t|NN HV *hv|I32 riter\nApo\t|void\t|hv_eiter_set\t|NN HV *hv|NULLOK HE *eiter\nAp\t|void   |hv_rand_set    |NN HV *hv|U32 new_xhv_rand\nAp\t|void\t|hv_name_set\t|NN HV *hv|NULLOK const char *name|U32 len|U32 flags\np\t|void\t|hv_ename_add\t|NN HV *hv|NN const char *name|U32 len \\\n\t\t\t\t|U32 flags\np\t|void\t|hv_ename_delete|NN HV *hv|NN const char *name|U32 len \\\n\t\t\t\t|U32 flags\n: Used in dump.c and hv.c\npoM\t|AV**\t|hv_backreferences_p\t|NN HV *hv\n#if defined(PERL_IN_DUMP_C) || defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_SCOPE_C)\npoM\t|void\t|hv_kill_backrefs\t|NN HV *hv\n#endif\nApd\t|void\t|hv_clear_placeholders\t|NN HV *hv\nXpoR\t|SSize_t*|hv_placeholders_p\t|NN HV *hv\nApoR\t|I32\t|hv_placeholders_get\t|NN const HV *hv\nApo\t|void\t|hv_placeholders_set\t|NN HV *hv|I32 ph\n\n: This is indirectly referenced by globals.c. This is somewhat annoying.\np\t|SV*\t|magic_scalarpack|NN HV *hv|NN MAGIC *mg\n\n#if defined(PERL_IN_SV_C)\ns\t|SV *\t|find_hash_subscript|NULLOK const HV *const hv \\\n\t\t|NN const SV *const val\ns\t|SSize_t|find_array_subscript|NULLOK const AV *const av \\\n\t\t|NN const SV *const val\nsMd\t|SV*\t|find_uninit_var|NULLOK const OP *const obase \\\n\t\t|NULLOK const SV *const uninit_sv|bool match \\\n\t\t|NN const char **desc_p\n#endif\n\nAp\t|GV*\t|gv_fetchpvn_flags|NN const char* name|STRLEN len|I32 flags|const svtype sv_type\nAp\t|GV*\t|gv_fetchsv|NN SV *name|I32 flags|const svtype sv_type\n\n#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP\n: Used in sv.c\np\t|void\t|dump_sv_child\t|NN SV *sv\n#endif\n\n#ifdef PERL_DONT_CREATE_GVSV\nApbm\t|GV*\t|gv_SVadd\t|NULLOK GV *gv\n#endif\n#if defined(PERL_IN_UTIL_C)\ns\t|bool\t|ckwarn_common\t|U32 w\n#endif\nApoP\t|bool\t|ckwarn\t\t|U32 w\nApoP\t|bool\t|ckwarn_d\t|U32 w\n: FIXME - exported for ByteLoader - public or private?\nXEopMR\t|STRLEN *|new_warnings_bitfield|NULLOK STRLEN *buffer \\\n\t\t\t\t|NN const char *const bits|STRLEN size\n\nApnodf\t|int\t|my_snprintf\t|NN char *buffer|const Size_t len|NN const char *format|...\nApnod\t|int\t|my_vsnprintf\t|NN char *buffer|const Size_t len|NN const char *format|va_list ap\n#ifdef USE_QUADMATH\nApnd\t|const char*\t|quadmath_format_single|NN const char* format\nApnd\t|bool|quadmath_format_needed|NN const char* format\n#endif\n\n: Used in mg.c, sv.c\npx\t|void\t|my_clearenv\n\n#ifdef PERL_IMPLICIT_CONTEXT\n#ifdef PERL_GLOBAL_STRUCT_PRIVATE\nApo\t|void*\t|my_cxt_init\t|NN const char *my_cxt_key|size_t size\nApo\t|int\t|my_cxt_index\t|NN const char *my_cxt_key\n#else\nApo\t|void*\t|my_cxt_init\t|NN int *indexp|size_t size\n#endif\n#endif\n#if defined(PERL_IN_UTIL_C)\nso\t|void\t|xs_version_bootcheck|U32 items|U32 ax|NN const char *xs_p \\\n\t\t\t\t|STRLEN xs_len\n#endif\nXpon\t|I32\t|xs_handshake\t|const U32 key|NN void * v_my_perl\\\n\t\t\t\t|NN const char * file| ...\nXp\t|void\t|xs_boot_epilog\t|const I32 ax\n#ifndef HAS_STRLCAT\nApnod\t|Size_t\t|my_strlcat\t|NULLOK char *dst|NULLOK const char *src|Size_t size\n#endif\n\n#ifndef HAS_STRLCPY\nApnod\t|Size_t |my_strlcpy     |NULLOK char *dst|NULLOK const char *src|Size_t size\n#endif\n\n#ifndef HAS_STRNLEN\nApnod\t|Size_t |my_strnlen     |NN const char *str|Size_t maxlen\n#endif\n\n#ifndef HAS_MKOSTEMP\npno\t|int\t|my_mkostemp\t|NN char *templte|int flags\n#endif\n#ifndef HAS_MKSTEMP\npno\t|int\t|my_mkstemp\t|NN char *templte\n#endif\n\nAPpdn\t|bool\t|isinfnan\t|NV nv\np\t|bool\t|isinfnansv\t|NN SV *sv\n\n#if !defined(HAS_SIGNBIT)\nAMdnoP\t|int\t|Perl_signbit\t|NV f\n#endif\n\n: Used by B\nXEMop\t|void\t|emulate_cop_io\t|NN const COP *const c|NN SV *const sv\n: Used by SvRX and SvRXOK\nXEMop\t|REGEXP *|get_re_arg|NULLOK SV *sv\n\nAop\t|SV*\t|mro_get_private_data|NN struct mro_meta *const smeta \\\n\t\t\t\t     |NN const struct mro_alg *const which\nAop\t|SV*\t|mro_set_private_data|NN struct mro_meta *const smeta \\\n\t\t\t\t     |NN const struct mro_alg *const which \\\n\t\t\t\t     |NN SV *const data\nAop\t|const struct mro_alg *|mro_get_from_name|NN SV *name\nAop\t|void\t|mro_register\t|NN const struct mro_alg *mro\nAop\t|void\t|mro_set_mro\t|NN struct mro_meta *const meta \\\n\t\t\t\t|NN SV *const name\n: Used in HvMROMETA(), which is public.\nXpo\t|struct mro_meta*\t|mro_meta_init\t|NN HV* stash\n#if defined(USE_ITHREADS)\n: Only used in sv.c\np\t|struct mro_meta*\t|mro_meta_dup\t|NN struct mro_meta* smeta|NN CLONE_PARAMS* param\n#endif\nApd\t|AV*\t|mro_get_linear_isa|NN HV* stash\n#if defined(PERL_IN_MRO_C)\nsd\t|AV*\t|mro_get_linear_isa_dfs|NN HV* stash|U32 level\ns\t|void\t|mro_clean_isarev|NN HV * const isa   \\\n\t\t\t\t |NN const char * const name \\\n\t\t\t\t |const STRLEN len \\\n\t\t\t\t |NULLOK HV * const exceptions \\\n\t\t\t\t |U32 hash|U32 flags\ns\t|void\t|mro_gather_and_rename|NN HV * const stashes \\\n\t\t\t\t      |NN HV * const seen_stashes \\\n\t\t\t\t      |NULLOK HV *stash \\\n\t\t\t\t      |NULLOK HV *oldstash \\\n\t\t\t\t      |NN SV *namesv\n#endif\n: Used in hv.c, mg.c, pp.c, sv.c\npd\t|void   |mro_isa_changed_in|NN HV* stash\nApd\t|void\t|mro_method_changed_in\t|NN HV* stash\npdx\t|void\t|mro_package_moved\t|NULLOK HV * const stash|NULLOK HV * const oldstash|NN const GV * const gv|U32 flags\n: Only used in perl.c\np\t|void   |boot_core_mro\nApon\t|void\t|sys_init\t|NN int* argc|NN char*** argv\nApon\t|void\t|sys_init3\t|NN int* argc|NN char*** argv|NN char*** env\nApon\t|void\t|sys_term\nApoM\t|const char *|cop_fetch_label|NN COP *const cop \\\n\t\t|NULLOK STRLEN *len|NULLOK U32 *flags\n: Only used  in op.c and the perl compiler\nApoM\t|void|cop_store_label \\\n\t\t|NN COP *const cop|NN const char *label|STRLEN len|U32 flags\n\nxpo\t|int\t|keyword_plugin_standard|NN char* keyword_ptr|STRLEN keyword_len|NN OP** op_ptr\n\n#if defined(USE_ITHREADS)\n#  if defined(PERL_IN_SV_C)\ns\t|void\t|unreferenced_to_tmp_stack|NN AV *const unreferenced\n#  endif\nARnop\t|CLONE_PARAMS *|clone_params_new|NN PerlInterpreter *const from \\\n\t\t|NN PerlInterpreter *const to\nAnop\t|void\t|clone_params_del|NN CLONE_PARAMS *param\n#endif\n\n: Used in perl.c and toke.c\nop\t|void\t|populate_isa\t|NN const char *name|STRLEN len|...\n\n: Used in keywords.c and toke.c\nXop\t|bool\t|feature_is_enabled|NN const char *const name \\\n\t\t|STRLEN namelen\n\n: Some static inline functions need predeclaration because they are used\n: inside other static inline functions.\n#if defined(PERL_CORE) || defined (PERL_EXT)\nEi\t|STRLEN\t|sv_or_pv_pos_u2b|NN SV *sv|NN const char *pv|STRLEN pos \\\n\t\t\t\t |NULLOK STRLEN *lenp\n#endif\n\nAp\t|void\t|clear_defarray\t|NN AV* av|bool abandon\n\nApM\t|void\t|leave_adjust_stacks|NN SV **from_sp|NN SV **to_sp \\\n                |U8 gimme|int filter\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nAiM\t|PERL_CONTEXT *\t|cx_pushblock|U8 type|U8 gimme|NN SV** sp|I32 saveix\nAiM\t|void\t|cx_popblock|NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_topblock|NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_pushsub      |NN PERL_CONTEXT *cx|NN CV *cv \\\n\t\t\t\t |NULLOK OP *retop|bool hasargs\nAiM\t|void\t|cx_popsub_common|NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_popsub_args  |NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_popsub       |NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_pushformat   |NN PERL_CONTEXT *cx|NN CV *cv \\\n\t\t\t\t |NULLOK OP *retop|NULLOK GV *gv\nAiM\t|void\t|cx_popformat    |NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_pusheval     |NN PERL_CONTEXT *cx \\\n\t\t\t\t |NULLOK OP *retop|NULLOK SV *namesv\nAiM\t|void\t|cx_popeval      |NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_pushloop_plain|NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_pushloop_for |NN PERL_CONTEXT *cx \\\n\t\t\t\t |NN void *itervarp|NULLOK SV *itersave\nAiM\t|void\t|cx_poploop      |NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_pushwhen     |NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_popwhen      |NN PERL_CONTEXT *cx\nAiM\t|void\t|cx_pushgiven    |NN PERL_CONTEXT *cx|NULLOK SV *orig_defsv\nAiM\t|void\t|cx_popgiven     |NN PERL_CONTEXT *cx\n#endif\n\n#ifdef USE_DTRACE\nXEop\t|void   |dtrace_probe_call |NN CV *cv|bool is_call\nXEop\t|void   |dtrace_probe_load |NN const char *name|bool is_loading\nXEop\t|void   |dtrace_probe_op   |NN const OP *op\nXEop\t|void   |dtrace_probe_phase|enum perl_phase phase\n#endif\n\nXEop\t|STRLEN*|dup_warnings\t|NULLOK STRLEN* warnings\n\n: ex: set ts=8 sts=4 sw=4 noet:\n", "/* -*- buffer-read-only: t -*-\n *\n *    embed.h\n *\n *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others\n *\n *    You may distribute under the terms of either the GNU General Public\n *    License or the Artistic License, as specified in the README file.\n *\n * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n * This file is built by regen/embed.pl from data in embed.fnc,\n * regen/embed.pl, regen/opcodes, intrpvar.h and perlvars.h.\n * Any changes made here will be lost!\n *\n * Edit those files and run 'make regen_headers' to effect changes.\n */\n\n/* (Doing namespace management portably in C is really gross.) */\n\n/* By defining PERL_NO_SHORT_NAMES (not done by default) the short forms\n * (like warn instead of Perl_warn) for the API are not defined.\n * Not defining the short forms is a good thing for cleaner embedding. */\n\n#ifndef PERL_NO_SHORT_NAMES\n\n/* Hide global symbols */\n\n#define Gv_AMupdate(a,b)\tPerl_Gv_AMupdate(aTHX_ a,b)\n#define _force_out_malformed_utf8_message(a,b,c,d)\tPerl__force_out_malformed_utf8_message(aTHX_ a,b,c,d)\n#define _is_uni_FOO(a,b)\tPerl__is_uni_FOO(aTHX_ a,b)\n#define _is_uni_perl_idcont(a)\tPerl__is_uni_perl_idcont(aTHX_ a)\n#define _is_uni_perl_idstart(a)\tPerl__is_uni_perl_idstart(aTHX_ a)\n#define _is_utf8_FOO(a,b,c,d,e,f,g,h)\tPerl__is_utf8_FOO(aTHX_ a,b,c,d,e,f,g,h)\n#define _is_utf8_FOO_with_len(a,b,c)\tPerl__is_utf8_FOO_with_len(aTHX_ a,b,c)\n#define _is_utf8_char_helper\tPerl__is_utf8_char_helper\n#define _is_utf8_idcont(a)\tPerl__is_utf8_idcont(aTHX_ a)\n#define _is_utf8_idstart(a)\tPerl__is_utf8_idstart(aTHX_ a)\n#define _is_utf8_mark(a)\tPerl__is_utf8_mark(aTHX_ a)\n#define _is_utf8_perl_idcont_with_len(a,b)\tPerl__is_utf8_perl_idcont_with_len(aTHX_ a,b)\n#define _is_utf8_perl_idstart_with_len(a,b)\tPerl__is_utf8_perl_idstart_with_len(aTHX_ a,b)\n#define _is_utf8_xidcont(a)\tPerl__is_utf8_xidcont(aTHX_ a)\n#define _is_utf8_xidstart(a)\tPerl__is_utf8_xidstart(aTHX_ a)\n#define _to_uni_fold_flags(a,b,c,d)\tPerl__to_uni_fold_flags(aTHX_ a,b,c,d)\n#define _to_utf8_fold_flags(a,b,c,d,e,f,g)\tPerl__to_utf8_fold_flags(aTHX_ a,b,c,d,e,f,g)\n#define _to_utf8_lower_flags(a,b,c,d,e,f,g)\tPerl__to_utf8_lower_flags(aTHX_ a,b,c,d,e,f,g)\n#define _to_utf8_title_flags(a,b,c,d,e,f,g)\tPerl__to_utf8_title_flags(aTHX_ a,b,c,d,e,f,g)\n#define _to_utf8_upper_flags(a,b,c,d,e,f,g)\tPerl__to_utf8_upper_flags(aTHX_ a,b,c,d,e,f,g)\n#define _utf8n_to_uvchr_msgs_helper\tPerl__utf8n_to_uvchr_msgs_helper\n#define amagic_call(a,b,c,d)\tPerl_amagic_call(aTHX_ a,b,c,d)\n#define amagic_deref_call(a,b)\tPerl_amagic_deref_call(aTHX_ a,b)\n#define apply_attrs_string(a,b,c,d)\tPerl_apply_attrs_string(aTHX_ a,b,c,d)\n#define atfork_lock\t\tPerl_atfork_lock\n#define atfork_unlock\t\tPerl_atfork_unlock\n#define av_clear(a)\t\tPerl_av_clear(aTHX_ a)\n#define av_delete(a,b,c)\tPerl_av_delete(aTHX_ a,b,c)\n#define av_exists(a,b)\t\tPerl_av_exists(aTHX_ a,b)\n#define av_extend(a,b)\t\tPerl_av_extend(aTHX_ a,b)\n#define av_fetch(a,b,c)\t\tPerl_av_fetch(aTHX_ a,b,c)\n#define av_fill(a,b)\t\tPerl_av_fill(aTHX_ a,b)\n#define av_len(a)\t\tPerl_av_len(aTHX_ a)\n#define av_make(a,b)\t\tPerl_av_make(aTHX_ a,b)\n#define av_pop(a)\t\tPerl_av_pop(aTHX_ a)\n#define av_push(a,b)\t\tPerl_av_push(aTHX_ a,b)\n#define av_shift(a)\t\tPerl_av_shift(aTHX_ a)\n#define av_store(a,b,c)\t\tPerl_av_store(aTHX_ a,b,c)\n#define av_top_index(a)\t\tS_av_top_index(aTHX_ a)\n#define av_undef(a)\t\tPerl_av_undef(aTHX_ a)\n#define av_unshift(a,b)\t\tPerl_av_unshift(aTHX_ a,b)\n#define block_end(a,b)\t\tPerl_block_end(aTHX_ a,b)\n#define block_gimme()\t\tPerl_block_gimme(aTHX)\n#define block_start(a)\t\tPerl_block_start(aTHX_ a)\n#define bytes_cmp_utf8(a,b,c,d)\tPerl_bytes_cmp_utf8(aTHX_ a,b,c,d)\n#define bytes_from_utf8_loc\tPerl_bytes_from_utf8_loc\n#define bytes_to_utf8(a,b)\tPerl_bytes_to_utf8(aTHX_ a,b)\n#define call_argv(a,b,c)\tPerl_call_argv(aTHX_ a,b,c)\n#define call_atexit(a,b)\tPerl_call_atexit(aTHX_ a,b)\n#define call_list(a,b)\t\tPerl_call_list(aTHX_ a,b)\n#define call_method(a,b)\tPerl_call_method(aTHX_ a,b)\n#define call_pv(a,b)\t\tPerl_call_pv(aTHX_ a,b)\n#define call_sv(a,b)\t\tPerl_call_sv(aTHX_ a,b)\n#define caller_cx(a,b)\t\tPerl_caller_cx(aTHX_ a,b)\n#define cast_i32\t\tPerl_cast_i32\n#define cast_iv\t\t\tPerl_cast_iv\n#define cast_ulong\t\tPerl_cast_ulong\n#define cast_uv\t\t\tPerl_cast_uv\n#define ck_entersub_args_list(a)\tPerl_ck_entersub_args_list(aTHX_ a)\n#define ck_entersub_args_proto(a,b,c)\tPerl_ck_entersub_args_proto(aTHX_ a,b,c)\n#define ck_entersub_args_proto_or_list(a,b,c)\tPerl_ck_entersub_args_proto_or_list(aTHX_ a,b,c)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define ck_warner\t\tPerl_ck_warner\n#define ck_warner_d\t\tPerl_ck_warner_d\n#endif\n#define clear_defarray(a,b)\tPerl_clear_defarray(aTHX_ a,b)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define croak\t\t\tPerl_croak\n#endif\n#define croak_memory_wrap\tS_croak_memory_wrap\n#define croak_no_modify\t\tPerl_croak_no_modify\n#define croak_sv(a)\t\tPerl_croak_sv(aTHX_ a)\n#define croak_xs_usage\t\tPerl_croak_xs_usage\n#ifndef NO_MATHOMS\n#define custom_op_desc(a)\tPerl_custom_op_desc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define custom_op_name(a)\tPerl_custom_op_name(aTHX_ a)\n#endif\n#define cv_clone(a)\t\tPerl_cv_clone(aTHX_ a)\n#define cv_const_sv\t\tPerl_cv_const_sv\n#define cv_get_call_checker(a,b,c)\tPerl_cv_get_call_checker(aTHX_ a,b,c)\n#define cv_get_call_checker_flags(a,b,c,d,e)\tPerl_cv_get_call_checker_flags(aTHX_ a,b,c,d,e)\n#define cv_name(a,b,c)\t\tPerl_cv_name(aTHX_ a,b,c)\n#define cv_set_call_checker(a,b,c)\tPerl_cv_set_call_checker(aTHX_ a,b,c)\n#define cv_set_call_checker_flags(a,b,c,d)\tPerl_cv_set_call_checker_flags(aTHX_ a,b,c,d)\n#define cv_undef(a)\t\tPerl_cv_undef(aTHX_ a)\n#define cx_dump(a)\t\tPerl_cx_dump(aTHX_ a)\n#define cxinc()\t\t\tPerl_cxinc(aTHX)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define deb\t\t\tPerl_deb\n#endif\n#define debop(a)\t\tPerl_debop(aTHX_ a)\n#define debprofdump()\t\tPerl_debprofdump(aTHX)\n#define debstack()\t\tPerl_debstack(aTHX)\n#define debstackptrs()\t\tPerl_debstackptrs(aTHX)\n#define delimcpy\t\tPerl_delimcpy\n#define despatch_signals()\tPerl_despatch_signals(aTHX)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define die\t\t\tPerl_die\n#endif\n#define die_sv(a)\t\tPerl_die_sv(aTHX_ a)\n#ifndef NO_MATHOMS\n#define do_binmode(a,b,c)\tPerl_do_binmode(aTHX_ a,b,c)\n#endif\n#define do_close(a,b)\t\tPerl_do_close(aTHX_ a,b)\n#define do_gv_dump(a,b,c,d)\tPerl_do_gv_dump(aTHX_ a,b,c,d)\n#define do_gvgv_dump(a,b,c,d)\tPerl_do_gvgv_dump(aTHX_ a,b,c,d)\n#define do_hv_dump(a,b,c,d)\tPerl_do_hv_dump(aTHX_ a,b,c,d)\n#define do_join(a,b,c,d)\tPerl_do_join(aTHX_ a,b,c,d)\n#define do_magic_dump(a,b,c,d,e,f,g)\tPerl_do_magic_dump(aTHX_ a,b,c,d,e,f,g)\n#define do_op_dump(a,b,c)\tPerl_do_op_dump(aTHX_ a,b,c)\n#ifndef NO_MATHOMS\n#define do_open9(a,b,c,d,e,f,g,h,i)\tPerl_do_open9(aTHX_ a,b,c,d,e,f,g,h,i)\n#endif\n#define do_openn(a,b,c,d,e,f,g,h,i)\tPerl_do_openn(aTHX_ a,b,c,d,e,f,g,h,i)\n#define do_pmop_dump(a,b,c)\tPerl_do_pmop_dump(aTHX_ a,b,c)\n#define do_sprintf(a,b,c)\tPerl_do_sprintf(aTHX_ a,b,c)\n#define do_sv_dump(a,b,c,d,e,f,g)\tPerl_do_sv_dump(aTHX_ a,b,c,d,e,f,g)\n#define doing_taint\t\tPerl_doing_taint\n#define doref(a,b,c)\t\tPerl_doref(aTHX_ a,b,c)\n#define dounwind(a)\t\tPerl_dounwind(aTHX_ a)\n#define dowantarray()\t\tPerl_dowantarray(aTHX)\n#define dump_all()\t\tPerl_dump_all(aTHX)\n#define dump_eval()\t\tPerl_dump_eval(aTHX)\n#define dump_form(a)\t\tPerl_dump_form(aTHX_ a)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define dump_indent\t\tPerl_dump_indent\n#endif\n#define dump_packsubs(a)\tPerl_dump_packsubs(aTHX_ a)\n#define dump_sub(a)\t\tPerl_dump_sub(aTHX_ a)\n#define dump_vindent(a,b,c,d)\tPerl_dump_vindent(aTHX_ a,b,c,d)\n#define eval_pv(a,b)\t\tPerl_eval_pv(aTHX_ a,b)\n#define eval_sv(a,b)\t\tPerl_eval_sv(aTHX_ a,b)\n#define fbm_compile(a,b)\tPerl_fbm_compile(aTHX_ a,b)\n#define fbm_instr(a,b,c,d)\tPerl_fbm_instr(aTHX_ a,b,c,d)\n#define filter_add(a,b)\t\tPerl_filter_add(aTHX_ a,b)\n#define filter_del(a)\t\tPerl_filter_del(aTHX_ a)\n#define filter_read(a,b,c)\tPerl_filter_read(aTHX_ a,b,c)\n#define find_runcv(a)\t\tPerl_find_runcv(aTHX_ a)\n#define find_rundefsv()\t\tPerl_find_rundefsv(aTHX)\n#define find_rundefsvoffset()\tPerl_find_rundefsvoffset(aTHX)\n#define foldEQ\t\t\tPerl_foldEQ\n#define foldEQ_latin1\t\tPerl_foldEQ_latin1\n#define foldEQ_locale\t\tPerl_foldEQ_locale\n#define foldEQ_utf8_flags(a,b,c,d,e,f,g,h,i)\tPerl_foldEQ_utf8_flags(aTHX_ a,b,c,d,e,f,g,h,i)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define form\t\t\tPerl_form\n#endif\n#define free_tmps()\t\tPerl_free_tmps(aTHX)\n#define get_av(a,b)\t\tPerl_get_av(aTHX_ a,b)\n#define get_context\t\tPerl_get_context\n#define get_cv(a,b)\t\tPerl_get_cv(aTHX_ a,b)\n#define get_cvn_flags(a,b,c)\tPerl_get_cvn_flags(aTHX_ a,b,c)\n#define get_hv(a,b)\t\tPerl_get_hv(aTHX_ a,b)\n#define get_op_descs()\t\tPerl_get_op_descs(aTHX)\n#define get_op_names()\t\tPerl_get_op_names(aTHX)\n#define get_ppaddr()\t\tPerl_get_ppaddr(aTHX)\n#define get_sv(a,b)\t\tPerl_get_sv(aTHX_ a,b)\n#define get_vtbl(a)\t\tPerl_get_vtbl(aTHX_ a)\n#define getcwd_sv(a)\t\tPerl_getcwd_sv(aTHX_ a)\n#define gp_free(a)\t\tPerl_gp_free(aTHX_ a)\n#define gp_ref(a)\t\tPerl_gp_ref(aTHX_ a)\n#define grok_bin(a,b,c,d)\tPerl_grok_bin(aTHX_ a,b,c,d)\n#define grok_hex(a,b,c,d)\tPerl_grok_hex(aTHX_ a,b,c,d)\n#define grok_infnan(a,b)\tPerl_grok_infnan(aTHX_ a,b)\n#define grok_number(a,b,c)\tPerl_grok_number(aTHX_ a,b,c)\n#define grok_number_flags(a,b,c,d)\tPerl_grok_number_flags(aTHX_ a,b,c,d)\n#define grok_numeric_radix(a,b)\tPerl_grok_numeric_radix(aTHX_ a,b)\n#define grok_oct(a,b,c,d)\tPerl_grok_oct(aTHX_ a,b,c,d)\n#define gv_add_by_type(a,b)\tPerl_gv_add_by_type(aTHX_ a,b)\n#define gv_autoload_pv(a,b,c)\tPerl_gv_autoload_pv(aTHX_ a,b,c)\n#define gv_autoload_pvn(a,b,c,d)\tPerl_gv_autoload_pvn(aTHX_ a,b,c,d)\n#define gv_autoload_sv(a,b,c)\tPerl_gv_autoload_sv(aTHX_ a,b,c)\n#define gv_check(a)\t\tPerl_gv_check(aTHX_ a)\n#define gv_const_sv(a)\t\tPerl_gv_const_sv(aTHX_ a)\n#define gv_dump(a)\t\tPerl_gv_dump(aTHX_ a)\n#ifndef NO_MATHOMS\n#define gv_efullname(a,b)\tPerl_gv_efullname(aTHX_ a,b)\n#endif\n#define gv_efullname4(a,b,c,d)\tPerl_gv_efullname4(aTHX_ a,b,c,d)\n#define gv_fetchfile(a)\t\tPerl_gv_fetchfile(aTHX_ a)\n#define gv_fetchfile_flags(a,b,c)\tPerl_gv_fetchfile_flags(aTHX_ a,b,c)\n#define gv_fetchmeth_pv(a,b,c,d)\tPerl_gv_fetchmeth_pv(aTHX_ a,b,c,d)\n#define gv_fetchmeth_pv_autoload(a,b,c,d)\tPerl_gv_fetchmeth_pv_autoload(aTHX_ a,b,c,d)\n#define gv_fetchmeth_pvn(a,b,c,d,e)\tPerl_gv_fetchmeth_pvn(aTHX_ a,b,c,d,e)\n#define gv_fetchmeth_pvn_autoload(a,b,c,d,e)\tPerl_gv_fetchmeth_pvn_autoload(aTHX_ a,b,c,d,e)\n#define gv_fetchmeth_sv(a,b,c,d)\tPerl_gv_fetchmeth_sv(aTHX_ a,b,c,d)\n#define gv_fetchmeth_sv_autoload(a,b,c,d)\tPerl_gv_fetchmeth_sv_autoload(aTHX_ a,b,c,d)\n#define gv_fetchmethod_autoload(a,b,c)\tPerl_gv_fetchmethod_autoload(aTHX_ a,b,c)\n#define gv_fetchmethod_pv_flags(a,b,c)\tPerl_gv_fetchmethod_pv_flags(aTHX_ a,b,c)\n#define gv_fetchmethod_pvn_flags(a,b,c,d)\tPerl_gv_fetchmethod_pvn_flags(aTHX_ a,b,c,d)\n#define gv_fetchmethod_sv_flags(a,b,c)\tPerl_gv_fetchmethod_sv_flags(aTHX_ a,b,c)\n#define gv_fetchpv(a,b,c)\tPerl_gv_fetchpv(aTHX_ a,b,c)\n#define gv_fetchpvn_flags(a,b,c,d)\tPerl_gv_fetchpvn_flags(aTHX_ a,b,c,d)\n#define gv_fetchsv(a,b,c)\tPerl_gv_fetchsv(aTHX_ a,b,c)\n#ifndef NO_MATHOMS\n#define gv_fullname(a,b)\tPerl_gv_fullname(aTHX_ a,b)\n#endif\n#define gv_fullname4(a,b,c,d)\tPerl_gv_fullname4(aTHX_ a,b,c,d)\n#define gv_handler(a,b)\t\tPerl_gv_handler(aTHX_ a,b)\n#define gv_init_pv(a,b,c,d)\tPerl_gv_init_pv(aTHX_ a,b,c,d)\n#define gv_init_pvn(a,b,c,d,e)\tPerl_gv_init_pvn(aTHX_ a,b,c,d,e)\n#define gv_init_sv(a,b,c,d)\tPerl_gv_init_sv(aTHX_ a,b,c,d)\n#define gv_name_set(a,b,c,d)\tPerl_gv_name_set(aTHX_ a,b,c,d)\n#define gv_stashpv(a,b)\t\tPerl_gv_stashpv(aTHX_ a,b)\n#define gv_stashpvn(a,b,c)\tPerl_gv_stashpvn(aTHX_ a,b,c)\n#define gv_stashsv(a,b)\t\tPerl_gv_stashsv(aTHX_ a,b)\n#define hv_bucket_ratio(a)\tPerl_hv_bucket_ratio(aTHX_ a)\n#define hv_clear(a)\t\tPerl_hv_clear(aTHX_ a)\n#define hv_clear_placeholders(a)\tPerl_hv_clear_placeholders(aTHX_ a)\n#define hv_common(a,b,c,d,e,f,g,h)\tPerl_hv_common(aTHX_ a,b,c,d,e,f,g,h)\n#define hv_common_key_len(a,b,c,d,e,f)\tPerl_hv_common_key_len(aTHX_ a,b,c,d,e,f)\n#define hv_copy_hints_hv(a)\tPerl_hv_copy_hints_hv(aTHX_ a)\n#define hv_delayfree_ent(a,b)\tPerl_hv_delayfree_ent(aTHX_ a,b)\n#define hv_free_ent(a,b)\tPerl_hv_free_ent(aTHX_ a,b)\n#define hv_iterinit(a)\t\tPerl_hv_iterinit(aTHX_ a)\n#define hv_iterkey(a,b)\t\tPerl_hv_iterkey(aTHX_ a,b)\n#define hv_iterkeysv(a)\t\tPerl_hv_iterkeysv(aTHX_ a)\n#define hv_iternext_flags(a,b)\tPerl_hv_iternext_flags(aTHX_ a,b)\n#define hv_iternextsv(a,b,c)\tPerl_hv_iternextsv(aTHX_ a,b,c)\n#define hv_iterval(a,b)\t\tPerl_hv_iterval(aTHX_ a,b)\n#define hv_ksplit(a,b)\t\tPerl_hv_ksplit(aTHX_ a,b)\n#define hv_name_set(a,b,c,d)\tPerl_hv_name_set(aTHX_ a,b,c,d)\n#define hv_rand_set(a,b)\tPerl_hv_rand_set(aTHX_ a,b)\n#define hv_scalar(a)\t\tPerl_hv_scalar(aTHX_ a)\n#define init_i18nl10n(a)\tPerl_init_i18nl10n(aTHX_ a)\n#ifndef NO_MATHOMS\n#define init_i18nl14n(a)\tPerl_init_i18nl14n(aTHX_ a)\n#endif\n#define init_stacks()\t\tPerl_init_stacks(aTHX)\n#define init_tm(a)\t\tPerl_init_tm(aTHX_ a)\n#define intro_my()\t\tPerl_intro_my(aTHX)\n#ifndef NO_MATHOMS\n#define isALNUM_lazy(a)\t\tPerl_isALNUM_lazy(aTHX_ a)\n#endif\n#define isC9_STRICT_UTF8_CHAR\tS_isC9_STRICT_UTF8_CHAR\n#ifndef NO_MATHOMS\n#define isIDFIRST_lazy(a)\tPerl_isIDFIRST_lazy(aTHX_ a)\n#endif\n#define isSTRICT_UTF8_CHAR\tS_isSTRICT_UTF8_CHAR\n#define isUTF8_CHAR\t\tS_isUTF8_CHAR\n#define is_c9strict_utf8_string_loclen\tS_is_c9strict_utf8_string_loclen\n#define is_lvalue_sub()\t\tPerl_is_lvalue_sub(aTHX)\n#define is_safe_syscall(a,b,c,d)\tS_is_safe_syscall(aTHX_ a,b,c,d)\n#define is_strict_utf8_string_loclen\tS_is_strict_utf8_string_loclen\n#ifndef NO_MATHOMS\n#define is_uni_alnum(a)\t\tPerl_is_uni_alnum(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_alnum_lc(a)\tPerl_is_uni_alnum_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_alnumc(a)\tPerl_is_uni_alnumc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_alnumc_lc(a)\tPerl_is_uni_alnumc_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_alpha(a)\t\tPerl_is_uni_alpha(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_alpha_lc(a)\tPerl_is_uni_alpha_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_ascii(a)\t\tPerl_is_uni_ascii(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_ascii_lc(a)\tPerl_is_uni_ascii_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_blank(a)\t\tPerl_is_uni_blank(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_blank_lc(a)\tPerl_is_uni_blank_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_cntrl(a)\t\tPerl_is_uni_cntrl(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_cntrl_lc(a)\tPerl_is_uni_cntrl_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_digit(a)\t\tPerl_is_uni_digit(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_digit_lc(a)\tPerl_is_uni_digit_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_graph(a)\t\tPerl_is_uni_graph(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_graph_lc(a)\tPerl_is_uni_graph_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_idfirst(a)\tPerl_is_uni_idfirst(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_idfirst_lc(a)\tPerl_is_uni_idfirst_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_lower(a)\t\tPerl_is_uni_lower(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_lower_lc(a)\tPerl_is_uni_lower_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_print(a)\t\tPerl_is_uni_print(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_print_lc(a)\tPerl_is_uni_print_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_punct(a)\t\tPerl_is_uni_punct(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_punct_lc(a)\tPerl_is_uni_punct_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_space(a)\t\tPerl_is_uni_space(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_space_lc(a)\tPerl_is_uni_space_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_upper(a)\t\tPerl_is_uni_upper(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_upper_lc(a)\tPerl_is_uni_upper_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_xdigit(a)\tPerl_is_uni_xdigit(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_uni_xdigit_lc(a)\tPerl_is_uni_xdigit_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_alnum(a)\tPerl_is_utf8_alnum(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_alnumc(a)\tPerl_is_utf8_alnumc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_alpha(a)\tPerl_is_utf8_alpha(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_ascii(a)\tPerl_is_utf8_ascii(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_blank(a)\tPerl_is_utf8_blank(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_char\t\tPerl_is_utf8_char\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_cntrl(a)\tPerl_is_utf8_cntrl(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_digit(a)\tPerl_is_utf8_digit(aTHX_ a)\n#endif\n#define is_utf8_fixed_width_buf_loclen_flags\tS_is_utf8_fixed_width_buf_loclen_flags\n#ifndef NO_MATHOMS\n#define is_utf8_graph(a)\tPerl_is_utf8_graph(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_idcont(a)\tPerl_is_utf8_idcont(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_idfirst(a)\tPerl_is_utf8_idfirst(aTHX_ a)\n#endif\n#define is_utf8_invariant_string_loc\tS_is_utf8_invariant_string_loc\n#ifndef NO_MATHOMS\n#define is_utf8_lower(a)\tPerl_is_utf8_lower(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_mark(a)\t\tPerl_is_utf8_mark(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_perl_space(a)\tPerl_is_utf8_perl_space(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_perl_word(a)\tPerl_is_utf8_perl_word(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_posix_digit(a)\tPerl_is_utf8_posix_digit(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_print(a)\tPerl_is_utf8_print(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_punct(a)\tPerl_is_utf8_punct(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_space(a)\tPerl_is_utf8_space(aTHX_ a)\n#endif\n#define is_utf8_string_flags\tS_is_utf8_string_flags\n#define is_utf8_string_loclen\tPerl_is_utf8_string_loclen\n#define is_utf8_string_loclen_flags\tS_is_utf8_string_loclen_flags\n#ifndef NO_MATHOMS\n#define is_utf8_upper(a)\tPerl_is_utf8_upper(aTHX_ a)\n#endif\n#define is_utf8_valid_partial_char_flags\tS_is_utf8_valid_partial_char_flags\n#ifndef NO_MATHOMS\n#define is_utf8_xdigit(a)\tPerl_is_utf8_xdigit(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_xidcont(a)\tPerl_is_utf8_xidcont(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define is_utf8_xidfirst(a)\tPerl_is_utf8_xidfirst(aTHX_ a)\n#endif\n#define isinfnan\t\tPerl_isinfnan\n#define leave_adjust_stacks(a,b,c,d)\tPerl_leave_adjust_stacks(aTHX_ a,b,c,d)\n#define leave_scope(a)\t\tPerl_leave_scope(aTHX_ a)\n#define lex_bufutf8()\t\tPerl_lex_bufutf8(aTHX)\n#define lex_discard_to(a)\tPerl_lex_discard_to(aTHX_ a)\n#define lex_grow_linestr(a)\tPerl_lex_grow_linestr(aTHX_ a)\n#define lex_next_chunk(a)\tPerl_lex_next_chunk(aTHX_ a)\n#define lex_peek_unichar(a)\tPerl_lex_peek_unichar(aTHX_ a)\n#define lex_read_space(a)\tPerl_lex_read_space(aTHX_ a)\n#define lex_read_to(a)\t\tPerl_lex_read_to(aTHX_ a)\n#define lex_read_unichar(a)\tPerl_lex_read_unichar(aTHX_ a)\n#define lex_start(a,b,c)\tPerl_lex_start(aTHX_ a,b,c)\n#define lex_stuff_pv(a,b)\tPerl_lex_stuff_pv(aTHX_ a,b)\n#define lex_stuff_pvn(a,b,c)\tPerl_lex_stuff_pvn(aTHX_ a,b,c)\n#define lex_stuff_sv(a,b)\tPerl_lex_stuff_sv(aTHX_ a,b)\n#define lex_unstuff(a)\t\tPerl_lex_unstuff(aTHX_ a)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define load_module\t\tPerl_load_module\n#endif\n#define looks_like_number(a)\tPerl_looks_like_number(aTHX_ a)\n#define magic_dump(a)\t\tPerl_magic_dump(aTHX_ a)\n#define markstack_grow()\tPerl_markstack_grow(aTHX)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define mess\t\t\tPerl_mess\n#endif\n#define mess_sv(a,b)\t\tPerl_mess_sv(aTHX_ a,b)\n#define mg_clear(a)\t\tPerl_mg_clear(aTHX_ a)\n#define mg_copy(a,b,c,d)\tPerl_mg_copy(aTHX_ a,b,c,d)\n#define mg_find\t\t\tPerl_mg_find\n#define mg_findext\t\tPerl_mg_findext\n#define mg_free(a)\t\tPerl_mg_free(aTHX_ a)\n#define mg_free_type(a,b)\tPerl_mg_free_type(aTHX_ a,b)\n#define mg_freeext(a,b,c)\tPerl_mg_freeext(aTHX_ a,b,c)\n#define mg_get(a)\t\tPerl_mg_get(aTHX_ a)\n#define mg_length(a)\t\tPerl_mg_length(aTHX_ a)\n#define mg_magical\t\tPerl_mg_magical\n#define mg_set(a)\t\tPerl_mg_set(aTHX_ a)\n#define mg_size(a)\t\tPerl_mg_size(aTHX_ a)\n#define mini_mktime\t\tPerl_mini_mktime\n#define moreswitches(a)\t\tPerl_moreswitches(aTHX_ a)\n#define mro_get_linear_isa(a)\tPerl_mro_get_linear_isa(aTHX_ a)\n#define mro_method_changed_in(a)\tPerl_mro_method_changed_in(aTHX_ a)\n#define my_atof(a)\t\tPerl_my_atof(aTHX_ a)\n#define my_atof3(a,b,c)\t\tPerl_my_atof3(aTHX_ a,b,c)\n#define my_dirfd\t\tPerl_my_dirfd\n#define my_exit(a)\t\tPerl_my_exit(aTHX_ a)\n#define my_failure_exit()\tPerl_my_failure_exit(aTHX)\n#define my_fflush_all()\t\tPerl_my_fflush_all(aTHX)\n#define my_fork\t\t\tPerl_my_fork\n#define my_popen_list(a,b,c)\tPerl_my_popen_list(aTHX_ a,b,c)\n#define my_setenv(a,b)\t\tPerl_my_setenv(aTHX_ a,b)\n#define my_socketpair\t\tPerl_my_socketpair\n#define my_strftime(a,b,c,d,e,f,g,h,i,j)\tPerl_my_strftime(aTHX_ a,b,c,d,e,f,g,h,i,j)\n#define my_strtod\t\tPerl_my_strtod\n#define newANONATTRSUB(a,b,c,d)\tPerl_newANONATTRSUB(aTHX_ a,b,c,d)\n#define newANONHASH(a)\t\tPerl_newANONHASH(aTHX_ a)\n#define newANONLIST(a)\t\tPerl_newANONLIST(aTHX_ a)\n#define newANONSUB(a,b,c)\tPerl_newANONSUB(aTHX_ a,b,c)\n#define newASSIGNOP(a,b,c,d)\tPerl_newASSIGNOP(aTHX_ a,b,c,d)\n#define newAVREF(a)\t\tPerl_newAVREF(aTHX_ a)\n#define newBINOP(a,b,c,d)\tPerl_newBINOP(aTHX_ a,b,c,d)\n#define newCONDOP(a,b,c,d)\tPerl_newCONDOP(aTHX_ a,b,c,d)\n#define newCONSTSUB(a,b,c)\tPerl_newCONSTSUB(aTHX_ a,b,c)\n#define newCONSTSUB_flags(a,b,c,d,e)\tPerl_newCONSTSUB_flags(aTHX_ a,b,c,d,e)\n#define newCVREF(a,b)\t\tPerl_newCVREF(aTHX_ a,b)\n#define newDEFSVOP()\t\tPerl_newDEFSVOP(aTHX)\n#define newFORM(a,b,c)\t\tPerl_newFORM(aTHX_ a,b,c)\n#define newFOROP(a,b,c,d,e)\tPerl_newFOROP(aTHX_ a,b,c,d,e)\n#define newGIVENOP(a,b,c)\tPerl_newGIVENOP(aTHX_ a,b,c)\n#define newGVOP(a,b,c)\t\tPerl_newGVOP(aTHX_ a,b,c)\n#define newGVREF(a,b)\t\tPerl_newGVREF(aTHX_ a,b)\n#define newGVgen_flags(a,b)\tPerl_newGVgen_flags(aTHX_ a,b)\n#define newHVREF(a)\t\tPerl_newHVREF(aTHX_ a)\n#define newHVhv(a)\t\tPerl_newHVhv(aTHX_ a)\n#define newLISTOP(a,b,c,d)\tPerl_newLISTOP(aTHX_ a,b,c,d)\n#define newLOGOP(a,b,c,d)\tPerl_newLOGOP(aTHX_ a,b,c,d)\n#define newLOOPEX(a,b)\t\tPerl_newLOOPEX(aTHX_ a,b)\n#define newLOOPOP(a,b,c,d)\tPerl_newLOOPOP(aTHX_ a,b,c,d)\n#define newMETHOP(a,b,c)\tPerl_newMETHOP(aTHX_ a,b,c)\n#define newMETHOP_named(a,b,c)\tPerl_newMETHOP_named(aTHX_ a,b,c)\n#define newMYSUB(a,b,c,d,e)\tPerl_newMYSUB(aTHX_ a,b,c,d,e)\n#define newNULLLIST()\t\tPerl_newNULLLIST(aTHX)\n#define newOP(a,b)\t\tPerl_newOP(aTHX_ a,b)\n#define newPADNAMELIST\t\tPerl_newPADNAMELIST\n#define newPADNAMEouter\t\tPerl_newPADNAMEouter\n#define newPADNAMEpvn\t\tPerl_newPADNAMEpvn\n#define newPMOP(a,b)\t\tPerl_newPMOP(aTHX_ a,b)\n#define newPROG(a)\t\tPerl_newPROG(aTHX_ a)\n#define newPVOP(a,b,c)\t\tPerl_newPVOP(aTHX_ a,b,c)\n#define newRANGE(a,b,c)\t\tPerl_newRANGE(aTHX_ a,b,c)\n#define newRV(a)\t\tPerl_newRV(aTHX_ a)\n#define newRV_noinc(a)\t\tPerl_newRV_noinc(aTHX_ a)\n#define newSLICEOP(a,b,c)\tPerl_newSLICEOP(aTHX_ a,b,c)\n#define newSTATEOP(a,b,c)\tPerl_newSTATEOP(aTHX_ a,b,c)\n#define newSV(a)\t\tPerl_newSV(aTHX_ a)\n#define newSVOP(a,b,c)\t\tPerl_newSVOP(aTHX_ a,b,c)\n#define newSVREF(a)\t\tPerl_newSVREF(aTHX_ a)\n#define newSV_type(a)\t\tPerl_newSV_type(aTHX_ a)\n#define newSVhek(a)\t\tPerl_newSVhek(aTHX_ a)\n#define newSViv(a)\t\tPerl_newSViv(aTHX_ a)\n#define newSVnv(a)\t\tPerl_newSVnv(aTHX_ a)\n#define newSVpv(a,b)\t\tPerl_newSVpv(aTHX_ a,b)\n#define newSVpv_share(a,b)\tPerl_newSVpv_share(aTHX_ a,b)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define newSVpvf\t\tPerl_newSVpvf\n#endif\n#define newSVpvn(a,b)\t\tPerl_newSVpvn(aTHX_ a,b)\n#define newSVpvn_flags(a,b,c)\tPerl_newSVpvn_flags(aTHX_ a,b,c)\n#define newSVpvn_share(a,b,c)\tPerl_newSVpvn_share(aTHX_ a,b,c)\n#define newSVrv(a,b)\t\tPerl_newSVrv(aTHX_ a,b)\n#define newSVsv_flags(a,b)\tPerl_newSVsv_flags(aTHX_ a,b)\n#define newSVuv(a)\t\tPerl_newSVuv(aTHX_ a)\n#define newUNOP(a,b,c)\t\tPerl_newUNOP(aTHX_ a,b,c)\n#define newUNOP_AUX(a,b,c,d)\tPerl_newUNOP_AUX(aTHX_ a,b,c,d)\n#define newWHENOP(a,b)\t\tPerl_newWHENOP(aTHX_ a,b)\n#define newWHILEOP(a,b,c,d,e,f,g)\tPerl_newWHILEOP(aTHX_ a,b,c,d,e,f,g)\n#define newXS(a,b,c)\t\tPerl_newXS(aTHX_ a,b,c)\n#define newXS_flags(a,b,c,d,e)\tPerl_newXS_flags(aTHX_ a,b,c,d,e)\n#define new_stackinfo(a,b)\tPerl_new_stackinfo(aTHX_ a,b)\n#define new_version(a)\t\tPerl_new_version(aTHX_ a)\n#define nothreadhook()\t\tPerl_nothreadhook(aTHX)\n#define op_append_elem(a,b,c)\tPerl_op_append_elem(aTHX_ a,b,c)\n#define op_append_list(a,b,c)\tPerl_op_append_list(aTHX_ a,b,c)\n#define op_class(a)\t\tPerl_op_class(aTHX_ a)\n#define op_contextualize(a,b)\tPerl_op_contextualize(aTHX_ a,b)\n#define op_convert_list(a,b,c)\tPerl_op_convert_list(aTHX_ a,b,c)\n#define op_dump(a)\t\tPerl_op_dump(aTHX_ a)\n#define op_free(a)\t\tPerl_op_free(aTHX_ a)\n#define op_linklist(a)\t\tPerl_op_linklist(aTHX_ a)\n#define op_null(a)\t\tPerl_op_null(aTHX_ a)\n#define op_parent\t\tPerl_op_parent\n#define op_prepend_elem(a,b,c)\tPerl_op_prepend_elem(aTHX_ a,b,c)\n#define op_refcnt_lock()\tPerl_op_refcnt_lock(aTHX)\n#define op_refcnt_unlock()\tPerl_op_refcnt_unlock(aTHX)\n#define op_scope(a)\t\tPerl_op_scope(aTHX_ a)\n#define op_sibling_splice\tPerl_op_sibling_splice\n#ifndef NO_MATHOMS\n#define pack_cat(a,b,c,d,e,f,g)\tPerl_pack_cat(aTHX_ a,b,c,d,e,f,g)\n#endif\n#define packlist(a,b,c,d,e)\tPerl_packlist(aTHX_ a,b,c,d,e)\n#define pad_add_anon(a,b)\tPerl_pad_add_anon(aTHX_ a,b)\n#define pad_add_name_pv(a,b,c,d)\tPerl_pad_add_name_pv(aTHX_ a,b,c,d)\n#define pad_add_name_pvn(a,b,c,d,e)\tPerl_pad_add_name_pvn(aTHX_ a,b,c,d,e)\n#define pad_add_name_sv(a,b,c,d)\tPerl_pad_add_name_sv(aTHX_ a,b,c,d)\n#define pad_alloc(a,b)\t\tPerl_pad_alloc(aTHX_ a,b)\n#ifndef NO_MATHOMS\n#define pad_compname_type(a)\tPerl_pad_compname_type(aTHX_ a)\n#endif\n#define pad_findmy_pv(a,b)\tPerl_pad_findmy_pv(aTHX_ a,b)\n#define pad_findmy_pvn(a,b,c)\tPerl_pad_findmy_pvn(aTHX_ a,b,c)\n#define pad_findmy_sv(a,b)\tPerl_pad_findmy_sv(aTHX_ a,b)\n#define pad_new(a)\t\tPerl_pad_new(aTHX_ a)\n#define pad_tidy(a)\t\tPerl_pad_tidy(aTHX_ a)\n#define padnamelist_fetch\tPerl_padnamelist_fetch\n#define padnamelist_store(a,b,c)\tPerl_padnamelist_store(aTHX_ a,b,c)\n#define parse_arithexpr(a)\tPerl_parse_arithexpr(aTHX_ a)\n#define parse_barestmt(a)\tPerl_parse_barestmt(aTHX_ a)\n#define parse_block(a)\t\tPerl_parse_block(aTHX_ a)\n#define parse_fullexpr(a)\tPerl_parse_fullexpr(aTHX_ a)\n#define parse_fullstmt(a)\tPerl_parse_fullstmt(aTHX_ a)\n#define parse_label(a)\t\tPerl_parse_label(aTHX_ a)\n#define parse_listexpr(a)\tPerl_parse_listexpr(aTHX_ a)\n#define parse_stmtseq(a)\tPerl_parse_stmtseq(aTHX_ a)\n#define parse_termexpr(a)\tPerl_parse_termexpr(aTHX_ a)\n#define pmop_dump(a)\t\tPerl_pmop_dump(aTHX_ a)\n#define pop_scope()\t\tPerl_pop_scope(aTHX)\n#define pregcomp(a,b)\t\tPerl_pregcomp(aTHX_ a,b)\n#define pregexec(a,b,c,d,e,f,g)\tPerl_pregexec(aTHX_ a,b,c,d,e,f,g)\n#define pregfree(a)\t\tPerl_pregfree(aTHX_ a)\n#define pregfree2(a)\t\tPerl_pregfree2(aTHX_ a)\n#define prescan_version(a,b,c,d,e,f,g)\tPerl_prescan_version(aTHX_ a,b,c,d,e,f,g)\n#define ptr_table_clear(a)\tPerl_ptr_table_clear(aTHX_ a)\n#define ptr_table_fetch(a,b)\tPerl_ptr_table_fetch(aTHX_ a,b)\n#define ptr_table_free(a)\tPerl_ptr_table_free(aTHX_ a)\n#define ptr_table_new()\t\tPerl_ptr_table_new(aTHX)\n#define ptr_table_split(a)\tPerl_ptr_table_split(aTHX_ a)\n#define ptr_table_store(a,b,c)\tPerl_ptr_table_store(aTHX_ a,b,c)\n#define push_scope()\t\tPerl_push_scope(aTHX)\n#define pv_display(a,b,c,d,e)\tPerl_pv_display(aTHX_ a,b,c,d,e)\n#define pv_escape(a,b,c,d,e,f)\tPerl_pv_escape(aTHX_ a,b,c,d,e,f)\n#define pv_pretty(a,b,c,d,e,f,g)\tPerl_pv_pretty(aTHX_ a,b,c,d,e,f,g)\n#define pv_uni_display(a,b,c,d,e)\tPerl_pv_uni_display(aTHX_ a,b,c,d,e)\n#define re_compile(a,b)\t\tPerl_re_compile(aTHX_ a,b)\n#define re_intuit_start(a,b,c,d,e,f,g)\tPerl_re_intuit_start(aTHX_ a,b,c,d,e,f,g)\n#define re_intuit_string(a)\tPerl_re_intuit_string(aTHX_ a)\n#define reentrant_free()\tPerl_reentrant_free(aTHX)\n#define reentrant_init()\tPerl_reentrant_init(aTHX)\n#define reentrant_retry\t\tPerl_reentrant_retry\n#define reentrant_size()\tPerl_reentrant_size(aTHX)\n#define reg_named_buff_all(a,b)\tPerl_reg_named_buff_all(aTHX_ a,b)\n#define reg_named_buff_exists(a,b,c)\tPerl_reg_named_buff_exists(aTHX_ a,b,c)\n#define reg_named_buff_fetch(a,b,c)\tPerl_reg_named_buff_fetch(aTHX_ a,b,c)\n#define reg_named_buff_firstkey(a,b)\tPerl_reg_named_buff_firstkey(aTHX_ a,b)\n#define reg_named_buff_nextkey(a,b)\tPerl_reg_named_buff_nextkey(aTHX_ a,b)\n#define reg_named_buff_scalar(a,b)\tPerl_reg_named_buff_scalar(aTHX_ a,b)\n#define regdump(a)\t\tPerl_regdump(aTHX_ a)\n#define regexec_flags(a,b,c,d,e,f,g,h)\tPerl_regexec_flags(aTHX_ a,b,c,d,e,f,g,h)\n#define regfree_internal(a)\tPerl_regfree_internal(aTHX_ a)\n#define reginitcolors()\t\tPerl_reginitcolors(aTHX)\n#define regnext(a)\t\tPerl_regnext(aTHX_ a)\n#define repeatcpy\t\tPerl_repeatcpy\n#define require_pv(a)\t\tPerl_require_pv(aTHX_ a)\n#define rninstr\t\t\tPerl_rninstr\n#define rsignal(a,b)\t\tPerl_rsignal(aTHX_ a,b)\n#define rsignal_state(a)\tPerl_rsignal_state(aTHX_ a)\n#define runops_debug()\t\tPerl_runops_debug(aTHX)\n#define runops_standard()\tPerl_runops_standard(aTHX)\n#define rv2cv_op_cv(a,b)\tPerl_rv2cv_op_cv(aTHX_ a,b)\n#define safesyscalloc\t\tPerl_safesyscalloc\n#define safesysfree\t\tPerl_safesysfree\n#define safesysmalloc\t\tPerl_safesysmalloc\n#define safesysrealloc\t\tPerl_safesysrealloc\n#define save_I16(a)\t\tPerl_save_I16(aTHX_ a)\n#define save_I32(a)\t\tPerl_save_I32(aTHX_ a)\n#define save_I8(a)\t\tPerl_save_I8(aTHX_ a)\n#define save_adelete(a,b)\tPerl_save_adelete(aTHX_ a,b)\n#define save_aelem_flags(a,b,c,d)\tPerl_save_aelem_flags(aTHX_ a,b,c,d)\n#define save_alloc(a,b)\t\tPerl_save_alloc(aTHX_ a,b)\n#define save_aptr(a)\t\tPerl_save_aptr(aTHX_ a)\n#define save_ary(a)\t\tPerl_save_ary(aTHX_ a)\n#define save_bool(a)\t\tPerl_save_bool(aTHX_ a)\n#define save_clearsv(a)\t\tPerl_save_clearsv(aTHX_ a)\n#define save_delete(a,b,c)\tPerl_save_delete(aTHX_ a,b,c)\n#define save_destructor(a,b)\tPerl_save_destructor(aTHX_ a,b)\n#define save_destructor_x(a,b)\tPerl_save_destructor_x(aTHX_ a,b)\n#define save_generic_pvref(a)\tPerl_save_generic_pvref(aTHX_ a)\n#define save_generic_svref(a)\tPerl_save_generic_svref(aTHX_ a)\n#define save_gp(a,b)\t\tPerl_save_gp(aTHX_ a,b)\n#define save_hash(a)\t\tPerl_save_hash(aTHX_ a)\n#define save_hdelete(a,b)\tPerl_save_hdelete(aTHX_ a,b)\n#define save_helem_flags(a,b,c,d)\tPerl_save_helem_flags(aTHX_ a,b,c,d)\n#define save_hints()\t\tPerl_save_hints(aTHX)\n#define save_hptr(a)\t\tPerl_save_hptr(aTHX_ a)\n#define save_int(a)\t\tPerl_save_int(aTHX_ a)\n#define save_item(a)\t\tPerl_save_item(aTHX_ a)\n#define save_iv(a)\t\tPerl_save_iv(aTHX_ a)\n#ifndef NO_MATHOMS\n#define save_list(a,b)\t\tPerl_save_list(aTHX_ a,b)\n#endif\n#ifndef NO_MATHOMS\n#define save_long(a)\t\tPerl_save_long(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define save_nogv(a)\t\tPerl_save_nogv(aTHX_ a)\n#endif\n#define save_padsv_and_mortalize(a)\tPerl_save_padsv_and_mortalize(aTHX_ a)\n#define save_pptr(a)\t\tPerl_save_pptr(aTHX_ a)\n#define save_pushi32ptr(a,b,c)\tPerl_save_pushi32ptr(aTHX_ a,b,c)\n#define save_pushptr(a,b)\tPerl_save_pushptr(aTHX_ a,b)\n#define save_pushptrptr(a,b,c)\tPerl_save_pushptrptr(aTHX_ a,b,c)\n#define save_re_context()\tPerl_save_re_context(aTHX)\n#define save_scalar(a)\t\tPerl_save_scalar(aTHX_ a)\n#define save_set_svflags(a,b,c)\tPerl_save_set_svflags(aTHX_ a,b,c)\n#define save_shared_pvref(a)\tPerl_save_shared_pvref(aTHX_ a)\n#define save_sptr(a)\t\tPerl_save_sptr(aTHX_ a)\n#define save_svref(a)\t\tPerl_save_svref(aTHX_ a)\n#define save_vptr(a)\t\tPerl_save_vptr(aTHX_ a)\n#define savepv(a)\t\tPerl_savepv(aTHX_ a)\n#define savepvn(a,b)\t\tPerl_savepvn(aTHX_ a,b)\n#define savesharedpv(a)\t\tPerl_savesharedpv(aTHX_ a)\n#define savesharedpvn(a,b)\tPerl_savesharedpvn(aTHX_ a,b)\n#define savesharedsvpv(a)\tPerl_savesharedsvpv(aTHX_ a)\n#define savestack_grow()\tPerl_savestack_grow(aTHX)\n#define savestack_grow_cnt(a)\tPerl_savestack_grow_cnt(aTHX_ a)\n#define savesvpv(a)\t\tPerl_savesvpv(aTHX_ a)\n#define scan_bin(a,b,c)\t\tPerl_scan_bin(aTHX_ a,b,c)\n#define scan_hex(a,b,c)\t\tPerl_scan_hex(aTHX_ a,b,c)\n#define scan_num(a,b)\t\tPerl_scan_num(aTHX_ a,b)\n#define scan_oct(a,b,c)\t\tPerl_scan_oct(aTHX_ a,b,c)\n#define scan_version(a,b,c)\tPerl_scan_version(aTHX_ a,b,c)\n#define scan_vstring(a,b,c)\tPerl_scan_vstring(aTHX_ a,b,c)\n#define seed()\t\t\tPerl_seed(aTHX)\n#define set_context\t\tPerl_set_context\n#define setdefout(a)\t\tPerl_setdefout(aTHX_ a)\n#define share_hek(a,b,c)\tPerl_share_hek(aTHX_ a,b,c)\n#define sortsv(a,b,c)\t\tPerl_sortsv(aTHX_ a,b,c)\n#define sortsv_flags(a,b,c,d)\tPerl_sortsv_flags(aTHX_ a,b,c,d)\n#define stack_grow(a,b,c)\tPerl_stack_grow(aTHX_ a,b,c)\n#define start_subparse(a,b)\tPerl_start_subparse(aTHX_ a,b)\n#define str_to_version(a)\tPerl_str_to_version(aTHX_ a)\n#define sv_2bool_flags(a,b)\tPerl_sv_2bool_flags(aTHX_ a,b)\n#define sv_2cv(a,b,c,d)\t\tPerl_sv_2cv(aTHX_ a,b,c,d)\n#define sv_2io(a)\t\tPerl_sv_2io(aTHX_ a)\n#define sv_2iv_flags(a,b)\tPerl_sv_2iv_flags(aTHX_ a,b)\n#define sv_2mortal(a)\t\tPerl_sv_2mortal(aTHX_ a)\n#define sv_2nv_flags(a,b)\tPerl_sv_2nv_flags(aTHX_ a,b)\n#define sv_2pv_flags(a,b,c)\tPerl_sv_2pv_flags(aTHX_ a,b,c)\n#define sv_2pvbyte(a,b)\t\tPerl_sv_2pvbyte(aTHX_ a,b)\n#define sv_2pvutf8(a,b)\t\tPerl_sv_2pvutf8(aTHX_ a,b)\n#define sv_2uv_flags(a,b)\tPerl_sv_2uv_flags(aTHX_ a,b)\n#define sv_backoff\t\tPerl_sv_backoff\n#define sv_bless(a,b)\t\tPerl_sv_bless(aTHX_ a,b)\n#define sv_cat_decode(a,b,c,d,e,f)\tPerl_sv_cat_decode(aTHX_ a,b,c,d,e,f)\n#define sv_catpv(a,b)\t\tPerl_sv_catpv(aTHX_ a,b)\n#define sv_catpv_flags(a,b,c)\tPerl_sv_catpv_flags(aTHX_ a,b,c)\n#define sv_catpv_mg(a,b)\tPerl_sv_catpv_mg(aTHX_ a,b)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define sv_catpvf\t\tPerl_sv_catpvf\n#define sv_catpvf_mg\t\tPerl_sv_catpvf_mg\n#endif\n#define sv_catpvn_flags(a,b,c,d)\tPerl_sv_catpvn_flags(aTHX_ a,b,c,d)\n#define sv_catsv_flags(a,b,c)\tPerl_sv_catsv_flags(aTHX_ a,b,c)\n#define sv_chop(a,b)\t\tPerl_sv_chop(aTHX_ a,b)\n#define sv_clear(a)\t\tPerl_sv_clear(aTHX_ a)\n#define sv_cmp_flags(a,b,c)\tPerl_sv_cmp_flags(aTHX_ a,b,c)\n#define sv_cmp_locale_flags(a,b,c)\tPerl_sv_cmp_locale_flags(aTHX_ a,b,c)\n#define sv_copypv_flags(a,b,c)\tPerl_sv_copypv_flags(aTHX_ a,b,c)\n#define sv_dec(a)\t\tPerl_sv_dec(aTHX_ a)\n#define sv_dec_nomg(a)\t\tPerl_sv_dec_nomg(aTHX_ a)\n#define sv_derived_from(a,b)\tPerl_sv_derived_from(aTHX_ a,b)\n#define sv_derived_from_pv(a,b,c)\tPerl_sv_derived_from_pv(aTHX_ a,b,c)\n#define sv_derived_from_pvn(a,b,c,d)\tPerl_sv_derived_from_pvn(aTHX_ a,b,c,d)\n#define sv_derived_from_sv(a,b,c)\tPerl_sv_derived_from_sv(aTHX_ a,b,c)\n#define sv_destroyable(a)\tPerl_sv_destroyable(aTHX_ a)\n#define sv_does(a,b)\t\tPerl_sv_does(aTHX_ a,b)\n#define sv_does_pv(a,b,c)\tPerl_sv_does_pv(aTHX_ a,b,c)\n#define sv_does_pvn(a,b,c,d)\tPerl_sv_does_pvn(aTHX_ a,b,c,d)\n#define sv_does_sv(a,b,c)\tPerl_sv_does_sv(aTHX_ a,b,c)\n#define sv_dump(a)\t\tPerl_sv_dump(aTHX_ a)\n#define sv_eq_flags(a,b,c)\tPerl_sv_eq_flags(aTHX_ a,b,c)\n#define sv_force_normal_flags(a,b)\tPerl_sv_force_normal_flags(aTHX_ a,b)\n#define sv_free(a)\t\tPerl_sv_free(aTHX_ a)\n#define sv_get_backrefs\t\tPerl_sv_get_backrefs\n#define sv_gets(a,b,c)\t\tPerl_sv_gets(aTHX_ a,b,c)\n#define sv_grow(a,b)\t\tPerl_sv_grow(aTHX_ a,b)\n#define sv_inc(a)\t\tPerl_sv_inc(aTHX_ a)\n#define sv_inc_nomg(a)\t\tPerl_sv_inc_nomg(aTHX_ a)\n#define sv_insert_flags(a,b,c,d,e,f)\tPerl_sv_insert_flags(aTHX_ a,b,c,d,e,f)\n#define sv_isa(a,b)\t\tPerl_sv_isa(aTHX_ a,b)\n#define sv_isobject(a)\t\tPerl_sv_isobject(aTHX_ a)\n#ifndef NO_MATHOMS\n#define sv_iv(a)\t\tPerl_sv_iv(aTHX_ a)\n#endif\n#define sv_len(a)\t\tPerl_sv_len(aTHX_ a)\n#define sv_len_utf8(a)\t\tPerl_sv_len_utf8(aTHX_ a)\n#define sv_magic(a,b,c,d,e)\tPerl_sv_magic(aTHX_ a,b,c,d,e)\n#define sv_magicext(a,b,c,d,e,f)\tPerl_sv_magicext(aTHX_ a,b,c,d,e,f)\n#define sv_newmortal()\t\tPerl_sv_newmortal(aTHX)\n#define sv_newref(a)\t\tPerl_sv_newref(aTHX_ a)\n#define sv_nosharing(a)\t\tPerl_sv_nosharing(aTHX_ a)\n#ifndef NO_MATHOMS\n#define sv_nounlocking(a)\tPerl_sv_nounlocking(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define sv_nv(a)\t\tPerl_sv_nv(aTHX_ a)\n#endif\n#define sv_peek(a)\t\tPerl_sv_peek(aTHX_ a)\n#define sv_pos_b2u(a,b)\t\tPerl_sv_pos_b2u(aTHX_ a,b)\n#define sv_pos_b2u_flags(a,b,c)\tPerl_sv_pos_b2u_flags(aTHX_ a,b,c)\n#define sv_pos_u2b(a,b,c)\tPerl_sv_pos_u2b(aTHX_ a,b,c)\n#define sv_pos_u2b_flags(a,b,c,d)\tPerl_sv_pos_u2b_flags(aTHX_ a,b,c,d)\n#ifndef NO_MATHOMS\n#define sv_pvbyten(a,b)\t\tPerl_sv_pvbyten(aTHX_ a,b)\n#endif\n#define sv_pvbyten_force(a,b)\tPerl_sv_pvbyten_force(aTHX_ a,b)\n#ifndef NO_MATHOMS\n#define sv_pvn(a,b)\t\tPerl_sv_pvn(aTHX_ a,b)\n#endif\n#define sv_pvn_force_flags(a,b,c)\tPerl_sv_pvn_force_flags(aTHX_ a,b,c)\n#ifndef NO_MATHOMS\n#define sv_pvn_nomg(a,b)\tPerl_sv_pvn_nomg(aTHX_ a,b)\n#endif\n#ifndef NO_MATHOMS\n#define sv_pvutf8n(a,b)\t\tPerl_sv_pvutf8n(aTHX_ a,b)\n#endif\n#define sv_pvutf8n_force(a,b)\tPerl_sv_pvutf8n_force(aTHX_ a,b)\n#define sv_recode_to_utf8(a,b)\tPerl_sv_recode_to_utf8(aTHX_ a,b)\n#define sv_ref(a,b,c)\t\tPerl_sv_ref(aTHX_ a,b,c)\n#define sv_reftype(a,b)\t\tPerl_sv_reftype(aTHX_ a,b)\n#define sv_replace(a,b)\t\tPerl_sv_replace(aTHX_ a,b)\n#define sv_report_used()\tPerl_sv_report_used(aTHX)\n#define sv_reset(a,b)\t\tPerl_sv_reset(aTHX_ a,b)\n#define sv_rvunweaken(a)\tPerl_sv_rvunweaken(aTHX_ a)\n#define sv_rvweaken(a)\t\tPerl_sv_rvweaken(aTHX_ a)\n#define sv_set_undef(a)\t\tPerl_sv_set_undef(aTHX_ a)\n#define sv_setiv(a,b)\t\tPerl_sv_setiv(aTHX_ a,b)\n#define sv_setiv_mg(a,b)\tPerl_sv_setiv_mg(aTHX_ a,b)\n#define sv_setnv(a,b)\t\tPerl_sv_setnv(aTHX_ a,b)\n#define sv_setnv_mg(a,b)\tPerl_sv_setnv_mg(aTHX_ a,b)\n#define sv_setpv(a,b)\t\tPerl_sv_setpv(aTHX_ a,b)\n#define sv_setpv_bufsize(a,b,c)\tPerl_sv_setpv_bufsize(aTHX_ a,b,c)\n#define sv_setpv_mg(a,b)\tPerl_sv_setpv_mg(aTHX_ a,b)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define sv_setpvf\t\tPerl_sv_setpvf\n#define sv_setpvf_mg\t\tPerl_sv_setpvf_mg\n#endif\n#ifndef NO_MATHOMS\n#define sv_setpviv(a,b)\t\tPerl_sv_setpviv(aTHX_ a,b)\n#endif\n#ifndef NO_MATHOMS\n#define sv_setpviv_mg(a,b)\tPerl_sv_setpviv_mg(aTHX_ a,b)\n#endif\n#define sv_setpvn(a,b,c)\tPerl_sv_setpvn(aTHX_ a,b,c)\n#define sv_setpvn_mg(a,b,c)\tPerl_sv_setpvn_mg(aTHX_ a,b,c)\n#define sv_setref_iv(a,b,c)\tPerl_sv_setref_iv(aTHX_ a,b,c)\n#define sv_setref_nv(a,b,c)\tPerl_sv_setref_nv(aTHX_ a,b,c)\n#define sv_setref_pv(a,b,c)\tPerl_sv_setref_pv(aTHX_ a,b,c)\n#define sv_setref_pvn(a,b,c,d)\tPerl_sv_setref_pvn(aTHX_ a,b,c,d)\n#define sv_setref_uv(a,b,c)\tPerl_sv_setref_uv(aTHX_ a,b,c)\n#define sv_setsv_flags(a,b,c)\tPerl_sv_setsv_flags(aTHX_ a,b,c)\n#define sv_setsv_mg(a,b)\tPerl_sv_setsv_mg(aTHX_ a,b)\n#define sv_setuv(a,b)\t\tPerl_sv_setuv(aTHX_ a,b)\n#define sv_setuv_mg(a,b)\tPerl_sv_setuv_mg(aTHX_ a,b)\n#define sv_string_from_errnum(a,b)\tPerl_sv_string_from_errnum(aTHX_ a,b)\n#define sv_tainted(a)\t\tPerl_sv_tainted(aTHX_ a)\n#define sv_true(a)\t\tPerl_sv_true(aTHX_ a)\n#define sv_uni_display(a,b,c,d)\tPerl_sv_uni_display(aTHX_ a,b,c,d)\n#define sv_unmagic(a,b)\t\tPerl_sv_unmagic(aTHX_ a,b)\n#define sv_unmagicext(a,b,c)\tPerl_sv_unmagicext(aTHX_ a,b,c)\n#define sv_unref_flags(a,b)\tPerl_sv_unref_flags(aTHX_ a,b)\n#define sv_untaint(a)\t\tPerl_sv_untaint(aTHX_ a)\n#define sv_upgrade(a,b)\t\tPerl_sv_upgrade(aTHX_ a,b)\n#define sv_usepvn_flags(a,b,c,d)\tPerl_sv_usepvn_flags(aTHX_ a,b,c,d)\n#define sv_utf8_decode(a)\tPerl_sv_utf8_decode(aTHX_ a)\n#define sv_utf8_downgrade(a,b)\tPerl_sv_utf8_downgrade(aTHX_ a,b)\n#define sv_utf8_encode(a)\tPerl_sv_utf8_encode(aTHX_ a)\n#define sv_utf8_upgrade_flags_grow(a,b,c)\tPerl_sv_utf8_upgrade_flags_grow(aTHX_ a,b,c)\n#ifndef NO_MATHOMS\n#define sv_uv(a)\t\tPerl_sv_uv(aTHX_ a)\n#endif\n#define sv_vcatpvf(a,b,c)\tPerl_sv_vcatpvf(aTHX_ a,b,c)\n#define sv_vcatpvf_mg(a,b,c)\tPerl_sv_vcatpvf_mg(aTHX_ a,b,c)\n#define sv_vcatpvfn(a,b,c,d,e,f,g)\tPerl_sv_vcatpvfn(aTHX_ a,b,c,d,e,f,g)\n#define sv_vcatpvfn_flags(a,b,c,d,e,f,g,h)\tPerl_sv_vcatpvfn_flags(aTHX_ a,b,c,d,e,f,g,h)\n#define sv_vsetpvf(a,b,c)\tPerl_sv_vsetpvf(aTHX_ a,b,c)\n#define sv_vsetpvf_mg(a,b,c)\tPerl_sv_vsetpvf_mg(aTHX_ a,b,c)\n#define sv_vsetpvfn(a,b,c,d,e,f,g)\tPerl_sv_vsetpvfn(aTHX_ a,b,c,d,e,f,g)\n#define switch_to_global_locale\tPerl_switch_to_global_locale\n#define sync_locale\t\tPerl_sync_locale\n#define taint_env()\t\tPerl_taint_env(aTHX)\n#define taint_proper(a,b)\tPerl_taint_proper(aTHX_ a,b)\n#define thread_locale_init\tPerl_thread_locale_init\n#define thread_locale_term\tPerl_thread_locale_term\n#define to_uni_lower(a,b,c)\tPerl_to_uni_lower(aTHX_ a,b,c)\n#ifndef NO_MATHOMS\n#define to_uni_lower_lc(a)\tPerl_to_uni_lower_lc(aTHX_ a)\n#endif\n#define to_uni_title(a,b,c)\tPerl_to_uni_title(aTHX_ a,b,c)\n#ifndef NO_MATHOMS\n#define to_uni_title_lc(a)\tPerl_to_uni_title_lc(aTHX_ a)\n#endif\n#define to_uni_upper(a,b,c)\tPerl_to_uni_upper(aTHX_ a,b,c)\n#ifndef NO_MATHOMS\n#define to_uni_upper_lc(a)\tPerl_to_uni_upper_lc(aTHX_ a)\n#endif\n#ifndef NO_MATHOMS\n#define unpack_str(a,b,c,d,e,f,g,h)\tPerl_unpack_str(aTHX_ a,b,c,d,e,f,g,h)\n#endif\n#define unpackstring(a,b,c,d,e)\tPerl_unpackstring(aTHX_ a,b,c,d,e)\n#define unsharepvn(a,b,c)\tPerl_unsharepvn(aTHX_ a,b,c)\n#define upg_version(a,b)\tPerl_upg_version(aTHX_ a,b)\n#define utf8_distance(a,b)\tPerl_utf8_distance(aTHX_ a,b)\n#define utf8_hop\t\tPerl_utf8_hop\n#define utf8_hop_back\t\tPerl_utf8_hop_back\n#define utf8_hop_forward\tPerl_utf8_hop_forward\n#define utf8_hop_safe\t\tPerl_utf8_hop_safe\n#define utf8_length(a,b)\tPerl_utf8_length(aTHX_ a,b)\n#define utf8_to_bytes(a,b)\tPerl_utf8_to_bytes(aTHX_ a,b)\n#define utf8_to_uvchr(a,b)\tPerl_utf8_to_uvchr(aTHX_ a,b)\n#ifndef NO_MATHOMS\n#define utf8_to_uvuni(a,b)\tPerl_utf8_to_uvuni(aTHX_ a,b)\n#endif\n#define utf8_to_uvuni_buf(a,b,c)\tPerl_utf8_to_uvuni_buf(aTHX_ a,b,c)\n#define utf8n_to_uvchr_msgs\tS_utf8n_to_uvchr_msgs\n#define utf8n_to_uvuni(a,b,c,d)\tPerl_utf8n_to_uvuni(aTHX_ a,b,c,d)\n#define uvoffuni_to_utf8_flags_msgs(a,b,c,d)\tPerl_uvoffuni_to_utf8_flags_msgs(aTHX_ a,b,c,d)\n#define uvuni_to_utf8(a,b)\tPerl_uvuni_to_utf8(aTHX_ a,b)\n#define uvuni_to_utf8_flags(a,b,c)\tPerl_uvuni_to_utf8_flags(aTHX_ a,b,c)\n#define valid_utf8_to_uvchr\tPerl_valid_utf8_to_uvchr\n#ifndef NO_MATHOMS\n#define valid_utf8_to_uvuni(a,b)\tPerl_valid_utf8_to_uvuni(aTHX_ a,b)\n#endif\n#define vcmp(a,b)\t\tPerl_vcmp(aTHX_ a,b)\n#define vcroak(a,b)\t\tPerl_vcroak(aTHX_ a,b)\n#define vdeb(a,b)\t\tPerl_vdeb(aTHX_ a,b)\n#define vform(a,b)\t\tPerl_vform(aTHX_ a,b)\n#define vload_module(a,b,c,d)\tPerl_vload_module(aTHX_ a,b,c,d)\n#define vmess(a,b)\t\tPerl_vmess(aTHX_ a,b)\n#define vnewSVpvf(a,b)\t\tPerl_vnewSVpvf(aTHX_ a,b)\n#define vnormal(a)\t\tPerl_vnormal(aTHX_ a)\n#define vnumify(a)\t\tPerl_vnumify(aTHX_ a)\n#define vstringify(a)\t\tPerl_vstringify(aTHX_ a)\n#define vverify(a)\t\tPerl_vverify(aTHX_ a)\n#define vwarn(a,b)\t\tPerl_vwarn(aTHX_ a,b)\n#define vwarner(a,b,c)\t\tPerl_vwarner(aTHX_ a,b,c)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define warn\t\t\tPerl_warn\n#endif\n#define warn_sv(a)\t\tPerl_warn_sv(aTHX_ a)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define warner\t\t\tPerl_warner\n#endif\n#define whichsig_pv(a)\t\tPerl_whichsig_pv(aTHX_ a)\n#define whichsig_pvn(a,b)\tPerl_whichsig_pvn(aTHX_ a,b)\n#define whichsig_sv(a)\t\tPerl_whichsig_sv(aTHX_ a)\n#define wrap_keyword_plugin(a,b)\tPerl_wrap_keyword_plugin(aTHX_ a,b)\n#define wrap_op_checker(a,b,c)\tPerl_wrap_op_checker(aTHX_ a,b,c)\n#if !(defined(HAS_MEMMEM))\n#define ninstr\t\t\tPerl_ninstr\n#endif\n#if !(defined(HAS_SIGACTION) && defined(SA_SIGINFO))\n#define csighandler\t\tPerl_csighandler\n#endif\n#if !defined(EBCDIC)\n#define _variant_byte_number\tS__variant_byte_number\n#endif\n#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)\n#define my_chsize(a,b)\t\tPerl_my_chsize(aTHX_ a,b)\n#endif\n#if !defined(PERL_IMPLICIT_SYS)\n#define my_pclose(a)\t\tPerl_my_pclose(aTHX_ a)\n#define my_popen(a,b)\t\tPerl_my_popen(aTHX_ a,b)\n#endif\n#if !defined(PERL_NO_INLINE_FUNCTIONS)\n#define cx_popblock(a)\t\tS_cx_popblock(aTHX_ a)\n#define cx_popeval(a)\t\tS_cx_popeval(aTHX_ a)\n#define cx_popformat(a)\t\tS_cx_popformat(aTHX_ a)\n#define cx_popgiven(a)\t\tS_cx_popgiven(aTHX_ a)\n#define cx_poploop(a)\t\tS_cx_poploop(aTHX_ a)\n#define cx_popsub(a)\t\tS_cx_popsub(aTHX_ a)\n#define cx_popsub_args(a)\tS_cx_popsub_args(aTHX_ a)\n#define cx_popsub_common(a)\tS_cx_popsub_common(aTHX_ a)\n#define cx_popwhen(a)\t\tS_cx_popwhen(aTHX_ a)\n#define cx_pushblock(a,b,c,d)\tS_cx_pushblock(aTHX_ a,b,c,d)\n#define cx_pusheval(a,b,c)\tS_cx_pusheval(aTHX_ a,b,c)\n#define cx_pushformat(a,b,c,d)\tS_cx_pushformat(aTHX_ a,b,c,d)\n#define cx_pushgiven(a,b)\tS_cx_pushgiven(aTHX_ a,b)\n#define cx_pushloop_for(a,b,c)\tS_cx_pushloop_for(aTHX_ a,b,c)\n#define cx_pushloop_plain(a)\tS_cx_pushloop_plain(aTHX_ a)\n#define cx_pushsub(a,b,c,d)\tS_cx_pushsub(aTHX_ a,b,c,d)\n#define cx_pushwhen(a)\t\tS_cx_pushwhen(aTHX_ a)\n#define cx_topblock(a)\t\tS_cx_topblock(aTHX_ a)\n#endif\n#if defined(DEBUGGING)\n#define pad_setsv(a,b)\t\tPerl_pad_setsv(aTHX_ a,b)\n#define pad_sv(a)\t\tPerl_pad_sv(aTHX_ a)\n#endif\n#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)\n#define csighandler\t\tPerl_csighandler\n#endif\n#if defined(HAVE_INTERP_INTERN)\n#define sys_intern_clear()\tPerl_sys_intern_clear(aTHX)\n#define sys_intern_init()\tPerl_sys_intern_init(aTHX)\n#  if defined(USE_ITHREADS)\n#define sys_intern_dup(a,b)\tPerl_sys_intern_dup(aTHX_ a,b)\n#  endif\n#endif\n#if defined(MYMALLOC)\n#define dump_mstats(a)\t\tPerl_dump_mstats(aTHX_ a)\n#define get_mstats(a,b,c)\tPerl_get_mstats(aTHX_ a,b,c)\n#endif\n#if defined(PERL_GLOBAL_STRUCT)\n#define GetVars()\t\tPerl_GetVars(aTHX)\n#define free_global_struct(a)\tPerl_free_global_struct(aTHX_ a)\n#define init_global_struct()\tPerl_init_global_struct(aTHX)\n#endif\n#if defined(PERL_IMPLICIT_CONTEXT)\n#define croak_nocontext\t\tPerl_croak_nocontext\n#define deb_nocontext\t\tPerl_deb_nocontext\n#define die_nocontext\t\tPerl_die_nocontext\n#define form_nocontext\t\tPerl_form_nocontext\n#ifndef NO_MATHOMS\n#define fprintf_nocontext\tPerl_fprintf_nocontext\n#endif\n#define load_module_nocontext\tPerl_load_module_nocontext\n#define mess_nocontext\t\tPerl_mess_nocontext\n#define newSVpvf_nocontext\tPerl_newSVpvf_nocontext\n#ifndef NO_MATHOMS\n#define printf_nocontext\tPerl_printf_nocontext\n#endif\n#define sv_catpvf_mg_nocontext\tPerl_sv_catpvf_mg_nocontext\n#define sv_catpvf_nocontext\tPerl_sv_catpvf_nocontext\n#define sv_setpvf_mg_nocontext\tPerl_sv_setpvf_mg_nocontext\n#define sv_setpvf_nocontext\tPerl_sv_setpvf_nocontext\n#define warn_nocontext\t\tPerl_warn_nocontext\n#define warner_nocontext\tPerl_warner_nocontext\n#endif\n#if defined(UNLINK_ALL_VERSIONS)\n#define unlnk(a)\t\tPerl_unlnk(aTHX_ a)\n#endif\n#if defined(USE_C_BACKTRACE)\n#define dump_c_backtrace(a,b,c)\tPerl_dump_c_backtrace(aTHX_ a,b,c)\n#define get_c_backtrace_dump(a,b)\tPerl_get_c_backtrace_dump(aTHX_ a,b)\n#endif\n#if defined(USE_ITHREADS)\n#define alloccopstash(a)\tPerl_alloccopstash(aTHX_ a)\n#define any_dup(a,b)\t\tPerl_any_dup(aTHX_ a,b)\n#define cx_dup(a,b,c,d)\t\tPerl_cx_dup(aTHX_ a,b,c,d)\n#define dirp_dup(a,b)\t\tPerl_dirp_dup(aTHX_ a,b)\n#define fp_dup(a,b,c)\t\tPerl_fp_dup(aTHX_ a,b,c)\n#define gp_dup(a,b)\t\tPerl_gp_dup(aTHX_ a,b)\n#define he_dup(a,b,c)\t\tPerl_he_dup(aTHX_ a,b,c)\n#define hek_dup(a,b)\t\tPerl_hek_dup(aTHX_ a,b)\n#define mg_dup(a,b)\t\tPerl_mg_dup(aTHX_ a,b)\n#define newPADOP(a,b,c)\t\tPerl_newPADOP(aTHX_ a,b,c)\n#define parser_dup(a,b)\t\tPerl_parser_dup(aTHX_ a,b)\n#define re_dup_guts(a,b,c)\tPerl_re_dup_guts(aTHX_ a,b,c)\n#define regdupe_internal(a,b)\tPerl_regdupe_internal(aTHX_ a,b)\n#define rvpv_dup(a,b,c)\t\tPerl_rvpv_dup(aTHX_ a,b,c)\n#define si_dup(a,b)\t\tPerl_si_dup(aTHX_ a,b)\n#define ss_dup(a,b)\t\tPerl_ss_dup(aTHX_ a,b)\n#define sv_dup(a,b)\t\tPerl_sv_dup(aTHX_ a,b)\n#define sv_dup_inc(a,b)\t\tPerl_sv_dup_inc(aTHX_ a,b)\n#endif\n#if defined(USE_LOCALE)\t\t    && (   defined(PERL_IN_LOCALE_C)\t        || defined(PERL_IN_MG_C)\t\t|| defined (PERL_EXT_POSIX)\t\t|| defined (PERL_EXT_LANGINFO))\n#define _is_cur_LC_category_utf8(a)\tPerl__is_cur_LC_category_utf8(aTHX_ a)\n#endif\n#if defined(USE_LOCALE_COLLATE)\n#define sv_collxfrm_flags(a,b,c)\tPerl_sv_collxfrm_flags(aTHX_ a,b,c)\n#endif\n#if defined(USE_PERLIO)\n#define PerlIO_clearerr(a)\tPerl_PerlIO_clearerr(aTHX_ a)\n#define PerlIO_close(a)\t\tPerl_PerlIO_close(aTHX_ a)\n#define PerlIO_eof(a)\t\tPerl_PerlIO_eof(aTHX_ a)\n#define PerlIO_error(a)\t\tPerl_PerlIO_error(aTHX_ a)\n#define PerlIO_fileno(a)\tPerl_PerlIO_fileno(aTHX_ a)\n#define PerlIO_fill(a)\t\tPerl_PerlIO_fill(aTHX_ a)\n#define PerlIO_flush(a)\t\tPerl_PerlIO_flush(aTHX_ a)\n#define PerlIO_get_base(a)\tPerl_PerlIO_get_base(aTHX_ a)\n#define PerlIO_get_bufsiz(a)\tPerl_PerlIO_get_bufsiz(aTHX_ a)\n#define PerlIO_get_cnt(a)\tPerl_PerlIO_get_cnt(aTHX_ a)\n#define PerlIO_get_ptr(a)\tPerl_PerlIO_get_ptr(aTHX_ a)\n#define PerlIO_read(a,b,c)\tPerl_PerlIO_read(aTHX_ a,b,c)\n#define PerlIO_seek(a,b,c)\tPerl_PerlIO_seek(aTHX_ a,b,c)\n#define PerlIO_set_cnt(a,b)\tPerl_PerlIO_set_cnt(aTHX_ a,b)\n#define PerlIO_set_ptrcnt(a,b,c)\tPerl_PerlIO_set_ptrcnt(aTHX_ a,b,c)\n#define PerlIO_setlinebuf(a)\tPerl_PerlIO_setlinebuf(aTHX_ a)\n#define PerlIO_stderr()\t\tPerl_PerlIO_stderr(aTHX)\n#define PerlIO_stdin()\t\tPerl_PerlIO_stdin(aTHX)\n#define PerlIO_stdout()\t\tPerl_PerlIO_stdout(aTHX)\n#define PerlIO_tell(a)\t\tPerl_PerlIO_tell(aTHX_ a)\n#define PerlIO_unread(a,b,c)\tPerl_PerlIO_unread(aTHX_ a,b,c)\n#define PerlIO_write(a,b,c)\tPerl_PerlIO_write(aTHX_ a,b,c)\n#endif\n#if defined(USE_QUADMATH)\n#define quadmath_format_needed\tPerl_quadmath_format_needed\n#define quadmath_format_single\tPerl_quadmath_format_single\n#endif\n#if defined(WIN32) || defined(__SYMBIAN32__) || defined(VMS)\n#define do_aspawn(a,b,c)\tPerl_do_aspawn(aTHX_ a,b,c)\n#define do_spawn(a)\t\tPerl_do_spawn(aTHX_ a)\n#define do_spawn_nowait(a)\tPerl_do_spawn_nowait(aTHX_ a)\n#endif\n#if defined(PERL_CORE) || defined(PERL_EXT)\n#define _byte_dump_string(a,b,c)\tPerl__byte_dump_string(aTHX_ a,b,c)\n#define _inverse_folds(a,b,c)\tPerl__inverse_folds(aTHX_ a,b,c)\n#define append_utf8_from_native_byte\tS_append_utf8_from_native_byte\n#define av_reify(a)\t\tPerl_av_reify(aTHX_ a)\n#define current_re_engine()\tPerl_current_re_engine(aTHX)\n#define cv_ckproto_len_flags(a,b,c,d,e)\tPerl_cv_ckproto_len_flags(aTHX_ a,b,c,d,e)\n#define get_and_check_backslash_N_name(a,b,c,d)\tPerl_get_and_check_backslash_N_name(aTHX_ a,b,c,d)\n#define grok_atoUV\t\tPerl_grok_atoUV\n#define mg_find_mglob(a)\tPerl_mg_find_mglob(aTHX_ a)\n#define multiconcat_stringify(a)\tPerl_multiconcat_stringify(aTHX_ a)\n#define multideref_stringify(a,b)\tPerl_multideref_stringify(aTHX_ a,b)\n#define op_clear(a)\t\tPerl_op_clear(aTHX_ a)\n#define qerror(a)\t\tPerl_qerror(aTHX_ a)\n#define reg_named_buff(a,b,c,d)\tPerl_reg_named_buff(aTHX_ a,b,c,d)\n#define reg_named_buff_iter(a,b,c)\tPerl_reg_named_buff_iter(aTHX_ a,b,c)\n#define reg_numbered_buff_fetch(a,b,c)\tPerl_reg_numbered_buff_fetch(aTHX_ a,b,c)\n#define reg_numbered_buff_length(a,b,c)\tPerl_reg_numbered_buff_length(aTHX_ a,b,c)\n#define reg_numbered_buff_store(a,b,c)\tPerl_reg_numbered_buff_store(aTHX_ a,b,c)\n#define reg_qr_package(a)\tPerl_reg_qr_package(aTHX_ a)\n#define reg_temp_copy(a,b)\tPerl_reg_temp_copy(aTHX_ a,b)\n#define report_uninit(a)\tPerl_report_uninit(aTHX_ a)\n#define scan_str(a,b,c,d,e)\tPerl_scan_str(aTHX_ a,b,c,d,e)\n#define scan_word(a,b,c,d,e)\tPerl_scan_word(aTHX_ a,b,c,d,e)\n#define skipspace_flags(a,b)\tPerl_skipspace_flags(aTHX_ a,b)\n#define sv_magicext_mglob(a)\tPerl_sv_magicext_mglob(aTHX_ a)\n#define sv_only_taint_gmagic\tS_sv_only_taint_gmagic\n#define swash_fetch(a,b,c)\tPerl_swash_fetch(aTHX_ a,b,c)\n#define swash_init(a,b,c,d,e)\tPerl_swash_init(aTHX_ a,b,c,d,e)\n#define utf16_to_utf8(a,b,c,d)\tPerl_utf16_to_utf8(aTHX_ a,b,c,d)\n#define utf16_to_utf8_reversed(a,b,c,d)\tPerl_utf16_to_utf8_reversed(aTHX_ a,b,c,d)\n#define validate_proto(a,b,c,d)\tPerl_validate_proto(aTHX_ a,b,c,d)\n#define vivify_defelem(a)\tPerl_vivify_defelem(aTHX_ a)\n#define yylex()\t\t\tPerl_yylex(aTHX)\n#  if ! defined(HAS_MEMRCHR) && (defined(PERL_CORE) || defined(PERL_EXT))\n#define my_memrchr\t\tS_my_memrchr\n#  endif\n#  if !defined(PERL_EXT_RE_BUILD)\n#    if defined(PERL_IN_REGCOMP_C)\n#define _append_range_to_invlist(a,b,c)\tS__append_range_to_invlist(aTHX_ a,b,c)\n#define _invlist_array_init\tS__invlist_array_init\n#define get_invlist_previous_index_addr\tS_get_invlist_previous_index_addr\n#define invlist_clear(a)\tS_invlist_clear(aTHX_ a)\n#define invlist_extend(a,b)\tS_invlist_extend(aTHX_ a,b)\n#define invlist_max\t\tS_invlist_max\n#define invlist_previous_index\tS_invlist_previous_index\n#define invlist_replace_list_destroys_src(a,b)\tS_invlist_replace_list_destroys_src(aTHX_ a,b)\n#define invlist_set_len(a,b,c)\tS_invlist_set_len(aTHX_ a,b,c)\n#define invlist_set_previous_index\tS_invlist_set_previous_index\n#define invlist_trim\t\tS_invlist_trim\n#    endif\n#  endif\n#  if defined(DEBUGGING)\n#    if defined(PERL_IN_REGCOMP_C)\n#define dump_trie(a,b,c,d)\tS_dump_trie(aTHX_ a,b,c,d)\n#define dump_trie_interim_list(a,b,c,d,e)\tS_dump_trie_interim_list(aTHX_ a,b,c,d,e)\n#define dump_trie_interim_table(a,b,c,d,e)\tS_dump_trie_interim_table(aTHX_ a,b,c,d,e)\n#define dumpuntil(a,b,c,d,e,f,g,h)\tS_dumpuntil(aTHX_ a,b,c,d,e,f,g,h)\n#define put_charclass_bitmap_innards(a,b,c,d,e,f)\tS_put_charclass_bitmap_innards(aTHX_ a,b,c,d,e,f)\n#define put_charclass_bitmap_innards_common(a,b,c,d,e,f)\tS_put_charclass_bitmap_innards_common(aTHX_ a,b,c,d,e,f)\n#define put_charclass_bitmap_innards_invlist(a,b)\tS_put_charclass_bitmap_innards_invlist(aTHX_ a,b)\n#define put_code_point(a,b)\tS_put_code_point(aTHX_ a,b)\n#define put_range(a,b,c,d)\tS_put_range(aTHX_ a,b,c,d)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define re_indentf\t\tPerl_re_indentf\n#endif\n#define regdump_extflags(a,b)\tS_regdump_extflags(aTHX_ a,b)\n#define regdump_intflags(a,b)\tS_regdump_intflags(aTHX_ a,b)\n#define regtail_study(a,b,c,d)\tS_regtail_study(aTHX_ a,b,c,d)\n#    endif\n#    if defined(PERL_IN_REGEXEC_C)\n#define debug_start_match(a,b,c,d,e)\tS_debug_start_match(aTHX_ a,b,c,d,e)\n#define dump_exec_pos(a,b,c,d,e,f,g)\tS_dump_exec_pos(aTHX_ a,b,c,d,e,f,g)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define re_exec_indentf\t\tPerl_re_exec_indentf\n#endif\n#    endif\n#  endif\n#  if defined(DEBUGGING) && defined(ENABLE_REGEX_SETS_DEBUGGING)\n#    if defined(PERL_IN_REGCOMP_C)\n#define dump_regex_sets_structures(a,b,c,d)\tS_dump_regex_sets_structures(aTHX_ a,b,c,d)\n#    endif\n#  endif\n#  if defined(PERL_ANY_COW)\n#define sv_setsv_cow(a,b)\tPerl_sv_setsv_cow(aTHX_ a,b)\n#  endif\n#  if defined(PERL_CORE) || defined (PERL_EXT)\n#define is_utf8_non_invariant_string\tS_is_utf8_non_invariant_string\n#define sv_or_pv_pos_u2b(a,b,c,d)\tS_sv_or_pv_pos_u2b(aTHX_ a,b,c,d)\n#  endif\n#  if defined(PERL_CORE) || defined(PERL_EXT)\n#define isSCRIPT_RUN(a,b,c)\tPerl_isSCRIPT_RUN(aTHX_ a,b,c)\n#define variant_under_utf8_count\tS_variant_under_utf8_count\n#  endif\n#  if defined(PERL_IN_REGCOMP_C)\n#define _make_exactf_invlist(a,b)\tS__make_exactf_invlist(aTHX_ a,b)\n#define add_above_Latin1_folds(a,b,c)\tS_add_above_Latin1_folds(aTHX_ a,b,c)\n#define add_cp_to_invlist(a,b)\tS_add_cp_to_invlist(aTHX_ a,b)\n#define add_data\t\tS_add_data\n#define add_multi_match(a,b,c)\tS_add_multi_match(aTHX_ a,b,c)\n#define change_engine_size(a,b)\tS_change_engine_size(aTHX_ a,b)\n#define cntrl_to_mnemonic\tS_cntrl_to_mnemonic\n#define compute_EXACTish\tS_compute_EXACTish\n#define construct_ahocorasick_from_trie(a,b,c)\tS_construct_ahocorasick_from_trie(aTHX_ a,b,c)\n#define edit_distance\t\tS_edit_distance\n#define get_ANYOFM_contents(a)\tS_get_ANYOFM_contents(aTHX_ a)\n#define get_ANYOF_cp_list_for_ssc(a,b)\tS_get_ANYOF_cp_list_for_ssc(aTHX_ a,b)\n#define get_invlist_iter_addr\tS_get_invlist_iter_addr\n#define grok_bslash_N(a,b,c,d,e,f,g)\tS_grok_bslash_N(aTHX_ a,b,c,d,e,f,g)\n#define handle_named_backref(a,b,c,d)\tS_handle_named_backref(aTHX_ a,b,c,d)\n#define handle_possible_posix(a,b,c,d,e)\tS_handle_possible_posix(aTHX_ a,b,c,d,e)\n#define handle_regex_sets(a,b,c,d,e)\tS_handle_regex_sets(aTHX_ a,b,c,d,e)\n#define handle_user_defined_property(a,b,c,d,e,f,g,h,i,j)\tPerl_handle_user_defined_property(aTHX_ a,b,c,d,e,f,g,h,i,j)\n#define invlist_contents(a,b)\tS_invlist_contents(aTHX_ a,b)\n#define invlist_highest\t\tS_invlist_highest\n#define invlist_is_iterating\tS_invlist_is_iterating\n#define invlist_iterfinish\tS_invlist_iterfinish\n#define invlist_iterinit\tS_invlist_iterinit\n#define invlist_iternext\tS_invlist_iternext\n#define is_ssc_worth_it\t\tS_is_ssc_worth_it\n#define join_exact(a,b,c,d,e,f,g)\tS_join_exact(aTHX_ a,b,c,d,e,f,g)\n#define make_trie(a,b,c,d,e,f,g,h)\tS_make_trie(aTHX_ a,b,c,d,e,f,g,h)\n#define new_regcurly\t\tS_new_regcurly\n#define nextchar(a)\t\tS_nextchar(aTHX_ a)\n#define output_posix_warnings(a,b)\tS_output_posix_warnings(aTHX_ a,b)\n#define parse_lparen_question_flags(a)\tS_parse_lparen_question_flags(aTHX_ a)\n#define parse_uniprop_string(a,b,c,d,e,f,g,h,i)\tPerl_parse_uniprop_string(aTHX_ a,b,c,d,e,f,g,h,i)\n#define populate_ANYOF_from_invlist(a,b)\tS_populate_ANYOF_from_invlist(aTHX_ a,b)\n#define rck_elide_nothing(a)\tS_rck_elide_nothing(aTHX_ a)\n#define reg(a,b,c,d)\t\tS_reg(aTHX_ a,b,c,d)\n#define reg2Lanode(a,b,c,d)\tS_reg2Lanode(aTHX_ a,b,c,d)\n#define reg_node(a,b)\t\tS_reg_node(aTHX_ a,b)\n#define reg_scan_name(a,b)\tS_reg_scan_name(aTHX_ a,b)\n#define reg_skipcomment\t\tS_reg_skipcomment\n#define reganode(a,b,c)\t\tS_reganode(aTHX_ a,b,c)\n#define regatom(a,b,c)\t\tS_regatom(aTHX_ a,b,c)\n#define regbranch(a,b,c,d)\tS_regbranch(aTHX_ a,b,c,d)\n#define regclass(a,b,c,d,e,f,g,h,i)\tS_regclass(aTHX_ a,b,c,d,e,f,g,h,i)\n#define regex_set_precedence\tS_regex_set_precedence\n#define reginsert(a,b,c,d)\tS_reginsert(aTHX_ a,b,c,d)\n#define regnode_guts(a,b,c,d)\tS_regnode_guts(aTHX_ a,b,c,d)\n#define regpiece(a,b,c)\t\tS_regpiece(aTHX_ a,b,c)\n#define regtail(a,b,c,d)\tS_regtail(aTHX_ a,b,c,d)\n#define scan_commit(a,b,c,d)\tS_scan_commit(aTHX_ a,b,c,d)\n#define set_ANYOF_arg(a,b,c,d,e)\tS_set_ANYOF_arg(aTHX_ a,b,c,d,e)\n#define set_regex_pv(a,b)\tS_set_regex_pv(aTHX_ a,b)\n#define skip_to_be_ignored_text(a,b,c)\tS_skip_to_be_ignored_text(aTHX_ a,b,c)\n#define ssc_add_range(a,b,c)\tS_ssc_add_range(aTHX_ a,b,c)\n#define ssc_and(a,b,c)\t\tS_ssc_and(aTHX_ a,b,c)\n#define ssc_anything(a)\t\tS_ssc_anything(aTHX_ a)\n#define ssc_clear_locale\tS_ssc_clear_locale\n#define ssc_cp_and(a,b)\t\tS_ssc_cp_and(aTHX_ a,b)\n#define ssc_finalize(a,b)\tS_ssc_finalize(aTHX_ a,b)\n#define ssc_init(a,b)\t\tS_ssc_init(aTHX_ a,b)\n#define ssc_intersection(a,b,c)\tS_ssc_intersection(aTHX_ a,b,c)\n#define ssc_is_anything\t\tS_ssc_is_anything\n#define ssc_is_cp_posixl_init\tS_ssc_is_cp_posixl_init\n#define ssc_or(a,b,c)\t\tS_ssc_or(aTHX_ a,b,c)\n#define ssc_union(a,b,c)\tS_ssc_union(aTHX_ a,b,c)\n#define study_chunk(a,b,c,d,e,f,g,h,i,j,k,l)\tS_study_chunk(aTHX_ a,b,c,d,e,f,g,h,i,j,k,l)\n#  endif\n#  if defined(PERL_IN_REGCOMP_C) || defined (PERL_IN_DUMP_C)\n#define _invlist_dump(a,b,c,d)\tPerl__invlist_dump(aTHX_ a,b,c,d)\n#  endif\n#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_PERL_C) || defined(PERL_IN_UTF8_C)\n#define _invlistEQ(a,b,c)\tPerl__invlistEQ(aTHX_ a,b,c)\n#define _new_invlist_C_array(a)\tPerl__new_invlist_C_array(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)\n#define _get_regclass_nonbitmap_data(a,b,c,d,e,f)\tPerl__get_regclass_nonbitmap_data(aTHX_ a,b,c,d,e,f)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define re_printf\t\tPerl_re_printf\n#endif\n#define regprop(a,b,c,d,e)\tPerl_regprop(aTHX_ a,b,c,d,e)\n#  endif\n#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_TOKE_C) || defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)\n#define _invlist_contains_cp\tS__invlist_contains_cp\n#define _invlist_len\t\tS__invlist_len\n#define _invlist_search\t\tPerl__invlist_search\n#define get_invlist_offset_addr\tS_get_invlist_offset_addr\n#define invlist_array\t\tS_invlist_array\n#define is_invlist\t\tS_is_invlist\n#  endif\n#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_SV_C)\n#define invlist_clone(a,b)\tPerl_invlist_clone(aTHX_ a,b)\n#  endif\n#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_TOKE_C) || defined(PERL_IN_DQUOTE_C)\n#define form_short_octal_warning(a,b)\tS_form_short_octal_warning(aTHX_ a,b)\n#define grok_bslash_c(a,b)\tPerl_grok_bslash_c(aTHX_ a,b)\n#define grok_bslash_o(a,b,c,d,e,f,g,h)\tPerl_grok_bslash_o(aTHX_ a,b,c,d,e,f,g,h)\n#define grok_bslash_x(a,b,c,d,e,f,g,h)\tPerl_grok_bslash_x(aTHX_ a,b,c,d,e,f,g,h)\n#define regcurly\t\tS_regcurly\n#  endif\n#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_UTF8_C)\n#define _add_range_to_invlist(a,b,c)\tPerl__add_range_to_invlist(aTHX_ a,b,c)\n#define _invlist_intersection_maybe_complement_2nd(a,b,c,d)\tPerl__invlist_intersection_maybe_complement_2nd(aTHX_ a,b,c,d)\n#define _invlist_invert(a)\tPerl__invlist_invert(aTHX_ a)\n#define _invlist_union_maybe_complement_2nd(a,b,c,d)\tPerl__invlist_union_maybe_complement_2nd(aTHX_ a,b,c,d)\n#define _new_invlist(a)\t\tPerl__new_invlist(aTHX_ a)\n#define _setup_canned_invlist(a,b,c)\tPerl__setup_canned_invlist(aTHX_ a,b,c)\n#  endif\n#  if defined(PERL_IN_REGEXEC_C)\n#define advance_one_LB(a,b,c)\tS_advance_one_LB(aTHX_ a,b,c)\n#define advance_one_SB(a,b,c)\tS_advance_one_SB(aTHX_ a,b,c)\n#define advance_one_WB(a,b,c,d)\tS_advance_one_WB(aTHX_ a,b,c,d)\n#define backup_one_GCB(a,b,c)\tS_backup_one_GCB(aTHX_ a,b,c)\n#define backup_one_LB(a,b,c)\tS_backup_one_LB(aTHX_ a,b,c)\n#define backup_one_SB(a,b,c)\tS_backup_one_SB(aTHX_ a,b,c)\n#define backup_one_WB(a,b,c,d)\tS_backup_one_WB(aTHX_ a,b,c,d)\n#define find_byclass(a,b,c,d,e)\tS_find_byclass(aTHX_ a,b,c,d,e)\n#define find_next_masked\tS_find_next_masked\n#define find_span_end\t\tS_find_span_end\n#define find_span_end_mask\tS_find_span_end_mask\n#define foldEQ_latin1_s2_folded\tS_foldEQ_latin1_s2_folded\n#define isFOO_utf8_lc(a,b,c)\tS_isFOO_utf8_lc(aTHX_ a,b,c)\n#define isGCB(a,b,c,d,e)\tS_isGCB(aTHX_ a,b,c,d,e)\n#define isLB(a,b,c,d,e,f)\tS_isLB(aTHX_ a,b,c,d,e,f)\n#define isSB(a,b,c,d,e,f)\tS_isSB(aTHX_ a,b,c,d,e,f)\n#define isWB(a,b,c,d,e,f,g)\tS_isWB(aTHX_ a,b,c,d,e,f,g)\n#define reg_check_named_buff_matched\tS_reg_check_named_buff_matched\n#define regcp_restore(a,b,c)\tS_regcp_restore(aTHX_ a,b,c _aDEPTH)\n#define regcppop(a,b)\t\tS_regcppop(aTHX_ a,b _aDEPTH)\n#define regcppush(a,b,c)\tS_regcppush(aTHX_ a,b,c _aDEPTH)\n#define reghop3\t\t\tS_reghop3\n#define reghop4\t\t\tS_reghop4\n#define reghopmaybe3\t\tS_reghopmaybe3\n#define reginclass(a,b,c,d,e)\tS_reginclass(aTHX_ a,b,c,d,e)\n#define regmatch(a,b,c)\t\tS_regmatch(aTHX_ a,b,c)\n#define regrepeat(a,b,c,d,e,f)\tS_regrepeat(aTHX_ a,b,c,d,e,f _aDEPTH)\n#define regtry(a,b)\t\tS_regtry(aTHX_ a,b)\n#define to_byte_substr(a)\tS_to_byte_substr(aTHX_ a)\n#define to_utf8_substr(a)\tS_to_utf8_substr(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_TOKE_C)\n#define _is_grapheme(a,b,c,d)\tPerl__is_grapheme(aTHX_ a,b,c,d)\n#  endif\n#  if defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C)\n#define isFOO_lc(a,b)\t\tPerl_isFOO_lc(aTHX_ a,b)\n#  endif\n#  if defined(PERL_IN_UTF8_C) || defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)\n#define _to_fold_latin1\t\tPerl__to_fold_latin1\n#  endif\n#endif\n#ifdef PERL_CORE\n#define PerlLIO_dup2_cloexec(a,b)\tPerl_PerlLIO_dup2_cloexec(aTHX_ a,b)\n#define PerlLIO_dup_cloexec(a)\tPerl_PerlLIO_dup_cloexec(aTHX_ a)\n#define PerlLIO_open3_cloexec(a,b,c)\tPerl_PerlLIO_open3_cloexec(aTHX_ a,b,c)\n#define PerlLIO_open_cloexec(a,b)\tPerl_PerlLIO_open_cloexec(aTHX_ a,b)\n#define Slab_Alloc(a)\t\tPerl_Slab_Alloc(aTHX_ a)\n#define Slab_Free(a)\t\tPerl_Slab_Free(aTHX_ a)\n#define _is_in_locale_category(a,b)\tPerl__is_in_locale_category(aTHX_ a,b)\n#define _warn_problematic_locale\tPerl__warn_problematic_locale\n#define abort_execution(a,b)\tPerl_abort_execution(aTHX_ a,b)\n#define alloc_LOGOP(a,b,c)\tPerl_alloc_LOGOP(aTHX_ a,b,c)\n#define allocmy(a,b,c)\t\tPerl_allocmy(aTHX_ a,b,c)\n#define amagic_is_enabled(a)\tPerl_amagic_is_enabled(aTHX_ a)\n#define apply(a,b,c)\t\tPerl_apply(aTHX_ a,b,c)\n#define av_extend_guts(a,b,c,d,e)\tPerl_av_extend_guts(aTHX_ a,b,c,d,e)\n#define av_nonelem(a,b)\t\tPerl_av_nonelem(aTHX_ a,b)\n#define bind_match(a,b,c)\tPerl_bind_match(aTHX_ a,b,c)\n#define boot_core_PerlIO()\tPerl_boot_core_PerlIO(aTHX)\n#define boot_core_UNIVERSAL()\tPerl_boot_core_UNIVERSAL(aTHX)\n#define boot_core_mro()\t\tPerl_boot_core_mro(aTHX)\n#define cando(a,b,c)\t\tPerl_cando(aTHX_ a,b,c)\n#define check_utf8_print(a,b)\tPerl_check_utf8_print(aTHX_ a,b)\n#define ck_anoncode(a)\t\tPerl_ck_anoncode(aTHX_ a)\n#define ck_backtick(a)\t\tPerl_ck_backtick(aTHX_ a)\n#define ck_bitop(a)\t\tPerl_ck_bitop(aTHX_ a)\n#define ck_cmp(a)\t\tPerl_ck_cmp(aTHX_ a)\n#define ck_concat(a)\t\tPerl_ck_concat(aTHX_ a)\n#define ck_defined(a)\t\tPerl_ck_defined(aTHX_ a)\n#define ck_delete(a)\t\tPerl_ck_delete(aTHX_ a)\n#define ck_each(a)\t\tPerl_ck_each(aTHX_ a)\n#define ck_eof(a)\t\tPerl_ck_eof(aTHX_ a)\n#define ck_eval(a)\t\tPerl_ck_eval(aTHX_ a)\n#define ck_exec(a)\t\tPerl_ck_exec(aTHX_ a)\n#define ck_exists(a)\t\tPerl_ck_exists(aTHX_ a)\n#define ck_ftst(a)\t\tPerl_ck_ftst(aTHX_ a)\n#define ck_fun(a)\t\tPerl_ck_fun(aTHX_ a)\n#define ck_glob(a)\t\tPerl_ck_glob(aTHX_ a)\n#define ck_grep(a)\t\tPerl_ck_grep(aTHX_ a)\n#define ck_index(a)\t\tPerl_ck_index(aTHX_ a)\n#define ck_join(a)\t\tPerl_ck_join(aTHX_ a)\n#define ck_length(a)\t\tPerl_ck_length(aTHX_ a)\n#define ck_lfun(a)\t\tPerl_ck_lfun(aTHX_ a)\n#define ck_listiob(a)\t\tPerl_ck_listiob(aTHX_ a)\n#define ck_match(a)\t\tPerl_ck_match(aTHX_ a)\n#define ck_method(a)\t\tPerl_ck_method(aTHX_ a)\n#define ck_null(a)\t\tPerl_ck_null(aTHX_ a)\n#define ck_open(a)\t\tPerl_ck_open(aTHX_ a)\n#define ck_prototype(a)\t\tPerl_ck_prototype(aTHX_ a)\n#define ck_readline(a)\t\tPerl_ck_readline(aTHX_ a)\n#define ck_refassign(a)\t\tPerl_ck_refassign(aTHX_ a)\n#define ck_repeat(a)\t\tPerl_ck_repeat(aTHX_ a)\n#define ck_require(a)\t\tPerl_ck_require(aTHX_ a)\n#define ck_return(a)\t\tPerl_ck_return(aTHX_ a)\n#define ck_rfun(a)\t\tPerl_ck_rfun(aTHX_ a)\n#define ck_rvconst(a)\t\tPerl_ck_rvconst(aTHX_ a)\n#define ck_sassign(a)\t\tPerl_ck_sassign(aTHX_ a)\n#define ck_select(a)\t\tPerl_ck_select(aTHX_ a)\n#define ck_shift(a)\t\tPerl_ck_shift(aTHX_ a)\n#define ck_smartmatch(a)\tPerl_ck_smartmatch(aTHX_ a)\n#define ck_sort(a)\t\tPerl_ck_sort(aTHX_ a)\n#define ck_spair(a)\t\tPerl_ck_spair(aTHX_ a)\n#define ck_split(a)\t\tPerl_ck_split(aTHX_ a)\n#define ck_stringify(a)\t\tPerl_ck_stringify(aTHX_ a)\n#define ck_subr(a)\t\tPerl_ck_subr(aTHX_ a)\n#define ck_substr(a)\t\tPerl_ck_substr(aTHX_ a)\n#define ck_svconst(a)\t\tPerl_ck_svconst(aTHX_ a)\n#define ck_tell(a)\t\tPerl_ck_tell(aTHX_ a)\n#define ck_trunc(a)\t\tPerl_ck_trunc(aTHX_ a)\n#define closest_cop(a,b,c,d)\tPerl_closest_cop(aTHX_ a,b,c,d)\n#define core_prototype(a,b,c,d)\tPerl_core_prototype(aTHX_ a,b,c,d)\n#define coresub_op(a,b,c)\tPerl_coresub_op(aTHX_ a,b,c)\n#define create_eval_scope(a,b)\tPerl_create_eval_scope(aTHX_ a,b)\n#define croak_caller\t\tPerl_croak_caller\n#define croak_no_mem\t\tPerl_croak_no_mem\n#define croak_popstack\t\tPerl_croak_popstack\n#define custom_op_get_field(a,b)\tPerl_custom_op_get_field(aTHX_ a,b)\n#define cv_clone_into(a,b)\tPerl_cv_clone_into(aTHX_ a,b)\n#define cv_const_sv_or_av\tPerl_cv_const_sv_or_av\n#define cv_forget_slab(a)\tPerl_cv_forget_slab(aTHX_ a)\n#define cv_undef_flags(a,b)\tPerl_cv_undef_flags(aTHX_ a,b)\n#define cvgv_set(a,b)\t\tPerl_cvgv_set(aTHX_ a,b)\n#define cvstash_set(a,b)\tPerl_cvstash_set(aTHX_ a,b)\n#define deb_stack_all()\t\tPerl_deb_stack_all(aTHX)\n#define defelem_target(a,b)\tPerl_defelem_target(aTHX_ a,b)\n#define delete_eval_scope()\tPerl_delete_eval_scope(aTHX)\n#define delimcpy_no_escape\tPerl_delimcpy_no_escape\n#define die_unwind(a)\t\tPerl_die_unwind(aTHX_ a)\n#define do_aexec5(a,b,c,d,e)\tPerl_do_aexec5(aTHX_ a,b,c,d,e)\n#define do_dump_pad(a,b,c,d)\tPerl_do_dump_pad(aTHX_ a,b,c,d)\n#define do_eof(a)\t\tPerl_do_eof(aTHX_ a)\n#define do_ncmp(a,b)\t\tPerl_do_ncmp(aTHX_ a,b)\n#define do_open6(a,b,c,d,e,f)\tPerl_do_open6(aTHX_ a,b,c,d,e,f)\n#define do_open_raw(a,b,c,d,e,f)\tPerl_do_open_raw(aTHX_ a,b,c,d,e,f)\n#define do_print(a,b)\t\tPerl_do_print(aTHX_ a,b)\n#define do_readline()\t\tPerl_do_readline(aTHX)\n#define do_seek(a,b,c)\t\tPerl_do_seek(aTHX_ a,b,c)\n#define do_sysseek(a,b,c)\tPerl_do_sysseek(aTHX_ a,b,c)\n#define do_tell(a)\t\tPerl_do_tell(aTHX_ a)\n#define do_trans(a)\t\tPerl_do_trans(aTHX_ a)\n#define do_vecget(a,b,c)\tPerl_do_vecget(aTHX_ a,b,c)\n#define do_vecset(a)\t\tPerl_do_vecset(aTHX_ a)\n#define do_vop(a,b,c,d)\t\tPerl_do_vop(aTHX_ a,b,c,d)\n#define dofile(a,b)\t\tPerl_dofile(aTHX_ a,b)\n#define dump_all_perl(a)\tPerl_dump_all_perl(aTHX_ a)\n#define dump_packsubs_perl(a,b)\tPerl_dump_packsubs_perl(aTHX_ a,b)\n#define dump_sub_perl(a,b)\tPerl_dump_sub_perl(aTHX_ a,b)\n#define finalize_optree(a)\tPerl_finalize_optree(aTHX_ a)\n#define find_lexical_cv(a)\tPerl_find_lexical_cv(aTHX_ a)\n#define find_runcv_where(a,b,c)\tPerl_find_runcv_where(aTHX_ a,b,c)\n#define find_script(a,b,c,d)\tPerl_find_script(aTHX_ a,b,c,d)\n#define free_tied_hv_pool()\tPerl_free_tied_hv_pool(aTHX)\n#define get_hash_seed(a)\tPerl_get_hash_seed(aTHX_ a)\n#define get_no_modify()\t\tPerl_get_no_modify(aTHX)\n#define get_opargs()\t\tPerl_get_opargs(aTHX)\n#define gv_override(a,b)\tPerl_gv_override(aTHX_ a,b)\n#define gv_setref(a,b)\t\tPerl_gv_setref(aTHX_ a,b)\n#define gv_try_downgrade(a)\tPerl_gv_try_downgrade(aTHX_ a)\n#define hv_ename_add(a,b,c,d)\tPerl_hv_ename_add(aTHX_ a,b,c,d)\n#define hv_ename_delete(a,b,c,d)\tPerl_hv_ename_delete(aTHX_ a,b,c,d)\n#define hv_pushkv(a,b)\t\tPerl_hv_pushkv(aTHX_ a,b)\n#define init_argv_symbols(a,b)\tPerl_init_argv_symbols(aTHX_ a,b)\n#define init_constants()\tPerl_init_constants(aTHX)\n#define init_debugger()\t\tPerl_init_debugger(aTHX)\n#define init_named_cv(a,b)\tPerl_init_named_cv(aTHX_ a,b)\n#define init_uniprops()\t\tPerl_init_uniprops(aTHX)\n#define invert(a)\t\tPerl_invert(aTHX_ a)\n#define io_close(a,b,c,d)\tPerl_io_close(aTHX_ a,b,c,d)\n#define isinfnansv(a)\t\tPerl_isinfnansv(aTHX_ a)\n#define jmaybe(a)\t\tPerl_jmaybe(aTHX_ a)\n#define keyword(a,b,c)\t\tPerl_keyword(aTHX_ a,b,c)\n#define list(a)\t\t\tPerl_list(aTHX_ a)\n#define localize(a,b)\t\tPerl_localize(aTHX_ a,b)\n#define magic_clear_all_env(a,b)\tPerl_magic_clear_all_env(aTHX_ a,b)\n#define magic_cleararylen_p(a,b)\tPerl_magic_cleararylen_p(aTHX_ a,b)\n#define magic_clearenv(a,b)\tPerl_magic_clearenv(aTHX_ a,b)\n#define magic_clearhint(a,b)\tPerl_magic_clearhint(aTHX_ a,b)\n#define magic_clearhints(a,b)\tPerl_magic_clearhints(aTHX_ a,b)\n#define magic_clearisa(a,b)\tPerl_magic_clearisa(aTHX_ a,b)\n#define magic_clearpack(a,b)\tPerl_magic_clearpack(aTHX_ a,b)\n#define magic_clearsig(a,b)\tPerl_magic_clearsig(aTHX_ a,b)\n#define magic_copycallchecker(a,b,c,d,e)\tPerl_magic_copycallchecker(aTHX_ a,b,c,d,e)\n#define magic_existspack(a,b)\tPerl_magic_existspack(aTHX_ a,b)\n#define magic_freearylen_p(a,b)\tPerl_magic_freearylen_p(aTHX_ a,b)\n#define magic_freeovrld(a,b)\tPerl_magic_freeovrld(aTHX_ a,b)\n#define magic_get(a,b)\t\tPerl_magic_get(aTHX_ a,b)\n#define magic_getarylen(a,b)\tPerl_magic_getarylen(aTHX_ a,b)\n#define magic_getdebugvar(a,b)\tPerl_magic_getdebugvar(aTHX_ a,b)\n#define magic_getdefelem(a,b)\tPerl_magic_getdefelem(aTHX_ a,b)\n#define magic_getnkeys(a,b)\tPerl_magic_getnkeys(aTHX_ a,b)\n#define magic_getpack(a,b)\tPerl_magic_getpack(aTHX_ a,b)\n#define magic_getpos(a,b)\tPerl_magic_getpos(aTHX_ a,b)\n#define magic_getsig(a,b)\tPerl_magic_getsig(aTHX_ a,b)\n#define magic_getsubstr(a,b)\tPerl_magic_getsubstr(aTHX_ a,b)\n#define magic_gettaint(a,b)\tPerl_magic_gettaint(aTHX_ a,b)\n#define magic_getuvar(a,b)\tPerl_magic_getuvar(aTHX_ a,b)\n#define magic_getvec(a,b)\tPerl_magic_getvec(aTHX_ a,b)\n#define magic_killbackrefs(a,b)\tPerl_magic_killbackrefs(aTHX_ a,b)\n#define magic_nextpack(a,b,c)\tPerl_magic_nextpack(aTHX_ a,b,c)\n#define magic_regdata_cnt(a,b)\tPerl_magic_regdata_cnt(aTHX_ a,b)\n#define magic_regdatum_get(a,b)\tPerl_magic_regdatum_get(aTHX_ a,b)\n#define magic_scalarpack(a,b)\tPerl_magic_scalarpack(aTHX_ a,b)\n#define magic_set(a,b)\t\tPerl_magic_set(aTHX_ a,b)\n#define magic_set_all_env(a,b)\tPerl_magic_set_all_env(aTHX_ a,b)\n#define magic_setarylen(a,b)\tPerl_magic_setarylen(aTHX_ a,b)\n#define magic_setdbline(a,b)\tPerl_magic_setdbline(aTHX_ a,b)\n#define magic_setdebugvar(a,b)\tPerl_magic_setdebugvar(aTHX_ a,b)\n#define magic_setdefelem(a,b)\tPerl_magic_setdefelem(aTHX_ a,b)\n#define magic_setenv(a,b)\tPerl_magic_setenv(aTHX_ a,b)\n#define magic_sethint(a,b)\tPerl_magic_sethint(aTHX_ a,b)\n#define magic_setisa(a,b)\tPerl_magic_setisa(aTHX_ a,b)\n#define magic_setlvref(a,b)\tPerl_magic_setlvref(aTHX_ a,b)\n#define magic_setmglob(a,b)\tPerl_magic_setmglob(aTHX_ a,b)\n#define magic_setnkeys(a,b)\tPerl_magic_setnkeys(aTHX_ a,b)\n#define magic_setnonelem(a,b)\tPerl_magic_setnonelem(aTHX_ a,b)\n#define magic_setpack(a,b)\tPerl_magic_setpack(aTHX_ a,b)\n#define magic_setpos(a,b)\tPerl_magic_setpos(aTHX_ a,b)\n#define magic_setregexp(a,b)\tPerl_magic_setregexp(aTHX_ a,b)\n#define magic_setsig(a,b)\tPerl_magic_setsig(aTHX_ a,b)\n#define magic_setsubstr(a,b)\tPerl_magic_setsubstr(aTHX_ a,b)\n#define magic_settaint(a,b)\tPerl_magic_settaint(aTHX_ a,b)\n#define magic_setutf8(a,b)\tPerl_magic_setutf8(aTHX_ a,b)\n#define magic_setuvar(a,b)\tPerl_magic_setuvar(aTHX_ a,b)\n#define magic_setvec(a,b)\tPerl_magic_setvec(aTHX_ a,b)\n#define magic_sizepack(a,b)\tPerl_magic_sizepack(aTHX_ a,b)\n#define magic_wipepack(a,b)\tPerl_magic_wipepack(aTHX_ a,b)\n#define mg_localize(a,b,c)\tPerl_mg_localize(aTHX_ a,b,c)\n#define mode_from_discipline(a,b)\tPerl_mode_from_discipline(aTHX_ a,b)\n#define mro_isa_changed_in(a)\tPerl_mro_isa_changed_in(aTHX_ a)\n#define mro_package_moved(a,b,c,d)\tPerl_mro_package_moved(aTHX_ a,b,c,d)\n#define my_attrs(a,b)\t\tPerl_my_attrs(aTHX_ a,b)\n#define my_clearenv()\t\tPerl_my_clearenv(aTHX)\n#define my_lstat_flags(a)\tPerl_my_lstat_flags(aTHX_ a)\n#define my_stat_flags(a)\tPerl_my_stat_flags(aTHX_ a)\n#define my_strerror(a)\t\tPerl_my_strerror(aTHX_ a)\n#define my_unexec()\t\tPerl_my_unexec(aTHX)\n#define newATTRSUB_x(a,b,c,d,e,f)\tPerl_newATTRSUB_x(aTHX_ a,b,c,d,e,f)\n#define newSTUB(a,b)\t\tPerl_newSTUB(aTHX_ a,b)\n#define newSVavdefelem(a,b,c)\tPerl_newSVavdefelem(aTHX_ a,b,c)\n#define newXS_deffile(a,b)\tPerl_newXS_deffile(aTHX_ a,b)\n#define newXS_len_flags(a,b,c,d,e,f,g)\tPerl_newXS_len_flags(aTHX_ a,b,c,d,e,f,g)\n#define nextargv(a,b)\t\tPerl_nextargv(aTHX_ a,b)\n#define noperl_die\t\tPerl_noperl_die\n#define notify_parser_that_changed_to_utf8()\tPerl_notify_parser_that_changed_to_utf8(aTHX)\n#define oopsAV(a)\t\tPerl_oopsAV(aTHX_ a)\n#define oopsHV(a)\t\tPerl_oopsHV(aTHX_ a)\n#define op_unscope(a)\t\tPerl_op_unscope(aTHX_ a)\n#define optimize_optree(a)\tPerl_optimize_optree(aTHX_ a)\n#define package(a)\t\tPerl_package(aTHX_ a)\n#define package_version(a)\tPerl_package_version(aTHX_ a)\n#define pad_add_weakref(a)\tPerl_pad_add_weakref(aTHX_ a)\n#define pad_block_start(a)\tPerl_pad_block_start(aTHX_ a)\n#define pad_fixup_inner_anons(a,b,c)\tPerl_pad_fixup_inner_anons(aTHX_ a,b,c)\n#define pad_free(a)\t\tPerl_pad_free(aTHX_ a)\n#define pad_leavemy()\t\tPerl_pad_leavemy(aTHX)\n#define pad_push(a,b)\t\tPerl_pad_push(aTHX_ a,b)\n#define pad_swipe(a,b)\t\tPerl_pad_swipe(aTHX_ a,b)\n#define padlist_store(a,b,c)\tPerl_padlist_store(aTHX_ a,b,c)\n#define parse_unicode_opts(a)\tPerl_parse_unicode_opts(aTHX_ a)\n#define parser_free(a)\t\tPerl_parser_free(aTHX_ a)\n#define peep(a)\t\t\tPerl_peep(aTHX_ a)\n#define pmruntime(a,b,c,d,e)\tPerl_pmruntime(aTHX_ a,b,c,d,e)\n#define re_op_compile(a,b,c,d,e,f,g,h)\tPerl_re_op_compile(aTHX_ a,b,c,d,e,f,g,h)\n#define refcounted_he_chain_2hv(a,b)\tPerl_refcounted_he_chain_2hv(aTHX_ a,b)\n#define refcounted_he_fetch_pv(a,b,c,d)\tPerl_refcounted_he_fetch_pv(aTHX_ a,b,c,d)\n#define refcounted_he_fetch_pvn(a,b,c,d,e)\tPerl_refcounted_he_fetch_pvn(aTHX_ a,b,c,d,e)\n#define refcounted_he_fetch_sv(a,b,c,d)\tPerl_refcounted_he_fetch_sv(aTHX_ a,b,c,d)\n#define refcounted_he_free(a)\tPerl_refcounted_he_free(aTHX_ a)\n#define refcounted_he_inc(a)\tPerl_refcounted_he_inc(aTHX_ a)\n#define refcounted_he_new_pv(a,b,c,d,e)\tPerl_refcounted_he_new_pv(aTHX_ a,b,c,d,e)\n#define refcounted_he_new_pvn(a,b,c,d,e,f)\tPerl_refcounted_he_new_pvn(aTHX_ a,b,c,d,e,f)\n#define refcounted_he_new_sv(a,b,c,d,e)\tPerl_refcounted_he_new_sv(aTHX_ a,b,c,d,e)\n#define report_evil_fh(a)\tPerl_report_evil_fh(aTHX_ a)\n#define report_wrongway_fh(a,b)\tPerl_report_wrongway_fh(aTHX_ a,b)\n#define rpeep(a)\t\tPerl_rpeep(aTHX_ a)\n#define rsignal_restore(a,b)\tPerl_rsignal_restore(aTHX_ a,b)\n#define rsignal_save(a,b,c)\tPerl_rsignal_save(aTHX_ a,b,c)\n#define rxres_save(a,b)\t\tPerl_rxres_save(aTHX_ a,b)\n#define save_strlen(a)\t\tPerl_save_strlen(aTHX_ a)\n#define sawparens(a)\t\tPerl_sawparens(aTHX_ a)\n#define scalar(a)\t\tPerl_scalar(aTHX_ a)\n#define scalarvoid(a)\t\tPerl_scalarvoid(aTHX_ a)\n#define set_caret_X()\t\tPerl_set_caret_X(aTHX)\n#define set_numeric_standard()\tPerl_set_numeric_standard(aTHX)\n#define set_numeric_underlying()\tPerl_set_numeric_underlying(aTHX)\n#define setfd_cloexec\t\tPerl_setfd_cloexec\n#define setfd_cloexec_for_nonsysfd(a)\tPerl_setfd_cloexec_for_nonsysfd(aTHX_ a)\n#define setfd_cloexec_or_inhexec_by_sysfdness(a)\tPerl_setfd_cloexec_or_inhexec_by_sysfdness(aTHX_ a)\n#define setfd_inhexec\t\tPerl_setfd_inhexec\n#define setfd_inhexec_for_sysfd(a)\tPerl_setfd_inhexec_for_sysfd(aTHX_ a)\n#define sub_crush_depth(a)\tPerl_sub_crush_depth(aTHX_ a)\n#define sv_2num(a)\t\tPerl_sv_2num(aTHX_ a)\n#define sv_clean_all()\t\tPerl_sv_clean_all(aTHX)\n#define sv_clean_objs()\t\tPerl_sv_clean_objs(aTHX)\n#define sv_del_backref(a,b)\tPerl_sv_del_backref(aTHX_ a,b)\n#define sv_free_arenas()\tPerl_sv_free_arenas(aTHX)\n#define sv_len_utf8_nomg(a)\tPerl_sv_len_utf8_nomg(aTHX_ a)\n#define sv_mortalcopy_flags(a,b)\tPerl_sv_mortalcopy_flags(aTHX_ a,b)\n#define sv_resetpvn(a,b,c)\tPerl_sv_resetpvn(aTHX_ a,b,c)\n#define sv_sethek(a,b)\t\tPerl_sv_sethek(aTHX_ a,b)\n#ifndef PERL_IMPLICIT_CONTEXT\n#define tied_method\t\tPerl_tied_method\n#endif\n#define tmps_grow_p(a)\t\tPerl_tmps_grow_p(aTHX_ a)\n#define unshare_hek(a)\t\tPerl_unshare_hek(aTHX_ a)\n#define utilize(a,b,c,d,e)\tPerl_utilize(aTHX_ a,b,c,d,e)\n#define vivify_ref(a,b)\t\tPerl_vivify_ref(aTHX_ a,b)\n#define wait4pid(a,b,c)\t\tPerl_wait4pid(aTHX_ a,b,c)\n#define watch(a)\t\tPerl_watch(aTHX_ a)\n#define write_to_stderr(a)\tPerl_write_to_stderr(aTHX_ a)\n#define xs_boot_epilog(a)\tPerl_xs_boot_epilog(aTHX_ a)\n#define yyerror(a)\t\tPerl_yyerror(aTHX_ a)\n#define yyerror_pv(a,b)\t\tPerl_yyerror_pv(aTHX_ a,b)\n#define yyerror_pvn(a,b,c)\tPerl_yyerror_pvn(aTHX_ a,b,c)\n#define yyparse(a)\t\tPerl_yyparse(aTHX_ a)\n#define yyquit()\t\tPerl_yyquit(aTHX)\n#define yyunlex()\t\tPerl_yyunlex(aTHX)\n#  if !(defined(DEBUGGING))\n#    if !defined(NV_PRESERVES_UV)\n#      if defined(PERL_IN_SV_C)\n#define sv_2iuv_non_preserve(a)\tS_sv_2iuv_non_preserve(aTHX_ a)\n#      endif\n#    endif\n#  endif\n#  if !(defined(HAS_NL_LANGINFO))\n#    if defined(PERL_IN_LOCALE_C)\n#define my_nl_langinfo\t\tS_my_nl_langinfo\n#    endif\n#  endif\n#  if !(defined(HAS_SIGACTION) && defined(SA_SIGINFO))\n#define sighandler\t\tPerl_sighandler\n#  endif\n#  if !(defined(PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION))\n#define do_exec(a)\t\tPerl_do_exec(aTHX_ a)\n#  endif\n#  if !(defined(_MSC_VER))\n#define magic_regdatum_set(a,b)\tPerl_magic_regdatum_set(aTHX_ a,b)\n#  endif\n#  if !defined(HAS_GETENV_LEN)\n#define getenv_len(a,b)\t\tPerl_getenv_len(aTHX_ a,b)\n#  endif\n#  if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)\n#    if defined(PERL_IN_PP_SYS_C)\n#define dooneliner(a,b)\t\tS_dooneliner(aTHX_ a,b)\n#    endif\n#  endif\n#  if !defined(HAS_RENAME)\n#define same_dirent(a,b)\tPerl_same_dirent(aTHX_ a,b)\n#  endif\n#  if !defined(NV_PRESERVES_UV)\n#    if defined(DEBUGGING)\n#      if defined(PERL_IN_SV_C)\n#define sv_2iuv_non_preserve(a,b)\tS_sv_2iuv_non_preserve(aTHX_ a,b)\n#      endif\n#    endif\n#  endif\n#  if !defined(PERL_DISABLE_PMC)\n#    if defined(PERL_IN_PP_CTL_C)\n#define doopen_pm(a)\t\tS_doopen_pm(aTHX_ a)\n#    endif\n#  endif\n#  if !defined(PERL_EXT_RE_BUILD)\n#    if defined(PERL_IN_REGCOMP_C)\n#define initialize_invlist_guts(a,b)\tS_initialize_invlist_guts(aTHX_ a,b)\n#    endif\n#  endif\n#  if !defined(PERL_IS_MINIPERL)\n#    if defined(PERL_IN_PERL_C)\n#define incpush_if_exists(a,b,c)\tS_incpush_if_exists(aTHX_ a,b,c)\n#    endif\n#  endif\n#  if !defined(PERL_NO_UTF16_FILTER)\n#    if defined(PERL_IN_TOKE_C)\n#define add_utf16_textfilter(a,b)\tS_add_utf16_textfilter(aTHX_ a,b)\n#define utf16_textfilter(a,b,c)\tS_utf16_textfilter(aTHX_ a,b,c)\n#    endif\n#  endif\n#  if !defined(UV_IS_QUAD)\n#    if defined(PERL_IN_UTF8_C)\n#define is_utf8_cp_above_31_bits\tS_is_utf8_cp_above_31_bits\n#    endif\n#  endif\n#  if !defined(WIN32)\n#define do_exec3(a,b,c)\t\tPerl_do_exec3(aTHX_ a,b,c)\n#  endif\n#  if defined (HAS_SOCKETPAIR) ||     (defined (HAS_SOCKET) && defined(SOCK_DGRAM) && \tdefined(AF_INET) && defined(PF_INET))\n#define PerlSock_socketpair_cloexec(a,b,c,d)\tPerl_PerlSock_socketpair_cloexec(aTHX_ a,b,c,d)\n#  endif\n#  if defined(DEBUGGING)\n#define get_debug_opts(a,b)\tPerl_get_debug_opts(aTHX_ a,b)\n#define set_padlist\t\tPerl_set_padlist\n#    if defined(PERL_IN_LOCALE_C)\n#      if defined(USE_LOCALE)\n#define print_bytes_for_locale(a,b,c)\tS_print_bytes_for_locale(aTHX_ a,b,c)\n#define print_collxfrm_input_and_return(a,b,c,d)\tS_print_collxfrm_input_and_return(aTHX_ a,b,c,d)\n#define setlocale_debug_string\tS_setlocale_debug_string\n#      endif\n#    endif\n#    if defined(PERL_IN_PAD_C)\n#define cv_dump(a,b)\t\tS_cv_dump(aTHX_ a,b)\n#    endif\n#    if defined(PERL_IN_SV_C)\n#define del_sv(a)\t\tS_del_sv(aTHX_ a)\n#    endif\n#    if defined(PERL_IN_TOKE_C)\n#define printbuf(a,b)\t\tS_printbuf(aTHX_ a,b)\n#define tokereport(a,b)\t\tS_tokereport(aTHX_ a,b)\n#    endif\n#  endif\n#  if defined(DEBUG_LEAKING_SCALARS_FORK_DUMP)\n#define dump_sv_child(a)\tPerl_dump_sv_child(aTHX_ a)\n#  endif\n#  if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)\n#define do_ipcctl(a,b,c)\tPerl_do_ipcctl(aTHX_ a,b,c)\n#define do_ipcget(a,b,c)\tPerl_do_ipcget(aTHX_ a,b,c)\n#define do_msgrcv(a,b)\t\tPerl_do_msgrcv(aTHX_ a,b)\n#define do_msgsnd(a,b)\t\tPerl_do_msgsnd(aTHX_ a,b)\n#define do_semop(a,b)\t\tPerl_do_semop(aTHX_ a,b)\n#define do_shmio(a,b,c)\t\tPerl_do_shmio(aTHX_ a,b,c)\n#  endif\n#  if defined(HAS_NL_LANGINFO)\n#    if defined(PERL_IN_LOCALE_C)\n#define my_nl_langinfo\t\tS_my_nl_langinfo\n#    endif\n#  endif\n#  if defined(HAS_PIPE)\n#define PerlProc_pipe_cloexec(a)\tPerl_PerlProc_pipe_cloexec(aTHX_ a)\n#  endif\n#  if defined(HAS_SIGACTION) && defined(SA_SIGINFO)\n#define sighandler\t\tPerl_sighandler\n#  endif\n#  if defined(HAS_SOCKET)\n#define PerlSock_accept_cloexec(a,b,c)\tPerl_PerlSock_accept_cloexec(aTHX_ a,b,c)\n#define PerlSock_socket_cloexec(a,b,c)\tPerl_PerlSock_socket_cloexec(aTHX_ a,b,c)\n#  endif\n#  if defined(MYMALLOC)\n#define malloc_good_size\tPerl_malloc_good_size\n#define malloced_size\t\tPerl_malloced_size\n#  endif\n#  if defined(PERL_CORE)\n#define opslab_force_free(a)\tPerl_opslab_force_free(aTHX_ a)\n#define opslab_free(a)\t\tPerl_opslab_free(aTHX_ a)\n#define opslab_free_nopad(a)\tPerl_opslab_free_nopad(aTHX_ a)\n#define parser_free_nexttoke_ops(a,b)\tPerl_parser_free_nexttoke_ops(aTHX_ a,b)\n#define should_warn_nl\t\tS_should_warn_nl\n#    if defined(PERL_DEBUG_READONLY_OPS)\n#define Slab_to_ro(a)\t\tPerl_Slab_to_ro(aTHX_ a)\n#define Slab_to_rw(a)\t\tPerl_Slab_to_rw(aTHX_ a)\n#    endif\n#  endif\n#  if defined(PERL_CR_FILTER)\n#    if defined(PERL_IN_TOKE_C)\n#define cr_textfilter(a,b,c)\tS_cr_textfilter(aTHX_ a,b,c)\n#define strip_return(a)\t\tS_strip_return(aTHX_ a)\n#    endif\n#  endif\n#  if defined(PERL_DEBUG_READONLY_COW)\n#define sv_buf_to_ro(a)\t\tPerl_sv_buf_to_ro(aTHX_ a)\n#    if defined(PERL_IN_SV_C)\n#define sv_buf_to_rw(a)\t\tS_sv_buf_to_rw(aTHX_ a)\n#    endif\n#  endif\n#  if defined(PERL_IN_AV_C)\n#define get_aux_mg(a)\t\tS_get_aux_mg(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_DEB_C)\n#define deb_stack_n(a,b,c,d,e)\tS_deb_stack_n(aTHX_ a,b,c,d,e)\n#  endif\n#  if defined(PERL_IN_DOIO_C)\n#define argvout_final(a,b,c)\tS_argvout_final(aTHX_ a,b,c)\n#define exec_failed(a,b,c)\tS_exec_failed(aTHX_ a,b,c)\n#define ingroup(a,b)\t\tS_ingroup(aTHX_ a,b)\n#define openn_cleanup(a,b,c,d,e,f,g,h,i,j,k,l,m)\tS_openn_cleanup(aTHX_ a,b,c,d,e,f,g,h,i,j,k,l,m)\n#define openn_setup(a,b,c,d,e,f)\tS_openn_setup(aTHX_ a,b,c,d,e,f)\n#  endif\n#  if defined(PERL_IN_DOOP_C)\n#define do_trans_complex(a)\tS_do_trans_complex(aTHX_ a)\n#define do_trans_complex_utf8(a)\tS_do_trans_complex_utf8(aTHX_ a)\n#define do_trans_count(a)\tS_do_trans_count(aTHX_ a)\n#define do_trans_count_utf8(a)\tS_do_trans_count_utf8(aTHX_ a)\n#define do_trans_simple(a)\tS_do_trans_simple(aTHX_ a)\n#define do_trans_simple_utf8(a)\tS_do_trans_simple_utf8(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_DUMP_C)\n#define deb_curcv(a)\t\tS_deb_curcv(aTHX_ a)\n#define debprof(a)\t\tS_debprof(aTHX_ a)\n#define pm_description(a)\tS_pm_description(aTHX_ a)\n#define sequence_num(a)\t\tS_sequence_num(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_GV_C)\n#define find_default_stash(a,b,c,d,e,f)\tS_find_default_stash(aTHX_ a,b,c,d,e,f)\n#define gv_fetchmeth_internal(a,b,c,d,e,f)\tS_gv_fetchmeth_internal(aTHX_ a,b,c,d,e,f)\n#define gv_init_svtype(a,b)\tS_gv_init_svtype(aTHX_ a,b)\n#define gv_is_in_main(a,b,c)\tS_gv_is_in_main(aTHX_ a,b,c)\n#define gv_magicalize(a,b,c,d,e)\tS_gv_magicalize(aTHX_ a,b,c,d,e)\n#define gv_magicalize_isa(a)\tS_gv_magicalize_isa(aTHX_ a)\n#define gv_stashpvn_internal(a,b,c)\tS_gv_stashpvn_internal(aTHX_ a,b,c)\n#define gv_stashsvpvn_cached(a,b,c,d)\tS_gv_stashsvpvn_cached(aTHX_ a,b,c,d)\n#define maybe_multimagic_gv(a,b,c)\tS_maybe_multimagic_gv(aTHX_ a,b,c)\n#define parse_gv_stash_name(a,b,c,d,e,f,g,h)\tS_parse_gv_stash_name(aTHX_ a,b,c,d,e,f,g,h)\n#define require_tie_mod(a,b,c,d,e)\tS_require_tie_mod(aTHX_ a,b,c,d,e)\n#  endif\n#  if defined(PERL_IN_HV_C)\n#define clear_placeholders(a,b)\tS_clear_placeholders(aTHX_ a,b)\n#define hsplit(a,b,c)\t\tS_hsplit(aTHX_ a,b,c)\n#define hv_auxinit(a)\t\tS_hv_auxinit(aTHX_ a)\n#define hv_auxinit_internal\tS_hv_auxinit_internal\n#define hv_delete_common(a,b,c,d,e,f,g)\tS_hv_delete_common(aTHX_ a,b,c,d,e,f,g)\n#define hv_free_ent_ret(a,b)\tS_hv_free_ent_ret(aTHX_ a,b)\n#define hv_free_entries(a)\tS_hv_free_entries(aTHX_ a)\n#define hv_magic_check\t\tS_hv_magic_check\n#define hv_notallowed(a,b,c,d)\tS_hv_notallowed(aTHX_ a,b,c,d)\n#define new_he()\t\tS_new_he(aTHX)\n#define ptr_hash\t\tS_ptr_hash\n#define refcounted_he_value(a)\tS_refcounted_he_value(aTHX_ a)\n#define save_hek_flags\t\tS_save_hek_flags\n#define share_hek_flags(a,b,c,d)\tS_share_hek_flags(aTHX_ a,b,c,d)\n#define unshare_hek_or_pvn(a,b,c,d)\tS_unshare_hek_or_pvn(aTHX_ a,b,c,d)\n#  endif\n#  if defined(PERL_IN_LOCALE_C)\n#define save_to_buffer\t\tS_save_to_buffer\n#    if defined(USE_LOCALE)\n#define category_name\t\tS_category_name\n#define new_collate(a)\t\tS_new_collate(aTHX_ a)\n#define new_ctype(a)\t\tS_new_ctype(aTHX_ a)\n#define new_numeric(a)\t\tS_new_numeric(aTHX_ a)\n#define restore_switched_locale(a,b)\tS_restore_switched_locale(aTHX_ a,b)\n#define set_numeric_radix(a)\tS_set_numeric_radix(aTHX_ a)\n#define stdize_locale(a)\tS_stdize_locale(aTHX_ a)\n#define switch_category_locale_to_template(a,b,c)\tS_switch_category_locale_to_template(aTHX_ a,b,c)\n#      if defined(USE_POSIX_2008_LOCALE)\n#define emulate_setlocale\tS_emulate_setlocale\n#      endif\n#      if defined(WIN32)\n#define win32_setlocale(a,b)\tS_win32_setlocale(aTHX_ a,b)\n#      endif\n#    endif\n#  endif\n#  if defined(PERL_IN_LOCALE_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_MATHOMS_C)\n#    if defined(USE_LOCALE_COLLATE)\n#define _mem_collxfrm(a,b,c,d)\tPerl__mem_collxfrm(aTHX_ a,b,c,d)\n#    endif\n#  endif\n#  if defined(PERL_IN_MALLOC_C)\n#define adjust_size_and_find_bucket\tS_adjust_size_and_find_bucket\n#  endif\n#  if defined(PERL_IN_MG_C)\n#define fixup_errno_string(a)\tS_fixup_errno_string(aTHX_ a)\n#define magic_methcall1(a,b,c,d,e,f)\tS_magic_methcall1(aTHX_ a,b,c,d,e,f)\n#define magic_methpack(a,b,c)\tS_magic_methpack(aTHX_ a,b,c)\n#define restore_magic(a)\tS_restore_magic(aTHX_ a)\n#define save_magic_flags(a,b,c)\tS_save_magic_flags(aTHX_ a,b,c)\n#define unwind_handler_stack(a)\tS_unwind_handler_stack(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_MG_C) || defined(PERL_IN_PP_C)\n#define translate_substr_offsets\tPerl_translate_substr_offsets\n#  endif\n#  if defined(PERL_IN_MRO_C)\n#define mro_clean_isarev(a,b,c,d,e,f)\tS_mro_clean_isarev(aTHX_ a,b,c,d,e,f)\n#define mro_gather_and_rename(a,b,c,d,e)\tS_mro_gather_and_rename(aTHX_ a,b,c,d,e)\n#define mro_get_linear_isa_dfs(a,b)\tS_mro_get_linear_isa_dfs(aTHX_ a,b)\n#  endif\n#  if defined(PERL_IN_OP_C)\n#define apply_attrs(a,b,c)\tS_apply_attrs(aTHX_ a,b,c)\n#define apply_attrs_my(a,b,c,d)\tS_apply_attrs_my(aTHX_ a,b,c,d)\n#define assignment_type(a)\tS_assignment_type(aTHX_ a)\n#define bad_type_gv(a,b,c,d)\tS_bad_type_gv(aTHX_ a,b,c,d)\n#define bad_type_pv(a,b,c,d)\tS_bad_type_pv(aTHX_ a,b,c,d)\n#define clear_special_blocks(a,b,c)\tS_clear_special_blocks(aTHX_ a,b,c)\n#define cop_free(a)\t\tS_cop_free(aTHX_ a)\n#define dup_attrlist(a)\t\tS_dup_attrlist(aTHX_ a)\n#define finalize_op(a)\t\tS_finalize_op(aTHX_ a)\n#define find_and_forget_pmops(a)\tS_find_and_forget_pmops(aTHX_ a)\n#define fold_constants(a)\tS_fold_constants(aTHX_ a)\n#define force_list(a,b)\t\tS_force_list(aTHX_ a,b)\n#define forget_pmop(a)\t\tS_forget_pmop(aTHX_ a)\n#define gen_constant_list(a)\tS_gen_constant_list(aTHX_ a)\n#define inplace_aassign(a)\tS_inplace_aassign(aTHX_ a)\n#define is_handle_constructor\tS_is_handle_constructor\n#define listkids(a)\t\tS_listkids(aTHX_ a)\n#define looks_like_bool(a)\tS_looks_like_bool(aTHX_ a)\n#define modkids(a,b)\t\tS_modkids(aTHX_ a,b)\n#define move_proto_attr(a,b,c,d)\tS_move_proto_attr(aTHX_ a,b,c,d)\n#define my_kid(a,b,c)\t\tS_my_kid(aTHX_ a,b,c)\n#define newGIVWHENOP(a,b,c,d,e)\tS_newGIVWHENOP(aTHX_ a,b,c,d,e)\n#define newMETHOP_internal(a,b,c,d)\tS_newMETHOP_internal(aTHX_ a,b,c,d)\n#define new_logop(a,b,c,d)\tS_new_logop(aTHX_ a,b,c,d)\n#define no_bareword_allowed(a)\tS_no_bareword_allowed(aTHX_ a)\n#define no_fh_allowed(a)\tS_no_fh_allowed(aTHX_ a)\n#define op_integerize(a)\tS_op_integerize(aTHX_ a)\n#define op_std_init(a)\t\tS_op_std_init(aTHX_ a)\n#define optimize_op(a)\t\tS_optimize_op(aTHX_ a)\n#define pmtrans(a,b,c)\t\tS_pmtrans(aTHX_ a,b,c)\n#define process_special_blocks(a,b,c,d)\tS_process_special_blocks(aTHX_ a,b,c,d)\n#define ref_array_or_hash(a)\tS_ref_array_or_hash(aTHX_ a)\n#define refkids(a,b)\t\tS_refkids(aTHX_ a,b)\n#define scalar_mod_type\t\tS_scalar_mod_type\n#define scalarboolean(a)\tS_scalarboolean(aTHX_ a)\n#define scalarkids(a)\t\tS_scalarkids(aTHX_ a)\n#define scalarseq(a)\t\tS_scalarseq(aTHX_ a)\n#define search_const(a)\t\tS_search_const(aTHX_ a)\n#define simplify_sort(a)\tS_simplify_sort(aTHX_ a)\n#define too_few_arguments_pv(a,b,c)\tS_too_few_arguments_pv(aTHX_ a,b,c)\n#define too_many_arguments_pv(a,b,c)\tS_too_many_arguments_pv(aTHX_ a,b,c)\n#define traverse_op_tree(a,b)\tS_traverse_op_tree(aTHX_ a,b)\n#    if defined(USE_ITHREADS)\n#define op_relocate_sv(a,b)\tS_op_relocate_sv(aTHX_ a,b)\n#    endif\n#  endif\n#  if defined(PERL_IN_OP_C) || defined(PERL_IN_SV_C)\n#define report_redefined_cv(a,b,c)\tPerl_report_redefined_cv(aTHX_ a,b,c)\n#  endif\n#  if defined(PERL_IN_PAD_C)\n#define pad_alloc_name(a,b,c,d)\tS_pad_alloc_name(aTHX_ a,b,c,d)\n#define pad_check_dup(a,b,c)\tS_pad_check_dup(aTHX_ a,b,c)\n#define pad_findlex(a,b,c,d,e,f,g,h,i)\tS_pad_findlex(aTHX_ a,b,c,d,e,f,g,h,i)\n#define pad_reset()\t\tS_pad_reset(aTHX)\n#  endif\n#  if defined(PERL_IN_PERL_C)\n#define find_beginning(a,b)\tS_find_beginning(aTHX_ a,b)\n#define forbid_setid(a,b)\tS_forbid_setid(aTHX_ a,b)\n#define incpush(a,b,c)\t\tS_incpush(aTHX_ a,b,c)\n#define incpush_use_sep(a,b,c)\tS_incpush_use_sep(aTHX_ a,b,c)\n#define init_ids()\t\tS_init_ids(aTHX)\n#define init_interp()\t\tS_init_interp(aTHX)\n#define init_main_stash()\tS_init_main_stash(aTHX)\n#define init_perllib()\t\tS_init_perllib(aTHX)\n#define init_postdump_symbols(a,b,c)\tS_init_postdump_symbols(aTHX_ a,b,c)\n#define init_predump_symbols()\tS_init_predump_symbols(aTHX)\n#define mayberelocate(a,b,c)\tS_mayberelocate(aTHX_ a,b,c)\n#define minus_v()\t\tS_minus_v(aTHX)\n#define my_exit_jump()\t\tS_my_exit_jump(aTHX)\n#define nuke_stacks()\t\tS_nuke_stacks(aTHX)\n#define open_script(a,b,c)\tS_open_script(aTHX_ a,b,c)\n#define parse_body(a,b)\t\tS_parse_body(aTHX_ a,b)\n#define run_body(a)\t\tS_run_body(aTHX_ a)\n#define usage()\t\t\tS_usage(aTHX)\n#  endif\n#  if defined(PERL_IN_PP_C)\n#define do_chomp(a,b,c)\t\tS_do_chomp(aTHX_ a,b,c)\n#define do_delete_local()\tS_do_delete_local(aTHX)\n#define refto(a)\t\tS_refto(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_PP_CTL_C)\n#define check_type_and_open(a)\tS_check_type_and_open(aTHX_ a)\n#define destroy_matcher(a)\tS_destroy_matcher(aTHX_ a)\n#define do_smartmatch(a,b,c)\tS_do_smartmatch(aTHX_ a,b,c)\n#define docatch(a)\t\tS_docatch(aTHX_ a)\n#define doeval_compile(a,b,c,d)\tS_doeval_compile(aTHX_ a,b,c,d)\n#define dofindlabel(a,b,c,d,e,f)\tS_dofindlabel(aTHX_ a,b,c,d,e,f)\n#define doparseform(a)\t\tS_doparseform(aTHX_ a)\n#define dopoptoeval(a)\t\tS_dopoptoeval(aTHX_ a)\n#define dopoptogivenfor(a)\tS_dopoptogivenfor(aTHX_ a)\n#define dopoptolabel(a,b,c)\tS_dopoptolabel(aTHX_ a,b,c)\n#define dopoptoloop(a)\t\tS_dopoptoloop(aTHX_ a)\n#define dopoptosub_at(a,b)\tS_dopoptosub_at(aTHX_ a,b)\n#define dopoptowhen(a)\t\tS_dopoptowhen(aTHX_ a)\n#define make_matcher(a)\t\tS_make_matcher(aTHX_ a)\n#define matcher_matches_sv(a,b)\tS_matcher_matches_sv(aTHX_ a,b)\n#define num_overflow\t\tS_num_overflow\n#define path_is_searchable\tS_path_is_searchable\n#define run_user_filter(a,b,c)\tS_run_user_filter(aTHX_ a,b,c)\n#define rxres_free(a)\t\tS_rxres_free(aTHX_ a)\n#define rxres_restore(a,b)\tS_rxres_restore(aTHX_ a,b)\n#define save_lines(a,b)\t\tS_save_lines(aTHX_ a,b)\n#  endif\n#  if defined(PERL_IN_PP_HOT_C)\n#define do_oddball(a,b)\t\tS_do_oddball(aTHX_ a,b)\n#define opmethod_stash(a)\tS_opmethod_stash(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_PP_PACK_C)\n#define div128(a,b)\t\tS_div128(aTHX_ a,b)\n#define first_symbol\t\tS_first_symbol\n#define get_num(a,b)\t\tS_get_num(aTHX_ a,b)\n#define group_end(a,b,c)\tS_group_end(aTHX_ a,b,c)\n#define is_an_int(a,b)\t\tS_is_an_int(aTHX_ a,b)\n#define measure_struct(a)\tS_measure_struct(aTHX_ a)\n#define mul128(a,b)\t\tS_mul128(aTHX_ a,b)\n#define my_bytes_to_utf8\tS_my_bytes_to_utf8\n#define need_utf8\t\tS_need_utf8\n#define next_symbol(a)\t\tS_next_symbol(aTHX_ a)\n#define pack_rec(a,b,c,d)\tS_pack_rec(aTHX_ a,b,c,d)\n#define sv_exp_grow(a,b)\tS_sv_exp_grow(aTHX_ a,b)\n#define unpack_rec(a,b,c,d,e)\tS_unpack_rec(aTHX_ a,b,c,d,e)\n#  endif\n#  if defined(PERL_IN_PP_SORT_C)\n#define amagic_cmp(a,b)\t\tS_amagic_cmp(aTHX_ a,b)\n#define amagic_i_ncmp(a,b)\tS_amagic_i_ncmp(aTHX_ a,b)\n#define amagic_ncmp(a,b)\tS_amagic_ncmp(aTHX_ a,b)\n#define sortcv(a,b)\t\tS_sortcv(aTHX_ a,b)\n#define sortcv_stacked(a,b)\tS_sortcv_stacked(aTHX_ a,b)\n#define sortcv_xsub(a,b)\tS_sortcv_xsub(aTHX_ a,b)\n#define sv_i_ncmp(a,b)\t\tS_sv_i_ncmp(aTHX_ a,b)\n#define sv_ncmp(a,b)\t\tS_sv_ncmp(aTHX_ a,b)\n#    if defined(USE_LOCALE_COLLATE)\n#define amagic_cmp_locale(a,b)\tS_amagic_cmp_locale(aTHX_ a,b)\n#    endif\n#  endif\n#  if defined(PERL_IN_PP_SYS_C)\n#define doform(a,b,c)\t\tS_doform(aTHX_ a,b,c)\n#define space_join_names_mortal(a)\tS_space_join_names_mortal(aTHX_ a)\n#  endif\n#  if defined(PERL_IN_SCOPE_C)\n#define save_pushptri32ptr(a,b,c,d)\tS_save_pushptri32ptr(aTHX_ a,b,c,d)\n#define save_scalar_at(a,b)\tS_save_scalar_at(aTHX_ a,b)\n#  endif\n#  if defined(PERL_IN_SV_C)\n#define F0convert\t\tS_F0convert\n#define anonymise_cv_maybe(a,b)\tS_anonymise_cv_maybe(aTHX_ a,b)\n#define assert_uft8_cache_coherent(a,b,c,d)\tS_assert_uft8_cache_coherent(aTHX_ a,b,c,d)\n#define curse(a,b)\t\tS_curse(aTHX_ a,b)\n#define expect_number(a)\tS_expect_number(aTHX_ a)\n#define find_array_subscript(a,b)\tS_find_array_subscript(aTHX_ a,b)\n#define find_hash_subscript(a,b)\tS_find_hash_subscript(aTHX_ a,b)\n#define find_uninit_var(a,b,c,d)\tS_find_uninit_var(aTHX_ a,b,c,d)\n#define glob_2number(a)\t\tS_glob_2number(aTHX_ a)\n#define glob_assign_glob(a,b,c)\tS_glob_assign_glob(aTHX_ a,b,c)\n#define more_sv()\t\tS_more_sv(aTHX)\n#define not_a_number(a)\t\tS_not_a_number(aTHX_ a)\n#define not_incrementable(a)\tS_not_incrementable(aTHX_ a)\n#define ptr_table_find\t\tS_ptr_table_find\n#define sv_2iuv_common(a)\tS_sv_2iuv_common(aTHX_ a)\n#define sv_add_arena(a,b,c)\tS_sv_add_arena(aTHX_ a,b,c)\n#define sv_display(a,b,c)\tS_sv_display(aTHX_ a,b,c)\n#define sv_pos_b2u_midway(a,b,c,d)\tS_sv_pos_b2u_midway(aTHX_ a,b,c,d)\n#define sv_pos_u2b_cached(a,b,c,d,e,f,g)\tS_sv_pos_u2b_cached(aTHX_ a,b,c,d,e,f,g)\n#define sv_pos_u2b_forwards\tS_sv_pos_u2b_forwards\n#define sv_pos_u2b_midway\tS_sv_pos_u2b_midway\n#define sv_unglob(a,b)\t\tS_sv_unglob(aTHX_ a,b)\n#define uiv_2buf\t\tS_uiv_2buf\n#define utf8_mg_len_cache_update(a,b,c)\tS_utf8_mg_len_cache_update(aTHX_ a,b,c)\n#define utf8_mg_pos_cache_update(a,b,c,d,e)\tS_utf8_mg_pos_cache_update(aTHX_ a,b,c,d,e)\n#define visit(a,b,c)\t\tS_visit(aTHX_ a,b,c)\n#    if defined(USE_ITHREADS)\n#define sv_dup_common(a,b)\tS_sv_dup_common(aTHX_ a,b)\n#define sv_dup_inc_multiple(a,b,c,d)\tS_sv_dup_inc_multiple(aTHX_ a,b,c,d)\n#define unreferenced_to_tmp_stack(a)\tS_unreferenced_to_tmp_stack(aTHX_ a)\n#    endif\n#  endif\n#  if defined(PERL_IN_SV_C) || defined (PERL_IN_OP_C)\n#define varname(a,b,c,d,e,f)\tPerl_varname(aTHX_ a,b,c,d,e,f)\n#  endif\n#  if defined(PERL_IN_TOKE_C)\n#define ao(a)\t\t\tS_ao(aTHX_ a)\n#define check_uni()\t\tS_check_uni(aTHX)\n#define checkcomma(a,b,c)\tS_checkcomma(aTHX_ a,b,c)\n#define filter_gets(a,b)\tS_filter_gets(aTHX_ a,b)\n#define find_in_my_stash(a,b)\tS_find_in_my_stash(aTHX_ a,b)\n#define force_ident(a,b)\tS_force_ident(aTHX_ a,b)\n#define force_ident_maybe_lex(a)\tS_force_ident_maybe_lex(aTHX_ a)\n#define force_next(a)\t\tS_force_next(aTHX_ a)\n#define force_strict_version(a)\tS_force_strict_version(aTHX_ a)\n#define force_version(a,b)\tS_force_version(aTHX_ a,b)\n#define force_word(a,b,c,d)\tS_force_word(aTHX_ a,b,c,d)\n#define get_and_check_backslash_N_name_wrapper(a,b)\tS_get_and_check_backslash_N_name_wrapper(aTHX_ a,b)\n#define incline(a,b)\t\tS_incline(aTHX_ a,b)\n#define intuit_method(a,b,c)\tS_intuit_method(aTHX_ a,b,c)\n#define intuit_more(a,b)\tS_intuit_more(aTHX_ a,b)\n#define lop(a,b,c)\t\tS_lop(aTHX_ a,b,c)\n#define missingterm(a,b)\tS_missingterm(aTHX_ a,b)\n#define no_op(a,b)\t\tS_no_op(aTHX_ a,b)\n#define parse_ident(a,b,c,d,e,f,g)\tS_parse_ident(aTHX_ a,b,c,d,e,f,g)\n#define pending_ident()\t\tS_pending_ident(aTHX)\n#define scan_const(a)\t\tS_scan_const(aTHX_ a)\n#define scan_formline(a)\tS_scan_formline(aTHX_ a)\n#define scan_heredoc(a)\t\tS_scan_heredoc(aTHX_ a)\n#define scan_ident(a,b,c,d)\tS_scan_ident(aTHX_ a,b,c,d)\n#define scan_inputsymbol(a)\tS_scan_inputsymbol(aTHX_ a)\n#define scan_pat(a,b)\t\tS_scan_pat(aTHX_ a,b)\n#define scan_subst(a)\t\tS_scan_subst(aTHX_ a)\n#define scan_trans(a)\t\tS_scan_trans(aTHX_ a)\n#define sublex_done()\t\tS_sublex_done(aTHX)\n#define sublex_push()\t\tS_sublex_push(aTHX)\n#define sublex_start()\t\tS_sublex_start(aTHX)\n#define swallow_bom(a)\t\tS_swallow_bom(aTHX_ a)\n#define tokenize_use(a,b)\tS_tokenize_use(aTHX_ a,b)\n#define tokeq(a)\t\tS_tokeq(aTHX_ a)\n#define update_debugger_info(a,b,c)\tS_update_debugger_info(aTHX_ a,b,c)\n#define yywarn(a,b)\t\tS_yywarn(aTHX_ a,b)\n#  endif\n#  if defined(PERL_IN_UNIVERSAL_C)\n#define isa_lookup(a,b,c,d)\tS_isa_lookup(aTHX_ a,b,c,d)\n#  endif\n#  if defined(PERL_IN_UTF8_C)\n#define _to_utf8_case(a,b,c,d,e,f,g,h,i)\tS__to_utf8_case(aTHX_ a,b,c,d,e,f,g,h,i)\n#define check_and_deprecate(a,b,c,d,e,f)\tS_check_and_deprecate(aTHX_ a,b,c,d,e,f)\n#define check_locale_boundary_crossing(a,b,c,d)\tS_check_locale_boundary_crossing(aTHX_ a,b,c,d)\n#define does_utf8_overflow\tS_does_utf8_overflow\n#define isFF_OVERLONG\t\tS_isFF_OVERLONG\n#define is_utf8_common(a,b)\tS_is_utf8_common(aTHX_ a,b)\n#define is_utf8_common_with_len(a,b,c)\tS_is_utf8_common_with_len(aTHX_ a,b,c)\n#define is_utf8_overlong_given_start_byte_ok\tS_is_utf8_overlong_given_start_byte_ok\n#define new_msg_hv(a,b,c)\tS_new_msg_hv(aTHX_ a,b,c)\n#define swash_scan_list_line(a,b,c,d,e,f,g)\tS_swash_scan_list_line(aTHX_ a,b,c,d,e,f,g)\n#define swatch_get(a,b,c)\tS_swatch_get(aTHX_ a,b,c)\n#define to_lower_latin1\t\tS_to_lower_latin1\n#define turkic_fc(a,b,c,d)\tS_turkic_fc(aTHX_ a,b,c,d)\n#define turkic_lc(a,b,c,d)\tS_turkic_lc(aTHX_ a,b,c,d)\n#define turkic_uc(a,b,c,d)\tS_turkic_uc(aTHX_ a,b,c,d)\n#define unexpected_non_continuation_text(a,b,c,d)\tS_unexpected_non_continuation_text(aTHX_ a,b,c,d)\n#define warn_on_first_deprecated_use(a,b,c,d,e)\tS_warn_on_first_deprecated_use(aTHX_ a,b,c,d,e)\n#  endif\n#  if defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)\n#define _to_upper_title_latin1(a,b,c,d)\tPerl__to_upper_title_latin1(aTHX_ a,b,c,d)\n#  endif\n#  if defined(PERL_IN_UTIL_C)\n#define ckwarn_common(a)\tS_ckwarn_common(aTHX_ a)\n#define invoke_exception_hook(a,b)\tS_invoke_exception_hook(aTHX_ a,b)\n#define mess_alloc()\t\tS_mess_alloc(aTHX)\n#define with_queued_errors(a)\tS_with_queued_errors(aTHX_ a)\n#    if defined(PERL_MEM_LOG) && !defined(PERL_MEM_LOG_NOIMPL)\n#define mem_log_common\t\tS_mem_log_common\n#    endif\n#  endif\n#  if defined(PERL_MEM_LOG)\n#define mem_log_alloc\t\tPerl_mem_log_alloc\n#define mem_log_free\t\tPerl_mem_log_free\n#define mem_log_realloc\t\tPerl_mem_log_realloc\n#  endif\n#  if defined(PERL_USES_PL_PIDSTATUS) && defined(PERL_IN_UTIL_C)\n#define pidgone(a,b)\t\tS_pidgone(aTHX_ a,b)\n#  endif\n#  if defined(USE_C_BACKTRACE)\n#define get_c_backtrace(a,b)\tPerl_get_c_backtrace(aTHX_ a,b)\n#  endif\n#  if defined(USE_ITHREADS)\n#define mro_meta_dup(a,b)\tPerl_mro_meta_dup(aTHX_ a,b)\n#define padlist_dup(a,b)\tPerl_padlist_dup(aTHX_ a,b)\n#define padname_dup(a,b)\tPerl_padname_dup(aTHX_ a,b)\n#define padnamelist_dup(a,b)\tPerl_padnamelist_dup(aTHX_ a,b)\n#  endif\n#  if defined(USE_LOCALE_COLLATE)\n#define magic_setcollxfrm(a,b)\tPerl_magic_setcollxfrm(aTHX_ a,b)\n#ifndef NO_MATHOMS\n#define mem_collxfrm(a,b,c)\tPerl_mem_collxfrm(aTHX_ a,b,c)\n#endif\n#  endif\n#  if defined(USE_PERLIO)\n#define PerlIO_restore_errno(a)\tPerl_PerlIO_restore_errno(aTHX_ a)\n#define PerlIO_save_errno(a)\tPerl_PerlIO_save_errno(aTHX_ a)\n#  endif\n#  if defined(_MSC_VER)\n#define magic_regdatum_set(a,b)\tPerl_magic_regdatum_set(aTHX_ a,b)\n#  endif\n#endif\n\n#endif\t/* #ifndef PERL_NO_SHORT_NAMES */\n\n/* Compatibility stubs.  Compile extensions with -DPERL_NOCOMPAT to\n   disable them.\n */\n\n#if !defined(PERL_CORE)\n#  define sv_setptrobj(rv,ptr,name)\tsv_setref_iv(rv,name,PTR2IV(ptr))\n#  define sv_setptrref(rv,ptr)\t\tsv_setref_iv(rv,NULL,PTR2IV(ptr))\n#endif\n\n#if !defined(PERL_CORE) && !defined(PERL_NOCOMPAT)\n\n/* Compatibility for various misnamed functions.  All functions\n   in the API that begin with \"perl_\" (not \"Perl_\") take an explicit\n   interpreter context pointer.\n   The following are not like that, but since they had a \"perl_\"\n   prefix in previous versions, we provide compatibility macros.\n */\n#  define perl_atexit(a,b)\t\tcall_atexit(a,b)\n#  define perl_call_argv(a,b,c)\t\tcall_argv(a,b,c)\n#  define perl_call_method(a,b)\t\tcall_method(a,b)\n#  define perl_call_pv(a,b)\t\tcall_pv(a,b)\n#  define perl_call_sv(a,b)\t\tcall_sv(a,b)\n#  define perl_eval_pv(a,b)\t\teval_pv(a,b)\n#  define perl_eval_sv(a,b)\t\teval_sv(a,b)\n#  define perl_get_av(a,b)\t\tget_av(a,b)\n#  define perl_get_cv(a,b)\t\tget_cv(a,b)\n#  define perl_get_hv(a,b)\t\tget_hv(a,b)\n#  define perl_get_sv(a,b)\t\tget_sv(a,b)\n#  define perl_init_i18nl10n(a)\t\tinit_i18nl10n(a)\n#  define perl_init_i18nl14n(a)\t\tinit_i18nl14n(a)\n#  define perl_require_pv(a)\t\trequire_pv(a)\n\n/* varargs functions can't be handled with CPP macros. :-(\n   This provides a set of compatibility functions that don't take\n   an extra argument but grab the context pointer using the macro\n   dTHX.\n */\n#if defined(PERL_IMPLICIT_CONTEXT) && !defined(PERL_NO_SHORT_NAMES)\n#  define croak\t\t\tPerl_croak_nocontext\n#  define deb\t\t\tPerl_deb_nocontext\n#  define die\t\t\tPerl_die_nocontext\n#  define form\t\t\tPerl_form_nocontext\n#  define load_module\t\tPerl_load_module_nocontext\n#  define mess\t\t\tPerl_mess_nocontext\n#  define newSVpvf\t\tPerl_newSVpvf_nocontext\n#  define sv_catpvf\t\tPerl_sv_catpvf_nocontext\n#  define sv_catpvf_mg\t\tPerl_sv_catpvf_mg_nocontext\n#  define sv_setpvf\t\tPerl_sv_setpvf_nocontext\n#  define sv_setpvf_mg\t\tPerl_sv_setpvf_mg_nocontext\n#  define warn\t\t\tPerl_warn_nocontext\n#  define warner\t\tPerl_warner_nocontext\n#endif\n\n#endif /* !defined(PERL_CORE) && !defined(PERL_NOCOMPAT) */\n\n#if !defined(PERL_IMPLICIT_CONTEXT)\n/* undefined symbols, point them back at the usual ones */\n#  define Perl_croak_nocontext\tPerl_croak\n#  define Perl_deb_nocontext\tPerl_deb\n#  define Perl_die_nocontext\tPerl_die\n#  define Perl_form_nocontext\tPerl_form\n#  define Perl_load_module_nocontext\tPerl_load_module\n#  define Perl_mess_nocontext\tPerl_mess\n#  define Perl_newSVpvf_nocontext\tPerl_newSVpvf\n#  define Perl_sv_catpvf_nocontext\tPerl_sv_catpvf\n#  define Perl_sv_catpvf_mg_nocontext\tPerl_sv_catpvf_mg\n#  define Perl_sv_setpvf_nocontext\tPerl_sv_setpvf\n#  define Perl_sv_setpvf_mg_nocontext\tPerl_sv_setpvf_mg\n#  define Perl_warn_nocontext\tPerl_warn\n#  define Perl_warner_nocontext\tPerl_warner\n#endif\n\n/* ex: set ro: */\n", "/* -*- buffer-read-only: t -*-\n *\n *    proto.h\n *\n *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others\n *\n *    You may distribute under the terms of either the GNU General Public\n *    License or the Artistic License, as specified in the README file.\n *\n * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n * This file is built by regen/embed.pl from data in embed.fnc,\n * regen/embed.pl, regen/opcodes, intrpvar.h and perlvars.h.\n * Any changes made here will be lost!\n *\n * Edit those files and run 'make regen_headers' to effect changes.\n */\n\nSTART_EXTERN_C\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tASCII_TO_NEED(const UV enc, const UV ch)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\nPERL_CALLCONV int\tPerl_Gv_AMupdate(pTHX_ HV* stash, bool destructing);\n#define PERL_ARGS_ASSERT_GV_AMUPDATE\t\\\n\tassert(stash)\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tNATIVE_TO_NEED(const UV enc, const UV ch)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\nPERL_CALLCONV const char *\tPerl_PerlIO_context_layers(pTHX_ const char *mode);\nPERL_CALLCONV int\tPerl_PerlLIO_dup2_cloexec(pTHX_ int oldfd, int newfd);\nPERL_CALLCONV int\tPerl_PerlLIO_dup_cloexec(pTHX_ int oldfd)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV int\tPerl_PerlLIO_open3_cloexec(pTHX_ const char *file, int flag, int perm)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PERLLIO_OPEN3_CLOEXEC\t\\\n\tassert(file)\n\nPERL_CALLCONV int\tPerl_PerlLIO_open_cloexec(pTHX_ const char *file, int flag)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PERLLIO_OPEN_CLOEXEC\t\\\n\tassert(file)\n\nPERL_CALLCONV const char*\tPerl_setlocale(const int category, const char* locale);\nPERL_CALLCONV void*\tPerl_Slab_Alloc(pTHX_ size_t sz)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_Slab_Free(pTHX_ void *op);\n#define PERL_ARGS_ASSERT_SLAB_FREE\t\\\n\tassert(op)\nPERL_CALLCONV char *\tPerl__byte_dump_string(pTHX_ const U8 * const start, const STRLEN len, const bool format);\n#define PERL_ARGS_ASSERT__BYTE_DUMP_STRING\t\\\n\tassert(start)\nPERL_CALLCONV void\tPerl__force_out_malformed_utf8_message(pTHX_ const U8 *const p, const U8 * const e, const U32 flags, const bool die_here);\n#define PERL_ARGS_ASSERT__FORCE_OUT_MALFORMED_UTF8_MESSAGE\t\\\n\tassert(p); assert(e)\nPERL_CALLCONV Size_t\tPerl__inverse_folds(pTHX_ const UV cp, unsigned int * first_folds_to, const unsigned int ** remaining_folds_to)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__INVERSE_FOLDS\t\\\n\tassert(first_folds_to); assert(remaining_folds_to)\n\nPERL_CALLCONV bool\tPerl__is_in_locale_category(pTHX_ const bool compiling, const int category);\nPERL_CALLCONV bool\tPerl__is_uni_FOO(pTHX_ const U8 classnum, const UV c)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl__is_uni_perl_idcont(pTHX_ UV c)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl__is_uni_perl_idstart(pTHX_ UV c)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl__is_utf8_FOO(pTHX_ U8 classnum, const U8 * const p, const char * const name, const char * const alternative, const bool use_utf8, const bool use_locale, const char * const file, const unsigned line)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_FOO\t\\\n\tassert(p); assert(name); assert(alternative); assert(file)\n\nPERL_CALLCONV bool\tPerl__is_utf8_FOO_with_len(pTHX_ const U8 classnum, const U8 *p, const U8 * const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_FOO_WITH_LEN\t\\\n\tassert(p); assert(e)\n\nPERL_CALLCONV STRLEN\tPerl__is_utf8_char_helper(const U8 * const s, const U8 * e, const U32 flags)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#define PERL_ARGS_ASSERT__IS_UTF8_CHAR_HELPER\t\\\n\tassert(s); assert(e)\n\nPERL_CALLCONV bool\tPerl__is_utf8_idcont(pTHX_ const U8 *p)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_IDCONT\t\\\n\tassert(p)\n\nPERL_CALLCONV bool\tPerl__is_utf8_idstart(pTHX_ const U8 *p)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_IDSTART\t\\\n\tassert(p)\n\nPERL_CALLCONV bool\tPerl__is_utf8_mark(pTHX_ const U8 *p)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_MARK\t\\\n\tassert(p)\n\nPERL_CALLCONV bool\tPerl__is_utf8_perl_idcont_with_len(pTHX_ const U8 *p, const U8 * const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_PERL_IDCONT_WITH_LEN\t\\\n\tassert(p); assert(e)\n\nPERL_CALLCONV bool\tPerl__is_utf8_perl_idstart_with_len(pTHX_ const U8 *p, const U8 * const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_PERL_IDSTART_WITH_LEN\t\\\n\tassert(p); assert(e)\n\nPERL_CALLCONV bool\tPerl__is_utf8_xidcont(pTHX_ const U8 *p)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_XIDCONT\t\\\n\tassert(p)\n\nPERL_CALLCONV bool\tPerl__is_utf8_xidstart(pTHX_ const U8 *p)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_UTF8_XIDSTART\t\\\n\tassert(p)\n\nPERL_CALLCONV UV\tPerl__to_uni_fold_flags(pTHX_ UV c, U8 *p, STRLEN *lenp, U8 flags);\n#define PERL_ARGS_ASSERT__TO_UNI_FOLD_FLAGS\t\\\n\tassert(p); assert(lenp)\nPERL_CALLCONV UV\tPerl__to_utf8_fold_flags(pTHX_ const U8 *p, const U8 *e, U8* ustrp, STRLEN *lenp, U8 flags, const char * const file, const int line);\n#define PERL_ARGS_ASSERT__TO_UTF8_FOLD_FLAGS\t\\\n\tassert(p); assert(ustrp); assert(file)\nPERL_CALLCONV UV\tPerl__to_utf8_lower_flags(pTHX_ const U8 *p, const U8* e, U8* ustrp, STRLEN *lenp, bool flags, const char * const file, const int line);\n#define PERL_ARGS_ASSERT__TO_UTF8_LOWER_FLAGS\t\\\n\tassert(p); assert(ustrp); assert(file)\nPERL_CALLCONV UV\tPerl__to_utf8_title_flags(pTHX_ const U8 *p, const U8* e, U8* ustrp, STRLEN *lenp, bool flags, const char * const file, const int line);\n#define PERL_ARGS_ASSERT__TO_UTF8_TITLE_FLAGS\t\\\n\tassert(p); assert(ustrp); assert(file)\nPERL_CALLCONV UV\tPerl__to_utf8_upper_flags(pTHX_ const U8 *p, const U8 *e, U8* ustrp, STRLEN *lenp, bool flags, const char * const file, const int line);\n#define PERL_ARGS_ASSERT__TO_UTF8_UPPER_FLAGS\t\\\n\tassert(p); assert(ustrp); assert(file)\nPERL_CALLCONV UV\tPerl__utf8n_to_uvchr_msgs_helper(const U8 *s, STRLEN curlen, STRLEN *retlen, const U32 flags, U32 * errors, AV ** msgs);\n#define PERL_ARGS_ASSERT__UTF8N_TO_UVCHR_MSGS_HELPER\t\\\n\tassert(s)\nPERL_CALLCONV void\tPerl__warn_problematic_locale(void);\nPERL_CALLCONV_NO_RET void\tPerl_abort_execution(pTHX_ const char * const msg, const char * const name)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_ABORT_EXECUTION\t\\\n\tassert(msg); assert(name)\n\nPERL_CALLCONV LOGOP*\tPerl_alloc_LOGOP(pTHX_ I32 type, OP *first, OP *other);\nPERL_CALLCONV PADOFFSET\tPerl_allocmy(pTHX_ const char *const name, const STRLEN len, const U32 flags);\n#define PERL_ARGS_ASSERT_ALLOCMY\t\\\n\tassert(name)\nPERL_CALLCONV SV*\tPerl_amagic_call(pTHX_ SV* left, SV* right, int method, int dir);\n#define PERL_ARGS_ASSERT_AMAGIC_CALL\t\\\n\tassert(left); assert(right)\nPERL_CALLCONV SV *\tPerl_amagic_deref_call(pTHX_ SV *ref, int method);\n#define PERL_ARGS_ASSERT_AMAGIC_DEREF_CALL\t\\\n\tassert(ref)\nPERL_CALLCONV bool\tPerl_amagic_is_enabled(pTHX_ int method);\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_append_utf8_from_native_byte(const U8 byte, U8** dest);\n#define PERL_ARGS_ASSERT_APPEND_UTF8_FROM_NATIVE_BYTE\t\\\n\tassert(dest)\n#endif\nPERL_CALLCONV I32\tPerl_apply(pTHX_ I32 type, SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_APPLY\t\\\n\tassert(mark); assert(sp)\nPERL_CALLCONV void\tPerl_apply_attrs_string(pTHX_ const char *stashpv, CV *cv, const char *attrstr, STRLEN len);\n#define PERL_ARGS_ASSERT_APPLY_ATTRS_STRING\t\\\n\tassert(stashpv); assert(cv); assert(attrstr)\nPERL_CALLCONV void\tPerl_atfork_lock(void);\nPERL_CALLCONV void\tPerl_atfork_unlock(void);\nPERL_CALLCONV SV**\tPerl_av_arylen_p(pTHX_ AV *av);\n#define PERL_ARGS_ASSERT_AV_ARYLEN_P\t\\\n\tassert(av)\nPERL_CALLCONV void\tPerl_av_clear(pTHX_ AV *av);\n#define PERL_ARGS_ASSERT_AV_CLEAR\t\\\n\tassert(av)\nPERL_CALLCONV void\tPerl_av_create_and_push(pTHX_ AV **const avp, SV *const val);\n#define PERL_ARGS_ASSERT_AV_CREATE_AND_PUSH\t\\\n\tassert(avp); assert(val)\nPERL_CALLCONV SV**\tPerl_av_create_and_unshift_one(pTHX_ AV **const avp, SV *const val);\n#define PERL_ARGS_ASSERT_AV_CREATE_AND_UNSHIFT_ONE\t\\\n\tassert(avp); assert(val)\nPERL_CALLCONV SV*\tPerl_av_delete(pTHX_ AV *av, SSize_t key, I32 flags);\n#define PERL_ARGS_ASSERT_AV_DELETE\t\\\n\tassert(av)\nPERL_CALLCONV bool\tPerl_av_exists(pTHX_ AV *av, SSize_t key)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_AV_EXISTS\t\\\n\tassert(av)\n\nPERL_CALLCONV void\tPerl_av_extend(pTHX_ AV *av, SSize_t key);\n#define PERL_ARGS_ASSERT_AV_EXTEND\t\\\n\tassert(av)\nPERL_CALLCONV void\tPerl_av_extend_guts(pTHX_ AV *av, SSize_t key, SSize_t *maxp, SV ***allocp, SV ***arrayp);\n#define PERL_ARGS_ASSERT_AV_EXTEND_GUTS\t\\\n\tassert(maxp); assert(allocp); assert(arrayp)\nPERL_CALLCONV SV**\tPerl_av_fetch(pTHX_ AV *av, SSize_t key, I32 lval)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_AV_FETCH\t\\\n\tassert(av)\n\nPERL_CALLCONV void\tPerl_av_fill(pTHX_ AV *av, SSize_t fill);\n#define PERL_ARGS_ASSERT_AV_FILL\t\\\n\tassert(av)\nPERL_CALLCONV IV*\tPerl_av_iter_p(pTHX_ AV *av);\n#define PERL_ARGS_ASSERT_AV_ITER_P\t\\\n\tassert(av)\nPERL_CALLCONV SSize_t\tPerl_av_len(pTHX_ AV *av)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_AV_LEN\t\\\n\tassert(av)\n\nPERL_CALLCONV AV*\tPerl_av_make(pTHX_ SSize_t size, SV **strp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_AV_MAKE\t\\\n\tassert(strp)\n\nPERL_CALLCONV SV*\tPerl_av_nonelem(pTHX_ AV *av, SSize_t ix);\n#define PERL_ARGS_ASSERT_AV_NONELEM\t\\\n\tassert(av)\nPERL_CALLCONV SV*\tPerl_av_pop(pTHX_ AV *av);\n#define PERL_ARGS_ASSERT_AV_POP\t\\\n\tassert(av)\nPERL_CALLCONV void\tPerl_av_push(pTHX_ AV *av, SV *val);\n#define PERL_ARGS_ASSERT_AV_PUSH\t\\\n\tassert(av); assert(val)\nPERL_CALLCONV void\tPerl_av_reify(pTHX_ AV *av);\n#define PERL_ARGS_ASSERT_AV_REIFY\t\\\n\tassert(av)\nPERL_CALLCONV SV*\tPerl_av_shift(pTHX_ AV *av)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_AV_SHIFT\t\\\n\tassert(av)\n\nPERL_CALLCONV SV**\tPerl_av_store(pTHX_ AV *av, SSize_t key, SV *val);\n#define PERL_ARGS_ASSERT_AV_STORE\t\\\n\tassert(av)\n/* PERL_CALLCONV SSize_t\tPerl_av_tindex(pTHX_ AV *av)\n\t\t\t__attribute__warn_unused_result__; */\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE SSize_t\tS_av_top_index(pTHX_ AV *av)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_AV_TOP_INDEX\t\\\n\tassert(av)\n#endif\n\nPERL_CALLCONV void\tPerl_av_undef(pTHX_ AV *av);\n#define PERL_ARGS_ASSERT_AV_UNDEF\t\\\n\tassert(av)\nPERL_CALLCONV void\tPerl_av_unshift(pTHX_ AV *av, SSize_t num);\n#define PERL_ARGS_ASSERT_AV_UNSHIFT\t\\\n\tassert(av)\nPERL_CALLCONV OP*\tPerl_bind_match(pTHX_ I32 type, OP *left, OP *right)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_BIND_MATCH\t\\\n\tassert(left); assert(right)\n\nPERL_CALLCONV OP*\tPerl_block_end(pTHX_ I32 floor, OP* seq)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV U8\tPerl_block_gimme(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV int\tPerl_block_start(pTHX_ int full)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_blockhook_register(pTHX_ BHK *hk);\n#define PERL_ARGS_ASSERT_BLOCKHOOK_REGISTER\t\\\n\tassert(hk)\nPERL_CALLCONV void\tPerl_boot_core_PerlIO(pTHX);\nPERL_CALLCONV void\tPerl_boot_core_UNIVERSAL(pTHX);\nPERL_CALLCONV void\tPerl_boot_core_mro(pTHX);\nPERL_CALLCONV int\tPerl_bytes_cmp_utf8(pTHX_ const U8 *b, STRLEN blen, const U8 *u, STRLEN ulen);\n#define PERL_ARGS_ASSERT_BYTES_CMP_UTF8\t\\\n\tassert(b); assert(u)\nPERL_CALLCONV U8*\tPerl_bytes_from_utf8(pTHX_ const U8 *s, STRLEN *lenp, bool *is_utf8p);\n#define PERL_ARGS_ASSERT_BYTES_FROM_UTF8\t\\\n\tassert(s); assert(lenp); assert(is_utf8p)\nPERL_CALLCONV U8*\tPerl_bytes_from_utf8_loc(const U8 *s, STRLEN *lenp, bool *is_utf8p, const U8 ** first_unconverted);\n#define PERL_ARGS_ASSERT_BYTES_FROM_UTF8_LOC\t\\\n\tassert(s); assert(lenp); assert(is_utf8p)\nPERL_CALLCONV U8*\tPerl_bytes_to_utf8(pTHX_ const U8 *s, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_BYTES_TO_UTF8\t\\\n\tassert(s); assert(lenp)\nPERL_CALLCONV I32\tPerl_call_argv(pTHX_ const char* sub_name, I32 flags, char** argv);\n#define PERL_ARGS_ASSERT_CALL_ARGV\t\\\n\tassert(sub_name); assert(argv)\nPERL_CALLCONV void\tPerl_call_atexit(pTHX_ ATEXIT_t fn, void *ptr);\nPERL_CALLCONV void\tPerl_call_list(pTHX_ I32 oldscope, AV *paramList);\n#define PERL_ARGS_ASSERT_CALL_LIST\t\\\n\tassert(paramList)\nPERL_CALLCONV I32\tPerl_call_method(pTHX_ const char* methname, I32 flags);\n#define PERL_ARGS_ASSERT_CALL_METHOD\t\\\n\tassert(methname)\nPERL_CALLCONV I32\tPerl_call_pv(pTHX_ const char* sub_name, I32 flags);\n#define PERL_ARGS_ASSERT_CALL_PV\t\\\n\tassert(sub_name)\nPERL_CALLCONV I32\tPerl_call_sv(pTHX_ SV* sv, volatile I32 flags);\n#define PERL_ARGS_ASSERT_CALL_SV\t\\\n\tassert(sv)\nPERL_CALLCONV const PERL_CONTEXT *\tPerl_caller_cx(pTHX_ I32 level, const PERL_CONTEXT **dbcxp);\nPERL_CALLCONV Malloc_t\tPerl_calloc(MEM_SIZE elements, MEM_SIZE size)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl_cando(pTHX_ Mode_t mode, bool effective, const Stat_t* statbufp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CANDO\t\\\n\tassert(statbufp)\n\nPERL_CALLCONV I32\tPerl_cast_i32(NV f)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV IV\tPerl_cast_iv(NV f)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV U32\tPerl_cast_ulong(NV f)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV UV\tPerl_cast_uv(NV f)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl_check_utf8_print(pTHX_ const U8 *s, const STRLEN len);\n#define PERL_ARGS_ASSERT_CHECK_UTF8_PRINT\t\\\n\tassert(s)\nPERL_CALLCONV OP *\tPerl_ck_anoncode(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_ANONCODE\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_backtick(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_BACKTICK\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_bitop(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_BITOP\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_cmp(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_CMP\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_concat(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_CONCAT\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_defined(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_DEFINED\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_delete(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_DELETE\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_each(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_EACH\t\\\n\tassert(o)\n\nPERL_CALLCONV OP*\tPerl_ck_entersub_args_core(pTHX_ OP *entersubop, GV *namegv, SV *protosv);\n#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_CORE\t\\\n\tassert(entersubop); assert(namegv); assert(protosv)\nPERL_CALLCONV OP*\tPerl_ck_entersub_args_list(pTHX_ OP *entersubop);\n#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_LIST\t\\\n\tassert(entersubop)\nPERL_CALLCONV OP*\tPerl_ck_entersub_args_proto(pTHX_ OP *entersubop, GV *namegv, SV *protosv);\n#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_PROTO\t\\\n\tassert(entersubop); assert(namegv); assert(protosv)\nPERL_CALLCONV OP*\tPerl_ck_entersub_args_proto_or_list(pTHX_ OP *entersubop, GV *namegv, SV *protosv);\n#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_PROTO_OR_LIST\t\\\n\tassert(entersubop); assert(namegv); assert(protosv)\nPERL_CALLCONV OP *\tPerl_ck_eof(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_EOF\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_eval(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_EVAL\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_exec(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_EXEC\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_exists(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_EXISTS\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_ftst(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_FTST\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_fun(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_FUN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_glob(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_GLOB\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_grep(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_GREP\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_index(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_INDEX\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_join(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_JOIN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_length(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_LENGTH\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_lfun(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_LFUN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_listiob(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_LISTIOB\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_match(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_MATCH\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_method(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_METHOD\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_null(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_NULL\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_open(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_OPEN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_prototype(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_PROTOTYPE\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_readline(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_READLINE\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_refassign(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_REFASSIGN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_repeat(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_REPEAT\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_require(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_REQUIRE\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_return(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_RETURN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_rfun(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_RFUN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_rvconst(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_RVCONST\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_sassign(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SASSIGN\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_select(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SELECT\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_shift(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SHIFT\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_smartmatch(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SMARTMATCH\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_sort(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SORT\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_spair(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SPAIR\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_split(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SPLIT\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_stringify(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_STRINGIFY\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_subr(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SUBR\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_substr(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SUBSTR\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_svconst(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_SVCONST\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_tell(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_TELL\t\\\n\tassert(o)\n\nPERL_CALLCONV OP *\tPerl_ck_trunc(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CK_TRUNC\t\\\n\tassert(o)\n\nPERL_CALLCONV void\tPerl_ck_warner(pTHX_ U32 err, const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_2,pTHX_3);\n#define PERL_ARGS_ASSERT_CK_WARNER\t\\\n\tassert(pat)\n\nPERL_CALLCONV void\tPerl_ck_warner_d(pTHX_ U32 err, const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_2,pTHX_3);\n#define PERL_ARGS_ASSERT_CK_WARNER_D\t\\\n\tassert(pat)\n\nPERL_CALLCONV bool\tPerl_ckwarn(pTHX_ U32 w)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV bool\tPerl_ckwarn_d(pTHX_ U32 w)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV void\tPerl_clear_defarray(pTHX_ AV* av, bool abandon);\n#define PERL_ARGS_ASSERT_CLEAR_DEFARRAY\t\\\n\tassert(av)\nPERL_CALLCONV const COP*\tPerl_closest_cop(pTHX_ const COP *cop, const OP *o, const OP *curop, bool opnext);\n#define PERL_ARGS_ASSERT_CLOSEST_COP\t\\\n\tassert(cop)\nPERL_CALLCONV const char *\tPerl_cop_fetch_label(pTHX_ COP *const cop, STRLEN *len, U32 *flags);\n#define PERL_ARGS_ASSERT_COP_FETCH_LABEL\t\\\n\tassert(cop)\nPERL_CALLCONV void\tPerl_cop_store_label(pTHX_ COP *const cop, const char *label, STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_COP_STORE_LABEL\t\\\n\tassert(cop); assert(label)\nPERL_CALLCONV SV *\tPerl_core_prototype(pTHX_ SV *sv, const char *name, const int code, int * const opnum);\n#define PERL_ARGS_ASSERT_CORE_PROTOTYPE\t\\\n\tassert(name)\nPERL_CALLCONV OP *\tPerl_coresub_op(pTHX_ SV *const coreargssv, const int code, const int opnum);\n#define PERL_ARGS_ASSERT_CORESUB_OP\t\\\n\tassert(coreargssv)\nPERL_CALLCONV void\tPerl_create_eval_scope(pTHX_ OP *retop, U32 flags);\nPERL_CALLCONV_NO_RET void\tPerl_croak(pTHX_ const char* pat, ...)\n\t\t\t__attribute__noreturn__\n\t\t\t__attribute__format__null_ok__(__printf__,pTHX_1,pTHX_2);\n\nPERL_CALLCONV_NO_RET void\tPerl_croak_caller(const char* pat, ...)\n\t\t\t__attribute__noreturn__\n\t\t\t__attribute__format__null_ok__(__printf__,1,2);\n\nPERL_STATIC_NO_RET void\tS_croak_memory_wrap(void)\n\t\t\t__attribute__noreturn__;\n\nPERL_CALLCONV_NO_RET void\tPerl_croak_no_mem(void)\n\t\t\t__attribute__noreturn__;\n\nPERL_CALLCONV_NO_RET void\tPerl_croak_no_modify(void)\n\t\t\t__attribute__noreturn__;\n\nPERL_CALLCONV_NO_RET void\tPerl_croak_popstack(void)\n\t\t\t__attribute__noreturn__;\n\nPERL_CALLCONV_NO_RET void\tPerl_croak_sv(pTHX_ SV *baseex)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_CROAK_SV\t\\\n\tassert(baseex)\n\nPERL_CALLCONV_NO_RET void\tPerl_croak_xs_usage(const CV *const cv, const char *const params)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_CROAK_XS_USAGE\t\\\n\tassert(cv); assert(params)\n\nPERL_CALLCONV regexp_engine const *\tPerl_current_re_engine(pTHX);\n#ifndef NO_MATHOMS\nPERL_CALLCONV const char *\tPerl_custom_op_desc(pTHX_ const OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CUSTOM_OP_DESC\t\\\n\tassert(o)\n#endif\n\nPERL_CALLCONV XOPRETANY\tPerl_custom_op_get_field(pTHX_ const OP *o, const xop_flags_enum field)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CUSTOM_OP_GET_FIELD\t\\\n\tassert(o)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV const char *\tPerl_custom_op_name(pTHX_ const OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CUSTOM_OP_NAME\t\\\n\tassert(o)\n#endif\n\nPERL_CALLCONV void\tPerl_custom_op_register(pTHX_ Perl_ppaddr_t ppaddr, const XOP *xop);\n#define PERL_ARGS_ASSERT_CUSTOM_OP_REGISTER\t\\\n\tassert(ppaddr); assert(xop)\n/* PERL_CALLCONV const XOP *\tPerl_custom_op_xop(pTHX_ const OP *o); */\nPERL_CALLCONV void\tPerl_cv_ckproto_len_flags(pTHX_ const CV* cv, const GV* gv, const char* p, const STRLEN len, const U32 flags);\n#define PERL_ARGS_ASSERT_CV_CKPROTO_LEN_FLAGS\t\\\n\tassert(cv)\nPERL_CALLCONV CV*\tPerl_cv_clone(pTHX_ CV* proto);\n#define PERL_ARGS_ASSERT_CV_CLONE\t\\\n\tassert(proto)\nPERL_CALLCONV CV*\tPerl_cv_clone_into(pTHX_ CV* proto, CV *target);\n#define PERL_ARGS_ASSERT_CV_CLONE_INTO\t\\\n\tassert(proto); assert(target)\nPERL_CALLCONV SV*\tPerl_cv_const_sv(const CV *const cv)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_cv_const_sv_or_av(const CV *const cv)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_cv_forget_slab(pTHX_ CV *cv);\nPERL_CALLCONV void\tPerl_cv_get_call_checker(pTHX_ CV *cv, Perl_call_checker *ckfun_p, SV **ckobj_p);\n#define PERL_ARGS_ASSERT_CV_GET_CALL_CHECKER\t\\\n\tassert(cv); assert(ckfun_p); assert(ckobj_p)\nPERL_CALLCONV void\tPerl_cv_get_call_checker_flags(pTHX_ CV *cv, U32 gflags, Perl_call_checker *ckfun_p, SV **ckobj_p, U32 *ckflags_p);\n#define PERL_ARGS_ASSERT_CV_GET_CALL_CHECKER_FLAGS\t\\\n\tassert(cv); assert(ckfun_p); assert(ckobj_p); assert(ckflags_p)\nPERL_CALLCONV SV *\tPerl_cv_name(pTHX_ CV *cv, SV *sv, U32 flags);\n#define PERL_ARGS_ASSERT_CV_NAME\t\\\n\tassert(cv)\nPERL_CALLCONV void\tPerl_cv_set_call_checker(pTHX_ CV *cv, Perl_call_checker ckfun, SV *ckobj);\n#define PERL_ARGS_ASSERT_CV_SET_CALL_CHECKER\t\\\n\tassert(cv); assert(ckfun); assert(ckobj)\nPERL_CALLCONV void\tPerl_cv_set_call_checker_flags(pTHX_ CV *cv, Perl_call_checker ckfun, SV *ckobj, U32 ckflags);\n#define PERL_ARGS_ASSERT_CV_SET_CALL_CHECKER_FLAGS\t\\\n\tassert(cv); assert(ckfun); assert(ckobj)\nPERL_CALLCONV void\tPerl_cv_undef(pTHX_ CV* cv);\n#define PERL_ARGS_ASSERT_CV_UNDEF\t\\\n\tassert(cv)\nPERL_CALLCONV void\tPerl_cv_undef_flags(pTHX_ CV* cv, U32 flags);\n#define PERL_ARGS_ASSERT_CV_UNDEF_FLAGS\t\\\n\tassert(cv)\nPERL_CALLCONV GV *\tPerl_cvgv_from_hek(pTHX_ CV* cv);\n#define PERL_ARGS_ASSERT_CVGV_FROM_HEK\t\\\n\tassert(cv)\nPERL_CALLCONV void\tPerl_cvgv_set(pTHX_ CV* cv, GV* gv);\n#define PERL_ARGS_ASSERT_CVGV_SET\t\\\n\tassert(cv)\nPERL_CALLCONV void\tPerl_cvstash_set(pTHX_ CV* cv, HV* stash);\n#define PERL_ARGS_ASSERT_CVSTASH_SET\t\\\n\tassert(cv)\nPERL_CALLCONV void\tPerl_cx_dump(pTHX_ PERL_CONTEXT* cx);\n#define PERL_ARGS_ASSERT_CX_DUMP\t\\\n\tassert(cx)\nPERL_CALLCONV I32\tPerl_cxinc(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_deb(pTHX_ const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_1,pTHX_2);\n#define PERL_ARGS_ASSERT_DEB\t\\\n\tassert(pat)\n\nPERL_CALLCONV void\tPerl_deb_stack_all(pTHX);\nPERL_CALLCONV I32\tPerl_debop(pTHX_ const OP* o);\n#define PERL_ARGS_ASSERT_DEBOP\t\\\n\tassert(o)\nPERL_CALLCONV void\tPerl_debprofdump(pTHX);\nPERL_CALLCONV I32\tPerl_debstack(pTHX);\nPERL_CALLCONV I32\tPerl_debstackptrs(pTHX);\nPERL_CALLCONV SV *\tPerl_defelem_target(pTHX_ SV *sv, MAGIC *mg)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DEFELEM_TARGET\t\\\n\tassert(sv)\n\nPERL_CALLCONV void\tPerl_delete_eval_scope(pTHX);\nPERL_CALLCONV char*\tPerl_delimcpy(char* to, const char* toend, const char* from, const char* fromend, int delim, I32* retlen);\n#define PERL_ARGS_ASSERT_DELIMCPY\t\\\n\tassert(to); assert(toend); assert(from); assert(fromend); assert(retlen)\nPERL_CALLCONV char*\tPerl_delimcpy_no_escape(char* to, const char* toend, const char* from, const char* fromend, int delim, I32* retlen);\n#define PERL_ARGS_ASSERT_DELIMCPY_NO_ESCAPE\t\\\n\tassert(to); assert(toend); assert(from); assert(fromend); assert(retlen)\nPERL_CALLCONV void\tPerl_despatch_signals(pTHX);\nPERL_CALLCONV_NO_RET OP*\tPerl_die(pTHX_ const char* pat, ...)\n\t\t\t__attribute__noreturn__\n\t\t\t__attribute__format__null_ok__(__printf__,pTHX_1,pTHX_2);\n\nPERL_CALLCONV_NO_RET OP*\tPerl_die_sv(pTHX_ SV *baseex)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_DIE_SV\t\\\n\tassert(baseex)\n\nPERL_CALLCONV_NO_RET void\tPerl_die_unwind(pTHX_ SV* msv)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_DIE_UNWIND\t\\\n\tassert(msv)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_do_aexec(pTHX_ SV* really, SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_AEXEC\t\\\n\tassert(mark); assert(sp)\n#endif\nPERL_CALLCONV bool\tPerl_do_aexec5(pTHX_ SV* really, SV** mark, SV** sp, int fd, int do_report);\n#define PERL_ARGS_ASSERT_DO_AEXEC5\t\\\n\tassert(mark); assert(sp)\n#ifndef NO_MATHOMS\nPERL_CALLCONV int\tPerl_do_binmode(pTHX_ PerlIO *fp, int iotype, int mode);\n#define PERL_ARGS_ASSERT_DO_BINMODE\t\\\n\tassert(fp)\n#endif\nPERL_CALLCONV bool\tPerl_do_close(pTHX_ GV* gv, bool not_implicit);\nPERL_CALLCONV void\tPerl_do_dump_pad(pTHX_ I32 level, PerlIO *file, PADLIST *padlist, int full);\n#define PERL_ARGS_ASSERT_DO_DUMP_PAD\t\\\n\tassert(file)\nPERL_CALLCONV bool\tPerl_do_eof(pTHX_ GV* gv);\n#define PERL_ARGS_ASSERT_DO_EOF\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_do_gv_dump(pTHX_ I32 level, PerlIO *file, const char *name, GV *sv);\n#define PERL_ARGS_ASSERT_DO_GV_DUMP\t\\\n\tassert(file); assert(name)\nPERL_CALLCONV void\tPerl_do_gvgv_dump(pTHX_ I32 level, PerlIO *file, const char *name, GV *sv);\n#define PERL_ARGS_ASSERT_DO_GVGV_DUMP\t\\\n\tassert(file); assert(name)\nPERL_CALLCONV void\tPerl_do_hv_dump(pTHX_ I32 level, PerlIO *file, const char *name, HV *sv);\n#define PERL_ARGS_ASSERT_DO_HV_DUMP\t\\\n\tassert(file); assert(name)\nPERL_CALLCONV void\tPerl_do_join(pTHX_ SV *sv, SV *delim, SV **mark, SV **sp);\n#define PERL_ARGS_ASSERT_DO_JOIN\t\\\n\tassert(sv); assert(delim); assert(mark); assert(sp)\nPERL_CALLCONV void\tPerl_do_magic_dump(pTHX_ I32 level, PerlIO *file, const MAGIC *mg, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim);\n#define PERL_ARGS_ASSERT_DO_MAGIC_DUMP\t\\\n\tassert(file)\nPERL_CALLCONV I32\tPerl_do_ncmp(pTHX_ SV *const left, SV *const right)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_NCMP\t\\\n\tassert(left); assert(right)\n\nPERL_CALLCONV void\tPerl_do_op_dump(pTHX_ I32 level, PerlIO *file, const OP *o);\n#define PERL_ARGS_ASSERT_DO_OP_DUMP\t\\\n\tassert(file)\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_do_open(pTHX_ GV* gv, const char* name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO* supplied_fp);\n#define PERL_ARGS_ASSERT_DO_OPEN\t\\\n\tassert(gv); assert(name)\n#endif\nPERL_CALLCONV bool\tPerl_do_open6(pTHX_ GV *gv, const char *oname, STRLEN len, PerlIO *supplied_fp, SV **svp, U32 num);\n#define PERL_ARGS_ASSERT_DO_OPEN6\t\\\n\tassert(gv); assert(oname)\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_do_open9(pTHX_ GV *gv, const char *name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO *supplied_fp, SV *svs, I32 num);\n#define PERL_ARGS_ASSERT_DO_OPEN9\t\\\n\tassert(gv); assert(name); assert(svs)\n#endif\nPERL_CALLCONV bool\tPerl_do_open_raw(pTHX_ GV *gv, const char *oname, STRLEN len, int rawmode, int rawperm, Stat_t *statbufp);\n#define PERL_ARGS_ASSERT_DO_OPEN_RAW\t\\\n\tassert(gv); assert(oname)\nPERL_CALLCONV bool\tPerl_do_openn(pTHX_ GV *gv, const char *oname, I32 len, int as_raw, int rawmode, int rawperm, PerlIO *supplied_fp, SV **svp, I32 num);\n#define PERL_ARGS_ASSERT_DO_OPENN\t\\\n\tassert(gv); assert(oname)\nPERL_CALLCONV void\tPerl_do_pmop_dump(pTHX_ I32 level, PerlIO *file, const PMOP *pm);\n#define PERL_ARGS_ASSERT_DO_PMOP_DUMP\t\\\n\tassert(file)\nPERL_CALLCONV bool\tPerl_do_print(pTHX_ SV* sv, PerlIO* fp);\n#define PERL_ARGS_ASSERT_DO_PRINT\t\\\n\tassert(fp)\nPERL_CALLCONV OP*\tPerl_do_readline(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl_do_seek(pTHX_ GV* gv, Off_t pos, int whence);\nPERL_CALLCONV void\tPerl_do_sprintf(pTHX_ SV* sv, SSize_t len, SV** sarg);\n#define PERL_ARGS_ASSERT_DO_SPRINTF\t\\\n\tassert(sv); assert(sarg)\nPERL_CALLCONV void\tPerl_do_sv_dump(pTHX_ I32 level, PerlIO *file, SV *sv, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim);\n#define PERL_ARGS_ASSERT_DO_SV_DUMP\t\\\n\tassert(file)\nPERL_CALLCONV Off_t\tPerl_do_sysseek(pTHX_ GV* gv, Off_t pos, int whence);\n#define PERL_ARGS_ASSERT_DO_SYSSEEK\t\\\n\tassert(gv)\nPERL_CALLCONV Off_t\tPerl_do_tell(pTHX_ GV* gv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_TELL\t\\\n\tassert(gv)\n\nPERL_CALLCONV Size_t\tPerl_do_trans(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_DO_TRANS\t\\\n\tassert(sv)\nPERL_CALLCONV UV\tPerl_do_vecget(pTHX_ SV* sv, STRLEN offset, int size);\n#define PERL_ARGS_ASSERT_DO_VECGET\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_do_vecset(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_DO_VECSET\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_do_vop(pTHX_ I32 optype, SV* sv, SV* left, SV* right);\n#define PERL_ARGS_ASSERT_DO_VOP\t\\\n\tassert(sv); assert(left); assert(right)\nPERL_CALLCONV OP*\tPerl_dofile(pTHX_ OP* term, I32 force_builtin);\n#define PERL_ARGS_ASSERT_DOFILE\t\\\n\tassert(term)\nPERL_CALLCONV bool\tPerl_doing_taint(int argc, char** argv, char** env)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP *\tPerl_doref(pTHX_ OP *o, I32 type, bool set_op_ref);\n#define PERL_ARGS_ASSERT_DOREF\t\\\n\tassert(o)\nPERL_CALLCONV void\tPerl_dounwind(pTHX_ I32 cxix);\nPERL_CALLCONV U8\tPerl_dowantarray(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_drand48_init_r(perl_drand48_t *random_state, U32 seed);\n#define PERL_ARGS_ASSERT_DRAND48_INIT_R\t\\\n\tassert(random_state)\nPERL_CALLCONV double\tPerl_drand48_r(perl_drand48_t *random_state);\n#define PERL_ARGS_ASSERT_DRAND48_R\t\\\n\tassert(random_state)\nPERL_CALLCONV void\tPerl_dump_all(pTHX);\nPERL_CALLCONV void\tPerl_dump_all_perl(pTHX_ bool justperl);\nPERL_CALLCONV void\tPerl_dump_eval(pTHX);\nPERL_CALLCONV void\tPerl_dump_form(pTHX_ const GV* gv);\n#define PERL_ARGS_ASSERT_DUMP_FORM\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_dump_indent(pTHX_ I32 level, PerlIO *file, const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_3,pTHX_4);\n#define PERL_ARGS_ASSERT_DUMP_INDENT\t\\\n\tassert(file); assert(pat)\n\nPERL_CALLCONV void\tPerl_dump_packsubs(pTHX_ const HV* stash);\n#define PERL_ARGS_ASSERT_DUMP_PACKSUBS\t\\\n\tassert(stash)\nPERL_CALLCONV void\tPerl_dump_packsubs_perl(pTHX_ const HV* stash, bool justperl);\n#define PERL_ARGS_ASSERT_DUMP_PACKSUBS_PERL\t\\\n\tassert(stash)\nPERL_CALLCONV void\tPerl_dump_sub(pTHX_ const GV* gv);\n#define PERL_ARGS_ASSERT_DUMP_SUB\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_dump_sub_perl(pTHX_ const GV* gv, bool justperl);\n#define PERL_ARGS_ASSERT_DUMP_SUB_PERL\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_dump_vindent(pTHX_ I32 level, PerlIO *file, const char* pat, va_list *args);\n#define PERL_ARGS_ASSERT_DUMP_VINDENT\t\\\n\tassert(file); assert(pat)\nPERL_CALLCONV STRLEN*\tPerl_dup_warnings(pTHX_ STRLEN* warnings);\nPERL_CALLCONV void\tPerl_emulate_cop_io(pTHX_ const COP *const c, SV *const sv);\n#define PERL_ARGS_ASSERT_EMULATE_COP_IO\t\\\n\tassert(c); assert(sv)\nPERL_CALLCONV SV*\tPerl_eval_pv(pTHX_ const char* p, I32 croak_on_error);\n#define PERL_ARGS_ASSERT_EVAL_PV\t\\\n\tassert(p)\nPERL_CALLCONV I32\tPerl_eval_sv(pTHX_ SV* sv, I32 flags);\n#define PERL_ARGS_ASSERT_EVAL_SV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_fbm_compile(pTHX_ SV* sv, U32 flags);\n#define PERL_ARGS_ASSERT_FBM_COMPILE\t\\\n\tassert(sv)\nPERL_CALLCONV char*\tPerl_fbm_instr(pTHX_ unsigned char* big, unsigned char* bigend, SV* littlestr, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FBM_INSTR\t\\\n\tassert(big); assert(bigend); assert(littlestr)\n\nPERL_CALLCONV bool\tPerl_feature_is_enabled(pTHX_ const char *const name, STRLEN namelen);\n#define PERL_ARGS_ASSERT_FEATURE_IS_ENABLED\t\\\n\tassert(name)\nPERL_CALLCONV SV*\tPerl_filter_add(pTHX_ filter_t funcp, SV* datasv);\nPERL_CALLCONV void\tPerl_filter_del(pTHX_ filter_t funcp);\n#define PERL_ARGS_ASSERT_FILTER_DEL\t\\\n\tassert(funcp)\nPERL_CALLCONV I32\tPerl_filter_read(pTHX_ int idx, SV *buf_sv, int maxlen)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FILTER_READ\t\\\n\tassert(buf_sv)\n\nPERL_CALLCONV void\tPerl_finalize_optree(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_FINALIZE_OPTREE\t\\\n\tassert(o)\nPERL_CALLCONV CV *\tPerl_find_lexical_cv(pTHX_ PADOFFSET off);\nPERL_CALLCONV CV*\tPerl_find_runcv(pTHX_ U32 *db_seqp)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV CV*\tPerl_find_runcv_where(pTHX_ U8 cond, IV arg, U32 *db_seqp)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_find_rundefsv(pTHX);\nPERL_CALLCONV PADOFFSET\tPerl_find_rundefsvoffset(pTHX)\n\t\t\t__attribute__deprecated__;\n\nPERL_CALLCONV char*\tPerl_find_script(pTHX_ const char *scriptname, bool dosearch, const char *const *const search_ext, I32 flags);\n#define PERL_ARGS_ASSERT_FIND_SCRIPT\t\\\n\tassert(scriptname)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE I32\tPerl_foldEQ(const char* a, const char* b, I32 len);\n#define PERL_ARGS_ASSERT_FOLDEQ\t\\\n\tassert(a); assert(b)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE I32\tPerl_foldEQ_latin1(const char* a, const char* b, I32 len);\n#define PERL_ARGS_ASSERT_FOLDEQ_LATIN1\t\\\n\tassert(a); assert(b)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE I32\tPerl_foldEQ_locale(const char* a, const char* b, I32 len);\n#define PERL_ARGS_ASSERT_FOLDEQ_LOCALE\t\\\n\tassert(a); assert(b)\n#endif\n/* PERL_CALLCONV I32\tfoldEQ_utf8(pTHX_ const char *s1, char **pe1, UV l1, bool u1, const char *s2, char **pe2, UV l2, bool u2); */\nPERL_CALLCONV I32\tPerl_foldEQ_utf8_flags(pTHX_ const char *s1, char **pe1, UV l1, bool u1, const char *s2, char **pe2, UV l2, bool u2, U32 flags);\n#define PERL_ARGS_ASSERT_FOLDEQ_UTF8_FLAGS\t\\\n\tassert(s1); assert(s2)\nPERL_CALLCONV char*\tPerl_form(pTHX_ const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_1,pTHX_2);\n#define PERL_ARGS_ASSERT_FORM\t\\\n\tassert(pat)\n\nPERL_CALLCONV void\tPerl_free_tied_hv_pool(pTHX);\nPERL_CALLCONV void\tPerl_free_tmps(pTHX);\nPERL_CALLCONV SV*\tPerl_get_and_check_backslash_N_name(pTHX_ const char* s, const char* const e, const bool is_utf8, const char** error_msg)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_AND_CHECK_BACKSLASH_N_NAME\t\\\n\tassert(s); assert(e); assert(error_msg)\n\nPERL_CALLCONV AV*\tPerl_get_av(pTHX_ const char *name, I32 flags);\n#define PERL_ARGS_ASSERT_GET_AV\t\\\n\tassert(name)\nPERL_CALLCONV void*\tPerl_get_context(void)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV CV*\tPerl_get_cv(pTHX_ const char* name, I32 flags);\n#define PERL_ARGS_ASSERT_GET_CV\t\\\n\tassert(name)\nPERL_CALLCONV CV*\tPerl_get_cvn_flags(pTHX_ const char* name, STRLEN len, I32 flags);\n#define PERL_ARGS_ASSERT_GET_CVN_FLAGS\t\\\n\tassert(name)\nPERL_CALLCONV void\tPerl_get_db_sub(pTHX_ SV **svp, CV *cv);\n#define PERL_ARGS_ASSERT_GET_DB_SUB\t\\\n\tassert(cv)\nPERL_CALLCONV void\tPerl_get_hash_seed(pTHX_ unsigned char * const seed_buffer);\n#define PERL_ARGS_ASSERT_GET_HASH_SEED\t\\\n\tassert(seed_buffer)\nPERL_CALLCONV HV*\tPerl_get_hv(pTHX_ const char *name, I32 flags);\n#define PERL_ARGS_ASSERT_GET_HV\t\\\n\tassert(name)\nPERL_CALLCONV const char*\tPerl_get_no_modify(pTHX)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV char**\tPerl_get_op_descs(pTHX)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV char**\tPerl_get_op_names(pTHX)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV U32*\tPerl_get_opargs(pTHX)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV PPADDR_t*\tPerl_get_ppaddr(pTHX)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV REGEXP *\tPerl_get_re_arg(pTHX_ SV *sv);\nPERL_CALLCONV SV*\tPerl_get_sv(pTHX_ const char *name, I32 flags);\n#define PERL_ARGS_ASSERT_GET_SV\t\\\n\tassert(name)\nPERL_CALLCONV MGVTBL*\tPerl_get_vtbl(pTHX_ int vtbl_id)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV int\tPerl_getcwd_sv(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_GETCWD_SV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_gp_free(pTHX_ GV* gv);\nPERL_CALLCONV GP*\tPerl_gp_ref(pTHX_ GP* gp);\nPERL_CALLCONV bool\tPerl_grok_atoUV(const char* pv, UV* valptr, const char** endptr);\n#define PERL_ARGS_ASSERT_GROK_ATOUV\t\\\n\tassert(pv); assert(valptr)\nPERL_CALLCONV UV\tPerl_grok_bin(pTHX_ const char* start, STRLEN* len_p, I32* flags, NV *result);\n#define PERL_ARGS_ASSERT_GROK_BIN\t\\\n\tassert(start); assert(len_p); assert(flags)\nPERL_CALLCONV UV\tPerl_grok_hex(pTHX_ const char* start, STRLEN* len_p, I32* flags, NV *result);\n#define PERL_ARGS_ASSERT_GROK_HEX\t\\\n\tassert(start); assert(len_p); assert(flags)\nPERL_CALLCONV int\tPerl_grok_infnan(pTHX_ const char** sp, const char *send);\n#define PERL_ARGS_ASSERT_GROK_INFNAN\t\\\n\tassert(sp); assert(send)\nPERL_CALLCONV int\tPerl_grok_number(pTHX_ const char *pv, STRLEN len, UV *valuep);\n#define PERL_ARGS_ASSERT_GROK_NUMBER\t\\\n\tassert(pv)\nPERL_CALLCONV int\tPerl_grok_number_flags(pTHX_ const char *pv, STRLEN len, UV *valuep, U32 flags);\n#define PERL_ARGS_ASSERT_GROK_NUMBER_FLAGS\t\\\n\tassert(pv)\nPERL_CALLCONV bool\tPerl_grok_numeric_radix(pTHX_ const char **sp, const char *send)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GROK_NUMERIC_RADIX\t\\\n\tassert(sp); assert(send)\n\nPERL_CALLCONV UV\tPerl_grok_oct(pTHX_ const char* start, STRLEN* len_p, I32* flags, NV *result);\n#define PERL_ARGS_ASSERT_GROK_OCT\t\\\n\tassert(start); assert(len_p); assert(flags)\n#ifndef NO_MATHOMS\nPERL_CALLCONV GV*\tPerl_gv_AVadd(pTHX_ GV *gv);\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV GV*\tPerl_gv_HVadd(pTHX_ GV *gv);\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV GV*\tPerl_gv_IOadd(pTHX_ GV* gv);\n#endif\nPERL_CALLCONV GV*\tPerl_gv_add_by_type(pTHX_ GV *gv, svtype type);\n/* PERL_CALLCONV GV*\tgv_autoload4(pTHX_ HV* stash, const char* name, STRLEN len, I32 method)\n\t\t\t__attribute__warn_unused_result__; */\n\nPERL_CALLCONV GV*\tPerl_gv_autoload_pv(pTHX_ HV* stash, const char* namepv, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GV_AUTOLOAD_PV\t\\\n\tassert(namepv)\n\nPERL_CALLCONV GV*\tPerl_gv_autoload_pvn(pTHX_ HV* stash, const char* name, STRLEN len, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GV_AUTOLOAD_PVN\t\\\n\tassert(name)\n\nPERL_CALLCONV GV*\tPerl_gv_autoload_sv(pTHX_ HV* stash, SV* namesv, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GV_AUTOLOAD_SV\t\\\n\tassert(namesv)\n\nPERL_CALLCONV void\tPerl_gv_check(pTHX_ HV* stash);\n#define PERL_ARGS_ASSERT_GV_CHECK\t\\\n\tassert(stash)\nPERL_CALLCONV SV*\tPerl_gv_const_sv(pTHX_ GV* gv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GV_CONST_SV\t\\\n\tassert(gv)\n\nPERL_CALLCONV void\tPerl_gv_dump(pTHX_ GV* gv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_gv_efullname(pTHX_ SV* sv, const GV* gv);\n#define PERL_ARGS_ASSERT_GV_EFULLNAME\t\\\n\tassert(sv); assert(gv)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_gv_efullname3(pTHX_ SV* sv, const GV* gv, const char* prefix);\n#define PERL_ARGS_ASSERT_GV_EFULLNAME3\t\\\n\tassert(sv); assert(gv)\n#endif\nPERL_CALLCONV void\tPerl_gv_efullname4(pTHX_ SV* sv, const GV* gv, const char* prefix, bool keepmain);\n#define PERL_ARGS_ASSERT_GV_EFULLNAME4\t\\\n\tassert(sv); assert(gv)\nPERL_CALLCONV GV*\tPerl_gv_fetchfile(pTHX_ const char* name);\n#define PERL_ARGS_ASSERT_GV_FETCHFILE\t\\\n\tassert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchfile_flags(pTHX_ const char *const name, const STRLEN len, const U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHFILE_FLAGS\t\\\n\tassert(name)\n/* PERL_CALLCONV GV*\tgv_fetchmeth(pTHX_ HV* stash, const char* name, STRLEN len, I32 level); */\n/* PERL_CALLCONV GV*\tgv_fetchmeth_autoload(pTHX_ HV* stash, const char* name, STRLEN len, I32 level); */\nPERL_CALLCONV GV*\tPerl_gv_fetchmeth_pv(pTHX_ HV* stash, const char* name, I32 level, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETH_PV\t\\\n\tassert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchmeth_pv_autoload(pTHX_ HV* stash, const char* name, I32 level, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETH_PV_AUTOLOAD\t\\\n\tassert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchmeth_pvn(pTHX_ HV* stash, const char* name, STRLEN len, I32 level, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETH_PVN\t\\\n\tassert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchmeth_pvn_autoload(pTHX_ HV* stash, const char* name, STRLEN len, I32 level, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETH_PVN_AUTOLOAD\t\\\n\tassert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchmeth_sv(pTHX_ HV* stash, SV* namesv, I32 level, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETH_SV\t\\\n\tassert(namesv)\nPERL_CALLCONV GV*\tPerl_gv_fetchmeth_sv_autoload(pTHX_ HV* stash, SV* namesv, I32 level, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETH_SV_AUTOLOAD\t\\\n\tassert(namesv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV GV*\tPerl_gv_fetchmethod(pTHX_ HV* stash, const char* name);\n#define PERL_ARGS_ASSERT_GV_FETCHMETHOD\t\\\n\tassert(stash); assert(name)\n#endif\nPERL_CALLCONV GV*\tPerl_gv_fetchmethod_autoload(pTHX_ HV* stash, const char* name, I32 autoload);\n#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_AUTOLOAD\t\\\n\tassert(stash); assert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchmethod_pv_flags(pTHX_ HV* stash, const char* name, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_PV_FLAGS\t\\\n\tassert(stash); assert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchmethod_pvn_flags(pTHX_ HV* stash, const char* name, const STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_PVN_FLAGS\t\\\n\tassert(stash); assert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchmethod_sv_flags(pTHX_ HV* stash, SV* namesv, U32 flags);\n#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_SV_FLAGS\t\\\n\tassert(stash); assert(namesv)\nPERL_CALLCONV GV*\tPerl_gv_fetchpv(pTHX_ const char *nambeg, I32 add, const svtype sv_type);\n#define PERL_ARGS_ASSERT_GV_FETCHPV\t\\\n\tassert(nambeg)\nPERL_CALLCONV GV*\tPerl_gv_fetchpvn_flags(pTHX_ const char* name, STRLEN len, I32 flags, const svtype sv_type);\n#define PERL_ARGS_ASSERT_GV_FETCHPVN_FLAGS\t\\\n\tassert(name)\nPERL_CALLCONV GV*\tPerl_gv_fetchsv(pTHX_ SV *name, I32 flags, const svtype sv_type);\n#define PERL_ARGS_ASSERT_GV_FETCHSV\t\\\n\tassert(name)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_gv_fullname(pTHX_ SV* sv, const GV* gv);\n#define PERL_ARGS_ASSERT_GV_FULLNAME\t\\\n\tassert(sv); assert(gv)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_gv_fullname3(pTHX_ SV* sv, const GV* gv, const char* prefix);\n#define PERL_ARGS_ASSERT_GV_FULLNAME3\t\\\n\tassert(sv); assert(gv)\n#endif\nPERL_CALLCONV void\tPerl_gv_fullname4(pTHX_ SV* sv, const GV* gv, const char* prefix, bool keepmain);\n#define PERL_ARGS_ASSERT_GV_FULLNAME4\t\\\n\tassert(sv); assert(gv)\nPERL_CALLCONV CV*\tPerl_gv_handler(pTHX_ HV* stash, I32 id)\n\t\t\t__attribute__warn_unused_result__;\n\n/* PERL_CALLCONV void\tgv_init(pTHX_ GV* gv, HV* stash, const char* name, STRLEN len, int multi); */\nPERL_CALLCONV void\tPerl_gv_init_pv(pTHX_ GV* gv, HV* stash, const char* name, U32 flags);\n#define PERL_ARGS_ASSERT_GV_INIT_PV\t\\\n\tassert(gv); assert(name)\nPERL_CALLCONV void\tPerl_gv_init_pvn(pTHX_ GV* gv, HV* stash, const char* name, STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_GV_INIT_PVN\t\\\n\tassert(gv); assert(name)\nPERL_CALLCONV void\tPerl_gv_init_sv(pTHX_ GV* gv, HV* stash, SV* namesv, U32 flags);\n#define PERL_ARGS_ASSERT_GV_INIT_SV\t\\\n\tassert(gv); assert(namesv)\nPERL_CALLCONV void\tPerl_gv_name_set(pTHX_ GV* gv, const char *name, U32 len, U32 flags);\n#define PERL_ARGS_ASSERT_GV_NAME_SET\t\\\n\tassert(gv); assert(name)\nPERL_CALLCONV GV *\tPerl_gv_override(pTHX_ const char * const name, const STRLEN len);\n#define PERL_ARGS_ASSERT_GV_OVERRIDE\t\\\n\tassert(name)\nPERL_CALLCONV void\tPerl_gv_setref(pTHX_ SV *const dstr, SV *const sstr);\n#define PERL_ARGS_ASSERT_GV_SETREF\t\\\n\tassert(dstr); assert(sstr)\nPERL_CALLCONV HV*\tPerl_gv_stashpv(pTHX_ const char* name, I32 flags);\n#define PERL_ARGS_ASSERT_GV_STASHPV\t\\\n\tassert(name)\nPERL_CALLCONV HV*\tPerl_gv_stashpvn(pTHX_ const char* name, U32 namelen, I32 flags);\n#define PERL_ARGS_ASSERT_GV_STASHPVN\t\\\n\tassert(name)\nPERL_CALLCONV HV*\tPerl_gv_stashsv(pTHX_ SV* sv, I32 flags);\n#define PERL_ARGS_ASSERT_GV_STASHSV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_gv_try_downgrade(pTHX_ GV* gv);\n#define PERL_ARGS_ASSERT_GV_TRY_DOWNGRADE\t\\\n\tassert(gv)\nPERL_CALLCONV AV**\tPerl_hv_backreferences_p(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_HV_BACKREFERENCES_P\t\\\n\tassert(hv)\nPERL_CALLCONV SV*\tPerl_hv_bucket_ratio(pTHX_ HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_BUCKET_RATIO\t\\\n\tassert(hv)\n\nPERL_CALLCONV void\tPerl_hv_clear(pTHX_ HV *hv);\nPERL_CALLCONV void\tPerl_hv_clear_placeholders(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_HV_CLEAR_PLACEHOLDERS\t\\\n\tassert(hv)\nPERL_CALLCONV void*\tPerl_hv_common(pTHX_ HV *hv, SV *keysv, const char* key, STRLEN klen, int flags, int action, SV *val, U32 hash);\nPERL_CALLCONV void*\tPerl_hv_common_key_len(pTHX_ HV *hv, const char *key, I32 klen_i32, const int action, SV *val, const U32 hash);\n#define PERL_ARGS_ASSERT_HV_COMMON_KEY_LEN\t\\\n\tassert(key)\nPERL_CALLCONV HV *\tPerl_hv_copy_hints_hv(pTHX_ HV *const ohv)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_hv_delayfree_ent(pTHX_ HV *hv, HE *entry);\n#define PERL_ARGS_ASSERT_HV_DELAYFREE_ENT\t\\\n\tassert(hv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV SV*\tPerl_hv_delete(pTHX_ HV *hv, const char *key, I32 klen, I32 flags);\n#define PERL_ARGS_ASSERT_HV_DELETE\t\\\n\tassert(key)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV SV*\tPerl_hv_delete_ent(pTHX_ HV *hv, SV *keysv, I32 flags, U32 hash);\n#define PERL_ARGS_ASSERT_HV_DELETE_ENT\t\\\n\tassert(keysv)\n#endif\nPERL_CALLCONV HE**\tPerl_hv_eiter_p(pTHX_ HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_EITER_P\t\\\n\tassert(hv)\n\nPERL_CALLCONV void\tPerl_hv_eiter_set(pTHX_ HV *hv, HE *eiter);\n#define PERL_ARGS_ASSERT_HV_EITER_SET\t\\\n\tassert(hv)\nPERL_CALLCONV void\tPerl_hv_ename_add(pTHX_ HV *hv, const char *name, U32 len, U32 flags);\n#define PERL_ARGS_ASSERT_HV_ENAME_ADD\t\\\n\tassert(hv); assert(name)\nPERL_CALLCONV void\tPerl_hv_ename_delete(pTHX_ HV *hv, const char *name, U32 len, U32 flags);\n#define PERL_ARGS_ASSERT_HV_ENAME_DELETE\t\\\n\tassert(hv); assert(name)\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_hv_exists(pTHX_ HV *hv, const char *key, I32 klen)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_EXISTS\t\\\n\tassert(key)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_hv_exists_ent(pTHX_ HV *hv, SV *keysv, U32 hash)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_EXISTS_ENT\t\\\n\tassert(keysv)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV SV**\tPerl_hv_fetch(pTHX_ HV *hv, const char *key, I32 klen, I32 lval);\n#define PERL_ARGS_ASSERT_HV_FETCH\t\\\n\tassert(key)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV HE*\tPerl_hv_fetch_ent(pTHX_ HV *hv, SV *keysv, I32 lval, U32 hash);\n#define PERL_ARGS_ASSERT_HV_FETCH_ENT\t\\\n\tassert(keysv)\n#endif\nPERL_CALLCONV STRLEN\tPerl_hv_fill(pTHX_ HV *const hv);\n#define PERL_ARGS_ASSERT_HV_FILL\t\\\n\tassert(hv)\nPERL_CALLCONV void\tPerl_hv_free_ent(pTHX_ HV *hv, HE *entry);\n#define PERL_ARGS_ASSERT_HV_FREE_ENT\t\\\n\tassert(hv)\nPERL_CALLCONV I32\tPerl_hv_iterinit(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_HV_ITERINIT\t\\\n\tassert(hv)\nPERL_CALLCONV char*\tPerl_hv_iterkey(pTHX_ HE* entry, I32* retlen)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_ITERKEY\t\\\n\tassert(entry); assert(retlen)\n\nPERL_CALLCONV SV*\tPerl_hv_iterkeysv(pTHX_ HE* entry)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_ITERKEYSV\t\\\n\tassert(entry)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV HE*\tPerl_hv_iternext(pTHX_ HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_ITERNEXT\t\\\n\tassert(hv)\n#endif\n\nPERL_CALLCONV HE*\tPerl_hv_iternext_flags(pTHX_ HV *hv, I32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_ITERNEXT_FLAGS\t\\\n\tassert(hv)\n\nPERL_CALLCONV SV*\tPerl_hv_iternextsv(pTHX_ HV *hv, char **key, I32 *retlen)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_ITERNEXTSV\t\\\n\tassert(hv); assert(key); assert(retlen)\n\nPERL_CALLCONV SV*\tPerl_hv_iterval(pTHX_ HV *hv, HE *entry)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_ITERVAL\t\\\n\tassert(hv); assert(entry)\n\nPERL_CALLCONV void\tPerl_hv_ksplit(pTHX_ HV *hv, IV newmax);\n#define PERL_ARGS_ASSERT_HV_KSPLIT\t\\\n\tassert(hv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_hv_magic(pTHX_ HV *hv, GV *gv, int how);\n#define PERL_ARGS_ASSERT_HV_MAGIC\t\\\n\tassert(hv)\n#endif\nPERL_CALLCONV void\tPerl_hv_name_set(pTHX_ HV *hv, const char *name, U32 len, U32 flags);\n#define PERL_ARGS_ASSERT_HV_NAME_SET\t\\\n\tassert(hv)\nPERL_CALLCONV I32\tPerl_hv_placeholders_get(pTHX_ const HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_PLACEHOLDERS_GET\t\\\n\tassert(hv)\n\nPERL_CALLCONV SSize_t*\tPerl_hv_placeholders_p(pTHX_ HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_PLACEHOLDERS_P\t\\\n\tassert(hv)\n\nPERL_CALLCONV void\tPerl_hv_placeholders_set(pTHX_ HV *hv, I32 ph);\n#define PERL_ARGS_ASSERT_HV_PLACEHOLDERS_SET\t\\\n\tassert(hv)\nPERL_CALLCONV void\tPerl_hv_pushkv(pTHX_ HV *hv, U32 flags);\n#define PERL_ARGS_ASSERT_HV_PUSHKV\t\\\n\tassert(hv)\nPERL_CALLCONV void\tPerl_hv_rand_set(pTHX_ HV *hv, U32 new_xhv_rand);\n#define PERL_ARGS_ASSERT_HV_RAND_SET\t\\\n\tassert(hv)\nPERL_CALLCONV I32*\tPerl_hv_riter_p(pTHX_ HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_RITER_P\t\\\n\tassert(hv)\n\nPERL_CALLCONV void\tPerl_hv_riter_set(pTHX_ HV *hv, I32 riter);\n#define PERL_ARGS_ASSERT_HV_RITER_SET\t\\\n\tassert(hv)\nPERL_CALLCONV SV*\tPerl_hv_scalar(pTHX_ HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HV_SCALAR\t\\\n\tassert(hv)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV SV**\tPerl_hv_store(pTHX_ HV *hv, const char *key, I32 klen, SV *val, U32 hash);\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV HE*\tPerl_hv_store_ent(pTHX_ HV *hv, SV *key, SV *val, U32 hash);\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV SV**\tPerl_hv_store_flags(pTHX_ HV *hv, const char *key, I32 klen, SV *val, U32 hash, int flags);\n#endif\n/* PERL_CALLCONV void\thv_undef(pTHX_ HV *hv); */\nPERL_CALLCONV void\tPerl_hv_undef_flags(pTHX_ HV *hv, U32 flags);\n/* PERL_CALLCONV I32\tibcmp(pTHX_ const char* a, const char* b, I32 len)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__; */\n\n/* PERL_CALLCONV I32\tibcmp_locale(pTHX_ const char* a, const char* b, I32 len)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__; */\n\n/* PERL_CALLCONV I32\tibcmp_utf8(pTHX_ const char *s1, char **pe1, UV l1, bool u1, const char *s2, char **pe2, UV l2, bool u2); */\nPERL_CALLCONV void\tPerl_init_argv_symbols(pTHX_ int argc, char **argv);\n#define PERL_ARGS_ASSERT_INIT_ARGV_SYMBOLS\t\\\n\tassert(argv)\nPERL_CALLCONV void\tPerl_init_constants(pTHX);\nPERL_CALLCONV void\tPerl_init_dbargs(pTHX);\nPERL_CALLCONV void\tPerl_init_debugger(pTHX);\nPERL_CALLCONV int\tPerl_init_i18nl10n(pTHX_ int printwarn);\n#ifndef NO_MATHOMS\nPERL_CALLCONV int\tPerl_init_i18nl14n(pTHX_ int printwarn);\n#endif\nPERL_CALLCONV void\tPerl_init_named_cv(pTHX_ CV *cv, OP *nameop);\n#define PERL_ARGS_ASSERT_INIT_NAMED_CV\t\\\n\tassert(cv); assert(nameop)\nPERL_CALLCONV void\tPerl_init_stacks(pTHX);\nPERL_CALLCONV void\tPerl_init_tm(pTHX_ struct tm *ptm);\n#define PERL_ARGS_ASSERT_INIT_TM\t\\\n\tassert(ptm)\nPERL_CALLCONV void\tPerl_init_uniprops(pTHX);\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_instr(const char* big, const char* little)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#define PERL_ARGS_ASSERT_INSTR\t\\\n\tassert(big); assert(little)\n#endif\n\nPERL_CALLCONV U32\tPerl_intro_my(pTHX);\nPERL_CALLCONV OP*\tPerl_invert(pTHX_ OP* cmd)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl_io_close(pTHX_ IO* io, GV *gv, bool not_implicit, bool warn_on_fail);\n#define PERL_ARGS_ASSERT_IO_CLOSE\t\\\n\tassert(io)\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_isALNUM_lazy(pTHX_ const char* p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISALNUM_LAZY\t\\\n\tassert(p)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE Size_t\tS_isC9_STRICT_UTF8_CHAR(const U8 * const s0, const U8 * const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISC9_STRICT_UTF8_CHAR\t\\\n\tassert(s0); assert(e)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_isIDFIRST_lazy(pTHX_ const char* p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISIDFIRST_LAZY\t\\\n\tassert(p)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE Size_t\tS_isSTRICT_UTF8_CHAR(const U8 * const s0, const U8 * const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISSTRICT_UTF8_CHAR\t\\\n\tassert(s0); assert(e)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE Size_t\tS_isUTF8_CHAR(const U8 * const s0, const U8 * const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISUTF8_CHAR\t\\\n\tassert(s0); assert(e)\n#endif\n\n/* PERL_CALLCONV bool\tPerl_is_ascii_string(const U8* const s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__; */\n\n/* PERL_CALLCONV bool\tPerl_is_c9strict_utf8_string(const U8 *s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__; */\n\n/* PERL_CALLCONV bool\tis_c9strict_utf8_string_loc(const U8 *s, STRLEN len, const U8 **ep); */\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_c9strict_utf8_string_loclen(const U8 *s, STRLEN len, const U8 **ep, STRLEN *el);\n#define PERL_ARGS_ASSERT_IS_C9STRICT_UTF8_STRING_LOCLEN\t\\\n\tassert(s)\n#endif\n/* PERL_CALLCONV bool\tPerl_is_invariant_string(const U8* const s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__; */\n\nPERL_CALLCONV I32\tPerl_is_lvalue_sub(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_safe_syscall(pTHX_ const char *pv, STRLEN len, const char *what, const char *op_name)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_SAFE_SYSCALL\t\\\n\tassert(pv); assert(what); assert(op_name)\n#endif\n\n/* PERL_CALLCONV bool\tPerl_is_strict_utf8_string(const U8 *s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__; */\n\n/* PERL_CALLCONV bool\tis_strict_utf8_string_loc(const U8 *s, STRLEN len, const U8 **ep); */\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_strict_utf8_string_loclen(const U8 *s, STRLEN len, const U8 **ep, STRLEN *el);\n#define PERL_ARGS_ASSERT_IS_STRICT_UTF8_STRING_LOCLEN\t\\\n\tassert(s)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_alnum(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_alnum_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_alnumc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_alnumc_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_alpha(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_alpha_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_ascii(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_ascii_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_blank(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_blank_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_cntrl(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_cntrl_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_digit(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_digit_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_graph(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_graph_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_idfirst(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_idfirst_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_lower(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_lower_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_print(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_print_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_punct(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_punct_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_space(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_space_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_upper(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_upper_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_xdigit(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_uni_xdigit_lc(pTHX_ UV c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_alnum(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_ALNUM\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_alnumc(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_ALNUMC\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_alpha(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_ALPHA\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_ascii(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_ASCII\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_blank(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_BLANK\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV STRLEN\tPerl_is_utf8_char(const U8 *s)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_IS_UTF8_CHAR\t\\\n\tassert(s)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV STRLEN\tPerl_is_utf8_char_buf(const U8 *buf, const U8 *buf_end);\n#define PERL_ARGS_ASSERT_IS_UTF8_CHAR_BUF\t\\\n\tassert(buf); assert(buf_end)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_cntrl(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_CNTRL\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_digit(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_DIGIT\t\\\n\tassert(p)\n#endif\n\n/* PERL_CALLCONV bool\tis_utf8_fixed_width_buf_flags(const U8 * const s, STRLEN len, const U32 flags); */\n/* PERL_CALLCONV bool\tis_utf8_fixed_width_buf_loc_flags(const U8 * const s, STRLEN len, const U8 **ep, const U32 flags); */\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_fixed_width_buf_loclen_flags(const U8 * const s, STRLEN len, const U8 **ep, STRLEN *el, const U32 flags);\n#define PERL_ARGS_ASSERT_IS_UTF8_FIXED_WIDTH_BUF_LOCLEN_FLAGS\t\\\n\tassert(s)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_graph(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_GRAPH\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_idcont(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_IDCONT\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_idfirst(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_IDFIRST\t\\\n\tassert(p)\n#endif\n\n/* PERL_CALLCONV bool\tis_utf8_invariant_string(const U8* const s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__; */\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_invariant_string_loc(const U8* const s, STRLEN len, const U8 ** ep)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_INVARIANT_STRING_LOC\t\\\n\tassert(s)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_lower(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_LOWER\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_mark(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_MARK\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_perl_space(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_PERL_SPACE\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_perl_word(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_PERL_WORD\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_posix_digit(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_POSIX_DIGIT\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_print(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_PRINT\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_punct(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_PUNCT\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_space(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_SPACE\t\\\n\tassert(p)\n#endif\n\n/* PERL_CALLCONV bool\tPerl_is_utf8_string(const U8 *s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__; */\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_string_flags(const U8 *s, STRLEN len, const U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_STRING_FLAGS\t\\\n\tassert(s)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_string_loc(const U8 *s, const STRLEN len, const U8 **ep);\n#define PERL_ARGS_ASSERT_IS_UTF8_STRING_LOC\t\\\n\tassert(s); assert(ep)\n#endif\n/* PERL_CALLCONV bool\tis_utf8_string_loc_flags(const U8 *s, STRLEN len, const U8 **ep, const U32 flags); */\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tPerl_is_utf8_string_loclen(const U8 *s, STRLEN len, const U8 **ep, STRLEN *el);\n#define PERL_ARGS_ASSERT_IS_UTF8_STRING_LOCLEN\t\\\n\tassert(s)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_string_loclen_flags(const U8 *s, STRLEN len, const U8 **ep, STRLEN *el, const U32 flags);\n#define PERL_ARGS_ASSERT_IS_UTF8_STRING_LOCLEN_FLAGS\t\\\n\tassert(s)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_upper(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_UPPER\t\\\n\tassert(p)\n#endif\n\n/* PERL_CALLCONV bool\tis_utf8_valid_partial_char(const U8 * const s, const U8 * const e)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__; */\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_valid_partial_char_flags(const U8 * const s, const U8 * const e, const U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_VALID_PARTIAL_CHAR_FLAGS\t\\\n\tassert(s); assert(e)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_xdigit(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_XDIGIT\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_xidcont(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_XIDCONT\t\\\n\tassert(p)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_is_utf8_xidfirst(pTHX_ const U8 *p)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_XIDFIRST\t\\\n\tassert(p)\n#endif\n\nPERL_CALLCONV bool\tPerl_isinfnan(NV nv)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\nPERL_CALLCONV bool\tPerl_isinfnansv(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_ISINFNANSV\t\\\n\tassert(sv)\nPERL_CALLCONV OP*\tPerl_jmaybe(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_JMAYBE\t\\\n\tassert(o)\nPERL_CALLCONV I32\tPerl_keyword(pTHX_ const char *name, I32 len, bool all_keywords)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#define PERL_ARGS_ASSERT_KEYWORD\t\\\n\tassert(name)\n\nPERL_CALLCONV int\tPerl_keyword_plugin_standard(pTHX_ char* keyword_ptr, STRLEN keyword_len, OP** op_ptr);\n#define PERL_ARGS_ASSERT_KEYWORD_PLUGIN_STANDARD\t\\\n\tassert(keyword_ptr); assert(op_ptr)\nPERL_CALLCONV void\tPerl_leave_adjust_stacks(pTHX_ SV **from_sp, SV **to_sp, U8 gimme, int filter);\n#define PERL_ARGS_ASSERT_LEAVE_ADJUST_STACKS\t\\\n\tassert(from_sp); assert(to_sp)\nPERL_CALLCONV void\tPerl_leave_scope(pTHX_ I32 base);\nPERL_CALLCONV bool\tPerl_lex_bufutf8(pTHX);\nPERL_CALLCONV void\tPerl_lex_discard_to(pTHX_ char* ptr);\n#define PERL_ARGS_ASSERT_LEX_DISCARD_TO\t\\\n\tassert(ptr)\nPERL_CALLCONV char*\tPerl_lex_grow_linestr(pTHX_ STRLEN len);\nPERL_CALLCONV bool\tPerl_lex_next_chunk(pTHX_ U32 flags);\nPERL_CALLCONV I32\tPerl_lex_peek_unichar(pTHX_ U32 flags);\nPERL_CALLCONV void\tPerl_lex_read_space(pTHX_ U32 flags);\nPERL_CALLCONV void\tPerl_lex_read_to(pTHX_ char* ptr);\n#define PERL_ARGS_ASSERT_LEX_READ_TO\t\\\n\tassert(ptr)\nPERL_CALLCONV I32\tPerl_lex_read_unichar(pTHX_ U32 flags);\nPERL_CALLCONV void\tPerl_lex_start(pTHX_ SV* line, PerlIO *rsfp, U32 flags);\nPERL_CALLCONV void\tPerl_lex_stuff_pv(pTHX_ const char* pv, U32 flags);\n#define PERL_ARGS_ASSERT_LEX_STUFF_PV\t\\\n\tassert(pv)\nPERL_CALLCONV void\tPerl_lex_stuff_pvn(pTHX_ const char* pv, STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_LEX_STUFF_PVN\t\\\n\tassert(pv)\nPERL_CALLCONV void\tPerl_lex_stuff_sv(pTHX_ SV* sv, U32 flags);\n#define PERL_ARGS_ASSERT_LEX_STUFF_SV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_lex_unstuff(pTHX_ char* ptr);\n#define PERL_ARGS_ASSERT_LEX_UNSTUFF\t\\\n\tassert(ptr)\nPERL_CALLCONV OP*\tPerl_list(pTHX_ OP* o);\nPERL_CALLCONV void\tPerl_load_module(pTHX_ U32 flags, SV* name, SV* ver, ...);\n#define PERL_ARGS_ASSERT_LOAD_MODULE\t\\\n\tassert(name)\nPERL_CALLCONV OP*\tPerl_localize(pTHX_ OP *o, I32 lex);\n#define PERL_ARGS_ASSERT_LOCALIZE\t\\\n\tassert(o)\nPERL_CALLCONV I32\tPerl_looks_like_number(pTHX_ SV *const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_LOOKS_LIKE_NUMBER\t\\\n\tassert(sv)\n\nPERL_CALLCONV int\tPerl_magic_clear_all_env(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEAR_ALL_ENV\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_cleararylen_p(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEARARYLEN_P\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_clearenv(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEARENV\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_clearhint(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEARHINT\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_clearhints(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEARHINTS\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_clearisa(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEARISA\t\\\n\tassert(mg)\nPERL_CALLCONV int\tPerl_magic_clearpack(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEARPACK\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_clearsig(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_CLEARSIG\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_copycallchecker(pTHX_ SV* sv, MAGIC *mg, SV *nsv, const char *name, I32 namlen);\n#define PERL_ARGS_ASSERT_MAGIC_COPYCALLCHECKER\t\\\n\tassert(sv); assert(mg); assert(nsv)\nPERL_CALLCONV void\tPerl_magic_dump(pTHX_ const MAGIC *mg);\nPERL_CALLCONV int\tPerl_magic_existspack(pTHX_ SV* sv, const MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_EXISTSPACK\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_freearylen_p(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_FREEARYLEN_P\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_freeovrld(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_FREEOVRLD\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_get(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GET\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getarylen(pTHX_ SV* sv, const MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETARYLEN\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getdebugvar(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETDEBUGVAR\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getdefelem(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETDEFELEM\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getnkeys(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETNKEYS\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getpack(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETPACK\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getpos(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETPOS\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getsig(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETSIG\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getsubstr(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETSUBSTR\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_gettaint(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETTAINT\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getuvar(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETUVAR\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_getvec(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_GETVEC\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_killbackrefs(pTHX_ SV *sv, MAGIC *mg);\n#define PERL_ARGS_ASSERT_MAGIC_KILLBACKREFS\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV SV*\tPerl_magic_methcall(pTHX_ SV *sv, const MAGIC *mg, SV *meth, U32 flags, U32 argc, ...);\n#define PERL_ARGS_ASSERT_MAGIC_METHCALL\t\\\n\tassert(sv); assert(mg); assert(meth)\nPERL_CALLCONV int\tPerl_magic_nextpack(pTHX_ SV *sv, MAGIC *mg, SV *key);\n#define PERL_ARGS_ASSERT_MAGIC_NEXTPACK\t\\\n\tassert(sv); assert(mg); assert(key)\nPERL_CALLCONV U32\tPerl_magic_regdata_cnt(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_REGDATA_CNT\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_regdatum_get(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_REGDATUM_GET\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV SV*\tPerl_magic_scalarpack(pTHX_ HV *hv, MAGIC *mg);\n#define PERL_ARGS_ASSERT_MAGIC_SCALARPACK\t\\\n\tassert(hv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_set(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SET\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_set_all_env(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SET_ALL_ENV\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setarylen(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETARYLEN\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setdbline(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETDBLINE\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setdebugvar(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETDEBUGVAR\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setdefelem(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETDEFELEM\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setenv(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETENV\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_sethint(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETHINT\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setisa(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETISA\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setlvref(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETLVREF\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setmglob(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETMGLOB\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setnkeys(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETNKEYS\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setnonelem(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETNONELEM\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setpack(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETPACK\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setpos(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETPOS\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setregexp(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETREGEXP\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setsig(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETSIG\t\\\n\tassert(mg)\nPERL_CALLCONV int\tPerl_magic_setsubstr(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETSUBSTR\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_settaint(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETTAINT\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setutf8(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETUTF8\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setuvar(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETUVAR\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_setvec(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETVEC\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV U32\tPerl_magic_sizepack(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SIZEPACK\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV int\tPerl_magic_wipepack(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_WIPEPACK\t\\\n\tassert(sv); assert(mg)\nPERL_CALLCONV Malloc_t\tPerl_malloc(MEM_SIZE nbytes)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV I32 *\tPerl_markstack_grow(pTHX);\nPERL_CALLCONV SV*\tPerl_mess(pTHX_ const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_1,pTHX_2);\n#define PERL_ARGS_ASSERT_MESS\t\\\n\tassert(pat)\n\nPERL_CALLCONV SV*\tPerl_mess_sv(pTHX_ SV* basemsg, bool consume);\n#define PERL_ARGS_ASSERT_MESS_SV\t\\\n\tassert(basemsg)\nPERL_CALLCONV Free_t\tPerl_mfree(Malloc_t where);\nPERL_CALLCONV int\tPerl_mg_clear(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_MG_CLEAR\t\\\n\tassert(sv)\nPERL_CALLCONV int\tPerl_mg_copy(pTHX_ SV *sv, SV *nsv, const char *key, I32 klen);\n#define PERL_ARGS_ASSERT_MG_COPY\t\\\n\tassert(sv); assert(nsv)\nPERL_CALLCONV MAGIC*\tPerl_mg_find(const SV* sv, int type)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV MAGIC*\tPerl_mg_find_mglob(pTHX_ SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MG_FIND_MGLOB\t\\\n\tassert(sv)\n\nPERL_CALLCONV MAGIC*\tPerl_mg_findext(const SV* sv, int type, const MGVTBL *vtbl)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV int\tPerl_mg_free(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_MG_FREE\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_mg_free_type(pTHX_ SV* sv, int how);\n#define PERL_ARGS_ASSERT_MG_FREE_TYPE\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_mg_freeext(pTHX_ SV* sv, int how, const MGVTBL *vtbl);\n#define PERL_ARGS_ASSERT_MG_FREEEXT\t\\\n\tassert(sv)\nPERL_CALLCONV int\tPerl_mg_get(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_MG_GET\t\\\n\tassert(sv)\nPERL_CALLCONV U32\tPerl_mg_length(pTHX_ SV* sv)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_MG_LENGTH\t\\\n\tassert(sv)\n\nPERL_CALLCONV void\tPerl_mg_localize(pTHX_ SV* sv, SV* nsv, bool setmagic);\n#define PERL_ARGS_ASSERT_MG_LOCALIZE\t\\\n\tassert(sv); assert(nsv)\nPERL_CALLCONV void\tPerl_mg_magical(SV* sv);\n#define PERL_ARGS_ASSERT_MG_MAGICAL\t\\\n\tassert(sv)\nPERL_CALLCONV int\tPerl_mg_set(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_MG_SET\t\\\n\tassert(sv)\nPERL_CALLCONV I32\tPerl_mg_size(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_MG_SIZE\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_mini_mktime(struct tm *ptm);\n#define PERL_ARGS_ASSERT_MINI_MKTIME\t\\\n\tassert(ptm)\nPERL_CALLCONV int\tPerl_mode_from_discipline(pTHX_ const char* s, STRLEN len);\nPERL_CALLCONV void *\tPerl_more_bodies(pTHX_ const svtype sv_type, const size_t body_size, const size_t arena_size);\nPERL_CALLCONV const char*\tPerl_moreswitches(pTHX_ const char* s);\n#define PERL_ARGS_ASSERT_MORESWITCHES\t\\\n\tassert(s)\nPERL_CALLCONV const struct mro_alg *\tPerl_mro_get_from_name(pTHX_ SV *name);\n#define PERL_ARGS_ASSERT_MRO_GET_FROM_NAME\t\\\n\tassert(name)\nPERL_CALLCONV AV*\tPerl_mro_get_linear_isa(pTHX_ HV* stash);\n#define PERL_ARGS_ASSERT_MRO_GET_LINEAR_ISA\t\\\n\tassert(stash)\nPERL_CALLCONV SV*\tPerl_mro_get_private_data(pTHX_ struct mro_meta *const smeta, const struct mro_alg *const which);\n#define PERL_ARGS_ASSERT_MRO_GET_PRIVATE_DATA\t\\\n\tassert(smeta); assert(which)\nPERL_CALLCONV void\tPerl_mro_isa_changed_in(pTHX_ HV* stash);\n#define PERL_ARGS_ASSERT_MRO_ISA_CHANGED_IN\t\\\n\tassert(stash)\nPERL_CALLCONV struct mro_meta*\tPerl_mro_meta_init(pTHX_ HV* stash);\n#define PERL_ARGS_ASSERT_MRO_META_INIT\t\\\n\tassert(stash)\nPERL_CALLCONV void\tPerl_mro_method_changed_in(pTHX_ HV* stash);\n#define PERL_ARGS_ASSERT_MRO_METHOD_CHANGED_IN\t\\\n\tassert(stash)\nPERL_CALLCONV void\tPerl_mro_package_moved(pTHX_ HV * const stash, HV * const oldstash, const GV * const gv, U32 flags);\n#define PERL_ARGS_ASSERT_MRO_PACKAGE_MOVED\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_mro_register(pTHX_ const struct mro_alg *mro);\n#define PERL_ARGS_ASSERT_MRO_REGISTER\t\\\n\tassert(mro)\nPERL_CALLCONV void\tPerl_mro_set_mro(pTHX_ struct mro_meta *const meta, SV *const name);\n#define PERL_ARGS_ASSERT_MRO_SET_MRO\t\\\n\tassert(meta); assert(name)\nPERL_CALLCONV SV*\tPerl_mro_set_private_data(pTHX_ struct mro_meta *const smeta, const struct mro_alg *const which, SV *const data);\n#define PERL_ARGS_ASSERT_MRO_SET_PRIVATE_DATA\t\\\n\tassert(smeta); assert(which); assert(data)\nPERL_CALLCONV SV*\tPerl_multiconcat_stringify(pTHX_ const OP* o);\n#define PERL_ARGS_ASSERT_MULTICONCAT_STRINGIFY\t\\\n\tassert(o)\nPERL_CALLCONV SV*\tPerl_multideref_stringify(pTHX_ const OP* o, CV *cv);\n#define PERL_ARGS_ASSERT_MULTIDEREF_STRINGIFY\t\\\n\tassert(o)\nPERL_CALLCONV NV\tPerl_my_atof(pTHX_ const char *s);\n#define PERL_ARGS_ASSERT_MY_ATOF\t\\\n\tassert(s)\nPERL_CALLCONV char*\tPerl_my_atof2(pTHX_ const char *orig, NV* value);\n#define PERL_ARGS_ASSERT_MY_ATOF2\t\\\n\tassert(orig); assert(value)\nPERL_CALLCONV char*\tPerl_my_atof3(pTHX_ const char *orig, NV* value, const STRLEN len);\n#define PERL_ARGS_ASSERT_MY_ATOF3\t\\\n\tassert(orig); assert(value)\nPERL_CALLCONV OP *\tPerl_my_attrs(pTHX_ OP *o, OP *attrs);\n#define PERL_ARGS_ASSERT_MY_ATTRS\t\\\n\tassert(o)\nPERL_CALLCONV void\tPerl_my_clearenv(pTHX);\nPERL_CALLCONV int\tPerl_my_dirfd(DIR* dir);\nPERL_CALLCONV_NO_RET void\tPerl_my_exit(pTHX_ U32 status)\n\t\t\t__attribute__noreturn__;\n\nPERL_CALLCONV_NO_RET void\tPerl_my_failure_exit(pTHX)\n\t\t\t__attribute__noreturn__;\n\nPERL_CALLCONV I32\tPerl_my_fflush_all(pTHX);\nPERL_CALLCONV Pid_t\tPerl_my_fork(void);\n#ifndef NO_MATHOMS\nPERL_CALLCONV I32\tPerl_my_lstat(pTHX);\n#endif\nPERL_CALLCONV I32\tPerl_my_lstat_flags(pTHX_ const U32 flags);\nPERL_CALLCONV int\tPerl_my_mkstemp_cloexec(char *templte)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MY_MKSTEMP_CLOEXEC\t\\\n\tassert(templte)\n\nPERL_CALLCONV PerlIO*\tPerl_my_popen_list(pTHX_ const char* mode, int n, SV ** args);\n#define PERL_ARGS_ASSERT_MY_POPEN_LIST\t\\\n\tassert(mode); assert(args)\nPERL_CALLCONV void\tPerl_my_setenv(pTHX_ const char* nam, const char* val);\nPERL_CALLCONV int\tPerl_my_snprintf(char *buffer, const Size_t len, const char *format, ...)\n\t\t\t__attribute__format__(__printf__,3,4);\n#define PERL_ARGS_ASSERT_MY_SNPRINTF\t\\\n\tassert(buffer); assert(format)\n\nPERL_CALLCONV int\tPerl_my_socketpair(int family, int type, int protocol, int fd[2]);\n#ifndef NO_MATHOMS\nPERL_CALLCONV I32\tPerl_my_stat(pTHX);\n#endif\nPERL_CALLCONV I32\tPerl_my_stat_flags(pTHX_ const U32 flags);\nPERL_CALLCONV char*\tPerl_my_strerror(pTHX_ const int errnum);\nPERL_CALLCONV char *\tPerl_my_strftime(pTHX_ const char *fmt, int sec, int min, int hour, int mday, int mon, int year, int wday, int yday, int isdst)\n\t\t\t__attribute__format__(__strftime__,pTHX_1,0);\n#define PERL_ARGS_ASSERT_MY_STRFTIME\t\\\n\tassert(fmt)\n\nPERL_CALLCONV NV\tPerl_my_strtod(const char * const s, char ** e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MY_STRTOD\t\\\n\tassert(s)\n\nPERL_CALLCONV void\tPerl_my_unexec(pTHX);\nPERL_CALLCONV int\tPerl_my_vsnprintf(char *buffer, const Size_t len, const char *format, va_list ap);\n#define PERL_ARGS_ASSERT_MY_VSNPRINTF\t\\\n\tassert(buffer); assert(format)\nPERL_CALLCONV OP*\tPerl_newANONATTRSUB(pTHX_ I32 floor, OP *proto, OP *attrs, OP *block);\nPERL_CALLCONV OP*\tPerl_newANONHASH(pTHX_ OP* o)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newANONLIST(pTHX_ OP* o)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newANONSUB(pTHX_ I32 floor, OP* proto, OP* block);\nPERL_CALLCONV OP*\tPerl_newASSIGNOP(pTHX_ I32 flags, OP* left, I32 optype, OP* right)\n\t\t\t__attribute__warn_unused_result__;\n\n/* PERL_CALLCONV CV*\tnewATTRSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block); */\nPERL_CALLCONV CV*\tPerl_newATTRSUB_x(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block, bool o_is_gv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV AV*\tPerl_newAV(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV OP*\tPerl_newAVREF(pTHX_ OP* o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWAVREF\t\\\n\tassert(o)\n\nPERL_CALLCONV OP*\tPerl_newBINOP(pTHX_ I32 type, I32 flags, OP* first, OP* last)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newCONDOP(pTHX_ I32 flags, OP* first, OP* trueop, OP* falseop)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWCONDOP\t\\\n\tassert(first)\n\nPERL_CALLCONV CV*\tPerl_newCONSTSUB(pTHX_ HV* stash, const char* name, SV* sv);\nPERL_CALLCONV CV*\tPerl_newCONSTSUB_flags(pTHX_ HV* stash, const char* name, STRLEN len, U32 flags, SV* sv);\nPERL_CALLCONV OP*\tPerl_newCVREF(pTHX_ I32 flags, OP* o)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newDEFSVOP(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_newFORM(pTHX_ I32 floor, OP* o, OP* block);\nPERL_CALLCONV OP*\tPerl_newFOROP(pTHX_ I32 flags, OP* sv, OP* expr, OP* block, OP* cont)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWFOROP\t\\\n\tassert(expr)\n\nPERL_CALLCONV OP*\tPerl_newGIVENOP(pTHX_ OP* cond, OP* block, PADOFFSET defsv_off)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWGIVENOP\t\\\n\tassert(cond); assert(block)\n\nPERL_CALLCONV GP *\tPerl_newGP(pTHX_ GV *const gv);\n#define PERL_ARGS_ASSERT_NEWGP\t\\\n\tassert(gv)\nPERL_CALLCONV OP*\tPerl_newGVOP(pTHX_ I32 type, I32 flags, GV* gv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWGVOP\t\\\n\tassert(gv)\n\nPERL_CALLCONV OP*\tPerl_newGVREF(pTHX_ I32 type, OP* o)\n\t\t\t__attribute__warn_unused_result__;\n\n/* PERL_CALLCONV GV*\tnewGVgen(pTHX_ const char* pack); */\nPERL_CALLCONV GV*\tPerl_newGVgen_flags(pTHX_ const char* pack, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWGVGEN_FLAGS\t\\\n\tassert(pack)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV HV*\tPerl_newHV(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV OP*\tPerl_newHVREF(pTHX_ OP* o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWHVREF\t\\\n\tassert(o)\n\nPERL_CALLCONV HV*\tPerl_newHVhv(pTHX_ HV *hv)\n\t\t\t__attribute__warn_unused_result__;\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV IO*\tPerl_newIO(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV OP*\tPerl_newLISTOP(pTHX_ I32 type, I32 flags, OP* first, OP* last)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newLOGOP(pTHX_ I32 optype, I32 flags, OP *first, OP *other)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWLOGOP\t\\\n\tassert(first); assert(other)\n\nPERL_CALLCONV OP*\tPerl_newLOOPEX(pTHX_ I32 type, OP* label)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWLOOPEX\t\\\n\tassert(label)\n\nPERL_CALLCONV OP*\tPerl_newLOOPOP(pTHX_ I32 flags, I32 debuggable, OP* expr, OP* block)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newMETHOP(pTHX_ I32 type, I32 flags, OP* dynamic_meth)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWMETHOP\t\\\n\tassert(dynamic_meth)\n\nPERL_CALLCONV OP*\tPerl_newMETHOP_named(pTHX_ I32 type, I32 flags, SV* const_meth)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWMETHOP_NAMED\t\\\n\tassert(const_meth)\n\nPERL_CALLCONV CV *\tPerl_newMYSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block);\n#define PERL_ARGS_ASSERT_NEWMYSUB\t\\\n\tassert(o)\nPERL_CALLCONV OP*\tPerl_newNULLLIST(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newOP(pTHX_ I32 optype, I32 flags)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV PADNAMELIST *\tPerl_newPADNAMELIST(size_t max)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV PADNAME *\tPerl_newPADNAMEouter(PADNAME *outer)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWPADNAMEOUTER\t\\\n\tassert(outer)\n\nPERL_CALLCONV PADNAME *\tPerl_newPADNAMEpvn(const char *s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWPADNAMEPVN\t\\\n\tassert(s)\n\nPERL_CALLCONV OP*\tPerl_newPMOP(pTHX_ I32 type, I32 flags)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_newPROG(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_NEWPROG\t\\\n\tassert(o)\nPERL_CALLCONV OP*\tPerl_newPVOP(pTHX_ I32 type, I32 flags, char* pv)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newRANGE(pTHX_ I32 flags, OP* left, OP* right)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWRANGE\t\\\n\tassert(left); assert(right)\n\nPERL_CALLCONV SV*\tPerl_newRV(pTHX_ SV *const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWRV\t\\\n\tassert(sv)\n\nPERL_CALLCONV SV*\tPerl_newRV_noinc(pTHX_ SV *const tmpRef)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWRV_NOINC\t\\\n\tassert(tmpRef)\n\nPERL_CALLCONV OP*\tPerl_newSLICEOP(pTHX_ I32 flags, OP* subscript, OP* listop)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newSTATEOP(pTHX_ I32 flags, char* label, OP* o)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV CV*\tPerl_newSTUB(pTHX_ GV *gv, bool fake);\n#define PERL_ARGS_ASSERT_NEWSTUB\t\\\n\tassert(gv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV CV*\tPerl_newSUB(pTHX_ I32 floor, OP* o, OP* proto, OP* block);\n#endif\nPERL_CALLCONV SV*\tPerl_newSV(pTHX_ const STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newSVOP(pTHX_ I32 type, I32 flags, SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWSVOP\t\\\n\tassert(sv)\n\nPERL_CALLCONV OP*\tPerl_newSVREF(pTHX_ OP* o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWSVREF\t\\\n\tassert(o)\n\nPERL_CALLCONV SV*\tPerl_newSV_type(pTHX_ const svtype type)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVavdefelem(pTHX_ AV *av, SSize_t ix, bool extendible)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWSVAVDEFELEM\t\\\n\tassert(av)\n\nPERL_CALLCONV SV*\tPerl_newSVhek(pTHX_ const HEK *const hek)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSViv(pTHX_ const IV i)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVnv(pTHX_ const NV n)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVpv(pTHX_ const char *const s, const STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVpv_share(pTHX_ const char* s, U32 hash)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVpvf(pTHX_ const char *const pat, ...)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__format__(__printf__,pTHX_1,pTHX_2);\n#define PERL_ARGS_ASSERT_NEWSVPVF\t\\\n\tassert(pat)\n\nPERL_CALLCONV SV*\tPerl_newSVpvn(pTHX_ const char *const buffer, const STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVpvn_flags(pTHX_ const char *const s, const STRLEN len, const U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVpvn_share(pTHX_ const char* s, I32 len, U32 hash)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_newSVrv(pTHX_ SV *const rv, const char *const classname);\n#define PERL_ARGS_ASSERT_NEWSVRV\t\\\n\tassert(rv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV SV*\tPerl_newSVsv(pTHX_ SV *const old)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV SV*\tPerl_newSVsv_flags(pTHX_ SV *const old, I32 flags)\n\t\t\t__attribute__warn_unused_result__;\n\n/* PERL_CALLCONV SV*\tPerl_newSVsv_nomg(pTHX_ SV *const old)\n\t\t\t__attribute__warn_unused_result__; */\n\nPERL_CALLCONV SV*\tPerl_newSVuv(pTHX_ const UV u)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newUNOP(pTHX_ I32 type, I32 flags, OP* first)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newUNOP_AUX(pTHX_ I32 type, I32 flags, OP* first, UNOP_AUX_item *aux)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV OP*\tPerl_newWHENOP(pTHX_ OP* cond, OP* block)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWWHENOP\t\\\n\tassert(block)\n\nPERL_CALLCONV OP*\tPerl_newWHILEOP(pTHX_ I32 flags, I32 debuggable, LOOP* loop, OP* expr, OP* block, OP* cont, I32 has_my)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV CV*\tPerl_newXS(pTHX_ const char *name, XSUBADDR_t subaddr, const char *filename);\n#define PERL_ARGS_ASSERT_NEWXS\t\\\n\tassert(subaddr); assert(filename)\nPERL_CALLCONV CV *\tPerl_newXS_deffile(pTHX_ const char *name, XSUBADDR_t subaddr);\n#define PERL_ARGS_ASSERT_NEWXS_DEFFILE\t\\\n\tassert(name); assert(subaddr)\nPERL_CALLCONV CV *\tPerl_newXS_flags(pTHX_ const char *name, XSUBADDR_t subaddr, const char *const filename, const char *const proto, U32 flags);\n#define PERL_ARGS_ASSERT_NEWXS_FLAGS\t\\\n\tassert(subaddr); assert(filename)\nPERL_CALLCONV CV *\tPerl_newXS_len_flags(pTHX_ const char *name, STRLEN len, XSUBADDR_t subaddr, const char *const filename, const char *const proto, SV **const_svp, U32 flags);\n#define PERL_ARGS_ASSERT_NEWXS_LEN_FLAGS\t\\\n\tassert(subaddr)\nPERL_CALLCONV PERL_SI*\tPerl_new_stackinfo(pTHX_ I32 stitems, I32 cxitems)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_new_version(pTHX_ SV *ver);\n#define PERL_ARGS_ASSERT_NEW_VERSION\t\\\n\tassert(ver)\nPERL_CALLCONV STRLEN *\tPerl_new_warnings_bitfield(pTHX_ STRLEN *buffer, const char *const bits, STRLEN size)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEW_WARNINGS_BITFIELD\t\\\n\tassert(bits)\n\nPERL_CALLCONV PerlIO*\tPerl_nextargv(pTHX_ GV* gv, bool nomagicopen);\n#define PERL_ARGS_ASSERT_NEXTARGV\t\\\n\tassert(gv)\nPERL_CALLCONV_NO_RET void\tPerl_noperl_die(const char* pat, ...)\n\t\t\t__attribute__noreturn__\n\t\t\t__attribute__format__(__printf__,1,2);\n#define PERL_ARGS_ASSERT_NOPERL_DIE\t\\\n\tassert(pat)\n\nPERL_CALLCONV int\tPerl_nothreadhook(pTHX);\nPERL_CALLCONV void\tPerl_notify_parser_that_changed_to_utf8(pTHX);\nPERL_CALLCONV OP*\tPerl_oopsAV(pTHX_ OP* o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_OOPSAV\t\\\n\tassert(o)\n\nPERL_CALLCONV OP*\tPerl_oopsHV(pTHX_ OP* o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_OOPSHV\t\\\n\tassert(o)\n\nPERL_CALLCONV OP*\tPerl_op_append_elem(pTHX_ I32 optype, OP* first, OP* last);\nPERL_CALLCONV OP*\tPerl_op_append_list(pTHX_ I32 optype, OP* first, OP* last);\nPERL_CALLCONV OPclass\tPerl_op_class(pTHX_ const OP *o);\nPERL_CALLCONV void\tPerl_op_clear(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_OP_CLEAR\t\\\n\tassert(o)\nPERL_CALLCONV OP*\tPerl_op_contextualize(pTHX_ OP* o, I32 context);\n#define PERL_ARGS_ASSERT_OP_CONTEXTUALIZE\t\\\n\tassert(o)\nPERL_CALLCONV OP*\tPerl_op_convert_list(pTHX_ I32 optype, I32 flags, OP* o)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_op_dump(pTHX_ const OP *o);\n#define PERL_ARGS_ASSERT_OP_DUMP\t\\\n\tassert(o)\nPERL_CALLCONV void\tPerl_op_free(pTHX_ OP* arg);\nPERL_CALLCONV OP*\tPerl_op_linklist(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_OP_LINKLIST\t\\\n\tassert(o)\n/* PERL_CALLCONV OP*\top_lvalue(pTHX_ OP* o, I32 type); */\nPERL_CALLCONV OP*\tPerl_op_lvalue_flags(pTHX_ OP* o, I32 type, U32 flags);\nPERL_CALLCONV void\tPerl_op_null(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_OP_NULL\t\\\n\tassert(o)\nPERL_CALLCONV OP*\tPerl_op_parent(OP *o);\n#define PERL_ARGS_ASSERT_OP_PARENT\t\\\n\tassert(o)\nPERL_CALLCONV OP*\tPerl_op_prepend_elem(pTHX_ I32 optype, OP* first, OP* last);\nPERL_CALLCONV void\tPerl_op_refcnt_lock(pTHX);\nPERL_CALLCONV void\tPerl_op_refcnt_unlock(pTHX);\nPERL_CALLCONV OP*\tPerl_op_scope(pTHX_ OP* o);\nPERL_CALLCONV OP*\tPerl_op_sibling_splice(OP *parent, OP *start, int del_count, OP* insert);\nPERL_CALLCONV OP*\tPerl_op_unscope(pTHX_ OP* o);\nPERL_CALLCONV void\tPerl_optimize_optree(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_OPTIMIZE_OPTREE\t\\\n\tassert(o)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_pack_cat(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist, SV ***next_in_list, U32 flags);\n#define PERL_ARGS_ASSERT_PACK_CAT\t\\\n\tassert(cat); assert(pat); assert(patend); assert(beglist); assert(endlist); assert(next_in_list)\n#endif\nPERL_CALLCONV void\tPerl_package(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_PACKAGE\t\\\n\tassert(o)\nPERL_CALLCONV void\tPerl_package_version(pTHX_ OP* v);\n#define PERL_ARGS_ASSERT_PACKAGE_VERSION\t\\\n\tassert(v)\nPERL_CALLCONV void\tPerl_packlist(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist);\n#define PERL_ARGS_ASSERT_PACKLIST\t\\\n\tassert(cat); assert(pat); assert(patend); assert(beglist); assert(endlist)\nPERL_CALLCONV PADOFFSET\tPerl_pad_add_anon(pTHX_ CV* func, I32 optype);\n#define PERL_ARGS_ASSERT_PAD_ADD_ANON\t\\\n\tassert(func)\nPERL_CALLCONV PADOFFSET\tPerl_pad_add_name_pv(pTHX_ const char *name, const U32 flags, HV *typestash, HV *ourstash);\n#define PERL_ARGS_ASSERT_PAD_ADD_NAME_PV\t\\\n\tassert(name)\nPERL_CALLCONV PADOFFSET\tPerl_pad_add_name_pvn(pTHX_ const char *namepv, STRLEN namelen, U32 flags, HV *typestash, HV *ourstash);\n#define PERL_ARGS_ASSERT_PAD_ADD_NAME_PVN\t\\\n\tassert(namepv)\nPERL_CALLCONV PADOFFSET\tPerl_pad_add_name_sv(pTHX_ SV *name, U32 flags, HV *typestash, HV *ourstash);\n#define PERL_ARGS_ASSERT_PAD_ADD_NAME_SV\t\\\n\tassert(name)\nPERL_CALLCONV void\tPerl_pad_add_weakref(pTHX_ CV* func);\n#define PERL_ARGS_ASSERT_PAD_ADD_WEAKREF\t\\\n\tassert(func)\nPERL_CALLCONV PADOFFSET\tPerl_pad_alloc(pTHX_ I32 optype, U32 tmptype);\nPERL_CALLCONV void\tPerl_pad_block_start(pTHX_ int full);\n#ifndef NO_MATHOMS\nPERL_CALLCONV HV*\tPerl_pad_compname_type(pTHX_ const PADOFFSET po)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV PADOFFSET\tPerl_pad_findmy_pv(pTHX_ const char* name, U32 flags);\n#define PERL_ARGS_ASSERT_PAD_FINDMY_PV\t\\\n\tassert(name)\nPERL_CALLCONV PADOFFSET\tPerl_pad_findmy_pvn(pTHX_ const char* namepv, STRLEN namelen, U32 flags);\n#define PERL_ARGS_ASSERT_PAD_FINDMY_PVN\t\\\n\tassert(namepv)\nPERL_CALLCONV PADOFFSET\tPerl_pad_findmy_sv(pTHX_ SV* name, U32 flags);\n#define PERL_ARGS_ASSERT_PAD_FINDMY_SV\t\\\n\tassert(name)\nPERL_CALLCONV void\tPerl_pad_fixup_inner_anons(pTHX_ PADLIST *padlist, CV *old_cv, CV *new_cv);\n#define PERL_ARGS_ASSERT_PAD_FIXUP_INNER_ANONS\t\\\n\tassert(padlist); assert(old_cv); assert(new_cv)\nPERL_CALLCONV void\tPerl_pad_free(pTHX_ PADOFFSET po);\nPERL_CALLCONV OP *\tPerl_pad_leavemy(pTHX);\nPERL_CALLCONV PADLIST*\tPerl_pad_new(pTHX_ int flags)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_pad_push(pTHX_ PADLIST *padlist, int depth);\n#define PERL_ARGS_ASSERT_PAD_PUSH\t\\\n\tassert(padlist)\nPERL_CALLCONV void\tPerl_pad_swipe(pTHX_ PADOFFSET po, bool refadjust);\nPERL_CALLCONV void\tPerl_pad_tidy(pTHX_ padtidy_type type);\nPERL_CALLCONV PAD **\tPerl_padlist_store(pTHX_ PADLIST *padlist, I32 key, PAD *val);\n#define PERL_ARGS_ASSERT_PADLIST_STORE\t\\\n\tassert(padlist)\nPERL_CALLCONV void\tPerl_padname_free(pTHX_ PADNAME *pn);\n#define PERL_ARGS_ASSERT_PADNAME_FREE\t\\\n\tassert(pn)\nPERL_CALLCONV PADNAME *\tPerl_padnamelist_fetch(PADNAMELIST *pnl, SSize_t key)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PADNAMELIST_FETCH\t\\\n\tassert(pnl)\n\nPERL_CALLCONV void\tPerl_padnamelist_free(pTHX_ PADNAMELIST *pnl);\n#define PERL_ARGS_ASSERT_PADNAMELIST_FREE\t\\\n\tassert(pnl)\nPERL_CALLCONV PADNAME **\tPerl_padnamelist_store(pTHX_ PADNAMELIST *pnl, SSize_t key, PADNAME *val);\n#define PERL_ARGS_ASSERT_PADNAMELIST_STORE\t\\\n\tassert(pnl)\nPERL_CALLCONV OP*\tPerl_parse_arithexpr(pTHX_ U32 flags);\nPERL_CALLCONV OP*\tPerl_parse_barestmt(pTHX_ U32 flags);\nPERL_CALLCONV OP*\tPerl_parse_block(pTHX_ U32 flags);\nPERL_CALLCONV OP*\tPerl_parse_fullexpr(pTHX_ U32 flags);\nPERL_CALLCONV OP*\tPerl_parse_fullstmt(pTHX_ U32 flags);\nPERL_CALLCONV SV*\tPerl_parse_label(pTHX_ U32 flags);\nPERL_CALLCONV OP*\tPerl_parse_listexpr(pTHX_ U32 flags);\nPERL_CALLCONV OP*\tPerl_parse_stmtseq(pTHX_ U32 flags);\nPERL_CALLCONV OP*\tPerl_parse_termexpr(pTHX_ U32 flags);\nPERL_CALLCONV U32\tPerl_parse_unicode_opts(pTHX_ const char **popt);\n#define PERL_ARGS_ASSERT_PARSE_UNICODE_OPTS\t\\\n\tassert(popt)\nPERL_CALLCONV void\tPerl_parser_free(pTHX_ const yy_parser *parser);\n#define PERL_ARGS_ASSERT_PARSER_FREE\t\\\n\tassert(parser)\nPERL_CALLCONV void\tPerl_peep(pTHX_ OP* o);\nPERL_CALLCONV PerlInterpreter*\tperl_alloc(void);\nPERL_CALLCONV void\tperl_construct(PerlInterpreter *my_perl);\n#define PERL_ARGS_ASSERT_PERL_CONSTRUCT\t\\\n\tassert(my_perl)\nPERL_CALLCONV int\tperl_destruct(PerlInterpreter *my_perl);\n#define PERL_ARGS_ASSERT_PERL_DESTRUCT\t\\\n\tassert(my_perl)\nPERL_CALLCONV void\tperl_free(PerlInterpreter *my_perl);\n#define PERL_ARGS_ASSERT_PERL_FREE\t\\\n\tassert(my_perl)\nPERL_CALLCONV int\tperl_parse(PerlInterpreter *my_perl, XSINIT_t xsinit, int argc, char** argv, char** env);\n#define PERL_ARGS_ASSERT_PERL_PARSE\t\\\n\tassert(my_perl)\nPERL_CALLCONV int\tperl_run(PerlInterpreter *my_perl);\n#define PERL_ARGS_ASSERT_PERL_RUN\t\\\n\tassert(my_perl)\nPERL_CALLCONV void\tPerl_pmop_dump(pTHX_ PMOP* pm);\nPERL_CALLCONV OP*\tPerl_pmruntime(pTHX_ OP *o, OP *expr, OP *repl, UV flags, I32 floor);\n#define PERL_ARGS_ASSERT_PMRUNTIME\t\\\n\tassert(o); assert(expr)\nPERL_CALLCONV void\tPerl_pop_scope(pTHX);\nPERL_CALLCONV void\tPerl_populate_isa(pTHX_ const char *name, STRLEN len, ...);\n#define PERL_ARGS_ASSERT_POPULATE_ISA\t\\\n\tassert(name)\nPERL_CALLCONV REGEXP*\tPerl_pregcomp(pTHX_ SV * const pattern, const U32 flags);\n#define PERL_ARGS_ASSERT_PREGCOMP\t\\\n\tassert(pattern)\nPERL_CALLCONV I32\tPerl_pregexec(pTHX_ REGEXP * const prog, char* stringarg, char* strend, char* strbeg, SSize_t minend, SV* screamer, U32 nosave);\n#define PERL_ARGS_ASSERT_PREGEXEC\t\\\n\tassert(prog); assert(stringarg); assert(strend); assert(strbeg); assert(screamer)\nPERL_CALLCONV void\tPerl_pregfree(pTHX_ REGEXP* r);\nPERL_CALLCONV void\tPerl_pregfree2(pTHX_ REGEXP *rx);\n#define PERL_ARGS_ASSERT_PREGFREE2\t\\\n\tassert(rx)\nPERL_CALLCONV const char*\tPerl_prescan_version(pTHX_ const char *s, bool strict, const char** errstr, bool *sqv, int *ssaw_decimal, int *swidth, bool *salpha);\n#define PERL_ARGS_ASSERT_PRESCAN_VERSION\t\\\n\tassert(s)\nPERL_CALLCONV void\tPerl_ptr_table_clear(pTHX_ PTR_TBL_t *const tbl)\n\t\t\t__attribute__deprecated__;\n\nPERL_CALLCONV void*\tPerl_ptr_table_fetch(pTHX_ PTR_TBL_t *const tbl, const void *const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PTR_TABLE_FETCH\t\\\n\tassert(tbl)\n\nPERL_CALLCONV void\tPerl_ptr_table_free(pTHX_ PTR_TBL_t *const tbl);\nPERL_CALLCONV PTR_TBL_t*\tPerl_ptr_table_new(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_ptr_table_split(pTHX_ PTR_TBL_t *const tbl);\n#define PERL_ARGS_ASSERT_PTR_TABLE_SPLIT\t\\\n\tassert(tbl)\nPERL_CALLCONV void\tPerl_ptr_table_store(pTHX_ PTR_TBL_t *const tbl, const void *const oldsv, void *const newsv);\n#define PERL_ARGS_ASSERT_PTR_TABLE_STORE\t\\\n\tassert(tbl); assert(newsv)\nPERL_CALLCONV void\tPerl_push_scope(pTHX);\nPERL_CALLCONV char*\tPerl_pv_display(pTHX_ SV *dsv, const char *pv, STRLEN cur, STRLEN len, STRLEN pvlim);\n#define PERL_ARGS_ASSERT_PV_DISPLAY\t\\\n\tassert(dsv); assert(pv)\nPERL_CALLCONV char*\tPerl_pv_escape(pTHX_ SV *dsv, char const * const str, const STRLEN count, const STRLEN max, STRLEN * const escaped, const U32 flags);\n#define PERL_ARGS_ASSERT_PV_ESCAPE\t\\\n\tassert(str)\nPERL_CALLCONV char*\tPerl_pv_pretty(pTHX_ SV *dsv, char const * const str, const STRLEN count, const STRLEN max, char const * const start_color, char const * const end_color, const U32 flags);\n#define PERL_ARGS_ASSERT_PV_PRETTY\t\\\n\tassert(dsv); assert(str)\nPERL_CALLCONV char*\tPerl_pv_uni_display(pTHX_ SV *dsv, const U8 *spv, STRLEN len, STRLEN pvlim, UV flags);\n#define PERL_ARGS_ASSERT_PV_UNI_DISPLAY\t\\\n\tassert(dsv); assert(spv)\nPERL_CALLCONV void\tPerl_qerror(pTHX_ SV* err);\n#define PERL_ARGS_ASSERT_QERROR\t\\\n\tassert(err)\nPERL_CALLCONV REGEXP*\tPerl_re_compile(pTHX_ SV * const pattern, U32 orig_rx_flags);\n#define PERL_ARGS_ASSERT_RE_COMPILE\t\\\n\tassert(pattern)\nPERL_CALLCONV char*\tPerl_re_intuit_start(pTHX_ REGEXP * const rx, SV* sv, const char* const strbeg, char* strpos, char* strend, const U32 flags, re_scream_pos_data *data);\n#define PERL_ARGS_ASSERT_RE_INTUIT_START\t\\\n\tassert(rx); assert(strbeg); assert(strpos); assert(strend)\nPERL_CALLCONV SV*\tPerl_re_intuit_string(pTHX_ REGEXP  *const r);\n#define PERL_ARGS_ASSERT_RE_INTUIT_STRING\t\\\n\tassert(r)\nPERL_CALLCONV REGEXP*\tPerl_re_op_compile(pTHX_ SV ** const patternp, int pat_count, OP *expr, const regexp_engine* eng, REGEXP *old_re, bool *is_bare_re, const U32 rx_flags, const U32 pm_flags);\n#define PERL_ARGS_ASSERT_RE_OP_COMPILE\t\\\n\tassert(eng)\nPERL_CALLCONV Malloc_t\tPerl_realloc(Malloc_t where, MEM_SIZE nbytes)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_reentrant_free(pTHX);\nPERL_CALLCONV void\tPerl_reentrant_init(pTHX);\nPERL_CALLCONV void*\tPerl_reentrant_retry(const char *f, ...);\n#define PERL_ARGS_ASSERT_REENTRANT_RETRY\t\\\n\tassert(f)\nPERL_CALLCONV void\tPerl_reentrant_size(pTHX);\n#ifndef NO_MATHOMS\nPERL_CALLCONV OP*\tPerl_ref(pTHX_ OP* o, I32 type);\n#endif\nPERL_CALLCONV HV *\tPerl_refcounted_he_chain_2hv(pTHX_ const struct refcounted_he *c, U32 flags);\nPERL_CALLCONV SV *\tPerl_refcounted_he_fetch_pv(pTHX_ const struct refcounted_he *chain, const char *key, U32 hash, U32 flags);\n#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_PV\t\\\n\tassert(key)\nPERL_CALLCONV SV *\tPerl_refcounted_he_fetch_pvn(pTHX_ const struct refcounted_he *chain, const char *keypv, STRLEN keylen, U32 hash, U32 flags);\n#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_PVN\t\\\n\tassert(keypv)\nPERL_CALLCONV SV *\tPerl_refcounted_he_fetch_sv(pTHX_ const struct refcounted_he *chain, SV *key, U32 hash, U32 flags);\n#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_SV\t\\\n\tassert(key)\nPERL_CALLCONV void\tPerl_refcounted_he_free(pTHX_ struct refcounted_he *he);\nPERL_CALLCONV struct refcounted_he *\tPerl_refcounted_he_inc(pTHX_ struct refcounted_he *he);\nPERL_CALLCONV struct refcounted_he *\tPerl_refcounted_he_new_pv(pTHX_ struct refcounted_he *parent, const char *key, U32 hash, SV *value, U32 flags);\n#define PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_PV\t\\\n\tassert(key)\nPERL_CALLCONV struct refcounted_he *\tPerl_refcounted_he_new_pvn(pTHX_ struct refcounted_he *parent, const char *keypv, STRLEN keylen, U32 hash, SV *value, U32 flags);\n#define PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_PVN\t\\\n\tassert(keypv)\nPERL_CALLCONV struct refcounted_he *\tPerl_refcounted_he_new_sv(pTHX_ struct refcounted_he *parent, SV *key, U32 hash, SV *value, U32 flags);\n#define PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_SV\t\\\n\tassert(key)\nPERL_CALLCONV SV*\tPerl_reg_named_buff(pTHX_ REGEXP * const rx, SV * const key, SV * const value, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF\t\\\n\tassert(rx)\nPERL_CALLCONV SV*\tPerl_reg_named_buff_all(pTHX_ REGEXP * const rx, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_ALL\t\\\n\tassert(rx)\nPERL_CALLCONV bool\tPerl_reg_named_buff_exists(pTHX_ REGEXP * const rx, SV * const key, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_EXISTS\t\\\n\tassert(rx); assert(key)\nPERL_CALLCONV SV*\tPerl_reg_named_buff_fetch(pTHX_ REGEXP * const rx, SV * const namesv, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_FETCH\t\\\n\tassert(rx); assert(namesv)\nPERL_CALLCONV SV*\tPerl_reg_named_buff_firstkey(pTHX_ REGEXP * const rx, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_FIRSTKEY\t\\\n\tassert(rx)\nPERL_CALLCONV SV*\tPerl_reg_named_buff_iter(pTHX_ REGEXP * const rx, const SV * const lastkey, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_ITER\t\\\n\tassert(rx)\nPERL_CALLCONV SV*\tPerl_reg_named_buff_nextkey(pTHX_ REGEXP * const rx, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_NEXTKEY\t\\\n\tassert(rx)\nPERL_CALLCONV SV*\tPerl_reg_named_buff_scalar(pTHX_ REGEXP * const rx, const U32 flags);\n#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_SCALAR\t\\\n\tassert(rx)\nPERL_CALLCONV void\tPerl_reg_numbered_buff_fetch(pTHX_ REGEXP * const rx, const I32 paren, SV * const sv);\n#define PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_FETCH\t\\\n\tassert(rx)\nPERL_CALLCONV I32\tPerl_reg_numbered_buff_length(pTHX_ REGEXP * const rx, const SV * const sv, const I32 paren);\n#define PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_LENGTH\t\\\n\tassert(rx); assert(sv)\nPERL_CALLCONV void\tPerl_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren, SV const * const value);\n#define PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_STORE\t\\\n\tassert(rx)\nPERL_CALLCONV SV*\tPerl_reg_qr_package(pTHX_ REGEXP * const rx);\n#define PERL_ARGS_ASSERT_REG_QR_PACKAGE\t\\\n\tassert(rx)\nPERL_CALLCONV REGEXP*\tPerl_reg_temp_copy(pTHX_ REGEXP* dsv, REGEXP* ssv);\n#define PERL_ARGS_ASSERT_REG_TEMP_COPY\t\\\n\tassert(ssv)\nPERL_CALLCONV void\tPerl_regdump(pTHX_ const regexp* r);\n#define PERL_ARGS_ASSERT_REGDUMP\t\\\n\tassert(r)\nPERL_CALLCONV I32\tPerl_regexec_flags(pTHX_ REGEXP *const rx, char *stringarg, char *strend, char *strbeg, SSize_t minend, SV *sv, void *data, U32 flags);\n#define PERL_ARGS_ASSERT_REGEXEC_FLAGS\t\\\n\tassert(rx); assert(stringarg); assert(strend); assert(strbeg); assert(sv)\nPERL_CALLCONV void\tPerl_regfree_internal(pTHX_ REGEXP *const rx);\n#define PERL_ARGS_ASSERT_REGFREE_INTERNAL\t\\\n\tassert(rx)\nPERL_CALLCONV void\tPerl_reginitcolors(pTHX);\nPERL_CALLCONV regnode*\tPerl_regnext(pTHX_ regnode* p)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_repeatcpy(char* to, const char* from, I32 len, IV count);\n#define PERL_ARGS_ASSERT_REPEATCPY\t\\\n\tassert(to); assert(from)\nPERL_CALLCONV void\tPerl_report_evil_fh(pTHX_ const GV *gv);\nPERL_CALLCONV void\tPerl_report_uninit(pTHX_ const SV *uninit_sv);\nPERL_CALLCONV void\tPerl_report_wrongway_fh(pTHX_ const GV *gv, const char have);\nPERL_CALLCONV void\tPerl_require_pv(pTHX_ const char* pv);\n#define PERL_ARGS_ASSERT_REQUIRE_PV\t\\\n\tassert(pv)\nPERL_CALLCONV char*\tPerl_rninstr(const char* big, const char* bigend, const char* little, const char* lend)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#define PERL_ARGS_ASSERT_RNINSTR\t\\\n\tassert(big); assert(bigend); assert(little); assert(lend)\n\nPERL_CALLCONV void\tPerl_rpeep(pTHX_ OP* o);\nPERL_CALLCONV Sighandler_t\tPerl_rsignal(pTHX_ int i, Sighandler_t t);\nPERL_CALLCONV int\tPerl_rsignal_restore(pTHX_ int i, Sigsave_t* t);\nPERL_CALLCONV int\tPerl_rsignal_save(pTHX_ int i, Sighandler_t t1, Sigsave_t* save);\n#define PERL_ARGS_ASSERT_RSIGNAL_SAVE\t\\\n\tassert(save)\nPERL_CALLCONV Sighandler_t\tPerl_rsignal_state(pTHX_ int i);\nPERL_CALLCONV int\tPerl_runops_debug(pTHX);\nPERL_CALLCONV int\tPerl_runops_standard(pTHX);\nPERL_CALLCONV CV*\tPerl_rv2cv_op_cv(pTHX_ OP *cvop, U32 flags);\n#define PERL_ARGS_ASSERT_RV2CV_OP_CV\t\\\n\tassert(cvop)\nPERL_CALLCONV void\tPerl_rxres_save(pTHX_ void **rsp, REGEXP *rx);\n#define PERL_ARGS_ASSERT_RXRES_SAVE\t\\\n\tassert(rsp); assert(rx)\nPERL_CALLCONV Malloc_t\tPerl_safesyscalloc(MEM_SIZE elements, MEM_SIZE size)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV Free_t\tPerl_safesysfree(Malloc_t where);\nPERL_CALLCONV Malloc_t\tPerl_safesysmalloc(MEM_SIZE nbytes)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV Malloc_t\tPerl_safesysrealloc(Malloc_t where, MEM_SIZE nbytes)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_save_I16(pTHX_ I16* intp);\n#define PERL_ARGS_ASSERT_SAVE_I16\t\\\n\tassert(intp)\nPERL_CALLCONV void\tPerl_save_I32(pTHX_ I32* intp);\n#define PERL_ARGS_ASSERT_SAVE_I32\t\\\n\tassert(intp)\nPERL_CALLCONV void\tPerl_save_I8(pTHX_ I8* bytep);\n#define PERL_ARGS_ASSERT_SAVE_I8\t\\\n\tassert(bytep)\nPERL_CALLCONV void\tPerl_save_adelete(pTHX_ AV *av, SSize_t key);\n#define PERL_ARGS_ASSERT_SAVE_ADELETE\t\\\n\tassert(av)\n/* PERL_CALLCONV void\tPerl_save_aelem(pTHX_ AV* av, SSize_t idx, SV **sptr); */\nPERL_CALLCONV void\tPerl_save_aelem_flags(pTHX_ AV* av, SSize_t idx, SV **sptr, const U32 flags);\n#define PERL_ARGS_ASSERT_SAVE_AELEM_FLAGS\t\\\n\tassert(av); assert(sptr)\nPERL_CALLCONV I32\tPerl_save_alloc(pTHX_ I32 size, I32 pad);\nPERL_CALLCONV void\tPerl_save_aptr(pTHX_ AV** aptr);\n#define PERL_ARGS_ASSERT_SAVE_APTR\t\\\n\tassert(aptr)\nPERL_CALLCONV AV*\tPerl_save_ary(pTHX_ GV* gv);\n#define PERL_ARGS_ASSERT_SAVE_ARY\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_save_bool(pTHX_ bool* boolp);\n#define PERL_ARGS_ASSERT_SAVE_BOOL\t\\\n\tassert(boolp)\nPERL_CALLCONV void\tPerl_save_clearsv(pTHX_ SV** svp);\n#define PERL_ARGS_ASSERT_SAVE_CLEARSV\t\\\n\tassert(svp)\nPERL_CALLCONV void\tPerl_save_delete(pTHX_ HV *hv, char *key, I32 klen);\n#define PERL_ARGS_ASSERT_SAVE_DELETE\t\\\n\tassert(hv); assert(key)\nPERL_CALLCONV void\tPerl_save_destructor(pTHX_ DESTRUCTORFUNC_NOCONTEXT_t f, void* p);\n#define PERL_ARGS_ASSERT_SAVE_DESTRUCTOR\t\\\n\tassert(p)\nPERL_CALLCONV void\tPerl_save_destructor_x(pTHX_ DESTRUCTORFUNC_t f, void* p);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_freeop(pTHX_ OP* o);\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_freepv(pTHX_ char* pv);\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_freesv(pTHX_ SV* sv);\n#endif\nPERL_CALLCONV void\tPerl_save_generic_pvref(pTHX_ char** str);\n#define PERL_ARGS_ASSERT_SAVE_GENERIC_PVREF\t\\\n\tassert(str)\nPERL_CALLCONV void\tPerl_save_generic_svref(pTHX_ SV** sptr);\n#define PERL_ARGS_ASSERT_SAVE_GENERIC_SVREF\t\\\n\tassert(sptr)\nPERL_CALLCONV void\tPerl_save_gp(pTHX_ GV* gv, I32 empty);\n#define PERL_ARGS_ASSERT_SAVE_GP\t\\\n\tassert(gv)\nPERL_CALLCONV HV*\tPerl_save_hash(pTHX_ GV* gv);\n#define PERL_ARGS_ASSERT_SAVE_HASH\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_save_hdelete(pTHX_ HV *hv, SV *keysv);\n#define PERL_ARGS_ASSERT_SAVE_HDELETE\t\\\n\tassert(hv); assert(keysv)\n/* PERL_CALLCONV void\tPerl_save_helem(pTHX_ HV *hv, SV *key, SV **sptr); */\nPERL_CALLCONV void\tPerl_save_helem_flags(pTHX_ HV *hv, SV *key, SV **sptr, const U32 flags);\n#define PERL_ARGS_ASSERT_SAVE_HELEM_FLAGS\t\\\n\tassert(hv); assert(key); assert(sptr)\nPERL_CALLCONV void\tPerl_save_hints(pTHX);\nPERL_CALLCONV void\tPerl_save_hptr(pTHX_ HV** hptr);\n#define PERL_ARGS_ASSERT_SAVE_HPTR\t\\\n\tassert(hptr)\nPERL_CALLCONV void\tPerl_save_int(pTHX_ int* intp);\n#define PERL_ARGS_ASSERT_SAVE_INT\t\\\n\tassert(intp)\nPERL_CALLCONV void\tPerl_save_item(pTHX_ SV* item);\n#define PERL_ARGS_ASSERT_SAVE_ITEM\t\\\n\tassert(item)\nPERL_CALLCONV void\tPerl_save_iv(pTHX_ IV *ivp);\n#define PERL_ARGS_ASSERT_SAVE_IV\t\\\n\tassert(ivp)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_list(pTHX_ SV** sarg, I32 maxsarg);\n#define PERL_ARGS_ASSERT_SAVE_LIST\t\\\n\tassert(sarg)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_long(pTHX_ long* longp);\n#define PERL_ARGS_ASSERT_SAVE_LONG\t\\\n\tassert(longp)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_mortalizesv(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_SAVE_MORTALIZESV\t\\\n\tassert(sv)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_nogv(pTHX_ GV* gv);\n#define PERL_ARGS_ASSERT_SAVE_NOGV\t\\\n\tassert(gv)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_save_op(pTHX);\n#endif\nPERL_CALLCONV void\tPerl_save_padsv_and_mortalize(pTHX_ PADOFFSET off);\nPERL_CALLCONV void\tPerl_save_pptr(pTHX_ char** pptr);\n#define PERL_ARGS_ASSERT_SAVE_PPTR\t\\\n\tassert(pptr)\nPERL_CALLCONV void\tPerl_save_pushi32ptr(pTHX_ const I32 i, void *const ptr, const int type);\nPERL_CALLCONV void\tPerl_save_pushptr(pTHX_ void *const ptr, const int type);\nPERL_CALLCONV void\tPerl_save_pushptrptr(pTHX_ void *const ptr1, void *const ptr2, const int type);\nPERL_CALLCONV void\tPerl_save_re_context(pTHX);\nPERL_CALLCONV SV*\tPerl_save_scalar(pTHX_ GV* gv);\n#define PERL_ARGS_ASSERT_SAVE_SCALAR\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_save_set_svflags(pTHX_ SV *sv, U32 mask, U32 val);\n#define PERL_ARGS_ASSERT_SAVE_SET_SVFLAGS\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_save_shared_pvref(pTHX_ char** str);\n#define PERL_ARGS_ASSERT_SAVE_SHARED_PVREF\t\\\n\tassert(str)\nPERL_CALLCONV void\tPerl_save_sptr(pTHX_ SV** sptr);\n#define PERL_ARGS_ASSERT_SAVE_SPTR\t\\\n\tassert(sptr)\nPERL_CALLCONV void\tPerl_save_strlen(pTHX_ STRLEN* ptr);\n#define PERL_ARGS_ASSERT_SAVE_STRLEN\t\\\n\tassert(ptr)\nPERL_CALLCONV SV*\tPerl_save_svref(pTHX_ SV** sptr);\n#define PERL_ARGS_ASSERT_SAVE_SVREF\t\\\n\tassert(sptr)\nPERL_CALLCONV void\tPerl_save_vptr(pTHX_ void *ptr);\n#define PERL_ARGS_ASSERT_SAVE_VPTR\t\\\n\tassert(ptr)\nPERL_CALLCONV char*\tPerl_savepv(pTHX_ const char* pv)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV char*\tPerl_savepvn(pTHX_ const char* pv, I32 len)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV char*\tPerl_savesharedpv(pTHX_ const char* pv)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV char*\tPerl_savesharedpvn(pTHX_ const char *const pv, const STRLEN len)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV char*\tPerl_savesharedsvpv(pTHX_ SV *sv)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SAVESHAREDSVPV\t\\\n\tassert(sv)\n\nPERL_CALLCONV void\tPerl_savestack_grow(pTHX);\nPERL_CALLCONV void\tPerl_savestack_grow_cnt(pTHX_ I32 need);\nPERL_CALLCONV char*\tPerl_savesvpv(pTHX_ SV* sv)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SAVESVPV\t\\\n\tassert(sv)\n\nPERL_CALLCONV void\tPerl_savetmps(pTHX);\nPERL_CALLCONV OP*\tPerl_sawparens(pTHX_ OP* o);\nPERL_CALLCONV OP*\tPerl_scalar(pTHX_ OP* o);\nPERL_CALLCONV OP*\tPerl_scalarvoid(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_SCALARVOID\t\\\n\tassert(o)\nPERL_CALLCONV NV\tPerl_scan_bin(pTHX_ const char* start, STRLEN len, STRLEN* retlen);\n#define PERL_ARGS_ASSERT_SCAN_BIN\t\\\n\tassert(start); assert(retlen)\nPERL_CALLCONV NV\tPerl_scan_hex(pTHX_ const char* start, STRLEN len, STRLEN* retlen);\n#define PERL_ARGS_ASSERT_SCAN_HEX\t\\\n\tassert(start); assert(retlen)\nPERL_CALLCONV char*\tPerl_scan_num(pTHX_ const char* s, YYSTYPE *lvalp);\n#define PERL_ARGS_ASSERT_SCAN_NUM\t\\\n\tassert(s); assert(lvalp)\nPERL_CALLCONV NV\tPerl_scan_oct(pTHX_ const char* start, STRLEN len, STRLEN* retlen);\n#define PERL_ARGS_ASSERT_SCAN_OCT\t\\\n\tassert(start); assert(retlen)\nPERL_CALLCONV char*\tPerl_scan_str(pTHX_ char *start, int keep_quoted, int keep_delims, int re_reparse, char **delimp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_STR\t\\\n\tassert(start)\n\nPERL_CALLCONV const char*\tPerl_scan_version(pTHX_ const char *s, SV *rv, bool qv);\n#define PERL_ARGS_ASSERT_SCAN_VERSION\t\\\n\tassert(s); assert(rv)\nPERL_CALLCONV char*\tPerl_scan_vstring(pTHX_ const char *s, const char *const e, SV *sv);\n#define PERL_ARGS_ASSERT_SCAN_VSTRING\t\\\n\tassert(s); assert(e); assert(sv)\nPERL_CALLCONV char*\tPerl_scan_word(pTHX_ char *s, char *dest, STRLEN destlen, int allow_package, STRLEN *slp);\n#define PERL_ARGS_ASSERT_SCAN_WORD\t\\\n\tassert(s); assert(dest); assert(slp)\nPERL_CALLCONV U32\tPerl_seed(pTHX);\nPERL_CALLCONV void\tPerl_set_caret_X(pTHX);\nPERL_CALLCONV void\tPerl_set_context(void *t);\n#define PERL_ARGS_ASSERT_SET_CONTEXT\t\\\n\tassert(t)\nPERL_CALLCONV void\tPerl_set_numeric_standard(pTHX);\nPERL_CALLCONV void\tPerl_set_numeric_underlying(pTHX);\nPERL_CALLCONV void\tPerl_setdefout(pTHX_ GV* gv);\n#define PERL_ARGS_ASSERT_SETDEFOUT\t\\\n\tassert(gv)\nPERL_CALLCONV void\tPerl_setfd_cloexec(int fd);\nPERL_CALLCONV void\tPerl_setfd_cloexec_for_nonsysfd(pTHX_ int fd);\nPERL_CALLCONV void\tPerl_setfd_cloexec_or_inhexec_by_sysfdness(pTHX_ int fd);\nPERL_CALLCONV void\tPerl_setfd_inhexec(int fd);\nPERL_CALLCONV void\tPerl_setfd_inhexec_for_sysfd(pTHX_ int fd);\nPERL_CALLCONV HEK*\tPerl_share_hek(pTHX_ const char* str, SSize_t len, U32 hash);\n#define PERL_ARGS_ASSERT_SHARE_HEK\t\\\n\tassert(str)\nPERL_CALLCONV char*\tPerl_skipspace_flags(pTHX_ char *s, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SKIPSPACE_FLAGS\t\\\n\tassert(s)\n\nPERL_CALLCONV void\tPerl_sortsv(pTHX_ SV** array, size_t num_elts, SVCOMPARE_t cmp);\n#define PERL_ARGS_ASSERT_SORTSV\t\\\n\tassert(cmp)\nPERL_CALLCONV void\tPerl_sortsv_flags(pTHX_ SV** array, size_t num_elts, SVCOMPARE_t cmp, U32 flags);\n#define PERL_ARGS_ASSERT_SORTSV_FLAGS\t\\\n\tassert(cmp)\nPERL_CALLCONV SV**\tPerl_stack_grow(pTHX_ SV** sp, SV** p, SSize_t n);\n#define PERL_ARGS_ASSERT_STACK_GROW\t\\\n\tassert(sp); assert(p)\nPERL_CALLCONV PerlIO*\tPerl_start_glob(pTHX_ SV *tmpglob, IO *io);\n#define PERL_ARGS_ASSERT_START_GLOB\t\\\n\tassert(tmpglob); assert(io)\nPERL_CALLCONV I32\tPerl_start_subparse(pTHX_ I32 is_format, U32 flags);\nPERL_CALLCONV NV\tPerl_str_to_version(pTHX_ SV *sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_STR_TO_VERSION\t\\\n\tassert(sv)\n\nPERL_CALLCONV void\tPerl_sub_crush_depth(pTHX_ CV* cv);\n#define PERL_ARGS_ASSERT_SUB_CRUSH_DEPTH\t\\\n\tassert(cv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV bool\tPerl_sv_2bool(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_2BOOL\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV bool\tPerl_sv_2bool_flags(pTHX_ SV *sv, I32 flags);\n#define PERL_ARGS_ASSERT_SV_2BOOL_FLAGS\t\\\n\tassert(sv)\nPERL_CALLCONV CV*\tPerl_sv_2cv(pTHX_ SV* sv, HV **const st, GV **const gvp, const I32 lref);\n#define PERL_ARGS_ASSERT_SV_2CV\t\\\n\tassert(st); assert(gvp)\nPERL_CALLCONV IO*\tPerl_sv_2io(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_2IO\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV IV\tPerl_sv_2iv(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_2IV\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV IV\tPerl_sv_2iv_flags(pTHX_ SV *const sv, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_2IV_FLAGS\t\\\n\tassert(sv)\nPERL_CALLCONV SV*\tPerl_sv_2mortal(pTHX_ SV *const sv);\nPERL_CALLCONV SV*\tPerl_sv_2num(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_2NUM\t\\\n\tassert(sv)\nPERL_CALLCONV NV\tPerl_sv_2nv_flags(pTHX_ SV *const sv, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_2NV_FLAGS\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_2pv(pTHX_ SV *sv, STRLEN *lp);\n#define PERL_ARGS_ASSERT_SV_2PV\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV char*\tPerl_sv_2pv_flags(pTHX_ SV *const sv, STRLEN *const lp, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_2PV_FLAGS\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_2pv_nolen(pTHX_ SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_2PV_NOLEN\t\\\n\tassert(sv)\n#endif\n\nPERL_CALLCONV char*\tPerl_sv_2pvbyte(pTHX_ SV *sv, STRLEN *const lp);\n#define PERL_ARGS_ASSERT_SV_2PVBYTE\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_2pvbyte_nolen(pTHX_ SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_2PVBYTE_NOLEN\t\\\n\tassert(sv)\n#endif\n\nPERL_CALLCONV char*\tPerl_sv_2pvutf8(pTHX_ SV *sv, STRLEN *const lp);\n#define PERL_ARGS_ASSERT_SV_2PVUTF8\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_2pvutf8_nolen(pTHX_ SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_2PVUTF8_NOLEN\t\\\n\tassert(sv)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_sv_2uv(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_2UV\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV UV\tPerl_sv_2uv_flags(pTHX_ SV *const sv, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_2UV_FLAGS\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_backoff(SV *const sv);\n#define PERL_ARGS_ASSERT_SV_BACKOFF\t\\\n\tassert(sv)\nPERL_CALLCONV SV*\tPerl_sv_bless(pTHX_ SV *const sv, HV *const stash);\n#define PERL_ARGS_ASSERT_SV_BLESS\t\\\n\tassert(sv); assert(stash)\nPERL_CALLCONV bool\tPerl_sv_cat_decode(pTHX_ SV* dsv, SV *encoding, SV *ssv, int *offset, char* tstr, int tlen);\n#define PERL_ARGS_ASSERT_SV_CAT_DECODE\t\\\n\tassert(dsv); assert(encoding); assert(ssv); assert(offset); assert(tstr)\nPERL_CALLCONV void\tPerl_sv_catpv(pTHX_ SV *const sv, const char* ptr);\n#define PERL_ARGS_ASSERT_SV_CATPV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_catpv_flags(pTHX_ SV *dstr, const char *sstr, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_CATPV_FLAGS\t\\\n\tassert(dstr); assert(sstr)\nPERL_CALLCONV void\tPerl_sv_catpv_mg(pTHX_ SV *const sv, const char *const ptr);\n#define PERL_ARGS_ASSERT_SV_CATPV_MG\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_catpvf(pTHX_ SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_2,pTHX_3);\n#define PERL_ARGS_ASSERT_SV_CATPVF\t\\\n\tassert(sv); assert(pat)\n\nPERL_CALLCONV void\tPerl_sv_catpvf_mg(pTHX_ SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_2,pTHX_3);\n#define PERL_ARGS_ASSERT_SV_CATPVF_MG\t\\\n\tassert(sv); assert(pat)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_catpvn(pTHX_ SV *dsv, const char *sstr, STRLEN len);\n#define PERL_ARGS_ASSERT_SV_CATPVN\t\\\n\tassert(dsv); assert(sstr)\n#endif\nPERL_CALLCONV void\tPerl_sv_catpvn_flags(pTHX_ SV *const dstr, const char *sstr, const STRLEN len, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_CATPVN_FLAGS\t\\\n\tassert(dstr); assert(sstr)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_catpvn_mg(pTHX_ SV *sv, const char *ptr, STRLEN len);\n#define PERL_ARGS_ASSERT_SV_CATPVN_MG\t\\\n\tassert(sv); assert(ptr)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_catsv(pTHX_ SV *dstr, SV *sstr);\n#define PERL_ARGS_ASSERT_SV_CATSV\t\\\n\tassert(dstr)\n#endif\nPERL_CALLCONV void\tPerl_sv_catsv_flags(pTHX_ SV *const dsv, SV *const ssv, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_CATSV_FLAGS\t\\\n\tassert(dsv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_catsv_mg(pTHX_ SV *dsv, SV *ssv);\n#define PERL_ARGS_ASSERT_SV_CATSV_MG\t\\\n\tassert(dsv)\n#endif\nPERL_CALLCONV void\tPerl_sv_chop(pTHX_ SV *const sv, const char *const ptr);\n#define PERL_ARGS_ASSERT_SV_CHOP\t\\\n\tassert(sv)\nPERL_CALLCONV I32\tPerl_sv_clean_all(pTHX);\nPERL_CALLCONV void\tPerl_sv_clean_objs(pTHX);\nPERL_CALLCONV void\tPerl_sv_clear(pTHX_ SV *const orig_sv);\n#define PERL_ARGS_ASSERT_SV_CLEAR\t\\\n\tassert(orig_sv)\nPERL_CALLCONV I32\tPerl_sv_cmp(pTHX_ SV *const sv1, SV *const sv2);\nPERL_CALLCONV I32\tPerl_sv_cmp_flags(pTHX_ SV *const sv1, SV *const sv2, const U32 flags);\nPERL_CALLCONV I32\tPerl_sv_cmp_locale(pTHX_ SV *const sv1, SV *const sv2);\nPERL_CALLCONV I32\tPerl_sv_cmp_locale_flags(pTHX_ SV *const sv1, SV *const sv2, const U32 flags);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_copypv(pTHX_ SV *const dsv, SV *const ssv);\n#define PERL_ARGS_ASSERT_SV_COPYPV\t\\\n\tassert(dsv); assert(ssv)\n#endif\nPERL_CALLCONV void\tPerl_sv_copypv_flags(pTHX_ SV *const dsv, SV *const ssv, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_COPYPV_FLAGS\t\\\n\tassert(dsv); assert(ssv)\n/* PERL_CALLCONV void\tPerl_sv_copypv_nomg(pTHX_ SV *const dsv, SV *const ssv); */\nPERL_CALLCONV void\tPerl_sv_dec(pTHX_ SV *const sv);\nPERL_CALLCONV void\tPerl_sv_dec_nomg(pTHX_ SV *const sv);\nPERL_CALLCONV void\tPerl_sv_del_backref(pTHX_ SV *const tsv, SV *const sv);\n#define PERL_ARGS_ASSERT_SV_DEL_BACKREF\t\\\n\tassert(tsv); assert(sv)\nPERL_CALLCONV bool\tPerl_sv_derived_from(pTHX_ SV* sv, const char *const name)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DERIVED_FROM\t\\\n\tassert(sv); assert(name)\n\nPERL_CALLCONV bool\tPerl_sv_derived_from_pv(pTHX_ SV* sv, const char *const name, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DERIVED_FROM_PV\t\\\n\tassert(sv); assert(name)\n\nPERL_CALLCONV bool\tPerl_sv_derived_from_pvn(pTHX_ SV* sv, const char *const name, const STRLEN len, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DERIVED_FROM_PVN\t\\\n\tassert(sv); assert(name)\n\nPERL_CALLCONV bool\tPerl_sv_derived_from_sv(pTHX_ SV* sv, SV *namesv, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DERIVED_FROM_SV\t\\\n\tassert(sv); assert(namesv)\n\nPERL_CALLCONV bool\tPerl_sv_destroyable(pTHX_ SV *sv);\nPERL_CALLCONV bool\tPerl_sv_does(pTHX_ SV* sv, const char *const name)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DOES\t\\\n\tassert(sv); assert(name)\n\nPERL_CALLCONV bool\tPerl_sv_does_pv(pTHX_ SV* sv, const char *const name, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DOES_PV\t\\\n\tassert(sv); assert(name)\n\nPERL_CALLCONV bool\tPerl_sv_does_pvn(pTHX_ SV* sv, const char *const name, const STRLEN len, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DOES_PVN\t\\\n\tassert(sv); assert(name)\n\nPERL_CALLCONV bool\tPerl_sv_does_sv(pTHX_ SV* sv, SV* namesv, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DOES_SV\t\\\n\tassert(sv); assert(namesv)\n\nPERL_CALLCONV void\tPerl_sv_dump(pTHX_ SV* sv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV I32\tPerl_sv_eq(pTHX_ SV* sv1, SV* sv2);\n#endif\nPERL_CALLCONV I32\tPerl_sv_eq_flags(pTHX_ SV* sv1, SV* sv2, const U32 flags);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_force_normal(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_FORCE_NORMAL\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV void\tPerl_sv_force_normal_flags(pTHX_ SV *const sv, const U32 flags);\n#define PERL_ARGS_ASSERT_SV_FORCE_NORMAL_FLAGS\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_free(pTHX_ SV *const sv);\nPERL_CALLCONV void\tPerl_sv_free2(pTHX_ SV *const sv, const U32 refcnt);\n#define PERL_ARGS_ASSERT_SV_FREE2\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_free_arenas(pTHX);\nPERL_CALLCONV SV*\tPerl_sv_get_backrefs(SV *const sv);\n#define PERL_ARGS_ASSERT_SV_GET_BACKREFS\t\\\n\tassert(sv)\nPERL_CALLCONV char*\tPerl_sv_gets(pTHX_ SV *const sv, PerlIO *const fp, I32 append);\n#define PERL_ARGS_ASSERT_SV_GETS\t\\\n\tassert(sv); assert(fp)\nPERL_CALLCONV char*\tPerl_sv_grow(pTHX_ SV *const sv, STRLEN newlen);\n#define PERL_ARGS_ASSERT_SV_GROW\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_inc(pTHX_ SV *const sv);\nPERL_CALLCONV void\tPerl_sv_inc_nomg(pTHX_ SV *const sv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_insert(pTHX_ SV *const bigstr, const STRLEN offset, const STRLEN len, const char *const little, const STRLEN littlelen);\n#define PERL_ARGS_ASSERT_SV_INSERT\t\\\n\tassert(bigstr); assert(little)\n#endif\nPERL_CALLCONV void\tPerl_sv_insert_flags(pTHX_ SV *const bigstr, const STRLEN offset, const STRLEN len, const char *little, const STRLEN littlelen, const U32 flags);\n#define PERL_ARGS_ASSERT_SV_INSERT_FLAGS\t\\\n\tassert(bigstr); assert(little)\nPERL_CALLCONV int\tPerl_sv_isa(pTHX_ SV* sv, const char *const name);\n#define PERL_ARGS_ASSERT_SV_ISA\t\\\n\tassert(name)\nPERL_CALLCONV int\tPerl_sv_isobject(pTHX_ SV* sv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV IV\tPerl_sv_iv(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_SV_IV\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV STRLEN\tPerl_sv_len(pTHX_ SV *const sv);\nPERL_CALLCONV STRLEN\tPerl_sv_len_utf8(pTHX_ SV *const sv);\nPERL_CALLCONV STRLEN\tPerl_sv_len_utf8_nomg(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_LEN_UTF8_NOMG\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_magic(pTHX_ SV *const sv, SV *const obj, const int how, const char *const name, const I32 namlen);\n#define PERL_ARGS_ASSERT_SV_MAGIC\t\\\n\tassert(sv)\nPERL_CALLCONV MAGIC *\tPerl_sv_magicext(pTHX_ SV *const sv, SV *const obj, const int how, const MGVTBL *const vtbl, const char *const name, const I32 namlen);\n#define PERL_ARGS_ASSERT_SV_MAGICEXT\t\\\n\tassert(sv)\nPERL_CALLCONV MAGIC *\tPerl_sv_magicext_mglob(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_MAGICEXT_MGLOB\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV SV*\tPerl_sv_mortalcopy(pTHX_ SV *const oldsv)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV SV*\tPerl_sv_mortalcopy_flags(pTHX_ SV *const oldsv, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_sv_newmortal(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl_sv_newref(pTHX_ SV *const sv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_nolocking(pTHX_ SV *sv);\n#endif\nPERL_CALLCONV void\tPerl_sv_nosharing(pTHX_ SV *sv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_nounlocking(pTHX_ SV *sv);\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV NV\tPerl_sv_nv(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_SV_NV\t\\\n\tassert(sv)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_sv_only_taint_gmagic(SV *sv);\n#define PERL_ARGS_ASSERT_SV_ONLY_TAINT_GMAGIC\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV char*\tPerl_sv_peek(pTHX_ SV* sv);\nPERL_CALLCONV void\tPerl_sv_pos_b2u(pTHX_ SV *const sv, I32 *const offsetp);\n#define PERL_ARGS_ASSERT_SV_POS_B2U\t\\\n\tassert(offsetp)\nPERL_CALLCONV STRLEN\tPerl_sv_pos_b2u_flags(pTHX_ SV *const sv, STRLEN const offset, U32 flags);\n#define PERL_ARGS_ASSERT_SV_POS_B2U_FLAGS\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_pos_u2b(pTHX_ SV *const sv, I32 *const offsetp, I32 *const lenp);\n#define PERL_ARGS_ASSERT_SV_POS_U2B\t\\\n\tassert(offsetp)\nPERL_CALLCONV STRLEN\tPerl_sv_pos_u2b_flags(pTHX_ SV *const sv, STRLEN uoffset, STRLEN *const lenp, U32 flags);\n#define PERL_ARGS_ASSERT_SV_POS_U2B_FLAGS\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pv(pTHX_ SV *sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_PV\t\\\n\tassert(sv)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pvbyte(pTHX_ SV *sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_PVBYTE\t\\\n\tassert(sv)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pvbyten(pTHX_ SV *sv, STRLEN *lp);\n#define PERL_ARGS_ASSERT_SV_PVBYTEN\t\\\n\tassert(sv); assert(lp)\n#endif\nPERL_CALLCONV char*\tPerl_sv_pvbyten_force(pTHX_ SV *const sv, STRLEN *const lp);\n#define PERL_ARGS_ASSERT_SV_PVBYTEN_FORCE\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pvn(pTHX_ SV *sv, STRLEN *lp);\n#define PERL_ARGS_ASSERT_SV_PVN\t\\\n\tassert(sv); assert(lp)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pvn_force(pTHX_ SV* sv, STRLEN* lp);\n#define PERL_ARGS_ASSERT_SV_PVN_FORCE\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV char*\tPerl_sv_pvn_force_flags(pTHX_ SV *const sv, STRLEN *const lp, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_PVN_FORCE_FLAGS\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pvn_nomg(pTHX_ SV* sv, STRLEN* lp);\n#define PERL_ARGS_ASSERT_SV_PVN_NOMG\t\\\n\tassert(sv)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pvutf8(pTHX_ SV *sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_PVUTF8\t\\\n\tassert(sv)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_pvutf8n(pTHX_ SV *sv, STRLEN *lp);\n#define PERL_ARGS_ASSERT_SV_PVUTF8N\t\\\n\tassert(sv); assert(lp)\n#endif\nPERL_CALLCONV char*\tPerl_sv_pvutf8n_force(pTHX_ SV *const sv, STRLEN *const lp);\n#define PERL_ARGS_ASSERT_SV_PVUTF8N_FORCE\t\\\n\tassert(sv)\nPERL_CALLCONV char*\tPerl_sv_recode_to_utf8(pTHX_ SV* sv, SV *encoding);\n#define PERL_ARGS_ASSERT_SV_RECODE_TO_UTF8\t\\\n\tassert(sv); assert(encoding)\nPERL_CALLCONV SV*\tPerl_sv_ref(pTHX_ SV *dst, const SV *const sv, const int ob);\n#define PERL_ARGS_ASSERT_SV_REF\t\\\n\tassert(sv)\nPERL_CALLCONV const char*\tPerl_sv_reftype(pTHX_ const SV *const sv, const int ob)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_REFTYPE\t\\\n\tassert(sv)\n\nPERL_CALLCONV void\tPerl_sv_replace(pTHX_ SV *const sv, SV *const nsv);\n#define PERL_ARGS_ASSERT_SV_REPLACE\t\\\n\tassert(sv); assert(nsv)\nPERL_CALLCONV void\tPerl_sv_report_used(pTHX);\nPERL_CALLCONV void\tPerl_sv_reset(pTHX_ const char* s, HV *const stash);\n#define PERL_ARGS_ASSERT_SV_RESET\t\\\n\tassert(s)\nPERL_CALLCONV void\tPerl_sv_resetpvn(pTHX_ const char* s, STRLEN len, HV *const stash);\nPERL_CALLCONV SV*\tPerl_sv_rvunweaken(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_RVUNWEAKEN\t\\\n\tassert(sv)\nPERL_CALLCONV SV*\tPerl_sv_rvweaken(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_RVWEAKEN\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_set_undef(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_SET_UNDEF\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_sethek(pTHX_ SV *const sv, const HEK *const hek);\n#define PERL_ARGS_ASSERT_SV_SETHEK\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setiv(pTHX_ SV *const sv, const IV num);\n#define PERL_ARGS_ASSERT_SV_SETIV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setiv_mg(pTHX_ SV *const sv, const IV i);\n#define PERL_ARGS_ASSERT_SV_SETIV_MG\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setnv(pTHX_ SV *const sv, const NV num);\n#define PERL_ARGS_ASSERT_SV_SETNV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setnv_mg(pTHX_ SV *const sv, const NV num);\n#define PERL_ARGS_ASSERT_SV_SETNV_MG\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setpv(pTHX_ SV *const sv, const char *const ptr);\n#define PERL_ARGS_ASSERT_SV_SETPV\t\\\n\tassert(sv)\nPERL_CALLCONV char  *\tPerl_sv_setpv_bufsize(pTHX_ SV *const sv, const STRLEN cur, const STRLEN len);\n#define PERL_ARGS_ASSERT_SV_SETPV_BUFSIZE\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setpv_mg(pTHX_ SV *const sv, const char *const ptr);\n#define PERL_ARGS_ASSERT_SV_SETPV_MG\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setpvf(pTHX_ SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_2,pTHX_3);\n#define PERL_ARGS_ASSERT_SV_SETPVF\t\\\n\tassert(sv); assert(pat)\n\nPERL_CALLCONV void\tPerl_sv_setpvf_mg(pTHX_ SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_2,pTHX_3);\n#define PERL_ARGS_ASSERT_SV_SETPVF_MG\t\\\n\tassert(sv); assert(pat)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_setpviv(pTHX_ SV *const sv, const IV num);\n#define PERL_ARGS_ASSERT_SV_SETPVIV\t\\\n\tassert(sv)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_setpviv_mg(pTHX_ SV *const sv, const IV iv);\n#define PERL_ARGS_ASSERT_SV_SETPVIV_MG\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV void\tPerl_sv_setpvn(pTHX_ SV *const sv, const char *const ptr, const STRLEN len);\n#define PERL_ARGS_ASSERT_SV_SETPVN\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setpvn_mg(pTHX_ SV *const sv, const char *const ptr, const STRLEN len);\n#define PERL_ARGS_ASSERT_SV_SETPVN_MG\t\\\n\tassert(sv); assert(ptr)\nPERL_CALLCONV SV*\tPerl_sv_setref_iv(pTHX_ SV *const rv, const char *const classname, const IV iv);\n#define PERL_ARGS_ASSERT_SV_SETREF_IV\t\\\n\tassert(rv)\nPERL_CALLCONV SV*\tPerl_sv_setref_nv(pTHX_ SV *const rv, const char *const classname, const NV nv);\n#define PERL_ARGS_ASSERT_SV_SETREF_NV\t\\\n\tassert(rv)\nPERL_CALLCONV SV*\tPerl_sv_setref_pv(pTHX_ SV *const rv, const char *const classname, void *const pv);\n#define PERL_ARGS_ASSERT_SV_SETREF_PV\t\\\n\tassert(rv)\nPERL_CALLCONV SV*\tPerl_sv_setref_pvn(pTHX_ SV *const rv, const char *const classname, const char *const pv, const STRLEN n);\n#define PERL_ARGS_ASSERT_SV_SETREF_PVN\t\\\n\tassert(rv); assert(pv)\nPERL_CALLCONV SV*\tPerl_sv_setref_uv(pTHX_ SV *const rv, const char *const classname, const UV uv);\n#define PERL_ARGS_ASSERT_SV_SETREF_UV\t\\\n\tassert(rv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_setsv(pTHX_ SV *dstr, SV *sstr);\n#define PERL_ARGS_ASSERT_SV_SETSV\t\\\n\tassert(dstr)\n#endif\nPERL_CALLCONV void\tPerl_sv_setsv_flags(pTHX_ SV *dstr, SV *sstr, const I32 flags);\n#define PERL_ARGS_ASSERT_SV_SETSV_FLAGS\t\\\n\tassert(dstr)\nPERL_CALLCONV void\tPerl_sv_setsv_mg(pTHX_ SV *const dstr, SV *const sstr);\n#define PERL_ARGS_ASSERT_SV_SETSV_MG\t\\\n\tassert(dstr)\nPERL_CALLCONV void\tPerl_sv_setuv(pTHX_ SV *const sv, const UV num);\n#define PERL_ARGS_ASSERT_SV_SETUV\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_setuv_mg(pTHX_ SV *const sv, const UV u);\n#define PERL_ARGS_ASSERT_SV_SETUV_MG\t\\\n\tassert(sv)\nPERL_CALLCONV SV*\tPerl_sv_string_from_errnum(pTHX_ int errnum, SV* tgtsv);\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_taint(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_SV_TAINT\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV bool\tPerl_sv_tainted(pTHX_ SV *const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_TAINTED\t\\\n\tassert(sv)\n\nPERL_CALLCONV I32\tPerl_sv_true(pTHX_ SV *const sv);\nPERL_CALLCONV char*\tPerl_sv_uni_display(pTHX_ SV *dsv, SV *ssv, STRLEN pvlim, UV flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_UNI_DISPLAY\t\\\n\tassert(dsv); assert(ssv)\n\nPERL_CALLCONV int\tPerl_sv_unmagic(pTHX_ SV *const sv, const int type);\n#define PERL_ARGS_ASSERT_SV_UNMAGIC\t\\\n\tassert(sv)\nPERL_CALLCONV int\tPerl_sv_unmagicext(pTHX_ SV *const sv, const int type, MGVTBL *vtbl);\n#define PERL_ARGS_ASSERT_SV_UNMAGICEXT\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_unref(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_SV_UNREF\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV void\tPerl_sv_unref_flags(pTHX_ SV *const ref, const U32 flags);\n#define PERL_ARGS_ASSERT_SV_UNREF_FLAGS\t\\\n\tassert(ref)\nPERL_CALLCONV void\tPerl_sv_untaint(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_UNTAINT\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_upgrade(pTHX_ SV *const sv, svtype new_type);\n#define PERL_ARGS_ASSERT_SV_UPGRADE\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_usepvn(pTHX_ SV* sv, char* ptr, STRLEN len);\n#define PERL_ARGS_ASSERT_SV_USEPVN\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV void\tPerl_sv_usepvn_flags(pTHX_ SV *const sv, char* ptr, const STRLEN len, const U32 flags);\n#define PERL_ARGS_ASSERT_SV_USEPVN_FLAGS\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV void\tPerl_sv_usepvn_mg(pTHX_ SV *sv, char *ptr, STRLEN len);\n#define PERL_ARGS_ASSERT_SV_USEPVN_MG\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV bool\tPerl_sv_utf8_decode(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_UTF8_DECODE\t\\\n\tassert(sv)\nPERL_CALLCONV bool\tPerl_sv_utf8_downgrade(pTHX_ SV *const sv, const bool fail_ok);\n#define PERL_ARGS_ASSERT_SV_UTF8_DOWNGRADE\t\\\n\tassert(sv)\nPERL_CALLCONV void\tPerl_sv_utf8_encode(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_UTF8_ENCODE\t\\\n\tassert(sv)\n#ifndef NO_MATHOMS\nPERL_CALLCONV STRLEN\tPerl_sv_utf8_upgrade(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_UTF8_UPGRADE\t\\\n\tassert(sv)\n#endif\n/* PERL_CALLCONV STRLEN\tPerl_sv_utf8_upgrade_flags(pTHX_ SV *const sv, const I32 flags); */\nPERL_CALLCONV STRLEN\tPerl_sv_utf8_upgrade_flags_grow(pTHX_ SV *const sv, const I32 flags, STRLEN extra);\n#define PERL_ARGS_ASSERT_SV_UTF8_UPGRADE_FLAGS_GROW\t\\\n\tassert(sv)\n/* PERL_CALLCONV STRLEN\tsv_utf8_upgrade_nomg(pTHX_ SV *sv); */\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_sv_uv(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_SV_UV\t\\\n\tassert(sv)\n#endif\nPERL_CALLCONV void\tPerl_sv_vcatpvf(pTHX_ SV *const sv, const char *const pat, va_list *const args);\n#define PERL_ARGS_ASSERT_SV_VCATPVF\t\\\n\tassert(sv); assert(pat)\nPERL_CALLCONV void\tPerl_sv_vcatpvf_mg(pTHX_ SV *const sv, const char *const pat, va_list *const args);\n#define PERL_ARGS_ASSERT_SV_VCATPVF_MG\t\\\n\tassert(sv); assert(pat)\nPERL_CALLCONV void\tPerl_sv_vcatpvfn(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen, va_list *const args, SV **const svargs, const Size_t sv_count, bool *const maybe_tainted);\n#define PERL_ARGS_ASSERT_SV_VCATPVFN\t\\\n\tassert(sv); assert(pat)\nPERL_CALLCONV void\tPerl_sv_vcatpvfn_flags(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen, va_list *const args, SV **const svargs, const Size_t sv_count, bool *const maybe_tainted, const U32 flags);\n#define PERL_ARGS_ASSERT_SV_VCATPVFN_FLAGS\t\\\n\tassert(sv); assert(pat)\nPERL_CALLCONV void\tPerl_sv_vsetpvf(pTHX_ SV *const sv, const char *const pat, va_list *const args);\n#define PERL_ARGS_ASSERT_SV_VSETPVF\t\\\n\tassert(sv); assert(pat)\nPERL_CALLCONV void\tPerl_sv_vsetpvf_mg(pTHX_ SV *const sv, const char *const pat, va_list *const args);\n#define PERL_ARGS_ASSERT_SV_VSETPVF_MG\t\\\n\tassert(sv); assert(pat)\nPERL_CALLCONV void\tPerl_sv_vsetpvfn(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen, va_list *const args, SV **const svargs, const Size_t sv_count, bool *const maybe_tainted);\n#define PERL_ARGS_ASSERT_SV_VSETPVFN\t\\\n\tassert(sv); assert(pat)\nPERL_CALLCONV UV\tPerl_swash_fetch(pTHX_ SV *swash, const U8 *ptr, bool do_utf8);\n#define PERL_ARGS_ASSERT_SWASH_FETCH\t\\\n\tassert(swash); assert(ptr)\nPERL_CALLCONV SV*\tPerl_swash_init(pTHX_ const char* pkg, const char* name, SV* listsv, I32 minbits, I32 none)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SWASH_INIT\t\\\n\tassert(pkg); assert(name); assert(listsv)\n\nPERL_CALLCONV void\tPerl_switch_to_global_locale(void);\nPERL_CALLCONV bool\tPerl_sync_locale(void);\nPERL_CALLCONV void\tPerl_sys_init(int* argc, char*** argv);\n#define PERL_ARGS_ASSERT_SYS_INIT\t\\\n\tassert(argc); assert(argv)\nPERL_CALLCONV void\tPerl_sys_init3(int* argc, char*** argv, char*** env);\n#define PERL_ARGS_ASSERT_SYS_INIT3\t\\\n\tassert(argc); assert(argv); assert(env)\nPERL_CALLCONV void\tPerl_sys_term(void);\nPERL_CALLCONV void\tPerl_taint_env(pTHX);\nPERL_CALLCONV void\tPerl_taint_proper(pTHX_ const char* f, const char *const s);\n#define PERL_ARGS_ASSERT_TAINT_PROPER\t\\\n\tassert(s)\nPERL_CALLCONV void\tPerl_thread_locale_init(void);\nPERL_CALLCONV void\tPerl_thread_locale_term(void);\nPERL_CALLCONV OP *\tPerl_tied_method(pTHX_ SV *methname, SV **sp, SV *const sv, const MAGIC *const mg, const U32 flags, U32 argc, ...);\n#define PERL_ARGS_ASSERT_TIED_METHOD\t\\\n\tassert(methname); assert(sp); assert(sv); assert(mg)\nPERL_CALLCONV SSize_t\tPerl_tmps_grow_p(pTHX_ SSize_t ix);\n/* PERL_CALLCONV UV\tPerl_to_uni_fold(pTHX_ UV c, U8 *p, STRLEN *lenp); */\nPERL_CALLCONV UV\tPerl_to_uni_lower(pTHX_ UV c, U8 *p, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_TO_UNI_LOWER\t\\\n\tassert(p); assert(lenp)\n#ifndef NO_MATHOMS\nPERL_CALLCONV U32\tPerl_to_uni_lower_lc(pTHX_ U32 c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV UV\tPerl_to_uni_title(pTHX_ UV c, U8 *p, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_TO_UNI_TITLE\t\\\n\tassert(p); assert(lenp)\n#ifndef NO_MATHOMS\nPERL_CALLCONV U32\tPerl_to_uni_title_lc(pTHX_ U32 c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nPERL_CALLCONV UV\tPerl_to_uni_upper(pTHX_ UV c, U8 *p, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_TO_UNI_UPPER\t\\\n\tassert(p); assert(lenp)\n#ifndef NO_MATHOMS\nPERL_CALLCONV U32\tPerl_to_uni_upper_lc(pTHX_ U32 c)\n\t\t\t__attribute__deprecated__\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_to_utf8_fold(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_TO_UTF8_FOLD\t\\\n\tassert(p); assert(ustrp)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_to_utf8_lower(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_TO_UTF8_LOWER\t\\\n\tassert(p); assert(ustrp)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_to_utf8_title(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_TO_UTF8_TITLE\t\\\n\tassert(p); assert(ustrp)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_to_utf8_upper(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_TO_UTF8_UPPER\t\\\n\tassert(p); assert(ustrp)\n#endif\n\nPERL_CALLCONV bool\tPerl_try_amagic_bin(pTHX_ int method, int flags);\nPERL_CALLCONV bool\tPerl_try_amagic_un(pTHX_ int method, int flags);\n#ifndef NO_MATHOMS\nPERL_CALLCONV SSize_t\tPerl_unpack_str(pTHX_ const char *pat, const char *patend, const char *s, const char *strbeg, const char *strend, char **new_s, I32 ocnt, U32 flags);\n#define PERL_ARGS_ASSERT_UNPACK_STR\t\\\n\tassert(pat); assert(patend); assert(s); assert(strend)\n#endif\nPERL_CALLCONV SSize_t\tPerl_unpackstring(pTHX_ const char *pat, const char *patend, const char *s, const char *strend, U32 flags);\n#define PERL_ARGS_ASSERT_UNPACKSTRING\t\\\n\tassert(pat); assert(patend); assert(s); assert(strend)\nPERL_CALLCONV void\tPerl_unshare_hek(pTHX_ HEK* hek);\nPERL_CALLCONV void\tPerl_unsharepvn(pTHX_ const char* sv, I32 len, U32 hash);\nPERL_CALLCONV SV*\tPerl_upg_version(pTHX_ SV *ver, bool qv);\n#define PERL_ARGS_ASSERT_UPG_VERSION\t\\\n\tassert(ver)\nPERL_CALLCONV U8*\tPerl_utf16_to_utf8(pTHX_ U8* p, U8 *d, I32 bytelen, I32 *newlen);\n#define PERL_ARGS_ASSERT_UTF16_TO_UTF8\t\\\n\tassert(p); assert(d); assert(newlen)\nPERL_CALLCONV U8*\tPerl_utf16_to_utf8_reversed(pTHX_ U8* p, U8 *d, I32 bytelen, I32 *newlen);\n#define PERL_ARGS_ASSERT_UTF16_TO_UTF8_REVERSED\t\\\n\tassert(p); assert(d); assert(newlen)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE IV\tPerl_utf8_distance(pTHX_ const U8 *a, const U8 *b)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UTF8_DISTANCE\t\\\n\tassert(a); assert(b)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE U8*\tPerl_utf8_hop(const U8 *s, SSize_t off)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UTF8_HOP\t\\\n\tassert(s)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE U8*\tPerl_utf8_hop_back(const U8 *s, SSize_t off, const U8 *start)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UTF8_HOP_BACK\t\\\n\tassert(s); assert(start)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE U8*\tPerl_utf8_hop_forward(const U8 *s, SSize_t off, const U8 *end)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UTF8_HOP_FORWARD\t\\\n\tassert(s); assert(end)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE U8*\tPerl_utf8_hop_safe(const U8 *s, SSize_t off, const U8 *start, const U8 *end)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UTF8_HOP_SAFE\t\\\n\tassert(s); assert(start); assert(end)\n#endif\n\nPERL_CALLCONV STRLEN\tPerl_utf8_length(pTHX_ const U8* s, const U8 *e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UTF8_LENGTH\t\\\n\tassert(s); assert(e)\n\nPERL_CALLCONV U8*\tPerl_utf8_to_bytes(pTHX_ U8 *s, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_UTF8_TO_BYTES\t\\\n\tassert(s); assert(lenp)\nPERL_CALLCONV UV\tPerl_utf8_to_uvchr(pTHX_ const U8 *s, STRLEN *retlen)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_UTF8_TO_UVCHR\t\\\n\tassert(s)\n\nPERL_CALLCONV UV\tPerl_utf8_to_uvchr_buf(pTHX_ const U8 *s, const U8 *send, STRLEN *retlen);\n#define PERL_ARGS_ASSERT_UTF8_TO_UVCHR_BUF\t\\\n\tassert(s); assert(send)\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_utf8_to_uvuni(pTHX_ const U8 *s, STRLEN *retlen)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_UTF8_TO_UVUNI\t\\\n\tassert(s)\n#endif\n\nPERL_CALLCONV UV\tPerl_utf8_to_uvuni_buf(pTHX_ const U8 *s, const U8 *send, STRLEN *retlen)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_UTF8_TO_UVUNI_BUF\t\\\n\tassert(s); assert(send)\n\nPERL_CALLCONV UV\tPerl_utf8n_to_uvchr(const U8 *s, STRLEN curlen, STRLEN *retlen, const U32 flags);\n#define PERL_ARGS_ASSERT_UTF8N_TO_UVCHR\t\\\n\tassert(s)\nPERL_CALLCONV UV\tPerl_utf8n_to_uvchr_error(const U8 *s, STRLEN curlen, STRLEN *retlen, const U32 flags, U32 * errors);\n#define PERL_ARGS_ASSERT_UTF8N_TO_UVCHR_ERROR\t\\\n\tassert(s)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE UV\tS_utf8n_to_uvchr_msgs(const U8 *s, STRLEN curlen, STRLEN *retlen, const U32 flags, U32 * errors, AV ** msgs);\n#define PERL_ARGS_ASSERT_UTF8N_TO_UVCHR_MSGS\t\\\n\tassert(s)\n#endif\nPERL_CALLCONV UV\tPerl_utf8n_to_uvuni(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags);\n#define PERL_ARGS_ASSERT_UTF8N_TO_UVUNI\t\\\n\tassert(s)\nPERL_CALLCONV void\tPerl_utilize(pTHX_ int aver, I32 floor, OP* version, OP* idop, OP* arg);\n#define PERL_ARGS_ASSERT_UTILIZE\t\\\n\tassert(idop)\n/* PERL_CALLCONV U8*\tuvchr_to_utf8(pTHX_ U8 *d, UV uv); */\n/* PERL_CALLCONV U8*\tuvchr_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags); */\n/* PERL_CALLCONV U8*\tuvchr_to_utf8_flags_msgs(pTHX_ U8 *d, UV uv, UV flags, HV ** msgs); */\nPERL_CALLCONV U8*\tPerl_uvoffuni_to_utf8_flags(pTHX_ U8 *d, UV uv, const UV flags);\n#define PERL_ARGS_ASSERT_UVOFFUNI_TO_UTF8_FLAGS\t\\\n\tassert(d)\nPERL_CALLCONV U8*\tPerl_uvoffuni_to_utf8_flags_msgs(pTHX_ U8 *d, UV uv, const UV flags, HV** msgs);\n#define PERL_ARGS_ASSERT_UVOFFUNI_TO_UTF8_FLAGS_MSGS\t\\\n\tassert(d)\nPERL_CALLCONV U8*\tPerl_uvuni_to_utf8(pTHX_ U8 *d, UV uv);\n#define PERL_ARGS_ASSERT_UVUNI_TO_UTF8\t\\\n\tassert(d)\nPERL_CALLCONV U8*\tPerl_uvuni_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags);\n#define PERL_ARGS_ASSERT_UVUNI_TO_UTF8_FLAGS\t\\\n\tassert(d)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE UV\tPerl_valid_utf8_to_uvchr(const U8 *s, STRLEN *retlen)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_VALID_UTF8_TO_UVCHR\t\\\n\tassert(s)\n#endif\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV UV\tPerl_valid_utf8_to_uvuni(pTHX_ const U8 *s, STRLEN *retlen)\n\t\t\t__attribute__deprecated__;\n#define PERL_ARGS_ASSERT_VALID_UTF8_TO_UVUNI\t\\\n\tassert(s)\n#endif\n\nPERL_CALLCONV bool\tPerl_validate_proto(pTHX_ SV *name, SV *proto, bool warn, bool curstash);\n#define PERL_ARGS_ASSERT_VALIDATE_PROTO\t\\\n\tassert(name)\nPERL_CALLCONV int\tPerl_vcmp(pTHX_ SV *lhv, SV *rhv);\n#define PERL_ARGS_ASSERT_VCMP\t\\\n\tassert(lhv); assert(rhv)\nPERL_CALLCONV_NO_RET void\tPerl_vcroak(pTHX_ const char* pat, va_list* args)\n\t\t\t__attribute__noreturn__;\n\nPERL_CALLCONV void\tPerl_vdeb(pTHX_ const char* pat, va_list* args);\n#define PERL_ARGS_ASSERT_VDEB\t\\\n\tassert(pat)\nPERL_CALLCONV char*\tPerl_vform(pTHX_ const char* pat, va_list* args);\n#define PERL_ARGS_ASSERT_VFORM\t\\\n\tassert(pat)\nPERL_CALLCONV void\tPerl_vivify_defelem(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_VIVIFY_DEFELEM\t\\\n\tassert(sv)\nPERL_CALLCONV SV*\tPerl_vivify_ref(pTHX_ SV* sv, U32 to_what)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_VIVIFY_REF\t\\\n\tassert(sv)\n\nPERL_CALLCONV void\tPerl_vload_module(pTHX_ U32 flags, SV* name, SV* ver, va_list* args);\n#define PERL_ARGS_ASSERT_VLOAD_MODULE\t\\\n\tassert(name)\nPERL_CALLCONV SV*\tPerl_vmess(pTHX_ const char* pat, va_list* args);\n#define PERL_ARGS_ASSERT_VMESS\t\\\n\tassert(pat)\nPERL_CALLCONV SV*\tPerl_vnewSVpvf(pTHX_ const char *const pat, va_list *const args)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_VNEWSVPVF\t\\\n\tassert(pat)\n\nPERL_CALLCONV SV*\tPerl_vnormal(pTHX_ SV *vs);\n#define PERL_ARGS_ASSERT_VNORMAL\t\\\n\tassert(vs)\nPERL_CALLCONV SV*\tPerl_vnumify(pTHX_ SV *vs);\n#define PERL_ARGS_ASSERT_VNUMIFY\t\\\n\tassert(vs)\nPERL_CALLCONV SV*\tPerl_vstringify(pTHX_ SV *vs);\n#define PERL_ARGS_ASSERT_VSTRINGIFY\t\\\n\tassert(vs)\nPERL_CALLCONV SV*\tPerl_vverify(pTHX_ SV *vs);\n#define PERL_ARGS_ASSERT_VVERIFY\t\\\n\tassert(vs)\nPERL_CALLCONV void\tPerl_vwarn(pTHX_ const char* pat, va_list* args);\n#define PERL_ARGS_ASSERT_VWARN\t\\\n\tassert(pat)\nPERL_CALLCONV void\tPerl_vwarner(pTHX_ U32 err, const char* pat, va_list* args);\n#define PERL_ARGS_ASSERT_VWARNER\t\\\n\tassert(pat)\nPERL_CALLCONV I32\tPerl_wait4pid(pTHX_ Pid_t pid, int* statusp, int flags);\n#define PERL_ARGS_ASSERT_WAIT4PID\t\\\n\tassert(statusp)\nPERL_CALLCONV void\tPerl_warn(pTHX_ const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_1,pTHX_2);\n#define PERL_ARGS_ASSERT_WARN\t\\\n\tassert(pat)\n\nPERL_CALLCONV void\tPerl_warn_sv(pTHX_ SV *baseex);\n#define PERL_ARGS_ASSERT_WARN_SV\t\\\n\tassert(baseex)\nPERL_CALLCONV void\tPerl_warner(pTHX_ U32 err, const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,pTHX_2,pTHX_3);\n#define PERL_ARGS_ASSERT_WARNER\t\\\n\tassert(pat)\n\nPERL_CALLCONV I32\tPerl_was_lvalue_sub(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV void\tPerl_watch(pTHX_ char** addr);\n#define PERL_ARGS_ASSERT_WATCH\t\\\n\tassert(addr)\n/* PERL_CALLCONV I32\twhichsig(pTHX_ const char* sig); */\nPERL_CALLCONV I32\tPerl_whichsig_pv(pTHX_ const char* sig);\n#define PERL_ARGS_ASSERT_WHICHSIG_PV\t\\\n\tassert(sig)\nPERL_CALLCONV I32\tPerl_whichsig_pvn(pTHX_ const char* sig, STRLEN len);\n#define PERL_ARGS_ASSERT_WHICHSIG_PVN\t\\\n\tassert(sig)\nPERL_CALLCONV I32\tPerl_whichsig_sv(pTHX_ SV* sigsv);\n#define PERL_ARGS_ASSERT_WHICHSIG_SV\t\\\n\tassert(sigsv)\nPERL_CALLCONV void\tPerl_wrap_keyword_plugin(pTHX_ Perl_keyword_plugin_t new_plugin, Perl_keyword_plugin_t *old_plugin_p);\n#define PERL_ARGS_ASSERT_WRAP_KEYWORD_PLUGIN\t\\\n\tassert(new_plugin); assert(old_plugin_p)\nPERL_CALLCONV void\tPerl_wrap_op_checker(pTHX_ Optype opcode, Perl_check_t new_checker, Perl_check_t *old_checker_p);\n#define PERL_ARGS_ASSERT_WRAP_OP_CHECKER\t\\\n\tassert(new_checker); assert(old_checker_p)\nPERL_CALLCONV void\tPerl_write_to_stderr(pTHX_ SV* msv);\n#define PERL_ARGS_ASSERT_WRITE_TO_STDERR\t\\\n\tassert(msv)\nPERL_CALLCONV void\tPerl_xs_boot_epilog(pTHX_ const I32 ax);\nPERL_CALLCONV I32\tPerl_xs_handshake(const U32 key, void * v_my_perl, const char * file, ...);\n#define PERL_ARGS_ASSERT_XS_HANDSHAKE\t\\\n\tassert(v_my_perl); assert(file)\nPERL_CALLCONV int\tPerl_yyerror(pTHX_ const char *const s);\n#define PERL_ARGS_ASSERT_YYERROR\t\\\n\tassert(s)\nPERL_CALLCONV int\tPerl_yyerror_pv(pTHX_ const char *const s, U32 flags);\n#define PERL_ARGS_ASSERT_YYERROR_PV\t\\\n\tassert(s)\nPERL_CALLCONV int\tPerl_yyerror_pvn(pTHX_ const char *const s, STRLEN len, U32 flags);\nPERL_CALLCONV int\tPerl_yylex(pTHX);\nPERL_CALLCONV int\tPerl_yyparse(pTHX_ int gramtype);\nPERL_CALLCONV void\tPerl_yyquit(pTHX);\nPERL_CALLCONV void\tPerl_yyunlex(pTHX);\n#if ! defined(HAS_MEMRCHR) && (defined(PERL_CORE) || defined(PERL_EXT))\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void *\tS_my_memrchr(const char * s, const char c, const STRLEN len);\n#define PERL_ARGS_ASSERT_MY_MEMRCHR\t\\\n\tassert(s)\n#endif\n#endif\n#if !(defined(DEBUGGING))\n#  if !defined(NV_PRESERVES_UV)\n#    if defined(PERL_IN_SV_C)\nSTATIC int\tS_sv_2iuv_non_preserve(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_2IUV_NON_PRESERVE\t\\\n\tassert(sv)\n#    endif\n#  endif\n#endif\n#if !(defined(HAS_MEMMEM))\nPERL_CALLCONV char*\tPerl_ninstr(const char* big, const char* bigend, const char* little, const char* lend)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#define PERL_ARGS_ASSERT_NINSTR\t\\\n\tassert(big); assert(bigend); assert(little); assert(lend)\n\n#endif\n#if !(defined(HAS_NL_LANGINFO) && defined(PERL_LANGINFO_H))\nPERL_CALLCONV const char*\tPerl_langinfo(const int item);\n#endif\n#if !(defined(HAS_NL_LANGINFO))\n#  if defined(PERL_IN_LOCALE_C)\nSTATIC const char*\tS_my_nl_langinfo(const int item, bool toggle);\n#  endif\n#endif\n#if !(defined(HAS_SIGACTION) && defined(SA_SIGINFO))\nPERL_CALLCONV Signal_t\tPerl_csighandler(int sig);\nPERL_CALLCONV Signal_t\tPerl_sighandler(int sig);\n#endif\n#if !(defined(PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION))\nPERL_CALLCONV bool\tPerl_do_exec(pTHX_ const char* cmd);\n#define PERL_ARGS_ASSERT_DO_EXEC\t\\\n\tassert(cmd)\n#endif\n#if !(defined(PERL_GLOBAL_STRUCT_PRIVATE))\n#  if defined(PERL_IMPLICIT_CONTEXT)\nPERL_CALLCONV void*\tPerl_my_cxt_init(pTHX_ int *indexp, size_t size);\n#define PERL_ARGS_ASSERT_MY_CXT_INIT\t\\\n\tassert(indexp)\n#  endif\n#endif\n#if !(defined(_MSC_VER))\nPERL_CALLCONV_NO_RET int\tPerl_magic_regdatum_set(pTHX_ SV* sv, MAGIC* mg)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_MAGIC_REGDATUM_SET\t\\\n\tassert(sv); assert(mg)\n\n#endif\n#if !defined(EBCDIC)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE unsigned int\tS__variant_byte_number(PERL_UINTMAX_T word)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#endif\n#if !defined(HAS_GETENV_LEN)\nPERL_CALLCONV char*\tPerl_getenv_len(pTHX_ const char *env_elem, unsigned long *len);\n#define PERL_ARGS_ASSERT_GETENV_LEN\t\\\n\tassert(env_elem); assert(len)\n#endif\n#if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)\n#  if defined(PERL_IN_PP_SYS_C)\nSTATIC int\tS_dooneliner(pTHX_ const char *cmd, const char *filename)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DOONELINER\t\\\n\tassert(cmd); assert(filename)\n\n#  endif\n#endif\n#if !defined(HAS_MKOSTEMP)\nPERL_CALLCONV int\tPerl_my_mkostemp(char *templte, int flags);\n#define PERL_ARGS_ASSERT_MY_MKOSTEMP\t\\\n\tassert(templte)\n#endif\n#if !defined(HAS_MKSTEMP)\nPERL_CALLCONV int\tPerl_my_mkstemp(char *templte);\n#define PERL_ARGS_ASSERT_MY_MKSTEMP\t\\\n\tassert(templte)\n#endif\n#if !defined(HAS_RENAME)\nPERL_CALLCONV I32\tPerl_same_dirent(pTHX_ const char* a, const char* b);\n#define PERL_ARGS_ASSERT_SAME_DIRENT\t\\\n\tassert(a); assert(b)\n#endif\n#if !defined(HAS_SIGNBIT)\nPERL_CALLCONV int\tPerl_signbit(NV f)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n\n#endif\n#if !defined(HAS_STRLCAT)\nPERL_CALLCONV Size_t\tPerl_my_strlcat(char *dst, const char *src, Size_t size);\n#endif\n#if !defined(HAS_STRLCPY)\nPERL_CALLCONV Size_t\tPerl_my_strlcpy(char *dst, const char *src, Size_t size);\n#endif\n#if !defined(HAS_STRNLEN)\nPERL_CALLCONV Size_t\tPerl_my_strnlen(const char *str, Size_t maxlen);\n#define PERL_ARGS_ASSERT_MY_STRNLEN\t\\\n\tassert(str)\n#endif\n#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)\nPERL_CALLCONV I32\tPerl_my_chsize(pTHX_ int fd, Off_t length)\n\t\t\t__attribute__warn_unused_result__;\n\n#endif\n#if !defined(NV_PRESERVES_UV)\n#  if defined(DEBUGGING)\n#    if defined(PERL_IN_SV_C)\nSTATIC int\tS_sv_2iuv_non_preserve(pTHX_ SV *const sv, I32 numtype);\n#define PERL_ARGS_ASSERT_SV_2IUV_NON_PRESERVE\t\\\n\tassert(sv)\n#    endif\n#  endif\n#endif\n#if !defined(PERL_DISABLE_PMC)\n#  if defined(PERL_IN_PP_CTL_C)\nSTATIC PerlIO *\tS_doopen_pm(pTHX_ SV *name)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DOOPEN_PM\t\\\n\tassert(name)\n\n#  endif\n#endif\n#if !defined(PERL_EXT_RE_BUILD)\n#  if defined(PERL_IN_REGCOMP_C)\nSTATIC void\tS__append_range_to_invlist(pTHX_ SV* const invlist, const UV start, const UV end);\n#define PERL_ARGS_ASSERT__APPEND_RANGE_TO_INVLIST\t\\\n\tassert(invlist)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE UV*\tS__invlist_array_init(SV* const invlist, const bool will_have_0)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__INVLIST_ARRAY_INIT\t\\\n\tassert(invlist)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE IV*\tS_get_invlist_previous_index_addr(SV* invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_INVLIST_PREVIOUS_INDEX_ADDR\t\\\n\tassert(invlist)\n#endif\n\nSTATIC void\tS_initialize_invlist_guts(pTHX_ SV* invlist, const Size_t initial_size);\n#define PERL_ARGS_ASSERT_INITIALIZE_INVLIST_GUTS\t\\\n\tassert(invlist)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_invlist_clear(pTHX_ SV* invlist);\n#define PERL_ARGS_ASSERT_INVLIST_CLEAR\t\\\n\tassert(invlist)\n#endif\nSTATIC void\tS_invlist_extend(pTHX_ SV* const invlist, const UV len);\n#define PERL_ARGS_ASSERT_INVLIST_EXTEND\t\\\n\tassert(invlist)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE UV\tS_invlist_max(SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_INVLIST_MAX\t\\\n\tassert(invlist)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE IV\tS_invlist_previous_index(SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX\t\\\n\tassert(invlist)\n#endif\n\nSTATIC void\tS_invlist_replace_list_destroys_src(pTHX_ SV *dest, SV *src);\n#define PERL_ARGS_ASSERT_INVLIST_REPLACE_LIST_DESTROYS_SRC\t\\\n\tassert(dest); assert(src)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_invlist_set_len(pTHX_ SV* const invlist, const UV len, const bool offset);\n#define PERL_ARGS_ASSERT_INVLIST_SET_LEN\t\\\n\tassert(invlist)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_invlist_set_previous_index(SV* const invlist, const IV index);\n#define PERL_ARGS_ASSERT_INVLIST_SET_PREVIOUS_INDEX\t\\\n\tassert(invlist)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_invlist_trim(SV* invlist);\n#define PERL_ARGS_ASSERT_INVLIST_TRIM\t\\\n\tassert(invlist)\n#endif\n#  endif\n#endif\n#if !defined(PERL_IMPLICIT_SYS)\nPERL_CALLCONV I32\tPerl_my_pclose(pTHX_ PerlIO* ptr);\nPERL_CALLCONV PerlIO*\tPerl_my_popen(pTHX_ const char* cmd, const char* mode);\n#define PERL_ARGS_ASSERT_MY_POPEN\t\\\n\tassert(cmd); assert(mode)\n#endif\n#if !defined(PERL_IS_MINIPERL)\n#  if defined(PERL_IN_PERL_C)\nSTATIC SV *\tS_incpush_if_exists(pTHX_ AV *const av, SV *dir, SV *const stem);\n#define PERL_ARGS_ASSERT_INCPUSH_IF_EXISTS\t\\\n\tassert(av); assert(dir); assert(stem)\n#  endif\n#endif\n#if !defined(PERL_NO_INLINE_FUNCTIONS)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popblock(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPBLOCK\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popeval(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPEVAL\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popformat(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPFORMAT\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popgiven(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPGIVEN\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_poploop(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPLOOP\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popsub(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPSUB\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popsub_args(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPSUB_ARGS\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popsub_common(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPSUB_COMMON\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_popwhen(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_POPWHEN\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE PERL_CONTEXT *\tS_cx_pushblock(pTHX_ U8 type, U8 gimme, SV** sp, I32 saveix);\n#define PERL_ARGS_ASSERT_CX_PUSHBLOCK\t\\\n\tassert(sp)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_pusheval(pTHX_ PERL_CONTEXT *cx, OP *retop, SV *namesv);\n#define PERL_ARGS_ASSERT_CX_PUSHEVAL\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_pushformat(pTHX_ PERL_CONTEXT *cx, CV *cv, OP *retop, GV *gv);\n#define PERL_ARGS_ASSERT_CX_PUSHFORMAT\t\\\n\tassert(cx); assert(cv)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_pushgiven(pTHX_ PERL_CONTEXT *cx, SV *orig_defsv);\n#define PERL_ARGS_ASSERT_CX_PUSHGIVEN\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_pushloop_for(pTHX_ PERL_CONTEXT *cx, void *itervarp, SV *itersave);\n#define PERL_ARGS_ASSERT_CX_PUSHLOOP_FOR\t\\\n\tassert(cx); assert(itervarp)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_pushloop_plain(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_PUSHLOOP_PLAIN\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_pushsub(pTHX_ PERL_CONTEXT *cx, CV *cv, OP *retop, bool hasargs);\n#define PERL_ARGS_ASSERT_CX_PUSHSUB\t\\\n\tassert(cx); assert(cv)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_pushwhen(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_PUSHWHEN\t\\\n\tassert(cx)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_cx_topblock(pTHX_ PERL_CONTEXT *cx);\n#define PERL_ARGS_ASSERT_CX_TOPBLOCK\t\\\n\tassert(cx)\n#endif\n#endif\n#if !defined(PERL_NO_UTF16_FILTER)\n#  if defined(PERL_IN_TOKE_C)\nSTATIC U8*\tS_add_utf16_textfilter(pTHX_ U8 *const s, bool reversed);\n#define PERL_ARGS_ASSERT_ADD_UTF16_TEXTFILTER\t\\\n\tassert(s)\nSTATIC I32\tS_utf16_textfilter(pTHX_ int idx, SV *sv, int maxlen);\n#define PERL_ARGS_ASSERT_UTF16_TEXTFILTER\t\\\n\tassert(sv)\n#  endif\n#endif\n#if !defined(SETUID_SCRIPTS_ARE_SECURE_NOW)\n#  if defined(PERL_IN_PERL_C)\nSTATIC void\tS_validate_suid(pTHX_ PerlIO *rsfp);\n#define PERL_ARGS_ASSERT_VALIDATE_SUID\t\\\n\tassert(rsfp)\n#  endif\n#endif\n#if !defined(UV_IS_QUAD)\n#  if defined(PERL_IN_UTF8_C)\nSTATIC int\tS_is_utf8_cp_above_31_bits(const U8 * const s, const U8 * const e, const bool consider_overlongs)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_CP_ABOVE_31_BITS\t\\\n\tassert(s); assert(e)\n\n#  endif\n#endif\n#if !defined(WIN32)\nPERL_CALLCONV bool\tPerl_do_exec3(pTHX_ const char *incmd, int fd, int do_report);\n#define PERL_ARGS_ASSERT_DO_EXEC3\t\\\n\tassert(incmd)\n#endif\n#if defined (HAS_SOCKETPAIR) ||     (defined (HAS_SOCKET) && defined(SOCK_DGRAM) && \tdefined(AF_INET) && defined(PF_INET))\nPERL_CALLCONV int\tPerl_PerlSock_socketpair_cloexec(pTHX_ int domain, int type, int protocol, int *pairfd)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PERLSOCK_SOCKETPAIR_CLOEXEC\t\\\n\tassert(pairfd)\n\n#endif\n#if defined(DEBUGGING)\nPERL_CALLCONV int\tPerl_get_debug_opts(pTHX_ const char **s, bool givehelp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_DEBUG_OPTS\t\\\n\tassert(s)\n\nPERL_CALLCONV void\tPerl_hv_assert(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_HV_ASSERT\t\\\n\tassert(hv)\nPERL_CALLCONV void\tPerl_pad_setsv(pTHX_ PADOFFSET po, SV* sv);\n#define PERL_ARGS_ASSERT_PAD_SETSV\t\\\n\tassert(sv)\nPERL_CALLCONV SV*\tPerl_pad_sv(pTHX_ PADOFFSET po);\nPERL_CALLCONV void\tPerl_set_padlist(CV * cv, PADLIST * padlist);\n#define PERL_ARGS_ASSERT_SET_PADLIST\t\\\n\tassert(cv)\n#  if defined(PERL_IN_LOCALE_C)\n#    if defined(USE_LOCALE)\nSTATIC void\tS_print_bytes_for_locale(pTHX_ const char * const s, const char * const e, const bool is_utf8);\n#define PERL_ARGS_ASSERT_PRINT_BYTES_FOR_LOCALE\t\\\n\tassert(s); assert(e)\nSTATIC void\tS_print_collxfrm_input_and_return(pTHX_ const char * const s, const char * const e, const STRLEN * const xlen, const bool is_utf8);\n#define PERL_ARGS_ASSERT_PRINT_COLLXFRM_INPUT_AND_RETURN\t\\\n\tassert(s); assert(e)\nSTATIC char *\tS_setlocale_debug_string(const int category, const char* const locale, const char* const retval)\n\t\t\t__attribute__warn_unused_result__;\n\n#    endif\n#  endif\n#  if defined(PERL_IN_PAD_C)\nSTATIC void\tS_cv_dump(pTHX_ const CV *cv, const char *title);\n#define PERL_ARGS_ASSERT_CV_DUMP\t\\\n\tassert(cv); assert(title)\n#  endif\n#  if defined(PERL_IN_REGCOMP_C)\nSTATIC void\tS_dump_trie(pTHX_ const struct _reg_trie_data *trie, HV* widecharmap, AV *revcharmap, U32 depth);\n#define PERL_ARGS_ASSERT_DUMP_TRIE\t\\\n\tassert(trie); assert(revcharmap)\nSTATIC void\tS_dump_trie_interim_list(pTHX_ const struct _reg_trie_data *trie, HV* widecharmap, AV *revcharmap, U32 next_alloc, U32 depth);\n#define PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_LIST\t\\\n\tassert(trie); assert(revcharmap)\nSTATIC void\tS_dump_trie_interim_table(pTHX_ const struct _reg_trie_data *trie, HV* widecharmap, AV *revcharmap, U32 next_alloc, U32 depth);\n#define PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_TABLE\t\\\n\tassert(trie); assert(revcharmap)\nSTATIC const regnode*\tS_dumpuntil(pTHX_ const regexp *r, const regnode *start, const regnode *node, const regnode *last, const regnode *plast, SV* sv, I32 indent, U32 depth);\n#define PERL_ARGS_ASSERT_DUMPUNTIL\t\\\n\tassert(r); assert(start); assert(node); assert(sv)\nSTATIC bool\tS_put_charclass_bitmap_innards(pTHX_ SV* sv, char* bitmap, SV* nonbitmap_invlist, SV* only_utf8_locale_invlist, const regnode * const node, const bool force_as_is_display);\n#define PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS\t\\\n\tassert(sv)\nSTATIC SV*\tS_put_charclass_bitmap_innards_common(pTHX_ SV* invlist, SV* posixes, SV* only_utf8, SV* not_utf8, SV* only_utf8_locale, const bool invert);\n#define PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_COMMON\t\\\n\tassert(invlist)\nSTATIC void\tS_put_charclass_bitmap_innards_invlist(pTHX_ SV *sv, SV* invlist);\n#define PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_INVLIST\t\\\n\tassert(sv); assert(invlist)\nSTATIC void\tS_put_code_point(pTHX_ SV* sv, UV c);\n#define PERL_ARGS_ASSERT_PUT_CODE_POINT\t\\\n\tassert(sv)\nSTATIC void\tS_put_range(pTHX_ SV* sv, UV start, const UV end, const bool allow_literals);\n#define PERL_ARGS_ASSERT_PUT_RANGE\t\\\n\tassert(sv)\nPERL_CALLCONV int\tPerl_re_indentf(pTHX_ const char *fmt, U32 depth, ...);\n#define PERL_ARGS_ASSERT_RE_INDENTF\t\\\n\tassert(fmt)\nSTATIC void\tS_regdump_extflags(pTHX_ const char *lead, const U32 flags);\nSTATIC void\tS_regdump_intflags(pTHX_ const char *lead, const U32 flags);\nSTATIC bool\tS_regtail_study(pTHX_ RExC_state_t *pRExC_state, regnode_offset p, const regnode_offset val, U32 depth)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGTAIL_STUDY\t\\\n\tassert(pRExC_state); assert(p); assert(val)\n\n#  endif\n#  if defined(PERL_IN_REGEXEC_C)\nSTATIC void\tS_debug_start_match(pTHX_ const REGEXP *prog, const bool do_utf8, const char *start, const char *end, const char *blurb);\n#define PERL_ARGS_ASSERT_DEBUG_START_MATCH\t\\\n\tassert(prog); assert(start); assert(end); assert(blurb)\nSTATIC void\tS_dump_exec_pos(pTHX_ const char *locinput, const regnode *scan, const char *loc_regeol, const char *loc_bostr, const char *loc_reg_starttry, const bool do_utf8, const U32 depth);\n#define PERL_ARGS_ASSERT_DUMP_EXEC_POS\t\\\n\tassert(locinput); assert(scan); assert(loc_regeol); assert(loc_bostr); assert(loc_reg_starttry)\nPERL_CALLCONV int\tPerl_re_exec_indentf(pTHX_ const char *fmt, U32 depth, ...);\n#define PERL_ARGS_ASSERT_RE_EXEC_INDENTF\t\\\n\tassert(fmt)\n#  endif\n#  if defined(PERL_IN_SV_C)\nSTATIC void\tS_del_sv(pTHX_ SV *p);\n#define PERL_ARGS_ASSERT_DEL_SV\t\\\n\tassert(p)\n#  endif\n#  if defined(PERL_IN_TOKE_C)\nSTATIC void\tS_printbuf(pTHX_ const char *const fmt, const char *const s)\n\t\t\t__attribute__format__(__printf__,pTHX_1,0);\n#define PERL_ARGS_ASSERT_PRINTBUF\t\\\n\tassert(fmt); assert(s)\n\nSTATIC int\tS_tokereport(pTHX_ I32 rv, const YYSTYPE* lvalp);\n#define PERL_ARGS_ASSERT_TOKEREPORT\t\\\n\tassert(lvalp)\n#  endif\n#endif\n#if defined(DEBUGGING) && defined(ENABLE_REGEX_SETS_DEBUGGING)\n#  if defined(PERL_IN_REGCOMP_C)\nSTATIC void\tS_dump_regex_sets_structures(pTHX_ RExC_state_t *pRExC_state, AV * stack, const IV fence, AV * fence_stack);\n#define PERL_ARGS_ASSERT_DUMP_REGEX_SETS_STRUCTURES\t\\\n\tassert(pRExC_state); assert(stack); assert(fence_stack)\n#  endif\n#endif\n#if defined(DEBUG_LEAKING_SCALARS_FORK_DUMP)\nPERL_CALLCONV void\tPerl_dump_sv_child(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_DUMP_SV_CHILD\t\\\n\tassert(sv)\n#endif\n#if defined(HAS_MEMMEM)\nPERL_CALLCONV char*\tPerl_ninstr(const char* big, const char* bigend, const char* little, const char* lend)\n\t\t\t__attribute__warn_unused_result__\n\t\t\t__attribute__pure__;\n#define PERL_ARGS_ASSERT_NINSTR\t\\\n\tassert(big); assert(bigend); assert(little); assert(lend)\n\n#endif\n#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)\nPERL_CALLCONV I32\tPerl_do_ipcctl(pTHX_ I32 optype, SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_IPCCTL\t\\\n\tassert(mark); assert(sp)\nPERL_CALLCONV I32\tPerl_do_ipcget(pTHX_ I32 optype, SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_IPCGET\t\\\n\tassert(mark); assert(sp)\nPERL_CALLCONV I32\tPerl_do_msgrcv(pTHX_ SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_MSGRCV\t\\\n\tassert(mark); assert(sp)\nPERL_CALLCONV I32\tPerl_do_msgsnd(pTHX_ SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_MSGSND\t\\\n\tassert(mark); assert(sp)\nPERL_CALLCONV I32\tPerl_do_semop(pTHX_ SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_SEMOP\t\\\n\tassert(mark); assert(sp)\nPERL_CALLCONV I32\tPerl_do_shmio(pTHX_ I32 optype, SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_SHMIO\t\\\n\tassert(mark); assert(sp)\n#endif\n#if defined(HAS_NL_LANGINFO)\n#  if defined(PERL_IN_LOCALE_C)\nSTATIC const char*\tS_my_nl_langinfo(const nl_item item, bool toggle);\n#  endif\n#endif\n#if defined(HAS_NL_LANGINFO) && defined(PERL_LANGINFO_H)\nPERL_CALLCONV const char*\tPerl_langinfo(const nl_item item);\n#endif\n#if defined(HAS_PIPE)\nPERL_CALLCONV int\tPerl_PerlProc_pipe_cloexec(pTHX_ int *pipefd)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PERLPROC_PIPE_CLOEXEC\t\\\n\tassert(pipefd)\n\n#endif\n#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)\nPERL_CALLCONV Signal_t\tPerl_csighandler(int sig, siginfo_t *info, void *uap);\nPERL_CALLCONV Signal_t\tPerl_sighandler(int sig, siginfo_t *info, void *uap);\n#endif\n#if defined(HAS_SOCKET)\nPERL_CALLCONV int\tPerl_PerlSock_accept_cloexec(pTHX_ int listenfd, struct sockaddr *addr, Sock_size_t *addrlen)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV int\tPerl_PerlSock_socket_cloexec(pTHX_ int domain, int type, int protocol)\n\t\t\t__attribute__warn_unused_result__;\n\n#endif\n#if defined(HAVE_INTERP_INTERN)\nPERL_CALLCONV void\tPerl_sys_intern_clear(pTHX);\nPERL_CALLCONV void\tPerl_sys_intern_init(pTHX);\n#  if defined(USE_ITHREADS)\nPERL_CALLCONV void\tPerl_sys_intern_dup(pTHX_ struct interp_intern* src, struct interp_intern* dst);\n#define PERL_ARGS_ASSERT_SYS_INTERN_DUP\t\\\n\tassert(src); assert(dst)\n#  endif\n#endif\n#if defined(MYMALLOC)\nPERL_CALLCONV void\tPerl_dump_mstats(pTHX_ const char* s);\n#define PERL_ARGS_ASSERT_DUMP_MSTATS\t\\\n\tassert(s)\nPERL_CALLCONV int\tPerl_get_mstats(pTHX_ perl_mstats_t *buf, int buflen, int level);\n#define PERL_ARGS_ASSERT_GET_MSTATS\t\\\n\tassert(buf)\nPERL_CALLCONV MEM_SIZE\tPerl_malloc_good_size(size_t nbytes)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV MEM_SIZE\tPerl_malloced_size(void *p)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MALLOCED_SIZE\t\\\n\tassert(p)\n\n#endif\n#if defined(PERL_ANY_COW)\nPERL_CALLCONV SV*\tPerl_sv_setsv_cow(pTHX_ SV* dstr, SV* sstr);\n#define PERL_ARGS_ASSERT_SV_SETSV_COW\t\\\n\tassert(sstr)\n#endif\n#if defined(PERL_CORE)\nPERL_CALLCONV void\tPerl_opslab_force_free(pTHX_ OPSLAB *slab);\n#define PERL_ARGS_ASSERT_OPSLAB_FORCE_FREE\t\\\n\tassert(slab)\nPERL_CALLCONV void\tPerl_opslab_free(pTHX_ OPSLAB *slab);\n#define PERL_ARGS_ASSERT_OPSLAB_FREE\t\\\n\tassert(slab)\nPERL_CALLCONV void\tPerl_opslab_free_nopad(pTHX_ OPSLAB *slab);\n#define PERL_ARGS_ASSERT_OPSLAB_FREE_NOPAD\t\\\n\tassert(slab)\nPERL_CALLCONV void\tPerl_parser_free_nexttoke_ops(pTHX_ yy_parser *parser, OPSLAB *slab);\n#define PERL_ARGS_ASSERT_PARSER_FREE_NEXTTOKE_OPS\t\\\n\tassert(parser); assert(slab)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_should_warn_nl(const char *pv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SHOULD_WARN_NL\t\\\n\tassert(pv)\n#endif\n\n#  if defined(PERL_DEBUG_READONLY_OPS)\nPERL_CALLCONV void\tPerl_Slab_to_ro(pTHX_ OPSLAB *slab);\n#define PERL_ARGS_ASSERT_SLAB_TO_RO\t\\\n\tassert(slab)\nPERL_CALLCONV void\tPerl_Slab_to_rw(pTHX_ OPSLAB *const slab);\n#define PERL_ARGS_ASSERT_SLAB_TO_RW\t\\\n\tassert(slab)\n#  endif\n#endif\n#if defined(PERL_CORE) || defined (PERL_EXT)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_non_invariant_string(const U8* const s, STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_NON_INVARIANT_STRING\t\\\n\tassert(s)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE STRLEN\tS_sv_or_pv_pos_u2b(pTHX_ SV *sv, const char *pv, STRLEN pos, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_SV_OR_PV_POS_U2B\t\\\n\tassert(sv); assert(pv)\n#endif\n#endif\n#if defined(PERL_CORE) || defined(PERL_EXT)\nPERL_CALLCONV bool\tPerl_isSCRIPT_RUN(pTHX_ const U8 *s, const U8 *send, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISSCRIPT_RUN\t\\\n\tassert(s); assert(send)\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE Size_t\tS_variant_under_utf8_count(const U8* const s, const U8* const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_VARIANT_UNDER_UTF8_COUNT\t\\\n\tassert(s); assert(e)\n#endif\n\n#endif\n#if defined(PERL_CR_FILTER)\n#  if defined(PERL_IN_TOKE_C)\nSTATIC I32\tS_cr_textfilter(pTHX_ int idx, SV *sv, int maxlen);\nSTATIC void\tS_strip_return(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_STRIP_RETURN\t\\\n\tassert(sv)\n#  endif\n#endif\n#if defined(PERL_DEBUG_READONLY_COW)\nPERL_CALLCONV void\tPerl_sv_buf_to_ro(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_BUF_TO_RO\t\\\n\tassert(sv)\n#  if defined(PERL_IN_SV_C)\nSTATIC void\tS_sv_buf_to_rw(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_SV_BUF_TO_RW\t\\\n\tassert(sv)\n#  endif\n#endif\n#if defined(PERL_DEBUG_READONLY_OPS)\nPERL_CALLCONV PADOFFSET\tPerl_op_refcnt_dec(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_OP_REFCNT_DEC\t\\\n\tassert(o)\nPERL_CALLCONV OP *\tPerl_op_refcnt_inc(pTHX_ OP *o);\n#endif\n#if defined(PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION)\n/* PERL_CALLCONV bool\tPerl_do_exec(pTHX_ const char* cmd); */\n#endif\n#if defined(PERL_DONT_CREATE_GVSV)\n#ifndef NO_MATHOMS\nPERL_CALLCONV GV*\tPerl_gv_SVadd(pTHX_ GV *gv);\n#endif\n#endif\n#if defined(PERL_GLOBAL_STRUCT)\nPERL_CALLCONV struct perl_vars *\tPerl_GetVars(pTHX);\nPERL_CALLCONV void\tPerl_free_global_struct(pTHX_ struct perl_vars *plvarsp);\n#define PERL_ARGS_ASSERT_FREE_GLOBAL_STRUCT\t\\\n\tassert(plvarsp)\nPERL_CALLCONV struct perl_vars*\tPerl_init_global_struct(pTHX);\n#endif\n#if defined(PERL_GLOBAL_STRUCT_PRIVATE)\n#  if defined(PERL_IMPLICIT_CONTEXT)\nPERL_CALLCONV int\tPerl_my_cxt_index(pTHX_ const char *my_cxt_key);\n#define PERL_ARGS_ASSERT_MY_CXT_INDEX\t\\\n\tassert(my_cxt_key)\nPERL_CALLCONV void*\tPerl_my_cxt_init(pTHX_ const char *my_cxt_key, size_t size);\n#define PERL_ARGS_ASSERT_MY_CXT_INIT\t\\\n\tassert(my_cxt_key)\n#  endif\n#endif\n#if defined(PERL_IMPLICIT_CONTEXT)\nPERL_CALLCONV_NO_RET void\tPerl_croak_nocontext(const char* pat, ...)\n\t\t\t__attribute__noreturn__\n\t\t\t__attribute__format__null_ok__(__printf__,1,2);\n\nPERL_CALLCONV void\tPerl_deb_nocontext(const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,1,2);\n#define PERL_ARGS_ASSERT_DEB_NOCONTEXT\t\\\n\tassert(pat)\n\nPERL_CALLCONV_NO_RET OP*\tPerl_die_nocontext(const char* pat, ...)\n\t\t\t__attribute__noreturn__\n\t\t\t__attribute__format__null_ok__(__printf__,1,2);\n\nPERL_CALLCONV char*\tPerl_form_nocontext(const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,1,2);\n#define PERL_ARGS_ASSERT_FORM_NOCONTEXT\t\\\n\tassert(pat)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV int\tPerl_fprintf_nocontext(PerlIO *stream, const char *format, ...)\n\t\t\t__attribute__format__(__printf__,2,3);\n#define PERL_ARGS_ASSERT_FPRINTF_NOCONTEXT\t\\\n\tassert(stream); assert(format)\n#endif\n\nPERL_CALLCONV void\tPerl_load_module_nocontext(U32 flags, SV* name, SV* ver, ...);\n#define PERL_ARGS_ASSERT_LOAD_MODULE_NOCONTEXT\t\\\n\tassert(name)\nPERL_CALLCONV SV*\tPerl_mess_nocontext(const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,1,2);\n#define PERL_ARGS_ASSERT_MESS_NOCONTEXT\t\\\n\tassert(pat)\n\nPERL_CALLCONV SV*\tPerl_newSVpvf_nocontext(const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,1,2);\n#define PERL_ARGS_ASSERT_NEWSVPVF_NOCONTEXT\t\\\n\tassert(pat)\n\n#ifndef NO_MATHOMS\nPERL_CALLCONV int\tPerl_printf_nocontext(const char *format, ...)\n\t\t\t__attribute__format__(__printf__,1,2);\n#define PERL_ARGS_ASSERT_PRINTF_NOCONTEXT\t\\\n\tassert(format)\n#endif\n\nPERL_CALLCONV void\tPerl_sv_catpvf_mg_nocontext(SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,2,3);\n#define PERL_ARGS_ASSERT_SV_CATPVF_MG_NOCONTEXT\t\\\n\tassert(sv); assert(pat)\n\nPERL_CALLCONV void\tPerl_sv_catpvf_nocontext(SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,2,3);\n#define PERL_ARGS_ASSERT_SV_CATPVF_NOCONTEXT\t\\\n\tassert(sv); assert(pat)\n\nPERL_CALLCONV void\tPerl_sv_setpvf_mg_nocontext(SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,2,3);\n#define PERL_ARGS_ASSERT_SV_SETPVF_MG_NOCONTEXT\t\\\n\tassert(sv); assert(pat)\n\nPERL_CALLCONV void\tPerl_sv_setpvf_nocontext(SV *const sv, const char *const pat, ...)\n\t\t\t__attribute__format__(__printf__,2,3);\n#define PERL_ARGS_ASSERT_SV_SETPVF_NOCONTEXT\t\\\n\tassert(sv); assert(pat)\n\nPERL_CALLCONV void\tPerl_warn_nocontext(const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,1,2);\n#define PERL_ARGS_ASSERT_WARN_NOCONTEXT\t\\\n\tassert(pat)\n\nPERL_CALLCONV void\tPerl_warner_nocontext(U32 err, const char* pat, ...)\n\t\t\t__attribute__format__(__printf__,2,3);\n#define PERL_ARGS_ASSERT_WARNER_NOCONTEXT\t\\\n\tassert(pat)\n\n#endif\n#if defined(PERL_IMPLICIT_SYS)\nPERL_CALLCONV PerlInterpreter*\tperl_alloc_using(struct IPerlMem *ipM, struct IPerlMem *ipMS, struct IPerlMem *ipMP, struct IPerlEnv *ipE, struct IPerlStdIO *ipStd, struct IPerlLIO *ipLIO, struct IPerlDir *ipD, struct IPerlSock *ipS, struct IPerlProc *ipP);\n#define PERL_ARGS_ASSERT_PERL_ALLOC_USING\t\\\n\tassert(ipM); assert(ipMS); assert(ipMP); assert(ipE); assert(ipStd); assert(ipLIO); assert(ipD); assert(ipS); assert(ipP)\n#  if defined(USE_ITHREADS)\nPERL_CALLCONV PerlInterpreter*\tperl_clone_using(PerlInterpreter *proto_perl, UV flags, struct IPerlMem* ipM, struct IPerlMem* ipMS, struct IPerlMem* ipMP, struct IPerlEnv* ipE, struct IPerlStdIO* ipStd, struct IPerlLIO* ipLIO, struct IPerlDir* ipD, struct IPerlSock* ipS, struct IPerlProc* ipP);\n#define PERL_ARGS_ASSERT_PERL_CLONE_USING\t\\\n\tassert(proto_perl); assert(ipM); assert(ipMS); assert(ipMP); assert(ipE); assert(ipStd); assert(ipLIO); assert(ipD); assert(ipS); assert(ipP)\n#  endif\n#endif\n#if defined(PERL_IN_AV_C)\nSTATIC MAGIC*\tS_get_aux_mg(pTHX_ AV *av);\n#define PERL_ARGS_ASSERT_GET_AUX_MG\t\\\n\tassert(av)\n#endif\n#if defined(PERL_IN_DEB_C)\nSTATIC void\tS_deb_stack_n(pTHX_ SV** stack_base, I32 stack_min, I32 stack_max, I32 mark_min, I32 mark_max);\n#define PERL_ARGS_ASSERT_DEB_STACK_N\t\\\n\tassert(stack_base)\n#endif\n#if defined(PERL_IN_DOIO_C)\nSTATIC bool\tS_argvout_final(pTHX_ MAGIC *mg, IO *io, bool not_implicit);\n#define PERL_ARGS_ASSERT_ARGVOUT_FINAL\t\\\n\tassert(mg); assert(io)\nSTATIC void\tS_exec_failed(pTHX_ const char *cmd, int fd, int do_report);\n#define PERL_ARGS_ASSERT_EXEC_FAILED\t\\\n\tassert(cmd)\nSTATIC bool\tS_ingroup(pTHX_ Gid_t testgid, bool effective)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC bool\tS_openn_cleanup(pTHX_ GV *gv, IO *io, PerlIO *fp, char *mode, const char *oname, PerlIO *saveifp, PerlIO *saveofp, int savefd, char savetype, int writing, bool was_fdopen, const char *type, Stat_t *statbufp);\n#define PERL_ARGS_ASSERT_OPENN_CLEANUP\t\\\n\tassert(gv); assert(io); assert(mode); assert(oname)\nSTATIC IO *\tS_openn_setup(pTHX_ GV *gv, char *mode, PerlIO **saveifp, PerlIO **saveofp, int *savefd, char *savetype);\n#define PERL_ARGS_ASSERT_OPENN_SETUP\t\\\n\tassert(gv); assert(mode); assert(saveifp); assert(saveofp); assert(savefd); assert(savetype)\n#endif\n#if defined(PERL_IN_DOOP_C)\nSTATIC Size_t\tS_do_trans_complex(pTHX_ SV * const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_TRANS_COMPLEX\t\\\n\tassert(sv)\n\nSTATIC Size_t\tS_do_trans_complex_utf8(pTHX_ SV * const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_TRANS_COMPLEX_UTF8\t\\\n\tassert(sv)\n\nSTATIC Size_t\tS_do_trans_count(pTHX_ SV * const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_TRANS_COUNT\t\\\n\tassert(sv)\n\nSTATIC Size_t\tS_do_trans_count_utf8(pTHX_ SV * const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_TRANS_COUNT_UTF8\t\\\n\tassert(sv)\n\nSTATIC Size_t\tS_do_trans_simple(pTHX_ SV * const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_TRANS_SIMPLE\t\\\n\tassert(sv)\n\nSTATIC Size_t\tS_do_trans_simple_utf8(pTHX_ SV * const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DO_TRANS_SIMPLE_UTF8\t\\\n\tassert(sv)\n\n#endif\n#if defined(PERL_IN_DUMP_C)\nSTATIC CV*\tS_deb_curcv(pTHX_ I32 ix);\nSTATIC void\tS_debprof(pTHX_ const OP *o);\n#define PERL_ARGS_ASSERT_DEBPROF\t\\\n\tassert(o)\nSTATIC SV*\tS_pm_description(pTHX_ const PMOP *pm);\n#define PERL_ARGS_ASSERT_PM_DESCRIPTION\t\\\n\tassert(pm)\nSTATIC UV\tS_sequence_num(pTHX_ const OP *o);\n#endif\n#if defined(PERL_IN_DUMP_C) || defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_SCOPE_C)\nPERL_CALLCONV void\tPerl_hv_kill_backrefs(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_HV_KILL_BACKREFS\t\\\n\tassert(hv)\n#endif\n#if defined(PERL_IN_GV_C)\nSTATIC bool\tS_find_default_stash(pTHX_ HV **stash, const char *name, STRLEN len, const U32 is_utf8, const I32 add, const svtype sv_type);\n#define PERL_ARGS_ASSERT_FIND_DEFAULT_STASH\t\\\n\tassert(stash); assert(name)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE GV*\tS_gv_fetchmeth_internal(pTHX_ HV* stash, SV* meth, const char* name, STRLEN len, I32 level, U32 flags);\n#endif\nSTATIC void\tS_gv_init_svtype(pTHX_ GV *gv, const svtype sv_type);\n#define PERL_ARGS_ASSERT_GV_INIT_SVTYPE\t\\\n\tassert(gv)\nSTATIC bool\tS_gv_is_in_main(pTHX_ const char *name, STRLEN len, const U32 is_utf8);\n#define PERL_ARGS_ASSERT_GV_IS_IN_MAIN\t\\\n\tassert(name)\nSTATIC bool\tS_gv_magicalize(pTHX_ GV *gv, HV *stash, const char *name, STRLEN len, const svtype sv_type);\n#define PERL_ARGS_ASSERT_GV_MAGICALIZE\t\\\n\tassert(gv); assert(stash); assert(name)\nSTATIC void\tS_gv_magicalize_isa(pTHX_ GV *gv);\n#define PERL_ARGS_ASSERT_GV_MAGICALIZE_ISA\t\\\n\tassert(gv)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE HV*\tS_gv_stashpvn_internal(pTHX_ const char* name, U32 namelen, I32 flags);\n#define PERL_ARGS_ASSERT_GV_STASHPVN_INTERNAL\t\\\n\tassert(name)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE HV*\tS_gv_stashsvpvn_cached(pTHX_ SV *namesv, const char* name, U32 namelen, I32 flags);\n#endif\nSTATIC void\tS_maybe_multimagic_gv(pTHX_ GV *gv, const char *name, const svtype sv_type);\n#define PERL_ARGS_ASSERT_MAYBE_MULTIMAGIC_GV\t\\\n\tassert(gv); assert(name)\nSTATIC bool\tS_parse_gv_stash_name(pTHX_ HV **stash, GV **gv, const char **name, STRLEN *len, const char *nambeg, STRLEN full_len, const U32 is_utf8, const I32 add);\n#define PERL_ARGS_ASSERT_PARSE_GV_STASH_NAME\t\\\n\tassert(stash); assert(gv); assert(name); assert(len); assert(nambeg)\nSTATIC void\tS_require_tie_mod(pTHX_ GV *gv, const char varname, const char * name, STRLEN len, const U32 flags);\n#define PERL_ARGS_ASSERT_REQUIRE_TIE_MOD\t\\\n\tassert(gv); assert(varname); assert(name)\n#endif\n#if defined(PERL_IN_GV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_PAD_C) || defined(PERL_IN_OP_C)\nPERL_CALLCONV void\tPerl_sv_add_backref(pTHX_ SV *const tsv, SV *const sv);\n#define PERL_ARGS_ASSERT_SV_ADD_BACKREF\t\\\n\tassert(tsv); assert(sv)\n#endif\n#if defined(PERL_IN_HV_C)\nSTATIC void\tS_clear_placeholders(pTHX_ HV *hv, U32 items);\n#define PERL_ARGS_ASSERT_CLEAR_PLACEHOLDERS\t\\\n\tassert(hv)\nSTATIC void\tS_hsplit(pTHX_ HV *hv, STRLEN const oldsize, STRLEN newsize);\n#define PERL_ARGS_ASSERT_HSPLIT\t\\\n\tassert(hv)\nSTATIC struct xpvhv_aux*\tS_hv_auxinit(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_HV_AUXINIT\t\\\n\tassert(hv)\nSTATIC struct xpvhv_aux*\tS_hv_auxinit_internal(struct xpvhv_aux *iter);\n#define PERL_ARGS_ASSERT_HV_AUXINIT_INTERNAL\t\\\n\tassert(iter)\nSTATIC SV*\tS_hv_delete_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen, int k_flags, I32 d_flags, U32 hash);\nSTATIC SV*\tS_hv_free_ent_ret(pTHX_ HV *hv, HE *entry);\n#define PERL_ARGS_ASSERT_HV_FREE_ENT_RET\t\\\n\tassert(hv); assert(entry)\nSTATIC void\tS_hv_free_entries(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_HV_FREE_ENTRIES\t\\\n\tassert(hv)\nSTATIC void\tS_hv_magic_check(HV *hv, bool *needs_copy, bool *needs_store);\n#define PERL_ARGS_ASSERT_HV_MAGIC_CHECK\t\\\n\tassert(hv); assert(needs_copy); assert(needs_store)\nPERL_STATIC_NO_RET void\tS_hv_notallowed(pTHX_ int flags, const char *key, I32 klen, const char *msg)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_HV_NOTALLOWED\t\\\n\tassert(key); assert(msg)\n\nSTATIC HE*\tS_new_he(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE U32\tS_ptr_hash(PTRV u);\n#endif\nSTATIC SV *\tS_refcounted_he_value(pTHX_ const struct refcounted_he *he);\n#define PERL_ARGS_ASSERT_REFCOUNTED_HE_VALUE\t\\\n\tassert(he)\nSTATIC HEK*\tS_save_hek_flags(const char *str, I32 len, U32 hash, int flags)\n\t\t\t__attribute__malloc__\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SAVE_HEK_FLAGS\t\\\n\tassert(str)\n\nSTATIC HEK*\tS_share_hek_flags(pTHX_ const char *str, STRLEN len, U32 hash, int flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SHARE_HEK_FLAGS\t\\\n\tassert(str)\n\nSTATIC void\tS_unshare_hek_or_pvn(pTHX_ const HEK* hek, const char* str, I32 len, U32 hash);\n#endif\n#if defined(PERL_IN_HV_C) || defined(PERL_IN_MG_C) || defined(PERL_IN_SV_C)\nPERL_CALLCONV void\tPerl_sv_kill_backrefs(pTHX_ SV *const sv, AV *const av);\n#define PERL_ARGS_ASSERT_SV_KILL_BACKREFS\t\\\n\tassert(sv)\n#endif\n#if defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C)\nPERL_CALLCONV SV*\tPerl_hfree_next_entry(pTHX_ HV *hv, STRLEN *indexp);\n#define PERL_ARGS_ASSERT_HFREE_NEXT_ENTRY\t\\\n\tassert(hv); assert(indexp)\n#endif\n#if defined(PERL_IN_LOCALE_C)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE const char *\tS_save_to_buffer(const char * string, char **buf, Size_t *buf_size, const Size_t offset)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SAVE_TO_BUFFER\t\\\n\tassert(buf_size)\n#endif\n\n#  if defined(USE_LOCALE)\nSTATIC const char*\tS_category_name(const int category);\nSTATIC void\tS_new_collate(pTHX_ const char* newcoll);\nSTATIC void\tS_new_ctype(pTHX_ const char* newctype);\n#define PERL_ARGS_ASSERT_NEW_CTYPE\t\\\n\tassert(newctype)\nSTATIC void\tS_new_numeric(pTHX_ const char* newnum);\nSTATIC void\tS_restore_switched_locale(pTHX_ const int category, const char * const original_locale);\nSTATIC void\tS_set_numeric_radix(pTHX_ const bool use_locale);\nSTATIC char*\tS_stdize_locale(pTHX_ char* locs);\n#define PERL_ARGS_ASSERT_STDIZE_LOCALE\t\\\n\tassert(locs)\nSTATIC const char*\tS_switch_category_locale_to_template(pTHX_ const int switch_category, const int template_category, const char * template_locale);\n#    if defined(USE_POSIX_2008_LOCALE)\nSTATIC const char*\tS_emulate_setlocale(const int category, const char* locale, unsigned int index, const bool is_index_valid);\n#    endif\n#    if defined(WIN32)\nSTATIC char*\tS_win32_setlocale(pTHX_ int category, const char* locale);\n#    endif\n#  endif\n#endif\n#if defined(PERL_IN_LOCALE_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_MATHOMS_C)\n#  if defined(USE_LOCALE_COLLATE)\nPERL_CALLCONV char*\tPerl__mem_collxfrm(pTHX_ const char* input_string, STRLEN len, STRLEN* xlen, bool utf8);\n#define PERL_ARGS_ASSERT__MEM_COLLXFRM\t\\\n\tassert(input_string); assert(xlen)\n#  endif\n#endif\n#if defined(PERL_IN_MALLOC_C)\nSTATIC int\tS_adjust_size_and_find_bucket(size_t *nbytes_p);\n#define PERL_ARGS_ASSERT_ADJUST_SIZE_AND_FIND_BUCKET\t\\\n\tassert(nbytes_p)\n#endif\n#if defined(PERL_IN_MG_C)\nSTATIC void\tS_fixup_errno_string(pTHX_ SV* sv);\n#define PERL_ARGS_ASSERT_FIXUP_ERRNO_STRING\t\\\n\tassert(sv)\nSTATIC SV*\tS_magic_methcall1(pTHX_ SV *sv, const MAGIC *mg, SV *meth, U32 flags, int n, SV *val);\n#define PERL_ARGS_ASSERT_MAGIC_METHCALL1\t\\\n\tassert(sv); assert(mg); assert(meth)\nSTATIC int\tS_magic_methpack(pTHX_ SV *sv, const MAGIC *mg, SV *meth);\n#define PERL_ARGS_ASSERT_MAGIC_METHPACK\t\\\n\tassert(sv); assert(mg); assert(meth)\nSTATIC void\tS_restore_magic(pTHX_ const void *p);\nSTATIC void\tS_save_magic_flags(pTHX_ I32 mgs_ix, SV *sv, U32 flags);\n#define PERL_ARGS_ASSERT_SAVE_MAGIC_FLAGS\t\\\n\tassert(sv)\nSTATIC void\tS_unwind_handler_stack(pTHX_ const void *p);\n#endif\n#if defined(PERL_IN_MG_C) || defined(PERL_IN_PP_C)\nPERL_CALLCONV bool\tPerl_translate_substr_offsets(STRLEN curlen, IV pos1_iv, bool pos1_is_uv, IV len_iv, bool len_is_uv, STRLEN *posp, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_TRANSLATE_SUBSTR_OFFSETS\t\\\n\tassert(posp); assert(lenp)\n#endif\n#if defined(PERL_IN_MRO_C)\nSTATIC void\tS_mro_clean_isarev(pTHX_ HV * const isa, const char * const name, const STRLEN len, HV * const exceptions, U32 hash, U32 flags);\n#define PERL_ARGS_ASSERT_MRO_CLEAN_ISAREV\t\\\n\tassert(isa); assert(name)\nSTATIC void\tS_mro_gather_and_rename(pTHX_ HV * const stashes, HV * const seen_stashes, HV *stash, HV *oldstash, SV *namesv);\n#define PERL_ARGS_ASSERT_MRO_GATHER_AND_RENAME\t\\\n\tassert(stashes); assert(seen_stashes); assert(namesv)\nSTATIC AV*\tS_mro_get_linear_isa_dfs(pTHX_ HV* stash, U32 level);\n#define PERL_ARGS_ASSERT_MRO_GET_LINEAR_ISA_DFS\t\\\n\tassert(stash)\n#endif\n#if defined(PERL_IN_OP_C)\nSTATIC void\tS_apply_attrs(pTHX_ HV *stash, SV *target, OP *attrs);\n#define PERL_ARGS_ASSERT_APPLY_ATTRS\t\\\n\tassert(stash); assert(target)\nSTATIC void\tS_apply_attrs_my(pTHX_ HV *stash, OP *target, OP *attrs, OP **imopsp);\n#define PERL_ARGS_ASSERT_APPLY_ATTRS_MY\t\\\n\tassert(stash); assert(target); assert(imopsp)\nSTATIC I32\tS_assignment_type(pTHX_ const OP *o)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC void\tS_bad_type_gv(pTHX_ I32 n, GV *gv, const OP *kid, const char *t);\n#define PERL_ARGS_ASSERT_BAD_TYPE_GV\t\\\n\tassert(gv); assert(kid); assert(t)\nSTATIC void\tS_bad_type_pv(pTHX_ I32 n, const char *t, const OP *o, const OP *kid);\n#define PERL_ARGS_ASSERT_BAD_TYPE_PV\t\\\n\tassert(t); assert(o); assert(kid)\nSTATIC void\tS_clear_special_blocks(pTHX_ const char *const fullname, GV *const gv, CV *const cv);\n#define PERL_ARGS_ASSERT_CLEAR_SPECIAL_BLOCKS\t\\\n\tassert(fullname); assert(gv); assert(cv)\nSTATIC void\tS_cop_free(pTHX_ COP *cop);\n#define PERL_ARGS_ASSERT_COP_FREE\t\\\n\tassert(cop)\nSTATIC OP *\tS_dup_attrlist(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_DUP_ATTRLIST\t\\\n\tassert(o)\nSTATIC void\tS_finalize_op(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_FINALIZE_OP\t\\\n\tassert(o)\nSTATIC void\tS_find_and_forget_pmops(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_FIND_AND_FORGET_PMOPS\t\\\n\tassert(o)\nSTATIC OP*\tS_fold_constants(pTHX_ OP * const o);\n#define PERL_ARGS_ASSERT_FOLD_CONSTANTS\t\\\n\tassert(o)\nSTATIC OP*\tS_force_list(pTHX_ OP* arg, bool nullit);\nSTATIC void\tS_forget_pmop(pTHX_ PMOP *const o);\n#define PERL_ARGS_ASSERT_FORGET_PMOP\t\\\n\tassert(o)\nSTATIC OP*\tS_gen_constant_list(pTHX_ OP* o);\nSTATIC void\tS_inplace_aassign(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_INPLACE_AASSIGN\t\\\n\tassert(o)\nSTATIC bool\tS_is_handle_constructor(const OP *o, I32 numargs)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_HANDLE_CONSTRUCTOR\t\\\n\tassert(o)\n\nSTATIC OP*\tS_listkids(pTHX_ OP* o);\nSTATIC bool\tS_looks_like_bool(pTHX_ const OP* o);\n#define PERL_ARGS_ASSERT_LOOKS_LIKE_BOOL\t\\\n\tassert(o)\nSTATIC OP*\tS_modkids(pTHX_ OP *o, I32 type);\nSTATIC void\tS_move_proto_attr(pTHX_ OP **proto, OP **attrs, const GV *name, bool curstash);\n#define PERL_ARGS_ASSERT_MOVE_PROTO_ATTR\t\\\n\tassert(proto); assert(attrs); assert(name)\nSTATIC OP *\tS_my_kid(pTHX_ OP *o, OP *attrs, OP **imopsp);\n#define PERL_ARGS_ASSERT_MY_KID\t\\\n\tassert(imopsp)\nSTATIC OP*\tS_newGIVWHENOP(pTHX_ OP* cond, OP *block, I32 enter_opcode, I32 leave_opcode, PADOFFSET entertarg);\n#define PERL_ARGS_ASSERT_NEWGIVWHENOP\t\\\n\tassert(block)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE OP*\tS_newMETHOP_internal(pTHX_ I32 type, I32 flags, OP* dynamic_meth, SV* const_meth);\n#endif\nSTATIC OP*\tS_new_logop(pTHX_ I32 type, I32 flags, OP **firstp, OP **otherp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEW_LOGOP\t\\\n\tassert(firstp); assert(otherp)\n\nSTATIC void\tS_no_bareword_allowed(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_NO_BAREWORD_ALLOWED\t\\\n\tassert(o)\nSTATIC OP*\tS_no_fh_allowed(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NO_FH_ALLOWED\t\\\n\tassert(o)\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE OP*\tS_op_integerize(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_OP_INTEGERIZE\t\\\n\tassert(o)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE OP*\tS_op_std_init(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_OP_STD_INIT\t\\\n\tassert(o)\n#endif\nSTATIC void\tS_optimize_op(pTHX_ OP* o);\n#define PERL_ARGS_ASSERT_OPTIMIZE_OP\t\\\n\tassert(o)\nSTATIC OP*\tS_pmtrans(pTHX_ OP* o, OP* expr, OP* repl);\n#define PERL_ARGS_ASSERT_PMTRANS\t\\\n\tassert(o); assert(expr); assert(repl)\nSTATIC bool\tS_process_special_blocks(pTHX_ I32 floor, const char *const fullname, GV *const gv, CV *const cv);\n#define PERL_ARGS_ASSERT_PROCESS_SPECIAL_BLOCKS\t\\\n\tassert(fullname); assert(gv); assert(cv)\nSTATIC OP*\tS_ref_array_or_hash(pTHX_ OP* cond);\nSTATIC OP*\tS_refkids(pTHX_ OP* o, I32 type);\nSTATIC bool\tS_scalar_mod_type(const OP *o, I32 type)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC OP*\tS_scalarboolean(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_SCALARBOOLEAN\t\\\n\tassert(o)\nSTATIC OP*\tS_scalarkids(pTHX_ OP* o);\nSTATIC OP*\tS_scalarseq(pTHX_ OP* o);\nSTATIC OP*\tS_search_const(pTHX_ OP *o)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SEARCH_CONST\t\\\n\tassert(o)\n\nSTATIC void\tS_simplify_sort(pTHX_ OP *o);\n#define PERL_ARGS_ASSERT_SIMPLIFY_SORT\t\\\n\tassert(o)\nSTATIC OP*\tS_too_few_arguments_pv(pTHX_ OP *o, const char* name, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_TOO_FEW_ARGUMENTS_PV\t\\\n\tassert(o); assert(name)\n\nSTATIC OP*\tS_too_many_arguments_pv(pTHX_ OP *o, const char* name, U32 flags);\n#define PERL_ARGS_ASSERT_TOO_MANY_ARGUMENTS_PV\t\\\n\tassert(o); assert(name)\nSTATIC OP*\tS_traverse_op_tree(pTHX_ OP* top, OP* o);\n#define PERL_ARGS_ASSERT_TRAVERSE_OP_TREE\t\\\n\tassert(top); assert(o)\n#  if defined(USE_ITHREADS)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_op_relocate_sv(pTHX_ SV** svp, PADOFFSET* targp);\n#define PERL_ARGS_ASSERT_OP_RELOCATE_SV\t\\\n\tassert(svp); assert(targp)\n#endif\n#  endif\n#endif\n#if defined(PERL_IN_OP_C) || defined(PERL_IN_SV_C)\nPERL_CALLCONV void\tPerl_report_redefined_cv(pTHX_ const SV *name, const CV *old_cv, SV * const *new_const_svp);\n#define PERL_ARGS_ASSERT_REPORT_REDEFINED_CV\t\\\n\tassert(name); assert(old_cv)\n#endif\n#if defined(PERL_IN_PAD_C)\nSTATIC PADOFFSET\tS_pad_alloc_name(pTHX_ PADNAME *name, U32 flags, HV *typestash, HV *ourstash);\n#define PERL_ARGS_ASSERT_PAD_ALLOC_NAME\t\\\n\tassert(name)\nSTATIC void\tS_pad_check_dup(pTHX_ PADNAME *name, U32 flags, const HV *ourstash);\n#define PERL_ARGS_ASSERT_PAD_CHECK_DUP\t\\\n\tassert(name)\nSTATIC PADOFFSET\tS_pad_findlex(pTHX_ const char *namepv, STRLEN namelen, U32 flags, const CV* cv, U32 seq, int warn, SV** out_capture, PADNAME** out_name, int *out_flags);\n#define PERL_ARGS_ASSERT_PAD_FINDLEX\t\\\n\tassert(namepv); assert(cv); assert(out_name); assert(out_flags)\nSTATIC void\tS_pad_reset(pTHX);\n#endif\n#if defined(PERL_IN_PERL_C)\nSTATIC void\tS_find_beginning(pTHX_ SV* linestr_sv, PerlIO *rsfp);\n#define PERL_ARGS_ASSERT_FIND_BEGINNING\t\\\n\tassert(linestr_sv); assert(rsfp)\nSTATIC void\tS_forbid_setid(pTHX_ const char flag, const bool suidscript);\nSTATIC void\tS_incpush(pTHX_ const char *const dir, STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_INCPUSH\t\\\n\tassert(dir)\nSTATIC void\tS_incpush_use_sep(pTHX_ const char *p, STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_INCPUSH_USE_SEP\t\\\n\tassert(p)\nSTATIC void\tS_init_ids(pTHX);\nSTATIC void\tS_init_interp(pTHX);\nSTATIC void\tS_init_main_stash(pTHX);\nSTATIC void\tS_init_perllib(pTHX);\nSTATIC void\tS_init_postdump_symbols(pTHX_ int argc, char **argv, char **env);\n#define PERL_ARGS_ASSERT_INIT_POSTDUMP_SYMBOLS\t\\\n\tassert(argv)\nSTATIC void\tS_init_predump_symbols(pTHX);\nSTATIC SV*\tS_mayberelocate(pTHX_ const char *const dir, STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_MAYBERELOCATE\t\\\n\tassert(dir)\nPERL_STATIC_NO_RET void\tS_minus_v(pTHX)\n\t\t\t__attribute__noreturn__;\n\nPERL_STATIC_NO_RET void\tS_my_exit_jump(pTHX)\n\t\t\t__attribute__noreturn__;\n\nSTATIC void\tS_nuke_stacks(pTHX);\nSTATIC PerlIO *\tS_open_script(pTHX_ const char *scriptname, bool dosearch, bool *suidscript);\n#define PERL_ARGS_ASSERT_OPEN_SCRIPT\t\\\n\tassert(scriptname); assert(suidscript)\nSTATIC void*\tS_parse_body(pTHX_ char **env, XSINIT_t xsinit);\nPERL_STATIC_NO_RET void\tS_run_body(pTHX_ I32 oldscope)\n\t\t\t__attribute__noreturn__;\n\nPERL_STATIC_NO_RET void\tS_usage(pTHX)\n\t\t\t__attribute__noreturn__;\n\n#endif\n#if defined(PERL_IN_PP_C)\nSTATIC size_t\tS_do_chomp(pTHX_ SV *retval, SV *sv, bool chomping);\n#define PERL_ARGS_ASSERT_DO_CHOMP\t\\\n\tassert(retval); assert(sv)\nSTATIC OP*\tS_do_delete_local(pTHX);\nSTATIC SV*\tS_refto(pTHX_ SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REFTO\t\\\n\tassert(sv)\n\n#endif\n#if defined(PERL_IN_PP_C) || defined(PERL_IN_PP_HOT_C)\nPERL_CALLCONV GV*\tPerl_softref2xv(pTHX_ SV *const sv, const char *const what, const svtype type, SV ***spp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SOFTREF2XV\t\\\n\tassert(sv); assert(what); assert(spp)\n\n#endif\n#if defined(PERL_IN_PP_CTL_C)\nSTATIC PerlIO *\tS_check_type_and_open(pTHX_ SV *name)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CHECK_TYPE_AND_OPEN\t\\\n\tassert(name)\n\nSTATIC void\tS_destroy_matcher(pTHX_ PMOP* matcher);\n#define PERL_ARGS_ASSERT_DESTROY_MATCHER\t\\\n\tassert(matcher)\nSTATIC OP*\tS_do_smartmatch(pTHX_ HV* seen_this, HV* seen_other, const bool copied);\nSTATIC OP*\tS_docatch(pTHX_ Perl_ppaddr_t firstpp)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC bool\tS_doeval_compile(pTHX_ U8 gimme, CV* outside, U32 seq, HV* hh);\nSTATIC OP*\tS_dofindlabel(pTHX_ OP *o, const char *label, STRLEN len, U32 flags, OP **opstack, OP **oplimit)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DOFINDLABEL\t\\\n\tassert(o); assert(label); assert(opstack); assert(oplimit)\n\nSTATIC MAGIC *\tS_doparseform(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_DOPARSEFORM\t\\\n\tassert(sv)\nSTATIC I32\tS_dopoptoeval(pTHX_ I32 startingblock)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC I32\tS_dopoptogivenfor(pTHX_ I32 startingblock)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC I32\tS_dopoptolabel(pTHX_ const char *label, STRLEN len, U32 flags)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DOPOPTOLABEL\t\\\n\tassert(label)\n\nSTATIC I32\tS_dopoptoloop(pTHX_ I32 startingblock)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC I32\tS_dopoptosub_at(pTHX_ const PERL_CONTEXT* cxstk, I32 startingblock)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DOPOPTOSUB_AT\t\\\n\tassert(cxstk)\n\nSTATIC I32\tS_dopoptowhen(pTHX_ I32 startingblock)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC PMOP*\tS_make_matcher(pTHX_ REGEXP* re)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MAKE_MATCHER\t\\\n\tassert(re)\n\nSTATIC bool\tS_matcher_matches_sv(pTHX_ PMOP* matcher, SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MATCHER_MATCHES_SV\t\\\n\tassert(matcher); assert(sv)\n\nSTATIC bool\tS_num_overflow(NV value, I32 fldsize, I32 frcsize)\n\t\t\t__attribute__warn_unused_result__;\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_path_is_searchable(const char *name)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PATH_IS_SEARCHABLE\t\\\n\tassert(name)\n#endif\n\nSTATIC I32\tS_run_user_filter(pTHX_ int idx, SV *buf_sv, int maxlen)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_RUN_USER_FILTER\t\\\n\tassert(buf_sv)\n\nSTATIC void\tS_rxres_free(pTHX_ void** rsp);\n#define PERL_ARGS_ASSERT_RXRES_FREE\t\\\n\tassert(rsp)\nSTATIC void\tS_rxres_restore(pTHX_ void **rsp, REGEXP *rx);\n#define PERL_ARGS_ASSERT_RXRES_RESTORE\t\\\n\tassert(rsp); assert(rx)\nSTATIC void\tS_save_lines(pTHX_ AV *array, SV *sv);\n#define PERL_ARGS_ASSERT_SAVE_LINES\t\\\n\tassert(sv)\n#endif\n#if defined(PERL_IN_PP_HOT_C)\nSTATIC void\tS_do_oddball(pTHX_ SV **oddkey, SV **firstkey);\n#define PERL_ARGS_ASSERT_DO_ODDBALL\t\\\n\tassert(oddkey); assert(firstkey)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE HV*\tS_opmethod_stash(pTHX_ SV* meth);\n#define PERL_ARGS_ASSERT_OPMETHOD_STASH\t\\\n\tassert(meth)\n#endif\n#endif\n#if defined(PERL_IN_PP_PACK_C)\nSTATIC int\tS_div128(pTHX_ SV *pnum, bool *done);\n#define PERL_ARGS_ASSERT_DIV128\t\\\n\tassert(pnum); assert(done)\nSTATIC char\tS_first_symbol(const char *pat, const char *patend);\n#define PERL_ARGS_ASSERT_FIRST_SYMBOL\t\\\n\tassert(pat); assert(patend)\nSTATIC const char *\tS_get_num(pTHX_ const char *patptr, SSize_t *lenptr)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_NUM\t\\\n\tassert(patptr); assert(lenptr)\n\nSTATIC const char *\tS_group_end(pTHX_ const char *patptr, const char *patend, char ender);\n#define PERL_ARGS_ASSERT_GROUP_END\t\\\n\tassert(patptr); assert(patend)\nSTATIC SV*\tS_is_an_int(pTHX_ const char *s, STRLEN l)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_AN_INT\t\\\n\tassert(s)\n\nSTATIC SSize_t\tS_measure_struct(pTHX_ struct tempsym* symptr);\n#define PERL_ARGS_ASSERT_MEASURE_STRUCT\t\\\n\tassert(symptr)\nSTATIC SV*\tS_mul128(pTHX_ SV *sv, U8 m);\n#define PERL_ARGS_ASSERT_MUL128\t\\\n\tassert(sv)\nSTATIC char *\tS_my_bytes_to_utf8(const U8 *start, STRLEN len, char *dest, const bool needs_swap)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MY_BYTES_TO_UTF8\t\\\n\tassert(start); assert(dest)\n\nSTATIC bool\tS_need_utf8(const char *pat, const char *patend);\n#define PERL_ARGS_ASSERT_NEED_UTF8\t\\\n\tassert(pat); assert(patend)\nSTATIC bool\tS_next_symbol(pTHX_ struct tempsym* symptr);\n#define PERL_ARGS_ASSERT_NEXT_SYMBOL\t\\\n\tassert(symptr)\nSTATIC SV **\tS_pack_rec(pTHX_ SV *cat, struct tempsym* symptr, SV **beglist, SV **endlist);\n#define PERL_ARGS_ASSERT_PACK_REC\t\\\n\tassert(cat); assert(symptr); assert(beglist); assert(endlist)\nSTATIC char *\tS_sv_exp_grow(pTHX_ SV *sv, STRLEN needed)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_EXP_GROW\t\\\n\tassert(sv)\n\nSTATIC SSize_t\tS_unpack_rec(pTHX_ struct tempsym* symptr, const char *s, const char *strbeg, const char *strend, const char **new_s);\n#define PERL_ARGS_ASSERT_UNPACK_REC\t\\\n\tassert(symptr); assert(s); assert(strbeg); assert(strend)\n#endif\n#if defined(PERL_IN_PP_SORT_C)\nSTATIC I32\tS_amagic_cmp(pTHX_ SV *const str1, SV *const str2);\n#define PERL_ARGS_ASSERT_AMAGIC_CMP\t\\\n\tassert(str1); assert(str2)\nSTATIC I32\tS_amagic_i_ncmp(pTHX_ SV *const a, SV *const b);\n#define PERL_ARGS_ASSERT_AMAGIC_I_NCMP\t\\\n\tassert(a); assert(b)\nSTATIC I32\tS_amagic_ncmp(pTHX_ SV *const a, SV *const b);\n#define PERL_ARGS_ASSERT_AMAGIC_NCMP\t\\\n\tassert(a); assert(b)\nSTATIC I32\tS_sortcv(pTHX_ SV *const a, SV *const b);\n#define PERL_ARGS_ASSERT_SORTCV\t\\\n\tassert(a); assert(b)\nSTATIC I32\tS_sortcv_stacked(pTHX_ SV *const a, SV *const b);\n#define PERL_ARGS_ASSERT_SORTCV_STACKED\t\\\n\tassert(a); assert(b)\nSTATIC I32\tS_sortcv_xsub(pTHX_ SV *const a, SV *const b);\n#define PERL_ARGS_ASSERT_SORTCV_XSUB\t\\\n\tassert(a); assert(b)\nSTATIC I32\tS_sv_i_ncmp(pTHX_ SV *const a, SV *const b);\n#define PERL_ARGS_ASSERT_SV_I_NCMP\t\\\n\tassert(a); assert(b)\nSTATIC I32\tS_sv_ncmp(pTHX_ SV *const a, SV *const b);\n#define PERL_ARGS_ASSERT_SV_NCMP\t\\\n\tassert(a); assert(b)\n#  if defined(USE_LOCALE_COLLATE)\nSTATIC I32\tS_amagic_cmp_locale(pTHX_ SV *const str1, SV *const str2);\n#define PERL_ARGS_ASSERT_AMAGIC_CMP_LOCALE\t\\\n\tassert(str1); assert(str2)\n#  endif\n#endif\n#if defined(PERL_IN_PP_SYS_C)\nSTATIC OP*\tS_doform(pTHX_ CV *cv, GV *gv, OP *retop);\n#define PERL_ARGS_ASSERT_DOFORM\t\\\n\tassert(cv); assert(gv)\nSTATIC SV *\tS_space_join_names_mortal(pTHX_ char *const *array);\n#endif\n#if defined(PERL_IN_REGCOMP_C)\nSTATIC SV*\tS__make_exactf_invlist(pTHX_ RExC_state_t *pRExC_state, regnode *node)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__MAKE_EXACTF_INVLIST\t\\\n\tassert(pRExC_state); assert(node)\n\nSTATIC void\tS_add_above_Latin1_folds(pTHX_ RExC_state_t *pRExC_state, const U8 cp, SV** invlist);\n#define PERL_ARGS_ASSERT_ADD_ABOVE_LATIN1_FOLDS\t\\\n\tassert(pRExC_state); assert(invlist)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE SV*\tS_add_cp_to_invlist(pTHX_ SV* invlist, const UV cp)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\nSTATIC U32\tS_add_data(RExC_state_t* const pRExC_state, const char* const s, const U32 n)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ADD_DATA\t\\\n\tassert(pRExC_state); assert(s)\n\nSTATIC AV*\tS_add_multi_match(pTHX_ AV* multi_char_matches, SV* multi_string, const STRLEN cp_count);\n#define PERL_ARGS_ASSERT_ADD_MULTI_MATCH\t\\\n\tassert(multi_string)\nSTATIC void\tS_change_engine_size(pTHX_ RExC_state_t *pRExC_state, const Ptrdiff_t size);\n#define PERL_ARGS_ASSERT_CHANGE_ENGINE_SIZE\t\\\n\tassert(pRExC_state)\nSTATIC const char *\tS_cntrl_to_mnemonic(const U8 c)\n\t\t\t__attribute__warn_unused_result__;\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE U8\tS_compute_EXACTish(RExC_state_t *pRExC_state);\n#define PERL_ARGS_ASSERT_COMPUTE_EXACTISH\t\\\n\tassert(pRExC_state)\n#endif\nSTATIC regnode *\tS_construct_ahocorasick_from_trie(pTHX_ RExC_state_t *pRExC_state, regnode *source, U32 depth);\n#define PERL_ARGS_ASSERT_CONSTRUCT_AHOCORASICK_FROM_TRIE\t\\\n\tassert(pRExC_state); assert(source)\nSTATIC int\tS_edit_distance(const UV *src, const UV *tgt, const STRLEN x, const STRLEN y, const SSize_t maxDistance)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_EDIT_DISTANCE\t\\\n\tassert(src); assert(tgt)\n\nSTATIC SV *\tS_get_ANYOFM_contents(pTHX_ const regnode * n)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_ANYOFM_CONTENTS\t\\\n\tassert(n)\n\nSTATIC SV*\tS_get_ANYOF_cp_list_for_ssc(pTHX_ const RExC_state_t *pRExC_state, const regnode_charclass* const node);\n#define PERL_ARGS_ASSERT_GET_ANYOF_CP_LIST_FOR_SSC\t\\\n\tassert(pRExC_state); assert(node)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE STRLEN*\tS_get_invlist_iter_addr(SV* invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_INVLIST_ITER_ADDR\t\\\n\tassert(invlist)\n#endif\n\nSTATIC bool\tS_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state, regnode_offset* nodep, UV *code_point_p, int* cp_count, I32 *flagp, const bool strict, const U32 depth);\n#define PERL_ARGS_ASSERT_GROK_BSLASH_N\t\\\n\tassert(pRExC_state); assert(flagp)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE regnode_offset\tS_handle_named_backref(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, char * parse_start, char ch);\n#define PERL_ARGS_ASSERT_HANDLE_NAMED_BACKREF\t\\\n\tassert(pRExC_state); assert(flagp); assert(parse_start)\n#endif\nSTATIC int\tS_handle_possible_posix(pTHX_ RExC_state_t *pRExC_state, const char* const s, char ** updated_parse_ptr, AV** posix_warnings, const bool check_only);\n#define PERL_ARGS_ASSERT_HANDLE_POSSIBLE_POSIX\t\\\n\tassert(pRExC_state); assert(s)\nSTATIC regnode_offset\tS_handle_regex_sets(pTHX_ RExC_state_t *pRExC_state, SV ** return_invlist, I32 *flagp, U32 depth, char * const oregcomp_parse);\n#define PERL_ARGS_ASSERT_HANDLE_REGEX_SETS\t\\\n\tassert(pRExC_state); assert(flagp); assert(oregcomp_parse)\nPERL_CALLCONV SV *\tPerl_handle_user_defined_property(pTHX_ const char * name, const STRLEN name_len, const bool is_utf8, const bool to_fold, const bool runtime, const bool deferrable, SV* contents, bool *user_defined_ptr, SV * msg, const STRLEN level);\n#define PERL_ARGS_ASSERT_HANDLE_USER_DEFINED_PROPERTY\t\\\n\tassert(name); assert(contents); assert(user_defined_ptr); assert(msg)\nSTATIC SV*\tS_invlist_contents(pTHX_ SV* const invlist, const bool traditional_style)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_INVLIST_CONTENTS\t\\\n\tassert(invlist)\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE UV\tS_invlist_highest(SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_INVLIST_HIGHEST\t\\\n\tassert(invlist)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_invlist_is_iterating(SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_INVLIST_IS_ITERATING\t\\\n\tassert(invlist)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_invlist_iterfinish(SV* invlist);\n#define PERL_ARGS_ASSERT_INVLIST_ITERFINISH\t\\\n\tassert(invlist)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_invlist_iterinit(SV* invlist);\n#define PERL_ARGS_ASSERT_INVLIST_ITERINIT\t\\\n\tassert(invlist)\n#endif\nSTATIC bool\tS_invlist_iternext(SV* invlist, UV* start, UV* end)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_INVLIST_ITERNEXT\t\\\n\tassert(invlist); assert(start); assert(end)\n\nSTATIC bool\tS_is_ssc_worth_it(const RExC_state_t * pRExC_state, const regnode_ssc * ssc);\n#define PERL_ARGS_ASSERT_IS_SSC_WORTH_IT\t\\\n\tassert(pRExC_state); assert(ssc)\nSTATIC U32\tS_join_exact(pTHX_ RExC_state_t *pRExC_state, regnode *scan, UV *min_subtract, bool *unfolded_multi_char, U32 flags, regnode *val, U32 depth);\n#define PERL_ARGS_ASSERT_JOIN_EXACT\t\\\n\tassert(pRExC_state); assert(scan); assert(min_subtract); assert(unfolded_multi_char)\nSTATIC I32\tS_make_trie(pTHX_ RExC_state_t *pRExC_state, regnode *startbranch, regnode *first, regnode *last, regnode *tail, U32 word_count, U32 flags, U32 depth);\n#define PERL_ARGS_ASSERT_MAKE_TRIE\t\\\n\tassert(pRExC_state); assert(startbranch); assert(first); assert(last); assert(tail)\nSTATIC bool\tS_new_regcurly(const char *s, const char *e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEW_REGCURLY\t\\\n\tassert(s); assert(e)\n\nSTATIC void\tS_nextchar(pTHX_ RExC_state_t *pRExC_state);\n#define PERL_ARGS_ASSERT_NEXTCHAR\t\\\n\tassert(pRExC_state)\nSTATIC void\tS_output_posix_warnings(pTHX_ RExC_state_t *pRExC_state, AV* posix_warnings);\n#define PERL_ARGS_ASSERT_OUTPUT_POSIX_WARNINGS\t\\\n\tassert(pRExC_state); assert(posix_warnings)\nSTATIC void\tS_parse_lparen_question_flags(pTHX_ RExC_state_t *pRExC_state);\n#define PERL_ARGS_ASSERT_PARSE_LPAREN_QUESTION_FLAGS\t\\\n\tassert(pRExC_state)\nPERL_CALLCONV SV *\tPerl_parse_uniprop_string(pTHX_ const char * const name, const Size_t name_len, const bool is_utf8, const bool to_fold, const bool runtime, const bool deferrable, bool * user_defined_ptr, SV * msg, const STRLEN level);\n#define PERL_ARGS_ASSERT_PARSE_UNIPROP_STRING\t\\\n\tassert(name); assert(user_defined_ptr); assert(msg)\nSTATIC void\tS_populate_ANYOF_from_invlist(pTHX_ regnode *node, SV** invlist_ptr);\n#define PERL_ARGS_ASSERT_POPULATE_ANYOF_FROM_INVLIST\t\\\n\tassert(node); assert(invlist_ptr)\nSTATIC void\tS_rck_elide_nothing(pTHX_ regnode *node);\n#define PERL_ARGS_ASSERT_RCK_ELIDE_NOTHING\t\\\n\tassert(node)\nPERL_STATIC_NO_RET void\tS_re_croak2(pTHX_ bool utf8, const char* pat1, const char* pat2, ...)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_RE_CROAK2\t\\\n\tassert(pat1); assert(pat2)\n\nSTATIC regnode_offset\tS_reg(pTHX_ RExC_state_t *pRExC_state, I32 paren, I32 *flagp, U32 depth);\n#define PERL_ARGS_ASSERT_REG\t\\\n\tassert(pRExC_state); assert(flagp)\nSTATIC regnode_offset\tS_reg2Lanode(pTHX_ RExC_state_t *pRExC_state, const U8 op, const U32 arg1, const I32 arg2);\n#define PERL_ARGS_ASSERT_REG2LANODE\t\\\n\tassert(pRExC_state)\nSTATIC regnode_offset\tS_reg_node(pTHX_ RExC_state_t *pRExC_state, U8 op);\n#define PERL_ARGS_ASSERT_REG_NODE\t\\\n\tassert(pRExC_state)\nSTATIC SV *\tS_reg_scan_name(pTHX_ RExC_state_t *pRExC_state, U32 flags);\n#define PERL_ARGS_ASSERT_REG_SCAN_NAME\t\\\n\tassert(pRExC_state)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE char *\tS_reg_skipcomment(RExC_state_t *pRExC_state, char * p);\n#define PERL_ARGS_ASSERT_REG_SKIPCOMMENT\t\\\n\tassert(pRExC_state); assert(p)\n#endif\nSTATIC regnode_offset\tS_reganode(pTHX_ RExC_state_t *pRExC_state, U8 op, U32 arg);\n#define PERL_ARGS_ASSERT_REGANODE\t\\\n\tassert(pRExC_state)\nSTATIC regnode_offset\tS_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth);\n#define PERL_ARGS_ASSERT_REGATOM\t\\\n\tassert(pRExC_state); assert(flagp)\nSTATIC regnode_offset\tS_regbranch(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, I32 first, U32 depth);\n#define PERL_ARGS_ASSERT_REGBRANCH\t\\\n\tassert(pRExC_state); assert(flagp)\nSTATIC regnode_offset\tS_regclass(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth, const bool stop_at_1, bool allow_multi_fold, const bool silence_non_portable, const bool strict, bool optimizable, SV** ret_invlist);\n#define PERL_ARGS_ASSERT_REGCLASS\t\\\n\tassert(pRExC_state); assert(flagp)\nSTATIC unsigned int\tS_regex_set_precedence(const U8 my_operator)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC void\tS_reginsert(pTHX_ RExC_state_t *pRExC_state, const U8 op, const regnode_offset operand, const U32 depth);\n#define PERL_ARGS_ASSERT_REGINSERT\t\\\n\tassert(pRExC_state)\nSTATIC regnode_offset\tS_regnode_guts(pTHX_ RExC_state_t *pRExC_state, const U8 op, const STRLEN extra_len, const char* const name);\n#define PERL_ARGS_ASSERT_REGNODE_GUTS\t\\\n\tassert(pRExC_state); assert(name)\nSTATIC regnode_offset\tS_regpiece(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth);\n#define PERL_ARGS_ASSERT_REGPIECE\t\\\n\tassert(pRExC_state); assert(flagp)\nSTATIC bool\tS_regtail(pTHX_ RExC_state_t * pRExC_state, const regnode_offset p, const regnode_offset val, const U32 depth)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGTAIL\t\\\n\tassert(pRExC_state); assert(p); assert(val)\n\nSTATIC void\tS_scan_commit(pTHX_ const RExC_state_t *pRExC_state, struct scan_data_t *data, SSize_t *minlenp, int is_inf);\n#define PERL_ARGS_ASSERT_SCAN_COMMIT\t\\\n\tassert(pRExC_state); assert(data); assert(minlenp)\nSTATIC void\tS_set_ANYOF_arg(pTHX_ RExC_state_t* const pRExC_state, regnode* const node, SV* const cp_list, SV* const runtime_defns, SV* const only_utf8_locale_list);\n#define PERL_ARGS_ASSERT_SET_ANYOF_ARG\t\\\n\tassert(pRExC_state); assert(node)\nSTATIC void\tS_set_regex_pv(pTHX_ RExC_state_t *pRExC_state, REGEXP *Rx);\n#define PERL_ARGS_ASSERT_SET_REGEX_PV\t\\\n\tassert(pRExC_state); assert(Rx)\nSTATIC void\tS_skip_to_be_ignored_text(pTHX_ RExC_state_t *pRExC_state, char ** p, const bool force_to_xmod);\n#define PERL_ARGS_ASSERT_SKIP_TO_BE_IGNORED_TEXT\t\\\n\tassert(pRExC_state); assert(p)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_ssc_add_range(pTHX_ regnode_ssc *ssc, UV const start, UV const end);\n#define PERL_ARGS_ASSERT_SSC_ADD_RANGE\t\\\n\tassert(ssc)\n#endif\nSTATIC void\tS_ssc_and(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc, const regnode_charclass *and_with);\n#define PERL_ARGS_ASSERT_SSC_AND\t\\\n\tassert(pRExC_state); assert(ssc); assert(and_with)\nSTATIC void\tS_ssc_anything(pTHX_ regnode_ssc *ssc);\n#define PERL_ARGS_ASSERT_SSC_ANYTHING\t\\\n\tassert(ssc)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_ssc_clear_locale(regnode_ssc *ssc);\n#define PERL_ARGS_ASSERT_SSC_CLEAR_LOCALE\t\\\n\tassert(ssc)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_ssc_cp_and(pTHX_ regnode_ssc *ssc, UV const cp);\n#define PERL_ARGS_ASSERT_SSC_CP_AND\t\\\n\tassert(ssc)\n#endif\nSTATIC void\tS_ssc_finalize(pTHX_ RExC_state_t *pRExC_state, regnode_ssc *ssc);\n#define PERL_ARGS_ASSERT_SSC_FINALIZE\t\\\n\tassert(pRExC_state); assert(ssc)\nSTATIC void\tS_ssc_init(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc);\n#define PERL_ARGS_ASSERT_SSC_INIT\t\\\n\tassert(pRExC_state); assert(ssc)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_ssc_intersection(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert_2nd);\n#define PERL_ARGS_ASSERT_SSC_INTERSECTION\t\\\n\tassert(ssc); assert(invlist)\n#endif\nSTATIC int\tS_ssc_is_anything(const regnode_ssc *ssc)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SSC_IS_ANYTHING\t\\\n\tassert(ssc)\n\nSTATIC int\tS_ssc_is_cp_posixl_init(const RExC_state_t *pRExC_state, const regnode_ssc *ssc)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SSC_IS_CP_POSIXL_INIT\t\\\n\tassert(pRExC_state); assert(ssc)\n\nSTATIC void\tS_ssc_or(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc, const regnode_charclass *or_with);\n#define PERL_ARGS_ASSERT_SSC_OR\t\\\n\tassert(pRExC_state); assert(ssc); assert(or_with)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_ssc_union(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert_2nd);\n#define PERL_ARGS_ASSERT_SSC_UNION\t\\\n\tassert(ssc); assert(invlist)\n#endif\nSTATIC SSize_t\tS_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp, SSize_t *minlenp, SSize_t *deltap, regnode *last, struct scan_data_t *data, I32 stopparen, U32 recursed_depth, regnode_ssc *and_withp, U32 flags, U32 depth, bool was_mutate_ok);\n#define PERL_ARGS_ASSERT_STUDY_CHUNK\t\\\n\tassert(pRExC_state); assert(scanp); assert(minlenp); assert(deltap); assert(last)\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined (PERL_IN_DUMP_C)\nPERL_CALLCONV void\tPerl__invlist_dump(pTHX_ PerlIO *file, I32 level, const char* const indent, SV* const invlist);\n#define PERL_ARGS_ASSERT__INVLIST_DUMP\t\\\n\tassert(file); assert(indent); assert(invlist)\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_PERL_C) || defined(PERL_IN_UTF8_C)\nPERL_CALLCONV bool\tPerl__invlistEQ(pTHX_ SV* const a, SV* const b, const bool complement_b);\n#define PERL_ARGS_ASSERT__INVLISTEQ\t\\\n\tassert(a); assert(b)\nPERL_CALLCONV SV*\tPerl__new_invlist_C_array(pTHX_ const UV* const list)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__NEW_INVLIST_C_ARRAY\t\\\n\tassert(list)\n\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)\nPERL_CALLCONV SV*\tPerl__get_regclass_nonbitmap_data(pTHX_ const regexp *prog, const struct regnode *node, bool doinit, SV **listsvp, SV **lonly_utf8_locale, SV **output_invlist);\n#define PERL_ARGS_ASSERT__GET_REGCLASS_NONBITMAP_DATA\t\\\n\tassert(node)\nPERL_CALLCONV int\tPerl_re_printf(pTHX_ const char *fmt, ...);\n#define PERL_ARGS_ASSERT_RE_PRINTF\t\\\n\tassert(fmt)\nPERL_CALLCONV void\tPerl_regprop(pTHX_ const regexp *prog, SV* sv, const regnode* o, const regmatch_info *reginfo, const RExC_state_t *pRExC_state);\n#define PERL_ARGS_ASSERT_REGPROP\t\\\n\tassert(sv); assert(o)\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_TOKE_C) || defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS__invlist_contains_cp(SV* const invlist, const UV cp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__INVLIST_CONTAINS_CP\t\\\n\tassert(invlist)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE UV\tS__invlist_len(SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__INVLIST_LEN\t\\\n\tassert(invlist)\n#endif\n\nPERL_CALLCONV SSize_t\tPerl__invlist_search(SV* const invlist, const UV cp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__INVLIST_SEARCH\t\\\n\tassert(invlist)\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool*\tS_get_invlist_offset_addr(SV* invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_INVLIST_OFFSET_ADDR\t\\\n\tassert(invlist)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE UV*\tS_invlist_array(SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_INVLIST_ARRAY\t\\\n\tassert(invlist)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_invlist(SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#endif\n\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_SV_C)\nPERL_CALLCONV SV*\tPerl_invlist_clone(pTHX_ SV* const invlist, SV* newlist);\n#define PERL_ARGS_ASSERT_INVLIST_CLONE\t\\\n\tassert(invlist)\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_TOKE_C) || defined(PERL_IN_DQUOTE_C)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE char*\tS_form_short_octal_warning(pTHX_ const char * const s, const STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FORM_SHORT_OCTAL_WARNING\t\\\n\tassert(s)\n#endif\n\nPERL_CALLCONV char\tPerl_grok_bslash_c(pTHX_ const char source, const bool output_warning)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV bool\tPerl_grok_bslash_o(pTHX_ char** s, const char* const send, UV* uv, const char** error_msg, const bool output_warning, const bool strict, const bool silence_non_portable, const bool utf8)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GROK_BSLASH_O\t\\\n\tassert(s); assert(send); assert(uv); assert(error_msg)\n\nPERL_CALLCONV bool\tPerl_grok_bslash_x(pTHX_ char** s, const char* const send, UV* uv, const char** error_msg, const bool output_warning, const bool strict, const bool silence_non_portable, const bool utf8)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GROK_BSLASH_X\t\\\n\tassert(s); assert(send); assert(uv); assert(error_msg)\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE I32\tS_regcurly(const char *s)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGCURLY\t\\\n\tassert(s)\n#endif\n\n#endif\n#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_UTF8_C)\nPERL_CALLCONV SV*\tPerl__add_range_to_invlist(pTHX_ SV* invlist, UV start, UV end)\n\t\t\t__attribute__warn_unused_result__;\n\n/* PERL_CALLCONV void\t_invlist_intersection(pTHX_ SV* const a, SV* const b, SV** i); */\nPERL_CALLCONV void\tPerl__invlist_intersection_maybe_complement_2nd(pTHX_ SV* const a, SV* const b, const bool complement_b, SV** i);\n#define PERL_ARGS_ASSERT__INVLIST_INTERSECTION_MAYBE_COMPLEMENT_2ND\t\\\n\tassert(b); assert(i)\nPERL_CALLCONV void\tPerl__invlist_invert(pTHX_ SV* const invlist);\n#define PERL_ARGS_ASSERT__INVLIST_INVERT\t\\\n\tassert(invlist)\n/* PERL_CALLCONV void\t_invlist_subtract(pTHX_ SV* const a, SV* const b, SV** result); */\n/* PERL_CALLCONV void\t_invlist_union(pTHX_ SV* const a, SV* const b, SV** output); */\nPERL_CALLCONV void\tPerl__invlist_union_maybe_complement_2nd(pTHX_ SV* const a, SV* const b, const bool complement_b, SV** output);\n#define PERL_ARGS_ASSERT__INVLIST_UNION_MAYBE_COMPLEMENT_2ND\t\\\n\tassert(b); assert(output)\nPERL_CALLCONV SV*\tPerl__new_invlist(pTHX_ IV initial_size)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SV*\tPerl__setup_canned_invlist(pTHX_ const STRLEN size, const UV element0, UV** other_elements_ptr)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__SETUP_CANNED_INVLIST\t\\\n\tassert(other_elements_ptr)\n\n#endif\n#if defined(PERL_IN_REGEXEC_C)\nSTATIC LB_enum\tS_advance_one_LB(pTHX_ U8 ** curpos, const U8 * const strend, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ADVANCE_ONE_LB\t\\\n\tassert(curpos); assert(strend)\n\nSTATIC SB_enum\tS_advance_one_SB(pTHX_ U8 ** curpos, const U8 * const strend, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ADVANCE_ONE_SB\t\\\n\tassert(curpos); assert(strend)\n\nSTATIC WB_enum\tS_advance_one_WB(pTHX_ U8 ** curpos, const U8 * const strend, const bool utf8_target, const bool skip_Extend_Format)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ADVANCE_ONE_WB\t\\\n\tassert(curpos); assert(strend)\n\nSTATIC GCB_enum\tS_backup_one_GCB(pTHX_ const U8 * const strbeg, U8 ** curpos, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_BACKUP_ONE_GCB\t\\\n\tassert(strbeg); assert(curpos)\n\nSTATIC LB_enum\tS_backup_one_LB(pTHX_ const U8 * const strbeg, U8 ** curpos, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_BACKUP_ONE_LB\t\\\n\tassert(strbeg); assert(curpos)\n\nSTATIC SB_enum\tS_backup_one_SB(pTHX_ const U8 * const strbeg, U8 ** curpos, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_BACKUP_ONE_SB\t\\\n\tassert(strbeg); assert(curpos)\n\nSTATIC WB_enum\tS_backup_one_WB(pTHX_ WB_enum * previous, const U8 * const strbeg, U8 ** curpos, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_BACKUP_ONE_WB\t\\\n\tassert(previous); assert(strbeg); assert(curpos)\n\nSTATIC char*\tS_find_byclass(pTHX_ regexp * prog, const regnode *c, char *s, const char *strend, regmatch_info *reginfo)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FIND_BYCLASS\t\\\n\tassert(prog); assert(c); assert(s); assert(strend)\n\nSTATIC U8 *\tS_find_next_masked(U8 * s, const U8 * send, const U8 byte, const U8 mask)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FIND_NEXT_MASKED\t\\\n\tassert(s); assert(send)\n\nSTATIC U8 *\tS_find_span_end(U8* s, const U8 * send, const U8 span_byte)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FIND_SPAN_END\t\\\n\tassert(s); assert(send)\n\nSTATIC U8 *\tS_find_span_end_mask(U8 * s, const U8 * send, const U8 span_byte, const U8 mask)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FIND_SPAN_END_MASK\t\\\n\tassert(s); assert(send)\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE I32\tS_foldEQ_latin1_s2_folded(const char* a, const char* b, I32 len);\n#define PERL_ARGS_ASSERT_FOLDEQ_LATIN1_S2_FOLDED\t\\\n\tassert(a); assert(b)\n#endif\nSTATIC bool\tS_isFOO_utf8_lc(pTHX_ const U8 classnum, const U8* character, const U8* e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISFOO_UTF8_LC\t\\\n\tassert(character); assert(e)\n\nSTATIC bool\tS_isGCB(pTHX_ const GCB_enum before, const GCB_enum after, const U8 * const strbeg, const U8 * const curpos, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISGCB\t\\\n\tassert(strbeg); assert(curpos)\n\nSTATIC bool\tS_isLB(pTHX_ LB_enum before, LB_enum after, const U8 * const strbeg, const U8 * const curpos, const U8 * const strend, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISLB\t\\\n\tassert(strbeg); assert(curpos); assert(strend)\n\nSTATIC bool\tS_isSB(pTHX_ SB_enum before, SB_enum after, const U8 * const strbeg, const U8 * const curpos, const U8 * const strend, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISSB\t\\\n\tassert(strbeg); assert(curpos); assert(strend)\n\nSTATIC bool\tS_isWB(pTHX_ WB_enum previous, WB_enum before, WB_enum after, const U8 * const strbeg, const U8 * const curpos, const U8 * const strend, const bool utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISWB\t\\\n\tassert(strbeg); assert(curpos); assert(strend)\n\nSTATIC I32\tS_reg_check_named_buff_matched(const regexp *rex, const regnode *scan)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REG_CHECK_NAMED_BUFF_MATCHED\t\\\n\tassert(rex); assert(scan)\n\nSTATIC void\tS_regcp_restore(pTHX_ regexp *rex, I32 ix, U32 *maxopenparen_p _pDEPTH);\n#define PERL_ARGS_ASSERT_REGCP_RESTORE\t\\\n\tassert(rex); assert(maxopenparen_p)\nSTATIC void\tS_regcppop(pTHX_ regexp *rex, U32 *maxopenparen_p _pDEPTH);\n#define PERL_ARGS_ASSERT_REGCPPOP\t\\\n\tassert(rex); assert(maxopenparen_p)\nSTATIC CHECKPOINT\tS_regcppush(pTHX_ const regexp *rex, I32 parenfloor, U32 maxopenparen _pDEPTH);\n#define PERL_ARGS_ASSERT_REGCPPUSH\t\\\n\tassert(rex)\nSTATIC U8*\tS_reghop3(U8 *s, SSize_t off, const U8 *lim)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGHOP3\t\\\n\tassert(s); assert(lim)\n\nSTATIC U8*\tS_reghop4(U8 *s, SSize_t off, const U8 *llim, const U8 *rlim)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGHOP4\t\\\n\tassert(s); assert(llim); assert(rlim)\n\nSTATIC U8*\tS_reghopmaybe3(U8 *s, SSize_t off, const U8 * const lim)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGHOPMAYBE3\t\\\n\tassert(s); assert(lim)\n\nSTATIC bool\tS_reginclass(pTHX_ regexp * const prog, const regnode * const n, const U8 * const p, const U8 * const p_end, bool const utf8_target)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGINCLASS\t\\\n\tassert(n); assert(p); assert(p_end)\n\nSTATIC SSize_t\tS_regmatch(pTHX_ regmatch_info *reginfo, char *startpos, regnode *prog)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGMATCH\t\\\n\tassert(reginfo); assert(startpos); assert(prog)\n\nSTATIC I32\tS_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p, char *loceol, regmatch_info *const reginfo, I32 max _pDEPTH)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGREPEAT\t\\\n\tassert(prog); assert(startposp); assert(p); assert(loceol); assert(reginfo)\n\nSTATIC bool\tS_regtry(pTHX_ regmatch_info *reginfo, char **startposp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_REGTRY\t\\\n\tassert(reginfo); assert(startposp)\n\nSTATIC bool\tS_to_byte_substr(pTHX_ regexp * prog);\n#define PERL_ARGS_ASSERT_TO_BYTE_SUBSTR\t\\\n\tassert(prog)\nSTATIC void\tS_to_utf8_substr(pTHX_ regexp * prog);\n#define PERL_ARGS_ASSERT_TO_UTF8_SUBSTR\t\\\n\tassert(prog)\n#endif\n#if defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_TOKE_C)\nPERL_CALLCONV bool\tPerl__is_grapheme(pTHX_ const U8 * strbeg, const U8 * s, const U8 *strend, const UV cp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT__IS_GRAPHEME\t\\\n\tassert(strbeg); assert(s); assert(strend)\n\n#endif\n#if defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C)\nPERL_CALLCONV bool\tPerl_isFOO_lc(pTHX_ const U8 classnum, const U8 character)\n\t\t\t__attribute__warn_unused_result__;\n\n#endif\n#if defined(PERL_IN_SCOPE_C)\nSTATIC void\tS_save_pushptri32ptr(pTHX_ void *const ptr1, const I32 i, void *const ptr2, const int type);\nSTATIC SV*\tS_save_scalar_at(pTHX_ SV **sptr, const U32 flags);\n#define PERL_ARGS_ASSERT_SAVE_SCALAR_AT\t\\\n\tassert(sptr)\n#endif\n#if defined(PERL_IN_SV_C)\nSTATIC char *\tS_F0convert(NV nv, char *const endbuf, STRLEN *const len);\n#define PERL_ARGS_ASSERT_F0CONVERT\t\\\n\tassert(endbuf); assert(len)\nSTATIC void\tS_anonymise_cv_maybe(pTHX_ GV *gv, CV *cv);\n#define PERL_ARGS_ASSERT_ANONYMISE_CV_MAYBE\t\\\n\tassert(gv); assert(cv)\nSTATIC void\tS_assert_uft8_cache_coherent(pTHX_ const char *const func, STRLEN from_cache, STRLEN real, SV *const sv);\n#define PERL_ARGS_ASSERT_ASSERT_UFT8_CACHE_COHERENT\t\\\n\tassert(func); assert(sv)\nSTATIC bool\tS_curse(pTHX_ SV * const sv, const bool check_refcnt);\n#define PERL_ARGS_ASSERT_CURSE\t\\\n\tassert(sv)\nSTATIC STRLEN\tS_expect_number(pTHX_ const char **const pattern)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_EXPECT_NUMBER\t\\\n\tassert(pattern)\n\nSTATIC SSize_t\tS_find_array_subscript(pTHX_ const AV *const av, const SV *const val);\n#define PERL_ARGS_ASSERT_FIND_ARRAY_SUBSCRIPT\t\\\n\tassert(val)\nSTATIC SV *\tS_find_hash_subscript(pTHX_ const HV *const hv, const SV *const val);\n#define PERL_ARGS_ASSERT_FIND_HASH_SUBSCRIPT\t\\\n\tassert(val)\nSTATIC SV*\tS_find_uninit_var(pTHX_ const OP *const obase, const SV *const uninit_sv, bool match, const char **desc_p);\n#define PERL_ARGS_ASSERT_FIND_UNINIT_VAR\t\\\n\tassert(desc_p)\nSTATIC bool\tS_glob_2number(pTHX_ GV* const gv);\n#define PERL_ARGS_ASSERT_GLOB_2NUMBER\t\\\n\tassert(gv)\nSTATIC void\tS_glob_assign_glob(pTHX_ SV *const dstr, SV *const sstr, const int dtype);\n#define PERL_ARGS_ASSERT_GLOB_ASSIGN_GLOB\t\\\n\tassert(dstr); assert(sstr)\nSTATIC SV *\tS_more_sv(pTHX);\nSTATIC void\tS_not_a_number(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_NOT_A_NUMBER\t\\\n\tassert(sv)\nSTATIC void\tS_not_incrementable(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_NOT_INCREMENTABLE\t\\\n\tassert(sv)\nSTATIC PTR_TBL_ENT_t *\tS_ptr_table_find(PTR_TBL_t *const tbl, const void *const sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PTR_TABLE_FIND\t\\\n\tassert(tbl)\n\nSTATIC bool\tS_sv_2iuv_common(pTHX_ SV *const sv);\n#define PERL_ARGS_ASSERT_SV_2IUV_COMMON\t\\\n\tassert(sv)\nSTATIC void\tS_sv_add_arena(pTHX_ char *const ptr, const U32 size, const U32 flags);\n#define PERL_ARGS_ASSERT_SV_ADD_ARENA\t\\\n\tassert(ptr)\nSTATIC const char *\tS_sv_display(pTHX_ SV *const sv, char *tmpbuf, STRLEN tmpbuf_size);\n#define PERL_ARGS_ASSERT_SV_DISPLAY\t\\\n\tassert(sv); assert(tmpbuf)\nSTATIC STRLEN\tS_sv_pos_b2u_midway(pTHX_ const U8 *const s, const U8 *const target, const U8 *end, STRLEN endu);\n#define PERL_ARGS_ASSERT_SV_POS_B2U_MIDWAY\t\\\n\tassert(s); assert(target); assert(end)\nSTATIC STRLEN\tS_sv_pos_u2b_cached(pTHX_ SV *const sv, MAGIC **const mgp, const U8 *const start, const U8 *const send, STRLEN uoffset, STRLEN uoffset0, STRLEN boffset0);\n#define PERL_ARGS_ASSERT_SV_POS_U2B_CACHED\t\\\n\tassert(sv); assert(mgp); assert(start); assert(send)\nSTATIC STRLEN\tS_sv_pos_u2b_forwards(const U8 *const start, const U8 *const send, STRLEN *const uoffset, bool *const at_end);\n#define PERL_ARGS_ASSERT_SV_POS_U2B_FORWARDS\t\\\n\tassert(start); assert(send); assert(uoffset); assert(at_end)\nSTATIC STRLEN\tS_sv_pos_u2b_midway(const U8 *const start, const U8 *send, STRLEN uoffset, const STRLEN uend);\n#define PERL_ARGS_ASSERT_SV_POS_U2B_MIDWAY\t\\\n\tassert(start); assert(send)\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE void\tS_sv_unglob(pTHX_ SV *const sv, U32 flags);\n#define PERL_ARGS_ASSERT_SV_UNGLOB\t\\\n\tassert(sv)\n#endif\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE char *\tS_uiv_2buf(char *const buf, const IV iv, UV uv, const int is_uv, char **const peob)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UIV_2BUF\t\\\n\tassert(buf); assert(peob)\n#endif\n\nSTATIC void\tS_utf8_mg_len_cache_update(pTHX_ SV *const sv, MAGIC **const mgp, const STRLEN ulen);\n#define PERL_ARGS_ASSERT_UTF8_MG_LEN_CACHE_UPDATE\t\\\n\tassert(sv); assert(mgp)\nSTATIC void\tS_utf8_mg_pos_cache_update(pTHX_ SV *const sv, MAGIC **const mgp, const STRLEN byte, const STRLEN utf8, const STRLEN blen);\n#define PERL_ARGS_ASSERT_UTF8_MG_POS_CACHE_UPDATE\t\\\n\tassert(sv); assert(mgp)\nSTATIC I32\tS_visit(pTHX_ SVFUNC_t f, const U32 flags, const U32 mask);\n#define PERL_ARGS_ASSERT_VISIT\t\\\n\tassert(f)\n#  if defined(USE_ITHREADS)\nSTATIC SV*\tS_sv_dup_common(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DUP_COMMON\t\\\n\tassert(sstr); assert(param)\n\nSTATIC SV **\tS_sv_dup_inc_multiple(pTHX_ SV *const *source, SV **dest, SSize_t items, CLONE_PARAMS *const param);\n#define PERL_ARGS_ASSERT_SV_DUP_INC_MULTIPLE\t\\\n\tassert(source); assert(dest); assert(param)\nSTATIC void\tS_unreferenced_to_tmp_stack(pTHX_ AV *const unreferenced);\n#define PERL_ARGS_ASSERT_UNREFERENCED_TO_TMP_STACK\t\\\n\tassert(unreferenced)\n#  endif\n#endif\n#if defined(PERL_IN_SV_C) || defined (PERL_IN_OP_C)\nPERL_CALLCONV SV *\tPerl_varname(pTHX_ const GV *const gv, const char gvtype, PADOFFSET targ, const SV *const keyname, SSize_t aindex, int subscript_type)\n\t\t\t__attribute__warn_unused_result__;\n\n#endif\n#if defined(PERL_IN_TOKE_C)\nSTATIC int\tS_ao(pTHX_ int toketype);\nSTATIC void\tS_check_uni(pTHX);\nSTATIC void\tS_checkcomma(pTHX_ const char *s, const char *name, const char *what);\n#define PERL_ARGS_ASSERT_CHECKCOMMA\t\\\n\tassert(s); assert(name); assert(what)\nSTATIC char *\tS_filter_gets(pTHX_ SV *sv, STRLEN append)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FILTER_GETS\t\\\n\tassert(sv)\n\nSTATIC HV *\tS_find_in_my_stash(pTHX_ const char *pkgname, STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_FIND_IN_MY_STASH\t\\\n\tassert(pkgname)\n\nSTATIC void\tS_force_ident(pTHX_ const char *s, int kind);\n#define PERL_ARGS_ASSERT_FORCE_IDENT\t\\\n\tassert(s)\nSTATIC void\tS_force_ident_maybe_lex(pTHX_ char pit);\nSTATIC void\tS_force_next(pTHX_ I32 type);\nSTATIC char*\tS_force_strict_version(pTHX_ char *s);\n#define PERL_ARGS_ASSERT_FORCE_STRICT_VERSION\t\\\n\tassert(s)\nSTATIC char*\tS_force_version(pTHX_ char *s, int guessing);\n#define PERL_ARGS_ASSERT_FORCE_VERSION\t\\\n\tassert(s)\nSTATIC char*\tS_force_word(pTHX_ char *start, int token, int check_keyword, int allow_pack);\n#define PERL_ARGS_ASSERT_FORCE_WORD\t\\\n\tassert(start)\nSTATIC SV*\tS_get_and_check_backslash_N_name_wrapper(pTHX_ const char* s, const char* const e)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GET_AND_CHECK_BACKSLASH_N_NAME_WRAPPER\t\\\n\tassert(s); assert(e)\n\nSTATIC void\tS_incline(pTHX_ const char *s, const char *end);\n#define PERL_ARGS_ASSERT_INCLINE\t\\\n\tassert(s); assert(end)\nSTATIC int\tS_intuit_method(pTHX_ char *s, SV *ioname, CV *cv);\n#define PERL_ARGS_ASSERT_INTUIT_METHOD\t\\\n\tassert(s)\nSTATIC int\tS_intuit_more(pTHX_ char *s, char *e);\n#define PERL_ARGS_ASSERT_INTUIT_MORE\t\\\n\tassert(s); assert(e)\nSTATIC I32\tS_lop(pTHX_ I32 f, U8 x, char *s);\n#define PERL_ARGS_ASSERT_LOP\t\\\n\tassert(s)\nPERL_STATIC_NO_RET void\tS_missingterm(pTHX_ char *s, STRLEN len)\n\t\t\t__attribute__noreturn__;\n\nSTATIC SV*\tS_new_constant(pTHX_ const char *s, STRLEN len, const char *key, STRLEN keylen, SV *sv, SV *pv, const char *type, STRLEN typelen, const char ** error_msg);\n#define PERL_ARGS_ASSERT_NEW_CONSTANT\t\\\n\tassert(key); assert(sv)\nSTATIC void\tS_no_op(pTHX_ const char *const what, char *s);\n#define PERL_ARGS_ASSERT_NO_OP\t\\\n\tassert(what)\nSTATIC void\tS_parse_ident(pTHX_ char **s, char **d, char * const e, int allow_package, bool is_utf8, bool check_dollar, bool tick_warn);\n#define PERL_ARGS_ASSERT_PARSE_IDENT\t\\\n\tassert(s); assert(d); assert(e)\nSTATIC int\tS_pending_ident(pTHX);\nSTATIC char*\tS_scan_const(pTHX_ char *start)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_CONST\t\\\n\tassert(start)\n\nSTATIC char*\tS_scan_formline(pTHX_ char *s)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_FORMLINE\t\\\n\tassert(s)\n\nSTATIC char*\tS_scan_heredoc(pTHX_ char *s)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_HEREDOC\t\\\n\tassert(s)\n\nSTATIC char*\tS_scan_ident(pTHX_ char *s, char *dest, STRLEN destlen, I32 ck_uni);\n#define PERL_ARGS_ASSERT_SCAN_IDENT\t\\\n\tassert(s); assert(dest)\nSTATIC char*\tS_scan_inputsymbol(pTHX_ char *start)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_INPUTSYMBOL\t\\\n\tassert(start)\n\nSTATIC char*\tS_scan_pat(pTHX_ char *start, I32 type)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_PAT\t\\\n\tassert(start)\n\nSTATIC char*\tS_scan_subst(pTHX_ char *start)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_SUBST\t\\\n\tassert(start)\n\nSTATIC char*\tS_scan_trans(pTHX_ char *start)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SCAN_TRANS\t\\\n\tassert(start)\n\nSTATIC I32\tS_sublex_done(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC I32\tS_sublex_push(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC I32\tS_sublex_start(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC char*\tS_swallow_bom(pTHX_ U8 *s)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SWALLOW_BOM\t\\\n\tassert(s)\n\nSTATIC char *\tS_tokenize_use(pTHX_ int is_use, char *s)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_TOKENIZE_USE\t\\\n\tassert(s)\n\nSTATIC SV*\tS_tokeq(pTHX_ SV *sv);\n#define PERL_ARGS_ASSERT_TOKEQ\t\\\n\tassert(sv)\nSTATIC void\tS_update_debugger_info(pTHX_ SV *orig_sv, const char *const buf, STRLEN len);\nSTATIC int\tS_yywarn(pTHX_ const char *const s, U32 flags);\n#define PERL_ARGS_ASSERT_YYWARN\t\\\n\tassert(s)\n#endif\n#if defined(PERL_IN_UNIVERSAL_C)\nSTATIC bool\tS_isa_lookup(pTHX_ HV *stash, const char * const name, STRLEN len, U32 flags);\n#define PERL_ARGS_ASSERT_ISA_LOOKUP\t\\\n\tassert(stash); assert(name)\n#endif\n#if defined(PERL_IN_UTF8_C)\nSTATIC UV\tS__to_utf8_case(pTHX_ const UV uv1, const U8 *p, U8* ustrp, STRLEN *lenp, SV *invlist, const int * const invmap, const unsigned int * const * const aux_tables, const U8 * const aux_table_lengths, const char * const normal);\n#define PERL_ARGS_ASSERT__TO_UTF8_CASE\t\\\n\tassert(ustrp); assert(lenp); assert(invlist); assert(invmap); assert(normal)\nSTATIC U32\tS_check_and_deprecate(pTHX_ const U8 * p, const U8 ** e, const unsigned type, const bool use_locale, const char * const file, const unsigned line);\n#define PERL_ARGS_ASSERT_CHECK_AND_DEPRECATE\t\\\n\tassert(p); assert(e); assert(file)\nSTATIC UV\tS_check_locale_boundary_crossing(pTHX_ const U8* const p, const UV result, U8* const ustrp, STRLEN *lenp)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CHECK_LOCALE_BOUNDARY_CROSSING\t\\\n\tassert(p); assert(ustrp); assert(lenp)\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE int\tS_does_utf8_overflow(const U8 * const s, const U8 * e, const bool consider_overlongs)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DOES_UTF8_OVERFLOW\t\\\n\tassert(s); assert(e)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE int\tS_isFF_OVERLONG(const U8 * const s, const STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ISFF_OVERLONG\t\\\n\tassert(s)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_common(pTHX_ const U8 *const p, SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_COMMON\t\\\n\tassert(p)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE bool\tS_is_utf8_common_with_len(pTHX_ const U8 *const p, const U8 *const e, SV* const invlist)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_COMMON_WITH_LEN\t\\\n\tassert(p); assert(e)\n#endif\n\n#ifndef PERL_NO_INLINE_FUNCTIONS\nPERL_STATIC_INLINE int\tS_is_utf8_overlong_given_start_byte_ok(const U8 * const s, const STRLEN len)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_IS_UTF8_OVERLONG_GIVEN_START_BYTE_OK\t\\\n\tassert(s)\n#endif\n\nSTATIC HV *\tS_new_msg_hv(pTHX_ const char * const message, U32 categories, U32 flag)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEW_MSG_HV\t\\\n\tassert(message)\n\nSTATIC U8*\tS_swash_scan_list_line(pTHX_ U8* l, U8* const lend, UV* min, UV* max, UV* val, const bool wants_value, const U8* const typestr)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SWASH_SCAN_LIST_LINE\t\\\n\tassert(l); assert(lend); assert(min); assert(max); assert(val); assert(typestr)\n\nSTATIC SV*\tS_swatch_get(pTHX_ SV* swash, UV start, UV span)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SWATCH_GET\t\\\n\tassert(swash)\n\nSTATIC U8\tS_to_lower_latin1(const U8 c, U8 *p, STRLEN *lenp, const char dummy)\n\t\t\t__attribute__warn_unused_result__;\n\nSTATIC UV\tS_turkic_fc(pTHX_ const U8 * const p, const U8 * const e, U8* ustrp, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_TURKIC_FC\t\\\n\tassert(p); assert(e); assert(ustrp); assert(lenp)\nSTATIC UV\tS_turkic_lc(pTHX_ const U8 * const p0, const U8 * const e, U8* ustrp, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_TURKIC_LC\t\\\n\tassert(p0); assert(e); assert(ustrp); assert(lenp)\nSTATIC UV\tS_turkic_uc(pTHX_ const U8 * const p, const U8 * const e, U8* ustrp, STRLEN *lenp);\n#define PERL_ARGS_ASSERT_TURKIC_UC\t\\\n\tassert(p); assert(e); assert(ustrp); assert(lenp)\nSTATIC char *\tS_unexpected_non_continuation_text(pTHX_ const U8 * const s, STRLEN print_len, const STRLEN non_cont_byte_pos, const STRLEN expect_len)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_UNEXPECTED_NON_CONTINUATION_TEXT\t\\\n\tassert(s)\n\nSTATIC void\tS_warn_on_first_deprecated_use(pTHX_ const char * const name, const char * const alternative, const bool use_locale, const char * const file, const unsigned line);\n#define PERL_ARGS_ASSERT_WARN_ON_FIRST_DEPRECATED_USE\t\\\n\tassert(name); assert(alternative); assert(file)\n#endif\n#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)\nPERL_CALLCONV UV\tPerl__to_upper_title_latin1(pTHX_ const U8 c, U8 *p, STRLEN *lenp, const char S_or_s);\n#define PERL_ARGS_ASSERT__TO_UPPER_TITLE_LATIN1\t\\\n\tassert(p); assert(lenp)\n#endif\n#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)\nPERL_CALLCONV UV\tPerl__to_fold_latin1(const U8 c, U8 *p, STRLEN *lenp, const unsigned int flags);\n#define PERL_ARGS_ASSERT__TO_FOLD_LATIN1\t\\\n\tassert(p); assert(lenp)\n#endif\n#if defined(PERL_IN_UTIL_C)\nSTATIC bool\tS_ckwarn_common(pTHX_ U32 w);\nSTATIC bool\tS_invoke_exception_hook(pTHX_ SV *ex, bool warn);\nSTATIC SV*\tS_mess_alloc(pTHX);\nSTATIC SV *\tS_with_queued_errors(pTHX_ SV *ex);\n#define PERL_ARGS_ASSERT_WITH_QUEUED_ERRORS\t\\\n\tassert(ex)\nSTATIC void\tS_xs_version_bootcheck(pTHX_ U32 items, U32 ax, const char *xs_p, STRLEN xs_len);\n#define PERL_ARGS_ASSERT_XS_VERSION_BOOTCHECK\t\\\n\tassert(xs_p)\n#  if defined(PERL_MEM_LOG) && !defined(PERL_MEM_LOG_NOIMPL)\nSTATIC void\tS_mem_log_common(enum mem_log_type mlt, const UV n, const UV typesize, const char *type_name, const SV *sv, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);\n#define PERL_ARGS_ASSERT_MEM_LOG_COMMON\t\\\n\tassert(type_name); assert(filename); assert(funcname)\n#  endif\n#endif\n#if defined(PERL_MEM_LOG)\nPERL_CALLCONV Malloc_t\tPerl_mem_log_alloc(const UV nconst, UV typesize, const char *type_name, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);\n#define PERL_ARGS_ASSERT_MEM_LOG_ALLOC\t\\\n\tassert(type_name); assert(filename); assert(funcname)\nPERL_CALLCONV Malloc_t\tPerl_mem_log_free(Malloc_t oldalloc, const char *filename, const int linenumber, const char *funcname);\n#define PERL_ARGS_ASSERT_MEM_LOG_FREE\t\\\n\tassert(filename); assert(funcname)\nPERL_CALLCONV Malloc_t\tPerl_mem_log_realloc(const UV n, const UV typesize, const char *type_name, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);\n#define PERL_ARGS_ASSERT_MEM_LOG_REALLOC\t\\\n\tassert(type_name); assert(filename); assert(funcname)\n#endif\n#if defined(PERL_USES_PL_PIDSTATUS) && defined(PERL_IN_UTIL_C)\nSTATIC void\tS_pidgone(pTHX_ Pid_t pid, int status);\n#endif\n#if defined(UNLINK_ALL_VERSIONS)\nPERL_CALLCONV I32\tPerl_unlnk(pTHX_ const char* f);\n#define PERL_ARGS_ASSERT_UNLNK\t\\\n\tassert(f)\n#endif\n#if defined(USE_C_BACKTRACE)\nPERL_CALLCONV bool\tPerl_dump_c_backtrace(pTHX_ PerlIO* fp, int max_depth, int skip);\n#define PERL_ARGS_ASSERT_DUMP_C_BACKTRACE\t\\\n\tassert(fp)\n/* PERL_CALLCONV void\tfree_c_backtrace(pTHX_ Perl_c_backtrace* bt); */\nPERL_CALLCONV Perl_c_backtrace*\tPerl_get_c_backtrace(pTHX_ int max_depth, int skip);\nPERL_CALLCONV SV*\tPerl_get_c_backtrace_dump(pTHX_ int max_depth, int skip);\n#endif\n#if defined(USE_DTRACE)\nPERL_CALLCONV void\tPerl_dtrace_probe_call(pTHX_ CV *cv, bool is_call);\n#define PERL_ARGS_ASSERT_DTRACE_PROBE_CALL\t\\\n\tassert(cv)\nPERL_CALLCONV void\tPerl_dtrace_probe_load(pTHX_ const char *name, bool is_loading);\n#define PERL_ARGS_ASSERT_DTRACE_PROBE_LOAD\t\\\n\tassert(name)\nPERL_CALLCONV void\tPerl_dtrace_probe_op(pTHX_ const OP *op);\n#define PERL_ARGS_ASSERT_DTRACE_PROBE_OP\t\\\n\tassert(op)\nPERL_CALLCONV void\tPerl_dtrace_probe_phase(pTHX_ enum perl_phase phase);\n#endif\n#if defined(USE_ITHREADS)\nPERL_CALLCONV PADOFFSET\tPerl_alloccopstash(pTHX_ HV *hv);\n#define PERL_ARGS_ASSERT_ALLOCCOPSTASH\t\\\n\tassert(hv)\nPERL_CALLCONV void*\tPerl_any_dup(pTHX_ void* v, const PerlInterpreter* proto_perl)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_ANY_DUP\t\\\n\tassert(proto_perl)\n\nPERL_CALLCONV void\tPerl_clone_params_del(CLONE_PARAMS *param);\n#define PERL_ARGS_ASSERT_CLONE_PARAMS_DEL\t\\\n\tassert(param)\nPERL_CALLCONV CLONE_PARAMS *\tPerl_clone_params_new(PerlInterpreter *const from, PerlInterpreter *const to)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CLONE_PARAMS_NEW\t\\\n\tassert(from); assert(to)\n\nPERL_CALLCONV PERL_CONTEXT*\tPerl_cx_dup(pTHX_ PERL_CONTEXT* cx, I32 ix, I32 max, CLONE_PARAMS* param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_CX_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV DIR*\tPerl_dirp_dup(pTHX_ DIR *const dp, CLONE_PARAMS *const param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_DIRP_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV PerlIO*\tPerl_fp_dup(pTHX_ PerlIO *const fp, const char type, CLONE_PARAMS *const param);\n#define PERL_ARGS_ASSERT_FP_DUP\t\\\n\tassert(param)\nPERL_CALLCONV GP*\tPerl_gp_dup(pTHX_ GP *const gp, CLONE_PARAMS *const param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_GP_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV HE*\tPerl_he_dup(pTHX_ const HE* e, bool shared, CLONE_PARAMS* param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HE_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV HEK*\tPerl_hek_dup(pTHX_ HEK* e, CLONE_PARAMS* param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_HEK_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV MAGIC*\tPerl_mg_dup(pTHX_ MAGIC *mg, CLONE_PARAMS *const param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_MG_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV struct mro_meta*\tPerl_mro_meta_dup(pTHX_ struct mro_meta* smeta, CLONE_PARAMS* param);\n#define PERL_ARGS_ASSERT_MRO_META_DUP\t\\\n\tassert(smeta); assert(param)\nPERL_CALLCONV OP*\tPerl_newPADOP(pTHX_ I32 type, I32 flags, SV* sv)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_NEWPADOP\t\\\n\tassert(sv)\n\nPERL_CALLCONV PADLIST *\tPerl_padlist_dup(pTHX_ PADLIST *srcpad, CLONE_PARAMS *param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PADLIST_DUP\t\\\n\tassert(srcpad); assert(param)\n\nPERL_CALLCONV PADNAME *\tPerl_padname_dup(pTHX_ PADNAME *src, CLONE_PARAMS *param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PADNAME_DUP\t\\\n\tassert(src); assert(param)\n\nPERL_CALLCONV PADNAMELIST *\tPerl_padnamelist_dup(pTHX_ PADNAMELIST *srcpad, CLONE_PARAMS *param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_PADNAMELIST_DUP\t\\\n\tassert(srcpad); assert(param)\n\nPERL_CALLCONV yy_parser*\tPerl_parser_dup(pTHX_ const yy_parser *const proto, CLONE_PARAMS *const param);\n#define PERL_ARGS_ASSERT_PARSER_DUP\t\\\n\tassert(param)\nPERL_CALLCONV PerlInterpreter*\tperl_clone(PerlInterpreter *proto_perl, UV flags);\n#define PERL_ARGS_ASSERT_PERL_CLONE\t\\\n\tassert(proto_perl)\nPERL_CALLCONV void\tPerl_re_dup_guts(pTHX_ const REGEXP *sstr, REGEXP *dstr, CLONE_PARAMS* param);\n#define PERL_ARGS_ASSERT_RE_DUP_GUTS\t\\\n\tassert(sstr); assert(dstr); assert(param)\nPERL_CALLCONV void*\tPerl_regdupe_internal(pTHX_ REGEXP * const r, CLONE_PARAMS* param);\n#define PERL_ARGS_ASSERT_REGDUPE_INTERNAL\t\\\n\tassert(r); assert(param)\nPERL_CALLCONV void\tPerl_rvpv_dup(pTHX_ SV *const dstr, const SV *const sstr, CLONE_PARAMS *const param);\n#define PERL_ARGS_ASSERT_RVPV_DUP\t\\\n\tassert(dstr); assert(sstr); assert(param)\nPERL_CALLCONV PERL_SI*\tPerl_si_dup(pTHX_ PERL_SI* si, CLONE_PARAMS* param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SI_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV ANY*\tPerl_ss_dup(pTHX_ PerlInterpreter* proto_perl, CLONE_PARAMS* param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SS_DUP\t\\\n\tassert(proto_perl); assert(param)\n\nPERL_CALLCONV SV*\tPerl_sv_dup(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DUP\t\\\n\tassert(param)\n\nPERL_CALLCONV SV*\tPerl_sv_dup_inc(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)\n\t\t\t__attribute__warn_unused_result__;\n#define PERL_ARGS_ASSERT_SV_DUP_INC\t\\\n\tassert(param)\n\n#endif\n#if defined(USE_LOCALE)\t\t    && (   defined(PERL_IN_LOCALE_C)\t        || defined(PERL_IN_MG_C)\t\t|| defined (PERL_EXT_POSIX)\t\t|| defined (PERL_EXT_LANGINFO))\nPERL_CALLCONV bool\tPerl__is_cur_LC_category_utf8(pTHX_ int category);\n#endif\n#if defined(USE_LOCALE_COLLATE)\nPERL_CALLCONV int\tPerl_magic_setcollxfrm(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_SETCOLLXFRM\t\\\n\tassert(sv); assert(mg)\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_mem_collxfrm(pTHX_ const char* input_string, STRLEN len, STRLEN* xlen);\n#define PERL_ARGS_ASSERT_MEM_COLLXFRM\t\\\n\tassert(input_string); assert(xlen)\n#endif\n#ifndef NO_MATHOMS\nPERL_CALLCONV char*\tPerl_sv_collxfrm(pTHX_ SV *const sv, STRLEN *const nxp);\n#define PERL_ARGS_ASSERT_SV_COLLXFRM\t\\\n\tassert(sv); assert(nxp)\n#endif\nPERL_CALLCONV char*\tPerl_sv_collxfrm_flags(pTHX_ SV *const sv, STRLEN *const nxp, I32 const flags);\n#define PERL_ARGS_ASSERT_SV_COLLXFRM_FLAGS\t\\\n\tassert(sv); assert(nxp)\n#endif\n#if defined(USE_PERLIO)\nPERL_CALLCONV void\tPerl_PerlIO_clearerr(pTHX_ PerlIO *f);\nPERL_CALLCONV int\tPerl_PerlIO_close(pTHX_ PerlIO *f);\nPERL_CALLCONV int\tPerl_PerlIO_eof(pTHX_ PerlIO *f);\nPERL_CALLCONV int\tPerl_PerlIO_error(pTHX_ PerlIO *f);\nPERL_CALLCONV int\tPerl_PerlIO_fileno(pTHX_ PerlIO *f);\nPERL_CALLCONV int\tPerl_PerlIO_fill(pTHX_ PerlIO *f);\nPERL_CALLCONV int\tPerl_PerlIO_flush(pTHX_ PerlIO *f);\nPERL_CALLCONV STDCHAR *\tPerl_PerlIO_get_base(pTHX_ PerlIO *f);\nPERL_CALLCONV SSize_t\tPerl_PerlIO_get_bufsiz(pTHX_ PerlIO *f)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV SSize_t\tPerl_PerlIO_get_cnt(pTHX_ PerlIO *f)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV STDCHAR *\tPerl_PerlIO_get_ptr(pTHX_ PerlIO *f);\nPERL_CALLCONV SSize_t\tPerl_PerlIO_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);\n#define PERL_ARGS_ASSERT_PERLIO_READ\t\\\n\tassert(vbuf)\nPERL_CALLCONV void\tPerl_PerlIO_restore_errno(pTHX_ PerlIO *f);\nPERL_CALLCONV void\tPerl_PerlIO_save_errno(pTHX_ PerlIO *f);\nPERL_CALLCONV int\tPerl_PerlIO_seek(pTHX_ PerlIO *f, Off_t offset, int whence);\nPERL_CALLCONV void\tPerl_PerlIO_set_cnt(pTHX_ PerlIO *f, SSize_t cnt);\nPERL_CALLCONV void\tPerl_PerlIO_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR *ptr, SSize_t cnt);\nPERL_CALLCONV void\tPerl_PerlIO_setlinebuf(pTHX_ PerlIO *f);\nPERL_CALLCONV PerlIO *\tPerl_PerlIO_stderr(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV PerlIO *\tPerl_PerlIO_stdin(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV PerlIO *\tPerl_PerlIO_stdout(pTHX)\n\t\t\t__attribute__warn_unused_result__;\n\nPERL_CALLCONV Off_t\tPerl_PerlIO_tell(pTHX_ PerlIO *f);\nPERL_CALLCONV SSize_t\tPerl_PerlIO_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);\n#define PERL_ARGS_ASSERT_PERLIO_UNREAD\t\\\n\tassert(vbuf)\nPERL_CALLCONV SSize_t\tPerl_PerlIO_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);\n#define PERL_ARGS_ASSERT_PERLIO_WRITE\t\\\n\tassert(vbuf)\n#endif\n#if defined(USE_QUADMATH)\nPERL_CALLCONV bool\tPerl_quadmath_format_needed(const char* format);\n#define PERL_ARGS_ASSERT_QUADMATH_FORMAT_NEEDED\t\\\n\tassert(format)\nPERL_CALLCONV const char*\tPerl_quadmath_format_single(const char* format);\n#define PERL_ARGS_ASSERT_QUADMATH_FORMAT_SINGLE\t\\\n\tassert(format)\n#endif\n#if defined(WIN32)\nPERL_CALLCONV_NO_RET void\twin32_croak_not_implemented(const char * fname)\n\t\t\t__attribute__noreturn__;\n#define PERL_ARGS_ASSERT_WIN32_CROAK_NOT_IMPLEMENTED\t\\\n\tassert(fname)\n\n#endif\n#if defined(WIN32) || defined(__SYMBIAN32__) || defined(VMS)\nPERL_CALLCONV int\tPerl_do_aspawn(pTHX_ SV* really, SV** mark, SV** sp);\n#define PERL_ARGS_ASSERT_DO_ASPAWN\t\\\n\tassert(mark); assert(sp)\nPERL_CALLCONV int\tPerl_do_spawn(pTHX_ char* cmd);\n#define PERL_ARGS_ASSERT_DO_SPAWN\t\\\n\tassert(cmd)\nPERL_CALLCONV int\tPerl_do_spawn_nowait(pTHX_ char* cmd);\n#define PERL_ARGS_ASSERT_DO_SPAWN_NOWAIT\t\\\n\tassert(cmd)\n#endif\n#if defined(_MSC_VER)\nPERL_CALLCONV int\tPerl_magic_regdatum_set(pTHX_ SV* sv, MAGIC* mg);\n#define PERL_ARGS_ASSERT_MAGIC_REGDATUM_SET\t\\\n\tassert(sv); assert(mg)\n#endif\n#ifdef PERL_CORE\n#  include \"pp_proto.h\"\n#endif\nEND_EXTERN_C\n\n/* ex: set ro: */\n", "/*    regcomp.c\n */\n\n/*\n * 'A fair jaw-cracker dwarf-language must be.'            --Samwise Gamgee\n *\n *     [p.285 of _The Lord of the Rings_, II/iii: \"The Ring Goes South\"]\n */\n\n/* This file contains functions for compiling a regular expression.  See\n * also regexec.c which funnily enough, contains functions for executing\n * a regular expression.\n *\n * This file is also copied at build time to ext/re/re_comp.c, where\n * it's built with -DPERL_EXT_RE_BUILD -DPERL_EXT_RE_DEBUG -DPERL_EXT.\n * This causes the main functions to be compiled under new names and with\n * debugging support added, which makes \"use re 'debug'\" work.\n */\n\n/* NOTE: this is derived from Henry Spencer's regexp code, and should not\n * confused with the original package (see point 3 below).  Thanks, Henry!\n */\n\n/* Additional note: this code is very heavily munged from Henry's version\n * in places.  In some spots I've traded clarity for efficiency, so don't\n * blame Henry for some of the lack of readability.\n */\n\n/* The names of the functions have been changed from regcomp and\n * regexec to pregcomp and pregexec in order to avoid conflicts\n * with the POSIX routines of the same names.\n*/\n\n#ifdef PERL_EXT_RE_BUILD\n#include \"re_top.h\"\n#endif\n\n/*\n * pregcomp and pregexec -- regsub and regerror are not used in perl\n *\n *\tCopyright (c) 1986 by University of Toronto.\n *\tWritten by Henry Spencer.  Not derived from licensed software.\n *\n *\tPermission is granted to anyone to use this software for any\n *\tpurpose on any computer system, and to redistribute it freely,\n *\tsubject to the following restrictions:\n *\n *\t1. The author is not responsible for the consequences of use of\n *\t\tthis software, no matter how awful, even if they arise\n *\t\tfrom defects in it.\n *\n *\t2. The origin of this software must not be misrepresented, either\n *\t\tby explicit claim or by omission.\n *\n *\t3. Altered versions must be plainly marked as such, and must not\n *\t\tbe misrepresented as being the original software.\n *\n *\n ****    Alterations to Henry's code are...\n ****\n ****    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n ****    by Larry Wall and others\n ****\n ****    You may distribute under the terms of either the GNU General Public\n ****    License or the Artistic License, as specified in the README file.\n\n *\n * Beware that some of this code is subtly aware of the way operator\n * precedence is structured in regular expressions.  Serious changes in\n * regular-expression syntax might require a total rethink.\n */\n#include \"EXTERN.h\"\n#define PERL_IN_REGCOMP_C\n#include \"perl.h\"\n\n#define REG_COMP_C\n#ifdef PERL_IN_XSUB_RE\n#  include \"re_comp.h\"\nEXTERN_C const struct regexp_engine my_reg_engine;\n#else\n#  include \"regcomp.h\"\n#endif\n\n#include \"dquote_inline.h\"\n#include \"invlist_inline.h\"\n#include \"unicode_constants.h\"\n\n#define HAS_NONLATIN1_FOLD_CLOSURE(i) \\\n _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)\n#define HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(i) \\\n _HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)\n#define IS_NON_FINAL_FOLD(c) _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)\n#define IS_IN_SOME_FOLD_L1(c) _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)\n\n#ifndef STATIC\n#define\tSTATIC\tstatic\n#endif\n\n/* this is a chain of data about sub patterns we are processing that\n   need to be handled separately/specially in study_chunk. Its so\n   we can simulate recursion without losing state.  */\nstruct scan_frame;\ntypedef struct scan_frame {\n    regnode *last_regnode;      /* last node to process in this frame */\n    regnode *next_regnode;      /* next node to process when last is reached */\n    U32 prev_recursed_depth;\n    I32 stopparen;              /* what stopparen do we use */\n    bool in_gosub;              /* this or an outer frame is for GOSUB */\n\n    struct scan_frame *this_prev_frame; /* this previous frame */\n    struct scan_frame *prev_frame;      /* previous frame */\n    struct scan_frame *next_frame;      /* next frame */\n} scan_frame;\n\n/* Certain characters are output as a sequence with the first being a\n * backslash. */\n#define isBACKSLASHED_PUNCT(c)  strchr(\"-[]\\\\^\", c)\n\n\nstruct RExC_state_t {\n    U32\t\tflags;\t\t\t/* RXf_* are we folding, multilining? */\n    U32\t\tpm_flags;\t\t/* PMf_* stuff from the calling PMOP */\n    char\t*precomp;\t\t/* uncompiled string. */\n    char\t*precomp_end;\t\t/* pointer to end of uncompiled string. */\n    REGEXP\t*rx_sv;\t\t\t/* The SV that is the regexp. */\n    regexp\t*rx;                    /* perl core regexp structure */\n    regexp_internal\t*rxi;           /* internal data for regexp object\n                                           pprivate field */\n    char\t*start;\t\t\t/* Start of input for compile */\n    char\t*end;\t\t\t/* End of input for compile */\n    char\t*parse;\t\t\t/* Input-scan pointer. */\n    char        *copy_start;            /* start of copy of input within\n                                           constructed parse string */\n    char        *save_copy_start;       /* Provides one level of saving\n                                           and restoring 'copy_start' */\n    char        *copy_start_in_input;   /* Position in input string\n                                           corresponding to copy_start */\n    SSize_t\twhilem_seen;\t\t/* number of WHILEM in this expr */\n    regnode\t*emit_start;\t\t/* Start of emitted-code area */\n    regnode_offset emit;\t\t/* Code-emit pointer */\n    I32\t\tnaughty;\t\t/* How bad is this pattern? */\n    I32\t\tsawback;\t\t/* Did we see \\1, ...? */\n    U32\t\tseen;\n    SSize_t\tsize;\t\t\t/* Number of regnode equivalents in\n                                           pattern */\n\n    /* position beyond 'precomp' of the warning message furthest away from\n     * 'precomp'.  During the parse, no warnings are raised for any problems\n     * earlier in the parse than this position.  This works if warnings are\n     * raised the first time a given spot is parsed, and if only one\n     * independent warning is raised for any given spot */\n    Size_t\tlatest_warn_offset;\n\n    I32         npar;                   /* Capture buffer count so far in the\n                                           parse, (OPEN) plus one. (\"par\" 0 is\n                                           the whole pattern)*/\n    I32         total_par;              /* During initial parse, is either 0,\n                                           or -1; the latter indicating a\n                                           reparse is needed.  After that pass,\n                                           it is what 'npar' became after the\n                                           pass.  Hence, it being > 0 indicates\n                                           we are in a reparse situation */\n    I32\t\tnestroot;\t\t/* root parens we are in - used by\n                                           accept */\n    I32\t\tseen_zerolen;\n    regnode_offset *open_parens;\t/* offsets to open parens */\n    regnode_offset *close_parens;\t/* offsets to close parens */\n    I32      parens_buf_size;           /* #slots malloced open/close_parens */\n    regnode     *end_op;                /* END node in program */\n    I32\t\tutf8;\t\t/* whether the pattern is utf8 or not */\n    I32\t\torig_utf8;\t/* whether the pattern was originally in utf8 */\n\t\t\t\t/* XXX use this for future optimisation of case\n\t\t\t\t * where pattern must be upgraded to utf8. */\n    I32\t\tuni_semantics;\t/* If a d charset modifier should use unicode\n\t\t\t\t   rules, even if the pattern is not in\n\t\t\t\t   utf8 */\n    HV\t\t*paren_names;\t\t/* Paren names */\n\n    regnode\t**recurse;\t\t/* Recurse regops */\n    I32         recurse_count;          /* Number of recurse regops we have generated */\n    U8          *study_chunk_recursed;  /* bitmap of which subs we have moved\n                                           through */\n    U32         study_chunk_recursed_bytes;  /* bytes in bitmap */\n    I32\t\tin_lookbehind;\n    I32\t\tcontains_locale;\n    I32\t\toverride_recoding;\n#ifdef EBCDIC\n    I32\t\trecode_x_to_native;\n#endif\n    I32\t\tin_multi_char_class;\n    struct reg_code_blocks *code_blocks;/* positions of literal (?{})\n\t\t\t\t\t    within pattern */\n    int\t\tcode_index;\t\t/* next code_blocks[] slot */\n    SSize_t     maxlen;                        /* mininum possible number of chars in string to match */\n    scan_frame *frame_head;\n    scan_frame *frame_last;\n    U32         frame_count;\n    AV         *warn_text;\n    HV         *unlexed_names;\n#ifdef ADD_TO_REGEXEC\n    char \t*starttry;\t\t/* -Dr: where regtry was called. */\n#define RExC_starttry\t(pRExC_state->starttry)\n#endif\n    SV\t\t*runtime_code_qr;\t/* qr with the runtime code blocks */\n#ifdef DEBUGGING\n    const char  *lastparse;\n    I32         lastnum;\n    AV          *paren_name_list;       /* idx -> name */\n    U32         study_chunk_recursed_count;\n    SV          *mysv1;\n    SV          *mysv2;\n\n#define RExC_lastparse\t(pRExC_state->lastparse)\n#define RExC_lastnum\t(pRExC_state->lastnum)\n#define RExC_paren_name_list    (pRExC_state->paren_name_list)\n#define RExC_study_chunk_recursed_count    (pRExC_state->study_chunk_recursed_count)\n#define RExC_mysv\t(pRExC_state->mysv1)\n#define RExC_mysv1\t(pRExC_state->mysv1)\n#define RExC_mysv2\t(pRExC_state->mysv2)\n\n#endif\n    bool        seen_d_op;\n    bool        strict;\n    bool        study_started;\n    bool        in_script_run;\n    bool        use_BRANCHJ;\n};\n\n#define RExC_flags\t(pRExC_state->flags)\n#define RExC_pm_flags\t(pRExC_state->pm_flags)\n#define RExC_precomp\t(pRExC_state->precomp)\n#define RExC_copy_start_in_input (pRExC_state->copy_start_in_input)\n#define RExC_copy_start_in_constructed  (pRExC_state->copy_start)\n#define RExC_save_copy_start_in_constructed  (pRExC_state->save_copy_start)\n#define RExC_precomp_end (pRExC_state->precomp_end)\n#define RExC_rx_sv\t(pRExC_state->rx_sv)\n#define RExC_rx\t\t(pRExC_state->rx)\n#define RExC_rxi\t(pRExC_state->rxi)\n#define RExC_start\t(pRExC_state->start)\n#define RExC_end\t(pRExC_state->end)\n#define RExC_parse\t(pRExC_state->parse)\n#define RExC_latest_warn_offset (pRExC_state->latest_warn_offset )\n#define RExC_whilem_seen\t(pRExC_state->whilem_seen)\n#define RExC_seen_d_op (pRExC_state->seen_d_op) /* Seen something that differs\n                                                   under /d from /u ? */\n\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n#  define RExC_offsets\t(RExC_rxi->u.offsets) /* I am not like the\n                                                         others */\n#endif\n#define RExC_emit\t(pRExC_state->emit)\n#define RExC_emit_start\t(pRExC_state->emit_start)\n#define RExC_sawback\t(pRExC_state->sawback)\n#define RExC_seen\t(pRExC_state->seen)\n#define RExC_size\t(pRExC_state->size)\n#define RExC_maxlen        (pRExC_state->maxlen)\n#define RExC_npar\t(pRExC_state->npar)\n#define RExC_total_parens\t(pRExC_state->total_par)\n#define RExC_parens_buf_size\t(pRExC_state->parens_buf_size)\n#define RExC_nestroot   (pRExC_state->nestroot)\n#define RExC_seen_zerolen\t(pRExC_state->seen_zerolen)\n#define RExC_utf8\t(pRExC_state->utf8)\n#define RExC_uni_semantics\t(pRExC_state->uni_semantics)\n#define RExC_orig_utf8\t(pRExC_state->orig_utf8)\n#define RExC_open_parens\t(pRExC_state->open_parens)\n#define RExC_close_parens\t(pRExC_state->close_parens)\n#define RExC_end_op\t(pRExC_state->end_op)\n#define RExC_paren_names\t(pRExC_state->paren_names)\n#define RExC_recurse\t(pRExC_state->recurse)\n#define RExC_recurse_count\t(pRExC_state->recurse_count)\n#define RExC_study_chunk_recursed        (pRExC_state->study_chunk_recursed)\n#define RExC_study_chunk_recursed_bytes  \\\n                                   (pRExC_state->study_chunk_recursed_bytes)\n#define RExC_in_lookbehind\t(pRExC_state->in_lookbehind)\n#define RExC_contains_locale\t(pRExC_state->contains_locale)\n#ifdef EBCDIC\n#   define RExC_recode_x_to_native (pRExC_state->recode_x_to_native)\n#endif\n#define RExC_in_multi_char_class (pRExC_state->in_multi_char_class)\n#define RExC_frame_head (pRExC_state->frame_head)\n#define RExC_frame_last (pRExC_state->frame_last)\n#define RExC_frame_count (pRExC_state->frame_count)\n#define RExC_strict (pRExC_state->strict)\n#define RExC_study_started      (pRExC_state->study_started)\n#define RExC_warn_text (pRExC_state->warn_text)\n#define RExC_in_script_run      (pRExC_state->in_script_run)\n#define RExC_use_BRANCHJ        (pRExC_state->use_BRANCHJ)\n#define RExC_unlexed_names (pRExC_state->unlexed_names)\n\n/* Heuristic check on the complexity of the pattern: if TOO_NAUGHTY, we set\n * a flag to disable back-off on the fixed/floating substrings - if it's\n * a high complexity pattern we assume the benefit of avoiding a full match\n * is worth the cost of checking for the substrings even if they rarely help.\n */\n#define RExC_naughty\t(pRExC_state->naughty)\n#define TOO_NAUGHTY (10)\n#define MARK_NAUGHTY(add) \\\n    if (RExC_naughty < TOO_NAUGHTY) \\\n        RExC_naughty += (add)\n#define MARK_NAUGHTY_EXP(exp, add) \\\n    if (RExC_naughty < TOO_NAUGHTY) \\\n        RExC_naughty += RExC_naughty / (exp) + (add)\n\n#define\tISMULT1(c)\t((c) == '*' || (c) == '+' || (c) == '?')\n#define\tISMULT2(s)\t((*s) == '*' || (*s) == '+' || (*s) == '?' || \\\n\t((*s) == '{' && regcurly(s)))\n\n/*\n * Flags to be passed up and down.\n */\n#define\tWORST\t\t0\t/* Worst case. */\n#define\tHASWIDTH\t0x01\t/* Known to not match null strings, could match\n                                   non-null ones. */\n\n/* Simple enough to be STAR/PLUS operand; in an EXACTish node must be a single\n * character.  (There needs to be a case: in the switch statement in regexec.c\n * for any node marked SIMPLE.)  Note that this is not the same thing as\n * REGNODE_SIMPLE */\n#define\tSIMPLE\t\t0x02\n#define\tSPSTART\t\t0x04\t/* Starts with * or + */\n#define POSTPONED\t0x08    /* (?1),(?&name), (??{...}) or similar */\n#define TRYAGAIN\t0x10\t/* Weeded out a declaration. */\n#define RESTART_PARSE   0x20    /* Need to redo the parse */\n#define NEED_UTF8       0x40    /* In conjunction with RESTART_PARSE, need to\n                                   calcuate sizes as UTF-8 */\n\n#define REG_NODE_NUM(x) ((x) ? (int)((x)-RExC_emit_start) : -1)\n\n/* whether trie related optimizations are enabled */\n#if PERL_ENABLE_EXTENDED_TRIE_OPTIMISATION\n#define TRIE_STUDY_OPT\n#define FULL_TRIE_STUDY\n#define TRIE_STCLASS\n#endif\n\n\n\n#define PBYTE(u8str,paren) ((U8*)(u8str))[(paren) >> 3]\n#define PBITVAL(paren) (1 << ((paren) & 7))\n#define PAREN_TEST(u8str,paren) ( PBYTE(u8str,paren) & PBITVAL(paren))\n#define PAREN_SET(u8str,paren) PBYTE(u8str,paren) |= PBITVAL(paren)\n#define PAREN_UNSET(u8str,paren) PBYTE(u8str,paren) &= (~PBITVAL(paren))\n\n#define REQUIRE_UTF8(flagp) STMT_START {                                   \\\n                                     if (!UTF) {                           \\\n                                         *flagp = RESTART_PARSE|NEED_UTF8; \\\n                                         return 0;                         \\\n                                     }                                     \\\n                             } STMT_END\n\n/* Change from /d into /u rules, and restart the parse.  RExC_uni_semantics is\n * a flag that indicates we need to override /d with /u as a result of\n * something in the pattern.  It should only be used in regards to calling\n * set_regex_charset() or get_regex_charse() */\n#define REQUIRE_UNI_RULES(flagp, restart_retval)                            \\\n    STMT_START {                                                            \\\n            if (DEPENDS_SEMANTICS) {                                        \\\n                set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);      \\\n                RExC_uni_semantics = 1;                                     \\\n                if (RExC_seen_d_op && LIKELY(! IN_PARENS_PASS)) {           \\\n                    /* No need to restart the parse if we haven't seen      \\\n                     * anything that differs between /u and /d, and no need \\\n                     * to restart immediately if we're going to reparse     \\\n                     * anyway to count parens */                            \\\n                    *flagp |= RESTART_PARSE;                                \\\n                    return restart_retval;                                  \\\n                }                                                           \\\n            }                                                               \\\n    } STMT_END\n\n#define REQUIRE_BRANCHJ(flagp, restart_retval)                              \\\n    STMT_START {                                                            \\\n                RExC_use_BRANCHJ = 1;                                       \\\n                *flagp |= RESTART_PARSE;                                    \\\n                return restart_retval;                                      \\\n    } STMT_END\n\n/* Until we have completed the parse, we leave RExC_total_parens at 0 or\n * less.  After that, it must always be positive, because the whole re is\n * considered to be surrounded by virtual parens.  Setting it to negative\n * indicates there is some construct that needs to know the actual number of\n * parens to be properly handled.  And that means an extra pass will be\n * required after we've counted them all */\n#define ALL_PARENS_COUNTED (RExC_total_parens > 0)\n#define REQUIRE_PARENS_PASS                                                 \\\n    STMT_START {  /* No-op if have completed a pass */                      \\\n                    if (! ALL_PARENS_COUNTED) RExC_total_parens = -1;       \\\n    } STMT_END\n#define IN_PARENS_PASS (RExC_total_parens < 0)\n\n\n/* This is used to return failure (zero) early from the calling function if\n * various flags in 'flags' are set.  Two flags always cause a return:\n * 'RESTART_PARSE' and 'NEED_UTF8'.   'extra' can be used to specify any\n * additional flags that should cause a return; 0 if none.  If the return will\n * be done, '*flagp' is first set to be all of the flags that caused the\n * return. */\n#define RETURN_FAIL_ON_RESTART_OR_FLAGS(flags,flagp,extra)                  \\\n    STMT_START {                                                            \\\n            if ((flags) & (RESTART_PARSE|NEED_UTF8|(extra))) {              \\\n                *(flagp) = (flags) & (RESTART_PARSE|NEED_UTF8|(extra));     \\\n                return 0;                                                   \\\n            }                                                               \\\n    } STMT_END\n\n#define MUST_RESTART(flags) ((flags) & (RESTART_PARSE))\n\n#define RETURN_FAIL_ON_RESTART(flags,flagp)                                 \\\n                        RETURN_FAIL_ON_RESTART_OR_FLAGS( flags, flagp, 0)\n#define RETURN_FAIL_ON_RESTART_FLAGP(flagp)                                 \\\n                                    if (MUST_RESTART(*(flagp))) return 0\n\n/* This converts the named class defined in regcomp.h to its equivalent class\n * number defined in handy.h. */\n#define namedclass_to_classnum(class)  ((int) ((class) / 2))\n#define classnum_to_namedclass(classnum)  ((classnum) * 2)\n\n#define _invlist_union_complement_2nd(a, b, output) \\\n                        _invlist_union_maybe_complement_2nd(a, b, TRUE, output)\n#define _invlist_intersection_complement_2nd(a, b, output) \\\n                 _invlist_intersection_maybe_complement_2nd(a, b, TRUE, output)\n\n/* About scan_data_t.\n\n  During optimisation we recurse through the regexp program performing\n  various inplace (keyhole style) optimisations. In addition study_chunk\n  and scan_commit populate this data structure with information about\n  what strings MUST appear in the pattern. We look for the longest\n  string that must appear at a fixed location, and we look for the\n  longest string that may appear at a floating location. So for instance\n  in the pattern:\n\n    /FOO[xX]A.*B[xX]BAR/\n\n  Both 'FOO' and 'A' are fixed strings. Both 'B' and 'BAR' are floating\n  strings (because they follow a .* construct). study_chunk will identify\n  both FOO and BAR as being the longest fixed and floating strings respectively.\n\n  The strings can be composites, for instance\n\n     /(f)(o)(o)/\n\n  will result in a composite fixed substring 'foo'.\n\n  For each string some basic information is maintained:\n\n  - min_offset\n    This is the position the string must appear at, or not before.\n    It also implicitly (when combined with minlenp) tells us how many\n    characters must match before the string we are searching for.\n    Likewise when combined with minlenp and the length of the string it\n    tells us how many characters must appear after the string we have\n    found.\n\n  - max_offset\n    Only used for floating strings. This is the rightmost point that\n    the string can appear at. If set to SSize_t_MAX it indicates that the\n    string can occur infinitely far to the right.\n    For fixed strings, it is equal to min_offset.\n\n  - minlenp\n    A pointer to the minimum number of characters of the pattern that the\n    string was found inside. This is important as in the case of positive\n    lookahead or positive lookbehind we can have multiple patterns\n    involved. Consider\n\n    /(?=FOO).*F/\n\n    The minimum length of the pattern overall is 3, the minimum length\n    of the lookahead part is 3, but the minimum length of the part that\n    will actually match is 1. So 'FOO's minimum length is 3, but the\n    minimum length for the F is 1. This is important as the minimum length\n    is used to determine offsets in front of and behind the string being\n    looked for.  Since strings can be composites this is the length of the\n    pattern at the time it was committed with a scan_commit. Note that\n    the length is calculated by study_chunk, so that the minimum lengths\n    are not known until the full pattern has been compiled, thus the\n    pointer to the value.\n\n  - lookbehind\n\n    In the case of lookbehind the string being searched for can be\n    offset past the start point of the final matching string.\n    If this value was just blithely removed from the min_offset it would\n    invalidate some of the calculations for how many chars must match\n    before or after (as they are derived from min_offset and minlen and\n    the length of the string being searched for).\n    When the final pattern is compiled and the data is moved from the\n    scan_data_t structure into the regexp structure the information\n    about lookbehind is factored in, with the information that would\n    have been lost precalculated in the end_shift field for the\n    associated string.\n\n  The fields pos_min and pos_delta are used to store the minimum offset\n  and the delta to the maximum offset at the current point in the pattern.\n\n*/\n\nstruct scan_data_substrs {\n    SV      *str;       /* longest substring found in pattern */\n    SSize_t min_offset; /* earliest point in string it can appear */\n    SSize_t max_offset; /* latest point in string it can appear */\n    SSize_t *minlenp;   /* pointer to the minlen relevant to the string */\n    SSize_t lookbehind; /* is the pos of the string modified by LB */\n    I32 flags;          /* per substring SF_* and SCF_* flags */\n};\n\ntypedef struct scan_data_t {\n    /*I32 len_min;      unused */\n    /*I32 len_delta;    unused */\n    SSize_t pos_min;\n    SSize_t pos_delta;\n    SV *last_found;\n    SSize_t last_end;\t    /* min value, <0 unless valid. */\n    SSize_t last_start_min;\n    SSize_t last_start_max;\n    U8      cur_is_floating; /* whether the last_* values should be set as\n                              * the next fixed (0) or floating (1)\n                              * substring */\n\n    /* [0] is longest fixed substring so far, [1] is longest float so far */\n    struct scan_data_substrs  substrs[2];\n\n    I32 flags;             /* common SF_* and SCF_* flags */\n    I32 whilem_c;\n    SSize_t *last_closep;\n    regnode_ssc *start_class;\n} scan_data_t;\n\n/*\n * Forward declarations for pregcomp()'s friends.\n */\n\nstatic const scan_data_t zero_scan_data = {\n    0, 0, NULL, 0, 0, 0, 0,\n    {\n        { NULL, 0, 0, 0, 0, 0 },\n        { NULL, 0, 0, 0, 0, 0 },\n    },\n    0, 0, NULL, NULL\n};\n\n/* study flags */\n\n#define SF_BEFORE_SEOL\t\t0x0001\n#define SF_BEFORE_MEOL\t\t0x0002\n#define SF_BEFORE_EOL\t\t(SF_BEFORE_SEOL|SF_BEFORE_MEOL)\n\n#define SF_IS_INF\t\t0x0040\n#define SF_HAS_PAR\t\t0x0080\n#define SF_IN_PAR\t\t0x0100\n#define SF_HAS_EVAL\t\t0x0200\n\n\n/* SCF_DO_SUBSTR is the flag that tells the regexp analyzer to track the\n * longest substring in the pattern. When it is not set the optimiser keeps\n * track of position, but does not keep track of the actual strings seen,\n *\n * So for instance /foo/ will be parsed with SCF_DO_SUBSTR being true, but\n * /foo/i will not.\n *\n * Similarly, /foo.*(blah|erm|huh).*fnorble/ will have \"foo\" and \"fnorble\"\n * parsed with SCF_DO_SUBSTR on, but while processing the (...) it will be\n * turned off because of the alternation (BRANCH). */\n#define SCF_DO_SUBSTR\t\t0x0400\n\n#define SCF_DO_STCLASS_AND\t0x0800\n#define SCF_DO_STCLASS_OR\t0x1000\n#define SCF_DO_STCLASS\t\t(SCF_DO_STCLASS_AND|SCF_DO_STCLASS_OR)\n#define SCF_WHILEM_VISITED_POS\t0x2000\n\n#define SCF_TRIE_RESTUDY        0x4000 /* Do restudy? */\n#define SCF_SEEN_ACCEPT         0x8000\n#define SCF_TRIE_DOING_RESTUDY 0x10000\n#define SCF_IN_DEFINE          0x20000\n\n\n\n\n#define UTF cBOOL(RExC_utf8)\n\n/* The enums for all these are ordered so things work out correctly */\n#define LOC (get_regex_charset(RExC_flags) == REGEX_LOCALE_CHARSET)\n#define DEPENDS_SEMANTICS (get_regex_charset(RExC_flags)                    \\\n                                                     == REGEX_DEPENDS_CHARSET)\n#define UNI_SEMANTICS (get_regex_charset(RExC_flags) == REGEX_UNICODE_CHARSET)\n#define AT_LEAST_UNI_SEMANTICS (get_regex_charset(RExC_flags)                \\\n                                                     >= REGEX_UNICODE_CHARSET)\n#define ASCII_RESTRICTED (get_regex_charset(RExC_flags)                      \\\n                                            == REGEX_ASCII_RESTRICTED_CHARSET)\n#define AT_LEAST_ASCII_RESTRICTED (get_regex_charset(RExC_flags)             \\\n                                            >= REGEX_ASCII_RESTRICTED_CHARSET)\n#define ASCII_FOLD_RESTRICTED (get_regex_charset(RExC_flags)                 \\\n                                        == REGEX_ASCII_MORE_RESTRICTED_CHARSET)\n\n#define FOLD cBOOL(RExC_flags & RXf_PMf_FOLD)\n\n/* For programs that want to be strictly Unicode compatible by dying if any\n * attempt is made to match a non-Unicode code point against a Unicode\n * property.  */\n#define ALWAYS_WARN_SUPER  ckDEAD(packWARN(WARN_NON_UNICODE))\n\n#define OOB_NAMEDCLASS\t\t-1\n\n/* There is no code point that is out-of-bounds, so this is problematic.  But\n * its only current use is to initialize a variable that is always set before\n * looked at. */\n#define OOB_UNICODE\t\t0xDEADBEEF\n\n#define CHR_SVLEN(sv) (UTF ? sv_len_utf8(sv) : SvCUR(sv))\n\n\n/* length of regex to show in messages that don't mark a position within */\n#define RegexLengthToShowInErrorMessages 127\n\n/*\n * If MARKER[12] are adjusted, be sure to adjust the constants at the top\n * of t/op/regmesg.t, the tests in t/op/re_tests, and those in\n * op/pragma/warn/regcomp.\n */\n#define MARKER1 \"<-- HERE\"    /* marker as it appears in the description */\n#define MARKER2 \" <-- HERE \"  /* marker as it appears within the regex */\n\n#define REPORT_LOCATION \" in regex; marked by \" MARKER1    \\\n                        \" in m/%\" UTF8f MARKER2 \"%\" UTF8f \"/\"\n\n/* The code in this file in places uses one level of recursion with parsing\n * rebased to an alternate string constructed by us in memory.  This can take\n * the form of something that is completely different from the input, or\n * something that uses the input as part of the alternate.  In the first case,\n * there should be no possibility of an error, as we are in complete control of\n * the alternate string.  But in the second case we don't completely control\n * the input portion, so there may be errors in that.  Here's an example:\n *      /[abc\\x{DF}def]/ui\n * is handled specially because \\x{df} folds to a sequence of more than one\n * character: 'ss'.  What is done is to create and parse an alternate string,\n * which looks like this:\n *      /(?:\\x{DF}|[abc\\x{DF}def])/ui\n * where it uses the input unchanged in the middle of something it constructs,\n * which is a branch for the DF outside the character class, and clustering\n * parens around the whole thing. (It knows enough to skip the DF inside the\n * class while in this substitute parse.) 'abc' and 'def' may have errors that\n * need to be reported.  The general situation looks like this:\n *\n *                                       |<------- identical ------>|\n *              sI                       tI               xI       eI\n * Input:       ---------------------------------------------------------------\n * Constructed:         ---------------------------------------------------\n *                      sC               tC               xC       eC     EC\n *                                       |<------- identical ------>|\n *\n * sI..eI   is the portion of the input pattern we are concerned with here.\n * sC..EC   is the constructed substitute parse string.\n *  sC..tC  is constructed by us\n *  tC..eC  is an exact duplicate of the portion of the input pattern tI..eI.\n *          In the diagram, these are vertically aligned.\n *  eC..EC  is also constructed by us.\n * xC       is the position in the substitute parse string where we found a\n *          problem.\n * xI       is the position in the original pattern corresponding to xC.\n *\n * We want to display a message showing the real input string.  Thus we need to\n * translate from xC to xI.  We know that xC >= tC, since the portion of the\n * string sC..tC has been constructed by us, and so shouldn't have errors.  We\n * get:\n *      xI = tI + (xC - tC)\n *\n * When the substitute parse is constructed, the code needs to set:\n *      RExC_start (sC)\n *      RExC_end (eC)\n *      RExC_copy_start_in_input  (tI)\n *      RExC_copy_start_in_constructed (tC)\n * and restore them when done.\n *\n * During normal processing of the input pattern, both\n * 'RExC_copy_start_in_input' and 'RExC_copy_start_in_constructed' are set to\n * sI, so that xC equals xI.\n */\n\n#define sI              RExC_precomp\n#define eI              RExC_precomp_end\n#define sC              RExC_start\n#define eC              RExC_end\n#define tI              RExC_copy_start_in_input\n#define tC              RExC_copy_start_in_constructed\n#define xI(xC)          (tI + (xC - tC))\n#define xI_offset(xC)   (xI(xC) - sI)\n\n#define REPORT_LOCATION_ARGS(xC)                                            \\\n    UTF8fARG(UTF,                                                           \\\n             (xI(xC) > eI) /* Don't run off end */                          \\\n              ? eI - sI   /* Length before the <--HERE */                   \\\n              : ((xI_offset(xC) >= 0)                                       \\\n                 ? xI_offset(xC)                                            \\\n                 : (Perl_croak(aTHX_ \"panic: %s: %d: negative offset: %\"    \\\n                                    IVdf \" trying to output message for \"   \\\n                                    \" pattern %.*s\",                        \\\n                                    __FILE__, __LINE__, (IV) xI_offset(xC), \\\n                                    ((int) (eC - sC)), sC), 0)),            \\\n             sI),         /* The input pattern printed up to the <--HERE */ \\\n    UTF8fARG(UTF,                                                           \\\n             (xI(xC) > eI) ? 0 : eI - xI(xC), /* Length after <--HERE */    \\\n             (xI(xC) > eI) ? eI : xI(xC))     /* pattern after <--HERE */\n\n/* Used to point after bad bytes for an error message, but avoid skipping\n * past a nul byte. */\n#define SKIP_IF_CHAR(s, e) (!*(s) ? 0 : UTF ? UTF8_SAFE_SKIP(s, e) : 1)\n\n/* Set up to clean up after our imminent demise */\n#define PREPARE_TO_DIE                                                      \\\n    STMT_START {\t\t\t\t\t                    \\\n        if (RExC_rx_sv)                                                     \\\n            SAVEFREESV(RExC_rx_sv);                                         \\\n        if (RExC_open_parens)                                               \\\n            SAVEFREEPV(RExC_open_parens);                                   \\\n        if (RExC_close_parens)                                              \\\n            SAVEFREEPV(RExC_close_parens);                                  \\\n    } STMT_END\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then calls Perl_croak with the given\n * arg. Show regex, up to a maximum length. If it's too long, chop and add\n * \"...\".\n */\n#define _FAIL(code) STMT_START {\t\t\t\t\t\\\n    const char *ellipses = \"\";\t\t\t\t\t\t\\\n    IV len = RExC_precomp_end - RExC_precomp;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    PREPARE_TO_DIE;\t\t\t\t\t\t        \\\n    if (len > RegexLengthToShowInErrorMessages) {\t\t\t\\\n\t/* chop 10 shorter than the max, to ensure meaning of \"...\" */\t\\\n\tlen = RegexLengthToShowInErrorMessages - 10;\t\t\t\\\n\tellipses = \"...\";\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n    code;                                                               \\\n} STMT_END\n\n#define\tFAIL(msg) _FAIL(\t\t\t    \\\n    Perl_croak(aTHX_ \"%s in regex m/%\" UTF8f \"%s/\",\t    \\\n\t    msg, UTF8fARG(UTF, len, RExC_precomp), ellipses))\n\n#define\tFAIL2(msg,arg) _FAIL(\t\t\t    \\\n    Perl_croak(aTHX_ msg \" in regex m/%\" UTF8f \"%s/\",\t    \\\n\t    arg, UTF8fARG(UTF, len, RExC_precomp), ellipses))\n\n/*\n * Simple_vFAIL -- like FAIL, but marks the current location in the scan\n */\n#define\tSimple_vFAIL(m) STMT_START {\t\t\t\t\t\\\n    Perl_croak(aTHX_ \"%s\" REPORT_LOCATION,\t\t\t\t\\\n\t    m, REPORT_LOCATION_ARGS(RExC_parse));\t                \\\n} STMT_END\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL()\n */\n#define\tvFAIL(m) STMT_START {\t\t\t\t\\\n    PREPARE_TO_DIE;                                     \\\n    Simple_vFAIL(m);\t\t\t\t\t\\\n} STMT_END\n\n/*\n * Like Simple_vFAIL(), but accepts two arguments.\n */\n#define\tSimple_vFAIL2(m,a1) STMT_START {\t\t\t\\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1,\t\t\\\n                      REPORT_LOCATION_ARGS(RExC_parse));\t\\\n} STMT_END\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL2().\n */\n#define\tvFAIL2(m,a1) STMT_START {\t\t\t\\\n    PREPARE_TO_DIE;                                     \\\n    Simple_vFAIL2(m, a1);\t\t\t\t\\\n} STMT_END\n\n\n/*\n * Like Simple_vFAIL(), but accepts three arguments.\n */\n#define\tSimple_vFAIL3(m, a1, a2) STMT_START {\t\t\t\\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2,\t\t\\\n\t    REPORT_LOCATION_ARGS(RExC_parse));\t                \\\n} STMT_END\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL3().\n */\n#define\tvFAIL3(m,a1,a2) STMT_START {\t\t\t\\\n    PREPARE_TO_DIE;                                     \\\n    Simple_vFAIL3(m, a1, a2);\t\t\t\t\\\n} STMT_END\n\n/*\n * Like Simple_vFAIL(), but accepts four arguments.\n */\n#define\tSimple_vFAIL4(m, a1, a2, a3) STMT_START {\t\t\\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2, a3,\t\\\n\t    REPORT_LOCATION_ARGS(RExC_parse));\t                \\\n} STMT_END\n\n#define\tvFAIL4(m,a1,a2,a3) STMT_START {\t\t\t\\\n    PREPARE_TO_DIE;                                     \\\n    Simple_vFAIL4(m, a1, a2, a3);\t\t\t\\\n} STMT_END\n\n/* A specialized version of vFAIL2 that works with UTF8f */\n#define vFAIL2utf8f(m, a1) STMT_START {             \\\n    PREPARE_TO_DIE;                                 \\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1,  \\\n            REPORT_LOCATION_ARGS(RExC_parse));      \\\n} STMT_END\n\n#define vFAIL3utf8f(m, a1, a2) STMT_START {             \\\n    PREPARE_TO_DIE;                                     \\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2,  \\\n            REPORT_LOCATION_ARGS(RExC_parse));          \\\n} STMT_END\n\n/* Setting this to NULL is a signal to not output warnings */\n#define TURN_OFF_WARNINGS_IN_SUBSTITUTE_PARSE                               \\\n    STMT_START {                                                            \\\n      RExC_save_copy_start_in_constructed  = RExC_copy_start_in_constructed;\\\n      RExC_copy_start_in_constructed = NULL;                                \\\n    } STMT_END\n#define RESTORE_WARNINGS                                                    \\\n    RExC_copy_start_in_constructed = RExC_save_copy_start_in_constructed\n\n/* Since a warning can be generated multiple times as the input is reparsed, we\n * output it the first time we come to that point in the parse, but suppress it\n * otherwise.  'RExC_copy_start_in_constructed' being NULL is a flag to not\n * generate any warnings */\n#define TO_OUTPUT_WARNINGS(loc)                                         \\\n  (   RExC_copy_start_in_constructed                                    \\\n   && ((xI(loc)) - RExC_precomp) > (Ptrdiff_t) RExC_latest_warn_offset)\n\n/* After we've emitted a warning, we save the position in the input so we don't\n * output it again */\n#define UPDATE_WARNINGS_LOC(loc)                                        \\\n    STMT_START {                                                        \\\n        if (TO_OUTPUT_WARNINGS(loc)) {                                  \\\n            RExC_latest_warn_offset = MAX(sI, MIN(eI, xI(loc)))         \\\n                                                       - RExC_precomp;  \\\n        }                                                               \\\n    } STMT_END\n\n/* 'warns' is the output of the packWARNx macro used in 'code' */\n#define _WARN_HELPER(loc, warns, code)                                  \\\n    STMT_START {                                                        \\\n        if (! RExC_copy_start_in_constructed) {                         \\\n            Perl_croak( aTHX_ \"panic! %s: %d: Tried to warn when none\"  \\\n                              \" expected at '%s'\",                      \\\n                              __FILE__, __LINE__, loc);                 \\\n        }                                                               \\\n        if (TO_OUTPUT_WARNINGS(loc)) {                                  \\\n            if (ckDEAD(warns))                                          \\\n                PREPARE_TO_DIE;                                         \\\n            code;                                                       \\\n            UPDATE_WARNINGS_LOC(loc);                                   \\\n        }                                                               \\\n    } STMT_END\n\n/* m is not necessarily a \"literal string\", in this macro */\n#define reg_warn_non_literal_string(loc, m)                             \\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                            \\\n                      Perl_warner(aTHX_ packWARN(WARN_REGEXP),          \\\n                                       \"%s\" REPORT_LOCATION,            \\\n                                  m, REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARNreg(loc,m) \t\t\t\t\t        \\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                            \\\n                      Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),       \\\n                                          m REPORT_LOCATION,\t        \\\n\t                                  REPORT_LOCATION_ARGS(loc)))\n\n#define\tvWARN(loc, m)           \t\t\t\t        \\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                            \\\n                      Perl_warner(aTHX_ packWARN(WARN_REGEXP),          \\\n                                       m REPORT_LOCATION,               \\\n                                       REPORT_LOCATION_ARGS(loc)))      \\\n\n#define\tvWARN_dep(loc, m)           \t\t\t\t        \\\n    _WARN_HELPER(loc, packWARN(WARN_DEPRECATED),                        \\\n                      Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),      \\\n                                       m REPORT_LOCATION,               \\\n\t                               REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARNdep(loc,m)            \t\t\t\t        \\\n    _WARN_HELPER(loc, packWARN(WARN_DEPRECATED),                        \\\n                      Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED), \\\n\t                                    m REPORT_LOCATION,          \\\n\t                                    REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARNregdep(loc,m)             \t\t\t\t    \\\n    _WARN_HELPER(loc, packWARN2(WARN_DEPRECATED, WARN_REGEXP),              \\\n                      Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED,     \\\n                                                      WARN_REGEXP),         \\\n\t                                     m REPORT_LOCATION,             \\\n\t                                     REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARN2reg_d(loc,m, a1)             \t\t\t\t    \\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                                \\\n                      Perl_ck_warner_d(aTHX_ packWARN(WARN_REGEXP),         \\\n\t                                    m REPORT_LOCATION,              \\\n\t                                    a1, REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARN2reg(loc, m, a1)                                              \\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                                \\\n                      Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),           \\\n                                          m REPORT_LOCATION,\t            \\\n                                          a1, REPORT_LOCATION_ARGS(loc)))\n\n#define\tvWARN3(loc, m, a1, a2)          \t\t\t\t    \\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                                \\\n                      Perl_warner(aTHX_ packWARN(WARN_REGEXP),              \\\n                                       m REPORT_LOCATION,                   \\\n\t                               a1, a2, REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARN3reg(loc, m, a1, a2)          \t\t\t\t    \\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                                \\\n                      Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),           \\\n                                          m REPORT_LOCATION,                \\\n\t                                  a1, a2,                           \\\n                                          REPORT_LOCATION_ARGS(loc)))\n\n#define\tvWARN4(loc, m, a1, a2, a3)          \t\t\t\t\\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                            \\\n                      Perl_warner(aTHX_ packWARN(WARN_REGEXP),          \\\n                                       m REPORT_LOCATION,               \\\n\t                               a1, a2, a3,                      \\\n                                       REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARN4reg(loc, m, a1, a2, a3)          \t\t\t\\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                            \\\n                      Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),       \\\n                                          m REPORT_LOCATION,            \\\n\t                                  a1, a2, a3,                   \\\n                                          REPORT_LOCATION_ARGS(loc)))\n\n#define\tvWARN5(loc, m, a1, a2, a3, a4)          \t\t\t\\\n    _WARN_HELPER(loc, packWARN(WARN_REGEXP),                            \\\n                      Perl_warner(aTHX_ packWARN(WARN_REGEXP),          \\\n                                       m REPORT_LOCATION,\t\t\\\n\t                               a1, a2, a3, a4,                  \\\n                                       REPORT_LOCATION_ARGS(loc)))\n\n#define\tckWARNexperimental(loc, class, m)                               \\\n    _WARN_HELPER(loc, packWARN(class),                                  \\\n                      Perl_ck_warner_d(aTHX_ packWARN(class),           \\\n                                            m REPORT_LOCATION,          \\\n                                            REPORT_LOCATION_ARGS(loc)))\n\n/* Convert between a pointer to a node and its offset from the beginning of the\n * program */\n#define REGNODE_p(offset)    (RExC_emit_start + (offset))\n#define REGNODE_OFFSET(node) ((node) - RExC_emit_start)\n\n/* Macros for recording node offsets.   20001227 mjd@plover.com\n * Nodes are numbered 1, 2, 3, 4.  Node #n's position is recorded in\n * element 2*n-1 of the array.  Element #2n holds the byte length node #n.\n * Element 0 holds the number n.\n * Position is 1 indexed.\n */\n#ifndef RE_TRACK_PATTERN_OFFSETS\n#define Set_Node_Offset_To_R(offset,byte)\n#define Set_Node_Offset(node,byte)\n#define Set_Cur_Node_Offset\n#define Set_Node_Length_To_R(node,len)\n#define Set_Node_Length(node,len)\n#define Set_Node_Cur_Length(node,start)\n#define Node_Offset(n)\n#define Node_Length(n)\n#define Set_Node_Offset_Length(node,offset,len)\n#define ProgLen(ri) ri->u.proglen\n#define SetProgLen(ri,x) ri->u.proglen = x\n#define Track_Code(code)\n#else\n#define ProgLen(ri) ri->u.offsets[0]\n#define SetProgLen(ri,x) ri->u.offsets[0] = x\n#define Set_Node_Offset_To_R(offset,byte) STMT_START {\t\t\t\\\n\tMJD_OFFSET_DEBUG((\"** (%d) offset of node %d is %d.\\n\",\t\t\\\n\t\t    __LINE__, (int)(offset), (int)(byte)));\t\t\\\n\tif((offset) < 0) {\t\t\t\t\t\t\\\n\t    Perl_croak(aTHX_ \"value of node is %d in Offset macro\",     \\\n                                         (int)(offset));                \\\n\t} else {\t\t\t\t\t\t\t\\\n            RExC_offsets[2*(offset)-1] = (byte);\t                \\\n\t}\t\t\t\t\t\t\t\t\\\n} STMT_END\n\n#define Set_Node_Offset(node,byte)                                      \\\n    Set_Node_Offset_To_R(REGNODE_OFFSET(node), (byte)-RExC_start)\n#define Set_Cur_Node_Offset Set_Node_Offset(RExC_emit, RExC_parse)\n\n#define Set_Node_Length_To_R(node,len) STMT_START {\t\t\t\\\n\tMJD_OFFSET_DEBUG((\"** (%d) size of node %d is %d.\\n\",\t\t\\\n\t\t__LINE__, (int)(node), (int)(len)));\t\t\t\\\n\tif((node) < 0) {\t\t\t\t\t\t\\\n\t    Perl_croak(aTHX_ \"value of node is %d in Length macro\",     \\\n                                         (int)(node));                  \\\n\t} else {\t\t\t\t\t\t\t\\\n\t    RExC_offsets[2*(node)] = (len);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} STMT_END\n\n#define Set_Node_Length(node,len) \\\n    Set_Node_Length_To_R(REGNODE_OFFSET(node), len)\n#define Set_Node_Cur_Length(node, start)                \\\n    Set_Node_Length(node, RExC_parse - start)\n\n/* Get offsets and lengths */\n#define Node_Offset(n) (RExC_offsets[2*(REGNODE_OFFSET(n))-1])\n#define Node_Length(n) (RExC_offsets[2*(REGNODE_OFFSET(n))])\n\n#define Set_Node_Offset_Length(node,offset,len) STMT_START {\t\\\n    Set_Node_Offset_To_R(REGNODE_OFFSET(node), (offset));\t\\\n    Set_Node_Length_To_R(REGNODE_OFFSET(node), (len));\t\\\n} STMT_END\n\n#define Track_Code(code) STMT_START { code } STMT_END\n#endif\n\n#if PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS\n#define EXPERIMENTAL_INPLACESCAN\n#endif /*PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS*/\n\n#ifdef DEBUGGING\nint\nPerl_re_printf(pTHX_ const char *fmt, ...)\n{\n    va_list ap;\n    int result;\n    PerlIO *f= Perl_debug_log;\n    PERL_ARGS_ASSERT_RE_PRINTF;\n    va_start(ap, fmt);\n    result = PerlIO_vprintf(f, fmt, ap);\n    va_end(ap);\n    return result;\n}\n\nint\nPerl_re_indentf(pTHX_ const char *fmt, U32 depth, ...)\n{\n    va_list ap;\n    int result;\n    PerlIO *f= Perl_debug_log;\n    PERL_ARGS_ASSERT_RE_INDENTF;\n    va_start(ap, depth);\n    PerlIO_printf(f, \"%*s\", ( (int)depth % 20 ) * 2, \"\");\n    result = PerlIO_vprintf(f, fmt, ap);\n    va_end(ap);\n    return result;\n}\n#endif /* DEBUGGING */\n\n#define DEBUG_RExC_seen()                                                   \\\n        DEBUG_OPTIMISE_MORE_r({                                             \\\n            Perl_re_printf( aTHX_ \"RExC_seen: \");                           \\\n                                                                            \\\n            if (RExC_seen & REG_ZERO_LEN_SEEN)                              \\\n                Perl_re_printf( aTHX_ \"REG_ZERO_LEN_SEEN \");                \\\n                                                                            \\\n            if (RExC_seen & REG_LOOKBEHIND_SEEN)                            \\\n                Perl_re_printf( aTHX_ \"REG_LOOKBEHIND_SEEN \");              \\\n                                                                            \\\n            if (RExC_seen & REG_GPOS_SEEN)                                  \\\n                Perl_re_printf( aTHX_ \"REG_GPOS_SEEN \");                    \\\n                                                                            \\\n            if (RExC_seen & REG_RECURSE_SEEN)                               \\\n                Perl_re_printf( aTHX_ \"REG_RECURSE_SEEN \");                 \\\n                                                                            \\\n            if (RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)                    \\\n                Perl_re_printf( aTHX_ \"REG_TOP_LEVEL_BRANCHES_SEEN \");      \\\n                                                                            \\\n            if (RExC_seen & REG_VERBARG_SEEN)                               \\\n                Perl_re_printf( aTHX_ \"REG_VERBARG_SEEN \");                 \\\n                                                                            \\\n            if (RExC_seen & REG_CUTGROUP_SEEN)                              \\\n                Perl_re_printf( aTHX_ \"REG_CUTGROUP_SEEN \");                \\\n                                                                            \\\n            if (RExC_seen & REG_RUN_ON_COMMENT_SEEN)                        \\\n                Perl_re_printf( aTHX_ \"REG_RUN_ON_COMMENT_SEEN \");          \\\n                                                                            \\\n            if (RExC_seen & REG_UNFOLDED_MULTI_SEEN)                        \\\n                Perl_re_printf( aTHX_ \"REG_UNFOLDED_MULTI_SEEN \");          \\\n                                                                            \\\n            if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)                  \\\n                Perl_re_printf( aTHX_ \"REG_UNBOUNDED_QUANTIFIER_SEEN \");    \\\n                                                                            \\\n            Perl_re_printf( aTHX_ \"\\n\");                                    \\\n        });\n\n#define DEBUG_SHOW_STUDY_FLAG(flags,flag) \\\n  if ((flags) & flag) Perl_re_printf( aTHX_  \"%s \", #flag)\n\n\n#ifdef DEBUGGING\nstatic void\nS_debug_show_study_flags(pTHX_ U32 flags, const char *open_str,\n                                    const char *close_str)\n{\n    if (!flags)\n        return;\n\n    Perl_re_printf( aTHX_  \"%s\", open_str);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_BEFORE_SEOL);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_BEFORE_MEOL);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_IS_INF);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_HAS_PAR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_IN_PAR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_HAS_EVAL);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_SUBSTR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_STCLASS_AND);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_STCLASS_OR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_STCLASS);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_WHILEM_VISITED_POS);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_TRIE_RESTUDY);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_SEEN_ACCEPT);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_TRIE_DOING_RESTUDY);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_IN_DEFINE);\n    Perl_re_printf( aTHX_  \"%s\", close_str);\n}\n\n\nstatic void\nS_debug_studydata(pTHX_ const char *where, scan_data_t *data,\n                    U32 depth, int is_inf)\n{\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    DEBUG_OPTIMISE_MORE_r({\n        if (!data)\n            return;\n        Perl_re_indentf(aTHX_  \"%s: Pos:%\" IVdf \"/%\" IVdf \" Flags: 0x%\" UVXf,\n            depth,\n            where,\n            (IV)data->pos_min,\n            (IV)data->pos_delta,\n            (UV)data->flags\n        );\n\n        S_debug_show_study_flags(aTHX_ data->flags,\" [\",\"]\");\n\n        Perl_re_printf( aTHX_\n            \" Whilem_c: %\" IVdf \" Lcp: %\" IVdf \" %s\",\n            (IV)data->whilem_c,\n            (IV)(data->last_closep ? *((data)->last_closep) : -1),\n            is_inf ? \"INF \" : \"\"\n        );\n\n        if (data->last_found) {\n            int i;\n            Perl_re_printf(aTHX_\n                \"Last:'%s' %\" IVdf \":%\" IVdf \"/%\" IVdf,\n                    SvPVX_const(data->last_found),\n                    (IV)data->last_end,\n                    (IV)data->last_start_min,\n                    (IV)data->last_start_max\n            );\n\n            for (i = 0; i < 2; i++) {\n                Perl_re_printf(aTHX_\n                    \" %s%s: '%s' @ %\" IVdf \"/%\" IVdf,\n                    data->cur_is_floating == i ? \"*\" : \"\",\n                    i ? \"Float\" : \"Fixed\",\n                    SvPVX_const(data->substrs[i].str),\n                    (IV)data->substrs[i].min_offset,\n                    (IV)data->substrs[i].max_offset\n                );\n                S_debug_show_study_flags(aTHX_ data->substrs[i].flags,\" [\",\"]\");\n            }\n        }\n\n        Perl_re_printf( aTHX_ \"\\n\");\n    });\n}\n\n\nstatic void\nS_debug_peep(pTHX_ const char *str, const RExC_state_t *pRExC_state,\n                regnode *scan, U32 depth, U32 flags)\n{\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    DEBUG_OPTIMISE_r({\n        regnode *Next;\n\n        if (!scan)\n            return;\n        Next = regnext(scan);\n        regprop(RExC_rx, RExC_mysv, scan, NULL, pRExC_state);\n        Perl_re_indentf( aTHX_   \"%s>%3d: %s (%d)\",\n            depth,\n            str,\n            REG_NODE_NUM(scan), SvPV_nolen_const(RExC_mysv),\n            Next ? (REG_NODE_NUM(Next)) : 0 );\n        S_debug_show_study_flags(aTHX_ flags,\" [ \",\"]\");\n        Perl_re_printf( aTHX_  \"\\n\");\n   });\n}\n\n\n#  define DEBUG_STUDYDATA(where, data, depth, is_inf) \\\n                    S_debug_studydata(aTHX_ where, data, depth, is_inf)\n\n#  define DEBUG_PEEP(str, scan, depth, flags)   \\\n                    S_debug_peep(aTHX_ str, pRExC_state, scan, depth, flags)\n\n#else\n#  define DEBUG_STUDYDATA(where, data, depth, is_inf) NOOP\n#  define DEBUG_PEEP(str, scan, depth, flags)         NOOP\n#endif\n\n\n/* =========================================================\n * BEGIN edit_distance stuff.\n *\n * This calculates how many single character changes of any type are needed to\n * transform a string into another one.  It is taken from version 3.1 of\n *\n * https://metacpan.org/pod/Text::Levenshtein::Damerau::XS\n */\n\n/* Our unsorted dictionary linked list.   */\n/* Note we use UVs, not chars. */\n\nstruct dictionary{\n  UV key;\n  UV value;\n  struct dictionary* next;\n};\ntypedef struct dictionary item;\n\n\nPERL_STATIC_INLINE item*\npush(UV key, item* curr)\n{\n    item* head;\n    Newx(head, 1, item);\n    head->key = key;\n    head->value = 0;\n    head->next = curr;\n    return head;\n}\n\n\nPERL_STATIC_INLINE item*\nfind(item* head, UV key)\n{\n    item* iterator = head;\n    while (iterator){\n        if (iterator->key == key){\n            return iterator;\n        }\n        iterator = iterator->next;\n    }\n\n    return NULL;\n}\n\nPERL_STATIC_INLINE item*\nuniquePush(item* head, UV key)\n{\n    item* iterator = head;\n\n    while (iterator){\n        if (iterator->key == key) {\n            return head;\n        }\n        iterator = iterator->next;\n    }\n\n    return push(key, head);\n}\n\nPERL_STATIC_INLINE void\ndict_free(item* head)\n{\n    item* iterator = head;\n\n    while (iterator) {\n        item* temp = iterator;\n        iterator = iterator->next;\n        Safefree(temp);\n    }\n\n    head = NULL;\n}\n\n/* End of Dictionary Stuff */\n\n/* All calculations/work are done here */\nSTATIC int\nS_edit_distance(const UV* src,\n                const UV* tgt,\n                const STRLEN x,             /* length of src[] */\n                const STRLEN y,             /* length of tgt[] */\n                const SSize_t maxDistance\n)\n{\n    item *head = NULL;\n    UV swapCount, swapScore, targetCharCount, i, j;\n    UV *scores;\n    UV score_ceil = x + y;\n\n    PERL_ARGS_ASSERT_EDIT_DISTANCE;\n\n    /* intialize matrix start values */\n    Newx(scores, ( (x + 2) * (y + 2)), UV);\n    scores[0] = score_ceil;\n    scores[1 * (y + 2) + 0] = score_ceil;\n    scores[0 * (y + 2) + 1] = score_ceil;\n    scores[1 * (y + 2) + 1] = 0;\n    head = uniquePush(uniquePush(head, src[0]), tgt[0]);\n\n    /* work loops    */\n    /* i = src index */\n    /* j = tgt index */\n    for (i=1;i<=x;i++) {\n        if (i < x)\n            head = uniquePush(head, src[i]);\n        scores[(i+1) * (y + 2) + 1] = i;\n        scores[(i+1) * (y + 2) + 0] = score_ceil;\n        swapCount = 0;\n\n        for (j=1;j<=y;j++) {\n            if (i == 1) {\n                if(j < y)\n                head = uniquePush(head, tgt[j]);\n                scores[1 * (y + 2) + (j + 1)] = j;\n                scores[0 * (y + 2) + (j + 1)] = score_ceil;\n            }\n\n            targetCharCount = find(head, tgt[j-1])->value;\n            swapScore = scores[targetCharCount * (y + 2) + swapCount] + i - targetCharCount - 1 + j - swapCount;\n\n            if (src[i-1] != tgt[j-1]){\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(swapScore,(MIN(scores[i * (y + 2) + j], MIN(scores[(i+1) * (y + 2) + j], scores[i * (y + 2) + (j + 1)])) + 1));\n            }\n            else {\n                swapCount = j;\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(scores[i * (y + 2) + j], swapScore);\n            }\n        }\n\n        find(head, src[i-1])->value = i;\n    }\n\n    {\n        IV score = scores[(x+1) * (y + 2) + (y + 1)];\n        dict_free(head);\n        Safefree(scores);\n        return (maxDistance != 0 && maxDistance < score)?(-1):score;\n    }\n}\n\n/* END of edit_distance() stuff\n * ========================================================= */\n\n/* is c a control character for which we have a mnemonic? */\n#define isMNEMONIC_CNTRL(c) _IS_MNEMONIC_CNTRL_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)\n\nSTATIC const char *\nS_cntrl_to_mnemonic(const U8 c)\n{\n    /* Returns the mnemonic string that represents character 'c', if one\n     * exists; NULL otherwise.  The only ones that exist for the purposes of\n     * this routine are a few control characters */\n\n    switch (c) {\n        case '\\a':       return \"\\\\a\";\n        case '\\b':       return \"\\\\b\";\n        case ESC_NATIVE: return \"\\\\e\";\n        case '\\f':       return \"\\\\f\";\n        case '\\n':       return \"\\\\n\";\n        case '\\r':       return \"\\\\r\";\n        case '\\t':       return \"\\\\t\";\n    }\n\n    return NULL;\n}\n\n/* Mark that we cannot extend a found fixed substring at this point.\n   Update the longest found anchored substring or the longest found\n   floating substrings if needed. */\n\nSTATIC void\nS_scan_commit(pTHX_ const RExC_state_t *pRExC_state, scan_data_t *data,\n                    SSize_t *minlenp, int is_inf)\n{\n    const STRLEN l = CHR_SVLEN(data->last_found);\n    SV * const longest_sv = data->substrs[data->cur_is_floating].str;\n    const STRLEN old_l = CHR_SVLEN(longest_sv);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_SCAN_COMMIT;\n\n    if ((l >= old_l) && ((l > old_l) || (data->flags & SF_BEFORE_EOL))) {\n        const U8 i = data->cur_is_floating;\n\tSvSetMagicSV(longest_sv, data->last_found);\n        data->substrs[i].min_offset = l ? data->last_start_min : data->pos_min;\n\n\tif (!i) /* fixed */\n\t    data->substrs[0].max_offset = data->substrs[0].min_offset;\n\telse { /* float */\n\t    data->substrs[1].max_offset = (l\n                          ? data->last_start_max\n                          : (data->pos_delta > SSize_t_MAX - data->pos_min\n\t\t\t\t\t ? SSize_t_MAX\n\t\t\t\t\t : data->pos_min + data->pos_delta));\n\t    if (is_inf\n\t\t || (STRLEN)data->substrs[1].max_offset > (STRLEN)SSize_t_MAX)\n\t\tdata->substrs[1].max_offset = SSize_t_MAX;\n        }\n\n        if (data->flags & SF_BEFORE_EOL)\n            data->substrs[i].flags |= (data->flags & SF_BEFORE_EOL);\n        else\n            data->substrs[i].flags &= ~SF_BEFORE_EOL;\n        data->substrs[i].minlenp = minlenp;\n        data->substrs[i].lookbehind = 0;\n    }\n\n    SvCUR_set(data->last_found, 0);\n    {\n\tSV * const sv = data->last_found;\n\tif (SvUTF8(sv) && SvMAGICAL(sv)) {\n\t    MAGIC * const mg = mg_find(sv, PERL_MAGIC_utf8);\n\t    if (mg)\n\t\tmg->mg_len = 0;\n\t}\n    }\n    data->last_end = -1;\n    data->flags &= ~SF_BEFORE_EOL;\n    DEBUG_STUDYDATA(\"commit\", data, 0, is_inf);\n}\n\n/* An SSC is just a regnode_charclass_posix with an extra field: the inversion\n * list that describes which code points it matches */\n\nSTATIC void\nS_ssc_anything(pTHX_ regnode_ssc *ssc)\n{\n    /* Set the SSC 'ssc' to match an empty string or any code point */\n\n    PERL_ARGS_ASSERT_SSC_ANYTHING;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* mortalize so won't leak */\n    ssc->invlist = sv_2mortal(_add_range_to_invlist(NULL, 0, UV_MAX));\n    ANYOF_FLAGS(ssc) |= SSC_MATCHES_EMPTY_STRING;  /* Plus matches empty */\n}\n\nSTATIC int\nS_ssc_is_anything(const regnode_ssc *ssc)\n{\n    /* Returns TRUE if the SSC 'ssc' can match the empty string and any code\n     * point; FALSE otherwise.  Thus, this is used to see if using 'ssc' buys\n     * us anything: if the function returns TRUE, 'ssc' hasn't been restricted\n     * in any way, so there's no point in using it */\n\n    UV start, end;\n    bool ret;\n\n    PERL_ARGS_ASSERT_SSC_IS_ANYTHING;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    if (! (ANYOF_FLAGS(ssc) & SSC_MATCHES_EMPTY_STRING)) {\n        return FALSE;\n    }\n\n    /* See if the list consists solely of the range 0 - Infinity */\n    invlist_iterinit(ssc->invlist);\n    ret = invlist_iternext(ssc->invlist, &start, &end)\n          && start == 0\n          && end == UV_MAX;\n\n    invlist_iterfinish(ssc->invlist);\n\n    if (ret) {\n        return TRUE;\n    }\n\n    /* If e.g., both \\w and \\W are set, matches everything */\n    if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n        int i;\n        for (i = 0; i < ANYOF_POSIXL_MAX; i += 2) {\n            if (ANYOF_POSIXL_TEST(ssc, i) && ANYOF_POSIXL_TEST(ssc, i+1)) {\n                return TRUE;\n            }\n        }\n    }\n\n    return FALSE;\n}\n\nSTATIC void\nS_ssc_init(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc)\n{\n    /* Initializes the SSC 'ssc'.  This includes setting it to match an empty\n     * string, any code point, or any posix class under locale */\n\n    PERL_ARGS_ASSERT_SSC_INIT;\n\n    Zero(ssc, 1, regnode_ssc);\n    set_ANYOF_SYNTHETIC(ssc);\n    ARG_SET(ssc, ANYOF_ONLY_HAS_BITMAP);\n    ssc_anything(ssc);\n\n    /* If any portion of the regex is to operate under locale rules that aren't\n     * fully known at compile time, initialization includes it.  The reason\n     * this isn't done for all regexes is that the optimizer was written under\n     * the assumption that locale was all-or-nothing.  Given the complexity and\n     * lack of documentation in the optimizer, and that there are inadequate\n     * test cases for locale, many parts of it may not work properly, it is\n     * safest to avoid locale unless necessary. */\n    if (RExC_contains_locale) {\n\tANYOF_POSIXL_SETALL(ssc);\n    }\n    else {\n\tANYOF_POSIXL_ZERO(ssc);\n    }\n}\n\nSTATIC int\nS_ssc_is_cp_posixl_init(const RExC_state_t *pRExC_state,\n                        const regnode_ssc *ssc)\n{\n    /* Returns TRUE if the SSC 'ssc' is in its initial state with regard only\n     * to the list of code points matched, and locale posix classes; hence does\n     * not check its flags) */\n\n    UV start, end;\n    bool ret;\n\n    PERL_ARGS_ASSERT_SSC_IS_CP_POSIXL_INIT;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    invlist_iterinit(ssc->invlist);\n    ret = invlist_iternext(ssc->invlist, &start, &end)\n          && start == 0\n          && end == UV_MAX;\n\n    invlist_iterfinish(ssc->invlist);\n\n    if (! ret) {\n        return FALSE;\n    }\n\n    if (RExC_contains_locale && ! ANYOF_POSIXL_SSC_TEST_ALL_SET(ssc)) {\n        return FALSE;\n    }\n\n    return TRUE;\n}\n\n#define INVLIST_INDEX 0\n#define ONLY_LOCALE_MATCHES_INDEX 1\n#define DEFERRED_USER_DEFINED_INDEX 2\n\nSTATIC SV*\nS_get_ANYOF_cp_list_for_ssc(pTHX_ const RExC_state_t *pRExC_state,\n                               const regnode_charclass* const node)\n{\n    /* Returns a mortal inversion list defining which code points are matched\n     * by 'node', which is of type ANYOF.  Handles complementing the result if\n     * appropriate.  If some code points aren't knowable at this time, the\n     * returned list must, and will, contain every code point that is a\n     * possibility. */\n\n    dVAR;\n    SV* invlist = NULL;\n    SV* only_utf8_locale_invlist = NULL;\n    unsigned int i;\n    const U32 n = ARG(node);\n    bool new_node_has_latin1 = FALSE;\n    const U8 flags = OP(node) == ANYOFH ? 0 : ANYOF_FLAGS(node);\n\n    PERL_ARGS_ASSERT_GET_ANYOF_CP_LIST_FOR_SSC;\n\n    /* Look at the data structure created by S_set_ANYOF_arg() */\n    if (n != ANYOF_ONLY_HAS_BITMAP) {\n        SV * const rv = MUTABLE_SV(RExC_rxi->data->data[n]);\n        AV * const av = MUTABLE_AV(SvRV(rv));\n        SV **const ary = AvARRAY(av);\n        assert(RExC_rxi->data->what[n] == 's');\n\n        if (av_tindex_skip_len_mg(av) >= DEFERRED_USER_DEFINED_INDEX) {\n\n            /* Here there are things that won't be known until runtime -- we\n             * have to assume it could be anything */\n            invlist = sv_2mortal(_new_invlist(1));\n            return _add_range_to_invlist(invlist, 0, UV_MAX);\n        }\n        else if (ary[INVLIST_INDEX]) {\n\n            /* Use the node's inversion list */\n            invlist = sv_2mortal(invlist_clone(ary[INVLIST_INDEX], NULL));\n        }\n\n        /* Get the code points valid only under UTF-8 locales */\n        if (   (flags & ANYOFL_FOLD)\n            &&  av_tindex_skip_len_mg(av) >= ONLY_LOCALE_MATCHES_INDEX)\n        {\n            only_utf8_locale_invlist = ary[ONLY_LOCALE_MATCHES_INDEX];\n        }\n    }\n\n    if (! invlist) {\n        invlist = sv_2mortal(_new_invlist(0));\n    }\n\n    /* An ANYOF node contains a bitmap for the first NUM_ANYOF_CODE_POINTS\n     * code points, and an inversion list for the others, but if there are code\n     * points that should match only conditionally on the target string being\n     * UTF-8, those are placed in the inversion list, and not the bitmap.\n     * Since there are circumstances under which they could match, they are\n     * included in the SSC.  But if the ANYOF node is to be inverted, we have\n     * to exclude them here, so that when we invert below, the end result\n     * actually does include them.  (Think about \"\\xe0\" =~ /[^\\xc0]/di;).  We\n     * have to do this here before we add the unconditionally matched code\n     * points */\n    if (flags & ANYOF_INVERT) {\n        _invlist_intersection_complement_2nd(invlist,\n                                             PL_UpperLatin1,\n                                             &invlist);\n    }\n\n    /* Add in the points from the bit map */\n    if (OP(node) != ANYOFH) {\n        for (i = 0; i < NUM_ANYOF_CODE_POINTS; i++) {\n            if (ANYOF_BITMAP_TEST(node, i)) {\n                unsigned int start = i++;\n\n                for (;    i < NUM_ANYOF_CODE_POINTS\n                       && ANYOF_BITMAP_TEST(node, i); ++i)\n                {\n                    /* empty */\n                }\n                invlist = _add_range_to_invlist(invlist, start, i-1);\n                new_node_has_latin1 = TRUE;\n            }\n        }\n    }\n\n    /* If this can match all upper Latin1 code points, have to add them\n     * as well.  But don't add them if inverting, as when that gets done below,\n     * it would exclude all these characters, including the ones it shouldn't\n     * that were added just above */\n    if (! (flags & ANYOF_INVERT) && OP(node) == ANYOFD\n        && (flags & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER))\n    {\n        _invlist_union(invlist, PL_UpperLatin1, &invlist);\n    }\n\n    /* Similarly for these */\n    if (flags & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {\n        _invlist_union_complement_2nd(invlist, PL_InBitmap, &invlist);\n    }\n\n    if (flags & ANYOF_INVERT) {\n        _invlist_invert(invlist);\n    }\n    else if (flags & ANYOFL_FOLD) {\n        if (new_node_has_latin1) {\n\n            /* Under /li, any 0-255 could fold to any other 0-255, depending on\n             * the locale.  We can skip this if there are no 0-255 at all. */\n            _invlist_union(invlist, PL_Latin1, &invlist);\n\n            invlist = add_cp_to_invlist(invlist, LATIN_SMALL_LETTER_DOTLESS_I);\n            invlist = add_cp_to_invlist(invlist, LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE);\n        }\n        else {\n            if (_invlist_contains_cp(invlist, LATIN_SMALL_LETTER_DOTLESS_I)) {\n                invlist = add_cp_to_invlist(invlist, 'I');\n            }\n            if (_invlist_contains_cp(invlist,\n                                        LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE))\n            {\n                invlist = add_cp_to_invlist(invlist, 'i');\n            }\n        }\n    }\n\n    /* Similarly add the UTF-8 locale possible matches.  These have to be\n     * deferred until after the non-UTF-8 locale ones are taken care of just\n     * above, or it leads to wrong results under ANYOF_INVERT */\n    if (only_utf8_locale_invlist) {\n        _invlist_union_maybe_complement_2nd(invlist,\n                                            only_utf8_locale_invlist,\n                                            flags & ANYOF_INVERT,\n                                            &invlist);\n    }\n\n    return invlist;\n}\n\n/* These two functions currently do the exact same thing */\n#define ssc_init_zero\t\tssc_init\n\n#define ssc_add_cp(ssc, cp)   ssc_add_range((ssc), (cp), (cp))\n#define ssc_match_all_cp(ssc) ssc_add_range(ssc, 0, UV_MAX)\n\n/* 'AND' a given class with another one.  Can create false positives.  'ssc'\n * should not be inverted.  'and_with->flags & ANYOF_MATCHES_POSIXL' should be\n * 0 if 'and_with' is a regnode_charclass instead of a regnode_ssc. */\n\nSTATIC void\nS_ssc_and(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc,\n                const regnode_charclass *and_with)\n{\n    /* Accumulate into SSC 'ssc' its 'AND' with 'and_with', which is either\n     * another SSC or a regular ANYOF class.  Can create false positives. */\n\n    SV* anded_cp_list;\n    U8  and_with_flags = (OP(and_with) == ANYOFH) ? 0 : ANYOF_FLAGS(and_with);\n    U8  anded_flags;\n\n    PERL_ARGS_ASSERT_SSC_AND;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* 'and_with' is used as-is if it too is an SSC; otherwise have to extract\n     * the code point inversion list and just the relevant flags */\n    if (is_ANYOF_SYNTHETIC(and_with)) {\n        anded_cp_list = ((regnode_ssc *)and_with)->invlist;\n        anded_flags = and_with_flags;\n\n        /* XXX This is a kludge around what appears to be deficiencies in the\n         * optimizer.  If we make S_ssc_anything() add in the WARN_SUPER flag,\n         * there are paths through the optimizer where it doesn't get weeded\n         * out when it should.  And if we don't make some extra provision for\n         * it like the code just below, it doesn't get added when it should.\n         * This solution is to add it only when AND'ing, which is here, and\n         * only when what is being AND'ed is the pristine, original node\n         * matching anything.  Thus it is like adding it to ssc_anything() but\n         * only when the result is to be AND'ed.  Probably the same solution\n         * could be adopted for the same problem we have with /l matching,\n         * which is solved differently in S_ssc_init(), and that would lead to\n         * fewer false positives than that solution has.  But if this solution\n         * creates bugs, the consequences are only that a warning isn't raised\n         * that should be; while the consequences for having /l bugs is\n         * incorrect matches */\n        if (ssc_is_anything((regnode_ssc *)and_with)) {\n            anded_flags |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;\n        }\n    }\n    else {\n        anded_cp_list = get_ANYOF_cp_list_for_ssc(pRExC_state, and_with);\n        if (OP(and_with) == ANYOFD) {\n            anded_flags = and_with_flags & ANYOF_COMMON_FLAGS;\n        }\n        else {\n            anded_flags = and_with_flags\n            &( ANYOF_COMMON_FLAGS\n              |ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER\n              |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP);\n            if (ANYOFL_UTF8_LOCALE_REQD(and_with_flags)) {\n                anded_flags &=\n                    ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n            }\n        }\n    }\n\n    ANYOF_FLAGS(ssc) &= anded_flags;\n\n    /* Below, C1 is the list of code points in 'ssc'; P1, its posix classes.\n     * C2 is the list of code points in 'and-with'; P2, its posix classes.\n     * 'and_with' may be inverted.  When not inverted, we have the situation of\n     * computing:\n     *  (C1 | P1) & (C2 | P2)\n     *                     =  (C1 & (C2 | P2)) | (P1 & (C2 | P2))\n     *                     =  ((C1 & C2) | (C1 & P2)) | ((P1 & C2) | (P1 & P2))\n     *                    <=  ((C1 & C2) |       P2)) | ( P1       | (P1 & P2))\n     *                    <=  ((C1 & C2) | P1 | P2)\n     * Alternatively, the last few steps could be:\n     *                     =  ((C1 & C2) | (C1 & P2)) | ((P1 & C2) | (P1 & P2))\n     *                    <=  ((C1 & C2) |  C1      ) | (      C2  | (P1 & P2))\n     *                    <=  (C1 | C2 | (P1 & P2))\n     * We favor the second approach if either P1 or P2 is non-empty.  This is\n     * because these components are a barrier to doing optimizations, as what\n     * they match cannot be known until the moment of matching as they are\n     * dependent on the current locale, 'AND\"ing them likely will reduce or\n     * eliminate them.\n     * But we can do better if we know that C1,P1 are in their initial state (a\n     * frequent occurrence), each matching everything:\n     *  (<everything>) & (C2 | P2) =  C2 | P2\n     * Similarly, if C2,P2 are in their initial state (again a frequent\n     * occurrence), the result is a no-op\n     *  (C1 | P1) & (<everything>) =  C1 | P1\n     *\n     * Inverted, we have\n     *  (C1 | P1) & ~(C2 | P2)  =  (C1 | P1) & (~C2 & ~P2)\n     *                          =  (C1 & (~C2 & ~P2)) | (P1 & (~C2 & ~P2))\n     *                         <=  (C1 & ~C2) | (P1 & ~P2)\n     * */\n\n    if ((and_with_flags & ANYOF_INVERT)\n        && ! is_ANYOF_SYNTHETIC(and_with))\n    {\n        unsigned int i;\n\n        ssc_intersection(ssc,\n                         anded_cp_list,\n                         FALSE /* Has already been inverted */\n                         );\n\n        /* If either P1 or P2 is empty, the intersection will be also; can skip\n         * the loop */\n        if (! (and_with_flags & ANYOF_MATCHES_POSIXL)) {\n            ANYOF_POSIXL_ZERO(ssc);\n        }\n        else if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n\n            /* Note that the Posix class component P from 'and_with' actually\n             * looks like:\n             *      P = Pa | Pb | ... | Pn\n             * where each component is one posix class, such as in [\\w\\s].\n             * Thus\n             *      ~P = ~(Pa | Pb | ... | Pn)\n             *         = ~Pa & ~Pb & ... & ~Pn\n             *        <= ~Pa | ~Pb | ... | ~Pn\n             * The last is something we can easily calculate, but unfortunately\n             * is likely to have many false positives.  We could do better\n             * in some (but certainly not all) instances if two classes in\n             * P have known relationships.  For example\n             *      :lower: <= :alpha: <= :alnum: <= \\w <= :graph: <= :print:\n             * So\n             *      :lower: & :print: = :lower:\n             * And similarly for classes that must be disjoint.  For example,\n             * since \\s and \\w can have no elements in common based on rules in\n             * the POSIX standard,\n             *      \\w & ^\\S = nothing\n             * Unfortunately, some vendor locales do not meet the Posix\n             * standard, in particular almost everything by Microsoft.\n             * The loop below just changes e.g., \\w into \\W and vice versa */\n\n            regnode_charclass_posixl temp;\n            int add = 1;    /* To calculate the index of the complement */\n\n            Zero(&temp, 1, regnode_charclass_posixl);\n            ANYOF_POSIXL_ZERO(&temp);\n            for (i = 0; i < ANYOF_MAX; i++) {\n                assert(i % 2 != 0\n                       || ! ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i)\n                       || ! ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i + 1));\n\n                if (ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i)) {\n                    ANYOF_POSIXL_SET(&temp, i + add);\n                }\n                add = 0 - add; /* 1 goes to -1; -1 goes to 1 */\n            }\n            ANYOF_POSIXL_AND(&temp, ssc);\n\n        } /* else ssc already has no posixes */\n    } /* else: Not inverted.  This routine is a no-op if 'and_with' is an SSC\n         in its initial state */\n    else if (! is_ANYOF_SYNTHETIC(and_with)\n             || ! ssc_is_cp_posixl_init(pRExC_state, (regnode_ssc *)and_with))\n    {\n        /* But if 'ssc' is in its initial state, the result is just 'and_with';\n         * copy it over 'ssc' */\n        if (ssc_is_cp_posixl_init(pRExC_state, ssc)) {\n            if (is_ANYOF_SYNTHETIC(and_with)) {\n                StructCopy(and_with, ssc, regnode_ssc);\n            }\n            else {\n                ssc->invlist = anded_cp_list;\n                ANYOF_POSIXL_ZERO(ssc);\n                if (and_with_flags & ANYOF_MATCHES_POSIXL) {\n                    ANYOF_POSIXL_OR((regnode_charclass_posixl*) and_with, ssc);\n                }\n            }\n        }\n        else if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)\n                 || (and_with_flags & ANYOF_MATCHES_POSIXL))\n        {\n            /* One or the other of P1, P2 is non-empty. */\n            if (and_with_flags & ANYOF_MATCHES_POSIXL) {\n                ANYOF_POSIXL_AND((regnode_charclass_posixl*) and_with, ssc);\n            }\n            ssc_union(ssc, anded_cp_list, FALSE);\n        }\n        else { /* P1 = P2 = empty */\n            ssc_intersection(ssc, anded_cp_list, FALSE);\n        }\n    }\n}\n\nSTATIC void\nS_ssc_or(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc,\n               const regnode_charclass *or_with)\n{\n    /* Accumulate into SSC 'ssc' its 'OR' with 'or_with', which is either\n     * another SSC or a regular ANYOF class.  Can create false positives if\n     * 'or_with' is to be inverted. */\n\n    SV* ored_cp_list;\n    U8 ored_flags;\n    U8  or_with_flags = (OP(or_with) == ANYOFH) ? 0 : ANYOF_FLAGS(or_with);\n\n    PERL_ARGS_ASSERT_SSC_OR;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* 'or_with' is used as-is if it too is an SSC; otherwise have to extract\n     * the code point inversion list and just the relevant flags */\n    if (is_ANYOF_SYNTHETIC(or_with)) {\n        ored_cp_list = ((regnode_ssc*) or_with)->invlist;\n        ored_flags = or_with_flags;\n    }\n    else {\n        ored_cp_list = get_ANYOF_cp_list_for_ssc(pRExC_state, or_with);\n        ored_flags = or_with_flags & ANYOF_COMMON_FLAGS;\n        if (OP(or_with) != ANYOFD) {\n            ored_flags\n            |= or_with_flags\n             & ( ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER\n                |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP);\n            if (ANYOFL_UTF8_LOCALE_REQD(or_with_flags)) {\n                ored_flags |=\n                    ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n            }\n        }\n    }\n\n    ANYOF_FLAGS(ssc) |= ored_flags;\n\n    /* Below, C1 is the list of code points in 'ssc'; P1, its posix classes.\n     * C2 is the list of code points in 'or-with'; P2, its posix classes.\n     * 'or_with' may be inverted.  When not inverted, we have the simple\n     * situation of computing:\n     *  (C1 | P1) | (C2 | P2)  =  (C1 | C2) | (P1 | P2)\n     * If P1|P2 yields a situation with both a class and its complement are\n     * set, like having both \\w and \\W, this matches all code points, and we\n     * can delete these from the P component of the ssc going forward.  XXX We\n     * might be able to delete all the P components, but I (khw) am not certain\n     * about this, and it is better to be safe.\n     *\n     * Inverted, we have\n     *  (C1 | P1) | ~(C2 | P2)  =  (C1 | P1) | (~C2 & ~P2)\n     *                         <=  (C1 | P1) | ~C2\n     *                         <=  (C1 | ~C2) | P1\n     * (which results in actually simpler code than the non-inverted case)\n     * */\n\n    if ((or_with_flags & ANYOF_INVERT)\n        && ! is_ANYOF_SYNTHETIC(or_with))\n    {\n        /* We ignore P2, leaving P1 going forward */\n    }   /* else  Not inverted */\n    else if (or_with_flags & ANYOF_MATCHES_POSIXL) {\n        ANYOF_POSIXL_OR((regnode_charclass_posixl*)or_with, ssc);\n        if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n            unsigned int i;\n            for (i = 0; i < ANYOF_MAX; i += 2) {\n                if (ANYOF_POSIXL_TEST(ssc, i) && ANYOF_POSIXL_TEST(ssc, i + 1))\n                {\n                    ssc_match_all_cp(ssc);\n                    ANYOF_POSIXL_CLEAR(ssc, i);\n                    ANYOF_POSIXL_CLEAR(ssc, i+1);\n                }\n            }\n        }\n    }\n\n    ssc_union(ssc,\n              ored_cp_list,\n              FALSE /* Already has been inverted */\n              );\n}\n\nPERL_STATIC_INLINE void\nS_ssc_union(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert2nd)\n{\n    PERL_ARGS_ASSERT_SSC_UNION;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    _invlist_union_maybe_complement_2nd(ssc->invlist,\n                                        invlist,\n                                        invert2nd,\n                                        &ssc->invlist);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_intersection(pTHX_ regnode_ssc *ssc,\n                         SV* const invlist,\n                         const bool invert2nd)\n{\n    PERL_ARGS_ASSERT_SSC_INTERSECTION;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    _invlist_intersection_maybe_complement_2nd(ssc->invlist,\n                                               invlist,\n                                               invert2nd,\n                                               &ssc->invlist);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_add_range(pTHX_ regnode_ssc *ssc, const UV start, const UV end)\n{\n    PERL_ARGS_ASSERT_SSC_ADD_RANGE;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    ssc->invlist = _add_range_to_invlist(ssc->invlist, start, end);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_cp_and(pTHX_ regnode_ssc *ssc, const UV cp)\n{\n    /* AND just the single code point 'cp' into the SSC 'ssc' */\n\n    SV* cp_list = _new_invlist(2);\n\n    PERL_ARGS_ASSERT_SSC_CP_AND;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    cp_list = add_cp_to_invlist(cp_list, cp);\n    ssc_intersection(ssc, cp_list,\n                     FALSE /* Not inverted */\n                     );\n    SvREFCNT_dec_NN(cp_list);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_clear_locale(regnode_ssc *ssc)\n{\n    /* Set the SSC 'ssc' to not match any locale things */\n    PERL_ARGS_ASSERT_SSC_CLEAR_LOCALE;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    ANYOF_POSIXL_ZERO(ssc);\n    ANYOF_FLAGS(ssc) &= ~ANYOF_LOCALE_FLAGS;\n}\n\n#define NON_OTHER_COUNT   NON_OTHER_COUNT_FOR_USE_ONLY_BY_REGCOMP_DOT_C\n\nSTATIC bool\nS_is_ssc_worth_it(const RExC_state_t * pRExC_state, const regnode_ssc * ssc)\n{\n    /* The synthetic start class is used to hopefully quickly winnow down\n     * places where a pattern could start a match in the target string.  If it\n     * doesn't really narrow things down that much, there isn't much point to\n     * having the overhead of using it.  This function uses some very crude\n     * heuristics to decide if to use the ssc or not.\n     *\n     * It returns TRUE if 'ssc' rules out more than half what it considers to\n     * be the \"likely\" possible matches, but of course it doesn't know what the\n     * actual things being matched are going to be; these are only guesses\n     *\n     * For /l matches, it assumes that the only likely matches are going to be\n     *      in the 0-255 range, uniformly distributed, so half of that is 127\n     * For /a and /d matches, it assumes that the likely matches will be just\n     *      the ASCII range, so half of that is 63\n     * For /u and there isn't anything matching above the Latin1 range, it\n     *      assumes that that is the only range likely to be matched, and uses\n     *      half that as the cut-off: 127.  If anything matches above Latin1,\n     *      it assumes that all of Unicode could match (uniformly), except for\n     *      non-Unicode code points and things in the General Category \"Other\"\n     *      (unassigned, private use, surrogates, controls and formats).  This\n     *      is a much large number. */\n\n    U32 count = 0;      /* Running total of number of code points matched by\n                           'ssc' */\n    UV start, end;      /* Start and end points of current range in inversion\n                           XXX outdated.  UTF-8 locales are common, what about invert? list */\n    const U32 max_code_points = (LOC)\n                                ?  256\n                                : ((  ! UNI_SEMANTICS\n                                    ||  invlist_highest(ssc->invlist) < 256)\n                                  ? 128\n                                  : NON_OTHER_COUNT);\n    const U32 max_match = max_code_points / 2;\n\n    PERL_ARGS_ASSERT_IS_SSC_WORTH_IT;\n\n    invlist_iterinit(ssc->invlist);\n    while (invlist_iternext(ssc->invlist, &start, &end)) {\n        if (start >= max_code_points) {\n            break;\n        }\n        end = MIN(end, max_code_points - 1);\n        count += end - start + 1;\n        if (count >= max_match) {\n            invlist_iterfinish(ssc->invlist);\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}\n\n\nSTATIC void\nS_ssc_finalize(pTHX_ RExC_state_t *pRExC_state, regnode_ssc *ssc)\n{\n    /* The inversion list in the SSC is marked mortal; now we need a more\n     * permanent copy, which is stored the same way that is done in a regular\n     * ANYOF node, with the first NUM_ANYOF_CODE_POINTS code points in a bit\n     * map */\n\n    SV* invlist = invlist_clone(ssc->invlist, NULL);\n\n    PERL_ARGS_ASSERT_SSC_FINALIZE;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* The code in this file assumes that all but these flags aren't relevant\n     * to the SSC, except SSC_MATCHES_EMPTY_STRING, which should be cleared\n     * by the time we reach here */\n    assert(! (ANYOF_FLAGS(ssc)\n        & ~( ANYOF_COMMON_FLAGS\n            |ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER\n            |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP)));\n\n    populate_ANYOF_from_invlist( (regnode *) ssc, &invlist);\n\n    set_ANYOF_arg(pRExC_state, (regnode *) ssc, invlist, NULL, NULL);\n\n    /* Make sure is clone-safe */\n    ssc->invlist = NULL;\n\n    if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n        ANYOF_FLAGS(ssc) |= ANYOF_MATCHES_POSIXL;\n        OP(ssc) = ANYOFPOSIXL;\n    }\n    else if (RExC_contains_locale) {\n        OP(ssc) = ANYOFL;\n    }\n\n    assert(! (ANYOF_FLAGS(ssc) & ANYOF_LOCALE_FLAGS) || RExC_contains_locale);\n}\n\n#define TRIE_LIST_ITEM(state,idx) (trie->states[state].trans.list)[ idx ]\n#define TRIE_LIST_CUR(state)  ( TRIE_LIST_ITEM( state, 0 ).forid )\n#define TRIE_LIST_LEN(state) ( TRIE_LIST_ITEM( state, 0 ).newstate )\n#define TRIE_LIST_USED(idx)  ( trie->states[state].trans.list         \\\n                               ? (TRIE_LIST_CUR( idx ) - 1)           \\\n                               : 0 )\n\n\n#ifdef DEBUGGING\n/*\n   dump_trie(trie,widecharmap,revcharmap)\n   dump_trie_interim_list(trie,widecharmap,revcharmap,next_alloc)\n   dump_trie_interim_table(trie,widecharmap,revcharmap,next_alloc)\n\n   These routines dump out a trie in a somewhat readable format.\n   The _interim_ variants are used for debugging the interim\n   tables that are used to generate the final compressed\n   representation which is what dump_trie expects.\n\n   Part of the reason for their existence is to provide a form\n   of documentation as to how the different representations function.\n\n*/\n\n/*\n  Dumps the final compressed table form of the trie to Perl_debug_log.\n  Used for debugging make_trie().\n*/\n\nSTATIC void\nS_dump_trie(pTHX_ const struct _reg_trie_data *trie, HV *widecharmap,\n\t    AV *revcharmap, U32 depth)\n{\n    U32 state;\n    SV *sv=sv_newmortal();\n    int colwidth= widecharmap ? 6 : 4;\n    U16 word;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMP_TRIE;\n\n    Perl_re_indentf( aTHX_  \"Char : %-6s%-6s%-4s \",\n        depth+1, \"Match\",\"Base\",\"Ofs\" );\n\n    for( state = 0 ; state < trie->uniquecharcount ; state++ ) {\n\tSV ** const tmp = av_fetch( revcharmap, state, 0);\n        if ( tmp ) {\n            Perl_re_printf( aTHX_  \"%*s\",\n                colwidth,\n                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth,\n\t                    PL_colors[0], PL_colors[1],\n\t                    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |\n\t                    PERL_PV_ESCAPE_FIRSTCHAR\n                )\n            );\n        }\n    }\n    Perl_re_printf( aTHX_  \"\\n\");\n    Perl_re_indentf( aTHX_ \"State|-----------------------\", depth+1);\n\n    for( state = 0 ; state < trie->uniquecharcount ; state++ )\n        Perl_re_printf( aTHX_  \"%.*s\", colwidth, \"--------\");\n    Perl_re_printf( aTHX_  \"\\n\");\n\n    for( state = 1 ; state < trie->statecount ; state++ ) {\n\tconst U32 base = trie->states[ state ].trans.base;\n\n        Perl_re_indentf( aTHX_  \"#%4\" UVXf \"|\", depth+1, (UV)state);\n\n        if ( trie->states[ state ].wordnum ) {\n            Perl_re_printf( aTHX_  \" W%4X\", trie->states[ state ].wordnum );\n        } else {\n            Perl_re_printf( aTHX_  \"%6s\", \"\" );\n        }\n\n        Perl_re_printf( aTHX_  \" @%4\" UVXf \" \", (UV)base );\n\n        if ( base ) {\n            U32 ofs = 0;\n\n            while( ( base + ofs  < trie->uniquecharcount ) ||\n                   ( base + ofs - trie->uniquecharcount < trie->lasttrans\n                     && trie->trans[ base + ofs - trie->uniquecharcount ].check\n                                                                    != state))\n                    ofs++;\n\n            Perl_re_printf( aTHX_  \"+%2\" UVXf \"[ \", (UV)ofs);\n\n            for ( ofs = 0 ; ofs < trie->uniquecharcount ; ofs++ ) {\n                if ( ( base + ofs >= trie->uniquecharcount )\n                        && ( base + ofs - trie->uniquecharcount\n                                                        < trie->lasttrans )\n                        && trie->trans[ base + ofs\n                                    - trie->uniquecharcount ].check == state )\n                {\n                   Perl_re_printf( aTHX_  \"%*\" UVXf, colwidth,\n                    (UV)trie->trans[ base + ofs - trie->uniquecharcount ].next\n                   );\n                } else {\n                    Perl_re_printf( aTHX_  \"%*s\", colwidth,\"   .\" );\n                }\n            }\n\n            Perl_re_printf( aTHX_  \"]\");\n\n        }\n        Perl_re_printf( aTHX_  \"\\n\" );\n    }\n    Perl_re_indentf( aTHX_  \"word_info N:(prev,len)=\",\n                                depth);\n    for (word=1; word <= trie->wordcount; word++) {\n        Perl_re_printf( aTHX_  \" %d:(%d,%d)\",\n\t    (int)word, (int)(trie->wordinfo[word].prev),\n\t    (int)(trie->wordinfo[word].len));\n    }\n    Perl_re_printf( aTHX_  \"\\n\" );\n}\n/*\n  Dumps a fully constructed but uncompressed trie in list form.\n  List tries normally only are used for construction when the number of\n  possible chars (trie->uniquecharcount) is very high.\n  Used for debugging make_trie().\n*/\nSTATIC void\nS_dump_trie_interim_list(pTHX_ const struct _reg_trie_data *trie,\n\t\t\t HV *widecharmap, AV *revcharmap, U32 next_alloc,\n\t\t\t U32 depth)\n{\n    U32 state;\n    SV *sv=sv_newmortal();\n    int colwidth= widecharmap ? 6 : 4;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_LIST;\n\n    /* print out the table precompression.  */\n    Perl_re_indentf( aTHX_  \"State :Word | Transition Data\\n\",\n            depth+1 );\n    Perl_re_indentf( aTHX_  \"%s\",\n            depth+1, \"------:-----+-----------------\\n\" );\n\n    for( state=1 ; state < next_alloc ; state ++ ) {\n        U16 charid;\n\n        Perl_re_indentf( aTHX_  \" %4\" UVXf \" :\",\n            depth+1, (UV)state  );\n        if ( ! trie->states[ state ].wordnum ) {\n            Perl_re_printf( aTHX_  \"%5s| \",\"\");\n        } else {\n            Perl_re_printf( aTHX_  \"W%4x| \",\n                trie->states[ state ].wordnum\n            );\n        }\n        for( charid = 1 ; charid <= TRIE_LIST_USED( state ) ; charid++ ) {\n\t    SV ** const tmp = av_fetch( revcharmap,\n                                        TRIE_LIST_ITEM(state, charid).forid, 0);\n\t    if ( tmp ) {\n                Perl_re_printf( aTHX_  \"%*s:%3X=%4\" UVXf \" | \",\n                    colwidth,\n                    pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp),\n                              colwidth,\n                              PL_colors[0], PL_colors[1],\n                              (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0)\n                              | PERL_PV_ESCAPE_FIRSTCHAR\n                    ) ,\n                    TRIE_LIST_ITEM(state, charid).forid,\n                    (UV)TRIE_LIST_ITEM(state, charid).newstate\n                );\n                if (!(charid % 10))\n                    Perl_re_printf( aTHX_  \"\\n%*s| \",\n                        (int)((depth * 2) + 14), \"\");\n            }\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    }\n}\n\n/*\n  Dumps a fully constructed but uncompressed trie in table form.\n  This is the normal DFA style state transition table, with a few\n  twists to facilitate compression later.\n  Used for debugging make_trie().\n*/\nSTATIC void\nS_dump_trie_interim_table(pTHX_ const struct _reg_trie_data *trie,\n\t\t\t  HV *widecharmap, AV *revcharmap, U32 next_alloc,\n\t\t\t  U32 depth)\n{\n    U32 state;\n    U16 charid;\n    SV *sv=sv_newmortal();\n    int colwidth= widecharmap ? 6 : 4;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_TABLE;\n\n    /*\n       print out the table precompression so that we can do a visual check\n       that they are identical.\n     */\n\n    Perl_re_indentf( aTHX_  \"Char : \", depth+1 );\n\n    for( charid = 0 ; charid < trie->uniquecharcount ; charid++ ) {\n\tSV ** const tmp = av_fetch( revcharmap, charid, 0);\n        if ( tmp ) {\n            Perl_re_printf( aTHX_  \"%*s\",\n                colwidth,\n                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth,\n\t                    PL_colors[0], PL_colors[1],\n\t                    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |\n\t                    PERL_PV_ESCAPE_FIRSTCHAR\n                )\n            );\n        }\n    }\n\n    Perl_re_printf( aTHX_ \"\\n\");\n    Perl_re_indentf( aTHX_  \"State+-\", depth+1 );\n\n    for( charid=0 ; charid < trie->uniquecharcount ; charid++ ) {\n        Perl_re_printf( aTHX_  \"%.*s\", colwidth,\"--------\");\n    }\n\n    Perl_re_printf( aTHX_  \"\\n\" );\n\n    for( state=1 ; state < next_alloc ; state += trie->uniquecharcount ) {\n\n        Perl_re_indentf( aTHX_  \"%4\" UVXf \" : \",\n            depth+1,\n            (UV)TRIE_NODENUM( state ) );\n\n        for( charid = 0 ; charid < trie->uniquecharcount ; charid++ ) {\n            UV v=(UV)SAFE_TRIE_NODENUM( trie->trans[ state + charid ].next );\n            if (v)\n                Perl_re_printf( aTHX_  \"%*\" UVXf, colwidth, v );\n            else\n                Perl_re_printf( aTHX_  \"%*s\", colwidth, \".\" );\n        }\n        if ( ! trie->states[ TRIE_NODENUM( state ) ].wordnum ) {\n            Perl_re_printf( aTHX_  \" (%4\" UVXf \")\\n\",\n                                            (UV)trie->trans[ state ].check );\n        } else {\n            Perl_re_printf( aTHX_  \" (%4\" UVXf \") W%4X\\n\",\n                                            (UV)trie->trans[ state ].check,\n            trie->states[ TRIE_NODENUM( state ) ].wordnum );\n        }\n    }\n}\n\n#endif\n\n\n/* make_trie(startbranch,first,last,tail,word_count,flags,depth)\n  startbranch: the first branch in the whole branch sequence\n  first      : start branch of sequence of branch-exact nodes.\n\t       May be the same as startbranch\n  last       : Thing following the last branch.\n\t       May be the same as tail.\n  tail       : item following the branch sequence\n  count      : words in the sequence\n  flags      : currently the OP() type we will be building one of /EXACT(|F|FA|FU|FU_SS|L|FLU8)/\n  depth      : indent depth\n\nInplace optimizes a sequence of 2 or more Branch-Exact nodes into a TRIE node.\n\nA trie is an N'ary tree where the branches are determined by digital\ndecomposition of the key. IE, at the root node you look up the 1st character and\nfollow that branch repeat until you find the end of the branches. Nodes can be\nmarked as \"accepting\" meaning they represent a complete word. Eg:\n\n  /he|she|his|hers/\n\nwould convert into the following structure. Numbers represent states, letters\nfollowing numbers represent valid transitions on the letter from that state, if\nthe number is in square brackets it represents an accepting state, otherwise it\nwill be in parenthesis.\n\n      +-h->+-e->[3]-+-r->(8)-+-s->[9]\n      |    |\n      |   (2)\n      |    |\n     (1)   +-i->(6)-+-s->[7]\n      |\n      +-s->(3)-+-h->(4)-+-e->[5]\n\n      Accept Word Mapping: 3=>1 (he),5=>2 (she), 7=>3 (his), 9=>4 (hers)\n\nThis shows that when matching against the string 'hers' we will begin at state 1\nread 'h' and move to state 2, read 'e' and move to state 3 which is accepting,\nthen read 'r' and go to state 8 followed by 's' which takes us to state 9 which\nis also accepting. Thus we know that we can match both 'he' and 'hers' with a\nsingle traverse. We store a mapping from accepting to state to which word was\nmatched, and then when we have multiple possibilities we try to complete the\nrest of the regex in the order in which they occurred in the alternation.\n\nThe only prior NFA like behaviour that would be changed by the TRIE support is\nthe silent ignoring of duplicate alternations which are of the form:\n\n / (DUPE|DUPE) X? (?{ ... }) Y /x\n\nThus EVAL blocks following a trie may be called a different number of times with\nand without the optimisation. With the optimisations dupes will be silently\nignored. This inconsistent behaviour of EVAL type nodes is well established as\nthe following demonstrates:\n\n 'words'=~/(word|word|word)(?{ print $1 })[xyz]/\n\nwhich prints out 'word' three times, but\n\n 'words'=~/(word|word|word)(?{ print $1 })S/\n\nwhich doesnt print it out at all. This is due to other optimisations kicking in.\n\nExample of what happens on a structural level:\n\nThe regexp /(ac|ad|ab)+/ will produce the following debug output:\n\n   1: CURLYM[1] {1,32767}(18)\n   5:   BRANCH(8)\n   6:     EXACT <ac>(16)\n   8:   BRANCH(11)\n   9:     EXACT <ad>(16)\n  11:   BRANCH(14)\n  12:     EXACT <ab>(16)\n  16:   SUCCEED(0)\n  17:   NOTHING(18)\n  18: END(0)\n\nThis would be optimizable with startbranch=5, first=5, last=16, tail=16\nand should turn into:\n\n   1: CURLYM[1] {1,32767}(18)\n   5:   TRIE(16)\n\t[Words:3 Chars Stored:6 Unique Chars:4 States:5 NCP:1]\n\t  <ac>\n\t  <ad>\n\t  <ab>\n  16:   SUCCEED(0)\n  17:   NOTHING(18)\n  18: END(0)\n\nCases where tail != last would be like /(?foo|bar)baz/:\n\n   1: BRANCH(4)\n   2:   EXACT <foo>(8)\n   4: BRANCH(7)\n   5:   EXACT <bar>(8)\n   7: TAIL(8)\n   8: EXACT <baz>(10)\n  10: END(0)\n\nwhich would be optimizable with startbranch=1, first=1, last=7, tail=8\nand would end up looking like:\n\n    1: TRIE(8)\n      [Words:2 Chars Stored:6 Unique Chars:5 States:7 NCP:1]\n\t<foo>\n\t<bar>\n   7: TAIL(8)\n   8: EXACT <baz>(10)\n  10: END(0)\n\n    d = uvchr_to_utf8_flags(d, uv, 0);\n\nis the recommended Unicode-aware way of saying\n\n    *(d++) = uv;\n*/\n\n#define TRIE_STORE_REVCHAR(val)                                            \\\n    STMT_START {                                                           \\\n\tif (UTF) {\t\t\t\t\t\t\t   \\\n            SV *zlopp = newSV(UTF8_MAXBYTES);\t\t\t\t   \\\n\t    unsigned char *flrbbbbb = (unsigned char *) SvPVX(zlopp);\t   \\\n            unsigned const char *const kapow = uvchr_to_utf8(flrbbbbb, val); \\\n\t    SvCUR_set(zlopp, kapow - flrbbbbb);\t\t\t\t   \\\n\t    SvPOK_on(zlopp);\t\t\t\t\t\t   \\\n\t    SvUTF8_on(zlopp);\t\t\t\t\t\t   \\\n\t    av_push(revcharmap, zlopp);\t\t\t\t\t   \\\n\t} else {\t\t\t\t\t\t\t   \\\n            char ooooff = (char)val;                                           \\\n\t    av_push(revcharmap, newSVpvn(&ooooff, 1));\t\t\t   \\\n\t}\t\t\t\t\t\t\t\t   \\\n        } STMT_END\n\n/* This gets the next character from the input, folding it if not already\n * folded. */\n#define TRIE_READ_CHAR STMT_START {                                           \\\n    wordlen++;                                                                \\\n    if ( UTF ) {                                                              \\\n        /* if it is UTF then it is either already folded, or does not need    \\\n         * folding */                                                         \\\n        uvc = valid_utf8_to_uvchr( (const U8*) uc, &len);                     \\\n    }                                                                         \\\n    else if (folder == PL_fold_latin1) {                                      \\\n        /* This folder implies Unicode rules, which in the range expressible  \\\n         *  by not UTF is the lower case, with the two exceptions, one of     \\\n         *  which should have been taken care of before calling this */       \\\n        assert(*uc != LATIN_SMALL_LETTER_SHARP_S);                            \\\n        uvc = toLOWER_L1(*uc);                                                \\\n        if (UNLIKELY(uvc == MICRO_SIGN)) uvc = GREEK_SMALL_LETTER_MU;         \\\n        len = 1;                                                              \\\n    } else {                                                                  \\\n        /* raw data, will be folded later if needed */                        \\\n        uvc = (U32)*uc;                                                       \\\n        len = 1;                                                              \\\n    }                                                                         \\\n} STMT_END\n\n\n\n#define TRIE_LIST_PUSH(state,fid,ns) STMT_START {               \\\n    if ( TRIE_LIST_CUR( state ) >=TRIE_LIST_LEN( state ) ) {    \\\n\tU32 ging = TRIE_LIST_LEN( state ) * 2;                  \\\n\tRenew( trie->states[ state ].trans.list, ging, reg_trie_trans_le ); \\\n        TRIE_LIST_LEN( state ) = ging;                          \\\n    }                                                           \\\n    TRIE_LIST_ITEM( state, TRIE_LIST_CUR( state ) ).forid = fid;     \\\n    TRIE_LIST_ITEM( state, TRIE_LIST_CUR( state ) ).newstate = ns;   \\\n    TRIE_LIST_CUR( state )++;                                   \\\n} STMT_END\n\n#define TRIE_LIST_NEW(state) STMT_START {                       \\\n    Newx( trie->states[ state ].trans.list,                     \\\n\t4, reg_trie_trans_le );                                 \\\n     TRIE_LIST_CUR( state ) = 1;                                \\\n     TRIE_LIST_LEN( state ) = 4;                                \\\n} STMT_END\n\n#define TRIE_HANDLE_WORD(state) STMT_START {                    \\\n    U16 dupe= trie->states[ state ].wordnum;                    \\\n    regnode * const noper_next = regnext( noper );              \\\n                                                                \\\n    DEBUG_r({                                                   \\\n        /* store the word for dumping */                        \\\n        SV* tmp;                                                \\\n        if (OP(noper) != NOTHING)                               \\\n            tmp = newSVpvn_utf8(STRING(noper), STR_LEN(noper), UTF);\t\\\n        else                                                    \\\n            tmp = newSVpvn_utf8( \"\", 0, UTF );\t\t\t\\\n        av_push( trie_words, tmp );                             \\\n    });                                                         \\\n                                                                \\\n    curword++;                                                  \\\n    trie->wordinfo[curword].prev   = 0;                         \\\n    trie->wordinfo[curword].len    = wordlen;                   \\\n    trie->wordinfo[curword].accept = state;                     \\\n                                                                \\\n    if ( noper_next < tail ) {                                  \\\n        if (!trie->jump)                                        \\\n            trie->jump = (U16 *) PerlMemShared_calloc( word_count + 1, \\\n                                                 sizeof(U16) ); \\\n        trie->jump[curword] = (U16)(noper_next - convert);      \\\n        if (!jumper)                                            \\\n            jumper = noper_next;                                \\\n        if (!nextbranch)                                        \\\n            nextbranch= regnext(cur);                           \\\n    }                                                           \\\n                                                                \\\n    if ( dupe ) {                                               \\\n        /* It's a dupe. Pre-insert into the wordinfo[].prev   */\\\n        /* chain, so that when the bits of chain are later    */\\\n        /* linked together, the dups appear in the chain      */\\\n\ttrie->wordinfo[curword].prev = trie->wordinfo[dupe].prev; \\\n\ttrie->wordinfo[dupe].prev = curword;                    \\\n    } else {                                                    \\\n        /* we haven't inserted this word yet.                */ \\\n        trie->states[ state ].wordnum = curword;                \\\n    }                                                           \\\n} STMT_END\n\n\n#define TRIE_TRANS_STATE(state,base,ucharcount,charid,special)\t\t\\\n     ( ( base + charid >=  ucharcount\t\t\t\t\t\\\n         && base + charid < ubound\t\t\t\t\t\\\n         && state == trie->trans[ base - ucharcount + charid ].check\t\\\n         && trie->trans[ base - ucharcount + charid ].next )\t\t\\\n           ? trie->trans[ base - ucharcount + charid ].next\t\t\\\n           : ( state==1 ? special : 0 )\t\t\t\t\t\\\n      )\n\n#define TRIE_BITMAP_SET_FOLDED(trie, uvc, folder)           \\\nSTMT_START {                                                \\\n    TRIE_BITMAP_SET(trie, uvc);                             \\\n    /* store the folded codepoint */                        \\\n    if ( folder )                                           \\\n        TRIE_BITMAP_SET(trie, folder[(U8) uvc ]);           \\\n                                                            \\\n    if ( !UTF ) {                                           \\\n        /* store first byte of utf8 representation of */    \\\n        /* variant codepoints */                            \\\n        if (! UVCHR_IS_INVARIANT(uvc)) {                    \\\n            TRIE_BITMAP_SET(trie, UTF8_TWO_BYTE_HI(uvc));   \\\n        }                                                   \\\n    }                                                       \\\n} STMT_END\n#define MADE_TRIE       1\n#define MADE_JUMP_TRIE  2\n#define MADE_EXACT_TRIE 4\n\nSTATIC I32\nS_make_trie(pTHX_ RExC_state_t *pRExC_state, regnode *startbranch,\n                  regnode *first, regnode *last, regnode *tail,\n                  U32 word_count, U32 flags, U32 depth)\n{\n    /* first pass, loop through and scan words */\n    reg_trie_data *trie;\n    HV *widecharmap = NULL;\n    AV *revcharmap = newAV();\n    regnode *cur;\n    STRLEN len = 0;\n    UV uvc = 0;\n    U16 curword = 0;\n    U32 next_alloc = 0;\n    regnode *jumper = NULL;\n    regnode *nextbranch = NULL;\n    regnode *convert = NULL;\n    U32 *prev_states; /* temp array mapping each state to previous one */\n    /* we just use folder as a flag in utf8 */\n    const U8 * folder = NULL;\n\n    /* in the below add_data call we are storing either 'tu' or 'tuaa'\n     * which stands for one trie structure, one hash, optionally followed\n     * by two arrays */\n#ifdef DEBUGGING\n    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN(\"tuaa\"));\n    AV *trie_words = NULL;\n    /* along with revcharmap, this only used during construction but both are\n     * useful during debugging so we store them in the struct when debugging.\n     */\n#else\n    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN(\"tu\"));\n    STRLEN trie_charcount=0;\n#endif\n    SV *re_trie_maxbuff;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_MAKE_TRIE;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    switch (flags) {\n        case EXACT: case EXACT_ONLY8: case EXACTL: break;\n\tcase EXACTFAA:\n        case EXACTFUP:\n\tcase EXACTFU:\n\tcase EXACTFLU8: folder = PL_fold_latin1; break;\n\tcase EXACTF:  folder = PL_fold; break;\n        default: Perl_croak( aTHX_ \"panic! In trie construction, unknown node type %u %s\", (unsigned) flags, PL_reg_name[flags] );\n    }\n\n    trie = (reg_trie_data *) PerlMemShared_calloc( 1, sizeof(reg_trie_data) );\n    trie->refcount = 1;\n    trie->startstate = 1;\n    trie->wordcount = word_count;\n    RExC_rxi->data->data[ data_slot ] = (void*)trie;\n    trie->charmap = (U16 *) PerlMemShared_calloc( 256, sizeof(U16) );\n    if (flags == EXACT || flags == EXACT_ONLY8 || flags == EXACTL)\n\ttrie->bitmap = (char *) PerlMemShared_calloc( ANYOF_BITMAP_SIZE, 1 );\n    trie->wordinfo = (reg_trie_wordinfo *) PerlMemShared_calloc(\n                       trie->wordcount+1, sizeof(reg_trie_wordinfo));\n\n    DEBUG_r({\n        trie_words = newAV();\n    });\n\n    re_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, GV_ADD);\n    assert(re_trie_maxbuff);\n    if (!SvIOK(re_trie_maxbuff)) {\n        sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);\n    }\n    DEBUG_TRIE_COMPILE_r({\n        Perl_re_indentf( aTHX_\n          \"make_trie start==%d, first==%d, last==%d, tail==%d depth=%d\\n\",\n          depth+1,\n          REG_NODE_NUM(startbranch), REG_NODE_NUM(first),\n          REG_NODE_NUM(last), REG_NODE_NUM(tail), (int)depth);\n    });\n\n   /* Find the node we are going to overwrite */\n    if ( first == startbranch && OP( last ) != BRANCH ) {\n        /* whole branch chain */\n        convert = first;\n    } else {\n        /* branch sub-chain */\n        convert = NEXTOPER( first );\n    }\n\n    /*  -- First loop and Setup --\n\n       We first traverse the branches and scan each word to determine if it\n       contains widechars, and how many unique chars there are, this is\n       important as we have to build a table with at least as many columns as we\n       have unique chars.\n\n       We use an array of integers to represent the character codes 0..255\n       (trie->charmap) and we use a an HV* to store Unicode characters. We use\n       the native representation of the character value as the key and IV's for\n       the coded index.\n\n       *TODO* If we keep track of how many times each character is used we can\n       remap the columns so that the table compression later on is more\n       efficient in terms of memory by ensuring the most common value is in the\n       middle and the least common are on the outside.  IMO this would be better\n       than a most to least common mapping as theres a decent chance the most\n       common letter will share a node with the least common, meaning the node\n       will not be compressible. With a middle is most common approach the worst\n       case is when we have the least common nodes twice.\n\n     */\n\n    for ( cur = first ; cur < last ; cur = regnext( cur ) ) {\n        regnode *noper = NEXTOPER( cur );\n        const U8 *uc;\n        const U8 *e;\n        int foldlen = 0;\n        U32 wordlen      = 0;         /* required init */\n        STRLEN minchars = 0;\n        STRLEN maxchars = 0;\n        bool set_bit = trie->bitmap ? 1 : 0; /*store the first char in the\n                                               bitmap?*/\n\n        if (OP(noper) == NOTHING) {\n            /* skip past a NOTHING at the start of an alternation\n             * eg, /(?:)a|(?:b)/ should be the same as /a|b/\n             *\n             * If the next node is not something we are supposed to process\n             * we will just ignore it due to the condition guarding the\n             * next block.\n             */\n\n            regnode *noper_next= regnext(noper);\n            if (noper_next < tail)\n                noper= noper_next;\n        }\n\n        if (    noper < tail\n            && (    OP(noper) == flags\n                || (flags == EXACT && OP(noper) == EXACT_ONLY8)\n                || (flags == EXACTFU && (   OP(noper) == EXACTFU_ONLY8\n                                         || OP(noper) == EXACTFUP))))\n        {\n            uc= (U8*)STRING(noper);\n            e= uc + STR_LEN(noper);\n        } else {\n            trie->minlen= 0;\n            continue;\n        }\n\n\n        if ( set_bit ) { /* bitmap only alloced when !(UTF&&Folding) */\n            TRIE_BITMAP_SET(trie,*uc); /* store the raw first byte\n                                          regardless of encoding */\n            if (OP( noper ) == EXACTFUP) {\n                /* false positives are ok, so just set this */\n                TRIE_BITMAP_SET(trie, LATIN_SMALL_LETTER_SHARP_S);\n            }\n        }\n\n        for ( ; uc < e ; uc += len ) {  /* Look at each char in the current\n                                           branch */\n            TRIE_CHARCOUNT(trie)++;\n            TRIE_READ_CHAR;\n\n            /* TRIE_READ_CHAR returns the current character, or its fold if /i\n             * is in effect.  Under /i, this character can match itself, or\n             * anything that folds to it.  If not under /i, it can match just\n             * itself.  Most folds are 1-1, for example k, K, and KELVIN SIGN\n             * all fold to k, and all are single characters.   But some folds\n             * expand to more than one character, so for example LATIN SMALL\n             * LIGATURE FFI folds to the three character sequence 'ffi'.  If\n             * the string beginning at 'uc' is 'ffi', it could be matched by\n             * three characters, or just by the one ligature character. (It\n             * could also be matched by two characters: LATIN SMALL LIGATURE FF\n             * followed by 'i', or by 'f' followed by LATIN SMALL LIGATURE FI).\n             * (Of course 'I' and/or 'F' instead of 'i' and 'f' can also\n             * match.)  The trie needs to know the minimum and maximum number\n             * of characters that could match so that it can use size alone to\n             * quickly reject many match attempts.  The max is simple: it is\n             * the number of folded characters in this branch (since a fold is\n             * never shorter than what folds to it. */\n\n            maxchars++;\n\n            /* And the min is equal to the max if not under /i (indicated by\n             * 'folder' being NULL), or there are no multi-character folds.  If\n             * there is a multi-character fold, the min is incremented just\n             * once, for the character that folds to the sequence.  Each\n             * character in the sequence needs to be added to the list below of\n             * characters in the trie, but we count only the first towards the\n             * min number of characters needed.  This is done through the\n             * variable 'foldlen', which is returned by the macros that look\n             * for these sequences as the number of bytes the sequence\n             * occupies.  Each time through the loop, we decrement 'foldlen' by\n             * how many bytes the current char occupies.  Only when it reaches\n             * 0 do we increment 'minchars' or look for another multi-character\n             * sequence. */\n            if (folder == NULL) {\n                minchars++;\n            }\n            else if (foldlen > 0) {\n                foldlen -= (UTF) ? UTF8SKIP(uc) : 1;\n            }\n            else {\n                minchars++;\n\n                /* See if *uc is the beginning of a multi-character fold.  If\n                 * so, we decrement the length remaining to look at, to account\n                 * for the current character this iteration.  (We can use 'uc'\n                 * instead of the fold returned by TRIE_READ_CHAR because for\n                 * non-UTF, the latin1_safe macro is smart enough to account\n                 * for all the unfolded characters, and because for UTF, the\n                 * string will already have been folded earlier in the\n                 * compilation process */\n                if (UTF) {\n                    if ((foldlen = is_MULTI_CHAR_FOLD_utf8_safe(uc, e))) {\n                        foldlen -= UTF8SKIP(uc);\n                    }\n                }\n                else if ((foldlen = is_MULTI_CHAR_FOLD_latin1_safe(uc, e))) {\n                    foldlen--;\n                }\n            }\n\n            /* The current character (and any potential folds) should be added\n             * to the possible matching characters for this position in this\n             * branch */\n            if ( uvc < 256 ) {\n                if ( folder ) {\n                    U8 folded= folder[ (U8) uvc ];\n                    if ( !trie->charmap[ folded ] ) {\n                        trie->charmap[ folded ]=( ++trie->uniquecharcount );\n                        TRIE_STORE_REVCHAR( folded );\n                    }\n                }\n                if ( !trie->charmap[ uvc ] ) {\n                    trie->charmap[ uvc ]=( ++trie->uniquecharcount );\n                    TRIE_STORE_REVCHAR( uvc );\n                }\n                if ( set_bit ) {\n\t\t    /* store the codepoint in the bitmap, and its folded\n\t\t     * equivalent. */\n                    TRIE_BITMAP_SET_FOLDED(trie, uvc, folder);\n                    set_bit = 0; /* We've done our bit :-) */\n                }\n            } else {\n\n                /* XXX We could come up with the list of code points that fold\n                 * to this using PL_utf8_foldclosures, except not for\n                 * multi-char folds, as there may be multiple combinations\n                 * there that could work, which needs to wait until runtime to\n                 * resolve (The comment about LIGATURE FFI above is such an\n                 * example */\n\n                SV** svpp;\n                if ( !widecharmap )\n                    widecharmap = newHV();\n\n                svpp = hv_fetch( widecharmap, (char*)&uvc, sizeof( UV ), 1 );\n\n                if ( !svpp )\n                    Perl_croak( aTHX_ \"error creating/fetching widecharmap entry for 0x%\" UVXf, uvc );\n\n                if ( !SvTRUE( *svpp ) ) {\n                    sv_setiv( *svpp, ++trie->uniquecharcount );\n                    TRIE_STORE_REVCHAR(uvc);\n                }\n            }\n        } /* end loop through characters in this branch of the trie */\n\n        /* We take the min and max for this branch and combine to find the min\n         * and max for all branches processed so far */\n        if( cur == first ) {\n            trie->minlen = minchars;\n            trie->maxlen = maxchars;\n        } else if (minchars < trie->minlen) {\n            trie->minlen = minchars;\n        } else if (maxchars > trie->maxlen) {\n            trie->maxlen = maxchars;\n        }\n    } /* end first pass */\n    DEBUG_TRIE_COMPILE_r(\n        Perl_re_indentf( aTHX_\n                \"TRIE(%s): W:%d C:%d Uq:%d Min:%d Max:%d\\n\",\n                depth+1,\n                ( widecharmap ? \"UTF8\" : \"NATIVE\" ), (int)word_count,\n\t\t(int)TRIE_CHARCOUNT(trie), trie->uniquecharcount,\n\t\t(int)trie->minlen, (int)trie->maxlen )\n    );\n\n    /*\n        We now know what we are dealing with in terms of unique chars and\n        string sizes so we can calculate how much memory a naive\n        representation using a flat table  will take. If it's over a reasonable\n        limit (as specified by ${^RE_TRIE_MAXBUF}) we use a more memory\n        conservative but potentially much slower representation using an array\n        of lists.\n\n        At the end we convert both representations into the same compressed\n        form that will be used in regexec.c for matching with. The latter\n        is a form that cannot be used to construct with but has memory\n        properties similar to the list form and access properties similar\n        to the table form making it both suitable for fast searches and\n        small enough that its feasable to store for the duration of a program.\n\n        See the comment in the code where the compressed table is produced\n        inplace from the flat tabe representation for an explanation of how\n        the compression works.\n\n    */\n\n\n    Newx(prev_states, TRIE_CHARCOUNT(trie) + 2, U32);\n    prev_states[1] = 0;\n\n    if ( (IV)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount + 1)\n                                                    > SvIV(re_trie_maxbuff) )\n    {\n        /*\n            Second Pass -- Array Of Lists Representation\n\n            Each state will be represented by a list of charid:state records\n            (reg_trie_trans_le) the first such element holds the CUR and LEN\n            points of the allocated array. (See defines above).\n\n            We build the initial structure using the lists, and then convert\n            it into the compressed table form which allows faster lookups\n            (but cant be modified once converted).\n        */\n\n        STRLEN transcount = 1;\n\n        DEBUG_TRIE_COMPILE_MORE_r( Perl_re_indentf( aTHX_  \"Compiling trie using list compiler\\n\",\n            depth+1));\n\n\ttrie->states = (reg_trie_state *)\n\t    PerlMemShared_calloc( TRIE_CHARCOUNT(trie) + 2,\n\t\t\t\t  sizeof(reg_trie_state) );\n        TRIE_LIST_NEW(1);\n        next_alloc = 2;\n\n        for ( cur = first ; cur < last ; cur = regnext( cur ) ) {\n\n            regnode *noper   = NEXTOPER( cur );\n\t    U32 state        = 1;         /* required init */\n\t    U16 charid       = 0;         /* sanity init */\n            U32 wordlen      = 0;         /* required init */\n\n            if (OP(noper) == NOTHING) {\n                regnode *noper_next= regnext(noper);\n                if (noper_next < tail)\n                    noper= noper_next;\n                /* we will undo this assignment if noper does not\n                 * point at a trieable type in the else clause of\n                 * the following statement. */\n            }\n\n            if (    noper < tail\n                && (    OP(noper) == flags\n                    || (flags == EXACT && OP(noper) == EXACT_ONLY8)\n                    || (flags == EXACTFU && (   OP(noper) == EXACTFU_ONLY8\n                                             || OP(noper) == EXACTFUP))))\n            {\n                const U8 *uc= (U8*)STRING(noper);\n                const U8 *e= uc + STR_LEN(noper);\n\n                for ( ; uc < e ; uc += len ) {\n\n                    TRIE_READ_CHAR;\n\n                    if ( uvc < 256 ) {\n                        charid = trie->charmap[ uvc ];\n\t\t    } else {\n                        SV** const svpp = hv_fetch( widecharmap,\n                                                    (char*)&uvc,\n                                                    sizeof( UV ),\n                                                    0);\n                        if ( !svpp ) {\n                            charid = 0;\n                        } else {\n                            charid=(U16)SvIV( *svpp );\n                        }\n\t\t    }\n                    /* charid is now 0 if we dont know the char read, or\n                     * nonzero if we do */\n                    if ( charid ) {\n\n                        U16 check;\n                        U32 newstate = 0;\n\n                        charid--;\n                        if ( !trie->states[ state ].trans.list ) {\n                            TRIE_LIST_NEW( state );\n\t\t\t}\n                        for ( check = 1;\n                              check <= TRIE_LIST_USED( state );\n                              check++ )\n                        {\n                            if ( TRIE_LIST_ITEM( state, check ).forid\n                                                                    == charid )\n                            {\n                                newstate = TRIE_LIST_ITEM( state, check ).newstate;\n                                break;\n                            }\n                        }\n                        if ( ! newstate ) {\n                            newstate = next_alloc++;\n\t\t\t    prev_states[newstate] = state;\n                            TRIE_LIST_PUSH( state, charid, newstate );\n                            transcount++;\n                        }\n                        state = newstate;\n                    } else {\n                        Perl_croak( aTHX_ \"panic! In trie construction, no char mapping for %\" IVdf, uvc );\n\t\t    }\n\t\t}\n            } else {\n                /* If we end up here it is because we skipped past a NOTHING, but did not end up\n                 * on a trieable type. So we need to reset noper back to point at the first regop\n                 * in the branch before we call TRIE_HANDLE_WORD()\n                */\n                noper= NEXTOPER(cur);\n            }\n            TRIE_HANDLE_WORD(state);\n\n        } /* end second pass */\n\n        /* next alloc is the NEXT state to be allocated */\n        trie->statecount = next_alloc;\n        trie->states = (reg_trie_state *)\n\t    PerlMemShared_realloc( trie->states,\n\t\t\t\t   next_alloc\n\t\t\t\t   * sizeof(reg_trie_state) );\n\n        /* and now dump it out before we compress it */\n        DEBUG_TRIE_COMPILE_MORE_r(dump_trie_interim_list(trie, widecharmap,\n\t\t\t\t\t\t\t revcharmap, next_alloc,\n\t\t\t\t\t\t\t depth+1)\n        );\n\n        trie->trans = (reg_trie_trans *)\n\t    PerlMemShared_calloc( transcount, sizeof(reg_trie_trans) );\n        {\n            U32 state;\n            U32 tp = 0;\n            U32 zp = 0;\n\n\n            for( state=1 ; state < next_alloc ; state ++ ) {\n                U32 base=0;\n\n                /*\n                DEBUG_TRIE_COMPILE_MORE_r(\n                    Perl_re_printf( aTHX_  \"tp: %d zp: %d \",tp,zp)\n                );\n                */\n\n                if (trie->states[state].trans.list) {\n                    U16 minid=TRIE_LIST_ITEM( state, 1).forid;\n                    U16 maxid=minid;\n\t\t    U16 idx;\n\n                    for( idx = 2 ; idx <= TRIE_LIST_USED( state ) ; idx++ ) {\n\t\t\tconst U16 forid = TRIE_LIST_ITEM( state, idx).forid;\n\t\t\tif ( forid < minid ) {\n\t\t\t    minid=forid;\n\t\t\t} else if ( forid > maxid ) {\n\t\t\t    maxid=forid;\n\t\t\t}\n                    }\n                    if ( transcount < tp + maxid - minid + 1) {\n                        transcount *= 2;\n\t\t\ttrie->trans = (reg_trie_trans *)\n\t\t\t    PerlMemShared_realloc( trie->trans,\n\t\t\t\t\t\t     transcount\n\t\t\t\t\t\t     * sizeof(reg_trie_trans) );\n                        Zero( trie->trans + (transcount / 2),\n                              transcount / 2,\n                              reg_trie_trans );\n                    }\n                    base = trie->uniquecharcount + tp - minid;\n                    if ( maxid == minid ) {\n                        U32 set = 0;\n                        for ( ; zp < tp ; zp++ ) {\n                            if ( ! trie->trans[ zp ].next ) {\n                                base = trie->uniquecharcount + zp - minid;\n                                trie->trans[ zp ].next = TRIE_LIST_ITEM( state,\n                                                                   1).newstate;\n                                trie->trans[ zp ].check = state;\n                                set = 1;\n                                break;\n                            }\n                        }\n                        if ( !set ) {\n                            trie->trans[ tp ].next = TRIE_LIST_ITEM( state,\n                                                                   1).newstate;\n                            trie->trans[ tp ].check = state;\n                            tp++;\n                            zp = tp;\n                        }\n                    } else {\n                        for ( idx=1; idx <= TRIE_LIST_USED( state ) ; idx++ ) {\n                            const U32 tid = base\n                                           - trie->uniquecharcount\n                                           + TRIE_LIST_ITEM( state, idx ).forid;\n                            trie->trans[ tid ].next = TRIE_LIST_ITEM( state,\n                                                                idx ).newstate;\n                            trie->trans[ tid ].check = state;\n                        }\n                        tp += ( maxid - minid + 1 );\n                    }\n                    Safefree(trie->states[ state ].trans.list);\n                }\n                /*\n                DEBUG_TRIE_COMPILE_MORE_r(\n                    Perl_re_printf( aTHX_  \" base: %d\\n\",base);\n                );\n                */\n                trie->states[ state ].trans.base=base;\n            }\n            trie->lasttrans = tp + 1;\n        }\n    } else {\n        /*\n           Second Pass -- Flat Table Representation.\n\n           we dont use the 0 slot of either trans[] or states[] so we add 1 to\n           each.  We know that we will need Charcount+1 trans at most to store\n           the data (one row per char at worst case) So we preallocate both\n           structures assuming worst case.\n\n           We then construct the trie using only the .next slots of the entry\n           structs.\n\n           We use the .check field of the first entry of the node temporarily\n           to make compression both faster and easier by keeping track of how\n           many non zero fields are in the node.\n\n           Since trans are numbered from 1 any 0 pointer in the table is a FAIL\n           transition.\n\n           There are two terms at use here: state as a TRIE_NODEIDX() which is\n           a number representing the first entry of the node, and state as a\n           TRIE_NODENUM() which is the trans number. state 1 is TRIE_NODEIDX(1)\n           and TRIE_NODENUM(1), state 2 is TRIE_NODEIDX(2) and TRIE_NODENUM(3)\n           if there are 2 entrys per node. eg:\n\n             A B       A B\n          1. 2 4    1. 3 7\n          2. 0 3    3. 0 5\n          3. 0 0    5. 0 0\n          4. 0 0    7. 0 0\n\n           The table is internally in the right hand, idx form. However as we\n           also have to deal with the states array which is indexed by nodenum\n           we have to use TRIE_NODENUM() to convert.\n\n        */\n        DEBUG_TRIE_COMPILE_MORE_r( Perl_re_indentf( aTHX_  \"Compiling trie using table compiler\\n\",\n            depth+1));\n\n\ttrie->trans = (reg_trie_trans *)\n\t    PerlMemShared_calloc( ( TRIE_CHARCOUNT(trie) + 1 )\n\t\t\t\t  * trie->uniquecharcount + 1,\n\t\t\t\t  sizeof(reg_trie_trans) );\n        trie->states = (reg_trie_state *)\n\t    PerlMemShared_calloc( TRIE_CHARCOUNT(trie) + 2,\n\t\t\t\t  sizeof(reg_trie_state) );\n        next_alloc = trie->uniquecharcount + 1;\n\n\n        for ( cur = first ; cur < last ; cur = regnext( cur ) ) {\n\n            regnode *noper   = NEXTOPER( cur );\n\n            U32 state        = 1;         /* required init */\n\n            U16 charid       = 0;         /* sanity init */\n            U32 accept_state = 0;         /* sanity init */\n\n            U32 wordlen      = 0;         /* required init */\n\n            if (OP(noper) == NOTHING) {\n                regnode *noper_next= regnext(noper);\n                if (noper_next < tail)\n                    noper= noper_next;\n                /* we will undo this assignment if noper does not\n                 * point at a trieable type in the else clause of\n                 * the following statement. */\n            }\n\n            if (    noper < tail\n                && (    OP(noper) == flags\n                    || (flags == EXACT && OP(noper) == EXACT_ONLY8)\n                    || (flags == EXACTFU && (   OP(noper) == EXACTFU_ONLY8\n                                             || OP(noper) == EXACTFUP))))\n            {\n                const U8 *uc= (U8*)STRING(noper);\n                const U8 *e= uc + STR_LEN(noper);\n\n                for ( ; uc < e ; uc += len ) {\n\n                    TRIE_READ_CHAR;\n\n                    if ( uvc < 256 ) {\n                        charid = trie->charmap[ uvc ];\n                    } else {\n                        SV* const * const svpp = hv_fetch( widecharmap,\n                                                           (char*)&uvc,\n                                                           sizeof( UV ),\n                                                           0);\n                        charid = svpp ? (U16)SvIV(*svpp) : 0;\n                    }\n                    if ( charid ) {\n                        charid--;\n                        if ( !trie->trans[ state + charid ].next ) {\n                            trie->trans[ state + charid ].next = next_alloc;\n                            trie->trans[ state ].check++;\n\t\t\t    prev_states[TRIE_NODENUM(next_alloc)]\n\t\t\t\t    = TRIE_NODENUM(state);\n                            next_alloc += trie->uniquecharcount;\n                        }\n                        state = trie->trans[ state + charid ].next;\n                    } else {\n                        Perl_croak( aTHX_ \"panic! In trie construction, no char mapping for %\" IVdf, uvc );\n                    }\n                    /* charid is now 0 if we dont know the char read, or\n                     * nonzero if we do */\n                }\n            } else {\n                /* If we end up here it is because we skipped past a NOTHING, but did not end up\n                 * on a trieable type. So we need to reset noper back to point at the first regop\n                 * in the branch before we call TRIE_HANDLE_WORD().\n                */\n                noper= NEXTOPER(cur);\n            }\n            accept_state = TRIE_NODENUM( state );\n            TRIE_HANDLE_WORD(accept_state);\n\n        } /* end second pass */\n\n        /* and now dump it out before we compress it */\n        DEBUG_TRIE_COMPILE_MORE_r(dump_trie_interim_table(trie, widecharmap,\n\t\t\t\t\t\t\t  revcharmap,\n\t\t\t\t\t\t\t  next_alloc, depth+1));\n\n        {\n        /*\n           * Inplace compress the table.*\n\n           For sparse data sets the table constructed by the trie algorithm will\n           be mostly 0/FAIL transitions or to put it another way mostly empty.\n           (Note that leaf nodes will not contain any transitions.)\n\n           This algorithm compresses the tables by eliminating most such\n           transitions, at the cost of a modest bit of extra work during lookup:\n\n           - Each states[] entry contains a .base field which indicates the\n           index in the state[] array wheres its transition data is stored.\n\n           - If .base is 0 there are no valid transitions from that node.\n\n           - If .base is nonzero then charid is added to it to find an entry in\n           the trans array.\n\n           -If trans[states[state].base+charid].check!=state then the\n           transition is taken to be a 0/Fail transition. Thus if there are fail\n           transitions at the front of the node then the .base offset will point\n           somewhere inside the previous nodes data (or maybe even into a node\n           even earlier), but the .check field determines if the transition is\n           valid.\n\n           XXX - wrong maybe?\n           The following process inplace converts the table to the compressed\n           table: We first do not compress the root node 1,and mark all its\n           .check pointers as 1 and set its .base pointer as 1 as well. This\n           allows us to do a DFA construction from the compressed table later,\n           and ensures that any .base pointers we calculate later are greater\n           than 0.\n\n           - We set 'pos' to indicate the first entry of the second node.\n\n           - We then iterate over the columns of the node, finding the first and\n           last used entry at l and m. We then copy l..m into pos..(pos+m-l),\n           and set the .check pointers accordingly, and advance pos\n           appropriately and repreat for the next node. Note that when we copy\n           the next pointers we have to convert them from the original\n           NODEIDX form to NODENUM form as the former is not valid post\n           compression.\n\n           - If a node has no transitions used we mark its base as 0 and do not\n           advance the pos pointer.\n\n           - If a node only has one transition we use a second pointer into the\n           structure to fill in allocated fail transitions from other states.\n           This pointer is independent of the main pointer and scans forward\n           looking for null transitions that are allocated to a state. When it\n           finds one it writes the single transition into the \"hole\".  If the\n           pointer doesnt find one the single transition is appended as normal.\n\n           - Once compressed we can Renew/realloc the structures to release the\n           excess space.\n\n           See \"Table-Compression Methods\" in sec 3.9 of the Red Dragon,\n           specifically Fig 3.47 and the associated pseudocode.\n\n           demq\n        */\n        const U32 laststate = TRIE_NODENUM( next_alloc );\n\tU32 state, charid;\n        U32 pos = 0, zp=0;\n        trie->statecount = laststate;\n\n        for ( state = 1 ; state < laststate ; state++ ) {\n            U8 flag = 0;\n\t    const U32 stateidx = TRIE_NODEIDX( state );\n\t    const U32 o_used = trie->trans[ stateidx ].check;\n\t    U32 used = trie->trans[ stateidx ].check;\n            trie->trans[ stateidx ].check = 0;\n\n            for ( charid = 0;\n                  used && charid < trie->uniquecharcount;\n                  charid++ )\n            {\n                if ( flag || trie->trans[ stateidx + charid ].next ) {\n                    if ( trie->trans[ stateidx + charid ].next ) {\n                        if (o_used == 1) {\n                            for ( ; zp < pos ; zp++ ) {\n                                if ( ! trie->trans[ zp ].next ) {\n                                    break;\n                                }\n                            }\n                            trie->states[ state ].trans.base\n                                                    = zp\n                                                      + trie->uniquecharcount\n                                                      - charid ;\n                            trie->trans[ zp ].next\n                                = SAFE_TRIE_NODENUM( trie->trans[ stateidx\n                                                             + charid ].next );\n                            trie->trans[ zp ].check = state;\n                            if ( ++zp > pos ) pos = zp;\n                            break;\n                        }\n                        used--;\n                    }\n                    if ( !flag ) {\n                        flag = 1;\n                        trie->states[ state ].trans.base\n                                       = pos + trie->uniquecharcount - charid ;\n                    }\n                    trie->trans[ pos ].next\n                        = SAFE_TRIE_NODENUM(\n                                       trie->trans[ stateidx + charid ].next );\n                    trie->trans[ pos ].check = state;\n                    pos++;\n                }\n            }\n        }\n        trie->lasttrans = pos + 1;\n        trie->states = (reg_trie_state *)\n\t    PerlMemShared_realloc( trie->states, laststate\n\t\t\t\t   * sizeof(reg_trie_state) );\n        DEBUG_TRIE_COMPILE_MORE_r(\n            Perl_re_indentf( aTHX_  \"Alloc: %d Orig: %\" IVdf \" elements, Final:%\" IVdf \". Savings of %%%5.2f\\n\",\n                depth+1,\n                (int)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount\n                       + 1 ),\n                (IV)next_alloc,\n                (IV)pos,\n                ( ( next_alloc - pos ) * 100 ) / (double)next_alloc );\n            );\n\n        } /* end table compress */\n    }\n    DEBUG_TRIE_COMPILE_MORE_r(\n            Perl_re_indentf( aTHX_  \"Statecount:%\" UVxf \" Lasttrans:%\" UVxf \"\\n\",\n                depth+1,\n                (UV)trie->statecount,\n                (UV)trie->lasttrans)\n    );\n    /* resize the trans array to remove unused space */\n    trie->trans = (reg_trie_trans *)\n\tPerlMemShared_realloc( trie->trans, trie->lasttrans\n\t\t\t       * sizeof(reg_trie_trans) );\n\n    {   /* Modify the program and insert the new TRIE node */\n        U8 nodetype =(U8)(flags & 0xFF);\n        char *str=NULL;\n\n#ifdef DEBUGGING\n        regnode *optimize = NULL;\n#ifdef RE_TRACK_PATTERN_OFFSETS\n\n        U32 mjd_offset = 0;\n        U32 mjd_nodelen = 0;\n#endif /* RE_TRACK_PATTERN_OFFSETS */\n#endif /* DEBUGGING */\n        /*\n           This means we convert either the first branch or the first Exact,\n           depending on whether the thing following (in 'last') is a branch\n           or not and whther first is the startbranch (ie is it a sub part of\n           the alternation or is it the whole thing.)\n           Assuming its a sub part we convert the EXACT otherwise we convert\n           the whole branch sequence, including the first.\n         */\n        /* Find the node we are going to overwrite */\n        if ( first != startbranch || OP( last ) == BRANCH ) {\n            /* branch sub-chain */\n            NEXT_OFF( first ) = (U16)(last - first);\n#ifdef RE_TRACK_PATTERN_OFFSETS\n            DEBUG_r({\n                mjd_offset= Node_Offset((convert));\n                mjd_nodelen= Node_Length((convert));\n            });\n#endif\n            /* whole branch chain */\n        }\n#ifdef RE_TRACK_PATTERN_OFFSETS\n        else {\n            DEBUG_r({\n                const  regnode *nop = NEXTOPER( convert );\n                mjd_offset= Node_Offset((nop));\n                mjd_nodelen= Node_Length((nop));\n            });\n        }\n        DEBUG_OPTIMISE_r(\n            Perl_re_indentf( aTHX_  \"MJD offset:%\" UVuf \" MJD length:%\" UVuf \"\\n\",\n                depth+1,\n                (UV)mjd_offset, (UV)mjd_nodelen)\n        );\n#endif\n        /* But first we check to see if there is a common prefix we can\n           split out as an EXACT and put in front of the TRIE node.  */\n        trie->startstate= 1;\n        if ( trie->bitmap && !widecharmap && !trie->jump  ) {\n            /* we want to find the first state that has more than\n             * one transition, if that state is not the first state\n             * then we have a common prefix which we can remove.\n             */\n            U32 state;\n            for ( state = 1 ; state < trie->statecount-1 ; state++ ) {\n                U32 ofs = 0;\n                I32 first_ofs = -1; /* keeps track of the ofs of the first\n                                       transition, -1 means none */\n                U32 count = 0;\n                const U32 base = trie->states[ state ].trans.base;\n\n                /* does this state terminate an alternation? */\n                if ( trie->states[state].wordnum )\n                        count = 1;\n\n                for ( ofs = 0 ; ofs < trie->uniquecharcount ; ofs++ ) {\n                    if ( ( base + ofs >= trie->uniquecharcount ) &&\n                         ( base + ofs - trie->uniquecharcount < trie->lasttrans ) &&\n                         trie->trans[ base + ofs - trie->uniquecharcount ].check == state )\n                    {\n                        if ( ++count > 1 ) {\n                            /* we have more than one transition */\n                            SV **tmp;\n                            U8 *ch;\n                            /* if this is the first state there is no common prefix\n                             * to extract, so we can exit */\n                            if ( state == 1 ) break;\n                            tmp = av_fetch( revcharmap, ofs, 0);\n                            ch = (U8*)SvPV_nolen_const( *tmp );\n\n                            /* if we are on count 2 then we need to initialize the\n                             * bitmap, and store the previous char if there was one\n                             * in it*/\n                            if ( count == 2 ) {\n                                /* clear the bitmap */\n                                Zero(trie->bitmap, ANYOF_BITMAP_SIZE, char);\n                                DEBUG_OPTIMISE_r(\n                                    Perl_re_indentf( aTHX_  \"New Start State=%\" UVuf \" Class: [\",\n                                        depth+1,\n                                        (UV)state));\n                                if (first_ofs >= 0) {\n                                    SV ** const tmp = av_fetch( revcharmap, first_ofs, 0);\n\t\t\t\t    const U8 * const ch = (U8*)SvPV_nolen_const( *tmp );\n\n                                    TRIE_BITMAP_SET_FOLDED(trie,*ch, folder);\n                                    DEBUG_OPTIMISE_r(\n                                        Perl_re_printf( aTHX_  \"%s\", (char*)ch)\n                                    );\n\t\t\t\t}\n\t\t\t    }\n                            /* store the current firstchar in the bitmap */\n                            TRIE_BITMAP_SET_FOLDED(trie,*ch, folder);\n                            DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"%s\", ch));\n\t\t\t}\n                        first_ofs = ofs;\n\t\t    }\n                }\n                if ( count == 1 ) {\n                    /* This state has only one transition, its transition is part\n                     * of a common prefix - we need to concatenate the char it\n                     * represents to what we have so far. */\n                    SV **tmp = av_fetch( revcharmap, first_ofs, 0);\n                    STRLEN len;\n                    char *ch = SvPV( *tmp, len );\n                    DEBUG_OPTIMISE_r({\n                        SV *sv=sv_newmortal();\n                        Perl_re_indentf( aTHX_  \"Prefix State: %\" UVuf \" Ofs:%\" UVuf \" Char='%s'\\n\",\n                            depth+1,\n                            (UV)state, (UV)first_ofs,\n                            pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), 6,\n\t                        PL_colors[0], PL_colors[1],\n\t                        (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |\n\t                        PERL_PV_ESCAPE_FIRSTCHAR\n                            )\n                        );\n                    });\n                    if ( state==1 ) {\n                        OP( convert ) = nodetype;\n                        str=STRING(convert);\n                        STR_LEN(convert)=0;\n                    }\n                    STR_LEN(convert) += len;\n                    while (len--)\n                        *str++ = *ch++;\n\t\t} else {\n#ifdef DEBUGGING\n\t\t    if (state>1)\n                        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"]\\n\"));\n#endif\n\t\t    break;\n\t\t}\n\t    }\n\t    trie->prefixlen = (state-1);\n            if (str) {\n                regnode *n = convert+NODE_SZ_STR(convert);\n                NEXT_OFF(convert) = NODE_SZ_STR(convert);\n                trie->startstate = state;\n                trie->minlen -= (state - 1);\n                trie->maxlen -= (state - 1);\n#ifdef DEBUGGING\n               /* At least the UNICOS C compiler choked on this\n                * being argument to DEBUG_r(), so let's just have\n                * it right here. */\n               if (\n#ifdef PERL_EXT_RE_BUILD\n                   1\n#else\n                   DEBUG_r_TEST\n#endif\n                   ) {\n                   regnode *fix = convert;\n                   U32 word = trie->wordcount;\n#ifdef RE_TRACK_PATTERN_OFFSETS\n                   mjd_nodelen++;\n#endif\n                   Set_Node_Offset_Length(convert, mjd_offset, state - 1);\n                   while( ++fix < n ) {\n                       Set_Node_Offset_Length(fix, 0, 0);\n                   }\n                   while (word--) {\n                       SV ** const tmp = av_fetch( trie_words, word, 0 );\n                       if (tmp) {\n                           if ( STR_LEN(convert) <= SvCUR(*tmp) )\n                               sv_chop(*tmp, SvPV_nolen(*tmp) + STR_LEN(convert));\n                           else\n                               sv_chop(*tmp, SvPV_nolen(*tmp) + SvCUR(*tmp));\n                       }\n                   }\n               }\n#endif\n                if (trie->maxlen) {\n                    convert = n;\n\t\t} else {\n                    NEXT_OFF(convert) = (U16)(tail - convert);\n                    DEBUG_r(optimize= n);\n                }\n            }\n        }\n        if (!jumper)\n            jumper = last;\n        if ( trie->maxlen ) {\n\t    NEXT_OFF( convert ) = (U16)(tail - convert);\n\t    ARG_SET( convert, data_slot );\n\t    /* Store the offset to the first unabsorbed branch in\n\t       jump[0], which is otherwise unused by the jump logic.\n\t       We use this when dumping a trie and during optimisation. */\n\t    if (trie->jump)\n\t        trie->jump[0] = (U16)(nextbranch - convert);\n\n            /* If the start state is not accepting (meaning there is no empty string/NOTHING)\n\t     *   and there is a bitmap\n\t     *   and the first \"jump target\" node we found leaves enough room\n\t     * then convert the TRIE node into a TRIEC node, with the bitmap\n\t     * embedded inline in the opcode - this is hypothetically faster.\n\t     */\n            if ( !trie->states[trie->startstate].wordnum\n\t\t && trie->bitmap\n\t\t && ( (char *)jumper - (char *)convert) >= (int)sizeof(struct regnode_charclass) )\n            {\n                OP( convert ) = TRIEC;\n                Copy(trie->bitmap, ((struct regnode_charclass *)convert)->bitmap, ANYOF_BITMAP_SIZE, char);\n                PerlMemShared_free(trie->bitmap);\n                trie->bitmap= NULL;\n            } else\n                OP( convert ) = TRIE;\n\n            /* store the type in the flags */\n            convert->flags = nodetype;\n            DEBUG_r({\n            optimize = convert\n                      + NODE_STEP_REGNODE\n                      + regarglen[ OP( convert ) ];\n            });\n            /* XXX We really should free up the resource in trie now,\n                   as we won't use them - (which resources?) dmq */\n        }\n        /* needed for dumping*/\n        DEBUG_r(if (optimize) {\n            regnode *opt = convert;\n\n            while ( ++opt < optimize) {\n                Set_Node_Offset_Length(opt, 0, 0);\n            }\n            /*\n                Try to clean up some of the debris left after the\n                optimisation.\n             */\n            while( optimize < jumper ) {\n                Track_Code( mjd_nodelen += Node_Length((optimize)); );\n                OP( optimize ) = OPTIMIZED;\n                Set_Node_Offset_Length(optimize, 0, 0);\n                optimize++;\n            }\n            Set_Node_Offset_Length(convert, mjd_offset, mjd_nodelen);\n        });\n    } /* end node insert */\n\n    /*  Finish populating the prev field of the wordinfo array.  Walk back\n     *  from each accept state until we find another accept state, and if\n     *  so, point the first word's .prev field at the second word. If the\n     *  second already has a .prev field set, stop now. This will be the\n     *  case either if we've already processed that word's accept state,\n     *  or that state had multiple words, and the overspill words were\n     *  already linked up earlier.\n     */\n    {\n\tU16 word;\n\tU32 state;\n\tU16 prev;\n\n\tfor (word=1; word <= trie->wordcount; word++) {\n\t    prev = 0;\n\t    if (trie->wordinfo[word].prev)\n\t\tcontinue;\n\t    state = trie->wordinfo[word].accept;\n\t    while (state) {\n\t\tstate = prev_states[state];\n\t\tif (!state)\n\t\t    break;\n\t\tprev = trie->states[state].wordnum;\n\t\tif (prev)\n\t\t    break;\n\t    }\n\t    trie->wordinfo[word].prev = prev;\n\t}\n\tSafefree(prev_states);\n    }\n\n\n    /* and now dump out the compressed format */\n    DEBUG_TRIE_COMPILE_r(dump_trie(trie, widecharmap, revcharmap, depth+1));\n\n    RExC_rxi->data->data[ data_slot + 1 ] = (void*)widecharmap;\n#ifdef DEBUGGING\n    RExC_rxi->data->data[ data_slot + TRIE_WORDS_OFFSET ] = (void*)trie_words;\n    RExC_rxi->data->data[ data_slot + 3 ] = (void*)revcharmap;\n#else\n    SvREFCNT_dec_NN(revcharmap);\n#endif\n    return trie->jump\n           ? MADE_JUMP_TRIE\n           : trie->startstate>1\n             ? MADE_EXACT_TRIE\n             : MADE_TRIE;\n}\n\nSTATIC regnode *\nS_construct_ahocorasick_from_trie(pTHX_ RExC_state_t *pRExC_state, regnode *source, U32 depth)\n{\n/* The Trie is constructed and compressed now so we can build a fail array if\n * it's needed\n\n   This is basically the Aho-Corasick algorithm. Its from exercise 3.31 and\n   3.32 in the\n   \"Red Dragon\" -- Compilers, principles, techniques, and tools. Aho, Sethi,\n   Ullman 1985/88\n   ISBN 0-201-10088-6\n\n   We find the fail state for each state in the trie, this state is the longest\n   proper suffix of the current state's 'word' that is also a proper prefix of\n   another word in our trie. State 1 represents the word '' and is thus the\n   default fail state. This allows the DFA not to have to restart after its\n   tried and failed a word at a given point, it simply continues as though it\n   had been matching the other word in the first place.\n   Consider\n      'abcdgu'=~/abcdefg|cdgu/\n   When we get to 'd' we are still matching the first word, we would encounter\n   'g' which would fail, which would bring us to the state representing 'd' in\n   the second word where we would try 'g' and succeed, proceeding to match\n   'cdgu'.\n */\n /* add a fail transition */\n    const U32 trie_offset = ARG(source);\n    reg_trie_data *trie=(reg_trie_data *)RExC_rxi->data->data[trie_offset];\n    U32 *q;\n    const U32 ucharcount = trie->uniquecharcount;\n    const U32 numstates = trie->statecount;\n    const U32 ubound = trie->lasttrans + ucharcount;\n    U32 q_read = 0;\n    U32 q_write = 0;\n    U32 charid;\n    U32 base = trie->states[ 1 ].trans.base;\n    U32 *fail;\n    reg_ac_data *aho;\n    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN(\"T\"));\n    regnode *stclass;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_CONSTRUCT_AHOCORASICK_FROM_TRIE;\n    PERL_UNUSED_CONTEXT;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    if ( OP(source) == TRIE ) {\n        struct regnode_1 *op = (struct regnode_1 *)\n            PerlMemShared_calloc(1, sizeof(struct regnode_1));\n        StructCopy(source, op, struct regnode_1);\n        stclass = (regnode *)op;\n    } else {\n        struct regnode_charclass *op = (struct regnode_charclass *)\n            PerlMemShared_calloc(1, sizeof(struct regnode_charclass));\n        StructCopy(source, op, struct regnode_charclass);\n        stclass = (regnode *)op;\n    }\n    OP(stclass)+=2; /* convert the TRIE type to its AHO-CORASICK equivalent */\n\n    ARG_SET( stclass, data_slot );\n    aho = (reg_ac_data *) PerlMemShared_calloc( 1, sizeof(reg_ac_data) );\n    RExC_rxi->data->data[ data_slot ] = (void*)aho;\n    aho->trie=trie_offset;\n    aho->states=(reg_trie_state *)PerlMemShared_malloc( numstates * sizeof(reg_trie_state) );\n    Copy( trie->states, aho->states, numstates, reg_trie_state );\n    Newx( q, numstates, U32);\n    aho->fail = (U32 *) PerlMemShared_calloc( numstates, sizeof(U32) );\n    aho->refcount = 1;\n    fail = aho->fail;\n    /* initialize fail[0..1] to be 1 so that we always have\n       a valid final fail state */\n    fail[ 0 ] = fail[ 1 ] = 1;\n\n    for ( charid = 0; charid < ucharcount ; charid++ ) {\n\tconst U32 newstate = TRIE_TRANS_STATE( 1, base, ucharcount, charid, 0 );\n\tif ( newstate ) {\n            q[ q_write ] = newstate;\n            /* set to point at the root */\n            fail[ q[ q_write++ ] ]=1;\n        }\n    }\n    while ( q_read < q_write) {\n\tconst U32 cur = q[ q_read++ % numstates ];\n        base = trie->states[ cur ].trans.base;\n\n        for ( charid = 0 ; charid < ucharcount ; charid++ ) {\n\t    const U32 ch_state = TRIE_TRANS_STATE( cur, base, ucharcount, charid, 1 );\n\t    if (ch_state) {\n                U32 fail_state = cur;\n                U32 fail_base;\n                do {\n                    fail_state = fail[ fail_state ];\n                    fail_base = aho->states[ fail_state ].trans.base;\n                } while ( !TRIE_TRANS_STATE( fail_state, fail_base, ucharcount, charid, 1 ) );\n\n                fail_state = TRIE_TRANS_STATE( fail_state, fail_base, ucharcount, charid, 1 );\n                fail[ ch_state ] = fail_state;\n                if ( !aho->states[ ch_state ].wordnum && aho->states[ fail_state ].wordnum )\n                {\n                        aho->states[ ch_state ].wordnum =  aho->states[ fail_state ].wordnum;\n                }\n                q[ q_write++ % numstates] = ch_state;\n            }\n        }\n    }\n    /* restore fail[0..1] to 0 so that we \"fall out\" of the AC loop\n       when we fail in state 1, this allows us to use the\n       charclass scan to find a valid start char. This is based on the principle\n       that theres a good chance the string being searched contains lots of stuff\n       that cant be a start char.\n     */\n    fail[ 0 ] = fail[ 1 ] = 0;\n    DEBUG_TRIE_COMPILE_r({\n        Perl_re_indentf( aTHX_  \"Stclass Failtable (%\" UVuf \" states): 0\",\n                      depth, (UV)numstates\n        );\n        for( q_read=1; q_read<numstates; q_read++ ) {\n            Perl_re_printf( aTHX_  \", %\" UVuf, (UV)fail[q_read]);\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    });\n    Safefree(q);\n    /*RExC_seen |= REG_TRIEDFA_SEEN;*/\n    return stclass;\n}\n\n\n/* The below joins as many adjacent EXACTish nodes as possible into a single\n * one.  The regop may be changed if the node(s) contain certain sequences that\n * require special handling.  The joining is only done if:\n * 1) there is room in the current conglomerated node to entirely contain the\n *    next one.\n * 2) they are compatible node types\n *\n * The adjacent nodes actually may be separated by NOTHING-kind nodes, and\n * these get optimized out\n *\n * XXX khw thinks this should be enhanced to fill EXACT (at least) nodes as full\n * as possible, even if that means splitting an existing node so that its first\n * part is moved to the preceeding node.  This would maximise the efficiency of\n * memEQ during matching.\n *\n * If a node is to match under /i (folded), the number of characters it matches\n * can be different than its character length if it contains a multi-character\n * fold.  *min_subtract is set to the total delta number of characters of the\n * input nodes.\n *\n * And *unfolded_multi_char is set to indicate whether or not the node contains\n * an unfolded multi-char fold.  This happens when it won't be known until\n * runtime whether the fold is valid or not; namely\n *  1) for EXACTF nodes that contain LATIN SMALL LETTER SHARP S, as only if the\n *      target string being matched against turns out to be UTF-8 is that fold\n *      valid; or\n *  2) for EXACTFL nodes whose folding rules depend on the locale in force at\n *      runtime.\n * (Multi-char folds whose components are all above the Latin1 range are not\n * run-time locale dependent, and have already been folded by the time this\n * function is called.)\n *\n * This is as good a place as any to discuss the design of handling these\n * multi-character fold sequences.  It's been wrong in Perl for a very long\n * time.  There are three code points in Unicode whose multi-character folds\n * were long ago discovered to mess things up.  The previous designs for\n * dealing with these involved assigning a special node for them.  This\n * approach doesn't always work, as evidenced by this example:\n *      \"\\xDFs\" =~ /s\\xDF/ui    # Used to fail before these patches\n * Both sides fold to \"sss\", but if the pattern is parsed to create a node that\n * would match just the \\xDF, it won't be able to handle the case where a\n * successful match would have to cross the node's boundary.  The new approach\n * that hopefully generally solves the problem generates an EXACTFUP node\n * that is \"sss\" in this case.\n *\n * It turns out that there are problems with all multi-character folds, and not\n * just these three.  Now the code is general, for all such cases.  The\n * approach taken is:\n * 1)   This routine examines each EXACTFish node that could contain multi-\n *      character folded sequences.  Since a single character can fold into\n *      such a sequence, the minimum match length for this node is less than\n *      the number of characters in the node.  This routine returns in\n *      *min_subtract how many characters to subtract from the the actual\n *      length of the string to get a real minimum match length; it is 0 if\n *      there are no multi-char foldeds.  This delta is used by the caller to\n *      adjust the min length of the match, and the delta between min and max,\n *      so that the optimizer doesn't reject these possibilities based on size\n *      constraints.\n *\n * 2)   For the sequence involving the LATIN SMALL LETTER SHARP S (U+00DF)\n *      under /u, we fold it to 'ss' in regatom(), and in this routine, after\n *      joining, we scan for occurrences of the sequence 'ss' in non-UTF-8\n *      EXACTFU nodes.  The node type of such nodes is then changed to\n *      EXACTFUP, indicating it is problematic, and needs careful handling.\n *      (The procedures in step 1) above are sufficient to handle this case in\n *      UTF-8 encoded nodes.)  The reason this is problematic is that this is\n *      the only case where there is a possible fold length change in non-UTF-8\n *      patterns.  By reserving a special node type for problematic cases, the\n *      far more common regular EXACTFU nodes can be processed faster.\n *      regexec.c takes advantage of this.\n *\n *      EXACTFUP has been created as a grab-bag for (hopefully uncommon)\n *      problematic cases.   These all only occur when the pattern is not\n *      UTF-8.  In addition to the 'ss' sequence where there is a possible fold\n *      length change, it handles the situation where the string cannot be\n *      entirely folded.  The strings in an EXACTFish node are folded as much\n *      as possible during compilation in regcomp.c.  This saves effort in\n *      regex matching.  By using an EXACTFUP node when it is not possible to\n *      fully fold at compile time, regexec.c can know that everything in an\n *      EXACTFU node is folded, so folding can be skipped at runtime.  The only\n *      case where folding in EXACTFU nodes can't be done at compile time is\n *      the presumably uncommon MICRO SIGN, when the pattern isn't UTF-8.  This\n *      is because its fold requires UTF-8 to represent.  Thus EXACTFUP nodes\n *      handle two very different cases.  Alternatively, there could have been\n *      a node type where there are length changes, one for unfolded, and one\n *      for both.  If yet another special case needed to be created, the number\n *      of required node types would have to go to 7.  khw figures that even\n *      though there are plenty of node types to spare, that the maintenance\n *      cost wasn't worth the small speedup of doing it that way, especially\n *      since he thinks the MICRO SIGN is rarely encountered in practice.\n *\n *      There are other cases where folding isn't done at compile time, but\n *      none of them are under /u, and hence not for EXACTFU nodes.  The folds\n *      in EXACTFL nodes aren't known until runtime, and vary as the locale\n *      changes.  Some folds in EXACTF depend on if the runtime target string\n *      is UTF-8 or not.  (regatom() will create an EXACTFU node even under /di\n *      when no fold in it depends on the UTF-8ness of the target string.)\n *\n * 3)   A problem remains for unfolded multi-char folds. (These occur when the\n *      validity of the fold won't be known until runtime, and so must remain\n *      unfolded for now.  This happens for the sharp s in EXACTF and EXACTFAA\n *      nodes when the pattern isn't in UTF-8.  (Note, BTW, that there cannot\n *      be an EXACTF node with a UTF-8 pattern.)  They also occur for various\n *      folds in EXACTFL nodes, regardless of the UTF-ness of the pattern.)\n *      The reason this is a problem is that the optimizer part of regexec.c\n *      (probably unwittingly, in Perl_regexec_flags()) makes an assumption\n *      that a character in the pattern corresponds to at most a single\n *      character in the target string.  (And I do mean character, and not byte\n *      here, unlike other parts of the documentation that have never been\n *      updated to account for multibyte Unicode.)  Sharp s in EXACTF and\n *      EXACTFL nodes can match the two character string 'ss'; in EXACTFAA\n *      nodes it can match \"\\x{17F}\\x{17F}\".  These, along with other ones in\n *      EXACTFL nodes, violate the assumption, and they are the only instances\n *      where it is violated.  I'm reluctant to try to change the assumption,\n *      as the code involved is impenetrable to me (khw), so instead the code\n *      here punts.  This routine examines EXACTFL nodes, and (when the pattern\n *      isn't UTF-8) EXACTF and EXACTFAA for such unfolded folds, and returns a\n *      boolean indicating whether or not the node contains such a fold.  When\n *      it is true, the caller sets a flag that later causes the optimizer in\n *      this file to not set values for the floating and fixed string lengths,\n *      and thus avoids the optimizer code in regexec.c that makes the invalid\n *      assumption.  Thus, there is no optimization based on string lengths for\n *      EXACTFL nodes that contain these few folds, nor for non-UTF8-pattern\n *      EXACTF and EXACTFAA nodes that contain the sharp s.  (The reason the\n *      assumption is wrong only in these cases is that all other non-UTF-8\n *      folds are 1-1; and, for UTF-8 patterns, we pre-fold all other folds to\n *      their expanded versions.  (Again, we can't prefold sharp s to 'ss' in\n *      EXACTF nodes because we don't know at compile time if it actually\n *      matches 'ss' or not.  For EXACTF nodes it will match iff the target\n *      string is in UTF-8.  This is in contrast to EXACTFU nodes, where it\n *      always matches; and EXACTFAA where it never does.  In an EXACTFAA node\n *      in a UTF-8 pattern, sharp s is folded to \"\\x{17F}\\x{17F}, avoiding the\n *      problem; but in a non-UTF8 pattern, folding it to that above-Latin1\n *      string would require the pattern to be forced into UTF-8, the overhead\n *      of which we want to avoid.  Similarly the unfolded multi-char folds in\n *      EXACTFL nodes will match iff the locale at the time of match is a UTF-8\n *      locale.)\n *\n *      Similarly, the code that generates tries doesn't currently handle\n *      not-already-folded multi-char folds, and it looks like a pain to change\n *      that.  Therefore, trie generation of EXACTFAA nodes with the sharp s\n *      doesn't work.  Instead, such an EXACTFAA is turned into a new regnode,\n *      EXACTFAA_NO_TRIE, which the trie code knows not to handle.  Most people\n *      using /iaa matching will be doing so almost entirely with ASCII\n *      strings, so this should rarely be encountered in practice */\n\n#define JOIN_EXACT(scan,min_subtract,unfolded_multi_char, flags) \\\n    if (PL_regkind[OP(scan)] == EXACT) \\\n        join_exact(pRExC_state,(scan),(min_subtract),unfolded_multi_char, (flags), NULL, depth+1)\n\nSTATIC U32\nS_join_exact(pTHX_ RExC_state_t *pRExC_state, regnode *scan,\n                   UV *min_subtract, bool *unfolded_multi_char,\n                   U32 flags, regnode *val, U32 depth)\n{\n    /* Merge several consecutive EXACTish nodes into one. */\n\n    regnode *n = regnext(scan);\n    U32 stringok = 1;\n    regnode *next = scan + NODE_SZ_STR(scan);\n    U32 merged = 0;\n    U32 stopnow = 0;\n#ifdef DEBUGGING\n    regnode *stop = scan;\n    GET_RE_DEBUG_FLAGS_DECL;\n#else\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    PERL_ARGS_ASSERT_JOIN_EXACT;\n#ifndef EXPERIMENTAL_INPLACESCAN\n    PERL_UNUSED_ARG(flags);\n    PERL_UNUSED_ARG(val);\n#endif\n    DEBUG_PEEP(\"join\", scan, depth, 0);\n\n    assert(PL_regkind[OP(scan)] == EXACT);\n\n    /* Look through the subsequent nodes in the chain.  Skip NOTHING, merge\n     * EXACT ones that are mergeable to the current one. */\n    while (    n\n           && (    PL_regkind[OP(n)] == NOTHING\n               || (stringok && PL_regkind[OP(n)] == EXACT))\n           && NEXT_OFF(n)\n           && NEXT_OFF(scan) + NEXT_OFF(n) < I16_MAX)\n    {\n\n        if (OP(n) == TAIL || n > next)\n            stringok = 0;\n        if (PL_regkind[OP(n)] == NOTHING) {\n            DEBUG_PEEP(\"skip:\", n, depth, 0);\n            NEXT_OFF(scan) += NEXT_OFF(n);\n            next = n + NODE_STEP_REGNODE;\n#ifdef DEBUGGING\n            if (stringok)\n                stop = n;\n#endif\n            n = regnext(n);\n        }\n        else if (stringok) {\n            const unsigned int oldl = STR_LEN(scan);\n            regnode * const nnext = regnext(n);\n\n            /* XXX I (khw) kind of doubt that this works on platforms (should\n             * Perl ever run on one) where U8_MAX is above 255 because of lots\n             * of other assumptions */\n            /* Don't join if the sum can't fit into a single node */\n            if (oldl + STR_LEN(n) > U8_MAX)\n                break;\n\n            /* Joining something that requires UTF-8 with something that\n             * doesn't, means the result requires UTF-8. */\n            if (OP(scan) == EXACT && (OP(n) == EXACT_ONLY8)) {\n                OP(scan) = EXACT_ONLY8;\n            }\n            else if (OP(scan) == EXACT_ONLY8 && (OP(n) == EXACT)) {\n                ;   /* join is compatible, no need to change OP */\n            }\n            else if ((OP(scan) == EXACTFU) && (OP(n) == EXACTFU_ONLY8)) {\n                OP(scan) = EXACTFU_ONLY8;\n            }\n            else if ((OP(scan) == EXACTFU_ONLY8) && (OP(n) == EXACTFU)) {\n                ;   /* join is compatible, no need to change OP */\n            }\n            else if (OP(scan) == EXACTFU && OP(n) == EXACTFU) {\n                ;   /* join is compatible, no need to change OP */\n            }\n            else if (OP(scan) == EXACTFU && OP(n) == EXACTFU_S_EDGE) {\n\n                 /* Under /di, temporary EXACTFU_S_EDGE nodes are generated,\n                  * which can join with EXACTFU ones.  We check for this case\n                  * here.  These need to be resolved to either EXACTFU or\n                  * EXACTF at joining time.  They have nothing in them that\n                  * would forbid them from being the more desirable EXACTFU\n                  * nodes except that they begin and/or end with a single [Ss].\n                  * The reason this is problematic is because they could be\n                  * joined in this loop with an adjacent node that ends and/or\n                  * begins with [Ss] which would then form the sequence 'ss',\n                  * which matches differently under /di than /ui, in which case\n                  * EXACTFU can't be used.  If the 'ss' sequence doesn't get\n                  * formed, the nodes get absorbed into any adjacent EXACTFU\n                  * node.  And if the only adjacent node is EXACTF, they get\n                  * absorbed into that, under the theory that a longer node is\n                  * better than two shorter ones, even if one is EXACTFU.  Note\n                  * that EXACTFU_ONLY8 is generated only for UTF-8 patterns,\n                  * and the EXACTFU_S_EDGE ones only for non-UTF-8.  */\n\n                if (STRING(n)[STR_LEN(n)-1] == 's') {\n\n                    /* Here the joined node would end with 's'.  If the node\n                     * following the combination is an EXACTF one, it's better to\n                     * join this trailing edge 's' node with that one, leaving the\n                     * current one in 'scan' be the more desirable EXACTFU */\n                    if (OP(nnext) == EXACTF) {\n                        break;\n                    }\n\n                    OP(scan) = EXACTFU_S_EDGE;\n\n                }   /* Otherwise, the beginning 's' of the 2nd node just\n                       becomes an interior 's' in 'scan' */\n            }\n            else if (OP(scan) == EXACTF && OP(n) == EXACTF) {\n                ;   /* join is compatible, no need to change OP */\n            }\n            else if (OP(scan) == EXACTF && OP(n) == EXACTFU_S_EDGE) {\n\n                /* EXACTF nodes are compatible for joining with EXACTFU_S_EDGE\n                 * nodes.  But the latter nodes can be also joined with EXACTFU\n                 * ones, and that is a better outcome, so if the node following\n                 * 'n' is EXACTFU, quit now so that those two can be joined\n                 * later */\n                if (OP(nnext) == EXACTFU) {\n                    break;\n                }\n\n                /* The join is compatible, and the combined node will be\n                 * EXACTF.  (These don't care if they begin or end with 's' */\n            }\n            else if (OP(scan) == EXACTFU_S_EDGE && OP(n) == EXACTFU_S_EDGE) {\n                if (   STRING(scan)[STR_LEN(scan)-1] == 's'\n                    && STRING(n)[0] == 's')\n                {\n                    /* When combined, we have the sequence 'ss', which means we\n                     * have to remain /di */\n                    OP(scan) = EXACTF;\n                }\n            }\n            else if (OP(scan) == EXACTFU_S_EDGE && OP(n) == EXACTFU) {\n                if (STRING(n)[0] == 's') {\n                    ;   /* Here the join is compatible and the combined node\n                           starts with 's', no need to change OP */\n                }\n                else {  /* Now the trailing 's' is in the interior */\n                    OP(scan) = EXACTFU;\n                }\n            }\n            else if (OP(scan) == EXACTFU_S_EDGE && OP(n) == EXACTF) {\n\n                /* The join is compatible, and the combined node will be\n                 * EXACTF.  (These don't care if they begin or end with 's' */\n                OP(scan) = EXACTF;\n            }\n            else if (OP(scan) != OP(n)) {\n\n                /* The only other compatible joinings are the same node type */\n                break;\n            }\n\n            DEBUG_PEEP(\"merg\", n, depth, 0);\n            merged++;\n\n            NEXT_OFF(scan) += NEXT_OFF(n);\n            STR_LEN(scan) += STR_LEN(n);\n            next = n + NODE_SZ_STR(n);\n            /* Now we can overwrite *n : */\n            Move(STRING(n), STRING(scan) + oldl, STR_LEN(n), char);\n#ifdef DEBUGGING\n            stop = next - 1;\n#endif\n            n = nnext;\n            if (stopnow) break;\n        }\n\n#ifdef EXPERIMENTAL_INPLACESCAN\n\tif (flags && !NEXT_OFF(n)) {\n\t    DEBUG_PEEP(\"atch\", val, depth, 0);\n\t    if (reg_off_by_arg[OP(n)]) {\n\t\tARG_SET(n, val - n);\n\t    }\n\t    else {\n\t\tNEXT_OFF(n) = val - n;\n\t    }\n\t    stopnow = 1;\n\t}\n#endif\n    }\n\n    /* This temporary node can now be turned into EXACTFU, and must, as\n     * regexec.c doesn't handle it */\n    if (OP(scan) == EXACTFU_S_EDGE) {\n        OP(scan) = EXACTFU;\n    }\n\n    *min_subtract = 0;\n    *unfolded_multi_char = FALSE;\n\n    /* Here, all the adjacent mergeable EXACTish nodes have been merged.  We\n     * can now analyze for sequences of problematic code points.  (Prior to\n     * this final joining, sequences could have been split over boundaries, and\n     * hence missed).  The sequences only happen in folding, hence for any\n     * non-EXACT EXACTish node */\n    if (OP(scan) != EXACT && OP(scan) != EXACT_ONLY8 && OP(scan) != EXACTL) {\n        U8* s0 = (U8*) STRING(scan);\n        U8* s = s0;\n        U8* s_end = s0 + STR_LEN(scan);\n\n        int total_count_delta = 0;  /* Total delta number of characters that\n                                       multi-char folds expand to */\n\n\t/* One pass is made over the node's string looking for all the\n\t * possibilities.  To avoid some tests in the loop, there are two main\n\t * cases, for UTF-8 patterns (which can't have EXACTF nodes) and\n\t * non-UTF-8 */\n\tif (UTF) {\n            U8* folded = NULL;\n\n            if (OP(scan) == EXACTFL) {\n                U8 *d;\n\n                /* An EXACTFL node would already have been changed to another\n                 * node type unless there is at least one character in it that\n                 * is problematic; likely a character whose fold definition\n                 * won't be known until runtime, and so has yet to be folded.\n                 * For all but the UTF-8 locale, folds are 1-1 in length, but\n                 * to handle the UTF-8 case, we need to create a temporary\n                 * folded copy using UTF-8 locale rules in order to analyze it.\n                 * This is because our macros that look to see if a sequence is\n                 * a multi-char fold assume everything is folded (otherwise the\n                 * tests in those macros would be too complicated and slow).\n                 * Note that here, the non-problematic folds will have already\n                 * been done, so we can just copy such characters.  We actually\n                 * don't completely fold the EXACTFL string.  We skip the\n                 * unfolded multi-char folds, as that would just create work\n                 * below to figure out the size they already are */\n\n                Newx(folded, UTF8_MAX_FOLD_CHAR_EXPAND * STR_LEN(scan) + 1, U8);\n                d = folded;\n                while (s < s_end) {\n                    STRLEN s_len = UTF8SKIP(s);\n                    if (! is_PROBLEMATIC_LOCALE_FOLD_utf8(s)) {\n                        Copy(s, d, s_len, U8);\n                        d += s_len;\n                    }\n                    else if (is_FOLDS_TO_MULTI_utf8(s)) {\n                        *unfolded_multi_char = TRUE;\n                        Copy(s, d, s_len, U8);\n                        d += s_len;\n                    }\n                    else if (isASCII(*s)) {\n                        *(d++) = toFOLD(*s);\n                    }\n                    else {\n                        STRLEN len;\n                        _toFOLD_utf8_flags(s, s_end, d, &len, FOLD_FLAGS_FULL);\n                        d += len;\n                    }\n                    s += s_len;\n                }\n\n                /* Point the remainder of the routine to look at our temporary\n                 * folded copy */\n                s = folded;\n                s_end = d;\n            } /* End of creating folded copy of EXACTFL string */\n\n            /* Examine the string for a multi-character fold sequence.  UTF-8\n             * patterns have all characters pre-folded by the time this code is\n             * executed */\n            while (s < s_end - 1) /* Can stop 1 before the end, as minimum\n                                     length sequence we are looking for is 2 */\n\t    {\n                int count = 0;  /* How many characters in a multi-char fold */\n                int len = is_MULTI_CHAR_FOLD_utf8_safe(s, s_end);\n                if (! len) {    /* Not a multi-char fold: get next char */\n                    s += UTF8SKIP(s);\n                    continue;\n                }\n\n                { /* Here is a generic multi-char fold. */\n                    U8* multi_end  = s + len;\n\n                    /* Count how many characters are in it.  In the case of\n                     * /aa, no folds which contain ASCII code points are\n                     * allowed, so check for those, and skip if found. */\n                    if (OP(scan) != EXACTFAA && OP(scan) != EXACTFAA_NO_TRIE) {\n                        count = utf8_length(s, multi_end);\n                        s = multi_end;\n                    }\n                    else {\n                        while (s < multi_end) {\n                            if (isASCII(*s)) {\n                                s++;\n                                goto next_iteration;\n                            }\n                            else {\n                                s += UTF8SKIP(s);\n                            }\n                            count++;\n                        }\n                    }\n                }\n\n                /* The delta is how long the sequence is minus 1 (1 is how long\n                 * the character that folds to the sequence is) */\n                total_count_delta += count - 1;\n              next_iteration: ;\n\t    }\n\n            /* We created a temporary folded copy of the string in EXACTFL\n             * nodes.  Therefore we need to be sure it doesn't go below zero,\n             * as the real string could be shorter */\n            if (OP(scan) == EXACTFL) {\n                int total_chars = utf8_length((U8*) STRING(scan),\n                                           (U8*) STRING(scan) + STR_LEN(scan));\n                if (total_count_delta > total_chars) {\n                    total_count_delta = total_chars;\n                }\n            }\n\n            *min_subtract += total_count_delta;\n            Safefree(folded);\n\t}\n\telse if (OP(scan) == EXACTFAA) {\n\n            /* Non-UTF-8 pattern, EXACTFAA node.  There can't be a multi-char\n             * fold to the ASCII range (and there are no existing ones in the\n             * upper latin1 range).  But, as outlined in the comments preceding\n             * this function, we need to flag any occurrences of the sharp s.\n             * This character forbids trie formation (because of added\n             * complexity) */\n#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \\\n   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \\\n                                      || UNICODE_DOT_DOT_VERSION > 0)\n\t    while (s < s_end) {\n                if (*s == LATIN_SMALL_LETTER_SHARP_S) {\n                    OP(scan) = EXACTFAA_NO_TRIE;\n                    *unfolded_multi_char = TRUE;\n                    break;\n                }\n                s++;\n            }\n        }\n\telse {\n\n            /* Non-UTF-8 pattern, not EXACTFAA node.  Look for the multi-char\n             * folds that are all Latin1.  As explained in the comments\n             * preceding this function, we look also for the sharp s in EXACTF\n             * and EXACTFL nodes; it can be in the final position.  Otherwise\n             * we can stop looking 1 byte earlier because have to find at least\n             * two characters for a multi-fold */\n\t    const U8* upper = (OP(scan) == EXACTF || OP(scan) == EXACTFL)\n                              ? s_end\n                              : s_end -1;\n\n\t    while (s < upper) {\n                int len = is_MULTI_CHAR_FOLD_latin1_safe(s, s_end);\n                if (! len) {    /* Not a multi-char fold. */\n                    if (*s == LATIN_SMALL_LETTER_SHARP_S\n                        && (OP(scan) == EXACTF || OP(scan) == EXACTFL))\n                    {\n                        *unfolded_multi_char = TRUE;\n                    }\n                    s++;\n                    continue;\n                }\n\n                if (len == 2\n                    && isALPHA_FOLD_EQ(*s, 's')\n                    && isALPHA_FOLD_EQ(*(s+1), 's'))\n                {\n\n                    /* EXACTF nodes need to know that the minimum length\n                     * changed so that a sharp s in the string can match this\n                     * ss in the pattern, but they remain EXACTF nodes, as they\n                     * won't match this unless the target string is is UTF-8,\n                     * which we don't know until runtime.  EXACTFL nodes can't\n                     * transform into EXACTFU nodes */\n                    if (OP(scan) != EXACTF && OP(scan) != EXACTFL) {\n                        OP(scan) = EXACTFUP;\n                    }\n\t\t}\n\n                *min_subtract += len - 1;\n                s += len;\n\t    }\n#endif\n\t}\n\n        if (     STR_LEN(scan) == 1\n            &&   isALPHA_A(* STRING(scan))\n            &&  (         OP(scan) == EXACTFAA\n                 || (     OP(scan) == EXACTFU\n                     && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(* STRING(scan)))))\n        {\n            U8 mask = ~ ('A' ^ 'a'); /* These differ in just one bit */\n\n            /* Replace a length 1 ASCII fold pair node with an ANYOFM node,\n             * with the mask set to the complement of the bit that differs\n             * between upper and lower case, and the lowest code point of the\n             * pair (which the '&' forces) */\n            OP(scan) = ANYOFM;\n            ARG_SET(scan, *STRING(scan) & mask);\n            FLAGS(scan) = mask;\n        }\n    }\n\n#ifdef DEBUGGING\n    /* Allow dumping but overwriting the collection of skipped\n     * ops and/or strings with fake optimized ops */\n    n = scan + NODE_SZ_STR(scan);\n    while (n <= stop) {\n\tOP(n) = OPTIMIZED;\n\tFLAGS(n) = 0;\n\tNEXT_OFF(n) = 0;\n        n++;\n    }\n#endif\n    DEBUG_OPTIMISE_r(if (merged){DEBUG_PEEP(\"finl\", scan, depth, 0);});\n    return stopnow;\n}\n\n/* REx optimizer.  Converts nodes into quicker variants \"in place\".\n   Finds fixed substrings.  */\n\n/* Stops at toplevel WHILEM as well as at \"last\". At end *scanp is set\n   to the position after last scanned or to NULL. */\n\n#define INIT_AND_WITHP \\\n    assert(!and_withp); \\\n    Newx(and_withp, 1, regnode_ssc); \\\n    SAVEFREEPV(and_withp)\n\n\nstatic void\nS_unwind_scan_frames(pTHX_ const void *p)\n{\n    scan_frame *f= (scan_frame *)p;\n    do {\n        scan_frame *n= f->next_frame;\n        Safefree(f);\n        f= n;\n    } while (f);\n}\n\n/* Follow the next-chain of the current node and optimize away\n   all the NOTHINGs from it.\n */\nSTATIC void\nS_rck_elide_nothing(pTHX_ regnode *node)\n{\n    dVAR;\n\n    PERL_ARGS_ASSERT_RCK_ELIDE_NOTHING;\n\n    if (OP(node) != CURLYX) {\n        const int max = (reg_off_by_arg[OP(node)]\n                        ? I32_MAX\n                          /* I32 may be smaller than U16 on CRAYs! */\n                        : (I32_MAX < U16_MAX ? I32_MAX : U16_MAX));\n        int off = (reg_off_by_arg[OP(node)] ? ARG(node) : NEXT_OFF(node));\n        int noff;\n        regnode *n = node;\n\n        /* Skip NOTHING and LONGJMP. */\n        while (\n            (n = regnext(n))\n            && (\n                (PL_regkind[OP(n)] == NOTHING && (noff = NEXT_OFF(n)))\n                || ((OP(n) == LONGJMP) && (noff = ARG(n)))\n            )\n            && off + noff < max\n        ) {\n            off += noff;\n        }\n        if (reg_off_by_arg[OP(node)])\n            ARG(node) = off;\n        else\n            NEXT_OFF(node) = off;\n    }\n    return;\n}\n\n/* the return from this sub is the minimum length that could possibly match */\nSTATIC SSize_t\nS_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp,\n                        SSize_t *minlenp, SSize_t *deltap,\n\t\t\tregnode *last,\n\t\t\tscan_data_t *data,\n\t\t\tI32 stopparen,\n                        U32 recursed_depth,\n\t\t\tregnode_ssc *and_withp,\n\t\t\tU32 flags, U32 depth, bool was_mutate_ok)\n\t\t\t/* scanp: Start here (read-write). */\n\t\t\t/* deltap: Write maxlen-minlen here. */\n\t\t\t/* last: Stop before this one. */\n\t\t\t/* data: string data about the pattern */\n\t\t\t/* stopparen: treat close N as END */\n\t\t\t/* recursed: which subroutines have we recursed into */\n\t\t\t/* and_withp: Valid if flags & SCF_DO_STCLASS_OR */\n{\n    dVAR;\n    /* There must be at least this number of characters to match */\n    SSize_t min = 0;\n    I32 pars = 0, code;\n    regnode *scan = *scanp, *next;\n    SSize_t delta = 0;\n    int is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);\n    int is_inf_internal = 0;\t\t/* The studied chunk is infinite */\n    I32 is_par = OP(scan) == OPEN ? ARG(scan) : 0;\n    scan_data_t data_fake;\n    SV *re_trie_maxbuff = NULL;\n    regnode *first_non_open = scan;\n    SSize_t stopmin = SSize_t_MAX;\n    scan_frame *frame = NULL;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_STUDY_CHUNK;\n    RExC_study_started= 1;\n\n    Zero(&data_fake, 1, scan_data_t);\n\n    if ( depth == 0 ) {\n        while (first_non_open && OP(first_non_open) == OPEN)\n            first_non_open=regnext(first_non_open);\n    }\n\n\n  fake_study_recurse:\n    DEBUG_r(\n        RExC_study_chunk_recursed_count++;\n    );\n    DEBUG_OPTIMISE_MORE_r(\n    {\n        Perl_re_indentf( aTHX_  \"study_chunk stopparen=%ld recursed_count=%lu depth=%lu recursed_depth=%lu scan=%p last=%p\",\n            depth, (long)stopparen,\n            (unsigned long)RExC_study_chunk_recursed_count,\n            (unsigned long)depth, (unsigned long)recursed_depth,\n            scan,\n            last);\n        if (recursed_depth) {\n            U32 i;\n            U32 j;\n            for ( j = 0 ; j < recursed_depth ; j++ ) {\n                for ( i = 0 ; i < (U32)RExC_total_parens ; i++ ) {\n                    if (\n                        PAREN_TEST(RExC_study_chunk_recursed +\n                                   ( j * RExC_study_chunk_recursed_bytes), i )\n                        && (\n                            !j ||\n                            !PAREN_TEST(RExC_study_chunk_recursed +\n                                   (( j - 1 ) * RExC_study_chunk_recursed_bytes), i)\n                        )\n                    ) {\n                        Perl_re_printf( aTHX_ \" %d\",(int)i);\n                        break;\n                    }\n                }\n                if ( j + 1 < recursed_depth ) {\n                    Perl_re_printf( aTHX_  \",\");\n                }\n            }\n        }\n        Perl_re_printf( aTHX_ \"\\n\");\n    }\n    );\n    while ( scan && OP(scan) != END && scan < last ){\n        UV min_subtract = 0;    /* How mmany chars to subtract from the minimum\n                                   node length to get a real minimum (because\n                                   the folded version may be shorter) */\n\tbool unfolded_multi_char = FALSE;\n        /* avoid mutating ops if we are anywhere within the recursed or\n         * enframed handling for a GOSUB: the outermost level will handle it.\n         */\n        bool mutate_ok = was_mutate_ok && !(frame && frame->in_gosub);\n\t/* Peephole optimizer: */\n        DEBUG_STUDYDATA(\"Peep\", data, depth, is_inf);\n        DEBUG_PEEP(\"Peep\", scan, depth, flags);\n\n\n        /* The reason we do this here is that we need to deal with things like\n         * /(?:f)(?:o)(?:o)/ which cant be dealt with by the normal EXACT\n         * parsing code, as each (?:..) is handled by a different invocation of\n         * reg() -- Yves\n         */\n        if (mutate_ok)\n            JOIN_EXACT(scan,&min_subtract, &unfolded_multi_char, 0);\n\n        /* Follow the next-chain of the current node and optimize\n           away all the NOTHINGs from it.\n         */\n        rck_elide_nothing(scan);\n\n\t/* The principal pseudo-switch.  Cannot be a switch, since we\n\t   look into several different things.  */\n        if ( OP(scan) == DEFINEP ) {\n            SSize_t minlen = 0;\n            SSize_t deltanext = 0;\n            SSize_t fake_last_close = 0;\n            I32 f = SCF_IN_DEFINE;\n\n            StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n            scan = regnext(scan);\n            assert( OP(scan) == IFTHEN );\n            DEBUG_PEEP(\"expect IFTHEN\", scan, depth, flags);\n\n            data_fake.last_closep= &fake_last_close;\n            minlen = *minlenp;\n            next = regnext(scan);\n            scan = NEXTOPER(NEXTOPER(scan));\n            DEBUG_PEEP(\"scan\", scan, depth, flags);\n            DEBUG_PEEP(\"next\", next, depth, flags);\n\n            /* we suppose the run is continuous, last=next...\n             * NOTE we dont use the return here! */\n            /* DEFINEP study_chunk() recursion */\n            (void)study_chunk(pRExC_state, &scan, &minlen,\n                              &deltanext, next, &data_fake, stopparen,\n                              recursed_depth, NULL, f, depth+1, mutate_ok);\n\n            scan = next;\n        } else\n        if (\n            OP(scan) == BRANCH  ||\n            OP(scan) == BRANCHJ ||\n            OP(scan) == IFTHEN\n        ) {\n\t    next = regnext(scan);\n\t    code = OP(scan);\n\n            /* The op(next)==code check below is to see if we\n             * have \"BRANCH-BRANCH\", \"BRANCHJ-BRANCHJ\", \"IFTHEN-IFTHEN\"\n             * IFTHEN is special as it might not appear in pairs.\n             * Not sure whether BRANCH-BRANCHJ is possible, regardless\n             * we dont handle it cleanly. */\n\t    if (OP(next) == code || code == IFTHEN) {\n                /* NOTE - There is similar code to this block below for\n                 * handling TRIE nodes on a re-study.  If you change stuff here\n                 * check there too. */\n\t\tSSize_t max1 = 0, min1 = SSize_t_MAX, num = 0;\n\t\tregnode_ssc accum;\n\t\tregnode * const startbranch=scan;\n\n                if (flags & SCF_DO_SUBSTR) {\n                    /* Cannot merge strings after this. */\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n                }\n\n                if (flags & SCF_DO_STCLASS)\n\t\t    ssc_init_zero(pRExC_state, &accum);\n\n\t\twhile (OP(scan) == code) {\n\t\t    SSize_t deltanext, minnext, fake;\n\t\t    I32 f = 0;\n\t\t    regnode_ssc this_class;\n\n                    DEBUG_PEEP(\"Branch\", scan, depth, flags);\n\n\t\t    num++;\n                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n\t\t    if (data) {\n\t\t\tdata_fake.whilem_c = data->whilem_c;\n\t\t\tdata_fake.last_closep = data->last_closep;\n\t\t    }\n\t\t    else\n\t\t\tdata_fake.last_closep = &fake;\n\n\t\t    data_fake.pos_delta = delta;\n\t\t    next = regnext(scan);\n\n                    scan = NEXTOPER(scan); /* everything */\n                    if (code != BRANCH)    /* everything but BRANCH */\n\t\t\tscan = NEXTOPER(scan);\n\n\t\t    if (flags & SCF_DO_STCLASS) {\n\t\t\tssc_init(pRExC_state, &this_class);\n\t\t\tdata_fake.start_class = &this_class;\n\t\t\tf = SCF_DO_STCLASS_AND;\n\t\t    }\n\t\t    if (flags & SCF_WHILEM_VISITED_POS)\n\t\t\tf |= SCF_WHILEM_VISITED_POS;\n\n\t\t    /* we suppose the run is continuous, last=next...*/\n                    /* recurse study_chunk() for each BRANCH in an alternation */\n\t\t    minnext = study_chunk(pRExC_state, &scan, minlenp,\n                                      &deltanext, next, &data_fake, stopparen,\n                                      recursed_depth, NULL, f, depth+1,\n                                      mutate_ok);\n\n\t\t    if (min1 > minnext)\n\t\t\tmin1 = minnext;\n\t\t    if (deltanext == SSize_t_MAX) {\n\t\t\tis_inf = is_inf_internal = 1;\n\t\t\tmax1 = SSize_t_MAX;\n\t\t    } else if (max1 < minnext + deltanext)\n\t\t\tmax1 = minnext + deltanext;\n\t\t    scan = next;\n\t\t    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n\t\t\tpars++;\n\t            if (data_fake.flags & SCF_SEEN_ACCEPT) {\n\t                if ( stopmin > minnext)\n\t                    stopmin = min + min1;\n\t                flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n\t\t    if (data) {\n\t\t\tif (data_fake.flags & SF_HAS_EVAL)\n\t\t\t    data->flags |= SF_HAS_EVAL;\n\t\t\tdata->whilem_c = data_fake.whilem_c;\n\t\t    }\n\t\t    if (flags & SCF_DO_STCLASS)\n\t\t\tssc_or(pRExC_state, &accum, (regnode_charclass*)&this_class);\n\t\t}\n\t\tif (code == IFTHEN && num < 2) /* Empty ELSE branch */\n\t\t    min1 = 0;\n\t\tif (flags & SCF_DO_SUBSTR) {\n\t\t    data->pos_min += min1;\n\t\t    if (data->pos_delta >= SSize_t_MAX - (max1 - min1))\n\t\t        data->pos_delta = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += max1 - min1;\n\t\t    if (max1 != min1 || is_inf)\n\t\t\tdata->cur_is_floating = 1;\n\t\t}\n\t\tmin += min1;\n\t\tif (delta == SSize_t_MAX\n\t\t || SSize_t_MAX - delta - (max1 - min1) < 0)\n\t\t    delta = SSize_t_MAX;\n\t\telse\n\t\t    delta += max1 - min1;\n\t\tif (flags & SCF_DO_STCLASS_OR) {\n\t\t    ssc_or(pRExC_state, data->start_class, (regnode_charclass*) &accum);\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t}\n\t\telse if (flags & SCF_DO_STCLASS_AND) {\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t    else {\n\t\t\t/* Switch to OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\t\t\tStructCopy(&accum, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n\t\t    }\n\t\t}\n\n                if (PERL_ENABLE_TRIE_OPTIMISATION\n                    && OP(startbranch) == BRANCH\n                    && mutate_ok\n                ) {\n\t\t/* demq.\n\n                   Assuming this was/is a branch we are dealing with: 'scan'\n                   now points at the item that follows the branch sequence,\n                   whatever it is. We now start at the beginning of the\n                   sequence and look for subsequences of\n\n\t\t   BRANCH->EXACT=>x1\n\t\t   BRANCH->EXACT=>x2\n\t\t   tail\n\n                   which would be constructed from a pattern like\n                   /A|LIST|OF|WORDS/\n\n\t\t   If we can find such a subsequence we need to turn the first\n\t\t   element into a trie and then add the subsequent branch exact\n\t\t   strings to the trie.\n\n\t\t   We have two cases\n\n                     1. patterns where the whole set of branches can be\n                        converted.\n\n\t\t     2. patterns where only a subset can be converted.\n\n\t\t   In case 1 we can replace the whole set with a single regop\n\t\t   for the trie. In case 2 we need to keep the start and end\n\t\t   branches so\n\n\t\t     'BRANCH EXACT; BRANCH EXACT; BRANCH X'\n\t\t     becomes BRANCH TRIE; BRANCH X;\n\n\t\t  There is an additional case, that being where there is a\n\t\t  common prefix, which gets split out into an EXACT like node\n\t\t  preceding the TRIE node.\n\n\t\t  If x(1..n)==tail then we can do a simple trie, if not we make\n\t\t  a \"jump\" trie, such that when we match the appropriate word\n\t\t  we \"jump\" to the appropriate tail node. Essentially we turn\n\t\t  a nested if into a case structure of sorts.\n\n\t\t*/\n\n\t\t    int made=0;\n\t\t    if (!re_trie_maxbuff) {\n\t\t\tre_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1);\n\t\t\tif (!SvIOK(re_trie_maxbuff))\n\t\t\t    sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);\n\t\t    }\n                    if ( SvIV(re_trie_maxbuff)>=0  ) {\n                        regnode *cur;\n                        regnode *first = (regnode *)NULL;\n                        regnode *last = (regnode *)NULL;\n                        regnode *tail = scan;\n                        U8 trietype = 0;\n                        U32 count=0;\n\n                        /* var tail is used because there may be a TAIL\n                           regop in the way. Ie, the exacts will point to the\n                           thing following the TAIL, but the last branch will\n                           point at the TAIL. So we advance tail. If we\n                           have nested (?:) we may have to move through several\n                           tails.\n                         */\n\n                        while ( OP( tail ) == TAIL ) {\n                            /* this is the TAIL generated by (?:) */\n                            tail = regnext( tail );\n                        }\n\n\n                        DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx, RExC_mysv, tail, NULL, pRExC_state);\n                            Perl_re_indentf( aTHX_  \"%s %\" UVuf \":%s\\n\",\n                              depth+1,\n                              \"Looking for TRIE'able sequences. Tail node is \",\n                              (UV) REGNODE_OFFSET(tail),\n                              SvPV_nolen_const( RExC_mysv )\n                            );\n                        });\n\n                        /*\n\n                            Step through the branches\n                                cur represents each branch,\n                                noper is the first thing to be matched as part\n                                      of that branch\n                                noper_next is the regnext() of that node.\n\n                            We normally handle a case like this\n                            /FOO[xyz]|BAR[pqr]/ via a \"jump trie\" but we also\n                            support building with NOJUMPTRIE, which restricts\n                            the trie logic to structures like /FOO|BAR/.\n\n                            If noper is a trieable nodetype then the branch is\n                            a possible optimization target. If we are building\n                            under NOJUMPTRIE then we require that noper_next is\n                            the same as scan (our current position in the regex\n                            program).\n\n                            Once we have two or more consecutive such branches\n                            we can create a trie of the EXACT's contents and\n                            stitch it in place into the program.\n\n                            If the sequence represents all of the branches in\n                            the alternation we replace the entire thing with a\n                            single TRIE node.\n\n                            Otherwise when it is a subsequence we need to\n                            stitch it in place and replace only the relevant\n                            branches. This means the first branch has to remain\n                            as it is used by the alternation logic, and its\n                            next pointer, and needs to be repointed at the item\n                            on the branch chain following the last branch we\n                            have optimized away.\n\n                            This could be either a BRANCH, in which case the\n                            subsequence is internal, or it could be the item\n                            following the branch sequence in which case the\n                            subsequence is at the end (which does not\n                            necessarily mean the first node is the start of the\n                            alternation).\n\n                            TRIE_TYPE(X) is a define which maps the optype to a\n                            trietype.\n\n                                optype          |  trietype\n                                ----------------+-----------\n                                NOTHING         | NOTHING\n                                EXACT           | EXACT\n                                EXACT_ONLY8     | EXACT\n                                EXACTFU         | EXACTFU\n                                EXACTFU_ONLY8   | EXACTFU\n                                EXACTFUP        | EXACTFU\n                                EXACTFAA        | EXACTFAA\n                                EXACTL          | EXACTL\n                                EXACTFLU8       | EXACTFLU8\n\n\n                        */\n#define TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \\\n                       ? NOTHING                                            \\\n                       : ( EXACT == (X) || EXACT_ONLY8 == (X) )             \\\n                         ? EXACT                                            \\\n                         : (     EXACTFU == (X)                             \\\n                              || EXACTFU_ONLY8 == (X)                       \\\n                              || EXACTFUP == (X) )                          \\\n                           ? EXACTFU                                        \\\n                           : ( EXACTFAA == (X) )                            \\\n                             ? EXACTFAA                                     \\\n                             : ( EXACTL == (X) )                            \\\n                               ? EXACTL                                     \\\n                               : ( EXACTFLU8 == (X) )                       \\\n                                 ? EXACTFLU8                                \\\n                                 : 0 )\n\n                        /* dont use tail as the end marker for this traverse */\n                        for ( cur = startbranch ; cur != scan ; cur = regnext( cur ) ) {\n                            regnode * const noper = NEXTOPER( cur );\n                            U8 noper_type = OP( noper );\n                            U8 noper_trietype = TRIE_TYPE( noper_type );\n#if defined(DEBUGGING) || defined(NOJUMPTRIE)\n                            regnode * const noper_next = regnext( noper );\n                            U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n                            U8 noper_next_trietype = (noper_next && noper_next < tail) ? TRIE_TYPE( noper_next_type ) :0;\n#endif\n\n                            DEBUG_TRIE_COMPILE_r({\n                                regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                Perl_re_indentf( aTHX_  \"- %d:%s (%d)\",\n                                   depth+1,\n                                   REG_NODE_NUM(cur), SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur) );\n\n                                regprop(RExC_rx, RExC_mysv, noper, NULL, pRExC_state);\n                                Perl_re_printf( aTHX_  \" -> %d:%s\",\n                                    REG_NODE_NUM(noper), SvPV_nolen_const(RExC_mysv));\n\n                                if ( noper_next ) {\n                                  regprop(RExC_rx, RExC_mysv, noper_next, NULL, pRExC_state);\n                                  Perl_re_printf( aTHX_ \"\\t=> %d:%s\\t\",\n                                    REG_NODE_NUM(noper_next), SvPV_nolen_const(RExC_mysv));\n                                }\n                                Perl_re_printf( aTHX_  \"(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\\n\",\n                                   REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n\t\t\t\t   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype]\n\t\t\t\t);\n                            });\n\n                            /* Is noper a trieable nodetype that can be merged\n                             * with the current trie (if there is one)? */\n                            if ( noper_trietype\n                                  &&\n                                  (\n                                        ( noper_trietype == NOTHING )\n                                        || ( trietype == NOTHING )\n                                        || ( trietype == noper_trietype )\n                                  )\n#ifdef NOJUMPTRIE\n                                  && noper_next >= tail\n#endif\n                                  && count < U16_MAX)\n                            {\n                                /* Handle mergable triable node Either we are\n                                 * the first node in a new trieable sequence,\n                                 * in which case we do some bookkeeping,\n                                 * otherwise we update the end pointer. */\n                                if ( !first ) {\n                                    first = cur;\n\t\t\t\t    if ( noper_trietype == NOTHING ) {\n#if !defined(DEBUGGING) && !defined(NOJUMPTRIE)\n\t\t\t\t\tregnode * const noper_next = regnext( noper );\n                                        U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n\t\t\t\t\tU8 noper_next_trietype = noper_next_type ? TRIE_TYPE( noper_next_type ) :0;\n#endif\n\n                                        if ( noper_next_trietype ) {\n\t\t\t\t\t    trietype = noper_next_trietype;\n                                        } else if (noper_next_type)  {\n                                            /* a NOTHING regop is 1 regop wide.\n                                             * We need at least two for a trie\n                                             * so we can't merge this in */\n                                            first = NULL;\n                                        }\n                                    } else {\n                                        trietype = noper_trietype;\n                                    }\n                                } else {\n                                    if ( trietype == NOTHING )\n                                        trietype = noper_trietype;\n                                    last = cur;\n                                }\n\t\t\t\tif (first)\n\t\t\t\t    count++;\n                            } /* end handle mergable triable node */\n                            else {\n                                /* handle unmergable node -\n                                 * noper may either be a triable node which can\n                                 * not be tried together with the current trie,\n                                 * or a non triable node */\n                                if ( last ) {\n                                    /* If last is set and trietype is not\n                                     * NOTHING then we have found at least two\n                                     * triable branch sequences in a row of a\n                                     * similar trietype so we can turn them\n                                     * into a trie. If/when we allow NOTHING to\n                                     * start a trie sequence this condition\n                                     * will be required, and it isn't expensive\n                                     * so we leave it in for now. */\n                                    if ( trietype && trietype != NOTHING )\n                                        make_trie( pRExC_state,\n                                                startbranch, first, cur, tail,\n                                                count, trietype, depth+1 );\n                                    last = NULL; /* note: we clear/update\n                                                    first, trietype etc below,\n                                                    so we dont do it here */\n                                }\n                                if ( noper_trietype\n#ifdef NOJUMPTRIE\n                                     && noper_next >= tail\n#endif\n                                ){\n                                    /* noper is triable, so we can start a new\n                                     * trie sequence */\n                                    count = 1;\n                                    first = cur;\n                                    trietype = noper_trietype;\n                                } else if (first) {\n                                    /* if we already saw a first but the\n                                     * current node is not triable then we have\n                                     * to reset the first information. */\n                                    count = 0;\n                                    first = NULL;\n                                    trietype = 0;\n                                }\n                            } /* end handle unmergable node */\n                        } /* loop over branches */\n                        DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                            Perl_re_indentf( aTHX_  \"- %s (%d) <SCAN FINISHED> \",\n                              depth+1, SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n                            Perl_re_printf( aTHX_  \"(First==%d, Last==%d, Cur==%d, tt==%s)\\n\",\n                               REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n                               PL_reg_name[trietype]\n                            );\n\n                        });\n                        if ( last && trietype ) {\n                            if ( trietype != NOTHING ) {\n                                /* the last branch of the sequence was part of\n                                 * a trie, so we have to construct it here\n                                 * outside of the loop */\n                                made= make_trie( pRExC_state, startbranch,\n                                                 first, scan, tail, count,\n                                                 trietype, depth+1 );\n#ifdef TRIE_STUDY_OPT\n                                if ( ((made == MADE_EXACT_TRIE &&\n                                     startbranch == first)\n                                     || ( first_non_open == first )) &&\n                                     depth==0 ) {\n                                    flags |= SCF_TRIE_RESTUDY;\n                                    if ( startbranch == first\n                                         && scan >= tail )\n                                    {\n                                        RExC_seen &=~REG_TOP_LEVEL_BRANCHES_SEEN;\n                                    }\n                                }\n#endif\n                            } else {\n                                /* at this point we know whatever we have is a\n                                 * NOTHING sequence/branch AND if 'startbranch'\n                                 * is 'first' then we can turn the whole thing\n                                 * into a NOTHING\n                                 */\n                                if ( startbranch == first ) {\n                                    regnode *opt;\n                                    /* the entire thing is a NOTHING sequence,\n                                     * something like this: (?:|) So we can\n                                     * turn it into a plain NOTHING op. */\n                                    DEBUG_TRIE_COMPILE_r({\n                                        regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                        Perl_re_indentf( aTHX_  \"- %s (%d) <NOTHING BRANCH SEQUENCE>\\n\",\n                                          depth+1,\n                                          SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n\n                                    });\n                                    OP(startbranch)= NOTHING;\n                                    NEXT_OFF(startbranch)= tail - startbranch;\n                                    for ( opt= startbranch + 1; opt < tail ; opt++ )\n                                        OP(opt)= OPTIMIZED;\n                                }\n                            }\n                        } /* end if ( last) */\n                    } /* TRIE_MAXBUF is non zero */\n\n                } /* do trie */\n\n\t    }\n\t    else if ( code == BRANCHJ ) {  /* single branch is optimized. */\n\t\tscan = NEXTOPER(NEXTOPER(scan));\n\t    } else\t\t\t/* single branch is optimized. */\n\t\tscan = NEXTOPER(scan);\n\t    continue;\n        } else if (OP(scan) == SUSPEND || OP(scan) == GOSUB) {\n            I32 paren = 0;\n            regnode *start = NULL;\n            regnode *end = NULL;\n            U32 my_recursed_depth= recursed_depth;\n\n            if (OP(scan) != SUSPEND) { /* GOSUB */\n                /* Do setup, note this code has side effects beyond\n                 * the rest of this block. Specifically setting\n                 * RExC_recurse[] must happen at least once during\n                 * study_chunk(). */\n                paren = ARG(scan);\n                RExC_recurse[ARG2L(scan)] = scan;\n                start = REGNODE_p(RExC_open_parens[paren]);\n                end   = REGNODE_p(RExC_close_parens[paren]);\n\n                /* NOTE we MUST always execute the above code, even\n                 * if we do nothing with a GOSUB */\n                if (\n                    ( flags & SCF_IN_DEFINE )\n                    ||\n                    (\n                        (is_inf_internal || is_inf || (data && data->flags & SF_IS_INF))\n                        &&\n                        ( (flags & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )\n                    )\n                ) {\n                    /* no need to do anything here if we are in a define. */\n                    /* or we are after some kind of infinite construct\n                     * so we can skip recursing into this item.\n                     * Since it is infinite we will not change the maxlen\n                     * or delta, and if we miss something that might raise\n                     * the minlen it will merely pessimise a little.\n                     *\n                     * Iow /(?(DEFINE)(?<foo>foo|food))a+(?&foo)/\n                     * might result in a minlen of 1 and not of 4,\n                     * but this doesn't make us mismatch, just try a bit\n                     * harder than we should.\n                     * */\n                    scan= regnext(scan);\n                    continue;\n                }\n\n                if (\n                    !recursed_depth\n                    ||\n                    !PAREN_TEST(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes), paren)\n                ) {\n                    /* it is quite possible that there are more efficient ways\n                     * to do this. We maintain a bitmap per level of recursion\n                     * of which patterns we have entered so we can detect if a\n                     * pattern creates a possible infinite loop. When we\n                     * recurse down a level we copy the previous levels bitmap\n                     * down. When we are at recursion level 0 we zero the top\n                     * level bitmap. It would be nice to implement a different\n                     * more efficient way of doing this. In particular the top\n                     * level bitmap may be unnecessary.\n                     */\n                    if (!recursed_depth) {\n                        Zero(RExC_study_chunk_recursed, RExC_study_chunk_recursed_bytes, U8);\n                    } else {\n                        Copy(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes),\n                             RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes),\n                             RExC_study_chunk_recursed_bytes, U8);\n                    }\n                    /* we havent recursed into this paren yet, so recurse into it */\n                    DEBUG_STUDYDATA(\"gosub-set\", data, depth, is_inf);\n                    PAREN_SET(RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes), paren);\n                    my_recursed_depth= recursed_depth + 1;\n                } else {\n                    DEBUG_STUDYDATA(\"gosub-inf\", data, depth, is_inf);\n                    /* some form of infinite recursion, assume infinite length\n                     * */\n                    if (flags & SCF_DO_SUBSTR) {\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n                        data->cur_is_floating = 1;\n                    }\n                    is_inf = is_inf_internal = 1;\n                    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n                        ssc_anything(data->start_class);\n                    flags &= ~SCF_DO_STCLASS;\n\n                    start= NULL; /* reset start so we dont recurse later on. */\n\t        }\n            } else {\n\t        paren = stopparen;\n                start = scan + 2;\n\t        end = regnext(scan);\n\t    }\n            if (start) {\n                scan_frame *newframe;\n                assert(end);\n                if (!RExC_frame_last) {\n                    Newxz(newframe, 1, scan_frame);\n                    SAVEDESTRUCTOR_X(S_unwind_scan_frames, newframe);\n                    RExC_frame_head= newframe;\n                    RExC_frame_count++;\n                } else if (!RExC_frame_last->next_frame) {\n                    Newxz(newframe, 1, scan_frame);\n                    RExC_frame_last->next_frame= newframe;\n                    newframe->prev_frame= RExC_frame_last;\n                    RExC_frame_count++;\n                } else {\n                    newframe= RExC_frame_last->next_frame;\n                }\n                RExC_frame_last= newframe;\n\n                newframe->next_regnode = regnext(scan);\n                newframe->last_regnode = last;\n                newframe->stopparen = stopparen;\n                newframe->prev_recursed_depth = recursed_depth;\n                newframe->this_prev_frame= frame;\n                newframe->in_gosub = (\n                    (frame && frame->in_gosub) || OP(scan) == GOSUB\n                );\n\n                DEBUG_STUDYDATA(\"frame-new\", data, depth, is_inf);\n                DEBUG_PEEP(\"fnew\", scan, depth, flags);\n\n\t        frame = newframe;\n\t        scan =  start;\n\t        stopparen = paren;\n\t        last = end;\n                depth = depth + 1;\n                recursed_depth= my_recursed_depth;\n\n\t        continue;\n\t    }\n\t}\n\telse if (   OP(scan) == EXACT\n                 || OP(scan) == EXACT_ONLY8\n                 || OP(scan) == EXACTL)\n        {\n\t    SSize_t l = STR_LEN(scan);\n\t    UV uc;\n            assert(l);\n\t    if (UTF) {\n\t\tconst U8 * const s = (U8*)STRING(scan);\n\t\tuc = utf8_to_uvchr_buf(s, s + l, NULL);\n\t\tl = utf8_length(s, s + l);\n\t    } else {\n\t\tuc = *((U8*)STRING(scan));\n\t    }\n\t    min += l;\n\t    if (flags & SCF_DO_SUBSTR) { /* Update longest substr. */\n\t\t/* The code below prefers earlier match for fixed\n\t\t   offset, later match for variable offset.  */\n\t\tif (data->last_end == -1) { /* Update the start info. */\n\t\t    data->last_start_min = data->pos_min;\n \t\t    data->last_start_max = is_inf\n \t\t\t? SSize_t_MAX : data->pos_min + data->pos_delta;\n\t\t}\n\t\tsv_catpvn(data->last_found, STRING(scan), STR_LEN(scan));\n\t\tif (UTF)\n\t\t    SvUTF8_on(data->last_found);\n\t\t{\n\t\t    SV * const sv = data->last_found;\n\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\t\t    if (mg && mg->mg_len >= 0)\n\t\t\tmg->mg_len += utf8_length((U8*)STRING(scan),\n                                              (U8*)STRING(scan)+STR_LEN(scan));\n\t\t}\n\t\tdata->last_end = data->pos_min + l;\n\t\tdata->pos_min += l; /* As in the first entry. */\n\t\tdata->flags &= ~SF_BEFORE_EOL;\n\t    }\n\n            /* ANDing the code point leaves at most it, and not in locale, and\n             * can't match null string */\n\t    if (flags & SCF_DO_STCLASS_AND) {\n                ssc_cp_and(data->start_class, uc);\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                ssc_clear_locale(data->start_class);\n\t    }\n\t    else if (flags & SCF_DO_STCLASS_OR) {\n                ssc_add_cp(data->start_class, uc);\n\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\t    }\n\t    flags &= ~SCF_DO_STCLASS;\n\t}\n        else if (PL_regkind[OP(scan)] == EXACT) {\n            /* But OP != EXACT!, so is EXACTFish */\n\t    SSize_t l = STR_LEN(scan);\n            const U8 * s = (U8*)STRING(scan);\n\n\t    /* Search for fixed substrings supports EXACT only. */\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tassert(data);\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t    }\n\t    if (UTF) {\n\t\tl = utf8_length(s, s + l);\n\t    }\n\t    if (unfolded_multi_char) {\n                RExC_seen |= REG_UNFOLDED_MULTI_SEEN;\n\t    }\n\t    min += l - min_subtract;\n            assert (min >= 0);\n            delta += min_subtract;\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tdata->pos_min += l - min_subtract;\n\t\tif (data->pos_min < 0) {\n                    data->pos_min = 0;\n                }\n                data->pos_delta += min_subtract;\n\t\tif (min_subtract) {\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t    }\n\n            if (flags & SCF_DO_STCLASS) {\n                SV* EXACTF_invlist = _make_exactf_invlist(pRExC_state, scan);\n\n                assert(EXACTF_invlist);\n                if (flags & SCF_DO_STCLASS_AND) {\n                    if (OP(scan) != EXACTFL)\n                        ssc_clear_locale(data->start_class);\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                    ANYOF_POSIXL_ZERO(data->start_class);\n                    ssc_intersection(data->start_class, EXACTF_invlist, FALSE);\n                }\n                else {  /* SCF_DO_STCLASS_OR */\n                    ssc_union(data->start_class, EXACTF_invlist, FALSE);\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                    /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                flags &= ~SCF_DO_STCLASS;\n                SvREFCNT_dec(EXACTF_invlist);\n            }\n\t}\n\telse if (REGNODE_VARIES(OP(scan))) {\n\t    SSize_t mincount, maxcount, minnext, deltanext, pos_before = 0;\n\t    I32 fl = 0, f = flags;\n\t    regnode * const oscan = scan;\n\t    regnode_ssc this_class;\n\t    regnode_ssc *oclass = NULL;\n\t    I32 next_is_eval = 0;\n\n\t    switch (PL_regkind[OP(scan)]) {\n\t    case WHILEM:\t\t/* End of (?:...)* . */\n\t\tscan = NEXTOPER(scan);\n\t\tgoto finish;\n\t    case PLUS:\n\t\tif (flags & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) {\n\t\t    next = NEXTOPER(scan);\n\t\t    if (   OP(next) == EXACT\n                        || OP(next) == EXACT_ONLY8\n                        || OP(next) == EXACTL\n                        || (flags & SCF_DO_STCLASS))\n                    {\n\t\t\tmincount = 1;\n\t\t\tmaxcount = REG_INFTY;\n\t\t\tnext = regnext(scan);\n\t\t\tscan = NEXTOPER(scan);\n\t\t\tgoto do_curly;\n\t\t    }\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR)\n\t\t    data->pos_min++;\n\t\tmin++;\n\t\t/* FALLTHROUGH */\n\t    case STAR:\n                next = NEXTOPER(scan);\n\n                /* This temporary node can now be turned into EXACTFU, and\n                 * must, as regexec.c doesn't handle it */\n                if (OP(next) == EXACTFU_S_EDGE && mutate_ok) {\n                    OP(next) = EXACTFU;\n                }\n\n                if (     STR_LEN(next) == 1\n                    &&   isALPHA_A(* STRING(next))\n                    && (         OP(next) == EXACTFAA\n                        || (     OP(next) == EXACTFU\n                            && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(* STRING(next))))\n                    &&   mutate_ok\n                ) {\n                    /* These differ in just one bit */\n                    U8 mask = ~ ('A' ^ 'a');\n\n                    assert(isALPHA_A(* STRING(next)));\n\n                    /* Then replace it by an ANYOFM node, with\n                    * the mask set to the complement of the\n                    * bit that differs between upper and lower\n                    * case, and the lowest code point of the\n                    * pair (which the '&' forces) */\n                    OP(next) = ANYOFM;\n                    ARG_SET(next, *STRING(next) & mask);\n                    FLAGS(next) = mask;\n                }\n\n\t\tif (flags & SCF_DO_STCLASS) {\n\t\t    mincount = 0;\n\t\t    maxcount = REG_INFTY;\n\t\t    next = regnext(scan);\n\t\t    scan = NEXTOPER(scan);\n\t\t    goto do_curly;\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n                is_inf = is_inf_internal = 1;\n                scan = regnext(scan);\n\t\tgoto optimize_curly_tail;\n\t    case CURLY:\n\t        if (stopparen>0 && (OP(scan)==CURLYN || OP(scan)==CURLYM)\n\t            && (scan->flags == stopparen))\n\t\t{\n\t\t    mincount = 1;\n\t\t    maxcount = 1;\n\t\t} else {\n\t\t    mincount = ARG1(scan);\n\t\t    maxcount = ARG2(scan);\n\t\t}\n\t\tnext = regnext(scan);\n\t\tif (OP(scan) == CURLYX) {\n\t\t    I32 lp = (data ? *(data->last_closep) : 0);\n\t\t    scan->flags = ((lp <= (I32)U8_MAX) ? (U8)lp : U8_MAX);\n\t\t}\n\t\tscan = NEXTOPER(scan) + EXTRA_STEP_2ARGS;\n\t\tnext_is_eval = (OP(scan) == EVAL);\n\t      do_curly:\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    if (mincount == 0)\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t    pos_before = data->pos_min;\n\t\t}\n\t\tif (data) {\n\t\t    fl = data->flags;\n\t\t    data->flags &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL);\n\t\t    if (is_inf)\n\t\t\tdata->flags |= SF_IS_INF;\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS) {\n\t\t    ssc_init(pRExC_state, &this_class);\n\t\t    oclass = data->start_class;\n\t\t    data->start_class = &this_class;\n\t\t    f |= SCF_DO_STCLASS_AND;\n\t\t    f &= ~SCF_DO_STCLASS_OR;\n\t\t}\n\t        /* Exclude from super-linear cache processing any {n,m}\n\t\t   regops for which the combination of input pos and regex\n\t\t   pos is not enough information to determine if a match\n\t\t   will be possible.\n\n\t\t   For example, in the regex /foo(bar\\s*){4,8}baz/ with the\n\t\t   regex pos at the \\s*, the prospects for a match depend not\n\t\t   only on the input position but also on how many (bar\\s*)\n\t\t   repeats into the {4,8} we are. */\n               if ((mincount > 1) || (maxcount > 1 && maxcount != REG_INFTY))\n\t\t    f &= ~SCF_WHILEM_VISITED_POS;\n\n\t\t/* This will finish on WHILEM, setting scan, or on NULL: */\n                /* recurse study_chunk() on loop bodies */\n\t\tminnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext,\n                                  last, data, stopparen, recursed_depth, NULL,\n                                  (mincount == 0\n                                   ? (f & ~SCF_DO_SUBSTR)\n                                   : f)\n                                  , depth+1, mutate_ok);\n\n\t\tif (flags & SCF_DO_STCLASS)\n\t\t    data->start_class = oclass;\n\t\tif (mincount == 0 || minnext == 0) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND) {\n\t\t\t/* Switch to OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\t\t\tStructCopy(&this_class, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n                        ANYOF_FLAGS(data->start_class)\n                                                |= SSC_MATCHES_EMPTY_STRING;\n\t\t    }\n\t\t} else {\t\t/* Non-zero len */\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t    flags &= ~SCF_DO_STCLASS;\n\t\t}\n\t\tif (!scan) \t\t/* It was not CURLYX, but CURLY. */\n\t\t    scan = next;\n\t\tif (((flags & (SCF_TRIE_DOING_RESTUDY|SCF_DO_SUBSTR))==SCF_DO_SUBSTR)\n\t\t    /* ? quantifier ok, except for (?{ ... }) */\n\t\t    && (next_is_eval || !(mincount == 0 && maxcount == 1))\n\t\t    && (minnext == 0) && (deltanext == 0)\n\t\t    && data && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))\n                    && maxcount <= REG_INFTY/3) /* Complement check for big\n                                                   count */\n\t\t{\n\t\t    _WARN_HELPER(RExC_precomp_end, packWARN(WARN_REGEXP),\n                        Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),\n                            \"Quantifier unexpected on zero-length expression \"\n                            \"in regex m/%\" UTF8f \"/\",\n\t\t\t     UTF8fARG(UTF, RExC_precomp_end - RExC_precomp,\n\t\t\t\t  RExC_precomp)));\n                }\n\n                if ( ( minnext > 0 && mincount >= SSize_t_MAX / minnext )\n                    || min >= SSize_t_MAX - minnext * mincount )\n                {\n                    FAIL(\"Regexp out of space\");\n                }\n\n\t\tmin += minnext * mincount;\n\t\tis_inf_internal |= deltanext == SSize_t_MAX\n                         || (maxcount == REG_INFTY && minnext + deltanext > 0);\n\t\tis_inf |= is_inf_internal;\n                if (is_inf) {\n\t\t    delta = SSize_t_MAX;\n                } else {\n\t\t    delta += (minnext + deltanext) * maxcount\n                             - minnext * mincount;\n                }\n\t\t/* Try powerful optimization CURLYX => CURLYN. */\n\t\tif (  OP(oscan) == CURLYX && data\n\t\t      && data->flags & SF_IN_PAR\n\t\t      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext && minnext == 1\n                      && mutate_ok\n                ) {\n\t\t    /* Try to optimize to CURLYN.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;\n\t\t    regnode * const nxt1 = nxt;\n#ifdef DEBUGGING\n\t\t    regnode *nxt2;\n#endif\n\n\t\t    /* Skip open. */\n\t\t    nxt = regnext(nxt);\n\t\t    if (!REGNODE_SIMPLE(OP(nxt))\n\t\t\t&& !(PL_regkind[OP(nxt)] == EXACT\n\t\t\t     && STR_LEN(nxt) == 1))\n\t\t\tgoto nogo;\n#ifdef DEBUGGING\n\t\t    nxt2 = nxt;\n#endif\n\t\t    nxt = regnext(nxt);\n\t\t    if (OP(nxt) != CLOSE)\n\t\t\tgoto nogo;\n\t\t    if (RExC_open_parens) {\n\n                        /*open->CURLYM*/\n                        RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n\n                        /*close->while*/\n                        RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt) + 2;\n\t\t    }\n\t\t    /* Now we know that nxt2 is the only contents: */\n\t\t    oscan->flags = (U8)ARG(nxt);\n\t\t    OP(oscan) = CURLYN;\n\t\t    OP(nxt1) = NOTHING;\t/* was OPEN. */\n\n#ifdef DEBUGGING\n\t\t    OP(nxt1 + 1) = OPTIMIZED; /* was count. */\n\t\t    NEXT_OFF(nxt1+ 1) = 0; /* just for consistency. */\n\t\t    NEXT_OFF(nxt2) = 0;\t/* just for consistency with CURLY. */\n\t\t    OP(nxt) = OPTIMIZED;\t/* was CLOSE. */\n\t\t    OP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t    NEXT_OFF(nxt+ 1) = 0; /* just for consistency. */\n#endif\n\t\t}\n\t      nogo:\n\n\t\t/* Try optimization CURLYX => CURLYM. */\n\t\tif (  OP(oscan) == CURLYX && data\n\t\t      && !(data->flags & SF_HAS_PAR)\n\t\t      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext\t/* atom is fixed width */\n\t\t      && minnext != 0\t/* CURLYM can't handle zero width */\n                         /* Nor characters whose fold at run-time may be\n                          * multi-character */\n                      && ! (RExC_seen & REG_UNFOLDED_MULTI_SEEN)\n                      && mutate_ok\n\t\t) {\n\t\t    /* XXXX How to optimize if data == 0? */\n\t\t    /* Optimize to a simpler form.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN */\n\t\t    regnode *nxt2;\n\n\t\t    OP(oscan) = CURLYM;\n\t\t    while ( (nxt2 = regnext(nxt)) /* skip over embedded stuff*/\n\t\t\t    && (OP(nxt2) != WHILEM))\n\t\t\tnxt = nxt2;\n\t\t    OP(nxt2)  = SUCCEED; /* Whas WHILEM */\n\t\t    /* Need to optimize away parenths. */\n\t\t    if ((data->flags & SF_IN_PAR) && OP(nxt) == CLOSE) {\n\t\t\t/* Set the parenth number.  */\n\t\t\tregnode *nxt1 = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN*/\n\n\t\t\toscan->flags = (U8)ARG(nxt);\n\t\t\tif (RExC_open_parens) {\n                             /*open->CURLYM*/\n                            RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n\n                            /*close->NOTHING*/\n                            RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt2)\n                                                         + 1;\n\t\t\t}\n\t\t\tOP(nxt1) = OPTIMIZED;\t/* was OPEN. */\n\t\t\tOP(nxt) = OPTIMIZED;\t/* was CLOSE. */\n\n#ifdef DEBUGGING\n\t\t\tOP(nxt1 + 1) = OPTIMIZED; /* was count. */\n\t\t\tOP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t\tNEXT_OFF(nxt1 + 1) = 0; /* just for consistency. */\n\t\t\tNEXT_OFF(nxt + 1) = 0; /* just for consistency. */\n#endif\n#if 0\n\t\t\twhile ( nxt1 && (OP(nxt1) != WHILEM)) {\n\t\t\t    regnode *nnxt = regnext(nxt1);\n\t\t\t    if (nnxt == nxt) {\n\t\t\t\tif (reg_off_by_arg[OP(nxt1)])\n\t\t\t\t    ARG_SET(nxt1, nxt2 - nxt1);\n\t\t\t\telse if (nxt2 - nxt1 < U16_MAX)\n\t\t\t\t    NEXT_OFF(nxt1) = nxt2 - nxt1;\n\t\t\t\telse\n\t\t\t\t    OP(nxt) = NOTHING;\t/* Cannot beautify */\n\t\t\t    }\n\t\t\t    nxt1 = nnxt;\n\t\t\t}\n#endif\n\t\t\t/* Optimize again: */\n                        /* recurse study_chunk() on optimised CURLYX => CURLYM */\n\t\t\tstudy_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,\n                                    NULL, stopparen, recursed_depth, NULL, 0,\n                                    depth+1, mutate_ok);\n\t\t    }\n\t\t    else\n\t\t\toscan->flags = 0;\n\t\t}\n\t\telse if ((OP(oscan) == CURLYX)\n\t\t\t && (flags & SCF_WHILEM_VISITED_POS)\n\t\t\t /* See the comment on a similar expression above.\n\t\t\t    However, this time it's not a subexpression\n\t\t\t    we care about, but the expression itself. */\n\t\t\t && (maxcount == REG_INFTY)\n\t\t\t && data) {\n\t\t    /* This stays as CURLYX, we can put the count/of pair. */\n\t\t    /* Find WHILEM (as in regexec.c) */\n\t\t    regnode *nxt = oscan + NEXT_OFF(oscan);\n\n\t\t    if (OP(PREVOPER(nxt)) == NOTHING) /* LONGJMP */\n\t\t\tnxt += ARG(nxt);\n                    nxt = PREVOPER(nxt);\n                    if (nxt->flags & 0xf) {\n                        /* we've already set whilem count on this node */\n                    } else if (++data->whilem_c < 16) {\n                        assert(data->whilem_c <= RExC_whilem_seen);\n                        nxt->flags = (U8)(data->whilem_c\n                            | (RExC_whilem_seen << 4)); /* On WHILEM */\n                    }\n\t\t}\n\t\tif (data && fl & (SF_HAS_PAR|SF_IN_PAR))\n\t\t    pars++;\n\t\tif (flags & SCF_DO_SUBSTR) {\n\t\t    SV *last_str = NULL;\n                    STRLEN last_chrs = 0;\n\t\t    int counted = mincount != 0;\n\n                    if (data->last_end > 0 && mincount != 0) { /* Ends with a\n                                                                  string. */\n\t\t\tSSize_t b = pos_before >= data->last_start_min\n\t\t\t    ? pos_before : data->last_start_min;\n\t\t\tSTRLEN l;\n\t\t\tconst char * const s = SvPV_const(data->last_found, l);\n\t\t\tSSize_t old = b - data->last_start_min;\n                        assert(old >= 0);\n\n\t\t\tif (UTF)\n\t\t\t    old = utf8_hop_forward((U8*)s, old,\n                                               (U8 *) SvEND(data->last_found))\n                                - (U8*)s;\n\t\t\tl -= old;\n\t\t\t/* Get the added string: */\n\t\t\tlast_str = newSVpvn_utf8(s  + old, l, UTF);\n                        last_chrs = UTF ? utf8_length((U8*)(s + old),\n                                            (U8*)(s + old + l)) : l;\n\t\t\tif (deltanext == 0 && pos_before == b) {\n\t\t\t    /* What was added is a constant string */\n\t\t\t    if (mincount > 1) {\n\n\t\t\t\tSvGROW(last_str, (mincount * l) + 1);\n\t\t\t\trepeatcpy(SvPVX(last_str) + l,\n\t\t\t\t\t  SvPVX_const(last_str), l,\n                                          mincount - 1);\n\t\t\t\tSvCUR_set(last_str, SvCUR(last_str) * mincount);\n\t\t\t\t/* Add additional parts. */\n\t\t\t\tSvCUR_set(data->last_found,\n\t\t\t\t\t  SvCUR(data->last_found) - l);\n\t\t\t\tsv_catsv(data->last_found, last_str);\n\t\t\t\t{\n\t\t\t\t    SV * sv = data->last_found;\n\t\t\t\t    MAGIC *mg =\n\t\t\t\t\tSvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\t\t\t\t    if (mg && mg->mg_len >= 0)\n\t\t\t\t\tmg->mg_len += last_chrs * (mincount-1);\n\t\t\t\t}\n                                last_chrs *= mincount;\n\t\t\t\tdata->last_end += l * (mincount - 1);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    /* start offset must point into the last copy */\n\t\t\t    data->last_start_min += minnext * (mincount - 1);\n\t\t\t    data->last_start_max =\n                              is_inf\n                               ? SSize_t_MAX\n\t\t\t       : data->last_start_max +\n                                 (maxcount - 1) * (minnext + data->pos_delta);\n\t\t\t}\n\t\t    }\n\t\t    /* It is counted once already... */\n\t\t    data->pos_min += minnext * (mincount - counted);\n#if 0\nPerl_re_printf( aTHX_  \"counted=%\" UVuf \" deltanext=%\" UVuf\n                              \" SSize_t_MAX=%\" UVuf \" minnext=%\" UVuf\n                              \" maxcount=%\" UVuf \" mincount=%\" UVuf \"\\n\",\n    (UV)counted, (UV)deltanext, (UV)SSize_t_MAX, (UV)minnext, (UV)maxcount,\n    (UV)mincount);\nif (deltanext != SSize_t_MAX)\nPerl_re_printf( aTHX_  \"LHS=%\" UVuf \" RHS=%\" UVuf \"\\n\",\n    (UV)(-counted * deltanext + (minnext + deltanext) * maxcount\n          - minnext * mincount), (UV)(SSize_t_MAX - data->pos_delta));\n#endif\n\t\t    if (deltanext == SSize_t_MAX\n                        || -counted * deltanext + (minnext + deltanext) * maxcount - minnext * mincount >= SSize_t_MAX - data->pos_delta)\n\t\t        data->pos_delta = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += - counted * deltanext +\n\t\t\t(minnext + deltanext) * maxcount - minnext * mincount;\n\t\t    if (mincount != maxcount) {\n\t\t\t /* Cannot extend fixed substrings found inside\n\t\t\t    the group.  */\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t\tif (mincount && last_str) {\n\t\t\t    SV * const sv = data->last_found;\n\t\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\n\t\t\t    if (mg)\n\t\t\t\tmg->mg_len = -1;\n\t\t\t    sv_setsv(sv, last_str);\n\t\t\t    data->last_end = data->pos_min;\n\t\t\t    data->last_start_min = data->pos_min - last_chrs;\n\t\t\t    data->last_start_max = is_inf\n\t\t\t\t? SSize_t_MAX\n\t\t\t\t: data->pos_min + data->pos_delta - last_chrs;\n\t\t\t}\n\t\t\tdata->cur_is_floating = 1; /* float */\n\t\t    }\n\t\t    SvREFCNT_dec(last_str);\n\t\t}\n\t\tif (data && (fl & SF_HAS_EVAL))\n\t\t    data->flags |= SF_HAS_EVAL;\n\t      optimize_curly_tail:\n\t\trck_elide_nothing(oscan);\n\t\tcontinue;\n\n\t    default:\n#ifdef DEBUGGING\n                Perl_croak(aTHX_ \"panic: unexpected varying REx opcode %d\",\n                                                                    OP(scan));\n#endif\n            case REF:\n            case CLUMP:\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    /* Cannot expect anything... */\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) {\n                    if (OP(scan) == CLUMP) {\n                        /* Actually is any start char, but very few code points\n                         * aren't start characters */\n                        ssc_match_all_cp(data->start_class);\n                    }\n                    else {\n                        ssc_anything(data->start_class);\n                    }\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n\t\tbreak;\n\t    }\n\t}\n\telse if (OP(scan) == LNBREAK) {\n\t    if (flags & SCF_DO_STCLASS) {\n    \t        if (flags & SCF_DO_STCLASS_AND) {\n                    ssc_intersection(data->start_class,\n                                    PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);\n                    ssc_clear_locale(data->start_class);\n                    ANYOF_FLAGS(data->start_class)\n                                                &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                else if (flags & SCF_DO_STCLASS_OR) {\n                    ssc_union(data->start_class,\n                              PL_XPosix_ptrs[_CC_VERTSPACE],\n                              FALSE);\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                    /* See commit msg for\n                     * 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class)\n                                                &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n            }\n\t    min++;\n            if (delta != SSize_t_MAX)\n                delta++;    /* Because of the 2 char string cr-lf */\n            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything... */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t        data->pos_min += 1;\n                if (data->pos_delta != SSize_t_MAX) {\n                    data->pos_delta += 1;\n                }\n\t\tdata->cur_is_floating = 1; /* float */\n    \t    }\n\t}\n\telse if (REGNODE_SIMPLE(OP(scan))) {\n\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tdata->pos_min++;\n\t    }\n\t    min++;\n\t    if (flags & SCF_DO_STCLASS) {\n                bool invert = 0;\n                SV* my_invlist = NULL;\n                U8 namedclass;\n\n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\n\t\t/* Some of the logic below assumes that switching\n\t\t   locale on will only add false positives. */\n\t\tswitch (OP(scan)) {\n\n\t\tdefault:\n#ifdef DEBUGGING\n                   Perl_croak(aTHX_ \"panic: unexpected simple REx opcode %d\",\n                                                                     OP(scan));\n#endif\n\t\tcase SANY:\n\t\t    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n\t\t\tssc_match_all_cp(data->start_class);\n\t\t    break;\n\n\t\tcase REG_ANY:\n                    {\n                        SV* REG_ANY_invlist = _new_invlist(2);\n                        REG_ANY_invlist = add_cp_to_invlist(REG_ANY_invlist,\n                                                            '\\n');\n                        if (flags & SCF_DO_STCLASS_OR) {\n                            ssc_union(data->start_class,\n                                      REG_ANY_invlist,\n                                      TRUE /* TRUE => invert, hence all but \\n\n                                            */\n                                      );\n                        }\n                        else if (flags & SCF_DO_STCLASS_AND) {\n                            ssc_intersection(data->start_class,\n                                             REG_ANY_invlist,\n                                             TRUE  /* TRUE => invert */\n                                             );\n                            ssc_clear_locale(data->start_class);\n                        }\n                        SvREFCNT_dec_NN(REG_ANY_invlist);\n\t\t    }\n\t\t    break;\n\n                case ANYOFD:\n                case ANYOFL:\n                case ANYOFPOSIXL:\n                case ANYOFH:\n                case ANYOF:\n\t\t    if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state, data->start_class,\n                                (regnode_charclass *) scan);\n\t\t    else\n\t\t\tssc_or(pRExC_state, data->start_class,\n                                                          (regnode_charclass *) scan);\n\t\t    break;\n\n                case NANYOFM:\n                case ANYOFM:\n                  {\n                    SV* cp_list = get_ANYOFM_contents(scan);\n\n                    if (flags & SCF_DO_STCLASS_OR) {\n                        ssc_union(data->start_class, cp_list, invert);\n                    }\n                    else if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class, cp_list, invert);\n                    }\n\n                    SvREFCNT_dec_NN(cp_list);\n                    break;\n                  }\n\n\t\tcase NPOSIXL:\n                    invert = 1;\n                    /* FALLTHROUGH */\n\n\t\tcase POSIXL:\n                    namedclass = classnum_to_namedclass(FLAGS(scan)) + invert;\n                    if (flags & SCF_DO_STCLASS_AND) {\n                        bool was_there = cBOOL(\n                                          ANYOF_POSIXL_TEST(data->start_class,\n                                                                 namedclass));\n                        ANYOF_POSIXL_ZERO(data->start_class);\n                        if (was_there) {    /* Do an AND */\n                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n                        }\n                        /* No individual code points can now match */\n                        data->start_class->invlist\n                                                = sv_2mortal(_new_invlist(0));\n                    }\n                    else {\n                        int complement = namedclass + ((invert) ? -1 : 1);\n\n                        assert(flags & SCF_DO_STCLASS_OR);\n\n                        /* If the complement of this class was already there,\n                         * the result is that they match all code points,\n                         * (\\d + \\D == everything).  Remove the classes from\n                         * future consideration.  Locale is not relevant in\n                         * this case */\n                        if (ANYOF_POSIXL_TEST(data->start_class, complement)) {\n                            ssc_match_all_cp(data->start_class);\n                            ANYOF_POSIXL_CLEAR(data->start_class, namedclass);\n                            ANYOF_POSIXL_CLEAR(data->start_class, complement);\n                        }\n                        else {  /* The usual case; just add this class to the\n                                   existing set */\n                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n                        }\n                    }\n                    break;\n\n                case NPOSIXA:   /* For these, we always know the exact set of\n                                   what's matched */\n                    invert = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXA:\n                    my_invlist = invlist_clone(PL_Posix_ptrs[FLAGS(scan)], NULL);\n                    goto join_posix_and_ascii;\n\n\t\tcase NPOSIXD:\n\t\tcase NPOSIXU:\n                    invert = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXD:\n\t\tcase POSIXU:\n                    my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(scan)], NULL);\n\n                    /* NPOSIXD matches all upper Latin1 code points unless the\n                     * target string being matched is UTF-8, which is\n                     * unknowable until match time.  Since we are going to\n                     * invert, we want to get rid of all of them so that the\n                     * inversion will match all */\n                    if (OP(scan) == NPOSIXD) {\n                        _invlist_subtract(my_invlist, PL_UpperLatin1,\n                                          &my_invlist);\n                    }\n\n                  join_posix_and_ascii:\n\n                    if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class, my_invlist, invert);\n                        ssc_clear_locale(data->start_class);\n                    }\n                    else {\n                        assert(flags & SCF_DO_STCLASS_OR);\n                        ssc_union(data->start_class, my_invlist, invert);\n                    }\n                    SvREFCNT_dec(my_invlist);\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS_OR)\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t    }\n\t}\n\telse if (PL_regkind[OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {\n\t    data->flags |= (OP(scan) == MEOL\n\t\t\t    ? SF_BEFORE_MEOL\n\t\t\t    : SF_BEFORE_SEOL);\n            scan_commit(pRExC_state, data, minlenp, is_inf);\n\n\t}\n\telse if (  PL_regkind[OP(scan)] == BRANCHJ\n\t\t /* Lookbehind, or need to calculate parens/evals/stclass: */\n\t\t   && (scan->flags || data || (flags & SCF_DO_STCLASS))\n\t\t   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM))\n        {\n            if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n                || OP(scan) == UNLESSM )\n            {\n                /* Negative Lookahead/lookbehind\n                   In this case we can't do fixed string optimisation.\n                */\n\n                SSize_t deltanext, minnext, fake = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n                int f = 0;\n\n                StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                if (data) {\n                    data_fake.whilem_c = data->whilem_c;\n                    data_fake.last_closep = data->last_closep;\n\t\t}\n                else\n                    data_fake.last_closep = &fake;\n\t\tdata_fake.pos_delta = delta;\n                if ( flags & SCF_DO_STCLASS && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state, &intrnl);\n                    data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n\t\t}\n                if (flags & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* recurse study_chunk() for lookahead body */\n                minnext = study_chunk(pRExC_state, &nscan, minlenp, &deltanext,\n                                      last, &data_fake, stopparen,\n                                      recursed_depth, NULL, f, depth+1,\n                                      mutate_ok);\n                if (scan->flags) {\n                    if (   deltanext < 0\n                        || deltanext > (I32) U8_MAX\n                        || minnext > (I32)U8_MAX\n                        || minnext + deltanext > (I32)U8_MAX)\n                    {\n\t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                              (UV)U8_MAX);\n                    }\n\n                    /* The 'next_off' field has been repurposed to count the\n                     * additional starting positions to try beyond the initial\n                     * one.  (This leaves it at 0 for non-variable length\n                     * matches to avoid breakage for those not using this\n                     * extension) */\n                    if (deltanext) {\n                        scan->next_off = deltanext;\n                        ckWARNexperimental(RExC_parse,\n                            WARN_EXPERIMENTAL__VLB,\n                            \"Variable length lookbehind is experimental\");\n                    }\n                    scan->flags = (U8)minnext + deltanext;\n                }\n                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c = data_fake.whilem_c;\n                }\n                if (f & SCF_DO_STCLASS_AND) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\t/* OR before, AND after: ideally we would recurse with\n\t\t\t * data_fake to get the AND applied by study of the\n\t\t\t * remainder of the pattern, and then derecurse;\n\t\t\t * *** HACK *** for now just treat as \"no information\".\n\t\t\t * See [perl #56690].\n\t\t\t */\n\t\t\tssc_init(pRExC_state, data->start_class);\n\t\t    }  else {\n                        /* AND before and after: combine and continue.  These\n                         * assertions are zero-length, so can match an EMPTY\n                         * string */\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                        ANYOF_FLAGS(data->start_class)\n                                                   |= SSC_MATCHES_EMPTY_STRING;\n\t\t    }\n                }\n\t    }\n#if PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n            else {\n                /* Positive Lookahead/lookbehind\n                   In this case we can do fixed string optimisation,\n                   but we must be careful about it. Note in the case of\n                   lookbehind the positions will be offset by the minimum\n                   length of the pattern, something we won't know about\n                   until after the recurse.\n                */\n                SSize_t deltanext, fake = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n                int f = 0;\n                /* We use SAVEFREEPV so that when the full compile\n                    is finished perl will clean up the allocated\n                    minlens when it's all done. This way we don't\n                    have to worry about freeing them when we know\n                    they wont be used, which would be a pain.\n                 */\n                SSize_t *minnextp;\n                Newx( minnextp, 1, SSize_t );\n                SAVEFREEPV(minnextp);\n\n                if (data) {\n                    StructCopy(data, &data_fake, scan_data_t);\n                    if ((flags & SCF_DO_SUBSTR) && data->last_found) {\n                        f |= SCF_DO_SUBSTR;\n                        if (scan->flags)\n                            scan_commit(pRExC_state, &data_fake, minlenp, is_inf);\n                        data_fake.last_found=newSVsv(data->last_found);\n                    }\n                }\n                else\n                    data_fake.last_closep = &fake;\n                data_fake.flags = 0;\n                data_fake.substrs[0].flags = 0;\n                data_fake.substrs[1].flags = 0;\n\t\tdata_fake.pos_delta = delta;\n                if (is_inf)\n\t            data_fake.flags |= SF_IS_INF;\n                if ( flags & SCF_DO_STCLASS && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state, &intrnl);\n                    data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n                }\n                if (flags & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* positive lookahead study_chunk() recursion */\n                *minnextp = study_chunk(pRExC_state, &nscan, minnextp,\n                                        &deltanext, last, &data_fake,\n                                        stopparen, recursed_depth, NULL,\n                                        f, depth+1, mutate_ok);\n                if (scan->flags) {\n                    assert(0);  /* This code has never been tested since this\n                                   is normally not compiled */\n                    if (   deltanext < 0\n                        || deltanext > (I32) U8_MAX\n                        || *minnextp > (I32)U8_MAX\n                        || *minnextp + deltanext > (I32)U8_MAX)\n                    {\n\t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                              (UV)U8_MAX);\n                    }\n\n                    if (deltanext) {\n                        scan->next_off = deltanext;\n                    }\n                    scan->flags = (U8)*minnextp + deltanext;\n                }\n\n                *minnextp += min;\n\n                if (f & SCF_DO_STCLASS_AND) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                    ANYOF_FLAGS(data->start_class) |= SSC_MATCHES_EMPTY_STRING;\n                }\n                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c = data_fake.whilem_c;\n                    if ((flags & SCF_DO_SUBSTR) && data_fake.last_found) {\n                        int i;\n                        if (RExC_rx->minlen<*minnextp)\n                            RExC_rx->minlen=*minnextp;\n                        scan_commit(pRExC_state, &data_fake, minnextp, is_inf);\n                        SvREFCNT_dec_NN(data_fake.last_found);\n\n                        for (i = 0; i < 2; i++) {\n                            if (data_fake.substrs[i].minlenp != minlenp) {\n                                data->substrs[i].min_offset =\n                                            data_fake.substrs[i].min_offset;\n                                data->substrs[i].max_offset =\n                                            data_fake.substrs[i].max_offset;\n                                data->substrs[i].minlenp =\n                                            data_fake.substrs[i].minlenp;\n                                data->substrs[i].lookbehind += scan->flags;\n                            }\n                        }\n                    }\n                }\n\t    }\n#endif\n\t}\n\n\telse if (OP(scan) == OPEN) {\n\t    if (stopparen != (I32)ARG(scan))\n\t        pars++;\n\t}\n\telse if (OP(scan) == CLOSE) {\n\t    if (stopparen == (I32)ARG(scan)) {\n\t        break;\n\t    }\n\t    if ((I32)ARG(scan) == is_par) {\n\t\tnext = regnext(scan);\n\n\t\tif ( next && (OP(next) != WHILEM) && next < last)\n\t\t    is_par = 0;\t\t/* Disable optimization */\n\t    }\n\t    if (data)\n\t\t*(data->last_closep) = ARG(scan);\n\t}\n\telse if (OP(scan) == EVAL) {\n\t\tif (data)\n\t\t    data->flags |= SF_HAS_EVAL;\n\t}\n\telse if ( PL_regkind[OP(scan)] == ENDLIKE ) {\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tflags &= ~SCF_DO_SUBSTR;\n\t    }\n\t    if (data && OP(scan)==ACCEPT) {\n\t        data->flags |= SCF_SEEN_ACCEPT;\n\t        if (stopmin > min)\n\t            stopmin = min;\n\t    }\n\t}\n\telse if (OP(scan) == LOGICAL && scan->flags == 2) /* Embedded follows */\n\t{\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n\t\t    ssc_anything(data->start_class);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t}\n\telse if (OP(scan) == GPOS) {\n            if (!(RExC_rx->intflags & PREGf_GPOS_FLOAT) &&\n\t        !(delta || is_inf || (data && data->pos_delta)))\n\t    {\n                if (!(RExC_rx->intflags & PREGf_ANCH) && (flags & SCF_DO_SUBSTR))\n                    RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t        if (RExC_rx->gofs < (STRLEN)min)\n\t\t    RExC_rx->gofs = min;\n            } else {\n                RExC_rx->intflags |= PREGf_GPOS_FLOAT;\n                RExC_rx->gofs = 0;\n            }\n\t}\n#ifdef TRIE_STUDY_OPT\n#ifdef FULL_TRIE_STUDY\n        else if (PL_regkind[OP(scan)] == TRIE) {\n            /* NOTE - There is similar code to this block above for handling\n               BRANCH nodes on the initial study.  If you change stuff here\n               check there too. */\n            regnode *trie_node= scan;\n            regnode *tail= regnext(scan);\n            reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n            SSize_t max1 = 0, min1 = SSize_t_MAX;\n            regnode_ssc accum;\n\n            if (flags & SCF_DO_SUBSTR) { /* XXXX Add !SUSPEND? */\n                /* Cannot merge strings after this. */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n            }\n            if (flags & SCF_DO_STCLASS)\n                ssc_init_zero(pRExC_state, &accum);\n\n            if (!trie->jump) {\n                min1= trie->minlen;\n                max1= trie->maxlen;\n            } else {\n                const regnode *nextbranch= NULL;\n                U32 word;\n\n                for ( word=1 ; word <= trie->wordcount ; word++)\n                {\n                    SSize_t deltanext=0, minnext=0, f = 0, fake;\n                    regnode_ssc this_class;\n\n                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                    if (data) {\n                        data_fake.whilem_c = data->whilem_c;\n                        data_fake.last_closep = data->last_closep;\n                    }\n                    else\n                        data_fake.last_closep = &fake;\n\t\t    data_fake.pos_delta = delta;\n                    if (flags & SCF_DO_STCLASS) {\n                        ssc_init(pRExC_state, &this_class);\n                        data_fake.start_class = &this_class;\n                        f = SCF_DO_STCLASS_AND;\n                    }\n                    if (flags & SCF_WHILEM_VISITED_POS)\n                        f |= SCF_WHILEM_VISITED_POS;\n\n                    if (trie->jump[word]) {\n                        if (!nextbranch)\n                            nextbranch = trie_node + trie->jump[0];\n                        scan= trie_node + trie->jump[word];\n                        /* We go from the jump point to the branch that follows\n                           it. Note this means we need the vestigal unused\n                           branches even though they arent otherwise used. */\n                        /* optimise study_chunk() for TRIE */\n                        minnext = study_chunk(pRExC_state, &scan, minlenp,\n                            &deltanext, (regnode *)nextbranch, &data_fake,\n                            stopparen, recursed_depth, NULL, f, depth+1,\n                            mutate_ok);\n                    }\n                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n                        nextbranch= regnext((regnode*)nextbranch);\n\n                    if (min1 > (SSize_t)(minnext + trie->minlen))\n                        min1 = minnext + trie->minlen;\n                    if (deltanext == SSize_t_MAX) {\n                        is_inf = is_inf_internal = 1;\n                        max1 = SSize_t_MAX;\n                    } else if (max1 < (SSize_t)(minnext + deltanext + trie->maxlen))\n                        max1 = minnext + deltanext + trie->maxlen;\n\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SCF_SEEN_ACCEPT) {\n                        if ( stopmin > min + min1)\n\t                    stopmin = min + min1;\n\t                flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n                    if (data) {\n                        if (data_fake.flags & SF_HAS_EVAL)\n                            data->flags |= SF_HAS_EVAL;\n                        data->whilem_c = data_fake.whilem_c;\n                    }\n                    if (flags & SCF_DO_STCLASS)\n                        ssc_or(pRExC_state, &accum, (regnode_charclass *) &this_class);\n                }\n            }\n            if (flags & SCF_DO_SUBSTR) {\n                data->pos_min += min1;\n                data->pos_delta += max1 - min1;\n                if (max1 != min1 || is_inf)\n                    data->cur_is_floating = 1; /* float */\n            }\n            min += min1;\n            if (delta != SSize_t_MAX) {\n                if (SSize_t_MAX - (max1 - min1) >= delta)\n                    delta += max1 - min1;\n                else\n                    delta = SSize_t_MAX;\n            }\n            if (flags & SCF_DO_STCLASS_OR) {\n                ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                if (min1) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n                    flags &= ~SCF_DO_STCLASS;\n                }\n            }\n            else if (flags & SCF_DO_STCLASS_AND) {\n                if (min1) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                    flags &= ~SCF_DO_STCLASS;\n                }\n                else {\n                    /* Switch to OR mode: cache the old value of\n                     * data->start_class */\n\t\t    INIT_AND_WITHP;\n                    StructCopy(data->start_class, and_withp, regnode_ssc);\n                    flags &= ~SCF_DO_STCLASS_AND;\n                    StructCopy(&accum, data->start_class, regnode_ssc);\n                    flags |= SCF_DO_STCLASS_OR;\n                }\n            }\n            scan= tail;\n            continue;\n        }\n#else\n\telse if (PL_regkind[OP(scan)] == TRIE) {\n\t    reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n\t    U8*bang=NULL;\n\n\t    min += trie->minlen;\n\t    delta += (trie->maxlen - trie->minlen);\n\t    flags &= ~SCF_DO_STCLASS; /* xxx */\n            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything... */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t        data->pos_min += trie->minlen;\n    \t        data->pos_delta += (trie->maxlen - trie->minlen);\n\t\tif (trie->maxlen != trie->minlen)\n\t\t    data->cur_is_floating = 1; /* float */\n    \t    }\n    \t    if (trie->jump) /* no more substrings -- for now /grr*/\n               flags &= ~SCF_DO_SUBSTR;\n\t}\n#endif /* old or new */\n#endif /* TRIE_STUDY_OPT */\n\n\t/* Else: zero-length, ignore. */\n\tscan = regnext(scan);\n    }\n\n  finish:\n    if (frame) {\n        /* we need to unwind recursion. */\n        depth = depth - 1;\n\n        DEBUG_STUDYDATA(\"frame-end\", data, depth, is_inf);\n        DEBUG_PEEP(\"fend\", scan, depth, flags);\n\n        /* restore previous context */\n        last = frame->last_regnode;\n        scan = frame->next_regnode;\n        stopparen = frame->stopparen;\n        recursed_depth = frame->prev_recursed_depth;\n\n        RExC_frame_last = frame->prev_frame;\n        frame = frame->this_prev_frame;\n        goto fake_study_recurse;\n    }\n\n    assert(!frame);\n    DEBUG_STUDYDATA(\"pre-fin\", data, depth, is_inf);\n\n    *scanp = scan;\n    *deltap = is_inf_internal ? SSize_t_MAX : delta;\n\n    if (flags & SCF_DO_SUBSTR && is_inf)\n\tdata->pos_delta = SSize_t_MAX - data->pos_min;\n    if (is_par > (I32)U8_MAX)\n\tis_par = 0;\n    if (is_par && pars==1 && data) {\n\tdata->flags |= SF_IN_PAR;\n\tdata->flags &= ~SF_HAS_PAR;\n    }\n    else if (pars && data) {\n\tdata->flags |= SF_HAS_PAR;\n\tdata->flags &= ~SF_IN_PAR;\n    }\n    if (flags & SCF_DO_STCLASS_OR)\n\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n    if (flags & SCF_TRIE_RESTUDY)\n        data->flags |= \tSCF_TRIE_RESTUDY;\n\n    DEBUG_STUDYDATA(\"post-fin\", data, depth, is_inf);\n\n    {\n        SSize_t final_minlen= min < stopmin ? min : stopmin;\n\n        if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)) {\n            if (final_minlen > SSize_t_MAX - delta)\n                RExC_maxlen = SSize_t_MAX;\n            else if (RExC_maxlen < final_minlen + delta)\n                RExC_maxlen = final_minlen + delta;\n        }\n        return final_minlen;\n    }\n    NOT_REACHED; /* NOTREACHED */\n}\n\nSTATIC U32\nS_add_data(RExC_state_t* const pRExC_state, const char* const s, const U32 n)\n{\n    U32 count = RExC_rxi->data ? RExC_rxi->data->count : 0;\n\n    PERL_ARGS_ASSERT_ADD_DATA;\n\n    Renewc(RExC_rxi->data,\n\t   sizeof(*RExC_rxi->data) + sizeof(void*) * (count + n - 1),\n\t   char, struct reg_data);\n    if(count)\n\tRenew(RExC_rxi->data->what, count + n, U8);\n    else\n\tNewx(RExC_rxi->data->what, n, U8);\n    RExC_rxi->data->count = count + n;\n    Copy(s, RExC_rxi->data->what + count, n, U8);\n    return count;\n}\n\n/*XXX: todo make this not included in a non debugging perl, but appears to be\n * used anyway there, in 'use re' */\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_reginitcolors(pTHX)\n{\n    const char * const s = PerlEnv_getenv(\"PERL_RE_COLORS\");\n    if (s) {\n\tchar *t = savepv(s);\n\tint i = 0;\n\tPL_colors[0] = t;\n\twhile (++i < 6) {\n\t    t = strchr(t, '\\t');\n\t    if (t) {\n\t\t*t = '\\0';\n\t\tPL_colors[i] = ++t;\n\t    }\n\t    else\n\t\tPL_colors[i] = t = (char *)\"\";\n\t}\n    } else {\n\tint i = 0;\n\twhile (i < 6)\n\t    PL_colors[i++] = (char *)\"\";\n    }\n    PL_colorset = 1;\n}\n#endif\n\n\n#ifdef TRIE_STUDY_OPT\n#define CHECK_RESTUDY_GOTO_butfirst(dOsomething)            \\\n    STMT_START {                                            \\\n        if (                                                \\\n              (data.flags & SCF_TRIE_RESTUDY)               \\\n              && ! restudied++                              \\\n        ) {                                                 \\\n            dOsomething;                                    \\\n            goto reStudy;                                   \\\n        }                                                   \\\n    } STMT_END\n#else\n#define CHECK_RESTUDY_GOTO_butfirst\n#endif\n\n/*\n * pregcomp - compile a regular expression into internal code\n *\n * Decides which engine's compiler to call based on the hint currently in\n * scope\n */\n\n#ifndef PERL_IN_XSUB_RE\n\n/* return the currently in-scope regex engine (or the default if none)  */\n\nregexp_engine const *\nPerl_current_re_engine(pTHX)\n{\n    if (IN_PERL_COMPILETIME) {\n\tHV * const table = GvHV(PL_hintgv);\n\tSV **ptr;\n\n\tif (!table || !(PL_hints & HINT_LOCALIZE_HH))\n\t    return &PL_core_reg_engine;\n\tptr = hv_fetchs(table, \"regcomp\", FALSE);\n\tif ( !(ptr && SvIOK(*ptr) && SvIV(*ptr)))\n\t    return &PL_core_reg_engine;\n\treturn INT2PTR(regexp_engine*, SvIV(*ptr));\n    }\n    else {\n\tSV *ptr;\n\tif (!PL_curcop->cop_hints_hash)\n\t    return &PL_core_reg_engine;\n\tptr = cop_hints_fetch_pvs(PL_curcop, \"regcomp\", 0);\n\tif ( !(ptr && SvIOK(ptr) && SvIV(ptr)))\n\t    return &PL_core_reg_engine;\n\treturn INT2PTR(regexp_engine*, SvIV(ptr));\n    }\n}\n\n\nREGEXP *\nPerl_pregcomp(pTHX_ SV * const pattern, const U32 flags)\n{\n    regexp_engine const *eng = current_re_engine();\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_PREGCOMP;\n\n    /* Dispatch a request to compile a regexp to correct regexp engine. */\n    DEBUG_COMPILE_r({\n        Perl_re_printf( aTHX_  \"Using engine %\" UVxf \"\\n\",\n\t\t\tPTR2UV(eng));\n    });\n    return CALLREGCOMP_ENG(eng, pattern, flags);\n}\n#endif\n\n/* public(ish) entry point for the perl core's own regex compiling code.\n * It's actually a wrapper for Perl_re_op_compile that only takes an SV\n * pattern rather than a list of OPs, and uses the internal engine rather\n * than the current one */\n\nREGEXP *\nPerl_re_compile(pTHX_ SV * const pattern, U32 rx_flags)\n{\n    SV *pat = pattern; /* defeat constness! */\n    PERL_ARGS_ASSERT_RE_COMPILE;\n    return Perl_re_op_compile(aTHX_ &pat, 1, NULL,\n#ifdef PERL_IN_XSUB_RE\n                                &my_reg_engine,\n#else\n                                &PL_core_reg_engine,\n#endif\n                                NULL, NULL, rx_flags, 0);\n}\n\n\nstatic void\nS_free_codeblocks(pTHX_ struct reg_code_blocks *cbs)\n{\n    int n;\n\n    if (--cbs->refcnt > 0)\n        return;\n    for (n = 0; n < cbs->count; n++) {\n        REGEXP *rx = cbs->cb[n].src_regex;\n        if (rx) {\n            cbs->cb[n].src_regex = NULL;\n            SvREFCNT_dec_NN(rx);\n        }\n    }\n    Safefree(cbs->cb);\n    Safefree(cbs);\n}\n\n\nstatic struct reg_code_blocks *\nS_alloc_code_blocks(pTHX_  int ncode)\n{\n     struct reg_code_blocks *cbs;\n    Newx(cbs, 1, struct reg_code_blocks);\n    cbs->count = ncode;\n    cbs->refcnt = 1;\n    SAVEDESTRUCTOR_X(S_free_codeblocks, cbs);\n    if (ncode)\n        Newx(cbs->cb, ncode, struct reg_code_block);\n    else\n        cbs->cb = NULL;\n    return cbs;\n}\n\n\n/* upgrade pattern pat_p of length plen_p to UTF8, and if there are code\n * blocks, recalculate the indices. Update pat_p and plen_p in-place to\n * point to the realloced string and length.\n *\n * This is essentially a copy of Perl_bytes_to_utf8() with the code index\n * stuff added */\n\nstatic void\nS_pat_upgrade_to_utf8(pTHX_ RExC_state_t * const pRExC_state,\n\t\t    char **pat_p, STRLEN *plen_p, int num_code_blocks)\n{\n    U8 *const src = (U8*)*pat_p;\n    U8 *dst, *d;\n    int n=0;\n    STRLEN s = 0;\n    bool do_end = 0;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    DEBUG_PARSE_r(Perl_re_printf( aTHX_\n        \"UTF8 mismatch! Converting to utf8 for resizing and compile\\n\"));\n\n    /* 1 for each byte + 1 for each byte that expands to two, + trailing NUL */\n    Newx(dst, *plen_p + variant_under_utf8_count(src, src + *plen_p) + 1, U8);\n    d = dst;\n\n    while (s < *plen_p) {\n        append_utf8_from_native_byte(src[s], &d);\n\n        if (n < num_code_blocks) {\n            assert(pRExC_state->code_blocks);\n            if (!do_end && pRExC_state->code_blocks->cb[n].start == s) {\n                pRExC_state->code_blocks->cb[n].start = d - dst - 1;\n                assert(*(d - 1) == '(');\n                do_end = 1;\n            }\n            else if (do_end && pRExC_state->code_blocks->cb[n].end == s) {\n                pRExC_state->code_blocks->cb[n].end = d - dst - 1;\n                assert(*(d - 1) == ')');\n                do_end = 0;\n                n++;\n            }\n        }\n        s++;\n    }\n    *d = '\\0';\n    *plen_p = d - dst;\n    *pat_p = (char*) dst;\n    SAVEFREEPV(*pat_p);\n    RExC_orig_utf8 = RExC_utf8 = 1;\n}\n\n\n\n/* S_concat_pat(): concatenate a list of args to the pattern string pat,\n * while recording any code block indices, and handling overloading,\n * nested qr// objects etc.  If pat is null, it will allocate a new\n * string, or just return the first arg, if there's only one.\n *\n * Returns the malloced/updated pat.\n * patternp and pat_count is the array of SVs to be concatted;\n * oplist is the optional list of ops that generated the SVs;\n * recompile_p is a pointer to a boolean that will be set if\n *   the regex will need to be recompiled.\n * delim, if non-null is an SV that will be inserted between each element\n */\n\nstatic SV*\nS_concat_pat(pTHX_ RExC_state_t * const pRExC_state,\n                SV *pat, SV ** const patternp, int pat_count,\n                OP *oplist, bool *recompile_p, SV *delim)\n{\n    SV **svp;\n    int n = 0;\n    bool use_delim = FALSE;\n    bool alloced = FALSE;\n\n    /* if we know we have at least two args, create an empty string,\n     * then concatenate args to that. For no args, return an empty string */\n    if (!pat && pat_count != 1) {\n        pat = newSVpvs(\"\");\n        SAVEFREESV(pat);\n        alloced = TRUE;\n    }\n\n    for (svp = patternp; svp < patternp + pat_count; svp++) {\n        SV *sv;\n        SV *rx  = NULL;\n        STRLEN orig_patlen = 0;\n        bool code = 0;\n        SV *msv = use_delim ? delim : *svp;\n        if (!msv) msv = &PL_sv_undef;\n\n        /* if we've got a delimiter, we go round the loop twice for each\n         * svp slot (except the last), using the delimiter the second\n         * time round */\n        if (use_delim) {\n            svp--;\n            use_delim = FALSE;\n        }\n        else if (delim)\n            use_delim = TRUE;\n\n        if (SvTYPE(msv) == SVt_PVAV) {\n            /* we've encountered an interpolated array within\n             * the pattern, e.g. /...@a..../. Expand the list of elements,\n             * then recursively append elements.\n             * The code in this block is based on S_pushav() */\n\n            AV *const av = (AV*)msv;\n            const SSize_t maxarg = AvFILL(av) + 1;\n            SV **array;\n\n            if (oplist) {\n                assert(oplist->op_type == OP_PADAV\n                    || oplist->op_type == OP_RV2AV);\n                oplist = OpSIBLING(oplist);\n            }\n\n            if (SvRMAGICAL(av)) {\n                SSize_t i;\n\n                Newx(array, maxarg, SV*);\n                SAVEFREEPV(array);\n                for (i=0; i < maxarg; i++) {\n                    SV ** const svp = av_fetch(av, i, FALSE);\n                    array[i] = svp ? *svp : &PL_sv_undef;\n                }\n            }\n            else\n                array = AvARRAY(av);\n\n            pat = S_concat_pat(aTHX_ pRExC_state, pat,\n                                array, maxarg, NULL, recompile_p,\n                                /* $\" */\n                                GvSV((gv_fetchpvs(\"\\\"\", GV_ADDMULTI, SVt_PV))));\n\n            continue;\n        }\n\n\n        /* we make the assumption here that each op in the list of\n         * op_siblings maps to one SV pushed onto the stack,\n         * except for code blocks, with have both an OP_NULL and\n         * and OP_CONST.\n         * This allows us to match up the list of SVs against the\n         * list of OPs to find the next code block.\n         *\n         * Note that       PUSHMARK PADSV PADSV ..\n         * is optimised to\n         *                 PADRANGE PADSV  PADSV  ..\n         * so the alignment still works. */\n\n        if (oplist) {\n            if (oplist->op_type == OP_NULL\n                && (oplist->op_flags & OPf_SPECIAL))\n            {\n                assert(n < pRExC_state->code_blocks->count);\n                pRExC_state->code_blocks->cb[n].start = pat ? SvCUR(pat) : 0;\n                pRExC_state->code_blocks->cb[n].block = oplist;\n                pRExC_state->code_blocks->cb[n].src_regex = NULL;\n                n++;\n                code = 1;\n                oplist = OpSIBLING(oplist); /* skip CONST */\n                assert(oplist);\n            }\n            oplist = OpSIBLING(oplist);;\n        }\n\n\t/* apply magic and QR overloading to arg */\n\n        SvGETMAGIC(msv);\n        if (SvROK(msv) && SvAMAGIC(msv)) {\n            SV *sv = AMG_CALLunary(msv, regexp_amg);\n            if (sv) {\n                if (SvROK(sv))\n                    sv = SvRV(sv);\n                if (SvTYPE(sv) != SVt_REGEXP)\n                    Perl_croak(aTHX_ \"Overloaded qr did not return a REGEXP\");\n                msv = sv;\n            }\n        }\n\n        /* try concatenation overload ... */\n        if (pat && (SvAMAGIC(pat) || SvAMAGIC(msv)) &&\n                (sv = amagic_call(pat, msv, concat_amg, AMGf_assign)))\n        {\n            sv_setsv(pat, sv);\n            /* overloading involved: all bets are off over literal\n             * code. Pretend we haven't seen it */\n            if (n)\n                pRExC_state->code_blocks->count -= n;\n            n = 0;\n        }\n        else  {\n            /* ... or failing that, try \"\" overload */\n            while (SvAMAGIC(msv)\n                    && (sv = AMG_CALLunary(msv, string_amg))\n                    && sv != msv\n                    &&  !(   SvROK(msv)\n                          && SvROK(sv)\n                          && SvRV(msv) == SvRV(sv))\n            ) {\n                msv = sv;\n                SvGETMAGIC(msv);\n            }\n            if (SvROK(msv) && SvTYPE(SvRV(msv)) == SVt_REGEXP)\n                msv = SvRV(msv);\n\n            if (pat) {\n                /* this is a partially unrolled\n                 *     sv_catsv_nomg(pat, msv);\n                 * that allows us to adjust code block indices if\n                 * needed */\n                STRLEN dlen;\n                char *dst = SvPV_force_nomg(pat, dlen);\n                orig_patlen = dlen;\n                if (SvUTF8(msv) && !SvUTF8(pat)) {\n                    S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &dst, &dlen, n);\n                    sv_setpvn(pat, dst, dlen);\n                    SvUTF8_on(pat);\n                }\n                sv_catsv_nomg(pat, msv);\n                rx = msv;\n            }\n            else {\n                /* We have only one SV to process, but we need to verify\n                 * it is properly null terminated or we will fail asserts\n                 * later. In theory we probably shouldn't get such SV's,\n                 * but if we do we should handle it gracefully. */\n                if ( SvTYPE(msv) != SVt_PV || (SvLEN(msv) > SvCUR(msv) && *(SvEND(msv)) == 0) || SvIsCOW_shared_hash(msv) ) {\n                    /* not a string, or a string with a trailing null */\n                    pat = msv;\n                } else {\n                    /* a string with no trailing null, we need to copy it\n                     * so it has a trailing null */\n                    pat = sv_2mortal(newSVsv(msv));\n                }\n            }\n\n            if (code)\n                pRExC_state->code_blocks->cb[n-1].end = SvCUR(pat)-1;\n        }\n\n        /* extract any code blocks within any embedded qr//'s */\n        if (rx && SvTYPE(rx) == SVt_REGEXP\n            && RX_ENGINE((REGEXP*)rx)->op_comp)\n        {\n\n            RXi_GET_DECL(ReANY((REGEXP *)rx), ri);\n            if (ri->code_blocks && ri->code_blocks->count) {\n                int i;\n                /* the presence of an embedded qr// with code means\n                 * we should always recompile: the text of the\n                 * qr// may not have changed, but it may be a\n                 * different closure than last time */\n                *recompile_p = 1;\n                if (pRExC_state->code_blocks) {\n                    int new_count = pRExC_state->code_blocks->count\n                            + ri->code_blocks->count;\n                    Renew(pRExC_state->code_blocks->cb,\n                            new_count, struct reg_code_block);\n                    pRExC_state->code_blocks->count = new_count;\n                }\n                else\n                    pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_\n                                                    ri->code_blocks->count);\n\n                for (i=0; i < ri->code_blocks->count; i++) {\n                    struct reg_code_block *src, *dst;\n                    STRLEN offset =  orig_patlen\n                        + ReANY((REGEXP *)rx)->pre_prefix;\n                    assert(n < pRExC_state->code_blocks->count);\n                    src = &ri->code_blocks->cb[i];\n                    dst = &pRExC_state->code_blocks->cb[n];\n                    dst->start\t    = src->start + offset;\n                    dst->end\t    = src->end   + offset;\n                    dst->block\t    = src->block;\n                    dst->src_regex  = (REGEXP*) SvREFCNT_inc( (SV*)\n                                            src->src_regex\n                                                ? src->src_regex\n                                                : (REGEXP*)rx);\n                    n++;\n                }\n            }\n        }\n    }\n    /* avoid calling magic multiple times on a single element e.g. =~ $qr */\n    if (alloced)\n        SvSETMAGIC(pat);\n\n    return pat;\n}\n\n\n\n/* see if there are any run-time code blocks in the pattern.\n * False positives are allowed */\n\nstatic bool\nS_has_runtime_code(pTHX_ RExC_state_t * const pRExC_state,\n\t\t    char *pat, STRLEN plen)\n{\n    int n = 0;\n    STRLEN s;\n\n    PERL_UNUSED_CONTEXT;\n\n    for (s = 0; s < plen; s++) {\n\tif (   pRExC_state->code_blocks\n            && n < pRExC_state->code_blocks->count\n\t    && s == pRExC_state->code_blocks->cb[n].start)\n\t{\n\t    s = pRExC_state->code_blocks->cb[n].end;\n\t    n++;\n\t    continue;\n\t}\n\t/* TODO ideally should handle [..], (#..), /#.../x to reduce false\n\t * positives here */\n\tif (pat[s] == '(' && s+2 <= plen && pat[s+1] == '?' &&\n\t    (pat[s+2] == '{'\n                || (s + 2 <= plen && pat[s+2] == '?' && pat[s+3] == '{'))\n\t)\n\t    return 1;\n    }\n    return 0;\n}\n\n/* Handle run-time code blocks. We will already have compiled any direct\n * or indirect literal code blocks. Now, take the pattern 'pat' and make a\n * copy of it, but with any literal code blocks blanked out and\n * appropriate chars escaped; then feed it into\n *\n *    eval \"qr'modified_pattern'\"\n *\n * For example,\n *\n *       a\\bc(?{\"this was literal\"})def'ghi\\\\jkl(?{\"this is runtime\"})mno\n *\n * becomes\n *\n *    qr'a\\\\bc_______________________def\\'ghi\\\\\\\\jkl(?{\"this is runtime\"})mno'\n *\n * After eval_sv()-ing that, grab any new code blocks from the returned qr\n * and merge them with any code blocks of the original regexp.\n *\n * If the pat is non-UTF8, while the evalled qr is UTF8, don't merge;\n * instead, just save the qr and return FALSE; this tells our caller that\n * the original pattern needs upgrading to utf8.\n */\n\nstatic bool\nS_compile_runtime_code(pTHX_ RExC_state_t * const pRExC_state,\n    char *pat, STRLEN plen)\n{\n    SV *qr;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    if (pRExC_state->runtime_code_qr) {\n\t/* this is the second time we've been called; this should\n\t * only happen if the main pattern got upgraded to utf8\n\t * during compilation; re-use the qr we compiled first time\n\t * round (which should be utf8 too)\n\t */\n\tqr = pRExC_state->runtime_code_qr;\n\tpRExC_state->runtime_code_qr = NULL;\n\tassert(RExC_utf8 && SvUTF8(qr));\n    }\n    else {\n\tint n = 0;\n\tSTRLEN s;\n\tchar *p, *newpat;\n\tint newlen = plen + 7; /* allow for \"qr''xx\\0\" extra chars */\n\tSV *sv, *qr_ref;\n\tdSP;\n\n\t/* determine how many extra chars we need for ' and \\ escaping */\n\tfor (s = 0; s < plen; s++) {\n\t    if (pat[s] == '\\'' || pat[s] == '\\\\')\n\t\tnewlen++;\n\t}\n\n\tNewx(newpat, newlen, char);\n\tp = newpat;\n\t*p++ = 'q'; *p++ = 'r'; *p++ = '\\'';\n\n\tfor (s = 0; s < plen; s++) {\n\t    if (   pRExC_state->code_blocks\n\t        && n < pRExC_state->code_blocks->count\n\t\t&& s == pRExC_state->code_blocks->cb[n].start)\n\t    {\n\t\t/* blank out literal code block so that they aren't\n                 * recompiled: eg change from/to:\n                 *     /(?{xyz})/\n                 *     /(?=====)/\n                 * and\n                 *     /(??{xyz})/\n                 *     /(?======)/\n                 * and\n                 *     /(?(?{xyz}))/\n                 *     /(?(?=====))/\n                */\n\t\tassert(pat[s]   == '(');\n\t\tassert(pat[s+1] == '?');\n                *p++ = '(';\n                *p++ = '?';\n                s += 2;\n\t\twhile (s < pRExC_state->code_blocks->cb[n].end) {\n\t\t    *p++ = '=';\n\t\t    s++;\n\t\t}\n                *p++ = ')';\n\t\tn++;\n\t\tcontinue;\n\t    }\n\t    if (pat[s] == '\\'' || pat[s] == '\\\\')\n\t\t*p++ = '\\\\';\n\t    *p++ = pat[s];\n\t}\n\t*p++ = '\\'';\n\tif (pRExC_state->pm_flags & RXf_PMf_EXTENDED) {\n\t    *p++ = 'x';\n            if (pRExC_state->pm_flags & RXf_PMf_EXTENDED_MORE) {\n                *p++ = 'x';\n            }\n        }\n\t*p++ = '\\0';\n\tDEBUG_COMPILE_r({\n            Perl_re_printf( aTHX_\n\t\t\"%sre-parsing pattern for runtime code:%s %s\\n\",\n\t\tPL_colors[4], PL_colors[5], newpat);\n\t});\n\n\tsv = newSVpvn_flags(newpat, p-newpat-1, RExC_utf8 ? SVf_UTF8 : 0);\n\tSafefree(newpat);\n\n\tENTER;\n\tSAVETMPS;\n\tsave_re_context();\n\tPUSHSTACKi(PERLSI_REQUIRE);\n        /* G_RE_REPARSING causes the toker to collapse \\\\ into \\ when\n         * parsing qr''; normally only q'' does this. It also alters\n         * hints handling */\n\teval_sv(sv, G_SCALAR|G_RE_REPARSING);\n\tSvREFCNT_dec_NN(sv);\n\tSPAGAIN;\n\tqr_ref = POPs;\n\tPUTBACK;\n\t{\n\t    SV * const errsv = ERRSV;\n\t    if (SvTRUE_NN(errsv))\n                /* use croak_sv ? */\n\t\tPerl_croak_nocontext(\"%\" SVf, SVfARG(errsv));\n\t}\n\tassert(SvROK(qr_ref));\n\tqr = SvRV(qr_ref);\n\tassert(SvTYPE(qr) == SVt_REGEXP && RX_ENGINE((REGEXP*)qr)->op_comp);\n\t/* the leaving below frees the tmp qr_ref.\n\t * Give qr a life of its own */\n\tSvREFCNT_inc(qr);\n\tPOPSTACK;\n\tFREETMPS;\n\tLEAVE;\n\n    }\n\n    if (!RExC_utf8 && SvUTF8(qr)) {\n\t/* first time through; the pattern got upgraded; save the\n\t * qr for the next time through */\n\tassert(!pRExC_state->runtime_code_qr);\n\tpRExC_state->runtime_code_qr = qr;\n\treturn 0;\n    }\n\n\n    /* extract any code blocks within the returned qr//  */\n\n\n    /* merge the main (r1) and run-time (r2) code blocks into one */\n    {\n\tRXi_GET_DECL(ReANY((REGEXP *)qr), r2);\n\tstruct reg_code_block *new_block, *dst;\n\tRExC_state_t * const r1 = pRExC_state; /* convenient alias */\n\tint i1 = 0, i2 = 0;\n        int r1c, r2c;\n\n\tif (!r2->code_blocks || !r2->code_blocks->count) /* we guessed wrong */\n\t{\n\t    SvREFCNT_dec_NN(qr);\n\t    return 1;\n\t}\n\n        if (!r1->code_blocks)\n            r1->code_blocks = S_alloc_code_blocks(aTHX_ 0);\n\n        r1c = r1->code_blocks->count;\n        r2c = r2->code_blocks->count;\n\n\tNewx(new_block, r1c + r2c, struct reg_code_block);\n\n\tdst = new_block;\n\n\twhile (i1 < r1c || i2 < r2c) {\n\t    struct reg_code_block *src;\n\t    bool is_qr = 0;\n\n\t    if (i1 == r1c) {\n\t\tsrc = &r2->code_blocks->cb[i2++];\n\t\tis_qr = 1;\n\t    }\n\t    else if (i2 == r2c)\n\t\tsrc = &r1->code_blocks->cb[i1++];\n\t    else if (  r1->code_blocks->cb[i1].start\n\t             < r2->code_blocks->cb[i2].start)\n\t    {\n\t\tsrc = &r1->code_blocks->cb[i1++];\n\t\tassert(src->end < r2->code_blocks->cb[i2].start);\n\t    }\n\t    else {\n\t\tassert(  r1->code_blocks->cb[i1].start\n\t\t       > r2->code_blocks->cb[i2].start);\n\t\tsrc = &r2->code_blocks->cb[i2++];\n\t\tis_qr = 1;\n\t\tassert(src->end < r1->code_blocks->cb[i1].start);\n\t    }\n\n\t    assert(pat[src->start] == '(');\n\t    assert(pat[src->end]   == ')');\n\t    dst->start\t    = src->start;\n\t    dst->end\t    = src->end;\n\t    dst->block\t    = src->block;\n\t    dst->src_regex  = is_qr ? (REGEXP*) SvREFCNT_inc( (SV*) qr)\n\t\t\t\t    : src->src_regex;\n\t    dst++;\n\t}\n\tr1->code_blocks->count += r2c;\n\tSafefree(r1->code_blocks->cb);\n\tr1->code_blocks->cb = new_block;\n    }\n\n    SvREFCNT_dec_NN(qr);\n    return 1;\n}\n\n\nSTATIC bool\nS_setup_longest(pTHX_ RExC_state_t *pRExC_state,\n                      struct reg_substr_datum  *rsd,\n                      struct scan_data_substrs *sub,\n                      STRLEN longest_length)\n{\n    /* This is the common code for setting up the floating and fixed length\n     * string data extracted from Perl_re_op_compile() below.  Returns a boolean\n     * as to whether succeeded or not */\n\n    I32 t;\n    SSize_t ml;\n    bool eol  = cBOOL(sub->flags & SF_BEFORE_EOL);\n    bool meol = cBOOL(sub->flags & SF_BEFORE_MEOL);\n\n    if (! (longest_length\n           || (eol /* Can't have SEOL and MULTI */\n               && (! meol || (RExC_flags & RXf_PMf_MULTILINE)))\n          )\n            /* See comments for join_exact for why REG_UNFOLDED_MULTI_SEEN */\n        || (RExC_seen & REG_UNFOLDED_MULTI_SEEN))\n    {\n        return FALSE;\n    }\n\n    /* copy the information about the longest from the reg_scan_data\n        over to the program. */\n    if (SvUTF8(sub->str)) {\n        rsd->substr      = NULL;\n        rsd->utf8_substr = sub->str;\n    } else {\n        rsd->substr      = sub->str;\n        rsd->utf8_substr = NULL;\n    }\n    /* end_shift is how many chars that must be matched that\n        follow this item. We calculate it ahead of time as once the\n        lookbehind offset is added in we lose the ability to correctly\n        calculate it.*/\n    ml = sub->minlenp ? *(sub->minlenp) : (SSize_t)longest_length;\n    rsd->end_shift = ml - sub->min_offset\n        - longest_length\n            /* XXX SvTAIL is always false here - did you mean FBMcf_TAIL\n             * intead? - DAPM\n            + (SvTAIL(sub->str) != 0)\n            */\n        + sub->lookbehind;\n\n    t = (eol/* Can't have SEOL and MULTI */\n         && (! meol || (RExC_flags & RXf_PMf_MULTILINE)));\n    fbm_compile(sub->str, t ? FBMcf_TAIL : 0);\n\n    return TRUE;\n}\n\nSTATIC void\nS_set_regex_pv(pTHX_ RExC_state_t *pRExC_state, REGEXP *Rx)\n{\n    /* Calculates and sets in the compiled pattern 'Rx' the string to compile,\n     * properly wrapped with the right modifiers */\n\n    bool has_p     = ((RExC_rx->extflags & RXf_PMf_KEEPCOPY) == RXf_PMf_KEEPCOPY);\n    bool has_charset = RExC_utf8 || (get_regex_charset(RExC_rx->extflags)\n                                                != REGEX_DEPENDS_CHARSET);\n\n    /* The caret is output if there are any defaults: if not all the STD\n        * flags are set, or if no character set specifier is needed */\n    bool has_default =\n                (((RExC_rx->extflags & RXf_PMf_STD_PMMOD) != RXf_PMf_STD_PMMOD)\n                || ! has_charset);\n    bool has_runon = ((RExC_seen & REG_RUN_ON_COMMENT_SEEN)\n                                                == REG_RUN_ON_COMMENT_SEEN);\n    U8 reganch = (U8)((RExC_rx->extflags & RXf_PMf_STD_PMMOD)\n                        >> RXf_PMf_STD_PMMOD_SHIFT);\n    const char *fptr = STD_PAT_MODS;        /*\"msixxn\"*/\n    char *p;\n    STRLEN pat_len = RExC_precomp_end - RExC_precomp;\n\n    /* We output all the necessary flags; we never output a minus, as all\n        * those are defaults, so are\n        * covered by the caret */\n    const STRLEN wraplen = pat_len + has_p + has_runon\n        + has_default       /* If needs a caret */\n        + PL_bitcount[reganch] /* 1 char for each set standard flag */\n\n            /* If needs a character set specifier */\n        + ((has_charset) ? MAX_CHARSET_NAME_LENGTH : 0)\n        + (sizeof(\"(?:)\") - 1);\n\n    PERL_ARGS_ASSERT_SET_REGEX_PV;\n\n    /* make sure PL_bitcount bounds not exceeded */\n    assert(sizeof(STD_PAT_MODS) <= 8);\n\n    p = sv_grow(MUTABLE_SV(Rx), wraplen + 1); /* +1 for the ending NUL */\n    SvPOK_on(Rx);\n    if (RExC_utf8)\n        SvFLAGS(Rx) |= SVf_UTF8;\n    *p++='('; *p++='?';\n\n    /* If a default, cover it using the caret */\n    if (has_default) {\n        *p++= DEFAULT_PAT_MOD;\n    }\n    if (has_charset) {\n        STRLEN len;\n        const char* name;\n\n        name = get_regex_charset_name(RExC_rx->extflags, &len);\n        if strEQ(name, DEPENDS_PAT_MODS) {  /* /d under UTF-8 => /u */\n            assert(RExC_utf8);\n            name = UNICODE_PAT_MODS;\n            len = sizeof(UNICODE_PAT_MODS) - 1;\n        }\n        Copy(name, p, len, char);\n        p += len;\n    }\n    if (has_p)\n        *p++ = KEEPCOPY_PAT_MOD; /*'p'*/\n    {\n        char ch;\n        while((ch = *fptr++)) {\n            if(reganch & 1)\n                *p++ = ch;\n            reganch >>= 1;\n        }\n    }\n\n    *p++ = ':';\n    Copy(RExC_precomp, p, pat_len, char);\n    assert ((RX_WRAPPED(Rx) - p) < 16);\n    RExC_rx->pre_prefix = p - RX_WRAPPED(Rx);\n    p += pat_len;\n\n    /* Adding a trailing \\n causes this to compile properly:\n            my $R = qr / A B C # D E/x; /($R)/\n        Otherwise the parens are considered part of the comment */\n    if (has_runon)\n        *p++ = '\\n';\n    *p++ = ')';\n    *p = 0;\n    SvCUR_set(Rx, p - RX_WRAPPED(Rx));\n}\n\n/*\n * Perl_re_op_compile - the perl internal RE engine's function to compile a\n * regular expression into internal code.\n * The pattern may be passed either as:\n *    a list of SVs (patternp plus pat_count)\n *    a list of OPs (expr)\n * If both are passed, the SV list is used, but the OP list indicates\n * which SVs are actually pre-compiled code blocks\n *\n * The SVs in the list have magic and qr overloading applied to them (and\n * the list may be modified in-place with replacement SVs in the latter\n * case).\n *\n * If the pattern hasn't changed from old_re, then old_re will be\n * returned.\n *\n * eng is the current engine. If that engine has an op_comp method, then\n * handle directly (i.e. we assume that op_comp was us); otherwise, just\n * do the initial concatenation of arguments and pass on to the external\n * engine.\n *\n * If is_bare_re is not null, set it to a boolean indicating whether the\n * arg list reduced (after overloading) to a single bare regex which has\n * been returned (i.e. /$qr/).\n *\n * orig_rx_flags contains RXf_* flags. See perlreapi.pod for more details.\n *\n * pm_flags contains the PMf_* flags, typically based on those from the\n * pm_flags field of the related PMOP. Currently we're only interested in\n * PMf_HAS_CV, PMf_IS_QR, PMf_USE_RE_EVAL.\n *\n * For many years this code had an initial sizing pass that calculated\n * (sometimes incorrectly, leading to security holes) the size needed for the\n * compiled pattern.  That was changed by commit\n * 7c932d07cab18751bfc7515b4320436273a459e2 in 5.29, which reallocs the size, a\n * node at a time, as parsing goes along.  Patches welcome to fix any obsolete\n * references to this sizing pass.\n *\n * Now, an initial crude guess as to the size needed is made, based on the\n * length of the pattern.  Patches welcome to improve that guess.  That amount\n * of space is malloc'd and then immediately freed, and then clawed back node\n * by node.  This design is to minimze, to the extent possible, memory churn\n * when doing the the reallocs.\n *\n * A separate parentheses counting pass may be needed in some cases.\n * (Previously the sizing pass did this.)  Patches welcome to reduce the number\n * of these cases.\n *\n * The existence of a sizing pass necessitated design decisions that are no\n * longer needed.  There are potential areas of simplification.\n *\n * Beware that the optimization-preparation code in here knows about some\n * of the structure of the compiled regexp.  [I'll say.]\n */\n\nREGEXP *\nPerl_re_op_compile(pTHX_ SV ** const patternp, int pat_count,\n\t\t    OP *expr, const regexp_engine* eng, REGEXP *old_re,\n\t\t     bool *is_bare_re, const U32 orig_rx_flags, const U32 pm_flags)\n{\n    dVAR;\n    REGEXP *Rx;         /* Capital 'R' means points to a REGEXP */\n    STRLEN plen;\n    char *exp;\n    regnode *scan;\n    I32 flags;\n    SSize_t minlen = 0;\n    U32 rx_flags;\n    SV *pat;\n    SV** new_patternp = patternp;\n\n    /* these are all flags - maybe they should be turned\n     * into a single int with different bit masks */\n    I32 sawlookahead = 0;\n    I32 sawplus = 0;\n    I32 sawopen = 0;\n    I32 sawminmod = 0;\n\n    regex_charset initial_charset = get_regex_charset(orig_rx_flags);\n    bool recompile = 0;\n    bool runtime_code = 0;\n    scan_data_t data;\n    RExC_state_t RExC_state;\n    RExC_state_t * const pRExC_state = &RExC_state;\n#ifdef TRIE_STUDY_OPT\n    int restudied = 0;\n    RExC_state_t copyRExC_state;\n#endif\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_RE_OP_COMPILE;\n\n    DEBUG_r(if (!PL_colorset) reginitcolors());\n\n    /* Initialize these here instead of as-needed, as is quick and avoids\n     * having to test them each time otherwise */\n    if (! PL_InBitmap) {\n#ifdef DEBUGGING\n        char * dump_len_string;\n#endif\n\n        /* This is calculated here, because the Perl program that generates the\n         * static global ones doesn't currently have access to\n         * NUM_ANYOF_CODE_POINTS */\n\tPL_InBitmap = _new_invlist(2);\n\tPL_InBitmap = _add_range_to_invlist(PL_InBitmap, 0,\n                                                    NUM_ANYOF_CODE_POINTS - 1);\n#ifdef DEBUGGING\n        dump_len_string = PerlEnv_getenv(\"PERL_DUMP_RE_MAX_LEN\");\n        if (   ! dump_len_string\n            || ! grok_atoUV(dump_len_string, (UV *)&PL_dump_re_max_len, NULL))\n        {\n            PL_dump_re_max_len = 60;    /* A reasonable default */\n        }\n#endif\n    }\n\n    pRExC_state->warn_text = NULL;\n    pRExC_state->unlexed_names = NULL;\n    pRExC_state->code_blocks = NULL;\n\n    if (is_bare_re)\n\t*is_bare_re = FALSE;\n\n    if (expr && (expr->op_type == OP_LIST ||\n\t\t(expr->op_type == OP_NULL && expr->op_targ == OP_LIST))) {\n\t/* allocate code_blocks if needed */\n\tOP *o;\n\tint ncode = 0;\n\n\tfor (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o))\n\t    if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL))\n\t\tncode++; /* count of DO blocks */\n\n\tif (ncode)\n            pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_ ncode);\n    }\n\n    if (!pat_count) {\n        /* compile-time pattern with just OP_CONSTs and DO blocks */\n\n        int n;\n        OP *o;\n\n        /* find how many CONSTs there are */\n        assert(expr);\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            n = 1;\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    n++;\n            }\n\n        /* fake up an SV array */\n\n        assert(!new_patternp);\n        Newx(new_patternp, n, SV*);\n        SAVEFREEPV(new_patternp);\n        pat_count = n;\n\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            new_patternp[n] = cSVOPx_sv(expr);\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    new_patternp[n++] = cSVOPo_sv;\n            }\n\n    }\n\n    DEBUG_PARSE_r(Perl_re_printf( aTHX_\n        \"Assembling pattern from %d elements%s\\n\", pat_count,\n            orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n    /* set expr to the first arg op */\n\n    if (pRExC_state->code_blocks && pRExC_state->code_blocks->count\n         && expr->op_type != OP_CONST)\n    {\n            expr = cLISTOPx(expr)->op_first;\n            assert(   expr->op_type == OP_PUSHMARK\n                   || (expr->op_type == OP_NULL && expr->op_targ == OP_PUSHMARK)\n                   || expr->op_type == OP_PADRANGE);\n            expr = OpSIBLING(expr);\n    }\n\n    pat = S_concat_pat(aTHX_ pRExC_state, NULL, new_patternp, pat_count,\n                        expr, &recompile, NULL);\n\n    /* handle bare (possibly after overloading) regex: foo =~ $re */\n    {\n        SV *re = pat;\n        if (SvROK(re))\n            re = SvRV(re);\n        if (SvTYPE(re) == SVt_REGEXP) {\n            if (is_bare_re)\n                *is_bare_re = TRUE;\n            SvREFCNT_inc(re);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_\n                \"Precompiled pattern%s\\n\",\n                    orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n            return (REGEXP*)re;\n        }\n    }\n\n    exp = SvPV_nomg(pat, plen);\n\n    if (!eng->op_comp) {\n\tif ((SvUTF8(pat) && IN_BYTES)\n\t\t|| SvGMAGICAL(pat) || SvAMAGIC(pat))\n\t{\n\t    /* make a temporary copy; either to convert to bytes,\n\t     * or to avoid repeating get-magic / overloaded stringify */\n\t    pat = newSVpvn_flags(exp, plen, SVs_TEMP |\n\t\t\t\t\t(IN_BYTES ? 0 : SvUTF8(pat)));\n\t}\n\treturn CALLREGCOMP_ENG(eng, pat, orig_rx_flags);\n    }\n\n    /* ignore the utf8ness if the pattern is 0 length */\n    RExC_utf8 = RExC_orig_utf8 = (plen == 0 || IN_BYTES) ? 0 : SvUTF8(pat);\n    RExC_uni_semantics = 0;\n    RExC_contains_locale = 0;\n    RExC_strict = cBOOL(pm_flags & RXf_PMf_STRICT);\n    RExC_in_script_run = 0;\n    RExC_study_started = 0;\n    pRExC_state->runtime_code_qr = NULL;\n    RExC_frame_head= NULL;\n    RExC_frame_last= NULL;\n    RExC_frame_count= 0;\n    RExC_latest_warn_offset = 0;\n    RExC_use_BRANCHJ = 0;\n    RExC_total_parens = 0;\n    RExC_open_parens = NULL;\n    RExC_close_parens = NULL;\n    RExC_paren_names = NULL;\n    RExC_size = 0;\n    RExC_seen_d_op = FALSE;\n#ifdef DEBUGGING\n    RExC_paren_name_list = NULL;\n#endif\n\n    DEBUG_r({\n        RExC_mysv1= sv_newmortal();\n        RExC_mysv2= sv_newmortal();\n    });\n\n    DEBUG_COMPILE_r({\n            SV *dsv= sv_newmortal();\n            RE_PV_QUOTED_DECL(s, RExC_utf8, dsv, exp, plen, PL_dump_re_max_len);\n            Perl_re_printf( aTHX_  \"%sCompiling REx%s %s\\n\",\n                          PL_colors[4], PL_colors[5], s);\n        });\n\n    /* we jump here if we have to recompile, e.g., from upgrading the pattern\n     * to utf8 */\n\n    if ((pm_flags & PMf_USE_RE_EVAL)\n\t\t/* this second condition covers the non-regex literal case,\n\t\t * i.e.  $foo =~ '(?{})'. */\n\t\t|| (IN_PERL_COMPILETIME && (PL_hints & HINT_RE_EVAL))\n    )\n\truntime_code = S_has_runtime_code(aTHX_ pRExC_state, exp, plen);\n\n  redo_parse:\n    /* return old regex if pattern hasn't changed */\n    /* XXX: note in the below we have to check the flags as well as the\n     * pattern.\n     *\n     * Things get a touch tricky as we have to compare the utf8 flag\n     * independently from the compile flags.  */\n\n    if (   old_re\n        && !recompile\n        && !!RX_UTF8(old_re) == !!RExC_utf8\n        && ( RX_COMPFLAGS(old_re) == ( orig_rx_flags & RXf_PMf_FLAGCOPYMASK ) )\n\t&& RX_PRECOMP(old_re)\n\t&& RX_PRELEN(old_re) == plen\n        && memEQ(RX_PRECOMP(old_re), exp, plen)\n\t&& !runtime_code /* with runtime code, always recompile */ )\n    {\n        return old_re;\n    }\n\n    /* Allocate the pattern's SV */\n    RExC_rx_sv = Rx = (REGEXP*) newSV_type(SVt_REGEXP);\n    RExC_rx = ReANY(Rx);\n    if ( RExC_rx == NULL )\n        FAIL(\"Regexp out of space\");\n\n    rx_flags = orig_rx_flags;\n\n    if (   (UTF || RExC_uni_semantics)\n        && initial_charset == REGEX_DEPENDS_CHARSET)\n    {\n\n\t/* Set to use unicode semantics if the pattern is in utf8 and has the\n\t * 'depends' charset specified, as it means unicode when utf8  */\n\tset_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);\n        RExC_uni_semantics = 1;\n    }\n\n    RExC_pm_flags = pm_flags;\n\n    if (runtime_code) {\n        assert(TAINTING_get || !TAINT_get);\n\tif (TAINT_get)\n\t    Perl_croak(aTHX_ \"Eval-group in insecure regular expression\");\n\n\tif (!S_compile_runtime_code(aTHX_ pRExC_state, exp, plen)) {\n\t    /* whoops, we have a non-utf8 pattern, whilst run-time code\n\t     * got compiled as utf8. Try again with a utf8 pattern */\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n                pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            goto redo_parse;\n\t}\n    }\n    assert(!pRExC_state->runtime_code_qr);\n\n    RExC_sawback = 0;\n\n    RExC_seen = 0;\n    RExC_maxlen = 0;\n    RExC_in_lookbehind = 0;\n    RExC_seen_zerolen = *exp == '^' ? -1 : 0;\n#ifdef EBCDIC\n    RExC_recode_x_to_native = 0;\n#endif\n    RExC_in_multi_char_class = 0;\n\n    RExC_start = RExC_copy_start_in_constructed = RExC_copy_start_in_input = RExC_precomp = exp;\n    RExC_precomp_end = RExC_end = exp + plen;\n    RExC_nestroot = 0;\n    RExC_whilem_seen = 0;\n    RExC_end_op = NULL;\n    RExC_recurse = NULL;\n    RExC_study_chunk_recursed = NULL;\n    RExC_study_chunk_recursed_bytes= 0;\n    RExC_recurse_count = 0;\n    pRExC_state->code_index = 0;\n\n    /* Initialize the string in the compiled pattern.  This is so that there is\n     * something to output if necessary */\n    set_regex_pv(pRExC_state, Rx);\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Starting parse and generation\\n\");\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n    /* Allocate space and zero-initialize. Note, the two step process\n       of zeroing when in debug mode, thus anything assigned has to\n       happen after that */\n    if (!  RExC_size) {\n\n        /* On the first pass of the parse, we guess how big this will be.  Then\n         * we grow in one operation to that amount and then give it back.  As\n         * we go along, we re-allocate what we need.\n         *\n         * XXX Currently the guess is essentially that the pattern will be an\n         * EXACT node with one byte input, one byte output.  This is crude, and\n         * better heuristics are welcome.\n         *\n         * On any subsequent passes, we guess what we actually computed in the\n         * latest earlier pass.  Such a pass probably didn't complete so is\n         * missing stuff.  We could improve those guesses by knowing where the\n         * parse stopped, and use the length so far plus apply the above\n         * assumption to what's left. */\n        RExC_size = STR_SZ(RExC_end - RExC_start);\n    }\n\n    Newxc(RExC_rxi, sizeof(regexp_internal) + RExC_size, char, regexp_internal);\n    if ( RExC_rxi == NULL )\n        FAIL(\"Regexp out of space\");\n\n    Zero(RExC_rxi, sizeof(regexp_internal) + RExC_size, char);\n    RXi_SET( RExC_rx, RExC_rxi );\n\n    /* We start from 0 (over from 0 in the case this is a reparse.  The first\n     * node parsed will give back any excess memory we have allocated so far).\n     * */\n    RExC_size = 0;\n\n    /* non-zero initialization begins here */\n    RExC_rx->engine= eng;\n    RExC_rx->extflags = rx_flags;\n    RXp_COMPFLAGS(RExC_rx) = orig_rx_flags & RXf_PMf_FLAGCOPYMASK;\n\n    if (pm_flags & PMf_IS_QR) {\n\tRExC_rxi->code_blocks = pRExC_state->code_blocks;\n        if (RExC_rxi->code_blocks) {\n            RExC_rxi->code_blocks->refcnt++;\n        }\n    }\n\n    RExC_rx->intflags = 0;\n\n    RExC_flags = rx_flags;\t/* don't let top level (?i) bleed */\n    RExC_parse = exp;\n\n    /* This NUL is guaranteed because the pattern comes from an SV*, and the sv\n     * code makes sure the final byte is an uncounted NUL.  But should this\n     * ever not be the case, lots of things could read beyond the end of the\n     * buffer: loops like\n     *      while(isFOO(*RExC_parse)) RExC_parse++;\n     *      strchr(RExC_parse, \"foo\");\n     * etc.  So it is worth noting. */\n    assert(*RExC_end == '\\0');\n\n    RExC_naughty = 0;\n    RExC_npar = 1;\n    RExC_parens_buf_size = 0;\n    RExC_emit_start = RExC_rxi->program;\n    pRExC_state->code_index = 0;\n\n    *((char*) RExC_emit_start) = (char) REG_MAGIC;\n    RExC_emit = 1;\n\n    /* Do the parse */\n    if (reg(pRExC_state, 0, &flags, 1)) {\n\n        /* Success!, But we may need to redo the parse knowing how many parens\n         * there actually are */\n        if (IN_PARENS_PASS) {\n            flags |= RESTART_PARSE;\n        }\n\n        /* We have that number in RExC_npar */\n        RExC_total_parens = RExC_npar;\n\n        /* XXX For backporting, use long jumps if there is any possibility of\n         * overflow */\n        if (RExC_size > U16_MAX && ! RExC_use_BRANCHJ) {\n            RExC_use_BRANCHJ = TRUE;\n            flags |= RESTART_PARSE;\n        }\n    }\n    else if (! MUST_RESTART(flags)) {\n\tReREFCNT_dec(Rx);\n        Perl_croak(aTHX_ \"panic: reg returned failure to re_op_compile, flags=%#\" UVxf, (UV) flags);\n    }\n\n    /* Here, we either have success, or we have to redo the parse for some reason */\n    if (MUST_RESTART(flags)) {\n\n        /* It's possible to write a regexp in ascii that represents Unicode\n        codepoints outside of the byte range, such as via \\x{100}. If we\n        detect such a sequence we have to convert the entire pattern to utf8\n        and then recompile, as our sizing calculation will have been based\n        on 1 byte == 1 character, but we will need to use utf8 to encode\n        at least some part of the pattern, and therefore must convert the whole\n        thing.\n        -- dmq */\n        if (flags & NEED_UTF8) {\n\n            /* We have stored the offset of the final warning output so far.\n             * That must be adjusted.  Any variant characters between the start\n             * of the pattern and this warning count for 2 bytes in the final,\n             * so just add them again */\n            if (UNLIKELY(RExC_latest_warn_offset > 0)) {\n                RExC_latest_warn_offset +=\n                            variant_under_utf8_count((U8 *) exp, (U8 *) exp\n                                                + RExC_latest_warn_offset);\n            }\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n            pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse after upgrade\\n\"));\n        }\n        else {\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse\\n\"));\n        }\n\n        if (ALL_PARENS_COUNTED) {\n            /* Make enough room for all the known parens, and zero it */\n            Renew(RExC_open_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_open_parens, RExC_total_parens, regnode_offset);\n            RExC_open_parens[0] = 1;    /* +1 for REG_MAGIC */\n\n            Renew(RExC_close_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_close_parens, RExC_total_parens, regnode_offset);\n        }\n        else { /* Parse did not complete.  Reinitialize the parentheses\n                  structures */\n            RExC_total_parens = 0;\n            if (RExC_open_parens) {\n                Safefree(RExC_open_parens);\n                RExC_open_parens = NULL;\n            }\n            if (RExC_close_parens) {\n                Safefree(RExC_close_parens);\n                RExC_close_parens = NULL;\n            }\n        }\n\n        /* Clean up what we did in this parse */\n        SvREFCNT_dec_NN(RExC_rx_sv);\n\n        goto redo_parse;\n    }\n\n    /* Here, we have successfully parsed and generated the pattern's program\n     * for the regex engine.  We are ready to finish things up and look for\n     * optimizations. */\n\n    /* Update the string to compile, with correct modifiers, etc */\n    set_regex_pv(pRExC_state, Rx);\n\n    RExC_rx->nparens = RExC_total_parens - 1;\n\n    /* Uses the upper 4 bits of the FLAGS field, so keep within that size */\n    if (RExC_whilem_seen > 15)\n        RExC_whilem_seen = 15;\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Required size %\" IVdf \" nodes\\n\", (IV)RExC_size);\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    DEBUG_OFFSETS_r(Perl_re_printf( aTHX_\n                          \"%s %\" UVuf \" bytes for offset annotations.\\n\",\n                          RExC_offsets ? \"Got\" : \"Couldn't get\",\n                          (UV)((RExC_offsets[0] * 2 + 1))));\n    DEBUG_OFFSETS_r(if (RExC_offsets) {\n        const STRLEN len = RExC_offsets[0];\n        STRLEN i;\n        GET_RE_DEBUG_FLAGS_DECL;\n        Perl_re_printf( aTHX_\n                      \"Offsets: [%\" UVuf \"]\\n\\t\", (UV)RExC_offsets[0]);\n        for (i = 1; i <= len; i++) {\n            if (RExC_offsets[i*2-1] || RExC_offsets[i*2])\n                Perl_re_printf( aTHX_  \"%\" UVuf \":%\" UVuf \"[%\" UVuf \"] \",\n                (UV)i, (UV)RExC_offsets[i*2-1], (UV)RExC_offsets[i*2]);\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    });\n\n#else\n    SetProgLen(RExC_rxi,RExC_size);\n#endif\n\n    DEBUG_OPTIMISE_r(\n        Perl_re_printf( aTHX_  \"Starting post parse optimization\\n\");\n    );\n\n    /* XXXX To minimize changes to RE engine we always allocate\n       3-units-long substrs field. */\n    Newx(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_recurse_count) {\n        Newx(RExC_recurse, RExC_recurse_count, regnode *);\n        SAVEFREEPV(RExC_recurse);\n    }\n\n    if (RExC_seen & REG_RECURSE_SEEN) {\n        /* Note, RExC_total_parens is 1 + the number of parens in a pattern.\n         * So its 1 if there are no parens. */\n        RExC_study_chunk_recursed_bytes= (RExC_total_parens >> 3) +\n                                         ((RExC_total_parens & 0x07) != 0);\n        Newx(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n        SAVEFREEPV(RExC_study_chunk_recursed);\n    }\n\n  reStudy:\n    RExC_rx->minlen = minlen = sawlookahead = sawplus = sawopen = sawminmod = 0;\n    DEBUG_r(\n        RExC_study_chunk_recursed_count= 0;\n    );\n    Zero(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_study_chunk_recursed) {\n        Zero(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n    }\n\n\n#ifdef TRIE_STUDY_OPT\n    if (!restudied) {\n        StructCopy(&zero_scan_data, &data, scan_data_t);\n        copyRExC_state = RExC_state;\n    } else {\n        U32 seen=RExC_seen;\n        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"Restudying\\n\"));\n\n        RExC_state = copyRExC_state;\n        if (seen & REG_TOP_LEVEL_BRANCHES_SEEN)\n            RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;\n        else\n            RExC_seen &= ~REG_TOP_LEVEL_BRANCHES_SEEN;\n\tStructCopy(&zero_scan_data, &data, scan_data_t);\n    }\n#else\n    StructCopy(&zero_scan_data, &data, scan_data_t);\n#endif\n\n    /* Dig out information for optimizations. */\n    RExC_rx->extflags = RExC_flags; /* was pm_op */\n    /*dmq: removed as part of de-PMOP: pm->op_pmflags = RExC_flags; */\n\n    if (UTF)\n\tSvUTF8_on(Rx);\t/* Unicode in it? */\n    RExC_rxi->regstclass = NULL;\n    if (RExC_naughty >= TOO_NAUGHTY)\t/* Probably an expensive pattern. */\n\tRExC_rx->intflags |= PREGf_NAUGHTY;\n    scan = RExC_rxi->program + 1;\t\t/* First BRANCH. */\n\n    /* testing for BRANCH here tells us whether there is \"must appear\"\n       data in the pattern. If there is then we can use it for optimisations */\n    if (!(RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)) { /*  Only one top-level choice.\n                                                  */\n\tSSize_t fake;\n\tSTRLEN longest_length[2];\n\tregnode_ssc ch_class; /* pointed to by data */\n\tint stclass_flag;\n\tSSize_t last_close = 0; /* pointed to by data */\n        regnode *first= scan;\n        regnode *first_next= regnext(first);\n        int i;\n\n\t/*\n\t * Skip introductions and multiplicators >= 1\n\t * so that we can extract the 'meat' of the pattern that must\n\t * match in the large if() sequence following.\n\t * NOTE that EXACT is NOT covered here, as it is normally\n\t * picked up by the optimiser separately.\n\t *\n\t * This is unfortunate as the optimiser isnt handling lookahead\n\t * properly currently.\n\t *\n\t */\n\twhile ((OP(first) == OPEN && (sawopen = 1)) ||\n\t       /* An OR of *one* alternative - should not happen now. */\n\t    (OP(first) == BRANCH && OP(first_next) != BRANCH) ||\n\t    /* for now we can't handle lookbehind IFMATCH*/\n\t    (OP(first) == IFMATCH && !first->flags && (sawlookahead = 1)) ||\n\t    (OP(first) == PLUS) ||\n\t    (OP(first) == MINMOD) ||\n\t       /* An {n,m} with n>0 */\n\t    (PL_regkind[OP(first)] == CURLY && ARG1(first) > 0) ||\n\t    (OP(first) == NOTHING && PL_regkind[OP(first_next)] != END ))\n\t{\n\t\t/*\n\t\t * the only op that could be a regnode is PLUS, all the rest\n\t\t * will be regnode_1 or regnode_2.\n\t\t *\n                 * (yves doesn't think this is true)\n\t\t */\n\t\tif (OP(first) == PLUS)\n\t\t    sawplus = 1;\n                else {\n                    if (OP(first) == MINMOD)\n                        sawminmod = 1;\n\t\t    first += regarglen[OP(first)];\n                }\n\t\tfirst = NEXTOPER(first);\n\t\tfirst_next= regnext(first);\n\t}\n\n\t/* Starting-point info. */\n      again:\n        DEBUG_PEEP(\"first:\", first, 0, 0);\n        /* Ignore EXACT as we deal with it later. */\n\tif (PL_regkind[OP(first)] == EXACT) {\n\t    if (   OP(first) == EXACT\n                || OP(first) == EXACT_ONLY8\n                || OP(first) == EXACTL)\n            {\n\t\tNOOP;\t/* Empty, get anchored substr later. */\n            }\n\t    else\n\t\tRExC_rxi->regstclass = first;\n\t}\n#ifdef TRIE_STCLASS\n\telse if (PL_regkind[OP(first)] == TRIE &&\n\t        ((reg_trie_data *)RExC_rxi->data->data[ ARG(first) ])->minlen>0)\n\t{\n            /* this can happen only on restudy */\n            RExC_rxi->regstclass = construct_ahocorasick_from_trie(pRExC_state, (regnode *)first, 0);\n\t}\n#endif\n\telse if (REGNODE_SIMPLE(OP(first)))\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOUND ||\n\t\t PL_regkind[OP(first)] == NBOUND)\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOL) {\n            RExC_rx->intflags |= (OP(first) == MBOL\n                           ? PREGf_ANCH_MBOL\n                           : PREGf_ANCH_SBOL);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if (OP(first) == GPOS) {\n            RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if ((!sawopen || !RExC_sawback) &&\n            !sawlookahead &&\n\t    (OP(first) == STAR &&\n\t    PL_regkind[OP(NEXTOPER(first))] == REG_ANY) &&\n            !(RExC_rx->intflags & PREGf_ANCH) && !pRExC_state->code_blocks)\n\t{\n\t    /* turn .* into ^.* with an implied $*=1 */\n\t    const int type =\n\t\t(OP(NEXTOPER(first)) == REG_ANY)\n                    ? PREGf_ANCH_MBOL\n                    : PREGf_ANCH_SBOL;\n            RExC_rx->intflags |= (type | PREGf_IMPLICIT);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n        if (sawplus && !sawminmod && !sawlookahead\n            && (!sawopen || !RExC_sawback)\n\t    && !pRExC_state->code_blocks) /* May examine pos and $& */\n\t    /* x+ must match at the 1st pos of run of x's */\n\t    RExC_rx->intflags |= PREGf_SKIP;\n\n\t/* Scan is after the zeroth branch, first is atomic matcher. */\n#ifdef TRIE_STUDY_OPT\n\tDEBUG_PARSE_r(\n\t    if (!restudied)\n                Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t\t\t      (IV)(first - scan + 1))\n        );\n#else\n\tDEBUG_PARSE_r(\n            Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t        (IV)(first - scan + 1))\n        );\n#endif\n\n\n\t/*\n\t* If there's something expensive in the r.e., find the\n\t* longest literal string that must appear and make it the\n\t* regmust.  Resolve ties in favor of later strings, since\n\t* the regstart check works with the beginning of the r.e.\n\t* and avoiding duplication strengthens checking.  Not a\n\t* strong reason, but sufficient in the absence of others.\n\t* [Now we resolve ties in favor of the earlier string if\n\t* it happens that c_offset_min has been invalidated, since the\n\t* earlier string may buy us something the later one won't.]\n\t*/\n\n\tdata.substrs[0].str = newSVpvs(\"\");\n\tdata.substrs[1].str = newSVpvs(\"\");\n\tdata.last_found = newSVpvs(\"\");\n\tdata.cur_is_floating = 0; /* initially any found substring is fixed */\n\tENTER_with_name(\"study_chunk\");\n\tSAVEFREESV(data.substrs[0].str);\n\tSAVEFREESV(data.substrs[1].str);\n\tSAVEFREESV(data.last_found);\n\tfirst = scan;\n\tif (!RExC_rxi->regstclass) {\n\t    ssc_init(pRExC_state, &ch_class);\n\t    data.start_class = &ch_class;\n\t    stclass_flag = SCF_DO_STCLASS_AND;\n\t} else\t\t\t\t/* XXXX Check for BOUND? */\n\t    stclass_flag = 0;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/PATTERN/\n         * (NO top level branches)\n         */\n\tminlen = study_chunk(pRExC_state, &first, &minlen, &fake,\n                             scan + RExC_size, /* Up to end */\n            &data, -1, 0, NULL,\n            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag\n                          | (restudied ? SCF_TRIE_DOING_RESTUDY : 0),\n            0, TRUE);\n\n\n        CHECK_RESTUDY_GOTO_butfirst(LEAVE_with_name(\"study_chunk\"));\n\n\n\tif ( RExC_total_parens == 1 && !data.cur_is_floating\n\t     && data.last_start_min == 0 && data.last_end > 0\n\t     && !RExC_seen_zerolen\n             && !(RExC_seen & REG_VERBARG_SEEN)\n             && !(RExC_seen & REG_GPOS_SEEN)\n        ){\n\t    RExC_rx->extflags |= RXf_CHECK_ALL;\n        }\n\tscan_commit(pRExC_state, &data,&minlen, 0);\n\n\n        /* XXX this is done in reverse order because that's the way the\n         * code was before it was parameterised. Don't know whether it\n         * actually needs doing in reverse order. DAPM */\n        for (i = 1; i >= 0; i--) {\n            longest_length[i] = CHR_SVLEN(data.substrs[i].str);\n\n            if (   !(   i\n                     && SvCUR(data.substrs[0].str)  /* ok to leave SvCUR */\n                     &&    data.substrs[0].min_offset\n                        == data.substrs[1].min_offset\n                     &&    SvCUR(data.substrs[0].str)\n                        == SvCUR(data.substrs[1].str)\n                    )\n                && S_setup_longest (aTHX_ pRExC_state,\n                                        &(RExC_rx->substrs->data[i]),\n                                        &(data.substrs[i]),\n                                        longest_length[i]))\n            {\n                RExC_rx->substrs->data[i].min_offset =\n                        data.substrs[i].min_offset - data.substrs[i].lookbehind;\n\n                RExC_rx->substrs->data[i].max_offset = data.substrs[i].max_offset;\n                /* Don't offset infinity */\n                if (data.substrs[i].max_offset < SSize_t_MAX)\n                    RExC_rx->substrs->data[i].max_offset -= data.substrs[i].lookbehind;\n                SvREFCNT_inc_simple_void_NN(data.substrs[i].str);\n            }\n            else {\n                RExC_rx->substrs->data[i].substr      = NULL;\n                RExC_rx->substrs->data[i].utf8_substr = NULL;\n                longest_length[i] = 0;\n            }\n        }\n\n\tLEAVE_with_name(\"study_chunk\");\n\n\tif (RExC_rxi->regstclass\n\t    && (OP(RExC_rxi->regstclass) == REG_ANY || OP(RExC_rxi->regstclass) == SANY))\n\t    RExC_rxi->regstclass = NULL;\n\n\tif ((!(RExC_rx->substrs->data[0].substr || RExC_rx->substrs->data[0].utf8_substr)\n              || RExC_rx->substrs->data[0].min_offset)\n\t    && stclass_flag\n            && ! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n\t{\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV *sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n\n        /* A temporary algorithm prefers floated substr to fixed one of\n         * same length to dig more info. */\n\ti = (longest_length[0] <= longest_length[1]);\n        RExC_rx->substrs->check_ix = i;\n        RExC_rx->check_end_shift  = RExC_rx->substrs->data[i].end_shift;\n        RExC_rx->check_substr     = RExC_rx->substrs->data[i].substr;\n        RExC_rx->check_utf8       = RExC_rx->substrs->data[i].utf8_substr;\n        RExC_rx->check_offset_min = RExC_rx->substrs->data[i].min_offset;\n        RExC_rx->check_offset_max = RExC_rx->substrs->data[i].max_offset;\n        if (!i && (RExC_rx->intflags & (PREGf_ANCH_SBOL|PREGf_ANCH_GPOS)))\n            RExC_rx->intflags |= PREGf_NOSCAN;\n\n\tif ((RExC_rx->check_substr || RExC_rx->check_utf8) ) {\n\t    RExC_rx->extflags |= RXf_USE_INTUIT;\n\t    if (SvTAIL(RExC_rx->check_substr ? RExC_rx->check_substr : RExC_rx->check_utf8))\n\t\tRExC_rx->extflags |= RXf_INTUIT_TAIL;\n\t}\n\n\t/* XXX Unneeded? dmq (shouldn't as this is handled elsewhere)\n\tif ( (STRLEN)minlen < longest_length[1] )\n            minlen= longest_length[1];\n        if ( (STRLEN)minlen < longest_length[0] )\n            minlen= longest_length[0];\n        */\n    }\n    else {\n\t/* Several toplevels. Best we can is to set minlen. */\n\tSSize_t fake;\n\tregnode_ssc ch_class;\n\tSSize_t last_close = 0;\n\n        DEBUG_PARSE_r(Perl_re_printf( aTHX_  \"\\nMulti Top Level\\n\"));\n\n\tscan = RExC_rxi->program + 1;\n\tssc_init(pRExC_state, &ch_class);\n\tdata.start_class = &ch_class;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/P1|P2|.../\n         * (patterns WITH top level branches)\n         */\n\tminlen = study_chunk(pRExC_state,\n            &scan, &minlen, &fake, scan + RExC_size, &data, -1, 0, NULL,\n            SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS|(restudied\n                                                      ? SCF_TRIE_DOING_RESTUDY\n                                                      : 0),\n            0, TRUE);\n\n        CHECK_RESTUDY_GOTO_butfirst(NOOP);\n\n\tRExC_rx->check_substr = NULL;\n        RExC_rx->check_utf8 = NULL;\n        RExC_rx->substrs->data[0].substr      = NULL;\n        RExC_rx->substrs->data[0].utf8_substr = NULL;\n        RExC_rx->substrs->data[1].substr      = NULL;\n        RExC_rx->substrs->data[1].utf8_substr = NULL;\n\n        if (! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n        {\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV* sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n    }\n\n    if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN) {\n        RExC_rx->extflags |= RXf_UNBOUNDED_QUANTIFIER_SEEN;\n        RExC_rx->maxlen = REG_INFTY;\n    }\n    else {\n        RExC_rx->maxlen = RExC_maxlen;\n    }\n\n    /* Guard against an embedded (?=) or (?<=) with a longer minlen than\n       the \"real\" pattern. */\n    DEBUG_OPTIMISE_r({\n        Perl_re_printf( aTHX_ \"minlen: %\" IVdf \" RExC_rx->minlen:%\" IVdf \" maxlen:%\" IVdf \"\\n\",\n                      (IV)minlen, (IV)RExC_rx->minlen, (IV)RExC_maxlen);\n    });\n    RExC_rx->minlenret = minlen;\n    if (RExC_rx->minlen < minlen)\n        RExC_rx->minlen = minlen;\n\n    if (RExC_seen & REG_RECURSE_SEEN ) {\n        RExC_rx->intflags |= PREGf_RECURSE_SEEN;\n        Newx(RExC_rx->recurse_locinput, RExC_rx->nparens + 1, char *);\n    }\n    if (RExC_seen & REG_GPOS_SEEN)\n        RExC_rx->intflags |= PREGf_GPOS_SEEN;\n    if (RExC_seen & REG_LOOKBEHIND_SEEN)\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* inplace might break the\n                                                lookbehind */\n    if (pRExC_state->code_blocks)\n\tRExC_rx->extflags |= RXf_EVAL_SEEN;\n    if (RExC_seen & REG_VERBARG_SEEN)\n    {\n\tRExC_rx->intflags |= PREGf_VERBARG_SEEN;\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* don't understand this! Yves */\n    }\n    if (RExC_seen & REG_CUTGROUP_SEEN)\n\tRExC_rx->intflags |= PREGf_CUTGROUP_SEEN;\n    if (pm_flags & PMf_USE_RE_EVAL)\n\tRExC_rx->intflags |= PREGf_USE_RE_EVAL;\n    if (RExC_paren_names)\n        RXp_PAREN_NAMES(RExC_rx) = MUTABLE_HV(SvREFCNT_inc(RExC_paren_names));\n    else\n        RXp_PAREN_NAMES(RExC_rx) = NULL;\n\n    /* If we have seen an anchor in our pattern then we set the extflag RXf_IS_ANCHORED\n     * so it can be used in pp.c */\n    if (RExC_rx->intflags & PREGf_ANCH)\n        RExC_rx->extflags |= RXf_IS_ANCHORED;\n\n\n    {\n        /* this is used to identify \"special\" patterns that might result\n         * in Perl NOT calling the regex engine and instead doing the match \"itself\",\n         * particularly special cases in split//. By having the regex compiler\n         * do this pattern matching at a regop level (instead of by inspecting the pattern)\n         * we avoid weird issues with equivalent patterns resulting in different behavior,\n         * AND we allow non Perl engines to get the same optimizations by the setting the\n         * flags appropriately - Yves */\n        regnode *first = RExC_rxi->program + 1;\n        U8 fop = OP(first);\n        regnode *next = regnext(first);\n        U8 nop = OP(next);\n\n        if (PL_regkind[fop] == NOTHING && nop == END)\n            RExC_rx->extflags |= RXf_NULL;\n        else if ((fop == MBOL || (fop == SBOL && !first->flags)) && nop == END)\n            /* when fop is SBOL first->flags will be true only when it was\n             * produced by parsing /\\A/, and not when parsing /^/. This is\n             * very important for the split code as there we want to\n             * treat /^/ as /^/m, but we do not want to treat /\\A/ as /^/m.\n             * See rt #122761 for more details. -- Yves */\n            RExC_rx->extflags |= RXf_START_ONLY;\n        else if (fop == PLUS\n                 && PL_regkind[nop] == POSIXD && FLAGS(next) == _CC_SPACE\n                 && nop == END)\n            RExC_rx->extflags |= RXf_WHITE;\n        else if ( RExC_rx->extflags & RXf_SPLIT\n                  && (fop == EXACT || fop == EXACT_ONLY8 || fop == EXACTL)\n                  && STR_LEN(first) == 1\n                  && *(STRING(first)) == ' '\n                  && nop == END )\n            RExC_rx->extflags |= (RXf_SKIPWHITE|RXf_WHITE);\n\n    }\n\n    if (RExC_contains_locale) {\n        RXp_EXTFLAGS(RExC_rx) |= RXf_TAINTED;\n    }\n\n#ifdef DEBUGGING\n    if (RExC_paren_names) {\n        RExC_rxi->name_list_idx = add_data( pRExC_state, STR_WITH_LEN(\"a\"));\n        RExC_rxi->data->data[RExC_rxi->name_list_idx]\n                                   = (void*)SvREFCNT_inc(RExC_paren_name_list);\n    } else\n#endif\n    RExC_rxi->name_list_idx = 0;\n\n    while ( RExC_recurse_count > 0 ) {\n        const regnode *scan = RExC_recurse[ --RExC_recurse_count ];\n        /*\n         * This data structure is set up in study_chunk() and is used\n         * to calculate the distance between a GOSUB regopcode and\n         * the OPEN/CURLYM (CURLYM's are special and can act like OPEN's)\n         * it refers to.\n         *\n         * If for some reason someone writes code that optimises\n         * away a GOSUB opcode then the assert should be changed to\n         * an if(scan) to guard the ARG2L_SET() - Yves\n         *\n         */\n        assert(scan && OP(scan) == GOSUB);\n        ARG2L_SET( scan, RExC_open_parens[ARG(scan)] - REGNODE_OFFSET(scan));\n    }\n\n    Newxz(RExC_rx->offs, RExC_total_parens, regexp_paren_pair);\n    /* assume we don't need to swap parens around before we match */\n    DEBUG_TEST_r({\n        Perl_re_printf( aTHX_ \"study_chunk_recursed_count: %lu\\n\",\n            (unsigned long)RExC_study_chunk_recursed_count);\n    });\n    DEBUG_DUMP_r({\n        DEBUG_RExC_seen();\n        Perl_re_printf( aTHX_ \"Final program:\\n\");\n        regdump(RExC_rx);\n    });\n\n    if (RExC_open_parens) {\n        Safefree(RExC_open_parens);\n        RExC_open_parens = NULL;\n    }\n    if (RExC_close_parens) {\n        Safefree(RExC_close_parens);\n        RExC_close_parens = NULL;\n    }\n\n#ifdef USE_ITHREADS\n    /* under ithreads the ?pat? PMf_USED flag on the pmop is simulated\n     * by setting the regexp SV to readonly-only instead. If the\n     * pattern's been recompiled, the USEDness should remain. */\n    if (old_re && SvREADONLY(old_re))\n        SvREADONLY_on(Rx);\n#endif\n    return Rx;\n}\n\n\nSV*\nPerl_reg_named_buff(pTHX_ REGEXP * const rx, SV * const key, SV * const value,\n                    const U32 flags)\n{\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF;\n\n    PERL_UNUSED_ARG(value);\n\n    if (flags & RXapif_FETCH) {\n        return reg_named_buff_fetch(rx, key, flags);\n    } else if (flags & (RXapif_STORE | RXapif_DELETE | RXapif_CLEAR)) {\n        Perl_croak_no_modify();\n        return NULL;\n    } else if (flags & RXapif_EXISTS) {\n        return reg_named_buff_exists(rx, key, flags)\n            ? &PL_sv_yes\n            : &PL_sv_no;\n    } else if (flags & RXapif_REGNAMES) {\n        return reg_named_buff_all(rx, flags);\n    } else if (flags & (RXapif_SCALAR | RXapif_REGNAMES_COUNT)) {\n        return reg_named_buff_scalar(rx, flags);\n    } else {\n        Perl_croak(aTHX_ \"panic: Unknown flags %d in named_buff\", (int)flags);\n        return NULL;\n    }\n}\n\nSV*\nPerl_reg_named_buff_iter(pTHX_ REGEXP * const rx, const SV * const lastkey,\n                         const U32 flags)\n{\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_ITER;\n    PERL_UNUSED_ARG(lastkey);\n\n    if (flags & RXapif_FIRSTKEY)\n        return reg_named_buff_firstkey(rx, flags);\n    else if (flags & RXapif_NEXTKEY)\n        return reg_named_buff_nextkey(rx, flags);\n    else {\n        Perl_croak(aTHX_ \"panic: Unknown flags %d in named_buff_iter\",\n                                            (int)flags);\n        return NULL;\n    }\n}\n\nSV*\nPerl_reg_named_buff_fetch(pTHX_ REGEXP * const r, SV * const namesv,\n\t\t\t  const U32 flags)\n{\n    SV *ret;\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_FETCH;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HE *he_str = hv_fetch_ent( RXp_PAREN_NAMES(rx), namesv, 0, 0 );\n        if (he_str) {\n            IV i;\n            SV* sv_dat=HeVAL(he_str);\n            I32 *nums=(I32*)SvPVX(sv_dat);\n            AV * const retarray = (flags & RXapif_ALL) ? newAV() : NULL;\n            for ( i=0; i<SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->nparens) >= nums[i]\n                    && rx->offs[nums[i]].start != -1\n                    && rx->offs[nums[i]].end != -1)\n                {\n                    ret = newSVpvs(\"\");\n                    CALLREG_NUMBUF_FETCH(r, nums[i], ret);\n                    if (!retarray)\n                        return ret;\n                } else {\n                    if (retarray)\n                        ret = newSVsv(&PL_sv_undef);\n                }\n                if (retarray)\n                    av_push(retarray, ret);\n            }\n            if (retarray)\n                return newRV_noinc(MUTABLE_SV(retarray));\n        }\n    }\n    return NULL;\n}\n\nbool\nPerl_reg_named_buff_exists(pTHX_ REGEXP * const r, SV * const key,\n                           const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_EXISTS;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        if (flags & RXapif_ALL) {\n            return hv_exists_ent(RXp_PAREN_NAMES(rx), key, 0);\n        } else {\n\t    SV *sv = CALLREG_NAMED_BUFF_FETCH(r, key, flags);\n            if (sv) {\n\t\tSvREFCNT_dec_NN(sv);\n                return TRUE;\n            } else {\n                return FALSE;\n            }\n        }\n    } else {\n        return FALSE;\n    }\n}\n\nSV*\nPerl_reg_named_buff_firstkey(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_FIRSTKEY;\n\n    if ( rx && RXp_PAREN_NAMES(rx) ) {\n\t(void)hv_iterinit(RXp_PAREN_NAMES(rx));\n\n\treturn CALLREG_NAMED_BUFF_NEXTKEY(r, NULL, flags & ~RXapif_FIRSTKEY);\n    } else {\n\treturn FALSE;\n    }\n}\n\nSV*\nPerl_reg_named_buff_nextkey(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_NEXTKEY;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HV *hv = RXp_PAREN_NAMES(rx);\n        HE *temphe;\n        while ( (temphe = hv_iternext_flags(hv, 0)) ) {\n            IV i;\n            IV parno = 0;\n            SV* sv_dat = HeVAL(temphe);\n            I32 *nums = (I32*)SvPVX(sv_dat);\n            for ( i = 0; i < SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->lastparen) >= nums[i] &&\n                    rx->offs[nums[i]].start != -1 &&\n                    rx->offs[nums[i]].end != -1)\n                {\n                    parno = nums[i];\n                    break;\n                }\n            }\n            if (parno || flags & RXapif_ALL) {\n\t\treturn newSVhek(HeKEY_hek(temphe));\n            }\n        }\n    }\n    return NULL;\n}\n\nSV*\nPerl_reg_named_buff_scalar(pTHX_ REGEXP * const r, const U32 flags)\n{\n    SV *ret;\n    AV *av;\n    SSize_t length;\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_SCALAR;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        if (flags & (RXapif_ALL | RXapif_REGNAMES_COUNT)) {\n            return newSViv(HvTOTALKEYS(RXp_PAREN_NAMES(rx)));\n        } else if (flags & RXapif_ONE) {\n            ret = CALLREG_NAMED_BUFF_ALL(r, (flags | RXapif_REGNAMES));\n            av = MUTABLE_AV(SvRV(ret));\n            length = av_tindex(av);\n\t    SvREFCNT_dec_NN(ret);\n            return newSViv(length + 1);\n        } else {\n            Perl_croak(aTHX_ \"panic: Unknown flags %d in named_buff_scalar\",\n                                                (int)flags);\n            return NULL;\n        }\n    }\n    return &PL_sv_undef;\n}\n\nSV*\nPerl_reg_named_buff_all(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n    AV *av = newAV();\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_ALL;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HV *hv= RXp_PAREN_NAMES(rx);\n        HE *temphe;\n        (void)hv_iterinit(hv);\n        while ( (temphe = hv_iternext_flags(hv, 0)) ) {\n            IV i;\n            IV parno = 0;\n            SV* sv_dat = HeVAL(temphe);\n            I32 *nums = (I32*)SvPVX(sv_dat);\n            for ( i = 0; i < SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->lastparen) >= nums[i] &&\n                    rx->offs[nums[i]].start != -1 &&\n                    rx->offs[nums[i]].end != -1)\n                {\n                    parno = nums[i];\n                    break;\n                }\n            }\n            if (parno || flags & RXapif_ALL) {\n                av_push(av, newSVhek(HeKEY_hek(temphe)));\n            }\n        }\n    }\n\n    return newRV_noinc(MUTABLE_SV(av));\n}\n\nvoid\nPerl_reg_numbered_buff_fetch(pTHX_ REGEXP * const r, const I32 paren,\n\t\t\t     SV * const sv)\n{\n    struct regexp *const rx = ReANY(r);\n    char *s = NULL;\n    SSize_t i = 0;\n    SSize_t s1, t1;\n    I32 n = paren;\n\n    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_FETCH;\n\n    if (      n == RX_BUFF_IDX_CARET_PREMATCH\n           || n == RX_BUFF_IDX_CARET_FULLMATCH\n           || n == RX_BUFF_IDX_CARET_POSTMATCH\n       )\n    {\n        bool keepcopy = cBOOL(rx->extflags & RXf_PMf_KEEPCOPY);\n        if (!keepcopy) {\n            /* on something like\n             *    $r = qr/.../;\n             *    /$qr/p;\n             * the KEEPCOPY is set on the PMOP rather than the regex */\n            if (PL_curpm && r == PM_GETRE(PL_curpm))\n                 keepcopy = cBOOL(PL_curpm->op_pmflags & PMf_KEEPCOPY);\n        }\n        if (!keepcopy)\n            goto ret_undef;\n    }\n\n    if (!rx->subbeg)\n        goto ret_undef;\n\n    if (n == RX_BUFF_IDX_CARET_FULLMATCH)\n        /* no need to distinguish between them any more */\n        n = RX_BUFF_IDX_FULLMATCH;\n\n    if ((n == RX_BUFF_IDX_PREMATCH || n == RX_BUFF_IDX_CARET_PREMATCH)\n        && rx->offs[0].start != -1)\n    {\n        /* $`, ${^PREMATCH} */\n\ti = rx->offs[0].start;\n\ts = rx->subbeg;\n    }\n    else\n    if ((n == RX_BUFF_IDX_POSTMATCH || n == RX_BUFF_IDX_CARET_POSTMATCH)\n        && rx->offs[0].end != -1)\n    {\n        /* $', ${^POSTMATCH} */\n\ts = rx->subbeg - rx->suboffset + rx->offs[0].end;\n\ti = rx->sublen + rx->suboffset - rx->offs[0].end;\n    }\n    else\n    if ( 0 <= n && n <= (I32)rx->nparens &&\n        (s1 = rx->offs[n].start) != -1 &&\n        (t1 = rx->offs[n].end) != -1)\n    {\n        /* $&, ${^MATCH},  $1 ... */\n        i = t1 - s1;\n        s = rx->subbeg + s1 - rx->suboffset;\n    } else {\n        goto ret_undef;\n    }\n\n    assert(s >= rx->subbeg);\n    assert((STRLEN)rx->sublen >= (STRLEN)((s - rx->subbeg) + i) );\n    if (i >= 0) {\n#ifdef NO_TAINT_SUPPORT\n        sv_setpvn(sv, s, i);\n#else\n        const int oldtainted = TAINT_get;\n        TAINT_NOT;\n        sv_setpvn(sv, s, i);\n        TAINT_set(oldtainted);\n#endif\n        if (RXp_MATCH_UTF8(rx))\n            SvUTF8_on(sv);\n        else\n            SvUTF8_off(sv);\n        if (TAINTING_get) {\n            if (RXp_MATCH_TAINTED(rx)) {\n                if (SvTYPE(sv) >= SVt_PVMG) {\n                    MAGIC* const mg = SvMAGIC(sv);\n                    MAGIC* mgt;\n                    TAINT;\n                    SvMAGIC_set(sv, mg->mg_moremagic);\n                    SvTAINT(sv);\n                    if ((mgt = SvMAGIC(sv))) {\n                        mg->mg_moremagic = mgt;\n                        SvMAGIC_set(sv, mg);\n                    }\n                } else {\n                    TAINT;\n                    SvTAINT(sv);\n                }\n            } else\n                SvTAINTED_off(sv);\n        }\n    } else {\n      ret_undef:\n        sv_set_undef(sv);\n        return;\n    }\n}\n\nvoid\nPerl_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren,\n\t\t\t\t\t\t\t SV const * const value)\n{\n    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_STORE;\n\n    PERL_UNUSED_ARG(rx);\n    PERL_UNUSED_ARG(paren);\n    PERL_UNUSED_ARG(value);\n\n    if (!PL_localizing)\n        Perl_croak_no_modify();\n}\n\nI32\nPerl_reg_numbered_buff_length(pTHX_ REGEXP * const r, const SV * const sv,\n                              const I32 paren)\n{\n    struct regexp *const rx = ReANY(r);\n    I32 i;\n    I32 s1, t1;\n\n    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_LENGTH;\n\n    if (   paren == RX_BUFF_IDX_CARET_PREMATCH\n        || paren == RX_BUFF_IDX_CARET_FULLMATCH\n        || paren == RX_BUFF_IDX_CARET_POSTMATCH\n    )\n    {\n        bool keepcopy = cBOOL(rx->extflags & RXf_PMf_KEEPCOPY);\n        if (!keepcopy) {\n            /* on something like\n             *    $r = qr/.../;\n             *    /$qr/p;\n             * the KEEPCOPY is set on the PMOP rather than the regex */\n            if (PL_curpm && r == PM_GETRE(PL_curpm))\n                 keepcopy = cBOOL(PL_curpm->op_pmflags & PMf_KEEPCOPY);\n        }\n        if (!keepcopy)\n            goto warn_undef;\n    }\n\n    /* Some of this code was originally in C<Perl_magic_len> in F<mg.c> */\n    switch (paren) {\n      case RX_BUFF_IDX_CARET_PREMATCH: /* ${^PREMATCH} */\n      case RX_BUFF_IDX_PREMATCH:       /* $` */\n        if (rx->offs[0].start != -1) {\n\t\t\ti = rx->offs[0].start;\n\t\t\tif (i > 0) {\n\t\t\t\ts1 = 0;\n\t\t\t\tt1 = i;\n\t\t\t\tgoto getlen;\n\t\t\t}\n\t    }\n        return 0;\n\n      case RX_BUFF_IDX_CARET_POSTMATCH: /* ${^POSTMATCH} */\n      case RX_BUFF_IDX_POSTMATCH:       /* $' */\n\t    if (rx->offs[0].end != -1) {\n\t\t\ti = rx->sublen - rx->offs[0].end;\n\t\t\tif (i > 0) {\n\t\t\t\ts1 = rx->offs[0].end;\n\t\t\t\tt1 = rx->sublen;\n\t\t\t\tgoto getlen;\n\t\t\t}\n\t    }\n        return 0;\n\n      default: /* $& / ${^MATCH}, $1, $2, ... */\n\t    if (paren <= (I32)rx->nparens &&\n            (s1 = rx->offs[paren].start) != -1 &&\n            (t1 = rx->offs[paren].end) != -1)\n\t    {\n            i = t1 - s1;\n            goto getlen;\n        } else {\n          warn_undef:\n            if (ckWARN(WARN_UNINITIALIZED))\n                report_uninit((const SV *)sv);\n            return 0;\n        }\n    }\n  getlen:\n    if (i > 0 && RXp_MATCH_UTF8(rx)) {\n        const char * const s = rx->subbeg - rx->suboffset + s1;\n        const U8 *ep;\n        STRLEN el;\n\n        i = t1 - s1;\n        if (is_utf8_string_loclen((U8*)s, i, &ep, &el))\n\t\t\ti = el;\n    }\n    return i;\n}\n\nSV*\nPerl_reg_qr_package(pTHX_ REGEXP * const rx)\n{\n    PERL_ARGS_ASSERT_REG_QR_PACKAGE;\n\tPERL_UNUSED_ARG(rx);\n\tif (0)\n\t    return NULL;\n\telse\n\t    return newSVpvs(\"Regexp\");\n}\n\n/* Scans the name of a named buffer from the pattern.\n * If flags is REG_RSN_RETURN_NULL returns null.\n * If flags is REG_RSN_RETURN_NAME returns an SV* containing the name\n * If flags is REG_RSN_RETURN_DATA returns the data SV* corresponding\n * to the parsed name as looked up in the RExC_paren_names hash.\n * If there is an error throws a vFAIL().. type exception.\n */\n\n#define REG_RSN_RETURN_NULL    0\n#define REG_RSN_RETURN_NAME    1\n#define REG_RSN_RETURN_DATA    2\n\nSTATIC SV*\nS_reg_scan_name(pTHX_ RExC_state_t *pRExC_state, U32 flags)\n{\n    char *name_start = RExC_parse;\n    SV* sv_name;\n\n    PERL_ARGS_ASSERT_REG_SCAN_NAME;\n\n    assert (RExC_parse <= RExC_end);\n    if (RExC_parse == RExC_end) NOOP;\n    else if (isIDFIRST_lazy_if_safe(RExC_parse, RExC_end, UTF)) {\n         /* Note that the code here assumes well-formed UTF-8.  Skip IDFIRST by\n          * using do...while */\n\tif (UTF)\n\t    do {\n\t\tRExC_parse += UTF8SKIP(RExC_parse);\n\t    } while (   RExC_parse < RExC_end\n                     && isWORDCHAR_utf8_safe((U8*)RExC_parse, (U8*) RExC_end));\n\telse\n\t    do {\n\t\tRExC_parse++;\n\t    } while (RExC_parse < RExC_end && isWORDCHAR(*RExC_parse));\n    } else {\n        RExC_parse++; /* so the <- from the vFAIL is after the offending\n                         character */\n        vFAIL(\"Group name must start with a non-digit word character\");\n    }\n    sv_name = newSVpvn_flags(name_start, (int)(RExC_parse - name_start),\n\t\t\t     SVs_TEMP | (UTF ? SVf_UTF8 : 0));\n    if ( flags == REG_RSN_RETURN_NAME)\n        return sv_name;\n    else if (flags==REG_RSN_RETURN_DATA) {\n        HE *he_str = NULL;\n        SV *sv_dat = NULL;\n        if ( ! sv_name )      /* should not happen*/\n            Perl_croak(aTHX_ \"panic: no svname in reg_scan_name\");\n        if (RExC_paren_names)\n            he_str = hv_fetch_ent( RExC_paren_names, sv_name, 0, 0 );\n        if ( he_str )\n            sv_dat = HeVAL(he_str);\n        if ( ! sv_dat ) {   /* Didn't find group */\n\n            /* It might be a forward reference; we can't fail until we\n                * know, by completing the parse to get all the groups, and\n                * then reparsing */\n            if (ALL_PARENS_COUNTED)  {\n                vFAIL(\"Reference to nonexistent named group\");\n            }\n            else {\n                REQUIRE_PARENS_PASS;\n            }\n        }\n        return sv_dat;\n    }\n\n    Perl_croak(aTHX_ \"panic: bad flag %lx in reg_scan_name\",\n                     (unsigned long) flags);\n}\n\n#define DEBUG_PARSE_MSG(funcname)     DEBUG_PARSE_r({           \\\n    if (RExC_lastparse!=RExC_parse) {                           \\\n        Perl_re_printf( aTHX_  \"%s\",                            \\\n            Perl_pv_pretty(aTHX_ RExC_mysv1, RExC_parse,        \\\n                RExC_end - RExC_parse, 16,                      \\\n                \"\", \"\",                                         \\\n                PERL_PV_ESCAPE_UNI_DETECT |                     \\\n                PERL_PV_PRETTY_ELLIPSES   |                     \\\n                PERL_PV_PRETTY_LTGT       |                     \\\n                PERL_PV_ESCAPE_RE         |                     \\\n                PERL_PV_PRETTY_EXACTSIZE                        \\\n            )                                                   \\\n        );                                                      \\\n    } else                                                      \\\n        Perl_re_printf( aTHX_ \"%16s\",\"\");                       \\\n                                                                \\\n    if (RExC_lastnum!=RExC_emit)                                \\\n       Perl_re_printf( aTHX_ \"|%4d\", RExC_emit);                \\\n    else                                                        \\\n       Perl_re_printf( aTHX_ \"|%4s\",\"\");                        \\\n    Perl_re_printf( aTHX_ \"|%*s%-4s\",                           \\\n        (int)((depth*2)), \"\",                                   \\\n        (funcname)                                              \\\n    );                                                          \\\n    RExC_lastnum=RExC_emit;                                     \\\n    RExC_lastparse=RExC_parse;                                  \\\n})\n\n\n\n#define DEBUG_PARSE(funcname)     DEBUG_PARSE_r({           \\\n    DEBUG_PARSE_MSG((funcname));                            \\\n    Perl_re_printf( aTHX_ \"%4s\",\"\\n\");                                  \\\n})\n#define DEBUG_PARSE_FMT(funcname,fmt,args)     DEBUG_PARSE_r({\\\n    DEBUG_PARSE_MSG((funcname));                            \\\n    Perl_re_printf( aTHX_ fmt \"\\n\",args);                               \\\n})\n\n/* This section of code defines the inversion list object and its methods.  The\n * interfaces are highly subject to change, so as much as possible is static to\n * this file.  An inversion list is here implemented as a malloc'd C UV array\n * as an SVt_INVLIST scalar.\n *\n * An inversion list for Unicode is an array of code points, sorted by ordinal\n * number.  Each element gives the code point that begins a range that extends\n * up-to but not including the code point given by the next element.  The final\n * element gives the first code point of a range that extends to the platform's\n * infinity.  The even-numbered elements (invlist[0], invlist[2], invlist[4],\n * ...) give ranges whose code points are all in the inversion list.  We say\n * that those ranges are in the set.  The odd-numbered elements give ranges\n * whose code points are not in the inversion list, and hence not in the set.\n * Thus, element [0] is the first code point in the list.  Element [1]\n * is the first code point beyond that not in the list; and element [2] is the\n * first code point beyond that that is in the list.  In other words, the first\n * range is invlist[0]..(invlist[1]-1), and all code points in that range are\n * in the inversion list.  The second range is invlist[1]..(invlist[2]-1), and\n * all code points in that range are not in the inversion list.  The third\n * range invlist[2]..(invlist[3]-1) gives code points that are in the inversion\n * list, and so forth.  Thus every element whose index is divisible by two\n * gives the beginning of a range that is in the list, and every element whose\n * index is not divisible by two gives the beginning of a range not in the\n * list.  If the final element's index is divisible by two, the inversion list\n * extends to the platform's infinity; otherwise the highest code point in the\n * inversion list is the contents of that element minus 1.\n *\n * A range that contains just a single code point N will look like\n *  invlist[i]   == N\n *  invlist[i+1] == N+1\n *\n * If N is UV_MAX (the highest representable code point on the machine), N+1 is\n * impossible to represent, so element [i+1] is omitted.  The single element\n * inversion list\n *  invlist[0] == UV_MAX\n * contains just UV_MAX, but is interpreted as matching to infinity.\n *\n * Taking the complement (inverting) an inversion list is quite simple, if the\n * first element is 0, remove it; otherwise add a 0 element at the beginning.\n * This implementation reserves an element at the beginning of each inversion\n * list to always contain 0; there is an additional flag in the header which\n * indicates if the list begins at the 0, or is offset to begin at the next\n * element.  This means that the inversion list can be inverted without any\n * copying; just flip the flag.\n *\n * More about inversion lists can be found in \"Unicode Demystified\"\n * Chapter 13 by Richard Gillam, published by Addison-Wesley.\n *\n * The inversion list data structure is currently implemented as an SV pointing\n * to an array of UVs that the SV thinks are bytes.  This allows us to have an\n * array of UV whose memory management is automatically handled by the existing\n * facilities for SV's.\n *\n * Some of the methods should always be private to the implementation, and some\n * should eventually be made public */\n\n/* The header definitions are in F<invlist_inline.h> */\n\n#ifndef PERL_IN_XSUB_RE\n\nPERL_STATIC_INLINE UV*\nS__invlist_array_init(SV* const invlist, const bool will_have_0)\n{\n    /* Returns a pointer to the first element in the inversion list's array.\n     * This is called upon initialization of an inversion list.  Where the\n     * array begins depends on whether the list has the code point U+0000 in it\n     * or not.  The other parameter tells it whether the code that follows this\n     * call is about to put a 0 in the inversion list or not.  The first\n     * element is either the element reserved for 0, if TRUE, or the element\n     * after it, if FALSE */\n\n    bool* offset = get_invlist_offset_addr(invlist);\n    UV* zero_addr = (UV *) SvPVX(invlist);\n\n    PERL_ARGS_ASSERT__INVLIST_ARRAY_INIT;\n\n    /* Must be empty */\n    assert(! _invlist_len(invlist));\n\n    *zero_addr = 0;\n\n    /* 1^1 = 0; 1^0 = 1 */\n    *offset = 1 ^ will_have_0;\n    return zero_addr + *offset;\n}\n\nPERL_STATIC_INLINE void\nS_invlist_set_len(pTHX_ SV* const invlist, const UV len, const bool offset)\n{\n    /* Sets the current number of elements stored in the inversion list.\n     * Updates SvCUR correspondingly */\n    PERL_UNUSED_CONTEXT;\n    PERL_ARGS_ASSERT_INVLIST_SET_LEN;\n\n    assert(is_invlist(invlist));\n\n    SvCUR_set(invlist,\n              (len == 0)\n               ? 0\n               : TO_INTERNAL_SIZE(len + offset));\n    assert(SvLEN(invlist) == 0 || SvCUR(invlist) <= SvLEN(invlist));\n}\n\nSTATIC void\nS_invlist_replace_list_destroys_src(pTHX_ SV * dest, SV * src)\n{\n    /* Replaces the inversion list in 'dest' with the one from 'src'.  It\n     * steals the list from 'src', so 'src' is made to have a NULL list.  This\n     * is similar to what SvSetMagicSV() would do, if it were implemented on\n     * inversion lists, though this routine avoids a copy */\n\n    const UV src_len          = _invlist_len(src);\n    const bool src_offset     = *get_invlist_offset_addr(src);\n    const STRLEN src_byte_len = SvLEN(src);\n    char * array              = SvPVX(src);\n\n    const int oldtainted = TAINT_get;\n\n    PERL_ARGS_ASSERT_INVLIST_REPLACE_LIST_DESTROYS_SRC;\n\n    assert(is_invlist(src));\n    assert(is_invlist(dest));\n    assert(! invlist_is_iterating(src));\n    assert(SvCUR(src) == 0 || SvCUR(src) < SvLEN(src));\n\n    /* Make sure it ends in the right place with a NUL, as our inversion list\n     * manipulations aren't careful to keep this true, but sv_usepvn_flags()\n     * asserts it */\n    array[src_byte_len - 1] = '\\0';\n\n    TAINT_NOT;      /* Otherwise it breaks */\n    sv_usepvn_flags(dest,\n                    (char *) array,\n                    src_byte_len - 1,\n\n                    /* This flag is documented to cause a copy to be avoided */\n                    SV_HAS_TRAILING_NUL);\n    TAINT_set(oldtainted);\n    SvPV_set(src, 0);\n    SvLEN_set(src, 0);\n    SvCUR_set(src, 0);\n\n    /* Finish up copying over the other fields in an inversion list */\n    *get_invlist_offset_addr(dest) = src_offset;\n    invlist_set_len(dest, src_len, src_offset);\n    *get_invlist_previous_index_addr(dest) = 0;\n    invlist_iterfinish(dest);\n}\n\nPERL_STATIC_INLINE IV*\nS_get_invlist_previous_index_addr(SV* invlist)\n{\n    /* Return the address of the IV that is reserved to hold the cached index\n     * */\n    PERL_ARGS_ASSERT_GET_INVLIST_PREVIOUS_INDEX_ADDR;\n\n    assert(is_invlist(invlist));\n\n    return &(((XINVLIST*) SvANY(invlist))->prev_index);\n}\n\nPERL_STATIC_INLINE IV\nS_invlist_previous_index(SV* const invlist)\n{\n    /* Returns cached index of previous search */\n\n    PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;\n\n    return *get_invlist_previous_index_addr(invlist);\n}\n\nPERL_STATIC_INLINE void\nS_invlist_set_previous_index(SV* const invlist, const IV index)\n{\n    /* Caches <index> for later retrieval */\n\n    PERL_ARGS_ASSERT_INVLIST_SET_PREVIOUS_INDEX;\n\n    assert(index == 0 || index < (int) _invlist_len(invlist));\n\n    *get_invlist_previous_index_addr(invlist) = index;\n}\n\nPERL_STATIC_INLINE void\nS_invlist_trim(SV* invlist)\n{\n    /* Free the not currently-being-used space in an inversion list */\n\n    /* But don't free up the space needed for the 0 UV that is always at the\n     * beginning of the list, nor the trailing NUL */\n    const UV min_size = TO_INTERNAL_SIZE(1) + 1;\n\n    PERL_ARGS_ASSERT_INVLIST_TRIM;\n\n    assert(is_invlist(invlist));\n\n    SvPV_renew(invlist, MAX(min_size, SvCUR(invlist) + 1));\n}\n\nPERL_STATIC_INLINE void\nS_invlist_clear(pTHX_ SV* invlist)    /* Empty the inversion list */\n{\n    PERL_ARGS_ASSERT_INVLIST_CLEAR;\n\n    assert(is_invlist(invlist));\n\n    invlist_set_len(invlist, 0, 0);\n    invlist_trim(invlist);\n}\n\n#endif /* ifndef PERL_IN_XSUB_RE */\n\nPERL_STATIC_INLINE bool\nS_invlist_is_iterating(SV* const invlist)\n{\n    PERL_ARGS_ASSERT_INVLIST_IS_ITERATING;\n\n    return *(get_invlist_iter_addr(invlist)) < (STRLEN) UV_MAX;\n}\n\n#ifndef PERL_IN_XSUB_RE\n\nPERL_STATIC_INLINE UV\nS_invlist_max(SV* const invlist)\n{\n    /* Returns the maximum number of elements storable in the inversion list's\n     * array, without having to realloc() */\n\n    PERL_ARGS_ASSERT_INVLIST_MAX;\n\n    assert(is_invlist(invlist));\n\n    /* Assumes worst case, in which the 0 element is not counted in the\n     * inversion list, so subtracts 1 for that */\n    return SvLEN(invlist) == 0  /* This happens under _new_invlist_C_array */\n           ? FROM_INTERNAL_SIZE(SvCUR(invlist)) - 1\n           : FROM_INTERNAL_SIZE(SvLEN(invlist)) - 1;\n}\n\nSTATIC void\nS_initialize_invlist_guts(pTHX_ SV* invlist, const Size_t initial_size)\n{\n    PERL_ARGS_ASSERT_INITIALIZE_INVLIST_GUTS;\n\n    /* First 1 is in case the zero element isn't in the list; second 1 is for\n     * trailing NUL */\n    SvGROW(invlist, TO_INTERNAL_SIZE(initial_size + 1) + 1);\n    invlist_set_len(invlist, 0, 0);\n\n    /* Force iterinit() to be used to get iteration to work */\n    invlist_iterfinish(invlist);\n\n    *get_invlist_previous_index_addr(invlist) = 0;\n}\n\nSV*\nPerl__new_invlist(pTHX_ IV initial_size)\n{\n\n    /* Return a pointer to a newly constructed inversion list, with enough\n     * space to store 'initial_size' elements.  If that number is negative, a\n     * system default is used instead */\n\n    SV* new_list;\n\n    if (initial_size < 0) {\n\tinitial_size = 10;\n    }\n\n    new_list = newSV_type(SVt_INVLIST);\n    initialize_invlist_guts(new_list, initial_size);\n\n    return new_list;\n}\n\nSV*\nPerl__new_invlist_C_array(pTHX_ const UV* const list)\n{\n    /* Return a pointer to a newly constructed inversion list, initialized to\n     * point to <list>, which has to be in the exact correct inversion list\n     * form, including internal fields.  Thus this is a dangerous routine that\n     * should not be used in the wrong hands.  The passed in 'list' contains\n     * several header fields at the beginning that are not part of the\n     * inversion list body proper */\n\n    const STRLEN length = (STRLEN) list[0];\n    const UV version_id =          list[1];\n    const bool offset   =    cBOOL(list[2]);\n#define HEADER_LENGTH 3\n    /* If any of the above changes in any way, you must change HEADER_LENGTH\n     * (if appropriate) and regenerate INVLIST_VERSION_ID by running\n     *      perl -E 'say int(rand 2**31-1)'\n     */\n#define INVLIST_VERSION_ID 148565664 /* This is a combination of a version and\n                                        data structure type, so that one being\n                                        passed in can be validated to be an\n                                        inversion list of the correct vintage.\n                                       */\n\n    SV* invlist = newSV_type(SVt_INVLIST);\n\n    PERL_ARGS_ASSERT__NEW_INVLIST_C_ARRAY;\n\n    if (version_id != INVLIST_VERSION_ID) {\n        Perl_croak(aTHX_ \"panic: Incorrect version for previously generated inversion list\");\n    }\n\n    /* The generated array passed in includes header elements that aren't part\n     * of the list proper, so start it just after them */\n    SvPV_set(invlist, (char *) (list + HEADER_LENGTH));\n\n    SvLEN_set(invlist, 0);  /* Means we own the contents, and the system\n\t\t\t       shouldn't touch it */\n\n    *(get_invlist_offset_addr(invlist)) = offset;\n\n    /* The 'length' passed to us is the physical number of elements in the\n     * inversion list.  But if there is an offset the logical number is one\n     * less than that */\n    invlist_set_len(invlist, length  - offset, offset);\n\n    invlist_set_previous_index(invlist, 0);\n\n    /* Initialize the iteration pointer. */\n    invlist_iterfinish(invlist);\n\n    SvREADONLY_on(invlist);\n\n    return invlist;\n}\n\nSTATIC void\nS_invlist_extend(pTHX_ SV* const invlist, const UV new_max)\n{\n    /* Grow the maximum size of an inversion list */\n\n    PERL_ARGS_ASSERT_INVLIST_EXTEND;\n\n    assert(is_invlist(invlist));\n\n    /* Add one to account for the zero element at the beginning which may not\n     * be counted by the calling parameters */\n    SvGROW((SV *)invlist, TO_INTERNAL_SIZE(new_max + 1));\n}\n\nSTATIC void\nS__append_range_to_invlist(pTHX_ SV* const invlist,\n                                 const UV start, const UV end)\n{\n   /* Subject to change or removal.  Append the range from 'start' to 'end' at\n    * the end of the inversion list.  The range must be above any existing\n    * ones. */\n\n    UV* array;\n    UV max = invlist_max(invlist);\n    UV len = _invlist_len(invlist);\n    bool offset;\n\n    PERL_ARGS_ASSERT__APPEND_RANGE_TO_INVLIST;\n\n    if (len == 0) { /* Empty lists must be initialized */\n        offset = start != 0;\n        array = _invlist_array_init(invlist, ! offset);\n    }\n    else {\n\t/* Here, the existing list is non-empty. The current max entry in the\n\t * list is generally the first value not in the set, except when the\n\t * set extends to the end of permissible values, in which case it is\n\t * the first entry in that final set, and so this call is an attempt to\n\t * append out-of-order */\n\n\tUV final_element = len - 1;\n\tarray = invlist_array(invlist);\n\tif (   array[final_element] > start\n\t    || ELEMENT_RANGE_MATCHES_INVLIST(final_element))\n\t{\n\t    Perl_croak(aTHX_ \"panic: attempting to append to an inversion list, but wasn't at the end of the list, final=%\" UVuf \", start=%\" UVuf \", match=%c\",\n\t\t     array[final_element], start,\n\t\t     ELEMENT_RANGE_MATCHES_INVLIST(final_element) ? 't' : 'f');\n\t}\n\n        /* Here, it is a legal append.  If the new range begins 1 above the end\n         * of the range below it, it is extending the range below it, so the\n         * new first value not in the set is one greater than the newly\n         * extended range.  */\n        offset = *get_invlist_offset_addr(invlist);\n\tif (array[final_element] == start) {\n\t    if (end != UV_MAX) {\n\t\tarray[final_element] = end + 1;\n\t    }\n\t    else {\n\t\t/* But if the end is the maximum representable on the machine,\n                 * assume that infinity was actually what was meant.  Just let\n                 * the range that this would extend to have no end */\n\t\tinvlist_set_len(invlist, len - 1, offset);\n\t    }\n\t    return;\n\t}\n    }\n\n    /* Here the new range doesn't extend any existing set.  Add it */\n\n    len += 2;\t/* Includes an element each for the start and end of range */\n\n    /* If wll overflow the existing space, extend, which may cause the array to\n     * be moved */\n    if (max < len) {\n\tinvlist_extend(invlist, len);\n\n        /* Have to set len here to avoid assert failure in invlist_array() */\n        invlist_set_len(invlist, len, offset);\n\n\tarray = invlist_array(invlist);\n    }\n    else {\n\tinvlist_set_len(invlist, len, offset);\n    }\n\n    /* The next item on the list starts the range, the one after that is\n     * one past the new range.  */\n    array[len - 2] = start;\n    if (end != UV_MAX) {\n\tarray[len - 1] = end + 1;\n    }\n    else {\n\t/* But if the end is the maximum representable on the machine, just let\n\t * the range have no end */\n\tinvlist_set_len(invlist, len - 1, offset);\n    }\n}\n\nSSize_t\nPerl__invlist_search(SV* const invlist, const UV cp)\n{\n    /* Searches the inversion list for the entry that contains the input code\n     * point <cp>.  If <cp> is not in the list, -1 is returned.  Otherwise, the\n     * return value is the index into the list's array of the range that\n     * contains <cp>, that is, 'i' such that\n     *\tarray[i] <= cp < array[i+1]\n     */\n\n    IV low = 0;\n    IV mid;\n    IV high = _invlist_len(invlist);\n    const IV highest_element = high - 1;\n    const UV* array;\n\n    PERL_ARGS_ASSERT__INVLIST_SEARCH;\n\n    /* If list is empty, return failure. */\n    if (high == 0) {\n\treturn -1;\n    }\n\n    /* (We can't get the array unless we know the list is non-empty) */\n    array = invlist_array(invlist);\n\n    mid = invlist_previous_index(invlist);\n    assert(mid >=0);\n    if (mid > highest_element) {\n        mid = highest_element;\n    }\n\n    /* <mid> contains the cache of the result of the previous call to this\n     * function (0 the first time).  See if this call is for the same result,\n     * or if it is for mid-1.  This is under the theory that calls to this\n     * function will often be for related code points that are near each other.\n     * And benchmarks show that caching gives better results.  We also test\n     * here if the code point is within the bounds of the list.  These tests\n     * replace others that would have had to be made anyway to make sure that\n     * the array bounds were not exceeded, and these give us extra information\n     * at the same time */\n    if (cp >= array[mid]) {\n        if (cp >= array[highest_element]) {\n            return highest_element;\n        }\n\n        /* Here, array[mid] <= cp < array[highest_element].  This means that\n         * the final element is not the answer, so can exclude it; it also\n         * means that <mid> is not the final element, so can refer to 'mid + 1'\n         * safely */\n        if (cp < array[mid + 1]) {\n            return mid;\n        }\n        high--;\n        low = mid + 1;\n    }\n    else { /* cp < aray[mid] */\n        if (cp < array[0]) { /* Fail if outside the array */\n            return -1;\n        }\n        high = mid;\n        if (cp >= array[mid - 1]) {\n            goto found_entry;\n        }\n    }\n\n    /* Binary search.  What we are looking for is <i> such that\n     *\tarray[i] <= cp < array[i+1]\n     * The loop below converges on the i+1.  Note that there may not be an\n     * (i+1)th element in the array, and things work nonetheless */\n    while (low < high) {\n\tmid = (low + high) / 2;\n        assert(mid <= highest_element);\n\tif (array[mid] <= cp) { /* cp >= array[mid] */\n\t    low = mid + 1;\n\n\t    /* We could do this extra test to exit the loop early.\n\t    if (cp < array[low]) {\n\t\treturn mid;\n\t    }\n\t    */\n\t}\n\telse { /* cp < array[mid] */\n\t    high = mid;\n\t}\n    }\n\n  found_entry:\n    high--;\n    invlist_set_previous_index(invlist, high);\n    return high;\n}\n\nvoid\nPerl__invlist_union_maybe_complement_2nd(pTHX_ SV* const a, SV* const b,\n                                         const bool complement_b, SV** output)\n{\n    /* Take the union of two inversion lists and point '*output' to it.  On\n     * input, '*output' MUST POINT TO NULL OR TO AN SV* INVERSION LIST (possibly\n     * even 'a' or 'b').  If to an inversion list, the contents of the original\n     * list will be replaced by the union.  The first list, 'a', may be\n     * NULL, in which case a copy of the second list is placed in '*output'.\n     * If 'complement_b' is TRUE, the union is taken of the complement\n     * (inversion) of 'b' instead of b itself.\n     *\n     * The basis for this comes from \"Unicode Demystified\" Chapter 13 by\n     * Richard Gillam, published by Addison-Wesley, and explained at some\n     * length there.  The preface says to incorporate its examples into your\n     * code at your own risk.\n     *\n     * The algorithm is like a merge sort. */\n\n    const UV* array_a;    /* a's array */\n    const UV* array_b;\n    UV len_a;\t    /* length of a's array */\n    UV len_b;\n\n    SV* u;\t\t\t/* the resulting union */\n    UV* array_u;\n    UV len_u = 0;\n\n    UV i_a = 0;\t\t    /* current index into a's array */\n    UV i_b = 0;\n    UV i_u = 0;\n\n    /* running count, as explained in the algorithm source book; items are\n     * stopped accumulating and are output when the count changes to/from 0.\n     * The count is incremented when we start a range that's in an input's set,\n     * and decremented when we start a range that's not in a set.  So this\n     * variable can be 0, 1, or 2.  When it is 0 neither input is in their set,\n     * and hence nothing goes into the union; 1, just one of the inputs is in\n     * its set (and its current range gets added to the union); and 2 when both\n     * inputs are in their sets.  */\n    UV count = 0;\n\n    PERL_ARGS_ASSERT__INVLIST_UNION_MAYBE_COMPLEMENT_2ND;\n    assert(a != b);\n    assert(*output == NULL || is_invlist(*output));\n\n    len_b = _invlist_len(b);\n    if (len_b == 0) {\n\n        /* Here, 'b' is empty, hence it's complement is all possible code\n         * points.  So if the union includes the complement of 'b', it includes\n         * everything, and we need not even look at 'a'.  It's easiest to\n         * create a new inversion list that matches everything.  */\n        if (complement_b) {\n            SV* everything = _add_range_to_invlist(NULL, 0, UV_MAX);\n\n            if (*output == NULL) { /* If the output didn't exist, just point it\n                                      at the new list */\n                *output = everything;\n            }\n            else { /* Otherwise, replace its contents with the new list */\n                invlist_replace_list_destroys_src(*output, everything);\n                SvREFCNT_dec_NN(everything);\n            }\n\n            return;\n        }\n\n        /* Here, we don't want the complement of 'b', and since 'b' is empty,\n         * the union will come entirely from 'a'.  If 'a' is NULL or empty, the\n         * output will be empty */\n\n        if (a == NULL || _invlist_len(a) == 0) {\n            if (*output == NULL) {\n                *output = _new_invlist(0);\n            }\n            else {\n                invlist_clear(*output);\n            }\n            return;\n        }\n\n        /* Here, 'a' is not empty, but 'b' is, so 'a' entirely determines the\n         * union.  We can just return a copy of 'a' if '*output' doesn't point\n         * to an existing list */\n        if (*output == NULL) {\n            *output = invlist_clone(a, NULL);\n            return;\n        }\n\n        /* If the output is to overwrite 'a', we have a no-op, as it's\n         * already in 'a' */\n        if (*output == a) {\n            return;\n        }\n\n        /* Here, '*output' is to be overwritten by 'a' */\n        u = invlist_clone(a, NULL);\n        invlist_replace_list_destroys_src(*output, u);\n        SvREFCNT_dec_NN(u);\n\n        return;\n    }\n\n    /* Here 'b' is not empty.  See about 'a' */\n\n    if (a == NULL || ((len_a = _invlist_len(a)) == 0)) {\n\n        /* Here, 'a' is empty (and b is not).  That means the union will come\n         * entirely from 'b'.  If '*output' is NULL, we can directly return a\n         * clone of 'b'.  Otherwise, we replace the contents of '*output' with\n         * the clone */\n\n        SV ** dest = (*output == NULL) ? output : &u;\n        *dest = invlist_clone(b, NULL);\n        if (complement_b) {\n            _invlist_invert(*dest);\n        }\n\n        if (dest == &u) {\n            invlist_replace_list_destroys_src(*output, u);\n            SvREFCNT_dec_NN(u);\n        }\n\n\treturn;\n    }\n\n    /* Here both lists exist and are non-empty */\n    array_a = invlist_array(a);\n    array_b = invlist_array(b);\n\n    /* If are to take the union of 'a' with the complement of b, set it\n     * up so are looking at b's complement. */\n    if (complement_b) {\n\n\t/* To complement, we invert: if the first element is 0, remove it.  To\n\t * do this, we just pretend the array starts one later */\n        if (array_b[0] == 0) {\n            array_b++;\n            len_b--;\n        }\n        else {\n\n            /* But if the first element is not zero, we pretend the list starts\n             * at the 0 that is always stored immediately before the array. */\n            array_b--;\n            len_b++;\n        }\n    }\n\n    /* Size the union for the worst case: that the sets are completely\n     * disjoint */\n    u = _new_invlist(len_a + len_b);\n\n    /* Will contain U+0000 if either component does */\n    array_u = _invlist_array_init(u, (    len_a > 0 && array_a[0] == 0)\n                                      || (len_b > 0 && array_b[0] == 0));\n\n    /* Go through each input list item by item, stopping when have exhausted\n     * one of them */\n    while (i_a < len_a && i_b < len_b) {\n\tUV cp;\t    /* The element to potentially add to the union's array */\n\tbool cp_in_set;   /* is it in the the input list's set or not */\n\n\t/* We need to take one or the other of the two inputs for the union.\n\t * Since we are merging two sorted lists, we take the smaller of the\n         * next items.  In case of a tie, we take first the one that is in its\n         * set.  If we first took the one not in its set, it would decrement\n         * the count, possibly to 0 which would cause it to be output as ending\n         * the range, and the next time through we would take the same number,\n         * and output it again as beginning the next range.  By doing it the\n         * opposite way, there is no possibility that the count will be\n         * momentarily decremented to 0, and thus the two adjoining ranges will\n         * be seamlessly merged.  (In a tie and both are in the set or both not\n         * in the set, it doesn't matter which we take first.) */\n\tif (       array_a[i_a] < array_b[i_b]\n\t    || (   array_a[i_a] == array_b[i_b]\n\t\t&& ELEMENT_RANGE_MATCHES_INVLIST(i_a)))\n\t{\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_a);\n\t    cp = array_a[i_a++];\n\t}\n\telse {\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_b);\n\t    cp = array_b[i_b++];\n\t}\n\n\t/* Here, have chosen which of the two inputs to look at.  Only output\n\t * if the running count changes to/from 0, which marks the\n\t * beginning/end of a range that's in the set */\n\tif (cp_in_set) {\n\t    if (count == 0) {\n\t\tarray_u[i_u++] = cp;\n\t    }\n\t    count++;\n\t}\n\telse {\n\t    count--;\n\t    if (count == 0) {\n\t\tarray_u[i_u++] = cp;\n\t    }\n\t}\n    }\n\n\n    /* The loop above increments the index into exactly one of the input lists\n     * each iteration, and ends when either index gets to its list end.  That\n     * means the other index is lower than its end, and so something is\n     * remaining in that one.  We decrement 'count', as explained below, if\n     * that list is in its set.  (i_a and i_b each currently index the element\n     * beyond the one we care about.) */\n    if (   (i_a != len_a && PREV_RANGE_MATCHES_INVLIST(i_a))\n\t|| (i_b != len_b && PREV_RANGE_MATCHES_INVLIST(i_b)))\n    {\n\tcount--;\n    }\n\n    /* Above we decremented 'count' if the list that had unexamined elements in\n     * it was in its set.  This has made it so that 'count' being non-zero\n     * means there isn't anything left to output; and 'count' equal to 0 means\n     * that what is left to output is precisely that which is left in the\n     * non-exhausted input list.\n     *\n     * To see why, note first that the exhausted input obviously has nothing\n     * left to add to the union.  If it was in its set at its end, that means\n     * the set extends from here to the platform's infinity, and hence so does\n     * the union and the non-exhausted set is irrelevant.  The exhausted set\n     * also contributed 1 to 'count'.  If 'count' was 2, it got decremented to\n     * 1, but if it was 1, the non-exhausted set wasn't in its set, and so\n     * 'count' remains at 1.  This is consistent with the decremented 'count'\n     * != 0 meaning there's nothing left to add to the union.\n     *\n     * But if the exhausted input wasn't in its set, it contributed 0 to\n     * 'count', and the rest of the union will be whatever the other input is.\n     * If 'count' was 0, neither list was in its set, and 'count' remains 0;\n     * otherwise it gets decremented to 0.  This is consistent with 'count'\n     * == 0 meaning the remainder of the union is whatever is left in the\n     * non-exhausted list. */\n    if (count != 0) {\n        len_u = i_u;\n    }\n    else {\n        IV copy_count = len_a - i_a;\n        if (copy_count > 0) {   /* The non-exhausted input is 'a' */\n\t    Copy(array_a + i_a, array_u + i_u, copy_count, UV);\n        }\n        else { /* The non-exhausted input is b */\n            copy_count = len_b - i_b;\n\t    Copy(array_b + i_b, array_u + i_u, copy_count, UV);\n        }\n        len_u = i_u + copy_count;\n    }\n\n    /* Set the result to the final length, which can change the pointer to\n     * array_u, so re-find it.  (Note that it is unlikely that this will\n     * change, as we are shrinking the space, not enlarging it) */\n    if (len_u != _invlist_len(u)) {\n\tinvlist_set_len(u, len_u, *get_invlist_offset_addr(u));\n\tinvlist_trim(u);\n\tarray_u = invlist_array(u);\n    }\n\n    if (*output == NULL) {  /* Simply return the new inversion list */\n        *output = u;\n    }\n    else {\n        /* Otherwise, overwrite the inversion list that was in '*output'.  We\n         * could instead free '*output', and then set it to 'u', but experience\n         * has shown [perl #127392] that if the input is a mortal, we can get a\n         * huge build-up of these during regex compilation before they get\n         * freed. */\n        invlist_replace_list_destroys_src(*output, u);\n        SvREFCNT_dec_NN(u);\n    }\n\n    return;\n}\n\nvoid\nPerl__invlist_intersection_maybe_complement_2nd(pTHX_ SV* const a, SV* const b,\n                                               const bool complement_b, SV** i)\n{\n    /* Take the intersection of two inversion lists and point '*i' to it.  On\n     * input, '*i' MUST POINT TO NULL OR TO AN SV* INVERSION LIST (possibly\n     * even 'a' or 'b').  If to an inversion list, the contents of the original\n     * list will be replaced by the intersection.  The first list, 'a', may be\n     * NULL, in which case '*i' will be an empty list.  If 'complement_b' is\n     * TRUE, the result will be the intersection of 'a' and the complement (or\n     * inversion) of 'b' instead of 'b' directly.\n     *\n     * The basis for this comes from \"Unicode Demystified\" Chapter 13 by\n     * Richard Gillam, published by Addison-Wesley, and explained at some\n     * length there.  The preface says to incorporate its examples into your\n     * code at your own risk.  In fact, it had bugs\n     *\n     * The algorithm is like a merge sort, and is essentially the same as the\n     * union above\n     */\n\n    const UV* array_a;\t\t/* a's array */\n    const UV* array_b;\n    UV len_a;\t/* length of a's array */\n    UV len_b;\n\n    SV* r;\t\t     /* the resulting intersection */\n    UV* array_r;\n    UV len_r = 0;\n\n    UV i_a = 0;\t\t    /* current index into a's array */\n    UV i_b = 0;\n    UV i_r = 0;\n\n    /* running count of how many of the two inputs are postitioned at ranges\n     * that are in their sets.  As explained in the algorithm source book,\n     * items are stopped accumulating and are output when the count changes\n     * to/from 2.  The count is incremented when we start a range that's in an\n     * input's set, and decremented when we start a range that's not in a set.\n     * Only when it is 2 are we in the intersection. */\n    UV count = 0;\n\n    PERL_ARGS_ASSERT__INVLIST_INTERSECTION_MAYBE_COMPLEMENT_2ND;\n    assert(a != b);\n    assert(*i == NULL || is_invlist(*i));\n\n    /* Special case if either one is empty */\n    len_a = (a == NULL) ? 0 : _invlist_len(a);\n    if ((len_a == 0) || ((len_b = _invlist_len(b)) == 0)) {\n        if (len_a != 0 && complement_b) {\n\n            /* Here, 'a' is not empty, therefore from the enclosing 'if', 'b'\n             * must be empty.  Here, also we are using 'b's complement, which\n             * hence must be every possible code point.  Thus the intersection\n             * is simply 'a'. */\n\n            if (*i == a) {  /* No-op */\n                return;\n            }\n\n            if (*i == NULL) {\n                *i = invlist_clone(a, NULL);\n                return;\n            }\n\n            r = invlist_clone(a, NULL);\n            invlist_replace_list_destroys_src(*i, r);\n            SvREFCNT_dec_NN(r);\n            return;\n        }\n\n        /* Here, 'a' or 'b' is empty and not using the complement of 'b'.  The\n         * intersection must be empty */\n        if (*i == NULL) {\n            *i = _new_invlist(0);\n            return;\n        }\n\n        invlist_clear(*i);\n\treturn;\n    }\n\n    /* Here both lists exist and are non-empty */\n    array_a = invlist_array(a);\n    array_b = invlist_array(b);\n\n    /* If are to take the intersection of 'a' with the complement of b, set it\n     * up so are looking at b's complement. */\n    if (complement_b) {\n\n\t/* To complement, we invert: if the first element is 0, remove it.  To\n\t * do this, we just pretend the array starts one later */\n        if (array_b[0] == 0) {\n            array_b++;\n            len_b--;\n        }\n        else {\n\n            /* But if the first element is not zero, we pretend the list starts\n             * at the 0 that is always stored immediately before the array. */\n            array_b--;\n            len_b++;\n        }\n    }\n\n    /* Size the intersection for the worst case: that the intersection ends up\n     * fragmenting everything to be completely disjoint */\n    r= _new_invlist(len_a + len_b);\n\n    /* Will contain U+0000 iff both components do */\n    array_r = _invlist_array_init(r,    len_a > 0 && array_a[0] == 0\n                                     && len_b > 0 && array_b[0] == 0);\n\n    /* Go through each list item by item, stopping when have exhausted one of\n     * them */\n    while (i_a < len_a && i_b < len_b) {\n\tUV cp;\t    /* The element to potentially add to the intersection's\n\t\t       array */\n\tbool cp_in_set;\t/* Is it in the input list's set or not */\n\n\t/* We need to take one or the other of the two inputs for the\n\t * intersection.  Since we are merging two sorted lists, we take the\n         * smaller of the next items.  In case of a tie, we take first the one\n         * that is not in its set (a difference from the union algorithm).  If\n         * we first took the one in its set, it would increment the count,\n         * possibly to 2 which would cause it to be output as starting a range\n         * in the intersection, and the next time through we would take that\n         * same number, and output it again as ending the set.  By doing the\n         * opposite of this, there is no possibility that the count will be\n         * momentarily incremented to 2.  (In a tie and both are in the set or\n         * both not in the set, it doesn't matter which we take first.) */\n\tif (       array_a[i_a] < array_b[i_b]\n\t    || (   array_a[i_a] == array_b[i_b]\n\t\t&& ! ELEMENT_RANGE_MATCHES_INVLIST(i_a)))\n\t{\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_a);\n\t    cp = array_a[i_a++];\n\t}\n\telse {\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_b);\n\t    cp= array_b[i_b++];\n\t}\n\n\t/* Here, have chosen which of the two inputs to look at.  Only output\n\t * if the running count changes to/from 2, which marks the\n\t * beginning/end of a range that's in the intersection */\n\tif (cp_in_set) {\n\t    count++;\n\t    if (count == 2) {\n\t\tarray_r[i_r++] = cp;\n\t    }\n\t}\n\telse {\n\t    if (count == 2) {\n\t\tarray_r[i_r++] = cp;\n\t    }\n\t    count--;\n\t}\n\n    }\n\n    /* The loop above increments the index into exactly one of the input lists\n     * each iteration, and ends when either index gets to its list end.  That\n     * means the other index is lower than its end, and so something is\n     * remaining in that one.  We increment 'count', as explained below, if the\n     * exhausted list was in its set.  (i_a and i_b each currently index the\n     * element beyond the one we care about.) */\n    if (   (i_a == len_a && PREV_RANGE_MATCHES_INVLIST(i_a))\n        || (i_b == len_b && PREV_RANGE_MATCHES_INVLIST(i_b)))\n    {\n\tcount++;\n    }\n\n    /* Above we incremented 'count' if the exhausted list was in its set.  This\n     * has made it so that 'count' being below 2 means there is nothing left to\n     * output; otheriwse what's left to add to the intersection is precisely\n     * that which is left in the non-exhausted input list.\n     *\n     * To see why, note first that the exhausted input obviously has nothing\n     * left to affect the intersection.  If it was in its set at its end, that\n     * means the set extends from here to the platform's infinity, and hence\n     * anything in the non-exhausted's list will be in the intersection, and\n     * anything not in it won't be.  Hence, the rest of the intersection is\n     * precisely what's in the non-exhausted list  The exhausted set also\n     * contributed 1 to 'count', meaning 'count' was at least 1.  Incrementing\n     * it means 'count' is now at least 2.  This is consistent with the\n     * incremented 'count' being >= 2 means to add the non-exhausted list to\n     * the intersection.\n     *\n     * But if the exhausted input wasn't in its set, it contributed 0 to\n     * 'count', and the intersection can't include anything further; the\n     * non-exhausted set is irrelevant.  'count' was at most 1, and doesn't get\n     * incremented.  This is consistent with 'count' being < 2 meaning nothing\n     * further to add to the intersection. */\n    if (count < 2) { /* Nothing left to put in the intersection. */\n        len_r = i_r;\n    }\n    else { /* copy the non-exhausted list, unchanged. */\n        IV copy_count = len_a - i_a;\n        if (copy_count > 0) {   /* a is the one with stuff left */\n\t    Copy(array_a + i_a, array_r + i_r, copy_count, UV);\n        }\n        else {  /* b is the one with stuff left */\n            copy_count = len_b - i_b;\n\t    Copy(array_b + i_b, array_r + i_r, copy_count, UV);\n        }\n        len_r = i_r + copy_count;\n    }\n\n    /* Set the result to the final length, which can change the pointer to\n     * array_r, so re-find it.  (Note that it is unlikely that this will\n     * change, as we are shrinking the space, not enlarging it) */\n    if (len_r != _invlist_len(r)) {\n\tinvlist_set_len(r, len_r, *get_invlist_offset_addr(r));\n\tinvlist_trim(r);\n\tarray_r = invlist_array(r);\n    }\n\n    if (*i == NULL) { /* Simply return the calculated intersection */\n        *i = r;\n    }\n    else { /* Otherwise, replace the existing inversion list in '*i'.  We could\n              instead free '*i', and then set it to 'r', but experience has\n              shown [perl #127392] that if the input is a mortal, we can get a\n              huge build-up of these during regex compilation before they get\n              freed. */\n        if (len_r) {\n            invlist_replace_list_destroys_src(*i, r);\n        }\n        else {\n            invlist_clear(*i);\n        }\n        SvREFCNT_dec_NN(r);\n    }\n\n    return;\n}\n\nSV*\nPerl__add_range_to_invlist(pTHX_ SV* invlist, UV start, UV end)\n{\n    /* Add the range from 'start' to 'end' inclusive to the inversion list's\n     * set.  A pointer to the inversion list is returned.  This may actually be\n     * a new list, in which case the passed in one has been destroyed.  The\n     * passed-in inversion list can be NULL, in which case a new one is created\n     * with just the one range in it.  The new list is not necessarily\n     * NUL-terminated.  Space is not freed if the inversion list shrinks as a\n     * result of this function.  The gain would not be large, and in many\n     * cases, this is called multiple times on a single inversion list, so\n     * anything freed may almost immediately be needed again.\n     *\n     * This used to mostly call the 'union' routine, but that is much more\n     * heavyweight than really needed for a single range addition */\n\n    UV* array;              /* The array implementing the inversion list */\n    UV len;                 /* How many elements in 'array' */\n    SSize_t i_s;            /* index into the invlist array where 'start'\n                               should go */\n    SSize_t i_e = 0;        /* And the index where 'end' should go */\n    UV cur_highest;         /* The highest code point in the inversion list\n                               upon entry to this function */\n\n    /* This range becomes the whole inversion list if none already existed */\n    if (invlist == NULL) {\n\tinvlist = _new_invlist(2);\n        _append_range_to_invlist(invlist, start, end);\n        return invlist;\n    }\n\n    /* Likewise, if the inversion list is currently empty */\n    len = _invlist_len(invlist);\n    if (len == 0) {\n        _append_range_to_invlist(invlist, start, end);\n        return invlist;\n    }\n\n    /* Starting here, we have to know the internals of the list */\n    array = invlist_array(invlist);\n\n    /* If the new range ends higher than the current highest ... */\n    cur_highest = invlist_highest(invlist);\n    if (end > cur_highest) {\n\n        /* If the whole range is higher, we can just append it */\n        if (start > cur_highest) {\n            _append_range_to_invlist(invlist, start, end);\n            return invlist;\n        }\n\n        /* Otherwise, add the portion that is higher ... */\n        _append_range_to_invlist(invlist, cur_highest + 1, end);\n\n        /* ... and continue on below to handle the rest.  As a result of the\n         * above append, we know that the index of the end of the range is the\n         * final even numbered one of the array.  Recall that the final element\n         * always starts a range that extends to infinity.  If that range is in\n         * the set (meaning the set goes from here to infinity), it will be an\n         * even index, but if it isn't in the set, it's odd, and the final\n         * range in the set is one less, which is even. */\n        if (end == UV_MAX) {\n            i_e = len;\n        }\n        else {\n            i_e = len - 2;\n        }\n    }\n\n    /* We have dealt with appending, now see about prepending.  If the new\n     * range starts lower than the current lowest ... */\n    if (start < array[0]) {\n\n        /* Adding something which has 0 in it is somewhat tricky, and uncommon.\n         * Let the union code handle it, rather than having to know the\n         * trickiness in two code places.  */\n        if (UNLIKELY(start == 0)) {\n            SV* range_invlist;\n\n            range_invlist = _new_invlist(2);\n            _append_range_to_invlist(range_invlist, start, end);\n\n            _invlist_union(invlist, range_invlist, &invlist);\n\n            SvREFCNT_dec_NN(range_invlist);\n\n            return invlist;\n        }\n\n        /* If the whole new range comes before the first entry, and doesn't\n         * extend it, we have to insert it as an additional range */\n        if (end < array[0] - 1) {\n            i_s = i_e = -1;\n            goto splice_in_new_range;\n        }\n\n        /* Here the new range adjoins the existing first range, extending it\n         * downwards. */\n        array[0] = start;\n\n        /* And continue on below to handle the rest.  We know that the index of\n         * the beginning of the range is the first one of the array */\n        i_s = 0;\n    }\n    else { /* Not prepending any part of the new range to the existing list.\n            * Find where in the list it should go.  This finds i_s, such that:\n            *     invlist[i_s] <= start < array[i_s+1]\n            */\n        i_s = _invlist_search(invlist, start);\n    }\n\n    /* At this point, any extending before the beginning of the inversion list\n     * and/or after the end has been done.  This has made it so that, in the\n     * code below, each endpoint of the new range is either in a range that is\n     * in the set, or is in a gap between two ranges that are.  This means we\n     * don't have to worry about exceeding the array bounds.\n     *\n     * Find where in the list the new range ends (but we can skip this if we\n     * have already determined what it is, or if it will be the same as i_s,\n     * which we already have computed) */\n    if (i_e == 0) {\n        i_e = (start == end)\n              ? i_s\n              : _invlist_search(invlist, end);\n    }\n\n    /* Here generally invlist[i_e] <= end < array[i_e+1].  But if invlist[i_e]\n     * is a range that goes to infinity there is no element at invlist[i_e+1],\n     * so only the first relation holds. */\n\n    if ( ! ELEMENT_RANGE_MATCHES_INVLIST(i_s)) {\n\n        /* Here, the ranges on either side of the beginning of the new range\n         * are in the set, and this range starts in the gap between them.\n         *\n         * The new range extends the range above it downwards if the new range\n         * ends at or above that range's start */\n        const bool extends_the_range_above = (   end == UV_MAX\n                                              || end + 1 >= array[i_s+1]);\n\n        /* The new range extends the range below it upwards if it begins just\n         * after where that range ends */\n        if (start == array[i_s]) {\n\n            /* If the new range fills the entire gap between the other ranges,\n             * they will get merged together.  Other ranges may also get\n             * merged, depending on how many of them the new range spans.  In\n             * the general case, we do the merge later, just once, after we\n             * figure out how many to merge.  But in the case where the new\n             * range exactly spans just this one gap (possibly extending into\n             * the one above), we do the merge here, and an early exit.  This\n             * is done here to avoid having to special case later. */\n            if (i_e - i_s <= 1) {\n\n                /* If i_e - i_s == 1, it means that the new range terminates\n                 * within the range above, and hence 'extends_the_range_above'\n                 * must be true.  (If the range above it extends to infinity,\n                 * 'i_s+2' will be above the array's limit, but 'len-i_s-2'\n                 * will be 0, so no harm done.) */\n                if (extends_the_range_above) {\n                    Move(array + i_s + 2, array + i_s, len - i_s - 2, UV);\n                    invlist_set_len(invlist,\n                                    len - 2,\n                                    *(get_invlist_offset_addr(invlist)));\n                    return invlist;\n                }\n\n                /* Here, i_e must == i_s.  We keep them in sync, as they apply\n                 * to the same range, and below we are about to decrement i_s\n                 * */\n                i_e--;\n            }\n\n            /* Here, the new range is adjacent to the one below.  (It may also\n             * span beyond the range above, but that will get resolved later.)\n             * Extend the range below to include this one. */\n            array[i_s] = (end == UV_MAX) ? UV_MAX : end + 1;\n            i_s--;\n            start = array[i_s];\n        }\n        else if (extends_the_range_above) {\n\n            /* Here the new range only extends the range above it, but not the\n             * one below.  It merges with the one above.  Again, we keep i_e\n             * and i_s in sync if they point to the same range */\n            if (i_e == i_s) {\n                i_e++;\n            }\n            i_s++;\n            array[i_s] = start;\n        }\n    }\n\n    /* Here, we've dealt with the new range start extending any adjoining\n     * existing ranges.\n     *\n     * If the new range extends to infinity, it is now the final one,\n     * regardless of what was there before */\n    if (UNLIKELY(end == UV_MAX)) {\n        invlist_set_len(invlist, i_s + 1, *(get_invlist_offset_addr(invlist)));\n        return invlist;\n    }\n\n    /* If i_e started as == i_s, it has also been dealt with,\n     * and been updated to the new i_s, which will fail the following if */\n    if (! ELEMENT_RANGE_MATCHES_INVLIST(i_e)) {\n\n        /* Here, the ranges on either side of the end of the new range are in\n         * the set, and this range ends in the gap between them.\n         *\n         * If this range is adjacent to (hence extends) the range above it, it\n         * becomes part of that range; likewise if it extends the range below,\n         * it becomes part of that range */\n        if (end + 1 == array[i_e+1]) {\n            i_e++;\n            array[i_e] = start;\n        }\n        else if (start <= array[i_e]) {\n            array[i_e] = end + 1;\n            i_e--;\n        }\n    }\n\n    if (i_s == i_e) {\n\n        /* If the range fits entirely in an existing range (as possibly already\n         * extended above), it doesn't add anything new */\n        if (ELEMENT_RANGE_MATCHES_INVLIST(i_s)) {\n            return invlist;\n        }\n\n        /* Here, no part of the range is in the list.  Must add it.  It will\n         * occupy 2 more slots */\n      splice_in_new_range:\n\n        invlist_extend(invlist, len + 2);\n        array = invlist_array(invlist);\n        /* Move the rest of the array down two slots. Don't include any\n         * trailing NUL */\n        Move(array + i_e + 1, array + i_e + 3, len - i_e - 1, UV);\n\n        /* Do the actual splice */\n        array[i_e+1] = start;\n        array[i_e+2] = end + 1;\n        invlist_set_len(invlist, len + 2, *(get_invlist_offset_addr(invlist)));\n        return invlist;\n    }\n\n    /* Here the new range crossed the boundaries of a pre-existing range.  The\n     * code above has adjusted things so that both ends are in ranges that are\n     * in the set.  This means everything in between must also be in the set.\n     * Just squash things together */\n    Move(array + i_e + 1, array + i_s + 1, len - i_e - 1, UV);\n    invlist_set_len(invlist,\n                    len - i_e + i_s,\n                    *(get_invlist_offset_addr(invlist)));\n\n    return invlist;\n}\n\nSV*\nPerl__setup_canned_invlist(pTHX_ const STRLEN size, const UV element0,\n                                 UV** other_elements_ptr)\n{\n    /* Create and return an inversion list whose contents are to be populated\n     * by the caller.  The caller gives the number of elements (in 'size') and\n     * the very first element ('element0').  This function will set\n     * '*other_elements_ptr' to an array of UVs, where the remaining elements\n     * are to be placed.\n     *\n     * Obviously there is some trust involved that the caller will properly\n     * fill in the other elements of the array.\n     *\n     * (The first element needs to be passed in, as the underlying code does\n     * things differently depending on whether it is zero or non-zero) */\n\n    SV* invlist = _new_invlist(size);\n    bool offset;\n\n    PERL_ARGS_ASSERT__SETUP_CANNED_INVLIST;\n\n    invlist = add_cp_to_invlist(invlist, element0);\n    offset = *get_invlist_offset_addr(invlist);\n\n    invlist_set_len(invlist, size, offset);\n    *other_elements_ptr = invlist_array(invlist) + 1;\n    return invlist;\n}\n\n#endif\n\nPERL_STATIC_INLINE SV*\nS_add_cp_to_invlist(pTHX_ SV* invlist, const UV cp) {\n    return _add_range_to_invlist(invlist, cp, cp);\n}\n\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl__invlist_invert(pTHX_ SV* const invlist)\n{\n    /* Complement the input inversion list.  This adds a 0 if the list didn't\n     * have a zero; removes it otherwise.  As described above, the data\n     * structure is set up so that this is very efficient */\n\n    PERL_ARGS_ASSERT__INVLIST_INVERT;\n\n    assert(! invlist_is_iterating(invlist));\n\n    /* The inverse of matching nothing is matching everything */\n    if (_invlist_len(invlist) == 0) {\n\t_append_range_to_invlist(invlist, 0, UV_MAX);\n\treturn;\n    }\n\n    *get_invlist_offset_addr(invlist) = ! *get_invlist_offset_addr(invlist);\n}\n\nSV*\nPerl_invlist_clone(pTHX_ SV* const invlist, SV* new_invlist)\n{\n    /* Return a new inversion list that is a copy of the input one, which is\n     * unchanged.  The new list will not be mortal even if the old one was. */\n\n    const STRLEN nominal_length = _invlist_len(invlist);\n    const STRLEN physical_length = SvCUR(invlist);\n    const bool offset = *(get_invlist_offset_addr(invlist));\n\n    PERL_ARGS_ASSERT_INVLIST_CLONE;\n\n    if (new_invlist == NULL) {\n        new_invlist = _new_invlist(nominal_length);\n    }\n    else {\n        sv_upgrade(new_invlist, SVt_INVLIST);\n        initialize_invlist_guts(new_invlist, nominal_length);\n    }\n\n    *(get_invlist_offset_addr(new_invlist)) = offset;\n    invlist_set_len(new_invlist, nominal_length, offset);\n    Copy(SvPVX(invlist), SvPVX(new_invlist), physical_length, char);\n\n    return new_invlist;\n}\n\n#endif\n\nPERL_STATIC_INLINE STRLEN*\nS_get_invlist_iter_addr(SV* invlist)\n{\n    /* Return the address of the UV that contains the current iteration\n     * position */\n\n    PERL_ARGS_ASSERT_GET_INVLIST_ITER_ADDR;\n\n    assert(is_invlist(invlist));\n\n    return &(((XINVLIST*) SvANY(invlist))->iterator);\n}\n\nPERL_STATIC_INLINE void\nS_invlist_iterinit(SV* invlist)\t/* Initialize iterator for invlist */\n{\n    PERL_ARGS_ASSERT_INVLIST_ITERINIT;\n\n    *get_invlist_iter_addr(invlist) = 0;\n}\n\nPERL_STATIC_INLINE void\nS_invlist_iterfinish(SV* invlist)\n{\n    /* Terminate iterator for invlist.  This is to catch development errors.\n     * Any iteration that is interrupted before completed should call this\n     * function.  Functions that add code points anywhere else but to the end\n     * of an inversion list assert that they are not in the middle of an\n     * iteration.  If they were, the addition would make the iteration\n     * problematical: if the iteration hadn't reached the place where things\n     * were being added, it would be ok */\n\n    PERL_ARGS_ASSERT_INVLIST_ITERFINISH;\n\n    *get_invlist_iter_addr(invlist) = (STRLEN) UV_MAX;\n}\n\nSTATIC bool\nS_invlist_iternext(SV* invlist, UV* start, UV* end)\n{\n    /* An C<invlist_iterinit> call on <invlist> must be used to set this up.\n     * This call sets in <*start> and <*end>, the next range in <invlist>.\n     * Returns <TRUE> if successful and the next call will return the next\n     * range; <FALSE> if was already at the end of the list.  If the latter,\n     * <*start> and <*end> are unchanged, and the next call to this function\n     * will start over at the beginning of the list */\n\n    STRLEN* pos = get_invlist_iter_addr(invlist);\n    UV len = _invlist_len(invlist);\n    UV *array;\n\n    PERL_ARGS_ASSERT_INVLIST_ITERNEXT;\n\n    if (*pos >= len) {\n\t*pos = (STRLEN) UV_MAX;\t/* Force iterinit() to be required next time */\n\treturn FALSE;\n    }\n\n    array = invlist_array(invlist);\n\n    *start = array[(*pos)++];\n\n    if (*pos >= len) {\n\t*end = UV_MAX;\n    }\n    else {\n\t*end = array[(*pos)++] - 1;\n    }\n\n    return TRUE;\n}\n\nPERL_STATIC_INLINE UV\nS_invlist_highest(SV* const invlist)\n{\n    /* Returns the highest code point that matches an inversion list.  This API\n     * has an ambiguity, as it returns 0 under either the highest is actually\n     * 0, or if the list is empty.  If this distinction matters to you, check\n     * for emptiness before calling this function */\n\n    UV len = _invlist_len(invlist);\n    UV *array;\n\n    PERL_ARGS_ASSERT_INVLIST_HIGHEST;\n\n    if (len == 0) {\n\treturn 0;\n    }\n\n    array = invlist_array(invlist);\n\n    /* The last element in the array in the inversion list always starts a\n     * range that goes to infinity.  That range may be for code points that are\n     * matched in the inversion list, or it may be for ones that aren't\n     * matched.  In the latter case, the highest code point in the set is one\n     * less than the beginning of this range; otherwise it is the final element\n     * of this range: infinity */\n    return (ELEMENT_RANGE_MATCHES_INVLIST(len - 1))\n           ? UV_MAX\n           : array[len - 1] - 1;\n}\n\nSTATIC SV *\nS_invlist_contents(pTHX_ SV* const invlist, const bool traditional_style)\n{\n    /* Get the contents of an inversion list into a string SV so that they can\n     * be printed out.  If 'traditional_style' is TRUE, it uses the format\n     * traditionally done for debug tracing; otherwise it uses a format\n     * suitable for just copying to the output, with blanks between ranges and\n     * a dash between range components */\n\n    UV start, end;\n    SV* output;\n    const char intra_range_delimiter = (traditional_style ? '\\t' : '-');\n    const char inter_range_delimiter = (traditional_style ? '\\n' : ' ');\n\n    if (traditional_style) {\n        output = newSVpvs(\"\\n\");\n    }\n    else {\n        output = newSVpvs(\"\");\n    }\n\n    PERL_ARGS_ASSERT_INVLIST_CONTENTS;\n\n    assert(! invlist_is_iterating(invlist));\n\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n\tif (end == UV_MAX) {\n\t    Perl_sv_catpvf(aTHX_ output, \"%04\" UVXf \"%cINFTY%c\",\n                                          start, intra_range_delimiter,\n                                                 inter_range_delimiter);\n\t}\n\telse if (end != start) {\n\t    Perl_sv_catpvf(aTHX_ output, \"%04\" UVXf \"%c%04\" UVXf \"%c\",\n\t\t                          start,\n                                                   intra_range_delimiter,\n                                                  end, inter_range_delimiter);\n\t}\n\telse {\n\t    Perl_sv_catpvf(aTHX_ output, \"%04\" UVXf \"%c\",\n                                          start, inter_range_delimiter);\n\t}\n    }\n\n    if (SvCUR(output) && ! traditional_style) {/* Get rid of trailing blank */\n        SvCUR_set(output, SvCUR(output) - 1);\n    }\n\n    return output;\n}\n\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl__invlist_dump(pTHX_ PerlIO *file, I32 level,\n                         const char * const indent, SV* const invlist)\n{\n    /* Designed to be called only by do_sv_dump().  Dumps out the ranges of the\n     * inversion list 'invlist' to 'file' at 'level'  Each line is prefixed by\n     * the string 'indent'.  The output looks like this:\n         [0] 0x000A .. 0x000D\n         [2] 0x0085\n         [4] 0x2028 .. 0x2029\n         [6] 0x3104 .. INFTY\n     * This means that the first range of code points matched by the list are\n     * 0xA through 0xD; the second range contains only the single code point\n     * 0x85, etc.  An inversion list is an array of UVs.  Two array elements\n     * are used to define each range (except if the final range extends to\n     * infinity, only a single element is needed).  The array index of the\n     * first element for the corresponding range is given in brackets. */\n\n    UV start, end;\n    STRLEN count = 0;\n\n    PERL_ARGS_ASSERT__INVLIST_DUMP;\n\n    if (invlist_is_iterating(invlist)) {\n        Perl_dump_indent(aTHX_ level, file,\n             \"%sCan't dump inversion list because is in middle of iterating\\n\",\n             indent);\n        return;\n    }\n\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n\tif (end == UV_MAX) {\n\t    Perl_dump_indent(aTHX_ level, file,\n                                       \"%s[%\" UVuf \"] 0x%04\" UVXf \" .. INFTY\\n\",\n                                   indent, (UV)count, start);\n\t}\n\telse if (end != start) {\n\t    Perl_dump_indent(aTHX_ level, file,\n                                    \"%s[%\" UVuf \"] 0x%04\" UVXf \" .. 0x%04\" UVXf \"\\n\",\n\t\t                indent, (UV)count, start,         end);\n\t}\n\telse {\n\t    Perl_dump_indent(aTHX_ level, file, \"%s[%\" UVuf \"] 0x%04\" UVXf \"\\n\",\n                                            indent, (UV)count, start);\n\t}\n        count += 2;\n    }\n}\n\n#endif\n\n#if defined(PERL_ARGS_ASSERT__INVLISTEQ) && !defined(PERL_IN_XSUB_RE)\nbool\nPerl__invlistEQ(pTHX_ SV* const a, SV* const b, const bool complement_b)\n{\n    /* Return a boolean as to if the two passed in inversion lists are\n     * identical.  The final argument, if TRUE, says to take the complement of\n     * the second inversion list before doing the comparison */\n\n    const UV len_a = _invlist_len(a);\n    UV len_b = _invlist_len(b);\n\n    const UV* array_a = NULL;\n    const UV* array_b = NULL;\n\n    PERL_ARGS_ASSERT__INVLISTEQ;\n\n    /* This code avoids accessing the arrays unless it knows the length is\n     * non-zero */\n\n    if (len_a == 0) {\n        if (len_b == 0) {\n            return ! complement_b;\n        }\n    }\n    else {\n        array_a = invlist_array(a);\n    }\n\n    if (len_b != 0) {\n        array_b = invlist_array(b);\n    }\n\n    /* If are to compare 'a' with the complement of b, set it\n     * up so are looking at b's complement. */\n    if (complement_b) {\n\n        /* The complement of nothing is everything, so <a> would have to have\n         * just one element, starting at zero (ending at infinity) */\n        if (len_b == 0) {\n            return (len_a == 1 && array_a[0] == 0);\n        }\n        if (array_b[0] == 0) {\n\n            /* Otherwise, to complement, we invert.  Here, the first element is\n             * 0, just remove it.  To do this, we just pretend the array starts\n             * one later */\n\n            array_b++;\n            len_b--;\n        }\n        else {\n\n            /* But if the first element is not zero, we pretend the list starts\n             * at the 0 that is always stored immediately before the array. */\n            array_b--;\n            len_b++;\n        }\n    }\n\n    return    len_a == len_b\n           && memEQ(array_a, array_b, len_a * sizeof(array_a[0]));\n\n}\n#endif\n\n/*\n * As best we can, determine the characters that can match the start of\n * the given EXACTF-ish node.  This is for use in creating ssc nodes, so there\n * can be false positive matches\n *\n * Returns the invlist as a new SV*; it is the caller's responsibility to\n * call SvREFCNT_dec() when done with it.\n */\nSTATIC SV*\nS__make_exactf_invlist(pTHX_ RExC_state_t *pRExC_state, regnode *node)\n{\n    dVAR;\n    const U8 * s = (U8*)STRING(node);\n    SSize_t bytelen = STR_LEN(node);\n    UV uc;\n    /* Start out big enough for 2 separate code points */\n    SV* invlist = _new_invlist(4);\n\n    PERL_ARGS_ASSERT__MAKE_EXACTF_INVLIST;\n\n    if (! UTF) {\n        uc = *s;\n\n        /* We punt and assume can match anything if the node begins\n         * with a multi-character fold.  Things are complicated.  For\n         * example, /ffi/i could match any of:\n         *  \"\\N{LATIN SMALL LIGATURE FFI}\"\n         *  \"\\N{LATIN SMALL LIGATURE FF}I\"\n         *  \"F\\N{LATIN SMALL LIGATURE FI}\"\n         *  plus several other things; and making sure we have all the\n         *  possibilities is hard. */\n        if (is_MULTI_CHAR_FOLD_latin1_safe(s, s + bytelen)) {\n            invlist = _add_range_to_invlist(invlist, 0, UV_MAX);\n        }\n        else {\n            /* Any Latin1 range character can potentially match any\n             * other depending on the locale, and in Turkic locales, U+130 and\n             * U+131 */\n            if (OP(node) == EXACTFL) {\n                _invlist_union(invlist, PL_Latin1, &invlist);\n                invlist = add_cp_to_invlist(invlist,\n                                                LATIN_SMALL_LETTER_DOTLESS_I);\n                invlist = add_cp_to_invlist(invlist,\n                                        LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE);\n            }\n            else {\n                /* But otherwise, it matches at least itself.  We can\n                 * quickly tell if it has a distinct fold, and if so,\n                 * it matches that as well */\n                invlist = add_cp_to_invlist(invlist, uc);\n                if (IS_IN_SOME_FOLD_L1(uc))\n                    invlist = add_cp_to_invlist(invlist, PL_fold_latin1[uc]);\n            }\n\n            /* Some characters match above-Latin1 ones under /i.  This\n             * is true of EXACTFL ones when the locale is UTF-8 */\n            if (HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(uc)\n                && (! isASCII(uc) || (OP(node) != EXACTFAA\n                                    && OP(node) != EXACTFAA_NO_TRIE)))\n            {\n                add_above_Latin1_folds(pRExC_state, (U8) uc, &invlist);\n            }\n        }\n    }\n    else {  /* Pattern is UTF-8 */\n        U8 folded[UTF8_MAX_FOLD_CHAR_EXPAND * UTF8_MAXBYTES_CASE + 1] = { '\\0' };\n        const U8* e = s + bytelen;\n        IV fc;\n\n        fc = uc = utf8_to_uvchr_buf(s, s + bytelen, NULL);\n\n        /* The only code points that aren't folded in a UTF EXACTFish\n         * node are are the problematic ones in EXACTFL nodes */\n        if (OP(node) == EXACTFL && is_PROBLEMATIC_LOCALE_FOLDEDS_START_cp(uc)) {\n            /* We need to check for the possibility that this EXACTFL\n             * node begins with a multi-char fold.  Therefore we fold\n             * the first few characters of it so that we can make that\n             * check */\n            U8 *d = folded;\n            int i;\n\n            fc = -1;\n            for (i = 0; i < UTF8_MAX_FOLD_CHAR_EXPAND && s < e; i++) {\n                if (isASCII(*s)) {\n                    *(d++) = (U8) toFOLD(*s);\n                    if (fc < 0) {       /* Save the first fold */\n                        fc = *(d-1);\n                    }\n                    s++;\n                }\n                else {\n                    STRLEN len;\n                    UV fold = toFOLD_utf8_safe(s, e, d, &len);\n                    if (fc < 0) {       /* Save the first fold */\n                        fc = fold;\n                    }\n                    d += len;\n                    s += UTF8SKIP(s);\n                }\n            }\n\n            /* And set up so the code below that looks in this folded\n             * buffer instead of the node's string */\n            e = d;\n            s = folded;\n        }\n\n        /* When we reach here 's' points to the fold of the first\n         * character(s) of the node; and 'e' points to far enough along\n         * the folded string to be just past any possible multi-char\n         * fold.\n         *\n         * Unlike the non-UTF-8 case, the macro for determining if a\n         * string is a multi-char fold requires all the characters to\n         * already be folded.  This is because of all the complications\n         * if not.  Note that they are folded anyway, except in EXACTFL\n         * nodes.  Like the non-UTF case above, we punt if the node\n         * begins with a multi-char fold  */\n\n        if (is_MULTI_CHAR_FOLD_utf8_safe(s, e)) {\n            invlist = _add_range_to_invlist(invlist, 0, UV_MAX);\n        }\n        else {  /* Single char fold */\n            unsigned int k;\n            unsigned int first_fold;\n            const unsigned int * remaining_folds;\n            Size_t folds_count;\n\n            /* It matches itself */\n            invlist = add_cp_to_invlist(invlist, fc);\n\n            /* ... plus all the things that fold to it, which are found in\n             * PL_utf8_foldclosures */\n            folds_count = _inverse_folds(fc, &first_fold,\n                                                &remaining_folds);\n            for (k = 0; k < folds_count; k++) {\n                UV c = (k == 0) ? first_fold : remaining_folds[k-1];\n\n                /* /aa doesn't allow folds between ASCII and non- */\n                if (   (OP(node) == EXACTFAA || OP(node) == EXACTFAA_NO_TRIE)\n                    && isASCII(c) != isASCII(fc))\n                {\n                    continue;\n                }\n\n                invlist = add_cp_to_invlist(invlist, c);\n            }\n\n            if (OP(node) == EXACTFL) {\n\n                /* If either [iI] are present in an EXACTFL node the above code\n                 * should have added its normal case pair, but under a Turkish\n                 * locale they could match instead the case pairs from it.  Add\n                 * those as potential matches as well */\n                if (isALPHA_FOLD_EQ(fc, 'I')) {\n                    invlist = add_cp_to_invlist(invlist,\n                                                LATIN_SMALL_LETTER_DOTLESS_I);\n                    invlist = add_cp_to_invlist(invlist,\n                                        LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE);\n                }\n                else if (fc == LATIN_SMALL_LETTER_DOTLESS_I) {\n                    invlist = add_cp_to_invlist(invlist, 'I');\n                }\n                else if (fc == LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE) {\n                    invlist = add_cp_to_invlist(invlist, 'i');\n                }\n            }\n        }\n    }\n\n    return invlist;\n}\n\n#undef HEADER_LENGTH\n#undef TO_INTERNAL_SIZE\n#undef FROM_INTERNAL_SIZE\n#undef INVLIST_VERSION_ID\n\n/* End of inversion list object */\n\nSTATIC void\nS_parse_lparen_question_flags(pTHX_ RExC_state_t *pRExC_state)\n{\n    /* This parses the flags that are in either the '(?foo)' or '(?foo:bar)'\n     * constructs, and updates RExC_flags with them.  On input, RExC_parse\n     * should point to the first flag; it is updated on output to point to the\n     * final ')' or ':'.  There needs to be at least one flag, or this will\n     * abort */\n\n    /* for (?g), (?gc), and (?o) warnings; warning\n       about (?c) will warn about (?g) -- japhy    */\n\n#define WASTED_O  0x01\n#define WASTED_G  0x02\n#define WASTED_C  0x04\n#define WASTED_GC (WASTED_G|WASTED_C)\n    I32 wastedflags = 0x00;\n    U32 posflags = 0, negflags = 0;\n    U32 *flagsp = &posflags;\n    char has_charset_modifier = '\\0';\n    regex_charset cs;\n    bool has_use_defaults = FALSE;\n    const char* const seqstart = RExC_parse - 1; /* Point to the '?' */\n    int x_mod_count = 0;\n\n    PERL_ARGS_ASSERT_PARSE_LPAREN_QUESTION_FLAGS;\n\n    /* '^' as an initial flag sets certain defaults */\n    if (UCHARAT(RExC_parse) == '^') {\n        RExC_parse++;\n        has_use_defaults = TRUE;\n        STD_PMMOD_FLAGS_CLEAR(&RExC_flags);\n        cs = (RExC_uni_semantics)\n             ? REGEX_UNICODE_CHARSET\n             : REGEX_DEPENDS_CHARSET;\n        set_regex_charset(&RExC_flags, cs);\n    }\n    else {\n        cs = get_regex_charset(RExC_flags);\n        if (   cs == REGEX_DEPENDS_CHARSET\n            && RExC_uni_semantics)\n        {\n            cs = REGEX_UNICODE_CHARSET;\n        }\n    }\n\n    while (RExC_parse < RExC_end) {\n        /* && strchr(\"iogcmsx\", *RExC_parse) */\n        /* (?g), (?gc) and (?o) are useless here\n           and must be globally applied -- japhy */\n        switch (*RExC_parse) {\n\n            /* Code for the imsxn flags */\n            CASE_STD_PMMOD_FLAGS_PARSE_SET(flagsp, x_mod_count);\n\n            case LOCALE_PAT_MOD:\n                if (has_charset_modifier) {\n                    goto excess_modifier;\n                }\n                else if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                cs = REGEX_LOCALE_CHARSET;\n                has_charset_modifier = LOCALE_PAT_MOD;\n                break;\n            case UNICODE_PAT_MOD:\n                if (has_charset_modifier) {\n                    goto excess_modifier;\n                }\n                else if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                cs = REGEX_UNICODE_CHARSET;\n                has_charset_modifier = UNICODE_PAT_MOD;\n                break;\n            case ASCII_RESTRICT_PAT_MOD:\n                if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                if (has_charset_modifier) {\n                    if (cs != REGEX_ASCII_RESTRICTED_CHARSET) {\n                        goto excess_modifier;\n                    }\n                    /* Doubled modifier implies more restricted */\n                    cs = REGEX_ASCII_MORE_RESTRICTED_CHARSET;\n                }\n                else {\n                    cs = REGEX_ASCII_RESTRICTED_CHARSET;\n                }\n                has_charset_modifier = ASCII_RESTRICT_PAT_MOD;\n                break;\n            case DEPENDS_PAT_MOD:\n                if (has_use_defaults) {\n                    goto fail_modifiers;\n                }\n                else if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                else if (has_charset_modifier) {\n                    goto excess_modifier;\n                }\n\n                /* The dual charset means unicode semantics if the\n                 * pattern (or target, not known until runtime) are\n                 * utf8, or something in the pattern indicates unicode\n                 * semantics */\n                cs = (RExC_uni_semantics)\n                     ? REGEX_UNICODE_CHARSET\n                     : REGEX_DEPENDS_CHARSET;\n                has_charset_modifier = DEPENDS_PAT_MOD;\n                break;\n              excess_modifier:\n                RExC_parse++;\n                if (has_charset_modifier == ASCII_RESTRICT_PAT_MOD) {\n                    vFAIL2(\"Regexp modifier \\\"%c\\\" may appear a maximum of twice\", ASCII_RESTRICT_PAT_MOD);\n                }\n                else if (has_charset_modifier == *(RExC_parse - 1)) {\n                    vFAIL2(\"Regexp modifier \\\"%c\\\" may not appear twice\",\n                                        *(RExC_parse - 1));\n                }\n                else {\n                    vFAIL3(\"Regexp modifiers \\\"%c\\\" and \\\"%c\\\" are mutually exclusive\", has_charset_modifier, *(RExC_parse - 1));\n                }\n                NOT_REACHED; /*NOTREACHED*/\n              neg_modifier:\n                RExC_parse++;\n                vFAIL2(\"Regexp modifier \\\"%c\\\" may not appear after the \\\"-\\\"\",\n                                    *(RExC_parse - 1));\n                NOT_REACHED; /*NOTREACHED*/\n            case ONCE_PAT_MOD: /* 'o' */\n            case GLOBAL_PAT_MOD: /* 'g' */\n                if (ckWARN(WARN_REGEXP)) {\n                    const I32 wflagbit = *RExC_parse == 'o'\n                                         ? WASTED_O\n                                         : WASTED_G;\n                    if (! (wastedflags & wflagbit) ) {\n                        wastedflags |= wflagbit;\n\t\t\t/* diag_listed_as: Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in m/%s/ */\n                        vWARN5(\n                            RExC_parse + 1,\n                            \"Useless (%s%c) - %suse /%c modifier\",\n                            flagsp == &negflags ? \"?-\" : \"?\",\n                            *RExC_parse,\n                            flagsp == &negflags ? \"don't \" : \"\",\n                            *RExC_parse\n                        );\n                    }\n                }\n                break;\n\n            case CONTINUE_PAT_MOD: /* 'c' */\n                if (ckWARN(WARN_REGEXP)) {\n                    if (! (wastedflags & WASTED_C) ) {\n                        wastedflags |= WASTED_GC;\n\t\t\t/* diag_listed_as: Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in m/%s/ */\n                        vWARN3(\n                            RExC_parse + 1,\n                            \"Useless (%sc) - %suse /gc modifier\",\n                            flagsp == &negflags ? \"?-\" : \"?\",\n                            flagsp == &negflags ? \"don't \" : \"\"\n                        );\n                    }\n                }\n                break;\n            case KEEPCOPY_PAT_MOD: /* 'p' */\n                if (flagsp == &negflags) {\n                    ckWARNreg(RExC_parse + 1,\"Useless use of (?-p)\");\n                } else {\n                    *flagsp |= RXf_PMf_KEEPCOPY;\n                }\n                break;\n            case '-':\n                /* A flag is a default iff it is following a minus, so\n                 * if there is a minus, it means will be trying to\n                 * re-specify a default which is an error */\n                if (has_use_defaults || flagsp == &negflags) {\n                    goto fail_modifiers;\n                }\n                flagsp = &negflags;\n                wastedflags = 0;  /* reset so (?g-c) warns twice */\n                x_mod_count = 0;\n                break;\n            case ':':\n            case ')':\n\n                if ((posflags & (RXf_PMf_EXTENDED|RXf_PMf_EXTENDED_MORE)) == RXf_PMf_EXTENDED) {\n                    negflags |= RXf_PMf_EXTENDED_MORE;\n                }\n                RExC_flags |= posflags;\n\n                if (negflags & RXf_PMf_EXTENDED) {\n                    negflags |= RXf_PMf_EXTENDED_MORE;\n                }\n                RExC_flags &= ~negflags;\n                set_regex_charset(&RExC_flags, cs);\n\n                return;\n            default:\n              fail_modifiers:\n                RExC_parse += SKIP_IF_CHAR(RExC_parse, RExC_end);\n\t\t/* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */\n                vFAIL2utf8f(\"Sequence (%\" UTF8f \"...) not recognized\",\n                      UTF8fARG(UTF, RExC_parse-seqstart, seqstart));\n                NOT_REACHED; /*NOTREACHED*/\n        }\n\n        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n    }\n\n    vFAIL(\"Sequence (?... not terminated\");\n}\n\n/*\n - reg - regular expression, i.e. main body or parenthesized thing\n *\n * Caller must absorb opening parenthesis.\n *\n * Combining parenthesis handling with the base level of regular expression\n * is a trifle forced, but the need to tie the tails of the branches to what\n * follows makes it hard to avoid.\n */\n#define REGTAIL(x,y,z) regtail((x),(y),(z),depth+1)\n#ifdef DEBUGGING\n#define REGTAIL_STUDY(x,y,z) regtail_study((x),(y),(z),depth+1)\n#else\n#define REGTAIL_STUDY(x,y,z) regtail((x),(y),(z),depth+1)\n#endif\n\nPERL_STATIC_INLINE regnode_offset\nS_handle_named_backref(pTHX_ RExC_state_t *pRExC_state,\n                             I32 *flagp,\n                             char * parse_start,\n                             char ch\n                      )\n{\n    regnode_offset ret;\n    char* name_start = RExC_parse;\n    U32 num = 0;\n    SV *sv_dat = reg_scan_name(pRExC_state, REG_RSN_RETURN_DATA);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_HANDLE_NAMED_BACKREF;\n\n    if (RExC_parse == name_start || *RExC_parse != ch) {\n        /* diag_listed_as: Sequence \\%s... not terminated in regex; marked by <-- HERE in m/%s/ */\n        vFAIL2(\"Sequence %.3s... not terminated\", parse_start);\n    }\n\n    if (sv_dat) {\n        num = add_data( pRExC_state, STR_WITH_LEN(\"S\"));\n        RExC_rxi->data->data[num]=(void*)sv_dat;\n        SvREFCNT_inc_simple_void_NN(sv_dat);\n    }\n    RExC_sawback = 1;\n    ret = reganode(pRExC_state,\n                   ((! FOLD)\n                     ? NREF\n                     : (ASCII_FOLD_RESTRICTED)\n                       ? NREFFA\n                       : (AT_LEAST_UNI_SEMANTICS)\n                         ? NREFFU\n                         : (LOC)\n                           ? NREFFL\n                           : NREFF),\n                    num);\n    *flagp |= HASWIDTH;\n\n    Set_Node_Offset(REGNODE_p(ret), parse_start+1);\n    Set_Node_Cur_Length(REGNODE_p(ret), parse_start);\n\n    nextchar(pRExC_state);\n    return ret;\n}\n\n/* On success, returns the offset at which any next node should be placed into\n * the regex engine program being compiled.\n *\n * Returns 0 otherwise, with *flagp set to indicate why:\n *  TRYAGAIN        at the end of (?) that only sets flags.\n *  RESTART_PARSE   if the parse needs to be restarted, or'd with\n *                  NEED_UTF8 if the pattern needs to be upgraded to UTF-8.\n *  Otherwise would only return 0 if regbranch() returns 0, which cannot\n *  happen.  */\nSTATIC regnode_offset\nS_reg(pTHX_ RExC_state_t *pRExC_state, I32 paren, I32 *flagp, U32 depth)\n    /* paren: Parenthesized? 0=top; 1,2=inside '(': changed to letter.\n     * 2 is like 1, but indicates that nextchar() has been called to advance\n     * RExC_parse beyond the '('.  Things like '(?' are indivisible tokens, and\n     * this flag alerts us to the need to check for that */\n{\n    regnode_offset ret = 0;    /* Will be the head of the group. */\n    regnode_offset br;\n    regnode_offset lastbr;\n    regnode_offset ender = 0;\n    I32 parno = 0;\n    I32 flags;\n    U32 oregflags = RExC_flags;\n    bool have_branch = 0;\n    bool is_open = 0;\n    I32 freeze_paren = 0;\n    I32 after_freeze = 0;\n    I32 num; /* numeric backreferences */\n    SV * max_open;  /* Max number of unclosed parens */\n\n    char * parse_start = RExC_parse; /* MJD */\n    char * const oregcomp_parse = RExC_parse;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REG;\n    DEBUG_PARSE(\"reg \");\n\n\n    max_open = get_sv(RE_COMPILE_RECURSION_LIMIT, GV_ADD);\n    assert(max_open);\n    if (!SvIOK(max_open)) {\n        sv_setiv(max_open, RE_COMPILE_RECURSION_INIT);\n    }\n    if (depth > 4 * (UV) SvIV(max_open)) { /* We increase depth by 4 for each\n                                              open paren */\n        vFAIL(\"Too many nested open parens\");\n    }\n\n    *flagp = 0;\t\t\t\t/* Tentatively. */\n\n    /* Having this true makes it feasible to have a lot fewer tests for the\n     * parse pointer being in scope.  For example, we can write\n     *      while(isFOO(*RExC_parse)) RExC_parse++;\n     * instead of\n     *      while(RExC_parse < RExC_end && isFOO(*RExC_parse)) RExC_parse++;\n     */\n    assert(*RExC_end == '\\0');\n\n    /* Make an OPEN node, if parenthesized. */\n    if (paren) {\n\n        /* Under /x, space and comments can be gobbled up between the '(' and\n         * here (if paren ==2).  The forms '(*VERB' and '(?...' disallow such\n         * intervening space, as the sequence is a token, and a token should be\n         * indivisible */\n        bool has_intervening_patws = (paren == 2)\n                                  && *(RExC_parse - 1) != '(';\n\n        if (RExC_parse >= RExC_end) {\n\t    vFAIL(\"Unmatched (\");\n        }\n\n        if (paren == 'r') {     /* Atomic script run */\n            paren = '>';\n            goto parse_rest;\n        }\n        else if ( *RExC_parse == '*') { /* (*VERB:ARG), (*construct:...) */\n\t    char *start_verb = RExC_parse + 1;\n\t    STRLEN verb_len;\n\t    char *start_arg = NULL;\n\t    unsigned char op = 0;\n            int arg_required = 0;\n            int internal_argval = -1; /* if >-1 we are not allowed an argument*/\n            bool has_upper = FALSE;\n\n            if (has_intervening_patws) {\n                RExC_parse++;   /* past the '*' */\n\n                /* For strict backwards compatibility, don't change the message\n                 * now that we also have lowercase operands */\n                if (isUPPER(*RExC_parse)) {\n                    vFAIL(\"In '(*VERB...)', the '(' and '*' must be adjacent\");\n                }\n                else {\n                    vFAIL(\"In '(*...)', the '(' and '*' must be adjacent\");\n                }\n            }\n\t    while (RExC_parse < RExC_end && *RExC_parse != ')' ) {\n\t        if ( *RExC_parse == ':' ) {\n\t            start_arg = RExC_parse + 1;\n\t            break;\n\t        }\n                else if (! UTF) {\n                    if (isUPPER(*RExC_parse)) {\n                        has_upper = TRUE;\n                    }\n                    RExC_parse++;\n                }\n                else {\n                    RExC_parse += UTF8SKIP(RExC_parse);\n                }\n\t    }\n\t    verb_len = RExC_parse - start_verb;\n\t    if ( start_arg ) {\n                if (RExC_parse >= RExC_end) {\n                    goto unterminated_verb_pattern;\n                }\n\n\t        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n\t        while ( RExC_parse < RExC_end && *RExC_parse != ')' ) {\n                    RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n                }\n\t        if ( RExC_parse >= RExC_end || *RExC_parse != ')' ) {\n                  unterminated_verb_pattern:\n                    if (has_upper) {\n                        vFAIL(\"Unterminated verb pattern argument\");\n                    }\n                    else {\n                        vFAIL(\"Unterminated '(*...' argument\");\n                    }\n                }\n\t    } else {\n\t        if ( RExC_parse >= RExC_end || *RExC_parse != ')' ) {\n                    if (has_upper) {\n                        vFAIL(\"Unterminated verb pattern\");\n                    }\n                    else {\n                        vFAIL(\"Unterminated '(*...' construct\");\n                    }\n                }\n\t    }\n\n            /* Here, we know that RExC_parse < RExC_end */\n\n\t    switch ( *start_verb ) {\n            case 'A':  /* (*ACCEPT) */\n                if ( memEQs(start_verb, verb_len,\"ACCEPT\") ) {\n\t\t    op = ACCEPT;\n\t\t    internal_argval = RExC_nestroot;\n\t\t}\n\t\tbreak;\n            case 'C':  /* (*COMMIT) */\n                if ( memEQs(start_verb, verb_len,\"COMMIT\") )\n                    op = COMMIT;\n                break;\n            case 'F':  /* (*FAIL) */\n                if ( verb_len==1 || memEQs(start_verb, verb_len,\"FAIL\") ) {\n\t\t    op = OPFAIL;\n\t\t}\n\t\tbreak;\n            case ':':  /* (*:NAME) */\n\t    case 'M':  /* (*MARK:NAME) */\n\t        if ( verb_len==0 || memEQs(start_verb, verb_len,\"MARK\") ) {\n                    op = MARKPOINT;\n                    arg_required = 1;\n                }\n                break;\n            case 'P':  /* (*PRUNE) */\n                if ( memEQs(start_verb, verb_len,\"PRUNE\") )\n                    op = PRUNE;\n                break;\n            case 'S':   /* (*SKIP) */\n                if ( memEQs(start_verb, verb_len,\"SKIP\") )\n                    op = SKIP;\n                break;\n            case 'T':  /* (*THEN) */\n                /* [19:06] <TimToady> :: is then */\n                if ( memEQs(start_verb, verb_len,\"THEN\") ) {\n                    op = CUTGROUP;\n                    RExC_seen |= REG_CUTGROUP_SEEN;\n                }\n                break;\n            case 'a':\n                if (   memEQs(start_verb, verb_len, \"asr\")\n                    || memEQs(start_verb, verb_len, \"atomic_script_run\"))\n                {\n                    paren = 'r';        /* Mnemonic: recursed run */\n                    goto script_run;\n                }\n                else if (memEQs(start_verb, verb_len, \"atomic\")) {\n                    paren = 't';    /* AtOMIC */\n                    goto alpha_assertions;\n                }\n                break;\n            case 'p':\n                if (   memEQs(start_verb, verb_len, \"plb\")\n                    || memEQs(start_verb, verb_len, \"positive_lookbehind\"))\n                {\n                    paren = 'b';\n                    goto lookbehind_alpha_assertions;\n                }\n                else if (   memEQs(start_verb, verb_len, \"pla\")\n                         || memEQs(start_verb, verb_len, \"positive_lookahead\"))\n                {\n                    paren = 'a';\n                    goto alpha_assertions;\n                }\n                break;\n            case 'n':\n                if (   memEQs(start_verb, verb_len, \"nlb\")\n                    || memEQs(start_verb, verb_len, \"negative_lookbehind\"))\n                {\n                    paren = 'B';\n                    goto lookbehind_alpha_assertions;\n                }\n                else if (   memEQs(start_verb, verb_len, \"nla\")\n                         || memEQs(start_verb, verb_len, \"negative_lookahead\"))\n                {\n                    paren = 'A';\n                    goto alpha_assertions;\n                }\n                break;\n            case 's':\n                if (   memEQs(start_verb, verb_len, \"sr\")\n                    || memEQs(start_verb, verb_len, \"script_run\"))\n                {\n                    regnode_offset atomic;\n\n                    paren = 's';\n\n                   script_run:\n\n                    /* This indicates Unicode rules. */\n                    REQUIRE_UNI_RULES(flagp, 0);\n\n                    if (! start_arg) {\n                        goto no_colon;\n                    }\n\n                    RExC_parse = start_arg;\n\n                    if (RExC_in_script_run) {\n\n                        /*  Nested script runs are treated as no-ops, because\n                         *  if the nested one fails, the outer one must as\n                         *  well.  It could fail sooner, and avoid (??{} with\n                         *  side effects, but that is explicitly documented as\n                         *  undefined behavior. */\n\n                        ret = 0;\n\n                        if (paren == 's') {\n                            paren = ':';\n                            goto parse_rest;\n                        }\n\n                        /* But, the atomic part of a nested atomic script run\n                         * isn't a no-op, but can be treated just like a '(?>'\n                         * */\n                        paren = '>';\n                        goto parse_rest;\n                    }\n\n                    /* By doing this here, we avoid extra warnings for nested\n                     * script runs */\n                    ckWARNexperimental(RExC_parse,\n                        WARN_EXPERIMENTAL__SCRIPT_RUN,\n                        \"The script_run feature is experimental\");\n\n                    if (paren == 's') {\n                        /* Here, we're starting a new regular script run */\n                        ret = reg_node(pRExC_state, SROPEN);\n                        RExC_in_script_run = 1;\n                        is_open = 1;\n                        goto parse_rest;\n                    }\n\n                    /* Here, we are starting an atomic script run.  This is\n                     * handled by recursing to deal with the atomic portion\n                     * separately, enclosed in SROPEN ... SRCLOSE nodes */\n\n                    ret = reg_node(pRExC_state, SROPEN);\n\n                    RExC_in_script_run = 1;\n\n                    atomic = reg(pRExC_state, 'r', &flags, depth);\n                    if (flags & (RESTART_PARSE|NEED_UTF8)) {\n                        *flagp = flags & (RESTART_PARSE|NEED_UTF8);\n                        return 0;\n                    }\n\n                    if (! REGTAIL(pRExC_state, ret, atomic)) {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n\n                    if (! REGTAIL(pRExC_state, atomic, reg_node(pRExC_state,\n                                                                SRCLOSE)))\n                    {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n\n                    RExC_in_script_run = 0;\n                    return ret;\n                }\n\n                break;\n\n            lookbehind_alpha_assertions:\n                RExC_seen |= REG_LOOKBEHIND_SEEN;\n                RExC_in_lookbehind++;\n                /*FALLTHROUGH*/\n\n            alpha_assertions:\n                ckWARNexperimental(RExC_parse,\n                        WARN_EXPERIMENTAL__ALPHA_ASSERTIONS,\n                        \"The alpha_assertions feature is experimental\");\n\n                RExC_seen_zerolen++;\n\n                if (! start_arg) {\n                    goto no_colon;\n                }\n\n                /* An empty negative lookahead assertion simply is failure */\n                if (paren == 'A' && RExC_parse == start_arg) {\n                    ret=reganode(pRExC_state, OPFAIL, 0);\n                    nextchar(pRExC_state);\n                    return ret;\n\t        }\n\n                RExC_parse = start_arg;\n                goto parse_rest;\n\n              no_colon:\n                vFAIL2utf8f(\n                \"'(*%\" UTF8f \"' requires a terminating ':'\",\n                UTF8fARG(UTF, verb_len, start_verb));\n\t\tNOT_REACHED; /*NOTREACHED*/\n\n\t    } /* End of switch */\n\t    if ( ! op ) {\n\t        RExC_parse += UTF\n                              ? UTF8_SAFE_SKIP(RExC_parse, RExC_end)\n                              : 1;\n                if (has_upper || verb_len == 0) {\n                    vFAIL2utf8f(\n                    \"Unknown verb pattern '%\" UTF8f \"'\",\n                    UTF8fARG(UTF, verb_len, start_verb));\n                }\n                else {\n                    vFAIL2utf8f(\n                    \"Unknown '(*...)' construct '%\" UTF8f \"'\",\n                    UTF8fARG(UTF, verb_len, start_verb));\n                }\n\t    }\n            if ( RExC_parse == start_arg ) {\n                start_arg = NULL;\n            }\n            if ( arg_required && !start_arg ) {\n                vFAIL3(\"Verb pattern '%.*s' has a mandatory argument\",\n                    verb_len, start_verb);\n            }\n            if (internal_argval == -1) {\n                ret = reganode(pRExC_state, op, 0);\n            } else {\n                ret = reg2Lanode(pRExC_state, op, 0, internal_argval);\n            }\n            RExC_seen |= REG_VERBARG_SEEN;\n            if (start_arg) {\n                SV *sv = newSVpvn( start_arg,\n                                    RExC_parse - start_arg);\n                ARG(REGNODE_p(ret)) = add_data( pRExC_state,\n                                        STR_WITH_LEN(\"S\"));\n                RExC_rxi->data->data[ARG(REGNODE_p(ret))]=(void*)sv;\n                FLAGS(REGNODE_p(ret)) = 1;\n            } else {\n                FLAGS(REGNODE_p(ret)) = 0;\n            }\n            if ( internal_argval != -1 )\n                ARG2L_SET(REGNODE_p(ret), internal_argval);\n\t    nextchar(pRExC_state);\n\t    return ret;\n        }\n        else if (*RExC_parse == '?') { /* (?...) */\n\t    bool is_logical = 0;\n\t    const char * const seqstart = RExC_parse;\n            const char * endptr;\n            if (has_intervening_patws) {\n                RExC_parse++;\n                vFAIL(\"In '(?...)', the '(' and '?' must be adjacent\");\n            }\n\n\t    RExC_parse++;           /* past the '?' */\n            paren = *RExC_parse;    /* might be a trailing NUL, if not\n                                       well-formed */\n            RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n            if (RExC_parse > RExC_end) {\n                paren = '\\0';\n            }\n\t    ret = 0;\t\t\t/* For look-ahead/behind. */\n\t    switch (paren) {\n\n\t    case 'P':\t/* (?P...) variants for those used to PCRE/Python */\n\t        paren = *RExC_parse;\n\t\tif ( paren == '<') {    /* (?P<...>) named capture */\n                    RExC_parse++;\n                    if (RExC_parse >= RExC_end) {\n                        vFAIL(\"Sequence (?P<... not terminated\");\n                    }\n\t\t    goto named_capture;\n                }\n                else if (paren == '>') {   /* (?P>name) named recursion */\n                    RExC_parse++;\n                    if (RExC_parse >= RExC_end) {\n                        vFAIL(\"Sequence (?P>... not terminated\");\n                    }\n                    goto named_recursion;\n                }\n                else if (paren == '=') {   /* (?P=...)  named backref */\n                    RExC_parse++;\n                    return handle_named_backref(pRExC_state, flagp,\n                                                parse_start, ')');\n                }\n                RExC_parse += SKIP_IF_CHAR(RExC_parse, RExC_end);\n                /* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */\n\t\tvFAIL3(\"Sequence (%.*s...) not recognized\",\n                                RExC_parse-seqstart, seqstart);\n\t\tNOT_REACHED; /*NOTREACHED*/\n            case '<':           /* (?<...) */\n\t\tif (*RExC_parse == '!')\n\t\t    paren = ',';\n\t\telse if (*RExC_parse != '=')\n              named_capture:\n\t\t{               /* (?<...>) */\n\t\t    char *name_start;\n\t\t    SV *svname;\n\t\t    paren= '>';\n                /* FALLTHROUGH */\n            case '\\'':          /* (?'...') */\n                    name_start = RExC_parse;\n                    svname = reg_scan_name(pRExC_state, REG_RSN_RETURN_NAME);\n\t\t    if (   RExC_parse == name_start\n                        || RExC_parse >= RExC_end\n                        || *RExC_parse != paren)\n                    {\n\t\t        vFAIL2(\"Sequence (?%c... not terminated\",\n\t\t            paren=='>' ? '<' : paren);\n                    }\n\t\t    {\n\t\t\tHE *he_str;\n\t\t\tSV *sv_dat = NULL;\n                        if (!svname) /* shouldn't happen */\n                            Perl_croak(aTHX_\n                                \"panic: reg_scan_name returned NULL\");\n                        if (!RExC_paren_names) {\n                            RExC_paren_names= newHV();\n                            sv_2mortal(MUTABLE_SV(RExC_paren_names));\n#ifdef DEBUGGING\n                            RExC_paren_name_list= newAV();\n                            sv_2mortal(MUTABLE_SV(RExC_paren_name_list));\n#endif\n                        }\n                        he_str = hv_fetch_ent( RExC_paren_names, svname, 1, 0 );\n                        if ( he_str )\n                            sv_dat = HeVAL(he_str);\n                        if ( ! sv_dat ) {\n                            /* croak baby croak */\n                            Perl_croak(aTHX_\n                                \"panic: paren_name hash element allocation failed\");\n                        } else if ( SvPOK(sv_dat) ) {\n                            /* (?|...) can mean we have dupes so scan to check\n                               its already been stored. Maybe a flag indicating\n                               we are inside such a construct would be useful,\n                               but the arrays are likely to be quite small, so\n                               for now we punt -- dmq */\n                            IV count = SvIV(sv_dat);\n                            I32 *pv = (I32*)SvPVX(sv_dat);\n                            IV i;\n                            for ( i = 0 ; i < count ; i++ ) {\n                                if ( pv[i] == RExC_npar ) {\n                                    count = 0;\n                                    break;\n                                }\n                            }\n                            if ( count ) {\n                                pv = (I32*)SvGROW(sv_dat,\n                                                SvCUR(sv_dat) + sizeof(I32)+1);\n                                SvCUR_set(sv_dat, SvCUR(sv_dat) + sizeof(I32));\n                                pv[count] = RExC_npar;\n                                SvIV_set(sv_dat, SvIVX(sv_dat) + 1);\n                            }\n                        } else {\n                            (void)SvUPGRADE(sv_dat, SVt_PVNV);\n                            sv_setpvn(sv_dat, (char *)&(RExC_npar),\n                                                                sizeof(I32));\n                            SvIOK_on(sv_dat);\n                            SvIV_set(sv_dat, 1);\n                        }\n#ifdef DEBUGGING\n                        /* Yes this does cause a memory leak in debugging Perls\n                         * */\n                        if (!av_store(RExC_paren_name_list,\n                                      RExC_npar, SvREFCNT_inc_NN(svname)))\n                            SvREFCNT_dec_NN(svname);\n#endif\n\n                        /*sv_dump(sv_dat);*/\n                    }\n                    nextchar(pRExC_state);\n\t\t    paren = 1;\n\t\t    goto capturing_parens;\n\t\t}\n\n                RExC_seen |= REG_LOOKBEHIND_SEEN;\n\t\tRExC_in_lookbehind++;\n\t\tRExC_parse++;\n                if (RExC_parse >= RExC_end) {\n                    vFAIL(\"Sequence (?... not terminated\");\n                }\n\n                /* FALLTHROUGH */\n\t    case '=':           /* (?=...) */\n\t\tRExC_seen_zerolen++;\n                break;\n\t    case '!':           /* (?!...) */\n\t\tRExC_seen_zerolen++;\n\t\t/* check if we're really just a \"FAIL\" assertion */\n                skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                        FALSE /* Don't force to /x */ );\n\t        if (*RExC_parse == ')') {\n                    ret=reganode(pRExC_state, OPFAIL, 0);\n\t            nextchar(pRExC_state);\n\t            return ret;\n\t        }\n\t        break;\n\t    case '|':           /* (?|...) */\n\t        /* branch reset, behave like a (?:...) except that\n\t           buffers in alternations share the same numbers */\n\t        paren = ':';\n\t        after_freeze = freeze_paren = RExC_npar;\n\n                /* XXX This construct currently requires an extra pass.\n                 * Investigation would be required to see if that could be\n                 * changed */\n                REQUIRE_PARENS_PASS;\n\t        break;\n\t    case ':':           /* (?:...) */\n\t    case '>':           /* (?>...) */\n\t\tbreak;\n\t    case '$':           /* (?$...) */\n\t    case '@':           /* (?@...) */\n\t\tvFAIL2(\"Sequence (?%c...) not implemented\", (int)paren);\n\t\tbreak;\n\t    case '0' :           /* (?0) */\n\t    case 'R' :           /* (?R) */\n                if (RExC_parse == RExC_end || *RExC_parse != ')')\n\t\t    FAIL(\"Sequence (?R) not terminated\");\n                num = 0;\n                RExC_seen |= REG_RECURSE_SEEN;\n\n                /* XXX These constructs currently require an extra pass.\n                 * It probably could be changed */\n                REQUIRE_PARENS_PASS;\n\n\t\t*flagp |= POSTPONED;\n                goto gen_recurse_regop;\n\t\t/*notreached*/\n            /* named and numeric backreferences */\n            case '&':            /* (?&NAME) */\n                parse_start = RExC_parse - 1;\n              named_recursion:\n                {\n                    SV *sv_dat = reg_scan_name(pRExC_state,\n                                               REG_RSN_RETURN_DATA);\n                   num = sv_dat ? *((I32 *)SvPVX(sv_dat)) : 0;\n                }\n                if (RExC_parse >= RExC_end || *RExC_parse != ')')\n                    vFAIL(\"Sequence (?&... not terminated\");\n                goto gen_recurse_regop;\n                /* NOTREACHED */\n            case '+':\n                if (! inRANGE(RExC_parse[0], '1', '9')) {\n                    RExC_parse++;\n                    vFAIL(\"Illegal pattern\");\n                }\n                goto parse_recursion;\n                /* NOTREACHED*/\n            case '-': /* (?-1) */\n                if (! inRANGE(RExC_parse[0], '1', '9')) {\n                    RExC_parse--; /* rewind to let it be handled later */\n                    goto parse_flags;\n                }\n                /* FALLTHROUGH */\n            case '1': case '2': case '3': case '4': /* (?1) */\n\t    case '5': case '6': case '7': case '8': case '9':\n\t        RExC_parse = (char *) seqstart + 1;  /* Point to the digit */\n              parse_recursion:\n                {\n                    bool is_neg = FALSE;\n                    UV unum;\n                    parse_start = RExC_parse - 1; /* MJD */\n                    if (*RExC_parse == '-') {\n                        RExC_parse++;\n                        is_neg = TRUE;\n                    }\n                    endptr = RExC_end;\n                    if (grok_atoUV(RExC_parse, &unum, &endptr)\n                        && unum <= I32_MAX\n                    ) {\n                        num = (I32)unum;\n                        RExC_parse = (char*)endptr;\n                    } else\n                        num = I32_MAX;\n                    if (is_neg) {\n                        /* Some limit for num? */\n                        num = -num;\n                    }\n                }\n\t        if (*RExC_parse!=')')\n\t            vFAIL(\"Expecting close bracket\");\n\n              gen_recurse_regop:\n                if ( paren == '-' ) {\n                    /*\n                    Diagram of capture buffer numbering.\n                    Top line is the normal capture buffer numbers\n                    Bottom line is the negative indexing as from\n                    the X (the (?-2))\n\n                    +   1 2    3 4 5 X          6 7\n                       /(a(x)y)(a(b(c(?-2)d)e)f)(g(h))/\n                    -   5 4    3 2 1 X          x x\n\n                    */\n                    num = RExC_npar + num;\n                    if (num < 1)  {\n\n                        /* It might be a forward reference; we can't fail until\n                         * we know, by completing the parse to get all the\n                         * groups, and then reparsing */\n                        if (ALL_PARENS_COUNTED)  {\n                            RExC_parse++;\n                            vFAIL(\"Reference to nonexistent group\");\n                        }\n                        else {\n                            REQUIRE_PARENS_PASS;\n                        }\n                    }\n                } else if ( paren == '+' ) {\n                    num = RExC_npar + num - 1;\n                }\n                /* We keep track how many GOSUB items we have produced.\n                   To start off the ARG2L() of the GOSUB holds its \"id\",\n                   which is used later in conjunction with RExC_recurse\n                   to calculate the offset we need to jump for the GOSUB,\n                   which it will store in the final representation.\n                   We have to defer the actual calculation until much later\n                   as the regop may move.\n                 */\n\n                ret = reg2Lanode(pRExC_state, GOSUB, num, RExC_recurse_count);\n                if (num >= RExC_npar) {\n\n                    /* It might be a forward reference; we can't fail until we\n                     * know, by completing the parse to get all the groups, and\n                     * then reparsing */\n                    if (ALL_PARENS_COUNTED)  {\n                        if (num >= RExC_total_parens) {\n                            RExC_parse++;\n                            vFAIL(\"Reference to nonexistent group\");\n                        }\n                    }\n                    else {\n                        REQUIRE_PARENS_PASS;\n                    }\n                }\n                RExC_recurse_count++;\n                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                    \"%*s%*s Recurse #%\" UVuf \" to %\" IVdf \"\\n\",\n                            22, \"|    |\", (int)(depth * 2 + 1), \"\",\n                            (UV)ARG(REGNODE_p(ret)),\n                            (IV)ARG2L(REGNODE_p(ret))));\n                RExC_seen |= REG_RECURSE_SEEN;\n\n                Set_Node_Length(REGNODE_p(ret),\n                                1 + regarglen[OP(REGNODE_p(ret))]); /* MJD */\n\t\tSet_Node_Offset(REGNODE_p(ret), parse_start); /* MJD */\n\n                *flagp |= POSTPONED;\n                assert(*RExC_parse == ')');\n                nextchar(pRExC_state);\n                return ret;\n\n            /* NOTREACHED */\n\n\t    case '?':           /* (??...) */\n\t\tis_logical = 1;\n\t\tif (*RExC_parse != '{') {\n                    RExC_parse += SKIP_IF_CHAR(RExC_parse, RExC_end);\n                    /* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */\n                    vFAIL2utf8f(\n                        \"Sequence (%\" UTF8f \"...) not recognized\",\n                        UTF8fARG(UTF, RExC_parse-seqstart, seqstart));\n\t\t    NOT_REACHED; /*NOTREACHED*/\n\t\t}\n\t\t*flagp |= POSTPONED;\n\t\tparen = '{';\n                RExC_parse++;\n\t\t/* FALLTHROUGH */\n\t    case '{':           /* (?{...}) */\n\t    {\n\t\tU32 n = 0;\n\t\tstruct reg_code_block *cb;\n                OP * o;\n\n\t\tRExC_seen_zerolen++;\n\n\t\tif (   !pRExC_state->code_blocks\n\t\t    || pRExC_state->code_index\n                                        >= pRExC_state->code_blocks->count\n\t\t    || pRExC_state->code_blocks->cb[pRExC_state->code_index].start\n\t\t\t!= (STRLEN)((RExC_parse -3 - (is_logical ? 1 : 0))\n\t\t\t    - RExC_start)\n\t\t) {\n\t\t    if (RExC_pm_flags & PMf_USE_RE_EVAL)\n\t\t\tFAIL(\"panic: Sequence (?{...}): no code block found\\n\");\n\t\t    FAIL(\"Eval-group not allowed at runtime, use re 'eval'\");\n\t\t}\n\t\t/* this is a pre-compiled code block (?{...}) */\n\t\tcb = &pRExC_state->code_blocks->cb[pRExC_state->code_index];\n\t\tRExC_parse = RExC_start + cb->end;\n\t\to = cb->block;\n                if (cb->src_regex) {\n                    n = add_data(pRExC_state, STR_WITH_LEN(\"rl\"));\n                    RExC_rxi->data->data[n] =\n                        (void*)SvREFCNT_inc((SV*)cb->src_regex);\n                    RExC_rxi->data->data[n+1] = (void*)o;\n                }\n                else {\n                    n = add_data(pRExC_state,\n                            (RExC_pm_flags & PMf_HAS_CV) ? \"L\" : \"l\", 1);\n                    RExC_rxi->data->data[n] = (void*)o;\n                }\n\t\tpRExC_state->code_index++;\n\t\tnextchar(pRExC_state);\n\n\t\tif (is_logical) {\n                    regnode_offset eval;\n\t\t    ret = reg_node(pRExC_state, LOGICAL);\n\n                    eval = reg2Lanode(pRExC_state, EVAL,\n                                       n,\n\n                                       /* for later propagation into (??{})\n                                        * return value */\n                                       RExC_flags & RXf_PMf_COMPILETIME\n                                      );\n                    FLAGS(REGNODE_p(ret)) = 2;\n                    if (! REGTAIL(pRExC_state, ret, eval)) {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n                    /* deal with the length of this later - MJD */\n\t\t    return ret;\n\t\t}\n\t\tret = reg2Lanode(pRExC_state, EVAL, n, 0);\n\t\tSet_Node_Length(REGNODE_p(ret), RExC_parse - parse_start + 1);\n\t\tSet_Node_Offset(REGNODE_p(ret), parse_start);\n\t\treturn ret;\n\t    }\n\t    case '(':           /* (?(?{...})...) and (?(?=...)...) */\n\t    {\n\t        int is_define= 0;\n                const int DEFINE_len = sizeof(\"DEFINE\") - 1;\n\t\tif (    RExC_parse < RExC_end - 1\n                    && (   (       RExC_parse[0] == '?'        /* (?(?...)) */\n                            && (   RExC_parse[1] == '='\n                                || RExC_parse[1] == '!'\n                                || RExC_parse[1] == '<'\n                                || RExC_parse[1] == '{'))\n\t\t        || (       RExC_parse[0] == '*'        /* (?(*...)) */\n                            && (   memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"pla:\")\n                                || memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"plb:\")\n                                || memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"nla:\")\n                                || memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"nlb:\")\n                                || memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"positive_lookahead:\")\n                                || memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"positive_lookbehind:\")\n                                || memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"negative_lookahead:\")\n                                || memBEGINs(RExC_parse + 1,\n                                         (Size_t) (RExC_end - (RExC_parse + 1)),\n                                         \"negative_lookbehind:\"))))\n                ) { /* Lookahead or eval. */\n                    I32 flag;\n                    regnode_offset tail;\n\n                    ret = reg_node(pRExC_state, LOGICAL);\n                    FLAGS(REGNODE_p(ret)) = 1;\n\n                    tail = reg(pRExC_state, 1, &flag, depth+1);\n                    RETURN_FAIL_ON_RESTART(flag, flagp);\n                    if (! REGTAIL(pRExC_state, ret, tail)) {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n                    goto insert_if;\n                }\n\t\telse if (   RExC_parse[0] == '<'     /* (?(<NAME>)...) */\n\t\t         || RExC_parse[0] == '\\'' ) /* (?('NAME')...) */\n\t        {\n\t            char ch = RExC_parse[0] == '<' ? '>' : '\\'';\n\t            char *name_start= RExC_parse++;\n\t            U32 num = 0;\n\t            SV *sv_dat=reg_scan_name(pRExC_state, REG_RSN_RETURN_DATA);\n\t            if (   RExC_parse == name_start\n                        || RExC_parse >= RExC_end\n                        || *RExC_parse != ch)\n                    {\n                        vFAIL2(\"Sequence (?(%c... not terminated\",\n                            (ch == '>' ? '<' : ch));\n                    }\n                    RExC_parse++;\n                    if (sv_dat) {\n                        num = add_data( pRExC_state, STR_WITH_LEN(\"S\"));\n                        RExC_rxi->data->data[num]=(void*)sv_dat;\n                        SvREFCNT_inc_simple_void_NN(sv_dat);\n                    }\n                    ret = reganode(pRExC_state, NGROUPP, num);\n                    goto insert_if_check_paren;\n\t\t}\n\t\telse if (memBEGINs(RExC_parse,\n                                   (STRLEN) (RExC_end - RExC_parse),\n                                   \"DEFINE\"))\n                {\n\t\t    ret = reganode(pRExC_state, DEFINEP, 0);\n\t\t    RExC_parse += DEFINE_len;\n\t\t    is_define = 1;\n\t\t    goto insert_if_check_paren;\n\t\t}\n\t\telse if (RExC_parse[0] == 'R') {\n\t\t    RExC_parse++;\n                    /* parno == 0 => /(?(R)YES|NO)/  \"in any form of recursion OR eval\"\n                     * parno == 1 => /(?(R0)YES|NO)/ \"in GOSUB (?0) / (?R)\"\n                     * parno == 2 => /(?(R1)YES|NO)/ \"in GOSUB (?1) (parno-1)\"\n                     */\n\t\t    parno = 0;\n                    if (RExC_parse[0] == '0') {\n                        parno = 1;\n                        RExC_parse++;\n                    }\n                    else if (inRANGE(RExC_parse[0], '1', '9')) {\n                        UV uv;\n                        endptr = RExC_end;\n                        if (grok_atoUV(RExC_parse, &uv, &endptr)\n                            && uv <= I32_MAX\n                        ) {\n                            parno = (I32)uv + 1;\n                            RExC_parse = (char*)endptr;\n                        }\n                        /* else \"Switch condition not recognized\" below */\n\t\t    } else if (RExC_parse[0] == '&') {\n\t\t        SV *sv_dat;\n\t\t        RExC_parse++;\n\t\t        sv_dat = reg_scan_name(pRExC_state,\n                                               REG_RSN_RETURN_DATA);\n                        if (sv_dat)\n                            parno = 1 + *((I32 *)SvPVX(sv_dat));\n\t\t    }\n\t\t    ret = reganode(pRExC_state, INSUBP, parno);\n\t\t    goto insert_if_check_paren;\n\t\t}\n                else if (inRANGE(RExC_parse[0], '1', '9')) {\n                    /* (?(1)...) */\n\t\t    char c;\n                    UV uv;\n                    endptr = RExC_end;\n                    if (grok_atoUV(RExC_parse, &uv, &endptr)\n                        && uv <= I32_MAX\n                    ) {\n                        parno = (I32)uv;\n                        RExC_parse = (char*)endptr;\n                    }\n                    else {\n                        vFAIL(\"panic: grok_atoUV returned FALSE\");\n                    }\n                    ret = reganode(pRExC_state, GROUPP, parno);\n\n                 insert_if_check_paren:\n\t\t    if (UCHARAT(RExC_parse) != ')') {\n                        RExC_parse += UTF\n                                      ? UTF8_SAFE_SKIP(RExC_parse, RExC_end)\n                                      : 1;\n\t\t\tvFAIL(\"Switch condition not recognized\");\n\t\t    }\n\t\t    nextchar(pRExC_state);\n\t\t  insert_if:\n                    if (! REGTAIL(pRExC_state, ret, reganode(pRExC_state,\n                                                             IFTHEN, 0)))\n                    {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n                    br = regbranch(pRExC_state, &flags, 1, depth+1);\n\t\t    if (br == 0) {\n                        RETURN_FAIL_ON_RESTART(flags,flagp);\n                        FAIL2(\"panic: regbranch returned failure, flags=%#\" UVxf,\n                              (UV) flags);\n                    } else\n                    if (! REGTAIL(pRExC_state, br, reganode(pRExC_state,\n                                                             LONGJMP, 0)))\n                    {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n\t\t    c = UCHARAT(RExC_parse);\n                    nextchar(pRExC_state);\n\t\t    if (flags&HASWIDTH)\n\t\t\t*flagp |= HASWIDTH;\n\t\t    if (c == '|') {\n\t\t        if (is_define)\n\t\t            vFAIL(\"(?(DEFINE)....) does not allow branches\");\n\n                        /* Fake one for optimizer.  */\n                        lastbr = reganode(pRExC_state, IFTHEN, 0);\n\n                        if (!regbranch(pRExC_state, &flags, 1, depth+1)) {\n                            RETURN_FAIL_ON_RESTART(flags, flagp);\n                            FAIL2(\"panic: regbranch returned failure, flags=%#\" UVxf,\n                                  (UV) flags);\n                        }\n                        if (! REGTAIL(pRExC_state, ret, lastbr)) {\n                            REQUIRE_BRANCHJ(flagp, 0);\n                        }\n\t\t \tif (flags&HASWIDTH)\n\t\t\t    *flagp |= HASWIDTH;\n                        c = UCHARAT(RExC_parse);\n                        nextchar(pRExC_state);\n\t\t    }\n\t\t    else\n\t\t\tlastbr = 0;\n                    if (c != ')') {\n                        if (RExC_parse >= RExC_end)\n                            vFAIL(\"Switch (?(condition)... not terminated\");\n                        else\n                            vFAIL(\"Switch (?(condition)... contains too many branches\");\n                    }\n\t\t    ender = reg_node(pRExC_state, TAIL);\n                    if (! REGTAIL(pRExC_state, br, ender)) {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n\t\t    if (lastbr) {\n                        if (! REGTAIL(pRExC_state, lastbr, ender)) {\n                            REQUIRE_BRANCHJ(flagp, 0);\n                        }\n                        if (! REGTAIL(pRExC_state,\n                                      REGNODE_OFFSET(\n                                                 NEXTOPER(\n                                                 NEXTOPER(REGNODE_p(lastbr)))),\n                                      ender))\n                        {\n                            REQUIRE_BRANCHJ(flagp, 0);\n                        }\n\t\t    }\n\t\t    else\n                        if (! REGTAIL(pRExC_state, ret, ender)) {\n                            REQUIRE_BRANCHJ(flagp, 0);\n                        }\n#if 0  /* Removing this doesn't cause failures in the test suite -- khw */\n                    RExC_size++; /* XXX WHY do we need this?!!\n                                    For large programs it seems to be required\n                                    but I can't figure out why. -- dmq*/\n#endif\n\t\t    return ret;\n\t\t}\n                RExC_parse += UTF\n                              ? UTF8_SAFE_SKIP(RExC_parse, RExC_end)\n                              : 1;\n                vFAIL(\"Unknown switch condition (?(...))\");\n\t    }\n\t    case '[':           /* (?[ ... ]) */\n                return handle_regex_sets(pRExC_state, NULL, flagp, depth+1,\n                                         oregcomp_parse);\n            case 0: /* A NUL */\n\t\tRExC_parse--; /* for vFAIL to print correctly */\n                vFAIL(\"Sequence (? incomplete\");\n                break;\n\n            case ')':\n                if (RExC_strict) {  /* [perl #132851] */\n                    ckWARNreg(RExC_parse, \"Empty (?) without any modifiers\");\n                }\n                /* FALLTHROUGH */\n\t    default: /* e.g., (?i) */\n\t        RExC_parse = (char *) seqstart + 1;\n              parse_flags:\n\t\tparse_lparen_question_flags(pRExC_state);\n                if (UCHARAT(RExC_parse) != ':') {\n                    if (RExC_parse < RExC_end)\n                        nextchar(pRExC_state);\n                    *flagp = TRYAGAIN;\n                    return 0;\n                }\n                paren = ':';\n                nextchar(pRExC_state);\n                ret = 0;\n                goto parse_rest;\n            } /* end switch */\n\t}\n\telse {\n            if (*RExC_parse == '{') {\n                ckWARNregdep(RExC_parse + 1,\n                            \"Unescaped left brace in regex is \"\n                            \"deprecated here (and will be fatal \"\n                            \"in Perl 5.32), passed through\");\n            }\n            /* Not bothering to indent here, as the above 'else' is temporary\n             * */\n        if (!(RExC_flags & RXf_PMf_NOCAPTURE)) {   /* (...) */\n\t  capturing_parens:\n\t    parno = RExC_npar;\n\t    RExC_npar++;\n            if (! ALL_PARENS_COUNTED) {\n                /* If we are in our first pass through (and maybe only pass),\n                 * we  need to allocate memory for the capturing parentheses\n                 * data structures.\n                 */\n\n                if (!RExC_parens_buf_size) {\n                    /* first guess at number of parens we might encounter */\n                    RExC_parens_buf_size = 10;\n\n                    /* setup RExC_open_parens, which holds the address of each\n                     * OPEN tag, and to make things simpler for the 0 index the\n                     * start of the program - this is used later for offsets */\n                    Newxz(RExC_open_parens, RExC_parens_buf_size,\n                            regnode_offset);\n                    RExC_open_parens[0] = 1;    /* +1 for REG_MAGIC */\n\n                    /* setup RExC_close_parens, which holds the address of each\n                     * CLOSE tag, and to make things simpler for the 0 index\n                     * the end of the program - this is used later for offsets\n                     * */\n                    Newxz(RExC_close_parens, RExC_parens_buf_size,\n                            regnode_offset);\n                    /* we dont know where end op starts yet, so we dont need to\n                     * set RExC_close_parens[0] like we do RExC_open_parens[0]\n                     * above */\n                }\n                else if (RExC_npar > RExC_parens_buf_size) {\n                    I32 old_size = RExC_parens_buf_size;\n\n                    RExC_parens_buf_size *= 2;\n\n                    Renew(RExC_open_parens, RExC_parens_buf_size,\n                            regnode_offset);\n                    Zero(RExC_open_parens + old_size,\n                            RExC_parens_buf_size - old_size, regnode_offset);\n\n                    Renew(RExC_close_parens, RExC_parens_buf_size,\n                            regnode_offset);\n                    Zero(RExC_close_parens + old_size,\n                            RExC_parens_buf_size - old_size, regnode_offset);\n                }\n            }\n\n\t    ret = reganode(pRExC_state, OPEN, parno);\n            if (!RExC_nestroot)\n                RExC_nestroot = parno;\n            if (RExC_open_parens && !RExC_open_parens[parno])\n            {\n                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                    \"%*s%*s Setting open paren #%\" IVdf \" to %d\\n\",\n                    22, \"|    |\", (int)(depth * 2 + 1), \"\",\n                    (IV)parno, ret));\n                RExC_open_parens[parno]= ret;\n            }\n\n            Set_Node_Length(REGNODE_p(ret), 1); /* MJD */\n            Set_Node_Offset(REGNODE_p(ret), RExC_parse); /* MJD */\n\t    is_open = 1;\n\t} else {\n            /* with RXf_PMf_NOCAPTURE treat (...) as (?:...) */\n            paren = ':';\n\t    ret = 0;\n\t}\n        }\n    }\n    else                        /* ! paren */\n\tret = 0;\n\n   parse_rest:\n    /* Pick up the branches, linking them together. */\n    parse_start = RExC_parse;   /* MJD */\n    br = regbranch(pRExC_state, &flags, 1, depth+1);\n\n    /*     branch_len = (paren != 0); */\n\n    if (br == 0) {\n        RETURN_FAIL_ON_RESTART(flags, flagp);\n        FAIL2(\"panic: regbranch returned failure, flags=%#\" UVxf, (UV) flags);\n    }\n    if (*RExC_parse == '|') {\n\tif (RExC_use_BRANCHJ) {\n\t    reginsert(pRExC_state, BRANCHJ, br, depth+1);\n\t}\n\telse {                  /* MJD */\n\t    reginsert(pRExC_state, BRANCH, br, depth+1);\n            Set_Node_Length(REGNODE_p(br), paren != 0);\n            Set_Node_Offset_To_R(br, parse_start-RExC_start);\n        }\n\thave_branch = 1;\n    }\n    else if (paren == ':') {\n\t*flagp |= flags&SIMPLE;\n    }\n    if (is_open) {\t\t\t\t/* Starts with OPEN. */\n        if (! REGTAIL(pRExC_state, ret, br)) {  /* OPEN -> first. */\n            REQUIRE_BRANCHJ(flagp, 0);\n        }\n    }\n    else if (paren != '?')\t\t/* Not Conditional */\n\tret = br;\n    *flagp |= flags & (SPSTART | HASWIDTH | POSTPONED);\n    lastbr = br;\n    while (*RExC_parse == '|') {\n\tif (RExC_use_BRANCHJ) {\n            bool shut_gcc_up;\n\n\t    ender = reganode(pRExC_state, LONGJMP, 0);\n\n            /* Append to the previous. */\n            shut_gcc_up = REGTAIL(pRExC_state,\n                         REGNODE_OFFSET(NEXTOPER(NEXTOPER(REGNODE_p(lastbr)))),\n                         ender);\n            PERL_UNUSED_VAR(shut_gcc_up);\n\t}\n\tnextchar(pRExC_state);\n\tif (freeze_paren) {\n\t    if (RExC_npar > after_freeze)\n\t        after_freeze = RExC_npar;\n            RExC_npar = freeze_paren;\n        }\n        br = regbranch(pRExC_state, &flags, 0, depth+1);\n\n\tif (br == 0) {\n            RETURN_FAIL_ON_RESTART(flags, flagp);\n            FAIL2(\"panic: regbranch returned failure, flags=%#\" UVxf, (UV) flags);\n        }\n        if (!  REGTAIL(pRExC_state, lastbr, br)) {  /* BRANCH -> BRANCH. */\n            REQUIRE_BRANCHJ(flagp, 0);\n        }\n\tlastbr = br;\n\t*flagp |= flags & (SPSTART | HASWIDTH | POSTPONED);\n    }\n\n    if (have_branch || paren != ':') {\n        regnode * br;\n\n\t/* Make a closing node, and hook it on the end. */\n\tswitch (paren) {\n\tcase ':':\n\t    ender = reg_node(pRExC_state, TAIL);\n\t    break;\n\tcase 1: case 2:\n\t    ender = reganode(pRExC_state, CLOSE, parno);\n            if ( RExC_close_parens ) {\n                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                        \"%*s%*s Setting close paren #%\" IVdf \" to %d\\n\",\n                        22, \"|    |\", (int)(depth * 2 + 1), \"\",\n                        (IV)parno, ender));\n                RExC_close_parens[parno]= ender;\n\t        if (RExC_nestroot == parno)\n\t            RExC_nestroot = 0;\n\t    }\n            Set_Node_Offset(REGNODE_p(ender), RExC_parse+1); /* MJD */\n            Set_Node_Length(REGNODE_p(ender), 1); /* MJD */\n\t    break;\n\tcase 's':\n\t    ender = reg_node(pRExC_state, SRCLOSE);\n            RExC_in_script_run = 0;\n\t    break;\n\tcase '<':\n        case 'a':\n        case 'A':\n        case 'b':\n        case 'B':\n\tcase ',':\n\tcase '=':\n\tcase '!':\n\t    *flagp &= ~HASWIDTH;\n\t    /* FALLTHROUGH */\n        case 't':   /* aTomic */\n\tcase '>':\n\t    ender = reg_node(pRExC_state, SUCCEED);\n\t    break;\n\tcase 0:\n\t    ender = reg_node(pRExC_state, END);\n            assert(!RExC_end_op); /* there can only be one! */\n            RExC_end_op = REGNODE_p(ender);\n            if (RExC_close_parens) {\n                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                    \"%*s%*s Setting close paren #0 (END) to %d\\n\",\n                    22, \"|    |\", (int)(depth * 2 + 1), \"\",\n                    ender));\n\n                RExC_close_parens[0]= ender;\n            }\n\t    break;\n\t}\n        DEBUG_PARSE_r({\n            DEBUG_PARSE_MSG(\"lsbr\");\n            regprop(RExC_rx, RExC_mysv1, REGNODE_p(lastbr), NULL, pRExC_state);\n            regprop(RExC_rx, RExC_mysv2, REGNODE_p(ender), NULL, pRExC_state);\n            Perl_re_printf( aTHX_  \"~ tying lastbr %s (%\" IVdf \") to ender %s (%\" IVdf \") offset %\" IVdf \"\\n\",\n                          SvPV_nolen_const(RExC_mysv1),\n                          (IV)lastbr,\n                          SvPV_nolen_const(RExC_mysv2),\n                          (IV)ender,\n                          (IV)(ender - lastbr)\n            );\n        });\n        if (! REGTAIL(pRExC_state, lastbr, ender)) {\n            REQUIRE_BRANCHJ(flagp, 0);\n        }\n\n\tif (have_branch) {\n            char is_nothing= 1;\n\t    if (depth==1)\n                RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;\n\n\t    /* Hook the tails of the branches to the closing node. */\n\t    for (br = REGNODE_p(ret); br; br = regnext(br)) {\n\t\tconst U8 op = PL_regkind[OP(br)];\n\t\tif (op == BRANCH) {\n                    if (! REGTAIL_STUDY(pRExC_state,\n                                        REGNODE_OFFSET(NEXTOPER(br)),\n                                        ender))\n                    {\n                        REQUIRE_BRANCHJ(flagp, 0);\n                    }\n                    if ( OP(NEXTOPER(br)) != NOTHING\n                         || regnext(NEXTOPER(br)) != REGNODE_p(ender))\n                        is_nothing= 0;\n\t\t}\n\t\telse if (op == BRANCHJ) {\n                    bool shut_gcc_up = REGTAIL_STUDY(pRExC_state,\n                                        REGNODE_OFFSET(NEXTOPER(NEXTOPER(br))),\n                                        ender);\n                    PERL_UNUSED_VAR(shut_gcc_up);\n                    /* for now we always disable this optimisation * /\n                    if ( OP(NEXTOPER(NEXTOPER(br))) != NOTHING\n                         || regnext(NEXTOPER(NEXTOPER(br))) != REGNODE_p(ender))\n                    */\n                        is_nothing= 0;\n\t\t}\n\t    }\n            if (is_nothing) {\n                regnode * ret_as_regnode = REGNODE_p(ret);\n                br= PL_regkind[OP(ret_as_regnode)] != BRANCH\n                               ? regnext(ret_as_regnode)\n                               : ret_as_regnode;\n                DEBUG_PARSE_r({\n                    DEBUG_PARSE_MSG(\"NADA\");\n                    regprop(RExC_rx, RExC_mysv1, ret_as_regnode,\n                                     NULL, pRExC_state);\n                    regprop(RExC_rx, RExC_mysv2, REGNODE_p(ender),\n                                     NULL, pRExC_state);\n                    Perl_re_printf( aTHX_  \"~ converting ret %s (%\" IVdf \") to ender %s (%\" IVdf \") offset %\" IVdf \"\\n\",\n                                  SvPV_nolen_const(RExC_mysv1),\n                                  (IV)REG_NODE_NUM(ret_as_regnode),\n                                  SvPV_nolen_const(RExC_mysv2),\n                                  (IV)ender,\n                                  (IV)(ender - ret)\n                    );\n                });\n                OP(br)= NOTHING;\n                if (OP(REGNODE_p(ender)) == TAIL) {\n                    NEXT_OFF(br)= 0;\n                    RExC_emit= REGNODE_OFFSET(br) + 1;\n                } else {\n                    regnode *opt;\n                    for ( opt= br + 1; opt < REGNODE_p(ender) ; opt++ )\n                        OP(opt)= OPTIMIZED;\n                    NEXT_OFF(br)= REGNODE_p(ender) - br;\n                }\n            }\n\t}\n    }\n\n    {\n        const char *p;\n         /* Even/odd or x=don't care: 010101x10x */\n        static const char parens[] = \"=!aA<,>Bbt\";\n         /* flag below is set to 0 up through 'A'; 1 for larger */\n\n\tif (paren && (p = strchr(parens, paren))) {\n\t    U8 node = ((p - parens) % 2) ? UNLESSM : IFMATCH;\n\t    int flag = (p - parens) > 3;\n\n\t    if (paren == '>' || paren == 't') {\n\t\tnode = SUSPEND, flag = 0;\n            }\n\n\t    reginsert(pRExC_state, node, ret, depth+1);\n            Set_Node_Cur_Length(REGNODE_p(ret), parse_start);\n\t    Set_Node_Offset(REGNODE_p(ret), parse_start + 1);\n\t    FLAGS(REGNODE_p(ret)) = flag;\n            if (! REGTAIL_STUDY(pRExC_state, ret, reg_node(pRExC_state, TAIL)))\n            {\n                REQUIRE_BRANCHJ(flagp, 0);\n            }\n\t}\n    }\n\n    /* Check for proper termination. */\n    if (paren) {\n        /* restore original flags, but keep (?p) and, if we've encountered\n         * something in the parse that changes /d rules into /u, keep the /u */\n\tRExC_flags = oregflags | (RExC_flags & RXf_PMf_KEEPCOPY);\n        if (DEPENDS_SEMANTICS && RExC_uni_semantics) {\n            set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);\n        }\n\tif (RExC_parse >= RExC_end || UCHARAT(RExC_parse) != ')') {\n\t    RExC_parse = oregcomp_parse;\n\t    vFAIL(\"Unmatched (\");\n\t}\n\tnextchar(pRExC_state);\n    }\n    else if (!paren && RExC_parse < RExC_end) {\n\tif (*RExC_parse == ')') {\n\t    RExC_parse++;\n\t    vFAIL(\"Unmatched )\");\n\t}\n\telse\n\t    FAIL(\"Junk on end of regexp\");\t/* \"Can't happen\". */\n\tNOT_REACHED; /* NOTREACHED */\n    }\n\n    if (RExC_in_lookbehind) {\n\tRExC_in_lookbehind--;\n    }\n    if (after_freeze > RExC_npar)\n        RExC_npar = after_freeze;\n    return(ret);\n}\n\n/*\n - regbranch - one alternative of an | operator\n *\n * Implements the concatenation operator.\n *\n * On success, returns the offset at which any next node should be placed into\n * the regex engine program being compiled.\n *\n * Returns 0 otherwise, setting flagp to RESTART_PARSE if the parse needs\n * to be restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to\n * UTF-8\n */\nSTATIC regnode_offset\nS_regbranch(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, I32 first, U32 depth)\n{\n    regnode_offset ret;\n    regnode_offset chain = 0;\n    regnode_offset latest;\n    I32 flags = 0, c = 0;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGBRANCH;\n\n    DEBUG_PARSE(\"brnc\");\n\n    if (first)\n\tret = 0;\n    else {\n\tif (RExC_use_BRANCHJ)\n\t    ret = reganode(pRExC_state, BRANCHJ, 0);\n\telse {\n\t    ret = reg_node(pRExC_state, BRANCH);\n            Set_Node_Length(REGNODE_p(ret), 1);\n        }\n    }\n\n    *flagp = WORST;\t\t\t/* Tentatively. */\n\n    skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                            FALSE /* Don't force to /x */ );\n    while (RExC_parse < RExC_end && *RExC_parse != '|' && *RExC_parse != ')') {\n\tflags &= ~TRYAGAIN;\n        latest = regpiece(pRExC_state, &flags, depth+1);\n\tif (latest == 0) {\n\t    if (flags & TRYAGAIN)\n\t\tcontinue;\n            RETURN_FAIL_ON_RESTART(flags, flagp);\n            FAIL2(\"panic: regpiece returned failure, flags=%#\" UVxf, (UV) flags);\n\t}\n\telse if (ret == 0)\n            ret = latest;\n\t*flagp |= flags&(HASWIDTH|POSTPONED);\n\tif (chain == 0) \t/* First piece. */\n\t    *flagp |= flags&SPSTART;\n\telse {\n\t    /* FIXME adding one for every branch after the first is probably\n\t     * excessive now we have TRIE support. (hv) */\n\t    MARK_NAUGHTY(1);\n            if (! REGTAIL(pRExC_state, chain, latest)) {\n                /* XXX We could just redo this branch, but figuring out what\n                 * bookkeeping needs to be reset is a pain, and it's likely\n                 * that other branches that goto END will also be too large */\n                REQUIRE_BRANCHJ(flagp, 0);\n            }\n\t}\n\tchain = latest;\n\tc++;\n    }\n    if (chain == 0) {\t/* Loop ran zero times. */\n\tchain = reg_node(pRExC_state, NOTHING);\n\tif (ret == 0)\n\t    ret = chain;\n    }\n    if (c == 1) {\n\t*flagp |= flags&SIMPLE;\n    }\n\n    return ret;\n}\n\n/*\n - regpiece - something followed by possible quantifier * + ? {n,m}\n *\n * Note that the branching code sequences used for ? and the general cases\n * of * and + are somewhat optimized:  they use the same NOTHING node as\n * both the endmarker for their branch list and the body of the last branch.\n * It might seem that this node could be dispensed with entirely, but the\n * endmarker role is not redundant.\n *\n * On success, returns the offset at which any next node should be placed into\n * the regex engine program being compiled.\n *\n * Returns 0 otherwise, with *flagp set to indicate why:\n *  TRYAGAIN        if regatom() returns 0 with TRYAGAIN.\n *  RESTART_PARSE   if the parse needs to be restarted, or'd with\n *                  NEED_UTF8 if the pattern needs to be upgraded to UTF-8.\n */\nSTATIC regnode_offset\nS_regpiece(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)\n{\n    regnode_offset ret;\n    char op;\n    char *next;\n    I32 flags;\n    const char * const origparse = RExC_parse;\n    I32 min;\n    I32 max = REG_INFTY;\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    char *parse_start;\n#endif\n    const char *maxpos = NULL;\n    UV uv;\n\n    /* Save the original in case we change the emitted regop to a FAIL. */\n    const regnode_offset orig_emit = RExC_emit;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGPIECE;\n\n    DEBUG_PARSE(\"piec\");\n\n    ret = regatom(pRExC_state, &flags, depth+1);\n    if (ret == 0) {\n        RETURN_FAIL_ON_RESTART_OR_FLAGS(flags, flagp, TRYAGAIN);\n        FAIL2(\"panic: regatom returned failure, flags=%#\" UVxf, (UV) flags);\n    }\n\n    op = *RExC_parse;\n\n    if (op == '{' && regcurly(RExC_parse)) {\n\tmaxpos = NULL;\n#ifdef RE_TRACK_PATTERN_OFFSETS\n        parse_start = RExC_parse; /* MJD */\n#endif\n\tnext = RExC_parse + 1;\n\twhile (isDIGIT(*next) || *next == ',') {\n\t    if (*next == ',') {\n\t\tif (maxpos)\n\t\t    break;\n\t\telse\n\t\t    maxpos = next;\n\t    }\n\t    next++;\n\t}\n\tif (*next == '}') {\t\t/* got one */\n            const char* endptr;\n\t    if (!maxpos)\n\t\tmaxpos = next;\n\t    RExC_parse++;\n            if (isDIGIT(*RExC_parse)) {\n                endptr = RExC_end;\n                if (!grok_atoUV(RExC_parse, &uv, &endptr))\n                    vFAIL(\"Invalid quantifier in {,}\");\n                if (uv >= REG_INFTY)\n                    vFAIL2(\"Quantifier in {,} bigger than %d\", REG_INFTY - 1);\n                min = (I32)uv;\n            } else {\n                min = 0;\n            }\n\t    if (*maxpos == ',')\n\t\tmaxpos++;\n\t    else\n\t\tmaxpos = RExC_parse;\n            if (isDIGIT(*maxpos)) {\n                endptr = RExC_end;\n                if (!grok_atoUV(maxpos, &uv, &endptr))\n                    vFAIL(\"Invalid quantifier in {,}\");\n                if (uv >= REG_INFTY)\n                    vFAIL2(\"Quantifier in {,} bigger than %d\", REG_INFTY - 1);\n                max = (I32)uv;\n            } else {\n\t\tmax = REG_INFTY;\t\t/* meaning \"infinity\" */\n            }\n\t    RExC_parse = next;\n\t    nextchar(pRExC_state);\n            if (max < min) {    /* If can't match, warn and optimize to fail\n                                   unconditionally */\n                reginsert(pRExC_state, OPFAIL, orig_emit, depth+1);\n                ckWARNreg(RExC_parse, \"Quantifier {n,m} with n > m can't match\");\n                NEXT_OFF(REGNODE_p(orig_emit)) =\n                                    regarglen[OPFAIL] + NODE_STEP_REGNODE;\n                return ret;\n            }\n            else if (min == max && *RExC_parse == '?')\n            {\n                ckWARN2reg(RExC_parse + 1,\n                           \"Useless use of greediness modifier '%c'\",\n                           *RExC_parse);\n            }\n\n\t  do_curly:\n\t    if ((flags&SIMPLE)) {\n                if (min == 0 && max == REG_INFTY) {\n                    reginsert(pRExC_state, STAR, ret, depth+1);\n                    MARK_NAUGHTY(4);\n                    RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;\n                    goto nest_check;\n                }\n                if (min == 1 && max == REG_INFTY) {\n                    reginsert(pRExC_state, PLUS, ret, depth+1);\n                    MARK_NAUGHTY(3);\n                    RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;\n                    goto nest_check;\n                }\n                MARK_NAUGHTY_EXP(2, 2);\n\t\treginsert(pRExC_state, CURLY, ret, depth+1);\n                Set_Node_Offset(REGNODE_p(ret), parse_start+1); /* MJD */\n                Set_Node_Cur_Length(REGNODE_p(ret), parse_start);\n\t    }\n\t    else {\n\t\tconst regnode_offset w = reg_node(pRExC_state, WHILEM);\n\n\t\tFLAGS(REGNODE_p(w)) = 0;\n                if (!  REGTAIL(pRExC_state, ret, w)) {\n                    REQUIRE_BRANCHJ(flagp, 0);\n                }\n\t\tif (RExC_use_BRANCHJ) {\n\t\t    reginsert(pRExC_state, LONGJMP, ret, depth+1);\n\t\t    reginsert(pRExC_state, NOTHING, ret, depth+1);\n\t\t    NEXT_OFF(REGNODE_p(ret)) = 3;\t/* Go over LONGJMP. */\n\t\t}\n\t\treginsert(pRExC_state, CURLYX, ret, depth+1);\n                                /* MJD hk */\n                Set_Node_Offset(REGNODE_p(ret), parse_start+1);\n                Set_Node_Length(REGNODE_p(ret),\n                                op == '{' ? (RExC_parse - parse_start) : 1);\n\n\t\tif (RExC_use_BRANCHJ)\n                    NEXT_OFF(REGNODE_p(ret)) = 3;   /* Go over NOTHING to\n                                                       LONGJMP. */\n                if (! REGTAIL(pRExC_state, ret, reg_node(pRExC_state,\n                                                          NOTHING)))\n                {\n                    REQUIRE_BRANCHJ(flagp, 0);\n                }\n                RExC_whilem_seen++;\n                MARK_NAUGHTY_EXP(1, 4);     /* compound interest */\n\t    }\n\t    FLAGS(REGNODE_p(ret)) = 0;\n\n\t    if (min > 0)\n\t\t*flagp = WORST;\n\t    if (max > 0)\n\t\t*flagp |= HASWIDTH;\n            ARG1_SET(REGNODE_p(ret), (U16)min);\n            ARG2_SET(REGNODE_p(ret), (U16)max);\n            if (max == REG_INFTY)\n                RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;\n\n\t    goto nest_check;\n\t}\n    }\n\n    if (!ISMULT1(op)) {\n\t*flagp = flags;\n\treturn(ret);\n    }\n\n#if 0\t\t\t\t/* Now runtime fix should be reliable. */\n\n    /* if this is reinstated, don't forget to put this back into perldiag:\n\n\t    =item Regexp *+ operand could be empty at {#} in regex m/%s/\n\n\t   (F) The part of the regexp subject to either the * or + quantifier\n           could match an empty string. The {#} shows in the regular\n           expression about where the problem was discovered.\n\n    */\n\n    if (!(flags&HASWIDTH) && op != '?')\n      vFAIL(\"Regexp *+ operand could be empty\");\n#endif\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    parse_start = RExC_parse;\n#endif\n    nextchar(pRExC_state);\n\n    *flagp = (op != '+') ? (WORST|SPSTART|HASWIDTH) : (WORST|HASWIDTH);\n\n    if (op == '*') {\n\tmin = 0;\n\tgoto do_curly;\n    }\n    else if (op == '+') {\n\tmin = 1;\n\tgoto do_curly;\n    }\n    else if (op == '?') {\n\tmin = 0; max = 1;\n\tgoto do_curly;\n    }\n  nest_check:\n    if (!(flags&(HASWIDTH|POSTPONED)) && max > REG_INFTY/3) {\n\tckWARN2reg(RExC_parse,\n\t\t   \"%\" UTF8f \" matches null string many times\",\n\t\t   UTF8fARG(UTF, (RExC_parse >= origparse\n                                 ? RExC_parse - origparse\n                                 : 0),\n\t\t   origparse));\n    }\n\n    if (*RExC_parse == '?') {\n\tnextchar(pRExC_state);\n\treginsert(pRExC_state, MINMOD, ret, depth+1);\n        if (! REGTAIL(pRExC_state, ret, ret + NODE_STEP_REGNODE)) {\n            REQUIRE_BRANCHJ(flagp, 0);\n        }\n    }\n    else if (*RExC_parse == '+') {\n        regnode_offset ender;\n        nextchar(pRExC_state);\n        ender = reg_node(pRExC_state, SUCCEED);\n        if (! REGTAIL(pRExC_state, ret, ender)) {\n            REQUIRE_BRANCHJ(flagp, 0);\n        }\n        reginsert(pRExC_state, SUSPEND, ret, depth+1);\n        ender = reg_node(pRExC_state, TAIL);\n        if (! REGTAIL(pRExC_state, ret, ender)) {\n            REQUIRE_BRANCHJ(flagp, 0);\n        }\n    }\n\n    if (ISMULT2(RExC_parse)) {\n\tRExC_parse++;\n\tvFAIL(\"Nested quantifiers\");\n    }\n\n    return(ret);\n}\n\nSTATIC bool\nS_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state,\n                regnode_offset * node_p,\n                UV * code_point_p,\n                int * cp_count,\n                I32 * flagp,\n                const bool strict,\n                const U32 depth\n    )\n{\n /* This routine teases apart the various meanings of \\N and returns\n  * accordingly.  The input parameters constrain which meaning(s) is/are valid\n  * in the current context.\n  *\n  * Exactly one of <node_p> and <code_point_p> must be non-NULL.\n  *\n  * If <code_point_p> is not NULL, the context is expecting the result to be a\n  * single code point.  If this \\N instance turns out to a single code point,\n  * the function returns TRUE and sets *code_point_p to that code point.\n  *\n  * If <node_p> is not NULL, the context is expecting the result to be one of\n  * the things representable by a regnode.  If this \\N instance turns out to be\n  * one such, the function generates the regnode, returns TRUE and sets *node_p\n  * to point to the offset of that regnode into the regex engine program being\n  * compiled.\n  *\n  * If this instance of \\N isn't legal in any context, this function will\n  * generate a fatal error and not return.\n  *\n  * On input, RExC_parse should point to the first char following the \\N at the\n  * time of the call.  On successful return, RExC_parse will have been updated\n  * to point to just after the sequence identified by this routine.  Also\n  * *flagp has been updated as needed.\n  *\n  * When there is some problem with the current context and this \\N instance,\n  * the function returns FALSE, without advancing RExC_parse, nor setting\n  * *node_p, nor *code_point_p, nor *flagp.\n  *\n  * If <cp_count> is not NULL, the caller wants to know the length (in code\n  * points) that this \\N sequence matches.  This is set, and the input is\n  * parsed for errors, even if the function returns FALSE, as detailed below.\n  *\n  * There are 6 possibilities here, as detailed in the next 6 paragraphs.\n  *\n  * Probably the most common case is for the \\N to specify a single code point.\n  * *cp_count will be set to 1, and *code_point_p will be set to that code\n  * point.\n  *\n  * Another possibility is for the input to be an empty \\N{}.  This is no\n  * longer accepted, and will generate a fatal error.\n  *\n  * Another possibility is for a custom charnames handler to be in effect which\n  * translates the input name to an empty string.  *cp_count will be set to 0.\n  * *node_p will be set to a generated NOTHING node.\n  *\n  * Still another possibility is for the \\N to mean [^\\n]. *cp_count will be\n  * set to 0. *node_p will be set to a generated REG_ANY node.\n  *\n  * The fifth possibility is that \\N resolves to a sequence of more than one\n  * code points.  *cp_count will be set to the number of code points in the\n  * sequence. *node_p will be set to a generated node returned by this\n  * function calling S_reg().\n  *\n  * The final possibility is that it is premature to be calling this function;\n  * the parse needs to be restarted.  This can happen when this changes from\n  * /d to /u rules, or when the pattern needs to be upgraded to UTF-8.  The\n  * latter occurs only when the fifth possibility would otherwise be in\n  * effect, and is because one of those code points requires the pattern to be\n  * recompiled as UTF-8.  The function returns FALSE, and sets the\n  * RESTART_PARSE and NEED_UTF8 flags in *flagp, as appropriate.  When this\n  * happens, the caller needs to desist from continuing parsing, and return\n  * this information to its caller.  This is not set for when there is only one\n  * code point, as this can be called as part of an ANYOF node, and they can\n  * store above-Latin1 code points without the pattern having to be in UTF-8.\n  *\n  * For non-single-quoted regexes, the tokenizer has resolved character and\n  * sequence names inside \\N{...} into their Unicode values, normalizing the\n  * result into what we should see here: '\\N{U+c1.c2...}', where c1... are the\n  * hex-represented code points in the sequence.  This is done there because\n  * the names can vary based on what charnames pragma is in scope at the time,\n  * so we need a way to take a snapshot of what they resolve to at the time of\n  * the original parse. [perl #56444].\n  *\n  * That parsing is skipped for single-quoted regexes, so here we may get\n  * '\\N{NAME}', which is parsed now.  If the single-quoted regex is something\n  * like '\\N{U+41}', that code point is Unicode, and has to be translated into\n  * the native character set for non-ASCII platforms.  The other possibilities\n  * are already native, so no translation is done. */\n\n    char * endbrace;    /* points to '}' following the name */\n    char* p = RExC_parse; /* Temporary */\n\n    SV * substitute_parse = NULL;\n    char *orig_end;\n    char *save_start;\n    I32 flags;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_GROK_BSLASH_N;\n\n    GET_RE_DEBUG_FLAGS;\n\n    assert(cBOOL(node_p) ^ cBOOL(code_point_p));  /* Exactly one should be set */\n    assert(! (node_p && cp_count));               /* At most 1 should be set */\n\n    if (cp_count) {     /* Initialize return for the most common case */\n        *cp_count = 1;\n    }\n\n    /* The [^\\n] meaning of \\N ignores spaces and comments under the /x\n     * modifier.  The other meanings do not, so use a temporary until we find\n     * out which we are being called with */\n    skip_to_be_ignored_text(pRExC_state, &p,\n                            FALSE /* Don't force to /x */ );\n\n    /* Disambiguate between \\N meaning a named character versus \\N meaning\n     * [^\\n].  The latter is assumed when the {...} following the \\N is a legal\n     * quantifier, or if there is no '{' at all */\n    if (*p != '{' || regcurly(p)) {\n        RExC_parse = p;\n        if (cp_count) {\n            *cp_count = -1;\n        }\n\n        if (! node_p) {\n            return FALSE;\n        }\n\n        *node_p = reg_node(pRExC_state, REG_ANY);\n        *flagp |= HASWIDTH|SIMPLE;\n        MARK_NAUGHTY(1);\n        Set_Node_Length(REGNODE_p(*(node_p)), 1); /* MJD */\n        return TRUE;\n    }\n\n    /* The test above made sure that the next real character is a '{', but\n     * under the /x modifier, it could be separated by space (or a comment and\n     * \\n) and this is not allowed (for consistency with \\x{...} and the\n     * tokenizer handling of \\N{NAME}). */\n    if (*RExC_parse != '{') {\n        vFAIL(\"Missing braces on \\\\N{}\");\n    }\n\n    RExC_parse++;       /* Skip past the '{' */\n\n    endbrace = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n    if (! endbrace) { /* no trailing brace */\n        vFAIL2(\"Missing right brace on \\\\%c{}\", 'N');\n    }\n\n    /* Here, we have decided it should be a named character or sequence.  These\n     * imply Unicode semantics */\n    REQUIRE_UNI_RULES(flagp, FALSE);\n\n    /* \\N{_} is what toke.c returns to us to indicate a name that evaluates to\n     * nothing at all (not allowed under strict) */\n    if (endbrace - RExC_parse == 1 && *RExC_parse == '_') {\n        RExC_parse = endbrace;\n        if (strict) {\n            RExC_parse++;   /* Position after the \"}\" */\n            vFAIL(\"Zero length \\\\N{}\");\n        }\n\n        if (cp_count) {\n            *cp_count = 0;\n        }\n        nextchar(pRExC_state);\n        if (! node_p) {\n            return FALSE;\n        }\n\n        *node_p = reg_node(pRExC_state, NOTHING);\n        return TRUE;\n    }\n\n    if (endbrace - RExC_parse < 2 || ! strBEGINs(RExC_parse, \"U+\")) {\n\n        /* Here, the name isn't of the form  U+....  This can happen if the\n         * pattern is single-quoted, so didn't get evaluated in toke.c.  Now\n         * is the time to find out what the name means */\n\n        const STRLEN name_len = endbrace - RExC_parse;\n        SV *  value_sv;     /* What does this name evaluate to */\n        SV ** value_svp;\n        const U8 * value;   /* string of name's value */\n        STRLEN value_len;   /* and its length */\n\n        /*  RExC_unlexed_names is a hash of names that weren't evaluated by\n         *  toke.c, and their values. Make sure is initialized */\n        if (! RExC_unlexed_names) {\n            RExC_unlexed_names = newHV();\n        }\n\n        /* If we have already seen this name in this pattern, use that.  This\n         * allows us to only call the charnames handler once per name per\n         * pattern.  A broken or malicious handler could return something\n         * different each time, which could cause the results to vary depending\n         * on if something gets added or subtracted from the pattern that\n         * causes the number of passes to change, for example */\n        if ((value_svp = hv_fetch(RExC_unlexed_names, RExC_parse,\n                                                      name_len, 0)))\n        {\n            value_sv = *value_svp;\n        }\n        else { /* Otherwise we have to go out and get the name */\n            const char * error_msg = NULL;\n            value_sv = get_and_check_backslash_N_name(RExC_parse, endbrace,\n                                                      UTF,\n                                                      &error_msg);\n            if (error_msg) {\n                RExC_parse = endbrace;\n                vFAIL(error_msg);\n            }\n\n            /* If no error message, should have gotten a valid return */\n            assert (value_sv);\n\n            /* Save the name's meaning for later use */\n            if (! hv_store(RExC_unlexed_names, RExC_parse, name_len,\n                           value_sv, 0))\n            {\n                Perl_croak(aTHX_ \"panic: hv_store() unexpectedly failed\");\n            }\n        }\n\n        /* Here, we have the value the name evaluates to in 'value_sv' */\n        value = (U8 *) SvPV(value_sv, value_len);\n\n        /* See if the result is one code point vs 0 or multiple */\n        if (value_len > 0 && value_len <= (UV) ((SvUTF8(value_sv))\n                                               ? UTF8SKIP(value)\n                                               : 1))\n        {\n            /* Here, exactly one code point.  If that isn't what is wanted,\n             * fail */\n            if (! code_point_p) {\n                RExC_parse = p;\n                return FALSE;\n            }\n\n            /* Convert from string to numeric code point */\n            *code_point_p = (SvUTF8(value_sv))\n                            ? valid_utf8_to_uvchr(value, NULL)\n                            : *value;\n\n            /* Have parsed this entire single code point \\N{...}.  *cp_count\n             * has already been set to 1, so don't do it again. */\n            RExC_parse = endbrace;\n            nextchar(pRExC_state);\n            return TRUE;\n        } /* End of is a single code point */\n\n        /* Count the code points, if caller desires.  The API says to do this\n         * even if we will later return FALSE */\n        if (cp_count) {\n            *cp_count = 0;\n\n            *cp_count = (SvUTF8(value_sv))\n                        ? utf8_length(value, value + value_len)\n                        : value_len;\n        }\n\n        /* Fail if caller doesn't want to handle a multi-code-point sequence.\n         * But don't back the pointer up if the caller wants to know how many\n         * code points there are (they need to handle it themselves in this\n         * case).  */\n        if (! node_p) {\n            if (! cp_count) {\n                RExC_parse = p;\n            }\n            return FALSE;\n        }\n\n        /* Convert this to a sub-pattern of the form \"(?: ... )\", and then call\n         * reg recursively to parse it.  That way, it retains its atomicness,\n         * while not having to worry about any special handling that some code\n         * points may have. */\n\n        substitute_parse = newSVpvs(\"?:\");\n        sv_catsv(substitute_parse, value_sv);\n        sv_catpv(substitute_parse, \")\");\n\n#ifdef EBCDIC\n        /* The value should already be native, so no need to convert on EBCDIC\n         * platforms.*/\n        assert(! RExC_recode_x_to_native);\n#endif\n\n    }\n    else {   /* \\N{U+...} */\n        Size_t count = 0;   /* code point count kept internally */\n\n        /* We can get to here when the input is \\N{U+...} or when toke.c has\n         * converted a name to the \\N{U+...} form.  This include changing a\n         * name that evaluates to multiple code points to \\N{U+c1.c2.c3 ...} */\n\n        RExC_parse += 2;    /* Skip past the 'U+' */\n\n        /* Code points are separated by dots.  The '}' terminates the whole\n         * thing. */\n\n        do {    /* Loop until the ending brace */\n            UV cp = 0;\n            char * start_digit;     /* The first of the current code point */\n            if (! isXDIGIT(*RExC_parse)) {\n                RExC_parse++;\n                vFAIL(\"Invalid hexadecimal number in \\\\N{U+...}\");\n            }\n\n            start_digit = RExC_parse;\n            count++;\n\n            /* Loop through the hex digits of the current code point */\n            do {\n                /* Adding this digit will shift the result 4 bits.  If that\n                 * result would be above the legal max, it's overflow */\n                if (cp > MAX_LEGAL_CP >> 4) {\n\n                    /* Find the end of the code point */\n                    do {\n                        RExC_parse ++;\n                    } while (isXDIGIT(*RExC_parse) || *RExC_parse == '_');\n\n                    /* Be sure to synchronize this message with the similar one\n                     * in utf8.c */\n                    vFAIL4(\"Use of code point 0x%.*s is not allowed; the\"\n                        \" permissible max is 0x%\" UVxf,\n                        (int) (RExC_parse - start_digit), start_digit,\n                        MAX_LEGAL_CP);\n                }\n\n                /* Accumulate this (valid) digit into the running total */\n                cp  = (cp << 4) + READ_XDIGIT(RExC_parse);\n\n                /* READ_XDIGIT advanced the input pointer.  Ignore a single\n                 * underscore separator */\n                if (*RExC_parse == '_' && isXDIGIT(RExC_parse[1])) {\n                    RExC_parse++;\n                }\n            } while (isXDIGIT(*RExC_parse));\n\n            /* Here, have accumulated the next code point */\n            if (RExC_parse >= endbrace) {   /* If done ... */\n                if (count != 1) {\n                    goto do_concat;\n                }\n\n                /* Here, is a single code point; fail if doesn't want that */\n                if (! code_point_p) {\n                    RExC_parse = p;\n                    return FALSE;\n                }\n\n                /* A single code point is easy to handle; just return it */\n                *code_point_p = UNI_TO_NATIVE(cp);\n                RExC_parse = endbrace;\n                nextchar(pRExC_state);\n                return TRUE;\n            }\n\n            /* Here, the only legal thing would be a multiple character\n             * sequence (of the form \"\\N{U+c1.c2. ... }\".   So the next\n             * character must be a dot (and the one after that can't be the\n             * endbrace, or we'd have something like \\N{U+100.} ) */\n            if (*RExC_parse != '.' || RExC_parse + 1 >= endbrace) {\n                RExC_parse += (RExC_orig_utf8)  /* point to after 1st invalid */\n                                ? UTF8SKIP(RExC_parse)\n                                : 1;\n                if (RExC_parse >= endbrace) { /* Guard against malformed utf8 */\n                    RExC_parse = endbrace;\n                }\n                vFAIL(\"Invalid hexadecimal number in \\\\N{U+...}\");\n            }\n\n            /* Here, looks like its really a multiple character sequence.  Fail\n             * if that's not what the caller wants.  But continue with counting\n             * and error checking if they still want a count */\n            if (! node_p && ! cp_count) {\n                return FALSE;\n            }\n\n            /* What is done here is to convert this to a sub-pattern of the\n             * form \\x{char1}\\x{char2}...  and then call reg recursively to\n             * parse it (enclosing in \"(?: ... )\" ).  That way, it retains its\n             * atomicness, while not having to worry about special handling\n             * that some code points may have.  We don't create a subpattern,\n             * but go through the motions of code point counting and error\n             * checking, if the caller doesn't want a node returned. */\n\n            if (node_p && count == 1) {\n                substitute_parse = newSVpvs(\"?:\");\n            }\n\n          do_concat:\n\n            if (node_p) {\n                /* Convert to notation the rest of the code understands */\n                sv_catpvs(substitute_parse, \"\\\\x{\");\n                sv_catpvn(substitute_parse, start_digit,\n                                            RExC_parse - start_digit);\n                sv_catpvs(substitute_parse, \"}\");\n            }\n\n            /* Move to after the dot (or ending brace the final time through.)\n             * */\n            RExC_parse++;\n            count++;\n\n        } while (RExC_parse < endbrace);\n\n        if (! node_p) { /* Doesn't want the node */\n            assert (cp_count);\n\n            *cp_count = count;\n            return FALSE;\n        }\n\n        sv_catpvs(substitute_parse, \")\");\n\n#ifdef EBCDIC\n        /* The values are Unicode, and therefore have to be converted to native\n         * on a non-Unicode (meaning non-ASCII) platform. */\n        RExC_recode_x_to_native = 1;\n#endif\n\n    }\n\n    /* Here, we have the string the name evaluates to, ready to be parsed,\n     * stored in 'substitute_parse' as a series of valid \"\\x{...}\\x{...}\"\n     * constructs.  This can be called from within a substitute parse already.\n     * The error reporting mechanism doesn't work for 2 levels of this, but the\n     * code above has validated this new construct, so there should be no\n     * errors generated by the below.  And this isn' an exact copy, so the\n     * mechanism to seamlessly deal with this won't work, so turn off warnings\n     * during it */\n    save_start = RExC_start;\n    orig_end = RExC_end;\n\n    RExC_parse = RExC_start = SvPVX(substitute_parse);\n    RExC_end = RExC_parse + SvCUR(substitute_parse);\n    TURN_OFF_WARNINGS_IN_SUBSTITUTE_PARSE;\n\n    *node_p = reg(pRExC_state, 1, &flags, depth+1);\n\n    /* Restore the saved values */\n    RESTORE_WARNINGS;\n    RExC_start = save_start;\n    RExC_parse = endbrace;\n    RExC_end = orig_end;\n#ifdef EBCDIC\n    RExC_recode_x_to_native = 0;\n#endif\n\n    SvREFCNT_dec_NN(substitute_parse);\n\n    if (! *node_p) {\n        RETURN_FAIL_ON_RESTART(flags, flagp);\n        FAIL2(\"panic: reg returned failure to grok_bslash_N, flags=%#\" UVxf,\n            (UV) flags);\n    }\n    *flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);\n\n    nextchar(pRExC_state);\n\n    return TRUE;\n}\n\n\nPERL_STATIC_INLINE U8\nS_compute_EXACTish(RExC_state_t *pRExC_state)\n{\n    U8 op;\n\n    PERL_ARGS_ASSERT_COMPUTE_EXACTISH;\n\n    if (! FOLD) {\n        return (LOC)\n                ? EXACTL\n                : EXACT;\n    }\n\n    op = get_regex_charset(RExC_flags);\n    if (op >= REGEX_ASCII_RESTRICTED_CHARSET) {\n        op--; /* /a is same as /u, and map /aa's offset to what /a's would have\n                 been, so there is no hole */\n    }\n\n    return op + EXACTF;\n}\n\nSTATIC bool\nS_new_regcurly(const char *s, const char *e)\n{\n    /* This is a temporary function designed to match the most lenient form of\n     * a {m,n} quantifier we ever envision, with either number omitted, and\n     * spaces anywhere between/before/after them.\n     *\n     * If this function fails, then the string it matches is very unlikely to\n     * ever be considered a valid quantifier, so we can allow the '{' that\n     * begins it to be considered as a literal */\n\n    bool has_min = FALSE;\n    bool has_max = FALSE;\n\n    PERL_ARGS_ASSERT_NEW_REGCURLY;\n\n    if (s >= e || *s++ != '{')\n\treturn FALSE;\n\n    while (s < e && isSPACE(*s)) {\n        s++;\n    }\n    while (s < e && isDIGIT(*s)) {\n        has_min = TRUE;\n        s++;\n    }\n    while (s < e && isSPACE(*s)) {\n        s++;\n    }\n\n    if (*s == ',') {\n\ts++;\n        while (s < e && isSPACE(*s)) {\n            s++;\n        }\n        while (s < e && isDIGIT(*s)) {\n            has_max = TRUE;\n            s++;\n        }\n        while (s < e && isSPACE(*s)) {\n            s++;\n        }\n    }\n\n    return s < e && *s == '}' && (has_min || has_max);\n}\n\n/* Parse backref decimal value, unless it's too big to sensibly be a backref,\n * in which case return I32_MAX (rather than possibly 32-bit wrapping) */\n\nstatic I32\nS_backref_value(char *p, char *e)\n{\n    const char* endptr = e;\n    UV val;\n    if (grok_atoUV(p, &val, &endptr) && val <= I32_MAX)\n        return (I32)val;\n    return I32_MAX;\n}\n\n\n/*\n - regatom - the lowest level\n\n   Try to identify anything special at the start of the current parse position.\n   If there is, then handle it as required. This may involve generating a\n   single regop, such as for an assertion; or it may involve recursing, such as\n   to handle a () structure.\n\n   If the string doesn't start with something special then we gobble up\n   as much literal text as we can.  If we encounter a quantifier, we have to\n   back off the final literal character, as that quantifier applies to just it\n   and not to the whole string of literals.\n\n   Once we have been able to handle whatever type of thing started the\n   sequence, we return the offset into the regex engine program being compiled\n   at which any  next regnode should be placed.\n\n   Returns 0, setting *flagp to TRYAGAIN if reg() returns 0 with TRYAGAIN.\n   Returns 0, setting *flagp to RESTART_PARSE if the parse needs to be\n   restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to UTF-8\n   Otherwise does not return 0.\n\n   Note: we have to be careful with escapes, as they can be both literal\n   and special, and in the case of \\10 and friends, context determines which.\n\n   A summary of the code structure is:\n\n   switch (first_byte) {\n\tcases for each special:\n\t    handle this special;\n\t    break;\n\tcase '\\\\':\n\t    switch (2nd byte) {\n\t\tcases for each unambiguous special:\n\t\t    handle this special;\n\t\t    break;\n\t\tcases for each ambigous special/literal:\n\t\t    disambiguate;\n\t\t    if (special)  handle here\n\t\t    else goto defchar;\n\t\tdefault: // unambiguously literal:\n\t\t    goto defchar;\n\t    }\n\tdefault:  // is a literal char\n\t    // FALL THROUGH\n\tdefchar:\n\t    create EXACTish node for literal;\n\t    while (more input and node isn't full) {\n\t\tswitch (input_byte) {\n\t\t   cases for each special;\n                       make sure parse pointer is set so that the next call to\n                           regatom will see this special first\n                       goto loopdone; // EXACTish node terminated by prev. char\n\t\t   default:\n\t\t       append char to EXACTISH node;\n\t\t}\n\t        get next input byte;\n\t    }\n        loopdone:\n   }\n   return the generated node;\n\n   Specifically there are two separate switches for handling\n   escape sequences, with the one for handling literal escapes requiring\n   a dummy entry for all of the special escapes that are actually handled\n   by the other.\n\n*/\n\nSTATIC regnode_offset\nS_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)\n{\n    dVAR;\n    regnode_offset ret = 0;\n    I32 flags = 0;\n    char *parse_start;\n    U8 op;\n    int invert = 0;\n    U8 arg;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    *flagp = WORST;\t\t/* Tentatively. */\n\n    DEBUG_PARSE(\"atom\");\n\n    PERL_ARGS_ASSERT_REGATOM;\n\n  tryagain:\n    parse_start = RExC_parse;\n    assert(RExC_parse < RExC_end);\n    switch ((U8)*RExC_parse) {\n    case '^':\n\tRExC_seen_zerolen++;\n\tnextchar(pRExC_state);\n\tif (RExC_flags & RXf_PMf_MULTILINE)\n\t    ret = reg_node(pRExC_state, MBOL);\n\telse\n\t    ret = reg_node(pRExC_state, SBOL);\n        Set_Node_Length(REGNODE_p(ret), 1); /* MJD */\n\tbreak;\n    case '$':\n\tnextchar(pRExC_state);\n\tif (*RExC_parse)\n\t    RExC_seen_zerolen++;\n\tif (RExC_flags & RXf_PMf_MULTILINE)\n\t    ret = reg_node(pRExC_state, MEOL);\n\telse\n\t    ret = reg_node(pRExC_state, SEOL);\n        Set_Node_Length(REGNODE_p(ret), 1); /* MJD */\n\tbreak;\n    case '.':\n\tnextchar(pRExC_state);\n\tif (RExC_flags & RXf_PMf_SINGLELINE)\n\t    ret = reg_node(pRExC_state, SANY);\n\telse\n\t    ret = reg_node(pRExC_state, REG_ANY);\n\t*flagp |= HASWIDTH|SIMPLE;\n\tMARK_NAUGHTY(1);\n        Set_Node_Length(REGNODE_p(ret), 1); /* MJD */\n\tbreak;\n    case '[':\n    {\n\tchar * const oregcomp_parse = ++RExC_parse;\n        ret = regclass(pRExC_state, flagp, depth+1,\n                       FALSE, /* means parse the whole char class */\n                       TRUE, /* allow multi-char folds */\n                       FALSE, /* don't silence non-portable warnings. */\n                       (bool) RExC_strict,\n                       TRUE, /* Allow an optimized regnode result */\n                       NULL);\n        if (ret == 0) {\n            RETURN_FAIL_ON_RESTART_FLAGP(flagp);\n            FAIL2(\"panic: regclass returned failure to regatom, flags=%#\" UVxf,\n                  (UV) *flagp);\n        }\n\tif (*RExC_parse != ']') {\n\t    RExC_parse = oregcomp_parse;\n\t    vFAIL(\"Unmatched [\");\n\t}\n\tnextchar(pRExC_state);\n        Set_Node_Length(REGNODE_p(ret), RExC_parse - oregcomp_parse + 1); /* MJD */\n\tbreak;\n    }\n    case '(':\n\tnextchar(pRExC_state);\n        ret = reg(pRExC_state, 2, &flags, depth+1);\n\tif (ret == 0) {\n\t\tif (flags & TRYAGAIN) {\n\t\t    if (RExC_parse >= RExC_end) {\n\t\t\t /* Make parent create an empty node if needed. */\n\t\t\t*flagp |= TRYAGAIN;\n\t\t\treturn(0);\n\t\t    }\n\t\t    goto tryagain;\n\t\t}\n                RETURN_FAIL_ON_RESTART(flags, flagp);\n                FAIL2(\"panic: reg returned failure to regatom, flags=%#\" UVxf,\n                                                                 (UV) flags);\n\t}\n\t*flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);\n\tbreak;\n    case '|':\n    case ')':\n\tif (flags & TRYAGAIN) {\n\t    *flagp |= TRYAGAIN;\n\t    return 0;\n\t}\n\tvFAIL(\"Internal urp\");\n\t\t\t\t/* Supposed to be caught earlier. */\n\tbreak;\n    case '?':\n    case '+':\n    case '*':\n\tRExC_parse++;\n\tvFAIL(\"Quantifier follows nothing\");\n\tbreak;\n    case '\\\\':\n\t/* Special Escapes\n\n\t   This switch handles escape sequences that resolve to some kind\n\t   of special regop and not to literal text. Escape sequences that\n\t   resolve to literal text are handled below in the switch marked\n\t   \"Literal Escapes\".\n\n\t   Every entry in this switch *must* have a corresponding entry\n\t   in the literal escape switch. However, the opposite is not\n\t   required, as the default for this switch is to jump to the\n\t   literal text handling code.\n\t*/\n\tRExC_parse++;\n\tswitch ((U8)*RExC_parse) {\n\t/* Special Escapes */\n\tcase 'A':\n\t    RExC_seen_zerolen++;\n\t    ret = reg_node(pRExC_state, SBOL);\n            /* SBOL is shared with /^/ so we set the flags so we can tell\n             * /\\A/ from /^/ in split. */\n            FLAGS(REGNODE_p(ret)) = 1;\n\t    *flagp |= SIMPLE;\n\t    goto finish_meta_pat;\n\tcase 'G':\n\t    ret = reg_node(pRExC_state, GPOS);\n            RExC_seen |= REG_GPOS_SEEN;\n\t    *flagp |= SIMPLE;\n\t    goto finish_meta_pat;\n\tcase 'K':\n\t    RExC_seen_zerolen++;\n\t    ret = reg_node(pRExC_state, KEEPS);\n\t    *flagp |= SIMPLE;\n\t    /* XXX:dmq : disabling in-place substitution seems to\n\t     * be necessary here to avoid cases of memory corruption, as\n\t     * with: C<$_=\"x\" x 80; s/x\\K/y/> -- rgs\n\t     */\n            RExC_seen |= REG_LOOKBEHIND_SEEN;\n\t    goto finish_meta_pat;\n\tcase 'Z':\n\t    ret = reg_node(pRExC_state, SEOL);\n\t    *flagp |= SIMPLE;\n\t    RExC_seen_zerolen++;\t\t/* Do not optimize RE away */\n\t    goto finish_meta_pat;\n\tcase 'z':\n\t    ret = reg_node(pRExC_state, EOS);\n\t    *flagp |= SIMPLE;\n\t    RExC_seen_zerolen++;\t\t/* Do not optimize RE away */\n\t    goto finish_meta_pat;\n\tcase 'C':\n\t    vFAIL(\"\\\\C no longer supported\");\n\tcase 'X':\n\t    ret = reg_node(pRExC_state, CLUMP);\n\t    *flagp |= HASWIDTH;\n\t    goto finish_meta_pat;\n\n\tcase 'W':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'w':\n            arg = ANYOF_WORDCHAR;\n            goto join_posix;\n\n\tcase 'B':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'b':\n          {\n            U8 flags = 0;\n\t    regex_charset charset = get_regex_charset(RExC_flags);\n\n\t    RExC_seen_zerolen++;\n            RExC_seen |= REG_LOOKBEHIND_SEEN;\n\t    op = BOUND + charset;\n\n\t    if (RExC_parse >= RExC_end || *(RExC_parse + 1) != '{') {\n                flags = TRADITIONAL_BOUND;\n                if (op > BOUNDA) {  /* /aa is same as /a */\n                    op = BOUNDA;\n                }\n            }\n            else {\n                STRLEN length;\n                char name = *RExC_parse;\n                char * endbrace = NULL;\n                RExC_parse += 2;\n                endbrace = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n\n                if (! endbrace) {\n                    vFAIL2(\"Missing right brace on \\\\%c{}\", name);\n                }\n                /* XXX Need to decide whether to take spaces or not.  Should be\n                 * consistent with \\p{}, but that currently is SPACE, which\n                 * means vertical too, which seems wrong\n                 * while (isBLANK(*RExC_parse)) {\n                    RExC_parse++;\n                }*/\n                if (endbrace == RExC_parse) {\n                    RExC_parse++;  /* After the '}' */\n                    vFAIL2(\"Empty \\\\%c{}\", name);\n                }\n                length = endbrace - RExC_parse;\n                /*while (isBLANK(*(RExC_parse + length - 1))) {\n                    length--;\n                }*/\n                switch (*RExC_parse) {\n                    case 'g':\n                        if (    length != 1\n                            && (memNEs(RExC_parse + 1, length - 1, \"cb\")))\n                        {\n                            goto bad_bound_type;\n                        }\n                        flags = GCB_BOUND;\n                        break;\n                    case 'l':\n                        if (length != 2 || *(RExC_parse + 1) != 'b') {\n                            goto bad_bound_type;\n                        }\n                        flags = LB_BOUND;\n                        break;\n                    case 's':\n                        if (length != 2 || *(RExC_parse + 1) != 'b') {\n                            goto bad_bound_type;\n                        }\n                        flags = SB_BOUND;\n                        break;\n                    case 'w':\n                        if (length != 2 || *(RExC_parse + 1) != 'b') {\n                            goto bad_bound_type;\n                        }\n                        flags = WB_BOUND;\n                        break;\n                    default:\n                      bad_bound_type:\n                        RExC_parse = endbrace;\n\t\t\tvFAIL2utf8f(\n                            \"'%\" UTF8f \"' is an unknown bound type\",\n\t\t\t    UTF8fARG(UTF, length, endbrace - length));\n                        NOT_REACHED; /*NOTREACHED*/\n                }\n                RExC_parse = endbrace;\n                REQUIRE_UNI_RULES(flagp, 0);\n\n                if (op == BOUND) {\n                    op = BOUNDU;\n                }\n                else if (op >= BOUNDA) {  /* /aa is same as /a */\n                    op = BOUNDU;\n                    length += 4;\n\n                    /* Don't have to worry about UTF-8, in this message because\n                     * to get here the contents of the \\b must be ASCII */\n                    ckWARN4reg(RExC_parse + 1,  /* Include the '}' in msg */\n                              \"Using /u for '%.*s' instead of /%s\",\n                              (unsigned) length,\n                              endbrace - length + 1,\n                              (charset == REGEX_ASCII_RESTRICTED_CHARSET)\n                              ? ASCII_RESTRICT_PAT_MODS\n                              : ASCII_MORE_RESTRICT_PAT_MODS);\n                }\n\t    }\n\n            if (op == BOUND) {\n                RExC_seen_d_op = TRUE;\n            }\n            else if (op == BOUNDL) {\n                RExC_contains_locale = 1;\n            }\n\n            if (invert) {\n                op += NBOUND - BOUND;\n            }\n\n\t    ret = reg_node(pRExC_state, op);\n            FLAGS(REGNODE_p(ret)) = flags;\n\n\t    *flagp |= SIMPLE;\n\n\t    goto finish_meta_pat;\n          }\n\n\tcase 'D':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'd':\n            arg = ANYOF_DIGIT;\n            if (! DEPENDS_SEMANTICS) {\n                goto join_posix;\n            }\n\n            /* \\d doesn't have any matches in the upper Latin1 range, hence /d\n             * is equivalent to /u.  Changing to /u saves some branches at\n             * runtime */\n            op = POSIXU;\n            goto join_posix_op_known;\n\n\tcase 'R':\n\t    ret = reg_node(pRExC_state, LNBREAK);\n\t    *flagp |= HASWIDTH|SIMPLE;\n\t    goto finish_meta_pat;\n\n\tcase 'H':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'h':\n\t    arg = ANYOF_BLANK;\n            op = POSIXU;\n            goto join_posix_op_known;\n\n\tcase 'V':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'v':\n\t    arg = ANYOF_VERTWS;\n            op = POSIXU;\n            goto join_posix_op_known;\n\n\tcase 'S':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 's':\n            arg = ANYOF_SPACE;\n\n          join_posix:\n\n\t    op = POSIXD + get_regex_charset(RExC_flags);\n            if (op > POSIXA) {  /* /aa is same as /a */\n                op = POSIXA;\n            }\n            else if (op == POSIXL) {\n                RExC_contains_locale = 1;\n            }\n            else if (op == POSIXD) {\n                RExC_seen_d_op = TRUE;\n            }\n\n          join_posix_op_known:\n\n            if (invert) {\n                op += NPOSIXD - POSIXD;\n            }\n\n\t    ret = reg_node(pRExC_state, op);\n            FLAGS(REGNODE_p(ret)) = namedclass_to_classnum(arg);\n\n\t    *flagp |= HASWIDTH|SIMPLE;\n            /* FALLTHROUGH */\n\n          finish_meta_pat:\n            if (   UCHARAT(RExC_parse + 1) == '{'\n                && UNLIKELY(! new_regcurly(RExC_parse + 1, RExC_end)))\n            {\n                RExC_parse += 2;\n                vFAIL(\"Unescaped left brace in regex is illegal here\");\n            }\n\t    nextchar(pRExC_state);\n            Set_Node_Length(REGNODE_p(ret), 2); /* MJD */\n\t    break;\n\tcase 'p':\n\tcase 'P':\n            RExC_parse--;\n\n            ret = regclass(pRExC_state, flagp, depth+1,\n                           TRUE, /* means just parse this element */\n                           FALSE, /* don't allow multi-char folds */\n                           FALSE, /* don't silence non-portable warnings.  It\n                                     would be a bug if these returned\n                                     non-portables */\n                           (bool) RExC_strict,\n                           TRUE, /* Allow an optimized regnode result */\n                           NULL);\n            RETURN_FAIL_ON_RESTART_FLAGP(flagp);\n            /* regclass() can only return RESTART_PARSE and NEED_UTF8 if\n             * multi-char folds are allowed.  */\n            if (!ret)\n                FAIL2(\"panic: regclass returned failure to regatom, flags=%#\" UVxf,\n                      (UV) *flagp);\n\n            RExC_parse--;\n\n            Set_Node_Offset(REGNODE_p(ret), parse_start);\n            Set_Node_Cur_Length(REGNODE_p(ret), parse_start - 2);\n            nextchar(pRExC_state);\n\t    break;\n        case 'N':\n            /* Handle \\N, \\N{} and \\N{NAMED SEQUENCE} (the latter meaning the\n             * \\N{...} evaluates to a sequence of more than one code points).\n             * The function call below returns a regnode, which is our result.\n             * The parameters cause it to fail if the \\N{} evaluates to a\n             * single code point; we handle those like any other literal.  The\n             * reason that the multicharacter case is handled here and not as\n             * part of the EXACtish code is because of quantifiers.  In\n             * /\\N{BLAH}+/, the '+' applies to the whole thing, and doing it\n             * this way makes that Just Happen. dmq.\n             * join_exact() will join this up with adjacent EXACTish nodes\n             * later on, if appropriate. */\n            ++RExC_parse;\n            if (grok_bslash_N(pRExC_state,\n                              &ret,     /* Want a regnode returned */\n                              NULL,     /* Fail if evaluates to a single code\n                                           point */\n                              NULL,     /* Don't need a count of how many code\n                                           points */\n                              flagp,\n                              RExC_strict,\n                              depth)\n            ) {\n                break;\n            }\n\n            RETURN_FAIL_ON_RESTART_FLAGP(flagp);\n\n            /* Here, evaluates to a single code point.  Go get that */\n            RExC_parse = parse_start;\n            goto defchar;\n\n\tcase 'k':    /* Handle \\k<NAME> and \\k'NAME' */\n      parse_named_seq:\n        {\n            char ch;\n            if (   RExC_parse >= RExC_end - 1\n                || ((   ch = RExC_parse[1]) != '<'\n                                      && ch != '\\''\n                                      && ch != '{'))\n            {\n\t        RExC_parse++;\n\t\t/* diag_listed_as: Sequence \\%s... not terminated in regex; marked by <-- HERE in m/%s/ */\n\t        vFAIL2(\"Sequence %.2s... not terminated\", parse_start);\n\t    } else {\n\t\tRExC_parse += 2;\n                ret = handle_named_backref(pRExC_state,\n                                           flagp,\n                                           parse_start,\n                                           (ch == '<')\n                                           ? '>'\n                                           : (ch == '{')\n                                             ? '}'\n                                             : '\\'');\n            }\n            break;\n\t}\n\tcase 'g':\n\tcase '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t    {\n\t\tI32 num;\n\t\tbool hasbrace = 0;\n\n\t\tif (*RExC_parse == 'g') {\n                    bool isrel = 0;\n\n\t\t    RExC_parse++;\n\t\t    if (*RExC_parse == '{') {\n\t\t        RExC_parse++;\n\t\t        hasbrace = 1;\n\t\t    }\n\t\t    if (*RExC_parse == '-') {\n\t\t        RExC_parse++;\n\t\t        isrel = 1;\n\t\t    }\n\t\t    if (hasbrace && !isDIGIT(*RExC_parse)) {\n\t\t        if (isrel) RExC_parse--;\n                        RExC_parse -= 2;\n\t\t        goto parse_named_seq;\n                    }\n\n                    if (RExC_parse >= RExC_end) {\n                        goto unterminated_g;\n                    }\n                    num = S_backref_value(RExC_parse, RExC_end);\n                    if (num == 0)\n                        vFAIL(\"Reference to invalid group 0\");\n                    else if (num == I32_MAX) {\n                         if (isDIGIT(*RExC_parse))\n\t\t\t    vFAIL(\"Reference to nonexistent group\");\n                        else\n                          unterminated_g:\n                            vFAIL(\"Unterminated \\\\g... pattern\");\n                    }\n\n                    if (isrel) {\n                        num = RExC_npar - num;\n                        if (num < 1)\n                            vFAIL(\"Reference to nonexistent or unclosed group\");\n                    }\n                }\n                else {\n                    num = S_backref_value(RExC_parse, RExC_end);\n                    /* bare \\NNN might be backref or octal - if it is larger\n                     * than or equal RExC_npar then it is assumed to be an\n                     * octal escape. Note RExC_npar is +1 from the actual\n                     * number of parens. */\n                    /* Note we do NOT check if num == I32_MAX here, as that is\n                     * handled by the RExC_npar check */\n\n                    if (\n                        /* any numeric escape < 10 is always a backref */\n                        num > 9\n                        /* any numeric escape < RExC_npar is a backref */\n                        && num >= RExC_npar\n                        /* cannot be an octal escape if it starts with 8 */\n                        && *RExC_parse != '8'\n                        /* cannot be an octal escape it it starts with 9 */\n                        && *RExC_parse != '9'\n                    ) {\n                        /* Probably not meant to be a backref, instead likely\n                         * to be an octal character escape, e.g. \\35 or \\777.\n                         * The above logic should make it obvious why using\n                         * octal escapes in patterns is problematic. - Yves */\n                        RExC_parse = parse_start;\n                        goto defchar;\n                    }\n                }\n\n                /* At this point RExC_parse points at a numeric escape like\n                 * \\12 or \\88 or something similar, which we should NOT treat\n                 * as an octal escape. It may or may not be a valid backref\n                 * escape. For instance \\88888888 is unlikely to be a valid\n                 * backref. */\n                while (isDIGIT(*RExC_parse))\n                    RExC_parse++;\n                if (hasbrace) {\n                    if (*RExC_parse != '}')\n                        vFAIL(\"Unterminated \\\\g{...} pattern\");\n                    RExC_parse++;\n                }\n                if (num >= (I32)RExC_npar) {\n\n                    /* It might be a forward reference; we can't fail until we\n                     * know, by completing the parse to get all the groups, and\n                     * then reparsing */\n                    if (ALL_PARENS_COUNTED)  {\n                        if (num >= RExC_total_parens)  {\n                            vFAIL(\"Reference to nonexistent group\");\n                        }\n                    }\n                    else {\n                        REQUIRE_PARENS_PASS;\n                    }\n                }\n                RExC_sawback = 1;\n                ret = reganode(pRExC_state,\n                               ((! FOLD)\n                                 ? REF\n                                 : (ASCII_FOLD_RESTRICTED)\n                                   ? REFFA\n                                   : (AT_LEAST_UNI_SEMANTICS)\n                                     ? REFFU\n                                     : (LOC)\n                                       ? REFFL\n                                       : REFF),\n                                num);\n                if (OP(REGNODE_p(ret)) == REFF) {\n                    RExC_seen_d_op = TRUE;\n                }\n                *flagp |= HASWIDTH;\n\n                /* override incorrect value set in reganode MJD */\n                Set_Node_Offset(REGNODE_p(ret), parse_start);\n                Set_Node_Cur_Length(REGNODE_p(ret), parse_start-1);\n                skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                        FALSE /* Don't force to /x */ );\n\t    }\n\t    break;\n\tcase '\\0':\n\t    if (RExC_parse >= RExC_end)\n\t\tFAIL(\"Trailing \\\\\");\n\t    /* FALLTHROUGH */\n\tdefault:\n\t    /* Do not generate \"unrecognized\" warnings here, we fall\n\t       back into the quick-grab loop below */\n            RExC_parse = parse_start;\n\t    goto defchar;\n\t} /* end of switch on a \\foo sequence */\n\tbreak;\n\n    case '#':\n\n        /* '#' comments should have been spaced over before this function was\n         * called */\n        assert((RExC_flags & RXf_PMf_EXTENDED) == 0);\n\t/*\n        if (RExC_flags & RXf_PMf_EXTENDED) {\n\t    RExC_parse = reg_skipcomment( pRExC_state, RExC_parse );\n\t    if (RExC_parse < RExC_end)\n\t\tgoto tryagain;\n\t}\n        */\n\n\t/* FALLTHROUGH */\n\n    default:\n\t  defchar: {\n\n            /* Here, we have determined that the next thing is probably a\n             * literal character.  RExC_parse points to the first byte of its\n             * definition.  (It still may be an escape sequence that evaluates\n             * to a single character) */\n\n\t    STRLEN len = 0;\n\t    UV ender = 0;\n\t    char *p;\n\t    char *s;\n\n/* This allows us to fill a node with just enough spare so that if the final\n * character folds, its expansion is guaranteed to fit */\n#define MAX_NODE_STRING_SIZE (255-UTF8_MAXBYTES_CASE)\n\n\t    char *s0;\n\t    U8 upper_parse = MAX_NODE_STRING_SIZE;\n\n            /* We start out as an EXACT node, even if under /i, until we find a\n             * character which is in a fold.  The algorithm now segregates into\n             * separate nodes, characters that fold from those that don't under\n             * /i.  (This hopefully will create nodes that are fixed strings\n             * even under /i, giving the optimizer something to grab on to.)\n             * So, if a node has something in it and the next character is in\n             * the opposite category, that node is closed up, and the function\n             * returns.  Then regatom is called again, and a new node is\n             * created for the new category. */\n            U8 node_type = EXACT;\n\n            /* Assume the node will be fully used; the excess is given back at\n             * the end.  We can't make any other length assumptions, as a byte\n             * input sequence could shrink down. */\n            Ptrdiff_t initial_size = STR_SZ(256);\n\n            bool next_is_quantifier;\n            char * oldp = NULL;\n\n            /* We can convert EXACTF nodes to EXACTFU if they contain only\n             * characters that match identically regardless of the target\n             * string's UTF8ness.  The reason to do this is that EXACTF is not\n             * trie-able, EXACTFU is, and EXACTFU requires fewer operations at\n             * runtime.\n             *\n             * Similarly, we can convert EXACTFL nodes to EXACTFLU8 if they\n             * contain only above-Latin1 characters (hence must be in UTF8),\n             * which don't participate in folds with Latin1-range characters,\n             * as the latter's folds aren't known until runtime. */\n            bool maybe_exactfu = FOLD && (DEPENDS_SEMANTICS || LOC);\n\n            /* Single-character EXACTish nodes are almost always SIMPLE.  This\n             * allows us to override this as encountered */\n            U8 maybe_SIMPLE = SIMPLE;\n\n            /* Does this node contain something that can't match unless the\n             * target string is (also) in UTF-8 */\n            bool requires_utf8_target = FALSE;\n\n            /* The sequence 'ss' is problematic in non-UTF-8 patterns. */\n            bool has_ss = FALSE;\n\n            /* So is the MICRO SIGN */\n            bool has_micro_sign = FALSE;\n\n            /* Allocate an EXACT node.  The node_type may change below to\n             * another EXACTish node, but since the size of the node doesn't\n             * change, it works */\n            ret = regnode_guts(pRExC_state, node_type, initial_size, \"exact\");\n            FILL_NODE(ret, node_type);\n            RExC_emit++;\n\n\t    s = STRING(REGNODE_p(ret));\n\n            s0 = s;\n\n\t  reparse:\n\n            /* This breaks under rare circumstances.  If folding, we do not\n             * want to split a node at a character that is a non-final in a\n             * multi-char fold, as an input string could just happen to want to\n             * match across the node boundary.  The code at the end of the loop\n             * looks for this, and backs off until it finds not such a\n             * character, but it is possible (though extremely, extremely\n             * unlikely) for all characters in the node to be non-final fold\n             * ones, in which case we just leave the node fully filled, and\n             * hope that it doesn't match the string in just the wrong place */\n\n            assert( ! UTF     /* Is at the beginning of a character */\n                   || UTF8_IS_INVARIANT(UCHARAT(RExC_parse))\n                   || UTF8_IS_START(UCHARAT(RExC_parse)));\n\n            /* Here, we have a literal character.  Find the maximal string of\n             * them in the input that we can fit into a single EXACTish node.\n             * We quit at the first non-literal or when the node gets full, or\n             * under /i the categorization of folding/non-folding character\n             * changes */\n\t    for (p = RExC_parse; len < upper_parse && p < RExC_end; ) {\n\n                /* In most cases each iteration adds one byte to the output.\n                 * The exceptions override this */\n                Size_t added_len = 1;\n\n\t\toldp = p;\n\n                /* White space has already been ignored */\n                assert(   (RExC_flags & RXf_PMf_EXTENDED) == 0\n                       || ! is_PATWS_safe((p), RExC_end, UTF));\n\n\t\tswitch ((U8)*p) {\n\t\tcase '^':\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '[':\n\t\tcase '(':\n\t\tcase ')':\n\t\tcase '|':\n\t\t    goto loopdone;\n\t\tcase '\\\\':\n\t\t    /* Literal Escapes Switch\n\n\t\t       This switch is meant to handle escape sequences that\n\t\t       resolve to a literal character.\n\n\t\t       Every escape sequence that represents something\n\t\t       else, like an assertion or a char class, is handled\n\t\t       in the switch marked 'Special Escapes' above in this\n\t\t       routine, but also has an entry here as anything that\n\t\t       isn't explicitly mentioned here will be treated as\n\t\t       an unescaped equivalent literal.\n\t\t    */\n\n\t\t    switch ((U8)*++p) {\n\n\t\t    /* These are all the special escapes. */\n\t\t    case 'A':             /* Start assertion */\n\t\t    case 'b': case 'B':   /* Word-boundary assertion*/\n\t\t    case 'C':             /* Single char !DANGEROUS! */\n\t\t    case 'd': case 'D':   /* digit class */\n\t\t    case 'g': case 'G':   /* generic-backref, pos assertion */\n\t\t    case 'h': case 'H':   /* HORIZWS */\n\t\t    case 'k': case 'K':   /* named backref, keep marker */\n\t\t    case 'p': case 'P':   /* Unicode property */\n\t\t              case 'R':   /* LNBREAK */\n\t\t    case 's': case 'S':   /* space class */\n\t\t    case 'v': case 'V':   /* VERTWS */\n\t\t    case 'w': case 'W':   /* word class */\n                    case 'X':             /* eXtended Unicode \"combining\n                                             character sequence\" */\n\t\t    case 'z': case 'Z':   /* End of line/string assertion */\n\t\t\t--p;\n\t\t\tgoto loopdone;\n\n\t            /* Anything after here is an escape that resolves to a\n\t               literal. (Except digits, which may or may not)\n\t             */\n\t\t    case 'n':\n\t\t\tender = '\\n';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'N': /* Handle a single-code point named character. */\n                        RExC_parse = p + 1;\n                        if (! grok_bslash_N(pRExC_state,\n                                            NULL,   /* Fail if evaluates to\n                                                       anything other than a\n                                                       single code point */\n                                            &ender, /* The returned single code\n                                                       point */\n                                            NULL,   /* Don't need a count of\n                                                       how many code points */\n                                            flagp,\n                                            RExC_strict,\n                                            depth)\n                        ) {\n                            if (*flagp & NEED_UTF8)\n                                FAIL(\"panic: grok_bslash_N set NEED_UTF8\");\n                            RETURN_FAIL_ON_RESTART_FLAGP(flagp);\n\n                            /* Here, it wasn't a single code point.  Go close\n                             * up this EXACTish node.  The switch() prior to\n                             * this switch handles the other cases */\n                            RExC_parse = p = oldp;\n                            goto loopdone;\n                        }\n                        p = RExC_parse;\n                        RExC_parse = parse_start;\n\n                        /* The \\N{} means the pattern, if previously /d,\n                         * becomes /u.  That means it can't be an EXACTF node,\n                         * but an EXACTFU */\n                        if (node_type == EXACTF) {\n                            node_type = EXACTFU;\n\n                            /* If the node already contains something that\n                             * differs between EXACTF and EXACTFU, reparse it\n                             * as EXACTFU */\n                            if (! maybe_exactfu) {\n                                len = 0;\n                                s = s0;\n                                goto reparse;\n                            }\n                        }\n\n                        break;\n\t\t    case 'r':\n\t\t\tender = '\\r';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 't':\n\t\t\tender = '\\t';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'f':\n\t\t\tender = '\\f';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'e':\n\t\t\tender = ESC_NATIVE;\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'a':\n\t\t\tender = '\\a';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'o':\n\t\t\t{\n\t\t\t    UV result;\n\t\t\t    const char* error_msg;\n\n\t\t\t    bool valid = grok_bslash_o(&p,\n                                                       RExC_end,\n\t\t\t\t\t\t       &result,\n\t\t\t\t\t\t       &error_msg,\n\t\t\t\t\t\t       TO_OUTPUT_WARNINGS(p),\n                                                       (bool) RExC_strict,\n                                                       TRUE, /* Output warnings\n                                                                for non-\n                                                                portables */\n                                                       UTF);\n\t\t\t    if (! valid) {\n\t\t\t\tRExC_parse = p;\t/* going to die anyway; point\n\t\t\t\t\t\t   to exact spot of failure */\n\t\t\t\tvFAIL(error_msg);\n\t\t\t    }\n                            UPDATE_WARNINGS_LOC(p - 1);\n                            ender = result;\n\t\t\t    break;\n\t\t\t}\n\t\t    case 'x':\n\t\t\t{\n                            UV result = UV_MAX; /* initialize to erroneous\n                                                   value */\n\t\t\t    const char* error_msg;\n\n\t\t\t    bool valid = grok_bslash_x(&p,\n                                                       RExC_end,\n\t\t\t\t\t\t       &result,\n\t\t\t\t\t\t       &error_msg,\n                                                       TO_OUTPUT_WARNINGS(p),\n                                                       (bool) RExC_strict,\n                                                       TRUE, /* Silence warnings\n                                                                for non-\n                                                                portables */\n                                                       UTF);\n\t\t\t    if (! valid) {\n\t\t\t\tRExC_parse = p;\t/* going to die anyway; point\n\t\t\t\t\t\t   to exact spot of failure */\n\t\t\t\tvFAIL(error_msg);\n\t\t\t    }\n                            UPDATE_WARNINGS_LOC(p - 1);\n                            ender = result;\n\n                            if (ender < 0x100) {\n#ifdef EBCDIC\n                                if (RExC_recode_x_to_native) {\n                                    ender = LATIN1_TO_NATIVE(ender);\n                                }\n#endif\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t    case 'c':\n\t\t\tp++;\n\t\t\tender = grok_bslash_c(*p, TO_OUTPUT_WARNINGS(p));\n                        UPDATE_WARNINGS_LOC(p);\n                        p++;\n\t\t\tbreak;\n                    case '8': case '9': /* must be a backreference */\n                        --p;\n                        /* we have an escape like \\8 which cannot be an octal escape\n                         * so we exit the loop, and let the outer loop handle this\n                         * escape which may or may not be a legitimate backref. */\n                        goto loopdone;\n                    case '1': case '2': case '3':case '4':\n\t\t    case '5': case '6': case '7':\n                        /* When we parse backslash escapes there is ambiguity\n                         * between backreferences and octal escapes. Any escape\n                         * from \\1 - \\9 is a backreference, any multi-digit\n                         * escape which does not start with 0 and which when\n                         * evaluated as decimal could refer to an already\n                         * parsed capture buffer is a back reference. Anything\n                         * else is octal.\n                         *\n                         * Note this implies that \\118 could be interpreted as\n                         * 118 OR as \"\\11\" . \"8\" depending on whether there\n                         * were 118 capture buffers defined already in the\n                         * pattern.  */\n\n                        /* NOTE, RExC_npar is 1 more than the actual number of\n                         * parens we have seen so far, hence the \"<\" as opposed\n                         * to \"<=\" */\n                        if ( !isDIGIT(p[1]) || S_backref_value(p, RExC_end) < RExC_npar)\n                        {  /* Not to be treated as an octal constant, go\n                                   find backref */\n                            --p;\n                            goto loopdone;\n                        }\n                        /* FALLTHROUGH */\n                    case '0':\n\t\t\t{\n\t\t\t    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;\n\t\t\t    STRLEN numlen = 3;\n\t\t\t    ender = grok_oct(p, &numlen, &flags, NULL);\n\t\t\t    p += numlen;\n                            if (   isDIGIT(*p)  /* like \\08, \\178 */\n                                && ckWARN(WARN_REGEXP)\n                                && numlen < 3)\n                            {\n\t\t\t\treg_warn_non_literal_string(\n                                         p + 1,\n                                         form_short_octal_warning(p, numlen));\n                            }\n\t\t\t}\n\t\t\tbreak;\n\t\t    case '\\0':\n\t\t\tif (p >= RExC_end)\n\t\t\t    FAIL(\"Trailing \\\\\");\n\t\t\t/* FALLTHROUGH */\n\t\t    default:\n\t\t\tif (isALPHANUMERIC(*p)) {\n                            /* An alpha followed by '{' is going to fail next\n                             * iteration, so don't output this warning in that\n                             * case */\n                            if (! isALPHA(*p) || *(p + 1) != '{') {\n                                ckWARN2reg(p + 1, \"Unrecognized escape \\\\%.1s\"\n                                                  \" passed through\", p);\n                            }\n\t\t\t}\n\t\t\tgoto normal_default;\n\t\t    } /* End of switch on '\\' */\n\t\t    break;\n\t\tcase '{':\n                    /* Trying to gain new uses for '{' without breaking too\n                     * much existing code is hard.  The solution currently\n                     * adopted is:\n                     *  1)  If there is no ambiguity that a '{' should always\n                     *      be taken literally, at the start of a construct, we\n                     *      just do so.\n                     *  2)  If the literal '{' conflicts with our desired use\n                     *      of it as a metacharacter, we die.  The deprecation\n                     *      cycles for this have come and gone.\n                     *  3)  If there is ambiguity, we raise a simple warning.\n                     *      This could happen, for example, if the user\n                     *      intended it to introduce a quantifier, but slightly\n                     *      misspelled the quantifier.  Without this warning,\n                     *      the quantifier would silently be taken as a literal\n                     *      string of characters instead of a meta construct */\n\t\t    if (len || (p > RExC_start && isALPHA_A(*(p - 1)))) {\n                        if (      RExC_strict\n                            || (  p > parse_start + 1\n                                && isALPHA_A(*(p - 1))\n                                && *(p - 2) == '\\\\')\n                            || new_regcurly(p, RExC_end))\n                        {\n                            RExC_parse = p + 1;\n                            vFAIL(\"Unescaped left brace in regex is \"\n                                  \"illegal here\");\n                        }\n                        ckWARNreg(p + 1, \"Unescaped left brace in regex is\"\n                                         \" passed through\");\n\t\t    }\n\t\t    goto normal_default;\n                case '}':\n                case ']':\n                    if (p > RExC_parse && RExC_strict) {\n                        ckWARN2reg(p + 1, \"Unescaped literal '%c'\", *p);\n                    }\n\t\t    /*FALLTHROUGH*/\n\t\tdefault:    /* A literal character */\n\t\t  normal_default:\n\t\t    if (! UTF8_IS_INVARIANT(*p) && UTF) {\n\t\t\tSTRLEN numlen;\n\t\t\tender = utf8n_to_uvchr((U8*)p, RExC_end - p,\n\t\t\t\t\t       &numlen, UTF8_ALLOW_DEFAULT);\n\t\t\tp += numlen;\n\t\t    }\n\t\t    else\n\t\t\tender = (U8) *p++;\n\t\t    break;\n\t\t} /* End of switch on the literal */\n\n\t\t/* Here, have looked at the literal character, and <ender>\n                 * contains its ordinal; <p> points to the character after it.\n                 * */\n\n                if (ender > 255) {\n                    REQUIRE_UTF8(flagp);\n                }\n\n                /* We need to check if the next non-ignored thing is a\n                 * quantifier.  Move <p> to after anything that should be\n                 * ignored, which, as a side effect, positions <p> for the next\n                 * loop iteration */\n                skip_to_be_ignored_text(pRExC_state, &p,\n                                        FALSE /* Don't force to /x */ );\n\n                /* If the next thing is a quantifier, it applies to this\n                 * character only, which means that this character has to be in\n                 * its own node and can't just be appended to the string in an\n                 * existing node, so if there are already other characters in\n                 * the node, close the node with just them, and set up to do\n                 * this character again next time through, when it will be the\n                 * only thing in its new node */\n\n                next_is_quantifier =    LIKELY(p < RExC_end)\n                                     && UNLIKELY(ISMULT2(p));\n\n                if (next_is_quantifier && LIKELY(len)) {\n                    p = oldp;\n                    goto loopdone;\n                }\n\n                /* Ready to add 'ender' to the node */\n\n                if (! FOLD) {  /* The simple case, just append the literal */\n\n                      not_fold_common:\n                        if (UVCHR_IS_INVARIANT(ender) || ! UTF) {\n                            *(s++) = (char) ender;\n                        }\n                        else {\n                            U8 * new_s = uvchr_to_utf8((U8*)s, ender);\n                            added_len = (char *) new_s - s;\n                            s = (char *) new_s;\n\n                            if (ender > 255)  {\n                                requires_utf8_target = TRUE;\n                            }\n                        }\n                }\n                else if (LOC && is_PROBLEMATIC_LOCALE_FOLD_cp(ender)) {\n\n                    /* Here are folding under /l, and the code point is\n                     * problematic.  If this is the first character in the\n                     * node, change the node type to folding.   Otherwise, if\n                     * this is the first problematic character, close up the\n                     * existing node, so can start a new node with this one */\n                    if (! len) {\n                        node_type = EXACTFL;\n                        RExC_contains_locale = 1;\n                    }\n                    else if (node_type == EXACT) {\n                        p = oldp;\n                        goto loopdone;\n                    }\n\n                    /* This problematic code point means we can't simplify\n                     * things */\n                    maybe_exactfu = FALSE;\n\n                    /* Here, we are adding a problematic fold character.\n                     * \"Problematic\" in this context means that its fold isn't\n                     * known until runtime.  (The non-problematic code points\n                     * are the above-Latin1 ones that fold to also all\n                     * above-Latin1.  Their folds don't vary no matter what the\n                     * locale is.) But here we have characters whose fold\n                     * depends on the locale.  We just add in the unfolded\n                     * character, and wait until runtime to fold it */\n                    goto not_fold_common;\n                }\n                else /* regular fold; see if actually is in a fold */\n                     if (   (ender < 256 && ! IS_IN_SOME_FOLD_L1(ender))\n                         || (ender > 255\n                            && ! _invlist_contains_cp(PL_in_some_fold, ender)))\n                {\n                    /* Here, folding, but the character isn't in a fold.\n                     *\n                     * Start a new node if previous characters in the node were\n                     * folded */\n                    if (len && node_type != EXACT) {\n                        p = oldp;\n                        goto loopdone;\n                    }\n\n                    /* Here, continuing a node with non-folded characters.  Add\n                     * this one */\n                    goto not_fold_common;\n                }\n                else {  /* Here, does participate in some fold */\n\n                    /* If this is the first character in the node, change its\n                     * type to folding.  Otherwise, if this is the first\n                     * folding character in the node, close up the existing\n                     * node, so can start a new node with this one.  */\n                    if (! len) {\n                        node_type = compute_EXACTish(pRExC_state);\n                    }\n                    else if (node_type == EXACT) {\n                        p = oldp;\n                        goto loopdone;\n                    }\n\n                    if (UTF) {  /* Use the folded value */\n                        if (UVCHR_IS_INVARIANT(ender)) {\n                            *(s)++ = (U8) toFOLD(ender);\n                        }\n                        else {\n                            ender = _to_uni_fold_flags(\n                                    ender,\n                                    (U8 *) s,\n                                    &added_len,\n                                    FOLD_FLAGS_FULL | ((ASCII_FOLD_RESTRICTED)\n                                                    ? FOLD_FLAGS_NOMIX_ASCII\n                                                    : 0));\n                            s += added_len;\n\n                            if (   ender > 255\n                                && LIKELY(ender != GREEK_SMALL_LETTER_MU))\n                            {\n                                /* U+B5 folds to the MU, so its possible for a\n                                 * non-UTF-8 target to match it */\n                                requires_utf8_target = TRUE;\n                            }\n                        }\n                    }\n                    else {\n\n                        /* Here is non-UTF8.  First, see if the character's\n                         * fold differs between /d and /u. */\n                        if (PL_fold[ender] != PL_fold_latin1[ender]) {\n                            maybe_exactfu = FALSE;\n                        }\n\n#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \\\n   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \\\n                                      || UNICODE_DOT_DOT_VERSION > 0)\n\n                        /* On non-ancient Unicode versions, this includes the\n                         * multi-char fold SHARP S to 'ss' */\n\n                        if (   UNLIKELY(ender == LATIN_SMALL_LETTER_SHARP_S)\n                                 || (   isALPHA_FOLD_EQ(ender, 's')\n                                     && len > 0\n                                     && isALPHA_FOLD_EQ(*(s-1), 's')))\n                        {\n                            /* Here, we have one of the following:\n                             *  a)  a SHARP S.  This folds to 'ss' only under\n                             *      /u rules.  If we are in that situation,\n                             *      fold the SHARP S to 'ss'.  See the comments\n                             *      for join_exact() as to why we fold this\n                             *      non-UTF at compile time, and no others.\n                             *  b)  'ss'.  When under /u, there's nothing\n                             *      special needed to be done here.  The\n                             *      previous iteration handled the first 's',\n                             *      and this iteration will handle the second.\n                             *      If, on the otherhand it's not /u, we have\n                             *      to exclude the possibility of moving to /u,\n                             *      so that we won't generate an unwanted\n                             *      match, unless, at runtime, the target\n                             *      string is in UTF-8.\n                             * */\n\n                            has_ss = TRUE;\n                            maybe_exactfu = FALSE;  /* Can't generate an\n                                                       EXACTFU node (unless we\n                                                       already are in one) */\n                            if (UNLIKELY(ender == LATIN_SMALL_LETTER_SHARP_S)) {\n                                maybe_SIMPLE = 0;\n                                if (node_type == EXACTFU) {\n                                    *(s++) = 's';\n\n                                    /* Let the code below add in the extra 's' */\n                                    ender = 's';\n                                    added_len = 2;\n                                }\n                            }\n                        }\n#endif\n\n                        else if (UNLIKELY(ender == MICRO_SIGN)) {\n                            has_micro_sign = TRUE;\n                        }\n\n                        *(s++) = (DEPENDS_SEMANTICS)\n                                 ? (char) toFOLD(ender)\n\n                                   /* Under /u, the fold of any character in\n                                    * the 0-255 range happens to be its\n                                    * lowercase equivalent, except for LATIN\n                                    * SMALL LETTER SHARP S, which was handled\n                                    * above, and the MICRO SIGN, whose fold\n                                    * requires UTF-8 to represent.  */\n                                 : (char) toLOWER_L1(ender);\n                    }\n\t\t} /* End of adding current character to the node */\n\n                len += added_len;\n\n\t\tif (next_is_quantifier) {\n\n                    /* Here, the next input is a quantifier, and to get here,\n                     * the current character is the only one in the node. */\n                    goto loopdone;\n\t\t}\n\n\t    } /* End of loop through literal characters */\n\n            /* Here we have either exhausted the input or ran out of room in\n             * the node.  (If we encountered a character that can't be in the\n             * node, transfer is made directly to <loopdone>, and so we\n             * wouldn't have fallen off the end of the loop.)  In the latter\n             * case, we artificially have to split the node into two, because\n             * we just don't have enough space to hold everything.  This\n             * creates a problem if the final character participates in a\n             * multi-character fold in the non-final position, as a match that\n             * should have occurred won't, due to the way nodes are matched,\n             * and our artificial boundary.  So back off until we find a non-\n             * problematic character -- one that isn't at the beginning or\n             * middle of such a fold.  (Either it doesn't participate in any\n             * folds, or appears only in the final position of all the folds it\n             * does participate in.)  A better solution with far fewer false\n             * positives, and that would fill the nodes more completely, would\n             * be to actually have available all the multi-character folds to\n             * test against, and to back-off only far enough to be sure that\n             * this node isn't ending with a partial one.  <upper_parse> is set\n             * further below (if we need to reparse the node) to include just\n             * up through that final non-problematic character that this code\n             * identifies, so when it is set to less than the full node, we can\n             * skip the rest of this */\n            if (FOLD && p < RExC_end && upper_parse == MAX_NODE_STRING_SIZE) {\n                PERL_UINT_FAST8_T backup_count = 0;\n\n                const STRLEN full_len = len;\n\n\t\tassert(len >= MAX_NODE_STRING_SIZE);\n\n                /* Here, <s> points to just beyond where we have output the\n                 * final character of the node.  Look backwards through the\n                 * string until find a non- problematic character */\n\n\t\tif (! UTF) {\n\n                    /* This has no multi-char folds to non-UTF characters */\n                    if (ASCII_FOLD_RESTRICTED) {\n                        goto loopdone;\n                    }\n\n                    while (--s >= s0 && IS_NON_FINAL_FOLD(*s)) {\n                        backup_count++;\n                    }\n                    len = s - s0 + 1;\n\t\t}\n                else {\n\n                    /* Point to the first byte of the final character */\n                    s = (char *) utf8_hop_back((U8 *) s, -1, (U8 *) s0);\n\n                    while (s >= s0) {   /* Search backwards until find\n                                           a non-problematic char */\n                        if (UTF8_IS_INVARIANT(*s)) {\n\n                            /* There are no ascii characters that participate\n                             * in multi-char folds under /aa.  In EBCDIC, the\n                             * non-ascii invariants are all control characters,\n                             * so don't ever participate in any folds. */\n                            if (ASCII_FOLD_RESTRICTED\n                                || ! IS_NON_FINAL_FOLD(*s))\n                            {\n                                break;\n                            }\n                        }\n                        else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {\n                            if (! IS_NON_FINAL_FOLD(EIGHT_BIT_UTF8_TO_NATIVE(\n                                                                  *s, *(s+1))))\n                            {\n                                break;\n                            }\n                        }\n                        else if (! _invlist_contains_cp(\n                                        PL_NonFinalFold,\n                                        valid_utf8_to_uvchr((U8 *) s, NULL)))\n                        {\n                            break;\n                        }\n\n                        /* Here, the current character is problematic in that\n                         * it does occur in the non-final position of some\n                         * fold, so try the character before it, but have to\n                         * special case the very first byte in the string, so\n                         * we don't read outside the string */\n                        s = (s == s0) ? s -1 : (char *) utf8_hop((U8 *) s, -1);\n                        backup_count++;\n                    } /* End of loop backwards through the string */\n\n                    /* If there were only problematic characters in the string,\n                     * <s> will point to before s0, in which case the length\n                     * should be 0, otherwise include the length of the\n                     * non-problematic character just found */\n                    len = (s < s0) ? 0 : s - s0 + UTF8SKIP(s);\n\t\t}\n\n                /* Here, have found the final character, if any, that is\n                 * non-problematic as far as ending the node without splitting\n                 * it across a potential multi-char fold.  <len> contains the\n                 * number of bytes in the node up-to and including that\n                 * character, or is 0 if there is no such character, meaning\n                 * the whole node contains only problematic characters.  In\n                 * this case, give up and just take the node as-is.  We can't\n                 * do any better */\n                if (len == 0) {\n                    len = full_len;\n\n                } else {\n\n                    /* Here, the node does contain some characters that aren't\n                     * problematic.  If we didn't have to backup any, then the\n                     * final character in the node is non-problematic, and we\n                     * can take the node as-is */\n                    if (backup_count == 0) {\n                        goto loopdone;\n                    }\n                    else if (backup_count == 1) {\n\n                        /* If the final character is problematic, but the\n                         * penultimate is not, back-off that last character to\n                         * later start a new node with it */\n                        p = oldp;\n                        goto loopdone;\n                    }\n\n                    /* Here, the final non-problematic character is earlier\n                     * in the input than the penultimate character.  What we do\n                     * is reparse from the beginning, going up only as far as\n                     * this final ok one, thus guaranteeing that the node ends\n                     * in an acceptable character.  The reason we reparse is\n                     * that we know how far in the character is, but we don't\n                     * know how to correlate its position with the input parse.\n                     * An alternate implementation would be to build that\n                     * correlation as we go along during the original parse,\n                     * but that would entail extra work for every node, whereas\n                     * this code gets executed only when the string is too\n                     * large for the node, and the final two characters are\n                     * problematic, an infrequent occurrence.  Yet another\n                     * possible strategy would be to save the tail of the\n                     * string, and the next time regatom is called, initialize\n                     * with that.  The problem with this is that unless you\n                     * back off one more character, you won't be guaranteed\n                     * regatom will get called again, unless regbranch,\n                     * regpiece ... are also changed.  If you do back off that\n                     * extra character, so that there is input guaranteed to\n                     * force calling regatom, you can't handle the case where\n                     * just the first character in the node is acceptable.  I\n                     * (khw) decided to try this method which doesn't have that\n                     * pitfall; if performance issues are found, we can do a\n                     * combination of the current approach plus that one */\n                    upper_parse = len;\n                    len = 0;\n                    s = s0;\n                    goto reparse;\n                }\n\t    }   /* End of verifying node ends with an appropriate char */\n\n          loopdone:   /* Jumped to when encounters something that shouldn't be\n                         in the node */\n\n            /* Free up any over-allocated space; cast is to silence bogus\n             * warning in MS VC */\n            change_engine_size(pRExC_state,\n                                - (Ptrdiff_t) (initial_size - STR_SZ(len)));\n\n            /* I (khw) don't know if you can get here with zero length, but the\n             * old code handled this situation by creating a zero-length EXACT\n             * node.  Might as well be NOTHING instead */\n            if (len == 0) {\n                OP(REGNODE_p(ret)) = NOTHING;\n            }\n            else {\n\n                /* If the node type is EXACT here, check to see if it\n                 * should be EXACTL, or EXACT_ONLY8. */\n                if (node_type == EXACT) {\n                    if (LOC) {\n                        node_type = EXACTL;\n                    }\n                    else if (requires_utf8_target) {\n                        node_type = EXACT_ONLY8;\n                    }\n                } else if (FOLD) {\n                    if (    UNLIKELY(has_micro_sign || has_ss)\n                        && (node_type == EXACTFU || (   node_type == EXACTF\n                                                     && maybe_exactfu)))\n                    {   /* These two conditions are problematic in non-UTF-8\n                           EXACTFU nodes. */\n                        assert(! UTF);\n                        node_type = EXACTFUP;\n                    }\n                    else if (node_type == EXACTFL) {\n\n                        /* 'maybe_exactfu' is deliberately set above to\n                         * indicate this node type, where all code points in it\n                         * are above 255 */\n                        if (maybe_exactfu) {\n                            node_type = EXACTFLU8;\n                        }\n                        else if (UNLIKELY(\n                             _invlist_contains_cp(PL_HasMultiCharFold, ender)))\n                        {\n                            /* A character that folds to more than one will\n                             * match multiple characters, so can't be SIMPLE.\n                             * We don't have to worry about this with EXACTFLU8\n                             * nodes just above, as they have already been\n                             * folded (since the fold doesn't vary at run\n                             * time).  Here, if the final character in the node\n                             * folds to multiple, it can't be simple.  (This\n                             * only has an effect if the node has only a single\n                             * character, hence the final one, as elsewhere we\n                             * turn off simple for nodes whose length > 1 */\n                            maybe_SIMPLE = 0;\n                        }\n                    }\n                    else if (node_type == EXACTF) {  /* Means is /di */\n\n                        /* If 'maybe_exactfu' is clear, then we need to stay\n                         * /di.  If it is set, it means there are no code\n                         * points that match differently depending on UTF8ness\n                         * of the target string, so it can become an EXACTFU\n                         * node */\n                        if (! maybe_exactfu) {\n                            RExC_seen_d_op = TRUE;\n                        }\n                        else if (   isALPHA_FOLD_EQ(* STRING(REGNODE_p(ret)), 's')\n                                 || isALPHA_FOLD_EQ(ender, 's'))\n                        {\n                            /* But, if the node begins or ends in an 's' we\n                             * have to defer changing it into an EXACTFU, as\n                             * the node could later get joined with another one\n                             * that ends or begins with 's' creating an 'ss'\n                             * sequence which would then wrongly match the\n                             * sharp s without the target being UTF-8.  We\n                             * create a special node that we resolve later when\n                             * we join nodes together */\n\n                            node_type = EXACTFU_S_EDGE;\n                        }\n                        else {\n                            node_type = EXACTFU;\n                        }\n                    }\n\n                    if (requires_utf8_target && node_type == EXACTFU) {\n                        node_type = EXACTFU_ONLY8;\n                    }\n                }\n\n                OP(REGNODE_p(ret)) = node_type;\n                STR_LEN(REGNODE_p(ret)) = len;\n                RExC_emit += STR_SZ(len);\n\n                /* If the node isn't a single character, it can't be SIMPLE */\n                if (len > (Size_t) ((UTF) ? UVCHR_SKIP(ender) : 1)) {\n                    maybe_SIMPLE = 0;\n                }\n\n                *flagp |= HASWIDTH | maybe_SIMPLE;\n            }\n\n            Set_Node_Length(REGNODE_p(ret), p - parse_start - 1);\n            RExC_parse = p;\n\n\t    {\n\t\t/* len is STRLEN which is unsigned, need to copy to signed */\n\t\tIV iv = len;\n\t\tif (iv < 0)\n\t\t    vFAIL(\"Internal disaster\");\n\t    }\n\n\t} /* End of label 'defchar:' */\n\tbreak;\n    } /* End of giant switch on input character */\n\n    /* Position parse to next real character */\n    skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                            FALSE /* Don't force to /x */ );\n    if (   *RExC_parse == '{'\n        && OP(REGNODE_p(ret)) != SBOL && ! regcurly(RExC_parse))\n    {\n        if (RExC_strict || new_regcurly(RExC_parse, RExC_end)) {\n            RExC_parse++;\n            vFAIL(\"Unescaped left brace in regex is illegal here\");\n        }\n        ckWARNreg(RExC_parse + 1, \"Unescaped left brace in regex is\"\n                                  \" passed through\");\n    }\n\n    return(ret);\n}\n\n\nSTATIC void\nS_populate_ANYOF_from_invlist(pTHX_ regnode *node, SV** invlist_ptr)\n{\n    /* Uses the inversion list '*invlist_ptr' to populate the ANYOF 'node'.  It\n     * sets up the bitmap and any flags, removing those code points from the\n     * inversion list, setting it to NULL should it become completely empty */\n\n    dVAR;\n\n    PERL_ARGS_ASSERT_POPULATE_ANYOF_FROM_INVLIST;\n    assert(PL_regkind[OP(node)] == ANYOF);\n\n    /* There is no bitmap for this node type */\n    if (OP(node) == ANYOFH) {\n        return;\n    }\n\n    ANYOF_BITMAP_ZERO(node);\n    if (*invlist_ptr) {\n\n\t/* This gets set if we actually need to modify things */\n\tbool change_invlist = FALSE;\n\n\tUV start, end;\n\n\t/* Start looking through *invlist_ptr */\n\tinvlist_iterinit(*invlist_ptr);\n\twhile (invlist_iternext(*invlist_ptr, &start, &end)) {\n\t    UV high;\n\t    int i;\n\n            if (end == UV_MAX && start <= NUM_ANYOF_CODE_POINTS) {\n                ANYOF_FLAGS(node) |= ANYOF_MATCHES_ALL_ABOVE_BITMAP;\n            }\n\n\t    /* Quit if are above what we should change */\n\t    if (start >= NUM_ANYOF_CODE_POINTS) {\n\t\tbreak;\n\t    }\n\n\t    change_invlist = TRUE;\n\n\t    /* Set all the bits in the range, up to the max that we are doing */\n\t    high = (end < NUM_ANYOF_CODE_POINTS - 1)\n                   ? end\n                   : NUM_ANYOF_CODE_POINTS - 1;\n\t    for (i = start; i <= (int) high; i++) {\n\t\tif (! ANYOF_BITMAP_TEST(node, i)) {\n\t\t    ANYOF_BITMAP_SET(node, i);\n\t\t}\n\t    }\n\t}\n\tinvlist_iterfinish(*invlist_ptr);\n\n        /* Done with loop; remove any code points that are in the bitmap from\n         * *invlist_ptr; similarly for code points above the bitmap if we have\n         * a flag to match all of them anyways */\n\tif (change_invlist) {\n\t    _invlist_subtract(*invlist_ptr, PL_InBitmap, invlist_ptr);\n\t}\n        if (ANYOF_FLAGS(node) & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {\n\t    _invlist_intersection(*invlist_ptr, PL_InBitmap, invlist_ptr);\n\t}\n\n\t/* If have completely emptied it, remove it completely */\n\tif (_invlist_len(*invlist_ptr) == 0) {\n\t    SvREFCNT_dec_NN(*invlist_ptr);\n\t    *invlist_ptr = NULL;\n\t}\n    }\n}\n\n/* Parse POSIX character classes: [[:foo:]], [[=foo=]], [[.foo.]].\n   Character classes ([:foo:]) can also be negated ([:^foo:]).\n   Returns a named class id (ANYOF_XXX) if successful, -1 otherwise.\n   Equivalence classes ([=foo=]) and composites ([.foo.]) are parsed,\n   but trigger failures because they are currently unimplemented. */\n\n#define POSIXCC_DONE(c)   ((c) == ':')\n#define POSIXCC_NOTYET(c) ((c) == '=' || (c) == '.')\n#define POSIXCC(c) (POSIXCC_DONE(c) || POSIXCC_NOTYET(c))\n#define MAYBE_POSIXCC(c) (POSIXCC(c) || (c) == '^' || (c) == ';')\n\n#define WARNING_PREFIX              \"Assuming NOT a POSIX class since \"\n#define NO_BLANKS_POSIX_WARNING     \"no blanks are allowed in one\"\n#define SEMI_COLON_POSIX_WARNING    \"a semi-colon was found instead of a colon\"\n\n#define NOT_MEANT_TO_BE_A_POSIX_CLASS (OOB_NAMEDCLASS - 1)\n\n/* 'posix_warnings' and 'warn_text' are names of variables in the following\n * routine. q.v. */\n#define ADD_POSIX_WARNING(p, text)  STMT_START {                            \\\n        if (posix_warnings) {                                               \\\n            if (! RExC_warn_text ) RExC_warn_text =                         \\\n                                         (AV *) sv_2mortal((SV *) newAV()); \\\n            av_push(RExC_warn_text, Perl_newSVpvf(aTHX_                     \\\n                                             WARNING_PREFIX                 \\\n                                             text                           \\\n                                             REPORT_LOCATION,               \\\n                                             REPORT_LOCATION_ARGS(p)));     \\\n        }                                                                   \\\n    } STMT_END\n#define CLEAR_POSIX_WARNINGS()                                              \\\n    STMT_START {                                                            \\\n        if (posix_warnings && RExC_warn_text)                               \\\n            av_clear(RExC_warn_text);                                       \\\n    } STMT_END\n\n#define CLEAR_POSIX_WARNINGS_AND_RETURN(ret)                                \\\n    STMT_START {                                                            \\\n        CLEAR_POSIX_WARNINGS();                                             \\\n        return ret;                                                         \\\n    } STMT_END\n\nSTATIC int\nS_handle_possible_posix(pTHX_ RExC_state_t *pRExC_state,\n\n    const char * const s,      /* Where the putative posix class begins.\n                                  Normally, this is one past the '['.  This\n                                  parameter exists so it can be somewhere\n                                  besides RExC_parse. */\n    char ** updated_parse_ptr, /* Where to set the updated parse pointer, or\n                                  NULL */\n    AV ** posix_warnings,      /* Where to place any generated warnings, or\n                                  NULL */\n    const bool check_only      /* Don't die if error */\n)\n{\n    /* This parses what the caller thinks may be one of the three POSIX\n     * constructs:\n     *  1) a character class, like [:blank:]\n     *  2) a collating symbol, like [. .]\n     *  3) an equivalence class, like [= =]\n     * In the latter two cases, it croaks if it finds a syntactically legal\n     * one, as these are not handled by Perl.\n     *\n     * The main purpose is to look for a POSIX character class.  It returns:\n     *  a) the class number\n     *      if it is a completely syntactically and semantically legal class.\n     *      'updated_parse_ptr', if not NULL, is set to point to just after the\n     *      closing ']' of the class\n     *  b) OOB_NAMEDCLASS\n     *      if it appears that one of the three POSIX constructs was meant, but\n     *      its specification was somehow defective.  'updated_parse_ptr', if\n     *      not NULL, is set to point to the character just after the end\n     *      character of the class.  See below for handling of warnings.\n     *  c) NOT_MEANT_TO_BE_A_POSIX_CLASS\n     *      if it  doesn't appear that a POSIX construct was intended.\n     *      'updated_parse_ptr' is not changed.  No warnings nor errors are\n     *      raised.\n     *\n     * In b) there may be errors or warnings generated.  If 'check_only' is\n     * TRUE, then any errors are discarded.  Warnings are returned to the\n     * caller via an AV* created into '*posix_warnings' if it is not NULL.  If\n     * instead it is NULL, warnings are suppressed.\n     *\n     * The reason for this function, and its complexity is that a bracketed\n     * character class can contain just about anything.  But it's easy to\n     * mistype the very specific posix class syntax but yielding a valid\n     * regular bracketed class, so it silently gets compiled into something\n     * quite unintended.\n     *\n     * The solution adopted here maintains backward compatibility except that\n     * it adds a warning if it looks like a posix class was intended but\n     * improperly specified.  The warning is not raised unless what is input\n     * very closely resembles one of the 14 legal posix classes.  To do this,\n     * it uses fuzzy parsing.  It calculates how many single-character edits it\n     * would take to transform what was input into a legal posix class.  Only\n     * if that number is quite small does it think that the intention was a\n     * posix class.  Obviously these are heuristics, and there will be cases\n     * where it errs on one side or another, and they can be tweaked as\n     * experience informs.\n     *\n     * The syntax for a legal posix class is:\n     *\n     * qr/(?xa: \\[ : \\^? [[:lower:]]{4,6} : \\] )/\n     *\n     * What this routine considers syntactically to be an intended posix class\n     * is this (the comments indicate some restrictions that the pattern\n     * doesn't show):\n     *\n     *  qr/(?x: \\[?                         # The left bracket, possibly\n     *                                      # omitted\n     *          \\h*                         # possibly followed by blanks\n     *          (?: \\^ \\h* )?               # possibly a misplaced caret\n     *          [:;]?                       # The opening class character,\n     *                                      # possibly omitted.  A typo\n     *                                      # semi-colon can also be used.\n     *          \\h*\n     *          \\^?                         # possibly a correctly placed\n     *                                      # caret, but not if there was also\n     *                                      # a misplaced one\n     *          \\h*\n     *          .{3,15}                     # The class name.  If there are\n     *                                      # deviations from the legal syntax,\n     *                                      # its edit distance must be close\n     *                                      # to a real class name in order\n     *                                      # for it to be considered to be\n     *                                      # an intended posix class.\n     *          \\h*\n     *          [[:punct:]]?                # The closing class character,\n     *                                      # possibly omitted.  If not a colon\n     *                                      # nor semi colon, the class name\n     *                                      # must be even closer to a valid\n     *                                      # one\n     *          \\h*\n     *          \\]?                         # The right bracket, possibly\n     *                                      # omitted.\n     *     )/\n     *\n     * In the above, \\h must be ASCII-only.\n     *\n     * These are heuristics, and can be tweaked as field experience dictates.\n     * There will be cases when someone didn't intend to specify a posix class\n     * that this warns as being so.  The goal is to minimize these, while\n     * maximizing the catching of things intended to be a posix class that\n     * aren't parsed as such.\n     */\n\n    const char* p             = s;\n    const char * const e      = RExC_end;\n    unsigned complement       = 0;      /* If to complement the class */\n    bool found_problem        = FALSE;  /* Assume OK until proven otherwise */\n    bool has_opening_bracket  = FALSE;\n    bool has_opening_colon    = FALSE;\n    int class_number          = OOB_NAMEDCLASS; /* Out-of-bounds until find\n                                                   valid class */\n    const char * possible_end = NULL;   /* used for a 2nd parse pass */\n    const char* name_start;             /* ptr to class name first char */\n\n    /* If the number of single-character typos the input name is away from a\n     * legal name is no more than this number, it is considered to have meant\n     * the legal name */\n    int max_distance          = 2;\n\n    /* to store the name.  The size determines the maximum length before we\n     * decide that no posix class was intended.  Should be at least\n     * sizeof(\"alphanumeric\") */\n    UV input_text[15];\n    STATIC_ASSERT_DECL(C_ARRAY_LENGTH(input_text) >= sizeof \"alphanumeric\");\n\n    PERL_ARGS_ASSERT_HANDLE_POSSIBLE_POSIX;\n\n    CLEAR_POSIX_WARNINGS();\n\n    if (p >= e) {\n        return NOT_MEANT_TO_BE_A_POSIX_CLASS;\n    }\n\n    if (*(p - 1) != '[') {\n        ADD_POSIX_WARNING(p, \"it doesn't start with a '['\");\n        found_problem = TRUE;\n    }\n    else {\n        has_opening_bracket = TRUE;\n    }\n\n    /* They could be confused and think you can put spaces between the\n     * components */\n    if (isBLANK(*p)) {\n        found_problem = TRUE;\n\n        do {\n            p++;\n        } while (p < e && isBLANK(*p));\n\n        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n    }\n\n    /* For [. .] and [= =].  These are quite different internally from [: :],\n     * so they are handled separately.  */\n    if (POSIXCC_NOTYET(*p) && p < e - 3) /* 1 for the close, and 1 for the ']'\n                                            and 1 for at least one char in it\n                                          */\n    {\n        const char open_char  = *p;\n        const char * temp_ptr = p + 1;\n\n        /* These two constructs are not handled by perl, and if we find a\n         * syntactically valid one, we croak.  khw, who wrote this code, finds\n         * this explanation of them very unclear:\n         * http://pubs.opengroup.org/onlinepubs/009696899/basedefs/xbd_chap09.html\n         * And searching the rest of the internet wasn't very helpful either.\n         * It looks like just about any byte can be in these constructs,\n         * depending on the locale.  But unless the pattern is being compiled\n         * under /l, which is very rare, Perl runs under the C or POSIX locale.\n         * In that case, it looks like [= =] isn't allowed at all, and that\n         * [. .] could be any single code point, but for longer strings the\n         * constituent characters would have to be the ASCII alphabetics plus\n         * the minus-hyphen.  Any sensible locale definition would limit itself\n         * to these.  And any portable one definitely should.  Trying to parse\n         * the general case is a nightmare (see [perl #127604]).  So, this code\n         * looks only for interiors of these constructs that match:\n         *      qr/.|[-\\w]{2,}/\n         * Using \\w relaxes the apparent rules a little, without adding much\n         * danger of mistaking something else for one of these constructs.\n         *\n         * [. .] in some implementations described on the internet is usable to\n         * escape a character that otherwise is special in bracketed character\n         * classes.  For example [.].] means a literal right bracket instead of\n         * the ending of the class\n         *\n         * [= =] can legitimately contain a [. .] construct, but we don't\n         * handle this case, as that [. .] construct will later get parsed\n         * itself and croak then.  And [= =] is checked for even when not under\n         * /l, as Perl has long done so.\n         *\n         * The code below relies on there being a trailing NUL, so it doesn't\n         * have to keep checking if the parse ptr < e.\n         */\n        if (temp_ptr[1] == open_char) {\n            temp_ptr++;\n        }\n        else while (    temp_ptr < e\n                    && (isWORDCHAR(*temp_ptr) || *temp_ptr == '-'))\n        {\n            temp_ptr++;\n        }\n\n        if (*temp_ptr == open_char) {\n            temp_ptr++;\n            if (*temp_ptr == ']') {\n                temp_ptr++;\n                if (! found_problem && ! check_only) {\n                    RExC_parse = (char *) temp_ptr;\n                    vFAIL3(\"POSIX syntax [%c %c] is reserved for future \"\n                            \"extensions\", open_char, open_char);\n                }\n\n                /* Here, the syntax wasn't completely valid, or else the call\n                 * is to check-only */\n                if (updated_parse_ptr) {\n                    *updated_parse_ptr = (char *) temp_ptr;\n                }\n\n                CLEAR_POSIX_WARNINGS_AND_RETURN(OOB_NAMEDCLASS);\n            }\n        }\n\n        /* If we find something that started out to look like one of these\n         * constructs, but isn't, we continue below so that it can be checked\n         * for being a class name with a typo of '.' or '=' instead of a colon.\n         * */\n    }\n\n    /* Here, we think there is a possibility that a [: :] class was meant, and\n     * we have the first real character.  It could be they think the '^' comes\n     * first */\n    if (*p == '^') {\n        found_problem = TRUE;\n        ADD_POSIX_WARNING(p + 1, \"the '^' must come after the colon\");\n        complement = 1;\n        p++;\n\n        if (isBLANK(*p)) {\n            found_problem = TRUE;\n\n            do {\n                p++;\n            } while (p < e && isBLANK(*p));\n\n            ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n        }\n    }\n\n    /* But the first character should be a colon, which they could have easily\n     * mistyped on a qwerty keyboard as a semi-colon (and which may be hard to\n     * distinguish from a colon, so treat that as a colon).  */\n    if (*p == ':') {\n        p++;\n        has_opening_colon = TRUE;\n    }\n    else if (*p == ';') {\n        found_problem = TRUE;\n        p++;\n        ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);\n        has_opening_colon = TRUE;\n    }\n    else {\n        found_problem = TRUE;\n        ADD_POSIX_WARNING(p, \"there must be a starting ':'\");\n\n        /* Consider an initial punctuation (not one of the recognized ones) to\n         * be a left terminator */\n        if (*p != '^' && *p != ']' && isPUNCT(*p)) {\n            p++;\n        }\n    }\n\n    /* They may think that you can put spaces between the components */\n    if (isBLANK(*p)) {\n        found_problem = TRUE;\n\n        do {\n            p++;\n        } while (p < e && isBLANK(*p));\n\n        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n    }\n\n    if (*p == '^') {\n\n        /* We consider something like [^:^alnum:]] to not have been intended to\n         * be a posix class, but XXX maybe we should */\n        if (complement) {\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        complement = 1;\n        p++;\n    }\n\n    /* Again, they may think that you can put spaces between the components */\n    if (isBLANK(*p)) {\n        found_problem = TRUE;\n\n        do {\n            p++;\n        } while (p < e && isBLANK(*p));\n\n        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n    }\n\n    if (*p == ']') {\n\n        /* XXX This ']' may be a typo, and something else was meant.  But\n         * treating it as such creates enough complications, that that\n         * possibility isn't currently considered here.  So we assume that the\n         * ']' is what is intended, and if we've already found an initial '[',\n         * this leaves this construct looking like [:] or [:^], which almost\n         * certainly weren't intended to be posix classes */\n        if (has_opening_bracket) {\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* But this function can be called when we parse the colon for\n         * something like qr/[alpha:]]/, so we back up to look for the\n         * beginning */\n        p--;\n\n        if (*p == ';') {\n            found_problem = TRUE;\n            ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);\n        }\n        else if (*p != ':') {\n\n            /* XXX We are currently very restrictive here, so this code doesn't\n             * consider the possibility that, say, /[alpha.]]/ was intended to\n             * be a posix class. */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* Here we have something like 'foo:]'.  There was no initial colon,\n         * and we back up over 'foo.  XXX Unlike the going forward case, we\n         * don't handle typos of non-word chars in the middle */\n        has_opening_colon = FALSE;\n        p--;\n\n        while (p > RExC_start && isWORDCHAR(*p)) {\n            p--;\n        }\n        p++;\n\n        /* Here, we have positioned ourselves to where we think the first\n         * character in the potential class is */\n    }\n\n    /* Now the interior really starts.  There are certain key characters that\n     * can end the interior, or these could just be typos.  To catch both\n     * cases, we may have to do two passes.  In the first pass, we keep on\n     * going unless we come to a sequence that matches\n     *      qr/ [[:punct:]] [[:blank:]]* \\] /xa\n     * This means it takes a sequence to end the pass, so two typos in a row if\n     * that wasn't what was intended.  If the class is perfectly formed, just\n     * this one pass is needed.  We also stop if there are too many characters\n     * being accumulated, but this number is deliberately set higher than any\n     * real class.  It is set high enough so that someone who thinks that\n     * 'alphanumeric' is a correct name would get warned that it wasn't.\n     * While doing the pass, we keep track of where the key characters were in\n     * it.  If we don't find an end to the class, and one of the key characters\n     * was found, we redo the pass, but stop when we get to that character.\n     * Thus the key character was considered a typo in the first pass, but a\n     * terminator in the second.  If two key characters are found, we stop at\n     * the second one in the first pass.  Again this can miss two typos, but\n     * catches a single one\n     *\n     * In the first pass, 'possible_end' starts as NULL, and then gets set to\n     * point to the first key character.  For the second pass, it starts as -1.\n     * */\n\n    name_start = p;\n  parse_name:\n    {\n        bool has_blank               = FALSE;\n        bool has_upper               = FALSE;\n        bool has_terminating_colon   = FALSE;\n        bool has_terminating_bracket = FALSE;\n        bool has_semi_colon          = FALSE;\n        unsigned int name_len        = 0;\n        int punct_count              = 0;\n\n        while (p < e) {\n\n            /* Squeeze out blanks when looking up the class name below */\n            if (isBLANK(*p) ) {\n                has_blank = TRUE;\n                found_problem = TRUE;\n                p++;\n                continue;\n            }\n\n            /* The name will end with a punctuation */\n            if (isPUNCT(*p)) {\n                const char * peek = p + 1;\n\n                /* Treat any non-']' punctuation followed by a ']' (possibly\n                 * with intervening blanks) as trying to terminate the class.\n                 * ']]' is very likely to mean a class was intended (but\n                 * missing the colon), but the warning message that gets\n                 * generated shows the error position better if we exit the\n                 * loop at the bottom (eventually), so skip it here. */\n                if (*p != ']') {\n                    if (peek < e && isBLANK(*peek)) {\n                        has_blank = TRUE;\n                        found_problem = TRUE;\n                        do {\n                            peek++;\n                        } while (peek < e && isBLANK(*peek));\n                    }\n\n                    if (peek < e && *peek == ']') {\n                        has_terminating_bracket = TRUE;\n                        if (*p == ':') {\n                            has_terminating_colon = TRUE;\n                        }\n                        else if (*p == ';') {\n                            has_semi_colon = TRUE;\n                            has_terminating_colon = TRUE;\n                        }\n                        else {\n                            found_problem = TRUE;\n                        }\n                        p = peek + 1;\n                        goto try_posix;\n                    }\n                }\n\n                /* Here we have punctuation we thought didn't end the class.\n                 * Keep track of the position of the key characters that are\n                 * more likely to have been class-enders */\n                if (*p == ']' || *p == '[' || *p == ':' || *p == ';') {\n\n                    /* Allow just one such possible class-ender not actually\n                     * ending the class. */\n                    if (possible_end) {\n                        break;\n                    }\n                    possible_end = p;\n                }\n\n                /* If we have too many punctuation characters, no use in\n                 * keeping going */\n                if (++punct_count > max_distance) {\n                    break;\n                }\n\n                /* Treat the punctuation as a typo. */\n                input_text[name_len++] = *p;\n                p++;\n            }\n            else if (isUPPER(*p)) { /* Use lowercase for lookup */\n                input_text[name_len++] = toLOWER(*p);\n                has_upper = TRUE;\n                found_problem = TRUE;\n                p++;\n            } else if (! UTF || UTF8_IS_INVARIANT(*p)) {\n                input_text[name_len++] = *p;\n                p++;\n            }\n            else {\n                input_text[name_len++] = utf8_to_uvchr_buf((U8 *) p, e, NULL);\n                p+= UTF8SKIP(p);\n            }\n\n            /* The declaration of 'input_text' is how long we allow a potential\n             * class name to be, before saying they didn't mean a class name at\n             * all */\n            if (name_len >= C_ARRAY_LENGTH(input_text)) {\n                break;\n            }\n        }\n\n        /* We get to here when the possible class name hasn't been properly\n         * terminated before:\n         *   1) we ran off the end of the pattern; or\n         *   2) found two characters, each of which might have been intended to\n         *      be the name's terminator\n         *   3) found so many punctuation characters in the purported name,\n         *      that the edit distance to a valid one is exceeded\n         *   4) we decided it was more characters than anyone could have\n         *      intended to be one. */\n\n        found_problem = TRUE;\n\n        /* In the final two cases, we know that looking up what we've\n         * accumulated won't lead to a match, even a fuzzy one. */\n        if (   name_len >= C_ARRAY_LENGTH(input_text)\n            || punct_count > max_distance)\n        {\n            /* If there was an intermediate key character that could have been\n             * an intended end, redo the parse, but stop there */\n            if (possible_end && possible_end != (char *) -1) {\n                possible_end = (char *) -1; /* Special signal value to say\n                                               we've done a first pass */\n                p = name_start;\n                goto parse_name;\n            }\n\n            /* Otherwise, it can't have meant to have been a class */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* If we ran off the end, and the final character was a punctuation\n         * one, back up one, to look at that final one just below.  Later, we\n         * will restore the parse pointer if appropriate */\n        if (name_len && p == e && isPUNCT(*(p-1))) {\n            p--;\n            name_len--;\n        }\n\n        if (p < e && isPUNCT(*p)) {\n            if (*p == ']') {\n                has_terminating_bracket = TRUE;\n\n                /* If this is a 2nd ']', and the first one is just below this\n                 * one, consider that to be the real terminator.  This gives a\n                 * uniform and better positioning for the warning message  */\n                if (   possible_end\n                    && possible_end != (char *) -1\n                    && *possible_end == ']'\n                    && name_len && input_text[name_len - 1] == ']')\n                {\n                    name_len--;\n                    p = possible_end;\n\n                    /* And this is actually equivalent to having done the 2nd\n                     * pass now, so set it to not try again */\n                    possible_end = (char *) -1;\n                }\n            }\n            else {\n                if (*p == ':') {\n                    has_terminating_colon = TRUE;\n                }\n                else if (*p == ';') {\n                    has_semi_colon = TRUE;\n                    has_terminating_colon = TRUE;\n                }\n                p++;\n            }\n        }\n\n    try_posix:\n\n        /* Here, we have a class name to look up.  We can short circuit the\n         * stuff below for short names that can't possibly be meant to be a\n         * class name.  (We can do this on the first pass, as any second pass\n         * will yield an even shorter name) */\n        if (name_len < 3) {\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* Find which class it is.  Initially switch on the length of the name.\n         * */\n        switch (name_len) {\n            case 4:\n                if (memEQs(name_start, 4, \"word\")) {\n                    /* this is not POSIX, this is the Perl \\w */\n                    class_number = ANYOF_WORDCHAR;\n                }\n                break;\n            case 5:\n                /* Names all of length 5: alnum alpha ascii blank cntrl digit\n                 *                        graph lower print punct space upper\n                 * Offset 4 gives the best switch position.  */\n                switch (name_start[4]) {\n                    case 'a':\n                        if (memBEGINs(name_start, 5, \"alph\")) /* alpha */\n                            class_number = ANYOF_ALPHA;\n                        break;\n                    case 'e':\n                        if (memBEGINs(name_start, 5, \"spac\")) /* space */\n                            class_number = ANYOF_SPACE;\n                        break;\n                    case 'h':\n                        if (memBEGINs(name_start, 5, \"grap\")) /* graph */\n                            class_number = ANYOF_GRAPH;\n                        break;\n                    case 'i':\n                        if (memBEGINs(name_start, 5, \"asci\")) /* ascii */\n                            class_number = ANYOF_ASCII;\n                        break;\n                    case 'k':\n                        if (memBEGINs(name_start, 5, \"blan\")) /* blank */\n                            class_number = ANYOF_BLANK;\n                        break;\n                    case 'l':\n                        if (memBEGINs(name_start, 5, \"cntr\")) /* cntrl */\n                            class_number = ANYOF_CNTRL;\n                        break;\n                    case 'm':\n                        if (memBEGINs(name_start, 5, \"alnu\")) /* alnum */\n                            class_number = ANYOF_ALPHANUMERIC;\n                        break;\n                    case 'r':\n                        if (memBEGINs(name_start, 5, \"lowe\")) /* lower */\n                            class_number = (FOLD) ? ANYOF_CASED : ANYOF_LOWER;\n                        else if (memBEGINs(name_start, 5, \"uppe\")) /* upper */\n                            class_number = (FOLD) ? ANYOF_CASED : ANYOF_UPPER;\n                        break;\n                    case 't':\n                        if (memBEGINs(name_start, 5, \"digi\")) /* digit */\n                            class_number = ANYOF_DIGIT;\n                        else if (memBEGINs(name_start, 5, \"prin\")) /* print */\n                            class_number = ANYOF_PRINT;\n                        else if (memBEGINs(name_start, 5, \"punc\")) /* punct */\n                            class_number = ANYOF_PUNCT;\n                        break;\n                }\n                break;\n            case 6:\n                if (memEQs(name_start, 6, \"xdigit\"))\n                    class_number = ANYOF_XDIGIT;\n                break;\n        }\n\n        /* If the name exactly matches a posix class name the class number will\n         * here be set to it, and the input almost certainly was meant to be a\n         * posix class, so we can skip further checking.  If instead the syntax\n         * is exactly correct, but the name isn't one of the legal ones, we\n         * will return that as an error below.  But if neither of these apply,\n         * it could be that no posix class was intended at all, or that one\n         * was, but there was a typo.  We tease these apart by doing fuzzy\n         * matching on the name */\n        if (class_number == OOB_NAMEDCLASS && found_problem) {\n            const UV posix_names[][6] = {\n                                                { 'a', 'l', 'n', 'u', 'm' },\n                                                { 'a', 'l', 'p', 'h', 'a' },\n                                                { 'a', 's', 'c', 'i', 'i' },\n                                                { 'b', 'l', 'a', 'n', 'k' },\n                                                { 'c', 'n', 't', 'r', 'l' },\n                                                { 'd', 'i', 'g', 'i', 't' },\n                                                { 'g', 'r', 'a', 'p', 'h' },\n                                                { 'l', 'o', 'w', 'e', 'r' },\n                                                { 'p', 'r', 'i', 'n', 't' },\n                                                { 'p', 'u', 'n', 'c', 't' },\n                                                { 's', 'p', 'a', 'c', 'e' },\n                                                { 'u', 'p', 'p', 'e', 'r' },\n                                                { 'w', 'o', 'r', 'd' },\n                                                { 'x', 'd', 'i', 'g', 'i', 't' }\n                                            };\n            /* The names of the above all have added NULs to make them the same\n             * size, so we need to also have the real lengths */\n            const UV posix_name_lengths[] = {\n                                                sizeof(\"alnum\") - 1,\n                                                sizeof(\"alpha\") - 1,\n                                                sizeof(\"ascii\") - 1,\n                                                sizeof(\"blank\") - 1,\n                                                sizeof(\"cntrl\") - 1,\n                                                sizeof(\"digit\") - 1,\n                                                sizeof(\"graph\") - 1,\n                                                sizeof(\"lower\") - 1,\n                                                sizeof(\"print\") - 1,\n                                                sizeof(\"punct\") - 1,\n                                                sizeof(\"space\") - 1,\n                                                sizeof(\"upper\") - 1,\n                                                sizeof(\"word\")  - 1,\n                                                sizeof(\"xdigit\")- 1\n                                            };\n            unsigned int i;\n            int temp_max = max_distance;    /* Use a temporary, so if we\n                                               reparse, we haven't changed the\n                                               outer one */\n\n            /* Use a smaller max edit distance if we are missing one of the\n             * delimiters */\n            if (   has_opening_bracket + has_opening_colon < 2\n                || has_terminating_bracket + has_terminating_colon < 2)\n            {\n                temp_max--;\n            }\n\n            /* See if the input name is close to a legal one */\n            for (i = 0; i < C_ARRAY_LENGTH(posix_names); i++) {\n\n                /* Short circuit call if the lengths are too far apart to be\n                 * able to match */\n                if (abs( (int) (name_len - posix_name_lengths[i]))\n                    > temp_max)\n                {\n                    continue;\n                }\n\n                if (edit_distance(input_text,\n                                  posix_names[i],\n                                  name_len,\n                                  posix_name_lengths[i],\n                                  temp_max\n                                 )\n                    > -1)\n                { /* If it is close, it probably was intended to be a class */\n                    goto probably_meant_to_be;\n                }\n            }\n\n            /* Here the input name is not close enough to a valid class name\n             * for us to consider it to be intended to be a posix class.  If\n             * we haven't already done so, and the parse found a character that\n             * could have been terminators for the name, but which we absorbed\n             * as typos during the first pass, repeat the parse, signalling it\n             * to stop at that character */\n            if (possible_end && possible_end != (char *) -1) {\n                possible_end = (char *) -1;\n                p = name_start;\n                goto parse_name;\n            }\n\n            /* Here neither pass found a close-enough class name */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n    probably_meant_to_be:\n\n        /* Here we think that a posix specification was intended.  Update any\n         * parse pointer */\n        if (updated_parse_ptr) {\n            *updated_parse_ptr = (char *) p;\n        }\n\n        /* If a posix class name was intended but incorrectly specified, we\n         * output or return the warnings */\n        if (found_problem) {\n\n            /* We set flags for these issues in the parse loop above instead of\n             * adding them to the list of warnings, because we can parse it\n             * twice, and we only want one warning instance */\n            if (has_upper) {\n                ADD_POSIX_WARNING(p, \"the name must be all lowercase letters\");\n            }\n            if (has_blank) {\n                ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n            }\n            if (has_semi_colon) {\n                ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);\n            }\n            else if (! has_terminating_colon) {\n                ADD_POSIX_WARNING(p, \"there is no terminating ':'\");\n            }\n            if (! has_terminating_bracket) {\n                ADD_POSIX_WARNING(p, \"there is no terminating ']'\");\n            }\n\n            if (   posix_warnings\n                && RExC_warn_text\n                && av_top_index(RExC_warn_text) > -1)\n            {\n                *posix_warnings = RExC_warn_text;\n            }\n        }\n        else if (class_number != OOB_NAMEDCLASS) {\n            /* If it is a known class, return the class.  The class number\n             * #defines are structured so each complement is +1 to the normal\n             * one */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(class_number + complement);\n        }\n        else if (! check_only) {\n\n            /* Here, it is an unrecognized class.  This is an error (unless the\n            * call is to check only, which we've already handled above) */\n            const char * const complement_string = (complement)\n                                                   ? \"^\"\n                                                   : \"\";\n            RExC_parse = (char *) p;\n            vFAIL3utf8f(\"POSIX class [:%s%\" UTF8f \":] unknown\",\n                        complement_string,\n                        UTF8fARG(UTF, RExC_parse - name_start - 2, name_start));\n        }\n    }\n\n    return OOB_NAMEDCLASS;\n}\n#undef ADD_POSIX_WARNING\n\nSTATIC unsigned  int\nS_regex_set_precedence(const U8 my_operator) {\n\n    /* Returns the precedence in the (?[...]) construct of the input operator,\n     * specified by its character representation.  The precedence follows\n     * general Perl rules, but it extends this so that ')' and ']' have (low)\n     * precedence even though they aren't really operators */\n\n    switch (my_operator) {\n        case '!':\n            return 5;\n        case '&':\n            return 4;\n        case '^':\n        case '|':\n        case '+':\n        case '-':\n            return 3;\n        case ')':\n            return 2;\n        case ']':\n            return 1;\n    }\n\n    NOT_REACHED; /* NOTREACHED */\n    return 0;   /* Silence compiler warning */\n}\n\nSTATIC regnode_offset\nS_handle_regex_sets(pTHX_ RExC_state_t *pRExC_state, SV** return_invlist,\n                    I32 *flagp, U32 depth,\n                    char * const oregcomp_parse)\n{\n    /* Handle the (?[...]) construct to do set operations */\n\n    U8 curchar;                     /* Current character being parsed */\n    UV start, end;\t            /* End points of code point ranges */\n    SV* final = NULL;               /* The end result inversion list */\n    SV* result_string;              /* 'final' stringified */\n    AV* stack;                      /* stack of operators and operands not yet\n                                       resolved */\n    AV* fence_stack = NULL;         /* A stack containing the positions in\n                                       'stack' of where the undealt-with left\n                                       parens would be if they were actually\n                                       put there */\n    /* The 'volatile' is a workaround for an optimiser bug\n     * in Solaris Studio 12.3. See RT #127455 */\n    volatile IV fence = 0;          /* Position of where most recent undealt-\n                                       with left paren in stack is; -1 if none.\n                                     */\n    STRLEN len;                     /* Temporary */\n    regnode_offset node;                  /* Temporary, and final regnode returned by\n                                       this function */\n    const bool save_fold = FOLD;    /* Temporary */\n    char *save_end, *save_parse;    /* Temporaries */\n    const bool in_locale = LOC;     /* we turn off /l during processing */\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_HANDLE_REGEX_SETS;\n\n    DEBUG_PARSE(\"xcls\");\n\n    if (in_locale) {\n        set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);\n    }\n\n    /* The use of this operator implies /u.  This is required so that the\n     * compile time values are valid in all runtime cases */\n    REQUIRE_UNI_RULES(flagp, 0);\n\n    ckWARNexperimental(RExC_parse,\n                       WARN_EXPERIMENTAL__REGEX_SETS,\n                       \"The regex_sets feature is experimental\");\n\n    /* Everything in this construct is a metacharacter.  Operands begin with\n     * either a '\\' (for an escape sequence), or a '[' for a bracketed\n     * character class.  Any other character should be an operator, or\n     * parenthesis for grouping.  Both types of operands are handled by calling\n     * regclass() to parse them.  It is called with a parameter to indicate to\n     * return the computed inversion list.  The parsing here is implemented via\n     * a stack.  Each entry on the stack is a single character representing one\n     * of the operators; or else a pointer to an operand inversion list. */\n\n#define IS_OPERATOR(a) SvIOK(a)\n#define IS_OPERAND(a)  (! IS_OPERATOR(a))\n\n    /* The stack is kept in \u0141ukasiewicz order.  (That's pronounced similar\n     * to luke-a-shave-itch (or -itz), but people who didn't want to bother\n     * with pronouncing it called it Reverse Polish instead, but now that YOU\n     * know how to pronounce it you can use the correct term, thus giving due\n     * credit to the person who invented it, and impressing your geek friends.\n     * Wikipedia says that the pronounciation of \"\u0141\" has been changing so that\n     * it is now more like an English initial W (as in wonk) than an L.)\n     *\n     * This means that, for example, 'a | b & c' is stored on the stack as\n     *\n     * c  [4]\n     * b  [3]\n     * &  [2]\n     * a  [1]\n     * |  [0]\n     *\n     * where the numbers in brackets give the stack [array] element number.\n     * In this implementation, parentheses are not stored on the stack.\n     * Instead a '(' creates a \"fence\" so that the part of the stack below the\n     * fence is invisible except to the corresponding ')' (this allows us to\n     * replace testing for parens, by using instead subtraction of the fence\n     * position).  As new operands are processed they are pushed onto the stack\n     * (except as noted in the next paragraph).  New operators of higher\n     * precedence than the current final one are inserted on the stack before\n     * the lhs operand (so that when the rhs is pushed next, everything will be\n     * in the correct positions shown above.  When an operator of equal or\n     * lower precedence is encountered in parsing, all the stacked operations\n     * of equal or higher precedence are evaluated, leaving the result as the\n     * top entry on the stack.  This makes higher precedence operations\n     * evaluate before lower precedence ones, and causes operations of equal\n     * precedence to left associate.\n     *\n     * The only unary operator '!' is immediately pushed onto the stack when\n     * encountered.  When an operand is encountered, if the top of the stack is\n     * a '!\", the complement is immediately performed, and the '!' popped.  The\n     * resulting value is treated as a new operand, and the logic in the\n     * previous paragraph is executed.  Thus in the expression\n     *      [a] + ! [b]\n     * the stack looks like\n     *\n     * !\n     * a\n     * +\n     *\n     * as 'b' gets parsed, the latter gets evaluated to '!b', and the stack\n     * becomes\n     *\n     * !b\n     * a\n     * +\n     *\n     * A ')' is treated as an operator with lower precedence than all the\n     * aforementioned ones, which causes all operations on the stack above the\n     * corresponding '(' to be evaluated down to a single resultant operand.\n     * Then the fence for the '(' is removed, and the operand goes through the\n     * algorithm above, without the fence.\n     *\n     * A separate stack is kept of the fence positions, so that the position of\n     * the latest so-far unbalanced '(' is at the top of it.\n     *\n     * The ']' ending the construct is treated as the lowest operator of all,\n     * so that everything gets evaluated down to a single operand, which is the\n     * result */\n\n    sv_2mortal((SV *)(stack = newAV()));\n    sv_2mortal((SV *)(fence_stack = newAV()));\n\n    while (RExC_parse < RExC_end) {\n        I32 top_index;              /* Index of top-most element in 'stack' */\n        SV** top_ptr;               /* Pointer to top 'stack' element */\n        SV* current = NULL;         /* To contain the current inversion list\n                                       operand */\n        SV* only_to_avoid_leaks;\n\n        skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                TRUE /* Force /x */ );\n        if (RExC_parse >= RExC_end) {   /* Fail */\n            break;\n        }\n\n        curchar = UCHARAT(RExC_parse);\n\nredo_curchar:\n\n#ifdef ENABLE_REGEX_SETS_DEBUGGING\n                    /* Enable with -Accflags=-DENABLE_REGEX_SETS_DEBUGGING */\n        DEBUG_U(dump_regex_sets_structures(pRExC_state,\n                                           stack, fence, fence_stack));\n#endif\n\n        top_index = av_tindex_skip_len_mg(stack);\n\n        switch (curchar) {\n            SV** stacked_ptr;       /* Ptr to something already on 'stack' */\n            char stacked_operator;  /* The topmost operator on the 'stack'. */\n            SV* lhs;                /* Operand to the left of the operator */\n            SV* rhs;                /* Operand to the right of the operator */\n            SV* fence_ptr;          /* Pointer to top element of the fence\n                                       stack */\n\n            case '(':\n\n                if (   RExC_parse < RExC_end - 2\n                    && UCHARAT(RExC_parse + 1) == '?'\n                    && UCHARAT(RExC_parse + 2) == '^')\n                {\n                    /* If is a '(?', could be an embedded '(?^flags:(?[...])'.\n                     * This happens when we have some thing like\n                     *\n                     *   my $thai_or_lao = qr/(?[ \\p{Thai} + \\p{Lao} ])/;\n                     *   ...\n                     *   qr/(?[ \\p{Digit} & $thai_or_lao ])/;\n                     *\n                     * Here we would be handling the interpolated\n                     * '$thai_or_lao'.  We handle this by a recursive call to\n                     * ourselves which returns the inversion list the\n                     * interpolated expression evaluates to.  We use the flags\n                     * from the interpolated pattern. */\n                    U32 save_flags = RExC_flags;\n                    const char * save_parse;\n\n                    RExC_parse += 2;        /* Skip past the '(?' */\n                    save_parse = RExC_parse;\n\n                    /* Parse the flags for the '(?'.  We already know the first\n                     * flag to parse is a '^' */\n                    parse_lparen_question_flags(pRExC_state);\n\n                    if (   RExC_parse >= RExC_end - 4\n                        || UCHARAT(RExC_parse) != ':'\n                        || UCHARAT(++RExC_parse) != '('\n                        || UCHARAT(++RExC_parse) != '?'\n                        || UCHARAT(++RExC_parse) != '[')\n                    {\n\n                        /* In combination with the above, this moves the\n                         * pointer to the point just after the first erroneous\n                         * character. */\n                        if (RExC_parse >= RExC_end - 4) {\n                            RExC_parse = RExC_end;\n                        }\n                        else if (RExC_parse != save_parse) {\n                            RExC_parse += (UTF)\n                                          ? UTF8_SAFE_SKIP(RExC_parse, RExC_end)\n                                          : 1;\n                        }\n                        vFAIL(\"Expecting '(?flags:(?[...'\");\n                    }\n\n                    /* Recurse, with the meat of the embedded expression */\n                    RExC_parse++;\n                    if (! handle_regex_sets(pRExC_state, &current, flagp,\n                                                    depth+1, oregcomp_parse))\n                    {\n                        RETURN_FAIL_ON_RESTART(*flagp, flagp);\n                    }\n\n                    /* Here, 'current' contains the embedded expression's\n                     * inversion list, and RExC_parse points to the trailing\n                     * ']'; the next character should be the ')' */\n                    RExC_parse++;\n                    if (UCHARAT(RExC_parse) != ')')\n                        vFAIL(\"Expecting close paren for nested extended charclass\");\n\n                    /* Then the ')' matching the original '(' handled by this\n                     * case: statement */\n                    RExC_parse++;\n                    if (UCHARAT(RExC_parse) != ')')\n                        vFAIL(\"Expecting close paren for wrapper for nested extended charclass\");\n\n                    RExC_flags = save_flags;\n                    goto handle_operand;\n                }\n\n                /* A regular '('.  Look behind for illegal syntax */\n                if (top_index - fence >= 0) {\n                    /* If the top entry on the stack is an operator, it had\n                     * better be a '!', otherwise the entry below the top\n                     * operand should be an operator */\n                    if (   ! (top_ptr = av_fetch(stack, top_index, FALSE))\n                        || (IS_OPERATOR(*top_ptr) && SvUV(*top_ptr) != '!')\n                        || (   IS_OPERAND(*top_ptr)\n                            && (   top_index - fence < 1\n                                || ! (stacked_ptr = av_fetch(stack,\n                                                             top_index - 1,\n                                                             FALSE))\n                                || ! IS_OPERATOR(*stacked_ptr))))\n                    {\n                        RExC_parse++;\n                        vFAIL(\"Unexpected '(' with no preceding operator\");\n                    }\n                }\n\n                /* Stack the position of this undealt-with left paren */\n                av_push(fence_stack, newSViv(fence));\n                fence = top_index + 1;\n                break;\n\n            case '\\\\':\n                /* regclass() can only return RESTART_PARSE and NEED_UTF8 if\n                 * multi-char folds are allowed.  */\n                if (!regclass(pRExC_state, flagp, depth+1,\n                              TRUE, /* means parse just the next thing */\n                              FALSE, /* don't allow multi-char folds */\n                              FALSE, /* don't silence non-portable warnings.  */\n                              TRUE,  /* strict */\n                              FALSE, /* Require return to be an ANYOF */\n                              &current))\n                {\n                    RETURN_FAIL_ON_RESTART(*flagp, flagp);\n                    goto regclass_failed;\n                }\n\n                /* regclass() will return with parsing just the \\ sequence,\n                 * leaving the parse pointer at the next thing to parse */\n                RExC_parse--;\n                goto handle_operand;\n\n            case '[':   /* Is a bracketed character class */\n            {\n                /* See if this is a [:posix:] class. */\n                bool is_posix_class = (OOB_NAMEDCLASS\n                            < handle_possible_posix(pRExC_state,\n                                                RExC_parse + 1,\n                                                NULL,\n                                                NULL,\n                                                TRUE /* checking only */));\n                /* If it is a posix class, leave the parse pointer at the '['\n                 * to fool regclass() into thinking it is part of a\n                 * '[[:posix:]]'. */\n                if (! is_posix_class) {\n                    RExC_parse++;\n                }\n\n                /* regclass() can only return RESTART_PARSE and NEED_UTF8 if\n                 * multi-char folds are allowed.  */\n                if (!regclass(pRExC_state, flagp, depth+1,\n                                is_posix_class, /* parse the whole char\n                                                    class only if not a\n                                                    posix class */\n                                FALSE, /* don't allow multi-char folds */\n                                TRUE, /* silence non-portable warnings. */\n                                TRUE, /* strict */\n                                FALSE, /* Require return to be an ANYOF */\n                                &current))\n                {\n                    RETURN_FAIL_ON_RESTART(*flagp, flagp);\n                    goto regclass_failed;\n                }\n\n                if (! current) {\n                    break;\n                }\n\n                /* function call leaves parse pointing to the ']', except if we\n                 * faked it */\n                if (is_posix_class) {\n                    RExC_parse--;\n                }\n\n                goto handle_operand;\n            }\n\n            case ']':\n                if (top_index >= 1) {\n                    goto join_operators;\n                }\n\n                /* Only a single operand on the stack: are done */\n                goto done;\n\n            case ')':\n                if (av_tindex_skip_len_mg(fence_stack) < 0) {\n                    if (UCHARAT(RExC_parse - 1) == ']')  {\n                        break;\n                    }\n                    RExC_parse++;\n                    vFAIL(\"Unexpected ')'\");\n                }\n\n                /* If nothing after the fence, is missing an operand */\n                if (top_index - fence < 0) {\n                    RExC_parse++;\n                    goto bad_syntax;\n                }\n                /* If at least two things on the stack, treat this as an\n                  * operator */\n                if (top_index - fence >= 1) {\n                    goto join_operators;\n                }\n\n                /* Here only a single thing on the fenced stack, and there is a\n                 * fence.  Get rid of it */\n                fence_ptr = av_pop(fence_stack);\n                assert(fence_ptr);\n                fence = SvIV(fence_ptr);\n                SvREFCNT_dec_NN(fence_ptr);\n                fence_ptr = NULL;\n\n                if (fence < 0) {\n                    fence = 0;\n                }\n\n                /* Having gotten rid of the fence, we pop the operand at the\n                 * stack top and process it as a newly encountered operand */\n                current = av_pop(stack);\n                if (IS_OPERAND(current)) {\n                    goto handle_operand;\n                }\n\n                RExC_parse++;\n                goto bad_syntax;\n\n            case '&':\n            case '|':\n            case '+':\n            case '-':\n            case '^':\n\n                /* These binary operators should have a left operand already\n                 * parsed */\n                if (   top_index - fence < 0\n                    || top_index - fence == 1\n                    || ( ! (top_ptr = av_fetch(stack, top_index, FALSE)))\n                    || ! IS_OPERAND(*top_ptr))\n                {\n                    goto unexpected_binary;\n                }\n\n                /* If only the one operand is on the part of the stack visible\n                 * to us, we just place this operator in the proper position */\n                if (top_index - fence < 2) {\n\n                    /* Place the operator before the operand */\n\n                    SV* lhs = av_pop(stack);\n                    av_push(stack, newSVuv(curchar));\n                    av_push(stack, lhs);\n                    break;\n                }\n\n                /* But if there is something else on the stack, we need to\n                 * process it before this new operator if and only if the\n                 * stacked operation has equal or higher precedence than the\n                 * new one */\n\n             join_operators:\n\n                /* The operator on the stack is supposed to be below both its\n                 * operands */\n                if (   ! (stacked_ptr = av_fetch(stack, top_index - 2, FALSE))\n                    || IS_OPERAND(*stacked_ptr))\n                {\n                    /* But if not, it's legal and indicates we are completely\n                     * done if and only if we're currently processing a ']',\n                     * which should be the final thing in the expression */\n                    if (curchar == ']') {\n                        goto done;\n                    }\n\n                  unexpected_binary:\n                    RExC_parse++;\n                    vFAIL2(\"Unexpected binary operator '%c' with no \"\n                           \"preceding operand\", curchar);\n                }\n                stacked_operator = (char) SvUV(*stacked_ptr);\n\n                if (regex_set_precedence(curchar)\n                    > regex_set_precedence(stacked_operator))\n                {\n                    /* Here, the new operator has higher precedence than the\n                     * stacked one.  This means we need to add the new one to\n                     * the stack to await its rhs operand (and maybe more\n                     * stuff).  We put it before the lhs operand, leaving\n                     * untouched the stacked operator and everything below it\n                     * */\n                    lhs = av_pop(stack);\n                    assert(IS_OPERAND(lhs));\n\n                    av_push(stack, newSVuv(curchar));\n                    av_push(stack, lhs);\n                    break;\n                }\n\n                /* Here, the new operator has equal or lower precedence than\n                 * what's already there.  This means the operation already\n                 * there should be performed now, before the new one. */\n\n                rhs = av_pop(stack);\n                if (! IS_OPERAND(rhs)) {\n\n                    /* This can happen when a ! is not followed by an operand,\n                     * like in /(?[\\t &!])/ */\n                    goto bad_syntax;\n                }\n\n                lhs = av_pop(stack);\n\n                if (! IS_OPERAND(lhs)) {\n\n                    /* This can happen when there is an empty (), like in\n                     * /(?[[0]+()+])/ */\n                    goto bad_syntax;\n                }\n\n                switch (stacked_operator) {\n                    case '&':\n                        _invlist_intersection(lhs, rhs, &rhs);\n                        break;\n\n                    case '|':\n                    case '+':\n                        _invlist_union(lhs, rhs, &rhs);\n                        break;\n\n                    case '-':\n                        _invlist_subtract(lhs, rhs, &rhs);\n                        break;\n\n                    case '^':   /* The union minus the intersection */\n                    {\n                        SV* i = NULL;\n                        SV* u = NULL;\n\n                        _invlist_union(lhs, rhs, &u);\n                        _invlist_intersection(lhs, rhs, &i);\n                        _invlist_subtract(u, i, &rhs);\n                        SvREFCNT_dec_NN(i);\n                        SvREFCNT_dec_NN(u);\n                        break;\n                    }\n                }\n                SvREFCNT_dec(lhs);\n\n                /* Here, the higher precedence operation has been done, and the\n                 * result is in 'rhs'.  We overwrite the stacked operator with\n                 * the result.  Then we redo this code to either push the new\n                 * operator onto the stack or perform any higher precedence\n                 * stacked operation */\n                only_to_avoid_leaks = av_pop(stack);\n                SvREFCNT_dec(only_to_avoid_leaks);\n                av_push(stack, rhs);\n                goto redo_curchar;\n\n            case '!':   /* Highest priority, right associative */\n\n                /* If what's already at the top of the stack is another '!\",\n                 * they just cancel each other out */\n                if (   (top_ptr = av_fetch(stack, top_index, FALSE))\n                    && (IS_OPERATOR(*top_ptr) && SvUV(*top_ptr) == '!'))\n                {\n                    only_to_avoid_leaks = av_pop(stack);\n                    SvREFCNT_dec(only_to_avoid_leaks);\n                }\n                else { /* Otherwise, since it's right associative, just push\n                          onto the stack */\n                    av_push(stack, newSVuv(curchar));\n                }\n                break;\n\n            default:\n                RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n                if (RExC_parse >= RExC_end) {\n                    break;\n                }\n                vFAIL(\"Unexpected character\");\n\n          handle_operand:\n\n            /* Here 'current' is the operand.  If something is already on the\n             * stack, we have to check if it is a !.  But first, the code above\n             * may have altered the stack in the time since we earlier set\n             * 'top_index'.  */\n\n            top_index = av_tindex_skip_len_mg(stack);\n            if (top_index - fence >= 0) {\n                /* If the top entry on the stack is an operator, it had better\n                 * be a '!', otherwise the entry below the top operand should\n                 * be an operator */\n                top_ptr = av_fetch(stack, top_index, FALSE);\n                assert(top_ptr);\n                if (IS_OPERATOR(*top_ptr)) {\n\n                    /* The only permissible operator at the top of the stack is\n                     * '!', which is applied immediately to this operand. */\n                    curchar = (char) SvUV(*top_ptr);\n                    if (curchar != '!') {\n                        SvREFCNT_dec(current);\n                        vFAIL2(\"Unexpected binary operator '%c' with no \"\n                                \"preceding operand\", curchar);\n                    }\n\n                    _invlist_invert(current);\n\n                    only_to_avoid_leaks = av_pop(stack);\n                    SvREFCNT_dec(only_to_avoid_leaks);\n\n                    /* And we redo with the inverted operand.  This allows\n                     * handling multiple ! in a row */\n                    goto handle_operand;\n                }\n                          /* Single operand is ok only for the non-binary ')'\n                           * operator */\n                else if ((top_index - fence == 0 && curchar != ')')\n                         || (top_index - fence > 0\n                             && (! (stacked_ptr = av_fetch(stack,\n                                                           top_index - 1,\n                                                           FALSE))\n                                 || IS_OPERAND(*stacked_ptr))))\n                {\n                    SvREFCNT_dec(current);\n                    vFAIL(\"Operand with no preceding operator\");\n                }\n            }\n\n            /* Here there was nothing on the stack or the top element was\n             * another operand.  Just add this new one */\n            av_push(stack, current);\n\n        } /* End of switch on next parse token */\n\n        RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n    } /* End of loop parsing through the construct */\n\n    vFAIL(\"Syntax error in (?[...])\");\n\n  done:\n\n    if (RExC_parse >= RExC_end || RExC_parse[1] != ')') {\n        if (RExC_parse < RExC_end) {\n            RExC_parse++;\n        }\n\n        vFAIL(\"Unexpected ']' with no following ')' in (?[...\");\n    }\n\n    if (av_tindex_skip_len_mg(fence_stack) >= 0) {\n        vFAIL(\"Unmatched (\");\n    }\n\n    if (av_tindex_skip_len_mg(stack) < 0   /* Was empty */\n        || ((final = av_pop(stack)) == NULL)\n        || ! IS_OPERAND(final)\n        || ! is_invlist(final)\n        || av_tindex_skip_len_mg(stack) >= 0)  /* More left on stack */\n    {\n      bad_syntax:\n        SvREFCNT_dec(final);\n        vFAIL(\"Incomplete expression within '(?[ ])'\");\n    }\n\n    /* Here, 'final' is the resultant inversion list from evaluating the\n     * expression.  Return it if so requested */\n    if (return_invlist) {\n        *return_invlist = final;\n        return END;\n    }\n\n    /* Otherwise generate a resultant node, based on 'final'.  regclass() is\n     * expecting a string of ranges and individual code points */\n    invlist_iterinit(final);\n    result_string = newSVpvs(\"\");\n    while (invlist_iternext(final, &start, &end)) {\n        if (start == end) {\n            Perl_sv_catpvf(aTHX_ result_string, \"\\\\x{%\" UVXf \"}\", start);\n        }\n        else {\n            Perl_sv_catpvf(aTHX_ result_string, \"\\\\x{%\" UVXf \"}-\\\\x{%\" UVXf \"}\",\n                                                     start,          end);\n        }\n    }\n\n    /* About to generate an ANYOF (or similar) node from the inversion list we\n     * have calculated */\n    save_parse = RExC_parse;\n    RExC_parse = SvPV(result_string, len);\n    save_end = RExC_end;\n    RExC_end = RExC_parse + len;\n    TURN_OFF_WARNINGS_IN_SUBSTITUTE_PARSE;\n\n    /* We turn off folding around the call, as the class we have constructed\n     * already has all folding taken into consideration, and we don't want\n     * regclass() to add to that */\n    RExC_flags &= ~RXf_PMf_FOLD;\n    /* regclass() can only return RESTART_PARSE and NEED_UTF8 if multi-char\n     * folds are allowed.  */\n    node = regclass(pRExC_state, flagp, depth+1,\n                    FALSE, /* means parse the whole char class */\n                    FALSE, /* don't allow multi-char folds */\n                    TRUE, /* silence non-portable warnings.  The above may very\n                             well have generated non-portable code points, but\n                             they're valid on this machine */\n                    FALSE, /* similarly, no need for strict */\n                    FALSE, /* Require return to be an ANYOF */\n                    NULL\n                );\n\n    RESTORE_WARNINGS;\n    RExC_parse = save_parse + 1;\n    RExC_end = save_end;\n    SvREFCNT_dec_NN(final);\n    SvREFCNT_dec_NN(result_string);\n\n    if (save_fold) {\n        RExC_flags |= RXf_PMf_FOLD;\n    }\n\n    if (!node) {\n        RETURN_FAIL_ON_RESTART(*flagp, flagp);\n        goto regclass_failed;\n    }\n\n    /* Fix up the node type if we are in locale.  (We have pretended we are\n     * under /u for the purposes of regclass(), as this construct will only\n     * work under UTF-8 locales.  But now we change the opcode to be ANYOFL (so\n     * as to cause any warnings about bad locales to be output in regexec.c),\n     * and add the flag that indicates to check if not in a UTF-8 locale.  The\n     * reason we above forbid optimization into something other than an ANYOF\n     * node is simply to minimize the number of code changes in regexec.c.\n     * Otherwise we would have to create new EXACTish node types and deal with\n     * them.  This decision could be revisited should this construct become\n     * popular.\n     *\n     * (One might think we could look at the resulting ANYOF node and suppress\n     * the flag if everything is above 255, as those would be UTF-8 only,\n     * but this isn't true, as the components that led to that result could\n     * have been locale-affected, and just happen to cancel each other out\n     * under UTF-8 locales.) */\n    if (in_locale) {\n        set_regex_charset(&RExC_flags, REGEX_LOCALE_CHARSET);\n\n        assert(OP(REGNODE_p(node)) == ANYOF);\n\n        OP(REGNODE_p(node)) = ANYOFL;\n        ANYOF_FLAGS(REGNODE_p(node))\n                |= ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n    }\n\n    nextchar(pRExC_state);\n    Set_Node_Length(REGNODE_p(node), RExC_parse - oregcomp_parse + 1); /* MJD */\n    return node;\n\n  regclass_failed:\n    FAIL2(\"panic: regclass returned failure to handle_sets, \" \"flags=%#\" UVxf,\n                                                                (UV) *flagp);\n}\n\n#ifdef ENABLE_REGEX_SETS_DEBUGGING\n\nSTATIC void\nS_dump_regex_sets_structures(pTHX_ RExC_state_t *pRExC_state,\n                             AV * stack, const IV fence, AV * fence_stack)\n{   /* Dumps the stacks in handle_regex_sets() */\n\n    const SSize_t stack_top = av_tindex_skip_len_mg(stack);\n    const SSize_t fence_stack_top = av_tindex_skip_len_mg(fence_stack);\n    SSize_t i;\n\n    PERL_ARGS_ASSERT_DUMP_REGEX_SETS_STRUCTURES;\n\n    PerlIO_printf(Perl_debug_log, \"\\nParse position is:%s\\n\", RExC_parse);\n\n    if (stack_top < 0) {\n        PerlIO_printf(Perl_debug_log, \"Nothing on stack\\n\");\n    }\n    else {\n        PerlIO_printf(Perl_debug_log, \"Stack: (fence=%d)\\n\", (int) fence);\n        for (i = stack_top; i >= 0; i--) {\n            SV ** element_ptr = av_fetch(stack, i, FALSE);\n            if (! element_ptr) {\n            }\n\n            if (IS_OPERATOR(*element_ptr)) {\n                PerlIO_printf(Perl_debug_log, \"[%d]: %c\\n\",\n                                            (int) i, (int) SvIV(*element_ptr));\n            }\n            else {\n                PerlIO_printf(Perl_debug_log, \"[%d] \", (int) i);\n                sv_dump(*element_ptr);\n            }\n        }\n    }\n\n    if (fence_stack_top < 0) {\n        PerlIO_printf(Perl_debug_log, \"Nothing on fence_stack\\n\");\n    }\n    else {\n        PerlIO_printf(Perl_debug_log, \"Fence_stack: \\n\");\n        for (i = fence_stack_top; i >= 0; i--) {\n            SV ** element_ptr = av_fetch(fence_stack, i, FALSE);\n            if (! element_ptr) {\n            }\n\n            PerlIO_printf(Perl_debug_log, \"[%d]: %d\\n\",\n                                            (int) i, (int) SvIV(*element_ptr));\n        }\n    }\n}\n\n#endif\n\n#undef IS_OPERATOR\n#undef IS_OPERAND\n\nSTATIC void\nS_add_above_Latin1_folds(pTHX_ RExC_state_t *pRExC_state, const U8 cp, SV** invlist)\n{\n    /* This adds the Latin1/above-Latin1 folding rules.\n     *\n     * This should be called only for a Latin1-range code points, cp, which is\n     * known to be involved in a simple fold with other code points above\n     * Latin1.  It would give false results if /aa has been specified.\n     * Multi-char folds are outside the scope of this, and must be handled\n     * specially. */\n\n    PERL_ARGS_ASSERT_ADD_ABOVE_LATIN1_FOLDS;\n\n    assert(HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(cp));\n\n    /* The rules that are valid for all Unicode versions are hard-coded in */\n    switch (cp) {\n        case 'k':\n        case 'K':\n          *invlist =\n             add_cp_to_invlist(*invlist, KELVIN_SIGN);\n            break;\n        case 's':\n        case 'S':\n          *invlist = add_cp_to_invlist(*invlist, LATIN_SMALL_LETTER_LONG_S);\n            break;\n        case MICRO_SIGN:\n          *invlist = add_cp_to_invlist(*invlist, GREEK_CAPITAL_LETTER_MU);\n          *invlist = add_cp_to_invlist(*invlist, GREEK_SMALL_LETTER_MU);\n            break;\n        case LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE:\n        case LATIN_SMALL_LETTER_A_WITH_RING_ABOVE:\n          *invlist = add_cp_to_invlist(*invlist, ANGSTROM_SIGN);\n            break;\n        case LATIN_SMALL_LETTER_Y_WITH_DIAERESIS:\n          *invlist = add_cp_to_invlist(*invlist,\n                                        LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS);\n            break;\n\n        default:    /* Other code points are checked against the data for the\n                       current Unicode version */\n          {\n            Size_t folds_count;\n            unsigned int first_fold;\n            const unsigned int * remaining_folds;\n            UV folded_cp;\n\n            if (isASCII(cp)) {\n                folded_cp = toFOLD(cp);\n            }\n            else {\n                U8 dummy_fold[UTF8_MAXBYTES_CASE+1];\n                Size_t dummy_len;\n                folded_cp = _to_fold_latin1(cp, dummy_fold, &dummy_len, 0);\n            }\n\n            if (folded_cp > 255) {\n                *invlist = add_cp_to_invlist(*invlist, folded_cp);\n            }\n\n            folds_count = _inverse_folds(folded_cp, &first_fold,\n                                                    &remaining_folds);\n            if (folds_count == 0) {\n\n                /* Use deprecated warning to increase the chances of this being\n                 * output */\n                ckWARN2reg_d(RExC_parse,\n                        \"Perl folding rules are not up-to-date for 0x%02X;\"\n                        \" please use the perlbug utility to report;\", cp);\n            }\n            else {\n                unsigned int i;\n\n                if (first_fold > 255) {\n                    *invlist = add_cp_to_invlist(*invlist, first_fold);\n                }\n                for (i = 0; i < folds_count - 1; i++) {\n                    if (remaining_folds[i] > 255) {\n                        *invlist = add_cp_to_invlist(*invlist,\n                                                    remaining_folds[i]);\n                    }\n                }\n            }\n            break;\n         }\n    }\n}\n\nSTATIC void\nS_output_posix_warnings(pTHX_ RExC_state_t *pRExC_state, AV* posix_warnings)\n{\n    /* Output the elements of the array given by '*posix_warnings' as REGEXP\n     * warnings. */\n\n    SV * msg;\n    const bool first_is_fatal = ckDEAD(packWARN(WARN_REGEXP));\n\n    PERL_ARGS_ASSERT_OUTPUT_POSIX_WARNINGS;\n\n    if (! TO_OUTPUT_WARNINGS(RExC_parse)) {\n        return;\n    }\n\n    while ((msg = av_shift(posix_warnings)) != &PL_sv_undef) {\n        if (first_is_fatal) {           /* Avoid leaking this */\n            av_undef(posix_warnings);   /* This isn't necessary if the\n                                            array is mortal, but is a\n                                            fail-safe */\n            (void) sv_2mortal(msg);\n            PREPARE_TO_DIE;\n        }\n        Perl_warner(aTHX_ packWARN(WARN_REGEXP), \"%s\", SvPVX(msg));\n        SvREFCNT_dec_NN(msg);\n    }\n\n    UPDATE_WARNINGS_LOC(RExC_parse);\n}\n\nSTATIC AV *\nS_add_multi_match(pTHX_ AV* multi_char_matches, SV* multi_string, const STRLEN cp_count)\n{\n    /* This adds the string scalar <multi_string> to the array\n     * <multi_char_matches>.  <multi_string> is known to have exactly\n     * <cp_count> code points in it.  This is used when constructing a\n     * bracketed character class and we find something that needs to match more\n     * than a single character.\n     *\n     * <multi_char_matches> is actually an array of arrays.  Each top-level\n     * element is an array that contains all the strings known so far that are\n     * the same length.  And that length (in number of code points) is the same\n     * as the index of the top-level array.  Hence, the [2] element is an\n     * array, each element thereof is a string containing TWO code points;\n     * while element [3] is for strings of THREE characters, and so on.  Since\n     * this is for multi-char strings there can never be a [0] nor [1] element.\n     *\n     * When we rewrite the character class below, we will do so such that the\n     * longest strings are written first, so that it prefers the longest\n     * matching strings first.  This is done even if it turns out that any\n     * quantifier is non-greedy, out of this programmer's (khw) laziness.  Tom\n     * Christiansen has agreed that this is ok.  This makes the test for the\n     * ligature 'ffi' come before the test for 'ff', for example */\n\n    AV* this_array;\n    AV** this_array_ptr;\n\n    PERL_ARGS_ASSERT_ADD_MULTI_MATCH;\n\n    if (! multi_char_matches) {\n        multi_char_matches = newAV();\n    }\n\n    if (av_exists(multi_char_matches, cp_count)) {\n        this_array_ptr = (AV**) av_fetch(multi_char_matches, cp_count, FALSE);\n        this_array = *this_array_ptr;\n    }\n    else {\n        this_array = newAV();\n        av_store(multi_char_matches, cp_count,\n                 (SV*) this_array);\n    }\n    av_push(this_array, multi_string);\n\n    return multi_char_matches;\n}\n\n/* The names of properties whose definitions are not known at compile time are\n * stored in this SV, after a constant heading.  So if the length has been\n * changed since initialization, then there is a run-time definition. */\n#define HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION                            \\\n                                        (SvCUR(listsv) != initial_listsv_len)\n\n/* There is a restricted set of white space characters that are legal when\n * ignoring white space in a bracketed character class.  This generates the\n * code to skip them.\n *\n * There is a line below that uses the same white space criteria but is outside\n * this macro.  Both here and there must use the same definition */\n#define SKIP_BRACKETED_WHITE_SPACE(do_skip, p)                          \\\n    STMT_START {                                                        \\\n        if (do_skip) {                                                  \\\n            while (isBLANK_A(UCHARAT(p)))                               \\\n            {                                                           \\\n                p++;                                                    \\\n            }                                                           \\\n        }                                                               \\\n    } STMT_END\n\nSTATIC regnode_offset\nS_regclass(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth,\n                 const bool stop_at_1,  /* Just parse the next thing, don't\n                                           look for a full character class */\n                 bool allow_mutiple_chars,\n                 const bool silence_non_portable,   /* Don't output warnings\n                                                       about too large\n                                                       characters */\n                 const bool strict,\n                 bool optimizable,                  /* ? Allow a non-ANYOF return\n                                                       node */\n                 SV** ret_invlist  /* Return an inversion list, not a node */\n          )\n{\n    /* parse a bracketed class specification.  Most of these will produce an\n     * ANYOF node; but something like [a] will produce an EXACT node; [aA], an\n     * EXACTFish node; [[:ascii:]], a POSIXA node; etc.  It is more complex\n     * under /i with multi-character folds: it will be rewritten following the\n     * paradigm of this example, where the <multi-fold>s are characters which\n     * fold to multiple character sequences:\n     *      /[abc\\x{multi-fold1}def\\x{multi-fold2}ghi]/i\n     * gets effectively rewritten as:\n     *      /(?:\\x{multi-fold1}|\\x{multi-fold2}|[abcdefghi]/i\n     * reg() gets called (recursively) on the rewritten version, and this\n     * function will return what it constructs.  (Actually the <multi-fold>s\n     * aren't physically removed from the [abcdefghi], it's just that they are\n     * ignored in the recursion by means of a flag:\n     * <RExC_in_multi_char_class>.)\n     *\n     * ANYOF nodes contain a bit map for the first NUM_ANYOF_CODE_POINTS\n     * characters, with the corresponding bit set if that character is in the\n     * list.  For characters above this, an inversion list is used.  There\n     * are extra bits for \\w, etc. in locale ANYOFs, as what these match is not\n     * determinable at compile time\n     *\n     * On success, returns the offset at which any next node should be placed\n     * into the regex engine program being compiled.\n     *\n     * Returns 0 otherwise, setting flagp to RESTART_PARSE if the parse needs\n     * to be restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to\n     * UTF-8\n     */\n\n    dVAR;\n    UV prevvalue = OOB_UNICODE, save_prevvalue = OOB_UNICODE;\n    IV range = 0;\n    UV value = OOB_UNICODE, save_value = OOB_UNICODE;\n    regnode_offset ret = -1;    /* Initialized to an illegal value */\n    STRLEN numlen;\n    int namedclass = OOB_NAMEDCLASS;\n    char *rangebegin = NULL;\n    SV *listsv = NULL;      /* List of \\p{user-defined} whose definitions\n                               aren't available at the time this was called */\n    STRLEN initial_listsv_len = 0; /* Kind of a kludge to see if it is more\n\t\t\t\t      than just initialized.  */\n    SV* properties = NULL;    /* Code points that match \\p{} \\P{} */\n    SV* posixes = NULL;     /* Code points that match classes like [:word:],\n                               extended beyond the Latin1 range.  These have to\n                               be kept separate from other code points for much\n                               of this function because their handling  is\n                               different under /i, and for most classes under\n                               /d as well */\n    SV* nposixes = NULL;    /* Similarly for [:^word:].  These are kept\n                               separate for a while from the non-complemented\n                               versions because of complications with /d\n                               matching */\n    SV* simple_posixes = NULL; /* But under some conditions, the classes can be\n                                  treated more simply than the general case,\n                                  leading to less compilation and execution\n                                  work */\n    UV element_count = 0;   /* Number of distinct elements in the class.\n\t\t\t       Optimizations may be possible if this is tiny */\n    AV * multi_char_matches = NULL; /* Code points that fold to more than one\n                                       character; used under /i */\n    UV n;\n    char * stop_ptr = RExC_end;    /* where to stop parsing */\n\n    /* ignore unescaped whitespace? */\n    const bool skip_white = cBOOL(   ret_invlist\n                                  || (RExC_flags & RXf_PMf_EXTENDED_MORE));\n\n    /* inversion list of code points this node matches only when the target\n     * string is in UTF-8.  These are all non-ASCII, < 256.  (Because is under\n     * /d) */\n    SV* upper_latin1_only_utf8_matches = NULL;\n\n    /* Inversion list of code points this node matches regardless of things\n     * like locale, folding, utf8ness of the target string */\n    SV* cp_list = NULL;\n\n    /* Like cp_list, but code points on this list need to be checked for things\n     * that fold to/from them under /i */\n    SV* cp_foldable_list = NULL;\n\n    /* Like cp_list, but code points on this list are valid only when the\n     * runtime locale is UTF-8 */\n    SV* only_utf8_locale_list = NULL;\n\n    /* In a range, if one of the endpoints is non-character-set portable,\n     * meaning that it hard-codes a code point that may mean a different\n     * charactger in ASCII vs. EBCDIC, as opposed to, say, a literal 'A' or a\n     * mnemonic '\\t' which each mean the same character no matter which\n     * character set the platform is on. */\n    unsigned int non_portable_endpoint = 0;\n\n    /* Is the range unicode? which means on a platform that isn't 1-1 native\n     * to Unicode (i.e. non-ASCII), each code point in it should be considered\n     * to be a Unicode value.  */\n    bool unicode_range = FALSE;\n    bool invert = FALSE;    /* Is this class to be complemented */\n\n    bool warn_super = ALWAYS_WARN_SUPER;\n\n    const char * orig_parse = RExC_parse;\n\n    /* This variable is used to mark where the end in the input is of something\n     * that looks like a POSIX construct but isn't.  During the parse, when\n     * something looks like it could be such a construct is encountered, it is\n     * checked for being one, but not if we've already checked this area of the\n     * input.  Only after this position is reached do we check again */\n    char *not_posix_region_end = RExC_parse - 1;\n\n    AV* posix_warnings = NULL;\n    const bool do_posix_warnings = ckWARN(WARN_REGEXP);\n    U8 op = END;    /* The returned node-type, initialized to an impossible\n                       one.  */\n    U8 anyof_flags = 0;   /* flag bits if the node is an ANYOF-type */\n    U32 posixl = 0;       /* bit field of posix classes matched under /l */\n\n\n/* Flags as to what things aren't knowable until runtime.  (Note that these are\n * mutually exclusive.) */\n#define HAS_USER_DEFINED_PROPERTY 0x01   /* /u any user-defined properties that\n                                            haven't been defined as of yet */\n#define HAS_D_RUNTIME_DEPENDENCY  0x02   /* /d if the target being matched is\n                                            UTF-8 or not */\n#define HAS_L_RUNTIME_DEPENDENCY   0x04 /* /l what the posix classes match and\n                                            what gets folded */\n    U32 has_runtime_dependency = 0;     /* OR of the above flags */\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGCLASS;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n\n    /* If wants an inversion list returned, we can't optimize to something\n     * else. */\n    if (ret_invlist) {\n        optimizable = FALSE;\n    }\n\n    DEBUG_PARSE(\"clas\");\n\n#if UNICODE_MAJOR_VERSION < 3 /* no multifolds in early Unicode */      \\\n    || (UNICODE_MAJOR_VERSION == 3 && UNICODE_DOT_VERSION == 0          \\\n                                   && UNICODE_DOT_DOT_VERSION == 0)\n    allow_mutiple_chars = FALSE;\n#endif\n\n    /* We include the /i status at the beginning of this so that we can\n     * know it at runtime */\n    listsv = sv_2mortal(Perl_newSVpvf(aTHX_ \"#%d\\n\", cBOOL(FOLD)));\n    initial_listsv_len = SvCUR(listsv);\n    SvTEMP_off(listsv); /* Grr, TEMPs and mortals are conflated.  */\n\n    SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n\n    assert(RExC_parse <= RExC_end);\n\n    if (UCHARAT(RExC_parse) == '^') {\t/* Complement the class */\n\tRExC_parse++;\n        invert = TRUE;\n        allow_mutiple_chars = FALSE;\n        MARK_NAUGHTY(1);\n        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n    }\n\n    /* Check that they didn't say [:posix:] instead of [[:posix:]] */\n    if (! ret_invlist && MAYBE_POSIXCC(UCHARAT(RExC_parse))) {\n        int maybe_class = handle_possible_posix(pRExC_state,\n                                                RExC_parse,\n                                                &not_posix_region_end,\n                                                NULL,\n                                                TRUE /* checking only */);\n        if (maybe_class >= OOB_NAMEDCLASS && do_posix_warnings) {\n            ckWARN4reg(not_posix_region_end,\n                    \"POSIX syntax [%c %c] belongs inside character classes%s\",\n                    *RExC_parse, *RExC_parse,\n                    (maybe_class == OOB_NAMEDCLASS)\n                    ? ((POSIXCC_NOTYET(*RExC_parse))\n                        ? \" (but this one isn't implemented)\"\n                        : \" (but this one isn't fully valid)\")\n                    : \"\"\n                    );\n        }\n    }\n\n    /* If the caller wants us to just parse a single element, accomplish this\n     * by faking the loop ending condition */\n    if (stop_at_1 && RExC_end > RExC_parse) {\n        stop_ptr = RExC_parse + 1;\n    }\n\n    /* allow 1st char to be ']' (allowing it to be '-' is dealt with later) */\n    if (UCHARAT(RExC_parse) == ']')\n\tgoto charclassloop;\n\n    while (1) {\n\n        if (   posix_warnings\n            && av_tindex_skip_len_mg(posix_warnings) >= 0\n            && RExC_parse > not_posix_region_end)\n        {\n            /* Warnings about posix class issues are considered tentative until\n             * we are far enough along in the parse that we can no longer\n             * change our mind, at which point we output them.  This is done\n             * each time through the loop so that a later class won't zap them\n             * before they have been dealt with. */\n            output_posix_warnings(pRExC_state, posix_warnings);\n        }\n\n        if  (RExC_parse >= stop_ptr) {\n            break;\n        }\n\n        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n\n        if  (UCHARAT(RExC_parse) == ']') {\n            break;\n        }\n\n      charclassloop:\n\n\tnamedclass = OOB_NAMEDCLASS; /* initialize as illegal */\n        save_value = value;\n        save_prevvalue = prevvalue;\n\n\tif (!range) {\n\t    rangebegin = RExC_parse;\n\t    element_count++;\n            non_portable_endpoint = 0;\n\t}\n\tif (UTF && ! UTF8_IS_INVARIANT(* RExC_parse)) {\n\t    value = utf8n_to_uvchr((U8*)RExC_parse,\n\t\t\t\t   RExC_end - RExC_parse,\n\t\t\t\t   &numlen, UTF8_ALLOW_DEFAULT);\n\t    RExC_parse += numlen;\n\t}\n\telse\n\t    value = UCHARAT(RExC_parse++);\n\n        if (value == '[') {\n            char * posix_class_end;\n            namedclass = handle_possible_posix(pRExC_state,\n                                               RExC_parse,\n                                               &posix_class_end,\n                                               do_posix_warnings ? &posix_warnings : NULL,\n                                               FALSE    /* die if error */);\n            if (namedclass > OOB_NAMEDCLASS) {\n\n                /* If there was an earlier attempt to parse this particular\n                 * posix class, and it failed, it was a false alarm, as this\n                 * successful one proves */\n                if (   posix_warnings\n                    && av_tindex_skip_len_mg(posix_warnings) >= 0\n                    && not_posix_region_end >= RExC_parse\n                    && not_posix_region_end <= posix_class_end)\n                {\n                    av_undef(posix_warnings);\n                }\n\n                RExC_parse = posix_class_end;\n            }\n            else if (namedclass == OOB_NAMEDCLASS) {\n                not_posix_region_end = posix_class_end;\n            }\n            else {\n                namedclass = OOB_NAMEDCLASS;\n            }\n        }\n        else if (   RExC_parse - 1 > not_posix_region_end\n                 && MAYBE_POSIXCC(value))\n        {\n            (void) handle_possible_posix(\n                        pRExC_state,\n                        RExC_parse - 1,  /* -1 because parse has already been\n                                            advanced */\n                        &not_posix_region_end,\n                        do_posix_warnings ? &posix_warnings : NULL,\n                        TRUE /* checking only */);\n        }\n        else if (  strict && ! skip_white\n                 && (   _generic_isCC(value, _CC_VERTSPACE)\n                     || is_VERTWS_cp_high(value)))\n        {\n            vFAIL(\"Literal vertical space in [] is illegal except under /x\");\n        }\n        else if (value == '\\\\') {\n            /* Is a backslash; get the code point of the char after it */\n\n            if (RExC_parse >= RExC_end) {\n                vFAIL(\"Unmatched [\");\n            }\n\n\t    if (UTF && ! UTF8_IS_INVARIANT(UCHARAT(RExC_parse))) {\n\t\tvalue = utf8n_to_uvchr((U8*)RExC_parse,\n\t\t\t\t   RExC_end - RExC_parse,\n\t\t\t\t   &numlen, UTF8_ALLOW_DEFAULT);\n\t\tRExC_parse += numlen;\n\t    }\n\t    else\n\t\tvalue = UCHARAT(RExC_parse++);\n\n\t    /* Some compilers cannot handle switching on 64-bit integer\n\t     * values, therefore value cannot be an UV.  Yes, this will\n\t     * be a problem later if we want switch on Unicode.\n\t     * A similar issue a little bit later when switching on\n\t     * namedclass. --jhi */\n\n            /* If the \\ is escaping white space when white space is being\n             * skipped, it means that that white space is wanted literally, and\n             * is already in 'value'.  Otherwise, need to translate the escape\n             * into what it signifies. */\n            if (! skip_white || ! isBLANK_A(value)) switch ((I32)value) {\n\n\t    case 'w':\tnamedclass = ANYOF_WORDCHAR;\tbreak;\n\t    case 'W':\tnamedclass = ANYOF_NWORDCHAR;\tbreak;\n\t    case 's':\tnamedclass = ANYOF_SPACE;\tbreak;\n\t    case 'S':\tnamedclass = ANYOF_NSPACE;\tbreak;\n\t    case 'd':\tnamedclass = ANYOF_DIGIT;\tbreak;\n\t    case 'D':\tnamedclass = ANYOF_NDIGIT;\tbreak;\n\t    case 'v':\tnamedclass = ANYOF_VERTWS;\tbreak;\n\t    case 'V':\tnamedclass = ANYOF_NVERTWS;\tbreak;\n\t    case 'h':\tnamedclass = ANYOF_HORIZWS;\tbreak;\n\t    case 'H':\tnamedclass = ANYOF_NHORIZWS;\tbreak;\n            case 'N':  /* Handle \\N{NAME} in class */\n                {\n                    const char * const backslash_N_beg = RExC_parse - 2;\n                    int cp_count;\n\n                    if (! grok_bslash_N(pRExC_state,\n                                        NULL,      /* No regnode */\n                                        &value,    /* Yes single value */\n                                        &cp_count, /* Multiple code pt count */\n                                        flagp,\n                                        strict,\n                                        depth)\n                    ) {\n\n                        if (*flagp & NEED_UTF8)\n                            FAIL(\"panic: grok_bslash_N set NEED_UTF8\");\n\n                        RETURN_FAIL_ON_RESTART_FLAGP(flagp);\n\n                        if (cp_count < 0) {\n                            vFAIL(\"\\\\N in a character class must be a named character: \\\\N{...}\");\n                        }\n                        else if (cp_count == 0) {\n                            ckWARNreg(RExC_parse,\n                              \"Ignoring zero length \\\\N{} in character class\");\n                        }\n                        else { /* cp_count > 1 */\n                            assert(cp_count > 1);\n                            if (! RExC_in_multi_char_class) {\n                                if ( ! allow_mutiple_chars\n                                    || invert\n                                    || range\n                                    || *RExC_parse == '-')\n                                {\n                                    if (strict) {\n                                        RExC_parse--;\n                                        vFAIL(\"\\\\N{} in inverted character class or as a range end-point is restricted to one character\");\n                                    }\n                                    ckWARNreg(RExC_parse, \"Using just the first character returned by \\\\N{} in character class\");\n                                    break; /* <value> contains the first code\n                                              point. Drop out of the switch to\n                                              process it */\n                                }\n                                else {\n                                    SV * multi_char_N = newSVpvn(backslash_N_beg,\n                                                 RExC_parse - backslash_N_beg);\n                                    multi_char_matches\n                                        = add_multi_match(multi_char_matches,\n                                                          multi_char_N,\n                                                          cp_count);\n                                }\n                            }\n                        } /* End of cp_count != 1 */\n\n                        /* This element should not be processed further in this\n                         * class */\n                        element_count--;\n                        value = save_value;\n                        prevvalue = save_prevvalue;\n                        continue;   /* Back to top of loop to get next char */\n                    }\n\n                    /* Here, is a single code point, and <value> contains it */\n                    unicode_range = TRUE;   /* \\N{} are Unicode */\n                }\n                break;\n\t    case 'p':\n\t    case 'P':\n\t\t{\n\t\tchar *e;\n\n\t\t/* \\p means they want Unicode semantics */\n\t\tREQUIRE_UNI_RULES(flagp, 0);\n\n\t\tif (RExC_parse >= RExC_end)\n\t\t    vFAIL2(\"Empty \\\\%c\", (U8)value);\n\t\tif (*RExC_parse == '{') {\n\t\t    const U8 c = (U8)value;\n\t\t    e = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n                    if (!e) {\n                        RExC_parse++;\n                        vFAIL2(\"Missing right brace on \\\\%c{}\", c);\n                    }\n\n                    RExC_parse++;\n\n                    /* White space is allowed adjacent to the braces and after\n                     * any '^', even when not under /x */\n                    while (isSPACE(*RExC_parse)) {\n                         RExC_parse++;\n\t\t    }\n\n\t\t    if (UCHARAT(RExC_parse) == '^') {\n\n                        /* toggle.  (The rhs xor gets the single bit that\n                         * differs between P and p; the other xor inverts just\n                         * that bit) */\n                        value ^= 'P' ^ 'p';\n\n                        RExC_parse++;\n                        while (isSPACE(*RExC_parse)) {\n                            RExC_parse++;\n                        }\n                    }\n\n                    if (e == RExC_parse)\n                        vFAIL2(\"Empty \\\\%c{}\", c);\n\n\t\t    n = e - RExC_parse;\n\t\t    while (isSPACE(*(RExC_parse + n - 1)))\n\t\t        n--;\n\n\t\t}   /* The \\p isn't immediately followed by a '{' */\n\t\telse if (! isALPHA(*RExC_parse)) {\n                    RExC_parse += (UTF)\n                                  ? UTF8_SAFE_SKIP(RExC_parse, RExC_end)\n                                  : 1;\n                    vFAIL2(\"Character following \\\\%c must be '{' or a \"\n                           \"single-character Unicode property name\",\n                           (U8) value);\n                }\n                else {\n\t\t    e = RExC_parse;\n\t\t    n = 1;\n\t\t}\n\t\t{\n                    char* name = RExC_parse;\n\n                    /* Any message returned about expanding the definition */\n                    SV* msg = newSVpvs_flags(\"\", SVs_TEMP);\n\n                    /* If set TRUE, the property is user-defined as opposed to\n                     * official Unicode */\n                    bool user_defined = FALSE;\n\n                    SV * prop_definition = parse_uniprop_string(\n                                            name, n, UTF, FOLD,\n                                            FALSE, /* This is compile-time */\n\n                                            /* We can't defer this defn when\n                                             * the full result is required in\n                                             * this call */\n                                            ! cBOOL(ret_invlist),\n\n                                            &user_defined,\n                                            msg,\n                                            0 /* Base level */\n                                           );\n                    if (SvCUR(msg)) {   /* Assumes any error causes a msg */\n                        assert(prop_definition == NULL);\n                        RExC_parse = e + 1;\n                        if (SvUTF8(msg)) {  /* msg being UTF-8 makes the whole\n                                               thing so, or else the display is\n                                               mojibake */\n                            RExC_utf8 = TRUE;\n                        }\n\t\t\t/* diag_listed_as: Can't find Unicode property definition \"%s\" in regex; marked by <-- HERE in m/%s/ */\n                        vFAIL2utf8f(\"%\" UTF8f, UTF8fARG(SvUTF8(msg),\n                                    SvCUR(msg), SvPVX(msg)));\n                    }\n\n                    if (! is_invlist(prop_definition)) {\n\n                        /* Here, the definition isn't known, so we have gotten\n                         * returned a string that will be evaluated if and when\n                         * encountered at runtime.  We add it to the list of\n                         * such properties, along with whether it should be\n                         * complemented or not */\n                        if (value == 'P') {\n                            sv_catpvs(listsv, \"!\");\n                        }\n                        else {\n                            sv_catpvs(listsv, \"+\");\n                        }\n                        sv_catsv(listsv, prop_definition);\n\n                        has_runtime_dependency |= HAS_USER_DEFINED_PROPERTY;\n\n                        /* We don't know yet what this matches, so have to flag\n                         * it */\n                        anyof_flags |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;\n                    }\n                    else {\n                        assert (prop_definition && is_invlist(prop_definition));\n\n                        /* Here we do have the complete property definition\n                         *\n                         * Temporary workaround for [perl #133136].  For this\n                         * precise input that is in the .t that is failing,\n                         * load utf8.pm, which is what the test wants, so that\n                         * that .t passes */\n                        if (     memEQs(RExC_start, e + 1 - RExC_start,\n                                        \"foo\\\\p{Alnum}\")\n                            && ! hv_common(GvHVn(PL_incgv),\n                                           NULL,\n                                           \"utf8.pm\", sizeof(\"utf8.pm\") - 1,\n                                           0, HV_FETCH_ISEXISTS, NULL, 0))\n                        {\n                            require_pv(\"utf8.pm\");\n                        }\n\n                        if (! user_defined &&\n                            /* We warn on matching an above-Unicode code point\n                             * if the match would return true, except don't\n                             * warn for \\p{All}, which has exactly one element\n                             * = 0 */\n                            (_invlist_contains_cp(prop_definition, 0x110000)\n                                && (! (_invlist_len(prop_definition) == 1\n                                       && *invlist_array(prop_definition) == 0))))\n                        {\n                            warn_super = TRUE;\n                        }\n\n                        /* Invert if asking for the complement */\n                        if (value == 'P') {\n\t\t\t    _invlist_union_complement_2nd(properties,\n                                                          prop_definition,\n                                                          &properties);\n                        }\n                        else {\n                            _invlist_union(properties, prop_definition, &properties);\n\t\t\t}\n                    }\n                }\n\n\t\tRExC_parse = e + 1;\n                namedclass = ANYOF_UNIPROP;  /* no official name, but it's\n                                                named */\n\t\t}\n\t\tbreak;\n\t    case 'n':\tvalue = '\\n';\t\t\tbreak;\n\t    case 'r':\tvalue = '\\r';\t\t\tbreak;\n\t    case 't':\tvalue = '\\t';\t\t\tbreak;\n\t    case 'f':\tvalue = '\\f';\t\t\tbreak;\n\t    case 'b':\tvalue = '\\b';\t\t\tbreak;\n\t    case 'e':\tvalue = ESC_NATIVE;             break;\n\t    case 'a':\tvalue = '\\a';                   break;\n\t    case 'o':\n\t\tRExC_parse--;\t/* function expects to be pointed at the 'o' */\n\t\t{\n\t\t    const char* error_msg;\n\t\t    bool valid = grok_bslash_o(&RExC_parse,\n                                               RExC_end,\n\t\t\t\t\t       &value,\n\t\t\t\t\t       &error_msg,\n                                               TO_OUTPUT_WARNINGS(RExC_parse),\n                                               strict,\n                                               silence_non_portable,\n                                               UTF);\n\t\t    if (! valid) {\n\t\t\tvFAIL(error_msg);\n\t\t    }\n                    UPDATE_WARNINGS_LOC(RExC_parse - 1);\n\t\t}\n                non_portable_endpoint++;\n\t\tbreak;\n\t    case 'x':\n\t\tRExC_parse--;\t/* function expects to be pointed at the 'x' */\n\t\t{\n\t\t    const char* error_msg;\n\t\t    bool valid = grok_bslash_x(&RExC_parse,\n                                               RExC_end,\n\t\t\t\t\t       &value,\n\t\t\t\t\t       &error_msg,\n\t\t\t\t\t       TO_OUTPUT_WARNINGS(RExC_parse),\n                                               strict,\n                                               silence_non_portable,\n                                               UTF);\n                    if (! valid) {\n\t\t\tvFAIL(error_msg);\n\t\t    }\n                    UPDATE_WARNINGS_LOC(RExC_parse - 1);\n\t\t}\n                non_portable_endpoint++;\n\t\tbreak;\n\t    case 'c':\n\t\tvalue = grok_bslash_c(*RExC_parse, TO_OUTPUT_WARNINGS(RExC_parse));\n                UPDATE_WARNINGS_LOC(RExC_parse);\n\t\tRExC_parse++;\n                non_portable_endpoint++;\n\t\tbreak;\n\t    case '0': case '1': case '2': case '3': case '4':\n\t    case '5': case '6': case '7':\n\t\t{\n\t\t    /* Take 1-3 octal digits */\n\t\t    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;\n                    numlen = (strict) ? 4 : 3;\n                    value = grok_oct(--RExC_parse, &numlen, &flags, NULL);\n\t\t    RExC_parse += numlen;\n                    if (numlen != 3) {\n                        if (strict) {\n                            RExC_parse += (UTF)\n                                          ? UTF8_SAFE_SKIP(RExC_parse, RExC_end)\n                                          : 1;\n                            vFAIL(\"Need exactly 3 octal digits\");\n                        }\n                        else if (   numlen < 3 /* like \\08, \\178 */\n                                 && RExC_parse < RExC_end\n                                 && isDIGIT(*RExC_parse)\n                                 && ckWARN(WARN_REGEXP))\n                        {\n                            reg_warn_non_literal_string(\n                                 RExC_parse + 1,\n                                 form_short_octal_warning(RExC_parse, numlen));\n                        }\n                    }\n                    non_portable_endpoint++;\n\t\t    break;\n\t\t}\n\t    default:\n\t\t/* Allow \\_ to not give an error */\n\t\tif (isWORDCHAR(value) && value != '_') {\n                    if (strict) {\n                        vFAIL2(\"Unrecognized escape \\\\%c in character class\",\n                               (int)value);\n                    }\n                    else {\n                        ckWARN2reg(RExC_parse,\n                            \"Unrecognized escape \\\\%c in character class passed through\",\n                            (int)value);\n                    }\n\t\t}\n\t\tbreak;\n\t    }   /* End of switch on char following backslash */\n\t} /* end of handling backslash escape sequences */\n\n        /* Here, we have the current token in 'value' */\n\n\tif (namedclass > OOB_NAMEDCLASS) { /* this is a named class \\blah */\n            U8 classnum;\n\n\t    /* a bad range like a-\\d, a-[:digit:].  The '-' is taken as a\n\t     * literal, as is the character that began the false range, i.e.\n\t     * the 'a' in the examples */\n\t    if (range) {\n                const int w = (RExC_parse >= rangebegin)\n                                ? RExC_parse - rangebegin\n                                : 0;\n                if (strict) {\n                    vFAIL2utf8f(\n                        \"False [] range \\\"%\" UTF8f \"\\\"\",\n                        UTF8fARG(UTF, w, rangebegin));\n                }\n                else {\n                    ckWARN2reg(RExC_parse,\n                        \"False [] range \\\"%\" UTF8f \"\\\"\",\n                        UTF8fARG(UTF, w, rangebegin));\n                    cp_list = add_cp_to_invlist(cp_list, '-');\n                    cp_foldable_list = add_cp_to_invlist(cp_foldable_list,\n                                                            prevvalue);\n                }\n\n\t\trange = 0; /* this was not a true range */\n                element_count += 2; /* So counts for three values */\n\t    }\n\n            classnum = namedclass_to_classnum(namedclass);\n\n\t    if (LOC && namedclass < ANYOF_POSIXL_MAX\n#ifndef HAS_ISASCII\n                && classnum != _CC_ASCII\n#endif\n            ) {\n                SV* scratch_list = NULL;\n\n                /* What the Posix classes (like \\w, [:space:]) match isn't\n                 * generally knowable under locale until actual match time.  A\n                 * special node is used for these which has extra space for a\n                 * bitmap, with a bit reserved for each named class that is to\n                 * be matched against.  (This isn't needed for \\p{} and\n                 * pseudo-classes, as they are not affected by locale, and\n                 * hence are dealt with separately.)  However, if a named class\n                 * and its complement are both present, then it matches\n                 * everything, and there is no runtime dependency.  Odd numbers\n                 * are the complements of the next lower number, so xor works.\n                 * (Note that something like [\\w\\D] should match everything,\n                 * because \\d should be a proper subset of \\w.  But rather than\n                 * trust that the locale is well behaved, we leave this to\n                 * runtime to sort out) */\n                if (POSIXL_TEST(posixl, namedclass ^ 1)) {\n                    cp_list = _add_range_to_invlist(cp_list, 0, UV_MAX);\n                    POSIXL_ZERO(posixl);\n                    has_runtime_dependency &= ~HAS_L_RUNTIME_DEPENDENCY;\n                    anyof_flags &= ~ANYOF_MATCHES_POSIXL;\n                    continue;   /* We could ignore the rest of the class, but\n                                   best to parse it for any errors */\n                }\n                else { /* Here, isn't the complement of any already parsed\n                          class */\n                    POSIXL_SET(posixl, namedclass);\n                    has_runtime_dependency |= HAS_L_RUNTIME_DEPENDENCY;\n                    anyof_flags |= ANYOF_MATCHES_POSIXL;\n\n                    /* The above-Latin1 characters are not subject to locale\n                     * rules.  Just add them to the unconditionally-matched\n                     * list */\n\n                    /* Get the list of the above-Latin1 code points this\n                     * matches */\n                    _invlist_intersection_maybe_complement_2nd(PL_AboveLatin1,\n                                            PL_XPosix_ptrs[classnum],\n\n                                            /* Odd numbers are complements,\n                                             * like NDIGIT, NASCII, ... */\n                                            namedclass % 2 != 0,\n                                            &scratch_list);\n                    /* Checking if 'cp_list' is NULL first saves an extra\n                     * clone.  Its reference count will be decremented at the\n                     * next union, etc, or if this is the only instance, at the\n                     * end of the routine */\n                    if (! cp_list) {\n                        cp_list = scratch_list;\n                    }\n                    else {\n                        _invlist_union(cp_list, scratch_list, &cp_list);\n                        SvREFCNT_dec_NN(scratch_list);\n                    }\n                    continue;   /* Go get next character */\n                }\n            }\n            else {\n\n                /* Here, is not /l, or is a POSIX class for which /l doesn't\n                 * matter (or is a Unicode property, which is skipped here). */\n                if (namedclass >= ANYOF_POSIXL_MAX) {  /* If a special class */\n                    if (namedclass != ANYOF_UNIPROP) { /* UNIPROP = \\p and \\P */\n\n                        /* Here, should be \\h, \\H, \\v, or \\V.  None of /d, /i\n                         * nor /l make a difference in what these match,\n                         * therefore we just add what they match to cp_list. */\n                        if (classnum != _CC_VERTSPACE) {\n                            assert(   namedclass == ANYOF_HORIZWS\n                                   || namedclass == ANYOF_NHORIZWS);\n\n                            /* It turns out that \\h is just a synonym for\n                             * XPosixBlank */\n                            classnum = _CC_BLANK;\n                        }\n\n                        _invlist_union_maybe_complement_2nd(\n                                cp_list,\n                                PL_XPosix_ptrs[classnum],\n                                namedclass % 2 != 0,    /* Complement if odd\n                                                          (NHORIZWS, NVERTWS)\n                                                        */\n                                &cp_list);\n                    }\n                }\n                else if (   AT_LEAST_UNI_SEMANTICS\n                         || classnum == _CC_ASCII\n                         || (DEPENDS_SEMANTICS && (   classnum == _CC_DIGIT\n                                                   || classnum == _CC_XDIGIT)))\n                {\n                    /* We usually have to worry about /d affecting what POSIX\n                     * classes match, with special code needed because we won't\n                     * know until runtime what all matches.  But there is no\n                     * extra work needed under /u and /a; and [:ascii:] is\n                     * unaffected by /d; and :digit: and :xdigit: don't have\n                     * runtime differences under /d.  So we can special case\n                     * these, and avoid some extra work below, and at runtime.\n                     * */\n                    _invlist_union_maybe_complement_2nd(\n                                                     simple_posixes,\n                                                      ((AT_LEAST_ASCII_RESTRICTED)\n                                                       ? PL_Posix_ptrs[classnum]\n                                                       : PL_XPosix_ptrs[classnum]),\n                                                     namedclass % 2 != 0,\n                                                     &simple_posixes);\n                }\n                else {  /* Garden variety class.  If is NUPPER, NALPHA, ...\n                           complement and use nposixes */\n                    SV** posixes_ptr = namedclass % 2 == 0\n                                       ? &posixes\n                                       : &nposixes;\n                    _invlist_union_maybe_complement_2nd(\n                                                     *posixes_ptr,\n                                                     PL_XPosix_ptrs[classnum],\n                                                     namedclass % 2 != 0,\n                                                     posixes_ptr);\n                }\n\t    }\n\t} /* end of namedclass \\blah */\n\n        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n\n        /* If 'range' is set, 'value' is the ending of a range--check its\n         * validity.  (If value isn't a single code point in the case of a\n         * range, we should have figured that out above in the code that\n         * catches false ranges).  Later, we will handle each individual code\n         * point in the range.  If 'range' isn't set, this could be the\n         * beginning of a range, so check for that by looking ahead to see if\n         * the next real character to be processed is the range indicator--the\n         * minus sign */\n\n\tif (range) {\n#ifdef EBCDIC\n            /* For unicode ranges, we have to test that the Unicode as opposed\n             * to the native values are not decreasing.  (Above 255, there is\n             * no difference between native and Unicode) */\n\t    if (unicode_range && prevvalue < 255 && value < 255) {\n                if (NATIVE_TO_LATIN1(prevvalue) > NATIVE_TO_LATIN1(value)) {\n                    goto backwards_range;\n                }\n            }\n            else\n#endif\n\t    if (prevvalue > value) /* b-a */ {\n\t\tint w;\n#ifdef EBCDIC\n              backwards_range:\n#endif\n                w = RExC_parse - rangebegin;\n                vFAIL2utf8f(\n                    \"Invalid [] range \\\"%\" UTF8f \"\\\"\",\n                    UTF8fARG(UTF, w, rangebegin));\n                NOT_REACHED; /* NOTREACHED */\n\t    }\n\t}\n\telse {\n            prevvalue = value; /* save the beginning of the potential range */\n            if (! stop_at_1     /* Can't be a range if parsing just one thing */\n                && *RExC_parse == '-')\n            {\n                char* next_char_ptr = RExC_parse + 1;\n\n                /* Get the next real char after the '-' */\n                SKIP_BRACKETED_WHITE_SPACE(skip_white, next_char_ptr);\n\n                /* If the '-' is at the end of the class (just before the ']',\n                 * it is a literal minus; otherwise it is a range */\n                if (next_char_ptr < RExC_end && *next_char_ptr != ']') {\n                    RExC_parse = next_char_ptr;\n\n                    /* a bad range like \\w-, [:word:]- ? */\n                    if (namedclass > OOB_NAMEDCLASS) {\n                        if (strict || ckWARN(WARN_REGEXP)) {\n                            const int w = RExC_parse >= rangebegin\n                                          ?  RExC_parse - rangebegin\n                                          : 0;\n                            if (strict) {\n                                vFAIL4(\"False [] range \\\"%*.*s\\\"\",\n                                    w, w, rangebegin);\n                            }\n                            else {\n                                vWARN4(RExC_parse,\n                                    \"False [] range \\\"%*.*s\\\"\",\n                                    w, w, rangebegin);\n                            }\n                        }\n                        cp_list = add_cp_to_invlist(cp_list, '-');\n                        element_count++;\n                    } else\n                        range = 1;\t/* yeah, it's a range! */\n                    continue;\t/* but do it the next time */\n                }\n\t    }\n\t}\n\n        if (namedclass > OOB_NAMEDCLASS) {\n            continue;\n        }\n\n        /* Here, we have a single value this time through the loop, and\n         * <prevvalue> is the beginning of the range, if any; or <value> if\n         * not. */\n\n\t/* non-Latin1 code point implies unicode semantics. */\n\tif (value > 255) {\n            REQUIRE_UNI_RULES(flagp, 0);\n\t}\n\n        /* Ready to process either the single value, or the completed range.\n         * For single-valued non-inverted ranges, we consider the possibility\n         * of multi-char folds.  (We made a conscious decision to not do this\n         * for the other cases because it can often lead to non-intuitive\n         * results.  For example, you have the peculiar case that:\n         *  \"s s\" =~ /^[^\\xDF]+$/i => Y\n         *  \"ss\"  =~ /^[^\\xDF]+$/i => N\n         *\n         * See [perl #89750] */\n        if (FOLD && allow_mutiple_chars && value == prevvalue) {\n            if (    value == LATIN_SMALL_LETTER_SHARP_S\n                || (value > 255 && _invlist_contains_cp(PL_HasMultiCharFold,\n                                                        value)))\n            {\n                /* Here <value> is indeed a multi-char fold.  Get what it is */\n\n                U8 foldbuf[UTF8_MAXBYTES_CASE+1];\n                STRLEN foldlen;\n\n                UV folded = _to_uni_fold_flags(\n                                value,\n                                foldbuf,\n                                &foldlen,\n                                FOLD_FLAGS_FULL | (ASCII_FOLD_RESTRICTED\n                                                   ? FOLD_FLAGS_NOMIX_ASCII\n                                                   : 0)\n                                );\n\n                /* Here, <folded> should be the first character of the\n                 * multi-char fold of <value>, with <foldbuf> containing the\n                 * whole thing.  But, if this fold is not allowed (because of\n                 * the flags), <fold> will be the same as <value>, and should\n                 * be processed like any other character, so skip the special\n                 * handling */\n                if (folded != value) {\n\n                    /* Skip if we are recursed, currently parsing the class\n                     * again.  Otherwise add this character to the list of\n                     * multi-char folds. */\n                    if (! RExC_in_multi_char_class) {\n                        STRLEN cp_count = utf8_length(foldbuf,\n                                                      foldbuf + foldlen);\n                        SV* multi_fold = sv_2mortal(newSVpvs(\"\"));\n\n                        Perl_sv_catpvf(aTHX_ multi_fold, \"\\\\x{%\" UVXf \"}\", value);\n\n                        multi_char_matches\n                                        = add_multi_match(multi_char_matches,\n                                                          multi_fold,\n                                                          cp_count);\n\n                    }\n\n                    /* This element should not be processed further in this\n                     * class */\n                    element_count--;\n                    value = save_value;\n                    prevvalue = save_prevvalue;\n                    continue;\n                }\n            }\n        }\n\n        if (strict && ckWARN(WARN_REGEXP)) {\n            if (range) {\n\n                /* If the range starts above 255, everything is portable and\n                 * likely to be so for any forseeable character set, so don't\n                 * warn. */\n                if (unicode_range && non_portable_endpoint && prevvalue < 256) {\n                    vWARN(RExC_parse, \"Both or neither range ends should be Unicode\");\n                }\n                else if (prevvalue != value) {\n\n                    /* Under strict, ranges that stop and/or end in an ASCII\n                     * printable should have each end point be a portable value\n                     * for it (preferably like 'A', but we don't warn if it is\n                     * a (portable) Unicode name or code point), and the range\n                     * must be be all digits or all letters of the same case.\n                     * Otherwise, the range is non-portable and unclear as to\n                     * what it contains */\n                    if (             (isPRINT_A(prevvalue) || isPRINT_A(value))\n                        && (          non_portable_endpoint\n                            || ! (   (isDIGIT_A(prevvalue) && isDIGIT_A(value))\n                                  || (isLOWER_A(prevvalue) && isLOWER_A(value))\n                                  || (isUPPER_A(prevvalue) && isUPPER_A(value))\n                    ))) {\n                        vWARN(RExC_parse, \"Ranges of ASCII printables should\"\n                                          \" be some subset of \\\"0-9\\\",\"\n                                          \" \\\"A-Z\\\", or \\\"a-z\\\"\");\n                    }\n                    else if (prevvalue >= FIRST_NON_ASCII_DECIMAL_DIGIT) {\n                        SSize_t index_start;\n                        SSize_t index_final;\n\n                        /* But the nature of Unicode and languages mean we\n                         * can't do the same checks for above-ASCII ranges,\n                         * except in the case of digit ones.  These should\n                         * contain only digits from the same group of 10.  The\n                         * ASCII case is handled just above.  Hence here, the\n                         * range could be a range of digits.  First some\n                         * unlikely special cases.  Grandfather in that a range\n                         * ending in 19DA (NEW TAI LUE THAM DIGIT ONE) is bad\n                         * if its starting value is one of the 10 digits prior\n                         * to it.  This is because it is an alternate way of\n                         * writing 19D1, and some people may expect it to be in\n                         * that group.  But it is bad, because it won't give\n                         * the expected results.  In Unicode 5.2 it was\n                         * considered to be in that group (of 11, hence), but\n                         * this was fixed in the next version */\n\n                        if (UNLIKELY(value == 0x19DA && prevvalue >= 0x19D0)) {\n                            goto warn_bad_digit_range;\n                        }\n                        else if (UNLIKELY(   prevvalue >= 0x1D7CE\n                                          &&     value <= 0x1D7FF))\n                        {\n                            /* This is the only other case currently in Unicode\n                             * where the algorithm below fails.  The code\n                             * points just above are the end points of a single\n                             * range containing only decimal digits.  It is 5\n                             * different series of 0-9.  All other ranges of\n                             * digits currently in Unicode are just a single\n                             * series.  (And mktables will notify us if a later\n                             * Unicode version breaks this.)\n                             *\n                             * If the range being checked is at most 9 long,\n                             * and the digit values represented are in\n                             * numerical order, they are from the same series.\n                             * */\n                            if (         value - prevvalue > 9\n                                ||    (((    value - 0x1D7CE) % 10)\n                                     <= (prevvalue - 0x1D7CE) % 10))\n                            {\n                                goto warn_bad_digit_range;\n                            }\n                        }\n                        else {\n\n                            /* For all other ranges of digits in Unicode, the\n                             * algorithm is just to check if both end points\n                             * are in the same series, which is the same range.\n                             * */\n                            index_start = _invlist_search(\n                                                    PL_XPosix_ptrs[_CC_DIGIT],\n                                                    prevvalue);\n\n                            /* Warn if the range starts and ends with a digit,\n                             * and they are not in the same group of 10. */\n                            if (   index_start >= 0\n                                && ELEMENT_RANGE_MATCHES_INVLIST(index_start)\n                                && (index_final =\n                                    _invlist_search(PL_XPosix_ptrs[_CC_DIGIT],\n                                                    value)) != index_start\n                                && index_final >= 0\n                                && ELEMENT_RANGE_MATCHES_INVLIST(index_final))\n                            {\n                              warn_bad_digit_range:\n                                vWARN(RExC_parse, \"Ranges of digits should be\"\n                                                  \" from the same group of\"\n                                                  \" 10\");\n                            }\n                        }\n                    }\n                }\n            }\n            if ((! range || prevvalue == value) && non_portable_endpoint) {\n                if (isPRINT_A(value)) {\n                    char literal[3];\n                    unsigned d = 0;\n                    if (isBACKSLASHED_PUNCT(value)) {\n                        literal[d++] = '\\\\';\n                    }\n                    literal[d++] = (char) value;\n                    literal[d++] = '\\0';\n\n                    vWARN4(RExC_parse,\n                           \"\\\"%.*s\\\" is more clearly written simply as \\\"%s\\\"\",\n                           (int) (RExC_parse - rangebegin),\n                           rangebegin,\n                           literal\n                        );\n                }\n                else if isMNEMONIC_CNTRL(value) {\n                    vWARN4(RExC_parse,\n                           \"\\\"%.*s\\\" is more clearly written simply as \\\"%s\\\"\",\n                           (int) (RExC_parse - rangebegin),\n                           rangebegin,\n                           cntrl_to_mnemonic((U8) value)\n                        );\n                }\n            }\n        }\n\n        /* Deal with this element of the class */\n\n#ifndef EBCDIC\n        cp_foldable_list = _add_range_to_invlist(cp_foldable_list,\n                                                    prevvalue, value);\n#else\n        /* On non-ASCII platforms, for ranges that span all of 0..255, and ones\n         * that don't require special handling, we can just add the range like\n         * we do for ASCII platforms */\n        if ((UNLIKELY(prevvalue == 0) && value >= 255)\n            || ! (prevvalue < 256\n                    && (unicode_range\n                        || (! non_portable_endpoint\n                            && ((isLOWER_A(prevvalue) && isLOWER_A(value))\n                                || (isUPPER_A(prevvalue)\n                                    && isUPPER_A(value)))))))\n        {\n            cp_foldable_list = _add_range_to_invlist(cp_foldable_list,\n                                                        prevvalue, value);\n        }\n        else {\n            /* Here, requires special handling.  This can be because it is a\n             * range whose code points are considered to be Unicode, and so\n             * must be individually translated into native, or because its a\n             * subrange of 'A-Z' or 'a-z' which each aren't contiguous in\n             * EBCDIC, but we have defined them to include only the \"expected\"\n             * upper or lower case ASCII alphabetics.  Subranges above 255 are\n             * the same in native and Unicode, so can be added as a range */\n            U8 start = NATIVE_TO_LATIN1(prevvalue);\n            unsigned j;\n            U8 end = (value < 256) ? NATIVE_TO_LATIN1(value) : 255;\n            for (j = start; j <= end; j++) {\n                cp_foldable_list = add_cp_to_invlist(cp_foldable_list, LATIN1_TO_NATIVE(j));\n            }\n            if (value > 255) {\n                cp_foldable_list = _add_range_to_invlist(cp_foldable_list,\n                                                            256, value);\n            }\n        }\n#endif\n\n\trange = 0; /* this range (if it was one) is done now */\n    } /* End of loop through all the text within the brackets */\n\n    if (   posix_warnings && av_tindex_skip_len_mg(posix_warnings) >= 0) {\n        output_posix_warnings(pRExC_state, posix_warnings);\n    }\n\n    /* If anything in the class expands to more than one character, we have to\n     * deal with them by building up a substitute parse string, and recursively\n     * calling reg() on it, instead of proceeding */\n    if (multi_char_matches) {\n\tSV * substitute_parse = newSVpvn_flags(\"?:\", 2, SVs_TEMP);\n        I32 cp_count;\n\tSTRLEN len;\n\tchar *save_end = RExC_end;\n\tchar *save_parse = RExC_parse;\n\tchar *save_start = RExC_start;\n        Size_t constructed_prefix_len = 0; /* This gives the length of the\n                                              constructed portion of the\n                                              substitute parse. */\n        bool first_time = TRUE;     /* First multi-char occurrence doesn't get\n                                       a \"|\" */\n        I32 reg_flags;\n\n        assert(! invert);\n        /* Only one level of recursion allowed */\n        assert(RExC_copy_start_in_constructed == RExC_precomp);\n\n#if 0   /* Have decided not to deal with multi-char folds in inverted classes,\n           because too confusing */\n        if (invert) {\n            sv_catpvs(substitute_parse, \"(?:\");\n        }\n#endif\n\n        /* Look at the longest folds first */\n        for (cp_count = av_tindex_skip_len_mg(multi_char_matches);\n                        cp_count > 0;\n                        cp_count--)\n        {\n\n            if (av_exists(multi_char_matches, cp_count)) {\n                AV** this_array_ptr;\n                SV* this_sequence;\n\n                this_array_ptr = (AV**) av_fetch(multi_char_matches,\n                                                 cp_count, FALSE);\n                while ((this_sequence = av_pop(*this_array_ptr)) !=\n                                                                &PL_sv_undef)\n                {\n                    if (! first_time) {\n                        sv_catpvs(substitute_parse, \"|\");\n                    }\n                    first_time = FALSE;\n\n                    sv_catpv(substitute_parse, SvPVX(this_sequence));\n                }\n            }\n        }\n\n        /* If the character class contains anything else besides these\n         * multi-character folds, have to include it in recursive parsing */\n        if (element_count) {\n            sv_catpvs(substitute_parse, \"|[\");\n            constructed_prefix_len = SvCUR(substitute_parse);\n            sv_catpvn(substitute_parse, orig_parse, RExC_parse - orig_parse);\n\n            /* Put in a closing ']' only if not going off the end, as otherwise\n             * we are adding something that really isn't there */\n            if (RExC_parse < RExC_end) {\n                sv_catpvs(substitute_parse, \"]\");\n            }\n        }\n\n        sv_catpvs(substitute_parse, \")\");\n#if 0\n        if (invert) {\n            /* This is a way to get the parse to skip forward a whole named\n             * sequence instead of matching the 2nd character when it fails the\n             * first */\n            sv_catpvs(substitute_parse, \"(*THEN)(*SKIP)(*FAIL)|.)\");\n        }\n#endif\n\n        /* Set up the data structure so that any errors will be properly\n         * reported.  See the comments at the definition of\n         * REPORT_LOCATION_ARGS for details */\n        RExC_copy_start_in_input = (char *) orig_parse;\n\tRExC_start = RExC_parse = SvPV(substitute_parse, len);\n        RExC_copy_start_in_constructed = RExC_start + constructed_prefix_len;\n\tRExC_end = RExC_parse + len;\n        RExC_in_multi_char_class = 1;\n\n\tret = reg(pRExC_state, 1, &reg_flags, depth+1);\n\n        *flagp |= reg_flags & (HASWIDTH|SIMPLE|SPSTART|POSTPONED|RESTART_PARSE|NEED_UTF8);\n\n        /* And restore so can parse the rest of the pattern */\n        RExC_parse = save_parse;\n\tRExC_start = RExC_copy_start_in_constructed = RExC_copy_start_in_input = save_start;\n\tRExC_end = save_end;\n\tRExC_in_multi_char_class = 0;\n        SvREFCNT_dec_NN(multi_char_matches);\n        return ret;\n    }\n\n    /* If folding, we calculate all characters that could fold to or from the\n     * ones already on the list */\n    if (cp_foldable_list) {\n        if (FOLD) {\n            UV start, end;\t/* End points of code point ranges */\n\n            SV* fold_intersection = NULL;\n            SV** use_list;\n\n            /* Our calculated list will be for Unicode rules.  For locale\n             * matching, we have to keep a separate list that is consulted at\n             * runtime only when the locale indicates Unicode rules (and we\n             * don't include potential matches in the ASCII/Latin1 range, as\n             * any code point could fold to any other, based on the run-time\n             * locale).   For non-locale, we just use the general list */\n            if (LOC) {\n                use_list = &only_utf8_locale_list;\n            }\n            else {\n                use_list = &cp_list;\n            }\n\n            /* Only the characters in this class that participate in folds need\n             * be checked.  Get the intersection of this class and all the\n             * possible characters that are foldable.  This can quickly narrow\n             * down a large class */\n            _invlist_intersection(PL_in_some_fold, cp_foldable_list,\n                                  &fold_intersection);\n\n            /* Now look at the foldable characters in this class individually */\n            invlist_iterinit(fold_intersection);\n            while (invlist_iternext(fold_intersection, &start, &end)) {\n                UV j;\n                UV folded;\n\n                /* Look at every character in the range */\n                for (j = start; j <= end; j++) {\n                    U8 foldbuf[UTF8_MAXBYTES_CASE+1];\n                    STRLEN foldlen;\n                    unsigned int k;\n                    Size_t folds_count;\n                    unsigned int first_fold;\n                    const unsigned int * remaining_folds;\n\n                    if (j < 256) {\n\n                        /* Under /l, we don't know what code points below 256\n                         * fold to, except we do know the MICRO SIGN folds to\n                         * an above-255 character if the locale is UTF-8, so we\n                         * add it to the special list (in *use_list)  Otherwise\n                         * we know now what things can match, though some folds\n                         * are valid under /d only if the target is UTF-8.\n                         * Those go in a separate list */\n                        if (      IS_IN_SOME_FOLD_L1(j)\n                            && ! (LOC && j != MICRO_SIGN))\n                        {\n\n                            /* ASCII is always matched; non-ASCII is matched\n                             * only under Unicode rules (which could happen\n                             * under /l if the locale is a UTF-8 one */\n                            if (isASCII(j) || ! DEPENDS_SEMANTICS) {\n                                *use_list = add_cp_to_invlist(*use_list,\n                                                            PL_fold_latin1[j]);\n                            }\n                            else if (j != PL_fold_latin1[j]) {\n                                upper_latin1_only_utf8_matches\n                                        = add_cp_to_invlist(\n                                                upper_latin1_only_utf8_matches,\n                                                PL_fold_latin1[j]);\n                            }\n                        }\n\n                        if (HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(j)\n                            && (! isASCII(j) || ! ASCII_FOLD_RESTRICTED))\n                        {\n                            add_above_Latin1_folds(pRExC_state,\n                                                   (U8) j,\n                                                   use_list);\n                        }\n                        continue;\n                    }\n\n                    /* Here is an above Latin1 character.  We don't have the\n                     * rules hard-coded for it.  First, get its fold.  This is\n                     * the simple fold, as the multi-character folds have been\n                     * handled earlier and separated out */\n                    folded = _to_uni_fold_flags(j, foldbuf, &foldlen,\n                                                        (ASCII_FOLD_RESTRICTED)\n                                                        ? FOLD_FLAGS_NOMIX_ASCII\n                                                        : 0);\n\n                    /* Single character fold of above Latin1.  Add everything\n                     * in its fold closure to the list that this node should\n                     * match. */\n                    folds_count = _inverse_folds(folded, &first_fold,\n                                                    &remaining_folds);\n                    for (k = 0; k <= folds_count; k++) {\n                        UV c = (k == 0)     /* First time through use itself */\n                                ? folded\n                                : (k == 1)  /* 2nd time use, the first fold */\n                                   ? first_fold\n\n                                     /* Then the remaining ones */\n                                   : remaining_folds[k-2];\n\n                        /* /aa doesn't allow folds between ASCII and non- */\n                        if ((   ASCII_FOLD_RESTRICTED\n                            && (isASCII(c) != isASCII(j))))\n                        {\n                            continue;\n                        }\n\n                        /* Folds under /l which cross the 255/256 boundary are\n                         * added to a separate list.  (These are valid only\n                         * when the locale is UTF-8.) */\n                        if (c < 256 && LOC) {\n                            *use_list = add_cp_to_invlist(*use_list, c);\n                            continue;\n                        }\n\n                        if (isASCII(c) || c > 255 || AT_LEAST_UNI_SEMANTICS)\n                        {\n                            cp_list = add_cp_to_invlist(cp_list, c);\n                        }\n                        else {\n                            /* Similarly folds involving non-ascii Latin1\n                             * characters under /d are added to their list */\n                            upper_latin1_only_utf8_matches\n                                    = add_cp_to_invlist(\n                                                upper_latin1_only_utf8_matches,\n                                                c);\n                        }\n                    }\n                }\n            }\n            SvREFCNT_dec_NN(fold_intersection);\n        }\n\n        /* Now that we have finished adding all the folds, there is no reason\n         * to keep the foldable list separate */\n        _invlist_union(cp_list, cp_foldable_list, &cp_list);\n\tSvREFCNT_dec_NN(cp_foldable_list);\n    }\n\n    /* And combine the result (if any) with any inversion lists from posix\n     * classes.  The lists are kept separate up to now because we don't want to\n     * fold the classes */\n    if (simple_posixes) {   /* These are the classes known to be unaffected by\n                               /a, /aa, and /d */\n        if (cp_list) {\n            _invlist_union(cp_list, simple_posixes, &cp_list);\n            SvREFCNT_dec_NN(simple_posixes);\n        }\n        else {\n            cp_list = simple_posixes;\n        }\n    }\n    if (posixes || nposixes) {\n        if (! DEPENDS_SEMANTICS) {\n\n            /* For everything but /d, we can just add the current 'posixes' and\n             * 'nposixes' to the main list */\n            if (posixes) {\n                if (cp_list) {\n                    _invlist_union(cp_list, posixes, &cp_list);\n                    SvREFCNT_dec_NN(posixes);\n                }\n                else {\n                    cp_list = posixes;\n                }\n            }\n            if (nposixes) {\n                if (cp_list) {\n                    _invlist_union(cp_list, nposixes, &cp_list);\n                    SvREFCNT_dec_NN(nposixes);\n                }\n                else {\n                    cp_list = nposixes;\n                }\n            }\n        }\n        else {\n            /* Under /d, things like \\w match upper Latin1 characters only if\n             * the target string is in UTF-8.  But things like \\W match all the\n             * upper Latin1 characters if the target string is not in UTF-8.\n             *\n             * Handle the case with something like \\W separately */\n            if (nposixes) {\n                SV* only_non_utf8_list = invlist_clone(PL_UpperLatin1, NULL);\n\n                /* A complemented posix class matches all upper Latin1\n                 * characters if not in UTF-8.  And it matches just certain\n                 * ones when in UTF-8.  That means those certain ones are\n                 * matched regardless, so can just be added to the\n                 * unconditional list */\n                if (cp_list) {\n                    _invlist_union(cp_list, nposixes, &cp_list);\n                    SvREFCNT_dec_NN(nposixes);\n                    nposixes = NULL;\n                }\n                else {\n                    cp_list = nposixes;\n                }\n\n                /* Likewise for 'posixes' */\n                _invlist_union(posixes, cp_list, &cp_list);\n                SvREFCNT_dec(posixes);\n\n                /* Likewise for anything else in the range that matched only\n                 * under UTF-8 */\n                if (upper_latin1_only_utf8_matches) {\n                    _invlist_union(cp_list,\n                                   upper_latin1_only_utf8_matches,\n                                   &cp_list);\n                    SvREFCNT_dec_NN(upper_latin1_only_utf8_matches);\n                    upper_latin1_only_utf8_matches = NULL;\n                }\n\n                /* If we don't match all the upper Latin1 characters regardless\n                 * of UTF-8ness, we have to set a flag to match the rest when\n                 * not in UTF-8 */\n                _invlist_subtract(only_non_utf8_list, cp_list,\n                                  &only_non_utf8_list);\n                if (_invlist_len(only_non_utf8_list) != 0) {\n                    anyof_flags |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;\n                }\n                SvREFCNT_dec_NN(only_non_utf8_list);\n            }\n            else {\n                /* Here there were no complemented posix classes.  That means\n                 * the upper Latin1 characters in 'posixes' match only when the\n                 * target string is in UTF-8.  So we have to add them to the\n                 * list of those types of code points, while adding the\n                 * remainder to the unconditional list.\n                 *\n                 * First calculate what they are */\n                SV* nonascii_but_latin1_properties = NULL;\n                _invlist_intersection(posixes, PL_UpperLatin1,\n                                      &nonascii_but_latin1_properties);\n\n                /* And add them to the final list of such characters. */\n                _invlist_union(upper_latin1_only_utf8_matches,\n                               nonascii_but_latin1_properties,\n                               &upper_latin1_only_utf8_matches);\n\n                /* Remove them from what now becomes the unconditional list */\n                _invlist_subtract(posixes, nonascii_but_latin1_properties,\n                                  &posixes);\n\n                /* And add those unconditional ones to the final list */\n                if (cp_list) {\n                    _invlist_union(cp_list, posixes, &cp_list);\n                    SvREFCNT_dec_NN(posixes);\n                    posixes = NULL;\n                }\n                else {\n                    cp_list = posixes;\n                }\n\n                SvREFCNT_dec(nonascii_but_latin1_properties);\n\n                /* Get rid of any characters from the conditional list that we\n                 * now know are matched unconditionally, which may make that\n                 * list empty */\n                _invlist_subtract(upper_latin1_only_utf8_matches,\n                                  cp_list,\n                                  &upper_latin1_only_utf8_matches);\n                if (_invlist_len(upper_latin1_only_utf8_matches) == 0) {\n                    SvREFCNT_dec_NN(upper_latin1_only_utf8_matches);\n                    upper_latin1_only_utf8_matches = NULL;\n                }\n            }\n        }\n    }\n\n    /* And combine the result (if any) with any inversion list from properties.\n     * The lists are kept separate up to now so that we can distinguish the two\n     * in regards to matching above-Unicode.  A run-time warning is generated\n     * if a Unicode property is matched against a non-Unicode code point. But,\n     * we allow user-defined properties to match anything, without any warning,\n     * and we also suppress the warning if there is a portion of the character\n     * class that isn't a Unicode property, and which matches above Unicode, \\W\n     * or [\\x{110000}] for example.\n     * (Note that in this case, unlike the Posix one above, there is no\n     * <upper_latin1_only_utf8_matches>, because having a Unicode property\n     * forces Unicode semantics */\n    if (properties) {\n        if (cp_list) {\n\n            /* If it matters to the final outcome, see if a non-property\n             * component of the class matches above Unicode.  If so, the\n             * warning gets suppressed.  This is true even if just a single\n             * such code point is specified, as, though not strictly correct if\n             * another such code point is matched against, the fact that they\n             * are using above-Unicode code points indicates they should know\n             * the issues involved */\n            if (warn_super) {\n                warn_super = ! (invert\n                               ^ (invlist_highest(cp_list) > PERL_UNICODE_MAX));\n            }\n\n            _invlist_union(properties, cp_list, &cp_list);\n            SvREFCNT_dec_NN(properties);\n        }\n        else {\n            cp_list = properties;\n        }\n\n        if (warn_super) {\n            anyof_flags\n             |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;\n\n            /* Because an ANYOF node is the only one that warns, this node\n             * can't be optimized into something else */\n            optimizable = FALSE;\n        }\n    }\n\n    /* Here, we have calculated what code points should be in the character\n     * class.\n     *\n     * Now we can see about various optimizations.  Fold calculation (which we\n     * did above) needs to take place before inversion.  Otherwise /[^k]/i\n     * would invert to include K, which under /i would match k, which it\n     * shouldn't.  Therefore we can't invert folded locale now, as it won't be\n     * folded until runtime */\n\n    /* If we didn't do folding, it's because some information isn't available\n     * until runtime; set the run-time fold flag for these  We know to set the\n     * flag if we have a non-NULL list for UTF-8 locales, or the class matches\n     * at least one 0-255 range code point */\n    if (LOC && FOLD) {\n\n        /* Some things on the list might be unconditionally included because of\n         * other components.  Remove them, and clean up the list if it goes to\n         * 0 elements */\n        if (only_utf8_locale_list && cp_list) {\n            _invlist_subtract(only_utf8_locale_list, cp_list,\n                              &only_utf8_locale_list);\n\n            if (_invlist_len(only_utf8_locale_list) == 0) {\n                SvREFCNT_dec_NN(only_utf8_locale_list);\n                only_utf8_locale_list = NULL;\n            }\n        }\n        if (    only_utf8_locale_list\n            || (cp_list && (   _invlist_contains_cp(cp_list, LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE)\n                            || _invlist_contains_cp(cp_list, LATIN_SMALL_LETTER_DOTLESS_I))))\n        {\n            has_runtime_dependency |= HAS_L_RUNTIME_DEPENDENCY;\n            anyof_flags\n                 |= ANYOFL_FOLD\n                 |  ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n        }\n        else if (cp_list) { /* Look to see if a 0-255 code point is in list */\n            UV start, end;\n            invlist_iterinit(cp_list);\n            if (invlist_iternext(cp_list, &start, &end) && start < 256) {\n                anyof_flags |= ANYOFL_FOLD;\n                has_runtime_dependency |= HAS_L_RUNTIME_DEPENDENCY;\n            }\n            invlist_iterfinish(cp_list);\n        }\n    }\n    else if (   DEPENDS_SEMANTICS\n             && (    upper_latin1_only_utf8_matches\n                 || (anyof_flags & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER)))\n    {\n        RExC_seen_d_op = TRUE;\n        has_runtime_dependency |= HAS_D_RUNTIME_DEPENDENCY;\n    }\n\n    /* Optimize inverted patterns (e.g. [^a-z]) when everything is known at\n     * compile time. */\n    if (     cp_list\n        &&   invert\n        && ! has_runtime_dependency)\n    {\n        _invlist_invert(cp_list);\n\n\t/* Clear the invert flag since have just done it here */\n\tinvert = FALSE;\n    }\n\n    if (ret_invlist) {\n        *ret_invlist = cp_list;\n\n        return RExC_emit;\n    }\n\n    /* All possible optimizations below still have these characteristics.\n     * (Multi-char folds aren't SIMPLE, but they don't get this far in this\n     * routine) */\n    *flagp |= HASWIDTH|SIMPLE;\n\n    if (anyof_flags & ANYOF_LOCALE_FLAGS) {\n        RExC_contains_locale = 1;\n    }\n\n    /* Some character classes are equivalent to other nodes.  Such nodes take\n     * up less room, and some nodes require fewer operations to execute, than\n     * ANYOF nodes.  EXACTish nodes may be joinable with adjacent nodes to\n     * improve efficiency. */\n\n    if (optimizable) {\n        PERL_UINT_FAST8_T i;\n        Size_t partial_cp_count = 0;\n        UV start[MAX_FOLD_FROMS+1] = { 0 }; /* +1 for the folded-to char */\n        UV   end[MAX_FOLD_FROMS+1] = { 0 };\n\n        if (cp_list) { /* Count the code points in enough ranges that we would\n                          see all the ones possible in any fold in this version\n                          of Unicode */\n\n            invlist_iterinit(cp_list);\n            for (i = 0; i <= MAX_FOLD_FROMS; i++) {\n                if (! invlist_iternext(cp_list, &start[i], &end[i])) {\n                    break;\n                }\n                partial_cp_count += end[i] - start[i] + 1;\n            }\n\n            invlist_iterfinish(cp_list);\n        }\n\n        /* If we know at compile time that this matches every possible code\n         * point, any run-time dependencies don't matter */\n        if (start[0] == 0 && end[0] == UV_MAX) {\n            if (invert) {\n                ret = reganode(pRExC_state, OPFAIL, 0);\n            }\n            else {\n                ret = reg_node(pRExC_state, SANY);\n                MARK_NAUGHTY(1);\n            }\n            goto not_anyof;\n        }\n\n        /* Similarly, for /l posix classes, if both a class and its\n         * complement match, any run-time dependencies don't matter */\n        if (posixl) {\n            for (namedclass = 0; namedclass < ANYOF_POSIXL_MAX;\n                                                        namedclass += 2)\n            {\n                if (   POSIXL_TEST(posixl, namedclass)      /* class */\n                    && POSIXL_TEST(posixl, namedclass + 1)) /* its complement */\n                {\n                    if (invert) {\n                        ret = reganode(pRExC_state, OPFAIL, 0);\n                    }\n                    else {\n                        ret = reg_node(pRExC_state, SANY);\n                        MARK_NAUGHTY(1);\n                    }\n                    goto not_anyof;\n                }\n            }\n            /* For well-behaved locales, some classes are subsets of others,\n             * so complementing the subset and including the non-complemented\n             * superset should match everything, like [\\D[:alnum:]], and\n             * [[:^alpha:][:alnum:]], but some implementations of locales are\n             * buggy, and khw thinks its a bad idea to have optimization change\n             * behavior, even if it avoids an OS bug in a given case */\n\n#define isSINGLE_BIT_SET(n) isPOWER_OF_2(n)\n\n            /* If is a single posix /l class, can optimize to just that op.\n             * Such a node will not match anything in the Latin1 range, as that\n             * is not determinable until runtime, but will match whatever the\n             * class does outside that range.  (Note that some classes won't\n             * match anything outside the range, like [:ascii:]) */\n            if (    isSINGLE_BIT_SET(posixl)\n                && (partial_cp_count == 0 || start[0] > 255))\n            {\n                U8 classnum;\n                SV * class_above_latin1 = NULL;\n                bool already_inverted;\n                bool are_equivalent;\n\n                /* Compute which bit is set, which is the same thing as, e.g.,\n                 * ANYOF_CNTRL.  From\n                 * https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogDeBruijn\n                 * */\n                static const int MultiplyDeBruijnBitPosition2[32] =\n                    {\n                    0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,\n                    31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9\n                    };\n\n                namedclass = MultiplyDeBruijnBitPosition2[(posixl\n                                                          * 0x077CB531U) >> 27];\n                classnum = namedclass_to_classnum(namedclass);\n\n                /* The named classes are such that the inverted number is one\n                 * larger than the non-inverted one */\n                already_inverted = namedclass\n                                 - classnum_to_namedclass(classnum);\n\n                /* Create an inversion list of the official property, inverted\n                 * if the constructed node list is inverted, and restricted to\n                 * only the above latin1 code points, which are the only ones\n                 * known at compile time */\n                _invlist_intersection_maybe_complement_2nd(\n                                                    PL_AboveLatin1,\n                                                    PL_XPosix_ptrs[classnum],\n                                                    already_inverted,\n                                                    &class_above_latin1);\n                are_equivalent = _invlistEQ(class_above_latin1, cp_list,\n                                                                        FALSE);\n                SvREFCNT_dec_NN(class_above_latin1);\n\n                if (are_equivalent) {\n\n                    /* Resolve the run-time inversion flag with this possibly\n                     * inverted class */\n                    invert = invert ^ already_inverted;\n\n                    ret = reg_node(pRExC_state,\n                                   POSIXL + invert * (NPOSIXL - POSIXL));\n                    FLAGS(REGNODE_p(ret)) = classnum;\n                    goto not_anyof;\n                }\n            }\n        }\n\n        /* khw can't think of any other possible transformation involving\n         * these. */\n        if (has_runtime_dependency & HAS_USER_DEFINED_PROPERTY) {\n            goto is_anyof;\n        }\n\n        if (! has_runtime_dependency) {\n\n            /* If the list is empty, nothing matches.  This happens, for\n             * example, when a Unicode property that doesn't match anything is\n             * the only element in the character class (perluniprops.pod notes\n             * such properties). */\n            if (partial_cp_count == 0) {\n                if (invert) {\n                    ret = reg_node(pRExC_state, SANY);\n                }\n                else {\n                    ret = reganode(pRExC_state, OPFAIL, 0);\n                }\n\n                goto not_anyof;\n            }\n\n            /* If matches everything but \\n */\n            if (   start[0] == 0 && end[0] == '\\n' - 1\n                && start[1] == '\\n' + 1 && end[1] == UV_MAX)\n            {\n                assert (! invert);\n                ret = reg_node(pRExC_state, REG_ANY);\n                MARK_NAUGHTY(1);\n                goto not_anyof;\n            }\n        }\n\n        /* Next see if can optimize classes that contain just a few code points\n         * into an EXACTish node.  The reason to do this is to let the\n         * optimizer join this node with adjacent EXACTish ones.\n         *\n         * An EXACTFish node can be generated even if not under /i, and vice\n         * versa.  But care must be taken.  An EXACTFish node has to be such\n         * that it only matches precisely the code points in the class, but we\n         * want to generate the least restrictive one that does that, to\n         * increase the odds of being able to join with an adjacent node.  For\n         * example, if the class contains [kK], we have to make it an EXACTFAA\n         * node to prevent the KELVIN SIGN from matching.  Whether we are under\n         * /i or not is irrelevant in this case.  Less obvious is the pattern\n         * qr/[\\x{02BC}]n/i.  U+02BC is MODIFIER LETTER APOSTROPHE. That is\n         * supposed to match the single character U+0149 LATIN SMALL LETTER N\n         * PRECEDED BY APOSTROPHE.  And so even though there is no simple fold\n         * that includes \\X{02BC}, there is a multi-char fold that does, and so\n         * the node generated for it must be an EXACTFish one.  On the other\n         * hand qr/:/i should generate a plain EXACT node since the colon\n         * participates in no fold whatsoever, and having it EXACT tells the\n         * optimizer the target string cannot match unless it has a colon in\n         * it.\n         *\n         * We don't typically generate an EXACTish node if doing so would\n         * require changing the pattern to UTF-8, as that affects /d and\n         * otherwise is slower.  However, under /i, not changing to UTF-8 can\n         * miss some potential multi-character folds.  We calculate the\n         * EXACTish node, and then decide if something would be missed if we\n         * don't upgrade */\n        if (   ! posixl\n            && ! invert\n\n                /* Only try if there are no more code points in the class than\n                 * in the max possible fold */\n            &&   partial_cp_count > 0 && partial_cp_count <= MAX_FOLD_FROMS + 1\n\n            && (start[0] < 256 || UTF || FOLD))\n        {\n            if (partial_cp_count == 1 && ! upper_latin1_only_utf8_matches)\n            {\n                /* We can always make a single code point class into an\n                 * EXACTish node. */\n\n                if (LOC) {\n\n                    /* Here is /l:  Use EXACTL, except /li indicates EXACTFL,\n                     * as that means there is a fold not known until runtime so\n                     * shows as only a single code point here. */\n                    op = (FOLD) ? EXACTFL : EXACTL;\n                }\n                else if (! FOLD) { /* Not /l and not /i */\n                    op = (start[0] < 256) ? EXACT : EXACT_ONLY8;\n                }\n                else if (start[0] < 256) { /* /i, not /l, and the code point is\n                                              small */\n\n                    /* Under /i, it gets a little tricky.  A code point that\n                     * doesn't participate in a fold should be an EXACT node.\n                     * We know this one isn't the result of a simple fold, or\n                     * there'd be more than one code point in the list, but it\n                     * could be part of a multi- character fold.  In that case\n                     * we better not create an EXACT node, as we would wrongly\n                     * be telling the optimizer that this code point must be in\n                     * the target string, and that is wrong.  This is because\n                     * if the sequence around this code point forms a\n                     * multi-char fold, what needs to be in the string could be\n                     * the code point that folds to the sequence.\n                     *\n                     * This handles the case of below-255 code points, as we\n                     * have an easy look up for those.  The next clause handles\n                     * the above-256 one */\n                    op = IS_IN_SOME_FOLD_L1(start[0])\n                         ? EXACTFU\n                         : EXACT;\n                }\n                else {  /* /i, larger code point.  Since we are under /i, and\n                           have just this code point, we know that it can't\n                           fold to something else, so PL_InMultiCharFold\n                           applies to it */\n                    op = _invlist_contains_cp(PL_InMultiCharFold,\n                                              start[0])\n                         ? EXACTFU_ONLY8\n                         : EXACT_ONLY8;\n                }\n\n                value = start[0];\n            }\n            else if (  ! (has_runtime_dependency & ~HAS_D_RUNTIME_DEPENDENCY)\n                     && _invlist_contains_cp(PL_in_some_fold, start[0]))\n            {\n                /* Here, the only runtime dependency, if any, is from /d, and\n                 * the class matches more than one code point, and the lowest\n                 * code point participates in some fold.  It might be that the\n                 * other code points are /i equivalent to this one, and hence\n                 * they would representable by an EXACTFish node.  Above, we\n                 * eliminated classes that contain too many code points to be\n                 * EXACTFish, with the test for MAX_FOLD_FROMS\n                 *\n                 * First, special case the ASCII fold pairs, like 'B' and 'b'.\n                 * We do this because we have EXACTFAA at our disposal for the\n                 * ASCII range */\n                if (partial_cp_count == 2 && isASCII(start[0])) {\n\n                    /* The only ASCII characters that participate in folds are\n                     * alphabetics */\n                    assert(isALPHA(start[0]));\n                    if (   end[0] == start[0]   /* First range is a single\n                                                   character, so 2nd exists */\n                        && isALPHA_FOLD_EQ(start[0], start[1]))\n                    {\n\n                        /* Here, is part of an ASCII fold pair */\n\n                        if (   ASCII_FOLD_RESTRICTED\n                            || HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(start[0]))\n                        {\n                            /* If the second clause just above was true, it\n                             * means we can't be under /i, or else the list\n                             * would have included more than this fold pair.\n                             * Therefore we have to exclude the possibility of\n                             * whatever else it is that folds to these, by\n                             * using EXACTFAA */\n                            op = EXACTFAA;\n                        }\n                        else if (HAS_NONLATIN1_FOLD_CLOSURE(start[0])) {\n\n                            /* Here, there's no simple fold that start[0] is part\n                             * of, but there is a multi-character one.  If we\n                             * are not under /i, we want to exclude that\n                             * possibility; if under /i, we want to include it\n                             * */\n                            op = (FOLD) ? EXACTFU : EXACTFAA;\n                        }\n                        else {\n\n                            /* Here, the only possible fold start[0] particpates in\n                             * is with start[1].  /i or not isn't relevant */\n                            op = EXACTFU;\n                        }\n\n                        value = toFOLD(start[0]);\n                    }\n                }\n                else if (  ! upper_latin1_only_utf8_matches\n                         || (   _invlist_len(upper_latin1_only_utf8_matches)\n                                                                          == 2\n                             && PL_fold_latin1[\n                               invlist_highest(upper_latin1_only_utf8_matches)]\n                             == start[0]))\n                {\n                    /* Here, the smallest character is non-ascii or there are\n                     * more than 2 code points matched by this node.  Also, we\n                     * either don't have /d UTF-8 dependent matches, or if we\n                     * do, they look like they could be a single character that\n                     * is the fold of the lowest one in the always-match list.\n                     * This test quickly excludes most of the false positives\n                     * when there are /d UTF-8 depdendent matches.  These are\n                     * like LATIN CAPITAL LETTER A WITH GRAVE matching LATIN\n                     * SMALL LETTER A WITH GRAVE iff the target string is\n                     * UTF-8.  (We don't have to worry above about exceeding\n                     * the array bounds of PL_fold_latin1[] because any code\n                     * point in 'upper_latin1_only_utf8_matches' is below 256.)\n                     *\n                     * EXACTFAA would apply only to pairs (hence exactly 2 code\n                     * points) in the ASCII range, so we can't use it here to\n                     * artificially restrict the fold domain, so we check if\n                     * the class does or does not match some EXACTFish node.\n                     * Further, if we aren't under /i, and and the folded-to\n                     * character is part of a multi-character fold, we can't do\n                     * this optimization, as the sequence around it could be\n                     * that multi-character fold, and we don't here know the\n                     * context, so we have to assume it is that multi-char\n                     * fold, to prevent potential bugs.\n                     *\n                     * To do the general case, we first find the fold of the\n                     * lowest code point (which may be higher than the lowest\n                     * one), then find everything that folds to it.  (The data\n                     * structure we have only maps from the folded code points,\n                     * so we have to do the earlier step.) */\n\n                    Size_t foldlen;\n                    U8 foldbuf[UTF8_MAXBYTES_CASE];\n                    UV folded = _to_uni_fold_flags(start[0],\n                                                        foldbuf, &foldlen, 0);\n                    unsigned int first_fold;\n                    const unsigned int * remaining_folds;\n                    Size_t folds_to_this_cp_count = _inverse_folds(\n                                                            folded,\n                                                            &first_fold,\n                                                            &remaining_folds);\n                    Size_t folds_count = folds_to_this_cp_count + 1;\n                    SV * fold_list = _new_invlist(folds_count);\n                    unsigned int i;\n\n                    /* If there are UTF-8 dependent matches, create a temporary\n                     * list of what this node matches, including them. */\n                    SV * all_cp_list = NULL;\n                    SV ** use_this_list = &cp_list;\n\n                    if (upper_latin1_only_utf8_matches) {\n                        all_cp_list = _new_invlist(0);\n                        use_this_list = &all_cp_list;\n                        _invlist_union(cp_list,\n                                       upper_latin1_only_utf8_matches,\n                                       use_this_list);\n                    }\n\n                    /* Having gotten everything that participates in the fold\n                     * containing the lowest code point, we turn that into an\n                     * inversion list, making sure everything is included. */\n                    fold_list = add_cp_to_invlist(fold_list, start[0]);\n                    fold_list = add_cp_to_invlist(fold_list, folded);\n                    if (folds_to_this_cp_count > 0) {\n                        fold_list = add_cp_to_invlist(fold_list, first_fold);\n                        for (i = 0; i + 1 < folds_to_this_cp_count; i++) {\n                            fold_list = add_cp_to_invlist(fold_list,\n                                                        remaining_folds[i]);\n                        }\n                    }\n\n                    /* If the fold list is identical to what's in this ANYOF\n                     * node, the node can be represented by an EXACTFish one\n                     * instead */\n                    if (_invlistEQ(*use_this_list, fold_list,\n                                   0 /* Don't complement */ )\n                    ) {\n\n                        /* But, we have to be careful, as mentioned above.\n                         * Just the right sequence of characters could match\n                         * this if it is part of a multi-character fold.  That\n                         * IS what we want if we are under /i.  But it ISN'T\n                         * what we want if not under /i, as it could match when\n                         * it shouldn't.  So, when we aren't under /i and this\n                         * character participates in a multi-char fold, we\n                         * don't optimize into an EXACTFish node.  So, for each\n                         * case below we have to check if we are folding\n                         * and if not, if it is not part of a multi-char fold.\n                         * */\n                        if (start[0] > 255) {    /* Highish code point */\n                            if (FOLD || ! _invlist_contains_cp(\n                                            PL_InMultiCharFold, folded))\n                            {\n                                op = (LOC)\n                                     ? EXACTFLU8\n                                     : (ASCII_FOLD_RESTRICTED)\n                                       ? EXACTFAA\n                                       : EXACTFU_ONLY8;\n                                value = folded;\n                            }\n                        }   /* Below, the lowest code point < 256 */\n                        else if (    FOLD\n                                 &&  folded == 's'\n                                 &&  DEPENDS_SEMANTICS)\n                        {   /* An EXACTF node containing a single character\n                                's', can be an EXACTFU if it doesn't get\n                                joined with an adjacent 's' */\n                            op = EXACTFU_S_EDGE;\n                            value = folded;\n                        }\n                        else if (    FOLD\n                                || ! HAS_NONLATIN1_FOLD_CLOSURE(start[0]))\n                        {\n                            if (upper_latin1_only_utf8_matches) {\n                                op = EXACTF;\n\n                                /* We can't use the fold, as that only matches\n                                 * under UTF-8 */\n                                value = start[0];\n                            }\n                            else if (     UNLIKELY(start[0] == MICRO_SIGN)\n                                     && ! UTF)\n                            {   /* EXACTFUP is a special node for this\n                                   character */\n                                op = (ASCII_FOLD_RESTRICTED)\n                                     ? EXACTFAA\n                                     : EXACTFUP;\n                                value = MICRO_SIGN;\n                            }\n                            else if (     ASCII_FOLD_RESTRICTED\n                                     && ! isASCII(start[0]))\n                            {   /* For ASCII under /iaa, we can use EXACTFU\n                                   below */\n                                op = EXACTFAA;\n                                value = folded;\n                            }\n                            else {\n                                op = EXACTFU;\n                                value = folded;\n                            }\n                        }\n                    }\n\n                    SvREFCNT_dec_NN(fold_list);\n                    SvREFCNT_dec(all_cp_list);\n                }\n            }\n\n            if (op != END) {\n\n                /* Here, we have calculated what EXACTish node we would use.\n                 * But we don't use it if it would require converting the\n                 * pattern to UTF-8, unless not using it could cause us to miss\n                 * some folds (hence be buggy) */\n\n                if (! UTF && value > 255) {\n                    SV * in_multis = NULL;\n\n                    assert(FOLD);\n\n                    /* If there is no code point that is part of a multi-char\n                     * fold, then there aren't any matches, so we don't do this\n                     * optimization.  Otherwise, it could match depending on\n                     * the context around us, so we do upgrade */\n                    _invlist_intersection(PL_InMultiCharFold, cp_list, &in_multis);\n                    if (UNLIKELY(_invlist_len(in_multis) != 0)) {\n                        REQUIRE_UTF8(flagp);\n                    }\n                    else {\n                        op = END;\n                    }\n                }\n\n                if (op != END) {\n                    U8 len = (UTF) ? UVCHR_SKIP(value) : 1;\n\n                    ret = regnode_guts(pRExC_state, op, len, \"exact\");\n                    FILL_NODE(ret, op);\n                    RExC_emit += 1 + STR_SZ(len);\n                    STR_LEN(REGNODE_p(ret)) = len;\n                    if (len == 1) {\n                        *STRING(REGNODE_p(ret)) = (U8) value;\n                    }\n                    else {\n                        uvchr_to_utf8((U8 *) STRING(REGNODE_p(ret)), value);\n                    }\n                    goto not_anyof;\n                }\n            }\n        }\n\n        if (! has_runtime_dependency) {\n\n            /* See if this can be turned into an ANYOFM node.  Think about the\n             * bit patterns in two different bytes.  In some positions, the\n             * bits in each will be 1; and in other positions both will be 0;\n             * and in some positions the bit will be 1 in one byte, and 0 in\n             * the other.  Let 'n' be the number of positions where the bits\n             * differ.  We create a mask which has exactly 'n' 0 bits, each in\n             * a position where the two bytes differ.  Now take the set of all\n             * bytes that when ANDed with the mask yield the same result.  That\n             * set has 2**n elements, and is representable by just two 8 bit\n             * numbers: the result and the mask.  Importantly, matching the set\n             * can be vectorized by creating a word full of the result bytes,\n             * and a word full of the mask bytes, yielding a significant speed\n             * up.  Here, see if this node matches such a set.  As a concrete\n             * example consider [01], and the byte representing '0' which is\n             * 0x30 on ASCII machines.  It has the bits 0011 0000.  Take the\n             * mask 1111 1110.  If we AND 0x31 and 0x30 with that mask we get\n             * 0x30.  Any other bytes ANDed yield something else.  So [01],\n             * which is a common usage, is optimizable into ANYOFM, and can\n             * benefit from the speed up.  We can only do this on UTF-8\n             * invariant bytes, because they have the same bit patterns under\n             * UTF-8 as not. */\n            PERL_UINT_FAST8_T inverted = 0;\n#ifdef EBCDIC\n            const PERL_UINT_FAST8_T max_permissible = 0xFF;\n#else\n            const PERL_UINT_FAST8_T max_permissible = 0x7F;\n#endif\n            /* If doesn't fit the criteria for ANYOFM, invert and try again.\n             * If that works we will instead later generate an NANYOFM, and\n             * invert back when through */\n            if (invlist_highest(cp_list) > max_permissible) {\n                _invlist_invert(cp_list);\n                inverted = 1;\n            }\n\n            if (invlist_highest(cp_list) <= max_permissible) {\n                UV this_start, this_end;\n                UV lowest_cp = UV_MAX;  /* inited to suppress compiler warn */\n                U8 bits_differing = 0;\n                Size_t full_cp_count = 0;\n                bool first_time = TRUE;\n\n                /* Go through the bytes and find the bit positions that differ\n                 * */\n                invlist_iterinit(cp_list);\n                while (invlist_iternext(cp_list, &this_start, &this_end)) {\n                    unsigned int i = this_start;\n\n                    if (first_time) {\n                        if (! UVCHR_IS_INVARIANT(i)) {\n                            goto done_anyofm;\n                        }\n\n                        first_time = FALSE;\n                        lowest_cp = this_start;\n\n                        /* We have set up the code point to compare with.\n                         * Don't compare it with itself */\n                        i++;\n                    }\n\n                    /* Find the bit positions that differ from the lowest code\n                     * point in the node.  Keep track of all such positions by\n                     * OR'ing */\n                    for (; i <= this_end; i++) {\n                        if (! UVCHR_IS_INVARIANT(i)) {\n                            goto done_anyofm;\n                        }\n\n                        bits_differing  |= i ^ lowest_cp;\n                    }\n\n                    full_cp_count += this_end - this_start + 1;\n                }\n                invlist_iterfinish(cp_list);\n\n                /* At the end of the loop, we count how many bits differ from\n                 * the bits in lowest code point, call the count 'd'.  If the\n                 * set we found contains 2**d elements, it is the closure of\n                 * all code points that differ only in those bit positions.  To\n                 * convince yourself of that, first note that the number in the\n                 * closure must be a power of 2, which we test for.  The only\n                 * way we could have that count and it be some differing set,\n                 * is if we got some code points that don't differ from the\n                 * lowest code point in any position, but do differ from each\n                 * other in some other position.  That means one code point has\n                 * a 1 in that position, and another has a 0.  But that would\n                 * mean that one of them differs from the lowest code point in\n                 * that position, which possibility we've already excluded.  */\n                if (  (inverted || full_cp_count > 1)\n                    && full_cp_count == 1U << PL_bitcount[bits_differing])\n                {\n                    U8 ANYOFM_mask;\n\n                    op = ANYOFM + inverted;;\n\n                    /* We need to make the bits that differ be 0's */\n                    ANYOFM_mask = ~ bits_differing; /* This goes into FLAGS */\n\n                    /* The argument is the lowest code point */\n                    ret = reganode(pRExC_state, op, lowest_cp);\n                    FLAGS(REGNODE_p(ret)) = ANYOFM_mask;\n                }\n            }\n          done_anyofm:\n\n            if (inverted) {\n                _invlist_invert(cp_list);\n            }\n\n            if (op != END) {\n                goto not_anyof;\n            }\n        }\n\n        if (! (anyof_flags & ANYOF_LOCALE_FLAGS)) {\n            PERL_UINT_FAST8_T type;\n            SV * intersection = NULL;\n            SV* d_invlist = NULL;\n\n            /* See if this matches any of the POSIX classes.  The POSIXA and\n             * POSIXD ones are about the same speed as ANYOF ops, but take less\n             * room; the ones that have above-Latin1 code point matches are\n             * somewhat faster than ANYOF.  */\n\n            for (type = POSIXA; type >= POSIXD; type--) {\n                int posix_class;\n\n                if (type == POSIXL) {   /* But not /l posix classes */\n                    continue;\n                }\n\n                for (posix_class = 0;\n                     posix_class <= _HIGHEST_REGCOMP_DOT_H_SYNC;\n                     posix_class++)\n                {\n                    SV** our_code_points = &cp_list;\n                    SV** official_code_points;\n                    int try_inverted;\n\n                    if (type == POSIXA) {\n                        official_code_points = &PL_Posix_ptrs[posix_class];\n                    }\n                    else {\n                        official_code_points = &PL_XPosix_ptrs[posix_class];\n                    }\n\n                    /* Skip non-existent classes of this type.  e.g. \\v only\n                     * has an entry in PL_XPosix_ptrs */\n                    if (! *official_code_points) {\n                        continue;\n                    }\n\n                    /* Try both the regular class, and its inversion */\n                    for (try_inverted = 0; try_inverted < 2; try_inverted++) {\n                        bool this_inverted = invert ^ try_inverted;\n\n                        if (type != POSIXD) {\n\n                            /* This class that isn't /d can't match if we have\n                             * /d dependencies */\n                            if (has_runtime_dependency\n                                                    & HAS_D_RUNTIME_DEPENDENCY)\n                            {\n                                continue;\n                            }\n                        }\n                        else /* is /d */ if (! this_inverted) {\n\n                            /* /d classes don't match anything non-ASCII below\n                             * 256 unconditionally (which cp_list contains) */\n                            _invlist_intersection(cp_list, PL_UpperLatin1,\n                                                           &intersection);\n                            if (_invlist_len(intersection) != 0) {\n                                continue;\n                            }\n\n                            SvREFCNT_dec(d_invlist);\n                            d_invlist = invlist_clone(cp_list, NULL);\n\n                            /* But under UTF-8 it turns into using /u rules.\n                             * Add the things it matches under these conditions\n                             * so that we check below that these are identical\n                             * to what the tested class should match */\n                            if (upper_latin1_only_utf8_matches) {\n                                _invlist_union(\n                                            d_invlist,\n                                            upper_latin1_only_utf8_matches,\n                                            &d_invlist);\n                            }\n                            our_code_points = &d_invlist;\n                        }\n                        else {  /* POSIXD, inverted.  If this doesn't have this\n                                   flag set, it isn't /d. */\n                            if (! (anyof_flags & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER))\n                            {\n                                continue;\n                            }\n                            our_code_points = &cp_list;\n                        }\n\n                        /* Here, have weeded out some things.  We want to see\n                         * if the list of characters this node contains\n                         * ('*our_code_points') precisely matches those of the\n                         * class we are currently checking against\n                         * ('*official_code_points'). */\n                        if (_invlistEQ(*our_code_points,\n                                       *official_code_points,\n                                       try_inverted))\n                        {\n                            /* Here, they precisely match.  Optimize this ANYOF\n                             * node into its equivalent POSIX one of the\n                             * correct type, possibly inverted */\n                            ret = reg_node(pRExC_state, (try_inverted)\n                                                        ? type + NPOSIXA\n                                                                - POSIXA\n                                                        : type);\n                            FLAGS(REGNODE_p(ret)) = posix_class;\n                            SvREFCNT_dec(d_invlist);\n                            SvREFCNT_dec(intersection);\n                            goto not_anyof;\n                        }\n                    }\n                }\n            }\n            SvREFCNT_dec(d_invlist);\n            SvREFCNT_dec(intersection);\n        }\n\n        /* If didn't find an optimization and there is no need for a\n        * bitmap, optimize to indicate that */\n        if (     start[0] >= NUM_ANYOF_CODE_POINTS\n            && ! LOC\n            && ! upper_latin1_only_utf8_matches\n            &&   anyof_flags == 0)\n        {\n            UV highest_cp = invlist_highest(cp_list);\n\n            /* If the lowest and highest code point in the class have the same\n             * UTF-8 first byte, then all do, and we can store that byte for\n             * regexec.c to use so that it can more quickly scan the target\n             * string for potential matches for this class.  We co-opt the the\n             * flags field for this.  Zero means, they don't have the same\n             * first byte.  We do accept here very large code points (for\n             * future use), but don't bother with this optimization for them,\n             * as it would cause other complications */\n            if (highest_cp > IV_MAX) {\n                anyof_flags = 0;\n            }\n            else {\n                U8 low_utf8[UTF8_MAXBYTES+1];\n                U8 high_utf8[UTF8_MAXBYTES+1];\n\n                (void) uvchr_to_utf8(low_utf8, start[0]);\n                (void) uvchr_to_utf8(high_utf8, invlist_highest(cp_list));\n\n                anyof_flags = (low_utf8[0] == high_utf8[0])\n                            ? low_utf8[0]\n                            : 0;\n            }\n\n            op = ANYOFH;\n        }\n    }   /* End of seeing if can optimize it into a different node */\n\n  is_anyof: /* It's going to be an ANYOF node. */\n    if (op != ANYOFH) {\n        op = (has_runtime_dependency & HAS_D_RUNTIME_DEPENDENCY)\n             ? ANYOFD\n             : ((posixl)\n                ? ANYOFPOSIXL\n                : ((LOC)\n                   ? ANYOFL\n                   : ANYOF));\n    }\n\n    ret = regnode_guts(pRExC_state, op, regarglen[op], \"anyof\");\n    FILL_NODE(ret, op);        /* We set the argument later */\n    RExC_emit += 1 + regarglen[op];\n    ANYOF_FLAGS(REGNODE_p(ret)) = anyof_flags;\n\n    /* Here, <cp_list> contains all the code points we can determine at\n     * compile time that match under all conditions.  Go through it, and\n     * for things that belong in the bitmap, put them there, and delete from\n     * <cp_list>.  While we are at it, see if everything above 255 is in the\n     * list, and if so, set a flag to speed up execution */\n\n    populate_ANYOF_from_invlist(REGNODE_p(ret), &cp_list);\n\n    if (posixl) {\n        ANYOF_POSIXL_SET_TO_BITMAP(REGNODE_p(ret), posixl);\n    }\n\n    if (invert) {\n        ANYOF_FLAGS(REGNODE_p(ret)) |= ANYOF_INVERT;\n    }\n\n    /* Here, the bitmap has been populated with all the Latin1 code points that\n     * always match.  Can now add to the overall list those that match only\n     * when the target string is UTF-8 (<upper_latin1_only_utf8_matches>).\n     * */\n    if (upper_latin1_only_utf8_matches) {\n\tif (cp_list) {\n\t    _invlist_union(cp_list,\n                           upper_latin1_only_utf8_matches,\n                           &cp_list);\n\t    SvREFCNT_dec_NN(upper_latin1_only_utf8_matches);\n\t}\n\telse {\n\t    cp_list = upper_latin1_only_utf8_matches;\n\t}\n        ANYOF_FLAGS(REGNODE_p(ret)) |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;\n    }\n\n    set_ANYOF_arg(pRExC_state, REGNODE_p(ret), cp_list,\n                  (HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)\n                   ? listsv : NULL,\n                  only_utf8_locale_list);\n    return ret;\n\n  not_anyof:\n\n    /* Here, the node is getting optimized into something that's not an ANYOF\n     * one.  Finish up. */\n\n    Set_Node_Offset_Length(REGNODE_p(ret), orig_parse - RExC_start,\n                                           RExC_parse - orig_parse);;\n    SvREFCNT_dec(cp_list);;\n    return ret;\n}\n\n#undef HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION\n\nSTATIC void\nS_set_ANYOF_arg(pTHX_ RExC_state_t* const pRExC_state,\n                regnode* const node,\n                SV* const cp_list,\n                SV* const runtime_defns,\n                SV* const only_utf8_locale_list)\n{\n    /* Sets the arg field of an ANYOF-type node 'node', using information about\n     * the node passed-in.  If there is nothing outside the node's bitmap, the\n     * arg is set to ANYOF_ONLY_HAS_BITMAP.  Otherwise, it sets the argument to\n     * the count returned by add_data(), having allocated and stored an array,\n     * av, as follows:\n     *\n     *  av[0] stores the inversion list defining this class as far as known at\n     *        this time, or PL_sv_undef if nothing definite is now known.\n     *  av[1] stores the inversion list of code points that match only if the\n     *        current locale is UTF-8, or if none, PL_sv_undef if there is an\n     *        av[2], or no entry otherwise.\n     *  av[2] stores the list of user-defined properties whose subroutine\n     *        definitions aren't known at this time, or no entry if none. */\n\n    UV n;\n\n    PERL_ARGS_ASSERT_SET_ANYOF_ARG;\n\n    if (! cp_list && ! runtime_defns && ! only_utf8_locale_list) {\n        assert(! (ANYOF_FLAGS(node)\n                & ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP));\n\tARG_SET(node, ANYOF_ONLY_HAS_BITMAP);\n    }\n    else {\n\tAV * const av = newAV();\n\tSV *rv;\n\n        if (cp_list) {\n            av_store(av, INVLIST_INDEX, cp_list);\n        }\n\n        if (only_utf8_locale_list) {\n            av_store(av, ONLY_LOCALE_MATCHES_INDEX, only_utf8_locale_list);\n        }\n\n        if (runtime_defns) {\n            av_store(av, DEFERRED_USER_DEFINED_INDEX, SvREFCNT_inc(runtime_defns));\n        }\n\n\trv = newRV_noinc(MUTABLE_SV(av));\n\tn = add_data(pRExC_state, STR_WITH_LEN(\"s\"));\n\tRExC_rxi->data->data[n] = (void*)rv;\n\tARG_SET(node, n);\n    }\n}\n\n#if !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION)\nSV *\nPerl__get_regclass_nonbitmap_data(pTHX_ const regexp *prog,\n                                        const regnode* node,\n                                        bool doinit,\n                                        SV** listsvp,\n                                        SV** only_utf8_locale_ptr,\n                                        SV** output_invlist)\n\n{\n    /* For internal core use only.\n     * Returns the inversion list for the input 'node' in the regex 'prog'.\n     * If <doinit> is 'true', will attempt to create the inversion list if not\n     *    already done.\n     * If <listsvp> is non-null, will return the printable contents of the\n     *    property definition.  This can be used to get debugging information\n     *    even before the inversion list exists, by calling this function with\n     *    'doinit' set to false, in which case the components that will be used\n     *    to eventually create the inversion list are returned  (in a printable\n     *    form).\n     * If <only_utf8_locale_ptr> is not NULL, it is where this routine is to\n     *    store an inversion list of code points that should match only if the\n     *    execution-time locale is a UTF-8 one.\n     * If <output_invlist> is not NULL, it is where this routine is to store an\n     *    inversion list of the code points that would be instead returned in\n     *    <listsvp> if this were NULL.  Thus, what gets output in <listsvp>\n     *    when this parameter is used, is just the non-code point data that\n     *    will go into creating the inversion list.  This currently should be just\n     *    user-defined properties whose definitions were not known at compile\n     *    time.  Using this parameter allows for easier manipulation of the\n     *    inversion list's data by the caller.  It is illegal to call this\n     *    function with this parameter set, but not <listsvp>\n     *\n     * Tied intimately to how S_set_ANYOF_arg sets up the data structure.  Note\n     * that, in spite of this function's name, the inversion list it returns\n     * may include the bitmap data as well */\n\n    SV *si  = NULL;         /* Input initialization string */\n    SV* invlist = NULL;\n\n    RXi_GET_DECL(prog, progi);\n    const struct reg_data * const data = prog ? progi->data : NULL;\n\n    PERL_ARGS_ASSERT__GET_REGCLASS_NONBITMAP_DATA;\n    assert(! output_invlist || listsvp);\n\n    if (data && data->count) {\n\tconst U32 n = ARG(node);\n\n\tif (data->what[n] == 's') {\n\t    SV * const rv = MUTABLE_SV(data->data[n]);\n\t    AV * const av = MUTABLE_AV(SvRV(rv));\n\t    SV **const ary = AvARRAY(av);\n\n            invlist = ary[INVLIST_INDEX];\n\n            if (av_tindex_skip_len_mg(av) >= ONLY_LOCALE_MATCHES_INDEX) {\n                *only_utf8_locale_ptr = ary[ONLY_LOCALE_MATCHES_INDEX];\n            }\n\n            if (av_tindex_skip_len_mg(av) >= DEFERRED_USER_DEFINED_INDEX) {\n                si = ary[DEFERRED_USER_DEFINED_INDEX];\n            }\n\n\t    if (doinit && (si || invlist)) {\n                if (si) {\n                    bool user_defined;\n                    SV * msg = newSVpvs_flags(\"\", SVs_TEMP);\n\n                    SV * prop_definition = handle_user_defined_property(\n                            \"\", 0, FALSE,   /* There is no \\p{}, \\P{} */\n                            SvPVX_const(si)[1] - '0',   /* /i or not has been\n                                                           stored here for just\n                                                           this occasion */\n                            TRUE,           /* run time */\n                            FALSE,          /* This call must find the defn */\n                            si,             /* The property definition  */\n                            &user_defined,\n                            msg,\n                            0               /* base level call */\n                           );\n\n                    if (SvCUR(msg)) {\n                        assert(prop_definition == NULL);\n\n                        Perl_croak(aTHX_ \"%\" UTF8f,\n                                UTF8fARG(SvUTF8(msg), SvCUR(msg), SvPVX(msg)));\n                    }\n\n                    if (invlist) {\n                        _invlist_union(invlist, prop_definition, &invlist);\n                        SvREFCNT_dec_NN(prop_definition);\n                    }\n                    else {\n                        invlist = prop_definition;\n                    }\n\n                    STATIC_ASSERT_STMT(ONLY_LOCALE_MATCHES_INDEX == 1 + INVLIST_INDEX);\n                    STATIC_ASSERT_STMT(DEFERRED_USER_DEFINED_INDEX == 1 + ONLY_LOCALE_MATCHES_INDEX);\n\n                    av_store(av, INVLIST_INDEX, invlist);\n                    av_fill(av, (ary[ONLY_LOCALE_MATCHES_INDEX])\n                                 ? ONLY_LOCALE_MATCHES_INDEX:\n                                 INVLIST_INDEX);\n                    si = NULL;\n                }\n\t    }\n\t}\n    }\n\n    /* If requested, return a printable version of what this ANYOF node matches\n     * */\n    if (listsvp) {\n\tSV* matches_string = NULL;\n\n        /* This function can be called at compile-time, before everything gets\n         * resolved, in which case we return the currently best available\n         * information, which is the string that will eventually be used to do\n         * that resolving, 'si' */\n\tif (si) {\n            /* Here, we only have 'si' (and possibly some passed-in data in\n             * 'invlist', which is handled below)  If the caller only wants\n             * 'si', use that.  */\n            if (! output_invlist) {\n                matches_string = newSVsv(si);\n            }\n            else {\n                /* But if the caller wants an inversion list of the node, we\n                 * need to parse 'si' and place as much as possible in the\n                 * desired output inversion list, making 'matches_string' only\n                 * contain the currently unresolvable things */\n                const char *si_string = SvPVX(si);\n                STRLEN remaining = SvCUR(si);\n                UV prev_cp = 0;\n                U8 count = 0;\n\n                /* Ignore everything before the first new-line */\n                while (*si_string != '\\n' && remaining > 0) {\n                    si_string++;\n                    remaining--;\n                }\n                assert(remaining > 0);\n\n                si_string++;\n                remaining--;\n\n                while (remaining > 0) {\n\n                    /* The data consists of just strings defining user-defined\n                     * property names, but in prior incarnations, and perhaps\n                     * somehow from pluggable regex engines, it could still\n                     * hold hex code point definitions.  Each component of a\n                     * range would be separated by a tab, and each range by a\n                     * new-line.  If these are found, instead add them to the\n                     * inversion list */\n                    I32 grok_flags =  PERL_SCAN_SILENT_ILLDIGIT\n                                     |PERL_SCAN_SILENT_NON_PORTABLE;\n                    STRLEN len = remaining;\n                    UV cp = grok_hex(si_string, &len, &grok_flags, NULL);\n\n                    /* If the hex decode routine found something, it should go\n                     * up to the next \\n */\n                    if (   *(si_string + len) == '\\n') {\n                        if (count) {    /* 2nd code point on line */\n                            *output_invlist = _add_range_to_invlist(*output_invlist, prev_cp, cp);\n                        }\n                        else {\n                            *output_invlist = add_cp_to_invlist(*output_invlist, cp);\n                        }\n                        count = 0;\n                        goto prepare_for_next_iteration;\n                    }\n\n                    /* If the hex decode was instead for the lower range limit,\n                     * save it, and go parse the upper range limit */\n                    if (*(si_string + len) == '\\t') {\n                        assert(count == 0);\n\n                        prev_cp = cp;\n                        count = 1;\n                      prepare_for_next_iteration:\n                        si_string += len + 1;\n                        remaining -= len + 1;\n                        continue;\n                    }\n\n                    /* Here, didn't find a legal hex number.  Just add it from\n                     * here to the next \\n */\n\n                    remaining -= len;\n                    while (*(si_string + len) != '\\n' && remaining > 0) {\n                        remaining--;\n                        len++;\n                    }\n                    if (*(si_string + len) == '\\n') {\n                        len++;\n                        remaining--;\n                    }\n                    if (matches_string) {\n                        sv_catpvn(matches_string, si_string, len - 1);\n                    }\n                    else {\n                        matches_string = newSVpvn(si_string, len - 1);\n                    }\n                    si_string += len;\n                    sv_catpvs(matches_string, \" \");\n                } /* end of loop through the text */\n\n                assert(matches_string);\n                if (SvCUR(matches_string)) {  /* Get rid of trailing blank */\n                    SvCUR_set(matches_string, SvCUR(matches_string) - 1);\n                }\n            } /* end of has an 'si' */\n\t}\n\n        /* Add the stuff that's already known */\n        if (invlist) {\n\n            /* Again, if the caller doesn't want the output inversion list, put\n             * everything in 'matches-string' */\n            if (! output_invlist) {\n                if ( ! matches_string) {\n                    matches_string = newSVpvs(\"\\n\");\n                }\n                sv_catsv(matches_string, invlist_contents(invlist,\n                                                  TRUE /* traditional style */\n                                                  ));\n            }\n            else if (! *output_invlist) {\n                *output_invlist = invlist_clone(invlist, NULL);\n            }\n            else {\n                _invlist_union(*output_invlist, invlist, output_invlist);\n            }\n        }\n\n\t*listsvp = matches_string;\n    }\n\n    return invlist;\n}\n#endif /* !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION) */\n\n/* reg_skipcomment()\n\n   Absorbs an /x style # comment from the input stream,\n   returning a pointer to the first character beyond the comment, or if the\n   comment terminates the pattern without anything following it, this returns\n   one past the final character of the pattern (in other words, RExC_end) and\n   sets the REG_RUN_ON_COMMENT_SEEN flag.\n\n   Note it's the callers responsibility to ensure that we are\n   actually in /x mode\n\n*/\n\nPERL_STATIC_INLINE char*\nS_reg_skipcomment(RExC_state_t *pRExC_state, char* p)\n{\n    PERL_ARGS_ASSERT_REG_SKIPCOMMENT;\n\n    assert(*p == '#');\n\n    while (p < RExC_end) {\n        if (*(++p) == '\\n') {\n            return p+1;\n        }\n    }\n\n    /* we ran off the end of the pattern without ending the comment, so we have\n     * to add an \\n when wrapping */\n    RExC_seen |= REG_RUN_ON_COMMENT_SEEN;\n    return p;\n}\n\nSTATIC void\nS_skip_to_be_ignored_text(pTHX_ RExC_state_t *pRExC_state,\n                                char ** p,\n                                const bool force_to_xmod\n                         )\n{\n    /* If the text at the current parse position '*p' is a '(?#...)' comment,\n     * or if we are under /x or 'force_to_xmod' is TRUE, and the text at '*p'\n     * is /x whitespace, advance '*p' so that on exit it points to the first\n     * byte past all such white space and comments */\n\n    const bool use_xmod = force_to_xmod || (RExC_flags & RXf_PMf_EXTENDED);\n\n    PERL_ARGS_ASSERT_SKIP_TO_BE_IGNORED_TEXT;\n\n    assert( ! UTF || UTF8_IS_INVARIANT(**p) || UTF8_IS_START(**p));\n\n    for (;;) {\n\tif (RExC_end - (*p) >= 3\n\t    && *(*p)     == '('\n\t    && *(*p + 1) == '?'\n\t    && *(*p + 2) == '#')\n\t{\n\t    while (*(*p) != ')') {\n\t\tif ((*p) == RExC_end)\n\t\t    FAIL(\"Sequence (?#... not terminated\");\n\t\t(*p)++;\n\t    }\n\t    (*p)++;\n\t    continue;\n\t}\n\n\tif (use_xmod) {\n            const char * save_p = *p;\n            while ((*p) < RExC_end) {\n                STRLEN len;\n                if ((len = is_PATWS_safe((*p), RExC_end, UTF))) {\n                    (*p) += len;\n                }\n                else if (*(*p) == '#') {\n                    (*p) = reg_skipcomment(pRExC_state, (*p));\n                }\n                else {\n                    break;\n                }\n            }\n            if (*p != save_p) {\n                continue;\n            }\n\t}\n\n        break;\n    }\n\n    return;\n}\n\n/* nextchar()\n\n   Advances the parse position by one byte, unless that byte is the beginning\n   of a '(?#...)' style comment, or is /x whitespace and /x is in effect.  In\n   those two cases, the parse position is advanced beyond all such comments and\n   white space.\n\n   This is the UTF, (?#...), and /x friendly way of saying RExC_parse++.\n*/\n\nSTATIC void\nS_nextchar(pTHX_ RExC_state_t *pRExC_state)\n{\n    PERL_ARGS_ASSERT_NEXTCHAR;\n\n    if (RExC_parse < RExC_end) {\n        assert(   ! UTF\n               || UTF8_IS_INVARIANT(*RExC_parse)\n               || UTF8_IS_START(*RExC_parse));\n\n        RExC_parse += (UTF)\n                      ? UTF8_SAFE_SKIP(RExC_parse, RExC_end)\n                      : 1;\n\n        skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                FALSE /* Don't force /x */ );\n    }\n}\n\nSTATIC void\nS_change_engine_size(pTHX_ RExC_state_t *pRExC_state, const Ptrdiff_t size)\n{\n    /* 'size' is the delta to add or subtract from the current memory allocated\n     * to the regex engine being constructed */\n\n    PERL_ARGS_ASSERT_CHANGE_ENGINE_SIZE;\n\n    RExC_size += size;\n\n    Renewc(RExC_rxi,\n           sizeof(regexp_internal) + (RExC_size + 1) * sizeof(regnode),\n                                                /* +1 for REG_MAGIC */\n           char,\n           regexp_internal);\n    if ( RExC_rxi == NULL )\n\tFAIL(\"Regexp out of space\");\n    RXi_SET(RExC_rx, RExC_rxi);\n\n    RExC_emit_start = RExC_rxi->program;\n    if (size > 0) {\n        Zero(REGNODE_p(RExC_emit), size, regnode);\n    }\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    Renew(RExC_offsets, 2*RExC_size+1, U32);\n    if (size > 0) {\n        Zero(RExC_offsets + 2*(RExC_size - size) + 1, 2 * size, U32);\n    }\n    RExC_offsets[0] = RExC_size;\n#endif\n}\n\nSTATIC regnode_offset\nS_regnode_guts(pTHX_ RExC_state_t *pRExC_state, const U8 op, const STRLEN extra_size, const char* const name)\n{\n    /* Allocate a regnode for 'op', with 'extra_size' extra space.  It aligns\n     * and increments RExC_size and RExC_emit\n     *\n     * It returns the regnode's offset into the regex engine program */\n\n    const regnode_offset ret = RExC_emit;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGNODE_GUTS;\n\n    SIZE_ALIGN(RExC_size);\n    change_engine_size(pRExC_state, (Ptrdiff_t) 1 + extra_size);\n    NODE_ALIGN_FILL(REGNODE_p(ret));\n#ifndef RE_TRACK_PATTERN_OFFSETS\n    PERL_UNUSED_ARG(name);\n    PERL_UNUSED_ARG(op);\n#else\n    assert(extra_size >= regarglen[op] || PL_regkind[op] == ANYOF);\n\n    if (RExC_offsets) {         /* MJD */\n\tMJD_OFFSET_DEBUG(\n              (\"%s:%d: (op %s) %s %\" UVuf \" (len %\" UVuf \") (max %\" UVuf \").\\n\",\n              name, __LINE__,\n              PL_reg_name[op],\n              (UV)(RExC_emit) > RExC_offsets[0]\n\t\t? \"Overwriting end of array!\\n\" : \"OK\",\n              (UV)(RExC_emit),\n              (UV)(RExC_parse - RExC_start),\n              (UV)RExC_offsets[0]));\n\tSet_Node_Offset(REGNODE_p(RExC_emit), RExC_parse + (op == END));\n    }\n#endif\n    return(ret);\n}\n\n/*\n- reg_node - emit a node\n*/\nSTATIC regnode_offset /* Location. */\nS_reg_node(pTHX_ RExC_state_t *pRExC_state, U8 op)\n{\n    const regnode_offset ret = regnode_guts(pRExC_state, op, regarglen[op], \"reg_node\");\n    regnode_offset ptr = ret;\n\n    PERL_ARGS_ASSERT_REG_NODE;\n\n    assert(regarglen[op] == 0);\n\n    FILL_ADVANCE_NODE(ptr, op);\n    RExC_emit = ptr;\n    return(ret);\n}\n\n/*\n- reganode - emit a node with an argument\n*/\nSTATIC regnode_offset /* Location. */\nS_reganode(pTHX_ RExC_state_t *pRExC_state, U8 op, U32 arg)\n{\n    const regnode_offset ret = regnode_guts(pRExC_state, op, regarglen[op], \"reganode\");\n    regnode_offset ptr = ret;\n\n    PERL_ARGS_ASSERT_REGANODE;\n\n    /* ANYOF are special cased to allow non-length 1 args */\n    assert(regarglen[op] == 1);\n\n    FILL_ADVANCE_NODE_ARG(ptr, op, arg);\n    RExC_emit = ptr;\n    return(ret);\n}\n\nSTATIC regnode_offset\nS_reg2Lanode(pTHX_ RExC_state_t *pRExC_state, const U8 op, const U32 arg1, const I32 arg2)\n{\n    /* emit a node with U32 and I32 arguments */\n\n    const regnode_offset ret = regnode_guts(pRExC_state, op, regarglen[op], \"reg2Lanode\");\n    regnode_offset ptr = ret;\n\n    PERL_ARGS_ASSERT_REG2LANODE;\n\n    assert(regarglen[op] == 2);\n\n    FILL_ADVANCE_NODE_2L_ARG(ptr, op, arg1, arg2);\n    RExC_emit = ptr;\n    return(ret);\n}\n\n/*\n- reginsert - insert an operator in front of already-emitted operand\n*\n* That means that on exit 'operand' is the offset of the newly inserted\n* operator, and the original operand has been relocated.\n*\n* IMPORTANT NOTE - it is the *callers* responsibility to correctly\n* set up NEXT_OFF() of the inserted node if needed. Something like this:\n*\n*   reginsert(pRExC, OPFAIL, orig_emit, depth+1);\n*   NEXT_OFF(orig_emit) = regarglen[OPFAIL] + NODE_STEP_REGNODE;\n*\n* ALSO NOTE - FLAGS(newly-inserted-operator) will be set to 0 as well.\n*/\nSTATIC void\nS_reginsert(pTHX_ RExC_state_t *pRExC_state, const U8 op,\n                  const regnode_offset operand, const U32 depth)\n{\n    regnode *src;\n    regnode *dst;\n    regnode *place;\n    const int offset = regarglen[(U8)op];\n    const int size = NODE_STEP_REGNODE + offset;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGINSERT;\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(depth);\n/* (PL_regkind[(U8)op] == CURLY ? EXTRA_STEP_2ARGS : 0); */\n    DEBUG_PARSE_FMT(\"inst\",\" - %s\", PL_reg_name[op]);\n    assert(!RExC_study_started); /* I believe we should never use reginsert once we have started\n                                    studying. If this is wrong then we need to adjust RExC_recurse\n                                    below like we do with RExC_open_parens/RExC_close_parens. */\n    change_engine_size(pRExC_state, (Ptrdiff_t) size);\n    src = REGNODE_p(RExC_emit);\n    RExC_emit += size;\n    dst = REGNODE_p(RExC_emit);\n\n    /* If we are in a \"count the parentheses\" pass, the numbers are unreliable,\n     * and [perl #133871] shows this can lead to problems, so skip this\n     * realignment of parens until a later pass when they are reliable */\n    if (! IN_PARENS_PASS && RExC_open_parens) {\n        int paren;\n        /*DEBUG_PARSE_FMT(\"inst\",\" - %\" IVdf, (IV)RExC_npar);*/\n        /* remember that RExC_npar is rex->nparens + 1,\n         * iow it is 1 more than the number of parens seen in\n         * the pattern so far. */\n        for ( paren=0 ; paren < RExC_npar ; paren++ ) {\n            /* note, RExC_open_parens[0] is the start of the\n             * regex, it can't move. RExC_close_parens[0] is the end\n             * of the regex, it *can* move. */\n            if ( paren && RExC_open_parens[paren] >= operand ) {\n                /*DEBUG_PARSE_FMT(\"open\",\" - %d\", size);*/\n                RExC_open_parens[paren] += size;\n            } else {\n                /*DEBUG_PARSE_FMT(\"open\",\" - %s\",\"ok\");*/\n            }\n            if ( RExC_close_parens[paren] >= operand ) {\n                /*DEBUG_PARSE_FMT(\"close\",\" - %d\", size);*/\n                RExC_close_parens[paren] += size;\n            } else {\n                /*DEBUG_PARSE_FMT(\"close\",\" - %s\",\"ok\");*/\n            }\n        }\n    }\n    if (RExC_end_op)\n        RExC_end_op += size;\n\n    while (src > REGNODE_p(operand)) {\n\tStructCopy(--src, --dst, regnode);\n#ifdef RE_TRACK_PATTERN_OFFSETS\n        if (RExC_offsets) {     /* MJD 20010112 */\n\t    MJD_OFFSET_DEBUG(\n                 (\"%s(%d): (op %s) %s copy %\" UVuf \" -> %\" UVuf \" (max %\" UVuf \").\\n\",\n                  \"reginsert\",\n\t\t  __LINE__,\n\t\t  PL_reg_name[op],\n                  (UV)(REGNODE_OFFSET(dst)) > RExC_offsets[0]\n\t\t    ? \"Overwriting end of array!\\n\" : \"OK\",\n                  (UV)REGNODE_OFFSET(src),\n                  (UV)REGNODE_OFFSET(dst),\n                  (UV)RExC_offsets[0]));\n\t    Set_Node_Offset_To_R(REGNODE_OFFSET(dst), Node_Offset(src));\n\t    Set_Node_Length_To_R(REGNODE_OFFSET(dst), Node_Length(src));\n        }\n#endif\n    }\n\n    place = REGNODE_p(operand);\t/* Op node, where operand used to be. */\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    if (RExC_offsets) {         /* MJD */\n\tMJD_OFFSET_DEBUG(\n              (\"%s(%d): (op %s) %s %\" UVuf \" <- %\" UVuf \" (max %\" UVuf \").\\n\",\n              \"reginsert\",\n\t      __LINE__,\n\t      PL_reg_name[op],\n              (UV)REGNODE_OFFSET(place) > RExC_offsets[0]\n              ? \"Overwriting end of array!\\n\" : \"OK\",\n              (UV)REGNODE_OFFSET(place),\n              (UV)(RExC_parse - RExC_start),\n              (UV)RExC_offsets[0]));\n\tSet_Node_Offset(place, RExC_parse);\n\tSet_Node_Length(place, 1);\n    }\n#endif\n    src = NEXTOPER(place);\n    FLAGS(place) = 0;\n    FILL_NODE(operand, op);\n\n    /* Zero out any arguments in the new node */\n    Zero(src, offset, regnode);\n}\n\n/*\n- regtail - set the next-pointer at the end of a node chain of p to val.  If\n            that value won't fit in the space available, instead returns FALSE.\n            (Except asserts if we can't fit in the largest space the regex\n            engine is designed for.)\n- SEE ALSO: regtail_study\n*/\nSTATIC bool\nS_regtail(pTHX_ RExC_state_t * pRExC_state,\n                const regnode_offset p,\n                const regnode_offset val,\n                const U32 depth)\n{\n    regnode_offset scan;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGTAIL;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    /* Find last node. */\n    scan = (regnode_offset) p;\n    for (;;) {\n\tregnode * const temp = regnext(REGNODE_p(scan));\n        DEBUG_PARSE_r({\n            DEBUG_PARSE_MSG((scan==p ? \"tail\" : \"\"));\n            regprop(RExC_rx, RExC_mysv, REGNODE_p(scan), NULL, pRExC_state);\n            Perl_re_printf( aTHX_  \"~ %s (%d) %s %s\\n\",\n                SvPV_nolen_const(RExC_mysv), scan,\n                    (temp == NULL ? \"->\" : \"\"),\n                    (temp == NULL ? PL_reg_name[OP(REGNODE_p(val))] : \"\")\n            );\n        });\n        if (temp == NULL)\n            break;\n        scan = REGNODE_OFFSET(temp);\n    }\n\n    if (reg_off_by_arg[OP(REGNODE_p(scan))]) {\n        assert((UV) (val - scan) <= U32_MAX);\n        ARG_SET(REGNODE_p(scan), val - scan);\n    }\n    else {\n        if (val - scan > U16_MAX) {\n            /* Populate this with something that won't loop and will likely\n             * lead to a crash if the caller ignores the failure return, and\n             * execution continues */\n            NEXT_OFF(REGNODE_p(scan)) = U16_MAX;\n            return FALSE;\n        }\n        NEXT_OFF(REGNODE_p(scan)) = val - scan;\n    }\n\n    return TRUE;\n}\n\n#ifdef DEBUGGING\n/*\n- regtail_study - set the next-pointer at the end of a node chain of p to val.\n- Look for optimizable sequences at the same time.\n- currently only looks for EXACT chains.\n\nThis is experimental code. The idea is to use this routine to perform\nin place optimizations on branches and groups as they are constructed,\nwith the long term intention of removing optimization from study_chunk so\nthat it is purely analytical.\n\nCurrently only used when in DEBUG mode. The macro REGTAIL_STUDY() is used\nto control which is which.\n\nThis used to return a value that was ignored.  It was a problem that it is\n#ifdef'd to be another function that didn't return a value.  khw has changed it\nso both currently return a pass/fail return.\n\n*/\n/* TODO: All four parms should be const */\n\nSTATIC bool\nS_regtail_study(pTHX_ RExC_state_t *pRExC_state, regnode_offset p,\n                      const regnode_offset val, U32 depth)\n{\n    regnode_offset scan;\n    U8 exact = PSEUDO;\n#ifdef EXPERIMENTAL_INPLACESCAN\n    I32 min = 0;\n#endif\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGTAIL_STUDY;\n\n\n    /* Find last node. */\n\n    scan = p;\n    for (;;) {\n        regnode * const temp = regnext(REGNODE_p(scan));\n#ifdef EXPERIMENTAL_INPLACESCAN\n        if (PL_regkind[OP(REGNODE_p(scan))] == EXACT) {\n\t    bool unfolded_multi_char;\t/* Unexamined in this routine */\n            if (join_exact(pRExC_state, scan, &min,\n                           &unfolded_multi_char, 1, REGNODE_p(val), depth+1))\n                return TRUE; /* Was return EXACT */\n\t}\n#endif\n        if ( exact ) {\n            switch (OP(REGNODE_p(scan))) {\n                case EXACT:\n                case EXACT_ONLY8:\n                case EXACTL:\n                case EXACTF:\n                case EXACTFU_S_EDGE:\n                case EXACTFAA_NO_TRIE:\n                case EXACTFAA:\n                case EXACTFU:\n                case EXACTFU_ONLY8:\n                case EXACTFLU8:\n                case EXACTFUP:\n                case EXACTFL:\n                        if( exact == PSEUDO )\n                            exact= OP(REGNODE_p(scan));\n                        else if ( exact != OP(REGNODE_p(scan)) )\n                            exact= 0;\n                case NOTHING:\n                    break;\n                default:\n                    exact= 0;\n            }\n        }\n        DEBUG_PARSE_r({\n            DEBUG_PARSE_MSG((scan==p ? \"tsdy\" : \"\"));\n            regprop(RExC_rx, RExC_mysv, REGNODE_p(scan), NULL, pRExC_state);\n            Perl_re_printf( aTHX_  \"~ %s (%d) -> %s\\n\",\n                SvPV_nolen_const(RExC_mysv),\n                scan,\n                PL_reg_name[exact]);\n        });\n\tif (temp == NULL)\n\t    break;\n\tscan = REGNODE_OFFSET(temp);\n    }\n    DEBUG_PARSE_r({\n        DEBUG_PARSE_MSG(\"\");\n        regprop(RExC_rx, RExC_mysv, REGNODE_p(val), NULL, pRExC_state);\n        Perl_re_printf( aTHX_\n                      \"~ attach to %s (%\" IVdf \") offset to %\" IVdf \"\\n\",\n\t\t      SvPV_nolen_const(RExC_mysv),\n\t\t      (IV)val,\n\t\t      (IV)(val - scan)\n        );\n    });\n    if (reg_off_by_arg[OP(REGNODE_p(scan))]) {\n        assert((UV) (val - scan) <= U32_MAX);\n\tARG_SET(REGNODE_p(scan), val - scan);\n    }\n    else {\n        if (val - scan > U16_MAX) {\n            /* Populate this with something that won't loop and will likely\n             * lead to a crash if the caller ignores the failure return, and\n             * execution continues */\n            NEXT_OFF(REGNODE_p(scan)) = U16_MAX;\n            return FALSE;\n        }\n\tNEXT_OFF(REGNODE_p(scan)) = val - scan;\n    }\n\n    return TRUE; /* Was 'return exact' */\n}\n#endif\n\nSTATIC SV*\nS_get_ANYOFM_contents(pTHX_ const regnode * n) {\n\n    /* Returns an inversion list of all the code points matched by the\n     * ANYOFM/NANYOFM node 'n' */\n\n    SV * cp_list = _new_invlist(-1);\n    const U8 lowest = (U8) ARG(n);\n    unsigned int i;\n    U8 count = 0;\n    U8 needed = 1U << PL_bitcount[ (U8) ~ FLAGS(n)];\n\n    PERL_ARGS_ASSERT_GET_ANYOFM_CONTENTS;\n\n    /* Starting with the lowest code point, any code point that ANDed with the\n     * mask yields the lowest code point is in the set */\n    for (i = lowest; i <= 0xFF; i++) {\n        if ((i & FLAGS(n)) == ARG(n)) {\n            cp_list = add_cp_to_invlist(cp_list, i);\n            count++;\n\n            /* We know how many code points (a power of two) that are in the\n             * set.  No use looking once we've got that number */\n            if (count >= needed) break;\n        }\n    }\n\n    if (OP(n) == NANYOFM) {\n        _invlist_invert(cp_list);\n    }\n    return cp_list;\n}\n\n/*\n - regdump - dump a regexp onto Perl_debug_log in vaguely comprehensible form\n */\n#ifdef DEBUGGING\n\nstatic void\nS_regdump_intflags(pTHX_ const char *lead, const U32 flags)\n{\n    int bit;\n    int set=0;\n\n    ASSUME(REG_INTFLAGS_NAME_SIZE <= sizeof(flags)*8);\n\n    for (bit=0; bit<REG_INTFLAGS_NAME_SIZE; bit++) {\n        if (flags & (1<<bit)) {\n            if (!set++ && lead)\n                Perl_re_printf( aTHX_  \"%s\", lead);\n            Perl_re_printf( aTHX_  \"%s \", PL_reg_intflags_name[bit]);\n        }\n    }\n    if (lead)  {\n        if (set)\n            Perl_re_printf( aTHX_  \"\\n\");\n        else\n            Perl_re_printf( aTHX_  \"%s[none-set]\\n\", lead);\n    }\n}\n\nstatic void\nS_regdump_extflags(pTHX_ const char *lead, const U32 flags)\n{\n    int bit;\n    int set=0;\n    regex_charset cs;\n\n    ASSUME(REG_EXTFLAGS_NAME_SIZE <= sizeof(flags)*8);\n\n    for (bit=0; bit<REG_EXTFLAGS_NAME_SIZE; bit++) {\n        if (flags & (1<<bit)) {\n\t    if ((1<<bit) & RXf_PMf_CHARSET) {\t/* Output separately, below */\n\t\tcontinue;\n\t    }\n            if (!set++ && lead)\n                Perl_re_printf( aTHX_  \"%s\", lead);\n            Perl_re_printf( aTHX_  \"%s \", PL_reg_extflags_name[bit]);\n        }\n    }\n    if ((cs = get_regex_charset(flags)) != REGEX_DEPENDS_CHARSET) {\n            if (!set++ && lead) {\n                Perl_re_printf( aTHX_  \"%s\", lead);\n            }\n            switch (cs) {\n                case REGEX_UNICODE_CHARSET:\n                    Perl_re_printf( aTHX_  \"UNICODE\");\n                    break;\n                case REGEX_LOCALE_CHARSET:\n                    Perl_re_printf( aTHX_  \"LOCALE\");\n                    break;\n                case REGEX_ASCII_RESTRICTED_CHARSET:\n                    Perl_re_printf( aTHX_  \"ASCII-RESTRICTED\");\n                    break;\n                case REGEX_ASCII_MORE_RESTRICTED_CHARSET:\n                    Perl_re_printf( aTHX_  \"ASCII-MORE_RESTRICTED\");\n                    break;\n                default:\n                    Perl_re_printf( aTHX_  \"UNKNOWN CHARACTER SET\");\n                    break;\n            }\n    }\n    if (lead)  {\n        if (set)\n            Perl_re_printf( aTHX_  \"\\n\");\n        else\n            Perl_re_printf( aTHX_  \"%s[none-set]\\n\", lead);\n    }\n}\n#endif\n\nvoid\nPerl_regdump(pTHX_ const regexp *r)\n{\n#ifdef DEBUGGING\n    int i;\n    SV * const sv = sv_newmortal();\n    SV *dsv= sv_newmortal();\n    RXi_GET_DECL(r, ri);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGDUMP;\n\n    (void)dumpuntil(r, ri->program, ri->program + 1, NULL, NULL, sv, 0, 0);\n\n    /* Header fields of interest. */\n    for (i = 0; i < 2; i++) {\n        if (r->substrs->data[i].substr) {\n            RE_PV_QUOTED_DECL(s, 0, dsv,\n                            SvPVX_const(r->substrs->data[i].substr),\n                            RE_SV_DUMPLEN(r->substrs->data[i].substr),\n                            PL_dump_re_max_len);\n            Perl_re_printf( aTHX_\n                          \"%s %s%s at %\" IVdf \"..%\" UVuf \" \",\n                          i ? \"floating\" : \"anchored\",\n                          s,\n                          RE_SV_TAIL(r->substrs->data[i].substr),\n                          (IV)r->substrs->data[i].min_offset,\n                          (UV)r->substrs->data[i].max_offset);\n        }\n        else if (r->substrs->data[i].utf8_substr) {\n            RE_PV_QUOTED_DECL(s, 1, dsv,\n                            SvPVX_const(r->substrs->data[i].utf8_substr),\n                            RE_SV_DUMPLEN(r->substrs->data[i].utf8_substr),\n                            30);\n            Perl_re_printf( aTHX_\n                          \"%s utf8 %s%s at %\" IVdf \"..%\" UVuf \" \",\n                          i ? \"floating\" : \"anchored\",\n                          s,\n                          RE_SV_TAIL(r->substrs->data[i].utf8_substr),\n                          (IV)r->substrs->data[i].min_offset,\n                          (UV)r->substrs->data[i].max_offset);\n        }\n    }\n\n    if (r->check_substr || r->check_utf8)\n        Perl_re_printf( aTHX_\n\t\t      (const char *)\n\t\t      (   r->check_substr == r->substrs->data[1].substr\n\t\t       && r->check_utf8   == r->substrs->data[1].utf8_substr\n\t\t       ? \"(checking floating\" : \"(checking anchored\"));\n    if (r->intflags & PREGf_NOSCAN)\n        Perl_re_printf( aTHX_  \" noscan\");\n    if (r->extflags & RXf_CHECK_ALL)\n        Perl_re_printf( aTHX_  \" isall\");\n    if (r->check_substr || r->check_utf8)\n        Perl_re_printf( aTHX_  \") \");\n\n    if (ri->regstclass) {\n        regprop(r, sv, ri->regstclass, NULL, NULL);\n        Perl_re_printf( aTHX_  \"stclass %s \", SvPVX_const(sv));\n    }\n    if (r->intflags & PREGf_ANCH) {\n        Perl_re_printf( aTHX_  \"anchored\");\n        if (r->intflags & PREGf_ANCH_MBOL)\n            Perl_re_printf( aTHX_  \"(MBOL)\");\n        if (r->intflags & PREGf_ANCH_SBOL)\n            Perl_re_printf( aTHX_  \"(SBOL)\");\n        if (r->intflags & PREGf_ANCH_GPOS)\n            Perl_re_printf( aTHX_  \"(GPOS)\");\n        Perl_re_printf( aTHX_ \" \");\n    }\n    if (r->intflags & PREGf_GPOS_SEEN)\n        Perl_re_printf( aTHX_  \"GPOS:%\" UVuf \" \", (UV)r->gofs);\n    if (r->intflags & PREGf_SKIP)\n        Perl_re_printf( aTHX_  \"plus \");\n    if (r->intflags & PREGf_IMPLICIT)\n        Perl_re_printf( aTHX_  \"implicit \");\n    Perl_re_printf( aTHX_  \"minlen %\" IVdf \" \", (IV)r->minlen);\n    if (r->extflags & RXf_EVAL_SEEN)\n        Perl_re_printf( aTHX_  \"with eval \");\n    Perl_re_printf( aTHX_  \"\\n\");\n    DEBUG_FLAGS_r({\n        regdump_extflags(\"r->extflags: \", r->extflags);\n        regdump_intflags(\"r->intflags: \", r->intflags);\n    });\n#else\n    PERL_ARGS_ASSERT_REGDUMP;\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(r);\n#endif\t/* DEBUGGING */\n}\n\n/* Should be synchronized with ANYOF_ #defines in regcomp.h */\n#ifdef DEBUGGING\n\n#  if   _CC_WORDCHAR != 0 || _CC_DIGIT != 1        || _CC_ALPHA != 2    \\\n     || _CC_LOWER != 3    || _CC_UPPER != 4        || _CC_PUNCT != 5    \\\n     || _CC_PRINT != 6    || _CC_ALPHANUMERIC != 7 || _CC_GRAPH != 8    \\\n     || _CC_CASED != 9    || _CC_SPACE != 10       || _CC_BLANK != 11   \\\n     || _CC_XDIGIT != 12  || _CC_CNTRL != 13       || _CC_ASCII != 14   \\\n     || _CC_VERTSPACE != 15\n#   error Need to adjust order of anyofs[]\n#  endif\nstatic const char * const anyofs[] = {\n    \"\\\\w\",\n    \"\\\\W\",\n    \"\\\\d\",\n    \"\\\\D\",\n    \"[:alpha:]\",\n    \"[:^alpha:]\",\n    \"[:lower:]\",\n    \"[:^lower:]\",\n    \"[:upper:]\",\n    \"[:^upper:]\",\n    \"[:punct:]\",\n    \"[:^punct:]\",\n    \"[:print:]\",\n    \"[:^print:]\",\n    \"[:alnum:]\",\n    \"[:^alnum:]\",\n    \"[:graph:]\",\n    \"[:^graph:]\",\n    \"[:cased:]\",\n    \"[:^cased:]\",\n    \"\\\\s\",\n    \"\\\\S\",\n    \"[:blank:]\",\n    \"[:^blank:]\",\n    \"[:xdigit:]\",\n    \"[:^xdigit:]\",\n    \"[:cntrl:]\",\n    \"[:^cntrl:]\",\n    \"[:ascii:]\",\n    \"[:^ascii:]\",\n    \"\\\\v\",\n    \"\\\\V\"\n};\n#endif\n\n/*\n- regprop - printable representation of opcode, with run time support\n*/\n\nvoid\nPerl_regprop(pTHX_ const regexp *prog, SV *sv, const regnode *o, const regmatch_info *reginfo, const RExC_state_t *pRExC_state)\n{\n#ifdef DEBUGGING\n    dVAR;\n    int k;\n    RXi_GET_DECL(prog, progi);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGPROP;\n\n    SvPVCLEAR(sv);\n\n    if (OP(o) > REGNODE_MAX)\t\t/* regnode.type is unsigned */\n\t/* It would be nice to FAIL() here, but this may be called from\n\t   regexec.c, and it would be hard to supply pRExC_state. */\n\tPerl_croak(aTHX_ \"Corrupted regexp opcode %d > %d\",\n                                              (int)OP(o), (int)REGNODE_MAX);\n    sv_catpv(sv, PL_reg_name[OP(o)]); /* Take off const! */\n\n    k = PL_regkind[OP(o)];\n\n    if (k == EXACT) {\n\tsv_catpvs(sv, \" \");\n\t/* Using is_utf8_string() (via PERL_PV_UNI_DETECT)\n\t * is a crude hack but it may be the best for now since\n\t * we have no flag \"this EXACTish node was UTF-8\"\n\t * --jhi */\n\tpv_pretty(sv, STRING(o), STR_LEN(o), PL_dump_re_max_len,\n                  PL_colors[0], PL_colors[1],\n\t\t  PERL_PV_ESCAPE_UNI_DETECT |\n\t\t  PERL_PV_ESCAPE_NONASCII   |\n\t\t  PERL_PV_PRETTY_ELLIPSES   |\n\t\t  PERL_PV_PRETTY_LTGT       |\n\t\t  PERL_PV_PRETTY_NOCLEAR\n\t\t  );\n    } else if (k == TRIE) {\n\t/* print the details of the trie in dumpuntil instead, as\n\t * progi->data isn't available here */\n        const char op = OP(o);\n        const U32 n = ARG(o);\n        const reg_ac_data * const ac = IS_TRIE_AC(op) ?\n               (reg_ac_data *)progi->data->data[n] :\n               NULL;\n        const reg_trie_data * const trie\n\t    = (reg_trie_data*)progi->data->data[!IS_TRIE_AC(op) ? n : ac->trie];\n\n        Perl_sv_catpvf(aTHX_ sv, \"-%s\", PL_reg_name[o->flags]);\n        DEBUG_TRIE_COMPILE_r({\n          if (trie->jump)\n            sv_catpvs(sv, \"(JUMP)\");\n          Perl_sv_catpvf(aTHX_ sv,\n            \"<S:%\" UVuf \"/%\" IVdf \" W:%\" UVuf \" L:%\" UVuf \"/%\" UVuf \" C:%\" UVuf \"/%\" UVuf \">\",\n            (UV)trie->startstate,\n            (IV)trie->statecount-1, /* -1 because of the unused 0 element */\n            (UV)trie->wordcount,\n            (UV)trie->minlen,\n            (UV)trie->maxlen,\n            (UV)TRIE_CHARCOUNT(trie),\n            (UV)trie->uniquecharcount\n          );\n        });\n        if ( IS_ANYOF_TRIE(op) || trie->bitmap ) {\n            sv_catpvs(sv, \"[\");\n            (void) put_charclass_bitmap_innards(sv,\n                                                ((IS_ANYOF_TRIE(op))\n                                                 ? ANYOF_BITMAP(o)\n                                                 : TRIE_BITMAP(trie)),\n                                                NULL,\n                                                NULL,\n                                                NULL,\n                                                FALSE\n                                               );\n            sv_catpvs(sv, \"]\");\n        }\n    } else if (k == CURLY) {\n        U32 lo = ARG1(o), hi = ARG2(o);\n\tif (OP(o) == CURLYM || OP(o) == CURLYN || OP(o) == CURLYX)\n\t    Perl_sv_catpvf(aTHX_ sv, \"[%d]\", o->flags); /* Parenth number */\n        Perl_sv_catpvf(aTHX_ sv, \"{%u,\", (unsigned) lo);\n        if (hi == REG_INFTY)\n            sv_catpvs(sv, \"INFTY\");\n        else\n            Perl_sv_catpvf(aTHX_ sv, \"%u\", (unsigned) hi);\n        sv_catpvs(sv, \"}\");\n    }\n    else if (k == WHILEM && o->flags)\t\t\t/* Ordinal/of */\n\tPerl_sv_catpvf(aTHX_ sv, \"[%d/%d]\", o->flags & 0xf, o->flags>>4);\n    else if (k == REF || k == OPEN || k == CLOSE\n             || k == GROUPP || OP(o)==ACCEPT)\n    {\n        AV *name_list= NULL;\n        U32 parno= OP(o) == ACCEPT ? (U32)ARG2L(o) : ARG(o);\n        Perl_sv_catpvf(aTHX_ sv, \"%\" UVuf, (UV)parno);        /* Parenth number */\n\tif ( RXp_PAREN_NAMES(prog) ) {\n            name_list= MUTABLE_AV(progi->data->data[progi->name_list_idx]);\n        } else if ( pRExC_state ) {\n            name_list= RExC_paren_name_list;\n        }\n        if (name_list) {\n            if ( k != REF || (OP(o) < NREF)) {\n                SV **name= av_fetch(name_list, parno, 0 );\n\t        if (name)\n\t            Perl_sv_catpvf(aTHX_ sv, \" '%\" SVf \"'\", SVfARG(*name));\n            }\n            else {\n                SV *sv_dat= MUTABLE_SV(progi->data->data[ parno ]);\n                I32 *nums=(I32*)SvPVX(sv_dat);\n                SV **name= av_fetch(name_list, nums[0], 0 );\n                I32 n;\n                if (name) {\n                    for ( n=0; n<SvIVX(sv_dat); n++ ) {\n                        Perl_sv_catpvf(aTHX_ sv, \"%s%\" IVdf,\n\t\t\t   \t    (n ? \",\" : \"\"), (IV)nums[n]);\n                    }\n                    Perl_sv_catpvf(aTHX_ sv, \" '%\" SVf \"'\", SVfARG(*name));\n                }\n            }\n        }\n        if ( k == REF && reginfo) {\n            U32 n = ARG(o);  /* which paren pair */\n            I32 ln = prog->offs[n].start;\n            if (prog->lastparen < n || ln == -1 || prog->offs[n].end == -1)\n                Perl_sv_catpvf(aTHX_ sv, \": FAIL\");\n            else if (ln == prog->offs[n].end)\n                Perl_sv_catpvf(aTHX_ sv, \": ACCEPT - EMPTY STRING\");\n            else {\n                const char *s = reginfo->strbeg + ln;\n                Perl_sv_catpvf(aTHX_ sv, \": \");\n                Perl_pv_pretty( aTHX_ sv, s, prog->offs[n].end - prog->offs[n].start, 32, 0, 0,\n                    PERL_PV_ESCAPE_UNI_DETECT|PERL_PV_PRETTY_NOCLEAR|PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_QUOTE );\n            }\n        }\n    } else if (k == GOSUB) {\n        AV *name_list= NULL;\n        if ( RXp_PAREN_NAMES(prog) ) {\n            name_list= MUTABLE_AV(progi->data->data[progi->name_list_idx]);\n        } else if ( pRExC_state ) {\n            name_list= RExC_paren_name_list;\n        }\n\n        /* Paren and offset */\n        Perl_sv_catpvf(aTHX_ sv, \"%d[%+d:%d]\", (int)ARG(o),(int)ARG2L(o),\n                (int)((o + (int)ARG2L(o)) - progi->program) );\n        if (name_list) {\n            SV **name= av_fetch(name_list, ARG(o), 0 );\n            if (name)\n                Perl_sv_catpvf(aTHX_ sv, \" '%\" SVf \"'\", SVfARG(*name));\n        }\n    }\n    else if (k == LOGICAL)\n        /* 2: embedded, otherwise 1 */\n\tPerl_sv_catpvf(aTHX_ sv, \"[%d]\", o->flags);\n    else if (k == ANYOF) {\n\tconst U8 flags = (OP(o) == ANYOFH) ? 0 : ANYOF_FLAGS(o);\n        bool do_sep = FALSE;    /* Do we need to separate various components of\n                                   the output? */\n        /* Set if there is still an unresolved user-defined property */\n        SV *unresolved                = NULL;\n\n        /* Things that are ignored except when the runtime locale is UTF-8 */\n        SV *only_utf8_locale_invlist = NULL;\n\n        /* Code points that don't fit in the bitmap */\n        SV *nonbitmap_invlist = NULL;\n\n        /* And things that aren't in the bitmap, but are small enough to be */\n        SV* bitmap_range_not_in_bitmap = NULL;\n\n        const bool inverted = flags & ANYOF_INVERT;\n\n\tif (OP(o) == ANYOFL || OP(o) == ANYOFPOSIXL) {\n            if (ANYOFL_UTF8_LOCALE_REQD(flags)) {\n                sv_catpvs(sv, \"{utf8-locale-reqd}\");\n            }\n            if (flags & ANYOFL_FOLD) {\n                sv_catpvs(sv, \"{i}\");\n            }\n        }\n\n        /* If there is stuff outside the bitmap, get it */\n        if (ARG(o) != ANYOF_ONLY_HAS_BITMAP) {\n            (void) _get_regclass_nonbitmap_data(prog, o, FALSE,\n                                                &unresolved,\n                                                &only_utf8_locale_invlist,\n                                                &nonbitmap_invlist);\n            /* The non-bitmap data may contain stuff that could fit in the\n             * bitmap.  This could come from a user-defined property being\n             * finally resolved when this call was done; or much more likely\n             * because there are matches that require UTF-8 to be valid, and so\n             * aren't in the bitmap.  This is teased apart later */\n            _invlist_intersection(nonbitmap_invlist,\n                                  PL_InBitmap,\n                                  &bitmap_range_not_in_bitmap);\n            /* Leave just the things that don't fit into the bitmap */\n            _invlist_subtract(nonbitmap_invlist,\n                              PL_InBitmap,\n                              &nonbitmap_invlist);\n        }\n\n        /* Obey this flag to add all above-the-bitmap code points */\n        if (flags & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {\n            nonbitmap_invlist = _add_range_to_invlist(nonbitmap_invlist,\n                                                      NUM_ANYOF_CODE_POINTS,\n                                                      UV_MAX);\n        }\n\n        /* Ready to start outputting.  First, the initial left bracket */\n\tPerl_sv_catpvf(aTHX_ sv, \"[%s\", PL_colors[0]);\n\n        if (OP(o) != ANYOFH) {\n            /* Then all the things that could fit in the bitmap */\n            do_sep = put_charclass_bitmap_innards(sv,\n                                                  ANYOF_BITMAP(o),\n                                                  bitmap_range_not_in_bitmap,\n                                                  only_utf8_locale_invlist,\n                                                  o,\n\n                                                  /* Can't try inverting for a\n                                                   * better display if there\n                                                   * are things that haven't\n                                                   * been resolved */\n                                                  unresolved != NULL);\n            SvREFCNT_dec(bitmap_range_not_in_bitmap);\n\n            /* If there are user-defined properties which haven't been defined\n             * yet, output them.  If the result is not to be inverted, it is\n             * clearest to output them in a separate [] from the bitmap range\n             * stuff.  If the result is to be complemented, we have to show\n             * everything in one [], as the inversion applies to the whole\n             * thing.  Use {braces} to separate them from anything in the\n             * bitmap and anything above the bitmap. */\n            if (unresolved) {\n                if (inverted) {\n                    if (! do_sep) { /* If didn't output anything in the bitmap\n                                     */\n                        sv_catpvs(sv, \"^\");\n                    }\n                    sv_catpvs(sv, \"{\");\n                }\n                else if (do_sep) {\n                    Perl_sv_catpvf(aTHX_ sv,\"%s][%s\", PL_colors[1],\n                                                      PL_colors[0]);\n                }\n                sv_catsv(sv, unresolved);\n                if (inverted) {\n                    sv_catpvs(sv, \"}\");\n                }\n                do_sep = ! inverted;\n            }\n        }\n\n        /* And, finally, add the above-the-bitmap stuff */\n        if (nonbitmap_invlist && _invlist_len(nonbitmap_invlist)) {\n            SV* contents;\n\n            /* See if truncation size is overridden */\n            const STRLEN dump_len = (PL_dump_re_max_len > 256)\n                                    ? PL_dump_re_max_len\n                                    : 256;\n\n            /* This is output in a separate [] */\n            if (do_sep) {\n                Perl_sv_catpvf(aTHX_ sv,\"%s][%s\", PL_colors[1], PL_colors[0]);\n            }\n\n            /* And, for easy of understanding, it is shown in the\n             * uncomplemented form if possible.  The one exception being if\n             * there are unresolved items, where the inversion has to be\n             * delayed until runtime */\n            if (inverted && ! unresolved) {\n                _invlist_invert(nonbitmap_invlist);\n                _invlist_subtract(nonbitmap_invlist, PL_InBitmap, &nonbitmap_invlist);\n            }\n\n            contents = invlist_contents(nonbitmap_invlist,\n                                        FALSE /* output suitable for catsv */\n                                       );\n\n            /* If the output is shorter than the permissible maximum, just do it. */\n            if (SvCUR(contents) <= dump_len) {\n                sv_catsv(sv, contents);\n            }\n            else {\n                const char * contents_string = SvPVX(contents);\n                STRLEN i = dump_len;\n\n                /* Otherwise, start at the permissible max and work back to the\n                 * first break possibility */\n                while (i > 0 && contents_string[i] != ' ') {\n                    i--;\n                }\n                if (i == 0) {       /* Fail-safe.  Use the max if we couldn't\n                                       find a legal break */\n                    i = dump_len;\n                }\n\n                sv_catpvn(sv, contents_string, i);\n                sv_catpvs(sv, \"...\");\n            }\n\n            SvREFCNT_dec_NN(contents);\n            SvREFCNT_dec_NN(nonbitmap_invlist);\n        }\n\n        /* And finally the matching, closing ']' */\n\tPerl_sv_catpvf(aTHX_ sv, \"%s]\", PL_colors[1]);\n\n        if (OP(o) == ANYOFH && FLAGS(o) != 0) {\n            Perl_sv_catpvf(aTHX_ sv, \" (First UTF-8 byte=\\\\x%02x)\", FLAGS(o));\n        }\n\n\n        SvREFCNT_dec(unresolved);\n    }\n    else if (k == ANYOFM) {\n        SV * cp_list = get_ANYOFM_contents(o);\n\n\tPerl_sv_catpvf(aTHX_ sv, \"[%s\", PL_colors[0]);\n        if (OP(o) == NANYOFM) {\n            _invlist_invert(cp_list);\n        }\n\n        put_charclass_bitmap_innards(sv, NULL, cp_list, NULL, NULL, TRUE);\n\tPerl_sv_catpvf(aTHX_ sv, \"%s]\", PL_colors[1]);\n\n        SvREFCNT_dec(cp_list);\n    }\n    else if (k == POSIXD || k == NPOSIXD) {\n        U8 index = FLAGS(o) * 2;\n        if (index < C_ARRAY_LENGTH(anyofs)) {\n            if (*anyofs[index] != '[')  {\n                sv_catpvs(sv, \"[\");\n            }\n            sv_catpv(sv, anyofs[index]);\n            if (*anyofs[index] != '[')  {\n                sv_catpvs(sv, \"]\");\n            }\n        }\n        else {\n            Perl_sv_catpvf(aTHX_ sv, \"[illegal type=%d])\", index);\n        }\n    }\n    else if (k == BOUND || k == NBOUND) {\n        /* Must be synced with order of 'bound_type' in regcomp.h */\n        const char * const bounds[] = {\n            \"\",      /* Traditional */\n            \"{gcb}\",\n            \"{lb}\",\n            \"{sb}\",\n            \"{wb}\"\n        };\n        assert(FLAGS(o) < C_ARRAY_LENGTH(bounds));\n        sv_catpv(sv, bounds[FLAGS(o)]);\n    }\n    else if (k == BRANCHJ && (OP(o) == UNLESSM || OP(o) == IFMATCH)) {\n\tPerl_sv_catpvf(aTHX_ sv, \"[%d\", -(o->flags));\n        if (o->next_off) {\n            Perl_sv_catpvf(aTHX_ sv, \"..-%d\", o->flags - o->next_off);\n        }\n\tPerl_sv_catpvf(aTHX_ sv, \"]\");\n    }\n    else if (OP(o) == SBOL)\n        Perl_sv_catpvf(aTHX_ sv, \" /%s/\", o->flags ? \"\\\\A\" : \"^\");\n\n    /* add on the verb argument if there is one */\n    if ( ( k == VERB || OP(o) == ACCEPT || OP(o) == OPFAIL ) && o->flags) {\n        if ( ARG(o) )\n            Perl_sv_catpvf(aTHX_ sv, \":%\" SVf,\n                       SVfARG((MUTABLE_SV(progi->data->data[ ARG( o ) ]))));\n        else\n            sv_catpvs(sv, \":NULL\");\n    }\n#else\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(sv);\n    PERL_UNUSED_ARG(o);\n    PERL_UNUSED_ARG(prog);\n    PERL_UNUSED_ARG(reginfo);\n    PERL_UNUSED_ARG(pRExC_state);\n#endif\t/* DEBUGGING */\n}\n\n\n\nSV *\nPerl_re_intuit_string(pTHX_ REGEXP * const r)\n{\t\t\t\t/* Assume that RE_INTUIT is set */\n    struct regexp *const prog = ReANY(r);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_RE_INTUIT_STRING;\n    PERL_UNUSED_CONTEXT;\n\n    DEBUG_COMPILE_r(\n\t{\n\t    const char * const s = SvPV_nolen_const(RX_UTF8(r)\n\t\t      ? prog->check_utf8 : prog->check_substr);\n\n\t    if (!PL_colorset) reginitcolors();\n            Perl_re_printf( aTHX_\n\t\t      \"%sUsing REx %ssubstr:%s \\\"%s%.60s%s%s\\\"\\n\",\n\t\t      PL_colors[4],\n\t\t      RX_UTF8(r) ? \"utf8 \" : \"\",\n\t\t      PL_colors[5], PL_colors[0],\n\t\t      s,\n\t\t      PL_colors[1],\n\t\t      (strlen(s) > PL_dump_re_max_len ? \"...\" : \"\"));\n\t} );\n\n    /* use UTF8 check substring if regexp pattern itself is in UTF8 */\n    return RX_UTF8(r) ? prog->check_utf8 : prog->check_substr;\n}\n\n/*\n   pregfree()\n\n   handles refcounting and freeing the perl core regexp structure. When\n   it is necessary to actually free the structure the first thing it\n   does is call the 'free' method of the regexp_engine associated to\n   the regexp, allowing the handling of the void *pprivate; member\n   first. (This routine is not overridable by extensions, which is why\n   the extensions free is called first.)\n\n   See regdupe and regdupe_internal if you change anything here.\n*/\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_pregfree(pTHX_ REGEXP *r)\n{\n    SvREFCNT_dec(r);\n}\n\nvoid\nPerl_pregfree2(pTHX_ REGEXP *rx)\n{\n    struct regexp *const r = ReANY(rx);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_PREGFREE2;\n\n    if (! r)\n        return;\n\n    if (r->mother_re) {\n        ReREFCNT_dec(r->mother_re);\n    } else {\n        CALLREGFREE_PVT(rx); /* free the private data */\n        SvREFCNT_dec(RXp_PAREN_NAMES(r));\n    }\n    if (r->substrs) {\n        int i;\n        for (i = 0; i < 2; i++) {\n            SvREFCNT_dec(r->substrs->data[i].substr);\n            SvREFCNT_dec(r->substrs->data[i].utf8_substr);\n        }\n\tSafefree(r->substrs);\n    }\n    RX_MATCH_COPY_FREE(rx);\n#ifdef PERL_ANY_COW\n    SvREFCNT_dec(r->saved_copy);\n#endif\n    Safefree(r->offs);\n    SvREFCNT_dec(r->qr_anoncv);\n    if (r->recurse_locinput)\n        Safefree(r->recurse_locinput);\n}\n\n\n/*  reg_temp_copy()\n\n    Copy ssv to dsv, both of which should of type SVt_REGEXP or SVt_PVLV,\n    except that dsv will be created if NULL.\n\n    This function is used in two main ways. First to implement\n        $r = qr/....; $s = $$r;\n\n    Secondly, it is used as a hacky workaround to the structural issue of\n    match results\n    being stored in the regexp structure which is in turn stored in\n    PL_curpm/PL_reg_curpm. The problem is that due to qr// the pattern\n    could be PL_curpm in multiple contexts, and could require multiple\n    result sets being associated with the pattern simultaneously, such\n    as when doing a recursive match with (??{$qr})\n\n    The solution is to make a lightweight copy of the regexp structure\n    when a qr// is returned from the code executed by (??{$qr}) this\n    lightweight copy doesn't actually own any of its data except for\n    the starp/end and the actual regexp structure itself.\n\n*/\n\n\nREGEXP *\nPerl_reg_temp_copy(pTHX_ REGEXP *dsv, REGEXP *ssv)\n{\n    struct regexp *drx;\n    struct regexp *const srx = ReANY(ssv);\n    const bool islv = dsv && SvTYPE(dsv) == SVt_PVLV;\n\n    PERL_ARGS_ASSERT_REG_TEMP_COPY;\n\n    if (!dsv)\n\tdsv = (REGEXP*) newSV_type(SVt_REGEXP);\n    else {\n        assert(SvTYPE(dsv) == SVt_REGEXP || (SvTYPE(dsv) == SVt_PVLV));\n\n        /* our only valid caller, sv_setsv_flags(), should have done\n         * a SV_CHECK_THINKFIRST_COW_DROP() by now */\n        assert(!SvOOK(dsv));\n        assert(!SvIsCOW(dsv));\n        assert(!SvROK(dsv));\n\n        if (SvPVX_const(dsv)) {\n            if (SvLEN(dsv))\n                Safefree(SvPVX(dsv));\n            SvPVX(dsv) = NULL;\n        }\n        SvLEN_set(dsv, 0);\n        SvCUR_set(dsv, 0);\n\tSvOK_off((SV *)dsv);\n\n\tif (islv) {\n\t    /* For PVLVs, the head (sv_any) points to an XPVLV, while\n             * the LV's xpvlenu_rx will point to a regexp body, which\n             * we allocate here */\n\t    REGEXP *temp = (REGEXP *)newSV_type(SVt_REGEXP);\n\t    assert(!SvPVX(dsv));\n            ((XPV*)SvANY(dsv))->xpv_len_u.xpvlenu_rx = temp->sv_any;\n\t    temp->sv_any = NULL;\n\t    SvFLAGS(temp) = (SvFLAGS(temp) & ~SVTYPEMASK) | SVt_NULL;\n\t    SvREFCNT_dec_NN(temp);\n\t    /* SvCUR still resides in the xpvlv struct, so the regexp copy-\n\t       ing below will not set it. */\n\t    SvCUR_set(dsv, SvCUR(ssv));\n\t}\n    }\n    /* This ensures that SvTHINKFIRST(sv) is true, and hence that\n       sv_force_normal(sv) is called.  */\n    SvFAKE_on(dsv);\n    drx = ReANY(dsv);\n\n    SvFLAGS(dsv) |= SvFLAGS(ssv) & (SVf_POK|SVp_POK|SVf_UTF8);\n    SvPV_set(dsv, RX_WRAPPED(ssv));\n    /* We share the same string buffer as the original regexp, on which we\n       hold a reference count, incremented when mother_re is set below.\n       The string pointer is copied here, being part of the regexp struct.\n     */\n    memcpy(&(drx->xpv_cur), &(srx->xpv_cur),\n\t   sizeof(regexp) - STRUCT_OFFSET(regexp, xpv_cur));\n    if (!islv)\n        SvLEN_set(dsv, 0);\n    if (srx->offs) {\n        const I32 npar = srx->nparens+1;\n        Newx(drx->offs, npar, regexp_paren_pair);\n        Copy(srx->offs, drx->offs, npar, regexp_paren_pair);\n    }\n    if (srx->substrs) {\n        int i;\n        Newx(drx->substrs, 1, struct reg_substr_data);\n\tStructCopy(srx->substrs, drx->substrs, struct reg_substr_data);\n\n        for (i = 0; i < 2; i++) {\n            SvREFCNT_inc_void(drx->substrs->data[i].substr);\n            SvREFCNT_inc_void(drx->substrs->data[i].utf8_substr);\n        }\n\n\t/* check_substr and check_utf8, if non-NULL, point to either their\n\t   anchored or float namesakes, and don't hold a second reference.  */\n    }\n    RX_MATCH_COPIED_off(dsv);\n#ifdef PERL_ANY_COW\n    drx->saved_copy = NULL;\n#endif\n    drx->mother_re = ReREFCNT_inc(srx->mother_re ? srx->mother_re : ssv);\n    SvREFCNT_inc_void(drx->qr_anoncv);\n    if (srx->recurse_locinput)\n        Newx(drx->recurse_locinput, srx->nparens + 1, char *);\n\n    return dsv;\n}\n#endif\n\n\n/* regfree_internal()\n\n   Free the private data in a regexp. This is overloadable by\n   extensions. Perl takes care of the regexp structure in pregfree(),\n   this covers the *pprivate pointer which technically perl doesn't\n   know about, however of course we have to handle the\n   regexp_internal structure when no extension is in use.\n\n   Note this is called before freeing anything in the regexp\n   structure.\n */\n\nvoid\nPerl_regfree_internal(pTHX_ REGEXP * const rx)\n{\n    struct regexp *const r = ReANY(rx);\n    RXi_GET_DECL(r, ri);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGFREE_INTERNAL;\n\n    if (! ri) {\n        return;\n    }\n\n    DEBUG_COMPILE_r({\n\tif (!PL_colorset)\n\t    reginitcolors();\n\t{\n\t    SV *dsv= sv_newmortal();\n            RE_PV_QUOTED_DECL(s, RX_UTF8(rx),\n                dsv, RX_PRECOMP(rx), RX_PRELEN(rx), PL_dump_re_max_len);\n            Perl_re_printf( aTHX_ \"%sFreeing REx:%s %s\\n\",\n                PL_colors[4], PL_colors[5], s);\n        }\n    });\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    if (ri->u.offsets)\n        Safefree(ri->u.offsets);             /* 20010421 MJD */\n#endif\n    if (ri->code_blocks)\n        S_free_codeblocks(aTHX_ ri->code_blocks);\n\n    if (ri->data) {\n\tint n = ri->data->count;\n\n\twhile (--n >= 0) {\n          /* If you add a ->what type here, update the comment in regcomp.h */\n\t    switch (ri->data->what[n]) {\n\t    case 'a':\n\t    case 'r':\n\t    case 's':\n\t    case 'S':\n\t    case 'u':\n\t\tSvREFCNT_dec(MUTABLE_SV(ri->data->data[n]));\n\t\tbreak;\n\t    case 'f':\n\t\tSafefree(ri->data->data[n]);\n\t\tbreak;\n\t    case 'l':\n\t    case 'L':\n\t        break;\n            case 'T':\n                { /* Aho Corasick add-on structure for a trie node.\n                     Used in stclass optimization only */\n                    U32 refcount;\n                    reg_ac_data *aho=(reg_ac_data*)ri->data->data[n];\n#ifdef USE_ITHREADS\n                    dVAR;\n#endif\n                    OP_REFCNT_LOCK;\n                    refcount = --aho->refcount;\n                    OP_REFCNT_UNLOCK;\n                    if ( !refcount ) {\n                        PerlMemShared_free(aho->states);\n                        PerlMemShared_free(aho->fail);\n\t\t\t /* do this last!!!! */\n                        PerlMemShared_free(ri->data->data[n]);\n                        /* we should only ever get called once, so\n                         * assert as much, and also guard the free\n                         * which /might/ happen twice. At the least\n                         * it will make code anlyzers happy and it\n                         * doesn't cost much. - Yves */\n                        assert(ri->regstclass);\n                        if (ri->regstclass) {\n                            PerlMemShared_free(ri->regstclass);\n                            ri->regstclass = 0;\n                        }\n                    }\n                }\n                break;\n\t    case 't':\n\t        {\n\t            /* trie structure. */\n\t            U32 refcount;\n\t            reg_trie_data *trie=(reg_trie_data*)ri->data->data[n];\n#ifdef USE_ITHREADS\n                    dVAR;\n#endif\n                    OP_REFCNT_LOCK;\n                    refcount = --trie->refcount;\n                    OP_REFCNT_UNLOCK;\n                    if ( !refcount ) {\n                        PerlMemShared_free(trie->charmap);\n                        PerlMemShared_free(trie->states);\n                        PerlMemShared_free(trie->trans);\n                        if (trie->bitmap)\n                            PerlMemShared_free(trie->bitmap);\n                        if (trie->jump)\n                            PerlMemShared_free(trie->jump);\n\t\t\tPerlMemShared_free(trie->wordinfo);\n                        /* do this last!!!! */\n                        PerlMemShared_free(ri->data->data[n]);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    default:\n\t\tPerl_croak(aTHX_ \"panic: regfree data code '%c'\",\n                                                    ri->data->what[n]);\n\t    }\n\t}\n\tSafefree(ri->data->what);\n\tSafefree(ri->data);\n    }\n\n    Safefree(ri);\n}\n\n#define av_dup_inc(s, t)\tMUTABLE_AV(sv_dup_inc((const SV *)s, t))\n#define hv_dup_inc(s, t)\tMUTABLE_HV(sv_dup_inc((const SV *)s, t))\n#define SAVEPVN(p, n)\t((p) ? savepvn(p, n) : NULL)\n\n/*\n   re_dup_guts - duplicate a regexp.\n\n   This routine is expected to clone a given regexp structure. It is only\n   compiled under USE_ITHREADS.\n\n   After all of the core data stored in struct regexp is duplicated\n   the regexp_engine.dupe method is used to copy any private data\n   stored in the *pprivate pointer. This allows extensions to handle\n   any duplication it needs to do.\n\n   See pregfree() and regfree_internal() if you change anything here.\n*/\n#if defined(USE_ITHREADS)\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_re_dup_guts(pTHX_ const REGEXP *sstr, REGEXP *dstr, CLONE_PARAMS *param)\n{\n    dVAR;\n    I32 npar;\n    const struct regexp *r = ReANY(sstr);\n    struct regexp *ret = ReANY(dstr);\n\n    PERL_ARGS_ASSERT_RE_DUP_GUTS;\n\n    npar = r->nparens+1;\n    Newx(ret->offs, npar, regexp_paren_pair);\n    Copy(r->offs, ret->offs, npar, regexp_paren_pair);\n\n    if (ret->substrs) {\n\t/* Do it this way to avoid reading from *r after the StructCopy().\n\t   That way, if any of the sv_dup_inc()s dislodge *r from the L1\n\t   cache, it doesn't matter.  */\n        int i;\n\tconst bool anchored = r->check_substr\n\t    ? r->check_substr == r->substrs->data[0].substr\n\t    : r->check_utf8   == r->substrs->data[0].utf8_substr;\n        Newx(ret->substrs, 1, struct reg_substr_data);\n\tStructCopy(r->substrs, ret->substrs, struct reg_substr_data);\n\n        for (i = 0; i < 2; i++) {\n            ret->substrs->data[i].substr =\n                        sv_dup_inc(ret->substrs->data[i].substr, param);\n            ret->substrs->data[i].utf8_substr =\n                        sv_dup_inc(ret->substrs->data[i].utf8_substr, param);\n        }\n\n\t/* check_substr and check_utf8, if non-NULL, point to either their\n\t   anchored or float namesakes, and don't hold a second reference.  */\n\n\tif (ret->check_substr) {\n\t    if (anchored) {\n\t\tassert(r->check_utf8 == r->substrs->data[0].utf8_substr);\n\n\t\tret->check_substr = ret->substrs->data[0].substr;\n\t\tret->check_utf8   = ret->substrs->data[0].utf8_substr;\n\t    } else {\n\t\tassert(r->check_substr == r->substrs->data[1].substr);\n\t\tassert(r->check_utf8   == r->substrs->data[1].utf8_substr);\n\n\t\tret->check_substr = ret->substrs->data[1].substr;\n\t\tret->check_utf8   = ret->substrs->data[1].utf8_substr;\n\t    }\n\t} else if (ret->check_utf8) {\n\t    if (anchored) {\n\t\tret->check_utf8 = ret->substrs->data[0].utf8_substr;\n\t    } else {\n\t\tret->check_utf8 = ret->substrs->data[1].utf8_substr;\n\t    }\n\t}\n    }\n\n    RXp_PAREN_NAMES(ret) = hv_dup_inc(RXp_PAREN_NAMES(ret), param);\n    ret->qr_anoncv = MUTABLE_CV(sv_dup_inc((const SV *)ret->qr_anoncv, param));\n    if (r->recurse_locinput)\n        Newx(ret->recurse_locinput, r->nparens + 1, char *);\n\n    if (ret->pprivate)\n\tRXi_SET(ret, CALLREGDUPE_PVT(dstr, param));\n\n    if (RX_MATCH_COPIED(dstr))\n\tret->subbeg  = SAVEPVN(ret->subbeg, ret->sublen);\n    else\n\tret->subbeg = NULL;\n#ifdef PERL_ANY_COW\n    ret->saved_copy = NULL;\n#endif\n\n    /* Whether mother_re be set or no, we need to copy the string.  We\n       cannot refrain from copying it when the storage points directly to\n       our mother regexp, because that's\n\t       1: a buffer in a different thread\n\t       2: something we no longer hold a reference on\n\t       so we need to copy it locally.  */\n    RX_WRAPPED(dstr) = SAVEPVN(RX_WRAPPED_const(sstr), SvCUR(sstr)+1);\n    /* set malloced length to a non-zero value so it will be freed\n     * (otherwise in combination with SVf_FAKE it looks like an alien\n     * buffer). It doesn't have to be the actual malloced size, since it\n     * should never be grown */\n    SvLEN_set(dstr, SvCUR(sstr)+1);\n    ret->mother_re   = NULL;\n}\n#endif /* PERL_IN_XSUB_RE */\n\n/*\n   regdupe_internal()\n\n   This is the internal complement to regdupe() which is used to copy\n   the structure pointed to by the *pprivate pointer in the regexp.\n   This is the core version of the extension overridable cloning hook.\n   The regexp structure being duplicated will be copied by perl prior\n   to this and will be provided as the regexp *r argument, however\n   with the /old/ structures pprivate pointer value. Thus this routine\n   may override any copying normally done by perl.\n\n   It returns a pointer to the new regexp_internal structure.\n*/\n\nvoid *\nPerl_regdupe_internal(pTHX_ REGEXP * const rx, CLONE_PARAMS *param)\n{\n    dVAR;\n    struct regexp *const r = ReANY(rx);\n    regexp_internal *reti;\n    int len;\n    RXi_GET_DECL(r, ri);\n\n    PERL_ARGS_ASSERT_REGDUPE_INTERNAL;\n\n    len = ProgLen(ri);\n\n    Newxc(reti, sizeof(regexp_internal) + len*sizeof(regnode),\n          char, regexp_internal);\n    Copy(ri->program, reti->program, len+1, regnode);\n\n\n    if (ri->code_blocks) {\n\tint n;\n\tNewx(reti->code_blocks, 1, struct reg_code_blocks);\n\tNewx(reti->code_blocks->cb, ri->code_blocks->count,\n                    struct reg_code_block);\n\tCopy(ri->code_blocks->cb, reti->code_blocks->cb,\n             ri->code_blocks->count, struct reg_code_block);\n\tfor (n = 0; n < ri->code_blocks->count; n++)\n\t     reti->code_blocks->cb[n].src_regex = (REGEXP*)\n\t\t    sv_dup_inc((SV*)(ri->code_blocks->cb[n].src_regex), param);\n        reti->code_blocks->count = ri->code_blocks->count;\n        reti->code_blocks->refcnt = 1;\n    }\n    else\n\treti->code_blocks = NULL;\n\n    reti->regstclass = NULL;\n\n    if (ri->data) {\n\tstruct reg_data *d;\n        const int count = ri->data->count;\n\tint i;\n\n\tNewxc(d, sizeof(struct reg_data) + count*sizeof(void *),\n\t\tchar, struct reg_data);\n\tNewx(d->what, count, U8);\n\n\td->count = count;\n\tfor (i = 0; i < count; i++) {\n\t    d->what[i] = ri->data->what[i];\n\t    switch (d->what[i]) {\n\t        /* see also regcomp.h and regfree_internal() */\n            case 'a': /* actually an AV, but the dup function is identical.\n                         values seem to be \"plain sv's\" generally. */\n            case 'r': /* a compiled regex (but still just another SV) */\n            case 's': /* an RV (currently only used for an RV to an AV by the ANYOF code)\n                         this use case should go away, the code could have used\n                         'a' instead - see S_set_ANYOF_arg() for array contents. */\n            case 'S': /* actually an SV, but the dup function is identical.  */\n            case 'u': /* actually an HV, but the dup function is identical.\n                         values are \"plain sv's\" */\n\t\td->data[i] = sv_dup_inc((const SV *)ri->data->data[i], param);\n\t\tbreak;\n\t    case 'f':\n                /* Synthetic Start Class - \"Fake\" charclass we generate to optimize\n                 * patterns which could start with several different things. Pre-TRIE\n                 * this was more important than it is now, however this still helps\n                 * in some places, for instance /x?a+/ might produce a SSC equivalent\n                 * to [xa]. This is used by Perl_re_intuit_start() and S_find_byclass()\n                 * in regexec.c\n                 */\n\t\t/* This is cheating. */\n\t\tNewx(d->data[i], 1, regnode_ssc);\n\t\tStructCopy(ri->data->data[i], d->data[i], regnode_ssc);\n\t\treti->regstclass = (regnode*)d->data[i];\n\t\tbreak;\n\t    case 'T':\n                /* AHO-CORASICK fail table */\n                /* Trie stclasses are readonly and can thus be shared\n\t\t * without duplication. We free the stclass in pregfree\n\t\t * when the corresponding reg_ac_data struct is freed.\n\t\t */\n\t\treti->regstclass= ri->regstclass;\n\t\t/* FALLTHROUGH */\n\t    case 't':\n                /* TRIE transition table */\n\t\tOP_REFCNT_LOCK;\n\t\t((reg_trie_data*)ri->data->data[i])->refcount++;\n\t\tOP_REFCNT_UNLOCK;\n\t\t/* FALLTHROUGH */\n            case 'l': /* (?{...}) or (??{ ... }) code (cb->block) */\n            case 'L': /* same when RExC_pm_flags & PMf_HAS_CV and code\n                         is not from another regexp */\n\t\td->data[i] = ri->data->data[i];\n\t\tbreak;\n            default:\n                Perl_croak(aTHX_ \"panic: re_dup_guts unknown data code '%c'\",\n                                                           ri->data->what[i]);\n\t    }\n\t}\n\n\treti->data = d;\n    }\n    else\n\treti->data = NULL;\n\n    reti->name_list_idx = ri->name_list_idx;\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    if (ri->u.offsets) {\n        Newx(reti->u.offsets, 2*len+1, U32);\n        Copy(ri->u.offsets, reti->u.offsets, 2*len+1, U32);\n    }\n#else\n    SetProgLen(reti, len);\n#endif\n\n    return (void*)reti;\n}\n\n#endif    /* USE_ITHREADS */\n\n#ifndef PERL_IN_XSUB_RE\n\n/*\n - regnext - dig the \"next\" pointer out of a node\n */\nregnode *\nPerl_regnext(pTHX_ regnode *p)\n{\n    I32 offset;\n\n    if (!p)\n\treturn(NULL);\n\n    if (OP(p) > REGNODE_MAX) {\t\t/* regnode.type is unsigned */\n\tPerl_croak(aTHX_ \"Corrupted regexp opcode %d > %d\",\n                                                (int)OP(p), (int)REGNODE_MAX);\n    }\n\n    offset = (reg_off_by_arg[OP(p)] ? ARG(p) : NEXT_OFF(p));\n    if (offset == 0)\n\treturn(NULL);\n\n    return(p+offset);\n}\n\n#endif\n\nSTATIC void\nS_re_croak2(pTHX_ bool utf8, const char* pat1, const char* pat2,...)\n{\n    va_list args;\n    STRLEN l1 = strlen(pat1);\n    STRLEN l2 = strlen(pat2);\n    char buf[512];\n    SV *msv;\n    const char *message;\n\n    PERL_ARGS_ASSERT_RE_CROAK2;\n\n    if (l1 > 510)\n\tl1 = 510;\n    if (l1 + l2 > 510)\n\tl2 = 510 - l1;\n    Copy(pat1, buf, l1 , char);\n    Copy(pat2, buf + l1, l2 , char);\n    buf[l1 + l2] = '\\n';\n    buf[l1 + l2 + 1] = '\\0';\n    va_start(args, pat2);\n    msv = vmess(buf, &args);\n    va_end(args);\n    message = SvPV_const(msv, l1);\n    if (l1 > 512)\n\tl1 = 512;\n    Copy(message, buf, l1 , char);\n    /* l1-1 to avoid \\n */\n    Perl_croak(aTHX_ \"%\" UTF8f, UTF8fARG(utf8, l1-1, buf));\n}\n\n/* XXX Here's a total kludge.  But we need to re-enter for swash routines. */\n\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_save_re_context(pTHX)\n{\n    I32 nparens = -1;\n    I32 i;\n\n    /* Save $1..$n (#18107: UTF-8 s/(\\w+)/uc($1)/e); AMS 20021106. */\n\n    if (PL_curpm) {\n\tconst REGEXP * const rx = PM_GETRE(PL_curpm);\n\tif (rx)\n            nparens = RX_NPARENS(rx);\n    }\n\n    /* RT #124109. This is a complete hack; in the SWASHNEW case we know\n     * that PL_curpm will be null, but that utf8.pm and the modules it\n     * loads will only use $1..$3.\n     * The t/porting/re_context.t test file checks this assumption.\n     */\n    if (nparens == -1)\n        nparens = 3;\n\n    for (i = 1; i <= nparens; i++) {\n        char digits[TYPE_CHARS(long)];\n        const STRLEN len = my_snprintf(digits, sizeof(digits),\n                                       \"%lu\", (long)i);\n        GV *const *const gvp\n            = (GV**)hv_fetch(PL_defstash, digits, len, 0);\n\n        if (gvp) {\n            GV * const gv = *gvp;\n            if (SvTYPE(gv) == SVt_PVGV && GvSV(gv))\n                save_scalar(gv);\n        }\n    }\n}\n#endif\n\n#ifdef DEBUGGING\n\nSTATIC void\nS_put_code_point(pTHX_ SV *sv, UV c)\n{\n    PERL_ARGS_ASSERT_PUT_CODE_POINT;\n\n    if (c > 255) {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x{%04\" UVXf \"}\", c);\n    }\n    else if (isPRINT(c)) {\n\tconst char string = (char) c;\n\n        /* We use {phrase} as metanotation in the class, so also escape literal\n         * braces */\n\tif (isBACKSLASHED_PUNCT(c) || c == '{' || c == '}')\n\t    sv_catpvs(sv, \"\\\\\");\n\tsv_catpvn(sv, &string, 1);\n    }\n    else if (isMNEMONIC_CNTRL(c)) {\n        Perl_sv_catpvf(aTHX_ sv, \"%s\", cntrl_to_mnemonic((U8) c));\n    }\n    else {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x%02X\", (U8) c);\n    }\n}\n\n#define MAX_PRINT_A MAX_PRINT_A_FOR_USE_ONLY_BY_REGCOMP_DOT_C\n\nSTATIC void\nS_put_range(pTHX_ SV *sv, UV start, const UV end, const bool allow_literals)\n{\n    /* Appends to 'sv' a displayable version of the range of code points from\n     * 'start' to 'end'.  Mnemonics (like '\\r') are used for the few controls\n     * that have them, when they occur at the beginning or end of the range.\n     * It uses hex to output the remaining code points, unless 'allow_literals'\n     * is true, in which case the printable ASCII ones are output as-is (though\n     * some of these will be escaped by put_code_point()).\n     *\n     * NOTE:  This is designed only for printing ranges of code points that fit\n     *        inside an ANYOF bitmap.  Higher code points are simply suppressed\n     */\n\n    const unsigned int min_range_count = 3;\n\n    assert(start <= end);\n\n    PERL_ARGS_ASSERT_PUT_RANGE;\n\n    while (start <= end) {\n        UV this_end;\n        const char * format;\n\n        if (end - start < min_range_count) {\n\n            /* Output chars individually when they occur in short ranges */\n            for (; start <= end; start++) {\n                put_code_point(sv, start);\n            }\n            break;\n        }\n\n        /* If permitted by the input options, and there is a possibility that\n         * this range contains a printable literal, look to see if there is\n         * one. */\n        if (allow_literals && start <= MAX_PRINT_A) {\n\n            /* If the character at the beginning of the range isn't an ASCII\n             * printable, effectively split the range into two parts:\n             *  1) the portion before the first such printable,\n             *  2) the rest\n             * and output them separately. */\n            if (! isPRINT_A(start)) {\n                UV temp_end = start + 1;\n\n                /* There is no point looking beyond the final possible\n                 * printable, in MAX_PRINT_A */\n                UV max = MIN(end, MAX_PRINT_A);\n\n                while (temp_end <= max && ! isPRINT_A(temp_end)) {\n                    temp_end++;\n                }\n\n                /* Here, temp_end points to one beyond the first printable if\n                 * found, or to one beyond 'max' if not.  If none found, make\n                 * sure that we use the entire range */\n                if (temp_end > MAX_PRINT_A) {\n                    temp_end = end + 1;\n                }\n\n                /* Output the first part of the split range: the part that\n                 * doesn't have printables, with the parameter set to not look\n                 * for literals (otherwise we would infinitely recurse) */\n                put_range(sv, start, temp_end - 1, FALSE);\n\n                /* The 2nd part of the range (if any) starts here. */\n                start = temp_end;\n\n                /* We do a continue, instead of dropping down, because even if\n                 * the 2nd part is non-empty, it could be so short that we want\n                 * to output it as individual characters, as tested for at the\n                 * top of this loop.  */\n                continue;\n            }\n\n            /* Here, 'start' is a printable ASCII.  If it is an alphanumeric,\n             * output a sub-range of just the digits or letters, then process\n             * the remaining portion as usual. */\n            if (isALPHANUMERIC_A(start)) {\n                UV mask = (isDIGIT_A(start))\n                           ? _CC_DIGIT\n                             : isUPPER_A(start)\n                               ? _CC_UPPER\n                               : _CC_LOWER;\n                UV temp_end = start + 1;\n\n                /* Find the end of the sub-range that includes just the\n                 * characters in the same class as the first character in it */\n                while (temp_end <= end && _generic_isCC_A(temp_end, mask)) {\n                    temp_end++;\n                }\n                temp_end--;\n\n                /* For short ranges, don't duplicate the code above to output\n                 * them; just call recursively */\n                if (temp_end - start < min_range_count) {\n                    put_range(sv, start, temp_end, FALSE);\n                }\n                else {  /* Output as a range */\n                    put_code_point(sv, start);\n                    sv_catpvs(sv, \"-\");\n                    put_code_point(sv, temp_end);\n                }\n                start = temp_end + 1;\n                continue;\n            }\n\n            /* We output any other printables as individual characters */\n            if (isPUNCT_A(start) || isSPACE_A(start)) {\n                while (start <= end && (isPUNCT_A(start)\n                                        || isSPACE_A(start)))\n                {\n                    put_code_point(sv, start);\n                    start++;\n                }\n                continue;\n            }\n        } /* End of looking for literals */\n\n        /* Here is not to output as a literal.  Some control characters have\n         * mnemonic names.  Split off any of those at the beginning and end of\n         * the range to print mnemonically.  It isn't possible for many of\n         * these to be in a row, so this won't overwhelm with output */\n        if (   start <= end\n            && (isMNEMONIC_CNTRL(start) || isMNEMONIC_CNTRL(end)))\n        {\n            while (isMNEMONIC_CNTRL(start) && start <= end) {\n                put_code_point(sv, start);\n                start++;\n            }\n\n            /* If this didn't take care of the whole range ... */\n            if (start <= end) {\n\n                /* Look backwards from the end to find the final non-mnemonic\n                 * */\n                UV temp_end = end;\n                while (isMNEMONIC_CNTRL(temp_end)) {\n                    temp_end--;\n                }\n\n                /* And separately output the interior range that doesn't start\n                 * or end with mnemonics */\n                put_range(sv, start, temp_end, FALSE);\n\n                /* Then output the mnemonic trailing controls */\n                start = temp_end + 1;\n                while (start <= end) {\n                    put_code_point(sv, start);\n                    start++;\n                }\n                break;\n            }\n        }\n\n        /* As a final resort, output the range or subrange as hex. */\n\n        this_end = (end < NUM_ANYOF_CODE_POINTS)\n                    ? end\n                    : NUM_ANYOF_CODE_POINTS - 1;\n#if NUM_ANYOF_CODE_POINTS > 256\n        format = (this_end < 256)\n                 ? \"\\\\x%02\" UVXf \"-\\\\x%02\" UVXf\n                 : \"\\\\x{%04\" UVXf \"}-\\\\x{%04\" UVXf \"}\";\n#else\n        format = \"\\\\x%02\" UVXf \"-\\\\x%02\" UVXf;\n#endif\n        GCC_DIAG_IGNORE_STMT(-Wformat-nonliteral);\n        Perl_sv_catpvf(aTHX_ sv, format, start, this_end);\n        GCC_DIAG_RESTORE_STMT;\n        break;\n    }\n}\n\nSTATIC void\nS_put_charclass_bitmap_innards_invlist(pTHX_ SV *sv, SV* invlist)\n{\n    /* Concatenate onto the PV in 'sv' a displayable form of the inversion list\n     * 'invlist' */\n\n    UV start, end;\n    bool allow_literals = TRUE;\n\n    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_INVLIST;\n\n    /* Generally, it is more readable if printable characters are output as\n     * literals, but if a range (nearly) spans all of them, it's best to output\n     * it as a single range.  This code will use a single range if all but 2\n     * ASCII printables are in it */\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n\n        /* If the range starts beyond the final printable, it doesn't have any\n         * in it */\n        if (start > MAX_PRINT_A) {\n            break;\n        }\n\n        /* In both ASCII and EBCDIC, a SPACE is the lowest printable.  To span\n         * all but two, the range must start and end no later than 2 from\n         * either end */\n        if (start < ' ' + 2 && end > MAX_PRINT_A - 2) {\n            if (end > MAX_PRINT_A) {\n                end = MAX_PRINT_A;\n            }\n            if (start < ' ') {\n                start = ' ';\n            }\n            if (end - start >= MAX_PRINT_A - ' ' - 2) {\n                allow_literals = FALSE;\n            }\n            break;\n        }\n    }\n    invlist_iterfinish(invlist);\n\n    /* Here we have figured things out.  Output each range */\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n        if (start >= NUM_ANYOF_CODE_POINTS) {\n            break;\n        }\n        put_range(sv, start, end, allow_literals);\n    }\n    invlist_iterfinish(invlist);\n\n    return;\n}\n\nSTATIC SV*\nS_put_charclass_bitmap_innards_common(pTHX_\n        SV* invlist,            /* The bitmap */\n        SV* posixes,            /* Under /l, things like [:word:], \\S */\n        SV* only_utf8,          /* Under /d, matches iff the target is UTF-8 */\n        SV* not_utf8,           /* /d, matches iff the target isn't UTF-8 */\n        SV* only_utf8_locale,   /* Under /l, matches if the locale is UTF-8 */\n        const bool invert       /* Is the result to be inverted? */\n)\n{\n    /* Create and return an SV containing a displayable version of the bitmap\n     * and associated information determined by the input parameters.  If the\n     * output would have been only the inversion indicator '^', NULL is instead\n     * returned. */\n\n    dVAR;\n    SV * output;\n\n    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_COMMON;\n\n    if (invert) {\n        output = newSVpvs(\"^\");\n    }\n    else {\n        output = newSVpvs(\"\");\n    }\n\n    /* First, the code points in the bitmap that are unconditionally there */\n    put_charclass_bitmap_innards_invlist(output, invlist);\n\n    /* Traditionally, these have been placed after the main code points */\n    if (posixes) {\n        sv_catsv(output, posixes);\n    }\n\n    if (only_utf8 && _invlist_len(only_utf8)) {\n        Perl_sv_catpvf(aTHX_ output, \"%s{utf8}%s\", PL_colors[1], PL_colors[0]);\n        put_charclass_bitmap_innards_invlist(output, only_utf8);\n    }\n\n    if (not_utf8 && _invlist_len(not_utf8)) {\n        Perl_sv_catpvf(aTHX_ output, \"%s{not utf8}%s\", PL_colors[1], PL_colors[0]);\n        put_charclass_bitmap_innards_invlist(output, not_utf8);\n    }\n\n    if (only_utf8_locale && _invlist_len(only_utf8_locale)) {\n        Perl_sv_catpvf(aTHX_ output, \"%s{utf8 locale}%s\", PL_colors[1], PL_colors[0]);\n        put_charclass_bitmap_innards_invlist(output, only_utf8_locale);\n\n        /* This is the only list in this routine that can legally contain code\n         * points outside the bitmap range.  The call just above to\n         * 'put_charclass_bitmap_innards_invlist' will simply suppress them, so\n         * output them here.  There's about a half-dozen possible, and none in\n         * contiguous ranges longer than 2 */\n        if (invlist_highest(only_utf8_locale) >= NUM_ANYOF_CODE_POINTS) {\n            UV start, end;\n            SV* above_bitmap = NULL;\n\n            _invlist_subtract(only_utf8_locale, PL_InBitmap, &above_bitmap);\n\n            invlist_iterinit(above_bitmap);\n            while (invlist_iternext(above_bitmap, &start, &end)) {\n                UV i;\n\n                for (i = start; i <= end; i++) {\n                    put_code_point(output, i);\n                }\n            }\n            invlist_iterfinish(above_bitmap);\n            SvREFCNT_dec_NN(above_bitmap);\n        }\n    }\n\n    if (invert && SvCUR(output) == 1) {\n        return NULL;\n    }\n\n    return output;\n}\n\nSTATIC bool\nS_put_charclass_bitmap_innards(pTHX_ SV *sv,\n                                     char *bitmap,\n                                     SV *nonbitmap_invlist,\n                                     SV *only_utf8_locale_invlist,\n                                     const regnode * const node,\n                                     const bool force_as_is_display)\n{\n    /* Appends to 'sv' a displayable version of the innards of the bracketed\n     * character class defined by the other arguments:\n     *  'bitmap' points to the bitmap, or NULL if to ignore that.\n     *  'nonbitmap_invlist' is an inversion list of the code points that are in\n     *      the bitmap range, but for some reason aren't in the bitmap; NULL if\n     *      none.  The reasons for this could be that they require some\n     *      condition such as the target string being or not being in UTF-8\n     *      (under /d), or because they came from a user-defined property that\n     *      was not resolved at the time of the regex compilation (under /u)\n     *  'only_utf8_locale_invlist' is an inversion list of the code points that\n     *      are valid only if the runtime locale is a UTF-8 one; NULL if none\n     *  'node' is the regex pattern ANYOF node.  It is needed only when the\n     *      above two parameters are not null, and is passed so that this\n     *      routine can tease apart the various reasons for them.\n     *  'force_as_is_display' is TRUE if this routine should definitely NOT try\n     *      to invert things to see if that leads to a cleaner display.  If\n     *      FALSE, this routine is free to use its judgment about doing this.\n     *\n     * It returns TRUE if there was actually something output.  (It may be that\n     * the bitmap, etc is empty.)\n     *\n     * When called for outputting the bitmap of a non-ANYOF node, just pass the\n     * bitmap, with the succeeding parameters set to NULL, and the final one to\n     * FALSE.\n     */\n\n    /* In general, it tries to display the 'cleanest' representation of the\n     * innards, choosing whether to display them inverted or not, regardless of\n     * whether the class itself is to be inverted.  However,  there are some\n     * cases where it can't try inverting, as what actually matches isn't known\n     * until runtime, and hence the inversion isn't either. */\n\n    dVAR;\n    bool inverting_allowed = ! force_as_is_display;\n\n    int i;\n    STRLEN orig_sv_cur = SvCUR(sv);\n\n    SV* invlist;            /* Inversion list we accumulate of code points that\n                               are unconditionally matched */\n    SV* only_utf8 = NULL;   /* Under /d, list of matches iff the target is\n                               UTF-8 */\n    SV* not_utf8 =  NULL;   /* /d, list of matches iff the target isn't UTF-8\n                             */\n    SV* posixes = NULL;     /* Under /l, string of things like [:word:], \\D */\n    SV* only_utf8_locale = NULL;    /* Under /l, list of matches if the locale\n                                       is UTF-8 */\n\n    SV* as_is_display;      /* The output string when we take the inputs\n                               literally */\n    SV* inverted_display;   /* The output string when we invert the inputs */\n\n    U8 flags = (node) ? ANYOF_FLAGS(node) : 0;\n\n    bool invert = cBOOL(flags & ANYOF_INVERT);  /* Is the input to be inverted\n                                                   to match? */\n    /* We are biased in favor of displaying things without them being inverted,\n     * as that is generally easier to understand */\n    const int bias = 5;\n\n    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS;\n\n    /* Start off with whatever code points are passed in.  (We clone, so we\n     * don't change the caller's list) */\n    if (nonbitmap_invlist) {\n        assert(invlist_highest(nonbitmap_invlist) < NUM_ANYOF_CODE_POINTS);\n        invlist = invlist_clone(nonbitmap_invlist, NULL);\n    }\n    else {  /* Worst case size is every other code point is matched */\n        invlist = _new_invlist(NUM_ANYOF_CODE_POINTS / 2);\n    }\n\n    if (flags) {\n        if (OP(node) == ANYOFD) {\n\n            /* This flag indicates that the code points below 0x100 in the\n             * nonbitmap list are precisely the ones that match only when the\n             * target is UTF-8 (they should all be non-ASCII). */\n            if (flags & ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP)\n            {\n                _invlist_intersection(invlist, PL_UpperLatin1, &only_utf8);\n                _invlist_subtract(invlist, only_utf8, &invlist);\n            }\n\n            /* And this flag for matching all non-ASCII 0xFF and below */\n            if (flags & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER)\n            {\n                not_utf8 = invlist_clone(PL_UpperLatin1, NULL);\n            }\n        }\n        else if (OP(node) == ANYOFL || OP(node) == ANYOFPOSIXL) {\n\n            /* If either of these flags are set, what matches isn't\n             * determinable except during execution, so don't know enough here\n             * to invert */\n            if (flags & (ANYOFL_FOLD|ANYOF_MATCHES_POSIXL)) {\n                inverting_allowed = FALSE;\n            }\n\n            /* What the posix classes match also varies at runtime, so these\n             * will be output symbolically. */\n            if (ANYOF_POSIXL_TEST_ANY_SET(node)) {\n                int i;\n\n                posixes = newSVpvs(\"\");\n                for (i = 0; i < ANYOF_POSIXL_MAX; i++) {\n                    if (ANYOF_POSIXL_TEST(node, i)) {\n                        sv_catpv(posixes, anyofs[i]);\n                    }\n                }\n            }\n        }\n    }\n\n    /* Accumulate the bit map into the unconditional match list */\n    if (bitmap) {\n        for (i = 0; i < NUM_ANYOF_CODE_POINTS; i++) {\n            if (BITMAP_TEST(bitmap, i)) {\n                int start = i++;\n                for (;\n                     i < NUM_ANYOF_CODE_POINTS && BITMAP_TEST(bitmap, i);\n                     i++)\n                { /* empty */ }\n                invlist = _add_range_to_invlist(invlist, start, i-1);\n            }\n        }\n    }\n\n    /* Make sure that the conditional match lists don't have anything in them\n     * that match unconditionally; otherwise the output is quite confusing.\n     * This could happen if the code that populates these misses some\n     * duplication. */\n    if (only_utf8) {\n        _invlist_subtract(only_utf8, invlist, &only_utf8);\n    }\n    if (not_utf8) {\n        _invlist_subtract(not_utf8, invlist, &not_utf8);\n    }\n\n    if (only_utf8_locale_invlist) {\n\n        /* Since this list is passed in, we have to make a copy before\n         * modifying it */\n        only_utf8_locale = invlist_clone(only_utf8_locale_invlist, NULL);\n\n        _invlist_subtract(only_utf8_locale, invlist, &only_utf8_locale);\n\n        /* And, it can get really weird for us to try outputting an inverted\n         * form of this list when it has things above the bitmap, so don't even\n         * try */\n        if (invlist_highest(only_utf8_locale) >= NUM_ANYOF_CODE_POINTS) {\n            inverting_allowed = FALSE;\n        }\n    }\n\n    /* Calculate what the output would be if we take the input as-is */\n    as_is_display = put_charclass_bitmap_innards_common(invlist,\n                                                    posixes,\n                                                    only_utf8,\n                                                    not_utf8,\n                                                    only_utf8_locale,\n                                                    invert);\n\n    /* If have to take the output as-is, just do that */\n    if (! inverting_allowed) {\n        if (as_is_display) {\n            sv_catsv(sv, as_is_display);\n            SvREFCNT_dec_NN(as_is_display);\n        }\n    }\n    else { /* But otherwise, create the output again on the inverted input, and\n              use whichever version is shorter */\n\n        int inverted_bias, as_is_bias;\n\n        /* We will apply our bias to whichever of the the results doesn't have\n         * the '^' */\n        if (invert) {\n            invert = FALSE;\n            as_is_bias = bias;\n            inverted_bias = 0;\n        }\n        else {\n            invert = TRUE;\n            as_is_bias = 0;\n            inverted_bias = bias;\n        }\n\n        /* Now invert each of the lists that contribute to the output,\n         * excluding from the result things outside the possible range */\n\n        /* For the unconditional inversion list, we have to add in all the\n         * conditional code points, so that when inverted, they will be gone\n         * from it */\n        _invlist_union(only_utf8, invlist, &invlist);\n        _invlist_union(not_utf8, invlist, &invlist);\n        _invlist_union(only_utf8_locale, invlist, &invlist);\n        _invlist_invert(invlist);\n        _invlist_intersection(invlist, PL_InBitmap, &invlist);\n\n        if (only_utf8) {\n            _invlist_invert(only_utf8);\n            _invlist_intersection(only_utf8, PL_UpperLatin1, &only_utf8);\n        }\n        else if (not_utf8) {\n\n            /* If a code point matches iff the target string is not in UTF-8,\n             * then complementing the result has it not match iff not in UTF-8,\n             * which is the same thing as matching iff it is UTF-8. */\n            only_utf8 = not_utf8;\n            not_utf8 = NULL;\n        }\n\n        if (only_utf8_locale) {\n            _invlist_invert(only_utf8_locale);\n            _invlist_intersection(only_utf8_locale,\n                                  PL_InBitmap,\n                                  &only_utf8_locale);\n        }\n\n        inverted_display = put_charclass_bitmap_innards_common(\n                                            invlist,\n                                            posixes,\n                                            only_utf8,\n                                            not_utf8,\n                                            only_utf8_locale, invert);\n\n        /* Use the shortest representation, taking into account our bias\n         * against showing it inverted */\n        if (   inverted_display\n            && (   ! as_is_display\n                || (  SvCUR(inverted_display) + inverted_bias\n                    < SvCUR(as_is_display)    + as_is_bias)))\n        {\n\t    sv_catsv(sv, inverted_display);\n        }\n        else if (as_is_display) {\n\t    sv_catsv(sv, as_is_display);\n        }\n\n        SvREFCNT_dec(as_is_display);\n        SvREFCNT_dec(inverted_display);\n    }\n\n    SvREFCNT_dec_NN(invlist);\n    SvREFCNT_dec(only_utf8);\n    SvREFCNT_dec(not_utf8);\n    SvREFCNT_dec(posixes);\n    SvREFCNT_dec(only_utf8_locale);\n\n    return SvCUR(sv) > orig_sv_cur;\n}\n\n#define CLEAR_OPTSTART                                                       \\\n    if (optstart) STMT_START {                                               \\\n        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_                                           \\\n                              \" (%\" IVdf \" nodes)\\n\", (IV)(node - optstart))); \\\n        optstart=NULL;                                                       \\\n    } STMT_END\n\n#define DUMPUNTIL(b,e)                                                       \\\n                    CLEAR_OPTSTART;                                          \\\n                    node=dumpuntil(r,start,(b),(e),last,sv,indent+1,depth+1);\n\nSTATIC const regnode *\nS_dumpuntil(pTHX_ const regexp *r, const regnode *start, const regnode *node,\n\t    const regnode *last, const regnode *plast,\n\t    SV* sv, I32 indent, U32 depth)\n{\n    U8 op = PSEUDO;\t/* Arbitrary non-END op. */\n    const regnode *next;\n    const regnode *optstart= NULL;\n\n    RXi_GET_DECL(r, ri);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMPUNTIL;\n\n#ifdef DEBUG_DUMPUNTIL\n    Perl_re_printf( aTHX_  \"--- %d : %d - %d - %d\\n\", indent, node-start,\n        last ? last-start : 0, plast ? plast-start : 0);\n#endif\n\n    if (plast && plast < last)\n        last= plast;\n\n    while (PL_regkind[op] != END && (!last || node < last)) {\n        assert(node);\n\t/* While that wasn't END last time... */\n\tNODE_ALIGN(node);\n\top = OP(node);\n\tif (op == CLOSE || op == SRCLOSE || op == WHILEM)\n\t    indent--;\n\tnext = regnext((regnode *)node);\n\n\t/* Where, what. */\n\tif (OP(node) == OPTIMIZED) {\n\t    if (!optstart && RE_DEBUG_FLAG(RE_DEBUG_COMPILE_OPTIMISE))\n\t        optstart = node;\n\t    else\n\t\tgoto after_print;\n\t} else\n\t    CLEAR_OPTSTART;\n\n        regprop(r, sv, node, NULL, NULL);\n        Perl_re_printf( aTHX_  \"%4\" IVdf \":%*s%s\", (IV)(node - start),\n\t\t      (int)(2*indent + 1), \"\", SvPVX_const(sv));\n\n        if (OP(node) != OPTIMIZED) {\n            if (next == NULL)\t\t/* Next ptr. */\n                Perl_re_printf( aTHX_  \" (0)\");\n            else if (PL_regkind[(U8)op] == BRANCH\n                     && PL_regkind[OP(next)] != BRANCH )\n                Perl_re_printf( aTHX_  \" (FAIL)\");\n            else\n                Perl_re_printf( aTHX_  \" (%\" IVdf \")\", (IV)(next - start));\n            Perl_re_printf( aTHX_ \"\\n\");\n        }\n\n      after_print:\n\tif (PL_regkind[(U8)op] == BRANCHJ) {\n\t    assert(next);\n\t    {\n                const regnode *nnode = (OP(next) == LONGJMP\n                                       ? regnext((regnode *)next)\n                                       : next);\n                if (last && nnode > last)\n                    nnode = last;\n                DUMPUNTIL(NEXTOPER(NEXTOPER(node)), nnode);\n\t    }\n\t}\n\telse if (PL_regkind[(U8)op] == BRANCH) {\n\t    assert(next);\n\t    DUMPUNTIL(NEXTOPER(node), next);\n\t}\n\telse if ( PL_regkind[(U8)op]  == TRIE ) {\n\t    const regnode *this_trie = node;\n\t    const char op = OP(node);\n            const U32 n = ARG(node);\n\t    const reg_ac_data * const ac = op>=AHOCORASICK ?\n               (reg_ac_data *)ri->data->data[n] :\n               NULL;\n\t    const reg_trie_data * const trie =\n\t        (reg_trie_data*)ri->data->data[op<AHOCORASICK ? n : ac->trie];\n#ifdef DEBUGGING\n\t    AV *const trie_words\n                           = MUTABLE_AV(ri->data->data[n + TRIE_WORDS_OFFSET]);\n#endif\n\t    const regnode *nextbranch= NULL;\n\t    I32 word_idx;\n            SvPVCLEAR(sv);\n\t    for (word_idx= 0; word_idx < (I32)trie->wordcount; word_idx++) {\n\t\tSV ** const elem_ptr = av_fetch(trie_words, word_idx, 0);\n\n                Perl_re_indentf( aTHX_  \"%s \",\n                    indent+3,\n                    elem_ptr\n                    ? pv_pretty(sv, SvPV_nolen_const(*elem_ptr),\n                                SvCUR(*elem_ptr), PL_dump_re_max_len,\n                                PL_colors[0], PL_colors[1],\n                                (SvUTF8(*elem_ptr)\n                                 ? PERL_PV_ESCAPE_UNI\n                                 : 0)\n                                | PERL_PV_PRETTY_ELLIPSES\n                                | PERL_PV_PRETTY_LTGT\n                            )\n                    : \"???\"\n                );\n                if (trie->jump) {\n                    U16 dist= trie->jump[word_idx+1];\n                    Perl_re_printf( aTHX_  \"(%\" UVuf \")\\n\",\n                               (UV)((dist ? this_trie + dist : next) - start));\n                    if (dist) {\n                        if (!nextbranch)\n                            nextbranch= this_trie + trie->jump[0];\n\t\t\tDUMPUNTIL(this_trie + dist, nextbranch);\n                    }\n                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n                        nextbranch= regnext((regnode *)nextbranch);\n                } else {\n                    Perl_re_printf( aTHX_  \"\\n\");\n\t\t}\n\t    }\n\t    if (last && next > last)\n\t        node= last;\n\t    else\n\t        node= next;\n\t}\n\telse if ( op == CURLY ) {   /* \"next\" might be very big: optimizer */\n\t    DUMPUNTIL(NEXTOPER(node) + EXTRA_STEP_2ARGS,\n                    NEXTOPER(node) + EXTRA_STEP_2ARGS + 1);\n\t}\n\telse if (PL_regkind[(U8)op] == CURLY && op != CURLYX) {\n\t    assert(next);\n\t    DUMPUNTIL(NEXTOPER(node) + EXTRA_STEP_2ARGS, next);\n\t}\n\telse if ( op == PLUS || op == STAR) {\n\t    DUMPUNTIL(NEXTOPER(node), NEXTOPER(node) + 1);\n\t}\n\telse if (PL_regkind[(U8)op] == EXACT) {\n            /* Literal string, where present. */\n\t    node += NODE_SZ_STR(node) - 1;\n\t    node = NEXTOPER(node);\n\t}\n\telse {\n\t    node = NEXTOPER(node);\n\t    node += regarglen[(U8)op];\n\t}\n\tif (op == CURLYX || op == OPEN || op == SROPEN)\n\t    indent++;\n    }\n    CLEAR_OPTSTART;\n#ifdef DEBUG_DUMPUNTIL\n    Perl_re_printf( aTHX_  \"--- %d\\n\", (int)indent);\n#endif\n    return node;\n}\n\n#endif\t/* DEBUGGING */\n\n#ifndef PERL_IN_XSUB_RE\n\n#include \"uni_keywords.h\"\n\nvoid\nPerl_init_uniprops(pTHX)\n{\n    dVAR;\n\n    PL_user_def_props = newHV();\n\n#ifdef USE_ITHREADS\n\n    HvSHAREKEYS_off(PL_user_def_props);\n    PL_user_def_props_aTHX = aTHX;\n\n#endif\n\n    /* Set up the inversion list global variables */\n\n    PL_XPosix_ptrs[_CC_ASCII] = _new_invlist_C_array(uni_prop_ptrs[UNI_ASCII]);\n    PL_XPosix_ptrs[_CC_ALPHANUMERIC] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXALNUM]);\n    PL_XPosix_ptrs[_CC_ALPHA] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXALPHA]);\n    PL_XPosix_ptrs[_CC_BLANK] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXBLANK]);\n    PL_XPosix_ptrs[_CC_CASED] =  _new_invlist_C_array(uni_prop_ptrs[UNI_CASED]);\n    PL_XPosix_ptrs[_CC_CNTRL] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXCNTRL]);\n    PL_XPosix_ptrs[_CC_DIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXDIGIT]);\n    PL_XPosix_ptrs[_CC_GRAPH] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXGRAPH]);\n    PL_XPosix_ptrs[_CC_LOWER] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXLOWER]);\n    PL_XPosix_ptrs[_CC_PRINT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXPRINT]);\n    PL_XPosix_ptrs[_CC_PUNCT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXPUNCT]);\n    PL_XPosix_ptrs[_CC_SPACE] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXSPACE]);\n    PL_XPosix_ptrs[_CC_UPPER] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXUPPER]);\n    PL_XPosix_ptrs[_CC_VERTSPACE] = _new_invlist_C_array(uni_prop_ptrs[UNI_VERTSPACE]);\n    PL_XPosix_ptrs[_CC_WORDCHAR] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXWORD]);\n    PL_XPosix_ptrs[_CC_XDIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXXDIGIT]);\n\n    PL_Posix_ptrs[_CC_ASCII] = _new_invlist_C_array(uni_prop_ptrs[UNI_ASCII]);\n    PL_Posix_ptrs[_CC_ALPHANUMERIC] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXALNUM]);\n    PL_Posix_ptrs[_CC_ALPHA] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXALPHA]);\n    PL_Posix_ptrs[_CC_BLANK] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXBLANK]);\n    PL_Posix_ptrs[_CC_CASED] = PL_Posix_ptrs[_CC_ALPHA];\n    PL_Posix_ptrs[_CC_CNTRL] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXCNTRL]);\n    PL_Posix_ptrs[_CC_DIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXDIGIT]);\n    PL_Posix_ptrs[_CC_GRAPH] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXGRAPH]);\n    PL_Posix_ptrs[_CC_LOWER] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXLOWER]);\n    PL_Posix_ptrs[_CC_PRINT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXPRINT]);\n    PL_Posix_ptrs[_CC_PUNCT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXPUNCT]);\n    PL_Posix_ptrs[_CC_SPACE] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXSPACE]);\n    PL_Posix_ptrs[_CC_UPPER] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXUPPER]);\n    PL_Posix_ptrs[_CC_VERTSPACE] = NULL;\n    PL_Posix_ptrs[_CC_WORDCHAR] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXWORD]);\n    PL_Posix_ptrs[_CC_XDIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXXDIGIT]);\n\n    PL_GCB_invlist = _new_invlist_C_array(_Perl_GCB_invlist);\n    PL_SB_invlist = _new_invlist_C_array(_Perl_SB_invlist);\n    PL_WB_invlist = _new_invlist_C_array(_Perl_WB_invlist);\n    PL_LB_invlist = _new_invlist_C_array(_Perl_LB_invlist);\n    PL_SCX_invlist = _new_invlist_C_array(_Perl_SCX_invlist);\n\n    PL_AboveLatin1 = _new_invlist_C_array(AboveLatin1_invlist);\n    PL_Latin1 = _new_invlist_C_array(Latin1_invlist);\n    PL_UpperLatin1 = _new_invlist_C_array(UpperLatin1_invlist);\n\n    PL_Assigned_invlist = _new_invlist_C_array(uni_prop_ptrs[UNI_ASSIGNED]);\n\n    PL_utf8_perl_idstart = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_IDSTART]);\n    PL_utf8_perl_idcont = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_IDCONT]);\n\n    PL_utf8_charname_begin = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_CHARNAME_BEGIN]);\n    PL_utf8_charname_continue = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_CHARNAME_CONTINUE]);\n\n    PL_in_some_fold = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_ANY_FOLDS]);\n    PL_HasMultiCharFold = _new_invlist_C_array(uni_prop_ptrs[\n                                            UNI__PERL_FOLDS_TO_MULTI_CHAR]);\n    PL_InMultiCharFold = _new_invlist_C_array(uni_prop_ptrs[\n                                            UNI__PERL_IS_IN_MULTI_CHAR_FOLD]);\n    PL_NonFinalFold = _new_invlist_C_array(uni_prop_ptrs[\n                                            UNI__PERL_NON_FINAL_FOLDS]);\n\n    PL_utf8_toupper = _new_invlist_C_array(Uppercase_Mapping_invlist);\n    PL_utf8_tolower = _new_invlist_C_array(Lowercase_Mapping_invlist);\n    PL_utf8_totitle = _new_invlist_C_array(Titlecase_Mapping_invlist);\n    PL_utf8_tofold = _new_invlist_C_array(Case_Folding_invlist);\n    PL_utf8_tosimplefold = _new_invlist_C_array(Simple_Case_Folding_invlist);\n    PL_utf8_foldclosures = _new_invlist_C_array(_Perl_IVCF_invlist);\n    PL_utf8_mark = _new_invlist_C_array(uni_prop_ptrs[UNI_M]);\n    PL_CCC_non0_non230 = _new_invlist_C_array(_Perl_CCC_non0_non230_invlist);\n    PL_Private_Use = _new_invlist_C_array(uni_prop_ptrs[UNI_CO]);\n\n#ifdef UNI_XIDC\n    /* The below are used only by deprecated functions.  They could be removed */\n    PL_utf8_xidcont  = _new_invlist_C_array(uni_prop_ptrs[UNI_XIDC]);\n    PL_utf8_idcont   = _new_invlist_C_array(uni_prop_ptrs[UNI_IDC]);\n    PL_utf8_xidstart = _new_invlist_C_array(uni_prop_ptrs[UNI_XIDS]);\n#endif\n}\n\n#if 0\n\nThis code was mainly added for backcompat to give a warning for non-portable\ncode points in user-defined properties.  But experiments showed that the\nwarning in earlier perls were only omitted on overflow, which should be an\nerror, so there really isnt a backcompat issue, and actually adding the\nwarning when none was present before might cause breakage, for little gain.  So\nkhw left this code in, but not enabled.  Tests were never added.\n\nembed.fnc entry:\nEi\t|const char *|get_extended_utf8_msg|const UV cp\n\nPERL_STATIC_INLINE const char *\nS_get_extended_utf8_msg(pTHX_ const UV cp)\n{\n    U8 dummy[UTF8_MAXBYTES + 1];\n    HV *msgs;\n    SV **msg;\n\n    uvchr_to_utf8_flags_msgs(dummy, cp, UNICODE_WARN_PERL_EXTENDED,\n                             &msgs);\n\n    msg = hv_fetchs(msgs, \"text\", 0);\n    assert(msg);\n\n    (void) sv_2mortal((SV *) msgs);\n\n    return SvPVX(*msg);\n}\n\n#endif\n\nSV *\nPerl_handle_user_defined_property(pTHX_\n\n    /* Parses the contents of a user-defined property definition; returning the\n     * expanded definition if possible.  If so, the return is an inversion\n     * list.\n     *\n     * If there are subroutines that are part of the expansion and which aren't\n     * known at the time of the call to this function, this returns what\n     * parse_uniprop_string() returned for the first one encountered.\n     *\n     * If an error was found, NULL is returned, and 'msg' gets a suitable\n     * message appended to it.  (Appending allows the back trace of how we got\n     * to the faulty definition to be displayed through nested calls of\n     * user-defined subs.)\n     *\n     * The caller IS responsible for freeing any returned SV.\n     *\n     * The syntax of the contents is pretty much described in perlunicode.pod,\n     * but we also allow comments on each line */\n\n    const char * name,          /* Name of property */\n    const STRLEN name_len,      /* The name's length in bytes */\n    const bool is_utf8,         /* ? Is 'name' encoded in UTF-8 */\n    const bool to_fold,         /* ? Is this under /i */\n    const bool runtime,         /* ? Are we in compile- or run-time */\n    const bool deferrable,      /* Is it ok for this property's full definition\n                                   to be deferred until later? */\n    SV* contents,               /* The property's definition */\n    bool *user_defined_ptr,     /* This will be set TRUE as we wouldn't be\n                                   getting called unless this is thought to be\n                                   a user-defined property */\n    SV * msg,                   /* Any error or warning msg(s) are appended to\n                                   this */\n    const STRLEN level)         /* Recursion level of this call */\n{\n    STRLEN len;\n    const char * string         = SvPV_const(contents, len);\n    const char * const e        = string + len;\n    const bool is_contents_utf8 = cBOOL(SvUTF8(contents));\n    const STRLEN msgs_length_on_entry = SvCUR(msg);\n\n    const char * s0 = string;   /* Points to first byte in the current line\n                                   being parsed in 'string' */\n    const char overflow_msg[] = \"Code point too large in \\\"\";\n    SV* running_definition = NULL;\n\n    PERL_ARGS_ASSERT_HANDLE_USER_DEFINED_PROPERTY;\n\n    *user_defined_ptr = TRUE;\n\n    /* Look at each line */\n    while (s0 < e) {\n        const char * s;     /* Current byte */\n        char op = '+';      /* Default operation is 'union' */\n        IV   min = 0;       /* range begin code point */\n        IV   max = -1;      /* and range end */\n        SV* this_definition;\n\n        /* Skip comment lines */\n        if (*s0 == '#') {\n            s0 = strchr(s0, '\\n');\n            if (s0 == NULL) {\n                break;\n            }\n            s0++;\n            continue;\n        }\n\n        /* For backcompat, allow an empty first line */\n        if (*s0 == '\\n') {\n            s0++;\n            continue;\n        }\n\n        /* First character in the line may optionally be the operation */\n        if (   *s0 == '+'\n            || *s0 == '!'\n            || *s0 == '-'\n            || *s0 == '&')\n        {\n            op = *s0++;\n        }\n\n        /* If the line is one or two hex digits separated by blank space, its\n         * a range; otherwise it is either another user-defined property or an\n         * error */\n\n        s = s0;\n\n        if (! isXDIGIT(*s)) {\n            goto check_if_property;\n        }\n\n        do { /* Each new hex digit will add 4 bits. */\n            if (min > ( (IV) MAX_LEGAL_CP >> 4)) {\n                s = strchr(s, '\\n');\n                if (s == NULL) {\n                    s = e;\n                }\n                if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                sv_catpv(msg, overflow_msg);\n                Perl_sv_catpvf(aTHX_ msg, \"%\" UTF8f,\n                                     UTF8fARG(is_contents_utf8, s - s0, s0));\n                sv_catpvs(msg, \"\\\"\");\n                goto return_failure;\n            }\n\n            /* Accumulate this digit into the value */\n            min = (min << 4) + READ_XDIGIT(s);\n        } while (isXDIGIT(*s));\n\n        while (isBLANK(*s)) { s++; }\n\n        /* We allow comments at the end of the line */\n        if (*s == '#') {\n            s = strchr(s, '\\n');\n            if (s == NULL) {\n                s = e;\n            }\n            s++;\n        }\n        else if (s < e && *s != '\\n') {\n            if (! isXDIGIT(*s)) {\n                goto check_if_property;\n            }\n\n            /* Look for the high point of the range */\n            max = 0;\n            do {\n                if (max > ( (IV) MAX_LEGAL_CP >> 4)) {\n                    s = strchr(s, '\\n');\n                    if (s == NULL) {\n                        s = e;\n                    }\n                    if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                    sv_catpv(msg, overflow_msg);\n                    Perl_sv_catpvf(aTHX_ msg, \"%\" UTF8f,\n                                      UTF8fARG(is_contents_utf8, s - s0, s0));\n                    sv_catpvs(msg, \"\\\"\");\n                    goto return_failure;\n                }\n\n                max = (max << 4) + READ_XDIGIT(s);\n            } while (isXDIGIT(*s));\n\n            while (isBLANK(*s)) { s++; }\n\n            if (*s == '#') {\n                s = strchr(s, '\\n');\n                if (s == NULL) {\n                    s = e;\n                }\n            }\n            else if (s < e && *s != '\\n') {\n                goto check_if_property;\n            }\n        }\n\n        if (max == -1) {    /* The line only had one entry */\n            max = min;\n        }\n        else if (max < min) {\n            if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n            sv_catpvs(msg, \"Illegal range in \\\"\");\n            Perl_sv_catpvf(aTHX_ msg, \"%\" UTF8f,\n                                UTF8fARG(is_contents_utf8, s - s0, s0));\n            sv_catpvs(msg, \"\\\"\");\n            goto return_failure;\n        }\n\n#if 0   /* See explanation at definition above of get_extended_utf8_msg() */\n\n        if (   UNICODE_IS_PERL_EXTENDED(min)\n            || UNICODE_IS_PERL_EXTENDED(max))\n        {\n            if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n\n            /* If both code points are non-portable, warn only on the lower\n             * one. */\n            sv_catpv(msg, get_extended_utf8_msg(\n                                            (UNICODE_IS_PERL_EXTENDED(min))\n                                            ? min : max));\n            sv_catpvs(msg, \" in \\\"\");\n            Perl_sv_catpvf(aTHX_ msg, \"%\" UTF8f,\n                                 UTF8fARG(is_contents_utf8, s - s0, s0));\n            sv_catpvs(msg, \"\\\"\");\n        }\n\n#endif\n\n        /* Here, this line contains a legal range */\n        this_definition = sv_2mortal(_new_invlist(2));\n        this_definition = _add_range_to_invlist(this_definition, min, max);\n        goto calculate;\n\n      check_if_property:\n\n        /* Here it isn't a legal range line.  See if it is a legal property\n         * line.  First find the end of the meat of the line */\n        s = strpbrk(s, \"#\\n\");\n        if (s == NULL) {\n            s = e;\n        }\n\n        /* Ignore trailing blanks in keeping with the requirements of\n         * parse_uniprop_string() */\n        s--;\n        while (s > s0 && isBLANK_A(*s)) {\n            s--;\n        }\n        s++;\n\n        this_definition = parse_uniprop_string(s0, s - s0,\n                                               is_utf8, to_fold, runtime,\n                                               deferrable,\n                                               user_defined_ptr, msg,\n                                               (name_len == 0)\n                                                ? level /* Don't increase level\n                                                           if input is empty */\n                                                : level + 1\n                                              );\n        if (this_definition == NULL) {\n            goto return_failure;    /* 'msg' should have had the reason\n                                       appended to it by the above call */\n        }\n\n        if (! is_invlist(this_definition)) {    /* Unknown at this time */\n            return newSVsv(this_definition);\n        }\n\n        if (*s != '\\n') {\n            s = strchr(s, '\\n');\n            if (s == NULL) {\n                s = e;\n            }\n        }\n\n      calculate:\n\n        switch (op) {\n            case '+':\n                _invlist_union(running_definition, this_definition,\n                                                        &running_definition);\n                break;\n            case '-':\n                _invlist_subtract(running_definition, this_definition,\n                                                        &running_definition);\n                break;\n            case '&':\n                _invlist_intersection(running_definition, this_definition,\n                                                        &running_definition);\n                break;\n            case '!':\n                _invlist_union_complement_2nd(running_definition,\n                                        this_definition, &running_definition);\n                break;\n            default:\n                Perl_croak(aTHX_ \"panic: %s: %d: Unexpected operation %d\",\n                                 __FILE__, __LINE__, op);\n                break;\n        }\n\n        /* Position past the '\\n' */\n        s0 = s + 1;\n    }   /* End of loop through the lines of 'contents' */\n\n    /* Here, we processed all the lines in 'contents' without error.  If we\n     * didn't add any warnings, simply return success */\n    if (msgs_length_on_entry == SvCUR(msg)) {\n\n        /* If the expansion was empty, the answer isn't nothing: its an empty\n         * inversion list */\n        if (running_definition == NULL) {\n            running_definition = _new_invlist(1);\n        }\n\n        return running_definition;\n    }\n\n    /* Otherwise, add some explanatory text, but we will return success */\n    goto return_msg;\n\n  return_failure:\n    running_definition = NULL;\n\n  return_msg:\n\n    if (name_len > 0) {\n        sv_catpvs(msg, \" in expansion of \");\n        Perl_sv_catpvf(aTHX_ msg, \"%\" UTF8f, UTF8fARG(is_utf8, name_len, name));\n    }\n\n    return running_definition;\n}\n\n/* As explained below, certain operations need to take place in the first\n * thread created.  These macros switch contexts */\n#ifdef USE_ITHREADS\n#  define DECLARATION_FOR_GLOBAL_CONTEXT                                    \\\n                                        PerlInterpreter * save_aTHX = aTHX;\n#  define SWITCH_TO_GLOBAL_CONTEXT                                          \\\n                           PERL_SET_CONTEXT((aTHX = PL_user_def_props_aTHX))\n#  define RESTORE_CONTEXT  PERL_SET_CONTEXT((aTHX = save_aTHX));\n#  define CUR_CONTEXT      aTHX\n#  define ORIGINAL_CONTEXT save_aTHX\n#else\n#  define DECLARATION_FOR_GLOBAL_CONTEXT\n#  define SWITCH_TO_GLOBAL_CONTEXT          NOOP\n#  define RESTORE_CONTEXT                   NOOP\n#  define CUR_CONTEXT                       NULL\n#  define ORIGINAL_CONTEXT                  NULL\n#endif\n\nSTATIC void\nS_delete_recursion_entry(pTHX_ void *key)\n{\n    /* Deletes the entry used to detect recursion when expanding user-defined\n     * properties.  This is a function so it can be set up to be called even if\n     * the program unexpectedly quits */\n\n    dVAR;\n    SV ** current_entry;\n    const STRLEN key_len = strlen((const char *) key);\n    DECLARATION_FOR_GLOBAL_CONTEXT;\n\n    SWITCH_TO_GLOBAL_CONTEXT;\n\n    /* If the entry is one of these types, it is a permanent entry, and not the\n     * one used to detect recursions.  This function should delete only the\n     * recursion entry */\n    current_entry = hv_fetch(PL_user_def_props, (const char *) key, key_len, 0);\n    if (     current_entry\n        && ! is_invlist(*current_entry)\n        && ! SvPOK(*current_entry))\n    {\n        (void) hv_delete(PL_user_def_props, (const char *) key, key_len,\n                                                                    G_DISCARD);\n    }\n\n    RESTORE_CONTEXT;\n}\n\nSTATIC SV *\nS_get_fq_name(pTHX_\n              const char * const name,    /* The first non-blank in the \\p{}, \\P{} */\n              const Size_t name_len,      /* Its length in bytes, not including any trailing space */\n              const bool is_utf8,         /* ? Is 'name' encoded in UTF-8 */\n              const bool has_colon_colon\n             )\n{\n    /* Returns a mortal SV containing the fully qualified version of the input\n     * name */\n\n    SV * fq_name;\n\n    fq_name = newSVpvs_flags(\"\", SVs_TEMP);\n\n    /* Use the current package if it wasn't included in our input */\n    if (! has_colon_colon) {\n        const HV * pkg = (IN_PERL_COMPILETIME)\n                         ? PL_curstash\n                         : CopSTASH(PL_curcop);\n        const char* pkgname = HvNAME(pkg);\n\n        Perl_sv_catpvf(aTHX_ fq_name, \"%\" UTF8f,\n                      UTF8fARG(is_utf8, strlen(pkgname), pkgname));\n        sv_catpvs(fq_name, \"::\");\n    }\n\n    Perl_sv_catpvf(aTHX_ fq_name, \"%\" UTF8f,\n                         UTF8fARG(is_utf8, name_len, name));\n    return fq_name;\n}\n\nSV *\nPerl_parse_uniprop_string(pTHX_\n\n    /* Parse the interior of a \\p{}, \\P{}.  Returns its definition if knowable\n     * now.  If so, the return is an inversion list.\n     *\n     * If the property is user-defined, it is a subroutine, which in turn\n     * may call other subroutines.  This function will call the whole nest of\n     * them to get the definition they return; if some aren't known at the time\n     * of the call to this function, the fully qualified name of the highest\n     * level sub is returned.  It is an error to call this function at runtime\n     * without every sub defined.\n     *\n     * If an error was found, NULL is returned, and 'msg' gets a suitable\n     * message appended to it.  (Appending allows the back trace of how we got\n     * to the faulty definition to be displayed through nested calls of\n     * user-defined subs.)\n     *\n     * The caller should NOT try to free any returned inversion list.\n     *\n     * Other parameters will be set on return as described below */\n\n    const char * const name,    /* The first non-blank in the \\p{}, \\P{} */\n    const Size_t name_len,      /* Its length in bytes, not including any\n                                   trailing space */\n    const bool is_utf8,         /* ? Is 'name' encoded in UTF-8 */\n    const bool to_fold,         /* ? Is this under /i */\n    const bool runtime,         /* TRUE if this is being called at run time */\n    const bool deferrable,      /* TRUE if it's ok for the definition to not be\n                                   known at this call */\n    bool *user_defined_ptr,     /* Upon return from this function it will be\n                                   set to TRUE if any component is a\n                                   user-defined property */\n    SV * msg,                   /* Any error or warning msg(s) are appended to\n                                   this */\n   const STRLEN level)          /* Recursion level of this call */\n{\n    dVAR;\n    char* lookup_name;          /* normalized name for lookup in our tables */\n    unsigned lookup_len;        /* Its length */\n    bool stricter = FALSE;      /* Some properties have stricter name\n                                   normalization rules, which we decide upon\n                                   based on parsing */\n\n    /* nv= or numeric_value=, or possibly one of the cjk numeric properties\n     * (though it requires extra effort to download them from Unicode and\n     * compile perl to know about them) */\n    bool is_nv_type = FALSE;\n\n    unsigned int i, j = 0;\n    int equals_pos = -1;    /* Where the '=' is found, or negative if none */\n    int slash_pos  = -1;    /* Where the '/' is found, or negative if none */\n    int table_index = 0;    /* The entry number for this property in the table\n                               of all Unicode property names */\n    bool starts_with_In_or_Is = FALSE;  /* ? Does the name start with 'In' or\n                                             'Is' */\n    Size_t lookup_offset = 0;   /* Used to ignore the first few characters of\n                                   the normalized name in certain situations */\n    Size_t non_pkg_begin = 0;   /* Offset of first byte in 'name' that isn't\n                                   part of a package name */\n    bool could_be_user_defined = TRUE;  /* ? Could this be a user-defined\n                                             property rather than a Unicode\n                                             one. */\n    SV * prop_definition = NULL;  /* The returned definition of 'name' or NULL\n                                     if an error.  If it is an inversion list,\n                                     it is the definition.  Otherwise it is a\n                                     string containing the fully qualified sub\n                                     name of 'name' */\n    SV * fq_name = NULL;        /* For user-defined properties, the fully\n                                   qualified name */\n    bool invert_return = FALSE; /* ? Do we need to complement the result before\n                                     returning it */\n\n    PERL_ARGS_ASSERT_PARSE_UNIPROP_STRING;\n\n    /* The input will be normalized into 'lookup_name' */\n    Newx(lookup_name, name_len, char);\n    SAVEFREEPV(lookup_name);\n\n    /* Parse the input. */\n    for (i = 0; i < name_len; i++) {\n        char cur = name[i];\n\n        /* Most of the characters in the input will be of this ilk, being parts\n         * of a name */\n        if (isIDCONT_A(cur)) {\n\n            /* Case differences are ignored.  Our lookup routine assumes\n             * everything is lowercase, so normalize to that */\n            if (isUPPER_A(cur)) {\n                lookup_name[j++] = toLOWER_A(cur);\n                continue;\n            }\n\n            if (cur == '_') { /* Don't include these in the normalized name */\n                continue;\n            }\n\n            lookup_name[j++] = cur;\n\n            /* The first character in a user-defined name must be of this type.\n             * */\n            if (i - non_pkg_begin == 0 && ! isIDFIRST_A(cur)) {\n                could_be_user_defined = FALSE;\n            }\n\n            continue;\n        }\n\n        /* Here, the character is not something typically in a name,  But these\n         * two types of characters (and the '_' above) can be freely ignored in\n         * most situations.  Later it may turn out we shouldn't have ignored\n         * them, and we have to reparse, but we don't have enough information\n         * yet to make that decision */\n        if (cur == '-' || isSPACE_A(cur)) {\n            could_be_user_defined = FALSE;\n            continue;\n        }\n\n        /* An equals sign or single colon mark the end of the first part of\n         * the property name */\n        if (    cur == '='\n            || (cur == ':' && (i >= name_len - 1 || name[i+1] != ':')))\n        {\n            lookup_name[j++] = '='; /* Treat the colon as an '=' */\n            equals_pos = j; /* Note where it occurred in the input */\n            could_be_user_defined = FALSE;\n            break;\n        }\n\n        /* Otherwise, this character is part of the name. */\n        lookup_name[j++] = cur;\n\n        /* Here it isn't a single colon, so if it is a colon, it must be a\n         * double colon */\n        if (cur == ':') {\n\n            /* A double colon should be a package qualifier.  We note its\n             * position and continue.  Note that one could have\n             *      pkg1::pkg2::...::foo\n             * so that the position at the end of the loop will be just after\n             * the final qualifier */\n\n            i++;\n            non_pkg_begin = i + 1;\n            lookup_name[j++] = ':';\n        }\n        else { /* Only word chars (and '::') can be in a user-defined name */\n            could_be_user_defined = FALSE;\n        }\n    } /* End of parsing through the lhs of the property name (or all of it if\n         no rhs) */\n\n#define STRLENs(s)  (sizeof(\"\" s \"\") - 1)\n\n    /* If there is a single package name 'utf8::', it is ambiguous.  It could\n     * be for a user-defined property, or it could be a Unicode property, as\n     * all of them are considered to be for that package.  For the purposes of\n     * parsing the rest of the property, strip it off */\n    if (non_pkg_begin == STRLENs(\"utf8::\") && memBEGINPs(name, name_len, \"utf8::\")) {\n        lookup_name +=  STRLENs(\"utf8::\");\n        j -=  STRLENs(\"utf8::\");\n        equals_pos -=  STRLENs(\"utf8::\");\n    }\n\n    /* Here, we are either done with the whole property name, if it was simple;\n     * or are positioned just after the '=' if it is compound. */\n\n    if (equals_pos >= 0) {\n        assert(! stricter); /* We shouldn't have set this yet */\n\n        /* Space immediately after the '=' is ignored */\n        i++;\n        for (; i < name_len; i++) {\n            if (! isSPACE_A(name[i])) {\n                break;\n            }\n        }\n\n        /* Most punctuation after the equals indicates a subpattern, like\n         * \\p{foo=/bar/} */\n        if (   isPUNCT_A(name[i])\n            && name[i] != '-'\n            && name[i] != '+'\n            && name[i] != '_'\n            && name[i] != '{')\n        {\n            /* Find the property.  The table includes the equals sign, so we\n             * use 'j' as-is */\n            table_index = match_uniprop((U8 *) lookup_name, j);\n            if (table_index) {\n                const char * const * prop_values\n                                            = UNI_prop_value_ptrs[table_index];\n                SV * subpattern;\n                Size_t subpattern_len;\n                REGEXP * subpattern_re;\n                char open = name[i++];\n                char close;\n                const char * pos_in_brackets;\n                bool escaped = 0;\n\n                /* A backslash means the real delimitter is the next character.\n                 * */\n                if (open == '\\\\') {\n                    open = name[i++];\n                    escaped = 1;\n                }\n\n                /* This data structure is constructed so that the matching\n                 * closing bracket is 3 past its matching opening.  The second\n                 * set of closing is so that if the opening is something like\n                 * ']', the closing will be that as well.  Something similar is\n                 * done in toke.c */\n                pos_in_brackets = strchr(\"([<)]>)]>\", open);\n                close = (pos_in_brackets) ? pos_in_brackets[3] : open;\n\n                if (    i >= name_len\n                    ||  name[name_len-1] != close\n                    || (escaped && name[name_len-2] != '\\\\'))\n                {\n                    sv_catpvs(msg, \"Unicode property wildcard not terminated\");\n                    goto append_name_to_msg;\n                }\n\n                Perl_ck_warner_d(aTHX_\n                    packWARN(WARN_EXPERIMENTAL__UNIPROP_WILDCARDS),\n                    \"The Unicode property wildcards feature is experimental\");\n\n                /* Now create and compile the wildcard subpattern.  Use /iaa\n                 * because nothing outside of ASCII will match, and it the\n                 * property values should all match /i.  Note that when the\n                 * pattern fails to compile, our added text to the user's\n                 * pattern will be displayed to the user, which is not so\n                 * desirable. */\n                subpattern_len = name_len - i - 1 - escaped;\n                subpattern = Perl_newSVpvf(aTHX_ \"(?iaa:%.*s)\",\n                                              (unsigned) subpattern_len,\n                                              name + i);\n                subpattern = sv_2mortal(subpattern);\n                subpattern_re = re_compile(subpattern, 0);\n                assert(subpattern_re);  /* Should have died if didn't compile\n                                         successfully */\n\n                /* For each legal property value, see if the supplied pattern\n                 * matches it. */\n                while (*prop_values) {\n                    const char * const entry = *prop_values;\n                    const Size_t len = strlen(entry);\n                    SV* entry_sv = newSVpvn_flags(entry, len, SVs_TEMP);\n\n                    if (pregexec(subpattern_re,\n                                 (char *) entry,\n                                 (char *) entry + len,\n                                 (char *) entry, 0,\n                                 entry_sv,\n                                 0))\n                    { /* Here, matched.  Add to the returned list */\n                        Size_t total_len = j + len;\n                        SV * sub_invlist = NULL;\n                        char * this_string;\n\n                        /* We know this is a legal \\p{property=value}.  Call\n                         * the function to return the list of code points that\n                         * match it */\n                        Newxz(this_string, total_len + 1, char);\n                        Copy(lookup_name, this_string, j, char);\n                        my_strlcat(this_string, entry, total_len + 1);\n                        SAVEFREEPV(this_string);\n                        sub_invlist = parse_uniprop_string(this_string,\n                                                           total_len,\n                                                           is_utf8,\n                                                           to_fold,\n                                                           runtime,\n                                                           deferrable,\n                                                           user_defined_ptr,\n                                                           msg,\n                                                           level + 1);\n                        _invlist_union(prop_definition, sub_invlist,\n                                       &prop_definition);\n                    }\n\n                    prop_values++;  /* Next iteration, look at next propvalue */\n                } /* End of looking through property values; (the data\n                     structure is terminated by a NULL ptr) */\n\n                SvREFCNT_dec_NN(subpattern_re);\n\n                if (prop_definition) {\n                    return prop_definition;\n                }\n\n                sv_catpvs(msg, \"No Unicode property value wildcard matches:\");\n                goto append_name_to_msg;\n            }\n\n            /* Here's how khw thinks we should proceed to handle the properties\n             * not yet done:    Bidi Mirroring Glyph\n                                Bidi Paired Bracket\n                                Case Folding  (both full and simple)\n                                Decomposition Mapping\n                                Equivalent Unified Ideograph\n                                Name\n                                Name Alias\n                                Lowercase Mapping  (both full and simple)\n                                NFKC Case Fold\n                                Titlecase Mapping  (both full and simple)\n                                Uppercase Mapping  (both full and simple)\n             * Move the part that looks at the property values into a perl\n             * script, like utf8_heavy.pl is done.  This makes things somewhat\n             * easier, but most importantly, it avoids always adding all these\n             * strings to the memory usage when the feature is little-used.\n             *\n             * The property values would all be concatenated into a single\n             * string per property with each value on a separate line, and the\n             * code point it's for on alternating lines.  Then we match the\n             * user's input pattern m//mg, without having to worry about their\n             * uses of '^' and '$'.  Only the values that aren't the default\n             * would be in the strings.  Code points would be in UTF-8.  The\n             * search pattern that we would construct would look like\n             * (?: \\n (code-point_re) \\n (?aam: user-re ) \\n )\n             * And so $1 would contain the code point that matched the user-re.\n             * For properties where the default is the code point itself, such\n             * as any of the case changing mappings, the string would otherwise\n             * consist of all Unicode code points in UTF-8 strung together.\n             * This would be impractical.  So instead, examine their compiled\n             * pattern, looking at the ssc.  If none, reject the pattern as an\n             * error.  Otherwise run the pattern against every code point in\n             * the ssc.  The ssc is kind of like tr18's 3.9 Possible Match Sets\n             * And it might be good to create an API to return the ssc.\n             *\n             * For the name properties, a new function could be created in\n             * charnames which essentially does the same thing as above,\n             * sharing Name.pl with the other charname functions.  Don't know\n             * about loose name matching, or algorithmically determined names.\n             * Decomposition.pl similarly.\n             *\n             * It might be that a new pattern modifier would have to be\n             * created, like /t for resTricTed, which changed the behavior of\n             * some constructs in their subpattern, like \\A. */\n        } /* End of is a wildcard subppattern */\n\n\n        /* Certain properties whose values are numeric need special handling.\n         * They may optionally be prefixed by 'is'.  Ignore that prefix for the\n         * purposes of checking if this is one of those properties */\n        if (memBEGINPs(lookup_name, j, \"is\")) {\n            lookup_offset = 2;\n        }\n\n        /* Then check if it is one of these specially-handled properties.  The\n         * possibilities are hard-coded because easier this way, and the list\n         * is unlikely to change.\n         *\n         * All numeric value type properties are of this ilk, and are also\n         * special in a different way later on.  So find those first.  There\n         * are several numeric value type properties in the Unihan DB (which is\n         * unlikely to be compiled with perl, but we handle it here in case it\n         * does get compiled).  They all end with 'numeric'.  The interiors\n         * aren't checked for the precise property.  This would stop working if\n         * a cjk property were to be created that ended with 'numeric' and\n         * wasn't a numeric type */\n        is_nv_type = memEQs(lookup_name + lookup_offset,\n                       j - 1 - lookup_offset, \"numericvalue\")\n                  || memEQs(lookup_name + lookup_offset,\n                      j - 1 - lookup_offset, \"nv\")\n                  || (   memENDPs(lookup_name + lookup_offset,\n                            j - 1 - lookup_offset, \"numeric\")\n                      && (   memBEGINPs(lookup_name + lookup_offset,\n                                      j - 1 - lookup_offset, \"cjk\")\n                          || memBEGINPs(lookup_name + lookup_offset,\n                                      j - 1 - lookup_offset, \"k\")));\n        if (   is_nv_type\n            || memEQs(lookup_name + lookup_offset,\n                      j - 1 - lookup_offset, \"canonicalcombiningclass\")\n            || memEQs(lookup_name + lookup_offset,\n                      j - 1 - lookup_offset, \"ccc\")\n            || memEQs(lookup_name + lookup_offset,\n                      j - 1 - lookup_offset, \"age\")\n            || memEQs(lookup_name + lookup_offset,\n                      j - 1 - lookup_offset, \"in\")\n            || memEQs(lookup_name + lookup_offset,\n                      j - 1 - lookup_offset, \"presentin\"))\n        {\n            unsigned int k;\n\n            /* Since the stuff after the '=' is a number, we can't throw away\n             * '-' willy-nilly, as those could be a minus sign.  Other stricter\n             * rules also apply.  However, these properties all can have the\n             * rhs not be a number, in which case they contain at least one\n             * alphabetic.  In those cases, the stricter rules don't apply.\n             * But the numeric type properties can have the alphas [Ee] to\n             * signify an exponent, and it is still a number with stricter\n             * rules.  So look for an alpha that signifies not-strict */\n            stricter = TRUE;\n            for (k = i; k < name_len; k++) {\n                if (   isALPHA_A(name[k])\n                    && (! is_nv_type || ! isALPHA_FOLD_EQ(name[k], 'E')))\n                {\n                    stricter = FALSE;\n                    break;\n                }\n            }\n        }\n\n        if (stricter) {\n\n            /* A number may have a leading '+' or '-'.  The latter is retained\n             * */\n            if (name[i] == '+') {\n                i++;\n            }\n            else if (name[i] == '-') {\n                lookup_name[j++] = '-';\n                i++;\n            }\n\n            /* Skip leading zeros including single underscores separating the\n             * zeros, or between the final leading zero and the first other\n             * digit */\n            for (; i < name_len - 1; i++) {\n                if (    name[i] != '0'\n                    && (name[i] != '_' || ! isDIGIT_A(name[i+1])))\n                {\n                    break;\n                }\n            }\n        }\n    }\n    else {  /* No '=' */\n\n       /* Only a few properties without an '=' should be parsed with stricter\n        * rules.  The list is unlikely to change. */\n        if (   memBEGINPs(lookup_name, j, \"perl\")\n            && memNEs(lookup_name + 4, j - 4, \"space\")\n            && memNEs(lookup_name + 4, j - 4, \"word\"))\n        {\n            stricter = TRUE;\n\n            /* We set the inputs back to 0 and the code below will reparse,\n             * using strict */\n            i = j = 0;\n        }\n    }\n\n    /* Here, we have either finished the property, or are positioned to parse\n     * the remainder, and we know if stricter rules apply.  Finish out, if not\n     * already done */\n    for (; i < name_len; i++) {\n        char cur = name[i];\n\n        /* In all instances, case differences are ignored, and we normalize to\n         * lowercase */\n        if (isUPPER_A(cur)) {\n            lookup_name[j++] = toLOWER(cur);\n            continue;\n        }\n\n        /* An underscore is skipped, but not under strict rules unless it\n         * separates two digits */\n        if (cur == '_') {\n            if (    stricter\n                && (     i == 0 || (int) i == equals_pos || i == name_len- 1\n                    || ! isDIGIT_A(name[i-1]) || ! isDIGIT_A(name[i+1])))\n            {\n                lookup_name[j++] = '_';\n            }\n            continue;\n        }\n\n        /* Hyphens are skipped except under strict */\n        if (cur == '-' && ! stricter) {\n            continue;\n        }\n\n        /* XXX Bug in documentation.  It says white space skipped adjacent to\n         * non-word char.  Maybe we should, but shouldn't skip it next to a dot\n         * in a number */\n        if (isSPACE_A(cur) && ! stricter) {\n            continue;\n        }\n\n        lookup_name[j++] = cur;\n\n        /* Unless this is a non-trailing slash, we are done with it */\n        if (i >= name_len - 1 || cur != '/') {\n            continue;\n        }\n\n        slash_pos = j;\n\n        /* A slash in the 'numeric value' property indicates that what follows\n         * is a denominator.  It can have a leading '+' and '0's that should be\n         * skipped.  But we have never allowed a negative denominator, so treat\n         * a minus like every other character.  (No need to rule out a second\n         * '/', as that won't match anything anyway */\n        if (is_nv_type) {\n            i++;\n            if (i < name_len && name[i] == '+') {\n                i++;\n            }\n\n            /* Skip leading zeros including underscores separating digits */\n            for (; i < name_len - 1; i++) {\n                if (   name[i] != '0'\n                    && (name[i] != '_' || ! isDIGIT_A(name[i+1])))\n                {\n                    break;\n                }\n            }\n\n            /* Store the first real character in the denominator */\n            lookup_name[j++] = name[i];\n        }\n    }\n\n    /* Here are completely done parsing the input 'name', and 'lookup_name'\n     * contains a copy, normalized.\n     *\n     * This special case is grandfathered in: 'L_' and 'GC=L_' are accepted and\n     * different from without the underscores.  */\n    if (  (   UNLIKELY(memEQs(lookup_name, j, \"l\"))\n           || UNLIKELY(memEQs(lookup_name, j, \"gc=l\")))\n        && UNLIKELY(name[name_len-1] == '_'))\n    {\n        lookup_name[j++] = '&';\n    }\n\n    /* If the original input began with 'In' or 'Is', it could be a subroutine\n     * call to a user-defined property instead of a Unicode property name. */\n    if (    non_pkg_begin + name_len > 2\n        &&  name[non_pkg_begin+0] == 'I'\n        && (name[non_pkg_begin+1] == 'n' || name[non_pkg_begin+1] == 's'))\n    {\n        starts_with_In_or_Is = TRUE;\n    }\n    else {\n        could_be_user_defined = FALSE;\n    }\n\n    if (could_be_user_defined) {\n        CV* user_sub;\n\n        /* If the user defined property returns the empty string, it could\n         * easily be because the pattern is being compiled before the data it\n         * actually needs to compile is available.  This could be argued to be\n         * a bug in the perl code, but this is a change of behavior for Perl,\n         * so we handle it.  This means that intentionally returning nothing\n         * will not be resolved until runtime */\n        bool empty_return = FALSE;\n\n        /* Here, the name could be for a user defined property, which are\n         * implemented as subs. */\n        user_sub = get_cvn_flags(name, name_len, 0);\n        if (user_sub) {\n            const char insecure[] = \"Insecure user-defined property\";\n\n            /* Here, there is a sub by the correct name.  Normally we call it\n             * to get the property definition */\n            dSP;\n            SV * user_sub_sv = MUTABLE_SV(user_sub);\n            SV * error;     /* Any error returned by calling 'user_sub' */\n            SV * key;       /* The key into the hash of user defined sub names\n                             */\n            SV * placeholder;\n            SV ** saved_user_prop_ptr;      /* Hash entry for this property */\n\n            /* How many times to retry when another thread is in the middle of\n             * expanding the same definition we want */\n            PERL_INT_FAST8_T retry_countdown = 10;\n\n            DECLARATION_FOR_GLOBAL_CONTEXT;\n\n            /* If we get here, we know this property is user-defined */\n            *user_defined_ptr = TRUE;\n\n            /* We refuse to call a potentially tainted subroutine; returning an\n             * error instead */\n            if (TAINT_get) {\n                if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                sv_catpvn(msg, insecure, sizeof(insecure) - 1);\n                goto append_name_to_msg;\n            }\n\n            /* In principal, we only call each subroutine property definition\n             * once during the life of the program.  This guarantees that the\n             * property definition never changes.  The results of the single\n             * sub call are stored in a hash, which is used instead for future\n             * references to this property.  The property definition is thus\n             * immutable.  But, to allow the user to have a /i-dependent\n             * definition, we call the sub once for non-/i, and once for /i,\n             * should the need arise, passing the /i status as a parameter.\n             *\n             * We start by constructing the hash key name, consisting of the\n             * fully qualified subroutine name, preceded by the /i status, so\n             * that there is a key for /i and a different key for non-/i */\n            key = newSVpvn(((to_fold) ? \"1\" : \"0\"), 1);\n            fq_name = S_get_fq_name(aTHX_ name, name_len, is_utf8,\n                                          non_pkg_begin != 0);\n            sv_catsv(key, fq_name);\n            sv_2mortal(key);\n\n            /* We only call the sub once throughout the life of the program\n             * (with the /i, non-/i exception noted above).  That means the\n             * hash must be global and accessible to all threads.  It is\n             * created at program start-up, before any threads are created, so\n             * is accessible to all children.  But this creates some\n             * complications.\n             *\n             * 1) The keys can't be shared, or else problems arise; sharing is\n             *    turned off at hash creation time\n             * 2) All SVs in it are there for the remainder of the life of the\n             *    program, and must be created in the same interpreter context\n             *    as the hash, or else they will be freed from the wrong pool\n             *    at global destruction time.  This is handled by switching to\n             *    the hash's context to create each SV going into it, and then\n             *    immediately switching back\n             * 3) All accesses to the hash must be controlled by a mutex, to\n             *    prevent two threads from getting an unstable state should\n             *    they simultaneously be accessing it.  The code below is\n             *    crafted so that the mutex is locked whenever there is an\n             *    access and unlocked only when the next stable state is\n             *    achieved.\n             *\n             * The hash stores either the definition of the property if it was\n             * valid, or, if invalid, the error message that was raised.  We\n             * use the type of SV to distinguish.\n             *\n             * There's also the need to guard against the definition expansion\n             * from infinitely recursing.  This is handled by storing the aTHX\n             * of the expanding thread during the expansion.  Again the SV type\n             * is used to distinguish this from the other two cases.  If we\n             * come to here and the hash entry for this property is our aTHX,\n             * it means we have recursed, and the code assumes that we would\n             * infinitely recurse, so instead stops and raises an error.\n             * (Any recursion has always been treated as infinite recursion in\n             * this feature.)\n             *\n             * If instead, the entry is for a different aTHX, it means that\n             * that thread has gotten here first, and hasn't finished expanding\n             * the definition yet.  We just have to wait until it is done.  We\n             * sleep and retry a few times, returning an error if the other\n             * thread doesn't complete. */\n\n          re_fetch:\n            USER_PROP_MUTEX_LOCK;\n\n            /* If we have an entry for this key, the subroutine has already\n             * been called once with this /i status. */\n            saved_user_prop_ptr = hv_fetch(PL_user_def_props,\n                                                   SvPVX(key), SvCUR(key), 0);\n            if (saved_user_prop_ptr) {\n\n                /* If the saved result is an inversion list, it is the valid\n                 * definition of this property */\n                if (is_invlist(*saved_user_prop_ptr)) {\n                    prop_definition = *saved_user_prop_ptr;\n\n                    /* The SV in the hash won't be removed until global\n                     * destruction, so it is stable and we can unlock */\n                    USER_PROP_MUTEX_UNLOCK;\n\n                    /* The caller shouldn't try to free this SV */\n                    return prop_definition;\n                }\n\n                /* Otherwise, if it is a string, it is the error message\n                 * that was returned when we first tried to evaluate this\n                 * property.  Fail, and append the message */\n                if (SvPOK(*saved_user_prop_ptr)) {\n                    if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                    sv_catsv(msg, *saved_user_prop_ptr);\n\n                    /* The SV in the hash won't be removed until global\n                     * destruction, so it is stable and we can unlock */\n                    USER_PROP_MUTEX_UNLOCK;\n\n                    return NULL;\n                }\n\n                assert(SvIOK(*saved_user_prop_ptr));\n\n                /* Here, we have an unstable entry in the hash.  Either another\n                 * thread is in the middle of expanding the property's\n                 * definition, or we are ourselves recursing.  We use the aTHX\n                 * in it to distinguish */\n                if (SvIV(*saved_user_prop_ptr) != PTR2IV(CUR_CONTEXT)) {\n\n                    /* Here, it's another thread doing the expanding.  We've\n                     * looked as much as we are going to at the contents of the\n                     * hash entry.  It's safe to unlock. */\n                    USER_PROP_MUTEX_UNLOCK;\n\n                    /* Retry a few times */\n                    if (retry_countdown-- > 0) {\n                        PerlProc_sleep(1);\n                        goto re_fetch;\n                    }\n\n                    if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                    sv_catpvs(msg, \"Timeout waiting for another thread to \"\n                                   \"define\");\n                    goto append_name_to_msg;\n                }\n\n                /* Here, we are recursing; don't dig any deeper */\n                USER_PROP_MUTEX_UNLOCK;\n\n                if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                sv_catpvs(msg,\n                          \"Infinite recursion in user-defined property\");\n                goto append_name_to_msg;\n            }\n\n            /* Here, this thread has exclusive control, and there is no entry\n             * for this property in the hash.  So we have the go ahead to\n             * expand the definition ourselves. */\n\n            PUSHSTACKi(PERLSI_MAGIC);\n            ENTER;\n\n            /* Create a temporary placeholder in the hash to detect recursion\n             * */\n            SWITCH_TO_GLOBAL_CONTEXT;\n            placeholder= newSVuv(PTR2IV(ORIGINAL_CONTEXT));\n            (void) hv_store_ent(PL_user_def_props, key, placeholder, 0);\n            RESTORE_CONTEXT;\n\n            /* Now that we have a placeholder, we can let other threads\n             * continue */\n            USER_PROP_MUTEX_UNLOCK;\n\n            /* Make sure the placeholder always gets destroyed */\n            SAVEDESTRUCTOR_X(S_delete_recursion_entry, SvPVX(key));\n\n            PUSHMARK(SP);\n            SAVETMPS;\n\n            /* Call the user's function, with the /i status as a parameter.\n             * Note that we have gone to a lot of trouble to keep this call\n             * from being within the locked mutex region. */\n            XPUSHs(boolSV(to_fold));\n            PUTBACK;\n\n            /* The following block was taken from swash_init().  Presumably\n             * they apply to here as well, though we no longer use a swash --\n             * khw */\n            SAVEHINTS();\n            save_re_context();\n            /* We might get here via a subroutine signature which uses a utf8\n             * parameter name, at which point PL_subname will have been set\n             * but not yet used. */\n            save_item(PL_subname);\n\n            (void) call_sv(user_sub_sv, G_EVAL|G_SCALAR);\n\n            SPAGAIN;\n\n            error = ERRSV;\n            if (TAINT_get || SvTRUE(error)) {\n                if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                if (SvTRUE(error)) {\n                    sv_catpvs(msg, \"Error \\\"\");\n                    sv_catsv(msg, error);\n                    sv_catpvs(msg, \"\\\"\");\n                }\n                if (TAINT_get) {\n                    if (SvTRUE(error)) sv_catpvs(msg, \"; \");\n                    sv_catpvn(msg, insecure, sizeof(insecure) - 1);\n                }\n\n                if (name_len > 0) {\n                    sv_catpvs(msg, \" in expansion of \");\n                    Perl_sv_catpvf(aTHX_ msg, \"%\" UTF8f, UTF8fARG(is_utf8,\n                                                                  name_len,\n                                                                  name));\n                }\n\n                (void) POPs;\n                prop_definition = NULL;\n            }\n            else {  /* G_SCALAR guarantees a single return value */\n                SV * contents = POPs;\n\n                /* The contents is supposed to be the expansion of the property\n                 * definition.  If the definition is deferrable, and we got an\n                 * empty string back, set a flag to later defer it (after clean\n                 * up below). */\n                if (      deferrable\n                    && (! SvPOK(contents) || SvCUR(contents) == 0))\n                {\n                        empty_return = TRUE;\n                }\n                else { /* Otherwise, call a function to check for valid syntax,\n                          and handle it */\n\n                    prop_definition = handle_user_defined_property(\n                                                    name, name_len,\n                                                    is_utf8, to_fold, runtime,\n                                                    deferrable,\n                                                    contents, user_defined_ptr,\n                                                    msg,\n                                                    level);\n                }\n            }\n\n            /* Here, we have the results of the expansion.  Delete the\n             * placeholder, and if the definition is now known, replace it with\n             * that definition.  We need exclusive access to the hash, and we\n             * can't let anyone else in, between when we delete the placeholder\n             * and add the permanent entry */\n            USER_PROP_MUTEX_LOCK;\n\n            S_delete_recursion_entry(aTHX_ SvPVX(key));\n\n            if (    ! empty_return\n                && (! prop_definition || is_invlist(prop_definition)))\n            {\n                /* If we got success we use the inversion list defining the\n                 * property; otherwise use the error message */\n                SWITCH_TO_GLOBAL_CONTEXT;\n                (void) hv_store_ent(PL_user_def_props,\n                                    key,\n                                    ((prop_definition)\n                                     ? newSVsv(prop_definition)\n                                     : newSVsv(msg)),\n                                    0);\n                RESTORE_CONTEXT;\n            }\n\n            /* All done, and the hash now has a permanent entry for this\n             * property.  Give up exclusive control */\n            USER_PROP_MUTEX_UNLOCK;\n\n            FREETMPS;\n            LEAVE;\n            POPSTACK;\n\n            if (empty_return) {\n                goto definition_deferred;\n            }\n\n            if (prop_definition) {\n\n                /* If the definition is for something not known at this time,\n                 * we toss it, and go return the main property name, as that's\n                 * the one the user will be aware of */\n                if (! is_invlist(prop_definition)) {\n                    SvREFCNT_dec_NN(prop_definition);\n                    goto definition_deferred;\n                }\n\n                sv_2mortal(prop_definition);\n            }\n\n            /* And return */\n            return prop_definition;\n\n        }   /* End of calling the subroutine for the user-defined property */\n    }       /* End of it could be a user-defined property */\n\n    /* Here it wasn't a user-defined property that is known at this time.  See\n     * if it is a Unicode property */\n\n    lookup_len = j;     /* This is a more mnemonic name than 'j' */\n\n    /* Get the index into our pointer table of the inversion list corresponding\n     * to the property */\n    table_index = match_uniprop((U8 *) lookup_name, lookup_len);\n\n    /* If it didn't find the property ... */\n    if (table_index == 0) {\n\n        /* Try again stripping off any initial 'In' or 'Is' */\n        if (starts_with_In_or_Is) {\n            lookup_name += 2;\n            lookup_len -= 2;\n            equals_pos -= 2;\n            slash_pos -= 2;\n\n            table_index = match_uniprop((U8 *) lookup_name, lookup_len);\n        }\n\n        if (table_index == 0) {\n            char * canonical;\n\n            /* Here, we didn't find it.  If not a numeric type property, and\n             * can't be a user-defined one, it isn't a legal property */\n            if (! is_nv_type) {\n                if (! could_be_user_defined) {\n                    goto failed;\n                }\n\n                /* Here, the property name is legal as a user-defined one.   At\n                 * compile time, it might just be that the subroutine for that\n                 * property hasn't been encountered yet, but at runtime, it's\n                 * an error to try to use an undefined one */\n                if (! deferrable) {\n                    if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                    sv_catpvs(msg, \"Unknown user-defined property name\");\n                    goto append_name_to_msg;\n                }\n\n                goto definition_deferred;\n            } /* End of isn't a numeric type property */\n\n            /* The numeric type properties need more work to decide.  What we\n             * do is make sure we have the number in canonical form and look\n             * that up. */\n\n            if (slash_pos < 0) {    /* No slash */\n\n                /* When it isn't a rational, take the input, convert it to a\n                 * NV, then create a canonical string representation of that\n                 * NV. */\n\n                NV value;\n                SSize_t value_len = lookup_len - equals_pos;\n\n                /* Get the value */\n                if (   value_len <= 0\n                    || my_atof3(lookup_name + equals_pos, &value,\n                                value_len)\n                          != lookup_name + lookup_len)\n                {\n                    goto failed;\n                }\n\n                /* If the value is an integer, the canonical value is integral\n                 * */\n                if (Perl_ceil(value) == value) {\n                    canonical = Perl_form(aTHX_ \"%.*s%.0\" NVff,\n                                            equals_pos, lookup_name, value);\n                }\n                else {  /* Otherwise, it is %e with a known precision */\n                    char * exp_ptr;\n\n                    canonical = Perl_form(aTHX_ \"%.*s%.*\" NVef,\n                                                equals_pos, lookup_name,\n                                                PL_E_FORMAT_PRECISION, value);\n\n                    /* The exponent generated is expecting two digits, whereas\n                     * %e on some systems will generate three.  Remove leading\n                     * zeros in excess of 2 from the exponent.  We start\n                     * looking for them after the '=' */\n                    exp_ptr = strchr(canonical + equals_pos, 'e');\n                    if (exp_ptr) {\n                        char * cur_ptr = exp_ptr + 2; /* past the 'e[+-]' */\n                        SSize_t excess_exponent_len = strlen(cur_ptr) - 2;\n\n                        assert(*(cur_ptr - 1) == '-' || *(cur_ptr - 1) == '+');\n\n                        if (excess_exponent_len > 0) {\n                            SSize_t leading_zeros = strspn(cur_ptr, \"0\");\n                            SSize_t excess_leading_zeros\n                                    = MIN(leading_zeros, excess_exponent_len);\n                            if (excess_leading_zeros > 0) {\n                                Move(cur_ptr + excess_leading_zeros,\n                                     cur_ptr,\n                                     strlen(cur_ptr) - excess_leading_zeros\n                                       + 1,  /* Copy the NUL as well */\n                                     char);\n                            }\n                        }\n                    }\n                }\n            }\n            else {  /* Has a slash.  Create a rational in canonical form  */\n                UV numerator, denominator, gcd, trial;\n                const char * end_ptr;\n                const char * sign = \"\";\n\n                /* We can't just find the numerator, denominator, and do the\n                 * division, then use the method above, because that is\n                 * inexact.  And the input could be a rational that is within\n                 * epsilon (given our precision) of a valid rational, and would\n                 * then incorrectly compare valid.\n                 *\n                 * We're only interested in the part after the '=' */\n                const char * this_lookup_name = lookup_name + equals_pos;\n                lookup_len -= equals_pos;\n                slash_pos -= equals_pos;\n\n                /* Handle any leading minus */\n                if (this_lookup_name[0] == '-') {\n                    sign = \"-\";\n                    this_lookup_name++;\n                    lookup_len--;\n                    slash_pos--;\n                }\n\n                /* Convert the numerator to numeric */\n                end_ptr = this_lookup_name + slash_pos;\n                if (! grok_atoUV(this_lookup_name, &numerator, &end_ptr)) {\n                    goto failed;\n                }\n\n                /* It better have included all characters before the slash */\n                if (*end_ptr != '/') {\n                    goto failed;\n                }\n\n                /* Set to look at just the denominator */\n                this_lookup_name += slash_pos;\n                lookup_len -= slash_pos;\n                end_ptr = this_lookup_name + lookup_len;\n\n                /* Convert the denominator to numeric */\n                if (! grok_atoUV(this_lookup_name, &denominator, &end_ptr)) {\n                    goto failed;\n                }\n\n                /* It better be the rest of the characters, and don't divide by\n                 * 0 */\n                if (   end_ptr != this_lookup_name + lookup_len\n                    || denominator == 0)\n                {\n                    goto failed;\n                }\n\n                /* Get the greatest common denominator using\n                   http://en.wikipedia.org/wiki/Euclidean_algorithm */\n                gcd = numerator;\n                trial = denominator;\n                while (trial != 0) {\n                    UV temp = trial;\n                    trial = gcd % trial;\n                    gcd = temp;\n                }\n\n                /* If already in lowest possible terms, we have already tried\n                 * looking this up */\n                if (gcd == 1) {\n                    goto failed;\n                }\n\n                /* Reduce the rational, which should put it in canonical form\n                 * */\n                numerator /= gcd;\n                denominator /= gcd;\n\n                canonical = Perl_form(aTHX_ \"%.*s%s%\" UVuf \"/%\" UVuf,\n                        equals_pos, lookup_name, sign, numerator, denominator);\n            }\n\n            /* Here, we have the number in canonical form.  Try that */\n            table_index = match_uniprop((U8 *) canonical, strlen(canonical));\n            if (table_index == 0) {\n                goto failed;\n            }\n        }   /* End of still didn't find the property in our table */\n    }       /* End of       didn't find the property in our table */\n\n    /* Here, we have a non-zero return, which is an index into a table of ptrs.\n     * A negative return signifies that the real index is the absolute value,\n     * but the result needs to be inverted */\n    if (table_index < 0) {\n        invert_return = TRUE;\n        table_index = -table_index;\n    }\n\n    /* Out-of band indices indicate a deprecated property.  The proper index is\n     * modulo it with the table size.  And dividing by the table size yields\n     * an offset into a table constructed by regen/mk_invlists.pl to contain\n     * the corresponding warning message */\n    if (table_index > MAX_UNI_KEYWORD_INDEX) {\n        Size_t warning_offset = table_index / MAX_UNI_KEYWORD_INDEX;\n        table_index %= MAX_UNI_KEYWORD_INDEX;\n        Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),\n                \"Use of '%.*s' in \\\\p{} or \\\\P{} is deprecated because: %s\",\n                (int) name_len, name, deprecated_property_msgs[warning_offset]);\n    }\n\n    /* In a few properties, a different property is used under /i.  These are\n     * unlikely to change, so are hard-coded here. */\n    if (to_fold) {\n        if (   table_index == UNI_XPOSIXUPPER\n            || table_index == UNI_XPOSIXLOWER\n            || table_index == UNI_TITLE)\n        {\n            table_index = UNI_CASED;\n        }\n        else if (   table_index == UNI_UPPERCASELETTER\n                 || table_index == UNI_LOWERCASELETTER\n#  ifdef UNI_TITLECASELETTER   /* Missing from early Unicodes */\n                 || table_index == UNI_TITLECASELETTER\n#  endif\n        ) {\n            table_index = UNI_CASEDLETTER;\n        }\n        else if (  table_index == UNI_POSIXUPPER\n                || table_index == UNI_POSIXLOWER)\n        {\n            table_index = UNI_POSIXALPHA;\n        }\n    }\n\n    /* Create and return the inversion list */\n    prop_definition =_new_invlist_C_array(uni_prop_ptrs[table_index]);\n    sv_2mortal(prop_definition);\n\n\n    /* See if there is a private use override to add to this definition */\n    {\n        COPHH * hinthash = (IN_PERL_COMPILETIME)\n                           ? CopHINTHASH_get(&PL_compiling)\n                           : CopHINTHASH_get(PL_curcop);\n\tSV * pu_overrides = cophh_fetch_pv(hinthash, \"private_use\", 0, 0);\n\n        if (UNLIKELY(pu_overrides && SvPOK(pu_overrides))) {\n\n            /* See if there is an element in the hints hash for this table */\n            SV * pu_lookup = Perl_newSVpvf(aTHX_ \"%d=\", table_index);\n            const char * pos = strstr(SvPVX(pu_overrides), SvPVX(pu_lookup));\n\n            if (pos) {\n                bool dummy;\n                SV * pu_definition;\n                SV * pu_invlist;\n                SV * expanded_prop_definition =\n                            sv_2mortal(invlist_clone(prop_definition, NULL));\n\n                /* If so, it's definition is the string from here to the next\n                 * \\a character.  And its format is the same as a user-defined\n                 * property */\n                pos += SvCUR(pu_lookup);\n                pu_definition = newSVpvn(pos, strchr(pos, '\\a') - pos);\n                pu_invlist = handle_user_defined_property(lookup_name,\n                                                          lookup_len,\n                                                          0, /* Not UTF-8 */\n                                                          0, /* Not folded */\n                                                          runtime,\n                                                          deferrable,\n                                                          pu_definition,\n                                                          &dummy,\n                                                          msg,\n                                                          level);\n                if (TAINT_get) {\n                    if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n                    sv_catpvs(msg, \"Insecure private-use override\");\n                    goto append_name_to_msg;\n                }\n\n                /* For now, as a safety measure, make sure that it doesn't\n                 * override non-private use code points */\n                _invlist_intersection(pu_invlist, PL_Private_Use, &pu_invlist);\n\n                /* Add it to the list to be returned */\n                _invlist_union(prop_definition, pu_invlist,\n                               &expanded_prop_definition);\n                prop_definition = expanded_prop_definition;\n                Perl_ck_warner_d(aTHX_ packWARN(WARN_EXPERIMENTAL__PRIVATE_USE), \"The private_use feature is experimental\");\n            }\n        }\n    }\n\n    if (invert_return) {\n        _invlist_invert(prop_definition);\n    }\n    return prop_definition;\n\n\n  failed:\n    if (non_pkg_begin != 0) {\n        if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n        sv_catpvs(msg, \"Illegal user-defined property name\");\n    }\n    else {\n        if (SvCUR(msg) > 0) sv_catpvs(msg, \"; \");\n        sv_catpvs(msg, \"Can't find Unicode property definition\");\n    }\n    /* FALLTHROUGH */\n\n  append_name_to_msg:\n    {\n        const char * prefix = (runtime && level == 0) ?  \" \\\\p{\" : \" \\\"\";\n        const char * suffix = (runtime && level == 0) ?  \"}\" : \"\\\"\";\n\n        sv_catpv(msg, prefix);\n        Perl_sv_catpvf(aTHX_ msg, \"%\" UTF8f, UTF8fARG(is_utf8, name_len, name));\n        sv_catpv(msg, suffix);\n    }\n\n    return NULL;\n\n  definition_deferred:\n\n    /* Here it could yet to be defined, so defer evaluation of this\n     * until its needed at runtime.  We need the fully qualified property name\n     * to avoid ambiguity, and a trailing newline */\n    if (! fq_name) {\n        fq_name = S_get_fq_name(aTHX_ name, name_len, is_utf8,\n                                      non_pkg_begin != 0 /* If has \"::\" */\n                               );\n    }\n    sv_catpvs(fq_name, \"\\n\");\n\n    *user_defined_ptr = TRUE;\n    return fq_name;\n}\n\n#endif\n\n/*\n * ex: set ts=8 sts=4 sw=4 et:\n */\n", "#!./perl\n#\n# This is a home for regular expression tests that don't fit into\n# the format supported by re/regexp.t.  If you want to add a test\n# that does fit that format, add it to re/re_tests, not here.\n\nuse strict;\nuse warnings;\nno warnings 'experimental::vlb';\nuse 5.010;\n\nsub run_tests;\n\n$| = 1;\n\n\nBEGIN {\n    chdir 't' if -d 't';\n    require Config; import Config;\n    require './test.pl'; require './charset_tools.pl';\n    require './loc_tools.pl';\n    set_up_inc('../lib', '.', '../ext/re');\n}\n\nskip_all('no re module') unless defined &DynaLoader::boot_DynaLoader;\nskip_all_without_unicode_tables();\n\nplan tests => 873;  # Update this when adding/deleting tests.\n\nrun_tests() unless caller;\n\n#\n# Tests start here.\n#\nsub run_tests {\n    my $sharp_s = uni_to_native(\"\\xdf\");\n\n    {\n        my $x = \"abc\\ndef\\n\";\n\t(my $x_pretty = $x) =~ s/\\n/\\\\n/g;\n\n        ok $x =~ /^abc/,  qq [\"$x_pretty\" =~ /^abc/];\n        ok $x !~ /^def/,  qq [\"$x_pretty\" !~ /^def/];\n\n        # used to be a test for $*\n        ok $x =~ /^def/m, qq [\"$x_pretty\" =~ /^def/m];\n\n        ok(!($x =~ /^xxx/), qq [\"$x_pretty\" =~ /^xxx/]);\n        ok(!($x !~ /^abc/), qq [\"$x_pretty\" !~ /^abc/]);\n\n         ok $x =~ /def/, qq [\"$x_pretty\" =~ /def/];\n        ok(!($x !~ /def/), qq [\"$x_pretty\" !~ /def/]);\n\n         ok $x !~ /.def/, qq [\"$x_pretty\" !~ /.def/];\n        ok(!($x =~ /.def/), qq [\"$x_pretty\" =~ /.def/]);\n\n         ok $x =~ /\\ndef/, qq [\"$x_pretty\" =~ /\\\\ndef/];\n        ok(!($x !~ /\\ndef/), qq [\"$x_pretty\" !~ /\\\\ndef/]);\n    }\n\n    {\n        $_ = '123';\n        ok /^([0-9][0-9]*)/, qq [\\$_ = '$_'; /^([0-9][0-9]*)/];\n    }\n\n    {\n        $_ = 'aaabbbccc';\n         ok /(a*b*)(c*)/ && $1 eq 'aaabbb' && $2 eq 'ccc',\n                                             qq [\\$_ = '$_'; /(a*b*)(c*)/];\n         ok /(a+b+c+)/ && $1 eq 'aaabbbccc', qq [\\$_ = '$_'; /(a+b+c+)/];\n        unlike($_, qr/a+b?c+/, qq [\\$_ = '$_'; /a+b?c+/]);\n\n        $_ = 'aaabccc';\n         ok /a+b?c+/, qq [\\$_ = '$_'; /a+b?c+/];\n         ok /a*b?c*/, qq [\\$_ = '$_'; /a*b?c*/];\n\n        $_ = 'aaaccc';\n         ok /a*b?c*/, qq [\\$_ = '$_'; /a*b?c*/];\n        unlike($_, qr/a*b+c*/, qq [\\$_ = '$_'; /a*b+c*/]);\n\n        $_ = 'abcdef';\n         ok /bcd|xyz/, qq [\\$_ = '$_'; /bcd|xyz/];\n         ok /xyz|bcd/, qq [\\$_ = '$_'; /xyz|bcd/];\n         ok m|bc/*d|,  qq [\\$_ = '$_'; m|bc/*d|];\n         ok /^$_$/,    qq [\\$_ = '$_'; /^\\$_\\$/];\n    }\n\n    {\n        # used to be a test for $*\n        ok \"ab\\ncd\\n\" =~ /^cd/m, q [\"ab\\ncd\\n\" =~ /^cd/m];\n    }\n\n    {\n        our %XXX = map {($_ => $_)} 123, 234, 345;\n\n        our @XXX = ('ok 1','not ok 1', 'ok 2','not ok 2','not ok 3');\n        while ($_ = shift(@XXX)) {\n            my $e = index ($_, 'not') >= 0 ? '' : 1;\n            my $r = m?(.*)?;\n            is($r, $e, \"?(.*)?\");\n            /not/ && reset;\n            if (/not ok 2/) {\n                if ($^O eq 'VMS') {\n                    $_ = shift(@XXX);\n                }\n                else {\n                    reset 'X';\n                }\n            }\n        }\n\n        SKIP: {\n            if ($^O eq 'VMS') {\n                skip \"Reset 'X'\", 1;\n            }\n            ok !keys %XXX, \"%XXX is empty\";\n        }\n\n    }\n\n    {\n        my $message = \"Test empty pattern\";\n        my $xyz = 'xyz';\n        my $cde = 'cde';\n\n        $cde =~ /[^ab]*/;\n        $xyz =~ //;\n        is($&, $xyz, $message);\n\n        my $foo = '[^ab]*';\n        $cde =~ /$foo/;\n        $xyz =~ //;\n        is($&, $xyz, $message);\n\n        $cde =~ /$foo/;\n        my $null;\n        no warnings 'uninitialized';\n        $xyz =~ /$null/;\n        is($&, $xyz, $message);\n\n        $null = \"\";\n        $xyz =~ /$null/;\n        is($&, $xyz, $message);\n\n        # each entry: regexp, match string, $&, //o match success\n        my @tests =\n          (\n           [ \"\", \"xy\", \"x\", 1 ],\n           [ \"y\", \"yz\", \"y\", !1 ],\n          );\n        for my $test (@tests) {\n            my ($re, $str, $matched, $omatch) = @$test;\n            $xyz =~ /x/o;\n            ok($str =~ /$re/, \"$str matches /$re/\");\n            is($&, $matched, \"on $matched\");\n            $xyz =~ /x/o;\n            is($str =~ /$re/o, $omatch, \"$str matches /$re/o (or not)\");\n        }\n    }\n\n    {\n        my $message = q !Check $`, $&, $'!;\n        $_ = 'abcdefghi';\n        /def/;        # optimized up to cmd\n        is(\"$`:$&:$'\", 'abc:def:ghi', $message);\n\n        no warnings 'void';\n        /cde/ + 0;    # optimized only to spat\n        is(\"$`:$&:$'\", 'ab:cde:fghi', $message);\n\n        /[d][e][f]/;    # not optimized\n        is(\"$`:$&:$'\", 'abc:def:ghi', $message);\n    }\n\n    {\n        $_ = 'now is the {time for all} good men to come to.';\n        / \\{([^}]*)}/;\n        is($1, 'time for all', \"Match braces\");\n    }\n\n    {\n        my $message = \"{N,M} quantifier\";\n        $_ = 'xxx {3,4}  yyy   zzz';\n        ok(/( {3,4})/, $message);\n        is($1, '   ', $message);\n        unlike($_, qr/( {4,})/, $message);\n        ok(/( {2,3}.)/, $message);\n        is($1, '  y', $message);\n        ok(/(y{2,3}.)/, $message);\n        is($1, 'yyy ', $message);\n        unlike($_, qr/x {3,4}/, $message);\n        unlike($_, qr/^xxx {3,4}/, $message);\n    }\n\n    {\n        my $message = \"Test /g\";\n        local $\" = \":\";\n        $_ = \"now is the time for all good men to come to.\";\n        my @words = /(\\w+)/g;\n        my $exp   = \"now:is:the:time:for:all:good:men:to:come:to\";\n\n        is(\"@words\", $exp, $message);\n\n        @words = ();\n        while (/\\w+/g) {\n            push (@words, $&);\n        }\n        is(\"@words\", $exp, $message);\n\n        @words = ();\n        pos = 0;\n        while (/to/g) {\n            push(@words, $&);\n        }\n        is(\"@words\", \"to:to\", $message);\n\n        pos $_ = 0;\n        @words = /to/g;\n        is(\"@words\", \"to:to\", $message);\n    }\n\n    {\n        $_ = \"abcdefghi\";\n\n        my $pat1 = 'def';\n        my $pat2 = '^def';\n        my $pat3 = '.def.';\n        my $pat4 = 'abc';\n        my $pat5 = '^abc';\n        my $pat6 = 'abc$';\n        my $pat7 = 'ghi';\n        my $pat8 = '\\w*ghi';\n        my $pat9 = 'ghi$';\n\n        my $t1 = my $t2 = my $t3 = my $t4 = my $t5 =\n        my $t6 = my $t7 = my $t8 = my $t9 = 0;\n\n        for my $iter (1 .. 5) {\n            $t1++ if /$pat1/o;\n            $t2++ if /$pat2/o;\n            $t3++ if /$pat3/o;\n            $t4++ if /$pat4/o;\n            $t5++ if /$pat5/o;\n            $t6++ if /$pat6/o;\n            $t7++ if /$pat7/o;\n            $t8++ if /$pat8/o;\n            $t9++ if /$pat9/o;\n        }\n        my $x = \"$t1$t2$t3$t4$t5$t6$t7$t8$t9\";\n        is($x, '505550555', \"Test /o\");\n    }\n\n    {\n        my $xyz = 'xyz';\n        ok \"abc\" =~ /^abc$|$xyz/, \"| after \\$\";\n\n        # perl 4.009 says \"unmatched ()\"\n        my $message = '$ inside ()';\n\n        my $result;\n        eval '\"abc\" =~ /a(bc$)|$xyz/; $result = \"$&:$1\"';\n        is($@, \"\", $message);\n        is($result, \"abc:bc\", $message);\n    }\n\n    {\n        my $message = \"Scalar /g\";\n        $_ = \"abcfooabcbar\";\n\n        ok( /abc/g && $` eq \"\", $message);\n        ok( /abc/g && $` eq \"abcfoo\", $message);\n        ok(!/abc/g, $message);\n\n        $message = \"Scalar /gi\";\n        pos = 0;\n        ok( /ABC/gi && $` eq \"\", $message);\n        ok( /ABC/gi && $` eq \"abcfoo\", $message);\n        ok(!/ABC/gi, $message);\n\n        $message = \"Scalar /g\";\n        pos = 0;\n        ok( /abc/g && $' eq \"fooabcbar\", $message);\n        ok( /abc/g && $' eq \"bar\", $message);\n\n        $_ .= '';\n        my @x = /abc/g;\n        is(@x, 2, \"/g reset after assignment\");\n    }\n\n    {\n        my $message = '/g, \\G and pos';\n        $_ = \"abdc\";\n        pos $_ = 2;\n        /\\Gc/gc;\n        is(pos $_, 2, $message);\n        /\\Gc/g;\n        is(pos $_, undef, $message);\n    }\n\n    {\n        my $message = '(?{ })';\n        our $out = 1;\n        'abc' =~ m'a(?{ $out = 2 })b';\n        is($out, 2, $message);\n\n        $out = 1;\n        'abc' =~ m'a(?{ $out = 3 })c';\n        is($out, 1, $message);\n    }\n\n    {\n        $_ = 'foobar1 bar2 foobar3 barfoobar5 foobar6';\n        my @out = /(?<!foo)bar./g;\n        is(\"@out\", 'bar2 barf', \"Negative lookbehind\");\n    }\n\n    {\n        my $message = \"REG_INFTY tests\";\n        # Tests which depend on REG_INFTY\n\n\t#  Defaults assumed if this fails\n\teval { require Config; };\n        $::reg_infty   = $Config::Config{reg_infty} // 65535;\n        $::reg_infty_m = $::reg_infty - 1;\n        $::reg_infty_p = $::reg_infty + 1;\n        $::reg_infty_m = $::reg_infty_m;   # Suppress warning.\n\n        # As well as failing if the pattern matches do unexpected things, the\n        # next three tests will fail if you should have picked up a lower-than-\n        # default value for $reg_infty from Config.pm, but have not.\n\n        is(eval q{('aaa' =~ /(a{1,$::reg_infty_m})/)[0]}, 'aaa', $message);\n        is($@, '', $message);\n        is(eval q{('a' x $::reg_infty_m) =~ /a{$::reg_infty_m}/}, 1, $message);\n        is($@, '', $message);\n        isnt(q{('a' x ($::reg_infty_m - 1)) !~ /a{$::reg_infty_m}/}, 1, $message);\n        is($@, '', $message);\n\n        eval \"'aaa' =~ /a{1,$::reg_infty}/\";\n        like($@, qr/^\\QQuantifier in {,} bigger than/, $message);\n        eval \"'aaa' =~ /a{1,$::reg_infty_p}/\";\n        like($@, qr/^\\QQuantifier in {,} bigger than/, $message);\n\n        # It should be 'a' x 2147483647, but that exhausts memory on\n        # reasonably sized modern machines\n        like('a' x $::reg_infty_p, qr/a{1,}/,\n             \"{1,} matches more times than REG_INFTY\");\n    }\n\n    {\n        # Poke a couple more parse failures\n        my $context = 'x' x 256;\n        eval qq(\"${context}y\" =~ /(?<=$context)y/);\n        ok $@ =~ /^\\QLookbehind longer than 255 not/, \"Lookbehind limit\";\n    }\n\n    {\n        # Long Monsters\n        for my $l (125, 140, 250, 270, 300000, 30) { # Ordered to free memory\n            my $a = 'a' x $l;\n\t    my $message = \"Long monster, length = $l\";\n\t    like(\"ba$a=\", qr/a$a=/, $message);\n            unlike(\"b$a=\", qr/a$a=/, $message);\n            like(\"b$a=\", qr/ba+=/, $message);\n\n\t    like(\"ba$a=\", qr/b(?:a|b)+=/, $message);\n        }\n    }\n\n    {\n        # 20000 nodes, each taking 3 words per string, and 1 per branch\n        my $long_constant_len = join '|', 12120 .. 32645;\n        my $long_var_len = join '|', 8120 .. 28645;\n        my %ans = ( 'ax13876y25677lbc' => 1,\n                    'ax13876y25677mcb' => 0, # not b.\n                    'ax13876y35677nbc' => 0, # Num too big\n                    'ax13876y25677y21378obc' => 1,\n                    'ax13876y25677y21378zbc' => 0,    # Not followed by [k-o]\n                    'ax13876y25677y21378y21378kbc' => 1,\n                    'ax13876y25677y21378y21378kcb' => 0, # Not b.\n                    'ax13876y25677y21378y21378y21378kbc' => 0, # 5 runs\n                  );\n\n        for (keys %ans) {\n\t    my $message = \"20000 nodes, const-len '$_'\";\n            ok !($ans{$_} xor /a(?=([yx]($long_constant_len)){2,4}[k-o]).*b./o), $message;\n\n\t    $message = \"20000 nodes, var-len '$_'\";\n            ok !($ans{$_} xor /a(?=([yx]($long_var_len)){2,4}[k-o]).*b./o,), $message;\n        }\n    }\n\n    {\n        my $message = \"Complicated backtracking\";\n        $_ = \" a (bla()) and x(y b((l)u((e))) and b(l(e)e)e\";\n        my $expect = \"(bla()) ((l)u((e))) (l(e)e)\";\n\n        our $c;\n        sub matchit {\n          m/\n             (\n               \\(\n               (?{ $c = 1 })    # Initialize\n               (?:\n                 (?(?{ $c == 0 })   # PREVIOUS iteration was OK, stop the loop\n                   (?!\n                   )        # Fail: will unwind one iteration back\n                 )\n                 (?:\n                   [^()]+        # Match a big chunk\n                   (?=\n                     [()]\n                   )        # Do not try to match subchunks\n                 |\n                   \\(\n                   (?{ ++$c })\n                 |\n                   \\)\n                   (?{ --$c })\n                 )\n               )+        # This may not match with different subblocks\n             )\n             (?(?{ $c != 0 })\n               (?!\n               )        # Fail\n             )            # Otherwise the chunk 1 may succeed with $c>0\n           /xg;\n        }\n\n        my @ans = ();\n        my $res;\n        push @ans, $res while $res = matchit;\n        is(\"@ans\", \"1 1 1\", $message);\n\n        @ans = matchit;\n        is(\"@ans\", $expect, $message);\n\n        $message = \"Recursion with (??{ })\";\n        our $matched;\n        $matched = qr/\\((?:(?>[^()]+)|(??{$matched}))*\\)/;\n\n        @ans = my @ans1 = ();\n        push (@ans, $res), push (@ans1, $&) while $res = m/$matched/g;\n\n        is(\"@ans\", \"1 1 1\", $message);\n        is(\"@ans1\", $expect, $message);\n\n        @ans = m/$matched/g;\n        is(\"@ans\", $expect, $message);\n\n    }\n\n    {\n        ok \"abc\" =~ /^(??{\"a\"})b/, '\"abc\" =~ /^(??{\"a\"})b/';\n    }\n\n    {\n        my @ans = ('a/b' =~ m%(.*/)?(.*)%);    # Stack may be bad\n        is(\"@ans\", 'a/ b', \"Stack may be bad\");\n    }\n\n    {\n        my $message = \"Eval-group not allowed at runtime\";\n        my $code = '{$blah = 45}';\n        our $blah = 12;\n        eval { /(?$code)/ };\n        ok($@ && $@ =~ /not allowed at runtime/ && $blah == 12, $message);\n\n\t$blah = 12;\n\tmy $res = eval { \"xx\" =~ /(?$code)/o };\n\t{\n\t    no warnings 'uninitialized';\n\t    chomp $@; my $message = \"$message '$@', '$res', '$blah'\";\n\t    ok($@ && $@ =~ /not allowed at runtime/ && $blah == 12, $message);\n\t}\n\n        $code = '=xx';\n\t$blah = 12;\n\t$res = eval { \"xx\" =~ /(?$code)/o };\n\t{\n\t    no warnings 'uninitialized';\n\t    my $message = \"$message '$@', '$res', '$blah'\";\n\t    ok(!$@ && $res, $message);\n\t}\n\n        $code = '{$blah = 45}';\n        $blah = 12;\n        eval \"/(?$code)/\";\n        is($blah, 45, $message);\n\n        $blah = 12;\n        /(?{$blah = 45})/;\n        is($blah, 45, $message);\n    }\n\n    {\n        my $message = \"Pos checks\";\n        my $x = 'banana';\n        $x =~ /.a/g;\n        is(pos $x, 2, $message);\n\n        $x =~ /.z/gc;\n        is(pos $x, 2, $message);\n\n        sub f {\n            my $p = $_[0];\n            return $p;\n        }\n\n        $x =~ /.a/g;\n        is(f (pos $x), 4, $message);\n    }\n\n    {\n        my $message = 'Checking $^R';\n        our $x = $^R = 67;\n        'foot' =~ /foo(?{$x = 12; 75})[t]/;\n        is($^R, 75, $message);\n\n        $x = $^R = 67;\n        'foot' =~ /foo(?{$x = 12; 75})[xy]/;\n        ok($^R eq '67' && $x eq '12', $message);\n\n        $x = $^R = 67;\n        'foot' =~ /foo(?{ $^R + 12 })((?{ $x = 12; $^R + 17 })[xy])?/;\n        ok($^R eq '79' && $x eq '12', $message);\n    }\n\n    {\n        is(qr/\\b\\v$/i,    '(?^i:\\b\\v$)', 'qr/\\b\\v$/i');\n        is(qr/\\b\\v$/s,    '(?^s:\\b\\v$)', 'qr/\\b\\v$/s');\n        is(qr/\\b\\v$/m,    '(?^m:\\b\\v$)', 'qr/\\b\\v$/m');\n        is(qr/\\b\\v$/x,    '(?^x:\\b\\v$)', 'qr/\\b\\v$/x');\n        is(qr/\\b\\v$/xism, '(?^msix:\\b\\v$)',  'qr/\\b\\v$/xism');\n        is(qr/\\b\\v$/,     '(?^:\\b\\v$)', 'qr/\\b\\v$/');\n    }\n\n    {   # Test that charset modifier work, and are interpolated\n        is(qr/\\b\\v$/, '(?^:\\b\\v$)', 'Verify no locale, no unicode_strings gives default modifier');\n        is(qr/(?l:\\b\\v$)/, '(?^:(?l:\\b\\v$))', 'Verify infix l modifier compiles');\n        is(qr/(?u:\\b\\v$)/, '(?^:(?u:\\b\\v$))', 'Verify infix u modifier compiles');\n        is(qr/(?l)\\b\\v$/, '(?^:(?l)\\b\\v$)', 'Verify (?l) compiles');\n        is(qr/(?u)\\b\\v$/, '(?^:(?u)\\b\\v$)', 'Verify (?u) compiles');\n\n        my $dual = qr/\\b\\v$/;\n        my $locale;\n\n      SKIP: {\n            skip 'Locales not available', 1 unless locales_enabled('LC_CTYPE');\n\n            use locale;\n            $locale = qr/\\b\\v$/;\n            is($locale,    '(?^l:\\b\\v$)', 'Verify has l modifier when compiled under use locale');\n            no locale;\n        }\n\n        use feature 'unicode_strings';\n        my $unicode = qr/\\b\\v$/;\n        is($unicode,    '(?^u:\\b\\v$)', 'Verify has u modifier when compiled under unicode_strings');\n        is(qr/abc$dual/,    '(?^u:abc(?^:\\b\\v$))', 'Verify retains d meaning when interpolated under locale');\n\n      SKIP: {\n            skip 'Locales not available', 1 unless locales_enabled('LC_CTYPE');\n\n            is(qr/abc$locale/,    '(?^u:abc(?^l:\\b\\v$))', 'Verify retains l when interpolated under unicode_strings');\n        }\n\n        no feature 'unicode_strings';\n      SKIP: {\n            skip 'Locales not available', 1 unless locales_enabled('LC_CTYPE');\n            is(qr/abc$locale/,    '(?^:abc(?^l:\\b\\v$))', 'Verify retains l when interpolated outside locale and unicode strings');\n        }\n\n        is(qr/def$unicode/,    '(?^:def(?^u:\\b\\v$))', 'Verify retains u when interpolated outside locale and unicode strings');\n\n      SKIP: {\n            skip 'Locales not available', 2 unless locales_enabled('LC_CTYPE');\n\n             use locale;\n            is(qr/abc$dual/,    '(?^l:abc(?^:\\b\\v$))', 'Verify retains d meaning when interpolated under locale');\n            is(qr/abc$unicode/,    '(?^l:abc(?^u:\\b\\v$))', 'Verify retains u when interpolated under locale');\n        }\n    }\n\n    {\n        my $message = \"Look around\";\n        $_ = 'xabcx';\n        foreach my $ans ('', 'c') {\n            ok(/(?<=(?=a)..)((?=c)|.)/g, $message);\n            is($1, $ans, $message);\n        }\n    }\n\n    {\n        my $message = \"Empty clause\";\n        $_ = 'a';\n        foreach my $ans ('', 'a', '') {\n            ok(/^|a|$/g, $message);\n            is($&, $ans, $message);\n        }\n    }\n\n    {\n        sub prefixify {\n        my $message = \"Prefixify\";\n            {\n                my ($v, $a, $b, $res) = @_;\n                ok($v =~ s/\\Q$a\\E/$b/, $message);\n                is($v, $res, $message);\n            }\n        }\n\n        prefixify ('/a/b/lib/arch', \"/a/b/lib\", 'X/lib', 'X/lib/arch');\n        prefixify ('/a/b/man/arch', \"/a/b/man\", 'X/man', 'X/man/arch');\n    }\n\n    {\n        $_ = 'var=\"foo\"';\n        /(\\\")/;\n        ok $1 && /$1/, \"Capture a quote\";\n    }\n\n    {\n        no warnings 'closure';\n        my $message = '(?{ $var } refers to package vars';\n        package aa;\n        our $c = 2;\n        $::c = 3;\n        '' =~ /(?{ $c = 4 })/;\n        main::is($c, 4, $message);\n        main::is($::c, 3, $message);\n    }\n\n    {\n        is(eval 'q(a:[b]:) =~ /[x[:foo:]]/', undef);\n\tlike ($@, qr/POSIX class \\[:[^:]+:\\] unknown in regex/,\n\t      'POSIX class [: :] must have valid name');\n\n        for my $d (qw [= .]) {\n            is(eval \"/[[${d}foo${d}]]/\", undef);\n\t    like ($@, qr/\\QPOSIX syntax [$d $d] is reserved for future extensions/,\n\t\t  \"POSIX syntax [[$d $d]] is an error\");\n        }\n    }\n\n    {\n        # test if failure of patterns returns empty list\n        my $message = \"Failed pattern returns empty list\";\n        $_ = 'aaa';\n        @_ = /bbb/;\n        is(\"@_\", \"\", $message);\n\n        @_ = /bbb/g;\n        is(\"@_\", \"\", $message);\n\n        @_ = /(bbb)/;\n        is(\"@_\", \"\", $message);\n\n        @_ = /(bbb)/g;\n        is(\"@_\", \"\", $message);\n    }\n\n    {\n        my $message = '@- and @+ and @{^CAPTURE} tests';\n\n        $_= \"ace\";\n        /c(?=.$)/;\n        is($#{^CAPTURE}, -1, $message);\n        is($#+, 0, $message);\n        is($#-, 0, $message);\n        is($+ [0], 2, $message);\n        is($- [0], 1, $message);\n        ok(!defined $+ [1] && !defined $- [1] &&\n           !defined $+ [2] && !defined $- [2], $message);\n\n        /a(c)(e)/;\n        is($#{^CAPTURE}, 1, $message); # one less than $#-\n        is($#+, 2, $message);\n        is($#-, 2, $message);\n        is($+ [0], 3, $message);\n        is($- [0], 0, $message);\n        is(${^CAPTURE}[0], \"c\", $message);\n        is($+ [1], 2, $message);\n        is($- [1], 1, $message);\n        is(${^CAPTURE}[1], \"e\", $message);\n        is($+ [2], 3, $message);\n        is($- [2], 2, $message);\n        ok(!defined $+ [3] && !defined $- [3] &&\n           !defined ${^CAPTURE}[2] && !defined ${^CAPTURE}[3] &&\n           !defined $+ [4] && !defined $- [4], $message);\n\n        # Exists has a special check for @-/@+ - bug 45147\n        ok(exists $-[0], $message);\n        ok(exists $+[0], $message);\n        ok(exists ${^CAPTURE}[0], $message);\n        ok(exists ${^CAPTURE}[1], $message);\n        ok(exists $-[2], $message);\n        ok(exists $+[2], $message);\n        ok(!exists ${^CAPTURE}[2], $message);\n        ok(!exists $-[3], $message);\n        ok(!exists $+[3], $message);\n        ok(exists ${^CAPTURE}[-1], $message);\n        ok(exists ${^CAPTURE}[-2], $message);\n        ok(exists $-[-1], $message);\n        ok(exists $+[-1], $message);\n        ok(exists $-[-3], $message);\n        ok(exists $+[-3], $message);\n        ok(!exists $-[-4], $message);\n        ok(!exists $+[-4], $message);\n        ok(!exists ${^CAPTURE}[-3], $message);\n\n\n        /.(c)(b)?(e)/;\n        is($#{^CAPTURE}, 2, $message); # one less than $#-\n        is($#+, 3, $message);\n        is($#-, 3, $message);\n        is(${^CAPTURE}[0], \"c\", $message);\n        is(${^CAPTURE}[2], \"e\", $message . \"[$1 $3]\");\n        is($+ [1], 2, $message);\n        is($- [1], 1, $message);\n        is($+ [3], 3, $message);\n        is($- [3], 2, $message);\n        ok(!defined $+ [2] && !defined $- [2] &&\n           !defined $+ [4] && !defined $- [4] &&\n           !defined ${^CAPTURE}[1], $message);\n\n        /.(c)/;\n        is($#{^CAPTURE}, 0, $message); # one less than $#-\n        is($#+, 1, $message);\n        is($#-, 1, $message);\n        is(${^CAPTURE}[0], \"c\", $message);\n        is($+ [0], 2, $message);\n        is($- [0], 0, $message);\n        is($+ [1], 2, $message);\n        is($- [1], 1, $message);\n        ok(!defined $+ [2] && !defined $- [2] &&\n           !defined $+ [3] && !defined $- [3] &&\n           !defined ${^CAPTURE}[1], $message);\n\n        /.(c)(ba*)?/;\n        is($#{^CAPTURE}, 0, $message); # one less than $#-\n        is($#+, 2, $message);\n        is($#-, 1, $message);\n\n        # Check that values don\u2019t stick\n        \"     \"=~/()()()(.)(..)/;\n        my($m,$p,$q) = (\\$-[5], \\$+[5], \\${^CAPTURE}[4]);\n        () = \"$$_\" for $m, $p, $q; # FETCH (or eqv.)\n        \" \" =~ /()/;\n        is $$m, undef, 'values do not stick to @- elements';\n        is $$p, undef, 'values do not stick to @+ elements';\n        is $$q, undef, 'values do not stick to @{^CAPTURE} elements';\n    }\n\n    foreach ('$+[0] = 13', '$-[0] = 13', '@+ = (7, 6, 5)',\n             '${^CAPTURE}[0] = 13',\n\t     '@- = qw (foo bar)', '$^N = 42') {\n\tis(eval $_, undef);\n        like($@, qr/^Modification of a read-only value attempted/,\n\t     '$^N, @- and @+ are read-only');\n    }\n\n    {\n        my $message = '\\G testing';\n        $_ = 'aaa';\n        pos = 1;\n        my @a = /\\Ga/g;\n        is(\"@a\", \"a a\", $message);\n\n        my $str = 'abcde';\n        pos $str = 2;\n        unlike($str, qr/^\\G/, $message);\n        unlike($str, qr/^.\\G/, $message);\n        like($str, qr/^..\\G/, $message);\n        unlike($str, qr/^...\\G/, $message);\n        ok($str =~ /\\G../ && $& eq 'cd', $message);\n        ok($str =~ /.\\G./ && $& eq 'bc', $message);\n\n    }\n\n    {\n        my $message = '\\G and intuit and anchoring';\n\t$_ = \"abcdef\";\n\tpos = 0;\n\tok($_ =~ /\\Gabc/, $message);\n\tok($_ =~ /^\\Gabc/, $message);\n\n\tpos = 3;\n\tok($_ =~ /\\Gdef/, $message);\n\tpos = 3;\n\tok($_ =~ /\\Gdef$/, $message);\n\tpos = 3;\n\tok($_ =~ /abc\\Gdef$/, $message);\n\tpos = 3;\n\tok($_ =~ /^abc\\Gdef$/, $message);\n\tpos = 3;\n\tok($_ =~ /c\\Gd/, $message);\n\tpos = 3;\n\tok($_ =~ /..\\GX?def/, $message);\n    }\n\n    {\n        my $s = '123';\n        pos($s) = 1;\n        my @a = $s =~ /(\\d)\\G/g; # this infinitely looped up till 5.19.1\n        is(\"@a\", \"1\", '\\G looping');\n    }\n\n\n    {\n        my $message = 'pos inside (?{ })';\n        my $str = 'abcde';\n        our ($foo, $bar);\n        like($str, qr/b(?{$foo = $_; $bar = pos})c/, $message);\n        is($foo, $str, $message);\n        is($bar, 2, $message);\n        is(pos $str, undef, $message);\n\n        undef $foo;\n        undef $bar;\n        pos $str = undef;\n        ok($str =~ /b(?{$foo = $_; $bar = pos})c/g, $message);\n        is($foo, $str, $message);\n        is($bar, 2, $message);\n        is(pos $str, 3, $message);\n\n        $_ = $str;\n        undef $foo;\n        undef $bar;\n        like($_, qr/b(?{$foo = $_; $bar = pos})c/, $message);\n        is($foo, $str, $message);\n        is($bar, 2, $message);\n\n        undef $foo;\n        undef $bar;\n        ok(/b(?{$foo = $_; $bar = pos})c/g, $message);\n        is($foo, $str, $message);\n        is($bar, 2, $message);\n        is(pos, 3, $message);\n\n        undef $foo;\n        undef $bar;\n        pos = undef;\n        1 while /b(?{$foo = $_; $bar = pos})c/g;\n        is($foo, $str, $message);\n        is($bar, 2, $message);\n        is(pos, undef, $message);\n\n        undef $foo;\n        undef $bar;\n        $_ = 'abcde|abcde';\n        ok(s/b(?{$foo = $_; $bar = pos})c/x/g, $message);\n        is($foo, 'abcde|abcde', $message);\n        is($bar, 8, $message);\n        is($_, 'axde|axde', $message);\n\n        # List context:\n        $_ = 'abcde|abcde';\n        our @res;\n        () = /([ace]).(?{push @res, $1,$2})([ce])(?{push @res, $1,$2})/g;\n        @res = map {defined $_ ? \"'$_'\" : 'undef'} @res;\n        is(\"@res\", \"'a' undef 'a' 'c' 'e' undef 'a' undef 'a' 'c'\", $message);\n\n        @res = ();\n        () = /([ace]).(?{push @res, $`,$&,$'})([ce])(?{push @res, $`,$&,$'})/g;\n        @res = map {defined $_ ? \"'$_'\" : 'undef'} @res;\n        is(\"@res\", \"'' 'ab' 'cde|abcde' \" .\n                     \"'' 'abc' 'de|abcde' \" .\n                     \"'abcd' 'e|' 'abcde' \" .\n                     \"'abcde|' 'ab' 'cde' \" .\n                     \"'abcde|' 'abc' 'de'\", $message);\n    }\n\n    {\n        my $message = '\\G anchor checks';\n        my $foo = 'aabbccddeeffgg';\n        pos ($foo) = 1;\n\n\tok($foo =~ /.\\G(..)/g, $message);\n\tis($1, 'ab', $message);\n\n\tpos ($foo) += 1;\n\tok($foo =~ /.\\G(..)/g, $message);\n\tis($1, 'cc', $message);\n\n\tpos ($foo) += 1;\n\tok($foo =~ /.\\G(..)/g, $message);\n\tis($1, 'de', $message);\n\n\tok($foo =~ /\\Gef/g, $message);\n\n        undef pos $foo;\n        ok($foo =~ /\\G(..)/g, $message);\n        is($1, 'aa', $message);\n\n        ok($foo =~ /\\G(..)/g, $message);\n        is($1, 'bb', $message);\n\n        pos ($foo) = 5;\n        ok($foo =~ /\\G(..)/g, $message);\n        is($1, 'cd', $message);\n    }\n\n    {\n        my $message = 'basic \\G floating checks';\n        my $foo = 'aabbccddeeffgg';\n        pos ($foo) = 1;\n\n\tok($foo =~ /a+\\G(..)/g, \"$message: a+\\\\G\");\n\tis($1, 'ab', \"$message: ab\");\n\n\tpos ($foo) += 1;\n\tok($foo =~ /b+\\G(..)/g, \"$message: b+\\\\G\");\n\tis($1, 'cc', \"$message: cc\");\n\n\tpos ($foo) += 1;\n\tok($foo =~ /d+\\G(..)/g, \"$message: d+\\\\G\");\n\tis($1, 'de', \"$message: de\");\n\n\tok($foo =~ /\\Gef/g, \"$message: \\\\Gef\");\n\n        pos ($foo) = 1;\n\n\tok($foo =~ /(?=a+\\G)(..)/g, \"$message: (?a+\\\\G)\");\n\tis($1, 'aa', \"$message: aa\");\n\n        pos ($foo) = 2;\n\n\tok($foo =~ /a(?=a+\\G)(..)/g, \"$message: a(?=a+\\\\G)\");\n\tis($1, 'ab', \"$message: ab\");\n\n    }\n\n    {\n        $_ = '123x123';\n        my @res = /(\\d*|x)/g;\n        local $\" = '|';\n        is(\"@res\", \"123||x|123|\", \"0 match in alternation\");\n    }\n\n    {\n        my $message = \"Match against temporaries (created via pp_helem())\" .\n                         \" is safe\";\n        ok({foo => \"bar\\n\" . $^X} -> {foo} =~ /^(.*)\\n/g, $message);\n        is($1, \"bar\", $message);\n    }\n\n    {\n        my $message = 'package $i inside (?{ }), ' .\n                         'saved substrings and changing $_';\n        our @a = qw [foo bar];\n        our @b = ();\n        s/(\\w)(?{push @b, $1})/,$1,/g for @a;\n        is(\"@b\", \"f o o b a r\", $message);\n        is(\"@a\", \",f,,o,,o, ,b,,a,,r,\", $message);\n\n        $message = 'lexical $i inside (?{ }), ' .\n                         'saved substrings and changing $_';\n        no warnings 'closure';\n        my @c = qw [foo bar];\n        my @d = ();\n        s/(\\w)(?{push @d, $1})/,$1,/g for @c;\n        is(\"@d\", \"f o o b a r\", $message);\n        is(\"@c\", \",f,,o,,o, ,b,,a,,r,\", $message);\n    }\n\n    {\n        my $message = 'Brackets';\n        our $brackets;\n        $brackets = qr {\n            {  (?> [^{}]+ | (??{ $brackets }) )* }\n        }x;\n\n        ok(\"{{}\" =~ $brackets, $message);\n        is($&, \"{}\", $message);\n        ok(\"something { long { and } hairy\" =~ $brackets, $message);\n        is($&, \"{ and }\", $message);\n        ok(\"something { long { and } hairy\" =~ m/((??{ $brackets }))/, $message);\n        is($&, \"{ and }\", $message);\n    }\n\n    {\n        $_ = \"a-a\\nxbb\";\n        pos = 1;\n        ok(!m/^-.*bb/mg, '$_ = \"a-a\\nxbb\"; m/^-.*bb/mg');\n    }\n\n    {\n        my $message = '\\G anchor checks';\n        my $text = \"aaXbXcc\";\n        pos ($text) = 0;\n        ok($text !~ /\\GXb*X/g, $message);\n    }\n\n    {\n        $_ = \"xA\\n\" x 500;\n        unlike($_, qr/^\\s*A/m, '$_ = \"xA\\n\" x 500; /^\\s*A/m\"');\n\n        my $text = \"abc dbf\";\n        my @res = ($text =~ /.*?(b).*?\\b/g);\n        is(\"@res\", \"b b\", '\\b is not special');\n    }\n\n    {\n        my $message = '\\S, [\\S], \\s, [\\s]';\n        my @a = map chr, 0 .. 255;\n        my @b = grep m/\\S/, @a;\n        my @c = grep m/[^\\s]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\S/, @a;\n        @c = grep /[\\S]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\s/, @a;\n        @c = grep /[^\\S]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\s/, @a;\n        @c = grep /[\\s]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        # Test an inverted posix class with a char also in the class.\n        my $nbsp = chr utf8::unicode_to_native(0xA0);\n        my $non_s = chr utf8::unicode_to_native(0xA1);\n        my $pat_string = \"[^\\\\S ]\";\n        unlike(\" \", qr/$pat_string/, \"Verify ' ' !~ /$pat_string/\");\n        like(\"\\t\", qr/$pat_string/, \"Verify '\\\\t =~ /$pat_string/\");\n        unlike($nbsp, qr/$pat_string/, \"Verify non-utf8-NBSP !~ /$pat_string/\");\n        utf8::upgrade($nbsp);\n        like($nbsp, qr/$pat_string/, \"Verify utf8-NBSP =~ /$pat_string/\");\n        unlike($non_s, qr/$pat_string/, \"Verify non-utf8-inverted-bang !~ /$pat_string/\");\n        utf8::upgrade($non_s);\n        unlike($non_s, qr/$pat_string/, \"Verify utf8-inverted-bang !~ /$pat_string/\");\n    }\n    {\n        my $message = '\\D, [\\D], \\d, [\\d]';\n        my @a = map chr, 0 .. 255;\n        my @b = grep /\\D/, @a;\n        my @c = grep /[^\\d]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\D/, @a;\n        @c = grep /[\\D]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\d/, @a;\n        @c = grep /[^\\D]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\d/, @a;\n        @c = grep /[\\d]/, @a;\n        is(\"@b\", \"@c\", $message);\n    }\n    {\n        my $message = '\\W, [\\W], \\w, [\\w]';\n        my @a = map chr, 0 .. 255;\n        my @b = grep /\\W/, @a;\n        my @c = grep /[^\\w]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\W/, @a;\n        @c = grep /[\\W]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\w/, @a;\n        @c = grep /[^\\W]/, @a;\n        is(\"@b\", \"@c\", $message);\n\n        @b = grep /\\w/, @a;\n        @c = grep /[\\w]/, @a;\n        is(\"@b\", \"@c\", $message);\n    }\n\n    {\n        # see if backtracking optimization works correctly\n        my $message = 'Backtrack optimization';\n        like(\"\\n\\n\", qr/\\n   $ \\n/x, $message);\n        like(\"\\n\\n\", qr/\\n*  $ \\n/x, $message);\n        like(\"\\n\\n\", qr/\\n+  $ \\n/x, $message);\n        like(\"\\n\\n\", qr/\\n?  $ \\n/x, $message);\n        like(\"\\n\\n\", qr/\\n*? $ \\n/x, $message);\n        like(\"\\n\\n\", qr/\\n+? $ \\n/x, $message);\n        like(\"\\n\\n\", qr/\\n?? $ \\n/x, $message);\n        unlike(\"\\n\\n\", qr/\\n*+ $ \\n/x, $message);\n        unlike(\"\\n\\n\", qr/\\n++ $ \\n/x, $message);\n        like(\"\\n\\n\", qr/\\n?+ $ \\n/x, $message);\n    }\n\n    {\n        package S;\n        use overload '\"\"' => sub {'Object S'};\n        sub new {bless []}\n\n        my $message  = \"Ref stringification\";\n      ::ok(do { \\my $v} =~ /^SCALAR/,   \"Scalar ref stringification\") or diag($message);\n      ::ok(do {\\\\my $v} =~ /^REF/,      \"Ref ref stringification\") or diag($message);\n      ::ok([]           =~ /^ARRAY/,    \"Array ref stringification\") or diag($message);\n      ::ok({}           =~ /^HASH/,     \"Hash ref stringification\") or diag($message);\n      ::ok('S' -> new   =~ /^Object S/, \"Object stringification\") or diag($message);\n    }\n\n    {\n        my $message = \"Test result of match used as match\";\n        ok('a1b' =~ ('xyz' =~ /y/), $message);\n        is($`, 'a', $message);\n        ok('a1b' =~ ('xyz' =~ /t/), $message);\n        is($`, 'a', $message);\n    }\n\n    {\n        my $message = '\"1\" is not \\s';\n        warning_is(sub {unlike(\"1\\n\" x 102, qr/^\\s*\\n/m, $message)},\n\t\t   undef, \"$message (did not warn)\");\n    }\n\n    {\n        my $message = '\\s, [[:space:]] and [[:blank:]]';\n        my %space = (spc   => \" \",\n                     tab   => \"\\t\",\n                     cr    => \"\\r\",\n                     lf    => \"\\n\",\n                     ff    => \"\\f\",\n        # There's no \\v but the vertical tabulator seems miraculously\n        # be 11 both in ASCII and EBCDIC.\n                     vt    => chr(11),\n                     false => \"space\");\n\n        my @space0 = sort grep {$space {$_} =~ /\\s/         } keys %space;\n        my @space1 = sort grep {$space {$_} =~ /[[:space:]]/} keys %space;\n        my @space2 = sort grep {$space {$_} =~ /[[:blank:]]/} keys %space;\n\n        is(\"@space0\", \"cr ff lf spc tab vt\", $message);\n        is(\"@space1\", \"cr ff lf spc tab vt\", $message);\n        is(\"@space2\", \"spc tab\", $message);\n    }\n\n    {\n        my $n= 50;\n        # this must be a high number and go from 0 to N, as the bug we are looking for doesn't\n        # seem to be predictable. Slight changes to the test make it fail earlier or later.\n        foreach my $i (0 .. $n)\n        {\n            my $str= \"\\n\" x $i;\n            ok $str=~/.*\\z/, \"implicit MBOL check string disable does not break things length=$i\";\n        }\n    }\n    {\n        # we are actually testing that we dont die when executing these patterns\n        use utf8;\n        my $e = \"B\u00f6ck\";\n        ok(utf8::is_utf8($e),\"got a unicode string - rt75680\");\n\n        ok($e !~ m/.*?[x]$/, \"unicode string against /.*?[x]\\$/ - rt75680\");\n        ok($e !~ m/.*?\\p{Space}$/i, \"unicode string against /.*?\\\\p{space}\\$/i - rt75680\");\n        ok($e !~ m/.*?[xyz]$/, \"unicode string against /.*?[xyz]\\$/ - rt75680\");\n        ok($e !~ m/(.*?)[,\\p{isSpace}]+((?:\\p{isAlpha}[\\p{isSpace}\\.]{1,2})+)\\p{isSpace}*$/, \"unicode string against big pattern - rt75680\");\n    }\n    {\n        # we are actually testing that we dont die when executing these patterns\n        my $e = \"B\" . uni_to_native(\"\\x{f6}\") . \"ck\";\n        ok(!utf8::is_utf8($e), \"got a latin string - rt75680\");\n\n        ok($e !~ m/.*?[x]$/, \"latin string against /.*?[x]\\$/ - rt75680\");\n        ok($e !~ m/.*?\\p{Space}$/i, \"latin string against /.*?\\\\p{space}\\$/i - rt75680\");\n        ok($e !~ m/.*?[xyz]$/,\"latin string against /.*?[xyz]\\$/ - rt75680\");\n        ok($e !~ m/(.*?)[,\\p{isSpace}]+((?:\\p{isAlpha}[\\p{isSpace}\\.]{1,2})+)\\p{isSpace}*$/,\"latin string against big pattern - rt75680\");\n    }\n\n    {\n        #\n        # Tests for bug 77414.\n        #\n\n        my $message = '\\p property after empty * match';\n        {\n            like(\"1\", qr/\\s*\\pN/, $message);\n            like(\"-\", qr/\\s*\\p{Dash}/, $message);\n            like(\" \", qr/\\w*\\p{Blank}/, $message);\n        }\n\n        like(\"1\", qr/\\s*\\pN+/, $message);\n        like(\"-\", qr/\\s*\\p{Dash}{1}/, $message);\n        like(\" \", qr/\\w*\\p{Blank}{1,4}/, $message);\n\n    }\n\n    {   # Some constructs with Latin1 characters cause a utf8 string not\n        # to match itself in non-utf8\n        my $c = uni_to_native(\"\\xc0\");\n        my $pattern = my $utf8_pattern = qr/(($c)+,?)/;\n        utf8::upgrade($utf8_pattern);\n        ok $c =~ $pattern, \"\\\\xc0 =~ $pattern; Neither pattern nor target utf8\";\n        ok $c =~ /$pattern/i, \"\\\\xc0 =~ /$pattern/i; Neither pattern nor target utf8\";\n        ok $c =~ $utf8_pattern, \"\\\\xc0 =~ $pattern; pattern utf8, target not\";\n        ok $c =~ /$utf8_pattern/i, \"\\\\xc0 =~ /$pattern/i; pattern utf8, target not\";\n        utf8::upgrade($c);\n        ok $c =~ $pattern, \"\\\\xc0 =~ $pattern; target utf8, pattern not\";\n        ok $c =~ /$pattern/i, \"\\\\xc0 =~ /$pattern/i; target utf8, pattern not\";\n        ok $c =~ $utf8_pattern, \"\\\\xc0 =~ $pattern; Both target and pattern utf8\";\n        ok $c =~ /$utf8_pattern/i, \"\\\\xc0 =~ /$pattern/i; Both target and pattern utf8\";\n    }\n\n    {   # Make sure can override the formatting\n        use feature 'unicode_strings';\n        ok uni_to_native(\"\\xc0\") =~ /\\w/, 'Under unicode_strings: \"\\xc0\" =~ /\\w/';\n        ok uni_to_native(\"\\xc0\") !~ /(?d:\\w)/, 'Under unicode_strings: \"\\xc0\" !~ /(?d:\\w)/';\n    }\n\n    {\n        my $str= \"\\x{100}\";\n        chop $str;\n        my $qr= qr/$str/;\n        is(\"$qr\", \"(?^:)\", \"Empty pattern qr// stringifies to (?^:) with unicode flag enabled - Bug #80212\");\n        $str= \"\";\n        $qr= qr/$str/;\n        is(\"$qr\", \"(?^:)\", \"Empty pattern qr// stringifies to (?^:) with unicode flag disabled - Bug #80212\");\n\n    }\n\n    {\n        local $::TODO = \"[perl #38133]\";\n\n        \"A\" =~ /(((?:A))?)+/;\n        my $first = $2;\n\n        \"A\" =~ /(((A))?)+/;\n        my $second = $2;\n\n        is($first, $second);\n    }\n\n    {\n\t# RT #3516: \\G in a m//g expression causes problems\n\tmy $count = 0;\n\twhile (\"abc\" =~ m/(\\G[ac])?/g) {\n\t    last if $count++ > 10;\n\t}\n\tok($count < 10, 'RT #3516 A');\n\n\t$count = 0;\n\twhile (\"abc\" =~ m/(\\G|.)[ac]/g) {\n\t    last if $count++ > 10;\n\t}\n\tok($count < 10, 'RT #3516 B');\n\n\t$count = 0;\n\twhile (\"abc\" =~ m/(\\G?[ac])?/g) {\n\t    last if $count++ > 10;\n\t}\n\tok($count < 10, 'RT #3516 C');\n    }\n    {\n        # RT #84294: Is this a bug in the simple Perl regex?\n        #          : Nested buffers and (?{...}) dont play nicely on partial matches\n        our @got= ();\n        ok(\"ab\" =~ /((\\w+)(?{ push @got, $2 })){2}/,\"RT #84294: Pattern should match\");\n        my $want= \"'ab', 'a', 'b'\";\n        my $got= join(\", \", map { defined($_) ? \"'$_'\" : \"undef\" } @got);\n        is($got,$want,'RT #84294: check that \"ab\" =~ /((\\w+)(?{ push @got, $2 })){2}/ leaves @got in the correct state');\n    }\n\n    {\n        # Suppress warnings, as the non-unicode one comes out even if turn off\n        # warnings here (because the execution is done in another scope).\n        local $SIG{__WARN__} = sub {};\n        my $str = \"\\x{110000}\";\n\n        unlike($str, qr/\\p{ASCII_Hex_Digit=True}/, \"Non-Unicode doesn't match \\\\p{AHEX=True}\");\n        like($str, qr/\\p{ASCII_Hex_Digit=False}/, \"Non-Unicode matches \\\\p{AHEX=False}\");\n        like($str, qr/\\P{ASCII_Hex_Digit=True}/, \"Non-Unicode matches \\\\P{AHEX=True}\");\n        unlike($str, qr/\\P{ASCII_Hex_Digit=False}/, \"Non-Unicode matches \\\\P{AHEX=FALSE}\");\n    }\n\n    {\n        # Test that IDstart works, but because the author (khw) knows\n        # regexes much better than the rest of the core, it is being done here\n        # in the context of a regex which relies on buffer names beginng with\n        # IDStarts.\n        use utf8;\n        my $str = \"abc\";\n        like($str, qr/(?<a>abc)/, \"'a' is legal IDStart\");\n        like($str, qr/(?<_>abc)/, \"'_' is legal IDStart\");\n        like($str, qr/(?<\u00df>abc)/, \"U+00DF is legal IDStart\");\n        like($str, qr/(?<\u2115>abc)/, \"U+2115' is legal IDStart\");\n\n        # This test works on Unicode 6.0 in which U+2118 and U+212E are legal\n        # IDStarts there, but are not Word characters, and therefore Perl\n        # doesn't allow them to be IDStarts.  But there is no guarantee that\n        # Unicode won't change things around in the future so that at some\n        # future Unicode revision these tests would need to be revised.\n        foreach my $char (\"%\", \"\u00d7\", chr(0x2118), chr(0x212E)) {\n            my $prog = <<\"EOP\";\nuse utf8;;\n\"abc\" =~ qr/(?<$char>abc)/;\nEOP\n            utf8::encode($prog);\n            fresh_perl_like($prog, qr!Group name must start with a non-digit word character!, {},\n                        sprintf(\"'U+%04X not legal IDFirst'\", ord($char)));\n        }\n    }\n\n    { # [perl #101710]\n        my $pat = \"b\";\n        utf8::upgrade($pat);\n        like(\"\\xffb\", qr/$pat/i, \"/i: utf8 pattern, non-utf8 string, latin1-char preceding matching char in string\");\n    }\n\n    { # Crash with @a =~ // warning\n\tlocal $SIG{__WARN__} = sub {\n             pass 'no crash for @a =~ // warning'\n        };\n\teval ' sub { my @a =~ // } ';\n    }\n\n    { # Concat overloading and qr// thingies\n\tmy @refs;\n\tmy $qr = qr//;\n        package Cat {\n            require overload;\n            overload->import(\n\t\t'\"\"' => sub { ${$_[0]} },\n\t\t'.' => sub {\n\t\t    push @refs, ref $_[1] if ref $_[1];\n\t\t    bless $_[2] ? \\\"$_[1]${$_[0]}\" : \\\"${$_[0]}$_[1]\"\n\t\t}\n            );\n\t}\n\tmy $s = \"foo\";\n\tmy $o = bless \\$s, Cat::;\n\t/$o$qr/;\n\tis \"@refs\", \"Regexp\", '/$o$qr/ passes qr ref to cat overload meth';\n    }\n\n    {\n        my $count=0;\n        my $str=\"\\n\";\n        $count++ while $str=~/.*/g;\n        is $count, 2, 'test that ANCH_MBOL works properly. We should get 2 from $count++ while \"\\n\"=~/.*/g';\n        my $class_count= 0;\n        $class_count++ while $str=~/[^\\n]*/g;\n        is $class_count, $count, 'while \"\\n\"=~/.*/g and while \"\\n\"=~/[^\\n]*/g should behave the same';\n        my $anch_count= 0;\n        $anch_count++ while $str=~/^.*/mg;\n        is $anch_count, 1, 'while \"\\n\"=~/^.*/mg should match only once';\n    }\n\n    { # [perl #111174]\n        use re '/u';\n        my $A_grave = uni_to_native(\"\\xc0\");\n        like uni_to_native(\"\\xe0\"), qr/(?i:$A_grave)/, \"(?i: shouldn't lose the passed in /u\";\n        use re '/a';\n        unlike \"\\x{100}\", qr/(?i:\\w)/, \"(?i: shouldn't lose the passed in /a\";\n        use re '/aa';\n        unlike 'k', qr/(?i:\\N{KELVIN SIGN})/, \"(?i: shouldn't lose the passed in /aa\";\n        unlike 'k', qr'(?i:\\N{KELVIN SIGN})', \"(?i: shouldn't lose the passed in /aa\";\n    }\n\n    {\n\t# the test for whether the pattern should be re-compiled should\n\t# consider the UTF8ness of the previous and current pattern\n\t# string, as well as the physical bytes of the pattern string\n\n\tfor my $s (byte_utf8a_to_utf8n(\"\\xc4\\x80\"), \"\\x{100}\") {\n\t    ok($s =~ /^$s$/, \"re-compile check is UTF8-aware\");\n\t}\n    }\n\n    #  #113682 more overloading and qr//\n    # when doing /foo$overloaded/, if $overloaded returns\n    # a qr/(?{})/ via qr or \"\" overloading, then 'use re 'eval'\n    # shouldn't be required. Via '.', it still is.\n    {\n        package Qr0;\n\tuse overload 'qr' => sub { qr/(??{50})/ };\n\n        package Qr1;\n\tuse overload '\"\"' => sub { qr/(??{51})/ };\n\n        package Qr2;\n\tuse overload '.'  => sub { $_[1] . qr/(??{52})/ };\n\n        package Qr3;\n\tuse overload '\"\"' => sub { qr/(??{7})/ },\n\t\t     '.'  => sub { $_[1] . qr/(??{53})/ };\n\n        package Qr_indirect;\n\tuse overload '\"\"'  => sub { $_[0][0] };\n\n\tpackage main;\n\n\tfor my $i (0..3) {\n\t    my $o = bless [], \"Qr$i\";\n\t    if ((0,0,1,1)[$i]) {\n\t\teval { \"A5$i\" =~ /^A$o$/ };\n\t\tlike($@, qr/Eval-group not allowed/, \"Qr$i\");\n\t\teval { \"5$i\" =~ /$o/ };\n\t\tlike($@, ($i == 3 ? qr/^$/ : qr/no method found,/),\n\t\t\t\"Qr$i bare\");\n\t\t{\n\t\t    use re 'eval';\n\t\t    ok(\"A5$i\" =~ /^A$o$/, \"Qr$i - with use re eval\");\n\t\t    eval { \"5$i\" =~ /$o/ };\n\t\t    like($@, ($i == 3 ? qr/^$/ : qr/no method found,/),\n\t\t\t    \"Qr$i bare - with use re eval\");\n\t\t}\n\t    }\n\t    else {\n\t\tok(\"A5$i\" =~ /^A$o$/, \"Qr$i\");\n\t\tok(\"5$i\" =~ /$o/, \"Qr$i bare\");\n\t    }\n\t}\n\n\tmy $o = bless [ bless [], \"Qr1\" ], 'Qr_indirect';\n\tok(\"A51\" =~ /^A$o/, \"Qr_indirect\");\n\tok(\"51\" =~ /$o/, \"Qr_indirect bare\");\n    }\n\n    {   # Various flags weren't being set when a [] is optimized into an\n        # EXACTish node\n        ok(\"\\x{017F}\\x{017F}\" =~ qr/^[$sharp_s]?$/i, \"[] to EXACTish optimization\");\n    }\n\n    {\n        for my $char (\":\", uni_to_native(\"\\x{f7}\"), \"\\x{2010}\") {\n            my $utf8_char = $char;\n            utf8::upgrade($utf8_char);\n            my $display = $char;\n            $display = display($display);\n            my $utf8_display = \"utf8::upgrade(\\\"$display\\\")\";\n\n            like($char, qr/^$char?$/, \"\\\"$display\\\" =~ /^$display?\\$/\");\n            like($char, qr/^$utf8_char?$/, \"my \\$p = \\\"$display\\\"; utf8::upgrade(\\$p); \\\"$display\\\" =~ /^\\$p?\\$/\");\n            like($utf8_char, qr/^$char?$/, \"my \\$c = \\\"$display\\\"; utf8::upgrade(\\$c); \\\"\\$c\\\" =~ /^$display?\\$/\");\n            like($utf8_char, qr/^$utf8_char?$/, \"my \\$c = \\\"$display\\\"; utf8::upgrade(\\$c); my \\$p = \\\"$display\\\"; utf8::upgrade(\\$p); \\\"\\$c\\\" =~ /^\\$p?\\$/\");\n        }\n    }\n\n    {\n\t# #116148: Pattern utf8ness sticks around globally\n\t# the utf8 in the first match was sticking around for the second\n\t# match\n\n\tuse feature 'unicode_strings';\n\n\tmy $x = \"\\x{263a}\";\n\t$x =~ /$x/;\n\n\tmy $text = \"Perl\";\n\tok(\"Perl\" =~ /P.*$/i, '#116148');\n    }\n\n    { # 118297: Mixing up- and down-graded strings in regex\n        utf8::upgrade(my $u = \"\\x{e5}\");\n        utf8::downgrade(my $d = \"\\x{e5}\");\n        my $warned;\n        local $SIG{__WARN__} = sub { $warned++ if $_[0] =~ /\\AMalformed UTF-8/ };\n        my $re = qr/$u$d/;\n        ok(!$warned, \"no warnings when interpolating mixed up-/downgraded strings in pattern\");\n        my $c = \"\\x{e5}\\x{e5}\";\n        utf8::downgrade($c);\n        like($c, $re, \"mixed up-/downgraded pattern matches downgraded string\");\n        utf8::upgrade($c);\n        like($c, $re, \"mixed up-/downgraded pattern matches upgraded string\");\n    }\n\n    {\n        # if we have 87 capture buffers defined then \\87 should refer to the 87th.\n        # test that this is true for 1..100\n        # Note that this test causes the engine to recurse at runtime, and\n        # hence use a lot of C stack.\n\n        # Compiling for all 100 nested captures blows the stack under\n        # clang and ASan; reduce.\n        my $max_captures = $Config{ccflags} =~ /sanitize/ ? 20 : 100;\n\n        for my $i (1..100) {\n            if ($i > $max_captures) {\n                pass(\"skipping $i buffers under ASan aa\");\n                pass(\"skipping $i buffers under ASan aba\");\n                next;\n            }\n            my $capture= \"a\";\n            $capture= \"($capture)\" for 1 .. $i;\n            for my $mid (\"\",\"b\") {\n                my $str= \"a${mid}a\";\n                my $backref= \"\\\\$i\";\n                eval {\n                    ok($str=~/$capture$mid$backref/,\"\\\\$i works with $i buffers '$str'=~/...$mid$backref/\");\n                    1;\n                } or do {\n                    is(\"$@\",\"\",\"\\\\$i works with $i buffers works with $i buffers '$str'=~/...$mid$backref/\");\n                };\n            }\n        }\n    }\n\n    # this mixture of readonly (not COWable) and COWable strings\n    # messed up the capture buffers under COW. The actual test results\n    # are incidental; the issue is was an AddressSanitizer failure\n    {\n\tmy $c ='AB';\n\tmy $res = '';\n\tfor ($c, 'C', $c, 'DE') {\n\t    ok(/(.)/, \"COWable match\");\n\t    $res .= $1;\n\t}\n\tis($res, \"ACAD\");\n    }\n\n\n    {\n\t# RT #45667\n\t# /[#$x]/x didn't interpolate the var $x.\n\tmy $b = 'cd';\n\tmy $s = 'abcd$%#&';\n\t$s =~ s/[a#$b%]/X/g;\n\tis ($s, 'XbXX$XX&', 'RT #45667 without /x');\n\t$s = 'abcd$%#&';\n\t$s =~ s/[a#$b%]/X/gx;\n\tis ($s, 'XbXX$XX&', 'RT #45667 with /x');\n    }\n\n    {\n\tno warnings \"uninitialized\";\n\tmy @a;\n\t$a[1]++;\n\t/@a/;\n\tpass('no crash with /@a/ when array has nonexistent elems');\n    }\n\n    {\n\tis runperl(prog => 'delete $::{qq-\\cR-}; //; print qq-ok\\n-'),\n\t   \"ok\\n\",\n\t   'deleting *^R does not result in crashes';\n\tno warnings 'once';\n\t*^R = *caretRglobwithnoscalar;\n\t\"\" =~ /(?{42})/;\n\tis $^R, 42, 'assigning to *^R does not result in a crash';\n\tis runperl(\n\t     stderr => 1,\n\t     prog => 'eval q|'\n\t            .' q-..- =~ /(??{undef *^R;q--})(?{42})/; '\n                    .' print qq-$^R\\n-'\n\t            .'|'\n\t   ),\n\t   \"42\\n\",\n\t   'undefining *^R within (??{}) does not result in a crash';\n    }\n\n    SKIP: {   # Test literal range end point special handling\n        unless ($::IS_EBCDIC) {\n            skip \"Valid only for EBCDIC\", 24;\n        }\n\n        like(\"\\x89\", qr/[i-j]/, '\"\\x89\" should match [i-j]');\n        unlike(\"\\x8A\", qr/[i-j]/, '\"\\x8A\" shouldnt match [i-j]');\n        unlike(\"\\x90\", qr/[i-j]/, '\"\\x90\" shouldnt match [i-j]');\n        like(\"\\x91\", qr/[i-j]/, '\"\\x91\" should match [i-j]');\n\n        like(\"\\x89\", qr/[i-\\N{LATIN SMALL LETTER J}]/, '\"\\x89\" should match [i-\\N{LATIN SMALL LETTER J}]');\n        unlike(\"\\x8A\", qr/[i-\\N{LATIN SMALL LETTER J}]/, '\"\\x8A\" shouldnt match [i-\\N{LATIN SMALL LETTER J}]');\n        unlike(\"\\x90\", qr/[i-\\N{LATIN SMALL LETTER J}]/, '\"\\x90\" shouldnt match [i-\\N{LATIN SMALL LETTER J}]');\n        like(\"\\x91\", qr/[i-\\N{LATIN SMALL LETTER J}]/, '\"\\x91\" should match [i-\\N{LATIN SMALL LETTER J}]');\n\n        like(\"\\x89\", qr/[i-\\N{U+6A}]/, '\"\\x89\" should match [i-\\N{U+6A}]');\n        unlike(\"\\x8A\", qr/[i-\\N{U+6A}]/, '\"\\x8A\" shouldnt match [i-\\N{U+6A}]');\n        unlike(\"\\x90\", qr/[i-\\N{U+6A}]/, '\"\\x90\" shouldnt match [i-\\N{U+6A}]');\n        like(\"\\x91\", qr/[i-\\N{U+6A}]/, '\"\\x91\" should match [i-\\N{U+6A}]');\n\n        like(\"\\x89\", qr/[\\N{U+69}-\\N{U+6A}]/, '\"\\x89\" should match [\\N{U+69}-\\N{U+6A}]');\n        unlike(\"\\x8A\", qr/[\\N{U+69}-\\N{U+6A}]/, '\"\\x8A\" shouldnt match [\\N{U+69}-\\N{U+6A}]');\n        unlike(\"\\x90\", qr/[\\N{U+69}-\\N{U+6A}]/, '\"\\x90\" shouldnt match [\\N{U+69}-\\N{U+6A}]');\n        like(\"\\x91\", qr/[\\N{U+69}-\\N{U+6A}]/, '\"\\x91\" should match [\\N{U+69}-\\N{U+6A}]');\n\n        like(\"\\x89\", qr/[i-\\x{91}]/, '\"\\x89\" should match [i-\\x{91}]');\n        like(\"\\x8A\", qr/[i-\\x{91}]/, '\"\\x8A\" should match [i-\\x{91}]');\n        like(\"\\x90\", qr/[i-\\x{91}]/, '\"\\x90\" should match [i-\\x{91}]');\n        like(\"\\x91\", qr/[i-\\x{91}]/, '\"\\x91\" should match [i-\\x{91}]');\n\n        # Need to use eval, because tries to compile on ASCII platforms even\n        # though the tests are skipped, and fails because 0x89-j is an illegal\n        # range there.\n        like(\"\\x89\", eval 'qr/[\\x{89}-j]/', '\"\\x89\" should match [\\x{89}-j]');\n        like(\"\\x8A\", eval 'qr/[\\x{89}-j]/', '\"\\x8A\" should match [\\x{89}-j]');\n        like(\"\\x90\", eval 'qr/[\\x{89}-j]/', '\"\\x90\" should match [\\x{89}-j]');\n        like(\"\\x91\", eval 'qr/[\\x{89}-j]/', '\"\\x91\" should match [\\x{89}-j]');\n    }\n\n    # These are based on looking at the code in regcomp.c\n    # We don't look for specific code, just the existence of an SSC\n    foreach my $re (qw(     qr/a?c/\n                            qr/a?c/i\n                            qr/[ab]?c/\n                            qr/\\R?c/\n                            qr/\\d?c/d\n                            qr/\\w?c/l\n                            qr/\\s?c/a\n                            qr/[[:lower:]]?c/u\n    )) {\n      SKIP: {\n        skip \"no re-debug under miniperl\" if is_miniperl;\n        my $prog = <<\"EOP\";\nuse re qw(Debug COMPILE);\n$re;\nEOP\n        fresh_perl_like($prog, qr/synthetic stclass/, { stderr=>1 }, \"$re generates a synthetic start class\");\n      }\n    }\n\n    {\n        like \"\\x{AA}\", qr/a?[\\W_]/d, \"\\\\W with /d synthetic start class works\";\n    }\n\n    SKIP: {\n        skip(\"Tests are ASCII-centric, some would fail on EBCDIC\", 12) if $::IS_EBCDIC;\n\n        # Verify that the very last Latin-1 U+00FF\n        # (LATIN SMALL LETTER Y WITH DIAERESIS)\n        # and its UPPER counterpart (U+0178 which is pure Unicode),\n        # and likewise for the very first pure Unicode\n        # (LATIN CAPITAL LETTER A WITH MACRON) fold-match properly,\n        # and there are no off-by-one logic errors in the transition zone.\n\n        ok(\"\\xFF\" =~ /\\xFF/i, \"Y WITH DIAERESIS l =~ l\");\n        ok(\"\\xFF\" =~ /\\x{178}/i, \"Y WITH DIAERESIS l =~ u\");\n        ok(\"\\x{178}\" =~ /\\xFF/i, \"Y WITH DIAERESIS u =~ l\");\n        ok(\"\\x{178}\" =~ /\\x{178}/i, \"Y WITH DIAERESIS u =~ u\");\n\n        # U+00FF with U+05D0 (non-casing Hebrew letter).\n        ok(\"\\xFF\\x{5D0}\" =~ /\\xFF\\x{5D0}/i, \"Y WITH DIAERESIS l =~ l\");\n        ok(\"\\xFF\\x{5D0}\" =~ /\\x{178}\\x{5D0}/i, \"Y WITH DIAERESIS l =~ u\");\n        ok(\"\\x{178}\\x{5D0}\" =~ /\\xFF\\x{5D0}/i, \"Y WITH DIAERESIS u =~ l\");\n        ok(\"\\x{178}\\x{5D0}\" =~ /\\x{178}\\x{5D0}/i, \"Y WITH DIAERESIS u =~ u\");\n\n        # U+0100.\n        ok(\"\\x{100}\" =~ /\\x{100}/i, \"A WITH MACRON u =~ u\");\n        ok(\"\\x{100}\" =~ /\\x{101}/i, \"A WITH MACRON u =~ l\");\n        ok(\"\\x{101}\" =~ /\\x{100}/i, \"A WITH MACRON l =~ u\");\n        ok(\"\\x{101}\" =~ /\\x{101}/i, \"A WITH MACRON l =~ l\");\n    }\n\n    {\n        use utf8;\n        ok(\"abc\" =~ /a\u0085b\u0085c/x, \"NEL is white-space under /x\");\n    }\n\n    {\n        ok('a(b)c' =~ qr(a\\(b\\)c), \"'\\\\(' is a literal in qr(...)\");\n        ok('a[b]c' =~ qr[a\\[b\\]c], \"'\\\\[' is a literal in qr[...]\");\n        ok('a{3}c' =~ qr{a\\{3\\}c},  # Only failed when { could be a meta\n              \"'\\\\{' is a literal in qr{...}, where it could be a quantifier\");\n\n        # This one is for completeness\n        ok('a<b>c' =~ qr<a\\<b\\>c>, \"'\\\\<' is a literal in qr<...>)\");\n    }\n\n    {   # Was getting optimized into EXACT (non-folding node)\n        my $x = qr/[x]/i;\n        utf8::upgrade($x);\n        like(\"X\", qr/$x/, \"UTF-8 of /[x]/i matches upper case\");\n    }\n\nSKIP: {   # make sure we get an error when \\p{} cannot load Unicode tables\n        skip(\"Unicode tables always now loaded\", 1);\n        fresh_perl_like(<<'        prog that cannot load uni tables',\n            BEGIN {\n                @INC = '../lib';\n                require utf8; require 'utf8_heavy.pl';\n                @INC = ();\n            }\n            $name = 'A B';\n            if ($name =~ /(\\p{IsUpper}) (\\p{IsUpper})/){\n                print \"It's good! >$1< >$2<\\n\";\n            } else {\n                print \"It's not good...\\n\";\n            }\n        prog that cannot load uni tables\n                  qr/^Can't locate unicore\\/Heavy\\.pl(?x:\n                   )|^Can't find Unicode property definition/,\n                  undef,\n                 '\\p{} should not fail silently when uni tables evanesce');\n    }\n\n    {   # Special handling of literal-ended ranges in [...] was breaking this\n        use utf8;\n        like(\"\u00ff\", qr/[\u00ff-\u00ff]/, \"\\\"\u00ff\\\" should match [\u00ff-\u00ff]\");\n    }\n\n    {\t# [perl #123539]\n        like(\"TffffffffffffTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff\", qr/TffffffffffffTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff/il, \"\");\n        like(\"TffffffffffffT\\x{100}TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff\", qr/TffffffffffffT\\x{100}TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff/il, \"\");\n    }\n\n\t{\t# [perl #123604]\n\t\tmy($s, $x, @x) = ('abc', 'a', 'd');\n\t\tmy $long = 'b' x 2000;\n\t\tmy $eval = q{$s =~ m{$x[bbb]c} ? 1 : 0};\n\t\t$eval =~ s{bbb}{$long};\n\t\tmy $match = eval $eval;\n\t\tok(1, \"did not crash\");\n\t\tok($match, \"[bbb...] resolved as character class, not subscript\");\n\t}\n\n\t{\t# [perl #123755]\n\t\tfor my $pat ('(??', '(?P', '(?i-') {\n\t\t\teval qq{ qr/$pat/ };\n\t\t\tok(1, \"qr/$pat/ did not crash\");\n\t\t\teval qq{ qr/${pat}\\x{123}/ };\n\t\t\tmy $e = $@;\n\t\t\tlike($e, qr{\\x{123}},\n\t\t\t\t\"qr/${pat}x/ shows x in error even if it's a wide character\");\n\t\t}\n\t}\n\n\t{\n\t\t# Expect one of these sizes to cause overflow and wrap to negative\n\t\tfor my $bits (32, 64) {\n\t\t\tmy $wrapneg = 2 ** ($bits - 2) * 3;\n\t\t\tfor my $sign ('', '-') {\n\t\t\t\tmy $pat = sprintf \"qr/(?%s%u)/\", $sign, $wrapneg;\n\t\t\t\teval $pat;\n\t\t\t\tok(1, \"big backref $pat did not crash\");\n\t\t\t}\n\t\t}\n\t}\n        {\n            # Test that we handle qr/\\8888888/ and variants without an infinite loop,\n            # we use a test within a test so we can todo it, and make sure we don't\n            # infinite loop our tests.\n            # NOTE - Do not put quotes in the code!\n            # NOTE - We have to triple escape the backref in the pattern below.\n            my $code='\n                BEGIN{require q(./test.pl);}\n                watchdog(3);\n                for my $len (1 .. 20) {\n                    my $eights= q(8) x $len;\n                    eval qq{ qr/\\\\\\\\$eights/ };\n                }\n                print q(No infinite loop here!);\n            ';\n            fresh_perl_is($code, \"No infinite loop here!\", {},\n                \"test that we handle things like m/\\\\888888888/ without infinite loops\" );\n        }\n\n        {   # Test that we handle some malformed UTF-8 without looping [perl\n            # #123562]\n\n            my $code='\n                BEGIN{require q(./test.pl);}\n                use Encode qw(_utf8_on);\n                # \\x80 and \\x41 are continuation bytes in their respective\n                # character sets\n                my $malformed = (ord(\"A\") == 65) ? \"a\\x80\\n\" : \"a\\x41\\n\";\n                utf8::downgrade($malformed);\n                _utf8_on($malformed);\n                watchdog(3);\n                $malformed =~ /(\\n\\r|\\r)$/;\n                print q(No infinite loop here!);\n            ';\n            fresh_perl_like($code, qr/Malformed UTF-8 character/, {},\n                \"test that we handle some UTF-8 malformations without looping\" );\n        }\n\n\t{\n\t\t# [perl #123843] hits SEGV trying to compile this pattern\n\t\tmy $match;\n\t\teval q{ ($match) = (\"xxyxxyxy\" =~ m{(x+(y(?1))*)}) };\n\t\tok(1, \"compiled GOSUB in CURLYM ok\");\n\t\tis($match, 'xxyxxyx', \"matched GOSUB in CURLYM\");\n\t}\n\n\t{\n\t\t# [perl #123852] doesn't avoid all the capture-related work with\n\t\t# //n, leading to possible memory corruption\n\t\teval q{ qr{()(?1)}n };\n\t\tmy $error = $@;\n\t\tok(1, \"qr{()(?1)}n didn't crash\");\n\t\tlike($error, qr{Reference to nonexistent group},\n\t\t\t\t'gave appropriate error for qr{()(?1)}n');\n\t}\n\n\t{\n            # [perl #126406] panic with unmatchable quantifier\n            my $code='\n                no warnings \"regexp\";\n                \"\" =~ m/(.0\\N{6,0}0\\N{6,0}000000000000000000000000000000000)/;\n            ';\n            fresh_perl_is($code, \"\", {},\n                            \"perl [#126406] panic\");\n\t}\n        {\n            my $bug=\"[perl #126182]\"; # test for infinite pattern recursion\n            for my $tuple (\n                    [ 'q(a)=~/(.(?2))((?<=(?=(?1)).))/', \"died\", \"look ahead left recursion fails fast\" ],\n                    [ 'q(aa)=~/(?R)a/', \"died\", \"left-recursion fails fast\", ],\n                    [ 'q(bbaa)=~/(?&x)(?(DEFINE)(?<x>(?&y)*a)(?<y>(?&x)*b))/',\n                        \"died\", \"inter-cyclic optional left recursion dies\" ],\n                    [ 'q(abc) =~ /a((?1)?)c/', \"died\", \"optional left recursion dies\" ],\n                    [ 'q(abc) =~ /a((?1)??)c/', \"died\", \"min mod left recursion dies\" ],\n                    [ 'q(abc) =~ /a((?1)*)c/', \"died\", \"* left recursion dies\" ],\n                    [ 'q(abc) =~ /a((?1)+)c/', \"died\", \"+ left recursion dies\" ],\n                    [ 'q(abc) =~ /a((?1){0,3})c/', \"died\", \"{0,3} left recursion fails fast\" ],\n\n                    [ 'q(aaabbb)=~/a(?R)?b/', \"matched\", \"optional self recursion works\" ],\n                    [ '\"((5maa-maa)(maa-3maa))\" =~ /(\\\\\\\\((?:[^()]++|(?0))*+\\\\\\\\))/', \"matched\",\n                        \"recursion and possessive captures\", \"((5maa-maa)(maa-3maa))\"],\n                    [ '\"((5maa-maa)(maa-3maa))\" =~ /(\\\\\\\\((?:[^()]++|(?1))*+\\\\\\\\))/', \"matched\",\n                        \"recursion and possessive captures\", \"((5maa-maa)(maa-3maa))\"],\n                    [ '\"((5maa-maa)(maa-3maa))\" =~ /(\\\\\\\\((?:[^()]+|(?0))*\\\\\\\\))/', \"matched\",\n                        \"recursion and possessive captures\", \"((5maa-maa)(maa-3maa))\"],\n                    [ '\"((5maa-maa)(maa-3maa))\" =~ /(\\\\\\\\((?:[^()]+|(?1))*\\\\\\\\))/', \"matched\",\n                        \"recursion and possessive captures\", \"((5maa-maa)(maa-3maa))\"],\n            ) {\n                my ($expr, $expect, $test_name, $cap1)= @$tuple;\n                # avoid quotes in this code!\n                my $code='\n                    BEGIN{require q(./test.pl);}\n                    watchdog(3);\n                    my $status= eval(q{ !(' . $expr . ') ? q(failed) : ' .\n                        ($cap1 ? '($1 ne q['.$cap1.']) ? qq(badmatch:$1) : ' : '') .\n                        ' q(matched) })\n                                || ( ( $@ =~ /Infinite recursion/ ) ? qq(died) : q(strange-death) );\n                    print $status;\n                ';\n                fresh_perl_is($code, $expect, {}, \"$bug - $test_name\" );\n            }\n        }\n        {\n            fresh_perl_is('\n                BEGIN{require q(test.pl);}\n                watchdog(3);\n                $SIG{ALRM} = sub {print \"Timeout\\n\"; exit(1)};\n                alarm 1;\n                $_ = \"a\" x 1000 . \"b\" x 1000 . \"c\" x 1000;\n                /.*a.*b.*c.*[de]/;\n            ',\"Timeout\",{},\"Test Perl 73464\")\n        }\n\n        {   # [perl #128686], crashed the the interpreter\n            my $AE = chr utf8::unicode_to_native(0xC6);\n            my $ae = chr utf8::unicode_to_native(0xE6);\n            my $re = qr/[$ae\\s]/i;\n            ok($AE !~ $re, '/[\\xE6\\s]/i doesn\\'t match \\xC6 when not in UTF-8');\n            utf8::upgrade $AE;\n            ok($AE =~ $re, '/[\\xE6\\s]/i matches \\xC6 when in UTF-8');\n        }\n\n        {\n            is(0+(\"\\n\" =~ m'\\n'), 1, q|m'\\n' should interpolate escapes|);\n        }\n\n        {\n            my $str = \"a\\xB6\";\n            ok( $str =~ m{^(a|a\\x{b6})$}, \"fix [perl #129950] - latin1 case\" );\n            utf8::upgrade($str);\n            ok( $str =~ m{^(a|a\\x{b6})$}, \"fix [perl #129950] - utf8 case\" );\n        }\n        {\n            my $got= run_perl( switches => [ '-l' ], prog => <<'EOF_CODE' );\n            my $died= !eval {\n                $_=qq(ab);\n                print;\n                my $p=qr/(?{ s!!x! })/;\n                /$p/;\n                print;\n                /a/;\n                /$p/;\n                print;\n                /b/;\n                /$p/;\n                print;\n                //;\n                1;\n            };\n            $error = $died ? ($@ || qq(Zombie)) : qq(none);\n            print $died ? qq(died) : qq(lived);\n            print qq(Error: $@);\nEOF_CODE\n            my @got= split /\\n/, $got;\n            is($got[0],\"ab\",\"empty pattern in regex codeblock: got expected start string\");\n            is($got[1],\"xab\",\n                \"empty pattern in regex codeblock: first subst with no last-match worked right\");\n            is($got[2],\"xxb\",\"empty pattern in regex codeblock: second subst worked right\");\n            is($got[3],\"xxx\",\"empty pattern in regex codeblock: third subst worked right\");\n            is($got[4],\"died\",\"empty pattern in regex codeblock: died as expected\");\n            like($got[5],qr/Error: Infinite recursion via empty pattern/,\n           \"empty pattern in regex codeblock: produced the right exception message\" );\n        }\n\n    # This test is based on the one directly above, which happened to\n    # leak. Repeat the test, but stripped down to the bare essentials\n    # of the leak, which is to die while executing a regex which is\n    # already the current regex, thus causing the saved outer set of\n    # capture offsets to leak. The test itself doesn't do anything\n    # except sit around hoping not to be triggered by ASan\n    {\n        eval {\n            my $s = \"abcd\";\n            $s =~ m{([abcd]) (?{ die if $1 eq 'd'; })}gx;\n            $s =~ //g;\n            $s =~ //g;\n            $s =~ //g;\n        };\n        pass(\"call to current regex doesn't leak\");\n    }\n\n\n\n    {\n        # [perl #130495] /x comment skipping stopped a byte short, leading\n        # to assertion failure or 'malformed utf-8 character\" warning\n        fresh_perl_is(\n            \"use utf8; m{a#\\x{124}}x\", '', {wide_chars => 1},\n            '[perl #130495] utf-8 character at end of /x comment should not misparse',\n        );\n    }\n    {\n        # [perl #130522] causes out-of-bounds read detected by clang with\n        # address=sanitized when length of the STCLASS string is greater than\n        # length of target string.\n        my $re = qr{(?=\\0z)\\0?z?$}i;\n        my($yes, $no) = (1, \"\");\n        for my $test (\n            [ $no,  undef,   '<undef>' ],\n            [ $no,  '',      '' ],\n            [ $no,  \"\\0\",    '\\0' ],\n            [ $yes, \"\\0z\",   '\\0z' ],\n            [ $no,  \"\\0z\\0\", '\\0z\\0' ],\n            [ $yes, \"\\0z\\n\", '\\0z\\n' ],\n        ) {\n            my($result, $target, $disp) = @$test;\n            no warnings qw/uninitialized/;\n            is($target =~ $re, $result, \"[perl #130522] with target '$disp'\");\n        }\n    }\n    {\n\t# [perl #129377] backref to an unmatched capture should not cause\n\t# reading before start of string.\n\tSKIP: {\n\t    skip \"no re-debug under miniperl\" if is_miniperl;\n\t    my $prog = <<'EOP';\nuse re qw(Debug EXECUTE);\n\"x\" =~ m{ () y | () \\1 }x;\nEOP\n\t    fresh_perl_like($prog, qr{\n\t\t\\A (?! .* ^ \\s+ - )\n\t    }msx, { stderr => 1 }, \"Offsets in debug output are not negative\");\n\t}\n    }\n    {\n        # buffer overflow\n\n        # This test also used to leak - fixed by the commit which added\n        # this line.\n\n        fresh_perl_is(\"BEGIN{\\$^H=0x200000}\\ns/[(?{//xx\",\n                      \"Unmatched [ in regex; marked by <-- HERE in m/[ <-- HERE (?{/ at (eval 1) line 1.\\n\",\n                      {}, \"buffer overflow for regexp component\");\n    }\n    {\n        # [perl #129281] buffer write overflow, detected by ASAN, valgrind\n        fresh_perl_is('/0(?0)|^*0(?0)|^*(^*())0|/', '', {}, \"don't bump whilem_c too much\");\n    }\n    {\n        # RT #131893 - fails with ASAN -fsanitize=undefined\n        fresh_perl_is('qr/0(0?(0||00*))|/', '', {}, \"integer overflow during compilation\");\n    }\n\n    {\n        # RT #131575 intuit skipping back from the end to find the highest\n        # possible start point, was potentially hopping back beyond pos()\n        # and crashing by calling fbm_instr with a negative length\n\n        my $text = \"=t=\\x{5000}\";\n        pos($text) = 3;\n        ok(scalar($text !~ m{(~*=[a-z]=)}g), \"RT #131575\");\n    }\n    {\n        fresh_perl_is('\"AA\" =~ m/AA{1,0}/','',{},\"handle OPFAIL insert properly\");\n    }\n    {\n        fresh_perl_is('$_=\"0\\x{1000000}\";/^000?\\0000/','',{},\"dont throw assert errors trying to fbm past end of string\");\n    }\n    {   # [perl $132227]\n        fresh_perl_is(\"('0ba' . ('ss' x 300)) =~ m/0B\\\\N{U+41}\" . $sharp_s x 150 . '/i and print \"1\\n\"',  1,{},\"Use of sharp s under /di that changes to /ui\");\n\n        # A variation, but as far as khw knows not part of 132227\n        fresh_perl_is(\"'0bssa' =~ m/0B\" . $sharp_s . \"\\\\N{U+41}\" . '/i and print \"1\\n\"',  1,{},\"Use of sharp s under /di that changes to /ui\");\n    }\n    {   # [perl $132164]\n        fresh_perl_is('m m0*0+\\Rm', \"\",{},\"Undefined behavior in address sanitizer\");\n    }\n    {   # [perl #133642]\n        fresh_perl_is('no warnings \"experimental::vlb\";\n                      m/((?<=(0?)))/', \"\",{},\"Was getting 'Double free'\");\n    }\n    {   # [perl #133782]\n        # this would panic on DEBUGGING builds\n        fresh_perl_is(<<'CODE', \"ok\\nok\\n\",{}, 'Bad length magic was left on $^R');\nwhile( \"\\N{U+100}bc\" =~ /(..?)(?{$^N})/g ) {\n  print \"ok\\n\" if length($^R)==length(\"$^R\");\n}\nCODE\n    }\n    {   # [perl #133871], ASAN/valgrind out-of-bounds access\n        fresh_perl_like('qr/(?|(())|())|//', qr/syntax error/, {}, \"[perl #133871]\");\n    }\n    {   # [perl #133871], ASAN/valgrind out-of-bounds access\n        fresh_perl_like('qr/\\p{nv:NAnq}/', qr/Can't find Unicode property definition/, {}, \"GH #17367\");\n    }\n    {   # GH #17370, ASAN/valgrind out-of-bounds access\n        fresh_perl_like('qr/\\p{nv:qnan}/', qr/Can't find Unicode property definition/, {}, \"GH #17370\");\n    }\n\n    {   # [perl #133921], segfault\n        fresh_perl_is('qr\u00040||\u00df+p00000F00000\u00f9\\Q00000\u00ff00000x00000x0c0e0\\Qx0\\Qx0\\x{0c!}\\;\\;\u00ee0\\x\u0000\u00ff\u00ff\u00ff\u00fe\u0000\u0000\u0000\u00f9\\Q`\\Qx`\u0000\u0001{0c!}\u0001e;\u0000\u0000\u0000\u00f9\\\u00f2`\\Qm`\\x{0c!}\\;\\;\u00ee\u00e7\u00ff \u0000\u007f\u00e7\u0000\u0000\u0000!\u0000F\u0005\u0000\u0000/;\u00ee\u00e7\u00ff\u00f9\\Q\u0000\u0001\u0000\u0000x\u0010\u00ff\u00ff\u00ff\u00ff\u0000\u0000\u0000\u00f9\u0000\u0000\u0000\u007f`x{0c!}\u0001e;\u0000\u0000\u0000\u00f9\\Q`\\Qx`\\x{c!}\\;\\;\u00ee\u00e7!}\\;\u00ee\u00e7\u00ff\u00f9\\Q\u0087 \\x\u0000\u00ff\u00ff\u00ff\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2`\\Qx`\\x{0c!};\\;\u00ee\u00e7\u00ff \u0000F\u0005\u0000n0t0\u0000c \u0000\u0080\u0001d;t \u0000\u0000\u0000\u00f9 \u0000\u007f\u00e7\u0080\u0000\u0000!00000000000000000000000m/00000000000000000000\u000e00000000000m/\u0010\u0010\u0010\u0010\\x{){} \u0010\u0010\u0010\u0010)|\u0010\u0010\u0004i', \"\", {}, \"[perl #133921]\");\n        fresh_perl_is('\u0004|\u00df+W0\u00fc0r0\\Qx0\\Qx0x0c0G00000000000000000O000000000x0x0x0c!}\\;\u00ee\u00e7\u00ff\u00f9\\Q0 \\x\u0000\u00ff\u00ff\u00ff\u00ff\u0000\u0000\u0000\u00f9\\Q`\\Qx`\u0000\u0001{0d ;\u0000\u0000\u0000\u00f9\\\u00f2`\\Qm`\\x{0c!}\\;\\;\u00ee\u00e7\u00ff \u0000\u007f\u00e7\u0000\u0000\u0000!\u0000F\u0005\u0000\u0000/;\u00ee\u00e7\u00ff\u00f9\\Q\u0000\u0001\u0000\u0000x\u0010\u00ff\u00ff\u00ff\u00ff\u0000\u0000\u0000\u00f9\u0000\u0000\u0000\u007f`x{0c!}\u0001;\u0000\u0000\u0000\u00f9\\Q`\\Qq`\\x{c!}\\;\\;\u00ee\u00e7!}\\;\u00ee\u00e7\u00ff\u00f9\\Q\u0087 \\x\u0000\u00ff\u00ff\u00ff\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2`\\Qx`\\x{0c!};\\;\u00ee\u00e7\u00ff \u00000000000F\u0005\u0000m0t0\u0000c \u0000\u0080\u0001d;t \u0000\u0000\u0000\u00f9 \u0000\u007f\u00e7\u0080\u0000\u0000!00000000000000000000000m/00000000000000000000\u000e00000000000m/\u0010\u0010\u0010\u0010\\x{){} \u0010\u0010\u0010\u0010)|\u0010\u0010\u0004\u0004i', \"\", {}, \"[perl #133921]\");\n\nfresh_perl_is('s\u0004|\u00df+W0\u00fc0f0\\Qx0\\Qx0x0c0G0xgive0000000000000O0h\u008d000x0 \\x\u00f2\u00ff\u00ff\u00ff\u0000\u0000\u00f9\\Q`\\Q\n\n\u001a\n\n\n\t\u00e7\n\n\n\n\n\n\n\n\n\n\n\n\n\u0005\n\n\nx{0c!}\\;\\;\u00e7\u00ff \u0000\u007fq0/i0/!\u0000F\u0005\u0000\u0000/;\u00ee\u00e7\u00ff\u00f9\\Q\u0000\u0001\u0000\u0000x\u0010\u00ff\u00ff\u00ff\u00ff\u0000\u0000\u0000\u00f9\u0000\u0000\u0000\u007f`x{0c!}\u0001e;\u0000\u0000\u0000\u00f9\\Q`\\Qx`\\x{0c!}\\;\u00ff\u00ff\u00ff\u00ff!}\\;\u00ee\u00e7\u00ff\u00f9\\Q\u0087\u0001\\x\u0000\u00ff\u00ff\u00ff\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2`\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2`\\Qx`\\x{0c!};\\;\u00ee\u00e7\u00ff \u0000u00000F\u0005\u0000000t0\u0000p \u0000\u0080\u0001d? \u0000\u0000\u0000\u00f9 \u0000\u007f\u00e7\u0080\u0000\u0000!00000000000000000000000m/00000000000000000000\u000e00000000000m/0\u0000\u0010\u0010\u0010\\\u0000\u0000\u0001\u0000} \u0010\u0010\u0010\u0010)|\u0010\u0010\u0004\u0004i', \"\", {}, \"[perl #133921]\");\n\n        fresh_perl_is('\u0004a a\u00fa\u0000\u0000\u00fav sWtrt\u0010\u0000\\\u00f3||\u00df+W\u000e\u00fc\u0016ef\u0000\u00f9\\Qx`\\Qx`\\x{1c!gGnuc given1111111111111O1111each\u008d111\\jx` \\x\u0000\u00f2\u00ff\u00ff\u00ff\u0000\u0000\u0000\u00f9\\Qx`\\Q\n\n\n\n\n\n\t\u00e7\n\n\n\n\n\n\n\n\n\n\n\n\n\u0005\n\n\nx{1c!}\\;\\;\u00ee\u00e7\u00ffp \u0000\u007fqr/elsif/!\u0000eF\u0005\u0000\u0000/;\u00ee\u00e7\u00ff\u00f9\\Q\u0000\u0001\u0000\u0000x\u0010\u00ff\u00ff\u00ff\u00ff\u0000\u0000\u0000\u00f9HQx\u0000\u0000\u0000\u007f`Lx{1c!}\u0001e;\u0000\u0000\u0000\u00f9\\Qx`\\Qx`\\x{1c!}\\;\u00ff\u00ff\u00ff\u00ffc!}\\;\u00ee\u00e7\u00ff\u00f9\\Qx\u0087\u0001\\x\u0000\u00ff\u00ff\u00ff\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2x`\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2x`\\Qx`\\x{1c!}8;\\;\u00ee\u00e7\u00ffp \u0000unshifteF\u0005\u0000normat0\u0000cmp \u0000\u0080\u0001d?not \u0000\u0000\u0000\u00f9p \u0000\u007f\u00e7\u0080\u0000\u0000!0000000000000000000000000m/000000000000000000000\u000e00000000000m/0R\u0000\u0010\u0010\u0010\\\u0000\u0000\u0001\u0000} \u0010\u0010\u0010\u0010)|\u0010\u0010\u0004\u0010\u0010\u0010\u0010\u0010\u0001\\a\u00ef||K??\u008fp\u0080\u00bf\u00ff\u00fff\u00fad{\\\u000e{\u0004gri\u0004\u0004{\\x{1x/}\u0000 \u00f0\u00b9Nunti\u00c0h', \"\", {}, \"[perl #133921]\");\n\n    fresh_perl_is('s\u0004|\u00df+W0\u00fc0f0\\Qx0\\Qx0x0c0g0c 000n0000000000000O0h\u008d000x0 \\x\u00f2\u00ff\u00ff\u00ff\u0000\u0000\u00f9\\Q`\\Q\n\n\n\n\n\n\t\u00e7\n\n\n\n\n\n\n\n\n\n\n\n\n\u0005\n\n\nx{0c!}\\;\\;\u00ee\u00e7\u00ff \u0000\u007f/0f/!\u0000F\u0005\u0000\u0000/;\u00ee\u00e7\u00ff\u00f9\\Q\u0000\u0001\u0000\u0000x\u0010\u00ff\u00ff\u00ff\u00ff\u0000\u0000\u0000\u00f9\u0000\u0000\u0000\u007f`x{0c!}\u0001;\u0000\u0000\u0000\u00f9\\Q`\\Qx`\\x{0c!}\\;\u00ff\u00ff\u00ff\u00ff!}\\;\u00ee\u00e7\u00ff\u00f9\\Q\u0087\u0001\\x\u0000\u00ff\u00ff\u00ff\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2`\u00ff\u0000\u0000>=\\Qx`\\Qx`\u0000\u0000\u00f9\\\u00f2`\\Qx`\\x{0c!};\\;\u00ee\u00e7\u00ff \u0000000t0F\u0005\u0000000t0\u0000p \u0000\u0080\u0001d?n \u0000\u0000\u0000\u00f9 \u0000\u007f\u00e7\u0080\u0000\u0000!00000000000000000000000m/00000000000000000000\u000e00000000000m/\u0000\u0010\u0010\u0010\\\u0000\u0000\u0001\u0000} \u0010\u0010\u0010\u0010)|\u0010\u0010\u0004\u0004i', \"\", {}, \"[perl #133933]\");\n    }\n\n    {   # perl #133998]\n        fresh_perl_is('print \"\\x{110000}\" =~ qr/(?l)|[^\\S\\pC\\s]/', 1, {},\n        '/[\\S\\s]/l works');\n    }\n\n    {   # perl #133995]\n        use utf8;\n        fresh_perl_is('\"\u03ad\u03b4\u03c9\u03c3\u03b1\u03bd \u03b5\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ae\u10d5\u10d4\" =~ m/[^0](?=0)0?/', \"\",\n                      {wide_chars => 1},\n                      '[^0] doesnt crash on UTF-8 target string');\n    }\n\n    {   # [perl #133992]  This is a tokenizer bug of parsing a pattern\n        fresh_perl_is(q:$z = do {\n                                use utf8;\n                                \"q!\u00d1\u0082\u00d0\u00b5\u00d1\u0081\u00d1\u0082! =~ m'\"\n                        };\n                        $z .= '\u00e8(?#\u0084';\n                        $z .= \"'\";\n                        eval $z;:, \"\", {}, 'foo');\n    }\n\n    {   # [perl #134325]\n        my $quote=\"\\\\Q\";\n        my $back=\"\\\\\\\\\";\n        my $ff=\"\\xff\";\n        my $s = sprintf \"/\\\\1|(|%s)%s%s   /i\",\n                        $quote x 8 . $back x 69,\n                        $quote x 5 . $back x 4,\n                        $ff x 48;\n        like(runperl(prog => \"$s\", stderr => 1), qr/Unmatched \\(/);\n   }\n\nSKIP:\n    {   # [perl #134334], Assertion failure\n        my $utf8_locale = find_utf8_ctype_locale();\n        skip \"no UTF-8 locale available\" unless $utf8_locale;\n        fresh_perl_like(\"use POSIX; POSIX::setlocale(&LC_CTYPE, '$utf8_locale'); 'ssss' =~ /\\xDF+?sX/il;\",\n                        qr/^$/,\n                        {},\n                        \"Assertion failure matching /il on single char folding to multi\");\n    }\n\n    # gh17490: test recursion check\n    {\n        my $eval = '(?{1})';\n        my $re = sprintf '(?&FOO)(?(DEFINE)(?<FOO>%sfoo))', $eval x 20;\n        my $result = eval qq{\"foo\" =~ /$re/};\n        is($@ // '', '', \"many evals did not die\");\n        ok($result, \"regexp correctly matched\");\n    }\n\n    # gh16947: test regexp corruption (GOSUB)\n    {\n        fresh_perl_is(q{\n            'xy' =~ /x(?0)|x(?|y|y)/ && print 'ok'\n        }, 'ok', {}, 'gh16947: test regexp corruption (GOSUB)');\n    }\n    # gh16947: test fix doesn't break SUSPEND\n    {\n        fresh_perl_is(q{ 'sx' =~ m{ss++}i; print 'ok' },\n                'ok', {}, \"gh16947: test fix doesn't break SUSPEND\");\n    }\n\n    # gh17743: more regexp corruption via GOSUB\n    {\n        fresh_perl_is(q{\n            \"0\" =~ /((0(?0)|000(?|0000|0000)(?0))|)/; print \"ok\"\n        }, 'ok', {}, 'gh17743: test regexp corruption (1)');\n\n        fresh_perl_is(q{\n            \"000000000000\" =~ /(0(())(0((?0)())|000(?|\\x{ef}\\x{bf}\\x{bd}|\\x{ef}\\x{bf}\\x{bd}))|)/;\n            print \"ok\"\n        }, 'ok', {}, 'gh17743: test regexp corruption (2)');\n    }\n\n} # End of sub run_tests\n\n1;\n\n#\n# ex: set ts=8 sts=4 sw=4 et:\n#\n"], "filenames": ["embed.fnc", "embed.h", "proto.h", "regcomp.c", "t/re/pat.t"], "buggy_code_start_loc": [2483, 1242, 5662, 108, 28], "buggy_code_end_loc": [2484, 1243, 5663, 8239, 2145], "fixing_code_start_loc": [2483, 1242, 5662, 109, 28], "fixing_code_end_loc": [2484, 1243, 5663, 8255, 2170], "type": "CWE-120", "message": "regcomp.c in Perl before 5.30.3 allows a buffer overflow via a crafted regular expression because of recursive S_study_chunk calls.", "other": {"cve": {"id": "CVE-2020-12723", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-05T15:15:10.800", "lastModified": "2022-05-12T15:00:57.640", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "regcomp.c in Perl before 5.30.3 allows a buffer overflow via a crafted regular expression because of recursive S_study_chunk calls."}, {"lang": "es", "value": "En el archivo regcomp.c en Perl versiones anteriores a 5.30.3, permite un desbordamiento del b\u00fafer por medio de una expresi\u00f3n regular dise\u00f1ada debido a llamadas recursivas de la funci\u00f3n S_study_chunk"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:perl:perl:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.30.3", "matchCriteriaId": "C171B203-3DAA-43B7-A0BE-DDB0895EB744"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_workflow_automation:-:*:*:*:*:*:*:*", "matchCriteriaId": "5735E553-9731-4AAC-BCFF-989377F817B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snap_creator_framework:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F4754FB-E3EB-454A-AB1A-AE3835C5350C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_billing_and_revenue_management:12.0.0.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "2ECD5E79-5C1B-42E9-BE0B-A034EE2D632D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_billing_and_revenue_management:12.0.0.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "E39D442D-1997-49AF-8B02-5640BE2A26CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_diameter_signaling_router:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndIncluding": "8.5.0", "matchCriteriaId": "C88D46AF-459D-4917-9403-0F63FEC83512"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_eagle_application_processor:*:*:*:*:*:*:*:*", "versionStartIncluding": "16.1.0", "versionEndIncluding": "16.4.0", "matchCriteriaId": "1A0E3537-CB5A-40BF-B42C-CED9211B8892"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_eagle_lnp_application_processor:10.1:*:*:*:*:*:*:*", "matchCriteriaId": "996861FC-0089-4BED-8E46-F2B76037EA65"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_eagle_lnp_application_processor:10.2:*:*:*:*:*:*:*", "matchCriteriaId": "37764AF5-E42E-461E-AA43-763D21B3DCE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_lsms:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.1", "versionEndIncluding": "13.4", "matchCriteriaId": "806AF4AF-12FB-4222-84E4-BC9D44EFF09F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_offline_mediation_controller:12.0.0.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "49ACFC73-A509-4D1C-8FC3-F68F495AB055"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_performance_intelligence_center:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.3.0.0.0", "versionEndIncluding": "10.3.0.2.1", "matchCriteriaId": "977CA754-6CE0-4FCB-9683-D81B7A15449D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_performance_intelligence_center:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.4.0.1.0", "versionEndIncluding": "10.4.0.3.1", "matchCriteriaId": "29A3F7EF-2A69-427F-9F75-DDDBEE34BA2B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:configuration_manager:12.1.2.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "495DECD7-B14F-4D59-B3E1-30BF9B267475"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_manager_base_platform:13.4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "D26F3E23-F1A9-45E7-9E5F-0C0A24EE3783"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:sd-wan_edge:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "78C99571-0F3C-43E6-84B3-7D80E045EF8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:sd-wan_edge:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "77E39D5C-5EFA-4FEB-909E-0A92004F2563"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:sd-wan_edge:9.1:*:*:*:*:*:*:*", "matchCriteriaId": "06816711-7C49-47B9-A9D7-FB18CC3F42F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:tekelec_platform_distribution:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.4.0", "versionEndIncluding": "7.7.1", "matchCriteriaId": "26F05F85-7458-4C8F-B93F-93C92E506A40"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00044.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/Perl/perl5/blob/blead/pod/perl5303delta.pod", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Perl/perl5/compare/v5.30.2...v5.30.3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Perl/perl5/issues/16947", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Perl/perl5/issues/17743", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/perl/perl5/commit/66bbb51b93253a3f87d11c2695cfb7bdb782184a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IN3TTBO5KSGWE5IRIKDJ5JSQRH7ANNXE/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202006-03", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200611-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com//security-alerts/cpujul2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuApr2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2022.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuoct2020.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuoct2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/perl/perl5/commit/66bbb51b93253a3f87d11c2695cfb7bdb782184a"}}