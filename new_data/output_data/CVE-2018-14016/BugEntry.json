{"buggy_code": ["/* radare2 - LGPL - Copyright 2016-2017 - Davis, Alex Kornitzer */\n\n#include <r_util.h>\n\n#include \"mdmp.h\"\n\nut64 r_bin_mdmp_get_paddr(struct r_bin_mdmp_obj *obj, ut64 vaddr) {\n\t/* FIXME: Will only resolve exact matches, probably no need to fix as\n\t** this function will become redundant on the optimisation stage */\n\tstruct minidump_memory_descriptor64 *memory;\n\tut64 index, paddr = 0;\n\tRListIter *it;\n\n\t/* Loop through the memories sections looking for a match */\n\tindex = obj->streams.memories64.base_rva;\n\tr_list_foreach (obj->streams.memories64.memories, it, memory) {\n\t\tif (vaddr == memory->start_of_memory_range) {\n\t\t\tpaddr = index;\n\t\t\tbreak;\n\t\t}\n\t\tindex += memory->data_size;\n\t}\n\treturn paddr;\n}\n\nstruct minidump_memory_info *r_bin_mdmp_get_mem_info(struct r_bin_mdmp_obj *obj, ut64 vaddr) {\n\tstruct minidump_memory_info *mem_info;\n\tRListIter *it;\n\n\tif (!obj) return NULL;\n\n\tr_list_foreach (obj->streams.memory_infos, it, mem_info) {\n\t\tif (mem_info->allocation_base && vaddr == mem_info->base_address) {\n\t\t\treturn mem_info;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nut32 r_bin_mdmp_get_srwx(struct r_bin_mdmp_obj *obj, ut64 vaddr) {\n\tstruct minidump_memory_info *mem_info;\n\n\tif (!(mem_info = r_bin_mdmp_get_mem_info(obj, vaddr))) {\n\t\treturn 0;\n\t}\n\n\t/* FIXME: Have I got these mappings right, I am not sure I have!!! */\n\n\tswitch (mem_info->protect) {\n\tcase MINIDUMP_PAGE_READONLY:\n\t\treturn R_BIN_SCN_READABLE;\n\tcase MINIDUMP_PAGE_READWRITE:\n\t\treturn R_BIN_SCN_READABLE | R_BIN_SCN_WRITABLE;\n\tcase MINIDUMP_PAGE_EXECUTE:\n\t\treturn R_BIN_SCN_EXECUTABLE;\n\tcase MINIDUMP_PAGE_EXECUTE_READ:\n\t\treturn R_BIN_SCN_EXECUTABLE | R_BIN_SCN_READABLE;\n\tcase MINIDUMP_PAGE_EXECUTE_READWRITE:\n\t\treturn R_BIN_SCN_EXECUTABLE | R_BIN_SCN_READABLE | R_BIN_SCN_WRITABLE;\n\tcase MINIDUMP_PAGE_NOACCESS:\n\tcase MINIDUMP_PAGE_WRITECOPY:\n\tcase MINIDUMP_PAGE_EXECUTE_WRITECOPY:\n\tcase MINIDUMP_PAGE_GUARD:\n\tcase MINIDUMP_PAGE_NOCACHE:\n\tcase MINIDUMP_PAGE_WRITECOMBINE:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void r_bin_mdmp_free_pe32_bin(void *pe_bin_) {\n\tstruct Pe32_r_bin_mdmp_pe_bin *pe_bin = pe_bin_;\n\tif (pe_bin) {\n\t\tsdb_free (pe_bin->bin->kv);\n\t\tPe32_r_bin_pe_free (pe_bin->bin);\n\t\tR_FREE (pe_bin);\n\t}\n}\n\nstatic void r_bin_mdmp_free_pe64_bin(void *pe_bin_) {\n\tstruct Pe64_r_bin_mdmp_pe_bin *pe_bin = pe_bin_;\n\tif (pe_bin) {\n\t\tsdb_free (pe_bin->bin->kv);\n\t\tPe64_r_bin_pe_free (pe_bin->bin);\n\t\tR_FREE (pe_bin);\n\t}\n}\n\nvoid r_bin_mdmp_free(struct r_bin_mdmp_obj *obj) {\n\tif (!obj) return;\n\n\tr_list_free (obj->streams.ex_threads);\n\tr_list_free (obj->streams.memories);\n\tr_list_free (obj->streams.memories64.memories);\n\tr_list_free (obj->streams.memory_infos);\n\tr_list_free (obj->streams.modules);\n\tr_list_free (obj->streams.operations);\n\tr_list_free (obj->streams.thread_infos);\n\tr_list_free (obj->streams.threads);\n\tr_list_free (obj->streams.unloaded_modules);\n\n\tr_list_free (obj->pe32_bins);\n\tr_list_free (obj->pe64_bins);\n\n\tr_buf_free (obj->b);\n\tobj->b = NULL;\n\tfree (obj);\n\n\treturn;\n}\n\nstatic void r_bin_mdmp_init_parsing(struct r_bin_mdmp_obj *obj) {\n\t/* TODO: Handle unions, can we? */\n\t/* FIXME: Why are we getting struct missing errors when it finds them */\n\tsdb_set (obj->kv, \"mdmp_mem_state.cparse\",\n\t\t\"enum mdmp_mem_state { MEM_COMMIT=0x1000, \"\n\t\t\"MEM_FREE=0x10000, MEM_RESERVE=0x02000 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_mem_type.cparse\",\n\t\t\"enum mdmp_mem_type { MEM_IMAGE=0x1000000, \"\n\t\t\"MEM_MAPPED=0x40000, MEM_PRIVATE=0x20000 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_page_protect.cparse\",\n\t\t\"enum mdmp_page_protect { PAGE_NOACCESS=1, \"\n\t\t\"PAGE_READONLY=2, PAGE_READWRITE=4, PAGE_WRITECOPY=8, \"\n\t\t\"PAGE_EXECUTE=0x10, PAGE_EXECUTE_READ=0x20, \"\n\t\t\"PAGE_EXECUTE_READWRITE=0x40, PAGE_EXECUTE_WRITECOPY=0x80, \"\n\t\t\"PAGE_GUARD=0x100, PAGE_NOCACHE=0x200, \"\n\t\t\"PAGE_WRITECOMBINE=0x400, PAGE_TARGETS_INVALID=0x40000000 };\",\n\t\t0);\n\n\tsdb_set (obj->kv, \"mdmp_misc1_flags.cparse\",\n\t\t\"enum mdmp_misc1_flags { MINIDUMP_MISC1_PROCESS_ID=1, \"\n\t\t\"MINIDUMP_MISC1_PROCESS_TIMES=2, \"\n\t\t\"MINIDUMP_MISC1_PROCESSOR_POWER_INFO=4 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_processor_architecture.cparse\",\n\t\t\"enum mdmp_processor_architecture { \"\n\t\t\"PROCESSOR_ARCHITECTURE_INTEL=0, \"\n\t\t\"PROCESSOR_ARCHITECTURE_ARM=5, \"\n\t\t\"PROCESSOR_ARCHITECTURE_IA64=6, \"\n\t\t\"PROCESSOR_ARCHITECTURE_AMD64=9, \"\n\t\t\"PROCESSOR_ARCHITECTURE_UNKNOWN=0xffff };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_product_type.cparse\",\n\t\t\"enum mdmp_product_type { \"\n\t\t\"VER_NT_WORKSTATION=1, VER_NT_DOMAIN_CONTROLLER=2, \"\n\t\t\"VER_NT_SERVER=3 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_platform_id.cparse\",\n\t\t\"enum mdmp_platform_id { \"\n\t\t\"VER_PLATFORM_WIN32s=0, \"\n\t\t\"VER_PLATFORM_WIN32_WINDOWS=1, \"\n\t\t\"VER_PLATFORM_WIN32_NT=2 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_suite_mask.cparse\",\n\t\t\"enum mdmp_suite_mask { \"\n\t\t\"VER_SUITE_SMALLBUSINESS=1, VER_SUITE_ENTERPRISE=2, \"\n\t\t\"VER_SUITE_BACKOFFICE=4, VER_SUITE_TERMINAL=0x10, \"\n\t\t\"VER_SUITE_SMALLBUSINESS_RESTRICTED=0x20, \"\n\t\t\"VER_SUITE_EMBEDDEDNT=0x40, VER_SUITE_DATACENTER=0x80, \"\n\t\t\"VER_SUITE_SINGLEUSERTS=0x100, VER_SUITE_PERSONAL=0x200, \"\n\t\t\"VER_SUITE_BLADE=0x400, VER_SUITE_STORAGE_SERVER=0x2000, \"\n\t\t\"VER_SUITE_COMPUTE_SERVER=0x4000 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_callback_type.cparse\",\n\t\t\"enum mdmp_type { ModuleCallback=0,\"\n\t\t\"ThreadCallback=1, ThreadExCallback=2, \"\n\t\t\"IncludeThreadCallback=3, IncludeModuleCallback=4, \"\n\t\t\"MemoryCallback=5, CancelCallback=6, \"\n\t\t\"WriteKernelMinidumpCallback=7, \"\n\t\t\"KernelMinidumpStatusCallback=8, \"\n\t\t\"RemoveMemoryCallback=9, \"\n\t\t\"IncludeVmRegionCallback=10, \"\n\t\t\"IoStartCallback=11, IoWriteAllCallback=12, \"\n\t\t\"IoFinishCallback=13, ReadMemoryFailureCallback=14, \"\n\t\t\"SecondaryFlagsCallback=15 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_exception_code.cparse\",\n\t\t\"enum mdmp_exception_code { \"\n\t\t\"DBG_CONTROL_C=0x40010005, \"\n\t\t\"EXCEPTION_GUARD_PAGE_VIOLATION=0x80000001, \"\n\t\t\"EXCEPTION_DATATYPE_MISALIGNMENT=0x80000002, \"\n\t\t\"EXCEPTION_BREAKPOINT=0x80000003, \"\n\t\t\"EXCEPTION_SINGLE_STEP=0x80000004, \"\n\t\t\"EXCEPTION_ACCESS_VIOLATION=0xc0000005, \"\n\t\t\"EXCEPTION_IN_PAGE_ERROR=0xc0000006, \"\n\t\t\"EXCEPTION_INVALID_HANDLE=0xc0000008, \"\n\t\t\"EXCEPTION_ILLEGAL_INSTRUCTION=0xc000001d, \"\n\t\t\"EXCEPTION_NONCONTINUABLE_EXCEPTION=0xc0000025, \"\n\t\t\"EXCEPTION_INVALID_DISPOSITION=0xc0000026, \"\n\t\t\"EXCEPTION_ARRAY_BOUNDS_EXCEEDED=0xc000008c, \"\n\t\t\"EXCEPTION_FLOAT_DENORMAL_OPERAND=0xc000008d, \"\n\t\t\"EXCEPTION_FLOAT_DIVIDE_BY_ZERO=0xc000008e, \"\n\t\t\"EXCEPTION_FLOAT_INEXACT_RESULT=0xc000008f, \"\n\t\t\"EXCEPTION_FLOAT_INVALID_OPERATION=0xc0000090, \"\n\t\t\"EXCEPTION_FLOAT_OVERFLOW=0xc0000091, \"\n\t\t\"EXCEPTION_FLOAT_STACK_CHECK=0xc0000092, \"\n\t\t\"EXCEPTION_FLOAT_UNDERFLOW=0xc0000093, \"\n\t\t\"EXCEPTION_INTEGER_DIVIDE_BY_ZERO=0xc0000094, \"\n\t\t\"EXCEPTION_INTEGER_OVERFLOW=0xc0000095, \"\n\t\t\"EXCEPTION_PRIVILEGED_INSTRUCTION=0xc0000096, \"\n\t\t\"EXCEPTION_STACK_OVERFLOW=0xc00000fd, \"\n\t\t\"EXCEPTION_POSSIBLE_DEADLOCK=0xc0000194 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_exception_flags.cparse\",\n\t\t\"enum mdmp_exception_flags { \"\n\t\t\"EXCEPTION_CONTINUABLE=0, \"\n\t\t\"EXCEPTION_NONCONTINUABLE=1 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_handle_object_information_type.cparse\",\n\t\t\"enum mdmp_handle_object_information_type { \"\n\t\t\"MiniHandleObjectInformationNone=0, \"\n\t\t\"MiniThreadInformation1=1, MiniMutantInformation1=2, \"\n\t\t\"MiniMutantInformation2=3, MiniMutantProcessInformation1=4, \"\n\t\t\"MiniProcessInformation2=5 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_secondary_flags.cparse\",\n\t\t\"enum mdmp_secondary_flags { \"\n\t\t\"MiniSecondaryWithoutPowerInfo=0 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_stream_type.cparse\",\n\t\t\"enum mdmp_stream_type { UnusedStream=0, \"\n\t\t\"ReservedStream0=1, ReservedStream1=2, \"\n\t\t\"ThreadListStream=3, ModuleListStream=4, \"\n\t\t\"MemoryListStream=5, ExceptionStream=6, \"\n\t\t\"SystemInfoStream=7, ThreadExListStream=8, \"\n\t\t\"Memory64ListStream=9, CommentStreamA=10, \"\n\t\t\"CommentStreamW=11, HandleDataStream=12, \"\n\t\t\"FunctionTableStream=13, UnloadedModuleListStream=14, \"\n\t\t\"MiscInfoStream=15, MemoryInfoListStream=16, \"\n\t\t\"ThreadInfoListStream=17, \"\n\t\t\"HandleOperationListStream=18, \"\n\t\t\"LastReservedStream=0xffff };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_type.cparse\", \"enum mdmp_type { \"\n\t\t\"MiniDumpNormal=0x0, \"\n\t\t\"MiniDumpWithDataSegs=0x1, \"\n\t\t\"MiniDumpWithFullMemory=0x2, \"\n\t\t\"MiniDumpWithHandleData=0x4, \"\n\t\t\"MiniDumpFilterMemory=0x8, \"\n\t\t\"MiniDumpScanMemory=0x10, \"\n\t\t\"MiniDumpWithUnloadedModule=0x20, \"\n\t\t\"MiniDumpWihinDirectlyReferencedMemory=0x40, \"\n\t\t\"MiniDumpFilterWithModulePaths=0x80,\"\n\t\t\"MiniDumpWithProcessThreadData=0x100, \"\n\t\t\"MiniDumpWithPrivateReadWriteMemory=0x200, \"\n\t\t\"MiniDumpWithoutOptionalDate=0x400, \"\n\t\t\"MiniDumpWithFullMemoryInfo=0x800, \"\n\t\t\"MiniDumpWithThreadInfo=0x1000, \"\n\t\t\"MiniDumpWithCodeSegs=0x2000, \"\n\t\t\"MiniDumpWithoutAuxiliaryState=0x4000, \"\n\t\t\"MiniDumpWithFullAuxiliaryState=0x8000, \"\n\t\t\"MiniDumpWithPrivateWriteCopyMemory=0x10000, \"\n\t\t\"MiniDumpIgnoreInaccessibleMemory=0x20000, \"\n\t\t\"MiniDumpWithTokenInformation=0x40000, \"\n\t\t\"MiniDumpWithModuleHeaders=0x80000, \"\n\t\t\"MiniDumpFilterTriage=0x100000, \"\n\t\t\"MiniDumpValidTypeFlags=0x1fffff };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_module_write_flags.cparse\",\n\t\t\"enum mdmp_module_write_flags { \"\n\t\t\"ModuleWriteModule=0, ModuleWriteDataSeg=2, \"\n\t\t\"ModuleWriteMiscRecord=4, ModuleWriteCvRecord=8, \"\n\t\t\"ModuleReferencedByMemory=0x10, ModuleWriteTlsData=0x20, \"\n\t\t\"ModuleWriteCodeSegs=0x40 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_thread_write_flags.cparse\",\n\t\t\"enum mdmp_thread_write_flags { \"\n\t\t\"ThreadWriteThread=0, ThreadWriteStack=2, \"\n\t\t\"ThreadWriteContext=4, ThreadWriteBackingStore=8, \"\n\t\t\"ThreadWriteInstructionWindow=0x10, \"\n\t\t\"ThreadWriteThreadData=0x20, \"\n\t\t\"ThreadWriteThreadInfo=0x40 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_context_flags.cparse\",\n\t\t\"enum mdmp_context_flags { CONTEXT_i386=0x10000, \"\n\t\t\"CONTEXT_CONTROL=0x10001, CONTEXT_INTEGER=0x10002, \"\n\t\t\"CONTEXT_SEGMENTS=0x10004, CONTEXT_FLOATING_POINT=0x10008, \"\n\t\t\"CONTEXT_DEBUG_REGISTERS=0x10010, \"\n\t\t\"CONTEXT_EXTENDED_REGISTERS=0x10020 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_location_descriptor.format\",\n\t\t\"dd DataSize RVA\", 0);\n\tsdb_set (obj->kv, \"mdmp_location_descriptor64.format\",\n\t\t\"qq DataSize RVA\", 0);\n\tsdb_set (obj->kv, \"mdmp_memory_descriptor.format\", \"q? \"\n\t\t\"StartOfMemoryRange \"\n\t\t\"(mdmp_location_descriptor)Memory\", 0);\n\tsdb_set (obj->kv, \"mdmp_memory_descriptor64.format\", \"qq \"\n\t\t\"StartOfMemoryRange DataSize\", 0);\n\n#if 0\n\t/* TODO: Flag dependent thus not fully implemented */\n\tsdb_set (obj->kv, \"mdmp_context.format\", \"[4]B \"\n\t\t\"(mdmp_context_flags)ContextFlags\", 0);\n#endif\n\n\tsdb_set (obj->kv, \"mdmp_vs_fixedfileinfo.format\", \"ddddddddddddd \"\n\t\t\"dwSignature dwStrucVersion dwFileVersionMs \"\n\t\t\"dwFileVersionLs dwProductVersionMs \"\n\t\t\"dwProductVersionLs dwFileFlagsMask dwFileFlags \"\n\t\t\"dwFileOs dwFileType dwFileSubtype dwFileDateMs \"\n\t\t\"dwFileDateLs\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_string.format\", \"dZ Length Buffer\", 0);\n}\n\nstatic bool r_bin_mdmp_init_hdr(struct r_bin_mdmp_obj *obj) {\n\tobj->hdr = (struct minidump_header *)obj->b->buf;\n\n\tif (obj->hdr->number_of_streams == 0) {\n\t\teprintf (\"[WARN] No streams present!\\n\");\n\t\treturn false;\n\t}\n\n\tif (obj->hdr->stream_directory_rva < sizeof (struct minidump_header))\n\t{\n\t\teprintf (\"[ERROR] RVA for directory resides in the header!\\n\");\n\t\treturn false;\n\t}\n\n\tif (obj->hdr->check_sum) {\n\t\teprintf (\"[INFO] Checksum present but needs validating!\\n\");\n\t\treturn false;\n\t}\n\n\tsdb_num_set (obj->kv, \"mdmp.hdr.time_date_stamp\", obj->hdr->time_date_stamp, 0);\n\tsdb_num_set (obj->kv, \"mdmp.hdr.flags\", obj->hdr->flags, 0);\n\tsdb_num_set (obj->kv, \"mdmp_header.offset\", 0, 0);\n\tsdb_set (obj->kv, \"mdmp_header.format\", \"[4]zddddt[8]B Signature \"\n\t\t\"Version NumberOfStreams StreamDirectoryRVA CheckSum \"\n\t\t\"TimeDateStamp (mdmp_type)Flags\", 0);\n\n\treturn true;\n}\n\nstatic bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct minidump_directory *entry) {\n\tint i;\n\n\tstruct minidump_handle_operation_list *handle_operation_list;\n\tstruct minidump_memory_list *memory_list;\n\tstruct minidump_memory64_list *memory64_list;\n\tstruct minidump_memory_info_list *memory_info_list;\n\tstruct minidump_module_list *module_list;\n\tstruct minidump_thread_list *thread_list;\n\tstruct minidump_thread_ex_list *thread_ex_list;\n\tstruct minidump_thread_info_list *thread_info_list;\n\tstruct minidump_unloaded_module_list *unloaded_module_list;\n\n\tstruct avrf_handle_operation *handle_operations;\n\tstruct minidump_memory_descriptor *memories;\n\tstruct minidump_memory_descriptor64 *memories64;\n\tstruct minidump_memory_info *memory_infos;\n\tstruct minidump_module *modules;\n\tstruct minidump_thread *threads;\n\tstruct minidump_thread_ex *ex_threads;\n\tstruct minidump_thread_info *thread_infos;\n\tstruct minidump_unloaded_module *unloaded_modules;\n\n\t/* We could confirm data sizes but a malcious MDMP will always get around\n\t** this! But we can ensure that the data is not outside of the file */\n\tif (entry->location.rva + entry->location.data_size > obj->b->length) {\n\t\teprintf(\"[ERROR] Size Mismatch - Stream data is larger than file size!\\n\");\n\t\treturn false;\n\t}\n\n\tswitch (entry->stream_type) {\n\tcase THREAD_LIST_STREAM:\n\t\tthread_list = (struct minidump_thread_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_thread.format\", \"ddddq?? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? \"\n\t\t\t\t\"NumberOfThreads (mdmp_thread)Threads\",\n\t\t\t\tthread_list->number_of_threads),\n\t\t\t0);\n\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tfor (i = 0; i < thread_list->number_of_threads; i++) {\n\t\t\tthreads = (struct minidump_thread *)(&(thread_list->threads));\n\t\t\tr_list_append (obj->streams.threads, &(threads[i]));\n\t\t}\n\t\tbreak;\n\tcase MODULE_LIST_STREAM:\n\t\tmodule_list = (struct minidump_module_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_module.format\", \"qddtd???qq \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum \"\n\t\t\t\"TimeDateStamp ModuleNameRVA \"\n\t\t\t\"(mdmp_vs_fixedfileinfo)VersionInfo \"\n\t\t\t\"(mdmp_location_descriptor)CvRecord \"\n\t\t\t\"(mdmp_location_descriptor)MiscRecord \"\n\t\t\t\"Reserved0 Reserved1\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_module_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? \"\n\t\t\t\t\"NumberOfModule (mdmp_module)Modules\",\n\t\t\t\tmodule_list->number_of_modules,\n\t\t\t\t0),\n\t\t\t0);\n\n\t\tfor (i = 0; i < module_list->number_of_modules; i++) {\n\t\t\tmodules = (struct minidump_module *)(&(module_list->modules));\n\t\t\tr_list_append(obj->streams.modules, &(modules[i]));\n\t\t}\n\t\tbreak;\n\tcase MEMORY_LIST_STREAM:\n\t\tmemory_list = (struct minidump_memory_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? \"\n\t\t\t\t\"NumberOfMemoryRanges \"\n\t\t\t\t\"(mdmp_memory_descriptor)MemoryRanges \",\n\t\t\t\tmemory_list->number_of_memory_ranges,\n\t\t\t\t0),\n\t\t\t0);\n\n\t\tfor (i = 0; i < memory_list->number_of_memory_ranges; i++) {\n\t\t\tmemories = (struct minidump_memory_descriptor *)(&(memory_list->memory_ranges));\n\t\t\tr_list_append (obj->streams.memories, &(memories[i]));\n\t\t}\n\t\tbreak;\n\tcase EXCEPTION_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.exception = (struct minidump_exception_stream *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_exception.format\", \"[4]E[4]Eqqdd[15]q \"\n\t\t\t\"(mdmp_exception_code)ExceptionCode \"\n\t\t\t\"(mdmp_exception_flags)ExceptionFlags \"\n\t\t\t\"ExceptionRecord ExceptionAddress \"\n\t\t\t\"NumberParameters __UnusedAlignment \"\n\t\t\t\"ExceptionInformation\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_exception_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_exception_stream.format\", \"dd?? \"\n\t\t\t\"ThreadId __Alignment \"\n\t\t\t\"(mdmp_exception)ExceptionRecord \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext\", 0);\n\n\t\tbreak;\n\tcase SYSTEM_INFO_STREAM:\n\t\tobj->streams.system_info = (struct minidump_system_info *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_system_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\t/* TODO: We need E as a byte! */\n\t\tsdb_set (obj->kv, \"mdmp_system_info.format\", \"[2]EwwbBddd[4]Ed[2]Ew[2]q \"\n\t\t\t\"(mdmp_processor_architecture)ProcessorArchitecture \"\n\t\t\t\"ProcessorLevel ProcessorRevision NumberOfProcessors \"\n\t\t\t\"(mdmp_product_type)ProductType \"\n\t\t\t\"MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId \"\n\t\t\t\"CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures\", 0);\n\n\t\tbreak;\n\tcase THREAD_EX_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tthread_ex_list = (struct minidump_thread_ex_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex.format\", \"ddddq??? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext \"\n\t\t\t\"(mdmp_memory_descriptor)BackingStore\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_ex_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? NumberOfThreads \"\n\t\t\t\t\"(mdmp_thread_ex)Threads\",\n\t\t\t\tthread_ex_list->number_of_threads, 0),\n\t\t\t0);\n\n\t\tfor (i = 0; i < thread_ex_list->number_of_threads; i++) {\n\t\t\tex_threads = (struct minidump_thread_ex *)(&(thread_ex_list->threads));\n\t\t\tr_list_append (obj->streams.ex_threads, &(ex_threads[i]));\n\t\t}\n\t\tbreak;\n\tcase MEMORY_64_LIST_STREAM:\n\t\tmemory64_list = (struct minidump_memory64_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory64_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory64_list.format\",\n\t\t\tsdb_fmt (\"qq[%i]? NumberOfMemoryRanges \"\n\t\t\t\t\"BaseRva \"\n\t\t\t\t\"(mdmp_memory_descriptor64)MemoryRanges\",\n\t\t\t\tmemory64_list->number_of_memory_ranges),\n\t\t\t0);\n\n\t\tobj->streams.memories64.base_rva = memory64_list->base_rva;\n\t\tfor (i = 0; i < memory64_list->number_of_memory_ranges; i++) {\n\t\t\tmemories64 = (struct minidump_memory_descriptor64 *)(&(memory64_list->memory_ranges));\n\t\t\tr_list_append (obj->streams.memories64.memories, &(memories64[i]));\n\t\t}\n\t\tbreak;\n\tcase COMMENT_STREAM_A:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_a = obj->b->buf + entry->location.rva;\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_a.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_a.format\",\n\t\t\t\"s CommentA\", 0);\n\n\t\tbreak;\n\tcase COMMENT_STREAM_W:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_w = obj->b->buf + entry->location.rva;\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_w.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_w.format\",\n\t\t\t\t\"s CommentW\", 0);\n\n\t\tbreak;\n\tcase HANDLE_DATA_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.handle_data = (struct minidump_handle_data_stream *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_data_stream.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_data_stream.format\", \"dddd \"\n\t\t\t\t\"SizeOfHeader SizeOfDescriptor \"\n\t\t\t\t\"NumberOfDescriptors Reserved\", 0);\n\t\tbreak;\n\tcase FUNCTION_TABLE_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.function_table = (struct minidump_function_table_stream *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_function_table_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_function_table_stream.format\", \"dddddd \"\n\t\t\t\"SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor \"\n\t\t\t\"SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad\",\n\t\t\t0);\n\t\tbreak;\n\tcase UNLOADED_MODULE_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tunloaded_module_list = (struct minidump_unloaded_module_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module.format\", \"qddtd \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum TimeDateStamp \"\n\t\t\t\"ModuleNameRva\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_unloaded_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\tfor (i = 0; i < unloaded_module_list->number_of_entries; i++) {\n\t\t\tunloaded_modules = (struct minidump_unloaded_module *)((ut8 *)&unloaded_module_list + sizeof (struct minidump_unloaded_module_list));\n\t\t\tr_list_append (obj->streams.unloaded_modules, &(unloaded_modules[i]));\n\t\t}\n\t\tbreak;\n\tcase MISC_INFO_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.misc_info.misc_info_1 = (struct minidump_misc_info *)(obj->b->buf + entry->location.rva);\n\n\t\t/* TODO: Handle different sizes */\n\t\tsdb_num_set (obj->kv, \"mdmp_misc_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_misc_info.format\", \"d[4]Bdtttddddd \"\n\t\t\t\"SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId \"\n\t\t\t\"ProcessCreateTime ProcessUserTime ProcessKernelTime \"\n\t\t\t\"ProcessorMaxMhz ProcessorCurrentMhz \"\n\t\t\t\"ProcessorMhzLimit ProcessorMaxIdleState \"\n\t\t\t\"ProcessorCurrentIdleState\", 0);\n\n\t\tbreak;\n\tcase MEMORY_INFO_LIST_STREAM:\n\t\tmemory_info_list = (struct minidump_memory_info_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_memory_info.format\",\n\t\t\t\"qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase \"\n\t\t\t\"(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize \"\n\t\t\t\"(mdmp_mem_state)State (mdmp_page_protect)Protect \"\n\t\t\t\"(mdmp_mem_type)Type __Alignment2\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_info_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_info_list.format\",\n\t\t\tsdb_fmt (\"ddq[%i]? SizeOfHeader SizeOfEntry \"\n\t\t\t\t\"NumberOfEntries (mdmp_memory_info)MemoryInfo\",\n\t\t\t\tmemory_info_list->number_of_entries),\n\t\t\t0);\n\n\t\tfor (i = 0; i < memory_info_list->number_of_entries; i++) {\n\t\t\tmemory_infos = (struct minidump_memory_info *)((ut8 *)memory_info_list + sizeof (struct minidump_memory_info_list));\n\t\t\tr_list_append (obj->streams.memory_infos, &(memory_infos[i]));\n\t\t}\n\t\tbreak;\n\tcase THREAD_INFO_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tthread_info_list = (struct minidump_thread_info_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_info.format\", \"ddddttttqq \"\n\t\t\t\"ThreadId DumpFlags DumpError ExitStatus CreateTime \"\n\t\t\t\"ExitTime KernelTime UserTime StartAddress Affinity\",\n\t\t\t0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_info_list.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_info_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\tfor (i = 0; i < thread_info_list->number_of_entries; i++) {\n\t\t\tthread_infos = (struct minidump_thread_info *)((ut8 *)thread_info_list + sizeof (struct minidump_thread_info_list));\n\t\t\tr_list_append (obj->streams.thread_infos, &(thread_infos[i]));\n\t\t}\n\t\tbreak;\n\tcase HANDLE_OPERATION_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\thandle_operation_list = (struct minidump_handle_operation_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_operation_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_operation_list.format\", \"dddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries Reserved\", 0);\n\n\t\tfor (i = 0; i < handle_operation_list->number_of_entries; i++) {\n\t\t\thandle_operations = (struct avrf_handle_operation *)((ut8 *)handle_operation_list + sizeof (struct minidump_handle_operation_list));\n\t\t\tr_list_append (obj->streams.operations, &(handle_operations[i]));\n\t\t}\n\n\t\tbreak;\n\tcase LAST_RESERVED_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tbreak;\n\tcase UNUSED_STREAM:\n\tcase RESERVED_STREAM_0:\n\tcase RESERVED_STREAM_1:\n\t\t/* Silently ignore reserved streams */\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"[WARN] Invalid or unsupported enumeration encountered %i\\n\", entry->stream_type);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tint i;\n\tut8 *directory_base;\n\tstruct minidump_directory *entry;\n\n\tdirectory_base = obj->b->buf + obj->hdr->stream_directory_rva;\n\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\n\t/* Parse each entry in the directory */\n\tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tentry = (struct minidump_directory *)(directory_base + (i * sizeof (struct minidump_directory)));\n\t\tr_bin_mdmp_init_directory_entry (obj, entry);\n\t}\n\n\treturn true;\n}\n\nstatic bool r_bin_mdmp_patch_pe_headers(RBuffer *pe_buf) {\n\tint i;\n\tPe64_image_dos_header dos_hdr;\n\tPe64_image_nt_headers nt_hdr;\n\tPe64_image_section_header *section_hdrs;\n\n\tr_buf_read_at (pe_buf, 0, (ut8 *)&dos_hdr, sizeof (Pe64_image_dos_header));\n\tr_buf_read_at (pe_buf, dos_hdr.e_lfanew, (ut8 *)&nt_hdr, sizeof (Pe64_image_nt_headers));\n\n\t/* Patch RawData in headers */\n\tsection_hdrs = (Pe64_image_section_header *)(pe_buf->buf + dos_hdr.e_lfanew + 4 + sizeof (Pe64_image_file_header) + nt_hdr.file_header.SizeOfOptionalHeader);\n\tfor (i = 0; i < nt_hdr.file_header.NumberOfSections; i++) {\n\t\tsection_hdrs[i].PointerToRawData = section_hdrs[i].VirtualAddress;\n\t}\n\n\treturn true;\n}\n\nstatic int check_pe32_bytes(const ut8 *buf, ut64 length) {\n\tunsigned int idx;\n\tif (!buf || length <= 0x3d) {\n\t\treturn false;\n\t}\n\tidx = (buf[0x3c] | (buf[0x3d]<<8));\n\tif (length > idx + 0x18 + 2) {\n\t\tif (!memcmp (buf, \"MZ\", 2) && !memcmp (buf+idx, \"PE\", 2) && !memcmp (buf+idx+0x18, \"\\x0b\\x01\", 2)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int check_pe64_bytes(const ut8 *buf, ut64 length) {\n\tint idx, ret = false;\n\tif (!buf || length <= 0x3d) {\n\t\treturn false;\n\t}\n\tidx = buf[0x3c] | (buf[0x3d]<<8);\n\tif (length >= idx + 0x20) {\n\t\tif (!memcmp (buf, \"MZ\", 2) && !memcmp (buf+idx, \"PE\", 2) && !memcmp (buf+idx+0x18, \"\\x0b\\x02\", 2)) {\n\t\t\tret = true;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic bool r_bin_mdmp_init_pe_bins(struct r_bin_mdmp_obj *obj) {\n\tbool dup;\n\tut64 paddr;\n\tstruct minidump_module *module;\n\tstruct Pe32_r_bin_mdmp_pe_bin *pe32_bin, *pe32_dup;\n\tstruct Pe64_r_bin_mdmp_pe_bin *pe64_bin, *pe64_dup;\n\tRBuffer *buf;\n\tRListIter *it, *it_dup;\n\n\tr_list_foreach (obj->streams.modules, it, module) {\n\t\t/* Duplicate modules can appear in the MDMP module list,\n\t\t** filtering them out seems to be the correct behaviour */\n\t\tif (!(paddr = r_bin_mdmp_get_paddr (obj, module->base_of_image))) {\n\t\t\tcontinue;\n\t\t}\n\t\tint left = 0;\n\t\tconst ut8 *b = r_buf_get_at (obj->b, paddr, &left);\n\t\tbuf = r_buf_new_with_bytes (b, R_MIN (left, module->size_of_image));\n\t\tdup = false;\n\t\tif (check_pe32_bytes (buf->buf, module->size_of_image)) {\n\t\t\tr_list_foreach(obj->pe32_bins, it_dup, pe32_dup) {\n\t\t\t\tif (pe32_dup->vaddr == module->base_of_image) {\n\t\t\t\t\tdup = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(pe32_bin = R_NEW0 (struct Pe32_r_bin_mdmp_pe_bin))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_bin_mdmp_patch_pe_headers (buf);\n\t\t\tpe32_bin->vaddr = module->base_of_image;\n\t\t\tpe32_bin->paddr = paddr;\n\t\t\tpe32_bin->bin = Pe32_r_bin_pe_new_buf (buf, 0);\n\n\t\t\tr_list_append (obj->pe32_bins, pe32_bin);\n\t\t} else if (check_pe64_bytes (buf->buf, module->size_of_image)) {\n\t\t\tr_list_foreach(obj->pe64_bins, it_dup, pe64_dup) {\n\t\t\t\tif (pe64_dup->vaddr == module->base_of_image) {\n\t\t\t\t\tdup = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(pe64_bin = R_NEW0 (struct Pe64_r_bin_mdmp_pe_bin))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_bin_mdmp_patch_pe_headers (buf);\n\t\t\tpe64_bin->vaddr = module->base_of_image;\n\t\t\tpe64_bin->paddr = paddr;\n\t\t\tpe64_bin->bin = Pe64_r_bin_pe_new_buf (buf, 0);\n\n\t\t\tr_list_append (obj->pe64_bins, pe64_bin);\n\t\t}\n\t\tr_buf_free (buf);\n\t}\n\treturn true;\n}\n\nstatic int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {\n\tr_bin_mdmp_init_parsing (obj);\n\n\tif (!r_bin_mdmp_init_hdr (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise header\\n\");\n\t\treturn false;\n\t}\n\n\tif (!r_bin_mdmp_init_directory (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise directory structures!\\n\");\n\t\treturn false;\n\t}\n\n\tif (!r_bin_mdmp_init_pe_bins (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise pe binaries!\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstruct r_bin_mdmp_obj *r_bin_mdmp_new_buf(struct r_buf_t *buf) {\n\tbool fail = false;\n\tstruct r_bin_mdmp_obj *obj = R_NEW0 (struct r_bin_mdmp_obj);\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\tobj->kv = sdb_new0 ();\n\tobj->b = r_buf_new ();\n\tobj->size = (ut32)buf->length;\n\n\tfail |= (!(obj->streams.ex_threads = r_list_new ()));\n\tfail |= (!(obj->streams.memories = r_list_new ()));\n\tfail |= (!(obj->streams.memories64.memories = r_list_new ()));\n\tfail |= (!(obj->streams.memory_infos = r_list_new ()));\n\tfail |= (!(obj->streams.modules = r_list_new ()));\n\tfail |= (!(obj->streams.operations = r_list_new ()));\n\tfail |= (!(obj->streams.thread_infos = r_list_new ()));\n\tfail |= (!(obj->streams.threads = r_list_new ()));\n\tfail |= (!(obj->streams.unloaded_modules = r_list_new ()));\n\n\tfail |= (!(obj->pe32_bins = r_list_newf (r_bin_mdmp_free_pe32_bin)));\n\tfail |= (!(obj->pe64_bins = r_list_newf (r_bin_mdmp_free_pe64_bin)));\n\n\tif (fail) {\n\t\tr_bin_mdmp_free (obj);\n\t\treturn NULL;\n\t}\n\n\tif (!r_buf_set_bytes (obj->b, buf->buf, buf->length)) {\n\t\tr_bin_mdmp_free (obj);\n\t\treturn NULL;\n\t}\n\n\tif (!r_bin_mdmp_init (obj)) {\n\t\tr_bin_mdmp_free (obj);\n\t\treturn NULL;\n\t}\n\n\treturn obj;\n}\n"], "fixing_code": ["/* radare2 - LGPL - Copyright 2016-2017 - Davis, Alex Kornitzer */\n\n#include <r_util.h>\n\n#include \"mdmp.h\"\n\nut64 r_bin_mdmp_get_paddr(struct r_bin_mdmp_obj *obj, ut64 vaddr) {\n\t/* FIXME: Will only resolve exact matches, probably no need to fix as\n\t** this function will become redundant on the optimisation stage */\n\tstruct minidump_memory_descriptor64 *memory;\n\tut64 index, paddr = 0;\n\tRListIter *it;\n\n\t/* Loop through the memories sections looking for a match */\n\tindex = obj->streams.memories64.base_rva;\n\tr_list_foreach (obj->streams.memories64.memories, it, memory) {\n\t\tif (vaddr == memory->start_of_memory_range) {\n\t\t\tpaddr = index;\n\t\t\tbreak;\n\t\t}\n\t\tindex += memory->data_size;\n\t}\n\treturn paddr;\n}\n\nstruct minidump_memory_info *r_bin_mdmp_get_mem_info(struct r_bin_mdmp_obj *obj, ut64 vaddr) {\n\tstruct minidump_memory_info *mem_info;\n\tRListIter *it;\n\n\tif (!obj) return NULL;\n\n\tr_list_foreach (obj->streams.memory_infos, it, mem_info) {\n\t\tif (mem_info->allocation_base && vaddr == mem_info->base_address) {\n\t\t\treturn mem_info;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nut32 r_bin_mdmp_get_srwx(struct r_bin_mdmp_obj *obj, ut64 vaddr) {\n\tstruct minidump_memory_info *mem_info;\n\n\tif (!(mem_info = r_bin_mdmp_get_mem_info(obj, vaddr))) {\n\t\treturn 0;\n\t}\n\n\t/* FIXME: Have I got these mappings right, I am not sure I have!!! */\n\n\tswitch (mem_info->protect) {\n\tcase MINIDUMP_PAGE_READONLY:\n\t\treturn R_BIN_SCN_READABLE;\n\tcase MINIDUMP_PAGE_READWRITE:\n\t\treturn R_BIN_SCN_READABLE | R_BIN_SCN_WRITABLE;\n\tcase MINIDUMP_PAGE_EXECUTE:\n\t\treturn R_BIN_SCN_EXECUTABLE;\n\tcase MINIDUMP_PAGE_EXECUTE_READ:\n\t\treturn R_BIN_SCN_EXECUTABLE | R_BIN_SCN_READABLE;\n\tcase MINIDUMP_PAGE_EXECUTE_READWRITE:\n\t\treturn R_BIN_SCN_EXECUTABLE | R_BIN_SCN_READABLE | R_BIN_SCN_WRITABLE;\n\tcase MINIDUMP_PAGE_NOACCESS:\n\tcase MINIDUMP_PAGE_WRITECOPY:\n\tcase MINIDUMP_PAGE_EXECUTE_WRITECOPY:\n\tcase MINIDUMP_PAGE_GUARD:\n\tcase MINIDUMP_PAGE_NOCACHE:\n\tcase MINIDUMP_PAGE_WRITECOMBINE:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void r_bin_mdmp_free_pe32_bin(void *pe_bin_) {\n\tstruct Pe32_r_bin_mdmp_pe_bin *pe_bin = pe_bin_;\n\tif (pe_bin) {\n\t\tsdb_free (pe_bin->bin->kv);\n\t\tPe32_r_bin_pe_free (pe_bin->bin);\n\t\tR_FREE (pe_bin);\n\t}\n}\n\nstatic void r_bin_mdmp_free_pe64_bin(void *pe_bin_) {\n\tstruct Pe64_r_bin_mdmp_pe_bin *pe_bin = pe_bin_;\n\tif (pe_bin) {\n\t\tsdb_free (pe_bin->bin->kv);\n\t\tPe64_r_bin_pe_free (pe_bin->bin);\n\t\tR_FREE (pe_bin);\n\t}\n}\n\nvoid r_bin_mdmp_free(struct r_bin_mdmp_obj *obj) {\n\tif (!obj) return;\n\n\tr_list_free (obj->streams.ex_threads);\n\tr_list_free (obj->streams.memories);\n\tr_list_free (obj->streams.memories64.memories);\n\tr_list_free (obj->streams.memory_infos);\n\tr_list_free (obj->streams.modules);\n\tr_list_free (obj->streams.operations);\n\tr_list_free (obj->streams.thread_infos);\n\tr_list_free (obj->streams.threads);\n\tr_list_free (obj->streams.unloaded_modules);\n\n\tr_list_free (obj->pe32_bins);\n\tr_list_free (obj->pe64_bins);\n\n\tr_buf_free (obj->b);\n\tobj->b = NULL;\n\tfree (obj);\n\n\treturn;\n}\n\nstatic void r_bin_mdmp_init_parsing(struct r_bin_mdmp_obj *obj) {\n\t/* TODO: Handle unions, can we? */\n\t/* FIXME: Why are we getting struct missing errors when it finds them */\n\tsdb_set (obj->kv, \"mdmp_mem_state.cparse\",\n\t\t\"enum mdmp_mem_state { MEM_COMMIT=0x1000, \"\n\t\t\"MEM_FREE=0x10000, MEM_RESERVE=0x02000 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_mem_type.cparse\",\n\t\t\"enum mdmp_mem_type { MEM_IMAGE=0x1000000, \"\n\t\t\"MEM_MAPPED=0x40000, MEM_PRIVATE=0x20000 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_page_protect.cparse\",\n\t\t\"enum mdmp_page_protect { PAGE_NOACCESS=1, \"\n\t\t\"PAGE_READONLY=2, PAGE_READWRITE=4, PAGE_WRITECOPY=8, \"\n\t\t\"PAGE_EXECUTE=0x10, PAGE_EXECUTE_READ=0x20, \"\n\t\t\"PAGE_EXECUTE_READWRITE=0x40, PAGE_EXECUTE_WRITECOPY=0x80, \"\n\t\t\"PAGE_GUARD=0x100, PAGE_NOCACHE=0x200, \"\n\t\t\"PAGE_WRITECOMBINE=0x400, PAGE_TARGETS_INVALID=0x40000000 };\",\n\t\t0);\n\n\tsdb_set (obj->kv, \"mdmp_misc1_flags.cparse\",\n\t\t\"enum mdmp_misc1_flags { MINIDUMP_MISC1_PROCESS_ID=1, \"\n\t\t\"MINIDUMP_MISC1_PROCESS_TIMES=2, \"\n\t\t\"MINIDUMP_MISC1_PROCESSOR_POWER_INFO=4 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_processor_architecture.cparse\",\n\t\t\"enum mdmp_processor_architecture { \"\n\t\t\"PROCESSOR_ARCHITECTURE_INTEL=0, \"\n\t\t\"PROCESSOR_ARCHITECTURE_ARM=5, \"\n\t\t\"PROCESSOR_ARCHITECTURE_IA64=6, \"\n\t\t\"PROCESSOR_ARCHITECTURE_AMD64=9, \"\n\t\t\"PROCESSOR_ARCHITECTURE_UNKNOWN=0xffff };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_product_type.cparse\",\n\t\t\"enum mdmp_product_type { \"\n\t\t\"VER_NT_WORKSTATION=1, VER_NT_DOMAIN_CONTROLLER=2, \"\n\t\t\"VER_NT_SERVER=3 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_platform_id.cparse\",\n\t\t\"enum mdmp_platform_id { \"\n\t\t\"VER_PLATFORM_WIN32s=0, \"\n\t\t\"VER_PLATFORM_WIN32_WINDOWS=1, \"\n\t\t\"VER_PLATFORM_WIN32_NT=2 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_suite_mask.cparse\",\n\t\t\"enum mdmp_suite_mask { \"\n\t\t\"VER_SUITE_SMALLBUSINESS=1, VER_SUITE_ENTERPRISE=2, \"\n\t\t\"VER_SUITE_BACKOFFICE=4, VER_SUITE_TERMINAL=0x10, \"\n\t\t\"VER_SUITE_SMALLBUSINESS_RESTRICTED=0x20, \"\n\t\t\"VER_SUITE_EMBEDDEDNT=0x40, VER_SUITE_DATACENTER=0x80, \"\n\t\t\"VER_SUITE_SINGLEUSERTS=0x100, VER_SUITE_PERSONAL=0x200, \"\n\t\t\"VER_SUITE_BLADE=0x400, VER_SUITE_STORAGE_SERVER=0x2000, \"\n\t\t\"VER_SUITE_COMPUTE_SERVER=0x4000 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_callback_type.cparse\",\n\t\t\"enum mdmp_type { ModuleCallback=0,\"\n\t\t\"ThreadCallback=1, ThreadExCallback=2, \"\n\t\t\"IncludeThreadCallback=3, IncludeModuleCallback=4, \"\n\t\t\"MemoryCallback=5, CancelCallback=6, \"\n\t\t\"WriteKernelMinidumpCallback=7, \"\n\t\t\"KernelMinidumpStatusCallback=8, \"\n\t\t\"RemoveMemoryCallback=9, \"\n\t\t\"IncludeVmRegionCallback=10, \"\n\t\t\"IoStartCallback=11, IoWriteAllCallback=12, \"\n\t\t\"IoFinishCallback=13, ReadMemoryFailureCallback=14, \"\n\t\t\"SecondaryFlagsCallback=15 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_exception_code.cparse\",\n\t\t\"enum mdmp_exception_code { \"\n\t\t\"DBG_CONTROL_C=0x40010005, \"\n\t\t\"EXCEPTION_GUARD_PAGE_VIOLATION=0x80000001, \"\n\t\t\"EXCEPTION_DATATYPE_MISALIGNMENT=0x80000002, \"\n\t\t\"EXCEPTION_BREAKPOINT=0x80000003, \"\n\t\t\"EXCEPTION_SINGLE_STEP=0x80000004, \"\n\t\t\"EXCEPTION_ACCESS_VIOLATION=0xc0000005, \"\n\t\t\"EXCEPTION_IN_PAGE_ERROR=0xc0000006, \"\n\t\t\"EXCEPTION_INVALID_HANDLE=0xc0000008, \"\n\t\t\"EXCEPTION_ILLEGAL_INSTRUCTION=0xc000001d, \"\n\t\t\"EXCEPTION_NONCONTINUABLE_EXCEPTION=0xc0000025, \"\n\t\t\"EXCEPTION_INVALID_DISPOSITION=0xc0000026, \"\n\t\t\"EXCEPTION_ARRAY_BOUNDS_EXCEEDED=0xc000008c, \"\n\t\t\"EXCEPTION_FLOAT_DENORMAL_OPERAND=0xc000008d, \"\n\t\t\"EXCEPTION_FLOAT_DIVIDE_BY_ZERO=0xc000008e, \"\n\t\t\"EXCEPTION_FLOAT_INEXACT_RESULT=0xc000008f, \"\n\t\t\"EXCEPTION_FLOAT_INVALID_OPERATION=0xc0000090, \"\n\t\t\"EXCEPTION_FLOAT_OVERFLOW=0xc0000091, \"\n\t\t\"EXCEPTION_FLOAT_STACK_CHECK=0xc0000092, \"\n\t\t\"EXCEPTION_FLOAT_UNDERFLOW=0xc0000093, \"\n\t\t\"EXCEPTION_INTEGER_DIVIDE_BY_ZERO=0xc0000094, \"\n\t\t\"EXCEPTION_INTEGER_OVERFLOW=0xc0000095, \"\n\t\t\"EXCEPTION_PRIVILEGED_INSTRUCTION=0xc0000096, \"\n\t\t\"EXCEPTION_STACK_OVERFLOW=0xc00000fd, \"\n\t\t\"EXCEPTION_POSSIBLE_DEADLOCK=0xc0000194 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_exception_flags.cparse\",\n\t\t\"enum mdmp_exception_flags { \"\n\t\t\"EXCEPTION_CONTINUABLE=0, \"\n\t\t\"EXCEPTION_NONCONTINUABLE=1 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_handle_object_information_type.cparse\",\n\t\t\"enum mdmp_handle_object_information_type { \"\n\t\t\"MiniHandleObjectInformationNone=0, \"\n\t\t\"MiniThreadInformation1=1, MiniMutantInformation1=2, \"\n\t\t\"MiniMutantInformation2=3, MiniMutantProcessInformation1=4, \"\n\t\t\"MiniProcessInformation2=5 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_secondary_flags.cparse\",\n\t\t\"enum mdmp_secondary_flags { \"\n\t\t\"MiniSecondaryWithoutPowerInfo=0 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_stream_type.cparse\",\n\t\t\"enum mdmp_stream_type { UnusedStream=0, \"\n\t\t\"ReservedStream0=1, ReservedStream1=2, \"\n\t\t\"ThreadListStream=3, ModuleListStream=4, \"\n\t\t\"MemoryListStream=5, ExceptionStream=6, \"\n\t\t\"SystemInfoStream=7, ThreadExListStream=8, \"\n\t\t\"Memory64ListStream=9, CommentStreamA=10, \"\n\t\t\"CommentStreamW=11, HandleDataStream=12, \"\n\t\t\"FunctionTableStream=13, UnloadedModuleListStream=14, \"\n\t\t\"MiscInfoStream=15, MemoryInfoListStream=16, \"\n\t\t\"ThreadInfoListStream=17, \"\n\t\t\"HandleOperationListStream=18, \"\n\t\t\"LastReservedStream=0xffff };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_type.cparse\", \"enum mdmp_type { \"\n\t\t\"MiniDumpNormal=0x0, \"\n\t\t\"MiniDumpWithDataSegs=0x1, \"\n\t\t\"MiniDumpWithFullMemory=0x2, \"\n\t\t\"MiniDumpWithHandleData=0x4, \"\n\t\t\"MiniDumpFilterMemory=0x8, \"\n\t\t\"MiniDumpScanMemory=0x10, \"\n\t\t\"MiniDumpWithUnloadedModule=0x20, \"\n\t\t\"MiniDumpWihinDirectlyReferencedMemory=0x40, \"\n\t\t\"MiniDumpFilterWithModulePaths=0x80,\"\n\t\t\"MiniDumpWithProcessThreadData=0x100, \"\n\t\t\"MiniDumpWithPrivateReadWriteMemory=0x200, \"\n\t\t\"MiniDumpWithoutOptionalDate=0x400, \"\n\t\t\"MiniDumpWithFullMemoryInfo=0x800, \"\n\t\t\"MiniDumpWithThreadInfo=0x1000, \"\n\t\t\"MiniDumpWithCodeSegs=0x2000, \"\n\t\t\"MiniDumpWithoutAuxiliaryState=0x4000, \"\n\t\t\"MiniDumpWithFullAuxiliaryState=0x8000, \"\n\t\t\"MiniDumpWithPrivateWriteCopyMemory=0x10000, \"\n\t\t\"MiniDumpIgnoreInaccessibleMemory=0x20000, \"\n\t\t\"MiniDumpWithTokenInformation=0x40000, \"\n\t\t\"MiniDumpWithModuleHeaders=0x80000, \"\n\t\t\"MiniDumpFilterTriage=0x100000, \"\n\t\t\"MiniDumpValidTypeFlags=0x1fffff };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_module_write_flags.cparse\",\n\t\t\"enum mdmp_module_write_flags { \"\n\t\t\"ModuleWriteModule=0, ModuleWriteDataSeg=2, \"\n\t\t\"ModuleWriteMiscRecord=4, ModuleWriteCvRecord=8, \"\n\t\t\"ModuleReferencedByMemory=0x10, ModuleWriteTlsData=0x20, \"\n\t\t\"ModuleWriteCodeSegs=0x40 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_thread_write_flags.cparse\",\n\t\t\"enum mdmp_thread_write_flags { \"\n\t\t\"ThreadWriteThread=0, ThreadWriteStack=2, \"\n\t\t\"ThreadWriteContext=4, ThreadWriteBackingStore=8, \"\n\t\t\"ThreadWriteInstructionWindow=0x10, \"\n\t\t\"ThreadWriteThreadData=0x20, \"\n\t\t\"ThreadWriteThreadInfo=0x40 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_context_flags.cparse\",\n\t\t\"enum mdmp_context_flags { CONTEXT_i386=0x10000, \"\n\t\t\"CONTEXT_CONTROL=0x10001, CONTEXT_INTEGER=0x10002, \"\n\t\t\"CONTEXT_SEGMENTS=0x10004, CONTEXT_FLOATING_POINT=0x10008, \"\n\t\t\"CONTEXT_DEBUG_REGISTERS=0x10010, \"\n\t\t\"CONTEXT_EXTENDED_REGISTERS=0x10020 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_location_descriptor.format\",\n\t\t\"dd DataSize RVA\", 0);\n\tsdb_set (obj->kv, \"mdmp_location_descriptor64.format\",\n\t\t\"qq DataSize RVA\", 0);\n\tsdb_set (obj->kv, \"mdmp_memory_descriptor.format\", \"q? \"\n\t\t\"StartOfMemoryRange \"\n\t\t\"(mdmp_location_descriptor)Memory\", 0);\n\tsdb_set (obj->kv, \"mdmp_memory_descriptor64.format\", \"qq \"\n\t\t\"StartOfMemoryRange DataSize\", 0);\n\n#if 0\n\t/* TODO: Flag dependent thus not fully implemented */\n\tsdb_set (obj->kv, \"mdmp_context.format\", \"[4]B \"\n\t\t\"(mdmp_context_flags)ContextFlags\", 0);\n#endif\n\n\tsdb_set (obj->kv, \"mdmp_vs_fixedfileinfo.format\", \"ddddddddddddd \"\n\t\t\"dwSignature dwStrucVersion dwFileVersionMs \"\n\t\t\"dwFileVersionLs dwProductVersionMs \"\n\t\t\"dwProductVersionLs dwFileFlagsMask dwFileFlags \"\n\t\t\"dwFileOs dwFileType dwFileSubtype dwFileDateMs \"\n\t\t\"dwFileDateLs\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_string.format\", \"dZ Length Buffer\", 0);\n}\n\nstatic bool r_bin_mdmp_init_hdr(struct r_bin_mdmp_obj *obj) {\n\tobj->hdr = (struct minidump_header *)obj->b->buf;\n\n\tif (obj->hdr->number_of_streams == 0) {\n\t\teprintf (\"[WARN] No streams present!\\n\");\n\t\treturn false;\n\t}\n\n\tif (obj->hdr->stream_directory_rva < sizeof (struct minidump_header))\n\t{\n\t\teprintf (\"[ERROR] RVA for directory resides in the header!\\n\");\n\t\treturn false;\n\t}\n\n\tif (obj->hdr->check_sum) {\n\t\teprintf (\"[INFO] Checksum present but needs validating!\\n\");\n\t\treturn false;\n\t}\n\n\tsdb_num_set (obj->kv, \"mdmp.hdr.time_date_stamp\", obj->hdr->time_date_stamp, 0);\n\tsdb_num_set (obj->kv, \"mdmp.hdr.flags\", obj->hdr->flags, 0);\n\tsdb_num_set (obj->kv, \"mdmp_header.offset\", 0, 0);\n\tsdb_set (obj->kv, \"mdmp_header.format\", \"[4]zddddt[8]B Signature \"\n\t\t\"Version NumberOfStreams StreamDirectoryRVA CheckSum \"\n\t\t\"TimeDateStamp (mdmp_type)Flags\", 0);\n\n\treturn true;\n}\n\nstatic bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct minidump_directory *entry) {\n\tint i;\n\n\tstruct minidump_handle_operation_list *handle_operation_list;\n\tstruct minidump_memory_list *memory_list;\n\tstruct minidump_memory64_list *memory64_list;\n\tstruct minidump_memory_info_list *memory_info_list;\n\tstruct minidump_module_list *module_list;\n\tstruct minidump_thread_list *thread_list;\n\tstruct minidump_thread_ex_list *thread_ex_list;\n\tstruct minidump_thread_info_list *thread_info_list;\n\tstruct minidump_unloaded_module_list *unloaded_module_list;\n\n\tstruct avrf_handle_operation *handle_operations;\n\tstruct minidump_memory_descriptor *memories;\n\tstruct minidump_memory_descriptor64 *memories64;\n\tstruct minidump_memory_info *memory_infos;\n\tstruct minidump_module *modules;\n\tstruct minidump_thread *threads;\n\tstruct minidump_thread_ex *ex_threads;\n\tstruct minidump_thread_info *thread_infos;\n\tstruct minidump_unloaded_module *unloaded_modules;\n\n\t/* We could confirm data sizes but a malcious MDMP will always get around\n\t** this! But we can ensure that the data is not outside of the file */\n\tif (entry->location.rva + entry->location.data_size > obj->b->length) {\n\t\teprintf (\"[ERROR] Size Mismatch - Stream data is larger than file size!\\n\");\n\t\treturn false;\n\t}\n\n\tswitch (entry->stream_type) {\n\tcase THREAD_LIST_STREAM:\n\t\tthread_list = (struct minidump_thread_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_thread.format\", \"ddddq?? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? \"\n\t\t\t\t\"NumberOfThreads (mdmp_thread)Threads\",\n\t\t\t\tthread_list->number_of_threads),\n\t\t\t0);\n\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tfor (i = 0; i < thread_list->number_of_threads; i++) {\n\t\t\tthreads = (struct minidump_thread *)(&(thread_list->threads));\n\t\t\tr_list_append (obj->streams.threads, &(threads[i]));\n\t\t}\n\t\tbreak;\n\tcase MODULE_LIST_STREAM:\n\t\tmodule_list = (struct minidump_module_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_module.format\", \"qddtd???qq \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum \"\n\t\t\t\"TimeDateStamp ModuleNameRVA \"\n\t\t\t\"(mdmp_vs_fixedfileinfo)VersionInfo \"\n\t\t\t\"(mdmp_location_descriptor)CvRecord \"\n\t\t\t\"(mdmp_location_descriptor)MiscRecord \"\n\t\t\t\"Reserved0 Reserved1\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_module_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? \"\n\t\t\t\t\"NumberOfModule (mdmp_module)Modules\",\n\t\t\t\tmodule_list->number_of_modules,\n\t\t\t\t0),\n\t\t\t0);\n\n\t\tfor (i = 0; i < module_list->number_of_modules; i++) {\n\t\t\tmodules = (struct minidump_module *)(&(module_list->modules));\n\t\t\tr_list_append(obj->streams.modules, &(modules[i]));\n\t\t}\n\t\tbreak;\n\tcase MEMORY_LIST_STREAM:\n\t\tmemory_list = (struct minidump_memory_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? \"\n\t\t\t\t\"NumberOfMemoryRanges \"\n\t\t\t\t\"(mdmp_memory_descriptor)MemoryRanges \",\n\t\t\t\tmemory_list->number_of_memory_ranges,\n\t\t\t\t0),\n\t\t\t0);\n\n\t\tfor (i = 0; i < memory_list->number_of_memory_ranges; i++) {\n\t\t\tmemories = (struct minidump_memory_descriptor *)(&(memory_list->memory_ranges));\n\t\t\tr_list_append (obj->streams.memories, &(memories[i]));\n\t\t}\n\t\tbreak;\n\tcase EXCEPTION_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.exception = (struct minidump_exception_stream *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_exception.format\", \"[4]E[4]Eqqdd[15]q \"\n\t\t\t\"(mdmp_exception_code)ExceptionCode \"\n\t\t\t\"(mdmp_exception_flags)ExceptionFlags \"\n\t\t\t\"ExceptionRecord ExceptionAddress \"\n\t\t\t\"NumberParameters __UnusedAlignment \"\n\t\t\t\"ExceptionInformation\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_exception_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_exception_stream.format\", \"dd?? \"\n\t\t\t\"ThreadId __Alignment \"\n\t\t\t\"(mdmp_exception)ExceptionRecord \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext\", 0);\n\n\t\tbreak;\n\tcase SYSTEM_INFO_STREAM:\n\t\tobj->streams.system_info = (struct minidump_system_info *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_system_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\t/* TODO: We need E as a byte! */\n\t\tsdb_set (obj->kv, \"mdmp_system_info.format\", \"[2]EwwbBddd[4]Ed[2]Ew[2]q \"\n\t\t\t\"(mdmp_processor_architecture)ProcessorArchitecture \"\n\t\t\t\"ProcessorLevel ProcessorRevision NumberOfProcessors \"\n\t\t\t\"(mdmp_product_type)ProductType \"\n\t\t\t\"MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId \"\n\t\t\t\"CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures\", 0);\n\n\t\tbreak;\n\tcase THREAD_EX_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tthread_ex_list = (struct minidump_thread_ex_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex.format\", \"ddddq??? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext \"\n\t\t\t\"(mdmp_memory_descriptor)BackingStore\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_ex_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? NumberOfThreads \"\n\t\t\t\t\"(mdmp_thread_ex)Threads\",\n\t\t\t\tthread_ex_list->number_of_threads, 0),\n\t\t\t0);\n\n\t\tfor (i = 0; i < thread_ex_list->number_of_threads; i++) {\n\t\t\tex_threads = (struct minidump_thread_ex *)(&(thread_ex_list->threads));\n\t\t\tr_list_append (obj->streams.ex_threads, &(ex_threads[i]));\n\t\t}\n\t\tbreak;\n\tcase MEMORY_64_LIST_STREAM:\n\t\tmemory64_list = (struct minidump_memory64_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory64_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory64_list.format\",\n\t\t\tsdb_fmt (\"qq[%i]? NumberOfMemoryRanges \"\n\t\t\t\t\"BaseRva \"\n\t\t\t\t\"(mdmp_memory_descriptor64)MemoryRanges\",\n\t\t\t\tmemory64_list->number_of_memory_ranges),\n\t\t\t0);\n\n\t\tobj->streams.memories64.base_rva = memory64_list->base_rva;\n\t\tfor (i = 0; i < memory64_list->number_of_memory_ranges; i++) {\n\t\t\tmemories64 = (struct minidump_memory_descriptor64 *)(&(memory64_list->memory_ranges));\n\t\t\tr_list_append (obj->streams.memories64.memories, &(memories64[i]));\n\t\t}\n\t\tbreak;\n\tcase COMMENT_STREAM_A:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_a = obj->b->buf + entry->location.rva;\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_a.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_a.format\",\n\t\t\t\"s CommentA\", 0);\n\n\t\tbreak;\n\tcase COMMENT_STREAM_W:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_w = obj->b->buf + entry->location.rva;\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_w.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_w.format\",\n\t\t\t\t\"s CommentW\", 0);\n\n\t\tbreak;\n\tcase HANDLE_DATA_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.handle_data = (struct minidump_handle_data_stream *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_data_stream.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_data_stream.format\", \"dddd \"\n\t\t\t\t\"SizeOfHeader SizeOfDescriptor \"\n\t\t\t\t\"NumberOfDescriptors Reserved\", 0);\n\t\tbreak;\n\tcase FUNCTION_TABLE_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.function_table = (struct minidump_function_table_stream *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_function_table_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_function_table_stream.format\", \"dddddd \"\n\t\t\t\"SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor \"\n\t\t\t\"SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad\",\n\t\t\t0);\n\t\tbreak;\n\tcase UNLOADED_MODULE_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tunloaded_module_list = (struct minidump_unloaded_module_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module.format\", \"qddtd \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum TimeDateStamp \"\n\t\t\t\"ModuleNameRva\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_unloaded_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\tfor (i = 0; i < unloaded_module_list->number_of_entries; i++) {\n\t\t\tunloaded_modules = (struct minidump_unloaded_module *)((ut8 *)&unloaded_module_list + sizeof (struct minidump_unloaded_module_list));\n\t\t\tr_list_append (obj->streams.unloaded_modules, &(unloaded_modules[i]));\n\t\t}\n\t\tbreak;\n\tcase MISC_INFO_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.misc_info.misc_info_1 = (struct minidump_misc_info *)(obj->b->buf + entry->location.rva);\n\n\t\t/* TODO: Handle different sizes */\n\t\tsdb_num_set (obj->kv, \"mdmp_misc_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_misc_info.format\", \"d[4]Bdtttddddd \"\n\t\t\t\"SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId \"\n\t\t\t\"ProcessCreateTime ProcessUserTime ProcessKernelTime \"\n\t\t\t\"ProcessorMaxMhz ProcessorCurrentMhz \"\n\t\t\t\"ProcessorMhzLimit ProcessorMaxIdleState \"\n\t\t\t\"ProcessorCurrentIdleState\", 0);\n\n\t\tbreak;\n\tcase MEMORY_INFO_LIST_STREAM:\n\t\tmemory_info_list = (struct minidump_memory_info_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_memory_info.format\",\n\t\t\t\"qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase \"\n\t\t\t\"(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize \"\n\t\t\t\"(mdmp_mem_state)State (mdmp_page_protect)Protect \"\n\t\t\t\"(mdmp_mem_type)Type __Alignment2\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_info_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_info_list.format\",\n\t\t\tsdb_fmt (\"ddq[%i]? SizeOfHeader SizeOfEntry \"\n\t\t\t\t\"NumberOfEntries (mdmp_memory_info)MemoryInfo\",\n\t\t\t\tmemory_info_list->number_of_entries),\n\t\t\t0);\n\n\t\tfor (i = 0; i < memory_info_list->number_of_entries; i++) {\n\t\t\tmemory_infos = (struct minidump_memory_info *)((ut8 *)memory_info_list + sizeof (struct minidump_memory_info_list));\n\t\t\tr_list_append (obj->streams.memory_infos, &(memory_infos[i]));\n\t\t}\n\t\tbreak;\n\tcase THREAD_INFO_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tthread_info_list = (struct minidump_thread_info_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_info.format\", \"ddddttttqq \"\n\t\t\t\"ThreadId DumpFlags DumpError ExitStatus CreateTime \"\n\t\t\t\"ExitTime KernelTime UserTime StartAddress Affinity\",\n\t\t\t0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_info_list.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_info_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\tfor (i = 0; i < thread_info_list->number_of_entries; i++) {\n\t\t\tthread_infos = (struct minidump_thread_info *)((ut8 *)thread_info_list + sizeof (struct minidump_thread_info_list));\n\t\t\tr_list_append (obj->streams.thread_infos, &(thread_infos[i]));\n\t\t}\n\t\tbreak;\n\tcase HANDLE_OPERATION_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\thandle_operation_list = (struct minidump_handle_operation_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_operation_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_operation_list.format\", \"dddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries Reserved\", 0);\n\n\t\tfor (i = 0; i < handle_operation_list->number_of_entries; i++) {\n\t\t\thandle_operations = (struct avrf_handle_operation *)((ut8 *)handle_operation_list + sizeof (struct minidump_handle_operation_list));\n\t\t\tr_list_append (obj->streams.operations, &(handle_operations[i]));\n\t\t}\n\n\t\tbreak;\n\tcase LAST_RESERVED_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tbreak;\n\tcase UNUSED_STREAM:\n\tcase RESERVED_STREAM_0:\n\tcase RESERVED_STREAM_1:\n\t\t/* Silently ignore reserved streams */\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"[WARN] Invalid or unsupported enumeration encountered %i\\n\", entry->stream_type);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tint i;\n\tstruct minidump_directory entry;\n\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\n\t/* Parse each entry in the directory */\n\tut64 rvadir = obj->hdr->stream_directory_rva;\n\tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tut32 delta = i * sizeof (struct minidump_directory);\n\t\tint r = r_buf_read_at (obj->b, rvadir + delta, (ut8*) &entry, sizeof (struct minidump_directory));\n\t\tif (r) {\n\t\t\tr_bin_mdmp_init_directory_entry (obj, &entry);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool r_bin_mdmp_patch_pe_headers(RBuffer *pe_buf) {\n\tint i;\n\tPe64_image_dos_header dos_hdr;\n\tPe64_image_nt_headers nt_hdr;\n\tPe64_image_section_header *section_hdrs;\n\n\tr_buf_read_at (pe_buf, 0, (ut8 *)&dos_hdr, sizeof (Pe64_image_dos_header));\n\tr_buf_read_at (pe_buf, dos_hdr.e_lfanew, (ut8 *)&nt_hdr, sizeof (Pe64_image_nt_headers));\n\n\t/* Patch RawData in headers */\n\tsection_hdrs = (Pe64_image_section_header *)(pe_buf->buf + dos_hdr.e_lfanew + 4 + sizeof (Pe64_image_file_header) + nt_hdr.file_header.SizeOfOptionalHeader);\n\tfor (i = 0; i < nt_hdr.file_header.NumberOfSections; i++) {\n\t\tsection_hdrs[i].PointerToRawData = section_hdrs[i].VirtualAddress;\n\t}\n\n\treturn true;\n}\n\nstatic int check_pe32_bytes(const ut8 *buf, ut64 length) {\n\tunsigned int idx;\n\tif (!buf || length <= 0x3d) {\n\t\treturn false;\n\t}\n\tidx = (buf[0x3c] | (buf[0x3d]<<8));\n\tif (length > idx + 0x18 + 2) {\n\t\tif (!memcmp (buf, \"MZ\", 2) && !memcmp (buf+idx, \"PE\", 2) && !memcmp (buf+idx+0x18, \"\\x0b\\x01\", 2)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int check_pe64_bytes(const ut8 *buf, ut64 length) {\n\tint idx, ret = false;\n\tif (!buf || length <= 0x3d) {\n\t\treturn false;\n\t}\n\tidx = buf[0x3c] | (buf[0x3d]<<8);\n\tif (length >= idx + 0x20) {\n\t\tif (!memcmp (buf, \"MZ\", 2) && !memcmp (buf+idx, \"PE\", 2) && !memcmp (buf+idx+0x18, \"\\x0b\\x02\", 2)) {\n\t\t\tret = true;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic bool r_bin_mdmp_init_pe_bins(struct r_bin_mdmp_obj *obj) {\n\tbool dup;\n\tut64 paddr;\n\tstruct minidump_module *module;\n\tstruct Pe32_r_bin_mdmp_pe_bin *pe32_bin, *pe32_dup;\n\tstruct Pe64_r_bin_mdmp_pe_bin *pe64_bin, *pe64_dup;\n\tRBuffer *buf;\n\tRListIter *it, *it_dup;\n\n\tr_list_foreach (obj->streams.modules, it, module) {\n\t\t/* Duplicate modules can appear in the MDMP module list,\n\t\t** filtering them out seems to be the correct behaviour */\n\t\tif (!(paddr = r_bin_mdmp_get_paddr (obj, module->base_of_image))) {\n\t\t\tcontinue;\n\t\t}\n\t\tint left = 0;\n\t\tconst ut8 *b = r_buf_get_at (obj->b, paddr, &left);\n\t\tbuf = r_buf_new_with_bytes (b, R_MIN (left, module->size_of_image));\n\t\tdup = false;\n\t\tif (check_pe32_bytes (buf->buf, module->size_of_image)) {\n\t\t\tr_list_foreach(obj->pe32_bins, it_dup, pe32_dup) {\n\t\t\t\tif (pe32_dup->vaddr == module->base_of_image) {\n\t\t\t\t\tdup = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(pe32_bin = R_NEW0 (struct Pe32_r_bin_mdmp_pe_bin))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_bin_mdmp_patch_pe_headers (buf);\n\t\t\tpe32_bin->vaddr = module->base_of_image;\n\t\t\tpe32_bin->paddr = paddr;\n\t\t\tpe32_bin->bin = Pe32_r_bin_pe_new_buf (buf, 0);\n\n\t\t\tr_list_append (obj->pe32_bins, pe32_bin);\n\t\t} else if (check_pe64_bytes (buf->buf, module->size_of_image)) {\n\t\t\tr_list_foreach(obj->pe64_bins, it_dup, pe64_dup) {\n\t\t\t\tif (pe64_dup->vaddr == module->base_of_image) {\n\t\t\t\t\tdup = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(pe64_bin = R_NEW0 (struct Pe64_r_bin_mdmp_pe_bin))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_bin_mdmp_patch_pe_headers (buf);\n\t\t\tpe64_bin->vaddr = module->base_of_image;\n\t\t\tpe64_bin->paddr = paddr;\n\t\t\tpe64_bin->bin = Pe64_r_bin_pe_new_buf (buf, 0);\n\n\t\t\tr_list_append (obj->pe64_bins, pe64_bin);\n\t\t}\n\t\tr_buf_free (buf);\n\t}\n\treturn true;\n}\n\nstatic int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {\n\tr_bin_mdmp_init_parsing (obj);\n\n\tif (!r_bin_mdmp_init_hdr (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise header\\n\");\n\t\treturn false;\n\t}\n\n\tif (!r_bin_mdmp_init_directory (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise directory structures!\\n\");\n\t\treturn false;\n\t}\n\n\tif (!r_bin_mdmp_init_pe_bins (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise pe binaries!\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstruct r_bin_mdmp_obj *r_bin_mdmp_new_buf(struct r_buf_t *buf) {\n\tbool fail = false;\n\tstruct r_bin_mdmp_obj *obj = R_NEW0 (struct r_bin_mdmp_obj);\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\tobj->kv = sdb_new0 ();\n\tobj->b = r_buf_new ();\n\tobj->size = (ut32)buf->length;\n\n\tfail |= (!(obj->streams.ex_threads = r_list_new ()));\n\tfail |= (!(obj->streams.memories = r_list_new ()));\n\tfail |= (!(obj->streams.memories64.memories = r_list_new ()));\n\tfail |= (!(obj->streams.memory_infos = r_list_new ()));\n\tfail |= (!(obj->streams.modules = r_list_new ()));\n\tfail |= (!(obj->streams.operations = r_list_new ()));\n\tfail |= (!(obj->streams.thread_infos = r_list_new ()));\n\tfail |= (!(obj->streams.threads = r_list_new ()));\n\tfail |= (!(obj->streams.unloaded_modules = r_list_new ()));\n\n\tfail |= (!(obj->pe32_bins = r_list_newf (r_bin_mdmp_free_pe32_bin)));\n\tfail |= (!(obj->pe64_bins = r_list_newf (r_bin_mdmp_free_pe64_bin)));\n\n\tif (fail) {\n\t\tr_bin_mdmp_free (obj);\n\t\treturn NULL;\n\t}\n\n\tif (!r_buf_set_bytes (obj->b, buf->buf, buf->length)) {\n\t\tr_bin_mdmp_free (obj);\n\t\treturn NULL;\n\t}\n\n\tif (!r_bin_mdmp_init (obj)) {\n\t\tr_bin_mdmp_free (obj);\n\t\treturn NULL;\n\t}\n\n\treturn obj;\n}\n"], "filenames": ["libr/bin/format/mdmp/mdmp.c"], "buggy_code_start_loc": [365], "buggy_code_end_loc": [664], "fixing_code_start_loc": [365], "fixing_code_end_loc": [665], "type": "CWE-125", "message": "The r_bin_mdmp_init_directory_entry function in mdmp.c in radare2 2.7.0 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted Mini Crash Dump file.", "other": {"cve": {"id": "CVE-2018-14016", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-12T20:29:00.227", "lastModified": "2020-10-15T13:38:29.670", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The r_bin_mdmp_init_directory_entry function in mdmp.c in radare2 2.7.0 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted Mini Crash Dump file."}, {"lang": "es", "value": "La funci\u00f3n r_bin_mdmp_init_directory_entry en mdmp.c en radare2 2.7.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (sobrelectura de b\u00fafer basada en memoria din\u00e1mica o heap y cierre inesperado de la aplicaci\u00f3n) mediante un archivo Mini Crash Dump."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:2.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "693C6349-1A2D-48F3-A861-9E3F7832D174"}]}]}], "references": [{"url": "https://github.com/radare/radare2/issues/10464", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/radareorg/radare2/commit/eb7deb281df54771fb8ecf5890dc325a7d22d3e2", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/eb7deb281df54771fb8ecf5890dc325a7d22d3e2"}}