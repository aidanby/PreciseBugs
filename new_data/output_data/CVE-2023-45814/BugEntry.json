{"buggy_code": ["using System.Net;\nusing System.Reflection;\nusing Bunkum.Core.Authentication;\nusing Bunkum.Core.Authentication.Dummy;\nusing Bunkum.Core.Database;\nusing Bunkum.Core.Endpoints;\nusing Bunkum.Core.Responses;\nusing Bunkum.Listener.Protocol;\nusing Bunkum.Listener.Request;\nusing NotEnoughLogs;\n\nnamespace Bunkum.Core.Services;\n\npublic class AuthenticationService : Service\n{\n    internal AuthenticationService(Logger logger,\n        IAuthenticationProvider<IToken<IUser>>? provider = null, bool assumeAuthenticationRequired = false) : base(logger)\n    {\n        this._authenticationProvider = provider ?? new DummyAuthenticationProvider();\n        this._assumeAuthenticationRequired = assumeAuthenticationRequired;\n    }\n    \n    /// <summary>\n    /// Is authentication required for your endpoints?\n    /// If true, clients will receive 403 if your <see cref=\"IAuthenticationProvider{TToken}\"/> does not return a user.\n    /// If false, endpoints will work as normal.\n    /// </summary>\n    /// <seealso cref=\"IAuthenticationProvider{TToken}\"/>\n    /// <seealso cref=\"AuthenticationAttribute\"/>\n    private readonly bool _assumeAuthenticationRequired;\n    private readonly IAuthenticationProvider<IToken<IUser>> _authenticationProvider;\n\n    public override void Initialize()\n    {\n        if (this._authenticationProvider is DummyAuthenticationProvider && this._assumeAuthenticationRequired)\n        {\n            this.Logger.LogWarning(BunkumCategory.Startup, \"The server was started with a dummy authentication provider. \" +\n                                                           \"If your application relies on authentication, users will always have full access.\");\n        }\n    }\n    \n    // Cache the token to avoid double lookups.\n    // We don't use a list here as you can't have multiple tokens per request (and thus one token per thread)\n    private readonly ThreadLocal<IToken<IUser>?> _tokenCache = new(() => null);\n\n    /// <inheritdoc />\n    public override Response? OnRequestHandled(ListenerContext context, MethodInfo method, Lazy<IDatabaseContext> database)\n    {\n        if (!(method.GetCustomAttribute<AuthenticationAttribute>()?.Required ?? this._assumeAuthenticationRequired)) return null;\n        \n        IToken<IUser>? token = this.AuthenticateToken(context, database);\n        this._tokenCache.Value = token;\n            \n        if (token == null)\n            return new Response(Array.Empty<byte>(), ContentType.Plaintext, HttpStatusCode.Forbidden);\n\n        return null;\n    }\n\n    /// <inheritdoc />\n    public override object? AddParameterToEndpoint(ListenerContext context, ParameterInfo parameter, Lazy<IDatabaseContext> database)\n    {\n        if(ParameterBasedFrom<IToken<IUser>>(parameter))\n            return this.AuthenticateToken(context, database);\n\n        if (ParameterBasedFrom<IUser>(parameter))\n        {\n            IToken<IUser>? token = this.AuthenticateToken(context, database);\n            if (token != null) return token.User;\n        }\n\n        this._tokenCache.Value = null;\n        return null;\n    }\n\n    public IToken<IUser>? AuthenticateToken(ListenerContext context, Lazy<IDatabaseContext> database, bool remove = false)\n    {\n        this.Logger.LogTrace(nameof(AuthenticationService), \"Attempting to look up a token in the cache...\");\n        \n        // Look for the user in the cache.\n        // ReSharper disable once InvertIf\n        if (this._tokenCache.Value != null)\n        {\n            this.Logger.LogTrace(nameof(AuthenticationService), \"Found token in cache! \\\\o/ (Remove: {0})\", remove);\n            \n            if(remove) this._tokenCache.Value = null;\n            return this._tokenCache.Value;\n        }\n\n        this.Logger.LogTrace(nameof(AuthenticationService), \"Did not find token in cache, calling authentication provider.\");\n        return this._authenticationProvider.AuthenticateToken(context, database);\n    }\n}"], "fixing_code": ["using System.Net;\nusing System.Reflection;\nusing Bunkum.Core.Authentication;\nusing Bunkum.Core.Authentication.Dummy;\nusing Bunkum.Core.Database;\nusing Bunkum.Core.Endpoints;\nusing Bunkum.Core.Responses;\nusing Bunkum.Listener.Protocol;\nusing Bunkum.Listener.Request;\nusing NotEnoughLogs;\n\nnamespace Bunkum.Core.Services;\n\npublic class AuthenticationService : Service\n{\n    internal AuthenticationService(Logger logger,\n        IAuthenticationProvider<IToken<IUser>>? provider = null, bool assumeAuthenticationRequired = false) : base(logger)\n    {\n        this._authenticationProvider = provider ?? new DummyAuthenticationProvider();\n        this._assumeAuthenticationRequired = assumeAuthenticationRequired;\n    }\n    \n    /// <summary>\n    /// Is authentication required for your endpoints?\n    /// If true, clients will receive 403 if your <see cref=\"IAuthenticationProvider{TToken}\"/> does not return a user.\n    /// If false, endpoints will work as normal.\n    /// </summary>\n    /// <seealso cref=\"IAuthenticationProvider{TToken}\"/>\n    /// <seealso cref=\"AuthenticationAttribute\"/>\n    private readonly bool _assumeAuthenticationRequired;\n    private readonly IAuthenticationProvider<IToken<IUser>> _authenticationProvider;\n\n    public override void Initialize()\n    {\n        if (this._authenticationProvider is DummyAuthenticationProvider && this._assumeAuthenticationRequired)\n        {\n            this.Logger.LogWarning(BunkumCategory.Startup, \"The server was started with a dummy authentication provider. \" +\n                                                           \"If your application relies on authentication, users will always have full access.\");\n        }\n    }\n    \n    // Cache the token to avoid double lookups.\n    // We don't use a list here as you can't have multiple tokens per request (and thus one token per thread)\n    private readonly ThreadLocal<IToken<IUser>?> _tokenCache = new(() => null);\n\n    /// <inheritdoc />\n    public override Response? OnRequestHandled(ListenerContext context, MethodInfo method, Lazy<IDatabaseContext> database)\n    {\n        if (!(method.GetCustomAttribute<AuthenticationAttribute>()?.Required ?? this._assumeAuthenticationRequired)) return null;\n        \n        IToken<IUser>? token = this.AuthenticateToken(context, database);\n        this._tokenCache.Value = token;\n            \n        if (token == null)\n            return new Response(Array.Empty<byte>(), ContentType.Plaintext, HttpStatusCode.Forbidden);\n\n        return null;\n    }\n\n    /// <inheritdoc />\n    public override object? AddParameterToEndpoint(ListenerContext context, ParameterInfo parameter, Lazy<IDatabaseContext> database)\n    {\n        if(ParameterBasedFrom<IToken<IUser>>(parameter))\n            return this.AuthenticateToken(context, database);\n\n        if (ParameterBasedFrom<IUser>(parameter))\n        {\n            IToken<IUser>? token = this.AuthenticateToken(context, database);\n            if (token != null) return token.User;\n        }\n        \n        return null;\n    }\n\n    /// <inheritdoc />\n    public override void AfterRequestHandled(ListenerContext context, Response response, MethodInfo method, Lazy<IDatabaseContext> database)\n    {\n        this._tokenCache.Value = null;\n    }\n\n    public IToken<IUser>? AuthenticateToken(ListenerContext context, Lazy<IDatabaseContext> database, bool remove = false)\n    {\n        this.Logger.LogTrace(nameof(AuthenticationService), \"Attempting to look up a token in the cache...\");\n        \n        // Look for the user in the cache.\n        // ReSharper disable once InvertIf\n        if (this._tokenCache.Value != null)\n        {\n            this.Logger.LogTrace(nameof(AuthenticationService), \"Found token in cache! \\\\o/ (Remove: {0})\", remove);\n            \n            if(remove) this._tokenCache.Value = null;\n            return this._tokenCache.Value;\n        }\n\n        this.Logger.LogTrace(nameof(AuthenticationService), \"Did not find token in cache, calling authentication provider.\");\n        return this._authenticationProvider.AuthenticateToken(context, database);\n    }\n}"], "filenames": ["Bunkum.Core/Services/AuthenticationService.cs"], "buggy_code_start_loc": [70], "buggy_code_end_loc": [74], "fixing_code_start_loc": [71], "fixing_code_end_loc": [78], "type": "CWE-772", "message": "Bunkum is an open-source protocol-agnostic request server for custom game servers. First, a little bit of background. So, in the beginning, Bunkum's `AuthenticationService` only supported injecting `IUser`s. However, as Refresh and SoundShapesServer implemented permissions systems support for injecting `IToken`s into endpoints was added. All was well until 4.0. Bunkum 4.0 then changed to enforce relations between `IToken`s and `IUser`s. This wasn't implemented in a very good way in the `AuthenticationService`, and ended up breaking caching in such a way that cached tokens would persist after the lifetime of the request - since we tried to cache both tokens and users. From that point until now, from what I understand, Bunkum was attempting to use that cached token at the start of the next request once cached. Naturally, when that token expired, downstream projects like Refresh would remove the object from Realm - and cause the object in the cache to be in a detached state, causing an exception from invalid use of `IToken.User`. So in other words, a use-after-free since Realm can't manage the lifetime of the cached token. Security-wise, the scope is fairly limited, can only be pulled off on a couple endpoints given a few conditions, and you can't guarantee which token you're going to get. Also, the token *would* get invalidated properly if the endpoint had either a `IToken` usage or a `IUser` usage. The fix is to just wipe the token cache after the request was handled, which is now in `4.2.1`. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-45814", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-18T22:15:09.497", "lastModified": "2023-10-30T17:16:15.390", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Bunkum is an open-source protocol-agnostic request server for custom game servers. First, a little bit of background. So, in the beginning, Bunkum's `AuthenticationService` only supported injecting `IUser`s. However, as Refresh and SoundShapesServer implemented permissions systems support for injecting `IToken`s into endpoints was added. All was well until 4.0. Bunkum 4.0 then changed to enforce relations between `IToken`s and `IUser`s. This wasn't implemented in a very good way in the `AuthenticationService`, and ended up breaking caching in such a way that cached tokens would persist after the lifetime of the request - since we tried to cache both tokens and users. From that point until now, from what I understand, Bunkum was attempting to use that cached token at the start of the next request once cached. Naturally, when that token expired, downstream projects like Refresh would remove the object from Realm - and cause the object in the cache to be in a detached state, causing an exception from invalid use of `IToken.User`. So in other words, a use-after-free since Realm can't manage the lifetime of the cached token. Security-wise, the scope is fairly limited, can only be pulled off on a couple endpoints given a few conditions, and you can't guarantee which token you're going to get. Also, the token *would* get invalidated properly if the endpoint had either a `IToken` usage or a `IUser` usage. The fix is to just wipe the token cache after the request was handled, which is now in `4.2.1`. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Bunkum es un servidor de solicitudes independiente del protocolo de c\u00f3digo abierto para servidores de juegos personalizados. Primero, un poco de historia. Entonces, al principio, el \"AuthenticationService\" de Bunkum solo admit\u00eda la inyecci\u00f3n de \"IUser\". Sin embargo, a medida que Refresh y SoundShapesServer implementaron sistemas de permisos, se agreg\u00f3 soporte para inyectar \"IToken\" en los endpoints. Todo estuvo bien hasta el 4.0. Bunkum 4.0, luego cambi\u00f3 para imponer relaciones entre `IToken`s e `IUser`s. Esto no se implement\u00f3 de muy buena manera en `AuthenticationService` y termin\u00f3 rompiendo el almacenamiento en cach\u00e9 de tal manera que los tokens almacenados en cach\u00e9 persistir\u00edan despu\u00e9s de la vida \u00fatil de la solicitud, ya que intentamos almacenar en cach\u00e9 tanto los tokens como los usuarios. Desde ese momento hasta ahora, seg\u00fan tengo entendido, Bunkum estaba intentando usar ese token almacenado en cach\u00e9 al comienzo de la siguiente solicitud una vez almacenado en cach\u00e9. Naturalmente, cuando ese token expir\u00f3, los proyectos posteriores como Refresh eliminar\u00edan el objeto de Realm y provocar\u00edan que el objeto en el cach\u00e9 estuviera en un estado separado, lo que provocar\u00eda una excepci\u00f3n por el uso no v\u00e1lido de `IToken.User`. En otras palabras, un use-after-free ya que Realm no puede administrar la vida \u00fatil del token almacenado en cach\u00e9. En cuanto a la seguridad, el alcance es bastante limitado, solo se puede implementar en un par de endpoints dadas algunas condiciones y no se puede garantizar qu\u00e9 token obtendr\u00e1. Adem\u00e1s, el token *would* invalidar\u00eda correctamente si el endpoint tuviera un uso de \"IToken\" o un uso de \"IUser\". La soluci\u00f3n es simplemente borrar el cach\u00e9 del token despu\u00e9s de que se manej\u00f3 la solicitud, que ahora est\u00e1 en `4.2.1`. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:littlebigfresh:bunkum:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0", "versionEndExcluding": "4.2.1", "matchCriteriaId": "F4F0D6F2-C400-42D2-BFC4-908EC8742FDA"}]}]}], "references": [{"url": "https://github.com/LittleBigRefresh/Bunkum/commit/6e109464ed9255f558182f001f475a378405ff76", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/LittleBigRefresh/Bunkum/security/advisories/GHSA-jrf2-h5j6-3rrq", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/LittleBigRefresh/Bunkum/commit/6e109464ed9255f558182f001f475a378405ff76"}}