{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/* Parts of this driver are based on the following:\n *  - Kvaser linux leaf driver (version 4.78)\n *  - CAN driver for esd CAN-USB/2\n *  - Kvaser linux usbcanII driver (version 5.3)\n *\n * Copyright (C) 2002-2018 KVASER AB, Sweden. All rights reserved.\n * Copyright (C) 2010 Matthias Fuchs <matthias.fuchs@esd.eu>, esd gmbh\n * Copyright (C) 2012 Olivier Sobrie <olivier@sobrie.be>\n * Copyright (C) 2015 Valeo S.A.\n */\n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/gfp.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/netlink.h>\n\n#include \"kvaser_usb.h\"\n\n/* Forward declaration */\nstatic const struct kvaser_usb_dev_cfg kvaser_usb_leaf_dev_cfg;\n\n#define CAN_USB_CLOCK\t\t\t8000000\n#define MAX_USBCAN_NET_DEVICES\t\t2\n\n/* Command header size */\n#define CMD_HEADER_LEN\t\t\t2\n\n/* Kvaser CAN message flags */\n#define MSG_FLAG_ERROR_FRAME\t\tBIT(0)\n#define MSG_FLAG_OVERRUN\t\tBIT(1)\n#define MSG_FLAG_NERR\t\t\tBIT(2)\n#define MSG_FLAG_WAKEUP\t\t\tBIT(3)\n#define MSG_FLAG_REMOTE_FRAME\t\tBIT(4)\n#define MSG_FLAG_RESERVED\t\tBIT(5)\n#define MSG_FLAG_TX_ACK\t\t\tBIT(6)\n#define MSG_FLAG_TX_REQUEST\t\tBIT(7)\n\n/* CAN states (M16C CxSTRH register) */\n#define M16C_STATE_BUS_RESET\t\tBIT(0)\n#define M16C_STATE_BUS_ERROR\t\tBIT(4)\n#define M16C_STATE_BUS_PASSIVE\t\tBIT(5)\n#define M16C_STATE_BUS_OFF\t\tBIT(6)\n\n/* Leaf/usbcan command ids */\n#define CMD_RX_STD_MESSAGE\t\t12\n#define CMD_TX_STD_MESSAGE\t\t13\n#define CMD_RX_EXT_MESSAGE\t\t14\n#define CMD_TX_EXT_MESSAGE\t\t15\n#define CMD_SET_BUS_PARAMS\t\t16\n#define CMD_CHIP_STATE_EVENT\t\t20\n#define CMD_SET_CTRL_MODE\t\t21\n#define CMD_RESET_CHIP\t\t\t24\n#define CMD_START_CHIP\t\t\t26\n#define CMD_START_CHIP_REPLY\t\t27\n#define CMD_STOP_CHIP\t\t\t28\n#define CMD_STOP_CHIP_REPLY\t\t29\n\n#define CMD_USBCAN_CLOCK_OVERFLOW_EVENT\t33\n\n#define CMD_GET_CARD_INFO\t\t34\n#define CMD_GET_CARD_INFO_REPLY\t\t35\n#define CMD_GET_SOFTWARE_INFO\t\t38\n#define CMD_GET_SOFTWARE_INFO_REPLY\t39\n#define CMD_FLUSH_QUEUE\t\t\t48\n#define CMD_TX_ACKNOWLEDGE\t\t50\n#define CMD_CAN_ERROR_EVENT\t\t51\n#define CMD_FLUSH_QUEUE_REPLY\t\t68\n\n#define CMD_LEAF_LOG_MESSAGE\t\t106\n\n/* error factors */\n#define M16C_EF_ACKE\t\t\tBIT(0)\n#define M16C_EF_CRCE\t\t\tBIT(1)\n#define M16C_EF_FORME\t\t\tBIT(2)\n#define M16C_EF_STFE\t\t\tBIT(3)\n#define M16C_EF_BITE0\t\t\tBIT(4)\n#define M16C_EF_BITE1\t\t\tBIT(5)\n#define M16C_EF_RCVE\t\t\tBIT(6)\n#define M16C_EF_TRE\t\t\tBIT(7)\n\n/* Only Leaf-based devices can report M16C error factors,\n * thus define our own error status flags for USBCANII\n */\n#define USBCAN_ERROR_STATE_NONE\t\t0\n#define USBCAN_ERROR_STATE_TX_ERROR\tBIT(0)\n#define USBCAN_ERROR_STATE_RX_ERROR\tBIT(1)\n#define USBCAN_ERROR_STATE_BUSERROR\tBIT(2)\n\n/* bittiming parameters */\n#define KVASER_USB_TSEG1_MIN\t\t1\n#define KVASER_USB_TSEG1_MAX\t\t16\n#define KVASER_USB_TSEG2_MIN\t\t1\n#define KVASER_USB_TSEG2_MAX\t\t8\n#define KVASER_USB_SJW_MAX\t\t4\n#define KVASER_USB_BRP_MIN\t\t1\n#define KVASER_USB_BRP_MAX\t\t64\n#define KVASER_USB_BRP_INC\t\t1\n\n/* ctrl modes */\n#define KVASER_CTRL_MODE_NORMAL\t\t1\n#define KVASER_CTRL_MODE_SILENT\t\t2\n#define KVASER_CTRL_MODE_SELFRECEPTION\t3\n#define KVASER_CTRL_MODE_OFF\t\t4\n\n/* Extended CAN identifier flag */\n#define KVASER_EXTENDED_FRAME\t\tBIT(31)\n\nstruct kvaser_cmd_simple {\n\tu8 tid;\n\tu8 channel;\n} __packed;\n\nstruct kvaser_cmd_cardinfo {\n\tu8 tid;\n\tu8 nchannels;\n\t__le32 serial_number;\n\t__le32 padding0;\n\t__le32 clock_resolution;\n\t__le32 mfgdate;\n\tu8 ean[8];\n\tu8 hw_revision;\n\tunion {\n\t\tstruct {\n\t\t\tu8 usb_hs_mode;\n\t\t} __packed leaf1;\n\t\tstruct {\n\t\t\tu8 padding;\n\t\t} __packed usbcan1;\n\t} __packed;\n\t__le16 padding1;\n} __packed;\n\nstruct leaf_cmd_softinfo {\n\tu8 tid;\n\tu8 padding0;\n\t__le32 sw_options;\n\t__le32 fw_version;\n\t__le16 max_outstanding_tx;\n\t__le16 padding1[9];\n} __packed;\n\nstruct usbcan_cmd_softinfo {\n\tu8 tid;\n\tu8 fw_name[5];\n\t__le16 max_outstanding_tx;\n\tu8 padding[6];\n\t__le32 fw_version;\n\t__le16 checksum;\n\t__le16 sw_options;\n} __packed;\n\nstruct kvaser_cmd_busparams {\n\tu8 tid;\n\tu8 channel;\n\t__le32 bitrate;\n\tu8 tseg1;\n\tu8 tseg2;\n\tu8 sjw;\n\tu8 no_samp;\n} __packed;\n\nstruct kvaser_cmd_tx_can {\n\tu8 channel;\n\tu8 tid;\n\tu8 data[14];\n\tunion {\n\t\tstruct {\n\t\t\tu8 padding;\n\t\t\tu8 flags;\n\t\t} __packed leaf;\n\t\tstruct {\n\t\t\tu8 flags;\n\t\t\tu8 padding;\n\t\t} __packed usbcan;\n\t} __packed;\n} __packed;\n\nstruct kvaser_cmd_rx_can_header {\n\tu8 channel;\n\tu8 flag;\n} __packed;\n\nstruct leaf_cmd_rx_can {\n\tu8 channel;\n\tu8 flag;\n\n\t__le16 time[3];\n\tu8 data[14];\n} __packed;\n\nstruct usbcan_cmd_rx_can {\n\tu8 channel;\n\tu8 flag;\n\n\tu8 data[14];\n\t__le16 time;\n} __packed;\n\nstruct leaf_cmd_chip_state_event {\n\tu8 tid;\n\tu8 channel;\n\n\t__le16 time[3];\n\tu8 tx_errors_count;\n\tu8 rx_errors_count;\n\n\tu8 status;\n\tu8 padding[3];\n} __packed;\n\nstruct usbcan_cmd_chip_state_event {\n\tu8 tid;\n\tu8 channel;\n\n\tu8 tx_errors_count;\n\tu8 rx_errors_count;\n\t__le16 time;\n\n\tu8 status;\n\tu8 padding[3];\n} __packed;\n\nstruct kvaser_cmd_tx_acknowledge_header {\n\tu8 channel;\n\tu8 tid;\n} __packed;\n\nstruct leaf_cmd_error_event {\n\tu8 tid;\n\tu8 flags;\n\t__le16 time[3];\n\tu8 channel;\n\tu8 padding;\n\tu8 tx_errors_count;\n\tu8 rx_errors_count;\n\tu8 status;\n\tu8 error_factor;\n} __packed;\n\nstruct usbcan_cmd_error_event {\n\tu8 tid;\n\tu8 padding;\n\tu8 tx_errors_count_ch0;\n\tu8 rx_errors_count_ch0;\n\tu8 tx_errors_count_ch1;\n\tu8 rx_errors_count_ch1;\n\tu8 status_ch0;\n\tu8 status_ch1;\n\t__le16 time;\n} __packed;\n\nstruct kvaser_cmd_ctrl_mode {\n\tu8 tid;\n\tu8 channel;\n\tu8 ctrl_mode;\n\tu8 padding[3];\n} __packed;\n\nstruct kvaser_cmd_flush_queue {\n\tu8 tid;\n\tu8 channel;\n\tu8 flags;\n\tu8 padding[3];\n} __packed;\n\nstruct leaf_cmd_log_message {\n\tu8 channel;\n\tu8 flags;\n\t__le16 time[3];\n\tu8 dlc;\n\tu8 time_offset;\n\t__le32 id;\n\tu8 data[8];\n} __packed;\n\nstruct kvaser_cmd {\n\tu8 len;\n\tu8 id;\n\tunion\t{\n\t\tstruct kvaser_cmd_simple simple;\n\t\tstruct kvaser_cmd_cardinfo cardinfo;\n\t\tstruct kvaser_cmd_busparams busparams;\n\n\t\tstruct kvaser_cmd_rx_can_header rx_can_header;\n\t\tstruct kvaser_cmd_tx_acknowledge_header tx_acknowledge_header;\n\n\t\tunion {\n\t\t\tstruct leaf_cmd_softinfo softinfo;\n\t\t\tstruct leaf_cmd_rx_can rx_can;\n\t\t\tstruct leaf_cmd_chip_state_event chip_state_event;\n\t\t\tstruct leaf_cmd_error_event error_event;\n\t\t\tstruct leaf_cmd_log_message log_message;\n\t\t} __packed leaf;\n\n\t\tunion {\n\t\t\tstruct usbcan_cmd_softinfo softinfo;\n\t\t\tstruct usbcan_cmd_rx_can rx_can;\n\t\t\tstruct usbcan_cmd_chip_state_event chip_state_event;\n\t\t\tstruct usbcan_cmd_error_event error_event;\n\t\t} __packed usbcan;\n\n\t\tstruct kvaser_cmd_tx_can tx_can;\n\t\tstruct kvaser_cmd_ctrl_mode ctrl_mode;\n\t\tstruct kvaser_cmd_flush_queue flush_queue;\n\t} u;\n} __packed;\n\n/* Summary of a kvaser error event, for a unified Leaf/Usbcan error\n * handling. Some discrepancies between the two families exist:\n *\n * - USBCAN firmware does not report M16C \"error factors\"\n * - USBCAN controllers has difficulties reporting if the raised error\n *   event is for ch0 or ch1. They leave such arbitration to the OS\n *   driver by letting it compare error counters with previous values\n *   and decide the error event's channel. Thus for USBCAN, the channel\n *   field is only advisory.\n */\nstruct kvaser_usb_err_summary {\n\tu8 channel, status, txerr, rxerr;\n\tunion {\n\t\tstruct {\n\t\t\tu8 error_factor;\n\t\t} leaf;\n\t\tstruct {\n\t\t\tu8 other_ch_status;\n\t\t\tu8 error_state;\n\t\t} usbcan;\n\t};\n};\n\nstatic void *\nkvaser_usb_leaf_frame_to_cmd(const struct kvaser_usb_net_priv *priv,\n\t\t\t     const struct sk_buff *skb, int *frame_len,\n\t\t\t     int *cmd_len, u16 transid)\n{\n\tstruct kvaser_usb *dev = priv->dev;\n\tstruct kvaser_cmd *cmd;\n\tu8 *cmd_tx_can_flags = NULL;\t\t/* GCC */\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\n\t*frame_len = cf->can_dlc;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (cmd) {\n\t\tcmd->u.tx_can.tid = transid & 0xff;\n\t\tcmd->len = *cmd_len = CMD_HEADER_LEN +\n\t\t\t\t      sizeof(struct kvaser_cmd_tx_can);\n\t\tcmd->u.tx_can.channel = priv->channel;\n\n\t\tswitch (dev->card_data.leaf.family) {\n\t\tcase KVASER_LEAF:\n\t\t\tcmd_tx_can_flags = &cmd->u.tx_can.leaf.flags;\n\t\t\tbreak;\n\t\tcase KVASER_USBCAN:\n\t\t\tcmd_tx_can_flags = &cmd->u.tx_can.usbcan.flags;\n\t\t\tbreak;\n\t\t}\n\n\t\t*cmd_tx_can_flags = 0;\n\n\t\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\t\tcmd->id = CMD_TX_EXT_MESSAGE;\n\t\t\tcmd->u.tx_can.data[0] = (cf->can_id >> 24) & 0x1f;\n\t\t\tcmd->u.tx_can.data[1] = (cf->can_id >> 18) & 0x3f;\n\t\t\tcmd->u.tx_can.data[2] = (cf->can_id >> 14) & 0x0f;\n\t\t\tcmd->u.tx_can.data[3] = (cf->can_id >> 6) & 0xff;\n\t\t\tcmd->u.tx_can.data[4] = cf->can_id & 0x3f;\n\t\t} else {\n\t\t\tcmd->id = CMD_TX_STD_MESSAGE;\n\t\t\tcmd->u.tx_can.data[0] = (cf->can_id >> 6) & 0x1f;\n\t\t\tcmd->u.tx_can.data[1] = cf->can_id & 0x3f;\n\t\t}\n\n\t\tcmd->u.tx_can.data[5] = cf->can_dlc;\n\t\tmemcpy(&cmd->u.tx_can.data[6], cf->data, cf->can_dlc);\n\n\t\tif (cf->can_id & CAN_RTR_FLAG)\n\t\t\t*cmd_tx_can_flags |= MSG_FLAG_REMOTE_FRAME;\n\t}\n\treturn cmd;\n}\n\nstatic int kvaser_usb_leaf_wait_cmd(const struct kvaser_usb *dev, u8 id,\n\t\t\t\t    struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_cmd *tmp;\n\tvoid *buf;\n\tint actual_len;\n\tint err;\n\tint pos;\n\tunsigned long to = jiffies + msecs_to_jiffies(KVASER_USB_TIMEOUT);\n\n\tbuf = kzalloc(KVASER_USB_RX_BUFFER_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tdo {\n\t\terr = kvaser_usb_recv_cmd(dev, buf, KVASER_USB_RX_BUFFER_SIZE,\n\t\t\t\t\t  &actual_len);\n\t\tif (err < 0)\n\t\t\tgoto end;\n\n\t\tpos = 0;\n\t\twhile (pos <= actual_len - CMD_HEADER_LEN) {\n\t\t\ttmp = buf + pos;\n\n\t\t\t/* Handle commands crossing the USB endpoint max packet\n\t\t\t * size boundary. Check kvaser_usb_read_bulk_callback()\n\t\t\t * for further details.\n\t\t\t */\n\t\t\tif (tmp->len == 0) {\n\t\t\t\tpos = round_up(pos,\n\t\t\t\t\t       le16_to_cpu\n\t\t\t\t\t\t(dev->bulk_in->wMaxPacketSize));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (pos + tmp->len > actual_len) {\n\t\t\t\tdev_err_ratelimited(&dev->intf->dev,\n\t\t\t\t\t\t    \"Format error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tmp->id == id) {\n\t\t\t\tmemcpy(cmd, tmp, tmp->len);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tpos += tmp->len;\n\t\t}\n\t} while (time_before(jiffies, to));\n\n\terr = -EINVAL;\n\nend:\n\tkfree(buf);\n\n\treturn err;\n}\n\nstatic int kvaser_usb_leaf_send_simple_cmd(const struct kvaser_usb *dev,\n\t\t\t\t\t   u8 cmd_id, int channel)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = cmd_id;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->u.simple.channel = channel;\n\tcmd->u.simple.tid = 0xff;\n\n\trc = kvaser_usb_send_cmd(dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}\n\nstatic int kvaser_usb_leaf_get_software_info_inner(struct kvaser_usb *dev)\n{\n\tstruct kvaser_cmd cmd;\n\tint err;\n\n\terr = kvaser_usb_leaf_send_simple_cmd(dev, CMD_GET_SOFTWARE_INFO, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = kvaser_usb_leaf_wait_cmd(dev, CMD_GET_SOFTWARE_INFO_REPLY, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tswitch (dev->card_data.leaf.family) {\n\tcase KVASER_LEAF:\n\t\tdev->fw_version = le32_to_cpu(cmd.u.leaf.softinfo.fw_version);\n\t\tdev->max_tx_urbs =\n\t\t\tle16_to_cpu(cmd.u.leaf.softinfo.max_outstanding_tx);\n\t\tbreak;\n\tcase KVASER_USBCAN:\n\t\tdev->fw_version = le32_to_cpu(cmd.u.usbcan.softinfo.fw_version);\n\t\tdev->max_tx_urbs =\n\t\t\tle16_to_cpu(cmd.u.usbcan.softinfo.max_outstanding_tx);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_get_software_info(struct kvaser_usb *dev)\n{\n\tint err;\n\tint retry = 3;\n\n\t/* On some x86 laptops, plugging a Kvaser device again after\n\t * an unplug makes the firmware always ignore the very first\n\t * command. For such a case, provide some room for retries\n\t * instead of completely exiting the driver.\n\t */\n\tdo {\n\t\terr = kvaser_usb_leaf_get_software_info_inner(dev);\n\t} while (--retry && err == -ETIMEDOUT);\n\n\treturn err;\n}\n\nstatic int kvaser_usb_leaf_get_card_info(struct kvaser_usb *dev)\n{\n\tstruct kvaser_cmd cmd;\n\tint err;\n\n\terr = kvaser_usb_leaf_send_simple_cmd(dev, CMD_GET_CARD_INFO, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = kvaser_usb_leaf_wait_cmd(dev, CMD_GET_CARD_INFO_REPLY, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tdev->nchannels = cmd.u.cardinfo.nchannels;\n\tif (dev->nchannels > KVASER_USB_MAX_NET_DEVICES ||\n\t    (dev->card_data.leaf.family == KVASER_USBCAN &&\n\t     dev->nchannels > MAX_USBCAN_NET_DEVICES))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void kvaser_usb_leaf_tx_acknowledge(const struct kvaser_usb *dev,\n\t\t\t\t\t   const struct kvaser_cmd *cmd)\n{\n\tstruct net_device_stats *stats;\n\tstruct kvaser_usb_tx_urb_context *context;\n\tstruct kvaser_usb_net_priv *priv;\n\tunsigned long flags;\n\tu8 channel, tid;\n\n\tchannel = cmd->u.tx_acknowledge_header.channel;\n\ttid = cmd->u.tx_acknowledge_header.tid;\n\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\n\tif (!netif_device_present(priv->netdev))\n\t\treturn;\n\n\tstats = &priv->netdev->stats;\n\n\tcontext = &priv->tx_contexts[tid % dev->max_tx_urbs];\n\n\t/* Sometimes the state change doesn't come after a bus-off event */\n\tif (priv->can.restart_ms && priv->can.state >= CAN_STATE_BUS_OFF) {\n\t\tstruct sk_buff *skb;\n\t\tstruct can_frame *cf;\n\n\t\tskb = alloc_can_err_skb(priv->netdev, &cf);\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_RESTARTED;\n\n\t\t\tstats->rx_packets++;\n\t\t\tstats->rx_bytes += cf->can_dlc;\n\t\t\tnetif_rx(skb);\n\t\t} else {\n\t\t\tnetdev_err(priv->netdev,\n\t\t\t\t   \"No memory left for err_skb\\n\");\n\t\t}\n\n\t\tpriv->can.can_stats.restarts++;\n\t\tnetif_carrier_on(priv->netdev);\n\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t}\n\n\tstats->tx_packets++;\n\tstats->tx_bytes += context->dlc;\n\n\tspin_lock_irqsave(&priv->tx_contexts_lock, flags);\n\n\tcan_get_echo_skb(priv->netdev, context->echo_index);\n\tcontext->echo_index = dev->max_tx_urbs;\n\t--priv->active_tx_contexts;\n\tnetif_wake_queue(priv->netdev);\n\n\tspin_unlock_irqrestore(&priv->tx_contexts_lock, flags);\n}\n\nstatic int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t    u8 cmd_id)\n{\n\tstruct kvaser_cmd *cmd;\n\tint err;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->id = cmd_id;\n\tcmd->u.simple.channel = priv->channel;\n\n\terr = kvaser_usb_send_cmd_async(priv, cmd, cmd->len);\n\tif (err)\n\t\tkfree(cmd);\n\n\treturn err;\n}\n\nstatic void\nkvaser_usb_leaf_rx_error_update_can_state(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\tconst struct kvaser_usb_err_summary *es,\n\t\t\t\t\tstruct can_frame *cf)\n{\n\tstruct kvaser_usb *dev = priv->dev;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tenum can_state cur_state, new_state, tx_state, rx_state;\n\n\tnetdev_dbg(priv->netdev, \"Error status: 0x%02x\\n\", es->status);\n\n\tnew_state = priv->can.state;\n\tcur_state = priv->can.state;\n\n\tif (es->status & (M16C_STATE_BUS_OFF | M16C_STATE_BUS_RESET)) {\n\t\tnew_state = CAN_STATE_BUS_OFF;\n\t} else if (es->status & M16C_STATE_BUS_PASSIVE) {\n\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t} else if (es->status & M16C_STATE_BUS_ERROR) {\n\t\t/* Guard against spurious error events after a busoff */\n\t\tif (cur_state < CAN_STATE_BUS_OFF) {\n\t\t\tif (es->txerr >= 128 || es->rxerr >= 128)\n\t\t\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t\t\telse if (es->txerr >= 96 || es->rxerr >= 96)\n\t\t\t\tnew_state = CAN_STATE_ERROR_WARNING;\n\t\t\telse if (cur_state > CAN_STATE_ERROR_ACTIVE)\n\t\t\t\tnew_state = CAN_STATE_ERROR_ACTIVE;\n\t\t}\n\t}\n\n\tif (!es->status)\n\t\tnew_state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (new_state != cur_state) {\n\t\ttx_state = (es->txerr >= es->rxerr) ? new_state : 0;\n\t\trx_state = (es->txerr <= es->rxerr) ? new_state : 0;\n\n\t\tcan_change_state(priv->netdev, cf, tx_state, rx_state);\n\t}\n\n\tif (priv->can.restart_ms &&\n\t    cur_state >= CAN_STATE_BUS_OFF &&\n\t    new_state < CAN_STATE_BUS_OFF)\n\t\tpriv->can.can_stats.restarts++;\n\n\tswitch (dev->card_data.leaf.family) {\n\tcase KVASER_LEAF:\n\t\tif (es->leaf.error_factor) {\n\t\t\tpriv->can.can_stats.bus_error++;\n\t\t\tstats->rx_errors++;\n\t\t}\n\t\tbreak;\n\tcase KVASER_USBCAN:\n\t\tif (es->usbcan.error_state & USBCAN_ERROR_STATE_TX_ERROR)\n\t\t\tstats->tx_errors++;\n\t\tif (es->usbcan.error_state & USBCAN_ERROR_STATE_RX_ERROR)\n\t\t\tstats->rx_errors++;\n\t\tif (es->usbcan.error_state & USBCAN_ERROR_STATE_BUSERROR)\n\t\t\tpriv->can.can_stats.bus_error++;\n\t\tbreak;\n\t}\n\n\tpriv->bec.txerr = es->txerr;\n\tpriv->bec.rxerr = es->rxerr;\n}\n\nstatic void kvaser_usb_leaf_rx_error(const struct kvaser_usb *dev,\n\t\t\t\t     const struct kvaser_usb_err_summary *es)\n{\n\tstruct can_frame *cf;\n\tstruct can_frame tmp_cf = { .can_id = CAN_ERR_FLAG,\n\t\t\t\t    .can_dlc = CAN_ERR_DLC };\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats;\n\tstruct kvaser_usb_net_priv *priv;\n\tenum can_state old_state, new_state;\n\n\tif (es->channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", es->channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[es->channel];\n\tstats = &priv->netdev->stats;\n\n\t/* Update all of the CAN interface's state and error counters before\n\t * trying any memory allocation that can actually fail with -ENOMEM.\n\t *\n\t * We send a temporary stack-allocated error CAN frame to\n\t * can_change_state() for the very same reason.\n\t *\n\t * TODO: Split can_change_state() responsibility between updating the\n\t * CAN interface's state and counters, and the setting up of CAN error\n\t * frame ID and data to userspace. Remove stack allocation afterwards.\n\t */\n\told_state = priv->can.state;\n\tkvaser_usb_leaf_rx_error_update_can_state(priv, es, &tmp_cf);\n\tnew_state = priv->can.state;\n\n\tskb = alloc_can_err_skb(priv->netdev, &cf);\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn;\n\t}\n\tmemcpy(cf, &tmp_cf, sizeof(*cf));\n\n\tif (new_state != old_state) {\n\t\tif (es->status &\n\t\t    (M16C_STATE_BUS_OFF | M16C_STATE_BUS_RESET)) {\n\t\t\tif (!priv->can.restart_ms)\n\t\t\t\tkvaser_usb_leaf_simple_cmd_async(priv,\n\t\t\t\t\t\t\t\t CMD_STOP_CHIP);\n\t\t\tnetif_carrier_off(priv->netdev);\n\t\t}\n\n\t\tif (priv->can.restart_ms &&\n\t\t    old_state >= CAN_STATE_BUS_OFF &&\n\t\t    new_state < CAN_STATE_BUS_OFF) {\n\t\t\tcf->can_id |= CAN_ERR_RESTARTED;\n\t\t\tnetif_carrier_on(priv->netdev);\n\t\t}\n\t}\n\n\tswitch (dev->card_data.leaf.family) {\n\tcase KVASER_LEAF:\n\t\tif (es->leaf.error_factor) {\n\t\t\tcf->can_id |= CAN_ERR_BUSERROR | CAN_ERR_PROT;\n\n\t\t\tif (es->leaf.error_factor & M16C_EF_ACKE)\n\t\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_ACK;\n\t\t\tif (es->leaf.error_factor & M16C_EF_CRCE)\n\t\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\t\tif (es->leaf.error_factor & M16C_EF_FORME)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\t\tif (es->leaf.error_factor & M16C_EF_STFE)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\t\tif (es->leaf.error_factor & M16C_EF_BITE0)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT0;\n\t\t\tif (es->leaf.error_factor & M16C_EF_BITE1)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT1;\n\t\t\tif (es->leaf.error_factor & M16C_EF_TRE)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_TX;\n\t\t}\n\t\tbreak;\n\tcase KVASER_USBCAN:\n\t\tif (es->usbcan.error_state & USBCAN_ERROR_STATE_BUSERROR)\n\t\t\tcf->can_id |= CAN_ERR_BUSERROR;\n\t\tbreak;\n\t}\n\n\tcf->data[6] = es->txerr;\n\tcf->data[7] = es->rxerr;\n\n\tstats->rx_packets++;\n\tstats->rx_bytes += cf->can_dlc;\n\tnetif_rx(skb);\n}\n\n/* For USBCAN, report error to userspace if the channels's errors counter\n * has changed, or we're the only channel seeing a bus error state.\n */\nstatic void\nkvaser_usb_leaf_usbcan_conditionally_rx_error(const struct kvaser_usb *dev,\n\t\t\t\t\t      struct kvaser_usb_err_summary *es)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\tunsigned int channel;\n\tbool report_error;\n\n\tchannel = es->channel;\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\treport_error = false;\n\n\tif (es->txerr != priv->bec.txerr) {\n\t\tes->usbcan.error_state |= USBCAN_ERROR_STATE_TX_ERROR;\n\t\treport_error = true;\n\t}\n\tif (es->rxerr != priv->bec.rxerr) {\n\t\tes->usbcan.error_state |= USBCAN_ERROR_STATE_RX_ERROR;\n\t\treport_error = true;\n\t}\n\tif ((es->status & M16C_STATE_BUS_ERROR) &&\n\t    !(es->usbcan.other_ch_status & M16C_STATE_BUS_ERROR)) {\n\t\tes->usbcan.error_state |= USBCAN_ERROR_STATE_BUSERROR;\n\t\treport_error = true;\n\t}\n\n\tif (report_error)\n\t\tkvaser_usb_leaf_rx_error(dev, es);\n}\n\nstatic void kvaser_usb_leaf_usbcan_rx_error(const struct kvaser_usb *dev,\n\t\t\t\t\t    const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_err_summary es = { };\n\n\tswitch (cmd->id) {\n\t/* Sometimes errors are sent as unsolicited chip state events */\n\tcase CMD_CHIP_STATE_EVENT:\n\t\tes.channel = cmd->u.usbcan.chip_state_event.channel;\n\t\tes.status = cmd->u.usbcan.chip_state_event.status;\n\t\tes.txerr = cmd->u.usbcan.chip_state_event.tx_errors_count;\n\t\tes.rxerr = cmd->u.usbcan.chip_state_event.rx_errors_count;\n\t\tkvaser_usb_leaf_usbcan_conditionally_rx_error(dev, &es);\n\t\tbreak;\n\n\tcase CMD_CAN_ERROR_EVENT:\n\t\tes.channel = 0;\n\t\tes.status = cmd->u.usbcan.error_event.status_ch0;\n\t\tes.txerr = cmd->u.usbcan.error_event.tx_errors_count_ch0;\n\t\tes.rxerr = cmd->u.usbcan.error_event.rx_errors_count_ch0;\n\t\tes.usbcan.other_ch_status =\n\t\t\tcmd->u.usbcan.error_event.status_ch1;\n\t\tkvaser_usb_leaf_usbcan_conditionally_rx_error(dev, &es);\n\n\t\t/* The USBCAN firmware supports up to 2 channels.\n\t\t * Now that ch0 was checked, check if ch1 has any errors.\n\t\t */\n\t\tif (dev->nchannels == MAX_USBCAN_NET_DEVICES) {\n\t\t\tes.channel = 1;\n\t\t\tes.status = cmd->u.usbcan.error_event.status_ch1;\n\t\t\tes.txerr =\n\t\t\t\tcmd->u.usbcan.error_event.tx_errors_count_ch1;\n\t\t\tes.rxerr =\n\t\t\t\tcmd->u.usbcan.error_event.rx_errors_count_ch1;\n\t\t\tes.usbcan.other_ch_status =\n\t\t\t\tcmd->u.usbcan.error_event.status_ch0;\n\t\t\tkvaser_usb_leaf_usbcan_conditionally_rx_error(dev, &es);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&dev->intf->dev, \"Invalid cmd id (%d)\\n\", cmd->id);\n\t}\n}\n\nstatic void kvaser_usb_leaf_leaf_rx_error(const struct kvaser_usb *dev,\n\t\t\t\t\t  const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_err_summary es = { };\n\n\tswitch (cmd->id) {\n\tcase CMD_CAN_ERROR_EVENT:\n\t\tes.channel = cmd->u.leaf.error_event.channel;\n\t\tes.status = cmd->u.leaf.error_event.status;\n\t\tes.txerr = cmd->u.leaf.error_event.tx_errors_count;\n\t\tes.rxerr = cmd->u.leaf.error_event.rx_errors_count;\n\t\tes.leaf.error_factor = cmd->u.leaf.error_event.error_factor;\n\t\tbreak;\n\tcase CMD_LEAF_LOG_MESSAGE:\n\t\tes.channel = cmd->u.leaf.log_message.channel;\n\t\tes.status = cmd->u.leaf.log_message.data[0];\n\t\tes.txerr = cmd->u.leaf.log_message.data[2];\n\t\tes.rxerr = cmd->u.leaf.log_message.data[3];\n\t\tes.leaf.error_factor = cmd->u.leaf.log_message.data[1];\n\t\tbreak;\n\tcase CMD_CHIP_STATE_EVENT:\n\t\tes.channel = cmd->u.leaf.chip_state_event.channel;\n\t\tes.status = cmd->u.leaf.chip_state_event.status;\n\t\tes.txerr = cmd->u.leaf.chip_state_event.tx_errors_count;\n\t\tes.rxerr = cmd->u.leaf.chip_state_event.rx_errors_count;\n\t\tes.leaf.error_factor = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->intf->dev, \"Invalid cmd id (%d)\\n\", cmd->id);\n\t\treturn;\n\t}\n\n\tkvaser_usb_leaf_rx_error(dev, &es);\n}\n\nstatic void kvaser_usb_leaf_rx_can_err(const struct kvaser_usb_net_priv *priv,\n\t\t\t\t       const struct kvaser_cmd *cmd)\n{\n\tif (cmd->u.rx_can_header.flag & (MSG_FLAG_ERROR_FRAME |\n\t\t\t\t\t MSG_FLAG_NERR)) {\n\t\tstruct net_device_stats *stats = &priv->netdev->stats;\n\n\t\tnetdev_err(priv->netdev, \"Unknown error (flags: 0x%02x)\\n\",\n\t\t\t   cmd->u.rx_can_header.flag);\n\n\t\tstats->rx_errors++;\n\t\treturn;\n\t}\n\n\tif (cmd->u.rx_can_header.flag & MSG_FLAG_OVERRUN)\n\t\tkvaser_usb_can_rx_over_error(priv->netdev);\n}\n\nstatic void kvaser_usb_leaf_rx_can_msg(const struct kvaser_usb *dev,\n\t\t\t\t       const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats;\n\tu8 channel = cmd->u.rx_can_header.channel;\n\tconst u8 *rx_data = NULL;\t/* GCC */\n\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\tstats = &priv->netdev->stats;\n\n\tif ((cmd->u.rx_can_header.flag & MSG_FLAG_ERROR_FRAME) &&\n\t    (dev->card_data.leaf.family == KVASER_LEAF &&\n\t     cmd->id == CMD_LEAF_LOG_MESSAGE)) {\n\t\tkvaser_usb_leaf_leaf_rx_error(dev, cmd);\n\t\treturn;\n\t} else if (cmd->u.rx_can_header.flag & (MSG_FLAG_ERROR_FRAME |\n\t\t\t\t\t\tMSG_FLAG_NERR |\n\t\t\t\t\t\tMSG_FLAG_OVERRUN)) {\n\t\tkvaser_usb_leaf_rx_can_err(priv, cmd);\n\t\treturn;\n\t} else if (cmd->u.rx_can_header.flag & ~MSG_FLAG_REMOTE_FRAME) {\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Unhandled frame (flags: 0x%02x)\\n\",\n\t\t\t    cmd->u.rx_can_header.flag);\n\t\treturn;\n\t}\n\n\tswitch (dev->card_data.leaf.family) {\n\tcase KVASER_LEAF:\n\t\trx_data = cmd->u.leaf.rx_can.data;\n\t\tbreak;\n\tcase KVASER_USBCAN:\n\t\trx_data = cmd->u.usbcan.rx_can.data;\n\t\tbreak;\n\t}\n\n\tskb = alloc_can_skb(priv->netdev, &cf);\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn;\n\t}\n\n\tif (dev->card_data.leaf.family == KVASER_LEAF && cmd->id ==\n\t    CMD_LEAF_LOG_MESSAGE) {\n\t\tcf->can_id = le32_to_cpu(cmd->u.leaf.log_message.id);\n\t\tif (cf->can_id & KVASER_EXTENDED_FRAME)\n\t\t\tcf->can_id &= CAN_EFF_MASK | CAN_EFF_FLAG;\n\t\telse\n\t\t\tcf->can_id &= CAN_SFF_MASK;\n\n\t\tcf->can_dlc = get_can_dlc(cmd->u.leaf.log_message.dlc);\n\n\t\tif (cmd->u.leaf.log_message.flags & MSG_FLAG_REMOTE_FRAME)\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\t\telse\n\t\t\tmemcpy(cf->data, &cmd->u.leaf.log_message.data,\n\t\t\t       cf->can_dlc);\n\t} else {\n\t\tcf->can_id = ((rx_data[0] & 0x1f) << 6) | (rx_data[1] & 0x3f);\n\n\t\tif (cmd->id == CMD_RX_EXT_MESSAGE) {\n\t\t\tcf->can_id <<= 18;\n\t\t\tcf->can_id |= ((rx_data[2] & 0x0f) << 14) |\n\t\t\t\t      ((rx_data[3] & 0xff) << 6) |\n\t\t\t\t      (rx_data[4] & 0x3f);\n\t\t\tcf->can_id |= CAN_EFF_FLAG;\n\t\t}\n\n\t\tcf->can_dlc = get_can_dlc(rx_data[5]);\n\n\t\tif (cmd->u.rx_can_header.flag & MSG_FLAG_REMOTE_FRAME)\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\t\telse\n\t\t\tmemcpy(cf->data, &rx_data[6], cf->can_dlc);\n\t}\n\n\tstats->rx_packets++;\n\tstats->rx_bytes += cf->can_dlc;\n\tnetif_rx(skb);\n}\n\nstatic void kvaser_usb_leaf_start_chip_reply(const struct kvaser_usb *dev,\n\t\t\t\t\t     const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\tu8 channel = cmd->u.simple.channel;\n\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\n\tif (completion_done(&priv->start_comp) &&\n\t    netif_queue_stopped(priv->netdev)) {\n\t\tnetif_wake_queue(priv->netdev);\n\t} else {\n\t\tnetif_start_queue(priv->netdev);\n\t\tcomplete(&priv->start_comp);\n\t}\n}\n\nstatic void kvaser_usb_leaf_stop_chip_reply(const struct kvaser_usb *dev,\n\t\t\t\t\t    const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\tu8 channel = cmd->u.simple.channel;\n\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\n\tcomplete(&priv->stop_comp);\n}\n\nstatic void kvaser_usb_leaf_handle_command(const struct kvaser_usb *dev,\n\t\t\t\t\t   const struct kvaser_cmd *cmd)\n{\n\tswitch (cmd->id) {\n\tcase CMD_START_CHIP_REPLY:\n\t\tkvaser_usb_leaf_start_chip_reply(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_STOP_CHIP_REPLY:\n\t\tkvaser_usb_leaf_stop_chip_reply(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_RX_STD_MESSAGE:\n\tcase CMD_RX_EXT_MESSAGE:\n\t\tkvaser_usb_leaf_rx_can_msg(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_LEAF_LOG_MESSAGE:\n\t\tif (dev->card_data.leaf.family != KVASER_LEAF)\n\t\t\tgoto warn;\n\t\tkvaser_usb_leaf_rx_can_msg(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_CHIP_STATE_EVENT:\n\tcase CMD_CAN_ERROR_EVENT:\n\t\tif (dev->card_data.leaf.family == KVASER_LEAF)\n\t\t\tkvaser_usb_leaf_leaf_rx_error(dev, cmd);\n\t\telse\n\t\t\tkvaser_usb_leaf_usbcan_rx_error(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_TX_ACKNOWLEDGE:\n\t\tkvaser_usb_leaf_tx_acknowledge(dev, cmd);\n\t\tbreak;\n\n\t/* Ignored commands */\n\tcase CMD_USBCAN_CLOCK_OVERFLOW_EVENT:\n\t\tif (dev->card_data.leaf.family != KVASER_USBCAN)\n\t\t\tgoto warn;\n\t\tbreak;\n\n\tcase CMD_FLUSH_QUEUE_REPLY:\n\t\tif (dev->card_data.leaf.family != KVASER_LEAF)\n\t\t\tgoto warn;\n\t\tbreak;\n\n\tdefault:\nwarn:\t\tdev_warn(&dev->intf->dev, \"Unhandled command (%d)\\n\", cmd->id);\n\t\tbreak;\n\t}\n}\n\nstatic void kvaser_usb_leaf_read_bulk_callback(struct kvaser_usb *dev,\n\t\t\t\t\t       void *buf, int len)\n{\n\tstruct kvaser_cmd *cmd;\n\tint pos = 0;\n\n\twhile (pos <= len - CMD_HEADER_LEN) {\n\t\tcmd = buf + pos;\n\n\t\t/* The Kvaser firmware can only read and write commands that\n\t\t * does not cross the USB's endpoint wMaxPacketSize boundary.\n\t\t * If a follow-up command crosses such boundary, firmware puts\n\t\t * a placeholder zero-length command in its place then aligns\n\t\t * the real command to the next max packet size.\n\t\t *\n\t\t * Handle such cases or we're going to miss a significant\n\t\t * number of events in case of a heavy rx load on the bus.\n\t\t */\n\t\tif (cmd->len == 0) {\n\t\t\tpos = round_up(pos, le16_to_cpu\n\t\t\t\t\t\t(dev->bulk_in->wMaxPacketSize));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pos + cmd->len > len) {\n\t\t\tdev_err_ratelimited(&dev->intf->dev, \"Format error\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tkvaser_usb_leaf_handle_command(dev, cmd);\n\t\tpos += cmd->len;\n\t}\n}\n\nstatic int kvaser_usb_leaf_set_opt_mode(const struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_SET_CTRL_MODE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_ctrl_mode);\n\tcmd->u.ctrl_mode.tid = 0xff;\n\tcmd->u.ctrl_mode.channel = priv->channel;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_SILENT;\n\telse\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_NORMAL;\n\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}\n\nstatic int kvaser_usb_leaf_start_chip(struct kvaser_usb_net_priv *priv)\n{\n\tint err;\n\n\tinit_completion(&priv->start_comp);\n\n\terr = kvaser_usb_leaf_send_simple_cmd(priv->dev, CMD_START_CHIP,\n\t\t\t\t\t      priv->channel);\n\tif (err)\n\t\treturn err;\n\n\tif (!wait_for_completion_timeout(&priv->start_comp,\n\t\t\t\t\t msecs_to_jiffies(KVASER_USB_TIMEOUT)))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_stop_chip(struct kvaser_usb_net_priv *priv)\n{\n\tint err;\n\n\tinit_completion(&priv->stop_comp);\n\n\terr = kvaser_usb_leaf_send_simple_cmd(priv->dev, CMD_STOP_CHIP,\n\t\t\t\t\t      priv->channel);\n\tif (err)\n\t\treturn err;\n\n\tif (!wait_for_completion_timeout(&priv->stop_comp,\n\t\t\t\t\t msecs_to_jiffies(KVASER_USB_TIMEOUT)))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_reset_chip(struct kvaser_usb *dev, int channel)\n{\n\treturn kvaser_usb_leaf_send_simple_cmd(dev, CMD_RESET_CHIP, channel);\n}\n\nstatic int kvaser_usb_leaf_flush_queue(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_FLUSH_QUEUE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_flush_queue);\n\tcmd->u.flush_queue.channel = priv->channel;\n\tcmd->u.flush_queue.flags = 0x00;\n\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}\n\nstatic int kvaser_usb_leaf_init_card(struct kvaser_usb *dev)\n{\n\tstruct kvaser_usb_dev_card_data *card_data = &dev->card_data;\n\n\tdev->cfg = &kvaser_usb_leaf_dev_cfg;\n\tcard_data->ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\n\n\treturn 0;\n}\n\nstatic const struct can_bittiming_const kvaser_usb_leaf_bittiming_const = {\n\t.name = \"kvaser_usb\",\n\t.tseg1_min = KVASER_USB_TSEG1_MIN,\n\t.tseg1_max = KVASER_USB_TSEG1_MAX,\n\t.tseg2_min = KVASER_USB_TSEG2_MIN,\n\t.tseg2_max = KVASER_USB_TSEG2_MAX,\n\t.sjw_max = KVASER_USB_SJW_MAX,\n\t.brp_min = KVASER_USB_BRP_MIN,\n\t.brp_max = KVASER_USB_BRP_MAX,\n\t.brp_inc = KVASER_USB_BRP_INC,\n};\n\nstatic int kvaser_usb_leaf_set_bittiming(struct net_device *netdev)\n{\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tstruct kvaser_usb *dev = priv->dev;\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_SET_BUS_PARAMS;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_busparams);\n\tcmd->u.busparams.channel = priv->channel;\n\tcmd->u.busparams.tid = 0xff;\n\tcmd->u.busparams.bitrate = cpu_to_le32(bt->bitrate);\n\tcmd->u.busparams.sjw = bt->sjw;\n\tcmd->u.busparams.tseg1 = bt->prop_seg + bt->phase_seg1;\n\tcmd->u.busparams.tseg2 = bt->phase_seg2;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tcmd->u.busparams.no_samp = 3;\n\telse\n\t\tcmd->u.busparams.no_samp = 1;\n\n\trc = kvaser_usb_send_cmd(dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}\n\nstatic int kvaser_usb_leaf_set_mode(struct net_device *netdev,\n\t\t\t\t    enum can_mode mode)\n{\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\tint err;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\terr = kvaser_usb_leaf_simple_cmd_async(priv, CMD_START_CHIP);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_get_berr_counter(const struct net_device *netdev,\n\t\t\t\t\t    struct can_berr_counter *bec)\n{\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\n\t*bec = priv->bec;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_setup_endpoints(struct kvaser_usb *dev)\n{\n\tconst struct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint i;\n\n\tiface_desc = &dev->intf->altsetting[0];\n\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (!dev->bulk_in && usb_endpoint_is_bulk_in(endpoint))\n\t\t\tdev->bulk_in = endpoint;\n\n\t\tif (!dev->bulk_out && usb_endpoint_is_bulk_out(endpoint))\n\t\t\tdev->bulk_out = endpoint;\n\n\t\t/* use first bulk endpoint for in and out */\n\t\tif (dev->bulk_in && dev->bulk_out)\n\t\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nconst struct kvaser_usb_dev_ops kvaser_usb_leaf_dev_ops = {\n\t.dev_set_mode = kvaser_usb_leaf_set_mode,\n\t.dev_set_bittiming = kvaser_usb_leaf_set_bittiming,\n\t.dev_set_data_bittiming = NULL,\n\t.dev_get_berr_counter = kvaser_usb_leaf_get_berr_counter,\n\t.dev_setup_endpoints = kvaser_usb_leaf_setup_endpoints,\n\t.dev_init_card = kvaser_usb_leaf_init_card,\n\t.dev_get_software_info = kvaser_usb_leaf_get_software_info,\n\t.dev_get_software_details = NULL,\n\t.dev_get_card_info = kvaser_usb_leaf_get_card_info,\n\t.dev_get_capabilities = NULL,\n\t.dev_set_opt_mode = kvaser_usb_leaf_set_opt_mode,\n\t.dev_start_chip = kvaser_usb_leaf_start_chip,\n\t.dev_stop_chip = kvaser_usb_leaf_stop_chip,\n\t.dev_reset_chip = kvaser_usb_leaf_reset_chip,\n\t.dev_flush_queue = kvaser_usb_leaf_flush_queue,\n\t.dev_read_bulk_callback = kvaser_usb_leaf_read_bulk_callback,\n\t.dev_frame_to_cmd = kvaser_usb_leaf_frame_to_cmd,\n};\n\nstatic const struct kvaser_usb_dev_cfg kvaser_usb_leaf_dev_cfg = {\n\t.clock = {\n\t\t.freq = CAN_USB_CLOCK,\n\t},\n\t.timestamp_freq = 1,\n\t.bittiming_const = &kvaser_usb_leaf_bittiming_const,\n};\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/* Parts of this driver are based on the following:\n *  - Kvaser linux leaf driver (version 4.78)\n *  - CAN driver for esd CAN-USB/2\n *  - Kvaser linux usbcanII driver (version 5.3)\n *\n * Copyright (C) 2002-2018 KVASER AB, Sweden. All rights reserved.\n * Copyright (C) 2010 Matthias Fuchs <matthias.fuchs@esd.eu>, esd gmbh\n * Copyright (C) 2012 Olivier Sobrie <olivier@sobrie.be>\n * Copyright (C) 2015 Valeo S.A.\n */\n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/gfp.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/netlink.h>\n\n#include \"kvaser_usb.h\"\n\n/* Forward declaration */\nstatic const struct kvaser_usb_dev_cfg kvaser_usb_leaf_dev_cfg;\n\n#define CAN_USB_CLOCK\t\t\t8000000\n#define MAX_USBCAN_NET_DEVICES\t\t2\n\n/* Command header size */\n#define CMD_HEADER_LEN\t\t\t2\n\n/* Kvaser CAN message flags */\n#define MSG_FLAG_ERROR_FRAME\t\tBIT(0)\n#define MSG_FLAG_OVERRUN\t\tBIT(1)\n#define MSG_FLAG_NERR\t\t\tBIT(2)\n#define MSG_FLAG_WAKEUP\t\t\tBIT(3)\n#define MSG_FLAG_REMOTE_FRAME\t\tBIT(4)\n#define MSG_FLAG_RESERVED\t\tBIT(5)\n#define MSG_FLAG_TX_ACK\t\t\tBIT(6)\n#define MSG_FLAG_TX_REQUEST\t\tBIT(7)\n\n/* CAN states (M16C CxSTRH register) */\n#define M16C_STATE_BUS_RESET\t\tBIT(0)\n#define M16C_STATE_BUS_ERROR\t\tBIT(4)\n#define M16C_STATE_BUS_PASSIVE\t\tBIT(5)\n#define M16C_STATE_BUS_OFF\t\tBIT(6)\n\n/* Leaf/usbcan command ids */\n#define CMD_RX_STD_MESSAGE\t\t12\n#define CMD_TX_STD_MESSAGE\t\t13\n#define CMD_RX_EXT_MESSAGE\t\t14\n#define CMD_TX_EXT_MESSAGE\t\t15\n#define CMD_SET_BUS_PARAMS\t\t16\n#define CMD_CHIP_STATE_EVENT\t\t20\n#define CMD_SET_CTRL_MODE\t\t21\n#define CMD_RESET_CHIP\t\t\t24\n#define CMD_START_CHIP\t\t\t26\n#define CMD_START_CHIP_REPLY\t\t27\n#define CMD_STOP_CHIP\t\t\t28\n#define CMD_STOP_CHIP_REPLY\t\t29\n\n#define CMD_USBCAN_CLOCK_OVERFLOW_EVENT\t33\n\n#define CMD_GET_CARD_INFO\t\t34\n#define CMD_GET_CARD_INFO_REPLY\t\t35\n#define CMD_GET_SOFTWARE_INFO\t\t38\n#define CMD_GET_SOFTWARE_INFO_REPLY\t39\n#define CMD_FLUSH_QUEUE\t\t\t48\n#define CMD_TX_ACKNOWLEDGE\t\t50\n#define CMD_CAN_ERROR_EVENT\t\t51\n#define CMD_FLUSH_QUEUE_REPLY\t\t68\n\n#define CMD_LEAF_LOG_MESSAGE\t\t106\n\n/* error factors */\n#define M16C_EF_ACKE\t\t\tBIT(0)\n#define M16C_EF_CRCE\t\t\tBIT(1)\n#define M16C_EF_FORME\t\t\tBIT(2)\n#define M16C_EF_STFE\t\t\tBIT(3)\n#define M16C_EF_BITE0\t\t\tBIT(4)\n#define M16C_EF_BITE1\t\t\tBIT(5)\n#define M16C_EF_RCVE\t\t\tBIT(6)\n#define M16C_EF_TRE\t\t\tBIT(7)\n\n/* Only Leaf-based devices can report M16C error factors,\n * thus define our own error status flags for USBCANII\n */\n#define USBCAN_ERROR_STATE_NONE\t\t0\n#define USBCAN_ERROR_STATE_TX_ERROR\tBIT(0)\n#define USBCAN_ERROR_STATE_RX_ERROR\tBIT(1)\n#define USBCAN_ERROR_STATE_BUSERROR\tBIT(2)\n\n/* bittiming parameters */\n#define KVASER_USB_TSEG1_MIN\t\t1\n#define KVASER_USB_TSEG1_MAX\t\t16\n#define KVASER_USB_TSEG2_MIN\t\t1\n#define KVASER_USB_TSEG2_MAX\t\t8\n#define KVASER_USB_SJW_MAX\t\t4\n#define KVASER_USB_BRP_MIN\t\t1\n#define KVASER_USB_BRP_MAX\t\t64\n#define KVASER_USB_BRP_INC\t\t1\n\n/* ctrl modes */\n#define KVASER_CTRL_MODE_NORMAL\t\t1\n#define KVASER_CTRL_MODE_SILENT\t\t2\n#define KVASER_CTRL_MODE_SELFRECEPTION\t3\n#define KVASER_CTRL_MODE_OFF\t\t4\n\n/* Extended CAN identifier flag */\n#define KVASER_EXTENDED_FRAME\t\tBIT(31)\n\nstruct kvaser_cmd_simple {\n\tu8 tid;\n\tu8 channel;\n} __packed;\n\nstruct kvaser_cmd_cardinfo {\n\tu8 tid;\n\tu8 nchannels;\n\t__le32 serial_number;\n\t__le32 padding0;\n\t__le32 clock_resolution;\n\t__le32 mfgdate;\n\tu8 ean[8];\n\tu8 hw_revision;\n\tunion {\n\t\tstruct {\n\t\t\tu8 usb_hs_mode;\n\t\t} __packed leaf1;\n\t\tstruct {\n\t\t\tu8 padding;\n\t\t} __packed usbcan1;\n\t} __packed;\n\t__le16 padding1;\n} __packed;\n\nstruct leaf_cmd_softinfo {\n\tu8 tid;\n\tu8 padding0;\n\t__le32 sw_options;\n\t__le32 fw_version;\n\t__le16 max_outstanding_tx;\n\t__le16 padding1[9];\n} __packed;\n\nstruct usbcan_cmd_softinfo {\n\tu8 tid;\n\tu8 fw_name[5];\n\t__le16 max_outstanding_tx;\n\tu8 padding[6];\n\t__le32 fw_version;\n\t__le16 checksum;\n\t__le16 sw_options;\n} __packed;\n\nstruct kvaser_cmd_busparams {\n\tu8 tid;\n\tu8 channel;\n\t__le32 bitrate;\n\tu8 tseg1;\n\tu8 tseg2;\n\tu8 sjw;\n\tu8 no_samp;\n} __packed;\n\nstruct kvaser_cmd_tx_can {\n\tu8 channel;\n\tu8 tid;\n\tu8 data[14];\n\tunion {\n\t\tstruct {\n\t\t\tu8 padding;\n\t\t\tu8 flags;\n\t\t} __packed leaf;\n\t\tstruct {\n\t\t\tu8 flags;\n\t\t\tu8 padding;\n\t\t} __packed usbcan;\n\t} __packed;\n} __packed;\n\nstruct kvaser_cmd_rx_can_header {\n\tu8 channel;\n\tu8 flag;\n} __packed;\n\nstruct leaf_cmd_rx_can {\n\tu8 channel;\n\tu8 flag;\n\n\t__le16 time[3];\n\tu8 data[14];\n} __packed;\n\nstruct usbcan_cmd_rx_can {\n\tu8 channel;\n\tu8 flag;\n\n\tu8 data[14];\n\t__le16 time;\n} __packed;\n\nstruct leaf_cmd_chip_state_event {\n\tu8 tid;\n\tu8 channel;\n\n\t__le16 time[3];\n\tu8 tx_errors_count;\n\tu8 rx_errors_count;\n\n\tu8 status;\n\tu8 padding[3];\n} __packed;\n\nstruct usbcan_cmd_chip_state_event {\n\tu8 tid;\n\tu8 channel;\n\n\tu8 tx_errors_count;\n\tu8 rx_errors_count;\n\t__le16 time;\n\n\tu8 status;\n\tu8 padding[3];\n} __packed;\n\nstruct kvaser_cmd_tx_acknowledge_header {\n\tu8 channel;\n\tu8 tid;\n} __packed;\n\nstruct leaf_cmd_error_event {\n\tu8 tid;\n\tu8 flags;\n\t__le16 time[3];\n\tu8 channel;\n\tu8 padding;\n\tu8 tx_errors_count;\n\tu8 rx_errors_count;\n\tu8 status;\n\tu8 error_factor;\n} __packed;\n\nstruct usbcan_cmd_error_event {\n\tu8 tid;\n\tu8 padding;\n\tu8 tx_errors_count_ch0;\n\tu8 rx_errors_count_ch0;\n\tu8 tx_errors_count_ch1;\n\tu8 rx_errors_count_ch1;\n\tu8 status_ch0;\n\tu8 status_ch1;\n\t__le16 time;\n} __packed;\n\nstruct kvaser_cmd_ctrl_mode {\n\tu8 tid;\n\tu8 channel;\n\tu8 ctrl_mode;\n\tu8 padding[3];\n} __packed;\n\nstruct kvaser_cmd_flush_queue {\n\tu8 tid;\n\tu8 channel;\n\tu8 flags;\n\tu8 padding[3];\n} __packed;\n\nstruct leaf_cmd_log_message {\n\tu8 channel;\n\tu8 flags;\n\t__le16 time[3];\n\tu8 dlc;\n\tu8 time_offset;\n\t__le32 id;\n\tu8 data[8];\n} __packed;\n\nstruct kvaser_cmd {\n\tu8 len;\n\tu8 id;\n\tunion\t{\n\t\tstruct kvaser_cmd_simple simple;\n\t\tstruct kvaser_cmd_cardinfo cardinfo;\n\t\tstruct kvaser_cmd_busparams busparams;\n\n\t\tstruct kvaser_cmd_rx_can_header rx_can_header;\n\t\tstruct kvaser_cmd_tx_acknowledge_header tx_acknowledge_header;\n\n\t\tunion {\n\t\t\tstruct leaf_cmd_softinfo softinfo;\n\t\t\tstruct leaf_cmd_rx_can rx_can;\n\t\t\tstruct leaf_cmd_chip_state_event chip_state_event;\n\t\t\tstruct leaf_cmd_error_event error_event;\n\t\t\tstruct leaf_cmd_log_message log_message;\n\t\t} __packed leaf;\n\n\t\tunion {\n\t\t\tstruct usbcan_cmd_softinfo softinfo;\n\t\t\tstruct usbcan_cmd_rx_can rx_can;\n\t\t\tstruct usbcan_cmd_chip_state_event chip_state_event;\n\t\t\tstruct usbcan_cmd_error_event error_event;\n\t\t} __packed usbcan;\n\n\t\tstruct kvaser_cmd_tx_can tx_can;\n\t\tstruct kvaser_cmd_ctrl_mode ctrl_mode;\n\t\tstruct kvaser_cmd_flush_queue flush_queue;\n\t} u;\n} __packed;\n\n/* Summary of a kvaser error event, for a unified Leaf/Usbcan error\n * handling. Some discrepancies between the two families exist:\n *\n * - USBCAN firmware does not report M16C \"error factors\"\n * - USBCAN controllers has difficulties reporting if the raised error\n *   event is for ch0 or ch1. They leave such arbitration to the OS\n *   driver by letting it compare error counters with previous values\n *   and decide the error event's channel. Thus for USBCAN, the channel\n *   field is only advisory.\n */\nstruct kvaser_usb_err_summary {\n\tu8 channel, status, txerr, rxerr;\n\tunion {\n\t\tstruct {\n\t\t\tu8 error_factor;\n\t\t} leaf;\n\t\tstruct {\n\t\t\tu8 other_ch_status;\n\t\t\tu8 error_state;\n\t\t} usbcan;\n\t};\n};\n\nstatic void *\nkvaser_usb_leaf_frame_to_cmd(const struct kvaser_usb_net_priv *priv,\n\t\t\t     const struct sk_buff *skb, int *frame_len,\n\t\t\t     int *cmd_len, u16 transid)\n{\n\tstruct kvaser_usb *dev = priv->dev;\n\tstruct kvaser_cmd *cmd;\n\tu8 *cmd_tx_can_flags = NULL;\t\t/* GCC */\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\n\t*frame_len = cf->can_dlc;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (cmd) {\n\t\tcmd->u.tx_can.tid = transid & 0xff;\n\t\tcmd->len = *cmd_len = CMD_HEADER_LEN +\n\t\t\t\t      sizeof(struct kvaser_cmd_tx_can);\n\t\tcmd->u.tx_can.channel = priv->channel;\n\n\t\tswitch (dev->card_data.leaf.family) {\n\t\tcase KVASER_LEAF:\n\t\t\tcmd_tx_can_flags = &cmd->u.tx_can.leaf.flags;\n\t\t\tbreak;\n\t\tcase KVASER_USBCAN:\n\t\t\tcmd_tx_can_flags = &cmd->u.tx_can.usbcan.flags;\n\t\t\tbreak;\n\t\t}\n\n\t\t*cmd_tx_can_flags = 0;\n\n\t\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\t\tcmd->id = CMD_TX_EXT_MESSAGE;\n\t\t\tcmd->u.tx_can.data[0] = (cf->can_id >> 24) & 0x1f;\n\t\t\tcmd->u.tx_can.data[1] = (cf->can_id >> 18) & 0x3f;\n\t\t\tcmd->u.tx_can.data[2] = (cf->can_id >> 14) & 0x0f;\n\t\t\tcmd->u.tx_can.data[3] = (cf->can_id >> 6) & 0xff;\n\t\t\tcmd->u.tx_can.data[4] = cf->can_id & 0x3f;\n\t\t} else {\n\t\t\tcmd->id = CMD_TX_STD_MESSAGE;\n\t\t\tcmd->u.tx_can.data[0] = (cf->can_id >> 6) & 0x1f;\n\t\t\tcmd->u.tx_can.data[1] = cf->can_id & 0x3f;\n\t\t}\n\n\t\tcmd->u.tx_can.data[5] = cf->can_dlc;\n\t\tmemcpy(&cmd->u.tx_can.data[6], cf->data, cf->can_dlc);\n\n\t\tif (cf->can_id & CAN_RTR_FLAG)\n\t\t\t*cmd_tx_can_flags |= MSG_FLAG_REMOTE_FRAME;\n\t}\n\treturn cmd;\n}\n\nstatic int kvaser_usb_leaf_wait_cmd(const struct kvaser_usb *dev, u8 id,\n\t\t\t\t    struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_cmd *tmp;\n\tvoid *buf;\n\tint actual_len;\n\tint err;\n\tint pos;\n\tunsigned long to = jiffies + msecs_to_jiffies(KVASER_USB_TIMEOUT);\n\n\tbuf = kzalloc(KVASER_USB_RX_BUFFER_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tdo {\n\t\terr = kvaser_usb_recv_cmd(dev, buf, KVASER_USB_RX_BUFFER_SIZE,\n\t\t\t\t\t  &actual_len);\n\t\tif (err < 0)\n\t\t\tgoto end;\n\n\t\tpos = 0;\n\t\twhile (pos <= actual_len - CMD_HEADER_LEN) {\n\t\t\ttmp = buf + pos;\n\n\t\t\t/* Handle commands crossing the USB endpoint max packet\n\t\t\t * size boundary. Check kvaser_usb_read_bulk_callback()\n\t\t\t * for further details.\n\t\t\t */\n\t\t\tif (tmp->len == 0) {\n\t\t\t\tpos = round_up(pos,\n\t\t\t\t\t       le16_to_cpu\n\t\t\t\t\t\t(dev->bulk_in->wMaxPacketSize));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (pos + tmp->len > actual_len) {\n\t\t\t\tdev_err_ratelimited(&dev->intf->dev,\n\t\t\t\t\t\t    \"Format error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tmp->id == id) {\n\t\t\t\tmemcpy(cmd, tmp, tmp->len);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tpos += tmp->len;\n\t\t}\n\t} while (time_before(jiffies, to));\n\n\terr = -EINVAL;\n\nend:\n\tkfree(buf);\n\n\treturn err;\n}\n\nstatic int kvaser_usb_leaf_send_simple_cmd(const struct kvaser_usb *dev,\n\t\t\t\t\t   u8 cmd_id, int channel)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = cmd_id;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->u.simple.channel = channel;\n\tcmd->u.simple.tid = 0xff;\n\n\trc = kvaser_usb_send_cmd(dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}\n\nstatic int kvaser_usb_leaf_get_software_info_inner(struct kvaser_usb *dev)\n{\n\tstruct kvaser_cmd cmd;\n\tint err;\n\n\terr = kvaser_usb_leaf_send_simple_cmd(dev, CMD_GET_SOFTWARE_INFO, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = kvaser_usb_leaf_wait_cmd(dev, CMD_GET_SOFTWARE_INFO_REPLY, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tswitch (dev->card_data.leaf.family) {\n\tcase KVASER_LEAF:\n\t\tdev->fw_version = le32_to_cpu(cmd.u.leaf.softinfo.fw_version);\n\t\tdev->max_tx_urbs =\n\t\t\tle16_to_cpu(cmd.u.leaf.softinfo.max_outstanding_tx);\n\t\tbreak;\n\tcase KVASER_USBCAN:\n\t\tdev->fw_version = le32_to_cpu(cmd.u.usbcan.softinfo.fw_version);\n\t\tdev->max_tx_urbs =\n\t\t\tle16_to_cpu(cmd.u.usbcan.softinfo.max_outstanding_tx);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_get_software_info(struct kvaser_usb *dev)\n{\n\tint err;\n\tint retry = 3;\n\n\t/* On some x86 laptops, plugging a Kvaser device again after\n\t * an unplug makes the firmware always ignore the very first\n\t * command. For such a case, provide some room for retries\n\t * instead of completely exiting the driver.\n\t */\n\tdo {\n\t\terr = kvaser_usb_leaf_get_software_info_inner(dev);\n\t} while (--retry && err == -ETIMEDOUT);\n\n\treturn err;\n}\n\nstatic int kvaser_usb_leaf_get_card_info(struct kvaser_usb *dev)\n{\n\tstruct kvaser_cmd cmd;\n\tint err;\n\n\terr = kvaser_usb_leaf_send_simple_cmd(dev, CMD_GET_CARD_INFO, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = kvaser_usb_leaf_wait_cmd(dev, CMD_GET_CARD_INFO_REPLY, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tdev->nchannels = cmd.u.cardinfo.nchannels;\n\tif (dev->nchannels > KVASER_USB_MAX_NET_DEVICES ||\n\t    (dev->card_data.leaf.family == KVASER_USBCAN &&\n\t     dev->nchannels > MAX_USBCAN_NET_DEVICES))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void kvaser_usb_leaf_tx_acknowledge(const struct kvaser_usb *dev,\n\t\t\t\t\t   const struct kvaser_cmd *cmd)\n{\n\tstruct net_device_stats *stats;\n\tstruct kvaser_usb_tx_urb_context *context;\n\tstruct kvaser_usb_net_priv *priv;\n\tunsigned long flags;\n\tu8 channel, tid;\n\n\tchannel = cmd->u.tx_acknowledge_header.channel;\n\ttid = cmd->u.tx_acknowledge_header.tid;\n\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\n\tif (!netif_device_present(priv->netdev))\n\t\treturn;\n\n\tstats = &priv->netdev->stats;\n\n\tcontext = &priv->tx_contexts[tid % dev->max_tx_urbs];\n\n\t/* Sometimes the state change doesn't come after a bus-off event */\n\tif (priv->can.restart_ms && priv->can.state >= CAN_STATE_BUS_OFF) {\n\t\tstruct sk_buff *skb;\n\t\tstruct can_frame *cf;\n\n\t\tskb = alloc_can_err_skb(priv->netdev, &cf);\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_RESTARTED;\n\n\t\t\tstats->rx_packets++;\n\t\t\tstats->rx_bytes += cf->can_dlc;\n\t\t\tnetif_rx(skb);\n\t\t} else {\n\t\t\tnetdev_err(priv->netdev,\n\t\t\t\t   \"No memory left for err_skb\\n\");\n\t\t}\n\n\t\tpriv->can.can_stats.restarts++;\n\t\tnetif_carrier_on(priv->netdev);\n\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t}\n\n\tstats->tx_packets++;\n\tstats->tx_bytes += context->dlc;\n\n\tspin_lock_irqsave(&priv->tx_contexts_lock, flags);\n\n\tcan_get_echo_skb(priv->netdev, context->echo_index);\n\tcontext->echo_index = dev->max_tx_urbs;\n\t--priv->active_tx_contexts;\n\tnetif_wake_queue(priv->netdev);\n\n\tspin_unlock_irqrestore(&priv->tx_contexts_lock, flags);\n}\n\nstatic int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t    u8 cmd_id)\n{\n\tstruct kvaser_cmd *cmd;\n\tint err;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->id = cmd_id;\n\tcmd->u.simple.channel = priv->channel;\n\n\terr = kvaser_usb_send_cmd_async(priv, cmd, cmd->len);\n\tif (err)\n\t\tkfree(cmd);\n\n\treturn err;\n}\n\nstatic void\nkvaser_usb_leaf_rx_error_update_can_state(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\tconst struct kvaser_usb_err_summary *es,\n\t\t\t\t\tstruct can_frame *cf)\n{\n\tstruct kvaser_usb *dev = priv->dev;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tenum can_state cur_state, new_state, tx_state, rx_state;\n\n\tnetdev_dbg(priv->netdev, \"Error status: 0x%02x\\n\", es->status);\n\n\tnew_state = priv->can.state;\n\tcur_state = priv->can.state;\n\n\tif (es->status & (M16C_STATE_BUS_OFF | M16C_STATE_BUS_RESET)) {\n\t\tnew_state = CAN_STATE_BUS_OFF;\n\t} else if (es->status & M16C_STATE_BUS_PASSIVE) {\n\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t} else if (es->status & M16C_STATE_BUS_ERROR) {\n\t\t/* Guard against spurious error events after a busoff */\n\t\tif (cur_state < CAN_STATE_BUS_OFF) {\n\t\t\tif (es->txerr >= 128 || es->rxerr >= 128)\n\t\t\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t\t\telse if (es->txerr >= 96 || es->rxerr >= 96)\n\t\t\t\tnew_state = CAN_STATE_ERROR_WARNING;\n\t\t\telse if (cur_state > CAN_STATE_ERROR_ACTIVE)\n\t\t\t\tnew_state = CAN_STATE_ERROR_ACTIVE;\n\t\t}\n\t}\n\n\tif (!es->status)\n\t\tnew_state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (new_state != cur_state) {\n\t\ttx_state = (es->txerr >= es->rxerr) ? new_state : 0;\n\t\trx_state = (es->txerr <= es->rxerr) ? new_state : 0;\n\n\t\tcan_change_state(priv->netdev, cf, tx_state, rx_state);\n\t}\n\n\tif (priv->can.restart_ms &&\n\t    cur_state >= CAN_STATE_BUS_OFF &&\n\t    new_state < CAN_STATE_BUS_OFF)\n\t\tpriv->can.can_stats.restarts++;\n\n\tswitch (dev->card_data.leaf.family) {\n\tcase KVASER_LEAF:\n\t\tif (es->leaf.error_factor) {\n\t\t\tpriv->can.can_stats.bus_error++;\n\t\t\tstats->rx_errors++;\n\t\t}\n\t\tbreak;\n\tcase KVASER_USBCAN:\n\t\tif (es->usbcan.error_state & USBCAN_ERROR_STATE_TX_ERROR)\n\t\t\tstats->tx_errors++;\n\t\tif (es->usbcan.error_state & USBCAN_ERROR_STATE_RX_ERROR)\n\t\t\tstats->rx_errors++;\n\t\tif (es->usbcan.error_state & USBCAN_ERROR_STATE_BUSERROR)\n\t\t\tpriv->can.can_stats.bus_error++;\n\t\tbreak;\n\t}\n\n\tpriv->bec.txerr = es->txerr;\n\tpriv->bec.rxerr = es->rxerr;\n}\n\nstatic void kvaser_usb_leaf_rx_error(const struct kvaser_usb *dev,\n\t\t\t\t     const struct kvaser_usb_err_summary *es)\n{\n\tstruct can_frame *cf;\n\tstruct can_frame tmp_cf = { .can_id = CAN_ERR_FLAG,\n\t\t\t\t    .can_dlc = CAN_ERR_DLC };\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats;\n\tstruct kvaser_usb_net_priv *priv;\n\tenum can_state old_state, new_state;\n\n\tif (es->channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", es->channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[es->channel];\n\tstats = &priv->netdev->stats;\n\n\t/* Update all of the CAN interface's state and error counters before\n\t * trying any memory allocation that can actually fail with -ENOMEM.\n\t *\n\t * We send a temporary stack-allocated error CAN frame to\n\t * can_change_state() for the very same reason.\n\t *\n\t * TODO: Split can_change_state() responsibility between updating the\n\t * CAN interface's state and counters, and the setting up of CAN error\n\t * frame ID and data to userspace. Remove stack allocation afterwards.\n\t */\n\told_state = priv->can.state;\n\tkvaser_usb_leaf_rx_error_update_can_state(priv, es, &tmp_cf);\n\tnew_state = priv->can.state;\n\n\tskb = alloc_can_err_skb(priv->netdev, &cf);\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn;\n\t}\n\tmemcpy(cf, &tmp_cf, sizeof(*cf));\n\n\tif (new_state != old_state) {\n\t\tif (es->status &\n\t\t    (M16C_STATE_BUS_OFF | M16C_STATE_BUS_RESET)) {\n\t\t\tif (!priv->can.restart_ms)\n\t\t\t\tkvaser_usb_leaf_simple_cmd_async(priv,\n\t\t\t\t\t\t\t\t CMD_STOP_CHIP);\n\t\t\tnetif_carrier_off(priv->netdev);\n\t\t}\n\n\t\tif (priv->can.restart_ms &&\n\t\t    old_state >= CAN_STATE_BUS_OFF &&\n\t\t    new_state < CAN_STATE_BUS_OFF) {\n\t\t\tcf->can_id |= CAN_ERR_RESTARTED;\n\t\t\tnetif_carrier_on(priv->netdev);\n\t\t}\n\t}\n\n\tswitch (dev->card_data.leaf.family) {\n\tcase KVASER_LEAF:\n\t\tif (es->leaf.error_factor) {\n\t\t\tcf->can_id |= CAN_ERR_BUSERROR | CAN_ERR_PROT;\n\n\t\t\tif (es->leaf.error_factor & M16C_EF_ACKE)\n\t\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_ACK;\n\t\t\tif (es->leaf.error_factor & M16C_EF_CRCE)\n\t\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\t\tif (es->leaf.error_factor & M16C_EF_FORME)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\t\tif (es->leaf.error_factor & M16C_EF_STFE)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\t\tif (es->leaf.error_factor & M16C_EF_BITE0)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT0;\n\t\t\tif (es->leaf.error_factor & M16C_EF_BITE1)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT1;\n\t\t\tif (es->leaf.error_factor & M16C_EF_TRE)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_TX;\n\t\t}\n\t\tbreak;\n\tcase KVASER_USBCAN:\n\t\tif (es->usbcan.error_state & USBCAN_ERROR_STATE_BUSERROR)\n\t\t\tcf->can_id |= CAN_ERR_BUSERROR;\n\t\tbreak;\n\t}\n\n\tcf->data[6] = es->txerr;\n\tcf->data[7] = es->rxerr;\n\n\tstats->rx_packets++;\n\tstats->rx_bytes += cf->can_dlc;\n\tnetif_rx(skb);\n}\n\n/* For USBCAN, report error to userspace if the channels's errors counter\n * has changed, or we're the only channel seeing a bus error state.\n */\nstatic void\nkvaser_usb_leaf_usbcan_conditionally_rx_error(const struct kvaser_usb *dev,\n\t\t\t\t\t      struct kvaser_usb_err_summary *es)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\tunsigned int channel;\n\tbool report_error;\n\n\tchannel = es->channel;\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\treport_error = false;\n\n\tif (es->txerr != priv->bec.txerr) {\n\t\tes->usbcan.error_state |= USBCAN_ERROR_STATE_TX_ERROR;\n\t\treport_error = true;\n\t}\n\tif (es->rxerr != priv->bec.rxerr) {\n\t\tes->usbcan.error_state |= USBCAN_ERROR_STATE_RX_ERROR;\n\t\treport_error = true;\n\t}\n\tif ((es->status & M16C_STATE_BUS_ERROR) &&\n\t    !(es->usbcan.other_ch_status & M16C_STATE_BUS_ERROR)) {\n\t\tes->usbcan.error_state |= USBCAN_ERROR_STATE_BUSERROR;\n\t\treport_error = true;\n\t}\n\n\tif (report_error)\n\t\tkvaser_usb_leaf_rx_error(dev, es);\n}\n\nstatic void kvaser_usb_leaf_usbcan_rx_error(const struct kvaser_usb *dev,\n\t\t\t\t\t    const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_err_summary es = { };\n\n\tswitch (cmd->id) {\n\t/* Sometimes errors are sent as unsolicited chip state events */\n\tcase CMD_CHIP_STATE_EVENT:\n\t\tes.channel = cmd->u.usbcan.chip_state_event.channel;\n\t\tes.status = cmd->u.usbcan.chip_state_event.status;\n\t\tes.txerr = cmd->u.usbcan.chip_state_event.tx_errors_count;\n\t\tes.rxerr = cmd->u.usbcan.chip_state_event.rx_errors_count;\n\t\tkvaser_usb_leaf_usbcan_conditionally_rx_error(dev, &es);\n\t\tbreak;\n\n\tcase CMD_CAN_ERROR_EVENT:\n\t\tes.channel = 0;\n\t\tes.status = cmd->u.usbcan.error_event.status_ch0;\n\t\tes.txerr = cmd->u.usbcan.error_event.tx_errors_count_ch0;\n\t\tes.rxerr = cmd->u.usbcan.error_event.rx_errors_count_ch0;\n\t\tes.usbcan.other_ch_status =\n\t\t\tcmd->u.usbcan.error_event.status_ch1;\n\t\tkvaser_usb_leaf_usbcan_conditionally_rx_error(dev, &es);\n\n\t\t/* The USBCAN firmware supports up to 2 channels.\n\t\t * Now that ch0 was checked, check if ch1 has any errors.\n\t\t */\n\t\tif (dev->nchannels == MAX_USBCAN_NET_DEVICES) {\n\t\t\tes.channel = 1;\n\t\t\tes.status = cmd->u.usbcan.error_event.status_ch1;\n\t\t\tes.txerr =\n\t\t\t\tcmd->u.usbcan.error_event.tx_errors_count_ch1;\n\t\t\tes.rxerr =\n\t\t\t\tcmd->u.usbcan.error_event.rx_errors_count_ch1;\n\t\t\tes.usbcan.other_ch_status =\n\t\t\t\tcmd->u.usbcan.error_event.status_ch0;\n\t\t\tkvaser_usb_leaf_usbcan_conditionally_rx_error(dev, &es);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&dev->intf->dev, \"Invalid cmd id (%d)\\n\", cmd->id);\n\t}\n}\n\nstatic void kvaser_usb_leaf_leaf_rx_error(const struct kvaser_usb *dev,\n\t\t\t\t\t  const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_err_summary es = { };\n\n\tswitch (cmd->id) {\n\tcase CMD_CAN_ERROR_EVENT:\n\t\tes.channel = cmd->u.leaf.error_event.channel;\n\t\tes.status = cmd->u.leaf.error_event.status;\n\t\tes.txerr = cmd->u.leaf.error_event.tx_errors_count;\n\t\tes.rxerr = cmd->u.leaf.error_event.rx_errors_count;\n\t\tes.leaf.error_factor = cmd->u.leaf.error_event.error_factor;\n\t\tbreak;\n\tcase CMD_LEAF_LOG_MESSAGE:\n\t\tes.channel = cmd->u.leaf.log_message.channel;\n\t\tes.status = cmd->u.leaf.log_message.data[0];\n\t\tes.txerr = cmd->u.leaf.log_message.data[2];\n\t\tes.rxerr = cmd->u.leaf.log_message.data[3];\n\t\tes.leaf.error_factor = cmd->u.leaf.log_message.data[1];\n\t\tbreak;\n\tcase CMD_CHIP_STATE_EVENT:\n\t\tes.channel = cmd->u.leaf.chip_state_event.channel;\n\t\tes.status = cmd->u.leaf.chip_state_event.status;\n\t\tes.txerr = cmd->u.leaf.chip_state_event.tx_errors_count;\n\t\tes.rxerr = cmd->u.leaf.chip_state_event.rx_errors_count;\n\t\tes.leaf.error_factor = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->intf->dev, \"Invalid cmd id (%d)\\n\", cmd->id);\n\t\treturn;\n\t}\n\n\tkvaser_usb_leaf_rx_error(dev, &es);\n}\n\nstatic void kvaser_usb_leaf_rx_can_err(const struct kvaser_usb_net_priv *priv,\n\t\t\t\t       const struct kvaser_cmd *cmd)\n{\n\tif (cmd->u.rx_can_header.flag & (MSG_FLAG_ERROR_FRAME |\n\t\t\t\t\t MSG_FLAG_NERR)) {\n\t\tstruct net_device_stats *stats = &priv->netdev->stats;\n\n\t\tnetdev_err(priv->netdev, \"Unknown error (flags: 0x%02x)\\n\",\n\t\t\t   cmd->u.rx_can_header.flag);\n\n\t\tstats->rx_errors++;\n\t\treturn;\n\t}\n\n\tif (cmd->u.rx_can_header.flag & MSG_FLAG_OVERRUN)\n\t\tkvaser_usb_can_rx_over_error(priv->netdev);\n}\n\nstatic void kvaser_usb_leaf_rx_can_msg(const struct kvaser_usb *dev,\n\t\t\t\t       const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats;\n\tu8 channel = cmd->u.rx_can_header.channel;\n\tconst u8 *rx_data = NULL;\t/* GCC */\n\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\tstats = &priv->netdev->stats;\n\n\tif ((cmd->u.rx_can_header.flag & MSG_FLAG_ERROR_FRAME) &&\n\t    (dev->card_data.leaf.family == KVASER_LEAF &&\n\t     cmd->id == CMD_LEAF_LOG_MESSAGE)) {\n\t\tkvaser_usb_leaf_leaf_rx_error(dev, cmd);\n\t\treturn;\n\t} else if (cmd->u.rx_can_header.flag & (MSG_FLAG_ERROR_FRAME |\n\t\t\t\t\t\tMSG_FLAG_NERR |\n\t\t\t\t\t\tMSG_FLAG_OVERRUN)) {\n\t\tkvaser_usb_leaf_rx_can_err(priv, cmd);\n\t\treturn;\n\t} else if (cmd->u.rx_can_header.flag & ~MSG_FLAG_REMOTE_FRAME) {\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Unhandled frame (flags: 0x%02x)\\n\",\n\t\t\t    cmd->u.rx_can_header.flag);\n\t\treturn;\n\t}\n\n\tswitch (dev->card_data.leaf.family) {\n\tcase KVASER_LEAF:\n\t\trx_data = cmd->u.leaf.rx_can.data;\n\t\tbreak;\n\tcase KVASER_USBCAN:\n\t\trx_data = cmd->u.usbcan.rx_can.data;\n\t\tbreak;\n\t}\n\n\tskb = alloc_can_skb(priv->netdev, &cf);\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn;\n\t}\n\n\tif (dev->card_data.leaf.family == KVASER_LEAF && cmd->id ==\n\t    CMD_LEAF_LOG_MESSAGE) {\n\t\tcf->can_id = le32_to_cpu(cmd->u.leaf.log_message.id);\n\t\tif (cf->can_id & KVASER_EXTENDED_FRAME)\n\t\t\tcf->can_id &= CAN_EFF_MASK | CAN_EFF_FLAG;\n\t\telse\n\t\t\tcf->can_id &= CAN_SFF_MASK;\n\n\t\tcf->can_dlc = get_can_dlc(cmd->u.leaf.log_message.dlc);\n\n\t\tif (cmd->u.leaf.log_message.flags & MSG_FLAG_REMOTE_FRAME)\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\t\telse\n\t\t\tmemcpy(cf->data, &cmd->u.leaf.log_message.data,\n\t\t\t       cf->can_dlc);\n\t} else {\n\t\tcf->can_id = ((rx_data[0] & 0x1f) << 6) | (rx_data[1] & 0x3f);\n\n\t\tif (cmd->id == CMD_RX_EXT_MESSAGE) {\n\t\t\tcf->can_id <<= 18;\n\t\t\tcf->can_id |= ((rx_data[2] & 0x0f) << 14) |\n\t\t\t\t      ((rx_data[3] & 0xff) << 6) |\n\t\t\t\t      (rx_data[4] & 0x3f);\n\t\t\tcf->can_id |= CAN_EFF_FLAG;\n\t\t}\n\n\t\tcf->can_dlc = get_can_dlc(rx_data[5]);\n\n\t\tif (cmd->u.rx_can_header.flag & MSG_FLAG_REMOTE_FRAME)\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\t\telse\n\t\t\tmemcpy(cf->data, &rx_data[6], cf->can_dlc);\n\t}\n\n\tstats->rx_packets++;\n\tstats->rx_bytes += cf->can_dlc;\n\tnetif_rx(skb);\n}\n\nstatic void kvaser_usb_leaf_start_chip_reply(const struct kvaser_usb *dev,\n\t\t\t\t\t     const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\tu8 channel = cmd->u.simple.channel;\n\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\n\tif (completion_done(&priv->start_comp) &&\n\t    netif_queue_stopped(priv->netdev)) {\n\t\tnetif_wake_queue(priv->netdev);\n\t} else {\n\t\tnetif_start_queue(priv->netdev);\n\t\tcomplete(&priv->start_comp);\n\t}\n}\n\nstatic void kvaser_usb_leaf_stop_chip_reply(const struct kvaser_usb *dev,\n\t\t\t\t\t    const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\tu8 channel = cmd->u.simple.channel;\n\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\n\tcomplete(&priv->stop_comp);\n}\n\nstatic void kvaser_usb_leaf_handle_command(const struct kvaser_usb *dev,\n\t\t\t\t\t   const struct kvaser_cmd *cmd)\n{\n\tswitch (cmd->id) {\n\tcase CMD_START_CHIP_REPLY:\n\t\tkvaser_usb_leaf_start_chip_reply(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_STOP_CHIP_REPLY:\n\t\tkvaser_usb_leaf_stop_chip_reply(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_RX_STD_MESSAGE:\n\tcase CMD_RX_EXT_MESSAGE:\n\t\tkvaser_usb_leaf_rx_can_msg(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_LEAF_LOG_MESSAGE:\n\t\tif (dev->card_data.leaf.family != KVASER_LEAF)\n\t\t\tgoto warn;\n\t\tkvaser_usb_leaf_rx_can_msg(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_CHIP_STATE_EVENT:\n\tcase CMD_CAN_ERROR_EVENT:\n\t\tif (dev->card_data.leaf.family == KVASER_LEAF)\n\t\t\tkvaser_usb_leaf_leaf_rx_error(dev, cmd);\n\t\telse\n\t\t\tkvaser_usb_leaf_usbcan_rx_error(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_TX_ACKNOWLEDGE:\n\t\tkvaser_usb_leaf_tx_acknowledge(dev, cmd);\n\t\tbreak;\n\n\t/* Ignored commands */\n\tcase CMD_USBCAN_CLOCK_OVERFLOW_EVENT:\n\t\tif (dev->card_data.leaf.family != KVASER_USBCAN)\n\t\t\tgoto warn;\n\t\tbreak;\n\n\tcase CMD_FLUSH_QUEUE_REPLY:\n\t\tif (dev->card_data.leaf.family != KVASER_LEAF)\n\t\t\tgoto warn;\n\t\tbreak;\n\n\tdefault:\nwarn:\t\tdev_warn(&dev->intf->dev, \"Unhandled command (%d)\\n\", cmd->id);\n\t\tbreak;\n\t}\n}\n\nstatic void kvaser_usb_leaf_read_bulk_callback(struct kvaser_usb *dev,\n\t\t\t\t\t       void *buf, int len)\n{\n\tstruct kvaser_cmd *cmd;\n\tint pos = 0;\n\n\twhile (pos <= len - CMD_HEADER_LEN) {\n\t\tcmd = buf + pos;\n\n\t\t/* The Kvaser firmware can only read and write commands that\n\t\t * does not cross the USB's endpoint wMaxPacketSize boundary.\n\t\t * If a follow-up command crosses such boundary, firmware puts\n\t\t * a placeholder zero-length command in its place then aligns\n\t\t * the real command to the next max packet size.\n\t\t *\n\t\t * Handle such cases or we're going to miss a significant\n\t\t * number of events in case of a heavy rx load on the bus.\n\t\t */\n\t\tif (cmd->len == 0) {\n\t\t\tpos = round_up(pos, le16_to_cpu\n\t\t\t\t\t\t(dev->bulk_in->wMaxPacketSize));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pos + cmd->len > len) {\n\t\t\tdev_err_ratelimited(&dev->intf->dev, \"Format error\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tkvaser_usb_leaf_handle_command(dev, cmd);\n\t\tpos += cmd->len;\n\t}\n}\n\nstatic int kvaser_usb_leaf_set_opt_mode(const struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_SET_CTRL_MODE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_ctrl_mode);\n\tcmd->u.ctrl_mode.tid = 0xff;\n\tcmd->u.ctrl_mode.channel = priv->channel;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_SILENT;\n\telse\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_NORMAL;\n\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}\n\nstatic int kvaser_usb_leaf_start_chip(struct kvaser_usb_net_priv *priv)\n{\n\tint err;\n\n\tinit_completion(&priv->start_comp);\n\n\terr = kvaser_usb_leaf_send_simple_cmd(priv->dev, CMD_START_CHIP,\n\t\t\t\t\t      priv->channel);\n\tif (err)\n\t\treturn err;\n\n\tif (!wait_for_completion_timeout(&priv->start_comp,\n\t\t\t\t\t msecs_to_jiffies(KVASER_USB_TIMEOUT)))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_stop_chip(struct kvaser_usb_net_priv *priv)\n{\n\tint err;\n\n\tinit_completion(&priv->stop_comp);\n\n\terr = kvaser_usb_leaf_send_simple_cmd(priv->dev, CMD_STOP_CHIP,\n\t\t\t\t\t      priv->channel);\n\tif (err)\n\t\treturn err;\n\n\tif (!wait_for_completion_timeout(&priv->stop_comp,\n\t\t\t\t\t msecs_to_jiffies(KVASER_USB_TIMEOUT)))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_reset_chip(struct kvaser_usb *dev, int channel)\n{\n\treturn kvaser_usb_leaf_send_simple_cmd(dev, CMD_RESET_CHIP, channel);\n}\n\nstatic int kvaser_usb_leaf_flush_queue(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_FLUSH_QUEUE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_flush_queue);\n\tcmd->u.flush_queue.channel = priv->channel;\n\tcmd->u.flush_queue.flags = 0x00;\n\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}\n\nstatic int kvaser_usb_leaf_init_card(struct kvaser_usb *dev)\n{\n\tstruct kvaser_usb_dev_card_data *card_data = &dev->card_data;\n\n\tdev->cfg = &kvaser_usb_leaf_dev_cfg;\n\tcard_data->ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\n\n\treturn 0;\n}\n\nstatic const struct can_bittiming_const kvaser_usb_leaf_bittiming_const = {\n\t.name = \"kvaser_usb\",\n\t.tseg1_min = KVASER_USB_TSEG1_MIN,\n\t.tseg1_max = KVASER_USB_TSEG1_MAX,\n\t.tseg2_min = KVASER_USB_TSEG2_MIN,\n\t.tseg2_max = KVASER_USB_TSEG2_MAX,\n\t.sjw_max = KVASER_USB_SJW_MAX,\n\t.brp_min = KVASER_USB_BRP_MIN,\n\t.brp_max = KVASER_USB_BRP_MAX,\n\t.brp_inc = KVASER_USB_BRP_INC,\n};\n\nstatic int kvaser_usb_leaf_set_bittiming(struct net_device *netdev)\n{\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tstruct kvaser_usb *dev = priv->dev;\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_SET_BUS_PARAMS;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_busparams);\n\tcmd->u.busparams.channel = priv->channel;\n\tcmd->u.busparams.tid = 0xff;\n\tcmd->u.busparams.bitrate = cpu_to_le32(bt->bitrate);\n\tcmd->u.busparams.sjw = bt->sjw;\n\tcmd->u.busparams.tseg1 = bt->prop_seg + bt->phase_seg1;\n\tcmd->u.busparams.tseg2 = bt->phase_seg2;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tcmd->u.busparams.no_samp = 3;\n\telse\n\t\tcmd->u.busparams.no_samp = 1;\n\n\trc = kvaser_usb_send_cmd(dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}\n\nstatic int kvaser_usb_leaf_set_mode(struct net_device *netdev,\n\t\t\t\t    enum can_mode mode)\n{\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\tint err;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\terr = kvaser_usb_leaf_simple_cmd_async(priv, CMD_START_CHIP);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_get_berr_counter(const struct net_device *netdev,\n\t\t\t\t\t    struct can_berr_counter *bec)\n{\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\n\t*bec = priv->bec;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_setup_endpoints(struct kvaser_usb *dev)\n{\n\tconst struct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint i;\n\n\tiface_desc = &dev->intf->altsetting[0];\n\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (!dev->bulk_in && usb_endpoint_is_bulk_in(endpoint))\n\t\t\tdev->bulk_in = endpoint;\n\n\t\tif (!dev->bulk_out && usb_endpoint_is_bulk_out(endpoint))\n\t\t\tdev->bulk_out = endpoint;\n\n\t\t/* use first bulk endpoint for in and out */\n\t\tif (dev->bulk_in && dev->bulk_out)\n\t\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nconst struct kvaser_usb_dev_ops kvaser_usb_leaf_dev_ops = {\n\t.dev_set_mode = kvaser_usb_leaf_set_mode,\n\t.dev_set_bittiming = kvaser_usb_leaf_set_bittiming,\n\t.dev_set_data_bittiming = NULL,\n\t.dev_get_berr_counter = kvaser_usb_leaf_get_berr_counter,\n\t.dev_setup_endpoints = kvaser_usb_leaf_setup_endpoints,\n\t.dev_init_card = kvaser_usb_leaf_init_card,\n\t.dev_get_software_info = kvaser_usb_leaf_get_software_info,\n\t.dev_get_software_details = NULL,\n\t.dev_get_card_info = kvaser_usb_leaf_get_card_info,\n\t.dev_get_capabilities = NULL,\n\t.dev_set_opt_mode = kvaser_usb_leaf_set_opt_mode,\n\t.dev_start_chip = kvaser_usb_leaf_start_chip,\n\t.dev_stop_chip = kvaser_usb_leaf_stop_chip,\n\t.dev_reset_chip = kvaser_usb_leaf_reset_chip,\n\t.dev_flush_queue = kvaser_usb_leaf_flush_queue,\n\t.dev_read_bulk_callback = kvaser_usb_leaf_read_bulk_callback,\n\t.dev_frame_to_cmd = kvaser_usb_leaf_frame_to_cmd,\n};\n\nstatic const struct kvaser_usb_dev_cfg kvaser_usb_leaf_dev_cfg = {\n\t.clock = {\n\t\t.freq = CAN_USB_CLOCK,\n\t},\n\t.timestamp_freq = 1,\n\t.bittiming_const = &kvaser_usb_leaf_bittiming_const,\n};\n"], "filenames": ["drivers/net/can/usb/kvaser_usb/kvaser_usb_leaf.c"], "buggy_code_start_loc": [611], "buggy_code_end_loc": [1210], "fixing_code_start_loc": [611], "fixing_code_end_loc": [1210], "type": "CWE-908", "message": "In the Linux kernel through 5.4.6, there are information leaks of uninitialized memory to a USB device in the drivers/net/can/usb/kvaser_usb/kvaser_usb_leaf.c driver, aka CID-da2311a6385c.", "other": {"cve": {"id": "CVE-2019-19947", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-24T00:15:10.963", "lastModified": "2022-11-09T21:49:08.647", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel through 5.4.6, there are information leaks of uninitialized memory to a USB device in the drivers/net/can/usb/kvaser_usb/kvaser_usb_leaf.c driver, aka CID-da2311a6385c."}, {"lang": "es", "value": "En el kernel de Linux versiones hasta 5.4.6, se presenta un filtrado de informaci\u00f3n de la memoria no inicializada hacia un dispositivo USB en el archivo controlador drivers/net/can/usb/kvaser_usb/kvaser_usb_leaf.c, tambi\u00e9n se conoce como CID-da2311a6385c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-908"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.4.6", "matchCriteriaId": "2BB5C122-1D76-4254-B523-5A7026CE8526"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:data_availability_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "0EF46487-B64A-454E-AECC-D74B83170ACD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0", "versionEndIncluding": "11.70.2", "matchCriteriaId": "A0DA944C-4992-424D-BC82-474585DAC5DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:fas\\/aff_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "66EEA3CA-8CC7-4F0B-8204-6132D4114873"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_baseboard_management_controller:h610s:*:*:*:*:*:*:*", "matchCriteriaId": "DE7C6010-F736-4BDA-9E3B-C4370BBFA149"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_\\&_hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "D6D700C5-F67F-4FFB-BE69-D524592A3D2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:steelstore_cloud_integrated_storage:-:*:*:*:*:*:*:*", "matchCriteriaId": "E94F7F59-1785-493F-91A7-5F5EA5E87E4D"}, {"vulnerable": true, "criteria": "cpe:2.3:h:netapp:aff_baseboard_management_controller:a700s:*:*:*:*:*:*:*", "matchCriteriaId": "804B2D7C-D890-4C4C-8A76-1760552E11BC"}, {"vulnerable": true, "criteria": "cpe:2.3:h:netapp:solidfire_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "090AA6F4-4404-4E26-82AB-C3A22636F276"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2019/12/24/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/da2311a6385c3b499da2ed5d9be59ce331fa93e9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/01/msg00013.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200204-0002/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4284-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4285-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4427-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4485-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/da2311a6385c3b499da2ed5d9be59ce331fa93e9"}}