{"buggy_code": ["from __future__ import annotations\n\nimport datetime\nimport os\nimport secrets\nimport uuid\nfrom typing import Dict, List, Literal, Tuple, Union\n\nimport requests\nfrom flask import (\n    Flask,\n    Request,\n    Response,\n    jsonify,\n    redirect,\n    request,\n    send_from_directory,\n)\nfrom werkzeug.security import check_password_hash, generate_password_hash\n\nfrom app.connections import db\nfrom app.models import Token, User\nfrom app.utils import PathType, _AuthCacheDictionary, get_auth_cache, set_auth_cache\n\n# This auth_cache is shared between requests\n# within the same Flask process\n_auth_cache: _AuthCacheDictionary = {}\n_auth_cache_age: int = 3  # in seconds\n\n\ndef register_views(app: Flask) -> None:\n    @app.after_request\n    def add_header(r: Response) -> Response:\n        \"\"\"\n        Disable cache for all auth server requests\n        \"\"\"\n        r.headers[\"Cache-Control\"] = \"no-cache, no-store, must-revalidate\"\n        r.headers[\"Pragma\"] = \"no-cache\"\n        r.headers[\"Expires\"] = \"0\"\n        r.headers[\"Cache-Control\"] = \"public, max-age=0\"\n        return r\n\n    # NOTE! This is an unprotected route for config for client\n    # side initialization.\n    @app.route(\"/login/server-config\", methods=[\"GET\"])\n    def server_config() -> Response:\n        return jsonify(\n            {\n                \"CLOUD\": app.config.get(\"CLOUD\"),\n                \"CLOUD_URL\": app.config.get(\"CLOUD_URL\"),\n                \"GITHUB_URL\": app.config.get(\"GITHUB_URL\"),\n                \"DOCUMENTATION_URL\": app.config.get(\"DOCUMENTATION_URL\"),\n                \"VIDEOS_URL\": app.config.get(\"VIDEOS_URL\"),\n            }\n        )\n\n    def is_authenticated(request: Request) -> bool:\n        # If authentication is not enabled then the request is always\n        # authenticated (by definition).\n        if not app.config[\"AUTH_ENABLED\"]:\n            return True\n\n        cookie_token = request.cookies.get(\"auth_token\")\n        username = request.cookies.get(\"auth_username\")\n\n        token_creation_limit = datetime.datetime.utcnow() - datetime.timedelta(\n            hours=app.config[\"TOKEN_DURATION_HOURS\"]\n        )\n        return db.session.query(\n            db.session.query(Token)\n            .join(User)\n            .filter(\n                Token.token == cookie_token,\n                User.username == username,\n                Token.created > token_creation_limit,\n            )\n            .exists()\n        ).scalar()\n\n    def serve_static_or_dev(path: PathType) -> Response:\n        file_path = os.path.join(app.config[\"STATIC_DIR\"], path)\n        if os.path.isfile(file_path):\n            return send_from_directory(app.config[\"STATIC_DIR\"], path)\n        else:\n            return send_from_directory(app.config[\"STATIC_DIR\"], \"index.html\")\n\n    # static file serving\n    @app.route(\"/login\", defaults={\"path\": \"\"}, methods=[\"GET\"])\n    @app.route(\"/login/<path:path>\", methods=[\"GET\"])\n    def login_static(path: PathType) -> Response:\n\n        # Automatically redirect to root if request is authenticated\n        if is_authenticated(request) and path == \"\":\n            return handle_login(redirect_type=\"server\")\n\n        return serve_static_or_dev(path)\n\n    @app.route(\"/login/admin\", methods=[\"GET\"])\n    def login_admin() -> Tuple[str, int] | Response:\n\n        if not is_authenticated(request):\n            return \"\", 401\n\n        return serve_static_or_dev(\"/admin\")\n\n    @app.route(\"/auth\", methods=[\"GET\"])\n    def index() -> Tuple[Literal[\"\"], Literal[200]] | Tuple[Literal[\"\"], Literal[401]]:\n        # validate authentication through token\n        if is_authenticated(request):\n            return \"\", 200\n        else:\n            return \"\", 401\n\n    @app.route(\"/login/clear\", methods=[\"GET\"])\n    def logout() -> Response | None:\n        resp = redirect_response(\"/\")\n        resp.set_cookie(\"auth_token\", \"\")\n        resp.set_cookie(\"auth_username\", \"\")\n        return resp\n\n    def redirect_response(url: str, redirect_type: str = \"server\") -> Response:\n        if redirect_type == \"client\":\n            return jsonify({\"redirect\": url})\n        elif redirect_type == \"server\":\n            return redirect(url)\n\n    @app.route(\"/login/submit\", methods=[\"POST\"])\n    def login() -> Response | Tuple[Response, Literal[401]] | None:\n        return handle_login()\n\n    @app.route(\"/login\", methods=[\"POST\"])\n    def login_post() -> Response | Tuple[Response, Literal[401]] | None:\n        return handle_login(redirect_type=\"server\")\n\n    def handle_login(\n        redirect_type: str = \"client\",\n    ) -> Response | Tuple[Response, Literal[401]] | None:\n\n        # Returns a shallow mutable copy of the immutable\n        # multi dict.\n        request_args = request.args.copy()\n        redirect_url = request_args.pop(\"redirect_url\", \"/\")\n        query_args = \"&\".join(\n            [arg + \"=\" + value for arg, value in request_args.items()]\n        )\n        if query_args:\n            redirect_url += \"?\" + query_args\n\n        if is_authenticated(request):\n            return redirect_response(redirect_url, redirect_type)\n\n        if request.method == \"POST\":\n            token_creation_limit = datetime.datetime.utcnow() - datetime.timedelta(\n                hours=app.config[\"TOKEN_DURATION_HOURS\"]\n            )\n            # Remove outdated tokens.\n            Token.query.filter(Token.created < token_creation_limit).delete()\n\n            username = request.form.get(\"username\")\n            password = request.form.get(\"password\")\n            token = request.form.get(\"token\")\n\n            # Check whether the given user exists.\n            user = User.query.filter(User.username == username).first()\n\n            invalid_login_msg = \"Username password combination does not exist.\"\n            if user is None:\n                return jsonify({\"error\": invalid_login_msg}), 401\n            else:\n                if password is not None:\n                    can_login = check_password_hash(user.password_hash, password)\n                elif token is not None and user.token_hash is not None:\n                    can_login = check_password_hash(user.token_hash, token)\n                else:\n                    can_login = False\n\n                if can_login:\n\n                    token = Token(user=user.uuid, token=str(secrets.token_hex(16)))\n\n                    db.session.add(token)\n                    db.session.commit()\n\n                    resp = redirect_response(redirect_url, redirect_type)\n                    resp.set_cookie(\"auth_token\", token.token)\n                    resp.set_cookie(\"auth_username\", username)\n\n                    return resp\n\n                else:\n                    return jsonify({\"error\": invalid_login_msg}), 401\n\n    @app.route(\"/login/users\", methods=[\"DELETE\"])\n    def delete_user() -> Union[\n        Tuple[Literal[\"\"], Literal[401]],\n        Tuple[Response, Literal[500]],\n        Tuple[Response, Literal[405]],\n        Literal[\"\"],\n    ]:\n        if not is_authenticated(request):\n            return \"\", 401\n\n        self_username = request.cookies.get(\"auth_username\")\n        if \"username\" in request.form:\n            to_delete_username = request.form.get(\"username\")\n\n            user = User.query.filter(User.username == to_delete_username).first()\n            if user is not None:\n                if user.is_admin:\n                    return jsonify({\"error\": \"Admins cannot be deleted.\"}), 500\n                elif self_username == to_delete_username:\n                    return jsonify({\"error\": \"Deleting own user is not allowed.\"}), 405\n                else:\n                    db.session.delete(user)\n                    db.session.commit()\n                    return \"\"\n            else:\n                return jsonify({\"error\": \"User does not exist.\"}), 500\n        else:\n            return jsonify({\"error\": \"No username supplied.\"}), 500\n\n    @app.route(\"/login/users\", methods=[\"POST\"])\n    def add_user() -> Union[\n        Tuple[Literal[\"\"], Literal[401]],\n        Tuple[Response, Literal[409]],\n        Tuple[Response, Literal[400]],\n        Literal[\"\"],\n    ]:\n        if not is_authenticated(request):\n            return \"\", 401\n\n        if \"username\" in request.form:\n\n            username = request.form.get(\"username\")\n            password = request.form.get(\"password\")\n\n            if username == app.config.get(\"ORCHEST_CLOUD_RESERVED_USER\"):\n                return jsonify({\"error\": \"User is reserved.\"}), 409\n\n            if len(password) == 0:\n                return jsonify({\"error\": \"Password cannot be empty.\"}), 400\n\n            user = User.query.filter(User.username == username).first()\n            if user is not None:\n                return jsonify({\"error\": \"User already exists.\"}), 409\n\n            user = User(\n                username=username,\n                password_hash=generate_password_hash(password),\n                uuid=str(uuid.uuid4()),\n            )\n\n            db.session.add(user)\n            db.session.commit()\n            return \"\"\n        else:\n            return jsonify({\"error\": \"No username supplied.\"}), 400\n\n    @app.route(\"/login/users\", methods=[\"GET\"])\n    def get_users() -> Tuple[Literal[\"\"], Literal[401]] | Tuple[Response, Literal[200]]:\n        if not is_authenticated(request):\n            return \"\", 401\n\n        data_json: Dict[\n            Literal[\"users\"],\n            List[Dict[Literal[\"username\"], str]],\n        ] = {\"users\": []}\n        users = User.query.all()\n        for user in users:\n            if user.username != app.config.get(\"ORCHEST_CLOUD_RESERVED_USER\"):\n                data_json[\"users\"].append({\"username\": user.username})\n\n        return jsonify(data_json), 200\n\n    @app.route(\"/auth/service\", methods=[\"GET\"])\n    def auth_service() -> Union[\n        Tuple[Literal[\"\"], Literal[200]],\n        Tuple[Literal[\"\"], Literal[401]],\n    ]:\n        global _auth_cache, _auth_cache_age\n\n        # Bypass definition based authentication if the request\n        # is authenticated\n        if is_authenticated(request):\n            return \"\", 200\n\n        # request URI\n        original_uri = request.headers.get(\"X-Original-URI\")\n\n        if original_uri is None:\n            return \"\", 401\n\n        try:\n            # expected uri:\n            # /pbp-service-[service-name]-\n            # [pipeline_uuid_prefix]-[session_uuid_prefix]_[port]/...\n            components = original_uri.split(\"/\")[1].split(\"_\")[-2].split(\"-\")\n            session_uuid_prefix = components[-1]\n            project_uuid_prefix = components[-2]\n        except Exception:\n            app.logger.error(\"Failed to parse X-Original-URI: %s\" % original_uri)\n            return \"\", 401\n\n        auth_check = get_auth_cache(\n            project_uuid_prefix, session_uuid_prefix, _auth_cache, _auth_cache_age\n        )\n        if auth_check[\"status\"] == \"available\":\n            if auth_check[\"requires_authentication\"] is False:\n                return \"\", 200\n            else:\n                return \"\", 401\n        else:\n            # No cache available, fetch from orchest-api\n            base_url = \"http://%s/api/services/\" % (app.config[\"ORCHEST_API_ADDRESS\"])\n            service_url = \"%s?project_uuid_prefix=%s&session_uuid_prefix=%s\" % (\n                base_url,\n                project_uuid_prefix,\n                session_uuid_prefix,\n            )\n\n            try:\n                r = requests.get(service_url)\n                services = r.json().get(\"services\", [])\n\n                # No service is found for given filter\n                if len(services) == 0:\n                    raise Exception(\"No services found\")\n\n                if len(services) > 1:\n                    raise Exception(\n                        \"Filtered /api/services endpoint \"\n                        \"should always return a single service\"\n                    )\n\n                # Always check first service that is returned,\n                # should be unique\n                if services[0][\"service\"][\"requires_authentication\"] is False:\n                    set_auth_cache(\n                        project_uuid_prefix, session_uuid_prefix, False, _auth_cache\n                    )\n                    return \"\", 200\n                else:\n                    set_auth_cache(\n                        project_uuid_prefix, session_uuid_prefix, True, _auth_cache\n                    )\n                    raise Exception(\"'requires_authentication' is not set to False\")\n\n            except Exception as e:\n                app.logger.error(e)\n                return \"\", 401\n"], "fixing_code": ["from __future__ import annotations\n\nimport datetime\nimport os\nimport secrets\nimport uuid\nfrom typing import Dict, List, Literal, Tuple, Union\n\nimport requests\nfrom flask import (\n    Flask,\n    Request,\n    Response,\n    jsonify,\n    redirect,\n    request,\n    send_from_directory,\n)\nfrom werkzeug.security import check_password_hash, generate_password_hash\n\nfrom app.connections import db\nfrom app.models import Token, User\nfrom app.utils import PathType, _AuthCacheDictionary, get_auth_cache, set_auth_cache\n\n# This auth_cache is shared between requests\n# within the same Flask process\n_auth_cache: _AuthCacheDictionary = {}\n_auth_cache_age: int = 3  # in seconds\n\n\ndef register_views(app: Flask) -> None:\n    @app.after_request\n    def add_header(r: Response) -> Response:\n        \"\"\"\n        Disable cache for all auth server requests\n        \"\"\"\n        r.headers[\"Cache-Control\"] = \"no-cache, no-store, must-revalidate\"\n        r.headers[\"Pragma\"] = \"no-cache\"\n        r.headers[\"Expires\"] = \"0\"\n        r.headers[\"Cache-Control\"] = \"public, max-age=0\"\n        return r\n\n    # NOTE! This is an unprotected route for config for client\n    # side initialization.\n    @app.route(\"/login/server-config\", methods=[\"GET\"])\n    def server_config() -> Response:\n        return jsonify(\n            {\n                \"CLOUD\": app.config.get(\"CLOUD\"),\n                \"CLOUD_URL\": app.config.get(\"CLOUD_URL\"),\n                \"GITHUB_URL\": app.config.get(\"GITHUB_URL\"),\n                \"DOCUMENTATION_URL\": app.config.get(\"DOCUMENTATION_URL\"),\n                \"VIDEOS_URL\": app.config.get(\"VIDEOS_URL\"),\n            }\n        )\n\n    def is_authenticated(request: Request) -> bool:\n        # If authentication is not enabled then the request is always\n        # authenticated (by definition).\n        if not app.config[\"AUTH_ENABLED\"]:\n            return True\n\n        cookie_token = request.cookies.get(\"auth_token\")\n        username = request.cookies.get(\"auth_username\")\n\n        token_creation_limit = datetime.datetime.utcnow() - datetime.timedelta(\n            hours=app.config[\"TOKEN_DURATION_HOURS\"]\n        )\n        return db.session.query(\n            db.session.query(Token)\n            .join(User)\n            .filter(\n                Token.token == cookie_token,\n                User.username == username,\n                Token.created > token_creation_limit,\n            )\n            .exists()\n        ).scalar()\n\n    def serve_static_or_dev(path: PathType) -> Response:\n        file_path = os.path.join(app.config[\"STATIC_DIR\"], path)\n        if os.path.isfile(file_path):\n            return send_from_directory(app.config[\"STATIC_DIR\"], path)\n        else:\n            return send_from_directory(app.config[\"STATIC_DIR\"], \"index.html\")\n\n    # static file serving\n    @app.route(\"/login\", defaults={\"path\": \"\"}, methods=[\"GET\"])\n    @app.route(\"/login/<path:path>\", methods=[\"GET\"])\n    def login_static(path: PathType) -> Response:\n\n        # Automatically redirect to root if request is authenticated\n        if is_authenticated(request) and path == \"\":\n            return handle_login(redirect_type=\"server\")\n\n        return serve_static_or_dev(path)\n\n    @app.route(\"/login/admin\", methods=[\"GET\"])\n    def login_admin() -> Tuple[str, int] | Response:\n\n        if not is_authenticated(request):\n            return \"\", 401\n\n        return serve_static_or_dev(\"/admin\")\n\n    @app.route(\"/auth\", methods=[\"GET\"])\n    def index() -> Tuple[Literal[\"\"], Literal[200]] | Tuple[Literal[\"\"], Literal[401]]:\n        # validate authentication through token\n        if is_authenticated(request):\n            return \"\", 200\n        else:\n            return \"\", 401\n\n    @app.route(\"/login/clear\", methods=[\"GET\"])\n    def logout() -> Response | None:\n        resp = redirect_response(\"/\")\n        resp.set_cookie(\"auth_token\", \"\", samesite=\"Lax\")\n        resp.set_cookie(\"auth_username\", samesite=\"Lax\")\n        return resp\n\n    def redirect_response(url: str, redirect_type: str = \"server\") -> Response:\n        if redirect_type == \"client\":\n            return jsonify({\"redirect\": url})\n        elif redirect_type == \"server\":\n            return redirect(url)\n\n    @app.route(\"/login/submit\", methods=[\"POST\"])\n    def login() -> Response | Tuple[Response, Literal[401]] | None:\n        return handle_login()\n\n    @app.route(\"/login\", methods=[\"POST\"])\n    def login_post() -> Response | Tuple[Response, Literal[401]] | None:\n        return handle_login(redirect_type=\"server\")\n\n    def handle_login(\n        redirect_type: str = \"client\",\n    ) -> Response | Tuple[Response, Literal[401]] | None:\n\n        # Returns a shallow mutable copy of the immutable\n        # multi dict.\n        request_args = request.args.copy()\n        redirect_url = request_args.pop(\"redirect_url\", \"/\")\n        query_args = \"&\".join(\n            [arg + \"=\" + value for arg, value in request_args.items()]\n        )\n        if query_args:\n            redirect_url += \"?\" + query_args\n\n        if is_authenticated(request):\n            return redirect_response(redirect_url, redirect_type)\n\n        if request.method == \"POST\":\n            token_creation_limit = datetime.datetime.utcnow() - datetime.timedelta(\n                hours=app.config[\"TOKEN_DURATION_HOURS\"]\n            )\n            # Remove outdated tokens.\n            Token.query.filter(Token.created < token_creation_limit).delete()\n\n            username = request.form.get(\"username\")\n            password = request.form.get(\"password\")\n            token = request.form.get(\"token\")\n\n            # Check whether the given user exists.\n            user = User.query.filter(User.username == username).first()\n\n            invalid_login_msg = \"Username password combination does not exist.\"\n            if user is None:\n                return jsonify({\"error\": invalid_login_msg}), 401\n            else:\n                if password is not None:\n                    can_login = check_password_hash(user.password_hash, password)\n                elif token is not None and user.token_hash is not None:\n                    can_login = check_password_hash(user.token_hash, token)\n                else:\n                    can_login = False\n\n                if can_login:\n\n                    token = Token(user=user.uuid, token=str(secrets.token_hex(16)))\n\n                    db.session.add(token)\n                    db.session.commit()\n\n                    resp = redirect_response(redirect_url, redirect_type)\n                    # samesite=\"Lax\" to avoid CSRF attacks.\n                    resp.set_cookie(\"auth_token\", token.token, samesite=\"Lax\")\n                    resp.set_cookie(\"auth_username\", username, samesite=\"Lax\")\n\n                    return resp\n\n                else:\n                    return jsonify({\"error\": invalid_login_msg}), 401\n\n    @app.route(\"/login/users\", methods=[\"DELETE\"])\n    def delete_user() -> Union[\n        Tuple[Literal[\"\"], Literal[401]],\n        Tuple[Response, Literal[500]],\n        Tuple[Response, Literal[405]],\n        Literal[\"\"],\n    ]:\n        if not is_authenticated(request):\n            return \"\", 401\n\n        self_username = request.cookies.get(\"auth_username\")\n        if \"username\" in request.form:\n            to_delete_username = request.form.get(\"username\")\n\n            user = User.query.filter(User.username == to_delete_username).first()\n            if user is not None:\n                if user.is_admin:\n                    return jsonify({\"error\": \"Admins cannot be deleted.\"}), 500\n                elif self_username == to_delete_username:\n                    return jsonify({\"error\": \"Deleting own user is not allowed.\"}), 405\n                else:\n                    db.session.delete(user)\n                    db.session.commit()\n                    return \"\"\n            else:\n                return jsonify({\"error\": \"User does not exist.\"}), 500\n        else:\n            return jsonify({\"error\": \"No username supplied.\"}), 500\n\n    @app.route(\"/login/users\", methods=[\"POST\"])\n    def add_user() -> Union[\n        Tuple[Literal[\"\"], Literal[401]],\n        Tuple[Response, Literal[409]],\n        Tuple[Response, Literal[400]],\n        Literal[\"\"],\n    ]:\n        if not is_authenticated(request):\n            return \"\", 401\n\n        if \"username\" in request.form:\n\n            username = request.form.get(\"username\")\n            password = request.form.get(\"password\")\n\n            if username == app.config.get(\"ORCHEST_CLOUD_RESERVED_USER\"):\n                return jsonify({\"error\": \"User is reserved.\"}), 409\n\n            if len(password) == 0:\n                return jsonify({\"error\": \"Password cannot be empty.\"}), 400\n\n            user = User.query.filter(User.username == username).first()\n            if user is not None:\n                return jsonify({\"error\": \"User already exists.\"}), 409\n\n            user = User(\n                username=username,\n                password_hash=generate_password_hash(password),\n                uuid=str(uuid.uuid4()),\n            )\n\n            db.session.add(user)\n            db.session.commit()\n            return \"\"\n        else:\n            return jsonify({\"error\": \"No username supplied.\"}), 400\n\n    @app.route(\"/login/users\", methods=[\"GET\"])\n    def get_users() -> Tuple[Literal[\"\"], Literal[401]] | Tuple[Response, Literal[200]]:\n        if not is_authenticated(request):\n            return \"\", 401\n\n        data_json: Dict[\n            Literal[\"users\"],\n            List[Dict[Literal[\"username\"], str]],\n        ] = {\"users\": []}\n        users = User.query.all()\n        for user in users:\n            if user.username != app.config.get(\"ORCHEST_CLOUD_RESERVED_USER\"):\n                data_json[\"users\"].append({\"username\": user.username})\n\n        return jsonify(data_json), 200\n\n    @app.route(\"/auth/service\", methods=[\"GET\"])\n    def auth_service() -> Union[\n        Tuple[Literal[\"\"], Literal[200]],\n        Tuple[Literal[\"\"], Literal[401]],\n    ]:\n        global _auth_cache, _auth_cache_age\n\n        # Bypass definition based authentication if the request\n        # is authenticated\n        if is_authenticated(request):\n            return \"\", 200\n\n        # request URI\n        original_uri = request.headers.get(\"X-Original-URI\")\n\n        if original_uri is None:\n            return \"\", 401\n\n        try:\n            # expected uri:\n            # /pbp-service-[service-name]-\n            # [pipeline_uuid_prefix]-[session_uuid_prefix]_[port]/...\n            components = original_uri.split(\"/\")[1].split(\"_\")[-2].split(\"-\")\n            session_uuid_prefix = components[-1]\n            project_uuid_prefix = components[-2]\n        except Exception:\n            app.logger.error(\"Failed to parse X-Original-URI: %s\" % original_uri)\n            return \"\", 401\n\n        auth_check = get_auth_cache(\n            project_uuid_prefix, session_uuid_prefix, _auth_cache, _auth_cache_age\n        )\n        if auth_check[\"status\"] == \"available\":\n            if auth_check[\"requires_authentication\"] is False:\n                return \"\", 200\n            else:\n                return \"\", 401\n        else:\n            # No cache available, fetch from orchest-api\n            base_url = \"http://%s/api/services/\" % (app.config[\"ORCHEST_API_ADDRESS\"])\n            service_url = \"%s?project_uuid_prefix=%s&session_uuid_prefix=%s\" % (\n                base_url,\n                project_uuid_prefix,\n                session_uuid_prefix,\n            )\n\n            try:\n                r = requests.get(service_url)\n                services = r.json().get(\"services\", [])\n\n                # No service is found for given filter\n                if len(services) == 0:\n                    raise Exception(\"No services found\")\n\n                if len(services) > 1:\n                    raise Exception(\n                        \"Filtered /api/services endpoint \"\n                        \"should always return a single service\"\n                    )\n\n                # Always check first service that is returned,\n                # should be unique\n                if services[0][\"service\"][\"requires_authentication\"] is False:\n                    set_auth_cache(\n                        project_uuid_prefix, session_uuid_prefix, False, _auth_cache\n                    )\n                    return \"\", 200\n                else:\n                    set_auth_cache(\n                        project_uuid_prefix, session_uuid_prefix, True, _auth_cache\n                    )\n                    raise Exception(\"'requires_authentication' is not set to False\")\n\n            except Exception as e:\n                app.logger.error(e)\n                return \"\", 401\n"], "filenames": ["services/auth-server/app/app/views.py"], "buggy_code_start_loc": [117], "buggy_code_end_loc": [187], "fixing_code_start_loc": [117], "fixing_code_end_loc": [188], "type": "CWE-352", "message": "### Impact In a CSRF attack, an innocent end user is tricked by an attacker into submitting a web request that they did not intend. This may cause actions to be performed on the website that can include inadvertent client or server data leakage, change of session state, or manipulation of an end user's account. ### Patch Upgrade to v2022.09.10 to patch this vulnerability. ### Workarounds Rebuild and redeploy the Orchest `auth-server` with this commit: https://github.com/orchest/orchest/commit/c2587a963cca742c4a2503bce4cfb4161bf64c2d ### References https://en.wikipedia.org/wiki/Cross-site_request_forgery https://cwe.mitre.org/data/definitions/352.html ### For more information If you have any questions or comments about this advisory: * Open an issue in https://github.com/orchest/orchest * Email us at rick@orchest.io", "other": {"cve": {"id": "CVE-2022-39268", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-30T21:15:09.543", "lastModified": "2022-10-04T19:51:51.073", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "### Impact In a CSRF attack, an innocent end user is tricked by an attacker into submitting a web request that they did not intend. This may cause actions to be performed on the website that can include inadvertent client or server data leakage, change of session state, or manipulation of an end user's account. ### Patch Upgrade to v2022.09.10 to patch this vulnerability. ### Workarounds Rebuild and redeploy the Orchest `auth-server` with this commit: https://github.com/orchest/orchest/commit/c2587a963cca742c4a2503bce4cfb4161bf64c2d ### References https://en.wikipedia.org/wiki/Cross-site_request_forgery https://cwe.mitre.org/data/definitions/352.html ### For more information If you have any questions or comments about this advisory: * Open an issue in https://github.com/orchest/orchest * Email us at rick@orchest.io"}, {"lang": "es", "value": "### Impacto En un ataque de tipo CSRF, un usuario final inocente es enga\u00f1ado por un atacante para que env\u00ede una petici\u00f3n web que no pretend\u00eda. Esto puede causar que sean llevado a cabo acciones en el sitio web que pueden incluir la filtraci\u00f3n inadvertida de datos del cliente o del servidor, el cambio del estado de la sesi\u00f3n o la manipulaci\u00f3n de la cuenta de un usuario final. ### Parche Actualice a versi\u00f3n 2022.09.10 para parchear esta vulnerabilidad. ### Mitigaciones Reconstruya y redistribuya el Orchest \"auth-server\" con este commit: https://github.com/orchest/orchest/commit/c2587a963cca742c4a2503bce4cfb4161bf64c2d ### Referencias https://en.wikipedia.org/wiki/Cross-site_request_forgery https://cwe.mitre.org/data/definitions/352.html ### Para m\u00e1s informaci\u00f3n Si presenta alguna pregunta o comentario sobre este aviso: * Abra una incidencia en https://github.com/orchest/orchest * Env\u00edenos un correo electr\u00f3nico a rick@orchest.io"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:orchest:orchest:*:*:*:*:*:*:*:*", "versionStartIncluding": "2022.03.7", "versionEndIncluding": "2022.09.9", "matchCriteriaId": "70A89378-9D8F-4B36-BAF3-FE79AEDA8B5E"}]}]}], "references": [{"url": "https://github.com/orchest/orchest/commit/c2587a963cca742c4a2503bce4cfb4161bf64c2d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/orchest/orchest/pull/1324", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/orchest/orchest/releases/tag/v2022.09.10", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/orchest/orchest/security/advisories/GHSA-q44f-8jpw-qv4j", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/orchest/orchest/commit/c2587a963cca742c4a2503bce4cfb4161bf64c2d"}}