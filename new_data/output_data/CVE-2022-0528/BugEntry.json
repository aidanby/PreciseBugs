{"buggy_code": ["# Clone this file to `.env` and edit the clone.\n\nNODE_ENV=development\n\n# Companion\n# =======================\nCOMPANION_DATADIR=./output\nCOMPANION_DOMAIN=localhost:3020\nCOMPANION_PROTOCOL=http\nCOMPANION_PORT=3020\nCOMPANION_CLIENT_ORIGINS=\nCOMPANION_SECRET=development\n\nCOMPANION_DROPBOX_KEY=***\nCOMPANION_DROPBOX_SECRET=***\n\nCOMPANION_BOX_KEY=***\nCOMPANION_BOX_SECRET=***\n\nCOMPANION_GOOGLE_KEY=***\nCOMPANION_GOOGLE_SECRET=***\n\nCOMPANION_INSTAGRAM_KEY=***\nCOMPANION_INSTAGRAM_SECRET=***\n\nCOMPANION_FACEBOOK_KEY=***\nCOMPANION_FACEBOOK_SECRET=***\n\nCOMPANION_ZOOM_KEY=***\nCOMPANION_ZOOM_SECRET=***\n\nCOMPANION_UNSPLASH_KEY=***\nCOMPANION_UNSPLASH_SECRET=***\n\n# Development environment\n# =======================\n\nVITE_UPLOADER=tus\n# VITE_UPLOADER=s3\n# VITE_UPLOADER=s3-multipart\n# xhr will use protocol 'multipart' in companion, if used with a remote service, e.g. google drive.\n# If local upload will use browser XHR\n# VITE_UPLOADER=xhr\n# VITE_UPLOADER=transloadit\n# VITE_UPLOADER=transloadit-s3\n# VITE_UPLOADER=transloadit-xhr\n\nVITE_COMPANION_URL=http://localhost:3020\nVITE_TUS_ENDPOINT=https://tusd.tusdemo.net/files/\nVITE_XHR_ENDPOINT=https://xhr-server.herokuapp.com/upload\n\nVITE_TRANSLOADIT_KEY=***\nVITE_TRANSLOADIT_TEMPLATE=***\nVITE_TRANSLOADIT_SERVICE_URL=https://api2.transloadit.com\n", "#!/usr/bin/env bash\n\n# Load local env vars. In CI, these are injected.\nif [ -f .env ]; then\n  nodemon --watch packages/@uppy/companion/src --exec node -r dotenv/config ./packages/@uppy/companion/src/standalone/start-server.js\nelse\n  env \\\n    COMPANION_DATADIR=\"./output\" \\\n    COMPANION_DOMAIN=\"localhost:3020\" \\\n    COMPANION_PROTOCOL=\"http\" \\\n    COMPANION_PORT=3020 \\\n    COMPANION_CLIENT_ORIGINS=\"\" \\\n    COMPANION_SECRET=\"development\" \\\n    nodemon --watch packages/@uppy/companion/src --exec node ./packages/@uppy/companion/src/standalone/start-server.js\nfi\n\n", "const fs = require('fs')\nconst express = require('express')\nconst ms = require('ms')\n// @ts-ignore\nconst Grant = require('grant').express()\nconst merge = require('lodash.merge')\nconst cookieParser = require('cookie-parser')\nconst interceptor = require('express-interceptor')\nconst { isURL } = require('validator')\nconst uuid = require('uuid')\n\nconst grantConfig = require('./config/grant')()\nconst providerManager = require('./server/provider')\nconst controllers = require('./server/controllers')\nconst s3 = require('./server/controllers/s3')\nconst getS3Client = require('./server/s3-client')\nconst url = require('./server/controllers/url')\nconst emitter = require('./server/emitter')\nconst redis = require('./server/redis')\nconst { getURLBuilder } = require('./server/helpers/utils')\nconst jobs = require('./server/jobs')\nconst logger = require('./server/logger')\nconst middlewares = require('./server/middlewares')\nconst { ProviderApiError, ProviderAuthError } = require('./server/provider/error')\nconst { getCredentialsOverrideMiddleware } = require('./server/provider/credentials')\n// @ts-ignore\nconst { version } = require('../package.json')\n\nconst defaultOptions = {\n  server: {\n    protocol: 'http',\n    path: '',\n  },\n  providerOptions: {\n    s3: {\n      acl: 'public-read',\n      endpoint: 'https://{service}.{region}.amazonaws.com',\n      conditions: [],\n      useAccelerateEndpoint: false,\n      getKey: (req, filename) => filename,\n      expires: ms('5 minutes') / 1000,\n    },\n  },\n  debug: true,\n  logClientVersion: true,\n  periodicPingUrls: [],\n  streamingUpload: false,\n}\n\n// make the errors available publicly for custom providers\nmodule.exports.errors = { ProviderApiError, ProviderAuthError }\nmodule.exports.socket = require('./server/socket')\n\n/**\n * Entry point into initializing the Companion app.\n *\n * @param {object} options\n * @returns {import('express').Express}\n */\nmodule.exports.app = (options = {}) => {\n  validateConfig(options)\n\n  options = merge({}, defaultOptions, options)\n  const providers = providerManager.getDefaultProviders()\n  const searchProviders = providerManager.getSearchProviders()\n  providerManager.addProviderOptions(options, grantConfig)\n\n  const { customProviders } = options\n  if (customProviders) {\n    providerManager.addCustomProviders(customProviders, providers, grantConfig)\n  }\n\n  // mask provider secrets from log messages\n  maskLogger(options)\n\n  // create singleton redis client\n  if (options.redisUrl) {\n    redis.client(merge({ url: options.redisUrl }, options.redisOptions || {}))\n  }\n  emitter(options.multipleInstances && options.redisUrl, options.redisPubSubScope)\n\n  const app = express()\n\n  if (options.metrics) {\n    app.use(middlewares.metrics({ path: options.server.path }))\n\n    // backward compatibility\n    // TODO remove in next major semver\n    if (options.server.path) {\n      const buildUrl = getURLBuilder(options)\n      app.get('/metrics', (req, res) => {\n        process.emitWarning('/metrics is deprecated when specifying a path to companion')\n        const metricsUrl = buildUrl('/metrics', true)\n        res.redirect(metricsUrl)\n      })\n    }\n  }\n\n  app.use(cookieParser()) // server tokens are added to cookies\n\n  app.use(interceptGrantErrorResponse)\n  // override provider credentials at request time\n  app.use('/connect/:authProvider/:override?', getCredentialsOverrideMiddleware(providers, options))\n  app.use(Grant(grantConfig))\n\n  app.use((req, res, next) => {\n    if (options.sendSelfEndpoint) {\n      const { protocol } = options.server\n      res.header('i-am', `${protocol}://${options.sendSelfEndpoint}`)\n    }\n    next()\n  })\n\n  app.use(middlewares.cors(options))\n\n  // add uppy options to the request object so it can be accessed by subsequent handlers.\n  app.use('*', getOptionsMiddleware(options))\n  app.use('/s3', s3(options.providerOptions.s3))\n  app.use('/url', url())\n\n  app.post('/:providerName/preauth', middlewares.hasSessionAndProvider, controllers.preauth)\n  app.get('/:providerName/connect', middlewares.hasSessionAndProvider, controllers.connect)\n  app.get('/:providerName/redirect', middlewares.hasSessionAndProvider, controllers.redirect)\n  app.get('/:providerName/callback', middlewares.hasSessionAndProvider, controllers.callback)\n  app.post('/:providerName/deauthorization/callback', middlewares.hasSessionAndProvider, controllers.deauthorizationCallback)\n  app.get('/:providerName/logout', middlewares.hasSessionAndProvider, middlewares.gentleVerifyToken, controllers.logout)\n  app.get('/:providerName/send-token', middlewares.hasSessionAndProvider, middlewares.verifyToken, controllers.sendToken)\n  app.get('/:providerName/list/:id?', middlewares.hasSessionAndProvider, middlewares.verifyToken, controllers.list)\n  app.post('/:providerName/get/:id', middlewares.hasSessionAndProvider, middlewares.verifyToken, controllers.get)\n  app.get('/:providerName/thumbnail/:id', middlewares.hasSessionAndProvider, middlewares.cookieAuthToken, middlewares.verifyToken, controllers.thumbnail)\n  // @ts-ignore Type instantiation is excessively deep and possibly infinite.\n  app.get('/search/:searchProviderName/list', middlewares.hasSearchQuery, middlewares.loadSearchProviderToken, controllers.list)\n  app.post('/search/:searchProviderName/get/:id', middlewares.loadSearchProviderToken, controllers.get)\n\n  app.param('providerName', providerManager.getProviderMiddleware(providers, true))\n  app.param('searchProviderName', providerManager.getProviderMiddleware(searchProviders))\n\n  if (app.get('env') !== 'test') {\n    jobs.startCleanUpJob(options.filePath)\n  }\n\n  const processId = uuid.v4()\n\n  jobs.startPeriodicPingJob({\n    urls: options.periodicPingUrls,\n    interval: options.periodicPingInterval,\n    count: options.periodicPingCount,\n    staticPayload: options.periodicPingStaticPayload,\n    version,\n    processId,\n  })\n\n  return app\n}\n\n// intercepts grantJS' default response error when something goes\n// wrong during oauth process.\nconst interceptGrantErrorResponse = interceptor((req, res) => {\n  return {\n    isInterceptable: () => {\n      // match grant.js' callback url\n      return /^\\/connect\\/\\w+\\/callback/.test(req.path)\n    },\n    intercept: (body, send) => {\n      const unwantedBody = 'error=Grant%3A%20missing%20session%20or%20misconfigured%20provider'\n      if (body === unwantedBody) {\n        logger.error(`grant.js responded with error: ${body}`, 'grant.oauth.error', req.id)\n        res.set('Content-Type', 'text/plain')\n        const reqHint = req.id ? `Request ID: ${req.id}` : ''\n        send([\n          'Companion was unable to complete the OAuth process :(',\n          'Error: User session is missing or the Provider was misconfigured',\n          reqHint,\n        ].join('\\n'))\n      } else {\n        send(body)\n      }\n    },\n  }\n})\n\n/**\n *\n * @param {object} options\n */\nconst getOptionsMiddleware = (options) => {\n  /**\n   * @param {object} req\n   * @param {object} res\n   * @param {Function} next\n   */\n  const middleware = (req, res, next) => {\n    const versionFromQuery = req.query.uppyVersions ? decodeURIComponent(req.query.uppyVersions) : null\n    req.companion = {\n      options,\n      s3Client: getS3Client(options),\n      authToken: req.header('uppy-auth-token') || req.query.uppyAuthToken,\n      clientVersion: req.header('uppy-versions') || versionFromQuery || '1.0.0',\n      buildURL: getURLBuilder(options),\n    }\n\n    if (options.logClientVersion) {\n      logger.info(`uppy client version ${req.companion.clientVersion}`, 'companion.client.version')\n    }\n    next()\n  }\n\n  return middleware\n}\n\n/**\n * Informs the logger about all provider secrets that should be masked\n * if they are found in a log message\n *\n * @param {object} companionOptions\n */\nconst maskLogger = (companionOptions) => {\n  const secrets = []\n  const { providerOptions, customProviders } = companionOptions\n  Object.keys(providerOptions).forEach((provider) => {\n    if (providerOptions[provider].secret) {\n      secrets.push(providerOptions[provider].secret)\n    }\n  })\n\n  if (customProviders) {\n    Object.keys(customProviders).forEach((provider) => {\n      if (customProviders[provider].config && customProviders[provider].config.secret) {\n        secrets.push(customProviders[provider].config.secret)\n      }\n    })\n  }\n\n  logger.setMaskables(secrets)\n}\n\n/**\n * validates that the mandatory companion options are set.\n * If it is invalid, it will console an error of unset options and exits the process.\n * If it is valid, nothing happens.\n *\n * @param {object} companionOptions\n */\nconst validateConfig = (companionOptions) => {\n  const mandatoryOptions = ['secret', 'filePath', 'server.host']\n  /** @type {string[]} */\n  const unspecified = []\n\n  mandatoryOptions.forEach((i) => {\n    const value = i.split('.').reduce((prev, curr) => (prev ? prev[curr] : undefined), companionOptions)\n\n    if (!value) unspecified.push(`\"${i}\"`)\n  })\n\n  // vaidate that all required config is specified\n  if (unspecified.length) {\n    const messagePrefix = 'Please specify the following options to use companion:'\n    throw new Error(`${messagePrefix}\\n${unspecified.join(',\\n')}`)\n  }\n\n  // validate that specified filePath is writeable/readable.\n  try {\n    // @ts-ignore\n    fs.accessSync(`${companionOptions.filePath}`, fs.R_OK | fs.W_OK) // eslint-disable-line no-bitwise\n  } catch (err) {\n    throw new Error(\n      `No access to \"${companionOptions.filePath}\". Please ensure the directory exists and with read/write permissions.`,\n    )\n  }\n\n  const { providerOptions, periodicPingUrls } = companionOptions\n\n  if (providerOptions) {\n    const deprecatedOptions = { microsoft: 'onedrive', google: 'drive' }\n    Object.keys(deprecatedOptions).forEach((deprected) => {\n      if (providerOptions[deprected]) {\n        throw new Error(`The Provider option \"${deprected}\" is no longer supported. Please use the option \"${deprecatedOptions[deprected]}\" instead.`)\n      }\n    })\n  }\n\n  if (companionOptions.uploadUrls == null || companionOptions.uploadUrls.length === 0) {\n    logger.warn('Running without uploadUrls specified is a security risk if running in production', 'startup.uploadUrls')\n  }\n\n  if (periodicPingUrls != null && (\n    !Array.isArray(periodicPingUrls)\n    || periodicPingUrls.some((url2) => !isURL(url2, { protocols: ['http', 'https'], require_protocol: true, require_tld: false }))\n  )) {\n    throw new TypeError('Invalid periodicPingUrls')\n  }\n}\n", "const router = require('express').Router\nconst request = require('request')\nconst { URL } = require('url')\nconst validator = require('validator')\n\nconst { startDownUpload } = require('../helpers/upload')\nconst { getURLMeta, getRedirectEvaluator, getProtectedHttpAgent } = require('../helpers/request')\nconst logger = require('../logger')\n\n/**\n * Validates that the download URL is secure\n *\n * @param {string} url the url to validate\n * @param {boolean} debug whether the server is running in debug mode\n */\nconst validateURL = (url, debug) => {\n  if (!url) {\n    return false\n  }\n\n  const validURLOpts = {\n    protocols: ['http', 'https'],\n    require_protocol: true,\n    require_tld: !debug,\n  }\n  if (!validator.isURL(url, validURLOpts)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @callback downloadCallback\n * @param {Error} err\n * @param {string | Buffer | Buffer[]} chunk\n */\n\n/**\n * Downloads the content in the specified url, and passes the data\n * to the callback chunk by chunk.\n *\n * @param {string} url\n * @param {boolean} blockLocalIPs\n * @param {string} traceId\n * @returns {Promise}\n */\nconst downloadURL = async (url, blockLocalIPs, traceId) => {\n  const opts = {\n    uri: url,\n    method: 'GET',\n    followRedirect: getRedirectEvaluator(url, blockLocalIPs),\n    agentClass: getProtectedHttpAgent((new URL(url)).protocol, blockLocalIPs),\n  }\n\n  return new Promise((resolve, reject) => {\n    const req = request(opts)\n      .on('response', (resp) => {\n        if (resp.statusCode >= 300) {\n          req.abort() // No need to keep request\n          reject(new Error(`URL server responded with status: ${resp.statusCode}`))\n          return\n        }\n\n        // Don't allow any more data to flow yet.\n        // https://github.com/request/request/issues/1990#issuecomment-184712275\n        resp.pause()\n        resolve(resp)\n      })\n      .on('error', (err) => {\n        logger.error(err, 'controller.url.download.error', traceId)\n        reject(err)\n      })\n  })\n}\n\n/**\n * Fteches the size and content type of a URL\n *\n * @param {object} req expressJS request object\n * @param {object} res expressJS response object\n */\nconst meta = async (req, res) => {\n  try {\n    logger.debug('URL file import handler running', null, req.id)\n    const { debug } = req.companion.options\n    if (!validateURL(req.body.url, debug)) {\n      logger.debug('Invalid request body detected. Exiting url meta handler.', null, req.id)\n      return res.status(400).json({ error: 'Invalid request body' })\n    }\n\n    const urlMeta = await getURLMeta(req.body.url, !debug)\n    return res.json(urlMeta)\n  } catch (err) {\n    logger.error(err, 'controller.url.meta.error', req.id)\n    // @todo send more meaningful error message and status code to client if possible\n    return res.status(err.status || 500).json({ message: 'failed to fetch URL metadata' })\n  }\n}\n\n/**\n * Handles the reques of import a file from a remote URL, and then\n * subsequently uploading it to the specified destination.\n *\n * @param {object} req expressJS request object\n * @param {object} res expressJS response object\n */\nconst get = async (req, res) => {\n  logger.debug('URL file import handler running', null, req.id)\n  const { debug } = req.companion.options\n  if (!validateURL(req.body.url, debug)) {\n    logger.debug('Invalid request body detected. Exiting url import handler.', null, req.id)\n    res.status(400).json({ error: 'Invalid request body' })\n    return\n  }\n\n  async function getSize () {\n    const { size } = await getURLMeta(req.body.url, !debug)\n    return size\n  }\n\n  async function download () {\n    return downloadURL(req.body.url, !debug, req.id)\n  }\n\n  function onUnhandledError (err) {\n    logger.error(err, 'controller.url.error', req.id)\n    // @todo send more meaningful error message and status code to client if possible\n    res.status(err.status || 500).json({ message: 'failed to fetch URL metadata' })\n  }\n\n  startDownUpload({ req, res, getSize, download, onUnhandledError })\n}\n\nmodule.exports = () => router()\n  .post('/meta', meta)\n  .post('/get', get)\n", "const chalk = require('chalk')\nconst escapeStringRegexp = require('escape-string-regexp')\nconst util = require('util')\n\nconst valuesToMask = []\n/**\n * Adds a list of strings that should be masked by the logger.\n * This function can only be called once through out the life of the server.\n *\n * @param {Array} maskables a list of strings to be masked\n */\nexports.setMaskables = (maskables) => {\n  maskables.forEach((i) => {\n    valuesToMask.push(escapeStringRegexp(i))\n  })\n\n  Object.freeze(valuesToMask)\n}\n\n/**\n * Mask the secret content of a message\n *\n * @param {string} msg the message whose content should be masked\n * @returns {string}\n */\nfunction maskMessage (msg) {\n  let out = msg\n  for (const toBeMasked of valuesToMask) {\n    const toBeReplaced = new RegExp(toBeMasked, 'gi')\n    out = out.replace(toBeReplaced, '******')\n  }\n  return out\n}\n\n/**\n * message log\n *\n * @param {string | Error} msg the message to log\n * @param {string} tag a unique tag to easily search for this message\n * @param {string} level error | info | debug\n * @param {string=} id a unique id to easily trace logs tied to a request\n * @param {Function=} color function to display the log in appropriate color\n * @param {boolean=} shouldLogStackTrace when set to true, errors will be logged with their stack trace\n */\nconst log = (msg, tag = '', level, id = '', color = (message) => message, shouldLogStackTrace) => {\n  const time = new Date().toISOString()\n  const whitespace = tag && id ? ' ' : ''\n\n  function logMsg (msg2) {\n    let msgString = typeof msg2 === 'string' ? msg2 : util.inspect(msg2)\n    msgString = maskMessage(msgString)\n    // eslint-disable-next-line no-console\n    console.log(color(`companion: ${time} [${level}] ${id}${whitespace}${tag}`), color(msgString))\n  }\n\n  if (msg instanceof Error) {\n    // Not sure why it only logs the stack without the message, but this is how the code was originally\n    if (shouldLogStackTrace && typeof msg.stack === 'string') {\n      logMsg(msg.stack)\n      return\n    }\n\n    // We don't want to log stack trace (this is how the code was originally)\n    logMsg(String(msg))\n    return\n  }\n\n  logMsg(msg)\n}\n\n/**\n * INFO level log\n *\n * @param {string} msg the message to log\n * @param {string=} tag a unique tag to easily search for this message\n * @param {string=} traceId a unique id to easily trace logs tied to a request\n */\nexports.info = (msg, tag, traceId) => {\n  log(msg, tag, 'info', traceId)\n}\n\n/**\n * WARN level log\n *\n * @param {string} msg the message to log\n * @param {string=} tag a unique tag to easily search for this message\n * @param {string=} traceId a unique id to easily trace logs tied to a request\n */\nexports.warn = (msg, tag, traceId) => {\n  // @ts-ignore\n  log(msg, tag, 'warn', traceId, chalk.bold.yellow)\n}\n\n/**\n * ERROR level log\n *\n * @param {string | Error} msg the message to log\n * @param {string=} tag a unique tag to easily search for this message\n * @param {string=} traceId a unique id to easily trace logs tied to a request\n * @param {boolean=} shouldLogStackTrace when set to true, errors will be logged with their stack trace\n */\nexports.error = (msg, tag, traceId, shouldLogStackTrace) => {\n  // @ts-ignore\n  log(msg, tag, 'error', traceId, chalk.bold.red, shouldLogStackTrace)\n}\n\n/**\n * DEBUG level log\n *\n * @param {string} msg the message to log\n * @param {string=} tag a unique tag to easily search for this message\n * @param {string=} traceId a unique id to easily trace logs tied to a request\n */\nexports.debug = (msg, tag, traceId) => {\n  // @todo: this function should depend on companion's debug option instead\n  if (process.env.NODE_ENV !== 'production') {\n    // @ts-ignore\n    log(msg, tag, 'debug', traceId, chalk.bold.blue)\n  }\n}\n", "const request = require('request')\nconst purest = require('purest')({ request })\nconst { promisify } = require('util')\n\nconst Provider = require('../Provider')\nconst { getURLMeta } = require('../../helpers/request')\nconst logger = require('../../logger')\nconst adapter = require('./adapter')\nconst { ProviderApiError, ProviderAuthError } = require('../error')\nconst { requestStream } = require('../../helpers/utils')\n\n/**\n * Adapter for API https://developers.facebook.com/docs/graph-api/using-graph-api/\n */\nclass Facebook extends Provider {\n  constructor (options) {\n    super(options)\n    this.authProvider = Facebook.authProvider\n    this.client = purest({\n      ...options,\n      provider: Facebook.authProvider,\n    })\n  }\n\n  static get authProvider () {\n    return 'facebook'\n  }\n\n  _list ({ directory, token, query = { cursor: null } }, done) {\n    const qs = {\n      fields: 'name,cover_photo,created_time,type',\n    }\n\n    if (query.cursor) {\n      qs.after = query.cursor\n    }\n\n    let path = 'me/albums'\n    if (directory) {\n      path = `${directory}/photos`\n      qs.fields = 'icon,images,name,width,height,created_time'\n    }\n\n    this.client\n      .get(`https://graph.facebook.com/${path}`)\n      .qs(qs)\n      .auth(token)\n      .request((err, resp, body) => {\n        if (err || resp.statusCode !== 200) {\n          err = this._error(err, resp)\n          logger.error(err, 'provider.facebook.list.error')\n          return done(err)\n        }\n        this._getUsername(token, (err, username) => {\n          if (err) {\n            done(err)\n          } else {\n            done(null, this.adaptData(body, username, directory, query))\n          }\n        })\n      })\n  }\n\n  _getUsername (token, done) {\n    this.client\n      .get('me')\n      .qs({ fields: 'email' })\n      .auth(token)\n      .request((err, resp, body) => {\n        if (err || resp.statusCode !== 200) {\n          err = this._error(err, resp)\n          logger.error(err, 'provider.facebook.user.error')\n          return done(err)\n        }\n        done(null, body.email)\n      })\n  }\n\n  _getMediaUrl (body) {\n    const sortedImages = adapter.sortImages(body.images)\n    return sortedImages[sortedImages.length - 1].source\n  }\n\n  async download ({ id, token }) {\n    try {\n      const body1 = await new Promise((resolve, reject) => (\n        this.client\n          .get(`https://graph.facebook.com/${id}`)\n          .qs({ fields: 'images' })\n          .auth(token)\n          .request((err, resp, body) => {\n            if (err || resp.statusCode !== 200) {\n              err = this._error(err, resp)\n              logger.error(err, 'provider.facebook.download.error')\n              reject(err)\n              return\n            }\n            resolve(body)\n          })\n      ))\n\n      const url = this._getMediaUrl(body1)\n      const req = request(url)\n      return await requestStream(req, async (res) => this._error(null, res))\n    } catch (err) {\n      logger.error(err, 'provider.facebook.download.url.error')\n      throw err\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async thumbnail () {\n    // not implementing this because a public thumbnail from facebook will be used instead\n    logger.error('call to thumbnail is not implemented', 'provider.facebook.thumbnail.error')\n    throw new Error('call to thumbnail is not implemented')\n  }\n\n  _size ({ id, token }, done) {\n    return this.client\n      .get(`https://graph.facebook.com/${id}`)\n      .qs({ fields: 'images' })\n      .auth(token)\n      .request((err, resp, body) => {\n        if (err || resp.statusCode !== 200) {\n          err = this._error(err, resp)\n          logger.error(err, 'provider.facebook.size.error')\n          return done(err)\n        }\n\n        getURLMeta(this._getMediaUrl(body))\n          .then(({ size }) => done(null, size))\n          .catch((err2) => {\n            logger.error(err2, 'provider.facebook.size.error')\n            done(err2)\n          })\n      })\n  }\n\n  _logout ({ token }, done) {\n    return this.client\n      .delete('me/permissions')\n      .auth(token)\n      .request((err, resp) => {\n        if (err || resp.statusCode !== 200) {\n          logger.error(err, 'provider.facebook.logout.error')\n          done(this._error(err, resp))\n          return\n        }\n        done(null, { revoked: true })\n      })\n  }\n\n  adaptData (res, username, directory, currentQuery) {\n    const data = { username, items: [] }\n    const items = adapter.getItemSubList(res)\n    items.forEach((item) => {\n      data.items.push({\n        isFolder: adapter.isFolder(item),\n        icon: adapter.getItemIcon(item),\n        name: adapter.getItemName(item),\n        mimeType: adapter.getMimeType(item),\n        size: null,\n        id: adapter.getItemId(item),\n        thumbnail: adapter.getItemThumbnailUrl(item),\n        requestPath: adapter.getItemRequestPath(item),\n        modifiedDate: adapter.getItemModifiedDate(item),\n      })\n    })\n\n    data.nextPagePath = adapter.getNextPagePath(res, currentQuery, directory)\n    return data\n  }\n\n  _error (err, resp) {\n    if (resp) {\n      if (resp.body && resp.body.error.code === 190) {\n        // Invalid OAuth 2.0 Access Token\n        return new ProviderAuthError()\n      }\n\n      const fallbackMessage = `request to ${this.authProvider} returned ${resp.statusCode}`\n      const msg = resp.body && resp.body.error ? resp.body.error.message : fallbackMessage\n      return new ProviderApiError(msg, resp.statusCode)\n    }\n\n    return err\n  }\n}\n\nFacebook.version = 2\n\nFacebook.prototype.list = promisify(Facebook.prototype._list)\nFacebook.prototype.size = promisify(Facebook.prototype._size)\nFacebook.prototype.logout = promisify(Facebook.prototype._logout)\n\nmodule.exports = Facebook\n", "const request = require('request')\nconst purest = require('purest')({ request })\nconst { promisify } = require('util')\n\nconst Provider = require('../../Provider')\nconst { getURLMeta } = require('../../../helpers/request')\nconst logger = require('../../../logger')\nconst adapter = require('./adapter')\nconst { ProviderApiError, ProviderAuthError } = require('../../error')\nconst { requestStream } = require('../../../helpers/utils')\n\n/**\n * Adapter for API https://developers.facebook.com/docs/instagram-api/overview\n */\nclass Instagram extends Provider {\n  constructor (options) {\n    super(options)\n    this.authProvider = Instagram.authProvider\n    this.client = purest({\n      ...options,\n      provider: Instagram.authProvider,\n    })\n  }\n\n  static getExtraConfig () {\n    return {\n      protocol: 'https',\n      scope: ['user_profile', 'user_media'],\n    }\n  }\n\n  static get authProvider () {\n    return 'instagram'\n  }\n\n  _list ({ directory, token, query = { cursor: null } }, done) {\n    const qs = {\n      fields: 'id,media_type,thumbnail_url,media_url,timestamp,children{media_type,media_url,thumbnail_url,timestamp}',\n    }\n\n    if (query.cursor) {\n      qs.after = query.cursor\n    }\n\n    this.client\n      .get('https://graph.instagram.com/me/media')\n      .qs(qs)\n      .auth(token)\n      .request((err, resp, body) => {\n        if (err || resp.statusCode !== 200) {\n          err = this._error(err, resp)\n          logger.error(err, 'provider.instagram.list.error')\n          return done(err)\n        }\n        this._getUsername(token, (err, username) => {\n          if (err) done(err)\n          else done(null, this.adaptData(body, username, directory, query))\n        })\n      })\n  }\n\n  _getUsername (token, done) {\n    this.client\n      .get('https://graph.instagram.com/me')\n      .qs({ fields: 'username' })\n      .auth(token)\n      .request((err, resp, body) => {\n        if (err || resp.statusCode !== 200) {\n          err = this._error(err, resp)\n          logger.error(err, 'provider.instagram.user.error')\n          return done(err)\n        }\n        done(null, body.username)\n      })\n  }\n\n  async download ({ id, token }) {\n    try {\n      const body1 = await new Promise((resolve, reject) => (\n        this.client\n          .get(`https://graph.instagram.com/${id}`)\n          .qs({ fields: 'media_url' })\n          .auth(token)\n          .request((err, resp, body) => {\n            if (err || resp.statusCode !== 200) {\n              err = this._error(err, resp)\n              logger.error(err, 'provider.instagram.download.error')\n              reject(err)\n              return\n            }\n            resolve(body)\n          })\n      ))\n\n      const req = request(body1.media_url)\n      return await requestStream(req, async (res) => this._error(null, res))\n    } catch (err) {\n      logger.error(err, 'provider.instagram.download.url.error')\n      throw err\n    }\n  }\n\n  async thumbnail () {\n    // not implementing this because a public thumbnail from instagram will be used instead\n    logger.error('call to thumbnail is not implemented', 'provider.instagram.thumbnail.error')\n    throw new Error('call to thumbnail is not implemented')\n  }\n\n  _size ({ id, token }, done) {\n    return this.client\n      .get(`https://graph.instagram.com/${id}`)\n      .qs({ fields: 'media_url' })\n      .auth(token)\n      .request((err, resp, body) => {\n        if (err || resp.statusCode !== 200) {\n          err = this._error(err, resp)\n          logger.error(err, 'provider.instagram.size.error')\n          return done(err)\n        }\n\n        getURLMeta(body.media_url)\n          .then(({ size }) => done(null, size))\n          .catch((err2) => {\n            logger.error(err2, 'provider.instagram.size.error')\n            done(err2)\n          })\n      })\n  }\n\n  async logout () {\n    // access revoke is not supported by Instagram's API\n    return { revoked: false, manual_revoke_url: 'https://www.instagram.com/accounts/manage_access/' }\n  }\n\n  adaptData (res, username, directory, currentQuery) {\n    const data = { username, items: [] }\n    const items = adapter.getItemSubList(res)\n    items.forEach((item, i) => {\n      data.items.push({\n        isFolder: adapter.isFolder(item),\n        icon: adapter.getItemIcon(item),\n        name: adapter.getItemName(item, i),\n        mimeType: adapter.getMimeType(item),\n        id: adapter.getItemId(item),\n        size: null,\n        thumbnail: adapter.getItemThumbnailUrl(item),\n        requestPath: adapter.getItemRequestPath(item),\n        modifiedDate: adapter.getItemModifiedDate(item),\n      })\n    })\n\n    data.nextPagePath = adapter.getNextPagePath(res, currentQuery, directory)\n    return data\n  }\n\n  _error (err, resp) {\n    if (resp) {\n      if (resp.body && resp.body.error.code === 190) {\n        // Invalid OAuth 2.0 Access Token\n        return new ProviderAuthError()\n      }\n\n      const fallbackMessage = `request to ${this.authProvider} returned ${resp.statusCode}`\n      const msg = resp.body && resp.body.error ? resp.body.error.message : fallbackMessage\n      return new ProviderApiError(msg, resp.statusCode)\n    }\n\n    return err\n  }\n}\n\nInstagram.version = 2\n\nInstagram.prototype.list = promisify(Instagram.prototype._list)\nInstagram.prototype.size = promisify(Instagram.prototype._size)\n\nmodule.exports = Instagram\n", "const request = require('request')\nconst { promisify } = require('util')\n\nconst SearchProvider = require('../SearchProvider')\nconst { getURLMeta } = require('../../helpers/request')\nconst logger = require('../../logger')\nconst adapter = require('./adapter')\nconst { ProviderApiError } = require('../error')\nconst { requestStream } = require('../../helpers/utils')\n\nconst BASE_URL = 'https://api.unsplash.com'\n\nfunction adaptData (body, currentQuery) {\n  const pagesCount = body.total_pages\n  const currentPage = Number(currentQuery.cursor || 1)\n  const hasNextPage = currentPage < pagesCount\n  const subList = adapter.getItemSubList(body) || []\n\n  return {\n    searchedFor: currentQuery.q,\n    username: null,\n    items: subList.map((item) => ({\n      isFolder: adapter.isFolder(item),\n      icon: adapter.getItemIcon(item),\n      name: adapter.getItemName(item),\n      mimeType: adapter.getMimeType(item),\n      id: adapter.getItemId(item),\n      thumbnail: adapter.getItemThumbnailUrl(item),\n      requestPath: adapter.getItemRequestPath(item),\n      modifiedDate: adapter.getItemModifiedDate(item),\n      author: adapter.getAuthor(item),\n      size: null,\n    })),\n    nextPageQuery: hasNextPage\n      ? adapter.getNextPageQuery(currentQuery)\n      : null,\n  }\n}\n\n/**\n * Adapter for API https://api.unsplash.com\n */\nclass Unsplash extends SearchProvider {\n  _list ({ token, query = { cursor: null, q: null } }, done) {\n    const reqOpts = {\n      url: `${BASE_URL}/search/photos`,\n      method: 'GET',\n      json: true,\n      qs: {\n        per_page: 40,\n        query: query.q,\n      },\n      headers: {\n        Authorization: `Client-ID ${token}`,\n      },\n    }\n\n    if (query.cursor) {\n      reqOpts.qs.page = query.cursor\n    }\n\n    request(reqOpts, (err, resp, body) => {\n      if (err || resp.statusCode !== 200) {\n        const error = this.error(err, resp)\n        logger.error(error, 'provider.unsplash.list.error')\n        return done(error)\n      }\n      return done(null, adaptData(body, query))\n    })\n  }\n\n  async download ({ id, token }) {\n    try {\n      const reqOpts = {\n        method: 'GET',\n        json: true,\n        headers: {\n          Authorization: `Client-ID ${token}`,\n        },\n      }\n\n      const body = await new Promise((resolve, reject) => (\n        request({ ...reqOpts, url: `${BASE_URL}/photos/${id}` }, (err, resp, body2) => {\n          if (err || resp.statusCode !== 200) {\n            const err2 = this.error(err, resp)\n            logger.error(err, 'provider.unsplash.download.error')\n            reject(err2)\n            return\n          }\n          resolve(body2)\n        })\n      ))\n\n      const req = request.get(body.links.download)\n      const stream = await requestStream(req, async (res) => this.error(null, res))\n\n      // To attribute the author of the image, we call the `download_location`\n      // endpoint to increment the download count on Unsplash.\n      // https://help.unsplash.com/en/articles/2511258-guideline-triggering-a-download\n      request({ ...reqOpts, url: body.links.download_location }, (err, resp) => {\n        if (err || resp.statusCode !== 200) {\n          const err2 = this.error(err, resp)\n          logger.error(err2, 'provider.unsplash.download.location.error')\n        }\n      })\n\n      return stream\n    } catch (err) {\n      logger.error(err, 'provider.unsplash.download.url.error')\n      throw err\n    }\n  }\n\n  _size ({ id, token }, done) {\n    const reqOpts = {\n      url: `${BASE_URL}/photos/${id}`,\n      method: 'GET',\n      json: true,\n      headers: {\n        Authorization: `Client-ID ${token}`,\n      },\n    }\n\n    request(reqOpts, (err, resp, body) => {\n      if (err || resp.statusCode !== 200) {\n        const error = this.error(err, resp)\n        logger.error(error, 'provider.unsplash.size.error')\n        done(error)\n        return\n      }\n\n      getURLMeta(body.links.download)\n        .then(({ size }) => done(null, size))\n        .catch((err2) => {\n          logger.error(err2, 'provider.unsplash.size.error')\n          done(err2)\n        })\n    })\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  error (err, resp) {\n    if (resp) {\n      const fallbackMessage = `request to Unsplash returned ${resp.statusCode}`\n      const msg = resp.body && resp.body.errors ? `${resp.body.errors}` : fallbackMessage\n      return new ProviderApiError(msg, resp.statusCode)\n    }\n\n    return err\n  }\n}\n\nUnsplash.version = 2\n\nUnsplash.prototype.list = promisify(Unsplash.prototype._list)\nUnsplash.prototype.size = promisify(Unsplash.prototype._size)\n\nmodule.exports = Unsplash\n", "const fs = require('fs')\nconst merge = require('lodash.merge')\nconst stripIndent = require('common-tags/lib/stripIndent')\nconst crypto = require('crypto')\nconst utils = require('../server/helpers/utils')\nconst logger = require('../server/logger')\n// @ts-ignore\nconst { version } = require('../../package.json')\n\n/**\n * Reads all companion configuration set via environment variables\n * and via the config file path\n *\n * @returns {object}\n */\nexports.getCompanionOptions = (options = {}) => {\n  return merge({}, getConfigFromEnv(), getConfigFromFile(), options)\n}\n\n/**\n * Loads the config from environment variables\n *\n * @returns {object}\n */\nconst getConfigFromEnv = () => {\n  const uploadUrls = process.env.COMPANION_UPLOAD_URLS\n  const domains = process.env.COMPANION_DOMAINS || process.env.COMPANION_DOMAIN || null\n  const validHosts = domains ? domains.split(',') : []\n\n  return {\n    providerOptions: {\n      drive: {\n        key: process.env.COMPANION_GOOGLE_KEY,\n        secret: getSecret('COMPANION_GOOGLE_SECRET'),\n        credentialsURL: process.env.COMPANION_GOOGLE_KEYS_ENDPOINT,\n      },\n      dropbox: {\n        key: process.env.COMPANION_DROPBOX_KEY,\n        secret: getSecret('COMPANION_DROPBOX_SECRET'),\n        credentialsURL: process.env.COMPANION_DROPBOX_KEYS_ENDPOINT,\n      },\n      box: {\n        key: process.env.COMPANION_BOX_KEY,\n        secret: getSecret('COMPANION_BOX_SECRET'),\n      },\n      instagram: {\n        key: process.env.COMPANION_INSTAGRAM_KEY,\n        secret: getSecret('COMPANION_INSTAGRAM_SECRET'),\n        credentialsURL: process.env.COMPANION_INSTAGRAM_KEYS_ENDPOINT,\n      },\n      facebook: {\n        key: process.env.COMPANION_FACEBOOK_KEY,\n        secret: getSecret('COMPANION_FACEBOOK_SECRET'),\n        credentialsURL: process.env.COMPANION_FACEBOOK_KEYS_ENDPOINT,\n      },\n      onedrive: {\n        key: process.env.COMPANION_ONEDRIVE_KEY,\n        secret: getSecret('COMPANION_ONEDRIVE_SECRET'),\n        credentialsURL: process.env.COMPANION_ONEDRIVE_KEYS_ENDPOINT,\n      },\n      zoom: {\n        key: process.env.COMPANION_ZOOM_KEY,\n        secret: getSecret('COMPANION_ZOOM_SECRET'),\n        verificationToken: getSecret('COMPANION_ZOOM_VERIFICATION_TOKEN'),\n        credentialsURL: process.env.COMPANION_ZOOM_KEYS_ENDPOINT,\n      },\n      searchProviders: {\n        unsplash: {\n          key: process.env.COMPANION_UNSPLASH_KEY,\n          secret: process.env.COMPANION_UNSPLASH_SECRET,\n        },\n      },\n      s3: {\n        key: process.env.COMPANION_AWS_KEY,\n        secret: getSecret('COMPANION_AWS_SECRET'),\n        bucket: process.env.COMPANION_AWS_BUCKET,\n        endpoint: process.env.COMPANION_AWS_ENDPOINT,\n        region: process.env.COMPANION_AWS_REGION,\n        useAccelerateEndpoint:\n          process.env.COMPANION_AWS_USE_ACCELERATE_ENDPOINT === 'true',\n        expires: parseInt(process.env.COMPANION_AWS_EXPIRES || '300', 10),\n        acl: process.env.COMPANION_AWS_ACL || 'public-read',\n      },\n    },\n    server: {\n      host: process.env.COMPANION_DOMAIN,\n      protocol: process.env.COMPANION_PROTOCOL,\n      path: process.env.COMPANION_PATH,\n      implicitPath: process.env.COMPANION_IMPLICIT_PATH,\n      oauthDomain: process.env.COMPANION_OAUTH_DOMAIN,\n      validHosts,\n    },\n    periodicPingUrls: process.env.COMPANION_PERIODIC_PING_URLS ? process.env.COMPANION_PERIODIC_PING_URLS.split(',') : [],\n    periodicPingInterval: process.env.COMPANION_PERIODIC_PING_INTERVAL\n      ? parseInt(process.env.COMPANION_PERIODIC_PING_INTERVAL, 10) : undefined,\n    periodicPingStaticPayload: process.env.COMPANION_PERIODIC_PING_STATIC_JSON_PAYLOAD\n      ? JSON.parse(process.env.COMPANION_PERIODIC_PING_STATIC_JSON_PAYLOAD) : undefined,\n    periodicPingCount: process.env.COMPANION_PERIODIC_PING_COUNT\n      ? parseInt(process.env.COMPANION_PERIODIC_PING_COUNT, 10) : undefined,\n    filePath: process.env.COMPANION_DATADIR,\n    redisUrl: process.env.COMPANION_REDIS_URL,\n    // adding redisOptions to keep all companion options easily visible\n    //  redisOptions refers to https://www.npmjs.com/package/redis#options-object-properties\n    redisOptions: {},\n    sendSelfEndpoint: process.env.COMPANION_SELF_ENDPOINT,\n    uploadUrls: uploadUrls ? uploadUrls.split(',') : null,\n    secret: getSecret('COMPANION_SECRET') || generateSecret(),\n    preAuthSecret: getSecret('COMPANION_PREAUTH_SECRET') || generateSecret(),\n    debug: process.env.NODE_ENV && process.env.NODE_ENV !== 'production',\n    // cookieDomain is kind of a hack to support distributed systems. This should be improved but we never got so far.\n    cookieDomain: process.env.COMPANION_COOKIE_DOMAIN,\n    multipleInstances: true,\n    streamingUpload: process.env.COMPANION_STREAMING_UPLOAD === 'true',\n    maxFileSize: process.env.COMPANION_MAX_FILE_SIZE ? parseInt(process.env.COMPANION_MAX_FILE_SIZE, 10) : undefined,\n    chunkSize: process.env.COMPANION_CHUNK_SIZE ? parseInt(process.env.COMPANION_CHUNK_SIZE, 10) : undefined,\n  }\n}\n\n/**\n * Tries to read the secret from a file if the according environment variable is set.\n * Otherwise it falls back to the standard secret environment variable.\n *\n * @param {string} baseEnvVar\n *\n * @returns {string}\n */\nconst getSecret = (baseEnvVar) => {\n  const secretFile = process.env[`${baseEnvVar}_FILE`]\n  return secretFile\n    ? fs.readFileSync(secretFile).toString()\n    : process.env[baseEnvVar]\n}\n\n/**\n * Auto-generates server secret\n *\n * @returns {string}\n */\nconst generateSecret = () => {\n  logger.warn('auto-generating server secret because none was specified', 'startup.secret')\n  return crypto.randomBytes(64).toString('hex')\n}\n\n/**\n * Loads the config from a file and returns it as an object\n *\n * @returns {object}\n */\nconst getConfigFromFile = () => {\n  const path = getConfigPath()\n  if (!path) return {}\n\n  const rawdata = fs.readFileSync(getConfigPath())\n  // @ts-ignore\n  return JSON.parse(rawdata)\n}\n\n/**\n * Returns the config path specified via cli arguments\n *\n * @returns {string}\n */\nconst getConfigPath = () => {\n  let configPath\n\n  for (let i = process.argv.length - 1; i >= 0; i--) {\n    const isConfigFlag = process.argv[i] === '-c' || process.argv[i] === '--config'\n    const flagHasValue = i + 1 <= process.argv.length\n    if (isConfigFlag && flagHasValue) {\n      configPath = process.argv[i + 1]\n      break\n    }\n  }\n\n  return configPath\n}\n\n/**\n *\n * @param {string} url\n */\nexports.hasProtocol = (url) => {\n  return url.startsWith('http://') || url.startsWith('https://')\n}\n\nexports.buildHelpfulStartupMessage = (companionOptions) => {\n  const buildURL = utils.getURLBuilder(companionOptions)\n  const callbackURLs = []\n  Object.keys(companionOptions.providerOptions).forEach((providerName) => {\n    // s3 does not need redirect_uris\n    if (providerName === 's3') {\n      return\n    }\n\n    callbackURLs.push(buildURL(`/connect/${providerName}/redirect`, true))\n  })\n\n  return stripIndent`\n    Welcome to Companion v${version}\n    ===================================\n\n    Congratulations on setting up Companion! Thanks for joining our cause, you have taken\n    the first step towards the future of file uploading! We\n    hope you are as excited about this as we are!\n\n    While you did an awesome job on getting Companion running, this is just the welcome\n    message, so let's talk about the places that really matter:\n\n    - Be sure to add ${callbackURLs.join(', ')} as your Oauth redirect uris on their corresponding developer interfaces.\n    - The URL ${buildURL('/metrics', true)} is available for  statistics to keep Companion running smoothly\n    - https://github.com/transloadit/uppy/issues - report your bugs here\n\n    So quit lollygagging, start uploading and experience the future!\n  `\n}\n", "/* global jest:false, test:false, expect:false, describe:false */\n\nconst mockOauthState = require('../mockoauthstate')()\nconst { version } = require('../../package.json')\n\njest.mock('tus-js-client')\njest.mock('purest')\njest.mock('../../src/server/helpers/oauth-state', () => ({\n  ...jest.requireActual('../../src/server/helpers/oauth-state'),\n  ...mockOauthState,\n}))\n\nconst nock = require('nock')\nconst request = require('supertest')\nconst tokenService = require('../../src/server/helpers/jwt')\nconst { getServer } = require('../mockserver')\n\nconst authServer = getServer()\nconst authData = {\n  dropbox: 'token value',\n  box: 'token value',\n  drive: 'token value',\n}\nconst token = tokenService.generateEncryptedToken(authData, process.env.COMPANION_SECRET)\nconst OAUTH_STATE = 'some-cool-nice-encrytpion'\n\ndescribe('validate upload data', () => {\n  test('invalid upload protocol gets rejected', () => {\n    return request(authServer)\n      .post('/drive/get/DUMMY-FILE-ID')\n      .set('uppy-auth-token', token)\n      .set('Content-Type', 'application/json')\n      .send({\n        endpoint: 'http://url.myendpoint.com/files',\n        protocol: 'tusInvalid',\n      })\n      .expect(400)\n      .then((res) => expect(res.body.message).toBe('unsupported protocol specified'))\n  })\n\n  test('invalid upload fieldname gets rejected', () => {\n    return request(authServer)\n      .post('/drive/get/DUMMY-FILE-ID')\n      .set('uppy-auth-token', token)\n      .set('Content-Type', 'application/json')\n      .send({\n        endpoint: 'http://url.myendpoint.com/files',\n        protocol: 'tus',\n        fieldname: 390,\n      })\n      .expect(400)\n      .then((res) => expect(res.body.message).toBe('fieldname must be a string'))\n  })\n\n  test('invalid upload metadata gets rejected', () => {\n    return request(authServer)\n      .post('/drive/get/DUMMY-FILE-ID')\n      .set('uppy-auth-token', token)\n      .set('Content-Type', 'application/json')\n      .send({\n        endpoint: 'http://url.myendpoint.com/files',\n        protocol: 'tus',\n        metadata: 'I am a string instead of object',\n      })\n      .expect(400)\n      .then((res) => expect(res.body.message).toBe('metadata must be an object'))\n  })\n\n  test('invalid upload headers get rejected', () => {\n    return request(authServer)\n      .post('/drive/get/DUMMY-FILE-ID')\n      .set('uppy-auth-token', token)\n      .set('Content-Type', 'application/json')\n      .send({\n        endpoint: 'http://url.myendpoint.com/files',\n        protocol: 'tus',\n        headers: 'I am a string instead of object',\n      })\n      .expect(400)\n      .then((res) => expect(res.body.message).toBe('headers must be an object'))\n  })\n\n  test('invalid upload HTTP Method gets rejected', () => {\n    return request(authServer)\n      .post('/drive/get/DUMMY-FILE-ID')\n      .set('uppy-auth-token', token)\n      .set('Content-Type', 'application/json')\n      .send({\n        endpoint: 'http://url.myendpoint.com/files',\n        protocol: 'tus',\n        httpMethod: 'DELETE',\n      })\n      .expect(400)\n      .then((res) => expect(res.body.message).toBe('unsupported HTTP METHOD specified'))\n  })\n\n  test('valid upload data is allowed - tus', () => {\n    return request(authServer)\n      .post('/drive/get/DUMMY-FILE-ID')\n      .set('uppy-auth-token', token)\n      .set('Content-Type', 'application/json')\n      .send({\n        endpoint: 'http://url.myendpoint.com/files',\n        protocol: 'tus',\n        httpMethod: 'POST',\n        headers: {\n          customheader: 'header value',\n        },\n        metadata: {\n          mymetadata: 'matadata value',\n        },\n        fieldname: 'uploadField',\n      })\n      .expect(200)\n  })\n\n  test('valid upload data is allowed - s3-multipart', () => {\n    return request(authServer)\n      .post('/drive/get/DUMMY-FILE-ID')\n      .set('uppy-auth-token', token)\n      .set('Content-Type', 'application/json')\n      .send({\n        endpoint: 'http://url.myendpoint.com/files',\n        protocol: 's3-multipart',\n        httpMethod: 'PUT',\n        headers: {\n          customheader: 'header value',\n        },\n        metadata: {\n          mymetadata: 'matadata value',\n        },\n        fieldname: 'uploadField',\n      })\n      .expect(200)\n  })\n})\n\ndescribe('handle main oauth redirect', () => {\n  const serverWithMainOauth = getServer({\n    COMPANION_OAUTH_DOMAIN: 'localhost:3040',\n  })\n  test('redirect to a valid uppy instance', () => {\n    return request(serverWithMainOauth)\n      .get(`/dropbox/redirect?state=${OAUTH_STATE}`)\n      .set('uppy-auth-token', token)\n      .expect(302)\n      .expect('Location', `http://localhost:3020/connect/dropbox/callback?state=${OAUTH_STATE}`)\n  })\n\n  test('do not redirect to invalid uppy instances', () => {\n    const state = 'state-with-invalid-instance-url' // see mock ../../src/server/helpers/oauth-state above\n    return request(serverWithMainOauth)\n      .get(`/dropbox/redirect?state=${state}`)\n      .set('uppy-auth-token', token)\n      .expect(400)\n  })\n})\n\nit('periodically pings', (done) => {\n  nock('http://localhost').post('/ping', (body) => (\n    body.some === 'value'\n    && body.version === version\n    && typeof body.processId === 'string'\n  )).reply(200, () => done())\n\n  getServer({\n    COMPANION_PERIODIC_PING_URLS: 'http://localhost/ping',\n    COMPANION_PERIODIC_PING_STATIC_JSON_PAYLOAD: '{\"some\": \"value\"}',\n    COMPANION_PERIODIC_PING_INTERVAL: '10',\n    COMPANION_PERIODIC_PING_COUNT: '1',\n  })\n}, 1000)\n\nafterAll(() => {\n  nock.cleanAll()\n  nock.restore()\n})\n", "/* global jest:false */\nconst express = require('express')\nconst session = require('express-session')\n\nconst defaultEnv = {\n  NODE_ENV: 'test',\n  COMPANION_PORT: 3020,\n  COMPANION_DOMAIN: 'localhost:3020',\n  COMPANION_SELF_ENDPOINT: 'localhost:3020',\n  COMPANION_HIDE_METRICS: 'false',\n  COMPANION_HIDE_WELCOME: 'false',\n\n  COMPANION_STREAMING_UPLOAD: 'true',\n\n  COMPANION_PROTOCOL: 'http',\n  COMPANION_DATADIR: './test/output',\n  COMPANION_SECRET: 'secret',\n\n  COMPANION_DROPBOX_KEY: 'dropbox_key',\n  COMPANION_DROPBOX_SECRET: 'dropbox_secret',\n\n  COMPANION_BOX_KEY: 'box_key',\n  COMPANION_BOX_SECRET: 'box_secret',\n\n  COMPANION_GOOGLE_KEY: 'google_key',\n  COMPANION_GOOGLE_SECRET: 'google_secret',\n\n  COMPANION_INSTAGRAM_KEY: 'instagram_key',\n  COMPANION_INSTAGRAM_SECRET: 'instagram_secret',\n\n  COMPANION_ZOOM_KEY: 'zoom_key',\n  COMPANION_ZOOM_SECRET: 'zoom_secret',\n  COMPANION_ZOOM_VERIFICATION_TOKEN: 'zoom_verfication_token',\n\n  COMPANION_PATH: '',\n}\n\nfunction updateEnv (env) {\n  Object.keys(env).forEach((key) => {\n    process.env[key] = env[key]\n  })\n}\n\nmodule.exports.setDefaultEnv = () => updateEnv(defaultEnv)\n\nmodule.exports.getServer = (extraEnv) => {\n  const env = {\n    ...defaultEnv,\n    ...extraEnv,\n  }\n\n  updateEnv(env)\n\n  // delete from cache to force the server to reload companionOptions from the new env vars\n  jest.resetModules()\n  const standalone = require('../src/standalone')\n  const authServer = express()\n\n  authServer.use(session({ secret: 'grant', resave: true, saveUninitialized: true }))\n  authServer.all('*/callback', (req, res, next) => {\n    req.session.grant = {\n      response: { access_token: 'fake token' },\n    }\n    next()\n  })\n  authServer.all(['*/send-token', '*/redirect'], (req, res, next) => {\n    req.session.grant = { dynamic: { state: req.query.state || 'non-empty-value' } }\n    next()\n  })\n\n  const { app } = standalone()\n  authServer.use(app)\n  return authServer\n}\n", "---\ntype: docs\norder: 2\ntitle: \"Companion\"\nmodule: \"@uppy/companion\"\npermalink: docs/companion/\nalias: docs/server/\ncategory: \"Docs\"\ntagline: \"Server-side proxy that enables remote sources like Instagram, Google Drive, and Dropbox\"\n---\n\nDrag and drop, webcam, basic file manipulation (adding metadata, for example) and uploading via tus-resumable uploads or XHR/Multipart are all possible using only the Uppy client module.\n\n<!--retext-simplify ignore however-->\n\nHowever, if you add [Companion](https://github.com/transloadit/uppy/tree/main/packages/@uppy/companion) to the mix, your users will be able to select files from remote sources, such as Instagram, Google Drive and Dropbox, bypassing the client (so a 5 GB video isn\u2019t eating into your users\u2019 data plans), and then uploaded to the final destination. Files are removed from Companion after an upload is complete, or after a reasonable timeout. Access tokens also don\u2019t stick around for long, for security reasons.\n\nCompanion handles the server-to-server communication between your server and file storage providers such as Google Drive, Dropbox, Instagram, etc. Note that you can **not** upload files **to** Companion, it only handles the third party integrations.\n\n## Supported providers\n\nAs of now, Companion is integrated to work with:\n\n* Google Drive (name `drive`) - [Set up instructions](/docs/google-drive/#Setting-Up)\n* Dropbox (name `dropbox`) - [Set up instructions](/docs/dropbox/#Setting-Up)\n* Box (name `box`) - [Set up instructions](/docs/box/#Setting-Up)\n* Instagram (name `instagram`)\n* Facebook (name `facebook`)\n* OneDrive (name `onedrive`)\n* Remote URLs (name `url`)\n* Amazon S3 (name `s3`)\n\n## Installation\n\nInstall from NPM:\n\n```bash\nnpm install @uppy/companion\n```\n\nIf you don\u2019t have a Node.js project with a `package.json` you might want to install/run Companion globally like so: `npm install -g @uppy/companion`.\n\n### Prerequisite\n\nSince v2, you now need to be running `node.js >= v10.20.1` to use Companion. Please see [Migrating v1 to v2](#Migrating-v1-to-v2)\n\nUnfortunately, Windows is not a supported platform right now. It may work, and we\u2019re happy to accept improvements in this area, but we can\u2019t provide support.\n\n## Usage\n\n<!--retext-simplify ignore already-existing-->\n\nCompanion may either be used as a pluggable express app, which you plug into your already existing server, or it may also be run as a standalone server:\n\n### Plugging into an existing express server\n\nTo plug Companion into an existing server, call its `.app` method, passing in an [options](#Options) object as a parameter. This returns a server instance that you can mount on a subpath in your Express or app.\n\n```js\nimport express from 'express'\nimport bodyParser from 'body-parser'\nimport session from 'express-session'\nimport companion from '@uppy/companion'\n\nconst app = express()\n\n// Companion requires body-parser and express-session middleware.\n// You can add it like this if you use those throughout your app.\n//\n// If you are using something else in your app, you can add these\n// middlewares in the same subpath as Companion instead.\napp.use(bodyParser.json())\napp.use(session({ secret: 'some secrety secret' }))\n\nconst options = {\n  providerOptions: {\n    drive: {\n      key: 'GOOGLE_DRIVE_KEY',\n      secret: 'GOOGLE_DRIVE_SECRET',\n    },\n  },\n  server: {\n    host: 'localhost:3020',\n    protocol: 'http',\n    // This MUST match the path you specify in `app.use()` below:\n    path: '/companion',\n  },\n  filePath: '/path/to/folder/',\n}\n\napp.use('/companion', companion.app(options))\n```\n\nSee [Options](#Options) for valid configuration options.\n\nThen, add the Companion WebSocket server for realtime upload progress, using the `companion.socket` function:\n\n```js\nconst server = app.listen(PORT)\n\ncompanion.socket(server)\n```\n\nThis takes your `server` instance as an argument.\n\n### Running as a standalone server\n\n> Please make sure that the required environment variables are set before running/using Companion as a standalone server. See [Configure Standalone](#Configuring-a-standalone-server) for the variables required.\n\nSet environment variables first:\n\n```bash\nexport COMPANION_SECRET=\"shh!Issa Secret!\"\nexport COMPANION_DOMAIN=\"YOUR SERVER DOMAIN\"\nexport COMPANION_DATADIR=\"PATH/TO/DOWNLOAD/DIRECTORY\"\n```\n\nAnd then run:\n\n```bash\ncompanion\n```\n\nYou can also pass in the path to your JSON config file, like so:\n\n```bash\ncompanion --config /path/to/uppyconf.json\n```\n\nPlease see [Options](#Options) for possible options.\n\n#### Configuring a standalone server\n\nTo run Companion as a standalone server, you are required to set your Uppy [Options](#Options) via environment variables:\n\n```bash\n####### Mandatory variables ###########\n\n# any long set of random characters for the server session\nexport COMPANION_SECRET=\"shh!Issa Secret!\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_SECRET_FILE=\"PATH/TO/COMPANION/SECRET/FILE\"\n# corresponds to the server.host option\nexport COMPANION_DOMAIN=\"YOUR SERVER DOMAIN\"\n# corresponds to the filePath option\nexport COMPANION_DATADIR=\"PATH/TO/DOWNLOAD/DIRECTORY\"\n\n###### Optional variables ##########\n\n# corresponds to the server.protocol option, defaults to http\nexport COMPANION_PROTOCOL=\"YOUR SERVER PROTOCOL\"\n# the port on which to start the server, defaults to 3020\nexport COMPANION_PORT=\"YOUR SERVER PORT\"\n# corresponds to the server.port option, defaults to ''\nexport COMPANION_PATH=\"/SERVER/PATH/TO/WHERE/COMPANION/LIVES\"\n# disables the welcome page, defaults to false\nexport COMPANION_HIDE_WELCOME=\"true\"\n# disables the metrics page, defaults to false\nexport COMPANION_HIDE_METRICS=\"true\"\n\n# use this in place of COMPANION_PATH if the server path should not be\n# handled by the express.js app, but maybe by an external server configuration\n# instead (e.g Nginx).\nexport COMPANION_IMPLICIT_PATH=\"/SERVER/PATH/TO/WHERE/UPPY/SERVER/LIVES\"\n\n# comma-separated client hosts to whitlelist by the server\n# if neither this or COMPANION_CLIENT_ORIGINS_REGEX specified, the server would allow any host\nexport COMPANION_CLIENT_ORIGINS=\"localhost:3452,uppy.io\"\n\n# Like COMPANION_CLIENT_ORIGINS, but allows a single regex instead\n# (COMPANION_CLIENT_ORIGINS will be ignored if this is used and vice versa)\nexport COMPANION_CLIENT_ORIGINS_REGEX=\"https://.*\\.example\\.(com|eu)$\"\n\n# corresponds to the redisUrl option\n# this also enables Redis session storage if set\nexport COMPANION_REDIS_URL=\"REDIS URL\"\n\n# to enable Dropbox\nexport COMPANION_DROPBOX_KEY=\"YOUR DROPBOX KEY\"\nexport COMPANION_DROPBOX_SECRET=\"YOUR DROPBOX SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_DROPBOX_SECRET_FILE=\"PATH/TO/DROPBOX/SECRET/FILE\"\n\n# to enable Box\nexport COMPANION_BOX_KEY=\"YOUR BOX KEY\"\nexport COMPANION_BOX_SECRET=\"YOUR BOX SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_BOX_SECRET_FILE=\"PATH/TO/BOX/SECRET/FILE\"\n\n# to enable Google Drive\nexport COMPANION_GOOGLE_KEY=\"YOUR GOOGLE DRIVE KEY\"\nexport COMPANION_GOOGLE_SECRET=\"YOUR GOOGLE DRIVE SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_GOOGLE_SECRET_FILE=\"PATH/TO/GOOGLEDRIVE/SECRET/FILE\"\n\n# to enable Instagram\nexport COMPANION_INSTAGRAM_KEY=\"YOUR INSTAGRAM KEY\"\nexport COMPANION_INSTAGRAM_SECRET=\"YOUR INSTAGRAM SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_INSTAGRAM_SECRET_FILE=\"PATH/TO/INSTAGRAM/SECRET/FILE\"\n\n# to enable Facebook\nexport COMPANION_FACEBOOK_KEY=\"YOUR FACEBOOK KEY\"\nexport COMPANION_FACEBOOK_SECRET=\"YOUR FACEBOOK SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_FACEBOOK_SECRET_FILE=\"PATH/TO/FACEBOOK/SECRET/FILE\"\n\n# to enable Onedrive\nexport COMPANION_ONEDRIVE_KEY=\"YOUR ONEDRIVE KEY\"\nexport COMPANION_ONEDRIVE_SECRET=\"YOUR ONEDRIVE SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_ONEDRIVE_SECRET_FILE=\"PATH/TO/ONEDRIVE/SECRET/FILE\"\n\n# to enable Zoom\nexport COMPANION_ZOOM_KEY=\"YOUR ZOOM KEY\"\nexport COMPANION_ZOOM_SECRET=\"YOUR ZOOM SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_ZOOM_SECRET_FILE=\"PATH/TO/ZOOM/SECRET/FILE\"\n\n# to enable S3\nexport COMPANION_AWS_KEY=\"YOUR AWS KEY\"\nexport COMPANION_AWS_SECRET=\"YOUR AWS SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_AWS_SECRET_FILE=\"PATH/TO/AWS/SECRET/FILE\"\nexport COMPANION_AWS_BUCKET=\"YOUR AWS S3 BUCKET\"\nexport COMPANION_AWS_REGION=\"AWS REGION\"\n# to enable S3 Transfer Acceleration (default: false)\nexport COMPANION_AWS_USE_ACCELERATE_ENDPOINT=\"false\"\n# to set X-Amz-Expires query param in presigned urls (in seconds, default: 300)\nexport COMPANION_AWS_EXPIRES=\"300\"\n# to set a canned ACL for uploaded objects: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl\nexport COMPANION_AWS_ACL=\"public-read\"\n\n# corresponds to the server.oauthDomain option\nexport COMPANION_OAUTH_DOMAIN=\"sub.domain.com\"\n# corresponds to the server.validHosts option\nexport COMPANION_DOMAINS=\"sub1.domain.com,sub2.domain.com,sub3.domain.com\"\n\n# corresponds to the sendSelfEndpoint option\nexport COMPANION_SELF_ENDPOINT=\"THIS SHOULD BE SAME AS YOUR DOMAIN + PATH\"\n\n# comma-separated URLs\n# corresponds to the uploadUrls option (comma-separated)\nexport COMPANION_UPLOAD_URLS=\"http://tusd.tusdemo.net/files/,https://tusd.tusdemo.net/files/\"\n\n# corresponds to the streamingUpload option\nexport COMPANION_STREAMING_UPLOAD=true\n\n# corresponds to the maxFileSize option\nexport COMPANION_MAX_FILE_SIZE=\"100000000\"\n\n# corresponds to the chunkSize option\nexport COMPANION_CHUNK_SIZE=\"50000000\"\n\n# corresponds to the periodicPingUrls option (CSV string converted to array)\nexport COMPANION_PERIODIC_PING_URLS=\"https://example.com/ping1,https://example.com/ping2\"\n# corresponds to the periodicPingInterval option\nexport COMPANION_PERIODIC_PING_INTERVAL=60000\n# corresponds to the periodicPingStaticPayload option (JSON string)\nexport COMPANION_PERIODIC_PING_STATIC_JSON_PAYLOAD=\"{\\\"static\\\":\\\"data\\\"}\"\n```\n\nSee [env.example.sh](https://github.com/transloadit/uppy/blob/main/env.example.sh) for an example configuration script.\n\n### Options\n\n```javascript\nconst options = {\n  providerOptions: {\n    drive: {\n      key: '***',\n      secret: '***',\n    },\n    dropbox: {\n      key: '***',\n      secret: '***',\n    },\n    instagram: {\n      key: '***',\n      secret: '***',\n    },\n    facebook: {\n      key: '***',\n      secret: '***',\n    },\n    onedrive: {\n      key: '***',\n      secret: '***',\n    },\n    s3: {\n      getKey: (req, filename, metadata) => filename,\n      key: '***',\n      secret: '***',\n      bucket: 'bucket-name',\n      region: 'us-east-1',\n      useAccelerateEndpoint: false, // default: false,\n      expires: 3600, // default: 300 (5 minutes)\n      acl: 'private', // default: public-read\n    },\n  },\n  server: {\n    host: 'localhost:3020', // or yourdomain.com\n    protocol: 'http',\n  },\n  filePath: 'path/to/download/folder',\n  sendSelfEndpoint: 'localhost:3020',\n  secret: 'mysecret',\n  uploadUrls: ['https://myuploadurl.com', /^http:\\/\\/myuploadurl2.com\\//],\n  debug: true,\n  metrics: false,\n  streamingUpload: true,\n  maxFileSize: 100000000,\n  periodicPingUrls: [],\n  periodicPingInterval: 60000,\n  periodicPingStaticPayload: { static: 'payload' },\n}\n```\n\n1. **filePath(required)** - Full path to the directory to which provider files will be downloaded temporarily.\n\n2. **secret(recommended)** - A secret string which Companion uses to generate authorization tokens. You should generate a long random string for this.\n\n3. **uploadUrls(recommended)** - An allowlist (array) of strings (exact URLs) or regular expressions. If specified, Companion will only accept uploads to these URLs. This is needed to make sure a Companion instance is only allowed to upload to your servers. **Omitting this leaves your system open to potential [SSRF](https://en.wikipedia.org/wiki/Server-side_request_forgery) attacks, and may throw an error in future `@uppy/companion` releases.**\n\n4. **redisUrl(optional)** - URL to running Redis server. If this is set, the state of uploads would be stored temporarily. This helps for resumed uploads after a browser crash from the client. The stored upload would be sent back to the client on reconnection.\n\n5. **redisOptions(optional)** - An object of [options supported by redis client](https://www.npmjs.com/package/redis#options-object-properties). This option can be used in place of `redisUrl`.\n\n6. **redisPubSubScope(optional)** - Use a scope for the companion events at the Redis server. Setting this option will prefix all events with the name provided and a colon.\n\n7. **server(optional)** - An object with details, mainly used to carry out oauth authentication from any of the enabled providers above. Though it\u2019s optional, it\u2019s required if you would be enabling any of the supported providers. The following are the server options you may set:\n\n* `protocol` - `http | https` - even though companion itself always runs as http, you may want to set this to `https` if you are running a reverse https proxy in front of companion.\n* `host` (required) - your server\u2019s publically facing hostname (for example `example.com`).\n* `oauthDomain` - if you have several instances of Companion with different (and perhaps dynamic) subdomains, you can set a single fixed domain (e.g `sub1.example.com`) to handle your OAuth authentication for you. This would then redirect back to the correct instance with the required credentials on completion. This way you only need to configure a single callback URL for OAuth providers.\n* `path` - the server path to where the Uppy app is sitting (e.g if Companion is at `example.com/companion`, then the path would be `/companion`).\n* `implicitPath` - if the URL\u2019s path in your reverse proxy is different from your Companion path in your express app, then you need to set this path as `implicitPath`. So if your Companion URL is `example.com/mypath/companion`. Where the path `/mypath` is defined in your NGINX server, while `/companion` is set in your express app. Then you need to set the option `implicitPath` to `/mypath`, and set the `path` option to `/companion`.\n* `validHosts` - if you are setting an `oauthDomain`, you need to set a list of valid hosts, so the oauth handler can validate the host of the Uppy instance requesting the authentication. This is essentially a list of valid domains running your Companion instances. The list may also contain regex patterns. e.g `['sub2.example.com', 'sub3.example.com', '(\\\\w+).example.com']`\n\n8. **sendSelfEndpoint(optional)** - This is essentially the same as the `server.host + server.path` attributes. The major reason for this attribute is that, when set, it adds the value as the `i-am` header of every request response.\n\n9. **providerOptions(optional)** - An object containing credentials (`key` and `secret`) for each provider you would like to enable. Please see [the list of supported providers](#Supported-providers).\n\n10. **customProviders(optional)** - This option enables you to add custom providers along with the already supported providers. See [Adding Custom Providers](#Adding-custom-providers) for more information.\n\n11. **debug(optional)** - A boolean flag to tell Companion whether to log useful debug information while running.\n\n12. **logClientVersion(optional)** - A boolean flag to tell Companion whether to log its version upon startup.\n\n13. **metrics(optional)** - A boolean flag to tell Companion whether to provide an endpoint `/metrics` with Prometheus metrics.\n\n14. **streamingUpload(optional)** - A boolean flag to tell Companion whether to enable streaming uploads. If enabled, it will lead to _faster uploads_ because companion will start uploading at the same time as downloading using `stream.pipe`. If `false`, files will be fully downloaded first, then uploaded. Defaults to `false`. Do **not** set it to `true` if you have a [custom Companion provider](#adding-custom-providers) that does not use the new async/stream API.\n\n15. **maxFileSize(optional)** - If this value is set, companion will limit the maximum file size to process. If unset, it will process files without any size limit (this is the default).\n\n16. **periodicPingUrls(optional)** - If this value is set, companion will periodically send POST requests to the specified URLs. Useful for keeping track of companion instances as a keep-alive.\n\n17. **periodicPingInterval(optional)** - Interval for periodic ping requests (in ms).\n\n18. **periodicPingStaticPayload(optional)** - A `JSON.stringify`-able JavaScript Object that will be sent as part of the JSON body in the period ping requests.\n\n### Provider Redirect URIs\n\nWhen generating your provider API keys on their corresponding developer platforms (e.g [Google Developer Console](https://console.developers.google.com/)), you\u2019d need to provide a `redirect URI` for the OAuth authorization process. In general the redirect URI for each provider takes the format:\n\n`http(s)://$YOUR_COMPANION_HOST_NAME/$PROVIDER_NAME/redirect`\n\nFor example, if your Companion server is hosted on `https://my.companion.server.com`, then the redirect URI you would supply for your OneDrive provider would be:\n\n`https://my.companion.server.com/onedrive/redirect`\n\nPlease see [Supported Providers](https://uppy.io/docs/companion/#Supported-providers) for a list of all Providers and their corresponding names.\n\n### S3 options\n\nCompanion comes with signature endpoints for AWS S3. These can be used by the Uppy client to sign requests to upload files directly to S3, without exposing secret S3 keys in the browser. Companion also supports uploading files from providers like Dropbox and Instagram directly into S3.\n\nThe S3 features can be configured using the `providerOptions.s3` property.\n\n#### `providerOptions.s3.key`\n\nThe S3 access key ID. The standalone Companion server populates this with the value of the `COMPANION_AWS_KEY` environment variable by default.\n\n#### `providerOptions.s3.secret`\n\nThe S3 secret access key. The standalone Companion server populates this with the value of the `COMPANION_AWS_SECRET` environment variable by default.\n\n#### `providerOptions.s3.bucket`\n\nThe name of the bucket to store uploaded files in. The standalone Companion server populates this with the value of the `COMPANION_AWS_BUCKET` environment variable by default.\n\n#### `providerOptions.s3.region`\n\nThe datacenter region where the target bucket is located. The standalone Companion server populates this with the value of the `COMPANION_AWS_REGION` environment variable by default.\n\n#### `providerOptions.s3.awsClientOptions`\n\nYou can supply any [S3 option supported by the AWS SDK](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#constructor-property) in the `providerOptions.s3.awsClientOptions` object, _except for_ the below:\n\n* `accessKeyId`. Instead, use the `providerOptions.s3.key` property. This is to make configuration names consistent between different Companion features.\n* `secretAccessKey`. Instead, use the `providerOptions.s3.secret` property. This is to make configuration names consistent between different Companion features.\n\nBe aware that some options may cause wrong behaviour if they conflict with Companion\u2019s assumptions. If you find that a particular option does not work as expected, please [open an issue on the Uppy repository](https://github.com/transloadit/uppy/issues/new) so we can document it here.\n\n#### `providerOptions.s3.getKey(req, filename, metadata)`\n\nGet the key name for a file. The key is the file path to which the file will be uploaded in your bucket. This option should be a function receiving three arguments:\n\n* `req`, the HTTP request, for _regular_ S3 uploads using the `@uppy/aws-s3` plugin. This parameter is _not_ available for multipart uploads using the `@uppy/aws-s3-multipart` plugin;\n* `filename`, the original name of the uploaded file;\n* `metadata`, user-provided metadata for the file. See the [`@uppy/aws-s3`](https://uppy.io/docs/aws-s3/#metaFields) docs. The `@uppy/aws-s3-multipart` plugin unconditionally sends all metadata fields, so they all are available here.\n\nThis function should return a string `key`. The `req` parameter can be used to upload to a user-specific folder in your bucket, for example:\n\n```js\napp.use(authenticationMiddleware)\napp.use(uppy.app({\n  providerOptions: {\n    s3: {\n      getKey: (req, filename, metadata) => `${req.user.id}/${filename}`,\n      /* auth options */\n    },\n  },\n}))\n```\n\nThe default implementation returns the `filename`, so all files will be uploaded to the root of the bucket as their original file name.\n\n```js\napp.use(uppy.app({\n  providerOptions: {\n    s3: {\n      getKey: (req, filename, metadata) => filename,\n    },\n  },\n}))\n```\n\n### Running in Kubernetes\n\nWe have [a detailed guide on running Companion in Kubernetes](https://github.com/transloadit/uppy/blob/main/packages/%40uppy/companion/KUBERNETES.md) for you, that\u2019s how we run our example server at <https://companion.uppy.io>.\n\n### Adding custom providers\n\nAs of now, Companion supports the [providers listed here](https://uppy.io/docs/companion/#Supported-providers) out of the box, but you may also choose to add your own custom providers. You can do this by passing the `customProviders` option when calling the Uppy `app` method. The custom provider is expected to support Oauth 1 or 2 for authentication/authorization.\n\n```javascript\nimport providerModule from './path/to/provider/module'\n\nconst options = {\n  customProviders: {\n    myprovidername: {\n      config: {\n        authorize_url: 'https://mywebsite.com/authorize',\n        access_url: 'https://mywebsite.com/token',\n        oauth: 2,\n        key: '***',\n        secret: '***',\n        scope: ['read', 'write'],\n      },\n      module: providerModule,\n    },\n  },\n}\n\nuppy.app(options)\n```\n\nThe `customProviders` option should be an object containing each custom provider. Each custom provider would, in turn, be an object with two keys, `config` and `module`. The `config` option would contain Oauth API settings, while the `module` would point to the provider module.\n\nTo work well with Companion, the **module** must be a class with the following methods. Note that the methods must be `async`, return a `Promise` or reject with an `Error`):\n\n1. `async list ({ token, directory, query })` - Returns a object containing a list of user files (such as a list of all the files in a particular directory). See [example returned list data structure](#list-data).\n   `token` - authorization token (retrieved from oauth process) to send along with your request\n   * `directory` - the id/name of the directory from which data is to be retrieved. This may be ignored if it doesn\u2019t apply to your provider\n   * `query` - expressjs query params object received by the server (in case some data you need in there).\n2. `async download ({ token, id, query })` - Downloads a particular file from the provider. Returns an object with a single property `{ stream }` - a [`stream.Readable`](https://nodejs.org/api/stream.html#stream_class_stream_readable), which will be read from and uploaded to the destination. To prevent memory leaks, make sure you release your stream if you reject this method with an error.\n   * `token` - authorization token (retrieved from oauth process) to send along with your request.\n   * `id` - ID of the file being downloaded.\n   * `query` - expressjs query params object received by the server (in case some data you need in there).\n3. `async size ({ token, id, query })` - Returns the byte size of the file that needs to be downloaded as a `Number`. If the size of the object is not known, `null` may be returned.\n   * `token` - authorization token (retrieved from oauth process) to send along with your request.\n   * `id` - ID of the file being downloaded.\n   * `query` - expressjs query params object received by the server (in case some data you need in there).\n\nThe class must also have:\n\n* A unique `authProvider` string property - a lowercased value which typically indicates the name of the provider (e.g \u201cdropbox\u201d).\n* A `static` property `static version = 2`, which is the current version of the Companion Provider API.\n\nSee also [example code with a custom provider](https://github.com/transloadit/uppy/blob/main/examples/custom-provider/server).\n\n#### list data\n\n```json\n{\n  // username or email of the user whose provider account is being accessed\n  \"username\": \"johndoe\",\n  // list of files and folders in the directory. An item is considered a folder\n  //  if it mainly exists as a collection to contain sub-items\n  \"items\": [\n    {\n      // boolean value of whether or NOT it's a folder\n      \"isFolder\": false,\n      // icon image URL\n      \"icon\": \"https://random-api.url.com/fileicon.jpg\",\n      // name of the item\n      \"name\": \"myfile.jpg\",\n      // the mime type of the item. Only relevant if the item is NOT a folder\n      \"mimeType\": \"image/jpg\",\n      // the id (in string) of the item\n      \"id\": \"uniqueitemid\",\n      // thumbnail image URL. Only relevant if the item is NOT a folder\n      \"thumbnail\": \"https://random-api.url.com/filethumbnail.jpg\",\n      // for folders this is typically the value that will be passed as \"directory\" in the list(...) method.\n      // For files, this is the value that will be passed as id in the download(...) method.\n      \"requestPath\": \"file-or-folder-requestpath\",\n      // datetime string (in ISO 8601 format) of when this item was last modified\n      \"modifiedDate\": \"2020-06-29T19:59:58Z\",\n      // the size in bytes of the item. Only relevant if the item is NOT a folder\n      \"size\": 278940,\n      \"custom\": {\n        // an object that may contain some more custom fields that you may need to send to the client. Only add this object if you have a need for it.\n        \"customData1\": \"the value\",\n        \"customData2\": \"the value\"\n      }\n      // more items here\n    }\n  ],\n  // if the \"items\" list is paginated, this is the request path needed to fetch the next page.\n  \"nextPagePath\": \"directory-name?cursor=cursor-to-next-page\"\n}\n```\n\n## Migrating v1 to v2\n\n### Prerequisite\n\nSince v2, you now need to be running `node.js >= v10.20.1` to use Companion.\n\n### ProviderOptions\n\nIn v2 the `google` and `microsoft` [providerOptions](https://uppy.io/docs/companion/#Options) have been changed to `drive` and `onedrive` respectively.\n\n### OAuth Redirect URIs\n\nOn your Providers\u2019 respective developer platforms, the OAuth redirect URIs that you should supply has now changed from:\n\n`http(s)://$COMPANION_HOST_NAME/connect/$AUTH_PROVIDER/callback` in v1\n\nto:\n\n`http(s)://$COMPANION_HOST_NAME/$PROVIDER_NAME/redirect` in v2\n\n#### New Redirect URIs\n\n<div class=\"table-responsive\">\n\n| Provider | New Redirect URI\n|-|-|\n| Dropbox | `https://$COMPANION_HOST_NAME/dropbox/redirect` |\n| Google Drive | `https://$COMPANION_HOST_NAME/drive/redirect` |\n| OneDrive | `https://$COMPANION_HOST_NAME/onedrive/redirect` |\n| Box | `https://$YOUR_COMPANION_HOST_NAME/box/redirect` |\n| Facebook | `https://$COMPANION_HOST_NAME/facebook/redirect` |\n| Instagram | `https://$COMPANION_HOST_NAME/instagram/redirect` |\n\n</div>\n\n## Development\n\n1\\. To set up Companion for local development, please clone the Uppy repo and install, like so:\n\n```bash\ngit clone https://github.com/transloadit/uppy\ncd uppy\nyarn install\n```\n\n2\\. Configure your environment variables by copying the `env.example.sh` file to `env.sh` and edit it to its correct values.\n\n```bash\ncp env.example.sh env.sh\n$EDITOR env.sh\n```\n\n3\\. To start the server, run:\n\n```bash\nyarn run start:companion\n```\n\nThis would get the Companion instance running on `http://localhost:3020`. It uses [nodemon](https://github.com/remy/nodemon) so it will automatically restart when files are changed.\n\n## Live example\n\nAn example server is running at <https://companion.uppy.io>, which is deployed with [Kubernetes](https://github.com/transloadit/uppy/blob/main/packages/%40uppy/companion/KUBERNETES.md)\n\n## How the Authentication and Token mechanism works\n\nThis section describes how Authentication works between Companion and Providers. While this behaviour is the same for all Providers (Dropbox, Instagram, Google Drive, etc.), we are going to be referring to Dropbox in place of any Provider throughout this section.\n\nThe following steps describe the actions that take place when a user Authenticates and Uploads from Dropbox through Companion:\n\n* The visitor to a website with Uppy clicks `Connect to Dropbox`.\n* Uppy sends a request to Companion, which in turn sends an OAuth request to Dropbox (Requires that OAuth credentials from Dropbox have been added to Companion).\n* Dropbox asks the visitor to log in, and whether the Website should be allowed to access your files\n* If the visitor agrees, Companion will receive a token from Dropbox, with which we can temporarily download files.\n* Companion encrypts the token with a secret key and sends the encrypted token to Uppy (client)\n* Every time the visitor clicks on a folder in Uppy, it asks Companion for the new list of files, with this question, the token (still encrypted by Companion) is sent along.\n* Companion decrypts the token, requests the list of files from Dropbox and sends it to Uppy.\n* When a file is selected for upload, Companion receives the token again according to this procedure, decrypts it again, and thereby downloads the file from Dropbox.\n* As the bytes arrive, Companion uploads the bytes to the final destination (depending on the configuration: Apache, a Tus server, S3 bucket, etc).\n* Companion reports progress to Uppy, as if it were a local upload.\n* Completed!\n"], "fixing_code": ["# Clone this file to `.env` and edit the clone.\n\nNODE_ENV=development\n\n# Companion\n# =======================\nCOMPANION_DATADIR=./output\nCOMPANION_DOMAIN=localhost:3020\nCOMPANION_PROTOCOL=http\nCOMPANION_PORT=3020\nCOMPANION_CLIENT_ORIGINS=\nCOMPANION_SECRET=development\n\n# NOTE: Only enable this in development. Enabling it in production is a security risk\nCOMPANION_ALLOW_LOCAL_URLS=true\n\nCOMPANION_DROPBOX_KEY=***\nCOMPANION_DROPBOX_SECRET=***\n\nCOMPANION_BOX_KEY=***\nCOMPANION_BOX_SECRET=***\n\nCOMPANION_GOOGLE_KEY=***\nCOMPANION_GOOGLE_SECRET=***\n\nCOMPANION_INSTAGRAM_KEY=***\nCOMPANION_INSTAGRAM_SECRET=***\n\nCOMPANION_FACEBOOK_KEY=***\nCOMPANION_FACEBOOK_SECRET=***\n\nCOMPANION_ZOOM_KEY=***\nCOMPANION_ZOOM_SECRET=***\n\nCOMPANION_UNSPLASH_KEY=***\nCOMPANION_UNSPLASH_SECRET=***\n\n# Development environment\n# =======================\n\nVITE_UPLOADER=tus\n# VITE_UPLOADER=s3\n# VITE_UPLOADER=s3-multipart\n# xhr will use protocol 'multipart' in companion, if used with a remote service, e.g. google drive.\n# If local upload will use browser XHR\n# VITE_UPLOADER=xhr\n# VITE_UPLOADER=transloadit\n# VITE_UPLOADER=transloadit-s3\n# VITE_UPLOADER=transloadit-xhr\n\nVITE_COMPANION_URL=http://localhost:3020\nVITE_TUS_ENDPOINT=https://tusd.tusdemo.net/files/\nVITE_XHR_ENDPOINT=https://xhr-server.herokuapp.com/upload\n\nVITE_TRANSLOADIT_KEY=***\nVITE_TRANSLOADIT_TEMPLATE=***\nVITE_TRANSLOADIT_SERVICE_URL=https://api2.transloadit.com\n", "#!/usr/bin/env bash\n\n# Load local env vars. In CI, these are injected.\nif [ -f .env ]; then\n  nodemon --watch packages/@uppy/companion/src --exec node -r dotenv/config ./packages/@uppy/companion/src/standalone/start-server.js\nelse\n  env \\\n    COMPANION_DATADIR=\"./output\" \\\n    COMPANION_DOMAIN=\"localhost:3020\" \\\n    COMPANION_PROTOCOL=\"http\" \\\n    COMPANION_PORT=3020 \\\n    COMPANION_CLIENT_ORIGINS=\"\" \\\n    COMPANION_SECRET=\"development\" \\\n    COMPANION_ALLOW_LOCAL_URLS=\"true\" \\\n    nodemon --watch packages/@uppy/companion/src --exec node ./packages/@uppy/companion/src/standalone/start-server.js\nfi\n\n", "const fs = require('fs')\nconst express = require('express')\nconst ms = require('ms')\n// @ts-ignore\nconst Grant = require('grant').express()\nconst merge = require('lodash.merge')\nconst cookieParser = require('cookie-parser')\nconst interceptor = require('express-interceptor')\nconst { isURL } = require('validator')\nconst uuid = require('uuid')\n\nconst grantConfig = require('./config/grant')()\nconst providerManager = require('./server/provider')\nconst controllers = require('./server/controllers')\nconst s3 = require('./server/controllers/s3')\nconst getS3Client = require('./server/s3-client')\nconst url = require('./server/controllers/url')\nconst emitter = require('./server/emitter')\nconst redis = require('./server/redis')\nconst { getURLBuilder } = require('./server/helpers/utils')\nconst jobs = require('./server/jobs')\nconst logger = require('./server/logger')\nconst middlewares = require('./server/middlewares')\nconst { ProviderApiError, ProviderAuthError } = require('./server/provider/error')\nconst { getCredentialsOverrideMiddleware } = require('./server/provider/credentials')\n// @ts-ignore\nconst { version } = require('../package.json')\n\nconst defaultOptions = {\n  server: {\n    protocol: 'http',\n    path: '',\n  },\n  providerOptions: {\n    s3: {\n      acl: 'public-read',\n      endpoint: 'https://{service}.{region}.amazonaws.com',\n      conditions: [],\n      useAccelerateEndpoint: false,\n      getKey: (req, filename) => filename,\n      expires: ms('5 minutes') / 1000,\n    },\n  },\n  allowLocalUrls: false,\n  logClientVersion: true,\n  periodicPingUrls: [],\n  streamingUpload: false,\n}\n\n// make the errors available publicly for custom providers\nmodule.exports.errors = { ProviderApiError, ProviderAuthError }\nmodule.exports.socket = require('./server/socket')\n\n/**\n * Entry point into initializing the Companion app.\n *\n * @param {object} options\n * @returns {import('express').Express}\n */\nmodule.exports.app = (options = {}) => {\n  validateConfig(options)\n\n  options = merge({}, defaultOptions, options)\n  const providers = providerManager.getDefaultProviders()\n  const searchProviders = providerManager.getSearchProviders()\n  providerManager.addProviderOptions(options, grantConfig)\n\n  const { customProviders } = options\n  if (customProviders) {\n    providerManager.addCustomProviders(customProviders, providers, grantConfig)\n  }\n\n  // mask provider secrets from log messages\n  maskLogger(options)\n\n  // create singleton redis client\n  if (options.redisUrl) {\n    redis.client(merge({ url: options.redisUrl }, options.redisOptions || {}))\n  }\n  emitter(options.multipleInstances && options.redisUrl, options.redisPubSubScope)\n\n  const app = express()\n\n  if (options.metrics) {\n    app.use(middlewares.metrics({ path: options.server.path }))\n\n    // backward compatibility\n    // TODO remove in next major semver\n    if (options.server.path) {\n      const buildUrl = getURLBuilder(options)\n      app.get('/metrics', (req, res) => {\n        process.emitWarning('/metrics is deprecated when specifying a path to companion')\n        const metricsUrl = buildUrl('/metrics', true)\n        res.redirect(metricsUrl)\n      })\n    }\n  }\n\n  app.use(cookieParser()) // server tokens are added to cookies\n\n  app.use(interceptGrantErrorResponse)\n  // override provider credentials at request time\n  app.use('/connect/:authProvider/:override?', getCredentialsOverrideMiddleware(providers, options))\n  app.use(Grant(grantConfig))\n\n  app.use((req, res, next) => {\n    if (options.sendSelfEndpoint) {\n      const { protocol } = options.server\n      res.header('i-am', `${protocol}://${options.sendSelfEndpoint}`)\n    }\n    next()\n  })\n\n  app.use(middlewares.cors(options))\n\n  // add uppy options to the request object so it can be accessed by subsequent handlers.\n  app.use('*', getOptionsMiddleware(options))\n  app.use('/s3', s3(options.providerOptions.s3))\n  app.use('/url', url())\n\n  app.post('/:providerName/preauth', middlewares.hasSessionAndProvider, controllers.preauth)\n  app.get('/:providerName/connect', middlewares.hasSessionAndProvider, controllers.connect)\n  app.get('/:providerName/redirect', middlewares.hasSessionAndProvider, controllers.redirect)\n  app.get('/:providerName/callback', middlewares.hasSessionAndProvider, controllers.callback)\n  app.post('/:providerName/deauthorization/callback', middlewares.hasSessionAndProvider, controllers.deauthorizationCallback)\n  app.get('/:providerName/logout', middlewares.hasSessionAndProvider, middlewares.gentleVerifyToken, controllers.logout)\n  app.get('/:providerName/send-token', middlewares.hasSessionAndProvider, middlewares.verifyToken, controllers.sendToken)\n  app.get('/:providerName/list/:id?', middlewares.hasSessionAndProvider, middlewares.verifyToken, controllers.list)\n  app.post('/:providerName/get/:id', middlewares.hasSessionAndProvider, middlewares.verifyToken, controllers.get)\n  app.get('/:providerName/thumbnail/:id', middlewares.hasSessionAndProvider, middlewares.cookieAuthToken, middlewares.verifyToken, controllers.thumbnail)\n  // @ts-ignore Type instantiation is excessively deep and possibly infinite.\n  app.get('/search/:searchProviderName/list', middlewares.hasSearchQuery, middlewares.loadSearchProviderToken, controllers.list)\n  app.post('/search/:searchProviderName/get/:id', middlewares.loadSearchProviderToken, controllers.get)\n\n  app.param('providerName', providerManager.getProviderMiddleware(providers, true))\n  app.param('searchProviderName', providerManager.getProviderMiddleware(searchProviders))\n\n  if (app.get('env') !== 'test') {\n    jobs.startCleanUpJob(options.filePath)\n  }\n\n  const processId = uuid.v4()\n\n  jobs.startPeriodicPingJob({\n    urls: options.periodicPingUrls,\n    interval: options.periodicPingInterval,\n    count: options.periodicPingCount,\n    staticPayload: options.periodicPingStaticPayload,\n    version,\n    processId,\n  })\n\n  return app\n}\n\n// intercepts grantJS' default response error when something goes\n// wrong during oauth process.\nconst interceptGrantErrorResponse = interceptor((req, res) => {\n  return {\n    isInterceptable: () => {\n      // match grant.js' callback url\n      return /^\\/connect\\/\\w+\\/callback/.test(req.path)\n    },\n    intercept: (body, send) => {\n      const unwantedBody = 'error=Grant%3A%20missing%20session%20or%20misconfigured%20provider'\n      if (body === unwantedBody) {\n        logger.error(`grant.js responded with error: ${body}`, 'grant.oauth.error', req.id)\n        res.set('Content-Type', 'text/plain')\n        const reqHint = req.id ? `Request ID: ${req.id}` : ''\n        send([\n          'Companion was unable to complete the OAuth process :(',\n          'Error: User session is missing or the Provider was misconfigured',\n          reqHint,\n        ].join('\\n'))\n      } else {\n        send(body)\n      }\n    },\n  }\n})\n\n/**\n *\n * @param {object} options\n */\nconst getOptionsMiddleware = (options) => {\n  /**\n   * @param {object} req\n   * @param {object} res\n   * @param {Function} next\n   */\n  const middleware = (req, res, next) => {\n    const versionFromQuery = req.query.uppyVersions ? decodeURIComponent(req.query.uppyVersions) : null\n    req.companion = {\n      options,\n      s3Client: getS3Client(options),\n      authToken: req.header('uppy-auth-token') || req.query.uppyAuthToken,\n      clientVersion: req.header('uppy-versions') || versionFromQuery || '1.0.0',\n      buildURL: getURLBuilder(options),\n    }\n\n    if (options.logClientVersion) {\n      logger.info(`uppy client version ${req.companion.clientVersion}`, 'companion.client.version')\n    }\n    next()\n  }\n\n  return middleware\n}\n\n/**\n * Informs the logger about all provider secrets that should be masked\n * if they are found in a log message\n *\n * @param {object} companionOptions\n */\nconst maskLogger = (companionOptions) => {\n  const secrets = []\n  const { providerOptions, customProviders } = companionOptions\n  Object.keys(providerOptions).forEach((provider) => {\n    if (providerOptions[provider].secret) {\n      secrets.push(providerOptions[provider].secret)\n    }\n  })\n\n  if (customProviders) {\n    Object.keys(customProviders).forEach((provider) => {\n      if (customProviders[provider].config && customProviders[provider].config.secret) {\n        secrets.push(customProviders[provider].config.secret)\n      }\n    })\n  }\n\n  logger.setMaskables(secrets)\n}\n\n/**\n * validates that the mandatory companion options are set.\n * If it is invalid, it will console an error of unset options and exits the process.\n * If it is valid, nothing happens.\n *\n * @param {object} companionOptions\n */\nconst validateConfig = (companionOptions) => {\n  const mandatoryOptions = ['secret', 'filePath', 'server.host']\n  /** @type {string[]} */\n  const unspecified = []\n\n  mandatoryOptions.forEach((i) => {\n    const value = i.split('.').reduce((prev, curr) => (prev ? prev[curr] : undefined), companionOptions)\n\n    if (!value) unspecified.push(`\"${i}\"`)\n  })\n\n  // vaidate that all required config is specified\n  if (unspecified.length) {\n    const messagePrefix = 'Please specify the following options to use companion:'\n    throw new Error(`${messagePrefix}\\n${unspecified.join(',\\n')}`)\n  }\n\n  // validate that specified filePath is writeable/readable.\n  try {\n    // @ts-ignore\n    fs.accessSync(`${companionOptions.filePath}`, fs.R_OK | fs.W_OK) // eslint-disable-line no-bitwise\n  } catch (err) {\n    throw new Error(\n      `No access to \"${companionOptions.filePath}\". Please ensure the directory exists and with read/write permissions.`,\n    )\n  }\n\n  const { providerOptions, periodicPingUrls } = companionOptions\n\n  if (providerOptions) {\n    const deprecatedOptions = { microsoft: 'onedrive', google: 'drive' }\n    Object.keys(deprecatedOptions).forEach((deprected) => {\n      if (providerOptions[deprected]) {\n        throw new Error(`The Provider option \"${deprected}\" is no longer supported. Please use the option \"${deprecatedOptions[deprected]}\" instead.`)\n      }\n    })\n  }\n\n  if (companionOptions.uploadUrls == null || companionOptions.uploadUrls.length === 0) {\n    logger.warn('Running without uploadUrls specified is a security risk if running in production', 'startup.uploadUrls')\n  }\n\n  if (periodicPingUrls != null && (\n    !Array.isArray(periodicPingUrls)\n    || periodicPingUrls.some((url2) => !isURL(url2, { protocols: ['http', 'https'], require_protocol: true, require_tld: false }))\n  )) {\n    throw new TypeError('Invalid periodicPingUrls')\n  }\n}\n", "const router = require('express').Router\nconst request = require('request')\nconst { URL } = require('url')\nconst validator = require('validator')\n\nconst { startDownUpload } = require('../helpers/upload')\nconst { getURLMeta, getRedirectEvaluator, getProtectedHttpAgent } = require('../helpers/request')\nconst logger = require('../logger')\n\n/**\n * Validates that the download URL is secure\n *\n * @param {string} url the url to validate\n * @param {boolean} ignoreTld whether to allow local addresses\n */\nconst validateURL = (url, ignoreTld) => {\n  if (!url) {\n    return false\n  }\n\n  const validURLOpts = {\n    protocols: ['http', 'https'],\n    require_protocol: true,\n    require_tld: !ignoreTld,\n  }\n  if (!validator.isURL(url, validURLOpts)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @callback downloadCallback\n * @param {Error} err\n * @param {string | Buffer | Buffer[]} chunk\n */\n\n/**\n * Downloads the content in the specified url, and passes the data\n * to the callback chunk by chunk.\n *\n * @param {string} url\n * @param {boolean} blockLocalIPs\n * @param {string} traceId\n * @returns {Promise}\n */\nconst downloadURL = async (url, blockLocalIPs, traceId) => {\n  const opts = {\n    uri: url,\n    method: 'GET',\n    followRedirect: getRedirectEvaluator(url, blockLocalIPs),\n    agentClass: getProtectedHttpAgent((new URL(url)).protocol, blockLocalIPs),\n  }\n\n  return new Promise((resolve, reject) => {\n    const req = request(opts)\n      .on('response', (resp) => {\n        if (resp.statusCode >= 300) {\n          req.abort() // No need to keep request\n          reject(new Error(`URL server responded with status: ${resp.statusCode}`))\n          return\n        }\n\n        // Don't allow any more data to flow yet.\n        // https://github.com/request/request/issues/1990#issuecomment-184712275\n        resp.pause()\n        resolve(resp)\n      })\n      .on('error', (err) => {\n        logger.error(err, 'controller.url.download.error', traceId)\n        reject(err)\n      })\n  })\n}\n\n/**\n * Fteches the size and content type of a URL\n *\n * @param {object} req expressJS request object\n * @param {object} res expressJS response object\n */\nconst meta = async (req, res) => {\n  try {\n    logger.debug('URL file import handler running', null, req.id)\n    const { allowLocalUrls } = req.companion.options\n    if (!validateURL(req.body.url, allowLocalUrls)) {\n      logger.debug('Invalid request body detected. Exiting url meta handler.', null, req.id)\n      return res.status(400).json({ error: 'Invalid request body' })\n    }\n\n    const urlMeta = await getURLMeta(req.body.url, !allowLocalUrls)\n    return res.json(urlMeta)\n  } catch (err) {\n    logger.error(err, 'controller.url.meta.error', req.id)\n    // @todo send more meaningful error message and status code to client if possible\n    return res.status(err.status || 500).json({ message: 'failed to fetch URL metadata' })\n  }\n}\n\n/**\n * Handles the reques of import a file from a remote URL, and then\n * subsequently uploading it to the specified destination.\n *\n * @param {object} req expressJS request object\n * @param {object} res expressJS response object\n */\nconst get = async (req, res) => {\n  logger.debug('URL file import handler running', null, req.id)\n  const { allowLocalUrls } = req.companion.options\n  if (!validateURL(req.body.url, allowLocalUrls)) {\n    logger.debug('Invalid request body detected. Exiting url import handler.', null, req.id)\n    res.status(400).json({ error: 'Invalid request body' })\n    return\n  }\n\n  async function getSize () {\n    const { size } = await getURLMeta(req.body.url, !allowLocalUrls)\n    return size\n  }\n\n  async function download () {\n    return downloadURL(req.body.url, !allowLocalUrls, req.id)\n  }\n\n  function onUnhandledError (err) {\n    logger.error(err, 'controller.url.error', req.id)\n    // @todo send more meaningful error message and status code to client if possible\n    res.status(err.status || 500).json({ message: 'failed to fetch URL metadata' })\n  }\n\n  startDownUpload({ req, res, getSize, download, onUnhandledError })\n}\n\nmodule.exports = () => router()\n  .post('/meta', meta)\n  .post('/get', get)\n", "const chalk = require('chalk')\nconst escapeStringRegexp = require('escape-string-regexp')\nconst util = require('util')\n\nconst valuesToMask = []\n/**\n * Adds a list of strings that should be masked by the logger.\n * This function can only be called once through out the life of the server.\n *\n * @param {Array} maskables a list of strings to be masked\n */\nexports.setMaskables = (maskables) => {\n  maskables.forEach((i) => {\n    valuesToMask.push(escapeStringRegexp(i))\n  })\n\n  Object.freeze(valuesToMask)\n}\n\n/**\n * Mask the secret content of a message\n *\n * @param {string} msg the message whose content should be masked\n * @returns {string}\n */\nfunction maskMessage (msg) {\n  let out = msg\n  for (const toBeMasked of valuesToMask) {\n    const toBeReplaced = new RegExp(toBeMasked, 'gi')\n    out = out.replace(toBeReplaced, '******')\n  }\n  return out\n}\n\n/**\n * message log\n *\n * @param {string | Error} msg the message to log\n * @param {string} tag a unique tag to easily search for this message\n * @param {string} level error | info | debug\n * @param {string=} id a unique id to easily trace logs tied to a request\n * @param {Function=} color function to display the log in appropriate color\n * @param {boolean=} shouldLogStackTrace when set to true, errors will be logged with their stack trace\n */\nconst log = (msg, tag = '', level, id = '', color = (message) => message, shouldLogStackTrace) => {\n  const time = new Date().toISOString()\n  const whitespace = tag && id ? ' ' : ''\n\n  function logMsg (msg2) {\n    let msgString = typeof msg2 === 'string' ? msg2 : util.inspect(msg2)\n    msgString = maskMessage(msgString)\n    // eslint-disable-next-line no-console\n    console.log(color(`companion: ${time} [${level}] ${id}${whitespace}${tag}`), color(msgString))\n  }\n\n  if (msg instanceof Error) {\n    // Not sure why it only logs the stack without the message, but this is how the code was originally\n    if (shouldLogStackTrace && typeof msg.stack === 'string') {\n      logMsg(msg.stack)\n      return\n    }\n\n    // We don't want to log stack trace (this is how the code was originally)\n    logMsg(String(msg))\n    return\n  }\n\n  logMsg(msg)\n}\n\n/**\n * INFO level log\n *\n * @param {string} msg the message to log\n * @param {string=} tag a unique tag to easily search for this message\n * @param {string=} traceId a unique id to easily trace logs tied to a request\n */\nexports.info = (msg, tag, traceId) => {\n  log(msg, tag, 'info', traceId)\n}\n\n/**\n * WARN level log\n *\n * @param {string} msg the message to log\n * @param {string=} tag a unique tag to easily search for this message\n * @param {string=} traceId a unique id to easily trace logs tied to a request\n */\nexports.warn = (msg, tag, traceId) => {\n  // @ts-ignore\n  log(msg, tag, 'warn', traceId, chalk.bold.yellow)\n}\n\n/**\n * ERROR level log\n *\n * @param {string | Error} msg the message to log\n * @param {string=} tag a unique tag to easily search for this message\n * @param {string=} traceId a unique id to easily trace logs tied to a request\n * @param {boolean=} shouldLogStackTrace when set to true, errors will be logged with their stack trace\n */\nexports.error = (msg, tag, traceId, shouldLogStackTrace) => {\n  // @ts-ignore\n  log(msg, tag, 'error', traceId, chalk.bold.red, shouldLogStackTrace)\n}\n\n/**\n * DEBUG level log\n *\n * @param {string} msg the message to log\n * @param {string=} tag a unique tag to easily search for this message\n * @param {string=} traceId a unique id to easily trace logs tied to a request\n */\nexports.debug = (msg, tag, traceId) => {\n  if (process.env.NODE_ENV !== 'production') {\n    // @ts-ignore\n    log(msg, tag, 'debug', traceId, chalk.bold.blue)\n  }\n}\n", "const request = require('request')\nconst purest = require('purest')({ request })\nconst { promisify } = require('util')\n\nconst Provider = require('../Provider')\nconst { getURLMeta } = require('../../helpers/request')\nconst logger = require('../../logger')\nconst adapter = require('./adapter')\nconst { ProviderApiError, ProviderAuthError } = require('../error')\nconst { requestStream } = require('../../helpers/utils')\n\n/**\n * Adapter for API https://developers.facebook.com/docs/graph-api/using-graph-api/\n */\nclass Facebook extends Provider {\n  constructor (options) {\n    super(options)\n    this.authProvider = Facebook.authProvider\n    this.client = purest({\n      ...options,\n      provider: Facebook.authProvider,\n    })\n  }\n\n  static get authProvider () {\n    return 'facebook'\n  }\n\n  _list ({ directory, token, query = { cursor: null } }, done) {\n    const qs = {\n      fields: 'name,cover_photo,created_time,type',\n    }\n\n    if (query.cursor) {\n      qs.after = query.cursor\n    }\n\n    let path = 'me/albums'\n    if (directory) {\n      path = `${directory}/photos`\n      qs.fields = 'icon,images,name,width,height,created_time'\n    }\n\n    this.client\n      .get(`https://graph.facebook.com/${path}`)\n      .qs(qs)\n      .auth(token)\n      .request((err, resp, body) => {\n        if (err || resp.statusCode !== 200) {\n          err = this._error(err, resp)\n          logger.error(err, 'provider.facebook.list.error')\n          return done(err)\n        }\n        this._getUsername(token, (err, username) => {\n          if (err) {\n            done(err)\n          } else {\n            done(null, this.adaptData(body, username, directory, query))\n          }\n        })\n      })\n  }\n\n  _getUsername (token, done) {\n    this.client\n      .get('me')\n      .qs({ fields: 'email' })\n      .auth(token)\n      .request((err, resp, body) => {\n        if (err || resp.statusCode !== 200) {\n          err = this._error(err, resp)\n          logger.error(err, 'provider.facebook.user.error')\n          return done(err)\n        }\n        done(null, body.email)\n      })\n  }\n\n  _getMediaUrl (body) {\n    const sortedImages = adapter.sortImages(body.images)\n    return sortedImages[sortedImages.length - 1].source\n  }\n\n  async download ({ id, token }) {\n    try {\n      const body1 = await new Promise((resolve, reject) => (\n        this.client\n          .get(`https://graph.facebook.com/${id}`)\n          .qs({ fields: 'images' })\n          .auth(token)\n          .request((err, resp, body) => {\n            if (err || resp.statusCode !== 200) {\n              err = this._error(err, resp)\n              logger.error(err, 'provider.facebook.download.error')\n              reject(err)\n              return\n            }\n            resolve(body)\n          })\n      ))\n\n      const url = this._getMediaUrl(body1)\n      const req = request(url)\n      return await requestStream(req, async (res) => this._error(null, res))\n    } catch (err) {\n      logger.error(err, 'provider.facebook.download.url.error')\n      throw err\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async thumbnail () {\n    // not implementing this because a public thumbnail from facebook will be used instead\n    logger.error('call to thumbnail is not implemented', 'provider.facebook.thumbnail.error')\n    throw new Error('call to thumbnail is not implemented')\n  }\n\n  _size ({ id, token }, done) {\n    return this.client\n      .get(`https://graph.facebook.com/${id}`)\n      .qs({ fields: 'images' })\n      .auth(token)\n      .request((err, resp, body) => {\n        if (err || resp.statusCode !== 200) {\n          err = this._error(err, resp)\n          logger.error(err, 'provider.facebook.size.error')\n          return done(err)\n        }\n\n        getURLMeta(this._getMediaUrl(body), true)\n          .then(({ size }) => done(null, size))\n          .catch((err2) => {\n            logger.error(err2, 'provider.facebook.size.error')\n            done(err2)\n          })\n      })\n  }\n\n  _logout ({ token }, done) {\n    return this.client\n      .delete('me/permissions')\n      .auth(token)\n      .request((err, resp) => {\n        if (err || resp.statusCode !== 200) {\n          logger.error(err, 'provider.facebook.logout.error')\n          done(this._error(err, resp))\n          return\n        }\n        done(null, { revoked: true })\n      })\n  }\n\n  adaptData (res, username, directory, currentQuery) {\n    const data = { username, items: [] }\n    const items = adapter.getItemSubList(res)\n    items.forEach((item) => {\n      data.items.push({\n        isFolder: adapter.isFolder(item),\n        icon: adapter.getItemIcon(item),\n        name: adapter.getItemName(item),\n        mimeType: adapter.getMimeType(item),\n        size: null,\n        id: adapter.getItemId(item),\n        thumbnail: adapter.getItemThumbnailUrl(item),\n        requestPath: adapter.getItemRequestPath(item),\n        modifiedDate: adapter.getItemModifiedDate(item),\n      })\n    })\n\n    data.nextPagePath = adapter.getNextPagePath(res, currentQuery, directory)\n    return data\n  }\n\n  _error (err, resp) {\n    if (resp) {\n      if (resp.body && resp.body.error.code === 190) {\n        // Invalid OAuth 2.0 Access Token\n        return new ProviderAuthError()\n      }\n\n      const fallbackMessage = `request to ${this.authProvider} returned ${resp.statusCode}`\n      const msg = resp.body && resp.body.error ? resp.body.error.message : fallbackMessage\n      return new ProviderApiError(msg, resp.statusCode)\n    }\n\n    return err\n  }\n}\n\nFacebook.version = 2\n\nFacebook.prototype.list = promisify(Facebook.prototype._list)\nFacebook.prototype.size = promisify(Facebook.prototype._size)\nFacebook.prototype.logout = promisify(Facebook.prototype._logout)\n\nmodule.exports = Facebook\n", "const request = require('request')\nconst purest = require('purest')({ request })\nconst { promisify } = require('util')\n\nconst Provider = require('../../Provider')\nconst { getURLMeta } = require('../../../helpers/request')\nconst logger = require('../../../logger')\nconst adapter = require('./adapter')\nconst { ProviderApiError, ProviderAuthError } = require('../../error')\nconst { requestStream } = require('../../../helpers/utils')\n\n/**\n * Adapter for API https://developers.facebook.com/docs/instagram-api/overview\n */\nclass Instagram extends Provider {\n  constructor (options) {\n    super(options)\n    this.authProvider = Instagram.authProvider\n    this.client = purest({\n      ...options,\n      provider: Instagram.authProvider,\n    })\n  }\n\n  static getExtraConfig () {\n    return {\n      protocol: 'https',\n      scope: ['user_profile', 'user_media'],\n    }\n  }\n\n  static get authProvider () {\n    return 'instagram'\n  }\n\n  _list ({ directory, token, query = { cursor: null } }, done) {\n    const qs = {\n      fields: 'id,media_type,thumbnail_url,media_url,timestamp,children{media_type,media_url,thumbnail_url,timestamp}',\n    }\n\n    if (query.cursor) {\n      qs.after = query.cursor\n    }\n\n    this.client\n      .get('https://graph.instagram.com/me/media')\n      .qs(qs)\n      .auth(token)\n      .request((err, resp, body) => {\n        if (err || resp.statusCode !== 200) {\n          err = this._error(err, resp)\n          logger.error(err, 'provider.instagram.list.error')\n          return done(err)\n        }\n        this._getUsername(token, (err, username) => {\n          if (err) done(err)\n          else done(null, this.adaptData(body, username, directory, query))\n        })\n      })\n  }\n\n  _getUsername (token, done) {\n    this.client\n      .get('https://graph.instagram.com/me')\n      .qs({ fields: 'username' })\n      .auth(token)\n      .request((err, resp, body) => {\n        if (err || resp.statusCode !== 200) {\n          err = this._error(err, resp)\n          logger.error(err, 'provider.instagram.user.error')\n          return done(err)\n        }\n        done(null, body.username)\n      })\n  }\n\n  async download ({ id, token }) {\n    try {\n      const body1 = await new Promise((resolve, reject) => (\n        this.client\n          .get(`https://graph.instagram.com/${id}`)\n          .qs({ fields: 'media_url' })\n          .auth(token)\n          .request((err, resp, body) => {\n            if (err || resp.statusCode !== 200) {\n              err = this._error(err, resp)\n              logger.error(err, 'provider.instagram.download.error')\n              reject(err)\n              return\n            }\n            resolve(body)\n          })\n      ))\n\n      const req = request(body1.media_url)\n      return await requestStream(req, async (res) => this._error(null, res))\n    } catch (err) {\n      logger.error(err, 'provider.instagram.download.url.error')\n      throw err\n    }\n  }\n\n  async thumbnail () {\n    // not implementing this because a public thumbnail from instagram will be used instead\n    logger.error('call to thumbnail is not implemented', 'provider.instagram.thumbnail.error')\n    throw new Error('call to thumbnail is not implemented')\n  }\n\n  _size ({ id, token }, done) {\n    return this.client\n      .get(`https://graph.instagram.com/${id}`)\n      .qs({ fields: 'media_url' })\n      .auth(token)\n      .request((err, resp, body) => {\n        if (err || resp.statusCode !== 200) {\n          err = this._error(err, resp)\n          logger.error(err, 'provider.instagram.size.error')\n          return done(err)\n        }\n\n        getURLMeta(body.media_url, true)\n          .then(({ size }) => done(null, size))\n          .catch((err2) => {\n            logger.error(err2, 'provider.instagram.size.error')\n            done(err2)\n          })\n      })\n  }\n\n  async logout () {\n    // access revoke is not supported by Instagram's API\n    return { revoked: false, manual_revoke_url: 'https://www.instagram.com/accounts/manage_access/' }\n  }\n\n  adaptData (res, username, directory, currentQuery) {\n    const data = { username, items: [] }\n    const items = adapter.getItemSubList(res)\n    items.forEach((item, i) => {\n      data.items.push({\n        isFolder: adapter.isFolder(item),\n        icon: adapter.getItemIcon(item),\n        name: adapter.getItemName(item, i),\n        mimeType: adapter.getMimeType(item),\n        id: adapter.getItemId(item),\n        size: null,\n        thumbnail: adapter.getItemThumbnailUrl(item),\n        requestPath: adapter.getItemRequestPath(item),\n        modifiedDate: adapter.getItemModifiedDate(item),\n      })\n    })\n\n    data.nextPagePath = adapter.getNextPagePath(res, currentQuery, directory)\n    return data\n  }\n\n  _error (err, resp) {\n    if (resp) {\n      if (resp.body && resp.body.error.code === 190) {\n        // Invalid OAuth 2.0 Access Token\n        return new ProviderAuthError()\n      }\n\n      const fallbackMessage = `request to ${this.authProvider} returned ${resp.statusCode}`\n      const msg = resp.body && resp.body.error ? resp.body.error.message : fallbackMessage\n      return new ProviderApiError(msg, resp.statusCode)\n    }\n\n    return err\n  }\n}\n\nInstagram.version = 2\n\nInstagram.prototype.list = promisify(Instagram.prototype._list)\nInstagram.prototype.size = promisify(Instagram.prototype._size)\n\nmodule.exports = Instagram\n", "const request = require('request')\nconst { promisify } = require('util')\n\nconst SearchProvider = require('../SearchProvider')\nconst { getURLMeta } = require('../../helpers/request')\nconst logger = require('../../logger')\nconst adapter = require('./adapter')\nconst { ProviderApiError } = require('../error')\nconst { requestStream } = require('../../helpers/utils')\n\nconst BASE_URL = 'https://api.unsplash.com'\n\nfunction adaptData (body, currentQuery) {\n  const pagesCount = body.total_pages\n  const currentPage = Number(currentQuery.cursor || 1)\n  const hasNextPage = currentPage < pagesCount\n  const subList = adapter.getItemSubList(body) || []\n\n  return {\n    searchedFor: currentQuery.q,\n    username: null,\n    items: subList.map((item) => ({\n      isFolder: adapter.isFolder(item),\n      icon: adapter.getItemIcon(item),\n      name: adapter.getItemName(item),\n      mimeType: adapter.getMimeType(item),\n      id: adapter.getItemId(item),\n      thumbnail: adapter.getItemThumbnailUrl(item),\n      requestPath: adapter.getItemRequestPath(item),\n      modifiedDate: adapter.getItemModifiedDate(item),\n      author: adapter.getAuthor(item),\n      size: null,\n    })),\n    nextPageQuery: hasNextPage\n      ? adapter.getNextPageQuery(currentQuery)\n      : null,\n  }\n}\n\n/**\n * Adapter for API https://api.unsplash.com\n */\nclass Unsplash extends SearchProvider {\n  _list ({ token, query = { cursor: null, q: null } }, done) {\n    const reqOpts = {\n      url: `${BASE_URL}/search/photos`,\n      method: 'GET',\n      json: true,\n      qs: {\n        per_page: 40,\n        query: query.q,\n      },\n      headers: {\n        Authorization: `Client-ID ${token}`,\n      },\n    }\n\n    if (query.cursor) {\n      reqOpts.qs.page = query.cursor\n    }\n\n    request(reqOpts, (err, resp, body) => {\n      if (err || resp.statusCode !== 200) {\n        const error = this.error(err, resp)\n        logger.error(error, 'provider.unsplash.list.error')\n        return done(error)\n      }\n      return done(null, adaptData(body, query))\n    })\n  }\n\n  async download ({ id, token }) {\n    try {\n      const reqOpts = {\n        method: 'GET',\n        json: true,\n        headers: {\n          Authorization: `Client-ID ${token}`,\n        },\n      }\n\n      const body = await new Promise((resolve, reject) => (\n        request({ ...reqOpts, url: `${BASE_URL}/photos/${id}` }, (err, resp, body2) => {\n          if (err || resp.statusCode !== 200) {\n            const err2 = this.error(err, resp)\n            logger.error(err, 'provider.unsplash.download.error')\n            reject(err2)\n            return\n          }\n          resolve(body2)\n        })\n      ))\n\n      const req = request.get(body.links.download)\n      const stream = await requestStream(req, async (res) => this.error(null, res))\n\n      // To attribute the author of the image, we call the `download_location`\n      // endpoint to increment the download count on Unsplash.\n      // https://help.unsplash.com/en/articles/2511258-guideline-triggering-a-download\n      request({ ...reqOpts, url: body.links.download_location }, (err, resp) => {\n        if (err || resp.statusCode !== 200) {\n          const err2 = this.error(err, resp)\n          logger.error(err2, 'provider.unsplash.download.location.error')\n        }\n      })\n\n      return stream\n    } catch (err) {\n      logger.error(err, 'provider.unsplash.download.url.error')\n      throw err\n    }\n  }\n\n  _size ({ id, token }, done) {\n    const reqOpts = {\n      url: `${BASE_URL}/photos/${id}`,\n      method: 'GET',\n      json: true,\n      headers: {\n        Authorization: `Client-ID ${token}`,\n      },\n    }\n\n    request(reqOpts, (err, resp, body) => {\n      if (err || resp.statusCode !== 200) {\n        const error = this.error(err, resp)\n        logger.error(error, 'provider.unsplash.size.error')\n        done(error)\n        return\n      }\n\n      getURLMeta(body.links.download, true)\n        .then(({ size }) => done(null, size))\n        .catch((err2) => {\n          logger.error(err2, 'provider.unsplash.size.error')\n          done(err2)\n        })\n    })\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  error (err, resp) {\n    if (resp) {\n      const fallbackMessage = `request to Unsplash returned ${resp.statusCode}`\n      const msg = resp.body && resp.body.errors ? `${resp.body.errors}` : fallbackMessage\n      return new ProviderApiError(msg, resp.statusCode)\n    }\n\n    return err\n  }\n}\n\nUnsplash.version = 2\n\nUnsplash.prototype.list = promisify(Unsplash.prototype._list)\nUnsplash.prototype.size = promisify(Unsplash.prototype._size)\n\nmodule.exports = Unsplash\n", "const fs = require('fs')\nconst merge = require('lodash.merge')\nconst stripIndent = require('common-tags/lib/stripIndent')\nconst crypto = require('crypto')\nconst utils = require('../server/helpers/utils')\nconst logger = require('../server/logger')\n// @ts-ignore\nconst { version } = require('../../package.json')\n\n/**\n * Reads all companion configuration set via environment variables\n * and via the config file path\n *\n * @returns {object}\n */\nexports.getCompanionOptions = (options = {}) => {\n  return merge({}, getConfigFromEnv(), getConfigFromFile(), options)\n}\n\n/**\n * Loads the config from environment variables\n *\n * @returns {object}\n */\nconst getConfigFromEnv = () => {\n  const uploadUrls = process.env.COMPANION_UPLOAD_URLS\n  const domains = process.env.COMPANION_DOMAINS || process.env.COMPANION_DOMAIN || null\n  const validHosts = domains ? domains.split(',') : []\n\n  return {\n    providerOptions: {\n      drive: {\n        key: process.env.COMPANION_GOOGLE_KEY,\n        secret: getSecret('COMPANION_GOOGLE_SECRET'),\n        credentialsURL: process.env.COMPANION_GOOGLE_KEYS_ENDPOINT,\n      },\n      dropbox: {\n        key: process.env.COMPANION_DROPBOX_KEY,\n        secret: getSecret('COMPANION_DROPBOX_SECRET'),\n        credentialsURL: process.env.COMPANION_DROPBOX_KEYS_ENDPOINT,\n      },\n      box: {\n        key: process.env.COMPANION_BOX_KEY,\n        secret: getSecret('COMPANION_BOX_SECRET'),\n      },\n      instagram: {\n        key: process.env.COMPANION_INSTAGRAM_KEY,\n        secret: getSecret('COMPANION_INSTAGRAM_SECRET'),\n        credentialsURL: process.env.COMPANION_INSTAGRAM_KEYS_ENDPOINT,\n      },\n      facebook: {\n        key: process.env.COMPANION_FACEBOOK_KEY,\n        secret: getSecret('COMPANION_FACEBOOK_SECRET'),\n        credentialsURL: process.env.COMPANION_FACEBOOK_KEYS_ENDPOINT,\n      },\n      onedrive: {\n        key: process.env.COMPANION_ONEDRIVE_KEY,\n        secret: getSecret('COMPANION_ONEDRIVE_SECRET'),\n        credentialsURL: process.env.COMPANION_ONEDRIVE_KEYS_ENDPOINT,\n      },\n      zoom: {\n        key: process.env.COMPANION_ZOOM_KEY,\n        secret: getSecret('COMPANION_ZOOM_SECRET'),\n        verificationToken: getSecret('COMPANION_ZOOM_VERIFICATION_TOKEN'),\n        credentialsURL: process.env.COMPANION_ZOOM_KEYS_ENDPOINT,\n      },\n      searchProviders: {\n        unsplash: {\n          key: process.env.COMPANION_UNSPLASH_KEY,\n          secret: process.env.COMPANION_UNSPLASH_SECRET,\n        },\n      },\n      s3: {\n        key: process.env.COMPANION_AWS_KEY,\n        secret: getSecret('COMPANION_AWS_SECRET'),\n        bucket: process.env.COMPANION_AWS_BUCKET,\n        endpoint: process.env.COMPANION_AWS_ENDPOINT,\n        region: process.env.COMPANION_AWS_REGION,\n        useAccelerateEndpoint:\n          process.env.COMPANION_AWS_USE_ACCELERATE_ENDPOINT === 'true',\n        expires: parseInt(process.env.COMPANION_AWS_EXPIRES || '300', 10),\n        acl: process.env.COMPANION_AWS_ACL || 'public-read',\n      },\n    },\n    server: {\n      host: process.env.COMPANION_DOMAIN,\n      protocol: process.env.COMPANION_PROTOCOL,\n      path: process.env.COMPANION_PATH,\n      implicitPath: process.env.COMPANION_IMPLICIT_PATH,\n      oauthDomain: process.env.COMPANION_OAUTH_DOMAIN,\n      validHosts,\n    },\n    periodicPingUrls: process.env.COMPANION_PERIODIC_PING_URLS ? process.env.COMPANION_PERIODIC_PING_URLS.split(',') : [],\n    periodicPingInterval: process.env.COMPANION_PERIODIC_PING_INTERVAL\n      ? parseInt(process.env.COMPANION_PERIODIC_PING_INTERVAL, 10) : undefined,\n    periodicPingStaticPayload: process.env.COMPANION_PERIODIC_PING_STATIC_JSON_PAYLOAD\n      ? JSON.parse(process.env.COMPANION_PERIODIC_PING_STATIC_JSON_PAYLOAD) : undefined,\n    periodicPingCount: process.env.COMPANION_PERIODIC_PING_COUNT\n      ? parseInt(process.env.COMPANION_PERIODIC_PING_COUNT, 10) : undefined,\n    filePath: process.env.COMPANION_DATADIR,\n    redisUrl: process.env.COMPANION_REDIS_URL,\n    // adding redisOptions to keep all companion options easily visible\n    //  redisOptions refers to https://www.npmjs.com/package/redis#options-object-properties\n    redisOptions: {},\n    sendSelfEndpoint: process.env.COMPANION_SELF_ENDPOINT,\n    uploadUrls: uploadUrls ? uploadUrls.split(',') : null,\n    secret: getSecret('COMPANION_SECRET') || generateSecret(),\n    preAuthSecret: getSecret('COMPANION_PREAUTH_SECRET') || generateSecret(),\n    allowLocalUrls: process.env.COMPANION_ALLOW_LOCAL_URLS === 'true',\n    // cookieDomain is kind of a hack to support distributed systems. This should be improved but we never got so far.\n    cookieDomain: process.env.COMPANION_COOKIE_DOMAIN,\n    multipleInstances: true,\n    streamingUpload: process.env.COMPANION_STREAMING_UPLOAD === 'true',\n    maxFileSize: process.env.COMPANION_MAX_FILE_SIZE ? parseInt(process.env.COMPANION_MAX_FILE_SIZE, 10) : undefined,\n    chunkSize: process.env.COMPANION_CHUNK_SIZE ? parseInt(process.env.COMPANION_CHUNK_SIZE, 10) : undefined,\n  }\n}\n\n/**\n * Tries to read the secret from a file if the according environment variable is set.\n * Otherwise it falls back to the standard secret environment variable.\n *\n * @param {string} baseEnvVar\n *\n * @returns {string}\n */\nconst getSecret = (baseEnvVar) => {\n  const secretFile = process.env[`${baseEnvVar}_FILE`]\n  return secretFile\n    ? fs.readFileSync(secretFile).toString()\n    : process.env[baseEnvVar]\n}\n\n/**\n * Auto-generates server secret\n *\n * @returns {string}\n */\nconst generateSecret = () => {\n  logger.warn('auto-generating server secret because none was specified', 'startup.secret')\n  return crypto.randomBytes(64).toString('hex')\n}\n\n/**\n * Loads the config from a file and returns it as an object\n *\n * @returns {object}\n */\nconst getConfigFromFile = () => {\n  const path = getConfigPath()\n  if (!path) return {}\n\n  const rawdata = fs.readFileSync(getConfigPath())\n  // @ts-ignore\n  return JSON.parse(rawdata)\n}\n\n/**\n * Returns the config path specified via cli arguments\n *\n * @returns {string}\n */\nconst getConfigPath = () => {\n  let configPath\n\n  for (let i = process.argv.length - 1; i >= 0; i--) {\n    const isConfigFlag = process.argv[i] === '-c' || process.argv[i] === '--config'\n    const flagHasValue = i + 1 <= process.argv.length\n    if (isConfigFlag && flagHasValue) {\n      configPath = process.argv[i + 1]\n      break\n    }\n  }\n\n  return configPath\n}\n\n/**\n *\n * @param {string} url\n */\nexports.hasProtocol = (url) => {\n  return url.startsWith('http://') || url.startsWith('https://')\n}\n\nexports.buildHelpfulStartupMessage = (companionOptions) => {\n  const buildURL = utils.getURLBuilder(companionOptions)\n  const callbackURLs = []\n  Object.keys(companionOptions.providerOptions).forEach((providerName) => {\n    // s3 does not need redirect_uris\n    if (providerName === 's3') {\n      return\n    }\n\n    callbackURLs.push(buildURL(`/connect/${providerName}/redirect`, true))\n  })\n\n  return stripIndent`\n    Welcome to Companion v${version}\n    ===================================\n\n    Congratulations on setting up Companion! Thanks for joining our cause, you have taken\n    the first step towards the future of file uploading! We\n    hope you are as excited about this as we are!\n\n    While you did an awesome job on getting Companion running, this is just the welcome\n    message, so let's talk about the places that really matter:\n\n    - Be sure to add ${callbackURLs.join(', ')} as your Oauth redirect uris on their corresponding developer interfaces.\n    - The URL ${buildURL('/metrics', true)} is available for  statistics to keep Companion running smoothly\n    - https://github.com/transloadit/uppy/issues - report your bugs here\n\n    So quit lollygagging, start uploading and experience the future!\n  `\n}\n", "/* global jest:false, test:false, expect:false, describe:false */\n\nconst mockOauthState = require('../mockoauthstate')()\nconst { version } = require('../../package.json')\n\njest.mock('tus-js-client')\njest.mock('purest')\njest.mock('../../src/server/helpers/oauth-state', () => ({\n  ...jest.requireActual('../../src/server/helpers/oauth-state'),\n  ...mockOauthState,\n}))\n\nconst nock = require('nock')\nconst request = require('supertest')\nconst tokenService = require('../../src/server/helpers/jwt')\nconst { getServer } = require('../mockserver')\n\nconst authServer = getServer()\nconst authData = {\n  dropbox: 'token value',\n  box: 'token value',\n  drive: 'token value',\n}\nconst token = tokenService.generateEncryptedToken(authData, process.env.COMPANION_SECRET)\nconst OAUTH_STATE = 'some-cool-nice-encrytpion'\n\ndescribe('validate upload data', () => {\n  test('invalid upload protocol gets rejected', () => {\n    return request(authServer)\n      .post('/drive/get/DUMMY-FILE-ID')\n      .set('uppy-auth-token', token)\n      .set('Content-Type', 'application/json')\n      .send({\n        endpoint: 'http://url.myendpoint.com/files',\n        protocol: 'tusInvalid',\n      })\n      .expect(400)\n      .then((res) => expect(res.body.message).toBe('unsupported protocol specified'))\n  })\n\n  test('invalid upload fieldname gets rejected', () => {\n    return request(authServer)\n      .post('/drive/get/DUMMY-FILE-ID')\n      .set('uppy-auth-token', token)\n      .set('Content-Type', 'application/json')\n      .send({\n        endpoint: 'http://url.myendpoint.com/files',\n        protocol: 'tus',\n        fieldname: 390,\n      })\n      .expect(400)\n      .then((res) => expect(res.body.message).toBe('fieldname must be a string'))\n  })\n\n  test('invalid upload metadata gets rejected', () => {\n    return request(authServer)\n      .post('/drive/get/DUMMY-FILE-ID')\n      .set('uppy-auth-token', token)\n      .set('Content-Type', 'application/json')\n      .send({\n        endpoint: 'http://url.myendpoint.com/files',\n        protocol: 'tus',\n        metadata: 'I am a string instead of object',\n      })\n      .expect(400)\n      .then((res) => expect(res.body.message).toBe('metadata must be an object'))\n  })\n\n  test('invalid upload headers get rejected', () => {\n    return request(authServer)\n      .post('/drive/get/DUMMY-FILE-ID')\n      .set('uppy-auth-token', token)\n      .set('Content-Type', 'application/json')\n      .send({\n        endpoint: 'http://url.myendpoint.com/files',\n        protocol: 'tus',\n        headers: 'I am a string instead of object',\n      })\n      .expect(400)\n      .then((res) => expect(res.body.message).toBe('headers must be an object'))\n  })\n\n  test('invalid upload HTTP Method gets rejected', () => {\n    return request(authServer)\n      .post('/drive/get/DUMMY-FILE-ID')\n      .set('uppy-auth-token', token)\n      .set('Content-Type', 'application/json')\n      .send({\n        endpoint: 'http://url.myendpoint.com/files',\n        protocol: 'tus',\n        httpMethod: 'DELETE',\n      })\n      .expect(400)\n      .then((res) => expect(res.body.message).toBe('unsupported HTTP METHOD specified'))\n  })\n\n  test('valid upload data is allowed - tus', () => {\n    return request(authServer)\n      .post('/drive/get/DUMMY-FILE-ID')\n      .set('uppy-auth-token', token)\n      .set('Content-Type', 'application/json')\n      .send({\n        endpoint: 'http://url.myendpoint.com/files',\n        protocol: 'tus',\n        httpMethod: 'POST',\n        headers: {\n          customheader: 'header value',\n        },\n        metadata: {\n          mymetadata: 'matadata value',\n        },\n        fieldname: 'uploadField',\n      })\n      .expect(200)\n  })\n\n  test('valid upload data is allowed - s3-multipart', () => {\n    return request(authServer)\n      .post('/drive/get/DUMMY-FILE-ID')\n      .set('uppy-auth-token', token)\n      .set('Content-Type', 'application/json')\n      .send({\n        endpoint: 'http://url.myendpoint.com/files',\n        protocol: 's3-multipart',\n        httpMethod: 'PUT',\n        headers: {\n          customheader: 'header value',\n        },\n        metadata: {\n          mymetadata: 'matadata value',\n        },\n        fieldname: 'uploadField',\n      })\n      .expect(200)\n  })\n})\n\ndescribe('handle main oauth redirect', () => {\n  const serverWithMainOauth = getServer({\n    COMPANION_OAUTH_DOMAIN: 'localhost:3040',\n  })\n  test('redirect to a valid uppy instance', () => {\n    return request(serverWithMainOauth)\n      .get(`/dropbox/redirect?state=${OAUTH_STATE}`)\n      .set('uppy-auth-token', token)\n      .expect(302)\n      .expect('Location', `http://localhost:3020/connect/dropbox/callback?state=${OAUTH_STATE}`)\n  })\n\n  test('do not redirect to invalid uppy instances', () => {\n    const state = 'state-with-invalid-instance-url' // see mock ../../src/server/helpers/oauth-state above\n    return request(serverWithMainOauth)\n      .get(`/dropbox/redirect?state=${state}`)\n      .set('uppy-auth-token', token)\n      .expect(400)\n  })\n})\n\nit('periodically pings', (done) => {\n  nock('http://localhost').post('/ping', (body) => (\n    body.some === 'value'\n    && body.version === version\n    && typeof body.processId === 'string'\n  )).reply(200, () => done())\n\n  getServer({\n    COMPANION_PERIODIC_PING_URLS: 'http://localhost/ping',\n    COMPANION_PERIODIC_PING_STATIC_JSON_PAYLOAD: '{\"some\": \"value\"}',\n    COMPANION_PERIODIC_PING_INTERVAL: '10',\n    COMPANION_PERIODIC_PING_COUNT: '1',\n  })\n}, 1000)\n\nit('respects allowLocalUrls', async () => {\n  const server = getServer()\n  const url = 'http://localhost/'\n\n  let res\n\n  res = await request(server)\n    .post('/url/meta')\n    .send({ url })\n    .expect(400)\n\n  expect(res.body).toEqual({ error: 'Invalid request body' })\n\n  res = await request(server)\n    .post('/url/get')\n    .send({\n      fileId: url,\n      metadata: {},\n      endpoint: 'http://url.myendpoint.com/files',\n      protocol: 'tus',\n      size: null,\n      url,\n    })\n    .expect(400)\n\n  expect(res.body).toEqual({ error: 'Invalid request body' })\n}, 1000)\n\nafterAll(() => {\n  nock.cleanAll()\n  nock.restore()\n})\n", "/* global jest:false */\nconst express = require('express')\nconst session = require('express-session')\n\nconst defaultEnv = {\n  NODE_ENV: 'test',\n  COMPANION_PORT: 3020,\n  COMPANION_DOMAIN: 'localhost:3020',\n  COMPANION_SELF_ENDPOINT: 'localhost:3020',\n  COMPANION_HIDE_METRICS: 'false',\n  COMPANION_HIDE_WELCOME: 'false',\n\n  COMPANION_STREAMING_UPLOAD: 'true',\n  COMPANION_ALLOW_LOCAL_URLS : 'false',\n\n  COMPANION_PROTOCOL: 'http',\n  COMPANION_DATADIR: './test/output',\n  COMPANION_SECRET: 'secret',\n\n  COMPANION_DROPBOX_KEY: 'dropbox_key',\n  COMPANION_DROPBOX_SECRET: 'dropbox_secret',\n\n  COMPANION_BOX_KEY: 'box_key',\n  COMPANION_BOX_SECRET: 'box_secret',\n\n  COMPANION_GOOGLE_KEY: 'google_key',\n  COMPANION_GOOGLE_SECRET: 'google_secret',\n\n  COMPANION_INSTAGRAM_KEY: 'instagram_key',\n  COMPANION_INSTAGRAM_SECRET: 'instagram_secret',\n\n  COMPANION_ZOOM_KEY: 'zoom_key',\n  COMPANION_ZOOM_SECRET: 'zoom_secret',\n  COMPANION_ZOOM_VERIFICATION_TOKEN: 'zoom_verfication_token',\n\n  COMPANION_PATH: '',\n}\n\nfunction updateEnv (env) {\n  Object.keys(env).forEach((key) => {\n    process.env[key] = env[key]\n  })\n}\n\nmodule.exports.setDefaultEnv = () => updateEnv(defaultEnv)\n\nmodule.exports.getServer = (extraEnv) => {\n  const env = {\n    ...defaultEnv,\n    ...extraEnv,\n  }\n\n  updateEnv(env)\n\n  // delete from cache to force the server to reload companionOptions from the new env vars\n  jest.resetModules()\n  const standalone = require('../src/standalone')\n  const authServer = express()\n\n  authServer.use(session({ secret: 'grant', resave: true, saveUninitialized: true }))\n  authServer.all('*/callback', (req, res, next) => {\n    req.session.grant = {\n      response: { access_token: 'fake token' },\n    }\n    next()\n  })\n  authServer.all(['*/send-token', '*/redirect'], (req, res, next) => {\n    req.session.grant = { dynamic: { state: req.query.state || 'non-empty-value' } }\n    next()\n  })\n\n  const { app } = standalone()\n  authServer.use(app)\n  return authServer\n}\n", "---\ntype: docs\norder: 2\ntitle: \"Companion\"\nmodule: \"@uppy/companion\"\npermalink: docs/companion/\nalias: docs/server/\ncategory: \"Docs\"\ntagline: \"Server-side proxy that enables remote sources like Instagram, Google Drive, and Dropbox\"\n---\n\nDrag and drop, webcam, basic file manipulation (adding metadata, for example) and uploading via tus-resumable uploads or XHR/Multipart are all possible using only the Uppy client module.\n\n<!--retext-simplify ignore however-->\n\nHowever, if you add [Companion](https://github.com/transloadit/uppy/tree/main/packages/@uppy/companion) to the mix, your users will be able to select files from remote sources, such as Instagram, Google Drive and Dropbox, bypassing the client (so a 5 GB video isn\u2019t eating into your users\u2019 data plans), and then uploaded to the final destination. Files are removed from Companion after an upload is complete, or after a reasonable timeout. Access tokens also don\u2019t stick around for long, for security reasons.\n\nCompanion handles the server-to-server communication between your server and file storage providers such as Google Drive, Dropbox, Instagram, etc. Note that you can **not** upload files **to** Companion, it only handles the third party integrations.\n\n## Supported providers\n\nAs of now, Companion is integrated to work with:\n\n* Google Drive (name `drive`) - [Set up instructions](/docs/google-drive/#Setting-Up)\n* Dropbox (name `dropbox`) - [Set up instructions](/docs/dropbox/#Setting-Up)\n* Box (name `box`) - [Set up instructions](/docs/box/#Setting-Up)\n* Instagram (name `instagram`)\n* Facebook (name `facebook`)\n* OneDrive (name `onedrive`)\n* Remote URLs (name `url`)\n* Amazon S3 (name `s3`)\n\n## Installation\n\nInstall from NPM:\n\n```bash\nnpm install @uppy/companion\n```\n\nIf you don\u2019t have a Node.js project with a `package.json` you might want to install/run Companion globally like so: `npm install -g @uppy/companion`.\n\n### Prerequisite\n\nSince v2, you now need to be running `node.js >= v10.20.1` to use Companion. Please see [Migrating v1 to v2](#Migrating-v1-to-v2)\n\nUnfortunately, Windows is not a supported platform right now. It may work, and we\u2019re happy to accept improvements in this area, but we can\u2019t provide support.\n\n## Usage\n\n<!--retext-simplify ignore already-existing-->\n\nCompanion may either be used as a pluggable express app, which you plug into your already existing server, or it may also be run as a standalone server:\n\n### Plugging into an existing express server\n\nTo plug Companion into an existing server, call its `.app` method, passing in an [options](#Options) object as a parameter. This returns a server instance that you can mount on a subpath in your Express or app.\n\n```js\nimport express from 'express'\nimport bodyParser from 'body-parser'\nimport session from 'express-session'\nimport companion from '@uppy/companion'\n\nconst app = express()\n\n// Companion requires body-parser and express-session middleware.\n// You can add it like this if you use those throughout your app.\n//\n// If you are using something else in your app, you can add these\n// middlewares in the same subpath as Companion instead.\napp.use(bodyParser.json())\napp.use(session({ secret: 'some secrety secret' }))\n\nconst options = {\n  providerOptions: {\n    drive: {\n      key: 'GOOGLE_DRIVE_KEY',\n      secret: 'GOOGLE_DRIVE_SECRET',\n    },\n  },\n  server: {\n    host: 'localhost:3020',\n    protocol: 'http',\n    // This MUST match the path you specify in `app.use()` below:\n    path: '/companion',\n  },\n  filePath: '/path/to/folder/',\n}\n\napp.use('/companion', companion.app(options))\n```\n\nSee [Options](#Options) for valid configuration options.\n\nThen, add the Companion WebSocket server for realtime upload progress, using the `companion.socket` function:\n\n```js\nconst server = app.listen(PORT)\n\ncompanion.socket(server)\n```\n\nThis takes your `server` instance as an argument.\n\n### Running as a standalone server\n\n> Please make sure that the required environment variables are set before running/using Companion as a standalone server. See [Configure Standalone](#Configuring-a-standalone-server) for the variables required.\n\nSet environment variables first:\n\n```bash\nexport COMPANION_SECRET=\"shh!Issa Secret!\"\nexport COMPANION_DOMAIN=\"YOUR SERVER DOMAIN\"\nexport COMPANION_DATADIR=\"PATH/TO/DOWNLOAD/DIRECTORY\"\n```\n\nAnd then run:\n\n```bash\ncompanion\n```\n\nYou can also pass in the path to your JSON config file, like so:\n\n```bash\ncompanion --config /path/to/uppyconf.json\n```\n\nPlease see [Options](#Options) for possible options.\n\n#### Configuring a standalone server\n\nTo run Companion as a standalone server, you are required to set your Uppy [Options](#Options) via environment variables:\n\n```bash\n####### Mandatory variables ###########\n\n# any long set of random characters for the server session\nexport COMPANION_SECRET=\"shh!Issa Secret!\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_SECRET_FILE=\"PATH/TO/COMPANION/SECRET/FILE\"\n# corresponds to the server.host option\nexport COMPANION_DOMAIN=\"YOUR SERVER DOMAIN\"\n# corresponds to the filePath option\nexport COMPANION_DATADIR=\"PATH/TO/DOWNLOAD/DIRECTORY\"\n\n###### Optional variables ##########\n\n# corresponds to the server.protocol option, defaults to http\nexport COMPANION_PROTOCOL=\"YOUR SERVER PROTOCOL\"\n# the port on which to start the server, defaults to 3020\nexport COMPANION_PORT=\"YOUR SERVER PORT\"\n# corresponds to the server.port option, defaults to ''\nexport COMPANION_PATH=\"/SERVER/PATH/TO/WHERE/COMPANION/LIVES\"\n# disables the welcome page, defaults to false\nexport COMPANION_HIDE_WELCOME=\"true\"\n# disables the metrics page, defaults to false\nexport COMPANION_HIDE_METRICS=\"true\"\n\n# use this in place of COMPANION_PATH if the server path should not be\n# handled by the express.js app, but maybe by an external server configuration\n# instead (e.g Nginx).\nexport COMPANION_IMPLICIT_PATH=\"/SERVER/PATH/TO/WHERE/UPPY/SERVER/LIVES\"\n\n# comma-separated client hosts to whitlelist by the server\n# if neither this or COMPANION_CLIENT_ORIGINS_REGEX specified, the server would allow any host\nexport COMPANION_CLIENT_ORIGINS=\"localhost:3452,uppy.io\"\n\n# Like COMPANION_CLIENT_ORIGINS, but allows a single regex instead\n# (COMPANION_CLIENT_ORIGINS will be ignored if this is used and vice versa)\nexport COMPANION_CLIENT_ORIGINS_REGEX=\"https://.*\\.example\\.(com|eu)$\"\n\n# corresponds to the redisUrl option\n# this also enables Redis session storage if set\nexport COMPANION_REDIS_URL=\"REDIS URL\"\n\n# to enable Dropbox\nexport COMPANION_DROPBOX_KEY=\"YOUR DROPBOX KEY\"\nexport COMPANION_DROPBOX_SECRET=\"YOUR DROPBOX SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_DROPBOX_SECRET_FILE=\"PATH/TO/DROPBOX/SECRET/FILE\"\n\n# to enable Box\nexport COMPANION_BOX_KEY=\"YOUR BOX KEY\"\nexport COMPANION_BOX_SECRET=\"YOUR BOX SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_BOX_SECRET_FILE=\"PATH/TO/BOX/SECRET/FILE\"\n\n# to enable Google Drive\nexport COMPANION_GOOGLE_KEY=\"YOUR GOOGLE DRIVE KEY\"\nexport COMPANION_GOOGLE_SECRET=\"YOUR GOOGLE DRIVE SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_GOOGLE_SECRET_FILE=\"PATH/TO/GOOGLEDRIVE/SECRET/FILE\"\n\n# to enable Instagram\nexport COMPANION_INSTAGRAM_KEY=\"YOUR INSTAGRAM KEY\"\nexport COMPANION_INSTAGRAM_SECRET=\"YOUR INSTAGRAM SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_INSTAGRAM_SECRET_FILE=\"PATH/TO/INSTAGRAM/SECRET/FILE\"\n\n# to enable Facebook\nexport COMPANION_FACEBOOK_KEY=\"YOUR FACEBOOK KEY\"\nexport COMPANION_FACEBOOK_SECRET=\"YOUR FACEBOOK SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_FACEBOOK_SECRET_FILE=\"PATH/TO/FACEBOOK/SECRET/FILE\"\n\n# to enable Onedrive\nexport COMPANION_ONEDRIVE_KEY=\"YOUR ONEDRIVE KEY\"\nexport COMPANION_ONEDRIVE_SECRET=\"YOUR ONEDRIVE SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_ONEDRIVE_SECRET_FILE=\"PATH/TO/ONEDRIVE/SECRET/FILE\"\n\n# to enable Zoom\nexport COMPANION_ZOOM_KEY=\"YOUR ZOOM KEY\"\nexport COMPANION_ZOOM_SECRET=\"YOUR ZOOM SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_ZOOM_SECRET_FILE=\"PATH/TO/ZOOM/SECRET/FILE\"\n\n# to enable S3\nexport COMPANION_AWS_KEY=\"YOUR AWS KEY\"\nexport COMPANION_AWS_SECRET=\"YOUR AWS SECRET\"\n# specifying a secret file will override a directly set secret\nexport COMPANION_AWS_SECRET_FILE=\"PATH/TO/AWS/SECRET/FILE\"\nexport COMPANION_AWS_BUCKET=\"YOUR AWS S3 BUCKET\"\nexport COMPANION_AWS_REGION=\"AWS REGION\"\n# to enable S3 Transfer Acceleration (default: false)\nexport COMPANION_AWS_USE_ACCELERATE_ENDPOINT=\"false\"\n# to set X-Amz-Expires query param in presigned urls (in seconds, default: 300)\nexport COMPANION_AWS_EXPIRES=\"300\"\n# to set a canned ACL for uploaded objects: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl\nexport COMPANION_AWS_ACL=\"public-read\"\n\n# corresponds to the server.oauthDomain option\nexport COMPANION_OAUTH_DOMAIN=\"sub.domain.com\"\n# corresponds to the server.validHosts option\nexport COMPANION_DOMAINS=\"sub1.domain.com,sub2.domain.com,sub3.domain.com\"\n\n# corresponds to the sendSelfEndpoint option\nexport COMPANION_SELF_ENDPOINT=\"THIS SHOULD BE SAME AS YOUR DOMAIN + PATH\"\n\n# comma-separated URLs\n# corresponds to the uploadUrls option (comma-separated)\nexport COMPANION_UPLOAD_URLS=\"http://tusd.tusdemo.net/files/,https://tusd.tusdemo.net/files/\"\n\n# corresponds to the streamingUpload option\nexport COMPANION_STREAMING_UPLOAD=true\n\n# corresponds to the allowLocalUrls option\nexport COMPANION_ALLOW_LOCAL_URLS=false\n\n# corresponds to the maxFileSize option\nexport COMPANION_MAX_FILE_SIZE=\"100000000\"\n\n# corresponds to the chunkSize option\nexport COMPANION_CHUNK_SIZE=\"50000000\"\n\n# corresponds to the periodicPingUrls option (CSV string converted to array)\nexport COMPANION_PERIODIC_PING_URLS=\"https://example.com/ping1,https://example.com/ping2\"\n# corresponds to the periodicPingInterval option\nexport COMPANION_PERIODIC_PING_INTERVAL=60000\n# corresponds to the periodicPingStaticPayload option (JSON string)\nexport COMPANION_PERIODIC_PING_STATIC_JSON_PAYLOAD=\"{\\\"static\\\":\\\"data\\\"}\"\n```\n\nSee [env.example.sh](https://github.com/transloadit/uppy/blob/main/env.example.sh) for an example configuration script.\n\n### Options\n\n```javascript\nconst options = {\n  providerOptions: {\n    drive: {\n      key: '***',\n      secret: '***',\n    },\n    dropbox: {\n      key: '***',\n      secret: '***',\n    },\n    instagram: {\n      key: '***',\n      secret: '***',\n    },\n    facebook: {\n      key: '***',\n      secret: '***',\n    },\n    onedrive: {\n      key: '***',\n      secret: '***',\n    },\n    s3: {\n      getKey: (req, filename, metadata) => filename,\n      key: '***',\n      secret: '***',\n      bucket: 'bucket-name',\n      region: 'us-east-1',\n      useAccelerateEndpoint: false, // default: false,\n      expires: 3600, // default: 300 (5 minutes)\n      acl: 'private', // default: public-read\n    },\n  },\n  server: {\n    host: 'localhost:3020', // or yourdomain.com\n    protocol: 'http',\n  },\n  filePath: 'path/to/download/folder',\n  sendSelfEndpoint: 'localhost:3020',\n  secret: 'mysecret',\n  uploadUrls: ['https://myuploadurl.com', /^http:\\/\\/myuploadurl2.com\\//],\n  debug: true,\n  metrics: false,\n  streamingUpload: true,\n  allowLocalUrls: false,\n  maxFileSize: 100000000,\n  periodicPingUrls: [],\n  periodicPingInterval: 60000,\n  periodicPingStaticPayload: { static: 'payload' },\n}\n```\n\n1. **filePath(required)** - Full path to the directory to which provider files will be downloaded temporarily.\n\n2. **secret(recommended)** - A secret string which Companion uses to generate authorization tokens. You should generate a long random string for this.\n\n3. **uploadUrls(recommended)** - An allowlist (array) of strings (exact URLs) or regular expressions. If specified, Companion will only accept uploads to these URLs. This is needed to make sure a Companion instance is only allowed to upload to your servers. **Omitting this leaves your system open to potential [SSRF](https://en.wikipedia.org/wiki/Server-side_request_forgery) attacks, and may throw an error in future `@uppy/companion` releases.**\n\n4. **redisUrl(optional)** - URL to running Redis server. If this is set, the state of uploads would be stored temporarily. This helps for resumed uploads after a browser crash from the client. The stored upload would be sent back to the client on reconnection.\n\n5. **redisOptions(optional)** - An object of [options supported by redis client](https://www.npmjs.com/package/redis#options-object-properties). This option can be used in place of `redisUrl`.\n\n6. **redisPubSubScope(optional)** - Use a scope for the companion events at the Redis server. Setting this option will prefix all events with the name provided and a colon.\n\n7. **server(optional)** - An object with details, mainly used to carry out oauth authentication from any of the enabled providers above. Though it\u2019s optional, it\u2019s required if you would be enabling any of the supported providers. The following are the server options you may set:\n\n* `protocol` - `http | https` - even though companion itself always runs as http, you may want to set this to `https` if you are running a reverse https proxy in front of companion.\n* `host` (required) - your server\u2019s publically facing hostname (for example `example.com`).\n* `oauthDomain` - if you have several instances of Companion with different (and perhaps dynamic) subdomains, you can set a single fixed domain (e.g `sub1.example.com`) to handle your OAuth authentication for you. This would then redirect back to the correct instance with the required credentials on completion. This way you only need to configure a single callback URL for OAuth providers.\n* `path` - the server path to where the Uppy app is sitting (e.g if Companion is at `example.com/companion`, then the path would be `/companion`).\n* `implicitPath` - if the URL\u2019s path in your reverse proxy is different from your Companion path in your express app, then you need to set this path as `implicitPath`. So if your Companion URL is `example.com/mypath/companion`. Where the path `/mypath` is defined in your NGINX server, while `/companion` is set in your express app. Then you need to set the option `implicitPath` to `/mypath`, and set the `path` option to `/companion`.\n* `validHosts` - if you are setting an `oauthDomain`, you need to set a list of valid hosts, so the oauth handler can validate the host of the Uppy instance requesting the authentication. This is essentially a list of valid domains running your Companion instances. The list may also contain regex patterns. e.g `['sub2.example.com', 'sub3.example.com', '(\\\\w+).example.com']`\n\n8. **sendSelfEndpoint(optional)** - This is essentially the same as the `server.host + server.path` attributes. The major reason for this attribute is that, when set, it adds the value as the `i-am` header of every request response.\n\n9. **providerOptions(optional)** - An object containing credentials (`key` and `secret`) for each provider you would like to enable. Please see [the list of supported providers](#Supported-providers).\n\n10. **customProviders(optional)** - This option enables you to add custom providers along with the already supported providers. See [Adding Custom Providers](#Adding-custom-providers) for more information.\n\n11. **debug(optional)** - A boolean flag to tell Companion whether to log useful debug information while running.\n\n12. **logClientVersion(optional)** - A boolean flag to tell Companion whether to log its version upon startup.\n\n13. **metrics(optional)** - A boolean flag to tell Companion whether to provide an endpoint `/metrics` with Prometheus metrics.\n\n14. **streamingUpload(optional)** - A boolean flag to tell Companion whether to enable streaming uploads. If enabled, it will lead to _faster uploads_ because companion will start uploading at the same time as downloading using `stream.pipe`. If `false`, files will be fully downloaded first, then uploaded. Defaults to `false`. Do **not** set it to `true` if you have a [custom Companion provider](#adding-custom-providers) that does not use the new async/stream API.\n\n15. **maxFileSize(optional)** - If this value is set, companion will limit the maximum file size to process. If unset, it will process files without any size limit (this is the default).\n\n16. **periodicPingUrls(optional)** - If this value is set, companion will periodically send POST requests to the specified URLs. Useful for keeping track of companion instances as a keep-alive.\n\n17. **periodicPingInterval(optional)** - Interval for periodic ping requests (in ms).\n\n18. **periodicPingStaticPayload(optional)** - A `JSON.stringify`-able JavaScript Object that will be sent as part of the JSON body in the period ping requests.\n\n19. **allowLocalUrls(optional)** - A boolean flag to tell Companion whether to allow requesting local URLs. Note: Only enable this in development. **Enabling it in production is a security risk.**\n\n### Provider Redirect URIs\n\nWhen generating your provider API keys on their corresponding developer platforms (e.g [Google Developer Console](https://console.developers.google.com/)), you\u2019d need to provide a `redirect URI` for the OAuth authorization process. In general the redirect URI for each provider takes the format:\n\n`http(s)://$YOUR_COMPANION_HOST_NAME/$PROVIDER_NAME/redirect`\n\nFor example, if your Companion server is hosted on `https://my.companion.server.com`, then the redirect URI you would supply for your OneDrive provider would be:\n\n`https://my.companion.server.com/onedrive/redirect`\n\nPlease see [Supported Providers](https://uppy.io/docs/companion/#Supported-providers) for a list of all Providers and their corresponding names.\n\n### S3 options\n\nCompanion comes with signature endpoints for AWS S3. These can be used by the Uppy client to sign requests to upload files directly to S3, without exposing secret S3 keys in the browser. Companion also supports uploading files from providers like Dropbox and Instagram directly into S3.\n\nThe S3 features can be configured using the `providerOptions.s3` property.\n\n#### `providerOptions.s3.key`\n\nThe S3 access key ID. The standalone Companion server populates this with the value of the `COMPANION_AWS_KEY` environment variable by default.\n\n#### `providerOptions.s3.secret`\n\nThe S3 secret access key. The standalone Companion server populates this with the value of the `COMPANION_AWS_SECRET` environment variable by default.\n\n#### `providerOptions.s3.bucket`\n\nThe name of the bucket to store uploaded files in. The standalone Companion server populates this with the value of the `COMPANION_AWS_BUCKET` environment variable by default.\n\n#### `providerOptions.s3.region`\n\nThe datacenter region where the target bucket is located. The standalone Companion server populates this with the value of the `COMPANION_AWS_REGION` environment variable by default.\n\n#### `providerOptions.s3.awsClientOptions`\n\nYou can supply any [S3 option supported by the AWS SDK](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#constructor-property) in the `providerOptions.s3.awsClientOptions` object, _except for_ the below:\n\n* `accessKeyId`. Instead, use the `providerOptions.s3.key` property. This is to make configuration names consistent between different Companion features.\n* `secretAccessKey`. Instead, use the `providerOptions.s3.secret` property. This is to make configuration names consistent between different Companion features.\n\nBe aware that some options may cause wrong behaviour if they conflict with Companion\u2019s assumptions. If you find that a particular option does not work as expected, please [open an issue on the Uppy repository](https://github.com/transloadit/uppy/issues/new) so we can document it here.\n\n#### `providerOptions.s3.getKey(req, filename, metadata)`\n\nGet the key name for a file. The key is the file path to which the file will be uploaded in your bucket. This option should be a function receiving three arguments:\n\n* `req`, the HTTP request, for _regular_ S3 uploads using the `@uppy/aws-s3` plugin. This parameter is _not_ available for multipart uploads using the `@uppy/aws-s3-multipart` plugin;\n* `filename`, the original name of the uploaded file;\n* `metadata`, user-provided metadata for the file. See the [`@uppy/aws-s3`](https://uppy.io/docs/aws-s3/#metaFields) docs. The `@uppy/aws-s3-multipart` plugin unconditionally sends all metadata fields, so they all are available here.\n\nThis function should return a string `key`. The `req` parameter can be used to upload to a user-specific folder in your bucket, for example:\n\n```js\napp.use(authenticationMiddleware)\napp.use(uppy.app({\n  providerOptions: {\n    s3: {\n      getKey: (req, filename, metadata) => `${req.user.id}/${filename}`,\n      /* auth options */\n    },\n  },\n}))\n```\n\nThe default implementation returns the `filename`, so all files will be uploaded to the root of the bucket as their original file name.\n\n```js\napp.use(uppy.app({\n  providerOptions: {\n    s3: {\n      getKey: (req, filename, metadata) => filename,\n    },\n  },\n}))\n```\n\n### Running in Kubernetes\n\nWe have [a detailed guide on running Companion in Kubernetes](https://github.com/transloadit/uppy/blob/main/packages/%40uppy/companion/KUBERNETES.md) for you, that\u2019s how we run our example server at <https://companion.uppy.io>.\n\n### Adding custom providers\n\nAs of now, Companion supports the [providers listed here](https://uppy.io/docs/companion/#Supported-providers) out of the box, but you may also choose to add your own custom providers. You can do this by passing the `customProviders` option when calling the Uppy `app` method. The custom provider is expected to support Oauth 1 or 2 for authentication/authorization.\n\n```javascript\nimport providerModule from './path/to/provider/module'\n\nconst options = {\n  customProviders: {\n    myprovidername: {\n      config: {\n        authorize_url: 'https://mywebsite.com/authorize',\n        access_url: 'https://mywebsite.com/token',\n        oauth: 2,\n        key: '***',\n        secret: '***',\n        scope: ['read', 'write'],\n      },\n      module: providerModule,\n    },\n  },\n}\n\nuppy.app(options)\n```\n\nThe `customProviders` option should be an object containing each custom provider. Each custom provider would, in turn, be an object with two keys, `config` and `module`. The `config` option would contain Oauth API settings, while the `module` would point to the provider module.\n\nTo work well with Companion, the **module** must be a class with the following methods. Note that the methods must be `async`, return a `Promise` or reject with an `Error`):\n\n1. `async list ({ token, directory, query })` - Returns a object containing a list of user files (such as a list of all the files in a particular directory). See [example returned list data structure](#list-data).\n   `token` - authorization token (retrieved from oauth process) to send along with your request\n   * `directory` - the id/name of the directory from which data is to be retrieved. This may be ignored if it doesn\u2019t apply to your provider\n   * `query` - expressjs query params object received by the server (in case some data you need in there).\n2. `async download ({ token, id, query })` - Downloads a particular file from the provider. Returns an object with a single property `{ stream }` - a [`stream.Readable`](https://nodejs.org/api/stream.html#stream_class_stream_readable), which will be read from and uploaded to the destination. To prevent memory leaks, make sure you release your stream if you reject this method with an error.\n   * `token` - authorization token (retrieved from oauth process) to send along with your request.\n   * `id` - ID of the file being downloaded.\n   * `query` - expressjs query params object received by the server (in case some data you need in there).\n3. `async size ({ token, id, query })` - Returns the byte size of the file that needs to be downloaded as a `Number`. If the size of the object is not known, `null` may be returned.\n   * `token` - authorization token (retrieved from oauth process) to send along with your request.\n   * `id` - ID of the file being downloaded.\n   * `query` - expressjs query params object received by the server (in case some data you need in there).\n\nThe class must also have:\n\n* A unique `authProvider` string property - a lowercased value which typically indicates the name of the provider (e.g \u201cdropbox\u201d).\n* A `static` property `static version = 2`, which is the current version of the Companion Provider API.\n\nSee also [example code with a custom provider](https://github.com/transloadit/uppy/blob/main/examples/custom-provider/server).\n\n#### list data\n\n```json\n{\n  // username or email of the user whose provider account is being accessed\n  \"username\": \"johndoe\",\n  // list of files and folders in the directory. An item is considered a folder\n  //  if it mainly exists as a collection to contain sub-items\n  \"items\": [\n    {\n      // boolean value of whether or NOT it's a folder\n      \"isFolder\": false,\n      // icon image URL\n      \"icon\": \"https://random-api.url.com/fileicon.jpg\",\n      // name of the item\n      \"name\": \"myfile.jpg\",\n      // the mime type of the item. Only relevant if the item is NOT a folder\n      \"mimeType\": \"image/jpg\",\n      // the id (in string) of the item\n      \"id\": \"uniqueitemid\",\n      // thumbnail image URL. Only relevant if the item is NOT a folder\n      \"thumbnail\": \"https://random-api.url.com/filethumbnail.jpg\",\n      // for folders this is typically the value that will be passed as \"directory\" in the list(...) method.\n      // For files, this is the value that will be passed as id in the download(...) method.\n      \"requestPath\": \"file-or-folder-requestpath\",\n      // datetime string (in ISO 8601 format) of when this item was last modified\n      \"modifiedDate\": \"2020-06-29T19:59:58Z\",\n      // the size in bytes of the item. Only relevant if the item is NOT a folder\n      \"size\": 278940,\n      \"custom\": {\n        // an object that may contain some more custom fields that you may need to send to the client. Only add this object if you have a need for it.\n        \"customData1\": \"the value\",\n        \"customData2\": \"the value\"\n      }\n      // more items here\n    }\n  ],\n  // if the \"items\" list is paginated, this is the request path needed to fetch the next page.\n  \"nextPagePath\": \"directory-name?cursor=cursor-to-next-page\"\n}\n```\n\n## Migrating v1 to v2\n\n### Prerequisite\n\nSince v2, you now need to be running `node.js >= v10.20.1` to use Companion.\n\n### ProviderOptions\n\nIn v2 the `google` and `microsoft` [providerOptions](https://uppy.io/docs/companion/#Options) have been changed to `drive` and `onedrive` respectively.\n\n### OAuth Redirect URIs\n\nOn your Providers\u2019 respective developer platforms, the OAuth redirect URIs that you should supply has now changed from:\n\n`http(s)://$COMPANION_HOST_NAME/connect/$AUTH_PROVIDER/callback` in v1\n\nto:\n\n`http(s)://$COMPANION_HOST_NAME/$PROVIDER_NAME/redirect` in v2\n\n#### New Redirect URIs\n\n<div class=\"table-responsive\">\n\n| Provider | New Redirect URI\n|-|-|\n| Dropbox | `https://$COMPANION_HOST_NAME/dropbox/redirect` |\n| Google Drive | `https://$COMPANION_HOST_NAME/drive/redirect` |\n| OneDrive | `https://$COMPANION_HOST_NAME/onedrive/redirect` |\n| Box | `https://$YOUR_COMPANION_HOST_NAME/box/redirect` |\n| Facebook | `https://$COMPANION_HOST_NAME/facebook/redirect` |\n| Instagram | `https://$COMPANION_HOST_NAME/instagram/redirect` |\n\n</div>\n\n## Development\n\n1\\. To set up Companion for local development, please clone the Uppy repo and install, like so:\n\n```bash\ngit clone https://github.com/transloadit/uppy\ncd uppy\nyarn install\n```\n\n2\\. Configure your environment variables by copying the `env.example.sh` file to `env.sh` and edit it to its correct values.\n\n```bash\ncp env.example.sh env.sh\n$EDITOR env.sh\n```\n\n3\\. To start the server, run:\n\n```bash\nyarn run start:companion\n```\n\nThis would get the Companion instance running on `http://localhost:3020`. It uses [nodemon](https://github.com/remy/nodemon) so it will automatically restart when files are changed.\n\n## Live example\n\nAn example server is running at <https://companion.uppy.io>, which is deployed with [Kubernetes](https://github.com/transloadit/uppy/blob/main/packages/%40uppy/companion/KUBERNETES.md)\n\n## How the Authentication and Token mechanism works\n\nThis section describes how Authentication works between Companion and Providers. While this behaviour is the same for all Providers (Dropbox, Instagram, Google Drive, etc.), we are going to be referring to Dropbox in place of any Provider throughout this section.\n\nThe following steps describe the actions that take place when a user Authenticates and Uploads from Dropbox through Companion:\n\n* The visitor to a website with Uppy clicks `Connect to Dropbox`.\n* Uppy sends a request to Companion, which in turn sends an OAuth request to Dropbox (Requires that OAuth credentials from Dropbox have been added to Companion).\n* Dropbox asks the visitor to log in, and whether the Website should be allowed to access your files\n* If the visitor agrees, Companion will receive a token from Dropbox, with which we can temporarily download files.\n* Companion encrypts the token with a secret key and sends the encrypted token to Uppy (client)\n* Every time the visitor clicks on a folder in Uppy, it asks Companion for the new list of files, with this question, the token (still encrypted by Companion) is sent along.\n* Companion decrypts the token, requests the list of files from Dropbox and sends it to Uppy.\n* When a file is selected for upload, Companion receives the token again according to this procedure, decrypts it again, and thereby downloads the file from Dropbox.\n* As the bytes arrive, Companion uploads the bytes to the final destination (depending on the configuration: Apache, a Tus server, S3 bucket, etc).\n* Companion reports progress to Uppy, as if it were a local upload.\n* Completed!\n"], "filenames": [".env.example", "bin/companion.sh", "packages/@uppy/companion/src/companion.js", "packages/@uppy/companion/src/server/controllers/url.js", "packages/@uppy/companion/src/server/logger.js", "packages/@uppy/companion/src/server/provider/facebook/index.js", "packages/@uppy/companion/src/server/provider/instagram/graph/index.js", "packages/@uppy/companion/src/server/provider/unsplash/index.js", "packages/@uppy/companion/src/standalone/helper.js", "packages/@uppy/companion/test/__tests__/companion.js", "packages/@uppy/companion/test/mockserver.js", "website/src/docs/companion.md"], "buggy_code_start_loc": [12, 13, 44, 14, 115, 130, 121, 132, 109, 173, 13, 247], "buggy_code_end_loc": [12, 13, 45, 124, 116, 131, 122, 133, 110, 173, 13, 360], "fixing_code_start_loc": [13, 14, 44, 14, 114, 130, 121, 132, 109, 174, 14, 248], "fixing_code_end_loc": [16, 15, 45, 124, 114, 131, 122, 133, 110, 202, 15, 367], "type": "CWE-863", "message": "Exposure of Sensitive Information to an Unauthorized Actor in GitHub repository transloadit/uppy prior to 3.3.1.", "other": {"cve": {"id": "CVE-2022-0528", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-03T07:15:06.973", "lastModified": "2022-03-09T19:52:52.037", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Exposure of Sensitive Information to an Unauthorized Actor in GitHub repository transloadit/uppy prior to 3.3.1."}, {"lang": "es", "value": "Una Exposici\u00f3n de Informaci\u00f3n Confidencial a un Actor no Autorizado en el repositorio de GitHub transloadit/uppy versiones anteriores a 3.3.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:transloadit:uppy:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.3.1", "matchCriteriaId": "9FC0310C-437F-4263-BF52-B416811E0380"}]}]}], "references": [{"url": "https://github.com/transloadit/uppy/commit/267c34045a1e62c98406d8c31261c604a11e544a", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/8b060cc3-2420-468e-8293-b9216620175b", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/transloadit/uppy/commit/267c34045a1e62c98406d8c31261c604a11e544a"}}