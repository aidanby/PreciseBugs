{"buggy_code": ["/*\n * Copyright 2012-2013 Ontology Engineering Group, Universidad Politecnica de Madrid, Spain\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\npackage widoco;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.semanticweb.owlapi.apibinding.OWLManager;\nimport org.semanticweb.owlapi.io.FileDocumentSource;\nimport org.semanticweb.owlapi.model.*;\n\n/**\n * Some useful methods reused across different classes\n * \n * @author Daniel Garijo\n */\npublic class WidocoUtils {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(WidocoUtils.class);\n\n\t/**\n\t * Method that will download the ontology to document with Widoco.\n\t * \n\t * @param c Widoco configuration object.\n\t * @throws java.lang.Exception\n\t */\n\tpublic static void loadModelToDocument(Configuration c) throws Exception {\n\t\tif (!c.isFromFile()) {\n\t\t\tString newOntologyPath = c.getTmpFile().getAbsolutePath() + File.separator + \"Ontology\";\n\t\t\tdownloadOntology(c.getOntologyURI(), newOntologyPath);\n\t\t\tc.setFromFile(true);\n\t\t\tc.setOntologyPath(newOntologyPath);\n\t\t}\n\n\t\tlogger.info(\"Load ontology \" + c.getOntologyPath());\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\tOWLOntologyIRIMapper jenaCatalogMapper = new CatalogIRIMapper();\n\t\tmanager.getIRIMappers().add(jenaCatalogMapper);\n\t\t((CatalogIRIMapper) jenaCatalogMapper).printMap();\n\t\tOWLOntologyLoaderConfiguration loadingConfig = new OWLOntologyLoaderConfiguration();\n\t\tloadingConfig = loadingConfig.setMissingImportHandlingStrategy(MissingImportHandlingStrategy.SILENT);\n\t\tOWLOntology ontology = manager\n\t\t\t\t.loadOntologyFromOntologyDocument(new FileDocumentSource(new File(c.getOntologyPath())), loadingConfig);\n\t\tc.getMainOntology().setMainOntology(ontology);\n\t\tc.getMainOntology().setMainOntologyManager(manager);\n\t\tc.getMainOntology().getOWLAPIModel().setOWLOntologyManager(manager);\n\t}\n\n\t/**\n\t * Method that will download an ontology given its URI, doing content\n\t * negotiation The ontology will be downloaded in the first serialization\n\t * available (see Constants.POSSIBLE_VOCAB_SERIALIZATIONS)\n\t * \n\t * @param uri\n\t *            the URI of the ontology\n\t * @param downloadPath\n\t *            path where the ontology will be saved locally.\n\t */\n\tpublic static void downloadOntology(String uri, String downloadPath) {\n\n\t\tfor (String serialization : Constants.POSSIBLE_VOCAB_SERIALIZATIONS) {\n\t\t\tlogger.info(\"Attempting to download vocabulary in \" + serialization);\n\t\t\ttry {\n\t\t\t\tURL url = new URL(uri);\n\t\t\t\tHttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\t\t\t\tconnection.setRequestMethod(\"GET\");\n\t\t\t\tconnection.setInstanceFollowRedirects(true);\n\t\t\t\tconnection.setRequestProperty(\"Accept\", serialization);\n\t\t\t\tint status = connection.getResponseCode();\n\t\t\t\tboolean redirect = false;\n\t\t\t\tif (status != HttpURLConnection.HTTP_OK) {\n\t\t\t\t\tif (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM\n\t\t\t\t\t\t\t|| status == HttpURLConnection.HTTP_SEE_OTHER)\n\t\t\t\t\t\tredirect = true;\n\t\t\t\t}\n\t\t\t\t// there are some vocabularies with multiple redirections:\n\t\t\t\t// 301 -> 303 -> owl\n\t\t\t\twhile (redirect) {\n\t\t\t\t\tString newUrl = connection.getHeaderField(\"Location\");\n\t\t\t\t\tconnection = (HttpURLConnection) new URL(newUrl).openConnection();\n\t\t\t\t\tconnection.setRequestProperty(\"Accept\", serialization);\n\t\t\t\t\tstatus = connection.getResponseCode();\n\t\t\t\t\tif (status != HttpURLConnection.HTTP_MOVED_TEMP && status != HttpURLConnection.HTTP_MOVED_PERM\n\t\t\t\t\t\t\t&& status != HttpURLConnection.HTTP_SEE_OTHER)\n\t\t\t\t\t\tredirect = false;\n\t\t\t\t}\n\t\t\t\tInputStream in = (InputStream) connection.getInputStream();\n\t\t\t\tFiles.copy(in, Paths.get(downloadPath), StandardCopyOption.REPLACE_EXISTING);\n\t\t\t\tin.close();\n\t\t\t\tbreak; // if the vocabulary is downloaded, then we don't download it for the other\n\t\t\t\t\t\t// serializations\n\t\t\t} catch (Exception e) {\n\t\t\t\tfinal String message = \"Failed to download vocabulary in RDF format [\" + serialization +\"]: \";\n\t\t\t\tlogger.error(message + e.toString());\n\t\t\t\tthrow new RuntimeException(message, e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Writes a model into a file\n\t * \n\t * @param m\n\t *            the manager\n\t * @param o\n\t *            the ontology to write\n\t * @param f\n\t *            the format in which should be written\n\t * @param outPath\n\t */\n\tpublic static void writeModel(OWLOntologyManager m, OWLOntology o, OWLDocumentFormat f, String outPath) {\n\t\tOutputStream out = null;\n\t\ttry {\n\t\t\tout = new FileOutputStream(outPath);\n\t\t\tm.saveOntology(o, f, out);\n\t\t\tout.close();\n\t\t} catch (Exception ex) {\n\t\t\tlogger.error(\"Error while writing the model to file \" + ex.getMessage());\n\t\t\tif (out != null) {\n\t\t\t\ttry {\n\t\t\t\t\tout.close();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// /**\n\t// * Method that reads a local file and loads it into the configuration.\n\t// * @param model\n\t// * @param ontoPath\n\t// * @param ontoURL\n\t// */\n\t// private static void readOntModel(OntModel model,Configuration c){\n\t// String[] serializations = {\"RDF/XML\", \"TTL\", \"N3\"};\n\t// String ontoPath = c.getOntologyPath();\n\t// String ext = \"\";\n\t// for(String s:serializations){\n\t// InputStream in;\n\t// try{\n\t// in = FileManager.get().open(ontoPath);\n\t// if (in == null) {\n\t// System.err.println(\"Error: Ontology file not found\");\n\t// return;\n\t// }\n\t// model.read(in, null, s);\n\t// System.out.println(\"Vocab loaded in \"+s);\n\t// if(s.equals(\"RDF/XML\")){\n\t// ext=\"xml\";\n\t// }else if(s.equals(\"TTL\")){\n\t// ext=\"ttl\";\n\t// }else if(s.equals(\"N3\")){\n\t// ext=\"n3\";\n\t// }\n\t// c.getMainOntology().addSerialization(s, \"ontology.\"+ext);\n\t// //c.setVocabSerialization(s);\n\t// break;\n\t// }catch(Exception e){\n\t// System.err.println(\"Could not open the ontology in \"+s);\n\t// }\n\t// }\n\t//\n\t// }\n\n\tpublic static void copyResourceFolder(String[] resources, String savePath) throws IOException {\n\t\tfor (String resource : resources) {\n\t\t\tString aux = resource.substring(resource.lastIndexOf(\"/\") + 1, resource.length());\n\t\t\tFile b = new File(savePath + File.separator + aux);\n\t\t\tb.createNewFile();\n\t\t\tcopyLocalResource(resource, b);\n\t\t}\n\t}\n\n\t/**\n\t * Method used to copy the local files: styles, images, etc.\n\t * \n\t * @param resourceName\n\t *            Name of the resource\n\t * @param dest\n\t *            file where we should copy it.\n\t */\n\tpublic static void copyLocalResource(String resourceName, File dest) {\n\t\ttry {\n\t\t\tcopy(CreateResources.class.getResourceAsStream(resourceName), dest);\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(\"Exception while copying \" + resourceName + \" - \" + e.getMessage());\n\t\t}\n\t}\n\n\t/**\n\t * Copy a file from outside the project into the desired file.\n\t * \n\t * @param path\n\t * @param dest\n\t */\n\tpublic static void copyExternalResource(String path, File dest) {\n\t\ttry {\n\t\t\tInputStream is = new FileInputStream(path);\n\t\t\tcopy(is, dest);\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(\"Exception while copying \" + path + e.getMessage());\n\t\t}\n\t}\n        \n        public static String readExternalResource(String path) {\n            String content = \"\";\n            try{\n                content = new String ( Files.readAllBytes( Paths.get(path) ) );\n            }catch (IOException e){\n                logger.error(\"Exception while copying \" + path + e.getMessage());\n            }\n            return content;\n\t}\n\n\t/**\n\t * Code to unzip a file. Inspired from\n\t * http://www.mkyong.com/java/how-to-decompress-files-from-a-zip-file/ Taken\n\t * from\n\t * \n\t * @param resourceName\n\t * @param outputFolder\n\t */\n\tpublic static void unZipIt(String resourceName, String outputFolder) {\n\n\t\tbyte[] buffer = new byte[1024];\n\n\t\ttry {\n\t\t\tZipInputStream zis = new ZipInputStream(CreateResources.class.getResourceAsStream(resourceName));\n\t\t\tZipEntry ze = zis.getNextEntry();\n\n\t\t\twhile (ze != null) {\n\t\t\t\tString fileName = ze.getName();\n\t\t\t\tFile newFile = new File(outputFolder + File.separator + fileName);\n\t\t\t\t// System.out.println(\"file unzip : \"+ newFile.getAbsoluteFile());\n\t\t\t\tif (ze.isDirectory()) {\n\t\t\t\t\tString temp = newFile.getAbsolutePath();\n\t\t\t\t\tnew File(temp).mkdirs();\n\t\t\t\t} else {\n\t\t\t\t\tString directory = newFile.getParent();\n\t\t\t\t\tif (directory != null) {\n\t\t\t\t\t\tFile d = new File(directory);\n\t\t\t\t\t\tif (!d.exists()) {\n\t\t\t\t\t\t\td.mkdirs();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tFileOutputStream fos = new FileOutputStream(newFile);\n\t\t\t\t\tint len;\n\t\t\t\t\twhile ((len = zis.read(buffer)) > 0) {\n\t\t\t\t\t\tfos.write(buffer, 0, len);\n\t\t\t\t\t}\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t\tze = zis.getNextEntry();\n\t\t\t}\n\n\t\t\tzis.closeEntry();\n\t\t\tzis.close();\n\n\t\t} catch (IOException ex) {\n\t\t\tlogger.error(\"Error while extracting the reosurces: \" + ex.getMessage());\n\t\t}\n\n\t}\n\n\tpublic static void copy(InputStream is, File dest) throws Exception {\n\t\tOutputStream os = null;\n\t\ttry {\n\t\t\tos = new FileOutputStream(dest);\n\t\t\tbyte[] buffer = new byte[1024];\n\t\t\tint length;\n\t\t\twhile ((length = is.read(buffer)) > 0) {\n\t\t\t\tos.write(buffer, 0, length);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(\"Exception while copying resource. \" + e.getMessage());\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tif (is != null)\n\t\t\t\tis.close();\n\t\t\tif (os != null)\n\t\t\t\tos.close();\n\t\t}\n\t}\n\n\tpublic static String getValueAsLiteralOrURI(OWLAnnotationValue v) {\n\t\ttry {\n\t\t\treturn v.asIRI().get().getIRIString();\n\t\t} catch (Exception e) {\n\t\t\t// instead of a resource, it was added as a String\n\t\t\treturn v.asLiteral().get().getLiteral();\n\t\t}\n\t}\n\n}\n"], "fixing_code": ["/*\n * Copyright 2012-2013 Ontology Engineering Group, Universidad Politecnica de Madrid, Spain\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\npackage widoco;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.semanticweb.owlapi.apibinding.OWLManager;\nimport org.semanticweb.owlapi.io.FileDocumentSource;\nimport org.semanticweb.owlapi.model.*;\n\n/**\n * Some useful methods reused across different classes\n * \n * @author Daniel Garijo\n */\npublic class WidocoUtils {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(WidocoUtils.class);\n\n\t/**\n\t * Method that will download the ontology to document with Widoco.\n\t * \n\t * @param c Widoco configuration object.\n\t * @throws java.lang.Exception\n\t */\n\tpublic static void loadModelToDocument(Configuration c) throws Exception {\n\t\tif (!c.isFromFile()) {\n\t\t\tString newOntologyPath = c.getTmpFile().getAbsolutePath() + File.separator + \"Ontology\";\n\t\t\tdownloadOntology(c.getOntologyURI(), newOntologyPath);\n\t\t\tc.setFromFile(true);\n\t\t\tc.setOntologyPath(newOntologyPath);\n\t\t}\n\n\t\tlogger.info(\"Load ontology \" + c.getOntologyPath());\n\t\tOWLOntologyManager manager = OWLManager.createOWLOntologyManager();\n\t\tOWLOntologyIRIMapper jenaCatalogMapper = new CatalogIRIMapper();\n\t\tmanager.getIRIMappers().add(jenaCatalogMapper);\n\t\t((CatalogIRIMapper) jenaCatalogMapper).printMap();\n\t\tOWLOntologyLoaderConfiguration loadingConfig = new OWLOntologyLoaderConfiguration();\n\t\tloadingConfig = loadingConfig.setMissingImportHandlingStrategy(MissingImportHandlingStrategy.SILENT);\n\t\tOWLOntology ontology = manager\n\t\t\t\t.loadOntologyFromOntologyDocument(new FileDocumentSource(new File(c.getOntologyPath())), loadingConfig);\n\t\tc.getMainOntology().setMainOntology(ontology);\n\t\tc.getMainOntology().setMainOntologyManager(manager);\n\t\tc.getMainOntology().getOWLAPIModel().setOWLOntologyManager(manager);\n\t}\n\n\t/**\n\t * Method that will download an ontology given its URI, doing content\n\t * negotiation The ontology will be downloaded in the first serialization\n\t * available (see Constants.POSSIBLE_VOCAB_SERIALIZATIONS)\n\t * \n\t * @param uri\n\t *            the URI of the ontology\n\t * @param downloadPath\n\t *            path where the ontology will be saved locally.\n\t */\n\tpublic static void downloadOntology(String uri, String downloadPath) {\n\n\t\tfor (String serialization : Constants.POSSIBLE_VOCAB_SERIALIZATIONS) {\n\t\t\tlogger.info(\"Attempting to download vocabulary in \" + serialization);\n\t\t\ttry {\n\t\t\t\tURL url = new URL(uri);\n\t\t\t\tHttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\t\t\t\tconnection.setRequestMethod(\"GET\");\n\t\t\t\tconnection.setInstanceFollowRedirects(true);\n\t\t\t\tconnection.setRequestProperty(\"Accept\", serialization);\n\t\t\t\tint status = connection.getResponseCode();\n\t\t\t\tboolean redirect = false;\n\t\t\t\tif (status != HttpURLConnection.HTTP_OK) {\n\t\t\t\t\tif (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM\n\t\t\t\t\t\t\t|| status == HttpURLConnection.HTTP_SEE_OTHER)\n\t\t\t\t\t\tredirect = true;\n\t\t\t\t}\n\t\t\t\t// there are some vocabularies with multiple redirections:\n\t\t\t\t// 301 -> 303 -> owl\n\t\t\t\twhile (redirect) {\n\t\t\t\t\tString newUrl = connection.getHeaderField(\"Location\");\n\t\t\t\t\tconnection = (HttpURLConnection) new URL(newUrl).openConnection();\n\t\t\t\t\tconnection.setRequestProperty(\"Accept\", serialization);\n\t\t\t\t\tstatus = connection.getResponseCode();\n\t\t\t\t\tif (status != HttpURLConnection.HTTP_MOVED_TEMP && status != HttpURLConnection.HTTP_MOVED_PERM\n\t\t\t\t\t\t\t&& status != HttpURLConnection.HTTP_SEE_OTHER)\n\t\t\t\t\t\tredirect = false;\n\t\t\t\t}\n\t\t\t\tInputStream in = (InputStream) connection.getInputStream();\n\t\t\t\tFiles.copy(in, Paths.get(downloadPath), StandardCopyOption.REPLACE_EXISTING);\n\t\t\t\tin.close();\n\t\t\t\tbreak; // if the vocabulary is downloaded, then we don't download it for the other\n\t\t\t\t\t\t// serializations\n\t\t\t} catch (Exception e) {\n\t\t\t\tfinal String message = \"Failed to download vocabulary in RDF format [\" + serialization +\"]: \";\n\t\t\t\tlogger.error(message + e.toString());\n\t\t\t\tthrow new RuntimeException(message, e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Writes a model into a file\n\t * \n\t * @param m\n\t *            the manager\n\t * @param o\n\t *            the ontology to write\n\t * @param f\n\t *            the format in which should be written\n\t * @param outPath\n\t */\n\tpublic static void writeModel(OWLOntologyManager m, OWLOntology o, OWLDocumentFormat f, String outPath) {\n\t\tOutputStream out = null;\n\t\ttry {\n\t\t\tout = new FileOutputStream(outPath);\n\t\t\tm.saveOntology(o, f, out);\n\t\t\tout.close();\n\t\t} catch (Exception ex) {\n\t\t\tlogger.error(\"Error while writing the model to file \" + ex.getMessage());\n\t\t\tif (out != null) {\n\t\t\t\ttry {\n\t\t\t\t\tout.close();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// /**\n\t// * Method that reads a local file and loads it into the configuration.\n\t// * @param model\n\t// * @param ontoPath\n\t// * @param ontoURL\n\t// */\n\t// private static void readOntModel(OntModel model,Configuration c){\n\t// String[] serializations = {\"RDF/XML\", \"TTL\", \"N3\"};\n\t// String ontoPath = c.getOntologyPath();\n\t// String ext = \"\";\n\t// for(String s:serializations){\n\t// InputStream in;\n\t// try{\n\t// in = FileManager.get().open(ontoPath);\n\t// if (in == null) {\n\t// System.err.println(\"Error: Ontology file not found\");\n\t// return;\n\t// }\n\t// model.read(in, null, s);\n\t// System.out.println(\"Vocab loaded in \"+s);\n\t// if(s.equals(\"RDF/XML\")){\n\t// ext=\"xml\";\n\t// }else if(s.equals(\"TTL\")){\n\t// ext=\"ttl\";\n\t// }else if(s.equals(\"N3\")){\n\t// ext=\"n3\";\n\t// }\n\t// c.getMainOntology().addSerialization(s, \"ontology.\"+ext);\n\t// //c.setVocabSerialization(s);\n\t// break;\n\t// }catch(Exception e){\n\t// System.err.println(\"Could not open the ontology in \"+s);\n\t// }\n\t// }\n\t//\n\t// }\n\n\tpublic static void copyResourceFolder(String[] resources, String savePath) throws IOException {\n\t\tfor (String resource : resources) {\n\t\t\tString aux = resource.substring(resource.lastIndexOf(\"/\") + 1, resource.length());\n\t\t\tFile b = new File(savePath + File.separator + aux);\n\t\t\tb.createNewFile();\n\t\t\tcopyLocalResource(resource, b);\n\t\t}\n\t}\n\n\t/**\n\t * Method used to copy the local files: styles, images, etc.\n\t * \n\t * @param resourceName\n\t *            Name of the resource\n\t * @param dest\n\t *            file where we should copy it.\n\t */\n\tpublic static void copyLocalResource(String resourceName, File dest) {\n\t\ttry {\n\t\t\tcopy(CreateResources.class.getResourceAsStream(resourceName), dest);\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(\"Exception while copying \" + resourceName + \" - \" + e.getMessage());\n\t\t}\n\t}\n\n\t/**\n\t * Copy a file from outside the project into the desired file.\n\t * \n\t * @param path\n\t * @param dest\n\t */\n\tpublic static void copyExternalResource(String path, File dest) {\n\t\ttry {\n\t\t\tInputStream is = new FileInputStream(path);\n\t\t\tcopy(is, dest);\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(\"Exception while copying \" + path + e.getMessage());\n\t\t}\n\t}\n        \n        public static String readExternalResource(String path) {\n            String content = \"\";\n            try{\n                content = new String ( Files.readAllBytes( Paths.get(path) ) );\n            }catch (IOException e){\n                logger.error(\"Exception while copying \" + path + e.getMessage());\n            }\n            return content;\n\t}\n\n\t/**\n\t * Code to unzip a file. Inspired from\n\t * http://www.mkyong.com/java/how-to-decompress-files-from-a-zip-file/ Taken\n\t * from\n\t * \n\t * @param resourceName\n\t * @param outputFolder\n\t */\n\tpublic static void unZipIt(String resourceName, String outputFolder) {\n\n\t\tbyte[] buffer = new byte[1024];\n\n\t\ttry {\n\t\t\tZipInputStream zis = new ZipInputStream(CreateResources.class.getResourceAsStream(resourceName));\n\t\t\tZipEntry ze = zis.getNextEntry();\n\n\t\t\twhile (ze != null) {\n\t\t\t\tString fileName = ze.getName();\n\t\t\t\tFile newFile = new File(outputFolder, fileName);\n\t\t\t\tif (!newFile.toPath().normalize().startsWith(outputFolder)) {\n\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n\t\t\t\t}\n\t\t\t\t// System.out.println(\"file unzip : \"+ newFile.getAbsoluteFile());\n\t\t\t\tif (ze.isDirectory()) {\n\t\t\t\t\tString temp = newFile.getAbsolutePath();\n\t\t\t\t\tnew File(temp).mkdirs();\n\t\t\t\t} else {\n\t\t\t\t\tString directory = newFile.getParent();\n\t\t\t\t\tif (directory != null) {\n\t\t\t\t\t\tFile d = new File(directory);\n\t\t\t\t\t\tif (!d.exists()) {\n\t\t\t\t\t\t\td.mkdirs();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tFileOutputStream fos = new FileOutputStream(newFile);\n\t\t\t\t\tint len;\n\t\t\t\t\twhile ((len = zis.read(buffer)) > 0) {\n\t\t\t\t\t\tfos.write(buffer, 0, len);\n\t\t\t\t\t}\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t\tze = zis.getNextEntry();\n\t\t\t}\n\n\t\t\tzis.closeEntry();\n\t\t\tzis.close();\n\n\t\t} catch (IOException ex) {\n\t\t\tlogger.error(\"Error while extracting the reosurces: \" + ex.getMessage());\n\t\t}\n\n\t}\n\n\tpublic static void copy(InputStream is, File dest) throws Exception {\n\t\tOutputStream os = null;\n\t\ttry {\n\t\t\tos = new FileOutputStream(dest);\n\t\t\tbyte[] buffer = new byte[1024];\n\t\t\tint length;\n\t\t\twhile ((length = is.read(buffer)) > 0) {\n\t\t\t\tos.write(buffer, 0, length);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(\"Exception while copying resource. \" + e.getMessage());\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tif (is != null)\n\t\t\t\tis.close();\n\t\t\tif (os != null)\n\t\t\t\tos.close();\n\t\t}\n\t}\n\n\tpublic static String getValueAsLiteralOrURI(OWLAnnotationValue v) {\n\t\ttry {\n\t\t\treturn v.asIRI().get().getIRIString();\n\t\t} catch (Exception e) {\n\t\t\t// instead of a resource, it was added as a String\n\t\t\treturn v.asLiteral().get().getLiteral();\n\t\t}\n\t}\n\n}\n"], "filenames": ["src/main/java/widoco/WidocoUtils.java"], "buggy_code_start_loc": [260], "buggy_code_end_loc": [261], "fixing_code_start_loc": [260], "fixing_code_end_loc": [264], "type": "CWE-22", "message": "A vulnerability was found in Widoco and classified as critical. Affected by this issue is the function unZipIt of the file src/main/java/widoco/WidocoUtils.java. The manipulation leads to path traversal. It is possible to launch the attack on the local host. The name of the patch is f2279b76827f32190adfa9bd5229b7d5a147fa92. It is recommended to apply a patch to fix this issue. VDB-216914 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2022-4772", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-27T23:15:10.920", "lastModified": "2023-01-05T20:21:24.200", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Widoco and classified as critical. Affected by this issue is the function unZipIt of the file src/main/java/widoco/WidocoUtils.java. The manipulation leads to path traversal. It is possible to launch the attack on the local host. The name of the patch is f2279b76827f32190adfa9bd5229b7d5a147fa92. It is recommended to apply a patch to fix this issue. VDB-216914 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:widoco_project:widoco:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-07-29", "matchCriteriaId": "F759B35A-6EFF-4552-9506-D70AEBDE21EF"}]}]}], "references": [{"url": "https://github.com/dgarijo/Widoco/commit/f2279b76827f32190adfa9bd5229b7d5a147fa92", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dgarijo/Widoco/pull/551", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216914", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216914", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dgarijo/Widoco/commit/f2279b76827f32190adfa9bd5229b7d5a147fa92"}}