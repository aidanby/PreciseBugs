{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Budget Fair Queueing (BFQ) I/O scheduler.\n *\n * Based on ideas and code from CFQ:\n * Copyright (C) 2003 Jens Axboe <axboe@kernel.dk>\n *\n * Copyright (C) 2008 Fabio Checconi <fabio@gandalf.sssup.it>\n *\t\t      Paolo Valente <paolo.valente@unimore.it>\n *\n * Copyright (C) 2010 Paolo Valente <paolo.valente@unimore.it>\n *                    Arianna Avanzini <avanzini@google.com>\n *\n * Copyright (C) 2017 Paolo Valente <paolo.valente@linaro.org>\n *\n * BFQ is a proportional-share I/O scheduler, with some extra\n * low-latency capabilities. BFQ also supports full hierarchical\n * scheduling through cgroups. Next paragraphs provide an introduction\n * on BFQ inner workings. Details on BFQ benefits, usage and\n * limitations can be found in Documentation/block/bfq-iosched.rst.\n *\n * BFQ is a proportional-share storage-I/O scheduling algorithm based\n * on the slice-by-slice service scheme of CFQ. But BFQ assigns\n * budgets, measured in number of sectors, to processes instead of\n * time slices. The device is not granted to the in-service process\n * for a given time slice, but until it has exhausted its assigned\n * budget. This change from the time to the service domain enables BFQ\n * to distribute the device throughput among processes as desired,\n * without any distortion due to throughput fluctuations, or to device\n * internal queueing. BFQ uses an ad hoc internal scheduler, called\n * B-WF2Q+, to schedule processes according to their budgets. More\n * precisely, BFQ schedules queues associated with processes. Each\n * process/queue is assigned a user-configurable weight, and B-WF2Q+\n * guarantees that each queue receives a fraction of the throughput\n * proportional to its weight. Thanks to the accurate policy of\n * B-WF2Q+, BFQ can afford to assign high budgets to I/O-bound\n * processes issuing sequential requests (to boost the throughput),\n * and yet guarantee a low latency to interactive and soft real-time\n * applications.\n *\n * In particular, to provide these low-latency guarantees, BFQ\n * explicitly privileges the I/O of two classes of time-sensitive\n * applications: interactive and soft real-time. In more detail, BFQ\n * behaves this way if the low_latency parameter is set (default\n * configuration). This feature enables BFQ to provide applications in\n * these classes with a very low latency.\n *\n * To implement this feature, BFQ constantly tries to detect whether\n * the I/O requests in a bfq_queue come from an interactive or a soft\n * real-time application. For brevity, in these cases, the queue is\n * said to be interactive or soft real-time. In both cases, BFQ\n * privileges the service of the queue, over that of non-interactive\n * and non-soft-real-time queues. This privileging is performed,\n * mainly, by raising the weight of the queue. So, for brevity, we\n * call just weight-raising periods the time periods during which a\n * queue is privileged, because deemed interactive or soft real-time.\n *\n * The detection of soft real-time queues/applications is described in\n * detail in the comments on the function\n * bfq_bfqq_softrt_next_start. On the other hand, the detection of an\n * interactive queue works as follows: a queue is deemed interactive\n * if it is constantly non empty only for a limited time interval,\n * after which it does become empty. The queue may be deemed\n * interactive again (for a limited time), if it restarts being\n * constantly non empty, provided that this happens only after the\n * queue has remained empty for a given minimum idle time.\n *\n * By default, BFQ computes automatically the above maximum time\n * interval, i.e., the time interval after which a constantly\n * non-empty queue stops being deemed interactive. Since a queue is\n * weight-raised while it is deemed interactive, this maximum time\n * interval happens to coincide with the (maximum) duration of the\n * weight-raising for interactive queues.\n *\n * Finally, BFQ also features additional heuristics for\n * preserving both a low latency and a high throughput on NCQ-capable,\n * rotational or flash-based devices, and to get the job done quickly\n * for applications consisting in many I/O-bound processes.\n *\n * NOTE: if the main or only goal, with a given device, is to achieve\n * the maximum-possible throughput at all times, then do switch off\n * all low-latency heuristics for that device, by setting low_latency\n * to 0.\n *\n * BFQ is described in [1], where also a reference to the initial,\n * more theoretical paper on BFQ can be found. The interested reader\n * can find in the latter paper full details on the main algorithm, as\n * well as formulas of the guarantees and formal proofs of all the\n * properties.  With respect to the version of BFQ presented in these\n * papers, this implementation adds a few more heuristics, such as the\n * ones that guarantee a low latency to interactive and soft real-time\n * applications, and a hierarchical extension based on H-WF2Q+.\n *\n * B-WF2Q+ is based on WF2Q+, which is described in [2], together with\n * H-WF2Q+, while the augmented tree used here to implement B-WF2Q+\n * with O(log N) complexity derives from the one introduced with EEVDF\n * in [3].\n *\n * [1] P. Valente, A. Avanzini, \"Evolution of the BFQ Storage I/O\n *     Scheduler\", Proceedings of the First Workshop on Mobile System\n *     Technologies (MST-2015), May 2015.\n *     http://algogroup.unimore.it/people/paolo/disk_sched/mst-2015.pdf\n *\n * [2] Jon C.R. Bennett and H. Zhang, \"Hierarchical Packet Fair Queueing\n *     Algorithms\", IEEE/ACM Transactions on Networking, 5(5):675-689,\n *     Oct 1997.\n *\n * http://www.cs.cmu.edu/~hzhang/papers/TON-97-Oct.ps.gz\n *\n * [3] I. Stoica and H. Abdel-Wahab, \"Earliest Eligible Virtual Deadline\n *     First: A Flexible and Accurate Mechanism for Proportional Share\n *     Resource Allocation\", technical report.\n *\n * http://www.cs.berkeley.edu/~istoica/papers/eevdf-tr-95.pdf\n */\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/cgroup.h>\n#include <linux/elevator.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/ioprio.h>\n#include <linux/sbitmap.h>\n#include <linux/delay.h>\n\n#include \"blk.h\"\n#include \"blk-mq.h\"\n#include \"blk-mq-tag.h\"\n#include \"blk-mq-sched.h\"\n#include \"bfq-iosched.h\"\n#include \"blk-wbt.h\"\n\n#define BFQ_BFQQ_FNS(name)\t\t\t\t\t\t\\\nvoid bfq_mark_bfqq_##name(struct bfq_queue *bfqq)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t__set_bit(BFQQF_##name, &(bfqq)->flags);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nvoid bfq_clear_bfqq_##name(struct bfq_queue *bfqq)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t__clear_bit(BFQQF_##name, &(bfqq)->flags);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nint bfq_bfqq_##name(const struct bfq_queue *bfqq)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn test_bit(BFQQF_##name, &(bfqq)->flags);\t\t\\\n}\n\nBFQ_BFQQ_FNS(just_created);\nBFQ_BFQQ_FNS(busy);\nBFQ_BFQQ_FNS(wait_request);\nBFQ_BFQQ_FNS(non_blocking_wait_rq);\nBFQ_BFQQ_FNS(fifo_expire);\nBFQ_BFQQ_FNS(has_short_ttime);\nBFQ_BFQQ_FNS(sync);\nBFQ_BFQQ_FNS(IO_bound);\nBFQ_BFQQ_FNS(in_large_burst);\nBFQ_BFQQ_FNS(coop);\nBFQ_BFQQ_FNS(split_coop);\nBFQ_BFQQ_FNS(softrt_update);\nBFQ_BFQQ_FNS(has_waker);\n#undef BFQ_BFQQ_FNS\t\t\t\t\t\t\\\n\n/* Expiration time of sync (0) and async (1) requests, in ns. */\nstatic const u64 bfq_fifo_expire[2] = { NSEC_PER_SEC / 4, NSEC_PER_SEC / 8 };\n\n/* Maximum backwards seek (magic number lifted from CFQ), in KiB. */\nstatic const int bfq_back_max = 16 * 1024;\n\n/* Penalty of a backwards seek, in number of sectors. */\nstatic const int bfq_back_penalty = 2;\n\n/* Idling period duration, in ns. */\nstatic u64 bfq_slice_idle = NSEC_PER_SEC / 125;\n\n/* Minimum number of assigned budgets for which stats are safe to compute. */\nstatic const int bfq_stats_min_budgets = 194;\n\n/* Default maximum budget values, in sectors and number of requests. */\nstatic const int bfq_default_max_budget = 16 * 1024;\n\n/*\n * When a sync request is dispatched, the queue that contains that\n * request, and all the ancestor entities of that queue, are charged\n * with the number of sectors of the request. In contrast, if the\n * request is async, then the queue and its ancestor entities are\n * charged with the number of sectors of the request, multiplied by\n * the factor below. This throttles the bandwidth for async I/O,\n * w.r.t. to sync I/O, and it is done to counter the tendency of async\n * writes to steal I/O throughput to reads.\n *\n * The current value of this parameter is the result of a tuning with\n * several hardware and software configurations. We tried to find the\n * lowest value for which writes do not cause noticeable problems to\n * reads. In fact, the lower this parameter, the stabler I/O control,\n * in the following respect.  The lower this parameter is, the less\n * the bandwidth enjoyed by a group decreases\n * - when the group does writes, w.r.t. to when it does reads;\n * - when other groups do reads, w.r.t. to when they do writes.\n */\nstatic const int bfq_async_charge_factor = 3;\n\n/* Default timeout values, in jiffies, approximating CFQ defaults. */\nconst int bfq_timeout = HZ / 8;\n\n/*\n * Time limit for merging (see comments in bfq_setup_cooperator). Set\n * to the slowest value that, in our tests, proved to be effective in\n * removing false positives, while not causing true positives to miss\n * queue merging.\n *\n * As can be deduced from the low time limit below, queue merging, if\n * successful, happens at the very beginning of the I/O of the involved\n * cooperating processes, as a consequence of the arrival of the very\n * first requests from each cooperator.  After that, there is very\n * little chance to find cooperators.\n */\nstatic const unsigned long bfq_merge_time_limit = HZ/10;\n\nstatic struct kmem_cache *bfq_pool;\n\n/* Below this threshold (in ns), we consider thinktime immediate. */\n#define BFQ_MIN_TT\t\t(2 * NSEC_PER_MSEC)\n\n/* hw_tag detection: parallel requests threshold and min samples needed. */\n#define BFQ_HW_QUEUE_THRESHOLD\t3\n#define BFQ_HW_QUEUE_SAMPLES\t32\n\n#define BFQQ_SEEK_THR\t\t(sector_t)(8 * 100)\n#define BFQQ_SECT_THR_NONROT\t(sector_t)(2 * 32)\n#define BFQ_RQ_SEEKY(bfqd, last_pos, rq) \\\n\t(get_sdist(last_pos, rq) >\t\t\t\\\n\t BFQQ_SEEK_THR &&\t\t\t\t\\\n\t (!blk_queue_nonrot(bfqd->queue) ||\t\t\\\n\t  blk_rq_sectors(rq) < BFQQ_SECT_THR_NONROT))\n#define BFQQ_CLOSE_THR\t\t(sector_t)(8 * 1024)\n#define BFQQ_SEEKY(bfqq)\t(hweight32(bfqq->seek_history) > 19)\n/*\n * Sync random I/O is likely to be confused with soft real-time I/O,\n * because it is characterized by limited throughput and apparently\n * isochronous arrival pattern. To avoid false positives, queues\n * containing only random (seeky) I/O are prevented from being tagged\n * as soft real-time.\n */\n#define BFQQ_TOTALLY_SEEKY(bfqq)\t(bfqq->seek_history == -1)\n\n/* Min number of samples required to perform peak-rate update */\n#define BFQ_RATE_MIN_SAMPLES\t32\n/* Min observation time interval required to perform a peak-rate update (ns) */\n#define BFQ_RATE_MIN_INTERVAL\t(300*NSEC_PER_MSEC)\n/* Target observation time interval for a peak-rate update (ns) */\n#define BFQ_RATE_REF_INTERVAL\tNSEC_PER_SEC\n\n/*\n * Shift used for peak-rate fixed precision calculations.\n * With\n * - the current shift: 16 positions\n * - the current type used to store rate: u32\n * - the current unit of measure for rate: [sectors/usec], or, more precisely,\n *   [(sectors/usec) / 2^BFQ_RATE_SHIFT] to take into account the shift,\n * the range of rates that can be stored is\n * [1 / 2^BFQ_RATE_SHIFT, 2^(32 - BFQ_RATE_SHIFT)] sectors/usec =\n * [1 / 2^16, 2^16] sectors/usec = [15e-6, 65536] sectors/usec =\n * [15, 65G] sectors/sec\n * Which, assuming a sector size of 512B, corresponds to a range of\n * [7.5K, 33T] B/sec\n */\n#define BFQ_RATE_SHIFT\t\t16\n\n/*\n * When configured for computing the duration of the weight-raising\n * for interactive queues automatically (see the comments at the\n * beginning of this file), BFQ does it using the following formula:\n * duration = (ref_rate / r) * ref_wr_duration,\n * where r is the peak rate of the device, and ref_rate and\n * ref_wr_duration are two reference parameters.  In particular,\n * ref_rate is the peak rate of the reference storage device (see\n * below), and ref_wr_duration is about the maximum time needed, with\n * BFQ and while reading two files in parallel, to load typical large\n * applications on the reference device (see the comments on\n * max_service_from_wr below, for more details on how ref_wr_duration\n * is obtained).  In practice, the slower/faster the device at hand\n * is, the more/less it takes to load applications with respect to the\n * reference device.  Accordingly, the longer/shorter BFQ grants\n * weight raising to interactive applications.\n *\n * BFQ uses two different reference pairs (ref_rate, ref_wr_duration),\n * depending on whether the device is rotational or non-rotational.\n *\n * In the following definitions, ref_rate[0] and ref_wr_duration[0]\n * are the reference values for a rotational device, whereas\n * ref_rate[1] and ref_wr_duration[1] are the reference values for a\n * non-rotational device. The reference rates are not the actual peak\n * rates of the devices used as a reference, but slightly lower\n * values. The reason for using slightly lower values is that the\n * peak-rate estimator tends to yield slightly lower values than the\n * actual peak rate (it can yield the actual peak rate only if there\n * is only one process doing I/O, and the process does sequential\n * I/O).\n *\n * The reference peak rates are measured in sectors/usec, left-shifted\n * by BFQ_RATE_SHIFT.\n */\nstatic int ref_rate[2] = {14000, 33000};\n/*\n * To improve readability, a conversion function is used to initialize\n * the following array, which entails that the array can be\n * initialized only in a function.\n */\nstatic int ref_wr_duration[2];\n\n/*\n * BFQ uses the above-detailed, time-based weight-raising mechanism to\n * privilege interactive tasks. This mechanism is vulnerable to the\n * following false positives: I/O-bound applications that will go on\n * doing I/O for much longer than the duration of weight\n * raising. These applications have basically no benefit from being\n * weight-raised at the beginning of their I/O. On the opposite end,\n * while being weight-raised, these applications\n * a) unjustly steal throughput to applications that may actually need\n * low latency;\n * b) make BFQ uselessly perform device idling; device idling results\n * in loss of device throughput with most flash-based storage, and may\n * increase latencies when used purposelessly.\n *\n * BFQ tries to reduce these problems, by adopting the following\n * countermeasure. To introduce this countermeasure, we need first to\n * finish explaining how the duration of weight-raising for\n * interactive tasks is computed.\n *\n * For a bfq_queue deemed as interactive, the duration of weight\n * raising is dynamically adjusted, as a function of the estimated\n * peak rate of the device, so as to be equal to the time needed to\n * execute the 'largest' interactive task we benchmarked so far. By\n * largest task, we mean the task for which each involved process has\n * to do more I/O than for any of the other tasks we benchmarked. This\n * reference interactive task is the start-up of LibreOffice Writer,\n * and in this task each process/bfq_queue needs to have at most ~110K\n * sectors transferred.\n *\n * This last piece of information enables BFQ to reduce the actual\n * duration of weight-raising for at least one class of I/O-bound\n * applications: those doing sequential or quasi-sequential I/O. An\n * example is file copy. In fact, once started, the main I/O-bound\n * processes of these applications usually consume the above 110K\n * sectors in much less time than the processes of an application that\n * is starting, because these I/O-bound processes will greedily devote\n * almost all their CPU cycles only to their target,\n * throughput-friendly I/O operations. This is even more true if BFQ\n * happens to be underestimating the device peak rate, and thus\n * overestimating the duration of weight raising. But, according to\n * our measurements, once transferred 110K sectors, these processes\n * have no right to be weight-raised any longer.\n *\n * Basing on the last consideration, BFQ ends weight-raising for a\n * bfq_queue if the latter happens to have received an amount of\n * service at least equal to the following constant. The constant is\n * set to slightly more than 110K, to have a minimum safety margin.\n *\n * This early ending of weight-raising reduces the amount of time\n * during which interactive false positives cause the two problems\n * described at the beginning of these comments.\n */\nstatic const unsigned long max_service_from_wr = 120000;\n\n#define RQ_BIC(rq)\t\ticq_to_bic((rq)->elv.priv[0])\n#define RQ_BFQQ(rq)\t\t((rq)->elv.priv[1])\n\nstruct bfq_queue *bic_to_bfqq(struct bfq_io_cq *bic, bool is_sync)\n{\n\treturn bic->bfqq[is_sync];\n}\n\nvoid bic_set_bfqq(struct bfq_io_cq *bic, struct bfq_queue *bfqq, bool is_sync)\n{\n\tbic->bfqq[is_sync] = bfqq;\n}\n\nstruct bfq_data *bic_to_bfqd(struct bfq_io_cq *bic)\n{\n\treturn bic->icq.q->elevator->elevator_data;\n}\n\n/**\n * icq_to_bic - convert iocontext queue structure to bfq_io_cq.\n * @icq: the iocontext queue.\n */\nstatic struct bfq_io_cq *icq_to_bic(struct io_cq *icq)\n{\n\t/* bic->icq is the first member, %NULL will convert to %NULL */\n\treturn container_of(icq, struct bfq_io_cq, icq);\n}\n\n/**\n * bfq_bic_lookup - search into @ioc a bic associated to @bfqd.\n * @bfqd: the lookup key.\n * @ioc: the io_context of the process doing I/O.\n * @q: the request queue.\n */\nstatic struct bfq_io_cq *bfq_bic_lookup(struct bfq_data *bfqd,\n\t\t\t\t\tstruct io_context *ioc,\n\t\t\t\t\tstruct request_queue *q)\n{\n\tif (ioc) {\n\t\tunsigned long flags;\n\t\tstruct bfq_io_cq *icq;\n\n\t\tspin_lock_irqsave(&q->queue_lock, flags);\n\t\ticq = icq_to_bic(ioc_lookup_icq(ioc, q));\n\t\tspin_unlock_irqrestore(&q->queue_lock, flags);\n\n\t\treturn icq;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Scheduler run of queue, if there are requests pending and no one in the\n * driver that will restart queueing.\n */\nvoid bfq_schedule_dispatch(struct bfq_data *bfqd)\n{\n\tif (bfqd->queued != 0) {\n\t\tbfq_log(bfqd, \"schedule dispatch\");\n\t\tblk_mq_run_hw_queues(bfqd->queue, true);\n\t}\n}\n\n#define bfq_class_idle(bfqq)\t((bfqq)->ioprio_class == IOPRIO_CLASS_IDLE)\n\n#define bfq_sample_valid(samples)\t((samples) > 80)\n\n/*\n * Lifted from AS - choose which of rq1 and rq2 that is best served now.\n * We choose the request that is closer to the head right now.  Distance\n * behind the head is penalized and only allowed to a certain extent.\n */\nstatic struct request *bfq_choose_req(struct bfq_data *bfqd,\n\t\t\t\t      struct request *rq1,\n\t\t\t\t      struct request *rq2,\n\t\t\t\t      sector_t last)\n{\n\tsector_t s1, s2, d1 = 0, d2 = 0;\n\tunsigned long back_max;\n#define BFQ_RQ1_WRAP\t0x01 /* request 1 wraps */\n#define BFQ_RQ2_WRAP\t0x02 /* request 2 wraps */\n\tunsigned int wrap = 0; /* bit mask: requests behind the disk head? */\n\n\tif (!rq1 || rq1 == rq2)\n\t\treturn rq2;\n\tif (!rq2)\n\t\treturn rq1;\n\n\tif (rq_is_sync(rq1) && !rq_is_sync(rq2))\n\t\treturn rq1;\n\telse if (rq_is_sync(rq2) && !rq_is_sync(rq1))\n\t\treturn rq2;\n\tif ((rq1->cmd_flags & REQ_META) && !(rq2->cmd_flags & REQ_META))\n\t\treturn rq1;\n\telse if ((rq2->cmd_flags & REQ_META) && !(rq1->cmd_flags & REQ_META))\n\t\treturn rq2;\n\n\ts1 = blk_rq_pos(rq1);\n\ts2 = blk_rq_pos(rq2);\n\n\t/*\n\t * By definition, 1KiB is 2 sectors.\n\t */\n\tback_max = bfqd->bfq_back_max * 2;\n\n\t/*\n\t * Strict one way elevator _except_ in the case where we allow\n\t * short backward seeks which are biased as twice the cost of a\n\t * similar forward seek.\n\t */\n\tif (s1 >= last)\n\t\td1 = s1 - last;\n\telse if (s1 + back_max >= last)\n\t\td1 = (last - s1) * bfqd->bfq_back_penalty;\n\telse\n\t\twrap |= BFQ_RQ1_WRAP;\n\n\tif (s2 >= last)\n\t\td2 = s2 - last;\n\telse if (s2 + back_max >= last)\n\t\td2 = (last - s2) * bfqd->bfq_back_penalty;\n\telse\n\t\twrap |= BFQ_RQ2_WRAP;\n\n\t/* Found required data */\n\n\t/*\n\t * By doing switch() on the bit mask \"wrap\" we avoid having to\n\t * check two variables for all permutations: --> faster!\n\t */\n\tswitch (wrap) {\n\tcase 0: /* common case for CFQ: rq1 and rq2 not wrapped */\n\t\tif (d1 < d2)\n\t\t\treturn rq1;\n\t\telse if (d2 < d1)\n\t\t\treturn rq2;\n\n\t\tif (s1 >= s2)\n\t\t\treturn rq1;\n\t\telse\n\t\t\treturn rq2;\n\n\tcase BFQ_RQ2_WRAP:\n\t\treturn rq1;\n\tcase BFQ_RQ1_WRAP:\n\t\treturn rq2;\n\tcase BFQ_RQ1_WRAP|BFQ_RQ2_WRAP: /* both rqs wrapped */\n\tdefault:\n\t\t/*\n\t\t * Since both rqs are wrapped,\n\t\t * start with the one that's further behind head\n\t\t * (--> only *one* back seek required),\n\t\t * since back seek takes more time than forward.\n\t\t */\n\t\tif (s1 <= s2)\n\t\t\treturn rq1;\n\t\telse\n\t\t\treturn rq2;\n\t}\n}\n\n/*\n * Async I/O can easily starve sync I/O (both sync reads and sync\n * writes), by consuming all tags. Similarly, storms of sync writes,\n * such as those that sync(2) may trigger, can starve sync reads.\n * Limit depths of async I/O and sync writes so as to counter both\n * problems.\n */\nstatic void bfq_limit_depth(unsigned int op, struct blk_mq_alloc_data *data)\n{\n\tstruct bfq_data *bfqd = data->q->elevator->elevator_data;\n\n\tif (op_is_sync(op) && !op_is_write(op))\n\t\treturn;\n\n\tdata->shallow_depth =\n\t\tbfqd->word_depths[!!bfqd->wr_busy_queues][op_is_sync(op)];\n\n\tbfq_log(bfqd, \"[%s] wr_busy %d sync %d depth %u\",\n\t\t\t__func__, bfqd->wr_busy_queues, op_is_sync(op),\n\t\t\tdata->shallow_depth);\n}\n\nstatic struct bfq_queue *\nbfq_rq_pos_tree_lookup(struct bfq_data *bfqd, struct rb_root *root,\n\t\t     sector_t sector, struct rb_node **ret_parent,\n\t\t     struct rb_node ***rb_link)\n{\n\tstruct rb_node **p, *parent;\n\tstruct bfq_queue *bfqq = NULL;\n\n\tparent = NULL;\n\tp = &root->rb_node;\n\twhile (*p) {\n\t\tstruct rb_node **n;\n\n\t\tparent = *p;\n\t\tbfqq = rb_entry(parent, struct bfq_queue, pos_node);\n\n\t\t/*\n\t\t * Sort strictly based on sector. Smallest to the left,\n\t\t * largest to the right.\n\t\t */\n\t\tif (sector > blk_rq_pos(bfqq->next_rq))\n\t\t\tn = &(*p)->rb_right;\n\t\telse if (sector < blk_rq_pos(bfqq->next_rq))\n\t\t\tn = &(*p)->rb_left;\n\t\telse\n\t\t\tbreak;\n\t\tp = n;\n\t\tbfqq = NULL;\n\t}\n\n\t*ret_parent = parent;\n\tif (rb_link)\n\t\t*rb_link = p;\n\n\tbfq_log(bfqd, \"rq_pos_tree_lookup %llu: returning %d\",\n\t\t(unsigned long long)sector,\n\t\tbfqq ? bfqq->pid : 0);\n\n\treturn bfqq;\n}\n\nstatic bool bfq_too_late_for_merging(struct bfq_queue *bfqq)\n{\n\treturn bfqq->service_from_backlogged > 0 &&\n\t\ttime_is_before_jiffies(bfqq->first_IO_time +\n\t\t\t\t       bfq_merge_time_limit);\n}\n\n/*\n * The following function is not marked as __cold because it is\n * actually cold, but for the same performance goal described in the\n * comments on the likely() at the beginning of\n * bfq_setup_cooperator(). Unexpectedly, to reach an even lower\n * execution time for the case where this function is not invoked, we\n * had to add an unlikely() in each involved if().\n */\nvoid __cold\nbfq_pos_tree_add_move(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tstruct rb_node **p, *parent;\n\tstruct bfq_queue *__bfqq;\n\n\tif (bfqq->pos_root) {\n\t\trb_erase(&bfqq->pos_node, bfqq->pos_root);\n\t\tbfqq->pos_root = NULL;\n\t}\n\n\t/* oom_bfqq does not participate in queue merging */\n\tif (bfqq == &bfqd->oom_bfqq)\n\t\treturn;\n\n\t/*\n\t * bfqq cannot be merged any longer (see comments in\n\t * bfq_setup_cooperator): no point in adding bfqq into the\n\t * position tree.\n\t */\n\tif (bfq_too_late_for_merging(bfqq))\n\t\treturn;\n\n\tif (bfq_class_idle(bfqq))\n\t\treturn;\n\tif (!bfqq->next_rq)\n\t\treturn;\n\n\tbfqq->pos_root = &bfq_bfqq_to_bfqg(bfqq)->rq_pos_tree;\n\t__bfqq = bfq_rq_pos_tree_lookup(bfqd, bfqq->pos_root,\n\t\t\tblk_rq_pos(bfqq->next_rq), &parent, &p);\n\tif (!__bfqq) {\n\t\trb_link_node(&bfqq->pos_node, parent, p);\n\t\trb_insert_color(&bfqq->pos_node, bfqq->pos_root);\n\t} else\n\t\tbfqq->pos_root = NULL;\n}\n\n/*\n * The following function returns false either if every active queue\n * must receive the same share of the throughput (symmetric scenario),\n * or, as a special case, if bfqq must receive a share of the\n * throughput lower than or equal to the share that every other active\n * queue must receive.  If bfqq does sync I/O, then these are the only\n * two cases where bfqq happens to be guaranteed its share of the\n * throughput even if I/O dispatching is not plugged when bfqq remains\n * temporarily empty (for more details, see the comments in the\n * function bfq_better_to_idle()). For this reason, the return value\n * of this function is used to check whether I/O-dispatch plugging can\n * be avoided.\n *\n * The above first case (symmetric scenario) occurs when:\n * 1) all active queues have the same weight,\n * 2) all active queues belong to the same I/O-priority class,\n * 3) all active groups at the same level in the groups tree have the same\n *    weight,\n * 4) all active groups at the same level in the groups tree have the same\n *    number of children.\n *\n * Unfortunately, keeping the necessary state for evaluating exactly\n * the last two symmetry sub-conditions above would be quite complex\n * and time consuming. Therefore this function evaluates, instead,\n * only the following stronger three sub-conditions, for which it is\n * much easier to maintain the needed state:\n * 1) all active queues have the same weight,\n * 2) all active queues belong to the same I/O-priority class,\n * 3) there are no active groups.\n * In particular, the last condition is always true if hierarchical\n * support or the cgroups interface are not enabled, thus no state\n * needs to be maintained in this case.\n */\nstatic bool bfq_asymmetric_scenario(struct bfq_data *bfqd,\n\t\t\t\t   struct bfq_queue *bfqq)\n{\n\tbool smallest_weight = bfqq &&\n\t\tbfqq->weight_counter &&\n\t\tbfqq->weight_counter ==\n\t\tcontainer_of(\n\t\t\trb_first_cached(&bfqd->queue_weights_tree),\n\t\t\tstruct bfq_weight_counter,\n\t\t\tweights_node);\n\n\t/*\n\t * For queue weights to differ, queue_weights_tree must contain\n\t * at least two nodes.\n\t */\n\tbool varied_queue_weights = !smallest_weight &&\n\t\t!RB_EMPTY_ROOT(&bfqd->queue_weights_tree.rb_root) &&\n\t\t(bfqd->queue_weights_tree.rb_root.rb_node->rb_left ||\n\t\t bfqd->queue_weights_tree.rb_root.rb_node->rb_right);\n\n\tbool multiple_classes_busy =\n\t\t(bfqd->busy_queues[0] && bfqd->busy_queues[1]) ||\n\t\t(bfqd->busy_queues[0] && bfqd->busy_queues[2]) ||\n\t\t(bfqd->busy_queues[1] && bfqd->busy_queues[2]);\n\n\treturn varied_queue_weights || multiple_classes_busy\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\t       || bfqd->num_groups_with_pending_reqs > 0\n#endif\n\t\t;\n}\n\n/*\n * If the weight-counter tree passed as input contains no counter for\n * the weight of the input queue, then add that counter; otherwise just\n * increment the existing counter.\n *\n * Note that weight-counter trees contain few nodes in mostly symmetric\n * scenarios. For example, if all queues have the same weight, then the\n * weight-counter tree for the queues may contain at most one node.\n * This holds even if low_latency is on, because weight-raised queues\n * are not inserted in the tree.\n * In most scenarios, the rate at which nodes are created/destroyed\n * should be low too.\n */\nvoid bfq_weights_tree_add(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t  struct rb_root_cached *root)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\tstruct rb_node **new = &(root->rb_root.rb_node), *parent = NULL;\n\tbool leftmost = true;\n\n\t/*\n\t * Do not insert if the queue is already associated with a\n\t * counter, which happens if:\n\t *   1) a request arrival has caused the queue to become both\n\t *      non-weight-raised, and hence change its weight, and\n\t *      backlogged; in this respect, each of the two events\n\t *      causes an invocation of this function,\n\t *   2) this is the invocation of this function caused by the\n\t *      second event. This second invocation is actually useless,\n\t *      and we handle this fact by exiting immediately. More\n\t *      efficient or clearer solutions might possibly be adopted.\n\t */\n\tif (bfqq->weight_counter)\n\t\treturn;\n\n\twhile (*new) {\n\t\tstruct bfq_weight_counter *__counter = container_of(*new,\n\t\t\t\t\t\tstruct bfq_weight_counter,\n\t\t\t\t\t\tweights_node);\n\t\tparent = *new;\n\n\t\tif (entity->weight == __counter->weight) {\n\t\t\tbfqq->weight_counter = __counter;\n\t\t\tgoto inc_counter;\n\t\t}\n\t\tif (entity->weight < __counter->weight)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse {\n\t\t\tnew = &((*new)->rb_right);\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\tbfqq->weight_counter = kzalloc(sizeof(struct bfq_weight_counter),\n\t\t\t\t       GFP_ATOMIC);\n\n\t/*\n\t * In the unlucky event of an allocation failure, we just\n\t * exit. This will cause the weight of queue to not be\n\t * considered in bfq_asymmetric_scenario, which, in its turn,\n\t * causes the scenario to be deemed wrongly symmetric in case\n\t * bfqq's weight would have been the only weight making the\n\t * scenario asymmetric.  On the bright side, no unbalance will\n\t * however occur when bfqq becomes inactive again (the\n\t * invocation of this function is triggered by an activation\n\t * of queue).  In fact, bfq_weights_tree_remove does nothing\n\t * if !bfqq->weight_counter.\n\t */\n\tif (unlikely(!bfqq->weight_counter))\n\t\treturn;\n\n\tbfqq->weight_counter->weight = entity->weight;\n\trb_link_node(&bfqq->weight_counter->weights_node, parent, new);\n\trb_insert_color_cached(&bfqq->weight_counter->weights_node, root,\n\t\t\t\tleftmost);\n\ninc_counter:\n\tbfqq->weight_counter->num_active++;\n\tbfqq->ref++;\n}\n\n/*\n * Decrement the weight counter associated with the queue, and, if the\n * counter reaches 0, remove the counter from the tree.\n * See the comments to the function bfq_weights_tree_add() for considerations\n * about overhead.\n */\nvoid __bfq_weights_tree_remove(struct bfq_data *bfqd,\n\t\t\t       struct bfq_queue *bfqq,\n\t\t\t       struct rb_root_cached *root)\n{\n\tif (!bfqq->weight_counter)\n\t\treturn;\n\n\tbfqq->weight_counter->num_active--;\n\tif (bfqq->weight_counter->num_active > 0)\n\t\tgoto reset_entity_pointer;\n\n\trb_erase_cached(&bfqq->weight_counter->weights_node, root);\n\tkfree(bfqq->weight_counter);\n\nreset_entity_pointer:\n\tbfqq->weight_counter = NULL;\n\tbfq_put_queue(bfqq);\n}\n\n/*\n * Invoke __bfq_weights_tree_remove on bfqq and decrement the number\n * of active groups for each queue's inactive parent entity.\n */\nvoid bfq_weights_tree_remove(struct bfq_data *bfqd,\n\t\t\t     struct bfq_queue *bfqq)\n{\n\tstruct bfq_entity *entity = bfqq->entity.parent;\n\n\tfor_each_entity(entity) {\n\t\tstruct bfq_sched_data *sd = entity->my_sched_data;\n\n\t\tif (sd->next_in_service || sd->in_service_entity) {\n\t\t\t/*\n\t\t\t * entity is still active, because either\n\t\t\t * next_in_service or in_service_entity is not\n\t\t\t * NULL (see the comments on the definition of\n\t\t\t * next_in_service for details on why\n\t\t\t * in_service_entity must be checked too).\n\t\t\t *\n\t\t\t * As a consequence, its parent entities are\n\t\t\t * active as well, and thus this loop must\n\t\t\t * stop here.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The decrement of num_groups_with_pending_reqs is\n\t\t * not performed immediately upon the deactivation of\n\t\t * entity, but it is delayed to when it also happens\n\t\t * that the first leaf descendant bfqq of entity gets\n\t\t * all its pending requests completed. The following\n\t\t * instructions perform this delayed decrement, if\n\t\t * needed. See the comments on\n\t\t * num_groups_with_pending_reqs for details.\n\t\t */\n\t\tif (entity->in_groups_with_pending_reqs) {\n\t\t\tentity->in_groups_with_pending_reqs = false;\n\t\t\tbfqd->num_groups_with_pending_reqs--;\n\t\t}\n\t}\n\n\t/*\n\t * Next function is invoked last, because it causes bfqq to be\n\t * freed if the following holds: bfqq is not in service and\n\t * has no dispatched request. DO NOT use bfqq after the next\n\t * function invocation.\n\t */\n\t__bfq_weights_tree_remove(bfqd, bfqq,\n\t\t\t\t  &bfqd->queue_weights_tree);\n}\n\n/*\n * Return expired entry, or NULL to just start from scratch in rbtree.\n */\nstatic struct request *bfq_check_fifo(struct bfq_queue *bfqq,\n\t\t\t\t      struct request *last)\n{\n\tstruct request *rq;\n\n\tif (bfq_bfqq_fifo_expire(bfqq))\n\t\treturn NULL;\n\n\tbfq_mark_bfqq_fifo_expire(bfqq);\n\n\trq = rq_entry_fifo(bfqq->fifo.next);\n\n\tif (rq == last || ktime_get_ns() < rq->fifo_time)\n\t\treturn NULL;\n\n\tbfq_log_bfqq(bfqq->bfqd, bfqq, \"check_fifo: returned %p\", rq);\n\treturn rq;\n}\n\nstatic struct request *bfq_find_next_rq(struct bfq_data *bfqd,\n\t\t\t\t\tstruct bfq_queue *bfqq,\n\t\t\t\t\tstruct request *last)\n{\n\tstruct rb_node *rbnext = rb_next(&last->rb_node);\n\tstruct rb_node *rbprev = rb_prev(&last->rb_node);\n\tstruct request *next, *prev = NULL;\n\n\t/* Follow expired path, else get first next available. */\n\tnext = bfq_check_fifo(bfqq, last);\n\tif (next)\n\t\treturn next;\n\n\tif (rbprev)\n\t\tprev = rb_entry_rq(rbprev);\n\n\tif (rbnext)\n\t\tnext = rb_entry_rq(rbnext);\n\telse {\n\t\trbnext = rb_first(&bfqq->sort_list);\n\t\tif (rbnext && rbnext != &last->rb_node)\n\t\t\tnext = rb_entry_rq(rbnext);\n\t}\n\n\treturn bfq_choose_req(bfqd, next, prev, blk_rq_pos(last));\n}\n\n/* see the definition of bfq_async_charge_factor for details */\nstatic unsigned long bfq_serv_to_charge(struct request *rq,\n\t\t\t\t\tstruct bfq_queue *bfqq)\n{\n\tif (bfq_bfqq_sync(bfqq) || bfqq->wr_coeff > 1 ||\n\t    bfq_asymmetric_scenario(bfqq->bfqd, bfqq))\n\t\treturn blk_rq_sectors(rq);\n\n\treturn blk_rq_sectors(rq) * bfq_async_charge_factor;\n}\n\n/**\n * bfq_updated_next_req - update the queue after a new next_rq selection.\n * @bfqd: the device data the queue belongs to.\n * @bfqq: the queue to update.\n *\n * If the first request of a queue changes we make sure that the queue\n * has enough budget to serve at least its first request (if the\n * request has grown).  We do this because if the queue has not enough\n * budget for its first request, it has to go through two dispatch\n * rounds to actually get it dispatched.\n */\nstatic void bfq_updated_next_req(struct bfq_data *bfqd,\n\t\t\t\t struct bfq_queue *bfqq)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\tstruct request *next_rq = bfqq->next_rq;\n\tunsigned long new_budget;\n\n\tif (!next_rq)\n\t\treturn;\n\n\tif (bfqq == bfqd->in_service_queue)\n\t\t/*\n\t\t * In order not to break guarantees, budgets cannot be\n\t\t * changed after an entity has been selected.\n\t\t */\n\t\treturn;\n\n\tnew_budget = max_t(unsigned long,\n\t\t\t   max_t(unsigned long, bfqq->max_budget,\n\t\t\t\t bfq_serv_to_charge(next_rq, bfqq)),\n\t\t\t   entity->service);\n\tif (entity->budget != new_budget) {\n\t\tentity->budget = new_budget;\n\t\tbfq_log_bfqq(bfqd, bfqq, \"updated next rq: new budget %lu\",\n\t\t\t\t\t new_budget);\n\t\tbfq_requeue_bfqq(bfqd, bfqq, false);\n\t}\n}\n\nstatic unsigned int bfq_wr_duration(struct bfq_data *bfqd)\n{\n\tu64 dur;\n\n\tif (bfqd->bfq_wr_max_time > 0)\n\t\treturn bfqd->bfq_wr_max_time;\n\n\tdur = bfqd->rate_dur_prod;\n\tdo_div(dur, bfqd->peak_rate);\n\n\t/*\n\t * Limit duration between 3 and 25 seconds. The upper limit\n\t * has been conservatively set after the following worst case:\n\t * on a QEMU/KVM virtual machine\n\t * - running in a slow PC\n\t * - with a virtual disk stacked on a slow low-end 5400rpm HDD\n\t * - serving a heavy I/O workload, such as the sequential reading\n\t *   of several files\n\t * mplayer took 23 seconds to start, if constantly weight-raised.\n\t *\n\t * As for higher values than that accommodating the above bad\n\t * scenario, tests show that higher values would often yield\n\t * the opposite of the desired result, i.e., would worsen\n\t * responsiveness by allowing non-interactive applications to\n\t * preserve weight raising for too long.\n\t *\n\t * On the other end, lower values than 3 seconds make it\n\t * difficult for most interactive tasks to complete their jobs\n\t * before weight-raising finishes.\n\t */\n\treturn clamp_val(dur, msecs_to_jiffies(3000), msecs_to_jiffies(25000));\n}\n\n/* switch back from soft real-time to interactive weight raising */\nstatic void switch_back_to_interactive_wr(struct bfq_queue *bfqq,\n\t\t\t\t\t  struct bfq_data *bfqd)\n{\n\tbfqq->wr_coeff = bfqd->bfq_wr_coeff;\n\tbfqq->wr_cur_max_time = bfq_wr_duration(bfqd);\n\tbfqq->last_wr_start_finish = bfqq->wr_start_at_switch_to_srt;\n}\n\nstatic void\nbfq_bfqq_resume_state(struct bfq_queue *bfqq, struct bfq_data *bfqd,\n\t\t      struct bfq_io_cq *bic, bool bfq_already_existing)\n{\n\tunsigned int old_wr_coeff = bfqq->wr_coeff;\n\tbool busy = bfq_already_existing && bfq_bfqq_busy(bfqq);\n\n\tif (bic->saved_has_short_ttime)\n\t\tbfq_mark_bfqq_has_short_ttime(bfqq);\n\telse\n\t\tbfq_clear_bfqq_has_short_ttime(bfqq);\n\n\tif (bic->saved_IO_bound)\n\t\tbfq_mark_bfqq_IO_bound(bfqq);\n\telse\n\t\tbfq_clear_bfqq_IO_bound(bfqq);\n\n\tbfqq->entity.new_weight = bic->saved_weight;\n\tbfqq->ttime = bic->saved_ttime;\n\tbfqq->wr_coeff = bic->saved_wr_coeff;\n\tbfqq->wr_start_at_switch_to_srt = bic->saved_wr_start_at_switch_to_srt;\n\tbfqq->last_wr_start_finish = bic->saved_last_wr_start_finish;\n\tbfqq->wr_cur_max_time = bic->saved_wr_cur_max_time;\n\n\tif (bfqq->wr_coeff > 1 && (bfq_bfqq_in_large_burst(bfqq) ||\n\t    time_is_before_jiffies(bfqq->last_wr_start_finish +\n\t\t\t\t   bfqq->wr_cur_max_time))) {\n\t\tif (bfqq->wr_cur_max_time == bfqd->bfq_wr_rt_max_time &&\n\t\t    !bfq_bfqq_in_large_burst(bfqq) &&\n\t\t    time_is_after_eq_jiffies(bfqq->wr_start_at_switch_to_srt +\n\t\t\t\t\t     bfq_wr_duration(bfqd))) {\n\t\t\tswitch_back_to_interactive_wr(bfqq, bfqd);\n\t\t} else {\n\t\t\tbfqq->wr_coeff = 1;\n\t\t\tbfq_log_bfqq(bfqq->bfqd, bfqq,\n\t\t\t\t     \"resume state: switching off wr\");\n\t\t}\n\t}\n\n\t/* make sure weight will be updated, however we got here */\n\tbfqq->entity.prio_changed = 1;\n\n\tif (likely(!busy))\n\t\treturn;\n\n\tif (old_wr_coeff == 1 && bfqq->wr_coeff > 1)\n\t\tbfqd->wr_busy_queues++;\n\telse if (old_wr_coeff > 1 && bfqq->wr_coeff == 1)\n\t\tbfqd->wr_busy_queues--;\n}\n\nstatic int bfqq_process_refs(struct bfq_queue *bfqq)\n{\n\treturn bfqq->ref - bfqq->allocated - bfqq->entity.on_st_or_in_serv -\n\t\t(bfqq->weight_counter != NULL);\n}\n\n/* Empty burst list and add just bfqq (see comments on bfq_handle_burst) */\nstatic void bfq_reset_burst_list(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tstruct bfq_queue *item;\n\tstruct hlist_node *n;\n\n\thlist_for_each_entry_safe(item, n, &bfqd->burst_list, burst_list_node)\n\t\thlist_del_init(&item->burst_list_node);\n\n\t/*\n\t * Start the creation of a new burst list only if there is no\n\t * active queue. See comments on the conditional invocation of\n\t * bfq_handle_burst().\n\t */\n\tif (bfq_tot_busy_queues(bfqd) == 0) {\n\t\thlist_add_head(&bfqq->burst_list_node, &bfqd->burst_list);\n\t\tbfqd->burst_size = 1;\n\t} else\n\t\tbfqd->burst_size = 0;\n\n\tbfqd->burst_parent_entity = bfqq->entity.parent;\n}\n\n/* Add bfqq to the list of queues in current burst (see bfq_handle_burst) */\nstatic void bfq_add_to_burst(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\t/* Increment burst size to take into account also bfqq */\n\tbfqd->burst_size++;\n\n\tif (bfqd->burst_size == bfqd->bfq_large_burst_thresh) {\n\t\tstruct bfq_queue *pos, *bfqq_item;\n\t\tstruct hlist_node *n;\n\n\t\t/*\n\t\t * Enough queues have been activated shortly after each\n\t\t * other to consider this burst as large.\n\t\t */\n\t\tbfqd->large_burst = true;\n\n\t\t/*\n\t\t * We can now mark all queues in the burst list as\n\t\t * belonging to a large burst.\n\t\t */\n\t\thlist_for_each_entry(bfqq_item, &bfqd->burst_list,\n\t\t\t\t     burst_list_node)\n\t\t\tbfq_mark_bfqq_in_large_burst(bfqq_item);\n\t\tbfq_mark_bfqq_in_large_burst(bfqq);\n\n\t\t/*\n\t\t * From now on, and until the current burst finishes, any\n\t\t * new queue being activated shortly after the last queue\n\t\t * was inserted in the burst can be immediately marked as\n\t\t * belonging to a large burst. So the burst list is not\n\t\t * needed any more. Remove it.\n\t\t */\n\t\thlist_for_each_entry_safe(pos, n, &bfqd->burst_list,\n\t\t\t\t\t  burst_list_node)\n\t\t\thlist_del_init(&pos->burst_list_node);\n\t} else /*\n\t\t* Burst not yet large: add bfqq to the burst list. Do\n\t\t* not increment the ref counter for bfqq, because bfqq\n\t\t* is removed from the burst list before freeing bfqq\n\t\t* in put_queue.\n\t\t*/\n\t\thlist_add_head(&bfqq->burst_list_node, &bfqd->burst_list);\n}\n\n/*\n * If many queues belonging to the same group happen to be created\n * shortly after each other, then the processes associated with these\n * queues have typically a common goal. In particular, bursts of queue\n * creations are usually caused by services or applications that spawn\n * many parallel threads/processes. Examples are systemd during boot,\n * or git grep. To help these processes get their job done as soon as\n * possible, it is usually better to not grant either weight-raising\n * or device idling to their queues, unless these queues must be\n * protected from the I/O flowing through other active queues.\n *\n * In this comment we describe, firstly, the reasons why this fact\n * holds, and, secondly, the next function, which implements the main\n * steps needed to properly mark these queues so that they can then be\n * treated in a different way.\n *\n * The above services or applications benefit mostly from a high\n * throughput: the quicker the requests of the activated queues are\n * cumulatively served, the sooner the target job of these queues gets\n * completed. As a consequence, weight-raising any of these queues,\n * which also implies idling the device for it, is almost always\n * counterproductive, unless there are other active queues to isolate\n * these new queues from. If there no other active queues, then\n * weight-raising these new queues just lowers throughput in most\n * cases.\n *\n * On the other hand, a burst of queue creations may be caused also by\n * the start of an application that does not consist of a lot of\n * parallel I/O-bound threads. In fact, with a complex application,\n * several short processes may need to be executed to start-up the\n * application. In this respect, to start an application as quickly as\n * possible, the best thing to do is in any case to privilege the I/O\n * related to the application with respect to all other\n * I/O. Therefore, the best strategy to start as quickly as possible\n * an application that causes a burst of queue creations is to\n * weight-raise all the queues created during the burst. This is the\n * exact opposite of the best strategy for the other type of bursts.\n *\n * In the end, to take the best action for each of the two cases, the\n * two types of bursts need to be distinguished. Fortunately, this\n * seems relatively easy, by looking at the sizes of the bursts. In\n * particular, we found a threshold such that only bursts with a\n * larger size than that threshold are apparently caused by\n * services or commands such as systemd or git grep. For brevity,\n * hereafter we call just 'large' these bursts. BFQ *does not*\n * weight-raise queues whose creation occurs in a large burst. In\n * addition, for each of these queues BFQ performs or does not perform\n * idling depending on which choice boosts the throughput more. The\n * exact choice depends on the device and request pattern at\n * hand.\n *\n * Unfortunately, false positives may occur while an interactive task\n * is starting (e.g., an application is being started). The\n * consequence is that the queues associated with the task do not\n * enjoy weight raising as expected. Fortunately these false positives\n * are very rare. They typically occur if some service happens to\n * start doing I/O exactly when the interactive task starts.\n *\n * Turning back to the next function, it is invoked only if there are\n * no active queues (apart from active queues that would belong to the\n * same, possible burst bfqq would belong to), and it implements all\n * the steps needed to detect the occurrence of a large burst and to\n * properly mark all the queues belonging to it (so that they can then\n * be treated in a different way). This goal is achieved by\n * maintaining a \"burst list\" that holds, temporarily, the queues that\n * belong to the burst in progress. The list is then used to mark\n * these queues as belonging to a large burst if the burst does become\n * large. The main steps are the following.\n *\n * . when the very first queue is created, the queue is inserted into the\n *   list (as it could be the first queue in a possible burst)\n *\n * . if the current burst has not yet become large, and a queue Q that does\n *   not yet belong to the burst is activated shortly after the last time\n *   at which a new queue entered the burst list, then the function appends\n *   Q to the burst list\n *\n * . if, as a consequence of the previous step, the burst size reaches\n *   the large-burst threshold, then\n *\n *     . all the queues in the burst list are marked as belonging to a\n *       large burst\n *\n *     . the burst list is deleted; in fact, the burst list already served\n *       its purpose (keeping temporarily track of the queues in a burst,\n *       so as to be able to mark them as belonging to a large burst in the\n *       previous sub-step), and now is not needed any more\n *\n *     . the device enters a large-burst mode\n *\n * . if a queue Q that does not belong to the burst is created while\n *   the device is in large-burst mode and shortly after the last time\n *   at which a queue either entered the burst list or was marked as\n *   belonging to the current large burst, then Q is immediately marked\n *   as belonging to a large burst.\n *\n * . if a queue Q that does not belong to the burst is created a while\n *   later, i.e., not shortly after, than the last time at which a queue\n *   either entered the burst list or was marked as belonging to the\n *   current large burst, then the current burst is deemed as finished and:\n *\n *        . the large-burst mode is reset if set\n *\n *        . the burst list is emptied\n *\n *        . Q is inserted in the burst list, as Q may be the first queue\n *          in a possible new burst (then the burst list contains just Q\n *          after this step).\n */\nstatic void bfq_handle_burst(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\t/*\n\t * If bfqq is already in the burst list or is part of a large\n\t * burst, or finally has just been split, then there is\n\t * nothing else to do.\n\t */\n\tif (!hlist_unhashed(&bfqq->burst_list_node) ||\n\t    bfq_bfqq_in_large_burst(bfqq) ||\n\t    time_is_after_eq_jiffies(bfqq->split_time +\n\t\t\t\t     msecs_to_jiffies(10)))\n\t\treturn;\n\n\t/*\n\t * If bfqq's creation happens late enough, or bfqq belongs to\n\t * a different group than the burst group, then the current\n\t * burst is finished, and related data structures must be\n\t * reset.\n\t *\n\t * In this respect, consider the special case where bfqq is\n\t * the very first queue created after BFQ is selected for this\n\t * device. In this case, last_ins_in_burst and\n\t * burst_parent_entity are not yet significant when we get\n\t * here. But it is easy to verify that, whether or not the\n\t * following condition is true, bfqq will end up being\n\t * inserted into the burst list. In particular the list will\n\t * happen to contain only bfqq. And this is exactly what has\n\t * to happen, as bfqq may be the first queue of the first\n\t * burst.\n\t */\n\tif (time_is_before_jiffies(bfqd->last_ins_in_burst +\n\t    bfqd->bfq_burst_interval) ||\n\t    bfqq->entity.parent != bfqd->burst_parent_entity) {\n\t\tbfqd->large_burst = false;\n\t\tbfq_reset_burst_list(bfqd, bfqq);\n\t\tgoto end;\n\t}\n\n\t/*\n\t * If we get here, then bfqq is being activated shortly after the\n\t * last queue. So, if the current burst is also large, we can mark\n\t * bfqq as belonging to this large burst immediately.\n\t */\n\tif (bfqd->large_burst) {\n\t\tbfq_mark_bfqq_in_large_burst(bfqq);\n\t\tgoto end;\n\t}\n\n\t/*\n\t * If we get here, then a large-burst state has not yet been\n\t * reached, but bfqq is being activated shortly after the last\n\t * queue. Then we add bfqq to the burst.\n\t */\n\tbfq_add_to_burst(bfqd, bfqq);\nend:\n\t/*\n\t * At this point, bfqq either has been added to the current\n\t * burst or has caused the current burst to terminate and a\n\t * possible new burst to start. In particular, in the second\n\t * case, bfqq has become the first queue in the possible new\n\t * burst.  In both cases last_ins_in_burst needs to be moved\n\t * forward.\n\t */\n\tbfqd->last_ins_in_burst = jiffies;\n}\n\nstatic int bfq_bfqq_budget_left(struct bfq_queue *bfqq)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\treturn entity->budget - entity->service;\n}\n\n/*\n * If enough samples have been computed, return the current max budget\n * stored in bfqd, which is dynamically updated according to the\n * estimated disk peak rate; otherwise return the default max budget\n */\nstatic int bfq_max_budget(struct bfq_data *bfqd)\n{\n\tif (bfqd->budgets_assigned < bfq_stats_min_budgets)\n\t\treturn bfq_default_max_budget;\n\telse\n\t\treturn bfqd->bfq_max_budget;\n}\n\n/*\n * Return min budget, which is a fraction of the current or default\n * max budget (trying with 1/32)\n */\nstatic int bfq_min_budget(struct bfq_data *bfqd)\n{\n\tif (bfqd->budgets_assigned < bfq_stats_min_budgets)\n\t\treturn bfq_default_max_budget / 32;\n\telse\n\t\treturn bfqd->bfq_max_budget / 32;\n}\n\n/*\n * The next function, invoked after the input queue bfqq switches from\n * idle to busy, updates the budget of bfqq. The function also tells\n * whether the in-service queue should be expired, by returning\n * true. The purpose of expiring the in-service queue is to give bfqq\n * the chance to possibly preempt the in-service queue, and the reason\n * for preempting the in-service queue is to achieve one of the two\n * goals below.\n *\n * 1. Guarantee to bfqq its reserved bandwidth even if bfqq has\n * expired because it has remained idle. In particular, bfqq may have\n * expired for one of the following two reasons:\n *\n * - BFQQE_NO_MORE_REQUESTS bfqq did not enjoy any device idling\n *   and did not make it to issue a new request before its last\n *   request was served;\n *\n * - BFQQE_TOO_IDLE bfqq did enjoy device idling, but did not issue\n *   a new request before the expiration of the idling-time.\n *\n * Even if bfqq has expired for one of the above reasons, the process\n * associated with the queue may be however issuing requests greedily,\n * and thus be sensitive to the bandwidth it receives (bfqq may have\n * remained idle for other reasons: CPU high load, bfqq not enjoying\n * idling, I/O throttling somewhere in the path from the process to\n * the I/O scheduler, ...). But if, after every expiration for one of\n * the above two reasons, bfqq has to wait for the service of at least\n * one full budget of another queue before being served again, then\n * bfqq is likely to get a much lower bandwidth or resource time than\n * its reserved ones. To address this issue, two countermeasures need\n * to be taken.\n *\n * First, the budget and the timestamps of bfqq need to be updated in\n * a special way on bfqq reactivation: they need to be updated as if\n * bfqq did not remain idle and did not expire. In fact, if they are\n * computed as if bfqq expired and remained idle until reactivation,\n * then the process associated with bfqq is treated as if, instead of\n * being greedy, it stopped issuing requests when bfqq remained idle,\n * and restarts issuing requests only on this reactivation. In other\n * words, the scheduler does not help the process recover the \"service\n * hole\" between bfqq expiration and reactivation. As a consequence,\n * the process receives a lower bandwidth than its reserved one. In\n * contrast, to recover this hole, the budget must be updated as if\n * bfqq was not expired at all before this reactivation, i.e., it must\n * be set to the value of the remaining budget when bfqq was\n * expired. Along the same line, timestamps need to be assigned the\n * value they had the last time bfqq was selected for service, i.e.,\n * before last expiration. Thus timestamps need to be back-shifted\n * with respect to their normal computation (see [1] for more details\n * on this tricky aspect).\n *\n * Secondly, to allow the process to recover the hole, the in-service\n * queue must be expired too, to give bfqq the chance to preempt it\n * immediately. In fact, if bfqq has to wait for a full budget of the\n * in-service queue to be completed, then it may become impossible to\n * let the process recover the hole, even if the back-shifted\n * timestamps of bfqq are lower than those of the in-service queue. If\n * this happens for most or all of the holes, then the process may not\n * receive its reserved bandwidth. In this respect, it is worth noting\n * that, being the service of outstanding requests unpreemptible, a\n * little fraction of the holes may however be unrecoverable, thereby\n * causing a little loss of bandwidth.\n *\n * The last important point is detecting whether bfqq does need this\n * bandwidth recovery. In this respect, the next function deems the\n * process associated with bfqq greedy, and thus allows it to recover\n * the hole, if: 1) the process is waiting for the arrival of a new\n * request (which implies that bfqq expired for one of the above two\n * reasons), and 2) such a request has arrived soon. The first\n * condition is controlled through the flag non_blocking_wait_rq,\n * while the second through the flag arrived_in_time. If both\n * conditions hold, then the function computes the budget in the\n * above-described special way, and signals that the in-service queue\n * should be expired. Timestamp back-shifting is done later in\n * __bfq_activate_entity.\n *\n * 2. Reduce latency. Even if timestamps are not backshifted to let\n * the process associated with bfqq recover a service hole, bfqq may\n * however happen to have, after being (re)activated, a lower finish\n * timestamp than the in-service queue.\t That is, the next budget of\n * bfqq may have to be completed before the one of the in-service\n * queue. If this is the case, then preempting the in-service queue\n * allows this goal to be achieved, apart from the unpreemptible,\n * outstanding requests mentioned above.\n *\n * Unfortunately, regardless of which of the above two goals one wants\n * to achieve, service trees need first to be updated to know whether\n * the in-service queue must be preempted. To have service trees\n * correctly updated, the in-service queue must be expired and\n * rescheduled, and bfqq must be scheduled too. This is one of the\n * most costly operations (in future versions, the scheduling\n * mechanism may be re-designed in such a way to make it possible to\n * know whether preemption is needed without needing to update service\n * trees). In addition, queue preemptions almost always cause random\n * I/O, which may in turn cause loss of throughput. Finally, there may\n * even be no in-service queue when the next function is invoked (so,\n * no queue to compare timestamps with). Because of these facts, the\n * next function adopts the following simple scheme to avoid costly\n * operations, too frequent preemptions and too many dependencies on\n * the state of the scheduler: it requests the expiration of the\n * in-service queue (unconditionally) only for queues that need to\n * recover a hole. Then it delegates to other parts of the code the\n * responsibility of handling the above case 2.\n */\nstatic bool bfq_bfqq_update_budg_for_activation(struct bfq_data *bfqd,\n\t\t\t\t\t\tstruct bfq_queue *bfqq,\n\t\t\t\t\t\tbool arrived_in_time)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\t/*\n\t * In the next compound condition, we check also whether there\n\t * is some budget left, because otherwise there is no point in\n\t * trying to go on serving bfqq with this same budget: bfqq\n\t * would be expired immediately after being selected for\n\t * service. This would only cause useless overhead.\n\t */\n\tif (bfq_bfqq_non_blocking_wait_rq(bfqq) && arrived_in_time &&\n\t    bfq_bfqq_budget_left(bfqq) > 0) {\n\t\t/*\n\t\t * We do not clear the flag non_blocking_wait_rq here, as\n\t\t * the latter is used in bfq_activate_bfqq to signal\n\t\t * that timestamps need to be back-shifted (and is\n\t\t * cleared right after).\n\t\t */\n\n\t\t/*\n\t\t * In next assignment we rely on that either\n\t\t * entity->service or entity->budget are not updated\n\t\t * on expiration if bfqq is empty (see\n\t\t * __bfq_bfqq_recalc_budget). Thus both quantities\n\t\t * remain unchanged after such an expiration, and the\n\t\t * following statement therefore assigns to\n\t\t * entity->budget the remaining budget on such an\n\t\t * expiration.\n\t\t */\n\t\tentity->budget = min_t(unsigned long,\n\t\t\t\t       bfq_bfqq_budget_left(bfqq),\n\t\t\t\t       bfqq->max_budget);\n\n\t\t/*\n\t\t * At this point, we have used entity->service to get\n\t\t * the budget left (needed for updating\n\t\t * entity->budget). Thus we finally can, and have to,\n\t\t * reset entity->service. The latter must be reset\n\t\t * because bfqq would otherwise be charged again for\n\t\t * the service it has received during its previous\n\t\t * service slot(s).\n\t\t */\n\t\tentity->service = 0;\n\n\t\treturn true;\n\t}\n\n\t/*\n\t * We can finally complete expiration, by setting service to 0.\n\t */\n\tentity->service = 0;\n\tentity->budget = max_t(unsigned long, bfqq->max_budget,\n\t\t\t       bfq_serv_to_charge(bfqq->next_rq, bfqq));\n\tbfq_clear_bfqq_non_blocking_wait_rq(bfqq);\n\treturn false;\n}\n\n/*\n * Return the farthest past time instant according to jiffies\n * macros.\n */\nstatic unsigned long bfq_smallest_from_now(void)\n{\n\treturn jiffies - MAX_JIFFY_OFFSET;\n}\n\nstatic void bfq_update_bfqq_wr_on_rq_arrival(struct bfq_data *bfqd,\n\t\t\t\t\t     struct bfq_queue *bfqq,\n\t\t\t\t\t     unsigned int old_wr_coeff,\n\t\t\t\t\t     bool wr_or_deserves_wr,\n\t\t\t\t\t     bool interactive,\n\t\t\t\t\t     bool in_burst,\n\t\t\t\t\t     bool soft_rt)\n{\n\tif (old_wr_coeff == 1 && wr_or_deserves_wr) {\n\t\t/* start a weight-raising period */\n\t\tif (interactive) {\n\t\t\tbfqq->service_from_wr = 0;\n\t\t\tbfqq->wr_coeff = bfqd->bfq_wr_coeff;\n\t\t\tbfqq->wr_cur_max_time = bfq_wr_duration(bfqd);\n\t\t} else {\n\t\t\t/*\n\t\t\t * No interactive weight raising in progress\n\t\t\t * here: assign minus infinity to\n\t\t\t * wr_start_at_switch_to_srt, to make sure\n\t\t\t * that, at the end of the soft-real-time\n\t\t\t * weight raising periods that is starting\n\t\t\t * now, no interactive weight-raising period\n\t\t\t * may be wrongly considered as still in\n\t\t\t * progress (and thus actually started by\n\t\t\t * mistake).\n\t\t\t */\n\t\t\tbfqq->wr_start_at_switch_to_srt =\n\t\t\t\tbfq_smallest_from_now();\n\t\t\tbfqq->wr_coeff = bfqd->bfq_wr_coeff *\n\t\t\t\tBFQ_SOFTRT_WEIGHT_FACTOR;\n\t\t\tbfqq->wr_cur_max_time =\n\t\t\t\tbfqd->bfq_wr_rt_max_time;\n\t\t}\n\n\t\t/*\n\t\t * If needed, further reduce budget to make sure it is\n\t\t * close to bfqq's backlog, so as to reduce the\n\t\t * scheduling-error component due to a too large\n\t\t * budget. Do not care about throughput consequences,\n\t\t * but only about latency. Finally, do not assign a\n\t\t * too small budget either, to avoid increasing\n\t\t * latency by causing too frequent expirations.\n\t\t */\n\t\tbfqq->entity.budget = min_t(unsigned long,\n\t\t\t\t\t    bfqq->entity.budget,\n\t\t\t\t\t    2 * bfq_min_budget(bfqd));\n\t} else if (old_wr_coeff > 1) {\n\t\tif (interactive) { /* update wr coeff and duration */\n\t\t\tbfqq->wr_coeff = bfqd->bfq_wr_coeff;\n\t\t\tbfqq->wr_cur_max_time = bfq_wr_duration(bfqd);\n\t\t} else if (in_burst)\n\t\t\tbfqq->wr_coeff = 1;\n\t\telse if (soft_rt) {\n\t\t\t/*\n\t\t\t * The application is now or still meeting the\n\t\t\t * requirements for being deemed soft rt.  We\n\t\t\t * can then correctly and safely (re)charge\n\t\t\t * the weight-raising duration for the\n\t\t\t * application with the weight-raising\n\t\t\t * duration for soft rt applications.\n\t\t\t *\n\t\t\t * In particular, doing this recharge now, i.e.,\n\t\t\t * before the weight-raising period for the\n\t\t\t * application finishes, reduces the probability\n\t\t\t * of the following negative scenario:\n\t\t\t * 1) the weight of a soft rt application is\n\t\t\t *    raised at startup (as for any newly\n\t\t\t *    created application),\n\t\t\t * 2) since the application is not interactive,\n\t\t\t *    at a certain time weight-raising is\n\t\t\t *    stopped for the application,\n\t\t\t * 3) at that time the application happens to\n\t\t\t *    still have pending requests, and hence\n\t\t\t *    is destined to not have a chance to be\n\t\t\t *    deemed soft rt before these requests are\n\t\t\t *    completed (see the comments to the\n\t\t\t *    function bfq_bfqq_softrt_next_start()\n\t\t\t *    for details on soft rt detection),\n\t\t\t * 4) these pending requests experience a high\n\t\t\t *    latency because the application is not\n\t\t\t *    weight-raised while they are pending.\n\t\t\t */\n\t\t\tif (bfqq->wr_cur_max_time !=\n\t\t\t\tbfqd->bfq_wr_rt_max_time) {\n\t\t\t\tbfqq->wr_start_at_switch_to_srt =\n\t\t\t\t\tbfqq->last_wr_start_finish;\n\n\t\t\t\tbfqq->wr_cur_max_time =\n\t\t\t\t\tbfqd->bfq_wr_rt_max_time;\n\t\t\t\tbfqq->wr_coeff = bfqd->bfq_wr_coeff *\n\t\t\t\t\tBFQ_SOFTRT_WEIGHT_FACTOR;\n\t\t\t}\n\t\t\tbfqq->last_wr_start_finish = jiffies;\n\t\t}\n\t}\n}\n\nstatic bool bfq_bfqq_idle_for_long_time(struct bfq_data *bfqd,\n\t\t\t\t\tstruct bfq_queue *bfqq)\n{\n\treturn bfqq->dispatched == 0 &&\n\t\ttime_is_before_jiffies(\n\t\t\tbfqq->budget_timeout +\n\t\t\tbfqd->bfq_wr_min_idle_time);\n}\n\n\n/*\n * Return true if bfqq is in a higher priority class, or has a higher\n * weight than the in-service queue.\n */\nstatic bool bfq_bfqq_higher_class_or_weight(struct bfq_queue *bfqq,\n\t\t\t\t\t    struct bfq_queue *in_serv_bfqq)\n{\n\tint bfqq_weight, in_serv_weight;\n\n\tif (bfqq->ioprio_class < in_serv_bfqq->ioprio_class)\n\t\treturn true;\n\n\tif (in_serv_bfqq->entity.parent == bfqq->entity.parent) {\n\t\tbfqq_weight = bfqq->entity.weight;\n\t\tin_serv_weight = in_serv_bfqq->entity.weight;\n\t} else {\n\t\tif (bfqq->entity.parent)\n\t\t\tbfqq_weight = bfqq->entity.parent->weight;\n\t\telse\n\t\t\tbfqq_weight = bfqq->entity.weight;\n\t\tif (in_serv_bfqq->entity.parent)\n\t\t\tin_serv_weight = in_serv_bfqq->entity.parent->weight;\n\t\telse\n\t\t\tin_serv_weight = in_serv_bfqq->entity.weight;\n\t}\n\n\treturn bfqq_weight > in_serv_weight;\n}\n\nstatic void bfq_bfqq_handle_idle_busy_switch(struct bfq_data *bfqd,\n\t\t\t\t\t     struct bfq_queue *bfqq,\n\t\t\t\t\t     int old_wr_coeff,\n\t\t\t\t\t     struct request *rq,\n\t\t\t\t\t     bool *interactive)\n{\n\tbool soft_rt, in_burst,\twr_or_deserves_wr,\n\t\tbfqq_wants_to_preempt,\n\t\tidle_for_long_time = bfq_bfqq_idle_for_long_time(bfqd, bfqq),\n\t\t/*\n\t\t * See the comments on\n\t\t * bfq_bfqq_update_budg_for_activation for\n\t\t * details on the usage of the next variable.\n\t\t */\n\t\tarrived_in_time =  ktime_get_ns() <=\n\t\t\tbfqq->ttime.last_end_request +\n\t\t\tbfqd->bfq_slice_idle * 3;\n\n\n\t/*\n\t * bfqq deserves to be weight-raised if:\n\t * - it is sync,\n\t * - it does not belong to a large burst,\n\t * - it has been idle for enough time or is soft real-time,\n\t * - is linked to a bfq_io_cq (it is not shared in any sense).\n\t */\n\tin_burst = bfq_bfqq_in_large_burst(bfqq);\n\tsoft_rt = bfqd->bfq_wr_max_softrt_rate > 0 &&\n\t\t!BFQQ_TOTALLY_SEEKY(bfqq) &&\n\t\t!in_burst &&\n\t\ttime_is_before_jiffies(bfqq->soft_rt_next_start) &&\n\t\tbfqq->dispatched == 0;\n\t*interactive = !in_burst && idle_for_long_time;\n\twr_or_deserves_wr = bfqd->low_latency &&\n\t\t(bfqq->wr_coeff > 1 ||\n\t\t (bfq_bfqq_sync(bfqq) &&\n\t\t  bfqq->bic && (*interactive || soft_rt)));\n\n\t/*\n\t * Using the last flag, update budget and check whether bfqq\n\t * may want to preempt the in-service queue.\n\t */\n\tbfqq_wants_to_preempt =\n\t\tbfq_bfqq_update_budg_for_activation(bfqd, bfqq,\n\t\t\t\t\t\t    arrived_in_time);\n\n\t/*\n\t * If bfqq happened to be activated in a burst, but has been\n\t * idle for much more than an interactive queue, then we\n\t * assume that, in the overall I/O initiated in the burst, the\n\t * I/O associated with bfqq is finished. So bfqq does not need\n\t * to be treated as a queue belonging to a burst\n\t * anymore. Accordingly, we reset bfqq's in_large_burst flag\n\t * if set, and remove bfqq from the burst list if it's\n\t * there. We do not decrement burst_size, because the fact\n\t * that bfqq does not need to belong to the burst list any\n\t * more does not invalidate the fact that bfqq was created in\n\t * a burst.\n\t */\n\tif (likely(!bfq_bfqq_just_created(bfqq)) &&\n\t    idle_for_long_time &&\n\t    time_is_before_jiffies(\n\t\t    bfqq->budget_timeout +\n\t\t    msecs_to_jiffies(10000))) {\n\t\thlist_del_init(&bfqq->burst_list_node);\n\t\tbfq_clear_bfqq_in_large_burst(bfqq);\n\t}\n\n\tbfq_clear_bfqq_just_created(bfqq);\n\n\n\tif (!bfq_bfqq_IO_bound(bfqq)) {\n\t\tif (arrived_in_time) {\n\t\t\tbfqq->requests_within_timer++;\n\t\t\tif (bfqq->requests_within_timer >=\n\t\t\t    bfqd->bfq_requests_within_timer)\n\t\t\t\tbfq_mark_bfqq_IO_bound(bfqq);\n\t\t} else\n\t\t\tbfqq->requests_within_timer = 0;\n\t}\n\n\tif (bfqd->low_latency) {\n\t\tif (unlikely(time_is_after_jiffies(bfqq->split_time)))\n\t\t\t/* wraparound */\n\t\t\tbfqq->split_time =\n\t\t\t\tjiffies - bfqd->bfq_wr_min_idle_time - 1;\n\n\t\tif (time_is_before_jiffies(bfqq->split_time +\n\t\t\t\t\t   bfqd->bfq_wr_min_idle_time)) {\n\t\t\tbfq_update_bfqq_wr_on_rq_arrival(bfqd, bfqq,\n\t\t\t\t\t\t\t old_wr_coeff,\n\t\t\t\t\t\t\t wr_or_deserves_wr,\n\t\t\t\t\t\t\t *interactive,\n\t\t\t\t\t\t\t in_burst,\n\t\t\t\t\t\t\t soft_rt);\n\n\t\t\tif (old_wr_coeff != bfqq->wr_coeff)\n\t\t\t\tbfqq->entity.prio_changed = 1;\n\t\t}\n\t}\n\n\tbfqq->last_idle_bklogged = jiffies;\n\tbfqq->service_from_backlogged = 0;\n\tbfq_clear_bfqq_softrt_update(bfqq);\n\n\tbfq_add_bfqq_busy(bfqd, bfqq);\n\n\t/*\n\t * Expire in-service queue only if preemption may be needed\n\t * for guarantees. In particular, we care only about two\n\t * cases. The first is that bfqq has to recover a service\n\t * hole, as explained in the comments on\n\t * bfq_bfqq_update_budg_for_activation(), i.e., that\n\t * bfqq_wants_to_preempt is true. However, if bfqq does not\n\t * carry time-critical I/O, then bfqq's bandwidth is less\n\t * important than that of queues that carry time-critical I/O.\n\t * So, as a further constraint, we consider this case only if\n\t * bfqq is at least as weight-raised, i.e., at least as time\n\t * critical, as the in-service queue.\n\t *\n\t * The second case is that bfqq is in a higher priority class,\n\t * or has a higher weight than the in-service queue. If this\n\t * condition does not hold, we don't care because, even if\n\t * bfqq does not start to be served immediately, the resulting\n\t * delay for bfqq's I/O is however lower or much lower than\n\t * the ideal completion time to be guaranteed to bfqq's I/O.\n\t *\n\t * In both cases, preemption is needed only if, according to\n\t * the timestamps of both bfqq and of the in-service queue,\n\t * bfqq actually is the next queue to serve. So, to reduce\n\t * useless preemptions, the return value of\n\t * next_queue_may_preempt() is considered in the next compound\n\t * condition too. Yet next_queue_may_preempt() just checks a\n\t * simple, necessary condition for bfqq to be the next queue\n\t * to serve. In fact, to evaluate a sufficient condition, the\n\t * timestamps of the in-service queue would need to be\n\t * updated, and this operation is quite costly (see the\n\t * comments on bfq_bfqq_update_budg_for_activation()).\n\t */\n\tif (bfqd->in_service_queue &&\n\t    ((bfqq_wants_to_preempt &&\n\t      bfqq->wr_coeff >= bfqd->in_service_queue->wr_coeff) ||\n\t     bfq_bfqq_higher_class_or_weight(bfqq, bfqd->in_service_queue)) &&\n\t    next_queue_may_preempt(bfqd))\n\t\tbfq_bfqq_expire(bfqd, bfqd->in_service_queue,\n\t\t\t\tfalse, BFQQE_PREEMPTED);\n}\n\nstatic void bfq_reset_inject_limit(struct bfq_data *bfqd,\n\t\t\t\t   struct bfq_queue *bfqq)\n{\n\t/* invalidate baseline total service time */\n\tbfqq->last_serv_time_ns = 0;\n\n\t/*\n\t * Reset pointer in case we are waiting for\n\t * some request completion.\n\t */\n\tbfqd->waited_rq = NULL;\n\n\t/*\n\t * If bfqq has a short think time, then start by setting the\n\t * inject limit to 0 prudentially, because the service time of\n\t * an injected I/O request may be higher than the think time\n\t * of bfqq, and therefore, if one request was injected when\n\t * bfqq remains empty, this injected request might delay the\n\t * service of the next I/O request for bfqq significantly. In\n\t * case bfqq can actually tolerate some injection, then the\n\t * adaptive update will however raise the limit soon. This\n\t * lucky circumstance holds exactly because bfqq has a short\n\t * think time, and thus, after remaining empty, is likely to\n\t * get new I/O enqueued---and then completed---before being\n\t * expired. This is the very pattern that gives the\n\t * limit-update algorithm the chance to measure the effect of\n\t * injection on request service times, and then to update the\n\t * limit accordingly.\n\t *\n\t * However, in the following special case, the inject limit is\n\t * left to 1 even if the think time is short: bfqq's I/O is\n\t * synchronized with that of some other queue, i.e., bfqq may\n\t * receive new I/O only after the I/O of the other queue is\n\t * completed. Keeping the inject limit to 1 allows the\n\t * blocking I/O to be served while bfqq is in service. And\n\t * this is very convenient both for bfqq and for overall\n\t * throughput, as explained in detail in the comments in\n\t * bfq_update_has_short_ttime().\n\t *\n\t * On the opposite end, if bfqq has a long think time, then\n\t * start directly by 1, because:\n\t * a) on the bright side, keeping at most one request in\n\t * service in the drive is unlikely to cause any harm to the\n\t * latency of bfqq's requests, as the service time of a single\n\t * request is likely to be lower than the think time of bfqq;\n\t * b) on the downside, after becoming empty, bfqq is likely to\n\t * expire before getting its next request. With this request\n\t * arrival pattern, it is very hard to sample total service\n\t * times and update the inject limit accordingly (see comments\n\t * on bfq_update_inject_limit()). So the limit is likely to be\n\t * never, or at least seldom, updated.  As a consequence, by\n\t * setting the limit to 1, we avoid that no injection ever\n\t * occurs with bfqq. On the downside, this proactive step\n\t * further reduces chances to actually compute the baseline\n\t * total service time. Thus it reduces chances to execute the\n\t * limit-update algorithm and possibly raise the limit to more\n\t * than 1.\n\t */\n\tif (bfq_bfqq_has_short_ttime(bfqq))\n\t\tbfqq->inject_limit = 0;\n\telse\n\t\tbfqq->inject_limit = 1;\n\n\tbfqq->decrease_time_jif = jiffies;\n}\n\nstatic void bfq_add_request(struct request *rq)\n{\n\tstruct bfq_queue *bfqq = RQ_BFQQ(rq);\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tstruct request *next_rq, *prev;\n\tunsigned int old_wr_coeff = bfqq->wr_coeff;\n\tbool interactive = false;\n\n\tbfq_log_bfqq(bfqd, bfqq, \"add_request %d\", rq_is_sync(rq));\n\tbfqq->queued[rq_is_sync(rq)]++;\n\tbfqd->queued++;\n\n\tif (RB_EMPTY_ROOT(&bfqq->sort_list) && bfq_bfqq_sync(bfqq)) {\n\t\t/*\n\t\t * Detect whether bfqq's I/O seems synchronized with\n\t\t * that of some other queue, i.e., whether bfqq, after\n\t\t * remaining empty, happens to receive new I/O only\n\t\t * right after some I/O request of the other queue has\n\t\t * been completed. We call waker queue the other\n\t\t * queue, and we assume, for simplicity, that bfqq may\n\t\t * have at most one waker queue.\n\t\t *\n\t\t * A remarkable throughput boost can be reached by\n\t\t * unconditionally injecting the I/O of the waker\n\t\t * queue, every time a new bfq_dispatch_request\n\t\t * happens to be invoked while I/O is being plugged\n\t\t * for bfqq.  In addition to boosting throughput, this\n\t\t * unblocks bfqq's I/O, thereby improving bandwidth\n\t\t * and latency for bfqq. Note that these same results\n\t\t * may be achieved with the general injection\n\t\t * mechanism, but less effectively. For details on\n\t\t * this aspect, see the comments on the choice of the\n\t\t * queue for injection in bfq_select_queue().\n\t\t *\n\t\t * Turning back to the detection of a waker queue, a\n\t\t * queue Q is deemed as a waker queue for bfqq if, for\n\t\t * two consecutive times, bfqq happens to become non\n\t\t * empty right after a request of Q has been\n\t\t * completed. In particular, on the first time, Q is\n\t\t * tentatively set as a candidate waker queue, while\n\t\t * on the second time, the flag\n\t\t * bfq_bfqq_has_waker(bfqq) is set to confirm that Q\n\t\t * is a waker queue for bfqq. These detection steps\n\t\t * are performed only if bfqq has a long think time,\n\t\t * so as to make it more likely that bfqq's I/O is\n\t\t * actually being blocked by a synchronization. This\n\t\t * last filter, plus the above two-times requirement,\n\t\t * make false positives less likely.\n\t\t *\n\t\t * NOTE\n\t\t *\n\t\t * The sooner a waker queue is detected, the sooner\n\t\t * throughput can be boosted by injecting I/O from the\n\t\t * waker queue. Fortunately, detection is likely to be\n\t\t * actually fast, for the following reasons. While\n\t\t * blocked by synchronization, bfqq has a long think\n\t\t * time. This implies that bfqq's inject limit is at\n\t\t * least equal to 1 (see the comments in\n\t\t * bfq_update_inject_limit()). So, thanks to\n\t\t * injection, the waker queue is likely to be served\n\t\t * during the very first I/O-plugging time interval\n\t\t * for bfqq. This triggers the first step of the\n\t\t * detection mechanism. Thanks again to injection, the\n\t\t * candidate waker queue is then likely to be\n\t\t * confirmed no later than during the next\n\t\t * I/O-plugging interval for bfqq.\n\t\t */\n\t\tif (bfqd->last_completed_rq_bfqq &&\n\t\t    !bfq_bfqq_has_short_ttime(bfqq) &&\n\t\t    ktime_get_ns() - bfqd->last_completion <\n\t\t    200 * NSEC_PER_USEC) {\n\t\t\tif (bfqd->last_completed_rq_bfqq != bfqq &&\n\t\t\t    bfqd->last_completed_rq_bfqq !=\n\t\t\t    bfqq->waker_bfqq) {\n\t\t\t\t/*\n\t\t\t\t * First synchronization detected with\n\t\t\t\t * a candidate waker queue, or with a\n\t\t\t\t * different candidate waker queue\n\t\t\t\t * from the current one.\n\t\t\t\t */\n\t\t\t\tbfqq->waker_bfqq = bfqd->last_completed_rq_bfqq;\n\n\t\t\t\t/*\n\t\t\t\t * If the waker queue disappears, then\n\t\t\t\t * bfqq->waker_bfqq must be reset. To\n\t\t\t\t * this goal, we maintain in each\n\t\t\t\t * waker queue a list, woken_list, of\n\t\t\t\t * all the queues that reference the\n\t\t\t\t * waker queue through their\n\t\t\t\t * waker_bfqq pointer. When the waker\n\t\t\t\t * queue exits, the waker_bfqq pointer\n\t\t\t\t * of all the queues in the woken_list\n\t\t\t\t * is reset.\n\t\t\t\t *\n\t\t\t\t * In addition, if bfqq is already in\n\t\t\t\t * the woken_list of a waker queue,\n\t\t\t\t * then, before being inserted into\n\t\t\t\t * the woken_list of a new waker\n\t\t\t\t * queue, bfqq must be removed from\n\t\t\t\t * the woken_list of the old waker\n\t\t\t\t * queue.\n\t\t\t\t */\n\t\t\t\tif (!hlist_unhashed(&bfqq->woken_list_node))\n\t\t\t\t\thlist_del_init(&bfqq->woken_list_node);\n\t\t\t\thlist_add_head(&bfqq->woken_list_node,\n\t\t\t\t    &bfqd->last_completed_rq_bfqq->woken_list);\n\n\t\t\t\tbfq_clear_bfqq_has_waker(bfqq);\n\t\t\t} else if (bfqd->last_completed_rq_bfqq ==\n\t\t\t\t   bfqq->waker_bfqq &&\n\t\t\t\t   !bfq_bfqq_has_waker(bfqq)) {\n\t\t\t\t/*\n\t\t\t\t * synchronization with waker_bfqq\n\t\t\t\t * seen for the second time\n\t\t\t\t */\n\t\t\t\tbfq_mark_bfqq_has_waker(bfqq);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Periodically reset inject limit, to make sure that\n\t\t * the latter eventually drops in case workload\n\t\t * changes, see step (3) in the comments on\n\t\t * bfq_update_inject_limit().\n\t\t */\n\t\tif (time_is_before_eq_jiffies(bfqq->decrease_time_jif +\n\t\t\t\t\t     msecs_to_jiffies(1000)))\n\t\t\tbfq_reset_inject_limit(bfqd, bfqq);\n\n\t\t/*\n\t\t * The following conditions must hold to setup a new\n\t\t * sampling of total service time, and then a new\n\t\t * update of the inject limit:\n\t\t * - bfqq is in service, because the total service\n\t\t *   time is evaluated only for the I/O requests of\n\t\t *   the queues in service;\n\t\t * - this is the right occasion to compute or to\n\t\t *   lower the baseline total service time, because\n\t\t *   there are actually no requests in the drive,\n\t\t *   or\n\t\t *   the baseline total service time is available, and\n\t\t *   this is the right occasion to compute the other\n\t\t *   quantity needed to update the inject limit, i.e.,\n\t\t *   the total service time caused by the amount of\n\t\t *   injection allowed by the current value of the\n\t\t *   limit. It is the right occasion because injection\n\t\t *   has actually been performed during the service\n\t\t *   hole, and there are still in-flight requests,\n\t\t *   which are very likely to be exactly the injected\n\t\t *   requests, or part of them;\n\t\t * - the minimum interval for sampling the total\n\t\t *   service time and updating the inject limit has\n\t\t *   elapsed.\n\t\t */\n\t\tif (bfqq == bfqd->in_service_queue &&\n\t\t    (bfqd->rq_in_driver == 0 ||\n\t\t     (bfqq->last_serv_time_ns > 0 &&\n\t\t      bfqd->rqs_injected && bfqd->rq_in_driver > 0)) &&\n\t\t    time_is_before_eq_jiffies(bfqq->decrease_time_jif +\n\t\t\t\t\t      msecs_to_jiffies(10))) {\n\t\t\tbfqd->last_empty_occupied_ns = ktime_get_ns();\n\t\t\t/*\n\t\t\t * Start the state machine for measuring the\n\t\t\t * total service time of rq: setting\n\t\t\t * wait_dispatch will cause bfqd->waited_rq to\n\t\t\t * be set when rq will be dispatched.\n\t\t\t */\n\t\t\tbfqd->wait_dispatch = true;\n\t\t\t/*\n\t\t\t * If there is no I/O in service in the drive,\n\t\t\t * then possible injection occurred before the\n\t\t\t * arrival of rq will not affect the total\n\t\t\t * service time of rq. So the injection limit\n\t\t\t * must not be updated as a function of such\n\t\t\t * total service time, unless new injection\n\t\t\t * occurs before rq is completed. To have the\n\t\t\t * injection limit updated only in the latter\n\t\t\t * case, reset rqs_injected here (rqs_injected\n\t\t\t * will be set in case injection is performed\n\t\t\t * on bfqq before rq is completed).\n\t\t\t */\n\t\t\tif (bfqd->rq_in_driver == 0)\n\t\t\t\tbfqd->rqs_injected = false;\n\t\t}\n\t}\n\n\telv_rb_add(&bfqq->sort_list, rq);\n\n\t/*\n\t * Check if this request is a better next-serve candidate.\n\t */\n\tprev = bfqq->next_rq;\n\tnext_rq = bfq_choose_req(bfqd, bfqq->next_rq, rq, bfqd->last_position);\n\tbfqq->next_rq = next_rq;\n\n\t/*\n\t * Adjust priority tree position, if next_rq changes.\n\t * See comments on bfq_pos_tree_add_move() for the unlikely().\n\t */\n\tif (unlikely(!bfqd->nonrot_with_queueing && prev != bfqq->next_rq))\n\t\tbfq_pos_tree_add_move(bfqd, bfqq);\n\n\tif (!bfq_bfqq_busy(bfqq)) /* switching to busy ... */\n\t\tbfq_bfqq_handle_idle_busy_switch(bfqd, bfqq, old_wr_coeff,\n\t\t\t\t\t\t rq, &interactive);\n\telse {\n\t\tif (bfqd->low_latency && old_wr_coeff == 1 && !rq_is_sync(rq) &&\n\t\t    time_is_before_jiffies(\n\t\t\t\tbfqq->last_wr_start_finish +\n\t\t\t\tbfqd->bfq_wr_min_inter_arr_async)) {\n\t\t\tbfqq->wr_coeff = bfqd->bfq_wr_coeff;\n\t\t\tbfqq->wr_cur_max_time = bfq_wr_duration(bfqd);\n\n\t\t\tbfqd->wr_busy_queues++;\n\t\t\tbfqq->entity.prio_changed = 1;\n\t\t}\n\t\tif (prev != bfqq->next_rq)\n\t\t\tbfq_updated_next_req(bfqd, bfqq);\n\t}\n\n\t/*\n\t * Assign jiffies to last_wr_start_finish in the following\n\t * cases:\n\t *\n\t * . if bfqq is not going to be weight-raised, because, for\n\t *   non weight-raised queues, last_wr_start_finish stores the\n\t *   arrival time of the last request; as of now, this piece\n\t *   of information is used only for deciding whether to\n\t *   weight-raise async queues\n\t *\n\t * . if bfqq is not weight-raised, because, if bfqq is now\n\t *   switching to weight-raised, then last_wr_start_finish\n\t *   stores the time when weight-raising starts\n\t *\n\t * . if bfqq is interactive, because, regardless of whether\n\t *   bfqq is currently weight-raised, the weight-raising\n\t *   period must start or restart (this case is considered\n\t *   separately because it is not detected by the above\n\t *   conditions, if bfqq is already weight-raised)\n\t *\n\t * last_wr_start_finish has to be updated also if bfqq is soft\n\t * real-time, because the weight-raising period is constantly\n\t * restarted on idle-to-busy transitions for these queues, but\n\t * this is already done in bfq_bfqq_handle_idle_busy_switch if\n\t * needed.\n\t */\n\tif (bfqd->low_latency &&\n\t\t(old_wr_coeff == 1 || bfqq->wr_coeff == 1 || interactive))\n\t\tbfqq->last_wr_start_finish = jiffies;\n}\n\nstatic struct request *bfq_find_rq_fmerge(struct bfq_data *bfqd,\n\t\t\t\t\t  struct bio *bio,\n\t\t\t\t\t  struct request_queue *q)\n{\n\tstruct bfq_queue *bfqq = bfqd->bio_bfqq;\n\n\n\tif (bfqq)\n\t\treturn elv_rb_find(&bfqq->sort_list, bio_end_sector(bio));\n\n\treturn NULL;\n}\n\nstatic sector_t get_sdist(sector_t last_pos, struct request *rq)\n{\n\tif (last_pos)\n\t\treturn abs(blk_rq_pos(rq) - last_pos);\n\n\treturn 0;\n}\n\n#if 0 /* Still not clear if we can do without next two functions */\nstatic void bfq_activate_request(struct request_queue *q, struct request *rq)\n{\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\n\tbfqd->rq_in_driver++;\n}\n\nstatic void bfq_deactivate_request(struct request_queue *q, struct request *rq)\n{\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\n\tbfqd->rq_in_driver--;\n}\n#endif\n\nstatic void bfq_remove_request(struct request_queue *q,\n\t\t\t       struct request *rq)\n{\n\tstruct bfq_queue *bfqq = RQ_BFQQ(rq);\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tconst int sync = rq_is_sync(rq);\n\n\tif (bfqq->next_rq == rq) {\n\t\tbfqq->next_rq = bfq_find_next_rq(bfqd, bfqq, rq);\n\t\tbfq_updated_next_req(bfqd, bfqq);\n\t}\n\n\tif (rq->queuelist.prev != &rq->queuelist)\n\t\tlist_del_init(&rq->queuelist);\n\tbfqq->queued[sync]--;\n\tbfqd->queued--;\n\telv_rb_del(&bfqq->sort_list, rq);\n\n\telv_rqhash_del(q, rq);\n\tif (q->last_merge == rq)\n\t\tq->last_merge = NULL;\n\n\tif (RB_EMPTY_ROOT(&bfqq->sort_list)) {\n\t\tbfqq->next_rq = NULL;\n\n\t\tif (bfq_bfqq_busy(bfqq) && bfqq != bfqd->in_service_queue) {\n\t\t\tbfq_del_bfqq_busy(bfqd, bfqq, false);\n\t\t\t/*\n\t\t\t * bfqq emptied. In normal operation, when\n\t\t\t * bfqq is empty, bfqq->entity.service and\n\t\t\t * bfqq->entity.budget must contain,\n\t\t\t * respectively, the service received and the\n\t\t\t * budget used last time bfqq emptied. These\n\t\t\t * facts do not hold in this case, as at least\n\t\t\t * this last removal occurred while bfqq is\n\t\t\t * not in service. To avoid inconsistencies,\n\t\t\t * reset both bfqq->entity.service and\n\t\t\t * bfqq->entity.budget, if bfqq has still a\n\t\t\t * process that may issue I/O requests to it.\n\t\t\t */\n\t\t\tbfqq->entity.budget = bfqq->entity.service = 0;\n\t\t}\n\n\t\t/*\n\t\t * Remove queue from request-position tree as it is empty.\n\t\t */\n\t\tif (bfqq->pos_root) {\n\t\t\trb_erase(&bfqq->pos_node, bfqq->pos_root);\n\t\t\tbfqq->pos_root = NULL;\n\t\t}\n\t} else {\n\t\t/* see comments on bfq_pos_tree_add_move() for the unlikely() */\n\t\tif (unlikely(!bfqd->nonrot_with_queueing))\n\t\t\tbfq_pos_tree_add_move(bfqd, bfqq);\n\t}\n\n\tif (rq->cmd_flags & REQ_META)\n\t\tbfqq->meta_pending--;\n\n}\n\nstatic bool bfq_bio_merge(struct blk_mq_hw_ctx *hctx, struct bio *bio,\n\t\tunsigned int nr_segs)\n{\n\tstruct request_queue *q = hctx->queue;\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\tstruct request *free = NULL;\n\t/*\n\t * bfq_bic_lookup grabs the queue_lock: invoke it now and\n\t * store its return value for later use, to avoid nesting\n\t * queue_lock inside the bfqd->lock. We assume that the bic\n\t * returned by bfq_bic_lookup does not go away before\n\t * bfqd->lock is taken.\n\t */\n\tstruct bfq_io_cq *bic = bfq_bic_lookup(bfqd, current->io_context, q);\n\tbool ret;\n\n\tspin_lock_irq(&bfqd->lock);\n\n\tif (bic)\n\t\tbfqd->bio_bfqq = bic_to_bfqq(bic, op_is_sync(bio->bi_opf));\n\telse\n\t\tbfqd->bio_bfqq = NULL;\n\tbfqd->bio_bic = bic;\n\n\tret = blk_mq_sched_try_merge(q, bio, nr_segs, &free);\n\n\tif (free)\n\t\tblk_mq_free_request(free);\n\tspin_unlock_irq(&bfqd->lock);\n\n\treturn ret;\n}\n\nstatic int bfq_request_merge(struct request_queue *q, struct request **req,\n\t\t\t     struct bio *bio)\n{\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\tstruct request *__rq;\n\n\t__rq = bfq_find_rq_fmerge(bfqd, bio, q);\n\tif (__rq && elv_bio_merge_ok(__rq, bio)) {\n\t\t*req = __rq;\n\t\treturn ELEVATOR_FRONT_MERGE;\n\t}\n\n\treturn ELEVATOR_NO_MERGE;\n}\n\nstatic struct bfq_queue *bfq_init_rq(struct request *rq);\n\nstatic void bfq_request_merged(struct request_queue *q, struct request *req,\n\t\t\t       enum elv_merge type)\n{\n\tif (type == ELEVATOR_FRONT_MERGE &&\n\t    rb_prev(&req->rb_node) &&\n\t    blk_rq_pos(req) <\n\t    blk_rq_pos(container_of(rb_prev(&req->rb_node),\n\t\t\t\t    struct request, rb_node))) {\n\t\tstruct bfq_queue *bfqq = bfq_init_rq(req);\n\t\tstruct bfq_data *bfqd;\n\t\tstruct request *prev, *next_rq;\n\n\t\tif (!bfqq)\n\t\t\treturn;\n\n\t\tbfqd = bfqq->bfqd;\n\n\t\t/* Reposition request in its sort_list */\n\t\telv_rb_del(&bfqq->sort_list, req);\n\t\telv_rb_add(&bfqq->sort_list, req);\n\n\t\t/* Choose next request to be served for bfqq */\n\t\tprev = bfqq->next_rq;\n\t\tnext_rq = bfq_choose_req(bfqd, bfqq->next_rq, req,\n\t\t\t\t\t bfqd->last_position);\n\t\tbfqq->next_rq = next_rq;\n\t\t/*\n\t\t * If next_rq changes, update both the queue's budget to\n\t\t * fit the new request and the queue's position in its\n\t\t * rq_pos_tree.\n\t\t */\n\t\tif (prev != bfqq->next_rq) {\n\t\t\tbfq_updated_next_req(bfqd, bfqq);\n\t\t\t/*\n\t\t\t * See comments on bfq_pos_tree_add_move() for\n\t\t\t * the unlikely().\n\t\t\t */\n\t\t\tif (unlikely(!bfqd->nonrot_with_queueing))\n\t\t\t\tbfq_pos_tree_add_move(bfqd, bfqq);\n\t\t}\n\t}\n}\n\n/*\n * This function is called to notify the scheduler that the requests\n * rq and 'next' have been merged, with 'next' going away.  BFQ\n * exploits this hook to address the following issue: if 'next' has a\n * fifo_time lower that rq, then the fifo_time of rq must be set to\n * the value of 'next', to not forget the greater age of 'next'.\n *\n * NOTE: in this function we assume that rq is in a bfq_queue, basing\n * on that rq is picked from the hash table q->elevator->hash, which,\n * in its turn, is filled only with I/O requests present in\n * bfq_queues, while BFQ is in use for the request queue q. In fact,\n * the function that fills this hash table (elv_rqhash_add) is called\n * only by bfq_insert_request.\n */\nstatic void bfq_requests_merged(struct request_queue *q, struct request *rq,\n\t\t\t\tstruct request *next)\n{\n\tstruct bfq_queue *bfqq = bfq_init_rq(rq),\n\t\t*next_bfqq = bfq_init_rq(next);\n\n\tif (!bfqq)\n\t\treturn;\n\n\t/*\n\t * If next and rq belong to the same bfq_queue and next is older\n\t * than rq, then reposition rq in the fifo (by substituting next\n\t * with rq). Otherwise, if next and rq belong to different\n\t * bfq_queues, never reposition rq: in fact, we would have to\n\t * reposition it with respect to next's position in its own fifo,\n\t * which would most certainly be too expensive with respect to\n\t * the benefits.\n\t */\n\tif (bfqq == next_bfqq &&\n\t    !list_empty(&rq->queuelist) && !list_empty(&next->queuelist) &&\n\t    next->fifo_time < rq->fifo_time) {\n\t\tlist_del_init(&rq->queuelist);\n\t\tlist_replace_init(&next->queuelist, &rq->queuelist);\n\t\trq->fifo_time = next->fifo_time;\n\t}\n\n\tif (bfqq->next_rq == next)\n\t\tbfqq->next_rq = rq;\n\n\tbfqg_stats_update_io_merged(bfqq_group(bfqq), next->cmd_flags);\n}\n\n/* Must be called with bfqq != NULL */\nstatic void bfq_bfqq_end_wr(struct bfq_queue *bfqq)\n{\n\tif (bfq_bfqq_busy(bfqq))\n\t\tbfqq->bfqd->wr_busy_queues--;\n\tbfqq->wr_coeff = 1;\n\tbfqq->wr_cur_max_time = 0;\n\tbfqq->last_wr_start_finish = jiffies;\n\t/*\n\t * Trigger a weight change on the next invocation of\n\t * __bfq_entity_update_weight_prio.\n\t */\n\tbfqq->entity.prio_changed = 1;\n}\n\nvoid bfq_end_wr_async_queues(struct bfq_data *bfqd,\n\t\t\t     struct bfq_group *bfqg)\n{\n\tint i, j;\n\n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < IOPRIO_BE_NR; j++)\n\t\t\tif (bfqg->async_bfqq[i][j])\n\t\t\t\tbfq_bfqq_end_wr(bfqg->async_bfqq[i][j]);\n\tif (bfqg->async_idle_bfqq)\n\t\tbfq_bfqq_end_wr(bfqg->async_idle_bfqq);\n}\n\nstatic void bfq_end_wr(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq;\n\n\tspin_lock_irq(&bfqd->lock);\n\n\tlist_for_each_entry(bfqq, &bfqd->active_list, bfqq_list)\n\t\tbfq_bfqq_end_wr(bfqq);\n\tlist_for_each_entry(bfqq, &bfqd->idle_list, bfqq_list)\n\t\tbfq_bfqq_end_wr(bfqq);\n\tbfq_end_wr_async(bfqd);\n\n\tspin_unlock_irq(&bfqd->lock);\n}\n\nstatic sector_t bfq_io_struct_pos(void *io_struct, bool request)\n{\n\tif (request)\n\t\treturn blk_rq_pos(io_struct);\n\telse\n\t\treturn ((struct bio *)io_struct)->bi_iter.bi_sector;\n}\n\nstatic int bfq_rq_close_to_sector(void *io_struct, bool request,\n\t\t\t\t  sector_t sector)\n{\n\treturn abs(bfq_io_struct_pos(io_struct, request) - sector) <=\n\t       BFQQ_CLOSE_THR;\n}\n\nstatic struct bfq_queue *bfqq_find_close(struct bfq_data *bfqd,\n\t\t\t\t\t struct bfq_queue *bfqq,\n\t\t\t\t\t sector_t sector)\n{\n\tstruct rb_root *root = &bfq_bfqq_to_bfqg(bfqq)->rq_pos_tree;\n\tstruct rb_node *parent, *node;\n\tstruct bfq_queue *__bfqq;\n\n\tif (RB_EMPTY_ROOT(root))\n\t\treturn NULL;\n\n\t/*\n\t * First, if we find a request starting at the end of the last\n\t * request, choose it.\n\t */\n\t__bfqq = bfq_rq_pos_tree_lookup(bfqd, root, sector, &parent, NULL);\n\tif (__bfqq)\n\t\treturn __bfqq;\n\n\t/*\n\t * If the exact sector wasn't found, the parent of the NULL leaf\n\t * will contain the closest sector (rq_pos_tree sorted by\n\t * next_request position).\n\t */\n\t__bfqq = rb_entry(parent, struct bfq_queue, pos_node);\n\tif (bfq_rq_close_to_sector(__bfqq->next_rq, true, sector))\n\t\treturn __bfqq;\n\n\tif (blk_rq_pos(__bfqq->next_rq) < sector)\n\t\tnode = rb_next(&__bfqq->pos_node);\n\telse\n\t\tnode = rb_prev(&__bfqq->pos_node);\n\tif (!node)\n\t\treturn NULL;\n\n\t__bfqq = rb_entry(node, struct bfq_queue, pos_node);\n\tif (bfq_rq_close_to_sector(__bfqq->next_rq, true, sector))\n\t\treturn __bfqq;\n\n\treturn NULL;\n}\n\nstatic struct bfq_queue *bfq_find_close_cooperator(struct bfq_data *bfqd,\n\t\t\t\t\t\t   struct bfq_queue *cur_bfqq,\n\t\t\t\t\t\t   sector_t sector)\n{\n\tstruct bfq_queue *bfqq;\n\n\t/*\n\t * We shall notice if some of the queues are cooperating,\n\t * e.g., working closely on the same area of the device. In\n\t * that case, we can group them together and: 1) don't waste\n\t * time idling, and 2) serve the union of their requests in\n\t * the best possible order for throughput.\n\t */\n\tbfqq = bfqq_find_close(bfqd, cur_bfqq, sector);\n\tif (!bfqq || bfqq == cur_bfqq)\n\t\treturn NULL;\n\n\treturn bfqq;\n}\n\nstatic struct bfq_queue *\nbfq_setup_merge(struct bfq_queue *bfqq, struct bfq_queue *new_bfqq)\n{\n\tint process_refs, new_process_refs;\n\tstruct bfq_queue *__bfqq;\n\n\t/*\n\t * If there are no process references on the new_bfqq, then it is\n\t * unsafe to follow the ->new_bfqq chain as other bfqq's in the chain\n\t * may have dropped their last reference (not just their last process\n\t * reference).\n\t */\n\tif (!bfqq_process_refs(new_bfqq))\n\t\treturn NULL;\n\n\t/* Avoid a circular list and skip interim queue merges. */\n\twhile ((__bfqq = new_bfqq->new_bfqq)) {\n\t\tif (__bfqq == bfqq)\n\t\t\treturn NULL;\n\t\tnew_bfqq = __bfqq;\n\t}\n\n\tprocess_refs = bfqq_process_refs(bfqq);\n\tnew_process_refs = bfqq_process_refs(new_bfqq);\n\t/*\n\t * If the process for the bfqq has gone away, there is no\n\t * sense in merging the queues.\n\t */\n\tif (process_refs == 0 || new_process_refs == 0)\n\t\treturn NULL;\n\n\tbfq_log_bfqq(bfqq->bfqd, bfqq, \"scheduling merge with queue %d\",\n\t\tnew_bfqq->pid);\n\n\t/*\n\t * Merging is just a redirection: the requests of the process\n\t * owning one of the two queues are redirected to the other queue.\n\t * The latter queue, in its turn, is set as shared if this is the\n\t * first time that the requests of some process are redirected to\n\t * it.\n\t *\n\t * We redirect bfqq to new_bfqq and not the opposite, because\n\t * we are in the context of the process owning bfqq, thus we\n\t * have the io_cq of this process. So we can immediately\n\t * configure this io_cq to redirect the requests of the\n\t * process to new_bfqq. In contrast, the io_cq of new_bfqq is\n\t * not available any more (new_bfqq->bic == NULL).\n\t *\n\t * Anyway, even in case new_bfqq coincides with the in-service\n\t * queue, redirecting requests the in-service queue is the\n\t * best option, as we feed the in-service queue with new\n\t * requests close to the last request served and, by doing so,\n\t * are likely to increase the throughput.\n\t */\n\tbfqq->new_bfqq = new_bfqq;\n\tnew_bfqq->ref += process_refs;\n\treturn new_bfqq;\n}\n\nstatic bool bfq_may_be_close_cooperator(struct bfq_queue *bfqq,\n\t\t\t\t\tstruct bfq_queue *new_bfqq)\n{\n\tif (bfq_too_late_for_merging(new_bfqq))\n\t\treturn false;\n\n\tif (bfq_class_idle(bfqq) || bfq_class_idle(new_bfqq) ||\n\t    (bfqq->ioprio_class != new_bfqq->ioprio_class))\n\t\treturn false;\n\n\t/*\n\t * If either of the queues has already been detected as seeky,\n\t * then merging it with the other queue is unlikely to lead to\n\t * sequential I/O.\n\t */\n\tif (BFQQ_SEEKY(bfqq) || BFQQ_SEEKY(new_bfqq))\n\t\treturn false;\n\n\t/*\n\t * Interleaved I/O is known to be done by (some) applications\n\t * only for reads, so it does not make sense to merge async\n\t * queues.\n\t */\n\tif (!bfq_bfqq_sync(bfqq) || !bfq_bfqq_sync(new_bfqq))\n\t\treturn false;\n\n\treturn true;\n}\n\n/*\n * Attempt to schedule a merge of bfqq with the currently in-service\n * queue or with a close queue among the scheduled queues.  Return\n * NULL if no merge was scheduled, a pointer to the shared bfq_queue\n * structure otherwise.\n *\n * The OOM queue is not allowed to participate to cooperation: in fact, since\n * the requests temporarily redirected to the OOM queue could be redirected\n * again to dedicated queues at any time, the state needed to correctly\n * handle merging with the OOM queue would be quite complex and expensive\n * to maintain. Besides, in such a critical condition as an out of memory,\n * the benefits of queue merging may be little relevant, or even negligible.\n *\n * WARNING: queue merging may impair fairness among non-weight raised\n * queues, for at least two reasons: 1) the original weight of a\n * merged queue may change during the merged state, 2) even being the\n * weight the same, a merged queue may be bloated with many more\n * requests than the ones produced by its originally-associated\n * process.\n */\nstatic struct bfq_queue *\nbfq_setup_cooperator(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t     void *io_struct, bool request)\n{\n\tstruct bfq_queue *in_service_bfqq, *new_bfqq;\n\n\t/*\n\t * Do not perform queue merging if the device is non\n\t * rotational and performs internal queueing. In fact, such a\n\t * device reaches a high speed through internal parallelism\n\t * and pipelining. This means that, to reach a high\n\t * throughput, it must have many requests enqueued at the same\n\t * time. But, in this configuration, the internal scheduling\n\t * algorithm of the device does exactly the job of queue\n\t * merging: it reorders requests so as to obtain as much as\n\t * possible a sequential I/O pattern. As a consequence, with\n\t * the workload generated by processes doing interleaved I/O,\n\t * the throughput reached by the device is likely to be the\n\t * same, with and without queue merging.\n\t *\n\t * Disabling merging also provides a remarkable benefit in\n\t * terms of throughput. Merging tends to make many workloads\n\t * artificially more uneven, because of shared queues\n\t * remaining non empty for incomparably more time than\n\t * non-merged queues. This may accentuate workload\n\t * asymmetries. For example, if one of the queues in a set of\n\t * merged queues has a higher weight than a normal queue, then\n\t * the shared queue may inherit such a high weight and, by\n\t * staying almost always active, may force BFQ to perform I/O\n\t * plugging most of the time. This evidently makes it harder\n\t * for BFQ to let the device reach a high throughput.\n\t *\n\t * Finally, the likely() macro below is not used because one\n\t * of the two branches is more likely than the other, but to\n\t * have the code path after the following if() executed as\n\t * fast as possible for the case of a non rotational device\n\t * with queueing. We want it because this is the fastest kind\n\t * of device. On the opposite end, the likely() may lengthen\n\t * the execution time of BFQ for the case of slower devices\n\t * (rotational or at least without queueing). But in this case\n\t * the execution time of BFQ matters very little, if not at\n\t * all.\n\t */\n\tif (likely(bfqd->nonrot_with_queueing))\n\t\treturn NULL;\n\n\t/*\n\t * Prevent bfqq from being merged if it has been created too\n\t * long ago. The idea is that true cooperating processes, and\n\t * thus their associated bfq_queues, are supposed to be\n\t * created shortly after each other. This is the case, e.g.,\n\t * for KVM/QEMU and dump I/O threads. Basing on this\n\t * assumption, the following filtering greatly reduces the\n\t * probability that two non-cooperating processes, which just\n\t * happen to do close I/O for some short time interval, have\n\t * their queues merged by mistake.\n\t */\n\tif (bfq_too_late_for_merging(bfqq))\n\t\treturn NULL;\n\n\tif (bfqq->new_bfqq)\n\t\treturn bfqq->new_bfqq;\n\n\tif (!io_struct || unlikely(bfqq == &bfqd->oom_bfqq))\n\t\treturn NULL;\n\n\t/* If there is only one backlogged queue, don't search. */\n\tif (bfq_tot_busy_queues(bfqd) == 1)\n\t\treturn NULL;\n\n\tin_service_bfqq = bfqd->in_service_queue;\n\n\tif (in_service_bfqq && in_service_bfqq != bfqq &&\n\t    likely(in_service_bfqq != &bfqd->oom_bfqq) &&\n\t    bfq_rq_close_to_sector(io_struct, request,\n\t\t\t\t   bfqd->in_serv_last_pos) &&\n\t    bfqq->entity.parent == in_service_bfqq->entity.parent &&\n\t    bfq_may_be_close_cooperator(bfqq, in_service_bfqq)) {\n\t\tnew_bfqq = bfq_setup_merge(bfqq, in_service_bfqq);\n\t\tif (new_bfqq)\n\t\t\treturn new_bfqq;\n\t}\n\t/*\n\t * Check whether there is a cooperator among currently scheduled\n\t * queues. The only thing we need is that the bio/request is not\n\t * NULL, as we need it to establish whether a cooperator exists.\n\t */\n\tnew_bfqq = bfq_find_close_cooperator(bfqd, bfqq,\n\t\t\tbfq_io_struct_pos(io_struct, request));\n\n\tif (new_bfqq && likely(new_bfqq != &bfqd->oom_bfqq) &&\n\t    bfq_may_be_close_cooperator(bfqq, new_bfqq))\n\t\treturn bfq_setup_merge(bfqq, new_bfqq);\n\n\treturn NULL;\n}\n\nstatic void bfq_bfqq_save_state(struct bfq_queue *bfqq)\n{\n\tstruct bfq_io_cq *bic = bfqq->bic;\n\n\t/*\n\t * If !bfqq->bic, the queue is already shared or its requests\n\t * have already been redirected to a shared queue; both idle window\n\t * and weight raising state have already been saved. Do nothing.\n\t */\n\tif (!bic)\n\t\treturn;\n\n\tbic->saved_weight = bfqq->entity.orig_weight;\n\tbic->saved_ttime = bfqq->ttime;\n\tbic->saved_has_short_ttime = bfq_bfqq_has_short_ttime(bfqq);\n\tbic->saved_IO_bound = bfq_bfqq_IO_bound(bfqq);\n\tbic->saved_in_large_burst = bfq_bfqq_in_large_burst(bfqq);\n\tbic->was_in_burst_list = !hlist_unhashed(&bfqq->burst_list_node);\n\tif (unlikely(bfq_bfqq_just_created(bfqq) &&\n\t\t     !bfq_bfqq_in_large_burst(bfqq) &&\n\t\t     bfqq->bfqd->low_latency)) {\n\t\t/*\n\t\t * bfqq being merged right after being created: bfqq\n\t\t * would have deserved interactive weight raising, but\n\t\t * did not make it to be set in a weight-raised state,\n\t\t * because of this early merge.\tStore directly the\n\t\t * weight-raising state that would have been assigned\n\t\t * to bfqq, so that to avoid that bfqq unjustly fails\n\t\t * to enjoy weight raising if split soon.\n\t\t */\n\t\tbic->saved_wr_coeff = bfqq->bfqd->bfq_wr_coeff;\n\t\tbic->saved_wr_start_at_switch_to_srt = bfq_smallest_from_now();\n\t\tbic->saved_wr_cur_max_time = bfq_wr_duration(bfqq->bfqd);\n\t\tbic->saved_last_wr_start_finish = jiffies;\n\t} else {\n\t\tbic->saved_wr_coeff = bfqq->wr_coeff;\n\t\tbic->saved_wr_start_at_switch_to_srt =\n\t\t\tbfqq->wr_start_at_switch_to_srt;\n\t\tbic->saved_last_wr_start_finish = bfqq->last_wr_start_finish;\n\t\tbic->saved_wr_cur_max_time = bfqq->wr_cur_max_time;\n\t}\n}\n\n\nstatic\nvoid bfq_release_process_ref(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\t/*\n\t * To prevent bfqq's service guarantees from being violated,\n\t * bfqq may be left busy, i.e., queued for service, even if\n\t * empty (see comments in __bfq_bfqq_expire() for\n\t * details). But, if no process will send requests to bfqq any\n\t * longer, then there is no point in keeping bfqq queued for\n\t * service. In addition, keeping bfqq queued for service, but\n\t * with no process ref any longer, may have caused bfqq to be\n\t * freed when dequeued from service. But this is assumed to\n\t * never happen.\n\t */\n\tif (bfq_bfqq_busy(bfqq) && RB_EMPTY_ROOT(&bfqq->sort_list) &&\n\t    bfqq != bfqd->in_service_queue)\n\t\tbfq_del_bfqq_busy(bfqd, bfqq, false);\n\n\tbfq_put_queue(bfqq);\n}\n\nstatic void\nbfq_merge_bfqqs(struct bfq_data *bfqd, struct bfq_io_cq *bic,\n\t\tstruct bfq_queue *bfqq, struct bfq_queue *new_bfqq)\n{\n\tbfq_log_bfqq(bfqd, bfqq, \"merging with queue %lu\",\n\t\t(unsigned long)new_bfqq->pid);\n\t/* Save weight raising and idle window of the merged queues */\n\tbfq_bfqq_save_state(bfqq);\n\tbfq_bfqq_save_state(new_bfqq);\n\tif (bfq_bfqq_IO_bound(bfqq))\n\t\tbfq_mark_bfqq_IO_bound(new_bfqq);\n\tbfq_clear_bfqq_IO_bound(bfqq);\n\n\t/*\n\t * If bfqq is weight-raised, then let new_bfqq inherit\n\t * weight-raising. To reduce false positives, neglect the case\n\t * where bfqq has just been created, but has not yet made it\n\t * to be weight-raised (which may happen because EQM may merge\n\t * bfqq even before bfq_add_request is executed for the first\n\t * time for bfqq). Handling this case would however be very\n\t * easy, thanks to the flag just_created.\n\t */\n\tif (new_bfqq->wr_coeff == 1 && bfqq->wr_coeff > 1) {\n\t\tnew_bfqq->wr_coeff = bfqq->wr_coeff;\n\t\tnew_bfqq->wr_cur_max_time = bfqq->wr_cur_max_time;\n\t\tnew_bfqq->last_wr_start_finish = bfqq->last_wr_start_finish;\n\t\tnew_bfqq->wr_start_at_switch_to_srt =\n\t\t\tbfqq->wr_start_at_switch_to_srt;\n\t\tif (bfq_bfqq_busy(new_bfqq))\n\t\t\tbfqd->wr_busy_queues++;\n\t\tnew_bfqq->entity.prio_changed = 1;\n\t}\n\n\tif (bfqq->wr_coeff > 1) { /* bfqq has given its wr to new_bfqq */\n\t\tbfqq->wr_coeff = 1;\n\t\tbfqq->entity.prio_changed = 1;\n\t\tif (bfq_bfqq_busy(bfqq))\n\t\t\tbfqd->wr_busy_queues--;\n\t}\n\n\tbfq_log_bfqq(bfqd, new_bfqq, \"merge_bfqqs: wr_busy %d\",\n\t\t     bfqd->wr_busy_queues);\n\n\t/*\n\t * Merge queues (that is, let bic redirect its requests to new_bfqq)\n\t */\n\tbic_set_bfqq(bic, new_bfqq, 1);\n\tbfq_mark_bfqq_coop(new_bfqq);\n\t/*\n\t * new_bfqq now belongs to at least two bics (it is a shared queue):\n\t * set new_bfqq->bic to NULL. bfqq either:\n\t * - does not belong to any bic any more, and hence bfqq->bic must\n\t *   be set to NULL, or\n\t * - is a queue whose owning bics have already been redirected to a\n\t *   different queue, hence the queue is destined to not belong to\n\t *   any bic soon and bfqq->bic is already NULL (therefore the next\n\t *   assignment causes no harm).\n\t */\n\tnew_bfqq->bic = NULL;\n\t/*\n\t * If the queue is shared, the pid is the pid of one of the associated\n\t * processes. Which pid depends on the exact sequence of merge events\n\t * the queue underwent. So printing such a pid is useless and confusing\n\t * because it reports a random pid between those of the associated\n\t * processes.\n\t * We mark such a queue with a pid -1, and then print SHARED instead of\n\t * a pid in logging messages.\n\t */\n\tnew_bfqq->pid = -1;\n\tbfqq->bic = NULL;\n\tbfq_release_process_ref(bfqd, bfqq);\n}\n\nstatic bool bfq_allow_bio_merge(struct request_queue *q, struct request *rq,\n\t\t\t\tstruct bio *bio)\n{\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\tbool is_sync = op_is_sync(bio->bi_opf);\n\tstruct bfq_queue *bfqq = bfqd->bio_bfqq, *new_bfqq;\n\n\t/*\n\t * Disallow merge of a sync bio into an async request.\n\t */\n\tif (is_sync && !rq_is_sync(rq))\n\t\treturn false;\n\n\t/*\n\t * Lookup the bfqq that this bio will be queued with. Allow\n\t * merge only if rq is queued there.\n\t */\n\tif (!bfqq)\n\t\treturn false;\n\n\t/*\n\t * We take advantage of this function to perform an early merge\n\t * of the queues of possible cooperating processes.\n\t */\n\tnew_bfqq = bfq_setup_cooperator(bfqd, bfqq, bio, false);\n\tif (new_bfqq) {\n\t\t/*\n\t\t * bic still points to bfqq, then it has not yet been\n\t\t * redirected to some other bfq_queue, and a queue\n\t\t * merge between bfqq and new_bfqq can be safely\n\t\t * fulfilled, i.e., bic can be redirected to new_bfqq\n\t\t * and bfqq can be put.\n\t\t */\n\t\tbfq_merge_bfqqs(bfqd, bfqd->bio_bic, bfqq,\n\t\t\t\tnew_bfqq);\n\t\t/*\n\t\t * If we get here, bio will be queued into new_queue,\n\t\t * so use new_bfqq to decide whether bio and rq can be\n\t\t * merged.\n\t\t */\n\t\tbfqq = new_bfqq;\n\n\t\t/*\n\t\t * Change also bqfd->bio_bfqq, as\n\t\t * bfqd->bio_bic now points to new_bfqq, and\n\t\t * this function may be invoked again (and then may\n\t\t * use again bqfd->bio_bfqq).\n\t\t */\n\t\tbfqd->bio_bfqq = bfqq;\n\t}\n\n\treturn bfqq == RQ_BFQQ(rq);\n}\n\n/*\n * Set the maximum time for the in-service queue to consume its\n * budget. This prevents seeky processes from lowering the throughput.\n * In practice, a time-slice service scheme is used with seeky\n * processes.\n */\nstatic void bfq_set_budget_timeout(struct bfq_data *bfqd,\n\t\t\t\t   struct bfq_queue *bfqq)\n{\n\tunsigned int timeout_coeff;\n\n\tif (bfqq->wr_cur_max_time == bfqd->bfq_wr_rt_max_time)\n\t\ttimeout_coeff = 1;\n\telse\n\t\ttimeout_coeff = bfqq->entity.weight / bfqq->entity.orig_weight;\n\n\tbfqd->last_budget_start = ktime_get();\n\n\tbfqq->budget_timeout = jiffies +\n\t\tbfqd->bfq_timeout * timeout_coeff;\n}\n\nstatic void __bfq_set_in_service_queue(struct bfq_data *bfqd,\n\t\t\t\t       struct bfq_queue *bfqq)\n{\n\tif (bfqq) {\n\t\tbfq_clear_bfqq_fifo_expire(bfqq);\n\n\t\tbfqd->budgets_assigned = (bfqd->budgets_assigned * 7 + 256) / 8;\n\n\t\tif (time_is_before_jiffies(bfqq->last_wr_start_finish) &&\n\t\t    bfqq->wr_coeff > 1 &&\n\t\t    bfqq->wr_cur_max_time == bfqd->bfq_wr_rt_max_time &&\n\t\t    time_is_before_jiffies(bfqq->budget_timeout)) {\n\t\t\t/*\n\t\t\t * For soft real-time queues, move the start\n\t\t\t * of the weight-raising period forward by the\n\t\t\t * time the queue has not received any\n\t\t\t * service. Otherwise, a relatively long\n\t\t\t * service delay is likely to cause the\n\t\t\t * weight-raising period of the queue to end,\n\t\t\t * because of the short duration of the\n\t\t\t * weight-raising period of a soft real-time\n\t\t\t * queue.  It is worth noting that this move\n\t\t\t * is not so dangerous for the other queues,\n\t\t\t * because soft real-time queues are not\n\t\t\t * greedy.\n\t\t\t *\n\t\t\t * To not add a further variable, we use the\n\t\t\t * overloaded field budget_timeout to\n\t\t\t * determine for how long the queue has not\n\t\t\t * received service, i.e., how much time has\n\t\t\t * elapsed since the queue expired. However,\n\t\t\t * this is a little imprecise, because\n\t\t\t * budget_timeout is set to jiffies if bfqq\n\t\t\t * not only expires, but also remains with no\n\t\t\t * request.\n\t\t\t */\n\t\t\tif (time_after(bfqq->budget_timeout,\n\t\t\t\t       bfqq->last_wr_start_finish))\n\t\t\t\tbfqq->last_wr_start_finish +=\n\t\t\t\t\tjiffies - bfqq->budget_timeout;\n\t\t\telse\n\t\t\t\tbfqq->last_wr_start_finish = jiffies;\n\t\t}\n\n\t\tbfq_set_budget_timeout(bfqd, bfqq);\n\t\tbfq_log_bfqq(bfqd, bfqq,\n\t\t\t     \"set_in_service_queue, cur-budget = %d\",\n\t\t\t     bfqq->entity.budget);\n\t}\n\n\tbfqd->in_service_queue = bfqq;\n}\n\n/*\n * Get and set a new queue for service.\n */\nstatic struct bfq_queue *bfq_set_in_service_queue(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq = bfq_get_next_queue(bfqd);\n\n\t__bfq_set_in_service_queue(bfqd, bfqq);\n\treturn bfqq;\n}\n\nstatic void bfq_arm_slice_timer(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq = bfqd->in_service_queue;\n\tu32 sl;\n\n\tbfq_mark_bfqq_wait_request(bfqq);\n\n\t/*\n\t * We don't want to idle for seeks, but we do want to allow\n\t * fair distribution of slice time for a process doing back-to-back\n\t * seeks. So allow a little bit of time for him to submit a new rq.\n\t */\n\tsl = bfqd->bfq_slice_idle;\n\t/*\n\t * Unless the queue is being weight-raised or the scenario is\n\t * asymmetric, grant only minimum idle time if the queue\n\t * is seeky. A long idling is preserved for a weight-raised\n\t * queue, or, more in general, in an asymmetric scenario,\n\t * because a long idling is needed for guaranteeing to a queue\n\t * its reserved share of the throughput (in particular, it is\n\t * needed if the queue has a higher weight than some other\n\t * queue).\n\t */\n\tif (BFQQ_SEEKY(bfqq) && bfqq->wr_coeff == 1 &&\n\t    !bfq_asymmetric_scenario(bfqd, bfqq))\n\t\tsl = min_t(u64, sl, BFQ_MIN_TT);\n\telse if (bfqq->wr_coeff > 1)\n\t\tsl = max_t(u32, sl, 20ULL * NSEC_PER_MSEC);\n\n\tbfqd->last_idling_start = ktime_get();\n\tbfqd->last_idling_start_jiffies = jiffies;\n\n\thrtimer_start(&bfqd->idle_slice_timer, ns_to_ktime(sl),\n\t\t      HRTIMER_MODE_REL);\n\tbfqg_stats_set_start_idle_time(bfqq_group(bfqq));\n}\n\n/*\n * In autotuning mode, max_budget is dynamically recomputed as the\n * amount of sectors transferred in timeout at the estimated peak\n * rate. This enables BFQ to utilize a full timeslice with a full\n * budget, even if the in-service queue is served at peak rate. And\n * this maximises throughput with sequential workloads.\n */\nstatic unsigned long bfq_calc_max_budget(struct bfq_data *bfqd)\n{\n\treturn (u64)bfqd->peak_rate * USEC_PER_MSEC *\n\t\tjiffies_to_msecs(bfqd->bfq_timeout)>>BFQ_RATE_SHIFT;\n}\n\n/*\n * Update parameters related to throughput and responsiveness, as a\n * function of the estimated peak rate. See comments on\n * bfq_calc_max_budget(), and on the ref_wr_duration array.\n */\nstatic void update_thr_responsiveness_params(struct bfq_data *bfqd)\n{\n\tif (bfqd->bfq_user_max_budget == 0) {\n\t\tbfqd->bfq_max_budget =\n\t\t\tbfq_calc_max_budget(bfqd);\n\t\tbfq_log(bfqd, \"new max_budget = %d\", bfqd->bfq_max_budget);\n\t}\n}\n\nstatic void bfq_reset_rate_computation(struct bfq_data *bfqd,\n\t\t\t\t       struct request *rq)\n{\n\tif (rq != NULL) { /* new rq dispatch now, reset accordingly */\n\t\tbfqd->last_dispatch = bfqd->first_dispatch = ktime_get_ns();\n\t\tbfqd->peak_rate_samples = 1;\n\t\tbfqd->sequential_samples = 0;\n\t\tbfqd->tot_sectors_dispatched = bfqd->last_rq_max_size =\n\t\t\tblk_rq_sectors(rq);\n\t} else /* no new rq dispatched, just reset the number of samples */\n\t\tbfqd->peak_rate_samples = 0; /* full re-init on next disp. */\n\n\tbfq_log(bfqd,\n\t\t\"reset_rate_computation at end, sample %u/%u tot_sects %llu\",\n\t\tbfqd->peak_rate_samples, bfqd->sequential_samples,\n\t\tbfqd->tot_sectors_dispatched);\n}\n\nstatic void bfq_update_rate_reset(struct bfq_data *bfqd, struct request *rq)\n{\n\tu32 rate, weight, divisor;\n\n\t/*\n\t * For the convergence property to hold (see comments on\n\t * bfq_update_peak_rate()) and for the assessment to be\n\t * reliable, a minimum number of samples must be present, and\n\t * a minimum amount of time must have elapsed. If not so, do\n\t * not compute new rate. Just reset parameters, to get ready\n\t * for a new evaluation attempt.\n\t */\n\tif (bfqd->peak_rate_samples < BFQ_RATE_MIN_SAMPLES ||\n\t    bfqd->delta_from_first < BFQ_RATE_MIN_INTERVAL)\n\t\tgoto reset_computation;\n\n\t/*\n\t * If a new request completion has occurred after last\n\t * dispatch, then, to approximate the rate at which requests\n\t * have been served by the device, it is more precise to\n\t * extend the observation interval to the last completion.\n\t */\n\tbfqd->delta_from_first =\n\t\tmax_t(u64, bfqd->delta_from_first,\n\t\t      bfqd->last_completion - bfqd->first_dispatch);\n\n\t/*\n\t * Rate computed in sects/usec, and not sects/nsec, for\n\t * precision issues.\n\t */\n\trate = div64_ul(bfqd->tot_sectors_dispatched<<BFQ_RATE_SHIFT,\n\t\t\tdiv_u64(bfqd->delta_from_first, NSEC_PER_USEC));\n\n\t/*\n\t * Peak rate not updated if:\n\t * - the percentage of sequential dispatches is below 3/4 of the\n\t *   total, and rate is below the current estimated peak rate\n\t * - rate is unreasonably high (> 20M sectors/sec)\n\t */\n\tif ((bfqd->sequential_samples < (3 * bfqd->peak_rate_samples)>>2 &&\n\t     rate <= bfqd->peak_rate) ||\n\t\trate > 20<<BFQ_RATE_SHIFT)\n\t\tgoto reset_computation;\n\n\t/*\n\t * We have to update the peak rate, at last! To this purpose,\n\t * we use a low-pass filter. We compute the smoothing constant\n\t * of the filter as a function of the 'weight' of the new\n\t * measured rate.\n\t *\n\t * As can be seen in next formulas, we define this weight as a\n\t * quantity proportional to how sequential the workload is,\n\t * and to how long the observation time interval is.\n\t *\n\t * The weight runs from 0 to 8. The maximum value of the\n\t * weight, 8, yields the minimum value for the smoothing\n\t * constant. At this minimum value for the smoothing constant,\n\t * the measured rate contributes for half of the next value of\n\t * the estimated peak rate.\n\t *\n\t * So, the first step is to compute the weight as a function\n\t * of how sequential the workload is. Note that the weight\n\t * cannot reach 9, because bfqd->sequential_samples cannot\n\t * become equal to bfqd->peak_rate_samples, which, in its\n\t * turn, holds true because bfqd->sequential_samples is not\n\t * incremented for the first sample.\n\t */\n\tweight = (9 * bfqd->sequential_samples) / bfqd->peak_rate_samples;\n\n\t/*\n\t * Second step: further refine the weight as a function of the\n\t * duration of the observation interval.\n\t */\n\tweight = min_t(u32, 8,\n\t\t       div_u64(weight * bfqd->delta_from_first,\n\t\t\t       BFQ_RATE_REF_INTERVAL));\n\n\t/*\n\t * Divisor ranging from 10, for minimum weight, to 2, for\n\t * maximum weight.\n\t */\n\tdivisor = 10 - weight;\n\n\t/*\n\t * Finally, update peak rate:\n\t *\n\t * peak_rate = peak_rate * (divisor-1) / divisor  +  rate / divisor\n\t */\n\tbfqd->peak_rate *= divisor-1;\n\tbfqd->peak_rate /= divisor;\n\trate /= divisor; /* smoothing constant alpha = 1/divisor */\n\n\tbfqd->peak_rate += rate;\n\n\t/*\n\t * For a very slow device, bfqd->peak_rate can reach 0 (see\n\t * the minimum representable values reported in the comments\n\t * on BFQ_RATE_SHIFT). Push to 1 if this happens, to avoid\n\t * divisions by zero where bfqd->peak_rate is used as a\n\t * divisor.\n\t */\n\tbfqd->peak_rate = max_t(u32, 1, bfqd->peak_rate);\n\n\tupdate_thr_responsiveness_params(bfqd);\n\nreset_computation:\n\tbfq_reset_rate_computation(bfqd, rq);\n}\n\n/*\n * Update the read/write peak rate (the main quantity used for\n * auto-tuning, see update_thr_responsiveness_params()).\n *\n * It is not trivial to estimate the peak rate (correctly): because of\n * the presence of sw and hw queues between the scheduler and the\n * device components that finally serve I/O requests, it is hard to\n * say exactly when a given dispatched request is served inside the\n * device, and for how long. As a consequence, it is hard to know\n * precisely at what rate a given set of requests is actually served\n * by the device.\n *\n * On the opposite end, the dispatch time of any request is trivially\n * available, and, from this piece of information, the \"dispatch rate\"\n * of requests can be immediately computed. So, the idea in the next\n * function is to use what is known, namely request dispatch times\n * (plus, when useful, request completion times), to estimate what is\n * unknown, namely in-device request service rate.\n *\n * The main issue is that, because of the above facts, the rate at\n * which a certain set of requests is dispatched over a certain time\n * interval can vary greatly with respect to the rate at which the\n * same requests are then served. But, since the size of any\n * intermediate queue is limited, and the service scheme is lossless\n * (no request is silently dropped), the following obvious convergence\n * property holds: the number of requests dispatched MUST become\n * closer and closer to the number of requests completed as the\n * observation interval grows. This is the key property used in\n * the next function to estimate the peak service rate as a function\n * of the observed dispatch rate. The function assumes to be invoked\n * on every request dispatch.\n */\nstatic void bfq_update_peak_rate(struct bfq_data *bfqd, struct request *rq)\n{\n\tu64 now_ns = ktime_get_ns();\n\n\tif (bfqd->peak_rate_samples == 0) { /* first dispatch */\n\t\tbfq_log(bfqd, \"update_peak_rate: goto reset, samples %d\",\n\t\t\tbfqd->peak_rate_samples);\n\t\tbfq_reset_rate_computation(bfqd, rq);\n\t\tgoto update_last_values; /* will add one sample */\n\t}\n\n\t/*\n\t * Device idle for very long: the observation interval lasting\n\t * up to this dispatch cannot be a valid observation interval\n\t * for computing a new peak rate (similarly to the late-\n\t * completion event in bfq_completed_request()). Go to\n\t * update_rate_and_reset to have the following three steps\n\t * taken:\n\t * - close the observation interval at the last (previous)\n\t *   request dispatch or completion\n\t * - compute rate, if possible, for that observation interval\n\t * - start a new observation interval with this dispatch\n\t */\n\tif (now_ns - bfqd->last_dispatch > 100*NSEC_PER_MSEC &&\n\t    bfqd->rq_in_driver == 0)\n\t\tgoto update_rate_and_reset;\n\n\t/* Update sampling information */\n\tbfqd->peak_rate_samples++;\n\n\tif ((bfqd->rq_in_driver > 0 ||\n\t\tnow_ns - bfqd->last_completion < BFQ_MIN_TT)\n\t    && !BFQ_RQ_SEEKY(bfqd, bfqd->last_position, rq))\n\t\tbfqd->sequential_samples++;\n\n\tbfqd->tot_sectors_dispatched += blk_rq_sectors(rq);\n\n\t/* Reset max observed rq size every 32 dispatches */\n\tif (likely(bfqd->peak_rate_samples % 32))\n\t\tbfqd->last_rq_max_size =\n\t\t\tmax_t(u32, blk_rq_sectors(rq), bfqd->last_rq_max_size);\n\telse\n\t\tbfqd->last_rq_max_size = blk_rq_sectors(rq);\n\n\tbfqd->delta_from_first = now_ns - bfqd->first_dispatch;\n\n\t/* Target observation interval not yet reached, go on sampling */\n\tif (bfqd->delta_from_first < BFQ_RATE_REF_INTERVAL)\n\t\tgoto update_last_values;\n\nupdate_rate_and_reset:\n\tbfq_update_rate_reset(bfqd, rq);\nupdate_last_values:\n\tbfqd->last_position = blk_rq_pos(rq) + blk_rq_sectors(rq);\n\tif (RQ_BFQQ(rq) == bfqd->in_service_queue)\n\t\tbfqd->in_serv_last_pos = bfqd->last_position;\n\tbfqd->last_dispatch = now_ns;\n}\n\n/*\n * Remove request from internal lists.\n */\nstatic void bfq_dispatch_remove(struct request_queue *q, struct request *rq)\n{\n\tstruct bfq_queue *bfqq = RQ_BFQQ(rq);\n\n\t/*\n\t * For consistency, the next instruction should have been\n\t * executed after removing the request from the queue and\n\t * dispatching it.  We execute instead this instruction before\n\t * bfq_remove_request() (and hence introduce a temporary\n\t * inconsistency), for efficiency.  In fact, should this\n\t * dispatch occur for a non in-service bfqq, this anticipated\n\t * increment prevents two counters related to bfqq->dispatched\n\t * from risking to be, first, uselessly decremented, and then\n\t * incremented again when the (new) value of bfqq->dispatched\n\t * happens to be taken into account.\n\t */\n\tbfqq->dispatched++;\n\tbfq_update_peak_rate(q->elevator->elevator_data, rq);\n\n\tbfq_remove_request(q, rq);\n}\n\n/*\n * There is a case where idling does not have to be performed for\n * throughput concerns, but to preserve the throughput share of\n * the process associated with bfqq.\n *\n * To introduce this case, we can note that allowing the drive\n * to enqueue more than one request at a time, and hence\n * delegating de facto final scheduling decisions to the\n * drive's internal scheduler, entails loss of control on the\n * actual request service order. In particular, the critical\n * situation is when requests from different processes happen\n * to be present, at the same time, in the internal queue(s)\n * of the drive. In such a situation, the drive, by deciding\n * the service order of the internally-queued requests, does\n * determine also the actual throughput distribution among\n * these processes. But the drive typically has no notion or\n * concern about per-process throughput distribution, and\n * makes its decisions only on a per-request basis. Therefore,\n * the service distribution enforced by the drive's internal\n * scheduler is likely to coincide with the desired throughput\n * distribution only in a completely symmetric, or favorably\n * skewed scenario where:\n * (i-a) each of these processes must get the same throughput as\n *\t the others,\n * (i-b) in case (i-a) does not hold, it holds that the process\n *       associated with bfqq must receive a lower or equal\n *\t throughput than any of the other processes;\n * (ii)  the I/O of each process has the same properties, in\n *       terms of locality (sequential or random), direction\n *       (reads or writes), request sizes, greediness\n *       (from I/O-bound to sporadic), and so on;\n\n * In fact, in such a scenario, the drive tends to treat the requests\n * of each process in about the same way as the requests of the\n * others, and thus to provide each of these processes with about the\n * same throughput.  This is exactly the desired throughput\n * distribution if (i-a) holds, or, if (i-b) holds instead, this is an\n * even more convenient distribution for (the process associated with)\n * bfqq.\n *\n * In contrast, in any asymmetric or unfavorable scenario, device\n * idling (I/O-dispatch plugging) is certainly needed to guarantee\n * that bfqq receives its assigned fraction of the device throughput\n * (see [1] for details).\n *\n * The problem is that idling may significantly reduce throughput with\n * certain combinations of types of I/O and devices. An important\n * example is sync random I/O on flash storage with command\n * queueing. So, unless bfqq falls in cases where idling also boosts\n * throughput, it is important to check conditions (i-a), i(-b) and\n * (ii) accurately, so as to avoid idling when not strictly needed for\n * service guarantees.\n *\n * Unfortunately, it is extremely difficult to thoroughly check\n * condition (ii). And, in case there are active groups, it becomes\n * very difficult to check conditions (i-a) and (i-b) too.  In fact,\n * if there are active groups, then, for conditions (i-a) or (i-b) to\n * become false 'indirectly', it is enough that an active group\n * contains more active processes or sub-groups than some other active\n * group. More precisely, for conditions (i-a) or (i-b) to become\n * false because of such a group, it is not even necessary that the\n * group is (still) active: it is sufficient that, even if the group\n * has become inactive, some of its descendant processes still have\n * some request already dispatched but still waiting for\n * completion. In fact, requests have still to be guaranteed their\n * share of the throughput even after being dispatched. In this\n * respect, it is easy to show that, if a group frequently becomes\n * inactive while still having in-flight requests, and if, when this\n * happens, the group is not considered in the calculation of whether\n * the scenario is asymmetric, then the group may fail to be\n * guaranteed its fair share of the throughput (basically because\n * idling may not be performed for the descendant processes of the\n * group, but it had to be).  We address this issue with the following\n * bi-modal behavior, implemented in the function\n * bfq_asymmetric_scenario().\n *\n * If there are groups with requests waiting for completion\n * (as commented above, some of these groups may even be\n * already inactive), then the scenario is tagged as\n * asymmetric, conservatively, without checking any of the\n * conditions (i-a), (i-b) or (ii). So the device is idled for bfqq.\n * This behavior matches also the fact that groups are created\n * exactly if controlling I/O is a primary concern (to\n * preserve bandwidth and latency guarantees).\n *\n * On the opposite end, if there are no groups with requests waiting\n * for completion, then only conditions (i-a) and (i-b) are actually\n * controlled, i.e., provided that conditions (i-a) or (i-b) holds,\n * idling is not performed, regardless of whether condition (ii)\n * holds.  In other words, only if conditions (i-a) and (i-b) do not\n * hold, then idling is allowed, and the device tends to be prevented\n * from queueing many requests, possibly of several processes. Since\n * there are no groups with requests waiting for completion, then, to\n * control conditions (i-a) and (i-b) it is enough to check just\n * whether all the queues with requests waiting for completion also\n * have the same weight.\n *\n * Not checking condition (ii) evidently exposes bfqq to the\n * risk of getting less throughput than its fair share.\n * However, for queues with the same weight, a further\n * mechanism, preemption, mitigates or even eliminates this\n * problem. And it does so without consequences on overall\n * throughput. This mechanism and its benefits are explained\n * in the next three paragraphs.\n *\n * Even if a queue, say Q, is expired when it remains idle, Q\n * can still preempt the new in-service queue if the next\n * request of Q arrives soon (see the comments on\n * bfq_bfqq_update_budg_for_activation). If all queues and\n * groups have the same weight, this form of preemption,\n * combined with the hole-recovery heuristic described in the\n * comments on function bfq_bfqq_update_budg_for_activation,\n * are enough to preserve a correct bandwidth distribution in\n * the mid term, even without idling. In fact, even if not\n * idling allows the internal queues of the device to contain\n * many requests, and thus to reorder requests, we can rather\n * safely assume that the internal scheduler still preserves a\n * minimum of mid-term fairness.\n *\n * More precisely, this preemption-based, idleless approach\n * provides fairness in terms of IOPS, and not sectors per\n * second. This can be seen with a simple example. Suppose\n * that there are two queues with the same weight, but that\n * the first queue receives requests of 8 sectors, while the\n * second queue receives requests of 1024 sectors. In\n * addition, suppose that each of the two queues contains at\n * most one request at a time, which implies that each queue\n * always remains idle after it is served. Finally, after\n * remaining idle, each queue receives very quickly a new\n * request. It follows that the two queues are served\n * alternatively, preempting each other if needed. This\n * implies that, although both queues have the same weight,\n * the queue with large requests receives a service that is\n * 1024/8 times as high as the service received by the other\n * queue.\n *\n * The motivation for using preemption instead of idling (for\n * queues with the same weight) is that, by not idling,\n * service guarantees are preserved (completely or at least in\n * part) without minimally sacrificing throughput. And, if\n * there is no active group, then the primary expectation for\n * this device is probably a high throughput.\n *\n * We are now left only with explaining the two sub-conditions in the\n * additional compound condition that is checked below for deciding\n * whether the scenario is asymmetric. To explain the first\n * sub-condition, we need to add that the function\n * bfq_asymmetric_scenario checks the weights of only\n * non-weight-raised queues, for efficiency reasons (see comments on\n * bfq_weights_tree_add()). Then the fact that bfqq is weight-raised\n * is checked explicitly here. More precisely, the compound condition\n * below takes into account also the fact that, even if bfqq is being\n * weight-raised, the scenario is still symmetric if all queues with\n * requests waiting for completion happen to be\n * weight-raised. Actually, we should be even more precise here, and\n * differentiate between interactive weight raising and soft real-time\n * weight raising.\n *\n * The second sub-condition checked in the compound condition is\n * whether there is a fair amount of already in-flight I/O not\n * belonging to bfqq. If so, I/O dispatching is to be plugged, for the\n * following reason. The drive may decide to serve in-flight\n * non-bfqq's I/O requests before bfqq's ones, thereby delaying the\n * arrival of new I/O requests for bfqq (recall that bfqq is sync). If\n * I/O-dispatching is not plugged, then, while bfqq remains empty, a\n * basically uncontrolled amount of I/O from other queues may be\n * dispatched too, possibly causing the service of bfqq's I/O to be\n * delayed even longer in the drive. This problem gets more and more\n * serious as the speed and the queue depth of the drive grow,\n * because, as these two quantities grow, the probability to find no\n * queue busy but many requests in flight grows too. By contrast,\n * plugging I/O dispatching minimizes the delay induced by already\n * in-flight I/O, and enables bfqq to recover the bandwidth it may\n * lose because of this delay.\n *\n * As a side note, it is worth considering that the above\n * device-idling countermeasures may however fail in the following\n * unlucky scenario: if I/O-dispatch plugging is (correctly) disabled\n * in a time period during which all symmetry sub-conditions hold, and\n * therefore the device is allowed to enqueue many requests, but at\n * some later point in time some sub-condition stops to hold, then it\n * may become impossible to make requests be served in the desired\n * order until all the requests already queued in the device have been\n * served. The last sub-condition commented above somewhat mitigates\n * this problem for weight-raised queues.\n */\nstatic bool idling_needed_for_service_guarantees(struct bfq_data *bfqd,\n\t\t\t\t\t\t struct bfq_queue *bfqq)\n{\n\t/* No point in idling for bfqq if it won't get requests any longer */\n\tif (unlikely(!bfqq_process_refs(bfqq)))\n\t\treturn false;\n\n\treturn (bfqq->wr_coeff > 1 &&\n\t\t(bfqd->wr_busy_queues <\n\t\t bfq_tot_busy_queues(bfqd) ||\n\t\t bfqd->rq_in_driver >=\n\t\t bfqq->dispatched + 4)) ||\n\t\tbfq_asymmetric_scenario(bfqd, bfqq);\n}\n\nstatic bool __bfq_bfqq_expire(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t      enum bfqq_expiration reason)\n{\n\t/*\n\t * If this bfqq is shared between multiple processes, check\n\t * to make sure that those processes are still issuing I/Os\n\t * within the mean seek distance. If not, it may be time to\n\t * break the queues apart again.\n\t */\n\tif (bfq_bfqq_coop(bfqq) && BFQQ_SEEKY(bfqq))\n\t\tbfq_mark_bfqq_split_coop(bfqq);\n\n\t/*\n\t * Consider queues with a higher finish virtual time than\n\t * bfqq. If idling_needed_for_service_guarantees(bfqq) returns\n\t * true, then bfqq's bandwidth would be violated if an\n\t * uncontrolled amount of I/O from these queues were\n\t * dispatched while bfqq is waiting for its new I/O to\n\t * arrive. This is exactly what may happen if this is a forced\n\t * expiration caused by a preemption attempt, and if bfqq is\n\t * not re-scheduled. To prevent this from happening, re-queue\n\t * bfqq if it needs I/O-dispatch plugging, even if it is\n\t * empty. By doing so, bfqq is granted to be served before the\n\t * above queues (provided that bfqq is of course eligible).\n\t */\n\tif (RB_EMPTY_ROOT(&bfqq->sort_list) &&\n\t    !(reason == BFQQE_PREEMPTED &&\n\t      idling_needed_for_service_guarantees(bfqd, bfqq))) {\n\t\tif (bfqq->dispatched == 0)\n\t\t\t/*\n\t\t\t * Overloading budget_timeout field to store\n\t\t\t * the time at which the queue remains with no\n\t\t\t * backlog and no outstanding request; used by\n\t\t\t * the weight-raising mechanism.\n\t\t\t */\n\t\t\tbfqq->budget_timeout = jiffies;\n\n\t\tbfq_del_bfqq_busy(bfqd, bfqq, true);\n\t} else {\n\t\tbfq_requeue_bfqq(bfqd, bfqq, true);\n\t\t/*\n\t\t * Resort priority tree of potential close cooperators.\n\t\t * See comments on bfq_pos_tree_add_move() for the unlikely().\n\t\t */\n\t\tif (unlikely(!bfqd->nonrot_with_queueing &&\n\t\t\t     !RB_EMPTY_ROOT(&bfqq->sort_list)))\n\t\t\tbfq_pos_tree_add_move(bfqd, bfqq);\n\t}\n\n\t/*\n\t * All in-service entities must have been properly deactivated\n\t * or requeued before executing the next function, which\n\t * resets all in-service entities as no more in service. This\n\t * may cause bfqq to be freed. If this happens, the next\n\t * function returns true.\n\t */\n\treturn __bfq_bfqd_reset_in_service(bfqd);\n}\n\n/**\n * __bfq_bfqq_recalc_budget - try to adapt the budget to the @bfqq behavior.\n * @bfqd: device data.\n * @bfqq: queue to update.\n * @reason: reason for expiration.\n *\n * Handle the feedback on @bfqq budget at queue expiration.\n * See the body for detailed comments.\n */\nstatic void __bfq_bfqq_recalc_budget(struct bfq_data *bfqd,\n\t\t\t\t     struct bfq_queue *bfqq,\n\t\t\t\t     enum bfqq_expiration reason)\n{\n\tstruct request *next_rq;\n\tint budget, min_budget;\n\n\tmin_budget = bfq_min_budget(bfqd);\n\n\tif (bfqq->wr_coeff == 1)\n\t\tbudget = bfqq->max_budget;\n\telse /*\n\t      * Use a constant, low budget for weight-raised queues,\n\t      * to help achieve a low latency. Keep it slightly higher\n\t      * than the minimum possible budget, to cause a little\n\t      * bit fewer expirations.\n\t      */\n\t\tbudget = 2 * min_budget;\n\n\tbfq_log_bfqq(bfqd, bfqq, \"recalc_budg: last budg %d, budg left %d\",\n\t\tbfqq->entity.budget, bfq_bfqq_budget_left(bfqq));\n\tbfq_log_bfqq(bfqd, bfqq, \"recalc_budg: last max_budg %d, min budg %d\",\n\t\tbudget, bfq_min_budget(bfqd));\n\tbfq_log_bfqq(bfqd, bfqq, \"recalc_budg: sync %d, seeky %d\",\n\t\tbfq_bfqq_sync(bfqq), BFQQ_SEEKY(bfqd->in_service_queue));\n\n\tif (bfq_bfqq_sync(bfqq) && bfqq->wr_coeff == 1) {\n\t\tswitch (reason) {\n\t\t/*\n\t\t * Caveat: in all the following cases we trade latency\n\t\t * for throughput.\n\t\t */\n\t\tcase BFQQE_TOO_IDLE:\n\t\t\t/*\n\t\t\t * This is the only case where we may reduce\n\t\t\t * the budget: if there is no request of the\n\t\t\t * process still waiting for completion, then\n\t\t\t * we assume (tentatively) that the timer has\n\t\t\t * expired because the batch of requests of\n\t\t\t * the process could have been served with a\n\t\t\t * smaller budget.  Hence, betting that\n\t\t\t * process will behave in the same way when it\n\t\t\t * becomes backlogged again, we reduce its\n\t\t\t * next budget.  As long as we guess right,\n\t\t\t * this budget cut reduces the latency\n\t\t\t * experienced by the process.\n\t\t\t *\n\t\t\t * However, if there are still outstanding\n\t\t\t * requests, then the process may have not yet\n\t\t\t * issued its next request just because it is\n\t\t\t * still waiting for the completion of some of\n\t\t\t * the still outstanding ones.  So in this\n\t\t\t * subcase we do not reduce its budget, on the\n\t\t\t * contrary we increase it to possibly boost\n\t\t\t * the throughput, as discussed in the\n\t\t\t * comments to the BUDGET_TIMEOUT case.\n\t\t\t */\n\t\t\tif (bfqq->dispatched > 0) /* still outstanding reqs */\n\t\t\t\tbudget = min(budget * 2, bfqd->bfq_max_budget);\n\t\t\telse {\n\t\t\t\tif (budget > 5 * min_budget)\n\t\t\t\t\tbudget -= 4 * min_budget;\n\t\t\t\telse\n\t\t\t\t\tbudget = min_budget;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BFQQE_BUDGET_TIMEOUT:\n\t\t\t/*\n\t\t\t * We double the budget here because it gives\n\t\t\t * the chance to boost the throughput if this\n\t\t\t * is not a seeky process (and has bumped into\n\t\t\t * this timeout because of, e.g., ZBR).\n\t\t\t */\n\t\t\tbudget = min(budget * 2, bfqd->bfq_max_budget);\n\t\t\tbreak;\n\t\tcase BFQQE_BUDGET_EXHAUSTED:\n\t\t\t/*\n\t\t\t * The process still has backlog, and did not\n\t\t\t * let either the budget timeout or the disk\n\t\t\t * idling timeout expire. Hence it is not\n\t\t\t * seeky, has a short thinktime and may be\n\t\t\t * happy with a higher budget too. So\n\t\t\t * definitely increase the budget of this good\n\t\t\t * candidate to boost the disk throughput.\n\t\t\t */\n\t\t\tbudget = min(budget * 4, bfqd->bfq_max_budget);\n\t\t\tbreak;\n\t\tcase BFQQE_NO_MORE_REQUESTS:\n\t\t\t/*\n\t\t\t * For queues that expire for this reason, it\n\t\t\t * is particularly important to keep the\n\t\t\t * budget close to the actual service they\n\t\t\t * need. Doing so reduces the timestamp\n\t\t\t * misalignment problem described in the\n\t\t\t * comments in the body of\n\t\t\t * __bfq_activate_entity. In fact, suppose\n\t\t\t * that a queue systematically expires for\n\t\t\t * BFQQE_NO_MORE_REQUESTS and presents a\n\t\t\t * new request in time to enjoy timestamp\n\t\t\t * back-shifting. The larger the budget of the\n\t\t\t * queue is with respect to the service the\n\t\t\t * queue actually requests in each service\n\t\t\t * slot, the more times the queue can be\n\t\t\t * reactivated with the same virtual finish\n\t\t\t * time. It follows that, even if this finish\n\t\t\t * time is pushed to the system virtual time\n\t\t\t * to reduce the consequent timestamp\n\t\t\t * misalignment, the queue unjustly enjoys for\n\t\t\t * many re-activations a lower finish time\n\t\t\t * than all newly activated queues.\n\t\t\t *\n\t\t\t * The service needed by bfqq is measured\n\t\t\t * quite precisely by bfqq->entity.service.\n\t\t\t * Since bfqq does not enjoy device idling,\n\t\t\t * bfqq->entity.service is equal to the number\n\t\t\t * of sectors that the process associated with\n\t\t\t * bfqq requested to read/write before waiting\n\t\t\t * for request completions, or blocking for\n\t\t\t * other reasons.\n\t\t\t */\n\t\t\tbudget = max_t(int, bfqq->entity.service, min_budget);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t} else if (!bfq_bfqq_sync(bfqq)) {\n\t\t/*\n\t\t * Async queues get always the maximum possible\n\t\t * budget, as for them we do not care about latency\n\t\t * (in addition, their ability to dispatch is limited\n\t\t * by the charging factor).\n\t\t */\n\t\tbudget = bfqd->bfq_max_budget;\n\t}\n\n\tbfqq->max_budget = budget;\n\n\tif (bfqd->budgets_assigned >= bfq_stats_min_budgets &&\n\t    !bfqd->bfq_user_max_budget)\n\t\tbfqq->max_budget = min(bfqq->max_budget, bfqd->bfq_max_budget);\n\n\t/*\n\t * If there is still backlog, then assign a new budget, making\n\t * sure that it is large enough for the next request.  Since\n\t * the finish time of bfqq must be kept in sync with the\n\t * budget, be sure to call __bfq_bfqq_expire() *after* this\n\t * update.\n\t *\n\t * If there is no backlog, then no need to update the budget;\n\t * it will be updated on the arrival of a new request.\n\t */\n\tnext_rq = bfqq->next_rq;\n\tif (next_rq)\n\t\tbfqq->entity.budget = max_t(unsigned long, bfqq->max_budget,\n\t\t\t\t\t    bfq_serv_to_charge(next_rq, bfqq));\n\n\tbfq_log_bfqq(bfqd, bfqq, \"head sect: %u, new budget %d\",\n\t\t\tnext_rq ? blk_rq_sectors(next_rq) : 0,\n\t\t\tbfqq->entity.budget);\n}\n\n/*\n * Return true if the process associated with bfqq is \"slow\". The slow\n * flag is used, in addition to the budget timeout, to reduce the\n * amount of service provided to seeky processes, and thus reduce\n * their chances to lower the throughput. More details in the comments\n * on the function bfq_bfqq_expire().\n *\n * An important observation is in order: as discussed in the comments\n * on the function bfq_update_peak_rate(), with devices with internal\n * queues, it is hard if ever possible to know when and for how long\n * an I/O request is processed by the device (apart from the trivial\n * I/O pattern where a new request is dispatched only after the\n * previous one has been completed). This makes it hard to evaluate\n * the real rate at which the I/O requests of each bfq_queue are\n * served.  In fact, for an I/O scheduler like BFQ, serving a\n * bfq_queue means just dispatching its requests during its service\n * slot (i.e., until the budget of the queue is exhausted, or the\n * queue remains idle, or, finally, a timeout fires). But, during the\n * service slot of a bfq_queue, around 100 ms at most, the device may\n * be even still processing requests of bfq_queues served in previous\n * service slots. On the opposite end, the requests of the in-service\n * bfq_queue may be completed after the service slot of the queue\n * finishes.\n *\n * Anyway, unless more sophisticated solutions are used\n * (where possible), the sum of the sizes of the requests dispatched\n * during the service slot of a bfq_queue is probably the only\n * approximation available for the service received by the bfq_queue\n * during its service slot. And this sum is the quantity used in this\n * function to evaluate the I/O speed of a process.\n */\nstatic bool bfq_bfqq_is_slow(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t\t bool compensate, enum bfqq_expiration reason,\n\t\t\t\t unsigned long *delta_ms)\n{\n\tktime_t delta_ktime;\n\tu32 delta_usecs;\n\tbool slow = BFQQ_SEEKY(bfqq); /* if delta too short, use seekyness */\n\n\tif (!bfq_bfqq_sync(bfqq))\n\t\treturn false;\n\n\tif (compensate)\n\t\tdelta_ktime = bfqd->last_idling_start;\n\telse\n\t\tdelta_ktime = ktime_get();\n\tdelta_ktime = ktime_sub(delta_ktime, bfqd->last_budget_start);\n\tdelta_usecs = ktime_to_us(delta_ktime);\n\n\t/* don't use too short time intervals */\n\tif (delta_usecs < 1000) {\n\t\tif (blk_queue_nonrot(bfqd->queue))\n\t\t\t /*\n\t\t\t  * give same worst-case guarantees as idling\n\t\t\t  * for seeky\n\t\t\t  */\n\t\t\t*delta_ms = BFQ_MIN_TT / NSEC_PER_MSEC;\n\t\telse /* charge at least one seek */\n\t\t\t*delta_ms = bfq_slice_idle / NSEC_PER_MSEC;\n\n\t\treturn slow;\n\t}\n\n\t*delta_ms = delta_usecs / USEC_PER_MSEC;\n\n\t/*\n\t * Use only long (> 20ms) intervals to filter out excessive\n\t * spikes in service rate estimation.\n\t */\n\tif (delta_usecs > 20000) {\n\t\t/*\n\t\t * Caveat for rotational devices: processes doing I/O\n\t\t * in the slower disk zones tend to be slow(er) even\n\t\t * if not seeky. In this respect, the estimated peak\n\t\t * rate is likely to be an average over the disk\n\t\t * surface. Accordingly, to not be too harsh with\n\t\t * unlucky processes, a process is deemed slow only if\n\t\t * its rate has been lower than half of the estimated\n\t\t * peak rate.\n\t\t */\n\t\tslow = bfqq->entity.service < bfqd->bfq_max_budget / 2;\n\t}\n\n\tbfq_log_bfqq(bfqd, bfqq, \"bfq_bfqq_is_slow: slow %d\", slow);\n\n\treturn slow;\n}\n\n/*\n * To be deemed as soft real-time, an application must meet two\n * requirements. First, the application must not require an average\n * bandwidth higher than the approximate bandwidth required to playback or\n * record a compressed high-definition video.\n * The next function is invoked on the completion of the last request of a\n * batch, to compute the next-start time instant, soft_rt_next_start, such\n * that, if the next request of the application does not arrive before\n * soft_rt_next_start, then the above requirement on the bandwidth is met.\n *\n * The second requirement is that the request pattern of the application is\n * isochronous, i.e., that, after issuing a request or a batch of requests,\n * the application stops issuing new requests until all its pending requests\n * have been completed. After that, the application may issue a new batch,\n * and so on.\n * For this reason the next function is invoked to compute\n * soft_rt_next_start only for applications that meet this requirement,\n * whereas soft_rt_next_start is set to infinity for applications that do\n * not.\n *\n * Unfortunately, even a greedy (i.e., I/O-bound) application may\n * happen to meet, occasionally or systematically, both the above\n * bandwidth and isochrony requirements. This may happen at least in\n * the following circumstances. First, if the CPU load is high. The\n * application may stop issuing requests while the CPUs are busy\n * serving other processes, then restart, then stop again for a while,\n * and so on. The other circumstances are related to the storage\n * device: the storage device is highly loaded or reaches a low-enough\n * throughput with the I/O of the application (e.g., because the I/O\n * is random and/or the device is slow). In all these cases, the\n * I/O of the application may be simply slowed down enough to meet\n * the bandwidth and isochrony requirements. To reduce the probability\n * that greedy applications are deemed as soft real-time in these\n * corner cases, a further rule is used in the computation of\n * soft_rt_next_start: the return value of this function is forced to\n * be higher than the maximum between the following two quantities.\n *\n * (a) Current time plus: (1) the maximum time for which the arrival\n *     of a request is waited for when a sync queue becomes idle,\n *     namely bfqd->bfq_slice_idle, and (2) a few extra jiffies. We\n *     postpone for a moment the reason for adding a few extra\n *     jiffies; we get back to it after next item (b).  Lower-bounding\n *     the return value of this function with the current time plus\n *     bfqd->bfq_slice_idle tends to filter out greedy applications,\n *     because the latter issue their next request as soon as possible\n *     after the last one has been completed. In contrast, a soft\n *     real-time application spends some time processing data, after a\n *     batch of its requests has been completed.\n *\n * (b) Current value of bfqq->soft_rt_next_start. As pointed out\n *     above, greedy applications may happen to meet both the\n *     bandwidth and isochrony requirements under heavy CPU or\n *     storage-device load. In more detail, in these scenarios, these\n *     applications happen, only for limited time periods, to do I/O\n *     slowly enough to meet all the requirements described so far,\n *     including the filtering in above item (a). These slow-speed\n *     time intervals are usually interspersed between other time\n *     intervals during which these applications do I/O at a very high\n *     speed. Fortunately, exactly because of the high speed of the\n *     I/O in the high-speed intervals, the values returned by this\n *     function happen to be so high, near the end of any such\n *     high-speed interval, to be likely to fall *after* the end of\n *     the low-speed time interval that follows. These high values are\n *     stored in bfqq->soft_rt_next_start after each invocation of\n *     this function. As a consequence, if the last value of\n *     bfqq->soft_rt_next_start is constantly used to lower-bound the\n *     next value that this function may return, then, from the very\n *     beginning of a low-speed interval, bfqq->soft_rt_next_start is\n *     likely to be constantly kept so high that any I/O request\n *     issued during the low-speed interval is considered as arriving\n *     to soon for the application to be deemed as soft\n *     real-time. Then, in the high-speed interval that follows, the\n *     application will not be deemed as soft real-time, just because\n *     it will do I/O at a high speed. And so on.\n *\n * Getting back to the filtering in item (a), in the following two\n * cases this filtering might be easily passed by a greedy\n * application, if the reference quantity was just\n * bfqd->bfq_slice_idle:\n * 1) HZ is so low that the duration of a jiffy is comparable to or\n *    higher than bfqd->bfq_slice_idle. This happens, e.g., on slow\n *    devices with HZ=100. The time granularity may be so coarse\n *    that the approximation, in jiffies, of bfqd->bfq_slice_idle\n *    is rather lower than the exact value.\n * 2) jiffies, instead of increasing at a constant rate, may stop increasing\n *    for a while, then suddenly 'jump' by several units to recover the lost\n *    increments. This seems to happen, e.g., inside virtual machines.\n * To address this issue, in the filtering in (a) we do not use as a\n * reference time interval just bfqd->bfq_slice_idle, but\n * bfqd->bfq_slice_idle plus a few jiffies. In particular, we add the\n * minimum number of jiffies for which the filter seems to be quite\n * precise also in embedded systems and KVM/QEMU virtual machines.\n */\nstatic unsigned long bfq_bfqq_softrt_next_start(struct bfq_data *bfqd,\n\t\t\t\t\t\tstruct bfq_queue *bfqq)\n{\n\treturn max3(bfqq->soft_rt_next_start,\n\t\t    bfqq->last_idle_bklogged +\n\t\t    HZ * bfqq->service_from_backlogged /\n\t\t    bfqd->bfq_wr_max_softrt_rate,\n\t\t    jiffies + nsecs_to_jiffies(bfqq->bfqd->bfq_slice_idle) + 4);\n}\n\n/**\n * bfq_bfqq_expire - expire a queue.\n * @bfqd: device owning the queue.\n * @bfqq: the queue to expire.\n * @compensate: if true, compensate for the time spent idling.\n * @reason: the reason causing the expiration.\n *\n * If the process associated with bfqq does slow I/O (e.g., because it\n * issues random requests), we charge bfqq with the time it has been\n * in service instead of the service it has received (see\n * bfq_bfqq_charge_time for details on how this goal is achieved). As\n * a consequence, bfqq will typically get higher timestamps upon\n * reactivation, and hence it will be rescheduled as if it had\n * received more service than what it has actually received. In the\n * end, bfqq receives less service in proportion to how slowly its\n * associated process consumes its budgets (and hence how seriously it\n * tends to lower the throughput). In addition, this time-charging\n * strategy guarantees time fairness among slow processes. In\n * contrast, if the process associated with bfqq is not slow, we\n * charge bfqq exactly with the service it has received.\n *\n * Charging time to the first type of queues and the exact service to\n * the other has the effect of using the WF2Q+ policy to schedule the\n * former on a timeslice basis, without violating service domain\n * guarantees among the latter.\n */\nvoid bfq_bfqq_expire(struct bfq_data *bfqd,\n\t\t     struct bfq_queue *bfqq,\n\t\t     bool compensate,\n\t\t     enum bfqq_expiration reason)\n{\n\tbool slow;\n\tunsigned long delta = 0;\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\t/*\n\t * Check whether the process is slow (see bfq_bfqq_is_slow).\n\t */\n\tslow = bfq_bfqq_is_slow(bfqd, bfqq, compensate, reason, &delta);\n\n\t/*\n\t * As above explained, charge slow (typically seeky) and\n\t * timed-out queues with the time and not the service\n\t * received, to favor sequential workloads.\n\t *\n\t * Processes doing I/O in the slower disk zones will tend to\n\t * be slow(er) even if not seeky. Therefore, since the\n\t * estimated peak rate is actually an average over the disk\n\t * surface, these processes may timeout just for bad luck. To\n\t * avoid punishing them, do not charge time to processes that\n\t * succeeded in consuming at least 2/3 of their budget. This\n\t * allows BFQ to preserve enough elasticity to still perform\n\t * bandwidth, and not time, distribution with little unlucky\n\t * or quasi-sequential processes.\n\t */\n\tif (bfqq->wr_coeff == 1 &&\n\t    (slow ||\n\t     (reason == BFQQE_BUDGET_TIMEOUT &&\n\t      bfq_bfqq_budget_left(bfqq) >=  entity->budget / 3)))\n\t\tbfq_bfqq_charge_time(bfqd, bfqq, delta);\n\n\tif (reason == BFQQE_TOO_IDLE &&\n\t    entity->service <= 2 * entity->budget / 10)\n\t\tbfq_clear_bfqq_IO_bound(bfqq);\n\n\tif (bfqd->low_latency && bfqq->wr_coeff == 1)\n\t\tbfqq->last_wr_start_finish = jiffies;\n\n\tif (bfqd->low_latency && bfqd->bfq_wr_max_softrt_rate > 0 &&\n\t    RB_EMPTY_ROOT(&bfqq->sort_list)) {\n\t\t/*\n\t\t * If we get here, and there are no outstanding\n\t\t * requests, then the request pattern is isochronous\n\t\t * (see the comments on the function\n\t\t * bfq_bfqq_softrt_next_start()). Thus we can compute\n\t\t * soft_rt_next_start. And we do it, unless bfqq is in\n\t\t * interactive weight raising. We do not do it in the\n\t\t * latter subcase, for the following reason. bfqq may\n\t\t * be conveying the I/O needed to load a soft\n\t\t * real-time application. Such an application will\n\t\t * actually exhibit a soft real-time I/O pattern after\n\t\t * it finally starts doing its job. But, if\n\t\t * soft_rt_next_start is computed here for an\n\t\t * interactive bfqq, and bfqq had received a lot of\n\t\t * service before remaining with no outstanding\n\t\t * request (likely to happen on a fast device), then\n\t\t * soft_rt_next_start would be assigned such a high\n\t\t * value that, for a very long time, bfqq would be\n\t\t * prevented from being possibly considered as soft\n\t\t * real time.\n\t\t *\n\t\t * If, instead, the queue still has outstanding\n\t\t * requests, then we have to wait for the completion\n\t\t * of all the outstanding requests to discover whether\n\t\t * the request pattern is actually isochronous.\n\t\t */\n\t\tif (bfqq->dispatched == 0 &&\n\t\t    bfqq->wr_coeff != bfqd->bfq_wr_coeff)\n\t\t\tbfqq->soft_rt_next_start =\n\t\t\t\tbfq_bfqq_softrt_next_start(bfqd, bfqq);\n\t\telse if (bfqq->dispatched > 0) {\n\t\t\t/*\n\t\t\t * Schedule an update of soft_rt_next_start to when\n\t\t\t * the task may be discovered to be isochronous.\n\t\t\t */\n\t\t\tbfq_mark_bfqq_softrt_update(bfqq);\n\t\t}\n\t}\n\n\tbfq_log_bfqq(bfqd, bfqq,\n\t\t\"expire (%d, slow %d, num_disp %d, short_ttime %d)\", reason,\n\t\tslow, bfqq->dispatched, bfq_bfqq_has_short_ttime(bfqq));\n\n\t/*\n\t * bfqq expired, so no total service time needs to be computed\n\t * any longer: reset state machine for measuring total service\n\t * times.\n\t */\n\tbfqd->rqs_injected = bfqd->wait_dispatch = false;\n\tbfqd->waited_rq = NULL;\n\n\t/*\n\t * Increase, decrease or leave budget unchanged according to\n\t * reason.\n\t */\n\t__bfq_bfqq_recalc_budget(bfqd, bfqq, reason);\n\tif (__bfq_bfqq_expire(bfqd, bfqq, reason))\n\t\t/* bfqq is gone, no more actions on it */\n\t\treturn;\n\n\t/* mark bfqq as waiting a request only if a bic still points to it */\n\tif (!bfq_bfqq_busy(bfqq) &&\n\t    reason != BFQQE_BUDGET_TIMEOUT &&\n\t    reason != BFQQE_BUDGET_EXHAUSTED) {\n\t\tbfq_mark_bfqq_non_blocking_wait_rq(bfqq);\n\t\t/*\n\t\t * Not setting service to 0, because, if the next rq\n\t\t * arrives in time, the queue will go on receiving\n\t\t * service with this same budget (as if it never expired)\n\t\t */\n\t} else\n\t\tentity->service = 0;\n\n\t/*\n\t * Reset the received-service counter for every parent entity.\n\t * Differently from what happens with bfqq->entity.service,\n\t * the resetting of this counter never needs to be postponed\n\t * for parent entities. In fact, in case bfqq may have a\n\t * chance to go on being served using the last, partially\n\t * consumed budget, bfqq->entity.service needs to be kept,\n\t * because if bfqq then actually goes on being served using\n\t * the same budget, the last value of bfqq->entity.service is\n\t * needed to properly decrement bfqq->entity.budget by the\n\t * portion already consumed. In contrast, it is not necessary\n\t * to keep entity->service for parent entities too, because\n\t * the bubble up of the new value of bfqq->entity.budget will\n\t * make sure that the budgets of parent entities are correct,\n\t * even in case bfqq and thus parent entities go on receiving\n\t * service with the same budget.\n\t */\n\tentity = entity->parent;\n\tfor_each_entity(entity)\n\t\tentity->service = 0;\n}\n\n/*\n * Budget timeout is not implemented through a dedicated timer, but\n * just checked on request arrivals and completions, as well as on\n * idle timer expirations.\n */\nstatic bool bfq_bfqq_budget_timeout(struct bfq_queue *bfqq)\n{\n\treturn time_is_before_eq_jiffies(bfqq->budget_timeout);\n}\n\n/*\n * If we expire a queue that is actively waiting (i.e., with the\n * device idled) for the arrival of a new request, then we may incur\n * the timestamp misalignment problem described in the body of the\n * function __bfq_activate_entity. Hence we return true only if this\n * condition does not hold, or if the queue is slow enough to deserve\n * only to be kicked off for preserving a high throughput.\n */\nstatic bool bfq_may_expire_for_budg_timeout(struct bfq_queue *bfqq)\n{\n\tbfq_log_bfqq(bfqq->bfqd, bfqq,\n\t\t\"may_budget_timeout: wait_request %d left %d timeout %d\",\n\t\tbfq_bfqq_wait_request(bfqq),\n\t\t\tbfq_bfqq_budget_left(bfqq) >=  bfqq->entity.budget / 3,\n\t\tbfq_bfqq_budget_timeout(bfqq));\n\n\treturn (!bfq_bfqq_wait_request(bfqq) ||\n\t\tbfq_bfqq_budget_left(bfqq) >=  bfqq->entity.budget / 3)\n\t\t&&\n\t\tbfq_bfqq_budget_timeout(bfqq);\n}\n\nstatic bool idling_boosts_thr_without_issues(struct bfq_data *bfqd,\n\t\t\t\t\t     struct bfq_queue *bfqq)\n{\n\tbool rot_without_queueing =\n\t\t!blk_queue_nonrot(bfqd->queue) && !bfqd->hw_tag,\n\t\tbfqq_sequential_and_IO_bound,\n\t\tidling_boosts_thr;\n\n\t/* No point in idling for bfqq if it won't get requests any longer */\n\tif (unlikely(!bfqq_process_refs(bfqq)))\n\t\treturn false;\n\n\tbfqq_sequential_and_IO_bound = !BFQQ_SEEKY(bfqq) &&\n\t\tbfq_bfqq_IO_bound(bfqq) && bfq_bfqq_has_short_ttime(bfqq);\n\n\t/*\n\t * The next variable takes into account the cases where idling\n\t * boosts the throughput.\n\t *\n\t * The value of the variable is computed considering, first, that\n\t * idling is virtually always beneficial for the throughput if:\n\t * (a) the device is not NCQ-capable and rotational, or\n\t * (b) regardless of the presence of NCQ, the device is rotational and\n\t *     the request pattern for bfqq is I/O-bound and sequential, or\n\t * (c) regardless of whether it is rotational, the device is\n\t *     not NCQ-capable and the request pattern for bfqq is\n\t *     I/O-bound and sequential.\n\t *\n\t * Secondly, and in contrast to the above item (b), idling an\n\t * NCQ-capable flash-based device would not boost the\n\t * throughput even with sequential I/O; rather it would lower\n\t * the throughput in proportion to how fast the device\n\t * is. Accordingly, the next variable is true if any of the\n\t * above conditions (a), (b) or (c) is true, and, in\n\t * particular, happens to be false if bfqd is an NCQ-capable\n\t * flash-based device.\n\t */\n\tidling_boosts_thr = rot_without_queueing ||\n\t\t((!blk_queue_nonrot(bfqd->queue) || !bfqd->hw_tag) &&\n\t\t bfqq_sequential_and_IO_bound);\n\n\t/*\n\t * The return value of this function is equal to that of\n\t * idling_boosts_thr, unless a special case holds. In this\n\t * special case, described below, idling may cause problems to\n\t * weight-raised queues.\n\t *\n\t * When the request pool is saturated (e.g., in the presence\n\t * of write hogs), if the processes associated with\n\t * non-weight-raised queues ask for requests at a lower rate,\n\t * then processes associated with weight-raised queues have a\n\t * higher probability to get a request from the pool\n\t * immediately (or at least soon) when they need one. Thus\n\t * they have a higher probability to actually get a fraction\n\t * of the device throughput proportional to their high\n\t * weight. This is especially true with NCQ-capable drives,\n\t * which enqueue several requests in advance, and further\n\t * reorder internally-queued requests.\n\t *\n\t * For this reason, we force to false the return value if\n\t * there are weight-raised busy queues. In this case, and if\n\t * bfqq is not weight-raised, this guarantees that the device\n\t * is not idled for bfqq (if, instead, bfqq is weight-raised,\n\t * then idling will be guaranteed by another variable, see\n\t * below). Combined with the timestamping rules of BFQ (see\n\t * [1] for details), this behavior causes bfqq, and hence any\n\t * sync non-weight-raised queue, to get a lower number of\n\t * requests served, and thus to ask for a lower number of\n\t * requests from the request pool, before the busy\n\t * weight-raised queues get served again. This often mitigates\n\t * starvation problems in the presence of heavy write\n\t * workloads and NCQ, thereby guaranteeing a higher\n\t * application and system responsiveness in these hostile\n\t * scenarios.\n\t */\n\treturn idling_boosts_thr &&\n\t\tbfqd->wr_busy_queues == 0;\n}\n\n/*\n * For a queue that becomes empty, device idling is allowed only if\n * this function returns true for that queue. As a consequence, since\n * device idling plays a critical role for both throughput boosting\n * and service guarantees, the return value of this function plays a\n * critical role as well.\n *\n * In a nutshell, this function returns true only if idling is\n * beneficial for throughput or, even if detrimental for throughput,\n * idling is however necessary to preserve service guarantees (low\n * latency, desired throughput distribution, ...). In particular, on\n * NCQ-capable devices, this function tries to return false, so as to\n * help keep the drives' internal queues full, whenever this helps the\n * device boost the throughput without causing any service-guarantee\n * issue.\n *\n * Most of the issues taken into account to get the return value of\n * this function are not trivial. We discuss these issues in the two\n * functions providing the main pieces of information needed by this\n * function.\n */\nstatic bool bfq_better_to_idle(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tbool idling_boosts_thr_with_no_issue, idling_needed_for_service_guar;\n\n\t/* No point in idling for bfqq if it won't get requests any longer */\n\tif (unlikely(!bfqq_process_refs(bfqq)))\n\t\treturn false;\n\n\tif (unlikely(bfqd->strict_guarantees))\n\t\treturn true;\n\n\t/*\n\t * Idling is performed only if slice_idle > 0. In addition, we\n\t * do not idle if\n\t * (a) bfqq is async\n\t * (b) bfqq is in the idle io prio class: in this case we do\n\t * not idle because we want to minimize the bandwidth that\n\t * queues in this class can steal to higher-priority queues\n\t */\n\tif (bfqd->bfq_slice_idle == 0 || !bfq_bfqq_sync(bfqq) ||\n\t   bfq_class_idle(bfqq))\n\t\treturn false;\n\n\tidling_boosts_thr_with_no_issue =\n\t\tidling_boosts_thr_without_issues(bfqd, bfqq);\n\n\tidling_needed_for_service_guar =\n\t\tidling_needed_for_service_guarantees(bfqd, bfqq);\n\n\t/*\n\t * We have now the two components we need to compute the\n\t * return value of the function, which is true only if idling\n\t * either boosts the throughput (without issues), or is\n\t * necessary to preserve service guarantees.\n\t */\n\treturn idling_boosts_thr_with_no_issue ||\n\t\tidling_needed_for_service_guar;\n}\n\n/*\n * If the in-service queue is empty but the function bfq_better_to_idle\n * returns true, then:\n * 1) the queue must remain in service and cannot be expired, and\n * 2) the device must be idled to wait for the possible arrival of a new\n *    request for the queue.\n * See the comments on the function bfq_better_to_idle for the reasons\n * why performing device idling is the best choice to boost the throughput\n * and preserve service guarantees when bfq_better_to_idle itself\n * returns true.\n */\nstatic bool bfq_bfqq_must_idle(struct bfq_queue *bfqq)\n{\n\treturn RB_EMPTY_ROOT(&bfqq->sort_list) && bfq_better_to_idle(bfqq);\n}\n\n/*\n * This function chooses the queue from which to pick the next extra\n * I/O request to inject, if it finds a compatible queue. See the\n * comments on bfq_update_inject_limit() for details on the injection\n * mechanism, and for the definitions of the quantities mentioned\n * below.\n */\nstatic struct bfq_queue *\nbfq_choose_bfqq_for_injection(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq, *in_serv_bfqq = bfqd->in_service_queue;\n\tunsigned int limit = in_serv_bfqq->inject_limit;\n\t/*\n\t * If\n\t * - bfqq is not weight-raised and therefore does not carry\n\t *   time-critical I/O,\n\t * or\n\t * - regardless of whether bfqq is weight-raised, bfqq has\n\t *   however a long think time, during which it can absorb the\n\t *   effect of an appropriate number of extra I/O requests\n\t *   from other queues (see bfq_update_inject_limit for\n\t *   details on the computation of this number);\n\t * then injection can be performed without restrictions.\n\t */\n\tbool in_serv_always_inject = in_serv_bfqq->wr_coeff == 1 ||\n\t\t!bfq_bfqq_has_short_ttime(in_serv_bfqq);\n\n\t/*\n\t * If\n\t * - the baseline total service time could not be sampled yet,\n\t *   so the inject limit happens to be still 0, and\n\t * - a lot of time has elapsed since the plugging of I/O\n\t *   dispatching started, so drive speed is being wasted\n\t *   significantly;\n\t * then temporarily raise inject limit to one request.\n\t */\n\tif (limit == 0 && in_serv_bfqq->last_serv_time_ns == 0 &&\n\t    bfq_bfqq_wait_request(in_serv_bfqq) &&\n\t    time_is_before_eq_jiffies(bfqd->last_idling_start_jiffies +\n\t\t\t\t      bfqd->bfq_slice_idle)\n\t\t)\n\t\tlimit = 1;\n\n\tif (bfqd->rq_in_driver >= limit)\n\t\treturn NULL;\n\n\t/*\n\t * Linear search of the source queue for injection; but, with\n\t * a high probability, very few steps are needed to find a\n\t * candidate queue, i.e., a queue with enough budget left for\n\t * its next request. In fact:\n\t * - BFQ dynamically updates the budget of every queue so as\n\t *   to accommodate the expected backlog of the queue;\n\t * - if a queue gets all its requests dispatched as injected\n\t *   service, then the queue is removed from the active list\n\t *   (and re-added only if it gets new requests, but then it\n\t *   is assigned again enough budget for its new backlog).\n\t */\n\tlist_for_each_entry(bfqq, &bfqd->active_list, bfqq_list)\n\t\tif (!RB_EMPTY_ROOT(&bfqq->sort_list) &&\n\t\t    (in_serv_always_inject || bfqq->wr_coeff > 1) &&\n\t\t    bfq_serv_to_charge(bfqq->next_rq, bfqq) <=\n\t\t    bfq_bfqq_budget_left(bfqq)) {\n\t\t\t/*\n\t\t\t * Allow for only one large in-flight request\n\t\t\t * on non-rotational devices, for the\n\t\t\t * following reason. On non-rotationl drives,\n\t\t\t * large requests take much longer than\n\t\t\t * smaller requests to be served. In addition,\n\t\t\t * the drive prefers to serve large requests\n\t\t\t * w.r.t. to small ones, if it can choose. So,\n\t\t\t * having more than one large requests queued\n\t\t\t * in the drive may easily make the next first\n\t\t\t * request of the in-service queue wait for so\n\t\t\t * long to break bfqq's service guarantees. On\n\t\t\t * the bright side, large requests let the\n\t\t\t * drive reach a very high throughput, even if\n\t\t\t * there is only one in-flight large request\n\t\t\t * at a time.\n\t\t\t */\n\t\t\tif (blk_queue_nonrot(bfqd->queue) &&\n\t\t\t    blk_rq_sectors(bfqq->next_rq) >=\n\t\t\t    BFQQ_SECT_THR_NONROT)\n\t\t\t\tlimit = min_t(unsigned int, 1, limit);\n\t\t\telse\n\t\t\t\tlimit = in_serv_bfqq->inject_limit;\n\n\t\t\tif (bfqd->rq_in_driver < limit) {\n\t\t\t\tbfqd->rqs_injected = true;\n\t\t\t\treturn bfqq;\n\t\t\t}\n\t\t}\n\n\treturn NULL;\n}\n\n/*\n * Select a queue for service.  If we have a current queue in service,\n * check whether to continue servicing it, or retrieve and set a new one.\n */\nstatic struct bfq_queue *bfq_select_queue(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq;\n\tstruct request *next_rq;\n\tenum bfqq_expiration reason = BFQQE_BUDGET_TIMEOUT;\n\n\tbfqq = bfqd->in_service_queue;\n\tif (!bfqq)\n\t\tgoto new_queue;\n\n\tbfq_log_bfqq(bfqd, bfqq, \"select_queue: already in-service queue\");\n\n\t/*\n\t * Do not expire bfqq for budget timeout if bfqq may be about\n\t * to enjoy device idling. The reason why, in this case, we\n\t * prevent bfqq from expiring is the same as in the comments\n\t * on the case where bfq_bfqq_must_idle() returns true, in\n\t * bfq_completed_request().\n\t */\n\tif (bfq_may_expire_for_budg_timeout(bfqq) &&\n\t    !bfq_bfqq_must_idle(bfqq))\n\t\tgoto expire;\n\ncheck_queue:\n\t/*\n\t * This loop is rarely executed more than once. Even when it\n\t * happens, it is much more convenient to re-execute this loop\n\t * than to return NULL and trigger a new dispatch to get a\n\t * request served.\n\t */\n\tnext_rq = bfqq->next_rq;\n\t/*\n\t * If bfqq has requests queued and it has enough budget left to\n\t * serve them, keep the queue, otherwise expire it.\n\t */\n\tif (next_rq) {\n\t\tif (bfq_serv_to_charge(next_rq, bfqq) >\n\t\t\tbfq_bfqq_budget_left(bfqq)) {\n\t\t\t/*\n\t\t\t * Expire the queue for budget exhaustion,\n\t\t\t * which makes sure that the next budget is\n\t\t\t * enough to serve the next request, even if\n\t\t\t * it comes from the fifo expired path.\n\t\t\t */\n\t\t\treason = BFQQE_BUDGET_EXHAUSTED;\n\t\t\tgoto expire;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The idle timer may be pending because we may\n\t\t\t * not disable disk idling even when a new request\n\t\t\t * arrives.\n\t\t\t */\n\t\t\tif (bfq_bfqq_wait_request(bfqq)) {\n\t\t\t\t/*\n\t\t\t\t * If we get here: 1) at least a new request\n\t\t\t\t * has arrived but we have not disabled the\n\t\t\t\t * timer because the request was too small,\n\t\t\t\t * 2) then the block layer has unplugged\n\t\t\t\t * the device, causing the dispatch to be\n\t\t\t\t * invoked.\n\t\t\t\t *\n\t\t\t\t * Since the device is unplugged, now the\n\t\t\t\t * requests are probably large enough to\n\t\t\t\t * provide a reasonable throughput.\n\t\t\t\t * So we disable idling.\n\t\t\t\t */\n\t\t\t\tbfq_clear_bfqq_wait_request(bfqq);\n\t\t\t\thrtimer_try_to_cancel(&bfqd->idle_slice_timer);\n\t\t\t}\n\t\t\tgoto keep_queue;\n\t\t}\n\t}\n\n\t/*\n\t * No requests pending. However, if the in-service queue is idling\n\t * for a new request, or has requests waiting for a completion and\n\t * may idle after their completion, then keep it anyway.\n\t *\n\t * Yet, inject service from other queues if it boosts\n\t * throughput and is possible.\n\t */\n\tif (bfq_bfqq_wait_request(bfqq) ||\n\t    (bfqq->dispatched != 0 && bfq_better_to_idle(bfqq))) {\n\t\tstruct bfq_queue *async_bfqq =\n\t\t\tbfqq->bic && bfqq->bic->bfqq[0] &&\n\t\t\tbfq_bfqq_busy(bfqq->bic->bfqq[0]) &&\n\t\t\tbfqq->bic->bfqq[0]->next_rq ?\n\t\t\tbfqq->bic->bfqq[0] : NULL;\n\n\t\t/*\n\t\t * The next three mutually-exclusive ifs decide\n\t\t * whether to try injection, and choose the queue to\n\t\t * pick an I/O request from.\n\t\t *\n\t\t * The first if checks whether the process associated\n\t\t * with bfqq has also async I/O pending. If so, it\n\t\t * injects such I/O unconditionally. Injecting async\n\t\t * I/O from the same process can cause no harm to the\n\t\t * process. On the contrary, it can only increase\n\t\t * bandwidth and reduce latency for the process.\n\t\t *\n\t\t * The second if checks whether there happens to be a\n\t\t * non-empty waker queue for bfqq, i.e., a queue whose\n\t\t * I/O needs to be completed for bfqq to receive new\n\t\t * I/O. This happens, e.g., if bfqq is associated with\n\t\t * a process that does some sync. A sync generates\n\t\t * extra blocking I/O, which must be completed before\n\t\t * the process associated with bfqq can go on with its\n\t\t * I/O. If the I/O of the waker queue is not served,\n\t\t * then bfqq remains empty, and no I/O is dispatched,\n\t\t * until the idle timeout fires for bfqq. This is\n\t\t * likely to result in lower bandwidth and higher\n\t\t * latencies for bfqq, and in a severe loss of total\n\t\t * throughput. The best action to take is therefore to\n\t\t * serve the waker queue as soon as possible. So do it\n\t\t * (without relying on the third alternative below for\n\t\t * eventually serving waker_bfqq's I/O; see the last\n\t\t * paragraph for further details). This systematic\n\t\t * injection of I/O from the waker queue does not\n\t\t * cause any delay to bfqq's I/O. On the contrary,\n\t\t * next bfqq's I/O is brought forward dramatically,\n\t\t * for it is not blocked for milliseconds.\n\t\t *\n\t\t * The third if checks whether bfqq is a queue for\n\t\t * which it is better to avoid injection. It is so if\n\t\t * bfqq delivers more throughput when served without\n\t\t * any further I/O from other queues in the middle, or\n\t\t * if the service times of bfqq's I/O requests both\n\t\t * count more than overall throughput, and may be\n\t\t * easily increased by injection (this happens if bfqq\n\t\t * has a short think time). If none of these\n\t\t * conditions holds, then a candidate queue for\n\t\t * injection is looked for through\n\t\t * bfq_choose_bfqq_for_injection(). Note that the\n\t\t * latter may return NULL (for example if the inject\n\t\t * limit for bfqq is currently 0).\n\t\t *\n\t\t * NOTE: motivation for the second alternative\n\t\t *\n\t\t * Thanks to the way the inject limit is updated in\n\t\t * bfq_update_has_short_ttime(), it is rather likely\n\t\t * that, if I/O is being plugged for bfqq and the\n\t\t * waker queue has pending I/O requests that are\n\t\t * blocking bfqq's I/O, then the third alternative\n\t\t * above lets the waker queue get served before the\n\t\t * I/O-plugging timeout fires. So one may deem the\n\t\t * second alternative superfluous. It is not, because\n\t\t * the third alternative may be way less effective in\n\t\t * case of a synchronization. For two main\n\t\t * reasons. First, throughput may be low because the\n\t\t * inject limit may be too low to guarantee the same\n\t\t * amount of injected I/O, from the waker queue or\n\t\t * other queues, that the second alternative\n\t\t * guarantees (the second alternative unconditionally\n\t\t * injects a pending I/O request of the waker queue\n\t\t * for each bfq_dispatch_request()). Second, with the\n\t\t * third alternative, the duration of the plugging,\n\t\t * i.e., the time before bfqq finally receives new I/O,\n\t\t * may not be minimized, because the waker queue may\n\t\t * happen to be served only after other queues.\n\t\t */\n\t\tif (async_bfqq &&\n\t\t    icq_to_bic(async_bfqq->next_rq->elv.icq) == bfqq->bic &&\n\t\t    bfq_serv_to_charge(async_bfqq->next_rq, async_bfqq) <=\n\t\t    bfq_bfqq_budget_left(async_bfqq))\n\t\t\tbfqq = bfqq->bic->bfqq[0];\n\t\telse if (bfq_bfqq_has_waker(bfqq) &&\n\t\t\t   bfq_bfqq_busy(bfqq->waker_bfqq) &&\n\t\t\t   bfqq->next_rq &&\n\t\t\t   bfq_serv_to_charge(bfqq->waker_bfqq->next_rq,\n\t\t\t\t\t      bfqq->waker_bfqq) <=\n\t\t\t   bfq_bfqq_budget_left(bfqq->waker_bfqq)\n\t\t\t)\n\t\t\tbfqq = bfqq->waker_bfqq;\n\t\telse if (!idling_boosts_thr_without_issues(bfqd, bfqq) &&\n\t\t\t (bfqq->wr_coeff == 1 || bfqd->wr_busy_queues > 1 ||\n\t\t\t  !bfq_bfqq_has_short_ttime(bfqq)))\n\t\t\tbfqq = bfq_choose_bfqq_for_injection(bfqd);\n\t\telse\n\t\t\tbfqq = NULL;\n\n\t\tgoto keep_queue;\n\t}\n\n\treason = BFQQE_NO_MORE_REQUESTS;\nexpire:\n\tbfq_bfqq_expire(bfqd, bfqq, false, reason);\nnew_queue:\n\tbfqq = bfq_set_in_service_queue(bfqd);\n\tif (bfqq) {\n\t\tbfq_log_bfqq(bfqd, bfqq, \"select_queue: checking new queue\");\n\t\tgoto check_queue;\n\t}\nkeep_queue:\n\tif (bfqq)\n\t\tbfq_log_bfqq(bfqd, bfqq, \"select_queue: returned this queue\");\n\telse\n\t\tbfq_log(bfqd, \"select_queue: no queue returned\");\n\n\treturn bfqq;\n}\n\nstatic void bfq_update_wr_data(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\tif (bfqq->wr_coeff > 1) { /* queue is being weight-raised */\n\t\tbfq_log_bfqq(bfqd, bfqq,\n\t\t\t\"raising period dur %u/%u msec, old coeff %u, w %d(%d)\",\n\t\t\tjiffies_to_msecs(jiffies - bfqq->last_wr_start_finish),\n\t\t\tjiffies_to_msecs(bfqq->wr_cur_max_time),\n\t\t\tbfqq->wr_coeff,\n\t\t\tbfqq->entity.weight, bfqq->entity.orig_weight);\n\n\t\tif (entity->prio_changed)\n\t\t\tbfq_log_bfqq(bfqd, bfqq, \"WARN: pending prio change\");\n\n\t\t/*\n\t\t * If the queue was activated in a burst, or too much\n\t\t * time has elapsed from the beginning of this\n\t\t * weight-raising period, then end weight raising.\n\t\t */\n\t\tif (bfq_bfqq_in_large_burst(bfqq))\n\t\t\tbfq_bfqq_end_wr(bfqq);\n\t\telse if (time_is_before_jiffies(bfqq->last_wr_start_finish +\n\t\t\t\t\t\tbfqq->wr_cur_max_time)) {\n\t\t\tif (bfqq->wr_cur_max_time != bfqd->bfq_wr_rt_max_time ||\n\t\t\ttime_is_before_jiffies(bfqq->wr_start_at_switch_to_srt +\n\t\t\t\t\t       bfq_wr_duration(bfqd)))\n\t\t\t\tbfq_bfqq_end_wr(bfqq);\n\t\t\telse {\n\t\t\t\tswitch_back_to_interactive_wr(bfqq, bfqd);\n\t\t\t\tbfqq->entity.prio_changed = 1;\n\t\t\t}\n\t\t}\n\t\tif (bfqq->wr_coeff > 1 &&\n\t\t    bfqq->wr_cur_max_time != bfqd->bfq_wr_rt_max_time &&\n\t\t    bfqq->service_from_wr > max_service_from_wr) {\n\t\t\t/* see comments on max_service_from_wr */\n\t\t\tbfq_bfqq_end_wr(bfqq);\n\t\t}\n\t}\n\t/*\n\t * To improve latency (for this or other queues), immediately\n\t * update weight both if it must be raised and if it must be\n\t * lowered. Since, entity may be on some active tree here, and\n\t * might have a pending change of its ioprio class, invoke\n\t * next function with the last parameter unset (see the\n\t * comments on the function).\n\t */\n\tif ((entity->weight > entity->orig_weight) != (bfqq->wr_coeff > 1))\n\t\t__bfq_entity_update_weight_prio(bfq_entity_service_tree(entity),\n\t\t\t\t\t\tentity, false);\n}\n\n/*\n * Dispatch next request from bfqq.\n */\nstatic struct request *bfq_dispatch_rq_from_bfqq(struct bfq_data *bfqd,\n\t\t\t\t\t\t struct bfq_queue *bfqq)\n{\n\tstruct request *rq = bfqq->next_rq;\n\tunsigned long service_to_charge;\n\n\tservice_to_charge = bfq_serv_to_charge(rq, bfqq);\n\n\tbfq_bfqq_served(bfqq, service_to_charge);\n\n\tif (bfqq == bfqd->in_service_queue && bfqd->wait_dispatch) {\n\t\tbfqd->wait_dispatch = false;\n\t\tbfqd->waited_rq = rq;\n\t}\n\n\tbfq_dispatch_remove(bfqd->queue, rq);\n\n\tif (bfqq != bfqd->in_service_queue)\n\t\tgoto return_rq;\n\n\t/*\n\t * If weight raising has to terminate for bfqq, then next\n\t * function causes an immediate update of bfqq's weight,\n\t * without waiting for next activation. As a consequence, on\n\t * expiration, bfqq will be timestamped as if has never been\n\t * weight-raised during this service slot, even if it has\n\t * received part or even most of the service as a\n\t * weight-raised queue. This inflates bfqq's timestamps, which\n\t * is beneficial, as bfqq is then more willing to leave the\n\t * device immediately to possible other weight-raised queues.\n\t */\n\tbfq_update_wr_data(bfqd, bfqq);\n\n\t/*\n\t * Expire bfqq, pretending that its budget expired, if bfqq\n\t * belongs to CLASS_IDLE and other queues are waiting for\n\t * service.\n\t */\n\tif (!(bfq_tot_busy_queues(bfqd) > 1 && bfq_class_idle(bfqq)))\n\t\tgoto return_rq;\n\n\tbfq_bfqq_expire(bfqd, bfqq, false, BFQQE_BUDGET_EXHAUSTED);\n\nreturn_rq:\n\treturn rq;\n}\n\nstatic bool bfq_has_work(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct bfq_data *bfqd = hctx->queue->elevator->elevator_data;\n\n\t/*\n\t * Avoiding lock: a race on bfqd->busy_queues should cause at\n\t * most a call to dispatch for nothing\n\t */\n\treturn !list_empty_careful(&bfqd->dispatch) ||\n\t\tbfq_tot_busy_queues(bfqd) > 0;\n}\n\nstatic struct request *__bfq_dispatch_request(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct bfq_data *bfqd = hctx->queue->elevator->elevator_data;\n\tstruct request *rq = NULL;\n\tstruct bfq_queue *bfqq = NULL;\n\n\tif (!list_empty(&bfqd->dispatch)) {\n\t\trq = list_first_entry(&bfqd->dispatch, struct request,\n\t\t\t\t      queuelist);\n\t\tlist_del_init(&rq->queuelist);\n\n\t\tbfqq = RQ_BFQQ(rq);\n\n\t\tif (bfqq) {\n\t\t\t/*\n\t\t\t * Increment counters here, because this\n\t\t\t * dispatch does not follow the standard\n\t\t\t * dispatch flow (where counters are\n\t\t\t * incremented)\n\t\t\t */\n\t\t\tbfqq->dispatched++;\n\n\t\t\tgoto inc_in_driver_start_rq;\n\t\t}\n\n\t\t/*\n\t\t * We exploit the bfq_finish_requeue_request hook to\n\t\t * decrement rq_in_driver, but\n\t\t * bfq_finish_requeue_request will not be invoked on\n\t\t * this request. So, to avoid unbalance, just start\n\t\t * this request, without incrementing rq_in_driver. As\n\t\t * a negative consequence, rq_in_driver is deceptively\n\t\t * lower than it should be while this request is in\n\t\t * service. This may cause bfq_schedule_dispatch to be\n\t\t * invoked uselessly.\n\t\t *\n\t\t * As for implementing an exact solution, the\n\t\t * bfq_finish_requeue_request hook, if defined, is\n\t\t * probably invoked also on this request. So, by\n\t\t * exploiting this hook, we could 1) increment\n\t\t * rq_in_driver here, and 2) decrement it in\n\t\t * bfq_finish_requeue_request. Such a solution would\n\t\t * let the value of the counter be always accurate,\n\t\t * but it would entail using an extra interface\n\t\t * function. This cost seems higher than the benefit,\n\t\t * being the frequency of non-elevator-private\n\t\t * requests very low.\n\t\t */\n\t\tgoto start_rq;\n\t}\n\n\tbfq_log(bfqd, \"dispatch requests: %d busy queues\",\n\t\tbfq_tot_busy_queues(bfqd));\n\n\tif (bfq_tot_busy_queues(bfqd) == 0)\n\t\tgoto exit;\n\n\t/*\n\t * Force device to serve one request at a time if\n\t * strict_guarantees is true. Forcing this service scheme is\n\t * currently the ONLY way to guarantee that the request\n\t * service order enforced by the scheduler is respected by a\n\t * queueing device. Otherwise the device is free even to make\n\t * some unlucky request wait for as long as the device\n\t * wishes.\n\t *\n\t * Of course, serving one request at at time may cause loss of\n\t * throughput.\n\t */\n\tif (bfqd->strict_guarantees && bfqd->rq_in_driver > 0)\n\t\tgoto exit;\n\n\tbfqq = bfq_select_queue(bfqd);\n\tif (!bfqq)\n\t\tgoto exit;\n\n\trq = bfq_dispatch_rq_from_bfqq(bfqd, bfqq);\n\n\tif (rq) {\ninc_in_driver_start_rq:\n\t\tbfqd->rq_in_driver++;\nstart_rq:\n\t\trq->rq_flags |= RQF_STARTED;\n\t}\nexit:\n\treturn rq;\n}\n\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\nstatic void bfq_update_dispatch_stats(struct request_queue *q,\n\t\t\t\t      struct request *rq,\n\t\t\t\t      struct bfq_queue *in_serv_queue,\n\t\t\t\t      bool idle_timer_disabled)\n{\n\tstruct bfq_queue *bfqq = rq ? RQ_BFQQ(rq) : NULL;\n\n\tif (!idle_timer_disabled && !bfqq)\n\t\treturn;\n\n\t/*\n\t * rq and bfqq are guaranteed to exist until this function\n\t * ends, for the following reasons. First, rq can be\n\t * dispatched to the device, and then can be completed and\n\t * freed, only after this function ends. Second, rq cannot be\n\t * merged (and thus freed because of a merge) any longer,\n\t * because it has already started. Thus rq cannot be freed\n\t * before this function ends, and, since rq has a reference to\n\t * bfqq, the same guarantee holds for bfqq too.\n\t *\n\t * In addition, the following queue lock guarantees that\n\t * bfqq_group(bfqq) exists as well.\n\t */\n\tspin_lock_irq(&q->queue_lock);\n\tif (idle_timer_disabled)\n\t\t/*\n\t\t * Since the idle timer has been disabled,\n\t\t * in_serv_queue contained some request when\n\t\t * __bfq_dispatch_request was invoked above, which\n\t\t * implies that rq was picked exactly from\n\t\t * in_serv_queue. Thus in_serv_queue == bfqq, and is\n\t\t * therefore guaranteed to exist because of the above\n\t\t * arguments.\n\t\t */\n\t\tbfqg_stats_update_idle_time(bfqq_group(in_serv_queue));\n\tif (bfqq) {\n\t\tstruct bfq_group *bfqg = bfqq_group(bfqq);\n\n\t\tbfqg_stats_update_avg_queue_size(bfqg);\n\t\tbfqg_stats_set_start_empty_time(bfqg);\n\t\tbfqg_stats_update_io_remove(bfqg, rq->cmd_flags);\n\t}\n\tspin_unlock_irq(&q->queue_lock);\n}\n#else\nstatic inline void bfq_update_dispatch_stats(struct request_queue *q,\n\t\t\t\t\t     struct request *rq,\n\t\t\t\t\t     struct bfq_queue *in_serv_queue,\n\t\t\t\t\t     bool idle_timer_disabled) {}\n#endif /* CONFIG_BFQ_CGROUP_DEBUG */\n\nstatic struct request *bfq_dispatch_request(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct bfq_data *bfqd = hctx->queue->elevator->elevator_data;\n\tstruct request *rq;\n\tstruct bfq_queue *in_serv_queue;\n\tbool waiting_rq, idle_timer_disabled;\n\n\tspin_lock_irq(&bfqd->lock);\n\n\tin_serv_queue = bfqd->in_service_queue;\n\twaiting_rq = in_serv_queue && bfq_bfqq_wait_request(in_serv_queue);\n\n\trq = __bfq_dispatch_request(hctx);\n\n\tidle_timer_disabled =\n\t\twaiting_rq && !bfq_bfqq_wait_request(in_serv_queue);\n\n\tspin_unlock_irq(&bfqd->lock);\n\n\tbfq_update_dispatch_stats(hctx->queue, rq, in_serv_queue,\n\t\t\t\t  idle_timer_disabled);\n\n\treturn rq;\n}\n\n/*\n * Task holds one reference to the queue, dropped when task exits.  Each rq\n * in-flight on this queue also holds a reference, dropped when rq is freed.\n *\n * Scheduler lock must be held here. Recall not to use bfqq after calling\n * this function on it.\n */\nvoid bfq_put_queue(struct bfq_queue *bfqq)\n{\n\tstruct bfq_queue *item;\n\tstruct hlist_node *n;\n\tstruct bfq_group *bfqg = bfqq_group(bfqq);\n\n\tif (bfqq->bfqd)\n\t\tbfq_log_bfqq(bfqq->bfqd, bfqq, \"put_queue: %p %d\",\n\t\t\t     bfqq, bfqq->ref);\n\n\tbfqq->ref--;\n\tif (bfqq->ref)\n\t\treturn;\n\n\tif (!hlist_unhashed(&bfqq->burst_list_node)) {\n\t\thlist_del_init(&bfqq->burst_list_node);\n\t\t/*\n\t\t * Decrement also burst size after the removal, if the\n\t\t * process associated with bfqq is exiting, and thus\n\t\t * does not contribute to the burst any longer. This\n\t\t * decrement helps filter out false positives of large\n\t\t * bursts, when some short-lived process (often due to\n\t\t * the execution of commands by some service) happens\n\t\t * to start and exit while a complex application is\n\t\t * starting, and thus spawning several processes that\n\t\t * do I/O (and that *must not* be treated as a large\n\t\t * burst, see comments on bfq_handle_burst).\n\t\t *\n\t\t * In particular, the decrement is performed only if:\n\t\t * 1) bfqq is not a merged queue, because, if it is,\n\t\t * then this free of bfqq is not triggered by the exit\n\t\t * of the process bfqq is associated with, but exactly\n\t\t * by the fact that bfqq has just been merged.\n\t\t * 2) burst_size is greater than 0, to handle\n\t\t * unbalanced decrements. Unbalanced decrements may\n\t\t * happen in te following case: bfqq is inserted into\n\t\t * the current burst list--without incrementing\n\t\t * bust_size--because of a split, but the current\n\t\t * burst list is not the burst list bfqq belonged to\n\t\t * (see comments on the case of a split in\n\t\t * bfq_set_request).\n\t\t */\n\t\tif (bfqq->bic && bfqq->bfqd->burst_size > 0)\n\t\t\tbfqq->bfqd->burst_size--;\n\t}\n\n\t/*\n\t * bfqq does not exist any longer, so it cannot be woken by\n\t * any other queue, and cannot wake any other queue. Then bfqq\n\t * must be removed from the woken list of its possible waker\n\t * queue, and all queues in the woken list of bfqq must stop\n\t * having a waker queue. Strictly speaking, these updates\n\t * should be performed when bfqq remains with no I/O source\n\t * attached to it, which happens before bfqq gets freed. In\n\t * particular, this happens when the last process associated\n\t * with bfqq exits or gets associated with a different\n\t * queue. However, both events lead to bfqq being freed soon,\n\t * and dangling references would come out only after bfqq gets\n\t * freed. So these updates are done here, as a simple and safe\n\t * way to handle all cases.\n\t */\n\t/* remove bfqq from woken list */\n\tif (!hlist_unhashed(&bfqq->woken_list_node))\n\t\thlist_del_init(&bfqq->woken_list_node);\n\n\t/* reset waker for all queues in woken list */\n\thlist_for_each_entry_safe(item, n, &bfqq->woken_list,\n\t\t\t\t  woken_list_node) {\n\t\titem->waker_bfqq = NULL;\n\t\tbfq_clear_bfqq_has_waker(item);\n\t\thlist_del_init(&item->woken_list_node);\n\t}\n\n\tif (bfqq->bfqd && bfqq->bfqd->last_completed_rq_bfqq == bfqq)\n\t\tbfqq->bfqd->last_completed_rq_bfqq = NULL;\n\n\tkmem_cache_free(bfq_pool, bfqq);\n\tbfqg_and_blkg_put(bfqg);\n}\n\nstatic void bfq_put_cooperator(struct bfq_queue *bfqq)\n{\n\tstruct bfq_queue *__bfqq, *next;\n\n\t/*\n\t * If this queue was scheduled to merge with another queue, be\n\t * sure to drop the reference taken on that queue (and others in\n\t * the merge chain). See bfq_setup_merge and bfq_merge_bfqqs.\n\t */\n\t__bfqq = bfqq->new_bfqq;\n\twhile (__bfqq) {\n\t\tif (__bfqq == bfqq)\n\t\t\tbreak;\n\t\tnext = __bfqq->new_bfqq;\n\t\tbfq_put_queue(__bfqq);\n\t\t__bfqq = next;\n\t}\n}\n\nstatic void bfq_exit_bfqq(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tif (bfqq == bfqd->in_service_queue) {\n\t\t__bfq_bfqq_expire(bfqd, bfqq, BFQQE_BUDGET_TIMEOUT);\n\t\tbfq_schedule_dispatch(bfqd);\n\t}\n\n\tbfq_log_bfqq(bfqd, bfqq, \"exit_bfqq: %p, %d\", bfqq, bfqq->ref);\n\n\tbfq_put_cooperator(bfqq);\n\n\tbfq_release_process_ref(bfqd, bfqq);\n}\n\nstatic void bfq_exit_icq_bfqq(struct bfq_io_cq *bic, bool is_sync)\n{\n\tstruct bfq_queue *bfqq = bic_to_bfqq(bic, is_sync);\n\tstruct bfq_data *bfqd;\n\n\tif (bfqq)\n\t\tbfqd = bfqq->bfqd; /* NULL if scheduler already exited */\n\n\tif (bfqq && bfqd) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&bfqd->lock, flags);\n\t\tbfqq->bic = NULL;\n\t\tbfq_exit_bfqq(bfqd, bfqq);\n\t\tbic_set_bfqq(bic, NULL, is_sync);\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t}\n}\n\nstatic void bfq_exit_icq(struct io_cq *icq)\n{\n\tstruct bfq_io_cq *bic = icq_to_bic(icq);\n\n\tbfq_exit_icq_bfqq(bic, true);\n\tbfq_exit_icq_bfqq(bic, false);\n}\n\n/*\n * Update the entity prio values; note that the new values will not\n * be used until the next (re)activation.\n */\nstatic void\nbfq_set_next_ioprio_data(struct bfq_queue *bfqq, struct bfq_io_cq *bic)\n{\n\tstruct task_struct *tsk = current;\n\tint ioprio_class;\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\n\tif (!bfqd)\n\t\treturn;\n\n\tioprio_class = IOPRIO_PRIO_CLASS(bic->ioprio);\n\tswitch (ioprio_class) {\n\tdefault:\n\t\tdev_err(bfqq->bfqd->queue->backing_dev_info->dev,\n\t\t\t\"bfq: bad prio class %d\\n\", ioprio_class);\n\t\t/* fall through */\n\tcase IOPRIO_CLASS_NONE:\n\t\t/*\n\t\t * No prio set, inherit CPU scheduling settings.\n\t\t */\n\t\tbfqq->new_ioprio = task_nice_ioprio(tsk);\n\t\tbfqq->new_ioprio_class = task_nice_ioclass(tsk);\n\t\tbreak;\n\tcase IOPRIO_CLASS_RT:\n\t\tbfqq->new_ioprio = IOPRIO_PRIO_DATA(bic->ioprio);\n\t\tbfqq->new_ioprio_class = IOPRIO_CLASS_RT;\n\t\tbreak;\n\tcase IOPRIO_CLASS_BE:\n\t\tbfqq->new_ioprio = IOPRIO_PRIO_DATA(bic->ioprio);\n\t\tbfqq->new_ioprio_class = IOPRIO_CLASS_BE;\n\t\tbreak;\n\tcase IOPRIO_CLASS_IDLE:\n\t\tbfqq->new_ioprio_class = IOPRIO_CLASS_IDLE;\n\t\tbfqq->new_ioprio = 7;\n\t\tbreak;\n\t}\n\n\tif (bfqq->new_ioprio >= IOPRIO_BE_NR) {\n\t\tpr_crit(\"bfq_set_next_ioprio_data: new_ioprio %d\\n\",\n\t\t\tbfqq->new_ioprio);\n\t\tbfqq->new_ioprio = IOPRIO_BE_NR;\n\t}\n\n\tbfqq->entity.new_weight = bfq_ioprio_to_weight(bfqq->new_ioprio);\n\tbfqq->entity.prio_changed = 1;\n}\n\nstatic struct bfq_queue *bfq_get_queue(struct bfq_data *bfqd,\n\t\t\t\t       struct bio *bio, bool is_sync,\n\t\t\t\t       struct bfq_io_cq *bic);\n\nstatic void bfq_check_ioprio_change(struct bfq_io_cq *bic, struct bio *bio)\n{\n\tstruct bfq_data *bfqd = bic_to_bfqd(bic);\n\tstruct bfq_queue *bfqq;\n\tint ioprio = bic->icq.ioc->ioprio;\n\n\t/*\n\t * This condition may trigger on a newly created bic, be sure to\n\t * drop the lock before returning.\n\t */\n\tif (unlikely(!bfqd) || likely(bic->ioprio == ioprio))\n\t\treturn;\n\n\tbic->ioprio = ioprio;\n\n\tbfqq = bic_to_bfqq(bic, false);\n\tif (bfqq) {\n\t\tbfq_release_process_ref(bfqd, bfqq);\n\t\tbfqq = bfq_get_queue(bfqd, bio, BLK_RW_ASYNC, bic);\n\t\tbic_set_bfqq(bic, bfqq, false);\n\t}\n\n\tbfqq = bic_to_bfqq(bic, true);\n\tif (bfqq)\n\t\tbfq_set_next_ioprio_data(bfqq, bic);\n}\n\nstatic void bfq_init_bfqq(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t  struct bfq_io_cq *bic, pid_t pid, int is_sync)\n{\n\tRB_CLEAR_NODE(&bfqq->entity.rb_node);\n\tINIT_LIST_HEAD(&bfqq->fifo);\n\tINIT_HLIST_NODE(&bfqq->burst_list_node);\n\tINIT_HLIST_NODE(&bfqq->woken_list_node);\n\tINIT_HLIST_HEAD(&bfqq->woken_list);\n\n\tbfqq->ref = 0;\n\tbfqq->bfqd = bfqd;\n\n\tif (bic)\n\t\tbfq_set_next_ioprio_data(bfqq, bic);\n\n\tif (is_sync) {\n\t\t/*\n\t\t * No need to mark as has_short_ttime if in\n\t\t * idle_class, because no device idling is performed\n\t\t * for queues in idle class\n\t\t */\n\t\tif (!bfq_class_idle(bfqq))\n\t\t\t/* tentatively mark as has_short_ttime */\n\t\t\tbfq_mark_bfqq_has_short_ttime(bfqq);\n\t\tbfq_mark_bfqq_sync(bfqq);\n\t\tbfq_mark_bfqq_just_created(bfqq);\n\t} else\n\t\tbfq_clear_bfqq_sync(bfqq);\n\n\t/* set end request to minus infinity from now */\n\tbfqq->ttime.last_end_request = ktime_get_ns() + 1;\n\n\tbfq_mark_bfqq_IO_bound(bfqq);\n\n\tbfqq->pid = pid;\n\n\t/* Tentative initial value to trade off between thr and lat */\n\tbfqq->max_budget = (2 * bfq_max_budget(bfqd)) / 3;\n\tbfqq->budget_timeout = bfq_smallest_from_now();\n\n\tbfqq->wr_coeff = 1;\n\tbfqq->last_wr_start_finish = jiffies;\n\tbfqq->wr_start_at_switch_to_srt = bfq_smallest_from_now();\n\tbfqq->split_time = bfq_smallest_from_now();\n\n\t/*\n\t * To not forget the possibly high bandwidth consumed by a\n\t * process/queue in the recent past,\n\t * bfq_bfqq_softrt_next_start() returns a value at least equal\n\t * to the current value of bfqq->soft_rt_next_start (see\n\t * comments on bfq_bfqq_softrt_next_start).  Set\n\t * soft_rt_next_start to now, to mean that bfqq has consumed\n\t * no bandwidth so far.\n\t */\n\tbfqq->soft_rt_next_start = jiffies;\n\n\t/* first request is almost certainly seeky */\n\tbfqq->seek_history = 1;\n}\n\nstatic struct bfq_queue **bfq_async_queue_prio(struct bfq_data *bfqd,\n\t\t\t\t\t       struct bfq_group *bfqg,\n\t\t\t\t\t       int ioprio_class, int ioprio)\n{\n\tswitch (ioprio_class) {\n\tcase IOPRIO_CLASS_RT:\n\t\treturn &bfqg->async_bfqq[0][ioprio];\n\tcase IOPRIO_CLASS_NONE:\n\t\tioprio = IOPRIO_NORM;\n\t\t/* fall through */\n\tcase IOPRIO_CLASS_BE:\n\t\treturn &bfqg->async_bfqq[1][ioprio];\n\tcase IOPRIO_CLASS_IDLE:\n\t\treturn &bfqg->async_idle_bfqq;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic struct bfq_queue *bfq_get_queue(struct bfq_data *bfqd,\n\t\t\t\t       struct bio *bio, bool is_sync,\n\t\t\t\t       struct bfq_io_cq *bic)\n{\n\tconst int ioprio = IOPRIO_PRIO_DATA(bic->ioprio);\n\tconst int ioprio_class = IOPRIO_PRIO_CLASS(bic->ioprio);\n\tstruct bfq_queue **async_bfqq = NULL;\n\tstruct bfq_queue *bfqq;\n\tstruct bfq_group *bfqg;\n\n\trcu_read_lock();\n\n\tbfqg = bfq_find_set_group(bfqd, __bio_blkcg(bio));\n\tif (!bfqg) {\n\t\tbfqq = &bfqd->oom_bfqq;\n\t\tgoto out;\n\t}\n\n\tif (!is_sync) {\n\t\tasync_bfqq = bfq_async_queue_prio(bfqd, bfqg, ioprio_class,\n\t\t\t\t\t\t  ioprio);\n\t\tbfqq = *async_bfqq;\n\t\tif (bfqq)\n\t\t\tgoto out;\n\t}\n\n\tbfqq = kmem_cache_alloc_node(bfq_pool,\n\t\t\t\t     GFP_NOWAIT | __GFP_ZERO | __GFP_NOWARN,\n\t\t\t\t     bfqd->queue->node);\n\n\tif (bfqq) {\n\t\tbfq_init_bfqq(bfqd, bfqq, bic, current->pid,\n\t\t\t      is_sync);\n\t\tbfq_init_entity(&bfqq->entity, bfqg);\n\t\tbfq_log_bfqq(bfqd, bfqq, \"allocated\");\n\t} else {\n\t\tbfqq = &bfqd->oom_bfqq;\n\t\tbfq_log_bfqq(bfqd, bfqq, \"using oom bfqq\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Pin the queue now that it's allocated, scheduler exit will\n\t * prune it.\n\t */\n\tif (async_bfqq) {\n\t\tbfqq->ref++; /*\n\t\t\t      * Extra group reference, w.r.t. sync\n\t\t\t      * queue. This extra reference is removed\n\t\t\t      * only if bfqq->bfqg disappears, to\n\t\t\t      * guarantee that this queue is not freed\n\t\t\t      * until its group goes away.\n\t\t\t      */\n\t\tbfq_log_bfqq(bfqd, bfqq, \"get_queue, bfqq not in async: %p, %d\",\n\t\t\t     bfqq, bfqq->ref);\n\t\t*async_bfqq = bfqq;\n\t}\n\nout:\n\tbfqq->ref++; /* get a process reference to this queue */\n\tbfq_log_bfqq(bfqd, bfqq, \"get_queue, at end: %p, %d\", bfqq, bfqq->ref);\n\trcu_read_unlock();\n\treturn bfqq;\n}\n\nstatic void bfq_update_io_thinktime(struct bfq_data *bfqd,\n\t\t\t\t    struct bfq_queue *bfqq)\n{\n\tstruct bfq_ttime *ttime = &bfqq->ttime;\n\tu64 elapsed = ktime_get_ns() - bfqq->ttime.last_end_request;\n\n\telapsed = min_t(u64, elapsed, 2ULL * bfqd->bfq_slice_idle);\n\n\tttime->ttime_samples = (7*bfqq->ttime.ttime_samples + 256) / 8;\n\tttime->ttime_total = div_u64(7*ttime->ttime_total + 256*elapsed,  8);\n\tttime->ttime_mean = div64_ul(ttime->ttime_total + 128,\n\t\t\t\t     ttime->ttime_samples);\n}\n\nstatic void\nbfq_update_io_seektime(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t       struct request *rq)\n{\n\tbfqq->seek_history <<= 1;\n\tbfqq->seek_history |= BFQ_RQ_SEEKY(bfqd, bfqq->last_request_pos, rq);\n\n\tif (bfqq->wr_coeff > 1 &&\n\t    bfqq->wr_cur_max_time == bfqd->bfq_wr_rt_max_time &&\n\t    BFQQ_TOTALLY_SEEKY(bfqq))\n\t\tbfq_bfqq_end_wr(bfqq);\n}\n\nstatic void bfq_update_has_short_ttime(struct bfq_data *bfqd,\n\t\t\t\t       struct bfq_queue *bfqq,\n\t\t\t\t       struct bfq_io_cq *bic)\n{\n\tbool has_short_ttime = true, state_changed;\n\n\t/*\n\t * No need to update has_short_ttime if bfqq is async or in\n\t * idle io prio class, or if bfq_slice_idle is zero, because\n\t * no device idling is performed for bfqq in this case.\n\t */\n\tif (!bfq_bfqq_sync(bfqq) || bfq_class_idle(bfqq) ||\n\t    bfqd->bfq_slice_idle == 0)\n\t\treturn;\n\n\t/* Idle window just restored, statistics are meaningless. */\n\tif (time_is_after_eq_jiffies(bfqq->split_time +\n\t\t\t\t     bfqd->bfq_wr_min_idle_time))\n\t\treturn;\n\n\t/* Think time is infinite if no process is linked to\n\t * bfqq. Otherwise check average think time to\n\t * decide whether to mark as has_short_ttime\n\t */\n\tif (atomic_read(&bic->icq.ioc->active_ref) == 0 ||\n\t    (bfq_sample_valid(bfqq->ttime.ttime_samples) &&\n\t     bfqq->ttime.ttime_mean > bfqd->bfq_slice_idle))\n\t\thas_short_ttime = false;\n\n\tstate_changed = has_short_ttime != bfq_bfqq_has_short_ttime(bfqq);\n\n\tif (has_short_ttime)\n\t\tbfq_mark_bfqq_has_short_ttime(bfqq);\n\telse\n\t\tbfq_clear_bfqq_has_short_ttime(bfqq);\n\n\t/*\n\t * Until the base value for the total service time gets\n\t * finally computed for bfqq, the inject limit does depend on\n\t * the think-time state (short|long). In particular, the limit\n\t * is 0 or 1 if the think time is deemed, respectively, as\n\t * short or long (details in the comments in\n\t * bfq_update_inject_limit()). Accordingly, the next\n\t * instructions reset the inject limit if the think-time state\n\t * has changed and the above base value is still to be\n\t * computed.\n\t *\n\t * However, the reset is performed only if more than 100 ms\n\t * have elapsed since the last update of the inject limit, or\n\t * (inclusive) if the change is from short to long think\n\t * time. The reason for this waiting is as follows.\n\t *\n\t * bfqq may have a long think time because of a\n\t * synchronization with some other queue, i.e., because the\n\t * I/O of some other queue may need to be completed for bfqq\n\t * to receive new I/O. Details in the comments on the choice\n\t * of the queue for injection in bfq_select_queue().\n\t *\n\t * As stressed in those comments, if such a synchronization is\n\t * actually in place, then, without injection on bfqq, the\n\t * blocking I/O cannot happen to served while bfqq is in\n\t * service. As a consequence, if bfqq is granted\n\t * I/O-dispatch-plugging, then bfqq remains empty, and no I/O\n\t * is dispatched, until the idle timeout fires. This is likely\n\t * to result in lower bandwidth and higher latencies for bfqq,\n\t * and in a severe loss of total throughput.\n\t *\n\t * On the opposite end, a non-zero inject limit may allow the\n\t * I/O that blocks bfqq to be executed soon, and therefore\n\t * bfqq to receive new I/O soon.\n\t *\n\t * But, if the blocking gets actually eliminated, then the\n\t * next think-time sample for bfqq may be very low. This in\n\t * turn may cause bfqq's think time to be deemed\n\t * short. Without the 100 ms barrier, this new state change\n\t * would cause the body of the next if to be executed\n\t * immediately. But this would set to 0 the inject\n\t * limit. Without injection, the blocking I/O would cause the\n\t * think time of bfqq to become long again, and therefore the\n\t * inject limit to be raised again, and so on. The only effect\n\t * of such a steady oscillation between the two think-time\n\t * states would be to prevent effective injection on bfqq.\n\t *\n\t * In contrast, if the inject limit is not reset during such a\n\t * long time interval as 100 ms, then the number of short\n\t * think time samples can grow significantly before the reset\n\t * is performed. As a consequence, the think time state can\n\t * become stable before the reset. Therefore there will be no\n\t * state change when the 100 ms elapse, and no reset of the\n\t * inject limit. The inject limit remains steadily equal to 1\n\t * both during and after the 100 ms. So injection can be\n\t * performed at all times, and throughput gets boosted.\n\t *\n\t * An inject limit equal to 1 is however in conflict, in\n\t * general, with the fact that the think time of bfqq is\n\t * short, because injection may be likely to delay bfqq's I/O\n\t * (as explained in the comments in\n\t * bfq_update_inject_limit()). But this does not happen in\n\t * this special case, because bfqq's low think time is due to\n\t * an effective handling of a synchronization, through\n\t * injection. In this special case, bfqq's I/O does not get\n\t * delayed by injection; on the contrary, bfqq's I/O is\n\t * brought forward, because it is not blocked for\n\t * milliseconds.\n\t *\n\t * In addition, serving the blocking I/O much sooner, and much\n\t * more frequently than once per I/O-plugging timeout, makes\n\t * it much quicker to detect a waker queue (the concept of\n\t * waker queue is defined in the comments in\n\t * bfq_add_request()). This makes it possible to start sooner\n\t * to boost throughput more effectively, by injecting the I/O\n\t * of the waker queue unconditionally on every\n\t * bfq_dispatch_request().\n\t *\n\t * One last, important benefit of not resetting the inject\n\t * limit before 100 ms is that, during this time interval, the\n\t * base value for the total service time is likely to get\n\t * finally computed for bfqq, freeing the inject limit from\n\t * its relation with the think time.\n\t */\n\tif (state_changed && bfqq->last_serv_time_ns == 0 &&\n\t    (time_is_before_eq_jiffies(bfqq->decrease_time_jif +\n\t\t\t\t      msecs_to_jiffies(100)) ||\n\t     !has_short_ttime))\n\t\tbfq_reset_inject_limit(bfqd, bfqq);\n}\n\n/*\n * Called when a new fs request (rq) is added to bfqq.  Check if there's\n * something we should do about it.\n */\nstatic void bfq_rq_enqueued(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t    struct request *rq)\n{\n\tif (rq->cmd_flags & REQ_META)\n\t\tbfqq->meta_pending++;\n\n\tbfqq->last_request_pos = blk_rq_pos(rq) + blk_rq_sectors(rq);\n\n\tif (bfqq == bfqd->in_service_queue && bfq_bfqq_wait_request(bfqq)) {\n\t\tbool small_req = bfqq->queued[rq_is_sync(rq)] == 1 &&\n\t\t\t\t blk_rq_sectors(rq) < 32;\n\t\tbool budget_timeout = bfq_bfqq_budget_timeout(bfqq);\n\n\t\t/*\n\t\t * There is just this request queued: if\n\t\t * - the request is small, and\n\t\t * - we are idling to boost throughput, and\n\t\t * - the queue is not to be expired,\n\t\t * then just exit.\n\t\t *\n\t\t * In this way, if the device is being idled to wait\n\t\t * for a new request from the in-service queue, we\n\t\t * avoid unplugging the device and committing the\n\t\t * device to serve just a small request. In contrast\n\t\t * we wait for the block layer to decide when to\n\t\t * unplug the device: hopefully, new requests will be\n\t\t * merged to this one quickly, then the device will be\n\t\t * unplugged and larger requests will be dispatched.\n\t\t */\n\t\tif (small_req && idling_boosts_thr_without_issues(bfqd, bfqq) &&\n\t\t    !budget_timeout)\n\t\t\treturn;\n\n\t\t/*\n\t\t * A large enough request arrived, or idling is being\n\t\t * performed to preserve service guarantees, or\n\t\t * finally the queue is to be expired: in all these\n\t\t * cases disk idling is to be stopped, so clear\n\t\t * wait_request flag and reset timer.\n\t\t */\n\t\tbfq_clear_bfqq_wait_request(bfqq);\n\t\thrtimer_try_to_cancel(&bfqd->idle_slice_timer);\n\n\t\t/*\n\t\t * The queue is not empty, because a new request just\n\t\t * arrived. Hence we can safely expire the queue, in\n\t\t * case of budget timeout, without risking that the\n\t\t * timestamps of the queue are not updated correctly.\n\t\t * See [1] for more details.\n\t\t */\n\t\tif (budget_timeout)\n\t\t\tbfq_bfqq_expire(bfqd, bfqq, false,\n\t\t\t\t\tBFQQE_BUDGET_TIMEOUT);\n\t}\n}\n\n/* returns true if it causes the idle timer to be disabled */\nstatic bool __bfq_insert_request(struct bfq_data *bfqd, struct request *rq)\n{\n\tstruct bfq_queue *bfqq = RQ_BFQQ(rq),\n\t\t*new_bfqq = bfq_setup_cooperator(bfqd, bfqq, rq, true);\n\tbool waiting, idle_timer_disabled = false;\n\n\tif (new_bfqq) {\n\t\t/*\n\t\t * Release the request's reference to the old bfqq\n\t\t * and make sure one is taken to the shared queue.\n\t\t */\n\t\tnew_bfqq->allocated++;\n\t\tbfqq->allocated--;\n\t\tnew_bfqq->ref++;\n\t\t/*\n\t\t * If the bic associated with the process\n\t\t * issuing this request still points to bfqq\n\t\t * (and thus has not been already redirected\n\t\t * to new_bfqq or even some other bfq_queue),\n\t\t * then complete the merge and redirect it to\n\t\t * new_bfqq.\n\t\t */\n\t\tif (bic_to_bfqq(RQ_BIC(rq), 1) == bfqq)\n\t\t\tbfq_merge_bfqqs(bfqd, RQ_BIC(rq),\n\t\t\t\t\tbfqq, new_bfqq);\n\n\t\tbfq_clear_bfqq_just_created(bfqq);\n\t\t/*\n\t\t * rq is about to be enqueued into new_bfqq,\n\t\t * release rq reference on bfqq\n\t\t */\n\t\tbfq_put_queue(bfqq);\n\t\trq->elv.priv[1] = new_bfqq;\n\t\tbfqq = new_bfqq;\n\t}\n\n\tbfq_update_io_thinktime(bfqd, bfqq);\n\tbfq_update_has_short_ttime(bfqd, bfqq, RQ_BIC(rq));\n\tbfq_update_io_seektime(bfqd, bfqq, rq);\n\n\twaiting = bfqq && bfq_bfqq_wait_request(bfqq);\n\tbfq_add_request(rq);\n\tidle_timer_disabled = waiting && !bfq_bfqq_wait_request(bfqq);\n\n\trq->fifo_time = ktime_get_ns() + bfqd->bfq_fifo_expire[rq_is_sync(rq)];\n\tlist_add_tail(&rq->queuelist, &bfqq->fifo);\n\n\tbfq_rq_enqueued(bfqd, bfqq, rq);\n\n\treturn idle_timer_disabled;\n}\n\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\nstatic void bfq_update_insert_stats(struct request_queue *q,\n\t\t\t\t    struct bfq_queue *bfqq,\n\t\t\t\t    bool idle_timer_disabled,\n\t\t\t\t    unsigned int cmd_flags)\n{\n\tif (!bfqq)\n\t\treturn;\n\n\t/*\n\t * bfqq still exists, because it can disappear only after\n\t * either it is merged with another queue, or the process it\n\t * is associated with exits. But both actions must be taken by\n\t * the same process currently executing this flow of\n\t * instructions.\n\t *\n\t * In addition, the following queue lock guarantees that\n\t * bfqq_group(bfqq) exists as well.\n\t */\n\tspin_lock_irq(&q->queue_lock);\n\tbfqg_stats_update_io_add(bfqq_group(bfqq), bfqq, cmd_flags);\n\tif (idle_timer_disabled)\n\t\tbfqg_stats_update_idle_time(bfqq_group(bfqq));\n\tspin_unlock_irq(&q->queue_lock);\n}\n#else\nstatic inline void bfq_update_insert_stats(struct request_queue *q,\n\t\t\t\t\t   struct bfq_queue *bfqq,\n\t\t\t\t\t   bool idle_timer_disabled,\n\t\t\t\t\t   unsigned int cmd_flags) {}\n#endif /* CONFIG_BFQ_CGROUP_DEBUG */\n\nstatic void bfq_insert_request(struct blk_mq_hw_ctx *hctx, struct request *rq,\n\t\t\t       bool at_head)\n{\n\tstruct request_queue *q = hctx->queue;\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\tstruct bfq_queue *bfqq;\n\tbool idle_timer_disabled = false;\n\tunsigned int cmd_flags;\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tif (!cgroup_subsys_on_dfl(io_cgrp_subsys) && rq->bio)\n\t\tbfqg_stats_update_legacy_io(q, rq);\n#endif\n\tspin_lock_irq(&bfqd->lock);\n\tif (blk_mq_sched_try_insert_merge(q, rq)) {\n\t\tspin_unlock_irq(&bfqd->lock);\n\t\treturn;\n\t}\n\n\tspin_unlock_irq(&bfqd->lock);\n\n\tblk_mq_sched_request_inserted(rq);\n\n\tspin_lock_irq(&bfqd->lock);\n\tbfqq = bfq_init_rq(rq);\n\tif (!bfqq || at_head || blk_rq_is_passthrough(rq)) {\n\t\tif (at_head)\n\t\t\tlist_add(&rq->queuelist, &bfqd->dispatch);\n\t\telse\n\t\t\tlist_add_tail(&rq->queuelist, &bfqd->dispatch);\n\t} else {\n\t\tidle_timer_disabled = __bfq_insert_request(bfqd, rq);\n\t\t/*\n\t\t * Update bfqq, because, if a queue merge has occurred\n\t\t * in __bfq_insert_request, then rq has been\n\t\t * redirected into a new queue.\n\t\t */\n\t\tbfqq = RQ_BFQQ(rq);\n\n\t\tif (rq_mergeable(rq)) {\n\t\t\telv_rqhash_add(q, rq);\n\t\t\tif (!q->last_merge)\n\t\t\t\tq->last_merge = rq;\n\t\t}\n\t}\n\n\t/*\n\t * Cache cmd_flags before releasing scheduler lock, because rq\n\t * may disappear afterwards (for example, because of a request\n\t * merge).\n\t */\n\tcmd_flags = rq->cmd_flags;\n\n\tspin_unlock_irq(&bfqd->lock);\n\n\tbfq_update_insert_stats(q, bfqq, idle_timer_disabled,\n\t\t\t\tcmd_flags);\n}\n\nstatic void bfq_insert_requests(struct blk_mq_hw_ctx *hctx,\n\t\t\t\tstruct list_head *list, bool at_head)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct request *rq;\n\n\t\trq = list_first_entry(list, struct request, queuelist);\n\t\tlist_del_init(&rq->queuelist);\n\t\tbfq_insert_request(hctx, rq, at_head);\n\t}\n}\n\nstatic void bfq_update_hw_tag(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq = bfqd->in_service_queue;\n\n\tbfqd->max_rq_in_driver = max_t(int, bfqd->max_rq_in_driver,\n\t\t\t\t       bfqd->rq_in_driver);\n\n\tif (bfqd->hw_tag == 1)\n\t\treturn;\n\n\t/*\n\t * This sample is valid if the number of outstanding requests\n\t * is large enough to allow a queueing behavior.  Note that the\n\t * sum is not exact, as it's not taking into account deactivated\n\t * requests.\n\t */\n\tif (bfqd->rq_in_driver + bfqd->queued <= BFQ_HW_QUEUE_THRESHOLD)\n\t\treturn;\n\n\t/*\n\t * If active queue hasn't enough requests and can idle, bfq might not\n\t * dispatch sufficient requests to hardware. Don't zero hw_tag in this\n\t * case\n\t */\n\tif (bfqq && bfq_bfqq_has_short_ttime(bfqq) &&\n\t    bfqq->dispatched + bfqq->queued[0] + bfqq->queued[1] <\n\t    BFQ_HW_QUEUE_THRESHOLD &&\n\t    bfqd->rq_in_driver < BFQ_HW_QUEUE_THRESHOLD)\n\t\treturn;\n\n\tif (bfqd->hw_tag_samples++ < BFQ_HW_QUEUE_SAMPLES)\n\t\treturn;\n\n\tbfqd->hw_tag = bfqd->max_rq_in_driver > BFQ_HW_QUEUE_THRESHOLD;\n\tbfqd->max_rq_in_driver = 0;\n\tbfqd->hw_tag_samples = 0;\n\n\tbfqd->nonrot_with_queueing =\n\t\tblk_queue_nonrot(bfqd->queue) && bfqd->hw_tag;\n}\n\nstatic void bfq_completed_request(struct bfq_queue *bfqq, struct bfq_data *bfqd)\n{\n\tu64 now_ns;\n\tu32 delta_us;\n\n\tbfq_update_hw_tag(bfqd);\n\n\tbfqd->rq_in_driver--;\n\tbfqq->dispatched--;\n\n\tif (!bfqq->dispatched && !bfq_bfqq_busy(bfqq)) {\n\t\t/*\n\t\t * Set budget_timeout (which we overload to store the\n\t\t * time at which the queue remains with no backlog and\n\t\t * no outstanding request; used by the weight-raising\n\t\t * mechanism).\n\t\t */\n\t\tbfqq->budget_timeout = jiffies;\n\n\t\tbfq_weights_tree_remove(bfqd, bfqq);\n\t}\n\n\tnow_ns = ktime_get_ns();\n\n\tbfqq->ttime.last_end_request = now_ns;\n\n\t/*\n\t * Using us instead of ns, to get a reasonable precision in\n\t * computing rate in next check.\n\t */\n\tdelta_us = div_u64(now_ns - bfqd->last_completion, NSEC_PER_USEC);\n\n\t/*\n\t * If the request took rather long to complete, and, according\n\t * to the maximum request size recorded, this completion latency\n\t * implies that the request was certainly served at a very low\n\t * rate (less than 1M sectors/sec), then the whole observation\n\t * interval that lasts up to this time instant cannot be a\n\t * valid time interval for computing a new peak rate.  Invoke\n\t * bfq_update_rate_reset to have the following three steps\n\t * taken:\n\t * - close the observation interval at the last (previous)\n\t *   request dispatch or completion\n\t * - compute rate, if possible, for that observation interval\n\t * - reset to zero samples, which will trigger a proper\n\t *   re-initialization of the observation interval on next\n\t *   dispatch\n\t */\n\tif (delta_us > BFQ_MIN_TT/NSEC_PER_USEC &&\n\t   (bfqd->last_rq_max_size<<BFQ_RATE_SHIFT)/delta_us <\n\t\t\t1UL<<(BFQ_RATE_SHIFT - 10))\n\t\tbfq_update_rate_reset(bfqd, NULL);\n\tbfqd->last_completion = now_ns;\n\tbfqd->last_completed_rq_bfqq = bfqq;\n\n\t/*\n\t * If we are waiting to discover whether the request pattern\n\t * of the task associated with the queue is actually\n\t * isochronous, and both requisites for this condition to hold\n\t * are now satisfied, then compute soft_rt_next_start (see the\n\t * comments on the function bfq_bfqq_softrt_next_start()). We\n\t * do not compute soft_rt_next_start if bfqq is in interactive\n\t * weight raising (see the comments in bfq_bfqq_expire() for\n\t * an explanation). We schedule this delayed update when bfqq\n\t * expires, if it still has in-flight requests.\n\t */\n\tif (bfq_bfqq_softrt_update(bfqq) && bfqq->dispatched == 0 &&\n\t    RB_EMPTY_ROOT(&bfqq->sort_list) &&\n\t    bfqq->wr_coeff != bfqd->bfq_wr_coeff)\n\t\tbfqq->soft_rt_next_start =\n\t\t\tbfq_bfqq_softrt_next_start(bfqd, bfqq);\n\n\t/*\n\t * If this is the in-service queue, check if it needs to be expired,\n\t * or if we want to idle in case it has no pending requests.\n\t */\n\tif (bfqd->in_service_queue == bfqq) {\n\t\tif (bfq_bfqq_must_idle(bfqq)) {\n\t\t\tif (bfqq->dispatched == 0)\n\t\t\t\tbfq_arm_slice_timer(bfqd);\n\t\t\t/*\n\t\t\t * If we get here, we do not expire bfqq, even\n\t\t\t * if bfqq was in budget timeout or had no\n\t\t\t * more requests (as controlled in the next\n\t\t\t * conditional instructions). The reason for\n\t\t\t * not expiring bfqq is as follows.\n\t\t\t *\n\t\t\t * Here bfqq->dispatched > 0 holds, but\n\t\t\t * bfq_bfqq_must_idle() returned true. This\n\t\t\t * implies that, even if no request arrives\n\t\t\t * for bfqq before bfqq->dispatched reaches 0,\n\t\t\t * bfqq will, however, not be expired on the\n\t\t\t * completion event that causes bfqq->dispatch\n\t\t\t * to reach zero. In contrast, on this event,\n\t\t\t * bfqq will start enjoying device idling\n\t\t\t * (I/O-dispatch plugging).\n\t\t\t *\n\t\t\t * But, if we expired bfqq here, bfqq would\n\t\t\t * not have the chance to enjoy device idling\n\t\t\t * when bfqq->dispatched finally reaches\n\t\t\t * zero. This would expose bfqq to violation\n\t\t\t * of its reserved service guarantees.\n\t\t\t */\n\t\t\treturn;\n\t\t} else if (bfq_may_expire_for_budg_timeout(bfqq))\n\t\t\tbfq_bfqq_expire(bfqd, bfqq, false,\n\t\t\t\t\tBFQQE_BUDGET_TIMEOUT);\n\t\telse if (RB_EMPTY_ROOT(&bfqq->sort_list) &&\n\t\t\t (bfqq->dispatched == 0 ||\n\t\t\t  !bfq_better_to_idle(bfqq)))\n\t\t\tbfq_bfqq_expire(bfqd, bfqq, false,\n\t\t\t\t\tBFQQE_NO_MORE_REQUESTS);\n\t}\n\n\tif (!bfqd->rq_in_driver)\n\t\tbfq_schedule_dispatch(bfqd);\n}\n\nstatic void bfq_finish_requeue_request_body(struct bfq_queue *bfqq)\n{\n\tbfqq->allocated--;\n\n\tbfq_put_queue(bfqq);\n}\n\n/*\n * The processes associated with bfqq may happen to generate their\n * cumulative I/O at a lower rate than the rate at which the device\n * could serve the same I/O. This is rather probable, e.g., if only\n * one process is associated with bfqq and the device is an SSD. It\n * results in bfqq becoming often empty while in service. In this\n * respect, if BFQ is allowed to switch to another queue when bfqq\n * remains empty, then the device goes on being fed with I/O requests,\n * and the throughput is not affected. In contrast, if BFQ is not\n * allowed to switch to another queue---because bfqq is sync and\n * I/O-dispatch needs to be plugged while bfqq is temporarily\n * empty---then, during the service of bfqq, there will be frequent\n * \"service holes\", i.e., time intervals during which bfqq gets empty\n * and the device can only consume the I/O already queued in its\n * hardware queues. During service holes, the device may even get to\n * remaining idle. In the end, during the service of bfqq, the device\n * is driven at a lower speed than the one it can reach with the kind\n * of I/O flowing through bfqq.\n *\n * To counter this loss of throughput, BFQ implements a \"request\n * injection mechanism\", which tries to fill the above service holes\n * with I/O requests taken from other queues. The hard part in this\n * mechanism is finding the right amount of I/O to inject, so as to\n * both boost throughput and not break bfqq's bandwidth and latency\n * guarantees. In this respect, the mechanism maintains a per-queue\n * inject limit, computed as below. While bfqq is empty, the injection\n * mechanism dispatches extra I/O requests only until the total number\n * of I/O requests in flight---i.e., already dispatched but not yet\n * completed---remains lower than this limit.\n *\n * A first definition comes in handy to introduce the algorithm by\n * which the inject limit is computed.  We define as first request for\n * bfqq, an I/O request for bfqq that arrives while bfqq is in\n * service, and causes bfqq to switch from empty to non-empty. The\n * algorithm updates the limit as a function of the effect of\n * injection on the service times of only the first requests of\n * bfqq. The reason for this restriction is that these are the\n * requests whose service time is affected most, because they are the\n * first to arrive after injection possibly occurred.\n *\n * To evaluate the effect of injection, the algorithm measures the\n * \"total service time\" of first requests. We define as total service\n * time of an I/O request, the time that elapses since when the\n * request is enqueued into bfqq, to when it is completed. This\n * quantity allows the whole effect of injection to be measured. It is\n * easy to see why. Suppose that some requests of other queues are\n * actually injected while bfqq is empty, and that a new request R\n * then arrives for bfqq. If the device does start to serve all or\n * part of the injected requests during the service hole, then,\n * because of this extra service, it may delay the next invocation of\n * the dispatch hook of BFQ. Then, even after R gets eventually\n * dispatched, the device may delay the actual service of R if it is\n * still busy serving the extra requests, or if it decides to serve,\n * before R, some extra request still present in its queues. As a\n * conclusion, the cumulative extra delay caused by injection can be\n * easily evaluated by just comparing the total service time of first\n * requests with and without injection.\n *\n * The limit-update algorithm works as follows. On the arrival of a\n * first request of bfqq, the algorithm measures the total time of the\n * request only if one of the three cases below holds, and, for each\n * case, it updates the limit as described below:\n *\n * (1) If there is no in-flight request. This gives a baseline for the\n *     total service time of the requests of bfqq. If the baseline has\n *     not been computed yet, then, after computing it, the limit is\n *     set to 1, to start boosting throughput, and to prepare the\n *     ground for the next case. If the baseline has already been\n *     computed, then it is updated, in case it results to be lower\n *     than the previous value.\n *\n * (2) If the limit is higher than 0 and there are in-flight\n *     requests. By comparing the total service time in this case with\n *     the above baseline, it is possible to know at which extent the\n *     current value of the limit is inflating the total service\n *     time. If the inflation is below a certain threshold, then bfqq\n *     is assumed to be suffering from no perceivable loss of its\n *     service guarantees, and the limit is even tentatively\n *     increased. If the inflation is above the threshold, then the\n *     limit is decreased. Due to the lack of any hysteresis, this\n *     logic makes the limit oscillate even in steady workload\n *     conditions. Yet we opted for it, because it is fast in reaching\n *     the best value for the limit, as a function of the current I/O\n *     workload. To reduce oscillations, this step is disabled for a\n *     short time interval after the limit happens to be decreased.\n *\n * (3) Periodically, after resetting the limit, to make sure that the\n *     limit eventually drops in case the workload changes. This is\n *     needed because, after the limit has gone safely up for a\n *     certain workload, it is impossible to guess whether the\n *     baseline total service time may have changed, without measuring\n *     it again without injection. A more effective version of this\n *     step might be to just sample the baseline, by interrupting\n *     injection only once, and then to reset/lower the limit only if\n *     the total service time with the current limit does happen to be\n *     too large.\n *\n * More details on each step are provided in the comments on the\n * pieces of code that implement these steps: the branch handling the\n * transition from empty to non empty in bfq_add_request(), the branch\n * handling injection in bfq_select_queue(), and the function\n * bfq_choose_bfqq_for_injection(). These comments also explain some\n * exceptions, made by the injection mechanism in some special cases.\n */\nstatic void bfq_update_inject_limit(struct bfq_data *bfqd,\n\t\t\t\t    struct bfq_queue *bfqq)\n{\n\tu64 tot_time_ns = ktime_get_ns() - bfqd->last_empty_occupied_ns;\n\tunsigned int old_limit = bfqq->inject_limit;\n\n\tif (bfqq->last_serv_time_ns > 0 && bfqd->rqs_injected) {\n\t\tu64 threshold = (bfqq->last_serv_time_ns * 3)>>1;\n\n\t\tif (tot_time_ns >= threshold && old_limit > 0) {\n\t\t\tbfqq->inject_limit--;\n\t\t\tbfqq->decrease_time_jif = jiffies;\n\t\t} else if (tot_time_ns < threshold &&\n\t\t\t   old_limit <= bfqd->max_rq_in_driver)\n\t\t\tbfqq->inject_limit++;\n\t}\n\n\t/*\n\t * Either we still have to compute the base value for the\n\t * total service time, and there seem to be the right\n\t * conditions to do it, or we can lower the last base value\n\t * computed.\n\t *\n\t * NOTE: (bfqd->rq_in_driver == 1) means that there is no I/O\n\t * request in flight, because this function is in the code\n\t * path that handles the completion of a request of bfqq, and,\n\t * in particular, this function is executed before\n\t * bfqd->rq_in_driver is decremented in such a code path.\n\t */\n\tif ((bfqq->last_serv_time_ns == 0 && bfqd->rq_in_driver == 1) ||\n\t    tot_time_ns < bfqq->last_serv_time_ns) {\n\t\tif (bfqq->last_serv_time_ns == 0) {\n\t\t\t/*\n\t\t\t * Now we certainly have a base value: make sure we\n\t\t\t * start trying injection.\n\t\t\t */\n\t\t\tbfqq->inject_limit = max_t(unsigned int, 1, old_limit);\n\t\t}\n\t\tbfqq->last_serv_time_ns = tot_time_ns;\n\t} else if (!bfqd->rqs_injected && bfqd->rq_in_driver == 1)\n\t\t/*\n\t\t * No I/O injected and no request still in service in\n\t\t * the drive: these are the exact conditions for\n\t\t * computing the base value of the total service time\n\t\t * for bfqq. So let's update this value, because it is\n\t\t * rather variable. For example, it varies if the size\n\t\t * or the spatial locality of the I/O requests in bfqq\n\t\t * change.\n\t\t */\n\t\tbfqq->last_serv_time_ns = tot_time_ns;\n\n\n\t/* update complete, not waiting for any request completion any longer */\n\tbfqd->waited_rq = NULL;\n\tbfqd->rqs_injected = false;\n}\n\n/*\n * Handle either a requeue or a finish for rq. The things to do are\n * the same in both cases: all references to rq are to be dropped. In\n * particular, rq is considered completed from the point of view of\n * the scheduler.\n */\nstatic void bfq_finish_requeue_request(struct request *rq)\n{\n\tstruct bfq_queue *bfqq = RQ_BFQQ(rq);\n\tstruct bfq_data *bfqd;\n\n\t/*\n\t * Requeue and finish hooks are invoked in blk-mq without\n\t * checking whether the involved request is actually still\n\t * referenced in the scheduler. To handle this fact, the\n\t * following two checks make this function exit in case of\n\t * spurious invocations, for which there is nothing to do.\n\t *\n\t * First, check whether rq has nothing to do with an elevator.\n\t */\n\tif (unlikely(!(rq->rq_flags & RQF_ELVPRIV)))\n\t\treturn;\n\n\t/*\n\t * rq either is not associated with any icq, or is an already\n\t * requeued request that has not (yet) been re-inserted into\n\t * a bfq_queue.\n\t */\n\tif (!rq->elv.icq || !bfqq)\n\t\treturn;\n\n\tbfqd = bfqq->bfqd;\n\n\tif (rq->rq_flags & RQF_STARTED)\n\t\tbfqg_stats_update_completion(bfqq_group(bfqq),\n\t\t\t\t\t     rq->start_time_ns,\n\t\t\t\t\t     rq->io_start_time_ns,\n\t\t\t\t\t     rq->cmd_flags);\n\n\tif (likely(rq->rq_flags & RQF_STARTED)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&bfqd->lock, flags);\n\n\t\tif (rq == bfqd->waited_rq)\n\t\t\tbfq_update_inject_limit(bfqd, bfqq);\n\n\t\tbfq_completed_request(bfqq, bfqd);\n\t\tbfq_finish_requeue_request_body(bfqq);\n\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t} else {\n\t\t/*\n\t\t * Request rq may be still/already in the scheduler,\n\t\t * in which case we need to remove it (this should\n\t\t * never happen in case of requeue). And we cannot\n\t\t * defer such a check and removal, to avoid\n\t\t * inconsistencies in the time interval from the end\n\t\t * of this function to the start of the deferred work.\n\t\t * This situation seems to occur only in process\n\t\t * context, as a consequence of a merge. In the\n\t\t * current version of the code, this implies that the\n\t\t * lock is held.\n\t\t */\n\n\t\tif (!RB_EMPTY_NODE(&rq->rb_node)) {\n\t\t\tbfq_remove_request(rq->q, rq);\n\t\t\tbfqg_stats_update_io_remove(bfqq_group(bfqq),\n\t\t\t\t\t\t    rq->cmd_flags);\n\t\t}\n\t\tbfq_finish_requeue_request_body(bfqq);\n\t}\n\n\t/*\n\t * Reset private fields. In case of a requeue, this allows\n\t * this function to correctly do nothing if it is spuriously\n\t * invoked again on this same request (see the check at the\n\t * beginning of the function). Probably, a better general\n\t * design would be to prevent blk-mq from invoking the requeue\n\t * or finish hooks of an elevator, for a request that is not\n\t * referred by that elevator.\n\t *\n\t * Resetting the following fields would break the\n\t * request-insertion logic if rq is re-inserted into a bfq\n\t * internal queue, without a re-preparation. Here we assume\n\t * that re-insertions of requeued requests, without\n\t * re-preparation, can happen only for pass_through or at_head\n\t * requests (which are not re-inserted into bfq internal\n\t * queues).\n\t */\n\trq->elv.priv[0] = NULL;\n\trq->elv.priv[1] = NULL;\n}\n\n/*\n * Removes the association between the current task and bfqq, assuming\n * that bic points to the bfq iocontext of the task.\n * Returns NULL if a new bfqq should be allocated, or the old bfqq if this\n * was the last process referring to that bfqq.\n */\nstatic struct bfq_queue *\nbfq_split_bfqq(struct bfq_io_cq *bic, struct bfq_queue *bfqq)\n{\n\tbfq_log_bfqq(bfqq->bfqd, bfqq, \"splitting queue\");\n\n\tif (bfqq_process_refs(bfqq) == 1) {\n\t\tbfqq->pid = current->pid;\n\t\tbfq_clear_bfqq_coop(bfqq);\n\t\tbfq_clear_bfqq_split_coop(bfqq);\n\t\treturn bfqq;\n\t}\n\n\tbic_set_bfqq(bic, NULL, 1);\n\n\tbfq_put_cooperator(bfqq);\n\n\tbfq_release_process_ref(bfqq->bfqd, bfqq);\n\treturn NULL;\n}\n\nstatic struct bfq_queue *bfq_get_bfqq_handle_split(struct bfq_data *bfqd,\n\t\t\t\t\t\t   struct bfq_io_cq *bic,\n\t\t\t\t\t\t   struct bio *bio,\n\t\t\t\t\t\t   bool split, bool is_sync,\n\t\t\t\t\t\t   bool *new_queue)\n{\n\tstruct bfq_queue *bfqq = bic_to_bfqq(bic, is_sync);\n\n\tif (likely(bfqq && bfqq != &bfqd->oom_bfqq))\n\t\treturn bfqq;\n\n\tif (new_queue)\n\t\t*new_queue = true;\n\n\tif (bfqq)\n\t\tbfq_put_queue(bfqq);\n\tbfqq = bfq_get_queue(bfqd, bio, is_sync, bic);\n\n\tbic_set_bfqq(bic, bfqq, is_sync);\n\tif (split && is_sync) {\n\t\tif ((bic->was_in_burst_list && bfqd->large_burst) ||\n\t\t    bic->saved_in_large_burst)\n\t\t\tbfq_mark_bfqq_in_large_burst(bfqq);\n\t\telse {\n\t\t\tbfq_clear_bfqq_in_large_burst(bfqq);\n\t\t\tif (bic->was_in_burst_list)\n\t\t\t\t/*\n\t\t\t\t * If bfqq was in the current\n\t\t\t\t * burst list before being\n\t\t\t\t * merged, then we have to add\n\t\t\t\t * it back. And we do not need\n\t\t\t\t * to increase burst_size, as\n\t\t\t\t * we did not decrement\n\t\t\t\t * burst_size when we removed\n\t\t\t\t * bfqq from the burst list as\n\t\t\t\t * a consequence of a merge\n\t\t\t\t * (see comments in\n\t\t\t\t * bfq_put_queue). In this\n\t\t\t\t * respect, it would be rather\n\t\t\t\t * costly to know whether the\n\t\t\t\t * current burst list is still\n\t\t\t\t * the same burst list from\n\t\t\t\t * which bfqq was removed on\n\t\t\t\t * the merge. To avoid this\n\t\t\t\t * cost, if bfqq was in a\n\t\t\t\t * burst list, then we add\n\t\t\t\t * bfqq to the current burst\n\t\t\t\t * list without any further\n\t\t\t\t * check. This can cause\n\t\t\t\t * inappropriate insertions,\n\t\t\t\t * but rarely enough to not\n\t\t\t\t * harm the detection of large\n\t\t\t\t * bursts significantly.\n\t\t\t\t */\n\t\t\t\thlist_add_head(&bfqq->burst_list_node,\n\t\t\t\t\t       &bfqd->burst_list);\n\t\t}\n\t\tbfqq->split_time = jiffies;\n\t}\n\n\treturn bfqq;\n}\n\n/*\n * Only reset private fields. The actual request preparation will be\n * performed by bfq_init_rq, when rq is either inserted or merged. See\n * comments on bfq_init_rq for the reason behind this delayed\n * preparation.\n */\nstatic void bfq_prepare_request(struct request *rq, struct bio *bio)\n{\n\t/*\n\t * Regardless of whether we have an icq attached, we have to\n\t * clear the scheduler pointers, as they might point to\n\t * previously allocated bic/bfqq structs.\n\t */\n\trq->elv.priv[0] = rq->elv.priv[1] = NULL;\n}\n\n/*\n * If needed, init rq, allocate bfq data structures associated with\n * rq, and increment reference counters in the destination bfq_queue\n * for rq. Return the destination bfq_queue for rq, or NULL is rq is\n * not associated with any bfq_queue.\n *\n * This function is invoked by the functions that perform rq insertion\n * or merging. One may have expected the above preparation operations\n * to be performed in bfq_prepare_request, and not delayed to when rq\n * is inserted or merged. The rationale behind this delayed\n * preparation is that, after the prepare_request hook is invoked for\n * rq, rq may still be transformed into a request with no icq, i.e., a\n * request not associated with any queue. No bfq hook is invoked to\n * signal this transformation. As a consequence, should these\n * preparation operations be performed when the prepare_request hook\n * is invoked, and should rq be transformed one moment later, bfq\n * would end up in an inconsistent state, because it would have\n * incremented some queue counters for an rq destined to\n * transformation, without any chance to correctly lower these\n * counters back. In contrast, no transformation can still happen for\n * rq after rq has been inserted or merged. So, it is safe to execute\n * these preparation operations when rq is finally inserted or merged.\n */\nstatic struct bfq_queue *bfq_init_rq(struct request *rq)\n{\n\tstruct request_queue *q = rq->q;\n\tstruct bio *bio = rq->bio;\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\tstruct bfq_io_cq *bic;\n\tconst int is_sync = rq_is_sync(rq);\n\tstruct bfq_queue *bfqq;\n\tbool new_queue = false;\n\tbool bfqq_already_existing = false, split = false;\n\n\tif (unlikely(!rq->elv.icq))\n\t\treturn NULL;\n\n\t/*\n\t * Assuming that elv.priv[1] is set only if everything is set\n\t * for this rq. This holds true, because this function is\n\t * invoked only for insertion or merging, and, after such\n\t * events, a request cannot be manipulated any longer before\n\t * being removed from bfq.\n\t */\n\tif (rq->elv.priv[1])\n\t\treturn rq->elv.priv[1];\n\n\tbic = icq_to_bic(rq->elv.icq);\n\n\tbfq_check_ioprio_change(bic, bio);\n\n\tbfq_bic_update_cgroup(bic, bio);\n\n\tbfqq = bfq_get_bfqq_handle_split(bfqd, bic, bio, false, is_sync,\n\t\t\t\t\t &new_queue);\n\n\tif (likely(!new_queue)) {\n\t\t/* If the queue was seeky for too long, break it apart. */\n\t\tif (bfq_bfqq_coop(bfqq) && bfq_bfqq_split_coop(bfqq)) {\n\t\t\tbfq_log_bfqq(bfqd, bfqq, \"breaking apart bfqq\");\n\n\t\t\t/* Update bic before losing reference to bfqq */\n\t\t\tif (bfq_bfqq_in_large_burst(bfqq))\n\t\t\t\tbic->saved_in_large_burst = true;\n\n\t\t\tbfqq = bfq_split_bfqq(bic, bfqq);\n\t\t\tsplit = true;\n\n\t\t\tif (!bfqq)\n\t\t\t\tbfqq = bfq_get_bfqq_handle_split(bfqd, bic, bio,\n\t\t\t\t\t\t\t\t true, is_sync,\n\t\t\t\t\t\t\t\t NULL);\n\t\t\telse\n\t\t\t\tbfqq_already_existing = true;\n\t\t}\n\t}\n\n\tbfqq->allocated++;\n\tbfqq->ref++;\n\tbfq_log_bfqq(bfqd, bfqq, \"get_request %p: bfqq %p, %d\",\n\t\t     rq, bfqq, bfqq->ref);\n\n\trq->elv.priv[0] = bic;\n\trq->elv.priv[1] = bfqq;\n\n\t/*\n\t * If a bfq_queue has only one process reference, it is owned\n\t * by only this bic: we can then set bfqq->bic = bic. in\n\t * addition, if the queue has also just been split, we have to\n\t * resume its state.\n\t */\n\tif (likely(bfqq != &bfqd->oom_bfqq) && bfqq_process_refs(bfqq) == 1) {\n\t\tbfqq->bic = bic;\n\t\tif (split) {\n\t\t\t/*\n\t\t\t * The queue has just been split from a shared\n\t\t\t * queue: restore the idle window and the\n\t\t\t * possible weight raising period.\n\t\t\t */\n\t\t\tbfq_bfqq_resume_state(bfqq, bfqd, bic,\n\t\t\t\t\t      bfqq_already_existing);\n\t\t}\n\t}\n\n\t/*\n\t * Consider bfqq as possibly belonging to a burst of newly\n\t * created queues only if:\n\t * 1) A burst is actually happening (bfqd->burst_size > 0)\n\t * or\n\t * 2) There is no other active queue. In fact, if, in\n\t *    contrast, there are active queues not belonging to the\n\t *    possible burst bfqq may belong to, then there is no gain\n\t *    in considering bfqq as belonging to a burst, and\n\t *    therefore in not weight-raising bfqq. See comments on\n\t *    bfq_handle_burst().\n\t *\n\t * This filtering also helps eliminating false positives,\n\t * occurring when bfqq does not belong to an actual large\n\t * burst, but some background task (e.g., a service) happens\n\t * to trigger the creation of new queues very close to when\n\t * bfqq and its possible companion queues are created. See\n\t * comments on bfq_handle_burst() for further details also on\n\t * this issue.\n\t */\n\tif (unlikely(bfq_bfqq_just_created(bfqq) &&\n\t\t     (bfqd->burst_size > 0 ||\n\t\t      bfq_tot_busy_queues(bfqd) == 0)))\n\t\tbfq_handle_burst(bfqd, bfqq);\n\n\treturn bfqq;\n}\n\nstatic void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\tbfq_clear_bfqq_wait_request(bfqq);\n\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\t/*\n\t\t * Also here the queue can be safely expired\n\t\t * for budget timeout without wasting\n\t\t * guarantees\n\t\t */\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\t/*\n\t\t * The queue may not be empty upon timer expiration,\n\t\t * because we may not disable the timer when the\n\t\t * first request of the in-service queue arrives\n\t\t * during disk idling.\n\t\t */\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\n\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);\n}\n\n/*\n * Handler of the expiration of the timer running if the in-service queue\n * is idling inside its time slice.\n */\nstatic enum hrtimer_restart bfq_idle_slice_timer(struct hrtimer *timer)\n{\n\tstruct bfq_data *bfqd = container_of(timer, struct bfq_data,\n\t\t\t\t\t     idle_slice_timer);\n\tstruct bfq_queue *bfqq = bfqd->in_service_queue;\n\n\t/*\n\t * Theoretical race here: the in-service queue can be NULL or\n\t * different from the queue that was idling if a new request\n\t * arrives for the current queue and there is a full dispatch\n\t * cycle that changes the in-service queue.  This can hardly\n\t * happen, but in the worst case we just expire a queue too\n\t * early.\n\t */\n\tif (bfqq)\n\t\tbfq_idle_slice_timer_body(bfqq);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void __bfq_put_async_bfqq(struct bfq_data *bfqd,\n\t\t\t\t struct bfq_queue **bfqq_ptr)\n{\n\tstruct bfq_queue *bfqq = *bfqq_ptr;\n\n\tbfq_log(bfqd, \"put_async_bfqq: %p\", bfqq);\n\tif (bfqq) {\n\t\tbfq_bfqq_move(bfqd, bfqq, bfqd->root_group);\n\n\t\tbfq_log_bfqq(bfqd, bfqq, \"put_async_bfqq: putting %p, %d\",\n\t\t\t     bfqq, bfqq->ref);\n\t\tbfq_put_queue(bfqq);\n\t\t*bfqq_ptr = NULL;\n\t}\n}\n\n/*\n * Release all the bfqg references to its async queues.  If we are\n * deallocating the group these queues may still contain requests, so\n * we reparent them to the root cgroup (i.e., the only one that will\n * exist for sure until all the requests on a device are gone).\n */\nvoid bfq_put_async_queues(struct bfq_data *bfqd, struct bfq_group *bfqg)\n{\n\tint i, j;\n\n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < IOPRIO_BE_NR; j++)\n\t\t\t__bfq_put_async_bfqq(bfqd, &bfqg->async_bfqq[i][j]);\n\n\t__bfq_put_async_bfqq(bfqd, &bfqg->async_idle_bfqq);\n}\n\n/*\n * See the comments on bfq_limit_depth for the purpose of\n * the depths set in the function. Return minimum shallow depth we'll use.\n */\nstatic unsigned int bfq_update_depths(struct bfq_data *bfqd,\n\t\t\t\t      struct sbitmap_queue *bt)\n{\n\tunsigned int i, j, min_shallow = UINT_MAX;\n\n\t/*\n\t * In-word depths if no bfq_queue is being weight-raised:\n\t * leaving 25% of tags only for sync reads.\n\t *\n\t * In next formulas, right-shift the value\n\t * (1U<<bt->sb.shift), instead of computing directly\n\t * (1U<<(bt->sb.shift - something)), to be robust against\n\t * any possible value of bt->sb.shift, without having to\n\t * limit 'something'.\n\t */\n\t/* no more than 50% of tags for async I/O */\n\tbfqd->word_depths[0][0] = max((1U << bt->sb.shift) >> 1, 1U);\n\t/*\n\t * no more than 75% of tags for sync writes (25% extra tags\n\t * w.r.t. async I/O, to prevent async I/O from starving sync\n\t * writes)\n\t */\n\tbfqd->word_depths[0][1] = max(((1U << bt->sb.shift) * 3) >> 2, 1U);\n\n\t/*\n\t * In-word depths in case some bfq_queue is being weight-\n\t * raised: leaving ~63% of tags for sync reads. This is the\n\t * highest percentage for which, in our tests, application\n\t * start-up times didn't suffer from any regression due to tag\n\t * shortage.\n\t */\n\t/* no more than ~18% of tags for async I/O */\n\tbfqd->word_depths[1][0] = max(((1U << bt->sb.shift) * 3) >> 4, 1U);\n\t/* no more than ~37% of tags for sync writes (~20% extra tags) */\n\tbfqd->word_depths[1][1] = max(((1U << bt->sb.shift) * 6) >> 4, 1U);\n\n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < 2; j++)\n\t\t\tmin_shallow = min(min_shallow, bfqd->word_depths[i][j]);\n\n\treturn min_shallow;\n}\n\nstatic void bfq_depth_updated(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct bfq_data *bfqd = hctx->queue->elevator->elevator_data;\n\tstruct blk_mq_tags *tags = hctx->sched_tags;\n\tunsigned int min_shallow;\n\n\tmin_shallow = bfq_update_depths(bfqd, &tags->bitmap_tags);\n\tsbitmap_queue_min_shallow_depth(&tags->bitmap_tags, min_shallow);\n}\n\nstatic int bfq_init_hctx(struct blk_mq_hw_ctx *hctx, unsigned int index)\n{\n\tbfq_depth_updated(hctx);\n\treturn 0;\n}\n\nstatic void bfq_exit_queue(struct elevator_queue *e)\n{\n\tstruct bfq_data *bfqd = e->elevator_data;\n\tstruct bfq_queue *bfqq, *n;\n\n\thrtimer_cancel(&bfqd->idle_slice_timer);\n\n\tspin_lock_irq(&bfqd->lock);\n\tlist_for_each_entry_safe(bfqq, n, &bfqd->idle_list, bfqq_list)\n\t\tbfq_deactivate_bfqq(bfqd, bfqq, false, false);\n\tspin_unlock_irq(&bfqd->lock);\n\n\thrtimer_cancel(&bfqd->idle_slice_timer);\n\n\t/* release oom-queue reference to root group */\n\tbfqg_and_blkg_put(bfqd->root_group);\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tblkcg_deactivate_policy(bfqd->queue, &blkcg_policy_bfq);\n#else\n\tspin_lock_irq(&bfqd->lock);\n\tbfq_put_async_queues(bfqd, bfqd->root_group);\n\tkfree(bfqd->root_group);\n\tspin_unlock_irq(&bfqd->lock);\n#endif\n\n\tkfree(bfqd);\n}\n\nstatic void bfq_init_root_group(struct bfq_group *root_group,\n\t\t\t\tstruct bfq_data *bfqd)\n{\n\tint i;\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\troot_group->entity.parent = NULL;\n\troot_group->my_entity = NULL;\n\troot_group->bfqd = bfqd;\n#endif\n\troot_group->rq_pos_tree = RB_ROOT;\n\tfor (i = 0; i < BFQ_IOPRIO_CLASSES; i++)\n\t\troot_group->sched_data.service_tree[i] = BFQ_SERVICE_TREE_INIT;\n\troot_group->sched_data.bfq_class_idle_last_service = jiffies;\n}\n\nstatic int bfq_init_queue(struct request_queue *q, struct elevator_type *e)\n{\n\tstruct bfq_data *bfqd;\n\tstruct elevator_queue *eq;\n\n\teq = elevator_alloc(q, e);\n\tif (!eq)\n\t\treturn -ENOMEM;\n\n\tbfqd = kzalloc_node(sizeof(*bfqd), GFP_KERNEL, q->node);\n\tif (!bfqd) {\n\t\tkobject_put(&eq->kobj);\n\t\treturn -ENOMEM;\n\t}\n\teq->elevator_data = bfqd;\n\n\tspin_lock_irq(&q->queue_lock);\n\tq->elevator = eq;\n\tspin_unlock_irq(&q->queue_lock);\n\n\t/*\n\t * Our fallback bfqq if bfq_find_alloc_queue() runs into OOM issues.\n\t * Grab a permanent reference to it, so that the normal code flow\n\t * will not attempt to free it.\n\t */\n\tbfq_init_bfqq(bfqd, &bfqd->oom_bfqq, NULL, 1, 0);\n\tbfqd->oom_bfqq.ref++;\n\tbfqd->oom_bfqq.new_ioprio = BFQ_DEFAULT_QUEUE_IOPRIO;\n\tbfqd->oom_bfqq.new_ioprio_class = IOPRIO_CLASS_BE;\n\tbfqd->oom_bfqq.entity.new_weight =\n\t\tbfq_ioprio_to_weight(bfqd->oom_bfqq.new_ioprio);\n\n\t/* oom_bfqq does not participate to bursts */\n\tbfq_clear_bfqq_just_created(&bfqd->oom_bfqq);\n\n\t/*\n\t * Trigger weight initialization, according to ioprio, at the\n\t * oom_bfqq's first activation. The oom_bfqq's ioprio and ioprio\n\t * class won't be changed any more.\n\t */\n\tbfqd->oom_bfqq.entity.prio_changed = 1;\n\n\tbfqd->queue = q;\n\n\tINIT_LIST_HEAD(&bfqd->dispatch);\n\n\thrtimer_init(&bfqd->idle_slice_timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL);\n\tbfqd->idle_slice_timer.function = bfq_idle_slice_timer;\n\n\tbfqd->queue_weights_tree = RB_ROOT_CACHED;\n\tbfqd->num_groups_with_pending_reqs = 0;\n\n\tINIT_LIST_HEAD(&bfqd->active_list);\n\tINIT_LIST_HEAD(&bfqd->idle_list);\n\tINIT_HLIST_HEAD(&bfqd->burst_list);\n\n\tbfqd->hw_tag = -1;\n\tbfqd->nonrot_with_queueing = blk_queue_nonrot(bfqd->queue);\n\n\tbfqd->bfq_max_budget = bfq_default_max_budget;\n\n\tbfqd->bfq_fifo_expire[0] = bfq_fifo_expire[0];\n\tbfqd->bfq_fifo_expire[1] = bfq_fifo_expire[1];\n\tbfqd->bfq_back_max = bfq_back_max;\n\tbfqd->bfq_back_penalty = bfq_back_penalty;\n\tbfqd->bfq_slice_idle = bfq_slice_idle;\n\tbfqd->bfq_timeout = bfq_timeout;\n\n\tbfqd->bfq_requests_within_timer = 120;\n\n\tbfqd->bfq_large_burst_thresh = 8;\n\tbfqd->bfq_burst_interval = msecs_to_jiffies(180);\n\n\tbfqd->low_latency = true;\n\n\t/*\n\t * Trade-off between responsiveness and fairness.\n\t */\n\tbfqd->bfq_wr_coeff = 30;\n\tbfqd->bfq_wr_rt_max_time = msecs_to_jiffies(300);\n\tbfqd->bfq_wr_max_time = 0;\n\tbfqd->bfq_wr_min_idle_time = msecs_to_jiffies(2000);\n\tbfqd->bfq_wr_min_inter_arr_async = msecs_to_jiffies(500);\n\tbfqd->bfq_wr_max_softrt_rate = 7000; /*\n\t\t\t\t\t      * Approximate rate required\n\t\t\t\t\t      * to playback or record a\n\t\t\t\t\t      * high-definition compressed\n\t\t\t\t\t      * video.\n\t\t\t\t\t      */\n\tbfqd->wr_busy_queues = 0;\n\n\t/*\n\t * Begin by assuming, optimistically, that the device peak\n\t * rate is equal to 2/3 of the highest reference rate.\n\t */\n\tbfqd->rate_dur_prod = ref_rate[blk_queue_nonrot(bfqd->queue)] *\n\t\tref_wr_duration[blk_queue_nonrot(bfqd->queue)];\n\tbfqd->peak_rate = ref_rate[blk_queue_nonrot(bfqd->queue)] * 2 / 3;\n\n\tspin_lock_init(&bfqd->lock);\n\n\t/*\n\t * The invocation of the next bfq_create_group_hierarchy\n\t * function is the head of a chain of function calls\n\t * (bfq_create_group_hierarchy->blkcg_activate_policy->\n\t * blk_mq_freeze_queue) that may lead to the invocation of the\n\t * has_work hook function. For this reason,\n\t * bfq_create_group_hierarchy is invoked only after all\n\t * scheduler data has been initialized, apart from the fields\n\t * that can be initialized only after invoking\n\t * bfq_create_group_hierarchy. This, in particular, enables\n\t * has_work to correctly return false. Of course, to avoid\n\t * other inconsistencies, the blk-mq stack must then refrain\n\t * from invoking further scheduler hooks before this init\n\t * function is finished.\n\t */\n\tbfqd->root_group = bfq_create_group_hierarchy(bfqd, q->node);\n\tif (!bfqd->root_group)\n\t\tgoto out_free;\n\tbfq_init_root_group(bfqd->root_group, bfqd);\n\tbfq_init_entity(&bfqd->oom_bfqq.entity, bfqd->root_group);\n\n\twbt_disable_default(q);\n\treturn 0;\n\nout_free:\n\tkfree(bfqd);\n\tkobject_put(&eq->kobj);\n\treturn -ENOMEM;\n}\n\nstatic void bfq_slab_kill(void)\n{\n\tkmem_cache_destroy(bfq_pool);\n}\n\nstatic int __init bfq_slab_setup(void)\n{\n\tbfq_pool = KMEM_CACHE(bfq_queue, 0);\n\tif (!bfq_pool)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic ssize_t bfq_var_show(unsigned int var, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", var);\n}\n\nstatic int bfq_var_store(unsigned long *var, const char *page)\n{\n\tunsigned long new_val;\n\tint ret = kstrtoul(page, 10, &new_val);\n\n\tif (ret)\n\t\treturn ret;\n\t*var = new_val;\n\treturn 0;\n}\n\n#define SHOW_FUNCTION(__FUNC, __VAR, __CONV)\t\t\t\t\\\nstatic ssize_t __FUNC(struct elevator_queue *e, char *page)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bfq_data *bfqd = e->elevator_data;\t\t\t\\\n\tu64 __data = __VAR;\t\t\t\t\t\t\\\n\tif (__CONV == 1)\t\t\t\t\t\t\\\n\t\t__data = jiffies_to_msecs(__data);\t\t\t\\\n\telse if (__CONV == 2)\t\t\t\t\t\t\\\n\t\t__data = div_u64(__data, NSEC_PER_MSEC);\t\t\\\n\treturn bfq_var_show(__data, (page));\t\t\t\t\\\n}\nSHOW_FUNCTION(bfq_fifo_expire_sync_show, bfqd->bfq_fifo_expire[1], 2);\nSHOW_FUNCTION(bfq_fifo_expire_async_show, bfqd->bfq_fifo_expire[0], 2);\nSHOW_FUNCTION(bfq_back_seek_max_show, bfqd->bfq_back_max, 0);\nSHOW_FUNCTION(bfq_back_seek_penalty_show, bfqd->bfq_back_penalty, 0);\nSHOW_FUNCTION(bfq_slice_idle_show, bfqd->bfq_slice_idle, 2);\nSHOW_FUNCTION(bfq_max_budget_show, bfqd->bfq_user_max_budget, 0);\nSHOW_FUNCTION(bfq_timeout_sync_show, bfqd->bfq_timeout, 1);\nSHOW_FUNCTION(bfq_strict_guarantees_show, bfqd->strict_guarantees, 0);\nSHOW_FUNCTION(bfq_low_latency_show, bfqd->low_latency, 0);\n#undef SHOW_FUNCTION\n\n#define USEC_SHOW_FUNCTION(__FUNC, __VAR)\t\t\t\t\\\nstatic ssize_t __FUNC(struct elevator_queue *e, char *page)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bfq_data *bfqd = e->elevator_data;\t\t\t\\\n\tu64 __data = __VAR;\t\t\t\t\t\t\\\n\t__data = div_u64(__data, NSEC_PER_USEC);\t\t\t\\\n\treturn bfq_var_show(__data, (page));\t\t\t\t\\\n}\nUSEC_SHOW_FUNCTION(bfq_slice_idle_us_show, bfqd->bfq_slice_idle);\n#undef USEC_SHOW_FUNCTION\n\n#define STORE_FUNCTION(__FUNC, __PTR, MIN, MAX, __CONV)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\n__FUNC(struct elevator_queue *e, const char *page, size_t count)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bfq_data *bfqd = e->elevator_data;\t\t\t\\\n\tunsigned long __data, __min = (MIN), __max = (MAX);\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = bfq_var_store(&__data, (page));\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\tif (__data < __min)\t\t\t\t\t\t\\\n\t\t__data = __min;\t\t\t\t\t\t\\\n\telse if (__data > __max)\t\t\t\t\t\\\n\t\t__data = __max;\t\t\t\t\t\t\\\n\tif (__CONV == 1)\t\t\t\t\t\t\\\n\t\t*(__PTR) = msecs_to_jiffies(__data);\t\t\t\\\n\telse if (__CONV == 2)\t\t\t\t\t\t\\\n\t\t*(__PTR) = (u64)__data * NSEC_PER_MSEC;\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t*(__PTR) = __data;\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\nSTORE_FUNCTION(bfq_fifo_expire_sync_store, &bfqd->bfq_fifo_expire[1], 1,\n\t\tINT_MAX, 2);\nSTORE_FUNCTION(bfq_fifo_expire_async_store, &bfqd->bfq_fifo_expire[0], 1,\n\t\tINT_MAX, 2);\nSTORE_FUNCTION(bfq_back_seek_max_store, &bfqd->bfq_back_max, 0, INT_MAX, 0);\nSTORE_FUNCTION(bfq_back_seek_penalty_store, &bfqd->bfq_back_penalty, 1,\n\t\tINT_MAX, 0);\nSTORE_FUNCTION(bfq_slice_idle_store, &bfqd->bfq_slice_idle, 0, INT_MAX, 2);\n#undef STORE_FUNCTION\n\n#define USEC_STORE_FUNCTION(__FUNC, __PTR, MIN, MAX)\t\t\t\\\nstatic ssize_t __FUNC(struct elevator_queue *e, const char *page, size_t count)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bfq_data *bfqd = e->elevator_data;\t\t\t\\\n\tunsigned long __data, __min = (MIN), __max = (MAX);\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = bfq_var_store(&__data, (page));\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\tif (__data < __min)\t\t\t\t\t\t\\\n\t\t__data = __min;\t\t\t\t\t\t\\\n\telse if (__data > __max)\t\t\t\t\t\\\n\t\t__data = __max;\t\t\t\t\t\t\\\n\t*(__PTR) = (u64)__data * NSEC_PER_USEC;\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\nUSEC_STORE_FUNCTION(bfq_slice_idle_us_store, &bfqd->bfq_slice_idle, 0,\n\t\t    UINT_MAX);\n#undef USEC_STORE_FUNCTION\n\nstatic ssize_t bfq_max_budget_store(struct elevator_queue *e,\n\t\t\t\t    const char *page, size_t count)\n{\n\tstruct bfq_data *bfqd = e->elevator_data;\n\tunsigned long __data;\n\tint ret;\n\n\tret = bfq_var_store(&__data, (page));\n\tif (ret)\n\t\treturn ret;\n\n\tif (__data == 0)\n\t\tbfqd->bfq_max_budget = bfq_calc_max_budget(bfqd);\n\telse {\n\t\tif (__data > INT_MAX)\n\t\t\t__data = INT_MAX;\n\t\tbfqd->bfq_max_budget = __data;\n\t}\n\n\tbfqd->bfq_user_max_budget = __data;\n\n\treturn count;\n}\n\n/*\n * Leaving this name to preserve name compatibility with cfq\n * parameters, but this timeout is used for both sync and async.\n */\nstatic ssize_t bfq_timeout_sync_store(struct elevator_queue *e,\n\t\t\t\t      const char *page, size_t count)\n{\n\tstruct bfq_data *bfqd = e->elevator_data;\n\tunsigned long __data;\n\tint ret;\n\n\tret = bfq_var_store(&__data, (page));\n\tif (ret)\n\t\treturn ret;\n\n\tif (__data < 1)\n\t\t__data = 1;\n\telse if (__data > INT_MAX)\n\t\t__data = INT_MAX;\n\n\tbfqd->bfq_timeout = msecs_to_jiffies(__data);\n\tif (bfqd->bfq_user_max_budget == 0)\n\t\tbfqd->bfq_max_budget = bfq_calc_max_budget(bfqd);\n\n\treturn count;\n}\n\nstatic ssize_t bfq_strict_guarantees_store(struct elevator_queue *e,\n\t\t\t\t     const char *page, size_t count)\n{\n\tstruct bfq_data *bfqd = e->elevator_data;\n\tunsigned long __data;\n\tint ret;\n\n\tret = bfq_var_store(&__data, (page));\n\tif (ret)\n\t\treturn ret;\n\n\tif (__data > 1)\n\t\t__data = 1;\n\tif (!bfqd->strict_guarantees && __data == 1\n\t    && bfqd->bfq_slice_idle < 8 * NSEC_PER_MSEC)\n\t\tbfqd->bfq_slice_idle = 8 * NSEC_PER_MSEC;\n\n\tbfqd->strict_guarantees = __data;\n\n\treturn count;\n}\n\nstatic ssize_t bfq_low_latency_store(struct elevator_queue *e,\n\t\t\t\t     const char *page, size_t count)\n{\n\tstruct bfq_data *bfqd = e->elevator_data;\n\tunsigned long __data;\n\tint ret;\n\n\tret = bfq_var_store(&__data, (page));\n\tif (ret)\n\t\treturn ret;\n\n\tif (__data > 1)\n\t\t__data = 1;\n\tif (__data == 0 && bfqd->low_latency != 0)\n\t\tbfq_end_wr(bfqd);\n\tbfqd->low_latency = __data;\n\n\treturn count;\n}\n\n#define BFQ_ATTR(name) \\\n\t__ATTR(name, 0644, bfq_##name##_show, bfq_##name##_store)\n\nstatic struct elv_fs_entry bfq_attrs[] = {\n\tBFQ_ATTR(fifo_expire_sync),\n\tBFQ_ATTR(fifo_expire_async),\n\tBFQ_ATTR(back_seek_max),\n\tBFQ_ATTR(back_seek_penalty),\n\tBFQ_ATTR(slice_idle),\n\tBFQ_ATTR(slice_idle_us),\n\tBFQ_ATTR(max_budget),\n\tBFQ_ATTR(timeout_sync),\n\tBFQ_ATTR(strict_guarantees),\n\tBFQ_ATTR(low_latency),\n\t__ATTR_NULL\n};\n\nstatic struct elevator_type iosched_bfq_mq = {\n\t.ops = {\n\t\t.limit_depth\t\t= bfq_limit_depth,\n\t\t.prepare_request\t= bfq_prepare_request,\n\t\t.requeue_request        = bfq_finish_requeue_request,\n\t\t.finish_request\t\t= bfq_finish_requeue_request,\n\t\t.exit_icq\t\t= bfq_exit_icq,\n\t\t.insert_requests\t= bfq_insert_requests,\n\t\t.dispatch_request\t= bfq_dispatch_request,\n\t\t.next_request\t\t= elv_rb_latter_request,\n\t\t.former_request\t\t= elv_rb_former_request,\n\t\t.allow_merge\t\t= bfq_allow_bio_merge,\n\t\t.bio_merge\t\t= bfq_bio_merge,\n\t\t.request_merge\t\t= bfq_request_merge,\n\t\t.requests_merged\t= bfq_requests_merged,\n\t\t.request_merged\t\t= bfq_request_merged,\n\t\t.has_work\t\t= bfq_has_work,\n\t\t.depth_updated\t\t= bfq_depth_updated,\n\t\t.init_hctx\t\t= bfq_init_hctx,\n\t\t.init_sched\t\t= bfq_init_queue,\n\t\t.exit_sched\t\t= bfq_exit_queue,\n\t},\n\n\t.icq_size =\t\tsizeof(struct bfq_io_cq),\n\t.icq_align =\t\t__alignof__(struct bfq_io_cq),\n\t.elevator_attrs =\tbfq_attrs,\n\t.elevator_name =\t\"bfq\",\n\t.elevator_owner =\tTHIS_MODULE,\n};\nMODULE_ALIAS(\"bfq-iosched\");\n\nstatic int __init bfq_init(void)\n{\n\tint ret;\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tret = blkcg_policy_register(&blkcg_policy_bfq);\n\tif (ret)\n\t\treturn ret;\n#endif\n\n\tret = -ENOMEM;\n\tif (bfq_slab_setup())\n\t\tgoto err_pol_unreg;\n\n\t/*\n\t * Times to load large popular applications for the typical\n\t * systems installed on the reference devices (see the\n\t * comments before the definition of the next\n\t * array). Actually, we use slightly lower values, as the\n\t * estimated peak rate tends to be smaller than the actual\n\t * peak rate.  The reason for this last fact is that estimates\n\t * are computed over much shorter time intervals than the long\n\t * intervals typically used for benchmarking. Why? First, to\n\t * adapt more quickly to variations. Second, because an I/O\n\t * scheduler cannot rely on a peak-rate-evaluation workload to\n\t * be run for a long time.\n\t */\n\tref_wr_duration[0] = msecs_to_jiffies(7000); /* actually 8 sec */\n\tref_wr_duration[1] = msecs_to_jiffies(2500); /* actually 3 sec */\n\n\tret = elv_register(&iosched_bfq_mq);\n\tif (ret)\n\t\tgoto slab_kill;\n\n\treturn 0;\n\nslab_kill:\n\tbfq_slab_kill();\nerr_pol_unreg:\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tblkcg_policy_unregister(&blkcg_policy_bfq);\n#endif\n\treturn ret;\n}\n\nstatic void __exit bfq_exit(void)\n{\n\telv_unregister(&iosched_bfq_mq);\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tblkcg_policy_unregister(&blkcg_policy_bfq);\n#endif\n\tbfq_slab_kill();\n}\n\nmodule_init(bfq_init);\nmodule_exit(bfq_exit);\n\nMODULE_AUTHOR(\"Paolo Valente\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MQ Budget Fair Queueing I/O Scheduler\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Budget Fair Queueing (BFQ) I/O scheduler.\n *\n * Based on ideas and code from CFQ:\n * Copyright (C) 2003 Jens Axboe <axboe@kernel.dk>\n *\n * Copyright (C) 2008 Fabio Checconi <fabio@gandalf.sssup.it>\n *\t\t      Paolo Valente <paolo.valente@unimore.it>\n *\n * Copyright (C) 2010 Paolo Valente <paolo.valente@unimore.it>\n *                    Arianna Avanzini <avanzini@google.com>\n *\n * Copyright (C) 2017 Paolo Valente <paolo.valente@linaro.org>\n *\n * BFQ is a proportional-share I/O scheduler, with some extra\n * low-latency capabilities. BFQ also supports full hierarchical\n * scheduling through cgroups. Next paragraphs provide an introduction\n * on BFQ inner workings. Details on BFQ benefits, usage and\n * limitations can be found in Documentation/block/bfq-iosched.rst.\n *\n * BFQ is a proportional-share storage-I/O scheduling algorithm based\n * on the slice-by-slice service scheme of CFQ. But BFQ assigns\n * budgets, measured in number of sectors, to processes instead of\n * time slices. The device is not granted to the in-service process\n * for a given time slice, but until it has exhausted its assigned\n * budget. This change from the time to the service domain enables BFQ\n * to distribute the device throughput among processes as desired,\n * without any distortion due to throughput fluctuations, or to device\n * internal queueing. BFQ uses an ad hoc internal scheduler, called\n * B-WF2Q+, to schedule processes according to their budgets. More\n * precisely, BFQ schedules queues associated with processes. Each\n * process/queue is assigned a user-configurable weight, and B-WF2Q+\n * guarantees that each queue receives a fraction of the throughput\n * proportional to its weight. Thanks to the accurate policy of\n * B-WF2Q+, BFQ can afford to assign high budgets to I/O-bound\n * processes issuing sequential requests (to boost the throughput),\n * and yet guarantee a low latency to interactive and soft real-time\n * applications.\n *\n * In particular, to provide these low-latency guarantees, BFQ\n * explicitly privileges the I/O of two classes of time-sensitive\n * applications: interactive and soft real-time. In more detail, BFQ\n * behaves this way if the low_latency parameter is set (default\n * configuration). This feature enables BFQ to provide applications in\n * these classes with a very low latency.\n *\n * To implement this feature, BFQ constantly tries to detect whether\n * the I/O requests in a bfq_queue come from an interactive or a soft\n * real-time application. For brevity, in these cases, the queue is\n * said to be interactive or soft real-time. In both cases, BFQ\n * privileges the service of the queue, over that of non-interactive\n * and non-soft-real-time queues. This privileging is performed,\n * mainly, by raising the weight of the queue. So, for brevity, we\n * call just weight-raising periods the time periods during which a\n * queue is privileged, because deemed interactive or soft real-time.\n *\n * The detection of soft real-time queues/applications is described in\n * detail in the comments on the function\n * bfq_bfqq_softrt_next_start. On the other hand, the detection of an\n * interactive queue works as follows: a queue is deemed interactive\n * if it is constantly non empty only for a limited time interval,\n * after which it does become empty. The queue may be deemed\n * interactive again (for a limited time), if it restarts being\n * constantly non empty, provided that this happens only after the\n * queue has remained empty for a given minimum idle time.\n *\n * By default, BFQ computes automatically the above maximum time\n * interval, i.e., the time interval after which a constantly\n * non-empty queue stops being deemed interactive. Since a queue is\n * weight-raised while it is deemed interactive, this maximum time\n * interval happens to coincide with the (maximum) duration of the\n * weight-raising for interactive queues.\n *\n * Finally, BFQ also features additional heuristics for\n * preserving both a low latency and a high throughput on NCQ-capable,\n * rotational or flash-based devices, and to get the job done quickly\n * for applications consisting in many I/O-bound processes.\n *\n * NOTE: if the main or only goal, with a given device, is to achieve\n * the maximum-possible throughput at all times, then do switch off\n * all low-latency heuristics for that device, by setting low_latency\n * to 0.\n *\n * BFQ is described in [1], where also a reference to the initial,\n * more theoretical paper on BFQ can be found. The interested reader\n * can find in the latter paper full details on the main algorithm, as\n * well as formulas of the guarantees and formal proofs of all the\n * properties.  With respect to the version of BFQ presented in these\n * papers, this implementation adds a few more heuristics, such as the\n * ones that guarantee a low latency to interactive and soft real-time\n * applications, and a hierarchical extension based on H-WF2Q+.\n *\n * B-WF2Q+ is based on WF2Q+, which is described in [2], together with\n * H-WF2Q+, while the augmented tree used here to implement B-WF2Q+\n * with O(log N) complexity derives from the one introduced with EEVDF\n * in [3].\n *\n * [1] P. Valente, A. Avanzini, \"Evolution of the BFQ Storage I/O\n *     Scheduler\", Proceedings of the First Workshop on Mobile System\n *     Technologies (MST-2015), May 2015.\n *     http://algogroup.unimore.it/people/paolo/disk_sched/mst-2015.pdf\n *\n * [2] Jon C.R. Bennett and H. Zhang, \"Hierarchical Packet Fair Queueing\n *     Algorithms\", IEEE/ACM Transactions on Networking, 5(5):675-689,\n *     Oct 1997.\n *\n * http://www.cs.cmu.edu/~hzhang/papers/TON-97-Oct.ps.gz\n *\n * [3] I. Stoica and H. Abdel-Wahab, \"Earliest Eligible Virtual Deadline\n *     First: A Flexible and Accurate Mechanism for Proportional Share\n *     Resource Allocation\", technical report.\n *\n * http://www.cs.berkeley.edu/~istoica/papers/eevdf-tr-95.pdf\n */\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/cgroup.h>\n#include <linux/elevator.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/ioprio.h>\n#include <linux/sbitmap.h>\n#include <linux/delay.h>\n\n#include \"blk.h\"\n#include \"blk-mq.h\"\n#include \"blk-mq-tag.h\"\n#include \"blk-mq-sched.h\"\n#include \"bfq-iosched.h\"\n#include \"blk-wbt.h\"\n\n#define BFQ_BFQQ_FNS(name)\t\t\t\t\t\t\\\nvoid bfq_mark_bfqq_##name(struct bfq_queue *bfqq)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t__set_bit(BFQQF_##name, &(bfqq)->flags);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nvoid bfq_clear_bfqq_##name(struct bfq_queue *bfqq)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t__clear_bit(BFQQF_##name, &(bfqq)->flags);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nint bfq_bfqq_##name(const struct bfq_queue *bfqq)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn test_bit(BFQQF_##name, &(bfqq)->flags);\t\t\\\n}\n\nBFQ_BFQQ_FNS(just_created);\nBFQ_BFQQ_FNS(busy);\nBFQ_BFQQ_FNS(wait_request);\nBFQ_BFQQ_FNS(non_blocking_wait_rq);\nBFQ_BFQQ_FNS(fifo_expire);\nBFQ_BFQQ_FNS(has_short_ttime);\nBFQ_BFQQ_FNS(sync);\nBFQ_BFQQ_FNS(IO_bound);\nBFQ_BFQQ_FNS(in_large_burst);\nBFQ_BFQQ_FNS(coop);\nBFQ_BFQQ_FNS(split_coop);\nBFQ_BFQQ_FNS(softrt_update);\nBFQ_BFQQ_FNS(has_waker);\n#undef BFQ_BFQQ_FNS\t\t\t\t\t\t\\\n\n/* Expiration time of sync (0) and async (1) requests, in ns. */\nstatic const u64 bfq_fifo_expire[2] = { NSEC_PER_SEC / 4, NSEC_PER_SEC / 8 };\n\n/* Maximum backwards seek (magic number lifted from CFQ), in KiB. */\nstatic const int bfq_back_max = 16 * 1024;\n\n/* Penalty of a backwards seek, in number of sectors. */\nstatic const int bfq_back_penalty = 2;\n\n/* Idling period duration, in ns. */\nstatic u64 bfq_slice_idle = NSEC_PER_SEC / 125;\n\n/* Minimum number of assigned budgets for which stats are safe to compute. */\nstatic const int bfq_stats_min_budgets = 194;\n\n/* Default maximum budget values, in sectors and number of requests. */\nstatic const int bfq_default_max_budget = 16 * 1024;\n\n/*\n * When a sync request is dispatched, the queue that contains that\n * request, and all the ancestor entities of that queue, are charged\n * with the number of sectors of the request. In contrast, if the\n * request is async, then the queue and its ancestor entities are\n * charged with the number of sectors of the request, multiplied by\n * the factor below. This throttles the bandwidth for async I/O,\n * w.r.t. to sync I/O, and it is done to counter the tendency of async\n * writes to steal I/O throughput to reads.\n *\n * The current value of this parameter is the result of a tuning with\n * several hardware and software configurations. We tried to find the\n * lowest value for which writes do not cause noticeable problems to\n * reads. In fact, the lower this parameter, the stabler I/O control,\n * in the following respect.  The lower this parameter is, the less\n * the bandwidth enjoyed by a group decreases\n * - when the group does writes, w.r.t. to when it does reads;\n * - when other groups do reads, w.r.t. to when they do writes.\n */\nstatic const int bfq_async_charge_factor = 3;\n\n/* Default timeout values, in jiffies, approximating CFQ defaults. */\nconst int bfq_timeout = HZ / 8;\n\n/*\n * Time limit for merging (see comments in bfq_setup_cooperator). Set\n * to the slowest value that, in our tests, proved to be effective in\n * removing false positives, while not causing true positives to miss\n * queue merging.\n *\n * As can be deduced from the low time limit below, queue merging, if\n * successful, happens at the very beginning of the I/O of the involved\n * cooperating processes, as a consequence of the arrival of the very\n * first requests from each cooperator.  After that, there is very\n * little chance to find cooperators.\n */\nstatic const unsigned long bfq_merge_time_limit = HZ/10;\n\nstatic struct kmem_cache *bfq_pool;\n\n/* Below this threshold (in ns), we consider thinktime immediate. */\n#define BFQ_MIN_TT\t\t(2 * NSEC_PER_MSEC)\n\n/* hw_tag detection: parallel requests threshold and min samples needed. */\n#define BFQ_HW_QUEUE_THRESHOLD\t3\n#define BFQ_HW_QUEUE_SAMPLES\t32\n\n#define BFQQ_SEEK_THR\t\t(sector_t)(8 * 100)\n#define BFQQ_SECT_THR_NONROT\t(sector_t)(2 * 32)\n#define BFQ_RQ_SEEKY(bfqd, last_pos, rq) \\\n\t(get_sdist(last_pos, rq) >\t\t\t\\\n\t BFQQ_SEEK_THR &&\t\t\t\t\\\n\t (!blk_queue_nonrot(bfqd->queue) ||\t\t\\\n\t  blk_rq_sectors(rq) < BFQQ_SECT_THR_NONROT))\n#define BFQQ_CLOSE_THR\t\t(sector_t)(8 * 1024)\n#define BFQQ_SEEKY(bfqq)\t(hweight32(bfqq->seek_history) > 19)\n/*\n * Sync random I/O is likely to be confused with soft real-time I/O,\n * because it is characterized by limited throughput and apparently\n * isochronous arrival pattern. To avoid false positives, queues\n * containing only random (seeky) I/O are prevented from being tagged\n * as soft real-time.\n */\n#define BFQQ_TOTALLY_SEEKY(bfqq)\t(bfqq->seek_history == -1)\n\n/* Min number of samples required to perform peak-rate update */\n#define BFQ_RATE_MIN_SAMPLES\t32\n/* Min observation time interval required to perform a peak-rate update (ns) */\n#define BFQ_RATE_MIN_INTERVAL\t(300*NSEC_PER_MSEC)\n/* Target observation time interval for a peak-rate update (ns) */\n#define BFQ_RATE_REF_INTERVAL\tNSEC_PER_SEC\n\n/*\n * Shift used for peak-rate fixed precision calculations.\n * With\n * - the current shift: 16 positions\n * - the current type used to store rate: u32\n * - the current unit of measure for rate: [sectors/usec], or, more precisely,\n *   [(sectors/usec) / 2^BFQ_RATE_SHIFT] to take into account the shift,\n * the range of rates that can be stored is\n * [1 / 2^BFQ_RATE_SHIFT, 2^(32 - BFQ_RATE_SHIFT)] sectors/usec =\n * [1 / 2^16, 2^16] sectors/usec = [15e-6, 65536] sectors/usec =\n * [15, 65G] sectors/sec\n * Which, assuming a sector size of 512B, corresponds to a range of\n * [7.5K, 33T] B/sec\n */\n#define BFQ_RATE_SHIFT\t\t16\n\n/*\n * When configured for computing the duration of the weight-raising\n * for interactive queues automatically (see the comments at the\n * beginning of this file), BFQ does it using the following formula:\n * duration = (ref_rate / r) * ref_wr_duration,\n * where r is the peak rate of the device, and ref_rate and\n * ref_wr_duration are two reference parameters.  In particular,\n * ref_rate is the peak rate of the reference storage device (see\n * below), and ref_wr_duration is about the maximum time needed, with\n * BFQ and while reading two files in parallel, to load typical large\n * applications on the reference device (see the comments on\n * max_service_from_wr below, for more details on how ref_wr_duration\n * is obtained).  In practice, the slower/faster the device at hand\n * is, the more/less it takes to load applications with respect to the\n * reference device.  Accordingly, the longer/shorter BFQ grants\n * weight raising to interactive applications.\n *\n * BFQ uses two different reference pairs (ref_rate, ref_wr_duration),\n * depending on whether the device is rotational or non-rotational.\n *\n * In the following definitions, ref_rate[0] and ref_wr_duration[0]\n * are the reference values for a rotational device, whereas\n * ref_rate[1] and ref_wr_duration[1] are the reference values for a\n * non-rotational device. The reference rates are not the actual peak\n * rates of the devices used as a reference, but slightly lower\n * values. The reason for using slightly lower values is that the\n * peak-rate estimator tends to yield slightly lower values than the\n * actual peak rate (it can yield the actual peak rate only if there\n * is only one process doing I/O, and the process does sequential\n * I/O).\n *\n * The reference peak rates are measured in sectors/usec, left-shifted\n * by BFQ_RATE_SHIFT.\n */\nstatic int ref_rate[2] = {14000, 33000};\n/*\n * To improve readability, a conversion function is used to initialize\n * the following array, which entails that the array can be\n * initialized only in a function.\n */\nstatic int ref_wr_duration[2];\n\n/*\n * BFQ uses the above-detailed, time-based weight-raising mechanism to\n * privilege interactive tasks. This mechanism is vulnerable to the\n * following false positives: I/O-bound applications that will go on\n * doing I/O for much longer than the duration of weight\n * raising. These applications have basically no benefit from being\n * weight-raised at the beginning of their I/O. On the opposite end,\n * while being weight-raised, these applications\n * a) unjustly steal throughput to applications that may actually need\n * low latency;\n * b) make BFQ uselessly perform device idling; device idling results\n * in loss of device throughput with most flash-based storage, and may\n * increase latencies when used purposelessly.\n *\n * BFQ tries to reduce these problems, by adopting the following\n * countermeasure. To introduce this countermeasure, we need first to\n * finish explaining how the duration of weight-raising for\n * interactive tasks is computed.\n *\n * For a bfq_queue deemed as interactive, the duration of weight\n * raising is dynamically adjusted, as a function of the estimated\n * peak rate of the device, so as to be equal to the time needed to\n * execute the 'largest' interactive task we benchmarked so far. By\n * largest task, we mean the task for which each involved process has\n * to do more I/O than for any of the other tasks we benchmarked. This\n * reference interactive task is the start-up of LibreOffice Writer,\n * and in this task each process/bfq_queue needs to have at most ~110K\n * sectors transferred.\n *\n * This last piece of information enables BFQ to reduce the actual\n * duration of weight-raising for at least one class of I/O-bound\n * applications: those doing sequential or quasi-sequential I/O. An\n * example is file copy. In fact, once started, the main I/O-bound\n * processes of these applications usually consume the above 110K\n * sectors in much less time than the processes of an application that\n * is starting, because these I/O-bound processes will greedily devote\n * almost all their CPU cycles only to their target,\n * throughput-friendly I/O operations. This is even more true if BFQ\n * happens to be underestimating the device peak rate, and thus\n * overestimating the duration of weight raising. But, according to\n * our measurements, once transferred 110K sectors, these processes\n * have no right to be weight-raised any longer.\n *\n * Basing on the last consideration, BFQ ends weight-raising for a\n * bfq_queue if the latter happens to have received an amount of\n * service at least equal to the following constant. The constant is\n * set to slightly more than 110K, to have a minimum safety margin.\n *\n * This early ending of weight-raising reduces the amount of time\n * during which interactive false positives cause the two problems\n * described at the beginning of these comments.\n */\nstatic const unsigned long max_service_from_wr = 120000;\n\n#define RQ_BIC(rq)\t\ticq_to_bic((rq)->elv.priv[0])\n#define RQ_BFQQ(rq)\t\t((rq)->elv.priv[1])\n\nstruct bfq_queue *bic_to_bfqq(struct bfq_io_cq *bic, bool is_sync)\n{\n\treturn bic->bfqq[is_sync];\n}\n\nvoid bic_set_bfqq(struct bfq_io_cq *bic, struct bfq_queue *bfqq, bool is_sync)\n{\n\tbic->bfqq[is_sync] = bfqq;\n}\n\nstruct bfq_data *bic_to_bfqd(struct bfq_io_cq *bic)\n{\n\treturn bic->icq.q->elevator->elevator_data;\n}\n\n/**\n * icq_to_bic - convert iocontext queue structure to bfq_io_cq.\n * @icq: the iocontext queue.\n */\nstatic struct bfq_io_cq *icq_to_bic(struct io_cq *icq)\n{\n\t/* bic->icq is the first member, %NULL will convert to %NULL */\n\treturn container_of(icq, struct bfq_io_cq, icq);\n}\n\n/**\n * bfq_bic_lookup - search into @ioc a bic associated to @bfqd.\n * @bfqd: the lookup key.\n * @ioc: the io_context of the process doing I/O.\n * @q: the request queue.\n */\nstatic struct bfq_io_cq *bfq_bic_lookup(struct bfq_data *bfqd,\n\t\t\t\t\tstruct io_context *ioc,\n\t\t\t\t\tstruct request_queue *q)\n{\n\tif (ioc) {\n\t\tunsigned long flags;\n\t\tstruct bfq_io_cq *icq;\n\n\t\tspin_lock_irqsave(&q->queue_lock, flags);\n\t\ticq = icq_to_bic(ioc_lookup_icq(ioc, q));\n\t\tspin_unlock_irqrestore(&q->queue_lock, flags);\n\n\t\treturn icq;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Scheduler run of queue, if there are requests pending and no one in the\n * driver that will restart queueing.\n */\nvoid bfq_schedule_dispatch(struct bfq_data *bfqd)\n{\n\tif (bfqd->queued != 0) {\n\t\tbfq_log(bfqd, \"schedule dispatch\");\n\t\tblk_mq_run_hw_queues(bfqd->queue, true);\n\t}\n}\n\n#define bfq_class_idle(bfqq)\t((bfqq)->ioprio_class == IOPRIO_CLASS_IDLE)\n\n#define bfq_sample_valid(samples)\t((samples) > 80)\n\n/*\n * Lifted from AS - choose which of rq1 and rq2 that is best served now.\n * We choose the request that is closer to the head right now.  Distance\n * behind the head is penalized and only allowed to a certain extent.\n */\nstatic struct request *bfq_choose_req(struct bfq_data *bfqd,\n\t\t\t\t      struct request *rq1,\n\t\t\t\t      struct request *rq2,\n\t\t\t\t      sector_t last)\n{\n\tsector_t s1, s2, d1 = 0, d2 = 0;\n\tunsigned long back_max;\n#define BFQ_RQ1_WRAP\t0x01 /* request 1 wraps */\n#define BFQ_RQ2_WRAP\t0x02 /* request 2 wraps */\n\tunsigned int wrap = 0; /* bit mask: requests behind the disk head? */\n\n\tif (!rq1 || rq1 == rq2)\n\t\treturn rq2;\n\tif (!rq2)\n\t\treturn rq1;\n\n\tif (rq_is_sync(rq1) && !rq_is_sync(rq2))\n\t\treturn rq1;\n\telse if (rq_is_sync(rq2) && !rq_is_sync(rq1))\n\t\treturn rq2;\n\tif ((rq1->cmd_flags & REQ_META) && !(rq2->cmd_flags & REQ_META))\n\t\treturn rq1;\n\telse if ((rq2->cmd_flags & REQ_META) && !(rq1->cmd_flags & REQ_META))\n\t\treturn rq2;\n\n\ts1 = blk_rq_pos(rq1);\n\ts2 = blk_rq_pos(rq2);\n\n\t/*\n\t * By definition, 1KiB is 2 sectors.\n\t */\n\tback_max = bfqd->bfq_back_max * 2;\n\n\t/*\n\t * Strict one way elevator _except_ in the case where we allow\n\t * short backward seeks which are biased as twice the cost of a\n\t * similar forward seek.\n\t */\n\tif (s1 >= last)\n\t\td1 = s1 - last;\n\telse if (s1 + back_max >= last)\n\t\td1 = (last - s1) * bfqd->bfq_back_penalty;\n\telse\n\t\twrap |= BFQ_RQ1_WRAP;\n\n\tif (s2 >= last)\n\t\td2 = s2 - last;\n\telse if (s2 + back_max >= last)\n\t\td2 = (last - s2) * bfqd->bfq_back_penalty;\n\telse\n\t\twrap |= BFQ_RQ2_WRAP;\n\n\t/* Found required data */\n\n\t/*\n\t * By doing switch() on the bit mask \"wrap\" we avoid having to\n\t * check two variables for all permutations: --> faster!\n\t */\n\tswitch (wrap) {\n\tcase 0: /* common case for CFQ: rq1 and rq2 not wrapped */\n\t\tif (d1 < d2)\n\t\t\treturn rq1;\n\t\telse if (d2 < d1)\n\t\t\treturn rq2;\n\n\t\tif (s1 >= s2)\n\t\t\treturn rq1;\n\t\telse\n\t\t\treturn rq2;\n\n\tcase BFQ_RQ2_WRAP:\n\t\treturn rq1;\n\tcase BFQ_RQ1_WRAP:\n\t\treturn rq2;\n\tcase BFQ_RQ1_WRAP|BFQ_RQ2_WRAP: /* both rqs wrapped */\n\tdefault:\n\t\t/*\n\t\t * Since both rqs are wrapped,\n\t\t * start with the one that's further behind head\n\t\t * (--> only *one* back seek required),\n\t\t * since back seek takes more time than forward.\n\t\t */\n\t\tif (s1 <= s2)\n\t\t\treturn rq1;\n\t\telse\n\t\t\treturn rq2;\n\t}\n}\n\n/*\n * Async I/O can easily starve sync I/O (both sync reads and sync\n * writes), by consuming all tags. Similarly, storms of sync writes,\n * such as those that sync(2) may trigger, can starve sync reads.\n * Limit depths of async I/O and sync writes so as to counter both\n * problems.\n */\nstatic void bfq_limit_depth(unsigned int op, struct blk_mq_alloc_data *data)\n{\n\tstruct bfq_data *bfqd = data->q->elevator->elevator_data;\n\n\tif (op_is_sync(op) && !op_is_write(op))\n\t\treturn;\n\n\tdata->shallow_depth =\n\t\tbfqd->word_depths[!!bfqd->wr_busy_queues][op_is_sync(op)];\n\n\tbfq_log(bfqd, \"[%s] wr_busy %d sync %d depth %u\",\n\t\t\t__func__, bfqd->wr_busy_queues, op_is_sync(op),\n\t\t\tdata->shallow_depth);\n}\n\nstatic struct bfq_queue *\nbfq_rq_pos_tree_lookup(struct bfq_data *bfqd, struct rb_root *root,\n\t\t     sector_t sector, struct rb_node **ret_parent,\n\t\t     struct rb_node ***rb_link)\n{\n\tstruct rb_node **p, *parent;\n\tstruct bfq_queue *bfqq = NULL;\n\n\tparent = NULL;\n\tp = &root->rb_node;\n\twhile (*p) {\n\t\tstruct rb_node **n;\n\n\t\tparent = *p;\n\t\tbfqq = rb_entry(parent, struct bfq_queue, pos_node);\n\n\t\t/*\n\t\t * Sort strictly based on sector. Smallest to the left,\n\t\t * largest to the right.\n\t\t */\n\t\tif (sector > blk_rq_pos(bfqq->next_rq))\n\t\t\tn = &(*p)->rb_right;\n\t\telse if (sector < blk_rq_pos(bfqq->next_rq))\n\t\t\tn = &(*p)->rb_left;\n\t\telse\n\t\t\tbreak;\n\t\tp = n;\n\t\tbfqq = NULL;\n\t}\n\n\t*ret_parent = parent;\n\tif (rb_link)\n\t\t*rb_link = p;\n\n\tbfq_log(bfqd, \"rq_pos_tree_lookup %llu: returning %d\",\n\t\t(unsigned long long)sector,\n\t\tbfqq ? bfqq->pid : 0);\n\n\treturn bfqq;\n}\n\nstatic bool bfq_too_late_for_merging(struct bfq_queue *bfqq)\n{\n\treturn bfqq->service_from_backlogged > 0 &&\n\t\ttime_is_before_jiffies(bfqq->first_IO_time +\n\t\t\t\t       bfq_merge_time_limit);\n}\n\n/*\n * The following function is not marked as __cold because it is\n * actually cold, but for the same performance goal described in the\n * comments on the likely() at the beginning of\n * bfq_setup_cooperator(). Unexpectedly, to reach an even lower\n * execution time for the case where this function is not invoked, we\n * had to add an unlikely() in each involved if().\n */\nvoid __cold\nbfq_pos_tree_add_move(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tstruct rb_node **p, *parent;\n\tstruct bfq_queue *__bfqq;\n\n\tif (bfqq->pos_root) {\n\t\trb_erase(&bfqq->pos_node, bfqq->pos_root);\n\t\tbfqq->pos_root = NULL;\n\t}\n\n\t/* oom_bfqq does not participate in queue merging */\n\tif (bfqq == &bfqd->oom_bfqq)\n\t\treturn;\n\n\t/*\n\t * bfqq cannot be merged any longer (see comments in\n\t * bfq_setup_cooperator): no point in adding bfqq into the\n\t * position tree.\n\t */\n\tif (bfq_too_late_for_merging(bfqq))\n\t\treturn;\n\n\tif (bfq_class_idle(bfqq))\n\t\treturn;\n\tif (!bfqq->next_rq)\n\t\treturn;\n\n\tbfqq->pos_root = &bfq_bfqq_to_bfqg(bfqq)->rq_pos_tree;\n\t__bfqq = bfq_rq_pos_tree_lookup(bfqd, bfqq->pos_root,\n\t\t\tblk_rq_pos(bfqq->next_rq), &parent, &p);\n\tif (!__bfqq) {\n\t\trb_link_node(&bfqq->pos_node, parent, p);\n\t\trb_insert_color(&bfqq->pos_node, bfqq->pos_root);\n\t} else\n\t\tbfqq->pos_root = NULL;\n}\n\n/*\n * The following function returns false either if every active queue\n * must receive the same share of the throughput (symmetric scenario),\n * or, as a special case, if bfqq must receive a share of the\n * throughput lower than or equal to the share that every other active\n * queue must receive.  If bfqq does sync I/O, then these are the only\n * two cases where bfqq happens to be guaranteed its share of the\n * throughput even if I/O dispatching is not plugged when bfqq remains\n * temporarily empty (for more details, see the comments in the\n * function bfq_better_to_idle()). For this reason, the return value\n * of this function is used to check whether I/O-dispatch plugging can\n * be avoided.\n *\n * The above first case (symmetric scenario) occurs when:\n * 1) all active queues have the same weight,\n * 2) all active queues belong to the same I/O-priority class,\n * 3) all active groups at the same level in the groups tree have the same\n *    weight,\n * 4) all active groups at the same level in the groups tree have the same\n *    number of children.\n *\n * Unfortunately, keeping the necessary state for evaluating exactly\n * the last two symmetry sub-conditions above would be quite complex\n * and time consuming. Therefore this function evaluates, instead,\n * only the following stronger three sub-conditions, for which it is\n * much easier to maintain the needed state:\n * 1) all active queues have the same weight,\n * 2) all active queues belong to the same I/O-priority class,\n * 3) there are no active groups.\n * In particular, the last condition is always true if hierarchical\n * support or the cgroups interface are not enabled, thus no state\n * needs to be maintained in this case.\n */\nstatic bool bfq_asymmetric_scenario(struct bfq_data *bfqd,\n\t\t\t\t   struct bfq_queue *bfqq)\n{\n\tbool smallest_weight = bfqq &&\n\t\tbfqq->weight_counter &&\n\t\tbfqq->weight_counter ==\n\t\tcontainer_of(\n\t\t\trb_first_cached(&bfqd->queue_weights_tree),\n\t\t\tstruct bfq_weight_counter,\n\t\t\tweights_node);\n\n\t/*\n\t * For queue weights to differ, queue_weights_tree must contain\n\t * at least two nodes.\n\t */\n\tbool varied_queue_weights = !smallest_weight &&\n\t\t!RB_EMPTY_ROOT(&bfqd->queue_weights_tree.rb_root) &&\n\t\t(bfqd->queue_weights_tree.rb_root.rb_node->rb_left ||\n\t\t bfqd->queue_weights_tree.rb_root.rb_node->rb_right);\n\n\tbool multiple_classes_busy =\n\t\t(bfqd->busy_queues[0] && bfqd->busy_queues[1]) ||\n\t\t(bfqd->busy_queues[0] && bfqd->busy_queues[2]) ||\n\t\t(bfqd->busy_queues[1] && bfqd->busy_queues[2]);\n\n\treturn varied_queue_weights || multiple_classes_busy\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\t       || bfqd->num_groups_with_pending_reqs > 0\n#endif\n\t\t;\n}\n\n/*\n * If the weight-counter tree passed as input contains no counter for\n * the weight of the input queue, then add that counter; otherwise just\n * increment the existing counter.\n *\n * Note that weight-counter trees contain few nodes in mostly symmetric\n * scenarios. For example, if all queues have the same weight, then the\n * weight-counter tree for the queues may contain at most one node.\n * This holds even if low_latency is on, because weight-raised queues\n * are not inserted in the tree.\n * In most scenarios, the rate at which nodes are created/destroyed\n * should be low too.\n */\nvoid bfq_weights_tree_add(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t  struct rb_root_cached *root)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\tstruct rb_node **new = &(root->rb_root.rb_node), *parent = NULL;\n\tbool leftmost = true;\n\n\t/*\n\t * Do not insert if the queue is already associated with a\n\t * counter, which happens if:\n\t *   1) a request arrival has caused the queue to become both\n\t *      non-weight-raised, and hence change its weight, and\n\t *      backlogged; in this respect, each of the two events\n\t *      causes an invocation of this function,\n\t *   2) this is the invocation of this function caused by the\n\t *      second event. This second invocation is actually useless,\n\t *      and we handle this fact by exiting immediately. More\n\t *      efficient or clearer solutions might possibly be adopted.\n\t */\n\tif (bfqq->weight_counter)\n\t\treturn;\n\n\twhile (*new) {\n\t\tstruct bfq_weight_counter *__counter = container_of(*new,\n\t\t\t\t\t\tstruct bfq_weight_counter,\n\t\t\t\t\t\tweights_node);\n\t\tparent = *new;\n\n\t\tif (entity->weight == __counter->weight) {\n\t\t\tbfqq->weight_counter = __counter;\n\t\t\tgoto inc_counter;\n\t\t}\n\t\tif (entity->weight < __counter->weight)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse {\n\t\t\tnew = &((*new)->rb_right);\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\tbfqq->weight_counter = kzalloc(sizeof(struct bfq_weight_counter),\n\t\t\t\t       GFP_ATOMIC);\n\n\t/*\n\t * In the unlucky event of an allocation failure, we just\n\t * exit. This will cause the weight of queue to not be\n\t * considered in bfq_asymmetric_scenario, which, in its turn,\n\t * causes the scenario to be deemed wrongly symmetric in case\n\t * bfqq's weight would have been the only weight making the\n\t * scenario asymmetric.  On the bright side, no unbalance will\n\t * however occur when bfqq becomes inactive again (the\n\t * invocation of this function is triggered by an activation\n\t * of queue).  In fact, bfq_weights_tree_remove does nothing\n\t * if !bfqq->weight_counter.\n\t */\n\tif (unlikely(!bfqq->weight_counter))\n\t\treturn;\n\n\tbfqq->weight_counter->weight = entity->weight;\n\trb_link_node(&bfqq->weight_counter->weights_node, parent, new);\n\trb_insert_color_cached(&bfqq->weight_counter->weights_node, root,\n\t\t\t\tleftmost);\n\ninc_counter:\n\tbfqq->weight_counter->num_active++;\n\tbfqq->ref++;\n}\n\n/*\n * Decrement the weight counter associated with the queue, and, if the\n * counter reaches 0, remove the counter from the tree.\n * See the comments to the function bfq_weights_tree_add() for considerations\n * about overhead.\n */\nvoid __bfq_weights_tree_remove(struct bfq_data *bfqd,\n\t\t\t       struct bfq_queue *bfqq,\n\t\t\t       struct rb_root_cached *root)\n{\n\tif (!bfqq->weight_counter)\n\t\treturn;\n\n\tbfqq->weight_counter->num_active--;\n\tif (bfqq->weight_counter->num_active > 0)\n\t\tgoto reset_entity_pointer;\n\n\trb_erase_cached(&bfqq->weight_counter->weights_node, root);\n\tkfree(bfqq->weight_counter);\n\nreset_entity_pointer:\n\tbfqq->weight_counter = NULL;\n\tbfq_put_queue(bfqq);\n}\n\n/*\n * Invoke __bfq_weights_tree_remove on bfqq and decrement the number\n * of active groups for each queue's inactive parent entity.\n */\nvoid bfq_weights_tree_remove(struct bfq_data *bfqd,\n\t\t\t     struct bfq_queue *bfqq)\n{\n\tstruct bfq_entity *entity = bfqq->entity.parent;\n\n\tfor_each_entity(entity) {\n\t\tstruct bfq_sched_data *sd = entity->my_sched_data;\n\n\t\tif (sd->next_in_service || sd->in_service_entity) {\n\t\t\t/*\n\t\t\t * entity is still active, because either\n\t\t\t * next_in_service or in_service_entity is not\n\t\t\t * NULL (see the comments on the definition of\n\t\t\t * next_in_service for details on why\n\t\t\t * in_service_entity must be checked too).\n\t\t\t *\n\t\t\t * As a consequence, its parent entities are\n\t\t\t * active as well, and thus this loop must\n\t\t\t * stop here.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The decrement of num_groups_with_pending_reqs is\n\t\t * not performed immediately upon the deactivation of\n\t\t * entity, but it is delayed to when it also happens\n\t\t * that the first leaf descendant bfqq of entity gets\n\t\t * all its pending requests completed. The following\n\t\t * instructions perform this delayed decrement, if\n\t\t * needed. See the comments on\n\t\t * num_groups_with_pending_reqs for details.\n\t\t */\n\t\tif (entity->in_groups_with_pending_reqs) {\n\t\t\tentity->in_groups_with_pending_reqs = false;\n\t\t\tbfqd->num_groups_with_pending_reqs--;\n\t\t}\n\t}\n\n\t/*\n\t * Next function is invoked last, because it causes bfqq to be\n\t * freed if the following holds: bfqq is not in service and\n\t * has no dispatched request. DO NOT use bfqq after the next\n\t * function invocation.\n\t */\n\t__bfq_weights_tree_remove(bfqd, bfqq,\n\t\t\t\t  &bfqd->queue_weights_tree);\n}\n\n/*\n * Return expired entry, or NULL to just start from scratch in rbtree.\n */\nstatic struct request *bfq_check_fifo(struct bfq_queue *bfqq,\n\t\t\t\t      struct request *last)\n{\n\tstruct request *rq;\n\n\tif (bfq_bfqq_fifo_expire(bfqq))\n\t\treturn NULL;\n\n\tbfq_mark_bfqq_fifo_expire(bfqq);\n\n\trq = rq_entry_fifo(bfqq->fifo.next);\n\n\tif (rq == last || ktime_get_ns() < rq->fifo_time)\n\t\treturn NULL;\n\n\tbfq_log_bfqq(bfqq->bfqd, bfqq, \"check_fifo: returned %p\", rq);\n\treturn rq;\n}\n\nstatic struct request *bfq_find_next_rq(struct bfq_data *bfqd,\n\t\t\t\t\tstruct bfq_queue *bfqq,\n\t\t\t\t\tstruct request *last)\n{\n\tstruct rb_node *rbnext = rb_next(&last->rb_node);\n\tstruct rb_node *rbprev = rb_prev(&last->rb_node);\n\tstruct request *next, *prev = NULL;\n\n\t/* Follow expired path, else get first next available. */\n\tnext = bfq_check_fifo(bfqq, last);\n\tif (next)\n\t\treturn next;\n\n\tif (rbprev)\n\t\tprev = rb_entry_rq(rbprev);\n\n\tif (rbnext)\n\t\tnext = rb_entry_rq(rbnext);\n\telse {\n\t\trbnext = rb_first(&bfqq->sort_list);\n\t\tif (rbnext && rbnext != &last->rb_node)\n\t\t\tnext = rb_entry_rq(rbnext);\n\t}\n\n\treturn bfq_choose_req(bfqd, next, prev, blk_rq_pos(last));\n}\n\n/* see the definition of bfq_async_charge_factor for details */\nstatic unsigned long bfq_serv_to_charge(struct request *rq,\n\t\t\t\t\tstruct bfq_queue *bfqq)\n{\n\tif (bfq_bfqq_sync(bfqq) || bfqq->wr_coeff > 1 ||\n\t    bfq_asymmetric_scenario(bfqq->bfqd, bfqq))\n\t\treturn blk_rq_sectors(rq);\n\n\treturn blk_rq_sectors(rq) * bfq_async_charge_factor;\n}\n\n/**\n * bfq_updated_next_req - update the queue after a new next_rq selection.\n * @bfqd: the device data the queue belongs to.\n * @bfqq: the queue to update.\n *\n * If the first request of a queue changes we make sure that the queue\n * has enough budget to serve at least its first request (if the\n * request has grown).  We do this because if the queue has not enough\n * budget for its first request, it has to go through two dispatch\n * rounds to actually get it dispatched.\n */\nstatic void bfq_updated_next_req(struct bfq_data *bfqd,\n\t\t\t\t struct bfq_queue *bfqq)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\tstruct request *next_rq = bfqq->next_rq;\n\tunsigned long new_budget;\n\n\tif (!next_rq)\n\t\treturn;\n\n\tif (bfqq == bfqd->in_service_queue)\n\t\t/*\n\t\t * In order not to break guarantees, budgets cannot be\n\t\t * changed after an entity has been selected.\n\t\t */\n\t\treturn;\n\n\tnew_budget = max_t(unsigned long,\n\t\t\t   max_t(unsigned long, bfqq->max_budget,\n\t\t\t\t bfq_serv_to_charge(next_rq, bfqq)),\n\t\t\t   entity->service);\n\tif (entity->budget != new_budget) {\n\t\tentity->budget = new_budget;\n\t\tbfq_log_bfqq(bfqd, bfqq, \"updated next rq: new budget %lu\",\n\t\t\t\t\t new_budget);\n\t\tbfq_requeue_bfqq(bfqd, bfqq, false);\n\t}\n}\n\nstatic unsigned int bfq_wr_duration(struct bfq_data *bfqd)\n{\n\tu64 dur;\n\n\tif (bfqd->bfq_wr_max_time > 0)\n\t\treturn bfqd->bfq_wr_max_time;\n\n\tdur = bfqd->rate_dur_prod;\n\tdo_div(dur, bfqd->peak_rate);\n\n\t/*\n\t * Limit duration between 3 and 25 seconds. The upper limit\n\t * has been conservatively set after the following worst case:\n\t * on a QEMU/KVM virtual machine\n\t * - running in a slow PC\n\t * - with a virtual disk stacked on a slow low-end 5400rpm HDD\n\t * - serving a heavy I/O workload, such as the sequential reading\n\t *   of several files\n\t * mplayer took 23 seconds to start, if constantly weight-raised.\n\t *\n\t * As for higher values than that accommodating the above bad\n\t * scenario, tests show that higher values would often yield\n\t * the opposite of the desired result, i.e., would worsen\n\t * responsiveness by allowing non-interactive applications to\n\t * preserve weight raising for too long.\n\t *\n\t * On the other end, lower values than 3 seconds make it\n\t * difficult for most interactive tasks to complete their jobs\n\t * before weight-raising finishes.\n\t */\n\treturn clamp_val(dur, msecs_to_jiffies(3000), msecs_to_jiffies(25000));\n}\n\n/* switch back from soft real-time to interactive weight raising */\nstatic void switch_back_to_interactive_wr(struct bfq_queue *bfqq,\n\t\t\t\t\t  struct bfq_data *bfqd)\n{\n\tbfqq->wr_coeff = bfqd->bfq_wr_coeff;\n\tbfqq->wr_cur_max_time = bfq_wr_duration(bfqd);\n\tbfqq->last_wr_start_finish = bfqq->wr_start_at_switch_to_srt;\n}\n\nstatic void\nbfq_bfqq_resume_state(struct bfq_queue *bfqq, struct bfq_data *bfqd,\n\t\t      struct bfq_io_cq *bic, bool bfq_already_existing)\n{\n\tunsigned int old_wr_coeff = bfqq->wr_coeff;\n\tbool busy = bfq_already_existing && bfq_bfqq_busy(bfqq);\n\n\tif (bic->saved_has_short_ttime)\n\t\tbfq_mark_bfqq_has_short_ttime(bfqq);\n\telse\n\t\tbfq_clear_bfqq_has_short_ttime(bfqq);\n\n\tif (bic->saved_IO_bound)\n\t\tbfq_mark_bfqq_IO_bound(bfqq);\n\telse\n\t\tbfq_clear_bfqq_IO_bound(bfqq);\n\n\tbfqq->entity.new_weight = bic->saved_weight;\n\tbfqq->ttime = bic->saved_ttime;\n\tbfqq->wr_coeff = bic->saved_wr_coeff;\n\tbfqq->wr_start_at_switch_to_srt = bic->saved_wr_start_at_switch_to_srt;\n\tbfqq->last_wr_start_finish = bic->saved_last_wr_start_finish;\n\tbfqq->wr_cur_max_time = bic->saved_wr_cur_max_time;\n\n\tif (bfqq->wr_coeff > 1 && (bfq_bfqq_in_large_burst(bfqq) ||\n\t    time_is_before_jiffies(bfqq->last_wr_start_finish +\n\t\t\t\t   bfqq->wr_cur_max_time))) {\n\t\tif (bfqq->wr_cur_max_time == bfqd->bfq_wr_rt_max_time &&\n\t\t    !bfq_bfqq_in_large_burst(bfqq) &&\n\t\t    time_is_after_eq_jiffies(bfqq->wr_start_at_switch_to_srt +\n\t\t\t\t\t     bfq_wr_duration(bfqd))) {\n\t\t\tswitch_back_to_interactive_wr(bfqq, bfqd);\n\t\t} else {\n\t\t\tbfqq->wr_coeff = 1;\n\t\t\tbfq_log_bfqq(bfqq->bfqd, bfqq,\n\t\t\t\t     \"resume state: switching off wr\");\n\t\t}\n\t}\n\n\t/* make sure weight will be updated, however we got here */\n\tbfqq->entity.prio_changed = 1;\n\n\tif (likely(!busy))\n\t\treturn;\n\n\tif (old_wr_coeff == 1 && bfqq->wr_coeff > 1)\n\t\tbfqd->wr_busy_queues++;\n\telse if (old_wr_coeff > 1 && bfqq->wr_coeff == 1)\n\t\tbfqd->wr_busy_queues--;\n}\n\nstatic int bfqq_process_refs(struct bfq_queue *bfqq)\n{\n\treturn bfqq->ref - bfqq->allocated - bfqq->entity.on_st_or_in_serv -\n\t\t(bfqq->weight_counter != NULL);\n}\n\n/* Empty burst list and add just bfqq (see comments on bfq_handle_burst) */\nstatic void bfq_reset_burst_list(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tstruct bfq_queue *item;\n\tstruct hlist_node *n;\n\n\thlist_for_each_entry_safe(item, n, &bfqd->burst_list, burst_list_node)\n\t\thlist_del_init(&item->burst_list_node);\n\n\t/*\n\t * Start the creation of a new burst list only if there is no\n\t * active queue. See comments on the conditional invocation of\n\t * bfq_handle_burst().\n\t */\n\tif (bfq_tot_busy_queues(bfqd) == 0) {\n\t\thlist_add_head(&bfqq->burst_list_node, &bfqd->burst_list);\n\t\tbfqd->burst_size = 1;\n\t} else\n\t\tbfqd->burst_size = 0;\n\n\tbfqd->burst_parent_entity = bfqq->entity.parent;\n}\n\n/* Add bfqq to the list of queues in current burst (see bfq_handle_burst) */\nstatic void bfq_add_to_burst(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\t/* Increment burst size to take into account also bfqq */\n\tbfqd->burst_size++;\n\n\tif (bfqd->burst_size == bfqd->bfq_large_burst_thresh) {\n\t\tstruct bfq_queue *pos, *bfqq_item;\n\t\tstruct hlist_node *n;\n\n\t\t/*\n\t\t * Enough queues have been activated shortly after each\n\t\t * other to consider this burst as large.\n\t\t */\n\t\tbfqd->large_burst = true;\n\n\t\t/*\n\t\t * We can now mark all queues in the burst list as\n\t\t * belonging to a large burst.\n\t\t */\n\t\thlist_for_each_entry(bfqq_item, &bfqd->burst_list,\n\t\t\t\t     burst_list_node)\n\t\t\tbfq_mark_bfqq_in_large_burst(bfqq_item);\n\t\tbfq_mark_bfqq_in_large_burst(bfqq);\n\n\t\t/*\n\t\t * From now on, and until the current burst finishes, any\n\t\t * new queue being activated shortly after the last queue\n\t\t * was inserted in the burst can be immediately marked as\n\t\t * belonging to a large burst. So the burst list is not\n\t\t * needed any more. Remove it.\n\t\t */\n\t\thlist_for_each_entry_safe(pos, n, &bfqd->burst_list,\n\t\t\t\t\t  burst_list_node)\n\t\t\thlist_del_init(&pos->burst_list_node);\n\t} else /*\n\t\t* Burst not yet large: add bfqq to the burst list. Do\n\t\t* not increment the ref counter for bfqq, because bfqq\n\t\t* is removed from the burst list before freeing bfqq\n\t\t* in put_queue.\n\t\t*/\n\t\thlist_add_head(&bfqq->burst_list_node, &bfqd->burst_list);\n}\n\n/*\n * If many queues belonging to the same group happen to be created\n * shortly after each other, then the processes associated with these\n * queues have typically a common goal. In particular, bursts of queue\n * creations are usually caused by services or applications that spawn\n * many parallel threads/processes. Examples are systemd during boot,\n * or git grep. To help these processes get their job done as soon as\n * possible, it is usually better to not grant either weight-raising\n * or device idling to their queues, unless these queues must be\n * protected from the I/O flowing through other active queues.\n *\n * In this comment we describe, firstly, the reasons why this fact\n * holds, and, secondly, the next function, which implements the main\n * steps needed to properly mark these queues so that they can then be\n * treated in a different way.\n *\n * The above services or applications benefit mostly from a high\n * throughput: the quicker the requests of the activated queues are\n * cumulatively served, the sooner the target job of these queues gets\n * completed. As a consequence, weight-raising any of these queues,\n * which also implies idling the device for it, is almost always\n * counterproductive, unless there are other active queues to isolate\n * these new queues from. If there no other active queues, then\n * weight-raising these new queues just lowers throughput in most\n * cases.\n *\n * On the other hand, a burst of queue creations may be caused also by\n * the start of an application that does not consist of a lot of\n * parallel I/O-bound threads. In fact, with a complex application,\n * several short processes may need to be executed to start-up the\n * application. In this respect, to start an application as quickly as\n * possible, the best thing to do is in any case to privilege the I/O\n * related to the application with respect to all other\n * I/O. Therefore, the best strategy to start as quickly as possible\n * an application that causes a burst of queue creations is to\n * weight-raise all the queues created during the burst. This is the\n * exact opposite of the best strategy for the other type of bursts.\n *\n * In the end, to take the best action for each of the two cases, the\n * two types of bursts need to be distinguished. Fortunately, this\n * seems relatively easy, by looking at the sizes of the bursts. In\n * particular, we found a threshold such that only bursts with a\n * larger size than that threshold are apparently caused by\n * services or commands such as systemd or git grep. For brevity,\n * hereafter we call just 'large' these bursts. BFQ *does not*\n * weight-raise queues whose creation occurs in a large burst. In\n * addition, for each of these queues BFQ performs or does not perform\n * idling depending on which choice boosts the throughput more. The\n * exact choice depends on the device and request pattern at\n * hand.\n *\n * Unfortunately, false positives may occur while an interactive task\n * is starting (e.g., an application is being started). The\n * consequence is that the queues associated with the task do not\n * enjoy weight raising as expected. Fortunately these false positives\n * are very rare. They typically occur if some service happens to\n * start doing I/O exactly when the interactive task starts.\n *\n * Turning back to the next function, it is invoked only if there are\n * no active queues (apart from active queues that would belong to the\n * same, possible burst bfqq would belong to), and it implements all\n * the steps needed to detect the occurrence of a large burst and to\n * properly mark all the queues belonging to it (so that they can then\n * be treated in a different way). This goal is achieved by\n * maintaining a \"burst list\" that holds, temporarily, the queues that\n * belong to the burst in progress. The list is then used to mark\n * these queues as belonging to a large burst if the burst does become\n * large. The main steps are the following.\n *\n * . when the very first queue is created, the queue is inserted into the\n *   list (as it could be the first queue in a possible burst)\n *\n * . if the current burst has not yet become large, and a queue Q that does\n *   not yet belong to the burst is activated shortly after the last time\n *   at which a new queue entered the burst list, then the function appends\n *   Q to the burst list\n *\n * . if, as a consequence of the previous step, the burst size reaches\n *   the large-burst threshold, then\n *\n *     . all the queues in the burst list are marked as belonging to a\n *       large burst\n *\n *     . the burst list is deleted; in fact, the burst list already served\n *       its purpose (keeping temporarily track of the queues in a burst,\n *       so as to be able to mark them as belonging to a large burst in the\n *       previous sub-step), and now is not needed any more\n *\n *     . the device enters a large-burst mode\n *\n * . if a queue Q that does not belong to the burst is created while\n *   the device is in large-burst mode and shortly after the last time\n *   at which a queue either entered the burst list or was marked as\n *   belonging to the current large burst, then Q is immediately marked\n *   as belonging to a large burst.\n *\n * . if a queue Q that does not belong to the burst is created a while\n *   later, i.e., not shortly after, than the last time at which a queue\n *   either entered the burst list or was marked as belonging to the\n *   current large burst, then the current burst is deemed as finished and:\n *\n *        . the large-burst mode is reset if set\n *\n *        . the burst list is emptied\n *\n *        . Q is inserted in the burst list, as Q may be the first queue\n *          in a possible new burst (then the burst list contains just Q\n *          after this step).\n */\nstatic void bfq_handle_burst(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\t/*\n\t * If bfqq is already in the burst list or is part of a large\n\t * burst, or finally has just been split, then there is\n\t * nothing else to do.\n\t */\n\tif (!hlist_unhashed(&bfqq->burst_list_node) ||\n\t    bfq_bfqq_in_large_burst(bfqq) ||\n\t    time_is_after_eq_jiffies(bfqq->split_time +\n\t\t\t\t     msecs_to_jiffies(10)))\n\t\treturn;\n\n\t/*\n\t * If bfqq's creation happens late enough, or bfqq belongs to\n\t * a different group than the burst group, then the current\n\t * burst is finished, and related data structures must be\n\t * reset.\n\t *\n\t * In this respect, consider the special case where bfqq is\n\t * the very first queue created after BFQ is selected for this\n\t * device. In this case, last_ins_in_burst and\n\t * burst_parent_entity are not yet significant when we get\n\t * here. But it is easy to verify that, whether or not the\n\t * following condition is true, bfqq will end up being\n\t * inserted into the burst list. In particular the list will\n\t * happen to contain only bfqq. And this is exactly what has\n\t * to happen, as bfqq may be the first queue of the first\n\t * burst.\n\t */\n\tif (time_is_before_jiffies(bfqd->last_ins_in_burst +\n\t    bfqd->bfq_burst_interval) ||\n\t    bfqq->entity.parent != bfqd->burst_parent_entity) {\n\t\tbfqd->large_burst = false;\n\t\tbfq_reset_burst_list(bfqd, bfqq);\n\t\tgoto end;\n\t}\n\n\t/*\n\t * If we get here, then bfqq is being activated shortly after the\n\t * last queue. So, if the current burst is also large, we can mark\n\t * bfqq as belonging to this large burst immediately.\n\t */\n\tif (bfqd->large_burst) {\n\t\tbfq_mark_bfqq_in_large_burst(bfqq);\n\t\tgoto end;\n\t}\n\n\t/*\n\t * If we get here, then a large-burst state has not yet been\n\t * reached, but bfqq is being activated shortly after the last\n\t * queue. Then we add bfqq to the burst.\n\t */\n\tbfq_add_to_burst(bfqd, bfqq);\nend:\n\t/*\n\t * At this point, bfqq either has been added to the current\n\t * burst or has caused the current burst to terminate and a\n\t * possible new burst to start. In particular, in the second\n\t * case, bfqq has become the first queue in the possible new\n\t * burst.  In both cases last_ins_in_burst needs to be moved\n\t * forward.\n\t */\n\tbfqd->last_ins_in_burst = jiffies;\n}\n\nstatic int bfq_bfqq_budget_left(struct bfq_queue *bfqq)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\treturn entity->budget - entity->service;\n}\n\n/*\n * If enough samples have been computed, return the current max budget\n * stored in bfqd, which is dynamically updated according to the\n * estimated disk peak rate; otherwise return the default max budget\n */\nstatic int bfq_max_budget(struct bfq_data *bfqd)\n{\n\tif (bfqd->budgets_assigned < bfq_stats_min_budgets)\n\t\treturn bfq_default_max_budget;\n\telse\n\t\treturn bfqd->bfq_max_budget;\n}\n\n/*\n * Return min budget, which is a fraction of the current or default\n * max budget (trying with 1/32)\n */\nstatic int bfq_min_budget(struct bfq_data *bfqd)\n{\n\tif (bfqd->budgets_assigned < bfq_stats_min_budgets)\n\t\treturn bfq_default_max_budget / 32;\n\telse\n\t\treturn bfqd->bfq_max_budget / 32;\n}\n\n/*\n * The next function, invoked after the input queue bfqq switches from\n * idle to busy, updates the budget of bfqq. The function also tells\n * whether the in-service queue should be expired, by returning\n * true. The purpose of expiring the in-service queue is to give bfqq\n * the chance to possibly preempt the in-service queue, and the reason\n * for preempting the in-service queue is to achieve one of the two\n * goals below.\n *\n * 1. Guarantee to bfqq its reserved bandwidth even if bfqq has\n * expired because it has remained idle. In particular, bfqq may have\n * expired for one of the following two reasons:\n *\n * - BFQQE_NO_MORE_REQUESTS bfqq did not enjoy any device idling\n *   and did not make it to issue a new request before its last\n *   request was served;\n *\n * - BFQQE_TOO_IDLE bfqq did enjoy device idling, but did not issue\n *   a new request before the expiration of the idling-time.\n *\n * Even if bfqq has expired for one of the above reasons, the process\n * associated with the queue may be however issuing requests greedily,\n * and thus be sensitive to the bandwidth it receives (bfqq may have\n * remained idle for other reasons: CPU high load, bfqq not enjoying\n * idling, I/O throttling somewhere in the path from the process to\n * the I/O scheduler, ...). But if, after every expiration for one of\n * the above two reasons, bfqq has to wait for the service of at least\n * one full budget of another queue before being served again, then\n * bfqq is likely to get a much lower bandwidth or resource time than\n * its reserved ones. To address this issue, two countermeasures need\n * to be taken.\n *\n * First, the budget and the timestamps of bfqq need to be updated in\n * a special way on bfqq reactivation: they need to be updated as if\n * bfqq did not remain idle and did not expire. In fact, if they are\n * computed as if bfqq expired and remained idle until reactivation,\n * then the process associated with bfqq is treated as if, instead of\n * being greedy, it stopped issuing requests when bfqq remained idle,\n * and restarts issuing requests only on this reactivation. In other\n * words, the scheduler does not help the process recover the \"service\n * hole\" between bfqq expiration and reactivation. As a consequence,\n * the process receives a lower bandwidth than its reserved one. In\n * contrast, to recover this hole, the budget must be updated as if\n * bfqq was not expired at all before this reactivation, i.e., it must\n * be set to the value of the remaining budget when bfqq was\n * expired. Along the same line, timestamps need to be assigned the\n * value they had the last time bfqq was selected for service, i.e.,\n * before last expiration. Thus timestamps need to be back-shifted\n * with respect to their normal computation (see [1] for more details\n * on this tricky aspect).\n *\n * Secondly, to allow the process to recover the hole, the in-service\n * queue must be expired too, to give bfqq the chance to preempt it\n * immediately. In fact, if bfqq has to wait for a full budget of the\n * in-service queue to be completed, then it may become impossible to\n * let the process recover the hole, even if the back-shifted\n * timestamps of bfqq are lower than those of the in-service queue. If\n * this happens for most or all of the holes, then the process may not\n * receive its reserved bandwidth. In this respect, it is worth noting\n * that, being the service of outstanding requests unpreemptible, a\n * little fraction of the holes may however be unrecoverable, thereby\n * causing a little loss of bandwidth.\n *\n * The last important point is detecting whether bfqq does need this\n * bandwidth recovery. In this respect, the next function deems the\n * process associated with bfqq greedy, and thus allows it to recover\n * the hole, if: 1) the process is waiting for the arrival of a new\n * request (which implies that bfqq expired for one of the above two\n * reasons), and 2) such a request has arrived soon. The first\n * condition is controlled through the flag non_blocking_wait_rq,\n * while the second through the flag arrived_in_time. If both\n * conditions hold, then the function computes the budget in the\n * above-described special way, and signals that the in-service queue\n * should be expired. Timestamp back-shifting is done later in\n * __bfq_activate_entity.\n *\n * 2. Reduce latency. Even if timestamps are not backshifted to let\n * the process associated with bfqq recover a service hole, bfqq may\n * however happen to have, after being (re)activated, a lower finish\n * timestamp than the in-service queue.\t That is, the next budget of\n * bfqq may have to be completed before the one of the in-service\n * queue. If this is the case, then preempting the in-service queue\n * allows this goal to be achieved, apart from the unpreemptible,\n * outstanding requests mentioned above.\n *\n * Unfortunately, regardless of which of the above two goals one wants\n * to achieve, service trees need first to be updated to know whether\n * the in-service queue must be preempted. To have service trees\n * correctly updated, the in-service queue must be expired and\n * rescheduled, and bfqq must be scheduled too. This is one of the\n * most costly operations (in future versions, the scheduling\n * mechanism may be re-designed in such a way to make it possible to\n * know whether preemption is needed without needing to update service\n * trees). In addition, queue preemptions almost always cause random\n * I/O, which may in turn cause loss of throughput. Finally, there may\n * even be no in-service queue when the next function is invoked (so,\n * no queue to compare timestamps with). Because of these facts, the\n * next function adopts the following simple scheme to avoid costly\n * operations, too frequent preemptions and too many dependencies on\n * the state of the scheduler: it requests the expiration of the\n * in-service queue (unconditionally) only for queues that need to\n * recover a hole. Then it delegates to other parts of the code the\n * responsibility of handling the above case 2.\n */\nstatic bool bfq_bfqq_update_budg_for_activation(struct bfq_data *bfqd,\n\t\t\t\t\t\tstruct bfq_queue *bfqq,\n\t\t\t\t\t\tbool arrived_in_time)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\t/*\n\t * In the next compound condition, we check also whether there\n\t * is some budget left, because otherwise there is no point in\n\t * trying to go on serving bfqq with this same budget: bfqq\n\t * would be expired immediately after being selected for\n\t * service. This would only cause useless overhead.\n\t */\n\tif (bfq_bfqq_non_blocking_wait_rq(bfqq) && arrived_in_time &&\n\t    bfq_bfqq_budget_left(bfqq) > 0) {\n\t\t/*\n\t\t * We do not clear the flag non_blocking_wait_rq here, as\n\t\t * the latter is used in bfq_activate_bfqq to signal\n\t\t * that timestamps need to be back-shifted (and is\n\t\t * cleared right after).\n\t\t */\n\n\t\t/*\n\t\t * In next assignment we rely on that either\n\t\t * entity->service or entity->budget are not updated\n\t\t * on expiration if bfqq is empty (see\n\t\t * __bfq_bfqq_recalc_budget). Thus both quantities\n\t\t * remain unchanged after such an expiration, and the\n\t\t * following statement therefore assigns to\n\t\t * entity->budget the remaining budget on such an\n\t\t * expiration.\n\t\t */\n\t\tentity->budget = min_t(unsigned long,\n\t\t\t\t       bfq_bfqq_budget_left(bfqq),\n\t\t\t\t       bfqq->max_budget);\n\n\t\t/*\n\t\t * At this point, we have used entity->service to get\n\t\t * the budget left (needed for updating\n\t\t * entity->budget). Thus we finally can, and have to,\n\t\t * reset entity->service. The latter must be reset\n\t\t * because bfqq would otherwise be charged again for\n\t\t * the service it has received during its previous\n\t\t * service slot(s).\n\t\t */\n\t\tentity->service = 0;\n\n\t\treturn true;\n\t}\n\n\t/*\n\t * We can finally complete expiration, by setting service to 0.\n\t */\n\tentity->service = 0;\n\tentity->budget = max_t(unsigned long, bfqq->max_budget,\n\t\t\t       bfq_serv_to_charge(bfqq->next_rq, bfqq));\n\tbfq_clear_bfqq_non_blocking_wait_rq(bfqq);\n\treturn false;\n}\n\n/*\n * Return the farthest past time instant according to jiffies\n * macros.\n */\nstatic unsigned long bfq_smallest_from_now(void)\n{\n\treturn jiffies - MAX_JIFFY_OFFSET;\n}\n\nstatic void bfq_update_bfqq_wr_on_rq_arrival(struct bfq_data *bfqd,\n\t\t\t\t\t     struct bfq_queue *bfqq,\n\t\t\t\t\t     unsigned int old_wr_coeff,\n\t\t\t\t\t     bool wr_or_deserves_wr,\n\t\t\t\t\t     bool interactive,\n\t\t\t\t\t     bool in_burst,\n\t\t\t\t\t     bool soft_rt)\n{\n\tif (old_wr_coeff == 1 && wr_or_deserves_wr) {\n\t\t/* start a weight-raising period */\n\t\tif (interactive) {\n\t\t\tbfqq->service_from_wr = 0;\n\t\t\tbfqq->wr_coeff = bfqd->bfq_wr_coeff;\n\t\t\tbfqq->wr_cur_max_time = bfq_wr_duration(bfqd);\n\t\t} else {\n\t\t\t/*\n\t\t\t * No interactive weight raising in progress\n\t\t\t * here: assign minus infinity to\n\t\t\t * wr_start_at_switch_to_srt, to make sure\n\t\t\t * that, at the end of the soft-real-time\n\t\t\t * weight raising periods that is starting\n\t\t\t * now, no interactive weight-raising period\n\t\t\t * may be wrongly considered as still in\n\t\t\t * progress (and thus actually started by\n\t\t\t * mistake).\n\t\t\t */\n\t\t\tbfqq->wr_start_at_switch_to_srt =\n\t\t\t\tbfq_smallest_from_now();\n\t\t\tbfqq->wr_coeff = bfqd->bfq_wr_coeff *\n\t\t\t\tBFQ_SOFTRT_WEIGHT_FACTOR;\n\t\t\tbfqq->wr_cur_max_time =\n\t\t\t\tbfqd->bfq_wr_rt_max_time;\n\t\t}\n\n\t\t/*\n\t\t * If needed, further reduce budget to make sure it is\n\t\t * close to bfqq's backlog, so as to reduce the\n\t\t * scheduling-error component due to a too large\n\t\t * budget. Do not care about throughput consequences,\n\t\t * but only about latency. Finally, do not assign a\n\t\t * too small budget either, to avoid increasing\n\t\t * latency by causing too frequent expirations.\n\t\t */\n\t\tbfqq->entity.budget = min_t(unsigned long,\n\t\t\t\t\t    bfqq->entity.budget,\n\t\t\t\t\t    2 * bfq_min_budget(bfqd));\n\t} else if (old_wr_coeff > 1) {\n\t\tif (interactive) { /* update wr coeff and duration */\n\t\t\tbfqq->wr_coeff = bfqd->bfq_wr_coeff;\n\t\t\tbfqq->wr_cur_max_time = bfq_wr_duration(bfqd);\n\t\t} else if (in_burst)\n\t\t\tbfqq->wr_coeff = 1;\n\t\telse if (soft_rt) {\n\t\t\t/*\n\t\t\t * The application is now or still meeting the\n\t\t\t * requirements for being deemed soft rt.  We\n\t\t\t * can then correctly and safely (re)charge\n\t\t\t * the weight-raising duration for the\n\t\t\t * application with the weight-raising\n\t\t\t * duration for soft rt applications.\n\t\t\t *\n\t\t\t * In particular, doing this recharge now, i.e.,\n\t\t\t * before the weight-raising period for the\n\t\t\t * application finishes, reduces the probability\n\t\t\t * of the following negative scenario:\n\t\t\t * 1) the weight of a soft rt application is\n\t\t\t *    raised at startup (as for any newly\n\t\t\t *    created application),\n\t\t\t * 2) since the application is not interactive,\n\t\t\t *    at a certain time weight-raising is\n\t\t\t *    stopped for the application,\n\t\t\t * 3) at that time the application happens to\n\t\t\t *    still have pending requests, and hence\n\t\t\t *    is destined to not have a chance to be\n\t\t\t *    deemed soft rt before these requests are\n\t\t\t *    completed (see the comments to the\n\t\t\t *    function bfq_bfqq_softrt_next_start()\n\t\t\t *    for details on soft rt detection),\n\t\t\t * 4) these pending requests experience a high\n\t\t\t *    latency because the application is not\n\t\t\t *    weight-raised while they are pending.\n\t\t\t */\n\t\t\tif (bfqq->wr_cur_max_time !=\n\t\t\t\tbfqd->bfq_wr_rt_max_time) {\n\t\t\t\tbfqq->wr_start_at_switch_to_srt =\n\t\t\t\t\tbfqq->last_wr_start_finish;\n\n\t\t\t\tbfqq->wr_cur_max_time =\n\t\t\t\t\tbfqd->bfq_wr_rt_max_time;\n\t\t\t\tbfqq->wr_coeff = bfqd->bfq_wr_coeff *\n\t\t\t\t\tBFQ_SOFTRT_WEIGHT_FACTOR;\n\t\t\t}\n\t\t\tbfqq->last_wr_start_finish = jiffies;\n\t\t}\n\t}\n}\n\nstatic bool bfq_bfqq_idle_for_long_time(struct bfq_data *bfqd,\n\t\t\t\t\tstruct bfq_queue *bfqq)\n{\n\treturn bfqq->dispatched == 0 &&\n\t\ttime_is_before_jiffies(\n\t\t\tbfqq->budget_timeout +\n\t\t\tbfqd->bfq_wr_min_idle_time);\n}\n\n\n/*\n * Return true if bfqq is in a higher priority class, or has a higher\n * weight than the in-service queue.\n */\nstatic bool bfq_bfqq_higher_class_or_weight(struct bfq_queue *bfqq,\n\t\t\t\t\t    struct bfq_queue *in_serv_bfqq)\n{\n\tint bfqq_weight, in_serv_weight;\n\n\tif (bfqq->ioprio_class < in_serv_bfqq->ioprio_class)\n\t\treturn true;\n\n\tif (in_serv_bfqq->entity.parent == bfqq->entity.parent) {\n\t\tbfqq_weight = bfqq->entity.weight;\n\t\tin_serv_weight = in_serv_bfqq->entity.weight;\n\t} else {\n\t\tif (bfqq->entity.parent)\n\t\t\tbfqq_weight = bfqq->entity.parent->weight;\n\t\telse\n\t\t\tbfqq_weight = bfqq->entity.weight;\n\t\tif (in_serv_bfqq->entity.parent)\n\t\t\tin_serv_weight = in_serv_bfqq->entity.parent->weight;\n\t\telse\n\t\t\tin_serv_weight = in_serv_bfqq->entity.weight;\n\t}\n\n\treturn bfqq_weight > in_serv_weight;\n}\n\nstatic void bfq_bfqq_handle_idle_busy_switch(struct bfq_data *bfqd,\n\t\t\t\t\t     struct bfq_queue *bfqq,\n\t\t\t\t\t     int old_wr_coeff,\n\t\t\t\t\t     struct request *rq,\n\t\t\t\t\t     bool *interactive)\n{\n\tbool soft_rt, in_burst,\twr_or_deserves_wr,\n\t\tbfqq_wants_to_preempt,\n\t\tidle_for_long_time = bfq_bfqq_idle_for_long_time(bfqd, bfqq),\n\t\t/*\n\t\t * See the comments on\n\t\t * bfq_bfqq_update_budg_for_activation for\n\t\t * details on the usage of the next variable.\n\t\t */\n\t\tarrived_in_time =  ktime_get_ns() <=\n\t\t\tbfqq->ttime.last_end_request +\n\t\t\tbfqd->bfq_slice_idle * 3;\n\n\n\t/*\n\t * bfqq deserves to be weight-raised if:\n\t * - it is sync,\n\t * - it does not belong to a large burst,\n\t * - it has been idle for enough time or is soft real-time,\n\t * - is linked to a bfq_io_cq (it is not shared in any sense).\n\t */\n\tin_burst = bfq_bfqq_in_large_burst(bfqq);\n\tsoft_rt = bfqd->bfq_wr_max_softrt_rate > 0 &&\n\t\t!BFQQ_TOTALLY_SEEKY(bfqq) &&\n\t\t!in_burst &&\n\t\ttime_is_before_jiffies(bfqq->soft_rt_next_start) &&\n\t\tbfqq->dispatched == 0;\n\t*interactive = !in_burst && idle_for_long_time;\n\twr_or_deserves_wr = bfqd->low_latency &&\n\t\t(bfqq->wr_coeff > 1 ||\n\t\t (bfq_bfqq_sync(bfqq) &&\n\t\t  bfqq->bic && (*interactive || soft_rt)));\n\n\t/*\n\t * Using the last flag, update budget and check whether bfqq\n\t * may want to preempt the in-service queue.\n\t */\n\tbfqq_wants_to_preempt =\n\t\tbfq_bfqq_update_budg_for_activation(bfqd, bfqq,\n\t\t\t\t\t\t    arrived_in_time);\n\n\t/*\n\t * If bfqq happened to be activated in a burst, but has been\n\t * idle for much more than an interactive queue, then we\n\t * assume that, in the overall I/O initiated in the burst, the\n\t * I/O associated with bfqq is finished. So bfqq does not need\n\t * to be treated as a queue belonging to a burst\n\t * anymore. Accordingly, we reset bfqq's in_large_burst flag\n\t * if set, and remove bfqq from the burst list if it's\n\t * there. We do not decrement burst_size, because the fact\n\t * that bfqq does not need to belong to the burst list any\n\t * more does not invalidate the fact that bfqq was created in\n\t * a burst.\n\t */\n\tif (likely(!bfq_bfqq_just_created(bfqq)) &&\n\t    idle_for_long_time &&\n\t    time_is_before_jiffies(\n\t\t    bfqq->budget_timeout +\n\t\t    msecs_to_jiffies(10000))) {\n\t\thlist_del_init(&bfqq->burst_list_node);\n\t\tbfq_clear_bfqq_in_large_burst(bfqq);\n\t}\n\n\tbfq_clear_bfqq_just_created(bfqq);\n\n\n\tif (!bfq_bfqq_IO_bound(bfqq)) {\n\t\tif (arrived_in_time) {\n\t\t\tbfqq->requests_within_timer++;\n\t\t\tif (bfqq->requests_within_timer >=\n\t\t\t    bfqd->bfq_requests_within_timer)\n\t\t\t\tbfq_mark_bfqq_IO_bound(bfqq);\n\t\t} else\n\t\t\tbfqq->requests_within_timer = 0;\n\t}\n\n\tif (bfqd->low_latency) {\n\t\tif (unlikely(time_is_after_jiffies(bfqq->split_time)))\n\t\t\t/* wraparound */\n\t\t\tbfqq->split_time =\n\t\t\t\tjiffies - bfqd->bfq_wr_min_idle_time - 1;\n\n\t\tif (time_is_before_jiffies(bfqq->split_time +\n\t\t\t\t\t   bfqd->bfq_wr_min_idle_time)) {\n\t\t\tbfq_update_bfqq_wr_on_rq_arrival(bfqd, bfqq,\n\t\t\t\t\t\t\t old_wr_coeff,\n\t\t\t\t\t\t\t wr_or_deserves_wr,\n\t\t\t\t\t\t\t *interactive,\n\t\t\t\t\t\t\t in_burst,\n\t\t\t\t\t\t\t soft_rt);\n\n\t\t\tif (old_wr_coeff != bfqq->wr_coeff)\n\t\t\t\tbfqq->entity.prio_changed = 1;\n\t\t}\n\t}\n\n\tbfqq->last_idle_bklogged = jiffies;\n\tbfqq->service_from_backlogged = 0;\n\tbfq_clear_bfqq_softrt_update(bfqq);\n\n\tbfq_add_bfqq_busy(bfqd, bfqq);\n\n\t/*\n\t * Expire in-service queue only if preemption may be needed\n\t * for guarantees. In particular, we care only about two\n\t * cases. The first is that bfqq has to recover a service\n\t * hole, as explained in the comments on\n\t * bfq_bfqq_update_budg_for_activation(), i.e., that\n\t * bfqq_wants_to_preempt is true. However, if bfqq does not\n\t * carry time-critical I/O, then bfqq's bandwidth is less\n\t * important than that of queues that carry time-critical I/O.\n\t * So, as a further constraint, we consider this case only if\n\t * bfqq is at least as weight-raised, i.e., at least as time\n\t * critical, as the in-service queue.\n\t *\n\t * The second case is that bfqq is in a higher priority class,\n\t * or has a higher weight than the in-service queue. If this\n\t * condition does not hold, we don't care because, even if\n\t * bfqq does not start to be served immediately, the resulting\n\t * delay for bfqq's I/O is however lower or much lower than\n\t * the ideal completion time to be guaranteed to bfqq's I/O.\n\t *\n\t * In both cases, preemption is needed only if, according to\n\t * the timestamps of both bfqq and of the in-service queue,\n\t * bfqq actually is the next queue to serve. So, to reduce\n\t * useless preemptions, the return value of\n\t * next_queue_may_preempt() is considered in the next compound\n\t * condition too. Yet next_queue_may_preempt() just checks a\n\t * simple, necessary condition for bfqq to be the next queue\n\t * to serve. In fact, to evaluate a sufficient condition, the\n\t * timestamps of the in-service queue would need to be\n\t * updated, and this operation is quite costly (see the\n\t * comments on bfq_bfqq_update_budg_for_activation()).\n\t */\n\tif (bfqd->in_service_queue &&\n\t    ((bfqq_wants_to_preempt &&\n\t      bfqq->wr_coeff >= bfqd->in_service_queue->wr_coeff) ||\n\t     bfq_bfqq_higher_class_or_weight(bfqq, bfqd->in_service_queue)) &&\n\t    next_queue_may_preempt(bfqd))\n\t\tbfq_bfqq_expire(bfqd, bfqd->in_service_queue,\n\t\t\t\tfalse, BFQQE_PREEMPTED);\n}\n\nstatic void bfq_reset_inject_limit(struct bfq_data *bfqd,\n\t\t\t\t   struct bfq_queue *bfqq)\n{\n\t/* invalidate baseline total service time */\n\tbfqq->last_serv_time_ns = 0;\n\n\t/*\n\t * Reset pointer in case we are waiting for\n\t * some request completion.\n\t */\n\tbfqd->waited_rq = NULL;\n\n\t/*\n\t * If bfqq has a short think time, then start by setting the\n\t * inject limit to 0 prudentially, because the service time of\n\t * an injected I/O request may be higher than the think time\n\t * of bfqq, and therefore, if one request was injected when\n\t * bfqq remains empty, this injected request might delay the\n\t * service of the next I/O request for bfqq significantly. In\n\t * case bfqq can actually tolerate some injection, then the\n\t * adaptive update will however raise the limit soon. This\n\t * lucky circumstance holds exactly because bfqq has a short\n\t * think time, and thus, after remaining empty, is likely to\n\t * get new I/O enqueued---and then completed---before being\n\t * expired. This is the very pattern that gives the\n\t * limit-update algorithm the chance to measure the effect of\n\t * injection on request service times, and then to update the\n\t * limit accordingly.\n\t *\n\t * However, in the following special case, the inject limit is\n\t * left to 1 even if the think time is short: bfqq's I/O is\n\t * synchronized with that of some other queue, i.e., bfqq may\n\t * receive new I/O only after the I/O of the other queue is\n\t * completed. Keeping the inject limit to 1 allows the\n\t * blocking I/O to be served while bfqq is in service. And\n\t * this is very convenient both for bfqq and for overall\n\t * throughput, as explained in detail in the comments in\n\t * bfq_update_has_short_ttime().\n\t *\n\t * On the opposite end, if bfqq has a long think time, then\n\t * start directly by 1, because:\n\t * a) on the bright side, keeping at most one request in\n\t * service in the drive is unlikely to cause any harm to the\n\t * latency of bfqq's requests, as the service time of a single\n\t * request is likely to be lower than the think time of bfqq;\n\t * b) on the downside, after becoming empty, bfqq is likely to\n\t * expire before getting its next request. With this request\n\t * arrival pattern, it is very hard to sample total service\n\t * times and update the inject limit accordingly (see comments\n\t * on bfq_update_inject_limit()). So the limit is likely to be\n\t * never, or at least seldom, updated.  As a consequence, by\n\t * setting the limit to 1, we avoid that no injection ever\n\t * occurs with bfqq. On the downside, this proactive step\n\t * further reduces chances to actually compute the baseline\n\t * total service time. Thus it reduces chances to execute the\n\t * limit-update algorithm and possibly raise the limit to more\n\t * than 1.\n\t */\n\tif (bfq_bfqq_has_short_ttime(bfqq))\n\t\tbfqq->inject_limit = 0;\n\telse\n\t\tbfqq->inject_limit = 1;\n\n\tbfqq->decrease_time_jif = jiffies;\n}\n\nstatic void bfq_add_request(struct request *rq)\n{\n\tstruct bfq_queue *bfqq = RQ_BFQQ(rq);\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tstruct request *next_rq, *prev;\n\tunsigned int old_wr_coeff = bfqq->wr_coeff;\n\tbool interactive = false;\n\n\tbfq_log_bfqq(bfqd, bfqq, \"add_request %d\", rq_is_sync(rq));\n\tbfqq->queued[rq_is_sync(rq)]++;\n\tbfqd->queued++;\n\n\tif (RB_EMPTY_ROOT(&bfqq->sort_list) && bfq_bfqq_sync(bfqq)) {\n\t\t/*\n\t\t * Detect whether bfqq's I/O seems synchronized with\n\t\t * that of some other queue, i.e., whether bfqq, after\n\t\t * remaining empty, happens to receive new I/O only\n\t\t * right after some I/O request of the other queue has\n\t\t * been completed. We call waker queue the other\n\t\t * queue, and we assume, for simplicity, that bfqq may\n\t\t * have at most one waker queue.\n\t\t *\n\t\t * A remarkable throughput boost can be reached by\n\t\t * unconditionally injecting the I/O of the waker\n\t\t * queue, every time a new bfq_dispatch_request\n\t\t * happens to be invoked while I/O is being plugged\n\t\t * for bfqq.  In addition to boosting throughput, this\n\t\t * unblocks bfqq's I/O, thereby improving bandwidth\n\t\t * and latency for bfqq. Note that these same results\n\t\t * may be achieved with the general injection\n\t\t * mechanism, but less effectively. For details on\n\t\t * this aspect, see the comments on the choice of the\n\t\t * queue for injection in bfq_select_queue().\n\t\t *\n\t\t * Turning back to the detection of a waker queue, a\n\t\t * queue Q is deemed as a waker queue for bfqq if, for\n\t\t * two consecutive times, bfqq happens to become non\n\t\t * empty right after a request of Q has been\n\t\t * completed. In particular, on the first time, Q is\n\t\t * tentatively set as a candidate waker queue, while\n\t\t * on the second time, the flag\n\t\t * bfq_bfqq_has_waker(bfqq) is set to confirm that Q\n\t\t * is a waker queue for bfqq. These detection steps\n\t\t * are performed only if bfqq has a long think time,\n\t\t * so as to make it more likely that bfqq's I/O is\n\t\t * actually being blocked by a synchronization. This\n\t\t * last filter, plus the above two-times requirement,\n\t\t * make false positives less likely.\n\t\t *\n\t\t * NOTE\n\t\t *\n\t\t * The sooner a waker queue is detected, the sooner\n\t\t * throughput can be boosted by injecting I/O from the\n\t\t * waker queue. Fortunately, detection is likely to be\n\t\t * actually fast, for the following reasons. While\n\t\t * blocked by synchronization, bfqq has a long think\n\t\t * time. This implies that bfqq's inject limit is at\n\t\t * least equal to 1 (see the comments in\n\t\t * bfq_update_inject_limit()). So, thanks to\n\t\t * injection, the waker queue is likely to be served\n\t\t * during the very first I/O-plugging time interval\n\t\t * for bfqq. This triggers the first step of the\n\t\t * detection mechanism. Thanks again to injection, the\n\t\t * candidate waker queue is then likely to be\n\t\t * confirmed no later than during the next\n\t\t * I/O-plugging interval for bfqq.\n\t\t */\n\t\tif (bfqd->last_completed_rq_bfqq &&\n\t\t    !bfq_bfqq_has_short_ttime(bfqq) &&\n\t\t    ktime_get_ns() - bfqd->last_completion <\n\t\t    200 * NSEC_PER_USEC) {\n\t\t\tif (bfqd->last_completed_rq_bfqq != bfqq &&\n\t\t\t    bfqd->last_completed_rq_bfqq !=\n\t\t\t    bfqq->waker_bfqq) {\n\t\t\t\t/*\n\t\t\t\t * First synchronization detected with\n\t\t\t\t * a candidate waker queue, or with a\n\t\t\t\t * different candidate waker queue\n\t\t\t\t * from the current one.\n\t\t\t\t */\n\t\t\t\tbfqq->waker_bfqq = bfqd->last_completed_rq_bfqq;\n\n\t\t\t\t/*\n\t\t\t\t * If the waker queue disappears, then\n\t\t\t\t * bfqq->waker_bfqq must be reset. To\n\t\t\t\t * this goal, we maintain in each\n\t\t\t\t * waker queue a list, woken_list, of\n\t\t\t\t * all the queues that reference the\n\t\t\t\t * waker queue through their\n\t\t\t\t * waker_bfqq pointer. When the waker\n\t\t\t\t * queue exits, the waker_bfqq pointer\n\t\t\t\t * of all the queues in the woken_list\n\t\t\t\t * is reset.\n\t\t\t\t *\n\t\t\t\t * In addition, if bfqq is already in\n\t\t\t\t * the woken_list of a waker queue,\n\t\t\t\t * then, before being inserted into\n\t\t\t\t * the woken_list of a new waker\n\t\t\t\t * queue, bfqq must be removed from\n\t\t\t\t * the woken_list of the old waker\n\t\t\t\t * queue.\n\t\t\t\t */\n\t\t\t\tif (!hlist_unhashed(&bfqq->woken_list_node))\n\t\t\t\t\thlist_del_init(&bfqq->woken_list_node);\n\t\t\t\thlist_add_head(&bfqq->woken_list_node,\n\t\t\t\t    &bfqd->last_completed_rq_bfqq->woken_list);\n\n\t\t\t\tbfq_clear_bfqq_has_waker(bfqq);\n\t\t\t} else if (bfqd->last_completed_rq_bfqq ==\n\t\t\t\t   bfqq->waker_bfqq &&\n\t\t\t\t   !bfq_bfqq_has_waker(bfqq)) {\n\t\t\t\t/*\n\t\t\t\t * synchronization with waker_bfqq\n\t\t\t\t * seen for the second time\n\t\t\t\t */\n\t\t\t\tbfq_mark_bfqq_has_waker(bfqq);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Periodically reset inject limit, to make sure that\n\t\t * the latter eventually drops in case workload\n\t\t * changes, see step (3) in the comments on\n\t\t * bfq_update_inject_limit().\n\t\t */\n\t\tif (time_is_before_eq_jiffies(bfqq->decrease_time_jif +\n\t\t\t\t\t     msecs_to_jiffies(1000)))\n\t\t\tbfq_reset_inject_limit(bfqd, bfqq);\n\n\t\t/*\n\t\t * The following conditions must hold to setup a new\n\t\t * sampling of total service time, and then a new\n\t\t * update of the inject limit:\n\t\t * - bfqq is in service, because the total service\n\t\t *   time is evaluated only for the I/O requests of\n\t\t *   the queues in service;\n\t\t * - this is the right occasion to compute or to\n\t\t *   lower the baseline total service time, because\n\t\t *   there are actually no requests in the drive,\n\t\t *   or\n\t\t *   the baseline total service time is available, and\n\t\t *   this is the right occasion to compute the other\n\t\t *   quantity needed to update the inject limit, i.e.,\n\t\t *   the total service time caused by the amount of\n\t\t *   injection allowed by the current value of the\n\t\t *   limit. It is the right occasion because injection\n\t\t *   has actually been performed during the service\n\t\t *   hole, and there are still in-flight requests,\n\t\t *   which are very likely to be exactly the injected\n\t\t *   requests, or part of them;\n\t\t * - the minimum interval for sampling the total\n\t\t *   service time and updating the inject limit has\n\t\t *   elapsed.\n\t\t */\n\t\tif (bfqq == bfqd->in_service_queue &&\n\t\t    (bfqd->rq_in_driver == 0 ||\n\t\t     (bfqq->last_serv_time_ns > 0 &&\n\t\t      bfqd->rqs_injected && bfqd->rq_in_driver > 0)) &&\n\t\t    time_is_before_eq_jiffies(bfqq->decrease_time_jif +\n\t\t\t\t\t      msecs_to_jiffies(10))) {\n\t\t\tbfqd->last_empty_occupied_ns = ktime_get_ns();\n\t\t\t/*\n\t\t\t * Start the state machine for measuring the\n\t\t\t * total service time of rq: setting\n\t\t\t * wait_dispatch will cause bfqd->waited_rq to\n\t\t\t * be set when rq will be dispatched.\n\t\t\t */\n\t\t\tbfqd->wait_dispatch = true;\n\t\t\t/*\n\t\t\t * If there is no I/O in service in the drive,\n\t\t\t * then possible injection occurred before the\n\t\t\t * arrival of rq will not affect the total\n\t\t\t * service time of rq. So the injection limit\n\t\t\t * must not be updated as a function of such\n\t\t\t * total service time, unless new injection\n\t\t\t * occurs before rq is completed. To have the\n\t\t\t * injection limit updated only in the latter\n\t\t\t * case, reset rqs_injected here (rqs_injected\n\t\t\t * will be set in case injection is performed\n\t\t\t * on bfqq before rq is completed).\n\t\t\t */\n\t\t\tif (bfqd->rq_in_driver == 0)\n\t\t\t\tbfqd->rqs_injected = false;\n\t\t}\n\t}\n\n\telv_rb_add(&bfqq->sort_list, rq);\n\n\t/*\n\t * Check if this request is a better next-serve candidate.\n\t */\n\tprev = bfqq->next_rq;\n\tnext_rq = bfq_choose_req(bfqd, bfqq->next_rq, rq, bfqd->last_position);\n\tbfqq->next_rq = next_rq;\n\n\t/*\n\t * Adjust priority tree position, if next_rq changes.\n\t * See comments on bfq_pos_tree_add_move() for the unlikely().\n\t */\n\tif (unlikely(!bfqd->nonrot_with_queueing && prev != bfqq->next_rq))\n\t\tbfq_pos_tree_add_move(bfqd, bfqq);\n\n\tif (!bfq_bfqq_busy(bfqq)) /* switching to busy ... */\n\t\tbfq_bfqq_handle_idle_busy_switch(bfqd, bfqq, old_wr_coeff,\n\t\t\t\t\t\t rq, &interactive);\n\telse {\n\t\tif (bfqd->low_latency && old_wr_coeff == 1 && !rq_is_sync(rq) &&\n\t\t    time_is_before_jiffies(\n\t\t\t\tbfqq->last_wr_start_finish +\n\t\t\t\tbfqd->bfq_wr_min_inter_arr_async)) {\n\t\t\tbfqq->wr_coeff = bfqd->bfq_wr_coeff;\n\t\t\tbfqq->wr_cur_max_time = bfq_wr_duration(bfqd);\n\n\t\t\tbfqd->wr_busy_queues++;\n\t\t\tbfqq->entity.prio_changed = 1;\n\t\t}\n\t\tif (prev != bfqq->next_rq)\n\t\t\tbfq_updated_next_req(bfqd, bfqq);\n\t}\n\n\t/*\n\t * Assign jiffies to last_wr_start_finish in the following\n\t * cases:\n\t *\n\t * . if bfqq is not going to be weight-raised, because, for\n\t *   non weight-raised queues, last_wr_start_finish stores the\n\t *   arrival time of the last request; as of now, this piece\n\t *   of information is used only for deciding whether to\n\t *   weight-raise async queues\n\t *\n\t * . if bfqq is not weight-raised, because, if bfqq is now\n\t *   switching to weight-raised, then last_wr_start_finish\n\t *   stores the time when weight-raising starts\n\t *\n\t * . if bfqq is interactive, because, regardless of whether\n\t *   bfqq is currently weight-raised, the weight-raising\n\t *   period must start or restart (this case is considered\n\t *   separately because it is not detected by the above\n\t *   conditions, if bfqq is already weight-raised)\n\t *\n\t * last_wr_start_finish has to be updated also if bfqq is soft\n\t * real-time, because the weight-raising period is constantly\n\t * restarted on idle-to-busy transitions for these queues, but\n\t * this is already done in bfq_bfqq_handle_idle_busy_switch if\n\t * needed.\n\t */\n\tif (bfqd->low_latency &&\n\t\t(old_wr_coeff == 1 || bfqq->wr_coeff == 1 || interactive))\n\t\tbfqq->last_wr_start_finish = jiffies;\n}\n\nstatic struct request *bfq_find_rq_fmerge(struct bfq_data *bfqd,\n\t\t\t\t\t  struct bio *bio,\n\t\t\t\t\t  struct request_queue *q)\n{\n\tstruct bfq_queue *bfqq = bfqd->bio_bfqq;\n\n\n\tif (bfqq)\n\t\treturn elv_rb_find(&bfqq->sort_list, bio_end_sector(bio));\n\n\treturn NULL;\n}\n\nstatic sector_t get_sdist(sector_t last_pos, struct request *rq)\n{\n\tif (last_pos)\n\t\treturn abs(blk_rq_pos(rq) - last_pos);\n\n\treturn 0;\n}\n\n#if 0 /* Still not clear if we can do without next two functions */\nstatic void bfq_activate_request(struct request_queue *q, struct request *rq)\n{\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\n\tbfqd->rq_in_driver++;\n}\n\nstatic void bfq_deactivate_request(struct request_queue *q, struct request *rq)\n{\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\n\tbfqd->rq_in_driver--;\n}\n#endif\n\nstatic void bfq_remove_request(struct request_queue *q,\n\t\t\t       struct request *rq)\n{\n\tstruct bfq_queue *bfqq = RQ_BFQQ(rq);\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tconst int sync = rq_is_sync(rq);\n\n\tif (bfqq->next_rq == rq) {\n\t\tbfqq->next_rq = bfq_find_next_rq(bfqd, bfqq, rq);\n\t\tbfq_updated_next_req(bfqd, bfqq);\n\t}\n\n\tif (rq->queuelist.prev != &rq->queuelist)\n\t\tlist_del_init(&rq->queuelist);\n\tbfqq->queued[sync]--;\n\tbfqd->queued--;\n\telv_rb_del(&bfqq->sort_list, rq);\n\n\telv_rqhash_del(q, rq);\n\tif (q->last_merge == rq)\n\t\tq->last_merge = NULL;\n\n\tif (RB_EMPTY_ROOT(&bfqq->sort_list)) {\n\t\tbfqq->next_rq = NULL;\n\n\t\tif (bfq_bfqq_busy(bfqq) && bfqq != bfqd->in_service_queue) {\n\t\t\tbfq_del_bfqq_busy(bfqd, bfqq, false);\n\t\t\t/*\n\t\t\t * bfqq emptied. In normal operation, when\n\t\t\t * bfqq is empty, bfqq->entity.service and\n\t\t\t * bfqq->entity.budget must contain,\n\t\t\t * respectively, the service received and the\n\t\t\t * budget used last time bfqq emptied. These\n\t\t\t * facts do not hold in this case, as at least\n\t\t\t * this last removal occurred while bfqq is\n\t\t\t * not in service. To avoid inconsistencies,\n\t\t\t * reset both bfqq->entity.service and\n\t\t\t * bfqq->entity.budget, if bfqq has still a\n\t\t\t * process that may issue I/O requests to it.\n\t\t\t */\n\t\t\tbfqq->entity.budget = bfqq->entity.service = 0;\n\t\t}\n\n\t\t/*\n\t\t * Remove queue from request-position tree as it is empty.\n\t\t */\n\t\tif (bfqq->pos_root) {\n\t\t\trb_erase(&bfqq->pos_node, bfqq->pos_root);\n\t\t\tbfqq->pos_root = NULL;\n\t\t}\n\t} else {\n\t\t/* see comments on bfq_pos_tree_add_move() for the unlikely() */\n\t\tif (unlikely(!bfqd->nonrot_with_queueing))\n\t\t\tbfq_pos_tree_add_move(bfqd, bfqq);\n\t}\n\n\tif (rq->cmd_flags & REQ_META)\n\t\tbfqq->meta_pending--;\n\n}\n\nstatic bool bfq_bio_merge(struct blk_mq_hw_ctx *hctx, struct bio *bio,\n\t\tunsigned int nr_segs)\n{\n\tstruct request_queue *q = hctx->queue;\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\tstruct request *free = NULL;\n\t/*\n\t * bfq_bic_lookup grabs the queue_lock: invoke it now and\n\t * store its return value for later use, to avoid nesting\n\t * queue_lock inside the bfqd->lock. We assume that the bic\n\t * returned by bfq_bic_lookup does not go away before\n\t * bfqd->lock is taken.\n\t */\n\tstruct bfq_io_cq *bic = bfq_bic_lookup(bfqd, current->io_context, q);\n\tbool ret;\n\n\tspin_lock_irq(&bfqd->lock);\n\n\tif (bic)\n\t\tbfqd->bio_bfqq = bic_to_bfqq(bic, op_is_sync(bio->bi_opf));\n\telse\n\t\tbfqd->bio_bfqq = NULL;\n\tbfqd->bio_bic = bic;\n\n\tret = blk_mq_sched_try_merge(q, bio, nr_segs, &free);\n\n\tif (free)\n\t\tblk_mq_free_request(free);\n\tspin_unlock_irq(&bfqd->lock);\n\n\treturn ret;\n}\n\nstatic int bfq_request_merge(struct request_queue *q, struct request **req,\n\t\t\t     struct bio *bio)\n{\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\tstruct request *__rq;\n\n\t__rq = bfq_find_rq_fmerge(bfqd, bio, q);\n\tif (__rq && elv_bio_merge_ok(__rq, bio)) {\n\t\t*req = __rq;\n\t\treturn ELEVATOR_FRONT_MERGE;\n\t}\n\n\treturn ELEVATOR_NO_MERGE;\n}\n\nstatic struct bfq_queue *bfq_init_rq(struct request *rq);\n\nstatic void bfq_request_merged(struct request_queue *q, struct request *req,\n\t\t\t       enum elv_merge type)\n{\n\tif (type == ELEVATOR_FRONT_MERGE &&\n\t    rb_prev(&req->rb_node) &&\n\t    blk_rq_pos(req) <\n\t    blk_rq_pos(container_of(rb_prev(&req->rb_node),\n\t\t\t\t    struct request, rb_node))) {\n\t\tstruct bfq_queue *bfqq = bfq_init_rq(req);\n\t\tstruct bfq_data *bfqd;\n\t\tstruct request *prev, *next_rq;\n\n\t\tif (!bfqq)\n\t\t\treturn;\n\n\t\tbfqd = bfqq->bfqd;\n\n\t\t/* Reposition request in its sort_list */\n\t\telv_rb_del(&bfqq->sort_list, req);\n\t\telv_rb_add(&bfqq->sort_list, req);\n\n\t\t/* Choose next request to be served for bfqq */\n\t\tprev = bfqq->next_rq;\n\t\tnext_rq = bfq_choose_req(bfqd, bfqq->next_rq, req,\n\t\t\t\t\t bfqd->last_position);\n\t\tbfqq->next_rq = next_rq;\n\t\t/*\n\t\t * If next_rq changes, update both the queue's budget to\n\t\t * fit the new request and the queue's position in its\n\t\t * rq_pos_tree.\n\t\t */\n\t\tif (prev != bfqq->next_rq) {\n\t\t\tbfq_updated_next_req(bfqd, bfqq);\n\t\t\t/*\n\t\t\t * See comments on bfq_pos_tree_add_move() for\n\t\t\t * the unlikely().\n\t\t\t */\n\t\t\tif (unlikely(!bfqd->nonrot_with_queueing))\n\t\t\t\tbfq_pos_tree_add_move(bfqd, bfqq);\n\t\t}\n\t}\n}\n\n/*\n * This function is called to notify the scheduler that the requests\n * rq and 'next' have been merged, with 'next' going away.  BFQ\n * exploits this hook to address the following issue: if 'next' has a\n * fifo_time lower that rq, then the fifo_time of rq must be set to\n * the value of 'next', to not forget the greater age of 'next'.\n *\n * NOTE: in this function we assume that rq is in a bfq_queue, basing\n * on that rq is picked from the hash table q->elevator->hash, which,\n * in its turn, is filled only with I/O requests present in\n * bfq_queues, while BFQ is in use for the request queue q. In fact,\n * the function that fills this hash table (elv_rqhash_add) is called\n * only by bfq_insert_request.\n */\nstatic void bfq_requests_merged(struct request_queue *q, struct request *rq,\n\t\t\t\tstruct request *next)\n{\n\tstruct bfq_queue *bfqq = bfq_init_rq(rq),\n\t\t*next_bfqq = bfq_init_rq(next);\n\n\tif (!bfqq)\n\t\treturn;\n\n\t/*\n\t * If next and rq belong to the same bfq_queue and next is older\n\t * than rq, then reposition rq in the fifo (by substituting next\n\t * with rq). Otherwise, if next and rq belong to different\n\t * bfq_queues, never reposition rq: in fact, we would have to\n\t * reposition it with respect to next's position in its own fifo,\n\t * which would most certainly be too expensive with respect to\n\t * the benefits.\n\t */\n\tif (bfqq == next_bfqq &&\n\t    !list_empty(&rq->queuelist) && !list_empty(&next->queuelist) &&\n\t    next->fifo_time < rq->fifo_time) {\n\t\tlist_del_init(&rq->queuelist);\n\t\tlist_replace_init(&next->queuelist, &rq->queuelist);\n\t\trq->fifo_time = next->fifo_time;\n\t}\n\n\tif (bfqq->next_rq == next)\n\t\tbfqq->next_rq = rq;\n\n\tbfqg_stats_update_io_merged(bfqq_group(bfqq), next->cmd_flags);\n}\n\n/* Must be called with bfqq != NULL */\nstatic void bfq_bfqq_end_wr(struct bfq_queue *bfqq)\n{\n\tif (bfq_bfqq_busy(bfqq))\n\t\tbfqq->bfqd->wr_busy_queues--;\n\tbfqq->wr_coeff = 1;\n\tbfqq->wr_cur_max_time = 0;\n\tbfqq->last_wr_start_finish = jiffies;\n\t/*\n\t * Trigger a weight change on the next invocation of\n\t * __bfq_entity_update_weight_prio.\n\t */\n\tbfqq->entity.prio_changed = 1;\n}\n\nvoid bfq_end_wr_async_queues(struct bfq_data *bfqd,\n\t\t\t     struct bfq_group *bfqg)\n{\n\tint i, j;\n\n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < IOPRIO_BE_NR; j++)\n\t\t\tif (bfqg->async_bfqq[i][j])\n\t\t\t\tbfq_bfqq_end_wr(bfqg->async_bfqq[i][j]);\n\tif (bfqg->async_idle_bfqq)\n\t\tbfq_bfqq_end_wr(bfqg->async_idle_bfqq);\n}\n\nstatic void bfq_end_wr(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq;\n\n\tspin_lock_irq(&bfqd->lock);\n\n\tlist_for_each_entry(bfqq, &bfqd->active_list, bfqq_list)\n\t\tbfq_bfqq_end_wr(bfqq);\n\tlist_for_each_entry(bfqq, &bfqd->idle_list, bfqq_list)\n\t\tbfq_bfqq_end_wr(bfqq);\n\tbfq_end_wr_async(bfqd);\n\n\tspin_unlock_irq(&bfqd->lock);\n}\n\nstatic sector_t bfq_io_struct_pos(void *io_struct, bool request)\n{\n\tif (request)\n\t\treturn blk_rq_pos(io_struct);\n\telse\n\t\treturn ((struct bio *)io_struct)->bi_iter.bi_sector;\n}\n\nstatic int bfq_rq_close_to_sector(void *io_struct, bool request,\n\t\t\t\t  sector_t sector)\n{\n\treturn abs(bfq_io_struct_pos(io_struct, request) - sector) <=\n\t       BFQQ_CLOSE_THR;\n}\n\nstatic struct bfq_queue *bfqq_find_close(struct bfq_data *bfqd,\n\t\t\t\t\t struct bfq_queue *bfqq,\n\t\t\t\t\t sector_t sector)\n{\n\tstruct rb_root *root = &bfq_bfqq_to_bfqg(bfqq)->rq_pos_tree;\n\tstruct rb_node *parent, *node;\n\tstruct bfq_queue *__bfqq;\n\n\tif (RB_EMPTY_ROOT(root))\n\t\treturn NULL;\n\n\t/*\n\t * First, if we find a request starting at the end of the last\n\t * request, choose it.\n\t */\n\t__bfqq = bfq_rq_pos_tree_lookup(bfqd, root, sector, &parent, NULL);\n\tif (__bfqq)\n\t\treturn __bfqq;\n\n\t/*\n\t * If the exact sector wasn't found, the parent of the NULL leaf\n\t * will contain the closest sector (rq_pos_tree sorted by\n\t * next_request position).\n\t */\n\t__bfqq = rb_entry(parent, struct bfq_queue, pos_node);\n\tif (bfq_rq_close_to_sector(__bfqq->next_rq, true, sector))\n\t\treturn __bfqq;\n\n\tif (blk_rq_pos(__bfqq->next_rq) < sector)\n\t\tnode = rb_next(&__bfqq->pos_node);\n\telse\n\t\tnode = rb_prev(&__bfqq->pos_node);\n\tif (!node)\n\t\treturn NULL;\n\n\t__bfqq = rb_entry(node, struct bfq_queue, pos_node);\n\tif (bfq_rq_close_to_sector(__bfqq->next_rq, true, sector))\n\t\treturn __bfqq;\n\n\treturn NULL;\n}\n\nstatic struct bfq_queue *bfq_find_close_cooperator(struct bfq_data *bfqd,\n\t\t\t\t\t\t   struct bfq_queue *cur_bfqq,\n\t\t\t\t\t\t   sector_t sector)\n{\n\tstruct bfq_queue *bfqq;\n\n\t/*\n\t * We shall notice if some of the queues are cooperating,\n\t * e.g., working closely on the same area of the device. In\n\t * that case, we can group them together and: 1) don't waste\n\t * time idling, and 2) serve the union of their requests in\n\t * the best possible order for throughput.\n\t */\n\tbfqq = bfqq_find_close(bfqd, cur_bfqq, sector);\n\tif (!bfqq || bfqq == cur_bfqq)\n\t\treturn NULL;\n\n\treturn bfqq;\n}\n\nstatic struct bfq_queue *\nbfq_setup_merge(struct bfq_queue *bfqq, struct bfq_queue *new_bfqq)\n{\n\tint process_refs, new_process_refs;\n\tstruct bfq_queue *__bfqq;\n\n\t/*\n\t * If there are no process references on the new_bfqq, then it is\n\t * unsafe to follow the ->new_bfqq chain as other bfqq's in the chain\n\t * may have dropped their last reference (not just their last process\n\t * reference).\n\t */\n\tif (!bfqq_process_refs(new_bfqq))\n\t\treturn NULL;\n\n\t/* Avoid a circular list and skip interim queue merges. */\n\twhile ((__bfqq = new_bfqq->new_bfqq)) {\n\t\tif (__bfqq == bfqq)\n\t\t\treturn NULL;\n\t\tnew_bfqq = __bfqq;\n\t}\n\n\tprocess_refs = bfqq_process_refs(bfqq);\n\tnew_process_refs = bfqq_process_refs(new_bfqq);\n\t/*\n\t * If the process for the bfqq has gone away, there is no\n\t * sense in merging the queues.\n\t */\n\tif (process_refs == 0 || new_process_refs == 0)\n\t\treturn NULL;\n\n\tbfq_log_bfqq(bfqq->bfqd, bfqq, \"scheduling merge with queue %d\",\n\t\tnew_bfqq->pid);\n\n\t/*\n\t * Merging is just a redirection: the requests of the process\n\t * owning one of the two queues are redirected to the other queue.\n\t * The latter queue, in its turn, is set as shared if this is the\n\t * first time that the requests of some process are redirected to\n\t * it.\n\t *\n\t * We redirect bfqq to new_bfqq and not the opposite, because\n\t * we are in the context of the process owning bfqq, thus we\n\t * have the io_cq of this process. So we can immediately\n\t * configure this io_cq to redirect the requests of the\n\t * process to new_bfqq. In contrast, the io_cq of new_bfqq is\n\t * not available any more (new_bfqq->bic == NULL).\n\t *\n\t * Anyway, even in case new_bfqq coincides with the in-service\n\t * queue, redirecting requests the in-service queue is the\n\t * best option, as we feed the in-service queue with new\n\t * requests close to the last request served and, by doing so,\n\t * are likely to increase the throughput.\n\t */\n\tbfqq->new_bfqq = new_bfqq;\n\tnew_bfqq->ref += process_refs;\n\treturn new_bfqq;\n}\n\nstatic bool bfq_may_be_close_cooperator(struct bfq_queue *bfqq,\n\t\t\t\t\tstruct bfq_queue *new_bfqq)\n{\n\tif (bfq_too_late_for_merging(new_bfqq))\n\t\treturn false;\n\n\tif (bfq_class_idle(bfqq) || bfq_class_idle(new_bfqq) ||\n\t    (bfqq->ioprio_class != new_bfqq->ioprio_class))\n\t\treturn false;\n\n\t/*\n\t * If either of the queues has already been detected as seeky,\n\t * then merging it with the other queue is unlikely to lead to\n\t * sequential I/O.\n\t */\n\tif (BFQQ_SEEKY(bfqq) || BFQQ_SEEKY(new_bfqq))\n\t\treturn false;\n\n\t/*\n\t * Interleaved I/O is known to be done by (some) applications\n\t * only for reads, so it does not make sense to merge async\n\t * queues.\n\t */\n\tif (!bfq_bfqq_sync(bfqq) || !bfq_bfqq_sync(new_bfqq))\n\t\treturn false;\n\n\treturn true;\n}\n\n/*\n * Attempt to schedule a merge of bfqq with the currently in-service\n * queue or with a close queue among the scheduled queues.  Return\n * NULL if no merge was scheduled, a pointer to the shared bfq_queue\n * structure otherwise.\n *\n * The OOM queue is not allowed to participate to cooperation: in fact, since\n * the requests temporarily redirected to the OOM queue could be redirected\n * again to dedicated queues at any time, the state needed to correctly\n * handle merging with the OOM queue would be quite complex and expensive\n * to maintain. Besides, in such a critical condition as an out of memory,\n * the benefits of queue merging may be little relevant, or even negligible.\n *\n * WARNING: queue merging may impair fairness among non-weight raised\n * queues, for at least two reasons: 1) the original weight of a\n * merged queue may change during the merged state, 2) even being the\n * weight the same, a merged queue may be bloated with many more\n * requests than the ones produced by its originally-associated\n * process.\n */\nstatic struct bfq_queue *\nbfq_setup_cooperator(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t     void *io_struct, bool request)\n{\n\tstruct bfq_queue *in_service_bfqq, *new_bfqq;\n\n\t/*\n\t * Do not perform queue merging if the device is non\n\t * rotational and performs internal queueing. In fact, such a\n\t * device reaches a high speed through internal parallelism\n\t * and pipelining. This means that, to reach a high\n\t * throughput, it must have many requests enqueued at the same\n\t * time. But, in this configuration, the internal scheduling\n\t * algorithm of the device does exactly the job of queue\n\t * merging: it reorders requests so as to obtain as much as\n\t * possible a sequential I/O pattern. As a consequence, with\n\t * the workload generated by processes doing interleaved I/O,\n\t * the throughput reached by the device is likely to be the\n\t * same, with and without queue merging.\n\t *\n\t * Disabling merging also provides a remarkable benefit in\n\t * terms of throughput. Merging tends to make many workloads\n\t * artificially more uneven, because of shared queues\n\t * remaining non empty for incomparably more time than\n\t * non-merged queues. This may accentuate workload\n\t * asymmetries. For example, if one of the queues in a set of\n\t * merged queues has a higher weight than a normal queue, then\n\t * the shared queue may inherit such a high weight and, by\n\t * staying almost always active, may force BFQ to perform I/O\n\t * plugging most of the time. This evidently makes it harder\n\t * for BFQ to let the device reach a high throughput.\n\t *\n\t * Finally, the likely() macro below is not used because one\n\t * of the two branches is more likely than the other, but to\n\t * have the code path after the following if() executed as\n\t * fast as possible for the case of a non rotational device\n\t * with queueing. We want it because this is the fastest kind\n\t * of device. On the opposite end, the likely() may lengthen\n\t * the execution time of BFQ for the case of slower devices\n\t * (rotational or at least without queueing). But in this case\n\t * the execution time of BFQ matters very little, if not at\n\t * all.\n\t */\n\tif (likely(bfqd->nonrot_with_queueing))\n\t\treturn NULL;\n\n\t/*\n\t * Prevent bfqq from being merged if it has been created too\n\t * long ago. The idea is that true cooperating processes, and\n\t * thus their associated bfq_queues, are supposed to be\n\t * created shortly after each other. This is the case, e.g.,\n\t * for KVM/QEMU and dump I/O threads. Basing on this\n\t * assumption, the following filtering greatly reduces the\n\t * probability that two non-cooperating processes, which just\n\t * happen to do close I/O for some short time interval, have\n\t * their queues merged by mistake.\n\t */\n\tif (bfq_too_late_for_merging(bfqq))\n\t\treturn NULL;\n\n\tif (bfqq->new_bfqq)\n\t\treturn bfqq->new_bfqq;\n\n\tif (!io_struct || unlikely(bfqq == &bfqd->oom_bfqq))\n\t\treturn NULL;\n\n\t/* If there is only one backlogged queue, don't search. */\n\tif (bfq_tot_busy_queues(bfqd) == 1)\n\t\treturn NULL;\n\n\tin_service_bfqq = bfqd->in_service_queue;\n\n\tif (in_service_bfqq && in_service_bfqq != bfqq &&\n\t    likely(in_service_bfqq != &bfqd->oom_bfqq) &&\n\t    bfq_rq_close_to_sector(io_struct, request,\n\t\t\t\t   bfqd->in_serv_last_pos) &&\n\t    bfqq->entity.parent == in_service_bfqq->entity.parent &&\n\t    bfq_may_be_close_cooperator(bfqq, in_service_bfqq)) {\n\t\tnew_bfqq = bfq_setup_merge(bfqq, in_service_bfqq);\n\t\tif (new_bfqq)\n\t\t\treturn new_bfqq;\n\t}\n\t/*\n\t * Check whether there is a cooperator among currently scheduled\n\t * queues. The only thing we need is that the bio/request is not\n\t * NULL, as we need it to establish whether a cooperator exists.\n\t */\n\tnew_bfqq = bfq_find_close_cooperator(bfqd, bfqq,\n\t\t\tbfq_io_struct_pos(io_struct, request));\n\n\tif (new_bfqq && likely(new_bfqq != &bfqd->oom_bfqq) &&\n\t    bfq_may_be_close_cooperator(bfqq, new_bfqq))\n\t\treturn bfq_setup_merge(bfqq, new_bfqq);\n\n\treturn NULL;\n}\n\nstatic void bfq_bfqq_save_state(struct bfq_queue *bfqq)\n{\n\tstruct bfq_io_cq *bic = bfqq->bic;\n\n\t/*\n\t * If !bfqq->bic, the queue is already shared or its requests\n\t * have already been redirected to a shared queue; both idle window\n\t * and weight raising state have already been saved. Do nothing.\n\t */\n\tif (!bic)\n\t\treturn;\n\n\tbic->saved_weight = bfqq->entity.orig_weight;\n\tbic->saved_ttime = bfqq->ttime;\n\tbic->saved_has_short_ttime = bfq_bfqq_has_short_ttime(bfqq);\n\tbic->saved_IO_bound = bfq_bfqq_IO_bound(bfqq);\n\tbic->saved_in_large_burst = bfq_bfqq_in_large_burst(bfqq);\n\tbic->was_in_burst_list = !hlist_unhashed(&bfqq->burst_list_node);\n\tif (unlikely(bfq_bfqq_just_created(bfqq) &&\n\t\t     !bfq_bfqq_in_large_burst(bfqq) &&\n\t\t     bfqq->bfqd->low_latency)) {\n\t\t/*\n\t\t * bfqq being merged right after being created: bfqq\n\t\t * would have deserved interactive weight raising, but\n\t\t * did not make it to be set in a weight-raised state,\n\t\t * because of this early merge.\tStore directly the\n\t\t * weight-raising state that would have been assigned\n\t\t * to bfqq, so that to avoid that bfqq unjustly fails\n\t\t * to enjoy weight raising if split soon.\n\t\t */\n\t\tbic->saved_wr_coeff = bfqq->bfqd->bfq_wr_coeff;\n\t\tbic->saved_wr_start_at_switch_to_srt = bfq_smallest_from_now();\n\t\tbic->saved_wr_cur_max_time = bfq_wr_duration(bfqq->bfqd);\n\t\tbic->saved_last_wr_start_finish = jiffies;\n\t} else {\n\t\tbic->saved_wr_coeff = bfqq->wr_coeff;\n\t\tbic->saved_wr_start_at_switch_to_srt =\n\t\t\tbfqq->wr_start_at_switch_to_srt;\n\t\tbic->saved_last_wr_start_finish = bfqq->last_wr_start_finish;\n\t\tbic->saved_wr_cur_max_time = bfqq->wr_cur_max_time;\n\t}\n}\n\n\nstatic\nvoid bfq_release_process_ref(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\t/*\n\t * To prevent bfqq's service guarantees from being violated,\n\t * bfqq may be left busy, i.e., queued for service, even if\n\t * empty (see comments in __bfq_bfqq_expire() for\n\t * details). But, if no process will send requests to bfqq any\n\t * longer, then there is no point in keeping bfqq queued for\n\t * service. In addition, keeping bfqq queued for service, but\n\t * with no process ref any longer, may have caused bfqq to be\n\t * freed when dequeued from service. But this is assumed to\n\t * never happen.\n\t */\n\tif (bfq_bfqq_busy(bfqq) && RB_EMPTY_ROOT(&bfqq->sort_list) &&\n\t    bfqq != bfqd->in_service_queue)\n\t\tbfq_del_bfqq_busy(bfqd, bfqq, false);\n\n\tbfq_put_queue(bfqq);\n}\n\nstatic void\nbfq_merge_bfqqs(struct bfq_data *bfqd, struct bfq_io_cq *bic,\n\t\tstruct bfq_queue *bfqq, struct bfq_queue *new_bfqq)\n{\n\tbfq_log_bfqq(bfqd, bfqq, \"merging with queue %lu\",\n\t\t(unsigned long)new_bfqq->pid);\n\t/* Save weight raising and idle window of the merged queues */\n\tbfq_bfqq_save_state(bfqq);\n\tbfq_bfqq_save_state(new_bfqq);\n\tif (bfq_bfqq_IO_bound(bfqq))\n\t\tbfq_mark_bfqq_IO_bound(new_bfqq);\n\tbfq_clear_bfqq_IO_bound(bfqq);\n\n\t/*\n\t * If bfqq is weight-raised, then let new_bfqq inherit\n\t * weight-raising. To reduce false positives, neglect the case\n\t * where bfqq has just been created, but has not yet made it\n\t * to be weight-raised (which may happen because EQM may merge\n\t * bfqq even before bfq_add_request is executed for the first\n\t * time for bfqq). Handling this case would however be very\n\t * easy, thanks to the flag just_created.\n\t */\n\tif (new_bfqq->wr_coeff == 1 && bfqq->wr_coeff > 1) {\n\t\tnew_bfqq->wr_coeff = bfqq->wr_coeff;\n\t\tnew_bfqq->wr_cur_max_time = bfqq->wr_cur_max_time;\n\t\tnew_bfqq->last_wr_start_finish = bfqq->last_wr_start_finish;\n\t\tnew_bfqq->wr_start_at_switch_to_srt =\n\t\t\tbfqq->wr_start_at_switch_to_srt;\n\t\tif (bfq_bfqq_busy(new_bfqq))\n\t\t\tbfqd->wr_busy_queues++;\n\t\tnew_bfqq->entity.prio_changed = 1;\n\t}\n\n\tif (bfqq->wr_coeff > 1) { /* bfqq has given its wr to new_bfqq */\n\t\tbfqq->wr_coeff = 1;\n\t\tbfqq->entity.prio_changed = 1;\n\t\tif (bfq_bfqq_busy(bfqq))\n\t\t\tbfqd->wr_busy_queues--;\n\t}\n\n\tbfq_log_bfqq(bfqd, new_bfqq, \"merge_bfqqs: wr_busy %d\",\n\t\t     bfqd->wr_busy_queues);\n\n\t/*\n\t * Merge queues (that is, let bic redirect its requests to new_bfqq)\n\t */\n\tbic_set_bfqq(bic, new_bfqq, 1);\n\tbfq_mark_bfqq_coop(new_bfqq);\n\t/*\n\t * new_bfqq now belongs to at least two bics (it is a shared queue):\n\t * set new_bfqq->bic to NULL. bfqq either:\n\t * - does not belong to any bic any more, and hence bfqq->bic must\n\t *   be set to NULL, or\n\t * - is a queue whose owning bics have already been redirected to a\n\t *   different queue, hence the queue is destined to not belong to\n\t *   any bic soon and bfqq->bic is already NULL (therefore the next\n\t *   assignment causes no harm).\n\t */\n\tnew_bfqq->bic = NULL;\n\t/*\n\t * If the queue is shared, the pid is the pid of one of the associated\n\t * processes. Which pid depends on the exact sequence of merge events\n\t * the queue underwent. So printing such a pid is useless and confusing\n\t * because it reports a random pid between those of the associated\n\t * processes.\n\t * We mark such a queue with a pid -1, and then print SHARED instead of\n\t * a pid in logging messages.\n\t */\n\tnew_bfqq->pid = -1;\n\tbfqq->bic = NULL;\n\tbfq_release_process_ref(bfqd, bfqq);\n}\n\nstatic bool bfq_allow_bio_merge(struct request_queue *q, struct request *rq,\n\t\t\t\tstruct bio *bio)\n{\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\tbool is_sync = op_is_sync(bio->bi_opf);\n\tstruct bfq_queue *bfqq = bfqd->bio_bfqq, *new_bfqq;\n\n\t/*\n\t * Disallow merge of a sync bio into an async request.\n\t */\n\tif (is_sync && !rq_is_sync(rq))\n\t\treturn false;\n\n\t/*\n\t * Lookup the bfqq that this bio will be queued with. Allow\n\t * merge only if rq is queued there.\n\t */\n\tif (!bfqq)\n\t\treturn false;\n\n\t/*\n\t * We take advantage of this function to perform an early merge\n\t * of the queues of possible cooperating processes.\n\t */\n\tnew_bfqq = bfq_setup_cooperator(bfqd, bfqq, bio, false);\n\tif (new_bfqq) {\n\t\t/*\n\t\t * bic still points to bfqq, then it has not yet been\n\t\t * redirected to some other bfq_queue, and a queue\n\t\t * merge between bfqq and new_bfqq can be safely\n\t\t * fulfilled, i.e., bic can be redirected to new_bfqq\n\t\t * and bfqq can be put.\n\t\t */\n\t\tbfq_merge_bfqqs(bfqd, bfqd->bio_bic, bfqq,\n\t\t\t\tnew_bfqq);\n\t\t/*\n\t\t * If we get here, bio will be queued into new_queue,\n\t\t * so use new_bfqq to decide whether bio and rq can be\n\t\t * merged.\n\t\t */\n\t\tbfqq = new_bfqq;\n\n\t\t/*\n\t\t * Change also bqfd->bio_bfqq, as\n\t\t * bfqd->bio_bic now points to new_bfqq, and\n\t\t * this function may be invoked again (and then may\n\t\t * use again bqfd->bio_bfqq).\n\t\t */\n\t\tbfqd->bio_bfqq = bfqq;\n\t}\n\n\treturn bfqq == RQ_BFQQ(rq);\n}\n\n/*\n * Set the maximum time for the in-service queue to consume its\n * budget. This prevents seeky processes from lowering the throughput.\n * In practice, a time-slice service scheme is used with seeky\n * processes.\n */\nstatic void bfq_set_budget_timeout(struct bfq_data *bfqd,\n\t\t\t\t   struct bfq_queue *bfqq)\n{\n\tunsigned int timeout_coeff;\n\n\tif (bfqq->wr_cur_max_time == bfqd->bfq_wr_rt_max_time)\n\t\ttimeout_coeff = 1;\n\telse\n\t\ttimeout_coeff = bfqq->entity.weight / bfqq->entity.orig_weight;\n\n\tbfqd->last_budget_start = ktime_get();\n\n\tbfqq->budget_timeout = jiffies +\n\t\tbfqd->bfq_timeout * timeout_coeff;\n}\n\nstatic void __bfq_set_in_service_queue(struct bfq_data *bfqd,\n\t\t\t\t       struct bfq_queue *bfqq)\n{\n\tif (bfqq) {\n\t\tbfq_clear_bfqq_fifo_expire(bfqq);\n\n\t\tbfqd->budgets_assigned = (bfqd->budgets_assigned * 7 + 256) / 8;\n\n\t\tif (time_is_before_jiffies(bfqq->last_wr_start_finish) &&\n\t\t    bfqq->wr_coeff > 1 &&\n\t\t    bfqq->wr_cur_max_time == bfqd->bfq_wr_rt_max_time &&\n\t\t    time_is_before_jiffies(bfqq->budget_timeout)) {\n\t\t\t/*\n\t\t\t * For soft real-time queues, move the start\n\t\t\t * of the weight-raising period forward by the\n\t\t\t * time the queue has not received any\n\t\t\t * service. Otherwise, a relatively long\n\t\t\t * service delay is likely to cause the\n\t\t\t * weight-raising period of the queue to end,\n\t\t\t * because of the short duration of the\n\t\t\t * weight-raising period of a soft real-time\n\t\t\t * queue.  It is worth noting that this move\n\t\t\t * is not so dangerous for the other queues,\n\t\t\t * because soft real-time queues are not\n\t\t\t * greedy.\n\t\t\t *\n\t\t\t * To not add a further variable, we use the\n\t\t\t * overloaded field budget_timeout to\n\t\t\t * determine for how long the queue has not\n\t\t\t * received service, i.e., how much time has\n\t\t\t * elapsed since the queue expired. However,\n\t\t\t * this is a little imprecise, because\n\t\t\t * budget_timeout is set to jiffies if bfqq\n\t\t\t * not only expires, but also remains with no\n\t\t\t * request.\n\t\t\t */\n\t\t\tif (time_after(bfqq->budget_timeout,\n\t\t\t\t       bfqq->last_wr_start_finish))\n\t\t\t\tbfqq->last_wr_start_finish +=\n\t\t\t\t\tjiffies - bfqq->budget_timeout;\n\t\t\telse\n\t\t\t\tbfqq->last_wr_start_finish = jiffies;\n\t\t}\n\n\t\tbfq_set_budget_timeout(bfqd, bfqq);\n\t\tbfq_log_bfqq(bfqd, bfqq,\n\t\t\t     \"set_in_service_queue, cur-budget = %d\",\n\t\t\t     bfqq->entity.budget);\n\t}\n\n\tbfqd->in_service_queue = bfqq;\n}\n\n/*\n * Get and set a new queue for service.\n */\nstatic struct bfq_queue *bfq_set_in_service_queue(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq = bfq_get_next_queue(bfqd);\n\n\t__bfq_set_in_service_queue(bfqd, bfqq);\n\treturn bfqq;\n}\n\nstatic void bfq_arm_slice_timer(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq = bfqd->in_service_queue;\n\tu32 sl;\n\n\tbfq_mark_bfqq_wait_request(bfqq);\n\n\t/*\n\t * We don't want to idle for seeks, but we do want to allow\n\t * fair distribution of slice time for a process doing back-to-back\n\t * seeks. So allow a little bit of time for him to submit a new rq.\n\t */\n\tsl = bfqd->bfq_slice_idle;\n\t/*\n\t * Unless the queue is being weight-raised or the scenario is\n\t * asymmetric, grant only minimum idle time if the queue\n\t * is seeky. A long idling is preserved for a weight-raised\n\t * queue, or, more in general, in an asymmetric scenario,\n\t * because a long idling is needed for guaranteeing to a queue\n\t * its reserved share of the throughput (in particular, it is\n\t * needed if the queue has a higher weight than some other\n\t * queue).\n\t */\n\tif (BFQQ_SEEKY(bfqq) && bfqq->wr_coeff == 1 &&\n\t    !bfq_asymmetric_scenario(bfqd, bfqq))\n\t\tsl = min_t(u64, sl, BFQ_MIN_TT);\n\telse if (bfqq->wr_coeff > 1)\n\t\tsl = max_t(u32, sl, 20ULL * NSEC_PER_MSEC);\n\n\tbfqd->last_idling_start = ktime_get();\n\tbfqd->last_idling_start_jiffies = jiffies;\n\n\thrtimer_start(&bfqd->idle_slice_timer, ns_to_ktime(sl),\n\t\t      HRTIMER_MODE_REL);\n\tbfqg_stats_set_start_idle_time(bfqq_group(bfqq));\n}\n\n/*\n * In autotuning mode, max_budget is dynamically recomputed as the\n * amount of sectors transferred in timeout at the estimated peak\n * rate. This enables BFQ to utilize a full timeslice with a full\n * budget, even if the in-service queue is served at peak rate. And\n * this maximises throughput with sequential workloads.\n */\nstatic unsigned long bfq_calc_max_budget(struct bfq_data *bfqd)\n{\n\treturn (u64)bfqd->peak_rate * USEC_PER_MSEC *\n\t\tjiffies_to_msecs(bfqd->bfq_timeout)>>BFQ_RATE_SHIFT;\n}\n\n/*\n * Update parameters related to throughput and responsiveness, as a\n * function of the estimated peak rate. See comments on\n * bfq_calc_max_budget(), and on the ref_wr_duration array.\n */\nstatic void update_thr_responsiveness_params(struct bfq_data *bfqd)\n{\n\tif (bfqd->bfq_user_max_budget == 0) {\n\t\tbfqd->bfq_max_budget =\n\t\t\tbfq_calc_max_budget(bfqd);\n\t\tbfq_log(bfqd, \"new max_budget = %d\", bfqd->bfq_max_budget);\n\t}\n}\n\nstatic void bfq_reset_rate_computation(struct bfq_data *bfqd,\n\t\t\t\t       struct request *rq)\n{\n\tif (rq != NULL) { /* new rq dispatch now, reset accordingly */\n\t\tbfqd->last_dispatch = bfqd->first_dispatch = ktime_get_ns();\n\t\tbfqd->peak_rate_samples = 1;\n\t\tbfqd->sequential_samples = 0;\n\t\tbfqd->tot_sectors_dispatched = bfqd->last_rq_max_size =\n\t\t\tblk_rq_sectors(rq);\n\t} else /* no new rq dispatched, just reset the number of samples */\n\t\tbfqd->peak_rate_samples = 0; /* full re-init on next disp. */\n\n\tbfq_log(bfqd,\n\t\t\"reset_rate_computation at end, sample %u/%u tot_sects %llu\",\n\t\tbfqd->peak_rate_samples, bfqd->sequential_samples,\n\t\tbfqd->tot_sectors_dispatched);\n}\n\nstatic void bfq_update_rate_reset(struct bfq_data *bfqd, struct request *rq)\n{\n\tu32 rate, weight, divisor;\n\n\t/*\n\t * For the convergence property to hold (see comments on\n\t * bfq_update_peak_rate()) and for the assessment to be\n\t * reliable, a minimum number of samples must be present, and\n\t * a minimum amount of time must have elapsed. If not so, do\n\t * not compute new rate. Just reset parameters, to get ready\n\t * for a new evaluation attempt.\n\t */\n\tif (bfqd->peak_rate_samples < BFQ_RATE_MIN_SAMPLES ||\n\t    bfqd->delta_from_first < BFQ_RATE_MIN_INTERVAL)\n\t\tgoto reset_computation;\n\n\t/*\n\t * If a new request completion has occurred after last\n\t * dispatch, then, to approximate the rate at which requests\n\t * have been served by the device, it is more precise to\n\t * extend the observation interval to the last completion.\n\t */\n\tbfqd->delta_from_first =\n\t\tmax_t(u64, bfqd->delta_from_first,\n\t\t      bfqd->last_completion - bfqd->first_dispatch);\n\n\t/*\n\t * Rate computed in sects/usec, and not sects/nsec, for\n\t * precision issues.\n\t */\n\trate = div64_ul(bfqd->tot_sectors_dispatched<<BFQ_RATE_SHIFT,\n\t\t\tdiv_u64(bfqd->delta_from_first, NSEC_PER_USEC));\n\n\t/*\n\t * Peak rate not updated if:\n\t * - the percentage of sequential dispatches is below 3/4 of the\n\t *   total, and rate is below the current estimated peak rate\n\t * - rate is unreasonably high (> 20M sectors/sec)\n\t */\n\tif ((bfqd->sequential_samples < (3 * bfqd->peak_rate_samples)>>2 &&\n\t     rate <= bfqd->peak_rate) ||\n\t\trate > 20<<BFQ_RATE_SHIFT)\n\t\tgoto reset_computation;\n\n\t/*\n\t * We have to update the peak rate, at last! To this purpose,\n\t * we use a low-pass filter. We compute the smoothing constant\n\t * of the filter as a function of the 'weight' of the new\n\t * measured rate.\n\t *\n\t * As can be seen in next formulas, we define this weight as a\n\t * quantity proportional to how sequential the workload is,\n\t * and to how long the observation time interval is.\n\t *\n\t * The weight runs from 0 to 8. The maximum value of the\n\t * weight, 8, yields the minimum value for the smoothing\n\t * constant. At this minimum value for the smoothing constant,\n\t * the measured rate contributes for half of the next value of\n\t * the estimated peak rate.\n\t *\n\t * So, the first step is to compute the weight as a function\n\t * of how sequential the workload is. Note that the weight\n\t * cannot reach 9, because bfqd->sequential_samples cannot\n\t * become equal to bfqd->peak_rate_samples, which, in its\n\t * turn, holds true because bfqd->sequential_samples is not\n\t * incremented for the first sample.\n\t */\n\tweight = (9 * bfqd->sequential_samples) / bfqd->peak_rate_samples;\n\n\t/*\n\t * Second step: further refine the weight as a function of the\n\t * duration of the observation interval.\n\t */\n\tweight = min_t(u32, 8,\n\t\t       div_u64(weight * bfqd->delta_from_first,\n\t\t\t       BFQ_RATE_REF_INTERVAL));\n\n\t/*\n\t * Divisor ranging from 10, for minimum weight, to 2, for\n\t * maximum weight.\n\t */\n\tdivisor = 10 - weight;\n\n\t/*\n\t * Finally, update peak rate:\n\t *\n\t * peak_rate = peak_rate * (divisor-1) / divisor  +  rate / divisor\n\t */\n\tbfqd->peak_rate *= divisor-1;\n\tbfqd->peak_rate /= divisor;\n\trate /= divisor; /* smoothing constant alpha = 1/divisor */\n\n\tbfqd->peak_rate += rate;\n\n\t/*\n\t * For a very slow device, bfqd->peak_rate can reach 0 (see\n\t * the minimum representable values reported in the comments\n\t * on BFQ_RATE_SHIFT). Push to 1 if this happens, to avoid\n\t * divisions by zero where bfqd->peak_rate is used as a\n\t * divisor.\n\t */\n\tbfqd->peak_rate = max_t(u32, 1, bfqd->peak_rate);\n\n\tupdate_thr_responsiveness_params(bfqd);\n\nreset_computation:\n\tbfq_reset_rate_computation(bfqd, rq);\n}\n\n/*\n * Update the read/write peak rate (the main quantity used for\n * auto-tuning, see update_thr_responsiveness_params()).\n *\n * It is not trivial to estimate the peak rate (correctly): because of\n * the presence of sw and hw queues between the scheduler and the\n * device components that finally serve I/O requests, it is hard to\n * say exactly when a given dispatched request is served inside the\n * device, and for how long. As a consequence, it is hard to know\n * precisely at what rate a given set of requests is actually served\n * by the device.\n *\n * On the opposite end, the dispatch time of any request is trivially\n * available, and, from this piece of information, the \"dispatch rate\"\n * of requests can be immediately computed. So, the idea in the next\n * function is to use what is known, namely request dispatch times\n * (plus, when useful, request completion times), to estimate what is\n * unknown, namely in-device request service rate.\n *\n * The main issue is that, because of the above facts, the rate at\n * which a certain set of requests is dispatched over a certain time\n * interval can vary greatly with respect to the rate at which the\n * same requests are then served. But, since the size of any\n * intermediate queue is limited, and the service scheme is lossless\n * (no request is silently dropped), the following obvious convergence\n * property holds: the number of requests dispatched MUST become\n * closer and closer to the number of requests completed as the\n * observation interval grows. This is the key property used in\n * the next function to estimate the peak service rate as a function\n * of the observed dispatch rate. The function assumes to be invoked\n * on every request dispatch.\n */\nstatic void bfq_update_peak_rate(struct bfq_data *bfqd, struct request *rq)\n{\n\tu64 now_ns = ktime_get_ns();\n\n\tif (bfqd->peak_rate_samples == 0) { /* first dispatch */\n\t\tbfq_log(bfqd, \"update_peak_rate: goto reset, samples %d\",\n\t\t\tbfqd->peak_rate_samples);\n\t\tbfq_reset_rate_computation(bfqd, rq);\n\t\tgoto update_last_values; /* will add one sample */\n\t}\n\n\t/*\n\t * Device idle for very long: the observation interval lasting\n\t * up to this dispatch cannot be a valid observation interval\n\t * for computing a new peak rate (similarly to the late-\n\t * completion event in bfq_completed_request()). Go to\n\t * update_rate_and_reset to have the following three steps\n\t * taken:\n\t * - close the observation interval at the last (previous)\n\t *   request dispatch or completion\n\t * - compute rate, if possible, for that observation interval\n\t * - start a new observation interval with this dispatch\n\t */\n\tif (now_ns - bfqd->last_dispatch > 100*NSEC_PER_MSEC &&\n\t    bfqd->rq_in_driver == 0)\n\t\tgoto update_rate_and_reset;\n\n\t/* Update sampling information */\n\tbfqd->peak_rate_samples++;\n\n\tif ((bfqd->rq_in_driver > 0 ||\n\t\tnow_ns - bfqd->last_completion < BFQ_MIN_TT)\n\t    && !BFQ_RQ_SEEKY(bfqd, bfqd->last_position, rq))\n\t\tbfqd->sequential_samples++;\n\n\tbfqd->tot_sectors_dispatched += blk_rq_sectors(rq);\n\n\t/* Reset max observed rq size every 32 dispatches */\n\tif (likely(bfqd->peak_rate_samples % 32))\n\t\tbfqd->last_rq_max_size =\n\t\t\tmax_t(u32, blk_rq_sectors(rq), bfqd->last_rq_max_size);\n\telse\n\t\tbfqd->last_rq_max_size = blk_rq_sectors(rq);\n\n\tbfqd->delta_from_first = now_ns - bfqd->first_dispatch;\n\n\t/* Target observation interval not yet reached, go on sampling */\n\tif (bfqd->delta_from_first < BFQ_RATE_REF_INTERVAL)\n\t\tgoto update_last_values;\n\nupdate_rate_and_reset:\n\tbfq_update_rate_reset(bfqd, rq);\nupdate_last_values:\n\tbfqd->last_position = blk_rq_pos(rq) + blk_rq_sectors(rq);\n\tif (RQ_BFQQ(rq) == bfqd->in_service_queue)\n\t\tbfqd->in_serv_last_pos = bfqd->last_position;\n\tbfqd->last_dispatch = now_ns;\n}\n\n/*\n * Remove request from internal lists.\n */\nstatic void bfq_dispatch_remove(struct request_queue *q, struct request *rq)\n{\n\tstruct bfq_queue *bfqq = RQ_BFQQ(rq);\n\n\t/*\n\t * For consistency, the next instruction should have been\n\t * executed after removing the request from the queue and\n\t * dispatching it.  We execute instead this instruction before\n\t * bfq_remove_request() (and hence introduce a temporary\n\t * inconsistency), for efficiency.  In fact, should this\n\t * dispatch occur for a non in-service bfqq, this anticipated\n\t * increment prevents two counters related to bfqq->dispatched\n\t * from risking to be, first, uselessly decremented, and then\n\t * incremented again when the (new) value of bfqq->dispatched\n\t * happens to be taken into account.\n\t */\n\tbfqq->dispatched++;\n\tbfq_update_peak_rate(q->elevator->elevator_data, rq);\n\n\tbfq_remove_request(q, rq);\n}\n\n/*\n * There is a case where idling does not have to be performed for\n * throughput concerns, but to preserve the throughput share of\n * the process associated with bfqq.\n *\n * To introduce this case, we can note that allowing the drive\n * to enqueue more than one request at a time, and hence\n * delegating de facto final scheduling decisions to the\n * drive's internal scheduler, entails loss of control on the\n * actual request service order. In particular, the critical\n * situation is when requests from different processes happen\n * to be present, at the same time, in the internal queue(s)\n * of the drive. In such a situation, the drive, by deciding\n * the service order of the internally-queued requests, does\n * determine also the actual throughput distribution among\n * these processes. But the drive typically has no notion or\n * concern about per-process throughput distribution, and\n * makes its decisions only on a per-request basis. Therefore,\n * the service distribution enforced by the drive's internal\n * scheduler is likely to coincide with the desired throughput\n * distribution only in a completely symmetric, or favorably\n * skewed scenario where:\n * (i-a) each of these processes must get the same throughput as\n *\t the others,\n * (i-b) in case (i-a) does not hold, it holds that the process\n *       associated with bfqq must receive a lower or equal\n *\t throughput than any of the other processes;\n * (ii)  the I/O of each process has the same properties, in\n *       terms of locality (sequential or random), direction\n *       (reads or writes), request sizes, greediness\n *       (from I/O-bound to sporadic), and so on;\n\n * In fact, in such a scenario, the drive tends to treat the requests\n * of each process in about the same way as the requests of the\n * others, and thus to provide each of these processes with about the\n * same throughput.  This is exactly the desired throughput\n * distribution if (i-a) holds, or, if (i-b) holds instead, this is an\n * even more convenient distribution for (the process associated with)\n * bfqq.\n *\n * In contrast, in any asymmetric or unfavorable scenario, device\n * idling (I/O-dispatch plugging) is certainly needed to guarantee\n * that bfqq receives its assigned fraction of the device throughput\n * (see [1] for details).\n *\n * The problem is that idling may significantly reduce throughput with\n * certain combinations of types of I/O and devices. An important\n * example is sync random I/O on flash storage with command\n * queueing. So, unless bfqq falls in cases where idling also boosts\n * throughput, it is important to check conditions (i-a), i(-b) and\n * (ii) accurately, so as to avoid idling when not strictly needed for\n * service guarantees.\n *\n * Unfortunately, it is extremely difficult to thoroughly check\n * condition (ii). And, in case there are active groups, it becomes\n * very difficult to check conditions (i-a) and (i-b) too.  In fact,\n * if there are active groups, then, for conditions (i-a) or (i-b) to\n * become false 'indirectly', it is enough that an active group\n * contains more active processes or sub-groups than some other active\n * group. More precisely, for conditions (i-a) or (i-b) to become\n * false because of such a group, it is not even necessary that the\n * group is (still) active: it is sufficient that, even if the group\n * has become inactive, some of its descendant processes still have\n * some request already dispatched but still waiting for\n * completion. In fact, requests have still to be guaranteed their\n * share of the throughput even after being dispatched. In this\n * respect, it is easy to show that, if a group frequently becomes\n * inactive while still having in-flight requests, and if, when this\n * happens, the group is not considered in the calculation of whether\n * the scenario is asymmetric, then the group may fail to be\n * guaranteed its fair share of the throughput (basically because\n * idling may not be performed for the descendant processes of the\n * group, but it had to be).  We address this issue with the following\n * bi-modal behavior, implemented in the function\n * bfq_asymmetric_scenario().\n *\n * If there are groups with requests waiting for completion\n * (as commented above, some of these groups may even be\n * already inactive), then the scenario is tagged as\n * asymmetric, conservatively, without checking any of the\n * conditions (i-a), (i-b) or (ii). So the device is idled for bfqq.\n * This behavior matches also the fact that groups are created\n * exactly if controlling I/O is a primary concern (to\n * preserve bandwidth and latency guarantees).\n *\n * On the opposite end, if there are no groups with requests waiting\n * for completion, then only conditions (i-a) and (i-b) are actually\n * controlled, i.e., provided that conditions (i-a) or (i-b) holds,\n * idling is not performed, regardless of whether condition (ii)\n * holds.  In other words, only if conditions (i-a) and (i-b) do not\n * hold, then idling is allowed, and the device tends to be prevented\n * from queueing many requests, possibly of several processes. Since\n * there are no groups with requests waiting for completion, then, to\n * control conditions (i-a) and (i-b) it is enough to check just\n * whether all the queues with requests waiting for completion also\n * have the same weight.\n *\n * Not checking condition (ii) evidently exposes bfqq to the\n * risk of getting less throughput than its fair share.\n * However, for queues with the same weight, a further\n * mechanism, preemption, mitigates or even eliminates this\n * problem. And it does so without consequences on overall\n * throughput. This mechanism and its benefits are explained\n * in the next three paragraphs.\n *\n * Even if a queue, say Q, is expired when it remains idle, Q\n * can still preempt the new in-service queue if the next\n * request of Q arrives soon (see the comments on\n * bfq_bfqq_update_budg_for_activation). If all queues and\n * groups have the same weight, this form of preemption,\n * combined with the hole-recovery heuristic described in the\n * comments on function bfq_bfqq_update_budg_for_activation,\n * are enough to preserve a correct bandwidth distribution in\n * the mid term, even without idling. In fact, even if not\n * idling allows the internal queues of the device to contain\n * many requests, and thus to reorder requests, we can rather\n * safely assume that the internal scheduler still preserves a\n * minimum of mid-term fairness.\n *\n * More precisely, this preemption-based, idleless approach\n * provides fairness in terms of IOPS, and not sectors per\n * second. This can be seen with a simple example. Suppose\n * that there are two queues with the same weight, but that\n * the first queue receives requests of 8 sectors, while the\n * second queue receives requests of 1024 sectors. In\n * addition, suppose that each of the two queues contains at\n * most one request at a time, which implies that each queue\n * always remains idle after it is served. Finally, after\n * remaining idle, each queue receives very quickly a new\n * request. It follows that the two queues are served\n * alternatively, preempting each other if needed. This\n * implies that, although both queues have the same weight,\n * the queue with large requests receives a service that is\n * 1024/8 times as high as the service received by the other\n * queue.\n *\n * The motivation for using preemption instead of idling (for\n * queues with the same weight) is that, by not idling,\n * service guarantees are preserved (completely or at least in\n * part) without minimally sacrificing throughput. And, if\n * there is no active group, then the primary expectation for\n * this device is probably a high throughput.\n *\n * We are now left only with explaining the two sub-conditions in the\n * additional compound condition that is checked below for deciding\n * whether the scenario is asymmetric. To explain the first\n * sub-condition, we need to add that the function\n * bfq_asymmetric_scenario checks the weights of only\n * non-weight-raised queues, for efficiency reasons (see comments on\n * bfq_weights_tree_add()). Then the fact that bfqq is weight-raised\n * is checked explicitly here. More precisely, the compound condition\n * below takes into account also the fact that, even if bfqq is being\n * weight-raised, the scenario is still symmetric if all queues with\n * requests waiting for completion happen to be\n * weight-raised. Actually, we should be even more precise here, and\n * differentiate between interactive weight raising and soft real-time\n * weight raising.\n *\n * The second sub-condition checked in the compound condition is\n * whether there is a fair amount of already in-flight I/O not\n * belonging to bfqq. If so, I/O dispatching is to be plugged, for the\n * following reason. The drive may decide to serve in-flight\n * non-bfqq's I/O requests before bfqq's ones, thereby delaying the\n * arrival of new I/O requests for bfqq (recall that bfqq is sync). If\n * I/O-dispatching is not plugged, then, while bfqq remains empty, a\n * basically uncontrolled amount of I/O from other queues may be\n * dispatched too, possibly causing the service of bfqq's I/O to be\n * delayed even longer in the drive. This problem gets more and more\n * serious as the speed and the queue depth of the drive grow,\n * because, as these two quantities grow, the probability to find no\n * queue busy but many requests in flight grows too. By contrast,\n * plugging I/O dispatching minimizes the delay induced by already\n * in-flight I/O, and enables bfqq to recover the bandwidth it may\n * lose because of this delay.\n *\n * As a side note, it is worth considering that the above\n * device-idling countermeasures may however fail in the following\n * unlucky scenario: if I/O-dispatch plugging is (correctly) disabled\n * in a time period during which all symmetry sub-conditions hold, and\n * therefore the device is allowed to enqueue many requests, but at\n * some later point in time some sub-condition stops to hold, then it\n * may become impossible to make requests be served in the desired\n * order until all the requests already queued in the device have been\n * served. The last sub-condition commented above somewhat mitigates\n * this problem for weight-raised queues.\n */\nstatic bool idling_needed_for_service_guarantees(struct bfq_data *bfqd,\n\t\t\t\t\t\t struct bfq_queue *bfqq)\n{\n\t/* No point in idling for bfqq if it won't get requests any longer */\n\tif (unlikely(!bfqq_process_refs(bfqq)))\n\t\treturn false;\n\n\treturn (bfqq->wr_coeff > 1 &&\n\t\t(bfqd->wr_busy_queues <\n\t\t bfq_tot_busy_queues(bfqd) ||\n\t\t bfqd->rq_in_driver >=\n\t\t bfqq->dispatched + 4)) ||\n\t\tbfq_asymmetric_scenario(bfqd, bfqq);\n}\n\nstatic bool __bfq_bfqq_expire(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t      enum bfqq_expiration reason)\n{\n\t/*\n\t * If this bfqq is shared between multiple processes, check\n\t * to make sure that those processes are still issuing I/Os\n\t * within the mean seek distance. If not, it may be time to\n\t * break the queues apart again.\n\t */\n\tif (bfq_bfqq_coop(bfqq) && BFQQ_SEEKY(bfqq))\n\t\tbfq_mark_bfqq_split_coop(bfqq);\n\n\t/*\n\t * Consider queues with a higher finish virtual time than\n\t * bfqq. If idling_needed_for_service_guarantees(bfqq) returns\n\t * true, then bfqq's bandwidth would be violated if an\n\t * uncontrolled amount of I/O from these queues were\n\t * dispatched while bfqq is waiting for its new I/O to\n\t * arrive. This is exactly what may happen if this is a forced\n\t * expiration caused by a preemption attempt, and if bfqq is\n\t * not re-scheduled. To prevent this from happening, re-queue\n\t * bfqq if it needs I/O-dispatch plugging, even if it is\n\t * empty. By doing so, bfqq is granted to be served before the\n\t * above queues (provided that bfqq is of course eligible).\n\t */\n\tif (RB_EMPTY_ROOT(&bfqq->sort_list) &&\n\t    !(reason == BFQQE_PREEMPTED &&\n\t      idling_needed_for_service_guarantees(bfqd, bfqq))) {\n\t\tif (bfqq->dispatched == 0)\n\t\t\t/*\n\t\t\t * Overloading budget_timeout field to store\n\t\t\t * the time at which the queue remains with no\n\t\t\t * backlog and no outstanding request; used by\n\t\t\t * the weight-raising mechanism.\n\t\t\t */\n\t\t\tbfqq->budget_timeout = jiffies;\n\n\t\tbfq_del_bfqq_busy(bfqd, bfqq, true);\n\t} else {\n\t\tbfq_requeue_bfqq(bfqd, bfqq, true);\n\t\t/*\n\t\t * Resort priority tree of potential close cooperators.\n\t\t * See comments on bfq_pos_tree_add_move() for the unlikely().\n\t\t */\n\t\tif (unlikely(!bfqd->nonrot_with_queueing &&\n\t\t\t     !RB_EMPTY_ROOT(&bfqq->sort_list)))\n\t\t\tbfq_pos_tree_add_move(bfqd, bfqq);\n\t}\n\n\t/*\n\t * All in-service entities must have been properly deactivated\n\t * or requeued before executing the next function, which\n\t * resets all in-service entities as no more in service. This\n\t * may cause bfqq to be freed. If this happens, the next\n\t * function returns true.\n\t */\n\treturn __bfq_bfqd_reset_in_service(bfqd);\n}\n\n/**\n * __bfq_bfqq_recalc_budget - try to adapt the budget to the @bfqq behavior.\n * @bfqd: device data.\n * @bfqq: queue to update.\n * @reason: reason for expiration.\n *\n * Handle the feedback on @bfqq budget at queue expiration.\n * See the body for detailed comments.\n */\nstatic void __bfq_bfqq_recalc_budget(struct bfq_data *bfqd,\n\t\t\t\t     struct bfq_queue *bfqq,\n\t\t\t\t     enum bfqq_expiration reason)\n{\n\tstruct request *next_rq;\n\tint budget, min_budget;\n\n\tmin_budget = bfq_min_budget(bfqd);\n\n\tif (bfqq->wr_coeff == 1)\n\t\tbudget = bfqq->max_budget;\n\telse /*\n\t      * Use a constant, low budget for weight-raised queues,\n\t      * to help achieve a low latency. Keep it slightly higher\n\t      * than the minimum possible budget, to cause a little\n\t      * bit fewer expirations.\n\t      */\n\t\tbudget = 2 * min_budget;\n\n\tbfq_log_bfqq(bfqd, bfqq, \"recalc_budg: last budg %d, budg left %d\",\n\t\tbfqq->entity.budget, bfq_bfqq_budget_left(bfqq));\n\tbfq_log_bfqq(bfqd, bfqq, \"recalc_budg: last max_budg %d, min budg %d\",\n\t\tbudget, bfq_min_budget(bfqd));\n\tbfq_log_bfqq(bfqd, bfqq, \"recalc_budg: sync %d, seeky %d\",\n\t\tbfq_bfqq_sync(bfqq), BFQQ_SEEKY(bfqd->in_service_queue));\n\n\tif (bfq_bfqq_sync(bfqq) && bfqq->wr_coeff == 1) {\n\t\tswitch (reason) {\n\t\t/*\n\t\t * Caveat: in all the following cases we trade latency\n\t\t * for throughput.\n\t\t */\n\t\tcase BFQQE_TOO_IDLE:\n\t\t\t/*\n\t\t\t * This is the only case where we may reduce\n\t\t\t * the budget: if there is no request of the\n\t\t\t * process still waiting for completion, then\n\t\t\t * we assume (tentatively) that the timer has\n\t\t\t * expired because the batch of requests of\n\t\t\t * the process could have been served with a\n\t\t\t * smaller budget.  Hence, betting that\n\t\t\t * process will behave in the same way when it\n\t\t\t * becomes backlogged again, we reduce its\n\t\t\t * next budget.  As long as we guess right,\n\t\t\t * this budget cut reduces the latency\n\t\t\t * experienced by the process.\n\t\t\t *\n\t\t\t * However, if there are still outstanding\n\t\t\t * requests, then the process may have not yet\n\t\t\t * issued its next request just because it is\n\t\t\t * still waiting for the completion of some of\n\t\t\t * the still outstanding ones.  So in this\n\t\t\t * subcase we do not reduce its budget, on the\n\t\t\t * contrary we increase it to possibly boost\n\t\t\t * the throughput, as discussed in the\n\t\t\t * comments to the BUDGET_TIMEOUT case.\n\t\t\t */\n\t\t\tif (bfqq->dispatched > 0) /* still outstanding reqs */\n\t\t\t\tbudget = min(budget * 2, bfqd->bfq_max_budget);\n\t\t\telse {\n\t\t\t\tif (budget > 5 * min_budget)\n\t\t\t\t\tbudget -= 4 * min_budget;\n\t\t\t\telse\n\t\t\t\t\tbudget = min_budget;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BFQQE_BUDGET_TIMEOUT:\n\t\t\t/*\n\t\t\t * We double the budget here because it gives\n\t\t\t * the chance to boost the throughput if this\n\t\t\t * is not a seeky process (and has bumped into\n\t\t\t * this timeout because of, e.g., ZBR).\n\t\t\t */\n\t\t\tbudget = min(budget * 2, bfqd->bfq_max_budget);\n\t\t\tbreak;\n\t\tcase BFQQE_BUDGET_EXHAUSTED:\n\t\t\t/*\n\t\t\t * The process still has backlog, and did not\n\t\t\t * let either the budget timeout or the disk\n\t\t\t * idling timeout expire. Hence it is not\n\t\t\t * seeky, has a short thinktime and may be\n\t\t\t * happy with a higher budget too. So\n\t\t\t * definitely increase the budget of this good\n\t\t\t * candidate to boost the disk throughput.\n\t\t\t */\n\t\t\tbudget = min(budget * 4, bfqd->bfq_max_budget);\n\t\t\tbreak;\n\t\tcase BFQQE_NO_MORE_REQUESTS:\n\t\t\t/*\n\t\t\t * For queues that expire for this reason, it\n\t\t\t * is particularly important to keep the\n\t\t\t * budget close to the actual service they\n\t\t\t * need. Doing so reduces the timestamp\n\t\t\t * misalignment problem described in the\n\t\t\t * comments in the body of\n\t\t\t * __bfq_activate_entity. In fact, suppose\n\t\t\t * that a queue systematically expires for\n\t\t\t * BFQQE_NO_MORE_REQUESTS and presents a\n\t\t\t * new request in time to enjoy timestamp\n\t\t\t * back-shifting. The larger the budget of the\n\t\t\t * queue is with respect to the service the\n\t\t\t * queue actually requests in each service\n\t\t\t * slot, the more times the queue can be\n\t\t\t * reactivated with the same virtual finish\n\t\t\t * time. It follows that, even if this finish\n\t\t\t * time is pushed to the system virtual time\n\t\t\t * to reduce the consequent timestamp\n\t\t\t * misalignment, the queue unjustly enjoys for\n\t\t\t * many re-activations a lower finish time\n\t\t\t * than all newly activated queues.\n\t\t\t *\n\t\t\t * The service needed by bfqq is measured\n\t\t\t * quite precisely by bfqq->entity.service.\n\t\t\t * Since bfqq does not enjoy device idling,\n\t\t\t * bfqq->entity.service is equal to the number\n\t\t\t * of sectors that the process associated with\n\t\t\t * bfqq requested to read/write before waiting\n\t\t\t * for request completions, or blocking for\n\t\t\t * other reasons.\n\t\t\t */\n\t\t\tbudget = max_t(int, bfqq->entity.service, min_budget);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t} else if (!bfq_bfqq_sync(bfqq)) {\n\t\t/*\n\t\t * Async queues get always the maximum possible\n\t\t * budget, as for them we do not care about latency\n\t\t * (in addition, their ability to dispatch is limited\n\t\t * by the charging factor).\n\t\t */\n\t\tbudget = bfqd->bfq_max_budget;\n\t}\n\n\tbfqq->max_budget = budget;\n\n\tif (bfqd->budgets_assigned >= bfq_stats_min_budgets &&\n\t    !bfqd->bfq_user_max_budget)\n\t\tbfqq->max_budget = min(bfqq->max_budget, bfqd->bfq_max_budget);\n\n\t/*\n\t * If there is still backlog, then assign a new budget, making\n\t * sure that it is large enough for the next request.  Since\n\t * the finish time of bfqq must be kept in sync with the\n\t * budget, be sure to call __bfq_bfqq_expire() *after* this\n\t * update.\n\t *\n\t * If there is no backlog, then no need to update the budget;\n\t * it will be updated on the arrival of a new request.\n\t */\n\tnext_rq = bfqq->next_rq;\n\tif (next_rq)\n\t\tbfqq->entity.budget = max_t(unsigned long, bfqq->max_budget,\n\t\t\t\t\t    bfq_serv_to_charge(next_rq, bfqq));\n\n\tbfq_log_bfqq(bfqd, bfqq, \"head sect: %u, new budget %d\",\n\t\t\tnext_rq ? blk_rq_sectors(next_rq) : 0,\n\t\t\tbfqq->entity.budget);\n}\n\n/*\n * Return true if the process associated with bfqq is \"slow\". The slow\n * flag is used, in addition to the budget timeout, to reduce the\n * amount of service provided to seeky processes, and thus reduce\n * their chances to lower the throughput. More details in the comments\n * on the function bfq_bfqq_expire().\n *\n * An important observation is in order: as discussed in the comments\n * on the function bfq_update_peak_rate(), with devices with internal\n * queues, it is hard if ever possible to know when and for how long\n * an I/O request is processed by the device (apart from the trivial\n * I/O pattern where a new request is dispatched only after the\n * previous one has been completed). This makes it hard to evaluate\n * the real rate at which the I/O requests of each bfq_queue are\n * served.  In fact, for an I/O scheduler like BFQ, serving a\n * bfq_queue means just dispatching its requests during its service\n * slot (i.e., until the budget of the queue is exhausted, or the\n * queue remains idle, or, finally, a timeout fires). But, during the\n * service slot of a bfq_queue, around 100 ms at most, the device may\n * be even still processing requests of bfq_queues served in previous\n * service slots. On the opposite end, the requests of the in-service\n * bfq_queue may be completed after the service slot of the queue\n * finishes.\n *\n * Anyway, unless more sophisticated solutions are used\n * (where possible), the sum of the sizes of the requests dispatched\n * during the service slot of a bfq_queue is probably the only\n * approximation available for the service received by the bfq_queue\n * during its service slot. And this sum is the quantity used in this\n * function to evaluate the I/O speed of a process.\n */\nstatic bool bfq_bfqq_is_slow(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t\t bool compensate, enum bfqq_expiration reason,\n\t\t\t\t unsigned long *delta_ms)\n{\n\tktime_t delta_ktime;\n\tu32 delta_usecs;\n\tbool slow = BFQQ_SEEKY(bfqq); /* if delta too short, use seekyness */\n\n\tif (!bfq_bfqq_sync(bfqq))\n\t\treturn false;\n\n\tif (compensate)\n\t\tdelta_ktime = bfqd->last_idling_start;\n\telse\n\t\tdelta_ktime = ktime_get();\n\tdelta_ktime = ktime_sub(delta_ktime, bfqd->last_budget_start);\n\tdelta_usecs = ktime_to_us(delta_ktime);\n\n\t/* don't use too short time intervals */\n\tif (delta_usecs < 1000) {\n\t\tif (blk_queue_nonrot(bfqd->queue))\n\t\t\t /*\n\t\t\t  * give same worst-case guarantees as idling\n\t\t\t  * for seeky\n\t\t\t  */\n\t\t\t*delta_ms = BFQ_MIN_TT / NSEC_PER_MSEC;\n\t\telse /* charge at least one seek */\n\t\t\t*delta_ms = bfq_slice_idle / NSEC_PER_MSEC;\n\n\t\treturn slow;\n\t}\n\n\t*delta_ms = delta_usecs / USEC_PER_MSEC;\n\n\t/*\n\t * Use only long (> 20ms) intervals to filter out excessive\n\t * spikes in service rate estimation.\n\t */\n\tif (delta_usecs > 20000) {\n\t\t/*\n\t\t * Caveat for rotational devices: processes doing I/O\n\t\t * in the slower disk zones tend to be slow(er) even\n\t\t * if not seeky. In this respect, the estimated peak\n\t\t * rate is likely to be an average over the disk\n\t\t * surface. Accordingly, to not be too harsh with\n\t\t * unlucky processes, a process is deemed slow only if\n\t\t * its rate has been lower than half of the estimated\n\t\t * peak rate.\n\t\t */\n\t\tslow = bfqq->entity.service < bfqd->bfq_max_budget / 2;\n\t}\n\n\tbfq_log_bfqq(bfqd, bfqq, \"bfq_bfqq_is_slow: slow %d\", slow);\n\n\treturn slow;\n}\n\n/*\n * To be deemed as soft real-time, an application must meet two\n * requirements. First, the application must not require an average\n * bandwidth higher than the approximate bandwidth required to playback or\n * record a compressed high-definition video.\n * The next function is invoked on the completion of the last request of a\n * batch, to compute the next-start time instant, soft_rt_next_start, such\n * that, if the next request of the application does not arrive before\n * soft_rt_next_start, then the above requirement on the bandwidth is met.\n *\n * The second requirement is that the request pattern of the application is\n * isochronous, i.e., that, after issuing a request or a batch of requests,\n * the application stops issuing new requests until all its pending requests\n * have been completed. After that, the application may issue a new batch,\n * and so on.\n * For this reason the next function is invoked to compute\n * soft_rt_next_start only for applications that meet this requirement,\n * whereas soft_rt_next_start is set to infinity for applications that do\n * not.\n *\n * Unfortunately, even a greedy (i.e., I/O-bound) application may\n * happen to meet, occasionally or systematically, both the above\n * bandwidth and isochrony requirements. This may happen at least in\n * the following circumstances. First, if the CPU load is high. The\n * application may stop issuing requests while the CPUs are busy\n * serving other processes, then restart, then stop again for a while,\n * and so on. The other circumstances are related to the storage\n * device: the storage device is highly loaded or reaches a low-enough\n * throughput with the I/O of the application (e.g., because the I/O\n * is random and/or the device is slow). In all these cases, the\n * I/O of the application may be simply slowed down enough to meet\n * the bandwidth and isochrony requirements. To reduce the probability\n * that greedy applications are deemed as soft real-time in these\n * corner cases, a further rule is used in the computation of\n * soft_rt_next_start: the return value of this function is forced to\n * be higher than the maximum between the following two quantities.\n *\n * (a) Current time plus: (1) the maximum time for which the arrival\n *     of a request is waited for when a sync queue becomes idle,\n *     namely bfqd->bfq_slice_idle, and (2) a few extra jiffies. We\n *     postpone for a moment the reason for adding a few extra\n *     jiffies; we get back to it after next item (b).  Lower-bounding\n *     the return value of this function with the current time plus\n *     bfqd->bfq_slice_idle tends to filter out greedy applications,\n *     because the latter issue their next request as soon as possible\n *     after the last one has been completed. In contrast, a soft\n *     real-time application spends some time processing data, after a\n *     batch of its requests has been completed.\n *\n * (b) Current value of bfqq->soft_rt_next_start. As pointed out\n *     above, greedy applications may happen to meet both the\n *     bandwidth and isochrony requirements under heavy CPU or\n *     storage-device load. In more detail, in these scenarios, these\n *     applications happen, only for limited time periods, to do I/O\n *     slowly enough to meet all the requirements described so far,\n *     including the filtering in above item (a). These slow-speed\n *     time intervals are usually interspersed between other time\n *     intervals during which these applications do I/O at a very high\n *     speed. Fortunately, exactly because of the high speed of the\n *     I/O in the high-speed intervals, the values returned by this\n *     function happen to be so high, near the end of any such\n *     high-speed interval, to be likely to fall *after* the end of\n *     the low-speed time interval that follows. These high values are\n *     stored in bfqq->soft_rt_next_start after each invocation of\n *     this function. As a consequence, if the last value of\n *     bfqq->soft_rt_next_start is constantly used to lower-bound the\n *     next value that this function may return, then, from the very\n *     beginning of a low-speed interval, bfqq->soft_rt_next_start is\n *     likely to be constantly kept so high that any I/O request\n *     issued during the low-speed interval is considered as arriving\n *     to soon for the application to be deemed as soft\n *     real-time. Then, in the high-speed interval that follows, the\n *     application will not be deemed as soft real-time, just because\n *     it will do I/O at a high speed. And so on.\n *\n * Getting back to the filtering in item (a), in the following two\n * cases this filtering might be easily passed by a greedy\n * application, if the reference quantity was just\n * bfqd->bfq_slice_idle:\n * 1) HZ is so low that the duration of a jiffy is comparable to or\n *    higher than bfqd->bfq_slice_idle. This happens, e.g., on slow\n *    devices with HZ=100. The time granularity may be so coarse\n *    that the approximation, in jiffies, of bfqd->bfq_slice_idle\n *    is rather lower than the exact value.\n * 2) jiffies, instead of increasing at a constant rate, may stop increasing\n *    for a while, then suddenly 'jump' by several units to recover the lost\n *    increments. This seems to happen, e.g., inside virtual machines.\n * To address this issue, in the filtering in (a) we do not use as a\n * reference time interval just bfqd->bfq_slice_idle, but\n * bfqd->bfq_slice_idle plus a few jiffies. In particular, we add the\n * minimum number of jiffies for which the filter seems to be quite\n * precise also in embedded systems and KVM/QEMU virtual machines.\n */\nstatic unsigned long bfq_bfqq_softrt_next_start(struct bfq_data *bfqd,\n\t\t\t\t\t\tstruct bfq_queue *bfqq)\n{\n\treturn max3(bfqq->soft_rt_next_start,\n\t\t    bfqq->last_idle_bklogged +\n\t\t    HZ * bfqq->service_from_backlogged /\n\t\t    bfqd->bfq_wr_max_softrt_rate,\n\t\t    jiffies + nsecs_to_jiffies(bfqq->bfqd->bfq_slice_idle) + 4);\n}\n\n/**\n * bfq_bfqq_expire - expire a queue.\n * @bfqd: device owning the queue.\n * @bfqq: the queue to expire.\n * @compensate: if true, compensate for the time spent idling.\n * @reason: the reason causing the expiration.\n *\n * If the process associated with bfqq does slow I/O (e.g., because it\n * issues random requests), we charge bfqq with the time it has been\n * in service instead of the service it has received (see\n * bfq_bfqq_charge_time for details on how this goal is achieved). As\n * a consequence, bfqq will typically get higher timestamps upon\n * reactivation, and hence it will be rescheduled as if it had\n * received more service than what it has actually received. In the\n * end, bfqq receives less service in proportion to how slowly its\n * associated process consumes its budgets (and hence how seriously it\n * tends to lower the throughput). In addition, this time-charging\n * strategy guarantees time fairness among slow processes. In\n * contrast, if the process associated with bfqq is not slow, we\n * charge bfqq exactly with the service it has received.\n *\n * Charging time to the first type of queues and the exact service to\n * the other has the effect of using the WF2Q+ policy to schedule the\n * former on a timeslice basis, without violating service domain\n * guarantees among the latter.\n */\nvoid bfq_bfqq_expire(struct bfq_data *bfqd,\n\t\t     struct bfq_queue *bfqq,\n\t\t     bool compensate,\n\t\t     enum bfqq_expiration reason)\n{\n\tbool slow;\n\tunsigned long delta = 0;\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\t/*\n\t * Check whether the process is slow (see bfq_bfqq_is_slow).\n\t */\n\tslow = bfq_bfqq_is_slow(bfqd, bfqq, compensate, reason, &delta);\n\n\t/*\n\t * As above explained, charge slow (typically seeky) and\n\t * timed-out queues with the time and not the service\n\t * received, to favor sequential workloads.\n\t *\n\t * Processes doing I/O in the slower disk zones will tend to\n\t * be slow(er) even if not seeky. Therefore, since the\n\t * estimated peak rate is actually an average over the disk\n\t * surface, these processes may timeout just for bad luck. To\n\t * avoid punishing them, do not charge time to processes that\n\t * succeeded in consuming at least 2/3 of their budget. This\n\t * allows BFQ to preserve enough elasticity to still perform\n\t * bandwidth, and not time, distribution with little unlucky\n\t * or quasi-sequential processes.\n\t */\n\tif (bfqq->wr_coeff == 1 &&\n\t    (slow ||\n\t     (reason == BFQQE_BUDGET_TIMEOUT &&\n\t      bfq_bfqq_budget_left(bfqq) >=  entity->budget / 3)))\n\t\tbfq_bfqq_charge_time(bfqd, bfqq, delta);\n\n\tif (reason == BFQQE_TOO_IDLE &&\n\t    entity->service <= 2 * entity->budget / 10)\n\t\tbfq_clear_bfqq_IO_bound(bfqq);\n\n\tif (bfqd->low_latency && bfqq->wr_coeff == 1)\n\t\tbfqq->last_wr_start_finish = jiffies;\n\n\tif (bfqd->low_latency && bfqd->bfq_wr_max_softrt_rate > 0 &&\n\t    RB_EMPTY_ROOT(&bfqq->sort_list)) {\n\t\t/*\n\t\t * If we get here, and there are no outstanding\n\t\t * requests, then the request pattern is isochronous\n\t\t * (see the comments on the function\n\t\t * bfq_bfqq_softrt_next_start()). Thus we can compute\n\t\t * soft_rt_next_start. And we do it, unless bfqq is in\n\t\t * interactive weight raising. We do not do it in the\n\t\t * latter subcase, for the following reason. bfqq may\n\t\t * be conveying the I/O needed to load a soft\n\t\t * real-time application. Such an application will\n\t\t * actually exhibit a soft real-time I/O pattern after\n\t\t * it finally starts doing its job. But, if\n\t\t * soft_rt_next_start is computed here for an\n\t\t * interactive bfqq, and bfqq had received a lot of\n\t\t * service before remaining with no outstanding\n\t\t * request (likely to happen on a fast device), then\n\t\t * soft_rt_next_start would be assigned such a high\n\t\t * value that, for a very long time, bfqq would be\n\t\t * prevented from being possibly considered as soft\n\t\t * real time.\n\t\t *\n\t\t * If, instead, the queue still has outstanding\n\t\t * requests, then we have to wait for the completion\n\t\t * of all the outstanding requests to discover whether\n\t\t * the request pattern is actually isochronous.\n\t\t */\n\t\tif (bfqq->dispatched == 0 &&\n\t\t    bfqq->wr_coeff != bfqd->bfq_wr_coeff)\n\t\t\tbfqq->soft_rt_next_start =\n\t\t\t\tbfq_bfqq_softrt_next_start(bfqd, bfqq);\n\t\telse if (bfqq->dispatched > 0) {\n\t\t\t/*\n\t\t\t * Schedule an update of soft_rt_next_start to when\n\t\t\t * the task may be discovered to be isochronous.\n\t\t\t */\n\t\t\tbfq_mark_bfqq_softrt_update(bfqq);\n\t\t}\n\t}\n\n\tbfq_log_bfqq(bfqd, bfqq,\n\t\t\"expire (%d, slow %d, num_disp %d, short_ttime %d)\", reason,\n\t\tslow, bfqq->dispatched, bfq_bfqq_has_short_ttime(bfqq));\n\n\t/*\n\t * bfqq expired, so no total service time needs to be computed\n\t * any longer: reset state machine for measuring total service\n\t * times.\n\t */\n\tbfqd->rqs_injected = bfqd->wait_dispatch = false;\n\tbfqd->waited_rq = NULL;\n\n\t/*\n\t * Increase, decrease or leave budget unchanged according to\n\t * reason.\n\t */\n\t__bfq_bfqq_recalc_budget(bfqd, bfqq, reason);\n\tif (__bfq_bfqq_expire(bfqd, bfqq, reason))\n\t\t/* bfqq is gone, no more actions on it */\n\t\treturn;\n\n\t/* mark bfqq as waiting a request only if a bic still points to it */\n\tif (!bfq_bfqq_busy(bfqq) &&\n\t    reason != BFQQE_BUDGET_TIMEOUT &&\n\t    reason != BFQQE_BUDGET_EXHAUSTED) {\n\t\tbfq_mark_bfqq_non_blocking_wait_rq(bfqq);\n\t\t/*\n\t\t * Not setting service to 0, because, if the next rq\n\t\t * arrives in time, the queue will go on receiving\n\t\t * service with this same budget (as if it never expired)\n\t\t */\n\t} else\n\t\tentity->service = 0;\n\n\t/*\n\t * Reset the received-service counter for every parent entity.\n\t * Differently from what happens with bfqq->entity.service,\n\t * the resetting of this counter never needs to be postponed\n\t * for parent entities. In fact, in case bfqq may have a\n\t * chance to go on being served using the last, partially\n\t * consumed budget, bfqq->entity.service needs to be kept,\n\t * because if bfqq then actually goes on being served using\n\t * the same budget, the last value of bfqq->entity.service is\n\t * needed to properly decrement bfqq->entity.budget by the\n\t * portion already consumed. In contrast, it is not necessary\n\t * to keep entity->service for parent entities too, because\n\t * the bubble up of the new value of bfqq->entity.budget will\n\t * make sure that the budgets of parent entities are correct,\n\t * even in case bfqq and thus parent entities go on receiving\n\t * service with the same budget.\n\t */\n\tentity = entity->parent;\n\tfor_each_entity(entity)\n\t\tentity->service = 0;\n}\n\n/*\n * Budget timeout is not implemented through a dedicated timer, but\n * just checked on request arrivals and completions, as well as on\n * idle timer expirations.\n */\nstatic bool bfq_bfqq_budget_timeout(struct bfq_queue *bfqq)\n{\n\treturn time_is_before_eq_jiffies(bfqq->budget_timeout);\n}\n\n/*\n * If we expire a queue that is actively waiting (i.e., with the\n * device idled) for the arrival of a new request, then we may incur\n * the timestamp misalignment problem described in the body of the\n * function __bfq_activate_entity. Hence we return true only if this\n * condition does not hold, or if the queue is slow enough to deserve\n * only to be kicked off for preserving a high throughput.\n */\nstatic bool bfq_may_expire_for_budg_timeout(struct bfq_queue *bfqq)\n{\n\tbfq_log_bfqq(bfqq->bfqd, bfqq,\n\t\t\"may_budget_timeout: wait_request %d left %d timeout %d\",\n\t\tbfq_bfqq_wait_request(bfqq),\n\t\t\tbfq_bfqq_budget_left(bfqq) >=  bfqq->entity.budget / 3,\n\t\tbfq_bfqq_budget_timeout(bfqq));\n\n\treturn (!bfq_bfqq_wait_request(bfqq) ||\n\t\tbfq_bfqq_budget_left(bfqq) >=  bfqq->entity.budget / 3)\n\t\t&&\n\t\tbfq_bfqq_budget_timeout(bfqq);\n}\n\nstatic bool idling_boosts_thr_without_issues(struct bfq_data *bfqd,\n\t\t\t\t\t     struct bfq_queue *bfqq)\n{\n\tbool rot_without_queueing =\n\t\t!blk_queue_nonrot(bfqd->queue) && !bfqd->hw_tag,\n\t\tbfqq_sequential_and_IO_bound,\n\t\tidling_boosts_thr;\n\n\t/* No point in idling for bfqq if it won't get requests any longer */\n\tif (unlikely(!bfqq_process_refs(bfqq)))\n\t\treturn false;\n\n\tbfqq_sequential_and_IO_bound = !BFQQ_SEEKY(bfqq) &&\n\t\tbfq_bfqq_IO_bound(bfqq) && bfq_bfqq_has_short_ttime(bfqq);\n\n\t/*\n\t * The next variable takes into account the cases where idling\n\t * boosts the throughput.\n\t *\n\t * The value of the variable is computed considering, first, that\n\t * idling is virtually always beneficial for the throughput if:\n\t * (a) the device is not NCQ-capable and rotational, or\n\t * (b) regardless of the presence of NCQ, the device is rotational and\n\t *     the request pattern for bfqq is I/O-bound and sequential, or\n\t * (c) regardless of whether it is rotational, the device is\n\t *     not NCQ-capable and the request pattern for bfqq is\n\t *     I/O-bound and sequential.\n\t *\n\t * Secondly, and in contrast to the above item (b), idling an\n\t * NCQ-capable flash-based device would not boost the\n\t * throughput even with sequential I/O; rather it would lower\n\t * the throughput in proportion to how fast the device\n\t * is. Accordingly, the next variable is true if any of the\n\t * above conditions (a), (b) or (c) is true, and, in\n\t * particular, happens to be false if bfqd is an NCQ-capable\n\t * flash-based device.\n\t */\n\tidling_boosts_thr = rot_without_queueing ||\n\t\t((!blk_queue_nonrot(bfqd->queue) || !bfqd->hw_tag) &&\n\t\t bfqq_sequential_and_IO_bound);\n\n\t/*\n\t * The return value of this function is equal to that of\n\t * idling_boosts_thr, unless a special case holds. In this\n\t * special case, described below, idling may cause problems to\n\t * weight-raised queues.\n\t *\n\t * When the request pool is saturated (e.g., in the presence\n\t * of write hogs), if the processes associated with\n\t * non-weight-raised queues ask for requests at a lower rate,\n\t * then processes associated with weight-raised queues have a\n\t * higher probability to get a request from the pool\n\t * immediately (or at least soon) when they need one. Thus\n\t * they have a higher probability to actually get a fraction\n\t * of the device throughput proportional to their high\n\t * weight. This is especially true with NCQ-capable drives,\n\t * which enqueue several requests in advance, and further\n\t * reorder internally-queued requests.\n\t *\n\t * For this reason, we force to false the return value if\n\t * there are weight-raised busy queues. In this case, and if\n\t * bfqq is not weight-raised, this guarantees that the device\n\t * is not idled for bfqq (if, instead, bfqq is weight-raised,\n\t * then idling will be guaranteed by another variable, see\n\t * below). Combined with the timestamping rules of BFQ (see\n\t * [1] for details), this behavior causes bfqq, and hence any\n\t * sync non-weight-raised queue, to get a lower number of\n\t * requests served, and thus to ask for a lower number of\n\t * requests from the request pool, before the busy\n\t * weight-raised queues get served again. This often mitigates\n\t * starvation problems in the presence of heavy write\n\t * workloads and NCQ, thereby guaranteeing a higher\n\t * application and system responsiveness in these hostile\n\t * scenarios.\n\t */\n\treturn idling_boosts_thr &&\n\t\tbfqd->wr_busy_queues == 0;\n}\n\n/*\n * For a queue that becomes empty, device idling is allowed only if\n * this function returns true for that queue. As a consequence, since\n * device idling plays a critical role for both throughput boosting\n * and service guarantees, the return value of this function plays a\n * critical role as well.\n *\n * In a nutshell, this function returns true only if idling is\n * beneficial for throughput or, even if detrimental for throughput,\n * idling is however necessary to preserve service guarantees (low\n * latency, desired throughput distribution, ...). In particular, on\n * NCQ-capable devices, this function tries to return false, so as to\n * help keep the drives' internal queues full, whenever this helps the\n * device boost the throughput without causing any service-guarantee\n * issue.\n *\n * Most of the issues taken into account to get the return value of\n * this function are not trivial. We discuss these issues in the two\n * functions providing the main pieces of information needed by this\n * function.\n */\nstatic bool bfq_better_to_idle(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tbool idling_boosts_thr_with_no_issue, idling_needed_for_service_guar;\n\n\t/* No point in idling for bfqq if it won't get requests any longer */\n\tif (unlikely(!bfqq_process_refs(bfqq)))\n\t\treturn false;\n\n\tif (unlikely(bfqd->strict_guarantees))\n\t\treturn true;\n\n\t/*\n\t * Idling is performed only if slice_idle > 0. In addition, we\n\t * do not idle if\n\t * (a) bfqq is async\n\t * (b) bfqq is in the idle io prio class: in this case we do\n\t * not idle because we want to minimize the bandwidth that\n\t * queues in this class can steal to higher-priority queues\n\t */\n\tif (bfqd->bfq_slice_idle == 0 || !bfq_bfqq_sync(bfqq) ||\n\t   bfq_class_idle(bfqq))\n\t\treturn false;\n\n\tidling_boosts_thr_with_no_issue =\n\t\tidling_boosts_thr_without_issues(bfqd, bfqq);\n\n\tidling_needed_for_service_guar =\n\t\tidling_needed_for_service_guarantees(bfqd, bfqq);\n\n\t/*\n\t * We have now the two components we need to compute the\n\t * return value of the function, which is true only if idling\n\t * either boosts the throughput (without issues), or is\n\t * necessary to preserve service guarantees.\n\t */\n\treturn idling_boosts_thr_with_no_issue ||\n\t\tidling_needed_for_service_guar;\n}\n\n/*\n * If the in-service queue is empty but the function bfq_better_to_idle\n * returns true, then:\n * 1) the queue must remain in service and cannot be expired, and\n * 2) the device must be idled to wait for the possible arrival of a new\n *    request for the queue.\n * See the comments on the function bfq_better_to_idle for the reasons\n * why performing device idling is the best choice to boost the throughput\n * and preserve service guarantees when bfq_better_to_idle itself\n * returns true.\n */\nstatic bool bfq_bfqq_must_idle(struct bfq_queue *bfqq)\n{\n\treturn RB_EMPTY_ROOT(&bfqq->sort_list) && bfq_better_to_idle(bfqq);\n}\n\n/*\n * This function chooses the queue from which to pick the next extra\n * I/O request to inject, if it finds a compatible queue. See the\n * comments on bfq_update_inject_limit() for details on the injection\n * mechanism, and for the definitions of the quantities mentioned\n * below.\n */\nstatic struct bfq_queue *\nbfq_choose_bfqq_for_injection(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq, *in_serv_bfqq = bfqd->in_service_queue;\n\tunsigned int limit = in_serv_bfqq->inject_limit;\n\t/*\n\t * If\n\t * - bfqq is not weight-raised and therefore does not carry\n\t *   time-critical I/O,\n\t * or\n\t * - regardless of whether bfqq is weight-raised, bfqq has\n\t *   however a long think time, during which it can absorb the\n\t *   effect of an appropriate number of extra I/O requests\n\t *   from other queues (see bfq_update_inject_limit for\n\t *   details on the computation of this number);\n\t * then injection can be performed without restrictions.\n\t */\n\tbool in_serv_always_inject = in_serv_bfqq->wr_coeff == 1 ||\n\t\t!bfq_bfqq_has_short_ttime(in_serv_bfqq);\n\n\t/*\n\t * If\n\t * - the baseline total service time could not be sampled yet,\n\t *   so the inject limit happens to be still 0, and\n\t * - a lot of time has elapsed since the plugging of I/O\n\t *   dispatching started, so drive speed is being wasted\n\t *   significantly;\n\t * then temporarily raise inject limit to one request.\n\t */\n\tif (limit == 0 && in_serv_bfqq->last_serv_time_ns == 0 &&\n\t    bfq_bfqq_wait_request(in_serv_bfqq) &&\n\t    time_is_before_eq_jiffies(bfqd->last_idling_start_jiffies +\n\t\t\t\t      bfqd->bfq_slice_idle)\n\t\t)\n\t\tlimit = 1;\n\n\tif (bfqd->rq_in_driver >= limit)\n\t\treturn NULL;\n\n\t/*\n\t * Linear search of the source queue for injection; but, with\n\t * a high probability, very few steps are needed to find a\n\t * candidate queue, i.e., a queue with enough budget left for\n\t * its next request. In fact:\n\t * - BFQ dynamically updates the budget of every queue so as\n\t *   to accommodate the expected backlog of the queue;\n\t * - if a queue gets all its requests dispatched as injected\n\t *   service, then the queue is removed from the active list\n\t *   (and re-added only if it gets new requests, but then it\n\t *   is assigned again enough budget for its new backlog).\n\t */\n\tlist_for_each_entry(bfqq, &bfqd->active_list, bfqq_list)\n\t\tif (!RB_EMPTY_ROOT(&bfqq->sort_list) &&\n\t\t    (in_serv_always_inject || bfqq->wr_coeff > 1) &&\n\t\t    bfq_serv_to_charge(bfqq->next_rq, bfqq) <=\n\t\t    bfq_bfqq_budget_left(bfqq)) {\n\t\t\t/*\n\t\t\t * Allow for only one large in-flight request\n\t\t\t * on non-rotational devices, for the\n\t\t\t * following reason. On non-rotationl drives,\n\t\t\t * large requests take much longer than\n\t\t\t * smaller requests to be served. In addition,\n\t\t\t * the drive prefers to serve large requests\n\t\t\t * w.r.t. to small ones, if it can choose. So,\n\t\t\t * having more than one large requests queued\n\t\t\t * in the drive may easily make the next first\n\t\t\t * request of the in-service queue wait for so\n\t\t\t * long to break bfqq's service guarantees. On\n\t\t\t * the bright side, large requests let the\n\t\t\t * drive reach a very high throughput, even if\n\t\t\t * there is only one in-flight large request\n\t\t\t * at a time.\n\t\t\t */\n\t\t\tif (blk_queue_nonrot(bfqd->queue) &&\n\t\t\t    blk_rq_sectors(bfqq->next_rq) >=\n\t\t\t    BFQQ_SECT_THR_NONROT)\n\t\t\t\tlimit = min_t(unsigned int, 1, limit);\n\t\t\telse\n\t\t\t\tlimit = in_serv_bfqq->inject_limit;\n\n\t\t\tif (bfqd->rq_in_driver < limit) {\n\t\t\t\tbfqd->rqs_injected = true;\n\t\t\t\treturn bfqq;\n\t\t\t}\n\t\t}\n\n\treturn NULL;\n}\n\n/*\n * Select a queue for service.  If we have a current queue in service,\n * check whether to continue servicing it, or retrieve and set a new one.\n */\nstatic struct bfq_queue *bfq_select_queue(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq;\n\tstruct request *next_rq;\n\tenum bfqq_expiration reason = BFQQE_BUDGET_TIMEOUT;\n\n\tbfqq = bfqd->in_service_queue;\n\tif (!bfqq)\n\t\tgoto new_queue;\n\n\tbfq_log_bfqq(bfqd, bfqq, \"select_queue: already in-service queue\");\n\n\t/*\n\t * Do not expire bfqq for budget timeout if bfqq may be about\n\t * to enjoy device idling. The reason why, in this case, we\n\t * prevent bfqq from expiring is the same as in the comments\n\t * on the case where bfq_bfqq_must_idle() returns true, in\n\t * bfq_completed_request().\n\t */\n\tif (bfq_may_expire_for_budg_timeout(bfqq) &&\n\t    !bfq_bfqq_must_idle(bfqq))\n\t\tgoto expire;\n\ncheck_queue:\n\t/*\n\t * This loop is rarely executed more than once. Even when it\n\t * happens, it is much more convenient to re-execute this loop\n\t * than to return NULL and trigger a new dispatch to get a\n\t * request served.\n\t */\n\tnext_rq = bfqq->next_rq;\n\t/*\n\t * If bfqq has requests queued and it has enough budget left to\n\t * serve them, keep the queue, otherwise expire it.\n\t */\n\tif (next_rq) {\n\t\tif (bfq_serv_to_charge(next_rq, bfqq) >\n\t\t\tbfq_bfqq_budget_left(bfqq)) {\n\t\t\t/*\n\t\t\t * Expire the queue for budget exhaustion,\n\t\t\t * which makes sure that the next budget is\n\t\t\t * enough to serve the next request, even if\n\t\t\t * it comes from the fifo expired path.\n\t\t\t */\n\t\t\treason = BFQQE_BUDGET_EXHAUSTED;\n\t\t\tgoto expire;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The idle timer may be pending because we may\n\t\t\t * not disable disk idling even when a new request\n\t\t\t * arrives.\n\t\t\t */\n\t\t\tif (bfq_bfqq_wait_request(bfqq)) {\n\t\t\t\t/*\n\t\t\t\t * If we get here: 1) at least a new request\n\t\t\t\t * has arrived but we have not disabled the\n\t\t\t\t * timer because the request was too small,\n\t\t\t\t * 2) then the block layer has unplugged\n\t\t\t\t * the device, causing the dispatch to be\n\t\t\t\t * invoked.\n\t\t\t\t *\n\t\t\t\t * Since the device is unplugged, now the\n\t\t\t\t * requests are probably large enough to\n\t\t\t\t * provide a reasonable throughput.\n\t\t\t\t * So we disable idling.\n\t\t\t\t */\n\t\t\t\tbfq_clear_bfqq_wait_request(bfqq);\n\t\t\t\thrtimer_try_to_cancel(&bfqd->idle_slice_timer);\n\t\t\t}\n\t\t\tgoto keep_queue;\n\t\t}\n\t}\n\n\t/*\n\t * No requests pending. However, if the in-service queue is idling\n\t * for a new request, or has requests waiting for a completion and\n\t * may idle after their completion, then keep it anyway.\n\t *\n\t * Yet, inject service from other queues if it boosts\n\t * throughput and is possible.\n\t */\n\tif (bfq_bfqq_wait_request(bfqq) ||\n\t    (bfqq->dispatched != 0 && bfq_better_to_idle(bfqq))) {\n\t\tstruct bfq_queue *async_bfqq =\n\t\t\tbfqq->bic && bfqq->bic->bfqq[0] &&\n\t\t\tbfq_bfqq_busy(bfqq->bic->bfqq[0]) &&\n\t\t\tbfqq->bic->bfqq[0]->next_rq ?\n\t\t\tbfqq->bic->bfqq[0] : NULL;\n\n\t\t/*\n\t\t * The next three mutually-exclusive ifs decide\n\t\t * whether to try injection, and choose the queue to\n\t\t * pick an I/O request from.\n\t\t *\n\t\t * The first if checks whether the process associated\n\t\t * with bfqq has also async I/O pending. If so, it\n\t\t * injects such I/O unconditionally. Injecting async\n\t\t * I/O from the same process can cause no harm to the\n\t\t * process. On the contrary, it can only increase\n\t\t * bandwidth and reduce latency for the process.\n\t\t *\n\t\t * The second if checks whether there happens to be a\n\t\t * non-empty waker queue for bfqq, i.e., a queue whose\n\t\t * I/O needs to be completed for bfqq to receive new\n\t\t * I/O. This happens, e.g., if bfqq is associated with\n\t\t * a process that does some sync. A sync generates\n\t\t * extra blocking I/O, which must be completed before\n\t\t * the process associated with bfqq can go on with its\n\t\t * I/O. If the I/O of the waker queue is not served,\n\t\t * then bfqq remains empty, and no I/O is dispatched,\n\t\t * until the idle timeout fires for bfqq. This is\n\t\t * likely to result in lower bandwidth and higher\n\t\t * latencies for bfqq, and in a severe loss of total\n\t\t * throughput. The best action to take is therefore to\n\t\t * serve the waker queue as soon as possible. So do it\n\t\t * (without relying on the third alternative below for\n\t\t * eventually serving waker_bfqq's I/O; see the last\n\t\t * paragraph for further details). This systematic\n\t\t * injection of I/O from the waker queue does not\n\t\t * cause any delay to bfqq's I/O. On the contrary,\n\t\t * next bfqq's I/O is brought forward dramatically,\n\t\t * for it is not blocked for milliseconds.\n\t\t *\n\t\t * The third if checks whether bfqq is a queue for\n\t\t * which it is better to avoid injection. It is so if\n\t\t * bfqq delivers more throughput when served without\n\t\t * any further I/O from other queues in the middle, or\n\t\t * if the service times of bfqq's I/O requests both\n\t\t * count more than overall throughput, and may be\n\t\t * easily increased by injection (this happens if bfqq\n\t\t * has a short think time). If none of these\n\t\t * conditions holds, then a candidate queue for\n\t\t * injection is looked for through\n\t\t * bfq_choose_bfqq_for_injection(). Note that the\n\t\t * latter may return NULL (for example if the inject\n\t\t * limit for bfqq is currently 0).\n\t\t *\n\t\t * NOTE: motivation for the second alternative\n\t\t *\n\t\t * Thanks to the way the inject limit is updated in\n\t\t * bfq_update_has_short_ttime(), it is rather likely\n\t\t * that, if I/O is being plugged for bfqq and the\n\t\t * waker queue has pending I/O requests that are\n\t\t * blocking bfqq's I/O, then the third alternative\n\t\t * above lets the waker queue get served before the\n\t\t * I/O-plugging timeout fires. So one may deem the\n\t\t * second alternative superfluous. It is not, because\n\t\t * the third alternative may be way less effective in\n\t\t * case of a synchronization. For two main\n\t\t * reasons. First, throughput may be low because the\n\t\t * inject limit may be too low to guarantee the same\n\t\t * amount of injected I/O, from the waker queue or\n\t\t * other queues, that the second alternative\n\t\t * guarantees (the second alternative unconditionally\n\t\t * injects a pending I/O request of the waker queue\n\t\t * for each bfq_dispatch_request()). Second, with the\n\t\t * third alternative, the duration of the plugging,\n\t\t * i.e., the time before bfqq finally receives new I/O,\n\t\t * may not be minimized, because the waker queue may\n\t\t * happen to be served only after other queues.\n\t\t */\n\t\tif (async_bfqq &&\n\t\t    icq_to_bic(async_bfqq->next_rq->elv.icq) == bfqq->bic &&\n\t\t    bfq_serv_to_charge(async_bfqq->next_rq, async_bfqq) <=\n\t\t    bfq_bfqq_budget_left(async_bfqq))\n\t\t\tbfqq = bfqq->bic->bfqq[0];\n\t\telse if (bfq_bfqq_has_waker(bfqq) &&\n\t\t\t   bfq_bfqq_busy(bfqq->waker_bfqq) &&\n\t\t\t   bfqq->next_rq &&\n\t\t\t   bfq_serv_to_charge(bfqq->waker_bfqq->next_rq,\n\t\t\t\t\t      bfqq->waker_bfqq) <=\n\t\t\t   bfq_bfqq_budget_left(bfqq->waker_bfqq)\n\t\t\t)\n\t\t\tbfqq = bfqq->waker_bfqq;\n\t\telse if (!idling_boosts_thr_without_issues(bfqd, bfqq) &&\n\t\t\t (bfqq->wr_coeff == 1 || bfqd->wr_busy_queues > 1 ||\n\t\t\t  !bfq_bfqq_has_short_ttime(bfqq)))\n\t\t\tbfqq = bfq_choose_bfqq_for_injection(bfqd);\n\t\telse\n\t\t\tbfqq = NULL;\n\n\t\tgoto keep_queue;\n\t}\n\n\treason = BFQQE_NO_MORE_REQUESTS;\nexpire:\n\tbfq_bfqq_expire(bfqd, bfqq, false, reason);\nnew_queue:\n\tbfqq = bfq_set_in_service_queue(bfqd);\n\tif (bfqq) {\n\t\tbfq_log_bfqq(bfqd, bfqq, \"select_queue: checking new queue\");\n\t\tgoto check_queue;\n\t}\nkeep_queue:\n\tif (bfqq)\n\t\tbfq_log_bfqq(bfqd, bfqq, \"select_queue: returned this queue\");\n\telse\n\t\tbfq_log(bfqd, \"select_queue: no queue returned\");\n\n\treturn bfqq;\n}\n\nstatic void bfq_update_wr_data(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\tif (bfqq->wr_coeff > 1) { /* queue is being weight-raised */\n\t\tbfq_log_bfqq(bfqd, bfqq,\n\t\t\t\"raising period dur %u/%u msec, old coeff %u, w %d(%d)\",\n\t\t\tjiffies_to_msecs(jiffies - bfqq->last_wr_start_finish),\n\t\t\tjiffies_to_msecs(bfqq->wr_cur_max_time),\n\t\t\tbfqq->wr_coeff,\n\t\t\tbfqq->entity.weight, bfqq->entity.orig_weight);\n\n\t\tif (entity->prio_changed)\n\t\t\tbfq_log_bfqq(bfqd, bfqq, \"WARN: pending prio change\");\n\n\t\t/*\n\t\t * If the queue was activated in a burst, or too much\n\t\t * time has elapsed from the beginning of this\n\t\t * weight-raising period, then end weight raising.\n\t\t */\n\t\tif (bfq_bfqq_in_large_burst(bfqq))\n\t\t\tbfq_bfqq_end_wr(bfqq);\n\t\telse if (time_is_before_jiffies(bfqq->last_wr_start_finish +\n\t\t\t\t\t\tbfqq->wr_cur_max_time)) {\n\t\t\tif (bfqq->wr_cur_max_time != bfqd->bfq_wr_rt_max_time ||\n\t\t\ttime_is_before_jiffies(bfqq->wr_start_at_switch_to_srt +\n\t\t\t\t\t       bfq_wr_duration(bfqd)))\n\t\t\t\tbfq_bfqq_end_wr(bfqq);\n\t\t\telse {\n\t\t\t\tswitch_back_to_interactive_wr(bfqq, bfqd);\n\t\t\t\tbfqq->entity.prio_changed = 1;\n\t\t\t}\n\t\t}\n\t\tif (bfqq->wr_coeff > 1 &&\n\t\t    bfqq->wr_cur_max_time != bfqd->bfq_wr_rt_max_time &&\n\t\t    bfqq->service_from_wr > max_service_from_wr) {\n\t\t\t/* see comments on max_service_from_wr */\n\t\t\tbfq_bfqq_end_wr(bfqq);\n\t\t}\n\t}\n\t/*\n\t * To improve latency (for this or other queues), immediately\n\t * update weight both if it must be raised and if it must be\n\t * lowered. Since, entity may be on some active tree here, and\n\t * might have a pending change of its ioprio class, invoke\n\t * next function with the last parameter unset (see the\n\t * comments on the function).\n\t */\n\tif ((entity->weight > entity->orig_weight) != (bfqq->wr_coeff > 1))\n\t\t__bfq_entity_update_weight_prio(bfq_entity_service_tree(entity),\n\t\t\t\t\t\tentity, false);\n}\n\n/*\n * Dispatch next request from bfqq.\n */\nstatic struct request *bfq_dispatch_rq_from_bfqq(struct bfq_data *bfqd,\n\t\t\t\t\t\t struct bfq_queue *bfqq)\n{\n\tstruct request *rq = bfqq->next_rq;\n\tunsigned long service_to_charge;\n\n\tservice_to_charge = bfq_serv_to_charge(rq, bfqq);\n\n\tbfq_bfqq_served(bfqq, service_to_charge);\n\n\tif (bfqq == bfqd->in_service_queue && bfqd->wait_dispatch) {\n\t\tbfqd->wait_dispatch = false;\n\t\tbfqd->waited_rq = rq;\n\t}\n\n\tbfq_dispatch_remove(bfqd->queue, rq);\n\n\tif (bfqq != bfqd->in_service_queue)\n\t\tgoto return_rq;\n\n\t/*\n\t * If weight raising has to terminate for bfqq, then next\n\t * function causes an immediate update of bfqq's weight,\n\t * without waiting for next activation. As a consequence, on\n\t * expiration, bfqq will be timestamped as if has never been\n\t * weight-raised during this service slot, even if it has\n\t * received part or even most of the service as a\n\t * weight-raised queue. This inflates bfqq's timestamps, which\n\t * is beneficial, as bfqq is then more willing to leave the\n\t * device immediately to possible other weight-raised queues.\n\t */\n\tbfq_update_wr_data(bfqd, bfqq);\n\n\t/*\n\t * Expire bfqq, pretending that its budget expired, if bfqq\n\t * belongs to CLASS_IDLE and other queues are waiting for\n\t * service.\n\t */\n\tif (!(bfq_tot_busy_queues(bfqd) > 1 && bfq_class_idle(bfqq)))\n\t\tgoto return_rq;\n\n\tbfq_bfqq_expire(bfqd, bfqq, false, BFQQE_BUDGET_EXHAUSTED);\n\nreturn_rq:\n\treturn rq;\n}\n\nstatic bool bfq_has_work(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct bfq_data *bfqd = hctx->queue->elevator->elevator_data;\n\n\t/*\n\t * Avoiding lock: a race on bfqd->busy_queues should cause at\n\t * most a call to dispatch for nothing\n\t */\n\treturn !list_empty_careful(&bfqd->dispatch) ||\n\t\tbfq_tot_busy_queues(bfqd) > 0;\n}\n\nstatic struct request *__bfq_dispatch_request(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct bfq_data *bfqd = hctx->queue->elevator->elevator_data;\n\tstruct request *rq = NULL;\n\tstruct bfq_queue *bfqq = NULL;\n\n\tif (!list_empty(&bfqd->dispatch)) {\n\t\trq = list_first_entry(&bfqd->dispatch, struct request,\n\t\t\t\t      queuelist);\n\t\tlist_del_init(&rq->queuelist);\n\n\t\tbfqq = RQ_BFQQ(rq);\n\n\t\tif (bfqq) {\n\t\t\t/*\n\t\t\t * Increment counters here, because this\n\t\t\t * dispatch does not follow the standard\n\t\t\t * dispatch flow (where counters are\n\t\t\t * incremented)\n\t\t\t */\n\t\t\tbfqq->dispatched++;\n\n\t\t\tgoto inc_in_driver_start_rq;\n\t\t}\n\n\t\t/*\n\t\t * We exploit the bfq_finish_requeue_request hook to\n\t\t * decrement rq_in_driver, but\n\t\t * bfq_finish_requeue_request will not be invoked on\n\t\t * this request. So, to avoid unbalance, just start\n\t\t * this request, without incrementing rq_in_driver. As\n\t\t * a negative consequence, rq_in_driver is deceptively\n\t\t * lower than it should be while this request is in\n\t\t * service. This may cause bfq_schedule_dispatch to be\n\t\t * invoked uselessly.\n\t\t *\n\t\t * As for implementing an exact solution, the\n\t\t * bfq_finish_requeue_request hook, if defined, is\n\t\t * probably invoked also on this request. So, by\n\t\t * exploiting this hook, we could 1) increment\n\t\t * rq_in_driver here, and 2) decrement it in\n\t\t * bfq_finish_requeue_request. Such a solution would\n\t\t * let the value of the counter be always accurate,\n\t\t * but it would entail using an extra interface\n\t\t * function. This cost seems higher than the benefit,\n\t\t * being the frequency of non-elevator-private\n\t\t * requests very low.\n\t\t */\n\t\tgoto start_rq;\n\t}\n\n\tbfq_log(bfqd, \"dispatch requests: %d busy queues\",\n\t\tbfq_tot_busy_queues(bfqd));\n\n\tif (bfq_tot_busy_queues(bfqd) == 0)\n\t\tgoto exit;\n\n\t/*\n\t * Force device to serve one request at a time if\n\t * strict_guarantees is true. Forcing this service scheme is\n\t * currently the ONLY way to guarantee that the request\n\t * service order enforced by the scheduler is respected by a\n\t * queueing device. Otherwise the device is free even to make\n\t * some unlucky request wait for as long as the device\n\t * wishes.\n\t *\n\t * Of course, serving one request at at time may cause loss of\n\t * throughput.\n\t */\n\tif (bfqd->strict_guarantees && bfqd->rq_in_driver > 0)\n\t\tgoto exit;\n\n\tbfqq = bfq_select_queue(bfqd);\n\tif (!bfqq)\n\t\tgoto exit;\n\n\trq = bfq_dispatch_rq_from_bfqq(bfqd, bfqq);\n\n\tif (rq) {\ninc_in_driver_start_rq:\n\t\tbfqd->rq_in_driver++;\nstart_rq:\n\t\trq->rq_flags |= RQF_STARTED;\n\t}\nexit:\n\treturn rq;\n}\n\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\nstatic void bfq_update_dispatch_stats(struct request_queue *q,\n\t\t\t\t      struct request *rq,\n\t\t\t\t      struct bfq_queue *in_serv_queue,\n\t\t\t\t      bool idle_timer_disabled)\n{\n\tstruct bfq_queue *bfqq = rq ? RQ_BFQQ(rq) : NULL;\n\n\tif (!idle_timer_disabled && !bfqq)\n\t\treturn;\n\n\t/*\n\t * rq and bfqq are guaranteed to exist until this function\n\t * ends, for the following reasons. First, rq can be\n\t * dispatched to the device, and then can be completed and\n\t * freed, only after this function ends. Second, rq cannot be\n\t * merged (and thus freed because of a merge) any longer,\n\t * because it has already started. Thus rq cannot be freed\n\t * before this function ends, and, since rq has a reference to\n\t * bfqq, the same guarantee holds for bfqq too.\n\t *\n\t * In addition, the following queue lock guarantees that\n\t * bfqq_group(bfqq) exists as well.\n\t */\n\tspin_lock_irq(&q->queue_lock);\n\tif (idle_timer_disabled)\n\t\t/*\n\t\t * Since the idle timer has been disabled,\n\t\t * in_serv_queue contained some request when\n\t\t * __bfq_dispatch_request was invoked above, which\n\t\t * implies that rq was picked exactly from\n\t\t * in_serv_queue. Thus in_serv_queue == bfqq, and is\n\t\t * therefore guaranteed to exist because of the above\n\t\t * arguments.\n\t\t */\n\t\tbfqg_stats_update_idle_time(bfqq_group(in_serv_queue));\n\tif (bfqq) {\n\t\tstruct bfq_group *bfqg = bfqq_group(bfqq);\n\n\t\tbfqg_stats_update_avg_queue_size(bfqg);\n\t\tbfqg_stats_set_start_empty_time(bfqg);\n\t\tbfqg_stats_update_io_remove(bfqg, rq->cmd_flags);\n\t}\n\tspin_unlock_irq(&q->queue_lock);\n}\n#else\nstatic inline void bfq_update_dispatch_stats(struct request_queue *q,\n\t\t\t\t\t     struct request *rq,\n\t\t\t\t\t     struct bfq_queue *in_serv_queue,\n\t\t\t\t\t     bool idle_timer_disabled) {}\n#endif /* CONFIG_BFQ_CGROUP_DEBUG */\n\nstatic struct request *bfq_dispatch_request(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct bfq_data *bfqd = hctx->queue->elevator->elevator_data;\n\tstruct request *rq;\n\tstruct bfq_queue *in_serv_queue;\n\tbool waiting_rq, idle_timer_disabled;\n\n\tspin_lock_irq(&bfqd->lock);\n\n\tin_serv_queue = bfqd->in_service_queue;\n\twaiting_rq = in_serv_queue && bfq_bfqq_wait_request(in_serv_queue);\n\n\trq = __bfq_dispatch_request(hctx);\n\n\tidle_timer_disabled =\n\t\twaiting_rq && !bfq_bfqq_wait_request(in_serv_queue);\n\n\tspin_unlock_irq(&bfqd->lock);\n\n\tbfq_update_dispatch_stats(hctx->queue, rq, in_serv_queue,\n\t\t\t\t  idle_timer_disabled);\n\n\treturn rq;\n}\n\n/*\n * Task holds one reference to the queue, dropped when task exits.  Each rq\n * in-flight on this queue also holds a reference, dropped when rq is freed.\n *\n * Scheduler lock must be held here. Recall not to use bfqq after calling\n * this function on it.\n */\nvoid bfq_put_queue(struct bfq_queue *bfqq)\n{\n\tstruct bfq_queue *item;\n\tstruct hlist_node *n;\n\tstruct bfq_group *bfqg = bfqq_group(bfqq);\n\n\tif (bfqq->bfqd)\n\t\tbfq_log_bfqq(bfqq->bfqd, bfqq, \"put_queue: %p %d\",\n\t\t\t     bfqq, bfqq->ref);\n\n\tbfqq->ref--;\n\tif (bfqq->ref)\n\t\treturn;\n\n\tif (!hlist_unhashed(&bfqq->burst_list_node)) {\n\t\thlist_del_init(&bfqq->burst_list_node);\n\t\t/*\n\t\t * Decrement also burst size after the removal, if the\n\t\t * process associated with bfqq is exiting, and thus\n\t\t * does not contribute to the burst any longer. This\n\t\t * decrement helps filter out false positives of large\n\t\t * bursts, when some short-lived process (often due to\n\t\t * the execution of commands by some service) happens\n\t\t * to start and exit while a complex application is\n\t\t * starting, and thus spawning several processes that\n\t\t * do I/O (and that *must not* be treated as a large\n\t\t * burst, see comments on bfq_handle_burst).\n\t\t *\n\t\t * In particular, the decrement is performed only if:\n\t\t * 1) bfqq is not a merged queue, because, if it is,\n\t\t * then this free of bfqq is not triggered by the exit\n\t\t * of the process bfqq is associated with, but exactly\n\t\t * by the fact that bfqq has just been merged.\n\t\t * 2) burst_size is greater than 0, to handle\n\t\t * unbalanced decrements. Unbalanced decrements may\n\t\t * happen in te following case: bfqq is inserted into\n\t\t * the current burst list--without incrementing\n\t\t * bust_size--because of a split, but the current\n\t\t * burst list is not the burst list bfqq belonged to\n\t\t * (see comments on the case of a split in\n\t\t * bfq_set_request).\n\t\t */\n\t\tif (bfqq->bic && bfqq->bfqd->burst_size > 0)\n\t\t\tbfqq->bfqd->burst_size--;\n\t}\n\n\t/*\n\t * bfqq does not exist any longer, so it cannot be woken by\n\t * any other queue, and cannot wake any other queue. Then bfqq\n\t * must be removed from the woken list of its possible waker\n\t * queue, and all queues in the woken list of bfqq must stop\n\t * having a waker queue. Strictly speaking, these updates\n\t * should be performed when bfqq remains with no I/O source\n\t * attached to it, which happens before bfqq gets freed. In\n\t * particular, this happens when the last process associated\n\t * with bfqq exits or gets associated with a different\n\t * queue. However, both events lead to bfqq being freed soon,\n\t * and dangling references would come out only after bfqq gets\n\t * freed. So these updates are done here, as a simple and safe\n\t * way to handle all cases.\n\t */\n\t/* remove bfqq from woken list */\n\tif (!hlist_unhashed(&bfqq->woken_list_node))\n\t\thlist_del_init(&bfqq->woken_list_node);\n\n\t/* reset waker for all queues in woken list */\n\thlist_for_each_entry_safe(item, n, &bfqq->woken_list,\n\t\t\t\t  woken_list_node) {\n\t\titem->waker_bfqq = NULL;\n\t\tbfq_clear_bfqq_has_waker(item);\n\t\thlist_del_init(&item->woken_list_node);\n\t}\n\n\tif (bfqq->bfqd && bfqq->bfqd->last_completed_rq_bfqq == bfqq)\n\t\tbfqq->bfqd->last_completed_rq_bfqq = NULL;\n\n\tkmem_cache_free(bfq_pool, bfqq);\n\tbfqg_and_blkg_put(bfqg);\n}\n\nstatic void bfq_put_cooperator(struct bfq_queue *bfqq)\n{\n\tstruct bfq_queue *__bfqq, *next;\n\n\t/*\n\t * If this queue was scheduled to merge with another queue, be\n\t * sure to drop the reference taken on that queue (and others in\n\t * the merge chain). See bfq_setup_merge and bfq_merge_bfqqs.\n\t */\n\t__bfqq = bfqq->new_bfqq;\n\twhile (__bfqq) {\n\t\tif (__bfqq == bfqq)\n\t\t\tbreak;\n\t\tnext = __bfqq->new_bfqq;\n\t\tbfq_put_queue(__bfqq);\n\t\t__bfqq = next;\n\t}\n}\n\nstatic void bfq_exit_bfqq(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tif (bfqq == bfqd->in_service_queue) {\n\t\t__bfq_bfqq_expire(bfqd, bfqq, BFQQE_BUDGET_TIMEOUT);\n\t\tbfq_schedule_dispatch(bfqd);\n\t}\n\n\tbfq_log_bfqq(bfqd, bfqq, \"exit_bfqq: %p, %d\", bfqq, bfqq->ref);\n\n\tbfq_put_cooperator(bfqq);\n\n\tbfq_release_process_ref(bfqd, bfqq);\n}\n\nstatic void bfq_exit_icq_bfqq(struct bfq_io_cq *bic, bool is_sync)\n{\n\tstruct bfq_queue *bfqq = bic_to_bfqq(bic, is_sync);\n\tstruct bfq_data *bfqd;\n\n\tif (bfqq)\n\t\tbfqd = bfqq->bfqd; /* NULL if scheduler already exited */\n\n\tif (bfqq && bfqd) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&bfqd->lock, flags);\n\t\tbfqq->bic = NULL;\n\t\tbfq_exit_bfqq(bfqd, bfqq);\n\t\tbic_set_bfqq(bic, NULL, is_sync);\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t}\n}\n\nstatic void bfq_exit_icq(struct io_cq *icq)\n{\n\tstruct bfq_io_cq *bic = icq_to_bic(icq);\n\n\tbfq_exit_icq_bfqq(bic, true);\n\tbfq_exit_icq_bfqq(bic, false);\n}\n\n/*\n * Update the entity prio values; note that the new values will not\n * be used until the next (re)activation.\n */\nstatic void\nbfq_set_next_ioprio_data(struct bfq_queue *bfqq, struct bfq_io_cq *bic)\n{\n\tstruct task_struct *tsk = current;\n\tint ioprio_class;\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\n\tif (!bfqd)\n\t\treturn;\n\n\tioprio_class = IOPRIO_PRIO_CLASS(bic->ioprio);\n\tswitch (ioprio_class) {\n\tdefault:\n\t\tdev_err(bfqq->bfqd->queue->backing_dev_info->dev,\n\t\t\t\"bfq: bad prio class %d\\n\", ioprio_class);\n\t\t/* fall through */\n\tcase IOPRIO_CLASS_NONE:\n\t\t/*\n\t\t * No prio set, inherit CPU scheduling settings.\n\t\t */\n\t\tbfqq->new_ioprio = task_nice_ioprio(tsk);\n\t\tbfqq->new_ioprio_class = task_nice_ioclass(tsk);\n\t\tbreak;\n\tcase IOPRIO_CLASS_RT:\n\t\tbfqq->new_ioprio = IOPRIO_PRIO_DATA(bic->ioprio);\n\t\tbfqq->new_ioprio_class = IOPRIO_CLASS_RT;\n\t\tbreak;\n\tcase IOPRIO_CLASS_BE:\n\t\tbfqq->new_ioprio = IOPRIO_PRIO_DATA(bic->ioprio);\n\t\tbfqq->new_ioprio_class = IOPRIO_CLASS_BE;\n\t\tbreak;\n\tcase IOPRIO_CLASS_IDLE:\n\t\tbfqq->new_ioprio_class = IOPRIO_CLASS_IDLE;\n\t\tbfqq->new_ioprio = 7;\n\t\tbreak;\n\t}\n\n\tif (bfqq->new_ioprio >= IOPRIO_BE_NR) {\n\t\tpr_crit(\"bfq_set_next_ioprio_data: new_ioprio %d\\n\",\n\t\t\tbfqq->new_ioprio);\n\t\tbfqq->new_ioprio = IOPRIO_BE_NR;\n\t}\n\n\tbfqq->entity.new_weight = bfq_ioprio_to_weight(bfqq->new_ioprio);\n\tbfqq->entity.prio_changed = 1;\n}\n\nstatic struct bfq_queue *bfq_get_queue(struct bfq_data *bfqd,\n\t\t\t\t       struct bio *bio, bool is_sync,\n\t\t\t\t       struct bfq_io_cq *bic);\n\nstatic void bfq_check_ioprio_change(struct bfq_io_cq *bic, struct bio *bio)\n{\n\tstruct bfq_data *bfqd = bic_to_bfqd(bic);\n\tstruct bfq_queue *bfqq;\n\tint ioprio = bic->icq.ioc->ioprio;\n\n\t/*\n\t * This condition may trigger on a newly created bic, be sure to\n\t * drop the lock before returning.\n\t */\n\tif (unlikely(!bfqd) || likely(bic->ioprio == ioprio))\n\t\treturn;\n\n\tbic->ioprio = ioprio;\n\n\tbfqq = bic_to_bfqq(bic, false);\n\tif (bfqq) {\n\t\tbfq_release_process_ref(bfqd, bfqq);\n\t\tbfqq = bfq_get_queue(bfqd, bio, BLK_RW_ASYNC, bic);\n\t\tbic_set_bfqq(bic, bfqq, false);\n\t}\n\n\tbfqq = bic_to_bfqq(bic, true);\n\tif (bfqq)\n\t\tbfq_set_next_ioprio_data(bfqq, bic);\n}\n\nstatic void bfq_init_bfqq(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t  struct bfq_io_cq *bic, pid_t pid, int is_sync)\n{\n\tRB_CLEAR_NODE(&bfqq->entity.rb_node);\n\tINIT_LIST_HEAD(&bfqq->fifo);\n\tINIT_HLIST_NODE(&bfqq->burst_list_node);\n\tINIT_HLIST_NODE(&bfqq->woken_list_node);\n\tINIT_HLIST_HEAD(&bfqq->woken_list);\n\n\tbfqq->ref = 0;\n\tbfqq->bfqd = bfqd;\n\n\tif (bic)\n\t\tbfq_set_next_ioprio_data(bfqq, bic);\n\n\tif (is_sync) {\n\t\t/*\n\t\t * No need to mark as has_short_ttime if in\n\t\t * idle_class, because no device idling is performed\n\t\t * for queues in idle class\n\t\t */\n\t\tif (!bfq_class_idle(bfqq))\n\t\t\t/* tentatively mark as has_short_ttime */\n\t\t\tbfq_mark_bfqq_has_short_ttime(bfqq);\n\t\tbfq_mark_bfqq_sync(bfqq);\n\t\tbfq_mark_bfqq_just_created(bfqq);\n\t} else\n\t\tbfq_clear_bfqq_sync(bfqq);\n\n\t/* set end request to minus infinity from now */\n\tbfqq->ttime.last_end_request = ktime_get_ns() + 1;\n\n\tbfq_mark_bfqq_IO_bound(bfqq);\n\n\tbfqq->pid = pid;\n\n\t/* Tentative initial value to trade off between thr and lat */\n\tbfqq->max_budget = (2 * bfq_max_budget(bfqd)) / 3;\n\tbfqq->budget_timeout = bfq_smallest_from_now();\n\n\tbfqq->wr_coeff = 1;\n\tbfqq->last_wr_start_finish = jiffies;\n\tbfqq->wr_start_at_switch_to_srt = bfq_smallest_from_now();\n\tbfqq->split_time = bfq_smallest_from_now();\n\n\t/*\n\t * To not forget the possibly high bandwidth consumed by a\n\t * process/queue in the recent past,\n\t * bfq_bfqq_softrt_next_start() returns a value at least equal\n\t * to the current value of bfqq->soft_rt_next_start (see\n\t * comments on bfq_bfqq_softrt_next_start).  Set\n\t * soft_rt_next_start to now, to mean that bfqq has consumed\n\t * no bandwidth so far.\n\t */\n\tbfqq->soft_rt_next_start = jiffies;\n\n\t/* first request is almost certainly seeky */\n\tbfqq->seek_history = 1;\n}\n\nstatic struct bfq_queue **bfq_async_queue_prio(struct bfq_data *bfqd,\n\t\t\t\t\t       struct bfq_group *bfqg,\n\t\t\t\t\t       int ioprio_class, int ioprio)\n{\n\tswitch (ioprio_class) {\n\tcase IOPRIO_CLASS_RT:\n\t\treturn &bfqg->async_bfqq[0][ioprio];\n\tcase IOPRIO_CLASS_NONE:\n\t\tioprio = IOPRIO_NORM;\n\t\t/* fall through */\n\tcase IOPRIO_CLASS_BE:\n\t\treturn &bfqg->async_bfqq[1][ioprio];\n\tcase IOPRIO_CLASS_IDLE:\n\t\treturn &bfqg->async_idle_bfqq;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic struct bfq_queue *bfq_get_queue(struct bfq_data *bfqd,\n\t\t\t\t       struct bio *bio, bool is_sync,\n\t\t\t\t       struct bfq_io_cq *bic)\n{\n\tconst int ioprio = IOPRIO_PRIO_DATA(bic->ioprio);\n\tconst int ioprio_class = IOPRIO_PRIO_CLASS(bic->ioprio);\n\tstruct bfq_queue **async_bfqq = NULL;\n\tstruct bfq_queue *bfqq;\n\tstruct bfq_group *bfqg;\n\n\trcu_read_lock();\n\n\tbfqg = bfq_find_set_group(bfqd, __bio_blkcg(bio));\n\tif (!bfqg) {\n\t\tbfqq = &bfqd->oom_bfqq;\n\t\tgoto out;\n\t}\n\n\tif (!is_sync) {\n\t\tasync_bfqq = bfq_async_queue_prio(bfqd, bfqg, ioprio_class,\n\t\t\t\t\t\t  ioprio);\n\t\tbfqq = *async_bfqq;\n\t\tif (bfqq)\n\t\t\tgoto out;\n\t}\n\n\tbfqq = kmem_cache_alloc_node(bfq_pool,\n\t\t\t\t     GFP_NOWAIT | __GFP_ZERO | __GFP_NOWARN,\n\t\t\t\t     bfqd->queue->node);\n\n\tif (bfqq) {\n\t\tbfq_init_bfqq(bfqd, bfqq, bic, current->pid,\n\t\t\t      is_sync);\n\t\tbfq_init_entity(&bfqq->entity, bfqg);\n\t\tbfq_log_bfqq(bfqd, bfqq, \"allocated\");\n\t} else {\n\t\tbfqq = &bfqd->oom_bfqq;\n\t\tbfq_log_bfqq(bfqd, bfqq, \"using oom bfqq\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Pin the queue now that it's allocated, scheduler exit will\n\t * prune it.\n\t */\n\tif (async_bfqq) {\n\t\tbfqq->ref++; /*\n\t\t\t      * Extra group reference, w.r.t. sync\n\t\t\t      * queue. This extra reference is removed\n\t\t\t      * only if bfqq->bfqg disappears, to\n\t\t\t      * guarantee that this queue is not freed\n\t\t\t      * until its group goes away.\n\t\t\t      */\n\t\tbfq_log_bfqq(bfqd, bfqq, \"get_queue, bfqq not in async: %p, %d\",\n\t\t\t     bfqq, bfqq->ref);\n\t\t*async_bfqq = bfqq;\n\t}\n\nout:\n\tbfqq->ref++; /* get a process reference to this queue */\n\tbfq_log_bfqq(bfqd, bfqq, \"get_queue, at end: %p, %d\", bfqq, bfqq->ref);\n\trcu_read_unlock();\n\treturn bfqq;\n}\n\nstatic void bfq_update_io_thinktime(struct bfq_data *bfqd,\n\t\t\t\t    struct bfq_queue *bfqq)\n{\n\tstruct bfq_ttime *ttime = &bfqq->ttime;\n\tu64 elapsed = ktime_get_ns() - bfqq->ttime.last_end_request;\n\n\telapsed = min_t(u64, elapsed, 2ULL * bfqd->bfq_slice_idle);\n\n\tttime->ttime_samples = (7*bfqq->ttime.ttime_samples + 256) / 8;\n\tttime->ttime_total = div_u64(7*ttime->ttime_total + 256*elapsed,  8);\n\tttime->ttime_mean = div64_ul(ttime->ttime_total + 128,\n\t\t\t\t     ttime->ttime_samples);\n}\n\nstatic void\nbfq_update_io_seektime(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t       struct request *rq)\n{\n\tbfqq->seek_history <<= 1;\n\tbfqq->seek_history |= BFQ_RQ_SEEKY(bfqd, bfqq->last_request_pos, rq);\n\n\tif (bfqq->wr_coeff > 1 &&\n\t    bfqq->wr_cur_max_time == bfqd->bfq_wr_rt_max_time &&\n\t    BFQQ_TOTALLY_SEEKY(bfqq))\n\t\tbfq_bfqq_end_wr(bfqq);\n}\n\nstatic void bfq_update_has_short_ttime(struct bfq_data *bfqd,\n\t\t\t\t       struct bfq_queue *bfqq,\n\t\t\t\t       struct bfq_io_cq *bic)\n{\n\tbool has_short_ttime = true, state_changed;\n\n\t/*\n\t * No need to update has_short_ttime if bfqq is async or in\n\t * idle io prio class, or if bfq_slice_idle is zero, because\n\t * no device idling is performed for bfqq in this case.\n\t */\n\tif (!bfq_bfqq_sync(bfqq) || bfq_class_idle(bfqq) ||\n\t    bfqd->bfq_slice_idle == 0)\n\t\treturn;\n\n\t/* Idle window just restored, statistics are meaningless. */\n\tif (time_is_after_eq_jiffies(bfqq->split_time +\n\t\t\t\t     bfqd->bfq_wr_min_idle_time))\n\t\treturn;\n\n\t/* Think time is infinite if no process is linked to\n\t * bfqq. Otherwise check average think time to\n\t * decide whether to mark as has_short_ttime\n\t */\n\tif (atomic_read(&bic->icq.ioc->active_ref) == 0 ||\n\t    (bfq_sample_valid(bfqq->ttime.ttime_samples) &&\n\t     bfqq->ttime.ttime_mean > bfqd->bfq_slice_idle))\n\t\thas_short_ttime = false;\n\n\tstate_changed = has_short_ttime != bfq_bfqq_has_short_ttime(bfqq);\n\n\tif (has_short_ttime)\n\t\tbfq_mark_bfqq_has_short_ttime(bfqq);\n\telse\n\t\tbfq_clear_bfqq_has_short_ttime(bfqq);\n\n\t/*\n\t * Until the base value for the total service time gets\n\t * finally computed for bfqq, the inject limit does depend on\n\t * the think-time state (short|long). In particular, the limit\n\t * is 0 or 1 if the think time is deemed, respectively, as\n\t * short or long (details in the comments in\n\t * bfq_update_inject_limit()). Accordingly, the next\n\t * instructions reset the inject limit if the think-time state\n\t * has changed and the above base value is still to be\n\t * computed.\n\t *\n\t * However, the reset is performed only if more than 100 ms\n\t * have elapsed since the last update of the inject limit, or\n\t * (inclusive) if the change is from short to long think\n\t * time. The reason for this waiting is as follows.\n\t *\n\t * bfqq may have a long think time because of a\n\t * synchronization with some other queue, i.e., because the\n\t * I/O of some other queue may need to be completed for bfqq\n\t * to receive new I/O. Details in the comments on the choice\n\t * of the queue for injection in bfq_select_queue().\n\t *\n\t * As stressed in those comments, if such a synchronization is\n\t * actually in place, then, without injection on bfqq, the\n\t * blocking I/O cannot happen to served while bfqq is in\n\t * service. As a consequence, if bfqq is granted\n\t * I/O-dispatch-plugging, then bfqq remains empty, and no I/O\n\t * is dispatched, until the idle timeout fires. This is likely\n\t * to result in lower bandwidth and higher latencies for bfqq,\n\t * and in a severe loss of total throughput.\n\t *\n\t * On the opposite end, a non-zero inject limit may allow the\n\t * I/O that blocks bfqq to be executed soon, and therefore\n\t * bfqq to receive new I/O soon.\n\t *\n\t * But, if the blocking gets actually eliminated, then the\n\t * next think-time sample for bfqq may be very low. This in\n\t * turn may cause bfqq's think time to be deemed\n\t * short. Without the 100 ms barrier, this new state change\n\t * would cause the body of the next if to be executed\n\t * immediately. But this would set to 0 the inject\n\t * limit. Without injection, the blocking I/O would cause the\n\t * think time of bfqq to become long again, and therefore the\n\t * inject limit to be raised again, and so on. The only effect\n\t * of such a steady oscillation between the two think-time\n\t * states would be to prevent effective injection on bfqq.\n\t *\n\t * In contrast, if the inject limit is not reset during such a\n\t * long time interval as 100 ms, then the number of short\n\t * think time samples can grow significantly before the reset\n\t * is performed. As a consequence, the think time state can\n\t * become stable before the reset. Therefore there will be no\n\t * state change when the 100 ms elapse, and no reset of the\n\t * inject limit. The inject limit remains steadily equal to 1\n\t * both during and after the 100 ms. So injection can be\n\t * performed at all times, and throughput gets boosted.\n\t *\n\t * An inject limit equal to 1 is however in conflict, in\n\t * general, with the fact that the think time of bfqq is\n\t * short, because injection may be likely to delay bfqq's I/O\n\t * (as explained in the comments in\n\t * bfq_update_inject_limit()). But this does not happen in\n\t * this special case, because bfqq's low think time is due to\n\t * an effective handling of a synchronization, through\n\t * injection. In this special case, bfqq's I/O does not get\n\t * delayed by injection; on the contrary, bfqq's I/O is\n\t * brought forward, because it is not blocked for\n\t * milliseconds.\n\t *\n\t * In addition, serving the blocking I/O much sooner, and much\n\t * more frequently than once per I/O-plugging timeout, makes\n\t * it much quicker to detect a waker queue (the concept of\n\t * waker queue is defined in the comments in\n\t * bfq_add_request()). This makes it possible to start sooner\n\t * to boost throughput more effectively, by injecting the I/O\n\t * of the waker queue unconditionally on every\n\t * bfq_dispatch_request().\n\t *\n\t * One last, important benefit of not resetting the inject\n\t * limit before 100 ms is that, during this time interval, the\n\t * base value for the total service time is likely to get\n\t * finally computed for bfqq, freeing the inject limit from\n\t * its relation with the think time.\n\t */\n\tif (state_changed && bfqq->last_serv_time_ns == 0 &&\n\t    (time_is_before_eq_jiffies(bfqq->decrease_time_jif +\n\t\t\t\t      msecs_to_jiffies(100)) ||\n\t     !has_short_ttime))\n\t\tbfq_reset_inject_limit(bfqd, bfqq);\n}\n\n/*\n * Called when a new fs request (rq) is added to bfqq.  Check if there's\n * something we should do about it.\n */\nstatic void bfq_rq_enqueued(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t    struct request *rq)\n{\n\tif (rq->cmd_flags & REQ_META)\n\t\tbfqq->meta_pending++;\n\n\tbfqq->last_request_pos = blk_rq_pos(rq) + blk_rq_sectors(rq);\n\n\tif (bfqq == bfqd->in_service_queue && bfq_bfqq_wait_request(bfqq)) {\n\t\tbool small_req = bfqq->queued[rq_is_sync(rq)] == 1 &&\n\t\t\t\t blk_rq_sectors(rq) < 32;\n\t\tbool budget_timeout = bfq_bfqq_budget_timeout(bfqq);\n\n\t\t/*\n\t\t * There is just this request queued: if\n\t\t * - the request is small, and\n\t\t * - we are idling to boost throughput, and\n\t\t * - the queue is not to be expired,\n\t\t * then just exit.\n\t\t *\n\t\t * In this way, if the device is being idled to wait\n\t\t * for a new request from the in-service queue, we\n\t\t * avoid unplugging the device and committing the\n\t\t * device to serve just a small request. In contrast\n\t\t * we wait for the block layer to decide when to\n\t\t * unplug the device: hopefully, new requests will be\n\t\t * merged to this one quickly, then the device will be\n\t\t * unplugged and larger requests will be dispatched.\n\t\t */\n\t\tif (small_req && idling_boosts_thr_without_issues(bfqd, bfqq) &&\n\t\t    !budget_timeout)\n\t\t\treturn;\n\n\t\t/*\n\t\t * A large enough request arrived, or idling is being\n\t\t * performed to preserve service guarantees, or\n\t\t * finally the queue is to be expired: in all these\n\t\t * cases disk idling is to be stopped, so clear\n\t\t * wait_request flag and reset timer.\n\t\t */\n\t\tbfq_clear_bfqq_wait_request(bfqq);\n\t\thrtimer_try_to_cancel(&bfqd->idle_slice_timer);\n\n\t\t/*\n\t\t * The queue is not empty, because a new request just\n\t\t * arrived. Hence we can safely expire the queue, in\n\t\t * case of budget timeout, without risking that the\n\t\t * timestamps of the queue are not updated correctly.\n\t\t * See [1] for more details.\n\t\t */\n\t\tif (budget_timeout)\n\t\t\tbfq_bfqq_expire(bfqd, bfqq, false,\n\t\t\t\t\tBFQQE_BUDGET_TIMEOUT);\n\t}\n}\n\n/* returns true if it causes the idle timer to be disabled */\nstatic bool __bfq_insert_request(struct bfq_data *bfqd, struct request *rq)\n{\n\tstruct bfq_queue *bfqq = RQ_BFQQ(rq),\n\t\t*new_bfqq = bfq_setup_cooperator(bfqd, bfqq, rq, true);\n\tbool waiting, idle_timer_disabled = false;\n\n\tif (new_bfqq) {\n\t\t/*\n\t\t * Release the request's reference to the old bfqq\n\t\t * and make sure one is taken to the shared queue.\n\t\t */\n\t\tnew_bfqq->allocated++;\n\t\tbfqq->allocated--;\n\t\tnew_bfqq->ref++;\n\t\t/*\n\t\t * If the bic associated with the process\n\t\t * issuing this request still points to bfqq\n\t\t * (and thus has not been already redirected\n\t\t * to new_bfqq or even some other bfq_queue),\n\t\t * then complete the merge and redirect it to\n\t\t * new_bfqq.\n\t\t */\n\t\tif (bic_to_bfqq(RQ_BIC(rq), 1) == bfqq)\n\t\t\tbfq_merge_bfqqs(bfqd, RQ_BIC(rq),\n\t\t\t\t\tbfqq, new_bfqq);\n\n\t\tbfq_clear_bfqq_just_created(bfqq);\n\t\t/*\n\t\t * rq is about to be enqueued into new_bfqq,\n\t\t * release rq reference on bfqq\n\t\t */\n\t\tbfq_put_queue(bfqq);\n\t\trq->elv.priv[1] = new_bfqq;\n\t\tbfqq = new_bfqq;\n\t}\n\n\tbfq_update_io_thinktime(bfqd, bfqq);\n\tbfq_update_has_short_ttime(bfqd, bfqq, RQ_BIC(rq));\n\tbfq_update_io_seektime(bfqd, bfqq, rq);\n\n\twaiting = bfqq && bfq_bfqq_wait_request(bfqq);\n\tbfq_add_request(rq);\n\tidle_timer_disabled = waiting && !bfq_bfqq_wait_request(bfqq);\n\n\trq->fifo_time = ktime_get_ns() + bfqd->bfq_fifo_expire[rq_is_sync(rq)];\n\tlist_add_tail(&rq->queuelist, &bfqq->fifo);\n\n\tbfq_rq_enqueued(bfqd, bfqq, rq);\n\n\treturn idle_timer_disabled;\n}\n\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\nstatic void bfq_update_insert_stats(struct request_queue *q,\n\t\t\t\t    struct bfq_queue *bfqq,\n\t\t\t\t    bool idle_timer_disabled,\n\t\t\t\t    unsigned int cmd_flags)\n{\n\tif (!bfqq)\n\t\treturn;\n\n\t/*\n\t * bfqq still exists, because it can disappear only after\n\t * either it is merged with another queue, or the process it\n\t * is associated with exits. But both actions must be taken by\n\t * the same process currently executing this flow of\n\t * instructions.\n\t *\n\t * In addition, the following queue lock guarantees that\n\t * bfqq_group(bfqq) exists as well.\n\t */\n\tspin_lock_irq(&q->queue_lock);\n\tbfqg_stats_update_io_add(bfqq_group(bfqq), bfqq, cmd_flags);\n\tif (idle_timer_disabled)\n\t\tbfqg_stats_update_idle_time(bfqq_group(bfqq));\n\tspin_unlock_irq(&q->queue_lock);\n}\n#else\nstatic inline void bfq_update_insert_stats(struct request_queue *q,\n\t\t\t\t\t   struct bfq_queue *bfqq,\n\t\t\t\t\t   bool idle_timer_disabled,\n\t\t\t\t\t   unsigned int cmd_flags) {}\n#endif /* CONFIG_BFQ_CGROUP_DEBUG */\n\nstatic void bfq_insert_request(struct blk_mq_hw_ctx *hctx, struct request *rq,\n\t\t\t       bool at_head)\n{\n\tstruct request_queue *q = hctx->queue;\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\tstruct bfq_queue *bfqq;\n\tbool idle_timer_disabled = false;\n\tunsigned int cmd_flags;\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tif (!cgroup_subsys_on_dfl(io_cgrp_subsys) && rq->bio)\n\t\tbfqg_stats_update_legacy_io(q, rq);\n#endif\n\tspin_lock_irq(&bfqd->lock);\n\tif (blk_mq_sched_try_insert_merge(q, rq)) {\n\t\tspin_unlock_irq(&bfqd->lock);\n\t\treturn;\n\t}\n\n\tspin_unlock_irq(&bfqd->lock);\n\n\tblk_mq_sched_request_inserted(rq);\n\n\tspin_lock_irq(&bfqd->lock);\n\tbfqq = bfq_init_rq(rq);\n\tif (!bfqq || at_head || blk_rq_is_passthrough(rq)) {\n\t\tif (at_head)\n\t\t\tlist_add(&rq->queuelist, &bfqd->dispatch);\n\t\telse\n\t\t\tlist_add_tail(&rq->queuelist, &bfqd->dispatch);\n\t} else {\n\t\tidle_timer_disabled = __bfq_insert_request(bfqd, rq);\n\t\t/*\n\t\t * Update bfqq, because, if a queue merge has occurred\n\t\t * in __bfq_insert_request, then rq has been\n\t\t * redirected into a new queue.\n\t\t */\n\t\tbfqq = RQ_BFQQ(rq);\n\n\t\tif (rq_mergeable(rq)) {\n\t\t\telv_rqhash_add(q, rq);\n\t\t\tif (!q->last_merge)\n\t\t\t\tq->last_merge = rq;\n\t\t}\n\t}\n\n\t/*\n\t * Cache cmd_flags before releasing scheduler lock, because rq\n\t * may disappear afterwards (for example, because of a request\n\t * merge).\n\t */\n\tcmd_flags = rq->cmd_flags;\n\n\tspin_unlock_irq(&bfqd->lock);\n\n\tbfq_update_insert_stats(q, bfqq, idle_timer_disabled,\n\t\t\t\tcmd_flags);\n}\n\nstatic void bfq_insert_requests(struct blk_mq_hw_ctx *hctx,\n\t\t\t\tstruct list_head *list, bool at_head)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct request *rq;\n\n\t\trq = list_first_entry(list, struct request, queuelist);\n\t\tlist_del_init(&rq->queuelist);\n\t\tbfq_insert_request(hctx, rq, at_head);\n\t}\n}\n\nstatic void bfq_update_hw_tag(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq = bfqd->in_service_queue;\n\n\tbfqd->max_rq_in_driver = max_t(int, bfqd->max_rq_in_driver,\n\t\t\t\t       bfqd->rq_in_driver);\n\n\tif (bfqd->hw_tag == 1)\n\t\treturn;\n\n\t/*\n\t * This sample is valid if the number of outstanding requests\n\t * is large enough to allow a queueing behavior.  Note that the\n\t * sum is not exact, as it's not taking into account deactivated\n\t * requests.\n\t */\n\tif (bfqd->rq_in_driver + bfqd->queued <= BFQ_HW_QUEUE_THRESHOLD)\n\t\treturn;\n\n\t/*\n\t * If active queue hasn't enough requests and can idle, bfq might not\n\t * dispatch sufficient requests to hardware. Don't zero hw_tag in this\n\t * case\n\t */\n\tif (bfqq && bfq_bfqq_has_short_ttime(bfqq) &&\n\t    bfqq->dispatched + bfqq->queued[0] + bfqq->queued[1] <\n\t    BFQ_HW_QUEUE_THRESHOLD &&\n\t    bfqd->rq_in_driver < BFQ_HW_QUEUE_THRESHOLD)\n\t\treturn;\n\n\tif (bfqd->hw_tag_samples++ < BFQ_HW_QUEUE_SAMPLES)\n\t\treturn;\n\n\tbfqd->hw_tag = bfqd->max_rq_in_driver > BFQ_HW_QUEUE_THRESHOLD;\n\tbfqd->max_rq_in_driver = 0;\n\tbfqd->hw_tag_samples = 0;\n\n\tbfqd->nonrot_with_queueing =\n\t\tblk_queue_nonrot(bfqd->queue) && bfqd->hw_tag;\n}\n\nstatic void bfq_completed_request(struct bfq_queue *bfqq, struct bfq_data *bfqd)\n{\n\tu64 now_ns;\n\tu32 delta_us;\n\n\tbfq_update_hw_tag(bfqd);\n\n\tbfqd->rq_in_driver--;\n\tbfqq->dispatched--;\n\n\tif (!bfqq->dispatched && !bfq_bfqq_busy(bfqq)) {\n\t\t/*\n\t\t * Set budget_timeout (which we overload to store the\n\t\t * time at which the queue remains with no backlog and\n\t\t * no outstanding request; used by the weight-raising\n\t\t * mechanism).\n\t\t */\n\t\tbfqq->budget_timeout = jiffies;\n\n\t\tbfq_weights_tree_remove(bfqd, bfqq);\n\t}\n\n\tnow_ns = ktime_get_ns();\n\n\tbfqq->ttime.last_end_request = now_ns;\n\n\t/*\n\t * Using us instead of ns, to get a reasonable precision in\n\t * computing rate in next check.\n\t */\n\tdelta_us = div_u64(now_ns - bfqd->last_completion, NSEC_PER_USEC);\n\n\t/*\n\t * If the request took rather long to complete, and, according\n\t * to the maximum request size recorded, this completion latency\n\t * implies that the request was certainly served at a very low\n\t * rate (less than 1M sectors/sec), then the whole observation\n\t * interval that lasts up to this time instant cannot be a\n\t * valid time interval for computing a new peak rate.  Invoke\n\t * bfq_update_rate_reset to have the following three steps\n\t * taken:\n\t * - close the observation interval at the last (previous)\n\t *   request dispatch or completion\n\t * - compute rate, if possible, for that observation interval\n\t * - reset to zero samples, which will trigger a proper\n\t *   re-initialization of the observation interval on next\n\t *   dispatch\n\t */\n\tif (delta_us > BFQ_MIN_TT/NSEC_PER_USEC &&\n\t   (bfqd->last_rq_max_size<<BFQ_RATE_SHIFT)/delta_us <\n\t\t\t1UL<<(BFQ_RATE_SHIFT - 10))\n\t\tbfq_update_rate_reset(bfqd, NULL);\n\tbfqd->last_completion = now_ns;\n\tbfqd->last_completed_rq_bfqq = bfqq;\n\n\t/*\n\t * If we are waiting to discover whether the request pattern\n\t * of the task associated with the queue is actually\n\t * isochronous, and both requisites for this condition to hold\n\t * are now satisfied, then compute soft_rt_next_start (see the\n\t * comments on the function bfq_bfqq_softrt_next_start()). We\n\t * do not compute soft_rt_next_start if bfqq is in interactive\n\t * weight raising (see the comments in bfq_bfqq_expire() for\n\t * an explanation). We schedule this delayed update when bfqq\n\t * expires, if it still has in-flight requests.\n\t */\n\tif (bfq_bfqq_softrt_update(bfqq) && bfqq->dispatched == 0 &&\n\t    RB_EMPTY_ROOT(&bfqq->sort_list) &&\n\t    bfqq->wr_coeff != bfqd->bfq_wr_coeff)\n\t\tbfqq->soft_rt_next_start =\n\t\t\tbfq_bfqq_softrt_next_start(bfqd, bfqq);\n\n\t/*\n\t * If this is the in-service queue, check if it needs to be expired,\n\t * or if we want to idle in case it has no pending requests.\n\t */\n\tif (bfqd->in_service_queue == bfqq) {\n\t\tif (bfq_bfqq_must_idle(bfqq)) {\n\t\t\tif (bfqq->dispatched == 0)\n\t\t\t\tbfq_arm_slice_timer(bfqd);\n\t\t\t/*\n\t\t\t * If we get here, we do not expire bfqq, even\n\t\t\t * if bfqq was in budget timeout or had no\n\t\t\t * more requests (as controlled in the next\n\t\t\t * conditional instructions). The reason for\n\t\t\t * not expiring bfqq is as follows.\n\t\t\t *\n\t\t\t * Here bfqq->dispatched > 0 holds, but\n\t\t\t * bfq_bfqq_must_idle() returned true. This\n\t\t\t * implies that, even if no request arrives\n\t\t\t * for bfqq before bfqq->dispatched reaches 0,\n\t\t\t * bfqq will, however, not be expired on the\n\t\t\t * completion event that causes bfqq->dispatch\n\t\t\t * to reach zero. In contrast, on this event,\n\t\t\t * bfqq will start enjoying device idling\n\t\t\t * (I/O-dispatch plugging).\n\t\t\t *\n\t\t\t * But, if we expired bfqq here, bfqq would\n\t\t\t * not have the chance to enjoy device idling\n\t\t\t * when bfqq->dispatched finally reaches\n\t\t\t * zero. This would expose bfqq to violation\n\t\t\t * of its reserved service guarantees.\n\t\t\t */\n\t\t\treturn;\n\t\t} else if (bfq_may_expire_for_budg_timeout(bfqq))\n\t\t\tbfq_bfqq_expire(bfqd, bfqq, false,\n\t\t\t\t\tBFQQE_BUDGET_TIMEOUT);\n\t\telse if (RB_EMPTY_ROOT(&bfqq->sort_list) &&\n\t\t\t (bfqq->dispatched == 0 ||\n\t\t\t  !bfq_better_to_idle(bfqq)))\n\t\t\tbfq_bfqq_expire(bfqd, bfqq, false,\n\t\t\t\t\tBFQQE_NO_MORE_REQUESTS);\n\t}\n\n\tif (!bfqd->rq_in_driver)\n\t\tbfq_schedule_dispatch(bfqd);\n}\n\nstatic void bfq_finish_requeue_request_body(struct bfq_queue *bfqq)\n{\n\tbfqq->allocated--;\n\n\tbfq_put_queue(bfqq);\n}\n\n/*\n * The processes associated with bfqq may happen to generate their\n * cumulative I/O at a lower rate than the rate at which the device\n * could serve the same I/O. This is rather probable, e.g., if only\n * one process is associated with bfqq and the device is an SSD. It\n * results in bfqq becoming often empty while in service. In this\n * respect, if BFQ is allowed to switch to another queue when bfqq\n * remains empty, then the device goes on being fed with I/O requests,\n * and the throughput is not affected. In contrast, if BFQ is not\n * allowed to switch to another queue---because bfqq is sync and\n * I/O-dispatch needs to be plugged while bfqq is temporarily\n * empty---then, during the service of bfqq, there will be frequent\n * \"service holes\", i.e., time intervals during which bfqq gets empty\n * and the device can only consume the I/O already queued in its\n * hardware queues. During service holes, the device may even get to\n * remaining idle. In the end, during the service of bfqq, the device\n * is driven at a lower speed than the one it can reach with the kind\n * of I/O flowing through bfqq.\n *\n * To counter this loss of throughput, BFQ implements a \"request\n * injection mechanism\", which tries to fill the above service holes\n * with I/O requests taken from other queues. The hard part in this\n * mechanism is finding the right amount of I/O to inject, so as to\n * both boost throughput and not break bfqq's bandwidth and latency\n * guarantees. In this respect, the mechanism maintains a per-queue\n * inject limit, computed as below. While bfqq is empty, the injection\n * mechanism dispatches extra I/O requests only until the total number\n * of I/O requests in flight---i.e., already dispatched but not yet\n * completed---remains lower than this limit.\n *\n * A first definition comes in handy to introduce the algorithm by\n * which the inject limit is computed.  We define as first request for\n * bfqq, an I/O request for bfqq that arrives while bfqq is in\n * service, and causes bfqq to switch from empty to non-empty. The\n * algorithm updates the limit as a function of the effect of\n * injection on the service times of only the first requests of\n * bfqq. The reason for this restriction is that these are the\n * requests whose service time is affected most, because they are the\n * first to arrive after injection possibly occurred.\n *\n * To evaluate the effect of injection, the algorithm measures the\n * \"total service time\" of first requests. We define as total service\n * time of an I/O request, the time that elapses since when the\n * request is enqueued into bfqq, to when it is completed. This\n * quantity allows the whole effect of injection to be measured. It is\n * easy to see why. Suppose that some requests of other queues are\n * actually injected while bfqq is empty, and that a new request R\n * then arrives for bfqq. If the device does start to serve all or\n * part of the injected requests during the service hole, then,\n * because of this extra service, it may delay the next invocation of\n * the dispatch hook of BFQ. Then, even after R gets eventually\n * dispatched, the device may delay the actual service of R if it is\n * still busy serving the extra requests, or if it decides to serve,\n * before R, some extra request still present in its queues. As a\n * conclusion, the cumulative extra delay caused by injection can be\n * easily evaluated by just comparing the total service time of first\n * requests with and without injection.\n *\n * The limit-update algorithm works as follows. On the arrival of a\n * first request of bfqq, the algorithm measures the total time of the\n * request only if one of the three cases below holds, and, for each\n * case, it updates the limit as described below:\n *\n * (1) If there is no in-flight request. This gives a baseline for the\n *     total service time of the requests of bfqq. If the baseline has\n *     not been computed yet, then, after computing it, the limit is\n *     set to 1, to start boosting throughput, and to prepare the\n *     ground for the next case. If the baseline has already been\n *     computed, then it is updated, in case it results to be lower\n *     than the previous value.\n *\n * (2) If the limit is higher than 0 and there are in-flight\n *     requests. By comparing the total service time in this case with\n *     the above baseline, it is possible to know at which extent the\n *     current value of the limit is inflating the total service\n *     time. If the inflation is below a certain threshold, then bfqq\n *     is assumed to be suffering from no perceivable loss of its\n *     service guarantees, and the limit is even tentatively\n *     increased. If the inflation is above the threshold, then the\n *     limit is decreased. Due to the lack of any hysteresis, this\n *     logic makes the limit oscillate even in steady workload\n *     conditions. Yet we opted for it, because it is fast in reaching\n *     the best value for the limit, as a function of the current I/O\n *     workload. To reduce oscillations, this step is disabled for a\n *     short time interval after the limit happens to be decreased.\n *\n * (3) Periodically, after resetting the limit, to make sure that the\n *     limit eventually drops in case the workload changes. This is\n *     needed because, after the limit has gone safely up for a\n *     certain workload, it is impossible to guess whether the\n *     baseline total service time may have changed, without measuring\n *     it again without injection. A more effective version of this\n *     step might be to just sample the baseline, by interrupting\n *     injection only once, and then to reset/lower the limit only if\n *     the total service time with the current limit does happen to be\n *     too large.\n *\n * More details on each step are provided in the comments on the\n * pieces of code that implement these steps: the branch handling the\n * transition from empty to non empty in bfq_add_request(), the branch\n * handling injection in bfq_select_queue(), and the function\n * bfq_choose_bfqq_for_injection(). These comments also explain some\n * exceptions, made by the injection mechanism in some special cases.\n */\nstatic void bfq_update_inject_limit(struct bfq_data *bfqd,\n\t\t\t\t    struct bfq_queue *bfqq)\n{\n\tu64 tot_time_ns = ktime_get_ns() - bfqd->last_empty_occupied_ns;\n\tunsigned int old_limit = bfqq->inject_limit;\n\n\tif (bfqq->last_serv_time_ns > 0 && bfqd->rqs_injected) {\n\t\tu64 threshold = (bfqq->last_serv_time_ns * 3)>>1;\n\n\t\tif (tot_time_ns >= threshold && old_limit > 0) {\n\t\t\tbfqq->inject_limit--;\n\t\t\tbfqq->decrease_time_jif = jiffies;\n\t\t} else if (tot_time_ns < threshold &&\n\t\t\t   old_limit <= bfqd->max_rq_in_driver)\n\t\t\tbfqq->inject_limit++;\n\t}\n\n\t/*\n\t * Either we still have to compute the base value for the\n\t * total service time, and there seem to be the right\n\t * conditions to do it, or we can lower the last base value\n\t * computed.\n\t *\n\t * NOTE: (bfqd->rq_in_driver == 1) means that there is no I/O\n\t * request in flight, because this function is in the code\n\t * path that handles the completion of a request of bfqq, and,\n\t * in particular, this function is executed before\n\t * bfqd->rq_in_driver is decremented in such a code path.\n\t */\n\tif ((bfqq->last_serv_time_ns == 0 && bfqd->rq_in_driver == 1) ||\n\t    tot_time_ns < bfqq->last_serv_time_ns) {\n\t\tif (bfqq->last_serv_time_ns == 0) {\n\t\t\t/*\n\t\t\t * Now we certainly have a base value: make sure we\n\t\t\t * start trying injection.\n\t\t\t */\n\t\t\tbfqq->inject_limit = max_t(unsigned int, 1, old_limit);\n\t\t}\n\t\tbfqq->last_serv_time_ns = tot_time_ns;\n\t} else if (!bfqd->rqs_injected && bfqd->rq_in_driver == 1)\n\t\t/*\n\t\t * No I/O injected and no request still in service in\n\t\t * the drive: these are the exact conditions for\n\t\t * computing the base value of the total service time\n\t\t * for bfqq. So let's update this value, because it is\n\t\t * rather variable. For example, it varies if the size\n\t\t * or the spatial locality of the I/O requests in bfqq\n\t\t * change.\n\t\t */\n\t\tbfqq->last_serv_time_ns = tot_time_ns;\n\n\n\t/* update complete, not waiting for any request completion any longer */\n\tbfqd->waited_rq = NULL;\n\tbfqd->rqs_injected = false;\n}\n\n/*\n * Handle either a requeue or a finish for rq. The things to do are\n * the same in both cases: all references to rq are to be dropped. In\n * particular, rq is considered completed from the point of view of\n * the scheduler.\n */\nstatic void bfq_finish_requeue_request(struct request *rq)\n{\n\tstruct bfq_queue *bfqq = RQ_BFQQ(rq);\n\tstruct bfq_data *bfqd;\n\n\t/*\n\t * Requeue and finish hooks are invoked in blk-mq without\n\t * checking whether the involved request is actually still\n\t * referenced in the scheduler. To handle this fact, the\n\t * following two checks make this function exit in case of\n\t * spurious invocations, for which there is nothing to do.\n\t *\n\t * First, check whether rq has nothing to do with an elevator.\n\t */\n\tif (unlikely(!(rq->rq_flags & RQF_ELVPRIV)))\n\t\treturn;\n\n\t/*\n\t * rq either is not associated with any icq, or is an already\n\t * requeued request that has not (yet) been re-inserted into\n\t * a bfq_queue.\n\t */\n\tif (!rq->elv.icq || !bfqq)\n\t\treturn;\n\n\tbfqd = bfqq->bfqd;\n\n\tif (rq->rq_flags & RQF_STARTED)\n\t\tbfqg_stats_update_completion(bfqq_group(bfqq),\n\t\t\t\t\t     rq->start_time_ns,\n\t\t\t\t\t     rq->io_start_time_ns,\n\t\t\t\t\t     rq->cmd_flags);\n\n\tif (likely(rq->rq_flags & RQF_STARTED)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&bfqd->lock, flags);\n\n\t\tif (rq == bfqd->waited_rq)\n\t\t\tbfq_update_inject_limit(bfqd, bfqq);\n\n\t\tbfq_completed_request(bfqq, bfqd);\n\t\tbfq_finish_requeue_request_body(bfqq);\n\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t} else {\n\t\t/*\n\t\t * Request rq may be still/already in the scheduler,\n\t\t * in which case we need to remove it (this should\n\t\t * never happen in case of requeue). And we cannot\n\t\t * defer such a check and removal, to avoid\n\t\t * inconsistencies in the time interval from the end\n\t\t * of this function to the start of the deferred work.\n\t\t * This situation seems to occur only in process\n\t\t * context, as a consequence of a merge. In the\n\t\t * current version of the code, this implies that the\n\t\t * lock is held.\n\t\t */\n\n\t\tif (!RB_EMPTY_NODE(&rq->rb_node)) {\n\t\t\tbfq_remove_request(rq->q, rq);\n\t\t\tbfqg_stats_update_io_remove(bfqq_group(bfqq),\n\t\t\t\t\t\t    rq->cmd_flags);\n\t\t}\n\t\tbfq_finish_requeue_request_body(bfqq);\n\t}\n\n\t/*\n\t * Reset private fields. In case of a requeue, this allows\n\t * this function to correctly do nothing if it is spuriously\n\t * invoked again on this same request (see the check at the\n\t * beginning of the function). Probably, a better general\n\t * design would be to prevent blk-mq from invoking the requeue\n\t * or finish hooks of an elevator, for a request that is not\n\t * referred by that elevator.\n\t *\n\t * Resetting the following fields would break the\n\t * request-insertion logic if rq is re-inserted into a bfq\n\t * internal queue, without a re-preparation. Here we assume\n\t * that re-insertions of requeued requests, without\n\t * re-preparation, can happen only for pass_through or at_head\n\t * requests (which are not re-inserted into bfq internal\n\t * queues).\n\t */\n\trq->elv.priv[0] = NULL;\n\trq->elv.priv[1] = NULL;\n}\n\n/*\n * Removes the association between the current task and bfqq, assuming\n * that bic points to the bfq iocontext of the task.\n * Returns NULL if a new bfqq should be allocated, or the old bfqq if this\n * was the last process referring to that bfqq.\n */\nstatic struct bfq_queue *\nbfq_split_bfqq(struct bfq_io_cq *bic, struct bfq_queue *bfqq)\n{\n\tbfq_log_bfqq(bfqq->bfqd, bfqq, \"splitting queue\");\n\n\tif (bfqq_process_refs(bfqq) == 1) {\n\t\tbfqq->pid = current->pid;\n\t\tbfq_clear_bfqq_coop(bfqq);\n\t\tbfq_clear_bfqq_split_coop(bfqq);\n\t\treturn bfqq;\n\t}\n\n\tbic_set_bfqq(bic, NULL, 1);\n\n\tbfq_put_cooperator(bfqq);\n\n\tbfq_release_process_ref(bfqq->bfqd, bfqq);\n\treturn NULL;\n}\n\nstatic struct bfq_queue *bfq_get_bfqq_handle_split(struct bfq_data *bfqd,\n\t\t\t\t\t\t   struct bfq_io_cq *bic,\n\t\t\t\t\t\t   struct bio *bio,\n\t\t\t\t\t\t   bool split, bool is_sync,\n\t\t\t\t\t\t   bool *new_queue)\n{\n\tstruct bfq_queue *bfqq = bic_to_bfqq(bic, is_sync);\n\n\tif (likely(bfqq && bfqq != &bfqd->oom_bfqq))\n\t\treturn bfqq;\n\n\tif (new_queue)\n\t\t*new_queue = true;\n\n\tif (bfqq)\n\t\tbfq_put_queue(bfqq);\n\tbfqq = bfq_get_queue(bfqd, bio, is_sync, bic);\n\n\tbic_set_bfqq(bic, bfqq, is_sync);\n\tif (split && is_sync) {\n\t\tif ((bic->was_in_burst_list && bfqd->large_burst) ||\n\t\t    bic->saved_in_large_burst)\n\t\t\tbfq_mark_bfqq_in_large_burst(bfqq);\n\t\telse {\n\t\t\tbfq_clear_bfqq_in_large_burst(bfqq);\n\t\t\tif (bic->was_in_burst_list)\n\t\t\t\t/*\n\t\t\t\t * If bfqq was in the current\n\t\t\t\t * burst list before being\n\t\t\t\t * merged, then we have to add\n\t\t\t\t * it back. And we do not need\n\t\t\t\t * to increase burst_size, as\n\t\t\t\t * we did not decrement\n\t\t\t\t * burst_size when we removed\n\t\t\t\t * bfqq from the burst list as\n\t\t\t\t * a consequence of a merge\n\t\t\t\t * (see comments in\n\t\t\t\t * bfq_put_queue). In this\n\t\t\t\t * respect, it would be rather\n\t\t\t\t * costly to know whether the\n\t\t\t\t * current burst list is still\n\t\t\t\t * the same burst list from\n\t\t\t\t * which bfqq was removed on\n\t\t\t\t * the merge. To avoid this\n\t\t\t\t * cost, if bfqq was in a\n\t\t\t\t * burst list, then we add\n\t\t\t\t * bfqq to the current burst\n\t\t\t\t * list without any further\n\t\t\t\t * check. This can cause\n\t\t\t\t * inappropriate insertions,\n\t\t\t\t * but rarely enough to not\n\t\t\t\t * harm the detection of large\n\t\t\t\t * bursts significantly.\n\t\t\t\t */\n\t\t\t\thlist_add_head(&bfqq->burst_list_node,\n\t\t\t\t\t       &bfqd->burst_list);\n\t\t}\n\t\tbfqq->split_time = jiffies;\n\t}\n\n\treturn bfqq;\n}\n\n/*\n * Only reset private fields. The actual request preparation will be\n * performed by bfq_init_rq, when rq is either inserted or merged. See\n * comments on bfq_init_rq for the reason behind this delayed\n * preparation.\n */\nstatic void bfq_prepare_request(struct request *rq, struct bio *bio)\n{\n\t/*\n\t * Regardless of whether we have an icq attached, we have to\n\t * clear the scheduler pointers, as they might point to\n\t * previously allocated bic/bfqq structs.\n\t */\n\trq->elv.priv[0] = rq->elv.priv[1] = NULL;\n}\n\n/*\n * If needed, init rq, allocate bfq data structures associated with\n * rq, and increment reference counters in the destination bfq_queue\n * for rq. Return the destination bfq_queue for rq, or NULL is rq is\n * not associated with any bfq_queue.\n *\n * This function is invoked by the functions that perform rq insertion\n * or merging. One may have expected the above preparation operations\n * to be performed in bfq_prepare_request, and not delayed to when rq\n * is inserted or merged. The rationale behind this delayed\n * preparation is that, after the prepare_request hook is invoked for\n * rq, rq may still be transformed into a request with no icq, i.e., a\n * request not associated with any queue. No bfq hook is invoked to\n * signal this transformation. As a consequence, should these\n * preparation operations be performed when the prepare_request hook\n * is invoked, and should rq be transformed one moment later, bfq\n * would end up in an inconsistent state, because it would have\n * incremented some queue counters for an rq destined to\n * transformation, without any chance to correctly lower these\n * counters back. In contrast, no transformation can still happen for\n * rq after rq has been inserted or merged. So, it is safe to execute\n * these preparation operations when rq is finally inserted or merged.\n */\nstatic struct bfq_queue *bfq_init_rq(struct request *rq)\n{\n\tstruct request_queue *q = rq->q;\n\tstruct bio *bio = rq->bio;\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\tstruct bfq_io_cq *bic;\n\tconst int is_sync = rq_is_sync(rq);\n\tstruct bfq_queue *bfqq;\n\tbool new_queue = false;\n\tbool bfqq_already_existing = false, split = false;\n\n\tif (unlikely(!rq->elv.icq))\n\t\treturn NULL;\n\n\t/*\n\t * Assuming that elv.priv[1] is set only if everything is set\n\t * for this rq. This holds true, because this function is\n\t * invoked only for insertion or merging, and, after such\n\t * events, a request cannot be manipulated any longer before\n\t * being removed from bfq.\n\t */\n\tif (rq->elv.priv[1])\n\t\treturn rq->elv.priv[1];\n\n\tbic = icq_to_bic(rq->elv.icq);\n\n\tbfq_check_ioprio_change(bic, bio);\n\n\tbfq_bic_update_cgroup(bic, bio);\n\n\tbfqq = bfq_get_bfqq_handle_split(bfqd, bic, bio, false, is_sync,\n\t\t\t\t\t &new_queue);\n\n\tif (likely(!new_queue)) {\n\t\t/* If the queue was seeky for too long, break it apart. */\n\t\tif (bfq_bfqq_coop(bfqq) && bfq_bfqq_split_coop(bfqq)) {\n\t\t\tbfq_log_bfqq(bfqd, bfqq, \"breaking apart bfqq\");\n\n\t\t\t/* Update bic before losing reference to bfqq */\n\t\t\tif (bfq_bfqq_in_large_burst(bfqq))\n\t\t\t\tbic->saved_in_large_burst = true;\n\n\t\t\tbfqq = bfq_split_bfqq(bic, bfqq);\n\t\t\tsplit = true;\n\n\t\t\tif (!bfqq)\n\t\t\t\tbfqq = bfq_get_bfqq_handle_split(bfqd, bic, bio,\n\t\t\t\t\t\t\t\t true, is_sync,\n\t\t\t\t\t\t\t\t NULL);\n\t\t\telse\n\t\t\t\tbfqq_already_existing = true;\n\t\t}\n\t}\n\n\tbfqq->allocated++;\n\tbfqq->ref++;\n\tbfq_log_bfqq(bfqd, bfqq, \"get_request %p: bfqq %p, %d\",\n\t\t     rq, bfqq, bfqq->ref);\n\n\trq->elv.priv[0] = bic;\n\trq->elv.priv[1] = bfqq;\n\n\t/*\n\t * If a bfq_queue has only one process reference, it is owned\n\t * by only this bic: we can then set bfqq->bic = bic. in\n\t * addition, if the queue has also just been split, we have to\n\t * resume its state.\n\t */\n\tif (likely(bfqq != &bfqd->oom_bfqq) && bfqq_process_refs(bfqq) == 1) {\n\t\tbfqq->bic = bic;\n\t\tif (split) {\n\t\t\t/*\n\t\t\t * The queue has just been split from a shared\n\t\t\t * queue: restore the idle window and the\n\t\t\t * possible weight raising period.\n\t\t\t */\n\t\t\tbfq_bfqq_resume_state(bfqq, bfqd, bic,\n\t\t\t\t\t      bfqq_already_existing);\n\t\t}\n\t}\n\n\t/*\n\t * Consider bfqq as possibly belonging to a burst of newly\n\t * created queues only if:\n\t * 1) A burst is actually happening (bfqd->burst_size > 0)\n\t * or\n\t * 2) There is no other active queue. In fact, if, in\n\t *    contrast, there are active queues not belonging to the\n\t *    possible burst bfqq may belong to, then there is no gain\n\t *    in considering bfqq as belonging to a burst, and\n\t *    therefore in not weight-raising bfqq. See comments on\n\t *    bfq_handle_burst().\n\t *\n\t * This filtering also helps eliminating false positives,\n\t * occurring when bfqq does not belong to an actual large\n\t * burst, but some background task (e.g., a service) happens\n\t * to trigger the creation of new queues very close to when\n\t * bfqq and its possible companion queues are created. See\n\t * comments on bfq_handle_burst() for further details also on\n\t * this issue.\n\t */\n\tif (unlikely(bfq_bfqq_just_created(bfqq) &&\n\t\t     (bfqd->burst_size > 0 ||\n\t\t      bfq_tot_busy_queues(bfqd) == 0)))\n\t\tbfq_handle_burst(bfqd, bfqq);\n\n\treturn bfqq;\n}\n\nstatic void\nbfq_idle_slice_timer_body(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\n\t/*\n\t * Considering that bfqq may be in race, we should firstly check\n\t * whether bfqq is in service before doing something on it. If\n\t * the bfqq in race is not in service, it has already been expired\n\t * through __bfq_bfqq_expire func and its wait_request flags has\n\t * been cleared in __bfq_bfqd_reset_in_service func.\n\t */\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\n\tbfq_clear_bfqq_wait_request(bfqq);\n\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\t/*\n\t\t * Also here the queue can be safely expired\n\t\t * for budget timeout without wasting\n\t\t * guarantees\n\t\t */\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\t/*\n\t\t * The queue may not be empty upon timer expiration,\n\t\t * because we may not disable the timer when the\n\t\t * first request of the in-service queue arrives\n\t\t * during disk idling.\n\t\t */\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\n\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);\n}\n\n/*\n * Handler of the expiration of the timer running if the in-service queue\n * is idling inside its time slice.\n */\nstatic enum hrtimer_restart bfq_idle_slice_timer(struct hrtimer *timer)\n{\n\tstruct bfq_data *bfqd = container_of(timer, struct bfq_data,\n\t\t\t\t\t     idle_slice_timer);\n\tstruct bfq_queue *bfqq = bfqd->in_service_queue;\n\n\t/*\n\t * Theoretical race here: the in-service queue can be NULL or\n\t * different from the queue that was idling if a new request\n\t * arrives for the current queue and there is a full dispatch\n\t * cycle that changes the in-service queue.  This can hardly\n\t * happen, but in the worst case we just expire a queue too\n\t * early.\n\t */\n\tif (bfqq)\n\t\tbfq_idle_slice_timer_body(bfqd, bfqq);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void __bfq_put_async_bfqq(struct bfq_data *bfqd,\n\t\t\t\t struct bfq_queue **bfqq_ptr)\n{\n\tstruct bfq_queue *bfqq = *bfqq_ptr;\n\n\tbfq_log(bfqd, \"put_async_bfqq: %p\", bfqq);\n\tif (bfqq) {\n\t\tbfq_bfqq_move(bfqd, bfqq, bfqd->root_group);\n\n\t\tbfq_log_bfqq(bfqd, bfqq, \"put_async_bfqq: putting %p, %d\",\n\t\t\t     bfqq, bfqq->ref);\n\t\tbfq_put_queue(bfqq);\n\t\t*bfqq_ptr = NULL;\n\t}\n}\n\n/*\n * Release all the bfqg references to its async queues.  If we are\n * deallocating the group these queues may still contain requests, so\n * we reparent them to the root cgroup (i.e., the only one that will\n * exist for sure until all the requests on a device are gone).\n */\nvoid bfq_put_async_queues(struct bfq_data *bfqd, struct bfq_group *bfqg)\n{\n\tint i, j;\n\n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < IOPRIO_BE_NR; j++)\n\t\t\t__bfq_put_async_bfqq(bfqd, &bfqg->async_bfqq[i][j]);\n\n\t__bfq_put_async_bfqq(bfqd, &bfqg->async_idle_bfqq);\n}\n\n/*\n * See the comments on bfq_limit_depth for the purpose of\n * the depths set in the function. Return minimum shallow depth we'll use.\n */\nstatic unsigned int bfq_update_depths(struct bfq_data *bfqd,\n\t\t\t\t      struct sbitmap_queue *bt)\n{\n\tunsigned int i, j, min_shallow = UINT_MAX;\n\n\t/*\n\t * In-word depths if no bfq_queue is being weight-raised:\n\t * leaving 25% of tags only for sync reads.\n\t *\n\t * In next formulas, right-shift the value\n\t * (1U<<bt->sb.shift), instead of computing directly\n\t * (1U<<(bt->sb.shift - something)), to be robust against\n\t * any possible value of bt->sb.shift, without having to\n\t * limit 'something'.\n\t */\n\t/* no more than 50% of tags for async I/O */\n\tbfqd->word_depths[0][0] = max((1U << bt->sb.shift) >> 1, 1U);\n\t/*\n\t * no more than 75% of tags for sync writes (25% extra tags\n\t * w.r.t. async I/O, to prevent async I/O from starving sync\n\t * writes)\n\t */\n\tbfqd->word_depths[0][1] = max(((1U << bt->sb.shift) * 3) >> 2, 1U);\n\n\t/*\n\t * In-word depths in case some bfq_queue is being weight-\n\t * raised: leaving ~63% of tags for sync reads. This is the\n\t * highest percentage for which, in our tests, application\n\t * start-up times didn't suffer from any regression due to tag\n\t * shortage.\n\t */\n\t/* no more than ~18% of tags for async I/O */\n\tbfqd->word_depths[1][0] = max(((1U << bt->sb.shift) * 3) >> 4, 1U);\n\t/* no more than ~37% of tags for sync writes (~20% extra tags) */\n\tbfqd->word_depths[1][1] = max(((1U << bt->sb.shift) * 6) >> 4, 1U);\n\n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < 2; j++)\n\t\t\tmin_shallow = min(min_shallow, bfqd->word_depths[i][j]);\n\n\treturn min_shallow;\n}\n\nstatic void bfq_depth_updated(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct bfq_data *bfqd = hctx->queue->elevator->elevator_data;\n\tstruct blk_mq_tags *tags = hctx->sched_tags;\n\tunsigned int min_shallow;\n\n\tmin_shallow = bfq_update_depths(bfqd, &tags->bitmap_tags);\n\tsbitmap_queue_min_shallow_depth(&tags->bitmap_tags, min_shallow);\n}\n\nstatic int bfq_init_hctx(struct blk_mq_hw_ctx *hctx, unsigned int index)\n{\n\tbfq_depth_updated(hctx);\n\treturn 0;\n}\n\nstatic void bfq_exit_queue(struct elevator_queue *e)\n{\n\tstruct bfq_data *bfqd = e->elevator_data;\n\tstruct bfq_queue *bfqq, *n;\n\n\thrtimer_cancel(&bfqd->idle_slice_timer);\n\n\tspin_lock_irq(&bfqd->lock);\n\tlist_for_each_entry_safe(bfqq, n, &bfqd->idle_list, bfqq_list)\n\t\tbfq_deactivate_bfqq(bfqd, bfqq, false, false);\n\tspin_unlock_irq(&bfqd->lock);\n\n\thrtimer_cancel(&bfqd->idle_slice_timer);\n\n\t/* release oom-queue reference to root group */\n\tbfqg_and_blkg_put(bfqd->root_group);\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tblkcg_deactivate_policy(bfqd->queue, &blkcg_policy_bfq);\n#else\n\tspin_lock_irq(&bfqd->lock);\n\tbfq_put_async_queues(bfqd, bfqd->root_group);\n\tkfree(bfqd->root_group);\n\tspin_unlock_irq(&bfqd->lock);\n#endif\n\n\tkfree(bfqd);\n}\n\nstatic void bfq_init_root_group(struct bfq_group *root_group,\n\t\t\t\tstruct bfq_data *bfqd)\n{\n\tint i;\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\troot_group->entity.parent = NULL;\n\troot_group->my_entity = NULL;\n\troot_group->bfqd = bfqd;\n#endif\n\troot_group->rq_pos_tree = RB_ROOT;\n\tfor (i = 0; i < BFQ_IOPRIO_CLASSES; i++)\n\t\troot_group->sched_data.service_tree[i] = BFQ_SERVICE_TREE_INIT;\n\troot_group->sched_data.bfq_class_idle_last_service = jiffies;\n}\n\nstatic int bfq_init_queue(struct request_queue *q, struct elevator_type *e)\n{\n\tstruct bfq_data *bfqd;\n\tstruct elevator_queue *eq;\n\n\teq = elevator_alloc(q, e);\n\tif (!eq)\n\t\treturn -ENOMEM;\n\n\tbfqd = kzalloc_node(sizeof(*bfqd), GFP_KERNEL, q->node);\n\tif (!bfqd) {\n\t\tkobject_put(&eq->kobj);\n\t\treturn -ENOMEM;\n\t}\n\teq->elevator_data = bfqd;\n\n\tspin_lock_irq(&q->queue_lock);\n\tq->elevator = eq;\n\tspin_unlock_irq(&q->queue_lock);\n\n\t/*\n\t * Our fallback bfqq if bfq_find_alloc_queue() runs into OOM issues.\n\t * Grab a permanent reference to it, so that the normal code flow\n\t * will not attempt to free it.\n\t */\n\tbfq_init_bfqq(bfqd, &bfqd->oom_bfqq, NULL, 1, 0);\n\tbfqd->oom_bfqq.ref++;\n\tbfqd->oom_bfqq.new_ioprio = BFQ_DEFAULT_QUEUE_IOPRIO;\n\tbfqd->oom_bfqq.new_ioprio_class = IOPRIO_CLASS_BE;\n\tbfqd->oom_bfqq.entity.new_weight =\n\t\tbfq_ioprio_to_weight(bfqd->oom_bfqq.new_ioprio);\n\n\t/* oom_bfqq does not participate to bursts */\n\tbfq_clear_bfqq_just_created(&bfqd->oom_bfqq);\n\n\t/*\n\t * Trigger weight initialization, according to ioprio, at the\n\t * oom_bfqq's first activation. The oom_bfqq's ioprio and ioprio\n\t * class won't be changed any more.\n\t */\n\tbfqd->oom_bfqq.entity.prio_changed = 1;\n\n\tbfqd->queue = q;\n\n\tINIT_LIST_HEAD(&bfqd->dispatch);\n\n\thrtimer_init(&bfqd->idle_slice_timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL);\n\tbfqd->idle_slice_timer.function = bfq_idle_slice_timer;\n\n\tbfqd->queue_weights_tree = RB_ROOT_CACHED;\n\tbfqd->num_groups_with_pending_reqs = 0;\n\n\tINIT_LIST_HEAD(&bfqd->active_list);\n\tINIT_LIST_HEAD(&bfqd->idle_list);\n\tINIT_HLIST_HEAD(&bfqd->burst_list);\n\n\tbfqd->hw_tag = -1;\n\tbfqd->nonrot_with_queueing = blk_queue_nonrot(bfqd->queue);\n\n\tbfqd->bfq_max_budget = bfq_default_max_budget;\n\n\tbfqd->bfq_fifo_expire[0] = bfq_fifo_expire[0];\n\tbfqd->bfq_fifo_expire[1] = bfq_fifo_expire[1];\n\tbfqd->bfq_back_max = bfq_back_max;\n\tbfqd->bfq_back_penalty = bfq_back_penalty;\n\tbfqd->bfq_slice_idle = bfq_slice_idle;\n\tbfqd->bfq_timeout = bfq_timeout;\n\n\tbfqd->bfq_requests_within_timer = 120;\n\n\tbfqd->bfq_large_burst_thresh = 8;\n\tbfqd->bfq_burst_interval = msecs_to_jiffies(180);\n\n\tbfqd->low_latency = true;\n\n\t/*\n\t * Trade-off between responsiveness and fairness.\n\t */\n\tbfqd->bfq_wr_coeff = 30;\n\tbfqd->bfq_wr_rt_max_time = msecs_to_jiffies(300);\n\tbfqd->bfq_wr_max_time = 0;\n\tbfqd->bfq_wr_min_idle_time = msecs_to_jiffies(2000);\n\tbfqd->bfq_wr_min_inter_arr_async = msecs_to_jiffies(500);\n\tbfqd->bfq_wr_max_softrt_rate = 7000; /*\n\t\t\t\t\t      * Approximate rate required\n\t\t\t\t\t      * to playback or record a\n\t\t\t\t\t      * high-definition compressed\n\t\t\t\t\t      * video.\n\t\t\t\t\t      */\n\tbfqd->wr_busy_queues = 0;\n\n\t/*\n\t * Begin by assuming, optimistically, that the device peak\n\t * rate is equal to 2/3 of the highest reference rate.\n\t */\n\tbfqd->rate_dur_prod = ref_rate[blk_queue_nonrot(bfqd->queue)] *\n\t\tref_wr_duration[blk_queue_nonrot(bfqd->queue)];\n\tbfqd->peak_rate = ref_rate[blk_queue_nonrot(bfqd->queue)] * 2 / 3;\n\n\tspin_lock_init(&bfqd->lock);\n\n\t/*\n\t * The invocation of the next bfq_create_group_hierarchy\n\t * function is the head of a chain of function calls\n\t * (bfq_create_group_hierarchy->blkcg_activate_policy->\n\t * blk_mq_freeze_queue) that may lead to the invocation of the\n\t * has_work hook function. For this reason,\n\t * bfq_create_group_hierarchy is invoked only after all\n\t * scheduler data has been initialized, apart from the fields\n\t * that can be initialized only after invoking\n\t * bfq_create_group_hierarchy. This, in particular, enables\n\t * has_work to correctly return false. Of course, to avoid\n\t * other inconsistencies, the blk-mq stack must then refrain\n\t * from invoking further scheduler hooks before this init\n\t * function is finished.\n\t */\n\tbfqd->root_group = bfq_create_group_hierarchy(bfqd, q->node);\n\tif (!bfqd->root_group)\n\t\tgoto out_free;\n\tbfq_init_root_group(bfqd->root_group, bfqd);\n\tbfq_init_entity(&bfqd->oom_bfqq.entity, bfqd->root_group);\n\n\twbt_disable_default(q);\n\treturn 0;\n\nout_free:\n\tkfree(bfqd);\n\tkobject_put(&eq->kobj);\n\treturn -ENOMEM;\n}\n\nstatic void bfq_slab_kill(void)\n{\n\tkmem_cache_destroy(bfq_pool);\n}\n\nstatic int __init bfq_slab_setup(void)\n{\n\tbfq_pool = KMEM_CACHE(bfq_queue, 0);\n\tif (!bfq_pool)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic ssize_t bfq_var_show(unsigned int var, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", var);\n}\n\nstatic int bfq_var_store(unsigned long *var, const char *page)\n{\n\tunsigned long new_val;\n\tint ret = kstrtoul(page, 10, &new_val);\n\n\tif (ret)\n\t\treturn ret;\n\t*var = new_val;\n\treturn 0;\n}\n\n#define SHOW_FUNCTION(__FUNC, __VAR, __CONV)\t\t\t\t\\\nstatic ssize_t __FUNC(struct elevator_queue *e, char *page)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bfq_data *bfqd = e->elevator_data;\t\t\t\\\n\tu64 __data = __VAR;\t\t\t\t\t\t\\\n\tif (__CONV == 1)\t\t\t\t\t\t\\\n\t\t__data = jiffies_to_msecs(__data);\t\t\t\\\n\telse if (__CONV == 2)\t\t\t\t\t\t\\\n\t\t__data = div_u64(__data, NSEC_PER_MSEC);\t\t\\\n\treturn bfq_var_show(__data, (page));\t\t\t\t\\\n}\nSHOW_FUNCTION(bfq_fifo_expire_sync_show, bfqd->bfq_fifo_expire[1], 2);\nSHOW_FUNCTION(bfq_fifo_expire_async_show, bfqd->bfq_fifo_expire[0], 2);\nSHOW_FUNCTION(bfq_back_seek_max_show, bfqd->bfq_back_max, 0);\nSHOW_FUNCTION(bfq_back_seek_penalty_show, bfqd->bfq_back_penalty, 0);\nSHOW_FUNCTION(bfq_slice_idle_show, bfqd->bfq_slice_idle, 2);\nSHOW_FUNCTION(bfq_max_budget_show, bfqd->bfq_user_max_budget, 0);\nSHOW_FUNCTION(bfq_timeout_sync_show, bfqd->bfq_timeout, 1);\nSHOW_FUNCTION(bfq_strict_guarantees_show, bfqd->strict_guarantees, 0);\nSHOW_FUNCTION(bfq_low_latency_show, bfqd->low_latency, 0);\n#undef SHOW_FUNCTION\n\n#define USEC_SHOW_FUNCTION(__FUNC, __VAR)\t\t\t\t\\\nstatic ssize_t __FUNC(struct elevator_queue *e, char *page)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bfq_data *bfqd = e->elevator_data;\t\t\t\\\n\tu64 __data = __VAR;\t\t\t\t\t\t\\\n\t__data = div_u64(__data, NSEC_PER_USEC);\t\t\t\\\n\treturn bfq_var_show(__data, (page));\t\t\t\t\\\n}\nUSEC_SHOW_FUNCTION(bfq_slice_idle_us_show, bfqd->bfq_slice_idle);\n#undef USEC_SHOW_FUNCTION\n\n#define STORE_FUNCTION(__FUNC, __PTR, MIN, MAX, __CONV)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\n__FUNC(struct elevator_queue *e, const char *page, size_t count)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bfq_data *bfqd = e->elevator_data;\t\t\t\\\n\tunsigned long __data, __min = (MIN), __max = (MAX);\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = bfq_var_store(&__data, (page));\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\tif (__data < __min)\t\t\t\t\t\t\\\n\t\t__data = __min;\t\t\t\t\t\t\\\n\telse if (__data > __max)\t\t\t\t\t\\\n\t\t__data = __max;\t\t\t\t\t\t\\\n\tif (__CONV == 1)\t\t\t\t\t\t\\\n\t\t*(__PTR) = msecs_to_jiffies(__data);\t\t\t\\\n\telse if (__CONV == 2)\t\t\t\t\t\t\\\n\t\t*(__PTR) = (u64)__data * NSEC_PER_MSEC;\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t*(__PTR) = __data;\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\nSTORE_FUNCTION(bfq_fifo_expire_sync_store, &bfqd->bfq_fifo_expire[1], 1,\n\t\tINT_MAX, 2);\nSTORE_FUNCTION(bfq_fifo_expire_async_store, &bfqd->bfq_fifo_expire[0], 1,\n\t\tINT_MAX, 2);\nSTORE_FUNCTION(bfq_back_seek_max_store, &bfqd->bfq_back_max, 0, INT_MAX, 0);\nSTORE_FUNCTION(bfq_back_seek_penalty_store, &bfqd->bfq_back_penalty, 1,\n\t\tINT_MAX, 0);\nSTORE_FUNCTION(bfq_slice_idle_store, &bfqd->bfq_slice_idle, 0, INT_MAX, 2);\n#undef STORE_FUNCTION\n\n#define USEC_STORE_FUNCTION(__FUNC, __PTR, MIN, MAX)\t\t\t\\\nstatic ssize_t __FUNC(struct elevator_queue *e, const char *page, size_t count)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bfq_data *bfqd = e->elevator_data;\t\t\t\\\n\tunsigned long __data, __min = (MIN), __max = (MAX);\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = bfq_var_store(&__data, (page));\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\tif (__data < __min)\t\t\t\t\t\t\\\n\t\t__data = __min;\t\t\t\t\t\t\\\n\telse if (__data > __max)\t\t\t\t\t\\\n\t\t__data = __max;\t\t\t\t\t\t\\\n\t*(__PTR) = (u64)__data * NSEC_PER_USEC;\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\nUSEC_STORE_FUNCTION(bfq_slice_idle_us_store, &bfqd->bfq_slice_idle, 0,\n\t\t    UINT_MAX);\n#undef USEC_STORE_FUNCTION\n\nstatic ssize_t bfq_max_budget_store(struct elevator_queue *e,\n\t\t\t\t    const char *page, size_t count)\n{\n\tstruct bfq_data *bfqd = e->elevator_data;\n\tunsigned long __data;\n\tint ret;\n\n\tret = bfq_var_store(&__data, (page));\n\tif (ret)\n\t\treturn ret;\n\n\tif (__data == 0)\n\t\tbfqd->bfq_max_budget = bfq_calc_max_budget(bfqd);\n\telse {\n\t\tif (__data > INT_MAX)\n\t\t\t__data = INT_MAX;\n\t\tbfqd->bfq_max_budget = __data;\n\t}\n\n\tbfqd->bfq_user_max_budget = __data;\n\n\treturn count;\n}\n\n/*\n * Leaving this name to preserve name compatibility with cfq\n * parameters, but this timeout is used for both sync and async.\n */\nstatic ssize_t bfq_timeout_sync_store(struct elevator_queue *e,\n\t\t\t\t      const char *page, size_t count)\n{\n\tstruct bfq_data *bfqd = e->elevator_data;\n\tunsigned long __data;\n\tint ret;\n\n\tret = bfq_var_store(&__data, (page));\n\tif (ret)\n\t\treturn ret;\n\n\tif (__data < 1)\n\t\t__data = 1;\n\telse if (__data > INT_MAX)\n\t\t__data = INT_MAX;\n\n\tbfqd->bfq_timeout = msecs_to_jiffies(__data);\n\tif (bfqd->bfq_user_max_budget == 0)\n\t\tbfqd->bfq_max_budget = bfq_calc_max_budget(bfqd);\n\n\treturn count;\n}\n\nstatic ssize_t bfq_strict_guarantees_store(struct elevator_queue *e,\n\t\t\t\t     const char *page, size_t count)\n{\n\tstruct bfq_data *bfqd = e->elevator_data;\n\tunsigned long __data;\n\tint ret;\n\n\tret = bfq_var_store(&__data, (page));\n\tif (ret)\n\t\treturn ret;\n\n\tif (__data > 1)\n\t\t__data = 1;\n\tif (!bfqd->strict_guarantees && __data == 1\n\t    && bfqd->bfq_slice_idle < 8 * NSEC_PER_MSEC)\n\t\tbfqd->bfq_slice_idle = 8 * NSEC_PER_MSEC;\n\n\tbfqd->strict_guarantees = __data;\n\n\treturn count;\n}\n\nstatic ssize_t bfq_low_latency_store(struct elevator_queue *e,\n\t\t\t\t     const char *page, size_t count)\n{\n\tstruct bfq_data *bfqd = e->elevator_data;\n\tunsigned long __data;\n\tint ret;\n\n\tret = bfq_var_store(&__data, (page));\n\tif (ret)\n\t\treturn ret;\n\n\tif (__data > 1)\n\t\t__data = 1;\n\tif (__data == 0 && bfqd->low_latency != 0)\n\t\tbfq_end_wr(bfqd);\n\tbfqd->low_latency = __data;\n\n\treturn count;\n}\n\n#define BFQ_ATTR(name) \\\n\t__ATTR(name, 0644, bfq_##name##_show, bfq_##name##_store)\n\nstatic struct elv_fs_entry bfq_attrs[] = {\n\tBFQ_ATTR(fifo_expire_sync),\n\tBFQ_ATTR(fifo_expire_async),\n\tBFQ_ATTR(back_seek_max),\n\tBFQ_ATTR(back_seek_penalty),\n\tBFQ_ATTR(slice_idle),\n\tBFQ_ATTR(slice_idle_us),\n\tBFQ_ATTR(max_budget),\n\tBFQ_ATTR(timeout_sync),\n\tBFQ_ATTR(strict_guarantees),\n\tBFQ_ATTR(low_latency),\n\t__ATTR_NULL\n};\n\nstatic struct elevator_type iosched_bfq_mq = {\n\t.ops = {\n\t\t.limit_depth\t\t= bfq_limit_depth,\n\t\t.prepare_request\t= bfq_prepare_request,\n\t\t.requeue_request        = bfq_finish_requeue_request,\n\t\t.finish_request\t\t= bfq_finish_requeue_request,\n\t\t.exit_icq\t\t= bfq_exit_icq,\n\t\t.insert_requests\t= bfq_insert_requests,\n\t\t.dispatch_request\t= bfq_dispatch_request,\n\t\t.next_request\t\t= elv_rb_latter_request,\n\t\t.former_request\t\t= elv_rb_former_request,\n\t\t.allow_merge\t\t= bfq_allow_bio_merge,\n\t\t.bio_merge\t\t= bfq_bio_merge,\n\t\t.request_merge\t\t= bfq_request_merge,\n\t\t.requests_merged\t= bfq_requests_merged,\n\t\t.request_merged\t\t= bfq_request_merged,\n\t\t.has_work\t\t= bfq_has_work,\n\t\t.depth_updated\t\t= bfq_depth_updated,\n\t\t.init_hctx\t\t= bfq_init_hctx,\n\t\t.init_sched\t\t= bfq_init_queue,\n\t\t.exit_sched\t\t= bfq_exit_queue,\n\t},\n\n\t.icq_size =\t\tsizeof(struct bfq_io_cq),\n\t.icq_align =\t\t__alignof__(struct bfq_io_cq),\n\t.elevator_attrs =\tbfq_attrs,\n\t.elevator_name =\t\"bfq\",\n\t.elevator_owner =\tTHIS_MODULE,\n};\nMODULE_ALIAS(\"bfq-iosched\");\n\nstatic int __init bfq_init(void)\n{\n\tint ret;\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tret = blkcg_policy_register(&blkcg_policy_bfq);\n\tif (ret)\n\t\treturn ret;\n#endif\n\n\tret = -ENOMEM;\n\tif (bfq_slab_setup())\n\t\tgoto err_pol_unreg;\n\n\t/*\n\t * Times to load large popular applications for the typical\n\t * systems installed on the reference devices (see the\n\t * comments before the definition of the next\n\t * array). Actually, we use slightly lower values, as the\n\t * estimated peak rate tends to be smaller than the actual\n\t * peak rate.  The reason for this last fact is that estimates\n\t * are computed over much shorter time intervals than the long\n\t * intervals typically used for benchmarking. Why? First, to\n\t * adapt more quickly to variations. Second, because an I/O\n\t * scheduler cannot rely on a peak-rate-evaluation workload to\n\t * be run for a long time.\n\t */\n\tref_wr_duration[0] = msecs_to_jiffies(7000); /* actually 8 sec */\n\tref_wr_duration[1] = msecs_to_jiffies(2500); /* actually 3 sec */\n\n\tret = elv_register(&iosched_bfq_mq);\n\tif (ret)\n\t\tgoto slab_kill;\n\n\treturn 0;\n\nslab_kill:\n\tbfq_slab_kill();\nerr_pol_unreg:\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tblkcg_policy_unregister(&blkcg_policy_bfq);\n#endif\n\treturn ret;\n}\n\nstatic void __exit bfq_exit(void)\n{\n\telv_unregister(&iosched_bfq_mq);\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tblkcg_policy_unregister(&blkcg_policy_bfq);\n#endif\n\tbfq_slab_kill();\n}\n\nmodule_init(bfq_init);\nmodule_exit(bfq_exit);\n\nMODULE_AUTHOR(\"Paolo Valente\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MQ Budget Fair Queueing I/O Scheduler\");\n"], "filenames": ["block/bfq-iosched.c"], "buggy_code_start_loc": [6218], "buggy_code_end_loc": [6277], "fixing_code_start_loc": [6218], "fixing_code_end_loc": [6285], "type": "CWE-416", "message": "An issue was discovered in the Linux kernel before 5.6.5. There is a use-after-free in block/bfq-iosched.c related to bfq_idle_slice_timer_body.", "other": {"cve": {"id": "CVE-2020-12657", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-05T07:15:10.993", "lastModified": "2020-06-13T09:15:13.227", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 5.6.5. There is a use-after-free in block/bfq-iosched.c related to bfq_idle_slice_timer_body."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el kernel de Linux versiones anteriores a 5.6.5. Se presenta un uso de la memoria previamente liberada en el archivo block/bfq-iosched.c relacionado con la funci\u00f3n bfq_idle_slice_timer_body."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.5", "matchCriteriaId": "74C74C8C-8070-4FB7-8E86-26641C4EE4FF"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00022.html", "source": "cve@mitre.org"}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.6.5", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://patchwork.kernel.org/patch/11447049/", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200608-0001/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4363-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4367-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4368-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4369-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9"}}