{"buggy_code": ["// This file is part of MinIO Console Server\n// Copyright (c) 2021 MinIO, Inc.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport storage from \"local-storage-fallback\";\nimport { IBytesCalc, IErasureCodeCalc, IStorageFactors } from \"./types\";\n\nimport get from \"lodash/get\";\n\nconst minMemReq = 2147483648; // Minimal Memory required for MinIO in bytes\n\nexport const units = [\n  \"B\",\n  \"KiB\",\n  \"MiB\",\n  \"GiB\",\n  \"TiB\",\n  \"PiB\",\n  \"EiB\",\n  \"ZiB\",\n  \"YiB\",\n];\nexport const k8sUnits = [\"Ki\", \"Mi\", \"Gi\", \"Ti\", \"Pi\", \"Ei\"];\nexport const k8sCalcUnits = [\"B\", ...k8sUnits];\nexport const timeUnits = [\"ms\", \"s\", \"m\", \"h\", \"d\", \"w\", \"M\", \"Q\", \"y\"];\n\nexport const niceBytes = (x: string, showK8sUnits: boolean = false) => {\n  let n = parseInt(x, 10) || 0;\n\n  return niceBytesInt(n, showK8sUnits);\n};\n\nexport const niceBytesInt = (n: number, showK8sUnits: boolean = false) => {\n  let l = 0;\n\n  while (n >= 1024 && ++l) {\n    n = n / 1024;\n  }\n  // include a decimal point and a tenths-place digit if presenting\n  // less than ten of KB or greater units\n  const k8sUnitsN = [\"B\", ...k8sUnits];\n  return n.toFixed(1) + \" \" + (showK8sUnits ? k8sUnitsN[l] : units[l]);\n};\n\nexport const setCookie = (name: string, val: string) => {\n  const date = new Date();\n  const value = val;\n\n  // Set it expire in 45 minutes\n  date.setTime(date.getTime() + 45 * 60 * 1000);\n\n  // Set it\n  document.cookie =\n    name + \"=\" + value + \"; expires=\" + date.toUTCString() + \"; path=/\";\n};\n\nexport const deleteCookie = (name: string) => {\n  document.cookie = name + \"=; expires=Thu, 01 Jan 1970 00:00:01 GMT;\";\n};\n\nexport const clearSession = () => {\n  storage.removeItem(\"token\");\n  storage.removeItem(\"auth-state\");\n  deleteCookie(\"token\");\n  deleteCookie(\"idp-refresh-token\");\n};\n\n// timeFromDate gets time string from date input\nexport const timeFromDate = (d: Date) => {\n  let h = d.getHours() < 10 ? `0${d.getHours()}` : `${d.getHours()}`;\n  let m = d.getMinutes() < 10 ? `0${d.getMinutes()}` : `${d.getMinutes()}`;\n  let s = d.getSeconds() < 10 ? `0${d.getSeconds()}` : `${d.getSeconds()}`;\n\n  return `${h}:${m}:${s}:${d.getMilliseconds()}`;\n};\n\n// units to be used in a dropdown\nexport const factorForDropdown = () => {\n  return units.map((unit) => {\n    return { label: unit, value: unit };\n  });\n};\n\n// units to be used in a dropdown\nexport const k8sScalarUnitsExcluding = (exclude?: string[]) => {\n  return k8sUnits\n    .filter((unit) => {\n      if (exclude && exclude.includes(unit)) {\n        return false;\n      }\n      return true;\n    })\n    .map((unit) => {\n      return { label: unit, value: unit };\n    });\n};\n\n//getBytes, converts from a value and a unit from units array to bytes as a string\nexport const getBytes = (\n  value: string,\n  unit: string,\n  fromk8s: boolean = false\n): string => {\n  return getBytesNumber(value, unit, fromk8s).toString(10);\n};\n\n//getBytesNumber, converts from a value and a unit from units array to bytes\nexport const getBytesNumber = (\n  value: string,\n  unit: string,\n  fromk8s: boolean = false\n): number => {\n  const vl: number = parseFloat(value);\n\n  const unitsTake = fromk8s ? k8sCalcUnits : units;\n\n  const powFactor = unitsTake.findIndex((element) => element === unit);\n\n  if (powFactor === -1) {\n    return 0;\n  }\n  const factor = Math.pow(1024, powFactor);\n  const total = vl * factor;\n\n  return total;\n};\n\n//getTotalSize gets the total size of a value & unit\nexport const getTotalSize = (value: string, unit: string) => {\n  const bytes = getBytes(value, unit, true).toString();\n  return niceBytes(bytes);\n};\n\nexport const setMemoryResource = (\n  memorySize: number,\n  capacitySize: string,\n  maxMemorySize: number\n) => {\n  // value always comes as Gi\n  const requestedSizeBytes = getBytes(memorySize.toString(10), \"Gi\", true);\n  const memReqSize = parseInt(requestedSizeBytes, 10);\n  if (maxMemorySize === 0) {\n    return {\n      error: \"There is no memory available for the selected number of nodes\",\n      request: 0,\n      limit: 0,\n    };\n  }\n\n  if (maxMemorySize < minMemReq) {\n    return {\n      error: \"There are not enough memory resources available\",\n      request: 0,\n      limit: 0,\n    };\n  }\n\n  if (memReqSize < minMemReq) {\n    return {\n      error: \"The requested memory size must be greater than 2Gi\",\n      request: 0,\n      limit: 0,\n    };\n  }\n  if (memReqSize > maxMemorySize) {\n    return {\n      error:\n        \"The requested memory is greater than the max available memory for the selected number of nodes\",\n      request: 0,\n      limit: 0,\n    };\n  }\n\n  const capSize = parseInt(capacitySize, 10);\n  let memLimitSize = memReqSize;\n  // set memory limit based on the capacitySize\n  // if capacity size is lower than 1TiB we use the limit equal to request\n  if (capSize >= parseInt(getBytes(\"1\", \"Pi\", true), 10)) {\n    memLimitSize = Math.max(\n      memReqSize,\n      parseInt(getBytes(\"64\", \"Gi\", true), 10)\n    );\n  } else if (capSize >= parseInt(getBytes(\"100\", \"Ti\"), 10)) {\n    memLimitSize = Math.max(\n      memReqSize,\n      parseInt(getBytes(\"32\", \"Gi\", true), 10)\n    );\n  } else if (capSize >= parseInt(getBytes(\"10\", \"Ti\"), 10)) {\n    memLimitSize = Math.max(\n      memReqSize,\n      parseInt(getBytes(\"16\", \"Gi\", true), 10)\n    );\n  } else if (capSize >= parseInt(getBytes(\"1\", \"Ti\"), 10)) {\n    memLimitSize = Math.max(\n      memReqSize,\n      parseInt(getBytes(\"8\", \"Gi\", true), 10)\n    );\n  }\n\n  return {\n    error: \"\",\n    request: memReqSize,\n    limit: memLimitSize,\n  };\n};\n\n// Erasure Code Parity Calc\nexport const erasureCodeCalc = (\n  parityValidValues: string[],\n  totalDisks: number,\n  pvSize: number,\n  totalNodes: number\n): IErasureCodeCalc => {\n  // Parity Values is empty\n  if (parityValidValues.length < 1) {\n    return {\n      error: 1,\n      defaultEC: \"\",\n      erasureCodeSet: 0,\n      maxEC: \"\",\n      rawCapacity: \"0\",\n      storageFactors: [],\n    };\n  }\n\n  const totalStorage = totalDisks * pvSize;\n  const maxEC = parityValidValues[0];\n  const maxParityNumber = parseInt(maxEC.split(\":\")[1], 10);\n\n  const erasureStripeSet = maxParityNumber * 2; // ESS is calculated by multiplying maximum parity by two.\n\n  const storageFactors: IStorageFactors[] = parityValidValues.map(\n    (currentParity) => {\n      const parityNumber = parseInt(currentParity.split(\":\")[1], 10);\n      const storageFactor =\n        erasureStripeSet / (erasureStripeSet - parityNumber);\n\n      const maxCapacity = Math.floor(totalStorage / storageFactor);\n      const maxTolerations =\n        totalDisks - Math.floor(totalDisks / storageFactor);\n      return {\n        erasureCode: currentParity,\n        storageFactor,\n        maxCapacity: maxCapacity.toString(10),\n        maxFailureTolerations: maxTolerations,\n      };\n    }\n  );\n\n  let defaultEC = maxEC;\n\n  const fourVar = parityValidValues.find((element) => element === \"EC:4\");\n\n  if (fourVar) {\n    defaultEC = \"EC:4\";\n  }\n\n  return {\n    error: 0,\n    storageFactors,\n    maxEC,\n    rawCapacity: totalStorage.toString(10),\n    erasureCodeSet: erasureStripeSet,\n    defaultEC,\n  };\n};\n\n// seconds / minutes /hours / Days / Years calculator\nexport const niceDays = (secondsValue: string, timeVariant: string = \"s\") => {\n  let seconds = parseFloat(secondsValue);\n\n  return niceDaysInt(seconds, timeVariant);\n};\n\nexport const niceDaysInt = (seconds: number, timeVariant: string = \"s\") => {\n  switch (timeVariant) {\n    case \"ns\":\n      seconds = Math.floor(seconds * 0.000000001);\n      break;\n    case \"ms\":\n      seconds = Math.floor(seconds * 0.001);\n      break;\n    default:\n  }\n\n  const days = Math.floor(seconds / (3600 * 24));\n\n  seconds -= days * 3600 * 24;\n  const hours = Math.floor(seconds / 3600);\n  seconds -= hours * 3600;\n  const minutes = Math.floor(seconds / 60);\n  seconds -= minutes * 60;\n\n  if (days > 365) {\n    const years = days / 365;\n    return `${years} year${Math.floor(years) === 1 ? \"\" : \"s\"}`;\n  }\n\n  if (days > 30) {\n    const months = Math.floor(days / 30);\n    const diffDays = days - months * 30;\n\n    return `${months} month${Math.floor(months) === 1 ? \"\" : \"s\"} ${\n      diffDays > 0 ? `${diffDays} day${diffDays > 1 ? \"s\" : \"\"}` : \"\"\n    }`;\n  }\n\n  if (days >= 7 && days <= 30) {\n    const weeks = Math.floor(days / 7);\n\n    return `${Math.floor(weeks)} week${weeks === 1 ? \"\" : \"s\"}`;\n  }\n\n  if (days >= 1 && days <= 6) {\n    return `${days} day${days > 1 ? \"s\" : \"\"}`;\n  }\n\n  return `${hours >= 1 ? `${hours} hour${hours > 1 ? \"s\" : \"\"}` : \"\"} ${\n    minutes >= 1 && hours === 0\n      ? `${minutes} minute${minutes > 1 ? \"s\" : \"\"}`\n      : \"\"\n  } ${\n    seconds >= 1 && minutes === 0 && hours === 0\n      ? `${seconds} second${seconds > 1 ? \"s\" : \"\"}`\n      : \"\"\n  }`;\n};\n\nconst twoDigitsNumberString = (value: number) => {\n  return `${value < 10 ? \"0\" : \"\"}${value}`;\n};\n\nexport const getTimeFromTimestamp = (\n  timestamp: string,\n  fullDate: boolean = false,\n  simplifiedDate: boolean = false\n) => {\n  const timestampToInt = parseInt(timestamp);\n  if (isNaN(timestampToInt)) {\n    return \"\";\n  }\n  const dateObject = new Date(timestampToInt * 1000);\n\n  if (fullDate) {\n    if (simplifiedDate) {\n      return `${twoDigitsNumberString(\n        dateObject.getMonth() + 1\n      )}/${twoDigitsNumberString(dateObject.getDate())} ${twoDigitsNumberString(\n        dateObject.getHours()\n      )}:${twoDigitsNumberString(dateObject.getMinutes())}`;\n    } else {\n      return dateObject.toLocaleString();\n    }\n  }\n  return `${dateObject.getHours()}:${String(dateObject.getMinutes()).padStart(\n    2,\n    \"0\"\n  )}`;\n};\n\nexport const calculateBytes = (\n  x: string | number,\n  showDecimals = false,\n  roundFloor = true,\n  k8sUnit = false\n): IBytesCalc => {\n  let bytes;\n\n  if (typeof x === \"string\") {\n    bytes = parseInt(x, 10);\n  } else {\n    bytes = x;\n  }\n\n  if (bytes === 0) {\n    return { total: 0, unit: units[0] };\n  }\n\n  // Gi : GiB\n  const k = 1024;\n\n  // Get unit for measure\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  const fractionDigits = showDecimals ? 1 : 0;\n\n  const bytesUnit = bytes / Math.pow(k, i);\n\n  const roundedUnit = roundFloor ? Math.floor(bytesUnit) : bytesUnit;\n\n  // Get Unit parsed\n  const unitParsed = parseFloat(roundedUnit.toFixed(fractionDigits));\n  const finalUnit = k8sUnit ? k8sCalcUnits[i] : units[i];\n\n  return { total: unitParsed, unit: finalUnit };\n};\n\nexport const nsToSeconds = (nanoseconds: number) => {\n  const conversion = nanoseconds * 0.000000001;\n  const round = Math.round((conversion + Number.EPSILON) * 10000) / 10000;\n\n  return `${round} s`;\n};\n\nexport const textToRGBColor = (text: string) => {\n  const splitText = text.split(\"\");\n\n  const hashVl = splitText.reduce((acc, currItem) => {\n    return acc + currItem.charCodeAt(0) + ((acc << 5) - acc);\n  }, 0);\n\n  const hashColored = ((hashVl * 100) & 0x00ffffff).toString(16).toUpperCase();\n\n  return `#${hashColored.padStart(6, \"0\")}`;\n};\n\nexport const prettyNumber = (usage: number | undefined) => {\n  if (usage === undefined) {\n    return 0;\n  }\n\n  return usage.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n};\n\nexport const representationNumber = (number: number | undefined) => {\n  if (number === undefined) {\n    return \"0\";\n  }\n\n  let returnValue = number.toString();\n  let unit = \"\";\n\n  if (number > 999 && number < 1000000) {\n    returnValue = (number / 1000).toFixed(1); // convert to K, numbers > 999\n    unit = \"K\";\n  } else if (number >= 1000000 && number < 1000000000) {\n    returnValue = (number / 1000000).toFixed(1); // convert to M, numbers >= 1 million\n    unit = \"M\";\n  } else if (number >= 1000000000) {\n    returnValue = (number / 1000000000).toFixed(1); // convert to B, numbers >= 1 billion\n    unit = \"B\";\n  }\n\n  if (returnValue.endsWith(\".0\")) {\n    returnValue = returnValue.slice(0, -2);\n  }\n\n  return `${returnValue}${unit}`;\n};\n\nexport const encodeURLString = (name: string | null) => {\n  if (!name) {\n    return \"\";\n  }\n  try {\n    return btoa(unescape(encodeURIComponent(name)));\n  } catch (err) {\n    return \"\";\n  }\n};\n\nexport const decodeURLString = (text: string) => {\n  try {\n    return decodeURIComponent(escape(window.atob(text)));\n  } catch (err) {\n    return text;\n  }\n};\n\nexport const performDownload = (blob: Blob, fileName: string) => {\n  const link = document.createElement(\"a\");\n  link.href = window.URL.createObjectURL(blob);\n  link.download = fileName;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n};\n\nexport const getCookieValue = (cookieName: string) => {\n  return (\n    document.cookie\n      .match(\"(^|;)\\\\s*\" + cookieName + \"\\\\s*=\\\\s*([^;]+)\")\n      ?.pop() || \"\"\n  );\n};\n\nexport const capacityColors = (usedSpace: number, maxSpace: number) => {\n  const percCalculate = (usedSpace * 100) / maxSpace;\n\n  if (percCalculate >= 90) {\n    return \"#C83B51\";\n  } else if (percCalculate >= 70) {\n    return \"#FFAB0F\";\n  }\n\n  return \"#07193E\";\n};\n\nexport const getClientOS = (): string => {\n  const getPlatform = get(window.navigator, \"platform\", \"undefined\");\n\n  if (!getPlatform) {\n    return \"undefined\";\n  }\n\n  return getPlatform;\n};\n\nexport const MinIOEnvVarsSettings: any = {\n  MINIO_ACCESS_KEY: { secret: true },\n  MINIO_ACCESS_KEY_OLD: { secret: true },\n  MINIO_AUDIT_WEBHOOK_AUTH_TOKEN: { secret: true },\n  MINIO_IDENTITY_LDAP_LOOKUP_BIND_PASSWORD: { secret: true },\n  MINIO_IDENTITY_OPENID_CLIENT_SECRET: { secret: true },\n  MINIO_KMS_SECRET_KEY: { secret: true },\n  MINIO_LOGGER_WEBHOOK_AUTH_TOKEN: { secret: true },\n  MINIO_NOTIFY_ELASTICSEARCH_PASSWORD: { secret: true },\n  MINIO_NOTIFY_KAFKA_SASL_PASSWORD: { secret: true },\n  MINIO_NOTIFY_MQTT_PASSWORD: { secret: true },\n  MINIO_NOTIFY_NATS_PASSWORD: { secret: true },\n  MINIO_NOTIFY_NATS_TOKEN: { secret: true },\n  MINIO_NOTIFY_REDIS_PASSWORD: { secret: true },\n  MINIO_NOTIFY_WEBHOOK_AUTH_TOKEN: { secret: true },\n  MINIO_ROOT_PASSWORD: { secret: true },\n  MINIO_SECRET_KEY: { secret: true },\n  MINIO_SECRET_KEY_OLD: { secret: true },\n};\n\nexport const MinIOEnvironmentVariables = [\n  \"MINIO_ACCESS_KEY\",\n  \"MINIO_ACCESS_KEY_OLD\",\n  \"MINIO_AUDIT_WEBHOOK_AUTH_TOKEN\",\n  \"MINIO_AUDIT_WEBHOOK_CLIENT_CERT\",\n  \"MINIO_AUDIT_WEBHOOK_CLIENT_KEY\",\n  \"MINIO_AUDIT_WEBHOOK_ENABLE\",\n  \"MINIO_AUDIT_WEBHOOK_ENDPOINT\",\n  \"MINIO_BROWSER\",\n  \"MINIO_BROWSER_REDIRECT_URL\",\n  \"MINIO_IDENTITY_LDAP_COMMENT\",\n  \"MINIO_IDENTITY_LDAP_GROUP_SEARCH_BASE_DN\",\n  \"MINIO_IDENTITY_LDAP_GROUP_SEARCH_FILTER\",\n  \"MINIO_IDENTITY_LDAP_LOOKUP_BIND_DN\",\n  \"MINIO_IDENTITY_LDAP_LOOKUP_BIND_PASSWORD\",\n  \"MINIO_IDENTITY_LDAP_SERVER_ADDR\",\n  \"MINIO_IDENTITY_LDAP_SERVER_INSECURE\",\n  \"MINIO_IDENTITY_LDAP_SERVER_STARTTLS\",\n  \"MINIO_IDENTITY_LDAP_STS_EXPIRY\",\n  \"MINIO_IDENTITY_LDAP_TLS_SKIP_VERIFY\",\n  \"MINIO_IDENTITY_LDAP_USER_DN_SEARCH_BASE_DN\",\n  \"MINIO_IDENTITY_LDAP_USER_DN_SEARCH_FILTER\",\n  \"MINIO_IDENTITY_LDAP_USERNAME_FORMAT\",\n  \"MINIO_IDENTITY_OPENID_CLAIM_NAME\",\n  \"MINIO_IDENTITY_OPENID_CLAIM_PREFIX\",\n  \"MINIO_IDENTITY_OPENID_CLIENT_ID\",\n  \"MINIO_IDENTITY_OPENID_CLIENT_SECRET\",\n  \"MINIO_IDENTITY_OPENID_COMMENT\",\n  \"MINIO_IDENTITY_OPENID_CONFIG_URL\",\n  \"MINIO_IDENTITY_OPENID_REDIRECT_URI\",\n  \"MINIO_IDENTITY_OPENID_SCOPES\",\n  \"MINIO_KMS_AUTO_ENCRYPTION\",\n  \"MINIO_KMS_KES_CERT_FILE\",\n  \"MINIO_KMS_KES_ENDPOINT\",\n  \"MINIO_KMS_KES_KEY_FILE\",\n  \"MINIO_KMS_KES_KEY_NAME\",\n  \"MINIO_KMS_SECRET_KEY\",\n  \"MINIO_LOGGER_WEBHOOK_AUTH_TOKEN\",\n  \"MINIO_LOGGER_WEBHOOK_ENABLE\",\n  \"MINIO_LOGGER_WEBHOOK_ENDPOINT\",\n  \"MINIO_LOG_QUERY_URL\",\n  \"MINIO_NOTIFY_AMQP_AUTO_DELETED\",\n  \"MINIO_NOTIFY_AMQP_COMMENT\",\n  \"MINIO_NOTIFY_AMQP_DELIVERY_MODE\",\n  \"MINIO_NOTIFY_AMQP_DURABLE\",\n  \"MINIO_NOTIFY_AMQP_ENABLE\",\n  \"MINIO_NOTIFY_AMQP_EXCHANGE\",\n  \"MINIO_NOTIFY_AMQP_EXCHANGE_TYPE\",\n  \"MINIO_NOTIFY_AMQP_INTERNAL\",\n  \"MINIO_NOTIFY_AMQP_MANDATORY\",\n  \"MINIO_NOTIFY_AMQP_NO_WAIT\",\n  \"MINIO_NOTIFY_AMQP_QUEUE_DIR\",\n  \"MINIO_NOTIFY_AMQP_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_AMQP_ROUTING_KEY\",\n  \"MINIO_NOTIFY_AMQP_URL\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_COMMENT\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_ENABLE\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_FORMAT\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_INDEX\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_PASSWORD\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_QUEUE_DIR\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_URL\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_USERNAME\",\n  \"MINIO_NOTIFY_KAFKA_BROKERS\",\n  \"MINIO_NOTIFY_KAFKA_CLIENT_TLS_CERT\",\n  \"MINIO_NOTIFY_KAFKA_CLIENT_TLS_KEY\",\n  \"MINIO_NOTIFY_KAFKA_COMMENT\",\n  \"MINIO_NOTIFY_KAFKA_ENABLE\",\n  \"MINIO_NOTIFY_KAFKA_QUEUE_DIR\",\n  \"MINIO_NOTIFY_KAFKA_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_KAFKA_SASL\",\n  \"MINIO_NOTIFY_KAFKA_SASL_MECHANISM\",\n  \"MINIO_NOTIFY_KAFKA_SASL_PASSWORD\",\n  \"MINIO_NOTIFY_KAFKA_SASL_USERNAME\",\n  \"MINIO_NOTIFY_KAFKA_TLS\",\n  \"MINIO_NOTIFY_KAFKA_TLS_CLIENT_AUTH\",\n  \"MINIO_NOTIFY_KAFKA_TLS_SKIP_VERIFY\",\n  \"MINIO_NOTIFY_KAFKA_TOPIC\",\n  \"MINIO_NOTIFY_KAFKA_VERSION\",\n  \"MINIO_NOTIFY_MQTT_BROKER\",\n  \"MINIO_NOTIFY_MQTT_COMMENT\",\n  \"MINIO_NOTIFY_MQTT_ENABLE\",\n  \"MINIO_NOTIFY_MQTT_KEEP_ALIVE_INTERVAL\",\n  \"MINIO_NOTIFY_MQTT_PASSWORD\",\n  \"MINIO_NOTIFY_MQTT_QOS\",\n  \"MINIO_NOTIFY_MQTT_QUEUE_DIR\",\n  \"MINIO_NOTIFY_MQTT_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_MQTT_RECONNECT_INTERVAL\",\n  \"MINIO_NOTIFY_MQTT_TOPIC\",\n  \"MINIO_NOTIFY_MQTT_USERNAME\",\n  \"MINIO_NOTIFY_MYSQL_COMMENT\",\n  \"MINIO_NOTIFY_MYSQL_DSN_STRING\",\n  \"MINIO_NOTIFY_MYSQL_ENABLE\",\n  \"MINIO_NOTIFY_MYSQL_FORMAT\",\n  \"MINIO_NOTIFY_MYSQL_MAX_OPEN_CONNECTIONS\",\n  \"MINIO_NOTIFY_MYSQL_QUEUE_DIR\",\n  \"MINIO_NOTIFY_MYSQL_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_MYSQL_TABLE\",\n  \"MINIO_NOTIFY_NATS_ADDRESS\",\n  \"MINIO_NOTIFY_NATS_CERT_AUTHORITY\",\n  \"MINIO_NOTIFY_NATS_CLIENT_CERT\",\n  \"MINIO_NOTIFY_NATS_CLIENT_KEY\",\n  \"MINIO_NOTIFY_NATS_COMMENT\",\n  \"MINIO_NOTIFY_NATS_ENABLE\",\n  \"MINIO_NOTIFY_NATS_PASSWORD\",\n  \"MINIO_NOTIFY_NATS_PING_INTERVAL\",\n  \"MINIO_NOTIFY_NATS_QUEUE_DIR\",\n  \"MINIO_NOTIFY_NATS_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_NATS_STREAMING\",\n  \"MINIO_NOTIFY_NATS_STREAMING_ASYNC\",\n  \"MINIO_NOTIFY_NATS_STREAMING_CLUSTER_ID\",\n  \"MINIO_NOTIFY_NATS_STREAMING_MAX_PUB_ACKS_IN_FLIGHT\",\n  \"MINIO_NOTIFY_NATS_SUBJECT\",\n  \"MINIO_NOTIFY_NATS_TLS\",\n  \"MINIO_NOTIFY_NATS_TLS_SKIP_VERIFY\",\n  \"MINIO_NOTIFY_NATS_TOKEN\",\n  \"MINIO_NOTIFY_NATS_USERNAME\",\n  \"MINIO_NOTIFY_NSQ_COMMENT\",\n  \"MINIO_NOTIFY_NSQ_ENABLE\",\n  \"MINIO_NOTIFY_NSQ_NSQD_ADDRESS\",\n  \"MINIO_NOTIFY_NSQ_QUEUE_DIR\",\n  \"MINIO_NOTIFY_NSQ_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_NSQ_TLS\",\n  \"MINIO_NOTIFY_NSQ_TLS_SKIP_VERIFY\",\n  \"MINIO_NOTIFY_NSQ_TOPIC\",\n  \"MINIO_NOTIFY_POSTGRESQL_COMMENT\",\n  \"MINIO_NOTIFY_POSTGRESQL_CONNECTION_STRING\",\n  \"MINIO_NOTIFY_POSTGRESQL_ENABLE\",\n  \"MINIO_NOTIFY_POSTGRESQL_FORMAT\",\n  \"MINIO_NOTIFY_POSTGRESQL_MAX_OPEN_CONNECTIONS\",\n  \"MINIO_NOTIFY_POSTGRESQL_QUEUE_DIR\",\n  \"MINIO_NOTIFY_POSTGRESQL_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_POSTGRESQL_TABLE\",\n  \"MINIO_NOTIFY_REDIS_ADDRESS\",\n  \"MINIO_NOTIFY_REDIS_COMMENT\",\n  \"MINIO_NOTIFY_REDIS_ENABLE\",\n  \"MINIO_NOTIFY_REDIS_FORMAT\",\n  \"MINIO_NOTIFY_REDIS_KEY\",\n  \"MINIO_NOTIFY_REDIS_PASSWORD\",\n  \"MINIO_NOTIFY_REDIS_QUEUE_DIR\",\n  \"MINIO_NOTIFY_REDIS_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_WEBHOOK_AUTH_TOKEN\",\n  \"MINIO_NOTIFY_WEBHOOK_CLIENT_CERT\",\n  \"MINIO_NOTIFY_WEBHOOK_CLIENT_KEY\",\n  \"MINIO_NOTIFY_WEBHOOK_COMMENT\",\n  \"MINIO_NOTIFY_WEBHOOK_ENABLE\",\n  \"MINIO_NOTIFY_WEBHOOK_ENDPOINT\",\n  \"MINIO_NOTIFY_WEBHOOK_QUEUE_DIR\",\n  \"MINIO_NOTIFY_WEBHOOK_QUEUE_LIMIT\",\n  \"MINIO_PROMETHEUS_AUTH_TYPE\",\n  \"MINIO_PROMETHEUS_JOB_ID\",\n  \"MINIO_PROMETHEUS_URL\",\n  \"MINIO_ROOT_PASSWORD\",\n  \"MINIO_ROOT_USER\",\n  \"MINIO_SECRET_KEY\",\n  \"MINIO_SECRET_KEY_OLD\",\n  \"MINIO_SERVER_URL\",\n  \"MINIO_STORAGE_CLASS_COMMENT\",\n  \"MINIO_STORAGE_CLASS_RRS\",\n  \"MINIO_STORAGE_CLASS_STANDARD\",\n];\n\n// Generates a valid access/secret key string\nexport const getRandomString = function (length = 16): string {\n  let retval = \"\";\n  let legalcharacters =\n    \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  for (let i = 0; i < length; i++) {\n    retval +=\n      legalcharacters[Math.floor(Math.random() * legalcharacters.length)];\n  }\n  return retval;\n};\n", "import React from \"react\";\nimport createStyles from \"@mui/styles/createStyles\";\nimport withStyles from \"@mui/styles/withStyles\";\nimport { Theme } from \"@mui/material/styles\";\n\ninterface IIconWithLabel {\n  classes: any;\n  icon: JSX.Element;\n  strings: string[];\n}\n\nconst styles = (theme: Theme) =>\n  createStyles({\n    fileName: {\n      display: \"flex\",\n      alignItems: \"center\",\n      \"& .min-icon\": {\n        width: 16,\n        height: 16,\n        marginRight: 4,\n        minWidth: 16,\n        minHeight: 16,\n      },\n    },\n    fileNameText: {\n      whiteSpace: \"nowrap\",\n      overflow: \"hidden\",\n      textOverflow: \"ellipsis\",\n    },\n  });\n\nconst IconWithLabel = ({ classes, icon, strings }: IIconWithLabel) => {\n  return (\n    <div className={classes.fileName}>\n      {icon}\n      <span className={classes.fileNameText}>\n        {strings[strings.length - 1]}\n      </span>\n    </div>\n  );\n};\n\nexport default withStyles(styles)(IconWithLabel);\n"], "fixing_code": ["// This file is part of MinIO Console Server\n// Copyright (c) 2021 MinIO, Inc.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport storage from \"local-storage-fallback\";\nimport { IBytesCalc, IErasureCodeCalc, IStorageFactors } from \"./types\";\n\nimport get from \"lodash/get\";\n\nconst minMemReq = 2147483648; // Minimal Memory required for MinIO in bytes\n\nexport const units = [\n  \"B\",\n  \"KiB\",\n  \"MiB\",\n  \"GiB\",\n  \"TiB\",\n  \"PiB\",\n  \"EiB\",\n  \"ZiB\",\n  \"YiB\",\n];\nexport const k8sUnits = [\"Ki\", \"Mi\", \"Gi\", \"Ti\", \"Pi\", \"Ei\"];\nexport const k8sCalcUnits = [\"B\", ...k8sUnits];\nexport const timeUnits = [\"ms\", \"s\", \"m\", \"h\", \"d\", \"w\", \"M\", \"Q\", \"y\"];\n\nexport const niceBytes = (x: string, showK8sUnits: boolean = false) => {\n  let n = parseInt(x, 10) || 0;\n\n  return niceBytesInt(n, showK8sUnits);\n};\n\nexport const niceBytesInt = (n: number, showK8sUnits: boolean = false) => {\n  let l = 0;\n\n  while (n >= 1024 && ++l) {\n    n = n / 1024;\n  }\n  // include a decimal point and a tenths-place digit if presenting\n  // less than ten of KB or greater units\n  const k8sUnitsN = [\"B\", ...k8sUnits];\n  return n.toFixed(1) + \" \" + (showK8sUnits ? k8sUnitsN[l] : units[l]);\n};\n\nexport const setCookie = (name: string, val: string) => {\n  const date = new Date();\n  const value = val;\n\n  // Set it expire in 45 minutes\n  date.setTime(date.getTime() + 45 * 60 * 1000);\n\n  // Set it\n  document.cookie =\n    name + \"=\" + value + \"; expires=\" + date.toUTCString() + \"; path=/\";\n};\n\nexport const deleteCookie = (name: string) => {\n  document.cookie = name + \"=; expires=Thu, 01 Jan 1970 00:00:01 GMT;\";\n};\n\nexport const clearSession = () => {\n  storage.removeItem(\"token\");\n  storage.removeItem(\"auth-state\");\n  deleteCookie(\"token\");\n  deleteCookie(\"idp-refresh-token\");\n};\n\n// timeFromDate gets time string from date input\nexport const timeFromDate = (d: Date) => {\n  let h = d.getHours() < 10 ? `0${d.getHours()}` : `${d.getHours()}`;\n  let m = d.getMinutes() < 10 ? `0${d.getMinutes()}` : `${d.getMinutes()}`;\n  let s = d.getSeconds() < 10 ? `0${d.getSeconds()}` : `${d.getSeconds()}`;\n\n  return `${h}:${m}:${s}:${d.getMilliseconds()}`;\n};\n\n// units to be used in a dropdown\nexport const factorForDropdown = () => {\n  return units.map((unit) => {\n    return { label: unit, value: unit };\n  });\n};\n\n// units to be used in a dropdown\nexport const k8sScalarUnitsExcluding = (exclude?: string[]) => {\n  return k8sUnits\n    .filter((unit) => {\n      if (exclude && exclude.includes(unit)) {\n        return false;\n      }\n      return true;\n    })\n    .map((unit) => {\n      return { label: unit, value: unit };\n    });\n};\n\n//getBytes, converts from a value and a unit from units array to bytes as a string\nexport const getBytes = (\n  value: string,\n  unit: string,\n  fromk8s: boolean = false\n): string => {\n  return getBytesNumber(value, unit, fromk8s).toString(10);\n};\n\n//getBytesNumber, converts from a value and a unit from units array to bytes\nexport const getBytesNumber = (\n  value: string,\n  unit: string,\n  fromk8s: boolean = false\n): number => {\n  const vl: number = parseFloat(value);\n\n  const unitsTake = fromk8s ? k8sCalcUnits : units;\n\n  const powFactor = unitsTake.findIndex((element) => element === unit);\n\n  if (powFactor === -1) {\n    return 0;\n  }\n  const factor = Math.pow(1024, powFactor);\n  const total = vl * factor;\n\n  return total;\n};\n\n//getTotalSize gets the total size of a value & unit\nexport const getTotalSize = (value: string, unit: string) => {\n  const bytes = getBytes(value, unit, true).toString();\n  return niceBytes(bytes);\n};\n\nexport const setMemoryResource = (\n  memorySize: number,\n  capacitySize: string,\n  maxMemorySize: number\n) => {\n  // value always comes as Gi\n  const requestedSizeBytes = getBytes(memorySize.toString(10), \"Gi\", true);\n  const memReqSize = parseInt(requestedSizeBytes, 10);\n  if (maxMemorySize === 0) {\n    return {\n      error: \"There is no memory available for the selected number of nodes\",\n      request: 0,\n      limit: 0,\n    };\n  }\n\n  if (maxMemorySize < minMemReq) {\n    return {\n      error: \"There are not enough memory resources available\",\n      request: 0,\n      limit: 0,\n    };\n  }\n\n  if (memReqSize < minMemReq) {\n    return {\n      error: \"The requested memory size must be greater than 2Gi\",\n      request: 0,\n      limit: 0,\n    };\n  }\n  if (memReqSize > maxMemorySize) {\n    return {\n      error:\n        \"The requested memory is greater than the max available memory for the selected number of nodes\",\n      request: 0,\n      limit: 0,\n    };\n  }\n\n  const capSize = parseInt(capacitySize, 10);\n  let memLimitSize = memReqSize;\n  // set memory limit based on the capacitySize\n  // if capacity size is lower than 1TiB we use the limit equal to request\n  if (capSize >= parseInt(getBytes(\"1\", \"Pi\", true), 10)) {\n    memLimitSize = Math.max(\n      memReqSize,\n      parseInt(getBytes(\"64\", \"Gi\", true), 10)\n    );\n  } else if (capSize >= parseInt(getBytes(\"100\", \"Ti\"), 10)) {\n    memLimitSize = Math.max(\n      memReqSize,\n      parseInt(getBytes(\"32\", \"Gi\", true), 10)\n    );\n  } else if (capSize >= parseInt(getBytes(\"10\", \"Ti\"), 10)) {\n    memLimitSize = Math.max(\n      memReqSize,\n      parseInt(getBytes(\"16\", \"Gi\", true), 10)\n    );\n  } else if (capSize >= parseInt(getBytes(\"1\", \"Ti\"), 10)) {\n    memLimitSize = Math.max(\n      memReqSize,\n      parseInt(getBytes(\"8\", \"Gi\", true), 10)\n    );\n  }\n\n  return {\n    error: \"\",\n    request: memReqSize,\n    limit: memLimitSize,\n  };\n};\n\n// Erasure Code Parity Calc\nexport const erasureCodeCalc = (\n  parityValidValues: string[],\n  totalDisks: number,\n  pvSize: number,\n  totalNodes: number\n): IErasureCodeCalc => {\n  // Parity Values is empty\n  if (parityValidValues.length < 1) {\n    return {\n      error: 1,\n      defaultEC: \"\",\n      erasureCodeSet: 0,\n      maxEC: \"\",\n      rawCapacity: \"0\",\n      storageFactors: [],\n    };\n  }\n\n  const totalStorage = totalDisks * pvSize;\n  const maxEC = parityValidValues[0];\n  const maxParityNumber = parseInt(maxEC.split(\":\")[1], 10);\n\n  const erasureStripeSet = maxParityNumber * 2; // ESS is calculated by multiplying maximum parity by two.\n\n  const storageFactors: IStorageFactors[] = parityValidValues.map(\n    (currentParity) => {\n      const parityNumber = parseInt(currentParity.split(\":\")[1], 10);\n      const storageFactor =\n        erasureStripeSet / (erasureStripeSet - parityNumber);\n\n      const maxCapacity = Math.floor(totalStorage / storageFactor);\n      const maxTolerations =\n        totalDisks - Math.floor(totalDisks / storageFactor);\n      return {\n        erasureCode: currentParity,\n        storageFactor,\n        maxCapacity: maxCapacity.toString(10),\n        maxFailureTolerations: maxTolerations,\n      };\n    }\n  );\n\n  let defaultEC = maxEC;\n\n  const fourVar = parityValidValues.find((element) => element === \"EC:4\");\n\n  if (fourVar) {\n    defaultEC = \"EC:4\";\n  }\n\n  return {\n    error: 0,\n    storageFactors,\n    maxEC,\n    rawCapacity: totalStorage.toString(10),\n    erasureCodeSet: erasureStripeSet,\n    defaultEC,\n  };\n};\n\n// seconds / minutes /hours / Days / Years calculator\nexport const niceDays = (secondsValue: string, timeVariant: string = \"s\") => {\n  let seconds = parseFloat(secondsValue);\n\n  return niceDaysInt(seconds, timeVariant);\n};\n\nexport const niceDaysInt = (seconds: number, timeVariant: string = \"s\") => {\n  switch (timeVariant) {\n    case \"ns\":\n      seconds = Math.floor(seconds * 0.000000001);\n      break;\n    case \"ms\":\n      seconds = Math.floor(seconds * 0.001);\n      break;\n    default:\n  }\n\n  const days = Math.floor(seconds / (3600 * 24));\n\n  seconds -= days * 3600 * 24;\n  const hours = Math.floor(seconds / 3600);\n  seconds -= hours * 3600;\n  const minutes = Math.floor(seconds / 60);\n  seconds -= minutes * 60;\n\n  if (days > 365) {\n    const years = days / 365;\n    return `${years} year${Math.floor(years) === 1 ? \"\" : \"s\"}`;\n  }\n\n  if (days > 30) {\n    const months = Math.floor(days / 30);\n    const diffDays = days - months * 30;\n\n    return `${months} month${Math.floor(months) === 1 ? \"\" : \"s\"} ${\n      diffDays > 0 ? `${diffDays} day${diffDays > 1 ? \"s\" : \"\"}` : \"\"\n    }`;\n  }\n\n  if (days >= 7 && days <= 30) {\n    const weeks = Math.floor(days / 7);\n\n    return `${Math.floor(weeks)} week${weeks === 1 ? \"\" : \"s\"}`;\n  }\n\n  if (days >= 1 && days <= 6) {\n    return `${days} day${days > 1 ? \"s\" : \"\"}`;\n  }\n\n  return `${hours >= 1 ? `${hours} hour${hours > 1 ? \"s\" : \"\"}` : \"\"} ${\n    minutes >= 1 && hours === 0\n      ? `${minutes} minute${minutes > 1 ? \"s\" : \"\"}`\n      : \"\"\n  } ${\n    seconds >= 1 && minutes === 0 && hours === 0\n      ? `${seconds} second${seconds > 1 ? \"s\" : \"\"}`\n      : \"\"\n  }`;\n};\n\nconst twoDigitsNumberString = (value: number) => {\n  return `${value < 10 ? \"0\" : \"\"}${value}`;\n};\n\nexport const getTimeFromTimestamp = (\n  timestamp: string,\n  fullDate: boolean = false,\n  simplifiedDate: boolean = false\n) => {\n  const timestampToInt = parseInt(timestamp);\n  if (isNaN(timestampToInt)) {\n    return \"\";\n  }\n  const dateObject = new Date(timestampToInt * 1000);\n\n  if (fullDate) {\n    if (simplifiedDate) {\n      return `${twoDigitsNumberString(\n        dateObject.getMonth() + 1\n      )}/${twoDigitsNumberString(dateObject.getDate())} ${twoDigitsNumberString(\n        dateObject.getHours()\n      )}:${twoDigitsNumberString(dateObject.getMinutes())}`;\n    } else {\n      return dateObject.toLocaleString();\n    }\n  }\n  return `${dateObject.getHours()}:${String(dateObject.getMinutes()).padStart(\n    2,\n    \"0\"\n  )}`;\n};\n\nexport const calculateBytes = (\n  x: string | number,\n  showDecimals = false,\n  roundFloor = true,\n  k8sUnit = false\n): IBytesCalc => {\n  let bytes;\n\n  if (typeof x === \"string\") {\n    bytes = parseInt(x, 10);\n  } else {\n    bytes = x;\n  }\n\n  if (bytes === 0) {\n    return { total: 0, unit: units[0] };\n  }\n\n  // Gi : GiB\n  const k = 1024;\n\n  // Get unit for measure\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  const fractionDigits = showDecimals ? 1 : 0;\n\n  const bytesUnit = bytes / Math.pow(k, i);\n\n  const roundedUnit = roundFloor ? Math.floor(bytesUnit) : bytesUnit;\n\n  // Get Unit parsed\n  const unitParsed = parseFloat(roundedUnit.toFixed(fractionDigits));\n  const finalUnit = k8sUnit ? k8sCalcUnits[i] : units[i];\n\n  return { total: unitParsed, unit: finalUnit };\n};\n\nexport const nsToSeconds = (nanoseconds: number) => {\n  const conversion = nanoseconds * 0.000000001;\n  const round = Math.round((conversion + Number.EPSILON) * 10000) / 10000;\n\n  return `${round} s`;\n};\n\nexport const textToRGBColor = (text: string) => {\n  const splitText = text.split(\"\");\n\n  const hashVl = splitText.reduce((acc, currItem) => {\n    return acc + currItem.charCodeAt(0) + ((acc << 5) - acc);\n  }, 0);\n\n  const hashColored = ((hashVl * 100) & 0x00ffffff).toString(16).toUpperCase();\n\n  return `#${hashColored.padStart(6, \"0\")}`;\n};\n\nexport const prettyNumber = (usage: number | undefined) => {\n  if (usage === undefined) {\n    return 0;\n  }\n\n  return usage.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n};\n\nexport const representationNumber = (number: number | undefined) => {\n  if (number === undefined) {\n    return \"0\";\n  }\n\n  let returnValue = number.toString();\n  let unit = \"\";\n\n  if (number > 999 && number < 1000000) {\n    returnValue = (number / 1000).toFixed(1); // convert to K, numbers > 999\n    unit = \"K\";\n  } else if (number >= 1000000 && number < 1000000000) {\n    returnValue = (number / 1000000).toFixed(1); // convert to M, numbers >= 1 million\n    unit = \"M\";\n  } else if (number >= 1000000000) {\n    returnValue = (number / 1000000000).toFixed(1); // convert to B, numbers >= 1 billion\n    unit = \"B\";\n  }\n\n  if (returnValue.endsWith(\".0\")) {\n    returnValue = returnValue.slice(0, -2);\n  }\n\n  return `${returnValue}${unit}`;\n};\n\nexport const encodeURLString = (name: string | null) => {\n  if (!name) {\n    return \"\";\n  }\n  try {\n    return btoa(unescape(encodeURIComponent(name)));\n  } catch (err) {\n    return \"\";\n  }\n};\n\nexport const decodeURLString = (text: string) => {\n  try {\n    return decodeURIComponent(escape(window.atob(text)));\n  } catch (err) {\n    return text;\n  }\n};\n\nexport const performDownload = (blob: Blob, fileName: string) => {\n  const link = document.createElement(\"a\");\n  link.href = window.URL.createObjectURL(blob);\n  link.download = fileName;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n};\n\nexport const getCookieValue = (cookieName: string) => {\n  return (\n    document.cookie\n      .match(\"(^|;)\\\\s*\" + cookieName + \"\\\\s*=\\\\s*([^;]+)\")\n      ?.pop() || \"\"\n  );\n};\n\nexport const capacityColors = (usedSpace: number, maxSpace: number) => {\n  const percCalculate = (usedSpace * 100) / maxSpace;\n\n  if (percCalculate >= 90) {\n    return \"#C83B51\";\n  } else if (percCalculate >= 70) {\n    return \"#FFAB0F\";\n  }\n\n  return \"#07193E\";\n};\n\nexport const getClientOS = (): string => {\n  const getPlatform = get(window.navigator, \"platform\", \"undefined\");\n\n  if (!getPlatform) {\n    return \"undefined\";\n  }\n\n  return getPlatform;\n};\n\nexport const MinIOEnvVarsSettings: any = {\n  MINIO_ACCESS_KEY: { secret: true },\n  MINIO_ACCESS_KEY_OLD: { secret: true },\n  MINIO_AUDIT_WEBHOOK_AUTH_TOKEN: { secret: true },\n  MINIO_IDENTITY_LDAP_LOOKUP_BIND_PASSWORD: { secret: true },\n  MINIO_IDENTITY_OPENID_CLIENT_SECRET: { secret: true },\n  MINIO_KMS_SECRET_KEY: { secret: true },\n  MINIO_LOGGER_WEBHOOK_AUTH_TOKEN: { secret: true },\n  MINIO_NOTIFY_ELASTICSEARCH_PASSWORD: { secret: true },\n  MINIO_NOTIFY_KAFKA_SASL_PASSWORD: { secret: true },\n  MINIO_NOTIFY_MQTT_PASSWORD: { secret: true },\n  MINIO_NOTIFY_NATS_PASSWORD: { secret: true },\n  MINIO_NOTIFY_NATS_TOKEN: { secret: true },\n  MINIO_NOTIFY_REDIS_PASSWORD: { secret: true },\n  MINIO_NOTIFY_WEBHOOK_AUTH_TOKEN: { secret: true },\n  MINIO_ROOT_PASSWORD: { secret: true },\n  MINIO_SECRET_KEY: { secret: true },\n  MINIO_SECRET_KEY_OLD: { secret: true },\n};\n\nexport const MinIOEnvironmentVariables = [\n  \"MINIO_ACCESS_KEY\",\n  \"MINIO_ACCESS_KEY_OLD\",\n  \"MINIO_AUDIT_WEBHOOK_AUTH_TOKEN\",\n  \"MINIO_AUDIT_WEBHOOK_CLIENT_CERT\",\n  \"MINIO_AUDIT_WEBHOOK_CLIENT_KEY\",\n  \"MINIO_AUDIT_WEBHOOK_ENABLE\",\n  \"MINIO_AUDIT_WEBHOOK_ENDPOINT\",\n  \"MINIO_BROWSER\",\n  \"MINIO_BROWSER_REDIRECT_URL\",\n  \"MINIO_IDENTITY_LDAP_COMMENT\",\n  \"MINIO_IDENTITY_LDAP_GROUP_SEARCH_BASE_DN\",\n  \"MINIO_IDENTITY_LDAP_GROUP_SEARCH_FILTER\",\n  \"MINIO_IDENTITY_LDAP_LOOKUP_BIND_DN\",\n  \"MINIO_IDENTITY_LDAP_LOOKUP_BIND_PASSWORD\",\n  \"MINIO_IDENTITY_LDAP_SERVER_ADDR\",\n  \"MINIO_IDENTITY_LDAP_SERVER_INSECURE\",\n  \"MINIO_IDENTITY_LDAP_SERVER_STARTTLS\",\n  \"MINIO_IDENTITY_LDAP_STS_EXPIRY\",\n  \"MINIO_IDENTITY_LDAP_TLS_SKIP_VERIFY\",\n  \"MINIO_IDENTITY_LDAP_USER_DN_SEARCH_BASE_DN\",\n  \"MINIO_IDENTITY_LDAP_USER_DN_SEARCH_FILTER\",\n  \"MINIO_IDENTITY_LDAP_USERNAME_FORMAT\",\n  \"MINIO_IDENTITY_OPENID_CLAIM_NAME\",\n  \"MINIO_IDENTITY_OPENID_CLAIM_PREFIX\",\n  \"MINIO_IDENTITY_OPENID_CLIENT_ID\",\n  \"MINIO_IDENTITY_OPENID_CLIENT_SECRET\",\n  \"MINIO_IDENTITY_OPENID_COMMENT\",\n  \"MINIO_IDENTITY_OPENID_CONFIG_URL\",\n  \"MINIO_IDENTITY_OPENID_REDIRECT_URI\",\n  \"MINIO_IDENTITY_OPENID_SCOPES\",\n  \"MINIO_KMS_AUTO_ENCRYPTION\",\n  \"MINIO_KMS_KES_CERT_FILE\",\n  \"MINIO_KMS_KES_ENDPOINT\",\n  \"MINIO_KMS_KES_KEY_FILE\",\n  \"MINIO_KMS_KES_KEY_NAME\",\n  \"MINIO_KMS_SECRET_KEY\",\n  \"MINIO_LOGGER_WEBHOOK_AUTH_TOKEN\",\n  \"MINIO_LOGGER_WEBHOOK_ENABLE\",\n  \"MINIO_LOGGER_WEBHOOK_ENDPOINT\",\n  \"MINIO_LOG_QUERY_URL\",\n  \"MINIO_NOTIFY_AMQP_AUTO_DELETED\",\n  \"MINIO_NOTIFY_AMQP_COMMENT\",\n  \"MINIO_NOTIFY_AMQP_DELIVERY_MODE\",\n  \"MINIO_NOTIFY_AMQP_DURABLE\",\n  \"MINIO_NOTIFY_AMQP_ENABLE\",\n  \"MINIO_NOTIFY_AMQP_EXCHANGE\",\n  \"MINIO_NOTIFY_AMQP_EXCHANGE_TYPE\",\n  \"MINIO_NOTIFY_AMQP_INTERNAL\",\n  \"MINIO_NOTIFY_AMQP_MANDATORY\",\n  \"MINIO_NOTIFY_AMQP_NO_WAIT\",\n  \"MINIO_NOTIFY_AMQP_QUEUE_DIR\",\n  \"MINIO_NOTIFY_AMQP_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_AMQP_ROUTING_KEY\",\n  \"MINIO_NOTIFY_AMQP_URL\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_COMMENT\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_ENABLE\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_FORMAT\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_INDEX\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_PASSWORD\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_QUEUE_DIR\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_URL\",\n  \"MINIO_NOTIFY_ELASTICSEARCH_USERNAME\",\n  \"MINIO_NOTIFY_KAFKA_BROKERS\",\n  \"MINIO_NOTIFY_KAFKA_CLIENT_TLS_CERT\",\n  \"MINIO_NOTIFY_KAFKA_CLIENT_TLS_KEY\",\n  \"MINIO_NOTIFY_KAFKA_COMMENT\",\n  \"MINIO_NOTIFY_KAFKA_ENABLE\",\n  \"MINIO_NOTIFY_KAFKA_QUEUE_DIR\",\n  \"MINIO_NOTIFY_KAFKA_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_KAFKA_SASL\",\n  \"MINIO_NOTIFY_KAFKA_SASL_MECHANISM\",\n  \"MINIO_NOTIFY_KAFKA_SASL_PASSWORD\",\n  \"MINIO_NOTIFY_KAFKA_SASL_USERNAME\",\n  \"MINIO_NOTIFY_KAFKA_TLS\",\n  \"MINIO_NOTIFY_KAFKA_TLS_CLIENT_AUTH\",\n  \"MINIO_NOTIFY_KAFKA_TLS_SKIP_VERIFY\",\n  \"MINIO_NOTIFY_KAFKA_TOPIC\",\n  \"MINIO_NOTIFY_KAFKA_VERSION\",\n  \"MINIO_NOTIFY_MQTT_BROKER\",\n  \"MINIO_NOTIFY_MQTT_COMMENT\",\n  \"MINIO_NOTIFY_MQTT_ENABLE\",\n  \"MINIO_NOTIFY_MQTT_KEEP_ALIVE_INTERVAL\",\n  \"MINIO_NOTIFY_MQTT_PASSWORD\",\n  \"MINIO_NOTIFY_MQTT_QOS\",\n  \"MINIO_NOTIFY_MQTT_QUEUE_DIR\",\n  \"MINIO_NOTIFY_MQTT_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_MQTT_RECONNECT_INTERVAL\",\n  \"MINIO_NOTIFY_MQTT_TOPIC\",\n  \"MINIO_NOTIFY_MQTT_USERNAME\",\n  \"MINIO_NOTIFY_MYSQL_COMMENT\",\n  \"MINIO_NOTIFY_MYSQL_DSN_STRING\",\n  \"MINIO_NOTIFY_MYSQL_ENABLE\",\n  \"MINIO_NOTIFY_MYSQL_FORMAT\",\n  \"MINIO_NOTIFY_MYSQL_MAX_OPEN_CONNECTIONS\",\n  \"MINIO_NOTIFY_MYSQL_QUEUE_DIR\",\n  \"MINIO_NOTIFY_MYSQL_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_MYSQL_TABLE\",\n  \"MINIO_NOTIFY_NATS_ADDRESS\",\n  \"MINIO_NOTIFY_NATS_CERT_AUTHORITY\",\n  \"MINIO_NOTIFY_NATS_CLIENT_CERT\",\n  \"MINIO_NOTIFY_NATS_CLIENT_KEY\",\n  \"MINIO_NOTIFY_NATS_COMMENT\",\n  \"MINIO_NOTIFY_NATS_ENABLE\",\n  \"MINIO_NOTIFY_NATS_PASSWORD\",\n  \"MINIO_NOTIFY_NATS_PING_INTERVAL\",\n  \"MINIO_NOTIFY_NATS_QUEUE_DIR\",\n  \"MINIO_NOTIFY_NATS_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_NATS_STREAMING\",\n  \"MINIO_NOTIFY_NATS_STREAMING_ASYNC\",\n  \"MINIO_NOTIFY_NATS_STREAMING_CLUSTER_ID\",\n  \"MINIO_NOTIFY_NATS_STREAMING_MAX_PUB_ACKS_IN_FLIGHT\",\n  \"MINIO_NOTIFY_NATS_SUBJECT\",\n  \"MINIO_NOTIFY_NATS_TLS\",\n  \"MINIO_NOTIFY_NATS_TLS_SKIP_VERIFY\",\n  \"MINIO_NOTIFY_NATS_TOKEN\",\n  \"MINIO_NOTIFY_NATS_USERNAME\",\n  \"MINIO_NOTIFY_NSQ_COMMENT\",\n  \"MINIO_NOTIFY_NSQ_ENABLE\",\n  \"MINIO_NOTIFY_NSQ_NSQD_ADDRESS\",\n  \"MINIO_NOTIFY_NSQ_QUEUE_DIR\",\n  \"MINIO_NOTIFY_NSQ_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_NSQ_TLS\",\n  \"MINIO_NOTIFY_NSQ_TLS_SKIP_VERIFY\",\n  \"MINIO_NOTIFY_NSQ_TOPIC\",\n  \"MINIO_NOTIFY_POSTGRESQL_COMMENT\",\n  \"MINIO_NOTIFY_POSTGRESQL_CONNECTION_STRING\",\n  \"MINIO_NOTIFY_POSTGRESQL_ENABLE\",\n  \"MINIO_NOTIFY_POSTGRESQL_FORMAT\",\n  \"MINIO_NOTIFY_POSTGRESQL_MAX_OPEN_CONNECTIONS\",\n  \"MINIO_NOTIFY_POSTGRESQL_QUEUE_DIR\",\n  \"MINIO_NOTIFY_POSTGRESQL_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_POSTGRESQL_TABLE\",\n  \"MINIO_NOTIFY_REDIS_ADDRESS\",\n  \"MINIO_NOTIFY_REDIS_COMMENT\",\n  \"MINIO_NOTIFY_REDIS_ENABLE\",\n  \"MINIO_NOTIFY_REDIS_FORMAT\",\n  \"MINIO_NOTIFY_REDIS_KEY\",\n  \"MINIO_NOTIFY_REDIS_PASSWORD\",\n  \"MINIO_NOTIFY_REDIS_QUEUE_DIR\",\n  \"MINIO_NOTIFY_REDIS_QUEUE_LIMIT\",\n  \"MINIO_NOTIFY_WEBHOOK_AUTH_TOKEN\",\n  \"MINIO_NOTIFY_WEBHOOK_CLIENT_CERT\",\n  \"MINIO_NOTIFY_WEBHOOK_CLIENT_KEY\",\n  \"MINIO_NOTIFY_WEBHOOK_COMMENT\",\n  \"MINIO_NOTIFY_WEBHOOK_ENABLE\",\n  \"MINIO_NOTIFY_WEBHOOK_ENDPOINT\",\n  \"MINIO_NOTIFY_WEBHOOK_QUEUE_DIR\",\n  \"MINIO_NOTIFY_WEBHOOK_QUEUE_LIMIT\",\n  \"MINIO_PROMETHEUS_AUTH_TYPE\",\n  \"MINIO_PROMETHEUS_JOB_ID\",\n  \"MINIO_PROMETHEUS_URL\",\n  \"MINIO_ROOT_PASSWORD\",\n  \"MINIO_ROOT_USER\",\n  \"MINIO_SECRET_KEY\",\n  \"MINIO_SECRET_KEY_OLD\",\n  \"MINIO_SERVER_URL\",\n  \"MINIO_STORAGE_CLASS_COMMENT\",\n  \"MINIO_STORAGE_CLASS_RRS\",\n  \"MINIO_STORAGE_CLASS_STANDARD\",\n];\n\n// Generates a valid access/secret key string\nexport const getRandomString = function (length = 16): string {\n  let retval = \"\";\n  let legalcharacters =\n    \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  for (let i = 0; i < length; i++) {\n    retval +=\n      legalcharacters[Math.floor(Math.random() * legalcharacters.length)];\n  }\n  return retval;\n};\n\n// replaces bad unicode characters\nexport const replaceUnicodeChar = (inputString: string): string => {\n  let unicodeChar = \"\\u202E\";\n  return inputString.split(unicodeChar).join(\"<\ufffd202e>\");\n};\n", "import React from \"react\";\nimport createStyles from \"@mui/styles/createStyles\";\nimport withStyles from \"@mui/styles/withStyles\";\nimport { Theme } from \"@mui/material/styles\";\nimport { replaceUnicodeChar } from \"../../../../../../common/utils\";\n\ninterface IIconWithLabel {\n  classes: any;\n  icon: JSX.Element;\n  strings: string[];\n}\n\nconst styles = (theme: Theme) =>\n  createStyles({\n    fileName: {\n      display: \"flex\",\n      alignItems: \"center\",\n      \"& .min-icon\": {\n        width: 16,\n        height: 16,\n        marginRight: 4,\n        minWidth: 16,\n        minHeight: 16,\n      },\n    },\n    fileNameText: {\n      whiteSpace: \"nowrap\",\n      overflow: \"hidden\",\n      textOverflow: \"ellipsis\",\n    },\n  });\n\nconst IconWithLabel = ({ classes, icon, strings }: IIconWithLabel) => {\n  return (\n    <div className={classes.fileName}>\n      {icon}\n      <span className={classes.fileNameText}>\n        {replaceUnicodeChar(strings[strings.length - 1])}\n      </span>\n    </div>\n  );\n};\n\nexport default withStyles(styles)(IconWithLabel);\n"], "filenames": ["portal-ui/src/common/utils.ts", "portal-ui/src/screens/Console/Buckets/ListBuckets/Objects/ListObjects/IconWithLabel.tsx"], "buggy_code_start_loc": [714, 4], "buggy_code_end_loc": [714, 38], "fixing_code_start_loc": [715, 5], "fixing_code_end_loc": [721, 39], "type": "NVD-CWE-noinfo", "message": "Minio Console is the UI for MinIO Object Storage. Unicode RIGHT-TO-LEFT OVERRIDE characters can be used to mask the original filename. This issue has been patched in version 0.28.0.\n\n", "other": {"cve": {"id": "CVE-2023-33955", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-30T07:15:10.850", "lastModified": "2023-06-05T16:42:23.013", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Minio Console is the UI for MinIO Object Storage. Unicode RIGHT-TO-LEFT OVERRIDE characters can be used to mask the original filename. This issue has been patched in version 0.28.0.\n\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minio:console:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.28.0", "matchCriteriaId": "CD653D93-A1BC-4D8A-B7FC-D6A6B3F1FA53"}]}]}], "references": [{"url": "https://github.com/minio/console/commit/17e791afb90c9ad27c65f63c6be14f2f6a3a9d60", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/minio/console/releases/tag/v0.28.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/minio/console/security/advisories/GHSA-jv3f-7m33-qp65", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/minio/console/commit/17e791afb90c9ad27c65f63c6be14f2f6a3a9d60"}}