{"buggy_code": ["/* -*- C++ -*-\n * This file is part of Zutty.\n * Copyright (C) 2020 Tom Szilagyi\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * See the file LICENSE for the full license.\n */\n\n#include \"log.h\"\n#include \"pty.h\"\n\n#include <algorithm>\n#include <sstream>\n\n// for the debug/step facility:\n#include <chrono>\n#include <thread>\n#include <sys/types.h>\n#include <signal.h>\n\nnamespace zutty\n{\n#ifdef DEBUG\n\n   inline void\n   Vterm::debugKey ()\n   {\n      switch (debugStep)\n      {\n      case 0: debugStep = 1; break;\n      case 1: debugStep = 10; break;\n      case 10: debugStep = 100; break;\n      case 100: debugStep = 0; break;\n      }\n      debugCnt = debugStep;\n      logT << \"*** DEBUG step=\" << debugStep << std::endl;\n   }\n\n   inline void\n   Vterm::debugBreak ()\n   {\n      if (!debugStep || --debugCnt > 0)\n         return;\n\n      debugCnt = debugStep;\n      logT << \"*** DEBUG STOP (step=\" << debugStep << \"), \"\n           << readPos + 1 - lastStopPos << \" bytes since last:\\n        \"\n           << dumpBuffer (inputBuf + lastStopPos, inputBuf + readPos + 1);\n      lastStopPos = readPos + 1;\n\n      logT << \"Issue 'kill -CONT \" << getpid () << \"' or 'fg' to continue.\"\n           << std::endl;\n\n      redraw ();\n      using namespace std::chrono_literals;\n      std::this_thread::sleep_for (100ms);\n\n      kill (getpid (), SIGSTOP);\n   }\n\n   #define DEBUG_BREAK debugBreak()\n   #define TRACE_FUN                                                      \\\n      do {                                                                \\\n         logT << __FUNCTION__ << \" [\";                                    \\\n      for (size_t k = 0; k < nInputOps; ++k) {                            \\\n         if (k) {                                                         \\\n            vlog << \";\";                                                  \\\n         }                                                                \\\n         vlog << inputOps [k];                                            \\\n      }                                                                   \\\n      vlog << \"] \\t\"                                                      \\\n           << \"p(\" << posY << \",\" << posX << \")  \"                        \\\n           << \"d(\" << nRows << \",\" << nCols << \")  \"                      \\\n           << \"mgn[\" << marginTop << \",\" << marginBottom << \")  \"         \\\n           << \"hmgn:\" << horizMarginMode                                  \\\n           << \" [\" << hMargin << \",\" << nColsEff << \")\"                   \\\n           << std::endl;                                                  \\\n   } while (0)\n#else\n   #define DEBUG_BREAK\n   #define TRACE_FUN\n#endif // DEBUG\n\n   inline void\n   Vterm::unhandledInput (unsigned char ch)\n   {\n      logE << \"Unhandled input char '\" << ch << \"' (\" << (int)ch\n           << \") in state \" << strInputState (inputState)\n           << \". Escape sequence so far: \"\n           << dumpBuffer (inputBuf + lastEscBegin, inputBuf + readPos + 1);\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::traceNormalInput ()\n   {\n   #ifdef DEBUG\n      if (lastNormalBegin < readPos)\n      {\n         auto dumpbufs = dumpBuffer (inputBuf + lastNormalBegin,\n                                     inputBuf + readPos);\n         if (dumpbufs.length ())\n         {\n            logT << \"Inserted: \" << dumpbufs;\n         }\n      }\n      lastNormalBegin = readPos + 1;\n   #endif // DEBUG\n   }\n\n   inline void\n   Vterm::redraw ()\n   {\n      onRefresh (* cf);\n      cf->resetDamage ();\n   }\n\n   inline const MouseTrackingState&\n   Vterm::getMouseTrackingState () const\n   {\n      return mouseTrk;\n   }\n\n   inline void\n   Vterm::setHasFocus (bool hasFocus_)\n   {\n      hasFocus = hasFocus_;\n      showCursor ();\n      redraw ();\n   }\n\n   inline void\n   Vterm::pageUp ()\n   {\n      if (altScrollMode && altScreenBufferMode)\n      {\n         inputOps [0] = 1;\n         nInputOps = 1;\n         for (int k = 0; k < (marginBottom - marginTop) / 2; ++k)\n            writePty (VtKey::Up);\n      }\n      else\n      {\n         cf->pageUp (nRows / 2);\n         redraw ();\n      }\n   }\n\n   inline void\n   Vterm::pageDown ()\n   {\n      if (altScrollMode && altScreenBufferMode)\n      {\n         inputOps [0] = 1;\n         nInputOps = 1;\n         for (int k = 0; k < (marginBottom - marginTop) / 2; ++k)\n            writePty (VtKey::Down);\n      }\n      else\n      {\n         cf->pageDown (nRows / 2);\n         redraw ();\n      }\n   }\n\n   inline void\n   Vterm::mouseWheelUp ()\n   {\n      if (altScrollMode && altScreenBufferMode)\n      {\n         inputOps [0] = 1;\n         nInputOps = 1;\n         writePty (VtKey::Up);\n      }\n      else\n      {\n         cf->pageUp (5);\n         redraw ();\n      }\n   }\n\n   inline void\n   Vterm::mouseWheelDown ()\n   {\n      if (altScrollMode && altScreenBufferMode)\n      {\n         inputOps [0] = 1;\n         nInputOps = 1;\n         writePty (VtKey::Down);\n      }\n      else\n      {\n         cf->pageDown (5);\n         redraw ();\n      }\n   }\n\n   inline void\n   Vterm::resetTerminal ()\n   {\n      resetScreen ();\n      resetAttrs ();\n\n      switchColMode (ColMode::C80);\n\n      cf->dropScrollbackHistory ();\n      cf->resetMargins (marginTop, marginBottom);\n      clearScreen ();\n\n      switchScreenBufferMode (false);\n      altScrollMode = opts.altScrollMode;\n      altSendsEscape = opts.altSendsEscape;\n      modifyOtherKeys = opts.modifyOtherKeys;\n\n      horizMarginMode = false;\n      hMargin = 0;\n      nColsEff = nCols;\n\n      setState (InputState::Normal);\n\n      if (haveOscHandler)\n      {\n         // reset title\n         argBuf.clear ();\n         argBuf.push_back ('0');\n         argBuf.push_back (';');\n         for (const char* p = opts.title; *p != '\\0'; ++p)\n            argBuf.push_back (*p);\n         handle_OSC ();\n      }\n   }\n\n   inline void\n   Vterm::resetScreen ()\n   {\n      showCursorMode = true;\n      autoWrapMode = true;\n      autoNewlineMode = false;\n      keyboardLocked = false;\n      insertMode = false;\n      bkspSendsDel = true;\n      localEcho = false;\n      bracketedPasteMode = false;\n\n      compatLevel = CompatibilityLevel::VT400;\n      cursorKeyMode = CursorKeyMode::ANSI;\n      keypadMode = KeypadMode::Normal;\n      originMode = OriginMode::Absolute;\n      charsetState = CharsetState {};\n\n      savedCursor_SCO.isSet = false;\n      savedCursor_DEC->isSet = false;\n\n      mouseTrk = MouseTrackingState {};\n\n      tabStops.clear ();\n      cf->getSelection ().clear ();\n   }\n\n   inline void\n   Vterm::resetAttrs ()\n   {\n      reverseVideo = false;\n      fg = &attrs.fg;\n      bg = &attrs.bg;\n\n      inputOps [0] = 0;\n      nInputOps = 1;\n      csi_SGR ();\n   }\n\n   inline void\n   Vterm::clearScreen ()\n   {\n      posX = 0;\n      posY = 0;\n      lastCol = false;\n      fillScreen (' ');\n   }\n\n   inline void\n   Vterm::fillScreen (uint16_t ch)\n   {\n      cf->fillCells (ch, attrs);\n   }\n\n   inline void\n   Vterm::switchColMode (ColMode colMode_)\n   {\n      if (colMode == colMode_)\n         return;\n\n      resetScreen ();\n      clearScreen ();\n\n      if (colMode_ == ColMode::C80)\n      {\n         logT << \"DECCOLM: Selected 80 columns per line\" << std::endl;\n      }\n      else\n      {\n         logT << \"DECCOLM: Selected 132 columns per line\" << std::endl;\n      }\n\n      colMode = colMode_;\n   }\n\n   inline void\n   Vterm::switchScreenBufferMode (bool altScreenBufferMode_)\n   {\n      if (altScreenBufferMode == altScreenBufferMode_)\n         return;\n\n      if (altScreenBufferMode_)\n      {\n         frame_alt = Frame (winPx, winPy, nCols, nRows,\n                            marginTop, marginBottom);\n         cf = &frame_alt;\n         cf->expose ();\n\n         savedCursor_DEC = &savedCursor_DEC_alt;\n         altScreenBufferMode = true;\n      }\n      else\n      {\n         frame_pri.resize (winPx, winPy, nCols, nRows,\n                           marginTop, marginBottom);\n         cf = &frame_pri;\n         cf->expose ();\n         frame_alt.freeCells ();\n\n         savedCursor_DEC_alt.isSet = false;\n         savedCursor_DEC = &savedCursor_DEC_pri;\n         altScreenBufferMode = false;\n         cf->getSelection ().clear ();\n      }\n   }\n\n   inline void\n   Vterm::setState (InputState newState)\n   {\n      if (newState == inputState)\n         return;\n\n      if (newState == InputState::Normal)\n      {\n         DEBUG_BREAK;\n         nInputOps = 0;\n         inputOps [0] = 0;\n         lastNormalBegin = readPos + 1;\n      }\n      else if (inputState == InputState::Normal)\n      {\n         traceNormalInput ();\n      }\n\n      inputState = newState;\n   }\n\n   inline bool\n   Vterm::readPty ()\n   {\n      static bool first = true;\n      ssize_t n = read (ptyFd, inputBuf, sizeof (inputBuf));\n      if (n < 0)\n         return true;\n      else if (n == 0)\n         return !first;\n\n      if (first)\n      {\n         // Mitigate the race condition between shell process startup\n         // and first window size configuration happening in parallel:\n         // the signal could get delivered before the shell is ready\n         // for it, and thus get lost.\n         pty_resize (ptyFd, nCols, nRows);\n         first = false;\n      }\n\n      logT << \"pty read: \" << dumpBuffer (inputBuf, inputBuf + n);\n      processInput (inputBuf, n);\n\n      return false;\n   }\n\n   inline void\n   Vterm::normalizeCursorPos ()\n   {\n      if (nColsEff < posX + 1)\n         posX = nColsEff - 1;\n\n      if (nRows < posY + 1)\n         posY = nRows - 1;\n\n      lastCol = false;\n   }\n\n   inline bool\n   Vterm::isCursorInsideMargins ()\n   {\n      return posX >= hMargin && posX < nColsEff &&\n             posY >= marginTop && posY < marginBottom;\n   }\n\n   inline void\n   Vterm::eraseRow (uint16_t pY)\n   {\n      cf->eraseInRow (pY, hMargin, nColsEff - hMargin, attrs);\n   }\n\n   inline void\n   Vterm::eraseRows (uint16_t startY, uint16_t count)\n   {\n      for (uint16_t pY = startY; pY < startY + count; ++pY)\n         eraseRow (pY);\n   }\n\n   inline void\n   Vterm::copyRow (uint16_t dstY, uint16_t srcY)\n   {\n      cf->copyRow (dstY, srcY, hMargin, nColsEff - hMargin);\n   }\n\n   // insert blank rows at and below startY, within the scrolling area\n   inline void\n   Vterm::insertRows (uint16_t startY, uint16_t count)\n   {\n      for (uint16_t pY = marginBottom - count - 1; pY >= startY; --pY)\n      {\n         copyRow (pY + count, pY);\n         if (!pY) break;\n      }\n\n      for (uint16_t pY = startY; pY < startY + count; ++pY)\n         eraseRow (pY);\n   }\n\n   // delete rows at and below startY, within the scrolling area\n   inline void\n   Vterm::deleteRows (uint16_t startY, uint16_t count)\n   {\n      for (uint16_t pY = startY; pY < marginBottom - count; ++pY)\n         copyRow (pY, pY + count);\n\n      for (uint16_t pY = marginBottom - count; pY < marginBottom; ++pY)\n         eraseRow (pY);\n   }\n\n   // insert blank cols at and to the right of startX, within the scrolling area\n   inline void\n   Vterm::insertCols (uint16_t startX, uint16_t count)\n   {\n      for (uint16_t r = marginTop; r < marginBottom; ++r)\n      {\n         cf->moveInRow (r, startX + count, startX, nColsEff - startX - count);\n         cf->eraseInRow (r, startX, count, attrs);\n      }\n   }\n\n   // delete cols at and to the right of startX, within the scrolling area\n   inline void\n   Vterm::deleteCols (uint16_t startX, uint16_t count)\n   {\n      for (uint16_t r = marginTop; r < marginBottom; ++r)\n      {\n         cf->moveInRow (r, startX, startX + count, nColsEff - startX - count);\n         cf->eraseInRow (r, nColsEff - count, count, attrs);\n      }\n   }\n\n   inline void\n   Vterm::inputGraphicChar (unsigned char ch)\n   {\n      if ((ch & 0x80) == 0)\n      {\n         utf8dec.checkPrematureEOS ();\n\n         // GL range\n         Charset cs;\n         if (charsetState.ss)\n         {\n            cs = charsetState.g [charsetState.ss];\n            charsetState.ss = 0;\n         }\n         else\n            cs = charsetState.g [charsetState.gl];\n\n         if (cs == Charset::UTF8)\n            utf8dec.onUnicode (ch < 127 ? ch : 0);\n         else if (ch >= 32 && (cs == Charset::IsoLatin1 || ch < 127))\n            utf8dec.onUnicode (charCodes [(uint8_t)cs] [ch - 32]);\n      }\n      else\n      {\n         // GR range\n         Charset cs = charsetState.g [charsetState.gr];\n         if (cs == Charset::UTF8)\n            utf8dec.pushByte (ch);\n         else if (ch >= 160 && (cs == Charset::IsoLatin1 || ch < 255))\n            utf8dec.onUnicode (charCodes [(uint8_t)cs] [ch - 160]);\n      }\n   }\n\n   inline void\n   Vterm::placeGraphicChar ()\n   {\n      auto pt = utf8dec.getUnicode ();\n      auto w = wcwidth (pt);\n\n      if (!w) // zero-width code\n         return;\n\n      if (pt > 0xffff)\n      {\n         // Code outside the Unicode BMP -- not supported.\n         // Would get truncated anyway; this is safer and more deterministic.\n         pt = Missing_Glyph_Marker;\n      }\n\n      if (w < 0)\n      {\n         // Render codes with no visual representation as a Unicode RC\n         w = 1;\n         pt = Unicode_Replacement_Character;\n      }\n\n      if (autoWrapMode && lastCol)\n      {\n         cf->getCell (posY, posX).wrap = 1;\n         inp_CR ();\n         inp_LF ();\n      }\n\n      if (insertMode)\n      {\n         nInputOps = 1;\n         inputOps [0] = 1;\n         csi_ICH ();\n      }\n\n      auto& c = cf->getCell (posY, posX);\n      c = attrs;\n      c.uc_pt = pt;\n\n      if (w == 2 && posX < nColsEff - 1)\n      {\n         c.dwidth = 1;\n         cf->getCell (posY, ++posX).dwidth_cont = 1;\n      }\n\n      if (posX == nColsEff - 1)\n         lastCol = true;\n      else\n         ++posX;\n   }\n\n   inline void\n   Vterm::inp_LF ()\n   {\n      TRACE_FUN;\n      if (esc_IND ())\n         cf->eraseInRow (posY, posX, nColsEff - posX, attrs);\n   }\n\n   inline void\n   Vterm::inp_CR ()\n   {\n      TRACE_FUN;\n      if (originMode == OriginMode::Absolute && posX < hMargin)\n         posX = 0;\n      else\n         posX = hMargin;\n      lastCol = false;\n   }\n\n   inline void\n   Vterm::jumpToNextTabStop ()\n   {\n      if (tabStops.empty ())\n      {\n         // Hard default of 8 chars limited to right margin\n         auto margin = isCursorInsideMargins () ? hMargin : 0;\n         do\n         {\n            posX = ((posX / 8) + 1) * 8;\n         } while (posX < margin);\n         posX = std::min ((int)posX, nColsEff - 1);\n      }\n      else\n      {\n         // Next tabstop column set, or the right margin\n         auto ts = std::lower_bound (tabStops.begin (), tabStops.end (), posX);\n         posX = (ts == tabStops.end ()) ? nCols - 1 : * ts;\n      }\n      lastCol = false;\n   }\n\n   inline void\n   Vterm::inp_HT ()\n   {\n      TRACE_FUN;\n      if (posX < nColsEff - 1)\n         jumpToNextTabStop ();\n   }\n\n   inline void\n   Vterm::showCursor ()\n   {\n      TRACE_FUN;\n      if (showCursorMode && inputState == InputState::Normal)\n      {\n         cf->setCursorPos (posY, posX);\n         using CS = CharVdev::Cursor::Style;\n         cf->setCursorStyle (hasFocus ? CS::filled_block : CS::hollow_block);\n      }\n   }\n\n   inline void\n   Vterm::hideCursor ()\n   {\n      TRACE_FUN;\n      using CS = CharVdev::Cursor::Style;\n      cf->setCursorStyle (CS::hidden);\n   }\n\n   inline void\n   Vterm::esc_DCS (unsigned char fin)\n   {\n      TRACE_FUN;\n\n   #ifdef DEBUG\n      logT << \"Designate Character Set: destination '\" << scsDst\n           <<\"', charset '\";\n      if (scsMod)\n      {\n         vlog << scsMod;\n      }\n      vlog << fin << \"'\" << std::endl;\n   #endif\n\n      uint8_t ix = 0;\n      bool cs96 = false;\n      switch (scsDst)\n      {\n      case '(': ix = 0; break;\n      case ')': ix = 1; break;\n      case '*': ix = 2; break;\n      case '+': ix = 3; break;\n      case '-': ix = 1; cs96 = true; break;\n      case '.': ix = 2; cs96 = true; break;\n      case '/': ix = 3; cs96 = true; break;\n      }\n\n      Charset cs = Charset::UTF8;\n      switch (fin)\n      {\n      case 'A': cs = cs96 ? Charset::IsoLatin1 : Charset::IsoUK; break;\n      case 'B': cs = Charset::UTF8; break;\n      case '0': cs = Charset::DecSpec; break;\n      case '5':\n         if (scsMod == '%')\n            cs = Charset::DecSuppl;\n         break;\n      case '<': cs = Charset::DecUserPref; break;\n      case '>': cs = Charset::DecTechn; break;\n      }\n\n      charsetState.g [ix] = cs;\n      setState (InputState::Normal);\n   }\n\n   inline bool\n   Vterm::esc_IND ()\n   {\n      TRACE_FUN;\n      bool scrolled = false;\n      if (posY == marginBottom - 1)\n      {\n         nInputOps = 1;\n         inputOps [0] = 1;\n         csi_SU ();\n         scrolled = true;\n      }\n      else if (posY < nRows - 1)\n      {\n         ++posY;\n         lastCol = false;\n      }\n      setState (InputState::Normal);\n      return scrolled;\n   }\n\n   inline void\n   Vterm::esc_RI ()\n   {\n      TRACE_FUN;\n      if (posY == marginTop)\n      {\n         nInputOps = 1;\n         inputOps [0] = 1;\n         csi_SD ();\n      }\n      else if (posY > 0)\n      {\n         --posY;\n         lastCol = false;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_ecma48_SL ()\n   {\n      TRACE_FUN;\n      int arg = inputOps [0] ? inputOps [0] : 1u;\n      arg = std::min (arg, nColsEff - hMargin);\n      deleteCols (hMargin, arg);\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_ecma48_SR ()\n   {\n      TRACE_FUN;\n      int arg = inputOps [0] ? inputOps [0] : 1u;\n      arg = std::min (arg, nColsEff - hMargin);\n      insertCols (hMargin, arg);\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_DECIC ()\n   {\n      TRACE_FUN;\n      int arg = inputOps [0] ? inputOps [0] : 1u;\n      if (isCursorInsideMargins ())\n      {\n         arg = std::min (arg, nColsEff - posX);\n         insertCols (posX, arg);\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_DECDC ()\n   {\n      TRACE_FUN;\n      int arg = inputOps [0] ? inputOps [0] : 1u;\n      if (isCursorInsideMargins ())\n      {\n         arg = std::min (arg, nColsEff - posX);\n         deleteCols (posX, arg);\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esc_FI ()\n   {\n      TRACE_FUN;\n      nInputOps = 1;\n      inputOps [0] = 1;\n      if (posX < nColsEff - 1)\n         csi_CUF ();\n      else\n         csi_ecma48_SL ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esc_BI ()\n   {\n      TRACE_FUN;\n      nInputOps = 1;\n      inputOps [0] = 1;\n      if (posX > hMargin)\n         csi_CUB ();\n      else\n         csi_ecma48_SR ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esc_NEL ()\n   {\n      TRACE_FUN;\n      esc_IND ();\n      inp_CR ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esc_HTS ()\n   {\n      TRACE_FUN;\n      tabStops.push_back (posX);\n      std::sort (tabStops.begin (), tabStops.end ());\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_SCOSC_SLRM ()\n   {\n      if (horizMarginMode)\n         csi_SLRM ();\n      else\n         csi_SCOSC ();\n   }\n\n   inline void\n   Vterm::csi_SCOSC ()\n   {\n      TRACE_FUN;\n      savedCursor_SCO.posX = posX;\n      savedCursor_SCO.posY = posY;\n      savedCursor_SCO.isSet = true;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_SCORC ()\n   {\n      TRACE_FUN;\n      if (!savedCursor_SCO.isSet)\n      {\n         logI << \"Asked to restore cursor (SCORC) but it has not been saved.\"\n              << std::endl;\n      }\n      else\n      {\n         posX = savedCursor_SCO.posX;\n         posY = savedCursor_SCO.posY;\n         normalizeCursorPos ();\n         savedCursor_SCO.isSet = false;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esc_DECSC ()\n   {\n      TRACE_FUN;\n      savedCursor_DEC->posX = posX;\n      savedCursor_DEC->posY = posY;\n      savedCursor_DEC->lastCol = lastCol;\n      savedCursor_DEC->attrs = attrs;\n      savedCursor_DEC->originMode = originMode;\n      savedCursor_DEC->charsetState = charsetState;\n      savedCursor_DEC->isSet = true;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esc_DECRC ()\n   {\n      TRACE_FUN;\n      if (!savedCursor_DEC->isSet)\n      {\n         logI << \"Asked to restore cursor (DECRC) but it has not been saved.\"\n              << std::endl;\n      }\n      else\n      {\n         posX = savedCursor_DEC->posX;\n         posY = savedCursor_DEC->posY;\n         normalizeCursorPos ();\n         lastCol = savedCursor_DEC->lastCol;\n         attrs = savedCursor_DEC->attrs;\n         originMode = savedCursor_DEC->originMode;\n         charsetState = savedCursor_DEC->charsetState;\n         savedCursor_DEC->isSet = false;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CUU ()\n   {\n      TRACE_FUN;\n      uint16_t arg = inputOps [0] ? inputOps [0] : 1;\n      if (posY >= marginTop)\n         arg = std::min ((int)arg, posY - marginTop);\n      else\n         arg = std::min (arg, posY);\n      posY -= arg;\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CUD ()\n   {\n      TRACE_FUN;\n      int arg = inputOps [0] ? inputOps [0] : 1;\n      if (posY < marginBottom)\n         arg = std::min (arg, marginBottom - posY - 1);\n      else\n         arg = std::min (arg, nRows - posY - 1);\n      posY += arg;\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CUF ()\n   {\n      TRACE_FUN;\n      int arg = inputOps [0] ? inputOps [0] : 1;\n      arg = std::min (arg, nColsEff - posX - 1);\n      posX += arg;\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CUB ()\n   {\n      TRACE_FUN;\n      int arg = inputOps [0] ? inputOps [0] : 1;\n      if (posX >= hMargin)\n         arg = std::min (arg, posX - hMargin);\n      else\n         arg = std::min (arg, (int)posX);\n      if (posX == nColsEff)\n         arg = std::min (arg + 1, (int)posX);\n      posX -= arg;\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CNL ()\n   {\n      TRACE_FUN;\n      csi_CUD ();\n      inp_CR ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CPL ()\n   {\n      TRACE_FUN;\n      csi_CUU ();\n      inp_CR ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CHA ()\n   {\n      TRACE_FUN;\n      uint16_t col = inputOps [0] ? inputOps [0] : 1;\n      col = std::max ((uint16_t)1, std::min (col, nCols));\n      posX = col - 1;\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_HPA ()\n   {\n      TRACE_FUN;\n      csi_CHA ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_HPR ()\n   {\n      TRACE_FUN;\n      uint16_t arg = inputOps [0] ? inputOps [0] : 1;\n      inputOps [0] = posX + arg + 1;\n      csi_CHA ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_VPA ()\n   {\n      TRACE_FUN;\n      uint16_t row = inputOps [0] ? inputOps [0] : 1;\n      row = std::max ((uint16_t)1, std::min (row, nRows));\n      posY = row - 1;\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_VPR ()\n   {\n      TRACE_FUN;\n      uint16_t row = inputOps [0] ? inputOps [0] : 1;\n      row += (posY + 1);\n      row = std::max ((uint16_t)1, std::min (row, nRows));\n      posY = row - 1;\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CUP ()\n   {\n      TRACE_FUN;\n      uint16_t row = inputOps [0] ? inputOps [0] : 1;\n      uint16_t col = (nInputOps > 1 && inputOps [1]) ? inputOps [1] : 1;\n      switch (originMode)\n      {\n      case OriginMode::Absolute:\n         row = std::max ((uint16_t)1, std::min (row, nRows)) - 1;\n         break;\n      case OriginMode::ScrollingRegion:\n         row = std::max ((uint16_t)1, std::min (row, marginBottom)) - 1;\n         row += marginTop;\n         break;\n      }\n      col = std::max ((uint16_t)1, std::min (col, nCols)) - 1;\n\n      posX = col;\n      posY = row;\n      lastCol = false;\n      setState (InputState::Normal);\n      logT << \"Cursor positioned to (\" << posY << \",\" << posX << \")\"\n           << std::endl;\n   }\n\n   inline void\n   Vterm::csi_SU ()\n   {\n      TRACE_FUN;\n      uint16_t arg = inputOps [0] ? inputOps [0] : 1;\n      if (horizMarginMode)\n      {\n         arg = std::min ((int)arg, marginBottom - marginTop);\n         deleteRows (marginTop, arg);\n      }\n      else\n      {\n         cf->scrollUp (arg);\n         eraseRows (marginBottom - arg, arg);\n         lastCol = false;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_SD ()\n   {\n      TRACE_FUN;\n      uint16_t arg = inputOps [0] ? inputOps [0] : 1;\n      if (horizMarginMode)\n      {\n         arg = std::min ((int)arg, marginBottom - marginTop);\n         insertRows (marginTop, arg);\n      }\n      else\n      {\n         cf->scrollDown (arg);\n         eraseRows (marginTop, arg);\n         lastCol = false;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CHT ()\n   {\n      TRACE_FUN;\n      uint16_t arg = inputOps [0] ? inputOps [0] : 1;\n      if (arg == 1)\n         inp_HT ();\n      else\n         for (int k = 0; k < arg; ++k)\n            jumpToNextTabStop ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CBT ()\n   {\n      TRACE_FUN;\n      uint16_t arg = inputOps [0] ? inputOps [0] : 1;\n      for (uint16_t k = 0; k < arg; ++k)\n      {\n         if (tabStops.empty ())\n         {\n            if (posX > 0 && posX % 8 == 0)\n               posX -= 8;\n            else\n               posX = (posX / 8) * 8;\n         }\n         else\n         {\n            // Set posX to previous tab stop\n            auto ts = std::lower_bound (tabStops.begin (), tabStops.end (), posX);\n            if (ts != tabStops.begin ())\n               posX = * (--ts);\n            else\n               posX = 0;\n         }\n         lastCol = false;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_REP ()\n   {\n      TRACE_FUN;\n      uint16_t arg = inputOps [0] ? inputOps [0] : 1;\n      for (int k = 0; k < arg; ++k)\n         placeGraphicChar ();\n      utf8dec.setUnicode (' ');\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_ED ()\n   {\n      TRACE_FUN;\n      normalizeCursorPos ();\n      switch (inputOps [0])\n      {\n      case 0: // clear from cursor to end of screen\n         cf->eraseInRow (posY, posX, nCols - posX, attrs);\n         for (uint16_t pY = posY + 1; pY < nRows; ++pY)\n            eraseRow (pY);\n         break;\n      case 1: // clear from beginning of screen to cursor\n         for (uint16_t pY = 0; pY < posY; ++pY)\n            eraseRow (pY);\n         cf->eraseInRow (posY, 0, posX + 1, attrs);\n         break;\n      case 3: // clear entire screen including scrollback buffer (xterm)\n         cf->dropScrollbackHistory ();\n         // fallthrough\n      case 2: // clear entire screen\n         for (uint16_t pY = 0; pY < nRows; ++pY)\n            eraseRow (pY);\n         break;\n      default:\n         logI << \"Erase in Display with illegal param: \"\n              << inputOps [0] << std::endl;\n         break;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_EL ()\n   {\n      TRACE_FUN;\n      normalizeCursorPos ();\n      switch (inputOps [0])\n      {\n      case 0: // clear from cursor to end of line\n         cf->eraseInRow (posY, posX, nCols - posX, attrs);\n         break;\n      case 1: // clear from cursor to beginning of line\n         cf->eraseInRow (posY, 0, posX + 1, attrs);\n         break;\n      case 2: // clear entire line\n         cf->eraseInRow (posY, 0, nCols, attrs);\n         break;\n      default:\n         logI << \"Erase in Line with illegal param: \"\n              << inputOps [0] << std::endl;\n         break;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_IL ()\n   {\n      TRACE_FUN;\n      if (isCursorInsideMargins ())\n      {\n         int arg = inputOps [0] ? inputOps [0] : 1;\n         arg = std::min (arg, marginBottom - posY);\n         insertRows (posY, arg);\n         inp_CR ();\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_DL ()\n   {\n      TRACE_FUN;\n      if (isCursorInsideMargins ())\n      {\n         int arg = inputOps [0] ? inputOps [0] : 1;\n         arg = std::min (arg, marginBottom - posY);\n         deleteRows (posY, arg);\n         inp_CR ();\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_ICH ()\n   {\n      TRACE_FUN;\n      if (isCursorInsideMargins ())\n      {\n         uint32_t arg = inputOps [0] ? inputOps [0] : 1;\n         uint32_t len = nColsEff - posX;\n         arg = std::min (arg, len);\n         len -= arg;\n\n         if (len > 0 && cf->getCell (posY, posX + arg + len - 1).wrap)\n         {\n            // maintain wrap bit invariance at EOL\n            cf->getCell (posY, posX + arg + len - 1).wrap = 0;\n            cf->getCell (posY, posX + len - 1).wrap = 1;\n         }\n\n         cf->moveInRow (posY, posX + arg, posX, len);\n         cf->eraseInRow (posY, posX, arg, attrs);\n      }\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_DCH ()\n   {\n      TRACE_FUN;\n      if (isCursorInsideMargins ())\n      {\n         uint32_t arg = inputOps [0] ? inputOps [0] : 1;\n         uint32_t len = nColsEff - posX;\n         arg = std::min (arg, len);\n         len -= arg;\n\n         cf->moveInRow (posY, posX, posX + arg, len);\n         cf->eraseInRow (posY, posX + len, arg, attrs);\n      }\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_ECH ()\n   {\n      TRACE_FUN;\n      uint32_t arg = inputOps [0] ? inputOps [0] : 1;\n      uint32_t len = nColsEff - posX;\n      arg = std::min (arg, len);\n      cf->eraseInRow (posY, posX, arg, attrs);\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_STBM ()\n   {\n      TRACE_FUN;\n      if (nInputOps == 1 && inputOps [0] == 0)\n      {\n         if (marginTop != 0 || marginBottom != nRows)\n         {\n            cf->resetMargins (marginTop, marginBottom);\n         }\n      }\n      else if (nInputOps == 2)\n      {\n         uint16_t newMarginTop = inputOps [0] > 0 ? inputOps [0] - 1 : 0;\n         uint16_t newMarginBottom = inputOps [1];\n\n         if (newMarginBottom < newMarginTop + 2 || nRows < newMarginBottom)\n         {\n            logI << \"Illegal arguments to SetTopBottomMargins: top=\"\n                 << inputOps [0] << \", bottom=\" << inputOps [1] << std::endl;\n         }\n         else if (newMarginTop != marginTop || newMarginBottom != marginBottom)\n         {\n            marginTop = newMarginTop;\n            marginBottom = newMarginBottom;\n            if (marginTop == 0 && marginBottom == nRows)\n               cf->resetMargins (marginTop, marginBottom);\n            else\n               cf->setMargins (marginTop, marginBottom);\n         }\n      }\n\n      if (originMode == OriginMode::Absolute)\n      {\n         posX = 0;\n         posY = 0;\n      }\n      else\n      {\n         posX = hMargin;\n         posY = marginTop;\n      }\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_SLRM ()\n   {\n      TRACE_FUN;\n      if (nInputOps == 1 && inputOps [0] == 0)\n      {\n         hMargin = 0;\n         nColsEff = nCols;\n      }\n      else if (nInputOps == 2)\n      {\n         uint16_t newMarginLeft = inputOps [0] > 0 ? inputOps [0] - 1 : 0;\n         uint16_t newMarginRight = inputOps [1];\n\n         if (newMarginRight < newMarginLeft + 2 || nCols < newMarginRight)\n         {\n            logI << \"Illegal arguments to SetLeftRightMargins: left=\"\n                 << inputOps [0] << \", right=\" << inputOps [1] << std::endl;\n         }\n         else if (newMarginLeft != hMargin || newMarginRight != nColsEff)\n         {\n            hMargin = newMarginLeft;\n            nColsEff = newMarginRight;\n         }\n      }\n\n      if (originMode == OriginMode::Absolute)\n      {\n         posX = 0;\n         posY = 0;\n      }\n      else\n      {\n         posX = hMargin;\n         posY = marginTop;\n      }\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_TBC ()\n   {\n      TRACE_FUN;\n      switch (inputOps [0])\n      {\n      case 0:\n      {\n         auto it = std::find (tabStops.begin (), tabStops.end (), posX);\n         if (it != tabStops.end ())\n            tabStops.erase (it);\n      }\n         break;\n      case 3:\n         tabStops.clear ();\n         break;\n      default:\n         break;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_SM ()\n   {\n      TRACE_FUN;\n      for (size_t k = 0; k < nInputOps; ++k)\n      {\n         const auto& arg = inputOps [k];\n\n         switch (arg)\n         {\n         case 2: keyboardLocked = true; break;\n         case 4: insertMode = true; break;\n         case 12: localEcho = false; break;\n         case 20: autoNewlineMode = true; break;\n         default:\n            logW << \"Ignored bogus set mode \" << arg << std::endl;\n            break;\n         }\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_RM ()\n   {\n      TRACE_FUN;\n      for (size_t k = 0; k < nInputOps; ++k)\n      {\n         const auto& arg = inputOps [k];\n\n         switch (arg)\n         {\n         case 2: keyboardLocked = false; break;\n         case 4: insertMode = false; break;\n         case 12: localEcho = true; break;\n         case 20: autoNewlineMode = false; break;\n         default:\n            logW << \"Ignored bogus reset mode \" << arg << std::endl;\n            break;\n         }\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_privSM ()\n   {\n      TRACE_FUN;\n      for (size_t k = 0; k < nInputOps; ++k)\n      {\n         const auto& arg = inputOps [k];\n\n         switch (arg)\n         {\n         case 1: cursorKeyMode = CursorKeyMode::Application; break;\n         case 2:\n            charsetState = CharsetState {};\n            compatLevel = CompatibilityLevel::VT400;\n            break;\n         case 3: switchColMode (ColMode::C132); break;\n         case 4: logT << \"DECSCLM: Set smooth scroll\" << std::endl; break;\n         case 5: logU << \"DECSCNM: Set inverse video mode\" << std::endl; break;\n         case 6: originMode = OriginMode::ScrollingRegion; break;\n         case 7: autoWrapMode = true; break;\n         case 8: logU << \"DECARM: Set auto-repeat mode\" << std::endl; break;\n         case 9: mouseTrk.mode = MouseTrackingMode::X10_Compat; break;\n         case 12: logU << \"Start blinking cursor\" << std::endl; break;\n         case 25: showCursorMode = true; break;\n         case 47: switchScreenBufferMode (true);  break;\n         case 67: bkspSendsDel = false; break;\n         case 69: horizMarginMode = true; hMargin = 0; nColsEff = nCols; break;\n         case 1000: mouseTrk.mode = MouseTrackingMode::VT200; break;\n         case 1001: logU << \"Set VT200 Highlight Mouse mode\" << std::endl; break;\n         case 1002: mouseTrk.mode = MouseTrackingMode::VT200_ButtonEvent; break;\n         case 1003: mouseTrk.mode = MouseTrackingMode::VT200_AnyEvent; break;\n         case 1004: mouseTrk.focusEventMode = true; break;\n         case 1005: mouseTrk.enc = MouseTrackingEnc::UTF8; break;\n         case 1006: mouseTrk.enc = MouseTrackingEnc::SGR; break;\n         case 1007: altScrollMode = true; break;\n         case 1015: mouseTrk.enc = MouseTrackingEnc::URXVT; break;\n         case 1036: case 1039: altSendsEscape = true; break;\n         case 1047: switchScreenBufferMode (true); break;\n         case 1048: esc_DECSC (); break;\n         case 1049: esc_DECSC (); switchScreenBufferMode (true); break;\n         case 2004: bracketedPasteMode = true; break;\n         default:\n            logU << \"set priv mode \" << arg << std::endl;\n            break;\n         }\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_privRM ()\n   {\n      TRACE_FUN;\n      for (size_t k = 0; k < nInputOps; ++k)\n      {\n         const auto& arg = inputOps [k];\n\n         switch (arg)\n         {\n         case 1: cursorKeyMode = CursorKeyMode::ANSI; break;\n         case 2:\n            charsetState = CharsetState {};\n            compatLevel = CompatibilityLevel::VT52;\n            break;\n         case 3: switchColMode (ColMode::C80); break;\n         case 4: logT << \"DECSCLM: Set jump scroll\" << std::endl; break;\n         case 5: logU << \"DECSCNM: Set normal video mode\" << std::endl; break;\n         case 6: originMode = OriginMode::Absolute; break;\n         case 7: autoWrapMode = false; break;\n         case 8: logU << \"DECARM: Reset auto-repeat mode\" << std::endl; break;\n         case 9: case 1000: case 1002: case 1003:\n            mouseTrk.mode = MouseTrackingMode::Disabled; break;\n         case 12: logU << \"Stop blinking cursor\" << std::endl; break;\n         case 25: showCursorMode = false; break;\n         case 47: switchScreenBufferMode (false); break;\n         case 67: bkspSendsDel = true; break;\n         case 69: horizMarginMode = false; hMargin = 0; nColsEff = nCols; break;\n         case 1001: logU << \"Reset VT200 Highlight Mouse mode\" << std::endl; break;\n         case 1004: mouseTrk.focusEventMode = false; break;\n         case 1005: case 1006: case 1015:\n            mouseTrk.enc = MouseTrackingEnc::Default; break;\n         case 1007: altScrollMode = false; break;\n         case 1036: case 1039: altSendsEscape = false; break;\n         case 1047: switchScreenBufferMode (false); break;\n         case 1048: esc_DECRC (); break;\n         case 1049: switchScreenBufferMode (false); esc_DECRC (); break;\n         case 2004: bracketedPasteMode = false; break;\n         default:\n            logU << \"reset priv mode \" << arg << std::endl;\n            break;\n         }\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::setFgFromPalIx ()\n   {\n      if (fgPalIx < 0)\n         *fg = opts.fg;\n      else if (opts.boldColors && attrs.bold && fgPalIx >= 0 && fgPalIx <= 7)\n         *fg = palette256 [fgPalIx + 8];\n      else\n         *fg = palette256 [fgPalIx];\n   }\n\n   inline void\n   Vterm::setBgFromPalIx ()\n   {\n      if (bgPalIx < 0)\n         *bg = opts.bg;\n      else\n         *bg = palette256 [bgPalIx];\n   }\n\n   inline void\n   Vterm::csi_SGR ()\n   {\n      TRACE_FUN;\n      for (size_t k = 0; k < nInputOps; ++k)\n      {\n         const auto& attr = inputOps [k];\n\n         switch (attr)\n         {\n         case 0:\n            attrs.uc_pt = ' ';\n            attrs.bold = 0;\n            attrs.italic = 0;\n            attrs.underline = 0;\n            attrs.inverse = 0;\n            reverseVideo = false;\n            fg = &attrs.fg;\n            bg = &attrs.bg;\n            fgPalIx = defaultFgPalIx;\n            setFgFromPalIx ();\n            bgPalIx = defaultBgPalIx;\n            setBgFromPalIx ();\n            break;\n         case 1: attrs.bold = 1; setFgFromPalIx (); break;\n         case 2: attrs.bold = 0; setFgFromPalIx (); break;\n         case 3: attrs.italic = 1; break;\n         case 4: attrs.underline = 1; break;\n         case 5: /* blink on */ break;\n         case 7:\n            if (!reverseVideo)\n            {\n               fg = &attrs.bg;\n               bg = &attrs.fg;\n               reverseVideo = true;\n               setFgFromPalIx ();\n               setBgFromPalIx ();\n            }\n            break;\n         case 8: logU << \"attr.: concealed\" << std::endl; break;\n         case 10: attrs.bold = 0; attrs.italic = 0; setFgFromPalIx (); break;\n         case 11: attrs.bold = 1; attrs.italic = 0; setFgFromPalIx (); break;\n         case 12: attrs.bold = 0; attrs.italic = 1; setFgFromPalIx (); break;\n         case 13: attrs.bold = 1; attrs.italic = 1; setFgFromPalIx (); break;\n         case 14: case 15: case 16: case 17: case 18: case 19:\n            attrs.bold = 0; attrs.italic = 0; setFgFromPalIx ();\n            break;\n         case 22: attrs.bold = 0; setFgFromPalIx (); break;\n         case 23: attrs.italic = 0; break;\n         case 25: /* blink off */ break;\n         case 24: attrs.underline = 0; break;\n         case 27:\n            if (reverseVideo)\n            {\n               fg = &attrs.fg;\n               bg = &attrs.bg;\n               reverseVideo = false;\n               setFgFromPalIx ();\n               setBgFromPalIx ();\n            }\n            break;\n         case 28: logU << \"attr.: revealed (conceal off)\" << std::endl; break;\n\n         // standard foregrounds (bright if bold)\n         case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:\n            fgPalIx = attr - 30;\n            setFgFromPalIx ();\n            break;\n\n         case 38:\n            if (k >= nInputOps - 1) break;\n            switch (inputOps [++k])\n            {\n            case 5:\n               if (k >= nInputOps - 1) break;\n               fgPalIx = inputOps [++k];\n               setFgFromPalIx ();\n               break;\n            case 2:\n               if (k >= nInputOps - 3) break;\n               (*fg).red   = inputOps [++k];\n               (*fg).green = inputOps [++k];\n               (*fg).blue  = inputOps [++k];\n               break;\n            default:\n               break;\n            }\n            break;\n         case 39: fgPalIx = defaultFgPalIx; setFgFromPalIx (); break;\n\n         // standard backgrounds\n         case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:\n            bgPalIx = attr - 40;\n            setBgFromPalIx ();\n            break;\n\n         case 48:\n            if (k >= nInputOps - 1) break;\n            switch (inputOps [++k])\n            {\n            case 5:\n               if (k >= nInputOps - 1) break;\n               bgPalIx = inputOps [++k];\n               setBgFromPalIx ();\n               break;\n            case 2:\n               if (k >= nInputOps - 3) break;\n               (*bg).red   = inputOps [++k];\n               (*bg).green = inputOps [++k];\n               (*bg).blue  = inputOps [++k];\n               break;\n            default:\n               break;\n            }\n            break;\n         case 49: bgPalIx = defaultBgPalIx; setBgFromPalIx (); break;\n\n         // bright colored foregrounds\n         case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:\n            fgPalIx = attr - 82;\n            setFgFromPalIx ();\n            break;\n\n         // bright colored backgrounds\n         case 100: case 101: case 102: case 103: case 104: case 105: case 106:\n         case 107:\n            bgPalIx = attr - 92;\n            setBgFromPalIx ();\n            break;\n\n         default:\n            logU << \"attribute: \" << attr << std::endl;\n            break;\n         }\n      }\n      setState (InputState::Normal);\n   }\n\n   /* 64 - VT420 family\n    *  1 - 132 columns\n    *  9 - National Replacement Character-sets\n    * 15 - DEC technical set\n    * 21 - horizontal scrolling\n    * 22 - color\n    */\n   #define DEVICE_ID \"64;1;9;15;21;22c\"\n\n   inline void\n   Vterm::csi_priDA ()\n   {\n      TRACE_FUN;\n      writePty (\"\\e[?\" DEVICE_ID);\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_secDA ()\n   {\n      TRACE_FUN;\n      writePty (\"\\e[>64;0;0c\"); // VT520\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_DSR ()\n   {\n      TRACE_FUN;\n      switch (inputOps [0])\n      {\n      case 5:\n         writePty (\"\\e[0n\"); // device OK\n         break;\n      case 6:\n      {\n         std::ostringstream oss;\n         if (originMode == OriginMode::Absolute)\n            oss << \"\\e[\" << (posY + 1) << \";\" << (posX + 1) << \"R\";\n         else\n            oss << \"\\e[\" << (posY - marginTop + 1) << \";\" << (posX + 1) << \"R\";\n         writePty (oss.str ().c_str ());\n      }\n         break;\n      default:\n         break;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esch_DECALN ()\n   {\n      TRACE_FUN;\n\n      // Save current attrs\n      CharVdev::Cell origAttrs = attrs;\n      Color* origFg = &attrs.fg;\n      Color* origBg = &attrs.bg;\n\n      resetAttrs ();\n      fillScreen ('E');\n\n      // Restore attrs\n      fg = origFg;\n      bg = origBg;\n      attrs = origAttrs;\n\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esc_RIS ()\n   {\n      TRACE_FUN;\n      resetTerminal ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_DECSTR ()\n   {\n      TRACE_FUN;\n      resetScreen ();\n      resetAttrs ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::handle_DCS ()\n   {\n      TRACE_FUN;\n      auto arg = std::string ((char*)argBuf.data (), argBuf.size ());\n      if (arg.substr (0, 2) == \"$q\")\n      {\n         dcs_DECRQSS (arg);\n      }\n      else\n      {\n         logU << \"DCS: '\" << arg << \"'\" << std::endl;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::dcs_DECRQSS (const std::string& arg)\n   {\n      TRACE_FUN;\n\n      if (arg == \"$q\\\"p\")\n      {\n         // DECSCL\n         if (compatLevel == CompatibilityLevel::VT400)\n            writePty (\"\\eP1$r\" DEVICE_ID \"\\e\\\\\");\n      }\n      else\n      {\n         std::ostringstream oss;\n         oss << \"\\eP0$r\" << arg.substr (2) << \"\\e\\\\\";\n         writePty (oss.str ().c_str ());\n      }\n   }\n\n   inline void\n   Vterm::handle_OSC ()\n   {\n      TRACE_FUN;\n      auto osc = std::string ((char*)argBuf.data (), argBuf.size ());\n      std::size_t p = osc.find_first_of(\";\");\n      std::string arg;\n      if (p != std::string::npos)\n         arg = osc.substr (p + 1);\n\n      std::stringstream iss (osc);\n      int cmd;\n      iss >> cmd;\n      if (iss.fail () || cmd < 0 || cmd > 120)\n      {\n         logT << \"OSC: malformed command string '\" << osc << \"'\" << std::endl;\n      }\n      else\n      {\n         switch (cmd)\n         {\n         case 4:\n            osc_PaletteQuery (cmd, arg);\n            break;\n         case 10: case 11: case 12: case 17: case 19:\n            osc_DynamicColorQuery (cmd, arg);\n            break;\n\n         // Other cases handed over to external OSC handler:\n         default: onOsc (cmd, arg); break;\n         }\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::osc_PaletteQuery (int cmd, const std::string& arg)\n   {\n      std::size_t p = arg.find_first_of(\";\");\n      if (p == std::string::npos)\n         return; // malformed argument, missing ';'\n      std::string pc = arg.substr (0, p);\n      std::string ps = arg.substr (p + 1);\n\n      if (ps == \"?\")\n      {\n         std::stringstream iss (pc);\n         int paletteIdx;\n         iss >> paletteIdx;\n         if (iss.fail () || paletteIdx < 0 || paletteIdx > 255)\n            return;\n         Color c = palette256 [paletteIdx];\n\n         std::ostringstream oss;\n         oss << \"\\e]\" << cmd << \";\" << paletteIdx << \";\" << c << \"\\e\\\\\";\n         writePty (oss.str ().data (), oss.str ().size ());\n      }\n   }\n\n   inline void\n   Vterm::osc_DynamicColorQuery (int cmd, const std::string& arg)\n   {\n      if (arg == \"?\")\n      {\n         Color c;\n         switch (cmd)\n         {\n         case 10: case 17: c = *fg; break;\n         case 11: case 19: c = *bg; break;\n         case 12: c = cf->getCursor ().color; break;\n         }\n         std::ostringstream oss;\n         oss << \"\\e]\" << cmd << \";\" << c << \"\\e\\\\\";\n         writePty (oss.str ().data (), oss.str ().size ());\n      }\n   }\n\n   inline void\n   Vterm::csiq_DECSCL ()\n   {\n      TRACE_FUN;\n      if (nInputOps > 0)\n      {\n         switch (inputOps [0])\n         {\n         case 61: compatLevel = CompatibilityLevel::VT100; break;\n         case 62: compatLevel = CompatibilityLevel::VT400; break;\n         case 63: compatLevel = CompatibilityLevel::VT400; break;\n         case 64: compatLevel = CompatibilityLevel::VT400; break;\n         case 65: compatLevel = CompatibilityLevel::VT400; break;\n         default:\n            logU << \"DECSCL: compatibility mode \" << inputOps [0] << std::endl;\n            break;\n         }\n      }\n      if (nInputOps > 1)\n      {\n         switch (inputOps [1])\n         {\n         case 0: logT << \"DECSCL: 8-bit controls\" << std::endl; break;\n         case 1: logT << \"DECSCL: 7-bit controls\" << std::endl; break;\n         case 2: logT << \"DECSCL: 8-bit controls\" << std::endl; break;\n         default:\n            logU << \"DECSCL: C1 control transmission mode: \"\n                 << inputOps [1] << std::endl;\n            break;\n         }\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_XTWINOPS ()\n   {\n      TRACE_FUN;\n      // ignore\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_XTMODKEYS ()\n   {\n      TRACE_FUN;\n\n      switch (nInputOps)\n      {\n      case 0:\n         // Reset all options to initial values\n         break;\n      case 1:\n         inputOps [1] = 0;\n         // fall through\n      case 2:\n         switch (inputOps [0])\n         {\n         case 0:\n            if (inputOps [1] != 0)\n            {\n               logU << \"XTMODKEYS: modifyKeyboard = \" << inputOps [1]\n                    << std::endl;\n            }\n            break;\n         case 1:\n            if (inputOps [1] != 2)\n            {\n               logU << \"XTMODKEYS: modifyCursorKeys = \" << inputOps [1]\n                    << std::endl;\n            }\n            break;\n         case 2:\n            if (inputOps [1] != 2)\n            {\n               logU << \"XTMODKEYS: modifyFunctionKeys = \" << inputOps [1]\n                    << std::endl;\n            }\n            break;\n         case 4:\n            if (inputOps [1] <= 2)\n            {\n               modifyOtherKeys = inputOps [1];\n               logT << \"XTMODKEYS: modifyOtherKeys set to \"\n                    << (int)modifyOtherKeys << std::endl;\n            }\n            else\n            {\n               logI << \"XTMODKEYS: illegal argument for modifyOtherKeys: \"\n                    << inputOps [1] << std::endl;\n            }\n            break;\n         }\n      }\n\n      setState (InputState::Normal);\n   }\n\n} // namespace zutty\n"], "fixing_code": ["/* -*- C++ -*-\n * This file is part of Zutty.\n * Copyright (C) 2020 Tom Szilagyi\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * See the file LICENSE for the full license.\n */\n\n#include \"log.h\"\n#include \"pty.h\"\n\n#include <algorithm>\n#include <sstream>\n\n// for the debug/step facility:\n#include <chrono>\n#include <thread>\n#include <sys/types.h>\n#include <signal.h>\n\nnamespace zutty\n{\n#ifdef DEBUG\n\n   inline void\n   Vterm::debugKey ()\n   {\n      switch (debugStep)\n      {\n      case 0: debugStep = 1; break;\n      case 1: debugStep = 10; break;\n      case 10: debugStep = 100; break;\n      case 100: debugStep = 0; break;\n      }\n      debugCnt = debugStep;\n      logT << \"*** DEBUG step=\" << debugStep << std::endl;\n   }\n\n   inline void\n   Vterm::debugBreak ()\n   {\n      if (!debugStep || --debugCnt > 0)\n         return;\n\n      debugCnt = debugStep;\n      logT << \"*** DEBUG STOP (step=\" << debugStep << \"), \"\n           << readPos + 1 - lastStopPos << \" bytes since last:\\n        \"\n           << dumpBuffer (inputBuf + lastStopPos, inputBuf + readPos + 1);\n      lastStopPos = readPos + 1;\n\n      logT << \"Issue 'kill -CONT \" << getpid () << \"' or 'fg' to continue.\"\n           << std::endl;\n\n      redraw ();\n      using namespace std::chrono_literals;\n      std::this_thread::sleep_for (100ms);\n\n      kill (getpid (), SIGSTOP);\n   }\n\n   #define DEBUG_BREAK debugBreak()\n   #define TRACE_FUN                                                      \\\n      do {                                                                \\\n         logT << __FUNCTION__ << \" [\";                                    \\\n      for (size_t k = 0; k < nInputOps; ++k) {                            \\\n         if (k) {                                                         \\\n            vlog << \";\";                                                  \\\n         }                                                                \\\n         vlog << inputOps [k];                                            \\\n      }                                                                   \\\n      vlog << \"] \\t\"                                                      \\\n           << \"p(\" << posY << \",\" << posX << \")  \"                        \\\n           << \"d(\" << nRows << \",\" << nCols << \")  \"                      \\\n           << \"mgn[\" << marginTop << \",\" << marginBottom << \")  \"         \\\n           << \"hmgn:\" << horizMarginMode                                  \\\n           << \" [\" << hMargin << \",\" << nColsEff << \")\"                   \\\n           << std::endl;                                                  \\\n   } while (0)\n#else\n   #define DEBUG_BREAK\n   #define TRACE_FUN\n#endif // DEBUG\n\n   inline void\n   Vterm::unhandledInput (unsigned char ch)\n   {\n      logE << \"Unhandled input char '\" << ch << \"' (\" << (int)ch\n           << \") in state \" << strInputState (inputState)\n           << \". Escape sequence so far: \"\n           << dumpBuffer (inputBuf + lastEscBegin, inputBuf + readPos + 1);\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::traceNormalInput ()\n   {\n   #ifdef DEBUG\n      if (lastNormalBegin < readPos)\n      {\n         auto dumpbufs = dumpBuffer (inputBuf + lastNormalBegin,\n                                     inputBuf + readPos);\n         if (dumpbufs.length ())\n         {\n            logT << \"Inserted: \" << dumpbufs;\n         }\n      }\n      lastNormalBegin = readPos + 1;\n   #endif // DEBUG\n   }\n\n   inline void\n   Vterm::redraw ()\n   {\n      onRefresh (* cf);\n      cf->resetDamage ();\n   }\n\n   inline const MouseTrackingState&\n   Vterm::getMouseTrackingState () const\n   {\n      return mouseTrk;\n   }\n\n   inline void\n   Vterm::setHasFocus (bool hasFocus_)\n   {\n      hasFocus = hasFocus_;\n      showCursor ();\n      redraw ();\n   }\n\n   inline void\n   Vterm::pageUp ()\n   {\n      if (altScrollMode && altScreenBufferMode)\n      {\n         inputOps [0] = 1;\n         nInputOps = 1;\n         for (int k = 0; k < (marginBottom - marginTop) / 2; ++k)\n            writePty (VtKey::Up);\n      }\n      else\n      {\n         cf->pageUp (nRows / 2);\n         redraw ();\n      }\n   }\n\n   inline void\n   Vterm::pageDown ()\n   {\n      if (altScrollMode && altScreenBufferMode)\n      {\n         inputOps [0] = 1;\n         nInputOps = 1;\n         for (int k = 0; k < (marginBottom - marginTop) / 2; ++k)\n            writePty (VtKey::Down);\n      }\n      else\n      {\n         cf->pageDown (nRows / 2);\n         redraw ();\n      }\n   }\n\n   inline void\n   Vterm::mouseWheelUp ()\n   {\n      if (altScrollMode && altScreenBufferMode)\n      {\n         inputOps [0] = 1;\n         nInputOps = 1;\n         writePty (VtKey::Up);\n      }\n      else\n      {\n         cf->pageUp (5);\n         redraw ();\n      }\n   }\n\n   inline void\n   Vterm::mouseWheelDown ()\n   {\n      if (altScrollMode && altScreenBufferMode)\n      {\n         inputOps [0] = 1;\n         nInputOps = 1;\n         writePty (VtKey::Down);\n      }\n      else\n      {\n         cf->pageDown (5);\n         redraw ();\n      }\n   }\n\n   inline void\n   Vterm::resetTerminal ()\n   {\n      resetScreen ();\n      resetAttrs ();\n\n      switchColMode (ColMode::C80);\n\n      cf->dropScrollbackHistory ();\n      cf->resetMargins (marginTop, marginBottom);\n      clearScreen ();\n\n      switchScreenBufferMode (false);\n      altScrollMode = opts.altScrollMode;\n      altSendsEscape = opts.altSendsEscape;\n      modifyOtherKeys = opts.modifyOtherKeys;\n\n      horizMarginMode = false;\n      hMargin = 0;\n      nColsEff = nCols;\n\n      setState (InputState::Normal);\n\n      if (haveOscHandler)\n      {\n         // reset title\n         argBuf.clear ();\n         argBuf.push_back ('0');\n         argBuf.push_back (';');\n         for (const char* p = opts.title; *p != '\\0'; ++p)\n            argBuf.push_back (*p);\n         handle_OSC ();\n      }\n   }\n\n   inline void\n   Vterm::resetScreen ()\n   {\n      showCursorMode = true;\n      autoWrapMode = true;\n      autoNewlineMode = false;\n      keyboardLocked = false;\n      insertMode = false;\n      bkspSendsDel = true;\n      localEcho = false;\n      bracketedPasteMode = false;\n\n      compatLevel = CompatibilityLevel::VT400;\n      cursorKeyMode = CursorKeyMode::ANSI;\n      keypadMode = KeypadMode::Normal;\n      originMode = OriginMode::Absolute;\n      charsetState = CharsetState {};\n\n      savedCursor_SCO.isSet = false;\n      savedCursor_DEC->isSet = false;\n\n      mouseTrk = MouseTrackingState {};\n\n      tabStops.clear ();\n      cf->getSelection ().clear ();\n   }\n\n   inline void\n   Vterm::resetAttrs ()\n   {\n      reverseVideo = false;\n      fg = &attrs.fg;\n      bg = &attrs.bg;\n\n      inputOps [0] = 0;\n      nInputOps = 1;\n      csi_SGR ();\n   }\n\n   inline void\n   Vterm::clearScreen ()\n   {\n      posX = 0;\n      posY = 0;\n      lastCol = false;\n      fillScreen (' ');\n   }\n\n   inline void\n   Vterm::fillScreen (uint16_t ch)\n   {\n      cf->fillCells (ch, attrs);\n   }\n\n   inline void\n   Vterm::switchColMode (ColMode colMode_)\n   {\n      if (colMode == colMode_)\n         return;\n\n      resetScreen ();\n      clearScreen ();\n\n      if (colMode_ == ColMode::C80)\n      {\n         logT << \"DECCOLM: Selected 80 columns per line\" << std::endl;\n      }\n      else\n      {\n         logT << \"DECCOLM: Selected 132 columns per line\" << std::endl;\n      }\n\n      colMode = colMode_;\n   }\n\n   inline void\n   Vterm::switchScreenBufferMode (bool altScreenBufferMode_)\n   {\n      if (altScreenBufferMode == altScreenBufferMode_)\n         return;\n\n      if (altScreenBufferMode_)\n      {\n         frame_alt = Frame (winPx, winPy, nCols, nRows,\n                            marginTop, marginBottom);\n         cf = &frame_alt;\n         cf->expose ();\n\n         savedCursor_DEC = &savedCursor_DEC_alt;\n         altScreenBufferMode = true;\n      }\n      else\n      {\n         frame_pri.resize (winPx, winPy, nCols, nRows,\n                           marginTop, marginBottom);\n         cf = &frame_pri;\n         cf->expose ();\n         frame_alt.freeCells ();\n\n         savedCursor_DEC_alt.isSet = false;\n         savedCursor_DEC = &savedCursor_DEC_pri;\n         altScreenBufferMode = false;\n         cf->getSelection ().clear ();\n      }\n   }\n\n   inline void\n   Vterm::setState (InputState newState)\n   {\n      if (newState == inputState)\n         return;\n\n      if (newState == InputState::Normal)\n      {\n         DEBUG_BREAK;\n         nInputOps = 0;\n         inputOps [0] = 0;\n         lastNormalBegin = readPos + 1;\n      }\n      else if (inputState == InputState::Normal)\n      {\n         traceNormalInput ();\n      }\n\n      inputState = newState;\n   }\n\n   inline bool\n   Vterm::readPty ()\n   {\n      static bool first = true;\n      ssize_t n = read (ptyFd, inputBuf, sizeof (inputBuf));\n      if (n < 0)\n         return true;\n      else if (n == 0)\n         return !first;\n\n      if (first)\n      {\n         // Mitigate the race condition between shell process startup\n         // and first window size configuration happening in parallel:\n         // the signal could get delivered before the shell is ready\n         // for it, and thus get lost.\n         pty_resize (ptyFd, nCols, nRows);\n         first = false;\n      }\n\n      logT << \"pty read: \" << dumpBuffer (inputBuf, inputBuf + n);\n      processInput (inputBuf, n);\n\n      return false;\n   }\n\n   inline void\n   Vterm::normalizeCursorPos ()\n   {\n      if (nColsEff < posX + 1)\n         posX = nColsEff - 1;\n\n      if (nRows < posY + 1)\n         posY = nRows - 1;\n\n      lastCol = false;\n   }\n\n   inline bool\n   Vterm::isCursorInsideMargins ()\n   {\n      return posX >= hMargin && posX < nColsEff &&\n             posY >= marginTop && posY < marginBottom;\n   }\n\n   inline void\n   Vterm::eraseRow (uint16_t pY)\n   {\n      cf->eraseInRow (pY, hMargin, nColsEff - hMargin, attrs);\n   }\n\n   inline void\n   Vterm::eraseRows (uint16_t startY, uint16_t count)\n   {\n      for (uint16_t pY = startY; pY < startY + count; ++pY)\n         eraseRow (pY);\n   }\n\n   inline void\n   Vterm::copyRow (uint16_t dstY, uint16_t srcY)\n   {\n      cf->copyRow (dstY, srcY, hMargin, nColsEff - hMargin);\n   }\n\n   // insert blank rows at and below startY, within the scrolling area\n   inline void\n   Vterm::insertRows (uint16_t startY, uint16_t count)\n   {\n      for (uint16_t pY = marginBottom - count - 1; pY >= startY; --pY)\n      {\n         copyRow (pY + count, pY);\n         if (!pY) break;\n      }\n\n      for (uint16_t pY = startY; pY < startY + count; ++pY)\n         eraseRow (pY);\n   }\n\n   // delete rows at and below startY, within the scrolling area\n   inline void\n   Vterm::deleteRows (uint16_t startY, uint16_t count)\n   {\n      for (uint16_t pY = startY; pY < marginBottom - count; ++pY)\n         copyRow (pY, pY + count);\n\n      for (uint16_t pY = marginBottom - count; pY < marginBottom; ++pY)\n         eraseRow (pY);\n   }\n\n   // insert blank cols at and to the right of startX, within the scrolling area\n   inline void\n   Vterm::insertCols (uint16_t startX, uint16_t count)\n   {\n      for (uint16_t r = marginTop; r < marginBottom; ++r)\n      {\n         cf->moveInRow (r, startX + count, startX, nColsEff - startX - count);\n         cf->eraseInRow (r, startX, count, attrs);\n      }\n   }\n\n   // delete cols at and to the right of startX, within the scrolling area\n   inline void\n   Vterm::deleteCols (uint16_t startX, uint16_t count)\n   {\n      for (uint16_t r = marginTop; r < marginBottom; ++r)\n      {\n         cf->moveInRow (r, startX, startX + count, nColsEff - startX - count);\n         cf->eraseInRow (r, nColsEff - count, count, attrs);\n      }\n   }\n\n   inline void\n   Vterm::inputGraphicChar (unsigned char ch)\n   {\n      if ((ch & 0x80) == 0)\n      {\n         utf8dec.checkPrematureEOS ();\n\n         // GL range\n         Charset cs;\n         if (charsetState.ss)\n         {\n            cs = charsetState.g [charsetState.ss];\n            charsetState.ss = 0;\n         }\n         else\n            cs = charsetState.g [charsetState.gl];\n\n         if (cs == Charset::UTF8)\n            utf8dec.onUnicode (ch < 127 ? ch : 0);\n         else if (ch >= 32 && (cs == Charset::IsoLatin1 || ch < 127))\n            utf8dec.onUnicode (charCodes [(uint8_t)cs] [ch - 32]);\n      }\n      else\n      {\n         // GR range\n         Charset cs = charsetState.g [charsetState.gr];\n         if (cs == Charset::UTF8)\n            utf8dec.pushByte (ch);\n         else if (ch >= 160 && (cs == Charset::IsoLatin1 || ch < 255))\n            utf8dec.onUnicode (charCodes [(uint8_t)cs] [ch - 160]);\n      }\n   }\n\n   inline void\n   Vterm::placeGraphicChar ()\n   {\n      auto pt = utf8dec.getUnicode ();\n      auto w = wcwidth (pt);\n\n      if (!w) // zero-width code\n         return;\n\n      if (pt > 0xffff)\n      {\n         // Code outside the Unicode BMP -- not supported.\n         // Would get truncated anyway; this is safer and more deterministic.\n         pt = Missing_Glyph_Marker;\n      }\n\n      if (w < 0)\n      {\n         // Render codes with no visual representation as a Unicode RC\n         w = 1;\n         pt = Unicode_Replacement_Character;\n      }\n\n      if (autoWrapMode && lastCol)\n      {\n         cf->getCell (posY, posX).wrap = 1;\n         inp_CR ();\n         inp_LF ();\n      }\n\n      if (insertMode)\n      {\n         nInputOps = 1;\n         inputOps [0] = 1;\n         csi_ICH ();\n      }\n\n      auto& c = cf->getCell (posY, posX);\n      c = attrs;\n      c.uc_pt = pt;\n\n      if (w == 2 && posX < nColsEff - 1)\n      {\n         c.dwidth = 1;\n         cf->getCell (posY, ++posX).dwidth_cont = 1;\n      }\n\n      if (posX == nColsEff - 1)\n         lastCol = true;\n      else\n         ++posX;\n   }\n\n   inline void\n   Vterm::inp_LF ()\n   {\n      TRACE_FUN;\n      if (esc_IND ())\n         cf->eraseInRow (posY, posX, nColsEff - posX, attrs);\n   }\n\n   inline void\n   Vterm::inp_CR ()\n   {\n      TRACE_FUN;\n      if (originMode == OriginMode::Absolute && posX < hMargin)\n         posX = 0;\n      else\n         posX = hMargin;\n      lastCol = false;\n   }\n\n   inline void\n   Vterm::jumpToNextTabStop ()\n   {\n      if (tabStops.empty ())\n      {\n         // Hard default of 8 chars limited to right margin\n         auto margin = isCursorInsideMargins () ? hMargin : 0;\n         do\n         {\n            posX = ((posX / 8) + 1) * 8;\n         } while (posX < margin);\n         posX = std::min ((int)posX, nColsEff - 1);\n      }\n      else\n      {\n         // Next tabstop column set, or the right margin\n         auto ts = std::lower_bound (tabStops.begin (), tabStops.end (), posX);\n         posX = (ts == tabStops.end ()) ? nCols - 1 : * ts;\n      }\n      lastCol = false;\n   }\n\n   inline void\n   Vterm::inp_HT ()\n   {\n      TRACE_FUN;\n      if (posX < nColsEff - 1)\n         jumpToNextTabStop ();\n   }\n\n   inline void\n   Vterm::showCursor ()\n   {\n      TRACE_FUN;\n      if (showCursorMode && inputState == InputState::Normal)\n      {\n         cf->setCursorPos (posY, posX);\n         using CS = CharVdev::Cursor::Style;\n         cf->setCursorStyle (hasFocus ? CS::filled_block : CS::hollow_block);\n      }\n   }\n\n   inline void\n   Vterm::hideCursor ()\n   {\n      TRACE_FUN;\n      using CS = CharVdev::Cursor::Style;\n      cf->setCursorStyle (CS::hidden);\n   }\n\n   inline void\n   Vterm::esc_DCS (unsigned char fin)\n   {\n      TRACE_FUN;\n\n   #ifdef DEBUG\n      logT << \"Designate Character Set: destination '\" << scsDst\n           <<\"', charset '\";\n      if (scsMod)\n      {\n         vlog << scsMod;\n      }\n      vlog << fin << \"'\" << std::endl;\n   #endif\n\n      uint8_t ix = 0;\n      bool cs96 = false;\n      switch (scsDst)\n      {\n      case '(': ix = 0; break;\n      case ')': ix = 1; break;\n      case '*': ix = 2; break;\n      case '+': ix = 3; break;\n      case '-': ix = 1; cs96 = true; break;\n      case '.': ix = 2; cs96 = true; break;\n      case '/': ix = 3; cs96 = true; break;\n      }\n\n      Charset cs = Charset::UTF8;\n      switch (fin)\n      {\n      case 'A': cs = cs96 ? Charset::IsoLatin1 : Charset::IsoUK; break;\n      case 'B': cs = Charset::UTF8; break;\n      case '0': cs = Charset::DecSpec; break;\n      case '5':\n         if (scsMod == '%')\n            cs = Charset::DecSuppl;\n         break;\n      case '<': cs = Charset::DecUserPref; break;\n      case '>': cs = Charset::DecTechn; break;\n      }\n\n      charsetState.g [ix] = cs;\n      setState (InputState::Normal);\n   }\n\n   inline bool\n   Vterm::esc_IND ()\n   {\n      TRACE_FUN;\n      bool scrolled = false;\n      if (posY == marginBottom - 1)\n      {\n         nInputOps = 1;\n         inputOps [0] = 1;\n         csi_SU ();\n         scrolled = true;\n      }\n      else if (posY < nRows - 1)\n      {\n         ++posY;\n         lastCol = false;\n      }\n      setState (InputState::Normal);\n      return scrolled;\n   }\n\n   inline void\n   Vterm::esc_RI ()\n   {\n      TRACE_FUN;\n      if (posY == marginTop)\n      {\n         nInputOps = 1;\n         inputOps [0] = 1;\n         csi_SD ();\n      }\n      else if (posY > 0)\n      {\n         --posY;\n         lastCol = false;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_ecma48_SL ()\n   {\n      TRACE_FUN;\n      int arg = inputOps [0] ? inputOps [0] : 1u;\n      arg = std::min (arg, nColsEff - hMargin);\n      deleteCols (hMargin, arg);\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_ecma48_SR ()\n   {\n      TRACE_FUN;\n      int arg = inputOps [0] ? inputOps [0] : 1u;\n      arg = std::min (arg, nColsEff - hMargin);\n      insertCols (hMargin, arg);\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_DECIC ()\n   {\n      TRACE_FUN;\n      int arg = inputOps [0] ? inputOps [0] : 1u;\n      if (isCursorInsideMargins ())\n      {\n         arg = std::min (arg, nColsEff - posX);\n         insertCols (posX, arg);\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_DECDC ()\n   {\n      TRACE_FUN;\n      int arg = inputOps [0] ? inputOps [0] : 1u;\n      if (isCursorInsideMargins ())\n      {\n         arg = std::min (arg, nColsEff - posX);\n         deleteCols (posX, arg);\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esc_FI ()\n   {\n      TRACE_FUN;\n      nInputOps = 1;\n      inputOps [0] = 1;\n      if (posX < nColsEff - 1)\n         csi_CUF ();\n      else\n         csi_ecma48_SL ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esc_BI ()\n   {\n      TRACE_FUN;\n      nInputOps = 1;\n      inputOps [0] = 1;\n      if (posX > hMargin)\n         csi_CUB ();\n      else\n         csi_ecma48_SR ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esc_NEL ()\n   {\n      TRACE_FUN;\n      esc_IND ();\n      inp_CR ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esc_HTS ()\n   {\n      TRACE_FUN;\n      tabStops.push_back (posX);\n      std::sort (tabStops.begin (), tabStops.end ());\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_SCOSC_SLRM ()\n   {\n      if (horizMarginMode)\n         csi_SLRM ();\n      else\n         csi_SCOSC ();\n   }\n\n   inline void\n   Vterm::csi_SCOSC ()\n   {\n      TRACE_FUN;\n      savedCursor_SCO.posX = posX;\n      savedCursor_SCO.posY = posY;\n      savedCursor_SCO.isSet = true;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_SCORC ()\n   {\n      TRACE_FUN;\n      if (!savedCursor_SCO.isSet)\n      {\n         logI << \"Asked to restore cursor (SCORC) but it has not been saved.\"\n              << std::endl;\n      }\n      else\n      {\n         posX = savedCursor_SCO.posX;\n         posY = savedCursor_SCO.posY;\n         normalizeCursorPos ();\n         savedCursor_SCO.isSet = false;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esc_DECSC ()\n   {\n      TRACE_FUN;\n      savedCursor_DEC->posX = posX;\n      savedCursor_DEC->posY = posY;\n      savedCursor_DEC->lastCol = lastCol;\n      savedCursor_DEC->attrs = attrs;\n      savedCursor_DEC->originMode = originMode;\n      savedCursor_DEC->charsetState = charsetState;\n      savedCursor_DEC->isSet = true;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esc_DECRC ()\n   {\n      TRACE_FUN;\n      if (!savedCursor_DEC->isSet)\n      {\n         logI << \"Asked to restore cursor (DECRC) but it has not been saved.\"\n              << std::endl;\n      }\n      else\n      {\n         posX = savedCursor_DEC->posX;\n         posY = savedCursor_DEC->posY;\n         normalizeCursorPos ();\n         lastCol = savedCursor_DEC->lastCol;\n         attrs = savedCursor_DEC->attrs;\n         originMode = savedCursor_DEC->originMode;\n         charsetState = savedCursor_DEC->charsetState;\n         savedCursor_DEC->isSet = false;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CUU ()\n   {\n      TRACE_FUN;\n      uint16_t arg = inputOps [0] ? inputOps [0] : 1;\n      if (posY >= marginTop)\n         arg = std::min ((int)arg, posY - marginTop);\n      else\n         arg = std::min (arg, posY);\n      posY -= arg;\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CUD ()\n   {\n      TRACE_FUN;\n      int arg = inputOps [0] ? inputOps [0] : 1;\n      if (posY < marginBottom)\n         arg = std::min (arg, marginBottom - posY - 1);\n      else\n         arg = std::min (arg, nRows - posY - 1);\n      posY += arg;\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CUF ()\n   {\n      TRACE_FUN;\n      int arg = inputOps [0] ? inputOps [0] : 1;\n      arg = std::min (arg, nColsEff - posX - 1);\n      posX += arg;\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CUB ()\n   {\n      TRACE_FUN;\n      int arg = inputOps [0] ? inputOps [0] : 1;\n      if (posX >= hMargin)\n         arg = std::min (arg, posX - hMargin);\n      else\n         arg = std::min (arg, (int)posX);\n      if (posX == nColsEff)\n         arg = std::min (arg + 1, (int)posX);\n      posX -= arg;\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CNL ()\n   {\n      TRACE_FUN;\n      csi_CUD ();\n      inp_CR ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CPL ()\n   {\n      TRACE_FUN;\n      csi_CUU ();\n      inp_CR ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CHA ()\n   {\n      TRACE_FUN;\n      uint16_t col = inputOps [0] ? inputOps [0] : 1;\n      col = std::max ((uint16_t)1, std::min (col, nCols));\n      posX = col - 1;\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_HPA ()\n   {\n      TRACE_FUN;\n      csi_CHA ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_HPR ()\n   {\n      TRACE_FUN;\n      uint16_t arg = inputOps [0] ? inputOps [0] : 1;\n      inputOps [0] = posX + arg + 1;\n      csi_CHA ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_VPA ()\n   {\n      TRACE_FUN;\n      uint16_t row = inputOps [0] ? inputOps [0] : 1;\n      row = std::max ((uint16_t)1, std::min (row, nRows));\n      posY = row - 1;\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_VPR ()\n   {\n      TRACE_FUN;\n      uint16_t row = inputOps [0] ? inputOps [0] : 1;\n      row += (posY + 1);\n      row = std::max ((uint16_t)1, std::min (row, nRows));\n      posY = row - 1;\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CUP ()\n   {\n      TRACE_FUN;\n      uint16_t row = inputOps [0] ? inputOps [0] : 1;\n      uint16_t col = (nInputOps > 1 && inputOps [1]) ? inputOps [1] : 1;\n      switch (originMode)\n      {\n      case OriginMode::Absolute:\n         row = std::max ((uint16_t)1, std::min (row, nRows)) - 1;\n         break;\n      case OriginMode::ScrollingRegion:\n         row = std::max ((uint16_t)1, std::min (row, marginBottom)) - 1;\n         row += marginTop;\n         break;\n      }\n      col = std::max ((uint16_t)1, std::min (col, nCols)) - 1;\n\n      posX = col;\n      posY = row;\n      lastCol = false;\n      setState (InputState::Normal);\n      logT << \"Cursor positioned to (\" << posY << \",\" << posX << \")\"\n           << std::endl;\n   }\n\n   inline void\n   Vterm::csi_SU ()\n   {\n      TRACE_FUN;\n      uint16_t arg = inputOps [0] ? inputOps [0] : 1;\n      if (horizMarginMode)\n      {\n         arg = std::min ((int)arg, marginBottom - marginTop);\n         deleteRows (marginTop, arg);\n      }\n      else\n      {\n         cf->scrollUp (arg);\n         eraseRows (marginBottom - arg, arg);\n         lastCol = false;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_SD ()\n   {\n      TRACE_FUN;\n      uint16_t arg = inputOps [0] ? inputOps [0] : 1;\n      if (horizMarginMode)\n      {\n         arg = std::min ((int)arg, marginBottom - marginTop);\n         insertRows (marginTop, arg);\n      }\n      else\n      {\n         cf->scrollDown (arg);\n         eraseRows (marginTop, arg);\n         lastCol = false;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CHT ()\n   {\n      TRACE_FUN;\n      uint16_t arg = inputOps [0] ? inputOps [0] : 1;\n      if (arg == 1)\n         inp_HT ();\n      else\n         for (int k = 0; k < arg; ++k)\n            jumpToNextTabStop ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_CBT ()\n   {\n      TRACE_FUN;\n      uint16_t arg = inputOps [0] ? inputOps [0] : 1;\n      for (uint16_t k = 0; k < arg; ++k)\n      {\n         if (tabStops.empty ())\n         {\n            if (posX > 0 && posX % 8 == 0)\n               posX -= 8;\n            else\n               posX = (posX / 8) * 8;\n         }\n         else\n         {\n            // Set posX to previous tab stop\n            auto ts = std::lower_bound (tabStops.begin (), tabStops.end (), posX);\n            if (ts != tabStops.begin ())\n               posX = * (--ts);\n            else\n               posX = 0;\n         }\n         lastCol = false;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_REP ()\n   {\n      TRACE_FUN;\n      uint16_t arg = inputOps [0] ? inputOps [0] : 1;\n      for (int k = 0; k < arg; ++k)\n         placeGraphicChar ();\n      utf8dec.setUnicode (' ');\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_ED ()\n   {\n      TRACE_FUN;\n      normalizeCursorPos ();\n      switch (inputOps [0])\n      {\n      case 0: // clear from cursor to end of screen\n         cf->eraseInRow (posY, posX, nCols - posX, attrs);\n         for (uint16_t pY = posY + 1; pY < nRows; ++pY)\n            eraseRow (pY);\n         break;\n      case 1: // clear from beginning of screen to cursor\n         for (uint16_t pY = 0; pY < posY; ++pY)\n            eraseRow (pY);\n         cf->eraseInRow (posY, 0, posX + 1, attrs);\n         break;\n      case 3: // clear entire screen including scrollback buffer (xterm)\n         cf->dropScrollbackHistory ();\n         // fallthrough\n      case 2: // clear entire screen\n         for (uint16_t pY = 0; pY < nRows; ++pY)\n            eraseRow (pY);\n         break;\n      default:\n         logI << \"Erase in Display with illegal param: \"\n              << inputOps [0] << std::endl;\n         break;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_EL ()\n   {\n      TRACE_FUN;\n      normalizeCursorPos ();\n      switch (inputOps [0])\n      {\n      case 0: // clear from cursor to end of line\n         cf->eraseInRow (posY, posX, nCols - posX, attrs);\n         break;\n      case 1: // clear from cursor to beginning of line\n         cf->eraseInRow (posY, 0, posX + 1, attrs);\n         break;\n      case 2: // clear entire line\n         cf->eraseInRow (posY, 0, nCols, attrs);\n         break;\n      default:\n         logI << \"Erase in Line with illegal param: \"\n              << inputOps [0] << std::endl;\n         break;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_IL ()\n   {\n      TRACE_FUN;\n      if (isCursorInsideMargins ())\n      {\n         int arg = inputOps [0] ? inputOps [0] : 1;\n         arg = std::min (arg, marginBottom - posY);\n         insertRows (posY, arg);\n         inp_CR ();\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_DL ()\n   {\n      TRACE_FUN;\n      if (isCursorInsideMargins ())\n      {\n         int arg = inputOps [0] ? inputOps [0] : 1;\n         arg = std::min (arg, marginBottom - posY);\n         deleteRows (posY, arg);\n         inp_CR ();\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_ICH ()\n   {\n      TRACE_FUN;\n      if (isCursorInsideMargins ())\n      {\n         uint32_t arg = inputOps [0] ? inputOps [0] : 1;\n         uint32_t len = nColsEff - posX;\n         arg = std::min (arg, len);\n         len -= arg;\n\n         if (len > 0 && cf->getCell (posY, posX + arg + len - 1).wrap)\n         {\n            // maintain wrap bit invariance at EOL\n            cf->getCell (posY, posX + arg + len - 1).wrap = 0;\n            cf->getCell (posY, posX + len - 1).wrap = 1;\n         }\n\n         cf->moveInRow (posY, posX + arg, posX, len);\n         cf->eraseInRow (posY, posX, arg, attrs);\n      }\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_DCH ()\n   {\n      TRACE_FUN;\n      if (isCursorInsideMargins ())\n      {\n         uint32_t arg = inputOps [0] ? inputOps [0] : 1;\n         uint32_t len = nColsEff - posX;\n         arg = std::min (arg, len);\n         len -= arg;\n\n         cf->moveInRow (posY, posX, posX + arg, len);\n         cf->eraseInRow (posY, posX + len, arg, attrs);\n      }\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_ECH ()\n   {\n      TRACE_FUN;\n      uint32_t arg = inputOps [0] ? inputOps [0] : 1;\n      uint32_t len = nColsEff - posX;\n      arg = std::min (arg, len);\n      cf->eraseInRow (posY, posX, arg, attrs);\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_STBM ()\n   {\n      TRACE_FUN;\n      if (nInputOps == 1 && inputOps [0] == 0)\n      {\n         if (marginTop != 0 || marginBottom != nRows)\n         {\n            cf->resetMargins (marginTop, marginBottom);\n         }\n      }\n      else if (nInputOps == 2)\n      {\n         uint16_t newMarginTop = inputOps [0] > 0 ? inputOps [0] - 1 : 0;\n         uint16_t newMarginBottom = inputOps [1];\n\n         if (newMarginBottom < newMarginTop + 2 || nRows < newMarginBottom)\n         {\n            logI << \"Illegal arguments to SetTopBottomMargins: top=\"\n                 << inputOps [0] << \", bottom=\" << inputOps [1] << std::endl;\n         }\n         else if (newMarginTop != marginTop || newMarginBottom != marginBottom)\n         {\n            marginTop = newMarginTop;\n            marginBottom = newMarginBottom;\n            if (marginTop == 0 && marginBottom == nRows)\n               cf->resetMargins (marginTop, marginBottom);\n            else\n               cf->setMargins (marginTop, marginBottom);\n         }\n      }\n\n      if (originMode == OriginMode::Absolute)\n      {\n         posX = 0;\n         posY = 0;\n      }\n      else\n      {\n         posX = hMargin;\n         posY = marginTop;\n      }\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_SLRM ()\n   {\n      TRACE_FUN;\n      if (nInputOps == 1 && inputOps [0] == 0)\n      {\n         hMargin = 0;\n         nColsEff = nCols;\n      }\n      else if (nInputOps == 2)\n      {\n         uint16_t newMarginLeft = inputOps [0] > 0 ? inputOps [0] - 1 : 0;\n         uint16_t newMarginRight = inputOps [1];\n\n         if (newMarginRight < newMarginLeft + 2 || nCols < newMarginRight)\n         {\n            logI << \"Illegal arguments to SetLeftRightMargins: left=\"\n                 << inputOps [0] << \", right=\" << inputOps [1] << std::endl;\n         }\n         else if (newMarginLeft != hMargin || newMarginRight != nColsEff)\n         {\n            hMargin = newMarginLeft;\n            nColsEff = newMarginRight;\n         }\n      }\n\n      if (originMode == OriginMode::Absolute)\n      {\n         posX = 0;\n         posY = 0;\n      }\n      else\n      {\n         posX = hMargin;\n         posY = marginTop;\n      }\n      lastCol = false;\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_TBC ()\n   {\n      TRACE_FUN;\n      switch (inputOps [0])\n      {\n      case 0:\n      {\n         auto it = std::find (tabStops.begin (), tabStops.end (), posX);\n         if (it != tabStops.end ())\n            tabStops.erase (it);\n      }\n         break;\n      case 3:\n         tabStops.clear ();\n         break;\n      default:\n         break;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_SM ()\n   {\n      TRACE_FUN;\n      for (size_t k = 0; k < nInputOps; ++k)\n      {\n         const auto& arg = inputOps [k];\n\n         switch (arg)\n         {\n         case 2: keyboardLocked = true; break;\n         case 4: insertMode = true; break;\n         case 12: localEcho = false; break;\n         case 20: autoNewlineMode = true; break;\n         default:\n            logW << \"Ignored bogus set mode \" << arg << std::endl;\n            break;\n         }\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_RM ()\n   {\n      TRACE_FUN;\n      for (size_t k = 0; k < nInputOps; ++k)\n      {\n         const auto& arg = inputOps [k];\n\n         switch (arg)\n         {\n         case 2: keyboardLocked = false; break;\n         case 4: insertMode = false; break;\n         case 12: localEcho = true; break;\n         case 20: autoNewlineMode = false; break;\n         default:\n            logW << \"Ignored bogus reset mode \" << arg << std::endl;\n            break;\n         }\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_privSM ()\n   {\n      TRACE_FUN;\n      for (size_t k = 0; k < nInputOps; ++k)\n      {\n         const auto& arg = inputOps [k];\n\n         switch (arg)\n         {\n         case 1: cursorKeyMode = CursorKeyMode::Application; break;\n         case 2:\n            charsetState = CharsetState {};\n            compatLevel = CompatibilityLevel::VT400;\n            break;\n         case 3: switchColMode (ColMode::C132); break;\n         case 4: logT << \"DECSCLM: Set smooth scroll\" << std::endl; break;\n         case 5: logU << \"DECSCNM: Set inverse video mode\" << std::endl; break;\n         case 6: originMode = OriginMode::ScrollingRegion; break;\n         case 7: autoWrapMode = true; break;\n         case 8: logU << \"DECARM: Set auto-repeat mode\" << std::endl; break;\n         case 9: mouseTrk.mode = MouseTrackingMode::X10_Compat; break;\n         case 12: logU << \"Start blinking cursor\" << std::endl; break;\n         case 25: showCursorMode = true; break;\n         case 47: switchScreenBufferMode (true);  break;\n         case 67: bkspSendsDel = false; break;\n         case 69: horizMarginMode = true; hMargin = 0; nColsEff = nCols; break;\n         case 1000: mouseTrk.mode = MouseTrackingMode::VT200; break;\n         case 1001: logU << \"Set VT200 Highlight Mouse mode\" << std::endl; break;\n         case 1002: mouseTrk.mode = MouseTrackingMode::VT200_ButtonEvent; break;\n         case 1003: mouseTrk.mode = MouseTrackingMode::VT200_AnyEvent; break;\n         case 1004: mouseTrk.focusEventMode = true; break;\n         case 1005: mouseTrk.enc = MouseTrackingEnc::UTF8; break;\n         case 1006: mouseTrk.enc = MouseTrackingEnc::SGR; break;\n         case 1007: altScrollMode = true; break;\n         case 1015: mouseTrk.enc = MouseTrackingEnc::URXVT; break;\n         case 1036: case 1039: altSendsEscape = true; break;\n         case 1047: switchScreenBufferMode (true); break;\n         case 1048: esc_DECSC (); break;\n         case 1049: esc_DECSC (); switchScreenBufferMode (true); break;\n         case 2004: bracketedPasteMode = true; break;\n         default:\n            logU << \"set priv mode \" << arg << std::endl;\n            break;\n         }\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_privRM ()\n   {\n      TRACE_FUN;\n      for (size_t k = 0; k < nInputOps; ++k)\n      {\n         const auto& arg = inputOps [k];\n\n         switch (arg)\n         {\n         case 1: cursorKeyMode = CursorKeyMode::ANSI; break;\n         case 2:\n            charsetState = CharsetState {};\n            compatLevel = CompatibilityLevel::VT52;\n            break;\n         case 3: switchColMode (ColMode::C80); break;\n         case 4: logT << \"DECSCLM: Set jump scroll\" << std::endl; break;\n         case 5: logU << \"DECSCNM: Set normal video mode\" << std::endl; break;\n         case 6: originMode = OriginMode::Absolute; break;\n         case 7: autoWrapMode = false; break;\n         case 8: logU << \"DECARM: Reset auto-repeat mode\" << std::endl; break;\n         case 9: case 1000: case 1002: case 1003:\n            mouseTrk.mode = MouseTrackingMode::Disabled; break;\n         case 12: logU << \"Stop blinking cursor\" << std::endl; break;\n         case 25: showCursorMode = false; break;\n         case 47: switchScreenBufferMode (false); break;\n         case 67: bkspSendsDel = true; break;\n         case 69: horizMarginMode = false; hMargin = 0; nColsEff = nCols; break;\n         case 1001: logU << \"Reset VT200 Highlight Mouse mode\" << std::endl; break;\n         case 1004: mouseTrk.focusEventMode = false; break;\n         case 1005: case 1006: case 1015:\n            mouseTrk.enc = MouseTrackingEnc::Default; break;\n         case 1007: altScrollMode = false; break;\n         case 1036: case 1039: altSendsEscape = false; break;\n         case 1047: switchScreenBufferMode (false); break;\n         case 1048: esc_DECRC (); break;\n         case 1049: switchScreenBufferMode (false); esc_DECRC (); break;\n         case 2004: bracketedPasteMode = false; break;\n         default:\n            logU << \"reset priv mode \" << arg << std::endl;\n            break;\n         }\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::setFgFromPalIx ()\n   {\n      if (fgPalIx < 0)\n         *fg = opts.fg;\n      else if (opts.boldColors && attrs.bold && fgPalIx >= 0 && fgPalIx <= 7)\n         *fg = palette256 [fgPalIx + 8];\n      else\n         *fg = palette256 [fgPalIx];\n   }\n\n   inline void\n   Vterm::setBgFromPalIx ()\n   {\n      if (bgPalIx < 0)\n         *bg = opts.bg;\n      else\n         *bg = palette256 [bgPalIx];\n   }\n\n   inline void\n   Vterm::csi_SGR ()\n   {\n      TRACE_FUN;\n      for (size_t k = 0; k < nInputOps; ++k)\n      {\n         const auto& attr = inputOps [k];\n\n         switch (attr)\n         {\n         case 0:\n            attrs.uc_pt = ' ';\n            attrs.bold = 0;\n            attrs.italic = 0;\n            attrs.underline = 0;\n            attrs.inverse = 0;\n            reverseVideo = false;\n            fg = &attrs.fg;\n            bg = &attrs.bg;\n            fgPalIx = defaultFgPalIx;\n            setFgFromPalIx ();\n            bgPalIx = defaultBgPalIx;\n            setBgFromPalIx ();\n            break;\n         case 1: attrs.bold = 1; setFgFromPalIx (); break;\n         case 2: attrs.bold = 0; setFgFromPalIx (); break;\n         case 3: attrs.italic = 1; break;\n         case 4: attrs.underline = 1; break;\n         case 5: /* blink on */ break;\n         case 7:\n            if (!reverseVideo)\n            {\n               fg = &attrs.bg;\n               bg = &attrs.fg;\n               reverseVideo = true;\n               setFgFromPalIx ();\n               setBgFromPalIx ();\n            }\n            break;\n         case 8: logU << \"attr.: concealed\" << std::endl; break;\n         case 10: attrs.bold = 0; attrs.italic = 0; setFgFromPalIx (); break;\n         case 11: attrs.bold = 1; attrs.italic = 0; setFgFromPalIx (); break;\n         case 12: attrs.bold = 0; attrs.italic = 1; setFgFromPalIx (); break;\n         case 13: attrs.bold = 1; attrs.italic = 1; setFgFromPalIx (); break;\n         case 14: case 15: case 16: case 17: case 18: case 19:\n            attrs.bold = 0; attrs.italic = 0; setFgFromPalIx ();\n            break;\n         case 22: attrs.bold = 0; setFgFromPalIx (); break;\n         case 23: attrs.italic = 0; break;\n         case 25: /* blink off */ break;\n         case 24: attrs.underline = 0; break;\n         case 27:\n            if (reverseVideo)\n            {\n               fg = &attrs.fg;\n               bg = &attrs.bg;\n               reverseVideo = false;\n               setFgFromPalIx ();\n               setBgFromPalIx ();\n            }\n            break;\n         case 28: logU << \"attr.: revealed (conceal off)\" << std::endl; break;\n\n         // standard foregrounds (bright if bold)\n         case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:\n            fgPalIx = attr - 30;\n            setFgFromPalIx ();\n            break;\n\n         case 38:\n            if (k >= nInputOps - 1) break;\n            switch (inputOps [++k])\n            {\n            case 5:\n               if (k >= nInputOps - 1) break;\n               fgPalIx = inputOps [++k];\n               setFgFromPalIx ();\n               break;\n            case 2:\n               if (k >= nInputOps - 3) break;\n               (*fg).red   = inputOps [++k];\n               (*fg).green = inputOps [++k];\n               (*fg).blue  = inputOps [++k];\n               break;\n            default:\n               break;\n            }\n            break;\n         case 39: fgPalIx = defaultFgPalIx; setFgFromPalIx (); break;\n\n         // standard backgrounds\n         case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:\n            bgPalIx = attr - 40;\n            setBgFromPalIx ();\n            break;\n\n         case 48:\n            if (k >= nInputOps - 1) break;\n            switch (inputOps [++k])\n            {\n            case 5:\n               if (k >= nInputOps - 1) break;\n               bgPalIx = inputOps [++k];\n               setBgFromPalIx ();\n               break;\n            case 2:\n               if (k >= nInputOps - 3) break;\n               (*bg).red   = inputOps [++k];\n               (*bg).green = inputOps [++k];\n               (*bg).blue  = inputOps [++k];\n               break;\n            default:\n               break;\n            }\n            break;\n         case 49: bgPalIx = defaultBgPalIx; setBgFromPalIx (); break;\n\n         // bright colored foregrounds\n         case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:\n            fgPalIx = attr - 82;\n            setFgFromPalIx ();\n            break;\n\n         // bright colored backgrounds\n         case 100: case 101: case 102: case 103: case 104: case 105: case 106:\n         case 107:\n            bgPalIx = attr - 92;\n            setBgFromPalIx ();\n            break;\n\n         default:\n            logU << \"attribute: \" << attr << std::endl;\n            break;\n         }\n      }\n      setState (InputState::Normal);\n   }\n\n   /* 64 - VT420 family\n    *  1 - 132 columns\n    *  9 - National Replacement Character-sets\n    * 15 - DEC technical set\n    * 21 - horizontal scrolling\n    * 22 - color\n    */\n   #define DEVICE_ID \"64;1;9;15;21;22c\"\n\n   inline void\n   Vterm::csi_priDA ()\n   {\n      TRACE_FUN;\n      writePty (\"\\e[?\" DEVICE_ID);\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_secDA ()\n   {\n      TRACE_FUN;\n      writePty (\"\\e[>64;0;0c\"); // VT520\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_DSR ()\n   {\n      TRACE_FUN;\n      switch (inputOps [0])\n      {\n      case 5:\n         writePty (\"\\e[0n\"); // device OK\n         break;\n      case 6:\n      {\n         std::ostringstream oss;\n         if (originMode == OriginMode::Absolute)\n            oss << \"\\e[\" << (posY + 1) << \";\" << (posX + 1) << \"R\";\n         else\n            oss << \"\\e[\" << (posY - marginTop + 1) << \";\" << (posX + 1) << \"R\";\n         writePty (oss.str ().c_str ());\n      }\n         break;\n      default:\n         break;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esch_DECALN ()\n   {\n      TRACE_FUN;\n\n      // Save current attrs\n      CharVdev::Cell origAttrs = attrs;\n      Color* origFg = &attrs.fg;\n      Color* origBg = &attrs.bg;\n\n      resetAttrs ();\n      fillScreen ('E');\n\n      // Restore attrs\n      fg = origFg;\n      bg = origBg;\n      attrs = origAttrs;\n\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::esc_RIS ()\n   {\n      TRACE_FUN;\n      resetTerminal ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_DECSTR ()\n   {\n      TRACE_FUN;\n      resetScreen ();\n      resetAttrs ();\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::handle_DCS ()\n   {\n      TRACE_FUN;\n      auto arg = std::string ((char*)argBuf.data (), argBuf.size ());\n      if (arg.substr (0, 2) == \"$q\")\n      {\n         dcs_DECRQSS (arg);\n      }\n      else\n      {\n         logU << \"DCS: '\" << arg << \"'\" << std::endl;\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::dcs_DECRQSS (const std::string& arg)\n   {\n      TRACE_FUN;\n\n      if (arg == \"$q\\\"p\")\n      {\n         // DECSCL\n         if (compatLevel == CompatibilityLevel::VT400)\n            writePty (\"\\eP1$r\" DEVICE_ID \"\\e\\\\\");\n      }\n      else\n      {\n         writePty (\"\\eP0$r\\e\\\\\");\n      }\n   }\n\n   inline void\n   Vterm::handle_OSC ()\n   {\n      TRACE_FUN;\n      auto osc = std::string ((char*)argBuf.data (), argBuf.size ());\n      std::size_t p = osc.find_first_of(\";\");\n      std::string arg;\n      if (p != std::string::npos)\n         arg = osc.substr (p + 1);\n\n      std::stringstream iss (osc);\n      int cmd;\n      iss >> cmd;\n      if (iss.fail () || cmd < 0 || cmd > 120)\n      {\n         logT << \"OSC: malformed command string '\" << osc << \"'\" << std::endl;\n      }\n      else\n      {\n         switch (cmd)\n         {\n         case 4:\n            osc_PaletteQuery (cmd, arg);\n            break;\n         case 10: case 11: case 12: case 17: case 19:\n            osc_DynamicColorQuery (cmd, arg);\n            break;\n\n         // Other cases handed over to external OSC handler:\n         default: onOsc (cmd, arg); break;\n         }\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::osc_PaletteQuery (int cmd, const std::string& arg)\n   {\n      std::size_t p = arg.find_first_of(\";\");\n      if (p == std::string::npos)\n         return; // malformed argument, missing ';'\n      std::string pc = arg.substr (0, p);\n      std::string ps = arg.substr (p + 1);\n\n      if (ps == \"?\")\n      {\n         std::stringstream iss (pc);\n         int paletteIdx;\n         iss >> paletteIdx;\n         if (iss.fail () || paletteIdx < 0 || paletteIdx > 255)\n            return;\n         Color c = palette256 [paletteIdx];\n\n         std::ostringstream oss;\n         oss << \"\\e]\" << cmd << \";\" << paletteIdx << \";\" << c << \"\\e\\\\\";\n         writePty (oss.str ().data (), oss.str ().size ());\n      }\n   }\n\n   inline void\n   Vterm::osc_DynamicColorQuery (int cmd, const std::string& arg)\n   {\n      if (arg == \"?\")\n      {\n         Color c;\n         switch (cmd)\n         {\n         case 10: case 17: c = *fg; break;\n         case 11: case 19: c = *bg; break;\n         case 12: c = cf->getCursor ().color; break;\n         }\n         std::ostringstream oss;\n         oss << \"\\e]\" << cmd << \";\" << c << \"\\e\\\\\";\n         writePty (oss.str ().data (), oss.str ().size ());\n      }\n   }\n\n   inline void\n   Vterm::csiq_DECSCL ()\n   {\n      TRACE_FUN;\n      if (nInputOps > 0)\n      {\n         switch (inputOps [0])\n         {\n         case 61: compatLevel = CompatibilityLevel::VT100; break;\n         case 62: compatLevel = CompatibilityLevel::VT400; break;\n         case 63: compatLevel = CompatibilityLevel::VT400; break;\n         case 64: compatLevel = CompatibilityLevel::VT400; break;\n         case 65: compatLevel = CompatibilityLevel::VT400; break;\n         default:\n            logU << \"DECSCL: compatibility mode \" << inputOps [0] << std::endl;\n            break;\n         }\n      }\n      if (nInputOps > 1)\n      {\n         switch (inputOps [1])\n         {\n         case 0: logT << \"DECSCL: 8-bit controls\" << std::endl; break;\n         case 1: logT << \"DECSCL: 7-bit controls\" << std::endl; break;\n         case 2: logT << \"DECSCL: 8-bit controls\" << std::endl; break;\n         default:\n            logU << \"DECSCL: C1 control transmission mode: \"\n                 << inputOps [1] << std::endl;\n            break;\n         }\n      }\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_XTWINOPS ()\n   {\n      TRACE_FUN;\n      // ignore\n      setState (InputState::Normal);\n   }\n\n   inline void\n   Vterm::csi_XTMODKEYS ()\n   {\n      TRACE_FUN;\n\n      switch (nInputOps)\n      {\n      case 0:\n         // Reset all options to initial values\n         break;\n      case 1:\n         inputOps [1] = 0;\n         // fall through\n      case 2:\n         switch (inputOps [0])\n         {\n         case 0:\n            if (inputOps [1] != 0)\n            {\n               logU << \"XTMODKEYS: modifyKeyboard = \" << inputOps [1]\n                    << std::endl;\n            }\n            break;\n         case 1:\n            if (inputOps [1] != 2)\n            {\n               logU << \"XTMODKEYS: modifyCursorKeys = \" << inputOps [1]\n                    << std::endl;\n            }\n            break;\n         case 2:\n            if (inputOps [1] != 2)\n            {\n               logU << \"XTMODKEYS: modifyFunctionKeys = \" << inputOps [1]\n                    << std::endl;\n            }\n            break;\n         case 4:\n            if (inputOps [1] <= 2)\n            {\n               modifyOtherKeys = inputOps [1];\n               logT << \"XTMODKEYS: modifyOtherKeys set to \"\n                    << (int)modifyOtherKeys << std::endl;\n            }\n            else\n            {\n               logI << \"XTMODKEYS: illegal argument for modifyOtherKeys: \"\n                    << inputOps [1] << std::endl;\n            }\n            break;\n         }\n      }\n\n      setState (InputState::Normal);\n   }\n\n} // namespace zutty\n"], "filenames": ["src/vterm.icc"], "buggy_code_start_loc": [1782], "buggy_code_end_loc": [1785], "fixing_code_start_loc": [1782], "fixing_code_end_loc": [1783], "type": "NVD-CWE-noinfo", "message": "In Zutty before 0.13, DECRQSS in text written to the terminal can achieve arbitrary code execution.", "other": {"cve": {"id": "CVE-2022-41138", "sourceIdentifier": "cve@mitre.org", "published": "2022-09-20T18:15:10.690", "lastModified": "2022-10-07T13:20:24.543", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Zutty before 0.13, DECRQSS in text written to the terminal can achieve arbitrary code execution."}, {"lang": "es", "value": "En Zutty versiones anteriores a 0.13, DECRQSS en el texto escrito en el terminal puede lograr una ejecuci\u00f3n de c\u00f3digo arbitrario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zutty_project:zutty:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.13", "matchCriteriaId": "B1CDF4C3-EB5C-4DC3-B4DC-64463CF27AD7"}]}]}], "references": [{"url": "https://bugs.gentoo.org/868495", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/tomszilagyi/zutty/commit/bde7458c60a7bafe08bbeaafbf861eb865edfa38", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tomszilagyi/zutty/compare/0.12...0.13", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202209-25", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tomszilagyi/zutty/commit/bde7458c60a7bafe08bbeaafbf861eb865edfa38"}}