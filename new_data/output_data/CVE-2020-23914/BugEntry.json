{"buggy_code": ["\ufeff//\n//  peglib.h\n//\n//  Copyright (c) 2020 Yuji Hirose. All rights reserved.\n//  MIT License\n//\n\n#ifndef CPPPEGLIB_PEGLIB_H\n#define CPPPEGLIB_PEGLIB_H\n\n#ifndef PEGLIB_USE_STD_ANY\n#ifdef _MSVC_LANG\n#define PEGLIB_USE_STD_ANY _MSVC_LANG >= 201703L\n#elif defined(__cplusplus)\n#define PEGLIB_USE_STD_ANY __cplusplus >= 201703L\n#endif\n#endif // PEGLIB_USE_STD_ANY\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cstring>\n#include <functional>\n#include <initializer_list>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <mutex>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#if PEGLIB_USE_STD_ANY\n#include <any>\n#endif\n\n// guard for older versions of VC++\n#ifdef _MSC_VER\n#if defined(_MSC_VER) && _MSC_VER < 1900 // Less than Visual Studio 2015\n#error \"Requires complete C+11 support\"\n#endif\n#endif\n\nnamespace peg {\n\n/*-----------------------------------------------------------------------------\n *  any\n *---------------------------------------------------------------------------*/\n\n#if PEGLIB_USE_STD_ANY\nusing any = std::any;\n\n// Define a function alias to std::any_cast using perfect forwarding\ntemplate <typename T, typename... Args>\nauto any_cast(Args &&... args)\n    -> decltype(std::any_cast<T>(std::forward<Args>(args)...)) {\n  return std::any_cast<T>(std::forward<Args>(args)...);\n}\n#else\nclass any {\npublic:\n  any() = default;\n\n  any(const any &rhs) : content_(rhs.clone()) {}\n\n  any(any &&rhs) : content_(rhs.content_) { rhs.content_ = nullptr; }\n\n  template <typename T> any(const T &value) : content_(new holder<T>(value)) {}\n\n  any &operator=(const any &rhs) {\n    if (this != &rhs) {\n      if (content_) { delete content_; }\n      content_ = rhs.clone();\n    }\n    return *this;\n  }\n\n  any &operator=(any &&rhs) {\n    if (this != &rhs) {\n      if (content_) { delete content_; }\n      content_ = rhs.content_;\n      rhs.content_ = nullptr;\n    }\n    return *this;\n  }\n\n  ~any() { delete content_; }\n\n  bool has_value() const { return content_ != nullptr; }\n\n  template <typename T> friend T &any_cast(any &val);\n\n  template <typename T> friend const T &any_cast(const any &val);\n\nprivate:\n  struct placeholder {\n    virtual ~placeholder() {}\n    virtual placeholder *clone() const = 0;\n  };\n\n  template <typename T> struct holder : placeholder {\n    holder(const T &value) : value_(value) {}\n    placeholder *clone() const override { return new holder(value_); }\n    T value_;\n  };\n\n  placeholder *clone() const { return content_ ? content_->clone() : nullptr; }\n\n  placeholder *content_ = nullptr;\n};\n\ntemplate <typename T> T &any_cast(any &val) {\n  if (!val.content_) { throw std::bad_cast(); }\n  auto p = dynamic_cast<any::holder<T> *>(val.content_);\n  assert(p);\n  if (!p) { throw std::bad_cast(); }\n  return p->value_;\n}\n\ntemplate <> inline any &any_cast<any>(any &val) { return val; }\n\ntemplate <typename T> const T &any_cast(const any &val) {\n  assert(val.content_);\n  auto p = dynamic_cast<any::holder<T> *>(val.content_);\n  assert(p);\n  if (!p) { throw std::bad_cast(); }\n  return p->value_;\n}\n\ntemplate <> inline const any &any_cast<any>(const any &val) { return val; }\n#endif\n\n/*-----------------------------------------------------------------------------\n *  scope_exit\n *---------------------------------------------------------------------------*/\n\n// This is based on\n// \"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4189\".\n\ntemplate <typename EF> struct scope_exit {\n  explicit scope_exit(EF &&f)\n      : exit_function(std::move(f)), execute_on_destruction{true} {}\n\n  scope_exit(scope_exit &&rhs)\n      : exit_function(std::move(rhs.exit_function)),\n        execute_on_destruction{rhs.execute_on_destruction} {\n    rhs.release();\n  }\n\n  ~scope_exit() {\n    if (execute_on_destruction) { this->exit_function(); }\n  }\n\n  void release() { this->execute_on_destruction = false; }\n\nprivate:\n  scope_exit(const scope_exit &) = delete;\n  void operator=(const scope_exit &) = delete;\n  scope_exit &operator=(scope_exit &&) = delete;\n\n  EF exit_function;\n  bool execute_on_destruction;\n};\n\ntemplate <typename EF>\nauto make_scope_exit(EF &&exit_function) -> scope_exit<EF> {\n  return scope_exit<typename std::remove_reference<EF>::type>(\n      std::forward<EF>(exit_function));\n}\n\n/*-----------------------------------------------------------------------------\n *  UTF8 functions\n *---------------------------------------------------------------------------*/\n\ninline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}\n\ninline size_t encode_codepoint(char32_t cp, char *buff) {\n  if (cp < 0x0080) {\n    buff[0] = static_cast<char>(cp & 0x7F);\n    return 1;\n  } else if (cp < 0x0800) {\n    buff[0] = static_cast<char>(0xC0 | ((cp >> 6) & 0x1F));\n    buff[1] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 2;\n  } else if (cp < 0xD800) {\n    buff[0] = static_cast<char>(0xE0 | ((cp >> 12) & 0xF));\n    buff[1] = static_cast<char>(0x80 | ((cp >> 6) & 0x3F));\n    buff[2] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 3;\n  } else if (cp < 0xE000) {\n    // D800 - DFFF is invalid...\n    return 0;\n  } else if (cp < 0x10000) {\n    buff[0] = static_cast<char>(0xE0 | ((cp >> 12) & 0xF));\n    buff[1] = static_cast<char>(0x80 | ((cp >> 6) & 0x3F));\n    buff[2] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 3;\n  } else if (cp < 0x110000) {\n    buff[0] = static_cast<char>(0xF0 | ((cp >> 18) & 0x7));\n    buff[1] = static_cast<char>(0x80 | ((cp >> 12) & 0x3F));\n    buff[2] = static_cast<char>(0x80 | ((cp >> 6) & 0x3F));\n    buff[3] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 4;\n  }\n  return 0;\n}\n\ninline std::string encode_codepoint(char32_t cp) {\n  char buff[4];\n  auto l = encode_codepoint(cp, buff);\n  return std::string(buff, l);\n}\n\ninline bool decode_codepoint(const char *s8, size_t l, size_t &bytes,\n                             char32_t &cp) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      bytes = 1;\n      cp = b;\n      return true;\n    } else if ((b & 0xE0) == 0xC0) {\n      if (l >= 2) {\n        bytes = 2;\n        cp = ((static_cast<char32_t>(s8[0] & 0x1F)) << 6) |\n             (static_cast<char32_t>(s8[1] & 0x3F));\n        return true;\n      }\n    } else if ((b & 0xF0) == 0xE0) {\n      if (l >= 3) {\n        bytes = 3;\n        cp = ((static_cast<char32_t>(s8[0] & 0x0F)) << 12) |\n             ((static_cast<char32_t>(s8[1] & 0x3F)) << 6) |\n             (static_cast<char32_t>(s8[2] & 0x3F));\n        return true;\n      }\n    } else if ((b & 0xF8) == 0xF0) {\n      if (l >= 4) {\n        bytes = 4;\n        cp = ((static_cast<char32_t>(s8[0] & 0x07)) << 18) |\n             ((static_cast<char32_t>(s8[1] & 0x3F)) << 12) |\n             ((static_cast<char32_t>(s8[2] & 0x3F)) << 6) |\n             (static_cast<char32_t>(s8[3] & 0x3F));\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\ninline size_t decode_codepoint(const char *s8, size_t l, char32_t &out) {\n  size_t bytes;\n  if (decode_codepoint(s8, l, bytes, out)) { return bytes; }\n  return 0;\n}\n\ninline char32_t decode_codepoint(const char *s8, size_t l) {\n  char32_t out = 0;\n  decode_codepoint(s8, l, out);\n  return out;\n}\n\ninline std::u32string decode(const char *s8, size_t l) {\n  std::u32string out;\n  size_t i = 0;\n  while (i < l) {\n    auto beg = i++;\n    while (i < l && (s8[i] & 0xc0) == 0x80) {\n      i++;\n    }\n    out += decode_codepoint(&s8[beg], (i - beg));\n  }\n  return out;\n}\n\n/*-----------------------------------------------------------------------------\n *  resolve_escape_sequence\n *---------------------------------------------------------------------------*/\n\ninline bool is_hex(char c, int &v) {\n  if ('0' <= c && c <= '9') {\n    v = c - '0';\n    return true;\n  } else if ('a' <= c && c <= 'f') {\n    v = c - 'a' + 10;\n    return true;\n  } else if ('A' <= c && c <= 'F') {\n    v = c - 'A' + 10;\n    return true;\n  }\n  return false;\n}\n\ninline bool is_digit(char c, int &v) {\n  if ('0' <= c && c <= '9') {\n    v = c - '0';\n    return true;\n  }\n  return false;\n}\n\ninline std::pair<int, size_t> parse_hex_number(const char *s, size_t n,\n                                               size_t i) {\n  int ret = 0;\n  int val;\n  while (i < n && is_hex(s[i], val)) {\n    ret = static_cast<int>(ret * 16 + val);\n    i++;\n  }\n  return std::make_pair(ret, i);\n}\n\ninline std::pair<int, size_t> parse_octal_number(const char *s, size_t n,\n                                                 size_t i) {\n  int ret = 0;\n  int val;\n  while (i < n && is_digit(s[i], val)) {\n    ret = static_cast<int>(ret * 8 + val);\n    i++;\n  }\n  return std::make_pair(ret, i);\n}\n\ninline std::string resolve_escape_sequence(const char *s, size_t n) {\n  std::string r;\n  r.reserve(n);\n\n  size_t i = 0;\n  while (i < n) {\n    auto ch = s[i];\n    if (ch == '\\\\') {\n      i++;\n      if (i == n) { throw std::runtime_error(\"Invalid escape sequence...\"); }\n      switch (s[i]) {\n      case 'n':\n        r += '\\n';\n        i++;\n        break;\n      case 'r':\n        r += '\\r';\n        i++;\n        break;\n      case 't':\n        r += '\\t';\n        i++;\n        break;\n      case '\\'':\n        r += '\\'';\n        i++;\n        break;\n      case '\"':\n        r += '\"';\n        i++;\n        break;\n      case '[':\n        r += '[';\n        i++;\n        break;\n      case ']':\n        r += ']';\n        i++;\n        break;\n      case '\\\\':\n        r += '\\\\';\n        i++;\n        break;\n      case 'x':\n      case 'u': {\n        char32_t cp;\n        std::tie(cp, i) = parse_hex_number(s, n, i + 1);\n        r += encode_codepoint(cp);\n        break;\n      }\n      default: {\n        char32_t cp;\n        std::tie(cp, i) = parse_octal_number(s, n, i);\n        r += encode_codepoint(cp);\n        break;\n      }\n      }\n    } else {\n      r += ch;\n      i++;\n    }\n  }\n  return r;\n}\n\n/*-----------------------------------------------------------------------------\n *  Trie\n *---------------------------------------------------------------------------*/\n\nclass Trie {\npublic:\n  Trie() = default;\n  Trie(const Trie &) = default;\n\n  Trie(const std::vector<std::string> &items) {\n    for (const auto &item : items) {\n      for (size_t len = 1; len <= item.size(); len++) {\n        auto last = len == item.size();\n        std::string s(item.c_str(), len);\n        auto it = dic_.find(s);\n        if (it == dic_.end()) {\n          dic_.emplace(s, Info{last, last});\n        } else if (last) {\n          it->second.match = true;\n        } else {\n          it->second.done = false;\n        }\n      }\n    }\n  }\n\n  size_t match(const char *text, size_t text_len) const {\n    size_t match_len = 0;\n    {\n      auto done = false;\n      size_t len = 1;\n      while (!done && len <= text_len) {\n        std::string s(text, len);\n        auto it = dic_.find(s);\n        if (it == dic_.end()) {\n          done = true;\n        } else {\n          if (it->second.match) { match_len = len; }\n          if (it->second.done) { done = true; }\n        }\n        len += 1;\n      }\n    }\n    return match_len;\n  }\n\nprivate:\n  struct Info {\n    bool done;\n    bool match;\n  };\n  std::unordered_map<std::string, Info> dic_;\n};\n\n/*-----------------------------------------------------------------------------\n *  PEG\n *---------------------------------------------------------------------------*/\n\n/*\n * Line information utility function\n */\ninline std::pair<size_t, size_t> line_info(const char *start, const char *cur) {\n  auto p = start;\n  auto col_ptr = p;\n  auto no = 1;\n\n  while (p < cur) {\n    if (*p == '\\n') {\n      no++;\n      col_ptr = p + 1;\n    }\n    p++;\n  }\n\n  auto col = p - col_ptr + 1;\n\n  return std::make_pair(no, col);\n}\n\n/*\n * String tag\n */\ninline constexpr unsigned int str2tag(const char *str, unsigned int h = 0) {\n  return (*str == '\\0')\n             ? h\n             : str2tag(str + 1, (h * 33) ^ static_cast<unsigned char>(*str));\n}\n\nnamespace udl {\n\ninline constexpr unsigned int operator\"\" _(const char *s, size_t) {\n  return str2tag(s);\n}\n\n} // namespace udl\n\n/*\n * Semantic values\n */\nstruct SemanticValues : protected std::vector<any> {\n  // Input text\n  const char *path = nullptr;\n  const char *ss = nullptr;\n  const std::vector<size_t> *source_line_index = nullptr;\n\n  // Matched string\n  const char *c_str() const { return s_; }\n  size_t length() const { return n_; }\n\n  std::string str() const { return std::string(s_, n_); }\n\n  // Definition name\n  const std::string &name() const { return name_; }\n\n  std::vector<unsigned int> tags;\n\n  // Line number and column at which the matched string is\n  std::pair<size_t, size_t> line_info() const {\n    const auto &idx = *source_line_index;\n\n    auto cur = static_cast<size_t>(std::distance(ss, s_));\n    auto it = std::lower_bound(\n        idx.begin(), idx.end(), cur,\n        [](size_t element, size_t value) { return element < value; });\n\n    auto id = static_cast<size_t>(std::distance(idx.begin(), it));\n    auto off = cur - (id == 0 ? 0 : idx[id - 1] + 1);\n    return std::make_pair(id + 1, off + 1);\n  }\n\n  // Choice count\n  size_t choice_count() const { return choice_count_; }\n\n  // Choice number (0 based index)\n  size_t choice() const { return choice_; }\n\n  // Tokens\n  std::vector<std::pair<const char *, size_t>> tokens;\n\n  std::string token(size_t id = 0) const {\n    if (!tokens.empty()) {\n      assert(id < tokens.size());\n      const auto &tok = tokens[id];\n      return std::string(tok.first, tok.second);\n    }\n    return std::string(s_, n_);\n  }\n\n  // Transform the semantic value vector to another vector\n  template <typename T>\n  std::vector<T> transform(size_t beg = 0,\n                           size_t end = static_cast<size_t>(-1)) const {\n    std::vector<T> r;\n    end = (std::min)(end, size());\n    for (size_t i = beg; i < end; i++) {\n      r.emplace_back(any_cast<T>((*this)[i]));\n    }\n    return r;\n  }\n\n  using std::vector<any>::iterator;\n  using std::vector<any>::const_iterator;\n  using std::vector<any>::size;\n  using std::vector<any>::empty;\n  using std::vector<any>::assign;\n  using std::vector<any>::begin;\n  using std::vector<any>::end;\n  using std::vector<any>::rbegin;\n  using std::vector<any>::rend;\n  using std::vector<any>::operator[];\n  using std::vector<any>::at;\n  using std::vector<any>::resize;\n  using std::vector<any>::front;\n  using std::vector<any>::back;\n  using std::vector<any>::push_back;\n  using std::vector<any>::pop_back;\n  using std::vector<any>::insert;\n  using std::vector<any>::erase;\n  using std::vector<any>::clear;\n  using std::vector<any>::swap;\n  using std::vector<any>::emplace;\n  using std::vector<any>::emplace_back;\n\nprivate:\n  friend class Context;\n  friend class Sequence;\n  friend class PrioritizedChoice;\n  friend class Holder;\n  friend class PrecedenceClimbing;\n\n  const char *s_ = nullptr;\n  size_t n_ = 0;\n  size_t choice_count_ = 0;\n  size_t choice_ = 0;\n  std::string name_;\n};\n\n/*\n * Semantic action\n */\ntemplate <typename R, typename F,\n          typename std::enable_if<std::is_void<R>::value,\n                                  std::nullptr_t>::type = nullptr,\n          typename... Args>\nany call(F fn, Args &&... args) {\n  fn(std::forward<Args>(args)...);\n  return any();\n}\n\ntemplate <typename R, typename F,\n          typename std::enable_if<\n              std::is_same<typename std::remove_cv<R>::type, any>::value,\n              std::nullptr_t>::type = nullptr,\n          typename... Args>\nany call(F fn, Args &&... args) {\n  return fn(std::forward<Args>(args)...);\n}\n\ntemplate <typename R, typename F,\n          typename std::enable_if<\n              !std::is_void<R>::value &&\n                  !std::is_same<typename std::remove_cv<R>::type, any>::value,\n              std::nullptr_t>::type = nullptr,\n          typename... Args>\nany call(F fn, Args &&... args) {\n  return any(fn(std::forward<Args>(args)...));\n}\n\nclass Action {\npublic:\n  Action() = default;\n  Action(const Action &rhs) = default;\n\n  template <typename F,\n            typename std::enable_if<!std::is_pointer<F>::value &&\n                                        !std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  Action(F fn) : fn_(make_adaptor(fn, &F::operator())) {}\n\n  template <typename F, typename std::enable_if<std::is_pointer<F>::value,\n                                                std::nullptr_t>::type = nullptr>\n  Action(F fn) : fn_(make_adaptor(fn, fn)) {}\n\n  template <typename F,\n            typename std::enable_if<std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  Action(F /*fn*/) {}\n\n  template <typename F,\n            typename std::enable_if<!std::is_pointer<F>::value &&\n                                        !std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  void operator=(F fn) {\n    fn_ = make_adaptor(fn, &F::operator());\n  }\n\n  template <typename F, typename std::enable_if<std::is_pointer<F>::value,\n                                                std::nullptr_t>::type = nullptr>\n  void operator=(F fn) {\n    fn_ = make_adaptor(fn, fn);\n  }\n\n  template <typename F,\n            typename std::enable_if<std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  void operator=(F /*fn*/) {}\n\n  Action &operator=(const Action &rhs) = default;\n\n  operator bool() const { return bool(fn_); }\n\n  any operator()(SemanticValues &sv, any &dt) const { return fn_(sv, dt); }\n\nprivate:\n  template <typename R> struct TypeAdaptor_sv {\n    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}\n    any operator()(SemanticValues &sv, any & /*dt*/) {\n      return call<R>(fn_, sv);\n    }\n    std::function<R(SemanticValues &sv)> fn_;\n  };\n\n  template <typename R> struct TypeAdaptor_csv {\n    TypeAdaptor_csv(std::function<R(const SemanticValues &sv)> fn) : fn_(fn) {}\n    any operator()(SemanticValues &sv, any & /*dt*/) {\n      return call<R>(fn_, sv);\n    }\n    std::function<R(const SemanticValues &sv)> fn_;\n  };\n\n  template <typename R> struct TypeAdaptor_sv_dt {\n    TypeAdaptor_sv_dt(std::function<R(SemanticValues &sv, any &dt)> fn)\n        : fn_(fn) {}\n    any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }\n    std::function<R(SemanticValues &sv, any &dt)> fn_;\n  };\n\n  template <typename R> struct TypeAdaptor_csv_dt {\n    TypeAdaptor_csv_dt(std::function<R(const SemanticValues &sv, any &dt)> fn)\n        : fn_(fn) {}\n    any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }\n    std::function<R(const SemanticValues &sv, any &dt)> fn_;\n  };\n\n  typedef std::function<any(SemanticValues &sv, any &dt)> Fty;\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv) const) {\n    return TypeAdaptor_sv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv) const) {\n    return TypeAdaptor_csv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv)) {\n    return TypeAdaptor_sv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv)) {\n    return TypeAdaptor_csv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(SemanticValues &sv)) {\n    return TypeAdaptor_sv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(const SemanticValues &sv)) {\n    return TypeAdaptor_csv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv, any &dt) const) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv, any &dt) const) {\n    return TypeAdaptor_csv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_csv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(const SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_csv_dt<R>(fn);\n  }\n\n  Fty fn_;\n};\n\n/*\n * Semantic predicate\n */\n// Note: 'parse_error' exception class should be be used in sematic action\n// handlers to reject the rule.\nstruct parse_error {\n  parse_error() = default;\n  parse_error(const char *s) : s_(s) {}\n  const char *what() const { return s_.empty() ? nullptr : s_.c_str(); }\n\nprivate:\n  std::string s_;\n};\n\n/*\n * Result\n */\ninline bool success(size_t len) { return len != static_cast<size_t>(-1); }\n\ninline bool fail(size_t len) { return len == static_cast<size_t>(-1); }\n\n/*\n * Context\n */\nclass Context;\nclass Ope;\nclass Definition;\n\ntypedef std::function<void(const char *name, const char *s, size_t n,\n                           const SemanticValues &sv, const Context &c,\n                           const any &dt)>\n    TracerEnter;\n\ntypedef std::function<void(const char *name, const char *s, size_t n,\n                           const SemanticValues &sv, const Context &c,\n                           const any &dt, size_t)>\n    TracerLeave;\n\nclass Context {\npublic:\n  const char *path;\n  const char *s;\n  const size_t l;\n  std::vector<size_t> source_line_index;\n\n  const char *error_pos = nullptr;\n  const char *message_pos = nullptr;\n  std::string message; // TODO: should be `int`.\n\n  std::vector<std::shared_ptr<SemanticValues>> value_stack;\n  size_t value_stack_size = 0;\n\n  std::vector<Definition *> rule_stack;\n  std::vector<std::vector<std::shared_ptr<Ope>>> args_stack;\n\n  bool in_token = false;\n\n  std::shared_ptr<Ope> whitespaceOpe;\n  bool in_whitespace = false;\n\n  std::shared_ptr<Ope> wordOpe;\n\n  std::vector<std::map<std::string, std::string>> capture_scope_stack;\n  size_t capture_scope_stack_size = 0;\n\n  const size_t def_count;\n  const bool enablePackratParsing;\n  std::vector<bool> cache_registered;\n  std::vector<bool> cache_success;\n\n  std::map<std::pair<size_t, size_t>, std::tuple<size_t, any>> cache_values;\n\n  TracerEnter tracer_enter;\n  TracerLeave tracer_leave;\n\n  Context(const char *a_path, const char *a_s, size_t a_l, size_t a_def_count,\n          std::shared_ptr<Ope> a_whitespaceOpe, std::shared_ptr<Ope> a_wordOpe,\n          bool a_enablePackratParsing, TracerEnter a_tracer_enter,\n          TracerLeave a_tracer_leave)\n      : path(a_path), s(a_s), l(a_l), whitespaceOpe(a_whitespaceOpe),\n        wordOpe(a_wordOpe), def_count(a_def_count),\n        enablePackratParsing(a_enablePackratParsing),\n        cache_registered(enablePackratParsing ? def_count * (l + 1) : 0),\n        cache_success(enablePackratParsing ? def_count * (l + 1) : 0),\n        tracer_enter(a_tracer_enter), tracer_leave(a_tracer_leave) {\n\n    for (size_t pos = 0; pos < l; pos++) {\n      if (s[pos] == '\\n') { source_line_index.push_back(pos); }\n    }\n    source_line_index.push_back(l);\n\n    args_stack.resize(1);\n\n    push_capture_scope();\n  }\n\n  ~Context() { assert(!value_stack_size); }\n\n  Context(const Context &) = delete;\n  Context(Context &&) = delete;\n  Context operator=(const Context &) = delete;\n\n  template <typename T>\n  void packrat(const char *a_s, size_t def_id, size_t &len, any &val, T fn) {\n    if (!enablePackratParsing) {\n      fn(val);\n      return;\n    }\n\n    auto col = a_s - s;\n    auto idx = def_count * static_cast<size_t>(col) + def_id;\n\n    if (cache_registered[idx]) {\n      if (cache_success[idx]) {\n        auto key = std::make_pair(col, def_id);\n        std::tie(len, val) = cache_values[key];\n        return;\n      } else {\n        len = static_cast<size_t>(-1);\n        return;\n      }\n    } else {\n      fn(val);\n      cache_registered[idx] = true;\n      cache_success[idx] = success(len);\n      if (success(len)) {\n        auto key = std::make_pair(col, def_id);\n        cache_values[key] = std::make_pair(len, val);\n      }\n      return;\n    }\n  }\n\n  SemanticValues &push() {\n    assert(value_stack_size <= value_stack.size());\n    if (value_stack_size == value_stack.size()) {\n      value_stack.emplace_back(std::make_shared<SemanticValues>());\n    } else {\n      auto &sv = *value_stack[value_stack_size];\n      if (!sv.empty()) {\n        sv.clear();\n        if (!sv.tags.empty()) { sv.tags.clear(); }\n      }\n      sv.s_ = nullptr;\n      sv.n_ = 0;\n      sv.choice_count_ = 0;\n      sv.choice_ = 0;\n      if (!sv.tokens.empty()) { sv.tokens.clear(); }\n    }\n\n    auto &sv = *value_stack[value_stack_size++];\n    sv.path = path;\n    sv.ss = s;\n    sv.source_line_index = &source_line_index;\n    return sv;\n  }\n\n  void pop() { value_stack_size--; }\n\n  void push_args(std::vector<std::shared_ptr<Ope>> &&args) {\n    args_stack.emplace_back(args);\n  }\n\n  void pop_args() { args_stack.pop_back(); }\n\n  const std::vector<std::shared_ptr<Ope>> &top_args() const {\n    return args_stack[args_stack.size() - 1];\n  }\n\n  void push_capture_scope() {\n    assert(capture_scope_stack_size <= capture_scope_stack.size());\n    if (capture_scope_stack_size == capture_scope_stack.size()) {\n      capture_scope_stack.emplace_back(std::map<std::string, std::string>());\n    } else {\n      auto &cs = capture_scope_stack[capture_scope_stack_size];\n      if (!cs.empty()) { cs.clear(); }\n    }\n    capture_scope_stack_size++;\n  }\n\n  void pop_capture_scope() { capture_scope_stack_size--; }\n\n  void shift_capture_values() {\n    assert(capture_scope_stack.size() >= 2);\n    auto curr = &capture_scope_stack[capture_scope_stack_size - 1];\n    auto prev = curr - 1;\n    for (const auto &kv : *curr) {\n      (*prev)[kv.first] = kv.second;\n    }\n  }\n\n  void set_error_pos(const char *a_s) {\n    if (error_pos < a_s) error_pos = a_s;\n  }\n\n  void trace_enter(const char *name, const char *a_s, size_t n,\n                   SemanticValues &sv, any &dt) const;\n  void trace_leave(const char *name, const char *a_s, size_t n,\n                   SemanticValues &sv, any &dt, size_t len) const;\n  bool is_traceable(const Ope &ope) const;\n\n  mutable size_t next_trace_id = 0;\n  mutable std::list<size_t> trace_ids;\n};\n\n/*\n * Parser operators\n */\nclass Ope {\npublic:\n  struct Visitor;\n\n  virtual ~Ope() {}\n  size_t parse(const char *s, size_t n, SemanticValues &sv, Context &c,\n               any &dt) const;\n  virtual size_t parse_core(const char *s, size_t n, SemanticValues &sv,\n                            Context &c, any &dt) const = 0;\n  virtual void accept(Visitor &v) = 0;\n};\n\nclass Sequence : public Ope {\npublic:\n  template <typename... Args>\n  Sequence(const Args &... args)\n      : opes_{static_cast<std::shared_ptr<Ope>>(args)...} {}\n  Sequence(const std::vector<std::shared_ptr<Ope>> &opes) : opes_(opes) {}\n  Sequence(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    auto &chldsv = c.push();\n    auto pop_se = make_scope_exit([&]() { c.pop(); });\n    size_t i = 0;\n    for (const auto &ope : opes_) {\n      const auto &rule = *ope;\n      auto len = rule.parse(s + i, n - i, chldsv, c, dt);\n      if (fail(len)) { return static_cast<size_t>(-1); }\n      i += len;\n    }\n    if (!chldsv.empty()) {\n      for (size_t j = 0; j < chldsv.size(); j++) {\n        sv.emplace_back(std::move(chldsv[j]));\n      }\n    }\n    if (!chldsv.tags.empty()) {\n      for (size_t j = 0; j < chldsv.tags.size(); j++) {\n        sv.tags.emplace_back(std::move(chldsv.tags[j]));\n      }\n    }\n    sv.s_ = chldsv.c_str();\n    sv.n_ = chldsv.length();\n    if (!chldsv.tokens.empty()) {\n      for (size_t j = 0; j < chldsv.tokens.size(); j++) {\n        sv.tokens.emplace_back(std::move(chldsv.tokens[j]));\n      }\n    }\n    return i;\n  }\n\n  void accept(Visitor &v) override;\n\n  std::vector<std::shared_ptr<Ope>> opes_;\n};\n\nclass PrioritizedChoice : public Ope {\npublic:\n  template <typename... Args>\n  PrioritizedChoice(const Args &... args)\n      : opes_{static_cast<std::shared_ptr<Ope>>(args)...} {}\n  PrioritizedChoice(const std::vector<std::shared_ptr<Ope>> &opes)\n      : opes_(opes) {}\n  PrioritizedChoice(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    size_t id = 0;\n    for (const auto &ope : opes_) {\n      auto &chldsv = c.push();\n      c.push_capture_scope();\n      auto se = make_scope_exit([&]() {\n        c.pop();\n        c.pop_capture_scope();\n      });\n      auto len = ope->parse(s, n, chldsv, c, dt);\n      if (success(len)) {\n        if (!chldsv.empty()) {\n          for (size_t i = 0; i < chldsv.size(); i++) {\n            sv.emplace_back(std::move(chldsv[i]));\n          }\n        }\n        if (!chldsv.tags.empty()) {\n          for (size_t i = 0; i < chldsv.tags.size(); i++) {\n            sv.tags.emplace_back(std::move(chldsv.tags[i]));\n          }\n        }\n        sv.s_ = chldsv.c_str();\n        sv.n_ = chldsv.length();\n        sv.choice_count_ = opes_.size();\n        sv.choice_ = id;\n        if (!chldsv.tokens.empty()) {\n          for (size_t i = 0; i < chldsv.tokens.size(); i++) {\n            sv.tokens.emplace_back(std::move(chldsv.tokens[i]));\n          }\n        }\n\n        c.shift_capture_values();\n        return len;\n      }\n      id++;\n    }\n    return static_cast<size_t>(-1);\n  }\n\n  void accept(Visitor &v) override;\n\n  size_t size() const { return opes_.size(); }\n\n  std::vector<std::shared_ptr<Ope>> opes_;\n};\n\nclass Repetition : public Ope {\npublic:\n  Repetition(const std::shared_ptr<Ope> &ope, size_t min, size_t max)\n      : ope_(ope), min_(min), max_(max) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    size_t count = 0;\n    size_t i = 0;\n    while (count < min_) {\n      c.push_capture_scope();\n      auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n      const auto &rule = *ope_;\n      auto len = rule.parse(s + i, n - i, sv, c, dt);\n      if (success(len)) {\n        c.shift_capture_values();\n      } else {\n        return static_cast<size_t>(-1);\n      }\n      i += len;\n      count++;\n    }\n\n    auto save_error_pos = c.error_pos;\n    while (n - i > 0 && count < max_) {\n      c.push_capture_scope();\n      auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n      auto save_sv_size = sv.size();\n      auto save_tok_size = sv.tokens.size();\n      const auto &rule = *ope_;\n      auto len = rule.parse(s + i, n - i, sv, c, dt);\n      if (success(len)) {\n        c.shift_capture_values();\n      } else {\n        if (sv.size() != save_sv_size) {\n          sv.erase(sv.begin() + static_cast<std::ptrdiff_t>(save_sv_size));\n          sv.tags.erase(sv.tags.begin() +\n                        static_cast<std::ptrdiff_t>(save_sv_size));\n        }\n        if (sv.tokens.size() != save_tok_size) {\n          sv.tokens.erase(sv.tokens.begin() +\n                          static_cast<std::ptrdiff_t>(save_tok_size));\n        }\n        c.error_pos = save_error_pos;\n        break;\n      }\n      i += len;\n      count++;\n    }\n    return i;\n  }\n\n  void accept(Visitor &v) override;\n\n  bool is_zom() const {\n    return min_ == 0 && max_ == std::numeric_limits<size_t>::max();\n  }\n\n  static std::shared_ptr<Repetition> zom(const std::shared_ptr<Ope> &ope) {\n    return std::make_shared<Repetition>(ope, 0,\n                                        std::numeric_limits<size_t>::max());\n  }\n\n  static std::shared_ptr<Repetition> oom(const std::shared_ptr<Ope> &ope) {\n    return std::make_shared<Repetition>(ope, 1,\n                                        std::numeric_limits<size_t>::max());\n  }\n\n  static std::shared_ptr<Repetition> opt(const std::shared_ptr<Ope> &ope) {\n    return std::make_shared<Repetition>(ope, 0, 1);\n  }\n\n  std::shared_ptr<Ope> ope_;\n  size_t min_;\n  size_t max_;\n};\n\nclass AndPredicate : public Ope {\npublic:\n  AndPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any &dt) const override {\n    auto &chldsv = c.push();\n    c.push_capture_scope();\n    auto se = make_scope_exit([&]() {\n      c.pop();\n      c.pop_capture_scope();\n    });\n    const auto &rule = *ope_;\n    auto len = rule.parse(s, n, chldsv, c, dt);\n    if (success(len)) {\n      return 0;\n    } else {\n      return static_cast<size_t>(-1);\n    }\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\nclass NotPredicate : public Ope {\npublic:\n  NotPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any &dt) const override {\n    auto save_error_pos = c.error_pos;\n    auto &chldsv = c.push();\n    c.push_capture_scope();\n    auto se = make_scope_exit([&]() {\n      c.pop();\n      c.pop_capture_scope();\n    });\n    auto len = ope_->parse(s, n, chldsv, c, dt);\n    if (success(len)) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    } else {\n      c.error_pos = save_error_pos;\n      return 0;\n    }\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\nclass Dictionary : public Ope, public std::enable_shared_from_this<Dictionary> {\npublic:\n  Dictionary(const std::vector<std::string> &v) : trie_(v) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  Trie trie_;\n};\n\nclass LiteralString : public Ope,\n                      public std::enable_shared_from_this<LiteralString> {\npublic:\n  LiteralString(std::string &&s, bool ignore_case)\n      : lit_(s), ignore_case_(ignore_case),\n        is_word_(false) {}\n\n  LiteralString(const std::string &s, bool ignore_case)\n      : lit_(s), ignore_case_(ignore_case),\n        is_word_(false) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::string lit_;\n  bool ignore_case_;\n  mutable std::once_flag init_is_word_;\n  mutable bool is_word_;\n};\n\nclass CharacterClass : public Ope,\n                       public std::enable_shared_from_this<CharacterClass> {\npublic:\n  CharacterClass(const std::string &s, bool negated) : negated_(negated) {\n    auto chars = decode(s.c_str(), s.length());\n    auto i = 0u;\n    while (i < chars.size()) {\n      if (i + 2 < chars.size() && chars[i + 1] == '-') {\n        auto cp1 = chars[i];\n        auto cp2 = chars[i + 2];\n        ranges_.emplace_back(std::make_pair(cp1, cp2));\n        i += 3;\n      } else {\n        auto cp = chars[i];\n        ranges_.emplace_back(std::make_pair(cp, cp));\n        i += 1;\n      }\n    }\n    assert(!ranges_.empty());\n  }\n\n  CharacterClass(const std::vector<std::pair<char32_t, char32_t>> &ranges,\n                 bool negated)\n      : ranges_(ranges), negated_(negated) {\n    assert(!ranges_.empty());\n  }\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any & /*dt*/) const override {\n    if (n < 1) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n\n    char32_t cp = 0;\n    auto len = decode_codepoint(s, n, cp);\n\n    for (const auto &range : ranges_) {\n      if (range.first <= cp && cp <= range.second) {\n        if (negated_) {\n          c.set_error_pos(s);\n          return static_cast<size_t>(-1);\n        } else {\n          return len;\n        }\n      }\n    }\n\n    if (negated_) {\n      return len;\n    } else {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n  }\n\n  void accept(Visitor &v) override;\n\n  std::vector<std::pair<char32_t, char32_t>> ranges_;\n  bool negated_;\n};\n\nclass Character : public Ope, public std::enable_shared_from_this<Character> {\npublic:\n  Character(char ch) : ch_(ch) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any & /*dt*/) const override {\n    if (n < 1 || s[0] != ch_) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n    return 1;\n  }\n\n  void accept(Visitor &v) override;\n\n  char ch_;\n};\n\nclass AnyCharacter : public Ope,\n                     public std::enable_shared_from_this<AnyCharacter> {\npublic:\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any & /*dt*/) const override {\n    auto len = codepoint_length(s, n);\n    if (len < 1) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n    return len;\n  }\n\n  void accept(Visitor &v) override;\n};\n\nclass CaptureScope : public Ope {\npublic:\n  CaptureScope(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    c.push_capture_scope();\n    auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n    const auto &rule = *ope_;\n    auto len = rule.parse(s, n, sv, c, dt);\n    return len;\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\nclass Capture : public Ope {\npublic:\n  typedef std::function<void(const char *s, size_t n, Context &c)> MatchAction;\n\n  Capture(const std::shared_ptr<Ope> &ope, MatchAction ma)\n      : ope_(ope), match_action_(ma) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    const auto &rule = *ope_;\n    auto len = rule.parse(s, n, sv, c, dt);\n    if (success(len) && match_action_) { match_action_(s, len, c); }\n    return len;\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n  MatchAction match_action_;\n};\n\nclass TokenBoundary : public Ope {\npublic:\n  TokenBoundary(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\nclass Ignore : public Ope {\npublic:\n  Ignore(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any &dt) const override {\n    const auto &rule = *ope_;\n    auto &chldsv = c.push();\n    auto se = make_scope_exit([&]() { c.pop(); });\n    return rule.parse(s, n, chldsv, c, dt);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\ntypedef std::function<size_t(const char *s, size_t n, SemanticValues &sv,\n                             any &dt)>\n    Parser;\n\nclass User : public Ope {\npublic:\n  User(Parser fn) : fn_(fn) {}\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv,\n                    Context & /*c*/, any &dt) const override {\n    assert(fn_);\n    return fn_(s, n, sv, dt);\n  }\n  void accept(Visitor &v) override;\n  std::function<size_t(const char *s, size_t n, SemanticValues &sv, any &dt)>\n      fn_;\n};\n\nclass WeakHolder : public Ope {\npublic:\n  WeakHolder(const std::shared_ptr<Ope> &ope) : weak_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    auto ope = weak_.lock();\n    assert(ope);\n    const auto &rule = *ope;\n    return rule.parse(s, n, sv, c, dt);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::weak_ptr<Ope> weak_;\n};\n\nclass Holder : public Ope {\npublic:\n  Holder(Definition *outer) : outer_(outer) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  any reduce(SemanticValues &sv, any &dt) const;\n\n  const char *trace_name() const;\n\n  std::shared_ptr<Ope> ope_;\n  Definition *outer_;\n  mutable std::string trace_name_;\n\n  friend class Definition;\n};\n\ntypedef std::unordered_map<std::string, Definition> Grammar;\n\nclass Reference : public Ope, public std::enable_shared_from_this<Reference> {\npublic:\n  Reference(const Grammar &grammar, const std::string &name, const char *s,\n            bool is_macro, const std::vector<std::shared_ptr<Ope>> &args)\n      : grammar_(grammar), name_(name), s_(s), is_macro_(is_macro), args_(args),\n        rule_(nullptr), iarg_(0) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> get_core_operator() const;\n\n  const Grammar &grammar_;\n  const std::string name_;\n  const char *s_;\n\n  const bool is_macro_;\n  const std::vector<std::shared_ptr<Ope>> args_;\n\n  Definition *rule_;\n  size_t iarg_;\n};\n\nclass Whitespace : public Ope {\npublic:\n  Whitespace(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    if (c.in_whitespace) { return 0; }\n    c.in_whitespace = true;\n    auto se = make_scope_exit([&]() { c.in_whitespace = false; });\n    const auto &rule = *ope_;\n    return rule.parse(s, n, sv, c, dt);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\nclass BackReference : public Ope {\npublic:\n  BackReference(const std::string &name) : name_(name) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::string name_;\n};\n\nclass PrecedenceClimbing : public Ope {\npublic:\n  using BinOpeInfo = std::map<std::string, std::pair<size_t, char>>;\n\n  PrecedenceClimbing(const std::shared_ptr<Ope> &atom,\n                     const std::shared_ptr<Ope> &binop, const BinOpeInfo &info,\n                     const Definition &rule)\n      : atom_(atom), binop_(binop), info_(info), rule_(rule) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    return parse_expression(s, n, sv, c, dt, 0);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> atom_;\n  std::shared_ptr<Ope> binop_;\n  BinOpeInfo info_;\n  const Definition &rule_;\n\nprivate:\n  size_t parse_expression(const char *s, size_t n, SemanticValues &sv,\n                          Context &c, any &dt, size_t min_prec) const;\n\n  Definition &get_reference_for_binop(Context &c) const;\n};\n\n/*\n * Factories\n */\ntemplate <typename... Args> std::shared_ptr<Ope> seq(Args &&... args) {\n  return std::make_shared<Sequence>(static_cast<std::shared_ptr<Ope>>(args)...);\n}\n\ntemplate <typename... Args> std::shared_ptr<Ope> cho(Args &&... args) {\n  return std::make_shared<PrioritizedChoice>(\n      static_cast<std::shared_ptr<Ope>>(args)...);\n}\n\ninline std::shared_ptr<Ope> zom(const std::shared_ptr<Ope> &ope) {\n  return Repetition::zom(ope);\n}\n\ninline std::shared_ptr<Ope> oom(const std::shared_ptr<Ope> &ope) {\n  return Repetition::oom(ope);\n}\n\ninline std::shared_ptr<Ope> opt(const std::shared_ptr<Ope> &ope) {\n  return Repetition::opt(ope);\n}\n\ninline std::shared_ptr<Ope> rep(const std::shared_ptr<Ope> &ope, size_t min,\n                                size_t max) {\n  return std::make_shared<Repetition>(ope, min, max);\n}\n\ninline std::shared_ptr<Ope> apd(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<AndPredicate>(ope);\n}\n\ninline std::shared_ptr<Ope> npd(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<NotPredicate>(ope);\n}\n\ninline std::shared_ptr<Ope> dic(const std::vector<std::string> &v) {\n  return std::make_shared<Dictionary>(v);\n}\n\ninline std::shared_ptr<Ope> lit(std::string &&s) {\n  return std::make_shared<LiteralString>(s, false);\n}\n\ninline std::shared_ptr<Ope> liti(std::string &&s) {\n  return std::make_shared<LiteralString>(s, true);\n}\n\ninline std::shared_ptr<Ope> cls(const std::string &s) {\n  return std::make_shared<CharacterClass>(s, false);\n}\n\ninline std::shared_ptr<Ope>\ncls(const std::vector<std::pair<char32_t, char32_t>> &ranges) {\n  return std::make_shared<CharacterClass>(ranges, false);\n}\n\ninline std::shared_ptr<Ope> ncls(const std::string &s) {\n  return std::make_shared<CharacterClass>(s, true);\n}\n\ninline std::shared_ptr<Ope>\nncls(const std::vector<std::pair<char32_t, char32_t>> &ranges) {\n  return std::make_shared<CharacterClass>(ranges, true);\n}\n\ninline std::shared_ptr<Ope> chr(char dt) {\n  return std::make_shared<Character>(dt);\n}\n\ninline std::shared_ptr<Ope> dot() { return std::make_shared<AnyCharacter>(); }\n\ninline std::shared_ptr<Ope> csc(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<CaptureScope>(ope);\n}\n\ninline std::shared_ptr<Ope> cap(const std::shared_ptr<Ope> &ope,\n                                Capture::MatchAction ma) {\n  return std::make_shared<Capture>(ope, ma);\n}\n\ninline std::shared_ptr<Ope> tok(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<TokenBoundary>(ope);\n}\n\ninline std::shared_ptr<Ope> ign(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<Ignore>(ope);\n}\n\ninline std::shared_ptr<Ope>\nusr(std::function<size_t(const char *s, size_t n, SemanticValues &sv, any &dt)>\n        fn) {\n  return std::make_shared<User>(fn);\n}\n\ninline std::shared_ptr<Ope> ref(const Grammar &grammar, const std::string &name,\n                                const char *s, bool is_macro,\n                                const std::vector<std::shared_ptr<Ope>> &args) {\n  return std::make_shared<Reference>(grammar, name, s, is_macro, args);\n}\n\ninline std::shared_ptr<Ope> wsp(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<Whitespace>(std::make_shared<Ignore>(ope));\n}\n\ninline std::shared_ptr<Ope> bkr(const std::string &name) {\n  return std::make_shared<BackReference>(name);\n}\n\ninline std::shared_ptr<Ope> pre(const std::shared_ptr<Ope> &atom,\n                                const std::shared_ptr<Ope> &binop,\n                                const PrecedenceClimbing::BinOpeInfo &info,\n                                const Definition &rule) {\n  return std::make_shared<PrecedenceClimbing>(atom, binop, info, rule);\n}\n\n/*\n * Visitor\n */\nstruct Ope::Visitor {\n  virtual ~Visitor() {}\n  virtual void visit(Sequence & /*ope*/) {}\n  virtual void visit(PrioritizedChoice & /*ope*/) {}\n  virtual void visit(Repetition & /*ope*/) {}\n  virtual void visit(AndPredicate & /*ope*/) {}\n  virtual void visit(NotPredicate & /*ope*/) {}\n  virtual void visit(Dictionary & /*ope*/) {}\n  virtual void visit(LiteralString & /*ope*/) {}\n  virtual void visit(CharacterClass & /*ope*/) {}\n  virtual void visit(Character & /*ope*/) {}\n  virtual void visit(AnyCharacter & /*ope*/) {}\n  virtual void visit(CaptureScope & /*ope*/) {}\n  virtual void visit(Capture & /*ope*/) {}\n  virtual void visit(TokenBoundary & /*ope*/) {}\n  virtual void visit(Ignore & /*ope*/) {}\n  virtual void visit(User & /*ope*/) {}\n  virtual void visit(WeakHolder & /*ope*/) {}\n  virtual void visit(Holder & /*ope*/) {}\n  virtual void visit(Reference & /*ope*/) {}\n  virtual void visit(Whitespace & /*ope*/) {}\n  virtual void visit(BackReference & /*ope*/) {}\n  virtual void visit(PrecedenceClimbing & /*ope*/) {}\n};\n\nstruct IsReference : public Ope::Visitor {\n  using Ope::Visitor::visit;\n  void visit(Reference & /*ope*/) override { is_reference = true; }\n  bool is_reference = false;\n};\n\nstruct TraceOpeName : public Ope::Visitor {\n  void visit(Sequence & /*ope*/) override { name = \"Sequence\"; }\n  void visit(PrioritizedChoice & /*ope*/) override {\n    name = \"PrioritizedChoice\";\n  }\n  void visit(Repetition & /*ope*/) override { name = \"Repetition\"; }\n  void visit(AndPredicate & /*ope*/) override { name = \"AndPredicate\"; }\n  void visit(NotPredicate & /*ope*/) override { name = \"NotPredicate\"; }\n  void visit(Dictionary & /*ope*/) override { name = \"Dictionary\"; }\n  void visit(LiteralString & /*ope*/) override { name = \"LiteralString\"; }\n  void visit(CharacterClass & /*ope*/) override { name = \"CharacterClass\"; }\n  void visit(Character & /*ope*/) override { name = \"Character\"; }\n  void visit(AnyCharacter & /*ope*/) override { name = \"AnyCharacter\"; }\n  void visit(CaptureScope & /*ope*/) override { name = \"CaptureScope\"; }\n  void visit(Capture & /*ope*/) override { name = \"Capture\"; }\n  void visit(TokenBoundary & /*ope*/) override { name = \"TokenBoundary\"; }\n  void visit(Ignore & /*ope*/) override { name = \"Ignore\"; }\n  void visit(User & /*ope*/) override { name = \"User\"; }\n  void visit(WeakHolder & /*ope*/) override { name = \"WeakHolder\"; }\n  void visit(Holder &ope) override { name = ope.trace_name(); }\n  void visit(Reference & /*ope*/) override { name = \"Reference\"; }\n  void visit(Whitespace & /*ope*/) override { name = \"Whitespace\"; }\n  void visit(BackReference & /*ope*/) override { name = \"BackReference\"; }\n  void visit(PrecedenceClimbing & /*ope*/) override {\n    name = \"PrecedenceClimbing\";\n  }\n\n  const char *name = nullptr;\n};\n\nstruct AssignIDToDefinition : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override;\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override;\n\n  std::unordered_map<void *, size_t> ids;\n};\n\nstruct IsLiteralToken : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      if (!IsLiteralToken::check(*op)) { return; }\n    }\n    result_ = true;\n  }\n\n  void visit(Dictionary & /*ope*/) override { result_ = true; }\n  void visit(LiteralString & /*ope*/) override { result_ = true; }\n\n  static bool check(Ope &ope) {\n    IsLiteralToken vis;\n    ope.accept(vis);\n    return vis.result_;\n  }\n\nprivate:\n  bool result_ = false;\n};\n\nstruct TokenChecker : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary & /*ope*/) override { has_token_boundary_ = true; }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override;\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  static bool is_token(Ope &ope) {\n    if (IsLiteralToken::check(ope)) { return true; }\n\n    TokenChecker vis;\n    ope.accept(vis);\n    return vis.has_token_boundary_ || !vis.has_rule_;\n  }\n\nprivate:\n  bool has_token_boundary_ = false;\n  bool has_rule_ = false;\n};\n\nstruct DetectLeftRecursion : public Ope::Visitor {\n  DetectLeftRecursion(const std::string &name) : name_(name) {}\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (done_) {\n        break;\n      } else if (error_s) {\n        done_ = true;\n        break;\n      }\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (error_s) {\n        done_ = true;\n        break;\n      }\n    }\n  }\n  void visit(Repetition &ope) override {\n    ope.ope_->accept(*this);\n    done_ = ope.min_ > 0;\n  }\n  void visit(AndPredicate &ope) override {\n    ope.ope_->accept(*this);\n    done_ = false;\n  }\n  void visit(NotPredicate &ope) override {\n    ope.ope_->accept(*this);\n    done_ = false;\n  }\n  void visit(Dictionary & /*ope*/) override { done_ = true; }\n  void visit(LiteralString &ope) override { done_ = !ope.lit_.empty(); }\n  void visit(CharacterClass & /*ope*/) override { done_ = true; }\n  void visit(Character & /*ope*/) override { done_ = true; }\n  void visit(AnyCharacter & /*ope*/) override { done_ = true; }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(User & /*ope*/) override { done_ = true; }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(BackReference & /*ope*/) override { done_ = true; }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  const char *error_s = nullptr;\n\nprivate:\n  std::string name_;\n  std::set<std::string> refs_;\n  bool done_ = false;\n};\n\nstruct HasEmptyElement : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  HasEmptyElement(std::list<std::pair<const char *, std::string>> &refs)\n      : refs_(refs) {}\n\n  void visit(Sequence &ope) override {\n    bool save_is_empty = false;\n    const char *save_error_s = nullptr;\n    std::string save_error_name;\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (!is_empty) { return; }\n      save_is_empty = is_empty;\n      save_error_s = error_s;\n      save_error_name = error_name;\n      is_empty = false;\n      error_name.clear();\n    }\n    is_empty = save_is_empty;\n    error_s = save_error_s;\n    error_name = save_error_name;\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (is_empty) { return; }\n    }\n  }\n  void visit(Repetition &ope) override {\n    if (ope.min_ == 0) {\n      set_error();\n    } else {\n      ope.ope_->accept(*this);\n    }\n  }\n  void visit(AndPredicate & /*ope*/) override { set_error(); }\n  void visit(NotPredicate & /*ope*/) override { set_error(); }\n  void visit(LiteralString &ope) override {\n    if (ope.lit_.empty()) { set_error(); }\n  }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  bool is_empty = false;\n  const char *error_s = nullptr;\n  std::string error_name;\n\nprivate:\n  void set_error() {\n    is_empty = true;\n    error_s = refs_.back().first;\n    error_name = refs_.back().second;\n  }\n  std::list<std::pair<const char *, std::string>> &refs_;\n};\n\nstruct DetectInfiniteLoop : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  DetectInfiniteLoop(const char *s, const std::string &name) {\n    refs_.emplace_back(s, name);\n  }\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (has_error) { return; }\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (has_error) { return; }\n    }\n  }\n  void visit(Repetition &ope) override {\n    if (ope.max_ == std::numeric_limits<size_t>::max()) {\n      HasEmptyElement vis(refs_);\n      ope.ope_->accept(vis);\n      if (vis.is_empty) {\n        has_error = true;\n        error_s = vis.error_s;\n        error_name = vis.error_name;\n      }\n    } else {\n      ope.ope_->accept(*this);\n    }\n  }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  bool has_error = false;\n  const char *error_s = nullptr;\n  std::string error_name;\n\nprivate:\n  std::list<std::pair<const char *, std::string>> refs_;\n};\n\nstruct ReferenceChecker : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  ReferenceChecker(const Grammar &grammar,\n                   const std::vector<std::string> &params)\n      : grammar_(grammar), params_(params) {}\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  std::unordered_map<std::string, const char *> error_s;\n  std::unordered_map<std::string, std::string> error_message;\n\nprivate:\n  const Grammar &grammar_;\n  const std::vector<std::string> &params_;\n};\n\nstruct LinkReferences : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  LinkReferences(Grammar &grammar, const std::vector<std::string> &params)\n      : grammar_(grammar), params_(params) {}\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\nprivate:\n  Grammar &grammar_;\n  const std::vector<std::string> &params_;\n};\n\nstruct FindReference : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  FindReference(const std::vector<std::shared_ptr<Ope>> &args,\n                const std::vector<std::string> &params)\n      : args_(args), params_(params) {}\n\n  void visit(Sequence &ope) override {\n    std::vector<std::shared_ptr<Ope>> opes;\n    for (auto o : ope.opes_) {\n      o->accept(*this);\n      opes.push_back(found_ope);\n    }\n    found_ope = std::make_shared<Sequence>(opes);\n  }\n  void visit(PrioritizedChoice &ope) override {\n    std::vector<std::shared_ptr<Ope>> opes;\n    for (auto o : ope.opes_) {\n      o->accept(*this);\n      opes.push_back(found_ope);\n    }\n    found_ope = std::make_shared<PrioritizedChoice>(opes);\n  }\n  void visit(Repetition &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = rep(found_ope, ope.min_, ope.max_);\n  }\n  void visit(AndPredicate &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = apd(found_ope);\n  }\n  void visit(NotPredicate &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = npd(found_ope);\n  }\n  void visit(Dictionary &ope) override { found_ope = ope.shared_from_this(); }\n  void visit(LiteralString &ope) override {\n    found_ope = ope.shared_from_this();\n  }\n  void visit(CharacterClass &ope) override {\n    found_ope = ope.shared_from_this();\n  }\n  void visit(Character &ope) override { found_ope = ope.shared_from_this(); }\n  void visit(AnyCharacter &ope) override { found_ope = ope.shared_from_this(); }\n  void visit(CaptureScope &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = csc(found_ope);\n  }\n  void visit(Capture &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = cap(found_ope, ope.match_action_);\n  }\n  void visit(TokenBoundary &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = tok(found_ope);\n  }\n  void visit(Ignore &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = ign(found_ope);\n  }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = wsp(found_ope);\n  }\n  void visit(PrecedenceClimbing &ope) override {\n    ope.atom_->accept(*this);\n    found_ope = csc(found_ope);\n  }\n\n  std::shared_ptr<Ope> found_ope;\n\nprivate:\n  const std::vector<std::shared_ptr<Ope>> &args_;\n  const std::vector<std::string> &params_;\n};\n\nstruct IsPrioritizedChoice : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(PrioritizedChoice & /*ope*/) override { result_ = true; }\n\n  static bool check(Ope &ope) {\n    IsPrioritizedChoice vis;\n    ope.accept(vis);\n    return vis.result_;\n  }\n\nprivate:\n  bool result_ = false;\n};\n\n/*\n * Keywords\n */\nstatic const char *WHITESPACE_DEFINITION_NAME = \"%whitespace\";\nstatic const char *WORD_DEFINITION_NAME = \"%word\";\n\n/*\n * Definition\n */\nclass Definition {\npublic:\n  struct Result {\n    bool ret;\n    size_t len;\n    const char *error_pos;\n    const char *message_pos;\n    const std::string message;\n  };\n\n  Definition() : holder_(std::make_shared<Holder>(this)) {}\n\n  Definition(const Definition &rhs) : name(rhs.name), holder_(rhs.holder_) {\n    holder_->outer_ = this;\n  }\n\n  Definition(const std::shared_ptr<Ope> &ope)\n      : holder_(std::make_shared<Holder>(this)) {\n    *this <= ope;\n  }\n\n  operator std::shared_ptr<Ope>() {\n    return std::make_shared<WeakHolder>(holder_);\n  }\n\n  Definition &operator<=(const std::shared_ptr<Ope> &ope) {\n    holder_->ope_ = ope;\n    return *this;\n  }\n\n  Result parse(const char *s, size_t n, const char *path = nullptr) const {\n    SemanticValues sv;\n    any dt;\n    return parse_core(s, n, sv, dt, path);\n  }\n\n  Result parse(const char *s, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse(s, n, path);\n  }\n\n  Result parse(const char *s, size_t n, any &dt,\n               const char *path = nullptr) const {\n    SemanticValues sv;\n    return parse_core(s, n, sv, dt, path);\n  }\n\n  Result parse(const char *s, any &dt, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse(s, n, dt, path);\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, size_t n, T &val,\n                             const char *path = nullptr) const {\n    SemanticValues sv;\n    any dt;\n    auto r = parse_core(s, n, sv, dt, path);\n    if (r.ret && !sv.empty() && sv.front().has_value()) {\n      val = any_cast<T>(sv[0]);\n    }\n    return r;\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, T &val,\n                             const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_and_get_value(s, n, val, path);\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, size_t n, any &dt, T &val,\n                             const char *path = nullptr) const {\n    SemanticValues sv;\n    auto r = parse_core(s, n, sv, dt, path);\n    if (r.ret && !sv.empty() && sv.front().has_value()) {\n      val = any_cast<T>(sv[0]);\n    }\n    return r;\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, any &dt, T &val,\n                             const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_and_get_value(s, n, dt, val, path);\n  }\n\n  Action operator=(Action a) {\n    action = a;\n    return a;\n  }\n\n  template <typename T> Definition &operator,(T fn) {\n    operator=(fn);\n    return *this;\n  }\n\n  Definition &operator~() {\n    ignoreSemanticValue = true;\n    return *this;\n  }\n\n  void accept(Ope::Visitor &v) { holder_->accept(v); }\n\n  std::shared_ptr<Ope> get_core_operator() const { return holder_->ope_; }\n\n  bool is_token() const {\n    std::call_once(is_token_init_, [this]() {\n      is_token_ = TokenChecker::is_token(*get_core_operator());\n    });\n    return is_token_;\n  }\n\n  std::string name;\n  const char *s_ = nullptr;\n\n  size_t id = 0;\n  Action action;\n  std::function<void(const char *s, size_t n, any &dt)> enter;\n  std::function<void(const char *s, size_t n, size_t matchlen, any &value,\n                     any &dt)>\n      leave;\n  std::function<std::string()> error_message;\n  bool ignoreSemanticValue = false;\n  std::shared_ptr<Ope> whitespaceOpe;\n  std::shared_ptr<Ope> wordOpe;\n  bool enablePackratParsing = false;\n  bool is_macro = false;\n  std::vector<std::string> params;\n  TracerEnter tracer_enter;\n  TracerLeave tracer_leave;\n  bool disable_action = false;\n\nprivate:\n  friend class Reference;\n  friend class ParserGenerator;\n\n  Definition &operator=(const Definition &rhs);\n  Definition &operator=(Definition &&rhs);\n\n  void initialize_definition_ids() const {\n    std::call_once(definition_ids_init_, [&]() {\n      AssignIDToDefinition vis;\n      holder_->accept(vis);\n      if (whitespaceOpe) { whitespaceOpe->accept(vis); }\n      if (wordOpe) { wordOpe->accept(vis); }\n      definition_ids_.swap(vis.ids);\n    });\n  }\n\n  Result parse_core(const char *s, size_t n, SemanticValues &sv, any &dt,\n                    const char *path) const {\n    initialize_definition_ids();\n\n    std::shared_ptr<Ope> ope = holder_;\n    if (whitespaceOpe) { ope = std::make_shared<Sequence>(whitespaceOpe, ope); }\n\n    Context cxt(path, s, n, definition_ids_.size(), whitespaceOpe, wordOpe,\n                enablePackratParsing, tracer_enter, tracer_leave);\n\n    auto len = ope->parse(s, n, sv, cxt, dt);\n    return Result{success(len), len, cxt.error_pos, cxt.message_pos,\n                  cxt.message};\n  }\n\n  std::shared_ptr<Holder> holder_;\n  mutable std::once_flag is_token_init_;\n  mutable bool is_token_ = false;\n  mutable std::once_flag assign_id_to_definition_init_;\n  mutable std::once_flag definition_ids_init_;\n  mutable std::unordered_map<void *, size_t> definition_ids_;\n};\n\n/*\n * Implementations\n */\n\ninline size_t parse_literal(const char *s, size_t n, SemanticValues &sv,\n                            Context &c, any &dt, const std::string &lit,\n                            std::once_flag &init_is_word, bool &is_word,\n                            bool ignore_case) {\n  size_t i = 0;\n  for (; i < lit.size(); i++) {\n    if (i >= n || (ignore_case ? (std::tolower(s[i]) != std::tolower(lit[i]))\n                               : (s[i] != lit[i]))) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n  }\n\n  // Word check\n  static Context dummy_c(nullptr, c.s, c.l, 0, nullptr, nullptr, false, nullptr,\n                         nullptr);\n  static SemanticValues dummy_sv;\n  static any dummy_dt;\n\n  std::call_once(init_is_word, [&]() {\n    if (c.wordOpe) {\n      auto len =\n          c.wordOpe->parse(lit.data(), lit.size(), dummy_sv, dummy_c, dummy_dt);\n      is_word = success(len);\n    }\n  });\n\n  if (is_word) {\n    NotPredicate ope(c.wordOpe);\n    auto len = ope.parse(s + i, n - i, dummy_sv, dummy_c, dummy_dt);\n    if (fail(len)) { return static_cast<size_t>(-1); }\n    i += len;\n  }\n\n  // Skip whiltespace\n  if (!c.in_token) {\n    if (c.whitespaceOpe) {\n      auto len = c.whitespaceOpe->parse(s + i, n - i, sv, c, dt);\n      if (fail(len)) { return static_cast<size_t>(-1); }\n      i += len;\n    }\n  }\n\n  return i;\n}\n\ninline void Context::trace_enter(const char *name, const char *a_s, size_t n,\n                                 SemanticValues &sv, any &dt) const {\n  trace_ids.push_back(next_trace_id++);\n  tracer_enter(name, a_s, n, sv, *this, dt);\n}\n\ninline void Context::trace_leave(const char *name, const char *a_s, size_t n,\n                                 SemanticValues &sv, any &dt,\n                                 size_t len) const {\n  tracer_leave(name, a_s, n, sv, *this, dt, len);\n  trace_ids.pop_back();\n}\n\ninline bool Context::is_traceable(const Ope &ope) const {\n  if (tracer_enter && tracer_leave) {\n    IsReference vis;\n    const_cast<Ope &>(ope).accept(vis);\n    return !vis.is_reference;\n  }\n  return false;\n}\n\ninline size_t Ope::parse(const char *s, size_t n, SemanticValues &sv,\n                         Context &c, any &dt) const {\n  if (c.is_traceable(*this)) {\n    TraceOpeName vis;\n    const_cast<Ope &>(*this).accept(vis);\n    c.trace_enter(vis.name, s, n, sv, dt);\n    auto len = parse_core(s, n, sv, c, dt);\n    c.trace_leave(vis.name, s, n, sv, dt, len);\n    return len;\n  }\n  return parse_core(s, n, sv, c, dt);\n}\n\ninline size_t Dictionary::parse_core(const char *s, size_t n,\n                                     SemanticValues & /*sv*/, Context &c,\n                                     any & /*dt*/) const {\n  auto len = trie_.match(s, n);\n  if (len > 0) { return len; }\n  c.set_error_pos(s);\n  return static_cast<size_t>(-1);\n}\n\ninline size_t LiteralString::parse_core(const char *s, size_t n,\n                                        SemanticValues &sv, Context &c,\n                                        any &dt) const {\n  return parse_literal(s, n, sv, c, dt, lit_, init_is_word_, is_word_,\n                       ignore_case_);\n}\n\ninline size_t TokenBoundary::parse_core(const char *s, size_t n,\n                                        SemanticValues &sv, Context &c,\n                                        any &dt) const {\n  c.in_token = true;\n  auto se = make_scope_exit([&]() { c.in_token = false; });\n  auto len = ope_->parse(s, n, sv, c, dt);\n  if (success(len)) {\n    sv.tokens.emplace_back(std::make_pair(s, len));\n\n    if (c.whitespaceOpe) {\n      auto l = c.whitespaceOpe->parse(s + len, n - len, sv, c, dt);\n      if (fail(l)) { return static_cast<size_t>(-1); }\n      len += l;\n    }\n  }\n  return len;\n}\n\ninline size_t Holder::parse_core(const char *s, size_t n, SemanticValues &sv,\n                                 Context &c, any &dt) const {\n  if (!ope_) {\n    throw std::logic_error(\"Uninitialized definition ope was used...\");\n  }\n\n  // Macro reference\n  if (outer_->is_macro) {\n    c.rule_stack.push_back(outer_);\n    auto len = ope_->parse(s, n, sv, c, dt);\n    c.rule_stack.pop_back();\n    return len;\n  }\n\n  size_t len;\n  any val;\n\n  c.packrat(s, outer_->id, len, val, [&](any &a_val) {\n    if (outer_->enter) { outer_->enter(s, n, dt); }\n\n    auto se2 = make_scope_exit([&]() {\n      c.pop();\n\n      if (outer_->leave) { outer_->leave(s, n, len, a_val, dt); }\n    });\n\n    auto &chldsv = c.push();\n\n    c.rule_stack.push_back(outer_);\n    len = ope_->parse(s, n, chldsv, c, dt);\n    c.rule_stack.pop_back();\n\n    // Invoke action\n    if (success(len)) {\n      chldsv.s_ = s;\n      chldsv.n_ = len;\n      chldsv.name_ = outer_->name;\n\n      if (!IsPrioritizedChoice::check(*ope_)) {\n        chldsv.choice_count_ = 0;\n        chldsv.choice_ = 0;\n      }\n\n      try {\n        a_val = reduce(chldsv, dt);\n      } catch (const parse_error &e) {\n        if (e.what()) {\n          if (c.message_pos < s) {\n            c.message_pos = s;\n            c.message = e.what();\n          }\n        }\n        len = static_cast<size_t>(-1);\n      }\n    }\n  });\n\n  if (success(len)) {\n    if (!outer_->ignoreSemanticValue) {\n      sv.emplace_back(std::move(val));\n      sv.tags.emplace_back(str2tag(outer_->name.c_str()));\n    }\n  } else {\n    if (outer_->error_message) {\n      if (c.message_pos < s) {\n        c.message_pos = s;\n        c.message = outer_->error_message();\n      }\n    }\n  }\n\n  return len;\n}\n\ninline any Holder::reduce(SemanticValues &sv, any &dt) const {\n  if (outer_->action && !outer_->disable_action) {\n    return outer_->action(sv, dt);\n  } else if (sv.empty()) {\n    return any();\n  } else {\n    return std::move(sv.front());\n  }\n}\n\ninline const char *Holder::trace_name() const {\n  if (trace_name_.empty()) { trace_name_ = \"[\" + outer_->name + \"]\"; }\n  return trace_name_.c_str();\n}\n\ninline size_t Reference::parse_core(const char *s, size_t n, SemanticValues &sv,\n                                    Context &c, any &dt) const {\n  if (rule_) {\n    // Reference rule\n    if (rule_->is_macro) {\n      // Macro\n      FindReference vis(c.top_args(), c.rule_stack.back()->params);\n\n      // Collect arguments\n      std::vector<std::shared_ptr<Ope>> args;\n      for (auto arg : args_) {\n        arg->accept(vis);\n        args.emplace_back(std::move(vis.found_ope));\n      }\n\n      c.push_args(std::move(args));\n      auto se = make_scope_exit([&]() { c.pop_args(); });\n      auto ope = get_core_operator();\n      return ope->parse(s, n, sv, c, dt);\n    } else {\n      // Definition\n      c.push_args(std::vector<std::shared_ptr<Ope>>());\n      auto se = make_scope_exit([&]() { c.pop_args(); });\n      auto ope = get_core_operator();\n      return ope->parse(s, n, sv, c, dt);\n    }\n  } else {\n    // Reference parameter in macro\n    const auto &args = c.top_args();\n    return args[iarg_]->parse(s, n, sv, c, dt);\n  }\n}\n\ninline std::shared_ptr<Ope> Reference::get_core_operator() const {\n  return rule_->holder_;\n}\n\ninline size_t BackReference::parse_core(const char *s, size_t n,\n                                        SemanticValues &sv, Context &c,\n                                        any &dt) const {\n  auto size = static_cast<int>(c.capture_scope_stack_size);\n  for (auto i = size - 1; i >= 0; i--) {\n    auto index = static_cast<size_t>(i);\n    const auto &cs = c.capture_scope_stack[index];\n    if (cs.find(name_) != cs.end()) {\n      const auto &lit = cs.at(name_);\n      std::once_flag init_is_word;\n      auto is_word = false;\n      return parse_literal(s, n, sv, c, dt, lit, init_is_word, is_word, false);\n    }\n  }\n  throw std::runtime_error(\"Invalid back reference...\");\n}\n\ninline Definition &\nPrecedenceClimbing::get_reference_for_binop(Context &c) const {\n  if (rule_.is_macro) {\n    // Reference parameter in macro\n    const auto &args = c.top_args();\n    auto iarg = dynamic_cast<Reference &>(*binop_).iarg_;\n    auto arg = args[iarg];\n    return *dynamic_cast<Reference &>(*arg).rule_;\n  }\n\n  return *dynamic_cast<Reference &>(*binop_).rule_;\n}\n\ninline size_t PrecedenceClimbing::parse_expression(const char *s, size_t n,\n                                                   SemanticValues &sv,\n                                                   Context &c, any &dt,\n                                                   size_t min_prec) const {\n  auto len = atom_->parse(s, n, sv, c, dt);\n  if (fail(len)) { return len; }\n\n  std::string tok;\n  auto &rule = get_reference_for_binop(c);\n  auto action = rule.action;\n\n  rule.action = [&](SemanticValues &sv2, any &dt2) -> any {\n    tok = sv2.token();\n    if (action) {\n      return action(sv2, dt2);\n    } else if (!sv2.empty()) {\n      return sv2[0];\n    }\n    return any();\n  };\n  auto action_se = make_scope_exit([&]() { rule.action = action; });\n\n  auto save_error_pos = c.error_pos;\n\n  auto i = len;\n  while (i < n) {\n    std::vector<any> save_values(sv.begin(), sv.end());\n    auto save_tokens = sv.tokens;\n\n    auto chv = c.push();\n    auto chl = binop_->parse(s + i, n - i, chv, c, dt);\n    c.pop();\n\n    if (fail(chl)) {\n      c.error_pos = save_error_pos;\n      break;\n    }\n\n    auto it = info_.find(tok);\n    if (it == info_.end()) { break; }\n\n    auto level = std::get<0>(it->second);\n    auto assoc = std::get<1>(it->second);\n\n    if (level < min_prec) { break; }\n\n    sv.emplace_back(std::move(chv[0]));\n    i += chl;\n\n    auto next_min_prec = level;\n    if (assoc == 'L') { next_min_prec = level + 1; }\n\n    chv = c.push();\n    chl = parse_expression(s + i, n - i, chv, c, dt, next_min_prec);\n    c.pop();\n\n    if (fail(chl)) {\n      sv.assign(save_values.begin(), save_values.end());\n      sv.tokens = save_tokens;\n      c.error_pos = save_error_pos;\n      break;\n    }\n\n    sv.emplace_back(std::move(chv[0]));\n    i += chl;\n\n    any val;\n    if (rule_.action) {\n      sv.s_ = s;\n      sv.n_ = i;\n      val = rule_.action(sv, dt);\n    } else if (!sv.empty()) {\n      val = sv[0];\n    }\n    sv.clear();\n    sv.emplace_back(std::move(val));\n  }\n\n  return i;\n}\n\ninline void Sequence::accept(Visitor &v) { v.visit(*this); }\ninline void PrioritizedChoice::accept(Visitor &v) { v.visit(*this); }\ninline void Repetition::accept(Visitor &v) { v.visit(*this); }\ninline void AndPredicate::accept(Visitor &v) { v.visit(*this); }\ninline void NotPredicate::accept(Visitor &v) { v.visit(*this); }\ninline void Dictionary::accept(Visitor &v) { v.visit(*this); }\ninline void LiteralString::accept(Visitor &v) { v.visit(*this); }\ninline void CharacterClass::accept(Visitor &v) { v.visit(*this); }\ninline void Character::accept(Visitor &v) { v.visit(*this); }\ninline void AnyCharacter::accept(Visitor &v) { v.visit(*this); }\ninline void CaptureScope::accept(Visitor &v) { v.visit(*this); }\ninline void Capture::accept(Visitor &v) { v.visit(*this); }\ninline void TokenBoundary::accept(Visitor &v) { v.visit(*this); }\ninline void Ignore::accept(Visitor &v) { v.visit(*this); }\ninline void User::accept(Visitor &v) { v.visit(*this); }\ninline void WeakHolder::accept(Visitor &v) { v.visit(*this); }\ninline void Holder::accept(Visitor &v) { v.visit(*this); }\ninline void Reference::accept(Visitor &v) { v.visit(*this); }\ninline void Whitespace::accept(Visitor &v) { v.visit(*this); }\ninline void BackReference::accept(Visitor &v) { v.visit(*this); }\ninline void PrecedenceClimbing::accept(Visitor &v) { v.visit(*this); }\n\ninline void AssignIDToDefinition::visit(Holder &ope) {\n  auto p = static_cast<void *>(ope.outer_);\n  if (ids.count(p)) { return; }\n  auto id = ids.size();\n  ids[p] = id;\n  ope.outer_->id = id;\n  ope.ope_->accept(*this);\n}\n\ninline void AssignIDToDefinition::visit(Reference &ope) {\n  if (ope.rule_) {\n    for (auto arg : ope.args_) {\n      arg->accept(*this);\n    }\n    ope.rule_->accept(*this);\n  }\n}\n\ninline void AssignIDToDefinition::visit(PrecedenceClimbing &ope) {\n  ope.atom_->accept(*this);\n  ope.binop_->accept(*this);\n}\n\ninline void TokenChecker::visit(WeakHolder & /*ope*/) { has_rule_ = true; }\n\ninline void TokenChecker::visit(Reference &ope) {\n  if (ope.is_macro_) {\n    ope.rule_->accept(*this);\n    for (auto arg : ope.args_) {\n      arg->accept(*this);\n    }\n  } else {\n    has_rule_ = true;\n  }\n}\n\ninline void DetectLeftRecursion::visit(Reference &ope) {\n  if (ope.name_ == name_) {\n    error_s = ope.s_;\n  } else if (!refs_.count(ope.name_)) {\n    refs_.insert(ope.name_);\n    if (ope.rule_) {\n      ope.rule_->accept(*this);\n      if (done_ == false) { return; }\n    }\n  }\n  done_ = true;\n}\n\ninline void HasEmptyElement::visit(Reference &ope) {\n  auto it = std::find_if(refs_.begin(), refs_.end(),\n                         [&](const std::pair<const char *, std::string> &ref) {\n                           return ope.name_ == ref.second;\n                         });\n  if (it != refs_.end()) { return; }\n\n  if (ope.rule_) {\n    refs_.emplace_back(ope.s_, ope.name_);\n    ope.rule_->accept(*this);\n    refs_.pop_back();\n  }\n}\n\ninline void DetectInfiniteLoop::visit(Reference &ope) {\n  auto it = std::find_if(refs_.begin(), refs_.end(),\n                         [&](const std::pair<const char *, std::string> &ref) {\n                           return ope.name_ == ref.second;\n                         });\n  if (it != refs_.end()) { return; }\n\n  if (ope.rule_) {\n    refs_.emplace_back(ope.s_, ope.name_);\n    ope.rule_->accept(*this);\n    refs_.pop_back();\n  }\n}\n\ninline void ReferenceChecker::visit(Reference &ope) {\n  auto it = std::find(params_.begin(), params_.end(), ope.name_);\n  if (it != params_.end()) { return; }\n\n  if (!grammar_.count(ope.name_)) {\n    error_s[ope.name_] = ope.s_;\n    error_message[ope.name_] = \"'\" + ope.name_ + \"' is not defined.\";\n  } else {\n    const auto &rule = grammar_.at(ope.name_);\n    if (rule.is_macro) {\n      if (!ope.is_macro_ || ope.args_.size() != rule.params.size()) {\n        error_s[ope.name_] = ope.s_;\n        error_message[ope.name_] = \"incorrect number of arguments.\";\n      }\n    } else if (ope.is_macro_) {\n      error_s[ope.name_] = ope.s_;\n      error_message[ope.name_] = \"'\" + ope.name_ + \"' is not macro.\";\n    }\n  }\n}\n\ninline void LinkReferences::visit(Reference &ope) {\n  // Check if the reference is a macro parameter\n  auto found_param = false;\n  for (size_t i = 0; i < params_.size(); i++) {\n    const auto &param = params_[i];\n    if (param == ope.name_) {\n      ope.iarg_ = i;\n      found_param = true;\n      break;\n    }\n  }\n\n  // Check if the reference is a definition rule\n  if (!found_param && grammar_.count(ope.name_)) {\n    auto &rule = grammar_.at(ope.name_);\n    ope.rule_ = &rule;\n  }\n\n  for (auto arg : ope.args_) {\n    arg->accept(*this);\n  }\n}\n\ninline void FindReference::visit(Reference &ope) {\n  for (size_t i = 0; i < args_.size(); i++) {\n    const auto &name = params_[i];\n    if (name == ope.name_) {\n      found_ope = args_[i];\n      return;\n    }\n  }\n  found_ope = ope.shared_from_this();\n}\n\n/*-----------------------------------------------------------------------------\n *  PEG parser generator\n *---------------------------------------------------------------------------*/\n\ntypedef std::unordered_map<std::string, std::shared_ptr<Ope>> Rules;\ntypedef std::function<void(size_t, size_t, const std::string &)> Log;\n\nclass ParserGenerator {\npublic:\n  static std::shared_ptr<Grammar> parse(const char *s, size_t n,\n                                        const Rules &rules, std::string &start,\n                                        Log log) {\n    return get_instance().perform_core(s, n, rules, start, log);\n  }\n\n  static std::shared_ptr<Grammar> parse(const char *s, size_t n,\n                                        std::string &start, Log log) {\n    Rules dummy;\n    return parse(s, n, dummy, start, log);\n  }\n\n  // For debuging purpose\n  static Grammar &grammar() { return get_instance().g; }\n\nprivate:\n  static ParserGenerator &get_instance() {\n    static ParserGenerator instance;\n    return instance;\n  }\n\n  ParserGenerator() {\n    make_grammar();\n    setup_actions();\n  }\n\n  struct Instruction {\n    std::string type;\n    any data;\n  };\n\n  struct Data {\n    std::shared_ptr<Grammar> grammar;\n    std::string start;\n    const char *start_pos = nullptr;\n    std::vector<std::pair<std::string, const char *>> duplicates;\n    std::map<std::string, Instruction> instructions;\n\n    Data() : grammar(std::make_shared<Grammar>()) {}\n  };\n\n  void make_grammar() {\n    // Setup PEG syntax parser\n    g[\"Grammar\"] <= seq(g[\"Spacing\"], oom(g[\"Definition\"]), g[\"EndOfFile\"]);\n    g[\"Definition\"] <=\n        cho(seq(g[\"Ignore\"], g[\"IdentCont\"], g[\"Parameters\"], g[\"LEFTARROW\"],\n                g[\"Expression\"], opt(g[\"Instruction\"])),\n            seq(g[\"Ignore\"], g[\"Identifier\"], g[\"LEFTARROW\"], g[\"Expression\"],\n                opt(g[\"Instruction\"])));\n    g[\"Expression\"] <= seq(g[\"Sequence\"], zom(seq(g[\"SLASH\"], g[\"Sequence\"])));\n    g[\"Sequence\"] <= zom(g[\"Prefix\"]);\n    g[\"Prefix\"] <= seq(opt(cho(g[\"AND\"], g[\"NOT\"])), g[\"Suffix\"]);\n    g[\"Suffix\"] <= seq(g[\"Primary\"], opt(g[\"Loop\"]));\n    g[\"Loop\"] <= cho(g[\"QUESTION\"], g[\"STAR\"], g[\"PLUS\"], g[\"Repetition\"]);\n    g[\"Primary\"] <=\n        cho(seq(g[\"Ignore\"], g[\"IdentCont\"], g[\"Arguments\"],\n                npd(g[\"LEFTARROW\"])),\n            seq(g[\"Ignore\"], g[\"Identifier\"],\n                npd(seq(opt(g[\"Parameters\"]), g[\"LEFTARROW\"]))),\n            seq(g[\"OPEN\"], g[\"Expression\"], g[\"CLOSE\"]),\n            seq(g[\"BeginTok\"], g[\"Expression\"], g[\"EndTok\"]),\n            seq(g[\"BeginCapScope\"], g[\"Expression\"], g[\"EndCapScope\"]),\n            seq(g[\"BeginCap\"], g[\"Expression\"], g[\"EndCap\"]), g[\"BackRef\"],\n            g[\"LiteralI\"], g[\"Dictionary\"], g[\"Literal\"], g[\"NegatedClass\"],\n            g[\"Class\"], g[\"DOT\"]);\n\n    g[\"Identifier\"] <= seq(g[\"IdentCont\"], g[\"Spacing\"]);\n    g[\"IdentCont\"] <= seq(g[\"IdentStart\"], zom(g[\"IdentRest\"]));\n\n    const static std::vector<std::pair<char32_t, char32_t>> range = {\n        {0x0080, 0xFFFF}};\n    g[\"IdentStart\"] <= cho(cls(\"a-zA-Z_%\"), cls(range));\n\n    g[\"IdentRest\"] <= cho(g[\"IdentStart\"], cls(\"0-9\"));\n\n    g[\"Dictionary\"] <= seq(g[\"LiteralD\"], oom(seq(g[\"PIPE\"], g[\"LiteralD\"])));\n\n    auto lit_ope = cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))),\n                           cls(\"'\"), g[\"Spacing\"]),\n                       seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))),\n                           cls(\"\\\"\"), g[\"Spacing\"]));\n    g[\"Literal\"] <= lit_ope;\n    g[\"LiteralD\"] <= lit_ope;\n\n    g[\"LiteralI\"] <=\n        cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))), lit(\"'i\"),\n                g[\"Spacing\"]),\n            seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))), lit(\"\\\"i\"),\n                g[\"Spacing\"]));\n\n    // NOTE: The original Brian Ford's paper uses 'zom' instead of 'oom'.\n    g[\"Class\"] <= seq(chr('['), npd(chr('^')),\n                      tok(oom(seq(npd(chr(']')), g[\"Range\"]))), chr(']'),\n                      g[\"Spacing\"]);\n    g[\"NegatedClass\"] <= seq(lit(\"[^\"),\n                             tok(oom(seq(npd(chr(']')), g[\"Range\"]))), chr(']'),\n                             g[\"Spacing\"]);\n\n    g[\"Range\"] <= cho(seq(g[\"Char\"], chr('-'), g[\"Char\"]), g[\"Char\"]);\n    g[\"Char\"] <= cho(seq(chr('\\\\'), cls(\"nrt'\\\"[]\\\\^\")),\n                     seq(chr('\\\\'), cls(\"0-3\"), cls(\"0-7\"), cls(\"0-7\")),\n                     seq(chr('\\\\'), cls(\"0-7\"), opt(cls(\"0-7\"))),\n                     seq(lit(\"\\\\x\"), cls(\"0-9a-fA-F\"), opt(cls(\"0-9a-fA-F\"))),\n                     seq(lit(\"\\\\u\"), cls(\"0-9a-fA-F\"), cls(\"0-9a-fA-F\"),\n                         cls(\"0-9a-fA-F\"), cls(\"0-9a-fA-F\")),\n                     seq(npd(chr('\\\\')), dot()));\n\n    g[\"Repetition\"] <=\n        seq(g[\"BeginBlacket\"], g[\"RepetitionRange\"], g[\"EndBlacket\"]);\n    g[\"RepetitionRange\"] <= cho(seq(g[\"Number\"], g[\"COMMA\"], g[\"Number\"]),\n                                seq(g[\"Number\"], g[\"COMMA\"]), g[\"Number\"],\n                                seq(g[\"COMMA\"], g[\"Number\"]));\n    g[\"Number\"] <= seq(oom(cls(\"0-9\")), g[\"Spacing\"]);\n\n    g[\"LEFTARROW\"] <=\n        seq(cho(lit(\"<-\"), lit(reinterpret_cast<const char *>(u8\"\u2190\"))),\n            g[\"Spacing\"]);\n    ~g[\"SLASH\"] <= seq(chr('/'), g[\"Spacing\"]);\n    ~g[\"PIPE\"] <= seq(chr('|'), g[\"Spacing\"]);\n    g[\"AND\"] <= seq(chr('&'), g[\"Spacing\"]);\n    g[\"NOT\"] <= seq(chr('!'), g[\"Spacing\"]);\n    g[\"QUESTION\"] <= seq(chr('?'), g[\"Spacing\"]);\n    g[\"STAR\"] <= seq(chr('*'), g[\"Spacing\"]);\n    g[\"PLUS\"] <= seq(chr('+'), g[\"Spacing\"]);\n    ~g[\"OPEN\"] <= seq(chr('('), g[\"Spacing\"]);\n    ~g[\"CLOSE\"] <= seq(chr(')'), g[\"Spacing\"]);\n    g[\"DOT\"] <= seq(chr('.'), g[\"Spacing\"]);\n\n    ~g[\"Spacing\"] <= zom(cho(g[\"Space\"], g[\"Comment\"]));\n    g[\"Comment\"] <=\n        seq(chr('#'), zom(seq(npd(g[\"EndOfLine\"]), dot())), g[\"EndOfLine\"]);\n    g[\"Space\"] <= cho(chr(' '), chr('\\t'), g[\"EndOfLine\"]);\n    g[\"EndOfLine\"] <= cho(lit(\"\\r\\n\"), chr('\\n'), chr('\\r'));\n    g[\"EndOfFile\"] <= npd(dot());\n\n    ~g[\"BeginTok\"] <= seq(chr('<'), g[\"Spacing\"]);\n    ~g[\"EndTok\"] <= seq(chr('>'), g[\"Spacing\"]);\n\n    ~g[\"BeginCapScope\"] <= seq(chr('$'), chr('('), g[\"Spacing\"]);\n    ~g[\"EndCapScope\"] <= seq(chr(')'), g[\"Spacing\"]);\n\n    g[\"BeginCap\"] <= seq(chr('$'), tok(g[\"IdentCont\"]), chr('<'), g[\"Spacing\"]);\n    ~g[\"EndCap\"] <= seq(chr('>'), g[\"Spacing\"]);\n\n    g[\"BackRef\"] <= seq(chr('$'), tok(g[\"IdentCont\"]), g[\"Spacing\"]);\n\n    g[\"IGNORE\"] <= chr('~');\n\n    g[\"Ignore\"] <= opt(g[\"IGNORE\"]);\n    g[\"Parameters\"] <= seq(g[\"OPEN\"], g[\"Identifier\"],\n                           zom(seq(g[\"COMMA\"], g[\"Identifier\"])), g[\"CLOSE\"]);\n    g[\"Arguments\"] <= seq(g[\"OPEN\"], g[\"Expression\"],\n                          zom(seq(g[\"COMMA\"], g[\"Expression\"])), g[\"CLOSE\"]);\n    ~g[\"COMMA\"] <= seq(chr(','), g[\"Spacing\"]);\n\n    // Instruction grammars\n    g[\"Instruction\"] <=\n        seq(g[\"BeginBlacket\"], cho(g[\"PrecedenceClimbing\"]), g[\"EndBlacket\"]);\n\n    ~g[\"SpacesZom\"] <= zom(g[\"Space\"]);\n    ~g[\"SpacesOom\"] <= oom(g[\"Space\"]);\n    ~g[\"BeginBlacket\"] <= seq(chr('{'), g[\"Spacing\"]);\n    ~g[\"EndBlacket\"] <= seq(chr('}'), g[\"Spacing\"]);\n\n    // PrecedenceClimbing instruction\n    g[\"PrecedenceClimbing\"] <=\n        seq(lit(\"precedence\"), g[\"SpacesZom\"], g[\"PrecedenceInfo\"],\n            zom(seq(g[\"SpacesOom\"], g[\"PrecedenceInfo\"])), g[\"SpacesZom\"]);\n    g[\"PrecedenceInfo\"] <=\n        seq(g[\"PrecedenceAssoc\"],\n            oom(seq(ign(g[\"SpacesOom\"]), g[\"PrecedenceOpe\"])));\n    g[\"PrecedenceOpe\"] <=\n        tok(oom(\n            seq(npd(cho(g[\"PrecedenceAssoc\"], g[\"Space\"], chr('}'))), dot())));\n    g[\"PrecedenceAssoc\"] <= cls(\"LR\");\n\n    // Set definition names\n    for (auto &x : g) {\n      x.second.name = x.first;\n    }\n  }\n\n  void setup_actions() {\n    g[\"Definition\"] = [&](const SemanticValues &sv, any &dt) {\n      Data &data = *any_cast<Data *>(dt);\n\n      auto is_macro = sv.choice() == 0;\n      auto ignore = any_cast<bool>(sv[0]);\n      auto name = any_cast<std::string>(sv[1]);\n\n      std::vector<std::string> params;\n      std::shared_ptr<Ope> ope;\n      if (is_macro) {\n        params = any_cast<std::vector<std::string>>(sv[2]);\n        ope = any_cast<std::shared_ptr<Ope>>(sv[4]);\n        if (sv.size() == 6) {\n          data.instructions[name] = any_cast<Instruction>(sv[5]);\n        }\n      } else {\n        ope = any_cast<std::shared_ptr<Ope>>(sv[3]);\n        if (sv.size() == 5) {\n          data.instructions[name] = any_cast<Instruction>(sv[4]);\n        }\n      }\n\n      auto &grammar = *data.grammar;\n      if (!grammar.count(name)) {\n        auto &rule = grammar[name];\n        rule <= ope;\n        rule.name = name;\n        rule.s_ = sv.c_str();\n        rule.ignoreSemanticValue = ignore;\n        rule.is_macro = is_macro;\n        rule.params = params;\n\n        if (data.start.empty()) {\n          data.start = name;\n          data.start_pos = sv.c_str();\n        }\n      } else {\n        data.duplicates.emplace_back(name, sv.c_str());\n      }\n    };\n\n    g[\"Expression\"] = [&](const SemanticValues &sv) {\n      if (sv.size() == 1) {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        std::vector<std::shared_ptr<Ope>> opes;\n        for (auto i = 0u; i < sv.size(); i++) {\n          opes.emplace_back(any_cast<std::shared_ptr<Ope>>(sv[i]));\n        }\n        const std::shared_ptr<Ope> ope =\n            std::make_shared<PrioritizedChoice>(opes);\n        return ope;\n      }\n    };\n\n    g[\"Sequence\"] = [&](const SemanticValues &sv) {\n      if (sv.size() == 1) {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        std::vector<std::shared_ptr<Ope>> opes;\n        for (const auto &x : sv) {\n          opes.emplace_back(any_cast<std::shared_ptr<Ope>>(x));\n        }\n        const std::shared_ptr<Ope> ope = std::make_shared<Sequence>(opes);\n        return ope;\n      }\n    };\n\n    g[\"Prefix\"] = [&](const SemanticValues &sv) {\n      std::shared_ptr<Ope> ope;\n      if (sv.size() == 1) {\n        ope = any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        assert(sv.size() == 2);\n        auto tok = any_cast<char>(sv[0]);\n        ope = any_cast<std::shared_ptr<Ope>>(sv[1]);\n        if (tok == '&') {\n          ope = apd(ope);\n        } else { // '!'\n          ope = npd(ope);\n        }\n      }\n      return ope;\n    };\n\n    struct Loop {\n      enum class Type { opt = 0, zom, oom, rep };\n      Type type;\n      std::pair<size_t, size_t> range;\n    };\n\n    g[\"Suffix\"] = [&](const SemanticValues &sv) {\n      auto ope = any_cast<std::shared_ptr<Ope>>(sv[0]);\n      if (sv.size() == 1) {\n        return ope;\n      } else {\n        assert(sv.size() == 2);\n        auto loop = any_cast<Loop>(sv[1]);\n        switch (loop.type) {\n        case Loop::Type::opt: return opt(ope);\n        case Loop::Type::zom: return zom(ope);\n        case Loop::Type::oom: return oom(ope);\n        default: // Regex-like repetition\n          return rep(ope, loop.range.first, loop.range.second);\n        }\n      }\n    };\n\n    g[\"Loop\"] = [&](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: // Option\n        return Loop{Loop::Type::opt, std::pair<size_t, size_t>()};\n      case 1: // Zero or More\n        return Loop{Loop::Type::zom, std::pair<size_t, size_t>()};\n      case 2: // One or More\n        return Loop{Loop::Type::oom, std::pair<size_t, size_t>()};\n      default: // Regex-like repetition\n        return Loop{Loop::Type::rep,\n                    any_cast<std::pair<size_t, size_t>>(sv[0])};\n      }\n    };\n\n    g[\"RepetitionRange\"] = [&](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: { // Number COMMA Number\n        auto min = any_cast<size_t>(sv[0]);\n        auto max = any_cast<size_t>(sv[1]);\n        return std::make_pair(min, max);\n      }\n      case 1: // Number COMMA\n        return std::make_pair(any_cast<size_t>(sv[0]),\n                              std::numeric_limits<size_t>::max());\n      case 2: { // Number\n        auto n = any_cast<size_t>(sv[0]);\n        return std::make_pair(n, n);\n      }\n      default: // COMMA Number\n        return std::make_pair(std::numeric_limits<size_t>::min(),\n                              any_cast<size_t>(sv[0]));\n      }\n    };\n    g[\"Number\"] = [&](const SemanticValues &sv) {\n      std::stringstream ss(sv.str());\n      size_t n;\n      ss >> n;\n      return n;\n    };\n\n    g[\"Primary\"] = [&](const SemanticValues &sv, any &dt) {\n      Data &data = *any_cast<Data *>(dt);\n\n      switch (sv.choice()) {\n      case 0:   // Macro Reference\n      case 1: { // Reference\n        auto is_macro = sv.choice() == 0;\n        auto ignore = any_cast<bool>(sv[0]);\n        const auto &ident = any_cast<std::string>(sv[1]);\n\n        std::vector<std::shared_ptr<Ope>> args;\n        if (is_macro) {\n          args = any_cast<std::vector<std::shared_ptr<Ope>>>(sv[2]);\n        }\n\n        std::shared_ptr<Ope> ope =\n            ref(*data.grammar, ident, sv.c_str(), is_macro, args);\n\n        if (ignore) {\n          return ign(ope);\n        } else {\n          return ope;\n        }\n      }\n      case 2: { // (Expression)\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      }\n      case 3: { // TokenBoundary\n        return tok(any_cast<std::shared_ptr<Ope>>(sv[0]));\n      }\n      case 4: { // CaptureScope\n        return csc(any_cast<std::shared_ptr<Ope>>(sv[0]));\n      }\n      case 5: { // Capture\n        const auto &name = any_cast<std::string>(sv[0]);\n        auto ope = any_cast<std::shared_ptr<Ope>>(sv[1]);\n        return cap(ope, [name](const char *a_s, size_t a_n, Context &c) {\n          auto &cs = c.capture_scope_stack[c.capture_scope_stack_size - 1];\n          cs[name] = std::string(a_s, a_n);\n        });\n      }\n      default: {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      }\n      }\n    };\n\n    g[\"IdentCont\"] = [](const SemanticValues &sv) {\n      return std::string(sv.c_str(), sv.length());\n    };\n\n    g[\"Dictionary\"] = [](const SemanticValues &sv) {\n      auto items = sv.transform<std::string>();\n      return dic(items);\n    };\n\n    g[\"Literal\"] = [](const SemanticValues &sv) {\n      const auto &tok = sv.tokens.front();\n      return lit(resolve_escape_sequence(tok.first, tok.second));\n    };\n    g[\"LiteralI\"] = [](const SemanticValues &sv) {\n      const auto &tok = sv.tokens.front();\n      return liti(resolve_escape_sequence(tok.first, tok.second));\n    };\n    g[\"LiteralD\"] = [](const SemanticValues &sv) {\n      auto &tok = sv.tokens.front();\n      return resolve_escape_sequence(tok.first, tok.second);\n    };\n\n    g[\"Class\"] = [](const SemanticValues &sv) {\n      auto ranges = sv.transform<std::pair<char32_t, char32_t>>();\n      return cls(ranges);\n    };\n    g[\"NegatedClass\"] = [](const SemanticValues &sv) {\n      auto ranges = sv.transform<std::pair<char32_t, char32_t>>();\n      return ncls(ranges);\n    };\n    g[\"Range\"] = [](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: {\n        auto s1 = any_cast<std::string>(sv[0]);\n        auto s2 = any_cast<std::string>(sv[1]);\n        auto cp1 = decode_codepoint(s1.c_str(), s1.length());\n        auto cp2 = decode_codepoint(s2.c_str(), s2.length());\n        return std::make_pair(cp1, cp2);\n      }\n      case 1: {\n        auto s = any_cast<std::string>(sv[0]);\n        auto cp = decode_codepoint(s.c_str(), s.length());\n        return std::make_pair(cp, cp);\n      }\n      }\n      return std::make_pair<char32_t, char32_t>(0, 0);\n    };\n    g[\"Char\"] = [](const SemanticValues &sv) {\n      return resolve_escape_sequence(sv.c_str(), sv.length());\n    };\n\n    g[\"AND\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"NOT\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"QUESTION\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"STAR\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"PLUS\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n\n    g[\"DOT\"] = [](const SemanticValues & /*sv*/) { return dot(); };\n\n    g[\"BeginCap\"] = [](const SemanticValues &sv) { return sv.token(); };\n\n    g[\"BackRef\"] = [&](const SemanticValues &sv) { return bkr(sv.token()); };\n\n    g[\"Ignore\"] = [](const SemanticValues &sv) { return sv.size() > 0; };\n\n    g[\"Parameters\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::string>();\n    };\n\n    g[\"Arguments\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::shared_ptr<Ope>>();\n    };\n\n    g[\"PrecedenceClimbing\"] = [](const SemanticValues &sv) {\n      PrecedenceClimbing::BinOpeInfo binOpeInfo;\n      size_t level = 1;\n      for (auto v : sv) {\n        auto tokens = any_cast<std::vector<std::string>>(v);\n        auto assoc = tokens[0][0];\n        for (size_t i = 1; i < tokens.size(); i++) {\n          const auto &tok = tokens[i];\n          binOpeInfo[tok] = std::make_pair(level, assoc);\n        }\n        level++;\n      }\n      Instruction instruction;\n      instruction.type = \"precedence\";\n      instruction.data = binOpeInfo;\n      return instruction;\n    };\n    g[\"PrecedenceInfo\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::string>();\n    };\n    g[\"PrecedenceOpe\"] = [](const SemanticValues &sv) { return sv.token(); };\n    g[\"PrecedenceAssoc\"] = [](const SemanticValues &sv) { return sv.token(); };\n  }\n\n  bool apply_precedence_instruction(Definition &rule,\n                                    const PrecedenceClimbing::BinOpeInfo &info,\n                                    const char *s, Log log) {\n    try {\n      auto &seq = dynamic_cast<Sequence &>(*rule.get_core_operator());\n      auto atom = seq.opes_[0];\n      auto &rep = dynamic_cast<Repetition &>(*seq.opes_[1]);\n      auto &seq1 = dynamic_cast<Sequence &>(*rep.ope_);\n      auto binop = seq1.opes_[0];\n      auto atom1 = seq1.opes_[1];\n\n      auto atom_name = dynamic_cast<Reference &>(*atom).name_;\n      auto binop_name = dynamic_cast<Reference &>(*binop).name_;\n      auto atom1_name = dynamic_cast<Reference &>(*atom1).name_;\n\n      if (!rep.is_zom() || atom_name != atom1_name || atom_name == binop_name) {\n        if (log) {\n          auto line = line_info(s, rule.s_);\n          log(line.first, line.second,\n              \"'precedence' instruction cannt be applied to '\" + rule.name +\n                  \"'.\");\n        }\n        return false;\n      }\n\n      rule.holder_->ope_ = pre(atom, binop, info, rule);\n      rule.disable_action = true;\n    } catch (...) {\n      if (log) {\n        auto line = line_info(s, rule.s_);\n        log(line.first, line.second,\n            \"'precedence' instruction cannt be applied to '\" + rule.name +\n                \"'.\");\n      }\n      return false;\n    }\n    return true;\n  }\n\n  std::shared_ptr<Grammar> perform_core(const char *s, size_t n,\n                                        const Rules &rules, std::string &start,\n                                        Log log) {\n    Data data;\n    any dt = &data;\n    auto r = g[\"Grammar\"].parse(s, n, dt);\n\n    if (!r.ret) {\n      if (log) {\n        if (r.message_pos) {\n          auto line = line_info(s, r.message_pos);\n          log(line.first, line.second, r.message);\n        } else {\n          auto line = line_info(s, r.error_pos);\n          log(line.first, line.second, \"syntax error\");\n        }\n      }\n      return nullptr;\n    }\n\n    auto &grammar = *data.grammar;\n\n    // User provided rules\n    for (const auto &x : rules) {\n      auto name = x.first;\n      bool ignore = false;\n      if (!name.empty() && name[0] == '~') {\n        ignore = true;\n        name.erase(0, 1);\n      }\n      if (!name.empty()) {\n        auto &rule = grammar[name];\n        rule <= x.second;\n        rule.name = name;\n        rule.ignoreSemanticValue = ignore;\n      }\n    }\n\n    // Check duplicated definitions\n    bool ret = data.duplicates.empty();\n\n    for (const auto &x : data.duplicates) {\n      if (log) {\n        const auto &name = x.first;\n        auto ptr = x.second;\n        auto line = line_info(s, ptr);\n        log(line.first, line.second, \"'\" + name + \"' is already defined.\");\n      }\n    }\n\n    // Check missing definitions\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n\n      ReferenceChecker vis(*data.grammar, rule.params);\n      rule.accept(vis);\n      for (const auto &y : vis.error_s) {\n        const auto &name = y.first;\n        const auto ptr = y.second;\n        if (log) {\n          auto line = line_info(s, ptr);\n          log(line.first, line.second, vis.error_message[name]);\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Link references\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n      LinkReferences vis(*data.grammar, rule.params);\n      rule.accept(vis);\n    }\n\n    // Check left recursion\n    ret = true;\n\n    for (auto &x : grammar) {\n      const auto &name = x.first;\n      auto &rule = x.second;\n\n      DetectLeftRecursion vis(name);\n      rule.accept(vis);\n      if (vis.error_s) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second, \"'\" + name + \"' is left recursive.\");\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Set root definition\n    auto &start_rule = (*data.grammar)[data.start];\n\n    // Check infinite loop\n    {\n      DetectInfiniteLoop vis(data.start_pos, data.start);\n      start_rule.accept(vis);\n      if (vis.has_error) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second,\n              \"infinite loop is detected in '\" + vis.error_name + \"'.\");\n        }\n        return nullptr;\n      }\n    }\n\n    // Automatic whitespace skipping\n    if (grammar.count(WHITESPACE_DEFINITION_NAME)) {\n      for (auto &x : grammar) {\n        auto &rule = x.second;\n        auto ope = rule.get_core_operator();\n        if (IsLiteralToken::check(*ope)) { rule <= tok(ope); }\n      }\n\n      start_rule.whitespaceOpe =\n          wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator());\n    }\n\n    // Word expression\n    if (grammar.count(WORD_DEFINITION_NAME)) {\n      start_rule.wordOpe =\n          (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator();\n    }\n\n    // Apply instructions\n    for (const auto &item : data.instructions) {\n      const auto &name = item.first;\n      const auto &instruction = item.second;\n      auto &rule = grammar[name];\n\n      if (instruction.type == \"precedence\") {\n        const auto &info =\n            any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data);\n\n        if (!apply_precedence_instruction(rule, info, s, log)) {\n          return nullptr;\n        }\n      }\n    }\n\n    // Set root definition\n    start = data.start;\n\n    return data.grammar;\n  }\n\n  Grammar g;\n};\n\n/*-----------------------------------------------------------------------------\n *  AST\n *---------------------------------------------------------------------------*/\n\ntemplate <typename Annotation> struct AstBase : public Annotation {\n  AstBase(const char *a_path, size_t a_line, size_t a_column,\n          const char *a_name,\n          const std::vector<std::shared_ptr<AstBase>> &a_nodes,\n          size_t a_position = 0, size_t a_length = 0, size_t a_choice_count = 0,\n          size_t a_choice = 0)\n      : path(a_path ? a_path : \"\"), line(a_line), column(a_column),\n        name(a_name), position(a_position), length(a_length),\n        choice_count(a_choice_count), choice(a_choice), original_name(a_name),\n        original_choice_count(a_choice_count), original_choice(a_choice),\n        tag(str2tag(a_name)), original_tag(tag), is_token(false),\n        nodes(a_nodes) {}\n\n  AstBase(const char *a_path, size_t a_line, size_t a_column,\n          const char *a_name, const std::string &a_token, size_t a_position = 0,\n          size_t a_length = 0, size_t a_choice_count = 0, size_t a_choice = 0)\n      : path(a_path ? a_path : \"\"), line(a_line), column(a_column),\n        name(a_name), position(a_position), length(a_length),\n        choice_count(a_choice_count), choice(a_choice), original_name(a_name),\n        original_choice_count(a_choice_count), original_choice(a_choice),\n        tag(str2tag(a_name)), original_tag(tag), is_token(true),\n        token(a_token) {}\n\n  AstBase(const AstBase &ast, const char *a_original_name,\n          size_t a_position = 0, size_t a_length = 0,\n          size_t a_original_choice_count = 0, size_t a_original_choise = 0)\n      : path(ast.path), line(ast.line), column(ast.column), name(ast.name),\n        position(a_position), length(a_length), choice_count(ast.choice_count),\n        choice(ast.choice), original_name(a_original_name),\n        original_choice_count(a_original_choice_count),\n        original_choice(a_original_choise), tag(ast.tag),\n        original_tag(str2tag(a_original_name)), is_token(ast.is_token),\n        token(ast.token), nodes(ast.nodes), parent(ast.parent) {}\n\n  const std::string path;\n  const size_t line = 1;\n  const size_t column = 1;\n\n  const std::string name;\n  size_t position;\n  size_t length;\n  const size_t choice_count;\n  const size_t choice;\n  const std::string original_name;\n  const size_t original_choice_count;\n  const size_t original_choice;\n  const unsigned int tag;\n  const unsigned int original_tag;\n\n  const bool is_token;\n  const std::string token;\n\n  std::vector<std::shared_ptr<AstBase<Annotation>>> nodes;\n  std::weak_ptr<AstBase<Annotation>> parent;\n};\n\ntemplate <typename T>\nvoid ast_to_s_core(const std::shared_ptr<T> &ptr, std::string &s, int level,\n                   std::function<std::string(const T &ast, int level)> fn) {\n  const auto &ast = *ptr;\n  for (auto i = 0; i < level; i++) {\n    s += \"  \";\n  }\n  auto name = ast.original_name;\n  if (ast.original_choice_count > 0) {\n    name += \"/\" + std::to_string(ast.original_choice);\n  }\n  if (ast.name != ast.original_name) { name += \"[\" + ast.name + \"]\"; }\n  if (ast.is_token) {\n    s += \"- \" + name + \" (\" + ast.token + \")\\n\";\n  } else {\n    s += \"+ \" + name + \"\\n\";\n  }\n  if (fn) { s += fn(ast, level + 1); }\n  for (auto node : ast.nodes) {\n    ast_to_s_core(node, s, level + 1, fn);\n  }\n}\n\ntemplate <typename T>\nstd::string\nast_to_s(const std::shared_ptr<T> &ptr,\n         std::function<std::string(const T &ast, int level)> fn = nullptr) {\n  std::string s;\n  ast_to_s_core(ptr, s, 0, fn);\n  return s;\n}\n\nstruct AstOptimizer {\n  AstOptimizer(bool mode, const std::vector<std::string> &rules = {})\n      : mode_(mode), rules_(rules) {}\n\n  template <typename T>\n  std::shared_ptr<T> optimize(std::shared_ptr<T> original,\n                              std::shared_ptr<T> parent = nullptr) {\n    auto found =\n        std::find(rules_.begin(), rules_.end(), original->name) != rules_.end();\n    bool opt = mode_ ? !found : found;\n\n    if (opt && original->nodes.size() == 1) {\n      auto child = optimize(original->nodes[0], parent);\n      return std::make_shared<T>(*child, original->name.c_str(),\n                                 original->choice_count, original->position,\n                                 original->length, original->choice);\n    }\n\n    auto ast = std::make_shared<T>(*original);\n    ast->parent = parent;\n    ast->nodes.clear();\n    for (auto node : original->nodes) {\n      auto child = optimize(node, ast);\n      ast->nodes.push_back(child);\n    }\n    return ast;\n  }\n\nprivate:\n  const bool mode_;\n  const std::vector<std::string> rules_;\n};\n\nstruct EmptyType {};\ntypedef AstBase<EmptyType> Ast;\n\ntemplate <typename T = Ast> void add_ast_action(Definition &rule) {\n  rule.action = [&](const SemanticValues &sv) {\n    auto line = sv.line_info();\n\n    if (rule.is_token()) {\n      return std::make_shared<T>(sv.path, line.first, line.second,\n                                 rule.name.c_str(), sv.token(),\n                                 std::distance(sv.ss, sv.c_str()), sv.length(),\n                                 sv.choice_count(), sv.choice());\n    }\n\n    auto ast = std::make_shared<T>(\n        sv.path, line.first, line.second, rule.name.c_str(),\n        sv.transform<std::shared_ptr<T>>(), std::distance(sv.ss, sv.c_str()),\n        sv.length(), sv.choice_count(), sv.choice());\n\n    for (auto node : ast->nodes) {\n      node->parent = ast;\n    }\n    return ast;\n  };\n}\n\n#define PEG_EXPAND(...) __VA_ARGS__\n#define PEG_CONCAT(a, b) a##b\n#define PEG_CONCAT2(a, b) PEG_CONCAT(a, b)\n\n#define PEG_PICK(                                                              \\\n    a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, \\\n    a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, \\\n    a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, \\\n    a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, \\\n    a62, a63, a64, a65, a66, a67, a68, a69, a70, a71, a72, a73, a74, a75, a76, \\\n    a77, a78, a79, a80, a81, a82, a83, a84, a85, a86, a87, a88, a89, a90, a91, \\\n    a92, a93, a94, a95, a96, a97, a98, a99, a100, ...)                         \\\n  a100\n\n#define PEG_COUNT(...)                                                         \\\n  PEG_EXPAND(PEG_PICK(                                                         \\\n      __VA_ARGS__, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87,    \\\n      86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69,  \\\n      68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51,  \\\n      50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33,  \\\n      32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15,  \\\n      14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0))\n\n#define PEG_DEF_1(r)                                                           \\\n  peg::Definition r;                                                           \\\n  r.name = #r;                                                                 \\\n  peg::add_ast_action(r);\n\n#define PEG_DEF_2(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_1(__VA_ARGS__))\n#define PEG_DEF_3(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_2(__VA_ARGS__))\n#define PEG_DEF_4(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_3(__VA_ARGS__))\n#define PEG_DEF_5(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_4(__VA_ARGS__))\n#define PEG_DEF_6(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_5(__VA_ARGS__))\n#define PEG_DEF_7(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_6(__VA_ARGS__))\n#define PEG_DEF_8(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_7(__VA_ARGS__))\n#define PEG_DEF_9(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_8(__VA_ARGS__))\n#define PEG_DEF_10(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_9(__VA_ARGS__))\n#define PEG_DEF_11(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_10(__VA_ARGS__))\n#define PEG_DEF_12(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_11(__VA_ARGS__))\n#define PEG_DEF_13(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_12(__VA_ARGS__))\n#define PEG_DEF_14(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_13(__VA_ARGS__))\n#define PEG_DEF_15(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_14(__VA_ARGS__))\n#define PEG_DEF_16(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_15(__VA_ARGS__))\n#define PEG_DEF_17(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_16(__VA_ARGS__))\n#define PEG_DEF_18(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_17(__VA_ARGS__))\n#define PEG_DEF_19(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_18(__VA_ARGS__))\n#define PEG_DEF_20(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_19(__VA_ARGS__))\n#define PEG_DEF_21(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_20(__VA_ARGS__))\n#define PEG_DEF_22(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_21(__VA_ARGS__))\n#define PEG_DEF_23(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_22(__VA_ARGS__))\n#define PEG_DEF_24(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_23(__VA_ARGS__))\n#define PEG_DEF_25(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_24(__VA_ARGS__))\n#define PEG_DEF_26(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_25(__VA_ARGS__))\n#define PEG_DEF_27(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_26(__VA_ARGS__))\n#define PEG_DEF_28(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_27(__VA_ARGS__))\n#define PEG_DEF_29(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_28(__VA_ARGS__))\n#define PEG_DEF_30(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_29(__VA_ARGS__))\n#define PEG_DEF_31(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_30(__VA_ARGS__))\n#define PEG_DEF_32(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_31(__VA_ARGS__))\n#define PEG_DEF_33(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_32(__VA_ARGS__))\n#define PEG_DEF_34(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_33(__VA_ARGS__))\n#define PEG_DEF_35(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_34(__VA_ARGS__))\n#define PEG_DEF_36(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_35(__VA_ARGS__))\n#define PEG_DEF_37(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_36(__VA_ARGS__))\n#define PEG_DEF_38(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_37(__VA_ARGS__))\n#define PEG_DEF_39(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_38(__VA_ARGS__))\n#define PEG_DEF_40(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_39(__VA_ARGS__))\n#define PEG_DEF_41(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_40(__VA_ARGS__))\n#define PEG_DEF_42(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_41(__VA_ARGS__))\n#define PEG_DEF_43(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_42(__VA_ARGS__))\n#define PEG_DEF_44(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_43(__VA_ARGS__))\n#define PEG_DEF_45(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_44(__VA_ARGS__))\n#define PEG_DEF_46(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_45(__VA_ARGS__))\n#define PEG_DEF_47(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_46(__VA_ARGS__))\n#define PEG_DEF_48(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_47(__VA_ARGS__))\n#define PEG_DEF_49(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_48(__VA_ARGS__))\n#define PEG_DEF_50(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_49(__VA_ARGS__))\n#define PEG_DEF_51(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_50(__VA_ARGS__))\n#define PEG_DEF_52(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_51(__VA_ARGS__))\n#define PEG_DEF_53(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_52(__VA_ARGS__))\n#define PEG_DEF_54(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_53(__VA_ARGS__))\n#define PEG_DEF_55(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_54(__VA_ARGS__))\n#define PEG_DEF_56(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_55(__VA_ARGS__))\n#define PEG_DEF_57(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_56(__VA_ARGS__))\n#define PEG_DEF_58(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_57(__VA_ARGS__))\n#define PEG_DEF_59(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_58(__VA_ARGS__))\n#define PEG_DEF_60(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_59(__VA_ARGS__))\n#define PEG_DEF_61(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_60(__VA_ARGS__))\n#define PEG_DEF_62(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_61(__VA_ARGS__))\n#define PEG_DEF_63(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_62(__VA_ARGS__))\n#define PEG_DEF_64(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_63(__VA_ARGS__))\n#define PEG_DEF_65(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_64(__VA_ARGS__))\n#define PEG_DEF_66(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_65(__VA_ARGS__))\n#define PEG_DEF_67(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_66(__VA_ARGS__))\n#define PEG_DEF_68(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_67(__VA_ARGS__))\n#define PEG_DEF_69(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_68(__VA_ARGS__))\n#define PEG_DEF_70(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_69(__VA_ARGS__))\n#define PEG_DEF_71(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_70(__VA_ARGS__))\n#define PEG_DEF_72(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_71(__VA_ARGS__))\n#define PEG_DEF_73(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_72(__VA_ARGS__))\n#define PEG_DEF_74(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_73(__VA_ARGS__))\n#define PEG_DEF_75(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_74(__VA_ARGS__))\n#define PEG_DEF_76(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_75(__VA_ARGS__))\n#define PEG_DEF_77(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_76(__VA_ARGS__))\n#define PEG_DEF_78(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_77(__VA_ARGS__))\n#define PEG_DEF_79(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_78(__VA_ARGS__))\n#define PEG_DEF_80(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_79(__VA_ARGS__))\n#define PEG_DEF_81(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_80(__VA_ARGS__))\n#define PEG_DEF_82(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_81(__VA_ARGS__))\n#define PEG_DEF_83(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_82(__VA_ARGS__))\n#define PEG_DEF_84(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_83(__VA_ARGS__))\n#define PEG_DEF_85(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_84(__VA_ARGS__))\n#define PEG_DEF_86(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_85(__VA_ARGS__))\n#define PEG_DEF_87(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_86(__VA_ARGS__))\n#define PEG_DEF_88(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_87(__VA_ARGS__))\n#define PEG_DEF_89(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_88(__VA_ARGS__))\n#define PEG_DEF_90(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_89(__VA_ARGS__))\n#define PEG_DEF_91(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_90(__VA_ARGS__))\n#define PEG_DEF_92(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_91(__VA_ARGS__))\n#define PEG_DEF_93(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_92(__VA_ARGS__))\n#define PEG_DEF_94(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_93(__VA_ARGS__))\n#define PEG_DEF_95(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_94(__VA_ARGS__))\n#define PEG_DEF_96(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_95(__VA_ARGS__))\n#define PEG_DEF_97(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_96(__VA_ARGS__))\n#define PEG_DEF_98(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_97(__VA_ARGS__))\n#define PEG_DEF_99(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_98(__VA_ARGS__))\n#define PEG_DEF_100(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_99(__VA_ARGS__))\n\n#define AST_DEFINITIONS(...)                                                   \\\n  PEG_EXPAND(PEG_CONCAT2(PEG_DEF_, PEG_COUNT(__VA_ARGS__))(__VA_ARGS__))\n\n/*-----------------------------------------------------------------------------\n *  parser\n *---------------------------------------------------------------------------*/\n\nclass parser {\npublic:\n  parser() = default;\n\n  parser(const char *s, size_t n, const Rules &rules) {\n    load_grammar(s, n, rules);\n  }\n\n  parser(const char *s, const Rules &rules) : parser(s, strlen(s), rules) {}\n\n  parser(const char *s, size_t n) : parser(s, n, Rules()) {}\n\n  parser(const char *s) : parser(s, strlen(s), Rules()) {}\n\n  operator bool() { return grammar_ != nullptr; }\n\n  bool load_grammar(const char *s, size_t n, const Rules &rules) {\n    grammar_ = ParserGenerator::parse(s, n, rules, start_, log);\n    return grammar_ != nullptr;\n  }\n\n  bool load_grammar(const char *s, size_t n) {\n    return load_grammar(s, n, Rules());\n  }\n\n  bool load_grammar(const char *s, const Rules &rules) {\n    auto n = strlen(s);\n    return load_grammar(s, n, rules);\n  }\n\n  bool load_grammar(const char *s) {\n    auto n = strlen(s);\n    return load_grammar(s, n);\n  }\n\n  bool parse_n(const char *s, size_t n, const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse(s, n, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  bool parse(const char *s, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, path);\n  }\n\n  bool parse_n(const char *s, size_t n, any &dt,\n               const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse(s, n, dt, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  bool parse(const char *s, any &dt, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, dt, path);\n  }\n\n  template <typename T>\n  bool parse_n(const char *s, size_t n, T &val,\n               const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse_and_get_value(s, n, val, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  template <typename T>\n  bool parse(const char *s, T &val, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, val, path);\n  }\n\n  template <typename T>\n  bool parse_n(const char *s, size_t n, any &dt, T &val,\n               const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse_and_get_value(s, n, dt, val, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  template <typename T>\n  bool parse(const char *s, any &dt, T &val,\n             const char * /*path*/ = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, dt, val);\n  }\n\n  Definition &operator[](const char *s) { return (*grammar_)[s]; }\n\n  const Definition &operator[](const char *s) const { return (*grammar_)[s]; }\n\n  std::vector<std::string> get_rule_names() {\n    std::vector<std::string> rules;\n    rules.reserve(grammar_->size());\n    for (auto const &r : *grammar_) {\n      rules.emplace_back(r.first);\n    }\n    return rules;\n  }\n\n  void enable_packrat_parsing() {\n    if (grammar_ != nullptr) {\n      auto &rule = (*grammar_)[start_];\n      rule.enablePackratParsing = true;\n    }\n  }\n\n  template <typename T = Ast> parser &enable_ast() {\n    for (auto &x : *grammar_) {\n      auto &rule = x.second;\n      if (!rule.action) { add_ast_action<T>(rule); }\n    }\n    return *this;\n  }\n\n  void enable_trace(TracerEnter tracer_enter, TracerLeave tracer_leave) {\n    if (grammar_ != nullptr) {\n      auto &rule = (*grammar_)[start_];\n      rule.tracer_enter = tracer_enter;\n      rule.tracer_leave = tracer_leave;\n    }\n  }\n\n  Log log;\n\nprivate:\n  void output_log(const char *s, size_t n, const Definition::Result &r) const {\n    if (log) {\n      if (!r.ret) {\n        if (r.message_pos) {\n          auto line = line_info(s, r.message_pos);\n          log(line.first, line.second, r.message);\n        } else {\n          auto line = line_info(s, r.error_pos);\n          log(line.first, line.second, \"syntax error\");\n        }\n      } else if (r.len != n) {\n        auto line = line_info(s, s + r.len);\n        log(line.first, line.second, \"syntax error\");\n      }\n    }\n  }\n\n  std::shared_ptr<Grammar> grammar_;\n  std::string start_;\n};\n\n} // namespace peg\n\n#endif\n\n// vim: et ts=2 sw=2 cin cino={1s ff=unix\n", "\ufeff#include \"catch.hh\"\n#include <peglib.h>\n\nusing namespace peg;\n\n#if !defined(PEGLIB_NO_UNICODE_CHARS)\nTEST_CASE(\"Simple syntax test (with unicode)\", \"[general]\")\n{\n    parser parser(\n        u8\" ROOT \u2190 _ \"\n        \" _ <- ' ' \"\n    );\n\n    bool ret = parser;\n    REQUIRE(ret == true);\n}\n#endif\n\nTEST_CASE(\"Simple syntax test\", \"[general]\")\n{\n    parser parser(R\"(\n        ROOT <- _\n        _ <- ' '\n    )\");\n\n    bool ret = parser;\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"Empty syntax test\", \"[general]\")\n{\n    parser parser(\"\");\n    bool ret = parser;\n    REQUIRE(ret == false);\n}\n\nTEST_CASE(\"Backslash escape sequence test\", \"[general]\")\n{\n    parser parser(R\"(\n        ROOT <- _\n        _ <- '\\\\'\n    )\");\n\n    bool ret = parser;\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"Invalid escape sequence test\", \"[general]\")\n{\n    parser parser(R\"(\n        ROOT <- _\n        _ <- '\\'\n    )\");\n\n    bool ret = parser;\n    REQUIRE(ret == false);\n}\n\nTEST_CASE(\"Action taking non const Semantic Values parameter\", \"[general]\")\n{\n    parser parser(R\"(\n        ROOT <- TEXT\n        TEXT <- [a-zA-Z]+\n    )\");\n\n    parser[\"ROOT\"] = [&](SemanticValues& sv) {\n        auto s = any_cast<std::string>(sv[0]);\n        s[0] = 'H'; // mutate\n        return std::string(std::move(s)); // move\n    };\n\n    parser[\"TEXT\"] = [&](SemanticValues& sv) {\n        return sv.token();\n    };\n\n    std::string val;\n    auto ret = parser.parse(\"hello\", val);\n    REQUIRE(ret == true);\n    REQUIRE(val == \"Hello\");\n}\n\nTEST_CASE(\"String capture test\", \"[general]\")\n{\n    parser parser(R\"(\n        ROOT      <-  _ ('[' TAG_NAME ']' _)*\n        TAG_NAME  <-  (!']' .)+\n        _         <-  [ \\t]*\n    )\");\n\n    std::vector<std::string> tags;\n\n    parser[\"TAG_NAME\"] = [&](const SemanticValues& sv) {\n        tags.push_back(sv.str());\n    };\n\n    auto ret = parser.parse(\" [tag1] [tag:2] [tag-3] \");\n\n    REQUIRE(ret == true);\n    REQUIRE(tags.size() == 3);\n    REQUIRE(tags[0] == \"tag1\");\n    REQUIRE(tags[1] == \"tag:2\");\n    REQUIRE(tags[2] == \"tag-3\");\n}\n\nusing namespace peg;\n\nTEST_CASE(\"String capture test2\", \"[general]\")\n{\n    std::vector<std::string> tags;\n\n    Definition ROOT, TAG, TAG_NAME, WS;\n    ROOT     <= seq(WS, zom(TAG));\n    TAG      <= seq(chr('['), TAG_NAME, chr(']'), WS);\n    TAG_NAME <= oom(seq(npd(chr(']')), dot())), [&](const SemanticValues& sv) { tags.push_back(sv.str()); };\n    WS       <= zom(cls(\" \\t\"));\n\n    auto r = ROOT.parse(\" [tag1] [tag:2] [tag-3] \");\n\n    REQUIRE(r.ret == true);\n    REQUIRE(tags.size() == 3);\n    REQUIRE(tags[0] == \"tag1\");\n    REQUIRE(tags[1] == \"tag:2\");\n    REQUIRE(tags[2] == \"tag-3\");\n}\n\nTEST_CASE(\"String capture test3\", \"[general]\")\n{\n    parser pg(R\"(\n        ROOT  <- _ TOKEN*\n        TOKEN <- '[' < (!']' .)+ > ']' _\n        _     <- [ \\t\\r\\n]*\n    )\");\n\n\n    std::vector<std::string> tags;\n\n    pg[\"TOKEN\"] = [&](const SemanticValues& sv) {\n        tags.push_back(sv.token());\n    };\n\n    auto ret = pg.parse(\" [tag1] [tag:2] [tag-3] \");\n\n    REQUIRE(ret == true);\n    REQUIRE(tags.size() == 3);\n    REQUIRE(tags[0] == \"tag1\");\n    REQUIRE(tags[1] == \"tag:2\");\n    REQUIRE(tags[2] == \"tag-3\");\n}\n\nTEST_CASE(\"Cyclic grammer test\", \"[general]\")\n{\n    Definition PARENT;\n    Definition CHILD;\n\n    PARENT <= seq(CHILD);\n    CHILD  <= seq(PARENT);\n}\n\nTEST_CASE(\"Visit test\", \"[general]\")\n{\n    Definition ROOT, TAG, TAG_NAME, WS;\n\n    ROOT     <= seq(WS, zom(TAG));\n    TAG      <= seq(chr('['), TAG_NAME, chr(']'), WS);\n    TAG_NAME <= oom(seq(npd(chr(']')), dot()));\n    WS       <= zom(cls(\" \\t\"));\n\n    AssignIDToDefinition defIds;\n    ROOT.accept(defIds);\n\n    REQUIRE(defIds.ids.size() == 4);\n}\n\nTEST_CASE(\"Token check test\", \"[general]\")\n{\n    parser parser(R\"(\n        EXPRESSION       <-  _ TERM (TERM_OPERATOR TERM)*\n        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*\n        FACTOR           <-  NUMBER / '(' _ EXPRESSION ')' _\n        TERM_OPERATOR    <-  < [-+] > _\n        FACTOR_OPERATOR  <-  < [/*] > _\n        NUMBER           <-  < [0-9]+ > _\n        _                <-  [ \\t\\r\\n]*\n    )\");\n\n    REQUIRE(parser[\"EXPRESSION\"].is_token() == false);\n    REQUIRE(parser[\"FACTOR\"].is_token() == false);\n    REQUIRE(parser[\"FACTOR_OPERATOR\"].is_token() == true);\n    REQUIRE(parser[\"NUMBER\"].is_token() == true);\n    REQUIRE(parser[\"_\"].is_token() == true);\n}\n\nTEST_CASE(\"Lambda action test\", \"[general]\")\n{\n    parser parser(R\"(\n       START <- (CHAR)*\n       CHAR  <- .\n    )\");\n\n    std::string ss;\n    parser[\"CHAR\"] = [&](const SemanticValues& sv) {\n        ss += *sv.c_str();\n    };\n\n    bool ret = parser.parse(\"hello\");\n    REQUIRE(ret == true);\n    REQUIRE(ss == \"hello\");\n}\n\nTEST_CASE(\"enter/leave handlers test\", \"[general]\")\n{\n    parser parser(R\"(\n        START  <- LTOKEN '=' RTOKEN\n        LTOKEN <- TOKEN\n        RTOKEN <- TOKEN\n        TOKEN  <- [A-Za-z]+\n    )\");\n\n    parser[\"LTOKEN\"].enter = [&](const char*, size_t, any& dt) {\n        auto& require_upper_case = *any_cast<bool*>(dt);\n        require_upper_case = false;\n    };\n    parser[\"LTOKEN\"].leave = [&](const char*, size_t, size_t, any&, any& dt) {\n        auto& require_upper_case = *any_cast<bool*>(dt);\n        require_upper_case = true;\n    };\n\n    auto message = \"should be upper case string...\";\n\n    parser[\"TOKEN\"] = [&](const SemanticValues& sv, any& dt) {\n        auto& require_upper_case = *any_cast<bool*>(dt);\n        if (require_upper_case) {\n            const auto& s = sv.str();\n            if (!std::all_of(s.begin(), s.end(), ::isupper)) {\n                throw parse_error(message);\n            }\n        }\n    };\n\n    bool require_upper_case = false;\n    any dt = &require_upper_case;\n    REQUIRE(parser.parse(\"hello=world\", dt) == false);\n    REQUIRE(parser.parse(\"HELLO=world\", dt) == false);\n    REQUIRE(parser.parse(\"hello=WORLD\", dt) == true);\n    REQUIRE(parser.parse(\"HELLO=WORLD\", dt) == true);\n\n    parser.log = [&](size_t ln, size_t col, const std::string& msg) {\n        REQUIRE(ln == 1);\n        REQUIRE(col == 7);\n        REQUIRE(msg == message);\n    };\n    parser.parse(\"hello=world\", dt);\n}\n\nTEST_CASE(\"WHITESPACE test\", \"[general]\")\n{\n    parser parser(R\"(\n        # Rules\n        ROOT         <-  ITEM (',' ITEM)*\n        ITEM         <-  WORD / PHRASE\n\n        # Tokens\n        WORD         <-  < [a-zA-Z0-9_]+ >\n        PHRASE       <-  < '\"' (!'\"' .)* '\"' >\n\n        %whitespace  <-  [ \\t\\r\\n]*\n    )\");\n\n    auto ret = parser.parse(R\"(  one, \t \"two, three\",   four  )\");\n\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"WHITESPACE test2\", \"[general]\")\n{\n    parser parser(R\"(\n        # Rules\n        ROOT         <-  ITEM (',' ITEM)*\n        ITEM         <-  '[' < [a-zA-Z0-9_]+ > ']'\n\n        %whitespace  <-  (SPACE / TAB)*\n        SPACE        <-  ' '\n        TAB          <-  '\\t'\n    )\");\n\n    std::vector<std::string> items;\n    parser[\"ITEM\"] = [&](const SemanticValues& sv) {\n        items.push_back(sv.token());\n    };\n\n    auto ret = parser.parse(R\"([one], \t[two] ,[three] )\");\n\n    REQUIRE(ret == true);\n    REQUIRE(items.size() == 3);\n    REQUIRE(items[0] == \"one\");\n    REQUIRE(items[1] == \"two\");\n    REQUIRE(items[2] == \"three\");\n}\n\nTEST_CASE(\"WHITESPACE test3\", \"[general]\") {\n    parser parser(R\"(\n        StrQuot      <- < '\"' < (StrEscape / StrChars)* > '\"' >\n        StrEscape    <- '\\\\' any\n        StrChars     <- (!'\"' !'\\\\' any)+\n        any          <- .\n        %whitespace  <- [ \\t]*\n    )\");\n\n    parser[\"StrQuot\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == R\"(  aaa \\\" bbb  )\");\n    };\n\n    auto ret = parser.parse(R\"( \"  aaa \\\" bbb  \" )\");\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"WHITESPACE test4\", \"[general]\") {\n    parser parser(R\"(\n        ROOT         <-  HELLO OPE WORLD\n        HELLO        <-  'hello'\n        OPE          <-  < [-+] >\n        WORLD        <-  'world' / 'WORLD'\n        %whitespace  <-  [ \\t\\r\\n]*\n    )\");\n\n    parser[\"HELLO\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == \"hello\");\n    };\n\n    parser[\"OPE\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == \"+\");\n    };\n\n    parser[\"WORLD\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == \"world\");\n    };\n\n    auto ret = parser.parse(\"  hello + world  \");\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"Word expression test\", \"[general]\") {\n    parser parser(R\"(\n        ROOT         <-  'hello' ','? 'world'\n        %whitespace  <-  [ \\t\\r\\n]*\n        %word        <-  [a-z]+\n    )\");\n\n\tREQUIRE(parser.parse(\"helloworld\") == false);\n\tREQUIRE(parser.parse(\"hello world\") == true);\n\tREQUIRE(parser.parse(\"hello,world\") == true);\n\tREQUIRE(parser.parse(\"hello, world\") == true);\n\tREQUIRE(parser.parse(\"hello , world\") == true);\n}\n\nTEST_CASE(\"Skip token test\", \"[general]\")\n{\n    parser parser(\n        \"  ROOT  <-  _ ITEM (',' _ ITEM _)* \"\n        \"  ITEM  <-  ([a-z0-9])+  \"\n        \"  ~_    <-  [ \\t]*    \"\n    );\n\n    parser[\"ROOT\"] = [&](const SemanticValues& sv) {\n        REQUIRE(sv.size() == 2);\n    };\n\n    auto ret = parser.parse(\" item1, item2 \");\n\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"Skip token test2\", \"[general]\")\n{\n    parser parser(R\"(\n        ROOT        <-  ITEM (',' ITEM)*\n        ITEM        <-  < ([a-z0-9])+ >\n        %whitespace <-  [ \\t]*\n    )\");\n\n    parser[\"ROOT\"] = [&](const SemanticValues& sv) {\n        REQUIRE(sv.size() == 2);\n    };\n\n    auto ret = parser.parse(\" item1, item2 \");\n\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"Custom AST test\", \"[general]\")\n{\n\tstruct CustomType {};\n\tusing CustomAst = AstBase<CustomType>;\n\t\n    parser parser(R\"(\n        ROOT <- _ TEXT*\n        TEXT <- [a-zA-Z]+ _\n        _ <- [ \\t\\r\\n]*\n    )\");\n\n    parser.enable_ast<CustomAst>();\n    std::shared_ptr<CustomAst> ast;\n    bool ret = parser.parse(\"a b c\", ast);\n    REQUIRE(ret == true);\n    REQUIRE(ast->nodes.size() == 4);\n}\n\nTEST_CASE(\"Backtracking test\", \"[general]\")\n{\n    parser parser(R\"(\n       START <- PAT1 / PAT2\n       PAT1  <- HELLO ' One'\n       PAT2  <- HELLO ' Two'\n       HELLO <- 'Hello'\n    )\");\n\n    size_t count = 0;\n    parser[\"HELLO\"] = [&](const SemanticValues& /*sv*/) {\n        count++;\n    };\n\n    parser.enable_packrat_parsing();\n\n    bool ret = parser.parse(\"Hello Two\");\n    REQUIRE(ret == true);\n    REQUIRE(count == 1); // Skip second time\n}\n\nTEST_CASE(\"Backtracking with AST\", \"[general]\")\n{\n    parser parser(R\"(\n        S <- A? B (A B)* A\n        A <- 'a'\n        B <- 'b'\n    )\");\n\n    parser.enable_ast();\n    std::shared_ptr<Ast> ast;\n    bool ret = parser.parse(\"ba\", ast);\n    REQUIRE(ret == true);\n    REQUIRE(ast->nodes.size() == 2);\n}\n\nTEST_CASE(\"Octal/Hex/Unicode value test\", \"[general]\")\n{\n    parser parser(\n        R\"( ROOT <- '\\132\\x7a\\u30f3' )\"\n    );\n\n    auto ret = parser.parse(\"Zz\u30f3\");\n\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"Ignore case test\", \"[general]\") {\n    parser parser(R\"(\n        ROOT         <-  HELLO WORLD\n        HELLO        <-  'hello'i\n        WORLD        <-  'world'i\n        %whitespace  <-  [ \\t\\r\\n]*\n    )\");\n\n    parser[\"HELLO\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == \"Hello\");\n    };\n\n    parser[\"WORLD\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == \"World\");\n    };\n\n    auto ret = parser.parse(\"  Hello World  \");\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"mutable lambda test\", \"[general]\")\n{\n    std::vector<std::string> vec;\n\n    parser pg(\"ROOT <- 'mutable lambda test'\");\n\n    // This test makes sure if the following code can be compiled.\n    pg[\"TOKEN\"] = [=](const SemanticValues& sv) mutable {\n        vec.push_back(sv.str());\n    };\n}\n\nTEST_CASE(\"Simple calculator test\", \"[general]\")\n{\n    parser parser(R\"(\n        Additive  <- Multitive '+' Additive / Multitive\n        Multitive <- Primary '*' Multitive / Primary\n        Primary   <- '(' Additive ')' / Number\n        Number    <- [0-9]+\n    )\");\n\n    parser[\"Additive\"] = [](const SemanticValues& sv) {\n        switch (sv.choice()) {\n        case 0:\n            return any_cast<int>(sv[0]) + any_cast<int>(sv[1]);\n        default:\n            return any_cast<int>(sv[0]);\n        }\n    };\n\n    parser[\"Multitive\"] = [](const SemanticValues& sv) {\n        switch (sv.choice()) {\n        case 0:\n            return any_cast<int>(sv[0]) * any_cast<int>(sv[1]);\n        default:\n            return any_cast<int>(sv[0]);\n        }\n    };\n\n    parser[\"Number\"] = [](const SemanticValues& sv) {\n        return atoi(sv.c_str());\n    };\n\n    int val;\n    parser.parse(\"(1+2)*3\", val);\n\n    REQUIRE(val == 9);\n}\n\nTEST_CASE(\"Calculator test\", \"[general]\")\n{\n    // Construct grammer\n    Definition EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER;\n\n    EXPRESSION      <= seq(TERM, zom(seq(TERM_OPERATOR, TERM)));\n    TERM            <= seq(FACTOR, zom(seq(FACTOR_OPERATOR, FACTOR)));\n    FACTOR          <= cho(NUMBER, seq(chr('('), EXPRESSION, chr(')')));\n    TERM_OPERATOR   <= cls(\"+-\");\n    FACTOR_OPERATOR <= cls(\"*/\");\n    NUMBER          <= oom(cls(\"0-9\"));\n\n    // Setup actions\n    auto reduce = [](const SemanticValues& sv) -> long {\n        long ret = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            switch (any_cast<char>(sv[i])) {\n                case '+': ret += num; break;\n                case '-': ret -= num; break;\n                case '*': ret *= num; break;\n                case '/': ret /= num; break;\n            }\n        }\n        return ret;\n    };\n\n    EXPRESSION      = reduce;\n    TERM            = reduce;\n    TERM_OPERATOR   = [](const SemanticValues& sv) { return *sv.c_str(); };\n    FACTOR_OPERATOR = [](const SemanticValues& sv) { return *sv.c_str(); };\n    NUMBER          = [](const SemanticValues& sv) { return stol(sv.str(), nullptr, 10); };\n\n    // Parse\n    long val;\n    auto r = EXPRESSION.parse_and_get_value(\"1+2*3*(4-5+6)/7-8\", val);\n\n    REQUIRE(r.ret == true);\n    REQUIRE(val == -3);\n}\n\nTEST_CASE(\"Calculator test2\", \"[general]\")\n{\n    // Parse syntax\n    auto syntax = R\"(\n        # Grammar for Calculator...\n        EXPRESSION       <-  TERM (TERM_OPERATOR TERM)*\n        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*\n        FACTOR           <-  NUMBER / '(' EXPRESSION ')'\n        TERM_OPERATOR    <-  [-+]\n        FACTOR_OPERATOR  <-  [/*]\n        NUMBER           <-  [0-9]+\n    )\";\n\n    std::string start;\n    auto grammar = ParserGenerator::parse(syntax, strlen(syntax), start, nullptr);\n    auto& g = *grammar;\n\n    // Setup actions\n    auto reduce = [](const SemanticValues& sv) -> long {\n        long ret = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            switch (any_cast<char>(sv[i])) {\n                case '+': ret += num; break;\n                case '-': ret -= num; break;\n                case '*': ret *= num; break;\n                case '/': ret /= num; break;\n            }\n        }\n        return ret;\n    };\n\n    g[\"EXPRESSION\"]      = reduce;\n    g[\"TERM\"]            = reduce;\n    g[\"TERM_OPERATOR\"]   = [](const SemanticValues& sv) { return *sv.c_str(); };\n    g[\"FACTOR_OPERATOR\"] = [](const SemanticValues& sv) { return *sv.c_str(); };\n    g[\"NUMBER\"]          = [](const SemanticValues& sv) { return stol(sv.str(), nullptr, 10); };\n\n    // Parse\n    long val;\n    auto r = g[start].parse_and_get_value(\"1+2*3*(4-5+6)/7-8\", val);\n\n    REQUIRE(r.ret == true);\n    REQUIRE(val == -3);\n}\n\nTEST_CASE(\"Calculator test3\", \"[general]\")\n{\n    // Parse syntax\n    parser parser(R\"(\n        # Grammar for Calculator...\n        EXPRESSION       <-  TERM (TERM_OPERATOR TERM)*\n        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*\n        FACTOR           <-  NUMBER / '(' EXPRESSION ')'\n        TERM_OPERATOR    <-  [-+]\n        FACTOR_OPERATOR  <-  [/*]\n        NUMBER           <-  [0-9]+\n    )\");\n\n    auto reduce = [](const SemanticValues& sv) -> long {\n        long ret = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            switch (any_cast<char>(sv[i])) {\n                case '+': ret += num; break;\n                case '-': ret -= num; break;\n                case '*': ret *= num; break;\n                case '/': ret /= num; break;\n            }\n        }\n        return ret;\n    };\n\n    // Setup actions\n    parser[\"EXPRESSION\"]      = reduce;\n    parser[\"TERM\"]            = reduce;\n    parser[\"TERM_OPERATOR\"]   = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };\n    parser[\"FACTOR_OPERATOR\"] = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };\n    parser[\"NUMBER\"]          = [](const SemanticValues& sv) { return stol(sv.str(), nullptr, 10); };\n\n    // Parse\n    long val;\n    auto ret = parser.parse(\"1+2*3*(4-5+6)/7-8\", val);\n\n    REQUIRE(ret == true);\n    REQUIRE(val == -3);\n}\n\nTEST_CASE(\"Calculator test with AST\", \"[general]\")\n{\n    parser parser(R\"(\n        EXPRESSION       <-  _ TERM (TERM_OPERATOR TERM)*\n        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*\n        FACTOR           <-  NUMBER / '(' _ EXPRESSION ')' _\n        TERM_OPERATOR    <-  < [-+] > _\n        FACTOR_OPERATOR  <-  < [/*] > _\n        NUMBER           <-  < [0-9]+ > _\n        ~_               <-  [ \\t\\r\\n]*\n    )\");\n\n    parser.enable_ast();\n\n    std::function<long (const Ast&)> eval = [&](const Ast& ast) {\n        if (ast.name == \"NUMBER\") {\n            return stol(ast.token);\n        } else {\n            const auto& nodes = ast.nodes;\n            auto result = eval(*nodes[0]);\n            for (auto i = 1u; i < nodes.size(); i += 2) {\n                auto num = eval(*nodes[i + 1]);\n                auto ope = nodes[i]->token[0];\n                switch (ope) {\n                    case '+': result += num; break;\n                    case '-': result -= num; break;\n                    case '*': result *= num; break;\n                    case '/': result /= num; break;\n                }\n            }\n            return result;\n        }\n    };\n\n    std::shared_ptr<Ast> ast;\n    auto ret = parser.parse(\"1+2*3*(4-5+6)/7-8\", ast);\n    ast = AstOptimizer(true).optimize(ast);\n    auto val = eval(*ast);\n\n    REQUIRE(ret == true);\n    REQUIRE(val == -3);\n}\n\nTEST_CASE(\"Calculator test with combinators and AST\", \"[general]\") {\n  // Construct grammer\n  AST_DEFINITIONS(EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER);\n\n  EXPRESSION <= seq(TERM, zom(seq(TERM_OPERATOR, TERM)));\n  TERM <= seq(FACTOR, zom(seq(FACTOR_OPERATOR, FACTOR)));\n  FACTOR <= cho(NUMBER, seq(chr('('), EXPRESSION, chr(')')));\n  TERM_OPERATOR <= cls(\"+-\");\n  FACTOR_OPERATOR <= cls(\"*/\");\n  NUMBER <= oom(cls(\"0-9\"));\n\n  std::function<long(const Ast &)> eval = [&](const Ast &ast) {\n    if (ast.name == \"NUMBER\") {\n      return stol(ast.token);\n    } else {\n      const auto &nodes = ast.nodes;\n      auto result = eval(*nodes[0]);\n      for (auto i = 1u; i < nodes.size(); i += 2) {\n        auto num = eval(*nodes[i + 1]);\n        auto ope = nodes[i]->token[0];\n        switch (ope) {\n        case '+': result += num; break;\n        case '-': result -= num; break;\n        case '*': result *= num; break;\n        case '/': result /= num; break;\n        }\n      }\n      return result;\n    }\n  };\n\n  std::shared_ptr<Ast> ast;\n  auto r = EXPRESSION.parse_and_get_value(\"1+2*3*(4-5+6)/7-8\", ast);\n  ast = AstOptimizer(true).optimize(ast);\n  auto val = eval(*ast);\n\n  REQUIRE(r.ret == true);\n  REQUIRE(val == -3);\n}\n\nTEST_CASE(\"Ignore semantic value test\", \"[general]\")\n{\n    parser parser(R\"(\n       START <-  ~HELLO WORLD\n       HELLO <- 'Hello' _\n       WORLD <- 'World' _\n       _     <- [ \\t\\r\\n]*\n    )\");\n\n    parser.enable_ast();\n\n    std::shared_ptr<Ast> ast;\n    auto ret = parser.parse(\"Hello World\", ast);\n\n    REQUIRE(ret == true);\n    REQUIRE(ast->nodes.size() == 1);\n    REQUIRE(ast->nodes[0]->name == \"WORLD\");\n}\n\nTEST_CASE(\"Ignore semantic value of 'or' predicate test\", \"[general]\")\n{\n    parser parser(R\"(\n       START       <- _ !DUMMY HELLO_WORLD '.'\n       HELLO_WORLD <- HELLO 'World' _\n       HELLO       <- 'Hello' _\n       DUMMY       <- 'dummy' _\n       ~_          <- [ \\t\\r\\n]*\n   )\");\n\n    parser.enable_ast();\n\n    std::shared_ptr<Ast> ast;\n    auto ret = parser.parse(\"Hello World.\", ast);\n\n    REQUIRE(ret == true);\n    REQUIRE(ast->nodes.size() == 1);\n    REQUIRE(ast->nodes[0]->name == \"HELLO_WORLD\");\n}\n\nTEST_CASE(\"Ignore semantic value of 'and' predicate test\", \"[general]\")\n{\n    parser parser(R\"(\n       START       <- _ &HELLO HELLO_WORLD '.'\n       HELLO_WORLD <- HELLO 'World' _\n       HELLO       <- 'Hello' _\n       ~_          <- [ \\t\\r\\n]*\n    )\");\n\n    parser.enable_ast();\n\n    std::shared_ptr<Ast> ast;\n    auto ret = parser.parse(\"Hello World.\", ast);\n\n    REQUIRE(ret == true);\n    REQUIRE(ast->nodes.size() == 1);\n    REQUIRE(ast->nodes[0]->name == \"HELLO_WORLD\");\n}\n\nTEST_CASE(\"Literal token on AST test1\", \"[general]\")\n{\n    parser parser(R\"(\n        STRING_LITERAL  <- '\"' (('\\\\\"' / '\\\\t' / '\\\\n') / (![\"] .))* '\"'\n    )\");\n    parser.enable_ast();\n\n    std::shared_ptr<Ast> ast;\n    auto ret = parser.parse(R\"(\"a\\tb\")\", ast);\n\n    REQUIRE(ret == true);\n    REQUIRE(ast->is_token == true);\n    REQUIRE(ast->token == R\"(\"a\\tb\")\");\n    REQUIRE(ast->nodes.empty());\n}\n\nTEST_CASE(\"Literal token on AST test2\", \"[general]\")\n{\n    parser parser(R\"(\n        STRING_LITERAL  <-  '\"' (ESC / CHAR)* '\"'\n        ESC             <-  ('\\\\\"' / '\\\\t' / '\\\\n')\n        CHAR            <-  (![\"] .)\n    )\");\n    parser.enable_ast();\n\n    std::shared_ptr<Ast> ast;\n    auto ret = parser.parse(R\"(\"a\\tb\")\", ast);\n\n    REQUIRE(ret == true);\n    REQUIRE(ast->is_token == false);\n    REQUIRE(ast->token.empty());\n    REQUIRE(ast->nodes.size() == 3);\n}\n\nTEST_CASE(\"Literal token on AST test3\", \"[general]\")\n{\n    parser parser(R\"(\n        STRING_LITERAL  <-  < '\"' (ESC / CHAR)* '\"' >\n        ESC             <-  ('\\\\\"' / '\\\\t' / '\\\\n')\n        CHAR            <-  (![\"] .)\n    )\");\n    parser.enable_ast();\n\n    std::shared_ptr<Ast> ast;\n    auto ret = parser.parse(R\"(\"a\\tb\")\", ast);\n\n    REQUIRE(ret == true);\n    REQUIRE(ast->is_token == true);\n    REQUIRE(ast->token == R\"(\"a\\tb\")\");\n    REQUIRE(ast->nodes.empty());\n}\n\nTEST_CASE(\"Missing missing definitions test\", \"[general]\")\n{\n    parser parser(R\"(\n        A <- B C\n    )\");\n\n    REQUIRE(!parser);\n}\n\nTEST_CASE(\"Definition duplicates test\", \"[general]\")\n{\n    parser parser(R\"(\n        A <- ''\n        A <- ''\n    )\");\n\n    REQUIRE(!parser);\n}\n\nTEST_CASE(\"Semantic values test\", \"[general]\")\n{\n    parser parser(R\"(\n        term <- ( a b c x )? a b c\n        a <- 'a'\n        b <- 'b'\n        c <- 'c'\n        x <- 'x'\n    )\");\n\n\tfor (const auto& rule: parser.get_rule_names()){\n\t\tparser[rule.c_str()] = [rule](const SemanticValues& sv, any&) {\n            if (rule == \"term\") {\n                REQUIRE(any_cast<std::string>(sv[0]) == \"a at 0\");\n                REQUIRE(any_cast<std::string>(sv[1]) == \"b at 1\");\n                REQUIRE(any_cast<std::string>(sv[2]) == \"c at 2\");\n                return std::string();\n            } else {\n                return rule + \" at \" + std::to_string(sv.c_str() - sv.ss);\n            }\n\t\t};\n\t}\n\n\tREQUIRE(parser.parse(\"abc\"));\n}\n\nTEST_CASE(\"Ordered choice count\", \"[general]\")\n{\n    parser parser(R\"(\n        S <- 'a' / 'b'\n    )\");\n\n    parser[\"S\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.choice() == 1);\n        REQUIRE(sv.choice_count() == 2);\n    };\n\n    parser.parse(\"b\");\n}\n\nTEST_CASE(\"Ordered choice count 2\", \"[general]\")\n{\n    parser parser(R\"(\n        S <- ('a' / 'b')*\n    )\");\n\n    parser[\"S\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.choice() == 0);\n        REQUIRE(sv.choice_count() == 0);\n    };\n\n    parser.parse(\"b\");\n}\n\nTEST_CASE(\"Semantic value tag\", \"[general]\")\n{\n    parser parser(R\"(\n        S <- A? B* C?\n        A <- 'a'\n        B <- 'b'\n        C <- 'c'\n    )\");\n\n    {\n        using namespace udl;\n        parser[\"S\"] = [](const SemanticValues& sv) {\n            REQUIRE(sv.size() == 1);\n            REQUIRE(sv.tags.size() == 1);\n            REQUIRE(sv.tags[0] == \"C\"_);\n        };\n        auto ret = parser.parse(\"c\");\n        REQUIRE(ret == true);\n    }\n\n    {\n        using namespace udl;\n        parser[\"S\"] = [](const SemanticValues& sv) {\n            REQUIRE(sv.size() == 2);\n            REQUIRE(sv.tags.size() == 2);\n            REQUIRE(sv.tags[0] == \"B\"_);\n            REQUIRE(sv.tags[1] == \"B\"_);\n        };\n        auto ret = parser.parse(\"bb\");\n        REQUIRE(ret == true);\n    }\n\n    {\n        using namespace udl;\n        parser[\"S\"] = [](const SemanticValues& sv) {\n            REQUIRE(sv.size() == 2);\n            REQUIRE(sv.tags.size() == 2);\n            REQUIRE(sv.tags[0] == \"A\"_);\n            REQUIRE(sv.tags[1] == \"C\"_);\n        };\n        auto ret = parser.parse(\"ac\");\n        REQUIRE(ret == true);\n    }\n}\n\nTEST_CASE(\"Negated Class test\", \"[general]\")\n{\n    parser parser(R\"(\n        ROOT <- [^a-z_]+\n    )\");\n\n    bool ret = parser;\n    REQUIRE(ret == true);\n\n    REQUIRE(parser.parse(\"ABC123\"));\n    REQUIRE_FALSE(parser.parse(\"ABcZ\"));\n    REQUIRE_FALSE(parser.parse(\"ABCZ_\"));\n    REQUIRE_FALSE(parser.parse(\"\"));\n}\n\n// vim: et ts=4 sw=4 cin cino={1s ff=unix\n"], "fixing_code": ["\ufeff//\n//  peglib.h\n//\n//  Copyright (c) 2020 Yuji Hirose. All rights reserved.\n//  MIT License\n//\n\n#ifndef CPPPEGLIB_PEGLIB_H\n#define CPPPEGLIB_PEGLIB_H\n\n#ifndef PEGLIB_USE_STD_ANY\n#ifdef _MSVC_LANG\n#define PEGLIB_USE_STD_ANY _MSVC_LANG >= 201703L\n#elif defined(__cplusplus)\n#define PEGLIB_USE_STD_ANY __cplusplus >= 201703L\n#endif\n#endif // PEGLIB_USE_STD_ANY\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cstring>\n#include <functional>\n#include <initializer_list>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <mutex>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#if PEGLIB_USE_STD_ANY\n#include <any>\n#endif\n\n// guard for older versions of VC++\n#ifdef _MSC_VER\n#if defined(_MSC_VER) && _MSC_VER < 1900 // Less than Visual Studio 2015\n#error \"Requires complete C+11 support\"\n#endif\n#endif\n\nnamespace peg {\n\n/*-----------------------------------------------------------------------------\n *  any\n *---------------------------------------------------------------------------*/\n\n#if PEGLIB_USE_STD_ANY\nusing any = std::any;\n\n// Define a function alias to std::any_cast using perfect forwarding\ntemplate <typename T, typename... Args>\nauto any_cast(Args &&... args)\n    -> decltype(std::any_cast<T>(std::forward<Args>(args)...)) {\n  return std::any_cast<T>(std::forward<Args>(args)...);\n}\n#else\nclass any {\npublic:\n  any() = default;\n\n  any(const any &rhs) : content_(rhs.clone()) {}\n\n  any(any &&rhs) : content_(rhs.content_) { rhs.content_ = nullptr; }\n\n  template <typename T> any(const T &value) : content_(new holder<T>(value)) {}\n\n  any &operator=(const any &rhs) {\n    if (this != &rhs) {\n      if (content_) { delete content_; }\n      content_ = rhs.clone();\n    }\n    return *this;\n  }\n\n  any &operator=(any &&rhs) {\n    if (this != &rhs) {\n      if (content_) { delete content_; }\n      content_ = rhs.content_;\n      rhs.content_ = nullptr;\n    }\n    return *this;\n  }\n\n  ~any() { delete content_; }\n\n  bool has_value() const { return content_ != nullptr; }\n\n  template <typename T> friend T &any_cast(any &val);\n\n  template <typename T> friend const T &any_cast(const any &val);\n\nprivate:\n  struct placeholder {\n    virtual ~placeholder() {}\n    virtual placeholder *clone() const = 0;\n  };\n\n  template <typename T> struct holder : placeholder {\n    holder(const T &value) : value_(value) {}\n    placeholder *clone() const override { return new holder(value_); }\n    T value_;\n  };\n\n  placeholder *clone() const { return content_ ? content_->clone() : nullptr; }\n\n  placeholder *content_ = nullptr;\n};\n\ntemplate <typename T> T &any_cast(any &val) {\n  if (!val.content_) { throw std::bad_cast(); }\n  auto p = dynamic_cast<any::holder<T> *>(val.content_);\n  assert(p);\n  if (!p) { throw std::bad_cast(); }\n  return p->value_;\n}\n\ntemplate <> inline any &any_cast<any>(any &val) { return val; }\n\ntemplate <typename T> const T &any_cast(const any &val) {\n  assert(val.content_);\n  auto p = dynamic_cast<any::holder<T> *>(val.content_);\n  assert(p);\n  if (!p) { throw std::bad_cast(); }\n  return p->value_;\n}\n\ntemplate <> inline const any &any_cast<any>(const any &val) { return val; }\n#endif\n\n/*-----------------------------------------------------------------------------\n *  scope_exit\n *---------------------------------------------------------------------------*/\n\n// This is based on\n// \"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4189\".\n\ntemplate <typename EF> struct scope_exit {\n  explicit scope_exit(EF &&f)\n      : exit_function(std::move(f)), execute_on_destruction{true} {}\n\n  scope_exit(scope_exit &&rhs)\n      : exit_function(std::move(rhs.exit_function)),\n        execute_on_destruction{rhs.execute_on_destruction} {\n    rhs.release();\n  }\n\n  ~scope_exit() {\n    if (execute_on_destruction) { this->exit_function(); }\n  }\n\n  void release() { this->execute_on_destruction = false; }\n\nprivate:\n  scope_exit(const scope_exit &) = delete;\n  void operator=(const scope_exit &) = delete;\n  scope_exit &operator=(scope_exit &&) = delete;\n\n  EF exit_function;\n  bool execute_on_destruction;\n};\n\ntemplate <typename EF>\nauto make_scope_exit(EF &&exit_function) -> scope_exit<EF> {\n  return scope_exit<typename std::remove_reference<EF>::type>(\n      std::forward<EF>(exit_function));\n}\n\n/*-----------------------------------------------------------------------------\n *  UTF8 functions\n *---------------------------------------------------------------------------*/\n\ninline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}\n\ninline size_t encode_codepoint(char32_t cp, char *buff) {\n  if (cp < 0x0080) {\n    buff[0] = static_cast<char>(cp & 0x7F);\n    return 1;\n  } else if (cp < 0x0800) {\n    buff[0] = static_cast<char>(0xC0 | ((cp >> 6) & 0x1F));\n    buff[1] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 2;\n  } else if (cp < 0xD800) {\n    buff[0] = static_cast<char>(0xE0 | ((cp >> 12) & 0xF));\n    buff[1] = static_cast<char>(0x80 | ((cp >> 6) & 0x3F));\n    buff[2] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 3;\n  } else if (cp < 0xE000) {\n    // D800 - DFFF is invalid...\n    return 0;\n  } else if (cp < 0x10000) {\n    buff[0] = static_cast<char>(0xE0 | ((cp >> 12) & 0xF));\n    buff[1] = static_cast<char>(0x80 | ((cp >> 6) & 0x3F));\n    buff[2] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 3;\n  } else if (cp < 0x110000) {\n    buff[0] = static_cast<char>(0xF0 | ((cp >> 18) & 0x7));\n    buff[1] = static_cast<char>(0x80 | ((cp >> 12) & 0x3F));\n    buff[2] = static_cast<char>(0x80 | ((cp >> 6) & 0x3F));\n    buff[3] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 4;\n  }\n  return 0;\n}\n\ninline std::string encode_codepoint(char32_t cp) {\n  char buff[4];\n  auto l = encode_codepoint(cp, buff);\n  return std::string(buff, l);\n}\n\ninline bool decode_codepoint(const char *s8, size_t l, size_t &bytes,\n                             char32_t &cp) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      bytes = 1;\n      cp = b;\n      return true;\n    } else if ((b & 0xE0) == 0xC0) {\n      if (l >= 2) {\n        bytes = 2;\n        cp = ((static_cast<char32_t>(s8[0] & 0x1F)) << 6) |\n             (static_cast<char32_t>(s8[1] & 0x3F));\n        return true;\n      }\n    } else if ((b & 0xF0) == 0xE0) {\n      if (l >= 3) {\n        bytes = 3;\n        cp = ((static_cast<char32_t>(s8[0] & 0x0F)) << 12) |\n             ((static_cast<char32_t>(s8[1] & 0x3F)) << 6) |\n             (static_cast<char32_t>(s8[2] & 0x3F));\n        return true;\n      }\n    } else if ((b & 0xF8) == 0xF0) {\n      if (l >= 4) {\n        bytes = 4;\n        cp = ((static_cast<char32_t>(s8[0] & 0x07)) << 18) |\n             ((static_cast<char32_t>(s8[1] & 0x3F)) << 12) |\n             ((static_cast<char32_t>(s8[2] & 0x3F)) << 6) |\n             (static_cast<char32_t>(s8[3] & 0x3F));\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\ninline size_t decode_codepoint(const char *s8, size_t l, char32_t &out) {\n  size_t bytes;\n  if (decode_codepoint(s8, l, bytes, out)) { return bytes; }\n  return 0;\n}\n\ninline char32_t decode_codepoint(const char *s8, size_t l) {\n  char32_t out = 0;\n  decode_codepoint(s8, l, out);\n  return out;\n}\n\ninline std::u32string decode(const char *s8, size_t l) {\n  std::u32string out;\n  size_t i = 0;\n  while (i < l) {\n    auto beg = i++;\n    while (i < l && (s8[i] & 0xc0) == 0x80) {\n      i++;\n    }\n    out += decode_codepoint(&s8[beg], (i - beg));\n  }\n  return out;\n}\n\n/*-----------------------------------------------------------------------------\n *  resolve_escape_sequence\n *---------------------------------------------------------------------------*/\n\ninline bool is_hex(char c, int &v) {\n  if ('0' <= c && c <= '9') {\n    v = c - '0';\n    return true;\n  } else if ('a' <= c && c <= 'f') {\n    v = c - 'a' + 10;\n    return true;\n  } else if ('A' <= c && c <= 'F') {\n    v = c - 'A' + 10;\n    return true;\n  }\n  return false;\n}\n\ninline bool is_digit(char c, int &v) {\n  if ('0' <= c && c <= '9') {\n    v = c - '0';\n    return true;\n  }\n  return false;\n}\n\ninline std::pair<int, size_t> parse_hex_number(const char *s, size_t n,\n                                               size_t i) {\n  int ret = 0;\n  int val;\n  while (i < n && is_hex(s[i], val)) {\n    ret = static_cast<int>(ret * 16 + val);\n    i++;\n  }\n  return std::make_pair(ret, i);\n}\n\ninline std::pair<int, size_t> parse_octal_number(const char *s, size_t n,\n                                                 size_t i) {\n  int ret = 0;\n  int val;\n  while (i < n && is_digit(s[i], val)) {\n    ret = static_cast<int>(ret * 8 + val);\n    i++;\n  }\n  return std::make_pair(ret, i);\n}\n\ninline std::string resolve_escape_sequence(const char *s, size_t n) {\n  std::string r;\n  r.reserve(n);\n\n  size_t i = 0;\n  while (i < n) {\n    auto ch = s[i];\n    if (ch == '\\\\') {\n      i++;\n      if (i == n) { throw std::runtime_error(\"Invalid escape sequence...\"); }\n      switch (s[i]) {\n      case 'n':\n        r += '\\n';\n        i++;\n        break;\n      case 'r':\n        r += '\\r';\n        i++;\n        break;\n      case 't':\n        r += '\\t';\n        i++;\n        break;\n      case '\\'':\n        r += '\\'';\n        i++;\n        break;\n      case '\"':\n        r += '\"';\n        i++;\n        break;\n      case '[':\n        r += '[';\n        i++;\n        break;\n      case ']':\n        r += ']';\n        i++;\n        break;\n      case '\\\\':\n        r += '\\\\';\n        i++;\n        break;\n      case 'x':\n      case 'u': {\n        char32_t cp;\n        std::tie(cp, i) = parse_hex_number(s, n, i + 1);\n        r += encode_codepoint(cp);\n        break;\n      }\n      default: {\n        char32_t cp;\n        std::tie(cp, i) = parse_octal_number(s, n, i);\n        r += encode_codepoint(cp);\n        break;\n      }\n      }\n    } else {\n      r += ch;\n      i++;\n    }\n  }\n  return r;\n}\n\n/*-----------------------------------------------------------------------------\n *  Trie\n *---------------------------------------------------------------------------*/\n\nclass Trie {\npublic:\n  Trie() = default;\n  Trie(const Trie &) = default;\n\n  Trie(const std::vector<std::string> &items) {\n    for (const auto &item : items) {\n      for (size_t len = 1; len <= item.size(); len++) {\n        auto last = len == item.size();\n        std::string s(item.c_str(), len);\n        auto it = dic_.find(s);\n        if (it == dic_.end()) {\n          dic_.emplace(s, Info{last, last});\n        } else if (last) {\n          it->second.match = true;\n        } else {\n          it->second.done = false;\n        }\n      }\n    }\n  }\n\n  size_t match(const char *text, size_t text_len) const {\n    size_t match_len = 0;\n    {\n      auto done = false;\n      size_t len = 1;\n      while (!done && len <= text_len) {\n        std::string s(text, len);\n        auto it = dic_.find(s);\n        if (it == dic_.end()) {\n          done = true;\n        } else {\n          if (it->second.match) { match_len = len; }\n          if (it->second.done) { done = true; }\n        }\n        len += 1;\n      }\n    }\n    return match_len;\n  }\n\nprivate:\n  struct Info {\n    bool done;\n    bool match;\n  };\n  std::unordered_map<std::string, Info> dic_;\n};\n\n/*-----------------------------------------------------------------------------\n *  PEG\n *---------------------------------------------------------------------------*/\n\n/*\n * Line information utility function\n */\ninline std::pair<size_t, size_t> line_info(const char *start, const char *cur) {\n  auto p = start;\n  auto col_ptr = p;\n  auto no = 1;\n\n  while (p < cur) {\n    if (*p == '\\n') {\n      no++;\n      col_ptr = p + 1;\n    }\n    p++;\n  }\n\n  auto col = p - col_ptr + 1;\n\n  return std::make_pair(no, col);\n}\n\n/*\n * String tag\n */\ninline constexpr unsigned int str2tag(const char *str, unsigned int h = 0) {\n  return (*str == '\\0')\n             ? h\n             : str2tag(str + 1, (h * 33) ^ static_cast<unsigned char>(*str));\n}\n\nnamespace udl {\n\ninline constexpr unsigned int operator\"\" _(const char *s, size_t) {\n  return str2tag(s);\n}\n\n} // namespace udl\n\n/*\n * Semantic values\n */\nstruct SemanticValues : protected std::vector<any> {\n  // Input text\n  const char *path = nullptr;\n  const char *ss = nullptr;\n  const std::vector<size_t> *source_line_index = nullptr;\n\n  // Matched string\n  const char *c_str() const { return s_; }\n  size_t length() const { return n_; }\n\n  std::string str() const { return std::string(s_, n_); }\n\n  // Definition name\n  const std::string &name() const { return name_; }\n\n  std::vector<unsigned int> tags;\n\n  // Line number and column at which the matched string is\n  std::pair<size_t, size_t> line_info() const {\n    const auto &idx = *source_line_index;\n\n    auto cur = static_cast<size_t>(std::distance(ss, s_));\n    auto it = std::lower_bound(\n        idx.begin(), idx.end(), cur,\n        [](size_t element, size_t value) { return element < value; });\n\n    auto id = static_cast<size_t>(std::distance(idx.begin(), it));\n    auto off = cur - (id == 0 ? 0 : idx[id - 1] + 1);\n    return std::make_pair(id + 1, off + 1);\n  }\n\n  // Choice count\n  size_t choice_count() const { return choice_count_; }\n\n  // Choice number (0 based index)\n  size_t choice() const { return choice_; }\n\n  // Tokens\n  std::vector<std::pair<const char *, size_t>> tokens;\n\n  std::string token(size_t id = 0) const {\n    if (!tokens.empty()) {\n      assert(id < tokens.size());\n      const auto &tok = tokens[id];\n      return std::string(tok.first, tok.second);\n    }\n    return std::string(s_, n_);\n  }\n\n  // Transform the semantic value vector to another vector\n  template <typename T>\n  std::vector<T> transform(size_t beg = 0,\n                           size_t end = static_cast<size_t>(-1)) const {\n    std::vector<T> r;\n    end = (std::min)(end, size());\n    for (size_t i = beg; i < end; i++) {\n      r.emplace_back(any_cast<T>((*this)[i]));\n    }\n    return r;\n  }\n\n  using std::vector<any>::iterator;\n  using std::vector<any>::const_iterator;\n  using std::vector<any>::size;\n  using std::vector<any>::empty;\n  using std::vector<any>::assign;\n  using std::vector<any>::begin;\n  using std::vector<any>::end;\n  using std::vector<any>::rbegin;\n  using std::vector<any>::rend;\n  using std::vector<any>::operator[];\n  using std::vector<any>::at;\n  using std::vector<any>::resize;\n  using std::vector<any>::front;\n  using std::vector<any>::back;\n  using std::vector<any>::push_back;\n  using std::vector<any>::pop_back;\n  using std::vector<any>::insert;\n  using std::vector<any>::erase;\n  using std::vector<any>::clear;\n  using std::vector<any>::swap;\n  using std::vector<any>::emplace;\n  using std::vector<any>::emplace_back;\n\nprivate:\n  friend class Context;\n  friend class Sequence;\n  friend class PrioritizedChoice;\n  friend class Holder;\n  friend class PrecedenceClimbing;\n\n  const char *s_ = nullptr;\n  size_t n_ = 0;\n  size_t choice_count_ = 0;\n  size_t choice_ = 0;\n  std::string name_;\n};\n\n/*\n * Semantic action\n */\ntemplate <typename R, typename F,\n          typename std::enable_if<std::is_void<R>::value,\n                                  std::nullptr_t>::type = nullptr,\n          typename... Args>\nany call(F fn, Args &&... args) {\n  fn(std::forward<Args>(args)...);\n  return any();\n}\n\ntemplate <typename R, typename F,\n          typename std::enable_if<\n              std::is_same<typename std::remove_cv<R>::type, any>::value,\n              std::nullptr_t>::type = nullptr,\n          typename... Args>\nany call(F fn, Args &&... args) {\n  return fn(std::forward<Args>(args)...);\n}\n\ntemplate <typename R, typename F,\n          typename std::enable_if<\n              !std::is_void<R>::value &&\n                  !std::is_same<typename std::remove_cv<R>::type, any>::value,\n              std::nullptr_t>::type = nullptr,\n          typename... Args>\nany call(F fn, Args &&... args) {\n  return any(fn(std::forward<Args>(args)...));\n}\n\nclass Action {\npublic:\n  Action() = default;\n  Action(const Action &rhs) = default;\n\n  template <typename F,\n            typename std::enable_if<!std::is_pointer<F>::value &&\n                                        !std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  Action(F fn) : fn_(make_adaptor(fn, &F::operator())) {}\n\n  template <typename F, typename std::enable_if<std::is_pointer<F>::value,\n                                                std::nullptr_t>::type = nullptr>\n  Action(F fn) : fn_(make_adaptor(fn, fn)) {}\n\n  template <typename F,\n            typename std::enable_if<std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  Action(F /*fn*/) {}\n\n  template <typename F,\n            typename std::enable_if<!std::is_pointer<F>::value &&\n                                        !std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  void operator=(F fn) {\n    fn_ = make_adaptor(fn, &F::operator());\n  }\n\n  template <typename F, typename std::enable_if<std::is_pointer<F>::value,\n                                                std::nullptr_t>::type = nullptr>\n  void operator=(F fn) {\n    fn_ = make_adaptor(fn, fn);\n  }\n\n  template <typename F,\n            typename std::enable_if<std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  void operator=(F /*fn*/) {}\n\n  Action &operator=(const Action &rhs) = default;\n\n  operator bool() const { return bool(fn_); }\n\n  any operator()(SemanticValues &sv, any &dt) const { return fn_(sv, dt); }\n\nprivate:\n  template <typename R> struct TypeAdaptor_sv {\n    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}\n    any operator()(SemanticValues &sv, any & /*dt*/) {\n      return call<R>(fn_, sv);\n    }\n    std::function<R(SemanticValues &sv)> fn_;\n  };\n\n  template <typename R> struct TypeAdaptor_csv {\n    TypeAdaptor_csv(std::function<R(const SemanticValues &sv)> fn) : fn_(fn) {}\n    any operator()(SemanticValues &sv, any & /*dt*/) {\n      return call<R>(fn_, sv);\n    }\n    std::function<R(const SemanticValues &sv)> fn_;\n  };\n\n  template <typename R> struct TypeAdaptor_sv_dt {\n    TypeAdaptor_sv_dt(std::function<R(SemanticValues &sv, any &dt)> fn)\n        : fn_(fn) {}\n    any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }\n    std::function<R(SemanticValues &sv, any &dt)> fn_;\n  };\n\n  template <typename R> struct TypeAdaptor_csv_dt {\n    TypeAdaptor_csv_dt(std::function<R(const SemanticValues &sv, any &dt)> fn)\n        : fn_(fn) {}\n    any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }\n    std::function<R(const SemanticValues &sv, any &dt)> fn_;\n  };\n\n  typedef std::function<any(SemanticValues &sv, any &dt)> Fty;\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv) const) {\n    return TypeAdaptor_sv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv) const) {\n    return TypeAdaptor_csv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv)) {\n    return TypeAdaptor_sv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv)) {\n    return TypeAdaptor_csv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(SemanticValues &sv)) {\n    return TypeAdaptor_sv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(const SemanticValues &sv)) {\n    return TypeAdaptor_csv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv, any &dt) const) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv, any &dt) const) {\n    return TypeAdaptor_csv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_csv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(const SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_csv_dt<R>(fn);\n  }\n\n  Fty fn_;\n};\n\n/*\n * Semantic predicate\n */\n// Note: 'parse_error' exception class should be be used in sematic action\n// handlers to reject the rule.\nstruct parse_error {\n  parse_error() = default;\n  parse_error(const char *s) : s_(s) {}\n  const char *what() const { return s_.empty() ? nullptr : s_.c_str(); }\n\nprivate:\n  std::string s_;\n};\n\n/*\n * Result\n */\ninline bool success(size_t len) { return len != static_cast<size_t>(-1); }\n\ninline bool fail(size_t len) { return len == static_cast<size_t>(-1); }\n\n/*\n * Context\n */\nclass Context;\nclass Ope;\nclass Definition;\n\ntypedef std::function<void(const char *name, const char *s, size_t n,\n                           const SemanticValues &sv, const Context &c,\n                           const any &dt)>\n    TracerEnter;\n\ntypedef std::function<void(const char *name, const char *s, size_t n,\n                           const SemanticValues &sv, const Context &c,\n                           const any &dt, size_t)>\n    TracerLeave;\n\nclass Context {\npublic:\n  const char *path;\n  const char *s;\n  const size_t l;\n  std::vector<size_t> source_line_index;\n\n  const char *error_pos = nullptr;\n  const char *message_pos = nullptr;\n  std::string message; // TODO: should be `int`.\n\n  std::vector<std::shared_ptr<SemanticValues>> value_stack;\n  size_t value_stack_size = 0;\n\n  std::vector<Definition *> rule_stack;\n  std::vector<std::vector<std::shared_ptr<Ope>>> args_stack;\n\n  bool in_token = false;\n\n  std::shared_ptr<Ope> whitespaceOpe;\n  bool in_whitespace = false;\n\n  std::shared_ptr<Ope> wordOpe;\n\n  std::vector<std::map<std::string, std::string>> capture_scope_stack;\n  size_t capture_scope_stack_size = 0;\n\n  const size_t def_count;\n  const bool enablePackratParsing;\n  std::vector<bool> cache_registered;\n  std::vector<bool> cache_success;\n\n  std::map<std::pair<size_t, size_t>, std::tuple<size_t, any>> cache_values;\n\n  TracerEnter tracer_enter;\n  TracerLeave tracer_leave;\n\n  Context(const char *a_path, const char *a_s, size_t a_l, size_t a_def_count,\n          std::shared_ptr<Ope> a_whitespaceOpe, std::shared_ptr<Ope> a_wordOpe,\n          bool a_enablePackratParsing, TracerEnter a_tracer_enter,\n          TracerLeave a_tracer_leave)\n      : path(a_path), s(a_s), l(a_l), whitespaceOpe(a_whitespaceOpe),\n        wordOpe(a_wordOpe), def_count(a_def_count),\n        enablePackratParsing(a_enablePackratParsing),\n        cache_registered(enablePackratParsing ? def_count * (l + 1) : 0),\n        cache_success(enablePackratParsing ? def_count * (l + 1) : 0),\n        tracer_enter(a_tracer_enter), tracer_leave(a_tracer_leave) {\n\n    for (size_t pos = 0; pos < l; pos++) {\n      if (s[pos] == '\\n') { source_line_index.push_back(pos); }\n    }\n    source_line_index.push_back(l);\n\n    args_stack.resize(1);\n\n    push_capture_scope();\n  }\n\n  ~Context() { assert(!value_stack_size); }\n\n  Context(const Context &) = delete;\n  Context(Context &&) = delete;\n  Context operator=(const Context &) = delete;\n\n  template <typename T>\n  void packrat(const char *a_s, size_t def_id, size_t &len, any &val, T fn) {\n    if (!enablePackratParsing) {\n      fn(val);\n      return;\n    }\n\n    auto col = a_s - s;\n    auto idx = def_count * static_cast<size_t>(col) + def_id;\n\n    if (cache_registered[idx]) {\n      if (cache_success[idx]) {\n        auto key = std::make_pair(col, def_id);\n        std::tie(len, val) = cache_values[key];\n        return;\n      } else {\n        len = static_cast<size_t>(-1);\n        return;\n      }\n    } else {\n      fn(val);\n      cache_registered[idx] = true;\n      cache_success[idx] = success(len);\n      if (success(len)) {\n        auto key = std::make_pair(col, def_id);\n        cache_values[key] = std::make_pair(len, val);\n      }\n      return;\n    }\n  }\n\n  SemanticValues &push() {\n    assert(value_stack_size <= value_stack.size());\n    if (value_stack_size == value_stack.size()) {\n      value_stack.emplace_back(std::make_shared<SemanticValues>());\n    } else {\n      auto &sv = *value_stack[value_stack_size];\n      if (!sv.empty()) {\n        sv.clear();\n        if (!sv.tags.empty()) { sv.tags.clear(); }\n      }\n      sv.s_ = nullptr;\n      sv.n_ = 0;\n      sv.choice_count_ = 0;\n      sv.choice_ = 0;\n      if (!sv.tokens.empty()) { sv.tokens.clear(); }\n    }\n\n    auto &sv = *value_stack[value_stack_size++];\n    sv.path = path;\n    sv.ss = s;\n    sv.source_line_index = &source_line_index;\n    return sv;\n  }\n\n  void pop() { value_stack_size--; }\n\n  void push_args(std::vector<std::shared_ptr<Ope>> &&args) {\n    args_stack.emplace_back(args);\n  }\n\n  void pop_args() { args_stack.pop_back(); }\n\n  const std::vector<std::shared_ptr<Ope>> &top_args() const {\n    return args_stack[args_stack.size() - 1];\n  }\n\n  void push_capture_scope() {\n    assert(capture_scope_stack_size <= capture_scope_stack.size());\n    if (capture_scope_stack_size == capture_scope_stack.size()) {\n      capture_scope_stack.emplace_back(std::map<std::string, std::string>());\n    } else {\n      auto &cs = capture_scope_stack[capture_scope_stack_size];\n      if (!cs.empty()) { cs.clear(); }\n    }\n    capture_scope_stack_size++;\n  }\n\n  void pop_capture_scope() { capture_scope_stack_size--; }\n\n  void shift_capture_values() {\n    assert(capture_scope_stack.size() >= 2);\n    auto curr = &capture_scope_stack[capture_scope_stack_size - 1];\n    auto prev = curr - 1;\n    for (const auto &kv : *curr) {\n      (*prev)[kv.first] = kv.second;\n    }\n  }\n\n  void set_error_pos(const char *a_s) {\n    if (error_pos < a_s) error_pos = a_s;\n  }\n\n  void trace_enter(const char *name, const char *a_s, size_t n,\n                   SemanticValues &sv, any &dt) const;\n  void trace_leave(const char *name, const char *a_s, size_t n,\n                   SemanticValues &sv, any &dt, size_t len) const;\n  bool is_traceable(const Ope &ope) const;\n\n  mutable size_t next_trace_id = 0;\n  mutable std::list<size_t> trace_ids;\n};\n\n/*\n * Parser operators\n */\nclass Ope {\npublic:\n  struct Visitor;\n\n  virtual ~Ope() {}\n  size_t parse(const char *s, size_t n, SemanticValues &sv, Context &c,\n               any &dt) const;\n  virtual size_t parse_core(const char *s, size_t n, SemanticValues &sv,\n                            Context &c, any &dt) const = 0;\n  virtual void accept(Visitor &v) = 0;\n};\n\nclass Sequence : public Ope {\npublic:\n  template <typename... Args>\n  Sequence(const Args &... args)\n      : opes_{static_cast<std::shared_ptr<Ope>>(args)...} {}\n  Sequence(const std::vector<std::shared_ptr<Ope>> &opes) : opes_(opes) {}\n  Sequence(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    auto &chldsv = c.push();\n    auto pop_se = make_scope_exit([&]() { c.pop(); });\n    size_t i = 0;\n    for (const auto &ope : opes_) {\n      const auto &rule = *ope;\n      auto len = rule.parse(s + i, n - i, chldsv, c, dt);\n      if (fail(len)) { return static_cast<size_t>(-1); }\n      i += len;\n    }\n    if (!chldsv.empty()) {\n      for (size_t j = 0; j < chldsv.size(); j++) {\n        sv.emplace_back(std::move(chldsv[j]));\n      }\n    }\n    if (!chldsv.tags.empty()) {\n      for (size_t j = 0; j < chldsv.tags.size(); j++) {\n        sv.tags.emplace_back(std::move(chldsv.tags[j]));\n      }\n    }\n    sv.s_ = chldsv.c_str();\n    sv.n_ = chldsv.length();\n    if (!chldsv.tokens.empty()) {\n      for (size_t j = 0; j < chldsv.tokens.size(); j++) {\n        sv.tokens.emplace_back(std::move(chldsv.tokens[j]));\n      }\n    }\n    return i;\n  }\n\n  void accept(Visitor &v) override;\n\n  std::vector<std::shared_ptr<Ope>> opes_;\n};\n\nclass PrioritizedChoice : public Ope {\npublic:\n  template <typename... Args>\n  PrioritizedChoice(const Args &... args)\n      : opes_{static_cast<std::shared_ptr<Ope>>(args)...} {}\n  PrioritizedChoice(const std::vector<std::shared_ptr<Ope>> &opes)\n      : opes_(opes) {}\n  PrioritizedChoice(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    size_t id = 0;\n    for (const auto &ope : opes_) {\n      auto &chldsv = c.push();\n      c.push_capture_scope();\n      auto se = make_scope_exit([&]() {\n        c.pop();\n        c.pop_capture_scope();\n      });\n      auto len = ope->parse(s, n, chldsv, c, dt);\n      if (success(len)) {\n        if (!chldsv.empty()) {\n          for (size_t i = 0; i < chldsv.size(); i++) {\n            sv.emplace_back(std::move(chldsv[i]));\n          }\n        }\n        if (!chldsv.tags.empty()) {\n          for (size_t i = 0; i < chldsv.tags.size(); i++) {\n            sv.tags.emplace_back(std::move(chldsv.tags[i]));\n          }\n        }\n        sv.s_ = chldsv.c_str();\n        sv.n_ = chldsv.length();\n        sv.choice_count_ = opes_.size();\n        sv.choice_ = id;\n        if (!chldsv.tokens.empty()) {\n          for (size_t i = 0; i < chldsv.tokens.size(); i++) {\n            sv.tokens.emplace_back(std::move(chldsv.tokens[i]));\n          }\n        }\n\n        c.shift_capture_values();\n        return len;\n      }\n      id++;\n    }\n    return static_cast<size_t>(-1);\n  }\n\n  void accept(Visitor &v) override;\n\n  size_t size() const { return opes_.size(); }\n\n  std::vector<std::shared_ptr<Ope>> opes_;\n};\n\nclass Repetition : public Ope {\npublic:\n  Repetition(const std::shared_ptr<Ope> &ope, size_t min, size_t max)\n      : ope_(ope), min_(min), max_(max) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    size_t count = 0;\n    size_t i = 0;\n    while (count < min_) {\n      c.push_capture_scope();\n      auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n      const auto &rule = *ope_;\n      auto len = rule.parse(s + i, n - i, sv, c, dt);\n      if (success(len)) {\n        c.shift_capture_values();\n      } else {\n        return static_cast<size_t>(-1);\n      }\n      i += len;\n      count++;\n    }\n\n    auto save_error_pos = c.error_pos;\n    while (n - i > 0 && count < max_) {\n      c.push_capture_scope();\n      auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n      auto save_sv_size = sv.size();\n      auto save_tok_size = sv.tokens.size();\n      const auto &rule = *ope_;\n      auto len = rule.parse(s + i, n - i, sv, c, dt);\n      if (success(len)) {\n        c.shift_capture_values();\n      } else {\n        if (sv.size() != save_sv_size) {\n          sv.erase(sv.begin() + static_cast<std::ptrdiff_t>(save_sv_size));\n          sv.tags.erase(sv.tags.begin() +\n                        static_cast<std::ptrdiff_t>(save_sv_size));\n        }\n        if (sv.tokens.size() != save_tok_size) {\n          sv.tokens.erase(sv.tokens.begin() +\n                          static_cast<std::ptrdiff_t>(save_tok_size));\n        }\n        c.error_pos = save_error_pos;\n        break;\n      }\n      i += len;\n      count++;\n    }\n    return i;\n  }\n\n  void accept(Visitor &v) override;\n\n  bool is_zom() const {\n    return min_ == 0 && max_ == std::numeric_limits<size_t>::max();\n  }\n\n  static std::shared_ptr<Repetition> zom(const std::shared_ptr<Ope> &ope) {\n    return std::make_shared<Repetition>(ope, 0,\n                                        std::numeric_limits<size_t>::max());\n  }\n\n  static std::shared_ptr<Repetition> oom(const std::shared_ptr<Ope> &ope) {\n    return std::make_shared<Repetition>(ope, 1,\n                                        std::numeric_limits<size_t>::max());\n  }\n\n  static std::shared_ptr<Repetition> opt(const std::shared_ptr<Ope> &ope) {\n    return std::make_shared<Repetition>(ope, 0, 1);\n  }\n\n  std::shared_ptr<Ope> ope_;\n  size_t min_;\n  size_t max_;\n};\n\nclass AndPredicate : public Ope {\npublic:\n  AndPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any &dt) const override {\n    auto &chldsv = c.push();\n    c.push_capture_scope();\n    auto se = make_scope_exit([&]() {\n      c.pop();\n      c.pop_capture_scope();\n    });\n    const auto &rule = *ope_;\n    auto len = rule.parse(s, n, chldsv, c, dt);\n    if (success(len)) {\n      return 0;\n    } else {\n      return static_cast<size_t>(-1);\n    }\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\nclass NotPredicate : public Ope {\npublic:\n  NotPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any &dt) const override {\n    auto save_error_pos = c.error_pos;\n    auto &chldsv = c.push();\n    c.push_capture_scope();\n    auto se = make_scope_exit([&]() {\n      c.pop();\n      c.pop_capture_scope();\n    });\n    auto len = ope_->parse(s, n, chldsv, c, dt);\n    if (success(len)) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    } else {\n      c.error_pos = save_error_pos;\n      return 0;\n    }\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\nclass Dictionary : public Ope, public std::enable_shared_from_this<Dictionary> {\npublic:\n  Dictionary(const std::vector<std::string> &v) : trie_(v) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  Trie trie_;\n};\n\nclass LiteralString : public Ope,\n                      public std::enable_shared_from_this<LiteralString> {\npublic:\n  LiteralString(std::string &&s, bool ignore_case)\n      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}\n\n  LiteralString(const std::string &s, bool ignore_case)\n      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::string lit_;\n  bool ignore_case_;\n  mutable std::once_flag init_is_word_;\n  mutable bool is_word_;\n};\n\nclass CharacterClass : public Ope,\n                       public std::enable_shared_from_this<CharacterClass> {\npublic:\n  CharacterClass(const std::string &s, bool negated) : negated_(negated) {\n    auto chars = decode(s.c_str(), s.length());\n    auto i = 0u;\n    while (i < chars.size()) {\n      if (i + 2 < chars.size() && chars[i + 1] == '-') {\n        auto cp1 = chars[i];\n        auto cp2 = chars[i + 2];\n        ranges_.emplace_back(std::make_pair(cp1, cp2));\n        i += 3;\n      } else {\n        auto cp = chars[i];\n        ranges_.emplace_back(std::make_pair(cp, cp));\n        i += 1;\n      }\n    }\n    assert(!ranges_.empty());\n  }\n\n  CharacterClass(const std::vector<std::pair<char32_t, char32_t>> &ranges,\n                 bool negated)\n      : ranges_(ranges), negated_(negated) {\n    assert(!ranges_.empty());\n  }\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any & /*dt*/) const override {\n    if (n < 1) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n\n    char32_t cp = 0;\n    auto len = decode_codepoint(s, n, cp);\n\n    for (const auto &range : ranges_) {\n      if (range.first <= cp && cp <= range.second) {\n        if (negated_) {\n          c.set_error_pos(s);\n          return static_cast<size_t>(-1);\n        } else {\n          return len;\n        }\n      }\n    }\n\n    if (negated_) {\n      return len;\n    } else {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n  }\n\n  void accept(Visitor &v) override;\n\n  std::vector<std::pair<char32_t, char32_t>> ranges_;\n  bool negated_;\n};\n\nclass Character : public Ope, public std::enable_shared_from_this<Character> {\npublic:\n  Character(char ch) : ch_(ch) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any & /*dt*/) const override {\n    if (n < 1 || s[0] != ch_) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n    return 1;\n  }\n\n  void accept(Visitor &v) override;\n\n  char ch_;\n};\n\nclass AnyCharacter : public Ope,\n                     public std::enable_shared_from_this<AnyCharacter> {\npublic:\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any & /*dt*/) const override {\n    auto len = codepoint_length(s, n);\n    if (len < 1) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n    return len;\n  }\n\n  void accept(Visitor &v) override;\n};\n\nclass CaptureScope : public Ope {\npublic:\n  CaptureScope(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    c.push_capture_scope();\n    auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n    const auto &rule = *ope_;\n    auto len = rule.parse(s, n, sv, c, dt);\n    return len;\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\nclass Capture : public Ope {\npublic:\n  typedef std::function<void(const char *s, size_t n, Context &c)> MatchAction;\n\n  Capture(const std::shared_ptr<Ope> &ope, MatchAction ma)\n      : ope_(ope), match_action_(ma) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    const auto &rule = *ope_;\n    auto len = rule.parse(s, n, sv, c, dt);\n    if (success(len) && match_action_) { match_action_(s, len, c); }\n    return len;\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n  MatchAction match_action_;\n};\n\nclass TokenBoundary : public Ope {\npublic:\n  TokenBoundary(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\nclass Ignore : public Ope {\npublic:\n  Ignore(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any &dt) const override {\n    const auto &rule = *ope_;\n    auto &chldsv = c.push();\n    auto se = make_scope_exit([&]() { c.pop(); });\n    return rule.parse(s, n, chldsv, c, dt);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\ntypedef std::function<size_t(const char *s, size_t n, SemanticValues &sv,\n                             any &dt)>\n    Parser;\n\nclass User : public Ope {\npublic:\n  User(Parser fn) : fn_(fn) {}\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv,\n                    Context & /*c*/, any &dt) const override {\n    assert(fn_);\n    return fn_(s, n, sv, dt);\n  }\n  void accept(Visitor &v) override;\n  std::function<size_t(const char *s, size_t n, SemanticValues &sv, any &dt)>\n      fn_;\n};\n\nclass WeakHolder : public Ope {\npublic:\n  WeakHolder(const std::shared_ptr<Ope> &ope) : weak_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    auto ope = weak_.lock();\n    assert(ope);\n    const auto &rule = *ope;\n    return rule.parse(s, n, sv, c, dt);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::weak_ptr<Ope> weak_;\n};\n\nclass Holder : public Ope {\npublic:\n  Holder(Definition *outer) : outer_(outer) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  any reduce(SemanticValues &sv, any &dt) const;\n\n  const char *trace_name() const;\n\n  std::shared_ptr<Ope> ope_;\n  Definition *outer_;\n  mutable std::string trace_name_;\n\n  friend class Definition;\n};\n\ntypedef std::unordered_map<std::string, Definition> Grammar;\n\nclass Reference : public Ope, public std::enable_shared_from_this<Reference> {\npublic:\n  Reference(const Grammar &grammar, const std::string &name, const char *s,\n            bool is_macro, const std::vector<std::shared_ptr<Ope>> &args)\n      : grammar_(grammar), name_(name), s_(s), is_macro_(is_macro), args_(args),\n        rule_(nullptr), iarg_(0) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> get_core_operator() const;\n\n  const Grammar &grammar_;\n  const std::string name_;\n  const char *s_;\n\n  const bool is_macro_;\n  const std::vector<std::shared_ptr<Ope>> args_;\n\n  Definition *rule_;\n  size_t iarg_;\n};\n\nclass Whitespace : public Ope {\npublic:\n  Whitespace(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    if (c.in_whitespace) { return 0; }\n    c.in_whitespace = true;\n    auto se = make_scope_exit([&]() { c.in_whitespace = false; });\n    const auto &rule = *ope_;\n    return rule.parse(s, n, sv, c, dt);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\nclass BackReference : public Ope {\npublic:\n  BackReference(const std::string &name) : name_(name) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::string name_;\n};\n\nclass PrecedenceClimbing : public Ope {\npublic:\n  using BinOpeInfo = std::map<std::string, std::pair<size_t, char>>;\n\n  PrecedenceClimbing(const std::shared_ptr<Ope> &atom,\n                     const std::shared_ptr<Ope> &binop, const BinOpeInfo &info,\n                     const Definition &rule)\n      : atom_(atom), binop_(binop), info_(info), rule_(rule) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    return parse_expression(s, n, sv, c, dt, 0);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> atom_;\n  std::shared_ptr<Ope> binop_;\n  BinOpeInfo info_;\n  const Definition &rule_;\n\nprivate:\n  size_t parse_expression(const char *s, size_t n, SemanticValues &sv,\n                          Context &c, any &dt, size_t min_prec) const;\n\n  Definition &get_reference_for_binop(Context &c) const;\n};\n\n/*\n * Factories\n */\ntemplate <typename... Args> std::shared_ptr<Ope> seq(Args &&... args) {\n  return std::make_shared<Sequence>(static_cast<std::shared_ptr<Ope>>(args)...);\n}\n\ntemplate <typename... Args> std::shared_ptr<Ope> cho(Args &&... args) {\n  return std::make_shared<PrioritizedChoice>(\n      static_cast<std::shared_ptr<Ope>>(args)...);\n}\n\ninline std::shared_ptr<Ope> zom(const std::shared_ptr<Ope> &ope) {\n  return Repetition::zom(ope);\n}\n\ninline std::shared_ptr<Ope> oom(const std::shared_ptr<Ope> &ope) {\n  return Repetition::oom(ope);\n}\n\ninline std::shared_ptr<Ope> opt(const std::shared_ptr<Ope> &ope) {\n  return Repetition::opt(ope);\n}\n\ninline std::shared_ptr<Ope> rep(const std::shared_ptr<Ope> &ope, size_t min,\n                                size_t max) {\n  return std::make_shared<Repetition>(ope, min, max);\n}\n\ninline std::shared_ptr<Ope> apd(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<AndPredicate>(ope);\n}\n\ninline std::shared_ptr<Ope> npd(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<NotPredicate>(ope);\n}\n\ninline std::shared_ptr<Ope> dic(const std::vector<std::string> &v) {\n  return std::make_shared<Dictionary>(v);\n}\n\ninline std::shared_ptr<Ope> lit(std::string &&s) {\n  return std::make_shared<LiteralString>(s, false);\n}\n\ninline std::shared_ptr<Ope> liti(std::string &&s) {\n  return std::make_shared<LiteralString>(s, true);\n}\n\ninline std::shared_ptr<Ope> cls(const std::string &s) {\n  return std::make_shared<CharacterClass>(s, false);\n}\n\ninline std::shared_ptr<Ope>\ncls(const std::vector<std::pair<char32_t, char32_t>> &ranges) {\n  return std::make_shared<CharacterClass>(ranges, false);\n}\n\ninline std::shared_ptr<Ope> ncls(const std::string &s) {\n  return std::make_shared<CharacterClass>(s, true);\n}\n\ninline std::shared_ptr<Ope>\nncls(const std::vector<std::pair<char32_t, char32_t>> &ranges) {\n  return std::make_shared<CharacterClass>(ranges, true);\n}\n\ninline std::shared_ptr<Ope> chr(char dt) {\n  return std::make_shared<Character>(dt);\n}\n\ninline std::shared_ptr<Ope> dot() { return std::make_shared<AnyCharacter>(); }\n\ninline std::shared_ptr<Ope> csc(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<CaptureScope>(ope);\n}\n\ninline std::shared_ptr<Ope> cap(const std::shared_ptr<Ope> &ope,\n                                Capture::MatchAction ma) {\n  return std::make_shared<Capture>(ope, ma);\n}\n\ninline std::shared_ptr<Ope> tok(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<TokenBoundary>(ope);\n}\n\ninline std::shared_ptr<Ope> ign(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<Ignore>(ope);\n}\n\ninline std::shared_ptr<Ope>\nusr(std::function<size_t(const char *s, size_t n, SemanticValues &sv, any &dt)>\n        fn) {\n  return std::make_shared<User>(fn);\n}\n\ninline std::shared_ptr<Ope> ref(const Grammar &grammar, const std::string &name,\n                                const char *s, bool is_macro,\n                                const std::vector<std::shared_ptr<Ope>> &args) {\n  return std::make_shared<Reference>(grammar, name, s, is_macro, args);\n}\n\ninline std::shared_ptr<Ope> wsp(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<Whitespace>(std::make_shared<Ignore>(ope));\n}\n\ninline std::shared_ptr<Ope> bkr(const std::string &name) {\n  return std::make_shared<BackReference>(name);\n}\n\ninline std::shared_ptr<Ope> pre(const std::shared_ptr<Ope> &atom,\n                                const std::shared_ptr<Ope> &binop,\n                                const PrecedenceClimbing::BinOpeInfo &info,\n                                const Definition &rule) {\n  return std::make_shared<PrecedenceClimbing>(atom, binop, info, rule);\n}\n\n/*\n * Visitor\n */\nstruct Ope::Visitor {\n  virtual ~Visitor() {}\n  virtual void visit(Sequence & /*ope*/) {}\n  virtual void visit(PrioritizedChoice & /*ope*/) {}\n  virtual void visit(Repetition & /*ope*/) {}\n  virtual void visit(AndPredicate & /*ope*/) {}\n  virtual void visit(NotPredicate & /*ope*/) {}\n  virtual void visit(Dictionary & /*ope*/) {}\n  virtual void visit(LiteralString & /*ope*/) {}\n  virtual void visit(CharacterClass & /*ope*/) {}\n  virtual void visit(Character & /*ope*/) {}\n  virtual void visit(AnyCharacter & /*ope*/) {}\n  virtual void visit(CaptureScope & /*ope*/) {}\n  virtual void visit(Capture & /*ope*/) {}\n  virtual void visit(TokenBoundary & /*ope*/) {}\n  virtual void visit(Ignore & /*ope*/) {}\n  virtual void visit(User & /*ope*/) {}\n  virtual void visit(WeakHolder & /*ope*/) {}\n  virtual void visit(Holder & /*ope*/) {}\n  virtual void visit(Reference & /*ope*/) {}\n  virtual void visit(Whitespace & /*ope*/) {}\n  virtual void visit(BackReference & /*ope*/) {}\n  virtual void visit(PrecedenceClimbing & /*ope*/) {}\n};\n\nstruct IsReference : public Ope::Visitor {\n  using Ope::Visitor::visit;\n  void visit(Reference & /*ope*/) override { is_reference = true; }\n  bool is_reference = false;\n};\n\nstruct TraceOpeName : public Ope::Visitor {\n  void visit(Sequence & /*ope*/) override { name = \"Sequence\"; }\n  void visit(PrioritizedChoice & /*ope*/) override {\n    name = \"PrioritizedChoice\";\n  }\n  void visit(Repetition & /*ope*/) override { name = \"Repetition\"; }\n  void visit(AndPredicate & /*ope*/) override { name = \"AndPredicate\"; }\n  void visit(NotPredicate & /*ope*/) override { name = \"NotPredicate\"; }\n  void visit(Dictionary & /*ope*/) override { name = \"Dictionary\"; }\n  void visit(LiteralString & /*ope*/) override { name = \"LiteralString\"; }\n  void visit(CharacterClass & /*ope*/) override { name = \"CharacterClass\"; }\n  void visit(Character & /*ope*/) override { name = \"Character\"; }\n  void visit(AnyCharacter & /*ope*/) override { name = \"AnyCharacter\"; }\n  void visit(CaptureScope & /*ope*/) override { name = \"CaptureScope\"; }\n  void visit(Capture & /*ope*/) override { name = \"Capture\"; }\n  void visit(TokenBoundary & /*ope*/) override { name = \"TokenBoundary\"; }\n  void visit(Ignore & /*ope*/) override { name = \"Ignore\"; }\n  void visit(User & /*ope*/) override { name = \"User\"; }\n  void visit(WeakHolder & /*ope*/) override { name = \"WeakHolder\"; }\n  void visit(Holder &ope) override { name = ope.trace_name(); }\n  void visit(Reference & /*ope*/) override { name = \"Reference\"; }\n  void visit(Whitespace & /*ope*/) override { name = \"Whitespace\"; }\n  void visit(BackReference & /*ope*/) override { name = \"BackReference\"; }\n  void visit(PrecedenceClimbing & /*ope*/) override {\n    name = \"PrecedenceClimbing\";\n  }\n\n  const char *name = nullptr;\n};\n\nstruct AssignIDToDefinition : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override;\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override;\n\n  std::unordered_map<void *, size_t> ids;\n};\n\nstruct IsLiteralToken : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      if (!IsLiteralToken::check(*op)) { return; }\n    }\n    result_ = true;\n  }\n\n  void visit(Dictionary & /*ope*/) override { result_ = true; }\n  void visit(LiteralString & /*ope*/) override { result_ = true; }\n\n  static bool check(Ope &ope) {\n    IsLiteralToken vis;\n    ope.accept(vis);\n    return vis.result_;\n  }\n\nprivate:\n  bool result_ = false;\n};\n\nstruct TokenChecker : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary & /*ope*/) override { has_token_boundary_ = true; }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override;\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  static bool is_token(Ope &ope) {\n    if (IsLiteralToken::check(ope)) { return true; }\n\n    TokenChecker vis;\n    ope.accept(vis);\n    return vis.has_token_boundary_ || !vis.has_rule_;\n  }\n\nprivate:\n  bool has_token_boundary_ = false;\n  bool has_rule_ = false;\n};\n\nstruct DetectLeftRecursion : public Ope::Visitor {\n  DetectLeftRecursion(const std::string &name) : name_(name) {}\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (done_) {\n        break;\n      } else if (error_s) {\n        done_ = true;\n        break;\n      }\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (error_s) {\n        done_ = true;\n        break;\n      }\n    }\n  }\n  void visit(Repetition &ope) override {\n    ope.ope_->accept(*this);\n    done_ = ope.min_ > 0;\n  }\n  void visit(AndPredicate &ope) override {\n    ope.ope_->accept(*this);\n    done_ = false;\n  }\n  void visit(NotPredicate &ope) override {\n    ope.ope_->accept(*this);\n    done_ = false;\n  }\n  void visit(Dictionary & /*ope*/) override { done_ = true; }\n  void visit(LiteralString &ope) override { done_ = !ope.lit_.empty(); }\n  void visit(CharacterClass & /*ope*/) override { done_ = true; }\n  void visit(Character & /*ope*/) override { done_ = true; }\n  void visit(AnyCharacter & /*ope*/) override { done_ = true; }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(User & /*ope*/) override { done_ = true; }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(BackReference & /*ope*/) override { done_ = true; }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  const char *error_s = nullptr;\n\nprivate:\n  std::string name_;\n  std::set<std::string> refs_;\n  bool done_ = false;\n};\n\nstruct HasEmptyElement : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  HasEmptyElement(std::list<std::pair<const char *, std::string>> &refs)\n      : refs_(refs) {}\n\n  void visit(Sequence &ope) override {\n    bool save_is_empty = false;\n    const char *save_error_s = nullptr;\n    std::string save_error_name;\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (!is_empty) { return; }\n      save_is_empty = is_empty;\n      save_error_s = error_s;\n      save_error_name = error_name;\n      is_empty = false;\n      error_name.clear();\n    }\n    is_empty = save_is_empty;\n    error_s = save_error_s;\n    error_name = save_error_name;\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (is_empty) { return; }\n    }\n  }\n  void visit(Repetition &ope) override {\n    if (ope.min_ == 0) {\n      set_error();\n    } else {\n      ope.ope_->accept(*this);\n    }\n  }\n  void visit(AndPredicate & /*ope*/) override { set_error(); }\n  void visit(NotPredicate & /*ope*/) override { set_error(); }\n  void visit(LiteralString &ope) override {\n    if (ope.lit_.empty()) { set_error(); }\n  }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  bool is_empty = false;\n  const char *error_s = nullptr;\n  std::string error_name;\n\nprivate:\n  void set_error() {\n    is_empty = true;\n    error_s = refs_.back().first;\n    error_name = refs_.back().second;\n  }\n  std::list<std::pair<const char *, std::string>> &refs_;\n};\n\nstruct DetectInfiniteLoop : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  DetectInfiniteLoop(const char *s, const std::string &name) {\n    refs_.emplace_back(s, name);\n  }\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (has_error) { return; }\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (has_error) { return; }\n    }\n  }\n  void visit(Repetition &ope) override {\n    if (ope.max_ == std::numeric_limits<size_t>::max()) {\n      HasEmptyElement vis(refs_);\n      ope.ope_->accept(vis);\n      if (vis.is_empty) {\n        has_error = true;\n        error_s = vis.error_s;\n        error_name = vis.error_name;\n      }\n    } else {\n      ope.ope_->accept(*this);\n    }\n  }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  bool has_error = false;\n  const char *error_s = nullptr;\n  std::string error_name;\n\nprivate:\n  std::list<std::pair<const char *, std::string>> refs_;\n};\n\nstruct ReferenceChecker : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  ReferenceChecker(const Grammar &grammar,\n                   const std::vector<std::string> &params)\n      : grammar_(grammar), params_(params) {}\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  std::unordered_map<std::string, const char *> error_s;\n  std::unordered_map<std::string, std::string> error_message;\n\nprivate:\n  const Grammar &grammar_;\n  const std::vector<std::string> &params_;\n};\n\nstruct LinkReferences : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  LinkReferences(Grammar &grammar, const std::vector<std::string> &params)\n      : grammar_(grammar), params_(params) {}\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\nprivate:\n  Grammar &grammar_;\n  const std::vector<std::string> &params_;\n};\n\nstruct FindReference : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  FindReference(const std::vector<std::shared_ptr<Ope>> &args,\n                const std::vector<std::string> &params)\n      : args_(args), params_(params) {}\n\n  void visit(Sequence &ope) override {\n    std::vector<std::shared_ptr<Ope>> opes;\n    for (auto o : ope.opes_) {\n      o->accept(*this);\n      opes.push_back(found_ope);\n    }\n    found_ope = std::make_shared<Sequence>(opes);\n  }\n  void visit(PrioritizedChoice &ope) override {\n    std::vector<std::shared_ptr<Ope>> opes;\n    for (auto o : ope.opes_) {\n      o->accept(*this);\n      opes.push_back(found_ope);\n    }\n    found_ope = std::make_shared<PrioritizedChoice>(opes);\n  }\n  void visit(Repetition &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = rep(found_ope, ope.min_, ope.max_);\n  }\n  void visit(AndPredicate &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = apd(found_ope);\n  }\n  void visit(NotPredicate &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = npd(found_ope);\n  }\n  void visit(Dictionary &ope) override { found_ope = ope.shared_from_this(); }\n  void visit(LiteralString &ope) override {\n    found_ope = ope.shared_from_this();\n  }\n  void visit(CharacterClass &ope) override {\n    found_ope = ope.shared_from_this();\n  }\n  void visit(Character &ope) override { found_ope = ope.shared_from_this(); }\n  void visit(AnyCharacter &ope) override { found_ope = ope.shared_from_this(); }\n  void visit(CaptureScope &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = csc(found_ope);\n  }\n  void visit(Capture &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = cap(found_ope, ope.match_action_);\n  }\n  void visit(TokenBoundary &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = tok(found_ope);\n  }\n  void visit(Ignore &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = ign(found_ope);\n  }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = wsp(found_ope);\n  }\n  void visit(PrecedenceClimbing &ope) override {\n    ope.atom_->accept(*this);\n    found_ope = csc(found_ope);\n  }\n\n  std::shared_ptr<Ope> found_ope;\n\nprivate:\n  const std::vector<std::shared_ptr<Ope>> &args_;\n  const std::vector<std::string> &params_;\n};\n\nstruct IsPrioritizedChoice : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(PrioritizedChoice & /*ope*/) override { result_ = true; }\n\n  static bool check(Ope &ope) {\n    IsPrioritizedChoice vis;\n    ope.accept(vis);\n    return vis.result_;\n  }\n\nprivate:\n  bool result_ = false;\n};\n\n/*\n * Keywords\n */\nstatic const char *WHITESPACE_DEFINITION_NAME = \"%whitespace\";\nstatic const char *WORD_DEFINITION_NAME = \"%word\";\n\n/*\n * Definition\n */\nclass Definition {\npublic:\n  struct Result {\n    bool ret;\n    size_t len;\n    const char *error_pos;\n    const char *message_pos;\n    const std::string message;\n  };\n\n  Definition() : holder_(std::make_shared<Holder>(this)) {}\n\n  Definition(const Definition &rhs) : name(rhs.name), holder_(rhs.holder_) {\n    holder_->outer_ = this;\n  }\n\n  Definition(const std::shared_ptr<Ope> &ope)\n      : holder_(std::make_shared<Holder>(this)) {\n    *this <= ope;\n  }\n\n  operator std::shared_ptr<Ope>() {\n    return std::make_shared<WeakHolder>(holder_);\n  }\n\n  Definition &operator<=(const std::shared_ptr<Ope> &ope) {\n    holder_->ope_ = ope;\n    return *this;\n  }\n\n  Result parse(const char *s, size_t n, const char *path = nullptr) const {\n    SemanticValues sv;\n    any dt;\n    return parse_core(s, n, sv, dt, path);\n  }\n\n  Result parse(const char *s, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse(s, n, path);\n  }\n\n  Result parse(const char *s, size_t n, any &dt,\n               const char *path = nullptr) const {\n    SemanticValues sv;\n    return parse_core(s, n, sv, dt, path);\n  }\n\n  Result parse(const char *s, any &dt, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse(s, n, dt, path);\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, size_t n, T &val,\n                             const char *path = nullptr) const {\n    SemanticValues sv;\n    any dt;\n    auto r = parse_core(s, n, sv, dt, path);\n    if (r.ret && !sv.empty() && sv.front().has_value()) {\n      val = any_cast<T>(sv[0]);\n    }\n    return r;\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, T &val,\n                             const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_and_get_value(s, n, val, path);\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, size_t n, any &dt, T &val,\n                             const char *path = nullptr) const {\n    SemanticValues sv;\n    auto r = parse_core(s, n, sv, dt, path);\n    if (r.ret && !sv.empty() && sv.front().has_value()) {\n      val = any_cast<T>(sv[0]);\n    }\n    return r;\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, any &dt, T &val,\n                             const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_and_get_value(s, n, dt, val, path);\n  }\n\n  Action operator=(Action a) {\n    action = a;\n    return a;\n  }\n\n  template <typename T> Definition &operator,(T fn) {\n    operator=(fn);\n    return *this;\n  }\n\n  Definition &operator~() {\n    ignoreSemanticValue = true;\n    return *this;\n  }\n\n  void accept(Ope::Visitor &v) { holder_->accept(v); }\n\n  std::shared_ptr<Ope> get_core_operator() const { return holder_->ope_; }\n\n  bool is_token() const {\n    std::call_once(is_token_init_, [this]() {\n      is_token_ = TokenChecker::is_token(*get_core_operator());\n    });\n    return is_token_;\n  }\n\n  std::string name;\n  const char *s_ = nullptr;\n\n  size_t id = 0;\n  Action action;\n  std::function<void(const char *s, size_t n, any &dt)> enter;\n  std::function<void(const char *s, size_t n, size_t matchlen, any &value,\n                     any &dt)>\n      leave;\n  std::function<std::string()> error_message;\n  bool ignoreSemanticValue = false;\n  std::shared_ptr<Ope> whitespaceOpe;\n  std::shared_ptr<Ope> wordOpe;\n  bool enablePackratParsing = false;\n  bool is_macro = false;\n  std::vector<std::string> params;\n  TracerEnter tracer_enter;\n  TracerLeave tracer_leave;\n  bool disable_action = false;\n\nprivate:\n  friend class Reference;\n  friend class ParserGenerator;\n\n  Definition &operator=(const Definition &rhs);\n  Definition &operator=(Definition &&rhs);\n\n  void initialize_definition_ids() const {\n    std::call_once(definition_ids_init_, [&]() {\n      AssignIDToDefinition vis;\n      holder_->accept(vis);\n      if (whitespaceOpe) { whitespaceOpe->accept(vis); }\n      if (wordOpe) { wordOpe->accept(vis); }\n      definition_ids_.swap(vis.ids);\n    });\n  }\n\n  Result parse_core(const char *s, size_t n, SemanticValues &sv, any &dt,\n                    const char *path) const {\n    initialize_definition_ids();\n\n    std::shared_ptr<Ope> ope = holder_;\n    if (whitespaceOpe) { ope = std::make_shared<Sequence>(whitespaceOpe, ope); }\n\n    Context cxt(path, s, n, definition_ids_.size(), whitespaceOpe, wordOpe,\n                enablePackratParsing, tracer_enter, tracer_leave);\n\n    auto len = ope->parse(s, n, sv, cxt, dt);\n    return Result{success(len), len, cxt.error_pos, cxt.message_pos,\n                  cxt.message};\n  }\n\n  std::shared_ptr<Holder> holder_;\n  mutable std::once_flag is_token_init_;\n  mutable bool is_token_ = false;\n  mutable std::once_flag assign_id_to_definition_init_;\n  mutable std::once_flag definition_ids_init_;\n  mutable std::unordered_map<void *, size_t> definition_ids_;\n};\n\n/*\n * Implementations\n */\n\ninline size_t parse_literal(const char *s, size_t n, SemanticValues &sv,\n                            Context &c, any &dt, const std::string &lit,\n                            std::once_flag &init_is_word, bool &is_word,\n                            bool ignore_case) {\n  size_t i = 0;\n  for (; i < lit.size(); i++) {\n    if (i >= n || (ignore_case ? (std::tolower(s[i]) != std::tolower(lit[i]))\n                               : (s[i] != lit[i]))) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n  }\n\n  // Word check\n  static Context dummy_c(nullptr, c.s, c.l, 0, nullptr, nullptr, false, nullptr,\n                         nullptr);\n  static SemanticValues dummy_sv;\n  static any dummy_dt;\n\n  std::call_once(init_is_word, [&]() {\n    if (c.wordOpe) {\n      auto len =\n          c.wordOpe->parse(lit.data(), lit.size(), dummy_sv, dummy_c, dummy_dt);\n      is_word = success(len);\n    }\n  });\n\n  if (is_word) {\n    NotPredicate ope(c.wordOpe);\n    auto len = ope.parse(s + i, n - i, dummy_sv, dummy_c, dummy_dt);\n    if (fail(len)) { return static_cast<size_t>(-1); }\n    i += len;\n  }\n\n  // Skip whiltespace\n  if (!c.in_token) {\n    if (c.whitespaceOpe) {\n      auto len = c.whitespaceOpe->parse(s + i, n - i, sv, c, dt);\n      if (fail(len)) { return static_cast<size_t>(-1); }\n      i += len;\n    }\n  }\n\n  return i;\n}\n\ninline void Context::trace_enter(const char *name, const char *a_s, size_t n,\n                                 SemanticValues &sv, any &dt) const {\n  trace_ids.push_back(next_trace_id++);\n  tracer_enter(name, a_s, n, sv, *this, dt);\n}\n\ninline void Context::trace_leave(const char *name, const char *a_s, size_t n,\n                                 SemanticValues &sv, any &dt,\n                                 size_t len) const {\n  tracer_leave(name, a_s, n, sv, *this, dt, len);\n  trace_ids.pop_back();\n}\n\ninline bool Context::is_traceable(const Ope &ope) const {\n  if (tracer_enter && tracer_leave) {\n    IsReference vis;\n    const_cast<Ope &>(ope).accept(vis);\n    return !vis.is_reference;\n  }\n  return false;\n}\n\ninline size_t Ope::parse(const char *s, size_t n, SemanticValues &sv,\n                         Context &c, any &dt) const {\n  if (c.is_traceable(*this)) {\n    TraceOpeName vis;\n    const_cast<Ope &>(*this).accept(vis);\n    c.trace_enter(vis.name, s, n, sv, dt);\n    auto len = parse_core(s, n, sv, c, dt);\n    c.trace_leave(vis.name, s, n, sv, dt, len);\n    return len;\n  }\n  return parse_core(s, n, sv, c, dt);\n}\n\ninline size_t Dictionary::parse_core(const char *s, size_t n,\n                                     SemanticValues & /*sv*/, Context &c,\n                                     any & /*dt*/) const {\n  auto len = trie_.match(s, n);\n  if (len > 0) { return len; }\n  c.set_error_pos(s);\n  return static_cast<size_t>(-1);\n}\n\ninline size_t LiteralString::parse_core(const char *s, size_t n,\n                                        SemanticValues &sv, Context &c,\n                                        any &dt) const {\n  return parse_literal(s, n, sv, c, dt, lit_, init_is_word_, is_word_,\n                       ignore_case_);\n}\n\ninline size_t TokenBoundary::parse_core(const char *s, size_t n,\n                                        SemanticValues &sv, Context &c,\n                                        any &dt) const {\n  c.in_token = true;\n  auto se = make_scope_exit([&]() { c.in_token = false; });\n  auto len = ope_->parse(s, n, sv, c, dt);\n  if (success(len)) {\n    sv.tokens.emplace_back(std::make_pair(s, len));\n\n    if (c.whitespaceOpe) {\n      auto l = c.whitespaceOpe->parse(s + len, n - len, sv, c, dt);\n      if (fail(l)) { return static_cast<size_t>(-1); }\n      len += l;\n    }\n  }\n  return len;\n}\n\ninline size_t Holder::parse_core(const char *s, size_t n, SemanticValues &sv,\n                                 Context &c, any &dt) const {\n  if (!ope_) {\n    throw std::logic_error(\"Uninitialized definition ope was used...\");\n  }\n\n  // Macro reference\n  if (outer_->is_macro) {\n    c.rule_stack.push_back(outer_);\n    auto len = ope_->parse(s, n, sv, c, dt);\n    c.rule_stack.pop_back();\n    return len;\n  }\n\n  size_t len;\n  any val;\n\n  c.packrat(s, outer_->id, len, val, [&](any &a_val) {\n    if (outer_->enter) { outer_->enter(s, n, dt); }\n\n    auto se2 = make_scope_exit([&]() {\n      c.pop();\n\n      if (outer_->leave) { outer_->leave(s, n, len, a_val, dt); }\n    });\n\n    auto &chldsv = c.push();\n\n    c.rule_stack.push_back(outer_);\n    len = ope_->parse(s, n, chldsv, c, dt);\n    c.rule_stack.pop_back();\n\n    // Invoke action\n    if (success(len)) {\n      chldsv.s_ = s;\n      chldsv.n_ = len;\n      chldsv.name_ = outer_->name;\n\n      if (!IsPrioritizedChoice::check(*ope_)) {\n        chldsv.choice_count_ = 0;\n        chldsv.choice_ = 0;\n      }\n\n      try {\n        a_val = reduce(chldsv, dt);\n      } catch (const parse_error &e) {\n        if (e.what()) {\n          if (c.message_pos < s) {\n            c.message_pos = s;\n            c.message = e.what();\n          }\n        }\n        len = static_cast<size_t>(-1);\n      }\n    }\n  });\n\n  if (success(len)) {\n    if (!outer_->ignoreSemanticValue) {\n      sv.emplace_back(std::move(val));\n      sv.tags.emplace_back(str2tag(outer_->name.c_str()));\n    }\n  } else {\n    if (outer_->error_message) {\n      if (c.message_pos < s) {\n        c.message_pos = s;\n        c.message = outer_->error_message();\n      }\n    }\n  }\n\n  return len;\n}\n\ninline any Holder::reduce(SemanticValues &sv, any &dt) const {\n  if (outer_->action && !outer_->disable_action) {\n    return outer_->action(sv, dt);\n  } else if (sv.empty()) {\n    return any();\n  } else {\n    return std::move(sv.front());\n  }\n}\n\ninline const char *Holder::trace_name() const {\n  if (trace_name_.empty()) { trace_name_ = \"[\" + outer_->name + \"]\"; }\n  return trace_name_.c_str();\n}\n\ninline size_t Reference::parse_core(const char *s, size_t n, SemanticValues &sv,\n                                    Context &c, any &dt) const {\n  if (rule_) {\n    // Reference rule\n    if (rule_->is_macro) {\n      // Macro\n      FindReference vis(c.top_args(), c.rule_stack.back()->params);\n\n      // Collect arguments\n      std::vector<std::shared_ptr<Ope>> args;\n      for (auto arg : args_) {\n        arg->accept(vis);\n        args.emplace_back(std::move(vis.found_ope));\n      }\n\n      c.push_args(std::move(args));\n      auto se = make_scope_exit([&]() { c.pop_args(); });\n      auto ope = get_core_operator();\n      return ope->parse(s, n, sv, c, dt);\n    } else {\n      // Definition\n      c.push_args(std::vector<std::shared_ptr<Ope>>());\n      auto se = make_scope_exit([&]() { c.pop_args(); });\n      auto ope = get_core_operator();\n      return ope->parse(s, n, sv, c, dt);\n    }\n  } else {\n    // Reference parameter in macro\n    const auto &args = c.top_args();\n    return args[iarg_]->parse(s, n, sv, c, dt);\n  }\n}\n\ninline std::shared_ptr<Ope> Reference::get_core_operator() const {\n  return rule_->holder_;\n}\n\ninline size_t BackReference::parse_core(const char *s, size_t n,\n                                        SemanticValues &sv, Context &c,\n                                        any &dt) const {\n  auto size = static_cast<int>(c.capture_scope_stack_size);\n  for (auto i = size - 1; i >= 0; i--) {\n    auto index = static_cast<size_t>(i);\n    const auto &cs = c.capture_scope_stack[index];\n    if (cs.find(name_) != cs.end()) {\n      const auto &lit = cs.at(name_);\n      std::once_flag init_is_word;\n      auto is_word = false;\n      return parse_literal(s, n, sv, c, dt, lit, init_is_word, is_word, false);\n    }\n  }\n  throw std::runtime_error(\"Invalid back reference...\");\n}\n\ninline Definition &\nPrecedenceClimbing::get_reference_for_binop(Context &c) const {\n  if (rule_.is_macro) {\n    // Reference parameter in macro\n    const auto &args = c.top_args();\n    auto iarg = dynamic_cast<Reference &>(*binop_).iarg_;\n    auto arg = args[iarg];\n    return *dynamic_cast<Reference &>(*arg).rule_;\n  }\n\n  return *dynamic_cast<Reference &>(*binop_).rule_;\n}\n\ninline size_t PrecedenceClimbing::parse_expression(const char *s, size_t n,\n                                                   SemanticValues &sv,\n                                                   Context &c, any &dt,\n                                                   size_t min_prec) const {\n  auto len = atom_->parse(s, n, sv, c, dt);\n  if (fail(len)) { return len; }\n\n  std::string tok;\n  auto &rule = get_reference_for_binop(c);\n  auto action = rule.action;\n\n  rule.action = [&](SemanticValues &sv2, any &dt2) -> any {\n    tok = sv2.token();\n    if (action) {\n      return action(sv2, dt2);\n    } else if (!sv2.empty()) {\n      return sv2[0];\n    }\n    return any();\n  };\n  auto action_se = make_scope_exit([&]() { rule.action = action; });\n\n  auto save_error_pos = c.error_pos;\n\n  auto i = len;\n  while (i < n) {\n    std::vector<any> save_values(sv.begin(), sv.end());\n    auto save_tokens = sv.tokens;\n\n    auto chv = c.push();\n    auto chl = binop_->parse(s + i, n - i, chv, c, dt);\n    c.pop();\n\n    if (fail(chl)) {\n      c.error_pos = save_error_pos;\n      break;\n    }\n\n    auto it = info_.find(tok);\n    if (it == info_.end()) { break; }\n\n    auto level = std::get<0>(it->second);\n    auto assoc = std::get<1>(it->second);\n\n    if (level < min_prec) { break; }\n\n    sv.emplace_back(std::move(chv[0]));\n    i += chl;\n\n    auto next_min_prec = level;\n    if (assoc == 'L') { next_min_prec = level + 1; }\n\n    chv = c.push();\n    chl = parse_expression(s + i, n - i, chv, c, dt, next_min_prec);\n    c.pop();\n\n    if (fail(chl)) {\n      sv.assign(save_values.begin(), save_values.end());\n      sv.tokens = save_tokens;\n      c.error_pos = save_error_pos;\n      break;\n    }\n\n    sv.emplace_back(std::move(chv[0]));\n    i += chl;\n\n    any val;\n    if (rule_.action) {\n      sv.s_ = s;\n      sv.n_ = i;\n      val = rule_.action(sv, dt);\n    } else if (!sv.empty()) {\n      val = sv[0];\n    }\n    sv.clear();\n    sv.emplace_back(std::move(val));\n  }\n\n  return i;\n}\n\ninline void Sequence::accept(Visitor &v) { v.visit(*this); }\ninline void PrioritizedChoice::accept(Visitor &v) { v.visit(*this); }\ninline void Repetition::accept(Visitor &v) { v.visit(*this); }\ninline void AndPredicate::accept(Visitor &v) { v.visit(*this); }\ninline void NotPredicate::accept(Visitor &v) { v.visit(*this); }\ninline void Dictionary::accept(Visitor &v) { v.visit(*this); }\ninline void LiteralString::accept(Visitor &v) { v.visit(*this); }\ninline void CharacterClass::accept(Visitor &v) { v.visit(*this); }\ninline void Character::accept(Visitor &v) { v.visit(*this); }\ninline void AnyCharacter::accept(Visitor &v) { v.visit(*this); }\ninline void CaptureScope::accept(Visitor &v) { v.visit(*this); }\ninline void Capture::accept(Visitor &v) { v.visit(*this); }\ninline void TokenBoundary::accept(Visitor &v) { v.visit(*this); }\ninline void Ignore::accept(Visitor &v) { v.visit(*this); }\ninline void User::accept(Visitor &v) { v.visit(*this); }\ninline void WeakHolder::accept(Visitor &v) { v.visit(*this); }\ninline void Holder::accept(Visitor &v) { v.visit(*this); }\ninline void Reference::accept(Visitor &v) { v.visit(*this); }\ninline void Whitespace::accept(Visitor &v) { v.visit(*this); }\ninline void BackReference::accept(Visitor &v) { v.visit(*this); }\ninline void PrecedenceClimbing::accept(Visitor &v) { v.visit(*this); }\n\ninline void AssignIDToDefinition::visit(Holder &ope) {\n  auto p = static_cast<void *>(ope.outer_);\n  if (ids.count(p)) { return; }\n  auto id = ids.size();\n  ids[p] = id;\n  ope.outer_->id = id;\n  ope.ope_->accept(*this);\n}\n\ninline void AssignIDToDefinition::visit(Reference &ope) {\n  if (ope.rule_) {\n    for (auto arg : ope.args_) {\n      arg->accept(*this);\n    }\n    ope.rule_->accept(*this);\n  }\n}\n\ninline void AssignIDToDefinition::visit(PrecedenceClimbing &ope) {\n  ope.atom_->accept(*this);\n  ope.binop_->accept(*this);\n}\n\ninline void TokenChecker::visit(WeakHolder & /*ope*/) { has_rule_ = true; }\n\ninline void TokenChecker::visit(Reference &ope) {\n  if (ope.is_macro_) {\n    ope.rule_->accept(*this);\n    for (auto arg : ope.args_) {\n      arg->accept(*this);\n    }\n  } else {\n    has_rule_ = true;\n  }\n}\n\ninline void DetectLeftRecursion::visit(Reference &ope) {\n  if (ope.name_ == name_) {\n    error_s = ope.s_;\n  } else if (!refs_.count(ope.name_)) {\n    refs_.insert(ope.name_);\n    if (ope.rule_) {\n      ope.rule_->accept(*this);\n      if (done_ == false) { return; }\n    }\n  }\n  done_ = true;\n}\n\ninline void HasEmptyElement::visit(Reference &ope) {\n  auto it = std::find_if(refs_.begin(), refs_.end(),\n                         [&](const std::pair<const char *, std::string> &ref) {\n                           return ope.name_ == ref.second;\n                         });\n  if (it != refs_.end()) { return; }\n\n  if (ope.rule_) {\n    refs_.emplace_back(ope.s_, ope.name_);\n    ope.rule_->accept(*this);\n    refs_.pop_back();\n  }\n}\n\ninline void DetectInfiniteLoop::visit(Reference &ope) {\n  auto it = std::find_if(refs_.begin(), refs_.end(),\n                         [&](const std::pair<const char *, std::string> &ref) {\n                           return ope.name_ == ref.second;\n                         });\n  if (it != refs_.end()) { return; }\n\n  if (ope.rule_) {\n    refs_.emplace_back(ope.s_, ope.name_);\n    ope.rule_->accept(*this);\n    refs_.pop_back();\n  }\n}\n\ninline void ReferenceChecker::visit(Reference &ope) {\n  auto it = std::find(params_.begin(), params_.end(), ope.name_);\n  if (it != params_.end()) { return; }\n\n  if (!grammar_.count(ope.name_)) {\n    error_s[ope.name_] = ope.s_;\n    error_message[ope.name_] = \"'\" + ope.name_ + \"' is not defined.\";\n  } else {\n    const auto &rule = grammar_.at(ope.name_);\n    if (rule.is_macro) {\n      if (!ope.is_macro_ || ope.args_.size() != rule.params.size()) {\n        error_s[ope.name_] = ope.s_;\n        error_message[ope.name_] = \"incorrect number of arguments.\";\n      }\n    } else if (ope.is_macro_) {\n      error_s[ope.name_] = ope.s_;\n      error_message[ope.name_] = \"'\" + ope.name_ + \"' is not macro.\";\n    }\n  }\n}\n\ninline void LinkReferences::visit(Reference &ope) {\n  // Check if the reference is a macro parameter\n  auto found_param = false;\n  for (size_t i = 0; i < params_.size(); i++) {\n    const auto &param = params_[i];\n    if (param == ope.name_) {\n      ope.iarg_ = i;\n      found_param = true;\n      break;\n    }\n  }\n\n  // Check if the reference is a definition rule\n  if (!found_param && grammar_.count(ope.name_)) {\n    auto &rule = grammar_.at(ope.name_);\n    ope.rule_ = &rule;\n  }\n\n  for (auto arg : ope.args_) {\n    arg->accept(*this);\n  }\n}\n\ninline void FindReference::visit(Reference &ope) {\n  for (size_t i = 0; i < args_.size(); i++) {\n    const auto &name = params_[i];\n    if (name == ope.name_) {\n      found_ope = args_[i];\n      return;\n    }\n  }\n  found_ope = ope.shared_from_this();\n}\n\n/*-----------------------------------------------------------------------------\n *  PEG parser generator\n *---------------------------------------------------------------------------*/\n\ntypedef std::unordered_map<std::string, std::shared_ptr<Ope>> Rules;\ntypedef std::function<void(size_t, size_t, const std::string &)> Log;\n\nclass ParserGenerator {\npublic:\n  static std::shared_ptr<Grammar> parse(const char *s, size_t n,\n                                        const Rules &rules, std::string &start,\n                                        Log log) {\n    return get_instance().perform_core(s, n, rules, start, log);\n  }\n\n  static std::shared_ptr<Grammar> parse(const char *s, size_t n,\n                                        std::string &start, Log log) {\n    Rules dummy;\n    return parse(s, n, dummy, start, log);\n  }\n\n  // For debuging purpose\n  static Grammar &grammar() { return get_instance().g; }\n\nprivate:\n  static ParserGenerator &get_instance() {\n    static ParserGenerator instance;\n    return instance;\n  }\n\n  ParserGenerator() {\n    make_grammar();\n    setup_actions();\n  }\n\n  struct Instruction {\n    std::string type;\n    any data;\n  };\n\n  struct Data {\n    std::shared_ptr<Grammar> grammar;\n    std::string start;\n    const char *start_pos = nullptr;\n    std::vector<std::pair<std::string, const char *>> duplicates;\n    std::map<std::string, Instruction> instructions;\n\n    Data() : grammar(std::make_shared<Grammar>()) {}\n  };\n\n  void make_grammar() {\n    // Setup PEG syntax parser\n    g[\"Grammar\"] <= seq(g[\"Spacing\"], oom(g[\"Definition\"]), g[\"EndOfFile\"]);\n    g[\"Definition\"] <=\n        cho(seq(g[\"Ignore\"], g[\"IdentCont\"], g[\"Parameters\"], g[\"LEFTARROW\"],\n                g[\"Expression\"], opt(g[\"Instruction\"])),\n            seq(g[\"Ignore\"], g[\"Identifier\"], g[\"LEFTARROW\"], g[\"Expression\"],\n                opt(g[\"Instruction\"])));\n    g[\"Expression\"] <= seq(g[\"Sequence\"], zom(seq(g[\"SLASH\"], g[\"Sequence\"])));\n    g[\"Sequence\"] <= zom(g[\"Prefix\"]);\n    g[\"Prefix\"] <= seq(opt(cho(g[\"AND\"], g[\"NOT\"])), g[\"Suffix\"]);\n    g[\"Suffix\"] <= seq(g[\"Primary\"], opt(g[\"Loop\"]));\n    g[\"Loop\"] <= cho(g[\"QUESTION\"], g[\"STAR\"], g[\"PLUS\"], g[\"Repetition\"]);\n    g[\"Primary\"] <=\n        cho(seq(g[\"Ignore\"], g[\"IdentCont\"], g[\"Arguments\"],\n                npd(g[\"LEFTARROW\"])),\n            seq(g[\"Ignore\"], g[\"Identifier\"],\n                npd(seq(opt(g[\"Parameters\"]), g[\"LEFTARROW\"]))),\n            seq(g[\"OPEN\"], g[\"Expression\"], g[\"CLOSE\"]),\n            seq(g[\"BeginTok\"], g[\"Expression\"], g[\"EndTok\"]),\n            seq(g[\"BeginCapScope\"], g[\"Expression\"], g[\"EndCapScope\"]),\n            seq(g[\"BeginCap\"], g[\"Expression\"], g[\"EndCap\"]), g[\"BackRef\"],\n            g[\"LiteralI\"], g[\"Dictionary\"], g[\"Literal\"], g[\"NegatedClass\"],\n            g[\"Class\"], g[\"DOT\"]);\n\n    g[\"Identifier\"] <= seq(g[\"IdentCont\"], g[\"Spacing\"]);\n    g[\"IdentCont\"] <= seq(g[\"IdentStart\"], zom(g[\"IdentRest\"]));\n\n    const static std::vector<std::pair<char32_t, char32_t>> range = {\n        {0x0080, 0xFFFF}};\n    g[\"IdentStart\"] <= cho(cls(\"a-zA-Z_%\"), cls(range));\n\n    g[\"IdentRest\"] <= cho(g[\"IdentStart\"], cls(\"0-9\"));\n\n    g[\"Dictionary\"] <= seq(g[\"LiteralD\"], oom(seq(g[\"PIPE\"], g[\"LiteralD\"])));\n\n    auto lit_ope = cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))),\n                           cls(\"'\"), g[\"Spacing\"]),\n                       seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))),\n                           cls(\"\\\"\"), g[\"Spacing\"]));\n    g[\"Literal\"] <= lit_ope;\n    g[\"LiteralD\"] <= lit_ope;\n\n    g[\"LiteralI\"] <=\n        cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))), lit(\"'i\"),\n                g[\"Spacing\"]),\n            seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))), lit(\"\\\"i\"),\n                g[\"Spacing\"]));\n\n    // NOTE: The original Brian Ford's paper uses 'zom' instead of 'oom'.\n    g[\"Class\"] <= seq(chr('['), npd(chr('^')),\n                      tok(oom(seq(npd(chr(']')), g[\"Range\"]))), chr(']'),\n                      g[\"Spacing\"]);\n    g[\"NegatedClass\"] <= seq(lit(\"[^\"),\n                             tok(oom(seq(npd(chr(']')), g[\"Range\"]))), chr(']'),\n                             g[\"Spacing\"]);\n\n    g[\"Range\"] <= cho(seq(g[\"Char\"], chr('-'), g[\"Char\"]), g[\"Char\"]);\n    g[\"Char\"] <= cho(seq(chr('\\\\'), cls(\"nrt'\\\"[]\\\\^\")),\n                     seq(chr('\\\\'), cls(\"0-3\"), cls(\"0-7\"), cls(\"0-7\")),\n                     seq(chr('\\\\'), cls(\"0-7\"), opt(cls(\"0-7\"))),\n                     seq(lit(\"\\\\x\"), cls(\"0-9a-fA-F\"), opt(cls(\"0-9a-fA-F\"))),\n                     seq(lit(\"\\\\u\"), cls(\"0-9a-fA-F\"), cls(\"0-9a-fA-F\"),\n                         cls(\"0-9a-fA-F\"), cls(\"0-9a-fA-F\")),\n                     seq(npd(chr('\\\\')), dot()));\n\n    g[\"Repetition\"] <=\n        seq(g[\"BeginBlacket\"], g[\"RepetitionRange\"], g[\"EndBlacket\"]);\n    g[\"RepetitionRange\"] <= cho(seq(g[\"Number\"], g[\"COMMA\"], g[\"Number\"]),\n                                seq(g[\"Number\"], g[\"COMMA\"]), g[\"Number\"],\n                                seq(g[\"COMMA\"], g[\"Number\"]));\n    g[\"Number\"] <= seq(oom(cls(\"0-9\")), g[\"Spacing\"]);\n\n    g[\"LEFTARROW\"] <=\n        seq(cho(lit(\"<-\"), lit(reinterpret_cast<const char *>(u8\"\u2190\"))),\n            g[\"Spacing\"]);\n    ~g[\"SLASH\"] <= seq(chr('/'), g[\"Spacing\"]);\n    ~g[\"PIPE\"] <= seq(chr('|'), g[\"Spacing\"]);\n    g[\"AND\"] <= seq(chr('&'), g[\"Spacing\"]);\n    g[\"NOT\"] <= seq(chr('!'), g[\"Spacing\"]);\n    g[\"QUESTION\"] <= seq(chr('?'), g[\"Spacing\"]);\n    g[\"STAR\"] <= seq(chr('*'), g[\"Spacing\"]);\n    g[\"PLUS\"] <= seq(chr('+'), g[\"Spacing\"]);\n    ~g[\"OPEN\"] <= seq(chr('('), g[\"Spacing\"]);\n    ~g[\"CLOSE\"] <= seq(chr(')'), g[\"Spacing\"]);\n    g[\"DOT\"] <= seq(chr('.'), g[\"Spacing\"]);\n\n    ~g[\"Spacing\"] <= zom(cho(g[\"Space\"], g[\"Comment\"]));\n    g[\"Comment\"] <=\n        seq(chr('#'), zom(seq(npd(g[\"EndOfLine\"]), dot())), g[\"EndOfLine\"]);\n    g[\"Space\"] <= cho(chr(' '), chr('\\t'), g[\"EndOfLine\"]);\n    g[\"EndOfLine\"] <= cho(lit(\"\\r\\n\"), chr('\\n'), chr('\\r'));\n    g[\"EndOfFile\"] <= npd(dot());\n\n    ~g[\"BeginTok\"] <= seq(chr('<'), g[\"Spacing\"]);\n    ~g[\"EndTok\"] <= seq(chr('>'), g[\"Spacing\"]);\n\n    ~g[\"BeginCapScope\"] <= seq(chr('$'), chr('('), g[\"Spacing\"]);\n    ~g[\"EndCapScope\"] <= seq(chr(')'), g[\"Spacing\"]);\n\n    g[\"BeginCap\"] <= seq(chr('$'), tok(g[\"IdentCont\"]), chr('<'), g[\"Spacing\"]);\n    ~g[\"EndCap\"] <= seq(chr('>'), g[\"Spacing\"]);\n\n    g[\"BackRef\"] <= seq(chr('$'), tok(g[\"IdentCont\"]), g[\"Spacing\"]);\n\n    g[\"IGNORE\"] <= chr('~');\n\n    g[\"Ignore\"] <= opt(g[\"IGNORE\"]);\n    g[\"Parameters\"] <= seq(g[\"OPEN\"], g[\"Identifier\"],\n                           zom(seq(g[\"COMMA\"], g[\"Identifier\"])), g[\"CLOSE\"]);\n    g[\"Arguments\"] <= seq(g[\"OPEN\"], g[\"Expression\"],\n                          zom(seq(g[\"COMMA\"], g[\"Expression\"])), g[\"CLOSE\"]);\n    ~g[\"COMMA\"] <= seq(chr(','), g[\"Spacing\"]);\n\n    // Instruction grammars\n    g[\"Instruction\"] <=\n        seq(g[\"BeginBlacket\"], cho(g[\"PrecedenceClimbing\"]), g[\"EndBlacket\"]);\n\n    ~g[\"SpacesZom\"] <= zom(g[\"Space\"]);\n    ~g[\"SpacesOom\"] <= oom(g[\"Space\"]);\n    ~g[\"BeginBlacket\"] <= seq(chr('{'), g[\"Spacing\"]);\n    ~g[\"EndBlacket\"] <= seq(chr('}'), g[\"Spacing\"]);\n\n    // PrecedenceClimbing instruction\n    g[\"PrecedenceClimbing\"] <=\n        seq(lit(\"precedence\"), g[\"SpacesZom\"], g[\"PrecedenceInfo\"],\n            zom(seq(g[\"SpacesOom\"], g[\"PrecedenceInfo\"])), g[\"SpacesZom\"]);\n    g[\"PrecedenceInfo\"] <=\n        seq(g[\"PrecedenceAssoc\"],\n            oom(seq(ign(g[\"SpacesOom\"]), g[\"PrecedenceOpe\"])));\n    g[\"PrecedenceOpe\"] <=\n        tok(oom(\n            seq(npd(cho(g[\"PrecedenceAssoc\"], g[\"Space\"], chr('}'))), dot())));\n    g[\"PrecedenceAssoc\"] <= cls(\"LR\");\n\n    // Set definition names\n    for (auto &x : g) {\n      x.second.name = x.first;\n    }\n  }\n\n  void setup_actions() {\n    g[\"Definition\"] = [&](const SemanticValues &sv, any &dt) {\n      Data &data = *any_cast<Data *>(dt);\n\n      auto is_macro = sv.choice() == 0;\n      auto ignore = any_cast<bool>(sv[0]);\n      auto name = any_cast<std::string>(sv[1]);\n\n      std::vector<std::string> params;\n      std::shared_ptr<Ope> ope;\n      if (is_macro) {\n        params = any_cast<std::vector<std::string>>(sv[2]);\n        ope = any_cast<std::shared_ptr<Ope>>(sv[4]);\n        if (sv.size() == 6) {\n          data.instructions[name] = any_cast<Instruction>(sv[5]);\n        }\n      } else {\n        ope = any_cast<std::shared_ptr<Ope>>(sv[3]);\n        if (sv.size() == 5) {\n          data.instructions[name] = any_cast<Instruction>(sv[4]);\n        }\n      }\n\n      auto &grammar = *data.grammar;\n      if (!grammar.count(name)) {\n        auto &rule = grammar[name];\n        rule <= ope;\n        rule.name = name;\n        rule.s_ = sv.c_str();\n        rule.ignoreSemanticValue = ignore;\n        rule.is_macro = is_macro;\n        rule.params = params;\n\n        if (data.start.empty()) {\n          data.start = name;\n          data.start_pos = sv.c_str();\n        }\n      } else {\n        data.duplicates.emplace_back(name, sv.c_str());\n      }\n    };\n\n    g[\"Expression\"] = [&](const SemanticValues &sv) {\n      if (sv.size() == 1) {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        std::vector<std::shared_ptr<Ope>> opes;\n        for (auto i = 0u; i < sv.size(); i++) {\n          opes.emplace_back(any_cast<std::shared_ptr<Ope>>(sv[i]));\n        }\n        const std::shared_ptr<Ope> ope =\n            std::make_shared<PrioritizedChoice>(opes);\n        return ope;\n      }\n    };\n\n    g[\"Sequence\"] = [&](const SemanticValues &sv) {\n      if (sv.size() == 1) {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        std::vector<std::shared_ptr<Ope>> opes;\n        for (const auto &x : sv) {\n          opes.emplace_back(any_cast<std::shared_ptr<Ope>>(x));\n        }\n        const std::shared_ptr<Ope> ope = std::make_shared<Sequence>(opes);\n        return ope;\n      }\n    };\n\n    g[\"Prefix\"] = [&](const SemanticValues &sv) {\n      std::shared_ptr<Ope> ope;\n      if (sv.size() == 1) {\n        ope = any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        assert(sv.size() == 2);\n        auto tok = any_cast<char>(sv[0]);\n        ope = any_cast<std::shared_ptr<Ope>>(sv[1]);\n        if (tok == '&') {\n          ope = apd(ope);\n        } else { // '!'\n          ope = npd(ope);\n        }\n      }\n      return ope;\n    };\n\n    struct Loop {\n      enum class Type { opt = 0, zom, oom, rep };\n      Type type;\n      std::pair<size_t, size_t> range;\n    };\n\n    g[\"Suffix\"] = [&](const SemanticValues &sv) {\n      auto ope = any_cast<std::shared_ptr<Ope>>(sv[0]);\n      if (sv.size() == 1) {\n        return ope;\n      } else {\n        assert(sv.size() == 2);\n        auto loop = any_cast<Loop>(sv[1]);\n        switch (loop.type) {\n        case Loop::Type::opt: return opt(ope);\n        case Loop::Type::zom: return zom(ope);\n        case Loop::Type::oom: return oom(ope);\n        default: // Regex-like repetition\n          return rep(ope, loop.range.first, loop.range.second);\n        }\n      }\n    };\n\n    g[\"Loop\"] = [&](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: // Option\n        return Loop{Loop::Type::opt, std::pair<size_t, size_t>()};\n      case 1: // Zero or More\n        return Loop{Loop::Type::zom, std::pair<size_t, size_t>()};\n      case 2: // One or More\n        return Loop{Loop::Type::oom, std::pair<size_t, size_t>()};\n      default: // Regex-like repetition\n        return Loop{Loop::Type::rep,\n                    any_cast<std::pair<size_t, size_t>>(sv[0])};\n      }\n    };\n\n    g[\"RepetitionRange\"] = [&](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: { // Number COMMA Number\n        auto min = any_cast<size_t>(sv[0]);\n        auto max = any_cast<size_t>(sv[1]);\n        return std::make_pair(min, max);\n      }\n      case 1: // Number COMMA\n        return std::make_pair(any_cast<size_t>(sv[0]),\n                              std::numeric_limits<size_t>::max());\n      case 2: { // Number\n        auto n = any_cast<size_t>(sv[0]);\n        return std::make_pair(n, n);\n      }\n      default: // COMMA Number\n        return std::make_pair(std::numeric_limits<size_t>::min(),\n                              any_cast<size_t>(sv[0]));\n      }\n    };\n    g[\"Number\"] = [&](const SemanticValues &sv) {\n      std::stringstream ss(sv.str());\n      size_t n;\n      ss >> n;\n      return n;\n    };\n\n    g[\"Primary\"] = [&](const SemanticValues &sv, any &dt) {\n      Data &data = *any_cast<Data *>(dt);\n\n      switch (sv.choice()) {\n      case 0:   // Macro Reference\n      case 1: { // Reference\n        auto is_macro = sv.choice() == 0;\n        auto ignore = any_cast<bool>(sv[0]);\n        const auto &ident = any_cast<std::string>(sv[1]);\n\n        std::vector<std::shared_ptr<Ope>> args;\n        if (is_macro) {\n          args = any_cast<std::vector<std::shared_ptr<Ope>>>(sv[2]);\n        }\n\n        std::shared_ptr<Ope> ope =\n            ref(*data.grammar, ident, sv.c_str(), is_macro, args);\n\n        if (ignore) {\n          return ign(ope);\n        } else {\n          return ope;\n        }\n      }\n      case 2: { // (Expression)\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      }\n      case 3: { // TokenBoundary\n        return tok(any_cast<std::shared_ptr<Ope>>(sv[0]));\n      }\n      case 4: { // CaptureScope\n        return csc(any_cast<std::shared_ptr<Ope>>(sv[0]));\n      }\n      case 5: { // Capture\n        const auto &name = any_cast<std::string>(sv[0]);\n        auto ope = any_cast<std::shared_ptr<Ope>>(sv[1]);\n        return cap(ope, [name](const char *a_s, size_t a_n, Context &c) {\n          auto &cs = c.capture_scope_stack[c.capture_scope_stack_size - 1];\n          cs[name] = std::string(a_s, a_n);\n        });\n      }\n      default: {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      }\n      }\n    };\n\n    g[\"IdentCont\"] = [](const SemanticValues &sv) {\n      return std::string(sv.c_str(), sv.length());\n    };\n\n    g[\"Dictionary\"] = [](const SemanticValues &sv) {\n      auto items = sv.transform<std::string>();\n      return dic(items);\n    };\n\n    g[\"Literal\"] = [](const SemanticValues &sv) {\n      const auto &tok = sv.tokens.front();\n      return lit(resolve_escape_sequence(tok.first, tok.second));\n    };\n    g[\"LiteralI\"] = [](const SemanticValues &sv) {\n      const auto &tok = sv.tokens.front();\n      return liti(resolve_escape_sequence(tok.first, tok.second));\n    };\n    g[\"LiteralD\"] = [](const SemanticValues &sv) {\n      auto &tok = sv.tokens.front();\n      return resolve_escape_sequence(tok.first, tok.second);\n    };\n\n    g[\"Class\"] = [](const SemanticValues &sv) {\n      auto ranges = sv.transform<std::pair<char32_t, char32_t>>();\n      return cls(ranges);\n    };\n    g[\"NegatedClass\"] = [](const SemanticValues &sv) {\n      auto ranges = sv.transform<std::pair<char32_t, char32_t>>();\n      return ncls(ranges);\n    };\n    g[\"Range\"] = [](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: {\n        auto s1 = any_cast<std::string>(sv[0]);\n        auto s2 = any_cast<std::string>(sv[1]);\n        auto cp1 = decode_codepoint(s1.c_str(), s1.length());\n        auto cp2 = decode_codepoint(s2.c_str(), s2.length());\n        return std::make_pair(cp1, cp2);\n      }\n      case 1: {\n        auto s = any_cast<std::string>(sv[0]);\n        auto cp = decode_codepoint(s.c_str(), s.length());\n        return std::make_pair(cp, cp);\n      }\n      }\n      return std::make_pair<char32_t, char32_t>(0, 0);\n    };\n    g[\"Char\"] = [](const SemanticValues &sv) {\n      return resolve_escape_sequence(sv.c_str(), sv.length());\n    };\n\n    g[\"AND\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"NOT\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"QUESTION\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"STAR\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"PLUS\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n\n    g[\"DOT\"] = [](const SemanticValues & /*sv*/) { return dot(); };\n\n    g[\"BeginCap\"] = [](const SemanticValues &sv) { return sv.token(); };\n\n    g[\"BackRef\"] = [&](const SemanticValues &sv) { return bkr(sv.token()); };\n\n    g[\"Ignore\"] = [](const SemanticValues &sv) { return sv.size() > 0; };\n\n    g[\"Parameters\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::string>();\n    };\n\n    g[\"Arguments\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::shared_ptr<Ope>>();\n    };\n\n    g[\"PrecedenceClimbing\"] = [](const SemanticValues &sv) {\n      PrecedenceClimbing::BinOpeInfo binOpeInfo;\n      size_t level = 1;\n      for (auto v : sv) {\n        auto tokens = any_cast<std::vector<std::string>>(v);\n        auto assoc = tokens[0][0];\n        for (size_t i = 1; i < tokens.size(); i++) {\n          const auto &tok = tokens[i];\n          binOpeInfo[tok] = std::make_pair(level, assoc);\n        }\n        level++;\n      }\n      Instruction instruction;\n      instruction.type = \"precedence\";\n      instruction.data = binOpeInfo;\n      return instruction;\n    };\n    g[\"PrecedenceInfo\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::string>();\n    };\n    g[\"PrecedenceOpe\"] = [](const SemanticValues &sv) { return sv.token(); };\n    g[\"PrecedenceAssoc\"] = [](const SemanticValues &sv) { return sv.token(); };\n  }\n\n  bool apply_precedence_instruction(Definition &rule,\n                                    const PrecedenceClimbing::BinOpeInfo &info,\n                                    const char *s, Log log) {\n    try {\n      auto &seq = dynamic_cast<Sequence &>(*rule.get_core_operator());\n      auto atom = seq.opes_[0];\n      auto &rep = dynamic_cast<Repetition &>(*seq.opes_[1]);\n      auto &seq1 = dynamic_cast<Sequence &>(*rep.ope_);\n      auto binop = seq1.opes_[0];\n      auto atom1 = seq1.opes_[1];\n\n      auto atom_name = dynamic_cast<Reference &>(*atom).name_;\n      auto binop_name = dynamic_cast<Reference &>(*binop).name_;\n      auto atom1_name = dynamic_cast<Reference &>(*atom1).name_;\n\n      if (!rep.is_zom() || atom_name != atom1_name || atom_name == binop_name) {\n        if (log) {\n          auto line = line_info(s, rule.s_);\n          log(line.first, line.second,\n              \"'precedence' instruction cannt be applied to '\" + rule.name +\n                  \"'.\");\n        }\n        return false;\n      }\n\n      rule.holder_->ope_ = pre(atom, binop, info, rule);\n      rule.disable_action = true;\n    } catch (...) {\n      if (log) {\n        auto line = line_info(s, rule.s_);\n        log(line.first, line.second,\n            \"'precedence' instruction cannt be applied to '\" + rule.name +\n                \"'.\");\n      }\n      return false;\n    }\n    return true;\n  }\n\n  std::shared_ptr<Grammar> perform_core(const char *s, size_t n,\n                                        const Rules &rules, std::string &start,\n                                        Log log) {\n    Data data;\n    any dt = &data;\n    auto r = g[\"Grammar\"].parse(s, n, dt);\n\n    if (!r.ret) {\n      if (log) {\n        if (r.message_pos) {\n          auto line = line_info(s, r.message_pos);\n          log(line.first, line.second, r.message);\n        } else {\n          auto line = line_info(s, r.error_pos);\n          log(line.first, line.second, \"syntax error\");\n        }\n      }\n      return nullptr;\n    }\n\n    auto &grammar = *data.grammar;\n\n    // User provided rules\n    for (const auto &x : rules) {\n      auto name = x.first;\n      bool ignore = false;\n      if (!name.empty() && name[0] == '~') {\n        ignore = true;\n        name.erase(0, 1);\n      }\n      if (!name.empty()) {\n        auto &rule = grammar[name];\n        rule <= x.second;\n        rule.name = name;\n        rule.ignoreSemanticValue = ignore;\n      }\n    }\n\n    // Check duplicated definitions\n    bool ret = data.duplicates.empty();\n\n    for (const auto &x : data.duplicates) {\n      if (log) {\n        const auto &name = x.first;\n        auto ptr = x.second;\n        auto line = line_info(s, ptr);\n        log(line.first, line.second, \"'\" + name + \"' is already defined.\");\n      }\n    }\n\n    // Check if the start rule has ignore operator\n    {\n      auto &rule = grammar[data.start];\n      if (rule.ignoreSemanticValue) {\n        if (log) {\n          auto line = line_info(s, rule.s_);\n          log(line.first, line.second,\n              \"Ignore operator cannot be applied to '\" + rule.name + \"'.\");\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Check missing definitions\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n\n      ReferenceChecker vis(*data.grammar, rule.params);\n      rule.accept(vis);\n      for (const auto &y : vis.error_s) {\n        const auto &name = y.first;\n        const auto ptr = y.second;\n        if (log) {\n          auto line = line_info(s, ptr);\n          log(line.first, line.second, vis.error_message[name]);\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Link references\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n      LinkReferences vis(*data.grammar, rule.params);\n      rule.accept(vis);\n    }\n\n    // Check left recursion\n    ret = true;\n\n    for (auto &x : grammar) {\n      const auto &name = x.first;\n      auto &rule = x.second;\n\n      DetectLeftRecursion vis(name);\n      rule.accept(vis);\n      if (vis.error_s) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second, \"'\" + name + \"' is left recursive.\");\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Set root definition\n    auto &start_rule = (*data.grammar)[data.start];\n\n    // Check infinite loop\n    {\n      DetectInfiniteLoop vis(data.start_pos, data.start);\n      start_rule.accept(vis);\n      if (vis.has_error) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second,\n              \"infinite loop is detected in '\" + vis.error_name + \"'.\");\n        }\n        return nullptr;\n      }\n    }\n\n    // Automatic whitespace skipping\n    if (grammar.count(WHITESPACE_DEFINITION_NAME)) {\n      for (auto &x : grammar) {\n        auto &rule = x.second;\n        auto ope = rule.get_core_operator();\n        if (IsLiteralToken::check(*ope)) { rule <= tok(ope); }\n      }\n\n      start_rule.whitespaceOpe =\n          wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator());\n    }\n\n    // Word expression\n    if (grammar.count(WORD_DEFINITION_NAME)) {\n      start_rule.wordOpe =\n          (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator();\n    }\n\n    // Apply instructions\n    for (const auto &item : data.instructions) {\n      const auto &name = item.first;\n      const auto &instruction = item.second;\n      auto &rule = grammar[name];\n\n      if (instruction.type == \"precedence\") {\n        const auto &info =\n            any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data);\n\n        if (!apply_precedence_instruction(rule, info, s, log)) {\n          return nullptr;\n        }\n      }\n    }\n\n    // Set root definition\n    start = data.start;\n\n    return data.grammar;\n  }\n\n  Grammar g;\n};\n\n/*-----------------------------------------------------------------------------\n *  AST\n *---------------------------------------------------------------------------*/\n\ntemplate <typename Annotation> struct AstBase : public Annotation {\n  AstBase(const char *a_path, size_t a_line, size_t a_column,\n          const char *a_name,\n          const std::vector<std::shared_ptr<AstBase>> &a_nodes,\n          size_t a_position = 0, size_t a_length = 0, size_t a_choice_count = 0,\n          size_t a_choice = 0)\n      : path(a_path ? a_path : \"\"), line(a_line), column(a_column),\n        name(a_name), position(a_position), length(a_length),\n        choice_count(a_choice_count), choice(a_choice), original_name(a_name),\n        original_choice_count(a_choice_count), original_choice(a_choice),\n        tag(str2tag(a_name)), original_tag(tag), is_token(false),\n        nodes(a_nodes) {}\n\n  AstBase(const char *a_path, size_t a_line, size_t a_column,\n          const char *a_name, const std::string &a_token, size_t a_position = 0,\n          size_t a_length = 0, size_t a_choice_count = 0, size_t a_choice = 0)\n      : path(a_path ? a_path : \"\"), line(a_line), column(a_column),\n        name(a_name), position(a_position), length(a_length),\n        choice_count(a_choice_count), choice(a_choice), original_name(a_name),\n        original_choice_count(a_choice_count), original_choice(a_choice),\n        tag(str2tag(a_name)), original_tag(tag), is_token(true),\n        token(a_token) {}\n\n  AstBase(const AstBase &ast, const char *a_original_name,\n          size_t a_position = 0, size_t a_length = 0,\n          size_t a_original_choice_count = 0, size_t a_original_choise = 0)\n      : path(ast.path), line(ast.line), column(ast.column), name(ast.name),\n        position(a_position), length(a_length), choice_count(ast.choice_count),\n        choice(ast.choice), original_name(a_original_name),\n        original_choice_count(a_original_choice_count),\n        original_choice(a_original_choise), tag(ast.tag),\n        original_tag(str2tag(a_original_name)), is_token(ast.is_token),\n        token(ast.token), nodes(ast.nodes), parent(ast.parent) {}\n\n  const std::string path;\n  const size_t line = 1;\n  const size_t column = 1;\n\n  const std::string name;\n  size_t position;\n  size_t length;\n  const size_t choice_count;\n  const size_t choice;\n  const std::string original_name;\n  const size_t original_choice_count;\n  const size_t original_choice;\n  const unsigned int tag;\n  const unsigned int original_tag;\n\n  const bool is_token;\n  const std::string token;\n\n  std::vector<std::shared_ptr<AstBase<Annotation>>> nodes;\n  std::weak_ptr<AstBase<Annotation>> parent;\n};\n\ntemplate <typename T>\nvoid ast_to_s_core(const std::shared_ptr<T> &ptr, std::string &s, int level,\n                   std::function<std::string(const T &ast, int level)> fn) {\n  const auto &ast = *ptr;\n  for (auto i = 0; i < level; i++) {\n    s += \"  \";\n  }\n  auto name = ast.original_name;\n  if (ast.original_choice_count > 0) {\n    name += \"/\" + std::to_string(ast.original_choice);\n  }\n  if (ast.name != ast.original_name) { name += \"[\" + ast.name + \"]\"; }\n  if (ast.is_token) {\n    s += \"- \" + name + \" (\" + ast.token + \")\\n\";\n  } else {\n    s += \"+ \" + name + \"\\n\";\n  }\n  if (fn) { s += fn(ast, level + 1); }\n  for (auto node : ast.nodes) {\n    ast_to_s_core(node, s, level + 1, fn);\n  }\n}\n\ntemplate <typename T>\nstd::string\nast_to_s(const std::shared_ptr<T> &ptr,\n         std::function<std::string(const T &ast, int level)> fn = nullptr) {\n  std::string s;\n  ast_to_s_core(ptr, s, 0, fn);\n  return s;\n}\n\nstruct AstOptimizer {\n  AstOptimizer(bool mode, const std::vector<std::string> &rules = {})\n      : mode_(mode), rules_(rules) {}\n\n  template <typename T>\n  std::shared_ptr<T> optimize(std::shared_ptr<T> original,\n                              std::shared_ptr<T> parent = nullptr) {\n    auto found =\n        std::find(rules_.begin(), rules_.end(), original->name) != rules_.end();\n    bool opt = mode_ ? !found : found;\n\n    if (opt && original->nodes.size() == 1) {\n      auto child = optimize(original->nodes[0], parent);\n      return std::make_shared<T>(*child, original->name.c_str(),\n                                 original->choice_count, original->position,\n                                 original->length, original->choice);\n    }\n\n    auto ast = std::make_shared<T>(*original);\n    ast->parent = parent;\n    ast->nodes.clear();\n    for (auto node : original->nodes) {\n      auto child = optimize(node, ast);\n      ast->nodes.push_back(child);\n    }\n    return ast;\n  }\n\nprivate:\n  const bool mode_;\n  const std::vector<std::string> rules_;\n};\n\nstruct EmptyType {};\ntypedef AstBase<EmptyType> Ast;\n\ntemplate <typename T = Ast> void add_ast_action(Definition &rule) {\n  rule.action = [&](const SemanticValues &sv) {\n    auto line = sv.line_info();\n\n    if (rule.is_token()) {\n      return std::make_shared<T>(sv.path, line.first, line.second,\n                                 rule.name.c_str(), sv.token(),\n                                 std::distance(sv.ss, sv.c_str()), sv.length(),\n                                 sv.choice_count(), sv.choice());\n    }\n\n    auto ast = std::make_shared<T>(\n        sv.path, line.first, line.second, rule.name.c_str(),\n        sv.transform<std::shared_ptr<T>>(), std::distance(sv.ss, sv.c_str()),\n        sv.length(), sv.choice_count(), sv.choice());\n\n    for (auto node : ast->nodes) {\n      node->parent = ast;\n    }\n    return ast;\n  };\n}\n\n#define PEG_EXPAND(...) __VA_ARGS__\n#define PEG_CONCAT(a, b) a##b\n#define PEG_CONCAT2(a, b) PEG_CONCAT(a, b)\n\n#define PEG_PICK(                                                              \\\n    a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, \\\n    a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, \\\n    a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, \\\n    a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, \\\n    a62, a63, a64, a65, a66, a67, a68, a69, a70, a71, a72, a73, a74, a75, a76, \\\n    a77, a78, a79, a80, a81, a82, a83, a84, a85, a86, a87, a88, a89, a90, a91, \\\n    a92, a93, a94, a95, a96, a97, a98, a99, a100, ...)                         \\\n  a100\n\n#define PEG_COUNT(...)                                                         \\\n  PEG_EXPAND(PEG_PICK(                                                         \\\n      __VA_ARGS__, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87,    \\\n      86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69,  \\\n      68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51,  \\\n      50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33,  \\\n      32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15,  \\\n      14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0))\n\n#define PEG_DEF_1(r)                                                           \\\n  peg::Definition r;                                                           \\\n  r.name = #r;                                                                 \\\n  peg::add_ast_action(r);\n\n#define PEG_DEF_2(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_1(__VA_ARGS__))\n#define PEG_DEF_3(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_2(__VA_ARGS__))\n#define PEG_DEF_4(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_3(__VA_ARGS__))\n#define PEG_DEF_5(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_4(__VA_ARGS__))\n#define PEG_DEF_6(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_5(__VA_ARGS__))\n#define PEG_DEF_7(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_6(__VA_ARGS__))\n#define PEG_DEF_8(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_7(__VA_ARGS__))\n#define PEG_DEF_9(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_8(__VA_ARGS__))\n#define PEG_DEF_10(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_9(__VA_ARGS__))\n#define PEG_DEF_11(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_10(__VA_ARGS__))\n#define PEG_DEF_12(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_11(__VA_ARGS__))\n#define PEG_DEF_13(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_12(__VA_ARGS__))\n#define PEG_DEF_14(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_13(__VA_ARGS__))\n#define PEG_DEF_15(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_14(__VA_ARGS__))\n#define PEG_DEF_16(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_15(__VA_ARGS__))\n#define PEG_DEF_17(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_16(__VA_ARGS__))\n#define PEG_DEF_18(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_17(__VA_ARGS__))\n#define PEG_DEF_19(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_18(__VA_ARGS__))\n#define PEG_DEF_20(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_19(__VA_ARGS__))\n#define PEG_DEF_21(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_20(__VA_ARGS__))\n#define PEG_DEF_22(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_21(__VA_ARGS__))\n#define PEG_DEF_23(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_22(__VA_ARGS__))\n#define PEG_DEF_24(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_23(__VA_ARGS__))\n#define PEG_DEF_25(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_24(__VA_ARGS__))\n#define PEG_DEF_26(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_25(__VA_ARGS__))\n#define PEG_DEF_27(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_26(__VA_ARGS__))\n#define PEG_DEF_28(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_27(__VA_ARGS__))\n#define PEG_DEF_29(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_28(__VA_ARGS__))\n#define PEG_DEF_30(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_29(__VA_ARGS__))\n#define PEG_DEF_31(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_30(__VA_ARGS__))\n#define PEG_DEF_32(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_31(__VA_ARGS__))\n#define PEG_DEF_33(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_32(__VA_ARGS__))\n#define PEG_DEF_34(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_33(__VA_ARGS__))\n#define PEG_DEF_35(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_34(__VA_ARGS__))\n#define PEG_DEF_36(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_35(__VA_ARGS__))\n#define PEG_DEF_37(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_36(__VA_ARGS__))\n#define PEG_DEF_38(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_37(__VA_ARGS__))\n#define PEG_DEF_39(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_38(__VA_ARGS__))\n#define PEG_DEF_40(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_39(__VA_ARGS__))\n#define PEG_DEF_41(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_40(__VA_ARGS__))\n#define PEG_DEF_42(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_41(__VA_ARGS__))\n#define PEG_DEF_43(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_42(__VA_ARGS__))\n#define PEG_DEF_44(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_43(__VA_ARGS__))\n#define PEG_DEF_45(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_44(__VA_ARGS__))\n#define PEG_DEF_46(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_45(__VA_ARGS__))\n#define PEG_DEF_47(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_46(__VA_ARGS__))\n#define PEG_DEF_48(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_47(__VA_ARGS__))\n#define PEG_DEF_49(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_48(__VA_ARGS__))\n#define PEG_DEF_50(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_49(__VA_ARGS__))\n#define PEG_DEF_51(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_50(__VA_ARGS__))\n#define PEG_DEF_52(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_51(__VA_ARGS__))\n#define PEG_DEF_53(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_52(__VA_ARGS__))\n#define PEG_DEF_54(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_53(__VA_ARGS__))\n#define PEG_DEF_55(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_54(__VA_ARGS__))\n#define PEG_DEF_56(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_55(__VA_ARGS__))\n#define PEG_DEF_57(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_56(__VA_ARGS__))\n#define PEG_DEF_58(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_57(__VA_ARGS__))\n#define PEG_DEF_59(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_58(__VA_ARGS__))\n#define PEG_DEF_60(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_59(__VA_ARGS__))\n#define PEG_DEF_61(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_60(__VA_ARGS__))\n#define PEG_DEF_62(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_61(__VA_ARGS__))\n#define PEG_DEF_63(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_62(__VA_ARGS__))\n#define PEG_DEF_64(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_63(__VA_ARGS__))\n#define PEG_DEF_65(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_64(__VA_ARGS__))\n#define PEG_DEF_66(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_65(__VA_ARGS__))\n#define PEG_DEF_67(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_66(__VA_ARGS__))\n#define PEG_DEF_68(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_67(__VA_ARGS__))\n#define PEG_DEF_69(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_68(__VA_ARGS__))\n#define PEG_DEF_70(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_69(__VA_ARGS__))\n#define PEG_DEF_71(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_70(__VA_ARGS__))\n#define PEG_DEF_72(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_71(__VA_ARGS__))\n#define PEG_DEF_73(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_72(__VA_ARGS__))\n#define PEG_DEF_74(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_73(__VA_ARGS__))\n#define PEG_DEF_75(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_74(__VA_ARGS__))\n#define PEG_DEF_76(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_75(__VA_ARGS__))\n#define PEG_DEF_77(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_76(__VA_ARGS__))\n#define PEG_DEF_78(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_77(__VA_ARGS__))\n#define PEG_DEF_79(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_78(__VA_ARGS__))\n#define PEG_DEF_80(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_79(__VA_ARGS__))\n#define PEG_DEF_81(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_80(__VA_ARGS__))\n#define PEG_DEF_82(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_81(__VA_ARGS__))\n#define PEG_DEF_83(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_82(__VA_ARGS__))\n#define PEG_DEF_84(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_83(__VA_ARGS__))\n#define PEG_DEF_85(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_84(__VA_ARGS__))\n#define PEG_DEF_86(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_85(__VA_ARGS__))\n#define PEG_DEF_87(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_86(__VA_ARGS__))\n#define PEG_DEF_88(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_87(__VA_ARGS__))\n#define PEG_DEF_89(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_88(__VA_ARGS__))\n#define PEG_DEF_90(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_89(__VA_ARGS__))\n#define PEG_DEF_91(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_90(__VA_ARGS__))\n#define PEG_DEF_92(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_91(__VA_ARGS__))\n#define PEG_DEF_93(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_92(__VA_ARGS__))\n#define PEG_DEF_94(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_93(__VA_ARGS__))\n#define PEG_DEF_95(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_94(__VA_ARGS__))\n#define PEG_DEF_96(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_95(__VA_ARGS__))\n#define PEG_DEF_97(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_96(__VA_ARGS__))\n#define PEG_DEF_98(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_97(__VA_ARGS__))\n#define PEG_DEF_99(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_98(__VA_ARGS__))\n#define PEG_DEF_100(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_99(__VA_ARGS__))\n\n#define AST_DEFINITIONS(...)                                                   \\\n  PEG_EXPAND(PEG_CONCAT2(PEG_DEF_, PEG_COUNT(__VA_ARGS__))(__VA_ARGS__))\n\n/*-----------------------------------------------------------------------------\n *  parser\n *---------------------------------------------------------------------------*/\n\nclass parser {\npublic:\n  parser() = default;\n\n  parser(const char *s, size_t n, const Rules &rules) {\n    load_grammar(s, n, rules);\n  }\n\n  parser(const char *s, const Rules &rules) : parser(s, strlen(s), rules) {}\n\n  parser(const char *s, size_t n) : parser(s, n, Rules()) {}\n\n  parser(const char *s) : parser(s, strlen(s), Rules()) {}\n\n  operator bool() { return grammar_ != nullptr; }\n\n  bool load_grammar(const char *s, size_t n, const Rules &rules) {\n    grammar_ = ParserGenerator::parse(s, n, rules, start_, log);\n    return grammar_ != nullptr;\n  }\n\n  bool load_grammar(const char *s, size_t n) {\n    return load_grammar(s, n, Rules());\n  }\n\n  bool load_grammar(const char *s, const Rules &rules) {\n    auto n = strlen(s);\n    return load_grammar(s, n, rules);\n  }\n\n  bool load_grammar(const char *s) {\n    auto n = strlen(s);\n    return load_grammar(s, n);\n  }\n\n  bool parse_n(const char *s, size_t n, const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse(s, n, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  bool parse(const char *s, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, path);\n  }\n\n  bool parse_n(const char *s, size_t n, any &dt,\n               const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse(s, n, dt, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  bool parse(const char *s, any &dt, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, dt, path);\n  }\n\n  template <typename T>\n  bool parse_n(const char *s, size_t n, T &val,\n               const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse_and_get_value(s, n, val, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  template <typename T>\n  bool parse(const char *s, T &val, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, val, path);\n  }\n\n  template <typename T>\n  bool parse_n(const char *s, size_t n, any &dt, T &val,\n               const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse_and_get_value(s, n, dt, val, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  template <typename T>\n  bool parse(const char *s, any &dt, T &val,\n             const char * /*path*/ = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, dt, val);\n  }\n\n  Definition &operator[](const char *s) { return (*grammar_)[s]; }\n\n  const Definition &operator[](const char *s) const { return (*grammar_)[s]; }\n\n  std::vector<std::string> get_rule_names() {\n    std::vector<std::string> rules;\n    rules.reserve(grammar_->size());\n    for (auto const &r : *grammar_) {\n      rules.emplace_back(r.first);\n    }\n    return rules;\n  }\n\n  void enable_packrat_parsing() {\n    if (grammar_ != nullptr) {\n      auto &rule = (*grammar_)[start_];\n      rule.enablePackratParsing = true;\n    }\n  }\n\n  template <typename T = Ast> parser &enable_ast() {\n    for (auto &x : *grammar_) {\n      auto &rule = x.second;\n      if (!rule.action) { add_ast_action<T>(rule); }\n    }\n    return *this;\n  }\n\n  void enable_trace(TracerEnter tracer_enter, TracerLeave tracer_leave) {\n    if (grammar_ != nullptr) {\n      auto &rule = (*grammar_)[start_];\n      rule.tracer_enter = tracer_enter;\n      rule.tracer_leave = tracer_leave;\n    }\n  }\n\n  Log log;\n\nprivate:\n  void output_log(const char *s, size_t n, const Definition::Result &r) const {\n    if (log) {\n      if (!r.ret) {\n        if (r.message_pos) {\n          auto line = line_info(s, r.message_pos);\n          log(line.first, line.second, r.message);\n        } else {\n          auto line = line_info(s, r.error_pos);\n          log(line.first, line.second, \"syntax error\");\n        }\n      } else if (r.len != n) {\n        auto line = line_info(s, s + r.len);\n        log(line.first, line.second, \"syntax error\");\n      }\n    }\n  }\n\n  std::shared_ptr<Grammar> grammar_;\n  std::string start_;\n};\n\n} // namespace peg\n\n#endif\n\n// vim: et ts=2 sw=2 cin cino={1s ff=unix\n", "\ufeff#include \"catch.hh\"\n#include <peglib.h>\n\nusing namespace peg;\n\n#if !defined(PEGLIB_NO_UNICODE_CHARS)\nTEST_CASE(\"Simple syntax test (with unicode)\", \"[general]\")\n{\n    parser parser(\n        u8\" ROOT \u2190 _ \"\n        \" _ <- ' ' \"\n    );\n\n    bool ret = parser;\n    REQUIRE(ret == true);\n}\n#endif\n\nTEST_CASE(\"Simple syntax test\", \"[general]\")\n{\n    parser parser(R\"(\n        ROOT <- _\n        _ <- ' '\n    )\");\n\n    bool ret = parser;\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"Empty syntax test\", \"[general]\")\n{\n    parser parser(\"\");\n    bool ret = parser;\n    REQUIRE(ret == false);\n}\n\nTEST_CASE(\"Start rule with ignore operator test\", \"[general]\")\n{\n    parser parser(R\"(\n        ~ROOT <- _\n        _ <- ' '\n    )\");\n\n    bool ret = parser;\n    REQUIRE(ret == false);\n}\n\nTEST_CASE(\"Backslash escape sequence test\", \"[general]\")\n{\n    parser parser(R\"(\n        ROOT <- _\n        _ <- '\\\\'\n    )\");\n\n    bool ret = parser;\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"Invalid escape sequence test\", \"[general]\")\n{\n    parser parser(R\"(\n        ROOT <- _\n        _ <- '\\'\n    )\");\n\n    bool ret = parser;\n    REQUIRE(ret == false);\n}\n\nTEST_CASE(\"Action taking non const Semantic Values parameter\", \"[general]\")\n{\n    parser parser(R\"(\n        ROOT <- TEXT\n        TEXT <- [a-zA-Z]+\n    )\");\n\n    parser[\"ROOT\"] = [&](SemanticValues& sv) {\n        auto s = any_cast<std::string>(sv[0]);\n        s[0] = 'H'; // mutate\n        return std::string(std::move(s)); // move\n    };\n\n    parser[\"TEXT\"] = [&](SemanticValues& sv) {\n        return sv.token();\n    };\n\n    std::string val;\n    auto ret = parser.parse(\"hello\", val);\n    REQUIRE(ret == true);\n    REQUIRE(val == \"Hello\");\n}\n\nTEST_CASE(\"String capture test\", \"[general]\")\n{\n    parser parser(R\"(\n        ROOT      <-  _ ('[' TAG_NAME ']' _)*\n        TAG_NAME  <-  (!']' .)+\n        _         <-  [ \\t]*\n    )\");\n\n    std::vector<std::string> tags;\n\n    parser[\"TAG_NAME\"] = [&](const SemanticValues& sv) {\n        tags.push_back(sv.str());\n    };\n\n    auto ret = parser.parse(\" [tag1] [tag:2] [tag-3] \");\n\n    REQUIRE(ret == true);\n    REQUIRE(tags.size() == 3);\n    REQUIRE(tags[0] == \"tag1\");\n    REQUIRE(tags[1] == \"tag:2\");\n    REQUIRE(tags[2] == \"tag-3\");\n}\n\nusing namespace peg;\n\nTEST_CASE(\"String capture test2\", \"[general]\")\n{\n    std::vector<std::string> tags;\n\n    Definition ROOT, TAG, TAG_NAME, WS;\n    ROOT     <= seq(WS, zom(TAG));\n    TAG      <= seq(chr('['), TAG_NAME, chr(']'), WS);\n    TAG_NAME <= oom(seq(npd(chr(']')), dot())), [&](const SemanticValues& sv) { tags.push_back(sv.str()); };\n    WS       <= zom(cls(\" \\t\"));\n\n    auto r = ROOT.parse(\" [tag1] [tag:2] [tag-3] \");\n\n    REQUIRE(r.ret == true);\n    REQUIRE(tags.size() == 3);\n    REQUIRE(tags[0] == \"tag1\");\n    REQUIRE(tags[1] == \"tag:2\");\n    REQUIRE(tags[2] == \"tag-3\");\n}\n\nTEST_CASE(\"String capture test3\", \"[general]\")\n{\n    parser pg(R\"(\n        ROOT  <- _ TOKEN*\n        TOKEN <- '[' < (!']' .)+ > ']' _\n        _     <- [ \\t\\r\\n]*\n    )\");\n\n\n    std::vector<std::string> tags;\n\n    pg[\"TOKEN\"] = [&](const SemanticValues& sv) {\n        tags.push_back(sv.token());\n    };\n\n    auto ret = pg.parse(\" [tag1] [tag:2] [tag-3] \");\n\n    REQUIRE(ret == true);\n    REQUIRE(tags.size() == 3);\n    REQUIRE(tags[0] == \"tag1\");\n    REQUIRE(tags[1] == \"tag:2\");\n    REQUIRE(tags[2] == \"tag-3\");\n}\n\nTEST_CASE(\"Cyclic grammer test\", \"[general]\")\n{\n    Definition PARENT;\n    Definition CHILD;\n\n    PARENT <= seq(CHILD);\n    CHILD  <= seq(PARENT);\n}\n\nTEST_CASE(\"Visit test\", \"[general]\")\n{\n    Definition ROOT, TAG, TAG_NAME, WS;\n\n    ROOT     <= seq(WS, zom(TAG));\n    TAG      <= seq(chr('['), TAG_NAME, chr(']'), WS);\n    TAG_NAME <= oom(seq(npd(chr(']')), dot()));\n    WS       <= zom(cls(\" \\t\"));\n\n    AssignIDToDefinition defIds;\n    ROOT.accept(defIds);\n\n    REQUIRE(defIds.ids.size() == 4);\n}\n\nTEST_CASE(\"Token check test\", \"[general]\")\n{\n    parser parser(R\"(\n        EXPRESSION       <-  _ TERM (TERM_OPERATOR TERM)*\n        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*\n        FACTOR           <-  NUMBER / '(' _ EXPRESSION ')' _\n        TERM_OPERATOR    <-  < [-+] > _\n        FACTOR_OPERATOR  <-  < [/*] > _\n        NUMBER           <-  < [0-9]+ > _\n        _                <-  [ \\t\\r\\n]*\n    )\");\n\n    REQUIRE(parser[\"EXPRESSION\"].is_token() == false);\n    REQUIRE(parser[\"FACTOR\"].is_token() == false);\n    REQUIRE(parser[\"FACTOR_OPERATOR\"].is_token() == true);\n    REQUIRE(parser[\"NUMBER\"].is_token() == true);\n    REQUIRE(parser[\"_\"].is_token() == true);\n}\n\nTEST_CASE(\"Lambda action test\", \"[general]\")\n{\n    parser parser(R\"(\n       START <- (CHAR)*\n       CHAR  <- .\n    )\");\n\n    std::string ss;\n    parser[\"CHAR\"] = [&](const SemanticValues& sv) {\n        ss += *sv.c_str();\n    };\n\n    bool ret = parser.parse(\"hello\");\n    REQUIRE(ret == true);\n    REQUIRE(ss == \"hello\");\n}\n\nTEST_CASE(\"enter/leave handlers test\", \"[general]\")\n{\n    parser parser(R\"(\n        START  <- LTOKEN '=' RTOKEN\n        LTOKEN <- TOKEN\n        RTOKEN <- TOKEN\n        TOKEN  <- [A-Za-z]+\n    )\");\n\n    parser[\"LTOKEN\"].enter = [&](const char*, size_t, any& dt) {\n        auto& require_upper_case = *any_cast<bool*>(dt);\n        require_upper_case = false;\n    };\n    parser[\"LTOKEN\"].leave = [&](const char*, size_t, size_t, any&, any& dt) {\n        auto& require_upper_case = *any_cast<bool*>(dt);\n        require_upper_case = true;\n    };\n\n    auto message = \"should be upper case string...\";\n\n    parser[\"TOKEN\"] = [&](const SemanticValues& sv, any& dt) {\n        auto& require_upper_case = *any_cast<bool*>(dt);\n        if (require_upper_case) {\n            const auto& s = sv.str();\n            if (!std::all_of(s.begin(), s.end(), ::isupper)) {\n                throw parse_error(message);\n            }\n        }\n    };\n\n    bool require_upper_case = false;\n    any dt = &require_upper_case;\n    REQUIRE(parser.parse(\"hello=world\", dt) == false);\n    REQUIRE(parser.parse(\"HELLO=world\", dt) == false);\n    REQUIRE(parser.parse(\"hello=WORLD\", dt) == true);\n    REQUIRE(parser.parse(\"HELLO=WORLD\", dt) == true);\n\n    parser.log = [&](size_t ln, size_t col, const std::string& msg) {\n        REQUIRE(ln == 1);\n        REQUIRE(col == 7);\n        REQUIRE(msg == message);\n    };\n    parser.parse(\"hello=world\", dt);\n}\n\nTEST_CASE(\"WHITESPACE test\", \"[general]\")\n{\n    parser parser(R\"(\n        # Rules\n        ROOT         <-  ITEM (',' ITEM)*\n        ITEM         <-  WORD / PHRASE\n\n        # Tokens\n        WORD         <-  < [a-zA-Z0-9_]+ >\n        PHRASE       <-  < '\"' (!'\"' .)* '\"' >\n\n        %whitespace  <-  [ \\t\\r\\n]*\n    )\");\n\n    auto ret = parser.parse(R\"(  one, \t \"two, three\",   four  )\");\n\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"WHITESPACE test2\", \"[general]\")\n{\n    parser parser(R\"(\n        # Rules\n        ROOT         <-  ITEM (',' ITEM)*\n        ITEM         <-  '[' < [a-zA-Z0-9_]+ > ']'\n\n        %whitespace  <-  (SPACE / TAB)*\n        SPACE        <-  ' '\n        TAB          <-  '\\t'\n    )\");\n\n    std::vector<std::string> items;\n    parser[\"ITEM\"] = [&](const SemanticValues& sv) {\n        items.push_back(sv.token());\n    };\n\n    auto ret = parser.parse(R\"([one], \t[two] ,[three] )\");\n\n    REQUIRE(ret == true);\n    REQUIRE(items.size() == 3);\n    REQUIRE(items[0] == \"one\");\n    REQUIRE(items[1] == \"two\");\n    REQUIRE(items[2] == \"three\");\n}\n\nTEST_CASE(\"WHITESPACE test3\", \"[general]\") {\n    parser parser(R\"(\n        StrQuot      <- < '\"' < (StrEscape / StrChars)* > '\"' >\n        StrEscape    <- '\\\\' any\n        StrChars     <- (!'\"' !'\\\\' any)+\n        any          <- .\n        %whitespace  <- [ \\t]*\n    )\");\n\n    parser[\"StrQuot\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == R\"(  aaa \\\" bbb  )\");\n    };\n\n    auto ret = parser.parse(R\"( \"  aaa \\\" bbb  \" )\");\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"WHITESPACE test4\", \"[general]\") {\n    parser parser(R\"(\n        ROOT         <-  HELLO OPE WORLD\n        HELLO        <-  'hello'\n        OPE          <-  < [-+] >\n        WORLD        <-  'world' / 'WORLD'\n        %whitespace  <-  [ \\t\\r\\n]*\n    )\");\n\n    parser[\"HELLO\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == \"hello\");\n    };\n\n    parser[\"OPE\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == \"+\");\n    };\n\n    parser[\"WORLD\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == \"world\");\n    };\n\n    auto ret = parser.parse(\"  hello + world  \");\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"Word expression test\", \"[general]\") {\n    parser parser(R\"(\n        ROOT         <-  'hello' ','? 'world'\n        %whitespace  <-  [ \\t\\r\\n]*\n        %word        <-  [a-z]+\n    )\");\n\n\tREQUIRE(parser.parse(\"helloworld\") == false);\n\tREQUIRE(parser.parse(\"hello world\") == true);\n\tREQUIRE(parser.parse(\"hello,world\") == true);\n\tREQUIRE(parser.parse(\"hello, world\") == true);\n\tREQUIRE(parser.parse(\"hello , world\") == true);\n}\n\nTEST_CASE(\"Skip token test\", \"[general]\")\n{\n    parser parser(\n        \"  ROOT  <-  _ ITEM (',' _ ITEM _)* \"\n        \"  ITEM  <-  ([a-z0-9])+  \"\n        \"  ~_    <-  [ \\t]*    \"\n    );\n\n    parser[\"ROOT\"] = [&](const SemanticValues& sv) {\n        REQUIRE(sv.size() == 2);\n    };\n\n    auto ret = parser.parse(\" item1, item2 \");\n\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"Skip token test2\", \"[general]\")\n{\n    parser parser(R\"(\n        ROOT        <-  ITEM (',' ITEM)*\n        ITEM        <-  < ([a-z0-9])+ >\n        %whitespace <-  [ \\t]*\n    )\");\n\n    parser[\"ROOT\"] = [&](const SemanticValues& sv) {\n        REQUIRE(sv.size() == 2);\n    };\n\n    auto ret = parser.parse(\" item1, item2 \");\n\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"Custom AST test\", \"[general]\")\n{\n\tstruct CustomType {};\n\tusing CustomAst = AstBase<CustomType>;\n\t\n    parser parser(R\"(\n        ROOT <- _ TEXT*\n        TEXT <- [a-zA-Z]+ _\n        _ <- [ \\t\\r\\n]*\n    )\");\n\n    parser.enable_ast<CustomAst>();\n    std::shared_ptr<CustomAst> ast;\n    bool ret = parser.parse(\"a b c\", ast);\n    REQUIRE(ret == true);\n    REQUIRE(ast->nodes.size() == 4);\n}\n\nTEST_CASE(\"Backtracking test\", \"[general]\")\n{\n    parser parser(R\"(\n       START <- PAT1 / PAT2\n       PAT1  <- HELLO ' One'\n       PAT2  <- HELLO ' Two'\n       HELLO <- 'Hello'\n    )\");\n\n    size_t count = 0;\n    parser[\"HELLO\"] = [&](const SemanticValues& /*sv*/) {\n        count++;\n    };\n\n    parser.enable_packrat_parsing();\n\n    bool ret = parser.parse(\"Hello Two\");\n    REQUIRE(ret == true);\n    REQUIRE(count == 1); // Skip second time\n}\n\nTEST_CASE(\"Backtracking with AST\", \"[general]\")\n{\n    parser parser(R\"(\n        S <- A? B (A B)* A\n        A <- 'a'\n        B <- 'b'\n    )\");\n\n    parser.enable_ast();\n    std::shared_ptr<Ast> ast;\n    bool ret = parser.parse(\"ba\", ast);\n    REQUIRE(ret == true);\n    REQUIRE(ast->nodes.size() == 2);\n}\n\nTEST_CASE(\"Octal/Hex/Unicode value test\", \"[general]\")\n{\n    parser parser(\n        R\"( ROOT <- '\\132\\x7a\\u30f3' )\"\n    );\n\n    auto ret = parser.parse(\"Zz\u30f3\");\n\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"Ignore case test\", \"[general]\") {\n    parser parser(R\"(\n        ROOT         <-  HELLO WORLD\n        HELLO        <-  'hello'i\n        WORLD        <-  'world'i\n        %whitespace  <-  [ \\t\\r\\n]*\n    )\");\n\n    parser[\"HELLO\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == \"Hello\");\n    };\n\n    parser[\"WORLD\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == \"World\");\n    };\n\n    auto ret = parser.parse(\"  Hello World  \");\n    REQUIRE(ret == true);\n}\n\nTEST_CASE(\"mutable lambda test\", \"[general]\")\n{\n    std::vector<std::string> vec;\n\n    parser pg(\"ROOT <- 'mutable lambda test'\");\n\n    // This test makes sure if the following code can be compiled.\n    pg[\"TOKEN\"] = [=](const SemanticValues& sv) mutable {\n        vec.push_back(sv.str());\n    };\n}\n\nTEST_CASE(\"Simple calculator test\", \"[general]\")\n{\n    parser parser(R\"(\n        Additive  <- Multitive '+' Additive / Multitive\n        Multitive <- Primary '*' Multitive / Primary\n        Primary   <- '(' Additive ')' / Number\n        Number    <- [0-9]+\n    )\");\n\n    parser[\"Additive\"] = [](const SemanticValues& sv) {\n        switch (sv.choice()) {\n        case 0:\n            return any_cast<int>(sv[0]) + any_cast<int>(sv[1]);\n        default:\n            return any_cast<int>(sv[0]);\n        }\n    };\n\n    parser[\"Multitive\"] = [](const SemanticValues& sv) {\n        switch (sv.choice()) {\n        case 0:\n            return any_cast<int>(sv[0]) * any_cast<int>(sv[1]);\n        default:\n            return any_cast<int>(sv[0]);\n        }\n    };\n\n    parser[\"Number\"] = [](const SemanticValues& sv) {\n        return atoi(sv.c_str());\n    };\n\n    int val;\n    parser.parse(\"(1+2)*3\", val);\n\n    REQUIRE(val == 9);\n}\n\nTEST_CASE(\"Calculator test\", \"[general]\")\n{\n    // Construct grammer\n    Definition EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER;\n\n    EXPRESSION      <= seq(TERM, zom(seq(TERM_OPERATOR, TERM)));\n    TERM            <= seq(FACTOR, zom(seq(FACTOR_OPERATOR, FACTOR)));\n    FACTOR          <= cho(NUMBER, seq(chr('('), EXPRESSION, chr(')')));\n    TERM_OPERATOR   <= cls(\"+-\");\n    FACTOR_OPERATOR <= cls(\"*/\");\n    NUMBER          <= oom(cls(\"0-9\"));\n\n    // Setup actions\n    auto reduce = [](const SemanticValues& sv) -> long {\n        long ret = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            switch (any_cast<char>(sv[i])) {\n                case '+': ret += num; break;\n                case '-': ret -= num; break;\n                case '*': ret *= num; break;\n                case '/': ret /= num; break;\n            }\n        }\n        return ret;\n    };\n\n    EXPRESSION      = reduce;\n    TERM            = reduce;\n    TERM_OPERATOR   = [](const SemanticValues& sv) { return *sv.c_str(); };\n    FACTOR_OPERATOR = [](const SemanticValues& sv) { return *sv.c_str(); };\n    NUMBER          = [](const SemanticValues& sv) { return stol(sv.str(), nullptr, 10); };\n\n    // Parse\n    long val;\n    auto r = EXPRESSION.parse_and_get_value(\"1+2*3*(4-5+6)/7-8\", val);\n\n    REQUIRE(r.ret == true);\n    REQUIRE(val == -3);\n}\n\nTEST_CASE(\"Calculator test2\", \"[general]\")\n{\n    // Parse syntax\n    auto syntax = R\"(\n        # Grammar for Calculator...\n        EXPRESSION       <-  TERM (TERM_OPERATOR TERM)*\n        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*\n        FACTOR           <-  NUMBER / '(' EXPRESSION ')'\n        TERM_OPERATOR    <-  [-+]\n        FACTOR_OPERATOR  <-  [/*]\n        NUMBER           <-  [0-9]+\n    )\";\n\n    std::string start;\n    auto grammar = ParserGenerator::parse(syntax, strlen(syntax), start, nullptr);\n    auto& g = *grammar;\n\n    // Setup actions\n    auto reduce = [](const SemanticValues& sv) -> long {\n        long ret = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            switch (any_cast<char>(sv[i])) {\n                case '+': ret += num; break;\n                case '-': ret -= num; break;\n                case '*': ret *= num; break;\n                case '/': ret /= num; break;\n            }\n        }\n        return ret;\n    };\n\n    g[\"EXPRESSION\"]      = reduce;\n    g[\"TERM\"]            = reduce;\n    g[\"TERM_OPERATOR\"]   = [](const SemanticValues& sv) { return *sv.c_str(); };\n    g[\"FACTOR_OPERATOR\"] = [](const SemanticValues& sv) { return *sv.c_str(); };\n    g[\"NUMBER\"]          = [](const SemanticValues& sv) { return stol(sv.str(), nullptr, 10); };\n\n    // Parse\n    long val;\n    auto r = g[start].parse_and_get_value(\"1+2*3*(4-5+6)/7-8\", val);\n\n    REQUIRE(r.ret == true);\n    REQUIRE(val == -3);\n}\n\nTEST_CASE(\"Calculator test3\", \"[general]\")\n{\n    // Parse syntax\n    parser parser(R\"(\n        # Grammar for Calculator...\n        EXPRESSION       <-  TERM (TERM_OPERATOR TERM)*\n        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*\n        FACTOR           <-  NUMBER / '(' EXPRESSION ')'\n        TERM_OPERATOR    <-  [-+]\n        FACTOR_OPERATOR  <-  [/*]\n        NUMBER           <-  [0-9]+\n    )\");\n\n    auto reduce = [](const SemanticValues& sv) -> long {\n        long ret = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            switch (any_cast<char>(sv[i])) {\n                case '+': ret += num; break;\n                case '-': ret -= num; break;\n                case '*': ret *= num; break;\n                case '/': ret /= num; break;\n            }\n        }\n        return ret;\n    };\n\n    // Setup actions\n    parser[\"EXPRESSION\"]      = reduce;\n    parser[\"TERM\"]            = reduce;\n    parser[\"TERM_OPERATOR\"]   = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };\n    parser[\"FACTOR_OPERATOR\"] = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };\n    parser[\"NUMBER\"]          = [](const SemanticValues& sv) { return stol(sv.str(), nullptr, 10); };\n\n    // Parse\n    long val;\n    auto ret = parser.parse(\"1+2*3*(4-5+6)/7-8\", val);\n\n    REQUIRE(ret == true);\n    REQUIRE(val == -3);\n}\n\nTEST_CASE(\"Calculator test with AST\", \"[general]\")\n{\n    parser parser(R\"(\n        EXPRESSION       <-  _ TERM (TERM_OPERATOR TERM)*\n        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*\n        FACTOR           <-  NUMBER / '(' _ EXPRESSION ')' _\n        TERM_OPERATOR    <-  < [-+] > _\n        FACTOR_OPERATOR  <-  < [/*] > _\n        NUMBER           <-  < [0-9]+ > _\n        ~_               <-  [ \\t\\r\\n]*\n    )\");\n\n    parser.enable_ast();\n\n    std::function<long (const Ast&)> eval = [&](const Ast& ast) {\n        if (ast.name == \"NUMBER\") {\n            return stol(ast.token);\n        } else {\n            const auto& nodes = ast.nodes;\n            auto result = eval(*nodes[0]);\n            for (auto i = 1u; i < nodes.size(); i += 2) {\n                auto num = eval(*nodes[i + 1]);\n                auto ope = nodes[i]->token[0];\n                switch (ope) {\n                    case '+': result += num; break;\n                    case '-': result -= num; break;\n                    case '*': result *= num; break;\n                    case '/': result /= num; break;\n                }\n            }\n            return result;\n        }\n    };\n\n    std::shared_ptr<Ast> ast;\n    auto ret = parser.parse(\"1+2*3*(4-5+6)/7-8\", ast);\n    ast = AstOptimizer(true).optimize(ast);\n    auto val = eval(*ast);\n\n    REQUIRE(ret == true);\n    REQUIRE(val == -3);\n}\n\nTEST_CASE(\"Calculator test with combinators and AST\", \"[general]\") {\n  // Construct grammer\n  AST_DEFINITIONS(EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER);\n\n  EXPRESSION <= seq(TERM, zom(seq(TERM_OPERATOR, TERM)));\n  TERM <= seq(FACTOR, zom(seq(FACTOR_OPERATOR, FACTOR)));\n  FACTOR <= cho(NUMBER, seq(chr('('), EXPRESSION, chr(')')));\n  TERM_OPERATOR <= cls(\"+-\");\n  FACTOR_OPERATOR <= cls(\"*/\");\n  NUMBER <= oom(cls(\"0-9\"));\n\n  std::function<long(const Ast &)> eval = [&](const Ast &ast) {\n    if (ast.name == \"NUMBER\") {\n      return stol(ast.token);\n    } else {\n      const auto &nodes = ast.nodes;\n      auto result = eval(*nodes[0]);\n      for (auto i = 1u; i < nodes.size(); i += 2) {\n        auto num = eval(*nodes[i + 1]);\n        auto ope = nodes[i]->token[0];\n        switch (ope) {\n        case '+': result += num; break;\n        case '-': result -= num; break;\n        case '*': result *= num; break;\n        case '/': result /= num; break;\n        }\n      }\n      return result;\n    }\n  };\n\n  std::shared_ptr<Ast> ast;\n  auto r = EXPRESSION.parse_and_get_value(\"1+2*3*(4-5+6)/7-8\", ast);\n  ast = AstOptimizer(true).optimize(ast);\n  auto val = eval(*ast);\n\n  REQUIRE(r.ret == true);\n  REQUIRE(val == -3);\n}\n\nTEST_CASE(\"Ignore semantic value test\", \"[general]\")\n{\n    parser parser(R\"(\n       START <-  ~HELLO WORLD\n       HELLO <- 'Hello' _\n       WORLD <- 'World' _\n       _     <- [ \\t\\r\\n]*\n    )\");\n\n    parser.enable_ast();\n\n    std::shared_ptr<Ast> ast;\n    auto ret = parser.parse(\"Hello World\", ast);\n\n    REQUIRE(ret == true);\n    REQUIRE(ast->nodes.size() == 1);\n    REQUIRE(ast->nodes[0]->name == \"WORLD\");\n}\n\nTEST_CASE(\"Ignore semantic value of 'or' predicate test\", \"[general]\")\n{\n    parser parser(R\"(\n       START       <- _ !DUMMY HELLO_WORLD '.'\n       HELLO_WORLD <- HELLO 'World' _\n       HELLO       <- 'Hello' _\n       DUMMY       <- 'dummy' _\n       ~_          <- [ \\t\\r\\n]*\n   )\");\n\n    parser.enable_ast();\n\n    std::shared_ptr<Ast> ast;\n    auto ret = parser.parse(\"Hello World.\", ast);\n\n    REQUIRE(ret == true);\n    REQUIRE(ast->nodes.size() == 1);\n    REQUIRE(ast->nodes[0]->name == \"HELLO_WORLD\");\n}\n\nTEST_CASE(\"Ignore semantic value of 'and' predicate test\", \"[general]\")\n{\n    parser parser(R\"(\n       START       <- _ &HELLO HELLO_WORLD '.'\n       HELLO_WORLD <- HELLO 'World' _\n       HELLO       <- 'Hello' _\n       ~_          <- [ \\t\\r\\n]*\n    )\");\n\n    parser.enable_ast();\n\n    std::shared_ptr<Ast> ast;\n    auto ret = parser.parse(\"Hello World.\", ast);\n\n    REQUIRE(ret == true);\n    REQUIRE(ast->nodes.size() == 1);\n    REQUIRE(ast->nodes[0]->name == \"HELLO_WORLD\");\n}\n\nTEST_CASE(\"Literal token on AST test1\", \"[general]\")\n{\n    parser parser(R\"(\n        STRING_LITERAL  <- '\"' (('\\\\\"' / '\\\\t' / '\\\\n') / (![\"] .))* '\"'\n    )\");\n    parser.enable_ast();\n\n    std::shared_ptr<Ast> ast;\n    auto ret = parser.parse(R\"(\"a\\tb\")\", ast);\n\n    REQUIRE(ret == true);\n    REQUIRE(ast->is_token == true);\n    REQUIRE(ast->token == R\"(\"a\\tb\")\");\n    REQUIRE(ast->nodes.empty());\n}\n\nTEST_CASE(\"Literal token on AST test2\", \"[general]\")\n{\n    parser parser(R\"(\n        STRING_LITERAL  <-  '\"' (ESC / CHAR)* '\"'\n        ESC             <-  ('\\\\\"' / '\\\\t' / '\\\\n')\n        CHAR            <-  (![\"] .)\n    )\");\n    parser.enable_ast();\n\n    std::shared_ptr<Ast> ast;\n    auto ret = parser.parse(R\"(\"a\\tb\")\", ast);\n\n    REQUIRE(ret == true);\n    REQUIRE(ast->is_token == false);\n    REQUIRE(ast->token.empty());\n    REQUIRE(ast->nodes.size() == 3);\n}\n\nTEST_CASE(\"Literal token on AST test3\", \"[general]\")\n{\n    parser parser(R\"(\n        STRING_LITERAL  <-  < '\"' (ESC / CHAR)* '\"' >\n        ESC             <-  ('\\\\\"' / '\\\\t' / '\\\\n')\n        CHAR            <-  (![\"] .)\n    )\");\n    parser.enable_ast();\n\n    std::shared_ptr<Ast> ast;\n    auto ret = parser.parse(R\"(\"a\\tb\")\", ast);\n\n    REQUIRE(ret == true);\n    REQUIRE(ast->is_token == true);\n    REQUIRE(ast->token == R\"(\"a\\tb\")\");\n    REQUIRE(ast->nodes.empty());\n}\n\nTEST_CASE(\"Missing missing definitions test\", \"[general]\")\n{\n    parser parser(R\"(\n        A <- B C\n    )\");\n\n    REQUIRE(!parser);\n}\n\nTEST_CASE(\"Definition duplicates test\", \"[general]\")\n{\n    parser parser(R\"(\n        A <- ''\n        A <- ''\n    )\");\n\n    REQUIRE(!parser);\n}\n\nTEST_CASE(\"Semantic values test\", \"[general]\")\n{\n    parser parser(R\"(\n        term <- ( a b c x )? a b c\n        a <- 'a'\n        b <- 'b'\n        c <- 'c'\n        x <- 'x'\n    )\");\n\n\tfor (const auto& rule: parser.get_rule_names()){\n\t\tparser[rule.c_str()] = [rule](const SemanticValues& sv, any&) {\n            if (rule == \"term\") {\n                REQUIRE(any_cast<std::string>(sv[0]) == \"a at 0\");\n                REQUIRE(any_cast<std::string>(sv[1]) == \"b at 1\");\n                REQUIRE(any_cast<std::string>(sv[2]) == \"c at 2\");\n                return std::string();\n            } else {\n                return rule + \" at \" + std::to_string(sv.c_str() - sv.ss);\n            }\n\t\t};\n\t}\n\n\tREQUIRE(parser.parse(\"abc\"));\n}\n\nTEST_CASE(\"Ordered choice count\", \"[general]\")\n{\n    parser parser(R\"(\n        S <- 'a' / 'b'\n    )\");\n\n    parser[\"S\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.choice() == 1);\n        REQUIRE(sv.choice_count() == 2);\n    };\n\n    parser.parse(\"b\");\n}\n\nTEST_CASE(\"Ordered choice count 2\", \"[general]\")\n{\n    parser parser(R\"(\n        S <- ('a' / 'b')*\n    )\");\n\n    parser[\"S\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.choice() == 0);\n        REQUIRE(sv.choice_count() == 0);\n    };\n\n    parser.parse(\"b\");\n}\n\nTEST_CASE(\"Semantic value tag\", \"[general]\")\n{\n    parser parser(R\"(\n        S <- A? B* C?\n        A <- 'a'\n        B <- 'b'\n        C <- 'c'\n    )\");\n\n    {\n        using namespace udl;\n        parser[\"S\"] = [](const SemanticValues& sv) {\n            REQUIRE(sv.size() == 1);\n            REQUIRE(sv.tags.size() == 1);\n            REQUIRE(sv.tags[0] == \"C\"_);\n        };\n        auto ret = parser.parse(\"c\");\n        REQUIRE(ret == true);\n    }\n\n    {\n        using namespace udl;\n        parser[\"S\"] = [](const SemanticValues& sv) {\n            REQUIRE(sv.size() == 2);\n            REQUIRE(sv.tags.size() == 2);\n            REQUIRE(sv.tags[0] == \"B\"_);\n            REQUIRE(sv.tags[1] == \"B\"_);\n        };\n        auto ret = parser.parse(\"bb\");\n        REQUIRE(ret == true);\n    }\n\n    {\n        using namespace udl;\n        parser[\"S\"] = [](const SemanticValues& sv) {\n            REQUIRE(sv.size() == 2);\n            REQUIRE(sv.tags.size() == 2);\n            REQUIRE(sv.tags[0] == \"A\"_);\n            REQUIRE(sv.tags[1] == \"C\"_);\n        };\n        auto ret = parser.parse(\"ac\");\n        REQUIRE(ret == true);\n    }\n}\n\nTEST_CASE(\"Negated Class test\", \"[general]\")\n{\n    parser parser(R\"(\n        ROOT <- [^a-z_]+\n    )\");\n\n    bool ret = parser;\n    REQUIRE(ret == true);\n\n    REQUIRE(parser.parse(\"ABC123\"));\n    REQUIRE_FALSE(parser.parse(\"ABcZ\"));\n    REQUIRE_FALSE(parser.parse(\"ABCZ_\"));\n    REQUIRE_FALSE(parser.parse(\"\"));\n}\n\n// vim: et ts=4 sw=4 cin cino={1s ff=unix\n"], "filenames": ["peglib.h", "test/test1.cc"], "buggy_code_start_loc": [1242, 32], "buggy_code_end_loc": [3439, 32], "fixing_code_start_loc": [1242, 33], "fixing_code_end_loc": [3453, 44], "type": "CWE-476", "message": "An issue was discovered in cpp-peglib through v0.1.12. A NULL pointer dereference exists in the peg::AstOptimizer::optimize() located in peglib.h. It allows an attacker to cause Denial of Service.", "other": {"cve": {"id": "CVE-2020-23914", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-21T18:15:08.237", "lastModified": "2021-04-26T17:22:31.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in cpp-peglib through v0.1.12. A NULL pointer dereference exists in the peg::AstOptimizer::optimize() located in peglib.h. It allows an attacker to cause Denial of Service."}, {"lang": "es", "value": "Se detect\u00f3 un problema en cpp-peglib hasta la versi\u00f3n v0.1.12.&#xa0;Se presenta una desreferencia del puntero NULL en la funci\u00f3n peg::AstOptimizer::optimizar() ubicado en el archivo peglib.h.&#xa0;Permite a un atacante causar una Denegaci\u00f3n de Servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cpp-peglib_project:cpp-peglib:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.1.12", "matchCriteriaId": "7E9A6A5B-E857-44B5-B9C0-8DA8E21A075E"}]}]}], "references": [{"url": "https://github.com/yhirose/cpp-peglib/commit/0061f393de54cf0326621c079dc2988336d1ebb3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/yhirose/cpp-peglib/issues/121", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/yhirose/cpp-peglib/commit/0061f393de54cf0326621c079dc2988336d1ebb3"}}