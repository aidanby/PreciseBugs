{"buggy_code": ["# frozen_string_literal: true\n\nrequire \"digest/sha1\"\n\n# Publify user.\n# TODO: Should belong to a blog\nclass User < ApplicationRecord\n  ADMIN = \"admin\"\n  PUBLISHER = \"publisher\"\n  CONTRIBUTOR = \"contributor\"\n\n  # Include default devise modules. Others available are:\n  # :confirmable, :lockable, :timeoutable and :omniauthable\n  devise :database_authenticatable, :registerable,\n         :recoverable, :rememberable, :trackable, :validatable\n  include ConfigManager\n  include StringLengthLimit\n\n  before_validation :set_default_profile\n\n  validates :login, uniqueness: true\n  validates :email, :login, presence: true\n  validates :login, length: { in: 3..40 }\n  validates_default_string_length :email, :text_filter_name\n\n  belongs_to :resource, optional: true\n  has_many :notifications, foreign_key: \"notify_user_id\"\n  has_many :notify_contents, -> { uniq }, through: :notifications,\n                                          source: \"notify_content\"\n\n  has_many :articles\n\n  serialize :settings, Hash\n\n  STATUS = %w(active inactive).freeze\n\n  attr_accessor :filename\n\n  # Settings\n  setting :notify_watch_my_articles, :boolean, true\n  setting :firstname, :string, \"\"\n  setting :lastname, :string, \"\"\n  setting :nickname, :string, \"\"\n  setting :description, :string, \"\"\n  setting :url, :string, \"\"\n  setting :msn, :string, \"\"\n  setting :aim, :string, \"\"\n  setting :yahoo, :string, \"\"\n  setting :twitter, :string, \"\"\n  setting :jabber, :string, \"\"\n  setting :admin_theme, :string, \"blue\"\n  setting :twitter_account, :string, \"\"\n  setting :twitter_oauth_token, :string, \"\"\n  setting :twitter_oauth_token_secret, :string, \"\"\n  setting :twitter_profile_image, :string, \"\"\n\n  # echo \"publify\" | sha1sum -\n  class_attribute :salt\n\n  def self.salt\n    \"20ac4d290c2293702c64b3b287ae5ea79b26a5c1\"\n  end\n\n  def first_and_last_name\n    return \"\" unless firstname.present? && lastname.present?\n\n    \"#{firstname} #{lastname}\"\n  end\n\n  def display_names\n    [:login, :nickname, :firstname, :lastname, :first_and_last_name].\n      map { |f| send(f) }.delete_if(&:empty?)\n  end\n\n  # Authenticate users with old password hashes\n  alias devise_valid_password? valid_password?\n\n  def valid_password?(password)\n    devise_valid_password?(password)\n  rescue BCrypt::Errors::InvalidHash\n    digest = Digest::SHA1.hexdigest(\"#{self.class.salt}--#{password}--\")\n    if digest == encrypted_password\n      # Update old SHA1 password with new Devise ByCrypt password\n      self.encrypted_password = password_digest(password)\n      save\n      true\n    else\n      # If not BCrypt password and not old SHA1 password deny access\n      false\n    end\n  end\n\n  def active_for_authentication?\n    super && state == \"active\"\n  end\n\n  def text_filter\n    TextFilter.make_filter(text_filter_name)\n  end\n\n  def self.to_prefix\n    \"author\"\n  end\n\n  def article_counter\n    articles.size\n  end\n\n  def display_name\n    if nickname.present?\n      nickname\n    elsif name.present?\n      name\n    else\n      login\n    end\n  end\n\n  def permalink\n    login\n  end\n\n  def admin?\n    profile == User::ADMIN\n  end\n\n  def update_twitter_profile_image(img)\n    return if twitter_profile_image == img\n\n    self.twitter_profile_image = img\n    save\n  end\n\n  def has_twitter_configured?\n    twitter_oauth_token.present? && twitter_oauth_token_secret.present?\n  end\n\n  private\n\n  def set_default_profile\n    self.profile ||= User.count.zero? ? \"admin\" : \"contributor\"\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe User, type: :model do\n  describe \"FactoryBot Bot\" do\n    it \"users factory valid\" do\n      expect(create(:user)).to be_valid\n      expect(build(:user)).to be_valid\n    end\n\n    it \"multiples user factory valid\" do\n      expect(create(:user)).to be_valid\n      expect(create(:user)).to be_valid\n    end\n\n    it \"salt should not be nil\" do\n      expect(described_class.salt).to eq(\"20ac4d290c2293702c64b3b287ae5ea79b26a5c1\")\n    end\n  end\n\n  describe \"#active_for_authentication?\" do\n    it \"is true for users in the state 'active'\" do\n      user = build :user, state: \"active\"\n      expect(user).to be_active_for_authentication\n    end\n\n    it \"is false for users in the state 'inactive'\" do\n      user = build :user, state: \"inactive\"\n      expect(user).not_to be_active_for_authentication\n    end\n  end\n\n  context \"With the contents and users fixtures loaded\" do\n    it \"The various article finders work appropriately\" do\n      create(:blog)\n      tobi = create(:user)\n      create_list(:article, 7, user: tobi)\n      create(:article, state: \"draft\", published_at: nil, user: tobi)\n      expect(tobi.articles.size).to eq(8)\n      expect(tobi.articles.published.size).to eq(7)\n    end\n  end\n\n  describe \"validations\" do\n    let(:user) { described_class.new }\n\n    it \"requires email to not be too long\" do\n      expect(user).to validate_length_of(:email).is_at_most(255)\n    end\n\n    it \"requires first name to not be too long\" do\n      expect(user).to validate_length_of(:firstname).is_at_most(256)\n    end\n\n    it \"requires last name to not be too long\" do\n      expect(user).to validate_length_of(:lastname).is_at_most(256)\n    end\n\n    it \"requires the email field to be present\" do\n      expect(user).to validate_presence_of(:email)\n    end\n\n    it \"requires the email field to always be unique\" do\n      expect(user).to validate_uniqueness_of(:email)\n    end\n\n    it \"requires the login field to always be unique\" do\n      expect(user).to validate_uniqueness_of(:login).case_insensitive\n    end\n\n    it \"requires the login field to be of reasonable length\" do\n      expect(user).to validate_length_of(:login).is_at_least(3).is_at_most(40)\n    end\n\n    it \"requires the login field to be present\" do\n      expect(user).to validate_presence_of(:login)\n    end\n\n    it \"requires text_filter_name to not be too long\" do\n      expect(user).to validate_length_of(:text_filter_name).is_at_most(255)\n    end\n\n    it \"does not allow duplicate logins when updating a user\" do\n      create :user, login: \"foo\"\n      bar = create :user, login: \"bar\"\n\n      expect(bar).not_to allow_value(\"foo\").for(:login)\n    end\n\n    it \"does not allow duplicate emails when updating a user\" do\n      create :user, email: \"foo@foo.com\"\n      bar = create :user, email: \"bar@bar.com\"\n\n      expect(bar).not_to allow_value(\"foo@foo.com\").for(:email)\n    end\n  end\n\n  describe \"#initialize\" do\n    it \"accepts a settings field in its parameter hash\" do\n      described_class.new(\"firstname\" => \"foo\")\n    end\n  end\n\n  describe \"#admin?\" do\n    it \"returns true if user is admin\" do\n      admin = build(:user, :as_admin)\n      expect(admin).to be_admin\n    end\n\n    it \"returns false if user is not admin\" do\n      publisher = build(:user, :as_publisher)\n      expect(publisher).not_to be_admin\n    end\n  end\n\n  describe \"#first_and_last_name\" do\n    context \"with first and last name\" do\n      let(:user) { create(:user, firstname: \"Marlon\", lastname: \"Brando\") }\n\n      it { expect(user.first_and_last_name).to eq(\"Marlon Brando\") }\n    end\n\n    context \"with firstname without lastname\" do\n      let(:user) { create(:user, firstname: \"Marlon\", lastname: nil) }\n\n      it { expect(user.first_and_last_name).to eq(\"\") }\n    end\n  end\n\n  describe \"#display_names\" do\n    context \"with user without nickname, firstname, lastname\" do\n      let(:user) { create(:user, nickname: nil, firstname: nil, lastname: nil) }\n\n      it { expect(user.display_names).to eq([user.login]) }\n    end\n\n    context \"with user with nickname without firstname, lastname\" do\n      let(:user) { create(:user, nickname: \"Bob\", firstname: nil, lastname: nil) }\n\n      it { expect(user.display_names).to eq([user.login, user.nickname]) }\n    end\n\n    context \"with user with firstname, without nickname, lastname\" do\n      let(:user) { create(:user, nickname: nil, firstname: \"Robert\", lastname: nil) }\n\n      it { expect(user.display_names).to eq([user.login, user.firstname]) }\n    end\n\n    context \"with user with lastname, without nickname, firstname\" do\n      let(:user) { create(:user, nickname: nil, firstname: nil, lastname: \"Redford\") }\n\n      it { expect(user.display_names).to eq([user.login, user.lastname]) }\n    end\n\n    context \"with user with firstname and lastname, witjout nickname\" do\n      let(:user) { create(:user, nickname: nil, firstname: \"Robert\", lastname: \"Redford\") }\n\n      it {\n        expect(user.display_names).\n          to eq([user.login, user.firstname, user.lastname,\n                 \"#{user.firstname} #{user.lastname}\"])\n      }\n    end\n  end\n\n  describe \"#has_twitter_configured?\" do\n    it \"is false without twitter_oauth_token or twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: nil, twitter_oauth_token_secret: nil)\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with an empty twitter_oauth_token and no twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"\", twitter_oauth_token_secret: nil)\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with empty twitter_oauth_token and twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"\", twitter_oauth_token_secret: \"\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token and no twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"12345\", twitter_oauth_token_secret: nil)\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token and an empty twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"12345\", twitter_oauth_token_secret: \"\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token_secret and no twitter_oauth_token\" do\n      user = build(:user, twitter_oauth_token: \"\", twitter_oauth_token_secret: \"67890\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token_secret and an empty twitter_oauth_token\" do\n      user = build(:user, twitter_oauth_token_secret: \"67890\", twitter_oauth_token: \"\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is true with a twitter_oauth_token and a twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"12345\", twitter_oauth_token_secret: \"67890\")\n      expect(user.has_twitter_configured?).to eq(true)\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire \"digest/sha1\"\n\n# Publify user.\n# TODO: Should belong to a blog\nclass User < ApplicationRecord\n  ADMIN = \"admin\"\n  PUBLISHER = \"publisher\"\n  CONTRIBUTOR = \"contributor\"\n\n  # Include default devise modules. Others available are:\n  # :confirmable, :lockable, :timeoutable and :omniauthable\n  devise :database_authenticatable, :registerable,\n         :recoverable, :rememberable, :trackable, :validatable\n  include ConfigManager\n  include StringLengthLimit\n\n  before_validation :set_default_profile\n\n  validates :login, uniqueness: true\n  validates :email, :login, presence: true\n  validates :login, length: { in: 3..40 }\n  validates_default_string_length :email, :text_filter_name\n  validates :name, length: { maximum: 2048 }\n\n  belongs_to :resource, optional: true\n  has_many :notifications, foreign_key: \"notify_user_id\"\n  has_many :notify_contents, -> { uniq }, through: :notifications,\n                                          source: \"notify_content\"\n\n  has_many :articles\n\n  serialize :settings, Hash\n\n  STATUS = %w(active inactive).freeze\n\n  attr_accessor :filename\n\n  # Settings\n  setting :notify_watch_my_articles, :boolean, true\n  setting :firstname, :string, \"\"\n  setting :lastname, :string, \"\"\n  setting :nickname, :string, \"\"\n  setting :description, :string, \"\"\n  setting :url, :string, \"\"\n  setting :msn, :string, \"\"\n  setting :aim, :string, \"\"\n  setting :yahoo, :string, \"\"\n  setting :twitter, :string, \"\"\n  setting :jabber, :string, \"\"\n  setting :admin_theme, :string, \"blue\"\n  setting :twitter_account, :string, \"\"\n  setting :twitter_oauth_token, :string, \"\"\n  setting :twitter_oauth_token_secret, :string, \"\"\n  setting :twitter_profile_image, :string, \"\"\n\n  # echo \"publify\" | sha1sum -\n  class_attribute :salt\n\n  def self.salt\n    \"20ac4d290c2293702c64b3b287ae5ea79b26a5c1\"\n  end\n\n  def first_and_last_name\n    return \"\" unless firstname.present? && lastname.present?\n\n    \"#{firstname} #{lastname}\"\n  end\n\n  def display_names\n    [:login, :nickname, :firstname, :lastname, :first_and_last_name].\n      map { |f| send(f) }.delete_if(&:empty?)\n  end\n\n  # Authenticate users with old password hashes\n  alias devise_valid_password? valid_password?\n\n  def valid_password?(password)\n    devise_valid_password?(password)\n  rescue BCrypt::Errors::InvalidHash\n    digest = Digest::SHA1.hexdigest(\"#{self.class.salt}--#{password}--\")\n    if digest == encrypted_password\n      # Update old SHA1 password with new Devise ByCrypt password\n      self.encrypted_password = password_digest(password)\n      save\n      true\n    else\n      # If not BCrypt password and not old SHA1 password deny access\n      false\n    end\n  end\n\n  def active_for_authentication?\n    super && state == \"active\"\n  end\n\n  def text_filter\n    TextFilter.make_filter(text_filter_name)\n  end\n\n  def self.to_prefix\n    \"author\"\n  end\n\n  def article_counter\n    articles.size\n  end\n\n  def display_name\n    if nickname.present?\n      nickname\n    elsif name.present?\n      name\n    else\n      login\n    end\n  end\n\n  def permalink\n    login\n  end\n\n  def admin?\n    profile == User::ADMIN\n  end\n\n  def update_twitter_profile_image(img)\n    return if twitter_profile_image == img\n\n    self.twitter_profile_image = img\n    save\n  end\n\n  def has_twitter_configured?\n    twitter_oauth_token.present? && twitter_oauth_token_secret.present?\n  end\n\n  private\n\n  def set_default_profile\n    self.profile ||= User.count.zero? ? \"admin\" : \"contributor\"\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe User, type: :model do\n  describe \"FactoryBot Bot\" do\n    it \"users factory valid\" do\n      expect(create(:user)).to be_valid\n      expect(build(:user)).to be_valid\n    end\n\n    it \"multiples user factory valid\" do\n      expect(create(:user)).to be_valid\n      expect(create(:user)).to be_valid\n    end\n\n    it \"salt should not be nil\" do\n      expect(described_class.salt).to eq(\"20ac4d290c2293702c64b3b287ae5ea79b26a5c1\")\n    end\n  end\n\n  describe \"#active_for_authentication?\" do\n    it \"is true for users in the state 'active'\" do\n      user = build :user, state: \"active\"\n      expect(user).to be_active_for_authentication\n    end\n\n    it \"is false for users in the state 'inactive'\" do\n      user = build :user, state: \"inactive\"\n      expect(user).not_to be_active_for_authentication\n    end\n  end\n\n  context \"With the contents and users fixtures loaded\" do\n    it \"The various article finders work appropriately\" do\n      create(:blog)\n      tobi = create(:user)\n      create_list(:article, 7, user: tobi)\n      create(:article, state: \"draft\", published_at: nil, user: tobi)\n      expect(tobi.articles.size).to eq(8)\n      expect(tobi.articles.published.size).to eq(7)\n    end\n  end\n\n  describe \"validations\" do\n    let(:user) { described_class.new }\n\n    it \"requires email to not be too long\" do\n      expect(user).to validate_length_of(:email).is_at_most(255)\n    end\n\n    it \"requires name to not be too long\" do\n      expect(user).to validate_length_of(:name).is_at_most(2048)\n    end\n\n    it \"requires first name to not be too long\" do\n      expect(user).to validate_length_of(:firstname).is_at_most(256)\n    end\n\n    it \"requires last name to not be too long\" do\n      expect(user).to validate_length_of(:lastname).is_at_most(256)\n    end\n\n    it \"requires the email field to be present\" do\n      expect(user).to validate_presence_of(:email)\n    end\n\n    it \"requires the email field to always be unique\" do\n      expect(user).to validate_uniqueness_of(:email)\n    end\n\n    it \"requires the login field to always be unique\" do\n      expect(user).to validate_uniqueness_of(:login).case_insensitive\n    end\n\n    it \"requires the login field to be of reasonable length\" do\n      expect(user).to validate_length_of(:login).is_at_least(3).is_at_most(40)\n    end\n\n    it \"requires the login field to be present\" do\n      expect(user).to validate_presence_of(:login)\n    end\n\n    it \"requires text_filter_name to not be too long\" do\n      expect(user).to validate_length_of(:text_filter_name).is_at_most(255)\n    end\n\n    it \"does not allow duplicate logins when updating a user\" do\n      create :user, login: \"foo\"\n      bar = create :user, login: \"bar\"\n\n      expect(bar).not_to allow_value(\"foo\").for(:login)\n    end\n\n    it \"does not allow duplicate emails when updating a user\" do\n      create :user, email: \"foo@foo.com\"\n      bar = create :user, email: \"bar@bar.com\"\n\n      expect(bar).not_to allow_value(\"foo@foo.com\").for(:email)\n    end\n  end\n\n  describe \"#initialize\" do\n    it \"accepts a settings field in its parameter hash\" do\n      described_class.new(\"firstname\" => \"foo\")\n    end\n  end\n\n  describe \"#admin?\" do\n    it \"returns true if user is admin\" do\n      admin = build(:user, :as_admin)\n      expect(admin).to be_admin\n    end\n\n    it \"returns false if user is not admin\" do\n      publisher = build(:user, :as_publisher)\n      expect(publisher).not_to be_admin\n    end\n  end\n\n  describe \"#first_and_last_name\" do\n    context \"with first and last name\" do\n      let(:user) { create(:user, firstname: \"Marlon\", lastname: \"Brando\") }\n\n      it { expect(user.first_and_last_name).to eq(\"Marlon Brando\") }\n    end\n\n    context \"with firstname without lastname\" do\n      let(:user) { create(:user, firstname: \"Marlon\", lastname: nil) }\n\n      it { expect(user.first_and_last_name).to eq(\"\") }\n    end\n  end\n\n  describe \"#display_names\" do\n    context \"with user without nickname, firstname, lastname\" do\n      let(:user) { create(:user, nickname: nil, firstname: nil, lastname: nil) }\n\n      it { expect(user.display_names).to eq([user.login]) }\n    end\n\n    context \"with user with nickname without firstname, lastname\" do\n      let(:user) { create(:user, nickname: \"Bob\", firstname: nil, lastname: nil) }\n\n      it { expect(user.display_names).to eq([user.login, user.nickname]) }\n    end\n\n    context \"with user with firstname, without nickname, lastname\" do\n      let(:user) { create(:user, nickname: nil, firstname: \"Robert\", lastname: nil) }\n\n      it { expect(user.display_names).to eq([user.login, user.firstname]) }\n    end\n\n    context \"with user with lastname, without nickname, firstname\" do\n      let(:user) { create(:user, nickname: nil, firstname: nil, lastname: \"Redford\") }\n\n      it { expect(user.display_names).to eq([user.login, user.lastname]) }\n    end\n\n    context \"with user with firstname and lastname, witjout nickname\" do\n      let(:user) { create(:user, nickname: nil, firstname: \"Robert\", lastname: \"Redford\") }\n\n      it {\n        expect(user.display_names).\n          to eq([user.login, user.firstname, user.lastname,\n                 \"#{user.firstname} #{user.lastname}\"])\n      }\n    end\n  end\n\n  describe \"#has_twitter_configured?\" do\n    it \"is false without twitter_oauth_token or twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: nil, twitter_oauth_token_secret: nil)\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with an empty twitter_oauth_token and no twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"\", twitter_oauth_token_secret: nil)\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with empty twitter_oauth_token and twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"\", twitter_oauth_token_secret: \"\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token and no twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"12345\", twitter_oauth_token_secret: nil)\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token and an empty twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"12345\", twitter_oauth_token_secret: \"\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token_secret and no twitter_oauth_token\" do\n      user = build(:user, twitter_oauth_token: \"\", twitter_oauth_token_secret: \"67890\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token_secret and an empty twitter_oauth_token\" do\n      user = build(:user, twitter_oauth_token_secret: \"67890\", twitter_oauth_token: \"\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is true with a twitter_oauth_token and a twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"12345\", twitter_oauth_token_secret: \"67890\")\n      expect(user.has_twitter_configured?).to eq(true)\n    end\n  end\nend\n"], "filenames": ["publify_core/app/models/user.rb", "publify_core/spec/models/user_spec.rb"], "buggy_code_start_loc": [24, 51], "buggy_code_end_loc": [24, 51], "fixing_code_start_loc": [25, 52], "fixing_code_end_loc": [26, 56], "type": "CWE-190", "message": "Integer Overflow or Wraparound in GitHub repository publify/publify prior to 9.2.10.", "other": {"cve": {"id": "CVE-2022-1812", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-14T14:15:08.953", "lastModified": "2023-01-23T14:21:36.940", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer Overflow or Wraparound in GitHub repository publify/publify prior to 9.2.10."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:H/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 6.0}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:publify_project:publify:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.2.10", "matchCriteriaId": "F96D7B8E-CB71-4E0F-807E-E1BE71D1C939"}]}]}], "references": [{"url": "https://github.com/publify/publify/commit/29a5837c29620e33857d7a5afce01384e3f8e41a", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/17d86a50-265c-4ec8-9592-0bd909ddc8f3", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/publify/publify/commit/29a5837c29620e33857d7a5afce01384e3f8e41a"}}