{"buggy_code": ["/**\nUnescape token part of a JSON Pointer string\n\n`token` should *not* contain any '/' characters.\n\n> Evaluation of each reference token begins by decoding any escaped\n> character sequence.  This is performed by first transforming any\n> occurrence of the sequence '~1' to '/', and then transforming any\n> occurrence of the sequence '~0' to '~'.  By performing the\n> substitutions in this order, an implementation avoids the error of\n> turning '~01' first into '~1' and then into '/', which would be\n> incorrect (the string '~01' correctly becomes '~1' after\n> transformation).\n\nHere's my take:\n\n~1 is unescaped with higher priority than ~0 because it is a lower-order escape character.\nI say \"lower order\" because '/' needs escaping due to the JSON Pointer serialization technique.\nWhereas, '~' is escaped because escaping '/' uses the '~' character.\n*/\nfunction unescape(token: string): string {\n  return token.replace(/~1/g, '/').replace(/~0/g, '~')\n}\n\n/** Escape token part of a JSON Pointer string\n\n> '~' needs to be encoded as '~0' and '/'\n> needs to be encoded as '~1' when these characters appear in a\n> reference token.\n\nThis is the exact inverse of `unescape()`, so the reverse replacements must take place in reverse order.\n*/\nfunction escape(token: string): string {\n  return token.replace(/~/g, '~0').replace(/\\//g, '~1')\n}\n\nexport interface PointerEvaluation {\n  parent: any\n  key: string\n  value: any\n}\n\n/**\nJSON Pointer representation\n*/\nexport class Pointer {\n  constructor(public tokens = ['']) { }\n  /**\n  `path` *must* be a properly escaped string.\n  */\n  static fromJSON(path: string): Pointer {\n    const tokens = path.split('/').map(unescape)\n    if (tokens[0] !== '') throw new Error(`Invalid JSON Pointer: ${path}`)\n    return new Pointer(tokens)\n  }\n  toString(): string {\n    return this.tokens.map(escape).join('/')\n  }\n  /**\n  Returns an object with 'parent', 'key', and 'value' properties.\n  In the special case that this Pointer's path == \"\",\n  this object will be {parent: null, key: '', value: object}.\n  Otherwise, parent and key will have the property such that parent[key] == value.\n  */\n  evaluate(object: any): PointerEvaluation {\n    let parent: any = null\n    let key = ''\n    let value = object\n    for (let i = 1, l = this.tokens.length; i < l; i++) {\n      parent = value\n      key = this.tokens[i]\n      // not sure if this the best way to handle non-existant paths...\n      value = (parent || {})[key]\n    }\n    return {parent, key, value}\n  }\n  get(object: any): any {\n    return this.evaluate(object).value\n  }\n  set(object: any, value: any): void {\n    let cursor: any = object\n    for (let i = 1, l = this.tokens.length - 1, token = this.tokens[i]; i < l; i++) {\n      // not sure if this the best way to handle non-existant paths...\n      cursor = (cursor || {})[token]\n    }\n    if (cursor) {\n      cursor[this.tokens[this.tokens.length - 1]] = value\n    }\n  }\n  push(token: string): void {\n    // mutable\n    this.tokens.push(token)\n  }\n  /**\n  `token` should be a String. It'll be coerced to one anyway.\n\n  immutable (shallowly)\n  */\n  add(token: string): Pointer {\n    const tokens = this.tokens.concat(String(token))\n    return new Pointer(tokens)\n  }\n}\n"], "fixing_code": ["/**\nUnescape token part of a JSON Pointer string\n\n`token` should *not* contain any '/' characters.\n\n> Evaluation of each reference token begins by decoding any escaped\n> character sequence.  This is performed by first transforming any\n> occurrence of the sequence '~1' to '/', and then transforming any\n> occurrence of the sequence '~0' to '~'.  By performing the\n> substitutions in this order, an implementation avoids the error of\n> turning '~01' first into '~1' and then into '/', which would be\n> incorrect (the string '~01' correctly becomes '~1' after\n> transformation).\n\nHere's my take:\n\n~1 is unescaped with higher priority than ~0 because it is a lower-order escape character.\nI say \"lower order\" because '/' needs escaping due to the JSON Pointer serialization technique.\nWhereas, '~' is escaped because escaping '/' uses the '~' character.\n*/\nfunction unescape(token: string): string {\n  return token.replace(/~1/g, '/').replace(/~0/g, '~')\n}\n\n/** Escape token part of a JSON Pointer string\n\n> '~' needs to be encoded as '~0' and '/'\n> needs to be encoded as '~1' when these characters appear in a\n> reference token.\n\nThis is the exact inverse of `unescape()`, so the reverse replacements must take place in reverse order.\n*/\nfunction escape(token: string): string {\n  return token.replace(/~/g, '~0').replace(/\\//g, '~1')\n}\n\nexport interface PointerEvaluation {\n  parent: any\n  key: string\n  value: any\n}\n\n/**\nJSON Pointer representation\n*/\nexport class Pointer {\n  constructor(public tokens = ['']) { }\n  /**\n  `path` *must* be a properly escaped string.\n  */\n  static fromJSON(path: string): Pointer {\n    const tokens = path.split('/').map(unescape)\n    if (tokens[0] !== '') throw new Error(`Invalid JSON Pointer: ${path}`)\n    return new Pointer(tokens)\n  }\n  toString(): string {\n    return this.tokens.map(escape).join('/')\n  }\n  /**\n  Returns an object with 'parent', 'key', and 'value' properties.\n  In the special case that this Pointer's path == \"\",\n  this object will be {parent: null, key: '', value: object}.\n  Otherwise, parent and key will have the property such that parent[key] == value.\n  */\n  evaluate(object: any): PointerEvaluation {\n    let parent: any = null\n    let key = ''\n    let value = object\n    for (let i = 1, l = this.tokens.length; i < l; i++) {\n      parent = value\n      key = this.tokens[i]\n      if (key == '__proto__' || key == 'constructor' || key == 'prototype') {\n        continue\n      }\n      // not sure if this the best way to handle non-existant paths...\n      value = (parent || {})[key]\n    }\n    return {parent, key, value}\n  }\n  get(object: any): any {\n    return this.evaluate(object).value\n  }\n  set(object: any, value: any): void {\n    let cursor: any = object\n    for (let i = 1, l = this.tokens.length - 1, token = this.tokens[i]; i < l; i++) {\n      // not sure if this the best way to handle non-existant paths...\n      cursor = (cursor || {})[token]\n    }\n    if (cursor) {\n      cursor[this.tokens[this.tokens.length - 1]] = value\n    }\n  }\n  push(token: string): void {\n    // mutable\n    this.tokens.push(token)\n  }\n  /**\n  `token` should be a String. It'll be coerced to one anyway.\n\n  immutable (shallowly)\n  */\n  add(token: string): Pointer {\n    const tokens = this.tokens.concat(String(token))\n    return new Pointer(tokens)\n  }\n}\n"], "filenames": ["pointer.ts"], "buggy_code_start_loc": [71], "buggy_code_end_loc": [71], "fixing_code_start_loc": [72], "fixing_code_end_loc": [75], "type": "CWE-1321", "message": "A vulnerability classified as problematic has been found in chbrown rfc6902. This affects an unknown part of the file pointer.ts. The manipulation leads to improperly controlled modification of object prototype attributes ('prototype pollution'). The exploit has been disclosed to the public and may be used. The name of the patch is c006ce9faa43d31edb34924f1df7b79c137096cf. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-215883.", "other": {"cve": {"id": "CVE-2021-4245", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-15T20:15:09.783", "lastModified": "2022-12-20T17:44:25.030", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as problematic has been found in chbrown rfc6902. This affects an unknown part of the file pointer.ts. The manipulation leads to improperly controlled modification of object prototype attributes ('prototype pollution'). The exploit has been disclosed to the public and may be used. The name of the patch is c006ce9faa43d31edb34924f1df7b79c137096cf. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-215883."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1321"}, {"lang": "en", "value": "CWE-74"}, {"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rfc6902_project:rfc6902:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.0.0", "matchCriteriaId": "0E0E03BF-922A-4CFF-A120-A22138E59D06"}]}]}], "references": [{"url": "https://github.com/chbrown/rfc6902/commit/c006ce9faa43d31edb34924f1df7b79c137096cf", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/chbrown/rfc6902/pull/76", "source": "cna@vuldb.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.215883", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/chbrown/rfc6902/commit/c006ce9faa43d31edb34924f1df7b79c137096cf"}}