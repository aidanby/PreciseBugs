{"buggy_code": ["from django.template import Library\nfrom django.template.defaultfilters import stringfilter\n\nfrom rest_framework.reverse import reverse\n\nfrom openforms.config.models import GlobalConfiguration\n\nfrom ..context_processors import sdk_urls\n\nregister = Library()\n\n\n@register.simple_tag(takes_context=True)\ndef api_base_url(context: dict):\n    request = context[\"request\"]\n    api_root = reverse(\"api:api-root\")\n    return request.build_absolute_uri(api_root)\n\n\n@register.filter\n@stringfilter\ndef trim(value):\n    return value.strip()\n\n\n@register.inclusion_tag(\"forms/sdk_info_banner.html\")\ndef sdk_info_banner():\n    config = GlobalConfiguration.get_solo()\n    return {\n        \"enabled\": config.display_sdk_information,\n        **sdk_urls(request=None),\n    }\n", "{% extends 'ui/views/abstract/list.html' %}\n{% load i18n %}\n\n\n{% block card %}\n    {% firstof request.GET.referer request.headers.referer as referer %}\n    <header class=\"card__header\">\n        <h1 class=\"title\">{% trans \"Cookies\" %}</h1>\n    </header>\n\n    <div class=\"card__body\">\n        {% block card_body %}\n            <p>\n              {% trans \"This is a list of the categories of cookies used in our website and why we use them.\" %}\n            </p>\n            <ul class=\"list\">\n                {% for cookie_group in object_list  %}\n                    <li class=\"list__item\">\n                        {% include \"cookie_consent/_cookie_group.html\" %}\n                    </li>\n                {% endfor %}\n            </ul>\n        {% endblock %}\n\n        {% if referer %}\n            <a href=\"{{ referer }}\" class=\"button button--primary\">\n                {% trans \"Close\" %}\n            </a>\n        {% endif %}\n    </div>\n{% endblock %}\n", "from io import StringIO\n\nfrom django.core.management import call_command\nfrom django.test import override_settings\nfrom django.urls import reverse\n\nfrom cookie_consent.cache import delete_cache\nfrom cookie_consent.models import CookieGroup\nfrom django_webtest import WebTest\n\nfrom openforms.config.models import GlobalConfiguration\nfrom openforms.forms.tests.factories import FormFactory\nfrom openforms.tests.utils import NOOP_CACHES\n\n\n@override_settings(CACHES=NOOP_CACHES)\nclass CookieNoticeTests(WebTest):\n    @classmethod\n    def setUpTestData(cls):\n        super().setUpTestData()\n\n        cls.form = FormFactory.create()\n        cls.url = reverse(\"forms:form-detail\", kwargs={\"slug\": cls.form.slug})\n\n        # load some default cookie groups and cookies\n        call_command(\"loaddata\", \"cookie_consent\", stdout=StringIO())\n\n        config = GlobalConfiguration.get_solo()\n\n        # configure analytics so that the JS snippets are not empty\n        config.gtm_code = \"GTM-XXXX\"\n        config.ga_code = \"UA-XXXXX-Y\"\n        config.matomo_url = \"https://example.com\"\n        config.matomo_site_id = \"1234\"\n        config.piwik_url = \"https://example.com\"\n        config.piwik_site_id = \"1234\"\n        config.siteimprove_id = \"1234\"\n        config.analytics_cookie_consent_group = CookieGroup.objects.get(\n            varname=\"analytical\"\n        )\n        config.save()\n\n        # workaround for https://github.com/bmihelac/django-cookie-consent/issues/41\n        # the cache instance is resolved at import time rather than at runtime.\n        delete_cache()\n\n    def test_anon_user_notice_rendered(self):\n        form_page = self.app.get(self.url)\n\n        cookie_notice = form_page.pyquery(\".cookie-notice\")\n\n        # check that the notice is present\n        self.assertTrue(bool(cookie_notice))\n\n    def test_accept_reject_cookies(self):\n        \"\"\"\n        Assert that the cookie notice is no longer visible once the user accepted or\n        rejected them.\n        \"\"\"\n        with self.subTest(action=\"accept\"):\n            form_page = self.app.get(self.url)\n\n            accept_form = form_page.forms[0]\n            assert \"accept\" in accept_form.action\n\n            refreshed_form_page = accept_form.submit().follow()\n\n            self.assertEqual(refreshed_form_page.request.path, self.url)\n            self.assertFalse(refreshed_form_page.pyquery(\".cookie-notice\"))\n\n        self.renew_app()\n\n        with self.subTest(action=\"decline\"):\n            form_page = self.app.get(self.url)\n\n            decline_form = form_page.forms[1]\n            assert \"decline\" in decline_form.action\n\n            refreshed_form_page = decline_form.submit().follow()\n\n            self.assertEqual(refreshed_form_page.request.path, self.url)\n            self.assertFalse(refreshed_form_page.pyquery(\".cookie-notice\"))\n\n    def test_analytics_snippets_not_rendered(self):\n        \"\"\"\n        Assert that the analytics snippets are opt-in.\n\n        Analytics snippets are only loaded after the user accepts the cookies.\n        \"\"\"\n        with self.subTest(case=\"no cookies accepted or declined\"):\n            form_page = self.app.get(self.url)\n\n            self.assertTemplateNotUsed(form_page, \"includes/analytics/all_head.html\")\n            self.assertTemplateNotUsed(form_page, \"includes/analytics/all_bottom.html\")\n\n        with self.subTest(case=\"cookies rejected\"):\n            decline_form = form_page.forms[1]\n            assert \"decline\" in decline_form.action\n\n            refreshed_form_page = decline_form.submit().follow()\n\n            self.assertTemplateNotUsed(\n                refreshed_form_page, \"includes/analytics/all_head.html\"\n            )\n            self.assertTemplateNotUsed(\n                refreshed_form_page, \"includes/analytics/all_bottom.html\"\n            )\n\n        self.renew_app()\n\n        with self.subTest(case=\"cookies accepted\"):\n            form_page = self.app.get(self.url)\n\n            accept_form = form_page.forms[0]\n            assert \"accept\" in accept_form.action\n\n            refreshed_form_page = accept_form.submit().follow()\n\n            self.assertTemplateUsed(\n                refreshed_form_page, \"includes/analytics/all_head.html\"\n            )\n            self.assertTemplateUsed(\n                refreshed_form_page, \"includes/analytics/all_bottom.html\"\n            )\n", "from urllib.parse import urlparse, urlunparse\n\nfrom corsheaders.conf import conf as cors_conf\nfrom corsheaders.middleware import CorsMiddleware\n\n\ndef origin_from_url(url: str) -> str:\n    parts = urlparse(url)\n    new = [parts[0], parts[1], \"\", \"\", \"\", \"\"]\n    return urlunparse(new)\n\n\ndef allow_redirect_url(url: str) -> bool:\n    \"\"\"\n    Check that a redirect target is allowed against the CORS policy.\n\n    The \"Cross-Origin Resource Sharing\" configuration specifies which external hosts\n    are allowed to access Open Forms. We leverage this configuration to block or allow\n    redirects to external hosts.\n    \"\"\"\n    cors = CorsMiddleware()\n    origin = origin_from_url(url)\n    parts = urlparse(url)\n\n    if not cors_conf.CORS_ALLOW_ALL_ORIGINS and not cors.origin_found_in_white_lists(\n        origin, parts\n    ):\n        return False\n    else:\n        return True\n"], "fixing_code": ["from django.template import Library\nfrom django.template.defaultfilters import stringfilter\n\nfrom rest_framework.reverse import reverse\n\nfrom openforms.config.models import GlobalConfiguration\nfrom openforms.utils.redirect import allow_redirect_url\n\nfrom ..context_processors import sdk_urls\n\nregister = Library()\n\n\n@register.simple_tag(takes_context=True)\ndef api_base_url(context: dict):\n    request = context[\"request\"]\n    api_root = reverse(\"api:api-root\")\n    return request.build_absolute_uri(api_root)\n\n\n@register.filter\n@stringfilter\ndef trim(value):\n    return value.strip()\n\n\n@register.inclusion_tag(\"forms/sdk_info_banner.html\")\ndef sdk_info_banner():\n    config = GlobalConfiguration.get_solo()\n    return {\n        \"enabled\": config.display_sdk_information,\n        **sdk_urls(request=None),\n    }\n\n\n@register.simple_tag\ndef get_allowed_redirect_url(*candidates: str) -> str:\n    \"\"\"\n    Output the first variable passed that is not empty and is an allowed redirect URL.\n\n    Output nothing if none of the values satisfy the requirements.\n\n    Heavily insired on the builtin {% firstof %} tag.\n    \"\"\"\n    for candidate in candidates:\n        if not candidate:\n            continue\n        if allow_redirect_url(candidate):\n            return candidate\n    return \"\"\n", "{% extends 'ui/views/abstract/list.html' %}\n{% load i18n openforms %}\n\n\n{% block card %}\n    {% get_allowed_redirect_url request.GET.referer request.headers.referer as referer %}\n    <header class=\"card__header\">\n        <h1 class=\"title\">{% trans \"Cookies\" %}</h1>\n    </header>\n\n    <div class=\"card__body\">\n        {% block card_body %}\n            <p>\n              {% trans \"This is a list of the categories of cookies used in our website and why we use them.\" %}\n            </p>\n            <ul class=\"list\">\n                {% for cookie_group in object_list  %}\n                    <li class=\"list__item\">\n                        {% include \"cookie_consent/_cookie_group.html\" %}\n                    </li>\n                {% endfor %}\n            </ul>\n        {% endblock %}\n\n        {% if referer %}\n            <a href=\"{{ referer }}\" class=\"button button--primary\">\n                {% trans \"Close\" %}\n            </a>\n        {% endif %}\n    </div>\n{% endblock %}\n", "from io import StringIO\n\nfrom django.core.management import call_command\nfrom django.test import override_settings, tag\nfrom django.urls import reverse\nfrom django.utils.translation import gettext as _\n\nfrom cookie_consent.cache import delete_cache\nfrom cookie_consent.models import CookieGroup\nfrom django_webtest import WebTest\nfrom furl import furl\n\nfrom openforms.config.models import GlobalConfiguration\nfrom openforms.forms.tests.factories import FormFactory\nfrom openforms.tests.utils import NOOP_CACHES\n\n\n@override_settings(CACHES=NOOP_CACHES)\nclass CookieNoticeTests(WebTest):\n    @classmethod\n    def setUpTestData(cls):\n        super().setUpTestData()\n\n        cls.form = FormFactory.create()\n        cls.url = reverse(\"forms:form-detail\", kwargs={\"slug\": cls.form.slug})\n\n        # load some default cookie groups and cookies\n        call_command(\"loaddata\", \"cookie_consent\", stdout=StringIO())\n\n        config = GlobalConfiguration.get_solo()\n\n        # configure analytics so that the JS snippets are not empty\n        config.gtm_code = \"GTM-XXXX\"\n        config.ga_code = \"UA-XXXXX-Y\"\n        config.matomo_url = \"https://example.com\"\n        config.matomo_site_id = \"1234\"\n        config.piwik_url = \"https://example.com\"\n        config.piwik_site_id = \"1234\"\n        config.siteimprove_id = \"1234\"\n        config.analytics_cookie_consent_group = CookieGroup.objects.get(\n            varname=\"analytical\"\n        )\n        config.save()\n\n        # workaround for https://github.com/bmihelac/django-cookie-consent/issues/41\n        # the cache instance is resolved at import time rather than at runtime.\n        delete_cache()\n\n    def test_anon_user_notice_rendered(self):\n        form_page = self.app.get(self.url)\n\n        cookie_notice = form_page.pyquery(\".cookie-notice\")\n\n        # check that the notice is present\n        self.assertTrue(bool(cookie_notice))\n\n    def test_accept_reject_cookies(self):\n        \"\"\"\n        Assert that the cookie notice is no longer visible once the user accepted or\n        rejected them.\n        \"\"\"\n        with self.subTest(action=\"accept\"):\n            form_page = self.app.get(self.url)\n\n            accept_form = form_page.forms[0]\n            assert \"accept\" in accept_form.action\n\n            refreshed_form_page = accept_form.submit().follow()\n\n            self.assertEqual(refreshed_form_page.request.path, self.url)\n            self.assertFalse(refreshed_form_page.pyquery(\".cookie-notice\"))\n\n        self.renew_app()\n\n        with self.subTest(action=\"decline\"):\n            form_page = self.app.get(self.url)\n\n            decline_form = form_page.forms[1]\n            assert \"decline\" in decline_form.action\n\n            refreshed_form_page = decline_form.submit().follow()\n\n            self.assertEqual(refreshed_form_page.request.path, self.url)\n            self.assertFalse(refreshed_form_page.pyquery(\".cookie-notice\"))\n\n    def test_analytics_snippets_not_rendered(self):\n        \"\"\"\n        Assert that the analytics snippets are opt-in.\n\n        Analytics snippets are only loaded after the user accepts the cookies.\n        \"\"\"\n        with self.subTest(case=\"no cookies accepted or declined\"):\n            form_page = self.app.get(self.url)\n\n            self.assertTemplateNotUsed(form_page, \"includes/analytics/all_head.html\")\n            self.assertTemplateNotUsed(form_page, \"includes/analytics/all_bottom.html\")\n\n        with self.subTest(case=\"cookies rejected\"):\n            decline_form = form_page.forms[1]\n            assert \"decline\" in decline_form.action\n\n            refreshed_form_page = decline_form.submit().follow()\n\n            self.assertTemplateNotUsed(\n                refreshed_form_page, \"includes/analytics/all_head.html\"\n            )\n            self.assertTemplateNotUsed(\n                refreshed_form_page, \"includes/analytics/all_bottom.html\"\n            )\n\n        self.renew_app()\n\n        with self.subTest(case=\"cookies accepted\"):\n            form_page = self.app.get(self.url)\n\n            accept_form = form_page.forms[0]\n            assert \"accept\" in accept_form.action\n\n            refreshed_form_page = accept_form.submit().follow()\n\n            self.assertTemplateUsed(\n                refreshed_form_page, \"includes/analytics/all_head.html\"\n            )\n            self.assertTemplateUsed(\n                refreshed_form_page, \"includes/analytics/all_bottom.html\"\n            )\n\n    @tag(\"GHSA-c97h-m5qf-j8mf\")\n    @override_settings(\n        CORS_ALLOW_ALL_ORIGINS=False,\n        CORS_ALLOWED_ORIGINS=[\"https://external.domain.com\"],\n        ALLOWED_HOSTS=[\"testserver\", \"example.com\"],\n        IS_HTTPS=True,\n    )\n    def test_accept_reject_does_not_allow_open_redirect(self):\n        url = reverse(\"cookie_consent_cookie_group_list\")\n        allowed_redirects = (\n            \"https://example.com/foo/bar\",\n            \"https://testserver/admin/\",\n            \"/admin/\",\n        )\n        blocked_redirects = (\n            \"http://example.com\",\n            \"https://evil.com\",\n        )\n\n        for allowed in allowed_redirects:\n            with self.subTest(f\"Allowed redirect to '{allowed}'\"):\n                self.renew_app()\n\n                cookies_page = self.app.get(url, {\"referer\": allowed})\n\n                button = cookies_page.pyquery.find(\"a.button--primary\")\n                self.assertEqual(button.attr[\"href\"], allowed)\n                self.assertEqual(button.text(), _(\"Close\"))\n\n        for blocked in blocked_redirects:\n            with self.subTest(f\"Blockedredirect to '{blocked}'\"):\n                self.renew_app()\n\n                cookies_page = self.app.get(url, {\"referer\": blocked})\n\n                button = cookies_page.pyquery.find(\"a.button--primary\")\n                self.assertFalse(button)\n\n                for form in cookies_page.forms.values():\n                    next_url = furl(form[\"next\"].value)\n\n                    self.assertEqual(next_url.args.get(\"referer\", \"\"), \"\")\n", "from urllib.parse import urlparse, urlunparse\n\nfrom django.conf import settings\nfrom django.utils.http import url_has_allowed_host_and_scheme\n\nfrom corsheaders.conf import conf as cors_conf\nfrom corsheaders.middleware import CorsMiddleware\n\n\ndef origin_from_url(url: str) -> str:\n    parts = urlparse(url)\n    new = [parts[0], parts[1], \"\", \"\", \"\", \"\"]\n    return urlunparse(new)\n\n\ndef allow_redirect_url(url: str) -> bool:\n    \"\"\"\n    Check that a redirect target is allowed against the CORS policy.\n\n    The \"Cross-Origin Resource Sharing\" configuration specifies which external hosts\n    are allowed to access Open Forms. We leverage this configuration to block or allow\n    redirects to external hosts.\n    \"\"\"\n    # first, check if the URL is in ALLOWED_HOSTS. We deliberately exclude the wildcard\n    # setting to require explicit configuration either via ALLOWED_HOSTS or CORS_* settings.\n    allowed_hosts_check = url_has_allowed_host_and_scheme(\n        url=url,\n        allowed_hosts=[host for host in settings.ALLOWED_HOSTS if host != \"*\"],\n        # settings.ALLOWED_HOSTS means we are serving the domain, so we can enforce our\n        # own custom HTTPS setting.\n        require_https=settings.IS_HTTPS,\n    )\n    # if we pass via ALLOWED_HOSTS, short-circuit, otherwise we check the CORS policy\n    # for allowed external domains.\n    if allowed_hosts_check:\n        return True\n\n    cors = CorsMiddleware()\n    origin = origin_from_url(url)\n    parts = urlparse(url)\n\n    if not cors_conf.CORS_ALLOW_ALL_ORIGINS and not cors.origin_found_in_white_lists(\n        origin, parts\n    ):\n        return False\n    else:\n        return True\n"], "filenames": ["src/openforms/forms/templatetags/openforms.py", "src/openforms/templates/cookie_consent/cookiegroup_list.html", "src/openforms/tests/test_cookie_notice.py", "src/openforms/utils/redirect.py"], "buggy_code_start_loc": [6, 2, 4, 1], "buggy_code_end_loc": [32, 7, 124, 20], "fixing_code_start_loc": [7, 2, 4, 2], "fixing_code_end_loc": [51, 7, 170, 38], "type": "CWE-601", "message": "Open Forms is an application for creating and publishing smart forms. Prior to versions 1.0.9 and 1.1.1, the cookie consent page in Open Forms contains an open redirect by injecting a `referer` querystring parameter and failing to validate the value. A malicious actor is able to redirect users to a website under their control, opening them up for phishing attacks. The redirect is initiated by the open forms backend which is a legimate page, making it less obvious to end users they are being redirected to a malicious website. Versions 1.0.9 and 1.1.1 contain patches for this issue. There are no known workarounds avaialble.", "other": {"cve": {"id": "CVE-2022-31040", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-13T12:15:08.360", "lastModified": "2022-06-21T14:16:44.243", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Open Forms is an application for creating and publishing smart forms. Prior to versions 1.0.9 and 1.1.1, the cookie consent page in Open Forms contains an open redirect by injecting a `referer` querystring parameter and failing to validate the value. A malicious actor is able to redirect users to a website under their control, opening them up for phishing attacks. The redirect is initiated by the open forms backend which is a legimate page, making it less obvious to end users they are being redirected to a malicious website. Versions 1.0.9 and 1.1.1 contain patches for this issue. There are no known workarounds avaialble."}, {"lang": "es", "value": "Open Forms es una aplicaci\u00f3n para crear y publicar formularios inteligentes. En versiones anteriores a 1.0.9 y 1.1.1, la p\u00e1gina de consentimiento de cookies en Open Forms contiene un redireccionamiento abierto al inyectar un par\u00e1metro de cadena de consulta \"referer\" y no comprender el valor. Un actor malicioso es capaz de redirigir a usuarios a un sitio web bajo su control, abri\u00e9ndolos a ataques de phishing. El redireccionamiento es iniciado por el backend de los formularios abiertos, que es una p\u00e1gina leg\u00edtima, lo que hace menos obvio para usuarios finales que est\u00e1n siendo redirigidos a un sitio web malicioso. Las versiones 1.0.9 y 1.1.1 contienen parches para este problema. No son conocidas mitigaciones disponibles"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:maykinmedia:open_forms:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.9", "matchCriteriaId": "CC6562EA-A0C8-4C37-B556-E83242D34914"}, {"vulnerable": true, "criteria": "cpe:2.3:a:maykinmedia:open_forms:1.10:-:*:*:*:*:*:*", "matchCriteriaId": "B564D60F-178C-4B58-AE49-17D95F5B6BF5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:maykinmedia:open_forms:1.10:rc0:*:*:*:*:*:*", "matchCriteriaId": "DC5F436F-9674-4530-B19B-DC4BC5CD7D61"}, {"vulnerable": true, "criteria": "cpe:2.3:a:maykinmedia:open_forms:1.10:rc1:*:*:*:*:*:*", "matchCriteriaId": "F0DB0F22-FBC9-447C-B3A0-5FBBB663F17E"}]}]}], "references": [{"url": "https://github.com/open-formulieren/open-forms/commit/3e8c9cce386e548765783354694fbb9d7a6ea7d3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/open-formulieren/open-forms/security/advisories/GHSA-c97h-m5qf-j8mf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/open-formulieren/open-forms/commit/3e8c9cce386e548765783354694fbb9d7a6ea7d3"}}