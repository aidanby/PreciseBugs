{"buggy_code": ["/*\n *  Copyright (c) 2011-2015 The original author or authors\n *  ------------------------------------------------------\n *  All rights reserved. This program and the accompanying materials\n *  are made available under the terms of the Eclipse Public License v1.0\n *  and Apache License v2.0 which accompanies this distribution.\n *\n *       The Eclipse Public License is available at\n *       http://www.eclipse.org/legal/epl-v10.html\n *\n *       The Apache License v2.0 is available at\n *       http://www.opensource.org/licenses/apache2.0.php\n *\n *  You may elect to redistribute this code under either of these licenses.\n */\n\npackage io.vertx.ext.stomp;\n\nimport io.vertx.core.AsyncResult;\nimport io.vertx.core.Future;\nimport io.vertx.core.Handler;\nimport io.vertx.ext.stomp.impl.FrameParser;\nimport io.vertx.ext.stomp.utils.Headers;\nimport io.vertx.ext.stomp.utils.Server;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * STOMP compliant actions executed when receiving a {@code CONNECT} frame. It may also be called when receiving a\n * {@code STOMP} frame depending on the {@link io.vertx.ext.stomp.StompServerHandler} configuration.\n * <p/>\n * This handler manages the STOMP version negotiation and authentication (if enabled). Once all the checks have been\n * passed, the {@code CONNECTED} frame is sent to the client.\n * <p/>\n * This handler is thread safe.\n *\n * @author <a href=\"http://escoffier.me\">Clement Escoffier</a>\n */\npublic class DefaultConnectHandler implements Handler<ServerFrame> {\n  @Override\n  public void handle(ServerFrame sf) {\n    // Server negotiation\n    List<String> accepted = new ArrayList<>();\n    String accept = sf.frame().getHeader(Frame.ACCEPT_VERSION);\n    if (accept == null) {\n      accepted.add(\"1.0\");\n    } else {\n      accepted.addAll(Arrays.asList(accept.split(FrameParser.COMMA)));\n    }\n\n    String version = negotiate(accepted, sf.connection());\n    if (version == null) {\n      // Spec says: if the server and the client do not share any common protocol versions, then the server MUST\n      // respond with an error.\n      sf.connection().write(Frames.createErrorFrame(\n              \"Incompatible versions\",\n              Headers.create(\n                  Frame.VERSION, getSupportedVersionsHeaderLine(sf.connection()),\n                  Frame.CONTENT_TYPE, \"text/plain\"),\n              \"Client protocol requirement does not mach versions supported by the server. \" +\n                  \"Supported protocol versions are \" + getSupportedVersionsHeaderLine(sf.connection()))\n      );\n      sf.connection().close();\n      return;\n    }\n\n    // Login / Passcode\n    authenticate(sf.frame(), sf.connection(), ar -> {\n      // Spec says: The server will respond back with the highest version of the protocol -> version\n      sf.connection().write(new Frame(Command.CONNECTED, Headers.create(\n          Frame.VERSION, version,\n          Frame.SERVER, Server.SERVER_NAME,\n          Frame.SESSION, sf.connection().session(),\n          Frame.HEARTBEAT, Frame.Heartbeat.create(sf.connection().server().options().getHeartbeat()).toString()), null));\n    });\n  }\n\n  private void authenticate(Frame frame, StompServerConnection connection,\n                            Handler<AsyncResult<Void>> remainingActions) {\n    if (connection.server().options().isSecured()) {\n      String login = frame.getHeader(Frame.LOGIN);\n      String passcode = frame.getHeader(Frame.PASSCODE);\n\n      connection.handler().onAuthenticationRequest(connection, login, passcode).onComplete(ar -> {\n        if (ar.result()) {\n          remainingActions.handle(Future.succeededFuture());\n        } else {\n          connection.write(Frames.createErrorFrame(\n                  \"Authentication failed\",\n                  Headers.create(\n                      Frame.VERSION, getSupportedVersionsHeaderLine(connection),\n                      Frame.CONTENT_TYPE, \"text/plain\"),\n                  \"The connection frame does not contain valid credentials.\")\n          );\n          connection.close();\n        }\n      });\n    } else {\n      remainingActions.handle(Future.succeededFuture());\n    }\n  }\n\n  private String getSupportedVersionsHeaderLine(StompServerConnection connection) {\n    StringBuilder builder = new StringBuilder();\n    connection.server().options().getSupportedVersions().stream().forEach(\n        v -> builder.append(builder.length() == 0 ? v : FrameParser.COMMA + v));\n    return builder.toString();\n  }\n\n  private String negotiate(List<String> accepted, StompServerConnection connection) {\n    List<String> supported = connection.server().options().getSupportedVersions();\n    for (String v : supported) {\n      if (accepted.contains(v)) {\n        return v;\n      }\n    }\n    return null;\n  }\n}\n", "/*\n *  Copyright (c) 2011-2015 The original author or authors\n *  ------------------------------------------------------\n *  All rights reserved. This program and the accompanying materials\n *  are made available under the terms of the Eclipse Public License v1.0\n *  and Apache License v2.0 which accompanies this distribution.\n *\n *       The Eclipse Public License is available at\n *       http://www.eclipse.org/legal/epl-v10.html\n *\n *       The Apache License v2.0 is available at\n *       http://www.opensource.org/licenses/apache2.0.php\n *\n *  You may elect to redistribute this code under either of these licenses.\n */\n\npackage io.vertx.ext.stomp;\n\nimport javax.net.ssl.SSLSession;\n\nimport io.vertx.codegen.annotations.Fluent;\nimport io.vertx.codegen.annotations.GenIgnore;\nimport io.vertx.codegen.annotations.VertxGen;\nimport io.vertx.core.Handler;\nimport io.vertx.core.buffer.Buffer;\n\n/**\n * Class representing a connection between a STOMP client a the server. It keeps a references on the client socket,\n * so let write to this socket.\n *\n * @author <a href=\"http://escoffier.me\">Clement Escoffier</a>\n */\n@VertxGen\npublic interface StompServerConnection {\n\n  /**\n   * Writes the given frame to the socket.\n   *\n   * @param frame the frame, must not be {@code null}.\n   * @return the current {@link StompServerConnection}\n   */\n  @Fluent\n  StompServerConnection write(Frame frame);\n\n  /**\n   * Writes the given buffer to the socket. This is a low level API that should be used carefully.\n   *\n   * @param buffer the buffer\n   * @return the current {@link StompServerConnection}\n   */\n  @Fluent\n  StompServerConnection write(Buffer buffer);\n\n  /**\n   * @return the STOMP server serving this connection.\n   */\n  StompServer server();\n\n  /**\n   * @return SSLSession associated with the underlying socket. Returns null if connection is\n   *         not SSL.\n   */\n  @GenIgnore({\"permitted-type\"})\n  SSLSession sslSession();\n\n  /**\n   * @return the STOMP server handler dealing with this connection\n   */\n  StompServerHandler handler();\n\n  /**\n   * @return the STOMP session id computed when the client has established the connection to the server\n   */\n  String session();\n\n  /**\n   * Closes the connection with the client.\n   */\n  void close();\n\n  /**\n   * Sends a `PING` frame to the client. A `PING` frame is a frame containing only {@code EOL}.\n   */\n  void ping();\n\n  /**\n   * Notifies the connection about server activity (the server has sent a frame). This method is used to handle the\n   * heartbeat.\n   */\n  void onServerActivity();\n\n  /**\n   * Configures the heartbeat.\n   * @param ping ping time\n   * @param pong pong time\n   * @param pingHandler the ping handler\n   */\n  void configureHeartbeat(long ping, long pong, Handler<StompServerConnection> pingHandler);\n}\n", "/*\n *  Copyright (c) 2011-2015 The original author or authors\n *  ------------------------------------------------------\n *  All rights reserved. This program and the accompanying materials\n *  are made available under the terms of the Eclipse Public License v1.0\n *  and Apache License v2.0 which accompanies this distribution.\n *\n *       The Eclipse Public License is available at\n *       http://www.eclipse.org/legal/epl-v10.html\n *\n *       The Apache License v2.0 is available at\n *       http://www.opensource.org/licenses/apache2.0.php\n *\n *  You may elect to redistribute this code under either of these licenses.\n */\n\npackage io.vertx.ext.stomp.impl;\n\nimport io.vertx.core.AsyncResult;\nimport io.vertx.core.Context;\nimport io.vertx.core.Future;\nimport io.vertx.core.Handler;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.impl.ContextInternal;\nimport io.vertx.core.impl.future.PromiseInternal;\nimport io.vertx.core.impl.logging.Logger;\nimport io.vertx.core.impl.logging.LoggerFactory;\nimport io.vertx.core.shareddata.LocalMap;\nimport io.vertx.ext.auth.User;\nimport io.vertx.ext.auth.authentication.AuthenticationProvider;\nimport io.vertx.ext.auth.authentication.UsernamePasswordCredentials;\nimport io.vertx.ext.stomp.Acknowledgement;\nimport io.vertx.ext.stomp.BridgeOptions;\nimport io.vertx.ext.stomp.DefaultAbortHandler;\nimport io.vertx.ext.stomp.DefaultAckHandler;\nimport io.vertx.ext.stomp.DefaultBeginHandler;\nimport io.vertx.ext.stomp.DefaultCommitHandler;\nimport io.vertx.ext.stomp.DefaultConnectHandler;\nimport io.vertx.ext.stomp.DefaultNackHandler;\nimport io.vertx.ext.stomp.DefaultSendHandler;\nimport io.vertx.ext.stomp.DefaultSubscribeHandler;\nimport io.vertx.ext.stomp.DefaultUnsubscribeHandler;\nimport io.vertx.ext.stomp.Destination;\nimport io.vertx.ext.stomp.DestinationFactory;\nimport io.vertx.ext.stomp.Frame;\nimport io.vertx.ext.stomp.Frames;\nimport io.vertx.ext.stomp.ServerFrame;\nimport io.vertx.ext.stomp.StompServer;\nimport io.vertx.ext.stomp.StompServerConnection;\nimport io.vertx.ext.stomp.StompServerHandler;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * A plug-able implementation of {@link StompServerHandler}. The default behavior is compliant with the STOMP\n * specification.\n * <p/>\n * By default {@code ACK/NACK} are managed as a dead messages. Not acknowledges messages are dropped from the list\n * and a warning is printed in the log.\n * <p/>\n * This class is thread safe.\n *\n * @author <a href=\"http://escoffier.me\">Clement Escoffier</a>\n */\npublic class DefaultStompHandler implements StompServerHandler {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(DefaultStompHandler.class);\n  private final Vertx vertx;\n  private final Context context;\n\n  private Handler<ServerFrame> connectHandler = new DefaultConnectHandler();\n\n  private Handler<ServerFrame> stompHandler;\n\n  private Handler<ServerFrame> sendHandler = new DefaultSendHandler();\n\n  private Handler<ServerFrame> subscribeHandler = new DefaultSubscribeHandler();\n\n  private Handler<ServerFrame> unsubscribeHandler = new DefaultUnsubscribeHandler();\n\n  private Handler<StompServerConnection> closeHandler;\n\n  private Handler<ServerFrame> commitHandler = new DefaultCommitHandler();\n  private Handler<ServerFrame> abortHandler = new DefaultAbortHandler();\n  private Handler<ServerFrame> beginHandler = new DefaultBeginHandler();\n\n  private Handler<ServerFrame> ackHandler = new DefaultAckHandler();\n\n  private Handler<ServerFrame> nackHandler = new DefaultNackHandler();\n\n  private Handler<ServerFrame> disconnectHandler = (sf -> {\n    StompServerConnection connection = sf.connection();\n    Frames.handleReceipt(sf.frame(), connection);\n    connection.close();\n  });\n\n  private AuthenticationProvider authProvider;\n\n  private Handler<StompServerConnection> pingHandler = StompServerConnection::ping;\n\n  private Handler<Acknowledgement> onAckHandler = (acknowledgement) -> LOGGER.info(\"Acknowledge messages - \" +\n      acknowledgement.frames());\n  private Handler<Acknowledgement> onNackHandler = (acknowledgement) ->\n      LOGGER.warn(\"Messages not acknowledge - \" + acknowledgement.frames());\n\n  private final LocalMap<Destination, String> destinations;\n\n  // user is mutable and built from other modules so there's no guarantees\n  // about thread safety so use w/ care..\n  private final ConcurrentHashMap<String, User> users;\n\n  private DestinationFactory factory = Destination::topic;\n\n  private Handler<ServerFrame> receivedFrameHandler;\n\n  /**\n   * Creates a new instance of {@link DefaultStompHandler}.\n   *\n   * @param vertx the vert.x instance\n   */\n  public DefaultStompHandler(Vertx vertx) {\n    this.vertx = vertx;\n    this.context = Vertx.currentContext();\n    this.destinations = vertx.sharedData().getLocalMap(\"stomp.destinations\");\n    this.users = new ConcurrentHashMap<>();\n  }\n\n  @Override\n  public synchronized void onClose(StompServerConnection connection) {\n    // Default behavior.\n    getDestinations().stream().forEach((d) -> d.unsubscribeConnection(connection));\n    Transactions.instance().unregisterTransactionsFromConnection(connection);\n\n    // Remove user, if exists\n    this.users.remove(connection.session());\n\n    if (closeHandler != null) {\n      closeHandler.handle(connection);\n    }\n  }\n\n  @Override\n  public synchronized StompServerHandler receivedFrameHandler(Handler<ServerFrame> handler) {\n    this.receivedFrameHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler connectHandler(Handler<ServerFrame> handler) {\n    this.connectHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler stompHandler(Handler<ServerFrame> handler) {\n    this.stompHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler subscribeHandler(Handler<ServerFrame> handler) {\n    this.subscribeHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler unsubscribeHandler(Handler<ServerFrame> handler) {\n    this.unsubscribeHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler sendHandler(Handler<ServerFrame> handler) {\n    this.sendHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler closeHandler(Handler<StompServerConnection> handler) {\n    this.closeHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler commitHandler(Handler<ServerFrame> handler) {\n    this.commitHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler abortHandler(Handler<ServerFrame> handler) {\n    this.abortHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler beginHandler(Handler<ServerFrame> handler) {\n    this.beginHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler disconnectHandler(Handler<ServerFrame> handler) {\n    this.disconnectHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler ackHandler(Handler<ServerFrame> handler) {\n    this.ackHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler nackHandler(Handler<ServerFrame> handler) {\n    this.nackHandler = handler;\n    return this;\n  }\n\n  @Override\n  public void handle(ServerFrame serverFrame) {\n    Frame frame = serverFrame.frame();\n    StompServerConnection connection = serverFrame.connection();\n    connection.onServerActivity();\n\n    synchronized (this) {\n      if (receivedFrameHandler != null) {\n        receivedFrameHandler.handle(serverFrame);\n      }\n    }\n\n    switch (frame.getCommand()) {\n      case CONNECT:\n        handleConnect(frame, connection);\n        break;\n      case STOMP:\n        handleStomp(frame, connection);\n        break;\n      case SEND:\n        handleSend(frame, connection);\n        break;\n      case SUBSCRIBE:\n        handleSubscribe(frame, connection);\n        break;\n      case UNSUBSCRIBE:\n        handleUnsubscribe(frame, connection);\n        break;\n      case BEGIN:\n        handleBegin(frame, connection);\n        break;\n      case ABORT:\n        handleAbort(frame, connection);\n        break;\n      case COMMIT:\n        handleCommit(frame, connection);\n        break;\n      case ACK:\n        handleAck(frame, connection);\n        break;\n      case NACK:\n        handleNack(frame, connection);\n        break;\n      case DISCONNECT:\n        handleDisconnect(frame, connection);\n        break;\n      case PING:\n        // We received a ping frame, we do nothing.\n        break;\n      default:\n        // Unknown frames\n        break;\n    }\n  }\n\n  private void handleAck(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = ackHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleNack(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = nackHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleBegin(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = beginHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleAbort(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = abortHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleCommit(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = commitHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleSubscribe(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = subscribeHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleUnsubscribe(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = unsubscribeHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleSend(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = sendHandler;\n    }\n\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleConnect(Frame frame, StompServerConnection connection) {\n\n    Handler<ServerFrame> handler;\n    Handler<StompServerConnection> pingH;\n    synchronized (this) {\n      handler = connectHandler;\n      pingH = pingHandler;\n    }\n\n    // Compute heartbeat, and register pinger and ponger\n    // Stomp server acts as a client to call the computePingPeriod & computePongPeriod method\n    long ping = Frame.Heartbeat.computePingPeriod(\n      Frame.Heartbeat.create(connection.server().options().getHeartbeat()),\n      Frame.Heartbeat.parse(frame.getHeader(Frame.HEARTBEAT)));\n    long pong = Frame.Heartbeat.computePongPeriod(\n        Frame.Heartbeat.create(connection.server().options().getHeartbeat()),\n        Frame.Heartbeat.parse(frame.getHeader(Frame.HEARTBEAT)));\n\n    connection.configureHeartbeat(ping, pong, pingH);\n\n    // Then, handle the frame.\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleDisconnect(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = disconnectHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleStomp(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = stompHandler;\n    }\n    if (handler == null) {\n      // Per spec, STOMP frame must be handled as CONNECT\n      handleConnect(frame, connection);\n      return;\n    }\n    handler.handle(new ServerFrameImpl(frame, connection));\n  }\n\n  @Override\n  public synchronized StompServerHandler authProvider(AuthenticationProvider handler) {\n    this.authProvider = handler;\n    return this;\n  }\n\n  @Override\n  public Future<Boolean> onAuthenticationRequest(StompServerConnection connection, String login, String passcode) {\n    PromiseInternal<Boolean> promise = ((ContextInternal) context).promise();\n    onAuthenticationRequest(connection, login, passcode, promise);\n    return promise.future();\n  }\n\n  public StompServerHandler onAuthenticationRequest(StompServerConnection connection,\n                                                    String login, String passcode,\n                                                    Handler<AsyncResult<Boolean>> handler) {\n    final AuthenticationProvider auth;\n    synchronized (this) {\n      // Stack contention.\n      auth = authProvider;\n    }\n\n    final StompServer server = connection.server();\n    if (!server.options().isSecured()) {\n      if (auth != null) {\n        LOGGER.warn(\"Authentication handler set while the server is not secured\");\n      }\n      context.runOnContext(v -> handler.handle(Future.succeededFuture(true)));\n      return this;\n    }\n\n    if (server.options().isSecured() && auth == null) {\n      LOGGER.error(\"Cannot authenticate connection - no authentication provider\");\n      context.runOnContext(v -> handler.handle(Future.succeededFuture(false)));\n      return this;\n    }\n\n    context.runOnContext(v ->\n        auth.authenticate(new UsernamePasswordCredentials(login, passcode))\n          .onFailure(err -> context.runOnContext(v2 -> handler.handle(Future.succeededFuture(false))))\n          .onSuccess(user -> {\n            // make the user available\n            users.put(connection.session(), user);\n            context.runOnContext(v2 -> handler.handle(Future.succeededFuture(true)));\n        }));\n    return this;\n  }\n\n  /**\n   * Return the authenticated user for this session.\n   *\n   * @param session session ID for the server connection.\n   * @return the user provided by the {@link AuthenticationProvider} or null if not found.\n   */\n  @Override\n  public User getUserBySession(String session) {\n    return this.users.get(session);\n  }\n\n  @Override\n  public List<Destination> getDestinations() {\n    return new ArrayList<>(destinations.keySet());\n  }\n\n  /**\n   * Gets the destination with the given name..\n   *\n   * @param destination the destination\n   * @return the {@link Destination}, {@code null} if not found.\n   */\n  public Destination getDestination(String destination) {\n    for (Destination d : destinations.keySet()) {\n      if (d.matches(destination)) {\n        return d;\n      }\n    }\n    return null;\n  }\n\n  public Destination getOrCreateDestination(String destination) {\n    DestinationFactory destinationFactory;\n    synchronized (this) {\n      destinationFactory = this.factory;\n    }\n    synchronized (vertx) {\n      Destination d = getDestination(destination);\n      if (d == null) {\n        d = destinationFactory.create(vertx, destination);\n        if (d != null) {\n          // We use the local map as a set, the value is irrelevant.\n          destinations.put(d, \"\");\n        }\n      }\n      return d;\n    }\n  }\n\n  @Override\n  public synchronized StompServerHandler destinationFactory(DestinationFactory factory) {\n    this.factory = factory;\n    return this;\n  }\n\n  /**\n   * Configures the STOMP server to act as a bridge with the Vert.x event bus.\n   *\n   * @param options the configuration options\n   * @return the current {@link StompServerHandler}.\n   * @see Vertx#eventBus()\n   */\n  @Override\n  public synchronized StompServerHandler bridge(BridgeOptions options) {\n    destinations.put(Destination.bridge(vertx, options), \"\");\n    return this;\n  }\n\n  @Override\n  public StompServerHandler onAck(StompServerConnection connection, Frame subscription, List<Frame> messages) {\n    Handler<Acknowledgement> handler;\n    synchronized (this) {\n      handler = onAckHandler;\n    }\n    if (handler != null) {\n      handler.handle(new AcknowledgementImpl(subscription, messages));\n    }\n    return this;\n  }\n\n  @Override\n  public StompServerHandler onNack(StompServerConnection connection, Frame subscribe, List<Frame> messages) {\n    Handler<Acknowledgement> handler;\n    synchronized (this) {\n      handler = onNackHandler;\n    }\n    if (handler != null) {\n      handler.handle(new AcknowledgementImpl(subscribe, messages));\n    }\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler onAckHandler(Handler<Acknowledgement> handler) {\n    this.onAckHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler onNackHandler(Handler<Acknowledgement> handler) {\n    this.onNackHandler = handler;\n    return this;\n  }\n\n  /**\n   * Allows customizing the action to do when the server needs to send a `PING` to the client. By default it send a\n   * frame containing {@code EOL} (specification). However, you can customize this and send another frame. However,\n   * be aware that this may requires a custom client.\n   * <p/>\n   * The handler will only be called if the connection supports heartbeats.\n   *\n   * @param handler the action to execute when a `PING` needs to be sent.\n   * @return the current {@link StompServerHandler}\n   */\n  @Override\n  public synchronized StompServerHandler pingHandler(Handler<StompServerConnection> handler) {\n    this.pingHandler = handler;\n    return this;\n  }\n\n}\n", "/*\n *  Copyright (c) 2011-2015 The original author or authors\n *  ------------------------------------------------------\n *  All rights reserved. This program and the accompanying materials\n *  are made available under the terms of the Eclipse Public License v1.0\n *  and Apache License v2.0 which accompanies this distribution.\n *\n *       The Eclipse Public License is available at\n *       http://www.eclipse.org/legal/epl-v10.html\n *\n *       The Apache License v2.0 is available at\n *       http://www.opensource.org/licenses/apache2.0.php\n *\n *  You may elect to redistribute this code under either of these licenses.\n */\n\npackage io.vertx.ext.stomp.impl;\n\nimport io.vertx.core.AsyncResult;\nimport io.vertx.core.Future;\nimport io.vertx.core.Handler;\nimport io.vertx.core.Promise;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.http.ServerWebSocket;\nimport io.vertx.core.impl.logging.Logger;\nimport io.vertx.core.impl.logging.LoggerFactory;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.ext.stomp.*;\n\nimport java.util.Objects;\n\n/**\n * Default implementation of the {@link StompServer}.\n *\n * @author <a href=\"http://escoffier.me\">Clement Escoffier</a>\n */\npublic class StompServerImpl implements StompServer {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(StompServerImpl.class);\n\n  private final Vertx vertx;\n  private final StompServerOptions options;\n  private final NetServer server;\n\n  private StompServerHandler handler;\n  private volatile boolean listening;\n\n  private Handler<ServerFrame> writingFrameHandler;\n\n  /**\n   * Creates a new instance of {@link StompServerImpl}.\n   * @param vertx the vert.x instance\n   * @param net the net server, may be {@code null}\n   * @param options the options\n   */\n  public StompServerImpl(Vertx vertx, NetServer net, StompServerOptions options) {\n    Objects.requireNonNull(vertx);\n    Objects.requireNonNull(options);\n    this.options = options;\n    this.vertx = vertx;\n    if (net == null) {\n      server = vertx.createNetServer(options);\n    } else {\n      server = net;\n    }\n  }\n\n  @Override\n  public synchronized StompServer handler(StompServerHandler handler) {\n    Objects.requireNonNull(handler);\n    this.handler = handler;\n    return this;\n  }\n\n  @Override\n  public Future<StompServer> listen() {\n    Promise<StompServer> promise = Promise.promise();\n    listen(promise);\n    return promise.future();\n  }\n\n  public StompServer listen(Handler<AsyncResult<StompServer>> handler) {\n    return listen(options.getPort(), options.getHost(), handler);\n  }\n\n  @Override\n  public Future<StompServer> listen(int port) {\n    return listen(port, StompServerOptions.DEFAULT_STOMP_HOST);\n  }\n\n  @Override\n  public Future<StompServer> listen(int port, String host) {\n    Promise<StompServer> promise = Promise.promise();\n    listen(port, host, promise);\n    return promise.future();\n  }\n\n  public StompServer listen(int port, String host, Handler<AsyncResult<StompServer>> handler) {\n    if (port == -1) {\n      handler.handle(Future.failedFuture(\"TCP server disabled. The port is set to '-1'.\"));\n      return this;\n    }\n    StompServerHandler stomp;\n    synchronized (this) {\n      stomp = this.handler;\n    }\n\n    Objects.requireNonNull(stomp, \"Cannot open STOMP server - no StompServerConnectionHandler attached to the \" +\n        \"server.\");\n    server\n        .connectHandler(socket -> {\n          StompServerConnection connection = new StompServerTCPConnectionImpl(socket, this, writingFrameHandler);\n          FrameParser parser = new FrameParser(options);\n          socket.exceptionHandler((exception) -> {\n            LOGGER.error(\"The STOMP server caught a TCP socket error - closing connection\", exception);\n            connection.close();\n          });\n          socket.endHandler(v -> connection.close());\n          parser\n              .errorHandler((exception) -> {\n                    connection.write(\n                        Frames.createInvalidFrameErrorFrame(exception));\n                    connection.close();\n                  }\n              )\n              .handler(frame -> stomp.handle(new ServerFrameImpl(frame, connection)));\n          socket.handler(parser);\n        })\n        .listen(port, host).onComplete(ar -> {\n          if (ar.failed()) {\n            if (handler != null) {\n              vertx.runOnContext(v -> handler.handle(Future.failedFuture(ar.cause())));\n            } else {\n              LOGGER.error(ar.cause());\n            }\n          } else {\n            listening = true;\n            LOGGER.info(\"STOMP server listening on \" + ar.result().actualPort());\n            if (handler != null) {\n              vertx.runOnContext(v -> handler.handle(Future.succeededFuture(this)));\n            }\n          }\n        });\n    return this;\n  }\n\n  @Override\n  public Future<Void> close() {\n    Promise<Void> promise = Promise.promise();\n    close(promise);\n    return promise.future();\n  }\n\n  @Override\n  public boolean isListening() {\n    return listening;\n  }\n\n  @Override\n  public int actualPort() {\n    return server.actualPort();\n  }\n\n  @Override\n  public StompServerOptions options() {\n    return options;\n  }\n\n  @Override\n  public Vertx vertx() {\n    return vertx;\n  }\n\n  @Override\n  public synchronized StompServerHandler stompHandler() {\n    return handler;\n  }\n\n  public void close(Handler<AsyncResult<Void>> done) {\n    if (!listening) {\n      if (done != null) {\n        vertx.runOnContext((v) -> done.handle(Future.succeededFuture()));\n      }\n      return;\n    }\n\n    Handler<AsyncResult<Void>> listener = (v) -> {\n      if (v.succeeded()) {\n        LOGGER.info(\"STOMP Server stopped\");\n      } else {\n        LOGGER.info(\"STOMP Server failed to stop\", v.cause());\n      }\n\n      listening = false;\n      if (done != null) {\n        done.handle(v);\n      }\n    };\n\n    server.close().onComplete(listener);\n  }\n\n  @Override\n  public Handler<ServerWebSocket> webSocketHandler() {\n    if (!options.isWebsocketBridge()) {\n      return null;\n    }\n\n    StompServerHandler stomp;\n    synchronized (this) {\n      stomp = this.handler;\n    }\n\n    return socket -> {\n      if (!socket.path().equals(options.getWebsocketPath())) {\n        LOGGER.error(\"Receiving a web socket connection on an invalid path (\" + socket.path() + \"), the path is \" +\n            \"configured to \" + options.getWebsocketPath() + \". Rejecting connection\");\n        socket.reject();\n        return;\n      }\n      StompServerConnection connection = new StompServerWebSocketConnectionImpl(socket, this, writingFrameHandler);\n      FrameParser parser = new FrameParser(options);\n      socket.exceptionHandler((exception) -> {\n        LOGGER.error(\"The STOMP server caught a WebSocket error - closing connection\", exception);\n        connection.close();\n      });\n      socket.endHandler(v -> connection.close());\n      parser\n          .errorHandler((exception) -> {\n                connection.write(\n                    Frames.createInvalidFrameErrorFrame(exception));\n                connection.close();\n              }\n          )\n          .handler(frame -> stomp.handle(new ServerFrameImpl(frame, connection)));\n      socket.handler(parser);\n    };\n  }\n\n  @Override\n  public StompServer writingFrameHandler(Handler<ServerFrame> handler) {\n    synchronized (this) {\n      this.writingFrameHandler = handler;\n    }\n    return this;\n  }\n\n\n}\n", "/*\n *  Copyright (c) 2011-2015 The original author or authors\n *  ------------------------------------------------------\n *  All rights reserved. This program and the accompanying materials\n *  are made available under the terms of the Eclipse Public License v1.0\n *  and Apache License v2.0 which accompanies this distribution.\n *\n *       The Eclipse Public License is available at\n *       http://www.eclipse.org/legal/epl-v10.html\n *\n *       The Apache License v2.0 is available at\n *       http://www.opensource.org/licenses/apache2.0.php\n *\n *  You may elect to redistribute this code under either of these licenses.\n */\n\npackage io.vertx.ext.stomp.impl;\n\nimport io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.ext.auth.User;\nimport io.vertx.ext.auth.authentication.AuthenticationProvider;\nimport io.vertx.ext.auth.properties.PropertyFileAuthentication;\nimport io.vertx.ext.stomp.Frame;\nimport io.vertx.ext.stomp.StompClient;\nimport io.vertx.ext.stomp.StompClientOptions;\nimport io.vertx.ext.stomp.StompServer;\nimport io.vertx.ext.stomp.StompServerHandler;\nimport io.vertx.ext.stomp.StompServerOptions;\nimport io.vertx.ext.unit.Async;\nimport io.vertx.ext.unit.TestContext;\nimport io.vertx.ext.unit.junit.RunTestOnContext;\nimport io.vertx.ext.unit.junit.VertxUnitRunner;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\n/**\n * Tests STOMP server with security.\n *\n * @author <a href=\"http://escoffier.me\">Clement Escoffier</a>\n */\n@RunWith(VertxUnitRunner.class)\npublic class SecuredServerConnectionTest {\n  private Vertx vertx;\n  private StompServer server;\n\n  @Rule\n  public RunTestOnContext rule = new RunTestOnContext();\n\n  @Before\n  public void setUp(TestContext context) {\n    vertx = rule.vertx();\n    AuthenticationProvider provider = PropertyFileAuthentication.create(vertx, \"test-auth.properties\");\n    server = StompServer.create(vertx, new StompServerOptions().setSecured(true))\n        .handler(StompServerHandler.create(vertx).authProvider(provider));\n    server.listen().onComplete(context.asyncAssertSuccess());\n  }\n\n  @After\n  public void tearDown(TestContext context) {\n    server.close().onComplete(context.asyncAssertSuccess());\n    // Do not close the vert.x instance when using the RunTestOnContext rule.\n  }\n\n  static String extractSession(String data) {\n    int start = data.indexOf(Frame.SESSION) + Frame.SESSION.length() + 1;\n    int end = data.indexOf('\\n', start);\n    String ret = data.substring(start, end);\n    return ret;\n  }\n\n  @Test\n  public void testAuthenticatedConnection(TestContext context) {\n    Async async = context.async();\n    vertx.createNetClient().connect(server.actualPort(), \"0.0.0.0\").onComplete(result -> {\n      if (result.failed()) {\n        context.fail(\"Connection failed\");\n        return;\n      }\n      NetSocket socket = result.result();\n      socket.handler(buffer -> {\n        validate(context, buffer);\n\n        async.complete();\n      });\n      socket.write(\"CONNECT\\n\" + \"accept-version:1.2\\nlogin:admin\\npasscode:admin\\n\" + \"\\n\" + FrameParser.NULL);\n    });\n  }\n\n  @Test\n  public void testFailedAuthentication(TestContext context) {\n    Async async = context.async();\n    vertx.createNetClient().connect(server.actualPort(), \"0.0.0.0\").onComplete(result -> {\n      if (result.failed()) {\n        context.fail(\"Connection failed\");\n        return;\n      }\n      NetSocket socket = result.result();\n      socket.handler(buffer -> {\n        context.assertTrue(buffer.toString().contains(\"ERROR\"));\n        context.assertTrue(buffer.toString().contains(\"Authentication failed\"));\n        async.complete();\n      });\n      socket.write(\"CONNECT\\n\" + \"accept-version:1.2\\nlogin:admin\\npasscode:nope\\n\" + \"\\n\" + FrameParser.NULL);\n    });\n  }\n\n  @Test(timeout = 5000)\n  public void testFailedAuthenticationBecauseOfMissingHeaders(TestContext context) {\n    Async async = context.async();\n    vertx.createNetClient().connect(server.actualPort(), \"0.0.0.0\").onComplete(result -> {\n      if (result.failed()) {\n        context.fail(\"Connection failed\");\n        return;\n      }\n      NetSocket socket = result.result();\n      socket.handler(buffer -> {\n        context.assertTrue(buffer.toString().contains(\"ERROR\"));\n        context.assertTrue(buffer.toString().contains(\"Authentication failed\"));\n        async.complete();\n      });\n      socket.write(\"CONNECT\\n\" + \"accept-version:1.2\\nlogin:admin\\n\" + \"\\n\" + FrameParser.NULL);\n    });\n  }\n\n  @Test\n  public void testAuthenticatedConnectionWithStompFrame(TestContext context) {\n    Async async = context.async();\n    vertx.createNetClient().connect(server.actualPort(), \"0.0.0.0\").onComplete(result -> {\n      if (result.failed()) {\n        context.fail(\"Connection failed\");\n        return;\n      }\n      NetSocket socket = result.result();\n      socket.handler(buffer -> {\n        validate(context, buffer);\n        async.complete();\n      });\n      socket.write(\"STOMP\\n\" + \"accept-version:1.2\\nlogin:admin\\npasscode:admin\\n\" + \"\\n\" + FrameParser.NULL);\n    });\n  }\n\n  @Test\n  public void testFailedAuthenticationWithClient(TestContext context) {\n    Async async = context.async();\n    StompClient client = StompClient.create(vertx, new StompClientOptions()\n        .setPort(server.actualPort()).setHost(\"0.0.0.0\").setLogin(\"admin\").setPasscode(\"nope\"))\n        .errorFrameHandler(frame -> {\n          async.complete();\n        });\n    client.connect().onComplete(context.asyncAssertFailure());\n  }\n\n  @Test\n  public void testClientConnectRejection(TestContext context) {\n    StompClient.create(vertx).connect(server.actualPort(), \"localhost\").onComplete(context.asyncAssertFailure(err -> {\n    }));\n  }\n\n  void validate(TestContext context, Buffer buffer) {\n    context.assertTrue(buffer.toString().contains(\"CONNECTED\"));\n    context.assertTrue(buffer.toString().contains(\"version:1.2\"));\n\n    User user = server.stompHandler().getUserBySession(extractSession(buffer.toString()));\n    context.assertNotNull(user);\n  }\n\n}\n"], "fixing_code": ["/*\n *  Copyright (c) 2011-2015 The original author or authors\n *  ------------------------------------------------------\n *  All rights reserved. This program and the accompanying materials\n *  are made available under the terms of the Eclipse Public License v1.0\n *  and Apache License v2.0 which accompanies this distribution.\n *\n *       The Eclipse Public License is available at\n *       http://www.eclipse.org/legal/epl-v10.html\n *\n *       The Apache License v2.0 is available at\n *       http://www.opensource.org/licenses/apache2.0.php\n *\n *  You may elect to redistribute this code under either of these licenses.\n */\n\npackage io.vertx.ext.stomp;\n\nimport io.vertx.core.AsyncResult;\nimport io.vertx.core.Future;\nimport io.vertx.core.Handler;\nimport io.vertx.ext.stomp.impl.FrameParser;\nimport io.vertx.ext.stomp.utils.Headers;\nimport io.vertx.ext.stomp.utils.Server;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * STOMP compliant actions executed when receiving a {@code CONNECT} frame. It may also be called when receiving a\n * {@code STOMP} frame depending on the {@link io.vertx.ext.stomp.StompServerHandler} configuration.\n * <p/>\n * This handler manages the STOMP version negotiation and authentication (if enabled). Once all the checks have been\n * passed, the {@code CONNECTED} frame is sent to the client.\n * <p/>\n * This handler is thread safe.\n *\n * @author <a href=\"http://escoffier.me\">Clement Escoffier</a>\n */\npublic class DefaultConnectHandler implements Handler<ServerFrame> {\n\n  @Override\n  public void handle(ServerFrame sf) {\n    // Server negotiation\n    List<String> accepted = new ArrayList<>();\n    String accept = sf.frame().getHeader(Frame.ACCEPT_VERSION);\n    if (accept == null) {\n      accepted.add(\"1.0\");\n    } else {\n      accepted.addAll(Arrays.asList(accept.split(FrameParser.COMMA)));\n    }\n\n    String version = negotiate(accepted, sf.connection());\n    if (version == null) {\n      // Spec says: if the server and the client do not share any common protocol versions, then the server MUST\n      // respond with an error.\n      sf.connection().write(Frames.createErrorFrame(\n              \"Incompatible versions\",\n              Headers.create(\n                  Frame.VERSION, getSupportedVersionsHeaderLine(sf.connection()),\n                  Frame.CONTENT_TYPE, \"text/plain\"),\n              \"Client protocol requirement does not mach versions supported by the server. \" +\n                  \"Supported protocol versions are \" + getSupportedVersionsHeaderLine(sf.connection()))\n      );\n      sf.connection().close();\n      return;\n    }\n\n    // Login / Passcode\n    authenticate(sf.frame(), sf.connection(), ar -> {\n      // Spec says: The server will respond back with the highest version of the protocol -> version\n      sf.connection().write(new Frame(Command.CONNECTED, Headers.create(\n          Frame.VERSION, version,\n          Frame.SERVER, Server.SERVER_NAME,\n          Frame.SESSION, sf.connection().session(),\n          Frame.HEARTBEAT, Frame.Heartbeat.create(sf.connection().server().options().getHeartbeat()).toString()), null));\n    });\n  }\n\n  private void authenticate(Frame frame, StompServerConnection connection,\n                            Handler<AsyncResult<Void>> remainingActions) {\n    if (connection.server().options().isSecured()) {\n      String login = frame.getHeader(Frame.LOGIN);\n      String passcode = frame.getHeader(Frame.PASSCODE);\n\n      connection.handler().onAuthenticationRequest(connection, login, passcode).onComplete(ar -> {\n        if (ar.result()) {\n          remainingActions.handle(Future.succeededFuture());\n        } else {\n          connection.write(Frames.createErrorFrame(\n                  \"Authentication failed\",\n                  Headers.create(\n                      Frame.VERSION, getSupportedVersionsHeaderLine(connection),\n                      Frame.CONTENT_TYPE, \"text/plain\"),\n                  \"The connection frame does not contain valid credentials.\")\n          );\n          connection.close();\n        }\n      });\n    } else {\n      remainingActions.handle(Future.succeededFuture());\n    }\n  }\n\n  private String getSupportedVersionsHeaderLine(StompServerConnection connection) {\n    StringBuilder builder = new StringBuilder();\n    connection.server().options().getSupportedVersions().stream().forEach(\n        v -> builder.append(builder.length() == 0 ? v : FrameParser.COMMA + v));\n    return builder.toString();\n  }\n\n  private String negotiate(List<String> accepted, StompServerConnection connection) {\n    List<String> supported = connection.server().options().getSupportedVersions();\n    for (String v : supported) {\n      if (accepted.contains(v)) {\n        return v;\n      }\n    }\n    return null;\n  }\n}\n", "/*\n *  Copyright (c) 2011-2015 The original author or authors\n *  ------------------------------------------------------\n *  All rights reserved. This program and the accompanying materials\n *  are made available under the terms of the Eclipse Public License v1.0\n *  and Apache License v2.0 which accompanies this distribution.\n *\n *       The Eclipse Public License is available at\n *       http://www.eclipse.org/legal/epl-v10.html\n *\n *       The Apache License v2.0 is available at\n *       http://www.opensource.org/licenses/apache2.0.php\n *\n *  You may elect to redistribute this code under either of these licenses.\n */\n\npackage io.vertx.ext.stomp;\n\nimport javax.net.ssl.SSLSession;\n\nimport io.vertx.codegen.annotations.Fluent;\nimport io.vertx.codegen.annotations.GenIgnore;\nimport io.vertx.codegen.annotations.VertxGen;\nimport io.vertx.core.Handler;\nimport io.vertx.core.buffer.Buffer;\n\n/**\n * Class representing a connection between a STOMP client a the server. It keeps a references on the client socket,\n * so let write to this socket.\n *\n * @author <a href=\"http://escoffier.me\">Clement Escoffier</a>\n */\n@VertxGen\npublic interface StompServerConnection {\n\n  /**\n   * Writes the given frame to the socket.\n   *\n   * @param frame the frame, must not be {@code null}.\n   * @return the current {@link StompServerConnection}\n   */\n  @Fluent\n  StompServerConnection write(Frame frame);\n\n  /**\n   * Writes the given buffer to the socket. This is a low level API that should be used carefully.\n   *\n   * @param buffer the buffer\n   * @return the current {@link StompServerConnection}\n   */\n  @Fluent\n  StompServerConnection write(Buffer buffer);\n\n  /**\n   * @return the STOMP server serving this connection.\n   */\n  StompServer server();\n\n  /**\n   * @return SSLSession associated with the underlying socket. Returns null if connection is\n   *         not SSL.\n   */\n  @GenIgnore({\"permitted-type\"})\n  SSLSession sslSession();\n\n  /**\n   * @return the STOMP server handler dealing with this connection\n   */\n  StompServerHandler handler();\n\n  /**\n   * @return the STOMP session id computed when the client has established the connection to the server\n   */\n  String session();\n\n  /**\n   * Closes the connection with the client.\n   */\n  void close();\n\n  /**\n   * Sends a `PING` frame to the client. A `PING` frame is a frame containing only {@code EOL}.\n   */\n  void ping();\n\n  /**\n   * Notifies the connection about server activity (the server has sent a frame). This method is used to handle the\n   * heartbeat.\n   */\n  void onServerActivity();\n\n  /**\n   * Configures the heartbeat.\n   * @param ping ping time\n   * @param pong pong time\n   * @param pingHandler the ping handler\n   */\n  void configureHeartbeat(long ping, long pong, Handler<StompServerConnection> pingHandler);\n\n}\n", "/*\n *  Copyright (c) 2011-2015 The original author or authors\n *  ------------------------------------------------------\n *  All rights reserved. This program and the accompanying materials\n *  are made available under the terms of the Eclipse Public License v1.0\n *  and Apache License v2.0 which accompanies this distribution.\n *\n *       The Eclipse Public License is available at\n *       http://www.eclipse.org/legal/epl-v10.html\n *\n *       The Apache License v2.0 is available at\n *       http://www.opensource.org/licenses/apache2.0.php\n *\n *  You may elect to redistribute this code under either of these licenses.\n */\n\npackage io.vertx.ext.stomp.impl;\n\nimport io.vertx.core.AsyncResult;\nimport io.vertx.core.Context;\nimport io.vertx.core.Future;\nimport io.vertx.core.Handler;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.impl.ContextInternal;\nimport io.vertx.core.impl.future.PromiseInternal;\nimport io.vertx.core.impl.logging.Logger;\nimport io.vertx.core.impl.logging.LoggerFactory;\nimport io.vertx.core.shareddata.LocalMap;\nimport io.vertx.ext.auth.User;\nimport io.vertx.ext.auth.authentication.AuthenticationProvider;\nimport io.vertx.ext.auth.authentication.UsernamePasswordCredentials;\nimport io.vertx.ext.stomp.Acknowledgement;\nimport io.vertx.ext.stomp.BridgeOptions;\nimport io.vertx.ext.stomp.DefaultAbortHandler;\nimport io.vertx.ext.stomp.DefaultAckHandler;\nimport io.vertx.ext.stomp.DefaultBeginHandler;\nimport io.vertx.ext.stomp.DefaultCommitHandler;\nimport io.vertx.ext.stomp.DefaultConnectHandler;\nimport io.vertx.ext.stomp.DefaultNackHandler;\nimport io.vertx.ext.stomp.DefaultSendHandler;\nimport io.vertx.ext.stomp.DefaultSubscribeHandler;\nimport io.vertx.ext.stomp.DefaultUnsubscribeHandler;\nimport io.vertx.ext.stomp.Destination;\nimport io.vertx.ext.stomp.DestinationFactory;\nimport io.vertx.ext.stomp.Frame;\nimport io.vertx.ext.stomp.Frames;\nimport io.vertx.ext.stomp.ServerFrame;\nimport io.vertx.ext.stomp.StompServer;\nimport io.vertx.ext.stomp.StompServerConnection;\nimport io.vertx.ext.stomp.StompServerHandler;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * A plug-able implementation of {@link StompServerHandler}. The default behavior is compliant with the STOMP\n * specification.\n * <p/>\n * By default {@code ACK/NACK} are managed as a dead messages. Not acknowledges messages are dropped from the list\n * and a warning is printed in the log.\n * <p/>\n * This class is thread safe.\n *\n * @author <a href=\"http://escoffier.me\">Clement Escoffier</a>\n */\npublic class DefaultStompHandler implements StompServerHandler {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(DefaultStompHandler.class);\n  private final Vertx vertx;\n  private final Context context;\n\n  private Handler<ServerFrame> connectHandler;\n\n  private Handler<ServerFrame> stompHandler;\n\n  private Handler<ServerFrame> sendHandler = new DefaultSendHandler();\n\n  private Handler<ServerFrame> subscribeHandler = new DefaultSubscribeHandler();\n\n  private Handler<ServerFrame> unsubscribeHandler = new DefaultUnsubscribeHandler();\n\n  private Handler<StompServerConnection> closeHandler;\n\n  private Handler<ServerFrame> commitHandler = new DefaultCommitHandler();\n  private Handler<ServerFrame> abortHandler = new DefaultAbortHandler();\n  private Handler<ServerFrame> beginHandler = new DefaultBeginHandler();\n\n  private Handler<ServerFrame> ackHandler = new DefaultAckHandler();\n\n  private Handler<ServerFrame> nackHandler = new DefaultNackHandler();\n\n  private Handler<ServerFrame> disconnectHandler = (sf -> {\n    StompServerConnection connection = sf.connection();\n    Frames.handleReceipt(sf.frame(), connection);\n    connection.close();\n  });\n\n  private AuthenticationProvider authProvider;\n\n  private Handler<StompServerConnection> pingHandler = StompServerConnection::ping;\n\n  private Handler<Acknowledgement> onAckHandler = (acknowledgement) -> LOGGER.info(\"Acknowledge messages - \" +\n      acknowledgement.frames());\n  private Handler<Acknowledgement> onNackHandler = (acknowledgement) ->\n      LOGGER.warn(\"Messages not acknowledge - \" + acknowledgement.frames());\n\n  private final LocalMap<Destination, String> destinations;\n\n  // user is mutable and built from other modules so there's no guarantees\n  // about thread safety so use w/ care..\n  private final ConcurrentHashMap<String, User> users;\n\n  private DestinationFactory factory = Destination::topic;\n\n  private Handler<ServerFrame> receivedFrameHandler;\n\n  /**\n   * Creates a new instance of {@link DefaultStompHandler}.\n   *\n   * @param vertx the vert.x instance\n   */\n  public DefaultStompHandler(Vertx vertx) {\n    this.vertx = vertx;\n    this.context = Vertx.currentContext();\n    this.destinations = vertx.sharedData().getLocalMap(\"stomp.destinations\");\n    this.users = new ConcurrentHashMap<>();\n    this.connectHandler = new DefaultConnectHandler();\n  }\n\n  @Override\n  public synchronized void onClose(StompServerConnection connection) {\n    // Default behavior.\n    getDestinations().stream().forEach((d) -> d.unsubscribeConnection(connection));\n    Transactions.instance().unregisterTransactionsFromConnection(connection);\n\n    // Remove user, if exists\n    this.users.remove(connection.session());\n\n    if (closeHandler != null) {\n      closeHandler.handle(connection);\n    }\n  }\n\n  @Override\n  public synchronized StompServerHandler receivedFrameHandler(Handler<ServerFrame> handler) {\n    this.receivedFrameHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler connectHandler(Handler<ServerFrame> handler) {\n    this.connectHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler stompHandler(Handler<ServerFrame> handler) {\n    this.stompHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler subscribeHandler(Handler<ServerFrame> handler) {\n    this.subscribeHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler unsubscribeHandler(Handler<ServerFrame> handler) {\n    this.unsubscribeHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler sendHandler(Handler<ServerFrame> handler) {\n    this.sendHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler closeHandler(Handler<StompServerConnection> handler) {\n    this.closeHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler commitHandler(Handler<ServerFrame> handler) {\n    this.commitHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler abortHandler(Handler<ServerFrame> handler) {\n    this.abortHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler beginHandler(Handler<ServerFrame> handler) {\n    this.beginHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler disconnectHandler(Handler<ServerFrame> handler) {\n    this.disconnectHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler ackHandler(Handler<ServerFrame> handler) {\n    this.ackHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler nackHandler(Handler<ServerFrame> handler) {\n    this.nackHandler = handler;\n    return this;\n  }\n\n  @Override\n  public void handle(ServerFrame serverFrame) {\n    Frame frame = serverFrame.frame();\n    StompServerConnection connection = serverFrame.connection();\n    connection.onServerActivity();\n\n    synchronized (this) {\n      if (receivedFrameHandler != null) {\n        receivedFrameHandler.handle(serverFrame);\n      }\n    }\n\n    switch (frame.getCommand()) {\n      case CONNECT:\n        handleConnect(frame, connection);\n        break;\n      case STOMP:\n        handleStomp(frame, connection);\n        break;\n      case SEND:\n        handleSend(frame, connection);\n        break;\n      case SUBSCRIBE:\n        handleSubscribe(frame, connection);\n        break;\n      case UNSUBSCRIBE:\n        handleUnsubscribe(frame, connection);\n        break;\n      case BEGIN:\n        handleBegin(frame, connection);\n        break;\n      case ABORT:\n        handleAbort(frame, connection);\n        break;\n      case COMMIT:\n        handleCommit(frame, connection);\n        break;\n      case ACK:\n        handleAck(frame, connection);\n        break;\n      case NACK:\n        handleNack(frame, connection);\n        break;\n      case DISCONNECT:\n        handleDisconnect(frame, connection);\n        break;\n      case PING:\n        // We received a ping frame, we do nothing.\n        break;\n      default:\n        // Unknown frames\n        break;\n    }\n  }\n\n  private void handleAck(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = ackHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleNack(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = nackHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleBegin(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = beginHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleAbort(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = abortHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleCommit(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = commitHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleSubscribe(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = subscribeHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleUnsubscribe(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = unsubscribeHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleSend(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = sendHandler;\n    }\n\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleConnect(Frame frame, StompServerConnection connection) {\n\n    Handler<ServerFrame> handler;\n    Handler<StompServerConnection> pingH;\n    synchronized (this) {\n      handler = connectHandler;\n      pingH = pingHandler;\n    }\n\n    // Compute heartbeat, and register pinger and ponger\n    // Stomp server acts as a client to call the computePingPeriod & computePongPeriod method\n    long ping = Frame.Heartbeat.computePingPeriod(\n      Frame.Heartbeat.create(connection.server().options().getHeartbeat()),\n      Frame.Heartbeat.parse(frame.getHeader(Frame.HEARTBEAT)));\n    long pong = Frame.Heartbeat.computePongPeriod(\n        Frame.Heartbeat.create(connection.server().options().getHeartbeat()),\n        Frame.Heartbeat.parse(frame.getHeader(Frame.HEARTBEAT)));\n\n    connection.configureHeartbeat(ping, pong, pingH);\n\n    // Then, handle the frame.\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleDisconnect(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = disconnectHandler;\n    }\n    if (handler != null) {\n      handler.handle(new ServerFrameImpl(frame, connection));\n    }\n  }\n\n  private void handleStomp(Frame frame, StompServerConnection connection) {\n    Handler<ServerFrame> handler;\n    synchronized (this) {\n      handler = stompHandler;\n    }\n    if (handler == null) {\n      // Per spec, STOMP frame must be handled as CONNECT\n      handleConnect(frame, connection);\n      return;\n    }\n    handler.handle(new ServerFrameImpl(frame, connection));\n  }\n\n  @Override\n  public synchronized StompServerHandler authProvider(AuthenticationProvider handler) {\n    this.authProvider = handler;\n    return this;\n  }\n\n  @Override\n  public Future<Boolean> onAuthenticationRequest(StompServerConnection connection, String login, String passcode) {\n    PromiseInternal<Boolean> promise = ((ContextInternal) context).promise();\n    onAuthenticationRequest(connection, login, passcode, promise);\n    return promise.future();\n  }\n\n  public StompServerHandler onAuthenticationRequest(StompServerConnection connection,\n                                                    String login, String passcode,\n                                                    Handler<AsyncResult<Boolean>> handler) {\n    final AuthenticationProvider auth;\n    synchronized (this) {\n      // Stack contention.\n      auth = authProvider;\n    }\n\n    final StompServer server = connection.server();\n    if (!server.options().isSecured()) {\n      if (auth != null) {\n        LOGGER.warn(\"Authentication handler set while the server is not secured\");\n      }\n      context.runOnContext(v -> handler.handle(Future.succeededFuture(true)));\n      return this;\n    }\n\n    if (server.options().isSecured() && auth == null) {\n      LOGGER.error(\"Cannot authenticate connection - no authentication provider\");\n      context.runOnContext(v -> handler.handle(Future.succeededFuture(false)));\n      return this;\n    }\n\n    context.runOnContext(v ->\n        auth.authenticate(new UsernamePasswordCredentials(login, passcode))\n          .onFailure(err -> context.runOnContext(v2 -> handler.handle(Future.succeededFuture(false))))\n          .onSuccess(user -> {\n            // make the user available\n            users.put(connection.session(), user);\n            context.runOnContext(v2 -> handler.handle(Future.succeededFuture(true)));\n        }));\n    return this;\n  }\n\n  /**\n   * Return the authenticated user for this session.\n   *\n   * @param session session ID for the server connection.\n   * @return the user provided by the {@link AuthenticationProvider} or null if not found.\n   */\n  @Override\n  public User getUserBySession(String session) {\n    return this.users.get(session);\n  }\n\n  @Override\n  public List<Destination> getDestinations() {\n    return new ArrayList<>(destinations.keySet());\n  }\n\n  /**\n   * Gets the destination with the given name..\n   *\n   * @param destination the destination\n   * @return the {@link Destination}, {@code null} if not found.\n   */\n  public Destination getDestination(String destination) {\n    for (Destination d : destinations.keySet()) {\n      if (d.matches(destination)) {\n        return d;\n      }\n    }\n    return null;\n  }\n\n  public Destination getOrCreateDestination(String destination) {\n    DestinationFactory destinationFactory;\n    synchronized (this) {\n      destinationFactory = this.factory;\n    }\n    synchronized (vertx) {\n      Destination d = getDestination(destination);\n      if (d == null) {\n        d = destinationFactory.create(vertx, destination);\n        if (d != null) {\n          // We use the local map as a set, the value is irrelevant.\n          destinations.put(d, \"\");\n        }\n      }\n      return d;\n    }\n  }\n\n  @Override\n  public synchronized StompServerHandler destinationFactory(DestinationFactory factory) {\n    this.factory = factory;\n    return this;\n  }\n\n  /**\n   * Configures the STOMP server to act as a bridge with the Vert.x event bus.\n   *\n   * @param options the configuration options\n   * @return the current {@link StompServerHandler}.\n   * @see Vertx#eventBus()\n   */\n  @Override\n  public synchronized StompServerHandler bridge(BridgeOptions options) {\n    destinations.put(Destination.bridge(vertx, options), \"\");\n    return this;\n  }\n\n  @Override\n  public StompServerHandler onAck(StompServerConnection connection, Frame subscription, List<Frame> messages) {\n    Handler<Acknowledgement> handler;\n    synchronized (this) {\n      handler = onAckHandler;\n    }\n    if (handler != null) {\n      handler.handle(new AcknowledgementImpl(subscription, messages));\n    }\n    return this;\n  }\n\n  @Override\n  public StompServerHandler onNack(StompServerConnection connection, Frame subscribe, List<Frame> messages) {\n    Handler<Acknowledgement> handler;\n    synchronized (this) {\n      handler = onNackHandler;\n    }\n    if (handler != null) {\n      handler.handle(new AcknowledgementImpl(subscribe, messages));\n    }\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler onAckHandler(Handler<Acknowledgement> handler) {\n    this.onAckHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized StompServerHandler onNackHandler(Handler<Acknowledgement> handler) {\n    this.onNackHandler = handler;\n    return this;\n  }\n\n  /**\n   * Allows customizing the action to do when the server needs to send a `PING` to the client. By default it send a\n   * frame containing {@code EOL} (specification). However, you can customize this and send another frame. However,\n   * be aware that this may requires a custom client.\n   * <p/>\n   * The handler will only be called if the connection supports heartbeats.\n   *\n   * @param handler the action to execute when a `PING` needs to be sent.\n   * @return the current {@link StompServerHandler}\n   */\n  @Override\n  public synchronized StompServerHandler pingHandler(Handler<StompServerConnection> handler) {\n    this.pingHandler = handler;\n    return this;\n  }\n\n}\n", "/*\n *  Copyright (c) 2011-2015 The original author or authors\n *  ------------------------------------------------------\n *  All rights reserved. This program and the accompanying materials\n *  are made available under the terms of the Eclipse Public License v1.0\n *  and Apache License v2.0 which accompanies this distribution.\n *\n *       The Eclipse Public License is available at\n *       http://www.eclipse.org/legal/epl-v10.html\n *\n *       The Apache License v2.0 is available at\n *       http://www.opensource.org/licenses/apache2.0.php\n *\n *  You may elect to redistribute this code under either of these licenses.\n */\n\npackage io.vertx.ext.stomp.impl;\n\nimport io.vertx.core.AsyncResult;\nimport io.vertx.core.Future;\nimport io.vertx.core.Handler;\nimport io.vertx.core.Promise;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.http.ServerWebSocket;\nimport io.vertx.core.impl.logging.Logger;\nimport io.vertx.core.impl.logging.LoggerFactory;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.ext.stomp.*;\n\nimport java.util.Collections;\nimport java.util.Objects;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n * Default implementation of the {@link StompServer}.\n *\n * @author <a href=\"http://escoffier.me\">Clement Escoffier</a>\n */\npublic class StompServerImpl implements StompServer {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(StompServerImpl.class);\n\n  private final Vertx vertx;\n  private final StompServerOptions options;\n  private final NetServer server;\n\n  private StompServerHandler handler;\n  private volatile boolean listening;\n\n  private Handler<ServerFrame> writingFrameHandler;\n\n  /**\n   * Creates a new instance of {@link StompServerImpl}.\n   * @param vertx the vert.x instance\n   * @param net the net server, may be {@code null}\n   * @param options the options\n   */\n  public StompServerImpl(Vertx vertx, NetServer net, StompServerOptions options) {\n    Objects.requireNonNull(vertx);\n    Objects.requireNonNull(options);\n    this.options = options;\n    this.vertx = vertx;\n    if (net == null) {\n      server = vertx.createNetServer(options);\n    } else {\n      server = net;\n    }\n  }\n\n  @Override\n  public synchronized StompServer handler(StompServerHandler handler) {\n    Objects.requireNonNull(handler);\n    this.handler = handler;\n    return this;\n  }\n\n  @Override\n  public Future<StompServer> listen() {\n    Promise<StompServer> promise = Promise.promise();\n    listen(promise);\n    return promise.future();\n  }\n\n  public StompServer listen(Handler<AsyncResult<StompServer>> handler) {\n    return listen(options.getPort(), options.getHost(), handler);\n  }\n\n  @Override\n  public Future<StompServer> listen(int port) {\n    return listen(port, StompServerOptions.DEFAULT_STOMP_HOST);\n  }\n\n  @Override\n  public Future<StompServer> listen(int port, String host) {\n    Promise<StompServer> promise = Promise.promise();\n    listen(port, host, promise);\n    return promise.future();\n  }\n\n  public StompServer listen(int port, String host, Handler<AsyncResult<StompServer>> handler) {\n    if (port == -1) {\n      handler.handle(Future.failedFuture(\"TCP server disabled. The port is set to '-1'.\"));\n      return this;\n    }\n    StompServerHandler stomp;\n    synchronized (this) {\n      stomp = this.handler;\n    }\n\n    Objects.requireNonNull(stomp, \"Cannot open STOMP server - no StompServerConnectionHandler attached to the \" +\n        \"server.\");\n    server\n        .connectHandler(socket -> {\n          AtomicBoolean connected = new AtomicBoolean();\n          AtomicBoolean firstFrame = new AtomicBoolean();\n          StompServerConnection connection = new StompServerTCPConnectionImpl(socket, this, frame -> {\n            if (frame.frame().getCommand() == Command.CONNECTED) {\n              connected.set(true);\n            }\n            Handler<ServerFrame> h = writingFrameHandler;\n            if (h != null) {\n              h.handle(frame);\n            }\n          });\n          FrameParser parser = new FrameParser(options);\n          socket.exceptionHandler((exception) -> {\n            LOGGER.error(\"The STOMP server caught a TCP socket error - closing connection\", exception);\n            connection.close();\n          });\n          socket.endHandler(v -> connection.close());\n          parser\n              .errorHandler((exception) -> {\n                    connection.write(\n                        Frames.createInvalidFrameErrorFrame(exception));\n                    connection.close();\n                  }\n              )\n              .handler(frame -> {\n                if (frame.getCommand() == Command.CONNECT || frame.getCommand() == Command.STOMP) {\n                  if (firstFrame.compareAndSet(false, true)) {\n                    stomp.handle(new ServerFrameImpl(frame, connection));\n                  } else {\n                    connection.write(Frames.createErrorFrame(\"Already connected\", Collections.emptyMap(), \"\"));\n                    connection.close();\n                  }\n                } else if (connected.get()) {\n                  stomp.handle(new ServerFrameImpl(frame, connection));\n                } else {\n                  connection.write(Frames.createErrorFrame(\"Not connected\", Collections.emptyMap(), \"\"));\n                  connection.close();\n                }\n              });\n          socket.handler(parser);\n        })\n        .listen(port, host).onComplete(ar -> {\n          if (ar.failed()) {\n            if (handler != null) {\n              vertx.runOnContext(v -> handler.handle(Future.failedFuture(ar.cause())));\n            } else {\n              LOGGER.error(ar.cause());\n            }\n          } else {\n            listening = true;\n            LOGGER.info(\"STOMP server listening on \" + ar.result().actualPort());\n            if (handler != null) {\n              vertx.runOnContext(v -> handler.handle(Future.succeededFuture(this)));\n            }\n          }\n        });\n    return this;\n  }\n\n  @Override\n  public Future<Void> close() {\n    Promise<Void> promise = Promise.promise();\n    close(promise);\n    return promise.future();\n  }\n\n  @Override\n  public boolean isListening() {\n    return listening;\n  }\n\n  @Override\n  public int actualPort() {\n    return server.actualPort();\n  }\n\n  @Override\n  public StompServerOptions options() {\n    return options;\n  }\n\n  @Override\n  public Vertx vertx() {\n    return vertx;\n  }\n\n  @Override\n  public synchronized StompServerHandler stompHandler() {\n    return handler;\n  }\n\n  public void close(Handler<AsyncResult<Void>> done) {\n    if (!listening) {\n      if (done != null) {\n        vertx.runOnContext((v) -> done.handle(Future.succeededFuture()));\n      }\n      return;\n    }\n\n    Handler<AsyncResult<Void>> listener = (v) -> {\n      if (v.succeeded()) {\n        LOGGER.info(\"STOMP Server stopped\");\n      } else {\n        LOGGER.info(\"STOMP Server failed to stop\", v.cause());\n      }\n\n      listening = false;\n      if (done != null) {\n        done.handle(v);\n      }\n    };\n\n    server.close().onComplete(listener);\n  }\n\n  @Override\n  public Handler<ServerWebSocket> webSocketHandler() {\n    if (!options.isWebsocketBridge()) {\n      return null;\n    }\n\n    StompServerHandler stomp;\n    synchronized (this) {\n      stomp = this.handler;\n    }\n\n    return socket -> {\n      if (!socket.path().equals(options.getWebsocketPath())) {\n        LOGGER.error(\"Receiving a web socket connection on an invalid path (\" + socket.path() + \"), the path is \" +\n            \"configured to \" + options.getWebsocketPath() + \". Rejecting connection\");\n        socket.reject();\n        return;\n      }\n      AtomicBoolean connected = new AtomicBoolean();\n      AtomicBoolean firstFrame = new AtomicBoolean();\n      StompServerConnection connection = new StompServerWebSocketConnectionImpl(socket, this, frame -> {\n        if (frame.frame().getCommand() == Command.CONNECTED  || frame.frame().getCommand() == Command.STOMP) {\n          connected.set(true);\n        }\n        Handler<ServerFrame> h = writingFrameHandler;\n        if (h != null) {\n          h.handle(frame);\n        }\n      });\n      FrameParser parser = new FrameParser(options);\n      socket.exceptionHandler((exception) -> {\n        LOGGER.error(\"The STOMP server caught a WebSocket error - closing connection\", exception);\n        connection.close();\n      });\n      socket.endHandler(v -> connection.close());\n      parser\n          .errorHandler((exception) -> {\n                connection.write(\n                    Frames.createInvalidFrameErrorFrame(exception));\n                connection.close();\n              }\n          )\n          .handler(frame -> {\n            if (frame.getCommand() == Command.CONNECT) {\n              if (firstFrame.compareAndSet(false, true)) {\n                stomp.handle(new ServerFrameImpl(frame, connection));\n              } else {\n                connection.write(Frames.createErrorFrame(\"Already connected\", Collections.emptyMap(), \"\"));\n                connection.close();\n              }\n            } else if (connected.get()) {\n              stomp.handle(new ServerFrameImpl(frame, connection));\n            } else {\n              connection.write(Frames.createErrorFrame(\"Not connected\", Collections.emptyMap(), \"\"));\n              connection.close();\n            }\n          });\n      socket.handler(parser);\n    };\n  }\n\n  @Override\n  public StompServer writingFrameHandler(Handler<ServerFrame> handler) {\n    synchronized (this) {\n      this.writingFrameHandler = handler;\n    }\n    return this;\n  }\n\n\n}\n", "/*\n *  Copyright (c) 2011-2015 The original author or authors\n *  ------------------------------------------------------\n *  All rights reserved. This program and the accompanying materials\n *  are made available under the terms of the Eclipse Public License v1.0\n *  and Apache License v2.0 which accompanies this distribution.\n *\n *       The Eclipse Public License is available at\n *       http://www.eclipse.org/legal/epl-v10.html\n *\n *       The Apache License v2.0 is available at\n *       http://www.opensource.org/licenses/apache2.0.php\n *\n *  You may elect to redistribute this code under either of these licenses.\n */\n\npackage io.vertx.ext.stomp.impl;\n\nimport io.vertx.core.Future;\nimport io.vertx.core.Handler;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.http.HttpClient;\nimport io.vertx.core.http.HttpServer;\nimport io.vertx.core.http.HttpServerOptions;\nimport io.vertx.core.net.NetClient;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.ext.auth.User;\nimport io.vertx.ext.auth.authentication.AuthenticationProvider;\nimport io.vertx.ext.auth.properties.PropertyFileAuthentication;\nimport io.vertx.ext.stomp.Frame;\nimport io.vertx.ext.stomp.StompClient;\nimport io.vertx.ext.stomp.StompClientOptions;\nimport io.vertx.ext.stomp.StompServer;\nimport io.vertx.ext.stomp.StompServerHandler;\nimport io.vertx.ext.stomp.StompServerOptions;\nimport io.vertx.ext.unit.Async;\nimport io.vertx.ext.unit.TestContext;\nimport io.vertx.ext.unit.junit.RunTestOnContext;\nimport io.vertx.ext.unit.junit.VertxUnitRunner;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\nimport java.util.Arrays;\n\n/**\n * Tests STOMP server with security.\n *\n * @author <a href=\"http://escoffier.me\">Clement Escoffier</a>\n */\n@RunWith(VertxUnitRunner.class)\npublic class SecuredServerConnectionTest {\n\n  private Vertx vertx;\n  private StompServer server;\n  private HttpServer wsServer;\n  private HttpClient wsClient;\n  private StompClient client;\n\n  @Rule\n  public RunTestOnContext rule = new RunTestOnContext();\n\n  @Before\n  public void setUp(TestContext context) {\n    vertx = rule.vertx();\n    AuthenticationProvider provider = PropertyFileAuthentication.create(vertx, \"test-auth.properties\");\n    server = StompServer.create(vertx, new StompServerOptions()\n        .setSecured(true)\n        .setWebsocketBridge(true)\n        .setWebsocketPath(\"/stomp\"))\n      .handler(StompServerHandler.create(vertx).authProvider(provider));\n    server.listen(StompServerOptions.DEFAULT_STOMP_PORT).onComplete(context.asyncAssertSuccess());\n    wsServer = vertx.createHttpServer(new HttpServerOptions().setWebSocketSubProtocols(Arrays.asList(\"v10.stomp\", \"v11.stomp\")))\n      .webSocketHandler(server.webSocketHandler());\n    wsServer.listen(8080).onComplete(context.asyncAssertSuccess());\n    wsClient = vertx.createHttpClient();\n    client = StompClient.create(vertx, new StompClientOptions().setLogin(\"admin\").setPasscode(\"admin\"));\n  }\n\n  @After\n  public void tearDown(TestContext context) {\n    server.close().onComplete(context.asyncAssertSuccess());\n    // Do not close the vert.x instance when using the RunTestOnContext rule.\n  }\n\n  static String extractSession(String data) {\n    int start = data.indexOf(Frame.SESSION) + Frame.SESSION.length() + 1;\n    int end = data.indexOf('\\n', start);\n    String ret = data.substring(start, end);\n    return ret;\n  }\n\n  @Test\n  public void testAuthenticatedConnection(TestContext context) {\n    Async async = context.async();\n    vertx.createNetClient().connect(server.actualPort(), \"0.0.0.0\").onComplete(result -> {\n      if (result.failed()) {\n        context.fail(\"Connection failed\");\n        return;\n      }\n      NetSocket socket = result.result();\n      socket.handler(buffer -> {\n        validate(context, buffer);\n\n        async.complete();\n      });\n      socket.write(\"CONNECT\\n\" + \"accept-version:1.2\\nlogin:admin\\npasscode:admin\\n\" + \"\\n\" + FrameParser.NULL);\n    });\n  }\n\n  @Test\n  public void testFailedAuthentication(TestContext context) {\n    Async async = context.async();\n    vertx.createNetClient().connect(server.actualPort(), \"0.0.0.0\").onComplete(result -> {\n      if (result.failed()) {\n        context.fail(\"Connection failed\");\n        return;\n      }\n      NetSocket socket = result.result();\n      socket.handler(buffer -> {\n        context.assertTrue(buffer.toString().contains(\"ERROR\"));\n        context.assertTrue(buffer.toString().contains(\"Authentication failed\"));\n        async.complete();\n      });\n      socket.write(\"CONNECT\\n\" + \"accept-version:1.2\\nlogin:admin\\npasscode:nope\\n\" + \"\\n\" + FrameParser.NULL);\n    });\n  }\n\n  @Test(timeout = 5000)\n  public void testFailedAuthenticationBecauseOfMissingHeaders(TestContext context) {\n    Async async = context.async();\n    vertx.createNetClient().connect(server.actualPort(), \"0.0.0.0\").onComplete(result -> {\n      if (result.failed()) {\n        context.fail(\"Connection failed\");\n        return;\n      }\n      NetSocket socket = result.result();\n      socket.handler(buffer -> {\n        context.assertTrue(buffer.toString().contains(\"ERROR\"));\n        context.assertTrue(buffer.toString().contains(\"Authentication failed\"));\n        async.complete();\n      });\n      socket.write(\"CONNECT\\n\" + \"accept-version:1.2\\nlogin:admin\\n\" + \"\\n\" + FrameParser.NULL);\n    });\n  }\n\n  @Test\n  public void testAuthenticatedConnectionWithStompFrame(TestContext context) {\n    Async async = context.async();\n    vertx.createNetClient().connect(server.actualPort(), \"0.0.0.0\").onComplete(result -> {\n      if (result.failed()) {\n        context.fail(\"Connection failed\");\n        return;\n      }\n      NetSocket socket = result.result();\n      socket.handler(buffer -> {\n        validate(context, buffer);\n        async.complete();\n      });\n      socket.write(\"STOMP\\n\" + \"accept-version:1.2\\nlogin:admin\\npasscode:admin\\n\" + \"\\n\" + FrameParser.NULL);\n    });\n  }\n\n  @Test\n  public void testFailedAuthenticationWithClient(TestContext context) {\n    Async async = context.async();\n    StompClient client = StompClient.create(vertx, new StompClientOptions()\n        .setPort(server.actualPort()).setHost(\"0.0.0.0\").setLogin(\"admin\").setPasscode(\"nope\"))\n        .errorFrameHandler(frame -> {\n          async.complete();\n        });\n    client.connect().onComplete(context.asyncAssertFailure());\n  }\n\n  @Test\n  public void testClientConnectRejection(TestContext context) {\n    StompClient.create(vertx).connect(server.actualPort(), \"localhost\").onComplete(context.asyncAssertFailure(err -> {\n    }));\n  }\n\n  void validate(TestContext context, Buffer buffer) {\n    context.assertTrue(buffer.toString().contains(\"CONNECTED\"), \"Was expected <\" + buffer.toString() + \"> to contain 'CONNECTED'\");\n    context.assertTrue(buffer.toString().contains(\"version:1.2\"));\n\n    User user = server.stompHandler().getUserBySession(extractSession(buffer.toString()));\n    context.assertNotNull(user);\n  }\n\n  @Test\n  public void testTCPClientMustBeConnected(TestContext context) {\n    Async async = context.async();\n    NetClient client = vertx.createNetClient();\n    testClientMustBeConnected(context, v -> {\n      client.connect(server.actualPort(), \"0.0.0.0\").onComplete(context.asyncAssertSuccess(so -> {\n        Buffer received = Buffer.buffer();\n        so.handler(received::appendBuffer);\n        so.write(\n          \"SEND\\n\" +\n            \"destination:/test\\n\" +\n            \"\\n\" +\n            \"hello\" +\n            FrameParser.NULL);\n        so.endHandler(v2 -> {\n          context.assertTrue(received.toString().startsWith(\"ERROR\\n\"));\n          async.complete();\n        });\n      }));\n    });\n  }\n\n  @Test\n  public void testWebSocketClientMustBeConnected(TestContext context) {\n    Async async = context.async();\n    testClientMustBeConnected(context, v -> {\n      wsClient.webSocket(8080, \"localhost\", \"/stomp\").onComplete(context.asyncAssertSuccess(ws -> {\n        Buffer received = Buffer.buffer();\n        ws.binaryMessageHandler(received::appendBuffer);\n        ws.writeBinaryMessage(\n          Buffer.buffer(\"SEND\\n\" +\n            \"destination:/test\\n\" +\n            \"\\n\" +\n            \"hello\" +\n            FrameParser.NULL));\n        ws.endHandler(v2 -> {\n          context.assertTrue(received.toString().startsWith(\"ERROR\\n\"));\n          async.complete();\n        });\n      }));\n    });\n  }\n\n  private void testClientMustBeConnected(TestContext context, Handler<Void> cont) {\n    client\n      .connect(server.actualPort(), \"localhost\")\n      .onComplete(context.asyncAssertSuccess(conn -> {\n        Future<String> fut = conn.subscribe(\"/test\", frame -> {\n          context.fail(\"Should not receive a messsage\");\n        });\n        fut.onComplete(context.asyncAssertSuccess(v2 -> {\n          cont.handle(null);\n        }));\n      }));\n  }\n}\n"], "filenames": ["src/main/java/io/vertx/ext/stomp/DefaultConnectHandler.java", "src/main/java/io/vertx/ext/stomp/StompServerConnection.java", "src/main/java/io/vertx/ext/stomp/impl/DefaultStompHandler.java", "src/main/java/io/vertx/ext/stomp/impl/StompServerImpl.java", "src/test/java/io/vertx/ext/stomp/impl/SecuredServerConnectionTest.java"], "buggy_code_start_loc": [41, 98, 73, 29, 18], "buggy_code_end_loc": [41, 98, 127, 236, 171], "fixing_code_start_loc": [42, 99, 73, 30, 19], "fixing_code_end_loc": [43, 100, 129, 286, 247], "type": "CWE-287", "message": "Vert.x STOMP is a vert.x implementation of the STOMP specification that provides a STOMP server and client. From versions 3.1.0 until 3.9.16 and 4.0.0 until 4.4.2, a Vert.x STOMP server processes client STOMP frames without checking that the client send an initial CONNECT frame replied with a successful CONNECTED frame. The client can subscribe to a destination or publish message without prior authentication. Any Vert.x STOMP server configured with an authentication handler is impacted. The issue is patched in Vert.x 3.9.16 and 4.4.2. There are no trivial workarounds.", "other": {"cve": {"id": "CVE-2023-32081", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-12T14:15:10.140", "lastModified": "2023-05-24T15:22:06.790", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vert.x STOMP is a vert.x implementation of the STOMP specification that provides a STOMP server and client. From versions 3.1.0 until 3.9.16 and 4.0.0 until 4.4.2, a Vert.x STOMP server processes client STOMP frames without checking that the client send an initial CONNECT frame replied with a successful CONNECTED frame. The client can subscribe to a destination or publish message without prior authentication. Any Vert.x STOMP server configured with an authentication handler is impacted. The issue is patched in Vert.x 3.9.16 and 4.4.2. There are no trivial workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:vert.x_stomp:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1.0", "versionEndExcluding": "3.9.16", "matchCriteriaId": "6AAF6003-F2E2-4C50-96E0-DF3D7D71472C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:vert.x_stomp:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.4.2", "matchCriteriaId": "98B500B9-4D40-451A-ABE0-D704F4102B30"}]}]}], "references": [{"url": "https://github.com/vert-x3/vertx-stomp/commit/0de4bc5a44ddb57e74d92c445f16456fa03f265b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vert-x3/vertx-stomp/security/advisories/GHSA-gvrq-cg5r-7chp", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/vert-x3/vertx-stomp/commit/0de4bc5a44ddb57e74d92c445f16456fa03f265b"}}