{"buggy_code": ["package CGI::Simple;\n\nrequire 5.004;\n\n# this module is both strict (and warnings) compliant, but they are only used\n# in testing as they add an unnecessary compile time overhead in production.\nuse strict;\nuse Carp;\n\nuse vars qw(\n $VERSION $USE_CGI_PM_DEFAULTS $DISABLE_UPLOADS $POST_MAX\n $NO_UNDEF_PARAMS $USE_PARAM_SEMICOLONS $PARAM_UTF8 $HEADERS_ONCE\n $NPH $DEBUG $NO_NULL $FATAL *in\n);\n\n$VERSION = \"1.113\";\n\n# you can hard code the global variable settings here if you want.\n# warning - do not delete the unless defined $VAR part unless you\n# want to permanently remove the ability to change the variable.\nsub _initialize_globals {\n\n  # set this to 1 to use CGI.pm default global settings\n  $USE_CGI_PM_DEFAULTS = 0\n   unless defined $USE_CGI_PM_DEFAULTS;\n\n  # see if user wants old CGI.pm defaults\n  if ( $USE_CGI_PM_DEFAULTS ) {\n    _use_cgi_pm_global_settings();\n    return;\n  }\n\n  # no file uploads by default, set to 0 to enable uploads\n  $DISABLE_UPLOADS = 1\n   unless defined $DISABLE_UPLOADS;\n\n  # use a post max of 100K, set to -1 for no limits\n  $POST_MAX = 102_400\n   unless defined $POST_MAX;\n\n  # set to 1 to not include undefined params parsed from query string\n  $NO_UNDEF_PARAMS = 0\n   unless defined $NO_UNDEF_PARAMS;\n\n  # separate the name=value pairs with ; rather than &\n  $USE_PARAM_SEMICOLONS = 0\n   unless defined $USE_PARAM_SEMICOLONS;\n\n  # return everything as utf-8\n  $PARAM_UTF8 ||= 0;\n  $PARAM_UTF8 and require Encode;\n\n  # only print headers once\n  $HEADERS_ONCE = 0\n   unless defined $HEADERS_ONCE;\n\n  # Set this to 1 to enable NPH scripts\n  $NPH = 0\n   unless defined $NPH;\n\n  # 0 => no debug, 1 => from @ARGV,  2 => from STDIN\n  $DEBUG = 0\n   unless defined $DEBUG;\n\n  # filter out null bytes in param - value pairs\n  $NO_NULL = 1\n   unless defined $NO_NULL;\n\n# set behavior when cgi_err() called -1 => silent, 0 => carp, 1 => croak\n  $FATAL = -1\n   unless defined $FATAL;\n}\n\n# I happen to disagree with many of the default global settings in CGI.pm\n# This sub is called if you set $CGI::Simple::USE_CGI_PM_GLOBALS = 1; or\n# invoke the '-default' pragma via a use CGI::Simple qw(-default);\nsub _use_cgi_pm_global_settings {\n  $USE_CGI_PM_DEFAULTS  = 1;\n  $DISABLE_UPLOADS      = 0 unless defined $DISABLE_UPLOADS;\n  $POST_MAX             = -1 unless defined $POST_MAX;\n  $NO_UNDEF_PARAMS      = 0 unless defined $NO_UNDEF_PARAMS;\n  $USE_PARAM_SEMICOLONS = 1 unless defined $USE_PARAM_SEMICOLONS;\n  $HEADERS_ONCE         = 0 unless defined $HEADERS_ONCE;\n  $NPH                  = 0 unless defined $NPH;\n  $DEBUG                = 1 unless defined $DEBUG;\n  $NO_NULL              = 0 unless defined $NO_NULL;\n  $FATAL                = -1 unless defined $FATAL;\n  $PARAM_UTF8           = 0 unless defined $PARAM_UTF8;\n}\n\n# this is called by new, we will never directly reference the globals again\nsub _store_globals {\n  my $self = shift;\n\n  $self->{'.globals'}->{'DISABLE_UPLOADS'}      = $DISABLE_UPLOADS;\n  $self->{'.globals'}->{'POST_MAX'}             = $POST_MAX;\n  $self->{'.globals'}->{'NO_UNDEF_PARAMS'}      = $NO_UNDEF_PARAMS;\n  $self->{'.globals'}->{'USE_PARAM_SEMICOLONS'} = $USE_PARAM_SEMICOLONS;\n  $self->{'.globals'}->{'HEADERS_ONCE'}         = $HEADERS_ONCE;\n  $self->{'.globals'}->{'NPH'}                  = $NPH;\n  $self->{'.globals'}->{'DEBUG'}                = $DEBUG;\n  $self->{'.globals'}->{'NO_NULL'}              = $NO_NULL;\n  $self->{'.globals'}->{'FATAL'}                = $FATAL;\n  $self->{'.globals'}->{'USE_CGI_PM_DEFAULTS'}  = $USE_CGI_PM_DEFAULTS;\n  $self->{'.globals'}->{'PARAM_UTF8'}           = $PARAM_UTF8;\n}\n\n# use the automatic calling of the import sub to set our pragmas. CGI.pm compat\nsub import {\n  my ( $self, @args ) = @_;\n\n# arguments supplied in the 'use CGI::Simple [ARGS];' will now be in @args\n  foreach ( @args ) {\n    $USE_CGI_PM_DEFAULTS = 1, next if m/^-default/i;\n    $DISABLE_UPLOADS     = 1, next if m/^-no.?upload/i;\n    $DISABLE_UPLOADS     = 0, next if m/^-upload/i;\n    $HEADERS_ONCE        = 1, next if m/^-unique.?header/i;\n    $NPH                 = 1, next if m/^-nph/i;\n    $DEBUG               = 0, next if m/^-no.?debug/i;\n    $DEBUG = defined $1 ? $1 : 2, next if m/^-debug(\\d)?/i;\n    $USE_PARAM_SEMICOLONS = 1, next if m/^-newstyle.?url/i;\n    $USE_PARAM_SEMICOLONS = 0, next if m/^-oldstyle.?url/i;\n    $NO_UNDEF_PARAMS      = 1, next if m/^-no.?undef.?param/i;\n    $FATAL                = 0, next if m/^-carp/i;\n    $FATAL                = 1, next if m/^-croak/i;\n    croak \"Pragma '$_' is not defined in CGI::Simple\\n\";\n  }\n}\n\n# used in CGI.pm .t files\nsub _reset_globals {\n  _use_cgi_pm_global_settings();\n}\n\nbinmode STDIN;\nbinmode STDOUT;\n\n# use correct encoding conversion to handle non ASCII char sets.\n# we import and install the complex routines only if we have to.\nBEGIN {\n\n  sub url_decode {\n    my ( $self, $decode ) = @_;\n    return () unless defined $decode;\n    $decode =~ tr/+/ /;\n    $decode =~ s/%([a-fA-F0-9]{2})/ pack \"C\", hex $1 /eg;\n    return $decode;\n  }\n\n  sub url_encode {\n    my ( $self, $encode ) = @_;\n    return () unless defined $encode;\n    $encode\n     =~ s/([^A-Za-z0-9\\-_.!~*'() ])/ uc sprintf \"%%%02x\",ord $1 /eg;\n    $encode =~ tr/ /+/;\n    return $encode;\n  }\n\n  if ( \"\\t\" ne \"\\011\" ) {\n    eval { require CGI::Simple::Util };\n    if ( $@ ) {\n      croak\n       \"Your server is using not using ASCII, you must install CGI::Simple::Util, error: $@\";\n    }\n\n    # hack the symbol table and replace simple encode/decode subs\n    *CGI::Simple::url_encode\n     = sub { CGI::Simple::Util::escape( $_[1] ) };\n    *CGI::Simple::url_decode\n     = sub { CGI::Simple::Util::unescape( $_[1] ) };\n  }\n}\n\n################ The Guts ################\n\nsub new {\n  my ( $class, $init ) = @_;\n  $class = ref( $class ) || $class;\n  my $self = {};\n  bless $self, $class;\n  if ( $self->_mod_perl ) {\n    if ( $init ) {\n      $self->{'.mod_perl_request'} = $init;\n      undef $init;    # otherwise _initialize takes the wrong path\n    }\n    $self->_initialize_mod_perl();\n  }\n  $self->_initialize_globals;\n  $self->_store_globals;\n  $self->_initialize( $init );\n  return $self;\n}\n\nsub _mod_perl {\n  return (\n    exists $ENV{MOD_PERL}\n     or ( $ENV{GATEWAY_INTERFACE}\n      and $ENV{GATEWAY_INTERFACE} =~ m{^CGI-Perl/} )\n  );\n}\n\n# Return the global request object under mod_perl. If you use mod_perl 2\n# and you don't set PerlOptions +GlobalRequest then the request must be\n# passed in to the new() method.\nsub _mod_perl_request {\n  my $self = shift;\n\n  my $mp = $self->{'.mod_perl'};\n\n  return unless $mp;\n\n  my $req = $self->{'.mod_perl_request'};\n  return $req if $req;\n\n  $self->{'.mod_perl_request'} = do {\n    if ( $mp == 2 ) {\n      Apache2::RequestUtil->request;\n    }\n    else {\n      Apache->request;\n    }\n  };\n}\n\nsub _initialize_mod_perl {\n  my ( $self ) = @_;\n\n  eval \"require mod_perl\";\n\n  if ( defined $mod_perl::VERSION ) {\n\n    if ( $mod_perl::VERSION >= 2.00 ) {\n      $self->{'.mod_perl'} = 2;\n\n      require Apache2::RequestRec;\n      require Apache2::RequestIO;\n      require Apache2::RequestUtil;\n      require Apache2::Response;\n      require APR::Pool;\n\n      my $r = $self->_mod_perl_request();\n\n      if ( defined $r ) {\n        $r->subprocess_env unless exists $ENV{REQUEST_METHOD};\n        $r->pool->cleanup_register(\n          \\&CGI::Simple::_initialize_globals );\n      }\n    }\n    else {\n      $self->{'.mod_perl'} = 1;\n\n      require Apache;\n\n      my $r = $self->_mod_perl_request();\n\n      if ( defined $r ) {\n        $r->register_cleanup( \\&CGI::Simple::_initialize_globals );\n      }\n    }\n  }\n}\n\nsub _initialize {\n  my ( $self, $init ) = @_;\n\n  if ( !defined $init ) {\n\n    # initialize from QUERY_STRING, STDIN or @ARGV\n    $self->_read_parse();\n  }\n  elsif ( ( ref $init ) =~ m/HASH/i ) {\n\n    # initialize from param hash\n    for my $param ( keys %{$init} ) {\n      $self->_add_param( $param, $init->{$param} );\n    }\n  }\n\n  # chromatic's blessed GLOB patch\n  # elsif ( (ref $init) =~ m/GLOB/i ) { # initialize from a file\n  elsif ( UNIVERSAL::isa( $init, 'GLOB' ) ) {   # initialize from a file\n    $self->_read_parse( $init );\n  }\n  elsif ( ( ref $init ) eq 'CGI::Simple' ) {\n\n    # initialize from a CGI::Simple object\n    require Data::Dumper;\n\n    # avoid problems with strict when Data::Dumper returns $VAR1\n    my $VAR1;\n    my $clone = eval( Data::Dumper::Dumper( $init ) );\n    if ( $@ ) {\n      $self->cgi_error( \"Can't clone CGI::Simple object: $@\" );\n    }\n    else {\n      $_[0] = $clone;\n    }\n  }\n  else {\n    $self->_parse_params( $init );    # initialize from a query string\n  }\n}\n\nsub _internal_read($*\\$;$) {\n  my ( $self, $glob, $buffer, $len ) = @_;\n  $len = 4096 if !defined $len;\n  if ( $self->{'.mod_perl'} ) {\n    my $r = $self->_mod_perl_request();\n    $r->read( $$buffer, $len );\n  }\n  else {\n    read( $glob, $$buffer, $len );\n  }\n}\n\nsub _read_parse {\n  my $self = shift;\n  my $handle = shift || \\*STDIN;\n\n  my $data   = '';\n  my $type   = $ENV{'CONTENT_TYPE'} || 'No CONTENT_TYPE received';\n  my $length = $ENV{'CONTENT_LENGTH'} || 0;\n  my $method = $ENV{'REQUEST_METHOD'} || 'No REQUEST_METHOD received';\n\n  # first check POST_MAX Steve Purkis pointed out the previous bug\n  if (  ( $method eq 'POST' or $method eq \"PUT\" )\n    and $self->{'.globals'}->{'POST_MAX'} != -1\n    and $length > $self->{'.globals'}->{'POST_MAX'} ) {\n    $self->cgi_error(\n      \"413 Request entity too large: $length bytes on STDIN exceeds \\$POST_MAX!\"\n    );\n\n    # silently discard data ??? better to just close the socket ???\n    while ( $length > 0 ) {\n      last unless _internal_read( $self, $handle, my $buffer );\n      $length -= length( $buffer );\n    }\n\n    return;\n  }\n\n  if ( $length and $type =~ m|^multipart/form-data|i ) {\n    my $got_length = $self->_parse_multipart( $handle );\n    if ( $length != $got_length ) {\n      $self->cgi_error(\n        \"500 Bad read on multipart/form-data! wanted $length, got $got_length\"\n      );\n    }\n\n    return;\n  }\n  elsif ( $method eq 'POST' or $method eq 'PUT' ) {\n    if ( $length ) {\n\n      # we may not get all the data we want with a single read on large\n      # POSTs as it may not be here yet! Credit Jason Luther for patch\n      # CGI.pm < 2.99 suffers from same bug\n      _internal_read( $self, $handle, $data, $length );\n      while ( length( $data ) < $length ) {\n        last unless _internal_read( $self, $handle, my $buffer );\n        $data .= $buffer;\n      }\n\n      unless ( $length == length $data ) {\n        $self->cgi_error( \"500 Bad read on POST! wanted $length, got \"\n           . length( $data ) );\n        return;\n      }\n\n      if ( $type !~ m|^application/x-www-form-urlencoded| ) {\n        $self->_add_param( $method . \"DATA\", $data );\n      }\n      else {\n        $self->_parse_params( $data );\n      }\n    }\n  }\n  elsif ( $method eq 'GET' or $method eq 'HEAD' ) {\n    $data\n     = $self->{'.mod_perl'}\n     ? $self->_mod_perl_request()->args()\n     : $ENV{'QUERY_STRING'}\n     || $ENV{'REDIRECT_QUERY_STRING'}\n     || '';\n    $self->_parse_params( $data );\n  }\n  else {\n    unless ( $self->{'.globals'}->{'DEBUG'}\n      and $data = $self->read_from_cmdline() ) {\n      $self->cgi_error( \"400 Unknown method $method\" );\n      return;\n    }\n\n    unless ( $data ) {\n\n# I liked this reporting but CGI.pm does not behave like this so\n# out it goes......\n# $self->cgi_error(\"400 No data received via method: $method, type: $type\");\n      return;\n    }\n\n    $self->_parse_params( $data );\n  }\n}\n\nsub _parse_params {\n  my ( $self, $data ) = @_;\n  return () unless defined $data;\n  unless ( $data =~ /[&=;]/ ) {\n    $self->{'keywords'} = [ $self->_parse_keywordlist( $data ) ];\n    return;\n  }\n  my @pairs = split /[&;]/, $data;\n  for my $pair ( @pairs ) {\n    my ( $param, $value ) = split /=/, $pair, 2;\n    next unless defined $param;\n    $value = '' unless defined $value;\n    $self->_add_param( $self->url_decode( $param ),\n      $self->url_decode( $value ) );\n  }\n}\n\nsub _add_param {\n  my ( $self, $param, $value, $overwrite ) = @_;\n  return () unless defined $param and defined $value;\n  $param =~ tr/\\000//d if $self->{'.globals'}->{'NO_NULL'};\n  @{ $self->{$param} } = () if $overwrite;\n  @{ $self->{$param} } = () unless exists $self->{$param};\n  my @values = ref $value ? @{$value} : ( $value );\n  for my $value ( @values ) {\n    next\n     if $value eq ''\n       and $self->{'.globals'}->{'NO_UNDEF_PARAMS'};\n    $value =~ tr/\\000//d if $self->{'.globals'}->{'NO_NULL'};\n    $value = Encode::decode( utf8 => $value )\n     if $self->{'.globals'}->{PARAM_UTF8};\n    push @{ $self->{$param} }, $value;\n    unless ( $self->{'.fieldnames'}->{$param} ) {\n      push @{ $self->{'.parameters'} }, $param;\n      $self->{'.fieldnames'}->{$param}++;\n    }\n  }\n  return scalar @values;    # for compatibility with CGI.pm request.t\n}\n\nsub _parse_keywordlist {\n  my ( $self, $data ) = @_;\n  return () unless defined $data;\n  $data = $self->url_decode( $data );\n  $data =~ tr/\\000//d if $self->{'.globals'}->{'NO_NULL'};\n  my @keywords = split /\\s+/, $data;\n  return @keywords;\n}\n\nsub _massage_boundary {\n  my ( $self, $boundary ) = @_;\n\n  # BUG: IE 3.01 on the Macintosh uses just the boundary,\n  # forgetting the --\n  $boundary = '--' . $boundary\n   unless exists $ENV{'HTTP_USER_AGENT'}\n     && $ENV{'HTTP_USER_AGENT'} =~ m/MSIE\\s+3\\.0[12];\\s*Mac/i;\n\n  return quotemeta $boundary;\n}\n\nsub _parse_multipart {\n  my $self = shift;\n  my $handle = shift or die \"NEED A HANDLE!?\";\n\n  my ( $boundary )\n   = $ENV{'CONTENT_TYPE'} =~ /boundary=\\\"?([^\\\";,]+)\\\"?/;\n\n  $boundary = $self->_massage_boundary( $boundary ) if $boundary;\n\n  my $got_data = 0;\n  my $data     = '';\n  my $length   = $ENV{'CONTENT_LENGTH'} || 0;\n  my $CRLF     = $self->crlf;\n\n  READ:\n\n  while ( $got_data < $length ) {\n    last READ unless _internal_read( $self, $handle, my $buffer );\n    $data .= $buffer;\n    $got_data += length $buffer;\n\n    unless ( $boundary ) {\n      # If we're going to guess the boundary we need a complete line.\n      next READ unless $data =~ /^(.*)$CRLF/o;\n      $boundary = $1;\n\n      # Still no boundary? Give up...\n      unless ( $boundary ) {\n        $self->cgi_error(\n          '400 No boundary supplied for multipart/form-data' );\n        return 0;\n      }\n      $boundary = $self->_massage_boundary( $boundary );\n    }\n\n    BOUNDARY:\n\n    while ( $data =~ m/^$boundary$CRLF/ ) {\n      ## TAB and high ascii chars are definitivelly allowed in headers.\n      ## Not accepting them in the following regex prevents the upload of\n      ## files with filenames like \"Espa\u0144a.txt\".\n      # next READ unless $data =~ m/^([\\040-\\176$CRLF]+?$CRLF$CRLF)/o;\n      next READ\n       unless $data =~ m/^([\\x20-\\x7E\\x80-\\xFF\\x09$CRLF]+?$CRLF$CRLF)/o;\n      my $header = $1;\n      ( my $unfold = $1 ) =~ s/$CRLF\\s+/ /og;\n      my ( $param ) = $unfold =~ m/form-data;\\s+name=\"?([^\\\";]*)\"?/;\n      my ( $filename )\n       = $unfold =~ m/name=\"?\\Q$param\\E\"?;\\s+filename=\"?([^\\\"]*)\"?/;\n\n      if ( defined $filename ) {\n        my ( $mime ) = $unfold =~ m/Content-Type:\\s+([-\\w\\+\\.\\/]+)/io;\n        $data =~ s/^\\Q$header\\E//;\n        ( $got_data, $data, my $fh, my $size )\n         = $self->_save_tmpfile( $handle, $boundary, $filename,\n          $got_data, $data );\n        $self->_add_param( $param, $filename );\n        $self->{'.upload_fields'}->{$param} = $filename;\n        $self->{'.filehandles'}->{$filename} = $fh if $fh;\n        $self->{'.tmpfiles'}->{$filename}\n         = { 'size' => $size, 'mime' => $mime }\n         if $size;\n        next BOUNDARY;\n      }\n      next READ\n       unless $data =~ s/^\\Q$header\\E(.*?)$CRLF(?=$boundary)//s;\n      $self->_add_param( $param, $1 );\n    }\n    unless ( $data =~ m/^$boundary/ ) {\n      ## In a perfect world, $data should always begin with $boundary.\n      ## But sometimes, IE5 prepends garbage boundaries into POST(ed) data.\n      ## Then, $data does not start with $boundary and the previous block\n      ## never gets executed. The following fix attempts to remove those\n      ## extra boundaries from readed $data and restart boundary parsing.\n      ## Note about performance: with well formed data, previous check is\n      ## executed (generally) only once, when $data value is \"$boundary--\"\n      ## at end of parsing.\n      goto BOUNDARY if ( $data =~ s/.*?$CRLF(?=$boundary$CRLF)//s );\n    }\n  }\n  return $got_data;\n}\n\nsub _save_tmpfile {\n  my ( $self, $handle, $boundary, $filename, $got_data, $data ) = @_;\n  my $fh;\n  my $CRLF      = $self->crlf;\n  my $length    = $ENV{'CONTENT_LENGTH'} || 0;\n  my $file_size = 0;\n  if ( $self->{'.globals'}->{'DISABLE_UPLOADS'} ) {\n    $self->cgi_error( \"405 Not Allowed - File uploads are disabled\" );\n  }\n  elsif ( $filename ) {\n    eval { require IO::File };\n    $self->cgi_error( \"500 IO::File is not available $@\" ) if $@;\n    $fh = new_tmpfile IO::File;\n    $self->cgi_error( \"500 IO::File can't create new temp_file\" )\n     unless $fh;\n  }\n\n# read in data until closing boundary found. buffer to catch split boundary\n# we do this regardless of whether we save the file or not to read the file\n# data from STDIN. if either uploads are disabled or no file has been sent\n# $fh will be undef so only do file stuff if $fh is true using $fh && syntax\n  $fh && binmode $fh;\n  while ( $got_data < $length ) {\n\n    my $buffer = $data;\n    last unless _internal_read( $self, \\*STDIN, $data );\n\n    # fixed hanging bug if browser terminates upload part way through\n    # thanks to Brandon Black\n    unless ( $data ) {\n      $self->cgi_error(\n        '400 Malformed multipart, no terminating boundary' );\n      undef $fh;\n      return $got_data;\n    }\n\n    $got_data += length $data;\n    if ( \"$buffer$data\" =~ m/$boundary/ ) {\n      $data = $buffer . $data;\n      last;\n    }\n\n    # we do not have partial boundary so print to file if valid $fh\n    $fh && print $fh $buffer;\n    $file_size += length $buffer;\n  }\n  $data =~ s/^(.*?)$CRLF(?=$boundary)//s;\n  $fh && print $fh $1;    # print remainder of file if valid $fh\n  $file_size += length $1;\n  return $got_data, $data, $fh, $file_size;\n}\n\n# Define the CRLF sequence.  You can't use a simple \"\\r\\n\" because of system\n# specific 'features'. On EBCDIC systems \"\\t\" ne \"\\011\" as the don't use ASCII\nsub crlf {\n  my ( $self, $CRLF ) = @_;\n  $self->{'.crlf'} = $CRLF if $CRLF;    # allow value to be set manually\n  unless ( $self->{'.crlf'} ) {\n    my $OS = $^O\n     || do { require Config; $Config::Config{'osname'} };\n    $self->{'.crlf'}\n     = ( $OS =~ m/VMS/i ) ? \"\\n\"\n     : ( \"\\t\" ne \"\\011\" ) ? \"\\r\\n\"\n     :                      \"\\015\\012\";\n  }\n  return $self->{'.crlf'};\n}\n\n################ The Core Methods ################\n\nsub param {\n  my ( $self, $param, @p ) = @_;\n  unless ( defined $param ) {    # return list of all params\n    my @params\n     = $self->{'.parameters'} ? @{ $self->{'.parameters'} } : ();\n    return @params;\n  }\n  unless ( @p ) {                # return values for $param\n    return () unless exists $self->{$param};\n    return wantarray ? @{ $self->{$param} } : $self->{$param}->[0];\n  }\n  if ( $param =~ m/^-name$/i and @p == 1 ) {\n    return () unless exists $self->{ $p[0] };\n    return wantarray ? @{ $self->{ $p[0] } } : $self->{ $p[0] }->[0];\n  }\n\n  # set values using -name=>'foo',-value=>'bar' syntax.\n  # also allows for $q->param( 'foo', 'some', 'new', 'values' ) syntax\n  ( $param, undef, @p ) = @p\n   if $param =~ m/^-name$/i;     # undef represents -value token\n  $self->_add_param( $param, ( ref $p[0] eq 'ARRAY' ? $p[0] : [@p] ),\n    'overwrite' );\n  return wantarray ? @{ $self->{$param} } : $self->{$param}->[0];\n}\n\n# a new method that provides access to a new internal routine. Useage:\n# $q->add_param( $param, $value, $overwrite )\n# $param must be a plain scalar\n# $value may be either a scalar or an array ref\n# if $overwrite is a true value $param will be overwritten with new values.\nsub add_param {\n  _add_param( @_ );\n}\n\nsub param_fetch {\n  my ( $self, $param, @p ) = @_;\n  $param\n   = ( defined $param and $param =~ m/^-name$/i ) ? $p[0] : $param;\n  return undef unless defined $param;\n  $self->_add_param( $param, [] ) unless exists $self->{$param};\n  return $self->{$param};\n}\n\n# Return a parameter in the QUERY_STRING, regardless of whether a POST or GET\nsub url_param {\n  my ( $self, $param ) = @_;\n  return () unless $ENV{'QUERY_STRING'};\n  $self->{'.url_param'} = {};\n  bless $self->{'.url_param'}, 'CGI::Simple';\n  $self->{'.url_param'}->_parse_params( $ENV{'QUERY_STRING'} );\n  return $self->{'.url_param'}->param( $param );\n}\n\nsub keywords {\n  my ( $self, @values ) = @_;\n  $self->{'keywords'}\n   = ref $values[0] eq 'ARRAY' ? $values[0] : [@values]\n   if @values;\n  my @result\n   = defined( $self->{'keywords'} ) ? @{ $self->{'keywords'} } : ();\n  return @result;\n}\n\nsub Vars {\n  my $self = shift;\n  $self->{'.sep'} = shift || $self->{'.sep'} || \"\\0\";\n  if ( wantarray ) {\n    my %hash;\n    for my $param ( $self->param ) {\n      $hash{$param} = join $self->{'.sep'}, $self->param( $param );\n    }\n    return %hash;\n  }\n  else {\n    my %tied;\n    tie %tied, \"CGI::Simple\", $self;\n    return \\%tied;\n  }\n}\n\nsub TIEHASH { $_[1] ? $_[1] : new $_[0] }\n\nsub STORE {\n  my ( $q, $p, $v ) = @_;\n  $q->param( $p, split $q->{'.sep'}, $v );\n}\n\nsub FETCH {\n  my ( $q, $p ) = @_;\n  ref $q->{$p} eq \"ARRAY\" ? join $q->{'.sep'}, @{ $q->{$p} } : $q->{$p};\n}\nsub FIRSTKEY { my $a = scalar keys %{ $_[0] }; each %{ $_[0] } }\nsub NEXTKEY { each %{ $_[0] } }\nsub EXISTS  { exists $_[0]->{ $_[1] } }\nsub DELETE  { $_[0]->delete( $_[1] ) }\nsub CLEAR   { %{ $_[0] } = () }\n\nsub append {\n  my ( $self, $param, @p ) = @_;\n  return () unless defined $param;\n\n  # set values using $q->append(-name=>'foo',-value=>'bar') syntax\n  # also allows for $q->append( 'foo', 'some', 'new', 'values' ) syntax\n  ( $param, undef, @p ) = @p\n   if $param =~ m/^-name$/i;    # undef represents -value token\n  $self->_add_param( $param,\n    ( ( defined $p[0] and ref $p[0] ) ? $p[0] : [@p] ) );\n  return $self->param( $param );\n}\n\nsub delete {\n  my ( $self, $param ) = @_;\n  return () unless defined $param;\n  $param\n   = $param =~ m/^-name$/i\n   ? shift\n   : $param;                    # allow delete(-name=>'foo') syntax\n  return undef unless defined $self->{$param};\n  delete $self->{$param};\n  delete $self->{'.fieldnames'}->{$param};\n  $self->{'.parameters'}\n   = [ grep { $_ ne $param } @{ $self->{'.parameters'} } ];\n}\n\nsub Delete { CGI::Simple::delete( @_ ) }    # for method style interface\n\nsub delete_all {\n  my $self = shift;\n  undef %{$self};\n  $self->_store_globals;\n}\n\nsub Delete_all { $_[0]->delete_all }        # as used by CGI.pm\n\nsub upload {\n  my ( $self, $filename, $writefile ) = @_;\n  unless ( $filename ) {\n    $self->cgi_error( \"No filename submitted for upload to $writefile\" )\n     if $writefile;\n    return $self->{'.filehandles'}\n     ? keys %{ $self->{'.filehandles'} }\n     : ();\n  }\n  unless ( $ENV{'CONTENT_TYPE'} =~ m|^multipart/form-data|i ) {\n    $self->cgi_error(\n      'Oops! File uploads only work if you specify ENCTYPE=\"multipart/form-data\" in your <FORM> tag'\n    );\n    return undef;\n  }\n  my $fh = $self->{'.filehandles'}->{$filename};\n\n  # allow use of upload fieldname to get filehandle\n  # this has limitation that in the event of duplicate\n  # upload field names there can only be one filehandle\n  # which will point to the last upload file\n  # access by filename does not suffer from this issue.\n  $fh\n   = $self->{'.filehandles'}->{ $self->{'.upload_fields'}->{$filename} }\n   if !$fh and defined $self->{'.upload_fields'}->{$filename};\n\n  if ( $fh ) {\n    seek $fh, 0, 0;    # get ready for reading\n    return $fh unless $writefile;\n    my $buffer;\n    unless ( open OUT, \">$writefile\" ) {\n      $self->cgi_error( \"500 Can't write to $writefile: $!\\n\" );\n      return undef;\n    }\n    binmode OUT;\n    binmode $fh;\n    print OUT $buffer while read( $fh, $buffer, 4096 );\n    close OUT;\n    $self->{'.filehandles'}->{$filename} = undef;\n    undef $fh;\n    return 1;\n  }\n  else {\n    $self->cgi_error(\n      \"No filehandle for '$filename'. Are uploads enabled (\\$DISABLE_UPLOADS = 0)? Is \\$POST_MAX big enough?\"\n    );\n    return undef;\n  }\n}\n\nsub upload_fieldnames {\n  my ( $self ) = @_;\n  return wantarray\n   ? ( keys %{ $self->{'.upload_fields'} } )\n   : [ keys %{ $self->{'.upload_fields'} } ];\n}\n\n# return the file size of an uploaded file\nsub upload_info {\n  my ( $self, $filename, $info ) = @_;\n  unless ( $ENV{'CONTENT_TYPE'} =~ m|^multipart/form-data|i ) {\n    $self->cgi_error(\n      'Oops! File uploads only work if you specify ENCTYPE=\"multipart/form-data\" in your <FORM> tag'\n    );\n    return undef;\n  }\n  return keys %{ $self->{'.tmpfiles'} } unless $filename;\n  return $self->{'.tmpfiles'}->{$filename}->{'mime'}\n   if $info =~ /mime/i;\n  return $self->{'.tmpfiles'}->{$filename}->{'size'};\n}\n\nsub uploadInfo { &upload_info }    # alias for CGI.pm compatibility\n\n# return all params/values in object as a query string suitable for 'GET'\nsub query_string {\n  my $self = shift;\n  my @pairs;\n  for my $param ( $self->param ) {\n    for my $value ( $self->param( $param ) ) {\n      next unless defined $value;\n      push @pairs,\n       $self->url_encode( $param ) . '=' . $self->url_encode( $value );\n    }\n  }\n  return join $self->{'.globals'}->{'USE_PARAM_SEMICOLONS'} ? ';' : '&',\n   @pairs;\n}\n\n# new method that will add QUERY_STRING data to our CGI::Simple object\n# if the REQUEST_METHOD was 'POST'\nsub parse_query_string {\n  my $self = shift;\n  $self->_parse_params( $ENV{'QUERY_STRING'} )\n   if defined $ENV{'QUERY_STRING'}\n     and $ENV{'REQUEST_METHOD'} eq 'POST';\n}\n\n################   Save and Restore params from file    ###############\n\nsub _init_from_file {\n  use Carp qw(confess);\n  confess \"INIT_FROM_FILE called, stupid fucker!\";\n  my ( $self, $fh ) = @_;\n  local $/ = \"\\n\";\n  while ( my $pair = <$fh> ) {\n    chomp $pair;\n    return if $pair eq '=';\n    $self->_parse_params( $pair );\n  }\n}\n\nsub save {\n  my ( $self, $fh ) = @_;\n  local ( $,, $\\ ) = ( '', '' );\n  unless ( $fh and fileno $fh ) {\n    $self->cgi_error( 'Invalid filehandle' );\n    return undef;\n  }\n  for my $param ( $self->param ) {\n    for my $value ( $self->param( $param ) ) {\n      ;\n      print $fh $self->url_encode( $param ), '=',\n       $self->url_encode( $value ), \"\\n\";\n    }\n  }\n  print $fh \"=\\n\";\n}\n\nsub save_parameters { save( @_ ) }    # CGI.pm alias for save\n\n################ Miscellaneous Methods ################\n\nsub parse_keywordlist {\n  _parse_keywordlist( @_ );\n}                                     # CGI.pm compatibility\n\nsub escapeHTML {\n  my ( $self, $escape, $newlinestoo ) = @_;\n  require CGI::Simple::Util;\n  $escape = CGI::Simple::Util::escapeHTML( $escape );\n  $escape =~ s/([\\012\\015])/'&#'.(ord $1).';'/eg if $newlinestoo;\n  return $escape;\n}\n\nsub unescapeHTML {\n  require CGI::Simple::Util;\n  return CGI::Simple::Util::unescapeHTML( $_[1] );\n}\n\nsub put {\n  my $self = shift;\n  $self->print( @_ );\n}    # send output to browser\n\nsub print {\n  shift;\n  CORE::print( @_ );\n}    # print to standard output (for overriding in mod_perl)\n\n################# Cookie Methods ################\n\nsub cookie {\n  my ( $self, @params ) = @_;\n  require CGI::Simple::Cookie;\n  require CGI::Simple::Util;\n  my ( $name, $value, $path, $domain, $secure, $expires, $httponly )\n   = CGI::Simple::Util::rearrange(\n    [\n      'NAME', [ 'VALUE', 'VALUES' ],\n      'PATH',   'DOMAIN',\n      'SECURE', 'EXPIRES',\n      'HTTPONLY'\n    ],\n    @params\n   );\n\n  # retrieve the value of the cookie, if no value is supplied\n  unless ( defined( $value ) ) {\n    $self->{'.cookies'} = CGI::Simple::Cookie->fetch\n     unless $self->{'.cookies'};\n    return () unless $self->{'.cookies'};\n\n   # if no name is supplied, then retrieve the names of all our cookies.\n    return keys %{ $self->{'.cookies'} } unless $name;\n\n    # return the value of the cookie\n    return\n     exists $self->{'.cookies'}->{$name}\n     ? $self->{'.cookies'}->{$name}->value\n     : ();\n  }\n\n  # If we get here, we're creating a new cookie\n  return undef unless $name;    # this is an error\n  @params = ();\n  push @params, '-name'     => $name;\n  push @params, '-value'    => $value;\n  push @params, '-domain'   => $domain if $domain;\n  push @params, '-path'     => $path if $path;\n  push @params, '-expires'  => $expires if $expires;\n  push @params, '-secure'   => $secure if $secure;\n  push @params, '-httponly' => $httponly if $httponly;\n  return CGI::Simple::Cookie->new( @params );\n}\n\nsub raw_cookie {\n  my ( $self, $key ) = @_;\n  if ( defined $key ) {\n    unless ( $self->{'.raw_cookies'} ) {\n      require CGI::Simple::Cookie;\n      $self->{'.raw_cookies'} = CGI::Simple::Cookie->raw_fetch;\n    }\n    return $self->{'.raw_cookies'}->{$key} || ();\n  }\n  return $ENV{'HTTP_COOKIE'} || $ENV{'COOKIE'} || '';\n}\n\n################# Header Methods ################\n\nsub header {\n  my ( $self, @params ) = @_;\n  require CGI::Simple::Util;\n  my @header;\n  return undef\n   if $self->{'.header_printed'}++\n     and $self->{'.globals'}->{'HEADERS_ONCE'};\n  my (\n    $type, $status,  $cookie,     $target, $expires,\n    $nph,  $charset, $attachment, $p3p,    @other\n   )\n   = CGI::Simple::Util::rearrange(\n    [\n      [ 'TYPE',   'CONTENT_TYPE', 'CONTENT-TYPE' ], 'STATUS',\n      [ 'COOKIE', 'COOKIES',      'SET-COOKIE' ],   'TARGET',\n      'EXPIRES', 'NPH',\n      'CHARSET', 'ATTACHMENT',\n      'P3P'\n    ],\n    @params\n   );\n\n  # CR escaping for values, per RFC 822\n  for my $header (\n    $type, $status,  $cookie,     $target, $expires,\n    $nph,  $charset, $attachment, $p3p,    @other\n   ) {\n    if ( defined $header ) {\n      $header =~ s/\n                (?<=\\n)    # For any character proceeded by a newline\n                (?=\\S)     # ... that is not whitespace\n            / /xg;    # ... inject a leading space in the new line\n    }\n  }\n\n  $nph ||= $self->{'.globals'}->{'NPH'};\n  $charset = $self->charset( $charset )\n   ;                  # get charset (and set new charset if supplied)\n   # rearrange() was designed for the HTML portion, so we need to fix it up a little.\n\n  for ( @other ) {\n\n    # Don't use \\s because of perl bug 21951\n    next\n     unless my ( $header, $value ) = /([^ \\r\\n\\t=]+)=\\\"?(.+?)\\\"?$/s;\n    ( $_ = $header )\n     =~ s/^(\\w)(.*)/\"\\u$1\\L$2\" . ': '.$self->unescapeHTML($value)/e;\n  }\n  $type ||= 'text/html' unless defined $type;\n  $type .= \"; charset=$charset\"\n   if $type\n     and $type =~ m!^text/!\n     and $type !~ /\\bcharset\\b/;\n  my $protocol = $ENV{SERVER_PROTOCOL} || 'HTTP/1.0';\n  push @header, $protocol . ' ' . ( $status || '200 OK' ) if $nph;\n  push @header, \"Server: \" . server_software() if $nph;\n  push @header, \"Status: $status\"              if $status;\n  push @header, \"Window-Target: $target\"       if $target;\n\n  if ( $p3p ) {\n    $p3p = join ' ', @$p3p if ref( $p3p ) eq 'ARRAY';\n    push( @header, qq(P3P: policyref=\"/w3c/p3p.xml\", CP=\"$p3p\") );\n  }\n\n  # push all the cookies -- there may be several\n  if ( $cookie ) {\n    my @cookie = ref $cookie eq 'ARRAY' ? @{$cookie} : $cookie;\n    for my $cookie ( @cookie ) {\n      my $cs\n       = ref $cookie eq 'CGI::Simple::Cookie'\n       ? $cookie->as_string\n       : $cookie;\n      push @header, \"Set-Cookie: $cs\" if $cs;\n    }\n  }\n\n# if the user indicates an expiration time, then we need both an Expires\n# and a Date header (so that the browser is using OUR clock)\n  $expires = 'now'\n   if $self->no_cache;    # encourage no caching via expires now\n  push @header,\n   \"Expires: \" . CGI::Simple::Util::expires( $expires, 'http' )\n   if $expires;\n  push @header, \"Date: \" . CGI::Simple::Util::expires( 0, 'http' )\n   if defined $expires || $cookie || $nph;\n  push @header, \"Pragma: no-cache\" if $self->cache or $self->no_cache;\n  push @header,\n   \"Content-Disposition: attachment; filename=\\\"$attachment\\\"\"\n   if $attachment;\n  push @header, @other;\n  push @header, \"Content-Type: $type\" if $type;\n  my $CRLF = $self->crlf;\n  my $header = join $CRLF, @header;\n  $header .= $CRLF . $CRLF;    # add the statutory two CRLFs\n\n  if ( $self->{'.mod_perl'} and not $nph ) {\n    my $r = $self->_mod_perl_request();\n    $r->send_cgi_header( $header );\n    return '';\n  }\n  return $header;\n}\n\n# Control whether header() will produce the no-cache Pragma directive.\nsub cache {\n  my ( $self, $value ) = @_;\n  $self->{'.cache'} = $value if defined $value;\n  return $self->{'.cache'};\n}\n\n# Control whether header() will produce expires now + the no-cache Pragma.\nsub no_cache {\n  my ( $self, $value ) = @_;\n  $self->{'.no_cache'} = $value if defined $value;\n  return $self->{'.no_cache'};\n}\n\nsub redirect {\n  my ( $self, @params ) = @_;\n  require CGI::Simple::Util;\n  my ( $url, $target, $cookie, $nph, @other )\n   = CGI::Simple::Util::rearrange(\n    [\n      [ 'LOCATION', 'URI',       'URL' ], 'TARGET',\n      [ 'COOKIE',   'COOKIES' ], 'NPH'\n    ],\n    @params\n   );\n  $url ||= $self->self_url;\n  my @o;\n  for ( @other ) { tr/\\\"//d; push @o, split \"=\", $_, 2; }\n  unshift @o,\n   '-Status'   => '302 Moved',\n   '-Location' => $url,\n   '-nph'      => $nph;\n  unshift @o, '-Target' => $target if $target;\n  unshift @o, '-Cookie' => $cookie if $cookie;\n  unshift @o, '-Type'   => '';\n  my @unescaped;\n  unshift( @unescaped, '-Cookie' => $cookie ) if $cookie;\n  return $self->header( ( map { $self->unescapeHTML( $_ ) } @o ),\n    @unescaped );\n}\n\n################# Server Push Methods #################\n# Return a Content-Type: style header for server-push\n# This has to be NPH, and it is advisable to set $| = 1\n# Credit to Ed Jordan <ed@fidalgo.net> and\n# Andrew Benham <adsb@bigfoot.com> for this section\n\nsub multipart_init {\n  my ( $self, @p ) = @_;\n  use CGI::Simple::Util qw(rearrange);\n  my ( $boundary, @other ) = rearrange( ['BOUNDARY'], @p );\n  $boundary = $boundary || '------- =_aaaaaaaaaa0';\n  my $CRLF = $self->crlf;    # get CRLF sequence\n  my $warning\n   = \"WARNING: YOUR BROWSER DOESN'T SUPPORT THIS SERVER-PUSH TECHNOLOGY.\";\n  $self->{'.separator'}       = \"$CRLF--$boundary$CRLF\";\n  $self->{'.final_separator'} = \"$CRLF--$boundary--$CRLF$warning$CRLF\";\n  my $type = 'multipart/x-mixed-replace;boundary=\"' . $boundary . '\"';\n  return $self->header(\n    -nph  => 1,\n    -type => $type,\n    map { split \"=\", $_, 2 } @other\n   )\n   . $warning\n   . $self->multipart_end;\n}\n\nsub multipart_start {\n  my ( $self, @p ) = @_;\n  use CGI::Simple::Util qw(rearrange);\n  my ( $type, @other ) = rearrange( ['TYPE'], @p );\n  foreach ( @other ) {    # fix return from rearange\n    next unless my ( $header, $value ) = /([^\\s=]+)=\\\"?(.+?)\\\"?$/;\n    $_ = ucfirst( lc $header ) . ': ' . unescapeHTML( 1, $value );\n  }\n  $type = $type || 'text/html';\n  my @header = ( \"Content-Type: $type\" );\n  push @header, @other;\n  my $CRLF = $self->crlf;    # get CRLF sequence\n  return ( join $CRLF, @header ) . $CRLF . $CRLF;\n}\n\nsub multipart_end { return $_[0]->{'.separator'} }\n\nsub multipart_final { return $_[0]->{'.final_separator'} }\n\n################# Debugging Methods ################\n\nsub read_from_cmdline {\n  my @words;\n  if ( $_[0]->{'.globals'}->{'DEBUG'} == 1 and @ARGV ) {\n    @words = @ARGV;\n  }\n  elsif ( $_[0]->{'.globals'}->{'DEBUG'} == 2 ) {\n    require \"shellwords.pl\";\n    print \"(offline mode: enter name=value pairs on standard input)\\n\";\n    chomp( my @lines = <STDIN> );\n    @words = &shellwords( join \" \", @lines );\n  }\n  else {\n    return '';\n  }\n  @words = map { s/\\\\=/%3D/g; s/\\\\&/%26/g; $_ } @words;\n  return \"@words\" =~ m/=/ ? join '&', @words : join '+', @words;\n}\n\nsub Dump {\n  require Data::Dumper;    # short and sweet way of doing it\n  ( my $dump = Data::Dumper::Dumper( @_ ) )\n   =~ tr/\\000/0/;          # remove null bytes cgi-lib.pl\n  return '<pre>' . escapeHTML( 1, $dump ) . '</pre>';\n}\n\nsub as_string { Dump( @_ ) }    # CGI.pm alias for Dump()\n\nsub cgi_error {\n  my ( $self, $err ) = @_;\n  if ( $err ) {\n    $self->{'.cgi_error'} = $err;\n       $self->{'.globals'}->{'FATAL'} == 1 ? croak $err\n     : $self->{'.globals'}->{'FATAL'} == 0 ? carp $err\n     :                                       return $err;\n  }\n  return $self->{'.cgi_error'};\n}\n\n################# cgi-lib.pl Compatibility Methods #################\n# Lightly GOLFED but the original functionality remains. You can call\n# them using either: # $q->MethodName or CGI::Simple::MethodName\n\nsub _shift_if_ref { shift if ref $_[0] eq 'CGI::Simple' }\n\nsub ReadParse {\n  my $q = &_shift_if_ref || new CGI::Simple;\n  my $pkg = caller();\n  no strict 'refs';\n  *in\n   = @_\n   ? $_[0]\n   : *{\"${pkg}::in\"};    # set *in to passed glob or export *in\n  %in = $q->Vars;\n  $in{'CGI'} = $q;\n  return scalar %in;\n}\n\nsub SplitParam {\n  &_shift_if_ref;\n  defined $_[0]\n   && ( wantarray ? split \"\\0\", $_[0] : ( split \"\\0\", $_[0] )[0] );\n}\n\nsub MethGet { request_method() eq 'GET' }\n\nsub MethPost { request_method() eq 'POST' }\n\nsub MyBaseUrl {\n  local $^W = 0;\n  'http://'\n   . server_name()\n   . ( server_port() != 80 ? ':' . server_port() : '' )\n   . script_name();\n}\n\nsub MyURL { MyBaseUrl() }\n\nsub MyFullUrl {\n  local $^W = 0;\n  MyBaseUrl()\n   . $ENV{'PATH_INFO'}\n   . ( $ENV{'QUERY_STRING'} ? \"?$ENV{'QUERY_STRING'}\" : '' );\n}\n\nsub PrintHeader {\n  ref $_[0] ? $_[0]->header() : \"Content-Type: text/html\\n\\n\";\n}\n\nsub HtmlTop {\n  &_shift_if_ref;\n  \"<html>\\n<head>\\n<title>$_[0]</title>\\n</head>\\n<body>\\n<h1>$_[0]</h1>\\n\";\n}\n\nsub HtmlBot { \"</body>\\n</html>\\n\" }\n\nsub PrintVariables { &_shift_if_ref; &Dump }\n\nsub PrintEnv { &Dump( \\%ENV ) }\n\nsub CgiDie { CgiError( @_ ); die @_ }\n\nsub CgiError {\n  &_shift_if_ref;\n  @_\n   = @_\n   ? @_\n   : ( \"Error: script \" . MyFullUrl() . \" encountered fatal error\\n\" );\n  print PrintHeader(), HtmlTop( shift ), ( map { \"<p>$_</p>\\n\" } @_ ),\n   HtmlBot();\n}\n\n################ Accessor Methods ################\n\nsub version { $VERSION }\n\nsub nph {\n  $_[0]->{'.globals'}->{'NPH'} = $_[1] if defined $_[1];\n  return $_[0]->{'.globals'}->{'NPH'};\n}\n\nsub all_parameters { $_[0]->param }\n\nsub charset {\n  require CGI::Simple::Util;\n  $CGI::Simple::Util::UTIL->charset( $_[1] );\n}\n\nsub globals {\n  my ( $self, $global, $value ) = @_;\n  return keys %{ $self->{'.globals'} } unless $global;\n  $self->{'.globals'}->{$global} = $value if defined $value;\n  return $self->{'.globals'}->{$global};\n}\n\nsub auth_type         { $ENV{'AUTH_TYPE'} }\nsub content_length    { $ENV{'CONTENT_LENGTH'} }\nsub content_type      { $ENV{'CONTENT_TYPE'} }\nsub document_root     { $ENV{'DOCUMENT_ROOT'} }\nsub gateway_interface { $ENV{'GATEWAY_INTERFACE'} }\nsub path_translated   { $ENV{'PATH_TRANSLATED'} }\nsub referer           { $ENV{'HTTP_REFERER'} }\nsub remote_addr       { $ENV{'REMOTE_ADDR'} || '127.0.0.1' }\n\nsub remote_host {\n  $ENV{'REMOTE_HOST'} || $ENV{'REMOTE_ADDR'} || 'localhost';\n}\n\nsub remote_ident   { $ENV{'REMOTE_IDENT'} }\nsub remote_user    { $ENV{'REMOTE_USER'} }\nsub request_method { $ENV{'REQUEST_METHOD'} }\nsub script_name    { $ENV{'SCRIPT_NAME'} || $0 || '' }\nsub server_name     { $ENV{'SERVER_NAME'}     || 'localhost' }\nsub server_port     { $ENV{'SERVER_PORT'}     || 80 }\nsub server_protocol { $ENV{'SERVER_PROTOCOL'} || 'HTTP/1.0' }\nsub server_software { $ENV{'SERVER_SOFTWARE'} || 'cmdline' }\n\nsub user_name {\n  $ENV{'HTTP_FROM'} || $ENV{'REMOTE_IDENT'} || $ENV{'REMOTE_USER'};\n}\n\nsub user_agent {\n  my ( $self, $match ) = @_;\n  return $match\n   ? $ENV{'HTTP_USER_AGENT'} =~ /\\Q$match\\E/i\n   : $ENV{'HTTP_USER_AGENT'};\n}\n\nsub virtual_host {\n  my $vh = $ENV{'HTTP_HOST'} || $ENV{'SERVER_NAME'};\n  $vh =~ s/:\\d+$//;    # get rid of port number\n  return $vh;\n}\n\nsub path_info {\n  my ( $self, $info ) = @_;\n  if ( defined $info ) {\n    $info = \"/$info\" if $info !~ m|^/|;\n    $self->{'.path_info'} = $info;\n  }\n  elsif ( !defined( $self->{'.path_info'} ) ) {\n    $self->{'.path_info'}\n     = defined( $ENV{'PATH_INFO'} ) ? $ENV{'PATH_INFO'} : '';\n\n    # hack to fix broken path info in IIS source CGI.pm\n    $self->{'.path_info'} =~ s/^\\Q$ENV{'SCRIPT_NAME'}\\E//\n     if defined( $ENV{'SERVER_SOFTWARE'} )\n       && $ENV{'SERVER_SOFTWARE'} =~ /IIS/;\n  }\n  return $self->{'.path_info'};\n}\n\nsub accept {\n  my ( $self, $search ) = @_;\n  my %prefs;\n  for my $accept ( split ',', $ENV{'HTTP_ACCEPT'} ) {\n    ( my $pref ) = $accept =~ m|q=([\\d\\.]+)|;\n    ( my $type ) = $accept =~ m|(\\S+/[^;]+)|;\n    next unless $type;\n    $prefs{$type} = $pref || 1;\n  }\n  return keys %prefs unless $search;\n  return $prefs{$search} if $prefs{$search};\n\n  # Didn't get it, so try pattern matching.\n  for my $pref ( keys %prefs ) {\n    next unless $pref =~ m/\\*/;    # not a pattern match\n    ( my $pat = $pref ) =~ s/([^\\w*])/\\\\$1/g;   # escape meta characters\n    $pat =~ s/\\*/.*/g;                          # turn it into a pattern\n    return $prefs{$pref} if $search =~ /$pat/;\n  }\n}\n\nsub Accept { my $self = shift; $self->accept( @_ ) }\n\nsub http {\n  my ( $self, $parameter ) = @_;\n  if ( defined $parameter ) {\n    ( $parameter = uc $parameter ) =~ tr/-/_/;\n    return $ENV{$parameter} if $parameter =~ m/^HTTP/;\n    return $ENV{\"HTTP_$parameter\"} if $parameter;\n  }\n  return grep { /^HTTP/ } keys %ENV;\n}\n\nsub https {\n  my ( $self, $parameter ) = @_;\n  return $ENV{'HTTPS'} unless $parameter;\n  ( $parameter = uc $parameter ) =~ tr/-/_/;\n  return $ENV{$parameter} if $parameter =~ /^HTTPS/;\n  return $ENV{\"HTTPS_$parameter\"};\n}\n\nsub protocol {\n  local ( $^W ) = 0;\n  my $self = shift;\n  return 'https' if uc $ENV{'HTTPS'} eq 'ON';\n  return 'https' if $self->server_port == 443;\n  my ( $protocol, $version ) = split '/', $self->server_protocol;\n  return lc $protocol;\n}\n\nsub url {\n  my ( $self, @p ) = @_;\n  use CGI::Simple::Util 'rearrange';\n  my ( $relative, $absolute, $full, $path_info, $query, $base )\n   = rearrange(\n    [\n      'RELATIVE', 'ABSOLUTE', 'FULL',\n      [ 'PATH',  'PATH_INFO' ],\n      [ 'QUERY', 'QUERY_STRING' ], 'BASE'\n    ],\n    @p\n   );\n  my $url;\n  $full++ if $base || !( $relative || $absolute );\n  my $path        = $self->path_info;\n  my $script_name = $self->script_name;\n  if ( $full ) {\n    my $protocol = $self->protocol();\n    $url = \"$protocol://\";\n    my $vh = $self->http( 'host' );\n    if ( $vh ) {\n      $url .= $vh;\n    }\n    else {\n      $url .= server_name();\n      my $port = $self->server_port;\n      $url .= \":\" . $port\n       unless ( lc( $protocol ) eq 'http' && $port == 80 )\n       or ( lc( $protocol ) eq 'https' && $port == 443 );\n    }\n    return $url if $base;\n    $url .= $script_name;\n  }\n  elsif ( $relative ) {\n    ( $url ) = $script_name =~ m#([^/]+)$#;\n  }\n  elsif ( $absolute ) {\n    $url = $script_name;\n  }\n  $url .= $path if $path_info and defined $path;\n  $url .= \"?\" . $self->query_string if $query and $self->query_string;\n  $url = '' unless defined $url;\n  $url\n   =~ s/([^a-zA-Z0-9_.%;&?\\/\\\\:+=~-])/uc sprintf(\"%%%02x\",ord($1))/eg;\n  return $url;\n}\n\nsub self_url {\n  my ( $self, @params ) = @_;\n  return $self->url(\n    '-path_info' => 1,\n    '-query'     => 1,\n    '-full'      => 1,\n    @params\n  );\n}\n\nsub state { self_url( @_ ) }    # CGI.pm synonym routine\n\n1;\n\n=head1 NAME\n\nCGI::Simple - A Simple totally OO CGI interface that is CGI.pm compliant\n\n=head1 VERSION\n\nThis document describes CGI::Simple version 1.113.\n\n=head1 SYNOPSIS\n\n    use CGI::Simple;\n    $CGI::Simple::POST_MAX = 1024;       # max upload via post default 100kB\n    $CGI::Simple::DISABLE_UPLOADS = 0;   # enable uploads\n\n    $q = new CGI::Simple;\n    $q = new CGI::Simple( { 'foo'=>'1', 'bar'=>[2,3,4] } );\n    $q = new CGI::Simple( 'foo=1&bar=2&bar=3&bar=4' );\n    $q = new CGI::Simple( \\*FILEHANDLE );\n\n    $q->save( \\*FILEHANDLE );   # save current object to a file as used by new\n\n    @params = $q->param;        # return all param names as a list\n    $value = $q->param('foo');  # return the first value supplied for 'foo'\n    @values = $q->param('foo'); # return all values supplied for foo\n\n    %fields   = $q->Vars;      # returns untied key value pair hash\n    $hash_ref = $q->Vars;      # or as a hash ref\n    %fields   = $q->Vars(\"|\"); # packs multiple values with \"|\" rather than \"\\0\";\n\n    @keywords = $q->keywords;  # return all keywords as a list\n\n    $q->param( 'foo', 'some', 'new', 'values' );      # set new 'foo' values\n    $q->param( -name=>'foo', -value=>'bar' );\n    $q->param( -name=>'foo', -value=>['bar','baz'] );\n\n    $q->param( 'foo', 'some', 'new', 'values' );      # append values to 'foo'\n    $q->append( -name=>'foo', -value=>'bar' );\n    $q->append( -name=>'foo', -value=>['some', 'new', 'values'] );\n\n    $q->delete('foo'); # delete param 'foo' and all its values\n    $q->delete_all;    # delete everything\n\n    <INPUT TYPE=\"file\" NAME=\"upload_file\" SIZE=\"42\">\n\n    $files    = $q->upload()                # number of files uploaded\n    @files    = $q->upload();               # names of all uploaded files\n    $filename = $q->param('upload_file')    # filename of uploaded file\n    $mime     = $q->upload_info($filename,'mime'); # MIME type of uploaded file\n    $size     = $q->upload_info($filename,'size'); # size of uploaded file\n\n    my $fh = $q->upload($filename);         # get filehandle to read from\n    while ( read( $fh, $buffer, 1024 ) ) { ... }\n\n    # short and sweet upload\n    $ok = $q->upload( $q->param('upload_file'), '/path/to/write/file.name' );\n    print \"Uploaded \".$q->param('upload_file').\" and wrote it OK!\" if $ok;\n\n    $decoded    = $q->url_decode($encoded);\n    $encoded    = $q->url_encode($unencoded);\n    $escaped    = $q->escapeHTML('<>\"&');\n    $unescaped  = $q->unescapeHTML('&lt;&gt;&quot;&amp;');\n\n    $qs = $q->query_string; # get all data in $q as a query string OK for GET\n\n    $q->no_cache(1);        # set Pragma: no-cache + expires\n    print $q->header();     # print a simple header\n    # get a complex header\n    $header = $q->header(   -type       => 'image/gif'\n                            -nph        => 1,\n                            -status     => '402 Payment required',\n                            -expires    =>'+24h',\n                            -cookie     => $cookie,\n                            -charset    => 'utf-7',\n                            -attachment => 'foo.gif',\n                            -Cost       => '$2.00'\n                        );\n    # a p3p header (OK for redirect use as well)\n    $header = $q->header( -p3p => 'policyref=\"http://somesite.com/P3P/PolicyReferences.xml' );\n\n    @cookies = $q->cookie();        # get names of all available cookies\n    $value   = $q->cookie('foo')    # get first value of cookie 'foo'\n    @value   = $q->cookie('foo')    # get all values of cookie 'foo'\n    # get a cookie formatted for header() method\n    $cookie  = $q->cookie(  -name    => 'Password',\n                            -values  => ['superuser','god','my dog woofie'],\n                            -expires => '+3d',\n                            -domain  => '.nowhere.com',\n                            -path    => '/cgi-bin/database',\n                            -secure  => 1\n                         );\n    print $q->header( -cookie=>$cookie );       # set cookie\n\n    print $q->redirect('http://go.away.now');   # print a redirect header\n\n    dienice( $q->cgi_error ) if $q->cgi_error;\n\n=head1 DESCRIPTION\n\nCGI::Simple provides a relatively lightweight drop in replacement for CGI.pm.\nIt shares an identical OO interface to CGI.pm for parameter parsing, file\nupload, cookie handling and header generation. This module is entirely object\noriented, however a complete functional interface is available by using the\nCGI::Simple::Standard module.\n\nEssentially everything in CGI.pm that relates to the CGI (not HTML) side of\nthings is available. There are even a few new methods and additions to old\nones! If you are interested in what has gone on under the hood see the\nCompatibility with CGI.pm section at the end.\n\nIn practical testing this module loads and runs about twice as fast as CGI.pm\ndepending on the precise task.\n\n=head1 CALLING CGI::Simple ROUTINES USING THE OBJECT INTERFACE\n\nHere is a very brief rundown on how you use the interface. Full details\nfollow.\n\n=head2 First you need to initialize an object\n\nBefore you can call a CGI::Simple method you must create a CGI::Simple object.\nYou do that by using the module and then calling the new() constructor:\n\n    use CGI::Simple;\n    my $q = new CGI::Simple;\n\nIt is traditional to call your object $q for query or perhaps $cgi.\n\n=head2 Next you call methods on that object\n\nOnce you have your object you can call methods on it using the -> arrow\nsyntax For example to get the names of all the parameters passed to your\nscript you would just write:\n\n    @names = $q->param();\n\nMany methods are sensitive to the context in which you call them. In the\nexample above the B<param()> method returns a list of all the parameter names\nwhen called without any arguments.\n\nWhen you call B<param('arg')> with a single argument it assumes you want\nto get the value(s) associated with that argument (parameter). If you ask\nfor an array it gives you an array of all the values associated with it's\nargument:\n\n    @values = $q->param('foo');  # get all the values for 'foo'\n\nwhereas if you ask for a scalar like this:\n\n    $value = $q->param('foo');   # get only the first value for 'foo'\n\nthen it returns only the first value (if more than one value for\n'foo' exists).\n\nMost CGI::Simple routines accept several arguments, sometimes as many as\n10 optional ones!  To simplify this interface, all routines use a named\nargument calling style that looks like this:\n\n    print $q->header( -type=>'image/gif', -expires=>'+3d' );\n\nEach argument name is preceded by a dash.  Neither case nor order\nmatters in the argument list.  -type, -Type, and -TYPE are all\nacceptable.\n\nSeveral routines are commonly called with just one argument.  In the\ncase of these routines you can provide the single argument without an\nargument name.  B<header()> happens to be one of these routines.  In this\ncase, the single argument is the document type.\n\n   print $q->header('text/html');\n\nSometimes methods expect a scalar, sometimes a reference to an\narray, and sometimes a reference to a hash.  Often, you can pass any\ntype of argument and the routine will do whatever is most appropriate.\nFor example, the B<param()> method can be used to set a CGI parameter to a\nsingle or a multi-valued value.  The two cases are shown below:\n\n   $q->param(-name=>'veggie',-value=>'tomato');\n   $q->param(-name=>'veggie',-value=>['tomato','tomahto','potato','potahto']);\n\n=head1 CALLING CGI::Simple ROUTINES USING THE FUNCTION INTERFACE\n\nFor convenience a functional interface is provided by the\nCGI::Simple::Standard module. This hides the OO details from you and allows\nyou to simply call methods. You may either use AUTOLOADING of methods or\nimport specific method sets into you namespace. Here are the first few\nexamples again using the function interface.\n\n    use CGI::Simple::Standard qw(-autoload);\n    @names  = param();\n    @values = param('foo');\n    $value  = param('foo');\n    print header(-type=>'image/gif',-expires=>'+3d');\n    print header('text/html');\n\nYes that's it. Not a $q-> in sight. You just use the module and select\nhow/which methods to load. You then just call the methods you want exactly\nas before but without the $q-> notation.\n\nWhen (if) you read the following docs and are using the functional interface\njust pretend the $q-> is not there.\n\n=head2 Selecting which methods to load\n\nWhen you use the functional interface Perl needs to be able to find the\nfunctions you call. The simplest way of doing this is to use autoloading as\nshown above. When you use CGI::Simple::Standard with the '-autoload' pragma\nit exports a single AUTOLOAD sub into you namespace. Every time you call a\nnon existent function AUTOLOAD is called and will load the required\nfunction and install it in your namespace. Thus only the AUTOLOAD sub and\nthose functions you specifically call will be imported.\n\nAlternatively CGI::Simple::Standard provides a range of function sets you can\nimport or you can just select exactly what you want. You do this using the\nfamiliar\n\n    use CGI::Simple::Standard qw( :func_set  some_func);\n\nnotation. This will import the ':func_set' function set and the specific\nfunction 'some_func'.\n\n=head2 To Autoload or not to Autoload, that is the question.\n\nIf you do not have a AUTOLOAD sub in you script it is generally best to use\nthe '-autoload' option. Under autoload you can use any method you want but\nonly import and compile those functions you actually use.\n\nIf you do not use autoload you must specify what functions to import. You can\nonly use functions that you have imported. For comvenience functions are\ngrouped into related sets. If you choose to import one or more ':func_set'\nyou may have potential namespace collisions so check out the docs to see\nwhat gets imported. Using the ':all' tag is pretty slack but it is there\nif you want. Full details of the function sets are provided in the\nCGI::Simple::Standard docs\n\nIf you just want say the param and header methods just load these two.\n\n    use CGI::Simple::Standard qw(param header);\n\n=head2 Setting globals using the functional interface\n\nWhere you see global variables being set using the syntax:\n\n    $CGI::Simple::DEBUG = 1;\n\nYou use exactly the same syntax when using CGI::Simple::Standard.\n\n=cut\n\n################ The Core Methods ################\n\n=head1 THE CORE METHODS\n\n=head2 new() Creating a new query object\n\nThe first step in using CGI::Simple is to create a new query object using\nthe B<new()> constructor:\n\n     $q = new CGI::Simple;\n\nThis will parse the input (from both POST and GET methods) and store\nit into an object called $q.\n\nIf you provide a file handle to the B<new()> method, it will read\nparameters from the file (or STDIN, or whatever).\n\n     open FH, \"test.in\" or die $!;\n     $q = new CGI::Simple(\\*FH);\n\n     open $fh, \"test.in\" or die $!;\n     $q = new CGI::Simple($fh);\n\nThe file should be a series of newline delimited TAG=VALUE pairs.\nConveniently, this type of file is created by the B<save()> method\n(see below). Multiple records can be saved and restored.\nIO::File objects work fine.\n\nIf you are using the function-oriented interface provided by\nCGI::Simple::Standard and want to initialize from a file handle,\nthe way to do this is with B<restore_parameters()>.  This will (re)initialize\nthe default CGI::Simple object from the indicated file handle.\n\n    restore_parameters(\\*FH);\n\nIn fact for all intents and purposes B<restore_parameters()> is identical\nto B<new()> Note that B<restore_parameters()> does not exist in\nCGI::Simple itself so you can't use it.\n\nYou can also initialize the query object from an associative array\nreference:\n\n    $q = new CGI::Simple( { 'dinosaur' => 'barney',\n                            'song'     => 'I love you',\n                            'friends'  => [qw/Jessica George Nancy/] }\n                        );\n\nor from a properly formatted, URL-escaped query string:\n\n    $q = new CGI::Simple( 'dinosaur=barney&color=purple' );\n\nor from a previously existing CGI::Simple object (this generates an identical clone\nincluding all global variable settings, etc that are stored in the object):\n\n    $old_query = new CGI::Simple;\n    $new_query = new CGI::Simple($old_query);\n\nTo create an empty query, initialize it from an empty string or hash:\n\n    $empty_query = new CGI::Simple(\"\");\n\n       -or-\n\n    $empty_query = new CGI::Simple({});\n\n=head2 keywords() Fetching a list of keywords from a query\n\n    @keywords = $q->keywords;\n\nIf the script was invoked as the result of an <ISINDEX> search, the\nparsed keywords can be obtained as an array using the B<keywords()> method.\n\n=head2 param() Fetching the names of all parameters passed to your script\n\n    @names = $q->param;\n\nIf the script was invoked with a parameter list\n(e.g. \"name1=value1&name2=value2&name3=value3\"), the B<param()> method\nwill return the parameter names as a list.  If the script was invoked\nas an <ISINDEX> script and contains a string without ampersands\n(e.g. \"value1+value2+value3\") , there will be a single parameter named\n\"keywords\" containing the \"+\"-delimited keywords.\n\nNOTE: The array of parameter names returned will\nbe in the same order as they were submitted by the browser.\nUsually this order is the same as the order in which the\nparameters are defined in the form (however, this isn't part\nof the spec, and so isn't guaranteed).\n\n=head2 param() Fetching the value or values of a simple named parameter\n\n    @values = $q->param('foo');\n\n          -or-\n\n    $value = $q->param('foo');\n\nPass the B<param()> method a single argument to fetch the value of the\nnamed parameter. If the parameter is multi-valued (e.g. from multiple\nselections in a scrolling list), you can ask to receive an array.  Otherwise\nthe method will return a single value.\n\nIf a value is not given in the query string, as in the queries\n\"name1=&name2=\" or \"name1&name2\", it will be returned by default\nas an empty string. If you set the global variable:\n\n    $CGI::Simple::NO_UNDEF_PARAMS = 1;\n\nThen value-less parameters will be ignored, and will not exist in the\nquery object. If you try to access them via param you will get an undef\nreturn value.\n\n=head2 param() Setting the values of a named parameter\n\n    $q->param('foo','an','array','of','values');\n\nThis sets the value for the named parameter 'foo' to an array of\nvalues.  This is one way to change the value of a field.\n\nB<param()> also recognizes a named parameter style of calling described\nin more detail later:\n\n    $q->param(-name=>'foo',-values=>['an','array','of','values']);\n\n                  -or-\n\n    $q->param(-name=>'foo',-value=>'the value');\n\n=head2 param() Retrieving non-application/x-www-form-urlencoded data\n\nIf POSTed or PUTed data is not of type application/x-www-form-urlencoded or multipart/form-data, \nthen the data will not be processed, but instead be returned as-is in a parameter named POSTDATA\nor PUTDATA.  To retrieve it, use code like this:\n\n    my $data = $q->param( 'POSTDATA' );\n\n                  -or-\n\n    my $data = $q->param( 'PUTDATA' );\n\n(If you don't know what the preceding means, don't worry about it.  It only affects people trying\nto use CGI::Simple for REST webservices)\n\n=head2 add_param() Setting the values of a named parameter\n\nYou nay also use the new method B<add_param> to add parameters. This is an\nalias to the _add_param() internal method that actually does all the work.\nYou can call it like this:\n\n    $q->add_param('foo', 'new');\n    $q->add_param('foo', [1,2,3,4,5]);\n    $q->add_param( 'foo', 'bar', 'overwrite' );\n\nThe first argument is the parameter, the second the value or an array ref\nof values and the optional third argument sets overwrite mode. If the third\nargument is absent of false the values will be appended. If true the values\nwill overwrite any existing ones\n\n=head2 append() Appending values to a named parameter\n\n   $q->append(-name=>'foo',-values=>['yet','more','values']);\n\nThis adds a value or list of values to the named parameter.  The\nvalues are appended to the end of the parameter if it already exists.\nOtherwise the parameter is created.  Note that this method only\nrecognizes the named argument calling syntax.\n\n=head2 import_names() Importing all parameters into a namespace.\n\nThis method was silly, non OO and has been deleted. You can get all the params\nas a hash using B<Vars> or via all the other accessors.\n\n=head2 delete() Deleting a parameter completely\n\n    $q->delete('foo');\n\nThis completely clears a parameter. If you are using the function call\ninterface, use B<Delete()> instead to avoid conflicts with Perl's\nbuilt-in delete operator.\n\nIf you are using the function call interface, use B<Delete()> instead to\navoid conflicts with Perl's built-in delete operator.\n\n=head2 delete_all() Deleting all parameters\n\n    $q->delete_all();\n\nThis clears the CGI::Simple object completely. For CGI.pm compatibility\nB<Delete_all()> is provided however there is no reason to use this in the\nfunction call interface other than symmetry.\n\nFor CGI.pm compatibility B<Delete_all()> is provided as an alias for\nB<delete_all> however there is no reason to use this, even in the\nfunction call interface.\n\n=head2 param_fetch() Direct access to the parameter list\n\nThis method is provided for CGI.pm compatibility only. It returns an\narray ref to the values associated with a named param. It is deprecated.\n\n=head2 Vars() Fetching the entire parameter list as a hash\n\n    $params = $q->Vars;  # as a tied hash ref\n    print $params->{'address'};\n    @foo = split \"\\0\", $params->{'foo'};\n\n    %params = $q->Vars;  # as a plain hash\n    print $params{'address'};\n    @foo = split \"\\0\", $params{'foo'};\n\n    %params = $q->Vars(','); # specifying a different separator than \"\\0\"\n    @foo = split ',', $params{'foo'};\n\nMany people want to fetch the entire parameter list as a hash in which\nthe keys are the names of the CGI parameters, and the values are the\nparameters' values.  The B<Vars()> method does this.\n\nCalled in a scalar context, it returns the parameter list as a tied\nhash reference. Because this hash ref is tied changing a key/value\nchanges the underlying CGI::Simple object.\n\nCalled in a list context, it returns the parameter list as an ordinary hash.\nChanging this hash will not change the underlying CGI::Simple object\n\nWhen using B<Vars()>, the thing you must watch out for are multi-valued CGI\nparameters.  Because a hash cannot distinguish between scalar and\nlist context, multi-valued parameters will be returned as a packed\nstring, separated by the \"\\0\" (null) character.  You must split this\npacked string in order to get at the individual values.  This is the\nconvention introduced long ago by Steve Brenner in his cgi-lib.pl\nmodule for Perl version 4.\n\nYou can change the character used to do the multiple value packing by passing\nit to B<Vars()> as an argument as shown.\n\n=head2 url_param() Access the QUERY_STRING regardless of 'GET' or 'POST'\n\nThe B<url_param()> method makes the QUERY_STRING data available regardless\nof whether the REQUEST_METHOD was 'GET' or 'POST'. You can do anything\nwith B<url_param> that you can do with B<param()>, however the data set\nis completely independent.\n\nTechnically what happens if you use this method is that the QUERY_STRING data\nis parsed into a new CGI::Simple object which is stored within the current\nobject. B<url_param> then just calls B<param()> on this new object.\n\n=head2 parse_query_string() Add QUERY_STRING data to 'POST' requests\n\nWhen the REQUEST_METHOD is 'POST' the default behavior is to ignore\nname/value pairs or keywords in the $ENV{'QUERY_STRING'}. You can override\nthis by calling B<parse_query_string()> which will add the QUERY_STRING data to\nthe data already in our CGI::Simple object if the REQUEST_METHOD was 'POST'\n\n    $q = new CGI::Simple;\n    $q->parse_query_string;  # add $ENV{'QUERY_STRING'} data to our $q object\n\nIf the REQUEST_METHOD was 'GET' then the QUERY_STRING will already be\nstored in our object so B<parse_query_string> will be ignored.\n\nThis is a new method in CGI::Simple that is not available in CGI.pm\n\n=head2 save() Saving the state of an object to file\n\n    $q->save(\\*FILEHANDLE)\n\nThis will write the current state of the form to the provided\nfilehandle.  You can read it back in by providing a filehandle\nto the B<new()> method.\n\nThe format of the saved file is:\n\n    NAME1=VALUE1\n    NAME1=VALUE1'\n    NAME2=VALUE2\n    NAME3=VALUE3\n    =\n\nBoth name and value are URL escaped.  Multi-valued CGI parameters are\nrepresented as repeated names.  A session record is delimited by a\nsingle = symbol.  You can write out multiple records and read them\nback in with several calls to B<new()>.\n\n    open FH, \"test.in\" or die $!;\n    $q1 = new CGI::Simple(\\*FH);  # get the first record\n    $q2 = new CGI::Simple(\\*FH);  # get the next record\n\nNote: If you wish to use this method from the function-oriented (non-OO)\ninterface, the exported name for this method is B<save_parameters()>.\nAlso if you want to initialize from a file handle, the way to do this is\nwith B<restore_parameters()>.  This will (re)initialize\nthe default CGI::Simple object from the indicated file handle.\n\n    restore_parameters(\\*FH);\n\n=cut\n\n################ Uploading Files ###################\n\n=head1 FILE UPLOADS\n\nFile uploads are easy with CGI::Simple. You use the B<upload()> method.\nAssuming you have the following in your HTML:\n\n    <FORM\n     METHOD=\"POST\"\n     ACTION=\"http://somewhere.com/cgi-bin/script.cgi\"\n     ENCTYPE=\"multipart/form-data\">\n        <INPUT TYPE=\"file\" NAME=\"upload_file1\" SIZE=\"42\">\n        <INPUT TYPE=\"file\" NAME=\"upload_file2\" SIZE=\"42\">\n    </FORM>\n\nNote that the ENCTYPE is \"multipart/form-data\". You must specify this or the\nbrowser will default to \"application/x-www-form-urlencoded\" which will result\nin no files being uploaded although on the surface things will appear OK.\n\nWhen the user submits this form any supplied files will be spooled onto disk\nand saved in temporary files. These files will be deleted when your script.cgi\nexits so if you want to keep them you will need to proceed as follows.\n\n=head2 upload() The key file upload method\n\nThe B<upload()> method is quite versatile. If you call B<upload()> without\nany arguments it will return a list of uploaded files in list context and\nthe number of uploaded files in scalar context.\n\n    $number_of_files = $q->upload;\n    @list_of_files   = $q->upload;\n\nHaving established that you have uploaded files available you can get the\nbrowser supplied filename using B<param()> like this:\n\n    $filename1 = $q->param('upload_file1');\n\nYou can then get a filehandle to read from by calling B<upload()> and\nsupplying this filename as an argument. Warning: do not modify the\nvalue you get from B<param()> in any way - you don't need to untaint it.\n\n    $fh = $q->upload( $filename1 );\n\nNow to save the file you would just do something like:\n\n    $save_path = '/path/to/write/file.name';\n    open FH, \">$save_path\" or die \"Oops $!\\n\";\n    binmode FH;\n    print FH $buffer while read( $fh, $buffer, 4096 );\n    close FH;\n\nBy utilizing a new feature of the upload method this process can be\nsimplified to:\n\n    $ok = $q->upload( $q->param('upload_file1'), '/path/to/write/file.name' );\n    if ($ok) {\n        print \"Uploaded and wrote file OK!\";\n    } else {\n        print $q->cgi_error();\n    }\n\nAs you can see upload will accept an optional second argument and will write\nthe file to this file path. It will return 1 for success and undef if it\nfails. If it fails you can get the error from B<cgi_error>\n\nYou can also use just the fieldname as an argument to upload ie:\n\n    $fh = $q->upload( 'upload_field_name' );\n\n    or\n\n    $ok = $q->upload( 'upload_field_name', '/path/to/write/file.name' );\n\nBUT there is a catch. If you have multiple upload fields, all called\n'upload_field_name' then you will only get the last uploaded file from\nthese fields.\n\n=head2 upload_info() Get the details about uploaded files\n\nThe B<upload_info()> method is a new method. Called without arguments it\nreturns the number of uploaded files in scalar context and the names of\nthose files in list context.\n\n    $number_of_upload_files   = $q->upload_info();\n    @filenames_of_all_uploads = $q->upload_info();\n\nYou can get the MIME type of an uploaded file like this:\n\n    $mime = $q->upload_info( $filename1, 'mime' );\n\nIf you want to know how big a file is before you copy it you can get that\ninformation from B<uploadInfo> which will return the file size in bytes.\n\n    $file_size = $q->upload_info( $filename1, 'size' );\n\nThe size attribute is optional as this is the default value returned.\n\nNote: The old CGI.pm B<uploadInfo()> method has been deleted.\n\n=head2 $POST_MAX and $DISABLE_UPLOADS\n\nCGI.pm has a default setting that allows infinite size file uploads by\ndefault. In contrast file uploads are disabled by default in CGI::Simple\nto discourage Denial of Service attacks. You must enable them before you\nexpect file uploads to work.\n\nWhen file uploads are disabled the file name and file size details will\nstill be available from B<param()> and B<upload_info> respectively but\nthe upload filehandle returned by B<upload()> will be undefined - not\nsurprising as the underlying temp file will not exist either.\n\nYou can enable uploads using the '-upload' pragma. You do this by specifying\nthis in you use statement:\n\n    use CGI::Simple qw(-upload);\n\nAlternatively you can enable uploads via the $DISABLE_UPLOADS global like this:\n\n    use CGI::Simple;\n    $CGI::Simple::DISABLE_UPLOADS = 0;\n    $q = new CGI::Simple;\n\nIf you wish to set $DISABLE_UPLOADS you must do this *after* the\nuse statement and *before* the new constructor call as shown above.\n\nThe maximum acceptable data via post is capped at 102_400kB rather than\ninfinity which is the CGI.pm default. This should be ample for most tasks\nbut you can set this to whatever you want using the $POST_MAX global.\n\n    use CGI::Simple;\n    $CGI::Simple::DISABLE_UPLOADS = 0;      # enable uploads\n    $CGI::Simple::POST_MAX = 1_048_576;     # allow 1MB uploads\n    $q = new CGI::Simple;\n\nIf you set to -1 infinite size uploads will be permitted, which is the CGI.pm\ndefault.\n\n    $CGI::Simple::POST_MAX = -1;            # infinite size upload\n\nAlternatively you can specify all the CGI.pm default values which allow file\nuploads of infinite size in one easy step by specifying the '-default' pragma\nin your use statement.\n\n    use CGI::Simple qw( -default ..... );\n\n=head2 binmode() and Win32\n\nIf you are using CGI::Simple be sure to call B<binmode()> on any handle that\nyou create to write the uploaded file to disk. Calling B<binmode()> will do\nno harm on other systems anyway.\n\n=cut\n\n################ Miscellaneous Methods ################\n\n=head1 MISCELANEOUS METHODS\n\n=head2 escapeHTML() Escaping HTML special characters\n\nIn HTML the < > \" and & chars have special meaning and need to be\nescaped to &lt; &gt; &quot; and &amp; respectively.\n\n    $escaped = $q->escapeHTML( $string );\n\n    $escaped = $q->escapeHTML( $string, 'new_lines_too' );\n\nIf the optional second argument is supplied then newlines will be escaped to.\n\n=head2 unescapeHTML() Unescape HTML special characters\n\nThis performs the reverse of B<escapeHTML()>.\n\n    $unescaped = $q->unescapeHTML( $HTML_escaped_string );\n\n=head2 url_decode() Decode a URL encoded string\n\nThis method will correctly decode a url encoded string.\n\n    $decoded = $q->url_decode( $encoded );\n\n=head2 url_encode() URL encode a string\n\nThis method will correctly URL encode a string.\n\n    $encoded = $q->url_encode( $string );\n\n=head2 parse_keywordlist() Parse a supplied keyword list\n\n    @keywords = $q->parse_keywordlist( $keyword_list );\n\nThis method returns a list of keywords, correctly URL escaped and split out\nof the supplied string\n\n=head2 put() Send output to browser\n\nCGI.pm alias for print. $q->put('Hello World!') will print the usual\n\n=head2 print() Send output to browser\n\nCGI.pm alias for print. $q->print('Hello World!') will print the usual\n\n=cut\n\n################# Cookie Methods ################\n\n=head1 HTTP COOKIES\n\nCGI.pm has several methods that support cookies.\n\nA cookie is a name=value pair much like the named parameters in a CGI\nquery string.  CGI scripts create one or more cookies and send\nthem to the browser in the HTTP header.  The browser maintains a list\nof cookies that belong to a particular Web server, and returns them\nto the CGI script during subsequent interactions.\n\nIn addition to the required name=value pair, each cookie has several\noptional attributes:\n\n=over 4\n\n=item 1. an expiration time\n\nThis is a time/date string (in a special GMT format) that indicates\nwhen a cookie expires.  The cookie will be saved and returned to your\nscript until this expiration date is reached if the user exits\nthe browser and restarts it.  If an expiration date isn't specified, the cookie\nwill remain active until the user quits the browser.\n\n=item 2. a domain\n\nThis is a partial or complete domain name for which the cookie is\nvalid.  The browser will return the cookie to any host that matches\nthe partial domain name.  For example, if you specify a domain name\nof \".capricorn.com\", then the browser will return the cookie to\nWeb servers running on any of the machines \"www.capricorn.com\",\n\"www2.capricorn.com\", \"feckless.capricorn.com\", etc.  Domain names\nmust contain at least two periods to prevent attempts to match\non top level domains like \".edu\".  If no domain is specified, then\nthe browser will only return the cookie to servers on the host the\ncookie originated from.\n\n=item 3. a path\n\nIf you provide a cookie path attribute, the browser will check it\nagainst your script's URL before returning the cookie.  For example,\nif you specify the path \"/cgi-bin\", then the cookie will be returned\nto each of the scripts \"/cgi-bin/tally.pl\", \"/cgi-bin/order.pl\",\nand \"/cgi-bin/customer_service/complain.pl\", but not to the script\n\"/cgi-private/site_admin.pl\".  By default, path is set to \"/\", which\ncauses the cookie to be sent to any CGI script on your site.\n\n=item 4. a \"secure\" flag\n\nIf the \"secure\" attribute is set, the cookie will only be sent to your\nscript if the CGI request is occurring on a secure channel, such as SSL.\n\n=back\n\n=head2 cookie() A simple access method to cookies\n\nThe interface to HTTP cookies is the B<cookie()> method:\n\n    $cookie = $q->cookie( -name      => 'sessionID',\n                          -value     => 'xyzzy',\n                          -expires   => '+1h',\n                          -path      => '/cgi-bin/database',\n                          -domain    => '.capricorn.org',\n                          -secure    => 1\n                         );\n    print $q->header(-cookie=>$cookie);\n\nB<cookie()> creates a new cookie.  Its parameters include:\n\n=over 4\n\n=item B<-name>\n\nThe name of the cookie (required).  This can be any string at all.\nAlthough browsers limit their cookie names to non-whitespace\nalphanumeric characters, CGI.pm removes this restriction by escaping\nand unescaping cookies behind the scenes.\n\n=item B<-value>\n\nThe value of the cookie.  This can be any scalar value,\narray reference, or even associative array reference.  For example,\nyou can store an entire associative array into a cookie this way:\n\n    $cookie=$q->cookie( -name   => 'family information',\n                        -value  => \\%childrens_ages );\n\n=item B<-path>\n\nThe optional partial path for which this cookie will be valid, as described\nabove.\n\n=item B<-domain>\n\nThe optional partial domain for which this cookie will be valid, as described\nabove.\n\n=item B<-expires>\n\nThe optional expiration date for this cookie.  The format is as described\nin the section on the B<header()> method:\n\n    \"+1h\"  one hour from now\n\n=item B<-secure>\n\nIf set to true, this cookie will only be used within a secure\nSSL session.\n\n=back\n\nThe cookie created by B<cookie()> must be incorporated into the HTTP\nheader within the string returned by the B<header()> method:\n\n    print $q->header(-cookie=>$my_cookie);\n\nTo create multiple cookies, give B<header()> an array reference:\n\n    $cookie1 = $q->cookie( -name  => 'riddle_name',\n                           -value => \"The Sphynx's Question\"\n                         );\n    $cookie2 = $q->cookie( -name  => 'answers',\n                           -value => \\%answers\n                         );\n    print $q->header( -cookie => [ $cookie1, $cookie2 ] );\n\nTo retrieve a cookie, request it by name by calling B<cookie()> method\nwithout the B<-value> parameter:\n\n    use CGI::Simple;\n    $q = new CGI::Simple;\n    $riddle  = $q->cookie('riddle_name');\n    %answers = $q->cookie('answers');\n\nCookies created with a single scalar value, such as the \"riddle_name\"\ncookie, will be returned in that form.  Cookies with array and hash\nvalues can also be retrieved.\n\nThe cookie and CGI::Simple  namespaces are separate.  If you have a parameter\nnamed 'answers' and a cookie named 'answers', the values retrieved by\nB<param()> and B<cookie()> are independent of each other.  However, it's\nsimple to turn a CGI parameter into a cookie, and vice-versa:\n\n    # turn a CGI parameter into a cookie\n    $c = $q->cookie( -name=>'answers', -value=>[$q->param('answers')] );\n    # vice-versa\n    $q->param( -name=>'answers', -value=>[$q->cookie('answers')] );\n\n=head2 raw_cookie()\n\nReturns the HTTP_COOKIE variable. Cookies have a special format, and\nthis method call just returns the raw form (?cookie dough). See\nB<cookie()> for ways of setting and retrieving cooked cookies.\n\nCalled with no parameters, B<raw_cookie()> returns the packed cookie\nstructure.  You can separate it into individual cookies by splitting\non the character sequence \"; \".  Called with the name of a cookie,\nretrieves the B<unescaped> form of the cookie.  You can use the\nregular B<cookie()> method to get the names, or use the raw_fetch()\nmethod from the CGI::Simmple::Cookie module.\n\n=cut\n\n################# Header Methods ################\n\n=head1 CREATING HTTP HEADERS\n\nNormally the first thing you will do in any CGI script is print out an\nHTTP header.  This tells the browser what type of document to expect,\nand gives other optional information, such as the language, expiration\ndate, and whether to cache the document.  The header can also be\nmanipulated for special purposes, such as server push and pay per view\npages.\n\n=head2 header() Create simple or complex HTTP headers\n\n    print $q->header;\n\n         -or-\n\n    print $q->header('image/gif');\n\n         -or-\n\n    print $q->header('text/html','204 No response');\n\n         -or-\n\n    print $q->header( -type       => 'image/gif',\n                      -nph        => 1,\n                      -status     => '402 Payment required',\n                      -expires    => '+3d',\n                      -cookie     => $cookie,\n                      -charset    => 'utf-7',\n                      -attachment => 'foo.gif',\n                      -Cost       => '$2.00'\n                    );\n\nB<header()> returns the Content-type: header.  You can provide your own\nMIME type if you choose, otherwise it defaults to text/html.  An\noptional second parameter specifies the status code and a human-readable\nmessage.  For example, you can specify 204, \"No response\" to create a\nscript that tells the browser to do nothing at all.\n\nThe last example shows the named argument style for passing arguments\nto the CGI methods using named parameters.  Recognized parameters are\nB<-type>, B<-status>, B<-cookie>, B<-target>, B<-expires>, B<-nph>,\nB<-charset> and B<-attachment>.  Any other named parameters will be\nstripped of their initial hyphens and turned into header fields, allowing\nyou to specify any HTTP header you desire.\n\nFor example, you can produce non-standard HTTP header fields by providing\nthem as named arguments:\n\n  print $q->header( -type            => 'text/html',\n                    -nph             => 1,\n                    -cost            => 'Three smackers',\n                    -annoyance_level => 'high',\n                    -complaints_to   => 'bit bucket'\n                  );\n\nThis will produce the following non-standard HTTP header:\n\n    HTTP/1.0 200 OK\n    Cost: Three smackers\n    Annoyance-level: high\n    Complaints-to: bit bucket\n    Content-type: text/html\n\nNote that underscores are translated automatically into hyphens. This feature\nallows you to keep up with the rapidly changing HTTP \"standards\".\n\nThe B<-type> is a key element that tell the browser how to display your\ndocument. The default is 'text/html'. Common types are:\n\n    text/html\n    text/plain\n    image/gif\n    image/jpg\n    image/png\n    application/octet-stream\n\nThe B<-status> code is the HTTP response code. The default is 200 OK. Common\nstatus codes are:\n\n    200 OK\n    204 No Response\n    301 Moved Permanently\n    302 Found\n    303 See Other\n    307 Temporary Redirect\n    400 Bad Request\n    401 Unauthorized\n    403 Forbidden\n    404 Not Found\n    405 Not Allowed\n    408 Request Timed Out\n    500 Internal Server Error\n    503 Service Unavailable\n    504 Gateway Timed Out\n\nThe B<-expires> parameter lets you indicate to a browser and proxy server\nhow long to cache pages for. When you specify an absolute or relative\nexpiration interval with this parameter, some browsers and proxy servers\nwill cache the script's output until the indicated expiration date.\nThe following forms are all valid for the -expires field:\n\n    +30s                                30 seconds from now\n    +10m                                ten minutes from now\n    +1h                                 one hour from now\n    -1d                                 yesterday (i.e. \"ASAP!\")\n    now                                 immediately\n    +3M                                 in three months\n    +10y                                in ten years time\n    Thursday, 25-Apr-1999 00:40:33 GMT  at the indicated time & date\n\nThe B<-cookie> parameter generates a header that tells the browser to provide\na \"magic cookie\" during all subsequent transactions with your script.\nNetscape cookies have a special format that includes interesting attributes\nsuch as expiration time.  Use the B<cookie()> method to create and retrieve\nsession cookies.\n\nThe B<-target> is for frames use\n\nThe B<-nph> parameter, if set to a true value, will issue the correct\nheaders to work with a NPH (no-parse-header) script.  This is important\nto use with certain servers that expect all their scripts to be NPH.\n\nThe B<-charset> parameter can be used to control the character set\nsent to the browser.  If not provided, defaults to ISO-8859-1.  As a\nside effect, this sets the charset() method as well.\n\nThe B<-attachment> parameter can be used to turn the page into an\nattachment.  Instead of displaying the page, some browsers will prompt\nthe user to save it to disk.  The value of the argument is the\nsuggested name for the saved file.  In order for this to work, you may\nhave to set the B<-type> to 'application/octet-stream'.\n\n=head2 no_cache() Preventing browser caching of scripts\n\nMost browsers will not cache the output from CGI scripts. Every time\nthe browser reloads the page, the script is invoked anew. However some\nbrowsers do cache pages. You can discourage this behavior using the\nB<no_cache()> function.\n\n    $q->no_cache(1); # turn caching off by sending appropriate headers\n    $q->no_cache(1); # do not send cache related headers.\n\n    $q->no_cache(1);\n    print header (-type=>'image/gif', -nph=>1);\n\n    This will produce a header like the following:\n\n    HTTP/1.0 200 OK\n    Server: Apache - accept no substitutes\n    Expires: Thu, 15 Nov 2001 03:37:50 GMT\n    Date: Thu, 15 Nov 2001 03:37:50 GMT\n    Pragma: no-cache\n    Content-Type: image/gif\n\nBoth the Pragma: no-cache header field and an Expires header that corresponds\nto the current time (ie now) will be sent.\n\n=head2 cache() Preventing browser caching of scripts\n\nThe somewhat ill named B<cache()> method is a legacy from CGI.pm. It operates\nthe same as the new B<no_cache()> method. The difference is/was that when set\nit results only in the Pragma: no-cache line being printed.\nExpires time data is not sent.\n\n=head2 redirect() Generating a redirection header\n\n    print $q->redirect('http://somewhere.else/in/movie/land');\n\nSometimes you don't want to produce a document yourself, but simply\nredirect the browser elsewhere, perhaps choosing a URL based on the\ntime of day or the identity of the user.\n\nThe B<redirect()> function redirects the browser to a different URL.  If\nyou use redirection like this, you should B<not> print out a header as\nwell.\n\nOne hint I can offer is that relative links may not work correctly\nwhen you generate a redirection to another document on your site.\nThis is due to a well-intentioned optimization that some servers use.\nThe solution to this is to use the full URL (including the http: part)\nof the document you are redirecting to.\n\nYou can also use named arguments:\n\n    print $q->redirect( -uri=>'http://somewhere.else/in/movie/land',\n                        -nph=>1\n                      );\n\nThe B<-nph> parameter, if set to a true value, will issue the correct\nheaders to work with a NPH (no-parse-header) script.  This is important\nto use with certain servers, such as Microsoft ones, which\nexpect all their scripts to be NPH.\n\n=cut\n\n=head1 PRAGMAS\n\nThere are a number of pragmas that you can specify in your use CGI::Simple\nstatement. Pragmas, which are always preceded by a hyphen, change the way\nthat CGI::Simple functions in various ways. You can generally achieve\nexactly the same results by setting the underlying $GLOBAL_VARIABLES.\n\nFor example the '-upload' pargma will enable file uploads:\n\n    use CGI::Simple qw(-upload);\n\nIn CGI::Simple::Standard Pragmas, function sets , and individual functions\ncan all be imported in the same use() line.  For example, the following\nuse statement imports the standard set of functions and enables debugging\nmode (pragma -debug):\n\n    use CGI::Simple::Standard qw(:standard -debug);\n\nThe current list of pragmas is as follows:\n\n=over 4\n\n=item -no_undef_params\n\nIf a value is not given in the query string, as in the queries\n\"name1=&name2=\" or \"name1&name2\", by default it will be returned\nas an empty string.\n\nIf you specify the '-no_undef_params' pragma then CGI::Simple ignores\nparameters with no values and they will not appear in the query object.\n\n=item -nph\n\nThis makes CGI.pm produce a header appropriate for an NPH (no\nparsed header) script.  You may need to do other things as well\nto tell the server that the script is NPH.  See the discussion\nof NPH scripts below.\n\n=item -newstyle_urls\n\nSeparate the name=value pairs in CGI parameter query strings with\nsemicolons rather than ampersands.  For example:\n\n    ?name=fred;age=24;favorite_color=3\n\nSemicolon-delimited query strings are always accepted, but will not be\nemitted by self_url() and query_string() unless the -newstyle_urls\npragma is specified.\n\n=item -oldstyle_urls\n\nSeparate the name=value pairs in CGI parameter query strings with\nampersands rather than semicolons.  This is the default.\n\n    ?name=fred&age=24&favorite_color=3\n\n=item -autoload\n\nThis is only available for CGI::Simple::Standard and uses AUTOLOAD to\nload functions on demand. See the CGI::Simple::Standard docs for details.\n\n=item -no_debug\n\nThis turns off the command-line processing features. This is the default.\n\n=item -debug1 and debug2\n\nThis turns on debugging.  At debug level 1 CGI::Simple will read arguments\nfrom the command-line. At debug level 2 CGI.pm will produce the prompt\n\"(offline mode: enter name=value pairs on standard input)\" and wait for\ninput on STDIN. If no number is specified then a debug level of 2 is used.\n\nSee the section on debugging for more details.\n\n=item -default\n\nThis sets the default global values for CGI.pm which will enable infinite\nsize file uploads, and specify the '-newstyle_urls' and '-debug1' pragmas\n\n=item -no_upload\n\nDisable uploads - the default setting\n\n=item - upload\n\nEnable uploads - the CGI.pm default\n\n=item -unique_header\n\nOnly allows headers to be generated once per script invocation\n\n=item -carp\n\nCarp when B<cgi_error()> called, default is to do nothing\n\n=item -croak\n\nCroak when B<cgi_error()> called, default is to do nothing\n\n=back\n\n=cut\n\n############### NPH Scripts ################\n\n=head1 USING NPH SCRIPTS\n\nNPH, or \"no-parsed-header\", scripts bypass the server completely by\nsending the complete HTTP header directly to the browser.  This has\nslight performance benefits, but is of most use for taking advantage\nof HTTP extensions that are not directly supported by your server,\nsuch as server push and PICS headers.\n\nServers use a variety of conventions for designating CGI scripts as\nNPH.  Many Unix servers look at the beginning of the script's name for\nthe prefix \"nph-\".  The Macintosh WebSTAR server and Microsoft's\nInternet Information Server, in contrast, try to decide whether a\nprogram is an NPH script by examining the first line of script output.\n\nCGI.pm supports NPH scripts with a special NPH mode.  When in this\nmode, CGI.pm will output the necessary extra header information when\nthe B<header()> and B<redirect()> methods are called. You can set NPH mode\nin any of the following ways:\n\n=over 4\n\n=item In the B<use> statement\n\nSimply add the \"-nph\" pragma to the use:\n\n    use CGI::Simple qw(-nph)\n\n=item By calling the B<nph()> method:\n\nCall B<nph()> with a non-zero parameter at any point after using CGI.pm in your program.\n\n    $q->nph(1)\n\n=item By using B<-nph> parameters\n\nin the B<header()> and B<redirect()>  statements:\n\n    print $q->header(-nph=>1);\n\n=back\n\nThe Microsoft Internet Information Server requires NPH mode.\nCGI::Simple will automatically detect when the script is\nrunning under IIS and put itself into this mode.  You do not need to\ndo this manually, although it won't hurt anything if you do.  However,\nnote that if you have applied Service Pack 6, much of the\nfunctionality of NPH scripts, including the ability to redirect while\nsetting a cookie, b<do not work at all> on IIS without a special patch\nfrom Microsoft.  See\nhttp://support.microsoft.com/support/kb/articles/Q280/3/41.ASP:\nNon-Parsed Headers Stripped From CGI Applications That Have nph-\nPrefix in Name.\n\n=cut\n\n################# Server Push Methods #################\n\n=head1 SERVER PUSH\n\nCGI.pm provides four simple functions for producing multipart\ndocuments of the type needed to implement server push.  These\nfunctions were graciously provided by Ed Jordan <ed@fidalgo.net> with\nadditions from Andrew Benham <adsb@bigfoot.com>\n\nYou are also advised to put the script into NPH mode and to set $| to\n1 to avoid buffering problems.\n\nBrowser support for server push is variable.\n\nHere is a simple script that demonstrates server push:\n\n    #!/usr/local/bin/perl\n    use CGI::Simple::Standard qw/:push -nph/;\n    $| = 1;\n    print multipart_init(-boundary=>'----here we go!');\n    foreach (0 .. 4) {\n        print multipart_start(-type=>'text/plain'),\n        \"The current time is \",scalar(localtime),\"\\n\";\n        if ($_ < 4) {\n            print multipart_end;\n        }\n        else {\n            print multipart_final;\n        }\n        sleep 1;\n    }\n\nThis script initializes server push by calling B<multipart_init()>.\nIt then enters a loop in which it begins a new multipart section by\ncalling B<multipart_start()>, prints the current local time,\nand ends a multipart section with B<multipart_end()>.  It then sleeps\na second, and begins again. On the final iteration, it ends the\nmultipart section with B<multipart_final()> rather than with\nB<multipart_end()>.\n\n=head2 multipart_init() Initialize the multipart system\n\n    multipart_init(-boundary=>$boundary);\n\nInitialize the multipart system.  The -boundary argument specifies\nwhat MIME boundary string to use to separate parts of the document.\nIf not provided, CGI.pm chooses a reasonable boundary for you.\n\n=head2 multipart_start() Start a new part of the multipart document\n\n    multipart_start(-type=>$type)\n\nStart a new part of the multipart document using the specified MIME\ntype.  If not specified, text/html is assumed.\n\n=head2 multipart_end() End a multipart part\n\n    multipart_end()\n\nEnd a part.  You must remember to call B<multipart_end()> once for each\nB<multipart_start()>, except at the end of the last part of the multipart\ndocument when B<multipart_final()> should be called instead of\nB<multipart_end()>.\n\n=head2 multipart_final()\n\n    multipart_final()\n\nEnd all parts.  You should call B<multipart_final()> rather than\nB<multipart_end()> at the end of the last part of the multipart document.\n\n=head2 CGI::Push\n\nUsers interested in server push applications should also have a look\nat the B<CGI::Push> module.\n\n=cut\n\n################# Debugging Methods ################\n\n=head1 DEBUGGING\n\nIf you are running the script from the command line or in the perl\ndebugger, you can pass the script a list of keywords or\nparameter=value pairs on the command line or from standard input (you\ndon't have to worry about tricking your script into reading from\nenvironment variables).  Before you do this you will need to change the\ndebug level from the default level of 0 (no debug) to either 1 if you\nwant to debug from @ARGV (the command line) of 2 if you want to debug from\nSTDIN. You can do this using the debug pragma like this:\n\n    use CGI::Simple qw(-debug2);  # set debug to level 2 => from STDIN\n\n        or this:\n\n    $CGI::Simple::DEBUG = 1;      # set debug to level 1 => from @ARGV\n\nAt debug level 1 you can pass keywords and name=value pairs like this:\n\n    your_script.pl keyword1 keyword2 keyword3\n\n        or this:\n\n    your_script.pl keyword1+keyword2+keyword3\n\n        or this:\n\n    your_script.pl name1=value1 name2=value2\n\n        or this:\n\n    your_script.pl name1=value1&name2=value2\n\nAt debug level 2 you can feed newline-delimited name=value\npairs to the script on standard input. You will be presented\nwith the following prompt:\n\n    (offline mode: enter name=value pairs on standard input)\n\nYou end the input with your system dependent end of file character.\nYou should try ^Z ^X ^D and ^C if all else fails. The ^ means hold down\nthe [Ctrl] button while you press the other key.\n\nWhen debugging, you can use quotes and backslashes to escape\ncharacters in the familiar shell manner, letting you place\nspaces and other funny characters in your parameter=value\npairs:\n\n    your_script.pl \"name1='I am a long value'\" \"name2=two\\ words\"\n\n=head2 Dump() Dumping the current object details\n\nThe B<Dump()> method produces a string consisting of all the\nquery's object attributes formatted nicely as a nested list.  This dump\nincludes the name/value pairs and a number of other details. This is useful\nfor debugging purposes:\n\n    print $q->Dump\n\nThe actual result of this is HTML escaped formatted text wrapped in <pre> tags\nso if you send it straight to the browser it produces something that looks\nlike:\n\n    $VAR1 = bless( {\n         '.parameters' => [\n                            'name',\n                            'color'\n                          ],\n         '.globals' => {\n                         'FATAL' => -1,\n                         'DEBUG' => 0,\n                         'NO_NULL' => 1,\n                         'POST_MAX' => 102400,\n                         'USE_CGI_PM_DEFAULTS' => 0,\n                         'HEADERS_ONCE' => 0,\n                         'NPH' => 0,\n                         'DISABLE_UPLOADS' => 1,\n                         'NO_UNDEF_PARAMS' => 0,\n                         'USE_PARAM_SEMICOLONS' => 0\n                       },\n         '.fieldnames' => {\n                            'color' => '1',\n                            'name' => '1'\n                          },\n         '.mod_perl' => '',\n         'color' => [\n                      'red',\n                      'green',\n                      'blue'\n                    ],\n         'name' => [\n                     'JaPh,'\n                   ]\n        }, 'CGI::Simple' );\n\nYou may recognize this as valid Perl syntax (which it is) and/or the output\nfrom Data::Dumper (also true). This is the actual guts of how the information\nis stored in the query object. All the internal params start with a . char\n\nAlternatively you can dump your object and the current environment using:\n\n    print $q->Dump(\\%ENV);\n\n=head2 PrintEnv() Dumping the environment\n\nYou can get a similar browser friendly dump of the current %ENV hash using:\n\n    print $q->PrintEnv;\n\nThis will produce something like (in the browser):\n\n    $VAR1 = {\n          'QUERY_STRING' => 'name=JaPh%2C&color=red&color=green&color=blue',\n          'CONTENT_TYPE' => 'application/x-www-form-urlencoded',\n          'REGRESSION_TEST' => 'simple.t.pl',\n          'VIM' => 'C:\\\\WINDOWS\\\\Desktop\\\\vim',\n          'HTTP_REFERER' => 'xxx.sex.com',\n          'HTTP_USER_AGENT' => 'LWP',\n          'HTTP_ACCEPT' => 'text/html;q=1, image/gif;q=0.42, */*;q=0.001',\n          'REMOTE_HOST' => 'localhost',\n          'HTTP_HOST' => 'the.restaurant.at.the.end.of.the.universe',\n          'GATEWAY_INTERFACE' => 'bleeding edge',\n          'REMOTE_IDENT' => 'None of your damn business',\n          'SCRIPT_NAME' => '/cgi-bin/foo.cgi',\n          'SERVER_NAME' => 'nowhere.com',\n          'HTTP_COOKIE' => '',\n          'CONTENT_LENGTH' => '42',\n          'HTTPS_A' => 'A',\n          'HTTP_FROM' => 'spammer@nowhere.com',\n          'HTTPS_B' => 'B',\n          'SERVER_PROTOCOL' => 'HTTP/1.0',\n          'PATH_TRANSLATED' => '/usr/local/somewhere/else',\n          'SERVER_SOFTWARE' => 'Apache - accept no substitutes',\n          'PATH_INFO' => '/somewhere/else',\n          'REMOTE_USER' => 'Just another Perl hacker,',\n          'REMOTE_ADDR' => '127.0.0.1',\n          'HTTPS' => 'ON',\n          'DOCUMENT_ROOT' => '/vs/www/foo',\n          'REQUEST_METHOD' => 'GET',\n          'REDIRECT_QUERY_STRING' => '',\n          'AUTH_TYPE' => 'PGP MD5 DES rot13',\n          'COOKIE' => 'foo=a%20phrase; bar=yes%2C%20a%20phrase&;I%20say;',\n          'SERVER_PORT' => '8080'\n        };\n\n\n=head2 cgi_error() Retrieving CGI::Simple error messages\n\nErrors can occur while processing user input, particularly when\nprocessing uploaded files.  When these errors occur, CGI::Simple will stop\nprocessing and return an empty parameter list.  You can test for\nthe existence and nature of errors using the B<cgi_error()> function.\nThe error messages are formatted as HTTP status codes. You can either\nincorporate the error text into an HTML page, or use it as the value\nof the HTTP status:\n\n    my $error = $q->cgi_error;\n    if ($error) {\n        print $q->header(-status=>$error);\n        print \"<H2>$error</H2>;\n      exit;\n    }\n\n=cut\n\n############### Accessor Methods ################\n\n=head1 ACCESSOR METHODS\n\n=head2 version() Get the CGI::Simple version info\n\n    $version = $q->version();\n\nThe B<version()> method returns the value of $VERSION\n\n=head2 nph() Enable/disable NPH (Non Parsed Header) mode\n\n    $q->nph(1);  # enable NPH mode\n    $q->nph(0);  # disable NPH mode\n\nThe B<nph()> method enables and disables NPH headers. See the NPH section.\n\n=head2 all_parameters() Get the names/values of all parameters\n\n    @all_parameters = $q->all_parameters();\n\nThe B<all_parameters()> method is an alias for B<param()>\n\n=head2 charset() Get/set the current character set.\n\n    $charset = $q->charset(); # get current charset\n    $q->charset('utf-42');    # set the charset\n\nThe B<charset()> method gets the current charset value if no argument is\nsupplied or sets it if an argument is supplied.\n\n=head2 crlf() Get the system specific line ending sequence\n\n    $crlf = $q->crlf();\n\nThe B<crlf()> method returns the system specific line ending sequence.\n\n=head2 globals() Get/set the value of the remaining global variables\n\n    $globals = $q->globals('FATAL');     # get the current value of $FATAL\n    $globals = $q->globals('FATAL', 1 ); # set croak mode on cgi_error()\n\nThe B<globals()> method gets/sets the values of the global variables after the\nscript has been invoked. For globals like $POST_MAX and $DISABLE_UPLOADS this\nmakes no difference as they must be set prior to calling the new constructor\nbut there might be reason the change the value of others.\n\n=head2 auth_type() Get the current authorization/verification method\n\n    $auth_type = $q->auth_type();\n\nThe B<auth_type()> method returns the value of $ENV{'AUTH_TYPE'} which should\ncontain the authorization/verification method in use for this script, if any.\n\n=head2 content_length() Get the content length submitted in a POST\n\n    $content_length = $q->content_length();\n\nThe B<content_length()> method returns the value of $ENV{'AUTH_TYPE'}\n\n=head2 content_type() Get the content_type of data submitted in a POST\n\n    $content_type = $q->content_type();\n\nThe B<content_type()> method returns the content_type of data submitted in\na POST, generally 'multipart/form-data' or\n'application/x-www-form-urlencoded' as supplied in $ENV{'CONTENT_TYPE'}\n\n=head2 document_root() Get the document root\n\n    $document_root = $q->document_root();\n\nThe B<document_root()> method returns the value of $ENV{'DOCUMENT_ROOT'}\n\n=head2 gateway_interface() Get the gateway interface\n\n    $gateway_interface = $q->gateway_interface();\n\nThe B<gateway_interface()> method returns the value of\n$ENV{'GATEWAY_INTERFACE'}\n\n=head2 path_translated() Get the value of path translated\n\n    $path_translated = $q->path_translated();\n\nThe B<path_translated()> method returns the value of $ENV{'PATH_TRANSLATED'}\n\n=head2 referer() Spy on your users\n\n    $referer = $q->referer();\n\nThe B<referer()> method returns the value of $ENV{'REFERER'} This will return\nthe URL of the page the browser was viewing prior to fetching your script.\nNot available for all browsers.\n\n=head2 remote_addr() Get the remote address\n\n    $remote_addr = $q->remote_addr();\n\nThe B<remote_addr()> method returns the value of $ENV{'REMOTE_ADDR'} or\n127.0.0.1 (localhost) if this is not defined.\n\n=head2 remote_host() Get a value for remote host\n\n    $remote_host = $q->remote_host();\n\nThe B<remote_host()> method returns the value of $ENV{'REMOTE_HOST'} if it is\ndefined. If this is not defined it returns $ENV{'REMOTE_ADDR'} If this is not\ndefined it returns 'localhost'\n\n=head2 remote_ident() Get the remote identity\n\n    $remote_ident = $q->remote_ident();\n\nThe B<remote_ident()> method returns the value of $ENV{'REMOTE_IDENT'}\n\n=head2 remote_user() Get the remote user\n\n    $remote_user = $q->remote_user();\n\nThe B<remote_user()> method returns the authorization/verification name used\nfor user verification, if this script is protected. The value comes from\n$ENV{'REMOTE_USER'}\n\n=head2 request_method() Get the request method\n\n    $request_method = $q->request_method();\n\nThe B<request_method()> method returns the method used to access your\nscript, usually one of 'POST', 'GET' or 'HEAD' as supplied by\n$ENV{'REQUEST_METHOD'}\n\n=head2 script_name() Get the script name\n\n    $script_name = $q->script_name();\n\nThe B<script_name()> method returns the value of $ENV{'SCRIPT_NAME'} if it is\ndefined. Otherwise it returns Perl's script name from $0. Failing this it\nreturns a null string ''\n\n=head2 server_name() Get the server name\n\n    $server_name = $q->server_name();\n\nThe B<server_name()> method returns the value of $ENV{'SERVER_NAME'} if defined\nor 'localhost' otherwise\n\n=head2 server_port() Get the port the server is listening on\n\n    $server_port = $q->server_port();\n\nThe B<server_port()> method returns the value $ENV{'SERVER_PORT'} if defined or\n80 if not.\n\n=head2 server_protocol() Get the current server protocol\n\n    $server_protocol = $q->server_protocol();\n\nThe B<server_protocol()> method returns the value of $ENV{'SERVER_PROTOCOL'} if\ndefined or 'HTTP/1.0' otherwise\n\n=head2 server_software() Get the server software\n\n    $server_software = $q->server_software();\n\nThe B<server_software()> method returns the value $ENV{'SERVER_SOFTWARE'} or\n'cmdline' If the server software is IIS it formats your hard drive, installs\nLinux, FTPs to www.apache.org, installs Apache, and then restores your system\nfrom tape. Well maybe not, but it's a nice thought.\n\n=head2 user_name() Get a value for the user name.\n\n    $user_name = $q->user_name();\n\nAttempt to obtain the remote user's name, using a variety of different\ntechniques.  This only works with older browsers such as Mosaic.\nNewer browsers do not report the user name for privacy reasons!\n\nTechnically the B<user_name()> method returns the value of $ENV{'HTTP_FROM'}\nor failing that $ENV{'REMOTE_IDENT'} or as a last choice $ENV{'REMOTE_USER'}\n\n=head2 user_agent() Get the users browser type\n\n    $ua = $q->user_agent();          # return the user agent\n    $ok = $q->user_agent('mozilla'); # return true if user agent 'mozilla'\n\nThe B<user_agent()> method returns the value of $ENV{'HTTP_USER_AGENT'}  when\ncalled without an argument or true or false if the $ENV{'HTTP_USER_AGENT'}\nmatches the passed argument. The matching is case insensitive and partial.\n\n=head2 virtual_host() Get the virtual host\n\n    $virtual_host = $q->virtual_host();\n\nThe B<virtual_host()> method returns the value of  $ENV{'HTTP_HOST'} if defined\nor $ENV{'SERVER_NAME'} as a default. Port numbers are removed.\n\n=head2 path_info() Get any extra path info set to the script\n\n    $path_info = $q->path_info();\n\nThe B<path_info()> method returns additional path information from the script\nURL. E.G. fetching /cgi-bin/your_script/additional/stuff will result in\n$q->path_info() returning \"/additional/stuff\".\n\nNOTE: The Microsoft Internet Information Server\nis broken with respect to additional path information.  If\nyou use the Perl DLL library, the IIS server will attempt to\nexecute the additional path information as a Perl script.\nIf you use the ordinary file associations mapping, the\npath information will be present in the environment,\nbut incorrect.  The best thing to do is to avoid using additional\npath information in CGI scripts destined for use with IIS.\n\n=head2 Accept() Get the browser MIME types\n\n    $Accept = $q->Accept();\n\nThe B<Accept()> method returns a list of MIME types that the remote browser\naccepts. If you give this method a single argument corresponding to a\nMIME type, as in $q->Accept('text/html'), it will return a floating point\nvalue corresponding to the browser's preference for this type from 0.0\n(don't want) to 1.0.  Glob types (e.g. text/*) in the browser's accept\nlist are handled correctly.\n\n=head2 accept() Alias for Accept()\n\n    $accept = $q->accept();\n\nThe B<accept()> Method is an alias for Accept()\n\n=head2 http() Get a range of HTTP related information\n\n    $http = $q->http();\n\nCalled with no arguments the B<http()> method returns the list of HTTP or HTTPS\nenvironment variables, including such things as HTTP_USER_AGENT,\nHTTP_ACCEPT_LANGUAGE, and HTTP_ACCEPT_CHARSET, corresponding to the\nlike-named HTTP header fields in the request. Called with the name of\nan HTTP header field, returns its value.  Capitalization and the use\nof hyphens versus underscores are not significant.\n\nFor example, all three of these examples are equivalent:\n\n   $requested_language = $q->http('Accept-language');\n   $requested_language = $q->http('Accept_language');\n   $requested_language = $q->http('HTTP_ACCEPT_LANGUAGE');\n\n=head2 https() Get a range of HTTPS related information\n\n    $https = $q->https();\n\nThe B<https()> method is similar to the http() method except that when called\nwithout an argument it returns the value of $ENV{'HTTPS'} which will be\ntrue if a HTTPS connection is in use and false otherwise.\n\n=head2 protocol() Get the current protocol\n\n    $protocol = $q->protocol();\n\nThe B<protocol()> method returns 'https' if a HTTPS connection is in use or the\nB<server_protocol()> minus version numbers ('http') otherwise.\n\n=head2 url() Return the script's URL in several formats\n\n    $full_url      = $q->url();\n    $full_url      = $q->url(-full=>1);\n    $relative_url  = $q->url(-relative=>1);\n    $absolute_url  = $q->url(-absolute=>1);\n    $url_with_path = $q->url(-path_info=>1);\n    $url_with_path_and_query = $q->url(-path_info=>1,-query=>1);\n    $netloc        = $q->url(-base => 1);\n\nB<url()> returns the script's URL in a variety of formats.  Called\nwithout any arguments, it returns the full form of the URL, including\nhost name and port number\n\n    http://your.host.com/path/to/script.cgi\n\nYou can modify this format with the following named arguments:\n\n=over 4\n\n=item B<-absolute>\n\nIf true, produce an absolute URL, e.g.\n\n    /path/to/script.cgi\n\n=item B<-relative>\n\nProduce a relative URL.  This is useful if you want to reinvoke your\nscript with different parameters. For example:\n\n    script.cgi\n\n=item B<-full>\n\nProduce the full URL, exactly as if called without any arguments.\nThis overrides the -relative and -absolute arguments.\n\n=item B<-path> (B<-path_info>)\n\nAppend the additional path information to the URL.  This can be\ncombined with B<-full>, B<-absolute> or B<-relative>.  B<-path_info>\nis provided as a synonym.\n\n=item B<-query> (B<-query_string>)\n\nAppend the query string to the URL.  This can be combined with\nB<-full>, B<-absolute> or B<-relative>.  B<-query_string> is provided\nas a synonym.\n\n=item B<-base>\n\nGenerate just the protocol and net location, as in http://www.foo.com:8000\n\n=back\n\n=head2 self_url() Get the scripts complete URL\n\n    $self_url = $q->self_url();\n\nThe B<self_url()> method returns the value of:\n\n   $self->url( '-path_info'=>1, '-query'=>1, '-full'=>1 );\n\n=head2 state() Alias for self_url()\n\n    $state = $q->state();\n\nThe B<state()> method is an alias for self_url()\n\n=cut\n\n################# cgi-lib.pl Compatibility Methods #################\n\n=head1 COMPATIBILITY WITH cgi-lib.pl 2.18\n\nTo make it easier to port existing programs that use cgi-lib.pl all\nthe subs within cgi-lib.pl are available in CGI::Simple.  Using the\nfunctional interface of CGI::Simple::Standard porting is\nas easy as:\n\n    OLD VERSION\n        require \"cgi-lib.pl\";\n        &ReadParse;\n        print \"The value of the antique is $in{'antique'}.\\n\";\n\n    NEW VERSION\n        use CGI::Simple::Standard qw(:cgi-lib);\n        &ReadParse;\n        print \"The value of the antique is $in{'antique'}.\\n\";\n\nCGI:Simple's B<ReadParse()> routine creates a variable named %in,\nwhich can be accessed to obtain the query variables.  Like\nReadParse, you can also provide your own variable via a glob. Infrequently\nused features of B<ReadParse()>, such as the creation of @in and $in\nvariables, are not supported.\n\nYou can also use the OO interface of CGI::Simple and call B<ReadParse()> and\nother cgi-lib.pl functions like this:\n\n    &CGI::Simple::ReadParse;       # get hash values in %in\n\n    my $q = new CGI::Simple;\n    $q->ReadParse();                # same thing\n\n    CGI::Simple::ReadParse(*field); # get hash values in %field function style\n\n    my $q = new CGI::Simple;\n    $q->ReadParse(*field);          # same thing\n\nOnce you use B<ReadParse()> under the functional interface , you can retrieve\nthe query object itself this way if needed:\n\n    $q = $in{'CGI'};\n\nEither way it allows you to start using the more interesting features\nof CGI.pm without rewriting your old scripts from scratch.\n\nUnlike CGI.pm all the cgi-lib.pl functions from Version 2.18 are supported:\n\n    ReadParse()\n    SplitParam()\n    MethGet()\n    MethPost()\n    MyBaseUrl()\n    MyURL()\n    MyFullUrl()\n    PrintHeader()\n    HtmlTop()\n    HtmlBot()\n    PrintVariables()\n    PrintEnv()\n    CgiDie()\n    CgiError()\n\n=head1 COMPATIBILITY WITH CGI.pm\n\nI has long been suggested that the CGI and HTML parts of CGI.pm should be\nsplit into separate modules (even the author suggests this!), CGI::Simple\nrepresents the realization of this and contains the complete CGI side of\nCGI.pm. Code-wise it weighs in at a little under 30% of the size of CGI.pm at\na little under 1000 lines.\n\nA great deal of care has been taken to ensure that the interface remains\nunchanged although a few tweaks have been made. The test suite is extensive\nand includes all the CGI.pm test scripts as well as a series of new test\nscripts. You may like to have a look at /t/concur.t which makes 160 tests\nof CGI::Simple and CGI in parallel and compares the results to ensure they\nare identical. This is the case as of CGI.pm 2.78.\n\nYou can't make an omelet without breaking eggs. A large number of methods\nand global variables have been deleted as detailed below. Some pragmas are\nalso gone. In the tarball there is a script B</misc/check.pl> that will check if\na script seems to be using any of these now non existent methods, globals or\npragmas. You call it like this:\n\n    perl check.pl <files>\n\nIf it finds any likely candidates it will print a line with the line number,\nproblem method/global and the complete line. For example here is some output\nfrom running the script on CGI.pm:\n\n    ...\n    3162: Problem:'$CGI::OS'   local($CRLF) = \"\\015\\012\" if $CGI::OS eq 'VMS';\n    3165: Problem:'fillBuffer' $self->fillBuffer($FILLUNIT);\n    ....\n\n=head1 DIFFERENCES FROM CGI.pm\n\nCGI::Simple is strict and warnings compliant.\n\nThere are 4 modules in this distribution:\n\n    CGI/Simple.pm           supplies all the core code.\n    CGI/Simple/Cookie.pm    supplies the cookie handling functions.\n    CGI/Simple/Util.pm      supplies a variety of utility functions\n    CGI/Simple/Standard.pm  supplies a functional interface for Simple.pm\n\nSimple.pm is the core module that provide all the essential functionality.\nCookie.pm is a shortened rehash of the CGI.pm module of the same name\nwhich supplies the required cookie functionality. Util.pm has been recoded to\nuse an internal object for data storage and supplies rarely needed non core\nfunctions and/or functions needed for the HTML side of things. Standard.pm is\na wrapper module that supplies a complete functional interface to the OO\nback end supplied by CGI::Simple.\n\nAlthough a serious attempt has been made to keep the interface identical,\nsome minor changes and tweaks have been made. They will likely be\ninsignificant to most users but here are the gory details.\n\n=head2 Globals Variables\n\nThe list of global variables has been pruned by 75%. Here is the complete\nlist of the global variables used:\n\n    $VERSION = \"0.01\";\n    # set this to 1 to use CGI.pm default global settings\n    $USE_CGI_PM_DEFAULTS = 0 unless defined $USE_CGI_PM_DEFAULTS;\n    # see if user wants old  CGI.pm defaults\n    do{ _use_cgi_pm_global_settings(); return } if $USE_CGI_PM_DEFAULTS;\n    # no file uploads by default, set to 0 to enable uploads\n    $DISABLE_UPLOADS = 1 unless defined $DISABLE_UPLOADS;\n    # use a post max of 100K, set to -1 for no limits\n    $POST_MAX = 102_400 unless defined $POST_MAX;\n    # do not include undefined params parsed from query string\n    $NO_UNDEF_PARAMS = 0 unless defined $NO_UNDEF_PARAMS;\n    # separate the name=value pairs with ; rather than &\n    $USE_PARAM_SEMICOLONS = 0 unless defined $USE_PARAM_SEMICOLONS;\n    # only print headers once\n    $HEADERS_ONCE = 0 unless defined $HEADERS_ONCE;\n    # Set this to 1 to enable NPH scripts\n    $NPH = 0 unless defined $NPH;\n    # 0 => no debug, 1 => from @ARGV,  2 => from STDIN\n    $DEBUG = 0 unless defined $DEBUG;\n    # filter out null bytes in param - value pairs\n    $NO_NULL  = 1 unless defined $NO_NULL;\n    # set behavior when cgi_err() called -1 => silent, 0 => carp, 1 => croak\n    $FATAL = -1 unless defined $FATAL;\n\nFour of the default values of the old CGI.pm variables have been changed.\nUnlike CGI.pm which by default allows unlimited POST data and file uploads\nby default CGI::Simple limits POST data size to 100kB and denies file uploads\nby default. $USE_PARAM_SEMICOLONS is set to 0 by default so we use (old style)\n& rather than ; as the pair separator for query strings. Debugging is\ndisabled by default.\n\nThere are three new global variables. If $NO_NULL is true (the default) then\nCGI::Simple will strip null bytes out of names, values and keywords. Null\nbytes can do interesting things to C based code like Perl. Uploaded files\nare not touched. $FATAL controls the behavior when B<cgi_error()> is called.\nThe default value of -1 makes errors silent. $USE_CGI_PM_DEFAULTS reverts the\ndefaults to the CGI.pm standard values ie unlimited file uploads via POST\nfor DNS attacks. You can also get the defaults back by using the '-default'\npragma in the use:\n\n    use CGI::Simple qw(-default);\n    use CGI::Simple::Standard qw(-default);\n\nThe values of the global variables are stored in the CGI::Simple object and\ncan be referenced and changed using the B<globals()> method like this:\n\n    my $value = $q->globals( 'VARNAME' );      # get\n    $q->globals( 'VARNAME', 'some value' );    # set\n\nAs with many CGI.pm methods if you pass the optional value that will\nbe set.\n\nThe $CGI::Simple::VARNAME = 'N' syntax is only useful prior to calling the\nB<new()> constructor. After that all reference is to the values stored in the\nCGI::Simple object so you must change these using the B<globals()> method.\n\n$DISABLE_UPLOADS and $POST_MAX *must* be set prior to calling the constructor\nif you want the changes to have any effect as they control behavior during\ninitialization. This is the same a CGI.pm although some people seem to miss\nthis rather important point and set these after calling the constructor which\ndoes nothing.\n\nThe following globals are no longer relevant and have all been deleted:\n\n    $AUTOLOADED_ROUTINES\n    $AUTOLOAD_DEBUG\n    $BEEN_THERE\n    $CRLF\n    $DEFAULT_DTD\n    $EBCDIC\n    $FH\n    $FILLUNIT\n    $IIS\n    $IN\n    $INITIAL_FILLUNIT\n    $JSCRIPT\n    $MAC\n    $MAXTRIES\n    $MOD_PERL\n    $NOSTICKY\n    $OS\n    $PERLEX\n    $PRIVATE_TEMPFILES\n    $Q\n    $QUERY_CHARSET\n    $QUERY_PARAM\n    $SCRATCH\n    $SL\n    $SPIN_LOOP_MAX\n    $TIMEOUT\n    $TMPDIRECTORY\n    $XHTML\n    %EXPORT\n    %EXPORT_OK\n    %EXPORT_TAGS\n    %OVERLOAD\n    %QUERY_FIELDNAMES\n    %SUBS\n    @QUERY_PARAM\n    @TEMP\n\nNotes: CGI::Simple uses IO::File->new_tmpfile to get tempfile filehandles.\nThese are private by default so $PRIVATE_TEMPFILES is no longer required nor\nis $TMPDIRECTORY. The value that were stored in $OS, $CRLF, $QUERY_CHARSET\nand $EBCDIC are now stored in the CGI::Simple::Util object where they find\nmost of their use. The $MOD_PERL and $PERLEX values are now stored in our\nCGI::Simple object. $IIS was only used once in path_info().  $SL the system\nspecific / \\ : path delimiter is not required as we let IO::File handle our\ntempfile requirements. The rest of the globals are HTML related, export\nrelated, hand rolled autoload related or serve obscure purposes in CGI.pm\n\n=head2 Changes to pragmas\n\nThere are some new pragmas available. See the pragmas section for details.\nThe following CGI.pm pragmas are not available:\n\n    -any\n    -compile\n    -nosticky\n    -no_xhtml\n    -private_tempfiles\n\n=head2 Filehandles\n\nUnlike CGI.pm which tries to accept all filehandle like objects only \\*FH\nand $fh are accepted by CGI::Simple as file accessors for B<new()> and B<save()>.\nIO::File objects work fine.\n\n=head2 Hash interface\n\n    %hash = $q->Vars();     # pack values with \"\\0\";\n    %hash = $q->Vars(\",\");  # comma separate values\n\nYou may optionally pass B<Vars()> a string that will be used to separate multiple\nvalues when they are packed into the single hash value. If no value is\nsupplied the default \"\\0\" (null byte) will be used. Null bytes are dangerous\nthings for C based code (ie Perl).\n\n=head2 cgi-lib.pl\n\nAll the cgi-lib.pl 2.18 routines are supported. Unlike CGI.pm all the\nsubroutines from cgi-lib.pl are included. They have been GOLFED down to\n25 lines but they all work pretty much the same as the originals.\n\n=head1 CGI::Simple COMPLETE METHOD LIST\n\nHere is a complete list of all the CGI::Simple methods.\n\n=head2 Guts (hands off, except of course for new)\n\n    _initialize_globals\n    _use_cgi_pm_global_settings\n    _store_globals\n    import\n    _reset_globals\n    new\n    _initialize\n    _read_parse\n    _parse_params\n    _add_param\n    _parse_keywordlist\n    _parse_multipart\n    _save_tmpfile\n    _read_data\n\n=head2 Core Methods\n\n    param\n    add_param\n    param_fetch\n    url_param\n    keywords\n    Vars\n    append\n    delete\n    Delete\n    delete_all\n    Delete_all\n    upload\n    upload_info\n    query_string\n    parse_query_string\n    parse_keywordlist\n\n=head2 Save and Restore from File Methods\n\n    _init_from_file\n    save\n    save_parameters\n\n=head2 Miscellaneous Methods\n\n    url_decode\n    url_encode\n    escapeHTML\n    unescapeHTML\n    put\n    print\n\n=head2 Cookie Methods\n\n    cookie\n    raw_cookie\n\n=head2 Header Methods\n\n    header\n    cache\n    no_cache\n    redirect\n\n=head2 Server Push Methods\n\n    multipart_init\n    multipart_start\n    multipart_end\n    multipart_final\n\n=head2 Debugging Methods\n\n    read_from_cmdline\n    Dump\n    as_string\n    cgi_error\n\n=head2 cgi-lib.pl Compatibility Routines - all 2.18 functions available\n\n    _shift_if_ref\n    ReadParse\n    SplitParam\n    MethGet\n    MethPost\n    MyBaseUrl\n    MyURL\n    MyFullUrl\n    PrintHeader\n    HtmlTop\n    HtmlBot\n    PrintVariables\n    PrintEnv\n    CgiDie\n    CgiError\n\n=head2 Accessor Methods\n\n    version\n    nph\n    all_parameters\n    charset\n    crlf                # new, returns OS specific CRLF sequence\n    globals             # get/set global variables\n    auth_type\n    content_length\n    content_type\n    document_root\n    gateway_interface\n    path_translated\n    referer\n    remote_addr\n    remote_host\n    remote_ident\n    remote_user\n    request_method\n    script_name\n    server_name\n    server_port\n    server_protocol\n    server_software\n    user_name\n    user_agent\n    virtual_host\n    path_info\n    Accept\n    accept\n    http\n    https\n    protocol\n    url\n    self_url\n    state\n\n=head1 NEW METHODS IN CGI::Simple\n\nThere are a few new methods in CGI::Simple as listed below. The highlights are\nthe B<parse_query_string()> method to add the QUERY_STRING data to your object if\nthe method was POST. The B<no_cache()> method adds an expires now directive and\nthe Pragma: no-cache directive to the header to encourage some browsers to\ndo the right thing. B<PrintEnv()> from the cgi-lib.pl routines will dump an\nHTML friendly list of the %ENV and makes a handy addition to B<Dump()> for use\nin debugging. The upload method now accepts a filepath as an optional second\nargument as shown in the synopsis. If this is supplied the uploaded file will\nbe written to there automagically.\n\n=head2 Internal Routines\n\n    _initialize_globals()\n    _use_cgi_pm_global_settings()\n    _store_globals()\n    _initialize()\n    _init_from_file()\n    _read_parse()\n    _parse_params()\n    _add_param()\n    _parse_keywordlist()\n    _parse_multipart()\n    _save_tmpfile()\n    _read_data()\n\n=head2 New Public Methods\n\n    add_param()             # adds a param/value(s) pair +/- overwrite\n    upload_info()           # uploaded files MIME type and size\n    url_decode()            # decode s url encoded string\n    url_encode()            # url encode a string\n    parse_query_string()    # add QUERY_STRING data to $q object if 'POST'\n    no_cache()              # add both the Pragma: no-cache\n                            # and Expires/Date => 'now' to header\n\n=head2  cgi-lib.pl methods added for completeness\n\n    _shift_if_ref()         # internal hack reminiscent of self_or_default :-)\n    MyBaseUrl()\n    MyURL()\n    MyFullUrl()\n    PrintVariables()\n    PrintEnv()\n    CgiDie()\n    CgiError()\n\n=head2 New Accessors\n\n    crlf()                  # returns CRLF sequence\n    globals()               # global vars now stored in $q object - get/set\n    content_length()        # returns $ENV{'CONTENT_LENGTH'}\n    document_root()         # returns $ENV{'DOCUMENT_ROOT'}\n    gateway_interface()     # returns $ENV{'GATEWAY_INTERFACE'}\n\n=head1 METHODS IN CGI.pm NOT IN CGI::Simple\n\nHere is a complete list of what is not included in CGI::Simple. Basically all\nthe HTML related stuff plus large redundant chunks of the guts. The check.pl\nscript in the /misc dir will check to see if a script is using any of these.\n\n=head2 Guts - rearranged, recoded, renamed and hacked out of existence\n\n    initialize_globals()\n    compile()\n    expand_tags()\n    self_or_default()\n    self_or_CGI()\n    init()\n    to_filehandle()\n    save_request()\n    parse_params()\n    add_parameter()\n    binmode()\n    _make_tag_func()\n    AUTOLOAD()\n    _compile()\n    _setup_symbols()\n    new_MultipartBuffer()\n    read_from_client()\n    import_names()     # I dislike this and left it out, so shoot me.\n\n=head2 HTML Related\n\n    autoEscape()\n    URL_ENCODED()\n    MULTIPART()\n    SERVER_PUSH()\n    start_html()\n    _style()\n    _script()\n    end_html()\n    isindex()\n    startform()\n    start_form()\n    end_multipart_form()\n    start_multipart_form()\n    endform()\n    end_form()\n    _textfield()\n    textfield()\n    filefield()\n    password_field()\n    textarea()\n    button()\n    submit()\n    reset()\n    defaults()\n    comment()\n    checkbox()\n    checkbox_group()\n    _tableize()\n    radio_group()\n    popup_menu()\n    scrolling_list()\n    hidden()\n    image_button()\n    nosticky()\n    default_dtd()\n\n=head2 Upload Related\n\nCGI::Simple uses anonymous tempfiles supplied by IO::File to spool uploaded\nfiles to.\n\n    private_tempfiles() # automatic in CGI::Simple\n    tmpFileName()       # all upload files are anonymous\n    uploadInfo()        # relied on FH access, replaced with upload_info()\n\n\n=head2 Really Private Subs (marked as so)\n\n    previous_or_default()\n    register_parameter()\n    get_fields()\n    _set_values_and_labels()\n    _compile_all()\n    asString()\n    compare()\n\n=head2 Internal Multipart Parsing Routines\n\n    read_multipart()\n    readHeader()\n    readBody()\n    read()\n    fillBuffer()\n    eof()\n\n=head1 EXPORT\n\nNothing.\n\n=head1 AUTHOR INFORMATION\n\nOriginally copyright 2001 Dr James Freeman E<lt>jfreeman@tassie.net.auE<gt>\nThis release by Andy Armstrong <andy@hexten.net>\n\nThis package is free software and is provided \"as is\" without express or\nimplied warranty. It may be used, redistributed and/or modified under the terms\nof the Perl Artistic License (see http://www.perl.com/perl/misc/Artistic.html)\n\nAddress bug reports and comments to: andy@hexten.net.  When sending\nbug reports, please provide the version of CGI::Simple, the version of\nPerl, the name and version of your Web server, and the name and\nversion of the operating system you are using.  If the problem is even\nremotely browser dependent, please provide information about the\naffected browsers as well.\n\nAddress bug reports and comments to: andy@hexten.net\n\n=head1 CREDITS\n\nLincoln D. Stein (lstein@cshl.org) and everyone else who worked on the\noriginal CGI.pm upon which this module is heavily based\n\nBrandon Black for some heavy duty testing and bug fixes\n\nJohn D Robinson and Jeroen Latour for helping solve some interesting test\nfailures as well as Perlmonks:\ntommyw, grinder, Jaap, vek, erasei, jlongino and strider_corinth\n\nThanks for patches to:\n\nEwan Edwards, Joshua N Pritikin, Mike Barry, Michael Nachbaur, Chris\nWilliams, Mark Stosberg, Krasimir Berov\n\n=head1 LICENCE AND COPYRIGHT\n\nCopyright (c) 2007, Andy Armstrong C<< <andy@hexten.net> >>. All rights reserved.\n\nThis module is free software; you can redistribute it and/or\nmodify it under the same terms as Perl itself. See L<perlartistic>.\n\n=head1 SEE ALSO\n\nB<CGI>, L<CGI::Simple::Standard>, L<CGI::Simple::Cookie>,\nL<CGI::Simple::Util>, L<CGI::Minimal>\n\n=cut\n\n", "use Test::More tests => 318;\nuse Carp;\nuse strict;\nuse vars qw(%field %in);\n\nuse CGI::Simple;\n\nmy ( $q, $sv, @av );\nmy $tmpfile = './cgi-tmpfile.tmp';\n\n$ENV{'AUTH_TYPE'}      = 'PGP MD5 DES rot13';\n$ENV{'CONTENT_LENGTH'} = '42';\n$ENV{'CONTENT_TYPE'}   = 'application/x-www-form-urlencoded';\n$ENV{'COOKIE'} = 'foo=a%20phrase; bar=yes%2C%20a%20phrase&I%20say;';\n$ENV{'DOCUMENT_ROOT'}     = '/vs/www/foo';\n$ENV{'GATEWAY_INTERFACE'} = 'bleeding edge';\n$ENV{'HTTPS'}             = 'ON';\n$ENV{'HTTPS_A'}           = 'A';\n$ENV{'HTTPS_B'}           = 'B';\n$ENV{'HTTP_ACCEPT'}\n = 'text/html;q=1, text/plain;q=0.8, image/jpg, image/gif;q=0.42, */*;q=0.001';\n$ENV{'HTTP_COOKIE'}     = '';\n$ENV{'HTTP_FROM'}       = 'spammer@nowhere.com';\n$ENV{'HTTP_HOST'}       = 'the.vatican.org';\n$ENV{'HTTP_REFERER'}    = 'xxx.sex.com';\n$ENV{'HTTP_USER_AGENT'} = 'LWP';\n$ENV{'PATH_INFO'}       = '/somewhere/else';\n$ENV{'PATH_TRANSLATED'} = '/usr/local/somewhere/else';\n$ENV{'QUERY_STRING'} = 'name=JaPh%2C&color=red&color=green&color=blue';\n$ENV{'REDIRECT_QUERY_STRING'} = '';\n$ENV{'REMOTE_ADDR'}           = '127.0.0.1';\n$ENV{'REMOTE_HOST'}           = 'localhost';\n$ENV{'REMOTE_IDENT'}          = 'None of your damn business';\n$ENV{'REMOTE_USER'}           = 'Just another Perl hacker,';\n$ENV{'REQUEST_METHOD'}        = 'GET';\n$ENV{'SCRIPT_NAME'}           = '/cgi-bin/foo.cgi';\n$ENV{'SERVER_NAME'}           = 'nowhere.com';\n$ENV{'SERVER_PORT'}           = '8080';\n$ENV{'SERVER_PROTOCOL'}       = 'HTTP/1.0';\n$ENV{'SERVER_SOFTWARE'}       = 'Apache - accept no substitutes';\n\n$q = new CGI::Simple;\n\nsub undef_globals {\n  undef $CGI::Simple::USE_CGI_PM_DEFAULTS;\n  undef $CGI::Simple::DISABLE_UPLOADS;\n  undef $CGI::Simple::POST_MAX;\n  undef $CGI::Simple::NO_UNDEF_PARAMS;\n  undef $CGI::Simple::USE_PARAM_SEMICOLONS;\n  undef $CGI::Simple::HEADERS_ONCE;\n  undef $CGI::Simple::NPH;\n  undef $CGI::Simple::DEBUG;\n  undef $CGI::Simple::NO_NULL;\n  undef $CGI::Simple::FATAL;\n}\n\nundef_globals();\n\n# _initialize_globals()\n$q->_initialize_globals();\nis( $CGI::Simple::USE_CGI_PM_DEFAULTS, 0, '_initialize_globals(), 1' );\nis( $CGI::Simple::DISABLE_UPLOADS,     1, '_initialize_globals(), 2' );\nis( $CGI::Simple::POST_MAX, 102_400, '_initialize_globals(), 3' );\nis( $CGI::Simple::NO_UNDEF_PARAMS,      0, '_initialize_globals(), 4' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 0, '_initialize_globals(), 5' );\nis( $CGI::Simple::HEADERS_ONCE,         0, '_initialize_globals(), 6' );\nis( $CGI::Simple::NPH,                  0, '_initialize_globals(), 7' );\nis( $CGI::Simple::DEBUG,                0, '_initialize_globals(), 8' );\nis( $CGI::Simple::NO_NULL,              1, '_initialize_globals(), 9' );\nis( $CGI::Simple::FATAL, -1, '_initialize_globals(), 10' );\nundef_globals();\n\n# _use_cgi_pm_global_settings()\n$q->_use_cgi_pm_global_settings();\nis( $CGI::Simple::DISABLE_UPLOADS, 0,\n  '_use_cgi_pm_global_settings(), 1' );\nis( $CGI::Simple::POST_MAX, -1, '_use_cgi_pm_global_settings(), 2' );\nis( $CGI::Simple::NO_UNDEF_PARAMS, 0,\n  '_use_cgi_pm_global_settings(), 3' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS,\n  1, '_use_cgi_pm_global_settings(), 4' );\nis( $CGI::Simple::HEADERS_ONCE, 0, '_use_cgi_pm_global_settings(), 5' );\nis( $CGI::Simple::NPH,          0, '_use_cgi_pm_global_settings(), 6' );\nis( $CGI::Simple::DEBUG,        1, '_use_cgi_pm_global_settings(), 7' );\nis( $CGI::Simple::NO_NULL,      0, '_use_cgi_pm_global_settings(), 8' );\nis( $CGI::Simple::FATAL, -1, '_use_cgi_pm_global_settings(), 9' );\n\n# _store_globals()\nundef %{$q};\n\nok( !defined $q->{'.globals'}->{'DISABLE_UPLOADS'},\n  '_store_globals(), 1' );\nok( !defined $q->{'.globals'}->{'POST_MAX'}, '_store_globals(), 2' );\nok( !defined $q->{'.globals'}->{'NO_UNDEF_PARAMS'},\n  '_store_globals(), 3' );\nok( !defined $q->{'.globals'}->{'USE_PARAM_SEMICOLONS'},\n  '_store_globals(), 4' );\nok( !defined $q->{'.globals'}->{'HEADERS_ONCE'},\n  '_store_globals(), 5' );\nok( !defined $q->{'.globals'}->{'NPH'},     '_store_globals(), 6' );\nok( !defined $q->{'.globals'}->{'DEBUG'},   '_store_globals(), 7' );\nok( !defined $q->{'.globals'}->{'NO_NULL'}, '_store_globals(), 8' );\nok( !defined $q->{'.globals'}->{'FATAL'},   '_store_globals(), 9' );\nok( !defined $q->{'.globals'}->{'USE_CGI_PM_DEFAULTS'},\n  '_store_globals(), 10' );\n$q->_store_globals();\n\nok( defined $q->{'.globals'}->{'DISABLE_UPLOADS'},\n  '_store_globals(), 11' );\nok( defined $q->{'.globals'}->{'POST_MAX'}, '_store_globals(), 12' );\nok( defined $q->{'.globals'}->{'NO_UNDEF_PARAMS'},\n  '_store_globals(), 13' );\nok( defined $q->{'.globals'}->{'USE_PARAM_SEMICOLONS'},\n  '_store_globals(), 14' );\nok( defined $q->{'.globals'}->{'HEADERS_ONCE'},\n  '_store_globals(), 15' );\nok( defined $q->{'.globals'}->{'NPH'},     '_store_globals(), 16' );\nok( defined $q->{'.globals'}->{'DEBUG'},   '_store_globals(), 17' );\nok( defined $q->{'.globals'}->{'NO_NULL'}, '_store_globals(), 18' );\nok( defined $q->{'.globals'}->{'FATAL'},   '_store_globals(), 19' );\nok( defined $q->{'.globals'}->{'USE_CGI_PM_DEFAULTS'},\n  '_store_globals(), 20' );\n\n# import() - used to set paragmas\nmy @args\n = qw( -default -no_upload -unique_header -nph -no_debug -newstyle_url -no_undef_param );\n\nundef_globals();\n\n$q->import( @args );\n\nis( $CGI::Simple::USE_CGI_PM_DEFAULTS,  1, 'import(), 1' );\nis( $CGI::Simple::DISABLE_UPLOADS,      1, 'import(), 2' );\nis( $CGI::Simple::NO_UNDEF_PARAMS,      1, 'import(), 3' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 1, 'import(), 4' );\nis( $CGI::Simple::HEADERS_ONCE,         1, 'import(), 5' );\nis( $CGI::Simple::NPH,                  1, 'import(), 6' );\nis( $CGI::Simple::DEBUG,                0, 'import(), 7' );\nundef_globals();\n\n$q->import( qw ( -upload -oldstyle_url  -debug  ) );\n\nis( $CGI::Simple::DISABLE_UPLOADS,      0, 'import(), 8' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 0, 'import(), 9' );\nis( $CGI::Simple::DEBUG,                2, 'import(), 10' );\nundef_globals();\n\n# _reset_globals()\n$q->_reset_globals();\nis( $CGI::Simple::DISABLE_UPLOADS,      0,  '_reset_globals(), 1' );\nis( $CGI::Simple::POST_MAX,             -1, '_reset_globals(), 2' );\nis( $CGI::Simple::NO_UNDEF_PARAMS,      0,  '_reset_globals(), 3' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 1,  '_reset_globals(), 4' );\nis( $CGI::Simple::HEADERS_ONCE,         0,  '_reset_globals(), 5' );\nis( $CGI::Simple::NPH,                  0,  '_reset_globals(), 6' );\nis( $CGI::Simple::DEBUG,                1,  '_reset_globals(), 7' );\nis( $CGI::Simple::NO_NULL,              0,  '_reset_globals(), 8' );\nis( $CGI::Simple::FATAL,                -1, '_reset_globals(), 9' );\nundef_globals();\n\n$q = new CGI::Simple;\n\n# url_decode() - scalar context, void argument\n$sv = $q->url_decode();\nis( $sv, undef, 'url_decode(), 1' );\n\n# url_decode() - scalar context, valid argument\nmy ( $string, $enc_string );\nfor ( 32 .. 255 ) {\n  $string .= chr;\n  $enc_string .= uc sprintf \"%%%02x\", ord chr;\n}\nis( $q->url_decode( $enc_string ),\n  $string, 'url_decode(\\$enc_string), 1' );\n\n# url_encode() - scalar context, void argument\n$sv = $q->url_encode();\nis( $sv, undef, 'url_encode(), 1' );\n\n# url_encode() - scalar context, valid argument\n$sv = $q->url_encode( $string );\n$sv =~ tr/+/ /;\n$sv =~ s/%([a-fA-F0-9]{2})/ pack \"C\", hex $1 /eg;\nis( $sv, $string, 'url_encode(\\$string), 1' );\n\n# url encoding - circular test\nis( $q->url_decode( $q->url_encode( $string ) ),\n  $string, 'url encoding via circular test, 1' );\n\n# new() plain constructor\n$q = CGI::Simple->new;\nlike( $q, qr/CGI::Simple/, 'new() plain constructor, 1' );\n\n# new('') empty constructor\n$q = new CGI::Simple( '' );\nlike( $q, qr/CGI::Simple/, 'new() empty constructor, 1' );\n$q = new CGI::Simple( {} );\nlike( $q, qr/CGI::Simple/, 'new() empty constructor, 2' );\n\n# new() hash constructor\n$q = new CGI::Simple( { 'foo' => '1', 'bar' => [ 2, 3, 4 ] } );\n@av = $q->param;\n\n# fix OS bug with testing\nis( join( ' ', sort @av ), 'bar foo', 'new() hash constructor, 1' );\nis( $q->param( 'foo' ), 1, 'new() hash constructor, 2' );\nis( $q->param( 'bar' ), 2, 'new() hash constructor, 3' );\n@av = $q->param( 'bar' );\nis( join( '', @av ), 234, 'new() hash constructor, 4' );\n$q = new CGI::Simple( 'foo=1&bar=2&bar=3&bar=4' );\nopen FH, \">$tmpfile\", or carp \"Can't create $tmpfile $!\\n\";\n$q->save( \\*FH );\nclose FH;\n\n# new() query string constructor\n$q  = new CGI::Simple( 'foo=5&bar=6&bar=7&bar=8' );\n@av = $q->param;\nis( join( ' ', @av ), 'foo bar', 'new() query string constructor, 1' );\nis( $q->param( 'foo' ), 5, 'new() query string constructor, 2' );\nis( $q->param( 'bar' ), 6, 'new() query string constructor, 3' );\n@av = $q->param( 'bar' );\nis( join( '', @av ), 678, 'new() query string constructor, 4' );\nopen FH, \">>$tmpfile\", or carp \"Can't append $tmpfile $!\\n\";\n$q->save_parameters( \\*FH );\nclose FH;\n\n# new() CGI::Simple object constructor\n\nmy $q_old = new CGI::Simple( 'foo=1&bar=2&bar=3&bar=4' );\nmy $q_new = new CGI::Simple( $q_old );\nis( $q_old->query_string, 'foo=1&bar=2&bar=3&bar=4',\n  'new() CGI::Simple object constructor, 1' );\nis( $q_new->query_string, 'foo=1&bar=2&bar=3&bar=4',\n  'new() CGI::Simple object constructor, 2' );\n\n# new() \\@ARGV constructor\n\n$ENV{'REQUEST_METHOD'} = '';\n$CGI::Simple::DEBUG    = 1;\n@ARGV                  = qw( foo=bar\\=baz foo=bar\\&baz );\n$q                     = new CGI::Simple;\n\nis(\n  join( ' ', $q->param( 'foo' ) ),\n  'bar=baz bar&baz',\n  'new() \\@ARGV constructor, 1'\n);\n$ENV{'REQUEST_METHOD'} = 'GET';\n\n################ The Core Methods ################\n\n$q = new CGI::Simple;\n\n# param() - scalar and array context, void argument\n$sv = $q->param();\n@av = $q->param();\nis( $sv, '2', 'param() void argument, 1' );\nis( join( ' ', @av ), 'name color', 'param() void argument, 2' );\n\n# param() - scalar and array context, single argument (valid)\n$sv = $q->param( 'color' );\n@av = $q->param( 'color' );\nis( $sv, 'red', 'param(\\'color\\') single argument (valid), 1' );\nis(\n  join( ' ', @av ),\n  'red green blue',\n  'param(\\'color\\') single argument (valid), 2'\n);\n\n# param() - scalar and array context, single argument (invalid)\n$sv = $q->param( 'invalid' );\n@av = $q->param( 'invalid' );\nis( $sv, undef, 'param(\\'invalid\\') single argument (invalid), 1' );\nis( join( ' ', @av ),\n  '', 'param(\\'invalid\\') single argument (invalid), 2' );\n\n# param() - scalar and array context, -name=>'param' (valid)\n$sv = $q->param( -name => 'color' );\n@av = $q->param( -name => 'color' );\nis( $sv, 'red', 'param( -name=>\\'color\\' ) get values, 1' );\nis(\n  join( ' ', @av ),\n  'red green blue',\n  'param( -name=>\\'color\\' ) get values, 2'\n);\n\n# param() - scalar and array context, -name=>'param' (invalid)\n$sv = $q->param( -name => 'invalid' );\n@av = $q->param( -name => 'invalid' );\nis( $sv, undef, 'param( -name=>\\'invalid\\' ) get values, 1' );\nis( join( ' ', @av ), '', 'param( -name=>\\'invalid\\' ) get values, 2' );\n$CGI::Simple::NO_UNDEF_PARAMS = 0;\n$q                            = new CGI::Simple( 'name=&color=' );\n\n# param() - scalar and array context, void values void arg\n$sv = $q->param();\n@av = $q->param();\nis( $sv, '2', 'param() void values 1, 1' );\nis( join( ' ', @av ), 'name color', 'param() void values 1, 2' );\n\n# param() - scalar and array context, void values, valid arg\n$sv = $q->param( 'name' );\n@av = $q->param( 'name' );\nis( $sv, '', 'param(\\'name\\') void values 1, valid param, 1' );\nis( join( ' ', @av ),\n  '', 'param(\\'name\\') void values 1, valid param, 2' );\n$q = new CGI::Simple( 'name&color' );\n\n# param() - scalar and array context, void values void arg\n$sv = $q->param();\n@av = $q->param();\nis( $sv, '2', 'param() void values 2, 1' );\nis( join( ' ', @av ), 'name color', 'param() void values 2, 2' );\n\n# param() - scalar and array context, void values, valid arg\n$sv = $q->param( 'name' );\n@av = $q->param( 'name' );\nis( $sv, '', 'param(\\'name\\') void values 2 , valid param, 1' );\nis( join( ' ', @av ),\n  '', 'param(\\'name\\') void values 2 , valid param, 2' );\n$CGI::Simple::NO_UNDEF_PARAMS = 1;\n$q                            = new CGI::Simple( 'name=&color=' );\n\n# param() - scalar and array context, void values void arg\n$sv = $q->param();\n@av = $q->param();\nis( $sv, '0', 'param() void values 1, no undef, 1' );\nis( join( ' ', @av ), '', 'param() void values 1, no undef, 2' );\n\n# param() - scalar and array context, void values, valid arg\n$sv = $q->param( 'name' );\n@av = $q->param( 'name' );\nis( $sv, undef,\n  'param(\\'name\\') void values 1, valid param, no undef, 1' );\nis( join( ' ', @av ),\n  '', 'param(\\'name\\') void values 1, valid param, no undef, 2' );\n$q = new CGI::Simple( 'name&color' );\n\n# param() - scalar and array context, void values void arg\n$sv = $q->param();\n@av = $q->param();\nis( $sv, '0', 'param() void values 2, no undef, 1' );\nis( join( ' ', @av ), '', 'param() void values 2, no undef, 2' );\n\n# param() - scalar and array context, void values, valid arg\n$sv = $q->param( 'name' );\n@av = $q->param( 'name' );\nis( $sv, undef,\n  'param(\\'name\\') void values 2, valid param, no undef, 1' );\nis( join( ' ', @av ),\n  '', 'param(\\'name\\') void values 2, valid param, no undef, 2' );\n$CGI::Simple::NO_UNDEF_PARAMS = 0;\n$q                            = new CGI::Simple;\n\n# param() - scalar and array context, set values\n$sv = $q->param( 'foo', 'some', 'new', 'values' );\n@av = $q->param( 'foo', 'some', 'new', 'values' );\nis( $sv, 'some',\n  'param( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'some new values',\n  'param( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 2'\n);\n\n# param() - scalar and array context\n$sv = $q->param( -name => 'foo', -value => 'bar' );\n@av = $q->param( -name => 'foo', -value => 'bar' );\nis( $sv, 'bar',\n  'param( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 1' );\nis( join( ' ', @av ),\n  'bar', 'param( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 2' );\n\n# param() - scalar and array context\n$sv = $q->param( -name => 'foo', -value => [ 'bar', 'baz' ] );\n@av = $q->param( -name => 'foo', -value => [ 'bar', 'baz' ] );\nis( $sv, 'bar',\n  'param(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 1' );\nis( join( ' ', @av ),\n  'bar baz',\n  'param(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 2' );\n\n# add_param() - scalar and array context, void argument\n$sv = $q->add_param();\n@av = $q->add_param();\nis( $sv, undef, 'add_param(), 1' );\nis( join( ' ', @av ), '', 'add_param(), 2' );\n\n# add_param() - scalar and array context, existing param argument\n$q->add_param( 'foo', 'new' );\n@av = $q->param( 'foo' );\nis( join( ' ', @av ),\n  'bar baz new', 'add_param( \\'foo\\', \\'new\\' ), 1' );\n$q->add_param( 'foo', [ 1, 2, 3, 4, 5 ] );\n@av = $q->param( 'foo' );\nis(\n  join( ' ', @av ),\n  'bar baz new 1 2 3 4 5',\n  'add_param( \\'foo\\', \\'new\\' ), 2'\n);\n\n# add_param() - existing param argument, overwrite\n$q->add_param( 'foo', 'bar', 'overwrite' );\n@av = $q->param( 'foo' );\nis( join( ' ', @av ),\n  'bar', 'add_param(\\'foo\\', \\'bar\\', \\'overwrite\\' ), 1' );\n\n# add_param() - scalar and array context, existing param argument\n$q->add_param( 'new', 'new%2C' );\n@av = $q->param( 'new' );\nis( join( ' ', @av ), 'new%2C', 'add_param(  \\'new\\', \\'new\\'  ), 1' );\n$q->add_param( 'new', [ 1, 2, 3, 4, 5 ] );\n@av = $q->param( 'new' );\nis(\n  join( ' ', @av ),\n  'new%2C 1 2 3 4 5',\n  'add_param(  \\'new\\', \\'new\\'  ), 2'\n);\n\n# param_fetch() - scalar context, void argument\n$sv = $q->param_fetch();\nis( $sv, undef, 'param_fetch(), 1' );\n\n# param_fetch() - scalar context, 'color' syntax\n$sv = $q->param_fetch( 'color' );\nis( ref $sv, 'ARRAY', 'param_fetch( \\'color\\' ), 1' );\nis( join( ' ', @$sv ), 'red green blue',\n  'param_fetch( \\'color\\' ), 2' );\n\n# param_fetch() - scalar context, -name=>'color' syntax\n$sv = $q->param_fetch( -name => 'color' );\nis( ref $sv, 'ARRAY', 'param_fetch( -name=>\\'color\\' ), 1' );\nis(\n  join( ' ', @$sv ),\n  'red green blue',\n  'param_fetch( -name=>\\'color\\' ), 2'\n);\n\n# url_param() - scalar and array context, void argument\n$sv = $q->url_param();\n@av = $q->url_param();\nis( $sv, '2', 'url_param() void argument, 1' );\nis( join( ' ', @av ), 'name color', 'url_param() void argument, 2' );\n\n# url_param() - scalar and array context, single argument (valid)\n$sv = $q->url_param( 'color' );\n@av = $q->url_param( 'color' );\nis( $sv, 'red', 'url_param(\\'color\\') single argument (valid), 1' );\nis(\n  join( ' ', @av ),\n  'red green blue',\n  'url_param(\\'color\\') single argument (valid), 2'\n);\n\n# url_param() - scalar and array context, single argument (invalid)\n$sv = $q->url_param( 'invalid' );\n@av = $q->url_param( 'invalid' );\nis( $sv, undef, 'url_param(\\'invalid\\') single argument (invalid), 1' );\nis( join( ' ', @av ),\n  '', 'url_param(\\'invalid\\') single argument (invalid), 2' );\n\n# keywords() - scalar and array context, void argument\n$q  = new CGI::Simple( 'here+are++++some%20keywords' );\n$sv = $q->keywords;\n@av = $q->keywords;\nis( $sv, '4', 'keywords(), 1' );\nis( join( ' ', @av ), 'here are some keywords', 'keywords(), 2' );\n\n# keywords() - scalar and array context, array argument\n$sv = $q->keywords( 'foo', 'bar', 'baz' );\n@av = $q->keywords( 'foo', 'bar', 'baz' );\nis( $sv, '3', 'keywords( \\'foo\\', \\'bar\\', \\'baz\\' ), 1' );\nis( join( ' ', @av ),\n  'foo bar baz', 'keywords( \\'foo\\', \\'bar\\', \\'baz\\' ), 2' );\n\n# keywords() - scalar and array context, array ref argument\n$q  = new CGI::Simple;\n$sv = $q->keywords( [ 'foo', 'man', 'chu' ] );\n@av = $q->keywords( [ 'foo', 'man', 'chu' ] );\nis( $sv, '3', 'keywords( [\\'foo\\', \\'man\\', \\'chu\\'] ), 1' );\nis( join( ' ', @av ),\n  'foo man chu', 'keywords( [\\'foo\\', \\'man\\', \\'chu\\'] ), 2' );\n$sv = $q->Vars();\nis( $sv->{'color'}, \"red\\0green\\0blue\", 'Vars() - tied interface, 1' );\n$sv->{'color'} = \"foo\\0bar\\0baz\";\nis( join( ' ', $q->param( 'color' ) ),\n  'foo bar baz', 'Vars() - tied interface, 2' );\n$q = new CGI::Simple;\n\n# Vars() - hash context, void argument\nmy %hv = $q->Vars();\nis( $hv{'name'}, 'JaPh,', 'Vars(), 1' );\n\n# Vars() - hash context, \"|\" argument\n%hv = $q->Vars( ',' );\nis( $hv{'color'}, 'red,green,blue', 'Vars(\\',\\'), 1' );\n\n# append() - scalar and array context, void argument\n$sv = $q->append();\n@av = $q->append();\nis( $sv, undef, 'append(), 1' );\nis( join( '', @av ), '', 'append(), 2' );\n\n# append() - scalar and array context, set values, valid param\n$q->add_param( 'foo', 'bar', 'overwrite' );\n$sv = $q->append( 'foo', 'some' );\n@av = $q->append( 'foo', 'some-more' );\nis( $sv, 'bar', 'append( \\'foo\\', \\'some\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more',\n  'append( \\'foo\\', \\'some\\' ) set values, 2'\n);\n\n# append() - scalar and array context, set values, non-existant param\n$sv = $q->append( 'invalid', 'param1' );\n@av = $q->append( 'invalid', 'param2' );\nis( $sv, 'param1', 'append( \\'invalid\\', \\'param\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'param1 param2',\n  'append( \\'invalid\\', \\'param\\' ) set values, 2'\n);\nis(\n  join( ' ', $q->param( 'invalid' ) ),\n  'param1 param2',\n  'append( \\'invalid\\', \\'param\\' ) set values, 3'\n);\n\n# append() - scalar and array context, set values\n$sv = $q->append( 'foo', 'some', 'new',  'values' );\n@av = $q->append( 'foo', 'even', 'more', 'stuff' );\nis( $sv, 'bar',\n  'append( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more some new values even more stuff',\n  'append( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 2'\n);\n\n# append() - scalar and array context\n$sv = $q->append( -name => 'foo', -value => 'baz' );\n@av = $q->append( -name => 'foo', -value => 'xyz' );\nis( $sv, 'bar',\n  'append( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more some new values even more stuff baz xyz',\n  'append( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 2'\n);\n\n# append() - scalar and array context\n$sv = $q->append( -name => 'foo', -value => [ 1, 2 ] );\n@av = $q->append( -name => 'foo', -value => [ 3, 4 ] );\nis( $sv, 'bar',\n  'append(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more some new values even more stuff baz xyz 1 2 3 4',\n  'append(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 2'\n);\n\n# delete() - void/valid argument\n$q->delete();\nis( join( ' ', $q->param ), 'name color foo invalid', 'delete(), 1' );\n$q->delete( 'foo' );\nis( join( ' ', $q->param ), 'name color invalid', 'delete(), 2' );\n\n# Delete() - void/valid argument\n$q->Delete();\nis( join( ' ', $q->param ), 'name color invalid', 'Delete(), 1' );\n$q->Delete( 'invalid' );\nis( join( ' ', $q->param ), 'name color', 'Delete(), 2' );\n\n# delete_all() - scalar and array context, void/invalid/valid argument\n$q->delete_all();\nis( join( '', $q->param ), '', 'delete_all(), 1' );\nis( $q->globals, '11', 'delete_all(), 2' );\n$ENV{'CONTENT_TYPE'} = 'NOT multipart/form-data';\n$q = new CGI::Simple;\n\n# delete_all() - scalar and array context, void/invalid/valid argument\nis( join( ' ', $q->param ), 'name color', 'Delete_all(), 1' );\n$q->Delete_all();\nis( join( '', $q->param ), '', 'Delete_all(), 2' );\n$ENV{'CONTENT_TYPE'} = 'application/x-www-form-urlencoded';\n\n# upload() - invalid CONTENT_TYPE\n$sv = $q->upload( 'foo' );\nis( $sv, undef, 'upload() - invalid CONTENT_TYPE, 1' );\nis(\n  $q->cgi_error(),\n  'Oops! File uploads only work if you specify ENCTYPE=\"multipart/form-data\" in your <FORM> tag',\n  'upload() - invalid CONTENT_TYPE, 2'\n);\n$ENV{'CONTENT_TYPE'} = 'multipart/form-data';\n\n# upload() - scalar and array context, void/invalid/valid argument\n$sv = $q->upload();\n@av = $q->upload();\nis( $sv, undef, 'upload() - no files available, 1' );\nis( join( ' ', @av ), '', 'upload() - no files available, 2' );\n\n# upload() - scalar and array context, files available, void arg\n$q->{'.filehandles'}->{$_} = $_ for qw( File1 File2 File3 );\n$sv                        = $q->upload();\n@av                        = $q->upload();\nis( $sv, 3, 'upload() - files available, 1' );\nis(\n  join( ' ', sort @av ),\n  'File1 File2 File3',\n  'upload() - files available, 2'\n);\n$q->{'.filehandles'} = {};\n\n# upload() - scalar context, valid argument\nopen FH, $tmpfile or carp \"Can't read $tmpfile $!\\n\";\nmy $data = join '', <FH>;\nis( $data && 1, 1, 'upload(\\'/some/path/to/myfile\\') - real files, 1' );\nseek FH, 0, 0;\n$q->{'.filehandles'}->{'/some/path/to/myfile'} = \\*FH;\nmy $handle = $q->upload( '/some/path/to/myfile' );\nmy $upload = join '', <$handle>;\nis( $upload, $data,\n  'upload(\\'/some/path/to/myfile\\') - real files, 2' );\n\n# upload() - scalar context, invalid argument\n$sv = $q->upload( 'invalid' );\nis( $sv, undef, 'upload(\\'invalid\\'), 1' );\nis(\n  $q->cgi_error,\n  \"No filehandle for 'invalid'. Are uploads enabled (\\$DISABLE_UPLOADS = 0)? Is \\$POST_MAX big enough?\",\n  'upload(\\'invalid\\'), 2'\n);\nmy $ok = $q->upload( '/some/path/to/myfile', \"$tmpfile.bak\" );\nis( $ok, 1, 'upload(\\'invalid\\'), 3' );\nopen $handle, \"$tmpfile.bak\" or carp \"Can't read $tmpfile.bak $!\\n\";\n$upload = join '', <$handle>;\nis( $upload, $data, 'upload(\\'invalid\\'), 4' );\n$sv = $q->upload( '/some/path/to/myfile', \"$tmpfile.bak\" );\nis( $sv, undef, 'upload(\\'invalid\\'), 5' );\nunlink $tmpfile, \"$tmpfile.bak\";\n\n$ENV{'CONTENT_TYPE'} = 'application/x-www-form-urlencoded';\n$q = new CGI::Simple;\n\n# query_string() - scalar and array context, void/invalid/valid argument\n$sv = $q->query_string();\nis(\n  $sv,\n  'name=JaPh%2C&color=red&color=green&color=blue',\n  'query_string(), 1'\n);\n\n# parse_query_string()\n$q->delete_all;\nis( $q->param, 0, 'parse_query_string(), 1' );\n$ENV{'REQUEST_METHOD'} = 'POST';\n$q->parse_query_string();\n$sv = $q->query_string();\nis(\n  $sv,\n  'name=JaPh%2C&color=red&color=green&color=blue',\n  'parse_query_string(), 2'\n);\n$ENV{'REQUEST_METHOD'} = 'GET';\n\n# parse_keywordlist() - scalar and array context\n$sv = $q->parse_keywordlist( 'Just+another++Perl%20hacker%2C' );\n@av = $q->parse_keywordlist( 'Just+another++Perl%20hacker%2C' );\nis( $sv, '4', 'parse_keywordlist(), 1' );\nis(\n  join( ' ', @av ),\n  'Just another Perl hacker,',\n  'parse_keywordlist(), 2'\n);\n\n################ Save and Restore params from file ###############\n\n# _init_from_file()\n# save() - scalar and array context, void/invalid/valid argument\n# save_parameters() - scalar and array context, void/invalid/valid argument\n\n# all tested in constructor section\n\n################ Miscelaneous Methods ################\n\n$q = new CGI::Simple;\n\n# escapeHTML()\n$sv = $q->escapeHTML();\nis( $sv, undef, 'escapeHTML(), 1' );\n$sv = $q->escapeHTML( \"<>&\\\"\\012\\015<>&\\\"\\012\\015\", 0 );\nis(\n  $sv,\n  \"&lt;&gt;&amp;&quot;\\012\\015&lt;&gt;&amp;&quot;\\012\\015\",\n  'escapeHTML(), 2'\n);\n$sv = $q->escapeHTML( \"<>&\\\"\\012\\015<>&\\\"\\012\\015\", 'newlines too' );\nis(\n  $sv,\n  \"&lt;&gt;&amp;&quot;&#10;&#13;&lt;&gt;&amp;&quot;&#10;&#13;\",\n  'escapeHTML(), 3'\n);\n\n# unescapeHTML()\n$sv = $q->unescapeHTML();\nis( $sv, undef, 'unescapeHTML(), 1' );\n$sv = $q->unescapeHTML(\n  \"&lt;&gt;&amp;&quot;&#10;&#13;&lt;&gt;&amp;&quot;&#10;&#13;\" );\nis( $sv, \"<>&\\\"\\012\\015<>&\\\"\\012\\015\", 'unescapeHTML(), 2' );\n$sv = $q->unescapeHTML(\n  'Jack & Jill went up the hill; to get a pail of water' );\nis(\n  $sv,\n  'Jack & Jill went up the hill; to get a pail of water',\n  'unescapeHTML(), 3 '\n);\n\n# put()\nis( $q->put( '' ), 1, 'put(), 1' );\n\n# print()\nis( $q->print( '' ), 1, 'print(), 1' );\n################# Cookie Methods ################\n\n$q = new CGI::Simple;\n\n# raw_cookie() - scalar and array context, void argument\n$sv = $q->raw_cookie();\n@av = $q->raw_cookie();\nis(\n  $sv,\n  'foo=a%20phrase; bar=yes%2C%20a%20phrase&I%20say;',\n  'raw_cookie(), 1'\n);\nis(\n  join( '', @av ),\n  'foo=a%20phrase; bar=yes%2C%20a%20phrase&I%20say;',\n  'raw_cookie(), 2'\n);\n\n# raw_cookie() - scalar and array context, valid argument\n$sv = $q->raw_cookie( 'foo' );\n@av = $q->raw_cookie( 'foo' );\nis( $sv, 'a%20phrase', 'raw_cookie(\\'foo\\'), 1' );\nis( join( '', @av ), 'a%20phrase', 'raw_cookie(\\'foo\\'), 2' );\n\n# raw_cookie() - scalar and array context, invalid argument\n$sv = $q->raw_cookie( 'invalid' );\n@av = $q->raw_cookie( 'invalid' );\nis( $sv, undef, 'raw_cookie(\\'invalid\\'), 1' );\nis( join( '', @av ), '', 'raw_cookie(\\'invalid\\'), 2' );\n\n# cookie() - scalar and array context, void argument\n$sv = $q->cookie();\n@av = $q->cookie();\nis( $sv, '2', 'cookie(), 1' );\n\n# fix OS perl version test bug\nis( join( ' ', sort @av ), 'bar foo', 'cookie(), 2' );\n\n# cookie() - scalar and array context, valid argument, single value\n$sv = $q->cookie( 'foo' );\n@av = $q->cookie( 'foo' );\nis( $sv, 'a phrase', 'cookie(\\'foo\\'), 1' );\nis( join( '', @av ), 'a phrase', 'cookie(\\'foo\\'), 2' );\n\n# cookie() - scalar and array context, valid argument, multiple values\n$sv = $q->cookie( 'bar' );\n@av = $q->cookie( 'bar' );\nis( $sv, 'yes, a phrase', 'cookie(\\'foo\\'), 1' );\nis( join( ' ', @av ), 'yes, a phrase I say', 'cookie(\\'foo\\'), 2' );\n\n# cookie() - scalar and array context, invalid argument\n$sv = $q->cookie( 'invalid' );\n@av = $q->cookie( 'invalid' );\nis( $sv, undef, 'cookie(\\'invalid\\'), 1' );\nis( join( '', @av ), '', 'cookie(\\'invalid\\'), 2' );\nmy @vals = (\n  -name     => 'Password',\n  -value    => [ 'superuser', 'god', 'open sesame', 'mydog woofie' ],\n  -expires  => 'Mon, 11-Nov-2018 11:00:00 GMT',\n  -domain   => '.nowhere.com',\n  -path     => '/cgi-bin/database',\n  -secure   => 1,\n  -httponly => 1\n);\n\n# cookie() - scalar and array context, full argument set, correct order\n$sv = $q->cookie( @vals );\n@av = $q->cookie( @vals );\nis(\n  $sv,\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) correct order, 1'\n);\nis(\n  join( '', @av ),\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) correct order, 2'\n);\n\n# cookie() - scalar and array context, full argument set, incorrect order\n$sv\n = $q->cookie( @vals[ 0, 1, 10, 11, 12, 13, 8, 9, 2, 3, 4, 5, 6, 7 ] );\n@av\n = $q->cookie( @vals[ 0, 1, 10, 11, 12, 13, 8, 9, 2, 3, 4, 5, 6, 7 ] );\nis(\n  $sv,\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) incorrect order, 1'\n);\nis(\n  join( '', @av ),\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) incorrect order, 2'\n);\nmy $cookie = $sv;    # save a cookie for header testing\n\n# cookie() - scalar and array context, partial argument set\n$sv = $q->cookie( -name => 'foo', -value => 'bar' );\n@av = $q->cookie( -name => 'foo', -value => 'bar' );\nis(\n  $sv,\n  'foo=bar; path=/',\n  'cookie( -name=>\\'foo\\', -value=>\\'bar\\' ), 1'\n);\nis(\n  join( '', @av ),\n  'foo=bar; path=/',\n  'cookie( -name=>\\'foo\\', -value=>\\'bar\\' ), 2'\n);\n################# Header Methods ################\n\n$q = new CGI::Simple\n\n my $CRLF = $q->crlf;\n\n# header() - scalar and array context, void argument\n$sv = $q->header();\n@av = $q->header();\nis( $sv, \"Content-Type: text/html; charset=ISO-8859-1$CRLF$CRLF\",\n  'header(), 1' );\nis(\n  join( '', @av ),\n  \"Content-Type: text/html; charset=ISO-8859-1$CRLF$CRLF\",\n  'header(), 2'\n);\n\n# header() - scalar context, single argument\n$sv = $q->header( 'image/gif' );\nis(\n  $sv,\n  \"Content-Type: image/gif$CRLF$CRLF\",\n  'header(\\'image/gif\\'), 1'\n);\n@vals = (\n  -type       => 'image/gif',\n  -nph        => 1,\n  -status     => '402 Payment required',\n  -expires    => 'Mon, 11-Nov-2018 11:00:00 GMT',\n  -cookie     => $cookie,\n  -charset    => 'utf-7',\n  -attachment => 'foo.gif',\n  -Cost       => '$2.00'\n);\n\n# header() - scalar context, complex header\n$sv = $q->header( @vals );\nmy $header = <<'HEADER';\nHTTP/1.0 402 Payment required\nServer: Apache - accept no substitutes\nStatus: 402 Payment required\nSet-Cookie: Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly\nExpires: Mon, 11-Nov-2018 11:00:00 GMT\nDate: Tue, 11-Nov-2018 11:00:00 GMT\nContent-Disposition: attachment; filename=\"foo.gif\"\nCost: $2.00\nContent-Type: image/gif\nHEADER\n$sv     =~ s/[\\012\\015]//g;\n$header =~ s/[\\012\\015]//g;\n$sv     =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\n$header =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\nis( $sv, $header, 'header(\\@vals) - complex header, 1' );\n\n# cache() - scalar and array context, void argument\n$sv = $q->cache();\nis( $sv, undef, 'cache(), 1' );\n\n# cache() - scalar and array context, true argument, sets no cache paragma\n$sv = $q->cache( 1 );\nis( $sv, 1, 'cache(1), 1' );\n$sv = $q->header();\nis( $sv =~ /Pragma: no-cache/, 1, 'cache(1), 2' );\n\n# no_cache() - scalar and array context, void argument\n$sv = $q->no_cache();\nis( $sv, undef, 'cache(), 1' );\n\n# no_cache() - scalar and array context, true argument, sets no cache paragma\n$sv = $q->no_cache( 1 );\nis( $sv, 1, 'cache(1), 1' );\n$sv = $q->header();\nlike( $sv, qr/Pragma: no-cache/, 'cache(1), 2' );\nok( $sv =~ /Expires:(.*?)GMT/, 'cache(1), 3' );\nok( $sv =~ /Date:$1GMT/ . 'cache(1), 4' );\n\n# redirect() - scalar and array context, void argument\n$sv     = $q->redirect( 'http://a.galaxy.far.away.gov' );\n$header = <<'HEADER';\nStatus: 302 Moved\nExpires: Tue, 13 Nov 2001 06:45:15 GMT\nDate: Tue, 13 Nov 2001 06:45:15 GMT\nPragma: no-cache\nLocation: http://a.galaxy.far.away.gov\nHEADER\n$sv     =~ s/[\\012\\015]//g;\n$header =~ s/[\\012\\015]//g;\n$sv     =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\n$header =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\nis( $sv, $header, 'redirect(), 1' );\n\n# redirect() - scalar and array context, void argument\n$sv = $q->redirect( -uri => 'http://a.galaxy.far.away.gov', -nph => 1 );\n$header = <<'HEADER';\nHTTP/1.0 302 Moved\nServer: Apache - accept no substitutes\nStatus: 302 Moved\nExpires: Tue, 13 Nov 2001 06:49:24 GMT\nDate: Tue, 13 Nov 2001 06:49:24 GMT\nPragma: no-cache\nLocation: http://a.galaxy.far.away.gov\nHEADER\n$sv     =~ s/[\\012\\015]//g;\n$header =~ s/[\\012\\015]//g;\n$sv     =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\n$header =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\nis( $sv, $header, 'redirect() - nph, 1' );\n################# Server Push Methods #################\n\n$q = new CGI::Simple;\n\n$sv = $q->multipart_init();\nlike(\n  $sv,\n  qr|Content-Type: multipart/x-mixed-replace;boundary=\"------- =_aaaaaaaaaa0\"|,\n  'multipart_init(), 1'\n);\nlike( $sv, qr/--------- =_aaaaaaaaaa0$CRLF/, 'multipart_init(), 2' );\n$sv = $q->multipart_init( 'this_is_the_boundary' );\nlike( $sv, qr/boundary=\"this_is_the_boundary\"/, 'multipart_init(), 3' );\n$sv = $q->multipart_init( -boundary => 'this_is_another_boundary' );\nlike(\n  $sv,\n  qr/boundary=\"this_is_another_boundary\"/,\n  'multipart_init(), 4'\n);\n\n# multipart_start()\n$sv = $q->multipart_start();\nis( $sv, \"Content-Type: text/html$CRLF$CRLF\", 'multipart_start(), 1' );\n$sv = $q->multipart_start( 'foo/bar' );\nis( $sv, \"Content-Type: foo/bar$CRLF$CRLF\", 'multipart_start(), 2' );\n$sv = $q->multipart_start( -type => 'text/plain' );\nis( $sv, \"Content-Type: text/plain$CRLF$CRLF\", 'multipart_start(), 3' );\n\n# multipart_end()\n$sv = $q->multipart_end();\nis( $sv, \"$CRLF--this_is_another_boundary$CRLF\", 'multipart_end(), 1' );\n\n# multipart_final() - scalar and array context, void/invalid/valid argument\n$sv = $q->multipart_final();\nlike( $sv, qr|--this_is_another_boundary--|, 'multipart_final(), 1' );\n################# Debugging Methods ################\n\n# Dump() - scalar context, void argument\n$sv = $q->Dump();\nlike( $sv, qr/JaPh,/, 'Dump(), 1' );\n\n# as_string()\nis( $q->as_string(), $q->Dump(), 'as_string(), 1' );\n\n# cgi_error()\n$ENV{'REQUEST_METHOD'} = 'GET';\n$ENV{'QUERY_STRING'}   = '';\n$q                     = CGI::Simple->new;\n\n# we have changes this behaviour\n# is( $q->cgi_error, qr/400 No data received via method: GET/ , 'cgi_error(), 1');\nis( $q->cgi_error, undef, 'cgi_error(), 2' );\n$ENV{'QUERY_STRING'} = 'name=JaPh%2C&color=red&color=green&color=blue';\n\n############## cgi-lib.pl tests ################\n\n# ReadParse() - scalar and array context, void/invalid/valid argument\nCGI::Simple::ReadParse();\nis( $in{'name'}, 'JaPh,', 'ReadParse(), 1' );\n%in = ();\n$q  = new CGI::Simple;\n$q->ReadParse();\nis( $in{'name'}, 'JaPh,', 'ReadParse(), 2' );\nCGI::Simple::ReadParse( *field );\nis( $field{'name'}, 'JaPh,', 'ReadParse(), 3' );\n%field = ();\n$q     = new CGI::Simple;\n$q->ReadParse( *field );\nis( $field{'name'}, 'JaPh,', 'ReadParse(), 4' );\n$q = $field{'CGI'};\nis( $q->param( 'name' ), 'JaPh,', 'ReadParse(), 5' );\n\n# SplitParam() - scalar and array context, void/invalid/valid argument\nis(\n  join( ' ', $q->SplitParam( $field{'color'} ) ),\n  'red green blue',\n  'SplitParam(), 1'\n);\nis(\n  join( ' ', CGI::Simple::SplitParam( $field{'color'} ) ),\n  'red green blue',\n  'SplitParam(), 2'\n);\nis( scalar $q->SplitParam( $field{'color'} ), 'red',\n  'SplitParam(), 3' );\nis( scalar CGI::Simple::SplitParam( $field{'color'} ),\n  'red', 'SplitParam(), 4' );\n\n# MethGet() - scalar and array context, void/invalid/valid argument\nis( $q->MethGet, 1, 'MethGet(), 1' );\n\n# MethPost() - scalar and array context, void/invalid/valid argument\nis( !$q->MethPost, 1, 'MethPost(), 1' );\n\n# MyBaseUrl() - scalar and array context, void/invalid/valid argument\nis(\n  $q->MyBaseUrl,\n  'http://nowhere.com:8080/cgi-bin/foo.cgi',\n  'MyBaseUrl(), 1'\n);\n$ENV{'SERVER_PORT'} = 80;\nis(\n  $q->MyBaseUrl,\n  'http://nowhere.com/cgi-bin/foo.cgi',\n  'MyBaseUrl(), 2'\n);\n$ENV{'SERVER_PORT'} = 8080;\n\n# MyURL() - scalar and array context, void/invalid/valid argument\nis( $q->MyURL, 'http://nowhere.com:8080/cgi-bin/foo.cgi',\n  'MyURL(), 1' );\n\n# MyFullUrl() - scalar and array context, void/invalid/valid argument\nis(\n  $q->MyFullUrl,\n  'http://nowhere.com:8080/cgi-bin/foo.cgi/somewhere/else?name=JaPh%2C&color=red&color=green&color=blue',\n  'MyFullUrl(), 1'\n);\n$ENV{'QUERY_STRING'} = '';\n$ENV{'PATH_INFO'}    = '';\nis(\n  $q->MyFullUrl,\n  'http://nowhere.com:8080/cgi-bin/foo.cgi',\n  'MyFullUrl(), 2'\n);\n$ENV{'QUERY_STRING'} = 'name=JaPh%2C&color=red&color=green&color=blue';\n$ENV{'PATH_INFO'}    = '/somewhere/else';\n\n# PrintHeader() - scalar and array context, void/invalid/valid argument\nlike( $q->PrintHeader, qr|Content-Type: text/html|,\n  'PrintHeader(), 1' );\n\n# HtmlTop() - scalar and array context, void/invalid/valid argument\nis(\n  $q->HtmlTop( '$' ),\n  \"<html>\\n<head>\\n<title>\\$</title>\\n</head>\\n<body>\\n<h1>\\$</h1>\\n\",\n  'HtmlTop(), 1'\n);\nis(\n  CGI::Simple::HtmlTop( '$' ),\n  \"<html>\\n<head>\\n<title>\\$</title>\\n</head>\\n<body>\\n<h1>\\$</h1>\\n\",\n  'HtmlTop(), 2'\n);\n\n# HtmlBot() - scalar and array context, void/invalid/valid argument\nis( $q->HtmlBot, \"</body>\\n</html>\\n\", 'HtmlBot(), 1' );\n\n# PrintVariables() - scalar and array context, void/invalid/valid argument\nlike( $q->PrintVariables( \\%field ), qr/JaPh,/, 'PrintVariables(), 1' );\n\n# PrintEnv() - scalar and array context, void/invalid/valid argument\nlike( $q->PrintEnv, qr/PATH_TRANSLATED/, 'PrintEnv(), 1' );\n\n# CgiDie() - scalar and array context, void/invalid/valid argument\n\n# CgiError() - scalar and array context, void/invalid/valid argument\n\n################ Accessor Methods ################\n\n$q = new CGI::Simple;\n\n# version() - scalar context, void argument\nlike( $q->version(), qr/[\\d\\.]+/, 'version(), 1' );\n\n# nph() - scalar context, void  argument\nis( $q->nph(), $q->globals( 'NPH' ), 'nph(), 1' );\n\n# nph() - scalar context, valid  argument\nis( $q->nph( 42 ),        42, 'nph(42), 1' );\nis( $q->globals( 'NPH' ), 42, 'nph(42), 2' );\n\n# all_parameters() - array context, void/invalid/valid argument\n$sv = $q->all_parameters();\n@av = $q->all_parameters();\nis( $sv, 2, 'all_parameters(), 1' );\nis( join( ' ', @av ), 'name color', 'all_parameters(), 2' );\n\n# charset() - scalar context, void argument\n$sv = $q->charset();\nis( $sv, 'utf-7', 'charset(), 1' );\n\n# charset() - scalar context, void argument\n$sv = $q->charset( 'Linear B' );\nis( $sv, 'Linear B', 'charset(), 1' );\n$sv = $q->charset();\nis( $sv, 'Linear B', 'charset(), 2' );\n\n# crlf() - scalar context, void argument\n$sv = $q->crlf();\nlike( $sv, qr/[\\012\\015]{1,2}/, 'crlf(), 1' );\n\n# globals() - scalar and array context, void argument\n$sv = $q->globals();\nis( $sv, 11, 'globals(), 1' );\n@av = $q->globals();\nis(\n  join( ' ', sort @av ),\n  'DEBUG DISABLE_UPLOADS FATAL HEADERS_ONCE NO_NULL NO_UNDEF_PARAMS NPH PARAM_UTF8 POST_MAX USE_CGI_PM_DEFAULTS USE_PARAM_SEMICOLONS',\n  'globals(), 2'\n);\n\n# globals() - scalar context, invalid argument\n$sv = $q->globals( 'FOO' );\nis( $sv, undef, 'globals(\\'FOO\\') - invalid arg, 1' );\n\n# globals() - scalar context, valid argument\nis( $q->globals( 'VERSION', '3.1415' ),\n  '3.1415', 'globals(\\'VERSION\\') - valid arg, 1' );\nis( $q->globals( 'VERSION' ),\n  '3.1415', 'globals(\\'VERSION\\') - valid arg, 2' );\n\n# auth_type() - scalar context, void argument\n$sv = $q->auth_type();\nis( $sv, 'PGP MD5 DES rot13', 'auth_type(), 1' );\n\n# content_length() - scalar context, void argument\n$sv = $q->content_length();\nis( $sv, '42', 'content_length(), 1' );\n\n# content_type() - scalar context, void argument\n$sv = $q->content_type();\nis( $sv, 'application/x-www-form-urlencoded', 'content_type(), 1' );\n\n# document_root() - scalar context, void argument\n$sv = $q->document_root();\nis( $sv, '/vs/www/foo', 'document_root(), 1' );\n\n# gateway_interface() - scalar context, void argument\n$sv = $q->gateway_interface();\nis( $sv, 'bleeding edge', 'gateway_interface(), 1' );\n\n# path_translated() - scalar context, void argument\n$sv = $q->path_translated();\nis( $sv, '/usr/local/somewhere/else', 'path_translated(), 1' );\n\n# referer() - scalar context, void argument\n$sv = $q->referer();\nis( $sv, 'xxx.sex.com', 'referer(), 1' );\n\n# remote_addr() - scalar and array context, void/invalid/valid argument\n$sv = $q->remote_addr();\nis( $sv, '127.0.0.1', 'remote_addr(), 1' );\n\n# remote_host() - scalar context, void argument\n$sv = $q->remote_host();\nis( $sv, 'localhost', 'remote_host(), 1' );\n\n# remote_ident() - scalar context, void argument\n$sv = $q->remote_ident();\nis( $sv, 'None of your damn business', 'remote_ident(), 1' );\n\n# remote_user() - scalar context, void argument\n$sv = $q->remote_user();\nis( $sv, 'Just another Perl hacker,', 'remote_user(), 1' );\n\n# request_method() - scalar context, void argument\n$sv = $q->request_method();\nis( $sv, 'GET', 'request_method(), 1' );\n\n# script_name() - scalar context, void argument\n$sv = $q->script_name();\nis( $sv, '/cgi-bin/foo.cgi', 'script_name(), 1' );\n\n# server_name() - scalar context, void argument\n$sv = $q->server_name();\nis( $sv, 'nowhere.com', 'server_name(), 1' );\n\n# server_port() - scalar context, void argument\n$sv = $q->server_port();\nis( $sv, '8080', 'server_port(), 1' );\n\n# server_protocol() - scalar context, void argument\n$sv = $q->server_protocol();\nis( $sv, 'HTTP/1.0', 'server_protocol(), 1' );\n\n# server_software() - scalar context, void argument\n$sv = $q->server_software();\nis( $sv, 'Apache - accept no substitutes', 'server_software(), 1' );\n\n# user_name() - scalar context, void argument\n$sv = $q->user_name();\nis( $sv, 'spammer@nowhere.com', 'user_name(), 1' );\n\n# user_agent() - scalar context, void argument\n$sv = $q->user_agent();\nis( $sv, 'LWP', 'user_agent(), 1' );\n\n# user_agent() - scalar context, void argument\n$sv = $q->user_agent( 'lwp' );\nis( $sv, 1, 'user_agent(), 1' );\n$sv = $q->user_agent( 'mozilla' );\nis( $sv, '', 'user_agent(), 2' );\n\n# virtual_host() - scalar context, void argument\n$sv = $q->virtual_host();\nis( $sv, 'the.vatican.org', 'virtual_host(), 1' );\n\n# path_info() - scalar and array context, void/valid argument\n$sv = $q->path_info();\nis( $sv, '/somewhere/else', 'path_info(), 1' );\n$sv = $q->path_info( 'somewhere/else/again' );\nis( $sv, '/somewhere/else/again', 'path_info(), 2' );\n$sv = $q->path_info();\nis( $sv, '/somewhere/else/again', 'path_info(), 3' );\n$q->path_info( '/somewhere/else' );\n\n# Accept() - scalar and array context, void argument\n$sv = $q->Accept();\n@av = $q->Accept();\nis( $sv, 5, 'Accept(), 1' );\nis(\n  join( ' ', sort @av ),\n  '*/* image/gif image/jpg text/html text/plain',\n  'Accept(), 2'\n);\n\n# Accept() - scalar context, invalid argument (matches '*/*'\n$sv = $q->Accept( 'foo/bar' );\nis( $sv, '0.001', 'Accept(\\'foo/bar\\'), 1' );\n\n# Accept() - scalar and array context, void argument\n$sv = $q->Accept( '*/*' );\nis( $sv, '0.001', 'Accept(), 1' );\n\n# http() - scalar and array context, void argument\n$sv = $q->http();\n@av = $q->http();\nok( $sv > 0, 'http(), 1' );\nlike( $av[0], qr/HTTP/, 'http(), 2' );\n\n# http() - scalar context, invalid arguments\n$sv = $q->http( 'http-hell' );\nis( $sv, undef, 'http(\\'invalid arg\\'), 1' );\n$sv = $q->http( 'hell' );\nis( $sv, undef, 'http(\\'invalid arg\\'), 2' );\n\n# http() - scalar context, valid arguments\n$sv = $q->http( 'http-from' );\nis( $sv, 'spammer@nowhere.com', 'http(\\'valid arg\\'), 1' );\n$sv = $q->http( 'from' );\nis( $sv, 'spammer@nowhere.com', 'http(\\'valid arg\\'), 2' );\n\n# https() - scalar and array context, void argument\n$sv = $q->https();\nis( $sv, 'ON', 'https(), 1' );\n\n# https() - scalar  context, invalid argument\n$sv = $q->https( 'hell' );\nis( $sv, undef, 'https(\\'invalid arg\\'), 1' );\n\n# https() - scalar context, valid arguments\n$sv = $q->https( 'https-a' );\nis( $sv, 'A', 'https(\\'valid arg\\'), 1' );\n$sv = $q->https( 'a' );\nis( $sv, 'A', 'https(\\'valid arg\\'), 2' );\n\n# protocol() - scalar context, void arguments\n$sv = $q->protocol();\nis( $sv, 'https', 'protocol(), 1' );\n$ENV{'HTTPS'}       = 'OFF';\n$ENV{'SERVER_PORT'} = '443';\n$sv                 = $q->protocol();\nis( $sv, 'https', 'protocol(), 2' );\n$ENV{'SERVER_PORT'} = '8080';\n$sv = $q->protocol();\nis( $sv, 'http', 'protocol(), 3' );\n\n# url() - scalar context, void argument\n$ENV{'HTTP_HOST'} = '';\nis( $q->url, 'http://nowhere.com:8080/cgi-bin/foo.cgi', 'url(), 1' );\n\n# url() - scalar context, valid argument\nis( $q->url( -absolute => 1 ),\n  '/cgi-bin/foo.cgi', 'CGI::url(-absolute=>1)' );\n\n# url() - scalar context, valid argument\nis( $q->url( -relative => 1 ), 'foo.cgi', 'url(-relative=>1), 1' );\n\n# url() - scalar context, valid argument\nis( $q->url( -relative => 1, -path => 1 ),\n  'foo.cgi/somewhere/else', 'url(-relative=>1,-path=>1), 1' );\n\n# url() - scalar context, valid argument\nis(\n  $q->url( -relative => 1, -path => 1, -query => 1 ),\n  'foo.cgi/somewhere/else?name=JaPh%2C&color=red&color=green&color=blue',\n  'url(-relative=>1,-path=>1,-query=>1), 1'\n);\n\n# self_url() - scalar context, void argument\n$sv = $q->self_url();\n@av = $q->self_url();\nis(\n  $sv,\n  'http://nowhere.com:8080/cgi-bin/foo.cgi/somewhere/else?name=JaPh%2C&color=red&color=green&color=blue',\n  'self_url(), 1'\n);\n\n# state() - scalar and array context, void/invalid/valid argument\nis( $q->state(), $q->self_url(), 'state(), 1' );\n\n################ Yet More Tests ################\n\n#$CGI::Simple::POST_MAX = 20;\n#$ENV{'REQUEST_METHOD'} = 'POST';\n#$q = new CGI::Simple;\n#is( $q->cgi_error, '413 Request entity too large: 42 bytes on STDIN exceeds $POST_MAX!' , 'Yet more tests, 1');\n\n$ENV{'REQUEST_METHOD'} = 'HEAD';\n$ENV{'QUERY_STRING'}   = '';\n$ENV{'REDIRECT_QUERY_STRING'}\n = 'name=JAPH&color=red&color=green&color=blue';\n\n$CGI::Simple::POST_MAX = 50;\n$q                     = new CGI::Simple;\n@av                    = $q->param;\n\nis( join( ' ', @av ), 'name color', 'Yet more tests, 2' );\n@av = $q->param( 'color' );\nis( join( ' ', @av ), 'red green blue', 'Yet more tests, 3' );\n", "use Test::More tests => 288;\nuse Carp;\nuse strict;\nuse vars qw(%field %in);\n\nuse CGI::Simple::Standard qw( :all );\n\nmy ( $q, $sv, @av );\nmy $tmpfile = './cgi-tmpfile.tmp';\n\nmy $debug = 0;\n\n$ENV{'AUTH_TYPE'}      = 'PGP MD5 DES rot13';\n$ENV{'CONTENT_LENGTH'} = '42';\n$ENV{'CONTENT_TYPE'}   = 'application/x-www-form-urlencoded';\n$ENV{'COOKIE'} = 'foo=a%20phrase; bar=yes%2C%20a%20phrase&I%20say;';\n$ENV{'DOCUMENT_ROOT'}     = '/vs/www/foo';\n$ENV{'GATEWAY_INTERFACE'} = 'bleeding edge';\n$ENV{'HTTPS'}             = 'ON';\n$ENV{'HTTPS_A'}           = 'A';\n$ENV{'HTTPS_B'}           = 'B';\n$ENV{'HTTP_ACCEPT'}\n = 'text/html;q=1, text/plain;q=0.8, image/jpg, image/gif;q=0.42, */*;q=0.001';\n$ENV{'HTTP_COOKIE'}     = '';\n$ENV{'HTTP_FROM'}       = 'spammer@nowhere.com';\n$ENV{'HTTP_HOST'}       = 'the.vatican.org';\n$ENV{'HTTP_REFERER'}    = 'xxx.sex.com';\n$ENV{'HTTP_USER_AGENT'} = 'LWP';\n$ENV{'PATH_INFO'}       = '/somewhere/else';\n$ENV{'PATH_TRANSLATED'} = '/usr/local/somewhere/else';\n$ENV{'QUERY_STRING'} = 'name=JaPh%2C&color=red&color=green&color=blue';\n$ENV{'REDIRECT_QUERY_STRING'} = '';\n$ENV{'REMOTE_ADDR'}           = '127.0.0.1';\n$ENV{'REMOTE_HOST'}           = 'localhost';\n$ENV{'REMOTE_IDENT'}          = 'None of your damn business';\n$ENV{'REMOTE_USER'}           = 'Just another Perl hacker,';\n$ENV{'REQUEST_METHOD'}        = 'GET';\n$ENV{'SCRIPT_NAME'}           = '/cgi-bin/foo.cgi';\n$ENV{'SERVER_NAME'}           = 'nowhere.com';\n$ENV{'SERVER_PORT'}           = '8080';\n$ENV{'SERVER_PROTOCOL'}       = 'HTTP/1.0';\n$ENV{'SERVER_SOFTWARE'}       = 'Apache - accept no substitutes';\n\nrestore_parameters();\n\nsub undef_globals {\n  undef $CGI::Simple::USE_CGI_PM_DEFAULTS;\n  undef $CGI::Simple::DISABLE_UPLOADS;\n  undef $CGI::Simple::POST_MAX;\n  undef $CGI::Simple::NO_UNDEF_PARAMS;\n  undef $CGI::Simple::USE_PARAM_SEMICOLONS;\n  undef $CGI::Simple::HEADERS_ONCE;\n  undef $CGI::Simple::NPH;\n  undef $CGI::Simple::DEBUG;\n  undef $CGI::Simple::NO_NULL;\n  undef $CGI::Simple::FATAL;\n}\n\nundef_globals();\nrestore_parameters();\n\n# _initialize_globals()\n\n_initialize_globals();\nis( $CGI::Simple::USE_CGI_PM_DEFAULTS, 0, '_initialize_globals(), 1' );\nis( $CGI::Simple::DISABLE_UPLOADS,     1, '_initialize_globals(), 2' );\nis( $CGI::Simple::POST_MAX, 102_400, '_initialize_globals(), 3' );\nis( $CGI::Simple::NO_UNDEF_PARAMS,      0, '_initialize_globals(), 4' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 0, '_initialize_globals(), 5' );\nis( $CGI::Simple::HEADERS_ONCE,         0, '_initialize_globals(), 6' );\nis( $CGI::Simple::NPH,                  0, '_initialize_globals(), 7' );\nis( $CGI::Simple::DEBUG,                0, '_initialize_globals(), 8' );\nis( $CGI::Simple::NO_NULL,              1, '_initialize_globals(), 9' );\nis( $CGI::Simple::FATAL, -1, '_initialize_globals(), 10' );\n\nundef_globals();\n\n# _use_cgi_pm_global_settings()\n\n_use_cgi_pm_global_settings();\nrestore_parameters();\nis( $CGI::Simple::DISABLE_UPLOADS, 0,\n  '_use_cgi_pm_global_settings(), 1' );\nis( $CGI::Simple::POST_MAX, -1, '_use_cgi_pm_global_settings(), 2' );\nis( $CGI::Simple::NO_UNDEF_PARAMS, 0,\n  '_use_cgi_pm_global_settings(), 3' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS,\n  1, '_use_cgi_pm_global_settings(), 4' );\nis( $CGI::Simple::HEADERS_ONCE, 0, '_use_cgi_pm_global_settings(), 5' );\nis( $CGI::Simple::NPH,          0, '_use_cgi_pm_global_settings(), 6' );\nis( $CGI::Simple::DEBUG,        1, '_use_cgi_pm_global_settings(), 7' );\nis( $CGI::Simple::NO_NULL,      0, '_use_cgi_pm_global_settings(), 8' );\nis( $CGI::Simple::FATAL, -1, '_use_cgi_pm_global_settings(), 9' );\n\n# _store_globals()\n\n$q = _cgi_object();\nundef %{$q};\n\nok( !defined $q->{'.globals'}->{'DISABLE_UPLOADS'},\n  '_store_globals(), 1' );\nok( !defined $q->{'.globals'}->{'POST_MAX'}, '_store_globals(), 2' );\nok( !defined $q->{'.globals'}->{'NO_UNDEF_PARAMS'},\n  '_store_globals(), 3' );\nok( !defined $q->{'.globals'}->{'USE_PARAM_SEMICOLONS'},\n  '_store_globals(), 4' );\nok( !defined $q->{'.globals'}->{'HEADERS_ONCE'},\n  '_store_globals(), 5' );\nok( !defined $q->{'.globals'}->{'NPH'},     '_store_globals(), 6' );\nok( !defined $q->{'.globals'}->{'DEBUG'},   '_store_globals(), 7' );\nok( !defined $q->{'.globals'}->{'NO_NULL'}, '_store_globals(), 8' );\nok( !defined $q->{'.globals'}->{'FATAL'},   '_store_globals(), 9' );\nok( !defined $q->{'.globals'}->{'USE_CGI_PM_DEFAULTS'},\n  '_store_globals(), 10' );\n\n$q->_store_globals();\n\nok( defined $q->{'.globals'}->{'DISABLE_UPLOADS'},\n  '_store_globals(), 11' );\nok( defined $q->{'.globals'}->{'POST_MAX'}, '_store_globals(), 12' );\nok( defined $q->{'.globals'}->{'NO_UNDEF_PARAMS'},\n  '_store_globals(), 13' );\nok( defined $q->{'.globals'}->{'USE_PARAM_SEMICOLONS'},\n  '_store_globals(), 14' );\nok( defined $q->{'.globals'}->{'HEADERS_ONCE'},\n  '_store_globals(), 15' );\nok( defined $q->{'.globals'}->{'NPH'},     '_store_globals(), 16' );\nok( defined $q->{'.globals'}->{'DEBUG'},   '_store_globals(), 17' );\nok( defined $q->{'.globals'}->{'NO_NULL'}, '_store_globals(), 18' );\nok( defined $q->{'.globals'}->{'FATAL'},   '_store_globals(), 19' );\nok( defined $q->{'.globals'}->{'USE_CGI_PM_DEFAULTS'},\n  '_store_globals(), 20' );\n\n# import() - used to set paragmas\n\nmy @args\n = qw( -default -no_upload -unique_header -nph -no_debug -newstyle_url -no_undef_param  );\n\nundef_globals();\n\n$q->import( @args );\n\nis( $CGI::Simple::USE_CGI_PM_DEFAULTS,  1, 'import(), 1' );\nis( $CGI::Simple::DISABLE_UPLOADS,      1, 'import(), 2' );\nis( $CGI::Simple::NO_UNDEF_PARAMS,      1, 'import(), 3' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 1, 'import(), 4' );\nis( $CGI::Simple::HEADERS_ONCE,         1, 'import(), 5' );\nis( $CGI::Simple::NPH,                  1, 'import(), 6' );\nis( $CGI::Simple::DEBUG,                0, 'import(), 7' );\n\nundef_globals();\n\n$q->import(\n  qw ( -default -upload -no_undefparams -oldstyle_url -npheader -debug  )\n);\n\nis( $CGI::Simple::USE_CGI_PM_DEFAULTS,  1, 'import(), 8' );\nis( $CGI::Simple::DISABLE_UPLOADS,      0, 'import(), 9' );\nis( $CGI::Simple::NO_UNDEF_PARAMS,      1, 'import(), 10' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 0, 'import(), 11' );\nis( $CGI::Simple::NPH,                  1, 'import(), 12' );\nis( $CGI::Simple::DEBUG,                2, 'import(), 13' );\n\nundef_globals();\n\n# _reset_globals()\n\n_reset_globals();\n\nis( $CGI::Simple::DISABLE_UPLOADS,      0,  '_reset_globals(), 1' );\nis( $CGI::Simple::POST_MAX,             -1, '_reset_globals(), 2' );\nis( $CGI::Simple::NO_UNDEF_PARAMS,      0,  '_reset_globals(), 3' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 1,  '_reset_globals(), 4' );\nis( $CGI::Simple::HEADERS_ONCE,         0,  '_reset_globals(), 5' );\nis( $CGI::Simple::NPH,                  0,  '_reset_globals(), 6' );\nis( $CGI::Simple::DEBUG,                1,  '_reset_globals(), 7' );\nis( $CGI::Simple::NO_NULL,              0,  '_reset_globals(), 8' );\nis( $CGI::Simple::FATAL,                -1, '_reset_globals(), 9' );\n\nundef_globals();\n\nrestore_parameters();\n\n# url_decode() - scalar context, void argument\n\n$sv = url_decode();\nis( $sv, undef, 'url_decode(), 1' );\n\n# url_decode() - scalar context, valid argument\n\nmy ( $string, $enc_string );\nfor ( 32 .. 255 ) {\n  $string .= chr;\n  $enc_string .= uc sprintf \"%%%02x\", ord chr;\n}\nis( url_decode( $enc_string ), $string, 'url_decode(\\$enc_string), 1' );\n\n# url_encode() - scalar context, void argument\n\n$sv = url_encode();\nis( $sv, undef, 'url_encode(), 1' );\n\n# url_encode() - scalar context, valid argument\n\n$sv = url_encode( $string );\n$sv =~ tr/+/ /;\n$sv =~ s/%([a-fA-F0-9]{2})/ pack \"C\", hex $1 /eg;\nis( $sv, $string, 'url_encode(\\$string), 1' );\n\n# url encoding - circular test\n\nis( url_decode( $q->url_encode( $string ) ),\n  $string, 'url encoding via circular test, 1' );\n\n# new() plain constructor\n\nrestore_parameters();\nlike( _cgi_object(), qr/CGI::Simple/, 'new() plain constructor, 1' );\n\n# new() hash constructor\n\nrestore_parameters( { 'foo' => '1', 'bar' => [ 2, 3, 4 ] } );\n@av = param();\n\n# fix OS bug with testing\nis( join( ' ', sort @av ), 'bar foo', 'new() hash constructor, 1' );\nis( param( 'foo' ), 1, 'new() hash constructor, 2' );\nis( param( 'bar' ), 2, 'new() hash constructor, 3' );\n@av = param( 'bar' );\nis( join( '', @av ), 234, 'new() hash constructor, 4' );\nrestore_parameters( 'foo=1&bar=2&bar=3&bar=4' );\nopen FH, \">$tmpfile\", or carp \"Can't create $tmpfile $!\\n\";\nsave_parameters( \\*FH );\n\n#close FH;\n\n# new() query string constructor\n\nrestore_parameters( 'foo=5&bar=6&bar=7&bar=8' );\n@av = param();\nis( join( ' ', @av ), 'foo bar', 'new() query string constructor, 1' );\nis( param( 'foo' ), 5, 'new() query string constructor, 2' );\nis( param( 'bar' ), 6, 'new() query string constructor, 3' );\n@av = param( 'bar' );\nis( join( '', @av ), 678, 'new() query string constructor, 4' );\nopen FH, \">>$tmpfile\", or carp \"Can't append $tmpfile $!\\n\";\nsave_parameters( \\*FH );\nclose FH;\n\n# new() \\@ARGV constructor\n\n$ENV{'REQUEST_METHOD'} = '';\n$CGI::Simple::DEBUG    = 1;\n@ARGV                  = qw( foo=bar\\=baz foo=bar\\&baz );\nrestore_parameters();\nis(\n  join( ' ', param( 'foo' ) ),\n  'bar=baz bar&baz',\n  'new() \\@ARGV constructor, 1'\n);\n$ENV{'REQUEST_METHOD'} = 'GET';\n\n################ The Core Methods ################\n\nrestore_parameters();\n\n# param() - scalar and array context, void argument\n\n$sv = param();\n@av = param();\nis( $sv, '2', 'param() void argument, 1' );\nis( join( ' ', @av ), 'name color', 'param() void argument, 2' );\n\n# param() - scalar and array context, single argument (valid)\n\n$sv = param( 'color' );\n@av = param( 'color' );\nis( $sv, 'red', 'param(\\'color\\') single argument (valid), 1' );\nis(\n  join( ' ', @av ),\n  'red green blue',\n  'param(\\'color\\') single argument (valid), 2'\n);\n\n# param() - scalar and array context, single argument (invalid)\n\n$sv = param( 'invalid' );\n@av = param( 'invalid' );\nis( $sv, undef, 'param(\\'invalid\\') single argument (invalid), 1' );\nis( join( ' ', @av ),\n  '', 'param(\\'invalid\\') single argument (invalid), 2' );\n\n# param() - scalar and array context, -name=>'param' (valid)\n\n$sv = param( -name => 'color' );\n@av = param( -name => 'color' );\nis( $sv, 'red', 'param( -name=>\\'color\\' ) get values, 1' );\nis(\n  join( ' ', @av ),\n  'red green blue',\n  'param( -name=>\\'color\\' ) get values, 2'\n);\n\n# param() - scalar and array context, -name=>'param' (invalid)\n\n$sv = param( -name => 'invalid' );\n@av = param( -name => 'invalid' );\nis( $sv, undef, 'param( -name=>\\'invalid\\' ) get values, 1' );\nis( join( ' ', @av ), '', 'param( -name=>\\'invalid\\' ) get values, 2' );\n\n# param() - scalar and array context, set values\n\n$sv = param( 'foo', 'some', 'new', 'values' );\n@av = param( 'foo', 'some', 'new', 'values' );\nis( $sv, 'some',\n  'param( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'some new values',\n  'param( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 2'\n);\n\n# param() - scalar and array context\n\n$sv = param( -name => 'foo', -value => 'bar' );\n@av = param( -name => 'foo', -value => 'bar' );\nis( $sv, 'bar',\n  'param( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 1' );\nis( join( ' ', @av ),\n  'bar', 'param( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 2' );\n\n# param() - scalar and array context\n\n$sv = param( -name => 'foo', -value => [ 'bar', 'baz' ] );\n@av = param( -name => 'foo', -value => [ 'bar', 'baz' ] );\nis( $sv, 'bar',\n  'param(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 1' );\nis( join( ' ', @av ),\n  'bar baz',\n  'param(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 2' );\n\n# add_param() - scalar and array context, void argument\n\n$sv = add_param();\n@av = add_param();\nis( $sv, undef, 'add_param(), 1' );\nis( join( ' ', @av ), '', 'add_param(), 2' );\n\n# add_param() - scalar and array context, existing param argument\n\nadd_param( 'foo', 'new' );\n@av = param( 'foo' );\nis( join( ' ', @av ),\n  'bar baz new', 'add_param( \\'foo\\', \\'new\\' ), 1' );\nadd_param( 'foo', [ 1, 2, 3, 4, 5 ] );\n@av = param( 'foo' );\nis(\n  join( ' ', @av ),\n  'bar baz new 1 2 3 4 5',\n  'add_param( \\'foo\\', \\'new\\' ), 2'\n);\n\n# add_param() - existing param argument, overwrite\n\nadd_param( 'foo', 'bar', 'overwrite' );\n@av = param( 'foo' );\nis( join( ' ', @av ),\n  'bar', 'add_param(\\'foo\\', \\'bar\\', \\'overwrite\\' ), 1' );\n\n# add_param() - scalar and array context, existing param argument\n\nadd_param( 'new', 'new%2C' );\n@av = param( 'new' );\nis( join( ' ', @av ), 'new%2C', 'add_param(  \\'new\\', \\'new\\'  ), 1' );\nadd_param( 'new', [ 1, 2, 3, 4, 5 ] );\n@av = param( 'new' );\nis(\n  join( ' ', @av ),\n  'new%2C 1 2 3 4 5',\n  'add_param(  \\'new\\', \\'new\\'  ), 2'\n);\n\n# param_fetch() - scalar context, void argument\n\n$sv = param_fetch();\nis( $sv, undef, 'param_fetch(), 1' );\n\n# param_fetch() - scalar context, 'color' syntax\n\n$sv = param_fetch( 'color' );\nis( ref $sv, 'ARRAY', 'param_fetch( \\'color\\' ), 1' );\nis( join( ' ', @$sv ), 'red green blue',\n  'param_fetch( \\'color\\' ), 2' );\n\n# param_fetch() - scalar context, -name=>'color' syntax\n\n$sv = param_fetch( -name => 'color' );\nis( ref $sv, 'ARRAY', 'param_fetch( -name=>\\'color\\' ), 1' );\nis(\n  join( ' ', @$sv ),\n  'red green blue',\n  'param_fetch( -name=>\\'color\\' ), 2'\n);\n\n# url_param() - scalar and array context, void argument\n\n$sv = url_param();\n@av = url_param();\nis( $sv, '2', 'url_param() void argument, 1' );\nis( join( ' ', @av ), 'name color', 'url_param() void argument, 2' );\n\n# url_param() - scalar and array context, single argument (valid)\n\n$sv = url_param( 'color' );\n@av = url_param( 'color' );\nis( $sv, 'red', 'url_param(\\'color\\') single argument (valid), 1' );\nis(\n  join( ' ', @av ),\n  'red green blue',\n  'url_param(\\'color\\') single argument (valid), 2'\n);\n\n# url_param() - scalar and array context, single argument (invalid)\n\n$sv = url_param( 'invalid' );\n@av = url_param( 'invalid' );\nis( $sv, undef, 'url_param(\\'invalid\\') single argument (invalid), 1' );\nis( join( ' ', @av ),\n  '', 'url_param(\\'invalid\\') single argument (invalid), 2' );\n\n# keywords() - scalar and array context, void argument\n\n$ENV{'QUERY_STRING'} = 'here+are++++some%20keywords';\nrestore_parameters();\n$sv = keywords();\n@av = keywords();\nis( $sv, '4', 'keywords(), 1' );\nis( join( ' ', @av ), 'here are some keywords', 'keywords(), 2' );\n$ENV{'QUERY_STRING'} = 'name=JaPh%2C&color=red&color=green&color=blue';\n\n# keywords() - scalar and array context, array argument\n\n$sv = keywords( 'foo', 'bar', 'baz' );\n@av = keywords( 'foo', 'bar', 'baz' );\nis( $sv, '3', 'keywords( \\'foo\\', \\'bar\\', \\'baz\\' ), 1' );\nis( join( ' ', @av ),\n  'foo bar baz', 'keywords( \\'foo\\', \\'bar\\', \\'baz\\' ), 2' );\n\n# keywords() - scalar and array context, array ref argument\n\nrestore_parameters();\n$sv = keywords( [ 'foo', 'man', 'chu' ] );\n@av = keywords( [ 'foo', 'man', 'chu' ] );\nis( $sv, '3', 'keywords( [\\'foo\\', \\'man\\', \\'chu\\'] ), 1' );\nis( join( ' ', @av ),\n  'foo man chu', 'keywords( [\\'foo\\', \\'man\\', \\'chu\\'] ), 2' );\n\n# Vars() - scalar and array context, void argument\n\n$sv = Vars();\nmy %hv = Vars();\nis( $sv->{'color'}, \"red\\0green\\0blue\", 'Vars(), 1' );\nis( $hv{'name'},    'JaPh,',            'Vars(), 2' );\n\n# Vars() - hash context, \"|\" argument\n\n%hv = Vars( '|' );\nis( $hv{'color'}, 'red|green|blue', 'Vars(\\'|\\'), 1' );\n\n# append() - scalar and array context, void argument\n\n$sv = append();\n@av = append();\nis( $sv, undef, 'append(), 1' );\nis( join( '', @av ), '', 'append(), 2' );\n\n# append() - scalar and array context, set values, valid param\n\nadd_param( 'foo', 'bar', 'overwrite' );\n$sv = append( 'foo', 'some' );\n@av = append( 'foo', 'some-more' );\nis( $sv, 'bar', 'append( \\'foo\\', \\'some\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more',\n  'append( \\'foo\\', \\'some\\' ) set values, 2'\n);\n\n# append() - scalar and array context, set values, non-existant param\n\n$sv = append( 'invalid', 'param1' );\n@av = append( 'invalid', 'param2' );\nis( $sv, 'param1', 'append( \\'invalid\\', \\'param\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'param1 param2',\n  'append( \\'invalid\\', \\'param\\' ) set values, 2'\n);\nis(\n  join( ' ', param( 'invalid' ) ),\n  'param1 param2',\n  'append( \\'invalid\\', \\'param\\' ) set values, 3'\n);\n\n# append() - scalar and array context, set values\n\n$sv = append( 'foo', 'some', 'new',  'values' );\n@av = append( 'foo', 'even', 'more', 'stuff' );\nis( $sv, 'bar',\n  'append( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more some new values even more stuff',\n  'append( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 2'\n);\n\n# append() - scalar and array context\n\n$sv = append( -name => 'foo', -value => 'baz' );\n@av = append( -name => 'foo', -value => 'xyz' );\nis( $sv, 'bar',\n  'append( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more some new values even more stuff baz xyz',\n  'append( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 2'\n);\n\n# append() - scalar and array context\n\n$sv = append( -name => 'foo', -value => [ 1, 2 ] );\n@av = append( -name => 'foo', -value => [ 3, 4 ] );\nis( $sv, 'bar',\n  'append(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more some new values even more stuff baz xyz 1 2 3 4',\n  'append(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 2'\n);\n\n# delete() - void/valid argument\n\nDelete();\nis( join( ' ', param() ), 'name color foo invalid', 'delete(), 1' );\nDelete( 'foo' );\nis( join( ' ', param() ), 'name color invalid', 'delete(), 2' );\n\n# Delete() - void/valid argument\n\nDelete();\nis( join( ' ', param() ), 'name color invalid', 'Delete(), 1' );\nDelete( 'invalid' );\nis( join( ' ', param() ), 'name color', 'Delete(), 2' );\n\n# delete_all() - scalar and array context, void/invalid/valid argument\n\ndelete_all();\nis( join( '', param() ), '', 'delete_all(), 1' );\nis( globals(), '11', 'delete_all(), 2' );\n\nrestore_parameters();\n\n# delete_all() - scalar and array context, void/invalid/valid argument\n\nis( join( ' ', param() ), 'name color', 'Delete_all(), 1' );\nDelete_all();\nis( join( '', param() ), '', 'Delete_all(), 2' );\n\n$ENV{'CONTENT_TYPE'} = 'multipart/form-data';\n\n# upload() - scalar and array context, void/invalid/valid argument\n\n$sv = upload();\n@av = upload();\nis( $sv, undef, 'upload() - no files available, 1' );\nis( join( ' ', @av ), '', 'upload() - no files available, 2' );\n\n# upload() - scalar and array context, files available, void arg\n\n$q = _cgi_object();\n$q->{'.filehandles'}->{$_} = $_ for qw( File1 File2 File3 );\n$sv                        = upload();\n@av                        = upload();\nis( $sv, 3, 'upload() - files available, 1' );\nis(\n  join( ' ', sort @av ),\n  'File1 File2 File3',\n  'upload() - files available, 2'\n);\n$q->{'.filehandles'} = {};\n\n# upload() - scalar context, valid argument\n\nopen FH, $tmpfile or carp \"Can't read $tmpfile $!\\n\";\nmy $data = join '', <FH>;\nis( $data && 1, 1, 'upload(\\'/some/path/to/myfile\\') - real files, 1' )\n ;    # make sure we have data\nseek FH, 0, 0;\n$q->{'.filehandles'}->{'/some/path/to/myfile'} = \\*FH;\nmy $handle = upload( '/some/path/to/myfile' );\nmy $upload = join '', <$handle>;\nis( $upload, $data,\n  'upload(\\'/some/path/to/myfile\\') - real files, 2' );\n\n# upload() - scalar context, invalid argument\n\n$sv = upload( 'invalid' );\nis( $sv, undef, 'upload(\\'invalid\\'), 1' );\nis( cgi_error,\n  \"No filehandle for 'invalid'. Are uploads enabled (\\$DISABLE_UPLOADS = 0)? Is \\$POST_MAX big enough?\",\n  'upload(\\'invalid\\'), 2'\n);\n\nmy $ok = upload( '/some/path/to/myfile', \"$tmpfile.bak\" );\nis( $ok, 1, 'upload( \\'/some/path/to/myfile\\', \\, 1' );\nopen $handle, \"$tmpfile.bak\" or carp \"Can't read $tmpfile.bak $!\\n\";\n$upload = join '', <$handle>;\nis( $upload, $data, 'upload( \\'/some/path/to/myfile\\', \\, 2' );\n$sv = upload( '/some/path/to/myfile', \"$tmpfile.bak\" );\nis( $sv, undef, 'upload( \\'/some/path/to/myfile\\', \\, 3' );\nunlink $tmpfile, \"$tmpfile.bak\";\n\n$ENV{'CONTENT_TYPE'} = 'application/x-www-form-urlencoded';\n\nrestore_parameters();\n\n# query_string() - scalar and array context, void/invalid/valid argument\n\n$sv = query_string();\nis(\n  $sv,\n  'name=JaPh%2C&color=red&color=green&color=blue',\n  'query_string(), 1'\n);\n\n# parse_query_string()\n\ndelete_all();\nis( param(), 0, 'parse_query_string(), 1' );\n$ENV{'REQUEST_METHOD'} = 'POST';\nparse_query_string();\n$sv = query_string();\nis(\n  $sv,\n  'name=JaPh%2C&color=red&color=green&color=blue',\n  'parse_query_string(), 2'\n);\n$ENV{'REQUEST_METHOD'} = 'GET';\n\n# parse_keywordlist() - scalar and array context\n\n$sv = parse_keywordlist( 'Just+another++Perl%20hacker%2C' );\n@av = parse_keywordlist( 'Just+another++Perl%20hacker%2C' );\nis( $sv, '4', 'parse_keywordlist(), 1' );\nis(\n  join( ' ', @av ),\n  'Just another Perl hacker,',\n  'parse_keywordlist(), 2'\n);\n\n################ Save and Restore params from file ###############\n\n# _init_from_file()\n# save() - scalar and array context, void/invalid/valid argument\n# save_parameters() - scalar and array context, void/invalid/valid argument\n\n# all tested in constructor section\n\n################ Miscelaneous Methods ################\n\nrestore_parameters();\n\n# escapeHTML()\n\n$sv = escapeHTML();\nis( $sv, undef, 'escapeHTML(), 1' );\n$sv = escapeHTML( \"<>&\\\"\\012\\015<>&\\\"\\012\\015\", 0 );\nis(\n  $sv,\n  \"&lt;&gt;&amp;&quot;\\012\\015&lt;&gt;&amp;&quot;\\012\\015\",\n  'escapeHTML(), 2'\n);\n$sv = escapeHTML( \"<>&\\\"\\012\\015<>&\\\"\\012\\015\", 'newlines too' );\nis(\n  $sv,\n  \"&lt;&gt;&amp;&quot;&#10;&#13;&lt;&gt;&amp;&quot;&#10;&#13;\",\n  'escapeHTML(), 3'\n);\n\n# unescapeHTML()\n\n$sv = unescapeHTML();\nis( $sv, undef, 'unescapeHTML(), 1' );\n$sv = unescapeHTML(\n  \"&lt;&gt;&amp;&quot;&#10;&#13;&lt;&gt;&amp;&quot;&#10;&#13;\" );\nis( $sv, \"<>&\\\"\\012\\015<>&\\\"\\012\\015\", 'unescapeHTML(), 2' );\n\n# put()\n\nis( put( '' ), 1, 'put(), 1' );\n\n# print()\n\nis( print( '' ), 1, 'print(), 1' );\n\n################# Cookie Methods ################\n\nrestore_parameters();\n\n# raw_cookie() - scalar and array context, void argument\n\n$sv = raw_cookie();\n@av = raw_cookie();\nis(\n  $sv,\n  'foo=a%20phrase; bar=yes%2C%20a%20phrase&I%20say;',\n  'raw_cookie(), 1'\n);\nis(\n  join( '', @av ),\n  'foo=a%20phrase; bar=yes%2C%20a%20phrase&I%20say;',\n  'raw_cookie(), 2'\n);\n\n# raw_cookie() - scalar and array context, valid argument\n\n$sv = raw_cookie( 'foo' );\n@av = raw_cookie( 'foo' );\nis( $sv, 'a%20phrase', 'raw_cookie(\\'foo\\'), 1' );\nis( join( '', @av ), 'a%20phrase', 'raw_cookie(\\'foo\\'), 2' );\n\n# raw_cookie() - scalar and array context, invalid argument\n\n$sv = raw_cookie( 'invalid' );\n@av = raw_cookie( 'invalid' );\nis( $sv, undef, 'raw_cookie(\\'invalid\\'), 1' );\nis( join( '', @av ), '', 'raw_cookie(\\'invalid\\'), 2' );\n\n# cookie() - scalar and array context, void argument\n\n$sv = cookie();\n@av = cookie();\nis( $sv, '2', 'cookie(), 1' );\n\n# fix OS perl version test bug\nis( join( ' ', sort @av ), 'bar foo', 'cookie(), 2' );\n\n# cookie() - scalar and array context, valid argument, single value\n\n$sv = cookie( 'foo' );\n@av = cookie( 'foo' );\nis( $sv, 'a phrase', 'cookie(\\'foo\\'), 1' );\nis( join( '', @av ), 'a phrase', 'cookie(\\'foo\\'), 2' );\n\n# cookie() - scalar and array context, valid argument, multiple values\n\n$sv = cookie( 'bar' );\n@av = cookie( 'bar' );\nis( $sv, 'yes, a phrase', 'cookie(\\'foo\\'), 1' );\nis( join( ' ', @av ), 'yes, a phrase I say', 'cookie(\\'foo\\'), 2' );\n\n# cookie() - scalar and array context, invalid argument\n\n$sv = cookie( 'invalid' );\n@av = cookie( 'invalid' );\nis( $sv, undef, 'cookie(\\'invalid\\'), 1' );\nis( join( '', @av ), '', 'cookie(\\'invalid\\'), 2' );\n\nmy @vals = (\n  -name     => 'Password',\n  -value    => [ 'superuser', 'god', 'open sesame', 'mydog woofie' ],\n  -expires  => 'Mon, 11-Nov-2018 11:00:00 GMT',\n  -domain   => '.nowhere.com',\n  -path     => '/cgi-bin/database',\n  -secure   => 1,\n  -httponly => 1\n);\n\n# cookie() - scalar and array context, full argument set, correct order\n\n$sv = cookie( @vals );\n@av = cookie( @vals );\nis(\n  $sv,\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) correct order, 1'\n);\nis(\n  join( '', @av ),\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) correct order, 2'\n);\n\n# cookie() - scalar and array context, full argument set, incorrect order\n\n$sv = cookie( @vals[ 0, 1, 10, 11, 12, 13, 8, 9, 2, 3, 4, 5, 6, 7 ] );\n@av = cookie( @vals[ 0, 1, 10, 11, 12, 13, 8, 9, 2, 3, 4, 5, 6, 7 ] );\nis(\n  $sv,\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) incorrect order, 1'\n);\nis(\n  join( '', @av ),\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) incorrect order, 2'\n);\nmy $cookie = $sv;    # save a cookie for header testing\n\n# cookie() - scalar and array context, partial argument set\n\n$sv = cookie( -name => 'foo', -value => 'bar' );\n@av = cookie( -name => 'foo', -value => 'bar' );\nis(\n  $sv,\n  'foo=bar; path=/',\n  'cookie( -name=>\\'foo\\', -value=>\\'bar\\' ), 1'\n);\nis(\n  join( '', @av ),\n  'foo=bar; path=/',\n  'cookie( -name=>\\'foo\\', -value=>\\'bar\\' ), 2'\n);\n\n################# Header Methods ################\n\n$q = new CGI::Simple\n\n my $CRLF = crlf();\n\n# header() - scalar and array context, void argument\n\n$sv = header();\n@av = header();\nis( $sv, \"Content-Type: text/html; charset=ISO-8859-1$CRLF$CRLF\",\n  'header(), 1' );\nis(\n  join( '', @av ),\n  \"Content-Type: text/html; charset=ISO-8859-1$CRLF$CRLF\",\n  'header(), 2'\n);\n\n# header() - scalar context, single argument\n\n$sv = header( 'image/gif' );\nis(\n  $sv,\n  \"Content-Type: image/gif$CRLF$CRLF\",\n  'header(\\'image/gif\\'), 1'\n);\n\n@vals = (\n  -type       => 'image/gif',\n  -nph        => 1,\n  -status     => '402 Payment required',\n  -expires    => 'Mon, 11-Nov-2018 11:00:00 GMT',\n  -cookie     => $cookie,\n  -charset    => 'utf-7',\n  -attachment => 'foo.gif',\n  -Cost       => '$2.00'\n);\n\n# header() - scalar context, complex header\n\n$sv = header( @vals );\nmy $header = <<'HEADER';\nHTTP/1.0 402 Payment required\nServer: Apache - accept no substitutes\nStatus: 402 Payment required\nSet-Cookie: Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly\nExpires: Mon, 11-Nov-2018 11:00:00 GMT\nDate: Tue, 11-Nov-2018 11:00:00 GMT\nContent-Disposition: attachment; filename=\"foo.gif\"\nCost: $2.00\nContent-Type: image/gif\nHEADER\n$sv     =~ s/[\\012\\015]//g;\n$header =~ s/[\\012\\015]//g;\n$sv     =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\n$header =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\nis( $sv, $header, 'header(\\@vals) - complex header, 1' );\n\n# cache() - scalar and array context, void argument\n\n$sv = cache();\nis( $sv, undef, 'cache(), 1' );\n\n# cache() - scalar and array context, true argument, sets no cache paragma\n\n$sv = cache( 1 );\nis( $sv, 1, 'cache(1), 1' );\n$sv = header();\nis( $sv =~ /Pragma: no-cache/, 1, 'cache(1), 2' );\n\n# no_cache() - scalar and array context, void argument\n\n$sv = no_cache();\nis( $sv, undef, 'cache(), 1' );\n\n# no_cache() - scalar and array context, true argument, sets no cache paragma\n\n$sv = no_cache( 1 );\nis( $sv, 1, 'cache(1), 1' );\n$sv = header();\nis(\n  (\n         $sv =~ /Pragma: no-cache/\n     and $sv =~ /Expires:(.*?)GMT/\n     and $sv =~ /Date:$1GMT/\n  ),\n  1,\n  'cache(1), 2'\n);\n\n# redirect() - scalar and array context, void argument\n\n$sv     = redirect( 'http://a.galaxy.far.away.gov' );\n$header = <<'HEADER';\nStatus: 302 Moved\nExpires: Tue, 13 Nov 2001 06:45:15 GMT\nDate: Tue, 13 Nov 2001 06:45:15 GMT\nPragma: no-cache\nLocation: http://a.galaxy.far.away.gov\nHEADER\n$sv     =~ s/[\\012\\015]//g;\n$header =~ s/[\\012\\015]//g;\n$sv     =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\n$header =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\nis( $sv, $header, 'redirect(), 1' );\n\n# redirect() - scalar and array context, void argument\n\n$sv = redirect( -uri => 'http://a.galaxy.far.away.gov', -nph => 1 );\n$header = <<'HEADER';\nHTTP/1.0 302 Moved\nServer: Apache - accept no substitutes\nStatus: 302 Moved\nExpires: Tue, 13 Nov 2001 06:49:24 GMT\nDate: Tue, 13 Nov 2001 06:49:24 GMT\nPragma: no-cache\nLocation: http://a.galaxy.far.away.gov\nHEADER\n$sv     =~ s/[\\012\\015]//g;\n$header =~ s/[\\012\\015]//g;\n$sv     =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\n$header =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\nis( $sv, $header, 'redirect() - nph, 1' );\n\n################# Server Push Methods #################\n\nrestore_parameters();\n\n$sv = multipart_init();\nlike(\n  $sv,\n  qr|Content-Type: multipart/x-mixed-replace;boundary=\"------- =_aaaaaaaaaa0\"|,\n  'multipart_init(), 1'\n);\nlike( $sv, qr/--------- =_aaaaaaaaaa0$CRLF/, 'multipart_init(), 2' );\n$sv = multipart_init( 'this_is_the_boundary' );\nlike( $sv, qr/boundary=\"this_is_the_boundary\"/, 'multipart_init(), 3' );\n$sv = multipart_init( -boundary => 'this_is_another_boundary' );\nlike(\n  $sv,\n  qr/boundary=\"this_is_another_boundary\"/,\n  'multipart_init(), 4'\n);\n\n# multipart_start()\n\n$sv = multipart_start();\nis( $sv, \"Content-Type: text/html$CRLF$CRLF\", 'multipart_start(), 1' );\n$sv = multipart_start( 'foo/bar' );\nis( $sv, \"Content-Type: foo/bar$CRLF$CRLF\", 'multipart_start(), 2' );\n$sv = multipart_start( -type => 'text/plain' );\nis( $sv, \"Content-Type: text/plain$CRLF$CRLF\", 'multipart_start(), 3' );\n\n# multipart_end()\n\n$sv = multipart_end();\nis( $sv, \"$CRLF--this_is_another_boundary$CRLF\", 'multipart_end(), 1' );\n\n# multipart_final() - scalar and array context, void/invalid/valid argument\n\n$sv = multipart_final();\nlike( $sv, qr|--this_is_another_boundary--|, 'multipart_final(), 1' );\n\n################# Debugging Methods ################\n\n# Dump() - scalar context, void argument\n\n$sv = Dump();\nis( $sv =~ m/JaPh,/, 1, 'Dump(), 1' );\n\n# as_string()\n\nis( as_string(), Dump(), 'as_string(), 1' );\n\n# cgi_error()\n\n$ENV{'REQUEST_METHOD'} = 'GET';\n$ENV{'QUERY_STRING'}   = '';\nrestore_parameters();\n\n# changed this behaviour\n# like( cgi_error(), qr/400 No data received via method: GET/ , 'cgi_error(), 1');\nis( cgi_error(), undef, 'cgi_error(), 2' );\n$ENV{'QUERY_STRING'} = 'name=JaPh%2C&color=red&color=green&color=blue';\n\n############## cgi-lib.pl tests ################\n\n# ReadParse() - scalar and array context, void/invalid/valid argument\n\nrestore_parameters();\nReadParse();\n\n#ok ( $in{'name'}, 'JaPh,' );\nrestore_parameters();\nReadParse( *field );\nis( $field{'name'}, 'JaPh,', 'ReadParse(), 1' );\n\n# SplitParam() - scalar and array context, void/invalid/valid argument\n\nis(\n  join( ' ', SplitParam( $field{'color'} ) ),\n  'red green blue',\n  'SplitParam(), 1'\n);\nis( scalar SplitParam( $field{'color'} ), 'red', 'SplitParam(), 2' );\n\n# MethGet() - scalar and array context, void/invalid/valid argument\n\nis( MethGet(), 1, 'MethGet(), 1' );\n\n# MethPost() - scalar and array context, void/invalid/valid argument\n\nis( !MethPost(), 1, 'MethPost(), 1' );\n\n# MyBaseUrl() - scalar and array context, void/invalid/valid argument\n\nis(\n  MyBaseUrl(),\n  'http://nowhere.com:8080/cgi-bin/foo.cgi',\n  'MyBaseUrl(), 1'\n);\n$ENV{'SERVER_PORT'} = 80;\nis(\n  MyBaseUrl(),\n  'http://nowhere.com/cgi-bin/foo.cgi',\n  'MyBaseUrl(), 2'\n);\n$ENV{'SERVER_PORT'} = 8080;\n\n# MyURL() - scalar and array context, void/invalid/valid argument\n\nis( MyURL(), 'http://nowhere.com:8080/cgi-bin/foo.cgi', 'MyURL(), 1' );\n\n# MyFullUrl() - scalar and array context, void/invalid/valid argument\n\nis(\n  MyFullUrl(),\n  'http://nowhere.com:8080/cgi-bin/foo.cgi/somewhere/else?name=JaPh%2C&color=red&color=green&color=blue',\n  'MyFullUrl(), 1'\n);\n$ENV{'QUERY_STRING'} = '';\n$ENV{'PATH_INFO'}    = '';\nis(\n  MyFullUrl(),\n  'http://nowhere.com:8080/cgi-bin/foo.cgi',\n  'MyFullUrl(), 2'\n);\n$ENV{'QUERY_STRING'} = 'name=JaPh%2C&color=red&color=green&color=blue';\n$ENV{'PATH_INFO'}    = '/somewhere/else';\n\n# PrintHeader() - scalar and array context, void/invalid/valid argument\n\nlike( PrintHeader(), qr|Content-Type: text/html|, 'PrintHeader(), 1' );\n\n# HtmlTop() - scalar and array context, void/invalid/valid argument\n\nis(\n  HtmlTop( '$' ),\n  \"<html>\\n<head>\\n<title>\\$</title>\\n</head>\\n<body>\\n<h1>\\$</h1>\\n\",\n  'HtmlTop(), 1'\n);\n\n# HtmlBot() - scalar and array context, void/invalid/valid argument\n\nis( HtmlBot(), \"</body>\\n</html>\\n\", 'HtmlBot(), 1' );\n\n# PrintVariables() - scalar and array context, void/invalid/valid argument\n\nlike( PrintVariables( \\%field ), qr/JaPh,/, 'PrintVariables(), 1' );\n\n# PrintEnv() - scalar and array context, void/invalid/valid argument\n\nlike( PrintEnv(), qr/PATH_TRANSLATED/, 'PrintEnv(), 1' );\n\n# CgiDie() - scalar and array context, void/invalid/valid argument\n\n# CgiError() - scalar and array context, void/invalid/valid argument\n\n################ Accessor Methods ################\n\nrestore_parameters();\n\n# version() - scalar context, void argument\n\nlike( version(), qr/[\\d\\.]+/, 'version(), 1' );\n\n# nph() - scalar context, void  argument\n\nis( nph(), globals( 'NPH' ), 'nph(), 1' );\n\n# nph() - scalar context, valid  argument\n\nis( nph( 42 ),        42, 'nph(42), 1' );\nis( globals( 'NPH' ), 42, 'nph(42), 2' );\n\n# all_parameters() - array context, void/invalid/valid argument\n\n$sv = all_parameters();\n@av = all_parameters();\nis( $sv, 2, 'all_parameters(), 1' );\nis( join( ' ', @av ), 'name color', 'all_parameters(), 2' );\n\n# charset() - scalar context, void argument\n\n$sv = charset();\nis( $sv, 'utf-7', 'charset(), 1' )\n ;    # should remain reset to this from header method\n\n# charset() - scalar context, void argument\n\n$sv = charset( 'Linear B' );\nis( $sv, 'Linear B', 'charset(), 1' );\n$sv = charset();\nis( $sv, 'Linear B', 'charset(), 2' );\n\n# crlf() - scalar context, void argument\n\n$sv = crlf();\nlike( $sv, qr/[\\012\\015]{1,2}/, 'crlf(), 1' );\n\n# globals() - scalar and array context, void argument\n\n$sv = globals();\nis( $sv, 11, 'globals(), 1' );\n@av = globals();\nis(\n  join( ' ', sort @av ),\n  'DEBUG DISABLE_UPLOADS FATAL HEADERS_ONCE NO_NULL NO_UNDEF_PARAMS NPH PARAM_UTF8 POST_MAX USE_CGI_PM_DEFAULTS USE_PARAM_SEMICOLONS',\n  'globals(), 2'\n);\n\n# globals() - scalar context, invalid argument\n\n$sv = globals( 'FOO' );\nis( $sv, undef, 'globals(\\'FOO\\') - invalid arg, 1' );\n\n# globals() - scalar context, valid argument\n\nis( globals( 'VERSION', '3.1415' ),\n  '3.1415', 'globals(\\'VERSION\\') - valid arg, 1' );\nis( globals( 'VERSION' ),\n  '3.1415', 'globals(\\'VERSION\\') - valid arg, 2' );\n\n# auth_type() - scalar context, void argument\n\n$sv = auth_type();\nis( $sv, 'PGP MD5 DES rot13', 'auth_type(), 1' );\n\n# content_length() - scalar context, void argument\n\n$sv = content_length();\nis( $sv, '42', 'content_length(), 1' );\n\n# content_type() - scalar context, void argument\n\n$sv = content_type();\nis( $sv, 'application/x-www-form-urlencoded', 'content_type(), 1' );\n\n# document_root() - scalar context, void argument\n\n$sv = document_root();\nis( $sv, '/vs/www/foo', 'document_root(), 1' );\n\n# gateway_interface() - scalar context, void argument\n\n$sv = gateway_interface();\nis( $sv, 'bleeding edge', 'gateway_interface(), 1' );\n\n# path_translated() - scalar context, void argument\n\n$sv = path_translated();\nis( $sv, '/usr/local/somewhere/else', 'path_translated(), 1' );\n\n# referer() - scalar context, void argument\n\n$sv = referer();\nis( $sv, 'xxx.sex.com', 'referer(), 1' );\n\n# remote_addr() - scalar and array context, void/invalid/valid argument\n\n$sv = remote_addr();\nis( $sv, '127.0.0.1', 'remote_addr(), 1' );\n\n# remote_host() - scalar context, void argument\n\n$sv = remote_host();\nis( $sv, 'localhost', 'remote_host(), 1' );\n\n# remote_ident() - scalar context, void argument\n\n$sv = remote_ident();\nis( $sv, 'None of your damn business', 'remote_ident(), 1' );\n\n# remote_user() - scalar context, void argument\n\n$sv = remote_user();\nis( $sv, 'Just another Perl hacker,', 'remote_user(), 1' );\n\n# request_method() - scalar context, void argument\n\n$sv = request_method();\nis( $sv, 'GET', 'request_method(), 1' );\n\n# script_name() - scalar context, void argument\n\n$sv = script_name();\nis( $sv, '/cgi-bin/foo.cgi', 'script_name(), 1' );\n\n# server_name() - scalar context, void argument\n\n$sv = server_name();\nis( $sv, 'nowhere.com', 'server_name(), 1' );\n\n# server_port() - scalar context, void argument\n\n$sv = server_port();\nis( $sv, '8080', 'server_port(), 1' );\n\n# server_protocol() - scalar context, void argument\n\n$sv = server_protocol();\nis( $sv, 'HTTP/1.0', 'server_protocol(), 1' );\n\n# server_software() - scalar context, void argument\n\n$sv = server_software();\nis( $sv, 'Apache - accept no substitutes', 'server_software(), 1' );\n\n# user_name() - scalar context, void argument\n\n$sv = user_name();\nis( $sv, 'spammer@nowhere.com', 'user_name(), 1' );\n\n# user_agent() - scalar context, void argument\n\n$sv = user_agent();\nis( $sv, 'LWP', 'user_agent(), 1' );\n\n# user_agent() - scalar context, void argument\n\n$sv = user_agent( 'lwp' );\nis( $sv, 1, 'user_agent(), 1' );\n$sv = user_agent( 'mozilla' );\nis( $sv, '', 'user_agent(), 2' );\n\n# virtual_host() - scalar context, void argument\n\n$sv = virtual_host();\nis( $sv, 'the.vatican.org', 'virtual_host(), 1' );\n\n# path_info() - scalar and array context, void/valid argument\n\n$sv = path_info();\nis( $sv, '/somewhere/else', 'path_info(), 1' );\n$sv = path_info( 'somewhere/else/again' );\nis( $sv, '/somewhere/else/again', 'path_info(), 2' );\n$sv = path_info();\nis( $sv, '/somewhere/else/again', 'path_info(), 3' );\npath_info( '/somewhere/else' );\n\n# Accept() - scalar and array context, void argument\n\n$sv = Accept();\n@av = Accept();\nis( $sv, 5, 'Accept(), 1' );\nis(\n  join( ' ', sort @av ),\n  '*/* image/gif image/jpg text/html text/plain',\n  'Accept(), 2'\n);\n\n# Accept() - scalar context, invalid argument (matches '*/*'\n\n$sv = Accept( 'foo/bar' );\nis( $sv, '0.001', 'Accept(\\'foo/bar\\'), 1' );\n\n# Accept() - scalar and array context, void argument\n\n$sv = Accept( '*/*' );\nis( $sv, '0.001', 'Accept(), 1' );\n\n# http() - scalar and array context, void argument\n\n$sv = http();\n@av = http();\nok( $sv > 0, 'http(), 1' );\nlike( $av[0], qr/HTTP/, 'http(), 2' );\n\n# http() - scalar context, invalid arguments\n\n$sv = http( 'http-hell' );\nis( $sv, undef, 'http(\\'invalid arg\\'), 1' );\n$sv = http( 'hell' );\nis( $sv, undef, 'http(\\'invalid arg\\'), 2' );\n\n# http() - scalar context, valid arguments\n\n$sv = http( 'http-from' );\nis( $sv, 'spammer@nowhere.com', 'http(\\'valid arg\\'), 1' );\n$sv = http( 'from' );\nis( $sv, 'spammer@nowhere.com', 'http(\\'valid arg\\'), 2' );\n\n# https() - scalar and array context, void argument\n\n$sv = https();\nis( $sv, 'ON', 'https(), 1' );\n\n# https() - scalar  context, invalid argument\n\n$sv = https( 'hell' );\nis( $sv, undef, 'https(\\'invalid arg\\'), 1' );\n\n# https() - scalar context, valid arguments\n\n$sv = https( 'https-a' );\nis( $sv, 'A', 'https(\\'valid arg\\'), 1' );\n$sv = https( 'a' );\nis( $sv, 'A', 'https(\\'valid arg\\'), 2' );\n\n# protocol() - scalar context, void arguments\n\n$sv = protocol();\nis( $sv, 'https', 'protocol(), 1' );\n$ENV{'HTTPS'}       = 'OFF';\n$ENV{'SERVER_PORT'} = '443';\n$sv                 = protocol();\nis( $sv, 'https', 'protocol(), 2' );\n$ENV{'SERVER_PORT'} = '8080';\n$sv = protocol();\nis( $sv, 'http', 'protocol(), 3' );\n\n# url() - scalar context, void argument\n\n$ENV{'HTTP_HOST'} = '';\nis( url(), 'http://nowhere.com:8080/cgi-bin/foo.cgi', 'url(), 1' );\n\n# url() - scalar context, valid argument\n\nis( url( -absolute => 1 ),\n  '/cgi-bin/foo.cgi', 'CGI::url(-absolute=>1)' );\n\n# url() - scalar context, valid argument\n\nis( url( -relative => 1 ), 'foo.cgi', 'url(-relative=>1), 1' );\n\n# url() - scalar context, valid argument\n\nis(\n  url( -relative => 1, -path => 1 ),\n  'foo.cgi/somewhere/else',\n  'url(-relative=>1,-path=>1), 1'\n);\n\n# url() - scalar context, valid argument\n\nis(\n  url( -relative => 1, -path => 1, -query => 1 ),\n  'foo.cgi/somewhere/else?name=JaPh%2C&color=red&color=green&color=blue',\n  'url(-relative=>1,-path=>1,-query=>1), 1'\n);\n\n# self_url() - scalar context, void argument\n\n$sv = self_url();\n@av = self_url();\nis(\n  $sv,\n  'http://nowhere.com:8080/cgi-bin/foo.cgi/somewhere/else?name=JaPh%2C&color=red&color=green&color=blue',\n  'self_url(), 1'\n);\n\n# state() - scalar and array context, void/invalid/valid argument\n\nis( state(), self_url(), 'state(), 1' );\n\n################ Yet More Tests ################\n\n#$CGI::Simple::POST_MAX = 20;\n#$ENV{'REQUEST_METHOD'} = 'POST';\n#restore_parameters();\n#ok( cgi_error(), '413 Request entity too large: 42 bytes on STDIN exceeds $POST_MAX!' );\n\n$ENV{'REQUEST_METHOD'} = 'HEAD';\n$ENV{'QUERY_STRING'}   = '';\n$ENV{'REDIRECT_QUERY_STRING'}\n = 'name=JAPH&color=red&color=green&color=blue';\n$CGI::Simple::POST_MAX = 50;\nrestore_parameters();\n@av = param();\nis( join( ' ', @av ), 'name color', 'Yet more tests, 1' );\n@av = param( 'color' );\nis( join( ' ', @av ), 'red green blue', 'Yet more tests, 2' );\n"], "fixing_code": ["package CGI::Simple;\n\nrequire 5.004;\n\n# this module is both strict (and warnings) compliant, but they are only used\n# in testing as they add an unnecessary compile time overhead in production.\nuse strict;\nuse Carp;\n\nuse vars qw(\n $VERSION $USE_CGI_PM_DEFAULTS $DISABLE_UPLOADS $POST_MAX\n $NO_UNDEF_PARAMS $USE_PARAM_SEMICOLONS $PARAM_UTF8 $HEADERS_ONCE\n $NPH $DEBUG $NO_NULL $FATAL *in\n);\n\n$VERSION = \"1.113\";\n\n# you can hard code the global variable settings here if you want.\n# warning - do not delete the unless defined $VAR part unless you\n# want to permanently remove the ability to change the variable.\nsub _initialize_globals {\n\n  # set this to 1 to use CGI.pm default global settings\n  $USE_CGI_PM_DEFAULTS = 0\n   unless defined $USE_CGI_PM_DEFAULTS;\n\n  # see if user wants old CGI.pm defaults\n  if ( $USE_CGI_PM_DEFAULTS ) {\n    _use_cgi_pm_global_settings();\n    return;\n  }\n\n  # no file uploads by default, set to 0 to enable uploads\n  $DISABLE_UPLOADS = 1\n   unless defined $DISABLE_UPLOADS;\n\n  # use a post max of 100K, set to -1 for no limits\n  $POST_MAX = 102_400\n   unless defined $POST_MAX;\n\n  # set to 1 to not include undefined params parsed from query string\n  $NO_UNDEF_PARAMS = 0\n   unless defined $NO_UNDEF_PARAMS;\n\n  # separate the name=value pairs with ; rather than &\n  $USE_PARAM_SEMICOLONS = 0\n   unless defined $USE_PARAM_SEMICOLONS;\n\n  # return everything as utf-8\n  $PARAM_UTF8 ||= 0;\n  $PARAM_UTF8 and require Encode;\n\n  # only print headers once\n  $HEADERS_ONCE = 0\n   unless defined $HEADERS_ONCE;\n\n  # Set this to 1 to enable NPH scripts\n  $NPH = 0\n   unless defined $NPH;\n\n  # 0 => no debug, 1 => from @ARGV,  2 => from STDIN\n  $DEBUG = 0\n   unless defined $DEBUG;\n\n  # filter out null bytes in param - value pairs\n  $NO_NULL = 1\n   unless defined $NO_NULL;\n\n# set behavior when cgi_err() called -1 => silent, 0 => carp, 1 => croak\n  $FATAL = -1\n   unless defined $FATAL;\n}\n\n# I happen to disagree with many of the default global settings in CGI.pm\n# This sub is called if you set $CGI::Simple::USE_CGI_PM_GLOBALS = 1; or\n# invoke the '-default' pragma via a use CGI::Simple qw(-default);\nsub _use_cgi_pm_global_settings {\n  $USE_CGI_PM_DEFAULTS  = 1;\n  $DISABLE_UPLOADS      = 0 unless defined $DISABLE_UPLOADS;\n  $POST_MAX             = -1 unless defined $POST_MAX;\n  $NO_UNDEF_PARAMS      = 0 unless defined $NO_UNDEF_PARAMS;\n  $USE_PARAM_SEMICOLONS = 1 unless defined $USE_PARAM_SEMICOLONS;\n  $HEADERS_ONCE         = 0 unless defined $HEADERS_ONCE;\n  $NPH                  = 0 unless defined $NPH;\n  $DEBUG                = 1 unless defined $DEBUG;\n  $NO_NULL              = 0 unless defined $NO_NULL;\n  $FATAL                = -1 unless defined $FATAL;\n  $PARAM_UTF8           = 0 unless defined $PARAM_UTF8;\n}\n\n# this is called by new, we will never directly reference the globals again\nsub _store_globals {\n  my $self = shift;\n\n  $self->{'.globals'}->{'DISABLE_UPLOADS'}      = $DISABLE_UPLOADS;\n  $self->{'.globals'}->{'POST_MAX'}             = $POST_MAX;\n  $self->{'.globals'}->{'NO_UNDEF_PARAMS'}      = $NO_UNDEF_PARAMS;\n  $self->{'.globals'}->{'USE_PARAM_SEMICOLONS'} = $USE_PARAM_SEMICOLONS;\n  $self->{'.globals'}->{'HEADERS_ONCE'}         = $HEADERS_ONCE;\n  $self->{'.globals'}->{'NPH'}                  = $NPH;\n  $self->{'.globals'}->{'DEBUG'}                = $DEBUG;\n  $self->{'.globals'}->{'NO_NULL'}              = $NO_NULL;\n  $self->{'.globals'}->{'FATAL'}                = $FATAL;\n  $self->{'.globals'}->{'USE_CGI_PM_DEFAULTS'}  = $USE_CGI_PM_DEFAULTS;\n  $self->{'.globals'}->{'PARAM_UTF8'}           = $PARAM_UTF8;\n}\n\n# use the automatic calling of the import sub to set our pragmas. CGI.pm compat\nsub import {\n  my ( $self, @args ) = @_;\n\n# arguments supplied in the 'use CGI::Simple [ARGS];' will now be in @args\n  foreach ( @args ) {\n    $USE_CGI_PM_DEFAULTS = 1, next if m/^-default/i;\n    $DISABLE_UPLOADS     = 1, next if m/^-no.?upload/i;\n    $DISABLE_UPLOADS     = 0, next if m/^-upload/i;\n    $HEADERS_ONCE        = 1, next if m/^-unique.?header/i;\n    $NPH                 = 1, next if m/^-nph/i;\n    $DEBUG               = 0, next if m/^-no.?debug/i;\n    $DEBUG = defined $1 ? $1 : 2, next if m/^-debug(\\d)?/i;\n    $USE_PARAM_SEMICOLONS = 1, next if m/^-newstyle.?url/i;\n    $USE_PARAM_SEMICOLONS = 0, next if m/^-oldstyle.?url/i;\n    $NO_UNDEF_PARAMS      = 1, next if m/^-no.?undef.?param/i;\n    $FATAL                = 0, next if m/^-carp/i;\n    $FATAL                = 1, next if m/^-croak/i;\n    croak \"Pragma '$_' is not defined in CGI::Simple\\n\";\n  }\n}\n\n# used in CGI.pm .t files\nsub _reset_globals {\n  _use_cgi_pm_global_settings();\n}\n\nbinmode STDIN;\nbinmode STDOUT;\n\n# use correct encoding conversion to handle non ASCII char sets.\n# we import and install the complex routines only if we have to.\nBEGIN {\n\n  sub url_decode {\n    my ( $self, $decode ) = @_;\n    return () unless defined $decode;\n    $decode =~ tr/+/ /;\n    $decode =~ s/%([a-fA-F0-9]{2})/ pack \"C\", hex $1 /eg;\n    return $decode;\n  }\n\n  sub url_encode {\n    my ( $self, $encode ) = @_;\n    return () unless defined $encode;\n    $encode\n     =~ s/([^A-Za-z0-9\\-_.!~*'() ])/ uc sprintf \"%%%02x\",ord $1 /eg;\n    $encode =~ tr/ /+/;\n    return $encode;\n  }\n\n  if ( \"\\t\" ne \"\\011\" ) {\n    eval { require CGI::Simple::Util };\n    if ( $@ ) {\n      croak\n       \"Your server is using not using ASCII, you must install CGI::Simple::Util, error: $@\";\n    }\n\n    # hack the symbol table and replace simple encode/decode subs\n    *CGI::Simple::url_encode\n     = sub { CGI::Simple::Util::escape( $_[1] ) };\n    *CGI::Simple::url_decode\n     = sub { CGI::Simple::Util::unescape( $_[1] ) };\n  }\n}\n\n################ The Guts ################\n\nsub new {\n  my ( $class, $init ) = @_;\n  $class = ref( $class ) || $class;\n  my $self = {};\n  bless $self, $class;\n  if ( $self->_mod_perl ) {\n    if ( $init ) {\n      $self->{'.mod_perl_request'} = $init;\n      undef $init;    # otherwise _initialize takes the wrong path\n    }\n    $self->_initialize_mod_perl();\n  }\n  $self->_initialize_globals;\n  $self->_store_globals;\n  $self->_initialize( $init );\n  return $self;\n}\n\nsub _mod_perl {\n  return (\n    exists $ENV{MOD_PERL}\n     or ( $ENV{GATEWAY_INTERFACE}\n      and $ENV{GATEWAY_INTERFACE} =~ m{^CGI-Perl/} )\n  );\n}\n\n# Return the global request object under mod_perl. If you use mod_perl 2\n# and you don't set PerlOptions +GlobalRequest then the request must be\n# passed in to the new() method.\nsub _mod_perl_request {\n  my $self = shift;\n\n  my $mp = $self->{'.mod_perl'};\n\n  return unless $mp;\n\n  my $req = $self->{'.mod_perl_request'};\n  return $req if $req;\n\n  $self->{'.mod_perl_request'} = do {\n    if ( $mp == 2 ) {\n      Apache2::RequestUtil->request;\n    }\n    else {\n      Apache->request;\n    }\n  };\n}\n\nsub _initialize_mod_perl {\n  my ( $self ) = @_;\n\n  eval \"require mod_perl\";\n\n  if ( defined $mod_perl::VERSION ) {\n\n    if ( $mod_perl::VERSION >= 2.00 ) {\n      $self->{'.mod_perl'} = 2;\n\n      require Apache2::RequestRec;\n      require Apache2::RequestIO;\n      require Apache2::RequestUtil;\n      require Apache2::Response;\n      require APR::Pool;\n\n      my $r = $self->_mod_perl_request();\n\n      if ( defined $r ) {\n        $r->subprocess_env unless exists $ENV{REQUEST_METHOD};\n        $r->pool->cleanup_register(\n          \\&CGI::Simple::_initialize_globals );\n      }\n    }\n    else {\n      $self->{'.mod_perl'} = 1;\n\n      require Apache;\n\n      my $r = $self->_mod_perl_request();\n\n      if ( defined $r ) {\n        $r->register_cleanup( \\&CGI::Simple::_initialize_globals );\n      }\n    }\n  }\n}\n\nsub _initialize {\n  my ( $self, $init ) = @_;\n\n  if ( !defined $init ) {\n\n    # initialize from QUERY_STRING, STDIN or @ARGV\n    $self->_read_parse();\n  }\n  elsif ( ( ref $init ) =~ m/HASH/i ) {\n\n    # initialize from param hash\n    for my $param ( keys %{$init} ) {\n      $self->_add_param( $param, $init->{$param} );\n    }\n  }\n\n  # chromatic's blessed GLOB patch\n  # elsif ( (ref $init) =~ m/GLOB/i ) { # initialize from a file\n  elsif ( UNIVERSAL::isa( $init, 'GLOB' ) ) {   # initialize from a file\n    $self->_read_parse( $init );\n  }\n  elsif ( ( ref $init ) eq 'CGI::Simple' ) {\n\n    # initialize from a CGI::Simple object\n    require Data::Dumper;\n\n    # avoid problems with strict when Data::Dumper returns $VAR1\n    my $VAR1;\n    my $clone = eval( Data::Dumper::Dumper( $init ) );\n    if ( $@ ) {\n      $self->cgi_error( \"Can't clone CGI::Simple object: $@\" );\n    }\n    else {\n      $_[0] = $clone;\n    }\n  }\n  else {\n    $self->_parse_params( $init );    # initialize from a query string\n  }\n}\n\nsub _internal_read($*\\$;$) {\n  my ( $self, $glob, $buffer, $len ) = @_;\n  $len = 4096 if !defined $len;\n  if ( $self->{'.mod_perl'} ) {\n    my $r = $self->_mod_perl_request();\n    $r->read( $$buffer, $len );\n  }\n  else {\n    read( $glob, $$buffer, $len );\n  }\n}\n\nsub _read_parse {\n  my $self = shift;\n  my $handle = shift || \\*STDIN;\n\n  my $data   = '';\n  my $type   = $ENV{'CONTENT_TYPE'} || 'No CONTENT_TYPE received';\n  my $length = $ENV{'CONTENT_LENGTH'} || 0;\n  my $method = $ENV{'REQUEST_METHOD'} || 'No REQUEST_METHOD received';\n\n  # first check POST_MAX Steve Purkis pointed out the previous bug\n  if (  ( $method eq 'POST' or $method eq \"PUT\" )\n    and $self->{'.globals'}->{'POST_MAX'} != -1\n    and $length > $self->{'.globals'}->{'POST_MAX'} ) {\n    $self->cgi_error(\n      \"413 Request entity too large: $length bytes on STDIN exceeds \\$POST_MAX!\"\n    );\n\n    # silently discard data ??? better to just close the socket ???\n    while ( $length > 0 ) {\n      last unless _internal_read( $self, $handle, my $buffer );\n      $length -= length( $buffer );\n    }\n\n    return;\n  }\n\n  if ( $length and $type =~ m|^multipart/form-data|i ) {\n    my $got_length = $self->_parse_multipart( $handle );\n    if ( $length != $got_length ) {\n      $self->cgi_error(\n        \"500 Bad read on multipart/form-data! wanted $length, got $got_length\"\n      );\n    }\n\n    return;\n  }\n  elsif ( $method eq 'POST' or $method eq 'PUT' ) {\n    if ( $length ) {\n\n      # we may not get all the data we want with a single read on large\n      # POSTs as it may not be here yet! Credit Jason Luther for patch\n      # CGI.pm < 2.99 suffers from same bug\n      _internal_read( $self, $handle, $data, $length );\n      while ( length( $data ) < $length ) {\n        last unless _internal_read( $self, $handle, my $buffer );\n        $data .= $buffer;\n      }\n\n      unless ( $length == length $data ) {\n        $self->cgi_error( \"500 Bad read on POST! wanted $length, got \"\n           . length( $data ) );\n        return;\n      }\n\n      if ( $type !~ m|^application/x-www-form-urlencoded| ) {\n        $self->_add_param( $method . \"DATA\", $data );\n      }\n      else {\n        $self->_parse_params( $data );\n      }\n    }\n  }\n  elsif ( $method eq 'GET' or $method eq 'HEAD' ) {\n    $data\n     = $self->{'.mod_perl'}\n     ? $self->_mod_perl_request()->args()\n     : $ENV{'QUERY_STRING'}\n     || $ENV{'REDIRECT_QUERY_STRING'}\n     || '';\n    $self->_parse_params( $data );\n  }\n  else {\n    unless ( $self->{'.globals'}->{'DEBUG'}\n      and $data = $self->read_from_cmdline() ) {\n      $self->cgi_error( \"400 Unknown method $method\" );\n      return;\n    }\n\n    unless ( $data ) {\n\n# I liked this reporting but CGI.pm does not behave like this so\n# out it goes......\n# $self->cgi_error(\"400 No data received via method: $method, type: $type\");\n      return;\n    }\n\n    $self->_parse_params( $data );\n  }\n}\n\nsub _parse_params {\n  my ( $self, $data ) = @_;\n  return () unless defined $data;\n  unless ( $data =~ /[&=;]/ ) {\n    $self->{'keywords'} = [ $self->_parse_keywordlist( $data ) ];\n    return;\n  }\n  my @pairs = split /[&;]/, $data;\n  for my $pair ( @pairs ) {\n    my ( $param, $value ) = split /=/, $pair, 2;\n    next unless defined $param;\n    $value = '' unless defined $value;\n    $self->_add_param( $self->url_decode( $param ),\n      $self->url_decode( $value ) );\n  }\n}\n\nsub _add_param {\n  my ( $self, $param, $value, $overwrite ) = @_;\n  return () unless defined $param and defined $value;\n  $param =~ tr/\\000//d if $self->{'.globals'}->{'NO_NULL'};\n  @{ $self->{$param} } = () if $overwrite;\n  @{ $self->{$param} } = () unless exists $self->{$param};\n  my @values = ref $value ? @{$value} : ( $value );\n  for my $value ( @values ) {\n    next\n     if $value eq ''\n       and $self->{'.globals'}->{'NO_UNDEF_PARAMS'};\n    $value =~ tr/\\000//d if $self->{'.globals'}->{'NO_NULL'};\n    $value = Encode::decode( utf8 => $value )\n     if $self->{'.globals'}->{PARAM_UTF8};\n    push @{ $self->{$param} }, $value;\n    unless ( $self->{'.fieldnames'}->{$param} ) {\n      push @{ $self->{'.parameters'} }, $param;\n      $self->{'.fieldnames'}->{$param}++;\n    }\n  }\n  return scalar @values;    # for compatibility with CGI.pm request.t\n}\n\nsub _parse_keywordlist {\n  my ( $self, $data ) = @_;\n  return () unless defined $data;\n  $data = $self->url_decode( $data );\n  $data =~ tr/\\000//d if $self->{'.globals'}->{'NO_NULL'};\n  my @keywords = split /\\s+/, $data;\n  return @keywords;\n}\n\nsub _massage_boundary {\n  my ( $self, $boundary ) = @_;\n\n  # BUG: IE 3.01 on the Macintosh uses just the boundary,\n  # forgetting the --\n  $boundary = '--' . $boundary\n   unless exists $ENV{'HTTP_USER_AGENT'}\n     && $ENV{'HTTP_USER_AGENT'} =~ m/MSIE\\s+3\\.0[12];\\s*Mac/i;\n\n  return quotemeta $boundary;\n}\n\nsub _parse_multipart {\n  my $self = shift;\n  my $handle = shift or die \"NEED A HANDLE!?\";\n\n  my ( $boundary )\n   = $ENV{'CONTENT_TYPE'} =~ /boundary=\\\"?([^\\\";,]+)\\\"?/;\n\n  $boundary = $self->_massage_boundary( $boundary ) if $boundary;\n\n  my $got_data = 0;\n  my $data     = '';\n  my $length   = $ENV{'CONTENT_LENGTH'} || 0;\n  my $CRLF     = $self->crlf;\n\n  READ:\n\n  while ( $got_data < $length ) {\n    last READ unless _internal_read( $self, $handle, my $buffer );\n    $data .= $buffer;\n    $got_data += length $buffer;\n\n    unless ( $boundary ) {\n      # If we're going to guess the boundary we need a complete line.\n      next READ unless $data =~ /^(.*)$CRLF/o;\n      $boundary = $1;\n\n      # Still no boundary? Give up...\n      unless ( $boundary ) {\n        $self->cgi_error(\n          '400 No boundary supplied for multipart/form-data' );\n        return 0;\n      }\n      $boundary = $self->_massage_boundary( $boundary );\n    }\n\n    BOUNDARY:\n\n    while ( $data =~ m/^$boundary$CRLF/ ) {\n      ## TAB and high ascii chars are definitivelly allowed in headers.\n      ## Not accepting them in the following regex prevents the upload of\n      ## files with filenames like \"Espa\u0144a.txt\".\n      # next READ unless $data =~ m/^([\\040-\\176$CRLF]+?$CRLF$CRLF)/o;\n      next READ\n       unless $data =~ m/^([\\x20-\\x7E\\x80-\\xFF\\x09$CRLF]+?$CRLF$CRLF)/o;\n      my $header = $1;\n      ( my $unfold = $1 ) =~ s/$CRLF\\s+/ /og;\n      my ( $param ) = $unfold =~ m/form-data;\\s+name=\"?([^\\\";]*)\"?/;\n      my ( $filename )\n       = $unfold =~ m/name=\"?\\Q$param\\E\"?;\\s+filename=\"?([^\\\"]*)\"?/;\n\n      if ( defined $filename ) {\n        my ( $mime ) = $unfold =~ m/Content-Type:\\s+([-\\w\\+\\.\\/]+)/io;\n        $data =~ s/^\\Q$header\\E//;\n        ( $got_data, $data, my $fh, my $size )\n         = $self->_save_tmpfile( $handle, $boundary, $filename,\n          $got_data, $data );\n        $self->_add_param( $param, $filename );\n        $self->{'.upload_fields'}->{$param} = $filename;\n        $self->{'.filehandles'}->{$filename} = $fh if $fh;\n        $self->{'.tmpfiles'}->{$filename}\n         = { 'size' => $size, 'mime' => $mime }\n         if $size;\n        next BOUNDARY;\n      }\n      next READ\n       unless $data =~ s/^\\Q$header\\E(.*?)$CRLF(?=$boundary)//s;\n      $self->_add_param( $param, $1 );\n    }\n    unless ( $data =~ m/^$boundary/ ) {\n      ## In a perfect world, $data should always begin with $boundary.\n      ## But sometimes, IE5 prepends garbage boundaries into POST(ed) data.\n      ## Then, $data does not start with $boundary and the previous block\n      ## never gets executed. The following fix attempts to remove those\n      ## extra boundaries from readed $data and restart boundary parsing.\n      ## Note about performance: with well formed data, previous check is\n      ## executed (generally) only once, when $data value is \"$boundary--\"\n      ## at end of parsing.\n      goto BOUNDARY if ( $data =~ s/.*?$CRLF(?=$boundary$CRLF)//s );\n    }\n  }\n  return $got_data;\n}\n\nsub _save_tmpfile {\n  my ( $self, $handle, $boundary, $filename, $got_data, $data ) = @_;\n  my $fh;\n  my $CRLF      = $self->crlf;\n  my $length    = $ENV{'CONTENT_LENGTH'} || 0;\n  my $file_size = 0;\n  if ( $self->{'.globals'}->{'DISABLE_UPLOADS'} ) {\n    $self->cgi_error( \"405 Not Allowed - File uploads are disabled\" );\n  }\n  elsif ( $filename ) {\n    eval { require IO::File };\n    $self->cgi_error( \"500 IO::File is not available $@\" ) if $@;\n    $fh = new_tmpfile IO::File;\n    $self->cgi_error( \"500 IO::File can't create new temp_file\" )\n     unless $fh;\n  }\n\n# read in data until closing boundary found. buffer to catch split boundary\n# we do this regardless of whether we save the file or not to read the file\n# data from STDIN. if either uploads are disabled or no file has been sent\n# $fh will be undef so only do file stuff if $fh is true using $fh && syntax\n  $fh && binmode $fh;\n  while ( $got_data < $length ) {\n\n    my $buffer = $data;\n    last unless _internal_read( $self, \\*STDIN, $data );\n\n    # fixed hanging bug if browser terminates upload part way through\n    # thanks to Brandon Black\n    unless ( $data ) {\n      $self->cgi_error(\n        '400 Malformed multipart, no terminating boundary' );\n      undef $fh;\n      return $got_data;\n    }\n\n    $got_data += length $data;\n    if ( \"$buffer$data\" =~ m/$boundary/ ) {\n      $data = $buffer . $data;\n      last;\n    }\n\n    # we do not have partial boundary so print to file if valid $fh\n    $fh && print $fh $buffer;\n    $file_size += length $buffer;\n  }\n  $data =~ s/^(.*?)$CRLF(?=$boundary)//s;\n  $fh && print $fh $1;    # print remainder of file if valid $fh\n  $file_size += length $1;\n  return $got_data, $data, $fh, $file_size;\n}\n\n# Define the CRLF sequence.  You can't use a simple \"\\r\\n\" because of system\n# specific 'features'. On EBCDIC systems \"\\t\" ne \"\\011\" as the don't use ASCII\nsub crlf {\n  my ( $self, $CRLF ) = @_;\n  $self->{'.crlf'} = $CRLF if $CRLF;    # allow value to be set manually\n  unless ( $self->{'.crlf'} ) {\n    my $OS = $^O\n     || do { require Config; $Config::Config{'osname'} };\n    $self->{'.crlf'}\n     = ( $OS =~ m/VMS/i ) ? \"\\n\"\n     : ( \"\\t\" ne \"\\011\" ) ? \"\\r\\n\"\n     :                      \"\\015\\012\";\n  }\n  return $self->{'.crlf'};\n}\n\n################ The Core Methods ################\n\nsub param {\n  my ( $self, $param, @p ) = @_;\n  unless ( defined $param ) {    # return list of all params\n    my @params\n     = $self->{'.parameters'} ? @{ $self->{'.parameters'} } : ();\n    return @params;\n  }\n  unless ( @p ) {                # return values for $param\n    return () unless exists $self->{$param};\n    return wantarray ? @{ $self->{$param} } : $self->{$param}->[0];\n  }\n  if ( $param =~ m/^-name$/i and @p == 1 ) {\n    return () unless exists $self->{ $p[0] };\n    return wantarray ? @{ $self->{ $p[0] } } : $self->{ $p[0] }->[0];\n  }\n\n  # set values using -name=>'foo',-value=>'bar' syntax.\n  # also allows for $q->param( 'foo', 'some', 'new', 'values' ) syntax\n  ( $param, undef, @p ) = @p\n   if $param =~ m/^-name$/i;     # undef represents -value token\n  $self->_add_param( $param, ( ref $p[0] eq 'ARRAY' ? $p[0] : [@p] ),\n    'overwrite' );\n  return wantarray ? @{ $self->{$param} } : $self->{$param}->[0];\n}\n\n# a new method that provides access to a new internal routine. Useage:\n# $q->add_param( $param, $value, $overwrite )\n# $param must be a plain scalar\n# $value may be either a scalar or an array ref\n# if $overwrite is a true value $param will be overwritten with new values.\nsub add_param {\n  _add_param( @_ );\n}\n\nsub param_fetch {\n  my ( $self, $param, @p ) = @_;\n  $param\n   = ( defined $param and $param =~ m/^-name$/i ) ? $p[0] : $param;\n  return undef unless defined $param;\n  $self->_add_param( $param, [] ) unless exists $self->{$param};\n  return $self->{$param};\n}\n\n# Return a parameter in the QUERY_STRING, regardless of whether a POST or GET\nsub url_param {\n  my ( $self, $param ) = @_;\n  return () unless $ENV{'QUERY_STRING'};\n  $self->{'.url_param'} = {};\n  bless $self->{'.url_param'}, 'CGI::Simple';\n  $self->{'.url_param'}->_parse_params( $ENV{'QUERY_STRING'} );\n  return $self->{'.url_param'}->param( $param );\n}\n\nsub keywords {\n  my ( $self, @values ) = @_;\n  $self->{'keywords'}\n   = ref $values[0] eq 'ARRAY' ? $values[0] : [@values]\n   if @values;\n  my @result\n   = defined( $self->{'keywords'} ) ? @{ $self->{'keywords'} } : ();\n  return @result;\n}\n\nsub Vars {\n  my $self = shift;\n  $self->{'.sep'} = shift || $self->{'.sep'} || \"\\0\";\n  if ( wantarray ) {\n    my %hash;\n    for my $param ( $self->param ) {\n      $hash{$param} = join $self->{'.sep'}, $self->param( $param );\n    }\n    return %hash;\n  }\n  else {\n    my %tied;\n    tie %tied, \"CGI::Simple\", $self;\n    return \\%tied;\n  }\n}\n\nsub TIEHASH { $_[1] ? $_[1] : new $_[0] }\n\nsub STORE {\n  my ( $q, $p, $v ) = @_;\n  $q->param( $p, split $q->{'.sep'}, $v );\n}\n\nsub FETCH {\n  my ( $q, $p ) = @_;\n  ref $q->{$p} eq \"ARRAY\" ? join $q->{'.sep'}, @{ $q->{$p} } : $q->{$p};\n}\nsub FIRSTKEY { my $a = scalar keys %{ $_[0] }; each %{ $_[0] } }\nsub NEXTKEY { each %{ $_[0] } }\nsub EXISTS  { exists $_[0]->{ $_[1] } }\nsub DELETE  { $_[0]->delete( $_[1] ) }\nsub CLEAR   { %{ $_[0] } = () }\n\nsub append {\n  my ( $self, $param, @p ) = @_;\n  return () unless defined $param;\n\n  # set values using $q->append(-name=>'foo',-value=>'bar') syntax\n  # also allows for $q->append( 'foo', 'some', 'new', 'values' ) syntax\n  ( $param, undef, @p ) = @p\n   if $param =~ m/^-name$/i;    # undef represents -value token\n  $self->_add_param( $param,\n    ( ( defined $p[0] and ref $p[0] ) ? $p[0] : [@p] ) );\n  return $self->param( $param );\n}\n\nsub delete {\n  my ( $self, $param ) = @_;\n  return () unless defined $param;\n  $param\n   = $param =~ m/^-name$/i\n   ? shift\n   : $param;                    # allow delete(-name=>'foo') syntax\n  return undef unless defined $self->{$param};\n  delete $self->{$param};\n  delete $self->{'.fieldnames'}->{$param};\n  $self->{'.parameters'}\n   = [ grep { $_ ne $param } @{ $self->{'.parameters'} } ];\n}\n\nsub Delete { CGI::Simple::delete( @_ ) }    # for method style interface\n\nsub delete_all {\n  my $self = shift;\n  undef %{$self};\n  $self->_store_globals;\n}\n\nsub Delete_all { $_[0]->delete_all }        # as used by CGI.pm\n\nsub upload {\n  my ( $self, $filename, $writefile ) = @_;\n  unless ( $filename ) {\n    $self->cgi_error( \"No filename submitted for upload to $writefile\" )\n     if $writefile;\n    return $self->{'.filehandles'}\n     ? keys %{ $self->{'.filehandles'} }\n     : ();\n  }\n  unless ( $ENV{'CONTENT_TYPE'} =~ m|^multipart/form-data|i ) {\n    $self->cgi_error(\n      'Oops! File uploads only work if you specify ENCTYPE=\"multipart/form-data\" in your <FORM> tag'\n    );\n    return undef;\n  }\n  my $fh = $self->{'.filehandles'}->{$filename};\n\n  # allow use of upload fieldname to get filehandle\n  # this has limitation that in the event of duplicate\n  # upload field names there can only be one filehandle\n  # which will point to the last upload file\n  # access by filename does not suffer from this issue.\n  $fh\n   = $self->{'.filehandles'}->{ $self->{'.upload_fields'}->{$filename} }\n   if !$fh and defined $self->{'.upload_fields'}->{$filename};\n\n  if ( $fh ) {\n    seek $fh, 0, 0;    # get ready for reading\n    return $fh unless $writefile;\n    my $buffer;\n    unless ( open OUT, \">$writefile\" ) {\n      $self->cgi_error( \"500 Can't write to $writefile: $!\\n\" );\n      return undef;\n    }\n    binmode OUT;\n    binmode $fh;\n    print OUT $buffer while read( $fh, $buffer, 4096 );\n    close OUT;\n    $self->{'.filehandles'}->{$filename} = undef;\n    undef $fh;\n    return 1;\n  }\n  else {\n    $self->cgi_error(\n      \"No filehandle for '$filename'. Are uploads enabled (\\$DISABLE_UPLOADS = 0)? Is \\$POST_MAX big enough?\"\n    );\n    return undef;\n  }\n}\n\nsub upload_fieldnames {\n  my ( $self ) = @_;\n  return wantarray\n   ? ( keys %{ $self->{'.upload_fields'} } )\n   : [ keys %{ $self->{'.upload_fields'} } ];\n}\n\n# return the file size of an uploaded file\nsub upload_info {\n  my ( $self, $filename, $info ) = @_;\n  unless ( $ENV{'CONTENT_TYPE'} =~ m|^multipart/form-data|i ) {\n    $self->cgi_error(\n      'Oops! File uploads only work if you specify ENCTYPE=\"multipart/form-data\" in your <FORM> tag'\n    );\n    return undef;\n  }\n  return keys %{ $self->{'.tmpfiles'} } unless $filename;\n  return $self->{'.tmpfiles'}->{$filename}->{'mime'}\n   if $info =~ /mime/i;\n  return $self->{'.tmpfiles'}->{$filename}->{'size'};\n}\n\nsub uploadInfo { &upload_info }    # alias for CGI.pm compatibility\n\n# return all params/values in object as a query string suitable for 'GET'\nsub query_string {\n  my $self = shift;\n  my @pairs;\n  for my $param ( $self->param ) {\n    for my $value ( $self->param( $param ) ) {\n      next unless defined $value;\n      push @pairs,\n       $self->url_encode( $param ) . '=' . $self->url_encode( $value );\n    }\n  }\n  return join $self->{'.globals'}->{'USE_PARAM_SEMICOLONS'} ? ';' : '&',\n   @pairs;\n}\n\n# new method that will add QUERY_STRING data to our CGI::Simple object\n# if the REQUEST_METHOD was 'POST'\nsub parse_query_string {\n  my $self = shift;\n  $self->_parse_params( $ENV{'QUERY_STRING'} )\n   if defined $ENV{'QUERY_STRING'}\n     and $ENV{'REQUEST_METHOD'} eq 'POST';\n}\n\n################   Save and Restore params from file    ###############\n\nsub _init_from_file {\n  use Carp qw(confess);\n  confess \"INIT_FROM_FILE called, stupid fucker!\";\n  my ( $self, $fh ) = @_;\n  local $/ = \"\\n\";\n  while ( my $pair = <$fh> ) {\n    chomp $pair;\n    return if $pair eq '=';\n    $self->_parse_params( $pair );\n  }\n}\n\nsub save {\n  my ( $self, $fh ) = @_;\n  local ( $,, $\\ ) = ( '', '' );\n  unless ( $fh and fileno $fh ) {\n    $self->cgi_error( 'Invalid filehandle' );\n    return undef;\n  }\n  for my $param ( $self->param ) {\n    for my $value ( $self->param( $param ) ) {\n      ;\n      print $fh $self->url_encode( $param ), '=',\n       $self->url_encode( $value ), \"\\n\";\n    }\n  }\n  print $fh \"=\\n\";\n}\n\nsub save_parameters { save( @_ ) }    # CGI.pm alias for save\n\n################ Miscellaneous Methods ################\n\nsub parse_keywordlist {\n  _parse_keywordlist( @_ );\n}                                     # CGI.pm compatibility\n\nsub escapeHTML {\n  my ( $self, $escape, $newlinestoo ) = @_;\n  require CGI::Simple::Util;\n  $escape = CGI::Simple::Util::escapeHTML( $escape );\n  $escape =~ s/([\\012\\015])/'&#'.(ord $1).';'/eg if $newlinestoo;\n  return $escape;\n}\n\nsub unescapeHTML {\n  require CGI::Simple::Util;\n  return CGI::Simple::Util::unescapeHTML( $_[1] );\n}\n\nsub put {\n  my $self = shift;\n  $self->print( @_ );\n}    # send output to browser\n\nsub print {\n  shift;\n  CORE::print( @_ );\n}    # print to standard output (for overriding in mod_perl)\n\n################# Cookie Methods ################\n\nsub cookie {\n  my ( $self, @params ) = @_;\n  require CGI::Simple::Cookie;\n  require CGI::Simple::Util;\n  my ( $name, $value, $path, $domain, $secure, $expires, $httponly )\n   = CGI::Simple::Util::rearrange(\n    [\n      'NAME', [ 'VALUE', 'VALUES' ],\n      'PATH',   'DOMAIN',\n      'SECURE', 'EXPIRES',\n      'HTTPONLY'\n    ],\n    @params\n   );\n\n  # retrieve the value of the cookie, if no value is supplied\n  unless ( defined( $value ) ) {\n    $self->{'.cookies'} = CGI::Simple::Cookie->fetch\n     unless $self->{'.cookies'};\n    return () unless $self->{'.cookies'};\n\n   # if no name is supplied, then retrieve the names of all our cookies.\n    return keys %{ $self->{'.cookies'} } unless $name;\n\n    # return the value of the cookie\n    return\n     exists $self->{'.cookies'}->{$name}\n     ? $self->{'.cookies'}->{$name}->value\n     : ();\n  }\n\n  # If we get here, we're creating a new cookie\n  return undef unless $name;    # this is an error\n  @params = ();\n  push @params, '-name'     => $name;\n  push @params, '-value'    => $value;\n  push @params, '-domain'   => $domain if $domain;\n  push @params, '-path'     => $path if $path;\n  push @params, '-expires'  => $expires if $expires;\n  push @params, '-secure'   => $secure if $secure;\n  push @params, '-httponly' => $httponly if $httponly;\n  return CGI::Simple::Cookie->new( @params );\n}\n\nsub raw_cookie {\n  my ( $self, $key ) = @_;\n  if ( defined $key ) {\n    unless ( $self->{'.raw_cookies'} ) {\n      require CGI::Simple::Cookie;\n      $self->{'.raw_cookies'} = CGI::Simple::Cookie->raw_fetch;\n    }\n    return $self->{'.raw_cookies'}->{$key} || ();\n  }\n  return $ENV{'HTTP_COOKIE'} || $ENV{'COOKIE'} || '';\n}\n\n################# Header Methods ################\n\nsub header {\n  my ( $self, @params ) = @_;\n  require CGI::Simple::Util;\n  my @header;\n  return undef\n   if $self->{'.header_printed'}++\n     and $self->{'.globals'}->{'HEADERS_ONCE'};\n  my (\n    $type, $status,  $cookie,     $target, $expires,\n    $nph,  $charset, $attachment, $p3p,    @other\n   )\n   = CGI::Simple::Util::rearrange(\n    [\n      [ 'TYPE',   'CONTENT_TYPE', 'CONTENT-TYPE' ], 'STATUS',\n      [ 'COOKIE', 'COOKIES',      'SET-COOKIE' ],   'TARGET',\n      'EXPIRES', 'NPH',\n      'CHARSET', 'ATTACHMENT',\n      'P3P'\n    ],\n    @params\n   );\n\n  # CR escaping for values, per RFC 822\n  for my $header (\n    $type, $status,  $cookie,     $target, $expires,\n    $nph,  $charset, $attachment, $p3p,    @other\n   ) {\n    if ( defined $header ) {\n      $header =~ s/\n                (?<=\\n)    # For any character proceeded by a newline\n                (?=\\S)     # ... that is not whitespace\n            / /xg;    # ... inject a leading space in the new line\n    }\n  }\n\n  $nph ||= $self->{'.globals'}->{'NPH'};\n  $charset = $self->charset( $charset )\n   ;                  # get charset (and set new charset if supplied)\n   # rearrange() was designed for the HTML portion, so we need to fix it up a little.\n\n  for ( @other ) {\n\n    # Don't use \\s because of perl bug 21951\n    next\n     unless my ( $header, $value ) = /([^ \\r\\n\\t=]+)=\\\"?(.+?)\\\"?$/s;\n    ( $_ = $header )\n     =~ s/^(\\w)(.*)/\"\\u$1\\L$2\" . ': '.$self->unescapeHTML($value)/e;\n  }\n  $type ||= 'text/html' unless defined $type;\n  $type .= \"; charset=$charset\"\n   if $type\n     and $type =~ m!^text/!\n     and $type !~ /\\bcharset\\b/;\n  my $protocol = $ENV{SERVER_PROTOCOL} || 'HTTP/1.0';\n  push @header, $protocol . ' ' . ( $status || '200 OK' ) if $nph;\n  push @header, \"Server: \" . server_software() if $nph;\n  push @header, \"Status: $status\"              if $status;\n  push @header, \"Window-Target: $target\"       if $target;\n\n  if ( $p3p ) {\n    $p3p = join ' ', @$p3p if ref( $p3p ) eq 'ARRAY';\n    push( @header, qq(P3P: policyref=\"/w3c/p3p.xml\", CP=\"$p3p\") );\n  }\n\n  # push all the cookies -- there may be several\n  if ( $cookie ) {\n    my @cookie = ref $cookie eq 'ARRAY' ? @{$cookie} : $cookie;\n    for my $cookie ( @cookie ) {\n      my $cs\n       = ref $cookie eq 'CGI::Simple::Cookie'\n       ? $cookie->as_string\n       : $cookie;\n      push @header, \"Set-Cookie: $cs\" if $cs;\n    }\n  }\n\n# if the user indicates an expiration time, then we need both an Expires\n# and a Date header (so that the browser is using OUR clock)\n  $expires = 'now'\n   if $self->no_cache;    # encourage no caching via expires now\n  push @header,\n   \"Expires: \" . CGI::Simple::Util::expires( $expires, 'http' )\n   if $expires;\n  push @header, \"Date: \" . CGI::Simple::Util::expires( 0, 'http' )\n   if defined $expires || $cookie || $nph;\n  push @header, \"Pragma: no-cache\" if $self->cache or $self->no_cache;\n  push @header,\n   \"Content-Disposition: attachment; filename=\\\"$attachment\\\"\"\n   if $attachment;\n  push @header, @other;\n  push @header, \"Content-Type: $type\" if $type;\n  my $CRLF = $self->crlf;\n  my $header = join $CRLF, @header;\n  $header .= $CRLF . $CRLF;    # add the statutory two CRLFs\n\n  if ( $self->{'.mod_perl'} and not $nph ) {\n    my $r = $self->_mod_perl_request();\n    $r->send_cgi_header( $header );\n    return '';\n  }\n  return $header;\n}\n\n# Control whether header() will produce the no-cache Pragma directive.\nsub cache {\n  my ( $self, $value ) = @_;\n  $self->{'.cache'} = $value if defined $value;\n  return $self->{'.cache'};\n}\n\n# Control whether header() will produce expires now + the no-cache Pragma.\nsub no_cache {\n  my ( $self, $value ) = @_;\n  $self->{'.no_cache'} = $value if defined $value;\n  return $self->{'.no_cache'};\n}\n\nsub redirect {\n  my ( $self, @params ) = @_;\n  require CGI::Simple::Util;\n  my ( $url, $target, $cookie, $nph, @other )\n   = CGI::Simple::Util::rearrange(\n    [\n      [ 'LOCATION', 'URI',       'URL' ], 'TARGET',\n      [ 'COOKIE',   'COOKIES' ], 'NPH'\n    ],\n    @params\n   );\n  $url ||= $self->self_url;\n  my @o;\n  for ( @other ) { tr/\\\"//d; push @o, split \"=\", $_, 2; }\n  unshift @o,\n   '-Status'   => '302 Moved',\n   '-Location' => $url,\n   '-nph'      => $nph;\n  unshift @o, '-Target' => $target if $target;\n  unshift @o, '-Cookie' => $cookie if $cookie;\n  unshift @o, '-Type'   => '';\n  my @unescaped;\n  unshift( @unescaped, '-Cookie' => $cookie ) if $cookie;\n  return $self->header( ( map { $self->unescapeHTML( $_ ) } @o ),\n    @unescaped );\n}\n\n################# Server Push Methods #################\n# Return a Content-Type: style header for server-push\n# This has to be NPH, and it is advisable to set $| = 1\n# Credit to Ed Jordan <ed@fidalgo.net> and\n# Andrew Benham <adsb@bigfoot.com> for this section\n\nsub multipart_init {\n  my ( $self, @p ) = @_;\n  use CGI::Simple::Util qw(rearrange);\n  my ( $boundary, @other ) = rearrange( ['BOUNDARY'], @p );\n  if ( !$boundary ) {\n    $boundary = '------- =_';\n    my @chrs = ( '0' .. '9', 'A' .. 'Z', 'a' .. 'z' );\n    for ( 1 .. 17 ) {\n      $boundary .= $chrs[ rand( scalar @chrs ) ];\n    }\n  }\n\n  my $CRLF = $self->crlf;    # get CRLF sequence\n  my $warning\n   = \"WARNING: YOUR BROWSER DOESN'T SUPPORT THIS SERVER-PUSH TECHNOLOGY.\";\n  $self->{'.separator'}       = \"$CRLF--$boundary$CRLF\";\n  $self->{'.final_separator'} = \"$CRLF--$boundary--$CRLF$warning$CRLF\";\n  my $type = 'multipart/x-mixed-replace;boundary=\"' . $boundary . '\"';\n  return $self->header(\n    -nph  => 1,\n    -type => $type,\n    map { split \"=\", $_, 2 } @other\n   )\n   . $warning\n   . $self->multipart_end;\n}\n\nsub multipart_start {\n  my ( $self, @p ) = @_;\n  use CGI::Simple::Util qw(rearrange);\n  my ( $type, @other ) = rearrange( ['TYPE'], @p );\n  foreach ( @other ) {    # fix return from rearange\n    next unless my ( $header, $value ) = /([^\\s=]+)=\\\"?(.+?)\\\"?$/;\n    $_ = ucfirst( lc $header ) . ': ' . unescapeHTML( 1, $value );\n  }\n  $type = $type || 'text/html';\n  my @header = ( \"Content-Type: $type\" );\n  push @header, @other;\n  my $CRLF = $self->crlf;    # get CRLF sequence\n  return ( join $CRLF, @header ) . $CRLF . $CRLF;\n}\n\nsub multipart_end { return $_[0]->{'.separator'} }\n\nsub multipart_final { return $_[0]->{'.final_separator'} }\n\n################# Debugging Methods ################\n\nsub read_from_cmdline {\n  my @words;\n  if ( $_[0]->{'.globals'}->{'DEBUG'} == 1 and @ARGV ) {\n    @words = @ARGV;\n  }\n  elsif ( $_[0]->{'.globals'}->{'DEBUG'} == 2 ) {\n    require \"shellwords.pl\";\n    print \"(offline mode: enter name=value pairs on standard input)\\n\";\n    chomp( my @lines = <STDIN> );\n    @words = &shellwords( join \" \", @lines );\n  }\n  else {\n    return '';\n  }\n  @words = map { s/\\\\=/%3D/g; s/\\\\&/%26/g; $_ } @words;\n  return \"@words\" =~ m/=/ ? join '&', @words : join '+', @words;\n}\n\nsub Dump {\n  require Data::Dumper;    # short and sweet way of doing it\n  ( my $dump = Data::Dumper::Dumper( @_ ) )\n   =~ tr/\\000/0/;          # remove null bytes cgi-lib.pl\n  return '<pre>' . escapeHTML( 1, $dump ) . '</pre>';\n}\n\nsub as_string { Dump( @_ ) }    # CGI.pm alias for Dump()\n\nsub cgi_error {\n  my ( $self, $err ) = @_;\n  if ( $err ) {\n    $self->{'.cgi_error'} = $err;\n       $self->{'.globals'}->{'FATAL'} == 1 ? croak $err\n     : $self->{'.globals'}->{'FATAL'} == 0 ? carp $err\n     :                                       return $err;\n  }\n  return $self->{'.cgi_error'};\n}\n\n################# cgi-lib.pl Compatibility Methods #################\n# Lightly GOLFED but the original functionality remains. You can call\n# them using either: # $q->MethodName or CGI::Simple::MethodName\n\nsub _shift_if_ref { shift if ref $_[0] eq 'CGI::Simple' }\n\nsub ReadParse {\n  my $q = &_shift_if_ref || new CGI::Simple;\n  my $pkg = caller();\n  no strict 'refs';\n  *in\n   = @_\n   ? $_[0]\n   : *{\"${pkg}::in\"};    # set *in to passed glob or export *in\n  %in = $q->Vars;\n  $in{'CGI'} = $q;\n  return scalar %in;\n}\n\nsub SplitParam {\n  &_shift_if_ref;\n  defined $_[0]\n   && ( wantarray ? split \"\\0\", $_[0] : ( split \"\\0\", $_[0] )[0] );\n}\n\nsub MethGet { request_method() eq 'GET' }\n\nsub MethPost { request_method() eq 'POST' }\n\nsub MyBaseUrl {\n  local $^W = 0;\n  'http://'\n   . server_name()\n   . ( server_port() != 80 ? ':' . server_port() : '' )\n   . script_name();\n}\n\nsub MyURL { MyBaseUrl() }\n\nsub MyFullUrl {\n  local $^W = 0;\n  MyBaseUrl()\n   . $ENV{'PATH_INFO'}\n   . ( $ENV{'QUERY_STRING'} ? \"?$ENV{'QUERY_STRING'}\" : '' );\n}\n\nsub PrintHeader {\n  ref $_[0] ? $_[0]->header() : \"Content-Type: text/html\\n\\n\";\n}\n\nsub HtmlTop {\n  &_shift_if_ref;\n  \"<html>\\n<head>\\n<title>$_[0]</title>\\n</head>\\n<body>\\n<h1>$_[0]</h1>\\n\";\n}\n\nsub HtmlBot { \"</body>\\n</html>\\n\" }\n\nsub PrintVariables { &_shift_if_ref; &Dump }\n\nsub PrintEnv { &Dump( \\%ENV ) }\n\nsub CgiDie { CgiError( @_ ); die @_ }\n\nsub CgiError {\n  &_shift_if_ref;\n  @_\n   = @_\n   ? @_\n   : ( \"Error: script \" . MyFullUrl() . \" encountered fatal error\\n\" );\n  print PrintHeader(), HtmlTop( shift ), ( map { \"<p>$_</p>\\n\" } @_ ),\n   HtmlBot();\n}\n\n################ Accessor Methods ################\n\nsub version { $VERSION }\n\nsub nph {\n  $_[0]->{'.globals'}->{'NPH'} = $_[1] if defined $_[1];\n  return $_[0]->{'.globals'}->{'NPH'};\n}\n\nsub all_parameters { $_[0]->param }\n\nsub charset {\n  require CGI::Simple::Util;\n  $CGI::Simple::Util::UTIL->charset( $_[1] );\n}\n\nsub globals {\n  my ( $self, $global, $value ) = @_;\n  return keys %{ $self->{'.globals'} } unless $global;\n  $self->{'.globals'}->{$global} = $value if defined $value;\n  return $self->{'.globals'}->{$global};\n}\n\nsub auth_type         { $ENV{'AUTH_TYPE'} }\nsub content_length    { $ENV{'CONTENT_LENGTH'} }\nsub content_type      { $ENV{'CONTENT_TYPE'} }\nsub document_root     { $ENV{'DOCUMENT_ROOT'} }\nsub gateway_interface { $ENV{'GATEWAY_INTERFACE'} }\nsub path_translated   { $ENV{'PATH_TRANSLATED'} }\nsub referer           { $ENV{'HTTP_REFERER'} }\nsub remote_addr       { $ENV{'REMOTE_ADDR'} || '127.0.0.1' }\n\nsub remote_host {\n  $ENV{'REMOTE_HOST'} || $ENV{'REMOTE_ADDR'} || 'localhost';\n}\n\nsub remote_ident   { $ENV{'REMOTE_IDENT'} }\nsub remote_user    { $ENV{'REMOTE_USER'} }\nsub request_method { $ENV{'REQUEST_METHOD'} }\nsub script_name    { $ENV{'SCRIPT_NAME'} || $0 || '' }\nsub server_name     { $ENV{'SERVER_NAME'}     || 'localhost' }\nsub server_port     { $ENV{'SERVER_PORT'}     || 80 }\nsub server_protocol { $ENV{'SERVER_PROTOCOL'} || 'HTTP/1.0' }\nsub server_software { $ENV{'SERVER_SOFTWARE'} || 'cmdline' }\n\nsub user_name {\n  $ENV{'HTTP_FROM'} || $ENV{'REMOTE_IDENT'} || $ENV{'REMOTE_USER'};\n}\n\nsub user_agent {\n  my ( $self, $match ) = @_;\n  return $match\n   ? $ENV{'HTTP_USER_AGENT'} =~ /\\Q$match\\E/i\n   : $ENV{'HTTP_USER_AGENT'};\n}\n\nsub virtual_host {\n  my $vh = $ENV{'HTTP_HOST'} || $ENV{'SERVER_NAME'};\n  $vh =~ s/:\\d+$//;    # get rid of port number\n  return $vh;\n}\n\nsub path_info {\n  my ( $self, $info ) = @_;\n  if ( defined $info ) {\n    $info = \"/$info\" if $info !~ m|^/|;\n    $self->{'.path_info'} = $info;\n  }\n  elsif ( !defined( $self->{'.path_info'} ) ) {\n    $self->{'.path_info'}\n     = defined( $ENV{'PATH_INFO'} ) ? $ENV{'PATH_INFO'} : '';\n\n    # hack to fix broken path info in IIS source CGI.pm\n    $self->{'.path_info'} =~ s/^\\Q$ENV{'SCRIPT_NAME'}\\E//\n     if defined( $ENV{'SERVER_SOFTWARE'} )\n       && $ENV{'SERVER_SOFTWARE'} =~ /IIS/;\n  }\n  return $self->{'.path_info'};\n}\n\nsub accept {\n  my ( $self, $search ) = @_;\n  my %prefs;\n  for my $accept ( split ',', $ENV{'HTTP_ACCEPT'} ) {\n    ( my $pref ) = $accept =~ m|q=([\\d\\.]+)|;\n    ( my $type ) = $accept =~ m|(\\S+/[^;]+)|;\n    next unless $type;\n    $prefs{$type} = $pref || 1;\n  }\n  return keys %prefs unless $search;\n  return $prefs{$search} if $prefs{$search};\n\n  # Didn't get it, so try pattern matching.\n  for my $pref ( keys %prefs ) {\n    next unless $pref =~ m/\\*/;    # not a pattern match\n    ( my $pat = $pref ) =~ s/([^\\w*])/\\\\$1/g;   # escape meta characters\n    $pat =~ s/\\*/.*/g;                          # turn it into a pattern\n    return $prefs{$pref} if $search =~ /$pat/;\n  }\n}\n\nsub Accept { my $self = shift; $self->accept( @_ ) }\n\nsub http {\n  my ( $self, $parameter ) = @_;\n  if ( defined $parameter ) {\n    ( $parameter = uc $parameter ) =~ tr/-/_/;\n    return $ENV{$parameter} if $parameter =~ m/^HTTP/;\n    return $ENV{\"HTTP_$parameter\"} if $parameter;\n  }\n  return grep { /^HTTP/ } keys %ENV;\n}\n\nsub https {\n  my ( $self, $parameter ) = @_;\n  return $ENV{'HTTPS'} unless $parameter;\n  ( $parameter = uc $parameter ) =~ tr/-/_/;\n  return $ENV{$parameter} if $parameter =~ /^HTTPS/;\n  return $ENV{\"HTTPS_$parameter\"};\n}\n\nsub protocol {\n  local ( $^W ) = 0;\n  my $self = shift;\n  return 'https' if uc $ENV{'HTTPS'} eq 'ON';\n  return 'https' if $self->server_port == 443;\n  my ( $protocol, $version ) = split '/', $self->server_protocol;\n  return lc $protocol;\n}\n\nsub url {\n  my ( $self, @p ) = @_;\n  use CGI::Simple::Util 'rearrange';\n  my ( $relative, $absolute, $full, $path_info, $query, $base )\n   = rearrange(\n    [\n      'RELATIVE', 'ABSOLUTE', 'FULL',\n      [ 'PATH',  'PATH_INFO' ],\n      [ 'QUERY', 'QUERY_STRING' ], 'BASE'\n    ],\n    @p\n   );\n  my $url;\n  $full++ if $base || !( $relative || $absolute );\n  my $path        = $self->path_info;\n  my $script_name = $self->script_name;\n  if ( $full ) {\n    my $protocol = $self->protocol();\n    $url = \"$protocol://\";\n    my $vh = $self->http( 'host' );\n    if ( $vh ) {\n      $url .= $vh;\n    }\n    else {\n      $url .= server_name();\n      my $port = $self->server_port;\n      $url .= \":\" . $port\n       unless ( lc( $protocol ) eq 'http' && $port == 80 )\n       or ( lc( $protocol ) eq 'https' && $port == 443 );\n    }\n    return $url if $base;\n    $url .= $script_name;\n  }\n  elsif ( $relative ) {\n    ( $url ) = $script_name =~ m#([^/]+)$#;\n  }\n  elsif ( $absolute ) {\n    $url = $script_name;\n  }\n  $url .= $path if $path_info and defined $path;\n  $url .= \"?\" . $self->query_string if $query and $self->query_string;\n  $url = '' unless defined $url;\n  $url\n   =~ s/([^a-zA-Z0-9_.%;&?\\/\\\\:+=~-])/uc sprintf(\"%%%02x\",ord($1))/eg;\n  return $url;\n}\n\nsub self_url {\n  my ( $self, @params ) = @_;\n  return $self->url(\n    '-path_info' => 1,\n    '-query'     => 1,\n    '-full'      => 1,\n    @params\n  );\n}\n\nsub state { self_url( @_ ) }    # CGI.pm synonym routine\n\n1;\n\n=head1 NAME\n\nCGI::Simple - A Simple totally OO CGI interface that is CGI.pm compliant\n\n=head1 VERSION\n\nThis document describes CGI::Simple version 1.113.\n\n=head1 SYNOPSIS\n\n    use CGI::Simple;\n    $CGI::Simple::POST_MAX = 1024;       # max upload via post default 100kB\n    $CGI::Simple::DISABLE_UPLOADS = 0;   # enable uploads\n\n    $q = new CGI::Simple;\n    $q = new CGI::Simple( { 'foo'=>'1', 'bar'=>[2,3,4] } );\n    $q = new CGI::Simple( 'foo=1&bar=2&bar=3&bar=4' );\n    $q = new CGI::Simple( \\*FILEHANDLE );\n\n    $q->save( \\*FILEHANDLE );   # save current object to a file as used by new\n\n    @params = $q->param;        # return all param names as a list\n    $value = $q->param('foo');  # return the first value supplied for 'foo'\n    @values = $q->param('foo'); # return all values supplied for foo\n\n    %fields   = $q->Vars;      # returns untied key value pair hash\n    $hash_ref = $q->Vars;      # or as a hash ref\n    %fields   = $q->Vars(\"|\"); # packs multiple values with \"|\" rather than \"\\0\";\n\n    @keywords = $q->keywords;  # return all keywords as a list\n\n    $q->param( 'foo', 'some', 'new', 'values' );      # set new 'foo' values\n    $q->param( -name=>'foo', -value=>'bar' );\n    $q->param( -name=>'foo', -value=>['bar','baz'] );\n\n    $q->param( 'foo', 'some', 'new', 'values' );      # append values to 'foo'\n    $q->append( -name=>'foo', -value=>'bar' );\n    $q->append( -name=>'foo', -value=>['some', 'new', 'values'] );\n\n    $q->delete('foo'); # delete param 'foo' and all its values\n    $q->delete_all;    # delete everything\n\n    <INPUT TYPE=\"file\" NAME=\"upload_file\" SIZE=\"42\">\n\n    $files    = $q->upload()                # number of files uploaded\n    @files    = $q->upload();               # names of all uploaded files\n    $filename = $q->param('upload_file')    # filename of uploaded file\n    $mime     = $q->upload_info($filename,'mime'); # MIME type of uploaded file\n    $size     = $q->upload_info($filename,'size'); # size of uploaded file\n\n    my $fh = $q->upload($filename);         # get filehandle to read from\n    while ( read( $fh, $buffer, 1024 ) ) { ... }\n\n    # short and sweet upload\n    $ok = $q->upload( $q->param('upload_file'), '/path/to/write/file.name' );\n    print \"Uploaded \".$q->param('upload_file').\" and wrote it OK!\" if $ok;\n\n    $decoded    = $q->url_decode($encoded);\n    $encoded    = $q->url_encode($unencoded);\n    $escaped    = $q->escapeHTML('<>\"&');\n    $unescaped  = $q->unescapeHTML('&lt;&gt;&quot;&amp;');\n\n    $qs = $q->query_string; # get all data in $q as a query string OK for GET\n\n    $q->no_cache(1);        # set Pragma: no-cache + expires\n    print $q->header();     # print a simple header\n    # get a complex header\n    $header = $q->header(   -type       => 'image/gif'\n                            -nph        => 1,\n                            -status     => '402 Payment required',\n                            -expires    =>'+24h',\n                            -cookie     => $cookie,\n                            -charset    => 'utf-7',\n                            -attachment => 'foo.gif',\n                            -Cost       => '$2.00'\n                        );\n    # a p3p header (OK for redirect use as well)\n    $header = $q->header( -p3p => 'policyref=\"http://somesite.com/P3P/PolicyReferences.xml' );\n\n    @cookies = $q->cookie();        # get names of all available cookies\n    $value   = $q->cookie('foo')    # get first value of cookie 'foo'\n    @value   = $q->cookie('foo')    # get all values of cookie 'foo'\n    # get a cookie formatted for header() method\n    $cookie  = $q->cookie(  -name    => 'Password',\n                            -values  => ['superuser','god','my dog woofie'],\n                            -expires => '+3d',\n                            -domain  => '.nowhere.com',\n                            -path    => '/cgi-bin/database',\n                            -secure  => 1\n                         );\n    print $q->header( -cookie=>$cookie );       # set cookie\n\n    print $q->redirect('http://go.away.now');   # print a redirect header\n\n    dienice( $q->cgi_error ) if $q->cgi_error;\n\n=head1 DESCRIPTION\n\nCGI::Simple provides a relatively lightweight drop in replacement for CGI.pm.\nIt shares an identical OO interface to CGI.pm for parameter parsing, file\nupload, cookie handling and header generation. This module is entirely object\noriented, however a complete functional interface is available by using the\nCGI::Simple::Standard module.\n\nEssentially everything in CGI.pm that relates to the CGI (not HTML) side of\nthings is available. There are even a few new methods and additions to old\nones! If you are interested in what has gone on under the hood see the\nCompatibility with CGI.pm section at the end.\n\nIn practical testing this module loads and runs about twice as fast as CGI.pm\ndepending on the precise task.\n\n=head1 CALLING CGI::Simple ROUTINES USING THE OBJECT INTERFACE\n\nHere is a very brief rundown on how you use the interface. Full details\nfollow.\n\n=head2 First you need to initialize an object\n\nBefore you can call a CGI::Simple method you must create a CGI::Simple object.\nYou do that by using the module and then calling the new() constructor:\n\n    use CGI::Simple;\n    my $q = new CGI::Simple;\n\nIt is traditional to call your object $q for query or perhaps $cgi.\n\n=head2 Next you call methods on that object\n\nOnce you have your object you can call methods on it using the -> arrow\nsyntax For example to get the names of all the parameters passed to your\nscript you would just write:\n\n    @names = $q->param();\n\nMany methods are sensitive to the context in which you call them. In the\nexample above the B<param()> method returns a list of all the parameter names\nwhen called without any arguments.\n\nWhen you call B<param('arg')> with a single argument it assumes you want\nto get the value(s) associated with that argument (parameter). If you ask\nfor an array it gives you an array of all the values associated with it's\nargument:\n\n    @values = $q->param('foo');  # get all the values for 'foo'\n\nwhereas if you ask for a scalar like this:\n\n    $value = $q->param('foo');   # get only the first value for 'foo'\n\nthen it returns only the first value (if more than one value for\n'foo' exists).\n\nMost CGI::Simple routines accept several arguments, sometimes as many as\n10 optional ones!  To simplify this interface, all routines use a named\nargument calling style that looks like this:\n\n    print $q->header( -type=>'image/gif', -expires=>'+3d' );\n\nEach argument name is preceded by a dash.  Neither case nor order\nmatters in the argument list.  -type, -Type, and -TYPE are all\nacceptable.\n\nSeveral routines are commonly called with just one argument.  In the\ncase of these routines you can provide the single argument without an\nargument name.  B<header()> happens to be one of these routines.  In this\ncase, the single argument is the document type.\n\n   print $q->header('text/html');\n\nSometimes methods expect a scalar, sometimes a reference to an\narray, and sometimes a reference to a hash.  Often, you can pass any\ntype of argument and the routine will do whatever is most appropriate.\nFor example, the B<param()> method can be used to set a CGI parameter to a\nsingle or a multi-valued value.  The two cases are shown below:\n\n   $q->param(-name=>'veggie',-value=>'tomato');\n   $q->param(-name=>'veggie',-value=>['tomato','tomahto','potato','potahto']);\n\n=head1 CALLING CGI::Simple ROUTINES USING THE FUNCTION INTERFACE\n\nFor convenience a functional interface is provided by the\nCGI::Simple::Standard module. This hides the OO details from you and allows\nyou to simply call methods. You may either use AUTOLOADING of methods or\nimport specific method sets into you namespace. Here are the first few\nexamples again using the function interface.\n\n    use CGI::Simple::Standard qw(-autoload);\n    @names  = param();\n    @values = param('foo');\n    $value  = param('foo');\n    print header(-type=>'image/gif',-expires=>'+3d');\n    print header('text/html');\n\nYes that's it. Not a $q-> in sight. You just use the module and select\nhow/which methods to load. You then just call the methods you want exactly\nas before but without the $q-> notation.\n\nWhen (if) you read the following docs and are using the functional interface\njust pretend the $q-> is not there.\n\n=head2 Selecting which methods to load\n\nWhen you use the functional interface Perl needs to be able to find the\nfunctions you call. The simplest way of doing this is to use autoloading as\nshown above. When you use CGI::Simple::Standard with the '-autoload' pragma\nit exports a single AUTOLOAD sub into you namespace. Every time you call a\nnon existent function AUTOLOAD is called and will load the required\nfunction and install it in your namespace. Thus only the AUTOLOAD sub and\nthose functions you specifically call will be imported.\n\nAlternatively CGI::Simple::Standard provides a range of function sets you can\nimport or you can just select exactly what you want. You do this using the\nfamiliar\n\n    use CGI::Simple::Standard qw( :func_set  some_func);\n\nnotation. This will import the ':func_set' function set and the specific\nfunction 'some_func'.\n\n=head2 To Autoload or not to Autoload, that is the question.\n\nIf you do not have a AUTOLOAD sub in you script it is generally best to use\nthe '-autoload' option. Under autoload you can use any method you want but\nonly import and compile those functions you actually use.\n\nIf you do not use autoload you must specify what functions to import. You can\nonly use functions that you have imported. For comvenience functions are\ngrouped into related sets. If you choose to import one or more ':func_set'\nyou may have potential namespace collisions so check out the docs to see\nwhat gets imported. Using the ':all' tag is pretty slack but it is there\nif you want. Full details of the function sets are provided in the\nCGI::Simple::Standard docs\n\nIf you just want say the param and header methods just load these two.\n\n    use CGI::Simple::Standard qw(param header);\n\n=head2 Setting globals using the functional interface\n\nWhere you see global variables being set using the syntax:\n\n    $CGI::Simple::DEBUG = 1;\n\nYou use exactly the same syntax when using CGI::Simple::Standard.\n\n=cut\n\n################ The Core Methods ################\n\n=head1 THE CORE METHODS\n\n=head2 new() Creating a new query object\n\nThe first step in using CGI::Simple is to create a new query object using\nthe B<new()> constructor:\n\n     $q = new CGI::Simple;\n\nThis will parse the input (from both POST and GET methods) and store\nit into an object called $q.\n\nIf you provide a file handle to the B<new()> method, it will read\nparameters from the file (or STDIN, or whatever).\n\n     open FH, \"test.in\" or die $!;\n     $q = new CGI::Simple(\\*FH);\n\n     open $fh, \"test.in\" or die $!;\n     $q = new CGI::Simple($fh);\n\nThe file should be a series of newline delimited TAG=VALUE pairs.\nConveniently, this type of file is created by the B<save()> method\n(see below). Multiple records can be saved and restored.\nIO::File objects work fine.\n\nIf you are using the function-oriented interface provided by\nCGI::Simple::Standard and want to initialize from a file handle,\nthe way to do this is with B<restore_parameters()>.  This will (re)initialize\nthe default CGI::Simple object from the indicated file handle.\n\n    restore_parameters(\\*FH);\n\nIn fact for all intents and purposes B<restore_parameters()> is identical\nto B<new()> Note that B<restore_parameters()> does not exist in\nCGI::Simple itself so you can't use it.\n\nYou can also initialize the query object from an associative array\nreference:\n\n    $q = new CGI::Simple( { 'dinosaur' => 'barney',\n                            'song'     => 'I love you',\n                            'friends'  => [qw/Jessica George Nancy/] }\n                        );\n\nor from a properly formatted, URL-escaped query string:\n\n    $q = new CGI::Simple( 'dinosaur=barney&color=purple' );\n\nor from a previously existing CGI::Simple object (this generates an identical clone\nincluding all global variable settings, etc that are stored in the object):\n\n    $old_query = new CGI::Simple;\n    $new_query = new CGI::Simple($old_query);\n\nTo create an empty query, initialize it from an empty string or hash:\n\n    $empty_query = new CGI::Simple(\"\");\n\n       -or-\n\n    $empty_query = new CGI::Simple({});\n\n=head2 keywords() Fetching a list of keywords from a query\n\n    @keywords = $q->keywords;\n\nIf the script was invoked as the result of an <ISINDEX> search, the\nparsed keywords can be obtained as an array using the B<keywords()> method.\n\n=head2 param() Fetching the names of all parameters passed to your script\n\n    @names = $q->param;\n\nIf the script was invoked with a parameter list\n(e.g. \"name1=value1&name2=value2&name3=value3\"), the B<param()> method\nwill return the parameter names as a list.  If the script was invoked\nas an <ISINDEX> script and contains a string without ampersands\n(e.g. \"value1+value2+value3\") , there will be a single parameter named\n\"keywords\" containing the \"+\"-delimited keywords.\n\nNOTE: The array of parameter names returned will\nbe in the same order as they were submitted by the browser.\nUsually this order is the same as the order in which the\nparameters are defined in the form (however, this isn't part\nof the spec, and so isn't guaranteed).\n\n=head2 param() Fetching the value or values of a simple named parameter\n\n    @values = $q->param('foo');\n\n          -or-\n\n    $value = $q->param('foo');\n\nPass the B<param()> method a single argument to fetch the value of the\nnamed parameter. If the parameter is multi-valued (e.g. from multiple\nselections in a scrolling list), you can ask to receive an array.  Otherwise\nthe method will return a single value.\n\nIf a value is not given in the query string, as in the queries\n\"name1=&name2=\" or \"name1&name2\", it will be returned by default\nas an empty string. If you set the global variable:\n\n    $CGI::Simple::NO_UNDEF_PARAMS = 1;\n\nThen value-less parameters will be ignored, and will not exist in the\nquery object. If you try to access them via param you will get an undef\nreturn value.\n\n=head2 param() Setting the values of a named parameter\n\n    $q->param('foo','an','array','of','values');\n\nThis sets the value for the named parameter 'foo' to an array of\nvalues.  This is one way to change the value of a field.\n\nB<param()> also recognizes a named parameter style of calling described\nin more detail later:\n\n    $q->param(-name=>'foo',-values=>['an','array','of','values']);\n\n                  -or-\n\n    $q->param(-name=>'foo',-value=>'the value');\n\n=head2 param() Retrieving non-application/x-www-form-urlencoded data\n\nIf POSTed or PUTed data is not of type application/x-www-form-urlencoded or multipart/form-data, \nthen the data will not be processed, but instead be returned as-is in a parameter named POSTDATA\nor PUTDATA.  To retrieve it, use code like this:\n\n    my $data = $q->param( 'POSTDATA' );\n\n                  -or-\n\n    my $data = $q->param( 'PUTDATA' );\n\n(If you don't know what the preceding means, don't worry about it.  It only affects people trying\nto use CGI::Simple for REST webservices)\n\n=head2 add_param() Setting the values of a named parameter\n\nYou nay also use the new method B<add_param> to add parameters. This is an\nalias to the _add_param() internal method that actually does all the work.\nYou can call it like this:\n\n    $q->add_param('foo', 'new');\n    $q->add_param('foo', [1,2,3,4,5]);\n    $q->add_param( 'foo', 'bar', 'overwrite' );\n\nThe first argument is the parameter, the second the value or an array ref\nof values and the optional third argument sets overwrite mode. If the third\nargument is absent of false the values will be appended. If true the values\nwill overwrite any existing ones\n\n=head2 append() Appending values to a named parameter\n\n   $q->append(-name=>'foo',-values=>['yet','more','values']);\n\nThis adds a value or list of values to the named parameter.  The\nvalues are appended to the end of the parameter if it already exists.\nOtherwise the parameter is created.  Note that this method only\nrecognizes the named argument calling syntax.\n\n=head2 import_names() Importing all parameters into a namespace.\n\nThis method was silly, non OO and has been deleted. You can get all the params\nas a hash using B<Vars> or via all the other accessors.\n\n=head2 delete() Deleting a parameter completely\n\n    $q->delete('foo');\n\nThis completely clears a parameter. If you are using the function call\ninterface, use B<Delete()> instead to avoid conflicts with Perl's\nbuilt-in delete operator.\n\nIf you are using the function call interface, use B<Delete()> instead to\navoid conflicts with Perl's built-in delete operator.\n\n=head2 delete_all() Deleting all parameters\n\n    $q->delete_all();\n\nThis clears the CGI::Simple object completely. For CGI.pm compatibility\nB<Delete_all()> is provided however there is no reason to use this in the\nfunction call interface other than symmetry.\n\nFor CGI.pm compatibility B<Delete_all()> is provided as an alias for\nB<delete_all> however there is no reason to use this, even in the\nfunction call interface.\n\n=head2 param_fetch() Direct access to the parameter list\n\nThis method is provided for CGI.pm compatibility only. It returns an\narray ref to the values associated with a named param. It is deprecated.\n\n=head2 Vars() Fetching the entire parameter list as a hash\n\n    $params = $q->Vars;  # as a tied hash ref\n    print $params->{'address'};\n    @foo = split \"\\0\", $params->{'foo'};\n\n    %params = $q->Vars;  # as a plain hash\n    print $params{'address'};\n    @foo = split \"\\0\", $params{'foo'};\n\n    %params = $q->Vars(','); # specifying a different separator than \"\\0\"\n    @foo = split ',', $params{'foo'};\n\nMany people want to fetch the entire parameter list as a hash in which\nthe keys are the names of the CGI parameters, and the values are the\nparameters' values.  The B<Vars()> method does this.\n\nCalled in a scalar context, it returns the parameter list as a tied\nhash reference. Because this hash ref is tied changing a key/value\nchanges the underlying CGI::Simple object.\n\nCalled in a list context, it returns the parameter list as an ordinary hash.\nChanging this hash will not change the underlying CGI::Simple object\n\nWhen using B<Vars()>, the thing you must watch out for are multi-valued CGI\nparameters.  Because a hash cannot distinguish between scalar and\nlist context, multi-valued parameters will be returned as a packed\nstring, separated by the \"\\0\" (null) character.  You must split this\npacked string in order to get at the individual values.  This is the\nconvention introduced long ago by Steve Brenner in his cgi-lib.pl\nmodule for Perl version 4.\n\nYou can change the character used to do the multiple value packing by passing\nit to B<Vars()> as an argument as shown.\n\n=head2 url_param() Access the QUERY_STRING regardless of 'GET' or 'POST'\n\nThe B<url_param()> method makes the QUERY_STRING data available regardless\nof whether the REQUEST_METHOD was 'GET' or 'POST'. You can do anything\nwith B<url_param> that you can do with B<param()>, however the data set\nis completely independent.\n\nTechnically what happens if you use this method is that the QUERY_STRING data\nis parsed into a new CGI::Simple object which is stored within the current\nobject. B<url_param> then just calls B<param()> on this new object.\n\n=head2 parse_query_string() Add QUERY_STRING data to 'POST' requests\n\nWhen the REQUEST_METHOD is 'POST' the default behavior is to ignore\nname/value pairs or keywords in the $ENV{'QUERY_STRING'}. You can override\nthis by calling B<parse_query_string()> which will add the QUERY_STRING data to\nthe data already in our CGI::Simple object if the REQUEST_METHOD was 'POST'\n\n    $q = new CGI::Simple;\n    $q->parse_query_string;  # add $ENV{'QUERY_STRING'} data to our $q object\n\nIf the REQUEST_METHOD was 'GET' then the QUERY_STRING will already be\nstored in our object so B<parse_query_string> will be ignored.\n\nThis is a new method in CGI::Simple that is not available in CGI.pm\n\n=head2 save() Saving the state of an object to file\n\n    $q->save(\\*FILEHANDLE)\n\nThis will write the current state of the form to the provided\nfilehandle.  You can read it back in by providing a filehandle\nto the B<new()> method.\n\nThe format of the saved file is:\n\n    NAME1=VALUE1\n    NAME1=VALUE1'\n    NAME2=VALUE2\n    NAME3=VALUE3\n    =\n\nBoth name and value are URL escaped.  Multi-valued CGI parameters are\nrepresented as repeated names.  A session record is delimited by a\nsingle = symbol.  You can write out multiple records and read them\nback in with several calls to B<new()>.\n\n    open FH, \"test.in\" or die $!;\n    $q1 = new CGI::Simple(\\*FH);  # get the first record\n    $q2 = new CGI::Simple(\\*FH);  # get the next record\n\nNote: If you wish to use this method from the function-oriented (non-OO)\ninterface, the exported name for this method is B<save_parameters()>.\nAlso if you want to initialize from a file handle, the way to do this is\nwith B<restore_parameters()>.  This will (re)initialize\nthe default CGI::Simple object from the indicated file handle.\n\n    restore_parameters(\\*FH);\n\n=cut\n\n################ Uploading Files ###################\n\n=head1 FILE UPLOADS\n\nFile uploads are easy with CGI::Simple. You use the B<upload()> method.\nAssuming you have the following in your HTML:\n\n    <FORM\n     METHOD=\"POST\"\n     ACTION=\"http://somewhere.com/cgi-bin/script.cgi\"\n     ENCTYPE=\"multipart/form-data\">\n        <INPUT TYPE=\"file\" NAME=\"upload_file1\" SIZE=\"42\">\n        <INPUT TYPE=\"file\" NAME=\"upload_file2\" SIZE=\"42\">\n    </FORM>\n\nNote that the ENCTYPE is \"multipart/form-data\". You must specify this or the\nbrowser will default to \"application/x-www-form-urlencoded\" which will result\nin no files being uploaded although on the surface things will appear OK.\n\nWhen the user submits this form any supplied files will be spooled onto disk\nand saved in temporary files. These files will be deleted when your script.cgi\nexits so if you want to keep them you will need to proceed as follows.\n\n=head2 upload() The key file upload method\n\nThe B<upload()> method is quite versatile. If you call B<upload()> without\nany arguments it will return a list of uploaded files in list context and\nthe number of uploaded files in scalar context.\n\n    $number_of_files = $q->upload;\n    @list_of_files   = $q->upload;\n\nHaving established that you have uploaded files available you can get the\nbrowser supplied filename using B<param()> like this:\n\n    $filename1 = $q->param('upload_file1');\n\nYou can then get a filehandle to read from by calling B<upload()> and\nsupplying this filename as an argument. Warning: do not modify the\nvalue you get from B<param()> in any way - you don't need to untaint it.\n\n    $fh = $q->upload( $filename1 );\n\nNow to save the file you would just do something like:\n\n    $save_path = '/path/to/write/file.name';\n    open FH, \">$save_path\" or die \"Oops $!\\n\";\n    binmode FH;\n    print FH $buffer while read( $fh, $buffer, 4096 );\n    close FH;\n\nBy utilizing a new feature of the upload method this process can be\nsimplified to:\n\n    $ok = $q->upload( $q->param('upload_file1'), '/path/to/write/file.name' );\n    if ($ok) {\n        print \"Uploaded and wrote file OK!\";\n    } else {\n        print $q->cgi_error();\n    }\n\nAs you can see upload will accept an optional second argument and will write\nthe file to this file path. It will return 1 for success and undef if it\nfails. If it fails you can get the error from B<cgi_error>\n\nYou can also use just the fieldname as an argument to upload ie:\n\n    $fh = $q->upload( 'upload_field_name' );\n\n    or\n\n    $ok = $q->upload( 'upload_field_name', '/path/to/write/file.name' );\n\nBUT there is a catch. If you have multiple upload fields, all called\n'upload_field_name' then you will only get the last uploaded file from\nthese fields.\n\n=head2 upload_info() Get the details about uploaded files\n\nThe B<upload_info()> method is a new method. Called without arguments it\nreturns the number of uploaded files in scalar context and the names of\nthose files in list context.\n\n    $number_of_upload_files   = $q->upload_info();\n    @filenames_of_all_uploads = $q->upload_info();\n\nYou can get the MIME type of an uploaded file like this:\n\n    $mime = $q->upload_info( $filename1, 'mime' );\n\nIf you want to know how big a file is before you copy it you can get that\ninformation from B<uploadInfo> which will return the file size in bytes.\n\n    $file_size = $q->upload_info( $filename1, 'size' );\n\nThe size attribute is optional as this is the default value returned.\n\nNote: The old CGI.pm B<uploadInfo()> method has been deleted.\n\n=head2 $POST_MAX and $DISABLE_UPLOADS\n\nCGI.pm has a default setting that allows infinite size file uploads by\ndefault. In contrast file uploads are disabled by default in CGI::Simple\nto discourage Denial of Service attacks. You must enable them before you\nexpect file uploads to work.\n\nWhen file uploads are disabled the file name and file size details will\nstill be available from B<param()> and B<upload_info> respectively but\nthe upload filehandle returned by B<upload()> will be undefined - not\nsurprising as the underlying temp file will not exist either.\n\nYou can enable uploads using the '-upload' pragma. You do this by specifying\nthis in you use statement:\n\n    use CGI::Simple qw(-upload);\n\nAlternatively you can enable uploads via the $DISABLE_UPLOADS global like this:\n\n    use CGI::Simple;\n    $CGI::Simple::DISABLE_UPLOADS = 0;\n    $q = new CGI::Simple;\n\nIf you wish to set $DISABLE_UPLOADS you must do this *after* the\nuse statement and *before* the new constructor call as shown above.\n\nThe maximum acceptable data via post is capped at 102_400kB rather than\ninfinity which is the CGI.pm default. This should be ample for most tasks\nbut you can set this to whatever you want using the $POST_MAX global.\n\n    use CGI::Simple;\n    $CGI::Simple::DISABLE_UPLOADS = 0;      # enable uploads\n    $CGI::Simple::POST_MAX = 1_048_576;     # allow 1MB uploads\n    $q = new CGI::Simple;\n\nIf you set to -1 infinite size uploads will be permitted, which is the CGI.pm\ndefault.\n\n    $CGI::Simple::POST_MAX = -1;            # infinite size upload\n\nAlternatively you can specify all the CGI.pm default values which allow file\nuploads of infinite size in one easy step by specifying the '-default' pragma\nin your use statement.\n\n    use CGI::Simple qw( -default ..... );\n\n=head2 binmode() and Win32\n\nIf you are using CGI::Simple be sure to call B<binmode()> on any handle that\nyou create to write the uploaded file to disk. Calling B<binmode()> will do\nno harm on other systems anyway.\n\n=cut\n\n################ Miscellaneous Methods ################\n\n=head1 MISCELANEOUS METHODS\n\n=head2 escapeHTML() Escaping HTML special characters\n\nIn HTML the < > \" and & chars have special meaning and need to be\nescaped to &lt; &gt; &quot; and &amp; respectively.\n\n    $escaped = $q->escapeHTML( $string );\n\n    $escaped = $q->escapeHTML( $string, 'new_lines_too' );\n\nIf the optional second argument is supplied then newlines will be escaped to.\n\n=head2 unescapeHTML() Unescape HTML special characters\n\nThis performs the reverse of B<escapeHTML()>.\n\n    $unescaped = $q->unescapeHTML( $HTML_escaped_string );\n\n=head2 url_decode() Decode a URL encoded string\n\nThis method will correctly decode a url encoded string.\n\n    $decoded = $q->url_decode( $encoded );\n\n=head2 url_encode() URL encode a string\n\nThis method will correctly URL encode a string.\n\n    $encoded = $q->url_encode( $string );\n\n=head2 parse_keywordlist() Parse a supplied keyword list\n\n    @keywords = $q->parse_keywordlist( $keyword_list );\n\nThis method returns a list of keywords, correctly URL escaped and split out\nof the supplied string\n\n=head2 put() Send output to browser\n\nCGI.pm alias for print. $q->put('Hello World!') will print the usual\n\n=head2 print() Send output to browser\n\nCGI.pm alias for print. $q->print('Hello World!') will print the usual\n\n=cut\n\n################# Cookie Methods ################\n\n=head1 HTTP COOKIES\n\nCGI.pm has several methods that support cookies.\n\nA cookie is a name=value pair much like the named parameters in a CGI\nquery string.  CGI scripts create one or more cookies and send\nthem to the browser in the HTTP header.  The browser maintains a list\nof cookies that belong to a particular Web server, and returns them\nto the CGI script during subsequent interactions.\n\nIn addition to the required name=value pair, each cookie has several\noptional attributes:\n\n=over 4\n\n=item 1. an expiration time\n\nThis is a time/date string (in a special GMT format) that indicates\nwhen a cookie expires.  The cookie will be saved and returned to your\nscript until this expiration date is reached if the user exits\nthe browser and restarts it.  If an expiration date isn't specified, the cookie\nwill remain active until the user quits the browser.\n\n=item 2. a domain\n\nThis is a partial or complete domain name for which the cookie is\nvalid.  The browser will return the cookie to any host that matches\nthe partial domain name.  For example, if you specify a domain name\nof \".capricorn.com\", then the browser will return the cookie to\nWeb servers running on any of the machines \"www.capricorn.com\",\n\"www2.capricorn.com\", \"feckless.capricorn.com\", etc.  Domain names\nmust contain at least two periods to prevent attempts to match\non top level domains like \".edu\".  If no domain is specified, then\nthe browser will only return the cookie to servers on the host the\ncookie originated from.\n\n=item 3. a path\n\nIf you provide a cookie path attribute, the browser will check it\nagainst your script's URL before returning the cookie.  For example,\nif you specify the path \"/cgi-bin\", then the cookie will be returned\nto each of the scripts \"/cgi-bin/tally.pl\", \"/cgi-bin/order.pl\",\nand \"/cgi-bin/customer_service/complain.pl\", but not to the script\n\"/cgi-private/site_admin.pl\".  By default, path is set to \"/\", which\ncauses the cookie to be sent to any CGI script on your site.\n\n=item 4. a \"secure\" flag\n\nIf the \"secure\" attribute is set, the cookie will only be sent to your\nscript if the CGI request is occurring on a secure channel, such as SSL.\n\n=back\n\n=head2 cookie() A simple access method to cookies\n\nThe interface to HTTP cookies is the B<cookie()> method:\n\n    $cookie = $q->cookie( -name      => 'sessionID',\n                          -value     => 'xyzzy',\n                          -expires   => '+1h',\n                          -path      => '/cgi-bin/database',\n                          -domain    => '.capricorn.org',\n                          -secure    => 1\n                         );\n    print $q->header(-cookie=>$cookie);\n\nB<cookie()> creates a new cookie.  Its parameters include:\n\n=over 4\n\n=item B<-name>\n\nThe name of the cookie (required).  This can be any string at all.\nAlthough browsers limit their cookie names to non-whitespace\nalphanumeric characters, CGI.pm removes this restriction by escaping\nand unescaping cookies behind the scenes.\n\n=item B<-value>\n\nThe value of the cookie.  This can be any scalar value,\narray reference, or even associative array reference.  For example,\nyou can store an entire associative array into a cookie this way:\n\n    $cookie=$q->cookie( -name   => 'family information',\n                        -value  => \\%childrens_ages );\n\n=item B<-path>\n\nThe optional partial path for which this cookie will be valid, as described\nabove.\n\n=item B<-domain>\n\nThe optional partial domain for which this cookie will be valid, as described\nabove.\n\n=item B<-expires>\n\nThe optional expiration date for this cookie.  The format is as described\nin the section on the B<header()> method:\n\n    \"+1h\"  one hour from now\n\n=item B<-secure>\n\nIf set to true, this cookie will only be used within a secure\nSSL session.\n\n=back\n\nThe cookie created by B<cookie()> must be incorporated into the HTTP\nheader within the string returned by the B<header()> method:\n\n    print $q->header(-cookie=>$my_cookie);\n\nTo create multiple cookies, give B<header()> an array reference:\n\n    $cookie1 = $q->cookie( -name  => 'riddle_name',\n                           -value => \"The Sphynx's Question\"\n                         );\n    $cookie2 = $q->cookie( -name  => 'answers',\n                           -value => \\%answers\n                         );\n    print $q->header( -cookie => [ $cookie1, $cookie2 ] );\n\nTo retrieve a cookie, request it by name by calling B<cookie()> method\nwithout the B<-value> parameter:\n\n    use CGI::Simple;\n    $q = new CGI::Simple;\n    $riddle  = $q->cookie('riddle_name');\n    %answers = $q->cookie('answers');\n\nCookies created with a single scalar value, such as the \"riddle_name\"\ncookie, will be returned in that form.  Cookies with array and hash\nvalues can also be retrieved.\n\nThe cookie and CGI::Simple  namespaces are separate.  If you have a parameter\nnamed 'answers' and a cookie named 'answers', the values retrieved by\nB<param()> and B<cookie()> are independent of each other.  However, it's\nsimple to turn a CGI parameter into a cookie, and vice-versa:\n\n    # turn a CGI parameter into a cookie\n    $c = $q->cookie( -name=>'answers', -value=>[$q->param('answers')] );\n    # vice-versa\n    $q->param( -name=>'answers', -value=>[$q->cookie('answers')] );\n\n=head2 raw_cookie()\n\nReturns the HTTP_COOKIE variable. Cookies have a special format, and\nthis method call just returns the raw form (?cookie dough). See\nB<cookie()> for ways of setting and retrieving cooked cookies.\n\nCalled with no parameters, B<raw_cookie()> returns the packed cookie\nstructure.  You can separate it into individual cookies by splitting\non the character sequence \"; \".  Called with the name of a cookie,\nretrieves the B<unescaped> form of the cookie.  You can use the\nregular B<cookie()> method to get the names, or use the raw_fetch()\nmethod from the CGI::Simmple::Cookie module.\n\n=cut\n\n################# Header Methods ################\n\n=head1 CREATING HTTP HEADERS\n\nNormally the first thing you will do in any CGI script is print out an\nHTTP header.  This tells the browser what type of document to expect,\nand gives other optional information, such as the language, expiration\ndate, and whether to cache the document.  The header can also be\nmanipulated for special purposes, such as server push and pay per view\npages.\n\n=head2 header() Create simple or complex HTTP headers\n\n    print $q->header;\n\n         -or-\n\n    print $q->header('image/gif');\n\n         -or-\n\n    print $q->header('text/html','204 No response');\n\n         -or-\n\n    print $q->header( -type       => 'image/gif',\n                      -nph        => 1,\n                      -status     => '402 Payment required',\n                      -expires    => '+3d',\n                      -cookie     => $cookie,\n                      -charset    => 'utf-7',\n                      -attachment => 'foo.gif',\n                      -Cost       => '$2.00'\n                    );\n\nB<header()> returns the Content-type: header.  You can provide your own\nMIME type if you choose, otherwise it defaults to text/html.  An\noptional second parameter specifies the status code and a human-readable\nmessage.  For example, you can specify 204, \"No response\" to create a\nscript that tells the browser to do nothing at all.\n\nThe last example shows the named argument style for passing arguments\nto the CGI methods using named parameters.  Recognized parameters are\nB<-type>, B<-status>, B<-cookie>, B<-target>, B<-expires>, B<-nph>,\nB<-charset> and B<-attachment>.  Any other named parameters will be\nstripped of their initial hyphens and turned into header fields, allowing\nyou to specify any HTTP header you desire.\n\nFor example, you can produce non-standard HTTP header fields by providing\nthem as named arguments:\n\n  print $q->header( -type            => 'text/html',\n                    -nph             => 1,\n                    -cost            => 'Three smackers',\n                    -annoyance_level => 'high',\n                    -complaints_to   => 'bit bucket'\n                  );\n\nThis will produce the following non-standard HTTP header:\n\n    HTTP/1.0 200 OK\n    Cost: Three smackers\n    Annoyance-level: high\n    Complaints-to: bit bucket\n    Content-type: text/html\n\nNote that underscores are translated automatically into hyphens. This feature\nallows you to keep up with the rapidly changing HTTP \"standards\".\n\nThe B<-type> is a key element that tell the browser how to display your\ndocument. The default is 'text/html'. Common types are:\n\n    text/html\n    text/plain\n    image/gif\n    image/jpg\n    image/png\n    application/octet-stream\n\nThe B<-status> code is the HTTP response code. The default is 200 OK. Common\nstatus codes are:\n\n    200 OK\n    204 No Response\n    301 Moved Permanently\n    302 Found\n    303 See Other\n    307 Temporary Redirect\n    400 Bad Request\n    401 Unauthorized\n    403 Forbidden\n    404 Not Found\n    405 Not Allowed\n    408 Request Timed Out\n    500 Internal Server Error\n    503 Service Unavailable\n    504 Gateway Timed Out\n\nThe B<-expires> parameter lets you indicate to a browser and proxy server\nhow long to cache pages for. When you specify an absolute or relative\nexpiration interval with this parameter, some browsers and proxy servers\nwill cache the script's output until the indicated expiration date.\nThe following forms are all valid for the -expires field:\n\n    +30s                                30 seconds from now\n    +10m                                ten minutes from now\n    +1h                                 one hour from now\n    -1d                                 yesterday (i.e. \"ASAP!\")\n    now                                 immediately\n    +3M                                 in three months\n    +10y                                in ten years time\n    Thursday, 25-Apr-1999 00:40:33 GMT  at the indicated time & date\n\nThe B<-cookie> parameter generates a header that tells the browser to provide\na \"magic cookie\" during all subsequent transactions with your script.\nNetscape cookies have a special format that includes interesting attributes\nsuch as expiration time.  Use the B<cookie()> method to create and retrieve\nsession cookies.\n\nThe B<-target> is for frames use\n\nThe B<-nph> parameter, if set to a true value, will issue the correct\nheaders to work with a NPH (no-parse-header) script.  This is important\nto use with certain servers that expect all their scripts to be NPH.\n\nThe B<-charset> parameter can be used to control the character set\nsent to the browser.  If not provided, defaults to ISO-8859-1.  As a\nside effect, this sets the charset() method as well.\n\nThe B<-attachment> parameter can be used to turn the page into an\nattachment.  Instead of displaying the page, some browsers will prompt\nthe user to save it to disk.  The value of the argument is the\nsuggested name for the saved file.  In order for this to work, you may\nhave to set the B<-type> to 'application/octet-stream'.\n\n=head2 no_cache() Preventing browser caching of scripts\n\nMost browsers will not cache the output from CGI scripts. Every time\nthe browser reloads the page, the script is invoked anew. However some\nbrowsers do cache pages. You can discourage this behavior using the\nB<no_cache()> function.\n\n    $q->no_cache(1); # turn caching off by sending appropriate headers\n    $q->no_cache(1); # do not send cache related headers.\n\n    $q->no_cache(1);\n    print header (-type=>'image/gif', -nph=>1);\n\n    This will produce a header like the following:\n\n    HTTP/1.0 200 OK\n    Server: Apache - accept no substitutes\n    Expires: Thu, 15 Nov 2001 03:37:50 GMT\n    Date: Thu, 15 Nov 2001 03:37:50 GMT\n    Pragma: no-cache\n    Content-Type: image/gif\n\nBoth the Pragma: no-cache header field and an Expires header that corresponds\nto the current time (ie now) will be sent.\n\n=head2 cache() Preventing browser caching of scripts\n\nThe somewhat ill named B<cache()> method is a legacy from CGI.pm. It operates\nthe same as the new B<no_cache()> method. The difference is/was that when set\nit results only in the Pragma: no-cache line being printed.\nExpires time data is not sent.\n\n=head2 redirect() Generating a redirection header\n\n    print $q->redirect('http://somewhere.else/in/movie/land');\n\nSometimes you don't want to produce a document yourself, but simply\nredirect the browser elsewhere, perhaps choosing a URL based on the\ntime of day or the identity of the user.\n\nThe B<redirect()> function redirects the browser to a different URL.  If\nyou use redirection like this, you should B<not> print out a header as\nwell.\n\nOne hint I can offer is that relative links may not work correctly\nwhen you generate a redirection to another document on your site.\nThis is due to a well-intentioned optimization that some servers use.\nThe solution to this is to use the full URL (including the http: part)\nof the document you are redirecting to.\n\nYou can also use named arguments:\n\n    print $q->redirect( -uri=>'http://somewhere.else/in/movie/land',\n                        -nph=>1\n                      );\n\nThe B<-nph> parameter, if set to a true value, will issue the correct\nheaders to work with a NPH (no-parse-header) script.  This is important\nto use with certain servers, such as Microsoft ones, which\nexpect all their scripts to be NPH.\n\n=cut\n\n=head1 PRAGMAS\n\nThere are a number of pragmas that you can specify in your use CGI::Simple\nstatement. Pragmas, which are always preceded by a hyphen, change the way\nthat CGI::Simple functions in various ways. You can generally achieve\nexactly the same results by setting the underlying $GLOBAL_VARIABLES.\n\nFor example the '-upload' pargma will enable file uploads:\n\n    use CGI::Simple qw(-upload);\n\nIn CGI::Simple::Standard Pragmas, function sets , and individual functions\ncan all be imported in the same use() line.  For example, the following\nuse statement imports the standard set of functions and enables debugging\nmode (pragma -debug):\n\n    use CGI::Simple::Standard qw(:standard -debug);\n\nThe current list of pragmas is as follows:\n\n=over 4\n\n=item -no_undef_params\n\nIf a value is not given in the query string, as in the queries\n\"name1=&name2=\" or \"name1&name2\", by default it will be returned\nas an empty string.\n\nIf you specify the '-no_undef_params' pragma then CGI::Simple ignores\nparameters with no values and they will not appear in the query object.\n\n=item -nph\n\nThis makes CGI.pm produce a header appropriate for an NPH (no\nparsed header) script.  You may need to do other things as well\nto tell the server that the script is NPH.  See the discussion\nof NPH scripts below.\n\n=item -newstyle_urls\n\nSeparate the name=value pairs in CGI parameter query strings with\nsemicolons rather than ampersands.  For example:\n\n    ?name=fred;age=24;favorite_color=3\n\nSemicolon-delimited query strings are always accepted, but will not be\nemitted by self_url() and query_string() unless the -newstyle_urls\npragma is specified.\n\n=item -oldstyle_urls\n\nSeparate the name=value pairs in CGI parameter query strings with\nampersands rather than semicolons.  This is the default.\n\n    ?name=fred&age=24&favorite_color=3\n\n=item -autoload\n\nThis is only available for CGI::Simple::Standard and uses AUTOLOAD to\nload functions on demand. See the CGI::Simple::Standard docs for details.\n\n=item -no_debug\n\nThis turns off the command-line processing features. This is the default.\n\n=item -debug1 and debug2\n\nThis turns on debugging.  At debug level 1 CGI::Simple will read arguments\nfrom the command-line. At debug level 2 CGI.pm will produce the prompt\n\"(offline mode: enter name=value pairs on standard input)\" and wait for\ninput on STDIN. If no number is specified then a debug level of 2 is used.\n\nSee the section on debugging for more details.\n\n=item -default\n\nThis sets the default global values for CGI.pm which will enable infinite\nsize file uploads, and specify the '-newstyle_urls' and '-debug1' pragmas\n\n=item -no_upload\n\nDisable uploads - the default setting\n\n=item - upload\n\nEnable uploads - the CGI.pm default\n\n=item -unique_header\n\nOnly allows headers to be generated once per script invocation\n\n=item -carp\n\nCarp when B<cgi_error()> called, default is to do nothing\n\n=item -croak\n\nCroak when B<cgi_error()> called, default is to do nothing\n\n=back\n\n=cut\n\n############### NPH Scripts ################\n\n=head1 USING NPH SCRIPTS\n\nNPH, or \"no-parsed-header\", scripts bypass the server completely by\nsending the complete HTTP header directly to the browser.  This has\nslight performance benefits, but is of most use for taking advantage\nof HTTP extensions that are not directly supported by your server,\nsuch as server push and PICS headers.\n\nServers use a variety of conventions for designating CGI scripts as\nNPH.  Many Unix servers look at the beginning of the script's name for\nthe prefix \"nph-\".  The Macintosh WebSTAR server and Microsoft's\nInternet Information Server, in contrast, try to decide whether a\nprogram is an NPH script by examining the first line of script output.\n\nCGI.pm supports NPH scripts with a special NPH mode.  When in this\nmode, CGI.pm will output the necessary extra header information when\nthe B<header()> and B<redirect()> methods are called. You can set NPH mode\nin any of the following ways:\n\n=over 4\n\n=item In the B<use> statement\n\nSimply add the \"-nph\" pragma to the use:\n\n    use CGI::Simple qw(-nph)\n\n=item By calling the B<nph()> method:\n\nCall B<nph()> with a non-zero parameter at any point after using CGI.pm in your program.\n\n    $q->nph(1)\n\n=item By using B<-nph> parameters\n\nin the B<header()> and B<redirect()>  statements:\n\n    print $q->header(-nph=>1);\n\n=back\n\nThe Microsoft Internet Information Server requires NPH mode.\nCGI::Simple will automatically detect when the script is\nrunning under IIS and put itself into this mode.  You do not need to\ndo this manually, although it won't hurt anything if you do.  However,\nnote that if you have applied Service Pack 6, much of the\nfunctionality of NPH scripts, including the ability to redirect while\nsetting a cookie, b<do not work at all> on IIS without a special patch\nfrom Microsoft.  See\nhttp://support.microsoft.com/support/kb/articles/Q280/3/41.ASP:\nNon-Parsed Headers Stripped From CGI Applications That Have nph-\nPrefix in Name.\n\n=cut\n\n################# Server Push Methods #################\n\n=head1 SERVER PUSH\n\nCGI.pm provides four simple functions for producing multipart\ndocuments of the type needed to implement server push.  These\nfunctions were graciously provided by Ed Jordan <ed@fidalgo.net> with\nadditions from Andrew Benham <adsb@bigfoot.com>\n\nYou are also advised to put the script into NPH mode and to set $| to\n1 to avoid buffering problems.\n\nBrowser support for server push is variable.\n\nHere is a simple script that demonstrates server push:\n\n    #!/usr/local/bin/perl\n    use CGI::Simple::Standard qw/:push -nph/;\n    $| = 1;\n    print multipart_init(-boundary=>'----here we go!');\n    foreach (0 .. 4) {\n        print multipart_start(-type=>'text/plain'),\n        \"The current time is \",scalar(localtime),\"\\n\";\n        if ($_ < 4) {\n            print multipart_end;\n        }\n        else {\n            print multipart_final;\n        }\n        sleep 1;\n    }\n\nThis script initializes server push by calling B<multipart_init()>.\nIt then enters a loop in which it begins a new multipart section by\ncalling B<multipart_start()>, prints the current local time,\nand ends a multipart section with B<multipart_end()>.  It then sleeps\na second, and begins again. On the final iteration, it ends the\nmultipart section with B<multipart_final()> rather than with\nB<multipart_end()>.\n\n=head2 multipart_init() Initialize the multipart system\n\n    multipart_init(-boundary=>$boundary);\n\nInitialize the multipart system.  The -boundary argument specifies\nwhat MIME boundary string to use to separate parts of the document.\nIf not provided, CGI.pm chooses a reasonable boundary for you.\n\n=head2 multipart_start() Start a new part of the multipart document\n\n    multipart_start(-type=>$type)\n\nStart a new part of the multipart document using the specified MIME\ntype.  If not specified, text/html is assumed.\n\n=head2 multipart_end() End a multipart part\n\n    multipart_end()\n\nEnd a part.  You must remember to call B<multipart_end()> once for each\nB<multipart_start()>, except at the end of the last part of the multipart\ndocument when B<multipart_final()> should be called instead of\nB<multipart_end()>.\n\n=head2 multipart_final()\n\n    multipart_final()\n\nEnd all parts.  You should call B<multipart_final()> rather than\nB<multipart_end()> at the end of the last part of the multipart document.\n\n=head2 CGI::Push\n\nUsers interested in server push applications should also have a look\nat the B<CGI::Push> module.\n\n=cut\n\n################# Debugging Methods ################\n\n=head1 DEBUGGING\n\nIf you are running the script from the command line or in the perl\ndebugger, you can pass the script a list of keywords or\nparameter=value pairs on the command line or from standard input (you\ndon't have to worry about tricking your script into reading from\nenvironment variables).  Before you do this you will need to change the\ndebug level from the default level of 0 (no debug) to either 1 if you\nwant to debug from @ARGV (the command line) of 2 if you want to debug from\nSTDIN. You can do this using the debug pragma like this:\n\n    use CGI::Simple qw(-debug2);  # set debug to level 2 => from STDIN\n\n        or this:\n\n    $CGI::Simple::DEBUG = 1;      # set debug to level 1 => from @ARGV\n\nAt debug level 1 you can pass keywords and name=value pairs like this:\n\n    your_script.pl keyword1 keyword2 keyword3\n\n        or this:\n\n    your_script.pl keyword1+keyword2+keyword3\n\n        or this:\n\n    your_script.pl name1=value1 name2=value2\n\n        or this:\n\n    your_script.pl name1=value1&name2=value2\n\nAt debug level 2 you can feed newline-delimited name=value\npairs to the script on standard input. You will be presented\nwith the following prompt:\n\n    (offline mode: enter name=value pairs on standard input)\n\nYou end the input with your system dependent end of file character.\nYou should try ^Z ^X ^D and ^C if all else fails. The ^ means hold down\nthe [Ctrl] button while you press the other key.\n\nWhen debugging, you can use quotes and backslashes to escape\ncharacters in the familiar shell manner, letting you place\nspaces and other funny characters in your parameter=value\npairs:\n\n    your_script.pl \"name1='I am a long value'\" \"name2=two\\ words\"\n\n=head2 Dump() Dumping the current object details\n\nThe B<Dump()> method produces a string consisting of all the\nquery's object attributes formatted nicely as a nested list.  This dump\nincludes the name/value pairs and a number of other details. This is useful\nfor debugging purposes:\n\n    print $q->Dump\n\nThe actual result of this is HTML escaped formatted text wrapped in <pre> tags\nso if you send it straight to the browser it produces something that looks\nlike:\n\n    $VAR1 = bless( {\n         '.parameters' => [\n                            'name',\n                            'color'\n                          ],\n         '.globals' => {\n                         'FATAL' => -1,\n                         'DEBUG' => 0,\n                         'NO_NULL' => 1,\n                         'POST_MAX' => 102400,\n                         'USE_CGI_PM_DEFAULTS' => 0,\n                         'HEADERS_ONCE' => 0,\n                         'NPH' => 0,\n                         'DISABLE_UPLOADS' => 1,\n                         'NO_UNDEF_PARAMS' => 0,\n                         'USE_PARAM_SEMICOLONS' => 0\n                       },\n         '.fieldnames' => {\n                            'color' => '1',\n                            'name' => '1'\n                          },\n         '.mod_perl' => '',\n         'color' => [\n                      'red',\n                      'green',\n                      'blue'\n                    ],\n         'name' => [\n                     'JaPh,'\n                   ]\n        }, 'CGI::Simple' );\n\nYou may recognize this as valid Perl syntax (which it is) and/or the output\nfrom Data::Dumper (also true). This is the actual guts of how the information\nis stored in the query object. All the internal params start with a . char\n\nAlternatively you can dump your object and the current environment using:\n\n    print $q->Dump(\\%ENV);\n\n=head2 PrintEnv() Dumping the environment\n\nYou can get a similar browser friendly dump of the current %ENV hash using:\n\n    print $q->PrintEnv;\n\nThis will produce something like (in the browser):\n\n    $VAR1 = {\n          'QUERY_STRING' => 'name=JaPh%2C&color=red&color=green&color=blue',\n          'CONTENT_TYPE' => 'application/x-www-form-urlencoded',\n          'REGRESSION_TEST' => 'simple.t.pl',\n          'VIM' => 'C:\\\\WINDOWS\\\\Desktop\\\\vim',\n          'HTTP_REFERER' => 'xxx.sex.com',\n          'HTTP_USER_AGENT' => 'LWP',\n          'HTTP_ACCEPT' => 'text/html;q=1, image/gif;q=0.42, */*;q=0.001',\n          'REMOTE_HOST' => 'localhost',\n          'HTTP_HOST' => 'the.restaurant.at.the.end.of.the.universe',\n          'GATEWAY_INTERFACE' => 'bleeding edge',\n          'REMOTE_IDENT' => 'None of your damn business',\n          'SCRIPT_NAME' => '/cgi-bin/foo.cgi',\n          'SERVER_NAME' => 'nowhere.com',\n          'HTTP_COOKIE' => '',\n          'CONTENT_LENGTH' => '42',\n          'HTTPS_A' => 'A',\n          'HTTP_FROM' => 'spammer@nowhere.com',\n          'HTTPS_B' => 'B',\n          'SERVER_PROTOCOL' => 'HTTP/1.0',\n          'PATH_TRANSLATED' => '/usr/local/somewhere/else',\n          'SERVER_SOFTWARE' => 'Apache - accept no substitutes',\n          'PATH_INFO' => '/somewhere/else',\n          'REMOTE_USER' => 'Just another Perl hacker,',\n          'REMOTE_ADDR' => '127.0.0.1',\n          'HTTPS' => 'ON',\n          'DOCUMENT_ROOT' => '/vs/www/foo',\n          'REQUEST_METHOD' => 'GET',\n          'REDIRECT_QUERY_STRING' => '',\n          'AUTH_TYPE' => 'PGP MD5 DES rot13',\n          'COOKIE' => 'foo=a%20phrase; bar=yes%2C%20a%20phrase&;I%20say;',\n          'SERVER_PORT' => '8080'\n        };\n\n\n=head2 cgi_error() Retrieving CGI::Simple error messages\n\nErrors can occur while processing user input, particularly when\nprocessing uploaded files.  When these errors occur, CGI::Simple will stop\nprocessing and return an empty parameter list.  You can test for\nthe existence and nature of errors using the B<cgi_error()> function.\nThe error messages are formatted as HTTP status codes. You can either\nincorporate the error text into an HTML page, or use it as the value\nof the HTTP status:\n\n    my $error = $q->cgi_error;\n    if ($error) {\n        print $q->header(-status=>$error);\n        print \"<H2>$error</H2>;\n      exit;\n    }\n\n=cut\n\n############### Accessor Methods ################\n\n=head1 ACCESSOR METHODS\n\n=head2 version() Get the CGI::Simple version info\n\n    $version = $q->version();\n\nThe B<version()> method returns the value of $VERSION\n\n=head2 nph() Enable/disable NPH (Non Parsed Header) mode\n\n    $q->nph(1);  # enable NPH mode\n    $q->nph(0);  # disable NPH mode\n\nThe B<nph()> method enables and disables NPH headers. See the NPH section.\n\n=head2 all_parameters() Get the names/values of all parameters\n\n    @all_parameters = $q->all_parameters();\n\nThe B<all_parameters()> method is an alias for B<param()>\n\n=head2 charset() Get/set the current character set.\n\n    $charset = $q->charset(); # get current charset\n    $q->charset('utf-42');    # set the charset\n\nThe B<charset()> method gets the current charset value if no argument is\nsupplied or sets it if an argument is supplied.\n\n=head2 crlf() Get the system specific line ending sequence\n\n    $crlf = $q->crlf();\n\nThe B<crlf()> method returns the system specific line ending sequence.\n\n=head2 globals() Get/set the value of the remaining global variables\n\n    $globals = $q->globals('FATAL');     # get the current value of $FATAL\n    $globals = $q->globals('FATAL', 1 ); # set croak mode on cgi_error()\n\nThe B<globals()> method gets/sets the values of the global variables after the\nscript has been invoked. For globals like $POST_MAX and $DISABLE_UPLOADS this\nmakes no difference as they must be set prior to calling the new constructor\nbut there might be reason the change the value of others.\n\n=head2 auth_type() Get the current authorization/verification method\n\n    $auth_type = $q->auth_type();\n\nThe B<auth_type()> method returns the value of $ENV{'AUTH_TYPE'} which should\ncontain the authorization/verification method in use for this script, if any.\n\n=head2 content_length() Get the content length submitted in a POST\n\n    $content_length = $q->content_length();\n\nThe B<content_length()> method returns the value of $ENV{'AUTH_TYPE'}\n\n=head2 content_type() Get the content_type of data submitted in a POST\n\n    $content_type = $q->content_type();\n\nThe B<content_type()> method returns the content_type of data submitted in\na POST, generally 'multipart/form-data' or\n'application/x-www-form-urlencoded' as supplied in $ENV{'CONTENT_TYPE'}\n\n=head2 document_root() Get the document root\n\n    $document_root = $q->document_root();\n\nThe B<document_root()> method returns the value of $ENV{'DOCUMENT_ROOT'}\n\n=head2 gateway_interface() Get the gateway interface\n\n    $gateway_interface = $q->gateway_interface();\n\nThe B<gateway_interface()> method returns the value of\n$ENV{'GATEWAY_INTERFACE'}\n\n=head2 path_translated() Get the value of path translated\n\n    $path_translated = $q->path_translated();\n\nThe B<path_translated()> method returns the value of $ENV{'PATH_TRANSLATED'}\n\n=head2 referer() Spy on your users\n\n    $referer = $q->referer();\n\nThe B<referer()> method returns the value of $ENV{'REFERER'} This will return\nthe URL of the page the browser was viewing prior to fetching your script.\nNot available for all browsers.\n\n=head2 remote_addr() Get the remote address\n\n    $remote_addr = $q->remote_addr();\n\nThe B<remote_addr()> method returns the value of $ENV{'REMOTE_ADDR'} or\n127.0.0.1 (localhost) if this is not defined.\n\n=head2 remote_host() Get a value for remote host\n\n    $remote_host = $q->remote_host();\n\nThe B<remote_host()> method returns the value of $ENV{'REMOTE_HOST'} if it is\ndefined. If this is not defined it returns $ENV{'REMOTE_ADDR'} If this is not\ndefined it returns 'localhost'\n\n=head2 remote_ident() Get the remote identity\n\n    $remote_ident = $q->remote_ident();\n\nThe B<remote_ident()> method returns the value of $ENV{'REMOTE_IDENT'}\n\n=head2 remote_user() Get the remote user\n\n    $remote_user = $q->remote_user();\n\nThe B<remote_user()> method returns the authorization/verification name used\nfor user verification, if this script is protected. The value comes from\n$ENV{'REMOTE_USER'}\n\n=head2 request_method() Get the request method\n\n    $request_method = $q->request_method();\n\nThe B<request_method()> method returns the method used to access your\nscript, usually one of 'POST', 'GET' or 'HEAD' as supplied by\n$ENV{'REQUEST_METHOD'}\n\n=head2 script_name() Get the script name\n\n    $script_name = $q->script_name();\n\nThe B<script_name()> method returns the value of $ENV{'SCRIPT_NAME'} if it is\ndefined. Otherwise it returns Perl's script name from $0. Failing this it\nreturns a null string ''\n\n=head2 server_name() Get the server name\n\n    $server_name = $q->server_name();\n\nThe B<server_name()> method returns the value of $ENV{'SERVER_NAME'} if defined\nor 'localhost' otherwise\n\n=head2 server_port() Get the port the server is listening on\n\n    $server_port = $q->server_port();\n\nThe B<server_port()> method returns the value $ENV{'SERVER_PORT'} if defined or\n80 if not.\n\n=head2 server_protocol() Get the current server protocol\n\n    $server_protocol = $q->server_protocol();\n\nThe B<server_protocol()> method returns the value of $ENV{'SERVER_PROTOCOL'} if\ndefined or 'HTTP/1.0' otherwise\n\n=head2 server_software() Get the server software\n\n    $server_software = $q->server_software();\n\nThe B<server_software()> method returns the value $ENV{'SERVER_SOFTWARE'} or\n'cmdline' If the server software is IIS it formats your hard drive, installs\nLinux, FTPs to www.apache.org, installs Apache, and then restores your system\nfrom tape. Well maybe not, but it's a nice thought.\n\n=head2 user_name() Get a value for the user name.\n\n    $user_name = $q->user_name();\n\nAttempt to obtain the remote user's name, using a variety of different\ntechniques.  This only works with older browsers such as Mosaic.\nNewer browsers do not report the user name for privacy reasons!\n\nTechnically the B<user_name()> method returns the value of $ENV{'HTTP_FROM'}\nor failing that $ENV{'REMOTE_IDENT'} or as a last choice $ENV{'REMOTE_USER'}\n\n=head2 user_agent() Get the users browser type\n\n    $ua = $q->user_agent();          # return the user agent\n    $ok = $q->user_agent('mozilla'); # return true if user agent 'mozilla'\n\nThe B<user_agent()> method returns the value of $ENV{'HTTP_USER_AGENT'}  when\ncalled without an argument or true or false if the $ENV{'HTTP_USER_AGENT'}\nmatches the passed argument. The matching is case insensitive and partial.\n\n=head2 virtual_host() Get the virtual host\n\n    $virtual_host = $q->virtual_host();\n\nThe B<virtual_host()> method returns the value of  $ENV{'HTTP_HOST'} if defined\nor $ENV{'SERVER_NAME'} as a default. Port numbers are removed.\n\n=head2 path_info() Get any extra path info set to the script\n\n    $path_info = $q->path_info();\n\nThe B<path_info()> method returns additional path information from the script\nURL. E.G. fetching /cgi-bin/your_script/additional/stuff will result in\n$q->path_info() returning \"/additional/stuff\".\n\nNOTE: The Microsoft Internet Information Server\nis broken with respect to additional path information.  If\nyou use the Perl DLL library, the IIS server will attempt to\nexecute the additional path information as a Perl script.\nIf you use the ordinary file associations mapping, the\npath information will be present in the environment,\nbut incorrect.  The best thing to do is to avoid using additional\npath information in CGI scripts destined for use with IIS.\n\n=head2 Accept() Get the browser MIME types\n\n    $Accept = $q->Accept();\n\nThe B<Accept()> method returns a list of MIME types that the remote browser\naccepts. If you give this method a single argument corresponding to a\nMIME type, as in $q->Accept('text/html'), it will return a floating point\nvalue corresponding to the browser's preference for this type from 0.0\n(don't want) to 1.0.  Glob types (e.g. text/*) in the browser's accept\nlist are handled correctly.\n\n=head2 accept() Alias for Accept()\n\n    $accept = $q->accept();\n\nThe B<accept()> Method is an alias for Accept()\n\n=head2 http() Get a range of HTTP related information\n\n    $http = $q->http();\n\nCalled with no arguments the B<http()> method returns the list of HTTP or HTTPS\nenvironment variables, including such things as HTTP_USER_AGENT,\nHTTP_ACCEPT_LANGUAGE, and HTTP_ACCEPT_CHARSET, corresponding to the\nlike-named HTTP header fields in the request. Called with the name of\nan HTTP header field, returns its value.  Capitalization and the use\nof hyphens versus underscores are not significant.\n\nFor example, all three of these examples are equivalent:\n\n   $requested_language = $q->http('Accept-language');\n   $requested_language = $q->http('Accept_language');\n   $requested_language = $q->http('HTTP_ACCEPT_LANGUAGE');\n\n=head2 https() Get a range of HTTPS related information\n\n    $https = $q->https();\n\nThe B<https()> method is similar to the http() method except that when called\nwithout an argument it returns the value of $ENV{'HTTPS'} which will be\ntrue if a HTTPS connection is in use and false otherwise.\n\n=head2 protocol() Get the current protocol\n\n    $protocol = $q->protocol();\n\nThe B<protocol()> method returns 'https' if a HTTPS connection is in use or the\nB<server_protocol()> minus version numbers ('http') otherwise.\n\n=head2 url() Return the script's URL in several formats\n\n    $full_url      = $q->url();\n    $full_url      = $q->url(-full=>1);\n    $relative_url  = $q->url(-relative=>1);\n    $absolute_url  = $q->url(-absolute=>1);\n    $url_with_path = $q->url(-path_info=>1);\n    $url_with_path_and_query = $q->url(-path_info=>1,-query=>1);\n    $netloc        = $q->url(-base => 1);\n\nB<url()> returns the script's URL in a variety of formats.  Called\nwithout any arguments, it returns the full form of the URL, including\nhost name and port number\n\n    http://your.host.com/path/to/script.cgi\n\nYou can modify this format with the following named arguments:\n\n=over 4\n\n=item B<-absolute>\n\nIf true, produce an absolute URL, e.g.\n\n    /path/to/script.cgi\n\n=item B<-relative>\n\nProduce a relative URL.  This is useful if you want to reinvoke your\nscript with different parameters. For example:\n\n    script.cgi\n\n=item B<-full>\n\nProduce the full URL, exactly as if called without any arguments.\nThis overrides the -relative and -absolute arguments.\n\n=item B<-path> (B<-path_info>)\n\nAppend the additional path information to the URL.  This can be\ncombined with B<-full>, B<-absolute> or B<-relative>.  B<-path_info>\nis provided as a synonym.\n\n=item B<-query> (B<-query_string>)\n\nAppend the query string to the URL.  This can be combined with\nB<-full>, B<-absolute> or B<-relative>.  B<-query_string> is provided\nas a synonym.\n\n=item B<-base>\n\nGenerate just the protocol and net location, as in http://www.foo.com:8000\n\n=back\n\n=head2 self_url() Get the scripts complete URL\n\n    $self_url = $q->self_url();\n\nThe B<self_url()> method returns the value of:\n\n   $self->url( '-path_info'=>1, '-query'=>1, '-full'=>1 );\n\n=head2 state() Alias for self_url()\n\n    $state = $q->state();\n\nThe B<state()> method is an alias for self_url()\n\n=cut\n\n################# cgi-lib.pl Compatibility Methods #################\n\n=head1 COMPATIBILITY WITH cgi-lib.pl 2.18\n\nTo make it easier to port existing programs that use cgi-lib.pl all\nthe subs within cgi-lib.pl are available in CGI::Simple.  Using the\nfunctional interface of CGI::Simple::Standard porting is\nas easy as:\n\n    OLD VERSION\n        require \"cgi-lib.pl\";\n        &ReadParse;\n        print \"The value of the antique is $in{'antique'}.\\n\";\n\n    NEW VERSION\n        use CGI::Simple::Standard qw(:cgi-lib);\n        &ReadParse;\n        print \"The value of the antique is $in{'antique'}.\\n\";\n\nCGI:Simple's B<ReadParse()> routine creates a variable named %in,\nwhich can be accessed to obtain the query variables.  Like\nReadParse, you can also provide your own variable via a glob. Infrequently\nused features of B<ReadParse()>, such as the creation of @in and $in\nvariables, are not supported.\n\nYou can also use the OO interface of CGI::Simple and call B<ReadParse()> and\nother cgi-lib.pl functions like this:\n\n    &CGI::Simple::ReadParse;       # get hash values in %in\n\n    my $q = new CGI::Simple;\n    $q->ReadParse();                # same thing\n\n    CGI::Simple::ReadParse(*field); # get hash values in %field function style\n\n    my $q = new CGI::Simple;\n    $q->ReadParse(*field);          # same thing\n\nOnce you use B<ReadParse()> under the functional interface , you can retrieve\nthe query object itself this way if needed:\n\n    $q = $in{'CGI'};\n\nEither way it allows you to start using the more interesting features\nof CGI.pm without rewriting your old scripts from scratch.\n\nUnlike CGI.pm all the cgi-lib.pl functions from Version 2.18 are supported:\n\n    ReadParse()\n    SplitParam()\n    MethGet()\n    MethPost()\n    MyBaseUrl()\n    MyURL()\n    MyFullUrl()\n    PrintHeader()\n    HtmlTop()\n    HtmlBot()\n    PrintVariables()\n    PrintEnv()\n    CgiDie()\n    CgiError()\n\n=head1 COMPATIBILITY WITH CGI.pm\n\nI has long been suggested that the CGI and HTML parts of CGI.pm should be\nsplit into separate modules (even the author suggests this!), CGI::Simple\nrepresents the realization of this and contains the complete CGI side of\nCGI.pm. Code-wise it weighs in at a little under 30% of the size of CGI.pm at\na little under 1000 lines.\n\nA great deal of care has been taken to ensure that the interface remains\nunchanged although a few tweaks have been made. The test suite is extensive\nand includes all the CGI.pm test scripts as well as a series of new test\nscripts. You may like to have a look at /t/concur.t which makes 160 tests\nof CGI::Simple and CGI in parallel and compares the results to ensure they\nare identical. This is the case as of CGI.pm 2.78.\n\nYou can't make an omelet without breaking eggs. A large number of methods\nand global variables have been deleted as detailed below. Some pragmas are\nalso gone. In the tarball there is a script B</misc/check.pl> that will check if\na script seems to be using any of these now non existent methods, globals or\npragmas. You call it like this:\n\n    perl check.pl <files>\n\nIf it finds any likely candidates it will print a line with the line number,\nproblem method/global and the complete line. For example here is some output\nfrom running the script on CGI.pm:\n\n    ...\n    3162: Problem:'$CGI::OS'   local($CRLF) = \"\\015\\012\" if $CGI::OS eq 'VMS';\n    3165: Problem:'fillBuffer' $self->fillBuffer($FILLUNIT);\n    ....\n\n=head1 DIFFERENCES FROM CGI.pm\n\nCGI::Simple is strict and warnings compliant.\n\nThere are 4 modules in this distribution:\n\n    CGI/Simple.pm           supplies all the core code.\n    CGI/Simple/Cookie.pm    supplies the cookie handling functions.\n    CGI/Simple/Util.pm      supplies a variety of utility functions\n    CGI/Simple/Standard.pm  supplies a functional interface for Simple.pm\n\nSimple.pm is the core module that provide all the essential functionality.\nCookie.pm is a shortened rehash of the CGI.pm module of the same name\nwhich supplies the required cookie functionality. Util.pm has been recoded to\nuse an internal object for data storage and supplies rarely needed non core\nfunctions and/or functions needed for the HTML side of things. Standard.pm is\na wrapper module that supplies a complete functional interface to the OO\nback end supplied by CGI::Simple.\n\nAlthough a serious attempt has been made to keep the interface identical,\nsome minor changes and tweaks have been made. They will likely be\ninsignificant to most users but here are the gory details.\n\n=head2 Globals Variables\n\nThe list of global variables has been pruned by 75%. Here is the complete\nlist of the global variables used:\n\n    $VERSION = \"0.01\";\n    # set this to 1 to use CGI.pm default global settings\n    $USE_CGI_PM_DEFAULTS = 0 unless defined $USE_CGI_PM_DEFAULTS;\n    # see if user wants old  CGI.pm defaults\n    do{ _use_cgi_pm_global_settings(); return } if $USE_CGI_PM_DEFAULTS;\n    # no file uploads by default, set to 0 to enable uploads\n    $DISABLE_UPLOADS = 1 unless defined $DISABLE_UPLOADS;\n    # use a post max of 100K, set to -1 for no limits\n    $POST_MAX = 102_400 unless defined $POST_MAX;\n    # do not include undefined params parsed from query string\n    $NO_UNDEF_PARAMS = 0 unless defined $NO_UNDEF_PARAMS;\n    # separate the name=value pairs with ; rather than &\n    $USE_PARAM_SEMICOLONS = 0 unless defined $USE_PARAM_SEMICOLONS;\n    # only print headers once\n    $HEADERS_ONCE = 0 unless defined $HEADERS_ONCE;\n    # Set this to 1 to enable NPH scripts\n    $NPH = 0 unless defined $NPH;\n    # 0 => no debug, 1 => from @ARGV,  2 => from STDIN\n    $DEBUG = 0 unless defined $DEBUG;\n    # filter out null bytes in param - value pairs\n    $NO_NULL  = 1 unless defined $NO_NULL;\n    # set behavior when cgi_err() called -1 => silent, 0 => carp, 1 => croak\n    $FATAL = -1 unless defined $FATAL;\n\nFour of the default values of the old CGI.pm variables have been changed.\nUnlike CGI.pm which by default allows unlimited POST data and file uploads\nby default CGI::Simple limits POST data size to 100kB and denies file uploads\nby default. $USE_PARAM_SEMICOLONS is set to 0 by default so we use (old style)\n& rather than ; as the pair separator for query strings. Debugging is\ndisabled by default.\n\nThere are three new global variables. If $NO_NULL is true (the default) then\nCGI::Simple will strip null bytes out of names, values and keywords. Null\nbytes can do interesting things to C based code like Perl. Uploaded files\nare not touched. $FATAL controls the behavior when B<cgi_error()> is called.\nThe default value of -1 makes errors silent. $USE_CGI_PM_DEFAULTS reverts the\ndefaults to the CGI.pm standard values ie unlimited file uploads via POST\nfor DNS attacks. You can also get the defaults back by using the '-default'\npragma in the use:\n\n    use CGI::Simple qw(-default);\n    use CGI::Simple::Standard qw(-default);\n\nThe values of the global variables are stored in the CGI::Simple object and\ncan be referenced and changed using the B<globals()> method like this:\n\n    my $value = $q->globals( 'VARNAME' );      # get\n    $q->globals( 'VARNAME', 'some value' );    # set\n\nAs with many CGI.pm methods if you pass the optional value that will\nbe set.\n\nThe $CGI::Simple::VARNAME = 'N' syntax is only useful prior to calling the\nB<new()> constructor. After that all reference is to the values stored in the\nCGI::Simple object so you must change these using the B<globals()> method.\n\n$DISABLE_UPLOADS and $POST_MAX *must* be set prior to calling the constructor\nif you want the changes to have any effect as they control behavior during\ninitialization. This is the same a CGI.pm although some people seem to miss\nthis rather important point and set these after calling the constructor which\ndoes nothing.\n\nThe following globals are no longer relevant and have all been deleted:\n\n    $AUTOLOADED_ROUTINES\n    $AUTOLOAD_DEBUG\n    $BEEN_THERE\n    $CRLF\n    $DEFAULT_DTD\n    $EBCDIC\n    $FH\n    $FILLUNIT\n    $IIS\n    $IN\n    $INITIAL_FILLUNIT\n    $JSCRIPT\n    $MAC\n    $MAXTRIES\n    $MOD_PERL\n    $NOSTICKY\n    $OS\n    $PERLEX\n    $PRIVATE_TEMPFILES\n    $Q\n    $QUERY_CHARSET\n    $QUERY_PARAM\n    $SCRATCH\n    $SL\n    $SPIN_LOOP_MAX\n    $TIMEOUT\n    $TMPDIRECTORY\n    $XHTML\n    %EXPORT\n    %EXPORT_OK\n    %EXPORT_TAGS\n    %OVERLOAD\n    %QUERY_FIELDNAMES\n    %SUBS\n    @QUERY_PARAM\n    @TEMP\n\nNotes: CGI::Simple uses IO::File->new_tmpfile to get tempfile filehandles.\nThese are private by default so $PRIVATE_TEMPFILES is no longer required nor\nis $TMPDIRECTORY. The value that were stored in $OS, $CRLF, $QUERY_CHARSET\nand $EBCDIC are now stored in the CGI::Simple::Util object where they find\nmost of their use. The $MOD_PERL and $PERLEX values are now stored in our\nCGI::Simple object. $IIS was only used once in path_info().  $SL the system\nspecific / \\ : path delimiter is not required as we let IO::File handle our\ntempfile requirements. The rest of the globals are HTML related, export\nrelated, hand rolled autoload related or serve obscure purposes in CGI.pm\n\n=head2 Changes to pragmas\n\nThere are some new pragmas available. See the pragmas section for details.\nThe following CGI.pm pragmas are not available:\n\n    -any\n    -compile\n    -nosticky\n    -no_xhtml\n    -private_tempfiles\n\n=head2 Filehandles\n\nUnlike CGI.pm which tries to accept all filehandle like objects only \\*FH\nand $fh are accepted by CGI::Simple as file accessors for B<new()> and B<save()>.\nIO::File objects work fine.\n\n=head2 Hash interface\n\n    %hash = $q->Vars();     # pack values with \"\\0\";\n    %hash = $q->Vars(\",\");  # comma separate values\n\nYou may optionally pass B<Vars()> a string that will be used to separate multiple\nvalues when they are packed into the single hash value. If no value is\nsupplied the default \"\\0\" (null byte) will be used. Null bytes are dangerous\nthings for C based code (ie Perl).\n\n=head2 cgi-lib.pl\n\nAll the cgi-lib.pl 2.18 routines are supported. Unlike CGI.pm all the\nsubroutines from cgi-lib.pl are included. They have been GOLFED down to\n25 lines but they all work pretty much the same as the originals.\n\n=head1 CGI::Simple COMPLETE METHOD LIST\n\nHere is a complete list of all the CGI::Simple methods.\n\n=head2 Guts (hands off, except of course for new)\n\n    _initialize_globals\n    _use_cgi_pm_global_settings\n    _store_globals\n    import\n    _reset_globals\n    new\n    _initialize\n    _read_parse\n    _parse_params\n    _add_param\n    _parse_keywordlist\n    _parse_multipart\n    _save_tmpfile\n    _read_data\n\n=head2 Core Methods\n\n    param\n    add_param\n    param_fetch\n    url_param\n    keywords\n    Vars\n    append\n    delete\n    Delete\n    delete_all\n    Delete_all\n    upload\n    upload_info\n    query_string\n    parse_query_string\n    parse_keywordlist\n\n=head2 Save and Restore from File Methods\n\n    _init_from_file\n    save\n    save_parameters\n\n=head2 Miscellaneous Methods\n\n    url_decode\n    url_encode\n    escapeHTML\n    unescapeHTML\n    put\n    print\n\n=head2 Cookie Methods\n\n    cookie\n    raw_cookie\n\n=head2 Header Methods\n\n    header\n    cache\n    no_cache\n    redirect\n\n=head2 Server Push Methods\n\n    multipart_init\n    multipart_start\n    multipart_end\n    multipart_final\n\n=head2 Debugging Methods\n\n    read_from_cmdline\n    Dump\n    as_string\n    cgi_error\n\n=head2 cgi-lib.pl Compatibility Routines - all 2.18 functions available\n\n    _shift_if_ref\n    ReadParse\n    SplitParam\n    MethGet\n    MethPost\n    MyBaseUrl\n    MyURL\n    MyFullUrl\n    PrintHeader\n    HtmlTop\n    HtmlBot\n    PrintVariables\n    PrintEnv\n    CgiDie\n    CgiError\n\n=head2 Accessor Methods\n\n    version\n    nph\n    all_parameters\n    charset\n    crlf                # new, returns OS specific CRLF sequence\n    globals             # get/set global variables\n    auth_type\n    content_length\n    content_type\n    document_root\n    gateway_interface\n    path_translated\n    referer\n    remote_addr\n    remote_host\n    remote_ident\n    remote_user\n    request_method\n    script_name\n    server_name\n    server_port\n    server_protocol\n    server_software\n    user_name\n    user_agent\n    virtual_host\n    path_info\n    Accept\n    accept\n    http\n    https\n    protocol\n    url\n    self_url\n    state\n\n=head1 NEW METHODS IN CGI::Simple\n\nThere are a few new methods in CGI::Simple as listed below. The highlights are\nthe B<parse_query_string()> method to add the QUERY_STRING data to your object if\nthe method was POST. The B<no_cache()> method adds an expires now directive and\nthe Pragma: no-cache directive to the header to encourage some browsers to\ndo the right thing. B<PrintEnv()> from the cgi-lib.pl routines will dump an\nHTML friendly list of the %ENV and makes a handy addition to B<Dump()> for use\nin debugging. The upload method now accepts a filepath as an optional second\nargument as shown in the synopsis. If this is supplied the uploaded file will\nbe written to there automagically.\n\n=head2 Internal Routines\n\n    _initialize_globals()\n    _use_cgi_pm_global_settings()\n    _store_globals()\n    _initialize()\n    _init_from_file()\n    _read_parse()\n    _parse_params()\n    _add_param()\n    _parse_keywordlist()\n    _parse_multipart()\n    _save_tmpfile()\n    _read_data()\n\n=head2 New Public Methods\n\n    add_param()             # adds a param/value(s) pair +/- overwrite\n    upload_info()           # uploaded files MIME type and size\n    url_decode()            # decode s url encoded string\n    url_encode()            # url encode a string\n    parse_query_string()    # add QUERY_STRING data to $q object if 'POST'\n    no_cache()              # add both the Pragma: no-cache\n                            # and Expires/Date => 'now' to header\n\n=head2  cgi-lib.pl methods added for completeness\n\n    _shift_if_ref()         # internal hack reminiscent of self_or_default :-)\n    MyBaseUrl()\n    MyURL()\n    MyFullUrl()\n    PrintVariables()\n    PrintEnv()\n    CgiDie()\n    CgiError()\n\n=head2 New Accessors\n\n    crlf()                  # returns CRLF sequence\n    globals()               # global vars now stored in $q object - get/set\n    content_length()        # returns $ENV{'CONTENT_LENGTH'}\n    document_root()         # returns $ENV{'DOCUMENT_ROOT'}\n    gateway_interface()     # returns $ENV{'GATEWAY_INTERFACE'}\n\n=head1 METHODS IN CGI.pm NOT IN CGI::Simple\n\nHere is a complete list of what is not included in CGI::Simple. Basically all\nthe HTML related stuff plus large redundant chunks of the guts. The check.pl\nscript in the /misc dir will check to see if a script is using any of these.\n\n=head2 Guts - rearranged, recoded, renamed and hacked out of existence\n\n    initialize_globals()\n    compile()\n    expand_tags()\n    self_or_default()\n    self_or_CGI()\n    init()\n    to_filehandle()\n    save_request()\n    parse_params()\n    add_parameter()\n    binmode()\n    _make_tag_func()\n    AUTOLOAD()\n    _compile()\n    _setup_symbols()\n    new_MultipartBuffer()\n    read_from_client()\n    import_names()     # I dislike this and left it out, so shoot me.\n\n=head2 HTML Related\n\n    autoEscape()\n    URL_ENCODED()\n    MULTIPART()\n    SERVER_PUSH()\n    start_html()\n    _style()\n    _script()\n    end_html()\n    isindex()\n    startform()\n    start_form()\n    end_multipart_form()\n    start_multipart_form()\n    endform()\n    end_form()\n    _textfield()\n    textfield()\n    filefield()\n    password_field()\n    textarea()\n    button()\n    submit()\n    reset()\n    defaults()\n    comment()\n    checkbox()\n    checkbox_group()\n    _tableize()\n    radio_group()\n    popup_menu()\n    scrolling_list()\n    hidden()\n    image_button()\n    nosticky()\n    default_dtd()\n\n=head2 Upload Related\n\nCGI::Simple uses anonymous tempfiles supplied by IO::File to spool uploaded\nfiles to.\n\n    private_tempfiles() # automatic in CGI::Simple\n    tmpFileName()       # all upload files are anonymous\n    uploadInfo()        # relied on FH access, replaced with upload_info()\n\n\n=head2 Really Private Subs (marked as so)\n\n    previous_or_default()\n    register_parameter()\n    get_fields()\n    _set_values_and_labels()\n    _compile_all()\n    asString()\n    compare()\n\n=head2 Internal Multipart Parsing Routines\n\n    read_multipart()\n    readHeader()\n    readBody()\n    read()\n    fillBuffer()\n    eof()\n\n=head1 EXPORT\n\nNothing.\n\n=head1 AUTHOR INFORMATION\n\nOriginally copyright 2001 Dr James Freeman E<lt>jfreeman@tassie.net.auE<gt>\nThis release by Andy Armstrong <andy@hexten.net>\n\nThis package is free software and is provided \"as is\" without express or\nimplied warranty. It may be used, redistributed and/or modified under the terms\nof the Perl Artistic License (see http://www.perl.com/perl/misc/Artistic.html)\n\nAddress bug reports and comments to: andy@hexten.net.  When sending\nbug reports, please provide the version of CGI::Simple, the version of\nPerl, the name and version of your Web server, and the name and\nversion of the operating system you are using.  If the problem is even\nremotely browser dependent, please provide information about the\naffected browsers as well.\n\nAddress bug reports and comments to: andy@hexten.net\n\n=head1 CREDITS\n\nLincoln D. Stein (lstein@cshl.org) and everyone else who worked on the\noriginal CGI.pm upon which this module is heavily based\n\nBrandon Black for some heavy duty testing and bug fixes\n\nJohn D Robinson and Jeroen Latour for helping solve some interesting test\nfailures as well as Perlmonks:\ntommyw, grinder, Jaap, vek, erasei, jlongino and strider_corinth\n\nThanks for patches to:\n\nEwan Edwards, Joshua N Pritikin, Mike Barry, Michael Nachbaur, Chris\nWilliams, Mark Stosberg, Krasimir Berov\n\n=head1 LICENCE AND COPYRIGHT\n\nCopyright (c) 2007, Andy Armstrong C<< <andy@hexten.net> >>. All rights reserved.\n\nThis module is free software; you can redistribute it and/or\nmodify it under the same terms as Perl itself. See L<perlartistic>.\n\n=head1 SEE ALSO\n\nB<CGI>, L<CGI::Simple::Standard>, L<CGI::Simple::Cookie>,\nL<CGI::Simple::Util>, L<CGI::Minimal>\n\n=cut\n\n", "use Test::More tests => 318;\nuse Carp;\nuse strict;\nuse vars qw(%field %in);\n\nuse CGI::Simple;\n\nmy ( $q, $sv, @av );\nmy $tmpfile = './cgi-tmpfile.tmp';\n\n$ENV{'AUTH_TYPE'}      = 'PGP MD5 DES rot13';\n$ENV{'CONTENT_LENGTH'} = '42';\n$ENV{'CONTENT_TYPE'}   = 'application/x-www-form-urlencoded';\n$ENV{'COOKIE'} = 'foo=a%20phrase; bar=yes%2C%20a%20phrase&I%20say;';\n$ENV{'DOCUMENT_ROOT'}     = '/vs/www/foo';\n$ENV{'GATEWAY_INTERFACE'} = 'bleeding edge';\n$ENV{'HTTPS'}             = 'ON';\n$ENV{'HTTPS_A'}           = 'A';\n$ENV{'HTTPS_B'}           = 'B';\n$ENV{'HTTP_ACCEPT'}\n = 'text/html;q=1, text/plain;q=0.8, image/jpg, image/gif;q=0.42, */*;q=0.001';\n$ENV{'HTTP_COOKIE'}     = '';\n$ENV{'HTTP_FROM'}       = 'spammer@nowhere.com';\n$ENV{'HTTP_HOST'}       = 'the.vatican.org';\n$ENV{'HTTP_REFERER'}    = 'xxx.sex.com';\n$ENV{'HTTP_USER_AGENT'} = 'LWP';\n$ENV{'PATH_INFO'}       = '/somewhere/else';\n$ENV{'PATH_TRANSLATED'} = '/usr/local/somewhere/else';\n$ENV{'QUERY_STRING'} = 'name=JaPh%2C&color=red&color=green&color=blue';\n$ENV{'REDIRECT_QUERY_STRING'} = '';\n$ENV{'REMOTE_ADDR'}           = '127.0.0.1';\n$ENV{'REMOTE_HOST'}           = 'localhost';\n$ENV{'REMOTE_IDENT'}          = 'None of your damn business';\n$ENV{'REMOTE_USER'}           = 'Just another Perl hacker,';\n$ENV{'REQUEST_METHOD'}        = 'GET';\n$ENV{'SCRIPT_NAME'}           = '/cgi-bin/foo.cgi';\n$ENV{'SERVER_NAME'}           = 'nowhere.com';\n$ENV{'SERVER_PORT'}           = '8080';\n$ENV{'SERVER_PROTOCOL'}       = 'HTTP/1.0';\n$ENV{'SERVER_SOFTWARE'}       = 'Apache - accept no substitutes';\n\n$q = new CGI::Simple;\n\nsub undef_globals {\n  undef $CGI::Simple::USE_CGI_PM_DEFAULTS;\n  undef $CGI::Simple::DISABLE_UPLOADS;\n  undef $CGI::Simple::POST_MAX;\n  undef $CGI::Simple::NO_UNDEF_PARAMS;\n  undef $CGI::Simple::USE_PARAM_SEMICOLONS;\n  undef $CGI::Simple::HEADERS_ONCE;\n  undef $CGI::Simple::NPH;\n  undef $CGI::Simple::DEBUG;\n  undef $CGI::Simple::NO_NULL;\n  undef $CGI::Simple::FATAL;\n}\n\nundef_globals();\n\n# _initialize_globals()\n$q->_initialize_globals();\nis( $CGI::Simple::USE_CGI_PM_DEFAULTS, 0, '_initialize_globals(), 1' );\nis( $CGI::Simple::DISABLE_UPLOADS,     1, '_initialize_globals(), 2' );\nis( $CGI::Simple::POST_MAX, 102_400, '_initialize_globals(), 3' );\nis( $CGI::Simple::NO_UNDEF_PARAMS,      0, '_initialize_globals(), 4' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 0, '_initialize_globals(), 5' );\nis( $CGI::Simple::HEADERS_ONCE,         0, '_initialize_globals(), 6' );\nis( $CGI::Simple::NPH,                  0, '_initialize_globals(), 7' );\nis( $CGI::Simple::DEBUG,                0, '_initialize_globals(), 8' );\nis( $CGI::Simple::NO_NULL,              1, '_initialize_globals(), 9' );\nis( $CGI::Simple::FATAL, -1, '_initialize_globals(), 10' );\nundef_globals();\n\n# _use_cgi_pm_global_settings()\n$q->_use_cgi_pm_global_settings();\nis( $CGI::Simple::DISABLE_UPLOADS, 0,\n  '_use_cgi_pm_global_settings(), 1' );\nis( $CGI::Simple::POST_MAX, -1, '_use_cgi_pm_global_settings(), 2' );\nis( $CGI::Simple::NO_UNDEF_PARAMS, 0,\n  '_use_cgi_pm_global_settings(), 3' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS,\n  1, '_use_cgi_pm_global_settings(), 4' );\nis( $CGI::Simple::HEADERS_ONCE, 0, '_use_cgi_pm_global_settings(), 5' );\nis( $CGI::Simple::NPH,          0, '_use_cgi_pm_global_settings(), 6' );\nis( $CGI::Simple::DEBUG,        1, '_use_cgi_pm_global_settings(), 7' );\nis( $CGI::Simple::NO_NULL,      0, '_use_cgi_pm_global_settings(), 8' );\nis( $CGI::Simple::FATAL, -1, '_use_cgi_pm_global_settings(), 9' );\n\n# _store_globals()\nundef %{$q};\n\nok( !defined $q->{'.globals'}->{'DISABLE_UPLOADS'},\n  '_store_globals(), 1' );\nok( !defined $q->{'.globals'}->{'POST_MAX'}, '_store_globals(), 2' );\nok( !defined $q->{'.globals'}->{'NO_UNDEF_PARAMS'},\n  '_store_globals(), 3' );\nok( !defined $q->{'.globals'}->{'USE_PARAM_SEMICOLONS'},\n  '_store_globals(), 4' );\nok( !defined $q->{'.globals'}->{'HEADERS_ONCE'},\n  '_store_globals(), 5' );\nok( !defined $q->{'.globals'}->{'NPH'},     '_store_globals(), 6' );\nok( !defined $q->{'.globals'}->{'DEBUG'},   '_store_globals(), 7' );\nok( !defined $q->{'.globals'}->{'NO_NULL'}, '_store_globals(), 8' );\nok( !defined $q->{'.globals'}->{'FATAL'},   '_store_globals(), 9' );\nok( !defined $q->{'.globals'}->{'USE_CGI_PM_DEFAULTS'},\n  '_store_globals(), 10' );\n$q->_store_globals();\n\nok( defined $q->{'.globals'}->{'DISABLE_UPLOADS'},\n  '_store_globals(), 11' );\nok( defined $q->{'.globals'}->{'POST_MAX'}, '_store_globals(), 12' );\nok( defined $q->{'.globals'}->{'NO_UNDEF_PARAMS'},\n  '_store_globals(), 13' );\nok( defined $q->{'.globals'}->{'USE_PARAM_SEMICOLONS'},\n  '_store_globals(), 14' );\nok( defined $q->{'.globals'}->{'HEADERS_ONCE'},\n  '_store_globals(), 15' );\nok( defined $q->{'.globals'}->{'NPH'},     '_store_globals(), 16' );\nok( defined $q->{'.globals'}->{'DEBUG'},   '_store_globals(), 17' );\nok( defined $q->{'.globals'}->{'NO_NULL'}, '_store_globals(), 18' );\nok( defined $q->{'.globals'}->{'FATAL'},   '_store_globals(), 19' );\nok( defined $q->{'.globals'}->{'USE_CGI_PM_DEFAULTS'},\n  '_store_globals(), 20' );\n\n# import() - used to set paragmas\nmy @args\n = qw( -default -no_upload -unique_header -nph -no_debug -newstyle_url -no_undef_param );\n\nundef_globals();\n\n$q->import( @args );\n\nis( $CGI::Simple::USE_CGI_PM_DEFAULTS,  1, 'import(), 1' );\nis( $CGI::Simple::DISABLE_UPLOADS,      1, 'import(), 2' );\nis( $CGI::Simple::NO_UNDEF_PARAMS,      1, 'import(), 3' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 1, 'import(), 4' );\nis( $CGI::Simple::HEADERS_ONCE,         1, 'import(), 5' );\nis( $CGI::Simple::NPH,                  1, 'import(), 6' );\nis( $CGI::Simple::DEBUG,                0, 'import(), 7' );\nundef_globals();\n\n$q->import( qw ( -upload -oldstyle_url  -debug  ) );\n\nis( $CGI::Simple::DISABLE_UPLOADS,      0, 'import(), 8' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 0, 'import(), 9' );\nis( $CGI::Simple::DEBUG,                2, 'import(), 10' );\nundef_globals();\n\n# _reset_globals()\n$q->_reset_globals();\nis( $CGI::Simple::DISABLE_UPLOADS,      0,  '_reset_globals(), 1' );\nis( $CGI::Simple::POST_MAX,             -1, '_reset_globals(), 2' );\nis( $CGI::Simple::NO_UNDEF_PARAMS,      0,  '_reset_globals(), 3' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 1,  '_reset_globals(), 4' );\nis( $CGI::Simple::HEADERS_ONCE,         0,  '_reset_globals(), 5' );\nis( $CGI::Simple::NPH,                  0,  '_reset_globals(), 6' );\nis( $CGI::Simple::DEBUG,                1,  '_reset_globals(), 7' );\nis( $CGI::Simple::NO_NULL,              0,  '_reset_globals(), 8' );\nis( $CGI::Simple::FATAL,                -1, '_reset_globals(), 9' );\nundef_globals();\n\n$q = new CGI::Simple;\n\n# url_decode() - scalar context, void argument\n$sv = $q->url_decode();\nis( $sv, undef, 'url_decode(), 1' );\n\n# url_decode() - scalar context, valid argument\nmy ( $string, $enc_string );\nfor ( 32 .. 255 ) {\n  $string .= chr;\n  $enc_string .= uc sprintf \"%%%02x\", ord chr;\n}\nis( $q->url_decode( $enc_string ),\n  $string, 'url_decode(\\$enc_string), 1' );\n\n# url_encode() - scalar context, void argument\n$sv = $q->url_encode();\nis( $sv, undef, 'url_encode(), 1' );\n\n# url_encode() - scalar context, valid argument\n$sv = $q->url_encode( $string );\n$sv =~ tr/+/ /;\n$sv =~ s/%([a-fA-F0-9]{2})/ pack \"C\", hex $1 /eg;\nis( $sv, $string, 'url_encode(\\$string), 1' );\n\n# url encoding - circular test\nis( $q->url_decode( $q->url_encode( $string ) ),\n  $string, 'url encoding via circular test, 1' );\n\n# new() plain constructor\n$q = CGI::Simple->new;\nlike( $q, qr/CGI::Simple/, 'new() plain constructor, 1' );\n\n# new('') empty constructor\n$q = new CGI::Simple( '' );\nlike( $q, qr/CGI::Simple/, 'new() empty constructor, 1' );\n$q = new CGI::Simple( {} );\nlike( $q, qr/CGI::Simple/, 'new() empty constructor, 2' );\n\n# new() hash constructor\n$q = new CGI::Simple( { 'foo' => '1', 'bar' => [ 2, 3, 4 ] } );\n@av = $q->param;\n\n# fix OS bug with testing\nis( join( ' ', sort @av ), 'bar foo', 'new() hash constructor, 1' );\nis( $q->param( 'foo' ), 1, 'new() hash constructor, 2' );\nis( $q->param( 'bar' ), 2, 'new() hash constructor, 3' );\n@av = $q->param( 'bar' );\nis( join( '', @av ), 234, 'new() hash constructor, 4' );\n$q = new CGI::Simple( 'foo=1&bar=2&bar=3&bar=4' );\nopen FH, \">$tmpfile\", or carp \"Can't create $tmpfile $!\\n\";\n$q->save( \\*FH );\nclose FH;\n\n# new() query string constructor\n$q  = new CGI::Simple( 'foo=5&bar=6&bar=7&bar=8' );\n@av = $q->param;\nis( join( ' ', @av ), 'foo bar', 'new() query string constructor, 1' );\nis( $q->param( 'foo' ), 5, 'new() query string constructor, 2' );\nis( $q->param( 'bar' ), 6, 'new() query string constructor, 3' );\n@av = $q->param( 'bar' );\nis( join( '', @av ), 678, 'new() query string constructor, 4' );\nopen FH, \">>$tmpfile\", or carp \"Can't append $tmpfile $!\\n\";\n$q->save_parameters( \\*FH );\nclose FH;\n\n# new() CGI::Simple object constructor\n\nmy $q_old = new CGI::Simple( 'foo=1&bar=2&bar=3&bar=4' );\nmy $q_new = new CGI::Simple( $q_old );\nis( $q_old->query_string, 'foo=1&bar=2&bar=3&bar=4',\n  'new() CGI::Simple object constructor, 1' );\nis( $q_new->query_string, 'foo=1&bar=2&bar=3&bar=4',\n  'new() CGI::Simple object constructor, 2' );\n\n# new() \\@ARGV constructor\n\n$ENV{'REQUEST_METHOD'} = '';\n$CGI::Simple::DEBUG    = 1;\n@ARGV                  = qw( foo=bar\\=baz foo=bar\\&baz );\n$q                     = new CGI::Simple;\n\nis(\n  join( ' ', $q->param( 'foo' ) ),\n  'bar=baz bar&baz',\n  'new() \\@ARGV constructor, 1'\n);\n$ENV{'REQUEST_METHOD'} = 'GET';\n\n################ The Core Methods ################\n\n$q = new CGI::Simple;\n\n# param() - scalar and array context, void argument\n$sv = $q->param();\n@av = $q->param();\nis( $sv, '2', 'param() void argument, 1' );\nis( join( ' ', @av ), 'name color', 'param() void argument, 2' );\n\n# param() - scalar and array context, single argument (valid)\n$sv = $q->param( 'color' );\n@av = $q->param( 'color' );\nis( $sv, 'red', 'param(\\'color\\') single argument (valid), 1' );\nis(\n  join( ' ', @av ),\n  'red green blue',\n  'param(\\'color\\') single argument (valid), 2'\n);\n\n# param() - scalar and array context, single argument (invalid)\n$sv = $q->param( 'invalid' );\n@av = $q->param( 'invalid' );\nis( $sv, undef, 'param(\\'invalid\\') single argument (invalid), 1' );\nis( join( ' ', @av ),\n  '', 'param(\\'invalid\\') single argument (invalid), 2' );\n\n# param() - scalar and array context, -name=>'param' (valid)\n$sv = $q->param( -name => 'color' );\n@av = $q->param( -name => 'color' );\nis( $sv, 'red', 'param( -name=>\\'color\\' ) get values, 1' );\nis(\n  join( ' ', @av ),\n  'red green blue',\n  'param( -name=>\\'color\\' ) get values, 2'\n);\n\n# param() - scalar and array context, -name=>'param' (invalid)\n$sv = $q->param( -name => 'invalid' );\n@av = $q->param( -name => 'invalid' );\nis( $sv, undef, 'param( -name=>\\'invalid\\' ) get values, 1' );\nis( join( ' ', @av ), '', 'param( -name=>\\'invalid\\' ) get values, 2' );\n$CGI::Simple::NO_UNDEF_PARAMS = 0;\n$q                            = new CGI::Simple( 'name=&color=' );\n\n# param() - scalar and array context, void values void arg\n$sv = $q->param();\n@av = $q->param();\nis( $sv, '2', 'param() void values 1, 1' );\nis( join( ' ', @av ), 'name color', 'param() void values 1, 2' );\n\n# param() - scalar and array context, void values, valid arg\n$sv = $q->param( 'name' );\n@av = $q->param( 'name' );\nis( $sv, '', 'param(\\'name\\') void values 1, valid param, 1' );\nis( join( ' ', @av ),\n  '', 'param(\\'name\\') void values 1, valid param, 2' );\n$q = new CGI::Simple( 'name&color' );\n\n# param() - scalar and array context, void values void arg\n$sv = $q->param();\n@av = $q->param();\nis( $sv, '2', 'param() void values 2, 1' );\nis( join( ' ', @av ), 'name color', 'param() void values 2, 2' );\n\n# param() - scalar and array context, void values, valid arg\n$sv = $q->param( 'name' );\n@av = $q->param( 'name' );\nis( $sv, '', 'param(\\'name\\') void values 2 , valid param, 1' );\nis( join( ' ', @av ),\n  '', 'param(\\'name\\') void values 2 , valid param, 2' );\n$CGI::Simple::NO_UNDEF_PARAMS = 1;\n$q                            = new CGI::Simple( 'name=&color=' );\n\n# param() - scalar and array context, void values void arg\n$sv = $q->param();\n@av = $q->param();\nis( $sv, '0', 'param() void values 1, no undef, 1' );\nis( join( ' ', @av ), '', 'param() void values 1, no undef, 2' );\n\n# param() - scalar and array context, void values, valid arg\n$sv = $q->param( 'name' );\n@av = $q->param( 'name' );\nis( $sv, undef,\n  'param(\\'name\\') void values 1, valid param, no undef, 1' );\nis( join( ' ', @av ),\n  '', 'param(\\'name\\') void values 1, valid param, no undef, 2' );\n$q = new CGI::Simple( 'name&color' );\n\n# param() - scalar and array context, void values void arg\n$sv = $q->param();\n@av = $q->param();\nis( $sv, '0', 'param() void values 2, no undef, 1' );\nis( join( ' ', @av ), '', 'param() void values 2, no undef, 2' );\n\n# param() - scalar and array context, void values, valid arg\n$sv = $q->param( 'name' );\n@av = $q->param( 'name' );\nis( $sv, undef,\n  'param(\\'name\\') void values 2, valid param, no undef, 1' );\nis( join( ' ', @av ),\n  '', 'param(\\'name\\') void values 2, valid param, no undef, 2' );\n$CGI::Simple::NO_UNDEF_PARAMS = 0;\n$q                            = new CGI::Simple;\n\n# param() - scalar and array context, set values\n$sv = $q->param( 'foo', 'some', 'new', 'values' );\n@av = $q->param( 'foo', 'some', 'new', 'values' );\nis( $sv, 'some',\n  'param( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'some new values',\n  'param( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 2'\n);\n\n# param() - scalar and array context\n$sv = $q->param( -name => 'foo', -value => 'bar' );\n@av = $q->param( -name => 'foo', -value => 'bar' );\nis( $sv, 'bar',\n  'param( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 1' );\nis( join( ' ', @av ),\n  'bar', 'param( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 2' );\n\n# param() - scalar and array context\n$sv = $q->param( -name => 'foo', -value => [ 'bar', 'baz' ] );\n@av = $q->param( -name => 'foo', -value => [ 'bar', 'baz' ] );\nis( $sv, 'bar',\n  'param(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 1' );\nis( join( ' ', @av ),\n  'bar baz',\n  'param(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 2' );\n\n# add_param() - scalar and array context, void argument\n$sv = $q->add_param();\n@av = $q->add_param();\nis( $sv, undef, 'add_param(), 1' );\nis( join( ' ', @av ), '', 'add_param(), 2' );\n\n# add_param() - scalar and array context, existing param argument\n$q->add_param( 'foo', 'new' );\n@av = $q->param( 'foo' );\nis( join( ' ', @av ),\n  'bar baz new', 'add_param( \\'foo\\', \\'new\\' ), 1' );\n$q->add_param( 'foo', [ 1, 2, 3, 4, 5 ] );\n@av = $q->param( 'foo' );\nis(\n  join( ' ', @av ),\n  'bar baz new 1 2 3 4 5',\n  'add_param( \\'foo\\', \\'new\\' ), 2'\n);\n\n# add_param() - existing param argument, overwrite\n$q->add_param( 'foo', 'bar', 'overwrite' );\n@av = $q->param( 'foo' );\nis( join( ' ', @av ),\n  'bar', 'add_param(\\'foo\\', \\'bar\\', \\'overwrite\\' ), 1' );\n\n# add_param() - scalar and array context, existing param argument\n$q->add_param( 'new', 'new%2C' );\n@av = $q->param( 'new' );\nis( join( ' ', @av ), 'new%2C', 'add_param(  \\'new\\', \\'new\\'  ), 1' );\n$q->add_param( 'new', [ 1, 2, 3, 4, 5 ] );\n@av = $q->param( 'new' );\nis(\n  join( ' ', @av ),\n  'new%2C 1 2 3 4 5',\n  'add_param(  \\'new\\', \\'new\\'  ), 2'\n);\n\n# param_fetch() - scalar context, void argument\n$sv = $q->param_fetch();\nis( $sv, undef, 'param_fetch(), 1' );\n\n# param_fetch() - scalar context, 'color' syntax\n$sv = $q->param_fetch( 'color' );\nis( ref $sv, 'ARRAY', 'param_fetch( \\'color\\' ), 1' );\nis( join( ' ', @$sv ), 'red green blue',\n  'param_fetch( \\'color\\' ), 2' );\n\n# param_fetch() - scalar context, -name=>'color' syntax\n$sv = $q->param_fetch( -name => 'color' );\nis( ref $sv, 'ARRAY', 'param_fetch( -name=>\\'color\\' ), 1' );\nis(\n  join( ' ', @$sv ),\n  'red green blue',\n  'param_fetch( -name=>\\'color\\' ), 2'\n);\n\n# url_param() - scalar and array context, void argument\n$sv = $q->url_param();\n@av = $q->url_param();\nis( $sv, '2', 'url_param() void argument, 1' );\nis( join( ' ', @av ), 'name color', 'url_param() void argument, 2' );\n\n# url_param() - scalar and array context, single argument (valid)\n$sv = $q->url_param( 'color' );\n@av = $q->url_param( 'color' );\nis( $sv, 'red', 'url_param(\\'color\\') single argument (valid), 1' );\nis(\n  join( ' ', @av ),\n  'red green blue',\n  'url_param(\\'color\\') single argument (valid), 2'\n);\n\n# url_param() - scalar and array context, single argument (invalid)\n$sv = $q->url_param( 'invalid' );\n@av = $q->url_param( 'invalid' );\nis( $sv, undef, 'url_param(\\'invalid\\') single argument (invalid), 1' );\nis( join( ' ', @av ),\n  '', 'url_param(\\'invalid\\') single argument (invalid), 2' );\n\n# keywords() - scalar and array context, void argument\n$q  = new CGI::Simple( 'here+are++++some%20keywords' );\n$sv = $q->keywords;\n@av = $q->keywords;\nis( $sv, '4', 'keywords(), 1' );\nis( join( ' ', @av ), 'here are some keywords', 'keywords(), 2' );\n\n# keywords() - scalar and array context, array argument\n$sv = $q->keywords( 'foo', 'bar', 'baz' );\n@av = $q->keywords( 'foo', 'bar', 'baz' );\nis( $sv, '3', 'keywords( \\'foo\\', \\'bar\\', \\'baz\\' ), 1' );\nis( join( ' ', @av ),\n  'foo bar baz', 'keywords( \\'foo\\', \\'bar\\', \\'baz\\' ), 2' );\n\n# keywords() - scalar and array context, array ref argument\n$q  = new CGI::Simple;\n$sv = $q->keywords( [ 'foo', 'man', 'chu' ] );\n@av = $q->keywords( [ 'foo', 'man', 'chu' ] );\nis( $sv, '3', 'keywords( [\\'foo\\', \\'man\\', \\'chu\\'] ), 1' );\nis( join( ' ', @av ),\n  'foo man chu', 'keywords( [\\'foo\\', \\'man\\', \\'chu\\'] ), 2' );\n$sv = $q->Vars();\nis( $sv->{'color'}, \"red\\0green\\0blue\", 'Vars() - tied interface, 1' );\n$sv->{'color'} = \"foo\\0bar\\0baz\";\nis( join( ' ', $q->param( 'color' ) ),\n  'foo bar baz', 'Vars() - tied interface, 2' );\n$q = new CGI::Simple;\n\n# Vars() - hash context, void argument\nmy %hv = $q->Vars();\nis( $hv{'name'}, 'JaPh,', 'Vars(), 1' );\n\n# Vars() - hash context, \"|\" argument\n%hv = $q->Vars( ',' );\nis( $hv{'color'}, 'red,green,blue', 'Vars(\\',\\'), 1' );\n\n# append() - scalar and array context, void argument\n$sv = $q->append();\n@av = $q->append();\nis( $sv, undef, 'append(), 1' );\nis( join( '', @av ), '', 'append(), 2' );\n\n# append() - scalar and array context, set values, valid param\n$q->add_param( 'foo', 'bar', 'overwrite' );\n$sv = $q->append( 'foo', 'some' );\n@av = $q->append( 'foo', 'some-more' );\nis( $sv, 'bar', 'append( \\'foo\\', \\'some\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more',\n  'append( \\'foo\\', \\'some\\' ) set values, 2'\n);\n\n# append() - scalar and array context, set values, non-existant param\n$sv = $q->append( 'invalid', 'param1' );\n@av = $q->append( 'invalid', 'param2' );\nis( $sv, 'param1', 'append( \\'invalid\\', \\'param\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'param1 param2',\n  'append( \\'invalid\\', \\'param\\' ) set values, 2'\n);\nis(\n  join( ' ', $q->param( 'invalid' ) ),\n  'param1 param2',\n  'append( \\'invalid\\', \\'param\\' ) set values, 3'\n);\n\n# append() - scalar and array context, set values\n$sv = $q->append( 'foo', 'some', 'new',  'values' );\n@av = $q->append( 'foo', 'even', 'more', 'stuff' );\nis( $sv, 'bar',\n  'append( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more some new values even more stuff',\n  'append( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 2'\n);\n\n# append() - scalar and array context\n$sv = $q->append( -name => 'foo', -value => 'baz' );\n@av = $q->append( -name => 'foo', -value => 'xyz' );\nis( $sv, 'bar',\n  'append( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more some new values even more stuff baz xyz',\n  'append( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 2'\n);\n\n# append() - scalar and array context\n$sv = $q->append( -name => 'foo', -value => [ 1, 2 ] );\n@av = $q->append( -name => 'foo', -value => [ 3, 4 ] );\nis( $sv, 'bar',\n  'append(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more some new values even more stuff baz xyz 1 2 3 4',\n  'append(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 2'\n);\n\n# delete() - void/valid argument\n$q->delete();\nis( join( ' ', $q->param ), 'name color foo invalid', 'delete(), 1' );\n$q->delete( 'foo' );\nis( join( ' ', $q->param ), 'name color invalid', 'delete(), 2' );\n\n# Delete() - void/valid argument\n$q->Delete();\nis( join( ' ', $q->param ), 'name color invalid', 'Delete(), 1' );\n$q->Delete( 'invalid' );\nis( join( ' ', $q->param ), 'name color', 'Delete(), 2' );\n\n# delete_all() - scalar and array context, void/invalid/valid argument\n$q->delete_all();\nis( join( '', $q->param ), '', 'delete_all(), 1' );\nis( $q->globals, '11', 'delete_all(), 2' );\n$ENV{'CONTENT_TYPE'} = 'NOT multipart/form-data';\n$q = new CGI::Simple;\n\n# delete_all() - scalar and array context, void/invalid/valid argument\nis( join( ' ', $q->param ), 'name color', 'Delete_all(), 1' );\n$q->Delete_all();\nis( join( '', $q->param ), '', 'Delete_all(), 2' );\n$ENV{'CONTENT_TYPE'} = 'application/x-www-form-urlencoded';\n\n# upload() - invalid CONTENT_TYPE\n$sv = $q->upload( 'foo' );\nis( $sv, undef, 'upload() - invalid CONTENT_TYPE, 1' );\nis(\n  $q->cgi_error(),\n  'Oops! File uploads only work if you specify ENCTYPE=\"multipart/form-data\" in your <FORM> tag',\n  'upload() - invalid CONTENT_TYPE, 2'\n);\n$ENV{'CONTENT_TYPE'} = 'multipart/form-data';\n\n# upload() - scalar and array context, void/invalid/valid argument\n$sv = $q->upload();\n@av = $q->upload();\nis( $sv, undef, 'upload() - no files available, 1' );\nis( join( ' ', @av ), '', 'upload() - no files available, 2' );\n\n# upload() - scalar and array context, files available, void arg\n$q->{'.filehandles'}->{$_} = $_ for qw( File1 File2 File3 );\n$sv                        = $q->upload();\n@av                        = $q->upload();\nis( $sv, 3, 'upload() - files available, 1' );\nis(\n  join( ' ', sort @av ),\n  'File1 File2 File3',\n  'upload() - files available, 2'\n);\n$q->{'.filehandles'} = {};\n\n# upload() - scalar context, valid argument\nopen FH, $tmpfile or carp \"Can't read $tmpfile $!\\n\";\nmy $data = join '', <FH>;\nis( $data && 1, 1, 'upload(\\'/some/path/to/myfile\\') - real files, 1' );\nseek FH, 0, 0;\n$q->{'.filehandles'}->{'/some/path/to/myfile'} = \\*FH;\nmy $handle = $q->upload( '/some/path/to/myfile' );\nmy $upload = join '', <$handle>;\nis( $upload, $data,\n  'upload(\\'/some/path/to/myfile\\') - real files, 2' );\n\n# upload() - scalar context, invalid argument\n$sv = $q->upload( 'invalid' );\nis( $sv, undef, 'upload(\\'invalid\\'), 1' );\nis(\n  $q->cgi_error,\n  \"No filehandle for 'invalid'. Are uploads enabled (\\$DISABLE_UPLOADS = 0)? Is \\$POST_MAX big enough?\",\n  'upload(\\'invalid\\'), 2'\n);\nmy $ok = $q->upload( '/some/path/to/myfile', \"$tmpfile.bak\" );\nis( $ok, 1, 'upload(\\'invalid\\'), 3' );\nopen $handle, \"$tmpfile.bak\" or carp \"Can't read $tmpfile.bak $!\\n\";\n$upload = join '', <$handle>;\nis( $upload, $data, 'upload(\\'invalid\\'), 4' );\n$sv = $q->upload( '/some/path/to/myfile', \"$tmpfile.bak\" );\nis( $sv, undef, 'upload(\\'invalid\\'), 5' );\nunlink $tmpfile, \"$tmpfile.bak\";\n\n$ENV{'CONTENT_TYPE'} = 'application/x-www-form-urlencoded';\n$q = new CGI::Simple;\n\n# query_string() - scalar and array context, void/invalid/valid argument\n$sv = $q->query_string();\nis(\n  $sv,\n  'name=JaPh%2C&color=red&color=green&color=blue',\n  'query_string(), 1'\n);\n\n# parse_query_string()\n$q->delete_all;\nis( $q->param, 0, 'parse_query_string(), 1' );\n$ENV{'REQUEST_METHOD'} = 'POST';\n$q->parse_query_string();\n$sv = $q->query_string();\nis(\n  $sv,\n  'name=JaPh%2C&color=red&color=green&color=blue',\n  'parse_query_string(), 2'\n);\n$ENV{'REQUEST_METHOD'} = 'GET';\n\n# parse_keywordlist() - scalar and array context\n$sv = $q->parse_keywordlist( 'Just+another++Perl%20hacker%2C' );\n@av = $q->parse_keywordlist( 'Just+another++Perl%20hacker%2C' );\nis( $sv, '4', 'parse_keywordlist(), 1' );\nis(\n  join( ' ', @av ),\n  'Just another Perl hacker,',\n  'parse_keywordlist(), 2'\n);\n\n################ Save and Restore params from file ###############\n\n# _init_from_file()\n# save() - scalar and array context, void/invalid/valid argument\n# save_parameters() - scalar and array context, void/invalid/valid argument\n\n# all tested in constructor section\n\n################ Miscelaneous Methods ################\n\n$q = new CGI::Simple;\n\n# escapeHTML()\n$sv = $q->escapeHTML();\nis( $sv, undef, 'escapeHTML(), 1' );\n$sv = $q->escapeHTML( \"<>&\\\"\\012\\015<>&\\\"\\012\\015\", 0 );\nis(\n  $sv,\n  \"&lt;&gt;&amp;&quot;\\012\\015&lt;&gt;&amp;&quot;\\012\\015\",\n  'escapeHTML(), 2'\n);\n$sv = $q->escapeHTML( \"<>&\\\"\\012\\015<>&\\\"\\012\\015\", 'newlines too' );\nis(\n  $sv,\n  \"&lt;&gt;&amp;&quot;&#10;&#13;&lt;&gt;&amp;&quot;&#10;&#13;\",\n  'escapeHTML(), 3'\n);\n\n# unescapeHTML()\n$sv = $q->unescapeHTML();\nis( $sv, undef, 'unescapeHTML(), 1' );\n$sv = $q->unescapeHTML(\n  \"&lt;&gt;&amp;&quot;&#10;&#13;&lt;&gt;&amp;&quot;&#10;&#13;\" );\nis( $sv, \"<>&\\\"\\012\\015<>&\\\"\\012\\015\", 'unescapeHTML(), 2' );\n$sv = $q->unescapeHTML(\n  'Jack & Jill went up the hill; to get a pail of water' );\nis(\n  $sv,\n  'Jack & Jill went up the hill; to get a pail of water',\n  'unescapeHTML(), 3 '\n);\n\n# put()\nis( $q->put( '' ), 1, 'put(), 1' );\n\n# print()\nis( $q->print( '' ), 1, 'print(), 1' );\n################# Cookie Methods ################\n\n$q = new CGI::Simple;\n\n# raw_cookie() - scalar and array context, void argument\n$sv = $q->raw_cookie();\n@av = $q->raw_cookie();\nis(\n  $sv,\n  'foo=a%20phrase; bar=yes%2C%20a%20phrase&I%20say;',\n  'raw_cookie(), 1'\n);\nis(\n  join( '', @av ),\n  'foo=a%20phrase; bar=yes%2C%20a%20phrase&I%20say;',\n  'raw_cookie(), 2'\n);\n\n# raw_cookie() - scalar and array context, valid argument\n$sv = $q->raw_cookie( 'foo' );\n@av = $q->raw_cookie( 'foo' );\nis( $sv, 'a%20phrase', 'raw_cookie(\\'foo\\'), 1' );\nis( join( '', @av ), 'a%20phrase', 'raw_cookie(\\'foo\\'), 2' );\n\n# raw_cookie() - scalar and array context, invalid argument\n$sv = $q->raw_cookie( 'invalid' );\n@av = $q->raw_cookie( 'invalid' );\nis( $sv, undef, 'raw_cookie(\\'invalid\\'), 1' );\nis( join( '', @av ), '', 'raw_cookie(\\'invalid\\'), 2' );\n\n# cookie() - scalar and array context, void argument\n$sv = $q->cookie();\n@av = $q->cookie();\nis( $sv, '2', 'cookie(), 1' );\n\n# fix OS perl version test bug\nis( join( ' ', sort @av ), 'bar foo', 'cookie(), 2' );\n\n# cookie() - scalar and array context, valid argument, single value\n$sv = $q->cookie( 'foo' );\n@av = $q->cookie( 'foo' );\nis( $sv, 'a phrase', 'cookie(\\'foo\\'), 1' );\nis( join( '', @av ), 'a phrase', 'cookie(\\'foo\\'), 2' );\n\n# cookie() - scalar and array context, valid argument, multiple values\n$sv = $q->cookie( 'bar' );\n@av = $q->cookie( 'bar' );\nis( $sv, 'yes, a phrase', 'cookie(\\'foo\\'), 1' );\nis( join( ' ', @av ), 'yes, a phrase I say', 'cookie(\\'foo\\'), 2' );\n\n# cookie() - scalar and array context, invalid argument\n$sv = $q->cookie( 'invalid' );\n@av = $q->cookie( 'invalid' );\nis( $sv, undef, 'cookie(\\'invalid\\'), 1' );\nis( join( '', @av ), '', 'cookie(\\'invalid\\'), 2' );\nmy @vals = (\n  -name     => 'Password',\n  -value    => [ 'superuser', 'god', 'open sesame', 'mydog woofie' ],\n  -expires  => 'Mon, 11-Nov-2018 11:00:00 GMT',\n  -domain   => '.nowhere.com',\n  -path     => '/cgi-bin/database',\n  -secure   => 1,\n  -httponly => 1\n);\n\n# cookie() - scalar and array context, full argument set, correct order\n$sv = $q->cookie( @vals );\n@av = $q->cookie( @vals );\nis(\n  $sv,\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) correct order, 1'\n);\nis(\n  join( '', @av ),\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) correct order, 2'\n);\n\n# cookie() - scalar and array context, full argument set, incorrect order\n$sv\n = $q->cookie( @vals[ 0, 1, 10, 11, 12, 13, 8, 9, 2, 3, 4, 5, 6, 7 ] );\n@av\n = $q->cookie( @vals[ 0, 1, 10, 11, 12, 13, 8, 9, 2, 3, 4, 5, 6, 7 ] );\nis(\n  $sv,\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) incorrect order, 1'\n);\nis(\n  join( '', @av ),\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) incorrect order, 2'\n);\nmy $cookie = $sv;    # save a cookie for header testing\n\n# cookie() - scalar and array context, partial argument set\n$sv = $q->cookie( -name => 'foo', -value => 'bar' );\n@av = $q->cookie( -name => 'foo', -value => 'bar' );\nis(\n  $sv,\n  'foo=bar; path=/',\n  'cookie( -name=>\\'foo\\', -value=>\\'bar\\' ), 1'\n);\nis(\n  join( '', @av ),\n  'foo=bar; path=/',\n  'cookie( -name=>\\'foo\\', -value=>\\'bar\\' ), 2'\n);\n################# Header Methods ################\n\n$q = new CGI::Simple\n\n my $CRLF = $q->crlf;\n\n# header() - scalar and array context, void argument\n$sv = $q->header();\n@av = $q->header();\nis( $sv, \"Content-Type: text/html; charset=ISO-8859-1$CRLF$CRLF\",\n  'header(), 1' );\nis(\n  join( '', @av ),\n  \"Content-Type: text/html; charset=ISO-8859-1$CRLF$CRLF\",\n  'header(), 2'\n);\n\n# header() - scalar context, single argument\n$sv = $q->header( 'image/gif' );\nis(\n  $sv,\n  \"Content-Type: image/gif$CRLF$CRLF\",\n  'header(\\'image/gif\\'), 1'\n);\n@vals = (\n  -type       => 'image/gif',\n  -nph        => 1,\n  -status     => '402 Payment required',\n  -expires    => 'Mon, 11-Nov-2018 11:00:00 GMT',\n  -cookie     => $cookie,\n  -charset    => 'utf-7',\n  -attachment => 'foo.gif',\n  -Cost       => '$2.00'\n);\n\n# header() - scalar context, complex header\n$sv = $q->header( @vals );\nmy $header = <<'HEADER';\nHTTP/1.0 402 Payment required\nServer: Apache - accept no substitutes\nStatus: 402 Payment required\nSet-Cookie: Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly\nExpires: Mon, 11-Nov-2018 11:00:00 GMT\nDate: Tue, 11-Nov-2018 11:00:00 GMT\nContent-Disposition: attachment; filename=\"foo.gif\"\nCost: $2.00\nContent-Type: image/gif\nHEADER\n$sv     =~ s/[\\012\\015]//g;\n$header =~ s/[\\012\\015]//g;\n$sv     =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\n$header =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\nis( $sv, $header, 'header(\\@vals) - complex header, 1' );\n\n# cache() - scalar and array context, void argument\n$sv = $q->cache();\nis( $sv, undef, 'cache(), 1' );\n\n# cache() - scalar and array context, true argument, sets no cache paragma\n$sv = $q->cache( 1 );\nis( $sv, 1, 'cache(1), 1' );\n$sv = $q->header();\nis( $sv =~ /Pragma: no-cache/, 1, 'cache(1), 2' );\n\n# no_cache() - scalar and array context, void argument\n$sv = $q->no_cache();\nis( $sv, undef, 'cache(), 1' );\n\n# no_cache() - scalar and array context, true argument, sets no cache paragma\n$sv = $q->no_cache( 1 );\nis( $sv, 1, 'cache(1), 1' );\n$sv = $q->header();\nlike( $sv, qr/Pragma: no-cache/, 'cache(1), 2' );\nok( $sv =~ /Expires:(.*?)GMT/, 'cache(1), 3' );\nok( $sv =~ /Date:$1GMT/ . 'cache(1), 4' );\n\n# redirect() - scalar and array context, void argument\n$sv     = $q->redirect( 'http://a.galaxy.far.away.gov' );\n$header = <<'HEADER';\nStatus: 302 Moved\nExpires: Tue, 13 Nov 2001 06:45:15 GMT\nDate: Tue, 13 Nov 2001 06:45:15 GMT\nPragma: no-cache\nLocation: http://a.galaxy.far.away.gov\nHEADER\n$sv     =~ s/[\\012\\015]//g;\n$header =~ s/[\\012\\015]//g;\n$sv     =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\n$header =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\nis( $sv, $header, 'redirect(), 1' );\n\n# redirect() - scalar and array context, void argument\n$sv = $q->redirect( -uri => 'http://a.galaxy.far.away.gov', -nph => 1 );\n$header = <<'HEADER';\nHTTP/1.0 302 Moved\nServer: Apache - accept no substitutes\nStatus: 302 Moved\nExpires: Tue, 13 Nov 2001 06:49:24 GMT\nDate: Tue, 13 Nov 2001 06:49:24 GMT\nPragma: no-cache\nLocation: http://a.galaxy.far.away.gov\nHEADER\n$sv     =~ s/[\\012\\015]//g;\n$header =~ s/[\\012\\015]//g;\n$sv     =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\n$header =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\nis( $sv, $header, 'redirect() - nph, 1' );\n################# Server Push Methods #################\n\n$q = new CGI::Simple;\n\n$sv = $q->multipart_init();\nlike(\n  $sv,\n  qr|Content-Type: multipart/x-mixed-replace;boundary=\"------- =_[a-zA-Z0-9]{17}\"|,\n  'multipart_init(), 1'\n);\nlike( $sv, qr/--------- =_[a-zA-Z0-9]{17}$CRLF/,\n  'multipart_init(), 2' );\n$sv = $q->multipart_init( 'this_is_the_boundary' );\nlike( $sv, qr/boundary=\"this_is_the_boundary\"/, 'multipart_init(), 3' );\n$sv = $q->multipart_init( -boundary => 'this_is_another_boundary' );\nlike(\n  $sv,\n  qr/boundary=\"this_is_another_boundary\"/,\n  'multipart_init(), 4'\n);\n\n# multipart_start()\n$sv = $q->multipart_start();\nis( $sv, \"Content-Type: text/html$CRLF$CRLF\", 'multipart_start(), 1' );\n$sv = $q->multipart_start( 'foo/bar' );\nis( $sv, \"Content-Type: foo/bar$CRLF$CRLF\", 'multipart_start(), 2' );\n$sv = $q->multipart_start( -type => 'text/plain' );\nis( $sv, \"Content-Type: text/plain$CRLF$CRLF\", 'multipart_start(), 3' );\n\n# multipart_end()\n$sv = $q->multipart_end();\nis( $sv, \"$CRLF--this_is_another_boundary$CRLF\", 'multipart_end(), 1' );\n\n# multipart_final() - scalar and array context, void/invalid/valid argument\n$sv = $q->multipart_final();\nlike( $sv, qr|--this_is_another_boundary--|, 'multipart_final(), 1' );\n################# Debugging Methods ################\n\n# Dump() - scalar context, void argument\n$sv = $q->Dump();\nlike( $sv, qr/JaPh,/, 'Dump(), 1' );\n\n# as_string()\nis( $q->as_string(), $q->Dump(), 'as_string(), 1' );\n\n# cgi_error()\n$ENV{'REQUEST_METHOD'} = 'GET';\n$ENV{'QUERY_STRING'}   = '';\n$q                     = CGI::Simple->new;\n\n# we have changes this behaviour\n# is( $q->cgi_error, qr/400 No data received via method: GET/ , 'cgi_error(), 1');\nis( $q->cgi_error, undef, 'cgi_error(), 2' );\n$ENV{'QUERY_STRING'} = 'name=JaPh%2C&color=red&color=green&color=blue';\n\n############## cgi-lib.pl tests ################\n\n# ReadParse() - scalar and array context, void/invalid/valid argument\nCGI::Simple::ReadParse();\nis( $in{'name'}, 'JaPh,', 'ReadParse(), 1' );\n%in = ();\n$q  = new CGI::Simple;\n$q->ReadParse();\nis( $in{'name'}, 'JaPh,', 'ReadParse(), 2' );\nCGI::Simple::ReadParse( *field );\nis( $field{'name'}, 'JaPh,', 'ReadParse(), 3' );\n%field = ();\n$q     = new CGI::Simple;\n$q->ReadParse( *field );\nis( $field{'name'}, 'JaPh,', 'ReadParse(), 4' );\n$q = $field{'CGI'};\nis( $q->param( 'name' ), 'JaPh,', 'ReadParse(), 5' );\n\n# SplitParam() - scalar and array context, void/invalid/valid argument\nis(\n  join( ' ', $q->SplitParam( $field{'color'} ) ),\n  'red green blue',\n  'SplitParam(), 1'\n);\nis(\n  join( ' ', CGI::Simple::SplitParam( $field{'color'} ) ),\n  'red green blue',\n  'SplitParam(), 2'\n);\nis( scalar $q->SplitParam( $field{'color'} ), 'red',\n  'SplitParam(), 3' );\nis( scalar CGI::Simple::SplitParam( $field{'color'} ),\n  'red', 'SplitParam(), 4' );\n\n# MethGet() - scalar and array context, void/invalid/valid argument\nis( $q->MethGet, 1, 'MethGet(), 1' );\n\n# MethPost() - scalar and array context, void/invalid/valid argument\nis( !$q->MethPost, 1, 'MethPost(), 1' );\n\n# MyBaseUrl() - scalar and array context, void/invalid/valid argument\nis(\n  $q->MyBaseUrl,\n  'http://nowhere.com:8080/cgi-bin/foo.cgi',\n  'MyBaseUrl(), 1'\n);\n$ENV{'SERVER_PORT'} = 80;\nis(\n  $q->MyBaseUrl,\n  'http://nowhere.com/cgi-bin/foo.cgi',\n  'MyBaseUrl(), 2'\n);\n$ENV{'SERVER_PORT'} = 8080;\n\n# MyURL() - scalar and array context, void/invalid/valid argument\nis( $q->MyURL, 'http://nowhere.com:8080/cgi-bin/foo.cgi',\n  'MyURL(), 1' );\n\n# MyFullUrl() - scalar and array context, void/invalid/valid argument\nis(\n  $q->MyFullUrl,\n  'http://nowhere.com:8080/cgi-bin/foo.cgi/somewhere/else?name=JaPh%2C&color=red&color=green&color=blue',\n  'MyFullUrl(), 1'\n);\n$ENV{'QUERY_STRING'} = '';\n$ENV{'PATH_INFO'}    = '';\nis(\n  $q->MyFullUrl,\n  'http://nowhere.com:8080/cgi-bin/foo.cgi',\n  'MyFullUrl(), 2'\n);\n$ENV{'QUERY_STRING'} = 'name=JaPh%2C&color=red&color=green&color=blue';\n$ENV{'PATH_INFO'}    = '/somewhere/else';\n\n# PrintHeader() - scalar and array context, void/invalid/valid argument\nlike( $q->PrintHeader, qr|Content-Type: text/html|,\n  'PrintHeader(), 1' );\n\n# HtmlTop() - scalar and array context, void/invalid/valid argument\nis(\n  $q->HtmlTop( '$' ),\n  \"<html>\\n<head>\\n<title>\\$</title>\\n</head>\\n<body>\\n<h1>\\$</h1>\\n\",\n  'HtmlTop(), 1'\n);\nis(\n  CGI::Simple::HtmlTop( '$' ),\n  \"<html>\\n<head>\\n<title>\\$</title>\\n</head>\\n<body>\\n<h1>\\$</h1>\\n\",\n  'HtmlTop(), 2'\n);\n\n# HtmlBot() - scalar and array context, void/invalid/valid argument\nis( $q->HtmlBot, \"</body>\\n</html>\\n\", 'HtmlBot(), 1' );\n\n# PrintVariables() - scalar and array context, void/invalid/valid argument\nlike( $q->PrintVariables( \\%field ), qr/JaPh,/, 'PrintVariables(), 1' );\n\n# PrintEnv() - scalar and array context, void/invalid/valid argument\nlike( $q->PrintEnv, qr/PATH_TRANSLATED/, 'PrintEnv(), 1' );\n\n# CgiDie() - scalar and array context, void/invalid/valid argument\n\n# CgiError() - scalar and array context, void/invalid/valid argument\n\n################ Accessor Methods ################\n\n$q = new CGI::Simple;\n\n# version() - scalar context, void argument\nlike( $q->version(), qr/[\\d\\.]+/, 'version(), 1' );\n\n# nph() - scalar context, void  argument\nis( $q->nph(), $q->globals( 'NPH' ), 'nph(), 1' );\n\n# nph() - scalar context, valid  argument\nis( $q->nph( 42 ),        42, 'nph(42), 1' );\nis( $q->globals( 'NPH' ), 42, 'nph(42), 2' );\n\n# all_parameters() - array context, void/invalid/valid argument\n$sv = $q->all_parameters();\n@av = $q->all_parameters();\nis( $sv, 2, 'all_parameters(), 1' );\nis( join( ' ', @av ), 'name color', 'all_parameters(), 2' );\n\n# charset() - scalar context, void argument\n$sv = $q->charset();\nis( $sv, 'utf-7', 'charset(), 1' );\n\n# charset() - scalar context, void argument\n$sv = $q->charset( 'Linear B' );\nis( $sv, 'Linear B', 'charset(), 1' );\n$sv = $q->charset();\nis( $sv, 'Linear B', 'charset(), 2' );\n\n# crlf() - scalar context, void argument\n$sv = $q->crlf();\nlike( $sv, qr/[\\012\\015]{1,2}/, 'crlf(), 1' );\n\n# globals() - scalar and array context, void argument\n$sv = $q->globals();\nis( $sv, 11, 'globals(), 1' );\n@av = $q->globals();\nis(\n  join( ' ', sort @av ),\n  'DEBUG DISABLE_UPLOADS FATAL HEADERS_ONCE NO_NULL NO_UNDEF_PARAMS NPH PARAM_UTF8 POST_MAX USE_CGI_PM_DEFAULTS USE_PARAM_SEMICOLONS',\n  'globals(), 2'\n);\n\n# globals() - scalar context, invalid argument\n$sv = $q->globals( 'FOO' );\nis( $sv, undef, 'globals(\\'FOO\\') - invalid arg, 1' );\n\n# globals() - scalar context, valid argument\nis( $q->globals( 'VERSION', '3.1415' ),\n  '3.1415', 'globals(\\'VERSION\\') - valid arg, 1' );\nis( $q->globals( 'VERSION' ),\n  '3.1415', 'globals(\\'VERSION\\') - valid arg, 2' );\n\n# auth_type() - scalar context, void argument\n$sv = $q->auth_type();\nis( $sv, 'PGP MD5 DES rot13', 'auth_type(), 1' );\n\n# content_length() - scalar context, void argument\n$sv = $q->content_length();\nis( $sv, '42', 'content_length(), 1' );\n\n# content_type() - scalar context, void argument\n$sv = $q->content_type();\nis( $sv, 'application/x-www-form-urlencoded', 'content_type(), 1' );\n\n# document_root() - scalar context, void argument\n$sv = $q->document_root();\nis( $sv, '/vs/www/foo', 'document_root(), 1' );\n\n# gateway_interface() - scalar context, void argument\n$sv = $q->gateway_interface();\nis( $sv, 'bleeding edge', 'gateway_interface(), 1' );\n\n# path_translated() - scalar context, void argument\n$sv = $q->path_translated();\nis( $sv, '/usr/local/somewhere/else', 'path_translated(), 1' );\n\n# referer() - scalar context, void argument\n$sv = $q->referer();\nis( $sv, 'xxx.sex.com', 'referer(), 1' );\n\n# remote_addr() - scalar and array context, void/invalid/valid argument\n$sv = $q->remote_addr();\nis( $sv, '127.0.0.1', 'remote_addr(), 1' );\n\n# remote_host() - scalar context, void argument\n$sv = $q->remote_host();\nis( $sv, 'localhost', 'remote_host(), 1' );\n\n# remote_ident() - scalar context, void argument\n$sv = $q->remote_ident();\nis( $sv, 'None of your damn business', 'remote_ident(), 1' );\n\n# remote_user() - scalar context, void argument\n$sv = $q->remote_user();\nis( $sv, 'Just another Perl hacker,', 'remote_user(), 1' );\n\n# request_method() - scalar context, void argument\n$sv = $q->request_method();\nis( $sv, 'GET', 'request_method(), 1' );\n\n# script_name() - scalar context, void argument\n$sv = $q->script_name();\nis( $sv, '/cgi-bin/foo.cgi', 'script_name(), 1' );\n\n# server_name() - scalar context, void argument\n$sv = $q->server_name();\nis( $sv, 'nowhere.com', 'server_name(), 1' );\n\n# server_port() - scalar context, void argument\n$sv = $q->server_port();\nis( $sv, '8080', 'server_port(), 1' );\n\n# server_protocol() - scalar context, void argument\n$sv = $q->server_protocol();\nis( $sv, 'HTTP/1.0', 'server_protocol(), 1' );\n\n# server_software() - scalar context, void argument\n$sv = $q->server_software();\nis( $sv, 'Apache - accept no substitutes', 'server_software(), 1' );\n\n# user_name() - scalar context, void argument\n$sv = $q->user_name();\nis( $sv, 'spammer@nowhere.com', 'user_name(), 1' );\n\n# user_agent() - scalar context, void argument\n$sv = $q->user_agent();\nis( $sv, 'LWP', 'user_agent(), 1' );\n\n# user_agent() - scalar context, void argument\n$sv = $q->user_agent( 'lwp' );\nis( $sv, 1, 'user_agent(), 1' );\n$sv = $q->user_agent( 'mozilla' );\nis( $sv, '', 'user_agent(), 2' );\n\n# virtual_host() - scalar context, void argument\n$sv = $q->virtual_host();\nis( $sv, 'the.vatican.org', 'virtual_host(), 1' );\n\n# path_info() - scalar and array context, void/valid argument\n$sv = $q->path_info();\nis( $sv, '/somewhere/else', 'path_info(), 1' );\n$sv = $q->path_info( 'somewhere/else/again' );\nis( $sv, '/somewhere/else/again', 'path_info(), 2' );\n$sv = $q->path_info();\nis( $sv, '/somewhere/else/again', 'path_info(), 3' );\n$q->path_info( '/somewhere/else' );\n\n# Accept() - scalar and array context, void argument\n$sv = $q->Accept();\n@av = $q->Accept();\nis( $sv, 5, 'Accept(), 1' );\nis(\n  join( ' ', sort @av ),\n  '*/* image/gif image/jpg text/html text/plain',\n  'Accept(), 2'\n);\n\n# Accept() - scalar context, invalid argument (matches '*/*'\n$sv = $q->Accept( 'foo/bar' );\nis( $sv, '0.001', 'Accept(\\'foo/bar\\'), 1' );\n\n# Accept() - scalar and array context, void argument\n$sv = $q->Accept( '*/*' );\nis( $sv, '0.001', 'Accept(), 1' );\n\n# http() - scalar and array context, void argument\n$sv = $q->http();\n@av = $q->http();\nok( $sv > 0, 'http(), 1' );\nlike( $av[0], qr/HTTP/, 'http(), 2' );\n\n# http() - scalar context, invalid arguments\n$sv = $q->http( 'http-hell' );\nis( $sv, undef, 'http(\\'invalid arg\\'), 1' );\n$sv = $q->http( 'hell' );\nis( $sv, undef, 'http(\\'invalid arg\\'), 2' );\n\n# http() - scalar context, valid arguments\n$sv = $q->http( 'http-from' );\nis( $sv, 'spammer@nowhere.com', 'http(\\'valid arg\\'), 1' );\n$sv = $q->http( 'from' );\nis( $sv, 'spammer@nowhere.com', 'http(\\'valid arg\\'), 2' );\n\n# https() - scalar and array context, void argument\n$sv = $q->https();\nis( $sv, 'ON', 'https(), 1' );\n\n# https() - scalar  context, invalid argument\n$sv = $q->https( 'hell' );\nis( $sv, undef, 'https(\\'invalid arg\\'), 1' );\n\n# https() - scalar context, valid arguments\n$sv = $q->https( 'https-a' );\nis( $sv, 'A', 'https(\\'valid arg\\'), 1' );\n$sv = $q->https( 'a' );\nis( $sv, 'A', 'https(\\'valid arg\\'), 2' );\n\n# protocol() - scalar context, void arguments\n$sv = $q->protocol();\nis( $sv, 'https', 'protocol(), 1' );\n$ENV{'HTTPS'}       = 'OFF';\n$ENV{'SERVER_PORT'} = '443';\n$sv                 = $q->protocol();\nis( $sv, 'https', 'protocol(), 2' );\n$ENV{'SERVER_PORT'} = '8080';\n$sv = $q->protocol();\nis( $sv, 'http', 'protocol(), 3' );\n\n# url() - scalar context, void argument\n$ENV{'HTTP_HOST'} = '';\nis( $q->url, 'http://nowhere.com:8080/cgi-bin/foo.cgi', 'url(), 1' );\n\n# url() - scalar context, valid argument\nis( $q->url( -absolute => 1 ),\n  '/cgi-bin/foo.cgi', 'CGI::url(-absolute=>1)' );\n\n# url() - scalar context, valid argument\nis( $q->url( -relative => 1 ), 'foo.cgi', 'url(-relative=>1), 1' );\n\n# url() - scalar context, valid argument\nis( $q->url( -relative => 1, -path => 1 ),\n  'foo.cgi/somewhere/else', 'url(-relative=>1,-path=>1), 1' );\n\n# url() - scalar context, valid argument\nis(\n  $q->url( -relative => 1, -path => 1, -query => 1 ),\n  'foo.cgi/somewhere/else?name=JaPh%2C&color=red&color=green&color=blue',\n  'url(-relative=>1,-path=>1,-query=>1), 1'\n);\n\n# self_url() - scalar context, void argument\n$sv = $q->self_url();\n@av = $q->self_url();\nis(\n  $sv,\n  'http://nowhere.com:8080/cgi-bin/foo.cgi/somewhere/else?name=JaPh%2C&color=red&color=green&color=blue',\n  'self_url(), 1'\n);\n\n# state() - scalar and array context, void/invalid/valid argument\nis( $q->state(), $q->self_url(), 'state(), 1' );\n\n################ Yet More Tests ################\n\n#$CGI::Simple::POST_MAX = 20;\n#$ENV{'REQUEST_METHOD'} = 'POST';\n#$q = new CGI::Simple;\n#is( $q->cgi_error, '413 Request entity too large: 42 bytes on STDIN exceeds $POST_MAX!' , 'Yet more tests, 1');\n\n$ENV{'REQUEST_METHOD'} = 'HEAD';\n$ENV{'QUERY_STRING'}   = '';\n$ENV{'REDIRECT_QUERY_STRING'}\n = 'name=JAPH&color=red&color=green&color=blue';\n\n$CGI::Simple::POST_MAX = 50;\n$q                     = new CGI::Simple;\n@av                    = $q->param;\n\nis( join( ' ', @av ), 'name color', 'Yet more tests, 2' );\n@av = $q->param( 'color' );\nis( join( ' ', @av ), 'red green blue', 'Yet more tests, 3' );\n", "use Test::More tests => 288;\nuse Carp;\nuse strict;\nuse vars qw(%field %in);\n\nuse CGI::Simple::Standard qw( :all );\n\nmy ( $q, $sv, @av );\nmy $tmpfile = './cgi-tmpfile.tmp';\n\nmy $debug = 0;\n\n$ENV{'AUTH_TYPE'}      = 'PGP MD5 DES rot13';\n$ENV{'CONTENT_LENGTH'} = '42';\n$ENV{'CONTENT_TYPE'}   = 'application/x-www-form-urlencoded';\n$ENV{'COOKIE'} = 'foo=a%20phrase; bar=yes%2C%20a%20phrase&I%20say;';\n$ENV{'DOCUMENT_ROOT'}     = '/vs/www/foo';\n$ENV{'GATEWAY_INTERFACE'} = 'bleeding edge';\n$ENV{'HTTPS'}             = 'ON';\n$ENV{'HTTPS_A'}           = 'A';\n$ENV{'HTTPS_B'}           = 'B';\n$ENV{'HTTP_ACCEPT'}\n = 'text/html;q=1, text/plain;q=0.8, image/jpg, image/gif;q=0.42, */*;q=0.001';\n$ENV{'HTTP_COOKIE'}     = '';\n$ENV{'HTTP_FROM'}       = 'spammer@nowhere.com';\n$ENV{'HTTP_HOST'}       = 'the.vatican.org';\n$ENV{'HTTP_REFERER'}    = 'xxx.sex.com';\n$ENV{'HTTP_USER_AGENT'} = 'LWP';\n$ENV{'PATH_INFO'}       = '/somewhere/else';\n$ENV{'PATH_TRANSLATED'} = '/usr/local/somewhere/else';\n$ENV{'QUERY_STRING'} = 'name=JaPh%2C&color=red&color=green&color=blue';\n$ENV{'REDIRECT_QUERY_STRING'} = '';\n$ENV{'REMOTE_ADDR'}           = '127.0.0.1';\n$ENV{'REMOTE_HOST'}           = 'localhost';\n$ENV{'REMOTE_IDENT'}          = 'None of your damn business';\n$ENV{'REMOTE_USER'}           = 'Just another Perl hacker,';\n$ENV{'REQUEST_METHOD'}        = 'GET';\n$ENV{'SCRIPT_NAME'}           = '/cgi-bin/foo.cgi';\n$ENV{'SERVER_NAME'}           = 'nowhere.com';\n$ENV{'SERVER_PORT'}           = '8080';\n$ENV{'SERVER_PROTOCOL'}       = 'HTTP/1.0';\n$ENV{'SERVER_SOFTWARE'}       = 'Apache - accept no substitutes';\n\nrestore_parameters();\n\nsub undef_globals {\n  undef $CGI::Simple::USE_CGI_PM_DEFAULTS;\n  undef $CGI::Simple::DISABLE_UPLOADS;\n  undef $CGI::Simple::POST_MAX;\n  undef $CGI::Simple::NO_UNDEF_PARAMS;\n  undef $CGI::Simple::USE_PARAM_SEMICOLONS;\n  undef $CGI::Simple::HEADERS_ONCE;\n  undef $CGI::Simple::NPH;\n  undef $CGI::Simple::DEBUG;\n  undef $CGI::Simple::NO_NULL;\n  undef $CGI::Simple::FATAL;\n}\n\nundef_globals();\nrestore_parameters();\n\n# _initialize_globals()\n\n_initialize_globals();\nis( $CGI::Simple::USE_CGI_PM_DEFAULTS, 0, '_initialize_globals(), 1' );\nis( $CGI::Simple::DISABLE_UPLOADS,     1, '_initialize_globals(), 2' );\nis( $CGI::Simple::POST_MAX, 102_400, '_initialize_globals(), 3' );\nis( $CGI::Simple::NO_UNDEF_PARAMS,      0, '_initialize_globals(), 4' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 0, '_initialize_globals(), 5' );\nis( $CGI::Simple::HEADERS_ONCE,         0, '_initialize_globals(), 6' );\nis( $CGI::Simple::NPH,                  0, '_initialize_globals(), 7' );\nis( $CGI::Simple::DEBUG,                0, '_initialize_globals(), 8' );\nis( $CGI::Simple::NO_NULL,              1, '_initialize_globals(), 9' );\nis( $CGI::Simple::FATAL, -1, '_initialize_globals(), 10' );\n\nundef_globals();\n\n# _use_cgi_pm_global_settings()\n\n_use_cgi_pm_global_settings();\nrestore_parameters();\nis( $CGI::Simple::DISABLE_UPLOADS, 0,\n  '_use_cgi_pm_global_settings(), 1' );\nis( $CGI::Simple::POST_MAX, -1, '_use_cgi_pm_global_settings(), 2' );\nis( $CGI::Simple::NO_UNDEF_PARAMS, 0,\n  '_use_cgi_pm_global_settings(), 3' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS,\n  1, '_use_cgi_pm_global_settings(), 4' );\nis( $CGI::Simple::HEADERS_ONCE, 0, '_use_cgi_pm_global_settings(), 5' );\nis( $CGI::Simple::NPH,          0, '_use_cgi_pm_global_settings(), 6' );\nis( $CGI::Simple::DEBUG,        1, '_use_cgi_pm_global_settings(), 7' );\nis( $CGI::Simple::NO_NULL,      0, '_use_cgi_pm_global_settings(), 8' );\nis( $CGI::Simple::FATAL, -1, '_use_cgi_pm_global_settings(), 9' );\n\n# _store_globals()\n\n$q = _cgi_object();\nundef %{$q};\n\nok( !defined $q->{'.globals'}->{'DISABLE_UPLOADS'},\n  '_store_globals(), 1' );\nok( !defined $q->{'.globals'}->{'POST_MAX'}, '_store_globals(), 2' );\nok( !defined $q->{'.globals'}->{'NO_UNDEF_PARAMS'},\n  '_store_globals(), 3' );\nok( !defined $q->{'.globals'}->{'USE_PARAM_SEMICOLONS'},\n  '_store_globals(), 4' );\nok( !defined $q->{'.globals'}->{'HEADERS_ONCE'},\n  '_store_globals(), 5' );\nok( !defined $q->{'.globals'}->{'NPH'},     '_store_globals(), 6' );\nok( !defined $q->{'.globals'}->{'DEBUG'},   '_store_globals(), 7' );\nok( !defined $q->{'.globals'}->{'NO_NULL'}, '_store_globals(), 8' );\nok( !defined $q->{'.globals'}->{'FATAL'},   '_store_globals(), 9' );\nok( !defined $q->{'.globals'}->{'USE_CGI_PM_DEFAULTS'},\n  '_store_globals(), 10' );\n\n$q->_store_globals();\n\nok( defined $q->{'.globals'}->{'DISABLE_UPLOADS'},\n  '_store_globals(), 11' );\nok( defined $q->{'.globals'}->{'POST_MAX'}, '_store_globals(), 12' );\nok( defined $q->{'.globals'}->{'NO_UNDEF_PARAMS'},\n  '_store_globals(), 13' );\nok( defined $q->{'.globals'}->{'USE_PARAM_SEMICOLONS'},\n  '_store_globals(), 14' );\nok( defined $q->{'.globals'}->{'HEADERS_ONCE'},\n  '_store_globals(), 15' );\nok( defined $q->{'.globals'}->{'NPH'},     '_store_globals(), 16' );\nok( defined $q->{'.globals'}->{'DEBUG'},   '_store_globals(), 17' );\nok( defined $q->{'.globals'}->{'NO_NULL'}, '_store_globals(), 18' );\nok( defined $q->{'.globals'}->{'FATAL'},   '_store_globals(), 19' );\nok( defined $q->{'.globals'}->{'USE_CGI_PM_DEFAULTS'},\n  '_store_globals(), 20' );\n\n# import() - used to set paragmas\n\nmy @args\n = qw( -default -no_upload -unique_header -nph -no_debug -newstyle_url -no_undef_param  );\n\nundef_globals();\n\n$q->import( @args );\n\nis( $CGI::Simple::USE_CGI_PM_DEFAULTS,  1, 'import(), 1' );\nis( $CGI::Simple::DISABLE_UPLOADS,      1, 'import(), 2' );\nis( $CGI::Simple::NO_UNDEF_PARAMS,      1, 'import(), 3' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 1, 'import(), 4' );\nis( $CGI::Simple::HEADERS_ONCE,         1, 'import(), 5' );\nis( $CGI::Simple::NPH,                  1, 'import(), 6' );\nis( $CGI::Simple::DEBUG,                0, 'import(), 7' );\n\nundef_globals();\n\n$q->import(\n  qw ( -default -upload -no_undefparams -oldstyle_url -npheader -debug  )\n);\n\nis( $CGI::Simple::USE_CGI_PM_DEFAULTS,  1, 'import(), 8' );\nis( $CGI::Simple::DISABLE_UPLOADS,      0, 'import(), 9' );\nis( $CGI::Simple::NO_UNDEF_PARAMS,      1, 'import(), 10' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 0, 'import(), 11' );\nis( $CGI::Simple::NPH,                  1, 'import(), 12' );\nis( $CGI::Simple::DEBUG,                2, 'import(), 13' );\n\nundef_globals();\n\n# _reset_globals()\n\n_reset_globals();\n\nis( $CGI::Simple::DISABLE_UPLOADS,      0,  '_reset_globals(), 1' );\nis( $CGI::Simple::POST_MAX,             -1, '_reset_globals(), 2' );\nis( $CGI::Simple::NO_UNDEF_PARAMS,      0,  '_reset_globals(), 3' );\nis( $CGI::Simple::USE_PARAM_SEMICOLONS, 1,  '_reset_globals(), 4' );\nis( $CGI::Simple::HEADERS_ONCE,         0,  '_reset_globals(), 5' );\nis( $CGI::Simple::NPH,                  0,  '_reset_globals(), 6' );\nis( $CGI::Simple::DEBUG,                1,  '_reset_globals(), 7' );\nis( $CGI::Simple::NO_NULL,              0,  '_reset_globals(), 8' );\nis( $CGI::Simple::FATAL,                -1, '_reset_globals(), 9' );\n\nundef_globals();\n\nrestore_parameters();\n\n# url_decode() - scalar context, void argument\n\n$sv = url_decode();\nis( $sv, undef, 'url_decode(), 1' );\n\n# url_decode() - scalar context, valid argument\n\nmy ( $string, $enc_string );\nfor ( 32 .. 255 ) {\n  $string .= chr;\n  $enc_string .= uc sprintf \"%%%02x\", ord chr;\n}\nis( url_decode( $enc_string ), $string, 'url_decode(\\$enc_string), 1' );\n\n# url_encode() - scalar context, void argument\n\n$sv = url_encode();\nis( $sv, undef, 'url_encode(), 1' );\n\n# url_encode() - scalar context, valid argument\n\n$sv = url_encode( $string );\n$sv =~ tr/+/ /;\n$sv =~ s/%([a-fA-F0-9]{2})/ pack \"C\", hex $1 /eg;\nis( $sv, $string, 'url_encode(\\$string), 1' );\n\n# url encoding - circular test\n\nis( url_decode( $q->url_encode( $string ) ),\n  $string, 'url encoding via circular test, 1' );\n\n# new() plain constructor\n\nrestore_parameters();\nlike( _cgi_object(), qr/CGI::Simple/, 'new() plain constructor, 1' );\n\n# new() hash constructor\n\nrestore_parameters( { 'foo' => '1', 'bar' => [ 2, 3, 4 ] } );\n@av = param();\n\n# fix OS bug with testing\nis( join( ' ', sort @av ), 'bar foo', 'new() hash constructor, 1' );\nis( param( 'foo' ), 1, 'new() hash constructor, 2' );\nis( param( 'bar' ), 2, 'new() hash constructor, 3' );\n@av = param( 'bar' );\nis( join( '', @av ), 234, 'new() hash constructor, 4' );\nrestore_parameters( 'foo=1&bar=2&bar=3&bar=4' );\nopen FH, \">$tmpfile\", or carp \"Can't create $tmpfile $!\\n\";\nsave_parameters( \\*FH );\n\n#close FH;\n\n# new() query string constructor\n\nrestore_parameters( 'foo=5&bar=6&bar=7&bar=8' );\n@av = param();\nis( join( ' ', @av ), 'foo bar', 'new() query string constructor, 1' );\nis( param( 'foo' ), 5, 'new() query string constructor, 2' );\nis( param( 'bar' ), 6, 'new() query string constructor, 3' );\n@av = param( 'bar' );\nis( join( '', @av ), 678, 'new() query string constructor, 4' );\nopen FH, \">>$tmpfile\", or carp \"Can't append $tmpfile $!\\n\";\nsave_parameters( \\*FH );\nclose FH;\n\n# new() \\@ARGV constructor\n\n$ENV{'REQUEST_METHOD'} = '';\n$CGI::Simple::DEBUG    = 1;\n@ARGV                  = qw( foo=bar\\=baz foo=bar\\&baz );\nrestore_parameters();\nis(\n  join( ' ', param( 'foo' ) ),\n  'bar=baz bar&baz',\n  'new() \\@ARGV constructor, 1'\n);\n$ENV{'REQUEST_METHOD'} = 'GET';\n\n################ The Core Methods ################\n\nrestore_parameters();\n\n# param() - scalar and array context, void argument\n\n$sv = param();\n@av = param();\nis( $sv, '2', 'param() void argument, 1' );\nis( join( ' ', @av ), 'name color', 'param() void argument, 2' );\n\n# param() - scalar and array context, single argument (valid)\n\n$sv = param( 'color' );\n@av = param( 'color' );\nis( $sv, 'red', 'param(\\'color\\') single argument (valid), 1' );\nis(\n  join( ' ', @av ),\n  'red green blue',\n  'param(\\'color\\') single argument (valid), 2'\n);\n\n# param() - scalar and array context, single argument (invalid)\n\n$sv = param( 'invalid' );\n@av = param( 'invalid' );\nis( $sv, undef, 'param(\\'invalid\\') single argument (invalid), 1' );\nis( join( ' ', @av ),\n  '', 'param(\\'invalid\\') single argument (invalid), 2' );\n\n# param() - scalar and array context, -name=>'param' (valid)\n\n$sv = param( -name => 'color' );\n@av = param( -name => 'color' );\nis( $sv, 'red', 'param( -name=>\\'color\\' ) get values, 1' );\nis(\n  join( ' ', @av ),\n  'red green blue',\n  'param( -name=>\\'color\\' ) get values, 2'\n);\n\n# param() - scalar and array context, -name=>'param' (invalid)\n\n$sv = param( -name => 'invalid' );\n@av = param( -name => 'invalid' );\nis( $sv, undef, 'param( -name=>\\'invalid\\' ) get values, 1' );\nis( join( ' ', @av ), '', 'param( -name=>\\'invalid\\' ) get values, 2' );\n\n# param() - scalar and array context, set values\n\n$sv = param( 'foo', 'some', 'new', 'values' );\n@av = param( 'foo', 'some', 'new', 'values' );\nis( $sv, 'some',\n  'param( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'some new values',\n  'param( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 2'\n);\n\n# param() - scalar and array context\n\n$sv = param( -name => 'foo', -value => 'bar' );\n@av = param( -name => 'foo', -value => 'bar' );\nis( $sv, 'bar',\n  'param( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 1' );\nis( join( ' ', @av ),\n  'bar', 'param( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 2' );\n\n# param() - scalar and array context\n\n$sv = param( -name => 'foo', -value => [ 'bar', 'baz' ] );\n@av = param( -name => 'foo', -value => [ 'bar', 'baz' ] );\nis( $sv, 'bar',\n  'param(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 1' );\nis( join( ' ', @av ),\n  'bar baz',\n  'param(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 2' );\n\n# add_param() - scalar and array context, void argument\n\n$sv = add_param();\n@av = add_param();\nis( $sv, undef, 'add_param(), 1' );\nis( join( ' ', @av ), '', 'add_param(), 2' );\n\n# add_param() - scalar and array context, existing param argument\n\nadd_param( 'foo', 'new' );\n@av = param( 'foo' );\nis( join( ' ', @av ),\n  'bar baz new', 'add_param( \\'foo\\', \\'new\\' ), 1' );\nadd_param( 'foo', [ 1, 2, 3, 4, 5 ] );\n@av = param( 'foo' );\nis(\n  join( ' ', @av ),\n  'bar baz new 1 2 3 4 5',\n  'add_param( \\'foo\\', \\'new\\' ), 2'\n);\n\n# add_param() - existing param argument, overwrite\n\nadd_param( 'foo', 'bar', 'overwrite' );\n@av = param( 'foo' );\nis( join( ' ', @av ),\n  'bar', 'add_param(\\'foo\\', \\'bar\\', \\'overwrite\\' ), 1' );\n\n# add_param() - scalar and array context, existing param argument\n\nadd_param( 'new', 'new%2C' );\n@av = param( 'new' );\nis( join( ' ', @av ), 'new%2C', 'add_param(  \\'new\\', \\'new\\'  ), 1' );\nadd_param( 'new', [ 1, 2, 3, 4, 5 ] );\n@av = param( 'new' );\nis(\n  join( ' ', @av ),\n  'new%2C 1 2 3 4 5',\n  'add_param(  \\'new\\', \\'new\\'  ), 2'\n);\n\n# param_fetch() - scalar context, void argument\n\n$sv = param_fetch();\nis( $sv, undef, 'param_fetch(), 1' );\n\n# param_fetch() - scalar context, 'color' syntax\n\n$sv = param_fetch( 'color' );\nis( ref $sv, 'ARRAY', 'param_fetch( \\'color\\' ), 1' );\nis( join( ' ', @$sv ), 'red green blue',\n  'param_fetch( \\'color\\' ), 2' );\n\n# param_fetch() - scalar context, -name=>'color' syntax\n\n$sv = param_fetch( -name => 'color' );\nis( ref $sv, 'ARRAY', 'param_fetch( -name=>\\'color\\' ), 1' );\nis(\n  join( ' ', @$sv ),\n  'red green blue',\n  'param_fetch( -name=>\\'color\\' ), 2'\n);\n\n# url_param() - scalar and array context, void argument\n\n$sv = url_param();\n@av = url_param();\nis( $sv, '2', 'url_param() void argument, 1' );\nis( join( ' ', @av ), 'name color', 'url_param() void argument, 2' );\n\n# url_param() - scalar and array context, single argument (valid)\n\n$sv = url_param( 'color' );\n@av = url_param( 'color' );\nis( $sv, 'red', 'url_param(\\'color\\') single argument (valid), 1' );\nis(\n  join( ' ', @av ),\n  'red green blue',\n  'url_param(\\'color\\') single argument (valid), 2'\n);\n\n# url_param() - scalar and array context, single argument (invalid)\n\n$sv = url_param( 'invalid' );\n@av = url_param( 'invalid' );\nis( $sv, undef, 'url_param(\\'invalid\\') single argument (invalid), 1' );\nis( join( ' ', @av ),\n  '', 'url_param(\\'invalid\\') single argument (invalid), 2' );\n\n# keywords() - scalar and array context, void argument\n\n$ENV{'QUERY_STRING'} = 'here+are++++some%20keywords';\nrestore_parameters();\n$sv = keywords();\n@av = keywords();\nis( $sv, '4', 'keywords(), 1' );\nis( join( ' ', @av ), 'here are some keywords', 'keywords(), 2' );\n$ENV{'QUERY_STRING'} = 'name=JaPh%2C&color=red&color=green&color=blue';\n\n# keywords() - scalar and array context, array argument\n\n$sv = keywords( 'foo', 'bar', 'baz' );\n@av = keywords( 'foo', 'bar', 'baz' );\nis( $sv, '3', 'keywords( \\'foo\\', \\'bar\\', \\'baz\\' ), 1' );\nis( join( ' ', @av ),\n  'foo bar baz', 'keywords( \\'foo\\', \\'bar\\', \\'baz\\' ), 2' );\n\n# keywords() - scalar and array context, array ref argument\n\nrestore_parameters();\n$sv = keywords( [ 'foo', 'man', 'chu' ] );\n@av = keywords( [ 'foo', 'man', 'chu' ] );\nis( $sv, '3', 'keywords( [\\'foo\\', \\'man\\', \\'chu\\'] ), 1' );\nis( join( ' ', @av ),\n  'foo man chu', 'keywords( [\\'foo\\', \\'man\\', \\'chu\\'] ), 2' );\n\n# Vars() - scalar and array context, void argument\n\n$sv = Vars();\nmy %hv = Vars();\nis( $sv->{'color'}, \"red\\0green\\0blue\", 'Vars(), 1' );\nis( $hv{'name'},    'JaPh,',            'Vars(), 2' );\n\n# Vars() - hash context, \"|\" argument\n\n%hv = Vars( '|' );\nis( $hv{'color'}, 'red|green|blue', 'Vars(\\'|\\'), 1' );\n\n# append() - scalar and array context, void argument\n\n$sv = append();\n@av = append();\nis( $sv, undef, 'append(), 1' );\nis( join( '', @av ), '', 'append(), 2' );\n\n# append() - scalar and array context, set values, valid param\n\nadd_param( 'foo', 'bar', 'overwrite' );\n$sv = append( 'foo', 'some' );\n@av = append( 'foo', 'some-more' );\nis( $sv, 'bar', 'append( \\'foo\\', \\'some\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more',\n  'append( \\'foo\\', \\'some\\' ) set values, 2'\n);\n\n# append() - scalar and array context, set values, non-existant param\n\n$sv = append( 'invalid', 'param1' );\n@av = append( 'invalid', 'param2' );\nis( $sv, 'param1', 'append( \\'invalid\\', \\'param\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'param1 param2',\n  'append( \\'invalid\\', \\'param\\' ) set values, 2'\n);\nis(\n  join( ' ', param( 'invalid' ) ),\n  'param1 param2',\n  'append( \\'invalid\\', \\'param\\' ) set values, 3'\n);\n\n# append() - scalar and array context, set values\n\n$sv = append( 'foo', 'some', 'new',  'values' );\n@av = append( 'foo', 'even', 'more', 'stuff' );\nis( $sv, 'bar',\n  'append( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more some new values even more stuff',\n  'append( \\'foo\\', \\'some\\', \\'new\\', \\'values\\' ) set values, 2'\n);\n\n# append() - scalar and array context\n\n$sv = append( -name => 'foo', -value => 'baz' );\n@av = append( -name => 'foo', -value => 'xyz' );\nis( $sv, 'bar',\n  'append( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more some new values even more stuff baz xyz',\n  'append( -name=>\\'foo\\', -value=>\\'bar\\' ) set values, 2'\n);\n\n# append() - scalar and array context\n\n$sv = append( -name => 'foo', -value => [ 1, 2 ] );\n@av = append( -name => 'foo', -value => [ 3, 4 ] );\nis( $sv, 'bar',\n  'append(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 1' );\nis(\n  join( ' ', @av ),\n  'bar some some-more some new values even more stuff baz xyz 1 2 3 4',\n  'append(-name=>\\'foo\\',-value=>[\\'bar\\',\\'baz\\']) set values, 2'\n);\n\n# delete() - void/valid argument\n\nDelete();\nis( join( ' ', param() ), 'name color foo invalid', 'delete(), 1' );\nDelete( 'foo' );\nis( join( ' ', param() ), 'name color invalid', 'delete(), 2' );\n\n# Delete() - void/valid argument\n\nDelete();\nis( join( ' ', param() ), 'name color invalid', 'Delete(), 1' );\nDelete( 'invalid' );\nis( join( ' ', param() ), 'name color', 'Delete(), 2' );\n\n# delete_all() - scalar and array context, void/invalid/valid argument\n\ndelete_all();\nis( join( '', param() ), '', 'delete_all(), 1' );\nis( globals(), '11', 'delete_all(), 2' );\n\nrestore_parameters();\n\n# delete_all() - scalar and array context, void/invalid/valid argument\n\nis( join( ' ', param() ), 'name color', 'Delete_all(), 1' );\nDelete_all();\nis( join( '', param() ), '', 'Delete_all(), 2' );\n\n$ENV{'CONTENT_TYPE'} = 'multipart/form-data';\n\n# upload() - scalar and array context, void/invalid/valid argument\n\n$sv = upload();\n@av = upload();\nis( $sv, undef, 'upload() - no files available, 1' );\nis( join( ' ', @av ), '', 'upload() - no files available, 2' );\n\n# upload() - scalar and array context, files available, void arg\n\n$q = _cgi_object();\n$q->{'.filehandles'}->{$_} = $_ for qw( File1 File2 File3 );\n$sv                        = upload();\n@av                        = upload();\nis( $sv, 3, 'upload() - files available, 1' );\nis(\n  join( ' ', sort @av ),\n  'File1 File2 File3',\n  'upload() - files available, 2'\n);\n$q->{'.filehandles'} = {};\n\n# upload() - scalar context, valid argument\n\nopen FH, $tmpfile or carp \"Can't read $tmpfile $!\\n\";\nmy $data = join '', <FH>;\nis( $data && 1, 1, 'upload(\\'/some/path/to/myfile\\') - real files, 1' )\n ;    # make sure we have data\nseek FH, 0, 0;\n$q->{'.filehandles'}->{'/some/path/to/myfile'} = \\*FH;\nmy $handle = upload( '/some/path/to/myfile' );\nmy $upload = join '', <$handle>;\nis( $upload, $data,\n  'upload(\\'/some/path/to/myfile\\') - real files, 2' );\n\n# upload() - scalar context, invalid argument\n\n$sv = upload( 'invalid' );\nis( $sv, undef, 'upload(\\'invalid\\'), 1' );\nis( cgi_error,\n  \"No filehandle for 'invalid'. Are uploads enabled (\\$DISABLE_UPLOADS = 0)? Is \\$POST_MAX big enough?\",\n  'upload(\\'invalid\\'), 2'\n);\n\nmy $ok = upload( '/some/path/to/myfile', \"$tmpfile.bak\" );\nis( $ok, 1, 'upload( \\'/some/path/to/myfile\\', \\, 1' );\nopen $handle, \"$tmpfile.bak\" or carp \"Can't read $tmpfile.bak $!\\n\";\n$upload = join '', <$handle>;\nis( $upload, $data, 'upload( \\'/some/path/to/myfile\\', \\, 2' );\n$sv = upload( '/some/path/to/myfile', \"$tmpfile.bak\" );\nis( $sv, undef, 'upload( \\'/some/path/to/myfile\\', \\, 3' );\nunlink $tmpfile, \"$tmpfile.bak\";\n\n$ENV{'CONTENT_TYPE'} = 'application/x-www-form-urlencoded';\n\nrestore_parameters();\n\n# query_string() - scalar and array context, void/invalid/valid argument\n\n$sv = query_string();\nis(\n  $sv,\n  'name=JaPh%2C&color=red&color=green&color=blue',\n  'query_string(), 1'\n);\n\n# parse_query_string()\n\ndelete_all();\nis( param(), 0, 'parse_query_string(), 1' );\n$ENV{'REQUEST_METHOD'} = 'POST';\nparse_query_string();\n$sv = query_string();\nis(\n  $sv,\n  'name=JaPh%2C&color=red&color=green&color=blue',\n  'parse_query_string(), 2'\n);\n$ENV{'REQUEST_METHOD'} = 'GET';\n\n# parse_keywordlist() - scalar and array context\n\n$sv = parse_keywordlist( 'Just+another++Perl%20hacker%2C' );\n@av = parse_keywordlist( 'Just+another++Perl%20hacker%2C' );\nis( $sv, '4', 'parse_keywordlist(), 1' );\nis(\n  join( ' ', @av ),\n  'Just another Perl hacker,',\n  'parse_keywordlist(), 2'\n);\n\n################ Save and Restore params from file ###############\n\n# _init_from_file()\n# save() - scalar and array context, void/invalid/valid argument\n# save_parameters() - scalar and array context, void/invalid/valid argument\n\n# all tested in constructor section\n\n################ Miscelaneous Methods ################\n\nrestore_parameters();\n\n# escapeHTML()\n\n$sv = escapeHTML();\nis( $sv, undef, 'escapeHTML(), 1' );\n$sv = escapeHTML( \"<>&\\\"\\012\\015<>&\\\"\\012\\015\", 0 );\nis(\n  $sv,\n  \"&lt;&gt;&amp;&quot;\\012\\015&lt;&gt;&amp;&quot;\\012\\015\",\n  'escapeHTML(), 2'\n);\n$sv = escapeHTML( \"<>&\\\"\\012\\015<>&\\\"\\012\\015\", 'newlines too' );\nis(\n  $sv,\n  \"&lt;&gt;&amp;&quot;&#10;&#13;&lt;&gt;&amp;&quot;&#10;&#13;\",\n  'escapeHTML(), 3'\n);\n\n# unescapeHTML()\n\n$sv = unescapeHTML();\nis( $sv, undef, 'unescapeHTML(), 1' );\n$sv = unescapeHTML(\n  \"&lt;&gt;&amp;&quot;&#10;&#13;&lt;&gt;&amp;&quot;&#10;&#13;\" );\nis( $sv, \"<>&\\\"\\012\\015<>&\\\"\\012\\015\", 'unescapeHTML(), 2' );\n\n# put()\n\nis( put( '' ), 1, 'put(), 1' );\n\n# print()\n\nis( print( '' ), 1, 'print(), 1' );\n\n################# Cookie Methods ################\n\nrestore_parameters();\n\n# raw_cookie() - scalar and array context, void argument\n\n$sv = raw_cookie();\n@av = raw_cookie();\nis(\n  $sv,\n  'foo=a%20phrase; bar=yes%2C%20a%20phrase&I%20say;',\n  'raw_cookie(), 1'\n);\nis(\n  join( '', @av ),\n  'foo=a%20phrase; bar=yes%2C%20a%20phrase&I%20say;',\n  'raw_cookie(), 2'\n);\n\n# raw_cookie() - scalar and array context, valid argument\n\n$sv = raw_cookie( 'foo' );\n@av = raw_cookie( 'foo' );\nis( $sv, 'a%20phrase', 'raw_cookie(\\'foo\\'), 1' );\nis( join( '', @av ), 'a%20phrase', 'raw_cookie(\\'foo\\'), 2' );\n\n# raw_cookie() - scalar and array context, invalid argument\n\n$sv = raw_cookie( 'invalid' );\n@av = raw_cookie( 'invalid' );\nis( $sv, undef, 'raw_cookie(\\'invalid\\'), 1' );\nis( join( '', @av ), '', 'raw_cookie(\\'invalid\\'), 2' );\n\n# cookie() - scalar and array context, void argument\n\n$sv = cookie();\n@av = cookie();\nis( $sv, '2', 'cookie(), 1' );\n\n# fix OS perl version test bug\nis( join( ' ', sort @av ), 'bar foo', 'cookie(), 2' );\n\n# cookie() - scalar and array context, valid argument, single value\n\n$sv = cookie( 'foo' );\n@av = cookie( 'foo' );\nis( $sv, 'a phrase', 'cookie(\\'foo\\'), 1' );\nis( join( '', @av ), 'a phrase', 'cookie(\\'foo\\'), 2' );\n\n# cookie() - scalar and array context, valid argument, multiple values\n\n$sv = cookie( 'bar' );\n@av = cookie( 'bar' );\nis( $sv, 'yes, a phrase', 'cookie(\\'foo\\'), 1' );\nis( join( ' ', @av ), 'yes, a phrase I say', 'cookie(\\'foo\\'), 2' );\n\n# cookie() - scalar and array context, invalid argument\n\n$sv = cookie( 'invalid' );\n@av = cookie( 'invalid' );\nis( $sv, undef, 'cookie(\\'invalid\\'), 1' );\nis( join( '', @av ), '', 'cookie(\\'invalid\\'), 2' );\n\nmy @vals = (\n  -name     => 'Password',\n  -value    => [ 'superuser', 'god', 'open sesame', 'mydog woofie' ],\n  -expires  => 'Mon, 11-Nov-2018 11:00:00 GMT',\n  -domain   => '.nowhere.com',\n  -path     => '/cgi-bin/database',\n  -secure   => 1,\n  -httponly => 1\n);\n\n# cookie() - scalar and array context, full argument set, correct order\n\n$sv = cookie( @vals );\n@av = cookie( @vals );\nis(\n  $sv,\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) correct order, 1'\n);\nis(\n  join( '', @av ),\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) correct order, 2'\n);\n\n# cookie() - scalar and array context, full argument set, incorrect order\n\n$sv = cookie( @vals[ 0, 1, 10, 11, 12, 13, 8, 9, 2, 3, 4, 5, 6, 7 ] );\n@av = cookie( @vals[ 0, 1, 10, 11, 12, 13, 8, 9, 2, 3, 4, 5, 6, 7 ] );\nis(\n  $sv,\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) incorrect order, 1'\n);\nis(\n  join( '', @av ),\n  'Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly',\n  'cookie(\\@vals) incorrect order, 2'\n);\nmy $cookie = $sv;    # save a cookie for header testing\n\n# cookie() - scalar and array context, partial argument set\n\n$sv = cookie( -name => 'foo', -value => 'bar' );\n@av = cookie( -name => 'foo', -value => 'bar' );\nis(\n  $sv,\n  'foo=bar; path=/',\n  'cookie( -name=>\\'foo\\', -value=>\\'bar\\' ), 1'\n);\nis(\n  join( '', @av ),\n  'foo=bar; path=/',\n  'cookie( -name=>\\'foo\\', -value=>\\'bar\\' ), 2'\n);\n\n################# Header Methods ################\n\n$q = new CGI::Simple\n\n my $CRLF = crlf();\n\n# header() - scalar and array context, void argument\n\n$sv = header();\n@av = header();\nis( $sv, \"Content-Type: text/html; charset=ISO-8859-1$CRLF$CRLF\",\n  'header(), 1' );\nis(\n  join( '', @av ),\n  \"Content-Type: text/html; charset=ISO-8859-1$CRLF$CRLF\",\n  'header(), 2'\n);\n\n# header() - scalar context, single argument\n\n$sv = header( 'image/gif' );\nis(\n  $sv,\n  \"Content-Type: image/gif$CRLF$CRLF\",\n  'header(\\'image/gif\\'), 1'\n);\n\n@vals = (\n  -type       => 'image/gif',\n  -nph        => 1,\n  -status     => '402 Payment required',\n  -expires    => 'Mon, 11-Nov-2018 11:00:00 GMT',\n  -cookie     => $cookie,\n  -charset    => 'utf-7',\n  -attachment => 'foo.gif',\n  -Cost       => '$2.00'\n);\n\n# header() - scalar context, complex header\n\n$sv = header( @vals );\nmy $header = <<'HEADER';\nHTTP/1.0 402 Payment required\nServer: Apache - accept no substitutes\nStatus: 402 Payment required\nSet-Cookie: Password=superuser&god&open%20sesame&mydog%20woofie; domain=.nowhere.com; path=/cgi-bin/database; expires=Mon, 11-Nov-2018 11:00:00 GMT; secure; HttpOnly\nExpires: Mon, 11-Nov-2018 11:00:00 GMT\nDate: Tue, 11-Nov-2018 11:00:00 GMT\nContent-Disposition: attachment; filename=\"foo.gif\"\nCost: $2.00\nContent-Type: image/gif\nHEADER\n$sv     =~ s/[\\012\\015]//g;\n$header =~ s/[\\012\\015]//g;\n$sv     =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\n$header =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\nis( $sv, $header, 'header(\\@vals) - complex header, 1' );\n\n# cache() - scalar and array context, void argument\n\n$sv = cache();\nis( $sv, undef, 'cache(), 1' );\n\n# cache() - scalar and array context, true argument, sets no cache paragma\n\n$sv = cache( 1 );\nis( $sv, 1, 'cache(1), 1' );\n$sv = header();\nis( $sv =~ /Pragma: no-cache/, 1, 'cache(1), 2' );\n\n# no_cache() - scalar and array context, void argument\n\n$sv = no_cache();\nis( $sv, undef, 'cache(), 1' );\n\n# no_cache() - scalar and array context, true argument, sets no cache paragma\n\n$sv = no_cache( 1 );\nis( $sv, 1, 'cache(1), 1' );\n$sv = header();\nis(\n  (\n         $sv =~ /Pragma: no-cache/\n     and $sv =~ /Expires:(.*?)GMT/\n     and $sv =~ /Date:$1GMT/\n  ),\n  1,\n  'cache(1), 2'\n);\n\n# redirect() - scalar and array context, void argument\n\n$sv     = redirect( 'http://a.galaxy.far.away.gov' );\n$header = <<'HEADER';\nStatus: 302 Moved\nExpires: Tue, 13 Nov 2001 06:45:15 GMT\nDate: Tue, 13 Nov 2001 06:45:15 GMT\nPragma: no-cache\nLocation: http://a.galaxy.far.away.gov\nHEADER\n$sv     =~ s/[\\012\\015]//g;\n$header =~ s/[\\012\\015]//g;\n$sv     =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\n$header =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\nis( $sv, $header, 'redirect(), 1' );\n\n# redirect() - scalar and array context, void argument\n\n$sv = redirect( -uri => 'http://a.galaxy.far.away.gov', -nph => 1 );\n$header = <<'HEADER';\nHTTP/1.0 302 Moved\nServer: Apache - accept no substitutes\nStatus: 302 Moved\nExpires: Tue, 13 Nov 2001 06:49:24 GMT\nDate: Tue, 13 Nov 2001 06:49:24 GMT\nPragma: no-cache\nLocation: http://a.galaxy.far.away.gov\nHEADER\n$sv     =~ s/[\\012\\015]//g;\n$header =~ s/[\\012\\015]//g;\n$sv     =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\n$header =~ s/(?:Expires|Date).*?GMT//g;    # strip the time elements\nis( $sv, $header, 'redirect() - nph, 1' );\n\n################# Server Push Methods #################\n\nrestore_parameters();\n\n$sv = multipart_init();\nlike(\n  $sv,\n  qr|Content-Type: multipart/x-mixed-replace;boundary=\"------- =_[a-zA-Z0-9]{17}\"|,\n  'multipart_init(), 1'\n);\n\nlike( $sv, qr/--------- =_[a-zA-Z0-9]{17}$CRLF/,\n  'multipart_init(), 2' );\n$sv = multipart_init( 'this_is_the_boundary' );\nlike( $sv, qr/boundary=\"this_is_the_boundary\"/, 'multipart_init(), 3' );\n$sv = multipart_init( -boundary => 'this_is_another_boundary' );\nlike(\n  $sv,\n  qr/boundary=\"this_is_another_boundary\"/,\n  'multipart_init(), 4'\n);\n\n# multipart_start()\n\n$sv = multipart_start();\nis( $sv, \"Content-Type: text/html$CRLF$CRLF\", 'multipart_start(), 1' );\n$sv = multipart_start( 'foo/bar' );\nis( $sv, \"Content-Type: foo/bar$CRLF$CRLF\", 'multipart_start(), 2' );\n$sv = multipart_start( -type => 'text/plain' );\nis( $sv, \"Content-Type: text/plain$CRLF$CRLF\", 'multipart_start(), 3' );\n\n# multipart_end()\n\n$sv = multipart_end();\nis( $sv, \"$CRLF--this_is_another_boundary$CRLF\", 'multipart_end(), 1' );\n\n# multipart_final() - scalar and array context, void/invalid/valid argument\n\n$sv = multipart_final();\nlike( $sv, qr|--this_is_another_boundary--|, 'multipart_final(), 1' );\n\n################# Debugging Methods ################\n\n# Dump() - scalar context, void argument\n\n$sv = Dump();\nis( $sv =~ m/JaPh,/, 1, 'Dump(), 1' );\n\n# as_string()\n\nis( as_string(), Dump(), 'as_string(), 1' );\n\n# cgi_error()\n\n$ENV{'REQUEST_METHOD'} = 'GET';\n$ENV{'QUERY_STRING'}   = '';\nrestore_parameters();\n\n# changed this behaviour\n# like( cgi_error(), qr/400 No data received via method: GET/ , 'cgi_error(), 1');\nis( cgi_error(), undef, 'cgi_error(), 2' );\n$ENV{'QUERY_STRING'} = 'name=JaPh%2C&color=red&color=green&color=blue';\n\n############## cgi-lib.pl tests ################\n\n# ReadParse() - scalar and array context, void/invalid/valid argument\n\nrestore_parameters();\nReadParse();\n\n#ok ( $in{'name'}, 'JaPh,' );\nrestore_parameters();\nReadParse( *field );\nis( $field{'name'}, 'JaPh,', 'ReadParse(), 1' );\n\n# SplitParam() - scalar and array context, void/invalid/valid argument\n\nis(\n  join( ' ', SplitParam( $field{'color'} ) ),\n  'red green blue',\n  'SplitParam(), 1'\n);\nis( scalar SplitParam( $field{'color'} ), 'red', 'SplitParam(), 2' );\n\n# MethGet() - scalar and array context, void/invalid/valid argument\n\nis( MethGet(), 1, 'MethGet(), 1' );\n\n# MethPost() - scalar and array context, void/invalid/valid argument\n\nis( !MethPost(), 1, 'MethPost(), 1' );\n\n# MyBaseUrl() - scalar and array context, void/invalid/valid argument\n\nis(\n  MyBaseUrl(),\n  'http://nowhere.com:8080/cgi-bin/foo.cgi',\n  'MyBaseUrl(), 1'\n);\n$ENV{'SERVER_PORT'} = 80;\nis(\n  MyBaseUrl(),\n  'http://nowhere.com/cgi-bin/foo.cgi',\n  'MyBaseUrl(), 2'\n);\n$ENV{'SERVER_PORT'} = 8080;\n\n# MyURL() - scalar and array context, void/invalid/valid argument\n\nis( MyURL(), 'http://nowhere.com:8080/cgi-bin/foo.cgi', 'MyURL(), 1' );\n\n# MyFullUrl() - scalar and array context, void/invalid/valid argument\n\nis(\n  MyFullUrl(),\n  'http://nowhere.com:8080/cgi-bin/foo.cgi/somewhere/else?name=JaPh%2C&color=red&color=green&color=blue',\n  'MyFullUrl(), 1'\n);\n$ENV{'QUERY_STRING'} = '';\n$ENV{'PATH_INFO'}    = '';\nis(\n  MyFullUrl(),\n  'http://nowhere.com:8080/cgi-bin/foo.cgi',\n  'MyFullUrl(), 2'\n);\n$ENV{'QUERY_STRING'} = 'name=JaPh%2C&color=red&color=green&color=blue';\n$ENV{'PATH_INFO'}    = '/somewhere/else';\n\n# PrintHeader() - scalar and array context, void/invalid/valid argument\n\nlike( PrintHeader(), qr|Content-Type: text/html|, 'PrintHeader(), 1' );\n\n# HtmlTop() - scalar and array context, void/invalid/valid argument\n\nis(\n  HtmlTop( '$' ),\n  \"<html>\\n<head>\\n<title>\\$</title>\\n</head>\\n<body>\\n<h1>\\$</h1>\\n\",\n  'HtmlTop(), 1'\n);\n\n# HtmlBot() - scalar and array context, void/invalid/valid argument\n\nis( HtmlBot(), \"</body>\\n</html>\\n\", 'HtmlBot(), 1' );\n\n# PrintVariables() - scalar and array context, void/invalid/valid argument\n\nlike( PrintVariables( \\%field ), qr/JaPh,/, 'PrintVariables(), 1' );\n\n# PrintEnv() - scalar and array context, void/invalid/valid argument\n\nlike( PrintEnv(), qr/PATH_TRANSLATED/, 'PrintEnv(), 1' );\n\n# CgiDie() - scalar and array context, void/invalid/valid argument\n\n# CgiError() - scalar and array context, void/invalid/valid argument\n\n################ Accessor Methods ################\n\nrestore_parameters();\n\n# version() - scalar context, void argument\n\nlike( version(), qr/[\\d\\.]+/, 'version(), 1' );\n\n# nph() - scalar context, void  argument\n\nis( nph(), globals( 'NPH' ), 'nph(), 1' );\n\n# nph() - scalar context, valid  argument\n\nis( nph( 42 ),        42, 'nph(42), 1' );\nis( globals( 'NPH' ), 42, 'nph(42), 2' );\n\n# all_parameters() - array context, void/invalid/valid argument\n\n$sv = all_parameters();\n@av = all_parameters();\nis( $sv, 2, 'all_parameters(), 1' );\nis( join( ' ', @av ), 'name color', 'all_parameters(), 2' );\n\n# charset() - scalar context, void argument\n\n$sv = charset();\nis( $sv, 'utf-7', 'charset(), 1' )\n ;    # should remain reset to this from header method\n\n# charset() - scalar context, void argument\n\n$sv = charset( 'Linear B' );\nis( $sv, 'Linear B', 'charset(), 1' );\n$sv = charset();\nis( $sv, 'Linear B', 'charset(), 2' );\n\n# crlf() - scalar context, void argument\n\n$sv = crlf();\nlike( $sv, qr/[\\012\\015]{1,2}/, 'crlf(), 1' );\n\n# globals() - scalar and array context, void argument\n\n$sv = globals();\nis( $sv, 11, 'globals(), 1' );\n@av = globals();\nis(\n  join( ' ', sort @av ),\n  'DEBUG DISABLE_UPLOADS FATAL HEADERS_ONCE NO_NULL NO_UNDEF_PARAMS NPH PARAM_UTF8 POST_MAX USE_CGI_PM_DEFAULTS USE_PARAM_SEMICOLONS',\n  'globals(), 2'\n);\n\n# globals() - scalar context, invalid argument\n\n$sv = globals( 'FOO' );\nis( $sv, undef, 'globals(\\'FOO\\') - invalid arg, 1' );\n\n# globals() - scalar context, valid argument\n\nis( globals( 'VERSION', '3.1415' ),\n  '3.1415', 'globals(\\'VERSION\\') - valid arg, 1' );\nis( globals( 'VERSION' ),\n  '3.1415', 'globals(\\'VERSION\\') - valid arg, 2' );\n\n# auth_type() - scalar context, void argument\n\n$sv = auth_type();\nis( $sv, 'PGP MD5 DES rot13', 'auth_type(), 1' );\n\n# content_length() - scalar context, void argument\n\n$sv = content_length();\nis( $sv, '42', 'content_length(), 1' );\n\n# content_type() - scalar context, void argument\n\n$sv = content_type();\nis( $sv, 'application/x-www-form-urlencoded', 'content_type(), 1' );\n\n# document_root() - scalar context, void argument\n\n$sv = document_root();\nis( $sv, '/vs/www/foo', 'document_root(), 1' );\n\n# gateway_interface() - scalar context, void argument\n\n$sv = gateway_interface();\nis( $sv, 'bleeding edge', 'gateway_interface(), 1' );\n\n# path_translated() - scalar context, void argument\n\n$sv = path_translated();\nis( $sv, '/usr/local/somewhere/else', 'path_translated(), 1' );\n\n# referer() - scalar context, void argument\n\n$sv = referer();\nis( $sv, 'xxx.sex.com', 'referer(), 1' );\n\n# remote_addr() - scalar and array context, void/invalid/valid argument\n\n$sv = remote_addr();\nis( $sv, '127.0.0.1', 'remote_addr(), 1' );\n\n# remote_host() - scalar context, void argument\n\n$sv = remote_host();\nis( $sv, 'localhost', 'remote_host(), 1' );\n\n# remote_ident() - scalar context, void argument\n\n$sv = remote_ident();\nis( $sv, 'None of your damn business', 'remote_ident(), 1' );\n\n# remote_user() - scalar context, void argument\n\n$sv = remote_user();\nis( $sv, 'Just another Perl hacker,', 'remote_user(), 1' );\n\n# request_method() - scalar context, void argument\n\n$sv = request_method();\nis( $sv, 'GET', 'request_method(), 1' );\n\n# script_name() - scalar context, void argument\n\n$sv = script_name();\nis( $sv, '/cgi-bin/foo.cgi', 'script_name(), 1' );\n\n# server_name() - scalar context, void argument\n\n$sv = server_name();\nis( $sv, 'nowhere.com', 'server_name(), 1' );\n\n# server_port() - scalar context, void argument\n\n$sv = server_port();\nis( $sv, '8080', 'server_port(), 1' );\n\n# server_protocol() - scalar context, void argument\n\n$sv = server_protocol();\nis( $sv, 'HTTP/1.0', 'server_protocol(), 1' );\n\n# server_software() - scalar context, void argument\n\n$sv = server_software();\nis( $sv, 'Apache - accept no substitutes', 'server_software(), 1' );\n\n# user_name() - scalar context, void argument\n\n$sv = user_name();\nis( $sv, 'spammer@nowhere.com', 'user_name(), 1' );\n\n# user_agent() - scalar context, void argument\n\n$sv = user_agent();\nis( $sv, 'LWP', 'user_agent(), 1' );\n\n# user_agent() - scalar context, void argument\n\n$sv = user_agent( 'lwp' );\nis( $sv, 1, 'user_agent(), 1' );\n$sv = user_agent( 'mozilla' );\nis( $sv, '', 'user_agent(), 2' );\n\n# virtual_host() - scalar context, void argument\n\n$sv = virtual_host();\nis( $sv, 'the.vatican.org', 'virtual_host(), 1' );\n\n# path_info() - scalar and array context, void/valid argument\n\n$sv = path_info();\nis( $sv, '/somewhere/else', 'path_info(), 1' );\n$sv = path_info( 'somewhere/else/again' );\nis( $sv, '/somewhere/else/again', 'path_info(), 2' );\n$sv = path_info();\nis( $sv, '/somewhere/else/again', 'path_info(), 3' );\npath_info( '/somewhere/else' );\n\n# Accept() - scalar and array context, void argument\n\n$sv = Accept();\n@av = Accept();\nis( $sv, 5, 'Accept(), 1' );\nis(\n  join( ' ', sort @av ),\n  '*/* image/gif image/jpg text/html text/plain',\n  'Accept(), 2'\n);\n\n# Accept() - scalar context, invalid argument (matches '*/*'\n\n$sv = Accept( 'foo/bar' );\nis( $sv, '0.001', 'Accept(\\'foo/bar\\'), 1' );\n\n# Accept() - scalar and array context, void argument\n\n$sv = Accept( '*/*' );\nis( $sv, '0.001', 'Accept(), 1' );\n\n# http() - scalar and array context, void argument\n\n$sv = http();\n@av = http();\nok( $sv > 0, 'http(), 1' );\nlike( $av[0], qr/HTTP/, 'http(), 2' );\n\n# http() - scalar context, invalid arguments\n\n$sv = http( 'http-hell' );\nis( $sv, undef, 'http(\\'invalid arg\\'), 1' );\n$sv = http( 'hell' );\nis( $sv, undef, 'http(\\'invalid arg\\'), 2' );\n\n# http() - scalar context, valid arguments\n\n$sv = http( 'http-from' );\nis( $sv, 'spammer@nowhere.com', 'http(\\'valid arg\\'), 1' );\n$sv = http( 'from' );\nis( $sv, 'spammer@nowhere.com', 'http(\\'valid arg\\'), 2' );\n\n# https() - scalar and array context, void argument\n\n$sv = https();\nis( $sv, 'ON', 'https(), 1' );\n\n# https() - scalar  context, invalid argument\n\n$sv = https( 'hell' );\nis( $sv, undef, 'https(\\'invalid arg\\'), 1' );\n\n# https() - scalar context, valid arguments\n\n$sv = https( 'https-a' );\nis( $sv, 'A', 'https(\\'valid arg\\'), 1' );\n$sv = https( 'a' );\nis( $sv, 'A', 'https(\\'valid arg\\'), 2' );\n\n# protocol() - scalar context, void arguments\n\n$sv = protocol();\nis( $sv, 'https', 'protocol(), 1' );\n$ENV{'HTTPS'}       = 'OFF';\n$ENV{'SERVER_PORT'} = '443';\n$sv                 = protocol();\nis( $sv, 'https', 'protocol(), 2' );\n$ENV{'SERVER_PORT'} = '8080';\n$sv = protocol();\nis( $sv, 'http', 'protocol(), 3' );\n\n# url() - scalar context, void argument\n\n$ENV{'HTTP_HOST'} = '';\nis( url(), 'http://nowhere.com:8080/cgi-bin/foo.cgi', 'url(), 1' );\n\n# url() - scalar context, valid argument\n\nis( url( -absolute => 1 ),\n  '/cgi-bin/foo.cgi', 'CGI::url(-absolute=>1)' );\n\n# url() - scalar context, valid argument\n\nis( url( -relative => 1 ), 'foo.cgi', 'url(-relative=>1), 1' );\n\n# url() - scalar context, valid argument\n\nis(\n  url( -relative => 1, -path => 1 ),\n  'foo.cgi/somewhere/else',\n  'url(-relative=>1,-path=>1), 1'\n);\n\n# url() - scalar context, valid argument\n\nis(\n  url( -relative => 1, -path => 1, -query => 1 ),\n  'foo.cgi/somewhere/else?name=JaPh%2C&color=red&color=green&color=blue',\n  'url(-relative=>1,-path=>1,-query=>1), 1'\n);\n\n# self_url() - scalar context, void argument\n\n$sv = self_url();\n@av = self_url();\nis(\n  $sv,\n  'http://nowhere.com:8080/cgi-bin/foo.cgi/somewhere/else?name=JaPh%2C&color=red&color=green&color=blue',\n  'self_url(), 1'\n);\n\n# state() - scalar and array context, void/invalid/valid argument\n\nis( state(), self_url(), 'state(), 1' );\n\n################ Yet More Tests ################\n\n#$CGI::Simple::POST_MAX = 20;\n#$ENV{'REQUEST_METHOD'} = 'POST';\n#restore_parameters();\n#ok( cgi_error(), '413 Request entity too large: 42 bytes on STDIN exceeds $POST_MAX!' );\n\n$ENV{'REQUEST_METHOD'} = 'HEAD';\n$ENV{'QUERY_STRING'}   = '';\n$ENV{'REDIRECT_QUERY_STRING'}\n = 'name=JAPH&color=red&color=green&color=blue';\n$CGI::Simple::POST_MAX = 50;\nrestore_parameters();\n@av = param();\nis( join( ' ', @av ), 'name color', 'Yet more tests, 1' );\n@av = param( 'color' );\nis( join( ' ', @av ), 'red green blue', 'Yet more tests, 2' );\n"], "filenames": ["lib/CGI/Simple.pm", "t/050.simple.t", "t/070.standard.t"], "buggy_code_start_loc": [1128, 948, 956], "buggy_code_end_loc": [1129, 952, 960], "fixing_code_start_loc": [1128, 948, 956], "fixing_code_end_loc": [1136, 953, 962], "type": "CWE-94", "message": "The multipart_init function in (1) CGI.pm before 3.50 and (2) Simple.pm in CGI::Simple 1.112 and earlier uses a hardcoded value of the MIME boundary string in multipart/x-mixed-replace content, which allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via crafted input that contains this value, a different vulnerability than CVE-2010-3172.", "other": {"cve": {"id": "CVE-2010-2761", "sourceIdentifier": "cve@mitre.org", "published": "2010-12-06T20:12:58.653", "lastModified": "2016-12-08T03:01:41.227", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The multipart_init function in (1) CGI.pm before 3.50 and (2) Simple.pm in CGI::Simple 1.112 and earlier uses a hardcoded value of the MIME boundary string in multipart/x-mixed-replace content, which allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via crafted input that contains this value, a different vulnerability than CVE-2010-3172."}, {"lang": "es", "value": "La funci\u00f3n multipart_init de (1) CGI.pm en versiones anteriores a la 3.50 y (2) Simple.pm de CGI::Simple 1.112 y versiones anteriores usa un valor est\u00e1tico (\"hardcoded\") en la cadena de l\u00edmite MIME en el contenido multipart/x-mixed-replace. Lo que permite a atacantes remotos inyectar cabeceras HTTP de su elecci\u00f3n y realizar ataques de divisi\u00f3n de respuestas HTTP a trav\u00e9s de una entrada modificada que contiene este valor. Una vulnerabilidad distinta a la CVE-2010-3172."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.49", "matchCriteriaId": "8E20D5E8-10F6-4B3F-907B-5468D3BB4AC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:1.4:*:*:*:*:*:*:*", "matchCriteriaId": "59B846E0-BF7F-4535-ABB0-4A8069E6AAA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:1.42:*:*:*:*:*:*:*", "matchCriteriaId": "37812E3C-0F0B-44ED-B96D-B7160E62E70E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:1.43:*:*:*:*:*:*:*", "matchCriteriaId": "4DF1A898-9663-4C9F-BC31-E3AD28B4388F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:1.44:*:*:*:*:*:*:*", "matchCriteriaId": "27A93905-4CAC-4D11-81A4-E27F1EDB41EA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:1.45:*:*:*:*:*:*:*", "matchCriteriaId": "55275EDA-ECFA-4569-A865-9BFD28BA6B8F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:1.50:*:*:*:*:*:*:*", "matchCriteriaId": "39741EBF-DDE7-41BC-9F72-03AD11F4C9BD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:1.51:*:*:*:*:*:*:*", "matchCriteriaId": "1B4E891E-1B05-48D0-B090-D29B1E5692CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:1.52:*:*:*:*:*:*:*", "matchCriteriaId": "711401D5-C463-4E8B-B194-0717651ACC78"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:1.53:*:*:*:*:*:*:*", "matchCriteriaId": "104FE050-AA99-42F4-AE92-A696A9AA4DE0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:1.54:*:*:*:*:*:*:*", "matchCriteriaId": "6C1D739D-C758-48EB-AF17-492A6304A2BD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:1.55:*:*:*:*:*:*:*", "matchCriteriaId": "B8FE7698-5B36-4E72-A53B-F87AD51EBD2A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:1.56:*:*:*:*:*:*:*", "matchCriteriaId": "09093061-28B6-4FF5-A72B-4F91787986D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:1.57:*:*:*:*:*:*:*", "matchCriteriaId": "6FBF48EA-5977-4849-B240-CBCB045A79E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "5208F25D-AEDA-495E-BF06-4751BD77150B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.01:*:*:*:*:*:*:*", "matchCriteriaId": "D35B9456-70D3-4CF7-A1C4-964455C5208B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.13:*:*:*:*:*:*:*", "matchCriteriaId": "550CAC56-6DF4-43D5-A395-B18CB16B6E81"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.14:*:*:*:*:*:*:*", "matchCriteriaId": "E39631C0-4BE0-4FAB-95D0-663643C5620D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.15:*:*:*:*:*:*:*", "matchCriteriaId": "10B0385D-48F8-465A-9637-4A4A20B3C5A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B0F1850E-390E-4D15-A552-C184B40277C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.17:*:*:*:*:*:*:*", "matchCriteriaId": "09D2CEE1-F3B6-4DA0-9DE3-C6197354CA22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.18:*:*:*:*:*:*:*", "matchCriteriaId": "97E06518-923C-4DA9-8451-2F56E3B3E59A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.19:*:*:*:*:*:*:*", "matchCriteriaId": "8AF5157D-741F-4D0E-AC9D-553A076A1FF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.20:*:*:*:*:*:*:*", "matchCriteriaId": "65CCC4EB-082A-4D31-98D9-22089580DBD9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.21:*:*:*:*:*:*:*", "matchCriteriaId": "FCFF70A8-B425-4D94-825D-FBB743FC8052"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.22:*:*:*:*:*:*:*", "matchCriteriaId": "8C183279-80AE-4FEE-95A3-7B291245A9ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.23:*:*:*:*:*:*:*", "matchCriteriaId": "5988C49D-B070-4CC2-8C25-5E911A7D73A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.24:*:*:*:*:*:*:*", "matchCriteriaId": "EECD86BB-1585-47CA-B797-2A413786799E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.25:*:*:*:*:*:*:*", "matchCriteriaId": "B666488B-412E-4A72-B27B-C8F046D4B49B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.26:*:*:*:*:*:*:*", "matchCriteriaId": "F00BAC21-9C67-489F-8F9B-79275D5F6539"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.27:*:*:*:*:*:*:*", "matchCriteriaId": "3CA274F5-4F9D-40F4-8B0B-3C586A648E80"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.28:*:*:*:*:*:*:*", "matchCriteriaId": "086D53BA-AC97-4DD0-B06F-5713387B3630"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.29:*:*:*:*:*:*:*", "matchCriteriaId": "5CEDB9EB-C840-469E-81F2-BA0C710192E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.30:*:*:*:*:*:*:*", "matchCriteriaId": "2C83539A-F459-4387-A98E-123E56151439"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.31:*:*:*:*:*:*:*", "matchCriteriaId": "223D9CA6-D88C-43A4-8B2E-2F98F56C3AAA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.32:*:*:*:*:*:*:*", "matchCriteriaId": "E153C549-3798-4AEB-B1E8-2BD83F8D1A4E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.33:*:*:*:*:*:*:*", "matchCriteriaId": "5B4FAD39-A275-42D3-84B5-8A798D0075AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.34:*:*:*:*:*:*:*", "matchCriteriaId": "DB45C8C8-9EDD-437D-8514-C380633A9B20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.35:*:*:*:*:*:*:*", "matchCriteriaId": "C3295F4B-064E-455E-9B9E-C671688D8A7A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.36:*:*:*:*:*:*:*", "matchCriteriaId": "E433A072-EBA4-41DC-8FA5-5DA32C2CA0C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.37:*:*:*:*:*:*:*", "matchCriteriaId": "C0179DE4-940E-4A41-8126-7A0AB7C9F28D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.38:*:*:*:*:*:*:*", "matchCriteriaId": "11ED8725-6D73-45F5-B833-13BCC9E2201F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.39:*:*:*:*:*:*:*", "matchCriteriaId": "EFC2D385-9FDD-429E-A9B1-369A175BB229"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.40:*:*:*:*:*:*:*", "matchCriteriaId": "5F7CD8DC-69A6-4EAA-BD91-26370D7BF395"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.41:*:*:*:*:*:*:*", "matchCriteriaId": "FFC8447C-EBCF-4D44-B43C-EC6BD75AC068"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.42:*:*:*:*:*:*:*", "matchCriteriaId": "ED66BCC1-D212-43EE-822F-C2E6BB0B1CB1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.43:*:*:*:*:*:*:*", "matchCriteriaId": "5D53297E-E35B-44B9-A400-E55E5A38B143"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.44:*:*:*:*:*:*:*", "matchCriteriaId": "C43C7BD0-58D6-429A-AC39-CA4CC1A0104D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.45:*:*:*:*:*:*:*", "matchCriteriaId": "21C3E14B-62A3-4146-AF92-43FA0FDCF78E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.46:*:*:*:*:*:*:*", "matchCriteriaId": "F6F37496-4EA4-4A29-BABD-EC572A13CC36"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.47:*:*:*:*:*:*:*", "matchCriteriaId": "9CC6F3E1-3F48-4F5F-BDCA-4FF886A84FF2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.48:*:*:*:*:*:*:*", "matchCriteriaId": "9E2A0FD4-12D6-406E-9173-7132958A2E13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.49:*:*:*:*:*:*:*", "matchCriteriaId": "591591DC-805B-4028-9114-AC1403A3D284"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.50:*:*:*:*:*:*:*", "matchCriteriaId": "5C901B1F-AA91-4AAE-B2C4-1E20B9A453E0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.51:*:*:*:*:*:*:*", "matchCriteriaId": "DD512456-CD6D-44D8-8143-9F4B0B3C7DB3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.52:*:*:*:*:*:*:*", "matchCriteriaId": "B7093E29-50BC-4495-A4C9-02A27F9A0DF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.53:*:*:*:*:*:*:*", "matchCriteriaId": "8F4DE297-5D2D-4244-AD40-3A1BA79391AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.54:*:*:*:*:*:*:*", "matchCriteriaId": "E1213E7E-7C8A-44B2-9B00-971F47088F40"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.55:*:*:*:*:*:*:*", "matchCriteriaId": "2FA2D166-D9C6-49C1-9D75-4D7347507F87"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.56:*:*:*:*:*:*:*", "matchCriteriaId": "8CEEFC9F-7DC7-4FDE-B6B0-0BF0998B9267"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.57:*:*:*:*:*:*:*", "matchCriteriaId": "B5619CC7-051C-4E66-A22D-6AC65965E74D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.58:*:*:*:*:*:*:*", "matchCriteriaId": "92B18751-4419-4ED3-9EE9-9AEA7FE31C69"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.59:*:*:*:*:*:*:*", "matchCriteriaId": "DDBE7139-2263-4B5B-9843-14214E9AAE2A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.60:*:*:*:*:*:*:*", "matchCriteriaId": "F6C27803-6AC0-4CC8-AAD6-447C2BD726B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.61:*:*:*:*:*:*:*", "matchCriteriaId": "94F24B1B-BB10-42CA-BD86-CCC237325BA0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.62:*:*:*:*:*:*:*", "matchCriteriaId": "41054C2C-92C4-4222-8DDC-1B788C7BE4A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.63:*:*:*:*:*:*:*", "matchCriteriaId": "E8D61299-9A05-4800-B3A3-A64977664559"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.64:*:*:*:*:*:*:*", "matchCriteriaId": "0C2EDAEF-B40A-437A-B30A-A5EF9B54752B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.65:*:*:*:*:*:*:*", "matchCriteriaId": "B62273AD-F3FC-4EDA-A3DB-4082C89C27DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.66:*:*:*:*:*:*:*", "matchCriteriaId": "4C07FA63-F744-497D-A251-4491DBA49AC1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.67:*:*:*:*:*:*:*", "matchCriteriaId": "47D4D43B-1347-43B3-980A-44859A1BB8A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.68:*:*:*:*:*:*:*", "matchCriteriaId": "97054639-45E1-405D-ADDC-B452D11DB8A0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.69:*:*:*:*:*:*:*", "matchCriteriaId": "B43E6CC8-A09E-43C4-B851-D25C24C3A4C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.70:*:*:*:*:*:*:*", "matchCriteriaId": "3D01EEBB-D8B2-45FA-8925-8AE779A57682"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.71:*:*:*:*:*:*:*", "matchCriteriaId": "F6CF59A2-936F-40F7-A727-25E6B6AC9748"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.72:*:*:*:*:*:*:*", "matchCriteriaId": "58B24B8A-328E-4434-9D02-4B6D5FF2F9F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.73:*:*:*:*:*:*:*", "matchCriteriaId": "6B7D2ED6-CBA2-46EA-ADAA-7F59B3B09FAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.74:*:*:*:*:*:*:*", "matchCriteriaId": "27BEADE4-AE41-486F-918D-5BC86346F22D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.75:*:*:*:*:*:*:*", "matchCriteriaId": "5AF31759-B531-48D3-9625-4AED09632A1A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.76:*:*:*:*:*:*:*", "matchCriteriaId": "978642D9-5330-4241-A5B3-E07794BF0B34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.77:*:*:*:*:*:*:*", "matchCriteriaId": "4C4CF987-E4AA-4489-9CC5-C0868BBD7617"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.78:*:*:*:*:*:*:*", "matchCriteriaId": "8A5FA7E2-B41A-4E3B-971C-EAE051CEEA77"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.79:*:*:*:*:*:*:*", "matchCriteriaId": "FBC8E0E4-C542-4012-9335-A561162B1E1B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.80:*:*:*:*:*:*:*", "matchCriteriaId": "F28335C7-5FB4-4777-8481-E1D3EDE6C143"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.81:*:*:*:*:*:*:*", "matchCriteriaId": "10C3ED14-191F-4E16-8101-FAEB8717CDFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.82:*:*:*:*:*:*:*", "matchCriteriaId": "B1ACE21F-3B1B-41C0-A087-D48AAB2D79AB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.83:*:*:*:*:*:*:*", "matchCriteriaId": "86D391A4-CA61-4EDB-BD09-0E69ADC93306"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.84:*:*:*:*:*:*:*", "matchCriteriaId": "D33AB5F1-8856-4F3D-A3C8-619BD5B897BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.85:*:*:*:*:*:*:*", "matchCriteriaId": "EBED7E87-D862-4ECB-98E9-0BA10606F1A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.86:*:*:*:*:*:*:*", "matchCriteriaId": "D471DB42-E992-4EEC-8F0B-A0FD7AC29EF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.87:*:*:*:*:*:*:*", "matchCriteriaId": "E4F4B2B6-A72C-4319-B65F-294DE27F77A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.88:*:*:*:*:*:*:*", "matchCriteriaId": "ECD471B9-2075-416D-AD87-3F826F38FAC8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.89:*:*:*:*:*:*:*", "matchCriteriaId": "641FD677-43BB-4796-B8F3-EEC282E118A8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.90:*:*:*:*:*:*:*", "matchCriteriaId": "415285DD-A6EF-4D11-9077-2BC6BE12D5EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.91:*:*:*:*:*:*:*", "matchCriteriaId": "418D4B38-93A1-465F-A8DD-433F8371F071"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.92:*:*:*:*:*:*:*", "matchCriteriaId": "98B2CA97-9140-4492-A342-B63F3647786A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.93:*:*:*:*:*:*:*", "matchCriteriaId": "B8C58B61-1531-4779-B04F-03D1FDFFE512"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.94:*:*:*:*:*:*:*", "matchCriteriaId": "757861AE-4B07-4C63-B381-4A9E33A913F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.95:*:*:*:*:*:*:*", "matchCriteriaId": "F047C787-2D66-4E65-995E-7F7AF26C83EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.96:*:*:*:*:*:*:*", "matchCriteriaId": "75CADE1E-7220-4A8C-A88E-634C705B955D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.97:*:*:*:*:*:*:*", "matchCriteriaId": "42B8AEA7-9555-42BB-83F6-8CDF2A45E27A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.98:*:*:*:*:*:*:*", "matchCriteriaId": "BCEFE536-5E0D-4A9F-AA0C-7442C364931A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.99:*:*:*:*:*:*:*", "matchCriteriaId": "9127D899-998F-4D1E-A883-D90D039BFF40"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.751:*:*:*:*:*:*:*", "matchCriteriaId": "299BB424-8871-460C-95B0-7AD990A4F2C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:2.752:*:*:*:*:*:*:*", "matchCriteriaId": "001AFBC4-C744-4254-B7CB-E0EB2C4E0FD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.00:*:*:*:*:*:*:*", "matchCriteriaId": "CEE30199-A513-44F3-9F8A-053E1D8853A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.01:*:*:*:*:*:*:*", "matchCriteriaId": "27CFEFC4-BC57-4A29-8938-D69E149A772C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.02:*:*:*:*:*:*:*", "matchCriteriaId": "C8AE6355-2F22-4338-9B64-9429DFE7B192"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.03:*:*:*:*:*:*:*", "matchCriteriaId": "F2C55E48-24B4-40FE-B398-2A9FC690B078"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.04:*:*:*:*:*:*:*", "matchCriteriaId": "87518DE5-F1C6-4296-9DF9-DA4FE3D29E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.05:*:*:*:*:*:*:*", "matchCriteriaId": "1EE610EC-660C-4651-AF61-BE86835CE819"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.06:*:*:*:*:*:*:*", "matchCriteriaId": "FDFCE75A-BED9-4A8B-A77A-45031C369C89"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.07:*:*:*:*:*:*:*", "matchCriteriaId": "4A874002-E4FA-4D58-985A-38C0144A17F9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.08:*:*:*:*:*:*:*", "matchCriteriaId": "BDA7F11A-0EBA-4055-BE91-615287759273"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.09:*:*:*:*:*:*:*", "matchCriteriaId": "F297D7BB-7BC6-45DB-98F9-F910F564E29D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.10:*:*:*:*:*:*:*", "matchCriteriaId": "E5D06357-6EFB-451E-84B2-B6B0C3751322"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "4AEAFAA4-A504-4830-8772-E04ABB8ABA94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.12:*:*:*:*:*:*:*", "matchCriteriaId": "B9932AD0-2EB8-46F9-B2A2-CEA5F2B86613"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.13:*:*:*:*:*:*:*", "matchCriteriaId": "51602911-C72B-443F-8430-3E0137D25FF8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.14:*:*:*:*:*:*:*", "matchCriteriaId": "8CC3430F-9ABA-49D2-9BDD-2D62EDE8903F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.15:*:*:*:*:*:*:*", "matchCriteriaId": "9D799737-46ED-4F5E-896A-98B8615F58EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.16:*:*:*:*:*:*:*", "matchCriteriaId": "16BBFF40-8130-466B-80BE-FF499BD5D6DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.17:*:*:*:*:*:*:*", "matchCriteriaId": "65113484-56AC-46C0-BF32-4A6E0506543C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.18:*:*:*:*:*:*:*", "matchCriteriaId": "8D66440A-ADFC-4739-AD3F-16BD9322B5BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.19:*:*:*:*:*:*:*", "matchCriteriaId": "35790EB9-4E91-4C74-973D-9F2D929CE177"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.20:*:*:*:*:*:*:*", "matchCriteriaId": "4FAF06A7-A4BF-4FF0-AFF8-5490E9F3C3E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.21:*:*:*:*:*:*:*", "matchCriteriaId": "D18B6CC6-6738-43D1-89CC-35E75AC6D372"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.22:*:*:*:*:*:*:*", "matchCriteriaId": "C2B8AC1E-1203-4857-A2D8-8DF7589A9B6E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.23:*:*:*:*:*:*:*", "matchCriteriaId": "2AE3CA84-F19B-4DBC-B3AA-F576011FBF6D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.24:*:*:*:*:*:*:*", "matchCriteriaId": "DE8ED0AD-F102-4D0D-84A6-753C9DCE29E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.25:*:*:*:*:*:*:*", "matchCriteriaId": "5EC87749-E547-435D-BFCA-C4EB8FA3F52E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.26:*:*:*:*:*:*:*", "matchCriteriaId": "F9B6599A-69AD-4C30-9BE2-4392B92D63E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.27:*:*:*:*:*:*:*", "matchCriteriaId": "8FC41A36-22ED-4140-BCE1-72FD600814C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.28:*:*:*:*:*:*:*", "matchCriteriaId": "D9A0369A-A65F-4FE1-AAB3-FE5D07F3BD83"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.29:*:*:*:*:*:*:*", "matchCriteriaId": "472F63BB-E8CE-4AFD-804C-89D180D1A8D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.30:*:*:*:*:*:*:*", "matchCriteriaId": "45B118D0-B093-421F-AAB3-1298A26F1162"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.31:*:*:*:*:*:*:*", "matchCriteriaId": "7E33BF7B-C086-4E72-9DE4-8264F50845F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.32:*:*:*:*:*:*:*", "matchCriteriaId": "0BAAF493-0460-40C8-9173-736582EF1AD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.33:*:*:*:*:*:*:*", "matchCriteriaId": "610C9B3E-0D2F-4881-9BE1-A60E484D5C08"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.34:*:*:*:*:*:*:*", "matchCriteriaId": "9AFD56E7-732A-45FE-B17B-46280F988058"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.35:*:*:*:*:*:*:*", "matchCriteriaId": "07FEC5A4-D662-4FDE-B9BA-53BCFEC5F521"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.36:*:*:*:*:*:*:*", "matchCriteriaId": "4F141F5D-4E41-4180-9413-D201EF57992C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.37:*:*:*:*:*:*:*", "matchCriteriaId": "79E16F80-C2A5-4859-89EC-E46FD371670A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.38:*:*:*:*:*:*:*", "matchCriteriaId": "932FFD59-B45F-44F1-8C48-4815BDEBFB30"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.39:*:*:*:*:*:*:*", "matchCriteriaId": "A890611B-A162-4CDF-AB59-F6A9683399AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.40:*:*:*:*:*:*:*", "matchCriteriaId": "45258F98-8CC4-4B27-BEE6-638A19F75674"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.41:*:*:*:*:*:*:*", "matchCriteriaId": "7DCC040A-3F5C-4CCC-9540-5A61FF4F3098"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.42:*:*:*:*:*:*:*", "matchCriteriaId": "6B17E4CB-AEEA-489F-8601-D2D7614FF2EA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.43:*:*:*:*:*:*:*", "matchCriteriaId": "B1C58D73-C864-48A6-B120-70111B6DC255"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.44:*:*:*:*:*:*:*", "matchCriteriaId": "341B12EC-F089-4D13-9CE1-F6C77F63EFEC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.45:*:*:*:*:*:*:*", "matchCriteriaId": "EDEBF3C6-26B2-45BE-B440-94FA0E4A699D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.46:*:*:*:*:*:*:*", "matchCriteriaId": "03513BD7-FABA-4B49-AA42-0EFDDA8EE245"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.47:*:*:*:*:*:*:*", "matchCriteriaId": "9A251F28-FCEA-4B0F-AEC9-32916CD464E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi.pm:3.48:*:*:*:*:*:*:*", "matchCriteriaId": "BD434B97-08D6-4533-BAE0-53EF94BBECA4"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.112", "matchCriteriaId": "F492844C-491A-4124-B0F4-677A7F6295B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:0.078:*:*:*:*:*:*:*", "matchCriteriaId": "F9D0AD63-ADB5-49A1-A947-C6B8DD2380D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:0.079:*:*:*:*:*:*:*", "matchCriteriaId": "933D7C72-F3EE-4037-8E2B-B1A316A1B21A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:0.080:*:*:*:*:*:*:*", "matchCriteriaId": "6E4627D1-2F49-4631-8621-0ED00809546E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:0.081:*:*:*:*:*:*:*", "matchCriteriaId": "FCCD9748-7429-4753-8D9B-4A18F3A1E5FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:0.082:*:*:*:*:*:*:*", "matchCriteriaId": "86C63243-6170-4E49-8ED8-A49A78EC1D27"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:0.83:*:*:*:*:*:*:*", "matchCriteriaId": "E3C6D841-7D30-48A0-B5B7-44A0DD80A378"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "8CE0E5A0-1AB2-47B7-97D4-7C86851CC568"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:1.1:*:*:*:*:*:*:*", "matchCriteriaId": "D5997A75-9A73-4C90-B522-D33618D55BA5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "FA3A447F-3203-44BD-95C6-C351ED458CA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "7C07267B-323F-4529-A7E6-AE8DE80D79DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:1.103:*:*:*:*:*:*:*", "matchCriteriaId": "04EF4A44-56C1-4078-A04F-80073290462B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:1.104:*:*:*:*:*:*:*", "matchCriteriaId": "0AC0DCD5-2689-4556-A346-59F563F39E9D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:1.105:*:*:*:*:*:*:*", "matchCriteriaId": "1432A51A-99D6-4D6C-8EF2-E8BBA8A7A222"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:1.106:*:*:*:*:*:*:*", "matchCriteriaId": "A8718571-C8D1-4337-BF12-396D764E2173"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:1.107:*:*:*:*:*:*:*", "matchCriteriaId": "69E512FF-25E0-4365-8CC0-6BA835A3B7F3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:1.108:*:*:*:*:*:*:*", "matchCriteriaId": "5B5D2AAA-C707-473F-83C5-5ACA4A2C8C35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:1.109:*:*:*:*:*:*:*", "matchCriteriaId": "D3FBF0F5-7C52-4CB8-8F3C-0173E692E774"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:1.110:*:*:*:*:*:*:*", "matchCriteriaId": "D0CC27CA-9852-4F69-B1E6-518ED2CED10B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:andy_armstrong:cgi-simple:1.111:*:*:*:*:*:*:*", "matchCriteriaId": "3BDCE5D0-A7FB-4F20-8418-C3B6E1005E0E"}]}]}], "references": [{"url": "http://cpansearch.perl.org/src/LDS/CGI.pm-3.50/Changes", "source": "cve@mitre.org"}, {"url": "http://kb.juniper.net/InfoCenter/index?page=content&id=JSA10705", "source": "cve@mitre.org"}, {"url": "http://kb.juniper.net/InfoCenter/index?page=content&id=JSA10735", "source": "cve@mitre.org"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2011-February/053665.html", "source": "cve@mitre.org"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2011-February/053678.html", "source": "cve@mitre.org"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2011-January/053576.html", "source": "cve@mitre.org"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2011-January/053591.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2011-01/msg00003.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2011-01/msg00006.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2011-04/msg00000.html", "source": "cve@mitre.org"}, {"url": "http://openwall.com/lists/oss-security/2010/12/01/1", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2010/12/01/2", "source": "cve@mitre.org"}, {"url": "http://openwall.com/lists/oss-security/2010/12/01/3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://perl5.git.perl.org/perl.git/blobdiff/a0b94c2432b1d8c20653453a0f6970cb10f59aec..84601d63a7e34958da47dad1e61e27cb3bd467d1:/cpan/CGI/lib/CGI.pm", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://perl5.git.perl.org/perl.git/commit/84601d63a7e34958da47dad1e61e27cb3bd467d1", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.bugzilla.org/security/3.2.9/", "source": "cve@mitre.org"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2010:237", "source": "cve@mitre.org"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2010:250", "source": "cve@mitre.org"}, {"url": "http://www.nntp.perl.org/group/perl.perl5.changes/2010/11/msg28043.html", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.redhat.com/support/errata/RHSA-2011-1797.html", "source": "cve@mitre.org"}, {"url": "http://www.vupen.com/english/advisories/2011/0076", "source": "cve@mitre.org"}, {"url": "http://www.vupen.com/english/advisories/2011/0207", "source": "cve@mitre.org"}, {"url": "http://www.vupen.com/english/advisories/2011/0212", "source": "cve@mitre.org"}, {"url": "http://www.vupen.com/english/advisories/2011/0249", "source": "cve@mitre.org"}, {"url": "http://www.vupen.com/english/advisories/2011/0271", "source": "cve@mitre.org"}, {"url": "https://bugzilla.mozilla.org/show_bug.cgi?id=591165", "source": "cve@mitre.org"}, {"url": "https://bugzilla.mozilla.org/show_bug.cgi?id=600464", "source": "cve@mitre.org"}, {"url": "https://github.com/AndyA/CGI--Simple/commit/e4942b871a26c1317a175a91ebb7262eea59b380", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/AndyA/CGI--Simple/commit/e4942b871a26c1317a175a91ebb7262eea59b380"}}