{"buggy_code": ["/*\n * Edgeport USB Serial Converter driver\n *\n * Copyright (C) 2000-2002 Inside Out Networks, All rights reserved.\n * Copyright (C) 2001-2002 Greg Kroah-Hartman <greg@kroah.com>\n *\n *\tThis program is free software; you can redistribute it and/or modify\n *\tit under the terms of the GNU General Public License as published by\n *\tthe Free Software Foundation; either version 2 of the License, or\n *\t(at your option) any later version.\n *\n * Supports the following devices:\n *\tEP/1 EP/2 EP/4 EP/21 EP/22 EP/221 EP/42 EP/421 WATCHPORT\n *\n * For questions or problems with this driver, contact Inside Out\n * Networks technical support, or Peter Berger <pberger@brimson.com>,\n * or Al Borchers <alborchers@steinerpoint.com>.\n */\n\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/serial.h>\n#include <linux/swab.h>\n#include <linux/kfifo.h>\n#include <linux/ioctl.h>\n#include <linux/firmware.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\n#include \"io_16654.h\"\n#include \"io_usbvend.h\"\n#include \"io_ti.h\"\n\n#define DRIVER_AUTHOR \"Greg Kroah-Hartman <greg@kroah.com> and David Iacovelli\"\n#define DRIVER_DESC \"Edgeport USB Serial Driver\"\n\n#define EPROM_PAGE_SIZE\t\t64\n\n\n/* different hardware types */\n#define HARDWARE_TYPE_930\t0\n#define HARDWARE_TYPE_TIUMP\t1\n\n/* IOCTL_PRIVATE_TI_GET_MODE Definitions */\n#define\tTI_MODE_CONFIGURING\t0   /* Device has not entered start device */\n#define\tTI_MODE_BOOT\t\t1   /* Staying in boot mode\t\t   */\n#define TI_MODE_DOWNLOAD\t2   /* Made it to download mode\t\t   */\n#define TI_MODE_TRANSITIONING\t3   /*\n\t\t\t\t     * Currently in boot mode but\n\t\t\t\t     * transitioning to download mode\n\t\t\t\t     */\n\n/* read urb state */\n#define EDGE_READ_URB_RUNNING\t0\n#define EDGE_READ_URB_STOPPING\t1\n#define EDGE_READ_URB_STOPPED\t2\n\n#define EDGE_CLOSING_WAIT\t4000\t/* in .01 sec */\n\n\n/* Product information read from the Edgeport */\nstruct product_info {\n\tint\tTiMode;\t\t\t/* Current TI Mode  */\n\t__u8\thardware_type;\t\t/* Type of hardware */\n} __attribute__((packed));\n\n/*\n * Edgeport firmware header\n *\n * \"build_number\" has been set to 0 in all three of the images I have\n * seen, and Digi Tech Support suggests that it is safe to ignore it.\n *\n * \"length\" is the number of bytes of actual data following the header.\n *\n * \"checksum\" is the low order byte resulting from adding the values of\n * all the data bytes.\n */\nstruct edgeport_fw_hdr {\n\tu8 major_version;\n\tu8 minor_version;\n\t__le16 build_number;\n\t__le16 length;\n\tu8 checksum;\n} __packed;\n\nstruct edgeport_port {\n\t__u16 uart_base;\n\t__u16 dma_address;\n\t__u8 shadow_msr;\n\t__u8 shadow_mcr;\n\t__u8 shadow_lsr;\n\t__u8 lsr_mask;\n\t__u32 ump_read_timeout;\t\t/*\n\t\t\t\t\t * Number of milliseconds the UMP will\n\t\t\t\t\t * wait without data before completing\n\t\t\t\t\t * a read short\n\t\t\t\t\t */\n\tint baud_rate;\n\tint close_pending;\n\tint lsr_event;\n\n\tstruct edgeport_serial\t*edge_serial;\n\tstruct usb_serial_port\t*port;\n\t__u8 bUartMode;\t\t/* Port type, 0: RS232, etc. */\n\tspinlock_t ep_lock;\n\tint ep_read_urb_state;\n\tint ep_write_urb_in_use;\n};\n\nstruct edgeport_serial {\n\tstruct product_info product_info;\n\tu8 TI_I2C_Type;\t\t\t/* Type of I2C in UMP */\n\tu8 TiReadI2C;\t\t\t/*\n\t\t\t\t\t * Set to TRUE if we have read the\n\t\t\t\t\t * I2c in Boot Mode\n\t\t\t\t\t */\n\tstruct mutex es_lock;\n\tint num_ports_open;\n\tstruct usb_serial *serial;\n\tstruct delayed_work heartbeat_work;\n\tint fw_version;\n\tbool use_heartbeat;\n};\n\n\n/* Devices that this driver supports */\nstatic const struct usb_device_id edgeport_1port_id_table[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_1) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_TI3410_EDGEPORT_1) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_TI3410_EDGEPORT_1I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_PROXIMITY) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_MOTION) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_MOISTURE) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_TEMPERATURE) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_HUMIDITY) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_POWER) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_LIGHT) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_RADIATION) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_DISTANCE) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_ACCELERATION) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_PROX_DIST) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_PLUS_PWR_HP4CD) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_PLUS_PWR_PCI) },\n\t{ }\n};\n\nstatic const struct usb_device_id edgeport_2port_id_table[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2C) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_42) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_22I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_221C) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_22C) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21C) },\n\t/* The 4, 8 and 16 port devices show up as multiple 2 port devices */\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4S) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_8) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_8S) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_416) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_416B) },\n\t{ }\n};\n\n/* Devices that this driver supports */\nstatic const struct usb_device_id id_table_combined[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_1) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_TI3410_EDGEPORT_1) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_TI3410_EDGEPORT_1I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_PROXIMITY) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_MOTION) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_MOISTURE) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_TEMPERATURE) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_HUMIDITY) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_POWER) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_LIGHT) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_RADIATION) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_DISTANCE) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_ACCELERATION) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_PROX_DIST) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_PLUS_PWR_HP4CD) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_PLUS_PWR_PCI) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2C) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_42) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_22I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_221C) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_22C) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21C) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4S) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_8) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_8S) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_416) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_416B) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, id_table_combined);\n\nstatic int closing_wait = EDGE_CLOSING_WAIT;\nstatic bool ignore_cpu_rev;\nstatic int default_uart_mode;\t\t/* RS232 */\n\nstatic void edge_tty_recv(struct usb_serial_port *port, unsigned char *data,\n\t\tint length);\n\nstatic void stop_read(struct edgeport_port *edge_port);\nstatic int restart_read(struct edgeport_port *edge_port);\n\nstatic void edge_set_termios(struct tty_struct *tty,\n\t\tstruct usb_serial_port *port, struct ktermios *old_termios);\nstatic void edge_send(struct usb_serial_port *port, struct tty_struct *tty);\n\nstatic int do_download_mode(struct edgeport_serial *serial,\n\t\tconst struct firmware *fw);\nstatic int do_boot_mode(struct edgeport_serial *serial,\n\t\tconst struct firmware *fw);\n\n/* sysfs attributes */\nstatic int edge_create_sysfs_attrs(struct usb_serial_port *port);\nstatic int edge_remove_sysfs_attrs(struct usb_serial_port *port);\n\n/*\n * Some release of Edgeport firmware \"down3.bin\" after version 4.80\n * introduced code to automatically disconnect idle devices on some\n * Edgeport models after periods of inactivity, typically ~60 seconds.\n * This occurs without regard to whether ports on the device are open\n * or not.  Digi International Tech Support suggested:\n *\n * 1.  Adding driver \"heartbeat\" code to reset the firmware timer by\n *     requesting a descriptor record every 15 seconds, which should be\n *     effective with newer firmware versions that require it, and benign\n *     with older versions that do not. In practice 40 seconds seems often\n *     enough.\n * 2.  The heartbeat code is currently required only on Edgeport/416 models.\n */\n#define FW_HEARTBEAT_VERSION_CUTOFF ((4 << 8) + 80)\n#define FW_HEARTBEAT_SECS 40\n\n/* Timeouts in msecs: firmware downloads take longer */\n#define TI_VSEND_TIMEOUT_DEFAULT 1000\n#define TI_VSEND_TIMEOUT_FW_DOWNLOAD 10000\n\nstatic int ti_vread_sync(struct usb_device *dev, __u8 request,\n\t\t\t\t__u16 value, __u16 index, u8 *data, int size)\n{\n\tint status;\n\n\tstatus = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,\n\t\t\t(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),\n\t\t\tvalue, index, data, size, 1000);\n\tif (status < 0)\n\t\treturn status;\n\tif (status != size) {\n\t\tdev_dbg(&dev->dev, \"%s - wanted to write %d, but only wrote %d\\n\",\n\t\t\t__func__, size, status);\n\t\treturn -ECOMM;\n\t}\n\treturn 0;\n}\n\nstatic int ti_vsend_sync(struct usb_device *dev, u8 request, u16 value,\n\t\tu16 index, u8 *data, int size, int timeout)\n{\n\tint status;\n\n\tstatus = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), request,\n\t\t\t(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT),\n\t\t\tvalue, index, data, size, timeout);\n\tif (status < 0)\n\t\treturn status;\n\tif (status != size) {\n\t\tdev_dbg(&dev->dev, \"%s - wanted to write %d, but only wrote %d\\n\",\n\t\t\t__func__, size, status);\n\t\treturn -ECOMM;\n\t}\n\treturn 0;\n}\n\nstatic int send_cmd(struct usb_device *dev, __u8 command,\n\t\t\t\t__u8 moduleid, __u16 value, u8 *data,\n\t\t\t\tint size)\n{\n\treturn ti_vsend_sync(dev, command, value, moduleid, data, size,\n\t\t\tTI_VSEND_TIMEOUT_DEFAULT);\n}\n\n/* clear tx/rx buffers and fifo in TI UMP */\nstatic int purge_port(struct usb_serial_port *port, __u16 mask)\n{\n\tint port_number = port->port_number;\n\n\tdev_dbg(&port->dev, \"%s - port %d, mask %x\\n\", __func__, port_number, mask);\n\n\treturn send_cmd(port->serial->dev,\n\t\t\t\t\tUMPC_PURGE_PORT,\n\t\t\t\t\t(__u8)(UMPM_UART1_PORT + port_number),\n\t\t\t\t\tmask,\n\t\t\t\t\tNULL,\n\t\t\t\t\t0);\n}\n\n/**\n * read_download_mem - Read edgeport memory from TI chip\n * @dev: usb device pointer\n * @start_address: Device CPU address at which to read\n * @length: Length of above data\n * @address_type: Can read both XDATA and I2C\n * @buffer: pointer to input data buffer\n */\nstatic int read_download_mem(struct usb_device *dev, int start_address,\n\t\t\t\tint length, __u8 address_type, __u8 *buffer)\n{\n\tint status = 0;\n\t__u8 read_length;\n\tu16 be_start_address;\n\n\tdev_dbg(&dev->dev, \"%s - @ %x for %d\\n\", __func__, start_address, length);\n\n\t/*\n\t * Read in blocks of 64 bytes\n\t * (TI firmware can't handle more than 64 byte reads)\n\t */\n\twhile (length) {\n\t\tif (length > 64)\n\t\t\tread_length = 64;\n\t\telse\n\t\t\tread_length = (__u8)length;\n\n\t\tif (read_length > 1) {\n\t\t\tdev_dbg(&dev->dev, \"%s - @ %x for %d\\n\", __func__, start_address, read_length);\n\t\t}\n\t\t/*\n\t\t * NOTE: Must use swab as wIndex is sent in little-endian\n\t\t *       byte order regardless of host byte order.\n\t\t */\n\t\tbe_start_address = swab16((u16)start_address);\n\t\tstatus = ti_vread_sync(dev, UMPC_MEMORY_READ,\n\t\t\t\t\t(__u16)address_type,\n\t\t\t\t\tbe_start_address,\n\t\t\t\t\tbuffer, read_length);\n\n\t\tif (status) {\n\t\t\tdev_dbg(&dev->dev, \"%s - ERROR %x\\n\", __func__, status);\n\t\t\treturn status;\n\t\t}\n\n\t\tif (read_length > 1)\n\t\t\tusb_serial_debug_data(&dev->dev, __func__, read_length, buffer);\n\n\t\t/* Update pointers/length */\n\t\tstart_address += read_length;\n\t\tbuffer += read_length;\n\t\tlength -= read_length;\n\t}\n\n\treturn status;\n}\n\nstatic int read_ram(struct usb_device *dev, int start_address,\n\t\t\t\t\t\tint length, __u8 *buffer)\n{\n\treturn read_download_mem(dev, start_address, length,\n\t\t\t\t\tDTK_ADDR_SPACE_XDATA, buffer);\n}\n\n/* Read edgeport memory to a given block */\nstatic int read_boot_mem(struct edgeport_serial *serial,\n\t\t\t\tint start_address, int length, __u8 *buffer)\n{\n\tint status = 0;\n\tint i;\n\n\tfor (i = 0; i < length; i++) {\n\t\tstatus = ti_vread_sync(serial->serial->dev,\n\t\t\t\tUMPC_MEMORY_READ, serial->TI_I2C_Type,\n\t\t\t\t(__u16)(start_address+i), &buffer[i], 0x01);\n\t\tif (status) {\n\t\t\tdev_dbg(&serial->serial->dev->dev, \"%s - ERROR %x\\n\", __func__, status);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tdev_dbg(&serial->serial->dev->dev, \"%s - start_address = %x, length = %d\\n\",\n\t\t__func__, start_address, length);\n\tusb_serial_debug_data(&serial->serial->dev->dev, __func__, length, buffer);\n\n\tserial->TiReadI2C = 1;\n\n\treturn status;\n}\n\n/* Write given block to TI EPROM memory */\nstatic int write_boot_mem(struct edgeport_serial *serial,\n\t\t\t\tint start_address, int length, __u8 *buffer)\n{\n\tint status = 0;\n\tint i;\n\tu8 *temp;\n\n\t/* Must do a read before write */\n\tif (!serial->TiReadI2C) {\n\t\ttemp = kmalloc(1, GFP_KERNEL);\n\t\tif (!temp)\n\t\t\treturn -ENOMEM;\n\n\t\tstatus = read_boot_mem(serial, 0, 1, temp);\n\t\tkfree(temp);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tfor (i = 0; i < length; ++i) {\n\t\tstatus = ti_vsend_sync(serial->serial->dev, UMPC_MEMORY_WRITE,\n\t\t\t\tbuffer[i], (u16)(i + start_address), NULL,\n\t\t\t\t0, TI_VSEND_TIMEOUT_DEFAULT);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tdev_dbg(&serial->serial->dev->dev, \"%s - start_sddr = %x, length = %d\\n\", __func__, start_address, length);\n\tusb_serial_debug_data(&serial->serial->dev->dev, __func__, length, buffer);\n\n\treturn status;\n}\n\n/* Write edgeport I2C memory to TI chip\t*/\nstatic int write_i2c_mem(struct edgeport_serial *serial,\n\t\tint start_address, int length, __u8 address_type, __u8 *buffer)\n{\n\tstruct device *dev = &serial->serial->dev->dev;\n\tint status = 0;\n\tint write_length;\n\tu16 be_start_address;\n\n\t/* We can only send a maximum of 1 aligned byte page at a time */\n\n\t/* calculate the number of bytes left in the first page */\n\twrite_length = EPROM_PAGE_SIZE -\n\t\t\t\t(start_address & (EPROM_PAGE_SIZE - 1));\n\n\tif (write_length > length)\n\t\twrite_length = length;\n\n\tdev_dbg(dev, \"%s - BytesInFirstPage Addr = %x, length = %d\\n\",\n\t\t__func__, start_address, write_length);\n\tusb_serial_debug_data(dev, __func__, write_length, buffer);\n\n\t/*\n\t * Write first page.\n\t *\n\t * NOTE: Must use swab as wIndex is sent in little-endian byte order\n\t *       regardless of host byte order.\n\t */\n\tbe_start_address = swab16((u16)start_address);\n\tstatus = ti_vsend_sync(serial->serial->dev, UMPC_MEMORY_WRITE,\n\t\t\t\t(u16)address_type, be_start_address,\n\t\t\t\tbuffer,\twrite_length, TI_VSEND_TIMEOUT_DEFAULT);\n\tif (status) {\n\t\tdev_dbg(dev, \"%s - ERROR %d\\n\", __func__, status);\n\t\treturn status;\n\t}\n\n\tlength\t\t-= write_length;\n\tstart_address\t+= write_length;\n\tbuffer\t\t+= write_length;\n\n\t/*\n\t * We should be aligned now -- can write max page size bytes at a\n\t * time.\n\t */\n\twhile (length) {\n\t\tif (length > EPROM_PAGE_SIZE)\n\t\t\twrite_length = EPROM_PAGE_SIZE;\n\t\telse\n\t\t\twrite_length = length;\n\n\t\tdev_dbg(dev, \"%s - Page Write Addr = %x, length = %d\\n\",\n\t\t\t__func__, start_address, write_length);\n\t\tusb_serial_debug_data(dev, __func__, write_length, buffer);\n\n\t\t/*\n\t\t * Write next page.\n\t\t *\n\t\t * NOTE: Must use swab as wIndex is sent in little-endian byte\n\t\t *       order regardless of host byte order.\n\t\t */\n\t\tbe_start_address = swab16((u16)start_address);\n\t\tstatus = ti_vsend_sync(serial->serial->dev, UMPC_MEMORY_WRITE,\n\t\t\t\t(u16)address_type, be_start_address, buffer,\n\t\t\t\twrite_length, TI_VSEND_TIMEOUT_DEFAULT);\n\t\tif (status) {\n\t\t\tdev_err(dev, \"%s - ERROR %d\\n\", __func__, status);\n\t\t\treturn status;\n\t\t}\n\n\t\tlength\t\t-= write_length;\n\t\tstart_address\t+= write_length;\n\t\tbuffer\t\t+= write_length;\n\t}\n\treturn status;\n}\n\n/*\n * Examine the UMP DMA registers and LSR\n *\n * Check the MSBit of the X and Y DMA byte count registers.\n * A zero in this bit indicates that the TX DMA buffers are empty\n * then check the TX Empty bit in the UART.\n */\nstatic int tx_active(struct edgeport_port *port)\n{\n\tint status;\n\tstruct out_endpoint_desc_block *oedb;\n\t__u8 *lsr;\n\tint bytes_left = 0;\n\n\toedb = kmalloc(sizeof(*oedb), GFP_KERNEL);\n\tif (!oedb)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Sigh, that's right, just one byte, as not all platforms can\n\t * do DMA from stack\n\t */\n\tlsr = kmalloc(1, GFP_KERNEL);\n\tif (!lsr) {\n\t\tkfree(oedb);\n\t\treturn -ENOMEM;\n\t}\n\t/* Read the DMA Count Registers */\n\tstatus = read_ram(port->port->serial->dev, port->dma_address,\n\t\t\t\t\t\tsizeof(*oedb), (void *)oedb);\n\tif (status)\n\t\tgoto exit_is_tx_active;\n\n\tdev_dbg(&port->port->dev, \"%s - XByteCount    0x%X\\n\", __func__, oedb->XByteCount);\n\n\t/* and the LSR */\n\tstatus = read_ram(port->port->serial->dev,\n\t\t\tport->uart_base + UMPMEM_OFFS_UART_LSR, 1, lsr);\n\n\tif (status)\n\t\tgoto exit_is_tx_active;\n\tdev_dbg(&port->port->dev, \"%s - LSR = 0x%X\\n\", __func__, *lsr);\n\n\t/* If either buffer has data or we are transmitting then return TRUE */\n\tif ((oedb->XByteCount & 0x80) != 0)\n\t\tbytes_left += 64;\n\n\tif ((*lsr & UMP_UART_LSR_TX_MASK) == 0)\n\t\tbytes_left += 1;\n\n\t/* We return Not Active if we get any kind of error */\nexit_is_tx_active:\n\tdev_dbg(&port->port->dev, \"%s - return %d\\n\", __func__, bytes_left);\n\n\tkfree(lsr);\n\tkfree(oedb);\n\treturn bytes_left;\n}\n\nstatic int choose_config(struct usb_device *dev)\n{\n\t/*\n\t * There may be multiple configurations on this device, in which case\n\t * we would need to read and parse all of them to find out which one\n\t * we want. However, we just support one config at this point,\n\t * configuration # 1, which is Config Descriptor 0.\n\t */\n\n\tdev_dbg(&dev->dev, \"%s - Number of Interfaces = %d\\n\",\n\t\t__func__, dev->config->desc.bNumInterfaces);\n\tdev_dbg(&dev->dev, \"%s - MAX Power            = %d\\n\",\n\t\t__func__, dev->config->desc.bMaxPower * 2);\n\n\tif (dev->config->desc.bNumInterfaces != 1) {\n\t\tdev_err(&dev->dev, \"%s - bNumInterfaces is not 1, ERROR!\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_rom(struct edgeport_serial *serial,\n\t\t\t\tint start_address, int length, __u8 *buffer)\n{\n\tint status;\n\n\tif (serial->product_info.TiMode == TI_MODE_DOWNLOAD) {\n\t\tstatus = read_download_mem(serial->serial->dev,\n\t\t\t\t\t       start_address,\n\t\t\t\t\t       length,\n\t\t\t\t\t       serial->TI_I2C_Type,\n\t\t\t\t\t       buffer);\n\t} else {\n\t\tstatus = read_boot_mem(serial, start_address, length,\n\t\t\t\t\t\t\t\tbuffer);\n\t}\n\treturn status;\n}\n\nstatic int write_rom(struct edgeport_serial *serial, int start_address,\n\t\t\t\t\t\tint length, __u8 *buffer)\n{\n\tif (serial->product_info.TiMode == TI_MODE_BOOT)\n\t\treturn write_boot_mem(serial, start_address, length,\n\t\t\t\t\t\t\t\tbuffer);\n\n\tif (serial->product_info.TiMode == TI_MODE_DOWNLOAD)\n\t\treturn write_i2c_mem(serial, start_address, length,\n\t\t\t\t\t\tserial->TI_I2C_Type, buffer);\n\treturn -EINVAL;\n}\n\n/* Read a descriptor header from I2C based on type */\nstatic int get_descriptor_addr(struct edgeport_serial *serial,\n\t\t\t\tint desc_type, struct ti_i2c_desc *rom_desc)\n{\n\tint start_address;\n\tint status;\n\n\t/* Search for requested descriptor in I2C */\n\tstart_address = 2;\n\tdo {\n\t\tstatus = read_rom(serial,\n\t\t\t\t   start_address,\n\t\t\t\t   sizeof(struct ti_i2c_desc),\n\t\t\t\t   (__u8 *)rom_desc);\n\t\tif (status)\n\t\t\treturn 0;\n\n\t\tif (rom_desc->Type == desc_type)\n\t\t\treturn start_address;\n\n\t\tstart_address = start_address + sizeof(struct ti_i2c_desc) +\n\t\t\t\t\t\tle16_to_cpu(rom_desc->Size);\n\n\t} while ((start_address < TI_MAX_I2C_SIZE) && rom_desc->Type);\n\n\treturn 0;\n}\n\n/* Validate descriptor checksum */\nstatic int valid_csum(struct ti_i2c_desc *rom_desc, __u8 *buffer)\n{\n\t__u16 i;\n\t__u8 cs = 0;\n\n\tfor (i = 0; i < le16_to_cpu(rom_desc->Size); i++)\n\t\tcs = (__u8)(cs + buffer[i]);\n\n\tif (cs != rom_desc->CheckSum) {\n\t\tpr_debug(\"%s - Mismatch %x - %x\", __func__, rom_desc->CheckSum, cs);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/* Make sure that the I2C image is good */\nstatic int check_i2c_image(struct edgeport_serial *serial)\n{\n\tstruct device *dev = &serial->serial->dev->dev;\n\tint status = 0;\n\tstruct ti_i2c_desc *rom_desc;\n\tint start_address = 2;\n\t__u8 *buffer;\n\t__u16 ttype;\n\n\trom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\n\tif (!rom_desc)\n\t\treturn -ENOMEM;\n\n\tbuffer = kmalloc(TI_MAX_I2C_SIZE, GFP_KERNEL);\n\tif (!buffer) {\n\t\tkfree(rom_desc);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Read the first byte (Signature0) must be 0x52 or 0x10 */\n\tstatus = read_rom(serial, 0, 1, buffer);\n\tif (status)\n\t\tgoto out;\n\n\tif (*buffer != UMP5152 && *buffer != UMP3410) {\n\t\tdev_err(dev, \"%s - invalid buffer signature\\n\", __func__);\n\t\tstatus = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\t/* Validate the I2C */\n\t\tstatus = read_rom(serial,\n\t\t\t\tstart_address,\n\t\t\t\tsizeof(struct ti_i2c_desc),\n\t\t\t\t(__u8 *)rom_desc);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tif ((start_address + sizeof(struct ti_i2c_desc) +\n\t\t\tle16_to_cpu(rom_desc->Size)) > TI_MAX_I2C_SIZE) {\n\t\t\tstatus = -ENODEV;\n\t\t\tdev_dbg(dev, \"%s - structure too big, erroring out.\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(dev, \"%s Type = 0x%x\\n\", __func__, rom_desc->Type);\n\n\t\t/* Skip type 2 record */\n\t\tttype = rom_desc->Type & 0x0f;\n\t\tif (ttype != I2C_DESC_TYPE_FIRMWARE_BASIC\n\t\t\t&& ttype != I2C_DESC_TYPE_FIRMWARE_AUTO) {\n\t\t\t/* Read the descriptor data */\n\t\t\tstatus = read_rom(serial, start_address +\n\t\t\t\t\t\tsizeof(struct ti_i2c_desc),\n\t\t\t\t\t\tle16_to_cpu(rom_desc->Size),\n\t\t\t\t\t\tbuffer);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\n\t\t\tstatus = valid_csum(rom_desc, buffer);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t}\n\t\tstart_address = start_address + sizeof(struct ti_i2c_desc) +\n\t\t\t\t\t\tle16_to_cpu(rom_desc->Size);\n\n\t} while ((rom_desc->Type != I2C_DESC_TYPE_ION) &&\n\t\t\t\t(start_address < TI_MAX_I2C_SIZE));\n\n\tif ((rom_desc->Type != I2C_DESC_TYPE_ION) ||\n\t\t\t\t(start_address > TI_MAX_I2C_SIZE))\n\t\tstatus = -ENODEV;\n\nout:\n\tkfree(buffer);\n\tkfree(rom_desc);\n\treturn status;\n}\n\nstatic int get_manuf_info(struct edgeport_serial *serial, __u8 *buffer)\n{\n\tint status;\n\tint start_address;\n\tstruct ti_i2c_desc *rom_desc;\n\tstruct edge_ti_manuf_descriptor *desc;\n\tstruct device *dev = &serial->serial->dev->dev;\n\n\trom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\n\tif (!rom_desc)\n\t\treturn -ENOMEM;\n\n\tstart_address = get_descriptor_addr(serial, I2C_DESC_TYPE_ION,\n\t\t\t\t\t\t\t\trom_desc);\n\n\tif (!start_address) {\n\t\tdev_dbg(dev, \"%s - Edge Descriptor not found in I2C\\n\", __func__);\n\t\tstatus = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t/* Read the descriptor data */\n\tstatus = read_rom(serial, start_address+sizeof(struct ti_i2c_desc),\n\t\t\t\t\tle16_to_cpu(rom_desc->Size), buffer);\n\tif (status)\n\t\tgoto exit;\n\n\tstatus = valid_csum(rom_desc, buffer);\n\n\tdesc = (struct edge_ti_manuf_descriptor *)buffer;\n\tdev_dbg(dev, \"%s - IonConfig      0x%x\\n\", __func__, desc->IonConfig);\n\tdev_dbg(dev, \"%s - Version          %d\\n\", __func__, desc->Version);\n\tdev_dbg(dev, \"%s - Cpu/Board      0x%x\\n\", __func__, desc->CpuRev_BoardRev);\n\tdev_dbg(dev, \"%s - NumPorts         %d\\n\", __func__, desc->NumPorts);\n\tdev_dbg(dev, \"%s - NumVirtualPorts  %d\\n\", __func__, desc->NumVirtualPorts);\n\tdev_dbg(dev, \"%s - TotalPorts       %d\\n\", __func__, desc->TotalPorts);\n\nexit:\n\tkfree(rom_desc);\n\treturn status;\n}\n\n/* Build firmware header used for firmware update */\nstatic int build_i2c_fw_hdr(u8 *header, const struct firmware *fw)\n{\n\t__u8 *buffer;\n\tint buffer_size;\n\tint i;\n\t__u8 cs = 0;\n\tstruct ti_i2c_desc *i2c_header;\n\tstruct ti_i2c_image_header *img_header;\n\tstruct ti_i2c_firmware_rec *firmware_rec;\n\tstruct edgeport_fw_hdr *fw_hdr = (struct edgeport_fw_hdr *)fw->data;\n\n\t/*\n\t * In order to update the I2C firmware we must change the type 2 record\n\t * to type 0xF2.  This will force the UMP to come up in Boot Mode.\n\t * Then while in boot mode, the driver will download the latest\n\t * firmware (padded to 15.5k) into the UMP ram.  And finally when the\n\t * device comes back up in download mode the driver will cause the new\n\t * firmware to be copied from the UMP Ram to I2C and the firmware will\n\t * update the record type from 0xf2 to 0x02.\n\t */\n\n\t/*\n\t * Allocate a 15.5k buffer + 2 bytes for version number (Firmware\n\t * Record)\n\t */\n\tbuffer_size = (((1024 * 16) - 512 ) +\n\t\t\tsizeof(struct ti_i2c_firmware_rec));\n\n\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t/* Set entire image of 0xffs */\n\tmemset(buffer, 0xff, buffer_size);\n\n\t/* Copy version number into firmware record */\n\tfirmware_rec = (struct ti_i2c_firmware_rec *)buffer;\n\n\tfirmware_rec->Ver_Major\t= fw_hdr->major_version;\n\tfirmware_rec->Ver_Minor\t= fw_hdr->minor_version;\n\n\t/* Pointer to fw_down memory image */\n\timg_header = (struct ti_i2c_image_header *)&fw->data[4];\n\n\tmemcpy(buffer + sizeof(struct ti_i2c_firmware_rec),\n\t\t&fw->data[4 + sizeof(struct ti_i2c_image_header)],\n\t\tle16_to_cpu(img_header->Length));\n\n\tfor (i=0; i < buffer_size; i++) {\n\t\tcs = (__u8)(cs + buffer[i]);\n\t}\n\n\tkfree(buffer);\n\n\t/* Build new header */\n\ti2c_header =  (struct ti_i2c_desc *)header;\n\tfirmware_rec =  (struct ti_i2c_firmware_rec*)i2c_header->Data;\n\n\ti2c_header->Type\t= I2C_DESC_TYPE_FIRMWARE_BLANK;\n\ti2c_header->Size\t= cpu_to_le16(buffer_size);\n\ti2c_header->CheckSum\t= cs;\n\tfirmware_rec->Ver_Major\t= fw_hdr->major_version;\n\tfirmware_rec->Ver_Minor\t= fw_hdr->minor_version;\n\n\treturn 0;\n}\n\n/* Try to figure out what type of I2c we have */\nstatic int i2c_type_bootmode(struct edgeport_serial *serial)\n{\n\tstruct device *dev = &serial->serial->dev->dev;\n\tint status;\n\tu8 *data;\n\n\tdata = kmalloc(1, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t/* Try to read type 2 */\n\tstatus = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,\n\t\t\t\tDTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);\n\tif (status)\n\t\tdev_dbg(dev, \"%s - read 2 status error = %d\\n\", __func__, status);\n\telse\n\t\tdev_dbg(dev, \"%s - read 2 data = 0x%x\\n\", __func__, *data);\n\tif ((!status) && (*data == UMP5152 || *data == UMP3410)) {\n\t\tdev_dbg(dev, \"%s - ROM_TYPE_II\\n\", __func__);\n\t\tserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;\n\t\tgoto out;\n\t}\n\n\t/* Try to read type 3 */\n\tstatus = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,\n\t\t\t\tDTK_ADDR_SPACE_I2C_TYPE_III, 0,\tdata, 0x01);\n\tif (status)\n\t\tdev_dbg(dev, \"%s - read 3 status error = %d\\n\", __func__, status);\n\telse\n\t\tdev_dbg(dev, \"%s - read 2 data = 0x%x\\n\", __func__, *data);\n\tif ((!status) && (*data == UMP5152 || *data == UMP3410)) {\n\t\tdev_dbg(dev, \"%s - ROM_TYPE_III\\n\", __func__);\n\t\tserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;\n\t\tgoto out;\n\t}\n\n\tdev_dbg(dev, \"%s - Unknown\\n\", __func__);\n\tserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;\n\tstatus = -ENODEV;\nout:\n\tkfree(data);\n\treturn status;\n}\n\nstatic int bulk_xfer(struct usb_serial *serial, void *buffer,\n\t\t\t\t\t\tint length, int *num_sent)\n{\n\tint status;\n\n\tstatus = usb_bulk_msg(serial->dev,\n\t\t\tusb_sndbulkpipe(serial->dev,\n\t\t\t\tserial->port[0]->bulk_out_endpointAddress),\n\t\t\tbuffer, length, num_sent, 1000);\n\treturn status;\n}\n\n/* Download given firmware image to the device (IN BOOT MODE) */\nstatic int download_code(struct edgeport_serial *serial, __u8 *image,\n\t\t\t\t\t\t\tint image_length)\n{\n\tint status = 0;\n\tint pos;\n\tint transfer;\n\tint done;\n\n\t/* Transfer firmware image */\n\tfor (pos = 0; pos < image_length; ) {\n\t\t/* Read the next buffer from file */\n\t\ttransfer = image_length - pos;\n\t\tif (transfer > EDGE_FW_BULK_MAX_PACKET_SIZE)\n\t\t\ttransfer = EDGE_FW_BULK_MAX_PACKET_SIZE;\n\n\t\t/* Transfer data */\n\t\tstatus = bulk_xfer(serial->serial, &image[pos],\n\t\t\t\t\t\t\ttransfer, &done);\n\t\tif (status)\n\t\t\tbreak;\n\t\t/* Advance buffer pointer */\n\t\tpos += done;\n\t}\n\n\treturn status;\n}\n\n/* FIXME!!! */\nstatic int config_boot_dev(struct usb_device *dev)\n{\n\treturn 0;\n}\n\nstatic int ti_cpu_rev(struct edge_ti_manuf_descriptor *desc)\n{\n\treturn TI_GET_CPU_REVISION(desc->CpuRev_BoardRev);\n}\n\nstatic int check_fw_sanity(struct edgeport_serial *serial,\n\t\tconst struct firmware *fw)\n{\n\tu16 length_total;\n\tu8 checksum = 0;\n\tint pos;\n\tstruct device *dev = &serial->serial->interface->dev;\n\tstruct edgeport_fw_hdr *fw_hdr = (struct edgeport_fw_hdr *)fw->data;\n\n\tif (fw->size < sizeof(struct edgeport_fw_hdr)) {\n\t\tdev_err(dev, \"incomplete fw header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlength_total = le16_to_cpu(fw_hdr->length) +\n\t\t\tsizeof(struct edgeport_fw_hdr);\n\n\tif (fw->size != length_total) {\n\t\tdev_err(dev, \"bad fw size (expected: %u, got: %zu)\\n\",\n\t\t\t\tlength_total, fw->size);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (pos = sizeof(struct edgeport_fw_hdr); pos < fw->size; ++pos)\n\t\tchecksum += fw->data[pos];\n\n\tif (checksum != fw_hdr->checksum) {\n\t\tdev_err(dev, \"bad fw checksum (expected: 0x%x, got: 0x%x)\\n\",\n\t\t\t\tfw_hdr->checksum, checksum);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/*\n * DownloadTIFirmware - Download run-time operating firmware to the TI5052\n *\n * This routine downloads the main operating code into the TI5052, using the\n * boot code already burned into E2PROM or ROM.\n */\nstatic int download_fw(struct edgeport_serial *serial)\n{\n\tstruct device *dev = &serial->serial->interface->dev;\n\tint status = 0;\n\tstruct usb_interface_descriptor *interface;\n\tconst struct firmware *fw;\n\tconst char *fw_name = \"edgeport/down3.bin\";\n\tstruct edgeport_fw_hdr *fw_hdr;\n\n\tstatus = request_firmware(&fw, fw_name, dev);\n\tif (status) {\n\t\tdev_err(dev, \"Failed to load image \\\"%s\\\" err %d\\n\",\n\t\t\t\tfw_name, status);\n\t\treturn status;\n\t}\n\n\tif (check_fw_sanity(serial, fw)) {\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfw_hdr = (struct edgeport_fw_hdr *)fw->data;\n\n\t/* If on-board version is newer, \"fw_version\" will be updated later. */\n\tserial->fw_version = (fw_hdr->major_version << 8) +\n\t\t\tfw_hdr->minor_version;\n\n\t/*\n\t * This routine is entered by both the BOOT mode and the Download mode\n\t * We can determine which code is running by the reading the config\n\t * descriptor and if we have only one bulk pipe it is in boot mode\n\t */\n\tserial->product_info.hardware_type = HARDWARE_TYPE_TIUMP;\n\n\t/* Default to type 2 i2c */\n\tserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;\n\n\tstatus = choose_config(serial->serial->dev);\n\tif (status)\n\t\tgoto out;\n\n\tinterface = &serial->serial->interface->cur_altsetting->desc;\n\tif (!interface) {\n\t\tdev_err(dev, \"%s - no interface set, error!\\n\", __func__);\n\t\tstatus = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Setup initial mode -- the default mode 0 is TI_MODE_CONFIGURING\n\t * if we have more than one endpoint we are definitely in download\n\t * mode\n\t */\n\tif (interface->bNumEndpoints > 1) {\n\t\tserial->product_info.TiMode = TI_MODE_DOWNLOAD;\n\t\tstatus = do_download_mode(serial, fw);\n\t} else {\n\t\t/* Otherwise we will remain in configuring mode */\n\t\tserial->product_info.TiMode = TI_MODE_CONFIGURING;\n\t\tstatus = do_boot_mode(serial, fw);\n\t}\n\nout:\n\trelease_firmware(fw);\n\treturn status;\n}\n\nstatic int do_download_mode(struct edgeport_serial *serial,\n\t\tconst struct firmware *fw)\n{\n\tstruct device *dev = &serial->serial->interface->dev;\n\tint status = 0;\n\tint start_address;\n\tstruct edge_ti_manuf_descriptor *ti_manuf_desc;\n\tint download_cur_ver;\n\tint download_new_ver;\n\tstruct edgeport_fw_hdr *fw_hdr = (struct edgeport_fw_hdr *)fw->data;\n\tstruct ti_i2c_desc *rom_desc;\n\n\tdev_dbg(dev, \"%s - RUNNING IN DOWNLOAD MODE\\n\", __func__);\n\n\tstatus = check_i2c_image(serial);\n\tif (status) {\n\t\tdev_dbg(dev, \"%s - DOWNLOAD MODE -- BAD I2C\\n\", __func__);\n\t\treturn status;\n\t}\n\n\t/*\n\t * Validate Hardware version number\n\t * Read Manufacturing Descriptor from TI Based Edgeport\n\t */\n\tti_manuf_desc = kmalloc(sizeof(*ti_manuf_desc), GFP_KERNEL);\n\tif (!ti_manuf_desc)\n\t\treturn -ENOMEM;\n\n\tstatus = get_manuf_info(serial, (__u8 *)ti_manuf_desc);\n\tif (status) {\n\t\tkfree(ti_manuf_desc);\n\t\treturn status;\n\t}\n\n\t/* Check version number of ION descriptor */\n\tif (!ignore_cpu_rev && ti_cpu_rev(ti_manuf_desc) < 2) {\n\t\tdev_dbg(dev, \"%s - Wrong CPU Rev %d (Must be 2)\\n\",\n\t\t\t__func__, ti_cpu_rev(ti_manuf_desc));\n\t\tkfree(ti_manuf_desc);\n\t\treturn -EINVAL;\n\t}\n\n\trom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\n\tif (!rom_desc) {\n\t\tkfree(ti_manuf_desc);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Search for type 2 record (firmware record) */\n\tstart_address = get_descriptor_addr(serial,\n\t\t\tI2C_DESC_TYPE_FIRMWARE_BASIC, rom_desc);\n\tif (start_address != 0) {\n\t\tstruct ti_i2c_firmware_rec *firmware_version;\n\t\tu8 *record;\n\n\t\tdev_dbg(dev, \"%s - Found Type FIRMWARE (Type 2) record\\n\",\n\t\t\t\t__func__);\n\n\t\tfirmware_version = kmalloc(sizeof(*firmware_version),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!firmware_version) {\n\t\t\tkfree(rom_desc);\n\t\t\tkfree(ti_manuf_desc);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/*\n\t\t * Validate version number\n\t\t * Read the descriptor data\n\t\t */\n\t\tstatus = read_rom(serial, start_address +\n\t\t\t\tsizeof(struct ti_i2c_desc),\n\t\t\t\tsizeof(struct ti_i2c_firmware_rec),\n\t\t\t\t(__u8 *)firmware_version);\n\t\tif (status) {\n\t\t\tkfree(firmware_version);\n\t\t\tkfree(rom_desc);\n\t\t\tkfree(ti_manuf_desc);\n\t\t\treturn status;\n\t\t}\n\n\t\t/*\n\t\t * Check version number of download with current\n\t\t * version in I2c\n\t\t */\n\t\tdownload_cur_ver = (firmware_version->Ver_Major << 8) +\n\t\t\t\t   (firmware_version->Ver_Minor);\n\t\tdownload_new_ver = (fw_hdr->major_version << 8) +\n\t\t\t\t   (fw_hdr->minor_version);\n\n\t\tdev_dbg(dev, \"%s - >> FW Versions Device %d.%d  Driver %d.%d\\n\",\n\t\t\t__func__, firmware_version->Ver_Major,\n\t\t\tfirmware_version->Ver_Minor,\n\t\t\tfw_hdr->major_version, fw_hdr->minor_version);\n\n\t\t/*\n\t\t * Check if we have an old version in the I2C and\n\t\t * update if necessary\n\t\t */\n\t\tif (download_cur_ver < download_new_ver) {\n\t\t\tdev_dbg(dev, \"%s - Update I2C dld from %d.%d to %d.%d\\n\",\n\t\t\t\t__func__,\n\t\t\t\tfirmware_version->Ver_Major,\n\t\t\t\tfirmware_version->Ver_Minor,\n\t\t\t\tfw_hdr->major_version,\n\t\t\t\tfw_hdr->minor_version);\n\n\t\t\trecord = kmalloc(1, GFP_KERNEL);\n\t\t\tif (!record) {\n\t\t\t\tkfree(firmware_version);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\t/*\n\t\t\t * In order to update the I2C firmware we must\n\t\t\t * change the type 2 record to type 0xF2. This\n\t\t\t * will force the UMP to come up in Boot Mode.\n\t\t\t * Then while in boot mode, the driver will\n\t\t\t * download the latest firmware (padded to\n\t\t\t * 15.5k) into the UMP ram. Finally when the\n\t\t\t * device comes back up in download mode the\n\t\t\t * driver will cause the new firmware to be\n\t\t\t * copied from the UMP Ram to I2C and the\n\t\t\t * firmware will update the record type from\n\t\t\t * 0xf2 to 0x02.\n\t\t\t */\n\t\t\t*record = I2C_DESC_TYPE_FIRMWARE_BLANK;\n\n\t\t\t/*\n\t\t\t * Change the I2C Firmware record type to\n\t\t\t * 0xf2 to trigger an update\n\t\t\t */\n\t\t\tstatus = write_rom(serial, start_address,\n\t\t\t\t\tsizeof(*record), record);\n\t\t\tif (status) {\n\t\t\t\tkfree(record);\n\t\t\t\tkfree(firmware_version);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn status;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * verify the write -- must do this in order\n\t\t\t * for write to complete before we do the\n\t\t\t * hardware reset\n\t\t\t */\n\t\t\tstatus = read_rom(serial,\n\t\t\t\t\t\tstart_address,\n\t\t\t\t\t\tsizeof(*record),\n\t\t\t\t\t\trecord);\n\t\t\tif (status) {\n\t\t\t\tkfree(record);\n\t\t\t\tkfree(firmware_version);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn status;\n\t\t\t}\n\n\t\t\tif (*record != I2C_DESC_TYPE_FIRMWARE_BLANK) {\n\t\t\t\tdev_err(dev, \"%s - error resetting device\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\tkfree(record);\n\t\t\t\tkfree(firmware_version);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\t\tdev_dbg(dev, \"%s - HARDWARE RESET\\n\", __func__);\n\n\t\t\t/* Reset UMP -- Back to BOOT MODE */\n\t\t\tstatus = ti_vsend_sync(serial->serial->dev,\n\t\t\t\t\tUMPC_HARDWARE_RESET,\n\t\t\t\t\t0, 0, NULL, 0,\n\t\t\t\t\tTI_VSEND_TIMEOUT_DEFAULT);\n\n\t\t\tdev_dbg(dev, \"%s - HARDWARE RESET return %d\\n\",\n\t\t\t\t\t__func__, status);\n\n\t\t\t/* return an error on purpose. */\n\t\t\tkfree(record);\n\t\t\tkfree(firmware_version);\n\t\t\tkfree(rom_desc);\n\t\t\tkfree(ti_manuf_desc);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t/* Same or newer fw version is already loaded */\n\t\tserial->fw_version = download_cur_ver;\n\t\tkfree(firmware_version);\n\t}\n\t/* Search for type 0xF2 record (firmware blank record) */\n\telse {\n\t\tstart_address = get_descriptor_addr(serial,\n\t\t\t\tI2C_DESC_TYPE_FIRMWARE_BLANK, rom_desc);\n\t\tif (start_address != 0) {\n#define HEADER_SIZE\t(sizeof(struct ti_i2c_desc) + \\\n\t\t\t\tsizeof(struct ti_i2c_firmware_rec))\n\t\t\t__u8 *header;\n\t\t\t__u8 *vheader;\n\n\t\t\theader = kmalloc(HEADER_SIZE, GFP_KERNEL);\n\t\t\tif (!header) {\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tvheader = kmalloc(HEADER_SIZE, GFP_KERNEL);\n\t\t\tif (!vheader) {\n\t\t\t\tkfree(header);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tdev_dbg(dev, \"%s - Found Type BLANK FIRMWARE (Type F2) record\\n\",\n\t\t\t\t\t__func__);\n\n\t\t\t/*\n\t\t\t * In order to update the I2C firmware we must change\n\t\t\t * the type 2 record to type 0xF2. This will force the\n\t\t\t * UMP to come up in Boot Mode.  Then while in boot\n\t\t\t * mode, the driver will download the latest firmware\n\t\t\t * (padded to 15.5k) into the UMP ram. Finally when the\n\t\t\t * device comes back up in download mode the driver\n\t\t\t * will cause the new firmware to be copied from the\n\t\t\t * UMP Ram to I2C and the firmware will update the\n\t\t\t * record type from 0xf2 to 0x02.\n\t\t\t */\n\t\t\tstatus = build_i2c_fw_hdr(header, fw);\n\t\t\tif (status) {\n\t\t\t\tkfree(vheader);\n\t\t\t\tkfree(header);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Update I2C with type 0xf2 record with correct\n\t\t\t * size and checksum\n\t\t\t */\n\t\t\tstatus = write_rom(serial,\n\t\t\t\t\t\tstart_address,\n\t\t\t\t\t\tHEADER_SIZE,\n\t\t\t\t\t\theader);\n\t\t\tif (status) {\n\t\t\t\tkfree(vheader);\n\t\t\t\tkfree(header);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * verify the write -- must do this in order for\n\t\t\t * write to complete before we do the hardware reset\n\t\t\t */\n\t\t\tstatus = read_rom(serial, start_address,\n\t\t\t\t\t\t\tHEADER_SIZE, vheader);\n\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(dev, \"%s - can't read header back\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\tkfree(vheader);\n\t\t\t\tkfree(header);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t\tif (memcmp(vheader, header, HEADER_SIZE)) {\n\t\t\t\tdev_dbg(dev, \"%s - write download record failed\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\tkfree(vheader);\n\t\t\t\tkfree(header);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tkfree(vheader);\n\t\t\tkfree(header);\n\n\t\t\tdev_dbg(dev, \"%s - Start firmware update\\n\", __func__);\n\n\t\t\t/* Tell firmware to copy download image into I2C */\n\t\t\tstatus = ti_vsend_sync(serial->serial->dev,\n\t\t\t\t\tUMPC_COPY_DNLD_TO_I2C,\n\t\t\t\t\t0, 0, NULL, 0,\n\t\t\t\t\tTI_VSEND_TIMEOUT_FW_DOWNLOAD);\n\n\t\t\tdev_dbg(dev, \"%s - Update complete 0x%x\\n\", __func__,\n\t\t\t\t\tstatus);\n\t\t\tif (status) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"%s - UMPC_COPY_DNLD_TO_I2C failed\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* The device is running the download code */\n\tkfree(rom_desc);\n\tkfree(ti_manuf_desc);\n\treturn 0;\n}\n\nstatic int do_boot_mode(struct edgeport_serial *serial,\n\t\tconst struct firmware *fw)\n{\n\tstruct device *dev = &serial->serial->interface->dev;\n\tint status = 0;\n\tstruct edge_ti_manuf_descriptor *ti_manuf_desc;\n\tstruct edgeport_fw_hdr *fw_hdr = (struct edgeport_fw_hdr *)fw->data;\n\n\tdev_dbg(dev, \"%s - RUNNING IN BOOT MODE\\n\", __func__);\n\n\t/* Configure the TI device so we can use the BULK pipes for download */\n\tstatus = config_boot_dev(serial->serial->dev);\n\tif (status)\n\t\treturn status;\n\n\tif (le16_to_cpu(serial->serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t\t!= USB_VENDOR_ID_ION) {\n\t\tdev_dbg(dev, \"%s - VID = 0x%x\\n\", __func__,\n\t\t\tle16_to_cpu(serial->serial->dev->descriptor.idVendor));\n\t\tserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;\n\t\tgoto stayinbootmode;\n\t}\n\n\t/*\n\t * We have an ION device (I2c Must be programmed)\n\t * Determine I2C image type\n\t */\n\tif (i2c_type_bootmode(serial))\n\t\tgoto stayinbootmode;\n\n\t/* Check for ION Vendor ID and that the I2C is valid */\n\tif (!check_i2c_image(serial)) {\n\t\tstruct ti_i2c_image_header *header;\n\t\tint i;\n\t\t__u8 cs = 0;\n\t\t__u8 *buffer;\n\t\tint buffer_size;\n\n\t\t/*\n\t\t * Validate Hardware version number\n\t\t * Read Manufacturing Descriptor from TI Based Edgeport\n\t\t */\n\t\tti_manuf_desc = kmalloc(sizeof(*ti_manuf_desc), GFP_KERNEL);\n\t\tif (!ti_manuf_desc)\n\t\t\treturn -ENOMEM;\n\n\t\tstatus = get_manuf_info(serial, (__u8 *)ti_manuf_desc);\n\t\tif (status) {\n\t\t\tkfree(ti_manuf_desc);\n\t\t\tgoto stayinbootmode;\n\t\t}\n\n\t\t/* Check for version 2 */\n\t\tif (!ignore_cpu_rev && ti_cpu_rev(ti_manuf_desc) < 2) {\n\t\t\tdev_dbg(dev, \"%s - Wrong CPU Rev %d (Must be 2)\\n\",\n\t\t\t\t__func__, ti_cpu_rev(ti_manuf_desc));\n\t\t\tkfree(ti_manuf_desc);\n\t\t\tgoto stayinbootmode;\n\t\t}\n\n\t\tkfree(ti_manuf_desc);\n\n\t\t/*\n\t\t * In order to update the I2C firmware we must change the type\n\t\t * 2 record to type 0xF2. This will force the UMP to come up\n\t\t * in Boot Mode.  Then while in boot mode, the driver will\n\t\t * download the latest firmware (padded to 15.5k) into the\n\t\t * UMP ram. Finally when the device comes back up in download\n\t\t * mode the driver will cause the new firmware to be copied\n\t\t * from the UMP Ram to I2C and the firmware will update the\n\t\t * record type from 0xf2 to 0x02.\n\t\t *\n\t\t * Do we really have to copy the whole firmware image,\n\t\t * or could we do this in place!\n\t\t */\n\n\t\t/* Allocate a 15.5k buffer + 3 byte header */\n\t\tbuffer_size = (((1024 * 16) - 512) +\n\t\t\t\t\tsizeof(struct ti_i2c_image_header));\n\t\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Initialize the buffer to 0xff (pad the buffer) */\n\t\tmemset(buffer, 0xff, buffer_size);\n\t\tmemcpy(buffer, &fw->data[4], fw->size - 4);\n\n\t\tfor (i = sizeof(struct ti_i2c_image_header);\n\t\t\t\ti < buffer_size; i++) {\n\t\t\tcs = (__u8)(cs + buffer[i]);\n\t\t}\n\n\t\theader = (struct ti_i2c_image_header *)buffer;\n\n\t\t/* update length and checksum after padding */\n\t\theader->Length \t = cpu_to_le16((__u16)(buffer_size -\n\t\t\t\t\tsizeof(struct ti_i2c_image_header)));\n\t\theader->CheckSum = cs;\n\n\t\t/* Download the operational code  */\n\t\tdev_dbg(dev, \"%s - Downloading operational code image version %d.%d (TI UMP)\\n\",\n\t\t\t\t__func__,\n\t\t\t\tfw_hdr->major_version, fw_hdr->minor_version);\n\t\tstatus = download_code(serial, buffer, buffer_size);\n\n\t\tkfree(buffer);\n\n\t\tif (status) {\n\t\t\tdev_dbg(dev, \"%s - Error downloading operational code image\\n\", __func__);\n\t\t\treturn status;\n\t\t}\n\n\t\t/* Device will reboot */\n\t\tserial->product_info.TiMode = TI_MODE_TRANSITIONING;\n\n\t\tdev_dbg(dev, \"%s - Download successful -- Device rebooting...\\n\", __func__);\n\n\t\treturn 1;\n\t}\n\nstayinbootmode:\n\t/* Eprom is invalid or blank stay in boot mode */\n\tdev_dbg(dev, \"%s - STAYING IN BOOT MODE\\n\", __func__);\n\tserial->product_info.TiMode = TI_MODE_BOOT;\n\n\treturn 1;\n}\n\nstatic int ti_do_config(struct edgeport_port *port, int feature, int on)\n{\n\tint port_number = port->port->port_number;\n\n\ton = !!on;\t/* 1 or 0 not bitmask */\n\treturn send_cmd(port->port->serial->dev,\n\t\t\tfeature, (__u8)(UMPM_UART1_PORT + port_number),\n\t\t\ton, NULL, 0);\n}\n\nstatic int restore_mcr(struct edgeport_port *port, __u8 mcr)\n{\n\tint status = 0;\n\n\tdev_dbg(&port->port->dev, \"%s - %x\\n\", __func__, mcr);\n\n\tstatus = ti_do_config(port, UMPC_SET_CLR_DTR, mcr & MCR_DTR);\n\tif (status)\n\t\treturn status;\n\tstatus = ti_do_config(port, UMPC_SET_CLR_RTS, mcr & MCR_RTS);\n\tif (status)\n\t\treturn status;\n\treturn ti_do_config(port, UMPC_SET_CLR_LOOPBACK, mcr & MCR_LOOPBACK);\n}\n\n/* Convert TI LSR to standard UART flags */\nstatic __u8 map_line_status(__u8 ti_lsr)\n{\n\t__u8 lsr = 0;\n\n#define MAP_FLAG(flagUmp, flagUart)    \\\n\tif (ti_lsr & flagUmp) \\\n\t\tlsr |= flagUart;\n\n\tMAP_FLAG(UMP_UART_LSR_OV_MASK, LSR_OVER_ERR)\t/* overrun */\n\tMAP_FLAG(UMP_UART_LSR_PE_MASK, LSR_PAR_ERR)\t/* parity error */\n\tMAP_FLAG(UMP_UART_LSR_FE_MASK, LSR_FRM_ERR)\t/* framing error */\n\tMAP_FLAG(UMP_UART_LSR_BR_MASK, LSR_BREAK)\t/* break detected */\n\tMAP_FLAG(UMP_UART_LSR_RX_MASK, LSR_RX_AVAIL)\t/* rx data available */\n\tMAP_FLAG(UMP_UART_LSR_TX_MASK, LSR_TX_EMPTY)\t/* tx hold reg empty */\n\n#undef MAP_FLAG\n\n\treturn lsr;\n}\n\nstatic void handle_new_msr(struct edgeport_port *edge_port, __u8 msr)\n{\n\tstruct async_icount *icount;\n\tstruct tty_struct *tty;\n\n\tdev_dbg(&edge_port->port->dev, \"%s - %02x\\n\", __func__, msr);\n\n\tif (msr & (EDGEPORT_MSR_DELTA_CTS | EDGEPORT_MSR_DELTA_DSR |\n\t\t\tEDGEPORT_MSR_DELTA_RI | EDGEPORT_MSR_DELTA_CD)) {\n\t\ticount = &edge_port->port->icount;\n\n\t\t/* update input line counters */\n\t\tif (msr & EDGEPORT_MSR_DELTA_CTS)\n\t\t\ticount->cts++;\n\t\tif (msr & EDGEPORT_MSR_DELTA_DSR)\n\t\t\ticount->dsr++;\n\t\tif (msr & EDGEPORT_MSR_DELTA_CD)\n\t\t\ticount->dcd++;\n\t\tif (msr & EDGEPORT_MSR_DELTA_RI)\n\t\t\ticount->rng++;\n\t\twake_up_interruptible(&edge_port->port->port.delta_msr_wait);\n\t}\n\n\t/* Save the new modem status */\n\tedge_port->shadow_msr = msr & 0xf0;\n\n\ttty = tty_port_tty_get(&edge_port->port->port);\n\t/* handle CTS flow control */\n\tif (tty && C_CRTSCTS(tty)) {\n\t\tif (msr & EDGEPORT_MSR_CTS)\n\t\t\ttty_wakeup(tty);\n\t}\n\ttty_kref_put(tty);\n}\n\nstatic void handle_new_lsr(struct edgeport_port *edge_port, int lsr_data,\n\t\t\t\t\t\t\t__u8 lsr, __u8 data)\n{\n\tstruct async_icount *icount;\n\t__u8 new_lsr = (__u8)(lsr & (__u8)(LSR_OVER_ERR | LSR_PAR_ERR |\n\t\t\t\t\t\tLSR_FRM_ERR | LSR_BREAK));\n\n\tdev_dbg(&edge_port->port->dev, \"%s - %02x\\n\", __func__, new_lsr);\n\n\tedge_port->shadow_lsr = lsr;\n\n\tif (new_lsr & LSR_BREAK)\n\t\t/*\n\t\t * Parity and Framing errors only count if they\n\t\t * occur exclusive of a break being received.\n\t\t */\n\t\tnew_lsr &= (__u8)(LSR_OVER_ERR | LSR_BREAK);\n\n\t/* Place LSR data byte into Rx buffer */\n\tif (lsr_data)\n\t\tedge_tty_recv(edge_port->port, &data, 1);\n\n\t/* update input line counters */\n\ticount = &edge_port->port->icount;\n\tif (new_lsr & LSR_BREAK)\n\t\ticount->brk++;\n\tif (new_lsr & LSR_OVER_ERR)\n\t\ticount->overrun++;\n\tif (new_lsr & LSR_PAR_ERR)\n\t\ticount->parity++;\n\tif (new_lsr & LSR_FRM_ERR)\n\t\ticount->frame++;\n}\n\nstatic void edge_interrupt_callback(struct urb *urb)\n{\n\tstruct edgeport_serial *edge_serial = urb->context;\n\tstruct usb_serial_port *port;\n\tstruct edgeport_port *edge_port;\n\tstruct device *dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint length = urb->actual_length;\n\tint port_number;\n\tint function;\n\tint retval;\n\t__u8 lsr;\n\t__u8 msr;\n\tint status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t/* this urb is terminated, clean up */\n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t    __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"%s - nonzero urb status received: \"\n\t\t\t\"%d\\n\", __func__, status);\n\t\tgoto exit;\n\t}\n\n\tif (!length) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - no data in urb\\n\", __func__);\n\t\tgoto exit;\n\t}\n\n\tdev = &edge_serial->serial->dev->dev;\n\tusb_serial_debug_data(dev, __func__, length, data);\n\n\tif (length != 2) {\n\t\tdev_dbg(dev, \"%s - expecting packet of size 2, got %d\\n\", __func__, length);\n\t\tgoto exit;\n\t}\n\n\tport_number = TIUMP_GET_PORT_FROM_CODE(data[0]);\n\tfunction    = TIUMP_GET_FUNC_FROM_CODE(data[0]);\n\tdev_dbg(dev, \"%s - port_number %d, function %d, info 0x%x\\n\", __func__,\n\t\tport_number, function, data[1]);\n\n\tif (port_number >= edge_serial->serial->num_ports) {\n\t\tdev_err(dev, \"bad port number %d\\n\", port_number);\n\t\tgoto exit;\n\t}\n\n\tport = edge_serial->serial->port[port_number];\n\tedge_port = usb_get_serial_port_data(port);\n\tif (!edge_port) {\n\t\tdev_dbg(dev, \"%s - edge_port not found\\n\", __func__);\n\t\treturn;\n\t}\n\tswitch (function) {\n\tcase TIUMP_INTERRUPT_CODE_LSR:\n\t\tlsr = map_line_status(data[1]);\n\t\tif (lsr & UMP_UART_LSR_DATA_MASK) {\n\t\t\t/*\n\t\t\t * Save the LSR event for bulk read completion routine\n\t\t\t */\n\t\t\tdev_dbg(dev, \"%s - LSR Event Port %u LSR Status = %02x\\n\",\n\t\t\t\t__func__, port_number, lsr);\n\t\t\tedge_port->lsr_event = 1;\n\t\t\tedge_port->lsr_mask = lsr;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"%s - ===== Port %d LSR Status = %02x ======\\n\",\n\t\t\t\t__func__, port_number, lsr);\n\t\t\thandle_new_lsr(edge_port, 0, lsr, 0);\n\t\t}\n\t\tbreak;\n\n\tcase TIUMP_INTERRUPT_CODE_MSR:\t/* MSR */\n\t\t/* Copy MSR from UMP */\n\t\tmsr = data[1];\n\t\tdev_dbg(dev, \"%s - ===== Port %u MSR Status = %02x ======\\n\",\n\t\t\t__func__, port_number, msr);\n\t\thandle_new_msr(edge_port, msr);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\"%s - Unknown Interrupt code from UMP %x\\n\",\n\t\t\t__func__, data[1]);\n\t\tbreak;\n\n\t}\n\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t __func__, retval);\n}\n\nstatic void edge_bulk_in_callback(struct urb *urb)\n{\n\tstruct edgeport_port *edge_port = urb->context;\n\tstruct device *dev = &edge_port->port->dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint retval = 0;\n\tint port_number;\n\tint status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t/* this urb is terminated, clean up */\n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"%s - nonzero read bulk status received: %d\\n\", __func__, status);\n\t}\n\n\tif (status == -EPIPE)\n\t\tgoto exit;\n\n\tif (status) {\n\t\tdev_err(&urb->dev->dev, \"%s - stopping read!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tport_number = edge_port->port->port_number;\n\n\tif (urb->actual_length > 0 && edge_port->lsr_event) {\n\t\tedge_port->lsr_event = 0;\n\t\tdev_dbg(dev, \"%s ===== Port %u LSR Status = %02x, Data = %02x ======\\n\",\n\t\t\t__func__, port_number, edge_port->lsr_mask, *data);\n\t\thandle_new_lsr(edge_port, 1, edge_port->lsr_mask, *data);\n\t\t/* Adjust buffer length/pointer */\n\t\t--urb->actual_length;\n\t\t++data;\n\t}\n\n\tif (urb->actual_length) {\n\t\tusb_serial_debug_data(dev, __func__, urb->actual_length, data);\n\t\tif (edge_port->close_pending)\n\t\t\tdev_dbg(dev, \"%s - close pending, dropping data on the floor\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\telse\n\t\t\tedge_tty_recv(edge_port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\tedge_port->port->icount.rx += urb->actual_length;\n\t}\n\nexit:\n\t/* continue read unless stopped */\n\tspin_lock(&edge_port->ep_lock);\n\tif (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)\n\t\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\telse if (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPING)\n\t\tedge_port->ep_read_urb_state = EDGE_READ_URB_STOPPED;\n\n\tspin_unlock(&edge_port->ep_lock);\n\tif (retval)\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result %d\\n\", __func__, retval);\n}\n\nstatic void edge_tty_recv(struct usb_serial_port *port, unsigned char *data,\n\t\tint length)\n{\n\tint queued;\n\n\tqueued = tty_insert_flip_string(&port->port, data, length);\n\tif (queued < length)\n\t\tdev_err(&port->dev, \"%s - dropping data, %d bytes lost\\n\",\n\t\t\t__func__, length - queued);\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic void edge_bulk_out_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint status = urb->status;\n\tstruct tty_struct *tty;\n\n\tedge_port->ep_write_urb_in_use = 0;\n\n\tswitch (status) {\n\tcase 0:\n\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t/* this urb is terminated, clean up */\n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t    __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err_console(port, \"%s - nonzero write bulk status \"\n\t\t\t\"received: %d\\n\", __func__, status);\n\t}\n\n\t/* send any buffered data */\n\ttty = tty_port_tty_get(&port->port);\n\tedge_send(port, tty);\n\ttty_kref_put(tty);\n}\n\nstatic int edge_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tstruct edgeport_serial *edge_serial;\n\tstruct usb_device *dev;\n\tstruct urb *urb;\n\tint port_number;\n\tint status;\n\tu16 open_settings;\n\tu8 transaction_timeout;\n\n\tif (edge_port == NULL)\n\t\treturn -ENODEV;\n\n\tport_number = port->port_number;\n\n\tdev = port->serial->dev;\n\n\t/* turn off loopback */\n\tstatus = ti_do_config(edge_port, UMPC_SET_CLR_LOOPBACK, 0);\n\tif (status) {\n\t\tdev_err(&port->dev,\n\t\t\t\t\"%s - cannot send clear loopback command, %d\\n\",\n\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\t/* set up the port settings */\n\tif (tty)\n\t\tedge_set_termios(tty, port, &tty->termios);\n\n\t/* open up the port */\n\n\t/* milliseconds to timeout for DMA transfer */\n\ttransaction_timeout = 2;\n\n\tedge_port->ump_read_timeout =\n\t\t\t\tmax(20, ((transaction_timeout * 3) / 2));\n\n\t/* milliseconds to timeout for DMA transfer */\n\topen_settings = (u8)(UMP_DMA_MODE_CONTINOUS |\n\t\t\t     UMP_PIPE_TRANS_TIMEOUT_ENA |\n\t\t\t     (transaction_timeout << 2));\n\n\tdev_dbg(&port->dev, \"%s - Sending UMPC_OPEN_PORT\\n\", __func__);\n\n\t/* Tell TI to open and start the port */\n\tstatus = send_cmd(dev, UMPC_OPEN_PORT,\n\t\t(u8)(UMPM_UART1_PORT + port_number), open_settings, NULL, 0);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s - cannot send open command, %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\t/* Start the DMA? */\n\tstatus = send_cmd(dev, UMPC_START_PORT,\n\t\t(u8)(UMPM_UART1_PORT + port_number), 0, NULL, 0);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s - cannot send start DMA command, %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\t/* Clear TX and RX buffers in UMP */\n\tstatus = purge_port(port, UMP_PORT_DIR_OUT | UMP_PORT_DIR_IN);\n\tif (status) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - cannot send clear buffers command, %d\\n\",\n\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\t/* Read Initial MSR */\n\tstatus = ti_vread_sync(dev, UMPC_READ_MSR, 0,\n\t\t\t\t(__u16)(UMPM_UART1_PORT + port_number),\n\t\t\t\t&edge_port->shadow_msr, 1);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s - cannot send read MSR command, %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\tdev_dbg(&port->dev, \"ShadowMSR 0x%X\\n\", edge_port->shadow_msr);\n\n\t/* Set Initial MCR */\n\tedge_port->shadow_mcr = MCR_RTS | MCR_DTR;\n\tdev_dbg(&port->dev, \"ShadowMCR 0x%X\\n\", edge_port->shadow_mcr);\n\n\tedge_serial = edge_port->edge_serial;\n\tif (mutex_lock_interruptible(&edge_serial->es_lock))\n\t\treturn -ERESTARTSYS;\n\tif (edge_serial->num_ports_open == 0) {\n\t\t/* we are the first port to open, post the interrupt urb */\n\t\turb = edge_serial->serial->port[0]->interrupt_in_urb;\n\t\turb->context = edge_serial;\n\t\tstatus = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (status) {\n\t\t\tdev_err(&port->dev,\n\t\t\t\t\"%s - usb_submit_urb failed with value %d\\n\",\n\t\t\t\t\t__func__, status);\n\t\t\tgoto release_es_lock;\n\t\t}\n\t}\n\n\t/*\n\t * reset the data toggle on the bulk endpoints to work around bug in\n\t * host controllers where things get out of sync some times\n\t */\n\tusb_clear_halt(dev, port->write_urb->pipe);\n\tusb_clear_halt(dev, port->read_urb->pipe);\n\n\t/* start up our bulk read urb */\n\turb = port->read_urb;\n\tedge_port->ep_read_urb_state = EDGE_READ_URB_RUNNING;\n\turb->context = edge_port;\n\tstatus = usb_submit_urb(urb, GFP_KERNEL);\n\tif (status) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - read bulk usb_submit_urb failed with value %d\\n\",\n\t\t\t\t__func__, status);\n\t\tgoto unlink_int_urb;\n\t}\n\n\t++edge_serial->num_ports_open;\n\n\tgoto release_es_lock;\n\nunlink_int_urb:\n\tif (edge_port->edge_serial->num_ports_open == 0)\n\t\tusb_kill_urb(port->serial->port[0]->interrupt_in_urb);\nrelease_es_lock:\n\tmutex_unlock(&edge_serial->es_lock);\n\treturn status;\n}\n\nstatic void edge_close(struct usb_serial_port *port)\n{\n\tstruct edgeport_serial *edge_serial;\n\tstruct edgeport_port *edge_port;\n\tstruct usb_serial *serial = port->serial;\n\tunsigned long flags;\n\tint port_number;\n\n\tedge_serial = usb_get_serial_data(port->serial);\n\tedge_port = usb_get_serial_port_data(port);\n\tif (edge_serial == NULL || edge_port == NULL)\n\t\treturn;\n\n\t/*\n\t * The bulkreadcompletion routine will check\n\t * this flag and dump add read data\n\t */\n\tedge_port->close_pending = 1;\n\n\tusb_kill_urb(port->read_urb);\n\tusb_kill_urb(port->write_urb);\n\tedge_port->ep_write_urb_in_use = 0;\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\tkfifo_reset_out(&port->write_fifo);\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - send umpc_close_port\\n\", __func__);\n\tport_number = port->port_number;\n\tsend_cmd(serial->dev, UMPC_CLOSE_PORT,\n\t\t     (__u8)(UMPM_UART1_PORT + port_number), 0, NULL, 0);\n\n\tmutex_lock(&edge_serial->es_lock);\n\t--edge_port->edge_serial->num_ports_open;\n\tif (edge_port->edge_serial->num_ports_open <= 0) {\n\t\t/* last port is now closed, let's shut down our interrupt urb */\n\t\tusb_kill_urb(port->serial->port[0]->interrupt_in_urb);\n\t\tedge_port->edge_serial->num_ports_open = 0;\n\t}\n\tmutex_unlock(&edge_serial->es_lock);\n\tedge_port->close_pending = 0;\n}\n\nstatic int edge_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\t\tconst unsigned char *data, int count)\n{\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\n\tif (count == 0) {\n\t\tdev_dbg(&port->dev, \"%s - write request of 0 bytes\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tif (edge_port == NULL)\n\t\treturn -ENODEV;\n\tif (edge_port->close_pending == 1)\n\t\treturn -ENODEV;\n\n\tcount = kfifo_in_locked(&port->write_fifo, data, count,\n\t\t\t\t\t\t\t&edge_port->ep_lock);\n\tedge_send(port, tty);\n\n\treturn count;\n}\n\nstatic void edge_send(struct usb_serial_port *port, struct tty_struct *tty)\n{\n\tint count, result;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\n\tif (edge_port->ep_write_urb_in_use) {\n\t\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\t\treturn;\n\t}\n\n\tcount = kfifo_out(&port->write_fifo,\n\t\t\t\tport->write_urb->transfer_buffer,\n\t\t\t\tport->bulk_out_size);\n\n\tif (count == 0) {\n\t\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\t\treturn;\n\t}\n\n\tedge_port->ep_write_urb_in_use = 1;\n\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\tusb_serial_debug_data(&port->dev, __func__, count, port->write_urb->transfer_buffer);\n\n\t/* set up our urb */\n\tport->write_urb->transfer_buffer_length = count;\n\n\t/* send the data out the bulk port */\n\tresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\n\tif (result) {\n\t\tdev_err_console(port,\n\t\t\t\"%s - failed submitting write urb, error %d\\n\",\n\t\t\t\t__func__, result);\n\t\tedge_port->ep_write_urb_in_use = 0;\n\t\t/* TODO: reschedule edge_send */\n\t} else\n\t\tedge_port->port->icount.tx += count;\n\n\t/*\n\t * wakeup any process waiting for writes to complete\n\t * there is now more room in the buffer for new writes\n\t */\n\tif (tty)\n\t\ttty_wakeup(tty);\n}\n\nstatic int edge_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint room = 0;\n\tunsigned long flags;\n\n\tif (edge_port == NULL)\n\t\treturn 0;\n\tif (edge_port->close_pending == 1)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\troom = kfifo_avail(&port->write_fifo);\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - returns %d\\n\", __func__, room);\n\treturn room;\n}\n\nstatic int edge_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint chars = 0;\n\tunsigned long flags;\n\tif (edge_port == NULL)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\tchars = kfifo_len(&port->write_fifo);\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - returns %d\\n\", __func__, chars);\n\treturn chars;\n}\n\nstatic bool edge_tx_empty(struct usb_serial_port *port)\n{\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint ret;\n\n\tret = tx_active(edge_port);\n\tif (ret > 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void edge_throttle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint status;\n\n\tif (edge_port == NULL)\n\t\treturn;\n\n\t/* if we are implementing XON/XOFF, send the stop character */\n\tif (I_IXOFF(tty)) {\n\t\tunsigned char stop_char = STOP_CHAR(tty);\n\t\tstatus = edge_write(tty, port, &stop_char, 1);\n\t\tif (status <= 0) {\n\t\t\tdev_err(&port->dev, \"%s - failed to write stop character, %d\\n\", __func__, status);\n\t\t}\n\t}\n\n\t/*\n\t * if we are implementing RTS/CTS, stop reads\n\t * and the Edgeport will clear the RTS line\n\t */\n\tif (C_CRTSCTS(tty))\n\t\tstop_read(edge_port);\n\n}\n\nstatic void edge_unthrottle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint status;\n\n\tif (edge_port == NULL)\n\t\treturn;\n\n\t/* if we are implementing XON/XOFF, send the start character */\n\tif (I_IXOFF(tty)) {\n\t\tunsigned char start_char = START_CHAR(tty);\n\t\tstatus = edge_write(tty, port, &start_char, 1);\n\t\tif (status <= 0) {\n\t\t\tdev_err(&port->dev, \"%s - failed to write start character, %d\\n\", __func__, status);\n\t\t}\n\t}\n\t/*\n\t * if we are implementing RTS/CTS, restart reads\n\t * are the Edgeport will assert the RTS line\n\t */\n\tif (C_CRTSCTS(tty)) {\n\t\tstatus = restart_read(edge_port);\n\t\tif (status)\n\t\t\tdev_err(&port->dev,\n\t\t\t\t\"%s - read bulk usb_submit_urb failed: %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t}\n\n}\n\nstatic void stop_read(struct edgeport_port *edge_port)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\n\tif (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)\n\t\tedge_port->ep_read_urb_state = EDGE_READ_URB_STOPPING;\n\tedge_port->shadow_mcr &= ~MCR_RTS;\n\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n}\n\nstatic int restart_read(struct edgeport_port *edge_port)\n{\n\tstruct urb *urb;\n\tint status = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\n\tif (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPED) {\n\t\turb = edge_port->port->read_urb;\n\t\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\t}\n\tedge_port->ep_read_urb_state = EDGE_READ_URB_RUNNING;\n\tedge_port->shadow_mcr |= MCR_RTS;\n\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\treturn status;\n}\n\nstatic void change_port_settings(struct tty_struct *tty,\n\t\tstruct edgeport_port *edge_port, struct ktermios *old_termios)\n{\n\tstruct device *dev = &edge_port->port->dev;\n\tstruct ump_uart_config *config;\n\tint baud;\n\tunsigned cflag;\n\tint status;\n\tint port_number = edge_port->port->port_number;\n\n\tconfig = kmalloc (sizeof (*config), GFP_KERNEL);\n\tif (!config) {\n\t\ttty->termios = *old_termios;\n\t\treturn;\n\t}\n\n\tcflag = tty->termios.c_cflag;\n\n\tconfig->wFlags = 0;\n\n\t/* These flags must be set */\n\tconfig->wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT;\n\tconfig->wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR;\n\tconfig->bUartMode = (__u8)(edge_port->bUartMode);\n\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\t    config->bDataBits = UMP_UART_CHAR5BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 5\\n\", __func__);\n\t\t    break;\n\tcase CS6:\n\t\t    config->bDataBits = UMP_UART_CHAR6BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 6\\n\", __func__);\n\t\t    break;\n\tcase CS7:\n\t\t    config->bDataBits = UMP_UART_CHAR7BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 7\\n\", __func__);\n\t\t    break;\n\tdefault:\n\tcase CS8:\n\t\t    config->bDataBits = UMP_UART_CHAR8BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 8\\n\", __func__);\n\t\t\t    break;\n\t}\n\n\tif (cflag & PARENB) {\n\t\tif (cflag & PARODD) {\n\t\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_PARITY;\n\t\t\tconfig->bParity = UMP_UART_ODDPARITY;\n\t\t\tdev_dbg(dev, \"%s - parity = odd\\n\", __func__);\n\t\t} else {\n\t\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_PARITY;\n\t\t\tconfig->bParity = UMP_UART_EVENPARITY;\n\t\t\tdev_dbg(dev, \"%s - parity = even\\n\", __func__);\n\t\t}\n\t} else {\n\t\tconfig->bParity = UMP_UART_NOPARITY;\n\t\tdev_dbg(dev, \"%s - parity = none\\n\", __func__);\n\t}\n\n\tif (cflag & CSTOPB) {\n\t\tconfig->bStopBits = UMP_UART_STOPBIT2;\n\t\tdev_dbg(dev, \"%s - stop bits = 2\\n\", __func__);\n\t} else {\n\t\tconfig->bStopBits = UMP_UART_STOPBIT1;\n\t\tdev_dbg(dev, \"%s - stop bits = 1\\n\", __func__);\n\t}\n\n\t/* figure out the flow control settings */\n\tif (cflag & CRTSCTS) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_OUT_X_CTS_FLOW;\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_RTS_FLOW;\n\t\tdev_dbg(dev, \"%s - RTS/CTS is enabled\\n\", __func__);\n\t} else {\n\t\tdev_dbg(dev, \"%s - RTS/CTS is disabled\\n\", __func__);\n\t\trestart_read(edge_port);\n\t}\n\n\t/*\n\t * if we are implementing XON/XOFF, set the start and stop\n\t * character in the device\n\t */\n\tconfig->cXon  = START_CHAR(tty);\n\tconfig->cXoff = STOP_CHAR(tty);\n\n\t/* if we are implementing INBOUND XON/XOFF */\n\tif (I_IXOFF(tty)) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_IN_X;\n\t\tdev_dbg(dev, \"%s - INBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\\n\",\n\t\t\t__func__, config->cXon, config->cXoff);\n\t} else\n\t\tdev_dbg(dev, \"%s - INBOUND XON/XOFF is disabled\\n\", __func__);\n\n\t/* if we are implementing OUTBOUND XON/XOFF */\n\tif (I_IXON(tty)) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_OUT_X;\n\t\tdev_dbg(dev, \"%s - OUTBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\\n\",\n\t\t\t__func__, config->cXon, config->cXoff);\n\t} else\n\t\tdev_dbg(dev, \"%s - OUTBOUND XON/XOFF is disabled\\n\", __func__);\n\n\ttty->termios.c_cflag &= ~CMSPAR;\n\n\t/* Round the baud rate */\n\tbaud = tty_get_baud_rate(tty);\n\tif (!baud) {\n\t\t/* pick a default, any default... */\n\t\tbaud = 9600;\n\t} else\n\t\ttty_encode_baud_rate(tty, baud, baud);\n\n\tedge_port->baud_rate = baud;\n\tconfig->wBaudRate = (__u16)((461550L + baud/2) / baud);\n\n\t/* FIXME: Recompute actual baud from divisor here */\n\n\tdev_dbg(dev, \"%s - baud rate = %d, wBaudRate = %d\\n\", __func__, baud, config->wBaudRate);\n\n\tdev_dbg(dev, \"wBaudRate:   %d\\n\", (int)(461550L / config->wBaudRate));\n\tdev_dbg(dev, \"wFlags:    0x%x\\n\", config->wFlags);\n\tdev_dbg(dev, \"bDataBits:   %d\\n\", config->bDataBits);\n\tdev_dbg(dev, \"bParity:     %d\\n\", config->bParity);\n\tdev_dbg(dev, \"bStopBits:   %d\\n\", config->bStopBits);\n\tdev_dbg(dev, \"cXon:        %d\\n\", config->cXon);\n\tdev_dbg(dev, \"cXoff:       %d\\n\", config->cXoff);\n\tdev_dbg(dev, \"bUartMode:   %d\\n\", config->bUartMode);\n\n\t/* move the word values into big endian mode */\n\tcpu_to_be16s(&config->wFlags);\n\tcpu_to_be16s(&config->wBaudRate);\n\n\tstatus = send_cmd(edge_port->port->serial->dev, UMPC_SET_CONFIG,\n\t\t\t\t(__u8)(UMPM_UART1_PORT + port_number),\n\t\t\t\t0, (__u8 *)config, sizeof(*config));\n\tif (status)\n\t\tdev_dbg(dev, \"%s - error %d when trying to write config to device\\n\",\n\t\t\t__func__, status);\n\tkfree(config);\n}\n\nstatic void edge_set_termios(struct tty_struct *tty,\n\t\tstruct usb_serial_port *port, struct ktermios *old_termios)\n{\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\n\tif (edge_port == NULL)\n\t\treturn;\n\t/* change the port settings to the new ones specified */\n\tchange_port_settings(tty, edge_port, old_termios);\n}\n\nstatic int edge_tiocmset(struct tty_struct *tty,\n\t\t\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tunsigned int mcr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\tmcr = edge_port->shadow_mcr;\n\tif (set & TIOCM_RTS)\n\t\tmcr |= MCR_RTS;\n\tif (set & TIOCM_DTR)\n\t\tmcr |= MCR_DTR;\n\tif (set & TIOCM_LOOP)\n\t\tmcr |= MCR_LOOPBACK;\n\n\tif (clear & TIOCM_RTS)\n\t\tmcr &= ~MCR_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tmcr &= ~MCR_DTR;\n\tif (clear & TIOCM_LOOP)\n\t\tmcr &= ~MCR_LOOPBACK;\n\n\tedge_port->shadow_mcr = mcr;\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\trestore_mcr(edge_port, mcr);\n\treturn 0;\n}\n\nstatic int edge_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tunsigned int result = 0;\n\tunsigned int msr;\n\tunsigned int mcr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\n\tmsr = edge_port->shadow_msr;\n\tmcr = edge_port->shadow_mcr;\n\tresult = ((mcr & MCR_DTR)\t? TIOCM_DTR: 0)\t  /* 0x002 */\n\t\t  | ((mcr & MCR_RTS)\t? TIOCM_RTS: 0)   /* 0x004 */\n\t\t  | ((msr & EDGEPORT_MSR_CTS)\t? TIOCM_CTS: 0)   /* 0x020 */\n\t\t  | ((msr & EDGEPORT_MSR_CD)\t? TIOCM_CAR: 0)   /* 0x040 */\n\t\t  | ((msr & EDGEPORT_MSR_RI)\t? TIOCM_RI:  0)   /* 0x080 */\n\t\t  | ((msr & EDGEPORT_MSR_DSR)\t? TIOCM_DSR: 0);  /* 0x100 */\n\n\n\tdev_dbg(&port->dev, \"%s -- %x\\n\", __func__, result);\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\treturn result;\n}\n\nstatic int get_serial_info(struct edgeport_port *edge_port,\n\t\t\t\tstruct serial_struct __user *retinfo)\n{\n\tstruct serial_struct tmp;\n\tunsigned cwait;\n\n\tcwait = edge_port->port->port.closing_wait;\n\tif (cwait != ASYNC_CLOSING_WAIT_NONE)\n\t\tcwait = jiffies_to_msecs(cwait) / 10;\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\n\ttmp.type\t\t= PORT_16550A;\n\ttmp.line\t\t= edge_port->port->minor;\n\ttmp.port\t\t= edge_port->port->port_number;\n\ttmp.irq\t\t\t= 0;\n\ttmp.xmit_fifo_size\t= edge_port->port->bulk_out_size;\n\ttmp.baud_base\t\t= 9600;\n\ttmp.close_delay\t\t= 5*HZ;\n\ttmp.closing_wait\t= cwait;\n\n\tif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int edge_ioctl(struct tty_struct *tty,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\n\tswitch (cmd) {\n\tcase TIOCGSERIAL:\n\t\tdev_dbg(&port->dev, \"%s - TIOCGSERIAL\\n\", __func__);\n\t\treturn get_serial_info(edge_port,\n\t\t\t\t(struct serial_struct __user *) arg);\n\t}\n\treturn -ENOIOCTLCMD;\n}\n\nstatic void edge_break(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint status;\n\tint bv = 0;\t/* Off */\n\n\tif (break_state == -1)\n\t\tbv = 1;\t/* On */\n\tstatus = ti_do_config(edge_port, UMPC_SET_CLR_BREAK, bv);\n\tif (status)\n\t\tdev_dbg(&port->dev, \"%s - error %d sending break set/clear command.\\n\",\n\t\t\t__func__, status);\n}\n\nstatic void edge_heartbeat_schedule(struct edgeport_serial *edge_serial)\n{\n\tif (!edge_serial->use_heartbeat)\n\t\treturn;\n\n\tschedule_delayed_work(&edge_serial->heartbeat_work,\n\t\t\tFW_HEARTBEAT_SECS * HZ);\n}\n\nstatic void edge_heartbeat_work(struct work_struct *work)\n{\n\tstruct edgeport_serial *serial;\n\tstruct ti_i2c_desc *rom_desc;\n\n\tserial = container_of(work, struct edgeport_serial,\n\t\t\theartbeat_work.work);\n\n\trom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\n\n\t/* Descriptor address request is enough to reset the firmware timer */\n\tif (!rom_desc || !get_descriptor_addr(serial, I2C_DESC_TYPE_ION,\n\t\t\trom_desc)) {\n\t\tdev_err(&serial->serial->interface->dev,\n\t\t\t\t\"%s - Incomplete heartbeat\\n\", __func__);\n\t}\n\tkfree(rom_desc);\n\n\tedge_heartbeat_schedule(serial);\n}\n\nstatic int edge_calc_num_ports(struct usb_serial *serial,\n\t\t\t\tstruct usb_serial_endpoints *epds)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tunsigned char num_ports = serial->type->num_ports;\n\n\t/* Make sure we have the required endpoints when in download mode. */\n\tif (serial->interface->cur_altsetting->desc.bNumEndpoints > 1) {\n\t\tif (epds->num_bulk_in < num_ports ||\n\t\t\t\tepds->num_bulk_out < num_ports ||\n\t\t\t\tepds->num_interrupt_in < 1) {\n\t\t\tdev_err(dev, \"required endpoints missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn num_ports;\n}\n\nstatic int edge_startup(struct usb_serial *serial)\n{\n\tstruct edgeport_serial *edge_serial;\n\tint status;\n\tu16 product_id;\n\n\t/* create our private serial structure */\n\tedge_serial = kzalloc(sizeof(struct edgeport_serial), GFP_KERNEL);\n\tif (!edge_serial)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&edge_serial->es_lock);\n\tedge_serial->serial = serial;\n\tINIT_DELAYED_WORK(&edge_serial->heartbeat_work, edge_heartbeat_work);\n\tusb_set_serial_data(serial, edge_serial);\n\n\tstatus = download_fw(edge_serial);\n\tif (status < 0) {\n\t\tkfree(edge_serial);\n\t\treturn status;\n\t}\n\n\tif (status > 0)\n\t\treturn 1;\t/* bind but do not register any ports */\n\n\tproduct_id = le16_to_cpu(\n\t\t\tedge_serial->serial->dev->descriptor.idProduct);\n\n\t/* Currently only the EP/416 models require heartbeat support */\n\tif (edge_serial->fw_version > FW_HEARTBEAT_VERSION_CUTOFF) {\n\t\tif (product_id == ION_DEVICE_ID_TI_EDGEPORT_416 ||\n\t\t\tproduct_id == ION_DEVICE_ID_TI_EDGEPORT_416B) {\n\t\t\tedge_serial->use_heartbeat = true;\n\t\t}\n\t}\n\n\tedge_heartbeat_schedule(edge_serial);\n\n\treturn 0;\n}\n\nstatic void edge_disconnect(struct usb_serial *serial)\n{\n\tstruct edgeport_serial *edge_serial = usb_get_serial_data(serial);\n\n\tcancel_delayed_work_sync(&edge_serial->heartbeat_work);\n}\n\nstatic void edge_release(struct usb_serial *serial)\n{\n\tstruct edgeport_serial *edge_serial = usb_get_serial_data(serial);\n\n\tcancel_delayed_work_sync(&edge_serial->heartbeat_work);\n\tkfree(edge_serial);\n}\n\nstatic int edge_port_probe(struct usb_serial_port *port)\n{\n\tstruct edgeport_port *edge_port;\n\tint ret;\n\n\tedge_port = kzalloc(sizeof(*edge_port), GFP_KERNEL);\n\tif (!edge_port)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&edge_port->ep_lock);\n\tedge_port->port = port;\n\tedge_port->edge_serial = usb_get_serial_data(port->serial);\n\tedge_port->bUartMode = default_uart_mode;\n\n\tswitch (port->port_number) {\n\tcase 0:\n\t\tedge_port->uart_base = UMPMEM_BASE_UART1;\n\t\tedge_port->dma_address = UMPD_OEDB1_ADDRESS;\n\t\tbreak;\n\tcase 1:\n\t\tedge_port->uart_base = UMPMEM_BASE_UART2;\n\t\tedge_port->dma_address = UMPD_OEDB2_ADDRESS;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&port->dev, \"unknown port number\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tdev_dbg(&port->dev,\n\t\t\"%s - port_number = %d, uart_base = %04x, dma_address = %04x\\n\",\n\t\t__func__, port->port_number, edge_port->uart_base,\n\t\tedge_port->dma_address);\n\n\tusb_set_serial_port_data(port, edge_port);\n\n\tret = edge_create_sysfs_attrs(port);\n\tif (ret)\n\t\tgoto err;\n\n\tport->port.closing_wait = msecs_to_jiffies(closing_wait * 10);\n\tport->port.drain_delay = 1;\n\n\treturn 0;\nerr:\n\tkfree(edge_port);\n\n\treturn ret;\n}\n\nstatic int edge_port_remove(struct usb_serial_port *port)\n{\n\tstruct edgeport_port *edge_port;\n\n\tedge_port = usb_get_serial_port_data(port);\n\tedge_remove_sysfs_attrs(port);\n\tkfree(edge_port);\n\n\treturn 0;\n}\n\n/* Sysfs Attributes */\n\nstatic ssize_t uart_mode_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\n\treturn sprintf(buf, \"%d\\n\", edge_port->bUartMode);\n}\n\nstatic ssize_t uart_mode_store(struct device *dev,\n\tstruct device_attribute *attr, const char *valbuf, size_t count)\n{\n\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tunsigned int v = simple_strtoul(valbuf, NULL, 0);\n\n\tdev_dbg(dev, \"%s: setting uart_mode = %d\\n\", __func__, v);\n\n\tif (v < 256)\n\t\tedge_port->bUartMode = v;\n\telse\n\t\tdev_err(dev, \"%s - uart_mode %d is invalid\\n\", __func__, v);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(uart_mode);\n\nstatic int edge_create_sysfs_attrs(struct usb_serial_port *port)\n{\n\treturn device_create_file(&port->dev, &dev_attr_uart_mode);\n}\n\nstatic int edge_remove_sysfs_attrs(struct usb_serial_port *port)\n{\n\tdevice_remove_file(&port->dev, &dev_attr_uart_mode);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int edge_suspend(struct usb_serial *serial, pm_message_t message)\n{\n\tstruct edgeport_serial *edge_serial = usb_get_serial_data(serial);\n\n\tcancel_delayed_work_sync(&edge_serial->heartbeat_work);\n\n\treturn 0;\n}\n\nstatic int edge_resume(struct usb_serial *serial)\n{\n\tstruct edgeport_serial *edge_serial = usb_get_serial_data(serial);\n\n\tedge_heartbeat_schedule(edge_serial);\n\n\treturn 0;\n}\n#endif\n\nstatic struct usb_serial_driver edgeport_1port_device = {\n\t.driver = {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"edgeport_ti_1\",\n\t},\n\t.description\t\t= \"Edgeport TI 1 port adapter\",\n\t.id_table\t\t= edgeport_1port_id_table,\n\t.num_ports\t\t= 1,\n\t.num_bulk_out\t\t= 1,\n\t.open\t\t\t= edge_open,\n\t.close\t\t\t= edge_close,\n\t.throttle\t\t= edge_throttle,\n\t.unthrottle\t\t= edge_unthrottle,\n\t.attach\t\t\t= edge_startup,\n\t.calc_num_ports\t\t= edge_calc_num_ports,\n\t.disconnect\t\t= edge_disconnect,\n\t.release\t\t= edge_release,\n\t.port_probe\t\t= edge_port_probe,\n\t.port_remove\t\t= edge_port_remove,\n\t.ioctl\t\t\t= edge_ioctl,\n\t.set_termios\t\t= edge_set_termios,\n\t.tiocmget\t\t= edge_tiocmget,\n\t.tiocmset\t\t= edge_tiocmset,\n\t.tiocmiwait\t\t= usb_serial_generic_tiocmiwait,\n\t.get_icount\t\t= usb_serial_generic_get_icount,\n\t.write\t\t\t= edge_write,\n\t.write_room\t\t= edge_write_room,\n\t.chars_in_buffer\t= edge_chars_in_buffer,\n\t.tx_empty\t\t= edge_tx_empty,\n\t.break_ctl\t\t= edge_break,\n\t.read_int_callback\t= edge_interrupt_callback,\n\t.read_bulk_callback\t= edge_bulk_in_callback,\n\t.write_bulk_callback\t= edge_bulk_out_callback,\n#ifdef CONFIG_PM\n\t.suspend\t\t= edge_suspend,\n\t.resume\t\t\t= edge_resume,\n#endif\n};\n\nstatic struct usb_serial_driver edgeport_2port_device = {\n\t.driver = {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"edgeport_ti_2\",\n\t},\n\t.description\t\t= \"Edgeport TI 2 port adapter\",\n\t.id_table\t\t= edgeport_2port_id_table,\n\t.num_ports\t\t= 2,\n\t.num_bulk_out\t\t= 1,\n\t.open\t\t\t= edge_open,\n\t.close\t\t\t= edge_close,\n\t.throttle\t\t= edge_throttle,\n\t.unthrottle\t\t= edge_unthrottle,\n\t.attach\t\t\t= edge_startup,\n\t.calc_num_ports\t\t= edge_calc_num_ports,\n\t.disconnect\t\t= edge_disconnect,\n\t.release\t\t= edge_release,\n\t.port_probe\t\t= edge_port_probe,\n\t.port_remove\t\t= edge_port_remove,\n\t.ioctl\t\t\t= edge_ioctl,\n\t.set_termios\t\t= edge_set_termios,\n\t.tiocmget\t\t= edge_tiocmget,\n\t.tiocmset\t\t= edge_tiocmset,\n\t.tiocmiwait\t\t= usb_serial_generic_tiocmiwait,\n\t.get_icount\t\t= usb_serial_generic_get_icount,\n\t.write\t\t\t= edge_write,\n\t.write_room\t\t= edge_write_room,\n\t.chars_in_buffer\t= edge_chars_in_buffer,\n\t.tx_empty\t\t= edge_tx_empty,\n\t.break_ctl\t\t= edge_break,\n\t.read_int_callback\t= edge_interrupt_callback,\n\t.read_bulk_callback\t= edge_bulk_in_callback,\n\t.write_bulk_callback\t= edge_bulk_out_callback,\n#ifdef CONFIG_PM\n\t.suspend\t\t= edge_suspend,\n\t.resume\t\t\t= edge_resume,\n#endif\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&edgeport_1port_device, &edgeport_2port_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table_combined);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"edgeport/down3.bin\");\n\nmodule_param(closing_wait, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(closing_wait, \"Maximum wait for data to drain, in .01 secs\");\n\nmodule_param(ignore_cpu_rev, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ignore_cpu_rev,\n\t\t\t\"Ignore the cpu revision when connecting to a device\");\n\nmodule_param(default_uart_mode, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(default_uart_mode, \"Default uart_mode, 0=RS232, ...\");\n"], "fixing_code": ["/*\n * Edgeport USB Serial Converter driver\n *\n * Copyright (C) 2000-2002 Inside Out Networks, All rights reserved.\n * Copyright (C) 2001-2002 Greg Kroah-Hartman <greg@kroah.com>\n *\n *\tThis program is free software; you can redistribute it and/or modify\n *\tit under the terms of the GNU General Public License as published by\n *\tthe Free Software Foundation; either version 2 of the License, or\n *\t(at your option) any later version.\n *\n * Supports the following devices:\n *\tEP/1 EP/2 EP/4 EP/21 EP/22 EP/221 EP/42 EP/421 WATCHPORT\n *\n * For questions or problems with this driver, contact Inside Out\n * Networks technical support, or Peter Berger <pberger@brimson.com>,\n * or Al Borchers <alborchers@steinerpoint.com>.\n */\n\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/serial.h>\n#include <linux/swab.h>\n#include <linux/kfifo.h>\n#include <linux/ioctl.h>\n#include <linux/firmware.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\n#include \"io_16654.h\"\n#include \"io_usbvend.h\"\n#include \"io_ti.h\"\n\n#define DRIVER_AUTHOR \"Greg Kroah-Hartman <greg@kroah.com> and David Iacovelli\"\n#define DRIVER_DESC \"Edgeport USB Serial Driver\"\n\n#define EPROM_PAGE_SIZE\t\t64\n\n\n/* different hardware types */\n#define HARDWARE_TYPE_930\t0\n#define HARDWARE_TYPE_TIUMP\t1\n\n/* IOCTL_PRIVATE_TI_GET_MODE Definitions */\n#define\tTI_MODE_CONFIGURING\t0   /* Device has not entered start device */\n#define\tTI_MODE_BOOT\t\t1   /* Staying in boot mode\t\t   */\n#define TI_MODE_DOWNLOAD\t2   /* Made it to download mode\t\t   */\n#define TI_MODE_TRANSITIONING\t3   /*\n\t\t\t\t     * Currently in boot mode but\n\t\t\t\t     * transitioning to download mode\n\t\t\t\t     */\n\n/* read urb state */\n#define EDGE_READ_URB_RUNNING\t0\n#define EDGE_READ_URB_STOPPING\t1\n#define EDGE_READ_URB_STOPPED\t2\n\n#define EDGE_CLOSING_WAIT\t4000\t/* in .01 sec */\n\n\n/* Product information read from the Edgeport */\nstruct product_info {\n\tint\tTiMode;\t\t\t/* Current TI Mode  */\n\t__u8\thardware_type;\t\t/* Type of hardware */\n} __attribute__((packed));\n\n/*\n * Edgeport firmware header\n *\n * \"build_number\" has been set to 0 in all three of the images I have\n * seen, and Digi Tech Support suggests that it is safe to ignore it.\n *\n * \"length\" is the number of bytes of actual data following the header.\n *\n * \"checksum\" is the low order byte resulting from adding the values of\n * all the data bytes.\n */\nstruct edgeport_fw_hdr {\n\tu8 major_version;\n\tu8 minor_version;\n\t__le16 build_number;\n\t__le16 length;\n\tu8 checksum;\n} __packed;\n\nstruct edgeport_port {\n\t__u16 uart_base;\n\t__u16 dma_address;\n\t__u8 shadow_msr;\n\t__u8 shadow_mcr;\n\t__u8 shadow_lsr;\n\t__u8 lsr_mask;\n\t__u32 ump_read_timeout;\t\t/*\n\t\t\t\t\t * Number of milliseconds the UMP will\n\t\t\t\t\t * wait without data before completing\n\t\t\t\t\t * a read short\n\t\t\t\t\t */\n\tint baud_rate;\n\tint close_pending;\n\tint lsr_event;\n\n\tstruct edgeport_serial\t*edge_serial;\n\tstruct usb_serial_port\t*port;\n\t__u8 bUartMode;\t\t/* Port type, 0: RS232, etc. */\n\tspinlock_t ep_lock;\n\tint ep_read_urb_state;\n\tint ep_write_urb_in_use;\n};\n\nstruct edgeport_serial {\n\tstruct product_info product_info;\n\tu8 TI_I2C_Type;\t\t\t/* Type of I2C in UMP */\n\tu8 TiReadI2C;\t\t\t/*\n\t\t\t\t\t * Set to TRUE if we have read the\n\t\t\t\t\t * I2c in Boot Mode\n\t\t\t\t\t */\n\tstruct mutex es_lock;\n\tint num_ports_open;\n\tstruct usb_serial *serial;\n\tstruct delayed_work heartbeat_work;\n\tint fw_version;\n\tbool use_heartbeat;\n};\n\n\n/* Devices that this driver supports */\nstatic const struct usb_device_id edgeport_1port_id_table[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_1) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_TI3410_EDGEPORT_1) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_TI3410_EDGEPORT_1I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_PROXIMITY) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_MOTION) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_MOISTURE) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_TEMPERATURE) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_HUMIDITY) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_POWER) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_LIGHT) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_RADIATION) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_DISTANCE) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_ACCELERATION) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_PROX_DIST) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_PLUS_PWR_HP4CD) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_PLUS_PWR_PCI) },\n\t{ }\n};\n\nstatic const struct usb_device_id edgeport_2port_id_table[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2C) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_42) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_22I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_221C) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_22C) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21C) },\n\t/* The 4, 8 and 16 port devices show up as multiple 2 port devices */\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4S) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_8) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_8S) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_416) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_416B) },\n\t{ }\n};\n\n/* Devices that this driver supports */\nstatic const struct usb_device_id id_table_combined[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_1) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_TI3410_EDGEPORT_1) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_TI3410_EDGEPORT_1I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_PROXIMITY) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_MOTION) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_MOISTURE) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_TEMPERATURE) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_HUMIDITY) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_POWER) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_LIGHT) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_RADIATION) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_DISTANCE) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_ACCELERATION) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_WP_PROX_DIST) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_PLUS_PWR_HP4CD) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_PLUS_PWR_PCI) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2C) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_42) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_22I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_221C) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_22C) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21C) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4S) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_8) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_8S) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_416) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_416B) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, id_table_combined);\n\nstatic int closing_wait = EDGE_CLOSING_WAIT;\nstatic bool ignore_cpu_rev;\nstatic int default_uart_mode;\t\t/* RS232 */\n\nstatic void edge_tty_recv(struct usb_serial_port *port, unsigned char *data,\n\t\tint length);\n\nstatic void stop_read(struct edgeport_port *edge_port);\nstatic int restart_read(struct edgeport_port *edge_port);\n\nstatic void edge_set_termios(struct tty_struct *tty,\n\t\tstruct usb_serial_port *port, struct ktermios *old_termios);\nstatic void edge_send(struct usb_serial_port *port, struct tty_struct *tty);\n\nstatic int do_download_mode(struct edgeport_serial *serial,\n\t\tconst struct firmware *fw);\nstatic int do_boot_mode(struct edgeport_serial *serial,\n\t\tconst struct firmware *fw);\n\n/* sysfs attributes */\nstatic int edge_create_sysfs_attrs(struct usb_serial_port *port);\nstatic int edge_remove_sysfs_attrs(struct usb_serial_port *port);\n\n/*\n * Some release of Edgeport firmware \"down3.bin\" after version 4.80\n * introduced code to automatically disconnect idle devices on some\n * Edgeport models after periods of inactivity, typically ~60 seconds.\n * This occurs without regard to whether ports on the device are open\n * or not.  Digi International Tech Support suggested:\n *\n * 1.  Adding driver \"heartbeat\" code to reset the firmware timer by\n *     requesting a descriptor record every 15 seconds, which should be\n *     effective with newer firmware versions that require it, and benign\n *     with older versions that do not. In practice 40 seconds seems often\n *     enough.\n * 2.  The heartbeat code is currently required only on Edgeport/416 models.\n */\n#define FW_HEARTBEAT_VERSION_CUTOFF ((4 << 8) + 80)\n#define FW_HEARTBEAT_SECS 40\n\n/* Timeouts in msecs: firmware downloads take longer */\n#define TI_VSEND_TIMEOUT_DEFAULT 1000\n#define TI_VSEND_TIMEOUT_FW_DOWNLOAD 10000\n\nstatic int ti_vread_sync(struct usb_device *dev, __u8 request,\n\t\t\t\t__u16 value, __u16 index, u8 *data, int size)\n{\n\tint status;\n\n\tstatus = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,\n\t\t\t(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),\n\t\t\tvalue, index, data, size, 1000);\n\tif (status < 0)\n\t\treturn status;\n\tif (status != size) {\n\t\tdev_dbg(&dev->dev, \"%s - wanted to write %d, but only wrote %d\\n\",\n\t\t\t__func__, size, status);\n\t\treturn -ECOMM;\n\t}\n\treturn 0;\n}\n\nstatic int ti_vsend_sync(struct usb_device *dev, u8 request, u16 value,\n\t\tu16 index, u8 *data, int size, int timeout)\n{\n\tint status;\n\n\tstatus = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), request,\n\t\t\t(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT),\n\t\t\tvalue, index, data, size, timeout);\n\tif (status < 0)\n\t\treturn status;\n\tif (status != size) {\n\t\tdev_dbg(&dev->dev, \"%s - wanted to write %d, but only wrote %d\\n\",\n\t\t\t__func__, size, status);\n\t\treturn -ECOMM;\n\t}\n\treturn 0;\n}\n\nstatic int send_cmd(struct usb_device *dev, __u8 command,\n\t\t\t\t__u8 moduleid, __u16 value, u8 *data,\n\t\t\t\tint size)\n{\n\treturn ti_vsend_sync(dev, command, value, moduleid, data, size,\n\t\t\tTI_VSEND_TIMEOUT_DEFAULT);\n}\n\n/* clear tx/rx buffers and fifo in TI UMP */\nstatic int purge_port(struct usb_serial_port *port, __u16 mask)\n{\n\tint port_number = port->port_number;\n\n\tdev_dbg(&port->dev, \"%s - port %d, mask %x\\n\", __func__, port_number, mask);\n\n\treturn send_cmd(port->serial->dev,\n\t\t\t\t\tUMPC_PURGE_PORT,\n\t\t\t\t\t(__u8)(UMPM_UART1_PORT + port_number),\n\t\t\t\t\tmask,\n\t\t\t\t\tNULL,\n\t\t\t\t\t0);\n}\n\n/**\n * read_download_mem - Read edgeport memory from TI chip\n * @dev: usb device pointer\n * @start_address: Device CPU address at which to read\n * @length: Length of above data\n * @address_type: Can read both XDATA and I2C\n * @buffer: pointer to input data buffer\n */\nstatic int read_download_mem(struct usb_device *dev, int start_address,\n\t\t\t\tint length, __u8 address_type, __u8 *buffer)\n{\n\tint status = 0;\n\t__u8 read_length;\n\tu16 be_start_address;\n\n\tdev_dbg(&dev->dev, \"%s - @ %x for %d\\n\", __func__, start_address, length);\n\n\t/*\n\t * Read in blocks of 64 bytes\n\t * (TI firmware can't handle more than 64 byte reads)\n\t */\n\twhile (length) {\n\t\tif (length > 64)\n\t\t\tread_length = 64;\n\t\telse\n\t\t\tread_length = (__u8)length;\n\n\t\tif (read_length > 1) {\n\t\t\tdev_dbg(&dev->dev, \"%s - @ %x for %d\\n\", __func__, start_address, read_length);\n\t\t}\n\t\t/*\n\t\t * NOTE: Must use swab as wIndex is sent in little-endian\n\t\t *       byte order regardless of host byte order.\n\t\t */\n\t\tbe_start_address = swab16((u16)start_address);\n\t\tstatus = ti_vread_sync(dev, UMPC_MEMORY_READ,\n\t\t\t\t\t(__u16)address_type,\n\t\t\t\t\tbe_start_address,\n\t\t\t\t\tbuffer, read_length);\n\n\t\tif (status) {\n\t\t\tdev_dbg(&dev->dev, \"%s - ERROR %x\\n\", __func__, status);\n\t\t\treturn status;\n\t\t}\n\n\t\tif (read_length > 1)\n\t\t\tusb_serial_debug_data(&dev->dev, __func__, read_length, buffer);\n\n\t\t/* Update pointers/length */\n\t\tstart_address += read_length;\n\t\tbuffer += read_length;\n\t\tlength -= read_length;\n\t}\n\n\treturn status;\n}\n\nstatic int read_ram(struct usb_device *dev, int start_address,\n\t\t\t\t\t\tint length, __u8 *buffer)\n{\n\treturn read_download_mem(dev, start_address, length,\n\t\t\t\t\tDTK_ADDR_SPACE_XDATA, buffer);\n}\n\n/* Read edgeport memory to a given block */\nstatic int read_boot_mem(struct edgeport_serial *serial,\n\t\t\t\tint start_address, int length, __u8 *buffer)\n{\n\tint status = 0;\n\tint i;\n\n\tfor (i = 0; i < length; i++) {\n\t\tstatus = ti_vread_sync(serial->serial->dev,\n\t\t\t\tUMPC_MEMORY_READ, serial->TI_I2C_Type,\n\t\t\t\t(__u16)(start_address+i), &buffer[i], 0x01);\n\t\tif (status) {\n\t\t\tdev_dbg(&serial->serial->dev->dev, \"%s - ERROR %x\\n\", __func__, status);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tdev_dbg(&serial->serial->dev->dev, \"%s - start_address = %x, length = %d\\n\",\n\t\t__func__, start_address, length);\n\tusb_serial_debug_data(&serial->serial->dev->dev, __func__, length, buffer);\n\n\tserial->TiReadI2C = 1;\n\n\treturn status;\n}\n\n/* Write given block to TI EPROM memory */\nstatic int write_boot_mem(struct edgeport_serial *serial,\n\t\t\t\tint start_address, int length, __u8 *buffer)\n{\n\tint status = 0;\n\tint i;\n\tu8 *temp;\n\n\t/* Must do a read before write */\n\tif (!serial->TiReadI2C) {\n\t\ttemp = kmalloc(1, GFP_KERNEL);\n\t\tif (!temp)\n\t\t\treturn -ENOMEM;\n\n\t\tstatus = read_boot_mem(serial, 0, 1, temp);\n\t\tkfree(temp);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tfor (i = 0; i < length; ++i) {\n\t\tstatus = ti_vsend_sync(serial->serial->dev, UMPC_MEMORY_WRITE,\n\t\t\t\tbuffer[i], (u16)(i + start_address), NULL,\n\t\t\t\t0, TI_VSEND_TIMEOUT_DEFAULT);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tdev_dbg(&serial->serial->dev->dev, \"%s - start_sddr = %x, length = %d\\n\", __func__, start_address, length);\n\tusb_serial_debug_data(&serial->serial->dev->dev, __func__, length, buffer);\n\n\treturn status;\n}\n\n/* Write edgeport I2C memory to TI chip\t*/\nstatic int write_i2c_mem(struct edgeport_serial *serial,\n\t\tint start_address, int length, __u8 address_type, __u8 *buffer)\n{\n\tstruct device *dev = &serial->serial->dev->dev;\n\tint status = 0;\n\tint write_length;\n\tu16 be_start_address;\n\n\t/* We can only send a maximum of 1 aligned byte page at a time */\n\n\t/* calculate the number of bytes left in the first page */\n\twrite_length = EPROM_PAGE_SIZE -\n\t\t\t\t(start_address & (EPROM_PAGE_SIZE - 1));\n\n\tif (write_length > length)\n\t\twrite_length = length;\n\n\tdev_dbg(dev, \"%s - BytesInFirstPage Addr = %x, length = %d\\n\",\n\t\t__func__, start_address, write_length);\n\tusb_serial_debug_data(dev, __func__, write_length, buffer);\n\n\t/*\n\t * Write first page.\n\t *\n\t * NOTE: Must use swab as wIndex is sent in little-endian byte order\n\t *       regardless of host byte order.\n\t */\n\tbe_start_address = swab16((u16)start_address);\n\tstatus = ti_vsend_sync(serial->serial->dev, UMPC_MEMORY_WRITE,\n\t\t\t\t(u16)address_type, be_start_address,\n\t\t\t\tbuffer,\twrite_length, TI_VSEND_TIMEOUT_DEFAULT);\n\tif (status) {\n\t\tdev_dbg(dev, \"%s - ERROR %d\\n\", __func__, status);\n\t\treturn status;\n\t}\n\n\tlength\t\t-= write_length;\n\tstart_address\t+= write_length;\n\tbuffer\t\t+= write_length;\n\n\t/*\n\t * We should be aligned now -- can write max page size bytes at a\n\t * time.\n\t */\n\twhile (length) {\n\t\tif (length > EPROM_PAGE_SIZE)\n\t\t\twrite_length = EPROM_PAGE_SIZE;\n\t\telse\n\t\t\twrite_length = length;\n\n\t\tdev_dbg(dev, \"%s - Page Write Addr = %x, length = %d\\n\",\n\t\t\t__func__, start_address, write_length);\n\t\tusb_serial_debug_data(dev, __func__, write_length, buffer);\n\n\t\t/*\n\t\t * Write next page.\n\t\t *\n\t\t * NOTE: Must use swab as wIndex is sent in little-endian byte\n\t\t *       order regardless of host byte order.\n\t\t */\n\t\tbe_start_address = swab16((u16)start_address);\n\t\tstatus = ti_vsend_sync(serial->serial->dev, UMPC_MEMORY_WRITE,\n\t\t\t\t(u16)address_type, be_start_address, buffer,\n\t\t\t\twrite_length, TI_VSEND_TIMEOUT_DEFAULT);\n\t\tif (status) {\n\t\t\tdev_err(dev, \"%s - ERROR %d\\n\", __func__, status);\n\t\t\treturn status;\n\t\t}\n\n\t\tlength\t\t-= write_length;\n\t\tstart_address\t+= write_length;\n\t\tbuffer\t\t+= write_length;\n\t}\n\treturn status;\n}\n\n/*\n * Examine the UMP DMA registers and LSR\n *\n * Check the MSBit of the X and Y DMA byte count registers.\n * A zero in this bit indicates that the TX DMA buffers are empty\n * then check the TX Empty bit in the UART.\n */\nstatic int tx_active(struct edgeport_port *port)\n{\n\tint status;\n\tstruct out_endpoint_desc_block *oedb;\n\t__u8 *lsr;\n\tint bytes_left = 0;\n\n\toedb = kmalloc(sizeof(*oedb), GFP_KERNEL);\n\tif (!oedb)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Sigh, that's right, just one byte, as not all platforms can\n\t * do DMA from stack\n\t */\n\tlsr = kmalloc(1, GFP_KERNEL);\n\tif (!lsr) {\n\t\tkfree(oedb);\n\t\treturn -ENOMEM;\n\t}\n\t/* Read the DMA Count Registers */\n\tstatus = read_ram(port->port->serial->dev, port->dma_address,\n\t\t\t\t\t\tsizeof(*oedb), (void *)oedb);\n\tif (status)\n\t\tgoto exit_is_tx_active;\n\n\tdev_dbg(&port->port->dev, \"%s - XByteCount    0x%X\\n\", __func__, oedb->XByteCount);\n\n\t/* and the LSR */\n\tstatus = read_ram(port->port->serial->dev,\n\t\t\tport->uart_base + UMPMEM_OFFS_UART_LSR, 1, lsr);\n\n\tif (status)\n\t\tgoto exit_is_tx_active;\n\tdev_dbg(&port->port->dev, \"%s - LSR = 0x%X\\n\", __func__, *lsr);\n\n\t/* If either buffer has data or we are transmitting then return TRUE */\n\tif ((oedb->XByteCount & 0x80) != 0)\n\t\tbytes_left += 64;\n\n\tif ((*lsr & UMP_UART_LSR_TX_MASK) == 0)\n\t\tbytes_left += 1;\n\n\t/* We return Not Active if we get any kind of error */\nexit_is_tx_active:\n\tdev_dbg(&port->port->dev, \"%s - return %d\\n\", __func__, bytes_left);\n\n\tkfree(lsr);\n\tkfree(oedb);\n\treturn bytes_left;\n}\n\nstatic int choose_config(struct usb_device *dev)\n{\n\t/*\n\t * There may be multiple configurations on this device, in which case\n\t * we would need to read and parse all of them to find out which one\n\t * we want. However, we just support one config at this point,\n\t * configuration # 1, which is Config Descriptor 0.\n\t */\n\n\tdev_dbg(&dev->dev, \"%s - Number of Interfaces = %d\\n\",\n\t\t__func__, dev->config->desc.bNumInterfaces);\n\tdev_dbg(&dev->dev, \"%s - MAX Power            = %d\\n\",\n\t\t__func__, dev->config->desc.bMaxPower * 2);\n\n\tif (dev->config->desc.bNumInterfaces != 1) {\n\t\tdev_err(&dev->dev, \"%s - bNumInterfaces is not 1, ERROR!\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_rom(struct edgeport_serial *serial,\n\t\t\t\tint start_address, int length, __u8 *buffer)\n{\n\tint status;\n\n\tif (serial->product_info.TiMode == TI_MODE_DOWNLOAD) {\n\t\tstatus = read_download_mem(serial->serial->dev,\n\t\t\t\t\t       start_address,\n\t\t\t\t\t       length,\n\t\t\t\t\t       serial->TI_I2C_Type,\n\t\t\t\t\t       buffer);\n\t} else {\n\t\tstatus = read_boot_mem(serial, start_address, length,\n\t\t\t\t\t\t\t\tbuffer);\n\t}\n\treturn status;\n}\n\nstatic int write_rom(struct edgeport_serial *serial, int start_address,\n\t\t\t\t\t\tint length, __u8 *buffer)\n{\n\tif (serial->product_info.TiMode == TI_MODE_BOOT)\n\t\treturn write_boot_mem(serial, start_address, length,\n\t\t\t\t\t\t\t\tbuffer);\n\n\tif (serial->product_info.TiMode == TI_MODE_DOWNLOAD)\n\t\treturn write_i2c_mem(serial, start_address, length,\n\t\t\t\t\t\tserial->TI_I2C_Type, buffer);\n\treturn -EINVAL;\n}\n\n/* Read a descriptor header from I2C based on type */\nstatic int get_descriptor_addr(struct edgeport_serial *serial,\n\t\t\t\tint desc_type, struct ti_i2c_desc *rom_desc)\n{\n\tint start_address;\n\tint status;\n\n\t/* Search for requested descriptor in I2C */\n\tstart_address = 2;\n\tdo {\n\t\tstatus = read_rom(serial,\n\t\t\t\t   start_address,\n\t\t\t\t   sizeof(struct ti_i2c_desc),\n\t\t\t\t   (__u8 *)rom_desc);\n\t\tif (status)\n\t\t\treturn 0;\n\n\t\tif (rom_desc->Type == desc_type)\n\t\t\treturn start_address;\n\n\t\tstart_address = start_address + sizeof(struct ti_i2c_desc) +\n\t\t\t\t\t\tle16_to_cpu(rom_desc->Size);\n\n\t} while ((start_address < TI_MAX_I2C_SIZE) && rom_desc->Type);\n\n\treturn 0;\n}\n\n/* Validate descriptor checksum */\nstatic int valid_csum(struct ti_i2c_desc *rom_desc, __u8 *buffer)\n{\n\t__u16 i;\n\t__u8 cs = 0;\n\n\tfor (i = 0; i < le16_to_cpu(rom_desc->Size); i++)\n\t\tcs = (__u8)(cs + buffer[i]);\n\n\tif (cs != rom_desc->CheckSum) {\n\t\tpr_debug(\"%s - Mismatch %x - %x\", __func__, rom_desc->CheckSum, cs);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/* Make sure that the I2C image is good */\nstatic int check_i2c_image(struct edgeport_serial *serial)\n{\n\tstruct device *dev = &serial->serial->dev->dev;\n\tint status = 0;\n\tstruct ti_i2c_desc *rom_desc;\n\tint start_address = 2;\n\t__u8 *buffer;\n\t__u16 ttype;\n\n\trom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\n\tif (!rom_desc)\n\t\treturn -ENOMEM;\n\n\tbuffer = kmalloc(TI_MAX_I2C_SIZE, GFP_KERNEL);\n\tif (!buffer) {\n\t\tkfree(rom_desc);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Read the first byte (Signature0) must be 0x52 or 0x10 */\n\tstatus = read_rom(serial, 0, 1, buffer);\n\tif (status)\n\t\tgoto out;\n\n\tif (*buffer != UMP5152 && *buffer != UMP3410) {\n\t\tdev_err(dev, \"%s - invalid buffer signature\\n\", __func__);\n\t\tstatus = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\t/* Validate the I2C */\n\t\tstatus = read_rom(serial,\n\t\t\t\tstart_address,\n\t\t\t\tsizeof(struct ti_i2c_desc),\n\t\t\t\t(__u8 *)rom_desc);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tif ((start_address + sizeof(struct ti_i2c_desc) +\n\t\t\tle16_to_cpu(rom_desc->Size)) > TI_MAX_I2C_SIZE) {\n\t\t\tstatus = -ENODEV;\n\t\t\tdev_dbg(dev, \"%s - structure too big, erroring out.\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(dev, \"%s Type = 0x%x\\n\", __func__, rom_desc->Type);\n\n\t\t/* Skip type 2 record */\n\t\tttype = rom_desc->Type & 0x0f;\n\t\tif (ttype != I2C_DESC_TYPE_FIRMWARE_BASIC\n\t\t\t&& ttype != I2C_DESC_TYPE_FIRMWARE_AUTO) {\n\t\t\t/* Read the descriptor data */\n\t\t\tstatus = read_rom(serial, start_address +\n\t\t\t\t\t\tsizeof(struct ti_i2c_desc),\n\t\t\t\t\t\tle16_to_cpu(rom_desc->Size),\n\t\t\t\t\t\tbuffer);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\n\t\t\tstatus = valid_csum(rom_desc, buffer);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t}\n\t\tstart_address = start_address + sizeof(struct ti_i2c_desc) +\n\t\t\t\t\t\tle16_to_cpu(rom_desc->Size);\n\n\t} while ((rom_desc->Type != I2C_DESC_TYPE_ION) &&\n\t\t\t\t(start_address < TI_MAX_I2C_SIZE));\n\n\tif ((rom_desc->Type != I2C_DESC_TYPE_ION) ||\n\t\t\t\t(start_address > TI_MAX_I2C_SIZE))\n\t\tstatus = -ENODEV;\n\nout:\n\tkfree(buffer);\n\tkfree(rom_desc);\n\treturn status;\n}\n\nstatic int get_manuf_info(struct edgeport_serial *serial, __u8 *buffer)\n{\n\tint status;\n\tint start_address;\n\tstruct ti_i2c_desc *rom_desc;\n\tstruct edge_ti_manuf_descriptor *desc;\n\tstruct device *dev = &serial->serial->dev->dev;\n\n\trom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\n\tif (!rom_desc)\n\t\treturn -ENOMEM;\n\n\tstart_address = get_descriptor_addr(serial, I2C_DESC_TYPE_ION,\n\t\t\t\t\t\t\t\trom_desc);\n\n\tif (!start_address) {\n\t\tdev_dbg(dev, \"%s - Edge Descriptor not found in I2C\\n\", __func__);\n\t\tstatus = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t/* Read the descriptor data */\n\tstatus = read_rom(serial, start_address+sizeof(struct ti_i2c_desc),\n\t\t\t\t\tle16_to_cpu(rom_desc->Size), buffer);\n\tif (status)\n\t\tgoto exit;\n\n\tstatus = valid_csum(rom_desc, buffer);\n\n\tdesc = (struct edge_ti_manuf_descriptor *)buffer;\n\tdev_dbg(dev, \"%s - IonConfig      0x%x\\n\", __func__, desc->IonConfig);\n\tdev_dbg(dev, \"%s - Version          %d\\n\", __func__, desc->Version);\n\tdev_dbg(dev, \"%s - Cpu/Board      0x%x\\n\", __func__, desc->CpuRev_BoardRev);\n\tdev_dbg(dev, \"%s - NumPorts         %d\\n\", __func__, desc->NumPorts);\n\tdev_dbg(dev, \"%s - NumVirtualPorts  %d\\n\", __func__, desc->NumVirtualPorts);\n\tdev_dbg(dev, \"%s - TotalPorts       %d\\n\", __func__, desc->TotalPorts);\n\nexit:\n\tkfree(rom_desc);\n\treturn status;\n}\n\n/* Build firmware header used for firmware update */\nstatic int build_i2c_fw_hdr(u8 *header, const struct firmware *fw)\n{\n\t__u8 *buffer;\n\tint buffer_size;\n\tint i;\n\t__u8 cs = 0;\n\tstruct ti_i2c_desc *i2c_header;\n\tstruct ti_i2c_image_header *img_header;\n\tstruct ti_i2c_firmware_rec *firmware_rec;\n\tstruct edgeport_fw_hdr *fw_hdr = (struct edgeport_fw_hdr *)fw->data;\n\n\t/*\n\t * In order to update the I2C firmware we must change the type 2 record\n\t * to type 0xF2.  This will force the UMP to come up in Boot Mode.\n\t * Then while in boot mode, the driver will download the latest\n\t * firmware (padded to 15.5k) into the UMP ram.  And finally when the\n\t * device comes back up in download mode the driver will cause the new\n\t * firmware to be copied from the UMP Ram to I2C and the firmware will\n\t * update the record type from 0xf2 to 0x02.\n\t */\n\n\t/*\n\t * Allocate a 15.5k buffer + 2 bytes for version number (Firmware\n\t * Record)\n\t */\n\tbuffer_size = (((1024 * 16) - 512 ) +\n\t\t\tsizeof(struct ti_i2c_firmware_rec));\n\n\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t/* Set entire image of 0xffs */\n\tmemset(buffer, 0xff, buffer_size);\n\n\t/* Copy version number into firmware record */\n\tfirmware_rec = (struct ti_i2c_firmware_rec *)buffer;\n\n\tfirmware_rec->Ver_Major\t= fw_hdr->major_version;\n\tfirmware_rec->Ver_Minor\t= fw_hdr->minor_version;\n\n\t/* Pointer to fw_down memory image */\n\timg_header = (struct ti_i2c_image_header *)&fw->data[4];\n\n\tmemcpy(buffer + sizeof(struct ti_i2c_firmware_rec),\n\t\t&fw->data[4 + sizeof(struct ti_i2c_image_header)],\n\t\tle16_to_cpu(img_header->Length));\n\n\tfor (i=0; i < buffer_size; i++) {\n\t\tcs = (__u8)(cs + buffer[i]);\n\t}\n\n\tkfree(buffer);\n\n\t/* Build new header */\n\ti2c_header =  (struct ti_i2c_desc *)header;\n\tfirmware_rec =  (struct ti_i2c_firmware_rec*)i2c_header->Data;\n\n\ti2c_header->Type\t= I2C_DESC_TYPE_FIRMWARE_BLANK;\n\ti2c_header->Size\t= cpu_to_le16(buffer_size);\n\ti2c_header->CheckSum\t= cs;\n\tfirmware_rec->Ver_Major\t= fw_hdr->major_version;\n\tfirmware_rec->Ver_Minor\t= fw_hdr->minor_version;\n\n\treturn 0;\n}\n\n/* Try to figure out what type of I2c we have */\nstatic int i2c_type_bootmode(struct edgeport_serial *serial)\n{\n\tstruct device *dev = &serial->serial->dev->dev;\n\tint status;\n\tu8 *data;\n\n\tdata = kmalloc(1, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t/* Try to read type 2 */\n\tstatus = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,\n\t\t\t\tDTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);\n\tif (status)\n\t\tdev_dbg(dev, \"%s - read 2 status error = %d\\n\", __func__, status);\n\telse\n\t\tdev_dbg(dev, \"%s - read 2 data = 0x%x\\n\", __func__, *data);\n\tif ((!status) && (*data == UMP5152 || *data == UMP3410)) {\n\t\tdev_dbg(dev, \"%s - ROM_TYPE_II\\n\", __func__);\n\t\tserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;\n\t\tgoto out;\n\t}\n\n\t/* Try to read type 3 */\n\tstatus = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,\n\t\t\t\tDTK_ADDR_SPACE_I2C_TYPE_III, 0,\tdata, 0x01);\n\tif (status)\n\t\tdev_dbg(dev, \"%s - read 3 status error = %d\\n\", __func__, status);\n\telse\n\t\tdev_dbg(dev, \"%s - read 2 data = 0x%x\\n\", __func__, *data);\n\tif ((!status) && (*data == UMP5152 || *data == UMP3410)) {\n\t\tdev_dbg(dev, \"%s - ROM_TYPE_III\\n\", __func__);\n\t\tserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;\n\t\tgoto out;\n\t}\n\n\tdev_dbg(dev, \"%s - Unknown\\n\", __func__);\n\tserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;\n\tstatus = -ENODEV;\nout:\n\tkfree(data);\n\treturn status;\n}\n\nstatic int bulk_xfer(struct usb_serial *serial, void *buffer,\n\t\t\t\t\t\tint length, int *num_sent)\n{\n\tint status;\n\n\tstatus = usb_bulk_msg(serial->dev,\n\t\t\tusb_sndbulkpipe(serial->dev,\n\t\t\t\tserial->port[0]->bulk_out_endpointAddress),\n\t\t\tbuffer, length, num_sent, 1000);\n\treturn status;\n}\n\n/* Download given firmware image to the device (IN BOOT MODE) */\nstatic int download_code(struct edgeport_serial *serial, __u8 *image,\n\t\t\t\t\t\t\tint image_length)\n{\n\tint status = 0;\n\tint pos;\n\tint transfer;\n\tint done;\n\n\t/* Transfer firmware image */\n\tfor (pos = 0; pos < image_length; ) {\n\t\t/* Read the next buffer from file */\n\t\ttransfer = image_length - pos;\n\t\tif (transfer > EDGE_FW_BULK_MAX_PACKET_SIZE)\n\t\t\ttransfer = EDGE_FW_BULK_MAX_PACKET_SIZE;\n\n\t\t/* Transfer data */\n\t\tstatus = bulk_xfer(serial->serial, &image[pos],\n\t\t\t\t\t\t\ttransfer, &done);\n\t\tif (status)\n\t\t\tbreak;\n\t\t/* Advance buffer pointer */\n\t\tpos += done;\n\t}\n\n\treturn status;\n}\n\n/* FIXME!!! */\nstatic int config_boot_dev(struct usb_device *dev)\n{\n\treturn 0;\n}\n\nstatic int ti_cpu_rev(struct edge_ti_manuf_descriptor *desc)\n{\n\treturn TI_GET_CPU_REVISION(desc->CpuRev_BoardRev);\n}\n\nstatic int check_fw_sanity(struct edgeport_serial *serial,\n\t\tconst struct firmware *fw)\n{\n\tu16 length_total;\n\tu8 checksum = 0;\n\tint pos;\n\tstruct device *dev = &serial->serial->interface->dev;\n\tstruct edgeport_fw_hdr *fw_hdr = (struct edgeport_fw_hdr *)fw->data;\n\n\tif (fw->size < sizeof(struct edgeport_fw_hdr)) {\n\t\tdev_err(dev, \"incomplete fw header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlength_total = le16_to_cpu(fw_hdr->length) +\n\t\t\tsizeof(struct edgeport_fw_hdr);\n\n\tif (fw->size != length_total) {\n\t\tdev_err(dev, \"bad fw size (expected: %u, got: %zu)\\n\",\n\t\t\t\tlength_total, fw->size);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (pos = sizeof(struct edgeport_fw_hdr); pos < fw->size; ++pos)\n\t\tchecksum += fw->data[pos];\n\n\tif (checksum != fw_hdr->checksum) {\n\t\tdev_err(dev, \"bad fw checksum (expected: 0x%x, got: 0x%x)\\n\",\n\t\t\t\tfw_hdr->checksum, checksum);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/*\n * DownloadTIFirmware - Download run-time operating firmware to the TI5052\n *\n * This routine downloads the main operating code into the TI5052, using the\n * boot code already burned into E2PROM or ROM.\n */\nstatic int download_fw(struct edgeport_serial *serial)\n{\n\tstruct device *dev = &serial->serial->interface->dev;\n\tint status = 0;\n\tstruct usb_interface_descriptor *interface;\n\tconst struct firmware *fw;\n\tconst char *fw_name = \"edgeport/down3.bin\";\n\tstruct edgeport_fw_hdr *fw_hdr;\n\n\tstatus = request_firmware(&fw, fw_name, dev);\n\tif (status) {\n\t\tdev_err(dev, \"Failed to load image \\\"%s\\\" err %d\\n\",\n\t\t\t\tfw_name, status);\n\t\treturn status;\n\t}\n\n\tif (check_fw_sanity(serial, fw)) {\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfw_hdr = (struct edgeport_fw_hdr *)fw->data;\n\n\t/* If on-board version is newer, \"fw_version\" will be updated later. */\n\tserial->fw_version = (fw_hdr->major_version << 8) +\n\t\t\tfw_hdr->minor_version;\n\n\t/*\n\t * This routine is entered by both the BOOT mode and the Download mode\n\t * We can determine which code is running by the reading the config\n\t * descriptor and if we have only one bulk pipe it is in boot mode\n\t */\n\tserial->product_info.hardware_type = HARDWARE_TYPE_TIUMP;\n\n\t/* Default to type 2 i2c */\n\tserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;\n\n\tstatus = choose_config(serial->serial->dev);\n\tif (status)\n\t\tgoto out;\n\n\tinterface = &serial->serial->interface->cur_altsetting->desc;\n\tif (!interface) {\n\t\tdev_err(dev, \"%s - no interface set, error!\\n\", __func__);\n\t\tstatus = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Setup initial mode -- the default mode 0 is TI_MODE_CONFIGURING\n\t * if we have more than one endpoint we are definitely in download\n\t * mode\n\t */\n\tif (interface->bNumEndpoints > 1) {\n\t\tserial->product_info.TiMode = TI_MODE_DOWNLOAD;\n\t\tstatus = do_download_mode(serial, fw);\n\t} else {\n\t\t/* Otherwise we will remain in configuring mode */\n\t\tserial->product_info.TiMode = TI_MODE_CONFIGURING;\n\t\tstatus = do_boot_mode(serial, fw);\n\t}\n\nout:\n\trelease_firmware(fw);\n\treturn status;\n}\n\nstatic int do_download_mode(struct edgeport_serial *serial,\n\t\tconst struct firmware *fw)\n{\n\tstruct device *dev = &serial->serial->interface->dev;\n\tint status = 0;\n\tint start_address;\n\tstruct edge_ti_manuf_descriptor *ti_manuf_desc;\n\tint download_cur_ver;\n\tint download_new_ver;\n\tstruct edgeport_fw_hdr *fw_hdr = (struct edgeport_fw_hdr *)fw->data;\n\tstruct ti_i2c_desc *rom_desc;\n\n\tdev_dbg(dev, \"%s - RUNNING IN DOWNLOAD MODE\\n\", __func__);\n\n\tstatus = check_i2c_image(serial);\n\tif (status) {\n\t\tdev_dbg(dev, \"%s - DOWNLOAD MODE -- BAD I2C\\n\", __func__);\n\t\treturn status;\n\t}\n\n\t/*\n\t * Validate Hardware version number\n\t * Read Manufacturing Descriptor from TI Based Edgeport\n\t */\n\tti_manuf_desc = kmalloc(sizeof(*ti_manuf_desc), GFP_KERNEL);\n\tif (!ti_manuf_desc)\n\t\treturn -ENOMEM;\n\n\tstatus = get_manuf_info(serial, (__u8 *)ti_manuf_desc);\n\tif (status) {\n\t\tkfree(ti_manuf_desc);\n\t\treturn status;\n\t}\n\n\t/* Check version number of ION descriptor */\n\tif (!ignore_cpu_rev && ti_cpu_rev(ti_manuf_desc) < 2) {\n\t\tdev_dbg(dev, \"%s - Wrong CPU Rev %d (Must be 2)\\n\",\n\t\t\t__func__, ti_cpu_rev(ti_manuf_desc));\n\t\tkfree(ti_manuf_desc);\n\t\treturn -EINVAL;\n\t}\n\n\trom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\n\tif (!rom_desc) {\n\t\tkfree(ti_manuf_desc);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Search for type 2 record (firmware record) */\n\tstart_address = get_descriptor_addr(serial,\n\t\t\tI2C_DESC_TYPE_FIRMWARE_BASIC, rom_desc);\n\tif (start_address != 0) {\n\t\tstruct ti_i2c_firmware_rec *firmware_version;\n\t\tu8 *record;\n\n\t\tdev_dbg(dev, \"%s - Found Type FIRMWARE (Type 2) record\\n\",\n\t\t\t\t__func__);\n\n\t\tfirmware_version = kmalloc(sizeof(*firmware_version),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!firmware_version) {\n\t\t\tkfree(rom_desc);\n\t\t\tkfree(ti_manuf_desc);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/*\n\t\t * Validate version number\n\t\t * Read the descriptor data\n\t\t */\n\t\tstatus = read_rom(serial, start_address +\n\t\t\t\tsizeof(struct ti_i2c_desc),\n\t\t\t\tsizeof(struct ti_i2c_firmware_rec),\n\t\t\t\t(__u8 *)firmware_version);\n\t\tif (status) {\n\t\t\tkfree(firmware_version);\n\t\t\tkfree(rom_desc);\n\t\t\tkfree(ti_manuf_desc);\n\t\t\treturn status;\n\t\t}\n\n\t\t/*\n\t\t * Check version number of download with current\n\t\t * version in I2c\n\t\t */\n\t\tdownload_cur_ver = (firmware_version->Ver_Major << 8) +\n\t\t\t\t   (firmware_version->Ver_Minor);\n\t\tdownload_new_ver = (fw_hdr->major_version << 8) +\n\t\t\t\t   (fw_hdr->minor_version);\n\n\t\tdev_dbg(dev, \"%s - >> FW Versions Device %d.%d  Driver %d.%d\\n\",\n\t\t\t__func__, firmware_version->Ver_Major,\n\t\t\tfirmware_version->Ver_Minor,\n\t\t\tfw_hdr->major_version, fw_hdr->minor_version);\n\n\t\t/*\n\t\t * Check if we have an old version in the I2C and\n\t\t * update if necessary\n\t\t */\n\t\tif (download_cur_ver < download_new_ver) {\n\t\t\tdev_dbg(dev, \"%s - Update I2C dld from %d.%d to %d.%d\\n\",\n\t\t\t\t__func__,\n\t\t\t\tfirmware_version->Ver_Major,\n\t\t\t\tfirmware_version->Ver_Minor,\n\t\t\t\tfw_hdr->major_version,\n\t\t\t\tfw_hdr->minor_version);\n\n\t\t\trecord = kmalloc(1, GFP_KERNEL);\n\t\t\tif (!record) {\n\t\t\t\tkfree(firmware_version);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\t/*\n\t\t\t * In order to update the I2C firmware we must\n\t\t\t * change the type 2 record to type 0xF2. This\n\t\t\t * will force the UMP to come up in Boot Mode.\n\t\t\t * Then while in boot mode, the driver will\n\t\t\t * download the latest firmware (padded to\n\t\t\t * 15.5k) into the UMP ram. Finally when the\n\t\t\t * device comes back up in download mode the\n\t\t\t * driver will cause the new firmware to be\n\t\t\t * copied from the UMP Ram to I2C and the\n\t\t\t * firmware will update the record type from\n\t\t\t * 0xf2 to 0x02.\n\t\t\t */\n\t\t\t*record = I2C_DESC_TYPE_FIRMWARE_BLANK;\n\n\t\t\t/*\n\t\t\t * Change the I2C Firmware record type to\n\t\t\t * 0xf2 to trigger an update\n\t\t\t */\n\t\t\tstatus = write_rom(serial, start_address,\n\t\t\t\t\tsizeof(*record), record);\n\t\t\tif (status) {\n\t\t\t\tkfree(record);\n\t\t\t\tkfree(firmware_version);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn status;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * verify the write -- must do this in order\n\t\t\t * for write to complete before we do the\n\t\t\t * hardware reset\n\t\t\t */\n\t\t\tstatus = read_rom(serial,\n\t\t\t\t\t\tstart_address,\n\t\t\t\t\t\tsizeof(*record),\n\t\t\t\t\t\trecord);\n\t\t\tif (status) {\n\t\t\t\tkfree(record);\n\t\t\t\tkfree(firmware_version);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn status;\n\t\t\t}\n\n\t\t\tif (*record != I2C_DESC_TYPE_FIRMWARE_BLANK) {\n\t\t\t\tdev_err(dev, \"%s - error resetting device\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\tkfree(record);\n\t\t\t\tkfree(firmware_version);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\t\tdev_dbg(dev, \"%s - HARDWARE RESET\\n\", __func__);\n\n\t\t\t/* Reset UMP -- Back to BOOT MODE */\n\t\t\tstatus = ti_vsend_sync(serial->serial->dev,\n\t\t\t\t\tUMPC_HARDWARE_RESET,\n\t\t\t\t\t0, 0, NULL, 0,\n\t\t\t\t\tTI_VSEND_TIMEOUT_DEFAULT);\n\n\t\t\tdev_dbg(dev, \"%s - HARDWARE RESET return %d\\n\",\n\t\t\t\t\t__func__, status);\n\n\t\t\t/* return an error on purpose. */\n\t\t\tkfree(record);\n\t\t\tkfree(firmware_version);\n\t\t\tkfree(rom_desc);\n\t\t\tkfree(ti_manuf_desc);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t/* Same or newer fw version is already loaded */\n\t\tserial->fw_version = download_cur_ver;\n\t\tkfree(firmware_version);\n\t}\n\t/* Search for type 0xF2 record (firmware blank record) */\n\telse {\n\t\tstart_address = get_descriptor_addr(serial,\n\t\t\t\tI2C_DESC_TYPE_FIRMWARE_BLANK, rom_desc);\n\t\tif (start_address != 0) {\n#define HEADER_SIZE\t(sizeof(struct ti_i2c_desc) + \\\n\t\t\t\tsizeof(struct ti_i2c_firmware_rec))\n\t\t\t__u8 *header;\n\t\t\t__u8 *vheader;\n\n\t\t\theader = kmalloc(HEADER_SIZE, GFP_KERNEL);\n\t\t\tif (!header) {\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tvheader = kmalloc(HEADER_SIZE, GFP_KERNEL);\n\t\t\tif (!vheader) {\n\t\t\t\tkfree(header);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tdev_dbg(dev, \"%s - Found Type BLANK FIRMWARE (Type F2) record\\n\",\n\t\t\t\t\t__func__);\n\n\t\t\t/*\n\t\t\t * In order to update the I2C firmware we must change\n\t\t\t * the type 2 record to type 0xF2. This will force the\n\t\t\t * UMP to come up in Boot Mode.  Then while in boot\n\t\t\t * mode, the driver will download the latest firmware\n\t\t\t * (padded to 15.5k) into the UMP ram. Finally when the\n\t\t\t * device comes back up in download mode the driver\n\t\t\t * will cause the new firmware to be copied from the\n\t\t\t * UMP Ram to I2C and the firmware will update the\n\t\t\t * record type from 0xf2 to 0x02.\n\t\t\t */\n\t\t\tstatus = build_i2c_fw_hdr(header, fw);\n\t\t\tif (status) {\n\t\t\t\tkfree(vheader);\n\t\t\t\tkfree(header);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Update I2C with type 0xf2 record with correct\n\t\t\t * size and checksum\n\t\t\t */\n\t\t\tstatus = write_rom(serial,\n\t\t\t\t\t\tstart_address,\n\t\t\t\t\t\tHEADER_SIZE,\n\t\t\t\t\t\theader);\n\t\t\tif (status) {\n\t\t\t\tkfree(vheader);\n\t\t\t\tkfree(header);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * verify the write -- must do this in order for\n\t\t\t * write to complete before we do the hardware reset\n\t\t\t */\n\t\t\tstatus = read_rom(serial, start_address,\n\t\t\t\t\t\t\tHEADER_SIZE, vheader);\n\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(dev, \"%s - can't read header back\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\tkfree(vheader);\n\t\t\t\tkfree(header);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t\tif (memcmp(vheader, header, HEADER_SIZE)) {\n\t\t\t\tdev_dbg(dev, \"%s - write download record failed\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\tkfree(vheader);\n\t\t\t\tkfree(header);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tkfree(vheader);\n\t\t\tkfree(header);\n\n\t\t\tdev_dbg(dev, \"%s - Start firmware update\\n\", __func__);\n\n\t\t\t/* Tell firmware to copy download image into I2C */\n\t\t\tstatus = ti_vsend_sync(serial->serial->dev,\n\t\t\t\t\tUMPC_COPY_DNLD_TO_I2C,\n\t\t\t\t\t0, 0, NULL, 0,\n\t\t\t\t\tTI_VSEND_TIMEOUT_FW_DOWNLOAD);\n\n\t\t\tdev_dbg(dev, \"%s - Update complete 0x%x\\n\", __func__,\n\t\t\t\t\tstatus);\n\t\t\tif (status) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"%s - UMPC_COPY_DNLD_TO_I2C failed\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tkfree(rom_desc);\n\t\t\t\tkfree(ti_manuf_desc);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* The device is running the download code */\n\tkfree(rom_desc);\n\tkfree(ti_manuf_desc);\n\treturn 0;\n}\n\nstatic int do_boot_mode(struct edgeport_serial *serial,\n\t\tconst struct firmware *fw)\n{\n\tstruct device *dev = &serial->serial->interface->dev;\n\tint status = 0;\n\tstruct edge_ti_manuf_descriptor *ti_manuf_desc;\n\tstruct edgeport_fw_hdr *fw_hdr = (struct edgeport_fw_hdr *)fw->data;\n\n\tdev_dbg(dev, \"%s - RUNNING IN BOOT MODE\\n\", __func__);\n\n\t/* Configure the TI device so we can use the BULK pipes for download */\n\tstatus = config_boot_dev(serial->serial->dev);\n\tif (status)\n\t\treturn status;\n\n\tif (le16_to_cpu(serial->serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t\t!= USB_VENDOR_ID_ION) {\n\t\tdev_dbg(dev, \"%s - VID = 0x%x\\n\", __func__,\n\t\t\tle16_to_cpu(serial->serial->dev->descriptor.idVendor));\n\t\tserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;\n\t\tgoto stayinbootmode;\n\t}\n\n\t/*\n\t * We have an ION device (I2c Must be programmed)\n\t * Determine I2C image type\n\t */\n\tif (i2c_type_bootmode(serial))\n\t\tgoto stayinbootmode;\n\n\t/* Check for ION Vendor ID and that the I2C is valid */\n\tif (!check_i2c_image(serial)) {\n\t\tstruct ti_i2c_image_header *header;\n\t\tint i;\n\t\t__u8 cs = 0;\n\t\t__u8 *buffer;\n\t\tint buffer_size;\n\n\t\t/*\n\t\t * Validate Hardware version number\n\t\t * Read Manufacturing Descriptor from TI Based Edgeport\n\t\t */\n\t\tti_manuf_desc = kmalloc(sizeof(*ti_manuf_desc), GFP_KERNEL);\n\t\tif (!ti_manuf_desc)\n\t\t\treturn -ENOMEM;\n\n\t\tstatus = get_manuf_info(serial, (__u8 *)ti_manuf_desc);\n\t\tif (status) {\n\t\t\tkfree(ti_manuf_desc);\n\t\t\tgoto stayinbootmode;\n\t\t}\n\n\t\t/* Check for version 2 */\n\t\tif (!ignore_cpu_rev && ti_cpu_rev(ti_manuf_desc) < 2) {\n\t\t\tdev_dbg(dev, \"%s - Wrong CPU Rev %d (Must be 2)\\n\",\n\t\t\t\t__func__, ti_cpu_rev(ti_manuf_desc));\n\t\t\tkfree(ti_manuf_desc);\n\t\t\tgoto stayinbootmode;\n\t\t}\n\n\t\tkfree(ti_manuf_desc);\n\n\t\t/*\n\t\t * In order to update the I2C firmware we must change the type\n\t\t * 2 record to type 0xF2. This will force the UMP to come up\n\t\t * in Boot Mode.  Then while in boot mode, the driver will\n\t\t * download the latest firmware (padded to 15.5k) into the\n\t\t * UMP ram. Finally when the device comes back up in download\n\t\t * mode the driver will cause the new firmware to be copied\n\t\t * from the UMP Ram to I2C and the firmware will update the\n\t\t * record type from 0xf2 to 0x02.\n\t\t *\n\t\t * Do we really have to copy the whole firmware image,\n\t\t * or could we do this in place!\n\t\t */\n\n\t\t/* Allocate a 15.5k buffer + 3 byte header */\n\t\tbuffer_size = (((1024 * 16) - 512) +\n\t\t\t\t\tsizeof(struct ti_i2c_image_header));\n\t\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Initialize the buffer to 0xff (pad the buffer) */\n\t\tmemset(buffer, 0xff, buffer_size);\n\t\tmemcpy(buffer, &fw->data[4], fw->size - 4);\n\n\t\tfor (i = sizeof(struct ti_i2c_image_header);\n\t\t\t\ti < buffer_size; i++) {\n\t\t\tcs = (__u8)(cs + buffer[i]);\n\t\t}\n\n\t\theader = (struct ti_i2c_image_header *)buffer;\n\n\t\t/* update length and checksum after padding */\n\t\theader->Length \t = cpu_to_le16((__u16)(buffer_size -\n\t\t\t\t\tsizeof(struct ti_i2c_image_header)));\n\t\theader->CheckSum = cs;\n\n\t\t/* Download the operational code  */\n\t\tdev_dbg(dev, \"%s - Downloading operational code image version %d.%d (TI UMP)\\n\",\n\t\t\t\t__func__,\n\t\t\t\tfw_hdr->major_version, fw_hdr->minor_version);\n\t\tstatus = download_code(serial, buffer, buffer_size);\n\n\t\tkfree(buffer);\n\n\t\tif (status) {\n\t\t\tdev_dbg(dev, \"%s - Error downloading operational code image\\n\", __func__);\n\t\t\treturn status;\n\t\t}\n\n\t\t/* Device will reboot */\n\t\tserial->product_info.TiMode = TI_MODE_TRANSITIONING;\n\n\t\tdev_dbg(dev, \"%s - Download successful -- Device rebooting...\\n\", __func__);\n\n\t\treturn 1;\n\t}\n\nstayinbootmode:\n\t/* Eprom is invalid or blank stay in boot mode */\n\tdev_dbg(dev, \"%s - STAYING IN BOOT MODE\\n\", __func__);\n\tserial->product_info.TiMode = TI_MODE_BOOT;\n\n\treturn 1;\n}\n\nstatic int ti_do_config(struct edgeport_port *port, int feature, int on)\n{\n\tint port_number = port->port->port_number;\n\n\ton = !!on;\t/* 1 or 0 not bitmask */\n\treturn send_cmd(port->port->serial->dev,\n\t\t\tfeature, (__u8)(UMPM_UART1_PORT + port_number),\n\t\t\ton, NULL, 0);\n}\n\nstatic int restore_mcr(struct edgeport_port *port, __u8 mcr)\n{\n\tint status = 0;\n\n\tdev_dbg(&port->port->dev, \"%s - %x\\n\", __func__, mcr);\n\n\tstatus = ti_do_config(port, UMPC_SET_CLR_DTR, mcr & MCR_DTR);\n\tif (status)\n\t\treturn status;\n\tstatus = ti_do_config(port, UMPC_SET_CLR_RTS, mcr & MCR_RTS);\n\tif (status)\n\t\treturn status;\n\treturn ti_do_config(port, UMPC_SET_CLR_LOOPBACK, mcr & MCR_LOOPBACK);\n}\n\n/* Convert TI LSR to standard UART flags */\nstatic __u8 map_line_status(__u8 ti_lsr)\n{\n\t__u8 lsr = 0;\n\n#define MAP_FLAG(flagUmp, flagUart)    \\\n\tif (ti_lsr & flagUmp) \\\n\t\tlsr |= flagUart;\n\n\tMAP_FLAG(UMP_UART_LSR_OV_MASK, LSR_OVER_ERR)\t/* overrun */\n\tMAP_FLAG(UMP_UART_LSR_PE_MASK, LSR_PAR_ERR)\t/* parity error */\n\tMAP_FLAG(UMP_UART_LSR_FE_MASK, LSR_FRM_ERR)\t/* framing error */\n\tMAP_FLAG(UMP_UART_LSR_BR_MASK, LSR_BREAK)\t/* break detected */\n\tMAP_FLAG(UMP_UART_LSR_RX_MASK, LSR_RX_AVAIL)\t/* rx data available */\n\tMAP_FLAG(UMP_UART_LSR_TX_MASK, LSR_TX_EMPTY)\t/* tx hold reg empty */\n\n#undef MAP_FLAG\n\n\treturn lsr;\n}\n\nstatic void handle_new_msr(struct edgeport_port *edge_port, __u8 msr)\n{\n\tstruct async_icount *icount;\n\tstruct tty_struct *tty;\n\n\tdev_dbg(&edge_port->port->dev, \"%s - %02x\\n\", __func__, msr);\n\n\tif (msr & (EDGEPORT_MSR_DELTA_CTS | EDGEPORT_MSR_DELTA_DSR |\n\t\t\tEDGEPORT_MSR_DELTA_RI | EDGEPORT_MSR_DELTA_CD)) {\n\t\ticount = &edge_port->port->icount;\n\n\t\t/* update input line counters */\n\t\tif (msr & EDGEPORT_MSR_DELTA_CTS)\n\t\t\ticount->cts++;\n\t\tif (msr & EDGEPORT_MSR_DELTA_DSR)\n\t\t\ticount->dsr++;\n\t\tif (msr & EDGEPORT_MSR_DELTA_CD)\n\t\t\ticount->dcd++;\n\t\tif (msr & EDGEPORT_MSR_DELTA_RI)\n\t\t\ticount->rng++;\n\t\twake_up_interruptible(&edge_port->port->port.delta_msr_wait);\n\t}\n\n\t/* Save the new modem status */\n\tedge_port->shadow_msr = msr & 0xf0;\n\n\ttty = tty_port_tty_get(&edge_port->port->port);\n\t/* handle CTS flow control */\n\tif (tty && C_CRTSCTS(tty)) {\n\t\tif (msr & EDGEPORT_MSR_CTS)\n\t\t\ttty_wakeup(tty);\n\t}\n\ttty_kref_put(tty);\n}\n\nstatic void handle_new_lsr(struct edgeport_port *edge_port, int lsr_data,\n\t\t\t\t\t\t\t__u8 lsr, __u8 data)\n{\n\tstruct async_icount *icount;\n\t__u8 new_lsr = (__u8)(lsr & (__u8)(LSR_OVER_ERR | LSR_PAR_ERR |\n\t\t\t\t\t\tLSR_FRM_ERR | LSR_BREAK));\n\n\tdev_dbg(&edge_port->port->dev, \"%s - %02x\\n\", __func__, new_lsr);\n\n\tedge_port->shadow_lsr = lsr;\n\n\tif (new_lsr & LSR_BREAK)\n\t\t/*\n\t\t * Parity and Framing errors only count if they\n\t\t * occur exclusive of a break being received.\n\t\t */\n\t\tnew_lsr &= (__u8)(LSR_OVER_ERR | LSR_BREAK);\n\n\t/* Place LSR data byte into Rx buffer */\n\tif (lsr_data)\n\t\tedge_tty_recv(edge_port->port, &data, 1);\n\n\t/* update input line counters */\n\ticount = &edge_port->port->icount;\n\tif (new_lsr & LSR_BREAK)\n\t\ticount->brk++;\n\tif (new_lsr & LSR_OVER_ERR)\n\t\ticount->overrun++;\n\tif (new_lsr & LSR_PAR_ERR)\n\t\ticount->parity++;\n\tif (new_lsr & LSR_FRM_ERR)\n\t\ticount->frame++;\n}\n\nstatic void edge_interrupt_callback(struct urb *urb)\n{\n\tstruct edgeport_serial *edge_serial = urb->context;\n\tstruct usb_serial_port *port;\n\tstruct edgeport_port *edge_port;\n\tstruct device *dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint length = urb->actual_length;\n\tint port_number;\n\tint function;\n\tint retval;\n\t__u8 lsr;\n\t__u8 msr;\n\tint status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t/* this urb is terminated, clean up */\n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t    __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"%s - nonzero urb status received: \"\n\t\t\t\"%d\\n\", __func__, status);\n\t\tgoto exit;\n\t}\n\n\tif (!length) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - no data in urb\\n\", __func__);\n\t\tgoto exit;\n\t}\n\n\tdev = &edge_serial->serial->dev->dev;\n\tusb_serial_debug_data(dev, __func__, length, data);\n\n\tif (length != 2) {\n\t\tdev_dbg(dev, \"%s - expecting packet of size 2, got %d\\n\", __func__, length);\n\t\tgoto exit;\n\t}\n\n\tport_number = TIUMP_GET_PORT_FROM_CODE(data[0]);\n\tfunction    = TIUMP_GET_FUNC_FROM_CODE(data[0]);\n\tdev_dbg(dev, \"%s - port_number %d, function %d, info 0x%x\\n\", __func__,\n\t\tport_number, function, data[1]);\n\n\tif (port_number >= edge_serial->serial->num_ports) {\n\t\tdev_err(dev, \"bad port number %d\\n\", port_number);\n\t\tgoto exit;\n\t}\n\n\tport = edge_serial->serial->port[port_number];\n\tedge_port = usb_get_serial_port_data(port);\n\tif (!edge_port) {\n\t\tdev_dbg(dev, \"%s - edge_port not found\\n\", __func__);\n\t\treturn;\n\t}\n\tswitch (function) {\n\tcase TIUMP_INTERRUPT_CODE_LSR:\n\t\tlsr = map_line_status(data[1]);\n\t\tif (lsr & UMP_UART_LSR_DATA_MASK) {\n\t\t\t/*\n\t\t\t * Save the LSR event for bulk read completion routine\n\t\t\t */\n\t\t\tdev_dbg(dev, \"%s - LSR Event Port %u LSR Status = %02x\\n\",\n\t\t\t\t__func__, port_number, lsr);\n\t\t\tedge_port->lsr_event = 1;\n\t\t\tedge_port->lsr_mask = lsr;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"%s - ===== Port %d LSR Status = %02x ======\\n\",\n\t\t\t\t__func__, port_number, lsr);\n\t\t\thandle_new_lsr(edge_port, 0, lsr, 0);\n\t\t}\n\t\tbreak;\n\n\tcase TIUMP_INTERRUPT_CODE_MSR:\t/* MSR */\n\t\t/* Copy MSR from UMP */\n\t\tmsr = data[1];\n\t\tdev_dbg(dev, \"%s - ===== Port %u MSR Status = %02x ======\\n\",\n\t\t\t__func__, port_number, msr);\n\t\thandle_new_msr(edge_port, msr);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\"%s - Unknown Interrupt code from UMP %x\\n\",\n\t\t\t__func__, data[1]);\n\t\tbreak;\n\n\t}\n\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t __func__, retval);\n}\n\nstatic void edge_bulk_in_callback(struct urb *urb)\n{\n\tstruct edgeport_port *edge_port = urb->context;\n\tstruct device *dev = &edge_port->port->dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint retval = 0;\n\tint port_number;\n\tint status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t/* this urb is terminated, clean up */\n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"%s - nonzero read bulk status received: %d\\n\", __func__, status);\n\t}\n\n\tif (status == -EPIPE)\n\t\tgoto exit;\n\n\tif (status) {\n\t\tdev_err(&urb->dev->dev, \"%s - stopping read!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tport_number = edge_port->port->port_number;\n\n\tif (urb->actual_length > 0 && edge_port->lsr_event) {\n\t\tedge_port->lsr_event = 0;\n\t\tdev_dbg(dev, \"%s ===== Port %u LSR Status = %02x, Data = %02x ======\\n\",\n\t\t\t__func__, port_number, edge_port->lsr_mask, *data);\n\t\thandle_new_lsr(edge_port, 1, edge_port->lsr_mask, *data);\n\t\t/* Adjust buffer length/pointer */\n\t\t--urb->actual_length;\n\t\t++data;\n\t}\n\n\tif (urb->actual_length) {\n\t\tusb_serial_debug_data(dev, __func__, urb->actual_length, data);\n\t\tif (edge_port->close_pending)\n\t\t\tdev_dbg(dev, \"%s - close pending, dropping data on the floor\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\telse\n\t\t\tedge_tty_recv(edge_port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\tedge_port->port->icount.rx += urb->actual_length;\n\t}\n\nexit:\n\t/* continue read unless stopped */\n\tspin_lock(&edge_port->ep_lock);\n\tif (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)\n\t\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\telse if (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPING)\n\t\tedge_port->ep_read_urb_state = EDGE_READ_URB_STOPPED;\n\n\tspin_unlock(&edge_port->ep_lock);\n\tif (retval)\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result %d\\n\", __func__, retval);\n}\n\nstatic void edge_tty_recv(struct usb_serial_port *port, unsigned char *data,\n\t\tint length)\n{\n\tint queued;\n\n\tqueued = tty_insert_flip_string(&port->port, data, length);\n\tif (queued < length)\n\t\tdev_err(&port->dev, \"%s - dropping data, %d bytes lost\\n\",\n\t\t\t__func__, length - queued);\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic void edge_bulk_out_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint status = urb->status;\n\tstruct tty_struct *tty;\n\n\tedge_port->ep_write_urb_in_use = 0;\n\n\tswitch (status) {\n\tcase 0:\n\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t/* this urb is terminated, clean up */\n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t    __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err_console(port, \"%s - nonzero write bulk status \"\n\t\t\t\"received: %d\\n\", __func__, status);\n\t}\n\n\t/* send any buffered data */\n\ttty = tty_port_tty_get(&port->port);\n\tedge_send(port, tty);\n\ttty_kref_put(tty);\n}\n\nstatic int edge_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tstruct edgeport_serial *edge_serial;\n\tstruct usb_device *dev;\n\tstruct urb *urb;\n\tint port_number;\n\tint status;\n\tu16 open_settings;\n\tu8 transaction_timeout;\n\n\tif (edge_port == NULL)\n\t\treturn -ENODEV;\n\n\tport_number = port->port_number;\n\n\tdev = port->serial->dev;\n\n\t/* turn off loopback */\n\tstatus = ti_do_config(edge_port, UMPC_SET_CLR_LOOPBACK, 0);\n\tif (status) {\n\t\tdev_err(&port->dev,\n\t\t\t\t\"%s - cannot send clear loopback command, %d\\n\",\n\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\t/* set up the port settings */\n\tif (tty)\n\t\tedge_set_termios(tty, port, &tty->termios);\n\n\t/* open up the port */\n\n\t/* milliseconds to timeout for DMA transfer */\n\ttransaction_timeout = 2;\n\n\tedge_port->ump_read_timeout =\n\t\t\t\tmax(20, ((transaction_timeout * 3) / 2));\n\n\t/* milliseconds to timeout for DMA transfer */\n\topen_settings = (u8)(UMP_DMA_MODE_CONTINOUS |\n\t\t\t     UMP_PIPE_TRANS_TIMEOUT_ENA |\n\t\t\t     (transaction_timeout << 2));\n\n\tdev_dbg(&port->dev, \"%s - Sending UMPC_OPEN_PORT\\n\", __func__);\n\n\t/* Tell TI to open and start the port */\n\tstatus = send_cmd(dev, UMPC_OPEN_PORT,\n\t\t(u8)(UMPM_UART1_PORT + port_number), open_settings, NULL, 0);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s - cannot send open command, %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\t/* Start the DMA? */\n\tstatus = send_cmd(dev, UMPC_START_PORT,\n\t\t(u8)(UMPM_UART1_PORT + port_number), 0, NULL, 0);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s - cannot send start DMA command, %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\t/* Clear TX and RX buffers in UMP */\n\tstatus = purge_port(port, UMP_PORT_DIR_OUT | UMP_PORT_DIR_IN);\n\tif (status) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - cannot send clear buffers command, %d\\n\",\n\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\t/* Read Initial MSR */\n\tstatus = ti_vread_sync(dev, UMPC_READ_MSR, 0,\n\t\t\t\t(__u16)(UMPM_UART1_PORT + port_number),\n\t\t\t\t&edge_port->shadow_msr, 1);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s - cannot send read MSR command, %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\tdev_dbg(&port->dev, \"ShadowMSR 0x%X\\n\", edge_port->shadow_msr);\n\n\t/* Set Initial MCR */\n\tedge_port->shadow_mcr = MCR_RTS | MCR_DTR;\n\tdev_dbg(&port->dev, \"ShadowMCR 0x%X\\n\", edge_port->shadow_mcr);\n\n\tedge_serial = edge_port->edge_serial;\n\tif (mutex_lock_interruptible(&edge_serial->es_lock))\n\t\treturn -ERESTARTSYS;\n\tif (edge_serial->num_ports_open == 0) {\n\t\t/* we are the first port to open, post the interrupt urb */\n\t\turb = edge_serial->serial->port[0]->interrupt_in_urb;\n\t\turb->context = edge_serial;\n\t\tstatus = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (status) {\n\t\t\tdev_err(&port->dev,\n\t\t\t\t\"%s - usb_submit_urb failed with value %d\\n\",\n\t\t\t\t\t__func__, status);\n\t\t\tgoto release_es_lock;\n\t\t}\n\t}\n\n\t/*\n\t * reset the data toggle on the bulk endpoints to work around bug in\n\t * host controllers where things get out of sync some times\n\t */\n\tusb_clear_halt(dev, port->write_urb->pipe);\n\tusb_clear_halt(dev, port->read_urb->pipe);\n\n\t/* start up our bulk read urb */\n\turb = port->read_urb;\n\tedge_port->ep_read_urb_state = EDGE_READ_URB_RUNNING;\n\turb->context = edge_port;\n\tstatus = usb_submit_urb(urb, GFP_KERNEL);\n\tif (status) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - read bulk usb_submit_urb failed with value %d\\n\",\n\t\t\t\t__func__, status);\n\t\tgoto unlink_int_urb;\n\t}\n\n\t++edge_serial->num_ports_open;\n\n\tgoto release_es_lock;\n\nunlink_int_urb:\n\tif (edge_port->edge_serial->num_ports_open == 0)\n\t\tusb_kill_urb(port->serial->port[0]->interrupt_in_urb);\nrelease_es_lock:\n\tmutex_unlock(&edge_serial->es_lock);\n\treturn status;\n}\n\nstatic void edge_close(struct usb_serial_port *port)\n{\n\tstruct edgeport_serial *edge_serial;\n\tstruct edgeport_port *edge_port;\n\tstruct usb_serial *serial = port->serial;\n\tunsigned long flags;\n\tint port_number;\n\n\tedge_serial = usb_get_serial_data(port->serial);\n\tedge_port = usb_get_serial_port_data(port);\n\tif (edge_serial == NULL || edge_port == NULL)\n\t\treturn;\n\n\t/*\n\t * The bulkreadcompletion routine will check\n\t * this flag and dump add read data\n\t */\n\tedge_port->close_pending = 1;\n\n\tusb_kill_urb(port->read_urb);\n\tusb_kill_urb(port->write_urb);\n\tedge_port->ep_write_urb_in_use = 0;\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\tkfifo_reset_out(&port->write_fifo);\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - send umpc_close_port\\n\", __func__);\n\tport_number = port->port_number;\n\tsend_cmd(serial->dev, UMPC_CLOSE_PORT,\n\t\t     (__u8)(UMPM_UART1_PORT + port_number), 0, NULL, 0);\n\n\tmutex_lock(&edge_serial->es_lock);\n\t--edge_port->edge_serial->num_ports_open;\n\tif (edge_port->edge_serial->num_ports_open <= 0) {\n\t\t/* last port is now closed, let's shut down our interrupt urb */\n\t\tusb_kill_urb(port->serial->port[0]->interrupt_in_urb);\n\t\tedge_port->edge_serial->num_ports_open = 0;\n\t}\n\tmutex_unlock(&edge_serial->es_lock);\n\tedge_port->close_pending = 0;\n}\n\nstatic int edge_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\t\tconst unsigned char *data, int count)\n{\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\n\tif (count == 0) {\n\t\tdev_dbg(&port->dev, \"%s - write request of 0 bytes\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tif (edge_port == NULL)\n\t\treturn -ENODEV;\n\tif (edge_port->close_pending == 1)\n\t\treturn -ENODEV;\n\n\tcount = kfifo_in_locked(&port->write_fifo, data, count,\n\t\t\t\t\t\t\t&edge_port->ep_lock);\n\tedge_send(port, tty);\n\n\treturn count;\n}\n\nstatic void edge_send(struct usb_serial_port *port, struct tty_struct *tty)\n{\n\tint count, result;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\n\tif (edge_port->ep_write_urb_in_use) {\n\t\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\t\treturn;\n\t}\n\n\tcount = kfifo_out(&port->write_fifo,\n\t\t\t\tport->write_urb->transfer_buffer,\n\t\t\t\tport->bulk_out_size);\n\n\tif (count == 0) {\n\t\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\t\treturn;\n\t}\n\n\tedge_port->ep_write_urb_in_use = 1;\n\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\tusb_serial_debug_data(&port->dev, __func__, count, port->write_urb->transfer_buffer);\n\n\t/* set up our urb */\n\tport->write_urb->transfer_buffer_length = count;\n\n\t/* send the data out the bulk port */\n\tresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\n\tif (result) {\n\t\tdev_err_console(port,\n\t\t\t\"%s - failed submitting write urb, error %d\\n\",\n\t\t\t\t__func__, result);\n\t\tedge_port->ep_write_urb_in_use = 0;\n\t\t/* TODO: reschedule edge_send */\n\t} else\n\t\tedge_port->port->icount.tx += count;\n\n\t/*\n\t * wakeup any process waiting for writes to complete\n\t * there is now more room in the buffer for new writes\n\t */\n\tif (tty)\n\t\ttty_wakeup(tty);\n}\n\nstatic int edge_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint room = 0;\n\tunsigned long flags;\n\n\tif (edge_port == NULL)\n\t\treturn 0;\n\tif (edge_port->close_pending == 1)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\troom = kfifo_avail(&port->write_fifo);\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - returns %d\\n\", __func__, room);\n\treturn room;\n}\n\nstatic int edge_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint chars = 0;\n\tunsigned long flags;\n\tif (edge_port == NULL)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\tchars = kfifo_len(&port->write_fifo);\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - returns %d\\n\", __func__, chars);\n\treturn chars;\n}\n\nstatic bool edge_tx_empty(struct usb_serial_port *port)\n{\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint ret;\n\n\tret = tx_active(edge_port);\n\tif (ret > 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void edge_throttle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint status;\n\n\tif (edge_port == NULL)\n\t\treturn;\n\n\t/* if we are implementing XON/XOFF, send the stop character */\n\tif (I_IXOFF(tty)) {\n\t\tunsigned char stop_char = STOP_CHAR(tty);\n\t\tstatus = edge_write(tty, port, &stop_char, 1);\n\t\tif (status <= 0) {\n\t\t\tdev_err(&port->dev, \"%s - failed to write stop character, %d\\n\", __func__, status);\n\t\t}\n\t}\n\n\t/*\n\t * if we are implementing RTS/CTS, stop reads\n\t * and the Edgeport will clear the RTS line\n\t */\n\tif (C_CRTSCTS(tty))\n\t\tstop_read(edge_port);\n\n}\n\nstatic void edge_unthrottle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint status;\n\n\tif (edge_port == NULL)\n\t\treturn;\n\n\t/* if we are implementing XON/XOFF, send the start character */\n\tif (I_IXOFF(tty)) {\n\t\tunsigned char start_char = START_CHAR(tty);\n\t\tstatus = edge_write(tty, port, &start_char, 1);\n\t\tif (status <= 0) {\n\t\t\tdev_err(&port->dev, \"%s - failed to write start character, %d\\n\", __func__, status);\n\t\t}\n\t}\n\t/*\n\t * if we are implementing RTS/CTS, restart reads\n\t * are the Edgeport will assert the RTS line\n\t */\n\tif (C_CRTSCTS(tty)) {\n\t\tstatus = restart_read(edge_port);\n\t\tif (status)\n\t\t\tdev_err(&port->dev,\n\t\t\t\t\"%s - read bulk usb_submit_urb failed: %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t}\n\n}\n\nstatic void stop_read(struct edgeport_port *edge_port)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\n\tif (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)\n\t\tedge_port->ep_read_urb_state = EDGE_READ_URB_STOPPING;\n\tedge_port->shadow_mcr &= ~MCR_RTS;\n\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n}\n\nstatic int restart_read(struct edgeport_port *edge_port)\n{\n\tstruct urb *urb;\n\tint status = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\n\tif (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPED) {\n\t\turb = edge_port->port->read_urb;\n\t\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\t}\n\tedge_port->ep_read_urb_state = EDGE_READ_URB_RUNNING;\n\tedge_port->shadow_mcr |= MCR_RTS;\n\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\treturn status;\n}\n\nstatic void change_port_settings(struct tty_struct *tty,\n\t\tstruct edgeport_port *edge_port, struct ktermios *old_termios)\n{\n\tstruct device *dev = &edge_port->port->dev;\n\tstruct ump_uart_config *config;\n\tint baud;\n\tunsigned cflag;\n\tint status;\n\tint port_number = edge_port->port->port_number;\n\n\tconfig = kmalloc (sizeof (*config), GFP_KERNEL);\n\tif (!config) {\n\t\ttty->termios = *old_termios;\n\t\treturn;\n\t}\n\n\tcflag = tty->termios.c_cflag;\n\n\tconfig->wFlags = 0;\n\n\t/* These flags must be set */\n\tconfig->wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT;\n\tconfig->wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR;\n\tconfig->bUartMode = (__u8)(edge_port->bUartMode);\n\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\t    config->bDataBits = UMP_UART_CHAR5BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 5\\n\", __func__);\n\t\t    break;\n\tcase CS6:\n\t\t    config->bDataBits = UMP_UART_CHAR6BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 6\\n\", __func__);\n\t\t    break;\n\tcase CS7:\n\t\t    config->bDataBits = UMP_UART_CHAR7BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 7\\n\", __func__);\n\t\t    break;\n\tdefault:\n\tcase CS8:\n\t\t    config->bDataBits = UMP_UART_CHAR8BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 8\\n\", __func__);\n\t\t\t    break;\n\t}\n\n\tif (cflag & PARENB) {\n\t\tif (cflag & PARODD) {\n\t\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_PARITY;\n\t\t\tconfig->bParity = UMP_UART_ODDPARITY;\n\t\t\tdev_dbg(dev, \"%s - parity = odd\\n\", __func__);\n\t\t} else {\n\t\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_PARITY;\n\t\t\tconfig->bParity = UMP_UART_EVENPARITY;\n\t\t\tdev_dbg(dev, \"%s - parity = even\\n\", __func__);\n\t\t}\n\t} else {\n\t\tconfig->bParity = UMP_UART_NOPARITY;\n\t\tdev_dbg(dev, \"%s - parity = none\\n\", __func__);\n\t}\n\n\tif (cflag & CSTOPB) {\n\t\tconfig->bStopBits = UMP_UART_STOPBIT2;\n\t\tdev_dbg(dev, \"%s - stop bits = 2\\n\", __func__);\n\t} else {\n\t\tconfig->bStopBits = UMP_UART_STOPBIT1;\n\t\tdev_dbg(dev, \"%s - stop bits = 1\\n\", __func__);\n\t}\n\n\t/* figure out the flow control settings */\n\tif (cflag & CRTSCTS) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_OUT_X_CTS_FLOW;\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_RTS_FLOW;\n\t\tdev_dbg(dev, \"%s - RTS/CTS is enabled\\n\", __func__);\n\t} else {\n\t\tdev_dbg(dev, \"%s - RTS/CTS is disabled\\n\", __func__);\n\t\trestart_read(edge_port);\n\t}\n\n\t/*\n\t * if we are implementing XON/XOFF, set the start and stop\n\t * character in the device\n\t */\n\tconfig->cXon  = START_CHAR(tty);\n\tconfig->cXoff = STOP_CHAR(tty);\n\n\t/* if we are implementing INBOUND XON/XOFF */\n\tif (I_IXOFF(tty)) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_IN_X;\n\t\tdev_dbg(dev, \"%s - INBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\\n\",\n\t\t\t__func__, config->cXon, config->cXoff);\n\t} else\n\t\tdev_dbg(dev, \"%s - INBOUND XON/XOFF is disabled\\n\", __func__);\n\n\t/* if we are implementing OUTBOUND XON/XOFF */\n\tif (I_IXON(tty)) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_OUT_X;\n\t\tdev_dbg(dev, \"%s - OUTBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\\n\",\n\t\t\t__func__, config->cXon, config->cXoff);\n\t} else\n\t\tdev_dbg(dev, \"%s - OUTBOUND XON/XOFF is disabled\\n\", __func__);\n\n\ttty->termios.c_cflag &= ~CMSPAR;\n\n\t/* Round the baud rate */\n\tbaud = tty_get_baud_rate(tty);\n\tif (!baud) {\n\t\t/* pick a default, any default... */\n\t\tbaud = 9600;\n\t} else {\n\t\t/* Avoid a zero divisor. */\n\t\tbaud = min(baud, 461550);\n\t\ttty_encode_baud_rate(tty, baud, baud);\n\t}\n\n\tedge_port->baud_rate = baud;\n\tconfig->wBaudRate = (__u16)((461550L + baud/2) / baud);\n\n\t/* FIXME: Recompute actual baud from divisor here */\n\n\tdev_dbg(dev, \"%s - baud rate = %d, wBaudRate = %d\\n\", __func__, baud, config->wBaudRate);\n\n\tdev_dbg(dev, \"wBaudRate:   %d\\n\", (int)(461550L / config->wBaudRate));\n\tdev_dbg(dev, \"wFlags:    0x%x\\n\", config->wFlags);\n\tdev_dbg(dev, \"bDataBits:   %d\\n\", config->bDataBits);\n\tdev_dbg(dev, \"bParity:     %d\\n\", config->bParity);\n\tdev_dbg(dev, \"bStopBits:   %d\\n\", config->bStopBits);\n\tdev_dbg(dev, \"cXon:        %d\\n\", config->cXon);\n\tdev_dbg(dev, \"cXoff:       %d\\n\", config->cXoff);\n\tdev_dbg(dev, \"bUartMode:   %d\\n\", config->bUartMode);\n\n\t/* move the word values into big endian mode */\n\tcpu_to_be16s(&config->wFlags);\n\tcpu_to_be16s(&config->wBaudRate);\n\n\tstatus = send_cmd(edge_port->port->serial->dev, UMPC_SET_CONFIG,\n\t\t\t\t(__u8)(UMPM_UART1_PORT + port_number),\n\t\t\t\t0, (__u8 *)config, sizeof(*config));\n\tif (status)\n\t\tdev_dbg(dev, \"%s - error %d when trying to write config to device\\n\",\n\t\t\t__func__, status);\n\tkfree(config);\n}\n\nstatic void edge_set_termios(struct tty_struct *tty,\n\t\tstruct usb_serial_port *port, struct ktermios *old_termios)\n{\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\n\tif (edge_port == NULL)\n\t\treturn;\n\t/* change the port settings to the new ones specified */\n\tchange_port_settings(tty, edge_port, old_termios);\n}\n\nstatic int edge_tiocmset(struct tty_struct *tty,\n\t\t\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tunsigned int mcr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\tmcr = edge_port->shadow_mcr;\n\tif (set & TIOCM_RTS)\n\t\tmcr |= MCR_RTS;\n\tif (set & TIOCM_DTR)\n\t\tmcr |= MCR_DTR;\n\tif (set & TIOCM_LOOP)\n\t\tmcr |= MCR_LOOPBACK;\n\n\tif (clear & TIOCM_RTS)\n\t\tmcr &= ~MCR_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tmcr &= ~MCR_DTR;\n\tif (clear & TIOCM_LOOP)\n\t\tmcr &= ~MCR_LOOPBACK;\n\n\tedge_port->shadow_mcr = mcr;\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\trestore_mcr(edge_port, mcr);\n\treturn 0;\n}\n\nstatic int edge_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tunsigned int result = 0;\n\tunsigned int msr;\n\tunsigned int mcr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\n\tmsr = edge_port->shadow_msr;\n\tmcr = edge_port->shadow_mcr;\n\tresult = ((mcr & MCR_DTR)\t? TIOCM_DTR: 0)\t  /* 0x002 */\n\t\t  | ((mcr & MCR_RTS)\t? TIOCM_RTS: 0)   /* 0x004 */\n\t\t  | ((msr & EDGEPORT_MSR_CTS)\t? TIOCM_CTS: 0)   /* 0x020 */\n\t\t  | ((msr & EDGEPORT_MSR_CD)\t? TIOCM_CAR: 0)   /* 0x040 */\n\t\t  | ((msr & EDGEPORT_MSR_RI)\t? TIOCM_RI:  0)   /* 0x080 */\n\t\t  | ((msr & EDGEPORT_MSR_DSR)\t? TIOCM_DSR: 0);  /* 0x100 */\n\n\n\tdev_dbg(&port->dev, \"%s -- %x\\n\", __func__, result);\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\treturn result;\n}\n\nstatic int get_serial_info(struct edgeport_port *edge_port,\n\t\t\t\tstruct serial_struct __user *retinfo)\n{\n\tstruct serial_struct tmp;\n\tunsigned cwait;\n\n\tcwait = edge_port->port->port.closing_wait;\n\tif (cwait != ASYNC_CLOSING_WAIT_NONE)\n\t\tcwait = jiffies_to_msecs(cwait) / 10;\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\n\ttmp.type\t\t= PORT_16550A;\n\ttmp.line\t\t= edge_port->port->minor;\n\ttmp.port\t\t= edge_port->port->port_number;\n\ttmp.irq\t\t\t= 0;\n\ttmp.xmit_fifo_size\t= edge_port->port->bulk_out_size;\n\ttmp.baud_base\t\t= 9600;\n\ttmp.close_delay\t\t= 5*HZ;\n\ttmp.closing_wait\t= cwait;\n\n\tif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int edge_ioctl(struct tty_struct *tty,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\n\tswitch (cmd) {\n\tcase TIOCGSERIAL:\n\t\tdev_dbg(&port->dev, \"%s - TIOCGSERIAL\\n\", __func__);\n\t\treturn get_serial_info(edge_port,\n\t\t\t\t(struct serial_struct __user *) arg);\n\t}\n\treturn -ENOIOCTLCMD;\n}\n\nstatic void edge_break(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint status;\n\tint bv = 0;\t/* Off */\n\n\tif (break_state == -1)\n\t\tbv = 1;\t/* On */\n\tstatus = ti_do_config(edge_port, UMPC_SET_CLR_BREAK, bv);\n\tif (status)\n\t\tdev_dbg(&port->dev, \"%s - error %d sending break set/clear command.\\n\",\n\t\t\t__func__, status);\n}\n\nstatic void edge_heartbeat_schedule(struct edgeport_serial *edge_serial)\n{\n\tif (!edge_serial->use_heartbeat)\n\t\treturn;\n\n\tschedule_delayed_work(&edge_serial->heartbeat_work,\n\t\t\tFW_HEARTBEAT_SECS * HZ);\n}\n\nstatic void edge_heartbeat_work(struct work_struct *work)\n{\n\tstruct edgeport_serial *serial;\n\tstruct ti_i2c_desc *rom_desc;\n\n\tserial = container_of(work, struct edgeport_serial,\n\t\t\theartbeat_work.work);\n\n\trom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\n\n\t/* Descriptor address request is enough to reset the firmware timer */\n\tif (!rom_desc || !get_descriptor_addr(serial, I2C_DESC_TYPE_ION,\n\t\t\trom_desc)) {\n\t\tdev_err(&serial->serial->interface->dev,\n\t\t\t\t\"%s - Incomplete heartbeat\\n\", __func__);\n\t}\n\tkfree(rom_desc);\n\n\tedge_heartbeat_schedule(serial);\n}\n\nstatic int edge_calc_num_ports(struct usb_serial *serial,\n\t\t\t\tstruct usb_serial_endpoints *epds)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tunsigned char num_ports = serial->type->num_ports;\n\n\t/* Make sure we have the required endpoints when in download mode. */\n\tif (serial->interface->cur_altsetting->desc.bNumEndpoints > 1) {\n\t\tif (epds->num_bulk_in < num_ports ||\n\t\t\t\tepds->num_bulk_out < num_ports ||\n\t\t\t\tepds->num_interrupt_in < 1) {\n\t\t\tdev_err(dev, \"required endpoints missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn num_ports;\n}\n\nstatic int edge_startup(struct usb_serial *serial)\n{\n\tstruct edgeport_serial *edge_serial;\n\tint status;\n\tu16 product_id;\n\n\t/* create our private serial structure */\n\tedge_serial = kzalloc(sizeof(struct edgeport_serial), GFP_KERNEL);\n\tif (!edge_serial)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&edge_serial->es_lock);\n\tedge_serial->serial = serial;\n\tINIT_DELAYED_WORK(&edge_serial->heartbeat_work, edge_heartbeat_work);\n\tusb_set_serial_data(serial, edge_serial);\n\n\tstatus = download_fw(edge_serial);\n\tif (status < 0) {\n\t\tkfree(edge_serial);\n\t\treturn status;\n\t}\n\n\tif (status > 0)\n\t\treturn 1;\t/* bind but do not register any ports */\n\n\tproduct_id = le16_to_cpu(\n\t\t\tedge_serial->serial->dev->descriptor.idProduct);\n\n\t/* Currently only the EP/416 models require heartbeat support */\n\tif (edge_serial->fw_version > FW_HEARTBEAT_VERSION_CUTOFF) {\n\t\tif (product_id == ION_DEVICE_ID_TI_EDGEPORT_416 ||\n\t\t\tproduct_id == ION_DEVICE_ID_TI_EDGEPORT_416B) {\n\t\t\tedge_serial->use_heartbeat = true;\n\t\t}\n\t}\n\n\tedge_heartbeat_schedule(edge_serial);\n\n\treturn 0;\n}\n\nstatic void edge_disconnect(struct usb_serial *serial)\n{\n\tstruct edgeport_serial *edge_serial = usb_get_serial_data(serial);\n\n\tcancel_delayed_work_sync(&edge_serial->heartbeat_work);\n}\n\nstatic void edge_release(struct usb_serial *serial)\n{\n\tstruct edgeport_serial *edge_serial = usb_get_serial_data(serial);\n\n\tcancel_delayed_work_sync(&edge_serial->heartbeat_work);\n\tkfree(edge_serial);\n}\n\nstatic int edge_port_probe(struct usb_serial_port *port)\n{\n\tstruct edgeport_port *edge_port;\n\tint ret;\n\n\tedge_port = kzalloc(sizeof(*edge_port), GFP_KERNEL);\n\tif (!edge_port)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&edge_port->ep_lock);\n\tedge_port->port = port;\n\tedge_port->edge_serial = usb_get_serial_data(port->serial);\n\tedge_port->bUartMode = default_uart_mode;\n\n\tswitch (port->port_number) {\n\tcase 0:\n\t\tedge_port->uart_base = UMPMEM_BASE_UART1;\n\t\tedge_port->dma_address = UMPD_OEDB1_ADDRESS;\n\t\tbreak;\n\tcase 1:\n\t\tedge_port->uart_base = UMPMEM_BASE_UART2;\n\t\tedge_port->dma_address = UMPD_OEDB2_ADDRESS;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&port->dev, \"unknown port number\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tdev_dbg(&port->dev,\n\t\t\"%s - port_number = %d, uart_base = %04x, dma_address = %04x\\n\",\n\t\t__func__, port->port_number, edge_port->uart_base,\n\t\tedge_port->dma_address);\n\n\tusb_set_serial_port_data(port, edge_port);\n\n\tret = edge_create_sysfs_attrs(port);\n\tif (ret)\n\t\tgoto err;\n\n\tport->port.closing_wait = msecs_to_jiffies(closing_wait * 10);\n\tport->port.drain_delay = 1;\n\n\treturn 0;\nerr:\n\tkfree(edge_port);\n\n\treturn ret;\n}\n\nstatic int edge_port_remove(struct usb_serial_port *port)\n{\n\tstruct edgeport_port *edge_port;\n\n\tedge_port = usb_get_serial_port_data(port);\n\tedge_remove_sysfs_attrs(port);\n\tkfree(edge_port);\n\n\treturn 0;\n}\n\n/* Sysfs Attributes */\n\nstatic ssize_t uart_mode_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\n\treturn sprintf(buf, \"%d\\n\", edge_port->bUartMode);\n}\n\nstatic ssize_t uart_mode_store(struct device *dev,\n\tstruct device_attribute *attr, const char *valbuf, size_t count)\n{\n\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tunsigned int v = simple_strtoul(valbuf, NULL, 0);\n\n\tdev_dbg(dev, \"%s: setting uart_mode = %d\\n\", __func__, v);\n\n\tif (v < 256)\n\t\tedge_port->bUartMode = v;\n\telse\n\t\tdev_err(dev, \"%s - uart_mode %d is invalid\\n\", __func__, v);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(uart_mode);\n\nstatic int edge_create_sysfs_attrs(struct usb_serial_port *port)\n{\n\treturn device_create_file(&port->dev, &dev_attr_uart_mode);\n}\n\nstatic int edge_remove_sysfs_attrs(struct usb_serial_port *port)\n{\n\tdevice_remove_file(&port->dev, &dev_attr_uart_mode);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int edge_suspend(struct usb_serial *serial, pm_message_t message)\n{\n\tstruct edgeport_serial *edge_serial = usb_get_serial_data(serial);\n\n\tcancel_delayed_work_sync(&edge_serial->heartbeat_work);\n\n\treturn 0;\n}\n\nstatic int edge_resume(struct usb_serial *serial)\n{\n\tstruct edgeport_serial *edge_serial = usb_get_serial_data(serial);\n\n\tedge_heartbeat_schedule(edge_serial);\n\n\treturn 0;\n}\n#endif\n\nstatic struct usb_serial_driver edgeport_1port_device = {\n\t.driver = {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"edgeport_ti_1\",\n\t},\n\t.description\t\t= \"Edgeport TI 1 port adapter\",\n\t.id_table\t\t= edgeport_1port_id_table,\n\t.num_ports\t\t= 1,\n\t.num_bulk_out\t\t= 1,\n\t.open\t\t\t= edge_open,\n\t.close\t\t\t= edge_close,\n\t.throttle\t\t= edge_throttle,\n\t.unthrottle\t\t= edge_unthrottle,\n\t.attach\t\t\t= edge_startup,\n\t.calc_num_ports\t\t= edge_calc_num_ports,\n\t.disconnect\t\t= edge_disconnect,\n\t.release\t\t= edge_release,\n\t.port_probe\t\t= edge_port_probe,\n\t.port_remove\t\t= edge_port_remove,\n\t.ioctl\t\t\t= edge_ioctl,\n\t.set_termios\t\t= edge_set_termios,\n\t.tiocmget\t\t= edge_tiocmget,\n\t.tiocmset\t\t= edge_tiocmset,\n\t.tiocmiwait\t\t= usb_serial_generic_tiocmiwait,\n\t.get_icount\t\t= usb_serial_generic_get_icount,\n\t.write\t\t\t= edge_write,\n\t.write_room\t\t= edge_write_room,\n\t.chars_in_buffer\t= edge_chars_in_buffer,\n\t.tx_empty\t\t= edge_tx_empty,\n\t.break_ctl\t\t= edge_break,\n\t.read_int_callback\t= edge_interrupt_callback,\n\t.read_bulk_callback\t= edge_bulk_in_callback,\n\t.write_bulk_callback\t= edge_bulk_out_callback,\n#ifdef CONFIG_PM\n\t.suspend\t\t= edge_suspend,\n\t.resume\t\t\t= edge_resume,\n#endif\n};\n\nstatic struct usb_serial_driver edgeport_2port_device = {\n\t.driver = {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"edgeport_ti_2\",\n\t},\n\t.description\t\t= \"Edgeport TI 2 port adapter\",\n\t.id_table\t\t= edgeport_2port_id_table,\n\t.num_ports\t\t= 2,\n\t.num_bulk_out\t\t= 1,\n\t.open\t\t\t= edge_open,\n\t.close\t\t\t= edge_close,\n\t.throttle\t\t= edge_throttle,\n\t.unthrottle\t\t= edge_unthrottle,\n\t.attach\t\t\t= edge_startup,\n\t.calc_num_ports\t\t= edge_calc_num_ports,\n\t.disconnect\t\t= edge_disconnect,\n\t.release\t\t= edge_release,\n\t.port_probe\t\t= edge_port_probe,\n\t.port_remove\t\t= edge_port_remove,\n\t.ioctl\t\t\t= edge_ioctl,\n\t.set_termios\t\t= edge_set_termios,\n\t.tiocmget\t\t= edge_tiocmget,\n\t.tiocmset\t\t= edge_tiocmset,\n\t.tiocmiwait\t\t= usb_serial_generic_tiocmiwait,\n\t.get_icount\t\t= usb_serial_generic_get_icount,\n\t.write\t\t\t= edge_write,\n\t.write_room\t\t= edge_write_room,\n\t.chars_in_buffer\t= edge_chars_in_buffer,\n\t.tx_empty\t\t= edge_tx_empty,\n\t.break_ctl\t\t= edge_break,\n\t.read_int_callback\t= edge_interrupt_callback,\n\t.read_bulk_callback\t= edge_bulk_in_callback,\n\t.write_bulk_callback\t= edge_bulk_out_callback,\n#ifdef CONFIG_PM\n\t.suspend\t\t= edge_suspend,\n\t.resume\t\t\t= edge_resume,\n#endif\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&edgeport_1port_device, &edgeport_2port_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table_combined);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"edgeport/down3.bin\");\n\nmodule_param(closing_wait, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(closing_wait, \"Maximum wait for data to drain, in .01 secs\");\n\nmodule_param(ignore_cpu_rev, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ignore_cpu_rev,\n\t\t\t\"Ignore the cpu revision when connecting to a device\");\n\nmodule_param(default_uart_mode, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(default_uart_mode, \"Default uart_mode, 0=RS232, ...\");\n"], "filenames": ["drivers/usb/serial/io_ti.c"], "buggy_code_start_loc": [2339], "buggy_code_end_loc": [2340], "fixing_code_start_loc": [2339], "fixing_code_end_loc": [2344], "type": "CWE-369", "message": "In change_port_settings in drivers/usb/serial/io_ti.c in the Linux kernel before 4.11.3, local users could cause a denial of service by division-by-zero in the serial device layer by trying to set very high baud rates.", "other": {"cve": {"id": "CVE-2017-18360", "sourceIdentifier": "cve@mitre.org", "published": "2019-01-31T09:29:00.220", "lastModified": "2019-04-17T17:41:09.037", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In change_port_settings in drivers/usb/serial/io_ti.c in the Linux kernel before 4.11.3, local users could cause a denial of service by division-by-zero in the serial device layer by trying to set very high baud rates."}, {"lang": "es", "value": "En change_port_settings en drivers/usb/serial/io_ti.c en el kernel de Linux, en versiones anteriores a la 4.11.3, los usuarios locales podr\u00edan provocar una denegaci\u00f3n de servicio (DoS) por medio de una divisi\u00f3n entre cero en la capa del dispositivo en serie intentando establecer tasas de baudio muy altas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.11.3", "matchCriteriaId": "BE3BBF22-09CC-4B94-B634-572E29C66ACA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6aeb75e6adfaed16e58780309613a578fe1ee90b", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/106802", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1123706", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.11.3", "source": "cve@mitre.org", "tags": ["Vendor Advisory", "Release Notes"]}, {"url": "https://github.com/torvalds/linux/commit/6aeb75e6adfaed16e58780309613a578fe1ee90b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3933-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3933-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6aeb75e6adfaed16e58780309613a578fe1ee90b"}}