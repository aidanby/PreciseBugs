{"buggy_code": ["/* radare2 - LGPL - Copyright 2011-2023 - pancake */\n\n#include <r_arch.h>\n\nstatic size_t countChar(const ut8 *buf, int len, char ch) {\n\tsize_t i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (buf[i] != ch) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\n\nstatic int getid(char ch) {\n\tconst char *keys = \"[]<>+-,.\";\n\tconst char *cidx = strchr (keys, ch);\n\treturn cidx? cidx - keys + 1: 0;\n}\n\nstatic int disassemble(RAnalOp *op, const ut8 *buf, int len) {\n\tconst ut8 *b;\n\tsize_t rep = 1;\n\n\t/* Count repetitions of the current instruction, unless it's a trap. */\n\tif (*buf != 0x00 && *buf != 0xff) {\n\t\tfor (b = &buf[1]; b < buf + len && *b == *buf; b++) {\n\t\t\trep++;\n\t\t}\n\t}\n\tconst char *buf_asm = \"invalid\";\n\tswitch (*buf) {\n\tcase '[':\n\t\tbuf_asm = \"while [ptr]\";\n\t\tbreak;\n\tcase ']':\n\t\tbuf_asm = \"loop\";\n\t\tbreak;\n\tcase '>':\n\t\tbuf_asm = (rep > 1)? \"add ptr\": \"inc ptr\";\n\t\tbreak;\n\tcase '<':\n\t\tbuf_asm = (rep > 1)? \"sub ptr\": \"dec ptr\";\n\t\tbreak;\n\tcase '+':\n\t\tbuf_asm = (rep > 1)? \"add [ptr]\": \"inc [ptr]\";\n\t\tbreak;\n\tcase '-':\n\t\tbuf_asm = (rep > 1)? \"sub [ptr]\": \"dec [ptr]\";\n\t\tbreak;\n\tcase ',':\n\t\tbuf_asm = \"in [ptr]\";\n\t\tbreak;\n\tcase '.':\n\t\tbuf_asm = \"out [ptr]\";\n\t\tbreak;\n\tcase 0xff:\n\tcase 0x00:\n\t\tbuf_asm = \"trap\";\n\t\tbreak;\n\tdefault:\n\t\tbuf_asm = \"nop\";\n\t\tbreak;\n\t}\n\n\tchar buf_asm_local[256];\n\tif (rep > 1) {\n\t\t/* Note: snprintf's source and destination buffers may not overlap. */\n\t\tconst char *fmt = strchr (buf_asm, ' ')? \"%s, %d\": \"%s %d\";\n\t\tsnprintf (buf_asm_local, sizeof (buf_asm_local), fmt, buf_asm, rep);\n\t\tbuf_asm = buf_asm_local;\n\t}\n\top->mnemonic = strdup (buf_asm);\n\top->size = rep;\n\treturn rep;\n}\n\nstatic void _write_asm(ut8 *outbuf, size_t outbufsz, int value, int n) {\n\tmemset (outbuf, value, R_MIN (n, outbufsz));\n}\n\nstatic int assemble(const char *buf, ut8 **outbuf) {\n\tint n = 0;\n\tif (buf[0] && buf[1] == ' ') {\n\t\tbuf += 2;\n\t}\n\tconst char *arg = strchr (buf, ',');\n\tconst char *ref = strchr (buf, '[');\n\tif (arg) {\n\t\tn = atoi (arg + 1);\n\t} else {\n\t\tn = 1;\n\t}\n\n\tsize_t outbufsz = n;\n\t*outbuf = malloc (outbufsz);\n\tif (!(*outbuf)) {\n\t\treturn 0;\n\t}\n\n\tif (r_str_startswith (buf, \"trap\")) {\n\t\t_write_asm (*outbuf, outbufsz, 0xcc, n);\n\t} else if (r_str_startswith (buf, \"nop\")) {\n\t\t_write_asm (*outbuf, outbufsz, 0x90, n);\n\t} else if (r_str_startswith (buf, \"inc\")) {\n\t\tchar ch = ref? '+': '>';\n\t\tn = 1;\n\t\t_write_asm (*outbuf, outbufsz, ch, n);\n\t} else if (r_str_startswith (buf, \"dec\")) {\n\t\tchar ch = ref? '-': '<';\n\t\tn = 1;\n\t\t_write_asm (*outbuf, outbufsz, ch, n);\n\t} else if (r_str_startswith (buf, \"sub\")) {\n\t\tchar ch = ref? '-': '<';\n\t\t_write_asm (*outbuf, outbufsz, ch, n);\n\t} else if (r_str_startswith (buf, \"add\")) {\n\t\tchar ch = ref? '+': '>';\n\t\t_write_asm (*outbuf, outbufsz, ch, n);\n\t} else if (r_str_startswith (buf, \"while\")) {\n\t\tn = 1;\n\t\t_write_asm (*outbuf, outbufsz, '[', 1);\n\t} else if (r_str_startswith (buf, \"loop\")) {\n\t\tn = 1;\n\t\t_write_asm (*outbuf, outbufsz, ']', 1);\n\t} else if (r_str_startswith (buf, \"in\")) {\n\t\t_write_asm (*outbuf, outbufsz, ',', n);\n\t} else if (r_str_startswith (buf, \"out\")) {\n\t\t_write_asm (*outbuf, outbufsz, '.', n);\n\t} else {\n\t\tR_FREE (*outbuf);\n\t\tn = 0;\n\t}\n\treturn n;\n}\n\n#define BUFSIZE_INC 32\nstatic bool decode(RArchSession *as, RAnalOp *op, RArchDecodeMask mask) {\n\tint len = op->size;\n\tconst ut8 *_buf = op->bytes;\n\tconst ut64 addr = op->addr;\n\tif (len < 1) {\n\t\treturn false;\n\t}\n\n\tut8 *buf = (ut8*)_buf; // XXX\n\tut64 dst = 0LL;\n\tif (!op) {\n\t\treturn 1;\n\t}\n\tif (mask & R_ARCH_OP_MASK_DISASM) {\n\t\t(void) disassemble (op, buf, len);\n\t}\n\tr_strbuf_init (&op->esil);\n\top->size = 1;\n\top->id = getid (buf[0]);\n\tswitch (buf[0]) {\n\tcase '[':\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t// read ahead to find the ] bracket\n\t\top->jump = dst;\n\t\top->fail = addr + 1;\n\t\tRArch *a = as->arch;\n\t\tRIOReadAt read_at = NULL;\n\t\tRBin *bin = R_UNWRAP2 (a, binb.bin);\n\t\tif (bin && bin->iob.read_at) {\n\t\t\tRIOReadAt read_at = bin->iob.read_at;\n\t\t\tbuf = malloc (0xff);\n\t\t\tread_at (bin->iob.io, op->addr, buf, 0xff);\n\t\t}\n\t\tr_strbuf_set (&op->esil, \"1,pc,-,brk,=[4],4,brk,+=\");\n#if 1\n\t\t{\n\t\t\tconst ut8 *p = buf + 1;\n\t\t\tint lev = 0, i = 1;\n\t\t\tlen--;\n\t\t\twhile (i < len && *p) {\n\t\t\t\tif (*p == '[') {\n\t\t\t\t\tlev++;\n\t\t\t\t}\n\t\t\t\tif (*p == ']') {\n\t\t\t\t\tlev--;\n\t\t\t\t\tif (lev == -1) {\n\t\t\t\t\t\tdst = addr + (size_t)(p - buf) + 1;\n\t\t\t\t\t\top->jump = dst;\n\t\t\t\t\t\tr_strbuf_set (&op->esil, \"1,pc,-,brk,=[4],4,brk,+=,\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*p == 0x00 || *p == 0xff) {\n\t\t\t\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (read_at && i == len - 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t\t// XXX unnecessary just break\n\t\t\t\t\tint new_buf_len = len + 1 + BUFSIZE_INC;\n\t\t\t\t\tut8 *new_buf = calloc (new_buf_len, 1);\n\t\t\t\t\tif (new_buf) {\n\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t\tmemcpy (new_buf, op->bytes, new_buf_len);\n\t\t\t\t\t\tbuf = new_buf;\n\t\t\t\t\t\tread_at (bin->iob.io, op->addr + i, buf + i, 0xff);\n\t\t\t\t\t\tp = buf + i;\n\t\t\t\t\t\tlen += BUFSIZE_INC;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\nbeach:\n\t\tfree (buf);\n#endif\n\t\tbreak;\n\tcase ']':\n\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\tr_strbuf_set (&op->esil, \"4,brk,-=,ptr,[1],?{,brk,[4],pc,=,}\");\n\t\tbreak;\n\tcase '>':\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\top->size = countChar (buf, len, '>');\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,+=\", op->size);\n\t\tbreak;\n\tcase '<':\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\top->size = countChar (buf, len, '<');\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,-=\", op->size);\n\t\tbreak;\n\tcase '+':\n\t\top->size = countChar (buf, len, '+');\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,+=[1]\", op->size);\n\t\tbreak;\n\tcase '-':\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\top->size = countChar (buf, len, '-');\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,-=[1]\", op->size);\n\t\tbreak;\n\tcase '.':\n\t\t// print element in stack to screen\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\tr_strbuf_set (&op->esil, \"ptr,[1],scr,=[1],1,scr,+=\");\n\t\tbreak;\n\tcase ',':\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\tr_strbuf_set (&op->esil, \"kbd,[1],ptr,=[1],1,kbd,+=\");\n\t\tbreak;\n\tcase 0x00:\n\tcase 0xff:\n\t\top->type = R_ANAL_OP_TYPE_TRAP;\n\t\tbreak;\n\tdefault:\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\tr_strbuf_set (&op->esil, \",\");\n\t\tbreak;\n\t}\n\treturn op->size;\n}\n\nstatic char *regs(RArchSession *as) {\n\tif (as->config->bits == 8) {\n\t\treturn strdup (\n\t\t\"=PC\tpc\\n\"\n\t\t\"=BP\tbrk\\n\"\n\t\t\"=SP\tptr\\n\"\n\t\t\"=A0\ttmp\\n\"\n\t\t\"=A1\ttmp\\n\"\n\t\t\"=A2\ttmp\\n\"\n\t\t\"=A3\ttmp\\n\"\n\t\t\"gpr\tptr\t.8\t0\t0\\n\" // data pointer\n\t\t\"gpr\tpc\t.8\t4\t0\\n\" // program counter\n\t\t\"gpr\tbrk\t.8\t8\t0\\n\" // brackets\n\t\t\"gpr\tscr\t.32\t12\t0\\n\" // screen\n\t\t\"gpr\tkbd\t.32\t16\t0\\n\" // keyboard\n\t\t\"gpr\ttmp\t.32\t20\t0\\n\" // keyboard\n\t\t);\n\t}\n\treturn strdup (\n\t\t\"=PC\tpc\\n\"\n\t\t\"=BP\tbrk\\n\"\n\t\t\"=SP\tptr\\n\"\n\t\t\"=A0\tptr\\n\"\n\t\t\"=A1\tptr\\n\"\n\t\t\"=A2\tptr\\n\"\n\t\t\"=A3\tptr\\n\"\n\t\t\"gpr\tptr\t.32\t0\t0\\n\" // data pointer\n\t\t\"gpr\tpc\t.32\t4\t0\\n\" // program counter\n\t\t\"gpr\tbrk\t.32\t8\t0\\n\" // brackets\n\t\t\"gpr\tscr\t.32\t12\t0\\n\" // screen\n\t\t\"gpr\tkbd\t.32\t16\t0\\n\" // keyboard\n\t);\n}\n\nstatic bool encode(RArchSession *as, RAnalOp *op, RArchEncodeMask mask) {\n\tut8 *outbuf = NULL;\n\tint size = assemble (op->mnemonic, &outbuf);\n\tfree (op->bytes);\n\top->bytes = outbuf;\n\top->size = size;\n\treturn size > 0;\n}\n\nstatic int archinfo(RArchSession *as, ut32 q) {\n\tswitch (q) {\n\tcase R_ANAL_ARCHINFO_MAX_OP_SIZE:\n\t\treturn 0xff;\n\t\t// return 32;\n\t}\n\treturn 1;\n}\n\nconst RArchPlugin r_arch_plugin_bf = {\n\t.meta = {\n\t\t.name = \"bf\",\n\t\t.desc = \"brainfuck code analysis plugin\",\n\t\t.license = \"LGPL3\",\n\t},\n\t.arch = \"bf\",\n\t.bits = R_SYS_BITS_PACK (32),\n\t.endian = R_SYS_ENDIAN_NONE,\n\t.decode = &decode,\n\t.encode = &encode,\n\t.regs = regs,\n\t.info = &archinfo\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ARCH,\n\t.data = &r_arch_plugin_bf,\n\t.version = R2_VERSION\n};\n#endif\n", "/* radare - LGPL - Copyright 2009-2023 - pancake, maijin */\n\n#include <r_core.h>\n\n#define MAX_SCAN_SIZE 0x7ffffff\n\nR_VEC_TYPE(RVecUT64, ut64);\n\nstatic RCoreHelpMessage help_msg_af_plus = {\n\t\"Usage:\", \"af+\", \" [addr] ([name] ([type] [diff]))\",\n\t\"af+\", \"$$\", \"add a raw function element. See afb+ to add basic blocks to it\",\n\t\"af+\", \"$$ main\", \"add new function in current offset with 'main' as name\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aex = {\n\t\"Usage:\", \"aex\", \"[a] [9090]\",\n\t\"aex\", \" 90\", \"decode the given hexpairs and execute them\",\n\t\"aexa\", \" mov rax, 33\", \"assemble instruction and execute it\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_a = {\n\t\"Usage:\", \"a\", \"[abdefFghoprxstc] [...]\",\n\t\"a\", \"\", \"alias for aai - analysis information\",\n\t\"a:\", \"[cmd]\", \"run a command implemented by an analysis plugin (like : for io)\",\n\t\"a*\", \"\", \"same as afl*;ah*;ax*\",\n\t\"aa\", \"[?]\", \"analyze all (fcns + bbs) (aa0 to avoid sub renaming)\",\n\t\"a8\", \" [hexpairs]\", \"analyze bytes\",\n\t\"ab\", \"[?]\", \"analyze basic block\",\n\t\"ac\", \"[?]\", \"manage classes\",\n\t\"aC\", \"[?]\", \"analyze function call\",\n\t\"ad\", \"[?]\", \"analyze data trampoline (wip) (see 'aod' to describe mnemonics)\", // XXX rename to at?\n\t\"ad\", \" [from] [to]\", \"analyze data pointers to (from-to)\",\n\t\"ae\", \"[?] [expr]\", \"analyze opcode eval expression (see ao)\",\n\t\"af\", \"[?]\", \"analyze functions\",\n\t\"aF\", \"\", \"same as above, but using anal.depth=1\",\n\t\"ag\", \"[?] [options]\", \"draw graphs in various formats\",\n\t\"ah\", \"[?]\", \"analysis hints (force opcode size, ...)\",\n\t\"ai\", \" [addr]\", \"address information (show perms, stack, heap, ...)\",\n\t\"aj\", \"\", \"same as a* but in json (aflj)\",\n\t\"aL\", \"[jq]\", \"list all asm/anal plugins (See `e asm.arch=?` and `La[jq]`)\",\n\t\"an\", \"[?] [name]\", \"show/rename/create whatever var/flag/function used in current instruction\",\n\t\"ao\", \"[?] [len]\", \"analyze Opcodes (or emulate it)\",\n\t\"aO\", \"[?] [len]\", \"analyze N instructions in M bytes\",\n\t\"ap\", \"\", \"find prelude for current offset\",\n\t\"ar\", \"[?]\", \"like 'dr' but for the esil vm. (registers)\",\n\t\"as\", \"[?] [num]\", \"analyze syscall using dbg.reg\",\n\t\"av\", \"[?] [.]\", \"show vtables\",\n\t\"avg\", \"[?] [.]\", \"manage global variables\",\n\t\"ax\", \"[?]\", \"manage refs/xrefs (see also afx?)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afna = {\n\t\"Usage:\", \"afna\", \" # construct a function name and rename the function for the current offset.\",\n\t\"\", \"\", \"Based on flags or methods calls found inside that function.\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afu = {\n\t\"Usage:\", \"afu\", \"[addr]   # resize and analyze function from current address until addr.\",\n\t\"afu\", \" 0x100004093\", \"resize and analyze function from current address until 0x100004093\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aae = {\n\t\"Usage:\", \"aae\", \"[pf] ([addr]) # analyze all kind of stuff using esil\",\n\t\"aaep\", \"\", \"same as aepa@@@i - define anal pins by import flag names\",\n\t\"aaep\", \"a\", \"run 'aep ret0@@@i' and then 'aaep' - all unknown imports are faked to return 0\",\n\t\"aaef\", \"\", \"emulate all functions using esil to find out computed references (same as aef@@@F)\",\n\t\"aae\", \" [size] ([addr])\", \"same as aepa@@@i - define anal pins by import flag names\",\n\t\"aae\", \"\", \"honor anal.{in,from,to} and emulate all executable regions\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aav = {\n\t\"Usage:\", \"aav\", \"[sat] # find values referencing a specific section or map\",\n\t\"aav\", \"\", \"find absolute reference values\",\n\t\"aavr\", \"\", \"find relative reference values (address + 4 byte signed int)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aan = {\n\t\"Usage:\", \"aan\", \"[rg]   # automatically name functions.\",\n\t\"aan\", \"\", \"autoname all functions\",\n\t\"aang\", \"\", \"autoname all golang functions\",\n\t\"aanr\", \"\", \"auto-noreturn propagation\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afm = {\n\t\"Usage:\", \"afm\", \"[name]   # merge two functions.\",\n\t\"afm\", \" sym.func.100003d74\", \"merge current function into 0x100003d74\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aF = {\n\t\"Usage:\", \"aF\", \" # analyze a function, but using anal.depth=1\",\n\t\"aF\", \"\", \"check af? for more options and information.\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_an = {\n\t\"Usage:\", \"an\", \" # analyze name for the current address\",\n\t\"an\", \"\", \"show flag/function/symbol name\",\n\t\"an*\", \"\", \"same as above but in r2 commands\",\n\t\"anj\", \"\", \"same as above but in json\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_a8 = {\n\t\"Usage:\", \"a8\", \"[hexpairs]   # analyze the byte array given as input\",\n\t\"a8 \", \"5548\", \"analyzes 5548 byte array\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ap = {\n\t\"Usage:\", \"ap[?]\", \" # analyze prelude in current offset\",\n\t\"ap\", \"\", \"check if current offset contains a function prelude\",\n\t\"apl\", \"\", \"list available function preludes defined by the arch plugin\",\n\t// \"ap+\", \"bytes:mask:align\", \"add a new function prelude\",\n\t\"apt\", \"\", \"analysis process-thread (like dpt for esil), list threads\",\n\t\"apt \", \"[id]\", \"select a thread (change register profile and TLS map\",\n\t\"apt+\", \"[map]\", \"create a thread with given TLS mapid and prints the new thread id\",\n\t\"apt-\", \"[id]\", \"delete a thread by id\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_avg = {\n\t\"Usage:\", \"avg\", \" # analyze variable global\",\n\t\"avg\", \"\", \"use ESIL emulation to find out arguments of a call (uses 'abte')\",\n\t\"avg\", \" [type] [name]\", \"add global\",\n\t\"avg-\", \"\", \"delete global\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aC = {\n\t\"Usage:\", \"aC[fej] [addr-of-call]\", \" # analyze call args\",\n\t\"aCe\", \"\", \"use ESIL emulation to find out arguments of a call (uses 'abte')\",\n\t\"aCf\", \"\", \"same as .aCe* $$ @@=`pdr~call`\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aaf = {\n\t\"Usage:\", \"aaf[efrt?]\", \" # analyse all functionsee also 'af' and 'afna'\",\n\t\"aaf\", \"\", \"same as afr@@c:isq\",\n\t\"aafe\", \" \", \"same as aef@@F\",\n\t\"aaff\", \"\", \"set a flag for every function\",\n\t\"aafr\", \" [len]\", \"consecutive function analysis (e anal.hasnext=1;afr@@c:isq)\",\n\t\"aaft\", \"\", \"recursive type matching across all functions\",\n\t\"aafs\", \"\", \"single basic block function analysis\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aaa = {\n\t\"Usage:\", \"aa[a[a[a]]]\", \" # automatically analyze the whole program\",\n\t\"a\", \" \", \"show code analysis statistics\",\n\t\"aa\", \" \", \"alias for 'af@@ sym.*;af@entry0;afva'\",\n\t\"aaa\", \"\", \"perform deeper analysis, most common use\",\n\t\"aaaa\", \"\", \"same as aaa but adds a bunch of experimental iterations\",\n\t\"aaaaa\", \"\", \"refine the analysis to find more functions after aaaa\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aa = {\n\t\"Usage:\", \"aa[0*?]\", \" # see also 'af' and 'afna'\",\n\t\"aa\", \" \", \"alias for 'af@@ sym.*;af@entry0;afva'\", //;.afna @@ fcn.*'\",\n\t\"aaa\", \"[?]\", \"autoname functions after aa (see afna)\",\n\t\"aab\", \"\", \"abb across bin.sections.rx\",\n\t\"aac\", \" [len]\", \"analyze function calls (af @@ `pi len~call[1]`)\",\n\t\"aac*\", \" [len]\", \"flag function calls without performing a complete analysis\",\n\t\"aaci\", \"\", \"flag import xrefs only\",\n\t\"aad\", \" [len]\", \"analyze data references to code\",\n\t\"aae\", \"[?] [len] ([addr])\", \"analyze references with ESIL (optionally to address)\",\n\t\"aaef\", \"\", \"analyze references with ESIL in all functions\",\n\t\"aaf\", \"[?][efrt] \", \"analyze all functions relationships with flags, type matching and consecutive\",\n\t\"aaF\", \" [sym*]\", \"set anal.in=block for all the spaces between flags matching glob\",\n\t\"aaFa\", \" [sym*]\", \"same as aaF but uses af/a2f instead of af+/afb+ (slower but more accurate)\",\n\t\"aai\", \"[j]\", \"show info of all analysis parameters\",\n\t\"aaj\", \" \", \"analyze all jumps\",\n\t\"aan\", \"[?][fgr]\", \"autoname functions (aang = golang, aanr = noreturn propagation, aanf = afna@@F)\",\n\t\"aao\", \"\", \"analyze all objc references\",\n\t\"aap\", \"\", \"find and analyze function preludes\",\n\t\"aar\", \"[?] [len]\", \"analyze len bytes of instructions for references\",\n\t\"aas\", \" [len]\", \"analyze symbols (af @@= `isq~[0]`)\",\n\t\"aaS\", \"\", \"analyze all flags starting with sym. (af @@ sym.*)\",\n\t\"aat\", \" [fcn]\", \"analyze all/given function to convert immediate to linked structure offsets (see tl?)\",\n\t\"aaT\", \" [len]\", \"analyze code after trap-sleds\",\n\t\"aau\", \" [len]\", \"list mem areas (larger than len bytes) not covered by functions\",\n\t\"aav\", \"[?] [sat]\", \"find values referencing a specific section or map\",\n\t\"aaw\", \"\", \"analyze all meta words (Cd) and add r. named flags for referenced pointers\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afls = {\n\t\"Usage:\", \"afls\", \"[afls] # sort function list\",\n\t\"afls\", \"\", \"same as aflsa\",\n\t\"aflsa\", \"\", \"sort by address (same as afls)\",\n\t\"aflss\", \"\", \"sort by size\",\n\t\"aflsn\", \"\", \"sort by name\",\n\t\"aflsb\", \"\", \"sort by number of basic blocks\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aflx = {\n\t\"Usage:\", \"aflx\", \"[jv*] # list function xrefs\",\n\t\"aflx\", \"\", \"list function xrefs (who references or calls the current function)\",\n\t\"aflxj\", \"\", \"list function xrefs in JSON format\",\n\t\"aflxv\", \"\", \"list function xrefs with names\",\n\t\"aflx*\", \"\", \"list function xrefs in radare commands format\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ai = {\n\t\"Usage:\", \"ai\", \"[j*] [sz] # analysis/address information/imports\",\n\t\"ai\", \" @addr\", \"show address information\",\n\t\"aia\", \"\", \"show architecture specific information instruction size and alignment details\",\n\t\"aii\", \" [namespace]\", \"global import (like afii, but global)\",\n\t\"aii\", \"-\", \"delete all global imports\",\n\t\"aij\", \" @addr\", \"show address information in JSON format\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aar = {\n\t\"Usage:\", \"aar\", \"[j*] [sz] # search and analyze xrefs\",\n\t\"aar\", \"\", \"analyze xrefs in current section \",\n\t\"aar\", \" [sz]\", \"analyze xrefs starting in current offset until sz bytes are consumed\",\n\t\"aarr\", \"\", \"analyze all function reference graph to find more functions (EXPERIMENTAL)\",\n\t\"aar*\", \" [sz]\", \"list found xrefs in radare commands format\",\n\t\"aarj\", \" [sz]\", \"list found xrefs in JSON format\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ab = {\n\t\"Usage:\", \"ab\", \"# analyze basic block\",\n\t\"ab\", \" [addr]\", \"show basic block information at given address\",\n\t\"ab-\", \"[addr]\", \"delete basic block at given address\",\n\t\"ab.\", \"\", \"same as: ab $$\",\n\t\"aba\", \" [addr]\", \"analyze esil accesses in basic block (see aea?)\",\n\t\"abb\", \" [length]\", \"analyze N bytes and extract basic blocks\",\n\t\"abc\", \"[-] [color]\", \"change color of the current basic block (same as afbc, abc- to unset)\",\n\t\"abe\", \" [addr]\", \"emulate basic block (alias for aeb)\",\n\t\"abf\", \" [addr]\", \"address of incoming (from) basic blocks\",\n\t\"abi\", \"\", \"same as ab. or ab\",\n\t\"abj\", \" [addr]\", \"display basic block information in JSON\",\n\t\"abl\", \"[?] [.-cqj]\", \"list all basic blocks\",\n\t\"abo\", \"\", \"list opcode offsets of current basic block\",\n\t\"abp\", \"[?] [addr] [num]\", \"follow basic blocks paths from current offset to addr\",\n\t\"abt\", \"[tag] ([color])\", \"trace tags are bitfields, 0 means nontraced, withuot arguments show current value\",\n\t\"abx\", \" [hexpair-bytes]\", \"analyze N bytes\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_abl = {\n\t\"Usage:\", \"abl\", \"analyzed basicblocks listing\",\n\t\"abl\", \"\", \"list all program-wide basic blocks analyzed\",\n\t\"abl,\", \" [table-query]\", \"render the list using a table\",\n\t\"ablc\", \"\", \"count how many basic blocks are registered\",\n\t\"ablj\", \"\", \"in json format\",\n\t\"ablq\", \"\", \"in quiet format\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_abp = {\n\t\"Usage:\", \"abp\", \"[addr] [num] # find num paths from current offset to addr\",\n\t\"abp\", \" [addr] [num]\", \"find num paths from current offset to addr\",\n\t\"abpe\", \" [addr]\", \"emulate from beginning of function to the given address\",\n\t\"abpj\", \" [addr] [num]\", \"display paths in JSON\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ac = {\n\t\"Usage:\", \"ac\", \"anal classes commands\",\n\t\"acl\", \"[j*]\", \"list all classes\",\n\t\"acll\", \"[j] (class_name)\", \"list all or single class detailed\",\n\t\"ac\", \" [class name]\", \"add class\",\n\t\"ac-\", \" [class name]\", \"delete class\",\n\t\"acn\", \" [class name] [new class name]\", \"rename class\",\n\t\"acv\", \" [class name] [addr] ([offset]) ([size])\", \"add vtable address to class\",\n\t\"acvf\", \" [offset] ([class name])\", \"lookup function address on vtable offset\",\n\t\"acv-\", \" [class name] [vtable id]\", \"delete vtable by id (from acv [class name])\",\n\t\"acb\", \" [class name]\", \"list bases of class\",\n\t\"acb\", \" [class name] [base class name] ([offset])\", \"add base class\",\n\t\"acb-\", \" [class name] [base class id]\", \"delete base by id (from acb [class name])\",\n\t\"acm\", \" [class name] [method name] [offset] ([vtable offset])\", \"add/edit method\",\n\t\"acm-\", \" [class name] [method name]\", \"delete method\",\n\t\"acmn\", \" [class name] [method name] [new name]\", \"rename method\",\n\t\"acg\", \"\", \"print inheritance ascii graph\",\n\t\"ac?\", \"\", \"show this help\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_acolon = {\n\t\"Usage:\", \"a:\", \"[plugin-command]\",\n\t\"a:\", \"\", \"list the analysis plugins\",\n\t\"a:\", \"a2f\", \"run the command associated with the 'a2f' analysis plugin\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ad = {\n\t\"Usage:\", \"ad\", \"[kt] [...]\",\n\t\"ad\", \" [N] [D]\", \"analyze N data words at D depth\",\n\t\"ad4\", \" [N] [D]\", \"analyze N data words at D depth (asm.bits=32)\",\n\t\"ad8\", \" [N] [D]\", \"analyze N data words at D depth (asm.bits=64)\",\n\t\"adf\", \"\", \"analyze data in function (use like .adf @@=`afl~[0]`\",\n\t\"adfg\", \"\", \"analyze data in function gaps\",\n\t\"adt\", \"\", \"analyze data trampolines (wip)\",\n\t\"adk\", \"\", \"analyze data kind (code, text, data, invalid, ...)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aes = {\n\t\"Usage:\", \"aes[pbosu]\", \"esil stepping utilities\",\n\t\"aesp\", \" [X] [N]\", \"evaluate N instr from offset X\",\n\t\"aesb\", \"\", \"step back\",\n\t\"aeso\", \" \", \"step over\",\n\t\"aesou\", \" [addr]\", \"step over until given address\",\n\t\"aess\", \" \", \"step skip (in case of CALL, just skip, instead of step into)\",\n\t\"aesu\", \" [addr]\", \"step until given address\",\n\t\"aesue\", \" [esil]\", \"step until esil expression match\",\n\t\"aesuo\", \" [optype]\", \"step until given opcode type\",\n\t\"aesB\", \" [addr] [N] @ [from-addr]\", \"step over every N instructions\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aei = {\n\t\"Usage:\", \"aei\", \"[smp] [...]\",\n\t\"aei\", \"\", \"initialize ESIL VM state (aei- to deinitialize)\",\n\t\"aeis\", \" argc [argv] [envp]\", \"initialize entrypoint stack environment\",\n\t\"aeim\", \" [addr] [size] [name]\", \"initialize ESIL VM stack (aeim- remove)\",\n\t\"aeip\", \"\", \"initialize ESIL program counter to curseek\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ae = {\n\t\"Usage:\", \"ae[idesr?] [arg]\", \"ESIL code emulation\",\n\t\"ae\", \" [expr]\", \"evaluate ESIL expression\",\n\t\"ae?\", \"\", \"show this help\",\n\t\"ae??\", \"\", \"show ESIL help\",\n\t\"aea\", \"[f] [count]\", \"analyse n esil instructions accesses (regs, mem..)\",\n\t\"aeA\", \"[f] [count]\", \"analyse n bytes for their esil accesses (regs, mem..)\",\n\t\"aeb\", \" ([addr])\", \"emulate block in current or given address\",\n\t\"aeC\", \"[arg0 arg1..] @ addr\", \"appcall in esil\",\n\t\"aec\", \"[?]\", \"continue until ^C\",\n\t\"aef\", \" [addr]\", \"emulate function\",\n\t\"aefa\", \" [addr]\", \"emulate function to find out args in given or current offset\",\n\t\"aeg\", \" [expr]\", \"esil data flow graph\",\n\t\"aegf\", \" [expr] [register]\", \"esil data flow graph filter\",\n\t\"aei\", \"[?]\", \"initialize ESIL VM state (aei- to deinitialize)\",\n\t\"aek\", \"[?] [query]\", \"perform sdb query on ESIL.info\",\n\t\"aeL\", \"[?][-] [name]\", \"list ESIL plugins\",\n\t\"aep\", \"[?] [addr]\", \"manage esil pin hooks (see 'e cmd.esil.pin')\",\n\t\"aepc\", \" [addr]\", \"change esil PC to this address\",\n\t\"aer\", \"[?] [..]\", \"handle ESIL registers like 'ar' or 'dr' does\",\n\t\"aes\", \"[?]\", \"perform emulated debugger step\",\n\t\"aet\", \"[?][s]\", \"esil trace listing and session management (requires aeim)\",\n\t\"aev\", \" [esil]\", \"visual esil debugger for the given expression or current instruction\",\n\t\"aex\", \" [hex]\", \"evaluate opcode expression\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_detail_ae = {\n\t\"Examples:\", \"ESIL\", \" examples and documentation\",\n\t\"=\", \"\", \"assign updating internal flags\",\n\t\":=\", \"\", \"assign without updating internal flags\",\n\t\"+=\", \"\", \"a+=b => b,a,+=\",\n\t\"/\", \"\", \"division\",\n\t\"*\", \"\", \"multiply\",\n\t\"*=\", \"\", \"multiply and assign a *= b\",\n\t\"L*\", \"\", \"long multiply\",\n\t\"+\", \"\", \"a=a+b => b,a,+,a,=\",\n\t\"++\", \"\", \"increment, 2,a,++ == 3 (see rsi,--=[1], ... )\",\n\t\"--\", \"\", \"decrement, 2,a,-- == 1\",\n\t\"*=\", \"\", \"a*=b => b,a,*=\",\n\t\"/=\", \"\", \"a/=b => b,a,/=\",\n\t\"%\", \"\", \"module\",\n\t\"%=\", \"\", \"a%=b => b,a,%=\",\n\t\"&=\", \"\", \"and ax, bx => bx,ax,&=\",\n\t\"^\", \"\", \"xor\",\n\t\"&\", \"\", \"and\",\n\t\"|\", \"\", \"or r0, r1, r2 => r2,r1,|,r0,=\",\n\t\"!=\", \"\", \"negate all bits\",\n\t\"^=\", \"\", \"xor ax, bx => bx,ax,^=\",\n\t\"\", \"[]\", \"mov eax,[eax] => eax,[],eax,=\",\n\t\"=\", \"[]\", \"mov [eax+3], 1 => 1,3,eax,+,=[]\",\n\t\"=\", \"[1]\", \"mov byte[eax],1 => 1,eax,=[1]\",\n\t\"=\", \"[8]\", \"mov [rax],1 => 1,rax,=[8]\",\n\t\"()\", \"\", \"execute an esil syscall\",\n\t\"[]\", \"\", \"peek from random position\",\n\t\"[N]\", \"\", \"peek word of N bytes from popped address\",\n\t\"[*]\", \"\", \"peek some from random position\",\n\t\"=\", \"[*]\", \"poke some at random position\",\n\t\"$\", \"\", \"int 0x80 => 0x80,$\",\n\t\"$$\", \"\", \"simulate a hardware trap\",\n\t\"==\", \"\", \"pops twice, compare and update esil flags\",\n\t\"<\", \"\", \"compare for smaller\",\n\t\"<=\", \"\", \"compare for smaller or equal\",\n\t\">\", \"\", \"compare for bigger\",\n\t\">=\", \"\", \"compare bigger for or equal\",\n\t\">>=\", \"\", \"shr ax, bx => bx,ax,>>=  # shift right\",\n\t\"<<=\", \"\", \"shl ax, bx => bx,ax,<<=  # shift left\",\n\t\">>>=\", \"\", \"ror ax, bx => bx,ax,>>>=  # rotate right\",\n\t\"<<<=\", \"\", \"rol ax, bx => bx,ax,<<<=  # rotate left\",\n\t\"?{\", \"\", \"if popped value != 0 run the block until }\",\n\t\"}{\", \"\", \"else block\",\n\t\"}\", \"\", \"end of conditional block\",\n\t\"NAN\", \"\", \"checks if result in stack is not a number\",\n\t\"I2D\", \"\", \"signed to double\",\n\t// \"S2D\", \"\", \"signed to double\",\n\t\"U2D\", \"\", \"unsigned to double\",\n\t\"D2I\", \"\", \"double to signed\",\n\t\"D2U\", \"\", \"double to unsigned\",\n\t\"F==\", \"\", \"float comparison\",\n\t\"CEIL\", \"\", \"float ceil\",\n\t\"FLOOR\", \"\", \"float floor\",\n\t\"ROUND\", \"\", \"float round\",\n\t\"SQRT\", \"\", \"float square root\",\n\t\"POP\", \"\", \"drops last element in the esil stack\",\n\t\"DUP\", \"\", \"duplicate last value in stack\",\n\t\"NUM\", \"\", \"evaluate last item in stack to number\",\n\t\"SWAP\", \"\", \"swap last two values in stack\",\n\t\"TRAP\", \"\", \"stop execution\",\n\t\"BITS\", \"\", \"16,BITS  # change bits, useful for arm/thumb\",\n\t\"TODO\", \"\", \"the instruction is not yet esilized\",\n\t\"STACK\", \"\", \"show contents of stack\",\n\t\"CLEAR\", \"\", \"clears the esil stack\",\n\t\"REPEAT\", \"\", \"repeat n times\",\n\t\"BREAK\", \"\", \"terminates the string parsing\",\n\t\"SETJT\", \"\", \"set jump target\",\n\t\"SETJTS\", \"\", \"set jump target set\",\n\t\"SETD\", \"\", \"set delay slot\",\n\t\"GOTO\", \"\", \"jump to the Nth word popped from the stack\",\n\t\"$\", \"\", \"esil interrupt\",\n\t\"$z\", \"\", \"internal flag: zero\",\n\t\"$c\", \"\", \"internal flag: carry\",\n\t\"$b\", \"\", \"internal flag: borrow\",\n\t\"$p\", \"\", \"internal flag: parity\",\n\t\"$s\", \"\", \"internal flag: sign\",\n\t\"$o\", \"\", \"internal flag: overflow\",\n\t\"$ds\", \"\", \"internal flag: delay-slot\",\n\t\"$jt\", \"\", \"internal flag: jump-target\",\n\t\"$js\", \"\", \"internal flag: jump-target-set\",\n\t\"$$\", \"\", \"internal flag: pc address\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aea = {\n\t\"Examples:\", \"aea\", \" show regs and memory accesses used in a range\",\n\t\"aea\", \"  [ops]\", \"show regs/memory accesses used in N instructions\",\n\t\"aea*\", \" [ops]\", \"create mem.* flags for memory accesses\",\n\t\"aeab\", \"\", \"show regs used in current basic block\",\n\t\"aeaf\", \"\", \"show regs used in current function\",\n\t\"aear\", \" [ops]\", \"show regs read in N instructions\",\n\t\"aeaw\", \" [ops]\", \"show regs written in N instructions\",\n\t\"aean\", \" [ops]\", \"show regs not written in N instructions\",\n\t\"aeaj\", \" [ops]\", \"show aea output in JSON format\",\n\t\"aeA\", \"  [len]\", \"show regs used in N bytes (subcommands are the same)\",\n\t\"Legend:\", \"\", \"\",\n\t\"I\", \"\", \"input registers (read before being set)\",\n\t\"A\", \"\", \"all regs accessed\",\n\t\"R\", \"\", \"register values read\",\n\t\"W\", \"\", \"registers written\",\n\t\"N\", \"\", \"read but never written\",\n\t\"V\", \"\", \"values\",\n\t\"@R\", \"\", \"memreads\",\n\t\"@W\", \"\", \"memwrites\",\n\t\"NOTE:\", \"\", \"mem{reads,writes} with PIC only fetch the offset\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aec = {\n\t\"Examples:\", \"aec\", \" continue until ^c\",\n\t\"aec\", \"\", \"continue until exception\",\n\t\"aecs\", \"\", \"continue until syscall\",\n\t\"aecc\", \"\", \"continue until call\",\n\t\"aecu\", \"[addr]\", \"continue until address\",\n\t\"aecue\", \"[addr]\", \"continue until esil expression\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aeC = {\n\t\"Examples:\", \"aeC\", \" arg0 arg1 ... @ calladdr\",\n\t\"aeC\", \" 1 2 @ sym._add\", \"Call sym._add(1,2)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aeg = {\n\t\"Usage:\", \"aeg[fniv]\", \" [...]\",\n\t\"aeg\", \"\", \"analyze current instruction as an esil graph\",\n\t\"aegb\", \"\", \"data flow graph for current basic block (aeg `pieq $Fi`)\",\n\t\"aegf\", \"\", \"analyze given expression and filter for register\",\n\t\"aegn\", \"\", \"create data flow graph for N instructions\",\n\t\"aegv\", \"\", \"analyse and launch the visual interactive mode\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aep = {\n\t\"Usage:\", \"aep[-*c] \", \" [...] manage esil pins, run r2 commands instead of esil\",\n\t\"aepc\", \" [addr]\", \"change program counter for esil\",\n\t\"aep*\", \"\", \"list pins in r2 commands\",\n\t\"aep-\", \"*\", \"remove all pins\",\n\t\"aep-\", \"[addr]\", \"remove pin\",\n\t\"aep-\", \"[name]\", \"remove pin command\",\n\t\"aepa\", \" ([addr])\", \"auto set pin in current or given address by flag name (see aaep)\",\n\t\"aep\", \" [name] @ [addr]\", \"set pin\",\n\t\"aep \", \"memcpy=wf `dr?A1` `dr?A2` @r:A0\", \"override esil.cmd.pin for this pin name\",\n\t\"aep\", \"\", \"list pins\",\n\t\"aep.\", \"\", \"show pin name in current address if any\",\n\t\"aepk\", \" [query]\", \"kuery the sdb of pins\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aek = {\n\t\"Usage:\", \"aek \", \" [...]\",\n\t\"aek\", \"\", \"dump the esil.stats database contents\",\n\t\"aek \", \"sdb.query\", \"evaluate sdb query on esil.stats db\",\n\t\"aek-\", \"\", \"clear the esil.stats sdb instance\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aets = {\n\t\"Usage:\", \"aets \", \" [...]\",\n\t\"aets+\", \"\", \"start ESIL trace session\",\n\t\"aets-\", \"\", \"stop ESIL trace session\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_af = {\n\t\"Usage:\", \"af\", \"\",\n\t\"af\", \" ([name]) ([addr])\", \"analyze functions (start at addr or $$)\",\n\t\"af+\", \" addr name [type] [diff]\", \"hand craft a function (requires afb+)\",\n\t\"af-\", \" [addr]\", \"clean all function analysis data (or function at addr)\",\n\t\"afa\", \"\", \"analyze function arguments in a call (afal honors dbg.funcarg)\",\n\t\"afB\", \" 16\", \"set current function as thumb (change asm.bits)\",\n\t\"afb\", \"[?] [addr]\", \"List basic blocks of given function\",\n\t\"afb+\", \" fcnA bbA sz [j] [f] ([t]( [d]))\", \"add bb to function @ fcnaddr\",\n\t\"afbF\", \"([0|1])\", \"Toggle the basic-block 'folded' attribute\",\n\t\"afc\", \"[?] type @[addr]\", \"set calling convention for function\",\n\t\"afC[lc]\", \" ([addr])@[addr]\", \"calculate the Cycles (afC) or Cyclomatic Complexity (afCc)\",\n\t\"afd\", \"[addr]\",\"show function + delta for given offset\",\n\t\"afF\", \"[1|0|]\", \"fold/unfold/toggle\",\n\t\"afi\", \" [addr|fcn.name]\", \"show function(s) information (verbose afl)\",\n\t\"afj\", \" [tableaddr] [elem_sz] [count] [seg]\", \"analyze function jumptable (adding seg to each elem)\",\n\t\"afl\", \"[?] [ls*] [fcn name]\", \"list functions (addr, size, bbs, name) (see afll)\",\n\t\"afm\", \" name\", \"merge two functions\",\n\t\"afM\", \" name\", \"print functions map\",\n\t\"afn\", \"[?] name [addr]\", \"rename name for function at address (change flag too)\",\n\t\"afna\", \"\", \"suggest automatic name for current offset\",\n\t\"afo\", \"[?j] [fcn.name]\", \"show address for the function name or current offset\",\n\t\"afr\", \" ([name]) ([addr])\", \"analyze functions recursively\",\n\t\"afs\", \"[!] ([fcnsign])\", \"get/set function signature at current address (afs! uses cfg.editor)\",\n\t\"afS\", \"[stack_size]\", \"set stack frame size for function at current address\",\n\t\"afsr\", \" [function_name] [new_type]\", \"change type for given function\",\n\t\"aft\", \"[?]\", \"type matching, type propagation\",\n\t\"afu\", \" addr\", \"resize and analyze function from current address until addr\",\n\t\"afv[absrx]\", \"?\", \"manipulate args, registers and variables in function\",\n\t\"afx\", \"[m]\", \"list function references\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afb = {\n\t\"Usage:\", \"afb\", \" list basic blocks of given function\",\n\t\".afbr-\", \"\", \"set breakpoint on every return address of the function\",\n\t\".afbr-*\", \"\", \"remove breakpoint on every return address of the function\",\n\t\"afb\", \" [addr]\", \"list basic blocks of function\",\n\t\"afb.\", \" [addr]\", \"show info of current basic block\",\n\t\"afb=\", \"\", \"display ascii-art bars for basic block regions\",\n\t\"afb+\", \" fcn_at bbat bbsz [jump] [fail] ([diff])\", \"add basic block by hand\",\n\t\"afbc\", \"[-] [color] ([addr])\", \"colorize basic block (same as 'abc', afbc- to unset)\",\n\t\"afbe\", \" bbfrom bbto\", \"add basic-block edge for switch-cases\",\n\t\"afbi\", \"[j]\", \"print current basic block information\",\n\t\"afbj\", \" [addr]\", \"show basic blocks information in json\",\n\t\"afbr\", \"\", \"show addresses of instructions which leave the function\",\n\t\"afbt\", \"\", \"show basic blocks of current function in a table\",\n\t\"afbo\", \"\", \"list addresses of each instruction for every basic block in function (see abo)\",\n\t\"afB\", \" [bits]\", \"define asm.bits for the given function\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afc = {\n\t\"Usage:\", \"afc[agl?]\", \"# see also tcc command to manage all calling conventions\",\n\t\"afc\", \" ccname\", \"manually set calling convention for current function\",\n\t\"afc\", \"\", \"show calling convention for the Current function (same as tcc)\",\n\t\"afcr\", \"[j]\", \"show register usage for the current function\",\n\t\"afcf\", \"[j] [name]\", \"prints return type function(arg1, arg2...), see afij\",\n\t\"afci\", \"\", \"information about the current calling convention\",\n\t\"afck\", \"\", \"list SDB details of call loaded calling conventions\",\n\t\"afcl\", \"\", \"list all available calling conventions\",\n\t\"afcll\", \"\", \"show all call conventions and its definition\",\n\t\"afco\", \" path\", \"open Calling Convention sdb profile from given path\",\n\t\"afcR\", \"\", \"register telescoping using the calling conventions order\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afC = {\n\t\"Usage:\", \"afC\", \" [addr]\",\n\t\"afC\", \"\", \"function cycles cost\",\n\t\"afCc\", \"\", \"cyclomatic complexity\",\n\t\"afCl\", \"\", \"loop count (backward jumps)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afi = {\n\t\"Usage:\", \"afi[jlp*]\", \" <addr>\",\n\t\"afi\", \"\", \"show information of the function\",\n\t\"afi\", \"[.j*]\", \"function, variables and arguments\",\n\t\"afii\", \"[-][import]\", \"show/add/delete imports used in function\",\n\t\"afil\", \"\", \"verbose function info\",\n\t\"afip\", \"\", \"show whether the function is pure or not\",\n\t\"afiq\", \"\", \"show quite few info about the function\",\n\t\"afis\", \"\", \"show function stats (opcode, meta)\",\n\t\"afix\", \"[.j]\", \"function xrefs information\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afis = {\n\t\"Usage:\", \"afis[ft]\", \"\",\n\t\"afis\", \"\", \"enumerate unique opcodes in function\",\n\t\"afisa\", \"[fo]\", \"enumerate all the meta of all the functions\",\n\t\"afisf\", \"\", \"enumerate unique opcode families in function\",\n\t\"afiso\", \"\", \"enumerate unique opcode types in function\",\n\t\"afist\", \" [query]\", \"list in table format\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afl = {\n\t\"Usage:\", \"afl\", \" List all functions\",\n\t\"afl\", \"\", \"list functions\",\n\t\"afl.\", \"\", \"display function in current offset (see afi.)\",\n\t\"afl+\", \"\", \"display sum all function sizes\",\n\t\"afl=\", \"\", \"display ascii-art bars with function ranges\",\n\t\"aflc\", \"\", \"count of functions\",\n\t\"aflj\", \"\", \"list functions in json\",\n\t\"aflt\", \" [query]\", \"list functions in table format\",\n\t\"afll\", \" [column]\", \"list functions in verbose mode (sorted by column name)\",\n\t\"afllj\", \"\", \"list functions in verbose mode (alias to aflj)\",\n\t\"aflm\", \"[?]\", \"list functions in makefile style (af@@=`aflm~0x`)\",\n\t\"aflq\", \"\", \"list functions in quiet mode\",\n\t\"aflqj\", \"\", \"list functions in json quiet mode\",\n\t\"afls\", \"[?asn]\", \"sort function list by address, size or name\",\n\t\"aflx\", \"[?*jv]\", \"list function xrefs (who references or calls the current function)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afll = {\n\t\"Usage:\", \"\", \" List functions in verbose mode\",\n\t\"\", \"\", \"\",\n\t\"Table fields:\", \"\", \"\",\n\t\"\", \"\", \"\",\n\t\"address\", \"\", \"start address\",\n\t\"size\", \"\", \"function size (realsize)\",\n\t\"nbbs\", \"\", \"number of basic blocks\",\n\t\"edges\", \"\", \"number of edges between basic blocks\",\n\t\"cc\", \"\", \"cyclomatic complexity ( cc = edges - blocks + 2 * exit_blocks)\",\n\t\"cost\", \"\", \"cyclomatic cost\",\n\t\"min bound\", \"\", \"minimal address\",\n\t\"range\", \"\", \"function size\",\n\t\"max bound\", \"\", \"maximal address\",\n\t\"calls\", \"\", \"number of caller functions\",\n\t\"locals\", \"\", \"number of local variables\",\n\t\"args\", \"\", \"number of function arguments\",\n\t\"xref\", \"\", \"number of cross references\",\n\t\"frame\", \"\", \"function stack size\",\n\t\"name\", \"\", \"function name\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afn = {\n\t\"Usage:\", \"afn[sa]\", \" Analyze function names\",\n\t\"afn\", \" [name]\", \"rename the function\",\n\t\"afn\", \" base64:encodedname\", \"rename the function\",\n\t\"afn.\", \"\", \"same as afn without arguments. show the function name in current offset\",\n\t\"afna\", \"\", \"construct a function name for the current offset\",\n\t\"afns\", \"\", \"list all strings associated with the current function\",\n\t\"afnsj\", \"\", \"list all strings associated with the current function in JSON format\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afs = {\n\t\"Usage:\", \"afs[r]\", \" Analyze function signatures\",\n\t\"afs\", \"[!] ([fcnsign])\", \"get/set function signature at current address (afs! uses cfg.editor)\",\n\t\"afs*\", \" ([signame])\", \"get function signature in flags\",\n\t\"afsj\", \" ([signame])\", \"get function signature in JSON\",\n\t\"afsr\", \" [function_name] [new_type]\", \"change type for given function\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aft = {\n\t\"Usage:\", \"aft\", \"\",\n\t\"aft\", \"\", \"type matching analysis for current function\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afv = {\n\t\"Usage:\", \"afv[rbs]\",\" Function variables manipulation\",\n\t\"afv*\", \"\", \"output r2 command to add args/locals to flagspace\",\n\t\"afv-\", \"([name])\", \"remove all or given var\",\n\t\"afv=\", \"\", \"list function variables and arguments with disasm refs\",\n\t\"afva\", \"\", \"analyze function arguments/locals\",\n\t\"afvb\", \"[?]\", \"manipulate bp based arguments/locals\",\n\t\"afvd\", \" name\", \"output r2 command for displaying the value of args/locals in the debugger\",\n\t\"afvf\", \"\", \"show BP relative stackframe variables\",\n\t\"afvn\", \" [new_name] ([old_name])\", \"rename argument/local\",\n\t\"afvr\", \"[?]\", \"manipulate register based arguments\",\n\t\"afvR\", \" [varname]\", \"list addresses where vars are accessed (READ)\",\n\t\"afvs\", \"[?]\", \"manipulate sp based arguments/locals\",\n\t\"afvt\", \" [name] [new_type]\", \"change type for given argument/local\",\n\t\"afvW\", \" [varname]\", \"list addresses where vars are accessed (WRITE)\",\n\t\"afvx\", \"\", \"show function variable xrefs (same as afvR+afvW)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aeim = {\n\t\"Usage:\", \"aeim\", \" [addr] [size] [name] - initialize the ESIL VM stack\",\n\t\"aeim\", \"\", \"initialize esil memory with default values from esil.stack.* evals\",\n\t\"aeim\", \" 0x10000\", \"same as aeim@e:esil.stack.addr=0x10000\",\n\t\"aeim\", \" 0x10000 2M mystack\", \"give a name to that new 2MB stack\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afvb = {\n\t\"Usage:\", \"afvb\", \" [idx] [name] ([type])\",\n\t\"afvb\", \"\", \"list base pointer based arguments, locals\",\n\t\"afvb*\", \"\", \"same as afvb but in r2 commands\",\n\t\"afvb\", \" [idx] [name] ([type])\", \"define base pointer based arguments, locals\",\n\t\"afvbj\", \"\", \"return list of base pointer based arguments, locals in JSON format\",\n\t\"afvb-\", \" [name]\", \"delete argument/locals at the given name\",\n\t\"afvbg\", \" [idx] [addr]\", \"define var get reference\",\n\t\"afvbs\", \" [idx] [addr]\", \"define var set reference\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afvr = {\n\t\"Usage:\", \"afvr\", \" [reg] [type] [name]\",\n\t\"afvr\", \"\", \"list register based arguments\",\n\t\"afvr*\", \"\", \"same as afvr but in r2 commands\",\n\t\"afvr\", \" [reg] [name] ([type])\", \"define register arguments\",\n\t\"afvrj\", \"\", \"return list of register arguments in JSON format\",\n\t\"afvr-\", \" [name]\", \"delete register arguments at the given index\",\n\t\"afvrg\", \" [reg] [addr]\", \"define argument get reference\",\n\t\"afvrs\", \" [reg] [addr]\", \"define argument set reference\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afvs = {\n\t\"Usage:\", \"afvs\", \" [idx] [type] [name]\",\n\t\"afvs\", \"\", \"list stack based arguments and locals\",\n\t\"afvs*\", \"\", \"same as afvs but in r2 commands\",\n\t\"afvs\", \" [idx] [name] [type]\", \"define stack based arguments,locals\",\n\t\"afvsj\", \"\", \"return list of stack based arguments and locals in JSON format\",\n\t\"afvs-\", \" [name]\", \"delete stack based argument or locals with the given name\",\n\t\"afvsg\", \" [idx] [addr]\", \"define var get reference\",\n\t\"afvss\", \" [idx] [addr]\", \"define var set reference\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ag = {\n\t\"Usage:\", \"ag<graphtype><format> [addr]\", \"\",\n\t\"Graph commands:\", \"\", \"\",\n\t\"aga\", \"[format]\", \"data references graph\",\n\t\"agA\", \"[format]\", \"global data references graph\",\n\t\"agc\", \"[format]\", \"function callgraph\",\n\t\"agC\", \"[format]\", \"global callgraph\",\n\t\"agd\", \"[format] [fcn addr]\", \"diff graph\",\n\t\"agf\", \"[format]\", \"basic blocks function graph\",\n\t\"agi\", \"[format]\", \"imports graph\",\n\t\"agr\", \"[format]\", \"references graph\",\n\t\"agR\", \"[format]\", \"global references graph\",\n\t\"agx\", \"[format]\", \"cross references graph\",\n\t\"agg\", \"[format]\", \"custom graph\",\n\t\"agt\", \"[format]\", \"tree map graph\",\n\t\"ag-\", \"\", \"clear the custom graph\",\n\t\"agn\", \"[?] title body\", \"add a node to the custom graph\",\n\t\"age\", \"[?] title1 title2\", \"add an edge to the custom graph\",\n\t\"\",\"\",\"\",\n\t\"Output formats:\", \"\", \"\",\n\t\"<blank>\", \"\", \"ascii art\",\n\t\"*\", \"\", \"r2 commands\",\n\t\"b\", \"\", \"braile art rendering (agfb)\",\n\t\"d\", \"\", \"graphviz dot\",\n\t\"g\", \"\", \"graph Modelling Language (gml)\",\n\t\"j\", \"\", \"json ('J' for formatted disassembly)\",\n\t\"k\", \"\", \"sdb key-value\",\n\t\"m\", \"\", \"mermaid\",\n\t\"t\", \"\", \"tiny ascii art\",\n\t\"v\", \"\", \"interactive ascii art\",\n\t\"w\", \" [path]\", \"write to path or display graph image (see graph.gv.format)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_age = {\n\t\"Usage:\", \"age [title1] [title2]\", \"\",\n\t\"Examples:\", \"\", \"\",\n\t\"age\", \" title1 title2\", \"add an edge from the node with \\\"title1\\\" as title to the one with title \\\"title2\\\"\",\n\t\"age\", \" \\\"title1 with spaces\\\" title2\", \"add an edge from node \\\"title1 with spaces\\\" to node \\\"title2\\\"\",\n\t\"age-\", \" title1 title2\", \"remove an edge from the node with \\\"title1\\\" as title to the one with title \\\"title2\\\"\",\n\t\"ageh\", \"\", \"list all the highlighted edges\",\n\t\"ageh\", \" nodeA nodeB\", \"highlight edge between nodeA and nodeB\",\n\t\"ageh-\", \" nodeA nodeB\", \"highlight edge between nodeA and nodeB\",\n\t\"age?\", \"\", \"show this help\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_agn = {\n\t\"Usage:\", \"agn [title] [body]\", \"\",\n\t\"Examples:\", \"\", \"\",\n\t\"agn\", \" title1 body1\", \"add a node with title \\\"title1\\\" and body \\\"body1\\\"\",\n\t\"agn\", \" \\\"title with space\\\" \\\"body with space\\\"\", \"add a node with spaces in the title and in the body\",\n\t\"agn\", \" title1 base64:Ym9keTE=\", \"add a node with the body specified as base64\",\n\t\"agn-\", \" title1\", \"remove a node with title \\\"title1\\\"\",\n\t\"agn?\", \"\", \"show this help\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ah = {\n\t\"Usage:\", \"ah[lba-]\", \"analysis Hints\",\n\t\"ah?\", \"\", \"show this help\",\n\t\"ah?\", \" offset\", \"show hint of given offset\",\n\t\"ah\", \"\", \"list hints in human-readable format\",\n\t\"ah.\", \"\", \"list hints in human-readable format from current offset\",\n\t\"ah-\", \"\", \"remove all hints\",\n\t\"ah-\", \" offset [size]\", \"remove hints at given offset\",\n\t\"ah*\", \" offset\", \"list hints in radare commands format\",\n\t\"aha\", \" ppc @ 0x42\", \"force arch ppc for all addrs >= 0x42 or until the next hint\",\n\t\"aha\", \" 0 @ 0x84\", \"disable the effect of arch hints for all addrs >= 0x84 or until the next hint\",\n\t\"ahb\", \"[-*] [8,16,32,64] @ 0x42\", \"get/set asm.bits for given address and beyond\",\n\t\"ahc\", \" 0x804804\", \"override call/jump address\",\n\t\"ahd\", \" foo a0,33\", \"replace opcode string\",\n\t\"ahe\", \" 3,eax,+=\", \"set vm analysis string\",\n\t\"ahf\", \" 0x804840\", \"override fallback address for call\",\n\t\"ahF\", \" 0x10\", \"set stackframe size at current offset\",\n\t\"ahh\", \" 0x804840\", \"highlight this address offset in disasm\",\n\t\"ahi\", \"[?] 10\", \"define numeric base for immediates (2, 8, 10, 10u, 16, i, p, S, s)\",\n\t\"ahj\", \"\", \"list hints in JSON\",\n\t\"aho\", \" call\", \"change opcode type (see aho?)\",\n\t\"ahp\", \" addr\", \"set pointer hint\",\n\t\"ahr\", \" val\", \"set hint for return value of a function\",\n\t\"ahs\", \" 4\", \"set opcode size=4\",\n\t\"ahS\", \" jz\", \"set asm.syntax=jz for this opcode\",\n\t\"aht\", \"[s][?] <type>\", \"mark immediate as a type offset (deprecated, moved to \\\"aho\\\")\",\n\t\"ahv\", \" val\", \"change opcode's val field (useful to set jmptbl sizes in jmp rax)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ahs = {\n\t\"Usage:\", \"ahs [size] [@ addr]\", \" Define opcode size hint\",\n\t\"ahs\", \" 16\", \"Hint the analysis to make the instruction 16 bytes in size\",\n\t\"ahs-\", \"\", \"Unset the instruction size hint in the current offset\",\n\t\"ahs-\", \"*\", \"Unset the instruction size hint in the current offset\",\n\t\"ahs*\", \"\", \"show all the instruction size hints as r2 commands\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aho = {\n\t\"Usage:\", \"aho [optype] [@ addr]\", \" Define opcode type hint\",\n\t\"aho\", \" nop\", \"change the opcode type in current address to be considered a NOP\",\n\t\"aho\", \"\", \"show the current opcode hint if any\",\n\t\"aho-\", \"$$\", \"delete hints in current offset\",\n\t\"aho*\", \"\", \"same as above but in r2 commands syntax\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ahb = {\n\t\"Usage:\", \"ahb [8|16|32|64] [@ addr]\", \" Define asm.bits hint at given address\",\n\t\"ahb\", \" 16\", \"set asm.bits=16 in the given address\",\n\t\"ahb\", \"\", \"get asm.bits used in given addr (current seek)\",\n\t\"ahb\", \"-$$\", \"delete all the hints in the given address\",\n\t\"ahb*\", \"\", \"show defined bits hints as r2 commands\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ahr = {\n\t\"Usage:\", \"ahr addr\", \" Set instruction as return type (similar to 'aho ret'?)\",\n\t\"ahr\", \" $$\", \"current instruction may be considered as the end of a function\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ahi = {\n\t\"Usage:\", \"ahi [2|8|10|10u|16|bodhipSs] [@ offset]\", \" Define numeric base\",\n\t\"ahi\", \" <base>\", \"set numeric base (2, 8, 10, 16)\",\n\t\"ahi\", \" 10|d\", \"set base to signed decimal (10), sign bit should depend on receiver size\",\n\t\"ahi\", \" 10u|du\", \"set base to unsigned decimal (11)\",\n\t\"ahi\", \" b\", \"set base to binary (2)\",\n\t\"ahi\", \" o\", \"set base to octal (8)\",\n\t\"ahi\", \" h\", \"set base to hexadecimal (16)\",\n\t\"ahi\", \" i\", \"set base to IP address (32)\",\n\t\"ahi\", \" p\", \"set base to htons(port) (3)\",\n\t\"ahi\", \" S\", \"set base to syscall (80)\",\n\t\"ahi\", \" s\", \"set base to string (1)\",\n\t\"ahi1\", \" 10\", \"set base of argument 1 to base 10 (same as ahi1 d)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aht = {\n\t\"Usage:\", \"aht[s] [addr|type]\", \"mark immediate as type offset (moved to aho)\",\n\t\"ahts\", \" <offset>\", \"list all matching structure offsets\",\n\t\"aht\", \" <struct.member>\", \"change immediate to structure offset\",\n\t\"aht?\", \"\", \"show this help\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aot = {\n\t\"Usage:\", \"aot[l]\", \"list opcode types\",\n\t\"aot\", \"\", \"show type of the current instruction\",\n\t\"aotl\", \"\", \"list all possible opcode types (See /atl)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aom = {\n\t\"Usage:\", \"aom[ljd] [arg]\", \"list opcode mnemonics\",\n\t\"aom\", \"\", \"show instruction mnemonic\",\n\t\"aom.\", \"\", \"show instruction mnemonic in current address\",\n\t\"aoml\", \"\", \"list all mnemonics\",\n\t\"aomj\", \"\", \"list in json format (TODO: add instruction description too?)\",\n\t\"aomd\", \"\", \"verbose mnemonic listing with instruction description\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ao = {\n\t\"Usage:\", \"ao[e?] [len]\", \"analyze Opcodes\",\n\t\"ao\", \" 5\", \"display opcode analysis of 5 opcodes\",\n\t\"ao*\", \"\", \"display opcode in r commands\",\n\t\"aob\", \" ([hex])\", \"analyze meaning of every single bit in the current opcode\",\n\t\"aoc\", \" [cycles]\", \"analyze which op could be executed in [cycles]\",\n\t\"aod\", \" [mnemonic]\", \"instruction mnemonic description for asm.arch\",\n\t\"aoda\", \"\", \"show all mnemonic descriptions\",\n\t\"aoe\", \" N\", \"display esil form for N opcodes\",\n\t\"aoem\", \" N\", \"display memory references from esil emulation of N opcode\",\n\t\"aoef\", \" expr\", \"filter esil expression of opcode by given output\",\n\t\"aoeq\", \" N\", \"display only the esil expression of N opcodes\",\n\t\"aoj\", \" N\", \"display opcode analysis information in JSON for N opcodes\",\n\t\"aom\", \"[?] [id]\", \"list current or all mnemonics for current arch\",\n\t\"aor\", \" [N]\", \"run N esil instructions + esil.dumpstack\",\n\t\"aos\", \" N\", \"display size of N opcodes\",\n\t\"aot\", \"[?]\", \"list all opcode types\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ar = {\n\t\"Usage: ar\", \"\", \"# Analysis Registers\",\n\t\"ar\", \"\", \"show 'gpr' registers\",\n\t\"ar.\", \">$snapshot\", \"show r2 commands to set register values to the current state\",\n\t\"ar,\", \"\", \"show registers in table format (see dr,)\",\n\t\".ar*\", \"\", \"import register values as flags\",\n\t\".ar-\", \"\", \"unflag all registers\",\n\t\"ar0\", \"\", \"reset register arenas to 0\",\n\t\"ara\", \"[?]\", \"manage register arenas\",\n\t\"arj\", \"\", \"show 'gpr' registers in JSON format\",\n\t\"arA\", \"\", \"show values of function argument calls (A0, A1, A2, ..)\",\n\t\"ar\", \" 16\", \"show 16 bit registers\",\n\t\"ar\", \" 32\", \"show 32 bit registers\",\n\t\"ar\", \" all\", \"show all bit registers\",\n\t\"ar\", \" <type>\", \"show all registers of given type\",\n\t\"arC\", \"\", \"display register profile comments\",\n\t\"arr\", \"\", \"show register references (telescoping)\",\n\t\"arrj\", \"\", \"show register references (telescoping) in JSON format\",\n\t\"ar=\", \"([size])(:[regs])\", \"show register values in columns\",\n\t\"ar?\", \" <reg>\", \"show register value\",\n\t\"arb\", \" <type>\", \"display hexdump of the given arena\",\n\t\"arc\", \"[cq=] <name>\", \"conditional flag registers\",\n\t\"arcc\", \"\", \"derive calling convention from the register profile\",\n\t\"ard\", \" <name>\", \"show only different registers\",\n\t\"arn\", \" <regalias>\", \"get regname for pc,sp,bp,a0-3,zf,cf,of,sg\",\n\t\"aro\", \"\", \"show old (previous) register values\",\n\t\"arp\", \"[?] <file>\", \"load register profile from file\",\n\t\"ars\", \"\", \"stack register state\",\n\t\"arS\", \"\", \"show the size of the register profile\",\n\t\"art\", \"\", \"list all register types\",\n\t\"arw\", \" <hexnum>\", \"set contents of the register arena\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ara = {\n\t\"Usage:\", \"ara[+-s]\", \"register Arena Push/Pop/Swap\",\n\t\"ara\", \"\", \"show all register arenas allocated\",\n\t\"ara\", \"+\", \"push a new register arena for each type\",\n\t\"ara\", \"-\", \"pop last register arena\",\n\t\"aras\", \"\", \"swap last two register arenas\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_arw = {\n\t\"Usage:\", \"arw \", \"# Set contents of the register arena\",\n\t\"arw\", \" <hexnum>\", \"set contents of the register arena\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_as = {\n\t\"Usage: as[ljk?]\", \"\", \"syscall name <-> number utility\",\n\t\"as\", \"\", \"show current syscall and arguments\",\n\t\"as\", \" 4\", \"show syscall 4 based on asm.os and current regs/mem\",\n\t\"asc[a]\", \" 4\", \"dump syscall info in .asm or .h\",\n\t\"asj\", \"\", \"list of syscalls in JSON\",\n\t\"asl\", \"\", \"list of syscalls by asm.os and asm.arch\",\n\t\"asl\", \" close\", \"returns the syscall number for close\",\n\t\"asl\", \" 4\", \"returns the name of the syscall number 4\",\n\t\"ask\", \" [query]\", \"perform syscall/ queries\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_av = {\n\t\"Usage:\", \"av[?jr*]\", \" C++ vtables and RTTI\",\n\t\"av\", \"\", \"search for vtables in data sections and show results\",\n\t\"avj\", \"\", \"like av, but as json\",\n\t\"av*\", \"\", \"like av, but as r2 commands\",\n\t\"avr\", \"[j@addr]\", \"try to parse RTTI at vtable addr (see anal.cxxabi)\",\n\t\"avra\", \"[j]\", \"search for vtables and try to parse RTTI at each of them\",\n\t\"avrr\", \"\", \"recover class info from all findable RTTI (see ac)\",\n\t\"avrD\", \" [classname]\", \"demangle a class name from RTTI\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ax = {\n\t\"Usage:\", \"ax[?d-l*]\", \" # see also 'afx?'\",\n\t\"ax\", \" addr [at]\", \"add code ref pointing to addr (from curseek)\",\n\t\"ax\", \"\", \"list refs\",\n\t\"ax*\", \"\", \"output radare commands\",\n\t\"ax-\", \" [at]\", \"clean all refs/refs from addr\",\n\t\"ax-*\", \"\", \"clean all refs/refs\",\n\t\"ax.\", \" [addr]\", \"find data/code references from and to this address\",\n\t\"axc\", \" addr [at]\", \"add generic code ref\",\n\t\"axC\", \" addr [at]\", \"add code call ref\",\n\t\"axd\", \" addr [at]\", \"add data ref\",\n\t\"axF\", \" [flg-glob]\", \"find data/code references of flags\",\n\t\"axf\", \"[?] [addr]\", \"find data/code references from this address\",\n\t\"axff[j]\", \" [addr]\", \"find data/code references from this function\",\n\t\"axg\", \" [addr]\", \"show xrefs graph to reach current function\",\n\t\"axg*\", \" [addr]\", \"show xrefs graph to given address, use .axg*;aggv\",\n\t\"axgj\", \" [addr]\", \"show xrefs graph to reach current function in json format\",\n\t\"axi\", \" addr [at]\", \"add indirect code reference (see ax?)\",\n\t\"axj\", \"\", \"add jmp reference\", // list refs in json format\",\n\t\"axl\", \"[jcq]\", \"list xrefs (axlc = count, axlq = quiet, axlj = json)\",\n\t\"axm\", \" addr [at]\", \"copy data/code references pointing to addr to also point to curseek (or at)\",\n\t\"axq\", \"\", \"list refs in quiet/human-readable format\",\n\t\"axr\", \" addr [at]\", \"add data-read ref\",\n\t\"axs\", \" addr [at]\", \"add string ref\",\n\t\"axt\", \"[?] [addr]\", \"find data/code references to this address\",\n\t\"axv\", \"[?] [addr]\", \"list local variables read-write-exec references\",\n\t\"axw\", \" addr [at]\", \"add data-write ref\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_axl= {\n\t\"Usage:\", \"axl[jcq]\", \"show global xrefs\",\n\t\"axl\", \"\", \"list all xrefs\",\n\t\"axlj\", \"\", \"list xrefs in json format\",\n\t\"axlc\", \"\", \"count how many xrefs are registered\",\n\t\"axlq\", \"\", \"list xrefs in quiet mode (axq)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_axv= {\n\t\"Usage:\", \"axv[?j]\", \"show xrefs to local variables in current function\",\n\t\"axv\", \" ([addr])\", \"optionally you can specify address instead of current seek\",\n\t\"axvj\", \" ([addr])\", \"show in json\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_axt= {\n\t\"Usage:\", \"axt[?gq*]\", \"find data/code references to this address\",\n\t\"axtj\", \" [addr]\", \"find data/code references to this address and print in json format\",\n\t\"axtg\", \" [addr]\", \"display commands to generate graphs according to the xrefs\",\n\t\"axtq\", \" [addr]\", \"find and list the data/code references in quiet mode\",\n\t\"axtm\", \" [addr]\", \"show xrefs to in 'make' syntax (see aflm and axfm)\",\n\t\"axt*\", \" [addr]\", \"same as axt, but prints as r2 commands\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_axf= {\n\t\"Usage:\", \"axf[?gq*]\", \"find data/code references from this address\",\n\t\"axfj\", \" [addr]\", \"find data/code references to this address and print in json format\",\n\t\"axfg\", \" [addr]\", \"display commands to generate graphs according to the xrefs\",\n\t\"axfq\", \" [addr]\", \"find and list the data/code references in quiet mode\",\n\t\"axfm\", \" [addr]\", \"show refs to in 'make' syntax (see aflm and axtm)\",\n\t\"axf*\", \" [addr]\", \"same as axt, but prints as r2 commands\",\n\tNULL\n};\n\nstatic inline const char *get_arch_name(RCore *core) {\n\treturn r_config_get (core->config, \"asm.arch\");\n}\n\nstatic int cmpname(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\treturn (int)strcmp (a->name, b->name);\n}\n\nstatic int cmpsize(const void *a, const void *b) {\n\tut64 sa = (int) r_anal_function_linear_size ((RAnalFunction *) a);\n\tut64 sb = (int) r_anal_function_linear_size ((RAnalFunction *) b);\n\treturn (sa > sb)? -1: (sa < sb)? 1 : 0;\n}\n\nstatic int cmpbbs(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\tint la = (int)r_list_length (a->bbs);\n\tint lb = (int)r_list_length (b->bbs);\n\treturn (la > lb)? -1: (la < lb)? 1 : 0;\n}\n\nstatic int cmpaddr(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\treturn (a->addr > b->addr)? 1: (a->addr < b->addr)? -1: 0;\n}\n\nstatic bool listOpDescriptions(void *_core, const char *k, const char *v) {\n\tr_cons_printf (\"%s=%s\\n\", k, v);\n\treturn true;\n}\n\n/* better aac for windows-x86-32 */\n#define JAYRO_03 0\n\n#if JAYRO_03\n\nstatic bool anal_is_bad_call(RCore *core, ut64 from, ut64 to, ut64 addr, ut8 *buf, int bufi) {\n\tut64 align = R_ABS (addr % PE_ALIGN);\n\tut32 call_bytes;\n\n\t// XXX this is x86 specific\n\tif (align == 0) {\n\t\tcall_bytes = (ut32)((ut8*)buf)[bufi + 3] << 24;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 2] << 16;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 1] << 8;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi];\n\t} else {\n\t\tcall_bytes = (ut32)((ut8*)buf)[bufi - align + 3] << 24;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi - align + 2] << 16;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi - align + 1] << 8;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi - align];\n\t}\n\tif (call_bytes >= from && call_bytes <= to) {\n\t\treturn true;\n\t}\n\tcall_bytes = (ut32)((ut8*)buf)[bufi + 4] << 24;\n\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 3] << 16;\n\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 2] << 8;\n\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 1];\n\tcall_bytes += addr + 5;\n\tif (call_bytes >= from && call_bytes <= to) {\n\t\treturn false;\n\t}\n\treturn false;\n}\n#endif\n\nstatic ut64 faddr(RCore *core, ut64 addr, bool *nr) {\n\tRList *fcns = r_anal_get_functions_in (core->anal, addr);\n\tif (fcns && r_list_length (fcns) > 0) {\n\t\tRListIter *iter;\n\t\tRAnalFunction *fcn;\n\t\tr_list_foreach (fcns, iter, fcn) {\n\t\t\tif (nr && fcn->is_noreturn) {\n\t\t\t\t*nr = true;\n\t\t\t}\n\t\t\treturn fcn->addr;\n\t\t}\n\t}\n\tr_list_free (fcns);\n\treturn addr;\n}\n\n// function argument types and names into anal/types\nstatic void __add_vars_sdb(RCore *core, RAnalFunction *fcn) {\n\tRAnalFcnVarsCache cache;\n\tr_anal_function_vars_cache_init (core->anal, &cache, fcn);\n\tRListIter *iter;\n\tRAnalVar *var;\n\tsize_t arg_count = 0;\n\n\tchar *args = r_str_newf (\"func.%s.args\", fcn->name);\n\tRList *all_vars = cache.rvars;\n\tr_list_join (all_vars, cache.bvars);\n\tr_list_join (all_vars, cache.svars);\n#if 0\n\tr_list_foreach (all_vars, iter, var) {\n\t\tif (var->isarg) {\n\t\t\targ_count++;\n\t\t}\n\t}\n\tint old_arg_count = r_num_get (NULL, args);\n\tif (old_arg_count >= arg_count) {\n\t\treturn;\n\t}\n#endif\n\tr_list_foreach (all_vars, iter, var) {\n\t\tif (var->isarg) {\n\t\t\tchar *k = r_str_newf (\"func.%s.arg.%d\", fcn->name, (int)arg_count);\n\t\t\tconst char *o = sdb_const_get (core->anal->sdb_types, k, 0);\n\t\t\tchar *comma = o? strchr (o, ','): NULL;\n\t\t\tchar *db_type = comma? r_str_ndup (o, comma - o): NULL;\n\t\t\tchar *db_name = comma? strdup (comma + 1): NULL;\n\t\t\tif (!strstr (var->name, \"arg_\") || (o && strstr (o, \",arg_\"))) {\n\t\t\t\t// #if 0\n\t\t\t\tchar *ks = r_str_newf (\"func.%s.arg.%d\", fcn->name, (int)arg_count);\n\t\t\t\t// eprintf (\"VARNAME %s %s %c\", var->name, db_name, 10);\n\t\t\t\t// eprintf (\"VARTYPE %s %s %c\", var->type,db_type, 10);\n\t\t\t\tchar *type = db_type && strstr (var->type, \"arg_\")? db_type: var->type;\n\t\t\t\tchar *v = r_str_newf (\"%s,%s\", type, var->name);\n\t\t\t\tsdb_set (core->anal->sdb_types, ks, v, 0);\n\t\t\t\tfree (ks);\n\t\t\t\tfree (v);\n\t\t\t} else {\n\t\t\t\tchar *name = db_name? db_name: var->name;\n\t\t\t\tchar *type = strdup (db_type? db_type: var->type);\n\t\t\t\t// eprintf (\"VARTYPE1 %s %s %c\", var->type,db_type, 10);\n\t\t\t\tif (var->name && !strstr (var->name, \"arg_\")) {\n\t\t\t\t\to = NULL;\n\t\t\t\t}\n#if 0\n\t\t\t\tif (name != var->name) {\n\t\t\t\t\to = NULL;\n\t\t\t\t} else {\n\t\t\t\t\ttype = strdup (var->type);\n\t\t\t\t}\n#endif\n\t\t\t\tchar *v = comma? strdup (o): r_str_newf (\"%s,%s\", type, name);\n\t\t\t\t/// eprintf(\"arg (%s) %s -- %s%c\", k, v, var->name, 10);\n\t\t\t\tchar *s = strdup (name);\n\t\t\t\tif (o) {\n\t\t\t\t\tchar *v2 = r_str_newf (\"%s,%s\", var->type, name);\n\t\t\t\t\tif (!strstr (var->name, \",arg_\")) {\n\t\t\t\t\t\tfree (var->name);\n\t\t\t\t\t\tvar->name = s;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfree (s);\n\t\t\t\t\t}\n\t\t\t\t\t// sdb_set (core->anal->sdb_types, k, v, 0);\n\t\t\t\t\tfree (v2);\n\t\t\t\t} else {\n\t\t\t\t\tfree (var->name);\n\t\t\t\t\tvar->name = s;\n\t\t\t\t\tsdb_set (core->anal->sdb_types, k, v, 0);\n\t\t\t\t}\n\t\t\t\tfree (v);\n\t\t\t\tfree (type);\n\t\t\t\t// #endif\n\t\t\t}\n\t\t\tfree (db_name);\n\t\t\tfree (db_type);\n\t\t\tfree (k);\n\t\t\targ_count++;\n\t\t}\n\t}\n\t//\tsdb_num_set (core->anal->sdb_types, args, (int)arg_count, 0);\n\tif (arg_count > 0) {\n\t\tchar *k = r_str_newf (\"func.%s.args\", fcn->name);\n\t\tchar *v = r_str_newf (\"%d\", (int)arg_count);\n\t\tsdb_set (core->anal->sdb_types, k, v, 0);\n\t\t// sdb_num_set (core->anal->sdb_types, k, (ut64)arg_count, 0);\n\t\tfree (k);\n\t\tfree (v);\n \t}\n\tfree (args);\n\tr_anal_function_vars_cache_fini (&cache);\n}\n\nstatic bool cmd_anal_aaft(RCore *core) {\n\tRListIter *it;\n\tRAnalFunction *fcn;\n\tut64 seek;\n\tconst char *io_cache_key = \"io.pcache.write\";\n\tbool io_cache = r_config_get_b (core->config, io_cache_key);\n\tif (r_config_get_b (core->config, \"cfg.debug\")) {\n\t\tR_LOG_WARN (\"aaft is disabled in debugger mode\");\n\t\treturn false;\n\t}\n\tif (!io_cache) {\n\t\t// XXX. we shouldnt need this, but it breaks 'r2 -c aaa -w ls'\n\t\tr_config_set_i (core->config, io_cache_key, true);\n\t}\n\tconst bool iova = r_config_get_b (core->config, \"io.va\");\n\tseek = core->offset;\n\tr_reg_arena_push (core->anal->reg);\n\tr_reg_arena_zero (core->anal->reg);\n\tr_core_cmd_call (core, \"aei\");\n\tr_core_cmd_call (core, \"aeim\");\n\tint saved_arena_size = 0;\n\tut8 *saved_arena = r_reg_arena_peek (core->anal->reg, &saved_arena_size);\n\t// Iterating Reverse so that we get function in top-bottom call order\n\tr_list_foreach_prev (core->anal->fcns, it, fcn) {\n\t\tint ret = r_core_seek (core, fcn->addr, true);\n\t\tif (!ret) {\n\t\t\tcontinue;\n\t\t}\n\t\tr_reg_arena_poke (core->anal->reg, saved_arena, saved_arena_size);\n\t\tr_esil_set_pc (core->anal->esil, fcn->addr);\n\t\tr_core_anal_type_match (core, fcn);\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t__add_vars_sdb (core, fcn);\n\t}\n\tr_config_set_b (core->config, \"io.va\", iova);\n\tr_core_seek (core, seek, true);\n\tr_reg_arena_pop (core->anal->reg);\n\tr_config_set_i (core->config, io_cache_key, io_cache);\n\tfree (saved_arena);\n\treturn true;\n}\n\nstatic void type_cmd(RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tif (!fcn && *input != '?') {\n\t\tR_LOG_WARN (\"cant find function here\");\n\t\treturn;\n\t}\n\tut64 seek;\n\tr_cons_break_push (NULL, NULL);\n\tswitch (*input) {\n\tcase '\\0': // \"aft\"\n\t\tseek = core->offset;\n\t\tr_esil_set_pc (core->anal->esil, fcn? fcn->addr: core->offset);\n\t\tr_core_anal_type_match (core, fcn);\n\t\tr_core_seek (core, seek, true);\n\t\tbreak;\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_aft);\n\t\tbreak;\n\t}\n\tr_cons_break_pop ();\n}\n\nstatic void find_refs(RCore *core, const char *glob) {\n\tut64 curseek = core->offset;\n\tglob = r_str_trim_head_ro (glob);\n\tif (!*glob) {\n\t\tglob = \"str.\";\n\t}\n\tif (*glob == '?') {\n\t\tr_core_cmd_help_match (core, help_msg_ax, \"axF\", true);\n\t\treturn;\n\t}\n\tR_LOG_WARN (\"Finding references of flags matching '%s'\", glob);\n\tchar *cmd = r_str_newf (\".(findstref) @@=`f~%s[0]`\", glob);\n\tr_core_cmd0 (core, \"(findstref;f here=$$;s entry0;/r here;f-here)\");\n\tr_core_cmd0 (core, cmd);\n\tr_core_cmd0 (core, \"(-findstref)\");\n\tr_core_seek (core, curseek, true);\n\tfree (cmd);\n}\n\nstatic ut64 sort64val(const void *a) {\n\tut64 *na = (ut64*)a;\n\treturn *na;\n}\nstatic int sort64(const void *a, const void *b) {\n\tut64 *na = (ut64*)a;\n\tut64 *nb = (ut64*)b;\n\treturn *na - *nb;\n}\n\nstatic RList *collect_addresses(RCore *core) {\n#if 0\n\tWIP: return addresses where functions start from different sources:\n\t* [x] symbols\n\t* [ ] exports\n\t* [ ] prelude search\n\t* [ ] call ref analysis\n\tresult is then sorted and uniqified\n#endif\n\tRList *list = r_list_newf (free);\n\tRBinSymbol *sym;\n\tRVecRBinSymbol *symbols = r_bin_get_symbols_vec (core->bin);\n\tR_VEC_FOREACH (symbols, sym) {\n\t\tr_list_append (list, ut64_new (sym->vaddr));\n\t}\n\t// find all calls and mark the destinations as function entrypoints\n\t// r_core_search_preludes (core, true); // __prelude_cb_hit uses globals and calls 'af', should be changed to just return a list for later processing\n\tr_list_sort (list, sort64);\n\tr_list_uniq_inplace (list, sort64val);\n\treturn list;\n}\n\nstatic void single_block_analysis(RCore *core) {\n\tconst ut64 max_fcn_size = 1024 * 1024;\n\tRList *list = collect_addresses (core);\n\tRListIter *iter;\n\tut64 *addr;\n\tr_list_foreach (list, iter, addr) {\n\t\tut64 *next = iter->n? iter->n->data: addr;\n\t\tint len = (*next) - *addr;\n\t\tif (len > 0 && len < max_fcn_size) {\n\t\t\tut64 at = *addr;\n\t\t\tif (r_anal_get_function_at (core->anal, at)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRFlagItem *fi = r_flag_get_at (core->flags, at, false);\n\t\t\tchar *name = (fi) ? strdup (fi->name): r_str_newf (\"fcn.%08\"PFMT64x, at);\n\t\t\tRAnalFunction *fcn = r_anal_create_function (core->anal, name, at, 0, NULL);\n\t\t\tif (fcn) {\n\t\t\t\tr_anal_function_add_bb (core->anal, fcn, at, len, UT64_MAX, UT64_MAX, 0);\n\t\t\t}\n\t\t\tfree (name);\n\t\t}\n\t}\n\tr_list_free (list);\n}\n\n/* set flags for every function */\nstatic void flag_every_function(RCore *core) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_flag_space_push (core->flags, R_FLAGS_FS_FUNCTIONS);\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tr_flag_set (core->flags, fcn->name,\n\t\t\tfcn->addr, r_anal_function_size_from_entry (fcn));\n\t}\n\tr_flag_space_pop (core->flags);\n}\n\nstatic void var_help(RCore *core, char ch) {\n\tswitch (ch) {\n\tcase 'b':\n\t\tr_core_cmd_help (core, help_msg_afvb);\n\t\tbreak;\n\tcase 's':\n\t\tr_core_cmd_help (core, help_msg_afvs);\n\t\tbreak;\n\tcase 'r':\n\t\tr_core_cmd_help (core, help_msg_afvr);\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_afv);\n\t\tbreak;\n\t}\n}\n\nstatic void var_accesses_list(RAnalFunction *fcn, RAnalVar *var, PJ *pj, int access_type, const char *name) {\n\tRAnalVarAccess *acc;\n\tbool first = true;\n\tif (r_vector_empty (&var->accesses)) {\n\t\tR_LOG_WARN (\"Variable '%s' have no references?\", name);\n\t}\n\tif (pj) {\n\t\tpj_o (pj);\n\t\tpj_ks (pj, \"name\", name);\n\t\tpj_ka (pj, \"addrs\");\n\t} else {\n\t\tr_cons_printf (\"%10s\", name);\n\t}\n\tr_vector_foreach (&var->accesses, acc) {\n\t\tif (!(acc->type & access_type)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 addr = fcn->addr + acc->offset;\n\t\tif (pj) {\n\t\t\tpj_n (pj, addr);\n\t\t} else {\n\t\t\tr_cons_printf (\"%s0x%\" PFMT64x, first ? \"  \" : \",\", addr);\n\t\t}\n\t\tfirst = false;\n\t}\n\tif (pj) {\n\t\tpj_end (pj);\n\t\tpj_end (pj);\n\t} else {\n\t\tr_cons_newline ();\n\t}\n}\n\nstatic void list_vars(RCore *core, RAnalFunction *fcn, PJ *pj, int type, const char *name) {\n\tRAnalVar *var = NULL;\n\tRListIter *iter;\n\tRList *list = r_anal_var_all_list (core->anal, fcn);\n\tif (type == '=') {\n\t\tut64 oaddr = core->offset;\n\t\tr_list_foreach (list, iter, var) {\n\t\t\tr_cons_printf (\"* %s\\n\", var->name);\n\t\t\tRAnalVarAccess *acc;\n\t\t\tr_vector_foreach (&var->accesses, acc) {\n\t\t\t\tif (!(acc->type & R_ANAL_VAR_ACCESS_TYPE_READ)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"R 0x%\"PFMT64x\"  \", fcn->addr + acc->offset);\n\t\t\t\tr_core_seek (core, fcn->addr + acc->offset, 1);\n\t\t\t\tr_core_print_disasm_instructions (core, 0, 1);\n\t\t\t}\n\t\t\tr_vector_foreach (&var->accesses, acc) {\n\t\t\t\tif (!(acc->type & R_ANAL_VAR_ACCESS_TYPE_WRITE)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"W 0x%\"PFMT64x\"  \", fcn->addr + acc->offset);\n\t\t\t\tr_core_seek (core, fcn->addr + acc->offset, 1);\n\t\t\t\tr_core_print_disasm_instructions (core, 0, 1);\n\t\t\t}\n\t\t}\n\t\tr_core_seek (core, oaddr, 0);\n\t\tr_list_free (list);\n\t\treturn;\n\t}\n\tif (type == '*') {\n\t\tconst char *bp = r_reg_get_name (core->anal->reg, R_REG_NAME_BP);\n\t\tr_cons_printf (\"f-fcnvar*\\n\");\n\t\tr_list_foreach (list, iter, var) {\n\t\t\tr_cons_printf (\"f fcnvar.%s @ %s%s%d\\n\", var->name, bp,\n\t\t\t\tvar->delta >= 0? \"+\":\"\", var->delta);\n\t\t}\n\t\tr_list_free (list);\n\t\treturn;\n\t}\n\tif (type != 'W' && type != 'R') {\n\t\tr_list_free (list);\n\t\treturn;\n\t}\n\tint access_type = type == 'R' ? R_ANAL_VAR_ACCESS_TYPE_READ : R_ANAL_VAR_ACCESS_TYPE_WRITE;\n\tif (pj) {\n\t\tpj_a (pj);\n\t}\n\tif (name && *name) {\n\t\tvar = r_anal_function_get_var_byname (fcn, name);\n\t\tif (var) {\n\t\t\tvar_accesses_list (fcn, var, pj, access_type, var->name);\n\t\t}\n\t} else {\n\t\tr_list_foreach (list, iter, var) {\n\t\t\tvar_accesses_list (fcn, var, pj, access_type, var->name);\n\t\t}\n\t}\n\tif (pj) {\n\t\tpj_end (pj);\n\t}\n\tr_list_free (list);\n}\n\nstatic void cmd_afvx(RCore *core, RAnalFunction *fcn, bool json) {\n\tr_return_if_fail (core);\n\tif (!fcn) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_ANY);\n\t}\n\tif (fcn) {\n\t\tPJ *pj = NULL;\n\t\tif (json) {\n\t\t\tpj = pj_new ();\n\t\t\tpj_o (pj);\n\t\t\tpj_k (pj, \"reads\");\n\t\t} else {\n\t\t\tr_cons_printf (\"afvR\\n\");\n\t\t}\n\t\tlist_vars (core, fcn, pj, 'R', NULL);\n\t\tif (json) {\n\t\t\tpj_k (pj, \"writes\");\n\t\t} else {\n\t\t\tr_cons_printf (\"afvW\\n\");\n\t\t}\n\t\tlist_vars (core, fcn, pj, 'W', NULL);\n\t\tif (json) {\n\t\t\tpj_end (pj);\n\t\t\tchar *j = pj_drain (pj);\n\t\t\tr_cons_printf (\"%s\\n\", j);\n\t\t\tfree (j);\n\t\t}\n\t}\n}\n\nstatic int cmd_an(RCore *core, const char *name, int mode) {\n\tint ret = 0;\n\tRAnalOp op = {0};\n\tPJ *pj = NULL;\n\n\tif (mode == 'j') {\n\t\tpj = pj_new ();\n\t\tpj_a (pj);\n\t}\n\tif (r_anal_op (core->anal, &op, core->offset, core->block, core->blocksize, R_ARCH_OP_MASK_BASIC) < 1) {\n\t\tgoto failure;\n\t}\n\tRAnalVar *var = r_anal_get_used_function_var (core->anal, op.addr);\n\n\tut64 tgt_addr = op.jump != UT64_MAX? op.jump: op.ptr;\n\tif (var) {\n\t\tif (name) {\n\t\t\tret = r_anal_var_rename (var, name, true) ? 0 : -1;\n\t\t} else if (mode == '*') {\n\t\t\tr_cons_printf (\"f %s=0x%\" PFMT64x \"\\n\", var->name, tgt_addr);\n\t\t} else if (mode == 'j') {\n\t\t\tpj_o (pj);\n\t\t\tpj_ks (pj, \"name\", var->name);\n\t\t\tpj_ks (pj, \"type\", \"var\");\n\t\t\tpj_kn (pj, \"offset\", tgt_addr);\n\t\t\tpj_end (pj);\n\t\t} else {\n\t\t\tr_cons_println (var->name);\n\t\t}\n\t} else {\n\t\tif (tgt_addr == UT64_MAX) {\n\t\t\ttgt_addr = core->offset;\n\t\t}\n\t\tRFlagItem *f = r_flag_get_by_spaces (core->flags, tgt_addr, R_FLAGS_FS_SYMBOLS, R_FLAGS_FS_IMPORTS, NULL);\n\t\tif (!f) {\n\t\t\tf = r_flag_get_i (core->flags, tgt_addr);\n\t\t}\n\t\tRAnalFunction *fcn = r_anal_get_function_at (core->anal, tgt_addr);\n\t\tif (fcn) {\n\t\t\tif (name) {\n\t\t\t\tret = r_anal_function_rename (fcn, name)? 0: -1;\n\t\t\t} else if (mode == '*') {\n\t\t\t\tr_cons_printf (\"f %s=0x%\" PFMT64x \"\\n\", fcn->name, core->offset);\n\t\t\t} else if (mode == 'j') {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", fcn->name);\n\t\t\t\tpj_ks (pj, \"type\", \"function\");\n\t\t\t\tpj_kn (pj, \"offset\", tgt_addr);\n\t\t\t\tpj_end (pj);\n\t\t\t} else {\n\t\t\t\tr_cons_println (fcn->name);\n\t\t\t}\n\t\t} else if (f) {\n\t\t\tif (name) {\n\t\t\t\tret = r_flag_rename (core->flags, f, name)? 0: -1;\n\t\t\t} else if (mode == '*') {\n\t\t\t\tr_cons_printf (\"f %s=0x%\" PFMT64x \"\\n\", r_str_get (name), core->offset);\n\t\t\t} else if (mode == 'j') {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", f->name);\n\t\t\t\tif (f->realname) {\n\t\t\t\t\tpj_ks (pj, \"realname\", f->realname);\n\t\t\t\t}\n\t\t\t\tpj_ks (pj, \"type\", \"flag\");\n\t\t\t\tpj_kn (pj, \"offset\", tgt_addr);\n\t\t\t\tpj_end (pj);\n\t\t\t} else {\n\t\t\t\tr_cons_println (f->name);\n\t\t\t}\n\t\t} else {\n\t\t\tif (name) {\n\t\t\t\tret = r_flag_set (core->flags, name, tgt_addr, 1)? 0: -1;\n\t\t\t} else if (mode == '*') {\n\t\t\t\tr_cons_printf (\"f %s=0x%\" PFMT64x \"\\n\", r_str_get (name), core->offset);\n\t\t\t} else if (mode == 'j') {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", r_str_get (name));\n\t\t\t\tpj_ks (pj, \"type\", \"address\");\n\t\t\t\tpj_kn (pj, \"offset\", tgt_addr);\n\t\t\t\tpj_end (pj);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", tgt_addr);\n\t\t\t}\n\t\t}\n\t}\nfailure:\n\tif (mode == 'j') {\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\n\tr_anal_op_fini (&op);\n\treturn ret;\n}\n\n// EBP BASED\nstatic int delta_cmp(const void *a, const void *b) {\n\tconst RAnalVar *va = a;\n\tconst RAnalVar *vb = b;\n\treturn vb->delta - va->delta;\n}\n\nstatic int delta_cmp2(const void *a, const void *b) {\n\tconst RAnalVar *va = a;\n\tconst RAnalVar *vb = b;\n\treturn va->delta - vb->delta;\n}\n\nstatic void __cmd_afvf(RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tRListIter *iter;\n\tRAnalVar *p;\n\tRList *list = r_anal_var_all_list (core->anal, fcn);\n\tr_list_sort (list, delta_cmp2);\n\tr_list_foreach (list, iter, p) {\n\t\tif (p->isarg || p->delta > 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *pad = r_str_pad (' ', 10 - strlen (p->name));\n\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %s:%s%s\\n\", (ut64)-p->delta, p->name, pad, p->type);\n\t}\n\tr_list_sort (list, delta_cmp);\n\tr_list_foreach (list, iter, p) {\n\t\tif (!p->isarg && p->delta < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t// TODO: only stack vars if (p->kind == 's') { }\n\t\tconst char *pad = r_str_pad (' ', 10 - strlen (p->name));\n\t\t// XXX this 0x6a is a hack\n\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %s:%s%s\\n\", ((ut64)p->delta) - 0x6a, p->name, pad, p->type);\n\t}\n\tr_list_free (list);\n\n}\n\nstatic int var_cmd(RCore *core, const char *str) {\n\tint delta, type = *str, res = true;\n\tRAnalVar *v1;\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tif (!fcn) {\n\t\tswitch (str[0]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_afv);\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tr_cons_println (\"{}\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_ERROR (\"No function found in current offset\");\n\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t}\n\tif (!str[0]) {\n\t\tif (fcn) {\n\t\t\t// \"afv\"\n\t\t\tr_core_cmd_call (core, \"afvr\");\n\t\t\tr_core_cmd_call (core, \"afvs\");\n\t\t\tr_core_cmd_call (core, \"afvb\");\n\t\t} else {\n\t\t\tR_LOG_WARN (\"Cannot find function in 0x%08\"PFMT64x, core->offset);\n\t\t}\n\t\treturn true;\n\t}\n\tif (str[1] == '?'|| str[0] == '?') {\n\t\tvar_help (core, *str);\n\t\treturn res;\n\t}\n\tPJ *pj = NULL;\n\tif (str[0] == 'j') { // \"afvj\"\n\t\tpj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\treturn false;\n\t\t}\n\t\tpj_o (pj);\n\t\tpj_k (pj, \"reg\");\n\t\tr_anal_var_list_show (core->anal, fcn, 'r', 'j', pj);\n\t\tpj_k (pj, \"sp\");\n\t\tr_anal_var_list_show (core->anal, fcn, 's', 'j', pj);\n\t\tpj_k (pj, \"bp\");\n\t\tr_anal_var_list_show (core->anal, fcn, 'b', 'j', pj);\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t\treturn true;\n\t}\n\tchar *p = strdup (str);\n\tchar *ostr = p;\n\t/* Variable access CFvs = set fun var */\n\tswitch (str[0]) {\n\tcase '-': // \"afv-\"\n\t\tr_core_cmdf (core, \"afvr-%s\", str + 1);\n\t\tr_core_cmdf (core, \"afvs-%s\", str + 1);\n\t\tr_core_cmdf (core, \"afvb-%s\", str + 1);\n\t\treturn true;\n\tcase 'x': // \"afvx\"\n\t\tif (fcn) {\n\t\t\tcmd_afvx (core, fcn, str[1] == 'j');\n\t\t} else {\n\t\t\tR_LOG_WARN (\"Cannot find function in 0x%08\"PFMT64x, core->offset);\n\t\t}\n\t\tfree (ostr);\n\t\treturn true;\n\tcase 'R': // \"afvR\"\n\tcase 'W': // \"afvW\"\n\tcase '*': // \"afv*\"\n\tcase '=': // \"afv=\"\n\t\tif (fcn) {\n\t\t\tconst char *name = strchr (ostr, ' ');\n\t\t\tif (name) {\n\t\t\t\tname = r_str_trim_head_ro (name);\n\t\t\t}\n\t\t\tif (str[1] == 'j') {\n\t\t\t\tpj = r_core_pj_new (core);\n\t\t\t\tif (!pj) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_vars (core, fcn, pj, str[0], name);\n\t\t\tif (str[1] == 'j') {\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find function in 0x%08\"PFMT64x, core->offset);\n\t\t\tfree (ostr);\n\t\t\treturn false;\n\t\t}\n\tcase 'a': // \"afva\"\n\t\tif (fcn) {\n\t\t\tchar *type = r_str_newf (\"func.%s.ret\", fcn->name);\n\t\t\tif (type && sdb_exists (core->anal->sdb_types, type)) {\n\t\t\t\t// if function type exists\n\t\t\t\t// do not analize vars if function has a signature\n\t\t\t} else {\n\t\t\t\tr_anal_function_delete_all_vars (fcn);\n\t\t\t\tr_core_recover_vars (core, fcn, false);\n\t\t\t}\n\t\t\tfree (type);\n\t\t\tfree (p);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find function in 0x%08\"PFMT64x, core->offset);\n\t\t\treturn false;\n\t\t}\n\tcase 'n': // \"afvn\"\n\t\tif (str[1]) {\n\t\t\tRAnalOp *op = r_core_anal_op (core, core->offset, R_ARCH_OP_MASK_BASIC);\n\t\t\tconst char *new_name = r_str_trim_head_ro (strchr (ostr, ' '));\n\t\t\tif (!new_name) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tchar *old_name = strchr (new_name, ' ');\n\t\t\tif (!old_name) {\n\t\t\t\tRAnalVar *var = op ? r_anal_get_used_function_var (core->anal, op->addr) : NULL;\n\t\t\t\tif (var) {\n\t\t\t\t\told_name = var->name;\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot find var @ 0x%08\"PFMT64x, core->offset);\n\t\t\t\t\tr_anal_op_free (op);\n\t\t\t\t\tfree (ostr);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*old_name++ = 0;\n\t\t\t\tr_str_trim (old_name);\n\t\t\t}\n\t\t\tif (fcn) {\n\t\t\t\tv1 = r_anal_function_get_var_byname (fcn, old_name);\n\t\t\t\tif (v1) {\n\t\t\t\t\tr_anal_var_rename (v1, new_name, true);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Cant find var by name\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot find function in 0x%08\"PFMT64x, core->offset);\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_anal_op_free (op);\n\t\t\tfree (ostr);\n\t\t} else {\n\t\t\tRListIter *iter;\n\t\t\tRAnalVar *v;\n\t\t\tRList *list = r_anal_var_all_list (core->anal, fcn);\n\t\t\tr_list_foreach (list, iter, v) {\n\t\t\t\tr_cons_printf (\"%s\\n\", v->name);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t}\n\t\treturn true;\n\tcase 'd': // \"afvd\"\n\t\tif (!fcn) {\n\t\t\tR_LOG_ERROR (\"Cannot find function\");\n\t\t} else if (str[1]) {\n\t\t\tp = strchr (ostr, ' ');\n\t\t\tif (!p) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_str_trim (p);\n\t\t\tv1 = r_anal_function_get_var_byname (fcn, p);\n\t\t\tif (!v1) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_anal_var_display (core->anal, v1);\n\t\t} else {\n\t\t\tRListIter *iter;\n\t\t\tRAnalVar *p;\n\t\t\tRList *list = r_anal_var_all_list (core->anal, fcn);\n\t\t\tr_list_foreach (list, iter, p) {\n\t\t\t\tchar *a = r_core_cmd_strf (core, \".afvd %s\", p->name);\n\t\t\t\tif ((a && !*a) || !a) {\n\t\t\t\t\tfree (a);\n\t\t\t\t\ta = strdup (\"\\n\");\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"%s %s = %s\", p->isarg? \"arg\": \"var\", p->name, a);\n\t\t\t\tfree (a);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t}\n\t\tfree (ostr);\n\t\treturn true;\n\tcase 'f': // \"afvf\"\n\t\t__cmd_afvf (core, ostr);\n\t\tbreak;\n\tcase 't': // \"afvt\"\n\t\tif (fcn) {\n\t\t\tp = strchr (ostr, ' ');\n\t\t\tif (!p++) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tchar *type = strchr (p, ' ');\n\t\t\tif (!type) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t*type++ = 0;\n\t\t\tv1 = r_anal_function_get_var_byname (fcn, p);\n\t\t\tif (!v1) {\n\t\t\t\tR_LOG_ERROR (\"Cant find get by name %s\", p);\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_anal_var_set_type (v1, type);\n\t\t\tfree (ostr);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find function\");\n\t\t\treturn false;\n\t\t}\n\tcase 'b': // \"afvb\"\n\tcase 's': // \"afbs\"\n\tcase 'r': // \"afbr\"\n\t\tbreak;\n\tdefault:\n\t\tif (str[0]) {\n\t\t\tr_core_cmd_help (core, help_msg_afv);\n\t\t\treturn false;\n\t\t}\n\t}\n\tswitch (str[1]) { // afv[bsr]\n\tcase '\\0':\n\tcase '*': // \"afv[bsr]*\"\n\t\tif (fcn) {\n\t\t\tr_anal_var_list_show (core->anal, fcn, type, str[1], NULL);\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find function\");\n\t\t}\n\t\tbreak;\n\tcase 'j':  // \"afv[bsr]j\"\n\t\tpj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\treturn false;\n\t\t}\n\t\tif (fcn) {\n\t\t\tr_anal_var_list_show (core->anal, fcn, type, str[1], pj);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"No function\");\n\t\t}\n\t\tpj_free (pj);\n\t\tbreak;\n\tcase '.': // \"afv[bsr].\"\n\t\tr_anal_var_list_show (core->anal, fcn, core->offset, 0, NULL);\n\t\tbreak;\n\tcase '-': // \"afv[bsr]-\"\n\t\tif (!fcn) {\n\t\t\tR_LOG_ERROR (\"afv: Cannot find function\");\n\t\t\treturn false;\n\t\t}\n\t\tif (str[2] == '*') {\n\t\t\tr_anal_function_delete_vars_by_kind (fcn, type);\n\t\t} else {\n\t\t\tRAnalVar *var = NULL;\n\t\t\tif (IS_DIGIT (str[2])) {\n\t\t\t\tvar = r_anal_function_get_var (fcn, type, (int)r_num_math (core->num, str + 1));\n\t\t\t} else {\n\t\t\t\tchar *name = r_str_trim_dup (str + 2);\n\t\t\t\tif (name) {\n\t\t\t\t\tvar = r_anal_function_get_var_byname (fcn, name);\n\t\t\t\t\tr_free (name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_delete (var);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 's': // \"afv[bsr]s\" // \"afvs\"\n\tcase 'g': // \"afv[bsr]g\"\n\t\tif (str[2]) {\n\t\t\tint idx = r_num_math (core->num, str + 2);\n\t\t\tchar *vaddr;\n\t\t\tp = strchr (ostr, ' ');\n\t\t\tif (!p) {\n\t\t\t\tvar_help (core, type);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_str_trim (p);\n\t\t\tut64 addr = core->offset;\n\t\t\tif ((vaddr = strchr (p, ' '))) {\n\t\t\t\taddr = r_num_math (core->num, vaddr);\n\t\t\t}\n\t\t\tRAnalVar *var = r_anal_function_get_var (fcn, str[0], idx);\n\t\t\tif (!var) {\n\t\t\t\tR_LOG_ERROR (\"Cannot find variable with delta %d\", idx);\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint rw = (str[1] == 'g') ? R_ANAL_VAR_ACCESS_TYPE_READ : R_ANAL_VAR_ACCESS_TYPE_WRITE;\n\t\t\tint ptr = *var->type == 's' ? idx - fcn->maxstack : idx;\n\t\t\tRAnalOp *op = r_core_anal_op (core, addr, 0);\n\t\t\tconst char *ireg = op ? op->ireg : NULL;\n\t\t\tr_anal_var_set_access (var, ireg, addr, rw, ptr);\n\t\t\tr_anal_op_free (op);\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Missing argument\");\n\t\t}\n\t\tbreak;\n\tcase ' ': { // \"afvs\" \"afvb\" \"afvr\"\n\t\tbool isarg = false;\n\t\tconst int size = 4;\n\t\tp = strchr (ostr, ' ');\n\t\tif (!p) {\n\t\t\tvar_help (core, type);\n\t\t\tbreak;\n\t\t}\n\t\tif (!fcn) {\n\t\t\tR_LOG_ERROR (\"Missing function at 0x%08\" PFMT64x, core->offset);\n\t\t\tbreak;\n\t\t}\n\t\t*p++ = 0;\n\t\tr_str_trim_head (p);\n\t\tchar *name = strchr (p, ' ');\n\t\tif (!name) {\n\t\t\tR_LOG_ERROR (\"Missing name\");\n\t\t\tbreak;\n\t\t}\n\t\t*name++ = 0;\n\t\tr_str_trim_head (name);\n\n\t\tif (type == 'r') { //registers\n\t\t\tRRegItem *ri = r_reg_get (core->anal->reg, p, -1);\n\t\t\tif (!ri) {\n\t\t\t\tR_LOG_ERROR (\"Register not found\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdelta = ri->index;\n\t\t\tisarg = true;\n\t\t\tr_unref (ri);\n\t\t} else {\n\t\t\tdelta = r_num_math (core->num, p);\n\t\t}\n\n\t\tchar *vartype = strchr (name, ' ');\n\t\tif (!vartype) {\n\t\t\tvartype = \"int\";\n\t\t} else {\n\t\t\t*vartype++ = 0;\n\t\t\tr_str_trim (vartype);\n\t\t}\n\t\tif (type == 'b') {\n\t\t\tdelta -= fcn->bp_off;\n\t\t}\n\t\tif ((type == 'b') && delta > 0) {\n\t\t\tisarg = true;\n\t\t} else if (type == 's' && delta > fcn->maxstack) {\n\t\t\tisarg = true;\n\t\t}\n\t\tr_anal_function_set_var (fcn, delta, type, vartype, size, isarg, name);\n \t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_afv);\n\t\tbreak;\n\t}\n\tfree (ostr);\n\treturn res;\n}\n\nstatic void print_trampolines(RCore *core, ut64 a, ut64 b, size_t element_size) {\n\tint i;\n\tfor (i = 0; i < core->blocksize; i += element_size) {\n\t\tut32 n;\n\t\tmemcpy (&n, core->block + i, sizeof (ut32));\n\t\tif (n >= a && n <= b) {\n\t\t\tif (element_size == 4) {\n\t\t\t\tr_cons_printf (\"f trampoline.%x @ 0x%\" PFMT64x \"\\n\", n, core->offset + i);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"f trampoline.%\" PFMT32x \" @ 0x%\" PFMT64x \"\\n\", n, core->offset + i);\n\t\t\t}\n\t\t\tr_cons_printf (\"Cd %u @ 0x%\" PFMT64x \":%u\\n\", (unsigned int)element_size, core->offset + i, (unsigned int)element_size);\n\t\t\t// TODO: add data xrefs\n\t\t}\n\t}\n}\n\nstatic void cmd_anal_trampoline(RCore *core, const char *input) {\n\tint bits = r_config_get_i (core->config, \"asm.bits\");\n\tchar *p, *inp = strdup (input);\n\tp = strchr (inp, ' ');\n\tif (p) {\n\t\t*p = 0;\n\t}\n\tut64 a = r_num_math (core->num, inp);\n\tut64 b = p? r_num_math (core->num, p + 1): 0;\n\tfree (inp);\n\n\tswitch (bits) {\n\tcase 32:\n\t\tprint_trampolines (core, a, b, 4);\n\t\tbreak;\n\tcase 64:\n\t\tprint_trampolines (core, a, b, 8);\n\t\tbreak;\n\t}\n}\n\nstatic const char *syscallNumber(char *snstr, int n) {\n\tsnprintf (snstr, 32, (n>1000)?\"0x%x\": \"%d\", n);\n\treturn snstr;\n}\n\nR_API char *cmd_syscall_dostr(RCore *core, st64 n, ut64 addr) {\n\tint i;\n\tchar str[64], snstr[32];\n\tst64 N = n;\n\tint defVector = r_syscall_get_swi (core->anal->syscall);\n\tif (defVector > 0) {\n\t\tn = -1;\n\t}\n\tif (n == -1 || defVector > 0) {\n\t\tn = (int)r_debug_reg_get (core->dbg, \"oeax\");\n\t\tif (!n || n == -1) {\n\t\t\tconst char *a0 = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n\t\t\tn = (a0 == NULL)? -1: (int)r_debug_reg_get (core->dbg, a0);\n\t\t}\n\t}\n\tRSyscallItem *item = r_syscall_get (core->anal->syscall, n, defVector);\n\tif (!item) {\n\t\titem =  r_syscall_get (core->anal->syscall, N, -1);\n\t}\n\tif (!item) {\n\t\treturn r_str_newf (\"%s = unknown ()\", syscallNumber (snstr, n));\n\t}\n\tchar *res = r_str_newf (\"%s = %s (\", syscallNumber (snstr, item->num), item->name);\n\t// TODO: move this to r_syscall\n\tconst char *cc = r_anal_syscc_default (core->anal);\n\t//TODO replace the hardcoded CC with the sdb ones\n\tfor (i = 0; i < item->args; i++) {\n\t\t// XXX this is a hack to make syscall args work on x86-32 and x86-64\n\t\t// we need to shift sn first.. which is bad, but needs to be redesigned\n\t\tint regidx = i;\n\t\tif (core->rasm->config->bits == 32 && !strcmp (core->rasm->config->arch, \"x86\")) {\n\t\t\tregidx++;\n\t\t}\n\t\tut64 arg = r_debug_arg_get (core->dbg, cc, regidx);\n\t\t//r_cons_printf (\"(%d:0x%\"PFMT64x\")\\n\", i, arg);\n\t\tif (item->sargs) {\n\t\t\tswitch (item->sargs[i]) {\n\t\t\tcase 'p': // pointer\n\t\t\t\tres = r_str_appendf (res, \"0x%08\" PFMT64x, arg);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tres = r_str_appendf (res, \"%\" PFMT64u \"\", arg);\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tmemset (str, 0, sizeof (str));\n\t\t\t\tr_io_read_at (core->io, arg, (ut8 *)str, sizeof (str) - 1);\n\t\t\t\tr_str_filter (str, strlen (str));\n\t\t\t\tres = r_str_appendf (res, \"\\\"%s\\\"\", str);\n\t\t\t\tbreak;\n\t\t\tcase 'Z': {\n\t\t\t\t//TODO replace the hardcoded CC with the sdb ones\n\t\t\t\tut64 len = r_debug_arg_get (core->dbg, cc, i + 2);\n\t\t\t\tlen = R_MIN (len + 1, sizeof (str) - 1);\n\t\t\t\tif (len == 0) {\n\t\t\t\t\tlen = 16; // override default\n\t\t\t\t}\n\t\t\t\t(void)r_io_read_at (core->io, arg, (ut8 *)str, len);\n\t\t\t\tstr[len] = 0;\n\t\t\t\tr_str_filter (str, -1);\n\t\t\t\tres = r_str_appendf (res, \"\\\"%s\\\"\", str);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tres = r_str_appendf (res, \"0x%08\" PFMT64x, arg);\n\t\t\t}\n\t\t} else {\n\t\t\tres = r_str_appendf (res, \"0x%08\" PFMT64x, arg);\n\t\t}\n\t\tif (i + 1 < item->args) {\n\t\t\tres = r_str_append (res, \", \");\n\t\t}\n\t}\n\tr_syscall_item_free (item);\n\treturn r_str_append (res, \")\");\n}\n\nstatic bool mw(REsil *esil, ut64 addr, const ut8 *buf, int len) {\n\tint *ec = (int*)esil->user;\n\t*ec += (len * 2);\n\treturn true;\n}\n\nstatic bool mr(REsil *esil, ut64 addr, ut8 *buf, int len) {\n\tint *ec = (int*)esil->user;\n\t*ec += len;\n\treturn true;\n}\n\nstatic int esil_cost(RCore *core, ut64 addr, const char *expr) {\n\tif (R_STR_ISEMPTY (expr)) {\n\t\treturn 0;\n\t}\n\tint ec = 0;\n\tREsil *e = r_esil_new (256, 0, 0);\n\tr_esil_setup (e, core->anal, false, false, false);\n\te->user = &ec;\n\te->cb.mem_read = mr;\n\te->cb.mem_write = mw;\n\tr_esil_parse (e, expr);\n\tr_esil_free (e);\n\treturn ec;\n}\n\nstatic void cmd_syscall_do(RCore *core, st64 n, ut64 addr) {\n\tchar *msg = cmd_syscall_dostr (core, n, addr);\n\tif (msg) {\n\t\tr_cons_println (msg);\n\t\tfree (msg);\n\t}\n}\n\nstatic inline REsil *esil_new_setup(RCore *core) {\n\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\tbool iotrap = r_config_get_b (core->config, \"esil.iotrap\");\n\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\tREsil *esil = r_esil_new (stacksize, iotrap, addrsize);\n\tif (esil) {\n\t\tesil->anal = core->anal;\n\t\tr_io_bind (core->io, &(core->anal->iob));\n\t\tbool romem = r_config_get_b (core->config, \"esil.romem\");\n\t\tbool stats = r_config_get_b (core->config, \"esil.stats\");\n\t\tbool nonull = r_config_get_b (core->config, \"esil.nonull\");\n\t\tr_esil_setup (esil, core->anal, romem, stats, nonull);\n\t\tesil->verbose = r_config_get_i (core->config, \"esil.verbose\");\n\t\tesil->cmd = r_core_esil_cmd;\n\t\tconst char *et = r_config_get (core->config, \"cmd.esil.trap\");\n\t\tesil->cmd_trap = R_STR_ISNOTEMPTY (et)? strdup (et): NULL;\n\n\t}\n\treturn esil;\n}\n\nstatic void val_tojson(PJ *pj, RAnalValue *val) {\n\tchar *s = r_anal_value_tostring (val);\n\tpj_o (pj);\n\tpj_ks (pj, \"name\", s);\n\tfree (s);\n\tpj_ks (pj, \"type\", r_anal_value_type_tostring (val));\n\tif (val->access) {\n\t\tpj_ks (pj, \"access\", (val->access & R_PERM_W)? \"rw\": \"ro\");\n\t}\n\tif (val->absolute) {\n\t\tpj_kn (pj, \"absolute\", val->absolute);\n\t}\n\tif (val->imm) {\n\t\tpj_kn (pj, \"imm\", val->imm);\n\t}\n\tif (val->delta) {\n\t\tpj_kn (pj, \"delta\", val->delta);\n\t}\n\tif (val->mul) {\n\t\tpj_kn (pj, \"mul\", val->mul);\n\t}\n\tpj_end (pj);\n}\n\n\nstatic bool mw2(REsil *esil, ut64 addr, const ut8 *buf, int len) {\n\tr_cons_printf (\"WRITE 0x%08\"PFMT64x\" %d\\n\", addr, len);\n\treturn true;\n}\n\nstatic bool mr2(REsil *esil, ut64 addr, ut8 *buf, int len) {\n\tr_cons_printf (\"READ 0x%08\"PFMT64x\" %d\\n\", addr, len);\n\treturn true;\n}\n\nstatic void esilmemrefs(RCore *core, const char *expr) {\n\tREsil *e = r_esil_new (256, 0, 0);\n\tr_esil_setup (e, core->anal, false, false, false);\n\te->cb.mem_read = mr2;\n\te->cb.mem_write = mw2;\n\tr_esil_parse (e, expr);\n\tr_esil_free (e);\n}\n\nstatic void core_anal_bytes(RCore *core, const ut8 *buf, int len, int nops, int fmt) {\n\tbool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->rasm->config);\n\tbool use_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\tcore->parser->subrel = r_config_get_i (core->config, \"asm.sub.rel\");\n\tint ret, i, j, idx, size;\n\tconst char *color = \"\";\n\tconst char *esilstr;\n\tconst char *opexstr;\n\tRAnalHint *hint;\n\tRAnalOp op = {0};\n\tut64 addr;\n\tPJ *pj = NULL;\n\tint totalsize = 0;\n#if 1\n\tREsil *esil = r_esil_new (256, 0, 0);\n\tr_esil_setup (esil, core->anal, false, false, false);\n\tesil->user = &core;\n\tesil->cb.mem_read = mr;\n\tesil->cb.mem_write = mw;\n#else\n\tREsil *esil = core->anal->esil;\n\t//esil->user = &ec;\n\tesil->cb.mem_read = mr;\n\tesil->cb.mem_write = mw;\n#endif\n\n\t// Variables required for setting up ESIL to REIL conversion\n\tif (use_color) {\n\t\tcolor = core->cons->context->pal.label;\n\t}\n\tswitch (fmt) {\n\tcase 'j': {\n\t\tpj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\tbreak;\n\t\t}\n\t\tpj_a (pj);\n\t\tbreak;\n\t}\n\t}\n\tconst bool smart_mask = r_config_get_b (core->config, \"anal.mask\");\n\tfor (i = idx = ret = 0; idx < len && (!nops || (nops && i < nops)); i++, idx += ret) {\n\t\tRAnalOp asmop = {0};\n\t\taddr = core->offset + idx;\n\t\tr_asm_set_pc (core->rasm, addr);\n\t\thint = r_anal_hint_get (core->anal, addr);\n\t\tret = r_anal_op (core->anal, &op, addr, buf + idx, len - idx,\n\t\t\tR_ARCH_OP_MASK_ESIL | R_ARCH_OP_MASK_OPEX | R_ARCH_OP_MASK_HINT | R_ARCH_OP_MASK_DISASM);\n\t\t(void)r_asm_disassemble (core->rasm, &asmop, buf + idx, len - idx);\n\t\tesilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\topexstr = R_STRBUF_SAFEGET (&op.opex);\n\t\tchar *mnem = strdup (r_str_get (r_asm_op_get_asm (&asmop)));\n\t\tchar *sp = strchr (mnem, ' ');\n\t\tif (sp) {\n\t\t\t*sp = 0;\n\t\t\tif (op.prefix) {\n\t\t\t\tchar *arg = strdup (sp + 1);\n\t\t\t\tchar *sp = strchr (arg, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\t*sp = 0;\n\t\t\t\t}\n\t\t\t\tfree (mnem);\n\t\t\t\tmnem = arg;\n\t\t\t}\n\t\t}\n\t\tif (ret < 1 && fmt != 'd') {\n\t\t\tret = op.size;\n#if 0\n\t\t\tRStrBuf *sb = r_strbuf_new (\"\");\n\t\t\tfor (i = idx, j = 0; i < core->blocksize && j < 3; i++, j++) {\n\t\t\t\tr_strbuf_appendf (sb, \"%02x \", buf[i]);\n\t\t\t}\n\t\t\tR_LOG_ERROR (\"Oops at 0x%08\" PFMT64x \" (%s...)\", core->offset + idx, r_strbuf_get (sb));\n\t\t\tr_strbuf_free (sb);\n\t\t\tfree (mnem);\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tsize = op.size;\n\t\tif (fmt == 'd') {\n\t\t\tchar *opname = strdup (r_asm_op_get_asm (&asmop));\n\t\t\tif (opname) {\n\t\t\t\tr_str_split (opname, ' ');\n\t\t\t\tchar *d = r_asm_describe (core->rasm, opname);\n\t\t\t\tif (R_STR_ISNOTEMPTY (d)) {\n\t\t\t\t\tr_cons_printf (\"%s: %s\\n\", opname, d);\n\t\t\t\t\tfree (d);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Unknown opcode at 0x%08\"PFMT64x, addr);\n\t\t\t\t}\n\t\t\t\tfree (opname);\n\t\t\t}\n\t\t} else if (fmt == 'm') {\n\t\t\tesilmemrefs (core, esilstr);\n\t\t} else if (fmt == 'E') {\n\t\t\tr_cons_printf (\"%s\\n\", esilstr);\n\t\t} else if (fmt == 'e') {\n\t\t\tif (R_STR_ISNOTEMPTY (esilstr)) {\n\t\t\t\tif (use_color) {\n\t\t\t\t\tr_cons_printf (\"%s0x%\" PFMT64x Color_RESET \" %s\\n\", color, core->offset + idx, esilstr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \" %s\\n\", core->offset + idx, esilstr);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (fmt == 's') {\n\t\t\ttotalsize += op.size;\n\t\t} else if (fmt == '*') {\n\t\t\t// TODO: ao* useful for wat? wx [bytes] ?\n\t\t} else if (fmt == 'j') {\n\t\t\tchar strsub[128] = {0};\n\t\t\t// pc+33\n\t\t\tr_parse_subvar (core->parser, NULL,\n\t\t\t\tcore->offset + idx,\n\t\t\t\tasmop.size, r_asm_op_get_asm (&asmop),\n\t\t\t\tstrsub, sizeof (strsub));\n\t\t\t\tut64 killme = UT64_MAX;\n\t\t\t\tif (r_io_read_i (core->io, op.ptr, &killme, op.refptr, be)) {\n\t\t\t\t\tcore->parser->subrel_addr = killme;\n\t\t\t\t}\n\t\t\t// 0x33->sym.xx\n\t\t\tchar *p = strdup (strsub);\n\t\t\tif (p) {\n\t\t\t\tr_parse_filter (core->parser, addr, core->flags, hint, p,\n\t\t\t\t\t\tstrsub, sizeof (strsub), be);\n\t\t\t\tfree (p);\n\t\t\t}\n\t\t\tpj_o (pj);\n\t\t\tpj_ks (pj, \"opcode\", r_asm_op_get_asm (&asmop));\n\t\t\tif (!*strsub) {\n\t\t\t\tr_str_ncpy (strsub, r_asm_op_get_asm (&asmop), sizeof (strsub) -1 );\n\t\t\t}\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_parse_subvar (core->parser, fcn, addr, asmop.size,\n\t\t\t\t\t\t\tstrsub, strsub, sizeof (strsub));\n\t\t\t\t}\n\t\t\t}\n\t\t\tpj_ks (pj, \"disasm\", strsub);\n\t\t\t// apply pseudo if needed\n\t\t\t{\n\t\t\t\tchar *pseudo = calloc (128 + strlen (strsub), 3);\n\t\t\t\tr_parse_parse (core->parser, strsub, pseudo);\n\t\t\t\tif (pseudo && *pseudo) {\n\t\t\t\t\tpj_ks (pj, \"pseudo\", pseudo);\n\t\t\t\t}\n\t\t\t\tfree (pseudo);\n\t\t\t}\n\t\t\t{\n\t\t\t\tchar *opname = strdup (strsub);\n\t\t\t\tchar *sp = strchr (opname, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\t*sp = 0;\n\t\t\t\t}\n\t\t\t\tchar *d = r_asm_describe (core->rasm, opname);\n\t\t\t\tif (d && *d) {\n\t\t\t\t\tpj_ks (pj, \"description\", d);\n\t\t\t\t}\n\t\t\t\tfree (d);\n\t\t\t\tfree (opname);\n\t\t\t}\n\n\t\t\tif (r_vector_length (&op.srcs) > 0) {\n\t\t\t\tpj_ka (pj, \"srcs\");\n\t\t\t\tRAnalValue *val;\n\t\t\t\tr_vector_foreach (&op.srcs, val) {\n\t\t\t\t\tval_tojson (pj, val);\n\t\t\t\t}\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\n\t\t\tif (r_vector_length (&op.dsts) > 0) {\n\t\t\t\tpj_ka (pj, \"dsts\");\n\t\t\t\tRAnalValue *val;\n\t\t\t\tr_vector_foreach (&op.dsts, val) {\n\t\t\t\t\tval_tojson (pj, val);\n\t\t\t\t}\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\n\t\t\tpj_ks (pj, \"mnemonic\", mnem);\n\t\t\tif (smart_mask) {\n\t\t\t\tchar *maskstr = r_core_cmd_strf (core, \"aobm@0x%08\"PFMT64x, op.addr);\n\t\t\t\tpj_ks (pj, \"mask\", maskstr);\n\t\t\t\tfree (maskstr);\n\t\t\t} else {\n\t\t\t\tut8 *mask = r_anal_mask (core->anal, len - idx, buf + idx, core->offset + idx);\n\t\t\t\tchar *maskstr = r_hex_bin2strdup (mask, size);\n\t\t\t\tpj_ks (pj, \"mask\", maskstr);\n\t\t\t\tfree (mask);\n\t\t\t\tfree (maskstr);\n\t\t\t}\n\t\t\tif (hint && hint->opcode) {\n\t\t\t\tpj_ks (pj, \"ophint\", hint->opcode);\n\t\t\t}\n\t\t\tif (hint && hint->jump != UT64_MAX) {\n\t\t\t\top.jump = hint->jump;\n\t\t\t}\n\t\t\tif (hint && hint->fail != UT64_MAX) {\n\t\t\t\top.fail = hint->fail;\n\t\t\t}\n\t\t\tif (op.jump != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"jump\", op.jump);\n\t\t\t}\n\t\t\tif (op.fail != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"fail\", op.fail);\n\t\t\t}\n\t\t\tconst char *jesil = (hint && hint->esil) ? hint->esil: esilstr;\n\t\t\tif (jesil && *jesil) {\n\t\t\t\tpj_ks (pj, \"esil\", jesil);\n\t\t\t}\n\t\t\tpj_kb (pj, \"sign\", op.sign);\n\t\t\tif (op.prefix > 0) {\n\t\t\t\tpj_kn (pj, \"prefix\", op.prefix);\n\t\t\t}\n\t\t\tpj_ki (pj, \"id\", op.id);\n\t\t\tif (op.vliw > 0) {\n\t\t\t\tpj_ki (pj, \"id\", op.vliw);\n\t\t\t}\n\t\t\tif (opexstr && *opexstr) {\n\t\t\t\tpj_k (pj, \"opex\");\n\t\t\t\tpj_j (pj, opexstr);\n\t\t\t}\n\t\t\tpj_kn (pj, \"addr\", core->offset + idx);\n\t\t\t{\n\t\t\t\tchar *bytes = r_hex_bin2strdup (buf + idx, size);\n\t\t\t\tpj_ks (pj, \"bytes\", bytes);\n\t\t\t\tfree (bytes);\n\t\t\t}\n\t\t\tif (op.val != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"val\", op.val);\n\t\t\t}\n\t\t\tif (op.disp && op.disp != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"disp\", op.disp);\n\t\t\t}\n\t\t\tif (op.ptr != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"ptr\", op.ptr);\n\t\t\t}\n\t\t\tpj_ki (pj, \"size\", size);\n\t\t\tpj_ks (pj, \"type\", r_anal_optype_tostring (op.type));\n\t\t\t{\n\t\t\t\tconst char *datatype = r_anal_datatype_tostring (op.datatype);\n\t\t\t\tif (datatype) {\n\t\t\t\t\tpj_ks (pj, \"datatype\", datatype);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (esilstr) {\n\t\t\t\tint ec = esil_cost (core, addr, esilstr);\n\t\t\t\tpj_ki (pj, \"esilcost\", ec);\n\t\t\t}\n\t\t\tif (op.reg) {\n\t\t\t\tpj_ks (pj, \"reg\", op.reg);\n\t\t\t}\n\t\t\tif (op.ireg) {\n\t\t\t\tpj_ks (pj, \"ireg\", op.ireg);\n\t\t\t}\n\t\t\tif (op.scale > 0) {\n\t\t\t\tpj_ki (pj, \"scale\", op.scale);\n\t\t\t}\n\t\t\tif (op.refptr != -1 && op.refptr > 0) {\n\t\t\t\tpj_ki (pj, \"refptr\", op.refptr);\n\t\t\t}\n\t\t\tpj_ki (pj, \"cycles\", op.cycles);\n\t\t\tpj_ki (pj, \"failcycles\", op.failcycles);\n\t\t\tpj_ki (pj, \"delay\", op.delay);\n\t\t\tconst char *p1 = r_anal_stackop_tostring (op.stackop);\n\t\t\tif (strcmp (p1, \"null\")) {\n\t\t\t\tpj_ks (pj, \"stack\", p1);\n\t\t\t}\n\t\t\tpj_kn (pj, \"stackptr\", op.stackptr);\n\t\t\tif (op.direction != 0) {\n\t\t\t\tpj_ks (pj, \"direction\", r_anal_op_direction_tostring (&op));\n\t\t\t}\n\t\t\tconst char *arg = (op.type & R_ANAL_OP_TYPE_COND)\n\t\t\t\t? r_anal_cond_type_tostring (op.cond): NULL;\n\t\t\tif (arg) {\n\t\t\t\tpj_ks (pj, \"cond\", arg);\n\t\t\t}\n\t\t\tpj_ks (pj, \"family\", r_anal_op_family_tostring (op.family));\n\t\t\tpj_end (pj);\n\t\t} else if (fmt == 'r') {\n\t\t\tif (R_STR_ISNOTEMPTY (esilstr)) {\n\t\t\t\tif (use_color) {\n\t\t\t\t\tr_cons_printf (\"%s0x%\" PFMT64x Color_RESET \" %s\\n\", color, core->offset + idx, esilstr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \" %s\\n\", core->offset + idx, esilstr);\n\t\t\t\t}\n\t\t\t\tr_esil_parse (core->anal->esil, esilstr);\n\t\t\t\tr_esil_dumpstack (core->anal->esil);\n\t\t\t\tr_esil_stack_free (core->anal->esil);\n\t\t\t} else {\n\t\t\t\t// ignored/skipped eprintf (\"No esil for '%s'\\n\", op.mnemonic);\n\t\t\t}\n\t\t} else {\n\t\t\tchar disasm[128] = {0};\n\t\t\tchar *text = r_asm_op_get_asm (&asmop);\n\t\t\tif (!text) {\n\t\t\t\tR_LOG_ERROR (\"invalid\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_parse_subvar (core->parser, NULL,\n\t\t\t\tcore->offset + idx,\n\t\t\t\tasmop.size,  text,\n\t\t\t\tdisasm, sizeof (disasm));\n\t\t\tut64 killme = UT64_MAX;\n\t\t\tif (r_io_read_i (core->io, op.ptr, &killme, op.refptr, be)) {\n\t\t\t\tcore->parser->subrel_addr = killme;\n\t\t\t}\n\t\t\tchar *p = strdup (disasm);\n\t\t\tif (p) {\n\t\t\t\tr_parse_filter (core->parser, addr, core->flags, hint, p,\n\t\t\t\t\tdisasm, sizeof (disasm), be);\n\t\t\t\tfree (p);\n\t\t\t}\n#define printline(k, fmt, arg)\\\n\t{ \\\n\t\tif (use_color)\\\n\t\t\tr_cons_printf (\"%s%s: \" Color_RESET, color, k);\\\n\t\telse\\\n\t\t\tr_cons_printf (\"%s: \", k);\\\n\t\tif (fmt) r_cons_printf (fmt, arg);\\\n\t}\n\t\t\tprintline (\"address\", \"0x%\" PFMT64x \"\\n\", core->offset + idx);\n\t\t\tprintline (\"opcode\", \"%s\\n\", r_asm_op_get_asm (&asmop));\n\t\t\tif (!*disasm) {\n\t\t\t\tr_str_ncpy (disasm, r_asm_op_get_asm (&asmop), sizeof (disasm) - 1);\n\t\t\t}\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_parse_subvar (core->parser, fcn, addr, asmop.size,\n\t\t\t\t\t\t\tdisasm, disasm, sizeof (disasm));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (esilstr) {\n\t\t\t\tint ec = esil_cost (core, addr, esilstr);\n\t\t\t\tprintline (\"esilcost\", \"%d\\n\", ec);\n\t\t\t}\n\t\t\tprintline (\"disasm\", \"%s\\n\", disasm);\n\t\t\t{\n\t\t\t\tchar *pseudo = calloc (128 + strlen (disasm), 3);\n\t\t\t\tr_parse_parse (core->parser, disasm, pseudo);\n\t\t\t\tif (pseudo && *pseudo) {\n\t\t\t\t\tprintline (\"pseudo\", \"%s\\n\", pseudo);\n\t\t\t\t}\n\t\t\t\tfree (pseudo);\n\t\t\t}\n\t\t\tprintline (\"mnemonic\", \"%s\\n\", mnem);\n\t\t\t{\n\t\t\t\tchar *opname = strdup (disasm);\n\t\t\t\tchar *sp = strchr (opname, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\t*sp = 0;\n\t\t\t\t}\n\t\t\t\tchar *d = r_asm_describe (core->rasm, opname);\n\t\t\t\tif (d && *d) {\n\t\t\t\t\tprintline (\"description\", \"%s\\n\", d);\n\t\t\t\t}\n\t\t\t\tfree (d);\n\t\t\t\tfree (opname);\n\t\t\t}\n\t\t\t{\n\t\t\t\tut8 *mask = r_anal_mask (core->anal, len - idx, buf + idx, core->offset + idx);\n\t\t\t\tif (smart_mask) {\n\t\t\t\t\tchar *maskstr = r_core_cmd_strf (core, \"aobm@0x%08\"PFMT64x, op.addr);\n\t\t\t\t\tr_str_trim (maskstr);\n\t\t\t\t\tprintline (\"mask\", \"%s\\n\", maskstr);\n\t\t\t\t\tfree (maskstr);\n\t\t\t\t} else {\n\t\t\t\t\tchar *maskstr = r_hex_bin2strdup (mask, size);\n\t\t\t\t\tprintline (\"mask\", \"%s\\n\", maskstr);\n\t\t\t\t\tfree (maskstr);\n\t\t\t\t}\n\t\t\t\tfree (mask);\n\t\t\t}\n\t\t\tif (hint) {\n\t\t\t\tif (hint->opcode) {\n\t\t\t\t\tprintline (\"ophint\", \"%s\\n\", hint->opcode);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op.prefix > 0) {\n\t\t\t\tprintline (\"prefix\", \"%u\\n\", op.prefix);\n\t\t\t}\n\t\t\tprintline (\"id\", \"%d\\n\", op.id);\n\t\t\tif (op.vliw > 0) {\n\t\t\t\tprintline (\"id\", \"%d\\n\", op.vliw);\n\t\t\t}\n#if 0\n// no opex here to avoid lot of tests broken..and having json in here is not much useful imho\n\t\t\tif (R_STR_ISNOTEMPTY (opexstr)) {\n\t\t\t\tprintline (\"opex\", \"%s\\n\", opexstr);\n\t\t\t}\n#endif\n\t\t\tprintline (\"bytes\", \"%s\", \"\");\n\t\t\tint minsz = R_MIN (len, size);\n\t\t\tminsz = R_MAX (minsz, 0);\n\t\t\tfor (j = 0; j < minsz; j++) {\n\t\t\t\tr_cons_printf (\"%02x\", buf[idx + j]);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tif (op.val != UT64_MAX) {\n\t\t\t\tprintline (\"val\", \"0x%08\" PFMT64x \"\\n\", op.val);\n\t\t\t}\n\t\t\tif (op.ptr != UT64_MAX) {\n\t\t\t\tprintline (\"ptr\", \"0x%08\" PFMT64x \"\\n\", op.ptr);\n\t\t\t}\n\t\t\tif (op.disp && op.disp != UT64_MAX) {\n\t\t\t\t// printline (\"disp\", \"0x%08\" PFMT64x \"\\n\", op.disp);\n\t\t\t\tprintline (\"disp\", \"%\" PFMT64d \"\\n\", op.disp);\n\t\t\t}\n\t\t\tif (op.refptr != -1 && op.refptr > 0) {\n\t\t\t\tprintline (\"refptr\", \"%d\\n\", op.refptr);\n\t\t\t}\n\t\t\tprintline (\"size\", \"%d\\n\", size);\n\t\t\tprintline (\"sign\", \"%s\\n\", r_str_bool (op.sign));\n\t\t\tprintline (\"type\", \"%s\\n\", r_anal_optype_tostring (op.type));\n\t\t\tconst char *datatype = r_anal_datatype_tostring (op.datatype);\n\t\t\tif (datatype) {\n\t\t\t\tprintline (\"datatype\", \"%s\\n\", datatype);\n\t\t\t}\n\t\t\tprintline (\"cycles\", \"%d\\n\", op.cycles);\n\t\t\tif (op.failcycles) {\n\t\t\t\tprintline (\"failcycles\", \"%d\\n\", op.failcycles);\n\t\t\t}\n\t\t\tif (op.type2) {\n\t\t\t\tprintline (\"type2\", \"0x%x\\n\", op.type2);\n\t\t\t}\n\t\t\tif (op.reg) {\n\t\t\t\tprintline (\"reg\", \"%s\\n\", op.reg);\n\t\t\t}\n\t\t\tif (op.ireg) {\n\t\t\t\tprintline (\"ireg\", \"%s\\n\", op.ireg);\n\t\t\t}\n\t\t\tif (op.scale > 0) {\n\t\t\t\tprintline (\"scale\", \"%d\\n\", op.scale);\n\t\t\t}\n\t\t\tif (hint && hint->esil) {\n\t\t\t\tprintline (\"esil\", \"%s\\n\", hint->esil);\n\t\t\t} else if (R_STR_ISNOTEMPTY (esilstr)) {\n\t\t\t\tprintline (\"esil\", \"%s\\n\", esilstr);\n\t\t\t}\n\t\t\tif (hint && hint->jump != UT64_MAX) {\n\t\t\t\top.jump = hint->jump;\n\t\t\t}\n\t\t\tif (op.jump != UT64_MAX) {\n\t\t\t\tprintline (\"jump\", \"0x%08\" PFMT64x \"\\n\", op.jump);\n\t\t\t}\n\t\t\tif (op.direction != 0) {\n\t\t\t\tprintline (\"direction\", \"%s\\n\", r_anal_op_direction_tostring (&op));\n\t\t\t}\n\t\t\tif (hint && hint->fail != UT64_MAX) {\n\t\t\t\top.fail = hint->fail;\n\t\t\t}\n\t\t\tif (op.fail != UT64_MAX) {\n\t\t\t\tprintline (\"fail\", \"0x%08\" PFMT64x \"\\n\", op.fail);\n\t\t\t}\n\t\t\tif (op.delay) {\n\t\t\t\tprintline (\"delay\", \"%d\\n\", op.delay);\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst char *arg = (op.type & R_ANAL_OP_TYPE_COND)?  r_anal_cond_type_tostring (op.cond): NULL;\n\t\t\t\tif (arg) {\n\t\t\t\t\tprintline (\"cond\", \"%s\\n\", arg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintline (\"family\", \"%s\\n\", r_anal_op_family_tostring (op.family));\n\t\t\tif (op.stackop != R_ANAL_STACK_NULL) {\n\t\t\t\tprintline (\"stackop\", \"%s\\n\", r_anal_stackop_tostring (op.stackop));\n\t\t\t}\n\t\t\tif (op.stackptr) {\n\t\t\t\tprintline (\"stackptr\", \"%\"PFMT64u\"\\n\", op.stackptr);\n\t\t\t}\n\t\t}\n\t\t//r_cons_printf (\"false: 0x%08\"PFMT64x\"\\n\", core->offset+idx);\n\t\t//free (hint);\n\t\tfree (mnem);\n\t\tr_anal_hint_free (hint);\n\t\tr_anal_op_fini (&op);\n\t\tr_asm_op_fini (&asmop);\n\t}\n\tr_anal_op_fini (&op);\n\tif (fmt == 's') {\n\t\tr_cons_printf (\"%d\\n\", totalsize);\n\t} else if (fmt == 'j') {\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\tr_esil_free (esil);\n}\n\nstatic int bb_cmp(const void *a, const void *b) {\n\tconst RAnalBlock *ba = a;\n\tconst RAnalBlock *bb = b;\n\treturn ba->addr - bb->addr;\n}\n\nstatic ut64 caseval(const void* _a) {\n\tconst RAnalCaseOp* a = _a;\n\treturn a->addr;\n}\n\nstatic ut64 __opaddr(const RAnalBlock *b, ut64 addr) {\n\tint i;\n\tif (addr >= b->addr && addr < (b->addr + b->size)) {\n\t\tfor (i = 0; i < b->ninstr; i++) {\n\t\t\tut64 aa = b->addr + r_anal_bb_offset_inst (b, i);\n\t\t\tut64 ab = b->addr + r_anal_bb_offset_inst (b, i + 1);\n\t\t\tif (addr >= aa && addr < ab) {\n\t\t\t\treturn aa;\n\t\t\t}\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nstatic RVecUT64 *get_xrefs(RAnalBlock *block) {\n\tRVecUT64 *result = RVecUT64_new ();\n\n\tsize_t i;\n\tfor (i = 0; i < block->ninstr; i++) {\n\t\tconst ut64 ia = block->addr + block->op_pos[i];\n\t\tRVecAnalRef *xrefs = r_anal_xrefs_get (block->anal, ia);\n\t\tif (xrefs) {\n\t\t\tRAnalRef *ref;\n\t\t\tR_VEC_FOREACH (xrefs, ref) {\n\t\t\t\tut64 *addr = RVecUT64_emplace_back (result);\n\t\t\t\tif (R_UNLIKELY (!addr)) {\n\t\t\t\t\tRVecUT64_free (result);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\t*addr = ref->addr;\n\t\t\t}\n\t\t}\n\n\t\tRVecAnalRef_free (xrefs);\n\t}\n\n\treturn result;\n}\n\nstatic char *fcnjoin(RList *list) {\n\tRAnalFunction *n;\n\tRListIter *iter;\n\tRStrBuf buf;\n\tr_strbuf_init (&buf);\n\tr_list_foreach (list, iter, n) {\n\t\tr_strbuf_appendf (&buf, \" 0x%08\" PFMT64x, n->addr);\n\t}\n\tchar *s = strdup (r_strbuf_get (&buf));\n\tr_strbuf_fini (&buf);\n\treturn s;\n}\n\nstatic char *ut64join(RList *list) {\n\tut64 *n;\n\tRListIter *iter;\n\tRStrBuf buf;\n\tr_strbuf_init (&buf);\n\tr_list_foreach (list, iter, n) {\n\t\tr_strbuf_appendf (&buf, \" 0x%08\" PFMT64x, *n);\n\t}\n\tchar *s = strdup (r_strbuf_get (&buf));\n\tr_strbuf_fini (&buf);\n\treturn s;\n}\n\nstatic RList *get_calls(RAnalBlock *block) {\n\tRList *list = NULL;\n\tRAnalOp op;\n\tut8 *data = malloc (block->size);\n\tif (data) {\n\t\tblock->anal->iob.read_at (block->anal->iob.io, block->addr, data, block->size);\n\t\tsize_t i;\n\t\tfor (i = 0; i < block->size; i++) {\n\t\t\tint ret = r_anal_op (block->anal, &op, block->addr + i, data + i, block->size - i, R_ARCH_OP_MASK_HINT);\n\t\t\tif (ret < 1) {\n\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (op.type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\tif (!list) {\n\t\t\t\t\tlist = r_list_newf (free);\n\t\t\t\t}\n\t\t\t\tr_list_push (list, ut64_new (op.jump));\n\t\t\t}\n\t\t\tr_anal_op_fini (&op);\n\t\t\tif (op.size > 0) {\n\t\t\t\ti += op.size - 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree (data);\n\treturn list;\n}\n\nstatic void anal_bb_list(RCore *core, const char *input) {\n\tconst int mode = *input;\n\tPJ *pj = NULL;\n\tRTable *table = NULL;\n\tRBIter iter;\n\tRAnalBlock *block;\n\tif (mode == 'c') {\n\t\tut64 count = 0;\n\t\tr_rbtree_foreach (core->anal->bb_tree, iter, block, RAnalBlock, _rb) {\n\t\t\tcount++;\n\t\t}\n\t\tr_cons_printf (\"%\"PFMT64d\"\\n\", count);\n\t\treturn;\n\t}\n\tif (mode == 'j') {\n\t\tpj = pj_new ();\n\t\tpj_o (pj);\n\t\tpj_ka (pj, \"blocks\");\n\t} else if (mode == ',' || mode == 't') {\n\t\ttable = r_table_new (\"bbs\");\n\t\tRTableColumnType *s = r_table_type (\"string\");\n\t\tRTableColumnType *n = r_table_type (\"number\");\n\t\tr_table_add_column (table, n, \"addr\", 0);\n\t\tr_table_add_column (table, n, \"size\", 0);\n\t\tr_table_add_column (table, n, \"traced\", 0);\n\t\tr_table_add_column (table, n, \"ninstr\", 0);\n\t\tr_table_add_column (table, s, \"jump\", 0);\n\t\tr_table_add_column (table, s, \"fail\", 0);\n\t\tr_table_add_column (table, s, \"fcns\", 0);\n\t\tr_table_add_column (table, s, \"calls\", 0);\n\t\tr_table_add_column (table, s, \"xrefs\", 0);\n\t}\n\n\tr_rbtree_foreach (core->anal->bb_tree, iter, block, RAnalBlock, _rb) {\n\t\tRVecUT64 *xrefs = get_xrefs (block);\n\t\tRList *calls = get_calls (block);\n\t\tswitch (mode) {\n\t\tcase 'j':\n\t\t\tpj_o (pj);\n\t\t\tchar *addr = r_str_newf (\"0x%\" PFMT64x, block->addr);\n\t\t\tpj_ks (pj, \"addr\", addr);\n\t\t\tfree (addr);\n\t\t\tpj_kn (pj, \"traced\", block->traced);\n\t\t\tpj_kn (pj, \"ninstr\", block->ninstr);\n\t\t\tpj_kn (pj, \"size\", block->size);\n\t\t\tif (block->jump != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"jump\", block->jump);\n\t\t\t}\n\t\t\tif (block->fail != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"fail\", block->fail);\n\t\t\t}\n\t\t\tif (xrefs) {\n\t\t\t\tpj_ka (pj, \"xrefs\");\n\t\t\t\tut64 *addr;\n\t\t\t\tR_VEC_FOREACH (xrefs, addr) {\n\t\t\t\t\tpj_n (pj, *addr);\n\t\t\t\t}\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tif (calls) {\n\t\t\t\tpj_ka (pj, \"calls\");\n\t\t\t\tRListIter *iter2;\n\t\t\t\tut64 *addr;\n\t\t\t\tr_list_foreach (calls, iter2, addr) {\n\t\t\t\t\tpj_n (pj, *addr);\n\t\t\t\t}\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tpj_ka (pj, \"fcns\");\n\t\t\tRListIter *iter2;\n\t\t\tRAnalFunction *fcn;\n\t\t\tr_list_foreach (block->fcns, iter2, fcn) {\n\t\t\t\tpj_n (pj, fcn->addr);\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t\tbreak;\n\t\tcase ',':\n\t\tcase 't':\n\t\t\t{\n\t\t\t\tchar *jump = block->jump != UT64_MAX? r_str_newf (\"0x%08\" PFMT64x, block->jump): strdup (\"\");\n\t\t\t\tchar *fail = block->fail != UT64_MAX? r_str_newf (\"0x%08\" PFMT64x, block->fail): strdup (\"\");\n\t\t\t\tchar *call = ut64join (calls);\n\t\t\t\tchar *xref = ut64join (calls);\n\t\t\t\tchar *fcns = fcnjoin (block->fcns);\n\t\t\t\tr_table_add_rowf (table, \"xnddsssss\",\n\t\t\t\t\tblock->addr,\n\t\t\t\t\tblock->size,\n\t\t\t\t\tblock->traced,\n\t\t\t\t\tblock->ninstr,\n\t\t\t\t\tjump,\n\t\t\t\t\tfail,\n\t\t\t\t\tfcns,\n\t\t\t\t\tcall,\n\t\t\t\t\txref\n\t\t\t\t);\n\t\t\t\tfree (jump);\n\t\t\t\tfree (fail);\n\t\t\t\tfree (call);\n\t\t\t\tfree (xref);\n\t\t\t\tfree (fcns);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x\"\\n\", block->addr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x , block->addr);\n\t\t\tif (block->jump != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" jump=0x%08\" PFMT64x, block->jump);\n\t\t\t}\n\t\t\tif (block->fail != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" fail=0x%08\" PFMT64x, block->fail);\n\t\t\t}\n\t\t\tif (block->traced) {\n\t\t\t\tr_cons_printf (\" trace=0x%08\" PFMT64x, block->traced);\n\t\t\t}\n\t\t\tif (xrefs) {\n\t\t\t\tut64 *addr;\n\t\t\t\tR_VEC_FOREACH (xrefs, addr) {\n\t\t\t\t\tr_cons_printf (\" xref=0x%08\" PFMT64x, *addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (calls) {\n\t\t\t\tRListIter *iter2;\n\t\t\t\tut64 *addr;\n\t\t\t\tr_list_foreach (calls, iter2, addr) {\n\t\t\t\t\tr_cons_printf (\" call=0x%08\" PFMT64x, *addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (block->fcns) {\n\t\t\t\tRListIter *iter2;\n\t\t\t\tRAnalFunction *fcn;\n\t\t\t\tr_list_foreach (block->fcns, iter2, fcn) {\n\t\t\t\t\tr_cons_printf (\" func=0x%\" PFMT64x, fcn->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\" size=%\" PFMT64d \"\\n\", block->size);\n\t\t}\n\t\tr_list_free (calls);\n\t\tRVecUT64_free (xrefs);\n\t}\n\tif (mode == 'j') {\n\t\tpj_end (pj);\n\t\tpj_end (pj);\n\t\tchar *j = pj_drain (pj);\n\t\tr_cons_println (j);\n\t\tfree (j);\n\t} else if (mode == 't' || mode == ',') {\n\t\tchar *q = strchr (input, ' ');\n\t\tbool show_query = true;\n\t\tif (q) {\n\t\t\tshow_query = r_table_query (table, q + 1);\n\t\t}\n\t\tif (show_query) {\n\t\t\tchar *s = r_table_tofancystring (table);\n\t\t\tr_cons_println (s);\n\t\t\tfree (s);\n\t\t}\n\t\tr_table_free (table);\n\t}\n}\n\nstatic void print_bb(PJ *pj, const RAnalBlock *b, const RAnalFunction *fcn, const ut64 addr) {\n\tRListIter *iter2;\n\tRAnalBlock *b2;\n\tint outputs = (b->jump != UT64_MAX) + (b->fail != UT64_MAX);\n\tint inputs = 0;\n\tr_list_foreach (fcn->bbs, iter2, b2) {\n\t\tinputs += (b2->jump == b->addr) + (b2->fail == b->addr);\n\t}\n\tut64 opaddr = __opaddr (b, addr);\n\tif (pj) {\n\t\tpj_o (pj);\n\t\tpj_kn (pj, \"addr\", b->addr);\n\t\tpj_ki (pj, \"size\", b->size);\n\t\tif (b->jump != UT64_MAX) {\n\t\t\tpj_kn (pj, \"jump\", b->jump);\n\t\t}\n\t\tif (b->fail != UT64_MAX) {\n\t\t\tpj_kn (pj, \"fail\", b->fail);\n\t\t}\n\t\tif (b->switch_op) {\n\t\t\tpj_k (pj, \"switch_op\");\n\t\t\tpj_o (pj);\n\t\t\tpj_kn (pj, \"addr\", b->switch_op->addr);\n\t\t\tpj_kn (pj, \"min_val\", b->switch_op->min_val);\n\t\t\tpj_kn (pj, \"def_val\", b->switch_op->def_val);\n\t\t\tpj_kn (pj, \"max_val\", b->switch_op->max_val);\n\t\t\tpj_k (pj, \"cases\");\n\t\t\tpj_a (pj);\n\t\t\t{\n\t\t\tRListIter *case_op_iter;\n\t\t\tRAnalCaseOp *case_op;\n\t\t\tr_list_foreach (b->switch_op->cases, case_op_iter, case_op) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"addr\", case_op->addr);\n\t\t\t\tpj_kn (pj, \"jump\", case_op->jump);\n\t\t\t\tpj_kn (pj, \"value\", case_op->value);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_kn (pj, \"opaddr\", opaddr);\n\t\tpj_ki (pj, \"inputs\", inputs);\n\t\tpj_ki (pj, \"outputs\", outputs);\n\t\t{\n\t\t\tRColor k = b->color;\n\t\t\tif (k.r || k.g || k.b) {\n\t\t\t\tchar *s = r_str_newf (\"rgb:%x%x%x\",\n\t\t\t\t\t\t16 * k.r / 255,\n\t\t\t\t\t\t16 * k.g / 255,\n\t\t\t\t\t\t16 * k.b / 255);\n\t\t\t\tpj_ks (pj, \"color\", s);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t}\n\t\tpj_ki (pj, \"ninstr\", b->ninstr);\n\t\tpj_ka (pj, \"instrs\");\n\t\t{\n\t\t\tint i;\n\t\t\tfor (i = 0; i < b->ninstr; i++) {\n\t\t\t\tint delta = (i > 0)? b->op_pos[i - 1]: 0;\n\t\t\t\tpj_n (pj, b->addr + delta);\n\t\t\t}\n\t\t}\n\t\tpj_end (pj);\n\t\tpj_kn (pj, \"traced\", b->traced);\n\t\tpj_end (pj);\n\t} else {\n\t\tif (b->switch_op) {\n\t\t\tr_list_uniq_inplace (b->switch_op->cases, caseval);\n\t\t\toutputs += r_list_length (b->switch_op->cases);\n\t\t}\n\t\tif (b->jump != UT64_MAX) {\n\t\t\tr_cons_printf (\"jump: 0x%08\"PFMT64x\"\\n\", b->jump);\n\t\t}\n\t\tif (b->fail != UT64_MAX) {\n\t\t\tr_cons_printf (\"fail: 0x%08\"PFMT64x\"\\n\", b->fail);\n\t\t}\n\t\tr_cons_printf (\"opaddr: 0x%08\"PFMT64x\"\\n\", opaddr);\n\t\tr_cons_printf (\"addr: 0x%08\" PFMT64x \"\\nsize: %\" PFMT64d \"\\ninputs: %d\\noutputs: %d\\nninstr: %d\\ntraced: 0x%\"PFMT64x\"\\n\",\n\t\t\tb->addr, b->size, inputs, outputs, b->ninstr, b->traced);\n\t}\n}\n\nstatic bool anal_fcn_list_bb(RCore *core, const char *input, bool one) {\n\tRDebugTracepoint *tp = NULL;\n\tRListIter *iter;\n\tRAnalBlock *b;\n\tint mode = 0;\n\tut64 addr, bbaddr = UT64_MAX;\n\tPJ *pj = NULL;\n\n\tif (*input == '.') {\n\t\tone = true;\n\t\tinput++;\n\t}\n\tif (*input) {\n\t\tmode = *input;\n\t\tinput++;\n\t}\n\tif (*input == '.') {\n\t\tone = true;\n\t\tinput++;\n\t}\n\tif (R_STR_ISNOTEMPTY (input)) {\n\t\taddr = bbaddr = r_num_math (core->num, input);\n\t\tif (!addr && *input != '0') {\n\t\t\taddr = core->offset;\n\t\t}\n\t} else {\n\t\tbbaddr = addr = core->offset;\n\t}\n\tinput = r_str_trim_head_ro (input);\n\tif (one) {\n\t\tbbaddr = addr;\n\t}\n\tif (mode == 'j') {\n\t\tpj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\tr_cons_println (\"[]\");\n\t\t\treturn false;\n\t\t}\n\t\tpj_a (pj);\n\t}\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\tif (!fcn) {\n\t\tif (mode == 'j') {\n\t\t\tpj_end (pj);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t}\n\t\tif (mode == 'i' && input && *input == 'j') {\n\t\t\tr_cons_println (\"{}\");\n\t\t}\n\t\tR_LOG_ERROR (\"Cannot find function in 0x%08\"PFMT64x, addr);\n\t\treturn false;\n\t}\n\tif (mode == '*') {\n\t\tr_cons_printf (\"fs blocks\\n\");\n\t}\n\tif (fcn->bbs) {\n\t\tr_list_sort (fcn->bbs, bb_cmp);\n\t}\n\tif (mode == '=') { // afb\n\t\tRList *flist = r_list_newf ((RListFree) r_listinfo_free);\n\t\tif (!flist) {\n\t\t\treturn false;\n\t\t}\n\t\tls_foreach (fcn->bbs, iter, b) {\n\t\t\tRInterval inter = (RInterval) {b->addr, b->size};\n\t\t\tRListInfo *info = r_listinfo_new (NULL, inter, inter, -1, NULL);\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (flist, info);\n\t\t}\n\t\tRTable *table = r_core_table (core, \"fcnbbs\");\n\t\tif (!table) {\n\t\t\treturn false;\n\t\t}\n\t\tr_table_visual_list (table, flist, core->offset, core->blocksize,\n\t\t\tr_cons_get_size (NULL), r_config_get_i (core->config, \"scr.color\"));\n\t\tchar *s = r_table_tostring (table);\n\t\tr_cons_printf (\"\\n%s\\n\", s);\n\t\tfree (s);\n\t\tr_table_free (table);\n\t\tr_list_free (flist);\n\t\treturn true;\n\t}\n\n\tRTable *t = NULL;\n\tif (mode == 't') {\n\t\tt = r_table_new (\"fcnbbs\");\n\t\tr_table_set_columnsf (t, \"xdxx\", \"addr\", \"size\", \"jump\", \"fail\");\n\t}\n\tr_list_foreach (fcn->bbs, iter, b) {\n\t\tif (one) {\n\t\t\tif (bbaddr != UT64_MAX && (bbaddr < b->addr || bbaddr >= (b->addr + b->size))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tswitch (mode) {\n\t\tcase 't': // \"afbt\"\n\t\t\tr_table_add_rowf (t, \"xdxx\", b->addr, b->size, b->jump, b->fail);\n\t\t\tbreak;\n\t\tcase 'r': // \"afbr\"\n\t\t\tif (b->jump == UT64_MAX || r_anal_noreturn_at_addr (core->anal, b->jump)) {\n\t\t\t\tut64 retaddr = r_anal_bb_opaddr_i (b, b->ninstr - 1);\n\t\t\t\tif (retaddr == UT64_MAX) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (input, \"*\")) {\n\t\t\t\t\tr_cons_printf (\"db 0x%08\"PFMT64x\"\\n\", retaddr);\n\t\t\t\t} else if (!strcmp (input, \"-*\")) {\n\t\t\t\t\tr_cons_printf (\"db-0x%08\"PFMT64x\"\\n\", retaddr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", retaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tr_cons_printf (\"f bb.%05\" PFMT64x \" = 0x%08\" PFMT64x \"\\n\",\n\t\t\t\tb->addr & 0xFFFFF, b->addr);\n\t\t\tbreak;\n\t\tcase 'q': // \"afbq\"\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", b->addr);\n\t\t\tbreak;\n\t\tcase 'j': // \"afbj\"\n\t\t\tprint_bb (pj, b, fcn, addr);\n\t\t\tbreak;\n\t\tcase 'i': // \"afbi\"\n\t\t\tif (*input == 'j') { // \"afbij\"\n\t\t\t\tpj = r_core_pj_new (core);\n\t\t\t\tif (!pj) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tprint_bb (pj, b, fcn, addr);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t} else {\n\t\t\t\tprint_bb (NULL, b, fcn, addr);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttp = r_debug_trace_get (core->dbg, b->addr);\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" 0x%08\" PFMT64x \" %02X:%04X %\" PFMT64d,\n\t\t\t\tb->addr, b->addr + b->size,\n\t\t\t\ttp? tp->times: 0, tp? tp->count: 0,\n\t\t\t\tb->size);\n\t\t\tif (b->jump != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" j 0x%08\" PFMT64x, b->jump);\n\t\t\t}\n\t\t\tif (b->fail != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" f 0x%08\" PFMT64x, b->fail);\n\t\t\t}\n\t\t\tif (b->switch_op) {\n\t\t\t\tRAnalCaseOp *cop;\n\t\t\t\tRListIter *iter;\n\t\t\t\tr_list_uniq_inplace (b->switch_op->cases, caseval);\n\t\t\t\tr_list_foreach (b->switch_op->cases, iter, cop) {\n\t\t\t\t\tr_cons_printf (\" s 0x%08\" PFMT64x, cop->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode == 't') {\n\t\tconst char *arg = input;\n\t\tif (r_table_query (t, arg)) {\n\t\t\tchar *ts = r_table_tofancystring (t);\n\t\t\tr_cons_printf (\"%s\", ts);\n\t\t\tfree (ts);\n\t\t}\n\t\tr_table_free (t);\n\t} else if (mode == 'j') {\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\treturn true;\n}\n\nstatic bool anal_bb_edge(RCore *core, const char *input) {\n\t// \"afbe\" switch-bb-addr case-bb-addr\n\tchar *arg = strdup (r_str_trim_head_ro (input));\n\tchar *sp = strchr (arg, ' ');\n\tbool ret = false;\n\tif (sp) {\n\t\t*sp++ = 0;\n\t\tut64 switch_addr = r_num_math (core->num, arg);\n\t\tut64 case_addr = r_num_math (core->num, sp);\n\t\tRList *blocks = r_anal_get_blocks_in (core->anal, switch_addr);\n\t\tif (blocks && !r_list_empty (blocks)) {\n\t\t\tr_anal_block_add_switch_case (r_list_first (blocks), switch_addr, 0, case_addr);\n\t\t\tret = true;\n\t\t}\n\t\tr_list_free (blocks);\n\t}\n\tfree (arg);\n\treturn ret;\n}\n\nstatic bool anal_fcn_del_bb(RCore *core, const char *input) {\n\tut64 addr = r_num_math (core->num, input);\n\tif (!addr) {\n\t\taddr = core->offset;\n\t}\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, -1);\n\tif (fcn) {\n\t\tif (!strcmp (input, \"*\")) {\n\t\t\twhile (!r_list_empty (fcn->bbs)) {\n\t\t\t\tr_anal_function_remove_block (fcn, r_list_first (fcn->bbs));\n\t\t\t}\n\t\t} else {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tif (b->addr == addr) {\n\t\t\t\t\tr_anal_function_remove_block (fcn, b);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tR_LOG_ERROR (\"Cannot find basic block\");\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int cmd_afbplus(RCore *core, const char *input) {\n\t// fcn_addr bb_addr bb_size [jump] [fail]\n\tconst char *ptr2 = NULL;\n\tut64 fcnaddr = -1LL, addr = -1LL;\n\tut64 size = 0LL;\n\tut64 jump = UT64_MAX;\n\tut64 fail = UT64_MAX;\n\tRAnalFunction *fcn = NULL;\n\tRAnalDiff *diff = NULL;\n\n\tchar *ptr = r_str_trim_dup (input);\n\n\tswitch (r_str_word_set0 (ptr)) {\n\tcase 6:\n\t\tptr2 = r_str_word_get0 (ptr, 6);\n\t\tif (!(diff = r_anal_diff_new ())) {\n\t\t\tR_LOG_ERROR (\"Cannot init RAnalDiff\");\n\t\t\tfree (ptr);\n\t\t\treturn false;\n\t\t}\n\t\tif (ptr2[0] == 'm') {\n\t\t\tdiff->type = R_ANAL_DIFF_TYPE_MATCH;\n\t\t} else if (ptr2[0] == 'u') {\n\t\t\tdiff->type = R_ANAL_DIFF_TYPE_UNMATCH;\n\t\t}\n\tcase 5: // get fail\n\t\tfail = r_num_math (core->num, r_str_word_get0 (ptr, 4));\n\tcase 4: // get jump\n\t\tjump = r_num_math (core->num, r_str_word_get0 (ptr, 3));\n\tcase 3: // get size\n\t\tsize = r_num_math (core->num, r_str_word_get0 (ptr, 2));\n\tcase 2: // get addr\n\t\taddr = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\tcase 1: // get fcnaddr\n\t\tfcnaddr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t}\n\tfcn = r_anal_get_function_at (core->anal, fcnaddr);\n\tif (fcn && size > 0) {\n\t\tif (!r_anal_function_add_bb (core->anal, fcn, addr, size, jump, fail, diff)) {\n\t\t\tR_LOG_ERROR (\"afb+: Cannot add basic block at 0x%08\"PFMT64x\" with size %d\", addr, (int)size);\n\t\t}\n\t} else {\n\t\tR_LOG_ERROR (\"afb+ No function at 0x%\" PFMT64x \" from 0x%08\"PFMT64x\" -> 0x%08\"PFMT64x,\n\t\t\t\tfcnaddr, addr, jump);\n\t}\n\tr_anal_diff_free (diff);\n\tfree (ptr);\n\treturn true;\n}\n\nstatic void r_core_anal_nofunclist(RCore *core, const char *input) {\n\tint minlen = (int)(input[0] == ' ') ? r_num_math (core->num, input + 1): 16;\n\tut64 code_size = r_num_get (core->num, \"$SS\");\n\tut64 base_addr = r_num_get (core->num, \"$S\");\n\tut64 chunk_size, chunk_offset, i;\n\tRListIter *iter, *iter2;\n\tRAnalFunction *fcn;\n\tRAnalBlock *b;\n\tchar* bitmap;\n\tint counter;\n\n\tif (minlen < 1) {\n\t\tminlen = 1;\n\t}\n\tif (code_size < 1) {\n\t\treturn;\n\t}\n\tbitmap = calloc (1, code_size + 64);\n\tif (!bitmap) {\n\t\treturn;\n\t}\n\n\t// for each function\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\t// for each basic block in the function\n\t\tr_list_foreach (fcn->bbs, iter2, b) {\n\t\t\t// if it is not withing range, continue\n\t\t\tif ((fcn->addr < base_addr) || (fcn->addr >= base_addr+code_size))\n\t\t\t\tcontinue;\n\t\t\t// otherwise mark each byte in the BB in the bitmap\n\t\t\tfor (counter = 0; counter < b->size; counter++) {\n\t\t\t\tbitmap[b->addr+counter-base_addr] = '=';\n\t\t\t}\n\t\t\t// finally, add a special marker to show the beginning of a\n\t\t\t// function\n\t\t\tbitmap[fcn->addr-base_addr] = 'F';\n\t\t}\n\t}\n\n\t// Now we print the list of memory regions that are not assigned to a function\n\tchunk_size = 0;\n\tchunk_offset = 0;\n\tfor (i = 0; i < code_size; i++) {\n\t\tif (bitmap[i]) {\n\t\t\t// We only print a region is its size is bigger than 15 bytes\n\t\t\tif (chunk_size >= minlen) {\n\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, base_addr+chunk_offset, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"  %6\" PFMT64u \"   %s\\n\",\n\t\t\t\t\t\t\tbase_addr+chunk_offset, chunk_size, fcn->name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"  %6\" PFMT64u \"\\n\",\n\t\t\t\t\t\t\tbase_addr+chunk_offset, chunk_size);\n\t\t\t\t}\n\t\t\t}\n\t\t\tchunk_size = 0;\n\t\t\tchunk_offset = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tchunk_size += 1;\n\t}\n\tif (chunk_size >= 16) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, base_addr+chunk_offset, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\tif (fcn) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %6\" PFMT64u \"   %s\\n\", base_addr+chunk_offset, chunk_size, fcn->name);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %6\" PFMT64u \"\\n\", base_addr+chunk_offset, chunk_size);\n\t\t}\n\t}\n\tfree (bitmap);\n}\n\nstatic void r_core_anal_fmap(RCore *core, const char *input) {\n\tint show_color = r_config_get_i (core->config, \"scr.color\");\n\tint cols = r_config_get_i (core->config, \"hex.cols\") * 4;\n\tut64 code_size = r_num_get (core->num, \"$SS\");\n\tut64 base_addr = r_num_get (core->num, \"$S\");\n\tRListIter *iter, *iter2;\n\tRAnalFunction *fcn;\n\tRAnalBlock *b;\n\tint assigned;\n\tut64 i;\n\n\tif (code_size < 1) {\n\t\treturn;\n\t}\n\tchar *bitmap = calloc (1, code_size + 64);\n\tif (!bitmap) {\n\t\treturn;\n\t}\n\n\t// for each function\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\t// for each basic block in the function\n\t\tr_list_foreach (fcn->bbs, iter2, b) {\n\t\t\t// if it is not within range, continue\n\t\t\tif ((fcn->addr < base_addr) || (fcn->addr >= base_addr+code_size))\n\t\t\t\tcontinue;\n\t\t\t// otherwise mark each byte in the BB in the bitmap\n\t\t\tint counter = 1;\n\t\t\tfor (counter = 0; counter < b->size; counter++) {\n\t\t\t\tbitmap[b->addr+counter-base_addr] = '=';\n\t\t\t}\n\t\t\tbitmap[fcn->addr-base_addr] = 'F';\n\t\t}\n\t}\n\t// print the bitmap\n\tassigned = 0;\n\tif (cols < 1) {\n\t\tcols = 1;\n\t}\n\tfor (i = 0; i < code_size; i += 1) {\n\t\tif (!(i % cols)) {\n\t\t\tr_cons_printf (\"\\n0x%08\"PFMT64x\"  \", base_addr+i);\n\t\t}\n\t\tif (bitmap[i]) {\n\t\t\tassigned++;\n\t\t}\n\t\tif (show_color) {\n\t\t\tif (bitmap[i]) {\n\t\t\t\tr_cons_printf (\"%s%c\\x1b[0m\", Color_GREEN, bitmap[i]);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\".\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_cons_printf (\"%c\", bitmap[i] ? bitmap[i] : '.' );\n\t\t}\n\t}\n\tr_cons_printf (\"\\n%d / %\" PFMT64u \" (%.2lf%%) bytes assigned to a function\\n\",\n\t\tassigned, code_size, 100.0 * ( (float) assigned) / code_size);\n\tfree (bitmap);\n}\n\nstatic bool fcnNeedsPrefix(const char *name) {\n\tif (!strncmp (name, \"entry\", 5)) {\n\t\treturn false;\n\t}\n\tif (!strncmp (name, \"main\", 4)) {\n\t\treturn false;\n\t}\n\treturn (!strchr (name, '.'));\n}\n\nstatic char *getFunctionName(RCore *core, ut64 off, const char *name, bool prefix) {\n\tconst char *fcnpfx = \"\";\n\tif (prefix) {\n\t\tif (fcnNeedsPrefix (name) && (!fcnpfx || !*fcnpfx)) {\n\t\t\tfcnpfx = \"fcn\";\n\t\t} else {\n\t\t\tfcnpfx = r_config_get (core->config, \"anal.fcnprefix\");\n\t\t}\n\t}\n\tif (r_reg_get (core->anal->reg, name, -1)) {\n\t\treturn r_str_newf (\"%s.%08\"PFMT64x, \"fcn\", off);\n\t}\n\treturn strdup (name); // r_str_newf (\"%s%s%s\", fcnpfx, *fcnpfx? \".\": \"\", name);\n}\n\nstatic void rename_fcnsig(RAnal *anal, const char *oname, const char *nname) {\n#define DB anal->sdb_types\n\t// rename type\n\tconst char *type = sdb_const_get (DB, oname, 0);\n\tif (type && !strcmp (type, \"func\")) {\n\t\tsdb_unset (DB, oname, 0);\n\t\tsdb_set (DB, nname, \"func\", 0);\n\t}\n\t// rename args\n\tchar *k = r_str_newf (\"func.%s.args\", oname);\n\tconst char *argstr = sdb_const_get (DB, k, 0);\n\tif (R_STR_ISEMPTY (argstr)) {\n\t\tfree (k);\n\t\treturn;\n\t}\n\tint i, args = r_num_get (NULL, argstr);\n\tsdb_unset (DB, k, 0);\n\tfree (k);\n\tk = r_str_newf (\"func.%s.args\", nname);\n\tchar *v = r_str_newf (\"%d\", (int)args);\n\tsdb_set (DB, k, v, 0);\n\tfree (v);\n\t// rename arg#\n\tfree (k);\n\tfor (i = 0; i < args; i++) {\n\t\tk = r_str_newf (\"func.%s.arg.%d\", oname, i);\n\t\tchar *v = sdb_get (DB, k, 0);\n\t\tif (v) {\n\t\t\tsdb_unset (DB, k, 0);\n\t\t\tfree (k);\n\t\t\tk = r_str_newf (\"func.%s.arg.%d\", nname, i);\n\t\t\tsdb_set (DB, k, v, 0);\n\t\t\tfree (v);\n\t\t}\n\t\tfree (k);\n\t}\n\t// unset the leftovers\n\tfor (; i < args + 8; i++) {\n\t\tk = r_str_newf (\"func.%s.arg.%d\", oname, i);\n\t\tsdb_unset (DB, k, 0);\n\t\tfree (k);\n\t}\n\t// rename ret\n\tk = r_str_newf (\"func.%s.ret\", oname);\n\tv = sdb_get (DB, k, 0);\n\tsdb_unset (DB, k, 0);\n\tfree (k);\n\tk = r_str_newf (\"func.%s.ret\", nname);\n\tsdb_set (DB, k, v, 0);\n\tfree (k);\n\tfree (v);\n#undef DB\n}\n\n/* TODO: move into r_anal_function_rename (); */\nstatic bool __setFunctionName(RCore *core, ut64 addr, const char *_name, bool prefix) {\n\tr_return_val_if_fail (core && _name, false);\n\tbool ret = false;\n\tchar *name = getFunctionName (core, addr, r_str_trim_head_ro (_name), prefix);\n\tchar *fname = r_name_filter_dup (name);\n\tRAnalFunction *fcn = r_anal_get_function_at (core->anal, addr);\n\tif (fcn) {\n\t\tchar *oname = strdup (fcn->name);\n\t\tRFlagItem *flag = r_flag_get (core->flags, fcn->name);\n\t\tif (flag && flag->space && strcmp (flag->space->name, R_FLAGS_FS_FUNCTIONS) == 0) {\n\t\t\t// Only flags in the functions fs should be renamed, e.g. we don't want to rename symbol flags.\n\t\t\tr_flag_rename (core->flags, flag, fname);\n\t\t} else {\n\t\t\t// No flag or not specific to the function, create a new one.\n\t\t\tr_flag_space_push (core->flags, R_FLAGS_FS_FUNCTIONS);\n\t\t\tr_flag_set (core->flags, name, fcn->addr, r_anal_function_size_from_entry (fcn));\n\t\t\tr_flag_space_pop (core->flags);\n\t\t}\n\t\trename_fcnsig (core->anal, oname, name);\n\t\tr_anal_function_rename (fcn, name);\n\t\tif (core->anal->cb.on_fcn_rename) {\n\t\t\tcore->anal->cb.on_fcn_rename (core->anal, core->anal->user, fcn, name);\n\t\t}\n\t\tfree (oname);\n\t\tret = true;\n\t}\n\tfree (name);\n\tfree (fname);\n\treturn ret;\n}\n\nstatic void afCc(RCore *core, const char *input) {\n\tut64 addr = (*input == ' ')\n\t\t? r_num_math (core->num, input)\n\t\t: core->offset;\n\tRAnalFunction *fcn = (addr == 0LL)\n\t\t? r_anal_get_function_byname (core->anal, input + 3)\n\t\t: r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\tif (fcn) {\n\t\tut32 totalCycles = r_anal_function_cost (fcn);\n\t\t// FIXME: This defeats the purpose of the function, but afC is used in project files.\n\t\t// cf. canal.c\n\t\tr_cons_printf (\"%d\\n\", totalCycles);\n\t} else {\n\t\tR_LOG_ERROR (\"afCc: Cannot find function\");\n\t}\n}\n\nstatic void cmd_anal_fcn_sig(RCore *core, const char *input) {\n\tbool json = (input[0] == 'j');\n\tchar *p = strchr (input, ' ');\n\tchar *fcn_name = p ? r_str_trim_dup (p): NULL;\n\tRListIter *iter;\n\tRAnalFuncArg *arg;\n\n\tRAnalFunction *fcn;\n\tif (fcn_name) {\n\t\tfcn = r_anal_get_function_byname (core->anal, fcn_name);\n\t} else {\n\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tif (fcn) {\n\t\t\tfcn_name = fcn->name;\n\t\t}\n\t}\n\tif (!fcn) {\n\t\treturn;\n\t}\n\n\tif (json) {\n\t\tPJ *j = pj_new ();\n\t\tif (!j) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (j);\n\t\tchar *key = (fcn_name)? resolve_fcn_name (core->anal, fcn_name): NULL;\n\t\tif (key) {\n\t\t\tconst char *fcn_type = r_type_func_ret (core->anal->sdb_types, key);\n\t\t\tint nargs = r_type_func_args_count (core->anal->sdb_types, key);\n\t\t\tif (fcn_type) {\n\t\t\t\tpj_o (j);\n\t\t\t\tpj_ks (j, \"name\", r_str_getf (key));\n\t\t\t\tpj_ks (j, \"return\", r_str_getf (fcn_type));\n\t\t\t\tpj_k (j, \"args\");\n\t\t\t\tpj_a (j);\n\t\t\t\tif (nargs) {\n\t\t\t\t\tRList *list = r_core_get_func_args (core, fcn_name);\n\t\t\t\t\tr_list_foreach (list, iter, arg) {\n\t\t\t\t\t\tchar *type = arg->orig_c_type;\n\t\t\t\t\t\tpj_o (j);\n\t\t\t\t\t\tpj_ks (j, \"name\", arg->name);\n\t\t\t\t\t\tpj_ks (j, \"type\", type);\n\t\t\t\t\t\tpj_end (j);\n\t\t\t\t\t}\n\t\t\t\t\tr_list_free (list);\n\t\t\t\t}\n\t\t\t\tpj_end (j);\n\t\t\t\tpj_ki (j, \"count\", nargs);\n\t\t\t\tpj_end (j);\n\t\t\t}\n\t\t\tfree (key);\n\t\t} else {\n\t\t\tpj_o (j);\n\t\t\tpj_ks (j, \"name\", r_str_getf (fcn_name));\n\t\t\tpj_k (j, \"args\");\n\t\t\tpj_a (j);\n\n\t\t\tRAnalFcnVarsCache cache;\n\t\t\tr_anal_function_vars_cache_init (core->anal, &cache, fcn);\n\t\t\tint nargs = 0;\n\t\t\tRAnalVar *var;\n\t\t\tr_list_foreach (cache.rvars, iter, var) {\n\t\t\t\tnargs++;\n\t\t\t\tpj_o (j);\n\t\t\t\tpj_ks (j, \"name\", var->name);\n\t\t\t\tpj_ks (j, \"type\", var->type);\n\t\t\t\tpj_end (j);\n\t\t\t}\n\t\t\tr_list_foreach (cache.bvars, iter, var) {\n\t\t\t\tif (var->delta <= 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnargs++;\n\t\t\t\tpj_o (j);\n\t\t\t\tpj_ks (j, \"name\", var->name);\n\t\t\t\tpj_ks (j, \"type\", var->type);\n\t\t\t\tpj_end (j);\n\t\t\t}\n\t\t\tr_list_foreach (cache.svars, iter, var) {\n\t\t\t\tif (!var->isarg) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnargs++;\n\t\t\t\tpj_o (j);\n\t\t\t\tpj_ks (j, \"name\", var->name);\n\t\t\t\tpj_ks (j, \"type\", var->type);\n\t\t\t\tpj_end (j);\n\t\t\t}\n\t\t\tr_anal_function_vars_cache_fini (&cache);\n\n\t\t\tpj_end (j);\n\t\t\tpj_ki (j, \"count\", nargs);\n\t\t\tpj_end (j);\n\t\t}\n\t\tpj_end (j);\n\t\tconst char *s = pj_string (j);\n\t\tif (s) {\n\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t}\n\t\tpj_free (j);\n\t} else {\n\t\tchar *sig = r_anal_function_format_sig (core->anal, fcn, fcn_name, NULL, NULL, NULL);\n\t\tif (sig) {\n\t\t\tr_cons_printf (\"%s\\n\", sig);\n\t\t\tfree (sig);\n\t\t}\n\t}\n}\n\nstatic void __updateStats(RCore *core, Sdb *db, ut64 addr, int statsMode) {\n\tRAnalOp *op = r_core_anal_op (core, addr, R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT | R_ARCH_OP_MASK_DISASM);\n\tif (!op) {\n\t\treturn;\n\t}\n\tif (statsMode == 'f') {\n\t\tconst char *family = r_anal_op_family_tostring (op->family);\n\t\tsdb_num_inc (db, family, 1, 0);\n\t} else if (statsMode == 'o') {\n\t\tconst char *type = r_anal_optype_tostring (op->type);\n\t\tsdb_num_inc (db, type, 1, 0);\n\t} else {\n\t\tchar *mnem = strdup (op->mnemonic);\n\t\tchar *sp = strchr (mnem, ' ');\n\t\tif (sp) {\n\t\t\t*sp = 0;\n\t\t\t//memmove (mnem, sp + 1, strlen (sp));\n\t\t}\n\t\tsdb_num_inc (db, mnem, 1, 0);\n\t}\n\t//sdb_set (db, family, \"1\", 0);\n\t//r_cons_printf (\"0x%08\"PFMT64x\" %s\\n\", addr, family);\n\tr_anal_op_free (op);\n\t// r_core_cmdf (core, \"pd 1 @ 0x%08\"PFMT64x, addr);\n}\n\nstatic Sdb *__core_cmd_anal_fcn_stats(RCore *core, const char *input) {\n\tbool silentMode = false;\n\tint statsMode = 0;\n\tif (*input == '*') {\n\t\tsilentMode = true;\n\t\tinput++;\n\t}\n\tswitch (*input) {\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_afis);\n\t\treturn NULL;\n\tcase 'f':\n\tcase 'o':\n\t\tstatsMode = *input;\n\t\tinput++;\n\t\tbreak;\n\t}\n\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tif (!fcn) {\n\t\tR_LOG_ERROR (\"Cannot find any function at 0x%08\"PFMT64x, core->offset);\n\t\treturn NULL;\n\t}\n\tSdb *db = sdb_new0 ();\n\tRAnalBlock *bb;\n\tRListIter *iter;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tint i;\n\t\t__updateStats (core, db, bb->addr, statsMode);\n\t\tfor (i = 0; i < bb->op_pos_size; i++) {\n\t\t\tut16 op_pos = bb->op_pos[i];\n\t\t\t__updateStats (core, db, bb->addr + op_pos, statsMode);\n\t\t}\n\t}\n\tif (silentMode) {\n\t\t// nothing\n\t} else if (*input == 't') {\n\t\tSdbList *ls = sdb_foreach_list (db, true);\n\t\tSdbListIter *it;\n\t\tRTable *t = r_table_new (\"fcnstats\");\n\t\tSdbKv *kv;\n\t\tRTableColumnType *typeString = r_table_type (\"string\");\n\t\tRTableColumnType *typeNumber = r_table_type (\"number\");\n\t\tr_table_add_column (t, typeString, \"name\", 0);\n\t\tls_foreach (ls, it, kv) {\n\t\t\tconst char *key = sdbkv_key (kv);\n\t\t\tr_table_add_column (t, typeNumber, key, 0);\n\t\t}\n\t\tRList *items = r_list_newf (free);\n\t\tr_list_append (items, strdup (fcn->name));\n\t\tls_foreach (ls, it, kv) {\n\t\t\tconst char *value = sdbkv_value (kv);\n\t\t\tint nv = (int)r_num_get (NULL, value);\n\t\t\tr_list_append (items, r_str_newf (\"%d\", nv));\n\t\t}\n\t\tr_table_add_row_list (t, items);\n\t\tif (r_table_query (t, input + 1)) {\n\t\t\tchar *ts = r_table_tostring (t);\n\t\t\tr_cons_printf (\"%s\", ts);\n\t\t\tfree (ts);\n\t\t}\n\t\tr_table_free (t);\n\t} else {\n\t\tSdbList *ls = sdb_foreach_list (db, true);\n\t\tSdbListIter *it;\n\t\tSdbKv *kv;\n\t\tls_foreach (ls, it, kv) {\n\t\t\tconst char *key = sdbkv_key(kv);\n\t\t\tconst char *value = sdbkv_value(kv);\n\t\t\tr_cons_printf (\"%4d %s\\n\", (int)r_num_get (NULL, value), key);\n\t\t}\n\t}\n\treturn db;\n\t//sdb_free (db);\n}\n\nstatic void __core_cmd_anal_fcn_allstats(RCore *core, const char *input) {\n\tRAnalFunction *fcn;\n\tSdbKv *kv;\n\tRListIter *iter;\n\tSdbListIter *it;\n\tRList *dbs = r_list_newf ((RListFree)sdb_free);\n\tSdb *d = sdb_new0 ();\n\tut64 oseek = core->offset;\n\tbool isJson = strchr (input, 'j');\n\n\tchar *inp = r_str_newf (\"*%s\", input);\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tr_core_seek (core, fcn->addr, true);\n\t\tSdb *db = __core_cmd_anal_fcn_stats (core, inp);\n\t\tsdb_num_set (db, \".addr\", fcn->addr, 0);\n\t\tr_list_append (dbs, db);\n\t}\n\tfree (inp);\n\tSdb *db;\n\tr_list_foreach (dbs, iter, db) {\n\t\tSdbList *ls = sdb_foreach_list (db, true);\n\t\tls_foreach (ls, it, kv) {\n\t\t\tconst char *name = sdbkv_key (kv);\n\t\t\tsdb_add (d, name, \"1\", 0);\n\t\t}\n\t\tls_free (ls);\n\t}\n\tRTable *t = r_table_new (\"fcnallstats\");\n\tSdbList *ls = sdb_foreach_list (d, true);\n\tRTableColumnType *typeString = r_table_type (\"string\");\n\tRTableColumnType *typeNumber = r_table_type (\"number\");\n\tr_table_add_column (t, typeString, \"name\", 0);\n\tr_table_add_column (t, typeNumber, \"addr\", 0);\n\tls_foreach (ls, it, kv) {\n\t\tconst char *key = sdbkv_key (kv);\n\t\tif (*key == '.') continue;\n\t\tr_table_add_column (t, typeNumber, key, 0);\n\t}\n\tsdb_free (d);\n\n\tr_list_foreach (dbs, iter, db) {\n\t\tSdbList *ls = sdb_foreach_list (db, false);\n\t\tSdbListIter *it;\n\t\tSdbKv *kv;\n\t\tchar *names[100];\n\t\tint i;\n\t\tfor (i = 0; i < 100; i++) {\n\t\t\tnames[i] = NULL;\n\t\t}\n\t\tls_foreach (ls, it, kv) {\n\t\t\tconst char *key = sdbkv_key(kv);\n\t\t\tconst char *value = sdbkv_value (kv);\n\t\t\tif (*key == '.') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint idx = r_table_column_nth (t, key);\n\t\t\tif (idx != -1) {\n\t\t\t\tut64 nv = r_num_get (NULL, value);\n\t\t\t\tnames[idx] = r_str_newf (\"%d\", (int)nv);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Invalid column name (%s)\", key);\n\t\t\t}\n\t\t}\n\t\tRList *items = r_list_newf (free);\n\t\tut64 fcnAddr = sdb_num_get (db, \".addr\", 0);\n\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, fcnAddr, 0);\n\t\tr_list_append (items, fcn?strdup (fcn->name):strdup (\"\"));\n\t\tr_list_append (items, fcn?r_str_newf (\"0x%08\"PFMT64x, fcnAddr): strdup (\"0\"));\n\t\tint cols = r_list_length (t->cols);\n\t\tfor (i = 2; i < cols; i++) {\n\t\t\tif (names[i]) {\n\t\t\t\tif (names[i][0] != '.') {\n\t\t\t\t\tr_list_append (items, strdup (names[i]));\n\t\t\t\t}\n\t\t\t\tR_FREE (names[i]);\n\t\t\t} else {\n\t\t\t\tr_list_append (items, strdup (\"0\"));\n\t\t\t}\n\t\t}\n\t\tr_table_add_row_list (t, items);\n\t}\n\tif (r_table_query (t, (*input)?input + 1: \"\")) {\n\t\tchar *ts = isJson? r_table_tojson(t): r_table_tostring (t);\n\t\tif (ts) {\n\t\t\tr_cons_printf (\"%s%s\", ts, isJson ? \"\\n\" : \"\");\n\t\t\tfree (ts);\n\t\t}\n\t}\n\tr_table_free (t);\n\tr_core_seek (core, oseek, true);\n\tr_list_free (dbs);\n}\n\nstatic void _abo(RAnalBlock *bb) {\n\tint i;\n\tfor (i = 0; i < bb->ninstr; i++) {\n\t\tut64 at = r_anal_block_ninstr (bb, i);\n\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", at);\n\t}\n}\n\nstatic void abo(RCore *core) {\n\tRAnalBlock *bb = r_anal_get_block_at (core->anal, core->offset);\n\tif (bb) {\n\t\t_abo (bb);\n\t}\n}\n\nstatic void afbo(RCore *core) {\n\tRAnalFunction *f = r_anal_get_function_at (core->anal, core->offset);\n\tif (f) {\n\t\tRListIter *iter;\n\t\tRAnalBlock *bb;\n\t\tr_list_foreach (f->bbs, iter, bb) {\n\t\t\t_abo (bb);\n\t\t}\n\t}\n}\n\nR_API char *fcnshowr(RAnalFunction *function) {\n\tRAnal *a = function->anal;\n\t//PJ *pj = a->coreb.pjWithEncoding (a->coreb.core);\n\tconst char *realname = NULL, *import_substring = NULL;\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\n\tRFlagItem *flag = a->flag_get (a->flb.f, function->addr);\n\t// Can't access R_FLAGS_FS_IMPORTS, since it is defined in r_core.h\n\tif (flag && flag->space && !strcmp (flag->space->name, \"imports\")) {\n\t\t// Get substring after last dot\n\t\timport_substring = r_str_rchr (function->name, NULL, '.');\n\t\tif (import_substring) {\n\t\t\trealname = import_substring + 1;\n\t\t}\n\t} else {\n\t\trealname = function->name;\n\t}\n\n\tchar *args = strdup (\"\");\n\tchar *sdb_ret = r_str_newf (\"func.%s.ret\", realname);\n\tchar *sdb_args = r_str_newf (\"func.%s.args\", realname);\n\t// RList *args_list = r_list_newf ((RListFree) free);\n\t// const char *ret_type = sdb_const_get (a->sdb_types, sdb_ret, 0);\n\tconst char *argc_str = sdb_const_get (a->sdb_types, sdb_args, 0);\n\tconst int argc = argc_str? atoi (argc_str): 0;\n\n\tconst bool no_return = r_anal_noreturn_at_addr (a, function->addr);\n\tif (no_return) {\n\t\tr_strbuf_appendf (sb, \"tn %s\\n\", function->name);\n\t}\n\tif (function->cc) {\n\t\tr_strbuf_appendf (sb, \"afc %s\\n\", function->cc);\n\t}\n\tint i;\n\tfor (i = 0; i < argc; i++) {\n\t\tchar *sdb_arg_i = r_str_newf (\"func.%s.arg.%d\", realname, i);\n\t\tchar *type = sdb_get (a->sdb_types, sdb_arg_i, 0);\n\t\tif (!type) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *comma = strchr (type, ',');\n\t\tif (comma) {\n\t\t\t*comma = 0;\n\t\t\tr_strf_var (regname, 32, \"A%d\", i);\n\t\t\tconst char *cc_arg = r_reg_get_name (a->reg, r_reg_get_name_idx (regname));\n\t\t\tr_strbuf_appendf (sb, \"afvr %s %s %s\\n\", cc_arg, comma + 1, type);\n\t\t}\n\t\tfree (type);\n\t\tfree (sdb_arg_i);\n\t}\n\tfree (sdb_args);\n\tfree (sdb_ret);\n\tfree (args);\n\treturn r_strbuf_drain (sb);\n}\n\nstatic void cmd_afsr(RCore *core, const char *input) {\n\tut64 addr = core->offset;\n\tRAnalFunction *f;\n\tif ((f = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL))) {\n\t\tchar *res = fcnshowr (f);\n\t\tif (R_STR_ISNOTEMPTY (res)) {\n\t\t\tr_cons_println (res);\n\t\t}\n\t\tfree (res);\n\t} else {\n\t\tR_LOG_ERROR (\"No function defined at 0x%08\" PFMT64x, addr);\n\t}\n}\n\nstatic void cmd_afsj(RCore *core, const char *arg) {\n\tut64 a = r_num_math (core->num, arg);\n\tconst ut64 addr = a? a: core->offset;\n\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, addr, -1);\n\tif (f) {\n\t\tchar *s = r_anal_function_get_json (f);\n\t\tr_cons_printf (\"%s\\n\", s);\n\t\tfree (s);\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot find function in 0x%08\"PFMT64x, addr);\n\t}\n}\n\nstatic void cmd_afbc(RCore *core, const char *input) {\n\tr_return_if_fail (core && input);\n\tchar *ptr = strdup (input);\n\tif (!ptr) {\n\t\treturn;\n\t}\n\tif (*ptr == '?') {\n\t\tr_core_cmd_help_match (core, help_msg_afb, \"afbc\", true);\n\t} else if (!*ptr) {\n\t\tRAnalBlock *bb = r_anal_get_block_at (core->anal, core->offset);\n\t\tif (bb && (bb->color.r || bb->color.g || bb->color.b)) {\n\t\t\tchar *s = r_cons_rgb_str (NULL, -1, &bb->color);\n\t\t\tif (s) {\n\t\t\t\tchar *name = r_cons_rgb_tostring (bb->color.r, bb->color.g, bb->color.b);\n\t\t\t\tr_cons_printf (\"%s%s\"Color_RESET\"\\n\", s, name);\n\t\t\t\tfree (name);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tut64 addr = core->offset;\n\t\tconst bool del = (*ptr == '-');\n\t\tif (del) {\n\t\t\tptr++;\n\t\t}\n\n\t\tchar *space = strchr (ptr, ' ');\n\t\tif (space) {\n\t\t\t*space++ = 0;\n\t\t\taddr = r_num_math (core->num, space);\n\t\t}\n\t\tRColor color = {0};\n\t\tif (del) {\n\t\t\tptr--;\n\t\t} else {\n\t\t\t(void)r_cons_pal_parse (ptr, &color);\n\t\t}\n\t\tRAnalBlock *bb = r_anal_get_block_at (core->anal, addr);\n\t\tif (bb) {\n\t\t\tbb->color = color;\n\t\t}\n\t}\n\tfree (ptr);\n}\n\n// Fcn Xrefs Map\nstatic void xrefs_map(RCore *core, const char *input) {\n\tRListIter *iter, *iter2;\n\tRAnalFunction *f, *f2;\n\tint col = 0;\n\tint count = 0;\n\tdo {\n\t\tr_cons_print (\"             \");\n\t\tcount = 0;\n\t\tr_list_foreach (core->anal->fcns, iter, f) {\n\t\t\tint nlen = strlen (f->name);\n\t\t\tif (col >= nlen) {\n\t\t\t\tr_cons_printf (\"|\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tr_cons_printf (\"%c\", f->name[col]);\n\t\t}\n\t\tr_cons_newline ();\n\t\tcol++;\n\t} while (count);\n\n\tint total = 0;\n\tr_list_foreach (core->anal->fcns, iter, f) {\n\t\tRVecAnalRef *refs = r_anal_function_get_refs (f);\n\t\tr_cons_printf (\"0x%08\"PFMT64x\"  \", f->addr);\n\t\ttotal = 0;\n\t\tr_list_foreach (core->anal->fcns, iter2, f2) {\n\t\t\tint count = 0;\n\t\t\tRAnalRef *r;\n\t\t\tR_VEC_FOREACH (refs, r) {\n\t\t\t\tif (r->addr == f2->addr) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > 0) {\n\t\t\t\ttotal++;\n\t\t\t\tif (count < 10) {\n\t\t\t\t\tr_cons_printf (\"%d\", count);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"+\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\".\");\n\t\t\t}\n\t\t}\n\t\tif (total > 0) {\n\t\t\tr_cons_printf (\"  %s\\n\", f->name);\n\t\t} else {\n\t\t\tr_cons_printf (\"\\r\");\n\t\t}\n\t\tRVecAnalRef_free (refs);\n\t}\n}\n\nR_API void r_core_af(RCore *core, ut64 addr, const char *name, bool anal_calls) {\n\tint depth = r_config_get_i (core->config, \"anal.depth\");\n\n\t//r_core_anal_undefine (core, core->offset);\n\tr_core_anal_fcn (core, addr, UT64_MAX, R_ANAL_REF_TYPE_NULL, depth);\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\tif (fcn) {\n\t\t/* ensure we use a proper name */\n\t\t__setFunctionName (core, addr, fcn->name, false);\n\t\tif (core->anal->opt.vars) {\n\t\t\tr_core_recover_vars (core, fcn, true);\n\t\t}\n\t\t__add_vars_sdb (core, fcn);\n\t} else {\n\t\tif (core->anal->verbose) {\n\t\t\tR_LOG_WARN (\"Unable to analyze function at 0x%08\"PFMT64x, addr);\n\t\t}\n\t}\n\tif (anal_calls) {\n\t\tSetU *visited = set_u_new ();\n\t\tfcn = r_anal_get_fcn_in (core->anal, addr, 0); /// XXX wrong in case of nopskip\n\t\tif (fcn) {\n\t\t\tRVecAnalRef *refs = r_anal_function_get_refs (fcn);\n\t\t\tRAnalRef *ref;\n\t\t\tR_VEC_FOREACH (refs, ref) {\n\t\t\t\tif (set_u_contains (visited, ref->addr)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tset_u_add (visited, ref->addr);\n\t\t\t\tif (ref->addr == UT64_MAX) {\n\t\t\t\t\tR_LOG_DEBUG (\"ignore 0x%08\"PFMT64x\" call 0x%08\"PFMT64x, ref->at, ref->addr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint rt = R_ANAL_REF_TYPE_MASK (ref->type);\n\t\t\t\tif (rt != R_ANAL_REF_TYPE_CODE && rt != R_ANAL_REF_TYPE_CALL) {\n\t\t\t\t\t/* only follow code/call references */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!r_io_is_valid_offset (core->io, ref->addr, !core->anal->opt.noncode)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr_core_anal_fcn (core, ref->addr, fcn->addr, R_ANAL_REF_TYPE_CALL, depth - 1);\n\t\t\t\t/* use recursivity here */\n#if 1\n\t\t\t\tRAnalFunction *f = r_anal_get_function_at (core->anal, ref->addr);\n\t\t\t\tif (f) {\n\t\t\t\t\tRVecAnalRef *refs1 = r_anal_function_get_refs (f);\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tR_VEC_FOREACH (refs1, ref) {\n\t\t\t\t\t\tconst ut64 raddr = ref->addr;\n\t\t\t\t\t\tif (set_u_contains (visited, raddr)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tset_u_add (visited, raddr);\n\t\t\t\t\t\tif (!r_io_is_valid_offset (core->io, raddr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst int rt = R_ANAL_REF_TYPE_MASK (ref->type);\n\t\t\t\t\t\tif (rt != R_ANAL_REF_TYPE_CALL && rt != R_ANAL_REF_TYPE_CODE) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// recursively follow fcn->refs again and again\n\t\t\t\t\t\tif (!r_anal_get_function_at (core->anal, raddr)) {\n\t\t\t\t\t\t\t// do not reanalize if theres a function already there\n\t\t\t\t\t\t\tr_core_anal_fcn (core, raddr, f->addr, R_ANAL_REF_TYPE_CALL, depth - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tRVecAnalRef_free (refs1);\n\t\t\t\t} else {\n\t\t\t\t\tf = r_anal_get_fcn_in (core->anal, fcn->addr, 0);\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\t/* cut function */\n\t\t\t\t\t\tr_anal_function_resize (f, addr - fcn->addr);\n\t\t\t\t\t\tr_core_anal_fcn (core, ref->addr, fcn->addr, R_ANAL_REF_TYPE_CALL, depth - 1);\n\t\t\t\t\t\tf = r_anal_get_function_at (core->anal, fcn->addr);\n\t\t\t\t\t}\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tR_LOG_ERROR (\"af: Cannot find function at 0x%08\" PFMT64x, fcn->addr);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tRVecAnalRef_free (refs);\n\t\t\tif (core->anal->opt.vars) {\n\t\t\t\tr_core_recover_vars (core, fcn, true);\n\t\t\t}\n\t\t}\n\t\tset_u_free (visited);\n\t}\n\tif (name) {\n\t\tif (*name && !__setFunctionName (core, addr, name, true)) {\n\t\t\tR_LOG_ERROR (\"af: Cannot find function at 0x%08\" PFMT64x, addr);\n\t\t}\n\t}\n#if 0\n\t// XXX THIS IS VERY SLOW\n\t// r_core_anal_propagate_noreturn (core, addr);\n\tif (core->anal->opt.vars) {\n\t\tRListIter *iter;\n\t\tRAnalFunction *fcni = NULL;\n\t\tr_list_foreach (core->anal->fcns, iter, fcni) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_core_recover_vars (core, fcni, true);\n\t\t}\n\t}\n//\tflag_every_function (core);\n#endif\n}\n\nstatic void cmd_aflxj(RCore *core) {\n\tut64 addr = faddr (core, core->offset, NULL);\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_ANY);\n\tSdb *db = sdb_new0 ();\n\tRVecAnalRef *xrefs = r_anal_xrefs_get (core->anal, addr);\n\tif (xrefs) {\n\t\tRAnalRef *ref;\n\t\tR_VEC_FOREACH (xrefs, ref) {\n\t\t\tbool nr = false;\n\t\t\tut64 fa = faddr (core, ref->addr, &nr);\n\t\t\tchar *key = r_str_newf (\"0x%08\"PFMT64x, fa);\n\t\t\tsdb_array_add_num (db, key, ref->addr, 0);\n\t\t}\n\t}\n\tSdbList *keys = sdb_foreach_list (db, true);\n\tSdbListIter *liter;\n\tSdbKv *kv;\n\tPJ * pj = r_core_pj_new (core);\n\tif (pj) {\n\t\tpj_o (pj);\n\t}\n\tls_foreach (keys, liter, kv) {\n\t\tconst char *key = sdbkv_key (kv);\n\t\tconst char *value = sdbkv_value (kv);\n\t\tut64 fcn_xref_addr = r_num_get (NULL, key);\n\t\tut64 xref_addr = r_num_get (NULL, value);\n\t\tRAnalFunction *xref = r_anal_get_fcn_in (core->anal, fcn_xref_addr, R_ANAL_FCN_TYPE_ANY);\n\t\tif (fcn && xref) {\n\t\t\tpj_kn (pj, \"address\", fcn->addr);\n\t\t\tpj_ks (pj, \"name\", fcn->name);\n\t\t\tpj_ko (pj, \"xrefs\");\n\t\t\tpj_ka (pj, xref->name);\n\t\t\tpj_n (pj, xref_addr);\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t} else {\n\t\t\tR_LOG_WARN (\"No function defined here\");\n\t\t}\n\t}\n\tpj_end (pj);\n\tchar *s = pj_drain (pj);\n\tr_cons_printf (\"%s\\n\", s);\n\tfree (s);\n\tRVecAnalRef_free (xrefs);\n\tsdb_free (db);\n\tls_free (keys);\n}\n\nstatic void cmd_afci(RCore *core, RAnalFunction *fcn) {\n\tconst char *cc = (fcn && fcn->cc)? fcn->cc: \"reg\";\n\tr_core_cmdf (core, \"afcll~%s (\", cc);\n}\n\nstatic void cmd_afix(RCore *core, const char *input) {\n\tswitch (input[3]) {\n\tcase '?': // \"afix?\"\n\t\tr_core_cmd_help_match (core, help_msg_afi, \"afix\", false);\n\t\tbreak;\n\tcase 'q': // \"afixq\"\n\tcase 'j': // \"afixj\"\n\t\tr_core_anal_fcn_list (core, input + 4, input + 2);\n\t\tbreak;\n\tcase 0: // \"afix\"\n\t\tr_core_anal_fcn_list (core, \"\", \"x\\x01\");\n\t\tbreak;\n\tdefault:\n\t\tR_LOG_ERROR (\"Invalid argument\");\n\t\tbreak;\n\t}\n}\n\nstatic int cmd_af(RCore *core, const char *input) {\n\tr_cons_break_timeout (r_config_get_i (core->config, \"anal.timeout\"));\n\tswitch (input[1]) {\n\tcase '-': // \"af-\"\n\t\tif (!input[2]) { // \"af-\"\n\t\t\tcmd_af (core, \"f-$$\");\n\t\t\tr_core_anal_undefine (core, core->offset);\n\t\t} else if (!strcmp (input + 2, \"*\")) { // \"af-*\"\n\t\t\tRAnalFunction *f;\n\t\t\tRListIter *iter, *iter2;\n\t\t\tr_list_foreach_safe (core->anal->fcns, iter, iter2, f) {\n\t\t\t\tut64 addr = f->addr;\n\t\t\t\tr_anal_del_jmprefs (core->anal, f);\n\t\t\t\t// r_anal_function_del_locs (core->anal, f->addr);\n\t\t\t//\tr_anal_function_del (core->anal, addr);\n\t\t\t\tr_core_anal_undefine (core, addr);\n\t\t\t}\n\t\t} else {\n\t\t\tut64 addr = input[2]\n\t\t\t\t? r_num_math (core->num, input + 2)\n\t\t\t\t: core->offset;\n\t\t\t// r_anal_function_del_locs (core->anal, addr);\n\t\t\t// r_anal_function_del (core->anal, addr);\n\t\t\tr_core_anal_undefine (core, addr);\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"afj\"\n\t\t{\n\t\t\tRList *blocks = r_anal_get_blocks_in (core->anal, core->offset);\n\t\t\tRAnalBlock *block = r_list_first (blocks);\n\t\t\tif (block && !r_list_empty (block->fcns)) {\n\t\t\t\tchar *args = strdup (input + 2);\n\t\t\t\tRList *argv = r_str_split_list (args, \" \", 0);\n\t\t\t\tut64 table = r_num_math (core->num, r_list_get_n (argv, 1));\n\t\t\t\tut64 sz = r_num_math (core->num, r_list_get_n (argv, 2));\n\t\t\t\tut64 elements = r_num_math (core->num, r_list_get_n (argv, 3));\n\t\t\t\tut64 seg = r_num_math (core->num, r_list_get_n (argv, 4));\n\t\t\t\tint depth = 50;\n\t\t\t\ttry_walkthrough_jmptbl (core->anal, r_list_first (block->fcns), block,\n\t\t\t\t\tdepth, core->offset, 0, table, seg, sz, elements, 0, false);\n\t\t\t\tfree (args);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"No function defined here\");\n\t\t\t}\n\t\t\tr_list_free (blocks);\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"afa\"\n\t\tif (input[2] == 'l') { // \"afal\" : list function call arguments\n\t\t\tint show_args = r_config_get_i (core->config, \"dbg.funcarg\");\n\t\t\tif (show_args) {\n\t\t\t\tr_core_print_func_args (core);\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_print_func_args (core);\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"afd\"\n\t\t{\n\t\tut64 addr = 0;\n\t\tif (input[2] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_af, \"afd\", true);\n\t\t} else if (input[2] == ' ') {\n\t\t\taddr = r_num_math (core->num, input + 2);\n\t\t} else {\n\t\t\taddr = core->offset;\n\t\t}\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\tif (input[2] == 'j') { // afdj\n\t\t\tPJ *pj = r_core_pj_new (core);\n\t\t\tif (!pj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpj_o (pj);\n\t\t\tif (fcn) {\n\t\t\t\tpj_ks (pj, \"name\", fcn->name);\n\t\t\t\tpj_ki (pj, \"offset\", (int)(addr - fcn->addr));\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t} else {\n\t\t\tif (fcn) {\n\t\t\t\tif (fcn->addr != addr) {\n\t\t\t\t\tr_cons_printf (\"%s + %d\\n\", fcn->name,\n\t\t\t\t\t\t\t(int)(addr - fcn->addr));\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_println (fcn->name);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"afd: Cannot find function\");\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'u': // \"afu\"\n\t\tif (input[2] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_afu);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (input[2] != ' ') {\n\t\t\tR_LOG_ERROR (\"Missing argument\");\n\t\t\treturn false;\n\t\t}\n\n\t\tut64 addr = core->offset;\n\t\tut64 addr_end = r_num_math (core->num, input + 2);\n\t\tif (addr_end < addr) {\n\t\t\tR_LOG_ERROR (\"Invalid address ranges\");\n\t\t} else {\n\t\t\tut64 a, b;\n\t\t\tconst char *c;\n\t\t\ta = r_config_get_i (core->config, \"anal.from\");\n\t\t\tb = r_config_get_i (core->config, \"anal.to\");\n\t\t\tc = r_config_get (core->config, \"anal.limits\");\n\t\t\tr_config_set_i (core->config, \"anal.from\", addr);\n\t\t\tr_config_set_i (core->config, \"anal.to\", addr_end);\n\t\t\tr_config_set_b (core->config, \"anal.limits\", true);\n\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\tif (fcn) {\n\t\t\t\tr_anal_function_resize (fcn, addr_end - addr);\n\t\t\t}\n\t\t\tr_core_anal_fcn (core, addr, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n\t\t\tfcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\tif (fcn) {\n\t\t\t\tr_anal_function_resize (fcn, addr_end - addr);\n\t\t\t}\n\t\t\tr_config_set_i (core->config, \"anal.from\", a);\n\t\t\tr_config_set_i (core->config, \"anal.to\", b);\n\t\t\tr_config_set (core->config, \"anal.limits\", r_str_get (c));\n\t\t}\n\t\tbreak;\n\tcase '+': { // \"af+\"\n\t\tif (input[2] == '?' || !input[2]) {\n\t\t\tr_core_cmd_help (core, help_msg_af_plus);\n\t\t\tbreak;\n\t\t}\n\t\tchar *ptr = input[2]? r_str_trim_dup (input + 2): r_str_newf (\"0x%\"PFMT64x, core->offset);\n\t\tconst char *ptr2;\n\t\tint n = r_str_word_set0 (ptr);\n\t\tconst char *name = NULL;\n\t\tchar *hname = NULL; // heaped name\n\t\tut64 addr = UT64_MAX;\n\t\tRAnalDiff *diff = NULL;\n\t\tint type = R_ANAL_FCN_TYPE_FCN;\n\t\tif (n > 0) {\n\t\t\tswitch (n) {\n\t\t\tcase 4:\n\t\t\t\tptr2 = r_str_word_get0 (ptr, 3);\n\t\t\t\tif (!(diff = r_anal_diff_new ())) {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot initialize RAnalDiff\");\n\t\t\t\t\tfree (ptr);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (ptr2[0] == 'm') {\n\t\t\t\t\tdiff->type = R_ANAL_DIFF_TYPE_MATCH;\n\t\t\t\t} else if (ptr2[0] == 'u') {\n\t\t\t\t\tdiff->type = R_ANAL_DIFF_TYPE_UNMATCH;\n\t\t\t\t}\n\t\t\t\t/* fallthrough */\n\t\t\tcase 3:\n\t\t\t\tptr2 = r_str_word_get0 (ptr, 2);\n\t\t\t\tif (strchr (ptr2, 'l')) {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_LOC;\n\t\t\t\t} else if (strchr (ptr2, 'i')) {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_IMP;\n\t\t\t\t} else if (strchr (ptr2, 's')) {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_SYM;\n\t\t\t\t} else {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_FCN;\n\t\t\t\t}\n\t\t\t\t/* fallthrough */\n\t\t\tcase 2:\n\t\t\t\tname = r_str_word_get0 (ptr, 1);\n\t\t\t\t/* fallthrough */\n\t\t\tcase 1:\n\t\t\t\taddr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\t\tif (!name) {\n\t\t\t\t\tRFlagItem *fi = r_flag_get_at (core->flags, addr, false);\n\t\t\t\t\tname = hname = (fi)\n\t\t\t\t\t\t? strdup (fi->name)\n\t\t\t\t\t\t: r_str_newf (\"fcn.%08\"PFMT64x, addr);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRAnalFunction *fcn = r_anal_create_function (core->anal, name, addr, type, diff);\n\t\t\tif (!fcn) {\n\t\t\t\tR_LOG_ERROR (\"Cannot add function '%s' (duplicated) at 0x%08\"PFMT64x, name, addr);\n\t\t\t}\n\t\t\tfree (hname);\n\t\t}\n\t\tr_anal_diff_free (diff);\n\t\tfree (ptr);\n\t\t}\n\t\tbreak;\n\tcase 'o': // \"afo\"\n\t\tswitch (input[2]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help_match (core, help_msg_af, \"afo\", true);\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tPJ *pj = r_core_pj_new (core);\n\t\t\t\tif (!pj) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpj_o (pj);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tpj_ki (pj, \"address\", fcn->addr);\n\t\t\t\t}\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", fcn->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's': // \"afos\"\n\t\t\t{\n\t\t\t\tut64 addr = core->offset;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRList *list = r_anal_get_functions_in (core->anal, addr);\n\t\t\t\tRAnalFunction *fcn;\n\t\t\t\tr_list_foreach (list, iter, fcn) {\n\t\t\t\t\tr_cons_printf (\"= 0x%08\" PFMT64x \"\\n\", fcn->addr);\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn;\n\t\t\t\tut64 addr = r_num_math (core->num, input + 3);\n\t\t\t\tif (addr == 0LL) {\n\t\t\t\t\tfcn = r_anal_get_function_byname (core->anal, input + 3);\n\t\t\t\t} else {\n\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\t}\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", fcn->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"afi\"\n\t\tswitch (input[2]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_afi);\n\t\t\tbreak;\n\t\tcase 'x': // \"afix\"\n\t\t\tcmd_afix (core, input);\n\t\t\tbreak;\n\t\tcase '.': // \"afi.\"\n\t\t\t{\n\t\t\t\tut64 addr = core->offset;\n\t\t\t\tif (input[3] == ' ') {\n\t\t\t\t\taddr = r_num_math (core->num, input + 3);\n\t\t\t\t}\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", fcn->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l': // \"afil\"\n\t\t\tif (input[3] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_afll);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough */\n\t\tcase 'i': // \"afii\"\n\t\t\tif (input[3] == '-') {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_list_free (fcn->imports);\n\t\t\t\t\tfcn->imports = NULL;\n\t\t\t\t}\n\t\t\t} else if (input[3] == ' ') {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tif (!fcn->imports) {\n\t\t\t\t\t\tfcn->imports = r_list_newf ((RListFree)free);\n\t\t\t\t\t}\n\t\t\t\t\tr_list_append (fcn->imports, r_str_trim_dup (input + 4));\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"No function found\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn && fcn->imports) {\n\t\t\t\t\tchar *imp;\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tr_list_foreach (fcn->imports, iter, imp) {\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", imp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's': // \"afis\"\n\t\t\tif (input[3] == 'a') { // \"afisa\"\n\t\t\t\t__core_cmd_anal_fcn_allstats (core, input + 4);\n\t\t\t} else {\n\t\t\t\tsdb_free (__core_cmd_anal_fcn_stats (core, input + 3));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j': // \"afij\"\n\t\tcase '*': // \"afi*\"\n\t\t\tr_core_anal_fcn_list (core, input + 3, input + 2);\n\t\t\tbreak;\n\t\tcase 'p': // \"afip\"\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"is-pure: %s\\n\", r_str_bool (r_anal_function_purity (fcn)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '=':\n\t\tcase 'q':\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\t// TODO: add info about xrefs and call counts\n\t\t\t\t\tint nargs = r_type_func_args_count (core->anal->sdb_types, 0);\n\t\t\t\t\tint nvars = r_anal_var_count_locals (fcn);\n\t\t\t\t\tint nins = r_anal_function_instrcount (fcn);\n\t\t\t\t\tint ebbs = 0;\n\t\t\t\t\tint edges = r_anal_function_count_edges (fcn, &ebbs);\n\t\t\t\t\tr_anal_function_count_edges (fcn, NULL);\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" : %s\\n\", fcn->addr, fcn->name);\n\t\t\t\t\tchar *sig = r_core_cmd_strf (core, \"afcf @ 0x%\"PFMT64x, fcn->addr);\n\t\t\t\t\tif (sig) {\n\t\t\t\t\t\tr_str_trim (sig);\n\t\t\t\t\t\tr_cons_printf (\"  sign:  %s\\n\", sig);\n\t\t\t\t\t\tfree (sig);\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"  stack: 0x%08x (vars:%d args:%d)\\n\",\n\t\t\t\t\t\tfcn->maxstack, nvars , nargs);\n\t\t\t\t\tr_cons_printf (\"  size:  %d (0x%08\" PFMT64x \" .. 0x%08\" PFMT64x \")\\n\",\n\t\t\t\t\t\t(int)r_anal_function_realsize (fcn),\n\t\t\t\t\t\tr_anal_function_min_addr (fcn),\n\t\t\t\t\t\tr_anal_function_max_addr (fcn));\n\t\t\t\t\tr_cons_printf (\"  nbbs:  %d edges:%d ebbs:%d ninstr:%d\\n\",\n\t\t\t\t\t\tr_list_length (fcn->bbs), edges, ebbs, nins);\n\t\t\t\t\tr_cons_printf (\"  cost:  %d complexity:%d\\n\",\n\t\t\t\t\t\tr_anal_function_cost (fcn), r_anal_function_complexity (fcn));\n\t\t\t\t\tr_cons_printf (\"  attr:  \");\n\t\t\t\t\tif (r_anal_function_islineal (fcn)) {\n\t\t\t\t\t\tr_cons_printf (\"lineal\");\n\t\t\t\t\t}\n\t\t\t\t\tif (fcn->is_noreturn) {\n\t\t\t\t\t\tr_cons_printf (\"noreturn\");\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_newline ();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ':\n\t\tcase 0:\n\t\t\t{\n\t\t\t\tconst char *arg = input[2]? input + 2: \"\";\n\t\t\t\tconst char *sec = \"\\x01\";\n\t\t\t\tr_core_anal_fcn_list (core, arg, sec);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_afi);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'l': // \"afl\"\n\t\tswitch (input[2]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_afl);\n\t\t\tbreak;\n\t\tcase 'x': // \"aflx\"\n\t\t\tswitch (input[3]) {\n\t\t\tdefault:\n\t\t\tcase '?':\n\t\t\t\tr_core_cmd_help (core, help_msg_aflx);\n\t\t\t\treturn true;\n\t\t\tcase 'v': // \"aflxv\"\n\t\t\tcase '*': // \"aflx*\"\n\t\t\tcase 0: // default for \"aflx\"\n\t\t\t{\n\t\t\t\tut64 addr = faddr (core, core->offset, NULL);\n\t\t\t\tSdb *db = sdb_new0 ();\n\t\t\t\t// sort by function and uniq to avoid dupped results\n\t\t\t\tRVecAnalRef *xrefs = r_anal_xrefs_get (core->anal, addr);\n\t\t\t\tif (xrefs) {\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tR_VEC_FOREACH (xrefs, ref) {\n\t\t\t\t\t\tbool nr = false;\n\t\t\t\t\t\tut64 fa = faddr (core, ref->addr, &nr);\n\t\t\t\t\t\tchar *key = r_str_newf (\"0x%08\"PFMT64x, fa);\n\t\t\t\t\t\tsdb_array_add_num (db, key, ref->addr, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSdbList *keys = sdb_foreach_list (db, true);\n\t\t\t\tSdbListIter *liter;\n\t\t\t\tSdbKv *kv;\n\t\t\t\tbool rad = input[3] == '*';\n\t\t\t\tbool verbose = input[3] == 'v';\n\t\t\t\tls_foreach (keys, liter, kv) {\n\t\t\t\t\tconst char *key = sdbkv_key (kv);\n\t\t\t\t\tconst char *value = sdbkv_value (kv);\n\t\t\t\t    if (verbose) {\n\t\t\t\t\t\tut64 fcn_xref_addr = r_num_get (NULL, key);\n\t\t\t\t\t\tRAnalFunction *xref = r_anal_get_fcn_in (core->anal, fcn_xref_addr, R_ANAL_FCN_TYPE_ANY);\n\t\t\t\t\t\tif (xref) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s %s\\n\",  xref->name, value);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (rad) {                                                                                                                                                                                      r_cons_printf (\"s %s;af-;af;s-\\n\", (const char *)kv->base.key);\n\t\t\t\t\t\tr_cons_printf (\"s %s;af-;af;s-\\n\", key);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"%s %s\\n\", key, value);\n\t\t\t\t}\n\t\t\t\tsdb_free (db);\n\t\t\t\tls_free (keys);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'j': // \"aflxj\"\n\t\t\t\tcmd_aflxj (core);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's': // \"afls\"\n\t\t\tswitch (input[3]) {\n\t\t\tdefault:\n\t\t\tcase '?':\n\t\t\t\tr_core_cmd_help (core, help_msg_afls);\n\t\t\t\treturn true;\n\t\t\tcase 0: // default for \"afls\"\n\t\t\tcase 'a': // \"aflsa\"\n\t\t\t\tcore->anal->fcns->sorted = false;\n\t\t\t\tr_list_sort (core->anal->fcns, cmpaddr);\n\t\t\t\tbreak;\n\t\t\tcase 'b': // \"aflsb\"\n\t\t\t\tcore->anal->fcns->sorted = false;\n\t\t\t\tr_list_sort (core->anal->fcns, cmpbbs);\n\t\t\t\tbreak;\n\t\t\tcase 's': // \"aflss\"\n\t\t\t\tcore->anal->fcns->sorted = false;\n\t\t\t\tr_list_sort (core->anal->fcns, cmpsize);\n\t\t\t\tbreak;\n\t\t\tcase 'n': // \"aflsn\"\n\t\t\t\tcore->anal->fcns->sorted = false;\n\t\t\t\tr_list_sort (core->anal->fcns, cmpname);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l': // \"afll\"\n\t\t\tif (input[3] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_afll);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough */\n\t\tcase ',': // \"afl,\"\n\t\tcase 't': // \"aflt\"\n\t\tcase 'j': // \"aflj\"\n\t\tcase 'q': // \"aflq\"\n\t\tcase 'm': // \"aflm\"\n\t\tcase '+': // \"afl+\"\n\t\tcase '=': // \"afl=\"\n\t\tcase '*': // \"afl*\"\n\t\tcase '.': // \"afl*\"\n\t\t\tr_core_anal_fcn_list (core, NULL, input + 2);\n\t\t\tbreak;\n\t\tcase 'c': // \"aflc\"\n\t\t\tr_cons_printf (\"%d\\n\", r_list_length (core->anal->fcns));\n\t\t\tbreak;\n\t\tcase ' ': // \"afl [addr]\" argument ignored\n\t\tcase 0: // \"afl\"\n\t\t\tr_core_anal_fcn_list (core, NULL, \"o\");\n\t\t\tbreak;\n\t\tdefault: // \"afl \"\n\t\t\tr_core_cmd_help (core, help_msg_afl);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 's': // \"afs\"\n\t\tswitch (input[2]) {\n\t\tcase '!': { // \"afs!\"\n\t\t\tchar *sig = r_core_cmd_str (core, \"afs\");\n\t\t\tchar *data = r_core_editor (core, NULL, sig);\n\t\t\tif (sig && data) {\n\t\t\t\tr_core_cmd_callf (core, \"afs %s\", data);\n\t\t\t}\n\t\t\tfree (sig);\n\t\t\tfree (data);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'r': { // \"afsr\"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\t\tif (fcn) {\n\t\t\t\tchar *type = r_str_newf (\"type.%s\", input + 4);\n\t\t\t\tif (sdb_exists (core->anal->sdb_types, type)) {\n\t\t\t\t\tchar *query = r_str_newf (\"anal/types/func.%s.ret=%s\", fcn->name, input + 4);\n\t\t\t\t\tsdb_querys (core->sdb, NULL, 0, query);\n\t\t\t\t\tfree (query);\n\t\t\t\t}\n\t\t\t\tfree (type);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"There's no function defined here\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase '*': // \"afs*\"\n\t\t\tcmd_afsr (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'j': // \"afsj\"\n\t\t\tcmd_afsj (core, input + 2);\n\t\t\tbreak;\n\t\tcase 0:\n\t\tcase ' ': { // \"afs\"\n\t\t\tut64 addr = core->offset;\n\t\t\tRAnalFunction *f;\n\t\t\tconst char *arg = r_str_trim_head_ro (input + 2);\n\t\t\tif ((f = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL))) {\n\t\t\t\tif (R_STR_ISNOTEMPTY (arg)) {\n\t\t\t\t\t// parse function signature here\n\t\t\t\t\tchar *fcnstr = r_str_newf (\"%s;\", arg), *fcnstr_copy = strdup (fcnstr);\n\t\t\t\t\tchar *save_ptr = NULL;\n\t\t\t\t\tchar *fcnname_aux = r_str_tok_r (fcnstr_copy, \"(\", &save_ptr);\n\t\t\t\t\tr_str_trim_tail (fcnname_aux);\n\t\t\t\t\tconst char *ls = r_str_lchr (fcnname_aux, ' ');\n\t\t\t\t\tchar *fcnname = strdup (ls? ls: fcnname_aux);\n\t\t\t\t\tif (fcnname) {\n\t\t\t\t\t\t// TODO: move this into r_anal_str_to_fcn()\n\t\t\t\t\t\tif (strcmp (f->name, fcnname)) {\n\t\t\t\t\t\t\t(void)__setFunctionName (core, addr, fcnname, false);\n\t\t\t\t\t\t\tf = r_anal_get_fcn_in (core->anal, addr, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_str_to_fcn (core->anal, f, fcnstr);\n\t\t\t\t\t}\n\t\t\t\t\tfree (fcnname);\n\t\t\t\t\tfree (fcnstr_copy);\n\t\t\t\t\tfree (fcnstr);\n\t\t\t\t} else {\n\t\t\t\t\tchar *str = r_anal_function_get_signature (f);\n\t\t\t\t\tif (str) {\n\t\t\t\t\t\tr_cons_println (str);\n\t\t\t\t\t\tfree (str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"No function defined at 0x%08\" PFMT64x, addr);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t// case '?': // \"afs?\"\n\t\t\tr_core_cmd_help (core, help_msg_afs);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'm': // \"afm\" - merge two functions\n\t\tif (input[2] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_afm);\n\t\t\tbreak;\n\t\t}\n\t\tr_core_anal_fcn_merge (core, core->offset, r_num_math (core->num, input + 2));\n\t\tbreak;\n\tcase 'M': // \"afM\" - print functions map\n\t\tr_core_anal_fmap (core, input + 1);\n\t\tbreak;\n\tcase 'v': // \"afv\"\n\t\tvar_cmd (core, input + 2);\n\t\tbreak;\n\tcase 't': // \"aft\"\n\t\ttype_cmd (core, input + 2);\n\t\tbreak;\n\tcase 'C': // \"afC\"\n\t\tif (input[2] == 'c') {\n\t\t\tRAnalFunction *fcn;\n\t\t\tif ((fcn = r_anal_get_fcn_in (core->anal, core->offset, 0))) {\n\t\t\t\tr_cons_printf (\"%i\\n\", r_anal_function_complexity (fcn));\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot find function at 0x08%\" PFMT64x, core->offset);\n\t\t\t}\n\t\t} else if (input[2] == 'l') {\n\t\t\tRAnalFunction *fcn;\n\t\t\tif ((fcn = r_anal_get_fcn_in (core->anal, core->offset, 0))) {\n\t\t\t\tr_cons_printf (\"%d\\n\", r_anal_function_loops (fcn));\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot find function at 0x08%\" PFMT64x, core->offset);\n\t\t\t}\n\t\t} else if (input[2] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_afC);\n\t\t} else {\n\t\t\tafCc (core, r_str_trim_head_ro (input + 2));\n\t\t}\n\t\tbreak;\n\tcase 'c': { // \"afc\"\n\t\tRAnalFunction *fcn = NULL;\n\t\tif (!input[2] || input[2] == ' ' || input[2] == 'i' || input[2] == 'r' || input[2] == 'a') {\n\t\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tif (!fcn) {\n\t\t\t\tR_LOG_ERROR (\"afc: Cannot find function here\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch (input[2]) {\n\t\tcase '\\0': // \"afc\"\n\t\t\tr_cons_println (fcn->cc);\n\t\t\tbreak;\n\t\tcase ' ': { // \"afc \"\n\t\t\t\t  char *cc = r_str_trim_dup (input + 3);\n\t\t\t\t  if (!r_anal_cc_exist (core->anal, cc)) {\n\t\t\t\t\t  const char *asmOs = r_config_get (core->config, \"asm.os\");\n\t\t\t\t\t  R_LOG_ERROR (\"afc: Unknown calling convention '%s' for '%s'. See afcl for available types\", cc, asmOs);\n\t\t\t\t  } else {\n\t\t\t\t\t  fcn->cc = r_str_constpool_get (&core->anal->constpool, cc);\n\t\t\t\t  }\n\t\t\t\t  free (cc);\n\t\t\t  }\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tcmd_afci (core, fcn);\n\t\t\tbreak;\n\t\tcase 'f': // \"afcf\" \"afcfj\"\n\t\t\tcmd_anal_fcn_sig (core, input + 3);\n\t\t\tbreak;\n\t\tcase 'k': // \"afck\"\n\t\t\tcmd_afck (core, NULL);\n\t\t\tbreak;\n\t\tcase 'l': // \"afcl\" list all function Calling conventions.\n\t\t\tif (input[3] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_afc);\n\t\t\t} else {\n\t\t\t\tcmd_tcc (core, input + 3);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'o': { // \"afco\"\n\t\t\t\t  char *dbpath = r_str_trim_dup (input + 3);\n\t\t\t\t  if (R_STR_ISNOTEMPTY (dbpath) && r_file_exists (dbpath)) {\n\t\t\t\t\t  Sdb *db = sdb_new (0, dbpath, 0);\n\t\t\t\t\t  if (db) {\n\t\t\t\t\t\t  sdb_merge (core->anal->sdb_cc, db);\n\t\t\t\t\t\t  sdb_close (db);\n\t\t\t\t\t\t  sdb_free (db);\n\t\t\t\t\t  }\n\t\t\t\t  } else {\n\t\t\t\t\t  r_core_cmd_help_match (core, help_msg_afc, \"afco\", true);\n\t\t\t\t  }\n\t\t\t\t  free (dbpath);\n\t\t\t  }\n\t\t\tbreak;\n\t\tcase 'r': { // \"afcr\"\n\t\t\tint i;\n\t\t\tPJ *pj = NULL;\n\t\t\tbool json = input[3] == 'j';\n\t\t\tif (json) {\n\t\t\t\tpj = r_core_pj_new (core);\n\t\t\t\tif (!pj) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpj_o (pj);\n\t\t\t}\n\t\t\tchar *cmd = r_str_newf (\"cc.%s.ret\", fcn->cc);\n\t\t\tconst char *regname = sdb_const_get (core->anal->sdb_cc, cmd, 0);\n\t\t\tif (regname) {\n\t\t\t\tif (json) {\n\t\t\t\t\tpj_ks (pj, \"ret\", regname);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s: %s\\n\", cmd, regname);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (cmd);\n\t\t\tif (json) {\n\t\t\t\tpj_ka (pj, \"args\");\n\t\t\t}\n\t\t\tfor (i = 0; i < R_ANAL_CC_MAXARG; i++) {\n\t\t\t\tcmd = r_str_newf (\"cc.%s.arg%d\", fcn->cc, i);\n\t\t\t\tregname = sdb_const_get (core->anal->sdb_cc, cmd, 0);\n\t\t\t\tif (regname) {\n\t\t\t\t\tif (json) {\n\t\t\t\t\t\tpj_s (pj, regname);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s: %s\\n\", cmd, regname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (cmd);\n\t\t\t}\n\t\t\tif (json) {\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tcmd = r_str_newf (\"cc.%s.self\", fcn->cc);\n\t\t\tregname = sdb_const_get (core->anal->sdb_cc, cmd, 0);\n\t\t\tif (regname) {\n\t\t\t\tif (json) {\n\t\t\t\t\tpj_ks (pj, \"self\", regname);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s: %s\\n\", cmd, regname);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (cmd);\n\t\t\tcmd = r_str_newf (\"cc.%s.error\", fcn->cc);\n\t\t\tregname = sdb_const_get (core->anal->sdb_cc, cmd, 0);\n\t\t\tif (regname) {\n\t\t\t\tif (json) {\n\t\t\t\t\tpj_ks (pj, \"error\", regname);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s: %s\\n\", cmd, regname);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (cmd);\n\t\t\tif (json) {\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'R': { // \"afcR\"\n\t\t\t/* very slow, but im tired of waiting for having this, so this is the quickest implementation */\n\t\t\tint i;\n\t\t\tchar *cc = r_core_cmd_str (core, \"k anal/cc/default.cc\");\n\t\t\tr_str_trim (cc);\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tchar *res = r_core_cmd_strf (core, \"k anal/cc/cc.%s.arg%d\", cc, i);\n\t\t\t\tr_str_trim_nc (res);\n\t\t\t\tif (*res) {\n\t\t\t\t\tchar *row = r_core_cmd_strf (core, \"drr~%s 0x\", res);\n\t\t\t\t\tr_str_trim (row);\n\t\t\t\t\tr_cons_printf (\"arg[%d] %s\\n\", i, row);\n\t\t\t\t\tfree (row);\n\t\t\t\t}\n\t\t\t\tfree (res);\n\t\t\t}\n\t\t\tfree (cc);\n\t\t\tbreak;\n\t\t}\n\t\tcase '?': // \"afc?\"\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_afc);\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'B': // \"afB\" // set function bits\n\t\tif (input[2] == ' ') {\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tif (fcn) { // bits = 0 means unset\n\t\t\t\tint nbits = atoi (input + 3);\n\t\t\t\tint obits = core->anal->config->bits;\n\t\t\t\tif (nbits > 0) {\n\t\t\t\t\tr_anal_hint_set_bits (core->anal, r_anal_function_min_addr (fcn), nbits);\n\t\t\t\t\tr_anal_hint_set_bits (core->anal, r_anal_function_max_addr (fcn), obits);\n\t\t\t\t\tfcn->bits = nbits;\n\t\t\t\t} else {\n\t\t\t\t\tr_anal_hint_unset_bits (core->anal, r_anal_function_min_addr (fcn));\n\t\t\t\t\tfcn->bits = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"afB: Cannot find function to set bits at 0x%08\"PFMT64x, core->offset);\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_cmd_help_match (core, help_msg_af, \"afB\", true);\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"afb\"\n\t\tswitch (input[2]) {\n\t\tcase '-': // \"afb-\"\n\t\t\tanal_fcn_del_bb (core, r_str_trim_head_ro (input + 3));\n\t\t\tbreak;\n\t\tcase 'o': // \"afbo\"\n\t\t\tafbo (core);\n\t\t\tbreak;\n\t\tcase 'e': // \"afbe\"\n\t\t\tanal_bb_edge (core, r_str_trim_head_ro (input + 3));\n\t\t\tbreak;\n\t\tcase 'F': { // \"afbF\"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\tif (fcn) {\n\t\t\t\tRAnalBlock *bb = r_anal_function_bbget_in (core->anal, fcn, core->offset);\n\t\t\t\tif (bb) {\n\t\t\t\t\tif (input[3]) {\n\t\t\t\t\t\tint n = atoi (input + 3);\n\t\t\t\t\t\tbb->folded = n;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbb->folded = !bb->folded;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tr_warn_if_reached ();\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0:\n\t\tcase ' ': // \"afb \"\n\t\tcase 'q': // \"afbq\"\n\t\tcase 'r': // \"afbr\"\n\t\tcase '=': // \"afb=\"\n\t\tcase '*': // \"afb*\"\n\t\tcase 'j': // \"afbj\"\n\t\tcase 't': // \"afbt\"\n\t\t\tanal_fcn_list_bb (core, input + 2, false);\n\t\t\tbreak;\n\t\tcase 'i': // \"afbi\"\n\t\t\tanal_fcn_list_bb (core, input + 2, true);\n\t\t\tbreak;\n\t\tcase '.': // \"afb.\"\n\t\t\tanal_fcn_list_bb (core, input[2]? \" $$\": input + 2, true);\n\t\t\tbreak;\n\t\tcase '+': // \"afb+\"\n\t\t\tcmd_afbplus (core, input + 3);\n\t\t\tbreak;\n\t\tcase 'c': // \"afbc\"\n\t\t\tcmd_afbc (core, r_str_trim_head_ro (input + 3));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_afb);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'n': // \"afn\"\n\t\tswitch (input[2]) {\n\t\tcase 's': // \"afns\"\n\t\t\tif (input[3] == 'j') { // \"afnsj\"\n\t\t\t\tfree (r_core_anal_fcn_autoname (core, core->offset, 1, input[3]));\n\t\t\t} else {\n\t\t\t\tfree (r_core_anal_fcn_autoname (core, core->offset, 1, 0));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a': // \"afna\"\n\t\t\tif (input[3] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_afna);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchar *name = r_core_anal_fcn_autoname (core, core->offset, 0, 0);\n\t\t\tif (name) {\n\t\t\t\tr_cons_printf (\"afn %s 0x%08\" PFMT64x \"\\n\", name, core->offset);\n\t\t\t\tfree (name);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '.': // \"afn.\"\n\t\tcase 0: { // \"afn\"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\t\tif (fcn) {\n\t\t\t\tr_cons_printf (\"%s\\n\", fcn->name);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ': { // \"afn \"\n\t\t\tut64 off = core->offset;\n\t\t\tchar *p, *name = strdup (r_str_trim_head_ro (input + 3));\n\t\t\tif ((p = strchr (name, ' '))) {\n\t\t\t\t*p++ = 0;\n\t\t\t\toff = r_num_math (core->num, p);\n\t\t\t}\n\t\t\tif (*name == '?') {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_afn, \"afn\", true);\n\t\t\t} else {\n\t\t\t\tif (r_str_startswith (name, \"base64:\")) {\n\t\t\t\t\tchar *res = (char *)r_base64_decode_dyn (name + 7, -1);\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tfree (name);\n\t\t\t\t\t\tname = res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!*name || !__setFunctionName (core, off, name, false)) {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot find function at 0x%08\" PFMT64x, off);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (name);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_afn);\n\t\t\tbreak;\n\t\t} // end of switch (input[2])\n\t\tbreak;\n\tcase 'S': { // afS\"\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\tif (fcn) {\n\t\t\tfcn->maxstack = r_num_math (core->num, input + 3);\n\t\t\t//fcn->stack = fcn->maxstack;\n\t\t}\n\t\tbreak;\n\t}\n#if 0\n\t/* this is undocumented, broken and probably have no uses. plz discuss */\n\tcase 'e': // \"afe\"\n\t\t{\n\t\tRAnalFunction *fcn;\n\t\tut64 off = core->offset;\n\t\tchar *p, *name = strdup ((input[2]&&input[3])? input + 3: \"\");\n\t\tif ((p = strchr (name, ' '))) {\n\t\t\t*p = 0;\n\t\t\toff = r_num_math (core->num, p + 1);\n\t\t}\n\t\tfcn = r_anal_get_fcn_in (core->anal, off, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\tif (fcn) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tRAnalRef *r;\n\t\t\tr_list_foreach (fcn->refs, iter, r) {\n\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" -%c 0x%08\" PFMT64x \"\\n\", r->at, r->type, r->addr);\n\t\t\t}\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint ok = 0;\n\t\t\t\tif (b->type == R_ANAL_BB_TYPE_LAST) ok = 1;\n\t\t\t\tif (b->type == R_ANAL_BB_TYPE_FOOT) ok = 1;\n\t\t\t\tif (b->jump == UT64_MAX && b->fail == UT64_MAX) ok = 1;\n\t\t\t\tif (ok) {\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" -r\\n\", b->addr);\n\t\t\t\t\t// TODO: check if destination is outside the function boundaries\n\t\t\t\t}\n\t\t\t}\n\t\t} else eprintf (\"Cannot find function at 0x%08\" PFMT64x \"\\n\", core->offset);\n\t\tfree (name);\n\t\t}\n\t\tbreak;\n#endif\n\tcase 'x': // \"afx\"\n\t\tswitch (input[2]) {\n\t\tcase 'm': // \"afxm\"\n\t\t\txrefs_map (core, input + 1);\n\t\t\tbreak;\n\t\tcase '\\0': // \"afx\"\n\t\tcase 'j': // \"afxj\"\n\t\tcase ' ': // \"afx \"\n\t\t{\n\t\t\tPJ *pj = r_core_pj_new (core);\n\t\t\tif (input[2] == 'j') {\n\t\t\t\tpj_a (pj);\n\t\t\t}\n\t\t\tif (!pj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// list xrefs from current address\n\t\t\t{\n\t\t\t\tut64 addr = (input[2] == ' ')? r_num_math (core->num, input + 2): core->offset;\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tut64 oaddr = core->offset;\n\t\t\t\t\tRVecAnalRef *refs = r_anal_function_get_refs (fcn);\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tR_VEC_FOREACH (refs, ref) {\n\t\t\t\t\t\tif (input[2] == 'j') {\n\t\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\t\tpj_ks (pj, \"type\", r_anal_ref_type_tostring (ref->type));\n\t\t\t\t\t\t\tpj_kn (pj, \"from\", ref->at);\n\t\t\t\t\t\t\tpj_kn (pj, \"to\", ref->addr);\n\t\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"%c 0x%08\" PFMT64x \" -> \", ref->type, ref->at);\n\t\t\t\t\t\t\tswitch (R_ANAL_REF_TYPE_MASK (ref->type)) {\n\t\t\t\t\t\t\tcase R_ANAL_REF_TYPE_NULL:\n\t\t\t\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" \", ref->addr);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase R_ANAL_REF_TYPE_CODE:\n\t\t\t\t\t\t\tcase R_ANAL_REF_TYPE_ICOD:\n\t\t\t\t\t\t\tcase R_ANAL_REF_TYPE_JUMP:\n\t\t\t\t\t\t\tcase R_ANAL_REF_TYPE_CALL:\n\t\t\t\t\t\t\tcase R_ANAL_REF_TYPE_DATA:\n\t\t\t\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" \", ref->addr);\n\t\t\t\t\t\t\t\tr_core_seek (core, ref->at, 1);\n\t\t\t\t\t\t\t\tr_core_print_disasm_instructions (core, 0, 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase R_ANAL_REF_TYPE_STRN:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tchar *s = r_core_cmd_strf (core, \"pxr 8 @ 0x%08\"PFMT64x, ref->addr);\n\t\t\t\t\t\t\t\t\tchar *nl = strchr (s, '\\n');\n\t\t\t\t\t\t\t\t\tif (nl) {\n\t\t\t\t\t\t\t\t\t\t*nl = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t\t\t\t\t\t\tfree (s);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// ignore rwx\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tRVecAnalRef_free (refs);\n\t\t\t\t\tr_core_seek (core, oaddr, 1);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"afx: Cannot find function at 0x%08\"PFMT64x, addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (input[2] == 'j') {\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t}\n\t\t\tpj_free (pj);\n\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tR_LOG_ERROR (\"Invalid command. Look at af?\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'F': // \"afF\"\n\t\t{\n\t\t\tint val = input[2] && r_num_math (core->num, input + 2);\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\tif (fcn) {\n\t\t\t\tfcn->folded = input[2]? val: !fcn->folded;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '?': // \"af?\"\n\t\tr_core_cmd_help (core, help_msg_af);\n\t\tbreak;\n\tcase 'r': // \"afr\" // analyze function recursively\n\tcase ' ': // \"af \"\n\tcase '\\0': // \"af\"\n\t\t{\n\t\t\tbool anal_calls = r_config_get_b (core->config, \"anal.calls\");\n\t\t\tif (input[0] && input[1] == 'r') {\n\t\t\t\tinput++;\n\t\t\t\tanal_calls = true;\n\t\t\t}\n\t\t\tut64 addr = core->offset;\n\t\t\tconst char *name = NULL;\n\t\t\t// first undefine\n\t\t\tif (input[0] && input[1] == ' ') {\n\t\t\t\tname = r_str_trim_head_ro (input + 2);\n\t\t\t\tchar *uaddr = strchr (name, ' ');\n\t\t\t\tif (uaddr) {\n\t\t\t\t\t*uaddr++ = 0;\n\t\t\t\t\taddr = r_num_math (core->num, uaddr);\n\t\t\t\t}\n\t\t\t\t// depth = 1; // or 1?\n\t\t\t\t// disable hasnext\n\t\t\t}\n\t\t\tr_core_af (core, addr, name, anal_calls);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nR_API void r_core_anal_undefine(RCore *core, ut64 off) {\n\t// very slow\n\t// RAnalFunction *f = r_anal_get_fcn_in (core->anal, off, -1);\n\tRAnalFunction *f = r_anal_get_function_at (core->anal, off);\n\tif (f) {\n\t\tif (!strncmp (f->name, \"fcn.\", 4)) {\n\t\t\tr_flag_unset_name (core->flags, f->name);\n\t\t}\n\t\tr_meta_del (core->anal, R_META_TYPE_ANY, r_anal_function_min_addr (f), r_anal_function_linear_size (f));\n\t\tr_anal_function_del (core->anal, off);\n\t}\n\t//r_anal_function_del_locs (core->anal, off);\n\tr_anal_delete_block_at (core->anal, off);\n\tchar *abcmd = r_str_newf (\"ab-0x%\"PFMT64x, off);\n\tif (abcmd) {\n\t\tcmd_af (core, abcmd);\n\t\tfree (abcmd);\n\t}\n}\n\n// size: 0: bits; -1: any; >0: exact size\nstatic void __anal_reg_list(RCore *core, int type, int bits, char mode) {\n\tPJ *pj = NULL;\n\tif (mode == 'i') {\n\t\tr_core_debug_ri (core, core->anal->reg, 0);\n\t\treturn;\n\t} else if (mode == 'j') {\n\t\tpj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t}\n\tRReg *hack = core->dbg->reg;\n\tcore->dbg->reg = core->anal->reg;\n\tconst char *use_color;\n\tint use_colors = r_config_get_i (core->config, \"scr.color\");\n\tif (use_colors) {\n#undef ConsP\n#define ConsP(x) (core->cons && core->cons->context->pal.x)? core->cons->context->pal.x\n\t\tuse_color = ConsP (creg) : Color_BWHITE;\n\t} else {\n\t\tuse_color = NULL;\n\t}\n\tif (bits < 0) {\n\t\t// TODO Change the `size` argument of r_debug_reg_list to use -1 for any and 0 for anal->config->bits\n\t\tbits = 0;\n\t} else if (!bits) {\n\t\tbits = core->anal->config->bits;\n\t}\n\tint mode2 = mode;\n\tconst char *arch_name = get_arch_name (core);\n\tcore->dbg->reg = core->anal->reg;\n\t/* workaround for thumb */\n\tif (r_str_startswith (arch_name, \"arm\") && bits == 16) {\n\t\tbits = 32;\n\t} else {\n\t\tconst int defsz = r_reg_default_bits (core->anal->reg);\n\t\tif (defsz > 0) {\n\t\t\tbits = defsz;\n\t\t}\n\t}\n\t/* workaround for 6502 and avr*/\n\tif ((!strcmp (arch_name, \"6502\") && bits == 8)\n\t\t|| (!strcmp (arch_name, \"avr\") && bits == 8)) {\n\t\tif (mode == 'j') {\n\t\t\tmode2 = 'J';\n\t\t\tpj_o (pj);\n\t\t}\n\t\t// XXX detect which one is current usage\n\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, 16, pj, mode2, use_color);\n\t}\n#if 0\n\tif (mode == '=') {\n\t\tint pcbits = 0;\n\t\tconst char *pcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\t\tif (pcname) {\n\t\t\tRRegItem *reg = r_reg_get (core->anal->reg, pcname, 0);\n\t\t\tif (reg && bits != reg->size) {\n\t\t\t\tpcbits = reg->size;\n\t\t\t}\n\t\t\tif (pcbits) {\n\t\t\t\t// r_debug_reg_list (core->dbg, R_REG_TYPE_GPR, pcbits, NULL, mode, use_color); // XXX detect which one is current usage\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tr_debug_reg_list (core->dbg, type, bits, pj, mode2, use_color);\n\tif (mode == 'j') {\n\t\tif (mode2 == 'J') {\n\t\t\tpj_end (pj);\n\t\t}\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\n\tcore->dbg->reg = hack;\n}\n\nstatic RRegItem *reg_by_name_role(RCore *core, const char *n) {\n\tRRegItem *r = r_reg_get (core->anal->reg, n, -1);\n\tif (!r) {\n\t\tint role = r_reg_get_name_idx (n);\n\t\tif (role != -1) {\n\t\t\tconst char *alias = r_reg_get_name (core->anal->reg, role);\n\t\t\tif (alias) {\n\t\t\t\tr = r_reg_get (core->anal->reg, alias, -1);\n\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}\n\nstatic bool reg_name_roll_set(RCore *core, const char *name, ut64 n) {\n\tRRegItem *r = reg_by_name_role (core, name);\n\tif (r) {\n\t\tr_reg_set_value (core->anal->reg, r, n);\n\t\tr_debug_reg_sync (core->dbg, R_REG_TYPE_ALL, true);\n\t\tr_core_cmdf (core, \".dr*%d\", core->anal->config->bits); // XXX: replace in future\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n// XXX dup from drp :OOO\nvoid cmd_anal_reg(RCore *core, const char *str) {\n#if 0\n\tif (0) {\n\t\t/* enable this block when dr and ar use the same code but just using\n\t\t   core->dbg->reg or core->anal->reg and removing all the debugger\n\t\t   dependent code */\n\t\tRReg *reg = core->dbg->reg;\n\t\tcore->dbg->reg = core->anal->reg;\n\t\tcmd_debug_reg (core, str);\n\t\tcore->dbg->reg = reg;\n\t\treturn;\n\t}\n#endif\n\tint size = 0, i, type = R_REG_TYPE_GPR;\n\tint use_colors = r_config_get_i (core->config, \"scr.color\");\n\tconst char *use_color = NULL;\n\tconst char *name;\n\tchar *arg;\n\tchar *save_ptr = NULL;\n\n\tif (use_colors) {\n#define ConsP(x) (core->cons && core->cons->context->pal.x)? core->cons->context->pal.x\n\t\tuse_color = ConsP (creg) : Color_BWHITE;\n\t}\n\tswitch (str[0]) {\n\tcase 'l': // \"arl\"\n\t{\n\t\tconst bool use_json = str[1] == 'j';\n\t\tRRegSet *rs = r_reg_regset_get (core->anal->reg, R_REG_TYPE_GPR);\n\t\tif (rs) {\n\t\t\tRRegItem *r;\n\t\t\tRListIter *iter;\n\t\t\tPJ *pj = pj_new ();\n\t\t\tpj_a (pj);\n\t\t\tr_list_foreach (rs->regs, iter, r) {\n\t\t\t\tif (use_json) {\n\t\t\t\t\tpj_s (pj, r->name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_println (r->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (use_json) {\n\t\t\t\tpj_end (pj);\n\t\t\t\tconst char *s = pj_string (pj);\n\t\t\t\tr_cons_println (s);\n\t\t\t}\n\t\t\tpj_free (pj);\n\t\t}\n\t} break;\n\tcase ',': // \"ar,\"\n\t\t__tableRegList (core, core->anal->reg, str + 1);\n\t\tbreak;\n\tcase '0': // \"ar0\"\n\t\tr_reg_arena_zero (core->anal->reg);\n\t\tbreak;\n\tcase 'A': // \"arA\"\n\t\t{\n\t\t\tint nargs = 4;\n\t\t\tRReg *reg = core->anal->reg;\n\t\t\tfor (i = 0; i < nargs; i++) {\n\t\t\t\tr_strf_var (regname, 32, \"A%d\", i);\n\t\t\t\tconst char *name = r_reg_get_name (reg, r_reg_get_name_idx (regname));\n\t\t\t\tut64 off = r_reg_getv (core->anal->reg, name);\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" \", off);\n\t\t\t\t// XXX very ugly hack\n\t\t\t\tchar *s = r_core_cmd_strf (core, \"pxr 32 @ 0x%08\"PFMT64x, off);\n\t\t\t\tif (s) {\n\t\t\t\t\tchar *nl = strchr (s, '\\n');\n\t\t\t\t\tif (nl) {\n\t\t\t\t\t\t*nl = 0;\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t\t\t}\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n//\t\t\t\tr_core_cmd0 (core, \"ar A0,A1,A2,A3\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'C': // \"arC\"\n\t\tif (core->anal->reg->reg_profile_cmt) {\n\t\t\tr_cons_println (core->anal->reg->reg_profile_cmt);\n\t\t}\n\t\tbreak;\n\tcase 'w': // \"arw\"\n\t\tswitch (str[1]) {\n\t\tcase '?': {\n\t\t\tr_core_cmd_help (core, help_msg_arw);\n\t\t\tbreak;\n\t\t}\n\t\tcase ' ':\n\t\t\tr_reg_arena_set_bytes (core->anal->reg, str + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_arw);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"ara\"\n\t\tswitch (str[1]) {\n\t\tcase '?': // \"ara?\"\n\t\t\tr_core_cmd_help (core, help_msg_ara);\n\t\t\tbreak;\n\t\tcase 's': // \"aras\"\n\t\t\tr_reg_arena_swap (core->anal->reg, false);\n\t\t\tbreak;\n\t\tcase '+': // \"ara+\"\n\t\t\tr_reg_arena_push (core->anal->reg);\n\t\t\tbreak;\n\t\tcase '-': // \"ara-\"\n\t\t\tr_reg_arena_pop (core->anal->reg);\n\t\t\tbreak;\n\t\tdefault: {\n\t\t\tint i, j;\n\t\t\tRRegArena *a;\n\t\t\tRListIter *iter;\n\t\t\tfor (i = 0; i < R_REG_TYPE_LAST; i++) {\n\t\t\t\tRRegSet *rs = &core->anal->reg->regset[i];\n\t\t\t\tj = 0;\n\t\t\t\tr_list_foreach (rs->pool, iter, a) {\n\t\t\t\t\tr_cons_printf (\"%s %p %d %d %s %d\\n\",\n\t\t\t\t\t\t(a == rs->arena)? \"*\": \".\", a,\n\t\t\t\t\t\ti, j, r_reg_get_type (i), a->size);\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t\tbreak;\n\tcase '?': // \"ar?\"\n\t\tif (str[1]) {\n\t\t\tut64 off = r_reg_getv (core->anal->reg, str + 1);\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", off);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ar);\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"arr\"\n\t\tswitch (str[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help_match (core, help_msg_dr, \"drr\", false);\n\t\t\tbreak;\n\t\tcase 'j': // \"arrj\"\n\t\t\tr_core_debug_rr (core, core->anal->reg, 'j');\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_debug_rr (core, core->anal->reg, 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'S': { // \"arS\"\n\t\tint sz;\n\t\tut8 *buf = r_reg_get_bytes (core->anal->reg, R_REG_TYPE_GPR, &sz);\n\t\tr_cons_printf (\"%d\\n\", sz);\n\t\tfree (buf);\n\t\t} break;\n\tcase 'b': { // \"arb\" WORK IN PROGRESS // DEBUG COMMAND\n\t\tint len, type = R_REG_TYPE_GPR;\n\t\targ = strchr (str, ' ');\n\t\tif (arg) {\n\t\t\tchar *string = r_str_trim_dup (arg + 1);\n\t\t\tif (string) {\n\t\t\t\ttype = r_reg_type_by_name (string);\n\t\t\t\tif (type == -1 && string[0] != 'a') {\n\t\t\t\t\ttype = R_REG_TYPE_GPR;\n\t\t\t\t}\n\t\t\t\tfree (string);\n\t\t\t}\n\t\t}\n\t\tut8 *buf = r_reg_get_bytes (core->dbg->reg, type, &len);\n\t\tif (buf) {\n\t\t\tr_print_hexdump (core->print, 0LL, buf, len, 32, 4, 1);\n\t\t\tfree (buf);\n\t\t}\n\t\t} break;\n\tcase 'c': // \"arc\"\n\t\t// TODO: set flag values with drc zf=1\n\t\tif (str[1] == 'q') { // \"arcq\"\n\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\tif (rf) {\n\t\t\t\tr_cons_printf (\"s:%d z:%d c:%d o:%d p:%d\\n\",\n\t\t\t\t\t\trf->s, rf->z, rf->c, rf->o, rf->p);\n\t\t\t\tfree (rf);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (str[1] == 'c') { // \"arcc\"\n\t\t\tchar *s = r_reg_profile_to_cc (core->anal->reg);\n\t\t\tif (s) {\n\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t} else {\n\t\t\tRRegItem *r;\n\t\t\tconst char *name = r_str_trim_head_ro (str + 1);\n\t\t\tif (*name && name[1]) {\n\t\t\t\tr = r_reg_cond_get (core->dbg->reg, name);\n\t\t\t\tif (r) {\n\t\t\t\t\tr_cons_println (r->name);\n\t\t\t\t} else {\n\t\t\t\t\tint id = r_reg_cond_from_string (name);\n\t\t\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\t\t\tif (rf) {\n\t\t\t\t\t\tint o = r_reg_cond_bits (core->dbg->reg, id, rf);\n\t\t\t\t\t\tr_core_return_value (core, o);\n\t\t\t\t\t\t// ORLY?\n\t\t\t\t\t\tr_cons_printf (\"%d\\n\", o);\n\t\t\t\t\t\tfree (rf);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tR_LOG_ERROR (\"unknown conditional or flag register\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\t\tif (rf) {\n\t\t\t\t\tr_cons_printf (\"| s:%d z:%d c:%d o:%d p:%d\\n\",\n\t\t\t\t\t\trf->s, rf->z, rf->c, rf->o, rf->p);\n\t\t\t\t\tif (*name == '=') {\n\t\t\t\t\t\tfor (i = 0; i < R_REG_COND_LAST; i++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s:%d \",\n\t\t\t\t\t\t\t\tr_reg_cond_tostring (i),\n\t\t\t\t\t\t\t\tr_reg_cond_bits (core->dbg->reg, i, rf));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (i = 0; i < R_REG_COND_LAST; i++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%d %s\\n\",\n\t\t\t\t\t\t\t\tr_reg_cond_bits (core->dbg->reg, i, rf),\n\t\t\t\t\t\t\t\tr_reg_cond_tostring (i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (rf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 's': // \"ars\"\n\t\tswitch (str[1]) {\n\t\tcase '-': // \"ars-\"\n\t\t\tr_reg_arena_pop (core->dbg->reg);\n\t\t\t// restore debug registers if in debugger mode\n\t\t\tr_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, true);\n\t\t\tbreak;\n\t\tcase '+': // \"ars+\"\n\t\t\tr_reg_arena_push (core->dbg->reg);\n\t\t\tbreak;\n\t\tcase '?': { // \"ars?\"\n\t\t\t// TODO #7967 help refactor: dup from drp\n\t\t\tRCoreHelpMessage help_msg = {\n\t\t\t\t\"Usage:\", \"drs\", \" # Register states commands\",\n\t\t\t\t\"drs\", \"\", \"list register stack\",\n\t\t\t\t\"drs+\", \"\", \"push register state\",\n\t\t\t\t\"drs-\", \"\", \"pop register state\",\n\t\t\t\tNULL };\n\t\t\tr_core_cmd_help (core, help_msg);\n\t\t} break;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tvoid *p = core->dbg->reg->regset[0].pool;\n\t\t\t\tint len = p? r_list_length (p): 0;\n\t\t\t\tr_cons_printf (\"%d\\n\", len);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'p': // \"arp\"\n\t\t// XXX we have to break out .h for these cmd_xxx files.\n\t\tcmd_reg_profile (core, 'a', str);\n\t\tbreak;\n\tcase 't': // \"art\"\n\t\tif (str[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_dr, \"drt\", false);\n\t\t} else {\n\t\t\tfor (i = 0; (name = r_reg_get_type (i)); i++) {\n\t\t\t\tr_cons_println (name);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'n': // \"arn\"\n\t\tif (*(str + 1) == '\\0') {\n\t\t\tR_LOG_ERROR (\"Oops. try arn [PC|SP|BP|SN|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\");\n\t\t\tbreak;\n\t\t}\n\t\tname = r_reg_get_name (core->dbg->reg, r_reg_get_name_idx (str + 2));\n\t\tif (name && *name) {\n\t\t\tr_cons_println (name);\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Oops. try arn [PC|SP|BP|SN|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\");\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"ard\"\n\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, core->anal->config->bits,\n\t\t\tNULL, 3, use_color); // XXX detect which one is current usage\n\t\tbreak;\n\tcase 'o': // \"aro\"\n\t\tr_reg_arena_swap (core->dbg->reg, false);\n\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, core->anal->config->bits,\n\t\t\tNULL, 0, use_color); // XXX detect which one is current usage\n\t\tr_reg_arena_swap (core->dbg->reg, false);\n\t\tbreak;\n\tcase '=': // \"ar=\"\n\t\t{\n\t\t\tchar *p = NULL;\n\t\t\tchar *bitstr = NULL;\n\t\t\tif (str[1]) {\n\t\t\t\tp = r_str_trim_dup (str + 1);\n\t\t\t\tif (str[1] != ':') {\n\t\t\t\t\t// Bits were specified\n\t\t\t\t\tbitstr = r_str_tok_r (p, \":\", &save_ptr);\n\t\t\t\t\tif (r_str_isnumber (bitstr)) {\n\t\t\t\t\t\tst64 sz = r_num_math (core->num, bitstr);\n\t\t\t\t\t\tif (sz > 0) {\n\t\t\t\t\t\t\tsize = sz;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_core_cmd_help (core, help_msg_ar);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint len = bitstr ? strlen (bitstr) : 0;\n\t\t\t\tif (str[len + 1] == ':') {\n\t\t\t\t\t// We have some regs\n\t\t\t\t\tchar *regs = bitstr ? r_str_tok_r (NULL, \":\", &save_ptr) : r_str_tok_r ((char *)str + 1, \":\", &save_ptr);\n\t\t\t\t\tchar *reg = r_str_tok_r (regs, \" \", &save_ptr);\n\t\t\t\t\tRList *q_regs = r_list_new ();\n\t\t\t\t\tif (q_regs) {\n\t\t\t\t\t\twhile (reg) {\n\t\t\t\t\t\t\tr_list_append (q_regs, reg);\n\t\t\t\t\t\t\treg = r_str_tok_r (NULL, \" \", &save_ptr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcore->dbg->q_regs = q_regs;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (size < 32 && r_str_startswith (r_config_get (core->config, \"asm.arch\"), \"arm\")) {\n\t\t\t\tsize = 32;\n\t\t\t}\n\t\t\t__anal_reg_list (core, type, size, str[0]);\n\t\t\tif (!r_list_empty (core->dbg->q_regs)) {\n\t\t\t\tr_list_free (core->dbg->q_regs);\n\t\t\t}\n\t\t\tcore->dbg->q_regs = NULL;\n\t\t\tfree (p);\n\t\t}\n\t\tbreak;\n\tcase '.': // \"ar.\"\n\tcase '-': // \"ar-\"\n\tcase '*': // \"ar*\"\n\tcase 'R': // \"arR\"\n\tcase 'j': // \"arj\"\n\tcase 'i': // \"ari\"\n\tcase '\\0': // \"ar\"\n\t\t__anal_reg_list (core, type, size, str[0]);\n\t\tbreak;\n\tcase ' ': { // \"ar \"\n\t\targ = strchr (str + 1, '=');\n\t\tif (arg) {\n\t\t\t*arg = 0;\n\t\t\tut64 n = r_num_math (core->num, arg + 1);\n\t\t\tchar *ostr = r_str_trim_dup (str + 1);\n\t\t\tchar *regname = r_str_trim_nc (ostr);\n\t\t\tif (!reg_name_roll_set (core, regname, n)) {\n\t\t\t\tR_LOG_ERROR (\"ar: Unknown register '%s'\", regname);\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\treturn;\n\t\t}\n\t\tchar name[32];\n\t\tint i = 1, j;\n\t\twhile (str[i]) {\n\t\t\tif (str[i] == ',') {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tfor (j = i; str[++j] && str[j] != ','; );\n\t\t\t\tif (j - i + 1 <= sizeof name) {\n\t\t\t\t\tr_str_ncpy (name, str + i, j - i + 1);\n\t\t\t\t\tif (IS_DIGIT (name[0])) { // e.g. ar 32\n\t\t\t\t\t\t__anal_reg_list (core, R_REG_TYPE_GPR, atoi (name), '\\0');\n\t\t\t\t\t} else if (showreg (core, name) > 0) {\n\t\t\t\t\t\t// e.g. ar rax\n\t\t\t\t\t} else { // e.g. ar gpr ; ar all\n\t\t\t\t\t\ttype = r_reg_type_by_name (name);\n\t\t\t\t\t\t// TODO differentiate ALL and illegal register types and print error message for the latter\n\t\t\t\t\t\t__anal_reg_list (core, type, -1, '\\0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nR_API int r_core_esil_step(RCore *core, ut64 until_addr, const char *until_expr, ut64 *prev_addr, bool stepOver) {\n#define return_tail(x) { tail_return_value = x; goto tail_return; }\n\tint tail_return_value = 0;\n\tint ret;\n\tut8 code[32];\n\tRAnalOp op = {0};\n\tREsil *esil = core->anal->esil;\n\t// esil->trap = 0;\n\tconst char *_pcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (R_STR_ISEMPTY (_pcname)) {\n\t\tR_LOG_ERROR (\"Cannot find =PC in current reg profile\");\n\t\treturn 0;\n\t}\n\tchar *pcname = strdup (_pcname);\n\tconst bool r2wars = r_config_get_b (core->config, \"cfg.r2wars\");\n\tconst bool breakoninvalid = r_config_get_b (core->config, \"esil.breakoninvalid\");\n\tconst int esiltimeout = r_config_get_i (core->config, \"esil.timeout\");\n\tut64 startTime = 0;\n\n\tif (esiltimeout > 0) {\n\t\tstartTime = r_time_now_mono ();\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tut64 addr = -1;\n\tut64 oaddr = -1;\n\tint minopsz = r_arch_info (core->anal->arch, R_ARCH_INFO_MIN_OP_SIZE);\n\tut64 naddr = addr + minopsz;\n\tbool notfirst = false;\n\tfor (; true; r_anal_op_fini (&op)) {\n\t\tesil->trap = 0;\n\t\toaddr = addr;\n\t\taddr = r_reg_getv (core->anal->reg, \"PC\");\n\t\tif (notfirst && addr == oaddr) {\n\t\t\tr_reg_setv (core->anal->reg, \"PC\", naddr);\n\t\t\taddr = naddr;\n\t\t} else {\n\t\t\tnotfirst = true;\n\t\t}\n\t\tR_LOG_DEBUG (\"esil step at 0x%08\"PFMT64x, addr);\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tR_LOG_INFO (\"[+] ESIL emulation interrupted at 0x%08\" PFMT64x, addr);\n\t\t\treturn_tail (0);\n\t\t}\n\t\t// Break if we have exceeded esil.timeout\n\t\tif (esiltimeout > 0) {\n\t\t\tut64 elapsedTime = r_time_now_mono () - startTime;\n\t\t\telapsedTime >>= 20;\n\t\t\tif (elapsedTime >= esiltimeout) {\n\t\t\t\tR_LOG_INFO (\"[ESIL] Timeout exceeded\");\n\t\t\t\treturn_tail (0);\n\t\t\t}\n\t\t}\n\t\tif (prev_addr) {\n\t\t\t*prev_addr = addr;\n\t\t}\n\t\tconst int perm = esil->exectrap ? R_PERM_X: 0;\n\t\tif (!r_io_is_valid_offset (core->io, addr, perm)) {\n\t\t\tesil->trap = R_ANAL_TRAP_EXEC_ERR;\n\t\t\tesil->trap_code = addr;\n\t\t\tR_LOG_INFO (\"[ESIL] Trap, trying to execute on non-executable memory\");\n\t\t\treturn_tail (1);\n\t\t}\n\t\t// eprintf (\"addr %llx\\n\", addr);\n\t\tr_asm_set_pc (core->rasm, addr);\n\t\t// run esil pin command here\n\t\tconst char *pincmd = r_anal_pin_call (core->anal, addr);\n\t\tif (pincmd) {\n\t\t\tr_core_cmd0 (core, pincmd);\n\t\t\tut64 pc = r_reg_getv (core->anal->reg, pcname);\n\t\t\tif (addr != pc) {\n\t\t\t\tR_LOG_ERROR (\"pincmd fail\");\n\t\t\t\treturn_tail (1);\n\t\t\t}\n\t\t}\n\t\tint dataAlign = r_anal_archinfo (esil->anal, R_ANAL_ARCHINFO_DATA_ALIGN);\n\t\tif (dataAlign > 1) {\n\t\t\tif (addr % dataAlign) {\n\t\t\t\tif (esil->cmd && R_STR_ISNOTEMPTY (esil->cmd_trap)) {\n\t\t\t\t\tesil->cmd (esil, esil->cmd_trap, addr, R_ANAL_TRAP_UNALIGNED);\n\t\t\t\t}\n\t\t\t\tif (breakoninvalid) {\n\t\t\t\t\tR_LOG_INFO (\"Execution stopped on unaligned instruction (see e?esil.breakoninvalid)\");\n\t\t\t\t\treturn_tail (0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t(void) r_io_read_at (core->io, addr, code, sizeof (code));\n\t\t// TODO: sometimes this is dupe\n\t\tret = r_anal_op (core->anal, &op, addr, code, sizeof (code), R_ARCH_OP_MASK_ESIL | R_ARCH_OP_MASK_HINT);\n\t\tnaddr = addr + op.size;\n\t\t// if type is JMP then we execute the next N instructions\n\t\t// update the esil pointer because RAnal.op() can change it\n\t\tesil = core->anal->esil;\n\t\tif (op.size < 1 || ret < 1) {\n\t\t\t// eprintf (\"esil trap\\n\");\n\t\t\tif (esil->cmd && R_STR_ISNOTEMPTY (esil->cmd_trap)) {\n\t\t\t\tesil->cmd (esil, esil->cmd_trap, addr, R_ANAL_TRAP_INVALID);\n\t\t\t}\n\t\t\tif (breakoninvalid) {\n\t\t\t\tR_LOG_INFO (\"Stopped execution in an invalid instruction (see e??esil.breakoninvalid)\");\n\t\t\t\treturn_tail (0);\n\t\t\t}\n\t\t\tif (op.size < 1) {\n\t\t\t\top.size = 1; // avoid inverted stepping\n\t\t\t}\n\t\t}\n\t\tif (stepOver) {\n\t\t\tswitch (op.type) {\n\t\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tcase R_ANAL_OP_TYPE_CRET:\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\t\tif (addr == until_addr) {\n\t\t\t\t\treturn_tail (0);\n\t\t\t\t} else {\n\t\t\t\t\tr_reg_setv (core->anal->reg, pcname, op.addr + op.size);\n\t\t\t\t\tr_reg_setv (core->dbg->reg, pcname, op.addr + op.size);\n\t\t\t\t}\n\t\t\t\treturn_tail (1);\n\t\t\t}\n\t\t}\n\t\tif (r2wars) {\n\t\t\t// this is x86 and r2wars specific, shouldnt hurt outside x86\n\t\t\tut64 vECX = r_reg_getv (core->anal->reg, \"ecx\");\n\t\t\tif (op.prefix  & R_ANAL_OP_PREFIX_REP && vECX > 1) {\n\t\t\t\t//char *tmp = strstr (op.esil.ptr, \",ecx,?{,5,GOTO,}\");\n\t\t\t\tchar *tmp = strstr (op.esil.ptr, \",0,GOTO\");\n\t\t\t\tif (tmp) {\n\t\t\t\t\ttmp[0] = 0;\n\t\t\t\t\top.esil.len -= 7; //16;\n\t\t\t\t} else {\n\t\t\t\t\tr_reg_setv (core->anal->reg, pcname, addr + op.size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_reg_setv (core->anal->reg, pcname, addr + op.size);\n\t\t\t}\n\t\t} else {\n\t\t\tr_reg_setv (core->anal->reg, pcname, addr + op.size);\n\t\t}\n\t\tif (ret) {\n\t\t\tr_esil_set_pc (esil, addr);\n\t\t\tconst char *e = R_STRBUF_SAFEGET (&op.esil);\n\t\t\tif (core->dbg->trace->enabled) {\n\t\t\t\tRReg *reg = core->dbg->reg;\n\t\t\t\tcore->dbg->reg = core->anal->reg;\n\t\t\t\tr_debug_trace_op (core->dbg, &op);\n\t\t\t\tcore->dbg->reg = reg;\n\t\t\t} else if (R_STR_ISNOTEMPTY (e)) {\n\t\t\t\tr_esil_parse (esil, e);\n\t\t\t\tif (esil->trap) {\n\t\t\t\t\tR_LOG_WARN (\"ESIL TRAP %d/%d ON %s at 0x%08\"PFMT64x,\n\t\t\t\t\t\t\tesil->trap, esil->trap_code, e, addr);\n\t\t\t\t\tif (r_config_get_b (core->config, \"esil.exectrap\")) {\n\t\t\t\t\t\tR_LOG_INFO (\"ESIL TRAP ignored\");\n\t\t\t\t\t\tesil->trap = false;\n\t\t\t\t\t}\n\t\t\t\t}\n#if 0\n\t\t\t\t// XXX thats not related to arch plugins, and wonder if its useful at all or we want it as part of the anal or esil plugs\n\t\t\t\tif (core->anal->cur && core->anal->cur->esil_post_loop) {\n\t\t\t\t\tcore->anal->cur->esil_post_loop (esil, &op);\n\t\t\t\t}\n#endif\n\t\t\t\t// warn if esil stack is not empty\n\t\t\t\tr_esil_stack_free (esil);\n\t\t\t}\n\t\t\tbool isNextFall = false;\n\t\t\tif (op.type == R_ANAL_OP_TYPE_CJMP) {\n\t\t\t\tint err = 0;\n\t\t\t\tut64 pc = r_reg_getv (core->anal->reg, pcname);\n\t\t\t\tif (err) {\n\t\t\t\t\tR_LOG_ERROR (\"Missing PC register in the current profile\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (pc == addr + op.size) {\n\t\t\t\t\t// do not opdelay here\n\t\t\t\t\tisNextFall = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// only support 1 slot for now\n\t\t\tif (op.delay && !isNextFall) {\n\t\t\t\tut8 code2[32];\n\t\t\t\t// ut64 naddr = addr + op.size;\n\t\t\t\tRAnalOp op2 = {0};\n\t\t\t\t// emulate only 1 instruction\n\t\t\t\tr_esil_set_pc (esil, naddr);\n\t\t\t\t(void)r_io_read_at (core->io, naddr, code2, sizeof (code2));\n\t\t\t\t// TODO: sometimes this is dupe\n\t\t\t\tret = r_anal_op (core->anal, &op2, naddr, code2, sizeof (code2), R_ARCH_OP_MASK_ESIL | R_ARCH_OP_MASK_HINT);\n\t\t\t\tif (ret > 0) {\n\t\t\t\t\tswitch (op2.type) {\n\t\t\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_CRET:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\t\t\t\t// branches are illegal in a delay slot\n\t\t\t\t\t\tesil->trap = R_ANAL_TRAP_EXEC_ERR;\n\t\t\t\t\t\tesil->trap_code = addr;\n\t\t\t\t\t\tR_LOG_INFO (\"[ESIL] Trap, trying to execute a branch in a delay slot\");\n\t\t\t\t\t\treturn_tail (1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst char *e = R_STRBUF_SAFEGET (&op2.esil);\n\t\t\t\t\tif (R_STR_ISNOTEMPTY (e)) {\n\t\t\t\t\t\tr_esil_parse (esil, e);\n\t\t\t\t\t\tesil->trap = false; // ignore traps on delayed instructions for now\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Invalid instruction at 0x%08\"PFMT64x, naddr);\n\t\t\t\t}\n\t\t\t\tr_anal_op_fini (&op2);\n\t\t\t}\n\t\t\ttail_return_value = 1;\n\t\t}\n\t\t// esil->verbose ?\n\t\t// eprintf (\"REPE 0x%llx %s => 0x%llx\\n\", addr, R_STRBUF_SAFEGET (&op.esil), r_reg_getv (core->anal->reg, \"PC\"));\n\t\tut64 pc = r_reg_getv (core->anal->reg, pcname);\n\t\tif (pc == UT64_MAX || pc == UT32_MAX) {\n\t\t\tR_LOG_ERROR (\"Invalid program counter PC=-1 coming from 0x%08\"PFMT64x, addr);\n\t\t\tbreak;\n\t\t}\n\t\tif (core->anal->config->codealign > 0) {\n\t\t\tpc -= (pc % core->anal->config->codealign);\n\t\t\tr_reg_setv (core->anal->reg, pcname, pc);\n\t\t\tr_reg_setv (core->dbg->reg, pcname, pc);\n\t\t}\n\t\tst64 follow = (st64)r_config_get_i (core->config, \"dbg.follow\");\n\t\tif (follow > 0) {\n\t\t\tif ((pc < core->offset) || (pc > (core->offset + follow))) {\n\t\t\t\tr_core_seek (core, pc, true);\n\t\t\t}\n\t\t}\n\t\t// check breakpoints\n\t\tif (r_bp_get_at (core->dbg->bp, pc)) {\n\t\t\tR_LOG_INFO (\"esil breakpoint hit at 0x%\"PFMT64x, pc);\n\t\t\treturn_tail (0);\n\t\t}\n\t\t// check addr\n\t\tif (until_addr != UT64_MAX) {\n\t\t\tif (pc == until_addr) {\n\t\t\t\treturn_tail (0);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n#if 1\n\t\tif (esil->trap) {\n\t\t\tR_LOG_DEBUG (\"TRAP\");\n\t\t\treturn_tail (0);\n\t\t}\n#endif\n\t\tif (until_expr) {\n\t\t\t// eprintf (\"CHK %s\\n\", until_expr);\n\t\t\tif (r_esil_condition (esil, until_expr)) {\n\t\t\t\tR_LOG_INFO (\"ESIL BREAK!\");\n\t\t\t\treturn_tail (0);\n\t\t\t}\n\t\t\tesil->trap = false;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\ntail_return:\n\tr_anal_op_fini (&op);\n\tr_cons_break_pop ();\n\tfree (pcname);\n\treturn tail_return_value;\n}\n\nR_API bool r_core_esil_step_back(RCore *core) {\n\tr_return_val_if_fail (core && core->anal, false);\n#if 0\n\tif (!core->anal->esil || !core->anal->esil->trace) {\n\t\tR_LOG_INFO (\"Run `aeim` to initialize the esil VM and enable e dbg.trace=true\");\n\t\treturn false;\n\t}\n#endif\n\tREsil *esil = core->anal->esil;\n\tif (esil && esil->trace->idx > 0) {\n\t\tr_esil_trace_restore (esil, esil->trace->idx - 1);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void cmd_address_info(RCore *core, const char *addrstr, int fmt) {\n\tut64 addr = R_STR_ISEMPTY (addrstr)? core->offset: r_num_math (core->num, addrstr);\n\tut64 type = r_core_anal_address (core, addr);\n\tswitch (fmt) {\n\tcase 'j': {\n\t\tPJ *pj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_o (pj);\n\t\tif (type & R_ANAL_ADDR_TYPE_PROGRAM) {\n\t\t\tpj_ks (pj, \"program\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_LIBRARY) {\n\t\t\tpj_ks (pj, \"library\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_EXEC) {\n\t\t\tpj_ks (pj, \"exec\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_READ) {\n\t\t\tpj_ks (pj, \"read\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_WRITE) {\n\t\t\tpj_ks (pj, \"write\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_FLAG) {\n\t\t\tpj_ks (pj, \"flag\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_FUNC) {\n\t\t\tpj_ks (pj, \"func\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_STACK) {\n\t\t\tpj_ks (pj, \"stack\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_HEAP) {\n\t\t\tpj_ks (pj, \"heap\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_REG) {\n\t\t\tpj_ks (pj, \"reg\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_ASCII) {\n\t\t\tpj_ks (pj, \"ascii\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_SEQUENCE) {\n\t\t\tpj_ks (pj, \"sequence\", \"true\");\n\t\t}\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (type & R_ANAL_ADDR_TYPE_PROGRAM) {\n\t\t\tr_cons_printf (\"program\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_LIBRARY) {\n\t\t\tr_cons_printf (\"library\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_EXEC) {\n\t\t\tr_cons_printf (\"exec\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_READ) {\n\t\t\tr_cons_printf (\"read\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_WRITE) {\n\t\t\tr_cons_printf (\"write\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_FLAG) {\n\t\t\tr_cons_printf (\"flag\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_FUNC) {\n\t\t\tr_cons_printf (\"func\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_STACK) {\n\t\t\tr_cons_printf (\"stack\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_HEAP) {\n\t\t\tr_cons_printf (\"heap\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_REG) {\n\t\t\tr_cons_printf (\"reg\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_ASCII) {\n\t\t\tr_cons_printf (\"ascii\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_SEQUENCE) {\n\t\t\tr_cons_printf (\"sequence\\n\");\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_info(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_ai);\n\t\tbreak;\n\tcase ' ':\n\t\tcmd_address_info (core, input, 0);\n\t\tbreak;\n\tcase 'a': // \"aia\"\n\t\tif (input[1] == 'j') { // \"aiaj\"\n\t\t\tPJ *pj = pj_new ();\n\t\t\tpj_o (pj);\n\t\t\tint v = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\t\tpj_ki (pj, \"minopsz\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\t\tpj_ki (pj, \"maxopsz\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_INV_OP_SIZE);\n\t\t\tpj_ki (pj, \"invopsz\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_DATA_ALIGN);\n\t\t\tpj_ki (pj, \"dtalign\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tpj_ki (pj, \"codealign\", v);\n\t\t\tpj_end (pj);\n\t\t\tchar *s = pj_drain (pj);\n\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\tfree (s);\n\t\t} else {\n\t\t\tint v = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\t\tr_cons_printf (\"minopsz %d\\n\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\t\tr_cons_printf (\"maxopsz %d\\n\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_INV_OP_SIZE);\n\t\t\tr_cons_printf (\"invopsz %d\\n\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_DATA_ALIGN);\n\t\t\tr_cons_printf (\"dtalign %d\\n\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tr_cons_printf (\"codealign %d\\n\", v);\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"aii\"\n\t\t// global imports\n\t\tif (input[1]) {\n\t\t\tif (input[1] == ' ') {\n\t\t\t\tchar *s = r_str_trim_dup (input + 1);\n\t\t\t\tif (s) {\n\t\t\t\t\tr_anal_add_import (core->anal, s);\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n\t\t\t} else if (input[1] == '-') {\n\t\t\t\tr_anal_purge_imports (core->anal);\n\t\t\t} else {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_ai, \"aii\", true);\n\t\t\t}\n\t\t} else {\n\t\t\tif (core->anal->imports) {\n\t\t\t\tchar *imp;\n\t\t\t\tRListIter *iter;\n\t\t\t\tr_list_foreach (core->anal->imports, iter, imp) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", imp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"aij\"\n\t\tcmd_address_info (core, input + 1, 'j');\n\t\tbreak;\n\tdefault:\n\t\tcmd_address_info (core, NULL, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void initialize_stack(RCore *core, ut64 addr, ut64 size) {\n\tconst char *mode = r_config_get (core->config, \"esil.fillstack\");\n\tif (mode && *mode && *mode != '0') {\n\t\tconst ut64 bs = 4096 * 32;\n\t\tut64 i;\n\t\tfor (i = 0; i < size; i += bs) {\n\t\t\tut64 left = R_MIN (bs, size - i);\n\t\t//\tr_core_cmdf (core, \"wx 10203040 @ 0x%llx\", addr);\n\t\t\tswitch (*mode) {\n\t\t\tcase 'd': // \"debrujn\"\n\t\t\t\tr_core_cmdf (core, \"wopD %\"PFMT64u\" @ 0x%\"PFMT64x, left, addr + i);\n\t\t\t\tbreak;\n\t\t\tcase 's': // \"seq\"\n\t\t\t\tr_core_cmdf (core, \"woe 1 0xff 1 4 @ 0x%\"PFMT64x\"!0x%\"PFMT64x, addr + i, left);\n\t\t\t\tbreak;\n\t\t\tcase 'r': // \"random\"\n\t\t\t\tr_core_cmdf (core, \"woR %\"PFMT64u\" @ 0x%\"PFMT64x\"!0x%\"PFMT64x, left, addr + i, left);\n\t\t\t\tbreak;\n\t\t\tcase 'z': // \"zero\"\n\t\t\tcase '0':\n\t\t\t\tr_core_cmdf (core, \"wow 00 @ 0x%\"PFMT64x\"!0x%\"PFMT64x, addr + i, left);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// eprintf (\"[*] Initializing ESIL stack with pattern\\n\");\n\t\t// r_core_cmdf (core, \"woe 0 10 4 @ 0x%\"PFMT64x, size, addr);\n\t}\n}\n\nstatic void cmd_esil_mem(RCore *core, const char *input) {\n\tREsil *esil = core->anal->esil;\n\tRIOMap *stack_map;\n\tut64 curoff = core->offset;\n\tconst char *patt = \"\";\n\tut64 addr = 0x100000;\n\tut32 size = 0xf0000;\n\tRFlagItem *fi;\n\tchar uri[32];\n\tchar nomalloc[256];\n\tif (*input == '?') {\n\t\tr_core_cmd_help (core, help_msg_aeim);\n\t\treturn;\n\t}\n\tif (r_config_get_b (core->config, \"cfg.debug\")) {\n\t\tR_LOG_WARN (\"When cfg.debug is set, I refuse to create a fake stack\");\n\t\treturn;\n\t}\n\n\tif (input[0] == 'p') {\n\t\tfi = r_flag_get (core->flags, \"aeim.stack\");\n\t\tif (fi) {\n\t\t\taddr = fi->offset;\n\t\t\tsize = fi->size;\n\t\t} else {\n\t\t\tcmd_esil_mem (core, \"\");\n\t\t}\n\t\tesil->stack_addr = addr;\n\t\tesil->stack_size = size;\n\t\tinitialize_stack (core, addr, size);\n\t\treturn;\n\t}\n\n\tif (R_STR_ISEMPTY (input)) {\n\t\tchar *fi = sdb_get (core->sdb, \"aeim.fd\", 0);\n\t\tif (fi) {\n\t\t\t// Close the fd associated with the aeim stack\n\t\t\tut64 fd = sdb_atoi (fi);\n\t\t\t(void)r_io_fd_close (core->io, fd);\n\t\t\tfree (fi);\n\t\t}\n\t}\n\tsize = r_config_get_i (core->config, \"esil.stack.size\");\n\taddr = r_config_get_i (core->config, \"esil.stack.addr\");\n\n\tif (r_io_map_is_mapped (core->io, addr)) {\n\t\taddr = core->offset;\n\t\tr_io_map_locate (core->io, &addr, size, 0x10000000);\n\t}\n\tpatt = r_config_get (core->config, \"esil.stack.pattern\");\n\tr_str_ncpy (nomalloc, input, 255);\n\tchar *p = nomalloc;\n\tchar *name = NULL;\n\tif ((p = strchr (p, ' '))) {\n\t\tp = (char *)r_str_trim_head_ro (p);\n\t\taddr = r_num_math (core->num, p);\n\t\tif ((p = strchr (p, ' '))) {\n\t\t\tp = (char *)r_str_trim_head_ro (p);\n\t\t\tsize = (ut32)r_num_math (core->num, p);\n\t\t\tif (size < 1) {\n\t\t\t\tsize = 0xf0000;\n\t\t\t}\n\t\t\tif ((p = strchr (p, ' '))) {\n\t\t\t\tp = (char *)r_str_trim_head_ro (p);\n\t\t\t\tname = r_str_newf (\"mem.%s\", p);\n\t\t\t} else {\n\t\t\t\tname = r_str_newf (\"mem.0x%\" PFMT64x \"_0x%x\", addr, size);\n\t\t\t}\n\t\t} else {\n\t\t\tname = r_str_newf (\"mem.0x%\" PFMT64x \"_0x%x\", addr, size);\n\t\t}\n\t} else {\n\t\tname = r_str_newf (\"mem.0x%\" PFMT64x \"_0x%x\", addr, size);\n\t}\n\tif (*input == '-') {\n\t\tif (esil->stack_fd > 2) { // 0, 1, 2 are reserved for stdio/stderr\n\t\t\tr_io_fd_close (core->io, esil->stack_fd);\n\t\t\t// no need to kill the maps, r_io_map_cleanup does that for us in the close\n\t\t\tesil->stack_fd = 0;\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot deinitialize %s\", name);\n\t\t}\n\t\tr_flag_unset_name (core->flags, name);\n\t\tr_flag_unset_name (core->flags, \"aeim.stack\");\n\t\tsdb_unset (core->sdb, \"aeim.fd\", 0);\n\t\tfree (name);\n\t\treturn;\n\t}\n\n\tsnprintf (uri, sizeof (uri), \"malloc://%d\", (int)size);\n\tesil->stack_fd = r_io_fd_open (core->io, uri, R_PERM_RW, 0);\n\tif (!(stack_map = r_io_map_add (core->io, esil->stack_fd, R_PERM_RW, 0LL, addr, size))) {\n\t\tr_io_fd_close (core->io, esil->stack_fd);\n\t\tR_LOG_ERROR (\"Cannot create map for tha stack, fd %d got closed again\", esil->stack_fd);\n\t\tesil->stack_fd = 0;\n\t\treturn;\n\t}\n\tr_io_map_set_name (stack_map, name);\n\tfree (name);\n\t// r_flag_set (core->flags, name, addr, size);\t//why is this here?\n\tchar val[128], *v;\n\tv = sdb_itoa (esil->stack_fd, 10, val, sizeof (val));\n\tsdb_set (core->sdb, \"aeim.fd\", v, 0);\n\n\tr_config_set_b (core->config, \"io.va\", true);\n\tif (R_STR_ISNOTEMPTY (patt)) {\n\t\tswitch (*patt) {\n\t\tcase '0':\n\t\t\t// do nothing\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tr_core_cmdf (core, \"wopD %d @ 0x%\"PFMT64x, size, addr);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tr_core_cmdf (core, \"woe 0 255 1 @ 0x%\"PFMT64x\"!%d\",addr, size);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tr_core_cmdf (core, \"woe 0 0xffff 1 4 @ 0x%\"PFMT64x\"!%d\",addr, size);\n\t\t\tbreak;\n\t\t}\n\t}\n\t// SP\n\tut64 sp = addr + (size / 2);\n\tr_reg_setv (core->anal->reg, \"SP\", sp);\n\tr_reg_setv (core->anal->reg, \"BP\", sp);\n\tr_reg_setv (core->anal->reg, \"PC\", curoff);\n\tr_core_cmd0 (core, \".ar*\");\n\tesil->stack_addr = addr;\n\tesil->stack_size = size;\n\tinitialize_stack (core, addr, size);\n\tr_core_seek (core, curoff, false);\n}\n\ntypedef struct {\n\tRList *regs;\n\tRList *regread;\n\tRList *regwrite;\n\tRList *regvalues;\n\tRList *inputregs;\n} AeaStats;\n\nstatic void aea_stats_init(AeaStats *stats) {\n\tstats->regs = r_list_newf (free);\n\tstats->regread = r_list_newf (free);\n\tstats->regwrite = r_list_newf (free);\n\tstats->regvalues = r_list_newf (free);\n\tstats->inputregs = r_list_newf (free);\n}\n\nstatic void aea_stats_fini(AeaStats *stats) {\n\tR_FREE (stats->regs);\n\tR_FREE (stats->regread);\n\tR_FREE (stats->regwrite);\n\tR_FREE (stats->inputregs);\n}\n\nstatic bool contains(RList *list, const char *name) {\n\tRListIter *iter;\n\tconst char *n;\n\tr_list_foreach (list, iter, n) {\n\t\tif (!strcmp (name, n))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic R_TH_LOCAL char *oldregread = NULL;\nstatic R_TH_LOCAL RList *mymemxsr = NULL;\nstatic R_TH_LOCAL RList *mymemxsw = NULL;\n\n#define R_NEW_DUP(x) memcpy((void*)malloc (sizeof (x)), &(x), sizeof (x))\ntypedef struct {\n\tut64 addr;\n\tint size;\n} AeaMemItem;\n\nstatic bool mymemwrite(REsil *esil, ut64 addr, const ut8 *buf, int len) {\n\tAeaMemItem *n;\n\tRListIter *iter;\n\tr_list_foreach (mymemxsw, iter, n) {\n\t\tif (addr == n->addr) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (!r_io_is_valid_offset (esil->anal->iob.io, addr, 0)) {\n\t\treturn false;\n\t}\n\tn = R_NEW (AeaMemItem);\n\tif (n) {\n\t\tn->addr = addr;\n\t\tn->size = len;\n\t\tr_list_push (mymemxsw, n);\n\t}\n\treturn true;\n}\n\nstatic bool mymemread(REsil *esil, ut64 addr, ut8 *buf, int len) {\n\tRListIter *iter;\n\tAeaMemItem *n;\n\tr_list_foreach (mymemxsr, iter, n) {\n\t\tif (addr == n->addr) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (!r_io_is_valid_offset (esil->anal->iob.io, addr, 0)) {\n\t\treturn false;\n\t}\n\tn = R_NEW (AeaMemItem);\n\tif (n) {\n\t\tn->addr = addr;\n\t\tn->size = len;\n\t\tr_list_push (mymemxsr, n);\n\t}\n\treturn true;\n}\n\nstatic bool myregwrite(REsil *esil, const char *name, ut64 *val) {\n\tAeaStats *stats = esil->user;\n\tif (oldregread && !strcmp (name, oldregread)) {\n\t\tr_list_pop (stats->regread);\n\t\tR_FREE (oldregread)\n\t}\n\tif (!IS_DIGIT (*name)) {\n\t\tif (!contains (stats->regs, name)) {\n\t\t\tr_list_push (stats->regs, strdup (name));\n\t\t}\n\t\tif (!contains (stats->regwrite, name)) {\n\t\t\tr_list_push (stats->regwrite, strdup (name));\n\t\t}\n\t\tchar *v = r_str_newf (\"%\"PFMT64d, *val);\n\t\tif (!contains (stats->regvalues, v)) {\n\t\t\tr_list_push (stats->regvalues, strdup (v));\n\t\t}\n\t\tfree (v);\n\t}\n\treturn false;\n}\n\nstatic bool myregread(REsil *esil, const char *name, ut64 *val, int *len) {\n\tAeaStats *stats = esil->user;\n\tif (!IS_DIGIT (*name)) {\n\t\tif (!contains (stats->inputregs, name)) {\n\t\t\tif (!contains (stats->regwrite, name)) {\n\t\t\t\tr_list_push (stats->inputregs, strdup (name));\n\t\t\t}\n\t\t}\n\t\tif (!contains (stats->regs, name)) {\n\t\t\tr_list_push (stats->regs, strdup (name));\n\t\t}\n\t\tif (!contains (stats->regread, name)) {\n\t\t\tr_list_push (stats->regread, strdup (name));\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void showregs(RList *list) {\n\tif (!r_list_empty (list)) {\n\t\tchar *reg;\n\t\tRListIter *iter;\n\t\tr_list_foreach (list, iter, reg) {\n\t\t\tr_cons_print (reg);\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_printf (\" \");\n\t\t\t}\n\t\t}\n\t}\n\tr_cons_newline ();\n}\n\nstatic void showmem(RList *list) {\n\tif (!r_list_empty (list)) {\n\t\tAeaMemItem *item;\n\t\tRListIter *iter;\n\t\tr_list_foreach (list, iter, item) {\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, item->addr);\n\n\t\t}\n\t}\n\tr_cons_newline ();\n}\n\nstatic void showregs_json(RList *list, PJ *pj) {\n\tpj_a (pj);\n\tif (!r_list_empty (list)) {\n\t\tchar *reg;\n\t\tRListIter *iter;\n\n\t\tr_list_foreach (list, iter, reg) {\n\t\t\tpj_s (pj, reg);\n\t\t}\n\t}\n\tpj_end (pj);\n}\n\nstatic void showmem_json(RList *list, PJ *pj) {\n\tpj_a (pj);\n\tif (!r_list_empty (list)) {\n\t\tRListIter *iter;\n\t\tAeaMemItem *item;\n\t\tr_list_foreach (list, iter, item) {\n\t\t\tpj_n (pj, item->addr);\n\t\t}\n\t}\n\tpj_end (pj);\n}\n\nstatic bool cmd_aea(RCore* core, int mode, ut64 addr, int length) {\n\tint ptr, ops, ops_end = 0, len, buf_sz;\n\tut64 addr_end;\n\tAeaStats stats;\n\tconst char *esilstr;\n\tRAnalOp aop = {0};\n\tRList* regnow;\n\tPJ *pj = NULL;\n\tif (!core) {\n\t\treturn false;\n\t}\n\tint maxopsize = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\tif (maxopsize < 1) {\n\t\tmaxopsize = 16;\n\t}\n\tif (mode & 1) {\n\t\t// number of bytes / length\n\t\tbuf_sz = length;\n\t} else {\n\t\t// number of instructions / opcodes\n\t\tops_end = length;\n\t\tif (ops_end < 1) {\n\t\t\tops_end = 1;\n\t\t}\n\t\tbuf_sz = ops_end * maxopsize;\n\t}\n\tif (buf_sz < 1) {\n\t\tbuf_sz = maxopsize;\n\t}\n\taddr_end = addr + buf_sz;\n\tut8 *buf = malloc (buf_sz);\n\tif (!buf) {\n\t\treturn false;\n\t}\n\t(void)r_io_read_at (core->io, addr, (ut8 *)buf, buf_sz);\n\taea_stats_init (&stats);\n\tr_reg_arena_push (core->anal->reg);\n\tconst bool cfg_r2wars = r_config_get_b (core->config, \"cfg.r2wars\");\n\tREsil *esil = esil_new_setup (core);\n\tif (!esil) {\n\t\tfree (buf);\n\t\treturn false;\n\t}\n#\tdefine hasNext(x) (x&1) ? (addr<addr_end) : (ops<ops_end)\n\n\tmymemxsr = r_list_new ();\n\tmymemxsw = r_list_new ();\n\tesil->user = &stats;\n\tesil->cb.hook_reg_write = myregwrite;\n\tesil->cb.hook_reg_read = myregread;\n\tesil->cb.hook_mem_write = mymemwrite;\n\tesil->cb.hook_mem_read = mymemread;\n\tesil->nowrite = true;\n\tr_cons_break_push (NULL, NULL);\n\tfor (ops = ptr = 0; ptr < buf_sz && hasNext (mode); ops++, ptr += len) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tlen = r_anal_op (core->anal, &aop, addr + ptr, buf + ptr, buf_sz - ptr, R_ARCH_OP_MASK_ESIL | R_ARCH_OP_MASK_HINT);\n\t\tesilstr = R_STRBUF_SAFEGET (&aop.esil);\n\t\tif (R_STR_ISNOTEMPTY (esilstr)) {\n\t\t\tif (len < 1) {\n\t\t\t\tR_LOG_ERROR (\"Invalid 0x%08\"PFMT64x\" instruction %02x %02x\",\n\t\t\t\t\taddr + ptr, buf[ptr], buf[ptr + 1]);\n\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cfg_r2wars) {\n\t\t\t\tif (aop.prefix  & R_ANAL_OP_PREFIX_REP) {\n\t\t\t\t\tchar *tmp = strstr (esilstr, \",0,GOTO\");\n\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\ttmp[0] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_esil_parse (esil, esilstr);\n\t\t\tr_esil_stack_free (esil);\n\t\t}\n\t\tr_anal_op_fini (&aop);\n\t\tif (len < 1) {\n\t\t\tlen = 1;\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\tesil->nowrite = false;\n\tesil->cb.hook_reg_write = NULL;\n\tesil->cb.hook_reg_read = NULL;\n\tr_esil_free (esil);\n\tr_reg_arena_pop (core->anal->reg);\n\tregnow = r_list_newf (free);\n\t{\n\t\tRListIter *iter;\n\t\tchar *reg;\n\t\tr_list_foreach (stats.regs, iter, reg) {\n\t\t\tif (!contains (stats.regwrite, reg)) {\n\t\t\t\tr_list_push (regnow, strdup (reg));\n\t\t\t}\n\t\t}\n\t}\n\tif ((mode >> 5) & 1) {\n\t\tRListIter *iter;\n\t\tAeaMemItem *n;\n\t\tint c = 0;\n\t\tr_cons_printf (\"f-mem.*\\n\");\n\t\tr_list_foreach (mymemxsr, iter, n) {\n\t\t\tr_cons_printf (\"f mem.read.%d 0x%08x @ 0x%08\"PFMT64x\"\\n\", c++, n->size, n->addr);\n\t\t}\n\t\tc = 0;\n\t\tr_list_foreach (mymemxsw, iter, n) {\n\t\t\tr_cons_printf (\"f mem.write.%d 0x%08x @ 0x%08\"PFMT64x\"\\n\", c++, n->size, n->addr);\n\t\t}\n\t}\n\n\t/* show registers used */\n\tif ((mode >> 1) & 1) {\n\t\tshowregs (stats.regread);\n\t} else if ((mode >> 2) & 1) {\n\t\tshowregs (stats.regwrite);\n\t} else if ((mode >> 3) & 1) {\n\t\tshowregs (regnow);\n\t} else if ((mode >> 4) & 1) {\n\t\tpj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn false;\n\t\t}\n\t\tpj_o (pj);\n\t\tpj_k (pj, \"A\");\n\t\tshowregs_json (stats.regs, pj);\n\t\tpj_k (pj, \"I\");\n\t\tshowregs_json (stats.inputregs, pj);\n\t\tpj_k (pj, \"R\");\n\t\tshowregs_json (stats.regread, pj);\n\t\tpj_k (pj, \"W\");\n\t\tshowregs_json (stats.regwrite, pj);\n\t\tif (!r_list_empty (stats.regvalues)) {\n\t\t\tpj_k (pj, \"V\");\n\t\t\tshowregs_json (stats.regvalues, pj);\n\t\t}\n\t\tif (!r_list_empty (regnow)) {\n\t\t\tpj_k (pj, \"N\");\n\t\t\tshowregs_json (regnow, pj);\n\t\t}\n\t\tif (!r_list_empty (mymemxsr)) {\n\t\t\tpj_k (pj, \"@R\");\n\t\t\tshowmem_json (mymemxsr, pj);\n\t\t}\n\t\tif (!r_list_empty (mymemxsw)) {\n\t\t\tpj_k (pj, \"@W\");\n\t\t\tshowmem_json (mymemxsw, pj);\n\t\t}\n\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t} else if ((mode >> 5) & 1) {\n\t\t// nothing\n\t} else {\n\t\tif (!r_list_empty (stats.inputregs)) {\n\t\t\tr_cons_printf (\" I: \");\n\t\t\tshowregs (stats.inputregs);\n\t\t}\n\t\tif (!r_list_empty (stats.regs)) {\n\t\t\tr_cons_printf (\" A: \");\n\t\t\tshowregs (stats.regs);\n\t\t}\n\t\tif (!r_list_empty (stats.regread)) {\n\t\t\tr_cons_printf (\" R: \");\n\t\t\tshowregs (stats.regread);\n\t\t}\n\t\tif (!r_list_empty (stats.regwrite)) {\n\t\t\tr_cons_printf (\" W: \");\n\t\t\tshowregs (stats.regwrite);\n\t\t}\n\t\tif (!r_list_empty (stats.regvalues)) {\n\t\t\tr_cons_printf (\" V: \");\n\t\t\tshowregs (stats.regvalues);\n\t\t}\n\t\tif (!r_list_empty (regnow)) {\n\t\t\tr_cons_printf (\" N: \");\n\t\t\tshowregs (regnow);\n\t\t}\n\t\tif (!r_list_empty (mymemxsr)) {\n\t\t\tr_cons_printf (\"@R:\");\n\t\t\tshowmem (mymemxsr);\n\t\t}\n\t\tif (!r_list_empty (mymemxsw)) {\n\t\t\tr_cons_printf (\"@W:\");\n\t\t\tshowmem (mymemxsw);\n\t\t}\n\t}\n\n\tr_list_free (mymemxsr);\n\tr_list_free (mymemxsw);\n\tmymemxsr = NULL;\n\tmymemxsw = NULL;\n\taea_stats_fini (&stats);\n\tfree (buf);\n\tR_FREE (regnow);\n\treturn true;\n}\n\nstatic void cmd_aespc(RCore *core, ut64 addr, ut64 until_addr, int ninstr) {\n\tREsil *esil = core->anal->esil;\n\tint i, j = 0;\n\tRAnalOp aop = {0};\n\tint ret , bsize = R_MAX (4096, core->blocksize);\n\tconst int mininstrsz = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tconst int minopcode = R_MAX (1, mininstrsz);\n\tconst char *pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);\n\n#if 0\n\t// eprintf (\"   aesB %llx %llx %d\\n\", addr, until_addr, off); // 0x%08llx %d  %s\\n\", aop.addr, ret, aop.mnemonic);\n\tif (!esil) {\n\t\tR_LOG_DEBUG (\"cmd_espc: creating new esil instance\");\n\t\tesil = esil_new_setup (core);\n\t\tif (!esil) {\n\t\t\treturn;\n\t\t}\n\t\tr_esil_free (core->anal->esil);\n\t\tcore->anal->esil = esil;\n\t}\n#endif\n\tut8 *buf = malloc (bsize);\n\tif (!buf) {\n\t\tR_LOG_ERROR (\"Cannot allocate %d byte(s)\", bsize);\n\t\treturn;\n\t}\n\tif (addr == UT64_MAX) {\n\t\taddr = r_reg_getv (core->dbg->reg, pc);\n\t}\n\tut64 cursp = r_reg_getv (core->dbg->reg, \"SP\");\n\tut64 oldoff = core->offset;\n\tconst ut64 flags = R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT | R_ARCH_OP_MASK_ESIL | R_ARCH_OP_MASK_DISASM;\n\tfor (i = 0, j = 0; j < ninstr; i++, j++) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tif (i >= (bsize - 32)) {\n\t\t\ti = 0;\n\t\t\tR_LOG_WARN (\"Chomp %d of %d\", i, bsize);\n\t\t}\n\t\tif (!i) {\n\t\t\tr_io_read_at (core->io, addr, buf, bsize);\n\t\t}\n\t\tif (addr == until_addr) {\n\t\t\tbreak;\n\t\t}\n\t\tret = r_anal_op (core->anal, &aop, addr, buf + i, bsize - i, flags);\n\t\tif (ret < 1) {\n\t\t\tR_LOG_ERROR (\"Failed analysis at 0x%08\"PFMT64x, addr);\n\t\t\tr_anal_op_fini (&aop);\n\t\t\tbreak;\n\t\t}\n\t\t// skip calls and such\n\t\tswitch (aop.type) {\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\tcase R_ANAL_OP_TYPE_CCALL:\n\t\tcase R_ANAL_OP_TYPE_UCCALL:\n\t\t\t// skip\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_reg_setv (core->anal->reg, \"PC\", aop.addr + aop.size);\n\t\t\tr_reg_setv (core->dbg->reg, \"PC\", aop.addr + aop.size);\n\t\t\tconst char *e = R_STRBUF_SAFEGET (&aop.esil);\n\t\t\tif (R_STR_ISNOTEMPTY (e)) {\n\t\t\t\t // eprintf (\"   0x%08llx %d  %s\\n\", aop.addr, ret, aop.mnemonic);\n\t\t\t\t(void)r_esil_parse (esil, e);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tint inc = (core->search->align > 0)? core->search->align - 1: ret - 1;\n\t\tif (inc < 0) {\n\t\t\tinc = minopcode;\n\t\t}\n\t\ti += inc;\n\t\taddr += aop.size;\n\t\tr_anal_op_fini (&aop);\n\t}\n\tfree (buf);\n\tr_core_seek (core, oldoff, true);\n\tr_reg_setv (core->dbg->reg, \"SP\", cursp);\n}\n\nstatic void r_anal_aefa(RCore *core, const char *arg) {\n\tut64 to = r_num_math (core->num, arg);\n\tut64 at, from = core->offset;\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, to, -1);\n\tif (!from || from == UT64_MAX) {\n\t\tif (fcn) {\n\t\t\tfrom = fcn->addr;\n\t\t} else {\n\t\t\tR_LOG_INFO (\"Usage: aefa [from] # if no from address is given, uses fcn.addr\");\n\t\t\treturn;\n\t\t}\n\t}\n\tR_LOG_INFO (\"Emulate from 0x%08\"PFMT64x\" to 0x%08\"PFMT64x, from, to);\n\tR_LOG_INFO (\"Resolve call args for 0x%08\"PFMT64x, to);\n\n\t// emulate\n\t// XXX do not use commands, here, just use the api\n\tr_core_cmd_call (core, \"aeim\"); // XXX\n\tut64 off = core->offset;\n\tfor (at = from; at < to ; at++) {\n\t\tr_core_cmdf (core, \"aepc 0x%08\"PFMT64x, at);\n\t\tr_core_cmd_call (core, \"aeso\");\n\t\tr_core_seek (core, at, true);\n\t\tint delta = r_num_get (core->num, \"$l\");\n\t\tif (delta < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tat += delta - 1;\n\t}\n\tr_core_seek (core, off, true);\n\n\t// the logic of identifying args by function types and\n\t// show json format and arg name goes into arA\n\tr_core_cmd_call (core, \"arA\");\n#if 0\n\t// get results\n\tconst char *fcn_type = r_type_func_ret (core->anal->sdb_types, fcn->name);\n\tconst char *key = resolve_fcn_name (core->anal, fcn->name);\n\tRList *list = r_core_get_func_args (core, key);\n\tif (!r_list_empty (list)) {\n\t\teprintf (\"HAS signature\\n\");\n\t}\n\tint i, nargs = 3; // r_type_func_args_count (core->anal->sdb_types, fcn->name);\n\tif (nargs > 0) {\n\t\tint i;\n\t\teprintf (\"NARGS %d (%s)\\n\", nargs, key);\n\t\tfor (i = 0; i < nargs; i++) {\n\t\t\tut64 v = r_debug_arg_get (core->dbg, \"reg\", i);\n\t\t\teprintf (\"arg: 0x%08\"PFMT64x\"\\n\", v);\n\t\t}\n\t}\n#endif\n}\n\nstatic void __core_anal_appcall(RCore *core, const char *input) {\n//\tr_reg_arena_push (core->dbg->reg);\n\tRListIter *iter;\n\tchar *arg;\n\tchar *inp = strdup (input);\n\tRList *args = r_str_split_list (inp, \" \", 0);\n\tint i = 0;\n\tr_list_foreach (args, iter, arg) {\n\t\tr_strf_var (alias, 32, \"A%d\", i);\n\t\tr_reg_setv (core->anal->reg, alias, r_num_math (core->num, arg));\n\t\ti++;\n\t}\n\tut64 sp = r_reg_getv (core->anal->reg, \"SP\");\n\tr_reg_setv (core->anal->reg, \"SP\", 0);\n\n\tr_reg_setv (core->anal->reg, \"PC\", core->offset);\n\tr_core_cmd_call (core, \"aesu 0\");\n\n\tr_reg_setv (core->anal->reg, \"SP\", sp);\n\tfree (inp);\n\n//\tr_reg_arena_pop (core->dbg->reg);\n}\n\nstatic void cmd_debug_stack_init(RCore *core, int argc, char **argv, char **envp) {\n\t// TODO: add support for 32 bit\n\tRBuffer *b = r_buf_new ();\n\tif (!b) {\n\t\treturn;\n\t}\n\tut64 sp = core->offset;\n\tint i;\n\tut64 dyld_call_from = UT64_MAX;\n\tr_buf_append_ut64 (b, dyld_call_from);\n\tr_buf_append_ut64 (b, 0); // rbp\n\tr_buf_append_ut64 (b, argc); // rbp\n\tint envp_count = 0;\n\tfor (i = 0; envp[i]; i++) {\n\t\tenvp_count++;\n\t}\n\tut64 strp = sp + 40 + (argc * 8) + (envp_count * 8);\n\t// pointer table\n\tfor (i = 0; i < argc && argv[i]; i++) {\n\t\tr_buf_append_ut64 (b, strp);\n\t\tstrp += strlen (argv[i]) + 1;\n\t}\n\tr_buf_append_ut64 (b, 0);\n\tfor (i = 0; i < envp_count; i++) {\n\t\tr_buf_append_ut64 (b, strp);\n\t\tstrp += strlen (envp[i]) + 1;\n\t}\n\tr_buf_append_ut64 (b, 0);\n\t// string table\n\tfor (i = 0; i < argc && argv[i]; i++) {\n\t\tr_buf_append_string (b, argv[i]);\n\t\tr_buf_append_ut8 (b, 0);\n\t}\n\tfor (i = 0; i < envp_count; i++) {\n\t\tr_buf_append_string (b, envp[i]);\n\t\tr_buf_append_ut8 (b, 0);\n\t}\n\tint slen = 0;\n\tut8 *s = r_buf_read_all (b, &slen);\n\tchar *x = r_hex_bin2strdup (s, slen);\n\tr_cons_printf (\"wx %s\\n\", x);\n\tfree (x);\n\tfree (s);\n\tr_buf_free (b);\n}\n\nR_IPI int core_type_by_addr(RCore *core, ut64 addr) {\n\tconst RList *list = r_flag_get_list (core->flags, addr);\n\tRListIter *iter;\n\tRFlagItem *item;\n\tbool has_flag = false;\n\tint type = R_ANAL_REF_TYPE_DATA;\n\tr_list_foreach (list, iter, item) {\n\t\tif (strchr (item->name, '.')) {\n\t\t\thas_flag = true;\n\t\t\tif (r_str_startswith (item->name, \"str\")) {\n\t\t\t\ttype = R_ANAL_REF_TYPE_STRN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!has_flag) {\n\t\treturn -1;\n\t}\n\treturn type;\n}\n\nstatic bool regwrite_hook(REsil *esil, const char *name, ut64 *val) {\n\tRCore *core = esil->user;\n\tint type = core_type_by_addr (core, *val);\n\tif (type != -1) {\n\t\tr_anal_xrefs_set (core->anal, esil->addr, *val, type);\n\t}\n\treturn false;\n}\n\nstatic void __anal_esil_function(RCore *core, ut64 addr) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n#if 0\n\tif (!core->anal->esil) {\n\t\tr_core_cmd_call (core, \"aei\");\n\t}\n#endif\n\tif (!sdb_const_get (core->sdb, \"aeim.fd\", 0)) {\n\t\tr_core_cmd_call (core, \"aeim\"); // should be set by default imho\n\t}\n\tvoid *u = core->anal->esil->user;\n\tcore->anal->esil->user = core;\n\tvoid *p = core->anal->esil->cb.hook_reg_write;\n\tcore->anal->esil->cb.hook_reg_write = regwrite_hook;\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal,\n\t\t\taddr, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\tconst char *pcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tconst ut64 old_pc = r_reg_getv (core->anal->reg, pcname);\n\tif (fcn) {\n\t\tbool anal_verbose = r_config_get_b (core->config, \"anal.verbose\");\n\t\t// emulate every instruction in the function recursively across all the basic blocks\n\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\tut64 pc = bb->addr;\n\t\t\tut64 end = bb->addr + bb->size;\n\t\t\tRAnalOp op;\n\t\t\tint ret, bbs = end - pc;\n\t\t\tif (bbs < 1 || bbs > 0xfffff || pc >= end) {\n\t\t\t\tR_LOG_ERROR (\"Invalid block size\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// eprintf (\"[*] Emulating 0x%08\"PFMT64x\" basic block 0x%08\" PFMT64x \" - 0x%08\" PFMT64x \"\\r[\", fcn->addr, pc, end);\n\t\t\tut8 *buf = calloc (1, bbs + 1);\n\t\t\tif (!buf) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// const char *pcname = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);\n\t\t\tr_io_read_at (core->io, pc, buf, bbs);\n\t\t\tint left;\n\t\t\twhile (pc < end) {\n\t\t\t\tleft = R_MIN (end - pc, 32);\n\t\t\t\t// r_asm_set_pc (core->rasm, pc);\n\t\t\t\tret = r_anal_op (core->anal, &op, pc, buf + pc - bb->addr, left, R_ARCH_OP_MASK_HINT | R_ARCH_OP_MASK_ESIL| R_ARCH_OP_MASK_DISASM); // read overflow\n\t\t\t\tif (ret) {\n\t\t\t\t\tbool opskip = false;\n#if 0\n\t\t\t\t\tswitch (op.type) {\n\t\t\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\t\t\t\topskip = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (!opskip) {\n\t\t\t\t\t\tconst char *esilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\t\t\t\t\t// eprintf (\"0x%08\"PFMT64x\"  %s\\n\", pc, op.mnemonic);\n\t\t\t\t\t\tif (R_STR_ISNOTEMPTY (esilstr)) {\n\t\t\t\t\t\t\tr_reg_setv (core->anal->reg, pcname, pc + op.size);\n\t\t\t\t\t\t\tr_esil_set_pc (core->anal->esil, pc);\n\t\t\t\t\t\t\tr_esil_parse (core->anal->esil, esilstr);\n\t\t\t\t\t\t\tif (anal_verbose) {\n\t\t\t\t\t\t\t\tr_esil_dumpstack (core->anal->esil);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr_esil_stack_free (core->anal->esil);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpc += op.size;\n\t\t\t\t} else {\n\t\t\t\t\tpc += 4; // XXX\n\t\t\t\t}\n\t\t\t\tr_anal_op_fini (&op);\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot find function at 0x%08\" PFMT64x, addr);\n\t}\n\tcore->anal->esil->cb.hook_reg_write = p;\n\tcore->anal->esil->user = u;\n\tr_reg_setv (core->anal->reg, pcname, old_pc);\n}\n\nstatic char *_aeg_get_title(void *data) {\n\tRAnalEsilDFGNode *enode = (RAnalEsilDFGNode *)data;\n\treturn r_str_newf (\"%d\", enode->idx);\n}\n\nstatic char *_aeg_get_body(void *data) {\n\tRAnalEsilDFGNode *enode = (RAnalEsilDFGNode *)data;\n\treturn r_str_newf (\"%s%s\",\n\t\t(enode->type & R_ANAL_ESIL_DFG_TAG_GENERATIVE)? \"generative:\": \"\",\n\t\tr_strbuf_get (enode->content));\n}\n\nstatic void cmd_aeg(RCore *core, int argc, char *argv[]) {\n\tr_return_if_fail (core && argc >= 0 && argv);\n\tRAGraphTransitionCBs cbs = {\n\t\t.get_title = _aeg_get_title,\n\t\t.get_body = _aeg_get_body\n\t};\n\tswitch (argv[0][1]) {\n\tcase '\\x00': // \"aeg\"\n\t\tif (argc == 1) {\n\t\t\tRAnalOp *aop = r_core_anal_op (core, core->offset, R_ARCH_OP_MASK_ESIL);\n\t\t\tif (!aop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst char *esilstr = r_strbuf_get (&aop->esil);\n\t\t\tif (R_STR_ISNOTEMPTY (esilstr)) {\n\t\t\t\tRAnalEsilDFG *dfg = r_anal_esil_dfg_expr (core->anal, NULL, esilstr,\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.mapinfo\"),\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.maps\"));\n\t\t\t\tif (!dfg) {\n\t\t\t\t\tr_anal_op_free (aop);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tRAGraph *agraph = r_agraph_new_from_graph (dfg->flow, &cbs);\n\t\t\t\tr_anal_esil_dfg_free (dfg);\n\t\t\t\tagraph->can->linemode = r_config_get_i (core->config, \"graph.linemode\");\n\t\t\t\tagraph->layout = r_config_get_i (core->config, \"graph.layout\");\n\t\t\t\tr_agraph_print (agraph);\n\t\t\t\tr_agraph_free (agraph);\n\t\t\t}\n\t\t\tr_anal_op_free (aop);\n\t\t} else {\n\t\t\tRStrBuf *sb = r_strbuf_new (\"\");\n\t\t\tint i;\n\t\t\tfor (i = 1; i < argc; i++) {\n\t\t\t\tif (r_strbuf_length (sb) > 0) {\n\t\t\t\t\tr_strbuf_append (sb, \",\");\n\t\t\t\t}\n\t\t\t\tr_strbuf_append (sb, argv[i]);\n\t\t\t}\n\t\t\tchar *esilexpr = r_strbuf_drain (sb);\n\t\t\tRAnalEsilDFG *dfg = r_anal_esil_dfg_expr (core->anal, NULL, esilexpr,\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.mapinfo\"),\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.maps\"));\n\t\t\tif (dfg) {\n\t\t\t\tRAGraph *agraph = r_agraph_new_from_graph (dfg->flow, &cbs);\n\t\t\t\tr_anal_esil_dfg_free (dfg);\n\t\t\t\tagraph->can->linemode = r_config_get_i (core->config, \"graph.linemode\");\n\t\t\t\tagraph->layout = r_config_get_i (core->config, \"graph.layout\");\n\t\t\t\tr_agraph_print (agraph);\n\t\t\t\tr_agraph_free (agraph);\n\t\t\t}\n\t\t\tfree (esilexpr);\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"aegb\"\n\t\tr_core_cmd0 (core, \"aeg `pieq $Fi`\");\n\t\tbreak;\n\tcase 'n': // \"aegn\"\n\t\tif (argc > 1) {\n\t\t\tint n = r_num_math (core->num, argv[1]);\n\t\t\tr_core_cmdf (core, \"aeg `pieq %d`\", n);\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Usage: aegn [number-of-instructions-to-combine-its-esil-essence]\");\n\t\t}\n\t\tbreak;\n\tcase 'v': // \"aegv\" - visual\n\t{\n\t\tRAGraph *agraph = NULL;\n\t\tif (argc == 1) {\n\t\t\tRAnalOp *aop = r_core_anal_op (core, core->offset, R_ARCH_OP_MASK_ESIL);\n\t\t\tif (!aop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst char *esilstr = r_strbuf_get (&aop->esil);\n\t\t\tif (R_STR_ISNOTEMPTY (esilstr)) {\n\t\t\t\tRAnalEsilDFG *dfg = r_anal_esil_dfg_expr (core->anal, NULL, esilstr,\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.mapinfo\"),\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.maps\"));\n\t\t\t\tif (!dfg) {\n\t\t\t\t\tr_anal_op_free (aop);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tagraph = r_agraph_new_from_graph (dfg->flow, &cbs);\n\t\t\t\tr_anal_esil_dfg_free (dfg);\n\t\t\t}\n\t\t\tr_anal_op_free (aop);\n\t\t} else {\n\t\t\tRAnalEsilDFG *dfg = r_anal_esil_dfg_expr (core->anal, NULL, argv[1],\n\t\t\t\tr_config_get_b (core->config, \"esil.dfg.mapinfo\"),\n\t\t\t\tr_config_get_b (core->config, \"esil.dfg.maps\"));\n\t\t\tr_return_if_fail (dfg);\n\t\t\tagraph = r_agraph_new_from_graph (dfg->flow, &cbs);\n\t\t\tr_anal_esil_dfg_free (dfg);\n\t\t}\n\t\tconst ut64 osc = r_config_get_i (core->config, \"scr.color\");\n\t\tr_config_set_i (core->config, \"scr.color\", 0);\n\t\tut64 oseek = core->offset;\n\t\tif (agraph) {\n\t\t\tagraph->need_update_dim = true;\n\t\t\t// layout\n\t\t\tagraph->layout = r_config_get_i (core->config, \"graph.layout\");\n\t\t\tagraph->need_set_layout = true;\n\t\t\tint update_seek = r_core_visual_graph (core, agraph, NULL, true);\n\t\t\tr_cons_show_cursor (true);\n\t\t\tr_cons_enable_mouse (false);\n\t\t\tif (update_seek != -1) {\n\t\t\t\tr_core_seek (core, oseek, false);\n\t\t\t}\n\t\t\tr_agraph_free (agraph);\n\t\t}\n\t\tr_config_set_i (core->config, \"scr.color\", osc);\n\t}\n\t\tbreak;\n\tcase 'f':\t// \"aegf\"\n\t{\n\t\tRStrBuf *filtered = r_anal_esil_dfg_filter_expr (core->anal, argv[1], argv[2],\n\t\t\tr_config_get_b (core->config, \"esil.dfg.mapinfo\"),\n\t\t\tr_config_get_b (core->config, \"esil.dfg.maps\"));\n\t\tif (filtered) {\n\t\t\tr_cons_printf (\"%s\\n\", r_strbuf_get (filtered));\n\t\t\tr_strbuf_free (filtered);\n\t\t}\n\t}\n\t\tbreak;\n#if 0\n\tcase 'c':\t// \"aegc\"\n\t{\n\t\tRAnalEsilDFG *dfg = r_anal_esil_dfg_expr (core->anal, NULL, argv[1]);\n\t\tif (!dfg) {\n\t\t\treturn;\n\t\t}\n\t\tr_anal_esil_dfg_fold_const (core->anal, dfg);\n\t\tif (argv[0][1] == 'f') {\t// \"aegcf\"\n\t\t\tRStrBuf *filtered = r_anal_esil_dfg_filter (dfg, argv[2]);\n\t\t\tif (filtered) {\n\t\t\t\tr_cons_printf (\"%s\\n\", r_strbuf_get (filtered));\n\t\t\t\tr_strbuf_free (filtered);\n\t\t\t}\n\t\t} else {\n\t\t\tprint_esil_dfg_as_commands (core, dfg);\n\t\t}\n\t\tr_anal_esil_dfg_free (dfg);\n\t}\n\t\tbreak;\n#endif\n\tcase '?': // \"aeg?\"\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_aeg);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_esil(RCore *core, const char *input, bool verbose) {\n\tREsil *esil = core->anal->esil;\n\tut64 addr = core->offset;\n\tut64 adr ;\n\tchar *n, *n1;\n\tint off;\n\tut64 until_addr = UT64_MAX;\n\n\tconst char *until_expr = NULL;\n\tRAnalOp *op = NULL;\n\n\tswitch (input[0]) {\n\tcase 'v': // \"aev\"\n\t\tr_core_visual_esil (core, r_str_trim_head_ro (input + 1));\n\t\tbreak;\n\tcase 'p': // \"aep\"\n\t\tswitch (input[1]) {\n\t\tcase 'a': // \"aepa\"\n\t\t\t{\n\t\t\t\tut64 at = core->offset;\n\t\t\t\tif (input[2] == ' ') {\n\t\t\t\t\tat = r_num_math (core->num, input + 2);\n\t\t\t\t}\n\t\t\t\t// get flag in current offset\n\t\t\t\t// find a pin named like the flag, skip dots if any\n\t\t\t\tRFlagItem *f = r_flag_get_by_spaces (core->flags, at, R_FLAGS_FS_SYMBOLS, R_FLAGS_FS_IMPORTS, NULL);\n\t\t\t\tif (!f) {\n\t\t\t\t\tf = r_flag_get_i (core->flags, at);\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tconst char *last = r_str_rchr (f->name, NULL, '.');\n\t\t\t\t\tconst char *pin_name = last? last + 1: f->name;\n\t\t\t\t\tconst char *havepin = r_anal_pin_get (core->anal, pin_name);\n\t\t\t\t\tif (havepin) {\n\t\t\t\t\t\tr_core_cmdf (core, \"aep %s @ 0x%08\" PFMT64x, pin_name, at);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '.': // \"aep.\"\n\t\t\t{\n\t\t\tconst char *n = r_anal_pin_at (core->anal, core->offset);\n\t\t\tif (R_STR_ISNOTEMPTY (n)) {\n\t\t\t\tr_cons_printf (\"%s\\n\", n);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c': // \"aepc\"\n\t\t\tif (input[2] == ' ' || input[2] == '=') {\n\t\t\t\t// seek to this address\n\t\t\t\treg_name_roll_set (core, \"PC\", r_num_math (core->num, input + 3));\n\t\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\t} else {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_aep, \"aepc\", true);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\t{\n\t\t\t\tchar *out = sdb_querys (core->anal->sdb_pins, NULL, 0, r_str_trim_head_ro (input + 3));\n\t\t\t\tif (out) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", out);\n\t\t\t\t\tfree (out);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '*':\n\t\tcase 0:\n\t\t\tr_anal_pin_list (core->anal);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tif (input[2] == '*') {\n\t\t\t\tr_anal_pin_init (core->anal);\n\t\t\t} else {\n\t\t\t\tif (input[2]) {\n\t\t\t\t\taddr = r_num_math (core->num, input + 2);\n\t\t\t\t}\n\t\t\t\tr_anal_pin_unset (core->anal, addr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tr_anal_pin (core->anal, addr, input + 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_aep);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"aer\"\n\t\t// 'aer' is an alias for 'ar'\n\t\tcmd_anal_reg (core, input + 1);\n\t\tbreak;\n\tcase '*': // \"aeq\"\n\t\t// XXX: this is wip, not working atm\n\t\tr_cons_printf (\"trap: %d\\n\", core->anal->esil->trap);\n\t\tr_cons_printf (\"trap-code: %d\\n\", core->anal->esil->trap_code);\n\t\tbreak;\n\tcase ' ':\n\tcase 'q': // \"aeq\"\n\t\tr_esil_set_pc (esil, core->offset);\n\t\tr_esil_parse (esil, r_str_trim_head_ro (input + 1));\n\t\tif (verbose && *input != 'q') {\n\t\t\tr_esil_dumpstack (esil);\n\t\t}\n\t\tr_esil_stack_free (esil);\n\t\tbreak;\n\tcase 's': // \"aes\" \"aeso\" \"aesu\" \"aesue\"\n#if 0\n\t\tr_core_cmd0 (core, \"ae `aoe@r:PC`\");\n\t\tr_core_cmd0 (core, \".ar*\");\n\t\tbreak;\n#endif\n\t\t// aes -> single step\n\t\t// aesb -> single step back\n\t\t// aeso -> single step over\n\t\t// aesu -> until address\n\t\t// aesue -> until esil expression\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_aes);\n\t\t\tbreak;\n\t\tcase 'l': // \"aesl\"\n\t\t{\n\t\t\tut64 pc = r_debug_reg_get (core->dbg, \"PC\");\n\t\t\tRAnalOp *op = r_core_anal_op (core, pc, R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT);\n\t\t\tif (!op) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_core_esil_step (core, UT64_MAX, NULL, NULL, false);\n\t\t\tr_debug_reg_set (core->dbg, \"PC\", pc + op->size);\n\t\t\tr_esil_set_pc (esil, pc + op->size);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tr_anal_op_free (op);\n\t\t} break;\n\t\tcase 'b': // \"aesb\"\n\t\t\tif (!r_core_esil_step_back (core)) {\n\t\t\t\tR_LOG_ERROR (\"Cannot step back\");\n\t\t\t}\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\tcase 'B': // \"aesB\"\n\t\t\tn = strchr (input + 2, ' ');\n\t\t\tif (n) {\n\t\t\t\tn = (char *)r_str_trim_head_ro (n + 1);\n\t\t\t}\n\t\t\tif (n) {\n\t\t\t\tchar *n2 = strchr (n, ' ');\n\t\t\t\tif (n2) {\n\t\t\t\t\t*n2++ = 0;\n\t\t\t\t}\n\t\t\t\tut64 off = r_num_math (core->num, n);\n\t\t\t\tut64 nth = n2? r_num_math (core->num, n2): 1;\n\t\t\t\tcmd_aespc (core, core->offset, off, (int)nth);\n\t\t\t} else {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_aes, \"aesB\", true);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u': // \"aesu\"\n\t\t\tuntil_expr = NULL;\n\t\t\tuntil_addr = UT64_MAX;\n\t\t\tif (r_str_endswith (input, \"?\")) {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_aes, \"aesu\", true);\n\t\t\t} else switch (input[2]) {\n\t\t\tcase 'e': // \"aesue\"\n\t\t\t\tuntil_expr = r_str_trim_head_ro (input + 3);\n\t\t\t\tbreak;\n\t\t\tcase ' ': // \"aesu\"\n\t\t\t\tuntil_addr = r_num_math (core->num, input + 2);\n\t\t\t\tbreak;\n\t\t\tcase 'o': // \"aesuo\"\n\t\t\t\tstep_until_optype (core, r_str_trim_head_ro (input + 3));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr_core_cmd0 (core, \"aes?~aesu\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (until_expr || until_addr != UT64_MAX) {\n\t\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL, false);\n\t\t\t}\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\tcase 's': // \"aess\"\n\t\t\tif (input[2] == 'u') { // \"aessu\"\n\t\t\t\tif (input[3] == 'e') {\n\t\t\t\t\tuntil_expr = input + 3;\n\t\t\t\t} else {\n\t\t\t\t\tuntil_addr = r_num_math (core->num, input + 2);\n\t\t\t\t}\n\t\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL, true);\n\t\t\t} else {\n\t\t\t\tr_core_esil_step (core, UT64_MAX, NULL, NULL, true);\n\t\t\t}\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\tcase 'o': // \"aeso\"\n\t\t\tif (input[2] == 'u') { // \"aesou\"\n\t\t\t\tif (input[3] == 'e') {\n\t\t\t\t\tuntil_expr = input + 3;\n\t\t\t\t} else {\n\t\t\t\t\tuntil_addr = r_num_math (core->num, input + 2);\n\t\t\t\t}\n\t\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL, true);\n\t\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\t} else if (!input[2] || input[2] == ' ') { // \"aeso [addr]\"\n\t\t\t\t// step over\n\t\t\t\top = r_core_anal_op (core, r_reg_getv (core->anal->reg,\n\t\t\t\t\tr_reg_get_name (core->anal->reg, R_REG_NAME_PC)), R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT);\n\t\t\t\tif (op && op->type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\t\tuntil_addr = op->addr + op->size;\n\t\t\t\t}\n\t\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL, false);\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\t} else {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_aes, \"aesou\", true);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p': //\"aesp\"\n\t\t\tn = strchr (input, ' ');\n\t\t\tn1 = R_STR_ISNOTEMPTY (n) ? strchr (n + 1, ' ') : NULL;\n\t\t\tif ((!n || !n1) || (!*n || !*n1)) {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_aes, \"aesp\", true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadr = R_STR_ISNOTEMPTY (n)? r_num_math (core->num, n + 1): 0;\n\t\t\toff = R_STR_ISNOTEMPTY (n1)? r_num_math (core->num, n1 + 1): 0;\n\t\t\tcmd_aespc (core, adr, -1, off);\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tn = strchr (input, ' ');\n\t\t\tn1 = n ? n + 1: NULL;\n\t\t\tif (!n1 || !*n1) {\n\t\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toff = r_num_math (core->num, n1);\n\t\t\tcmd_aespc (core, -1, -1, off);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL, false);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'C': // \"aeC\"\n\t\tif (input[1] == '?') { // \"aec?\"\n\t\t\tr_core_cmd_help (core, help_msg_aeC);\n\t\t} else {\n\t\t\t__core_anal_appcall (core, r_str_trim_head_ro (input + 1));\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"aec\"\n\t\tif (input[1] == '?') { // \"aec?\"\n\t\t\tr_core_cmd_help (core, help_msg_aec);\n\t\t} else if (input[1] == 's') { // \"aecs\"\n\t\t\tst64 maxsteps = r_config_get_i (core->config, \"esil.maxsteps\");\n\t\t\tut64 countsteps = 0;\n\t\t\tconst char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\t\t\tfor (; !maxsteps || countsteps < maxsteps; countsteps++) {\n\t\t\t\t// ignore return value is not an error, should 0, 1, -1 imho\n\t\t\t\t(void)r_core_esil_step (core, UT64_MAX, NULL, NULL, false);\n\t\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\t\taddr = r_reg_getv (core->anal->reg, pc);\n\t\t\t\top = r_core_anal_op (core, addr, R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT);\n\t\t\t\tif (!op) {\n\t\t\t\t\tR_LOG_ERROR (\"invalid instruction at 0x%08\" PFMT64x, addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op->type == R_ANAL_OP_TYPE_SWI) {\n\t\t\t\t\tR_LOG_INFO (\"syscall instruction at 0x%08\" PFMT64x, addr);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (op->type == R_ANAL_OP_TYPE_TRAP) {\n\t\t\t\t\tR_LOG_INFO (\"trap instruction at 0x%08\" PFMT64x, addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\top = NULL;\n\t\t\t\tif (core->anal->esil->trap || core->anal->esil->trap_code) {\n\t\t\t\t\tR_LOG_INFO (\"esil trap '%s' (%d) at 0x%08\" PFMT64x,\n\t\t\t\t\t\t\tr_esil_trapstr (core->anal->esil->trap),\n\t\t\t\t\t\t\tcore->anal->esil->trap_code, addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\top = NULL;\n\t\t\t}\n\t\t} else if (input[1] == 'c') { // \"aecc\"\n\t\t\tconst char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\t\t\tst64 maxsteps = r_config_get_i (core->config, \"esil.maxsteps\");\n\t\t\tut64 countsteps = 0;\n\t\t\tfor (; !maxsteps || countsteps < maxsteps; countsteps++) {\n\t\t\t\t(void)r_core_esil_step (core, UT64_MAX, NULL, NULL, false);\n\t\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\t\taddr = r_num_get (core->num, pc);\n\t\t\t\top = r_core_anal_op (core, addr, R_ARCH_OP_MASK_BASIC);\n\t\t\t\tif (!op) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op->type == R_ANAL_OP_TYPE_CALL || op->type == R_ANAL_OP_TYPE_UCALL) {\n\t\t\t\t\tR_LOG_INFO (\"stop in call instruction at 0x%08\" PFMT64x, addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\top = NULL;\n\t\t\t\tif (core->anal->esil->trap || core->anal->esil->trap_code) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t}\n\t\t} else {\n\t\t\t// \"aec\"  -> continue until ^C\n\t\t\t// \"aecu\" -> until address\n\t\t\t// \"aecue\" -> until esil expression\n\t\t\tif (input[1] == 'u' && input[2] == 'e') {\n\t\t\t\tuntil_expr = input + 3;\n\t\t\t} else if (input[1] == 'u') {\n\t\t\t\tuntil_addr = r_num_math (core->num, input + 2);\n\t\t\t} else {\n\t\t\t\tuntil_expr = \"0\";\n\t\t\t}\n\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL, false);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"aei\"\n\t\tswitch (input[1]) {\n\t\tcase 's': // \"aeis\"\n\t\t\t{\n\t\t\t\tchar *arg = r_str_trim_dup (input + 2);\n\t\t\t\tRList *args = r_str_split_list (arg, \" \", 0);\n\t\t\t\tint i, argc = atoi (r_list_pop_head (args));\n\t\t\t\tif (argc < 1) {\n\t\t\t\t\tr_core_cmd_help (core, help_msg_aei);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar **argv = calloc (argc + 1, sizeof (void *));\n\t\t\t\tfor (i = 0; i < argc; i++) {\n\t\t\t\t\tchar *arg = r_list_pop_head (args);\n\t\t\t\t\tif (!arg) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\targv[i] = arg;\n\t\t\t\t}\n\t\t\t\targv[i] = 0;\n\t\t\t\tchar **envp = calloc (r_list_length (args) + 1, sizeof (void *));\n\t\t\t\tfor (i = 0; ; i++) {\n\t\t\t\t\tchar *arg = r_list_pop_head (args);\n\t\t\t\t\tif (!arg) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tenvp[i] = arg;\n\t\t\t\t}\n\t\t\t\tenvp[i] = 0;\n#if R2__UNIX__\n\t\t\t\tif (strstr (input, \"$env\")) {\n\t\t\t\t\textern char **environ;\n\t\t\t\t\tcmd_debug_stack_init (core, argc, argv, environ);\n\t\t\t\t} else {\n\t\t\t\t\tcmd_debug_stack_init (core, argc, argv, envp);\n\t\t\t\t}\n#else\n\t\t\t\tcmd_debug_stack_init (core, argc, argv, envp);\n#endif\n\t\t\t\tfree (arg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'm': // \"aeim\"\n\t\t\tcmd_esil_mem (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'p': // \"aeip\" // initialize pc = $$\n\t\t\treg_name_roll_set (core, \"PC\", core->offset);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_aei);\n\t\t\tcmd_esil_mem (core, \"?\");\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tr_esil_reset (esil);\n\t\t\tbreak;\n\t\tcase 0: // \"aei\"\n\t\t\tesil = esil_new_setup (core);\n\t\t\tif (esil) {\n\t\t\t\tr_esil_free (core->anal->esil);\n\t\t\t\tcore->anal->esil = esil;\n\t\t\t\tr_esil_reset (esil);\n\t\t\t\tconst char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\t\t\t\tif (pc && r_reg_getv (core->anal->reg, pc) == 0LL) {\n\t\t\t\t\treg_name_roll_set (core, \"PC\", core->offset);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* restore user settings for interrupt handling */\n\t\t\t{\n\t\t\t\tconst char *s = r_config_get (core->config, \"cmd.esil.intr\");\n\t\t\t\tif (s) {\n\t\t\t\t\tchar *my = strdup (s);\n\t\t\t\t\tif (my) {\n\t\t\t\t\t\tr_config_set (core->config, \"cmd.esil.intr\", my);\n\t\t\t\t\t\tfree (my);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcmd_esil_mem (core, \"?\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'k': // \"aek\"\n\t\tswitch (input[1]) {\n\t\tcase '\\0':\n\t\t\tinput = \"*\";\n\t\t\t/* fall through */\n\t\tcase ' ':\n\t\t\tif (esil && esil->stats) {\n\t\t\t\tchar *out = sdb_querys (esil->stats, NULL, 0, input + 2);\n\t\t\t\tif (out) {\n\t\t\t\t\tr_cons_println (out);\n\t\t\t\t\tfree (out);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_INFO (\"esil.stats is empty. Run 'aei'\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tif (esil) {\n\t\t\t\tsdb_reset (esil->stats);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_aek);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'L': // \"aeL\" esil plugins\n\t\tif (input[1] == ' ') { // \"aeL\"\n\t\t\tconst char *name = r_str_trim_head_ro (input + 2);\n\t\t\tr_esil_plugin_activate (core->anal->esil, name);\n\t\t} else if (input[1] == '-') { // \"aeL-\"\n\t\t\tconst char *name = r_str_trim_head_ro (input + 2);\n\t\t\tr_esil_plugin_deactivate (core->anal->esil, name);\n\t\t} else {\n\t\t\tREsilPlugin *p;\n\t\t\tRListIter *iter;\n\t\t\tif (core->anal->esil) {\n\t\t\t\tr_list_foreach (core->anal->esil->plugins, iter, p) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", p->name);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_WARN (\"Run 'aei'\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'g': // \"aeg\"\n\t\t{\n\t\t\tint argc;\n\t\t\tchar **argv = r_str_argv (input, &argc);\n\t\t\tr_return_if_fail (argv);\n\t\t\tcmd_aeg (core, argc, argv);\n\t\t\tint i;\n\t\t\tfor (i = 0; i < argc; i++) {\n\t\t\t\tfree (argv[i]);\n\t\t\t}\n\t\t\tfree (argv);\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"aeb\"\n\t\t{\n\t\t\tut64 addr = r_num_math (core->num, input + 1);\n\t\t\tif (!addr || addr == UT64_MAX) {\n\t\t\t\taddr = core->offset;\n\t\t\t}\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t\t\tif (fcn) {\n\t\t\t\tRAnalBlock *bb = r_anal_function_bbget_in (core->anal, fcn, addr);\n\t\t\t\tif (bb) {\n\t\t\t\t\tcmd_aespc (core, bb->addr, bb->addr + bb->size, bb->ninstr);\n\t\t\t\t\t// r_core_cmdf (core, \"aesp `ab~addr[1]` `ab~ninstr[1]`\");\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"No basic block in this address\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"No function in this address\");\n\t\t\t}\n\t\t// ab~ninstr[1]\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"aef\"\n\t\tif (input[1] == 'a') { // \"aefa\"\n\t\t\tr_anal_aefa (core, r_str_trim_head_ro (input + 2));\n\t\t} else { // This should be aefb -> because its emulating all the bbs\n\t\t\t// anal ESIL to REIL.\n\t\t\t__anal_esil_function (core, core->offset);\n\t\t} break;\n\tcase 't': // \"aet\"\n\t\tswitch (input[1]) {\n\t\tcase 's': // \"aets\"\n\t\t\tswitch (input[2]) {\n\t\t\tcase '+': // \"aets+\"\n#if 0\n\t\t\t\tif (!esil) {\n\t\t\t\t\tR_LOG_ERROR (\"ESIL is not initialized. Use `aeim` first\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t\tif (esil->trace) {\n\t\t\t\t\tR_LOG_INFO (\"ESIL trace already started\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tesil->trace = r_esil_trace_new (esil);\n\t\t\t\tif (!esil->trace) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_config_set_b (core->config, \"dbg.trace\", true);\n\t\t\t\tbreak;\n\t\t\tcase '-': // \"aets-\"\n\t\t\t\tif (!esil) {\n\t\t\t\t\tR_LOG_ERROR (\"ESIL is not initialized. Use `aeim` first\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!esil->trace) {\n\t\t\t\t\tR_LOG_ERROR (\"No ESIL trace started\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_esil_trace_free (esil->trace);\n\t\t\t\tesil->trace = NULL;\n\t\t\t\tr_config_set_b (core->config, \"dbg.trace\", false);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr_core_cmd_help (core, help_msg_aets);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0: // \"aet\"\n\t\t\tr_esil_trace_list (core->anal->esil);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_ERROR (\"Unknown command\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'A': // \"aeA\"\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_aea);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tcmd_aea (core, 1 + (1<<1), core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tcmd_aea (core, 1 + (1<<2), core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tcmd_aea (core, 1 + (1<<3), core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tcmd_aea (core, 1 + (1<<4), core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tcmd_aea (core, 1 + (1<<5), core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'f': {\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\t\tif (fcn) {\n\t\t\t\tcmd_aea (core, 1, r_anal_function_min_addr (fcn), r_anal_function_linear_size (fcn));\n\t\t\t}\n\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tcmd_aea (core, 1, core->offset, (int)r_num_math (core->num, input[1]? input + 2:input + 1));\n\t\t}\n\t\tbreak;\n\tcase 'a': { // \"aea\"\n\t\tRReg *reg = core->anal->reg;\n\t\tut64 pc = r_reg_getv (reg, \"PC\");\n\t\tRAnalOp *op = r_core_anal_op (core, pc, 0);\n\t\tif (!op) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 newPC = core->offset + op->size;\n\t\tr_reg_setv (reg, \"PC\", newPC);\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_aea);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tcmd_aea (core, 1<<1, core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tcmd_aea (core, 1<<2, core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tcmd_aea (core, 1<<3, core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tcmd_aea (core, 1<<4, core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tcmd_aea (core, 1<<5, core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'B': { // \"aeaB\"\n\t\t\tbool json = input[2] == 'j';\n\t\t\tint a = json? 3: 2;\n\t\t\tut64 addr = (input[a] == ' ')? r_num_math (core->num, input + a): core->offset;\n\t\t\tRList *l = r_anal_get_blocks_in (core->anal, addr);\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (l, iter, b) {\n\t\t\t\tint mode = json? (1<<4): 1;\n\t\t\t\tcmd_aea (core, mode, b->addr, b->size);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'f': { // \"aeaf\"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\t\tif (fcn) {\n\t\t\t\tswitch (input[2]) {\n\t\t\t\tcase 'j': // \"aeafj\"\n\t\t\t\t\tcmd_aea (core, 1<<4, r_anal_function_min_addr (fcn), r_anal_function_linear_size (fcn));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcmd_aea (core, 1, r_anal_function_min_addr (fcn), r_anal_function_linear_size (fcn));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase 'b': { // \"aeab\"\n\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n\t\t\tif (bb) {\n\t\t\t\tswitch (input[2]) {\n\t\t\t\tcase 'j': // \"aeabj\"\n\t\t\t\t\tcmd_aea (core, 1 | (1<<4), bb->addr, bb->size);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcmd_aea (core, 1, bb->addr, bb->size);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault: {\n\t\t\tconst char *arg = input[1]? input + 2: \"\";\n\t\t\tut64 len = r_num_math (core->num, arg);\n\t\t\tcmd_aea (core, 0, core->offset, len);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tr_reg_setv (reg, \"PC\", pc);\n\t\tbreak;\n\t\t  }\n\tcase 'x':\n\t\tif (input[1] == ' ') { // \"aex\"\n\t\t\tchar *hex;\n\t\t\tint ret, bufsz;\n\n\t\t\tinput = r_str_trim_head_ro (input + 1);\n\t\t\thex = strdup (input);\n\t\t\tif (!hex) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tRAnalOp aop = {0};\n\t\t\tbufsz = r_hex_str2bin (hex, (ut8*)hex);\n\t\t\tret = r_anal_op (core->anal, &aop, core->offset,\n\t\t\t\t(const ut8*)hex, bufsz, R_ARCH_OP_MASK_ESIL);\n\t\t\tif (ret > 0) {\n\t\t\t\tconst char *str = R_STRBUF_SAFEGET (&aop.esil);\n\t\t\t\tchar *str2 = r_str_newf (\" %s\", str);\n\t\t\t\tcmd_anal_esil (core, str2, false);\n\t\t\t\tfree (str2);\n\t\t\t\tr_core_return_value (core, 1);\n\t\t\t} else {\n\t\t\t\t// fail to exevute, update code\n\t\t\t\tr_core_return_value (core, 0);\n\t\t\t}\n\t\t\tr_anal_op_fini (&aop);\n\t\t\tfree (hex);\n\t\t} else if (input[1] == 'a') { // \"aexa\"\n\t\t\tchar *bytes = r_core_cmd_strf (core, \"\\\"pa %s\\\"\", r_str_trim_head_ro (input + 2));\n\t\t\tif (R_STR_ISNOTEMPTY (bytes)) {\n\t\t\t\tr_core_cmdf (core, \"aex %s\", bytes);\n\t\t\t}\n\t\t\tfree (bytes);\n\t\t} else { // \"aex?\"\n\t\t\tr_core_cmd_help (core, help_msg_aex);\n\t\t}\n\t\tbreak;\n\tcase '?': // \"ae?\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_detail_ae);\n\t\t\tbreak;\n\t\t}\n\t\t/* fallthrough */\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ae);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_bytes(RCore *core, const char *input) {\n\tint len = core->blocksize;\n\tif (input[0]) {\n\t\tlen = (int)r_num_get (core->num, input + 1);\n\t}\n\tif (len < 1) {\n\t\treturn;\n\t}\n\tut8 *buf = calloc (len, 1);\n\tif (buf) {\n\t\tr_io_read_at (core->io, core->offset, buf, len);\n\t\tcore_anal_bytes (core, buf, len, 0, input[0]);\n\t\tfree (buf);\n\t}\n}\n\nstatic int compare_mnemonics(const char *a , const char *b) {\n\tif (!a || !b) {\n\t\treturn 0;\n\t}\n\tchar *sa = strdup (a);\n\tchar *sb = strdup (b);\n\tr_str_replace_ch (sa, ' ', ',', 0);\n\tr_str_replace_ch (sb, ' ', ',', 0);\n\tRList *la = r_str_split_list (sa, \",\", 0);\n\tRList *lb = r_str_split_list (sb, \",\", 0);\n\tint i = 0;\n\tfor (i = 0; i < 10; i++) {\n\t\tchar *wa = r_list_get_n (la, i);\n\t\tchar *wb = r_list_get_n (lb, i);\n\t\tif (!wa || !wb) {\n\t\t\ti = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp (wa, wb)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_list_free (la);\n\tr_list_free (lb);\n\tfree (sa);\n\tfree (sb);\n\treturn i;\n}\n\nstatic int intsort(const void *a, const void *b) {\n\tif (a > b) {\n\t\treturn 1;\n\t}\n\tif (a == b) {\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic void cmd_anal_opcode_bits(RCore *core, const char *arg, int mode) {\n\tut8 buf[32] = {0};\n\tif (R_STR_ISNOTEMPTY (arg)) {\n\t\tchar *choparg = r_str_ndup (arg, 8);\n\t\tint res = r_hex_str2bin (choparg, (ut8 *)buf);\n\t\tfree (choparg);\n\t\tif (res < 1) {\n\t\t\tR_LOG_ERROR (\"Invalid hex string\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tr_io_read_at (core->io, core->offset, buf, sizeof (buf));\n\t}\n\tRList *args[8];\n\tint i, j;\n\tRAnalOp analop, op;\n\tr_anal_op_init (&analop);\n\tr_anal_op_set_bytes (&analop, core->offset, buf, sizeof (ut64));\n\t(void)r_anal_op (core->anal, &analop, core->offset, buf, sizeof (buf), R_ARCH_OP_MASK_DISASM);\n\tint last = R_MIN (8, analop.size);\n\tPJ *pj = (mode == 'j')? r_core_pj_new (core): NULL;\n\tif (last < 1) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\targs[i] = r_list_new ();\n\t}\n\n\tif (pj) {\n\t\tpj_o (pj);\n\t\tpj_ks (pj, \"opstr\", analop.mnemonic);\n\t\tpj_kn (pj, \"size\", analop.size);\n\t\tpj_ko (pj, \"bytes\");\n\t}\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tfor (i = 0; i < last; i++) {\n\t\tut8 *byte = buf + i;\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t}\n\t\tif (i == 4) {\n\t\t\tr_strbuf_append (sb, \"| \");\n\t\t}\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tbool bit = R_BIT_CHK (byte, 7 - j);\n\t\t\tr_anal_op_init (&op);\n\t\t\tut8 newbuf[sizeof (ut64)] = {0};\n\t\t\tmemcpy (&newbuf, &buf, sizeof (ut64));\n\t\t\tut8 *newbyte = newbuf + i;\n\t\t\tif (bit) {\n\t\t\t\tnewbuf[i] = R_BIT_UNSET (newbyte, 7 - j);\n\t\t\t} else {\n\t\t\t\tnewbuf[i] = R_BIT_SET (newbyte, 7 - j);\n\t\t\t}\n\t\t\tr_anal_op_set_bytes (&op, core->offset, newbuf, sizeof (newbuf));\n\t\t\t(void)r_anal_op (core->anal, &op, core->offset, newbuf, sizeof (ut64), R_ARCH_OP_MASK_DISASM);\n\t\t\t// r_cons_printf (\"%d %s\\n%d %s\\n\\n\", (i*8) + j, analop.mnemonic, (i*8)+j, op.mnemonic);\n\t\t\tint word_change = compare_mnemonics (analop.mnemonic, op.mnemonic);\n\t\t\tr_anal_op_fini (&op);\n\t\t\tif (pj) {\n\t\t\t\tpj_n (pj, word_change);\n\t\t\t\tr_list_append (args[word_change], (void *)(size_t)((i * 8) + 7 - j));\n\t\t\t}\n\t\t\tr_strbuf_appendf (sb, \"%d\", word_change);\n\t\t}\n\t\tif (pj) {\n\t\t\tpj_end (pj);\n\t\t}\n\t\tr_strbuf_append (sb, \" \");\n\t}\n\tif (pj) {\n\t\tvoid *n;\n\t\tRListIter *iter;\n\t\tpj_end (pj);\n\t\tchar *s = r_strbuf_drain (sb);\n\t\tpj_ks (pj, \"flipstr\", s);\n\t\tfree (s);\n\t\tpj_ka (pj, \"args\");\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tif (r_list_empty (args[j])) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpj_a (pj);\n\t\t\tr_list_sort (args[j], intsort);\n\t\t\tr_list_foreach (args[j], iter, n) {\n\t\t\t\tint nn = (int)((size_t)n & ST32_MAX);\n\t\t\t\tpj_n (pj, nn);\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t\tpj_end (pj);\n\t\ts = pj_drain (pj);\n\t\tr_cons_printf (\"%s\\n\", s);\n\t\tfree (s);\n\t} else {\n\t\tif (mode == 'm') {\n\t\t\tint pi = 0;\n\t\t\tchar *s = r_strbuf_drain (sb);\n\t\t\tchar *p = s;\n\t\t\tut8 finalmask[8] = {0};\n\t\t\tfor (; *p; p++) {\n\t\t\t\tint byte_index = (pi / 8);\n\t\t\t\tint bit_index = (pi % 8);\n\t\t\t\tut8 *byte = finalmask + byte_index;\n\t\t\t\tif (*p == '0') {\n\t\t\t\t\t// only pick the bits that modify the 0th word\n\t\t\t\t\tR_BIT_SET (byte, bit_index);\n\t\t\t\t\tpi++;\n\t\t\t\t} else if (isalnum (*p)) {\n\t\t\t\t\tpi++;\n\t\t\t\t}\n\t\t\t\tif (byte_index >= last) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (s);\n\t\t\tfor (i = 0; i < 8 && i < last; i++) {\n\t\t\t\tr_cons_printf (\"%02x\", finalmask[i]);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t} else {\n\t\t\tr_strbuf_appendf (sb, \" : %s\", analop.mnemonic);\n\t\t\tchar *s = r_strbuf_drain (sb);\n\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\tfree (s);\n\t\t}\n\t}\n\tr_anal_op_fini (&analop);\n\tfor (i = 0; i < 8; i++) {\n\t\tr_list_free (args[i]);\n\t}\n}\n\nstatic void cmd_anal_opcode(RCore *core, const char *input) {\n\tint l, len = core->blocksize;\n\tut32 tbs = core->blocksize;\n\tr_core_block_read (core);\n\tswitch (input[0]) {\n\tcase 's': // \"aos\"\n\tcase 'j': // \"aoj\"\n\tcase 'e': // \"aoe\"\n\tcase 'r': { // \"aor\"\n\t\tint count = 1;\n\t\tint obs = core->blocksize;\n\t\tint fmt = input[0];\n\t\tif (input[0] == 'e') {\n\t\t\tswitch (input[1]) {\n\t\t\tcase 'q': // \"aoeq\"\n\t\t\t\tfmt = 'E'; // quiet esil\n\t\t\t\tinput++;\n\t\t\t\tbreak;\n\t\t\tcase 'm': // \"aoem\"\n\t\t\t\tfmt = 'm'; // memory esil\n\t\t\t\tinput++;\n\t\t\t\tbreak;\n\t\t\tcase '?': // \"aoe?\"\n\t\t\t\tr_core_cmd_help_match (core, help_msg_ao, \"aoe\", false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (input[1] && input[2]) {\n\t\t\tl = (int)r_num_get (core->num, input + 1);\n\t\t\tif (l > 0) {\n\t\t\t\tcount = l;\n\t\t\t}\n\t\t\tl *= 8;\n\t\t\tif (l > obs) {\n\t\t\t\tr_core_block_size (core, l);\n\t\t\t}\n\t\t} else {\n\t\t\tcount = 1;\n\t\t}\n\t\tcore_anal_bytes (core, core->block, core->blocksize, count, fmt);\n\t\tif (obs != core->blocksize) {\n\t\t\tr_core_block_size (core, obs);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 't': // \"aot\"\n\t\tif (input[1] == 'l') {\n\t\t\tr_core_cmd_call (core, \"/atl\");\n\t\t} else if (input[1] == '\\0') {\n\t\t\tr_core_cmd0 (core, \"ao~^type[1]\");\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_aot);\n\t\t}\n\t\tbreak;\n\tcase 'm': // \"aom\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_aom);\n\t\t} else if (input[1] == 'd') {\n\t\t\tconst int id = (input[2] == ' ')\n\t\t\t\t?(int)r_num_math (core->num, input + 2): -1;\n\t\t\tchar *ops = r_asm_mnemonics (core->rasm, id, false);\n\t\t\tif (ops) {\n\t\t\t\tchar *ptr = ops;\n\t\t\t\tchar *nl = strchr (ptr, '\\n');\n\t\t\t\twhile (nl) {\n\t\t\t\t\t*nl = 0;\n\t\t\t\t\tchar *desc = r_asm_describe (core->rasm, ptr);\n\t\t\t\t\tif (desc) {\n\t\t\t\t\t\tconst char *pad = r_str_pad (' ', 16 - strlen (ptr));\n\t\t\t\t\t\tr_cons_printf (\"%s%s%s\\n\", ptr, pad, desc);\n\t\t\t\t\t\tfree (desc);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", ptr);\n\t\t\t\t\t}\n\t\t\t\t\tptr = nl + 1;\n\t\t\t\t\tnl = strchr (ptr, '\\n');\n\t\t\t\t}\n\t\t\t\tfree (ops);\n\t\t\t}\n\t\t} else if (input[1] == 'l' || input[1] == '=' || input[1] == ' ' || input[1] == 'j') {\n\t\t\tif (input[1] == ' ' && !IS_DIGIT (input[2])) {\n\t\t\t\tr_cons_printf (\"%d\\n\", r_asm_mnemonics_byname (core->rasm, input + 2));\n\t\t\t} else {\n\t\t\t\t// \"aoml\"\n\t\t\t\tconst int id = (input[1] == ' ')\n\t\t\t\t\t?(int)r_num_math (core->num, input + 2): -1;\n\t\t\t\tchar *ops = r_asm_mnemonics (core->rasm, id, input[1] == 'j');\n\t\t\t\tif (ops) {\n\t\t\t\t\tr_str_trim (ops);\n\t\t\t\t\tr_cons_println (ops);\n\t\t\t\t\tfree (ops);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_cmd0 (core, \"ao~mnemonic[1]\");\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"aob\"\n\t\tif (input[1] == 'j') {\n\t\t\tcmd_anal_opcode_bits (core, r_str_trim_head_ro (input + 2), 'j');\n\t\t} else if (input[1] == 'm') {\n\t\t\tcmd_anal_opcode_bits (core, NULL, 'm');\n\t\t} else {\n\t\t\tcmd_anal_opcode_bits (core, r_str_trim_head_ro (input + 1), 0);\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"aoc\"\n\t{\n\t\tRList *hooks;\n\t\tRListIter *iter;\n\t\tRAnalCycleHook *hook;\n\t\tchar *instr_tmp = NULL;\n\t\tint ccl = input[1]? r_num_math (core->num, &input[2]): 0; //get cycles to look for\n\t\tbool cr = r_config_get_b (core->config, \"asm.cmt.right\");\n\t\tbool fu = r_config_get_b (core->config, \"asm.functions\");\n\t\tbool li = r_config_get_b (core->config, \"asm.lines\");\n\t\tbool xr = r_config_get_b (core->config, \"asm.xrefs\");\n\n\t\tr_config_set_b (core->config, \"asm.cmt.right\", true);\n\t\tr_config_set_b (core->config, \"asm.functions\", false);\n\t\tr_config_set_b (core->config, \"asm.lines\", false);\n\t\tr_config_set_b (core->config, \"asm.xrefs\", false);\n\n\t\thooks = r_core_anal_cycles (core, ccl); //analyse\n\t\tr_cons_clear_line (1);\n\t\tr_list_foreach (hooks, iter, hook) {\n\t\t\tinstr_tmp = r_core_disassemble_instr (core, hook->addr, 1);\n\t\t\tr_cons_printf (\"After %4i cycles:\\t%s\", (ccl - hook->cycles), instr_tmp);\n\t\t\tr_cons_flush ();\n\t\t\tfree (instr_tmp);\n\t\t}\n\t\tr_list_free (hooks);\n\n\t\tr_config_set_b (core->config, \"asm.cmt.right\", cr); //reset settings\n\t\tr_config_set_b (core->config, \"asm.functions\", fu);\n\t\tr_config_set_b (core->config, \"asm.lines\", li);\n\t\tr_config_set_b (core->config, \"asm.xrefs\", xr);\n\t}\n\tbreak;\n\tcase 'd': // \"aod\"\n\t\tif (input[1] == 'a') { // \"aoda\"\n\t\t\t// list sdb database\n\t\t\tsdb_foreach (core->rasm->pair, listOpDescriptions, core);\n\t\t} else if (input[1] == 0) {\n\t\t\tint cur = R_MAX (core->print->cur, 0);\n\t\t\t// XXX: we need cmd_xxx.h (cmd_anal.h)\n\t\t\tcore_anal_bytes (core, core->block + cur, core->blocksize, 1, 'd');\n\t\t} else if (input[1] == ' ') {\n\t\t\tchar *d = r_asm_describe (core->rasm, input + 2);\n\t\t\tif (d && *d) {\n\t\t\t\tr_cons_println (d);\n\t\t\t\tfree (d);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Unknown mnemonic\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_cmd_help_match (core, help_msg_ao, \"aod\", false);\n\t\t}\n\t\tbreak;\n\tcase '*':\n\t\tr_core_anal_hint_list (core->anal, input[0]);\n\t\tbreak;\n\tcase 0:\n\tcase ' ': {\n\t\t\tint count = 0;\n\t\t\tif (input[0]) {\n\t\t\t\tl = (int)r_num_get (core->num, input + 1);\n\t\t\t\tif (l > 0) {\n\t\t\t\t\tcount = l;\n\t\t\t\t}\n\t\t\t\tif (l > tbs) {\n\t\t\t\t\tr_core_block_size (core, l * 4);\n\t\t\t\t\t//len = l;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlen = l = core->blocksize;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t\tcore_anal_bytes (core, core->block, len, count, 0);\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"aof\"\n\t\tif (strlen (input + 1) > 1) {\n\t\t\tRAnalOp aop = {0};\n\t\t\tut8 data[32];\n\t\t\tr_io_read_at (core->io, core->offset, data, sizeof (data));\n\t\t\tint ret = r_anal_op (core->anal, &aop, core->offset, data, sizeof (data), R_ARCH_OP_MASK_ESIL);\n\t\t\tif (ret > 0) {\n\t\t\t\tconst char *arg = input + 2;\n\t\t\t\tconst char *expr = R_STRBUF_SAFEGET (&aop.esil);\n\t\t\t\tRStrBuf *b = r_anal_esil_dfg_filter_expr (core->anal, expr, arg,\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.mapinfo\"),\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.maps\"));\n\t\t\t\tif (b) {\n\t\t\t\t\tchar *s = r_strbuf_drain (b);\n\t\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_WARN (\"Unable to analyze instruction\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_ao);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_jumps(RCore *core, const char *input) {\n\tr_core_cmdf (core, \"af @@= `ax~ref.code.jmp[1]`\");\n}\n\n// TODO: cleanup to reuse code\nstatic void cmd_anal_aftertraps(RCore *core, const char *input) {\n\tint bufi, minop = 1; // 4\n\tut8 *buf;\n\tRAnalOp op = {0};\n\tut64 addr, addr_end;\n\tut64 len = r_num_math (core->num, input);\n\tif (len > ALLOC_SIZE_LIMIT) {\n\t\tR_LOG_ERROR (\"Length is too large\");\n\t\treturn;\n\t}\n\tRBinFile *bf = r_bin_cur (core->bin);\n\tif (!bf) {\n\t\treturn;\n\t}\n\taddr = core->offset;\n\tif (!len) {\n\t\t// ignore search.in to avoid problems. analysis != search\n\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\tif (map && (map->perm & R_PERM_X)) {\n\t\t\t// search in current section\n\t\t\tif (r_io_map_size (map) > bf->size) {\n\t\t\t\taddr = r_io_map_begin (map);\n\t\t\t\tif (bf->size > map->delta) {\n\t\t\t\t\tlen = bf->size - map->delta;\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Oops something went wrong aac\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr = r_io_map_begin (map);\n\t\t\t\tlen = r_io_map_size (map);\n\t\t\t}\n\t\t} else {\n\t\t\tif (map && r_io_map_begin (map) != map->delta && bf->size > (core->offset - r_io_map_begin (map) + map->delta)) {\n\t\t\t\tlen = bf->size - (core->offset - r_io_map_begin (map) + map->delta);\n\t\t\t} else {\n\t\t\t\tif (bf->size > core->offset) {\n\t\t\t\t\tlen = bf->size - core->offset;\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Oops invalid range\");\n\t\t\t\t\tlen = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taddr_end = addr + len;\n\tif (!(buf = malloc (4096))) {\n\t\treturn;\n\t}\n\tbufi = 0;\n\tint trapcount = 0;\n\tint nopcount = 0;\n\tr_cons_break_push (NULL, NULL);\n\twhile (addr < addr_end) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t// TODO: too many ioreads here\n\t\tif (bufi > 4000) {\n\t\t\tbufi = 0;\n\t\t}\n\t\tif (!bufi) {\n\t\t\tr_io_read_at (core->io, addr, buf, 4096);\n\t\t}\n\t\tif (r_anal_op (core->anal, &op, addr, buf + bufi, 4096 - bufi, R_ARCH_OP_MASK_BASIC)) {\n\t\t\tif (op.size < 1) {\n\t\t\t\t// XXX must be +4 on arm/mips/.. like we do in disasm.c\n\t\t\t\top.size = minop;\n\t\t\t}\n\t\t\tif (op.type == R_ANAL_OP_TYPE_TRAP) {\n\t\t\t\ttrapcount ++;\n\t\t\t} else if (op.type == R_ANAL_OP_TYPE_NOP) {\n\t\t\t\tnopcount ++;\n\t\t\t} else {\n\t\t\t\tif (nopcount > 1) {\n\t\t\t\t\tr_cons_printf (\"af @ 0x%08\"PFMT64x\"\\n\", addr);\n\t\t\t\t\tnopcount = 0;\n\t\t\t\t}\n\t\t\t\tif (trapcount > 0) {\n\t\t\t\t\tr_cons_printf (\"af @ 0x%08\"PFMT64x\"\\n\", addr);\n\t\t\t\t\ttrapcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\top.size = minop;\n\t\t}\n\t\taddr += (op.size > 0)? op.size : 1;\n\t\tbufi += (op.size > 0)? op.size : 1;\n\t\tr_anal_op_fini (&op);\n\t}\n\tr_cons_break_pop ();\n\tfree (buf);\n}\n\nstatic void cmd_anal_blocks(RCore *core, const char *input) {\n\tut64 from , to;\n\tchar *arg = strchr (input, ' ');\n\tr_cons_break_push (NULL, NULL);\n\tif (!arg) {\n\t\tr_core_cmd0 (core, \"abb $SS @ $S\");\n\t\tRList *list = r_core_get_boundaries_prot (core, R_PERM_X, NULL, \"anal\");\n\t\tRListIter *iter;\n\t\tRIOMap* map;\n\t\tif (!list) {\n\t\t\tgoto ctrl_c;\n\t\t}\n\t\tr_list_foreach (list, iter, map) {\n\t\t\tfrom = r_io_map_begin (map);\n\t\t\tto = r_io_map_end (map);\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto ctrl_c;\n\t\t\t}\n\t\t\tif (!from && !to) {\n\t\t\t\tR_LOG_ERROR (\"Cannot determine search boundaries\");\n\t\t\t} else if (to - from > UT32_MAX) {\n\t\t\t\tchar *unit = r_num_units (NULL, 0, to - from);\n\t\t\t\tR_LOG_WARN (\"Skipping huge range (%s)\", unit);\n\t\t\t\tfree (unit);\n\t\t\t} else {\n\t\t\t\tR_LOG_DEBUG (\"abb 0x%08\"PFMT64x\" @ 0x%08\"PFMT64x, (to - from), from);\n\t\t\t\tr_core_cmdf (core, \"abb 0x%08\"PFMT64x\" @ 0x%08\"PFMT64x, (to - from), from);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tst64 sz = r_num_math (core->num, arg + 1);\n\t\tif (sz < 1) {\n\t\t\tR_LOG_ERROR (\"Invalid range\");\n\t\t\treturn;\n\t\t}\n\t\tr_core_cmdf (core, \"abb 0x%08\"PFMT64x\" @ 0x%08\"PFMT64x, sz, core->offset);\n\t}\nctrl_c:\n\tr_cons_break_pop ();\n}\n\nstatic void _anal_calls(RCore *core, ut64 addr, ut64 addr_end, bool printCommands, bool importsOnly) {\n\tRAnalOp op = {0};\n\tint depth = r_config_get_i (core->config, \"anal.depth\");\n\tconst int addrbytes = core->io->addrbytes;\n\tconst int bsz = 4096;\n\tint bufi = 0;\n\tint bufi_max = bsz - 16;\n\tif (addr_end - addr > UT32_MAX) {\n\t\treturn;\n\t}\n\tut8 *buf = malloc (bsz);\n\tut8 *block0 = calloc (1, bsz);\n\tut8 *block1 = malloc (bsz);\n\tif (!buf || !block0 || !block1) {\n\t\tfree (buf);\n\t\tfree (block0);\n\t\tfree (block1);\n\t\treturn;\n\t}\n\tmemset (block1, -1, bsz);\n\tint minop = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tif (minop < 1) {\n\t\tminop = 1;\n\t}\n\tint setBits = r_config_get_i (core->config, \"asm.bits\");\n\tr_cons_break_push (NULL, NULL);\n\twhile (addr < addr_end && !r_cons_is_breaked ()) {\n\t\t// TODO: too many ioreads here\n\t\tif (bufi > bufi_max) {\n\t\t\tbufi = 0;\n\t\t}\n\t\tif (!bufi) {\n\t\t\t(void)r_io_read_at (core->io, addr, buf, bsz);\n\t\t}\n\t\tif (!memcmp (buf, block0, bsz) || !memcmp (buf, block1, bsz)) {\n\t\t\taddr += bsz;\n\t\t\tcontinue;\n\t\t}\n\t\tRAnalHint *hint = r_anal_hint_get (core->anal, addr);\n\t\tif (hint && hint->bits) {\n\t\t\tsetBits = hint->bits;\n\t\t}\n\t\tr_anal_hint_free (hint);\n\t\tif (setBits != core->rasm->config->bits) {\n\t\t\tr_config_set_i (core->config, \"asm.bits\", setBits);\n\t\t}\n\t\tif (r_anal_op (core->anal, &op, addr, buf + bufi, bsz - bufi, 0) > 0) {\n\t\t\tif (op.size < 1) {\n\t\t\t\top.size = minop;\n\t\t\t}\n\t\t\tif (op.type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\tbool isValidCall = true;\n\t\t\t\tif (importsOnly) {\n\t\t\t\t\tRFlagItem *f = r_flag_get_i (core->flags, op.jump);\n\t\t\t\t\tif (!f || !strstr (f->name, \"imp.\")) {\n\t\t\t\t\t\tisValidCall = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRBinReloc *rel = r_core_getreloc (core, addr, op.size);\n\t\t\t\tif (rel && (rel->import || rel->symbol)) {\n\t\t\t\t\tisValidCall = false;\n\t\t\t\t}\n\t\t\t\tif (isValidCall) {\n\t\t\t\t\tut8 buf[4] = {0};\n\t\t\t\t\tr_io_read_at (core->io, op.jump, buf, 4);\n\t\t\t\t\tisValidCall = memcmp (buf, \"\\x00\\x00\\x00\\x00\", 4);\n\t\t\t\t}\n\t\t\t\tif (isValidCall) {\n#if JAYRO_03\n\t\t\t\t\tif (!anal_is_bad_call (core, from, to, addr, buf, bufi)) {\n\t\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, op.jump, R_ANAL_FCN_TYPE_ROOT);\n\t\t\t\t\t\tif (!fcn) {\n\t\t\t\t\t\t\tr_core_anal_fcn (core, op.jump, addr, R_ANAL_REF_TYPE_CALL, depth - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#else\n\t\t\t\t\tif (printCommands) {\n\t\t\t\t\t\tr_cons_printf (\"ax 0x%08\" PFMT64x \" 0x%08\" PFMT64x \"\\n\", op.jump, addr);\n\t\t\t\t\t\tr_cons_printf (\"af @ 0x%08\" PFMT64x\"\\n\", op.jump);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// add xref here\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, addr, op.jump, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\t\tif (r_io_is_valid_offset (core->io, op.jump, 1)) {\n\t\t\t\t\t\t\tr_core_anal_fcn (core, op.jump, addr, R_ANAL_REF_TYPE_CALL, depth - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\top.size = minop;\n\t\t}\n\t\tif ((int)op.size < 1) {\n\t\t\top.size = minop;\n\t\t}\n\t\taddr += op.size;\n\t\tbufi += addrbytes * op.size;\n\t\tr_anal_op_fini (&op);\n\t}\n\tr_cons_break_pop ();\n\tfree (buf);\n\tfree (block0);\n\tfree (block1);\n}\n\nstatic void cmd_anal_calls(RCore *core, const char *input, bool printCommands, bool importsOnly) {\n\tRList *ranges = NULL;\n\tRIOMap *r;\n\tut64 addr;\n\tut64 len = r_num_math (core->num, input);\n\tif (len > 0xffffff) {\n\t\tR_LOG_ERROR (\"Too big\");\n\t\treturn;\n\t}\n\tRBinFile *binfile = r_bin_cur (core->bin);\n\taddr = core->offset;\n\tif (binfile) {\n\t\tif (len) {\n\t\t\tRIOMap *m = R_NEW0 (RIOMap);\n\t\t\tm->itv.addr = addr;\n\t\t\tm->itv.size = len;\n\t\t\tranges = r_list_newf ((RListFree)free);\n\t\t\tr_list_append (ranges, m);\n\t\t} else {\n\t\t\tranges = r_core_get_boundaries_prot (core, R_PERM_X, NULL, \"anal\");\n\t\t}\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tif (!binfile || (ranges && !r_list_length (ranges))) {\n\t\tRListIter *iter;\n\t\tRIOMap *map;\n\t\tr_list_free (ranges);\n\t\tranges = r_core_get_boundaries_prot (core, 0, NULL, \"anal\");\n\t\tif (ranges) {\n\t\t\tr_list_foreach (ranges, iter, map) {\n\t\t\t\tut64 addr = r_io_map_begin (map);\n\t\t\t\t_anal_calls (core, addr, r_io_map_end (map), printCommands, importsOnly);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tRListIter *iter;\n\t\tif (binfile) {\n\t\t\tr_list_foreach (ranges, iter, r) {\n\t\t\t\taddr = r->itv.addr;\n\t\t\t\t//this normally will happen on fuzzed binaries, dunno if with huge\n\t\t\t\t//binaries as well\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t_anal_calls (core, addr, r_itv_end (r->itv), printCommands, importsOnly);\n\t\t\t}\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\tr_list_free (ranges);\n}\n\nstatic void cmd_sdbk(Sdb *db, const char *input) {\n\tchar *out = (input[0] == ' ')\n\t\t? sdb_querys (db, NULL, 0, input + 1)\n\t\t: sdb_querys (db, NULL, 0, \"*\");\n\tif (out) {\n\t\tr_cons_println (out);\n\t\tfree (out);\n\t} else {\n\t\tR_LOG_ERROR (\"Usage: ask [query]\");\n\t}\n}\n\nstatic void cmd_anal_syscall(RCore *core, const char *input) {\n\tchar snstr[32];\n\tPJ *pj = NULL;\n\tRSyscallItem *si;\n\tRListIter *iter;\n\tRList *list;\n\tint n;\n\n\tswitch (input[0]) {\n\tcase 'c': // \"asc\"\n\t\tif (input[1] == 'a') {\n\t\t\tif (input[2] == ' ') {\n\t\t\t\tif (!isalpha ((ut8)input[3]) && (n = r_num_math (core->num, input + 3)) >= 0 ) {\n\t\t\t\t\tsi = r_syscall_get (core->anal->syscall, n, -1);\n\t\t\t\t\tif (si) {\n\t\t\t\t\t\tr_cons_printf (\".equ SYS_%s %s\\n\", si->name, syscallNumber (snstr, n));\n\t\t\t\t\t\tr_syscall_item_free (si);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tR_LOG_ERROR (\"Unknown syscall number\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tn = r_syscall_get_num (core->anal->syscall, input + 3);\n\t\t\t\t\tif (n != -1) {\n\t\t\t\t\t\tr_cons_printf (\".equ SYS_%s %s\\n\", input + 3, syscallNumber (snstr, n));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tR_LOG_ERROR (\"Unknown syscall name\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlist = r_syscall_list (core->anal->syscall);\n\t\t\t\tr_list_foreach (list, iter, si) {\n\t\t\t\t\tr_cons_printf (\".equ SYS_%s %s\\n\", si->name, syscallNumber (snstr, si->num));\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t} else {\n\t\t\tif (input[1] == ' ') {\n\t\t\t\tif (!isalpha ((ut8)input[2]) && (n = r_num_math (core->num, input + 2)) >= 0) {\n\t\t\t\t\tsi = r_syscall_get (core->anal->syscall, n, -1);\n\t\t\t\t\tif (si) {\n\t\t\t\t\t\tr_cons_printf (\"#define SYS_%s %s\\n\", si->name, syscallNumber (snstr, n));\n\t\t\t\t\t\tr_syscall_item_free (si);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tR_LOG_ERROR (\"Unknown syscall number\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tn = r_syscall_get_num (core->anal->syscall, input + 2);\n\t\t\t\t\tif (n != -1) {\n\t\t\t\t\t\tr_cons_printf (\"#define SYS_%s %s\\n\", input + 2, syscallNumber (snstr, n));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tR_LOG_ERROR (\"Unknown syscall name\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlist = r_syscall_list (core->anal->syscall);\n\t\t\t\tr_list_foreach (list, iter, si) {\n\t\t\t\t\tr_cons_printf (\"#define SYS_%s %s\\n\",\n\t\t\t\t\t\tsi->name, syscallNumber (snstr, si->num));\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'k': // \"ask\"\n\t\tcmd_sdbk (core->anal->syscall->db, input + 1);\n\t\tbreak;\n\tcase 'l': // \"asl\"\n\t\tif (input[1] == ' ') {\n\t\t\tconst char *sc_name = r_str_trim_head_ro (input + 2);\n\t\t\tint sc_number = r_syscall_get_num (core->anal->syscall, sc_name);\n\t\t\tif (sc_number != 0) {\n\t\t\t\tr_cons_printf (\"%s\\n\", syscallNumber (snstr, sc_number));\n\t\t\t} else {\n\t\t\t\tsc_number = r_num_math (core->num, sc_name);\n\t\t\t\tsi = r_syscall_get (core->anal->syscall, sc_number, -1);\n\t\t\t\tif (!si) {\n\t\t\t\t\tsi = r_syscall_get (core->anal->syscall, -1, sc_number);\n\t\t\t\t}\n\t\t\t\tif (si) {\n\t\t\t\t\tr_cons_println (si->name);\n\t\t\t\t\tr_syscall_item_free (si);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Unknown syscall number\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlist = r_syscall_list (core->anal->syscall);\n\t\t\tr_list_foreach (list, iter, si) {\n\t\t\t\tr_cons_printf (\"%s = 0x%02x.%s\\n\",\n\t\t\t\t\tsi->name, si->swi, syscallNumber (snstr, si->num));\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"asj\"\n\t\tpj = pj_new ();\n\t\tpj_a (pj);\n\t\tlist = r_syscall_list (core->anal->syscall);\n\t\tr_list_foreach (list, iter, si) {\n\t\t\tpj_o (pj);\n\t\t\tpj_ks (pj, \"name\", si->name);\n\t\t\tpj_ki (pj, \"swi\", si->swi);\n\t\t\tpj_ki (pj, \"num\", si->num);\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t\tif (pj) {\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t}\n\t\tr_list_free (list);\n\t\tbreak;\n\tcase '\\0':\n\t\tcmd_syscall_do (core, -1, core->offset);\n\t\tbreak;\n\tcase ' ':\n\t\t{\n\t\tconst char *sn = r_str_trim_head_ro (input + 1);\n\t\tst64 num = r_syscall_get_num (core->anal->syscall, sn);\n\t\tif (num < 1) {\n\t\t\tnum = (int)r_num_get (core->num, sn);\n\t\t}\n\t\tcmd_syscall_do (core, num, -1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_as);\n\t\tbreak;\n\t}\n}\n\nstatic void anal_axg(RCore *core, const char *input, int level, Sdb *db, int opts, PJ* pj) {\n\tchar arg[32], pre[128];\n\tRAnalRef *ref;\n\tut64 addr = core->offset;\n\tbool is_json = opts & R_CORE_ANAL_JSON;\n\tbool is_r2 = opts & R_CORE_ANAL_GRAPHBODY;\n\tif (is_json && !pj) {\n\t\treturn;\n\t}\n\tif (input && *input) {\n\t\taddr = r_num_math (core->num, input);\n\t}\n\t// eprintf (\"Path between 0x%08\"PFMT64x\" .. 0x%08\"PFMT64x\"\\n\", core->offset, addr);\n\tint spaces = (level + 1) * 2;\n\tif (spaces > sizeof (pre) - 4) {\n\t\tspaces = sizeof (pre) - 4;\n\t}\n\tmemset (pre, ' ', sizeof (pre));\n\tstrcpy (pre + spaces, \"- \");\n\n\tRVecAnalRef *xrefs = r_anal_xrefs_get (core->anal, addr);\n\tbool open_object = false;\n\tif (xrefs && !RVecAnalRef_empty (xrefs)) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, -1);\n\t\tif (fcn) {\n\t\t\tif (is_r2) {\n\t\t\t\tr_cons_printf (\"agn 0x%08\"PFMT64x\" %s\\n\", fcn->addr, fcn->name);\n\t\t\t} else if (is_json) {\n\t\t\t\tchar taddr[64];\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_k (pj, sdb_itoa (addr, 10, taddr, sizeof (taddr)));\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"type\", \"fcn\");\n\t\t\t\tpj_kn (pj, \"fcn_addr\", fcn->addr);\n\t\t\t\tpj_ks (pj, \"name\", fcn->name);\n\t\t\t\tpj_k (pj, \"refs\");\n\t\t\t\tpj_a (pj);\n\t\t\t\topen_object = true;\n\t\t\t} else {\n\t\t\t\t//if (sdb_add (db, fcn->name, \"1\", 0)) {\n\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" fcn 0x%08\"PFMT64x\" %s\\n\",\n\t\t\t\t\tpre + 2, addr, fcn->addr, fcn->name);\n\t\t\t\t//}\n\t\t\t}\n\t\t} else {\n\t\t\tif (is_r2) {\n\t\t\t\tr_cons_printf (\"age 0x%08\"PFMT64x\"\\n\", addr);\n\t\t\t} else if (is_json) {\n\t\t\t\tchar taddr[64];\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_k (pj, sdb_itoa (addr, 10, taddr, sizeof (taddr)));\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_k (pj, \"refs\");\n\t\t\t\tpj_a (pj);\n\t\t\t\topen_object = true;\n\t\t\t} else {\n\t\t\t//snprintf (arg, sizeof (arg), \"0x%08\"PFMT64x, addr);\n\t\t\t//if (sdb_add (db, arg, \"1\", 0)) {\n\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\"\\n\", pre+2, addr);\n\t\t\t//}\n\t\t\t}\n\t\t}\n\t}\n\tif (xrefs) {\n\t\tR_VEC_FOREACH (xrefs, ref) {\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, ref->addr, -1);\n\t\t\tif (fcn) {\n\t\t\t\tif (is_r2) {\n\t\t\t\t\tr_cons_printf (\"agn 0x%08\"PFMT64x\" %s\\n\", fcn->addr, fcn->name);\n\t\t\t\t\tr_cons_printf (\"age 0x%08\"PFMT64x\" 0x%08\"PFMT64x\"\\n\", fcn->addr, addr);\n\t\t\t\t} else if (is_json) {\n\t\t\t\t\tif (level == 0) {\n\t\t\t\t\t\tchar taddr[64];\n\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\tpj_k (pj, sdb_itoa (ref->addr, 10, taddr, sizeof (taddr)));\n\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\tpj_ks (pj, \"type\", \"fcn\");\n\t\t\t\t\t\tpj_kn (pj, \"fcn_addr\", fcn->addr);\n\t\t\t\t\t\tpj_ks (pj, \"name\", fcn->name);\n\t\t\t\t\t\tpj_k (pj, \"refs\");\n\t\t\t\t\t\tpj_a (pj);\n\t\t\t\t\t\topen_object = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar taddr[64];\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\tpj_k (pj, sdb_itoa (ref->addr, 10, taddr, sizeof (taddr)));\n\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\tpj_ks (pj, \"type\", \"fcn\");\n\t\t\t\t\t\tpj_kn (pj, \"fcn_addr\", fcn->addr);\n\t\t\t\t\t\tpj_ks (pj, \"name\", fcn->name);\n\t\t\t\t\t\tpj_k (pj, \"refs\");\n\t\t\t\t\t\tpj_a (pj);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" fcn 0x%08\"PFMT64x\" %s\\n\", pre, ref->addr, fcn->addr, fcn->name);\n\t\t\t\t}\n\t\t\t\tif (sdb_add (db, fcn->name, \"1\", 0)) {\n\t\t\t\t\tsnprintf (arg, sizeof (arg), \"0x%08\"PFMT64x, fcn->addr);\n\t\t\t\t\tanal_axg (core, arg, level + 1, db, opts, pj);\n\t\t\t\t} else {\n\t\t\t\t\tif (is_json) {\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\topen_object = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (is_r2) {\n\t\t\t\t\tr_cons_printf (\"agn 0x%08\"PFMT64x\" ???\\n\", ref->addr);\n\t\t\t\t\tr_cons_printf (\"age 0x%08\"PFMT64x\" 0x%08\"PFMT64x\"\\n\", ref->addr, addr);\n\t\t\t\t} else if (is_json) {\n\t\t\t\t\tchar taddr[64];\n\t\t\t\t\tpj_o (pj);\n\t\t\t\t\tpj_k (pj, sdb_itoa (ref->addr, 10, taddr, sizeof (taddr)));\n\t\t\t\t\tpj_o (pj);\n\t\t\t\t\tpj_ks (pj, \"type\", \"???\");\n\t\t\t\t\tpj_k (pj, \"refs\");\n\t\t\t\t\tpj_a (pj);\n\t\t\t\t\topen_object = true;\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" ???\\n\", pre, ref->addr);\n\t\t\t\t}\n\t\t\t\tsnprintf (arg, sizeof (arg), \"0x%08\"PFMT64x, ref->addr);\n\t\t\t\tif (sdb_add (db, arg, \"1\", 0)) {\n\t\t\t\t\tanal_axg (core, arg, level + 1, db, opts, pj);\n\t\t\t\t} else {\n\t\t\t\t\tif (is_json) {\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\topen_object = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (is_json) {\n\t\tif (open_object) {\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t}\n\t\tif (level == 0) {\n\t\t\tif (open_object) {\n\t\t\t\tpj_end (pj);\n\t\t\t\tpj_end (pj);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t}\n\t}\n\tRVecAnalRef_free (xrefs);\n}\n\nstatic void cmd_anal_ucall_ref(RCore *core, ut64 addr) {\n\tRAnalFunction * fcn = r_anal_get_function_at (core->anal, addr);\n\tif (fcn) {\n\t\tr_cons_printf (\" ; %s\", fcn->name);\n\t} else {\n\t\tr_cons_printf (\" ; 0x%\" PFMT64x, addr);\n\t}\n}\n\nstatic char *get_op_ireg(void *user, ut64 addr) {\n\tRCore *core = (RCore *)user;\n\tchar *res = NULL;\n\tRAnalOp *op = r_core_anal_op (core, addr, 0);\n\tif (op && op->ireg) {\n\t\tres = strdup (op->ireg);\n\t}\n\tr_anal_op_free (op);\n\treturn res;\n}\n\nstatic char *get_buf_asm(RCore *core, ut64 from, ut64 addr, RAnalFunction *fcn, bool color) {\n\tint has_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\tchar str[512];\n\tconst int size = 12;\n\tut8 buf[12];\n\tRAnalOp asmop = {0};\n\tbool asm_subvar = r_config_get_b (core->config, \"asm.sub.var\");\n\tbool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->rasm->config);\n\tcore->parser->pseudo = r_config_get_b (core->config, \"asm.pseudo\");\n\tcore->parser->subrel = r_config_get_i (core->config, \"asm.sub.rel\");\n\tcore->parser->localvar_only = r_config_get_b (core->config, \"asm.sub.varonly\");\n\n\tif (core->parser->subrel) {\n\t\tcore->parser->subrel_addr = from;\n\t}\n\tr_io_read_at (core->io, addr, buf, size);\n\tr_asm_set_pc (core->rasm, addr);\n\tr_asm_disassemble (core->rasm, &asmop, buf, size);\n\tint ba_len = strlen (asmop.mnemonic) + 128;\n\tchar *ba = malloc (ba_len);\n\tstrcpy (ba, asmop.mnemonic);\n\tif (asm_subvar) {\n\t\tcore->parser->get_ptr_at = r_anal_function_get_var_stackptr_at;\n\t\tcore->parser->get_reg_at = r_anal_function_get_var_reg_at;\n\t\tcore->parser->get_op_ireg = get_op_ireg;\n\t\tr_parse_subvar (core->parser, fcn, addr, asmop.size, ba, ba, ba_len);\n\t}\n\tRAnalHint *hint = r_anal_hint_get (core->anal, addr);\n\tr_parse_filter (core->parser, addr, core->flags, hint, ba, str, sizeof (str), be);\n\tr_anal_hint_free (hint);\n\tr_anal_op_set_mnemonic (&asmop, asmop.addr, ba);\n\tfree (ba);\n\tchar *buf_asm = NULL;\n\tif (color && has_color) {\n\t\tbuf_asm = r_print_colorize_opcode (core->print, str,\n\t\t\t\tcore->cons->context->pal.reg, core->cons->context->pal.num, false, fcn ? fcn->addr : 0);\n\t} else {\n\t\tbuf_asm = r_str_new (str);\n\t}\n\treturn buf_asm;\n}\n\nstatic const char *axtm_name(RCore *core, ut64 addr) {\n\tconst char *name = NULL;\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, -1);\n\tif (fcn) {\n\t\tname = fcn->name;\n\t} else {\n\t\tRFlagItem *f = r_flag_get_at (core->flags, addr, false);\n\t\tif (f) {\n\t\t\tname = f->name;\n\t\t}\n\t}\n\treturn name;\n}\n\n// Alternative sorting, first by \"addr\"/\"from\", then by \"at\"/\"to\"\nstatic inline int compare_ref(const RAnalRef *a, const RAnalRef *b) {\n\tif (a->addr < b->addr) {\n\t\treturn -1;\n\t}\n\tif (a->addr > b->addr) {\n\t\treturn 1;\n\t}\n\tif (a->at < b->at) {\n\t\treturn -1;\n\t}\n\tif (a->at > b->at) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void axtm(RCore *core) {\n\tRVecAnalRef *refs = r_anal_xrefs_get (core->anal, UT64_MAX);\n\tif (refs && !RVecAnalRef_empty (refs)) {\n\t\tRVecAnalRef_sort (refs, compare_ref);\n\n\t\tut64 last_addr = UT64_MAX;\n\t\tRAnalRef *ref;\n\t\tR_VEC_FOREACH (refs, ref) {\n\t\t\tconst bool is_first = ref->addr != last_addr;\n\t\t\tconst char *name;\n\t\t\tif (is_first) {\n\t\t\t\tname = axtm_name (core, ref->addr);\n\t\t\t\tr_cons_printf (\"0x%\"PFMT64x\": %s\\n\", ref->addr, name? name: \"?\");\n\t\t\t}\n\n\t\t\tname = axtm_name (core, ref->at);\n\t\t\tr_cons_printf (\"  0x%\"PFMT64x\": %s\\n\", ref->at, name? name: \"?\");\n\n\t\t\tlast_addr = ref->addr;\n\t\t}\n\t}\n\n\tRVecAnalRef_free (refs);\n}\n\nstatic void axfm(RCore *core) {\n\tRVecAnalRef *refs = r_anal_xrefs_get_from (core->anal, UT64_MAX);\n\tif (refs && !RVecAnalRef_empty (refs)) {\n\t\tRVecAnalRef_sort (refs, compare_ref);\n\n\t\tut64 last_addr = UT64_MAX;\n\t\tRAnalRef *ref;\n\t\tR_VEC_FOREACH (refs, ref) {\n\t\t\tconst bool is_first = ref->addr != last_addr;\n\t\t\tconst char *name;\n\t\t\tif (is_first) {\n\t\t\t\tname = axtm_name (core, ref->addr);\n\t\t\t\tr_cons_printf (\"0x%\"PFMT64x\": %s\\n\", ref->addr, name? name: \"?\");\n\t\t\t}\n\n\t\t\tname = axtm_name (core, ref->at);\n\t\t\tr_cons_printf (\"  0x%\"PFMT64x\": %s\\n\", ref->at, name? name: \"?\");\n\n\t\t\tlast_addr = ref->addr;\n\t\t}\n\t}\n\n\tRVecAnalRef_free (refs);\n}\n\nstatic bool cmd_anal_refs(RCore *core, const char *input) {\n\tbool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->print->config);\n\tut64 addr = core->offset;\n\tswitch (input[0]) {\n\tcase '-': { // \"ax-\"\n\t\tchar *cp_inp = strdup (input + 1);\n\t\tchar *ptr = cp_inp;\n\t\tr_str_trim_head (ptr);\n\t\tif (!strcmp (ptr, \"*\")) { // \"ax-*\"\n\t\t\tr_anal_xrefs_init (core->anal);\n\t\t} else {\n\t\t\tint n = r_str_word_set0 (ptr);\n\t\t\tut64 from = UT64_MAX, to = UT64_MAX;\n\t\t\tswitch (n) {\n\t\t\tcase 2:\n\t\t\t\tfrom = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t\t//fall through\n\t\t\tcase 1: // get addr\n\t\t\t\tto = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tto = core->offset;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// R2_590 slow, we should add a function that deletes several xrefs\n\t\t\tRVecAnalRef *list = r_anal_xrefs_get (core->anal, to);\n\t\t\tRAnalRef *ref;\n\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\tif (from != UT64_MAX && from == ref->addr) {\n\t\t\t\t\tr_anal_xref_del (core->anal, ref->addr, ref->at);\n\t\t\t\t}\n\t\t\t\tif (from == UT64_MAX) {\n\t\t\t\t\tr_anal_xref_del (core->anal, ref->addr, ref->at);\n\t\t\t\t}\n\t\t\t}\n\t\t\tRVecAnalRef_free (list);\n\t\t}\n\t\tfree (cp_inp);\n\t} break;\n\tcase 'g': // \"axg\"\n\t\t{\n\t\t\tSdb *db = sdb_new0 ();\n\t\t\tif (input[1] == '*') {\n\t\t\t\tanal_axg (core, input + 2, 0, db, R_CORE_ANAL_GRAPHBODY, NULL); // r2 commands\n\t\t\t} else if (input[1] == 'j') {\n\t\t\t\tPJ *pj = pj_new ();\n\t\t\t\tanal_axg (core, input + 2, 0, db, R_CORE_ANAL_JSON, pj);\n\t\t\t\tr_cons_printf(\"%s\\n\", pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t} else {\n\t\t\t\tanal_axg (core, input[1] ? input + 2 : NULL, 0, db, 0, NULL);\n\t\t\t}\n\t\t\tsdb_free (db);\n\t\t}\n\t\tbreak;\n\tcase '\\0': // \"ax\"\n\tcase 'q': // \"axq\"\n\tcase '*': // \"ax*\"\n\tcase ',': // \"ax,\"\n\t\tr_anal_xrefs_list (core->anal, input[0], *input? r_str_trim_head_ro (input + 1): \"\");\n\t\tbreak;\n\tcase '.': { // \"ax.\"\n\t\tchar *tInput = strdup (input);\n\t\tif (r_str_replace_ch (tInput, '.', 't', false)) {\n\t\t\tcmd_anal_refs (core, tInput);\n\t\t}\n\t\tchar *fInput = strdup (input);\n\t\tif (r_str_replace_ch (fInput, '.', 'f', false)) {\n\t\t\tcmd_anal_refs (core, fInput);\n\t\t}\n\t\tfree (tInput);\n\t\tfree (fInput);\n\t} break;\n\tcase 'm': { // \"axm\"\n\t\tchar *ptr = strdup (r_str_trim_head_ro (input + 1));\n\t\tint n = r_str_word_set0 (ptr);\n\t\tut64 at = core->offset;\n\t\tut64 addr = UT64_MAX;\n\t\tswitch (n) {\n\t\tcase 2: // get at\n\t\t\tat = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t/* fall through */\n\t\tcase 1: // get addr\n\t\t\taddr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfree (ptr);\n\t\t\treturn false;\n\t\t}\n\t\t//get all xrefs pointing to addr\n\t\tRVecAnalRef *list = r_anal_xrefs_get (core->anal, addr);\n\t\tRAnalRef *ref;\n\t\tR_VEC_FOREACH (list, ref) {\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\" %s %s\\n\", ref->addr,\n\t\t\t\tr_anal_ref_perm_tostring (ref),\n\t\t\t\tr_anal_ref_type_tostring (ref->type));\n\t\t\tr_anal_xrefs_set (core->anal, ref->addr, at, ref->type);\n\t\t}\n\t\tRVecAnalRef_free (list);\n\t\tfree (ptr);\n\t} break;\n\tcase 'v': // \"axv\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_axv);\n\t\t} else {\n\t\t\tcmd_afvx (core, NULL, input[1] == 'j');\n\t\t}\n\t\tbreak;\n\tcase 'l': // \"axl\"\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_axl);\n\t\t\tbreak;\n\t\tcase 'j': // \"axlj\"\n\t\t\tr_anal_xrefs_list (core->anal, 'j', \"\");\n\t\t\tbreak;\n\t\tcase 'c': // \"axlc\"\n\t\t\t{\n\t\t\t\tut64 count = r_anal_xrefs_count (core->anal);\n\t\t\t\tr_cons_printf (\"%\"PFMT64d\"\\n\", count);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'q': // \"axlq\"\n\t\t\tr_core_cmd_call (core, \"axq\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_call (core, \"ax\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 't': { // \"axt\"\n\t\tif (input[1] == '?') { // \"axt?\"\n\t\t\tr_core_cmd_help (core, help_msg_axt);\n\t\t\tbreak;\n\t\t}\n\t\tif (input[1] == 'm') { // \"axtm\"\n\t\t\t// like aflm but reversed\n\t\t\taxtm (core);\n\t\t\tbreak;\n\t\t}\n\t\tRAnalFunction *fcn;\n\t\tchar *space = strchr (input, ' ');\n\t\tif (space) {\n\t\t\taddr = r_num_math (core->num, space + 1);\n\t\t\tif (core->num->nc.errors > 0) {\n\t\t\t\tR_LOG_ERROR (\"Invalid argument\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\taddr = core->offset;\n\t\t}\n\t\tRVecAnalRef *list = r_anal_xrefs_get (core->anal, addr);\n\t\tif (list) {\n\t\t\tif (input[1] == 'q') { // \"axtq\"\n\t\t\t\tRAnalRef *ref;\n\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", ref->addr);\n\t\t\t\t}\n\t\t\t} else if (input[1] == 'j') { // \"axtj\"\n\t\t\t\tPJ *pj = pj_new ();\n\t\t\t\tif (!pj) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpj_a (pj);\n\t\t\t\tRAnalRef *ref;\n\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, ref->addr, 0);\n\t\t\t\t\tchar *str = get_buf_asm (core, addr, ref->addr, fcn, false);\n\t\t\t\t\tpj_o (pj);\n\t\t\t\t\tpj_kn (pj, \"from\", ref->addr);\n\t\t\t\t\tif (ref->type) {\n\t\t\t\t\t\tpj_ks (pj, \"type\", r_anal_ref_type_tostring (ref->type));\n\t\t\t\t\t\tpj_ks (pj, \"perm\", r_anal_ref_perm_tostring (ref));\n\t\t\t\t\t}\n\t\t\t\t\tpj_ks (pj, \"opcode\", str);\n\t\t\t\t\tif (fcn) {\n\t\t\t\t\t\tpj_kn (pj, \"fcn_addr\", fcn->addr);\n\t\t\t\t\t\tpj_ks (pj, \"fcn_name\", fcn->name);\n\t\t\t\t\t}\n\t\t\t\t\tRFlagItem *fi = r_flag_get_at (core->flags, fcn? fcn->addr: ref->addr, true);\n\t\t\t\t\tif (fi) {\n\t\t\t\t\t\tif (fcn) {\n\t\t\t\t\t\t\tif (strcmp (fcn->name, fi->name)) {\n\t\t\t\t\t\t\t\tpj_ks (pj, \"flag\", fi->name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpj_k (pj, \"name\");\n\t\t\t\t\t\t\tif (fi->offset != ref->addr) {\n\t\t\t\t\t\t\t\tint delta = (int)(ref->addr - fi->offset);\n\t\t\t\t\t\t\t\tchar *name_ref = r_str_newf (\"%s+%d\", fi->name, delta);\n\t\t\t\t\t\t\t\tpj_s (pj, name_ref);\n\t\t\t\t\t\t\t\tfree (name_ref);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpj_s (pj, fi->name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (fi->realname && strcmp (fi->name, fi->realname)) {\n\t\t\t\t\t\t\tchar *escaped = r_str_escape (fi->realname);\n\t\t\t\t\t\t\tif (escaped) {\n\t\t\t\t\t\t\t\tpj_ks (pj, \"realname\", escaped);\n\t\t\t\t\t\t\t\tfree (escaped);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRFlagItem *fi = r_flag_get_at (core->flags, fcn? fcn->addr: ref->addr, false);\n\t\t\t\t\t\tif (fi) {\n\t\t\t\t\t\t\tpj_ks (pj, \"near_name\", fi->name);\n\t\t\t\t\t\t\tpj_kn (pj, \"near_addr\", fi->offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchar *refname = core->anal->coreb.getNameDelta (core, ref->at);\n\t\t\t\t\tif (refname) {\n\t\t\t\t\t\tr_str_replace_ch (refname, ' ', 0, true);\n\t\t\t\t\t\tpj_ks (pj, \"refname\", refname);\n\t\t\t\t\t\tfree (refname);\n\t\t\t\t\t}\n\t\t\t\t\tpj_end (pj);\n\t\t\t\t\tfree (str);\n\t\t\t\t}\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_printf (\"%s\", pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t\tr_cons_newline ();\n\t\t\t} else if (input[1] == 'g') { // axtg\n\t\t\t\tRAnalRef *ref;\n\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\tchar *str = r_core_cmd_strf (core, \"fd 0x%\"PFMT64x, ref->addr);\n\t\t\t\t\tif (!str) {\n\t\t\t\t\t\tstr = strdup (\"?\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tr_str_trim_tail (str);\n\t\t\t\t\tr_cons_printf (\"agn 0x%\" PFMT64x \" \\\"%s\\\"\\n\", ref->addr, str);\n\t\t\t\t\tfree (str);\n\t\t\t\t}\n\t\t\t\tif (input[2] != '*') {\n\t\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\t\t\tr_cons_printf (\"agn 0x%\" PFMT64x \" \\\"%s\\\"\\n\", addr, fcn?fcn->name: \"$$\");\n\t\t\t\t}\n\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\tr_cons_printf (\"age 0x%\" PFMT64x \" 0x%\"PFMT64x\"\\n\", ref->addr, addr);\n\t\t\t\t}\n\t\t\t} else if (input[1] == '*') { // axt*\n\t\t\t\t// TODO: implement multi-line comments\n\t\t\t\tconst ut64 length = RVecAnalRef_length (list);\n\t\t\t\tut64 i = 0;\n\t\t\t\tRAnalRef *ref;\n\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\tconst bool is_at_end = i == length;\n\t\t\t\t\tr_cons_printf (\"CCa 0x%\" PFMT64x \" \\\"XREF type %d at 0x%\" PFMT64x\"%s\\n\",\n\t\t\t\t\t\tref->addr, ref->type, addr, is_at_end? \"\": \",\");\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t} else if (input[1] == ' ' || input[1] == 0) { // \"axt\"\n\t\t\t\tRAnalFunction *fcn;\n\t\t\t\tRAnalRef *ref;\n\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, ref->addr, 0);\n\t\t\t\t\tchar *buf_asm = get_buf_asm (core, addr, ref->addr, fcn, true);\n\t\t\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, ref->addr);\n\t\t\t\t\tchar *print_comment = NULL;\n\t\t\t\t\tconst char *nl = comment ? strchr (comment, '\\n') : NULL;\n\t\t\t\t\tif (nl) { // display only until the first newline\n\t\t\t\t\t\tcomment = print_comment = r_str_ndup (comment, nl - comment);\n\t\t\t\t\t}\n\t\t\t\t\tchar *buf_fcn = comment\n\t\t\t\t\t\t? r_str_newf (\"%s; %s\", fcn ?  fcn->name : \"(nofunc)\", comment)\n\t\t\t\t\t\t: r_str_newf (\"%s\", fcn ? fcn->name : \"(nofunc)\");\n\t\t\t\t\tfree (print_comment);\n\t\t\t\t\tr_cons_printf (\"%s 0x%\" PFMT64x \" [%s:%s] %s\\n\",\n\t\t\t\t\t\tbuf_fcn, ref->addr, r_anal_ref_type_tostring (ref->type),\n\t\t\t\t\t\tr_anal_ref_perm_tostring (ref), buf_asm);\n\t\t\t\t\tfree (buf_asm);\n\t\t\t\t\tfree (buf_fcn);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_core_cmd_help (core, help_msg_axt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (input[1] == 'j') { // \"axtj\"\n\t\t\t\tPJ *pj = pj_new ();\n\t\t\t\tif (!pj) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpj_a (pj);\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t}\n\t\t}\n\t\tRVecAnalRef_free (list);\n\t} break;\n\tcase 'f':\n\t\tif (input[1] == 'f') { // \"axff\"\n\t\t\tRAnalFunction * fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\tPJ *pj = NULL;\n\t\t\tif (input[2] == 'j') { // \"axffj\"\n\t\t\t\t// start a new JSON object\n\t\t\t\tpj = pj_new ();\n\t\t\t\tpj_a (pj);\n\t\t\t}\n\t\t\tif (fcn) {\n\t\t\t\tRVecAnalRef *refs = r_anal_function_get_refs (fcn);\n\t\t\t\tRAnalRef *refi;\n\t\t\t\tR_VEC_FOREACH (refs, refi) {\n\t\t\t\t\tRFlagItem *f = r_flag_get_at (core->flags, refi->addr, true);\n\t\t\t\t\tconst char *name = f ? f->name: \"\";\n\t\t\t\t\tif (pj) {\n\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\tpj_ks (pj, \"type\", r_anal_ref_type_tostring(refi->type));\n\t\t\t\t\t\tpj_kn (pj, \"at\", refi->at);\n\t\t\t\t\t\tpj_kn (pj, \"ref\", refi->addr);\n\t\t\t\t\t\tpj_ks (pj, \"name\", name);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s\\n\",\n\t\t\t\t\t\t\tr_anal_ref_type_tostring(refi->type), refi->at, refi->addr, name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRVecAnalRef_free (refs);\n\t\t\t\tif (pj) {\n\t\t\t\t\tpj_end (pj);\n\t\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot find any function\");\n\t\t\t}\n\t\t\tpj_free (pj);\n\t\t} else { // \"axf\"\n\t\t\tif (input[1] == '?') { // \"axf?\"\n\t\t\t\tr_core_cmd_help (core, help_msg_axf);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (input[1] == 'm') { // \"axfm\"\n\t\t\t\t// like aflm but reversed\n\t\t\t\taxfm (core);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRAnalOp asmop;\n\t\t\tchar *space = strchr (input, ' ');\n\t\t\tif (space) {\n\t\t\t\taddr = r_num_math (core->num, space + 1);\n\t\t\t\tif (core->num->nc.errors > 0) {\n\t\t\t\t\tR_LOG_ERROR (\"Invalid argument\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr = core->offset;\n\t\t\t}\n\t\t\tRAnalFunction * fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\tRVecAnalRef *list;\n\t\t\tif (input[1] == '.') { // \"axf.\"\n\t\t\t\tlist = r_anal_xrefs_get_from (core->anal, addr);\n\t\t\t\tif (!list) {\n\t\t\t\t\tlist = r_anal_function_get_refs (fcn);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlist = r_anal_refs_get (core->anal, addr);\n\t\t\t}\n\n\t\t\tif (list) {\n\t\t\t\tif (input[1] == 'q') { // \"axfq\"\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", ref->at);\n\t\t\t\t\t}\n\t\t\t\t} else if (input[1] == 'j') { // \"axfj\"\n\t\t\t\t\tPJ *pj = pj_new ();\n\t\t\t\t\tif (!pj) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tpj_a (pj);\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\t\t// TODO: Use r_core_anal_op(DISASM) instead of all those 4 lines\n\t\t\t\t\t\tut8 buf[16];\n\t\t\t\t\t\tr_io_read_at (core->io, ref->addr, buf, sizeof (buf));\n\t\t\t\t\t\tr_asm_set_pc (core->rasm, ref->addr);\n\t\t\t\t\t\tr_asm_disassemble (core->rasm, &asmop, buf, sizeof (buf));\n\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\tpj_kn (pj, \"from\", ref->at);\n\t\t\t\t\t\tpj_kn (pj, \"to\", ref->addr);\n\t\t\t\t\t\tpj_ks (pj, \"type\", r_anal_ref_type_tostring (ref->type));\n\t\t\t\t\t\tpj_ks (pj, \"perm\", r_anal_ref_perm_tostring (ref));\n\t\t\t\t\t\tpj_ks (pj, \"opcode\", r_asm_op_get_asm (&asmop));\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t}\n\t\t\t\t\tpj_end (pj);\n\t\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\t\tpj_free (pj);\n\t\t\t\t} else if (input[1] == '*') { // \"axf*\"\n\t\t\t\t\t// TODO: implement multi-line comments\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\t\tr_cons_printf (\"CCa 0x%\" PFMT64x \" \\\"XREF from 0x%u \\n\",\n\t\t\t\t\t\t\t\tref->at, ref->type);\n\t\t\t\t\t}\n\t\t\t\t} else { // \"axf\"\n\t\t\t\t\tchar str[512];\n\t\t\t\t\tint has_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\t\tut8 buf[16] = {0};\n\t\t\t\t\t\tchar *desc;\n\t\t\t\t\t\tchar *desc_to_free = NULL;\n\t\t\t\t\t\tRFlagItem *flag = r_flag_get_at (core->flags, ref->addr, false);\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\tdesc = flag->name;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_io_read_at (core->io, ref->addr, buf, sizeof (buf));\n\t\t\t\t\t\t\tr_asm_set_pc (core->rasm, ref->addr);\n\t\t\t\t\t\t\tr_asm_disassemble (core->rasm, &asmop, buf, sizeof (buf));\n\t\t\t\t\t\t\tRAnalHint *hint = r_anal_hint_get (core->anal, ref->addr);\n\t\t\t\t\t\t\tr_parse_filter (core->parser, ref->addr, core->flags, hint, r_asm_op_get_asm (&asmop),\n\t\t\t\t\t\t\t\t\tstr, sizeof (str), be);\n\t\t\t\t\t\t\tr_anal_hint_free (hint);\n\t\t\t\t\t\t\tif (has_color) {\n\t\t\t\t\t\t\t\tdesc = desc_to_free = r_print_colorize_opcode (core->print, str,\n\t\t\t\t\t\t\t\t\t\tcore->cons->context->pal.reg, core->cons->context->pal.num, false, fcn ? fcn->addr : 0);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdesc = str;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_printf (\"%s 0x%\" PFMT64x \" %s\",\n\t\t\t\t\t\t\t\tr_anal_ref_type_tostring (ref->type), ref->addr, desc);\n\n\t\t\t\t\t\tif (R_ANAL_REF_TYPE_MASK (ref->type) == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\t\t\t\tRAnalOp aop;\n\t\t\t\t\t\t\tr_anal_op (core->anal, &aop, ref->addr, buf, sizeof (buf), R_ARCH_OP_MASK_BASIC);\n\t\t\t\t\t\t\tif (aop.type == R_ANAL_OP_TYPE_UCALL) {\n\t\t\t\t\t\t\t\tcmd_anal_ucall_ref (core, ref->addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t\tfree (desc_to_free);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (input[1] == 'j') { // \"axfj\"\n\t\t\t\t\tr_cons_print (\"[]\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tRVecAnalRef_free (list);\n\t\t}\n\t\tbreak;\n\tcase 'F': // \"axF\"\n\t\tfind_refs (core, input + 1);\n\t\tbreak;\n\tcase 'C': // \"axC\"\n\tcase 'c': // \"axc\"\n\tcase 'i': // \"axi\"\n\tcase 'r': // \"axr\"\n\tcase 'w': // \"axw\"\n\tcase 'j': // \"axj\"\n\tcase 'd': // \"axd\"\n\tcase 's': // \"axs\"\n\tcase ' ': // \"ax \"\n\t\tif (input[1] == '?') {\n\t\t\tchar *s = r_str_newf (\"ax%c\", input[0]);\n\t\t\tr_core_cmd_help_match (core, help_msg_ax, s, true);\n\t\t\tfree (s);\n\t\t} else {\n\t\t\tchar *ptr = strdup (r_str_trim_head_ro ((char *)input + 1));\n\t\t\tint n = r_str_word_set0 (ptr);\n\t\t\tut64 at = core->offset;\n\t\t\tut64 addr = UT64_MAX;\n\t\t\tRAnalRefType reftype = r_anal_xrefs_type (input[0]);\n\t\t\tswitch (n) {\n\t\t\tcase 2: // get at\n\t\t\t\tat = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t/* fall through */\n\t\t\tcase 1: // get addr\n\t\t\t\taddr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfree (ptr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_anal_xrefs_set (core->anal, at, addr, reftype);\n\t\t\tfree (ptr);\n\t\t}\n\t   \tbreak;\n\tdefault:\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_ax);\n\t\tbreak;\n\t}\n\n\treturn true;\n}\nstatic void cmd_anal_hint(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase '?':\n\t\tif (input[1]) {\n\t\t\tut64 addr = r_num_math (core->num, input + 1);\n\t\t\tr_core_anal_hint_print (core->anal, addr, 0);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ah);\n\t\t}\n\t\tbreak;\n\tcase '.': // \"ah.\"\n\t\tr_core_anal_hint_print (core->anal, core->offset, 0);\n\t\tbreak;\n\tcase 'a': // \"aha\" set arch\n\t\tif (input[1] == ' ') {\n\t\t\tchar *ptr = strdup (input + 2);\n\t\t\tr_str_word_set0 (ptr);\n\t\t\tconst char *arch = r_str_word_get0 (ptr, 0);\n\t\t\tr_anal_hint_set_arch (core->anal, core->offset, !arch || strcmp (arch, \"0\") == 0 ? NULL : arch);\n\t\t\tfree (ptr);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_arch (core->anal, core->offset);\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Missing argument\");\n\t\t}\n\t\tbreak;\n\tcase 'o': // \"aho\"\n\t\tif (input[1] == '*') {\n\t\t\t// show in r2\n\t\t\tRAnalHint *hint = r_anal_hint_get (core->anal, core->offset);\n\t\t\tif (hint && hint->opcode) {\n\t\t\t\tr_cons_printf (\"aho %s @ 0x%08\"PFMT64x\"\\n\", hint->opcode, hint->addr);\n\t\t\t}\n\t\t\tr_anal_hint_free (hint);\n\t\t} else if (input[1] == 0) {\n\t\t\t// show if any\n\t\t\tRAnalHint *hint = r_anal_hint_get (core->anal, core->offset);\n\t\t\tif (hint && hint->type > 0) {\n\t\t\t\tr_cons_printf (\"%s\\n\", r_anal_optype_tostring (hint->type));\n\t\t\t}\n\t\t\tr_anal_hint_free (hint);\n\t\t}  else if (input[1] == '-') {\n\t\t\tut64 off = input[2]? r_num_math (core->num, input + 2): core->offset;\n\t\t\tr_anal_hint_unset_bits (core->anal, off);\n\t\t} else if (input[1] == ' ') {\n\t\t\tconst char *arg = r_str_trim_head_ro (input + 1);\n\t\t\tconst int type = r_anal_optype_from_string (arg);\n\t\t\tif (type != -1) {\n\t\t\t\tr_anal_hint_set_type (core->anal, core->offset, type);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Unknown opcode type. Try: io, acmp, add, sync, call, cjmp, cmp, nop,,,\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_aho);\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"ahb\" set bits\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_ahb);\n\t\t} else if (input[1] == ' ') {\n\t\t\tchar *ptr = r_str_trim_dup (input + 2);\n\t\t\tint bits;\n\t\t\tint i = r_str_word_set0 (ptr);\n\t\t\tif (i == 2) {\n\t\t\t\tr_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t}\n\t\t\tbits = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\tr_anal_hint_set_bits (core->anal, core->offset, bits);\n\t\t\tfree (ptr);\n\t\t}  else if (input[1] == '-') {\n\t\t\tif (!strcmp (input + 2, \"*\")) {\n\t\t\t\tr_anal_hint_unset_bits (core->anal, UT64_MAX);\n\t\t\t} else {\n\t\t\t\tut64 off = input[2]? r_num_math (core->num, input + 2): core->offset;\n\t\t\t\tr_anal_hint_unset_bits (core->anal, off);\n\t\t\t}\n\t\t} else {\n\t\t\tRAnalHint *hint = r_anal_hint_get (core->anal, core->offset);\n\t\t\tif (hint && hint->bits) {\n\t\t\t\tr_cons_printf (\"%d\\n\", hint->bits);\n\t\t\t}\n\t\t\tr_anal_hint_free (hint);\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"ahi\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_ahi);\n\t\t\tbreak;\n\t\t}\n\t\tif (input[1] == '-') { // \"ahi-\"\n\t\t\tut64 addr = r_num_get (core->num, input + 2);\n\t\t\t// add ahi-*\n\t\t\tr_anal_hint_set_immbase (core->anal, addr? addr: core->offset, 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (isdigit ((unsigned char)input[1])) {\n\t\t\tr_anal_hint_set_nword (core->anal, core->offset, input[1] - '0');\n\t\t\tinput++;\n\t\t}\n\t\tif (input[1] == ' ') {\n\t\t\t// You can either specify immbase with letters, or numbers\n\t\t\tint base;\n\t\t\tif (r_str_startswith (input + 2, \"10u\") || r_str_startswith (input + 2, \"du\")) {\n\t\t\t\tbase = 11;\n\t\t\t} else {\n\t\t\t\tbase = (input[2] == 's') ? 1 :\n\t\t\t\t       (input[2] == 'b') ? 2 :\n\t\t\t\t       (input[2] == 'p') ? 3 :\n\t\t\t\t       (input[2] == 'o') ? 8 :\n\t\t\t\t       (input[2] == 'd') ? 10 :\n\t\t\t\t       (input[2] == 'h') ? 16 :\n\t\t\t\t       (input[2] == 'i') ? 32 : // ip address\n\t\t\t\t       (input[2] == '3') ? 36 : // base36\n\t\t\t\t       (input[2] == 'S') ? 80 : // syscall\n\t\t\t\t       (int) r_num_math (core->num, input + 1);\n\t\t\t}\n\t\t\tr_anal_hint_set_immbase (core->anal, core->offset, base);\n\t\t} else if (!input[1]) {\n\t\t\tRAnalHint *hint = r_anal_hint_get (core->anal, core->offset);\n\t\t\tif (hint && hint->immbase) {\n\t\t\t\tr_cons_printf (\"%d\\n\", hint->immbase);\n\t\t\t}\n\t\t\tr_anal_hint_free (hint);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ahi);\n\t\t}\n\t\tbreak;\n\tcase 'h': // \"ahh\"\n\t\tif (input[1] == '-') {\n\t\t\tr_anal_hint_unset_high (core->anal, core->offset);\n\t\t} else if (input[1] == ' ') {\n\t\t\tr_anal_hint_set_high (core->anal, r_num_math (core->num, input + 1));\n\t\t} else {\n\t\t\tr_anal_hint_set_high (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"ahc\"\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_jump (\n\t\t\t\tcore->anal, core->offset,\n\t\t\t\tr_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_jump (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"ahf\"\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_fail (\n\t\t\t\tcore->anal, core->offset,\n\t\t\t\tr_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_fail (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 'F': // \"ahF\" set stackframe size\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_stackframe (\n\t\t\t\tcore->anal, core->offset,\n\t\t\t\tr_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_stackframe (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 's': // \"ahs\" set size (opcode length)\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_size (core->anal, core->offset, atoi (input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tif (input[2] == '*') {\n\t\t\t\tR_LOG_INFO (\"Not implemented\");\n\t\t\t\t// R2_590 - take arg to specify type of hint to remove .. r_anal_hint_clear (core->anal, );\n\t\t\t\t// r_anal_hint_unset_size (core->anal, UT64_MAX);\n\t\t\t\t// r_anal_hint_clear (core->anal);\n\t\t\t} else if (input[2]) {\n\t\t\t\tut64 at = r_num_math (core->num, input + 2);\n\t\t\t\tif (at != UT64_MAX) {\n\t\t\t\t\tr_anal_hint_unset_size (core->anal, at);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_anal_hint_unset_size (core->anal, core->offset);\n\t\t\t}\n\t\t} else if (input[1] == 0) {\n\t\t\tr_core_cmd0 (core, \"ah~size=\");\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ahs);\n\t\t}\n\t\tbreak;\n\tcase 'S': // \"ahS\" set asm.syntax\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_syntax (core->anal, core->offset, input + 2);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_syntax (core->anal, core->offset);\n\t\t} else {\n\t\t\tr_core_cmd_help_match (core, help_msg_ah, \"ahS\", true);\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"ahd\" set opcode string\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_opcode (core->anal, core->offset, input + 2);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_opcode (core->anal, core->offset);\n\t\t} else {\n\t\t\tr_core_cmd_help_match (core, help_msg_ah, \"ahd\", true);\n\t\t}\n\t\tbreak;\n\tcase 'e': // \"ahe\" set ESIL string\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_esil (core->anal, core->offset, input + 2);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_esil (core->anal, core->offset);\n\t\t} else {\n\t\t\tr_core_cmd_help_match (core, help_msg_ah, \"ahe\", true);\n\t\t}\n\t\tbreak;\n#if 0\n\tcase 'e': // set endian\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_opcode (core->anal, core->offset, atoi (input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_opcode (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n#endif\n\tcase 'p': // \"ahp\"\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_pointer (core->anal, core->offset, r_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') { // \"ahp-\"\n\t\t\tr_anal_hint_unset_pointer (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"ahr\"\n\t\t// XXX isnt this the same as 'aho ret' ?\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_ret (core->anal, core->offset, r_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') { // \"ahr-\"\n\t\t\tr_anal_hint_unset_ret (core->anal, core->offset);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ahr);\n\t\t}\n\t\tbreak;\n\tcase '*': // \"ah*\"\n\tcase 'j': // \"ahj\"\n\tcase '\\0': // \"ah\"\n\t\tif (input[0] && input[1] == ' ') {\n\t\t\tchar *ptr = strdup (r_str_trim_head_ro (input + 2));\n\t\t\tr_str_word_set0 (ptr);\n\t\t\tut64 addr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\tr_core_anal_hint_print (core->anal, addr, input[0]);\n\t\t\tfree (ptr);\n\t\t} else {\n\t\t\tr_core_anal_hint_list (core->anal, input[0]);\n\t\t}\n\t\tbreak;\n\tcase 'v': // \"ahv\"\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_val (\n\t\t\t\tcore->anal, core->offset,\n\t\t\t\tr_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_val (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase '-': // \"ah-\"\n\t\tif (input[1]) {\n\t\t\tif (input[1] == '*') {\n\t\t\t\tr_anal_hint_clear (core->anal);\n\t\t\t} else {\n\t\t\t\tchar *ptr = strdup (r_str_trim_head_ro (input + 1));\n\t\t\t\tut64 addr;\n\t\t\t\tint size = 1;\n\t\t\t\tint i = r_str_word_set0 (ptr);\n\t\t\t\tif (i == 2) {\n\t\t\t\t\tsize = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t\t}\n\t\t\t\tconst char *a0 = r_str_word_get0 (ptr, 0);\n\t\t\t\tif (a0 && *a0) {\n\t\t\t\t\taddr = r_num_math (core->num, a0);\n\t\t\t\t} else {\n\t\t\t\t\taddr = core->offset;\n\t\t\t\t}\n\t\t\t\tr_anal_hint_del (core->anal, addr, size);\n\t\t\t\tfree (ptr);\n\t\t\t}\n\t\t} else {\n\t\t\tr_anal_hint_clear (core->anal);\n\t\t} break;\n\tcase 't': // \"aht\"\n\t\tswitch (input[1]) {\n\t\tcase 's': { // \"ahts\"\n\t\t\tchar *off = strdup (input + 2);\n\t\t\tr_str_trim (off);\n\t\t\tint toff = r_num_math (NULL, off);\n\t\t\tif (toff) {\n\t\t\t\tRList *typeoffs = r_type_get_by_offset (core->anal->sdb_types, toff);\n\t\t\t\tRListIter *iter;\n\t\t\t\tchar *ty;\n\t\t\t\tr_list_foreach (typeoffs, iter, ty) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", ty);\n\t\t\t\t}\n\t\t\t\tr_list_free (typeoffs);\n\t\t\t}\n\t\t\tfree (off);\n\t\t\tbreak;\n\t\t}\n\t\tcase ' ': {\n\t\t\t// r_anal_hint_set_opcode (core->anal, core->offset, input + 2);\n\t\t\tconst char *off = NULL;\n\t\t\tchar *type = strdup (r_str_trim_head_ro (input + 2));\n\t\t\tchar *idx = strchr (type, ' ');\n\t\t\tif (idx) {\n\t\t\t\t*idx++ = 0;\n\t\t\t\toff = idx;\n\t\t\t}\n\t\t\tchar *ptr = strchr (type, '=');\n\t\t\tut64 offimm = 0;\n\t\t\tut64 addr;\n\n\t\t\tif (ptr) {\n\t\t\t\t*ptr++ = 0;\n\t\t\t\tr_str_trim (ptr);\n\t\t\t\tif (ptr && *ptr) {\n\t\t\t\t\taddr = r_num_math (core->num, ptr);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"address is not valid\");\n\t\t\t\t\tfree (type);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr = core->offset;\n\t\t\t}\n\t\t\tr_str_trim (type);\n\t\t\tRAnalOp asmop;\n\t\t\tRAnalOp op = {0};\n\t\t\tut8 code[128] = {0};\n\t\t\t(void)r_io_read_at (core->io, core->offset, code, sizeof (code));\n\t\t\tr_asm_set_pc (core->rasm, addr);\n\t\t\t(void)r_asm_disassemble (core->rasm, &asmop, code, sizeof (code));\n\t\t\tint ret = r_anal_op (core->anal, &op, core->offset, code, sizeof (code), R_ARCH_OP_MASK_VAL);\n\t\t\tif (ret >= 0) {\n\t\t\t\t// HACK: Just convert only the first imm seen\n\t\t\t\tRAnalValue *src = NULL;\n\t\t\t\tr_vector_foreach (&op.srcs, src) {\n\t\t\t\t\tif (src) {\n\t\t\t\t\t\tif (src->imm) {\n\t\t\t\t\t\t\toffimm = src->imm;\n\t\t\t\t\t\t} else if (src->delta) {\n\t\t\t\t\t\t\toffimm = src->delta;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!offimm) {\n\t\t\t\t\tRAnalValue *dst = r_vector_at (&op.dsts, 0);\n\t\t\t\t\tif (dst) {\n\t\t\t\t\t\tif (dst->imm) {\n\t\t\t\t\t\t\toffimm = dst->imm;\n\t\t\t\t\t\t} else if (dst->delta) {\n\t\t\t\t\t\t\toffimm = dst->delta;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (offimm != 0) {\n\t\t\t\t\tif (off) {\n\t\t\t\t\t\toffimm += r_num_math (NULL, off);\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: Allow to select from multiple choices\n\t\t\t\t\tRList *otypes = r_type_get_by_offset (core->anal->sdb_types, offimm);\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tchar *otype = NULL;\n\t\t\t\t\tr_list_foreach (otypes, iter, otype) {\n\t\t\t\t\t\t// TODO: I don't think we should silently error, it is confusing\n\t\t\t\t\t\tif (!strcmp (type, otype)) {\n\t\t\t\t\t\t\t//eprintf (\"Adding type offset %s\\n\", type);\n\t\t\t\t\t\t\tr_type_link_offset (core->anal->sdb_types, type, addr);\n\t\t\t\t\t\t\tr_anal_hint_set_offset (core->anal, addr, otype);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!otype) {\n\t\t\t\t\t\tR_LOG_ERROR (\"wrong type for opcode offset\");\n\t\t\t\t\t}\n\t\t\t\t\tr_list_free (otypes);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_anal_op_fini (&op);\n\t\t\tfree (type);\n\t\t} break;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_aht);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void agraph_print_node_gml(RANode *n, void *user) {\n\tr_cons_printf (\"  node [\\n\"\n\t\t\"    id  %d\\n\"\n\t\t\"    label  \\\"%s\\\"\\n\"\n\t\t\"  ]\\n\", n->gnode->idx, n->title);\n}\n\nstatic void agraph_print_edge_gml(RANode *from, RANode *to, void *user) {\n\tr_cons_printf (\"  edge [\\n\"\n\t\t\"    source  %d\\n\"\n\t\t\"    target  %d\\n\"\n\t\t\"  ]\\n\", from->gnode->idx, to->gnode->idx\n\t\t);\n}\n\nstatic void agraph_print_node_dot(RANode *n, void *user) {\n\tif (R_STR_ISEMPTY (n->body)) {\n\t\tr_cons_printf (\"\\\"%s\\\" [URL=\\\"%s\\\", color=\\\"lightgray\\\", label=\\\"%s\\\"]\\n\",\n\t\t\t\tn->title, n->title, n->title);\n\t} else {\n\t\tchar *label = strdup (n->body);\n\t\t//label = r_str_replace (label, \"\\n\", \"\\\\l\", 1);\n\t\tr_cons_printf (\"\\\"%s\\\" [URL=\\\"%s\\\", color=\\\"lightgray\\\", label=\\\"%s\\\\n%s\\\"]\\n\",\n\t\t\t\tn->title, n->title, n->title, label);\n\t\tfree (label);\n\t}\n}\n\nstatic void agraph_print_node(RANode *n, void *user) {\n\tsize_t len = strlen (n->body);\n\n\tif (len > 0 && n->body[len - 1] == '\\n') {\n\t\tlen--;\n\t}\n\tchar *encbody = r_base64_encode_dyn (n->body, len);\n\tchar *cmd = r_str_newf (\"agn \\\"%s\\\" base64:%s\\n\", n->title, encbody);\n\tr_cons_print (cmd);\n\tfree (cmd);\n\tfree (encbody);\n}\n\nstatic char *getViewerPath(void) {\n\tint i;\n\tconst char *viewers[] = {\n#if R2__WINDOWS__\n\t\t\"explorer\",\n#else\n\t\t\"open\",\n\t\t\"geeqie\",\n\t\t\"gqview\",\n\t\t\"eog\",\n\t\t\"xdg-open\",\n#endif\n\t\tNULL\n\t};\n\tfor (i = 0; viewers[i]; i++) {\n\t\tchar *viewerPath = r_file_path (viewers[i]);\n\t\tif (viewerPath) {\n\t\t\treturn viewerPath;\n\t\t}\n\t\tfree (viewerPath);\n\t}\n\treturn NULL;\n}\n\nstatic char *dot_executable_path(void) {\n\tchar *dotPath = r_file_path (\"dot\");\n\tif (!dotPath) {\n\t\tdotPath = r_file_path (\"xdot\");\n\t}\n\treturn dotPath;\n}\n\nstatic bool convert_dot_to_image(RCore *core, const char *dot_file, const char *save_path) {\n\tchar *dot = dot_executable_path ();\n\tbool result = false;\n\tif (!dot) {\n\t\tR_LOG_ERROR (\"Graphviz not found in PATH\");\n\t\treturn false;\n\t}\n\tconst char *ext = r_config_get (core->config, \"graph.gv.format\");\n\n\tchar *cmd = NULL;\n\tif (save_path && *save_path) {\n\t\tcmd = r_str_newf (\"!%s -T%s -o%s a.dot;\", dot, ext, save_path);\n\t} else {\n\t\tchar *viewer = getViewerPath();\n\t\tif (viewer) {\n\t\t\tcmd = r_str_newf (\"!%s -T%s -oa.%s a.dot;!%s a.%s\",\n\t\t\t\tdot, ext, ext, viewer, ext);\n\t\t\tfree (viewer);\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find a valid picture viewer\");\n\t\t\tgoto end;\n\t\t}\n\t}\n\tr_core_cmd0 (core, cmd);\n\tresult = true;\nend:\n\tfree (cmd);\n\tfree (dot);\n\treturn result;\n}\n\nstatic bool convert_dotcmd_to_image(RCore *core, char *r2_cmd, const char *save_path) {\n\tif (save_path && *save_path) {\n\t\tr_cons_printf (\"Saving to file '%s'...\\n\", save_path);\n\t\tr_cons_flush ();\n\t}\n\tr_core_cmdf (core, \"%s > a.dot\", r2_cmd); // TODO: check error here\n\treturn convert_dot_to_image (core, \"a.dot\", save_path);\n}\n\nstatic bool convert_dot_str_to_image(RCore *core, char *str, const char *save_path) {\n\tif (save_path && *save_path) {\n\t\tr_cons_printf (\"Saving to file '%s'...\\n\", save_path);\n\t\tr_cons_flush ();\n\t}\n\tif (!r_file_dump (\"a.dot\", (const unsigned char *)str, -1, false)) {\n\t\treturn false;\n\t}\n\treturn convert_dot_to_image (core, \"a.dot\", save_path);\n}\n\nstatic void agraph_print_edge_dot(RANode *from, RANode *to, void *user) {\n\tRCore *core = (RCore *)user;\n\tut64 a = r_num_math (NULL, from->title);\n\tut64 b = r_num_math (NULL, to->title);\n\tr_strf_var (k, 64, \"agraph.edge.0x%\"PFMT64x\"_0x%\"PFMT64x\".highlight\", a, b);\n\tif (sdb_exists (core->sdb, k)) {\n\t\tr_cons_printf (\"\\\"%s\\\" -> \\\"%s\\\" [color=cyan]\\n\", from->title, to->title);\n\t} else {\n\t\tr_cons_printf (\"\\\"%s\\\" -> \\\"%s\\\"\\n\", from->title, to->title);\n\t}\n}\n\nstatic void agraph_print_edge(RANode *from, RANode *to, void *user) {\n\tr_cons_printf (\"age \\\"%s\\\" \\\"%s\\\"\\n\", from->title, to->title);\n}\n\nstatic void cmd_agraph_node(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase ' ': { // \"agn\"\n\t\tchar *newbody = NULL;\n\t\tchar *body;\n\t\tint n_args, B_LEN = strlen (\"base64:\");\n\t\tchar *color = NULL;\n\t\tinput++;\n\t\tchar **args = r_str_argv (input, &n_args);\n\t\tif (n_args < 1 || n_args > 3) {\n\t\t\tR_LOG_ERROR (\"wrong arguments for agn\");\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\t\t// strdup cause there is double free in r_str_argv_free due to a realloc call\n\t\tif (n_args > 1) {\n\t\t\tbody = strdup (args[1]);\n\t\t\tif (strncmp (body, \"base64:\", B_LEN) == 0) {\n\t\t\t\tif (body[B_LEN]) {\n\t\t\t\t\tbody = r_str_replace (body, \"\\\\n\", \"\", true);\n\t\t\t\t\tnewbody = (char *)r_base64_decode_dyn (body + B_LEN, -1);\n\t\t\t\t\tif (!newbody) {\n\t\t\t\t\t\tR_LOG_ERROR (\"Invalid base64 string in agn (%s)\", body+B_LEN);\n\t\t\t\t\t\tr_str_argv_free (args);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree (body);\n\t\t\t\t\tbody = newbody;\n\t\t\t\t} else {\n\t\t\t\t\tfree (body);\n\t\t\t\t\tbody = strdup (\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbody = r_str_append (body, \"\\n\");\n\t\t\tif (n_args > 2) {\n\t\t\t\tRColor kolor = {0};\n\t\t\t\t(void)r_cons_pal_parse (args[2], &kolor);\n\t\t\t\tcolor = r_cons_rgb_str (NULL, -1, &kolor);\n\t\t\t}\n\t\t} else {\n\t\t\tbody = strdup (\"\");\n\t\t}\n\t\tr_agraph_add_node (core->graph, args[0], body, color);\n\t\tr_str_argv_free (args);\n\t\tfree (body);\n\t\tfree (color);\n\t\t// free newbody it's not necessary since r_str_append reallocate the space\n\t\tbreak;\n\t}\n\tcase '-': { // \"agn-\"\n\t\tinput++;\n\t\tint n_args;\n\t\tchar **args = r_str_argv (input, &n_args);\n\t\tif (n_args != 1) {\n\t\t\tR_LOG_ERROR (\"Wrong arguments\");\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\t\tr_agraph_del_node (core->graph, args[0]);\n\t\tr_str_argv_free (args);\n\t\tbreak;\n\t}\n\tcase '?':\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_agn);\n\t\tbreak;\n\t}\n}\n\nstatic bool cmd_ageh(RCore *core, const char *input) {\n\tif (!*input) {\n\t\tr_core_cmd0 (core, \"k~agraph.edge\");\n\t\treturn false;\n\t}\n\tbool add = true;\n\tif (*input == '-') {\n\t\tadd = false;\n\t\tinput++;\n\t}\n\tchar *arg = r_str_trim_dup (input + 1);\n\tchar *sp = strchr (arg, ' ');\n\tif (!sp) {\n\t\tfree (arg);\n\t\treturn false;\n\t}\n\t*sp++ = 0;\n\tut64 a = r_num_math (core->num, arg);\n\tut64 b = r_num_math (core->num, sp);\n\n\tr_strf_var (k, 64, \"agraph.edge.0x%\"PFMT64x\"_0x%\"PFMT64x\".highlight\", a, b);\n\tsdb_set (core->sdb, k, add? \"true\": \"\", 0);\n\tfree (arg);\n\treturn true;\n}\n\nstatic void cmd_agraph_edge(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase ' ': // \"age\"\n\tcase '-': { // \"age-\"\n\t\tRANode *u, *v;\n\t\tchar **args;\n\t\tint n_args;\n\n\t\targs = r_str_argv (input + 1, &n_args);\n\t\tif (n_args != 2) {\n\t\t\tr_cons_printf (\"Wrong arguments\\n\");\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\n\t\tu = r_agraph_get_node (core->graph, args[0]);\n\t\tv = r_agraph_get_node (core->graph, args[1]);\n\t\tif (!u || !v) {\n\t\t\tconst char *arg = args[u? 1: 0];\n\t\t\tr_cons_printf (\"Node %s not found!\\n\", arg);\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\t\tif (*input == ' ') {\n\t\t\tr_agraph_add_edge (core->graph, u, v, false);\n\t\t} else {\n\t\t\tr_agraph_del_edge (core->graph, u, v);\n\t\t}\n\t\tr_str_argv_free (args);\n\t\tbreak;\n\t}\n\tcase 'h':\n\t\tcmd_ageh (core, input + 1);\n\t\tbreak;\n\tcase '?':\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_age);\n\t\tbreak;\n\t}\n}\n\nR_API void cmd_agfb(RCore *core) {\n\tconst int c = r_config_get_b (core->config, \"scr.color\");\n\tr_config_set_i (core->config, \"scr.color\", 0);\n\tr_cons_push ();\n\tr_core_visual_graph (core, NULL, NULL, false);\n\tr_config_set_i (core->config, \"scr.color\", c);\n\tchar *s = strdup (r_cons_singleton()->context->buffer);\n\tr_cons_pop ();\n\tcmd_agfb2 (core, s);\n\tfree (s);\n}\n\nR_API void cmd_aggb(RCore *core) {\n\tconst int c = r_config_get_b (core->config, \"scr.color\");\n\tr_config_set_i (core->config, \"scr.color\", 0);\n\tr_cons_push ();\n\tint ograph_zoom = r_config_get_i (core->config, \"graph.zoom\");\n\tr_config_set_i (core->config, \"graph.zoom\", 1);\n\tr_core_cmd_call (core, \"agg\");\n\tr_config_set_i (core->config, \"scr.color\", c);\n\tchar *s = strdup (r_cons_singleton()->context->buffer);\n\tr_cons_pop ();\n\tcmd_agfb2 (core, s);\n\tr_config_set_i (core->config, \"graph.zoom\", ograph_zoom);\n\tfree (s);\n}\n\nR_API void cmd_agfb3(RCore *core, const char *s, int x, int y) {\n\tint h, w = r_str_size (s, &h);\n\tRConsPixel *p = r_cons_pixel_new (w, h);\n\tr_cons_pixel_sets (p, 0, 0, s);\n\tr_cons_pixel_flush (p, x, y);\n\tR_FREE (p);\n}\n\nR_API void cmd_agfb2(RCore *core, const char *s) {\n\tint h, w = r_str_size (s, &h);\n\tRConsPixel *p = r_cons_pixel_new (w, h);\n\tr_cons_pixel_sets (p, 0, 0, s);\n\tchar *pix = r_cons_pixel_drain (p);\n\tr_cons_printf (\"%s\\n\", pix);\n\tfree (pix);\n}\n\n\nstatic char *mermaid_sanitize_str(const char *str) {\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tsize_t len = strlen (str) * 4 + 1; // '\\n' -> \"\\x0a\"\n\tchar *buf = malloc (len);\n\tif (buf) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < len - 5 && *str;) {\n\t\t\tchar c = *str++;\n\t\t\tif (c < ' ' || c > '~' || c == '\\\\' || c == '\"' || c == '<') {\n\t\t\t\tsnprintf (buf + i, 5, \"\\\\x%02x\", c); // 5 b/c null byte\n\t\t\t\ti += 4;\n\t\t\t} else {\n\t\t\t\tbuf[i++] = c;\n\t\t\t}\n\t\t}\n\t\tbuf[i] = '\\0';\n\t}\n\t// buffer wont live long enough to merit a realloc\n\treturn buf;\n}\n\nstatic inline char *mermaid_title_body_node_str(const char *title, const char *body) {\n\tchar *t = mermaid_sanitize_str (title);\n\tchar *b = mermaid_sanitize_str (body);\n\tif (t && b) {\n\t\tchar *ret = r_str_newf (\"[%s]\\\\n%s\", t, b);\n\t\tfree (t);\n\t\tfree (b);\n\t\treturn ret;\n\t}\n\treturn t? t: b;\n}\n\nstatic char *mermaid_anod_body(RGraphNode *n) {\n\tRANode *an = (RANode *)n->data;\n\treturn mermaid_title_body_node_str (an->title, an->body);\n}\n\nstatic char *mermaid_nodeinfo_body(RGraphNode *n) {\n\tRGraphNodeInfo *nfo = (RGraphNodeInfo *)n->data;\n\treturn mermaid_title_body_node_str (nfo->title, nfo->body);\n}\n\ntypedef char *(*node_content_cb) (RGraphNode *);\nstatic void mermaid_graph(RGraph *graph, node_content_cb get_body) {\n\tif (!graph) {\n\t\treturn;\n\t}\n\tif (r_list_empty (graph->nodes)) {\n\t\tR_LOG_INFO (\"The graph is empty\");\n\t\treturn;\n\t}\n\tbool printit = true;\n\tRStrBuf *nodes = r_strbuf_new (\"stateDiagram-v2\\n\");\n\tRStrBuf *edges = r_strbuf_new (\"\");\n\tRGraphNode *n;\n\tRListIter *it;\n\tr_list_foreach (graph->nodes, it, n) {\n\t\tchar *free_body = get_body (n);\n\t\tchar *body = free_body? free_body: \"\";\n\t\tprintit &= r_strbuf_appendf (nodes, \"  state \\\"%s\\\" as node_%u\\n\", body, n->idx);\n\t\tfree (free_body);\n\n\t\t// edgdes\n\t\tRGraphNode *nxt;\n\t\tRListIter *itt;\n\t\tr_list_foreach (n->out_nodes, itt, nxt) {\n\t\t\tprintit &= r_strbuf_appendf (edges, \"  node_%u --> node_%u\\n\", n->idx, nxt->idx);\n\t\t}\n\t\tif (!printit) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (printit) {\n\t\tchar *n = r_strbuf_drain_nofree (nodes);\n\t\tchar *e = r_strbuf_drain_nofree (edges);\n\t\tif (n && e) {\n\t\t\tr_cons_print (n);\n\t\t\tr_cons_print (e);\n\t\t}\n\t\tfree (n);\n\t\tfree (e);\n\t}\n\tr_strbuf_free (nodes);\n\tr_strbuf_free (edges);\n}\n\ntypedef struct {\n\tRAnalFunction *fcn;\n\tchar *name;\n\tut64 addr;\n\tint size;\n\tint x;\n\tint y;\n\tint w;\n\tint h;\n} TreeMapItem;\n\nstatic void *add_item(RAnalFunction *f, const char *name, ut64 addr, ut64 size) {\n\tTreeMapItem *item = R_NEW0 (TreeMapItem);\n\titem->fcn = f;\n\titem->addr = addr;\n\titem->name = strdup (name);\n\titem->size = size;\n\treturn item;\n}\n\nstatic void free_item(void *a) {\n\tTreeMapItem *item = a;\n\tif (item) {\n\t\tfree (item->name);\n\t\tfree (item);\n\t}\n}\n\nstatic int bysize(const void *_a, const void *_b) {\n\tconst TreeMapItem *a = _a;\n\tconst TreeMapItem *b = _b;\n\treturn b->size - a->size;\n}\n\nstatic void treemap_layout(RConsCanvas *canvas, RList *maps) {\n\tRListIter *iter;\n\tTreeMapItem *mi;\n\tint i = 0;\n\tint n = r_list_length (maps);\n\tif (n == 0) {\n\t\treturn;\n\t}\n\tint nx = 0;\n\tint ny = 0;\n\tint nw = canvas->w;\n\tint nh = canvas->h;\n\tfloat mfact = 0.33;\n\tbool s = true; // layout\n\n\tr_list_sort (maps, bysize);\n\tr_list_foreach (maps, iter, mi) {\n\t\tif ((i % 2 && nh / 2 > 2 * mi->w) || (!(i % 2) && nw / 2 > 2 * mi->w)) {\n\t\t\tconst int imodfour = (i % 4);\n\t\t\tif (i < n - 1) {\n\t\t\t\tif (i % 2) {\n\t\t\t\t\tnh /= 2;\n\t\t\t\t} else {\n\t\t\t\t\tnw /= 2;\n\t\t\t\t}\n\t\t\t\tif (!s) {\n\t\t\t\t\tif (imodfour == 2) {\n\t\t\t\t\t\tnx += nw;\n\t\t\t\t\t} else if (imodfour == 3) {\n\t\t\t\t\t\tny += nh;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (imodfour) {\n\t\t\tcase 0:\n\t\t\t\tny += s? nh: -nh;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnx += nw;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tny += nh;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tnx += s? nw: -nw;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tif (n != 1) {\n\t\t\t\t\tnw = (int)(canvas->w * mfact);\n\t\t\t\t}\n\t\t\t\tny = 0;\n\t\t\t} else if (i == 1) {\n\t\t\t\tnw = canvas->w - nw;\n\t\t\t\tnx--;\n\t\t\t} else if (i == 2) {\n\t\t\t\tnh++;\n\t\t\t\t// ny--;\n\t\t\t}\n\t\t\tif (2== (i%4)) {\n\t\t\t\tnh++;\n\t\t\t\t// nw--;\n\t\t\t\tny--;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tmi->x = nx;\n\t\tmi->y = ny;\n\t\tmi->w = nw;\n\t\tmi->h = nh;\n\t}\n}\n\nR_API void r_core_agraph_treemap(RCore *core, int use_utf, const char *input) {\n\tint a = r_config_get_i (core->config, \"scr.color\");\n\tr_config_set_i (core->config, \"scr.color\", 0);\n\t// walk all the functions and create a treemap and render it\n\tint h, w = r_cons_get_size (&h);\n\tw--;\n\th--;\n\tRConsCanvas *canvas = r_cons_canvas_new (w, h);\n\tr_cons_canvas_box (canvas, 1, 1, w - 1, h - 1, \"\");\n\tRListIter *iter;\n\tRAnalFunction *fcn = NULL;\n\tRList *maps = r_list_newf (free_item);\n#if 1\n\tRList *list = r_anal_get_fcns (core->anal);\n\tr_list_foreach (list, iter, fcn) {\n\t\tut64 fsz = r_anal_function_realsize (fcn);\n\t\tr_list_append (maps, add_item (fcn, fcn->name, fcn->addr, fsz));\n\t}\n#else\n\tRAnalBlock *bb;\n\tif (!fcn) {\n\t\tfcn = r_anal_get_function_at (core->anal, core->offset);\n\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\tchar *name = r_str_newf (\"%d\", (int)(size_t)(bb->addr - fcn->addr));\n\t\t\tr_list_append (maps, add_item (fcn, name, bb->addr, bb->size));\n\t\t\tfree (name);\n\t\t}\n\t}\n#endif\n\ttreemap_layout (canvas, maps);\n\tTreeMapItem *mi;\n\tr_list_foreach (maps, iter, mi) {\n\t\t// char *s = r_core_cmd_strf (core, \"pdb@0x%\"PFMT64x\"@e:asm.byte=0@e:asm.bytes=0\", mi->addr);\n\t\tchar *s = r_core_cmd_strf (core, \"pid@0x%\"PFMT64x\"@e:asm.bytes=0\", mi->addr);\n\t\tif (mi->w > 4 && mi->h > 3) {\n\t\t\tchar *ns = r_str_crop (s, 0, 0, mi->w * 2, mi->h - 2);\n\t\t\tif (r_cons_canvas_gotoxy (canvas, mi->x + 2, mi->y + 2)) {\n\t\t\t\tr_cons_canvas_write (canvas, ns);\n\t\t\t}\n\t\t\tfree (ns);\n\t\t}\n\t\tfree (s);\n\t}\n\tr_list_foreach (maps, iter, mi) {\n\t\tif (r_cons_canvas_gotoxy (canvas, mi->x + 2, mi->y + 1)) {\n\t\t\tr_cons_canvas_write (canvas, mi->name);\n\t\t\tr_cons_canvas_box (canvas, mi->x, mi->y, mi->w, mi->h, \"\");\n\t\t}\n\t}\n\tchar *s = r_cons_canvas_tostring (canvas);\n\tif (s) {\n\t\tr_cons_println (s);\n\t\tfree (s);\n\t}\n\tr_list_free (maps);\n\tr_config_set_i (core->config, \"scr.color\", a);\n\tr_cons_canvas_free (canvas);\n}\n\nR_API void r_core_agraph_print(RCore *core, int use_utf, const char *input) {\n\tif (use_utf != -1) {\n\t\tr_config_set_i (core->config, \"scr.utf8\", use_utf);\n\t}\n\tswitch (*input) {\n\tcase 0:\n\t\tcore->graph->can->linemode = r_config_get_i (core->config, \"graph.linemode\");\n\t\tcore->graph->can->color = r_config_get_i (core->config, \"scr.color\");\n\t\tr_agraph_set_title (core->graph, r_config_get (core->config, \"graph.title\"));\n\t\tr_agraph_print (core->graph);\n\t\tbreak;\n\tcase 't': { // \"aggt\" - tiny graph\n\t\tcore->graph->is_tiny = true;\n\t\tint e = r_config_get_i (core->config, \"graph.edges\");\n\t\tr_config_set_i (core->config, \"graph.edges\", 0);\n\t\tr_core_visual_graph (core, core->graph, NULL, false);\n\t\tr_config_set_i (core->config, \"graph.edges\", e);\n\t\tcore->graph->is_tiny = false;\n\t\tbreak;\n\t}\n\tcase 'b': // \"aggb\"\n\t\tcmd_aggb (core);\n\t\tbreak;\n\tcase 'm': // \"aggm\"\n\t\tif (core->graph) {\n\t\t\tmermaid_graph (core->graph->graph, mermaid_anod_body);\n\t\t}\n\t\tbreak;\n\tcase 'k': // \"aggk\"\n\t{\n\t\tSdb *db = r_agraph_get_sdb (core->graph);\n\t\tif (db) {\n\t\t\tchar *o = sdb_querys (db, \"null\", 0, \"*\");\n\t\t\tif (o) {\n\t\t\t\tr_cons_print (o);\n\t\t\t\tfree (o);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'v': // \"aggv\" - open current core->graph in interactive visual mode\n\t{\n\t\tRANode *ran = r_agraph_get_first_node (core->graph);\n\t\tif (ran) {\n\t\t\tut64 oseek = core->offset;\n\t\t\tr_agraph_set_title (core->graph, r_config_get (core->config, \"graph.title\"));\n\t\t\tr_agraph_set_curnode (core->graph, ran);\n\t\t\tcore->graph->force_update_seek = true;\n\t\t\tcore->graph->need_set_layout = true;\n\t\t\tcore->graph->is_handmade = true;\n\t\t\tcore->graph->layout = r_config_get_i (core->config, \"graph.layout\");\n\t\t\tbool ov = r_cons_is_interactive ();\n\t\t\tcore->graph->need_update_dim = true;\n\t\t\tint update_seek = r_core_visual_graph (core, core->graph, NULL, true);\n\t\t\tr_config_set_b (core->config, \"scr.interactive\", ov);\n\t\t\tr_cons_show_cursor (true);\n\t\t\tcore->graph->is_handmade = false;\n\t\t\tr_cons_enable_mouse (false);\n\t\t\tif (update_seek != -1) {\n\t\t\t\tr_core_seek (core, oseek, false);\n\t\t\t}\n\t\t} else {\n\t\t\tR_LOG_INFO (\"This graph contains no nodes\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'd': { // \"aggd\" - dot format\n\t\tconst char *font = r_config_get (core->config, \"graph.font\");\n\t\tr_cons_printf (\"digraph code {\\nrankdir=LR;\\noutputorder=edgesfirst\\ngraph [bgcolor=azure];\\n\"\n\t\t\t\"edge [arrowhead=normal, color=\\\"#3030c0\\\" style=bold weight=2];\\n\"\n\t\t\t\"node [fillcolor=white, style=filled shape=box \"\n\t\t\t\"fontname=\\\"%s\\\" fontsize=\\\"8\\\"];\\n\",\n\t\t\tfont);\n\t\tr_agraph_foreach (core->graph, agraph_print_node_dot, core);\n\t\tr_agraph_foreach_edge (core->graph, agraph_print_edge_dot, core);\n\t\tr_cons_printf (\"}\\n\");\n\t\tbreak;\n\t}\n\tcase '*': // \"agg*\" -\n\t\tr_agraph_foreach (core->graph, agraph_print_node, core);\n\t\tr_agraph_foreach_edge (core->graph, agraph_print_edge, core);\n\t\tbreak;\n\tcase 'J':\n\tcase 'j': {\n\t\tPJ *pj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_o (pj);\n\t\tpj_k (pj, \"nodes\");\n\t\tpj_a (pj);\n\t\tr_agraph_print_json (core->graph, pj);\n\t\tpj_end (pj);\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\tbreak;\n\t\t}\n\tcase 'g':\n\t\tr_cons_printf (\"graph\\n[\\n\"\n\t\t\t       \"hierarchic 1\\n\"\n\t\t\t       \"label \\\"\\\"\\n\"\n\t\t\t       \"directed 1\\n\");\n\t\tr_agraph_foreach (core->graph, agraph_print_node_gml, NULL);\n\t\tr_agraph_foreach_edge (core->graph, agraph_print_edge_gml, NULL);\n\t\tr_cons_print (\"]\\n\");\n\t\tbreak;\n\tcase 'w': // \"aggw\"\n\t\t{\n\t\t\tconst char *filename = r_str_trim_head_ro (input + 1);\n\t\t\tconvert_dotcmd_to_image (core, \"aggd\", filename);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ag);\n\t\tbreak;\n\t}\n}\n\nstatic void print_graph_agg(RGraph /*RGraphNodeInfo*/ *graph) {\n\tRGraphNodeInfo *print_node;\n\tRGraphNode *node, *target;\n\tRListIter *it, *edge_it;\n\tr_list_foreach (graph->nodes, it, node) {\n\t\tchar *encbody;\n\t\tint len;\n\t\tprint_node = node->data;\n\t\tif (R_STR_ISNOTEMPTY (print_node->body)) {\n\t\t\tlen = strlen (print_node->body);\n\n\t\t\tif (len > 0 && print_node->body[len - 1] == '\\n') {\n\t\t\t\tlen--;\n\t\t\t}\n\t\t\tencbody = r_base64_encode_dyn (print_node->body, len);\n\t\t\tr_cons_printf (\"agn \\\"%s\\\" base64:%s\\n\", print_node->title, encbody);\n\t\t\tfree (encbody);\n\t\t} else {\n\t\t\tr_cons_printf (\"agn \\\"%s\\\"\\n\", print_node->title);\n\t\t}\n\t}\n\tr_list_foreach (graph->nodes, it, node) {\n\t\tprint_node = node->data;\n\t\tr_list_foreach (node->out_nodes, edge_it, target) {\n\t\t\tRGraphNodeInfo *to = target->data;\n\t\t\tr_cons_printf (\"age \\\"%s\\\" \\\"%s\\\"\\n\", print_node->title, to->title);\n\t\t}\n\t}\n}\n\nstatic char *print_graph_dot(RCore *core, RGraph /*<RGraphNodeInfo>*/ *graph) {\n\tconst char *font = r_config_get (core->config, \"graph.font\");\n\tchar *node_properties = r_str_newf (\"fontname=\\\"%s\\\"\", font);\n\tchar *result = r_graph_drawable_to_dot (graph, node_properties, NULL);\n\tfree (node_properties);\n\treturn result;\n}\n\nstatic char *_graph_node_info_get_title(void *data) {\n\tRGraphNodeInfo *info = (RGraphNodeInfo *)data;\n\treturn (info && info->title)? strdup (info->title): NULL;\n}\n\nstatic char *_graph_node_info_get_body(void *data) {\n\tRGraphNodeInfo *info = (RGraphNodeInfo *)data;\n\treturn (info && info->body)? strdup (info->body): NULL;\n}\n\nstatic void r_core_graph_print(RCore *core, RGraph /*<RGraphNodeInfo>*/ *graph, int use_utf, bool use_offset, const char *input) {\n\tRAGraph *agraph = NULL;\n\tRListIter *it;\n\tRListIter *edge_it;\n\tRGraphNode *graphNode, *target;\n\tRGraphNodeInfo *print_node;\n\tif (use_utf != -1) {\n\t\tr_config_set_b (core->config, \"scr.utf8\", use_utf);\n\t}\n\tswitch (*input) {\n\tcase 0:\n\tcase 't':\n\tcase 'k':\n\tcase 'v':\n\tcase 'i': {\n\t\tRAGraphTransitionCBs cbs = {\n\t\t\t.get_title = _graph_node_info_get_title,\n\t\t\t.get_body = _graph_node_info_get_body\n\t\t};\n\t\tagraph = r_agraph_new_from_graph (graph, &cbs);\n\t\tswitch (*input) {\n\t\tcase 0:\n\t\t\tagraph->can->linemode = r_config_get_i (core->config, \"graph.linemode\");\n\t\t\tagraph->can->color = r_config_get_i (core->config, \"scr.color\");\n\t\t\tr_agraph_set_title (agraph,\n\t\t\t\tr_config_get (core->config, \"graph.title\"));\n\t\t\tr_agraph_print (agraph);\n\t\t\tbreak;\n\t\tcase 't': { // \"ag_t\" - tiny graph\n\t\t\tagraph->is_tiny = true;\n\t\t\tint e = r_config_get_i (core->config, \"graph.edges\");\n\t\t\tr_config_set_i (core->config, \"graph.edges\", 0);\n\t\t\tr_core_visual_graph (core, agraph, NULL, false);\n\t\t\tr_config_set_i (core->config, \"graph.edges\", e);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'k': // \"ag_k\"\n\t\t{\n\t\t\tSdb *db = r_agraph_get_sdb (agraph);\n\t\t\tchar *o = sdb_querys (db, \"null\", 0, \"*\");\n\t\t\tr_cons_print (o);\n\t\t\tfree (o);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'v': // \"ag_v\"\n\t\tcase 'i': // \"ag_i\" - open current core->graph in interactive mode\n\t\t{\n\t\t\tRANode *ran = r_agraph_get_first_node (agraph);\n\t\t\tif (ran) {\n\t\t\t\tut64 oseek = core->offset;\n\t\t\t\tr_agraph_set_title (agraph, r_config_get (core->config, \"graph.title\"));\n\t\t\t\tr_agraph_set_curnode (agraph, ran);\n\t\t\t\tagraph->force_update_seek = true;\n\t\t\t\tagraph->need_set_layout = true;\n\t\t\t\tagraph->layout = r_config_get_i (core->config, \"graph.layout\");\n\t\t\t\tbool ov = r_cons_is_interactive ();\n\t\t\t\tagraph->need_update_dim = true;\n\t\t\t\tint update_seek = r_core_visual_graph (core, agraph, NULL, true);\n\t\t\t\tr_config_set_b (core->config, \"scr.interactive\", ov);\n\t\t\t\tr_cons_show_cursor (true);\n\t\t\t\tr_cons_enable_mouse (false);\n\t\t\t\tif (update_seek != -1) {\n\t\t\t\t\tr_core_seek (core, oseek, false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_INFO (\"This graph contains no nodes\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'd': { // \"ag_d\" - dot format\n\t\tchar *dot_text = print_graph_dot (core, graph);\n\t\tif (dot_text) {\n\t\t\tr_cons_print (dot_text);\n\t\t\tfree (dot_text);\n\t\t}\n\t\tbreak;\n\t}\n\tcase '*': // \"ag_*\" -\n\t\tprint_graph_agg (graph);\n\t\tbreak;\n\tcase 'J':\n\tcase 'j': {\n\t\tPJ *pj = pj_new ();\n\t\tif (pj) {\n\t\t\tr_graph_drawable_to_json (graph, pj, use_offset);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t}\n\t} break;\n\tcase 'g':\n\t\tr_cons_printf (\"graph\\n[\\n\"\n\t\t\t       \"hierarchic 1\\n\"\n\t\t\t       \"label \\\"\\\"\\n\"\n\t\t\t       \"directed 1\\n\");\n\t\tr_list_foreach (graph->nodes, it, graphNode) {\n\t\t\tprint_node = graphNode->data;\n\t\t\tr_cons_printf (\"  node [\\n\"\n\t\t\t\t       \"    id  %d\\n\"\n\t\t\t\t       \"    label  \\\"%s\\\"\\n\"\n\t\t\t\t       \"  ]\\n\",\n\t\t\t\tgraphNode->idx, print_node->title);\n\t\t}\n\t\tr_list_foreach (graph->nodes, it, graphNode) {\n\t\t\tprint_node = graphNode->data;\n\t\t\tr_list_foreach (graphNode->out_nodes, edge_it, target) {\n\t\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\t       \"    source  %d\\n\"\n\t\t\t\t\t       \"    target  %d\\n\"\n\t\t\t\t\t       \"  ]\\n\",\n\t\t\t\t\tgraphNode->idx, target->idx);\n\t\t\t}\n\t\t}\n\t\tr_cons_print (\"]\\n\");\n\t\tbreak;\n\tcase 'w': { // \"ag_w\"\n\t\tconst char *filename = r_str_trim_head_ro (input + 1);\n\t\tchar *dot_text = print_graph_dot (core, graph);\n\t\tif (dot_text) {\n\t\t\tconvert_dot_str_to_image (core, dot_text, filename);\n\t\t\tfree (dot_text);\n\t\t}\n\t\tbreak;\n\t\t}\n\tcase 'm':\n\t\tmermaid_graph (graph, mermaid_nodeinfo_body);\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ag);\n\t\tbreak;\n\t}\n}\n\nstatic inline bool mermaid_add_node_asm(RAnal *a, RAnalBlock *bb, RStrBuf *nodes) {\n\tut8 *bb_buf = calloc (1, bb->size);\n\tif (!bb_buf) {\n\t\treturn false;\n\t}\n\tif (!a->iob.read_at (a->iob.io, bb->addr, (ut8 *)bb_buf, bb->size)) {\n\t\treturn false;\n\t}\n\tRAnalOpMask mask = R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_DISASM | R_ANAL_OP_HINT_MASK;\n\tRAnalOp op = {0};\n\n\t// escaped newline to get out of title line\n\tbool ret = r_strbuf_append (nodes, \"\\\\n\");\n\tint i;\n\tfor (i = 0; i < bb->ninstr; i++) {\n\t\tconst ut64 prev_pos = r_anal_bb_offset_inst (bb, i);\n\t\tconst ut64 op_addr = r_anal_bb_opaddr_i (bb, i);\n\t\tif (prev_pos >= bb->size) {\n\t\t\tcontinue;\n\t\t}\n\t\tint buflen = bb->size - prev_pos;\n\t\tut8 *loc = bb_buf + prev_pos;\n\t\tif (r_anal_op (a, &op, op_addr, loc, buflen, mask) > 0) {\n\t\t\tret &= r_strbuf_appendf (nodes, \"%s\\\\n\", op.mnemonic);\n\t\t} else {\n\t\t\tret &= r_strbuf_append (nodes, \"...\\\\n\");\n\t\t}\n\t\tif (!ret) {\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_op_fini (&op);\n\t}\n\tfree (bb_buf);\n\treturn ret;\n}\n\nstatic inline bool fcn_siwtch_mermaid(RAnalBlock *b, RStrBuf *buf) {\n\tif (b->switch_op) {\n\t\tr_return_val_if_fail (b->switch_op->cases, false);\n\t\tRListIter *itt;\n\t\tRAnalCaseOp *c;\n\t\tr_list_foreach (b->switch_op->cases, itt, c) {\n\t\t\tif (!r_strbuf_appendf (buf, \"  _0x%\" PFMT64x \" --> _0x%\" PFMT64x \": Case %\" PFMT64d \"\\n\", b->addr, c->addr, c->value)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool cmd_graph_mermaid(RCore *core, bool add_asm) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\tif (!fcn || !fcn->bbs) {\n\t\treturn false;\n\t}\n\n\tbool ret = true;\n\n\t// for info on mermaid syntax: https://mermaid-js.github.io/mermaid/#/stateDiagram\n\tRStrBuf *nodes = r_strbuf_new (\"stateDiagram-v2\\n\");\n\tRStrBuf *edges = r_strbuf_new (\"\");\n\n\t// TODO: add themeing to nodes buff here -> https://mermaid-js.github.io/mermaid/#/theming\n\n\tRAnalBlock *b;\n\tRListIter *iter;\n\n\tr_list_sort (fcn->bbs, bb_cmp);\n\tr_list_foreach (fcn->bbs, iter, b) {\n\t\tret &= r_strbuf_appendf (nodes, \"  state \\\"[0x%\" PFMT64x \"]\", b->addr);\n\t\tif (b->addr == fcn->addr) {\n\t\t\tret &= r_strbuf_appendf (nodes, \" %s\", fcn->name);\n\t\t}\n\t\tif (add_asm) {\n\t\t\tret &= mermaid_add_node_asm (core->anal, b, nodes);\n\t\t}\n\t\t// ending of nodes string `... \" as _0xfffff`\n\t\t// node names start with _0x b/c 0x makes mermaids mad somehow\n\t\tret &= r_strbuf_appendf (nodes, \"\\\" as _0x%\" PFMT64x \"\\n\", b->addr);\n\n\t\tif (b->jump != UT64_MAX) {\n\t\t\tif (b->fail != UT64_MAX) {\n\t\t\t\tret &= r_strbuf_appendf (edges, \"  _0x%\" PFMT64x \" --> _0x%\" PFMT64x \": true\\n\", b->addr, b->jump);\n\t\t\t\tret &= r_strbuf_appendf (edges, \"  _0x%\" PFMT64x \" --> _0x%\" PFMT64x \": false\\n\", b->addr, b->fail);\n\t\t\t} else {\n\t\t\t\tret &= r_strbuf_appendf (edges, \"  _0x%\" PFMT64x \" --> _0x%\" PFMT64x \"\\n\", b->addr, b->jump);\n\t\t\t}\n\t\t} else if (b->fail != UT64_MAX) {\n\t\t\tret &= r_strbuf_appendf (edges, \"  _0x%\" PFMT64x \" --> _0x%\" PFMT64x \"\\n\", b->addr, b->fail);\n\t\t}\n\t\tret &= fcn_siwtch_mermaid (b, edges);\n\t\tif (!ret) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\tchar *n = r_strbuf_drain_nofree (nodes);\n\t\tchar *e = r_strbuf_drain_nofree (edges);\n\t\tif (n && e) {\n\t\t\tr_cons_print (n);\n\t\t\tr_cons_print (e);\n\t\t}\n\t\tfree (n);\n\t\tfree (e);\n\t}\n\tr_strbuf_free (nodes);\n\tr_strbuf_free (edges);\n\treturn ret;\n}\n\nstatic void cmd_anal_graph(RCore *core, const char *input) {\n\tcore->graph->show_node_titles = r_config_get_i (core->config, \"graph.ntitles\");\n\tr_cons_enable_highlight (false);\n\tif (*input == '?') {\n\t\tr_core_cmd_help (core, help_msg_ag);\n\t\treturn;\n\t}\n\tswitch (input[0]) {\n\tcase 'f': // \"agf\"\n\t\tswitch (input[1]) {\n\t\tcase 0: // \"agf\"\n\t\t\tr_core_visual_graph (core, NULL, NULL, false);\n\t\t\tbreak;\n\t\tcase 'b': // \"agfb\" // braile\n\t\t\tcmd_agfb (core);\n\t\t\tbreak;\n\t\tcase 'm': /// \"agfm\" // mermaid\n\t\t\tcmd_graph_mermaid (core, input[2] == 'a');\n\t\t\tbreak;\n\t\tcase ' ': { // \"agf \"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tr_core_visual_graph (core, NULL, fcn, false);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'v': // \"agfv\"\n\t\t{\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_ROOT);\n\t\t\tif (fcn) {\n\t\t\t\tr_core_visual_graph (core, NULL, fcn, 1);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"No function to graph\");\n\t\t\t}\n\t\t\tr_cons_enable_mouse (false);\n\t\t\tr_cons_show_cursor (true);\n\t\t}\n\t\t\tbreak;\n\t\tcase 't': { // \"agft\" - tiny graph\n\t\t\tint e = r_config_get_i (core->config, \"graph.edges\");\n\t\t\tr_config_set_i (core->config, \"graph.edges\", 0);\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tr_core_visual_graph (core, NULL, fcn, 2);\n\t\t\tr_config_set_i (core->config, \"graph.edges\", e);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase 'd': // \"agfd\"\n\t\t\tif (input[2] == 'm') { // \"agfdm\"\n\t\t\t\tr_core_anal_graph (core, r_num_math (core->num, input + 3),\n\t\t\t\t\tR_CORE_ANAL_GRAPHLINES);\n\t\t\t} else {\n\t\t\t\tr_core_anal_graph (core, r_num_math (core->num, input + 2),\n\t\t\t\t\tR_CORE_ANAL_GRAPHBODY);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j': // \"agfj\"\n\t\t\tr_core_anal_graph (core, r_num_math (core->num, input + 2), R_CORE_ANAL_JSON);\n\t\t\tbreak;\n\t\tcase 'J': { // \"agfJ\"\n\t\t\t// Honor asm.graph=false in json as well\n\t\t\tRConfigHold *hc = r_config_hold_new (core->config);\n\t\t\tr_config_hold (hc, \"asm.offset\", NULL);\n\t\t\tconst bool o_graph_offset = r_config_get_i (core->config, \"graph.offset\");\n\t\t\tr_config_set_i (core->config, \"asm.offset\", o_graph_offset);\n\t\t\tr_core_anal_graph (core, r_num_math (core->num, input + 2),\n\t\t\t\tR_CORE_ANAL_JSON | R_CORE_ANAL_JSON_FORMAT_DISASM);\n\t\t\tr_config_hold_restore (hc);\n\t\t\tr_config_hold_free (hc);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'g':{ // \"agfg\"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tr_core_print_bb_gml (core, fcn);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase 'k':{ // \"agfk\"\n\t\t\tr_core_cmdf (core, \"ag-; .agf* @ %\"PFMT64u\"; aggk\", core->offset);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase '*':{// \"agf*\"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tr_core_print_bb_custom (core, fcn);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase 'w': // \"agfw\"\n\t\t\t {\n\t\t\t\tchar *cmdargs = r_str_newf (\"agfd @ 0x%\"PFMT64x, core->offset);\n\t\t\t\tconvert_dotcmd_to_image (core, cmdargs, input + 2);\n\t\t\t\tfree (cmdargs);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_ag);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '-': // \"ag-\"\n\t\tr_agraph_reset (core->graph);\n\t\tbreak;\n\tcase 'n': // \"agn\"\n\t\tcmd_agraph_node (core, input + 1);\n\t\tbreak;\n\tcase 'e': // \"age\"\n\t\tcmd_agraph_edge (core, input + 1);\n\t\tbreak;\n\tcase 't': // \"agt\"\n\t\tr_core_agraph_treemap (core, -1, input + 1);\n\t\tbreak;\n\tcase 'g': // \"agg\"\n\t\tr_core_agraph_print (core, -1, input + 1);\n\t\tbreak;\n\tcase 's': // \"ags\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), 0);\n\t\tbreak;\n\tcase 'C': // \"agC\"\n\t\tswitch (input[1]) {\n\t\tcase 'm':\n\t\tcase 'v':\n\t\tcase 't':\n\t\tcase 'k':\n\t\tcase 'w':\n\t\tcase ' ':\n\t\tcase 0:\n\t\t\tcore->graph->is_callgraph = true;\n\t\t\tr_core_cmdf (core, \"ag-; .agC*;\");\n\t\t\tr_core_agraph_print(core, -1, input + 1);\n\t\t\tcore->graph->is_callgraph = false;\n\t\t\tbreak;\n\t\tcase 'J':\n\t\tcase 'j':\n\t\t\tr_core_anal_callgraph (core, UT64_MAX, R_GRAPH_FORMAT_JSON);\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tr_core_anal_callgraph (core, UT64_MAX, R_GRAPH_FORMAT_GML);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tr_core_anal_callgraph (core, UT64_MAX, R_GRAPH_FORMAT_DOT);\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tr_core_anal_callgraph (core, UT64_MAX, R_GRAPH_FORMAT_CMD);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_ag);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"agr\" references graph\n\t\tswitch (input[1]) {\n\t\tcase '*':\n\t\t\tr_core_anal_coderefs (core, core->offset);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcore->graph->is_callgraph = true;\n\t\t\tr_core_cmdf (core, \"ag-; .agr* @ %\"PFMT64u\";\", core->offset);\n\t\t\tr_core_agraph_print(core, -1, input + 1);\n\t\t\tcore->graph->is_callgraph = false;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'R': // \"agR\" global refs\n\t\tswitch (input[1]) {\n\t\tcase '*': {\n\t\t\tut64 from = r_config_get_i (core->config, \"graph.from\");\n\t\t\tut64 to = r_config_get_i (core->config, \"graph.to\");\n\t\t\tRListIter *it;\n\t\t\tRAnalFunction *fcn;\n\t\t\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\t\t\tif ((from == UT64_MAX && to == UT64_MAX) || R_BETWEEN (from, fcn->addr, to)) {\n\t\t\t\t\tr_core_anal_coderefs (core, fcn->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t}\n\t\tdefault: {\n\t\t\tcore->graph->is_callgraph = true;\n\t\t\tr_core_cmdf (core, \"ag-; .agR*;\");\n\t\t\tr_core_agraph_print(core, -1, input + 1);\n\t\t\tcore->graph->is_callgraph = false;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'x': {// \"agx\" cross refs\n\t\tRGraph *graph = r_core_anal_codexrefs (core, core->offset);\n\t\tif (!graph) {\n\t\t\tR_LOG_ERROR (\"Cannot create graph\");\n\t\t\tbreak;\n\t\t}\n\t\tr_core_graph_print (core, graph, -1, true, input + 1);\n\t\tr_graph_free (graph);\n\t\tbreak;\n\t}\n\tcase 'i': { // \"agi\" import graph\n\t\tRGraph *graph = r_core_anal_importxrefs (core);\n\t\tif (!graph) {\n\t\t\tR_LOG_ERROR (\"Cannot create graph\");\n\t\t\tbreak;\n\t\t}\n\t\tr_core_graph_print (core, graph, -1, true, input + 1);\n\t\tr_graph_free (graph);\n\t\tbreak;\n\t}\n\tcase 'c': // \"agc\"\n\t\tswitch (input[1]) {\n\t\tcase 'v':\n\t\tcase 't':\n\t\tcase 'k':\n\t\tcase 'w':\n\t\tcase 'm':\n\t\tcase ' ': {\n\t\t\tcore->graph->is_callgraph = true;\n\t\t\tr_core_cmdf (core, \"ag-; .agc* @ %\" PFMT64u \"; agg%s;\", core->offset, input + 1);\n\t\t\tcore->graph->is_callgraph = false;\n\t\t\tbreak;\n\t\t\t}\n\t\tcase 0:\n\t\t\tcore->graph->is_callgraph = true;\n\t\t\tr_core_cmd0 (core, \"ag-; .agc* $$; agg;\");\n\t\t\tcore->graph->is_callgraph = false;\n\t\t\tbreak;\n\t\tcase 'g': {\n\t\t\tr_core_anal_callgraph (core, core->offset, R_GRAPH_FORMAT_GMLFCN);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'd': {\n\t\t\tr_core_anal_callgraph (core, core->offset, R_GRAPH_FORMAT_DOT);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'J':\n\t\tcase 'j': {\n\t\t\tr_core_anal_callgraph (core, core->offset, R_GRAPH_FORMAT_JSON);\n\t\t\tbreak;\n\t\t}\n\t\tcase '*': {\n\t\t\tr_core_anal_callgraph (core, core->offset, R_GRAPH_FORMAT_CMD);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_ag);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"agj\" alias for agfj\n\t\tr_core_cmdf (core, \"agfj%s\", input + 1);\n\t\tbreak;\n\tcase 'J': // \"agJ\" alias for agfJ\n\t\tr_core_cmdf (core, \"agfJ%s\", input + 1);\n\t\tbreak;\n\tcase 'k': // \"agk\" alias for agfk\n\t\tr_core_cmdf (core, \"agfk%s\", input + 1);\n\t\tbreak;\n\tcase 'l': // \"agl\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), R_CORE_ANAL_GRAPHLINES);\n\t\tbreak;\n\tcase 'a': // \"aga\"\n\t\tswitch (input[1]) {\n\t\tcase '*': {\n\t\t\tr_core_anal_datarefs (core, core->offset);\n\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tr_core_cmdf (core, \"ag-; .aga* @ %\"PFMT64u\";\", core->offset);\n\t\t\tr_core_agraph_print(core, -1, input + 1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'A': // \"agA\" global data refs\n\t\tswitch (input[1]) {\n\t\tcase '*': {\n\t\t\tut64 from = r_config_get_i (core->config, \"graph.from\");\n\t\t\tut64 to = r_config_get_i (core->config, \"graph.to\");\n\t\t\tRListIter *it;\n\t\t\tRAnalFunction *fcn;\n\t\t\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\t\t\tif ((from == UT64_MAX && to == UT64_MAX) || R_BETWEEN (from, fcn->addr, to)) {\n\t\t\t\t\tr_core_anal_datarefs (core, fcn->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tr_core_cmdf (core, \"ag-; .agA*;\");\n\t\t\tr_core_agraph_print(core, -1, input + 1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'd': {// \"agd\"\n\t\tint diff_opt = R_CORE_ANAL_GRAPHBODY | R_CORE_ANAL_GRAPHDIFF;\n\t\tswitch (input[1]) {\n\t\tcase 'j': {\n\t\t\t\t  ut64 addr = input[2] ? r_num_math (core->num, input + 2) : core->offset;\n\t\t\t\t  r_core_gdiff_fcn (core, addr, core->offset);\n\t\t\t\t  r_core_anal_graph (core, addr, diff_opt | R_CORE_ANAL_JSON);\n\t\t\t\t  break;\n\t\t\t  }\n\t\tcase 'J': {\n\t\t\t\t  ut64 addr = input[2] ? r_num_math (core->num, input + 2) : core->offset;\n\t\t\t\t  r_core_gdiff_fcn (core, addr, core->offset);\n\t\t\t\t  r_core_anal_graph (core, addr, diff_opt | R_CORE_ANAL_JSON | R_CORE_ANAL_JSON_FORMAT_DISASM);\n\t\t\t\t  break;\n\t\t\t  }\n\t\tcase '*': {\n\t\t\t\t  ut64 addr = input[2] ? r_num_math (core->num, input + 2) : core->offset;\n\t\t\t\t  r_core_gdiff_fcn (core, addr, core->offset);\n\t\t\t\t  r_core_anal_graph (core, addr, diff_opt | R_CORE_ANAL_STAR);\n\t\t\t\t  break;\n\t\t\t  }\n\t\tcase ' ':\n\t\tcase 0:\n\t\tcase 't':\n\t\tcase 'k':\n\t\tcase 'v':\n\t\tcase 'm':\n\t\tcase 'g': {\n\t\t\t\t  ut64 addr = input[2]? r_num_math (core->num, input + 2): core->offset;\n\t\t\t\t  r_core_cmdf (core, \"ag-; .agd* @ %\"PFMT64u\"; agg%s;\", addr, input + 1);\n\t\t\t\t  break;\n\t\t\t  }\n\t\tcase 'd': {\n\t\t\t\t  ut64 addr = input[2]? r_num_math (core->num, input + 2): core->offset;\n\t\t\t\t  r_core_gdiff_fcn (core, addr, core->offset);\n\t\t\t\t  r_core_anal_graph (core, addr, diff_opt);\n\t\t\t\t  break;\n\t\t\t  }\n\t\tcase 'w': {\n\t\t\t\t  char *cmdargs = r_str_newf (\"agdd 0x%\"PFMT64x, core->offset);\n\t\t\t\t  convert_dotcmd_to_image (core, cmdargs, input + 2);\n\t\t\t\t  free (cmdargs);\n\t\t\t\t  break;\n\t\t\t  }\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'v': // \"agv\" alias for \"agfv\"\n\t\tr_core_cmdf (core, \"agfv%s\", input + 1);\n\t\tbreak;\n\tcase 'w':// \"agw\"\n\t\t{\n\t\t\tchar *cmdargs = r_str_newf (\"agfd @ 0x%\"PFMT64x, core->offset);\n\t\t\tconvert_dotcmd_to_image (core, cmdargs, input + 1);\n\t\t\tfree (cmdargs);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ag);\n\t\tbreak;\n\t}\n}\n\nR_API int r_core_anal_refs(RCore *core, const char *input) {\n\tconst bool cfg_debug = r_config_get_b (core->config, \"cfg.debug\");\n\tut64 from, to;\n\tint rad;\n\tPJ *pj = NULL;\n\tif (*input == '?') {\n\t\tr_core_cmd_help (core, help_msg_aar);\n\t\treturn 0;\n\t}\n\n\tif (*input == 'j' || *input == '*') {\n\t\trad = *input;\n\t\tinput++;\n\t\tif (rad == 'j') {\n\t\t\tpj = r_core_pj_new (core);\n\t\t\tif (!pj) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trad = 0;\n\t}\n\n\tfrom = to = 0;\n\tchar *ptr = r_str_trim_dup (input);\n\tint n = r_str_word_set0 (ptr);\n\tif (!n) {\n\t\t// get boundaries of current memory map, section or io map\n\t\tif (cfg_debug) {\n\t\t\tRDebugMap *map = r_debug_map_get (core->dbg, core->offset);\n\t\t\tif (map) {\n\t\t\t\tfrom = map->addr;\n\t\t\t\tto = map->addr_end;\n\t\t\t}\n\t\t} else {\n\t\t\tRList *list = r_core_get_boundaries_prot (core, R_PERM_X, NULL, \"anal\");\n\t\t\tRListIter *iter;\n\t\t\tRIOMap* map;\n\t\t\tif (!list) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (rad == 'j') {\n\t\t\t\tpj_o (pj);\n\t\t\t}\n\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\tfrom = r_io_map_begin (map);\n\t\t\t\tto = r_io_map_end (map);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!from && !to) {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot determine xref search boundaries\");\n\t\t\t\t} else if (to - from > UT32_MAX) {\n\t\t\t\t\tchar *unit = r_num_units (NULL, 0, to - from);\n\t\t\t\t\tR_LOG_WARN (\"Skipping huge range (%s)\", unit);\n\t\t\t\t\tfree (unit);\n\t\t\t\t} else {\n\t\t\t\t\tif (rad == 'j') {\n\t\t\t\t\t\tpj_ki (pj, \"mapid\", map->id);\n\t\t\t\t\t\tpj_ko (pj, \"refs\");\n\t\t\t\t\t}\n\t\t\t\t\tr_core_anal_search_xrefs (core, from, to, pj, rad);\n\t\t\t\t\tif (rad == 'j') {\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rad == 'j') {\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t}\n\t\t\tfree (ptr);\n\t\t\tr_list_free (list);\n\t\t\treturn 1;\n\t\t}\n\t} else if (n == 1) {\n\t\tfrom = core->offset;\n\t\tto = core->offset + r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t} else {\n\t\tR_LOG_ERROR (\"Invalid number of arguments\");\n\t}\n\tfree (ptr);\n\n\tif (from == UT64_MAX && to == UT64_MAX) {\n\t\treturn false;\n\t}\n\tif (!from && !to) {\n\t\treturn false;\n\t}\n\tif (to - from > r_io_size (core->io)) {\n\t\treturn false;\n\t}\n\tif (rad == 'j') {\n\t\tpj_o (pj);\n\t}\n\tbool res = r_core_anal_search_xrefs (core, from, to, pj, rad);\n\tif (rad == 'j') {\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\treturn res;\n}\n\nstatic int compute_coverage(RCore *core) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tint cov = 0;\n\tcov += r_meta_get_size(core->anal, R_META_TYPE_DATA);\n\tRIOBank *bank = r_io_bank_get (core->io, core->io->bank);\n\tif (bank) {\n\t\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\t\tRIOMapRef *mapref;\n\t\t\tRListIter *ator;\n\t\t\tr_list_foreach (bank->maprefs, ator, mapref) {\n\t\t\t\tRIOMap *map = r_io_map_get (core->io, mapref->id);\n\t\t\t\tif (map->perm & R_PERM_X) {\n\t\t\t\t\tut64 section_end = r_io_map_end (map);\n\t\t\t\t\tut64 s = r_anal_function_realsize (fcn);\n\t\t\t\t\tif (fcn->addr >= r_io_map_from (map) && (fcn->addr + s) < section_end) {\n\t\t\t\t\t\tcov += s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cov;\n}\n\nstatic int compute_code(RCore* core) {\n\tint code = 0;\n\tRIOBank *bank = r_io_bank_get (core->io, core->io->bank);\n\tif (bank) {\n\t\tRIOMapRef *mapref;\n\t\tRListIter *ator;\n\t\tr_list_foreach (bank->maprefs, ator, mapref) {\n\t\t\tRIOMap *map = r_io_map_get (core->io, mapref->id);\n\t\t\tif (map->perm & R_PERM_X) {\n\t\t\t\tcode += r_io_map_size (map);\n\t\t\t}\n\t\t}\n\t}\n\treturn code;\n}\n\nstatic int compute_calls(RCore *core) {\n\tint cov = 0;\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tRVecAnalRef *xrefs = r_anal_function_get_xrefs (fcn);\n\t\tif (xrefs) {\n\t\t\tcov += RVecAnalRef_length (xrefs);\n\t\t\tRVecAnalRef_free (xrefs);\n\t\t}\n\t}\n\treturn cov;\n}\n\nstatic void r_core_anal_info(RCore *core, const char *input) {\n\tint fcns = r_list_length (core->anal->fcns);\n\tint strs = r_flag_count (core->flags, \"str.*\");\n\tint syms = r_flag_count (core->flags, \"sym.*\");\n\tint imps = r_flag_count (core->flags, \"sym.imp.*\");\n\tint code = compute_code (core);\n\tint covr = compute_coverage (core);\n\tint call = compute_calls (core);\n\tint xrfs = r_anal_xrefs_count (core->anal);\n\tint cvpc = (code > 0)? (int)((covr * 100.0) / code): 0;\n\tif (*input == 'j') {\n\t\tPJ *pj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_o (pj);\n\t\tpj_ki (pj, \"fcns\", fcns);\n\t\tpj_ki (pj, \"xrefs\", xrfs);\n\t\tpj_ki (pj, \"calls\", call);\n\t\tpj_ki (pj, \"strings\", strs);\n\t\tpj_ki (pj, \"symbols\", syms);\n\t\tpj_ki (pj, \"imports\", imps);\n\t\tpj_ki (pj, \"covrage\", covr);\n\t\tpj_ki (pj, \"codesz\", code);\n\t\tpj_ki (pj, \"percent\", cvpc);\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t} else {\n\t\tr_cons_printf (\"fcns    %d\\n\", fcns);\n\t\tr_cons_printf (\"xrefs   %d\\n\", xrfs);\n\t\tr_cons_printf (\"calls   %d\\n\", call);\n\t\tr_cons_printf (\"strings %d\\n\", strs);\n\t\tr_cons_printf (\"symbols %d\\n\", syms);\n\t\tr_cons_printf (\"imports %d\\n\", imps);\n\t\tr_cons_printf (\"covrage %d\\n\", covr);\n\t\tr_cons_printf (\"codesz  %d\\n\", code);\n\t\tr_cons_printf (\"percent %d%%\\n\", cvpc);\n\t}\n}\n\nstatic void cmd_anal_aad(RCore *core, const char *input) {\n\tRVecAnalRef *list = r_anal_refs_get (core->anal, UT64_MAX);\n\tRAnalRef *ref;\n\tR_VEC_FOREACH (list, ref) {\n\t\tif (r_io_is_valid_offset (core->io, ref->addr, false)) {\n\t\t\tr_core_anal_fcn (core, ref->at, ref->addr, R_ANAL_REF_TYPE_NULL, 1);\n\t\t}\n\t}\n\tRVecAnalRef_free (list);\n}\n\nstatic bool archIsThumbable(RCore *core) {\n\tRArchConfig *ac = R_UNWRAP4 (core, anal, arch, cfg);\n\tif (ac && ac->bits <= 32) {\n\t\t// XXX for some reason this is null\n\t\tif (!strcmp (ac->arch, \"arm\")) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void _CbInRangeAav(RCore *core, ut64 from, ut64 to, int vsize, void *user) {\n\tbool asterisk = user;\n\tint arch_align = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_ALIGN);\n\tbool vinfun = r_config_get_b (core->config, \"anal.vinfun\");\n\tint searchAlign = r_config_get_i (core->config, \"search.align\");\n\tint align = (searchAlign > 0)? searchAlign: arch_align;\n\tif (align > 1) {\n\t\tif ((from % align) || (to % align)) {\n\t\t\tbool itsFine = false;\n\t\t\tif (archIsThumbable (core)) {\n\t\t\t\tif ((from & 1) || (to & 1)) {\n\t\t\t\t\titsFine = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!itsFine) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (core->anal->verbose) {\n\t\t\t\tR_LOG_WARN (\"aav: false positive in 0x%08\"PFMT64x, from);\n\t\t\t}\n\t\t}\n\t}\n\tif (!vinfun) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, from, -1);\n\t\tif (fcn) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (asterisk) {\n\t\tr_cons_printf (\"ax 0x%\"PFMT64x \" 0x%\"PFMT64x \"\\n\", to, from);\n\t\tr_cons_printf (\"Cd %d @ 0x%\"PFMT64x \"\\n\", vsize, from);\n\t\tr_cons_printf (\"f+ aav.0x%08\"PFMT64x \"= 0x%08\"PFMT64x, to, to);\n\t} else {\n\t\tr_anal_xrefs_set (core->anal, from, to, R_ANAL_REF_TYPE_NULL);\n\t\t// r_meta_set (core->anal, 'd', from, from + vsize, NULL);\n\t\tr_core_cmdf (core, \"Cd %d @ 0x%\"PFMT64x, vsize, from);\n\t\tif (!r_flag_get_at (core->flags, to, false)) {\n\t\t\tchar *name = r_str_newf (\"aav.0x%08\"PFMT64x, to);\n\t\t\tr_flag_set (core->flags, name, to, vsize);\n\t\t\tfree (name);\n\t\t}\n\t}\n}\n\nstatic void cmd_anal_aaw(RCore *core, const char *input) {\n\tbool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->print->config);\n\tint bits = core->anal->config->bits;\n\tRIntervalTreeIter it;\n\tRAnalMetaItem *item;\n\tr_interval_tree_foreach (&core->anal->meta, it, item) {\n\t\tRIntervalNode *node = r_interval_tree_iter_get (&it);\n\t\tut64 size = r_meta_item_size (node->start, node->end);\n\t\tif (item->type == R_META_TYPE_DATA && size == core->anal->config->bits / 8) {\n\t\t\tut8 buf[8] = {0};\n\t\t\tr_io_read_at (core->io, node->start, buf, 8);\n\t\t\tut64 n = r_read_ble (buf, be, bits);\n\t\t\tRFlagItem *fi = r_flag_get_at (core->flags, n, false);\n\t\t\tif (fi) {\n\t\t\t\tchar *fn = r_str_newf (\"r.%s\", fi->name);\n\t\t\t\tr_flag_set (core->flags, fn, node->start, true);\n\t\t\t\tfree (fn);\n\t\t\t} else if (core->anal->verbose) {\n\t\t\t\tR_LOG_WARN (\"Unknown pointer 0x%\"PFMT64x\" at 0x%\"PFMT64x, n, (ut64)node->start);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void cmd_anal_aav(RCore *core, const char *input) {\n#define seti(x,y) r_config_set_i(core->config, x, y);\n#define geti(x) r_config_get_i(core->config, x);\n\tr_return_if_fail (*input == 'v');\n\tbool relative = input[1] == 'r';\n\tut64 o_align = geti (\"search.align\");\n\tconst char *analin = r_config_get (core->config, \"anal.in\");\n\tchar *tmp = strdup (analin);\n\tbool asterisk = strchr (input, '*');\n\tconst bool is_debug = r_config_get_b (core->config, \"cfg.debug\");\n\tint archAlign = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_ALIGN);\n\tseti (\"search.align\", archAlign);\n\tr_config_set (core->config, \"anal.in\", \"io.maps.x\");\n\tR_LOG_INFO (\"Finding xrefs in noncode section (e anal.in=io.maps.x)\");\n\n\tint vsize = 4; // 32bit dword\n\tif (core->rasm->config->bits == 64) {\n\t\tvsize = 8;\n\t}\n\tR_LOG_INFO (\"Analyze value pointers (aav)\");\n\tr_cons_break_push (NULL, NULL);\n\tif (is_debug) {\n\t\tRList *list = r_core_get_boundaries_prot (core, 0, \"dbg.map\", \"anal\");\n\t\tRListIter *iter;\n\t\tRIOMap *map;\n\t\tif (!list) {\n\t\t\tgoto beach;\n\t\t}\n\t\tr_list_foreach (list, iter, map) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(void)r_core_search_value_in_range (core, relative, map->itv,\n\t\t\t\tr_io_map_begin (map), r_io_map_end (map), vsize, _CbInRangeAav, (void *)(size_t)asterisk);\n\t\t}\n\t\tr_list_free (list);\n\t} else {\n\t\tRList *list = r_core_get_boundaries_prot (core, 0, NULL, \"anal\");\n\t\tif (!list) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRListIter *iter, *iter2;\n\t\tRIOMap *map, *map2;\n\t\tut64 from = UT64_MAX;\n\t\tut64 to = UT64_MAX;\n\t\t// find values pointing to non-executable regions\n\t\tr_list_foreach (list, iter2, map2) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//TODO: Reduce multiple hits for same addr\n\t\t\tfrom = r_itv_begin (map2->itv);\n\t\t\tto = r_itv_end (map2->itv);\n\t\t\tif ((to - from) > MAX_SCAN_SIZE) {\n\t\t\t\tR_LOG_WARN (\"Skipping large region\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\tut64 begin = r_io_map_begin (map);\n\t\t\t\tut64 end = r_io_map_end (map);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (end - begin > UT32_MAX) {\n\t\t\t\t\tchar *unit = r_num_units (NULL, 0, end - begin);\n\t\t\t\t\tR_LOG_WARN (\"Skipping huge range (%s)\", unit);\n\t\t\t\t\tfree (unit);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tR_LOG_INFO (\"aav: 0x%08\"PFMT64x\"-0x%08\"PFMT64x\" in 0x%\"PFMT64x\"-0x%\"PFMT64x, from, to, begin, end);\n\t\t\t\t(void)r_core_search_value_in_range (core, relative, map->itv, from, to, vsize, _CbInRangeAav, (void *)(size_t)asterisk);\n\t\t\t}\n\t\t}\n\t\tr_list_free (list);\n\t}\nbeach:\n\tr_cons_break_pop ();\n\tr_config_set (core->config, \"anal.in\", tmp);\n\tfree (tmp);\n\tseti (\"search.align\", o_align);\n}\n\nstatic void cmd_anal_abt(RCore *core, const char *input) {\n\tRAnalBlock *bb = r_anal_get_block_at (core->anal, core->offset);\n\tif (bb) {\n\t\tif (R_STR_ISEMPTY (input)) {\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\"\\n\", bb->traced);\n\t\t} else if (*input == ' ') {\n\t\t\tchar *first = (char *)r_str_trim_head_ro (input);\n\t\t\tchar *arg = strchr (first, ' ');\n\t\t\tint tag = atoi (first);\n\t\t\tif (tag < 0 || tag > 63) {\n\t\t\t\tR_LOG_ERROR (\"Invalid trace tag number\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (arg) {\n\t\t\t\tRColor k = {0};\n\t\t\t\tchar *s = r_cons_pal_parse (arg + 1, &k);\n\t\t\t\tif (s)  {\n\t\t\t\t\tcore->anal->tracetagcolors[tag] = k;\n\t\t\t\t\tfree (s);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Invalid error\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbb->traced = tag;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot find any basic block here\");\n\t}\n}\n\nstatic void cmd_anal_abp(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase 'e': // \"abpe\"\n\t\t{\n\t\tint n = 1;\n\t\tchar *p = strchr (input + 1, ' ');\n\t\tif (!p) {\n\t\t\t// TODO use r_cons_cmd_help_match () instead\n\t\t\tr_core_cmd_help (core, help_msg_abp);\n\t\t\treturn;\n\t\t}\n\t\tut64 addr = r_num_math (core->num, p + 1);\n\t\tRList *paths = r_core_anal_graph_to (core, addr, n);\n\t\tif (paths) {\n\t\t\tRAnalBlock *bb;\n\t\t\tRList *path;\n\t\t\tRListIter *pathi;\n\t\t\tRListIter *bbi;\n\t\t\tr_cons_printf (\"f orip=`dr?PC`\\n\");\n\t\t\tr_list_foreach (paths, pathi, path) {\n\t\t\t\tr_list_foreach (path, bbi, bb) {\n\t\t\t\t\tr_cons_printf (\"# 0x%08\" PFMT64x \"\\n\", bb->addr);\n\t\t\t\t\tif (addr >= bb->addr && addr < bb->addr + bb->size) {\n\t\t\t\t\t\tr_cons_printf (\"aepc 0x%08\"PFMT64x\"\\n\", bb->addr);\n\t\t\t\t\t\tr_cons_printf (\"aesou 0x%08\"PFMT64x\"\\n\", addr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"aepc 0x%08\"PFMT64x\"\\n\", bb->addr);\n\t\t\t\t\t\tr_cons_printf (\"aesou 0x%08\"PFMT64x\"\\n\", bb->addr + bb->size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_cons_newline ();\n\t\t\t\tr_list_purge (path);\n\t\t\t\tfree (path);\n\t\t\t}\n\t\t\tr_list_purge (paths);\n\t\t\tr_cons_printf (\"aepc orip\\n\");\n\t\t\tfree (paths);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_abp);\n\t\tbreak;\n\tcase 'j': { // \"abpj\"\n\t\tut64 addr = r_num_math (core->num, input + 1);\n\t\tRAnalBlock *block = r_anal_get_block_at (core->anal, core->offset);\n\t\tif (!block) {\n\t\t\tbreak;\n\t\t}\n\t\tRList *path = r_anal_block_shortest_path (block, addr);\n\t\tPJ *pj = r_core_pj_new (core);\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t\tif (path) {\n\t\t\t\tRListIter *it;\n\t\t\t\tr_list_foreach (path, it, block) {\n\t\t\t\t\tpj_n (pj, block->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t}\n\t\tr_list_free (path);\n\t\tbreak;\n\t}\n\tcase ' ': {\n\t\tut64 addr = r_num_math (core->num, input + 1);\n\t\tif (addr == UT64_MAX || addr == 0) {\n\t\t\tR_LOG_ERROR (\"Invalid or missing address passed as argument\");\n\t\t} else {\n\t\t\tRAnalBlock *block = r_anal_get_block_at (core->anal, core->offset);\n\t\t\tif (!block) {\n\t\t\t\tR_LOG_ERROR (\"No basic block at\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRList *path = r_anal_block_shortest_path (block, addr);\n\t\t\tif (path) {\n\t\t\t\tRListIter *it;\n\t\t\t\tr_list_foreach (path, it, block) {\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", block->addr);\n\t\t\t\t}\n\t\t\t\tr_list_free (path);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase '\\0':\n\t\tr_core_cmdf (core, \"abl, addr/eq/0x%08\"PFMT64x, core->offset);\n\t\tbreak;\n\t}\n}\n\nstatic bool is_unknown_file(RCore *core) {\n\tif (core->bin->cur && core->bin->cur->bo) {\n\t\treturn r_list_empty (core->bin->cur->bo->sections);\n\t}\n\treturn true;\n}\n\nstatic bool is_apple_target(RCore *core) {\n\tconst char *arch = r_config_get (core->config, \"asm.arch\");\n\tif (!strstr (arch, \"ppc\") && !strstr (arch, \"arm\") && !strstr (arch, \"x86\")) {\n\t\treturn false;\n\t}\n\tRBinObject *bo = r_bin_cur_object (core->bin);\n\tr_return_val_if_fail (!bo || (bo->plugin && bo->plugin->name), false);\n\treturn bo? strstr (bo->plugin->name, \"mach\"): false;\n}\n\nstatic bool is_valid_code(RCore *core, ut64 addr, int n) {\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tRAnalOp *op = r_core_anal_op (core, addr, R_ARCH_OP_MASK_BASIC);\n\t\tif (op) {\n\t\t\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_NULL:\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_UNK:\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (op->size < 1) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\taddr += op->size;\n\t\t\tr_anal_op_free (op);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool is_executable(RCore *core, ut64 addr) {\n\tRBinObject *obj = r_bin_cur_object (core->bin);\n\tRListIter *it;\n\tRBinSection* sec;\n\tif (obj) {\n\t\tif (obj->info && obj->info->arch) {\n\t\t\treturn true;\n\t\t}\n\t\tr_list_foreach (obj->sections, it, sec) {\n\t\t\tut64 vaddr_end = sec->vaddr + sec->vsize;\n\t\t\tif (addr >= sec->vaddr && addr < vaddr_end) {\n\t\t\t\tif (sec->perm & R_PERM_X) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\tif (map) {\n\t\tif (map->perm & R_PERM_X) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool strnullpad_check(const ut8 *buf, int len, int clen, int inc, bool be) {\n\tint i;\n\tfor (i = 0; i < len; i += inc) {\n\t\tif (inc == 2) {\n\t\t\tif (be) {\n\t\t\t\tif (!buf[i] && !buf[i + 1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!IS_PRINTABLE (buf[i]) || buf[i + 1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!buf[i] && !buf[i + 1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (buf[i] || !IS_PRINTABLE (buf[i+1])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Invalid inc\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n// XXX from cmd_print.c\nstatic bool check_string_at(RCore *core, ut64 addr, bool and_print_it) {\n\tif (!r_io_is_valid_offset (core->io, addr, 0)) {\n\t\treturn false;\n\t}\n\tconst int len = core->blocksize; // max string length\n\tint i;\n\t// bool is_utf32le = false;\n\t// bool is_utf32be = false;\n\tbool is_pascal1 = false;\n\tbool is_pascal2 = false;\n\tbool is_utf8 = false;\n\tbool is_ascii = false;\n\tchar *out = NULL; // utf8 string containing the printable result\n\tut8 *buf = malloc (len);\n\tif (buf) {\n\t\tif (r_io_read_at (core->io, addr, buf, len) < 1) {\n\t\t\tfree (buf);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot allocate %d byte(s)\", len);\n\t\treturn false;\n\t}\n\tint nullbyte = r_str_nlen ((const char *)buf, len);\n\tif (nullbyte == len) {\n\t\t// full block, not null terminated somehow. lets check how printable it is first..\n\t\tbuf[len - 1] = 0;\n\t\tnullbyte--;\n\t}\n\tif (nullbyte < len && nullbyte > 3) {\n\t\tis_ascii = true;\n\t\t// it's a null terminated string!\n\t\tfor (i = 0; i < nullbyte; i++) {\n\t\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t\tis_ascii = false;\n\t\t\t}\n\t\t}\n\t\tif (!is_ascii) {\n\t\t\tis_utf8 = true;\n\t\t\tif ((buf[0] & 0xf0) == 0xf0 && (buf[1] & 0xf0) == 0xf0) {\n\t\t\t\tis_utf8 = false;\n\t\t\t}\n\t\t\tfor (i = 0; i < nullbyte; i++) {\n\t\t\t\tint us = r_utf8_size (buf + i);\n\t\t\t\tif (us < 1) {\n\t\t\t\t\tis_utf8 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti += us - 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// utf16le check\n\tif (strnullpad_check (buf, R_MIN (len, 10), 10, 2, false)) {\n\t\tout = malloc (len + 1);\n\t\tif (r_str_utf16_to_utf8 ((ut8*)out, len, buf, len, true) < 1) {\n\t\t\tR_FREE (out);\n\t\t}\n\t}\n\t// utf16be check\n\tif (strnullpad_check (buf, R_MIN (len, 10), 10, 2, true)) {\n\t\tout = malloc (len + 1);\n\t\tif (r_str_utf16_to_utf8 ((ut8*)out, len, buf, len, false) < 1) {\n\t\t\tR_FREE (out);\n\t\t}\n\t}\n\t// TODO: add support for utf32 strings and improve util apis\n\t// check for pascal string\n\t{\n\t\tut8 plen = buf[0];\n\t\tif (plen > 1 && plen < len) {\n\t\t\tis_pascal1 = true;\n\t\t\tint i;\n\t\t\tfor (i = 1; i < plen; i++) {\n\t\t\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t\t\tis_pascal1 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_pascal1) {\n\t\t\t\tchar *oout = r_str_ndup ((const char *)buf + 1, i);\n\t\t\t\tfree (out);\n\t\t\t\tout = oout;\n\t\t\t}\n\t\t}\n\t}\n\tif (!is_pascal1) {\n\t\tut8 plen = r_read_le16 (buf);\n\t\tif (plen > 2 && plen < len) {\n\t\t\tis_pascal2 = true;\n\t\t\tfor (i = 2; i < plen; i++) {\n\t\t\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t\t\tis_pascal2 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_pascal2) {\n\t\t\t\tchar *oout = r_str_ndup ((const char *)buf + 2, i);\n\t\t\t\tfree (out);\n\t\t\t\tout = oout;\n\t\t\t}\n\t\t}\n\t}\n\tif (!and_print_it) {\n\t\tfree (out);\n\t\treturn (is_ascii || is_utf8);\n\t}\n#if 0\n\teprintf (\"pascal %d\\n\", is_pascal1 + is_pascal2);\n\teprintf (\"utf8 %d\\n\", is_utf8);\n\teprintf (\"utf16 %d\\n\", is_utf16le+ is_utf16be);\n\teprintf (\"ascii %d\\n\", is_ascii);\n\teprintf (\"render\\n\");\n#endif\n\t// render the stuff\n\tif (out) {\n\t\tr_cons_printf (\"%s\\n\", out);\n\t\tfree (out);\n\t\tfree (buf);\n\t\treturn true;\n\t}\n\tif (is_ascii || is_utf8) {\n\t\tr_cons_printf (\"%s\\n\", buf);\n\t\tfree (buf);\n\t\treturn true;\n\t}\n\tfree (buf);\n\treturn false;\n}\n\nstatic bool funref(void *_core, ut64 from, ut64 addr) {\n\tRCore *core = _core;\n\tRAnalFunction *fcn = r_anal_get_function_at (core->anal, addr);\n\tif (!fcn && is_executable (core, addr)) {\n\t\tif (check_string_at (core, addr, false)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!is_valid_code (core, addr, 10)) {\n\t\t\treturn false;\n\t\t}\n\t\tr_core_cmdf (core, \"af@0x%08\"PFMT64x, addr);\n\t\t// r_core_anal_fcn (core, from, addr, 'c', 100);\n\t}\n\treturn true;\n}\n\nstatic void anal_aarr(RCore *core) {\n\tSetU *visited = set_u_new ();\n\tRAnalFunction *fcn;\n\tRListIter *it;\n\tr_list_foreach (core->anal->fcns, it, fcn) {\n#if 0\n\t\tr_anal_analyze_fcn_refs (core, fcn, depth);\n\t\tcontinue;\n#endif\n\t\tRVecAnalRef *refs = r_anal_function_get_refs (fcn);\n\t\tRAnalRef *refi;\n\t\tR_VEC_FOREACH (refs, refi) {\n\t\t\tut64 ra = refi->addr;\n\t\t\tif (set_u_contains (visited, ra)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tset_u_add (visited, ra);\n\t\t\tfunref (core, refi->at, ra);\n\t\t}\n\t\tRVecAnalRef_free (refs);\n\t}\n\tset_u_free (visited);\n}\n\nstatic int cmd_anal_all(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_aa);\n\t\tbreak;\n\tcase 'b': // \"aab\"\n\t\tcmd_anal_blocks (core, input + 1);\n\t\tbreak;\n\tcase 'f':\n\t\tif (input[1] == 'e') {  // \"aafe\"\n\t\t\tr_core_cmd0 (core, \"aef@@F\");\n\t\t} else if (input[1] == 'r') {\n\t\t\tut64 cur = core->offset;\n\t\t\tbool hasnext = r_config_get_b (core->config, \"anal.hasnext\");\n\t\t\tRListIter *iter;\n\t\t\tRIOMap *map;\n\t\t\tRList *list = r_core_get_boundaries_prot (core, R_PERM_X, NULL, \"anal\");\n\t\t\tif (!list) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\tr_core_seek (core, r_io_map_begin (map), true);\n\t\t\t\tr_config_set_b (core->config, \"anal.hasnext\", true);\n\t\t\t\tr_core_cmd_call (core, \"afr\");\n\t\t\t\tr_config_set_b (core->config, \"anal.hasnext\", hasnext);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t\tr_core_seek (core, cur, true);\n\t\t} else if (input[1] == 't') { // \"aaft\"\n\t\t\tcmd_anal_aaft (core);\n\t\t} else if (input[1] == 'f') { // \"aaff\"\n\t\t\tflag_every_function (core);\n\t\t} else if (input[1] == 's') { // \"aafs\"\n\t\t\tsingle_block_analysis (core);\n\t\t} else if (input[1] == 0) { // \"aaf\"\n\t\t\tconst bool analHasnext = r_config_get_b (core->config, \"anal.hasnext\");\n\t\t\tr_config_set_b (core->config, \"anal.hasnext\", true);\n\t\t\tr_core_cmd0 (core, \"afr@@c:isq\");\n\t\t\tr_config_set_b (core->config, \"anal.hasnext\", analHasnext);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_aaf);\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"aac\"\n\t\tswitch (input[1]) {\n\t\tcase '*': // \"aac*\"\n\t\t\tcmd_anal_calls (core, input + 1, true, false);\n\t\t\tbreak;\n\t\tcase 'i': // \"aaci\"\n\t\t\tcmd_anal_calls (core, input + 1, input[2] == '*', true);\n\t\t\tbreak;\n\t\tcase '?': // \"aac?\"\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aac\", false);\n\t\t\tbreak;\n\t\tdefault: // \"aac\"\n\t\t\tcmd_anal_calls (core, input + 1, false, false);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"aaj\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aaj\", true);\n\t\t} else {\n\t\t\tcmd_anal_jumps (core, input + 1);\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"aad\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aad\", true);\n\t\t} else {\n\t\t\tcmd_anal_aad (core, input);\n\t\t}\n\t\tbreak;\n\tcase 'v': // \"aav\"\n\t\tif (strchr (input + 1, '?')) {\n\t\t\tr_core_cmd_help (core, help_msg_aav);\n\t\t} else {\n\t\t\tcmd_anal_aav (core, input);\n\t\t}\n\t\tbreak;\n\tcase 'w': // \"aaw\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aaw\", true);\n\t\t} else {\n\t\t\tcmd_anal_aaw (core, input);\n\t\t}\n\t\tbreak;\n\tcase 'u': // \"aau\" - print areas not covered by functions\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aau\", true);\n\t\t} else {\n\t\t\tr_core_anal_nofunclist (core, input + 1);\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"aai\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aai\", true);\n\t\t} else {\n\t\t\tr_core_anal_info (core, input + 1);\n\t\t}\n\t\tbreak;\n\tcase 's': // \"aas\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aas\", true);\n\t\t} else {\n\t\t\tr_core_cmd0 (core, \"af @@= `isq~[0]`\");\n\t\t\tr_core_cmd0 (core, \"af @@f:entry*\");\n\t\t}\n\t\tbreak;\n\tcase 'S': // \"aaS\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aaS\", true);\n\t\t} else {\n\t\t\tr_core_cmd0 (core, \"af @@f:sym.*\");\n\t\t\tr_core_cmd0 (core, \"af @@f:entry*\");\n\t\t}\n\t\tbreak;\n\tcase 'F': // \"aaF\" \"aaFa\"\n\t\tif (!input[1] || input[1] == ' ' || input[1] == 'a') {\n\t\t\tr_core_anal_inflags (core, input + 1);\n\t\t} else {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aaF\", false);\n\t\t}\n\t\tbreak;\n\tcase 'n': // \"aan\"\n\t\tswitch (input[1]) {\n\t\tcase 'r': // \"aanr\" // all noreturn propagation\n\t\t\tr_core_anal_propagate_noreturn (core, UT64_MAX);\n\t\t\tbreak;\n\t\tcase 'g': // \"aang\"\n\t\t\tr_core_anal_autoname_all_golang_fcns (core);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_aan);\n\t\t\tbreak;\n\t\tcase 'f': // \"aanf\" same as \"aan\" but more friendly\n\t\tdefault: // \"aan\"\n\t\t\tr_core_anal_autoname_all_fcns (core);\n\t\t}\n\t\tbreak;\n\tcase 'p': // \"aap\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aap\", true);\n\t\t} else {\n\t\t\tr_core_search_preludes (core, true);\n\t\t}\n\t\tbreak;\n\tcase '\\0': // \"aa\"\n\tcase 'a':\n\t\tif (strchr (input, '?')) {\n\t\t\tr_core_cmd_help (core, help_msg_aaa);\n\t\t} else {\n\t\t\tbool didAap = false;\n\t\t\tchar *dh_orig = NULL;\n\t\t\tif (!strncmp (input, \"aaaaa\", 5)) {\n\t\t\t\tR_LOG_INFO (\"We fired the r2 developer that was heading to your location to help you analyze this binary\");\n\t\t\t\tR_LOG_INFO (\"Contact support for premium service\");\n\t\t\t\tif (r_cons_is_interactive ()) {\n\t\t\t\t\tr_cons_any_key (NULL);\n\t\t\t\t}\n\t\t\t\tgoto jacuzzi;\n\t\t\t}\n\t\t\tut64 curseek = core->offset;\n\t\t\tR_LOG_INFO (\"Analyze all flags starting with sym. and entry0 (aa)\");\n\t\t\tr_cons_break_push (NULL, NULL);\n\t\t\tr_cons_break_timeout (r_config_get_i (core->config, \"anal.timeout\"));\n\t\t\tr_core_anal_all (core);\n\t\t\tr_core_task_yield (&core->tasks);\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto jacuzzi;\n\t\t\t}\n\n\t\t\t// Run afvn in all fcns\n\t\t\tif (r_config_get_b (core->config, \"anal.vars\")) {\n\t\t\t\tR_LOG_INFO (\"Analyze all functions arguments/locals (afva@@@F)\");\n\t\t\t\t// r_core_cmd0 (core, \"afva@@f\");\n\t\t\t\tr_core_cmd0 (core, \"afva@@@F\");\n\t\t\t}\n\n\t\t\t// Run pending analysis immediately after analysis\n\t\t\t// Usefull when running commands with \";\" or via r2 -c,-i\n\t\t\tdh_orig = core->dbg->current\n\t\t\t\t? strdup (core->dbg->current->plugin.meta.name)\n\t\t\t\t: strdup (\"esil\");\n\t\t\tif (core->io->desc && core->io->desc->plugin && !core->io->desc->plugin->isdbg) {\n\t\t\t\t//use dh_origin if we are debugging\n\t\t\t\tR_FREE (dh_orig);\n\t\t\t}\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto jacuzzi;\n\t\t\t}\n\t\t\tr_cons_clear_line (1);\n\t\t\tbool cfg_debug = r_config_get_b (core->config, \"cfg.debug\");\n\t\t\tif (*input == 'a') { // \"aaa\" .. which is checked just in the case above\n\t\t\t\tif (r_str_startswith (r_config_get (core->config, \"bin.lang\"), \"go\")) {\n\t\t\t\t\tR_LOG_INFO (\"Find function and symbol names from golang binaries (aang)\");\n\t\t\t\t\tr_core_anal_autoname_all_golang_fcns (core);\n\t\t\t\t\tR_LOG_INFO (\"Analyze all flags starting with sym.go. (aF @@f:sym.go.*)\");\n\t\t\t\t\tr_core_cmd0 (core, \"aF @@@F:sym.go.*\");\n\t\t\t\t}\n\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\tif (!cfg_debug) {\n\t\t\t\t\tif (dh_orig && strcmp (dh_orig, \"esil\")) {\n\t\t\t\t\t\tr_core_cmd_call (core, \"dL esil\");\n\t\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// XXX do not override user settings!\n\t\t\t\t// int c = r_config_get_i (core->config, \"anal.calls\");\n\t\t\t\t// r_config_set_b (core->config, \"anal.calls\", true);\n\t\t\t\tr_core_cmd_call (core, \"s $S\");\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\n\t\t\t\tR_LOG_INFO (\"Analyze function calls (aac)\");\n\t\t\t\t(void)cmd_anal_calls (core, \"\", false, false); // \"aac\"\n\t\t\t\tr_core_seek (core, curseek, true);\n\t\t\t\t// R_LOG_INFO (\"Analyze data refs as code (LEA)\");\n\t\t\t\t// (void) cmd_anal_aad (core, NULL); // \"aad\"\n\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\n\t\t\t\tif (is_unknown_file (core)) {\n\t\t\t\t\tR_LOG_INFO (\"find and analyze function preludes (aap)\");\n\t\t\t\t\t(void)r_core_search_preludes (core, false); // \"aap\"\n\t\t\t\t\tdidAap = true;\n\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tR_LOG_INFO (\"Analyze len bytes of instructions for references (aar)\");\n\t\t\t\t(void)r_core_anal_refs (core, \"\"); // \"aar\"\n\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\t\t\t\tif (is_apple_target (core)) {\n\t\t\t\t\tR_LOG_INFO (\"Check for objc references (aao)\");\n\t\t\t\t\tcmd_anal_objc (core, input + 1, true);\n\t\t\t\t}\n\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\tR_LOG_INFO (\"Finding and parsing C++ vtables (avrr)\");\n\t\t\t\tr_core_cmd_call (core, \"avrr\");\n\t\t\t\tr_core_cmd0 (core, \"af @@ method.*\");\n\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t// r_config_set_b (core->config, \"anal.calls\", c);\n\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\t\t\t\tconst bool isPreludableArch = core->rasm->config->bits == 64 && r_str_startswith (r_config_get (core->config, \"asm.arch\"), \"arm\");\n\n\t\t\t\tif (!didAap && isPreludableArch) {\n\t\t\t\t\tdidAap = true;\n\t\t\t\t\tR_LOG_INFO (\"Finding function preludes (aap)\");\n\t\t\t\t\t(void)r_core_search_preludes (core, false); // \"aap\"\n\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t}\n\t\t\t\tif (!r_str_startswith (r_config_get (core->config, \"asm.arch\"), \"x86\")) {\n\t\t\t\t\tr_core_cmd_call (core, \"aav\");\n\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t\tif (cfg_debug) {\n\t\t\t\t\t\tR_LOG_INFO (\"Skipping function emulation in debugger mode (aaef)\");\n\t\t\t\t\t\t// nothing to do\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst bool io_cache = r_config_get_i (core->config, \"io.pcache\");\n\t\t\t\t\t\tr_config_set_b (core->config, \"io.pcache\", true);\n\t\t\t\t\t\tR_LOG_INFO (\"Emulate functions to find computed references (aaef)\");\n\t\t\t\t\t\tr_core_cmd_call (core, \"aaef\");\n\t\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t\t\tr_config_set_b (core->config, \"io.pcache\", io_cache);\n\t\t\t\t\t}\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (r_config_get_i (core->config, \"anal.autoname\")) {\n\t\t\t\t\tR_LOG_INFO (\"Speculatively constructing a function name for fcn.* and sym.func.* functions (aan)\");\n\t\t\t\t\tr_core_anal_autoname_all_fcns (core);\n\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t}\n\t\t\t\tif (core->anal->opt.vars) {\n\t\t\t\t\tRAnalFunction *fcni;\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tr_list_foreach (core->anal->fcns, iter, fcni) {\n\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tRList *list = r_anal_var_list (core->anal, fcni, 'r');\n\t\t\t\t\t\tif (!r_list_empty (list)) {\n\t\t\t\t\t\t\tr_list_free (list);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// extract only reg based var here\n\t\t\t\t\t\tr_core_recover_vars (core, fcni, true);\n\t\t\t\t\t\tr_list_free (list);\n\t\t\t\t\t}\n\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t}\n\t\t\t\tif (!sdb_isempty (core->anal->sdb_zigns)) {\n\t\t\t\t\tR_LOG_INFO (\"Check for zignature from zigns folder (z/)\");\n\t\t\t\t\tr_core_cmd_call (core, \"z/\");\n\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t}\n\t\t\t\tif (cfg_debug) {\n\t\t\t\t\tR_LOG_INFO (\"Skipping type matching analysis in debugger mode (aaft)\");\n\t\t\t\t\t// nothing to do\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_INFO (\"Type matching analysis for all functions (aaft)\");\n\t\t\t\t\tr_core_cmd_call (core, \"aaft\");\n\t\t\t\t}\n\t\t\t\tr_core_task_yield (&core->tasks);\n\n\t\t\t\tR_LOG_INFO (\"Propagate noreturn information (aanr)\");\n\t\t\t\tr_core_anal_propagate_noreturn (core, UT64_MAX);\n\t\t\t\tr_core_task_yield (&core->tasks);\n\n\t\t\t\t// apply dwarf function information\n\t\t\t\tSdb *dwarf_sdb = sdb_ns (core->anal->sdb, \"dwarf\", 0);\n\t\t\t\tif (dwarf_sdb) {\n\t\t\t\t\tR_LOG_INFO (\"Integrate dwarf function information\");\n\t\t\t\t\tr_anal_dwarf_integrate_functions (core->anal, core->flags, dwarf_sdb);\n\t\t\t\t}\n\n\t\t\t\tif (input[1] == 'a') { // \"aaaa\"\n\t\t\t\t\tR_LOG_INFO (\"Scanning for strings constructed in code (/azs)\");\n\t\t\t\t\tr_core_cmd_call (core, \"/azs\");\n\t\t\t\t\tif (!didAap) {\n\t\t\t\t\t\tdidAap = true;\n\t\t\t\t\t\tR_LOG_INFO (\"Finding function preludes (aap)\");\n\t\t\t\t\t\t(void)r_core_search_preludes (core, false); // \"aap\"\n\t\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t\t}\n\t\t\t\t\tR_LOG_INFO (\"Enable anal.types.constraint for experimental type propagation\");\n\t\t\t\t\tr_config_set_b (core->config, \"anal.types.constraint\", true);\n\t\t\t\t\tif (input[2] == 'a') { // \"aaaa\"\n\t\t\t\t\t\tR_LOG_INFO (\"Reanalizing graph references to improve function count (aarr)\");\n\t\t\t\t\t\tr_core_cmd_call (core, \"aarr\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_INFO (\"Use -AA or aaaa to perform additional experimental analysis\");\n\t\t\t\t}\n\t\t\t\tr_core_cmd_call (core, \"s-\");\n\t\t\t\tif (dh_orig) {\n\t\t\t\t\tr_core_cmdf (core, \"dL %s\", dh_orig);\n\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_core_seek (core, curseek, true);\n\t\tjacuzzi:\n\t\t\t// XXX this shouldnt be called. flags muts be created wheen the function is registered\n\t\t\tflag_every_function (core);\n\t\t\tr_core_anal_propagate_noreturn (core, UT64_MAX);\n\t\t\tr_cons_break_pop ();\n\t\t\tR_FREE (dh_orig);\n\t\t}\n\t\tbreak;\n\tcase 't': // \"aat\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aat\", true);\n\t\t} else {\n\t\t\tchar *off = input[1]? r_str_trim_dup (input + 2): NULL;\n\t\t\tRAnalFunction *fcn;\n\t\t\tRListIter *it;\n\t\t\tif (off && *off) {\n\t\t\t\tut64 addr = r_num_math (NULL, off);\n\t\t\t\tfcn = r_anal_get_function_at (core->anal, core->offset);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_core_link_stroff (core, fcn);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot find function at %08\" PFMT64x, addr);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (r_list_empty (core->anal->fcns)) {\n\t\t\t\t\tR_LOG_ERROR (\"Couldn't find any functions\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tr_core_link_stroff (core, fcn);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (off);\n\t\t}\n\t\tbreak;\n\tcase 'T': // \"aaT\"\n\t\tcmd_anal_aftertraps (core, input + 1);\n\t\tbreak;\n\tcase 'o': // \"aao\"\n\t\tif (input[1] == '?') { // \"aao?\"\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aao\", true);\n\t\t} else {\n\t\t\tcmd_anal_objc (core, input + 1, false);\n\t\t}\n\t\tbreak;\n\tcase 'e': // \"aae\"\n\t\tif (input[1] == 'f') { // \"aaef\"\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_aae, \"aaef\", true);\n\t\t\t} else {\n\t\t\t\tr_core_cmd0 (core, \"aeim\");\n\t\t\t\tRListIter *it;\n\t\t\t\tRAnalFunction *fcn;\n\t\t\t\tut64 cur_seek = core->offset;\n\t\t\t\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\t\t\t\tr_core_seek (core, fcn->addr, true);\n\t\t\t\t\tr_core_anal_esil (core, \"f\", NULL);\n\t\t\t\t\t// __anal_esil_function (core, fcn->addr);\n\t\t\t\t}\n\t\t\t\tr_core_seek (core, cur_seek, true);\n\t\t\t}\n\t\t} else if (input[1] == '?') { // \"aae?\"\n\t\t\tr_core_cmd_help (core, help_msg_aae);\n\t\t} else if (input[1] == 'p') { // \"aaep\" // auto define all esil pins\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_aae, \"aaef\", true);\n\t\t\t} else {\n\t\t\t\tr_core_cmd0 (core, \"aep ret0@@@i\");\n\t\t\t\tr_core_cmd0 (core, \"aepa@@@i\");\n\t\t\t}\n\t\t} else if (input[1] == ' ') { // \"aae \"\n\t\t\tchar *arg = r_str_trim_dup (input + 1);\n\t\t\tconst char *len = (char *)arg;\n\t\t\tchar *addr = strchr (arg, ' ');\n\t\t\tif (addr) {\n\t\t\t\t*addr = 0;\n\t\t\t\taddr = (char *)r_str_trim_head_ro (addr + 1);\n\t\t\t}\n\t\t\tr_core_cmd0 (core, \"aeim\");\n\t\t\tr_core_anal_esil (core, len, addr);\n\t\t\tfree (arg);\n\t\t} else {\n\t\t\tut64 at = core->offset;\n\t\t\tRIOMap *map;\n\t\t\tRListIter *iter;\n\t\t\tRList *list = r_core_get_boundaries_prot (core, -1, NULL, \"anal\");\n\t\t\tif (!list) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!strcmp (\"range\", r_config_get (core->config, \"anal.in\"))) {\n\t\t\t\tut64 from = r_config_get_i (core->config, \"anal.from\");\n\t\t\t\tut64 to = r_config_get_i (core->config, \"anal.to\");\n\t\t\t\tif (to > from) {\n\t\t\t\t\tchar *len = r_str_newf (\" 0x%\"PFMT64x, to - from);\n\t\t\t\t\tr_core_seek (core, from, true);\n\t\t\t\t\tr_core_anal_esil (core, len, NULL);\n\t\t\t\t\tfree (len);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Assert: anal.from > anal.to\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\t\tif (map->perm & R_PERM_X) {\n\t\t\t\t\t\tchar *ss = r_str_newf (\" 0x%\"PFMT64x, r_io_map_size (map));\n\t\t\t\t\t\tr_core_seek (core, r_io_map_begin (map), true);\n\t\t\t\t\t\tr_core_anal_esil (core, ss, NULL);\n\t\t\t\t\t\tfree (ss);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t\tr_core_seek (core, at, true);\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"aar\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_aar);\n\t\t} else if (input[1] == 'r') { // \"aarr\"\n\t\t\tanal_aarr (core);\n\t\t} else {\n\t\t\t(void)r_core_anal_refs (core, input + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_aa);\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic bool anal_fcn_data(RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_ANY);\n\tif (fcn) {\n\t\tint i;\n\t\tbool gap = false;\n\t\tut64 gap_addr = UT64_MAX;\n\t\tut32 fcn_size = r_anal_function_size_from_entry (fcn);\n\t\tchar *bitmap = calloc (1, fcn_size);\n\t\tif (bitmap) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint f = b->addr - fcn->addr;\n\t\t\t\tint t = R_MIN (f + b->size, fcn_size);\n\t\t\t\tif (f >= 0) {\n\t\t\t\t\twhile (f < t) {\n\t\t\t\t\t\tbitmap[f++] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < fcn_size; i++) {\n\t\t\tut64 here = fcn->addr + i;\n\t\t\tif (bitmap && bitmap[i]) {\n\t\t\t\tif (gap) {\n\t\t\t\t\tr_cons_printf (\"Cd %\" PFMT64u \" @ 0x%08\"PFMT64x\"\\n\", here - gap_addr, gap_addr);\n\t\t\t\t\tgap = false;\n\t\t\t\t}\n\t\t\t\tgap_addr = UT64_MAX;\n\t\t\t} else {\n\t\t\t\tif (!gap) {\n\t\t\t\t\tgap = true;\n\t\t\t\t\tgap_addr = here;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gap) {\n\t\t\tr_cons_printf (\"Cd %\" PFMT64u \" @ 0x%08\" PFMT64x \"\\n\", fcn->addr + fcn_size - gap_addr, gap_addr);\n\t\t}\n\t\tfree (bitmap);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool anal_fcn_data_gaps(RCore *core, const char *input) {\n\tut64 end = UT64_MAX;\n\tRAnalFunction *fcn;\n\tRListIter *iter;\n\tint i, wordsize = (core->rasm->config->bits == 64)? 8: 4;\n\tr_list_sort (core->anal->fcns, cmpaddr);\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tif (end != UT64_MAX) {\n\t\t\tint range = fcn->addr - end;\n\t\t\tif (range > 0) {\n\t\t\t\tfor (i = 0; i + wordsize < range; i+= wordsize) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", wordsize, end + i);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", range - i, end + i);\n\t\t\t\t//r_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", range, end);\n\t\t\t}\n\t\t}\n\t\tend = fcn->addr + r_anal_function_size_from_entry (fcn);\n\t}\n\treturn true;\n}\n\nstatic void cmd_anal_rtti(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase '\\0': // \"avr\"\n\tcase 'j': // \"avrj\"\n\t\tr_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);\n\t\tbreak;\n\tcase 'a': // \"avra\"\n\t\tr_anal_rtti_print_all (core->anal, input[1]);\n\t\tbreak;\n\tcase 'r': // \"avrr\"\n\t\tr_anal_rtti_recover_all (core->anal);\n\t\tbreak;\n\tcase 'D': { // \"avrD\"\n\t\tchar *name = r_str_trim_dup (input + 1);\n\t\tchar *demangled = r_anal_rtti_demangle_class_name (core->anal, name);\n\t\tfree (name);\n\t\tif (demangled) {\n\t\t\tr_cons_println (demangled);\n\t\t\tfree (demangled);\n\t\t}\n\t\tbreak;\n\t}\n\tdefault :\n\t\tr_core_cmd_help (core, help_msg_av);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_avg(RCore *core, const char* input) {\n\tswitch (input[0]) {\n\tcase ' ':\n\t\tif (strchr (input + 1, ' ')) {\n\t\t\tchar *a = r_str_trim_dup (input + 1);\n\t\t\tchar *b = strchr (a, ' ');\n\t\t\tif (b) {\n\t\t\t\t*b++ = 0;\n\t\t\t\tr_anal_global_add (core->anal, core->offset, a, b);\n\t\t\t} else {\n\t\t\t\tRFlagItem *fi = r_anal_global_get (core->anal, core->offset);\n\t\t\t\tif (fi) {\n\t\t\t\t\tR_LOG_INFO (\"type %s\", fi->type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (a);\n\t\t}\n\t\tbreak;\n\tcase '-':\n\t\tr_anal_global_del (core->anal, core->offset);\n\t\tbreak;\n\tcase '\\0': // \"av\"\n\t\tr_core_cmd0 (core, \"fs+globals;f;fs-\");\n\t\tbreak;\n\tdefault :\n\t\tr_core_cmd_help (core, help_msg_avg);\n\t\tbreak;\n\t}\n}\nstatic void cmd_anal_virtual_functions(RCore *core, const char* input) {\n\tswitch (input[0]) {\n\tcase 'g':\n\t\tcmd_avg (core, input + 1);\n\t\tbreak;\n\tcase '\\0': // \"av\"\n\tcase '*': // \"av*\"\n\tcase 'j': // \"avj\"\n\t\tr_anal_list_vtables (core->anal, input[0]);\n\t\tbreak;\n\tcase 'r': // \"avr\"\n\t\tcmd_anal_rtti (core, input + 1);\n\t\tbreak;\n\tdefault :\n\t\tr_core_cmd_help (core, help_msg_av);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_class_method(RCore *core, const char *input) {\n\tRAnalClassErr err = R_ANAL_CLASS_ERR_SUCCESS;\n\tchar c = input[0];\n\tswitch (c) {\n\tcase ' ': // \"acm\"\n\tcase '-': // \"acm-\"\n\tcase 'n': { // \"acmn\"\n\t\tconst char *str = r_str_trim_head_ro (input + 1);\n\t\tif (!*str) {\n\t\t\tR_LOG_ERROR (\"No class name given\");\n\t\t\tbreak;\n\t\t}\n\t\tchar *cstr = strdup (str);\n\t\tif (!cstr) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *end = strchr (cstr, ' ');\n\t\tif (!end) {\n\t\t\tR_LOG_ERROR (\"No method name given\");\n\t\t\tfree (cstr);\n\t\t\tbreak;\n\t\t}\n\t\t*end = '\\0';\n\t\tchar *name_str = end + 1;\n\n\t\tif (c == ' ' || c == 'n') {\n\t\t\tend = strchr (name_str, ' ');\n\t\t\tif (!end) {\n\t\t\t\tif (c == ' ') {\n\t\t\t\t\tR_LOG_ERROR (\"No offset given\");\n\t\t\t\t} else if (c == 'n') {\n\t\t\t\t\tR_LOG_ERROR (\"No new method name given\");\n\t\t\t\t}\n\t\t\t\tfree (cstr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*end = '\\0';\n\t\t}\n\n\t\tif (c == ' ') {\n\t\t\tchar *addr_str = end + 1;\n\t\t\tend = strchr (addr_str, ' ');\n\t\t\tif (end) {\n\t\t\t\t*end = '\\0';\n\t\t\t}\n\n\t\t\tRAnalMethod meth;\n\t\t\tmeth.name = name_str;\n\t\t\tmeth.addr = r_num_get (core->num, addr_str);\n\t\t\tmeth.vtable_offset = -1;\n\t\t\tif (end) {\n\t\t\t\tmeth.vtable_offset = (int)r_num_get (core->num, end + 1);\n\t\t\t}\n\t\t\terr = r_anal_class_method_set (core->anal, cstr, &meth);\n\t\t} else if (c == 'n') {\n\t\t\tchar *new_name_str = end + 1;\n\t\t\tend = strchr (new_name_str, ' ');\n\t\t\tif (end) {\n\t\t\t\t*end = '\\0';\n\t\t\t}\n\n\t\t\terr = r_anal_class_method_rename (core->anal, cstr, name_str, new_name_str);\n\t\t} else if (c == '-') {\n\t\t\terr = r_anal_class_method_delete (core->anal, cstr, name_str);\n\t\t}\n\n\t\tfree (cstr);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ac);\n\t\tbreak;\n\t}\n\n\tswitch (err) {\n\tcase R_ANAL_CLASS_ERR_NONEXISTENT_CLASS:\n\t\tR_LOG_ERROR (\"Class does not exist\");\n\t\tbreak;\n\tcase R_ANAL_CLASS_ERR_NONEXISTENT_ATTR:\n\t\tR_LOG_ERROR (\"Method does not exist\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_class_base(RCore *core, const char *input) {\n\tRAnalClassErr err = R_ANAL_CLASS_ERR_SUCCESS;\n\tchar c = input[0];\n\tswitch (c) {\n\tcase ' ': // \"acb\"\n\tcase '-': { // \"acb-\"\n\t\tconst char *str = r_str_trim_head_ro (input + 1);\n\t\tif (!*str) {\n\t\t\tR_LOG_ERROR (\"No class name given\");\n\t\t\treturn;\n\t\t}\n\t\tchar *cstr = strdup (str);\n\t\tif (!cstr) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *end = strchr (cstr, ' ');\n\t\tif (end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\n\t\tif (!end || *end == '\\0') {\n\t\t\tif (c == ' ') {\n\t\t\t\tr_anal_class_list_bases (core->anal, cstr);\n\t\t\t} else /*if (c == '-')*/ {\n\t\t\t\tR_LOG_ERROR (\"No base id given\");\n\t\t\t}\n\t\t\tfree (cstr);\n\t\t\tbreak;\n\t\t}\n\n\t\tchar *base_str = end;\n\t\tend = strchr (base_str, ' ');\n\t\tif (end) {\n\t\t\t*end = '\\0';\n\t\t}\n\n\t\tif (c == '-') {\n\t\t\terr = r_anal_class_base_delete (core->anal, cstr, base_str);\n\t\t\tfree (cstr);\n\t\t\tbreak;\n\t\t}\n\n\t\tRAnalBaseClass base;\n\t\tbase.id = NULL;\n\t\tbase.offset = 0;\n\t\tbase.class_name = base_str;\n\n\t\tif (end) {\n\t\t\tbase.offset = r_num_get (core->num, end + 1);\n\t\t}\n\n\t\terr = r_anal_class_base_set (core->anal, cstr, &base);\n\t\tfree (base.id);\n\t\tfree (cstr);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ac);\n\t\tbreak;\n\t}\n\n\tif (err == R_ANAL_CLASS_ERR_NONEXISTENT_CLASS) {\n\t\tR_LOG_ERROR (\"Class does not exist\");\n\t}\n}\n\nstatic void cmd_anal_class_vtable(RCore *core, const char *input) {\n\tRAnalClassErr err = R_ANAL_CLASS_ERR_SUCCESS;\n\tchar c = input[0];\n\tswitch (c) {\n\tcase 'f': {// \"acvf\" [offset] ([class_name])\n\t\tconst char *str = r_str_trim_head_ro (input + 1);\n\t\tif (!*str) {\n\t\t\tR_LOG_ERROR (\"No offset given\");\n\t\t\treturn;\n\t\t}\n\t\tchar *cstr = strdup (str);\n\t\tif (!cstr) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *end = strchr (cstr, ' ');\n\t\tif (end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\t\tut64 offset_arg = r_num_get (core->num, cstr); // Should I allow negative offset?\n\t\tchar *class_arg = NULL;\n\t\tif (end) {\n\t\t\tclass_arg = (char *)r_str_trim_head_ro (end);\n\t\t}\n\n\t\tif (class_arg) {\n\t\t\tend = (char *)r_str_trim_head_wp (class_arg); // in case of extra unwanted stuff at the cmd end\n\t\t\t*end = '\\0';\n\t\t}\n\t\tr_anal_class_list_vtable_offset_functions (core->anal, class_arg, offset_arg);\n\n\t\tfree (cstr);\n\t\tbreak;\n\t}\n\tcase ' ': // \"acv\"\n\tcase '-': { // \"acv-\"\n\t\tconst char *str = r_str_trim_head_ro (input + 1);\n\t\tif (!*str) {\n\t\t\tR_LOG_ERROR (\"No class name given\");\n\t\t\treturn;\n\t\t}\n\t\tchar *cstr = strdup (str);\n\t\tif (!cstr) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *end = strchr (cstr, ' ');\n\t\tif (end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\n\t\tif (!end || *end == '\\0') {\n\t\t\tif (c == ' ') {\n\t\t\t\tr_anal_class_list_vtables (core->anal, cstr);\n\t\t\t} else /*if (c == '-')*/ {\n\t\t\t\tR_LOG_ERROR (\"No vtable id given. See acv [class name]\");\n\t\t\t}\n\t\t\tfree (cstr);\n\t\t\tbreak;\n\t\t}\n\n\t\tchar *arg1_str = end;\n\n\t\tif (c == '-') {\n\t\t\terr = r_anal_class_vtable_delete (core->anal, cstr, arg1_str);\n\t\t\tfree (cstr);\n\t\t\tbreak;\n\t\t}\n\n\t\tend = strchr (arg1_str, ' ');\n\t\tif (end) {\n\t\t\t*end = '\\0';\n\t\t}\n\n\t\tRAnalVTable vtable;\n\t\tvtable.id = NULL;\n\t\tvtable.addr = r_num_get (core->num, arg1_str);\n\t\tvtable.offset = 0;\n\t\tvtable.size = 0;\n\n\t\tchar *arg3_str = NULL;\n\t\tif (end) {\n\t\t\tvtable.offset = r_num_get (core->num, end + 1);\n\t\t\t// end + 1 won't work on extra whitespace between arguments, TODO\n\t\t\targ3_str = strchr (end + 1, ' ');\n\t\t}\n\n\t\tif (arg3_str) {\n\t\t\tvtable.size = r_num_get (core->num, arg3_str + 1);\n\t\t}\n\n\t\terr = r_anal_class_vtable_set (core->anal, cstr, &vtable);\n\t\tfree (vtable.id);\n\t\tfree (cstr);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ac);\n\t\tbreak;\n\t}\n\tif (err == R_ANAL_CLASS_ERR_NONEXISTENT_CLASS) {\n\t\tR_LOG_ERROR (\"Class does not exist\");\n\t}\n}\n\nstatic void cmd_anal_classes(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase 'l': // \"acl\"\n\t\tif (input[1] == 'l') { // \"acll\" (name)\n\t\t\tchar mode = 0;\n\t\t\tint arg_offset = 2;\n\t\t\tif (input[2] == 'j') {\n\t\t\t\targ_offset++;\n\t\t\t\tmode = 'j';\n\t\t\t}\n\t\t\tconst char *arg = r_str_trim_head_ro (input + arg_offset);\n\t\t\tif (*arg) { // if there is an argument\n\t\t\t\tchar *class_name = strdup (arg);\n\t\t\t\tif (!class_name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *name_end = (char *)r_str_trim_head_wp (class_name);\n\t\t\t\t*name_end = 0; // trim the whitespace around the name\n\t\t\t\tif (mode == 'j') {\n\t\t\t\t\tPJ *pj = pj_new ();\n\t\t\t\t\tr_anal_class_json (core->anal, pj, class_name);\n\t\t\t\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\t\t\t\tpj_free (pj);\n\t\t\t\t} else {\n\t\t\t\t\tr_anal_class_print (core->anal, class_name, true);\n\t\t\t\t}\n\t\t\t\tfree (class_name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tr_anal_class_list (core->anal, input[1]);\n\t\tbreak;\n\tcase ' ': // \"ac\"\n\tcase '-': // \"ac-\"\n\tcase 'n': { // \"acn\"\n\t\tconst char *str = r_str_trim_head_ro (input + 1);\n\t\tif (!*str) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *cstr = strdup (str);\n\t\tif (!cstr) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *end = strchr (cstr, ' ');\n\t\tif (end) {\n\t\t\t*end = '\\0';\n\t\t}\n\t\tif (input[0] == '-') {\n\t\t\tr_anal_class_delete (core->anal, cstr);\n\t\t} else if (input[0] == 'n') {\n\t\t\tif (!end) {\n\t\t\t\tR_LOG_ERROR (\"No new class name given\");\n\t\t\t} else {\n\t\t\t\tchar *new_name = end + 1;\n\t\t\t\tend = strchr (new_name, ' ');\n\t\t\t\tif (end) {\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t}\n\t\t\t\tRAnalClassErr err = r_anal_class_rename (core->anal, cstr, new_name);\n\t\t\t\tif (err == R_ANAL_CLASS_ERR_NONEXISTENT_CLASS) {\n\t\t\t\t\tR_LOG_ERROR (\"Class does not exist\");\n\t\t\t\t} else if (err == R_ANAL_CLASS_ERR_CLASH) {\n\t\t\t\t\tR_LOG_ERROR (\"A class with this name already exists\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tr_anal_class_create (core->anal, cstr);\n\t\t}\n\t\tfree (cstr);\n\t\tbreak;\n\t}\n\tcase 'v':\n\t\tcmd_anal_class_vtable (core, input + 1);\n\t\tbreak;\n\tcase 'b': // \"acb\"\n\t\tcmd_anal_class_base (core, input + 1);\n\t\tbreak;\n\tcase 'm': // \"acm\"\n\t\tcmd_anal_class_method (core, input + 1);\n\t\tbreak;\n\tcase 'g': { // \"acg\"\n\t\tRGraph *graph = r_anal_class_get_inheritance_graph (core->anal);\n\t\tif (!graph) {\n\t\t\tR_LOG_ERROR (\"Couldn't create graph\");\n\t\t\tbreak;\n\t\t}\n\t\tr_core_graph_print (core, graph, -1, false, input + 1);\n\t\tr_graph_free (graph);\n\t} break;\n\tdefault: // \"ac?\"\n\t\tr_core_cmd_help (core, help_msg_ac);\n\t\tbreak;\n\t}\n}\n\nstatic void show_reg_args(RCore *core, int nargs, RStrBuf *sb) {\n\tint i;\n\tchar regname[16];\n\tif (nargs < 0) {\n\t\tnargs = 4; // default args if not defined\n\t}\n\tfor (i = 0; i < nargs; i++) {\n\t\tsnprintf (regname, sizeof (regname), \"A%d\", i);\n\t\tut64 v = r_reg_getv (core->anal->reg, regname);\n\t\tif (sb) {\n\t\t\tr_strbuf_appendf (sb, \"%s0x%08\"PFMT64x, i? \", \": \"\", v);\n\t\t} else {\n\t\t\tr_cons_printf (\"A%d 0x%08\"PFMT64x\"\\n\", i, v);\n\t\t}\n\t}\n}\n\n// ripped from disasm.c: dupe code from there\n// TODO: Implement aC* and aCj\nstatic void cmd_anal_aC(RCore *core, const char *input) {\n\tbool is_aCer = false;\n\tconst char *cc = r_anal_cc_default (core->anal);\n\tRAnalFuncArg *arg;\n\tRListIter *iter;\n\tRListIter *nextele;\n\tconst char *iarg = strchr (input, ' ');\n\tif (input[0] == 'e' && input[1] == 'f') { // \"aCf\"\n\t\t// hacky :D\n\t\tr_core_cmdf (core, \".aCe* $$ @@=`pdr~call`\");\n\t\treturn;\n\t}\n\tif (iarg) {\n\t\tiarg++;\n\t}\n\tif (!iarg) {\n\t\tr_core_cmd_help (core, help_msg_aC);\n\t\treturn;\n\t}\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tut64 pcv = r_num_math (core->num, iarg);\n\tif (input[0] == 'e') { // \"aCe\"\n\t\tis_aCer = (input[1] == '*');\n\t\tr_core_cmdf (core, \".abpe 0x%08\"PFMT64x, pcv);\n\t}\n\tRAnalOp* op = r_core_anal_op (core, pcv, -1);\n\tif (!op) {\n\t\tr_strbuf_free (sb);\n\t\treturn;\n\t}\n\tbool go_on = true;\n\tif (op->type != R_ANAL_OP_TYPE_CALL) {\n\t\tshow_reg_args (core, -1, sb);\n\t\tgo_on = false;\n\t}\n\tconst char *fcn_name = NULL;\n\tRAnalFunction *fcn;\n\tif (go_on) {\n\t\tfcn = r_anal_get_function_at (core->anal, pcv);\n\t\tif (fcn) {\n\t\t\tfcn_name = fcn->name;\n\t\t} else {\n\t\t\tRFlagItem *item = r_flag_get_i (core->flags, op->jump);\n\t\t\tif (item) {\n\t\t\t\tfcn_name = item->name;\n\t\t\t}\n\t\t}\n\t\tchar *key = (fcn_name)? resolve_fcn_name (core->anal, fcn_name): NULL;\n\t\tif (key) {\n\t\t\tconst char *fcn_type = r_type_func_ret (core->anal->sdb_types, key);\n\t\t\tint nargs = r_type_func_args_count (core->anal->sdb_types, key);\n\t\t\t// remove other comments\n\t\t\tif (fcn_type) {\n\t\t\t\tr_strbuf_appendf (sb, \"%s%s%s(\", r_str_getf (fcn_type),\n\t\t\t\t\t\t(*fcn_type && fcn_type[strlen (fcn_type) - 1] == '*') ? \"\" : \" \",\n\t\t\t\t\t\tr_str_getf (key));\n\t\t\t\tif (!nargs) {\n\t\t\t\t\tr_strbuf_append (sb, \"void)\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot find any function signature\");\n\t\t\t}\n\t\t\tfree (key);\n\t\t} else {\n\t\t\tif (is_aCer) {\n\t\t\t\tshow_reg_args (core, -1, sb);\n\t\t\t\tgo_on = true;\n\t\t\t} else {\n\t\t\t\tshow_reg_args (core, -1, NULL);\n\t\t\t\tgo_on = false;\n\t\t\t}\n\t\t}\n\t}\n\tif (go_on) {\n\t\tut64 s_width = (core->anal->config->bits == 64)? 8: 4;\n\t\tconst char *sp = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\t\tut64 spv = r_reg_getv (core->anal->reg, sp);\n\t\tr_reg_setv (core->anal->reg, sp, spv + s_width); // temporarily set stack ptr to sync with carg.c\n\t\tRList *list = r_core_get_func_args (core, fcn_name);\n\t\tif (!r_list_empty (list)) {\n\t#if 0\n\t\t\tbool warning = false;\n\t\t\tbool on_stack = false;\n\t\t\tr_list_foreach (list, iter, arg) {\n\t\t\t\tif (r_str_startswith (arg->cc_source, \"stack\")) {\n\t\t\t\t\ton_stack = true;\n\t\t\t\t}\n\t\t\t\tif (!arg->size) {\n\t\t\t\t\tr_cons_printf (\"%s: unk_size\", arg->c_type);\n\t\t\t\t\twarning = true;\n\t\t\t\t}\n\t#endif\n\t\t\tr_list_foreach (list, iter, arg) {\n\t\t\t\tnextele = r_list_iter_get_next (iter);\n\t\t\t\tif (!arg->fmt) {\n\t\t\t\t\tr_strbuf_appendf (sb, \"?%s\", nextele? \", \": \"\");\n\t\t\t\t} else {\n\t\t\t\t\t// print_fcn_arg (core, arg->orig_c_type, arg->name, arg->fmt, arg->src, on_stack, 0);\n\t\t\t\t\t// const char *fmt = arg->orig_c_type;\n\t\t\t\t\tut64 addr = arg->src;\n\t\t\t\t\tchar *res = r_core_cmd_strf (core, \"pfq %s @ 0x%08\" PFMT64x, arg->fmt, addr);\n\t\t\t\t\t// r_cons_printf (\"pfq *%s @ 0x%08\" PFMT64x\"\\n\", arg->fmt, addr);\n\t\t\t\t\tr_str_trim (res);\n\t\t\t\t\tr_strbuf_appendf (sb, \"%s\", res);\n\t\t\t\t\tfree (res);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_strbuf_append (sb, \")\");\n\t\t} else {\n\t\t\t// function name not resolved\n\t\t\tint i, nargs = 4; // DEFAULT_NARGS;\n\t\t\tif (fcn) {\n\t\t\t\t// @TODO: fcn->nargs should be updated somewhere and used here instead\n\t\t\t\tnargs = r_anal_var_count_args (fcn);\n\t\t\t}\n\t\t\tif (nargs > 0) {\n\t\t\t\tif (fcn_name) {\n\t\t\t\t\tr_strbuf_appendf (sb, \"; %s(\", fcn_name);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (sb, \"; 0x%\"PFMT64x\"(\", pcv);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < nargs; i++) {\n\t\t\t\t\tut64 v = r_debug_arg_get (core->dbg, cc, i);\n\t\t\t\t\tr_strbuf_appendf (sb, \"%s0x%\"PFMT64x, i?\", \":\"\", v);\n\t\t\t\t}\n\t\t\t\tr_strbuf_append (sb, \")\");\n\t\t\t}\n\t\t}\n\t\tr_list_free (list);\n\t\tr_reg_setv (core->anal->reg, sp, spv); // reset stack ptr\n\t}\n\tr_anal_op_free (op);\n\tchar *s = r_strbuf_drain (sb);\n\tif (is_aCer) {\n\t\tchar *u = r_base64_encode_dyn (s, -1);\n\t\tif (u) {\n\t\t\tr_cons_printf (\"CCu base64:%s\\n\", u);\n\t\t\tfree (u);\n\t\t}\n\t} else {\n\t\tr_cons_println (s);\n\t}\n\tfree (s);\n}\n\nstatic bool core_anal_abf(RCore *core, const char* input) {\n\tif (strchr (input, '?')) {\n\t\tr_core_cmd_help_match (core, help_msg_ab, \"abf\", true);\n\t\treturn false;\n\t}\n\tut64 addr = r_num_math (core->num, input);\n\tif (!addr || addr == UT64_MAX) {\n\t\taddr = core->offset;\n\t}\n\n\tRAnalBlock *bb, *bb2;\n\tRListIter *iter, *iter2, *bbiter;\n\tRAnalFunction *fcn;\n\tRList *bbs = r_anal_get_blocks_in (core->anal, addr);\n\tr_list_foreach (bbs, bbiter, bb) {\n\t\tif (!bb) {\n\t\t\tR_LOG_ERROR (\"Cannot find basic block\");\n\t\t\treturn false;\n\t\t}\n\t\tr_list_foreach (bb->fcns, iter, fcn) {\n\t\t\tr_list_foreach (fcn->bbs, iter2, bb2) {\n\t\t\t\tif (bb == bb2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (bb2->jump != UT64_MAX && bb2->jump == bb->addr) {\n\t\t\t\t\tr_cons_printf (\"0x%\"PFMT64x\"\\n\", bb2->addr);\n\t\t\t\t}\n\t\t\t\tif (bb2->fail != UT64_MAX && bb2->fail == bb->addr) {\n\t\t\t\t\tr_cons_printf (\"0x%\"PFMT64x\"\\n\", bb2->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void match_prelude(RCore *core, const char *input) {\n\tconst ut8 *prelude = (const ut8*)\"\\xe9\\x2d\"; //:fffff000\";\n\tconst int prelude_sz = 2;\n\tconst int bufsz = 4096;\n\tut8 *buf = calloc (1, bufsz);\n\tut64 off = core->offset;\n\tif (input[1] == ' ') {\n\t\toff = r_num_math (core->num, input + 1);\n\t}\n\tr_io_read_at (core->io, off - bufsz + prelude_sz, buf, bufsz);\n\t//const char *prelude = \"\\x2d\\xe9\\xf0\\x47\"; //:fffff000\";\n\tr_mem_reverse (buf, bufsz);\n\t//r_print_hexdump (NULL, off, buf, bufsz, 16, -16);\n\tconst ut8 *pos = r_mem_mem (buf, bufsz, prelude, prelude_sz);\n\tif (pos) {\n\t\tint delta = (size_t)(pos - buf);\n\t\t// R_LOG_DEBUG (\"POS = %d\", delta);\n\t\t// R_LOG_DEBUG (\"HIT = 0x%\"PFMT64x, off - delta);\n\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", off - delta);\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot find prelude\");\n\t}\n\tfree (buf);\n}\n\nstatic int cmd_apt(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase '?':\n\t\tr_core_cmd_help_match (core, help_msg_ap, \"apt\", false);\n\t\tbreak;\n\tcase '=':\n\tcase ' ':\n\t\tr_anal_tid_select (core->anal, atoi (input + 1));\n\t\tcore->dbg->reg = core->anal->reg;\n\t\tbreak;\n\tcase '+':\n\t\t{\n\t\t\tint tid = r_anal_tid_add (core->anal, atoi (input + 1));\n\t\t\tif (tid != -1) {\n\t\t\t\tcore->anal->thread = tid;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '-':\n\t\tr_anal_tid_kill (core->anal, atoi (input + 1));\n\t\tbreak;\n\tcase 0:\n\t\t{\n\t\t\tRListIter *iter;\n\t\t\tRAnalThread *t;\n\t\t\tr_list_foreach (core->anal->threads, iter, t) {\n\t\t\t\tconst int diff = (r_time_now () - t->birth) / 1000000;\n\t\t\t\tconst char cur = (t->id == core->anal->thread)? '*': '-';\n\t\t\t\tr_cons_printf (\"%c %d map=%d age=%ds\\n\", cur, t->id, t->map, diff);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int cmd_anal(void *data, const char *input) {\n\tconst char *r;\n\tRCore *core = (RCore *)data;\n\tut32 tbs = core->blocksize;\n\tswitch (input[0]) {\n\tcase 'p': // \"ap\"\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_ap);\n\t\t\tbreak;\n\t\tcase 'l': // \"apl\"\n\t\t\t// list function preludes\n\t\t\t{\n\t\t\t\tRSearchKeyword *k;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRList *list = r_anal_preludes (core->anal);\n\t\t\t\tr_list_foreach (list, iter, k) {\n\t\t\t\t\tchar *hex0 = r_hex_bin2strdup (k->bin_keyword, k->keyword_length);\n\t\t\t\t\tchar *hex1 = r_hex_bin2strdup (k->bin_binmask, k->binmask_length);\n\t\t\t\t\t// XXX must add an align field\n\t\t\t\t\tr_cons_printf (\"ap+ %s %s\\n\", hex0, hex1);\n\t\t\t\t\tfree (hex0);\n\t\t\t\t\tfree (hex1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't': // \"apt\"\n\t\t\tcmd_apt (core, input + 2);\n\t\t\tbreak;\n\t\tcase ' ':\n\t\tcase 0:\n\t\t\tmatch_prelude (core, r_str_trim_head_ro (input));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_ap);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '8':  // \"a8\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_a8);\n\t\t\tbreak;\n\t\t}\n\t\tut8 *buf = malloc (strlen (input) + 1);\n\t\tif (buf) {\n\t\t\tint len = r_hex_str2bin (input + 1, buf);\n\t\t\tif (len > 0) {\n\t\t\t\tcore_anal_bytes (core, buf, len, 0, input[1]);\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"ab\"\n\t\tswitch (input[1]) {\n\t\tcase '.': // \"ab.\"\n\t\t\tr_core_cmd_call (core, \"ab $$\");\n\t\t\tbreak;\n\t\tcase 'a': // \"aba\"\n\t\t\tr_core_cmdf (core, \"aeab%s\", input + 1);\n\t\t\tbreak;\n\t\tcase 'b': // \"abb\"\n\t\t\tcore_anal_bbs (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'c': // \"abc\"\n\t\t\tcmd_afbc (core, r_str_trim_head_ro (input + 2));\n\t\t\tbreak;\n\t\tcase 'o': // \"abo\"\n\t\t\tabo (core);\n\t\t\tbreak;\n\t\tcase 'e': // \"aeb\"\n\t\t\tr_core_cmdf (core, \"aeb%s\", input + 2);\n\t\t\tbreak;\n\t\tcase 'f': // \"abf\"\n\t\t\tcore_anal_abf (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'r': // \"abr\"\n\t\t\tcore_anal_bbs_range (core, input + 2);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tcmd_anal_abt (core, input + 2);\n\t\t\tbreak;\n\t\tcase ',': // \"ab,\"\n\t\tcase 'p': // \"abp\"\n\t\t\tcmd_anal_abp (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'l': // \"abl\"\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_abl);\n\t\t\t} else {\n\t\t\t\tanal_bb_list (core, input + 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j': { // \"abj\"\n\t\t\tut64 addr = core->offset;\n\t\t\tif (input[2] && input[2] != '.') {\n\t\t\t\taddr = r_num_math (core->num, input + 2);\n\t\t\t}\n\t\t\tr_core_cmd_call_at (core, addr, \"afbij\");\n\t\t\tbreak;\n\t\t}\n\t\tcase '-': // \"ab-\"\n\t\t\t  if (input[2] == '*') {\n\t\t\t\t  r_anal_block_reset (core->anal);\n\t\t\t  } else {\n\t\t\t\t  ut64 addr = core->offset;\n\t\t\t\t  if (input[2] == ' ') {\n\t\t\t\t\t  addr = r_num_math (core->num, input + 1);\n\t\t\t\t  }\n\t\t\t\t  r_anal_delete_block_at (core->anal, addr);\n\t\t\t  }\n\t\t\t  break;\n\t\tcase 0:\n\t\tcase ' ': // \"ab \"\n\t\t\t{\n\t\t\t\t// find block\n\t\t\t\tut64 addr = core->offset;\n\t\t\t\tif (input[1] && input[1] != '.') {\n\t\t\t\t\taddr = r_num_math (core->num, input + 1);\n\t\t\t\t}\n\t\t\t\tr_core_cmd_call_at (core, addr, \"afbi\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_ab);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"ac\"\n\t\tcmd_anal_classes (core, input + 1);\n\t\tbreak;\n\tcase 'C': // \"aC\"\n\t\tcmd_anal_aC (core, input + 1);\n\t\tbreak;\n\tcase 'i': cmd_anal_info (core, input + 1); break; // \"ai\"\n\tcase 'r': cmd_anal_reg (core, input + 1); break;  // \"ar\"\n\tcase 'e': cmd_anal_esil (core, input + 1, true); break; // \"ae\"\n\tcase 'L':\n\t\tswitch (input[1]) {\n\t\tcase 'j':\n\t\tcase 'q':\n\t\tcase 0:\n\t\t\tranal2_list (core, NULL, input[1]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// help\n\t\t\tr_core_cmd_help (core, help_msg_La);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'o': // \"ao\"\n\t\tcmd_anal_opcode (core, input + 1);\n\t\tbreak;\n\tcase 'O': // \"aO\"\n\t\tcmd_anal_bytes (core, input + 1);\n\t\tbreak;\n\tcase 'F': // \"aF\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_aF);\n\t\t\tbreak;\n\t\t}\n\t\tr_core_anal_fcn (core, core->offset, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n\t\tbreak;\n\tcase 'l':\n\t\t{\n\t\t\tRList *l = r_asm_cpus (core->rasm);\n\t\t\tRListIter *iter;\n\t\t\tchar *c;\n\t\t\tr_list_foreach (l, iter, c) {\n\t\t\t\tr_cons_printf (\"- %s\\n\", c);\n\t\t\t}\n\t\t\tr_list_free (l);\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"af\"\n\t\tif (!cmd_af (core, input)) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase 'n': // \"an\"\n\t\t{\n\t\tconst char *name = \"\";\n\t\tint mode = 0;\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_an);\n\t\t\tmode = -1;\n\t\t\tbreak;\n\t\tcase 'j':\n\t\tcase '*':\n\t\t\tmode = input[1];\n\t\t\tinput++;\n\t\t\tbreak;\n\t\t}\n\t\tif (mode >= 0) {\n\t\t\tif (input[1] == ' ') {\n\t\t\t\tname = input + 1;\n\t\t\t\twhile (name[0] == ' ') {\n\t\t\t\t\tname++;\n\t\t\t\t}\n\t\t\t\tchar *end = strchr (name, ' ');\n\t\t\t\tif (end) {\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (R_STR_ISEMPTY (name)) {\n\t\t\t\tname = NULL;\n\t\t\t}\n\t\t\tcmd_an (core, name, mode);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'g': // \"ag\"\n\t\tcmd_anal_graph (core, input + 1);\n\t\tbreak;\n\tcase 's': // \"as\"\n\t\tcmd_anal_syscall (core, input + 1);\n\t\tbreak;\n\tcase 'v': // \"av\"\n\t\tcmd_anal_virtual_functions (core, input + 1);\n\t\tbreak;\n\tcase 'x': // \"ax\"\n\t\tif (!cmd_anal_refs (core, input + 1)) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase '*': // \"a*\"\n\t\tr_core_cmd_call (core, \"afl*\");\n\t\tr_core_cmd_call (core, \"ah*\");\n\t\tr_core_cmd_call (core, \"ax*\");\n\t\tbreak;\n\tcase 'a': // \"aa\"\n\t\tif (!cmd_anal_all (core, input + 1)) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"ad\"\n\t\tswitch (input[1]) {\n\t\tcase 'f': // \"adf\"\n\t\t\tif (input[2] == 'g') {\n\t\t\t\tanal_fcn_data_gaps (core, r_str_trim_head_ro (input + 1));\n\t\t\t} else {\n\t\t\t\tanal_fcn_data (core, input + 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't': // \"adt\"\n\t\t\tcmd_anal_trampoline (core, input + 2);\n\t\t\tbreak;\n\t\tcase '.': // \"ad.\"\n\t\tcase ' ': { // \"ad\" // asm describe maybe? see aod instead\n\t\t\tconst int default_depth = 1;\n\t\t\tconst char *p;\n\t\t\tint a, b;\n\t\t\ta = r_num_math (core->num, input + 2);\n\t\t\tp = strchr (input + 2, ' ');\n\t\t\tb = p? r_num_math (core->num, p + 1): default_depth;\n\t\t\tif (a < 1) {\n\t\t\t\ta = 1;\n\t\t\t}\n\t\t\tif (b < 1) {\n\t\t\t\tb = 1;\n\t\t\t}\n\t\t\tr_core_anal_data (core, core->offset, a, b, 0);\n\t\t} break;\n\t\tcase 'k': // \"adk\"\n\t\t\tr = r_anal_data_kind (core->anal, core->offset, core->block, core->blocksize);\n\t\t\tr_cons_println (r);\n\t\t\tbreak;\n\t\tcase '\\0': // \"ad\"\n\t\t\tr_core_anal_data (core, core->offset, 2 + (core->blocksize / 4), 1, 0);\n\t\t\tbreak;\n\t\tcase '4': // \"ad4\"\n\t\t\tr_core_anal_data (core, core->offset, 2 + (core->blocksize / 4), 1, 4);\n\t\t\tbreak;\n\t\tcase '8': // \"ad8\"\n\t\t\tr_core_anal_data (core, core->offset, 2 + (core->blocksize / 4), 1, 8);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_ad);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'h': // \"ah\"\n\t\tcmd_anal_hint (core, input + 1);\n\t\tbreak;\n\tcase ':': // \"a:\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_acolon);\n\t\t} else if (input[1] == 'l' || !input[1]) {\n\t\t\tRListIter *iter;\n\t\t\tRAnalPlugin *ap;\n\t\t\tr_list_foreach (core->anal->plugins, iter, ap) {\n\t\t\t\tr_cons_println (ap->meta.name);\n\t\t\t}\n\t\t} else {\n\t\t\tr_anal_cmd (core->anal, r_str_trim_head_ro (input + 1));\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"aj\"\n\t\tr_core_cmd_call (core, \"aflj\");\n\t\tbreak;\n\tcase 0: // \"a\"\n\t\tr_core_cmd_call (core, \"aai\");\n\t\tbreak;\n\tcase '?':\n\t\tif (input[1] == 'j') {\n\t\t\tr_cons_cmd_help_json (help_msg_a);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_a);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_a);\n\t\tbreak;\n\t}\n\tif (tbs != core->blocksize) {\n\t\tr_core_block_size (core, tbs);\n\t}\n\tif (r_cons_is_breaked ()) {\n\t\tr_cons_clear_line (1);\n\t}\n\treturn 0;\n}\n"], "fixing_code": ["/* radare2 - LGPL - Copyright 2011-2023 - pancake */\n\n#include <r_arch.h>\n\nstatic size_t countChar(const ut8 *buf, int len, char ch) {\n\tsize_t i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (buf[i] != ch) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\n\nstatic int getid(char ch) {\n\tconst char *const keys = \"[]<>+-,.\";\n\tconst char *const cidx = strchr (keys, ch);\n\treturn cidx? cidx - keys + 1: 0;\n}\n\nstatic int disassemble(RAnalOp *op, const ut8 *buf, int len) {\n\tconst ut8 *b;\n\tsize_t rep = 1;\n\n\t/* Count repetitions of the current instruction, unless it's a trap. */\n\tif (*buf != 0x00 && *buf != 0xff) {\n\t\tfor (b = &buf[1]; b < buf + len && *b == *buf; b++) {\n\t\t\trep++;\n\t\t}\n\t}\n\tconst char *buf_asm = \"invalid\";\n\tswitch (*buf) {\n\tcase '[':\n\t\tbuf_asm = \"while [ptr]\";\n\t\tbreak;\n\tcase ']':\n\t\tbuf_asm = \"loop\";\n\t\tbreak;\n\tcase '>':\n\t\tbuf_asm = (rep > 1)? \"add ptr\": \"inc ptr\";\n\t\tbreak;\n\tcase '<':\n\t\tbuf_asm = (rep > 1)? \"sub ptr\": \"dec ptr\";\n\t\tbreak;\n\tcase '+':\n\t\tbuf_asm = (rep > 1)? \"add [ptr]\": \"inc [ptr]\";\n\t\tbreak;\n\tcase '-':\n\t\tbuf_asm = (rep > 1)? \"sub [ptr]\": \"dec [ptr]\";\n\t\tbreak;\n\tcase ',':\n\t\tbuf_asm = \"in [ptr]\";\n\t\tbreak;\n\tcase '.':\n\t\tbuf_asm = \"out [ptr]\";\n\t\tbreak;\n\tcase 0xff:\n\tcase 0x00:\n\t\tbuf_asm = \"trap\";\n\t\tbreak;\n\tdefault:\n\t\tbuf_asm = \"nop\";\n\t\tbreak;\n\t}\n\n\tchar buf_asm_local[256];\n\tif (rep > 1) {\n\t\t/* Note: snprintf's source and destination buffers may not overlap. */\n\t\tconst char *fmt = strchr (buf_asm, ' ')? \"%s, %d\": \"%s %d\";\n\t\tsnprintf (buf_asm_local, sizeof (buf_asm_local), fmt, buf_asm, rep);\n\t\tbuf_asm = buf_asm_local;\n\t}\n\top->mnemonic = strdup (buf_asm);\n\top->size = rep;\n\treturn rep;\n}\n\nstatic void _write_asm(ut8 *outbuf, size_t outbufsz, int value, int n) {\n\tmemset (outbuf, value, R_MIN (n, outbufsz));\n}\n\nstatic int assemble(const char *buf, ut8 **outbuf) {\n\tint n = 0;\n\tif (buf[0] && buf[1] == ' ') {\n\t\tbuf += 2;\n\t}\n\tconst char *arg = strchr (buf, ',');\n\tconst char *ref = strchr (buf, '[');\n\tif (arg) {\n\t\tn = atoi (arg + 1);\n\t} else {\n\t\tn = 1;\n\t}\n\n\tsize_t outbufsz = n;\n\t*outbuf = malloc (outbufsz);\n\tif (!(*outbuf)) {\n\t\treturn 0;\n\t}\n\n\tif (r_str_startswith (buf, \"trap\")) {\n\t\t_write_asm (*outbuf, outbufsz, 0xcc, n);\n\t} else if (r_str_startswith (buf, \"nop\")) {\n\t\t_write_asm (*outbuf, outbufsz, 0x90, n);\n\t} else if (r_str_startswith (buf, \"inc\")) {\n\t\tchar ch = ref? '+': '>';\n\t\tn = 1;\n\t\t_write_asm (*outbuf, outbufsz, ch, n);\n\t} else if (r_str_startswith (buf, \"dec\")) {\n\t\tchar ch = ref? '-': '<';\n\t\tn = 1;\n\t\t_write_asm (*outbuf, outbufsz, ch, n);\n\t} else if (r_str_startswith (buf, \"sub\")) {\n\t\tchar ch = ref? '-': '<';\n\t\t_write_asm (*outbuf, outbufsz, ch, n);\n\t} else if (r_str_startswith (buf, \"add\")) {\n\t\tchar ch = ref? '+': '>';\n\t\t_write_asm (*outbuf, outbufsz, ch, n);\n\t} else if (r_str_startswith (buf, \"while\")) {\n\t\tn = 1;\n\t\t_write_asm (*outbuf, outbufsz, '[', 1);\n\t} else if (r_str_startswith (buf, \"loop\")) {\n\t\tn = 1;\n\t\t_write_asm (*outbuf, outbufsz, ']', 1);\n\t} else if (r_str_startswith (buf, \"in\")) {\n\t\t_write_asm (*outbuf, outbufsz, ',', n);\n\t} else if (r_str_startswith (buf, \"out\")) {\n\t\t_write_asm (*outbuf, outbufsz, '.', n);\n\t} else {\n\t\tR_FREE (*outbuf);\n\t\tn = 0;\n\t}\n\treturn n;\n}\n\n#define BUFSIZE_INC 32\nstatic bool decode(RArchSession *as, RAnalOp *op, RArchDecodeMask mask) {\n\tint len = op->size;\n\tif (len < 1) {\n\t\treturn false;\n\t}\n\tut8 *buf = op->bytes;\n\tconst ut64 addr = op->addr;\n\tut64 dst = 0LL;\n\tif (!op) {\n\t\treturn 1;\n\t}\n\tif (mask & R_ARCH_OP_MASK_DISASM) {\n\t\t(void) disassemble (op, buf, len);\n\t}\n\tr_strbuf_init (&op->esil);\n\top->size = 1;\n\top->id = getid (buf[0]);\n\tswitch (buf[0]) {\n\tcase '[':\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t// read ahead to find the ] bracket\n\t\top->jump = dst;\n\t\top->fail = addr + 1;\n\t\tRArch *a = as->arch;\n\t\tRIOReadAt read_at = NULL;\n\t\tRBin *bin = R_UNWRAP2 (a, binb.bin);\n\t\tif (bin && bin->iob.read_at) {\n\t\t\tRIOReadAt read_at = bin->iob.read_at;\n\t\t\tbuf = malloc (0xff);\n\t\t\tread_at (bin->iob.io, op->addr, buf, 0xff);\n\t\t}\n\t\tr_strbuf_set (&op->esil, \"1,pc,-,brk,=[4],4,brk,+=\");\n#if 1\n\t\tif (len > 1) {\n\t\t\tconst ut8 *p = buf + 1;\n\t\t\tint lev = 0, i = 1;\n\t\t\tlen--;\n\t\t\twhile (i < len && *p) {\n\t\t\t\tswitch (*p) {\n\t\t\t\tcase '[':\n\t\t\t\t\tlev++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ']':\n\t\t\t\t\tlev--;\n\t\t\t\t\tif (lev < 1) {\n\t\t\t\t\t\tsize_t delta = p - buf;\n\t\t\t\t\t\tdst = addr + (size_t)delta + 1;\n\t\t\t\t\t\top->jump = dst;\n\t\t\t\t\t\tr_strbuf_set (&op->esil, \"1,pc,-,brk,=[4],4,brk,+=,\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\tcase 0xff:\n\t\t\t\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (read_at && i == len - 1) {\n#if 0\n\t\t\t\t\t// XXX unnecessary just break\n\t\t\t\t\tint new_buf_len = len + 1 + BUFSIZE_INC;\n\t\t\t\t\tut8 *new_buf = calloc (new_buf_len, 1);\n\t\t\t\t\tif (new_buf) {\n\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t\tmemcpy (new_buf, op->bytes, new_buf_len);\n\t\t\t\t\t\tbuf = new_buf;\n\t\t\t\t\t\tread_at (bin->iob.io, op->addr + i, buf + i, 0xff);\n\t\t\t\t\t\tp = buf + i;\n\t\t\t\t\t\tlen += BUFSIZE_INC;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\nbeach:\n\t\tfree (buf);\n#endif\n\t\tbreak;\n\tcase ']':\n\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\tr_strbuf_set (&op->esil, \"4,brk,-=,ptr,[1],?{,brk,[4],pc,=,}\");\n\t\tbreak;\n\tcase '>':\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\top->size = countChar (buf, len, '>');\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,+=\", op->size);\n\t\tbreak;\n\tcase '<':\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\top->size = countChar (buf, len, '<');\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,-=\", op->size);\n\t\tbreak;\n\tcase '+':\n\t\top->size = countChar (buf, len, '+');\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,+=[1]\", op->size);\n\t\tbreak;\n\tcase '-':\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\top->size = countChar (buf, len, '-');\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,-=[1]\", op->size);\n\t\tbreak;\n\tcase '.':\n\t\t// print element in stack to screen\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\tr_strbuf_set (&op->esil, \"ptr,[1],scr,=[1],1,scr,+=\");\n\t\tbreak;\n\tcase ',':\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\tr_strbuf_set (&op->esil, \"kbd,[1],ptr,=[1],1,kbd,+=\");\n\t\tbreak;\n\tcase 0x00:\n\tcase 0xff:\n\t\top->type = R_ANAL_OP_TYPE_TRAP;\n\t\tbreak;\n\tdefault:\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\tr_strbuf_set (&op->esil, \",\");\n\t\tbreak;\n\t}\n\treturn op->size;\n}\n\nstatic char *regs(RArchSession *as) {\n\tif (as->config->bits == 8) {\n\t\treturn strdup (\n\t\t\"=PC\tpc\\n\"\n\t\t\"=BP\tbrk\\n\"\n\t\t\"=SP\tptr\\n\"\n\t\t\"=A0\ttmp\\n\"\n\t\t\"=A1\ttmp\\n\"\n\t\t\"=A2\ttmp\\n\"\n\t\t\"=A3\ttmp\\n\"\n\t\t\"gpr\tptr\t.8\t0\t0\\n\" // data pointer\n\t\t\"gpr\tpc\t.8\t4\t0\\n\" // program counter\n\t\t\"gpr\tbrk\t.8\t8\t0\\n\" // brackets\n\t\t\"gpr\tscr\t.32\t12\t0\\n\" // screen\n\t\t\"gpr\tkbd\t.32\t16\t0\\n\" // keyboard\n\t\t\"gpr\ttmp\t.32\t20\t0\\n\" // keyboard\n\t\t);\n\t}\n\treturn strdup (\n\t\t\"=PC\tpc\\n\"\n\t\t\"=BP\tbrk\\n\"\n\t\t\"=SP\tptr\\n\"\n\t\t\"=A0\tptr\\n\"\n\t\t\"=A1\tptr\\n\"\n\t\t\"=A2\tptr\\n\"\n\t\t\"=A3\tptr\\n\"\n\t\t\"gpr\tptr\t.32\t0\t0\\n\" // data pointer\n\t\t\"gpr\tpc\t.32\t4\t0\\n\" // program counter\n\t\t\"gpr\tbrk\t.32\t8\t0\\n\" // brackets\n\t\t\"gpr\tscr\t.32\t12\t0\\n\" // screen\n\t\t\"gpr\tkbd\t.32\t16\t0\\n\" // keyboard\n\t);\n}\n\nstatic bool encode(RArchSession *as, RAnalOp *op, RArchEncodeMask mask) {\n\tut8 *outbuf = NULL;\n\tint size = assemble (op->mnemonic, &outbuf);\n\tfree (op->bytes);\n\top->bytes = outbuf;\n\top->size = size;\n\treturn size > 0;\n}\n\nstatic int archinfo(RArchSession *as, ut32 q) {\n\tswitch (q) {\n\tcase R_ANAL_ARCHINFO_MAX_OP_SIZE:\n\t\treturn 0xff;\n\t\t// return 32;\n\t}\n\treturn 1;\n}\n\nconst RArchPlugin r_arch_plugin_bf = {\n\t.meta = {\n\t\t.name = \"bf\",\n\t\t.desc = \"brainfuck code analysis plugin\",\n\t\t.license = \"LGPL3\",\n\t},\n\t.arch = \"bf\",\n\t.bits = R_SYS_BITS_PACK (32),\n\t.endian = R_SYS_ENDIAN_NONE,\n\t.decode = &decode,\n\t.encode = &encode,\n\t.regs = regs,\n\t.info = &archinfo\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ARCH,\n\t.data = &r_arch_plugin_bf,\n\t.version = R2_VERSION\n};\n#endif\n", "/* radare - LGPL - Copyright 2009-2023 - pancake, maijin */\n\n#include <r_core.h>\n\n#define MAX_SCAN_SIZE 0x7ffffff\n\nR_VEC_TYPE(RVecUT64, ut64);\n\nstatic RCoreHelpMessage help_msg_af_plus = {\n\t\"Usage:\", \"af+\", \" [addr] ([name] ([type] [diff]))\",\n\t\"af+\", \"$$\", \"add a raw function element. See afb+ to add basic blocks to it\",\n\t\"af+\", \"$$ main\", \"add new function in current offset with 'main' as name\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aex = {\n\t\"Usage:\", \"aex\", \"[a] [9090]\",\n\t\"aex\", \" 90\", \"decode the given hexpairs and execute them\",\n\t\"aexa\", \" mov rax, 33\", \"assemble instruction and execute it\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_a = {\n\t\"Usage:\", \"a\", \"[abdefFghoprxstc] [...]\",\n\t\"a\", \"\", \"alias for aai - analysis information\",\n\t\"a:\", \"[cmd]\", \"run a command implemented by an analysis plugin (like : for io)\",\n\t\"a*\", \"\", \"same as afl*;ah*;ax*\",\n\t\"aa\", \"[?]\", \"analyze all (fcns + bbs) (aa0 to avoid sub renaming)\",\n\t\"a8\", \" [hexpairs]\", \"analyze bytes\",\n\t\"ab\", \"[?]\", \"analyze basic block\",\n\t\"ac\", \"[?]\", \"manage classes\",\n\t\"aC\", \"[?]\", \"analyze function call\",\n\t\"ad\", \"[?]\", \"analyze data trampoline (wip) (see 'aod' to describe mnemonics)\", // XXX rename to at?\n\t\"ad\", \" [from] [to]\", \"analyze data pointers to (from-to)\",\n\t\"ae\", \"[?] [expr]\", \"analyze opcode eval expression (see ao)\",\n\t\"af\", \"[?]\", \"analyze functions\",\n\t\"aF\", \"\", \"same as above, but using anal.depth=1\",\n\t\"ag\", \"[?] [options]\", \"draw graphs in various formats\",\n\t\"ah\", \"[?]\", \"analysis hints (force opcode size, ...)\",\n\t\"ai\", \" [addr]\", \"address information (show perms, stack, heap, ...)\",\n\t\"aj\", \"\", \"same as a* but in json (aflj)\",\n\t\"aL\", \"[jq]\", \"list all asm/anal plugins (See `e asm.arch=?` and `La[jq]`)\",\n\t\"an\", \"[?] [name]\", \"show/rename/create whatever var/flag/function used in current instruction\",\n\t\"ao\", \"[?] [len]\", \"analyze Opcodes (or emulate it)\",\n\t\"aO\", \"[?] [len]\", \"analyze N instructions in M bytes\",\n\t\"ap\", \"\", \"find prelude for current offset\",\n\t\"ar\", \"[?]\", \"like 'dr' but for the esil vm. (registers)\",\n\t\"as\", \"[?] [num]\", \"analyze syscall using dbg.reg\",\n\t\"av\", \"[?] [.]\", \"show vtables\",\n\t\"avg\", \"[?] [.]\", \"manage global variables\",\n\t\"ax\", \"[?]\", \"manage refs/xrefs (see also afx?)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afna = {\n\t\"Usage:\", \"afna\", \" # construct a function name and rename the function for the current offset.\",\n\t\"\", \"\", \"Based on flags or methods calls found inside that function.\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afu = {\n\t\"Usage:\", \"afu\", \"[addr]   # resize and analyze function from current address until addr.\",\n\t\"afu\", \" 0x100004093\", \"resize and analyze function from current address until 0x100004093\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aae = {\n\t\"Usage:\", \"aae\", \"[pf] ([addr]) # analyze all kind of stuff using esil\",\n\t\"aaep\", \"\", \"same as aepa@@@i - define anal pins by import flag names\",\n\t\"aaep\", \"a\", \"run 'aep ret0@@@i' and then 'aaep' - all unknown imports are faked to return 0\",\n\t\"aaef\", \"\", \"emulate all functions using esil to find out computed references (same as aef@@@F)\",\n\t\"aae\", \" [size] ([addr])\", \"same as aepa@@@i - define anal pins by import flag names\",\n\t\"aae\", \"\", \"honor anal.{in,from,to} and emulate all executable regions\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aav = {\n\t\"Usage:\", \"aav\", \"[sat] # find values referencing a specific section or map\",\n\t\"aav\", \"\", \"find absolute reference values\",\n\t\"aavr\", \"\", \"find relative reference values (address + 4 byte signed int)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aan = {\n\t\"Usage:\", \"aan\", \"[rg]   # automatically name functions.\",\n\t\"aan\", \"\", \"autoname all functions\",\n\t\"aang\", \"\", \"autoname all golang functions\",\n\t\"aanr\", \"\", \"auto-noreturn propagation\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afm = {\n\t\"Usage:\", \"afm\", \"[name]   # merge two functions.\",\n\t\"afm\", \" sym.func.100003d74\", \"merge current function into 0x100003d74\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aF = {\n\t\"Usage:\", \"aF\", \" # analyze a function, but using anal.depth=1\",\n\t\"aF\", \"\", \"check af? for more options and information.\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_an = {\n\t\"Usage:\", \"an\", \" # analyze name for the current address\",\n\t\"an\", \"\", \"show flag/function/symbol name\",\n\t\"an*\", \"\", \"same as above but in r2 commands\",\n\t\"anj\", \"\", \"same as above but in json\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_a8 = {\n\t\"Usage:\", \"a8\", \"[hexpairs]   # analyze the byte array given as input\",\n\t\"a8 \", \"5548\", \"analyzes 5548 byte array\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ap = {\n\t\"Usage:\", \"ap[?]\", \" # analyze prelude in current offset\",\n\t\"ap\", \"\", \"check if current offset contains a function prelude\",\n\t\"apl\", \"\", \"list available function preludes defined by the arch plugin\",\n\t// \"ap+\", \"bytes:mask:align\", \"add a new function prelude\",\n\t\"apt\", \"\", \"analysis process-thread (like dpt for esil), list threads\",\n\t\"apt \", \"[id]\", \"select a thread (change register profile and TLS map\",\n\t\"apt+\", \"[map]\", \"create a thread with given TLS mapid and prints the new thread id\",\n\t\"apt-\", \"[id]\", \"delete a thread by id\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_avg = {\n\t\"Usage:\", \"avg\", \" # analyze variable global\",\n\t\"avg\", \"\", \"use ESIL emulation to find out arguments of a call (uses 'abte')\",\n\t\"avg\", \" [type] [name]\", \"add global\",\n\t\"avg-\", \"\", \"delete global\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aC = {\n\t\"Usage:\", \"aC[fej] [addr-of-call]\", \" # analyze call args\",\n\t\"aCe\", \"\", \"use ESIL emulation to find out arguments of a call (uses 'abte')\",\n\t\"aCf\", \"\", \"same as .aCe* $$ @@=`pdr~call`\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aaf = {\n\t\"Usage:\", \"aaf[efrt?]\", \" # analyse all functionsee also 'af' and 'afna'\",\n\t\"aaf\", \"\", \"same as afr@@c:isq\",\n\t\"aafe\", \" \", \"same as aef@@F\",\n\t\"aaff\", \"\", \"set a flag for every function\",\n\t\"aafr\", \" [len]\", \"consecutive function analysis (e anal.hasnext=1;afr@@c:isq)\",\n\t\"aaft\", \"\", \"recursive type matching across all functions\",\n\t\"aafs\", \"\", \"single basic block function analysis\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aaa = {\n\t\"Usage:\", \"aa[a[a[a]]]\", \" # automatically analyze the whole program\",\n\t\"a\", \" \", \"show code analysis statistics\",\n\t\"aa\", \" \", \"alias for 'af@@ sym.*;af@entry0;afva'\",\n\t\"aaa\", \"\", \"perform deeper analysis, most common use\",\n\t\"aaaa\", \"\", \"same as aaa but adds a bunch of experimental iterations\",\n\t\"aaaaa\", \"\", \"refine the analysis to find more functions after aaaa\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aa = {\n\t\"Usage:\", \"aa[0*?]\", \" # see also 'af' and 'afna'\",\n\t\"aa\", \" \", \"alias for 'af@@ sym.*;af@entry0;afva'\", //;.afna @@ fcn.*'\",\n\t\"aaa\", \"[?]\", \"autoname functions after aa (see afna)\",\n\t\"aab\", \"\", \"abb across bin.sections.rx\",\n\t\"aac\", \" [len]\", \"analyze function calls (af @@ `pi len~call[1]`)\",\n\t\"aac*\", \" [len]\", \"flag function calls without performing a complete analysis\",\n\t\"aaci\", \"\", \"flag import xrefs only\",\n\t\"aad\", \" [len]\", \"analyze data references to code\",\n\t\"aae\", \"[?] [len] ([addr])\", \"analyze references with ESIL (optionally to address)\",\n\t\"aaef\", \"\", \"analyze references with ESIL in all functions\",\n\t\"aaf\", \"[?][efrt] \", \"analyze all functions relationships with flags, type matching and consecutive\",\n\t\"aaF\", \" [sym*]\", \"set anal.in=block for all the spaces between flags matching glob\",\n\t\"aaFa\", \" [sym*]\", \"same as aaF but uses af/a2f instead of af+/afb+ (slower but more accurate)\",\n\t\"aai\", \"[j]\", \"show info of all analysis parameters\",\n\t\"aaj\", \" \", \"analyze all jumps\",\n\t\"aan\", \"[?][fgr]\", \"autoname functions (aang = golang, aanr = noreturn propagation, aanf = afna@@F)\",\n\t\"aao\", \"\", \"analyze all objc references\",\n\t\"aap\", \"\", \"find and analyze function preludes\",\n\t\"aar\", \"[?] [len]\", \"analyze len bytes of instructions for references\",\n\t\"aas\", \" [len]\", \"analyze symbols (af @@= `isq~[0]`)\",\n\t\"aaS\", \"\", \"analyze all flags starting with sym. (af @@ sym.*)\",\n\t\"aat\", \" [fcn]\", \"analyze all/given function to convert immediate to linked structure offsets (see tl?)\",\n\t\"aaT\", \" [len]\", \"analyze code after trap-sleds\",\n\t\"aau\", \" [len]\", \"list mem areas (larger than len bytes) not covered by functions\",\n\t\"aav\", \"[?] [sat]\", \"find values referencing a specific section or map\",\n\t\"aaw\", \"\", \"analyze all meta words (Cd) and add r. named flags for referenced pointers\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afls = {\n\t\"Usage:\", \"afls\", \"[afls] # sort function list\",\n\t\"afls\", \"\", \"same as aflsa\",\n\t\"aflsa\", \"\", \"sort by address (same as afls)\",\n\t\"aflss\", \"\", \"sort by size\",\n\t\"aflsn\", \"\", \"sort by name\",\n\t\"aflsb\", \"\", \"sort by number of basic blocks\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aflx = {\n\t\"Usage:\", \"aflx\", \"[jv*] # list function xrefs\",\n\t\"aflx\", \"\", \"list function xrefs (who references or calls the current function)\",\n\t\"aflxj\", \"\", \"list function xrefs in JSON format\",\n\t\"aflxv\", \"\", \"list function xrefs with names\",\n\t\"aflx*\", \"\", \"list function xrefs in radare commands format\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ai = {\n\t\"Usage:\", \"ai\", \"[j*] [sz] # analysis/address information/imports\",\n\t\"ai\", \" @addr\", \"show address information\",\n\t\"aia\", \"\", \"show architecture specific information instruction size and alignment details\",\n\t\"aii\", \" [namespace]\", \"global import (like afii, but global)\",\n\t\"aii\", \"-\", \"delete all global imports\",\n\t\"aij\", \" @addr\", \"show address information in JSON format\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aar = {\n\t\"Usage:\", \"aar\", \"[j*] [sz] # search and analyze xrefs\",\n\t\"aar\", \"\", \"analyze xrefs in current section \",\n\t\"aar\", \" [sz]\", \"analyze xrefs starting in current offset until sz bytes are consumed\",\n\t\"aarr\", \"\", \"analyze all function reference graph to find more functions (EXPERIMENTAL)\",\n\t\"aar*\", \" [sz]\", \"list found xrefs in radare commands format\",\n\t\"aarj\", \" [sz]\", \"list found xrefs in JSON format\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ab = {\n\t\"Usage:\", \"ab\", \"# analyze basic block\",\n\t\"ab\", \" [addr]\", \"show basic block information at given address\",\n\t\"ab-\", \"[addr]\", \"delete basic block at given address\",\n\t\"ab.\", \"\", \"same as: ab $$\",\n\t\"aba\", \" [addr]\", \"analyze esil accesses in basic block (see aea?)\",\n\t\"abb\", \" [length]\", \"analyze N bytes and extract basic blocks\",\n\t\"abc\", \"[-] [color]\", \"change color of the current basic block (same as afbc, abc- to unset)\",\n\t\"abe\", \" [addr]\", \"emulate basic block (alias for aeb)\",\n\t\"abf\", \" [addr]\", \"address of incoming (from) basic blocks\",\n\t\"abi\", \"\", \"same as ab. or ab\",\n\t\"abj\", \" [addr]\", \"display basic block information in JSON\",\n\t\"abl\", \"[?] [.-cqj]\", \"list all basic blocks\",\n\t\"abo\", \"\", \"list opcode offsets of current basic block\",\n\t\"abp\", \"[?] [addr] [num]\", \"follow basic blocks paths from current offset to addr\",\n\t\"abt\", \"[tag] ([color])\", \"trace tags are bitfields, 0 means nontraced, withuot arguments show current value\",\n\t\"abx\", \" [hexpair-bytes]\", \"analyze N bytes\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_abl = {\n\t\"Usage:\", \"abl\", \"analyzed basicblocks listing\",\n\t\"abl\", \"\", \"list all program-wide basic blocks analyzed\",\n\t\"abl,\", \" [table-query]\", \"render the list using a table\",\n\t\"ablc\", \"\", \"count how many basic blocks are registered\",\n\t\"ablj\", \"\", \"in json format\",\n\t\"ablq\", \"\", \"in quiet format\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_abp = {\n\t\"Usage:\", \"abp\", \"[addr] [num] # find num paths from current offset to addr\",\n\t\"abp\", \" [addr] [num]\", \"find num paths from current offset to addr\",\n\t\"abpe\", \" [addr]\", \"emulate from beginning of function to the given address\",\n\t\"abpj\", \" [addr] [num]\", \"display paths in JSON\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ac = {\n\t\"Usage:\", \"ac\", \"anal classes commands\",\n\t\"acl\", \"[j*]\", \"list all classes\",\n\t\"acll\", \"[j] (class_name)\", \"list all or single class detailed\",\n\t\"ac\", \" [class name]\", \"add class\",\n\t\"ac-\", \" [class name]\", \"delete class\",\n\t\"acn\", \" [class name] [new class name]\", \"rename class\",\n\t\"acv\", \" [class name] [addr] ([offset]) ([size])\", \"add vtable address to class\",\n\t\"acvf\", \" [offset] ([class name])\", \"lookup function address on vtable offset\",\n\t\"acv-\", \" [class name] [vtable id]\", \"delete vtable by id (from acv [class name])\",\n\t\"acb\", \" [class name]\", \"list bases of class\",\n\t\"acb\", \" [class name] [base class name] ([offset])\", \"add base class\",\n\t\"acb-\", \" [class name] [base class id]\", \"delete base by id (from acb [class name])\",\n\t\"acm\", \" [class name] [method name] [offset] ([vtable offset])\", \"add/edit method\",\n\t\"acm-\", \" [class name] [method name]\", \"delete method\",\n\t\"acmn\", \" [class name] [method name] [new name]\", \"rename method\",\n\t\"acg\", \"\", \"print inheritance ascii graph\",\n\t\"ac?\", \"\", \"show this help\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_acolon = {\n\t\"Usage:\", \"a:\", \"[plugin-command]\",\n\t\"a:\", \"\", \"list the analysis plugins\",\n\t\"a:\", \"a2f\", \"run the command associated with the 'a2f' analysis plugin\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ad = {\n\t\"Usage:\", \"ad\", \"[kt] [...]\",\n\t\"ad\", \" [N] [D]\", \"analyze N data words at D depth\",\n\t\"ad4\", \" [N] [D]\", \"analyze N data words at D depth (asm.bits=32)\",\n\t\"ad8\", \" [N] [D]\", \"analyze N data words at D depth (asm.bits=64)\",\n\t\"adf\", \"\", \"analyze data in function (use like .adf @@=`afl~[0]`\",\n\t\"adfg\", \"\", \"analyze data in function gaps\",\n\t\"adt\", \"\", \"analyze data trampolines (wip)\",\n\t\"adk\", \"\", \"analyze data kind (code, text, data, invalid, ...)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aes = {\n\t\"Usage:\", \"aes[pbosu]\", \"esil stepping utilities\",\n\t\"aesp\", \" [X] [N]\", \"evaluate N instr from offset X\",\n\t\"aesb\", \"\", \"step back\",\n\t\"aeso\", \" \", \"step over\",\n\t\"aesou\", \" [addr]\", \"step over until given address\",\n\t\"aess\", \" \", \"step skip (in case of CALL, just skip, instead of step into)\",\n\t\"aesu\", \" [addr]\", \"step until given address\",\n\t\"aesue\", \" [esil]\", \"step until esil expression match\",\n\t\"aesuo\", \" [optype]\", \"step until given opcode type\",\n\t\"aesB\", \" [addr] [N] @ [from-addr]\", \"step over every N instructions\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aei = {\n\t\"Usage:\", \"aei\", \"[smp] [...]\",\n\t\"aei\", \"\", \"initialize ESIL VM state (aei- to deinitialize)\",\n\t\"aeis\", \" argc [argv] [envp]\", \"initialize entrypoint stack environment\",\n\t\"aeim\", \" [addr] [size] [name]\", \"initialize ESIL VM stack (aeim- remove)\",\n\t\"aeip\", \"\", \"initialize ESIL program counter to curseek\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ae = {\n\t\"Usage:\", \"ae[idesr?] [arg]\", \"ESIL code emulation\",\n\t\"ae\", \" [expr]\", \"evaluate ESIL expression\",\n\t\"ae?\", \"\", \"show this help\",\n\t\"ae??\", \"\", \"show ESIL help\",\n\t\"aea\", \"[f] [count]\", \"analyse n esil instructions accesses (regs, mem..)\",\n\t\"aeA\", \"[f] [count]\", \"analyse n bytes for their esil accesses (regs, mem..)\",\n\t\"aeb\", \" ([addr])\", \"emulate block in current or given address\",\n\t\"aeC\", \"[arg0 arg1..] @ addr\", \"appcall in esil\",\n\t\"aec\", \"[?]\", \"continue until ^C\",\n\t\"aef\", \" [addr]\", \"emulate function\",\n\t\"aefa\", \" [addr]\", \"emulate function to find out args in given or current offset\",\n\t\"aeg\", \" [expr]\", \"esil data flow graph\",\n\t\"aegf\", \" [expr] [register]\", \"esil data flow graph filter\",\n\t\"aei\", \"[?]\", \"initialize ESIL VM state (aei- to deinitialize)\",\n\t\"aek\", \"[?] [query]\", \"perform sdb query on ESIL.info\",\n\t\"aeL\", \"[?][-] [name]\", \"list ESIL plugins\",\n\t\"aep\", \"[?] [addr]\", \"manage esil pin hooks (see 'e cmd.esil.pin')\",\n\t\"aepc\", \" [addr]\", \"change esil PC to this address\",\n\t\"aer\", \"[?] [..]\", \"handle ESIL registers like 'ar' or 'dr' does\",\n\t\"aes\", \"[?]\", \"perform emulated debugger step\",\n\t\"aet\", \"[?][s]\", \"esil trace listing and session management (requires aeim)\",\n\t\"aev\", \" [esil]\", \"visual esil debugger for the given expression or current instruction\",\n\t\"aex\", \" [hex]\", \"evaluate opcode expression\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_detail_ae = {\n\t\"Examples:\", \"ESIL\", \" examples and documentation\",\n\t\"=\", \"\", \"assign updating internal flags\",\n\t\":=\", \"\", \"assign without updating internal flags\",\n\t\"+=\", \"\", \"a+=b => b,a,+=\",\n\t\"/\", \"\", \"division\",\n\t\"*\", \"\", \"multiply\",\n\t\"*=\", \"\", \"multiply and assign a *= b\",\n\t\"L*\", \"\", \"long multiply\",\n\t\"+\", \"\", \"a=a+b => b,a,+,a,=\",\n\t\"++\", \"\", \"increment, 2,a,++ == 3 (see rsi,--=[1], ... )\",\n\t\"--\", \"\", \"decrement, 2,a,-- == 1\",\n\t\"*=\", \"\", \"a*=b => b,a,*=\",\n\t\"/=\", \"\", \"a/=b => b,a,/=\",\n\t\"%\", \"\", \"module\",\n\t\"%=\", \"\", \"a%=b => b,a,%=\",\n\t\"&=\", \"\", \"and ax, bx => bx,ax,&=\",\n\t\"^\", \"\", \"xor\",\n\t\"&\", \"\", \"and\",\n\t\"|\", \"\", \"or r0, r1, r2 => r2,r1,|,r0,=\",\n\t\"!=\", \"\", \"negate all bits\",\n\t\"^=\", \"\", \"xor ax, bx => bx,ax,^=\",\n\t\"\", \"[]\", \"mov eax,[eax] => eax,[],eax,=\",\n\t\"=\", \"[]\", \"mov [eax+3], 1 => 1,3,eax,+,=[]\",\n\t\"=\", \"[1]\", \"mov byte[eax],1 => 1,eax,=[1]\",\n\t\"=\", \"[8]\", \"mov [rax],1 => 1,rax,=[8]\",\n\t\"()\", \"\", \"execute an esil syscall\",\n\t\"[]\", \"\", \"peek from random position\",\n\t\"[N]\", \"\", \"peek word of N bytes from popped address\",\n\t\"[*]\", \"\", \"peek some from random position\",\n\t\"=\", \"[*]\", \"poke some at random position\",\n\t\"$\", \"\", \"int 0x80 => 0x80,$\",\n\t\"$$\", \"\", \"simulate a hardware trap\",\n\t\"==\", \"\", \"pops twice, compare and update esil flags\",\n\t\"<\", \"\", \"compare for smaller\",\n\t\"<=\", \"\", \"compare for smaller or equal\",\n\t\">\", \"\", \"compare for bigger\",\n\t\">=\", \"\", \"compare bigger for or equal\",\n\t\">>=\", \"\", \"shr ax, bx => bx,ax,>>=  # shift right\",\n\t\"<<=\", \"\", \"shl ax, bx => bx,ax,<<=  # shift left\",\n\t\">>>=\", \"\", \"ror ax, bx => bx,ax,>>>=  # rotate right\",\n\t\"<<<=\", \"\", \"rol ax, bx => bx,ax,<<<=  # rotate left\",\n\t\"?{\", \"\", \"if popped value != 0 run the block until }\",\n\t\"}{\", \"\", \"else block\",\n\t\"}\", \"\", \"end of conditional block\",\n\t\"NAN\", \"\", \"checks if result in stack is not a number\",\n\t\"I2D\", \"\", \"signed to double\",\n\t// \"S2D\", \"\", \"signed to double\",\n\t\"U2D\", \"\", \"unsigned to double\",\n\t\"D2I\", \"\", \"double to signed\",\n\t\"D2U\", \"\", \"double to unsigned\",\n\t\"F==\", \"\", \"float comparison\",\n\t\"CEIL\", \"\", \"float ceil\",\n\t\"FLOOR\", \"\", \"float floor\",\n\t\"ROUND\", \"\", \"float round\",\n\t\"SQRT\", \"\", \"float square root\",\n\t\"POP\", \"\", \"drops last element in the esil stack\",\n\t\"DUP\", \"\", \"duplicate last value in stack\",\n\t\"NUM\", \"\", \"evaluate last item in stack to number\",\n\t\"SWAP\", \"\", \"swap last two values in stack\",\n\t\"TRAP\", \"\", \"stop execution\",\n\t\"BITS\", \"\", \"16,BITS  # change bits, useful for arm/thumb\",\n\t\"TODO\", \"\", \"the instruction is not yet esilized\",\n\t\"STACK\", \"\", \"show contents of stack\",\n\t\"CLEAR\", \"\", \"clears the esil stack\",\n\t\"REPEAT\", \"\", \"repeat n times\",\n\t\"BREAK\", \"\", \"terminates the string parsing\",\n\t\"SETJT\", \"\", \"set jump target\",\n\t\"SETJTS\", \"\", \"set jump target set\",\n\t\"SETD\", \"\", \"set delay slot\",\n\t\"GOTO\", \"\", \"jump to the Nth word popped from the stack\",\n\t\"$\", \"\", \"esil interrupt\",\n\t\"$z\", \"\", \"internal flag: zero\",\n\t\"$c\", \"\", \"internal flag: carry\",\n\t\"$b\", \"\", \"internal flag: borrow\",\n\t\"$p\", \"\", \"internal flag: parity\",\n\t\"$s\", \"\", \"internal flag: sign\",\n\t\"$o\", \"\", \"internal flag: overflow\",\n\t\"$ds\", \"\", \"internal flag: delay-slot\",\n\t\"$jt\", \"\", \"internal flag: jump-target\",\n\t\"$js\", \"\", \"internal flag: jump-target-set\",\n\t\"$$\", \"\", \"internal flag: pc address\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aea = {\n\t\"Examples:\", \"aea\", \" show regs and memory accesses used in a range\",\n\t\"aea\", \"  [ops]\", \"show regs/memory accesses used in N instructions\",\n\t\"aea*\", \" [ops]\", \"create mem.* flags for memory accesses\",\n\t\"aeab\", \"\", \"show regs used in current basic block\",\n\t\"aeaf\", \"\", \"show regs used in current function\",\n\t\"aear\", \" [ops]\", \"show regs read in N instructions\",\n\t\"aeaw\", \" [ops]\", \"show regs written in N instructions\",\n\t\"aean\", \" [ops]\", \"show regs not written in N instructions\",\n\t\"aeaj\", \" [ops]\", \"show aea output in JSON format\",\n\t\"aeA\", \"  [len]\", \"show regs used in N bytes (subcommands are the same)\",\n\t\"Legend:\", \"\", \"\",\n\t\"I\", \"\", \"input registers (read before being set)\",\n\t\"A\", \"\", \"all regs accessed\",\n\t\"R\", \"\", \"register values read\",\n\t\"W\", \"\", \"registers written\",\n\t\"N\", \"\", \"read but never written\",\n\t\"V\", \"\", \"values\",\n\t\"@R\", \"\", \"memreads\",\n\t\"@W\", \"\", \"memwrites\",\n\t\"NOTE:\", \"\", \"mem{reads,writes} with PIC only fetch the offset\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aec = {\n\t\"Examples:\", \"aec\", \" continue until ^c\",\n\t\"aec\", \"\", \"continue until exception\",\n\t\"aecs\", \"\", \"continue until syscall\",\n\t\"aecc\", \"\", \"continue until call\",\n\t\"aecu\", \"[addr]\", \"continue until address\",\n\t\"aecue\", \"[addr]\", \"continue until esil expression\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aeC = {\n\t\"Examples:\", \"aeC\", \" arg0 arg1 ... @ calladdr\",\n\t\"aeC\", \" 1 2 @ sym._add\", \"Call sym._add(1,2)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aeg = {\n\t\"Usage:\", \"aeg[fniv]\", \" [...]\",\n\t\"aeg\", \"\", \"analyze current instruction as an esil graph\",\n\t\"aegb\", \"\", \"data flow graph for current basic block (aeg `pieq $Fi`)\",\n\t\"aegf\", \"\", \"analyze given expression and filter for register\",\n\t\"aegn\", \"\", \"create data flow graph for N instructions\",\n\t\"aegv\", \"\", \"analyse and launch the visual interactive mode\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aep = {\n\t\"Usage:\", \"aep[-*c] \", \" [...] manage esil pins, run r2 commands instead of esil\",\n\t\"aepc\", \" [addr]\", \"change program counter for esil\",\n\t\"aep*\", \"\", \"list pins in r2 commands\",\n\t\"aep-\", \"*\", \"remove all pins\",\n\t\"aep-\", \"[addr]\", \"remove pin\",\n\t\"aep-\", \"[name]\", \"remove pin command\",\n\t\"aepa\", \" ([addr])\", \"auto set pin in current or given address by flag name (see aaep)\",\n\t\"aep\", \" [name] @ [addr]\", \"set pin\",\n\t\"aep \", \"memcpy=wf `dr?A1` `dr?A2` @r:A0\", \"override esil.cmd.pin for this pin name\",\n\t\"aep\", \"\", \"list pins\",\n\t\"aep.\", \"\", \"show pin name in current address if any\",\n\t\"aepk\", \" [query]\", \"kuery the sdb of pins\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aek = {\n\t\"Usage:\", \"aek \", \" [...]\",\n\t\"aek\", \"\", \"dump the esil.stats database contents\",\n\t\"aek \", \"sdb.query\", \"evaluate sdb query on esil.stats db\",\n\t\"aek-\", \"\", \"clear the esil.stats sdb instance\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aets = {\n\t\"Usage:\", \"aets \", \" [...]\",\n\t\"aets+\", \"\", \"start ESIL trace session\",\n\t\"aets-\", \"\", \"stop ESIL trace session\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_af = {\n\t\"Usage:\", \"af\", \"\",\n\t\"af\", \" ([name]) ([addr])\", \"analyze functions (start at addr or $$)\",\n\t\"af+\", \" addr name [type] [diff]\", \"hand craft a function (requires afb+)\",\n\t\"af-\", \" [addr]\", \"clean all function analysis data (or function at addr)\",\n\t\"afa\", \"\", \"analyze function arguments in a call (afal honors dbg.funcarg)\",\n\t\"afB\", \" 16\", \"set current function as thumb (change asm.bits)\",\n\t\"afb\", \"[?] [addr]\", \"List basic blocks of given function\",\n\t\"afb+\", \" fcnA bbA sz [j] [f] ([t]( [d]))\", \"add bb to function @ fcnaddr\",\n\t\"afbF\", \"([0|1])\", \"Toggle the basic-block 'folded' attribute\",\n\t\"afc\", \"[?] type @[addr]\", \"set calling convention for function\",\n\t\"afC[lc]\", \" ([addr])@[addr]\", \"calculate the Cycles (afC) or Cyclomatic Complexity (afCc)\",\n\t\"afd\", \"[addr]\",\"show function + delta for given offset\",\n\t\"afF\", \"[1|0|]\", \"fold/unfold/toggle\",\n\t\"afi\", \" [addr|fcn.name]\", \"show function(s) information (verbose afl)\",\n\t\"afj\", \" [tableaddr] [elem_sz] [count] [seg]\", \"analyze function jumptable (adding seg to each elem)\",\n\t\"afl\", \"[?] [ls*] [fcn name]\", \"list functions (addr, size, bbs, name) (see afll)\",\n\t\"afm\", \" name\", \"merge two functions\",\n\t\"afM\", \" name\", \"print functions map\",\n\t\"afn\", \"[?] name [addr]\", \"rename name for function at address (change flag too)\",\n\t\"afna\", \"\", \"suggest automatic name for current offset\",\n\t\"afo\", \"[?j] [fcn.name]\", \"show address for the function name or current offset\",\n\t\"afr\", \" ([name]) ([addr])\", \"analyze functions recursively\",\n\t\"afs\", \"[!] ([fcnsign])\", \"get/set function signature at current address (afs! uses cfg.editor)\",\n\t\"afS\", \"[stack_size]\", \"set stack frame size for function at current address\",\n\t\"afsr\", \" [function_name] [new_type]\", \"change type for given function\",\n\t\"aft\", \"[?]\", \"type matching, type propagation\",\n\t\"afu\", \" addr\", \"resize and analyze function from current address until addr\",\n\t\"afv[absrx]\", \"?\", \"manipulate args, registers and variables in function\",\n\t\"afx\", \"[m]\", \"list function references\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afb = {\n\t\"Usage:\", \"afb\", \" list basic blocks of given function\",\n\t\".afbr-\", \"\", \"set breakpoint on every return address of the function\",\n\t\".afbr-*\", \"\", \"remove breakpoint on every return address of the function\",\n\t\"afb\", \" [addr]\", \"list basic blocks of function\",\n\t\"afb.\", \" [addr]\", \"show info of current basic block\",\n\t\"afb=\", \"\", \"display ascii-art bars for basic block regions\",\n\t\"afb+\", \" fcn_at bbat bbsz [jump] [fail] ([diff])\", \"add basic block by hand\",\n\t\"afbc\", \"[-] [color] ([addr])\", \"colorize basic block (same as 'abc', afbc- to unset)\",\n\t\"afbe\", \" bbfrom bbto\", \"add basic-block edge for switch-cases\",\n\t\"afbi\", \"[j]\", \"print current basic block information\",\n\t\"afbj\", \" [addr]\", \"show basic blocks information in json\",\n\t\"afbr\", \"\", \"show addresses of instructions which leave the function\",\n\t\"afbt\", \"\", \"show basic blocks of current function in a table\",\n\t\"afbo\", \"\", \"list addresses of each instruction for every basic block in function (see abo)\",\n\t\"afB\", \" [bits]\", \"define asm.bits for the given function\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afc = {\n\t\"Usage:\", \"afc[agl?]\", \"# see also tcc command to manage all calling conventions\",\n\t\"afc\", \" ccname\", \"manually set calling convention for current function\",\n\t\"afc\", \"\", \"show calling convention for the Current function (same as tcc)\",\n\t\"afcr\", \"[j]\", \"show register usage for the current function\",\n\t\"afcf\", \"[j] [name]\", \"prints return type function(arg1, arg2...), see afij\",\n\t\"afci\", \"\", \"information about the current calling convention\",\n\t\"afck\", \"\", \"list SDB details of call loaded calling conventions\",\n\t\"afcl\", \"\", \"list all available calling conventions\",\n\t\"afcll\", \"\", \"show all call conventions and its definition\",\n\t\"afco\", \" path\", \"open Calling Convention sdb profile from given path\",\n\t\"afcR\", \"\", \"register telescoping using the calling conventions order\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afC = {\n\t\"Usage:\", \"afC\", \" [addr]\",\n\t\"afC\", \"\", \"function cycles cost\",\n\t\"afCc\", \"\", \"cyclomatic complexity\",\n\t\"afCl\", \"\", \"loop count (backward jumps)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afi = {\n\t\"Usage:\", \"afi[jlp*]\", \" <addr>\",\n\t\"afi\", \"\", \"show information of the function\",\n\t\"afi\", \"[.j*]\", \"function, variables and arguments\",\n\t\"afii\", \"[-][import]\", \"show/add/delete imports used in function\",\n\t\"afil\", \"\", \"verbose function info\",\n\t\"afip\", \"\", \"show whether the function is pure or not\",\n\t\"afiq\", \"\", \"show quite few info about the function\",\n\t\"afis\", \"\", \"show function stats (opcode, meta)\",\n\t\"afix\", \"[.j]\", \"function xrefs information\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afis = {\n\t\"Usage:\", \"afis[ft]\", \"\",\n\t\"afis\", \"\", \"enumerate unique opcodes in function\",\n\t\"afisa\", \"[fo]\", \"enumerate all the meta of all the functions\",\n\t\"afisf\", \"\", \"enumerate unique opcode families in function\",\n\t\"afiso\", \"\", \"enumerate unique opcode types in function\",\n\t\"afist\", \" [query]\", \"list in table format\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afl = {\n\t\"Usage:\", \"afl\", \" List all functions\",\n\t\"afl\", \"\", \"list functions\",\n\t\"afl.\", \"\", \"display function in current offset (see afi.)\",\n\t\"afl+\", \"\", \"display sum all function sizes\",\n\t\"afl=\", \"\", \"display ascii-art bars with function ranges\",\n\t\"aflc\", \"\", \"count of functions\",\n\t\"aflj\", \"\", \"list functions in json\",\n\t\"aflt\", \" [query]\", \"list functions in table format\",\n\t\"afll\", \" [column]\", \"list functions in verbose mode (sorted by column name)\",\n\t\"afllj\", \"\", \"list functions in verbose mode (alias to aflj)\",\n\t\"aflm\", \"[?]\", \"list functions in makefile style (af@@=`aflm~0x`)\",\n\t\"aflq\", \"\", \"list functions in quiet mode\",\n\t\"aflqj\", \"\", \"list functions in json quiet mode\",\n\t\"afls\", \"[?asn]\", \"sort function list by address, size or name\",\n\t\"aflx\", \"[?*jv]\", \"list function xrefs (who references or calls the current function)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afll = {\n\t\"Usage:\", \"\", \" List functions in verbose mode\",\n\t\"\", \"\", \"\",\n\t\"Table fields:\", \"\", \"\",\n\t\"\", \"\", \"\",\n\t\"address\", \"\", \"start address\",\n\t\"size\", \"\", \"function size (realsize)\",\n\t\"nbbs\", \"\", \"number of basic blocks\",\n\t\"edges\", \"\", \"number of edges between basic blocks\",\n\t\"cc\", \"\", \"cyclomatic complexity ( cc = edges - blocks + 2 * exit_blocks)\",\n\t\"cost\", \"\", \"cyclomatic cost\",\n\t\"min bound\", \"\", \"minimal address\",\n\t\"range\", \"\", \"function size\",\n\t\"max bound\", \"\", \"maximal address\",\n\t\"calls\", \"\", \"number of caller functions\",\n\t\"locals\", \"\", \"number of local variables\",\n\t\"args\", \"\", \"number of function arguments\",\n\t\"xref\", \"\", \"number of cross references\",\n\t\"frame\", \"\", \"function stack size\",\n\t\"name\", \"\", \"function name\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afn = {\n\t\"Usage:\", \"afn[sa]\", \" Analyze function names\",\n\t\"afn\", \" [name]\", \"rename the function\",\n\t\"afn\", \" base64:encodedname\", \"rename the function\",\n\t\"afn.\", \"\", \"same as afn without arguments. show the function name in current offset\",\n\t\"afna\", \"\", \"construct a function name for the current offset\",\n\t\"afns\", \"\", \"list all strings associated with the current function\",\n\t\"afnsj\", \"\", \"list all strings associated with the current function in JSON format\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afs = {\n\t\"Usage:\", \"afs[r]\", \" Analyze function signatures\",\n\t\"afs\", \"[!] ([fcnsign])\", \"get/set function signature at current address (afs! uses cfg.editor)\",\n\t\"afs*\", \" ([signame])\", \"get function signature in flags\",\n\t\"afsj\", \" ([signame])\", \"get function signature in JSON\",\n\t\"afsr\", \" [function_name] [new_type]\", \"change type for given function\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aft = {\n\t\"Usage:\", \"aft\", \"\",\n\t\"aft\", \"\", \"type matching analysis for current function\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afv = {\n\t\"Usage:\", \"afv[rbs]\",\" Function variables manipulation\",\n\t\"afv*\", \"\", \"output r2 command to add args/locals to flagspace\",\n\t\"afv-\", \"([name])\", \"remove all or given var\",\n\t\"afv=\", \"\", \"list function variables and arguments with disasm refs\",\n\t\"afva\", \"\", \"analyze function arguments/locals\",\n\t\"afvb\", \"[?]\", \"manipulate bp based arguments/locals\",\n\t\"afvd\", \" name\", \"output r2 command for displaying the value of args/locals in the debugger\",\n\t\"afvf\", \"\", \"show BP relative stackframe variables\",\n\t\"afvn\", \" [new_name] ([old_name])\", \"rename argument/local\",\n\t\"afvr\", \"[?]\", \"manipulate register based arguments\",\n\t\"afvR\", \" [varname]\", \"list addresses where vars are accessed (READ)\",\n\t\"afvs\", \"[?]\", \"manipulate sp based arguments/locals\",\n\t\"afvt\", \" [name] [new_type]\", \"change type for given argument/local\",\n\t\"afvW\", \" [varname]\", \"list addresses where vars are accessed (WRITE)\",\n\t\"afvx\", \"\", \"show function variable xrefs (same as afvR+afvW)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aeim = {\n\t\"Usage:\", \"aeim\", \" [addr] [size] [name] - initialize the ESIL VM stack\",\n\t\"aeim\", \"\", \"initialize esil memory with default values from esil.stack.* evals\",\n\t\"aeim\", \" 0x10000\", \"same as aeim@e:esil.stack.addr=0x10000\",\n\t\"aeim\", \" 0x10000 2M mystack\", \"give a name to that new 2MB stack\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afvb = {\n\t\"Usage:\", \"afvb\", \" [idx] [name] ([type])\",\n\t\"afvb\", \"\", \"list base pointer based arguments, locals\",\n\t\"afvb*\", \"\", \"same as afvb but in r2 commands\",\n\t\"afvb\", \" [idx] [name] ([type])\", \"define base pointer based arguments, locals\",\n\t\"afvbj\", \"\", \"return list of base pointer based arguments, locals in JSON format\",\n\t\"afvb-\", \" [name]\", \"delete argument/locals at the given name\",\n\t\"afvbg\", \" [idx] [addr]\", \"define var get reference\",\n\t\"afvbs\", \" [idx] [addr]\", \"define var set reference\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afvr = {\n\t\"Usage:\", \"afvr\", \" [reg] [type] [name]\",\n\t\"afvr\", \"\", \"list register based arguments\",\n\t\"afvr*\", \"\", \"same as afvr but in r2 commands\",\n\t\"afvr\", \" [reg] [name] ([type])\", \"define register arguments\",\n\t\"afvrj\", \"\", \"return list of register arguments in JSON format\",\n\t\"afvr-\", \" [name]\", \"delete register arguments at the given index\",\n\t\"afvrg\", \" [reg] [addr]\", \"define argument get reference\",\n\t\"afvrs\", \" [reg] [addr]\", \"define argument set reference\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_afvs = {\n\t\"Usage:\", \"afvs\", \" [idx] [type] [name]\",\n\t\"afvs\", \"\", \"list stack based arguments and locals\",\n\t\"afvs*\", \"\", \"same as afvs but in r2 commands\",\n\t\"afvs\", \" [idx] [name] [type]\", \"define stack based arguments,locals\",\n\t\"afvsj\", \"\", \"return list of stack based arguments and locals in JSON format\",\n\t\"afvs-\", \" [name]\", \"delete stack based argument or locals with the given name\",\n\t\"afvsg\", \" [idx] [addr]\", \"define var get reference\",\n\t\"afvss\", \" [idx] [addr]\", \"define var set reference\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ag = {\n\t\"Usage:\", \"ag<graphtype><format> [addr]\", \"\",\n\t\"Graph commands:\", \"\", \"\",\n\t\"aga\", \"[format]\", \"data references graph\",\n\t\"agA\", \"[format]\", \"global data references graph\",\n\t\"agc\", \"[format]\", \"function callgraph\",\n\t\"agC\", \"[format]\", \"global callgraph\",\n\t\"agd\", \"[format] [fcn addr]\", \"diff graph\",\n\t\"agf\", \"[format]\", \"basic blocks function graph\",\n\t\"agi\", \"[format]\", \"imports graph\",\n\t\"agr\", \"[format]\", \"references graph\",\n\t\"agR\", \"[format]\", \"global references graph\",\n\t\"agx\", \"[format]\", \"cross references graph\",\n\t\"agg\", \"[format]\", \"custom graph\",\n\t\"agt\", \"[format]\", \"tree map graph\",\n\t\"ag-\", \"\", \"clear the custom graph\",\n\t\"agn\", \"[?] title body\", \"add a node to the custom graph\",\n\t\"age\", \"[?] title1 title2\", \"add an edge to the custom graph\",\n\t\"\",\"\",\"\",\n\t\"Output formats:\", \"\", \"\",\n\t\"<blank>\", \"\", \"ascii art\",\n\t\"*\", \"\", \"r2 commands\",\n\t\"b\", \"\", \"braile art rendering (agfb)\",\n\t\"d\", \"\", \"graphviz dot\",\n\t\"g\", \"\", \"graph Modelling Language (gml)\",\n\t\"j\", \"\", \"json ('J' for formatted disassembly)\",\n\t\"k\", \"\", \"sdb key-value\",\n\t\"m\", \"\", \"mermaid\",\n\t\"t\", \"\", \"tiny ascii art\",\n\t\"v\", \"\", \"interactive ascii art\",\n\t\"w\", \" [path]\", \"write to path or display graph image (see graph.gv.format)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_age = {\n\t\"Usage:\", \"age [title1] [title2]\", \"\",\n\t\"Examples:\", \"\", \"\",\n\t\"age\", \" title1 title2\", \"add an edge from the node with \\\"title1\\\" as title to the one with title \\\"title2\\\"\",\n\t\"age\", \" \\\"title1 with spaces\\\" title2\", \"add an edge from node \\\"title1 with spaces\\\" to node \\\"title2\\\"\",\n\t\"age-\", \" title1 title2\", \"remove an edge from the node with \\\"title1\\\" as title to the one with title \\\"title2\\\"\",\n\t\"ageh\", \"\", \"list all the highlighted edges\",\n\t\"ageh\", \" nodeA nodeB\", \"highlight edge between nodeA and nodeB\",\n\t\"ageh-\", \" nodeA nodeB\", \"highlight edge between nodeA and nodeB\",\n\t\"age?\", \"\", \"show this help\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_agn = {\n\t\"Usage:\", \"agn [title] [body]\", \"\",\n\t\"Examples:\", \"\", \"\",\n\t\"agn\", \" title1 body1\", \"add a node with title \\\"title1\\\" and body \\\"body1\\\"\",\n\t\"agn\", \" \\\"title with space\\\" \\\"body with space\\\"\", \"add a node with spaces in the title and in the body\",\n\t\"agn\", \" title1 base64:Ym9keTE=\", \"add a node with the body specified as base64\",\n\t\"agn-\", \" title1\", \"remove a node with title \\\"title1\\\"\",\n\t\"agn?\", \"\", \"show this help\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ah = {\n\t\"Usage:\", \"ah[lba-]\", \"analysis Hints\",\n\t\"ah?\", \"\", \"show this help\",\n\t\"ah?\", \" offset\", \"show hint of given offset\",\n\t\"ah\", \"\", \"list hints in human-readable format\",\n\t\"ah.\", \"\", \"list hints in human-readable format from current offset\",\n\t\"ah-\", \"\", \"remove all hints\",\n\t\"ah-\", \" offset [size]\", \"remove hints at given offset\",\n\t\"ah*\", \" offset\", \"list hints in radare commands format\",\n\t\"aha\", \" ppc @ 0x42\", \"force arch ppc for all addrs >= 0x42 or until the next hint\",\n\t\"aha\", \" 0 @ 0x84\", \"disable the effect of arch hints for all addrs >= 0x84 or until the next hint\",\n\t\"ahb\", \"[-*] [8,16,32,64] @ 0x42\", \"get/set asm.bits for given address and beyond\",\n\t\"ahc\", \" 0x804804\", \"override call/jump address\",\n\t\"ahd\", \" foo a0,33\", \"replace opcode string\",\n\t\"ahe\", \" 3,eax,+=\", \"set vm analysis string\",\n\t\"ahf\", \" 0x804840\", \"override fallback address for call\",\n\t\"ahF\", \" 0x10\", \"set stackframe size at current offset\",\n\t\"ahh\", \" 0x804840\", \"highlight this address offset in disasm\",\n\t\"ahi\", \"[?] 10\", \"define numeric base for immediates (2, 8, 10, 10u, 16, i, p, S, s)\",\n\t\"ahj\", \"\", \"list hints in JSON\",\n\t\"aho\", \" call\", \"change opcode type (see aho?)\",\n\t\"ahp\", \" addr\", \"set pointer hint\",\n\t\"ahr\", \" val\", \"set hint for return value of a function\",\n\t\"ahs\", \" 4\", \"set opcode size=4\",\n\t\"ahS\", \" jz\", \"set asm.syntax=jz for this opcode\",\n\t\"aht\", \"[s][?] <type>\", \"mark immediate as a type offset (deprecated, moved to \\\"aho\\\")\",\n\t\"ahv\", \" val\", \"change opcode's val field (useful to set jmptbl sizes in jmp rax)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ahs = {\n\t\"Usage:\", \"ahs [size] [@ addr]\", \" Define opcode size hint\",\n\t\"ahs\", \" 16\", \"Hint the analysis to make the instruction 16 bytes in size\",\n\t\"ahs-\", \"\", \"Unset the instruction size hint in the current offset\",\n\t\"ahs-\", \"*\", \"Unset the instruction size hint in the current offset\",\n\t\"ahs*\", \"\", \"show all the instruction size hints as r2 commands\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aho = {\n\t\"Usage:\", \"aho [optype] [@ addr]\", \" Define opcode type hint\",\n\t\"aho\", \" nop\", \"change the opcode type in current address to be considered a NOP\",\n\t\"aho\", \"\", \"show the current opcode hint if any\",\n\t\"aho-\", \"$$\", \"delete hints in current offset\",\n\t\"aho*\", \"\", \"same as above but in r2 commands syntax\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ahb = {\n\t\"Usage:\", \"ahb [8|16|32|64] [@ addr]\", \" Define asm.bits hint at given address\",\n\t\"ahb\", \" 16\", \"set asm.bits=16 in the given address\",\n\t\"ahb\", \"\", \"get asm.bits used in given addr (current seek)\",\n\t\"ahb\", \"-$$\", \"delete all the hints in the given address\",\n\t\"ahb*\", \"\", \"show defined bits hints as r2 commands\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ahr = {\n\t\"Usage:\", \"ahr addr\", \" Set instruction as return type (similar to 'aho ret'?)\",\n\t\"ahr\", \" $$\", \"current instruction may be considered as the end of a function\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ahi = {\n\t\"Usage:\", \"ahi [2|8|10|10u|16|bodhipSs] [@ offset]\", \" Define numeric base\",\n\t\"ahi\", \" <base>\", \"set numeric base (2, 8, 10, 16)\",\n\t\"ahi\", \" 10|d\", \"set base to signed decimal (10), sign bit should depend on receiver size\",\n\t\"ahi\", \" 10u|du\", \"set base to unsigned decimal (11)\",\n\t\"ahi\", \" b\", \"set base to binary (2)\",\n\t\"ahi\", \" o\", \"set base to octal (8)\",\n\t\"ahi\", \" h\", \"set base to hexadecimal (16)\",\n\t\"ahi\", \" i\", \"set base to IP address (32)\",\n\t\"ahi\", \" p\", \"set base to htons(port) (3)\",\n\t\"ahi\", \" S\", \"set base to syscall (80)\",\n\t\"ahi\", \" s\", \"set base to string (1)\",\n\t\"ahi1\", \" 10\", \"set base of argument 1 to base 10 (same as ahi1 d)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aht = {\n\t\"Usage:\", \"aht[s] [addr|type]\", \"mark immediate as type offset (moved to aho)\",\n\t\"ahts\", \" <offset>\", \"list all matching structure offsets\",\n\t\"aht\", \" <struct.member>\", \"change immediate to structure offset\",\n\t\"aht?\", \"\", \"show this help\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aot = {\n\t\"Usage:\", \"aot[l]\", \"list opcode types\",\n\t\"aot\", \"\", \"show type of the current instruction\",\n\t\"aotl\", \"\", \"list all possible opcode types (See /atl)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_aom = {\n\t\"Usage:\", \"aom[ljd] [arg]\", \"list opcode mnemonics\",\n\t\"aom\", \"\", \"show instruction mnemonic\",\n\t\"aom.\", \"\", \"show instruction mnemonic in current address\",\n\t\"aoml\", \"\", \"list all mnemonics\",\n\t\"aomj\", \"\", \"list in json format (TODO: add instruction description too?)\",\n\t\"aomd\", \"\", \"verbose mnemonic listing with instruction description\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ao = {\n\t\"Usage:\", \"ao[e?] [len]\", \"analyze Opcodes\",\n\t\"ao\", \" 5\", \"display opcode analysis of 5 opcodes\",\n\t\"ao*\", \"\", \"display opcode in r commands\",\n\t\"aob\", \" ([hex])\", \"analyze meaning of every single bit in the current opcode\",\n\t\"aoc\", \" [cycles]\", \"analyze which op could be executed in [cycles]\",\n\t\"aod\", \" [mnemonic]\", \"instruction mnemonic description for asm.arch\",\n\t\"aoda\", \"\", \"show all mnemonic descriptions\",\n\t\"aoe\", \" N\", \"display esil form for N opcodes\",\n\t\"aoem\", \" N\", \"display memory references from esil emulation of N opcode\",\n\t\"aoef\", \" expr\", \"filter esil expression of opcode by given output\",\n\t\"aoeq\", \" N\", \"display only the esil expression of N opcodes\",\n\t\"aoj\", \" N\", \"display opcode analysis information in JSON for N opcodes\",\n\t\"aom\", \"[?] [id]\", \"list current or all mnemonics for current arch\",\n\t\"aor\", \" [N]\", \"run N esil instructions + esil.dumpstack\",\n\t\"aos\", \" N\", \"display size of N opcodes\",\n\t\"aot\", \"[?]\", \"list all opcode types\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ar = {\n\t\"Usage: ar\", \"\", \"# Analysis Registers\",\n\t\"ar\", \"\", \"show 'gpr' registers\",\n\t\"ar.\", \">$snapshot\", \"show r2 commands to set register values to the current state\",\n\t\"ar,\", \"\", \"show registers in table format (see dr,)\",\n\t\".ar*\", \"\", \"import register values as flags\",\n\t\".ar-\", \"\", \"unflag all registers\",\n\t\"ar0\", \"\", \"reset register arenas to 0\",\n\t\"ara\", \"[?]\", \"manage register arenas\",\n\t\"arj\", \"\", \"show 'gpr' registers in JSON format\",\n\t\"arA\", \"\", \"show values of function argument calls (A0, A1, A2, ..)\",\n\t\"ar\", \" 16\", \"show 16 bit registers\",\n\t\"ar\", \" 32\", \"show 32 bit registers\",\n\t\"ar\", \" all\", \"show all bit registers\",\n\t\"ar\", \" <type>\", \"show all registers of given type\",\n\t\"arC\", \"\", \"display register profile comments\",\n\t\"arr\", \"\", \"show register references (telescoping)\",\n\t\"arrj\", \"\", \"show register references (telescoping) in JSON format\",\n\t\"ar=\", \"([size])(:[regs])\", \"show register values in columns\",\n\t\"ar?\", \" <reg>\", \"show register value\",\n\t\"arb\", \" <type>\", \"display hexdump of the given arena\",\n\t\"arc\", \"[cq=] <name>\", \"conditional flag registers\",\n\t\"arcc\", \"\", \"derive calling convention from the register profile\",\n\t\"ard\", \" <name>\", \"show only different registers\",\n\t\"arn\", \" <regalias>\", \"get regname for pc,sp,bp,a0-3,zf,cf,of,sg\",\n\t\"aro\", \"\", \"show old (previous) register values\",\n\t\"arp\", \"[?] <file>\", \"load register profile from file\",\n\t\"ars\", \"\", \"stack register state\",\n\t\"arS\", \"\", \"show the size of the register profile\",\n\t\"art\", \"\", \"list all register types\",\n\t\"arw\", \" <hexnum>\", \"set contents of the register arena\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ara = {\n\t\"Usage:\", \"ara[+-s]\", \"register Arena Push/Pop/Swap\",\n\t\"ara\", \"\", \"show all register arenas allocated\",\n\t\"ara\", \"+\", \"push a new register arena for each type\",\n\t\"ara\", \"-\", \"pop last register arena\",\n\t\"aras\", \"\", \"swap last two register arenas\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_arw = {\n\t\"Usage:\", \"arw \", \"# Set contents of the register arena\",\n\t\"arw\", \" <hexnum>\", \"set contents of the register arena\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_as = {\n\t\"Usage: as[ljk?]\", \"\", \"syscall name <-> number utility\",\n\t\"as\", \"\", \"show current syscall and arguments\",\n\t\"as\", \" 4\", \"show syscall 4 based on asm.os and current regs/mem\",\n\t\"asc[a]\", \" 4\", \"dump syscall info in .asm or .h\",\n\t\"asj\", \"\", \"list of syscalls in JSON\",\n\t\"asl\", \"\", \"list of syscalls by asm.os and asm.arch\",\n\t\"asl\", \" close\", \"returns the syscall number for close\",\n\t\"asl\", \" 4\", \"returns the name of the syscall number 4\",\n\t\"ask\", \" [query]\", \"perform syscall/ queries\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_av = {\n\t\"Usage:\", \"av[?jr*]\", \" C++ vtables and RTTI\",\n\t\"av\", \"\", \"search for vtables in data sections and show results\",\n\t\"avj\", \"\", \"like av, but as json\",\n\t\"av*\", \"\", \"like av, but as r2 commands\",\n\t\"avr\", \"[j@addr]\", \"try to parse RTTI at vtable addr (see anal.cxxabi)\",\n\t\"avra\", \"[j]\", \"search for vtables and try to parse RTTI at each of them\",\n\t\"avrr\", \"\", \"recover class info from all findable RTTI (see ac)\",\n\t\"avrD\", \" [classname]\", \"demangle a class name from RTTI\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_ax = {\n\t\"Usage:\", \"ax[?d-l*]\", \" # see also 'afx?'\",\n\t\"ax\", \" addr [at]\", \"add code ref pointing to addr (from curseek)\",\n\t\"ax\", \"\", \"list refs\",\n\t\"ax*\", \"\", \"output radare commands\",\n\t\"ax-\", \" [at]\", \"clean all refs/refs from addr\",\n\t\"ax-*\", \"\", \"clean all refs/refs\",\n\t\"ax.\", \" [addr]\", \"find data/code references from and to this address\",\n\t\"axc\", \" addr [at]\", \"add generic code ref\",\n\t\"axC\", \" addr [at]\", \"add code call ref\",\n\t\"axd\", \" addr [at]\", \"add data ref\",\n\t\"axF\", \" [flg-glob]\", \"find data/code references of flags\",\n\t\"axf\", \"[?] [addr]\", \"find data/code references from this address\",\n\t\"axff[j]\", \" [addr]\", \"find data/code references from this function\",\n\t\"axg\", \" [addr]\", \"show xrefs graph to reach current function\",\n\t\"axg*\", \" [addr]\", \"show xrefs graph to given address, use .axg*;aggv\",\n\t\"axgj\", \" [addr]\", \"show xrefs graph to reach current function in json format\",\n\t\"axi\", \" addr [at]\", \"add indirect code reference (see ax?)\",\n\t\"axj\", \"\", \"add jmp reference\", // list refs in json format\",\n\t\"axl\", \"[jcq]\", \"list xrefs (axlc = count, axlq = quiet, axlj = json)\",\n\t\"axm\", \" addr [at]\", \"copy data/code references pointing to addr to also point to curseek (or at)\",\n\t\"axq\", \"\", \"list refs in quiet/human-readable format\",\n\t\"axr\", \" addr [at]\", \"add data-read ref\",\n\t\"axs\", \" addr [at]\", \"add string ref\",\n\t\"axt\", \"[?] [addr]\", \"find data/code references to this address\",\n\t\"axv\", \"[?] [addr]\", \"list local variables read-write-exec references\",\n\t\"axw\", \" addr [at]\", \"add data-write ref\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_axl= {\n\t\"Usage:\", \"axl[jcq]\", \"show global xrefs\",\n\t\"axl\", \"\", \"list all xrefs\",\n\t\"axlj\", \"\", \"list xrefs in json format\",\n\t\"axlc\", \"\", \"count how many xrefs are registered\",\n\t\"axlq\", \"\", \"list xrefs in quiet mode (axq)\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_axv= {\n\t\"Usage:\", \"axv[?j]\", \"show xrefs to local variables in current function\",\n\t\"axv\", \" ([addr])\", \"optionally you can specify address instead of current seek\",\n\t\"axvj\", \" ([addr])\", \"show in json\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_axt= {\n\t\"Usage:\", \"axt[?gq*]\", \"find data/code references to this address\",\n\t\"axtj\", \" [addr]\", \"find data/code references to this address and print in json format\",\n\t\"axtg\", \" [addr]\", \"display commands to generate graphs according to the xrefs\",\n\t\"axtq\", \" [addr]\", \"find and list the data/code references in quiet mode\",\n\t\"axtm\", \" [addr]\", \"show xrefs to in 'make' syntax (see aflm and axfm)\",\n\t\"axt*\", \" [addr]\", \"same as axt, but prints as r2 commands\",\n\tNULL\n};\n\nstatic RCoreHelpMessage help_msg_axf= {\n\t\"Usage:\", \"axf[?gq*]\", \"find data/code references from this address\",\n\t\"axfj\", \" [addr]\", \"find data/code references to this address and print in json format\",\n\t\"axfg\", \" [addr]\", \"display commands to generate graphs according to the xrefs\",\n\t\"axfq\", \" [addr]\", \"find and list the data/code references in quiet mode\",\n\t\"axfm\", \" [addr]\", \"show refs to in 'make' syntax (see aflm and axtm)\",\n\t\"axf*\", \" [addr]\", \"same as axt, but prints as r2 commands\",\n\tNULL\n};\n\nstatic inline const char *get_arch_name(RCore *core) {\n\treturn r_config_get (core->config, \"asm.arch\");\n}\n\nstatic int cmpname(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\treturn (int)strcmp (a->name, b->name);\n}\n\nstatic int cmpsize(const void *a, const void *b) {\n\tut64 sa = (int) r_anal_function_linear_size ((RAnalFunction *) a);\n\tut64 sb = (int) r_anal_function_linear_size ((RAnalFunction *) b);\n\treturn (sa > sb)? -1: (sa < sb)? 1 : 0;\n}\n\nstatic int cmpbbs(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\tint la = (int)r_list_length (a->bbs);\n\tint lb = (int)r_list_length (b->bbs);\n\treturn (la > lb)? -1: (la < lb)? 1 : 0;\n}\n\nstatic int cmpaddr(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\treturn (a->addr > b->addr)? 1: (a->addr < b->addr)? -1: 0;\n}\n\nstatic bool listOpDescriptions(void *_core, const char *k, const char *v) {\n\tr_cons_printf (\"%s=%s\\n\", k, v);\n\treturn true;\n}\n\n/* better aac for windows-x86-32 */\n#define JAYRO_03 0\n\n#if JAYRO_03\n\nstatic bool anal_is_bad_call(RCore *core, ut64 from, ut64 to, ut64 addr, ut8 *buf, int bufi) {\n\tut64 align = R_ABS (addr % PE_ALIGN);\n\tut32 call_bytes;\n\n\t// XXX this is x86 specific\n\tif (align == 0) {\n\t\tcall_bytes = (ut32)((ut8*)buf)[bufi + 3] << 24;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 2] << 16;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 1] << 8;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi];\n\t} else {\n\t\tcall_bytes = (ut32)((ut8*)buf)[bufi - align + 3] << 24;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi - align + 2] << 16;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi - align + 1] << 8;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi - align];\n\t}\n\tif (call_bytes >= from && call_bytes <= to) {\n\t\treturn true;\n\t}\n\tcall_bytes = (ut32)((ut8*)buf)[bufi + 4] << 24;\n\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 3] << 16;\n\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 2] << 8;\n\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 1];\n\tcall_bytes += addr + 5;\n\tif (call_bytes >= from && call_bytes <= to) {\n\t\treturn false;\n\t}\n\treturn false;\n}\n#endif\n\nstatic ut64 faddr(RCore *core, ut64 addr, bool *nr) {\n\tRList *fcns = r_anal_get_functions_in (core->anal, addr);\n\tif (fcns && r_list_length (fcns) > 0) {\n\t\tRListIter *iter;\n\t\tRAnalFunction *fcn;\n\t\tr_list_foreach (fcns, iter, fcn) {\n\t\t\tif (nr && fcn->is_noreturn) {\n\t\t\t\t*nr = true;\n\t\t\t}\n\t\t\treturn fcn->addr;\n\t\t}\n\t}\n\tr_list_free (fcns);\n\treturn addr;\n}\n\n// function argument types and names into anal/types\nstatic void __add_vars_sdb(RCore *core, RAnalFunction *fcn) {\n\tRAnalFcnVarsCache cache;\n\tr_anal_function_vars_cache_init (core->anal, &cache, fcn);\n\tRListIter *iter;\n\tRAnalVar *var;\n\tsize_t arg_count = 0;\n\n\tchar *args = r_str_newf (\"func.%s.args\", fcn->name);\n\tRList *all_vars = cache.rvars;\n\tr_list_join (all_vars, cache.bvars);\n\tr_list_join (all_vars, cache.svars);\n#if 0\n\tr_list_foreach (all_vars, iter, var) {\n\t\tif (var->isarg) {\n\t\t\targ_count++;\n\t\t}\n\t}\n\tint old_arg_count = r_num_get (NULL, args);\n\tif (old_arg_count >= arg_count) {\n\t\treturn;\n\t}\n#endif\n\tr_list_foreach (all_vars, iter, var) {\n\t\tif (var->isarg) {\n\t\t\tchar *k = r_str_newf (\"func.%s.arg.%d\", fcn->name, (int)arg_count);\n\t\t\tconst char *o = sdb_const_get (core->anal->sdb_types, k, 0);\n\t\t\tchar *comma = o? strchr (o, ','): NULL;\n\t\t\tchar *db_type = comma? r_str_ndup (o, comma - o): NULL;\n\t\t\tchar *db_name = comma? strdup (comma + 1): NULL;\n\t\t\tif (!strstr (var->name, \"arg_\") || (o && strstr (o, \",arg_\"))) {\n\t\t\t\t// #if 0\n\t\t\t\tchar *ks = r_str_newf (\"func.%s.arg.%d\", fcn->name, (int)arg_count);\n\t\t\t\t// eprintf (\"VARNAME %s %s %c\", var->name, db_name, 10);\n\t\t\t\t// eprintf (\"VARTYPE %s %s %c\", var->type,db_type, 10);\n\t\t\t\tchar *type = db_type && strstr (var->type, \"arg_\")? db_type: var->type;\n\t\t\t\tchar *v = r_str_newf (\"%s,%s\", type, var->name);\n\t\t\t\tsdb_set (core->anal->sdb_types, ks, v, 0);\n\t\t\t\tfree (ks);\n\t\t\t\tfree (v);\n\t\t\t} else {\n\t\t\t\tchar *name = db_name? db_name: var->name;\n\t\t\t\tchar *type = strdup (db_type? db_type: var->type);\n\t\t\t\t// eprintf (\"VARTYPE1 %s %s %c\", var->type,db_type, 10);\n\t\t\t\tif (var->name && !strstr (var->name, \"arg_\")) {\n\t\t\t\t\to = NULL;\n\t\t\t\t}\n#if 0\n\t\t\t\tif (name != var->name) {\n\t\t\t\t\to = NULL;\n\t\t\t\t} else {\n\t\t\t\t\ttype = strdup (var->type);\n\t\t\t\t}\n#endif\n\t\t\t\tchar *v = comma? strdup (o): r_str_newf (\"%s,%s\", type, name);\n\t\t\t\t/// eprintf(\"arg (%s) %s -- %s%c\", k, v, var->name, 10);\n\t\t\t\tchar *s = strdup (name);\n\t\t\t\tif (o) {\n\t\t\t\t\tchar *v2 = r_str_newf (\"%s,%s\", var->type, name);\n\t\t\t\t\tif (!strstr (var->name, \",arg_\")) {\n\t\t\t\t\t\tfree (var->name);\n\t\t\t\t\t\tvar->name = s;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfree (s);\n\t\t\t\t\t}\n\t\t\t\t\t// sdb_set (core->anal->sdb_types, k, v, 0);\n\t\t\t\t\tfree (v2);\n\t\t\t\t} else {\n\t\t\t\t\tfree (var->name);\n\t\t\t\t\tvar->name = s;\n\t\t\t\t\tsdb_set (core->anal->sdb_types, k, v, 0);\n\t\t\t\t}\n\t\t\t\tfree (v);\n\t\t\t\tfree (type);\n\t\t\t\t// #endif\n\t\t\t}\n\t\t\tfree (db_name);\n\t\t\tfree (db_type);\n\t\t\tfree (k);\n\t\t\targ_count++;\n\t\t}\n\t}\n\t//\tsdb_num_set (core->anal->sdb_types, args, (int)arg_count, 0);\n\tif (arg_count > 0) {\n\t\tchar *k = r_str_newf (\"func.%s.args\", fcn->name);\n\t\tchar *v = r_str_newf (\"%d\", (int)arg_count);\n\t\tsdb_set (core->anal->sdb_types, k, v, 0);\n\t\t// sdb_num_set (core->anal->sdb_types, k, (ut64)arg_count, 0);\n\t\tfree (k);\n\t\tfree (v);\n \t}\n\tfree (args);\n\tr_anal_function_vars_cache_fini (&cache);\n}\n\nstatic bool cmd_anal_aaft(RCore *core) {\n\tRListIter *it;\n\tRAnalFunction *fcn;\n\tut64 seek;\n\tconst char *io_cache_key = \"io.pcache.write\";\n\tbool io_cache = r_config_get_b (core->config, io_cache_key);\n\tif (r_config_get_b (core->config, \"cfg.debug\")) {\n\t\tR_LOG_WARN (\"aaft is disabled in debugger mode\");\n\t\treturn false;\n\t}\n\tif (!io_cache) {\n\t\t// XXX. we shouldnt need this, but it breaks 'r2 -c aaa -w ls'\n\t\tr_config_set_i (core->config, io_cache_key, true);\n\t}\n\tconst bool iova = r_config_get_b (core->config, \"io.va\");\n\tseek = core->offset;\n\tr_reg_arena_push (core->anal->reg);\n\tr_reg_arena_zero (core->anal->reg);\n\tr_core_cmd_call (core, \"aei\");\n\tr_core_cmd_call (core, \"aeim\");\n\tint saved_arena_size = 0;\n\tut8 *saved_arena = r_reg_arena_peek (core->anal->reg, &saved_arena_size);\n\t// Iterating Reverse so that we get function in top-bottom call order\n\tr_list_foreach_prev (core->anal->fcns, it, fcn) {\n\t\tint ret = r_core_seek (core, fcn->addr, true);\n\t\tif (!ret) {\n\t\t\tcontinue;\n\t\t}\n\t\tr_reg_arena_poke (core->anal->reg, saved_arena, saved_arena_size);\n\t\tr_esil_set_pc (core->anal->esil, fcn->addr);\n\t\tr_core_anal_type_match (core, fcn);\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t__add_vars_sdb (core, fcn);\n\t}\n\tr_config_set_b (core->config, \"io.va\", iova);\n\tr_core_seek (core, seek, true);\n\tr_reg_arena_pop (core->anal->reg);\n\tr_config_set_i (core->config, io_cache_key, io_cache);\n\tfree (saved_arena);\n\treturn true;\n}\n\nstatic void type_cmd(RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tif (!fcn && *input != '?') {\n\t\tR_LOG_WARN (\"cant find function here\");\n\t\treturn;\n\t}\n\tut64 seek;\n\tr_cons_break_push (NULL, NULL);\n\tswitch (*input) {\n\tcase '\\0': // \"aft\"\n\t\tseek = core->offset;\n\t\tr_esil_set_pc (core->anal->esil, fcn? fcn->addr: core->offset);\n\t\tr_core_anal_type_match (core, fcn);\n\t\tr_core_seek (core, seek, true);\n\t\tbreak;\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_aft);\n\t\tbreak;\n\t}\n\tr_cons_break_pop ();\n}\n\nstatic void find_refs(RCore *core, const char *glob) {\n\tut64 curseek = core->offset;\n\tglob = r_str_trim_head_ro (glob);\n\tif (!*glob) {\n\t\tglob = \"str.\";\n\t}\n\tif (*glob == '?') {\n\t\tr_core_cmd_help_match (core, help_msg_ax, \"axF\", true);\n\t\treturn;\n\t}\n\tR_LOG_WARN (\"Finding references of flags matching '%s'\", glob);\n\tchar *cmd = r_str_newf (\".(findstref) @@=`f~%s[0]`\", glob);\n\tr_core_cmd0 (core, \"(findstref;f here=$$;s entry0;/r here;f-here)\");\n\tr_core_cmd0 (core, cmd);\n\tr_core_cmd0 (core, \"(-findstref)\");\n\tr_core_seek (core, curseek, true);\n\tfree (cmd);\n}\n\nstatic ut64 sort64val(const void *a) {\n\tut64 *na = (ut64*)a;\n\treturn *na;\n}\nstatic int sort64(const void *a, const void *b) {\n\tut64 *na = (ut64*)a;\n\tut64 *nb = (ut64*)b;\n\treturn *na - *nb;\n}\n\nstatic RList *collect_addresses(RCore *core) {\n#if 0\n\tWIP: return addresses where functions start from different sources:\n\t* [x] symbols\n\t* [ ] exports\n\t* [ ] prelude search\n\t* [ ] call ref analysis\n\tresult is then sorted and uniqified\n#endif\n\tRList *list = r_list_newf (free);\n\tRBinSymbol *sym;\n\tRVecRBinSymbol *symbols = r_bin_get_symbols_vec (core->bin);\n\tR_VEC_FOREACH (symbols, sym) {\n\t\tr_list_append (list, ut64_new (sym->vaddr));\n\t}\n\t// find all calls and mark the destinations as function entrypoints\n\t// r_core_search_preludes (core, true); // __prelude_cb_hit uses globals and calls 'af', should be changed to just return a list for later processing\n\tr_list_sort (list, sort64);\n\tr_list_uniq_inplace (list, sort64val);\n\treturn list;\n}\n\nstatic void single_block_analysis(RCore *core) {\n\tconst ut64 max_fcn_size = 1024 * 1024;\n\tRList *list = collect_addresses (core);\n\tRListIter *iter;\n\tut64 *addr;\n\tr_list_foreach (list, iter, addr) {\n\t\tut64 *next = iter->n? iter->n->data: addr;\n\t\tint len = (*next) - *addr;\n\t\tif (len > 0 && len < max_fcn_size) {\n\t\t\tut64 at = *addr;\n\t\t\tif (r_anal_get_function_at (core->anal, at)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRFlagItem *fi = r_flag_get_at (core->flags, at, false);\n\t\t\tchar *name = (fi) ? strdup (fi->name): r_str_newf (\"fcn.%08\"PFMT64x, at);\n\t\t\tRAnalFunction *fcn = r_anal_create_function (core->anal, name, at, 0, NULL);\n\t\t\tif (fcn) {\n\t\t\t\tr_anal_function_add_bb (core->anal, fcn, at, len, UT64_MAX, UT64_MAX, 0);\n\t\t\t}\n\t\t\tfree (name);\n\t\t}\n\t}\n\tr_list_free (list);\n}\n\n/* set flags for every function */\nstatic void flag_every_function(RCore *core) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_flag_space_push (core->flags, R_FLAGS_FS_FUNCTIONS);\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tr_flag_set (core->flags, fcn->name,\n\t\t\tfcn->addr, r_anal_function_size_from_entry (fcn));\n\t}\n\tr_flag_space_pop (core->flags);\n}\n\nstatic void var_help(RCore *core, char ch) {\n\tswitch (ch) {\n\tcase 'b':\n\t\tr_core_cmd_help (core, help_msg_afvb);\n\t\tbreak;\n\tcase 's':\n\t\tr_core_cmd_help (core, help_msg_afvs);\n\t\tbreak;\n\tcase 'r':\n\t\tr_core_cmd_help (core, help_msg_afvr);\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_afv);\n\t\tbreak;\n\t}\n}\n\nstatic void var_accesses_list(RAnalFunction *fcn, RAnalVar *var, PJ *pj, int access_type, const char *name) {\n\tRAnalVarAccess *acc;\n\tbool first = true;\n\tif (r_vector_empty (&var->accesses)) {\n\t\tR_LOG_WARN (\"Variable '%s' have no references?\", name);\n\t}\n\tif (pj) {\n\t\tpj_o (pj);\n\t\tpj_ks (pj, \"name\", name);\n\t\tpj_ka (pj, \"addrs\");\n\t} else {\n\t\tr_cons_printf (\"%10s\", name);\n\t}\n\tr_vector_foreach (&var->accesses, acc) {\n\t\tif (!(acc->type & access_type)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 addr = fcn->addr + acc->offset;\n\t\tif (pj) {\n\t\t\tpj_n (pj, addr);\n\t\t} else {\n\t\t\tr_cons_printf (\"%s0x%\" PFMT64x, first ? \"  \" : \",\", addr);\n\t\t}\n\t\tfirst = false;\n\t}\n\tif (pj) {\n\t\tpj_end (pj);\n\t\tpj_end (pj);\n\t} else {\n\t\tr_cons_newline ();\n\t}\n}\n\nstatic void list_vars(RCore *core, RAnalFunction *fcn, PJ *pj, int type, const char *name) {\n\tRAnalVar *var = NULL;\n\tRListIter *iter;\n\tRList *list = r_anal_var_all_list (core->anal, fcn);\n\tif (type == '=') {\n\t\tut64 oaddr = core->offset;\n\t\tr_list_foreach (list, iter, var) {\n\t\t\tr_cons_printf (\"* %s\\n\", var->name);\n\t\t\tRAnalVarAccess *acc;\n\t\t\tr_vector_foreach (&var->accesses, acc) {\n\t\t\t\tif (!(acc->type & R_ANAL_VAR_ACCESS_TYPE_READ)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"R 0x%\"PFMT64x\"  \", fcn->addr + acc->offset);\n\t\t\t\tr_core_seek (core, fcn->addr + acc->offset, 1);\n\t\t\t\tr_core_print_disasm_instructions (core, 0, 1);\n\t\t\t}\n\t\t\tr_vector_foreach (&var->accesses, acc) {\n\t\t\t\tif (!(acc->type & R_ANAL_VAR_ACCESS_TYPE_WRITE)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"W 0x%\"PFMT64x\"  \", fcn->addr + acc->offset);\n\t\t\t\tr_core_seek (core, fcn->addr + acc->offset, 1);\n\t\t\t\tr_core_print_disasm_instructions (core, 0, 1);\n\t\t\t}\n\t\t}\n\t\tr_core_seek (core, oaddr, 0);\n\t\tr_list_free (list);\n\t\treturn;\n\t}\n\tif (type == '*') {\n\t\tconst char *bp = r_reg_get_name (core->anal->reg, R_REG_NAME_BP);\n\t\tr_cons_printf (\"f-fcnvar*\\n\");\n\t\tr_list_foreach (list, iter, var) {\n\t\t\tr_cons_printf (\"f fcnvar.%s @ %s%s%d\\n\", var->name, bp,\n\t\t\t\tvar->delta >= 0? \"+\":\"\", var->delta);\n\t\t}\n\t\tr_list_free (list);\n\t\treturn;\n\t}\n\tif (type != 'W' && type != 'R') {\n\t\tr_list_free (list);\n\t\treturn;\n\t}\n\tint access_type = type == 'R' ? R_ANAL_VAR_ACCESS_TYPE_READ : R_ANAL_VAR_ACCESS_TYPE_WRITE;\n\tif (pj) {\n\t\tpj_a (pj);\n\t}\n\tif (name && *name) {\n\t\tvar = r_anal_function_get_var_byname (fcn, name);\n\t\tif (var) {\n\t\t\tvar_accesses_list (fcn, var, pj, access_type, var->name);\n\t\t}\n\t} else {\n\t\tr_list_foreach (list, iter, var) {\n\t\t\tvar_accesses_list (fcn, var, pj, access_type, var->name);\n\t\t}\n\t}\n\tif (pj) {\n\t\tpj_end (pj);\n\t}\n\tr_list_free (list);\n}\n\nstatic void cmd_afvx(RCore *core, RAnalFunction *fcn, bool json) {\n\tr_return_if_fail (core);\n\tif (!fcn) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_ANY);\n\t}\n\tif (fcn) {\n\t\tPJ *pj = NULL;\n\t\tif (json) {\n\t\t\tpj = pj_new ();\n\t\t\tpj_o (pj);\n\t\t\tpj_k (pj, \"reads\");\n\t\t} else {\n\t\t\tr_cons_printf (\"afvR\\n\");\n\t\t}\n\t\tlist_vars (core, fcn, pj, 'R', NULL);\n\t\tif (json) {\n\t\t\tpj_k (pj, \"writes\");\n\t\t} else {\n\t\t\tr_cons_printf (\"afvW\\n\");\n\t\t}\n\t\tlist_vars (core, fcn, pj, 'W', NULL);\n\t\tif (json) {\n\t\t\tpj_end (pj);\n\t\t\tchar *j = pj_drain (pj);\n\t\t\tr_cons_printf (\"%s\\n\", j);\n\t\t\tfree (j);\n\t\t}\n\t}\n}\n\nstatic int cmd_an(RCore *core, const char *name, int mode) {\n\tint ret = 0;\n\tRAnalOp op = {0};\n\tPJ *pj = NULL;\n\n\tif (mode == 'j') {\n\t\tpj = pj_new ();\n\t\tpj_a (pj);\n\t}\n\tif (r_anal_op (core->anal, &op, core->offset, core->block, core->blocksize, R_ARCH_OP_MASK_BASIC) < 1) {\n\t\tgoto failure;\n\t}\n\tRAnalVar *var = r_anal_get_used_function_var (core->anal, op.addr);\n\n\tut64 tgt_addr = op.jump != UT64_MAX? op.jump: op.ptr;\n\tif (var) {\n\t\tif (name) {\n\t\t\tret = r_anal_var_rename (var, name, true) ? 0 : -1;\n\t\t} else if (mode == '*') {\n\t\t\tr_cons_printf (\"f %s=0x%\" PFMT64x \"\\n\", var->name, tgt_addr);\n\t\t} else if (mode == 'j') {\n\t\t\tpj_o (pj);\n\t\t\tpj_ks (pj, \"name\", var->name);\n\t\t\tpj_ks (pj, \"type\", \"var\");\n\t\t\tpj_kn (pj, \"offset\", tgt_addr);\n\t\t\tpj_end (pj);\n\t\t} else {\n\t\t\tr_cons_println (var->name);\n\t\t}\n\t} else {\n\t\tif (tgt_addr == UT64_MAX) {\n\t\t\ttgt_addr = core->offset;\n\t\t}\n\t\tRFlagItem *f = r_flag_get_by_spaces (core->flags, tgt_addr, R_FLAGS_FS_SYMBOLS, R_FLAGS_FS_IMPORTS, NULL);\n\t\tif (!f) {\n\t\t\tf = r_flag_get_i (core->flags, tgt_addr);\n\t\t}\n\t\tRAnalFunction *fcn = r_anal_get_function_at (core->anal, tgt_addr);\n\t\tif (fcn) {\n\t\t\tif (name) {\n\t\t\t\tret = r_anal_function_rename (fcn, name)? 0: -1;\n\t\t\t} else if (mode == '*') {\n\t\t\t\tr_cons_printf (\"f %s=0x%\" PFMT64x \"\\n\", fcn->name, core->offset);\n\t\t\t} else if (mode == 'j') {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", fcn->name);\n\t\t\t\tpj_ks (pj, \"type\", \"function\");\n\t\t\t\tpj_kn (pj, \"offset\", tgt_addr);\n\t\t\t\tpj_end (pj);\n\t\t\t} else {\n\t\t\t\tr_cons_println (fcn->name);\n\t\t\t}\n\t\t} else if (f) {\n\t\t\tif (name) {\n\t\t\t\tret = r_flag_rename (core->flags, f, name)? 0: -1;\n\t\t\t} else if (mode == '*') {\n\t\t\t\tr_cons_printf (\"f %s=0x%\" PFMT64x \"\\n\", r_str_get (name), core->offset);\n\t\t\t} else if (mode == 'j') {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", f->name);\n\t\t\t\tif (f->realname) {\n\t\t\t\t\tpj_ks (pj, \"realname\", f->realname);\n\t\t\t\t}\n\t\t\t\tpj_ks (pj, \"type\", \"flag\");\n\t\t\t\tpj_kn (pj, \"offset\", tgt_addr);\n\t\t\t\tpj_end (pj);\n\t\t\t} else {\n\t\t\t\tr_cons_println (f->name);\n\t\t\t}\n\t\t} else {\n\t\t\tif (name) {\n\t\t\t\tret = r_flag_set (core->flags, name, tgt_addr, 1)? 0: -1;\n\t\t\t} else if (mode == '*') {\n\t\t\t\tr_cons_printf (\"f %s=0x%\" PFMT64x \"\\n\", r_str_get (name), core->offset);\n\t\t\t} else if (mode == 'j') {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", r_str_get (name));\n\t\t\t\tpj_ks (pj, \"type\", \"address\");\n\t\t\t\tpj_kn (pj, \"offset\", tgt_addr);\n\t\t\t\tpj_end (pj);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", tgt_addr);\n\t\t\t}\n\t\t}\n\t}\nfailure:\n\tif (mode == 'j') {\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\n\tr_anal_op_fini (&op);\n\treturn ret;\n}\n\n// EBP BASED\nstatic int delta_cmp(const void *a, const void *b) {\n\tconst RAnalVar *va = a;\n\tconst RAnalVar *vb = b;\n\treturn vb->delta - va->delta;\n}\n\nstatic int delta_cmp2(const void *a, const void *b) {\n\tconst RAnalVar *va = a;\n\tconst RAnalVar *vb = b;\n\treturn va->delta - vb->delta;\n}\n\nstatic void __cmd_afvf(RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tRListIter *iter;\n\tRAnalVar *p;\n\tRList *list = r_anal_var_all_list (core->anal, fcn);\n\tr_list_sort (list, delta_cmp2);\n\tr_list_foreach (list, iter, p) {\n\t\tif (p->isarg || p->delta > 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *pad = r_str_pad (' ', 10 - strlen (p->name));\n\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %s:%s%s\\n\", (ut64)-p->delta, p->name, pad, p->type);\n\t}\n\tr_list_sort (list, delta_cmp);\n\tr_list_foreach (list, iter, p) {\n\t\tif (!p->isarg && p->delta < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t// TODO: only stack vars if (p->kind == 's') { }\n\t\tconst char *pad = r_str_pad (' ', 10 - strlen (p->name));\n\t\t// XXX this 0x6a is a hack\n\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %s:%s%s\\n\", ((ut64)p->delta) - 0x6a, p->name, pad, p->type);\n\t}\n\tr_list_free (list);\n\n}\n\nstatic int var_cmd(RCore *core, const char *str) {\n\tint delta, type = *str, res = true;\n\tRAnalVar *v1;\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tif (!fcn) {\n\t\tswitch (str[0]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_afv);\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tr_cons_println (\"{}\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_ERROR (\"No function found in current offset\");\n\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t}\n\tif (!str[0]) {\n\t\tif (fcn) {\n\t\t\t// \"afv\"\n\t\t\tr_core_cmd_call (core, \"afvr\");\n\t\t\tr_core_cmd_call (core, \"afvs\");\n\t\t\tr_core_cmd_call (core, \"afvb\");\n\t\t} else {\n\t\t\tR_LOG_WARN (\"Cannot find function in 0x%08\"PFMT64x, core->offset);\n\t\t}\n\t\treturn true;\n\t}\n\tif (str[1] == '?'|| str[0] == '?') {\n\t\tvar_help (core, *str);\n\t\treturn res;\n\t}\n\tPJ *pj = NULL;\n\tif (str[0] == 'j') { // \"afvj\"\n\t\tpj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\treturn false;\n\t\t}\n\t\tpj_o (pj);\n\t\tpj_k (pj, \"reg\");\n\t\tr_anal_var_list_show (core->anal, fcn, 'r', 'j', pj);\n\t\tpj_k (pj, \"sp\");\n\t\tr_anal_var_list_show (core->anal, fcn, 's', 'j', pj);\n\t\tpj_k (pj, \"bp\");\n\t\tr_anal_var_list_show (core->anal, fcn, 'b', 'j', pj);\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t\treturn true;\n\t}\n\tchar *p = strdup (str);\n\tchar *ostr = p;\n\t/* Variable access CFvs = set fun var */\n\tswitch (str[0]) {\n\tcase '-': // \"afv-\"\n\t\tr_core_cmdf (core, \"afvr-%s\", str + 1);\n\t\tr_core_cmdf (core, \"afvs-%s\", str + 1);\n\t\tr_core_cmdf (core, \"afvb-%s\", str + 1);\n\t\treturn true;\n\tcase 'x': // \"afvx\"\n\t\tif (fcn) {\n\t\t\tcmd_afvx (core, fcn, str[1] == 'j');\n\t\t} else {\n\t\t\tR_LOG_WARN (\"Cannot find function in 0x%08\"PFMT64x, core->offset);\n\t\t}\n\t\tfree (ostr);\n\t\treturn true;\n\tcase 'R': // \"afvR\"\n\tcase 'W': // \"afvW\"\n\tcase '*': // \"afv*\"\n\tcase '=': // \"afv=\"\n\t\tif (fcn) {\n\t\t\tconst char *name = strchr (ostr, ' ');\n\t\t\tif (name) {\n\t\t\t\tname = r_str_trim_head_ro (name);\n\t\t\t}\n\t\t\tif (str[1] == 'j') {\n\t\t\t\tpj = r_core_pj_new (core);\n\t\t\t\tif (!pj) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_vars (core, fcn, pj, str[0], name);\n\t\t\tif (str[1] == 'j') {\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find function in 0x%08\"PFMT64x, core->offset);\n\t\t\tfree (ostr);\n\t\t\treturn false;\n\t\t}\n\tcase 'a': // \"afva\"\n\t\tif (fcn) {\n\t\t\tchar *type = r_str_newf (\"func.%s.ret\", fcn->name);\n\t\t\tif (type && sdb_exists (core->anal->sdb_types, type)) {\n\t\t\t\t// if function type exists\n\t\t\t\t// do not analize vars if function has a signature\n\t\t\t} else {\n\t\t\t\tr_anal_function_delete_all_vars (fcn);\n\t\t\t\tr_core_recover_vars (core, fcn, false);\n\t\t\t}\n\t\t\tfree (type);\n\t\t\tfree (p);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find function in 0x%08\"PFMT64x, core->offset);\n\t\t\treturn false;\n\t\t}\n\tcase 'n': // \"afvn\"\n\t\tif (str[1]) {\n\t\t\tRAnalOp *op = r_core_anal_op (core, core->offset, R_ARCH_OP_MASK_BASIC);\n\t\t\tconst char *new_name = r_str_trim_head_ro (strchr (ostr, ' '));\n\t\t\tif (!new_name) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tchar *old_name = strchr (new_name, ' ');\n\t\t\tif (!old_name) {\n\t\t\t\tRAnalVar *var = op ? r_anal_get_used_function_var (core->anal, op->addr) : NULL;\n\t\t\t\tif (var) {\n\t\t\t\t\told_name = var->name;\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot find var @ 0x%08\"PFMT64x, core->offset);\n\t\t\t\t\tr_anal_op_free (op);\n\t\t\t\t\tfree (ostr);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*old_name++ = 0;\n\t\t\t\tr_str_trim (old_name);\n\t\t\t}\n\t\t\tif (fcn) {\n\t\t\t\tv1 = r_anal_function_get_var_byname (fcn, old_name);\n\t\t\t\tif (v1) {\n\t\t\t\t\tr_anal_var_rename (v1, new_name, true);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Cant find var by name\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot find function in 0x%08\"PFMT64x, core->offset);\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_anal_op_free (op);\n\t\t\tfree (ostr);\n\t\t} else {\n\t\t\tRListIter *iter;\n\t\t\tRAnalVar *v;\n\t\t\tRList *list = r_anal_var_all_list (core->anal, fcn);\n\t\t\tr_list_foreach (list, iter, v) {\n\t\t\t\tr_cons_printf (\"%s\\n\", v->name);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t}\n\t\treturn true;\n\tcase 'd': // \"afvd\"\n\t\tif (!fcn) {\n\t\t\tR_LOG_ERROR (\"Cannot find function\");\n\t\t} else if (str[1]) {\n\t\t\tp = strchr (ostr, ' ');\n\t\t\tif (!p) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_str_trim (p);\n\t\t\tv1 = r_anal_function_get_var_byname (fcn, p);\n\t\t\tif (!v1) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_anal_var_display (core->anal, v1);\n\t\t} else {\n\t\t\tRListIter *iter;\n\t\t\tRAnalVar *p;\n\t\t\tRList *list = r_anal_var_all_list (core->anal, fcn);\n\t\t\tr_list_foreach (list, iter, p) {\n\t\t\t\tchar *a = r_core_cmd_strf (core, \".afvd %s\", p->name);\n\t\t\t\tif ((a && !*a) || !a) {\n\t\t\t\t\tfree (a);\n\t\t\t\t\ta = strdup (\"\\n\");\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"%s %s = %s\", p->isarg? \"arg\": \"var\", p->name, a);\n\t\t\t\tfree (a);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t}\n\t\tfree (ostr);\n\t\treturn true;\n\tcase 'f': // \"afvf\"\n\t\t__cmd_afvf (core, ostr);\n\t\tbreak;\n\tcase 't': // \"afvt\"\n\t\tif (fcn) {\n\t\t\tp = strchr (ostr, ' ');\n\t\t\tif (!p++) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tchar *type = strchr (p, ' ');\n\t\t\tif (!type) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t*type++ = 0;\n\t\t\tv1 = r_anal_function_get_var_byname (fcn, p);\n\t\t\tif (!v1) {\n\t\t\t\tR_LOG_ERROR (\"Cant find get by name %s\", p);\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_anal_var_set_type (v1, type);\n\t\t\tfree (ostr);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find function\");\n\t\t\treturn false;\n\t\t}\n\tcase 'b': // \"afvb\"\n\tcase 's': // \"afbs\"\n\tcase 'r': // \"afbr\"\n\t\tbreak;\n\tdefault:\n\t\tif (str[0]) {\n\t\t\tr_core_cmd_help (core, help_msg_afv);\n\t\t\treturn false;\n\t\t}\n\t}\n\tswitch (str[1]) { // afv[bsr]\n\tcase '\\0':\n\tcase '*': // \"afv[bsr]*\"\n\t\tif (fcn) {\n\t\t\tr_anal_var_list_show (core->anal, fcn, type, str[1], NULL);\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find function\");\n\t\t}\n\t\tbreak;\n\tcase 'j':  // \"afv[bsr]j\"\n\t\tpj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\treturn false;\n\t\t}\n\t\tif (fcn) {\n\t\t\tr_anal_var_list_show (core->anal, fcn, type, str[1], pj);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"No function\");\n\t\t}\n\t\tpj_free (pj);\n\t\tbreak;\n\tcase '.': // \"afv[bsr].\"\n\t\tr_anal_var_list_show (core->anal, fcn, core->offset, 0, NULL);\n\t\tbreak;\n\tcase '-': // \"afv[bsr]-\"\n\t\tif (!fcn) {\n\t\t\tR_LOG_ERROR (\"afv: Cannot find function\");\n\t\t\treturn false;\n\t\t}\n\t\tif (str[2] == '*') {\n\t\t\tr_anal_function_delete_vars_by_kind (fcn, type);\n\t\t} else {\n\t\t\tRAnalVar *var = NULL;\n\t\t\tif (IS_DIGIT (str[2])) {\n\t\t\t\tvar = r_anal_function_get_var (fcn, type, (int)r_num_math (core->num, str + 1));\n\t\t\t} else {\n\t\t\t\tchar *name = r_str_trim_dup (str + 2);\n\t\t\t\tif (name) {\n\t\t\t\t\tvar = r_anal_function_get_var_byname (fcn, name);\n\t\t\t\t\tr_free (name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_delete (var);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 's': // \"afv[bsr]s\" // \"afvs\"\n\tcase 'g': // \"afv[bsr]g\"\n\t\tif (str[2]) {\n\t\t\tint idx = r_num_math (core->num, str + 2);\n\t\t\tchar *vaddr;\n\t\t\tp = strchr (ostr, ' ');\n\t\t\tif (!p) {\n\t\t\t\tvar_help (core, type);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_str_trim (p);\n\t\t\tut64 addr = core->offset;\n\t\t\tif ((vaddr = strchr (p, ' '))) {\n\t\t\t\taddr = r_num_math (core->num, vaddr);\n\t\t\t}\n\t\t\tRAnalVar *var = r_anal_function_get_var (fcn, str[0], idx);\n\t\t\tif (!var) {\n\t\t\t\tR_LOG_ERROR (\"Cannot find variable with delta %d\", idx);\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint rw = (str[1] == 'g') ? R_ANAL_VAR_ACCESS_TYPE_READ : R_ANAL_VAR_ACCESS_TYPE_WRITE;\n\t\t\tint ptr = *var->type == 's' ? idx - fcn->maxstack : idx;\n\t\t\tRAnalOp *op = r_core_anal_op (core, addr, 0);\n\t\t\tconst char *ireg = op ? op->ireg : NULL;\n\t\t\tr_anal_var_set_access (var, ireg, addr, rw, ptr);\n\t\t\tr_anal_op_free (op);\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Missing argument\");\n\t\t}\n\t\tbreak;\n\tcase ' ': { // \"afvs\" \"afvb\" \"afvr\"\n\t\tbool isarg = false;\n\t\tconst int size = 4;\n\t\tp = strchr (ostr, ' ');\n\t\tif (!p) {\n\t\t\tvar_help (core, type);\n\t\t\tbreak;\n\t\t}\n\t\tif (!fcn) {\n\t\t\tR_LOG_ERROR (\"Missing function at 0x%08\" PFMT64x, core->offset);\n\t\t\tbreak;\n\t\t}\n\t\t*p++ = 0;\n\t\tr_str_trim_head (p);\n\t\tchar *name = strchr (p, ' ');\n\t\tif (!name) {\n\t\t\tR_LOG_ERROR (\"Missing name\");\n\t\t\tbreak;\n\t\t}\n\t\t*name++ = 0;\n\t\tr_str_trim_head (name);\n\n\t\tif (type == 'r') { //registers\n\t\t\tRRegItem *ri = r_reg_get (core->anal->reg, p, -1);\n\t\t\tif (!ri) {\n\t\t\t\tR_LOG_ERROR (\"Register not found\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdelta = ri->index;\n\t\t\tisarg = true;\n\t\t\tr_unref (ri);\n\t\t} else {\n\t\t\tdelta = r_num_math (core->num, p);\n\t\t}\n\n\t\tchar *vartype = strchr (name, ' ');\n\t\tif (!vartype) {\n\t\t\tvartype = \"int\";\n\t\t} else {\n\t\t\t*vartype++ = 0;\n\t\t\tr_str_trim (vartype);\n\t\t}\n\t\tif (type == 'b') {\n\t\t\tdelta -= fcn->bp_off;\n\t\t}\n\t\tif ((type == 'b') && delta > 0) {\n\t\t\tisarg = true;\n\t\t} else if (type == 's' && delta > fcn->maxstack) {\n\t\t\tisarg = true;\n\t\t}\n\t\tr_anal_function_set_var (fcn, delta, type, vartype, size, isarg, name);\n \t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_afv);\n\t\tbreak;\n\t}\n\tfree (ostr);\n\treturn res;\n}\n\nstatic void print_trampolines(RCore *core, ut64 a, ut64 b, size_t element_size) {\n\tint i;\n\tfor (i = 0; i < core->blocksize; i += element_size) {\n\t\tut32 n;\n\t\tmemcpy (&n, core->block + i, sizeof (ut32));\n\t\tif (n >= a && n <= b) {\n\t\t\tif (element_size == 4) {\n\t\t\t\tr_cons_printf (\"f trampoline.%x @ 0x%\" PFMT64x \"\\n\", n, core->offset + i);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"f trampoline.%\" PFMT32x \" @ 0x%\" PFMT64x \"\\n\", n, core->offset + i);\n\t\t\t}\n\t\t\tr_cons_printf (\"Cd %u @ 0x%\" PFMT64x \":%u\\n\", (unsigned int)element_size, core->offset + i, (unsigned int)element_size);\n\t\t\t// TODO: add data xrefs\n\t\t}\n\t}\n}\n\nstatic void cmd_anal_trampoline(RCore *core, const char *input) {\n\tint bits = r_config_get_i (core->config, \"asm.bits\");\n\tchar *p, *inp = strdup (input);\n\tp = strchr (inp, ' ');\n\tif (p) {\n\t\t*p = 0;\n\t}\n\tut64 a = r_num_math (core->num, inp);\n\tut64 b = p? r_num_math (core->num, p + 1): 0;\n\tfree (inp);\n\n\tswitch (bits) {\n\tcase 32:\n\t\tprint_trampolines (core, a, b, 4);\n\t\tbreak;\n\tcase 64:\n\t\tprint_trampolines (core, a, b, 8);\n\t\tbreak;\n\t}\n}\n\nstatic const char *syscallNumber(char *snstr, int n) {\n\tsnprintf (snstr, 32, (n>1000)?\"0x%x\": \"%d\", n);\n\treturn snstr;\n}\n\nR_API char *cmd_syscall_dostr(RCore *core, st64 n, ut64 addr) {\n\tint i;\n\tchar str[64], snstr[32];\n\tst64 N = n;\n\tint defVector = r_syscall_get_swi (core->anal->syscall);\n\tif (defVector > 0) {\n\t\tn = -1;\n\t}\n\tif (n == -1 || defVector > 0) {\n\t\tn = (int)r_debug_reg_get (core->dbg, \"oeax\");\n\t\tif (!n || n == -1) {\n\t\t\tconst char *a0 = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n\t\t\tn = (a0 == NULL)? -1: (int)r_debug_reg_get (core->dbg, a0);\n\t\t}\n\t}\n\tRSyscallItem *item = r_syscall_get (core->anal->syscall, n, defVector);\n\tif (!item) {\n\t\titem =  r_syscall_get (core->anal->syscall, N, -1);\n\t}\n\tif (!item) {\n\t\treturn r_str_newf (\"%s = unknown ()\", syscallNumber (snstr, n));\n\t}\n\tchar *res = r_str_newf (\"%s = %s (\", syscallNumber (snstr, item->num), item->name);\n\t// TODO: move this to r_syscall\n\tconst char *cc = r_anal_syscc_default (core->anal);\n\t//TODO replace the hardcoded CC with the sdb ones\n\tfor (i = 0; i < item->args; i++) {\n\t\t// XXX this is a hack to make syscall args work on x86-32 and x86-64\n\t\t// we need to shift sn first.. which is bad, but needs to be redesigned\n\t\tint regidx = i;\n\t\tif (core->rasm->config->bits == 32 && !strcmp (core->rasm->config->arch, \"x86\")) {\n\t\t\tregidx++;\n\t\t}\n\t\tut64 arg = r_debug_arg_get (core->dbg, cc, regidx);\n\t\t//r_cons_printf (\"(%d:0x%\"PFMT64x\")\\n\", i, arg);\n\t\tif (item->sargs) {\n\t\t\tswitch (item->sargs[i]) {\n\t\t\tcase 'p': // pointer\n\t\t\t\tres = r_str_appendf (res, \"0x%08\" PFMT64x, arg);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tres = r_str_appendf (res, \"%\" PFMT64u \"\", arg);\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tmemset (str, 0, sizeof (str));\n\t\t\t\tr_io_read_at (core->io, arg, (ut8 *)str, sizeof (str) - 1);\n\t\t\t\tr_str_filter (str, strlen (str));\n\t\t\t\tres = r_str_appendf (res, \"\\\"%s\\\"\", str);\n\t\t\t\tbreak;\n\t\t\tcase 'Z': {\n\t\t\t\t//TODO replace the hardcoded CC with the sdb ones\n\t\t\t\tut64 len = r_debug_arg_get (core->dbg, cc, i + 2);\n\t\t\t\tlen = R_MIN (len + 1, sizeof (str) - 1);\n\t\t\t\tif (len == 0) {\n\t\t\t\t\tlen = 16; // override default\n\t\t\t\t}\n\t\t\t\t(void)r_io_read_at (core->io, arg, (ut8 *)str, len);\n\t\t\t\tstr[len] = 0;\n\t\t\t\tr_str_filter (str, -1);\n\t\t\t\tres = r_str_appendf (res, \"\\\"%s\\\"\", str);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tres = r_str_appendf (res, \"0x%08\" PFMT64x, arg);\n\t\t\t}\n\t\t} else {\n\t\t\tres = r_str_appendf (res, \"0x%08\" PFMT64x, arg);\n\t\t}\n\t\tif (i + 1 < item->args) {\n\t\t\tres = r_str_append (res, \", \");\n\t\t}\n\t}\n\tr_syscall_item_free (item);\n\treturn r_str_append (res, \")\");\n}\n\nstatic bool mw(REsil *esil, ut64 addr, const ut8 *buf, int len) {\n\tint *ec = (int*)esil->user;\n\t*ec += (len * 2);\n\treturn true;\n}\n\nstatic bool mr(REsil *esil, ut64 addr, ut8 *buf, int len) {\n\tint *ec = (int*)esil->user;\n\t*ec += len;\n\treturn true;\n}\n\nstatic int esil_cost(RCore *core, ut64 addr, const char *expr) {\n\tif (R_STR_ISEMPTY (expr)) {\n\t\treturn 0;\n\t}\n\tint ec = 0;\n\tREsil *e = r_esil_new (256, 0, 0);\n\tr_esil_setup (e, core->anal, false, false, false);\n\te->user = &ec;\n\te->cb.mem_read = mr;\n\te->cb.mem_write = mw;\n\tr_esil_parse (e, expr);\n\tr_esil_free (e);\n\treturn ec;\n}\n\nstatic void cmd_syscall_do(RCore *core, st64 n, ut64 addr) {\n\tchar *msg = cmd_syscall_dostr (core, n, addr);\n\tif (msg) {\n\t\tr_cons_println (msg);\n\t\tfree (msg);\n\t}\n}\n\nstatic inline REsil *esil_new_setup(RCore *core) {\n\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\tbool iotrap = r_config_get_b (core->config, \"esil.iotrap\");\n\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\tREsil *esil = r_esil_new (stacksize, iotrap, addrsize);\n\tif (esil) {\n\t\tesil->anal = core->anal;\n\t\tr_io_bind (core->io, &(core->anal->iob));\n\t\tbool romem = r_config_get_b (core->config, \"esil.romem\");\n\t\tbool stats = r_config_get_b (core->config, \"esil.stats\");\n\t\tbool nonull = r_config_get_b (core->config, \"esil.nonull\");\n\t\tr_esil_setup (esil, core->anal, romem, stats, nonull);\n\t\tesil->verbose = r_config_get_i (core->config, \"esil.verbose\");\n\t\tesil->cmd = r_core_esil_cmd;\n\t\tconst char *et = r_config_get (core->config, \"cmd.esil.trap\");\n\t\tesil->cmd_trap = R_STR_ISNOTEMPTY (et)? strdup (et): NULL;\n\n\t}\n\treturn esil;\n}\n\nstatic void val_tojson(PJ *pj, RAnalValue *val) {\n\tchar *s = r_anal_value_tostring (val);\n\tpj_o (pj);\n\tpj_ks (pj, \"name\", s);\n\tfree (s);\n\tpj_ks (pj, \"type\", r_anal_value_type_tostring (val));\n\tif (val->access) {\n\t\tpj_ks (pj, \"access\", (val->access & R_PERM_W)? \"rw\": \"ro\");\n\t}\n\tif (val->absolute) {\n\t\tpj_kn (pj, \"absolute\", val->absolute);\n\t}\n\tif (val->imm) {\n\t\tpj_kn (pj, \"imm\", val->imm);\n\t}\n\tif (val->delta) {\n\t\tpj_kn (pj, \"delta\", val->delta);\n\t}\n\tif (val->mul) {\n\t\tpj_kn (pj, \"mul\", val->mul);\n\t}\n\tpj_end (pj);\n}\n\n\nstatic bool mw2(REsil *esil, ut64 addr, const ut8 *buf, int len) {\n\tr_cons_printf (\"WRITE 0x%08\"PFMT64x\" %d\\n\", addr, len);\n\treturn true;\n}\n\nstatic bool mr2(REsil *esil, ut64 addr, ut8 *buf, int len) {\n\tr_cons_printf (\"READ 0x%08\"PFMT64x\" %d\\n\", addr, len);\n\treturn true;\n}\n\nstatic void esilmemrefs(RCore *core, const char *expr) {\n\tREsil *e = r_esil_new (256, 0, 0);\n\tr_esil_setup (e, core->anal, false, false, false);\n\te->cb.mem_read = mr2;\n\te->cb.mem_write = mw2;\n\tr_esil_parse (e, expr);\n\tr_esil_free (e);\n}\n\nstatic void core_anal_bytes(RCore *core, const ut8 *buf, int len, int nops, int fmt) {\n\tbool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->rasm->config);\n\tbool use_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\tcore->parser->subrel = r_config_get_i (core->config, \"asm.sub.rel\");\n\tint ret, i, j, idx, size;\n\tconst char *color = \"\";\n\tconst char *esilstr;\n\tconst char *opexstr;\n\tRAnalHint *hint;\n\tRAnalOp op = {0};\n\tut64 addr;\n\tPJ *pj = NULL;\n\tint totalsize = 0;\n#if 1\n\tREsil *esil = r_esil_new (256, 0, 0);\n\tr_esil_setup (esil, core->anal, false, false, false);\n\tesil->user = &core;\n\tesil->cb.mem_read = mr;\n\tesil->cb.mem_write = mw;\n#else\n\tREsil *esil = core->anal->esil;\n\t//esil->user = &ec;\n\tesil->cb.mem_read = mr;\n\tesil->cb.mem_write = mw;\n#endif\n\n\t// Variables required for setting up ESIL to REIL conversion\n\tif (use_color) {\n\t\tcolor = core->cons->context->pal.label;\n\t}\n\tswitch (fmt) {\n\tcase 'j': {\n\t\tpj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\tbreak;\n\t\t}\n\t\tpj_a (pj);\n\t\tbreak;\n\t}\n\t}\n\tconst bool smart_mask = r_config_get_b (core->config, \"anal.mask\");\n\tfor (i = idx = ret = 0; idx < len && (!nops || (nops && i < nops)); i++, idx += ret) {\n\t\tRAnalOp asmop = {0};\n\t\taddr = core->offset + idx;\n\t\tr_asm_set_pc (core->rasm, addr);\n\t\thint = r_anal_hint_get (core->anal, addr);\n\t\tret = r_anal_op (core->anal, &op, addr, buf + idx, len - idx,\n\t\t\tR_ARCH_OP_MASK_ESIL | R_ARCH_OP_MASK_OPEX | R_ARCH_OP_MASK_HINT | R_ARCH_OP_MASK_DISASM);\n\t\t(void)r_asm_disassemble (core->rasm, &asmop, buf + idx, len - idx);\n\t\tesilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\topexstr = R_STRBUF_SAFEGET (&op.opex);\n\t\tchar *mnem = strdup (r_str_get (r_asm_op_get_asm (&asmop)));\n\t\tchar *sp = strchr (mnem, ' ');\n\t\tif (sp) {\n\t\t\t*sp = 0;\n\t\t\tif (op.prefix) {\n\t\t\t\tchar *arg = strdup (sp + 1);\n\t\t\t\tchar *sp = strchr (arg, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\t*sp = 0;\n\t\t\t\t}\n\t\t\t\tfree (mnem);\n\t\t\t\tmnem = arg;\n\t\t\t}\n\t\t}\n\t\tif (ret < 1 && fmt != 'd') {\n\t\t\tret = op.size;\n#if 0\n\t\t\tRStrBuf *sb = r_strbuf_new (\"\");\n\t\t\tfor (i = idx, j = 0; i < core->blocksize && j < 3; i++, j++) {\n\t\t\t\tr_strbuf_appendf (sb, \"%02x \", buf[i]);\n\t\t\t}\n\t\t\tR_LOG_ERROR (\"Oops at 0x%08\" PFMT64x \" (%s...)\", core->offset + idx, r_strbuf_get (sb));\n\t\t\tr_strbuf_free (sb);\n\t\t\tfree (mnem);\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tsize = op.size;\n\t\tif (fmt == 'd') {\n\t\t\tchar *opname = strdup (r_asm_op_get_asm (&asmop));\n\t\t\tif (opname) {\n\t\t\t\tr_str_split (opname, ' ');\n\t\t\t\tchar *d = r_asm_describe (core->rasm, opname);\n\t\t\t\tif (R_STR_ISNOTEMPTY (d)) {\n\t\t\t\t\tr_cons_printf (\"%s: %s\\n\", opname, d);\n\t\t\t\t\tfree (d);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Unknown opcode at 0x%08\"PFMT64x, addr);\n\t\t\t\t}\n\t\t\t\tfree (opname);\n\t\t\t}\n\t\t} else if (fmt == 'm') {\n\t\t\tesilmemrefs (core, esilstr);\n\t\t} else if (fmt == 'E') {\n\t\t\tr_cons_printf (\"%s\\n\", esilstr);\n\t\t} else if (fmt == 'e') {\n\t\t\tif (R_STR_ISNOTEMPTY (esilstr)) {\n\t\t\t\tif (use_color) {\n\t\t\t\t\tr_cons_printf (\"%s0x%\" PFMT64x Color_RESET \" %s\\n\", color, core->offset + idx, esilstr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \" %s\\n\", core->offset + idx, esilstr);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (fmt == 's') {\n\t\t\ttotalsize += op.size;\n\t\t} else if (fmt == '*') {\n\t\t\t// TODO: ao* useful for wat? wx [bytes] ?\n\t\t} else if (fmt == 'j') {\n\t\t\tchar strsub[128] = {0};\n\t\t\t// pc+33\n\t\t\tr_parse_subvar (core->parser, NULL,\n\t\t\t\tcore->offset + idx,\n\t\t\t\tasmop.size, r_asm_op_get_asm (&asmop),\n\t\t\t\tstrsub, sizeof (strsub));\n\t\t\t\tut64 killme = UT64_MAX;\n\t\t\t\tif (r_io_read_i (core->io, op.ptr, &killme, op.refptr, be)) {\n\t\t\t\t\tcore->parser->subrel_addr = killme;\n\t\t\t\t}\n\t\t\t// 0x33->sym.xx\n\t\t\tchar *p = strdup (strsub);\n\t\t\tif (p) {\n\t\t\t\tr_parse_filter (core->parser, addr, core->flags, hint, p,\n\t\t\t\t\t\tstrsub, sizeof (strsub), be);\n\t\t\t\tfree (p);\n\t\t\t}\n\t\t\tpj_o (pj);\n\t\t\tpj_ks (pj, \"opcode\", r_asm_op_get_asm (&asmop));\n\t\t\tif (!*strsub) {\n\t\t\t\tr_str_ncpy (strsub, r_asm_op_get_asm (&asmop), sizeof (strsub) -1 );\n\t\t\t}\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_parse_subvar (core->parser, fcn, addr, asmop.size,\n\t\t\t\t\t\t\tstrsub, strsub, sizeof (strsub));\n\t\t\t\t}\n\t\t\t}\n\t\t\tpj_ks (pj, \"disasm\", strsub);\n\t\t\t// apply pseudo if needed\n\t\t\t{\n\t\t\t\tchar *pseudo = calloc (128 + strlen (strsub), 3);\n\t\t\t\tr_parse_parse (core->parser, strsub, pseudo);\n\t\t\t\tif (pseudo && *pseudo) {\n\t\t\t\t\tpj_ks (pj, \"pseudo\", pseudo);\n\t\t\t\t}\n\t\t\t\tfree (pseudo);\n\t\t\t}\n\t\t\t{\n\t\t\t\tchar *opname = strdup (strsub);\n\t\t\t\tchar *sp = strchr (opname, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\t*sp = 0;\n\t\t\t\t}\n\t\t\t\tchar *d = r_asm_describe (core->rasm, opname);\n\t\t\t\tif (d && *d) {\n\t\t\t\t\tpj_ks (pj, \"description\", d);\n\t\t\t\t}\n\t\t\t\tfree (d);\n\t\t\t\tfree (opname);\n\t\t\t}\n\n\t\t\tif (r_vector_length (&op.srcs) > 0) {\n\t\t\t\tpj_ka (pj, \"srcs\");\n\t\t\t\tRAnalValue *val;\n\t\t\t\tr_vector_foreach (&op.srcs, val) {\n\t\t\t\t\tval_tojson (pj, val);\n\t\t\t\t}\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\n\t\t\tif (r_vector_length (&op.dsts) > 0) {\n\t\t\t\tpj_ka (pj, \"dsts\");\n\t\t\t\tRAnalValue *val;\n\t\t\t\tr_vector_foreach (&op.dsts, val) {\n\t\t\t\t\tval_tojson (pj, val);\n\t\t\t\t}\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\n\t\t\tpj_ks (pj, \"mnemonic\", mnem);\n\t\t\tif (smart_mask) {\n\t\t\t\tchar *maskstr = r_core_cmd_strf (core, \"aobm@0x%08\"PFMT64x, op.addr);\n\t\t\t\tpj_ks (pj, \"mask\", maskstr);\n\t\t\t\tfree (maskstr);\n\t\t\t} else {\n\t\t\t\tut8 *mask = r_anal_mask (core->anal, len - idx, buf + idx, core->offset + idx);\n\t\t\t\tchar *maskstr = r_hex_bin2strdup (mask, size);\n\t\t\t\tpj_ks (pj, \"mask\", maskstr);\n\t\t\t\tfree (mask);\n\t\t\t\tfree (maskstr);\n\t\t\t}\n\t\t\tif (hint && hint->opcode) {\n\t\t\t\tpj_ks (pj, \"ophint\", hint->opcode);\n\t\t\t}\n\t\t\tif (hint && hint->jump != UT64_MAX) {\n\t\t\t\top.jump = hint->jump;\n\t\t\t}\n\t\t\tif (hint && hint->fail != UT64_MAX) {\n\t\t\t\top.fail = hint->fail;\n\t\t\t}\n\t\t\tif (op.jump != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"jump\", op.jump);\n\t\t\t}\n\t\t\tif (op.fail != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"fail\", op.fail);\n\t\t\t}\n\t\t\tconst char *jesil = (hint && hint->esil) ? hint->esil: esilstr;\n\t\t\tif (jesil && *jesil) {\n\t\t\t\tpj_ks (pj, \"esil\", jesil);\n\t\t\t}\n\t\t\tpj_kb (pj, \"sign\", op.sign);\n\t\t\tif (op.prefix > 0) {\n\t\t\t\tpj_kn (pj, \"prefix\", op.prefix);\n\t\t\t}\n\t\t\tpj_ki (pj, \"id\", op.id);\n\t\t\tif (op.vliw > 0) {\n\t\t\t\tpj_ki (pj, \"id\", op.vliw);\n\t\t\t}\n\t\t\tif (opexstr && *opexstr) {\n\t\t\t\tpj_k (pj, \"opex\");\n\t\t\t\tpj_j (pj, opexstr);\n\t\t\t}\n\t\t\tpj_kn (pj, \"addr\", core->offset + idx);\n\t\t\t{\n\t\t\t\tchar *bytes = r_hex_bin2strdup (buf + idx, size);\n\t\t\t\tpj_ks (pj, \"bytes\", bytes);\n\t\t\t\tfree (bytes);\n\t\t\t}\n\t\t\tif (op.val != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"val\", op.val);\n\t\t\t}\n\t\t\tif (op.disp && op.disp != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"disp\", op.disp);\n\t\t\t}\n\t\t\tif (op.ptr != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"ptr\", op.ptr);\n\t\t\t}\n\t\t\tpj_ki (pj, \"size\", size);\n\t\t\tpj_ks (pj, \"type\", r_anal_optype_tostring (op.type));\n\t\t\t{\n\t\t\t\tconst char *datatype = r_anal_datatype_tostring (op.datatype);\n\t\t\t\tif (datatype) {\n\t\t\t\t\tpj_ks (pj, \"datatype\", datatype);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (esilstr) {\n\t\t\t\tint ec = esil_cost (core, addr, esilstr);\n\t\t\t\tpj_ki (pj, \"esilcost\", ec);\n\t\t\t}\n\t\t\tif (op.reg) {\n\t\t\t\tpj_ks (pj, \"reg\", op.reg);\n\t\t\t}\n\t\t\tif (op.ireg) {\n\t\t\t\tpj_ks (pj, \"ireg\", op.ireg);\n\t\t\t}\n\t\t\tif (op.scale > 0) {\n\t\t\t\tpj_ki (pj, \"scale\", op.scale);\n\t\t\t}\n\t\t\tif (op.refptr != -1 && op.refptr > 0) {\n\t\t\t\tpj_ki (pj, \"refptr\", op.refptr);\n\t\t\t}\n\t\t\tpj_ki (pj, \"cycles\", op.cycles);\n\t\t\tpj_ki (pj, \"failcycles\", op.failcycles);\n\t\t\tpj_ki (pj, \"delay\", op.delay);\n\t\t\tconst char *p1 = r_anal_stackop_tostring (op.stackop);\n\t\t\tif (strcmp (p1, \"null\")) {\n\t\t\t\tpj_ks (pj, \"stack\", p1);\n\t\t\t}\n\t\t\tpj_kn (pj, \"stackptr\", op.stackptr);\n\t\t\tif (op.direction != 0) {\n\t\t\t\tpj_ks (pj, \"direction\", r_anal_op_direction_tostring (&op));\n\t\t\t}\n\t\t\tconst char *arg = (op.type & R_ANAL_OP_TYPE_COND)\n\t\t\t\t? r_anal_cond_type_tostring (op.cond): NULL;\n\t\t\tif (arg) {\n\t\t\t\tpj_ks (pj, \"cond\", arg);\n\t\t\t}\n\t\t\tpj_ks (pj, \"family\", r_anal_op_family_tostring (op.family));\n\t\t\tpj_end (pj);\n\t\t} else if (fmt == 'r') {\n\t\t\tif (R_STR_ISNOTEMPTY (esilstr)) {\n\t\t\t\tif (use_color) {\n\t\t\t\t\tr_cons_printf (\"%s0x%\" PFMT64x Color_RESET \" %s\\n\", color, core->offset + idx, esilstr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \" %s\\n\", core->offset + idx, esilstr);\n\t\t\t\t}\n\t\t\t\tr_esil_parse (core->anal->esil, esilstr);\n\t\t\t\tr_esil_dumpstack (core->anal->esil);\n\t\t\t\tr_esil_stack_free (core->anal->esil);\n\t\t\t} else {\n\t\t\t\t// ignored/skipped eprintf (\"No esil for '%s'\\n\", op.mnemonic);\n\t\t\t}\n\t\t} else {\n\t\t\tchar disasm[128] = {0};\n\t\t\tchar *text = r_asm_op_get_asm (&asmop);\n\t\t\tif (!text) {\n\t\t\t\tR_LOG_ERROR (\"invalid\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_parse_subvar (core->parser, NULL,\n\t\t\t\tcore->offset + idx,\n\t\t\t\tasmop.size,  text,\n\t\t\t\tdisasm, sizeof (disasm));\n\t\t\tut64 killme = UT64_MAX;\n\t\t\tif (r_io_read_i (core->io, op.ptr, &killme, op.refptr, be)) {\n\t\t\t\tcore->parser->subrel_addr = killme;\n\t\t\t}\n\t\t\tchar *p = strdup (disasm);\n\t\t\tif (p) {\n\t\t\t\tr_parse_filter (core->parser, addr, core->flags, hint, p,\n\t\t\t\t\tdisasm, sizeof (disasm), be);\n\t\t\t\tfree (p);\n\t\t\t}\n#define printline(k, fmt, arg)\\\n\t{ \\\n\t\tif (use_color)\\\n\t\t\tr_cons_printf (\"%s%s: \" Color_RESET, color, k);\\\n\t\telse\\\n\t\t\tr_cons_printf (\"%s: \", k);\\\n\t\tif (fmt) r_cons_printf (fmt, arg);\\\n\t}\n\t\t\tprintline (\"address\", \"0x%\" PFMT64x \"\\n\", core->offset + idx);\n\t\t\tprintline (\"opcode\", \"%s\\n\", r_asm_op_get_asm (&asmop));\n\t\t\tif (!*disasm) {\n\t\t\t\tr_str_ncpy (disasm, r_asm_op_get_asm (&asmop), sizeof (disasm) - 1);\n\t\t\t}\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_parse_subvar (core->parser, fcn, addr, asmop.size,\n\t\t\t\t\t\t\tdisasm, disasm, sizeof (disasm));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (esilstr) {\n\t\t\t\tint ec = esil_cost (core, addr, esilstr);\n\t\t\t\tprintline (\"esilcost\", \"%d\\n\", ec);\n\t\t\t}\n\t\t\tprintline (\"disasm\", \"%s\\n\", disasm);\n\t\t\t{\n\t\t\t\tchar *pseudo = calloc (128 + strlen (disasm), 3);\n\t\t\t\tr_parse_parse (core->parser, disasm, pseudo);\n\t\t\t\tif (pseudo && *pseudo) {\n\t\t\t\t\tprintline (\"pseudo\", \"%s\\n\", pseudo);\n\t\t\t\t}\n\t\t\t\tfree (pseudo);\n\t\t\t}\n\t\t\tprintline (\"mnemonic\", \"%s\\n\", mnem);\n\t\t\t{\n\t\t\t\tchar *opname = strdup (disasm);\n\t\t\t\tchar *sp = strchr (opname, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\t*sp = 0;\n\t\t\t\t}\n\t\t\t\tchar *d = r_asm_describe (core->rasm, opname);\n\t\t\t\tif (d && *d) {\n\t\t\t\t\tprintline (\"description\", \"%s\\n\", d);\n\t\t\t\t}\n\t\t\t\tfree (d);\n\t\t\t\tfree (opname);\n\t\t\t}\n\t\t\t{\n\t\t\t\tut8 *mask = r_anal_mask (core->anal, len - idx, buf + idx, core->offset + idx);\n\t\t\t\tif (smart_mask) {\n\t\t\t\t\tchar *maskstr = r_core_cmd_strf (core, \"aobm@0x%08\"PFMT64x, op.addr);\n\t\t\t\t\tr_str_trim (maskstr);\n\t\t\t\t\tprintline (\"mask\", \"%s\\n\", maskstr);\n\t\t\t\t\tfree (maskstr);\n\t\t\t\t} else {\n\t\t\t\t\tchar *maskstr = r_hex_bin2strdup (mask, size);\n\t\t\t\t\tprintline (\"mask\", \"%s\\n\", maskstr);\n\t\t\t\t\tfree (maskstr);\n\t\t\t\t}\n\t\t\t\tfree (mask);\n\t\t\t}\n\t\t\tif (hint) {\n\t\t\t\tif (hint->opcode) {\n\t\t\t\t\tprintline (\"ophint\", \"%s\\n\", hint->opcode);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op.prefix > 0) {\n\t\t\t\tprintline (\"prefix\", \"%u\\n\", op.prefix);\n\t\t\t}\n\t\t\tprintline (\"id\", \"%d\\n\", op.id);\n\t\t\tif (op.vliw > 0) {\n\t\t\t\tprintline (\"id\", \"%d\\n\", op.vliw);\n\t\t\t}\n#if 0\n// no opex here to avoid lot of tests broken..and having json in here is not much useful imho\n\t\t\tif (R_STR_ISNOTEMPTY (opexstr)) {\n\t\t\t\tprintline (\"opex\", \"%s\\n\", opexstr);\n\t\t\t}\n#endif\n\t\t\tprintline (\"bytes\", \"%s\", \"\");\n\t\t\tint minsz = R_MIN (len, size);\n\t\t\tminsz = R_MAX (minsz, 0);\n\t\t\tfor (j = 0; j < minsz; j++) {\n\t\t\t\tr_cons_printf (\"%02x\", buf[idx + j]);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tif (op.val != UT64_MAX) {\n\t\t\t\tprintline (\"val\", \"0x%08\" PFMT64x \"\\n\", op.val);\n\t\t\t}\n\t\t\tif (op.ptr != UT64_MAX) {\n\t\t\t\tprintline (\"ptr\", \"0x%08\" PFMT64x \"\\n\", op.ptr);\n\t\t\t}\n\t\t\tif (op.disp && op.disp != UT64_MAX) {\n\t\t\t\t// printline (\"disp\", \"0x%08\" PFMT64x \"\\n\", op.disp);\n\t\t\t\tprintline (\"disp\", \"%\" PFMT64d \"\\n\", op.disp);\n\t\t\t}\n\t\t\tif (op.refptr != -1 && op.refptr > 0) {\n\t\t\t\tprintline (\"refptr\", \"%d\\n\", op.refptr);\n\t\t\t}\n\t\t\tprintline (\"size\", \"%d\\n\", size);\n\t\t\tprintline (\"sign\", \"%s\\n\", r_str_bool (op.sign));\n\t\t\tprintline (\"type\", \"%s\\n\", r_anal_optype_tostring (op.type));\n\t\t\tconst char *datatype = r_anal_datatype_tostring (op.datatype);\n\t\t\tif (datatype) {\n\t\t\t\tprintline (\"datatype\", \"%s\\n\", datatype);\n\t\t\t}\n\t\t\tprintline (\"cycles\", \"%d\\n\", op.cycles);\n\t\t\tif (op.failcycles) {\n\t\t\t\tprintline (\"failcycles\", \"%d\\n\", op.failcycles);\n\t\t\t}\n\t\t\tif (op.type2) {\n\t\t\t\tprintline (\"type2\", \"0x%x\\n\", op.type2);\n\t\t\t}\n\t\t\tif (op.reg) {\n\t\t\t\tprintline (\"reg\", \"%s\\n\", op.reg);\n\t\t\t}\n\t\t\tif (op.ireg) {\n\t\t\t\tprintline (\"ireg\", \"%s\\n\", op.ireg);\n\t\t\t}\n\t\t\tif (op.scale > 0) {\n\t\t\t\tprintline (\"scale\", \"%d\\n\", op.scale);\n\t\t\t}\n\t\t\tif (hint && hint->esil) {\n\t\t\t\tprintline (\"esil\", \"%s\\n\", hint->esil);\n\t\t\t} else if (R_STR_ISNOTEMPTY (esilstr)) {\n\t\t\t\tprintline (\"esil\", \"%s\\n\", esilstr);\n\t\t\t}\n\t\t\tif (hint && hint->jump != UT64_MAX) {\n\t\t\t\top.jump = hint->jump;\n\t\t\t}\n\t\t\tif (op.jump != UT64_MAX) {\n\t\t\t\tprintline (\"jump\", \"0x%08\" PFMT64x \"\\n\", op.jump);\n\t\t\t}\n\t\t\tif (op.direction != 0) {\n\t\t\t\tprintline (\"direction\", \"%s\\n\", r_anal_op_direction_tostring (&op));\n\t\t\t}\n\t\t\tif (hint && hint->fail != UT64_MAX) {\n\t\t\t\top.fail = hint->fail;\n\t\t\t}\n\t\t\tif (op.fail != UT64_MAX) {\n\t\t\t\tprintline (\"fail\", \"0x%08\" PFMT64x \"\\n\", op.fail);\n\t\t\t}\n\t\t\tif (op.delay) {\n\t\t\t\tprintline (\"delay\", \"%d\\n\", op.delay);\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst char *arg = (op.type & R_ANAL_OP_TYPE_COND)?  r_anal_cond_type_tostring (op.cond): NULL;\n\t\t\t\tif (arg) {\n\t\t\t\t\tprintline (\"cond\", \"%s\\n\", arg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintline (\"family\", \"%s\\n\", r_anal_op_family_tostring (op.family));\n\t\t\tif (op.stackop != R_ANAL_STACK_NULL) {\n\t\t\t\tprintline (\"stackop\", \"%s\\n\", r_anal_stackop_tostring (op.stackop));\n\t\t\t}\n\t\t\tif (op.stackptr) {\n\t\t\t\tprintline (\"stackptr\", \"%\"PFMT64u\"\\n\", op.stackptr);\n\t\t\t}\n\t\t}\n\t\t//r_cons_printf (\"false: 0x%08\"PFMT64x\"\\n\", core->offset+idx);\n\t\t//free (hint);\n\t\tfree (mnem);\n\t\tr_anal_hint_free (hint);\n\t\tr_anal_op_fini (&op);\n\t\tr_asm_op_fini (&asmop);\n\t}\n\tr_anal_op_fini (&op);\n\tif (fmt == 's') {\n\t\tr_cons_printf (\"%d\\n\", totalsize);\n\t} else if (fmt == 'j') {\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\tr_esil_free (esil);\n}\n\nstatic int bb_cmp(const void *a, const void *b) {\n\tconst RAnalBlock *ba = a;\n\tconst RAnalBlock *bb = b;\n\treturn ba->addr - bb->addr;\n}\n\nstatic ut64 caseval(const void* _a) {\n\tconst RAnalCaseOp* a = _a;\n\treturn a->addr;\n}\n\nstatic ut64 __opaddr(const RAnalBlock *b, ut64 addr) {\n\tint i;\n\tif (addr >= b->addr && addr < (b->addr + b->size)) {\n\t\tfor (i = 0; i < b->ninstr; i++) {\n\t\t\tut64 aa = b->addr + r_anal_bb_offset_inst (b, i);\n\t\t\tut64 ab = b->addr + r_anal_bb_offset_inst (b, i + 1);\n\t\t\tif (addr >= aa && addr < ab) {\n\t\t\t\treturn aa;\n\t\t\t}\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nstatic RVecUT64 *get_xrefs(RAnalBlock *block) {\n\tRVecUT64 *result = RVecUT64_new ();\n\n\tsize_t i;\n\tfor (i = 0; i < block->ninstr; i++) {\n\t\tconst ut64 ia = block->addr + block->op_pos[i];\n\t\tRVecAnalRef *xrefs = r_anal_xrefs_get (block->anal, ia);\n\t\tif (xrefs) {\n\t\t\tRAnalRef *ref;\n\t\t\tR_VEC_FOREACH (xrefs, ref) {\n\t\t\t\tut64 *addr = RVecUT64_emplace_back (result);\n\t\t\t\tif (R_UNLIKELY (!addr)) {\n\t\t\t\t\tRVecUT64_free (result);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\t*addr = ref->addr;\n\t\t\t}\n\t\t}\n\n\t\tRVecAnalRef_free (xrefs);\n\t}\n\n\treturn result;\n}\n\nstatic char *fcnjoin(RList *list) {\n\tRAnalFunction *n;\n\tRListIter *iter;\n\tRStrBuf buf;\n\tr_strbuf_init (&buf);\n\tr_list_foreach (list, iter, n) {\n\t\tr_strbuf_appendf (&buf, \" 0x%08\" PFMT64x, n->addr);\n\t}\n\tchar *s = strdup (r_strbuf_get (&buf));\n\tr_strbuf_fini (&buf);\n\treturn s;\n}\n\nstatic char *ut64join(RList *list) {\n\tut64 *n;\n\tRListIter *iter;\n\tRStrBuf buf;\n\tr_strbuf_init (&buf);\n\tr_list_foreach (list, iter, n) {\n\t\tr_strbuf_appendf (&buf, \" 0x%08\" PFMT64x, *n);\n\t}\n\tchar *s = strdup (r_strbuf_get (&buf));\n\tr_strbuf_fini (&buf);\n\treturn s;\n}\n\nstatic RList *get_calls(RAnalBlock *block) {\n\tRList *list = NULL;\n\tRAnalOp op;\n\tut8 *data = malloc (block->size);\n\tif (data) {\n\t\tblock->anal->iob.read_at (block->anal->iob.io, block->addr, data, block->size);\n\t\tsize_t i;\n\t\tfor (i = 0; i < block->size; i++) {\n\t\t\tint ret = r_anal_op (block->anal, &op, block->addr + i, data + i, block->size - i, R_ARCH_OP_MASK_HINT);\n\t\t\tif (ret < 1) {\n\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (op.type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\tif (!list) {\n\t\t\t\t\tlist = r_list_newf (free);\n\t\t\t\t}\n\t\t\t\tr_list_push (list, ut64_new (op.jump));\n\t\t\t}\n\t\t\tr_anal_op_fini (&op);\n\t\t\tif (op.size > 0) {\n\t\t\t\ti += op.size - 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree (data);\n\treturn list;\n}\n\nstatic void anal_bb_list(RCore *core, const char *input) {\n\tconst int mode = *input;\n\tPJ *pj = NULL;\n\tRTable *table = NULL;\n\tRBIter iter;\n\tRAnalBlock *block;\n\tif (mode == 'c') {\n\t\tut64 count = 0;\n\t\tr_rbtree_foreach (core->anal->bb_tree, iter, block, RAnalBlock, _rb) {\n\t\t\tcount++;\n\t\t}\n\t\tr_cons_printf (\"%\"PFMT64d\"\\n\", count);\n\t\treturn;\n\t}\n\tif (mode == 'j') {\n\t\tpj = pj_new ();\n\t\tpj_o (pj);\n\t\tpj_ka (pj, \"blocks\");\n\t} else if (mode == ',' || mode == 't') {\n\t\ttable = r_table_new (\"bbs\");\n\t\tRTableColumnType *s = r_table_type (\"string\");\n\t\tRTableColumnType *n = r_table_type (\"number\");\n\t\tr_table_add_column (table, n, \"addr\", 0);\n\t\tr_table_add_column (table, n, \"size\", 0);\n\t\tr_table_add_column (table, n, \"traced\", 0);\n\t\tr_table_add_column (table, n, \"ninstr\", 0);\n\t\tr_table_add_column (table, s, \"jump\", 0);\n\t\tr_table_add_column (table, s, \"fail\", 0);\n\t\tr_table_add_column (table, s, \"fcns\", 0);\n\t\tr_table_add_column (table, s, \"calls\", 0);\n\t\tr_table_add_column (table, s, \"xrefs\", 0);\n\t}\n\n\tr_rbtree_foreach (core->anal->bb_tree, iter, block, RAnalBlock, _rb) {\n\t\tRVecUT64 *xrefs = get_xrefs (block);\n\t\tRList *calls = get_calls (block);\n\t\tswitch (mode) {\n\t\tcase 'j':\n\t\t\tpj_o (pj);\n\t\t\tchar *addr = r_str_newf (\"0x%\" PFMT64x, block->addr);\n\t\t\tpj_ks (pj, \"addr\", addr);\n\t\t\tfree (addr);\n\t\t\tpj_kn (pj, \"traced\", block->traced);\n\t\t\tpj_kn (pj, \"ninstr\", block->ninstr);\n\t\t\tpj_kn (pj, \"size\", block->size);\n\t\t\tif (block->jump != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"jump\", block->jump);\n\t\t\t}\n\t\t\tif (block->fail != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"fail\", block->fail);\n\t\t\t}\n\t\t\tif (xrefs) {\n\t\t\t\tpj_ka (pj, \"xrefs\");\n\t\t\t\tut64 *addr;\n\t\t\t\tR_VEC_FOREACH (xrefs, addr) {\n\t\t\t\t\tpj_n (pj, *addr);\n\t\t\t\t}\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tif (calls) {\n\t\t\t\tpj_ka (pj, \"calls\");\n\t\t\t\tRListIter *iter2;\n\t\t\t\tut64 *addr;\n\t\t\t\tr_list_foreach (calls, iter2, addr) {\n\t\t\t\t\tpj_n (pj, *addr);\n\t\t\t\t}\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tpj_ka (pj, \"fcns\");\n\t\t\tRListIter *iter2;\n\t\t\tRAnalFunction *fcn;\n\t\t\tr_list_foreach (block->fcns, iter2, fcn) {\n\t\t\t\tpj_n (pj, fcn->addr);\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t\tbreak;\n\t\tcase ',':\n\t\tcase 't':\n\t\t\t{\n\t\t\t\tchar *jump = block->jump != UT64_MAX? r_str_newf (\"0x%08\" PFMT64x, block->jump): strdup (\"\");\n\t\t\t\tchar *fail = block->fail != UT64_MAX? r_str_newf (\"0x%08\" PFMT64x, block->fail): strdup (\"\");\n\t\t\t\tchar *call = ut64join (calls);\n\t\t\t\tchar *xref = ut64join (calls);\n\t\t\t\tchar *fcns = fcnjoin (block->fcns);\n\t\t\t\tr_table_add_rowf (table, \"xnddsssss\",\n\t\t\t\t\tblock->addr,\n\t\t\t\t\tblock->size,\n\t\t\t\t\tblock->traced,\n\t\t\t\t\tblock->ninstr,\n\t\t\t\t\tjump,\n\t\t\t\t\tfail,\n\t\t\t\t\tfcns,\n\t\t\t\t\tcall,\n\t\t\t\t\txref\n\t\t\t\t);\n\t\t\t\tfree (jump);\n\t\t\t\tfree (fail);\n\t\t\t\tfree (call);\n\t\t\t\tfree (xref);\n\t\t\t\tfree (fcns);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x\"\\n\", block->addr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x , block->addr);\n\t\t\tif (block->jump != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" jump=0x%08\" PFMT64x, block->jump);\n\t\t\t}\n\t\t\tif (block->fail != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" fail=0x%08\" PFMT64x, block->fail);\n\t\t\t}\n\t\t\tif (block->traced) {\n\t\t\t\tr_cons_printf (\" trace=0x%08\" PFMT64x, block->traced);\n\t\t\t}\n\t\t\tif (xrefs) {\n\t\t\t\tut64 *addr;\n\t\t\t\tR_VEC_FOREACH (xrefs, addr) {\n\t\t\t\t\tr_cons_printf (\" xref=0x%08\" PFMT64x, *addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (calls) {\n\t\t\t\tRListIter *iter2;\n\t\t\t\tut64 *addr;\n\t\t\t\tr_list_foreach (calls, iter2, addr) {\n\t\t\t\t\tr_cons_printf (\" call=0x%08\" PFMT64x, *addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (block->fcns) {\n\t\t\t\tRListIter *iter2;\n\t\t\t\tRAnalFunction *fcn;\n\t\t\t\tr_list_foreach (block->fcns, iter2, fcn) {\n\t\t\t\t\tr_cons_printf (\" func=0x%\" PFMT64x, fcn->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\" size=%\" PFMT64d \"\\n\", block->size);\n\t\t}\n\t\tr_list_free (calls);\n\t\tRVecUT64_free (xrefs);\n\t}\n\tif (mode == 'j') {\n\t\tpj_end (pj);\n\t\tpj_end (pj);\n\t\tchar *j = pj_drain (pj);\n\t\tr_cons_println (j);\n\t\tfree (j);\n\t} else if (mode == 't' || mode == ',') {\n\t\tchar *q = strchr (input, ' ');\n\t\tbool show_query = true;\n\t\tif (q) {\n\t\t\tshow_query = r_table_query (table, q + 1);\n\t\t}\n\t\tif (show_query) {\n\t\t\tchar *s = r_table_tofancystring (table);\n\t\t\tr_cons_println (s);\n\t\t\tfree (s);\n\t\t}\n\t\tr_table_free (table);\n\t}\n}\n\nstatic void print_bb(PJ *pj, const RAnalBlock *b, const RAnalFunction *fcn, const ut64 addr) {\n\tRListIter *iter2;\n\tRAnalBlock *b2;\n\tint outputs = (b->jump != UT64_MAX) + (b->fail != UT64_MAX);\n\tint inputs = 0;\n\tr_list_foreach (fcn->bbs, iter2, b2) {\n\t\tinputs += (b2->jump == b->addr) + (b2->fail == b->addr);\n\t}\n\tut64 opaddr = __opaddr (b, addr);\n\tif (pj) {\n\t\tpj_o (pj);\n\t\tpj_kn (pj, \"addr\", b->addr);\n\t\tpj_ki (pj, \"size\", b->size);\n\t\tif (b->jump != UT64_MAX) {\n\t\t\tpj_kn (pj, \"jump\", b->jump);\n\t\t}\n\t\tif (b->fail != UT64_MAX) {\n\t\t\tpj_kn (pj, \"fail\", b->fail);\n\t\t}\n\t\tif (b->switch_op) {\n\t\t\tpj_k (pj, \"switch_op\");\n\t\t\tpj_o (pj);\n\t\t\tpj_kn (pj, \"addr\", b->switch_op->addr);\n\t\t\tpj_kn (pj, \"min_val\", b->switch_op->min_val);\n\t\t\tpj_kn (pj, \"def_val\", b->switch_op->def_val);\n\t\t\tpj_kn (pj, \"max_val\", b->switch_op->max_val);\n\t\t\tpj_k (pj, \"cases\");\n\t\t\tpj_a (pj);\n\t\t\t{\n\t\t\tRListIter *case_op_iter;\n\t\t\tRAnalCaseOp *case_op;\n\t\t\tr_list_foreach (b->switch_op->cases, case_op_iter, case_op) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"addr\", case_op->addr);\n\t\t\t\tpj_kn (pj, \"jump\", case_op->jump);\n\t\t\t\tpj_kn (pj, \"value\", case_op->value);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_kn (pj, \"opaddr\", opaddr);\n\t\tpj_ki (pj, \"inputs\", inputs);\n\t\tpj_ki (pj, \"outputs\", outputs);\n\t\t{\n\t\t\tRColor k = b->color;\n\t\t\tif (k.r || k.g || k.b) {\n\t\t\t\tchar *s = r_str_newf (\"rgb:%x%x%x\",\n\t\t\t\t\t\t16 * k.r / 255,\n\t\t\t\t\t\t16 * k.g / 255,\n\t\t\t\t\t\t16 * k.b / 255);\n\t\t\t\tpj_ks (pj, \"color\", s);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t}\n\t\tpj_ki (pj, \"ninstr\", b->ninstr);\n\t\tpj_ka (pj, \"instrs\");\n\t\t{\n\t\t\tint i;\n\t\t\tfor (i = 0; i < b->ninstr; i++) {\n\t\t\t\tint delta = (i > 0)? b->op_pos[i - 1]: 0;\n\t\t\t\tpj_n (pj, b->addr + delta);\n\t\t\t}\n\t\t}\n\t\tpj_end (pj);\n\t\tpj_kn (pj, \"traced\", b->traced);\n\t\tpj_end (pj);\n\t} else {\n\t\tif (b->switch_op) {\n\t\t\tr_list_uniq_inplace (b->switch_op->cases, caseval);\n\t\t\toutputs += r_list_length (b->switch_op->cases);\n\t\t}\n\t\tif (b->jump != UT64_MAX) {\n\t\t\tr_cons_printf (\"jump: 0x%08\"PFMT64x\"\\n\", b->jump);\n\t\t}\n\t\tif (b->fail != UT64_MAX) {\n\t\t\tr_cons_printf (\"fail: 0x%08\"PFMT64x\"\\n\", b->fail);\n\t\t}\n\t\tr_cons_printf (\"opaddr: 0x%08\"PFMT64x\"\\n\", opaddr);\n\t\tr_cons_printf (\"addr: 0x%08\" PFMT64x \"\\nsize: %\" PFMT64d \"\\ninputs: %d\\noutputs: %d\\nninstr: %d\\ntraced: 0x%\"PFMT64x\"\\n\",\n\t\t\tb->addr, b->size, inputs, outputs, b->ninstr, b->traced);\n\t}\n}\n\nstatic bool anal_fcn_list_bb(RCore *core, const char *input, bool one) {\n\tRDebugTracepoint *tp = NULL;\n\tRListIter *iter;\n\tRAnalBlock *b;\n\tint mode = 0;\n\tut64 addr, bbaddr = UT64_MAX;\n\tPJ *pj = NULL;\n\n\tif (*input == '.') {\n\t\tone = true;\n\t\tinput++;\n\t}\n\tif (*input) {\n\t\tmode = *input;\n\t\tinput++;\n\t}\n\tif (*input == '.') {\n\t\tone = true;\n\t\tinput++;\n\t}\n\tif (R_STR_ISNOTEMPTY (input)) {\n\t\taddr = bbaddr = r_num_math (core->num, input);\n\t\tif (!addr && *input != '0') {\n\t\t\taddr = core->offset;\n\t\t}\n\t} else {\n\t\tbbaddr = addr = core->offset;\n\t}\n\tinput = r_str_trim_head_ro (input);\n\tif (one) {\n\t\tbbaddr = addr;\n\t}\n\tif (mode == 'j') {\n\t\tpj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\tr_cons_println (\"[]\");\n\t\t\treturn false;\n\t\t}\n\t\tpj_a (pj);\n\t}\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\tif (!fcn) {\n\t\tif (mode == 'j') {\n\t\t\tpj_end (pj);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t}\n\t\tif (mode == 'i' && input && *input == 'j') {\n\t\t\tr_cons_println (\"{}\");\n\t\t}\n\t\tR_LOG_ERROR (\"Cannot find function in 0x%08\"PFMT64x, addr);\n\t\treturn false;\n\t}\n\tif (mode == '*') {\n\t\tr_cons_printf (\"fs blocks\\n\");\n\t}\n\tif (fcn->bbs) {\n\t\tr_list_sort (fcn->bbs, bb_cmp);\n\t}\n\tif (mode == '=') { // afb\n\t\tRList *flist = r_list_newf ((RListFree) r_listinfo_free);\n\t\tif (!flist) {\n\t\t\treturn false;\n\t\t}\n\t\tls_foreach (fcn->bbs, iter, b) {\n\t\t\tRInterval inter = (RInterval) {b->addr, b->size};\n\t\t\tRListInfo *info = r_listinfo_new (NULL, inter, inter, -1, NULL);\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (flist, info);\n\t\t}\n\t\tRTable *table = r_core_table (core, \"fcnbbs\");\n\t\tif (!table) {\n\t\t\treturn false;\n\t\t}\n\t\tr_table_visual_list (table, flist, core->offset, core->blocksize,\n\t\t\tr_cons_get_size (NULL), r_config_get_i (core->config, \"scr.color\"));\n\t\tchar *s = r_table_tostring (table);\n\t\tr_cons_printf (\"\\n%s\\n\", s);\n\t\tfree (s);\n\t\tr_table_free (table);\n\t\tr_list_free (flist);\n\t\treturn true;\n\t}\n\n\tRTable *t = NULL;\n\tif (mode == 't') {\n\t\tt = r_table_new (\"fcnbbs\");\n\t\tr_table_set_columnsf (t, \"xdxx\", \"addr\", \"size\", \"jump\", \"fail\");\n\t}\n\tr_list_foreach (fcn->bbs, iter, b) {\n\t\tif (one) {\n\t\t\tif (bbaddr != UT64_MAX && (bbaddr < b->addr || bbaddr >= (b->addr + b->size))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tswitch (mode) {\n\t\tcase 't': // \"afbt\"\n\t\t\tr_table_add_rowf (t, \"xdxx\", b->addr, b->size, b->jump, b->fail);\n\t\t\tbreak;\n\t\tcase 'r': // \"afbr\"\n\t\t\tif (b->jump == UT64_MAX || r_anal_noreturn_at_addr (core->anal, b->jump)) {\n\t\t\t\tut64 retaddr = r_anal_bb_opaddr_i (b, b->ninstr - 1);\n\t\t\t\tif (retaddr == UT64_MAX) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (input, \"*\")) {\n\t\t\t\t\tr_cons_printf (\"db 0x%08\"PFMT64x\"\\n\", retaddr);\n\t\t\t\t} else if (!strcmp (input, \"-*\")) {\n\t\t\t\t\tr_cons_printf (\"db-0x%08\"PFMT64x\"\\n\", retaddr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", retaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tr_cons_printf (\"f bb.%05\" PFMT64x \" = 0x%08\" PFMT64x \"\\n\",\n\t\t\t\tb->addr & 0xFFFFF, b->addr);\n\t\t\tbreak;\n\t\tcase 'q': // \"afbq\"\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", b->addr);\n\t\t\tbreak;\n\t\tcase 'j': // \"afbj\"\n\t\t\tprint_bb (pj, b, fcn, addr);\n\t\t\tbreak;\n\t\tcase 'i': // \"afbi\"\n\t\t\tif (*input == 'j') { // \"afbij\"\n\t\t\t\tpj = r_core_pj_new (core);\n\t\t\t\tif (!pj) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tprint_bb (pj, b, fcn, addr);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t} else {\n\t\t\t\tprint_bb (NULL, b, fcn, addr);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttp = r_debug_trace_get (core->dbg, b->addr);\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" 0x%08\" PFMT64x \" %02X:%04X %\" PFMT64d,\n\t\t\t\tb->addr, b->addr + b->size,\n\t\t\t\ttp? tp->times: 0, tp? tp->count: 0,\n\t\t\t\tb->size);\n\t\t\tif (b->jump != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" j 0x%08\" PFMT64x, b->jump);\n\t\t\t}\n\t\t\tif (b->fail != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" f 0x%08\" PFMT64x, b->fail);\n\t\t\t}\n\t\t\tif (b->switch_op) {\n\t\t\t\tRAnalCaseOp *cop;\n\t\t\t\tRListIter *iter;\n\t\t\t\tr_list_uniq_inplace (b->switch_op->cases, caseval);\n\t\t\t\tr_list_foreach (b->switch_op->cases, iter, cop) {\n\t\t\t\t\tr_cons_printf (\" s 0x%08\" PFMT64x, cop->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode == 't') {\n\t\tconst char *arg = input;\n\t\tif (r_table_query (t, arg)) {\n\t\t\tchar *ts = r_table_tofancystring (t);\n\t\t\tr_cons_printf (\"%s\", ts);\n\t\t\tfree (ts);\n\t\t}\n\t\tr_table_free (t);\n\t} else if (mode == 'j') {\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\treturn true;\n}\n\nstatic bool anal_bb_edge(RCore *core, const char *input) {\n\t// \"afbe\" switch-bb-addr case-bb-addr\n\tchar *arg = strdup (r_str_trim_head_ro (input));\n\tchar *sp = strchr (arg, ' ');\n\tbool ret = false;\n\tif (sp) {\n\t\t*sp++ = 0;\n\t\tut64 switch_addr = r_num_math (core->num, arg);\n\t\tut64 case_addr = r_num_math (core->num, sp);\n\t\tRList *blocks = r_anal_get_blocks_in (core->anal, switch_addr);\n\t\tif (blocks && !r_list_empty (blocks)) {\n\t\t\tr_anal_block_add_switch_case (r_list_first (blocks), switch_addr, 0, case_addr);\n\t\t\tret = true;\n\t\t}\n\t\tr_list_free (blocks);\n\t}\n\tfree (arg);\n\treturn ret;\n}\n\nstatic bool anal_fcn_del_bb(RCore *core, const char *input) {\n\tut64 addr = r_num_math (core->num, input);\n\tif (!addr) {\n\t\taddr = core->offset;\n\t}\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, -1);\n\tif (fcn) {\n\t\tif (!strcmp (input, \"*\")) {\n\t\t\twhile (!r_list_empty (fcn->bbs)) {\n\t\t\t\tr_anal_function_remove_block (fcn, r_list_first (fcn->bbs));\n\t\t\t}\n\t\t} else {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tif (b->addr == addr) {\n\t\t\t\t\tr_anal_function_remove_block (fcn, b);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tR_LOG_ERROR (\"Cannot find basic block\");\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int cmd_afbplus(RCore *core, const char *input) {\n\t// fcn_addr bb_addr bb_size [jump] [fail]\n\tconst char *ptr2 = NULL;\n\tut64 fcnaddr = -1LL, addr = -1LL;\n\tut64 size = 0LL;\n\tut64 jump = UT64_MAX;\n\tut64 fail = UT64_MAX;\n\tRAnalFunction *fcn = NULL;\n\tRAnalDiff *diff = NULL;\n\n\tchar *ptr = r_str_trim_dup (input);\n\n\tswitch (r_str_word_set0 (ptr)) {\n\tcase 6:\n\t\tptr2 = r_str_word_get0 (ptr, 6);\n\t\tif (!(diff = r_anal_diff_new ())) {\n\t\t\tR_LOG_ERROR (\"Cannot init RAnalDiff\");\n\t\t\tfree (ptr);\n\t\t\treturn false;\n\t\t}\n\t\tif (ptr2[0] == 'm') {\n\t\t\tdiff->type = R_ANAL_DIFF_TYPE_MATCH;\n\t\t} else if (ptr2[0] == 'u') {\n\t\t\tdiff->type = R_ANAL_DIFF_TYPE_UNMATCH;\n\t\t}\n\tcase 5: // get fail\n\t\tfail = r_num_math (core->num, r_str_word_get0 (ptr, 4));\n\tcase 4: // get jump\n\t\tjump = r_num_math (core->num, r_str_word_get0 (ptr, 3));\n\tcase 3: // get size\n\t\tsize = r_num_math (core->num, r_str_word_get0 (ptr, 2));\n\tcase 2: // get addr\n\t\taddr = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\tcase 1: // get fcnaddr\n\t\tfcnaddr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t}\n\tfcn = r_anal_get_function_at (core->anal, fcnaddr);\n\tif (fcn && size > 0) {\n\t\tif (!r_anal_function_add_bb (core->anal, fcn, addr, size, jump, fail, diff)) {\n\t\t\tR_LOG_ERROR (\"afb+: Cannot add basic block at 0x%08\"PFMT64x\" with size %d\", addr, (int)size);\n\t\t}\n\t} else {\n\t\tR_LOG_ERROR (\"afb+ No function at 0x%\" PFMT64x \" from 0x%08\"PFMT64x\" -> 0x%08\"PFMT64x,\n\t\t\t\tfcnaddr, addr, jump);\n\t}\n\tr_anal_diff_free (diff);\n\tfree (ptr);\n\treturn true;\n}\n\nstatic void r_core_anal_nofunclist(RCore *core, const char *input) {\n\tint minlen = (int)(input[0] == ' ') ? r_num_math (core->num, input + 1): 16;\n\tut64 code_size = r_num_get (core->num, \"$SS\");\n\tut64 base_addr = r_num_get (core->num, \"$S\");\n\tut64 chunk_size, chunk_offset, i;\n\tRListIter *iter, *iter2;\n\tRAnalFunction *fcn;\n\tRAnalBlock *b;\n\tchar* bitmap;\n\tint counter;\n\n\tif (minlen < 1) {\n\t\tminlen = 1;\n\t}\n\tif (code_size < 1) {\n\t\treturn;\n\t}\n\tbitmap = calloc (1, code_size + 64);\n\tif (!bitmap) {\n\t\treturn;\n\t}\n\n\t// for each function\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\t// for each basic block in the function\n\t\tr_list_foreach (fcn->bbs, iter2, b) {\n\t\t\t// if it is not withing range, continue\n\t\t\tif ((fcn->addr < base_addr) || (fcn->addr >= base_addr+code_size))\n\t\t\t\tcontinue;\n\t\t\t// otherwise mark each byte in the BB in the bitmap\n\t\t\tfor (counter = 0; counter < b->size; counter++) {\n\t\t\t\tbitmap[b->addr+counter-base_addr] = '=';\n\t\t\t}\n\t\t\t// finally, add a special marker to show the beginning of a\n\t\t\t// function\n\t\t\tbitmap[fcn->addr-base_addr] = 'F';\n\t\t}\n\t}\n\n\t// Now we print the list of memory regions that are not assigned to a function\n\tchunk_size = 0;\n\tchunk_offset = 0;\n\tfor (i = 0; i < code_size; i++) {\n\t\tif (bitmap[i]) {\n\t\t\t// We only print a region is its size is bigger than 15 bytes\n\t\t\tif (chunk_size >= minlen) {\n\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, base_addr+chunk_offset, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"  %6\" PFMT64u \"   %s\\n\",\n\t\t\t\t\t\t\tbase_addr+chunk_offset, chunk_size, fcn->name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"  %6\" PFMT64u \"\\n\",\n\t\t\t\t\t\t\tbase_addr+chunk_offset, chunk_size);\n\t\t\t\t}\n\t\t\t}\n\t\t\tchunk_size = 0;\n\t\t\tchunk_offset = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tchunk_size += 1;\n\t}\n\tif (chunk_size >= 16) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, base_addr+chunk_offset, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\tif (fcn) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %6\" PFMT64u \"   %s\\n\", base_addr+chunk_offset, chunk_size, fcn->name);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %6\" PFMT64u \"\\n\", base_addr+chunk_offset, chunk_size);\n\t\t}\n\t}\n\tfree (bitmap);\n}\n\nstatic void r_core_anal_fmap(RCore *core, const char *input) {\n\tint show_color = r_config_get_i (core->config, \"scr.color\");\n\tint cols = r_config_get_i (core->config, \"hex.cols\") * 4;\n\tut64 code_size = r_num_get (core->num, \"$SS\");\n\tut64 base_addr = r_num_get (core->num, \"$S\");\n\tRListIter *iter, *iter2;\n\tRAnalFunction *fcn;\n\tRAnalBlock *b;\n\tint assigned;\n\tut64 i;\n\n\tif (code_size < 1) {\n\t\treturn;\n\t}\n\tchar *bitmap = calloc (1, code_size + 64);\n\tif (!bitmap) {\n\t\treturn;\n\t}\n\n\t// for each function\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\t// for each basic block in the function\n\t\tr_list_foreach (fcn->bbs, iter2, b) {\n\t\t\t// if it is not within range, continue\n\t\t\tif ((fcn->addr < base_addr) || (fcn->addr >= base_addr+code_size))\n\t\t\t\tcontinue;\n\t\t\t// otherwise mark each byte in the BB in the bitmap\n\t\t\tint counter = 1;\n\t\t\tfor (counter = 0; counter < b->size; counter++) {\n\t\t\t\tbitmap[b->addr+counter-base_addr] = '=';\n\t\t\t}\n\t\t\tbitmap[fcn->addr-base_addr] = 'F';\n\t\t}\n\t}\n\t// print the bitmap\n\tassigned = 0;\n\tif (cols < 1) {\n\t\tcols = 1;\n\t}\n\tfor (i = 0; i < code_size; i += 1) {\n\t\tif (!(i % cols)) {\n\t\t\tr_cons_printf (\"\\n0x%08\"PFMT64x\"  \", base_addr+i);\n\t\t}\n\t\tif (bitmap[i]) {\n\t\t\tassigned++;\n\t\t}\n\t\tif (show_color) {\n\t\t\tif (bitmap[i]) {\n\t\t\t\tr_cons_printf (\"%s%c\\x1b[0m\", Color_GREEN, bitmap[i]);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\".\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_cons_printf (\"%c\", bitmap[i] ? bitmap[i] : '.' );\n\t\t}\n\t}\n\tr_cons_printf (\"\\n%d / %\" PFMT64u \" (%.2lf%%) bytes assigned to a function\\n\",\n\t\tassigned, code_size, 100.0 * ( (float) assigned) / code_size);\n\tfree (bitmap);\n}\n\nstatic bool fcnNeedsPrefix(const char *name) {\n\tif (!strncmp (name, \"entry\", 5)) {\n\t\treturn false;\n\t}\n\tif (!strncmp (name, \"main\", 4)) {\n\t\treturn false;\n\t}\n\treturn (!strchr (name, '.'));\n}\n\nstatic char *getFunctionName(RCore *core, ut64 off, const char *name, bool prefix) {\n\tconst char *fcnpfx = \"\";\n\tif (prefix) {\n\t\tif (fcnNeedsPrefix (name) && (!fcnpfx || !*fcnpfx)) {\n\t\t\tfcnpfx = \"fcn\";\n\t\t} else {\n\t\t\tfcnpfx = r_config_get (core->config, \"anal.fcnprefix\");\n\t\t}\n\t}\n\tif (r_reg_get (core->anal->reg, name, -1)) {\n\t\treturn r_str_newf (\"%s.%08\"PFMT64x, \"fcn\", off);\n\t}\n\treturn strdup (name); // r_str_newf (\"%s%s%s\", fcnpfx, *fcnpfx? \".\": \"\", name);\n}\n\nstatic void rename_fcnsig(RAnal *anal, const char *oname, const char *nname) {\n#define DB anal->sdb_types\n\t// rename type\n\tconst char *type = sdb_const_get (DB, oname, 0);\n\tif (type && !strcmp (type, \"func\")) {\n\t\tsdb_unset (DB, oname, 0);\n\t\tsdb_set (DB, nname, \"func\", 0);\n\t}\n\t// rename args\n\tchar *k = r_str_newf (\"func.%s.args\", oname);\n\tconst char *argstr = sdb_const_get (DB, k, 0);\n\tif (R_STR_ISEMPTY (argstr)) {\n\t\tfree (k);\n\t\treturn;\n\t}\n\tint i, args = r_num_get (NULL, argstr);\n\tsdb_unset (DB, k, 0);\n\tfree (k);\n\tk = r_str_newf (\"func.%s.args\", nname);\n\tchar *v = r_str_newf (\"%d\", (int)args);\n\tsdb_set (DB, k, v, 0);\n\tfree (v);\n\t// rename arg#\n\tfree (k);\n\tfor (i = 0; i < args; i++) {\n\t\tk = r_str_newf (\"func.%s.arg.%d\", oname, i);\n\t\tchar *v = sdb_get (DB, k, 0);\n\t\tif (v) {\n\t\t\tsdb_unset (DB, k, 0);\n\t\t\tfree (k);\n\t\t\tk = r_str_newf (\"func.%s.arg.%d\", nname, i);\n\t\t\tsdb_set (DB, k, v, 0);\n\t\t\tfree (v);\n\t\t}\n\t\tfree (k);\n\t}\n\t// unset the leftovers\n\tfor (; i < args + 8; i++) {\n\t\tk = r_str_newf (\"func.%s.arg.%d\", oname, i);\n\t\tsdb_unset (DB, k, 0);\n\t\tfree (k);\n\t}\n\t// rename ret\n\tk = r_str_newf (\"func.%s.ret\", oname);\n\tv = sdb_get (DB, k, 0);\n\tsdb_unset (DB, k, 0);\n\tfree (k);\n\tk = r_str_newf (\"func.%s.ret\", nname);\n\tsdb_set (DB, k, v, 0);\n\tfree (k);\n\tfree (v);\n#undef DB\n}\n\n/* TODO: move into r_anal_function_rename (); */\nstatic bool __setFunctionName(RCore *core, ut64 addr, const char *_name, bool prefix) {\n\tr_return_val_if_fail (core && _name, false);\n\tbool ret = false;\n\tchar *name = getFunctionName (core, addr, r_str_trim_head_ro (_name), prefix);\n\tchar *fname = r_name_filter_dup (name);\n\tRAnalFunction *fcn = r_anal_get_function_at (core->anal, addr);\n\tif (fcn) {\n\t\tchar *oname = strdup (fcn->name);\n\t\tRFlagItem *flag = r_flag_get (core->flags, fcn->name);\n\t\tif (flag && flag->space && strcmp (flag->space->name, R_FLAGS_FS_FUNCTIONS) == 0) {\n\t\t\t// Only flags in the functions fs should be renamed, e.g. we don't want to rename symbol flags.\n\t\t\tr_flag_rename (core->flags, flag, fname);\n\t\t} else {\n\t\t\t// No flag or not specific to the function, create a new one.\n\t\t\tr_flag_space_push (core->flags, R_FLAGS_FS_FUNCTIONS);\n\t\t\tr_flag_set (core->flags, name, fcn->addr, r_anal_function_size_from_entry (fcn));\n\t\t\tr_flag_space_pop (core->flags);\n\t\t}\n\t\trename_fcnsig (core->anal, oname, name);\n\t\tr_anal_function_rename (fcn, name);\n\t\tif (core->anal->cb.on_fcn_rename) {\n\t\t\tcore->anal->cb.on_fcn_rename (core->anal, core->anal->user, fcn, name);\n\t\t}\n\t\tfree (oname);\n\t\tret = true;\n\t}\n\tfree (name);\n\tfree (fname);\n\treturn ret;\n}\n\nstatic void afCc(RCore *core, const char *input) {\n\tut64 addr = (*input == ' ')\n\t\t? r_num_math (core->num, input)\n\t\t: core->offset;\n\tRAnalFunction *fcn = (addr == 0LL)\n\t\t? r_anal_get_function_byname (core->anal, input + 3)\n\t\t: r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\tif (fcn) {\n\t\tut32 totalCycles = r_anal_function_cost (fcn);\n\t\t// FIXME: This defeats the purpose of the function, but afC is used in project files.\n\t\t// cf. canal.c\n\t\tr_cons_printf (\"%d\\n\", totalCycles);\n\t} else {\n\t\tR_LOG_ERROR (\"afCc: Cannot find function\");\n\t}\n}\n\nstatic void cmd_anal_fcn_sig(RCore *core, const char *input) {\n\tbool json = (input[0] == 'j');\n\tchar *p = strchr (input, ' ');\n\tchar *fcn_name = p ? r_str_trim_dup (p): NULL;\n\tRListIter *iter;\n\tRAnalFuncArg *arg;\n\n\tRAnalFunction *fcn;\n\tif (fcn_name) {\n\t\tfcn = r_anal_get_function_byname (core->anal, fcn_name);\n\t} else {\n\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tif (fcn) {\n\t\t\tfcn_name = fcn->name;\n\t\t}\n\t}\n\tif (!fcn) {\n\t\treturn;\n\t}\n\n\tif (json) {\n\t\tPJ *j = pj_new ();\n\t\tif (!j) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (j);\n\t\tchar *key = (fcn_name)? resolve_fcn_name (core->anal, fcn_name): NULL;\n\t\tif (key) {\n\t\t\tconst char *fcn_type = r_type_func_ret (core->anal->sdb_types, key);\n\t\t\tint nargs = r_type_func_args_count (core->anal->sdb_types, key);\n\t\t\tif (fcn_type) {\n\t\t\t\tpj_o (j);\n\t\t\t\tpj_ks (j, \"name\", r_str_getf (key));\n\t\t\t\tpj_ks (j, \"return\", r_str_getf (fcn_type));\n\t\t\t\tpj_k (j, \"args\");\n\t\t\t\tpj_a (j);\n\t\t\t\tif (nargs) {\n\t\t\t\t\tRList *list = r_core_get_func_args (core, fcn_name);\n\t\t\t\t\tr_list_foreach (list, iter, arg) {\n\t\t\t\t\t\tchar *type = arg->orig_c_type;\n\t\t\t\t\t\tpj_o (j);\n\t\t\t\t\t\tpj_ks (j, \"name\", arg->name);\n\t\t\t\t\t\tpj_ks (j, \"type\", type);\n\t\t\t\t\t\tpj_end (j);\n\t\t\t\t\t}\n\t\t\t\t\tr_list_free (list);\n\t\t\t\t}\n\t\t\t\tpj_end (j);\n\t\t\t\tpj_ki (j, \"count\", nargs);\n\t\t\t\tpj_end (j);\n\t\t\t}\n\t\t\tfree (key);\n\t\t} else {\n\t\t\tpj_o (j);\n\t\t\tpj_ks (j, \"name\", r_str_getf (fcn_name));\n\t\t\tpj_k (j, \"args\");\n\t\t\tpj_a (j);\n\n\t\t\tRAnalFcnVarsCache cache;\n\t\t\tr_anal_function_vars_cache_init (core->anal, &cache, fcn);\n\t\t\tint nargs = 0;\n\t\t\tRAnalVar *var;\n\t\t\tr_list_foreach (cache.rvars, iter, var) {\n\t\t\t\tnargs++;\n\t\t\t\tpj_o (j);\n\t\t\t\tpj_ks (j, \"name\", var->name);\n\t\t\t\tpj_ks (j, \"type\", var->type);\n\t\t\t\tpj_end (j);\n\t\t\t}\n\t\t\tr_list_foreach (cache.bvars, iter, var) {\n\t\t\t\tif (var->delta <= 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnargs++;\n\t\t\t\tpj_o (j);\n\t\t\t\tpj_ks (j, \"name\", var->name);\n\t\t\t\tpj_ks (j, \"type\", var->type);\n\t\t\t\tpj_end (j);\n\t\t\t}\n\t\t\tr_list_foreach (cache.svars, iter, var) {\n\t\t\t\tif (!var->isarg) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnargs++;\n\t\t\t\tpj_o (j);\n\t\t\t\tpj_ks (j, \"name\", var->name);\n\t\t\t\tpj_ks (j, \"type\", var->type);\n\t\t\t\tpj_end (j);\n\t\t\t}\n\t\t\tr_anal_function_vars_cache_fini (&cache);\n\n\t\t\tpj_end (j);\n\t\t\tpj_ki (j, \"count\", nargs);\n\t\t\tpj_end (j);\n\t\t}\n\t\tpj_end (j);\n\t\tconst char *s = pj_string (j);\n\t\tif (s) {\n\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t}\n\t\tpj_free (j);\n\t} else {\n\t\tchar *sig = r_anal_function_format_sig (core->anal, fcn, fcn_name, NULL, NULL, NULL);\n\t\tif (sig) {\n\t\t\tr_cons_printf (\"%s\\n\", sig);\n\t\t\tfree (sig);\n\t\t}\n\t}\n}\n\nstatic void __updateStats(RCore *core, Sdb *db, ut64 addr, int statsMode) {\n\tRAnalOp *op = r_core_anal_op (core, addr, R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT | R_ARCH_OP_MASK_DISASM);\n\tif (!op) {\n\t\treturn;\n\t}\n\tif (statsMode == 'f') {\n\t\tconst char *family = r_anal_op_family_tostring (op->family);\n\t\tsdb_num_inc (db, family, 1, 0);\n\t} else if (statsMode == 'o') {\n\t\tconst char *type = r_anal_optype_tostring (op->type);\n\t\tsdb_num_inc (db, type, 1, 0);\n\t} else {\n\t\tchar *mnem = strdup (op->mnemonic);\n\t\tchar *sp = strchr (mnem, ' ');\n\t\tif (sp) {\n\t\t\t*sp = 0;\n\t\t\t//memmove (mnem, sp + 1, strlen (sp));\n\t\t}\n\t\tsdb_num_inc (db, mnem, 1, 0);\n\t}\n\t//sdb_set (db, family, \"1\", 0);\n\t//r_cons_printf (\"0x%08\"PFMT64x\" %s\\n\", addr, family);\n\tr_anal_op_free (op);\n\t// r_core_cmdf (core, \"pd 1 @ 0x%08\"PFMT64x, addr);\n}\n\nstatic Sdb *__core_cmd_anal_fcn_stats(RCore *core, const char *input) {\n\tbool silentMode = false;\n\tint statsMode = 0;\n\tif (*input == '*') {\n\t\tsilentMode = true;\n\t\tinput++;\n\t}\n\tswitch (*input) {\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_afis);\n\t\treturn NULL;\n\tcase 'f':\n\tcase 'o':\n\t\tstatsMode = *input;\n\t\tinput++;\n\t\tbreak;\n\t}\n\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tif (!fcn) {\n\t\tR_LOG_ERROR (\"Cannot find any function at 0x%08\"PFMT64x, core->offset);\n\t\treturn NULL;\n\t}\n\tSdb *db = sdb_new0 ();\n\tRAnalBlock *bb;\n\tRListIter *iter;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tint i;\n\t\t__updateStats (core, db, bb->addr, statsMode);\n\t\tfor (i = 0; i < bb->op_pos_size; i++) {\n\t\t\tut16 op_pos = bb->op_pos[i];\n\t\t\t__updateStats (core, db, bb->addr + op_pos, statsMode);\n\t\t}\n\t}\n\tif (silentMode) {\n\t\t// nothing\n\t} else if (*input == 't') {\n\t\tSdbList *ls = sdb_foreach_list (db, true);\n\t\tSdbListIter *it;\n\t\tRTable *t = r_table_new (\"fcnstats\");\n\t\tSdbKv *kv;\n\t\tRTableColumnType *typeString = r_table_type (\"string\");\n\t\tRTableColumnType *typeNumber = r_table_type (\"number\");\n\t\tr_table_add_column (t, typeString, \"name\", 0);\n\t\tls_foreach (ls, it, kv) {\n\t\t\tconst char *key = sdbkv_key (kv);\n\t\t\tr_table_add_column (t, typeNumber, key, 0);\n\t\t}\n\t\tRList *items = r_list_newf (free);\n\t\tr_list_append (items, strdup (fcn->name));\n\t\tls_foreach (ls, it, kv) {\n\t\t\tconst char *value = sdbkv_value (kv);\n\t\t\tint nv = (int)r_num_get (NULL, value);\n\t\t\tr_list_append (items, r_str_newf (\"%d\", nv));\n\t\t}\n\t\tr_table_add_row_list (t, items);\n\t\tif (r_table_query (t, input + 1)) {\n\t\t\tchar *ts = r_table_tostring (t);\n\t\t\tr_cons_printf (\"%s\", ts);\n\t\t\tfree (ts);\n\t\t}\n\t\tr_table_free (t);\n\t} else {\n\t\tSdbList *ls = sdb_foreach_list (db, true);\n\t\tSdbListIter *it;\n\t\tSdbKv *kv;\n\t\tls_foreach (ls, it, kv) {\n\t\t\tconst char *key = sdbkv_key(kv);\n\t\t\tconst char *value = sdbkv_value(kv);\n\t\t\tr_cons_printf (\"%4d %s\\n\", (int)r_num_get (NULL, value), key);\n\t\t}\n\t}\n\treturn db;\n\t//sdb_free (db);\n}\n\nstatic void __core_cmd_anal_fcn_allstats(RCore *core, const char *input) {\n\tRAnalFunction *fcn;\n\tSdbKv *kv;\n\tRListIter *iter;\n\tSdbListIter *it;\n\tRList *dbs = r_list_newf ((RListFree)sdb_free);\n\tSdb *d = sdb_new0 ();\n\tut64 oseek = core->offset;\n\tbool isJson = strchr (input, 'j');\n\n\tchar *inp = r_str_newf (\"*%s\", input);\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tr_core_seek (core, fcn->addr, true);\n\t\tSdb *db = __core_cmd_anal_fcn_stats (core, inp);\n\t\tsdb_num_set (db, \".addr\", fcn->addr, 0);\n\t\tr_list_append (dbs, db);\n\t}\n\tfree (inp);\n\tSdb *db;\n\tr_list_foreach (dbs, iter, db) {\n\t\tSdbList *ls = sdb_foreach_list (db, true);\n\t\tls_foreach (ls, it, kv) {\n\t\t\tconst char *name = sdbkv_key (kv);\n\t\t\tsdb_add (d, name, \"1\", 0);\n\t\t}\n\t\tls_free (ls);\n\t}\n\tRTable *t = r_table_new (\"fcnallstats\");\n\tSdbList *ls = sdb_foreach_list (d, true);\n\tRTableColumnType *typeString = r_table_type (\"string\");\n\tRTableColumnType *typeNumber = r_table_type (\"number\");\n\tr_table_add_column (t, typeString, \"name\", 0);\n\tr_table_add_column (t, typeNumber, \"addr\", 0);\n\tls_foreach (ls, it, kv) {\n\t\tconst char *key = sdbkv_key (kv);\n\t\tif (*key == '.') continue;\n\t\tr_table_add_column (t, typeNumber, key, 0);\n\t}\n\tsdb_free (d);\n\n\tr_list_foreach (dbs, iter, db) {\n\t\tSdbList *ls = sdb_foreach_list (db, false);\n\t\tSdbListIter *it;\n\t\tSdbKv *kv;\n\t\tchar *names[100];\n\t\tint i;\n\t\tfor (i = 0; i < 100; i++) {\n\t\t\tnames[i] = NULL;\n\t\t}\n\t\tls_foreach (ls, it, kv) {\n\t\t\tconst char *key = sdbkv_key(kv);\n\t\t\tconst char *value = sdbkv_value (kv);\n\t\t\tif (*key == '.') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint idx = r_table_column_nth (t, key);\n\t\t\tif (idx != -1) {\n\t\t\t\tut64 nv = r_num_get (NULL, value);\n\t\t\t\tnames[idx] = r_str_newf (\"%d\", (int)nv);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Invalid column name (%s)\", key);\n\t\t\t}\n\t\t}\n\t\tRList *items = r_list_newf (free);\n\t\tut64 fcnAddr = sdb_num_get (db, \".addr\", 0);\n\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, fcnAddr, 0);\n\t\tr_list_append (items, fcn?strdup (fcn->name):strdup (\"\"));\n\t\tr_list_append (items, fcn?r_str_newf (\"0x%08\"PFMT64x, fcnAddr): strdup (\"0\"));\n\t\tint cols = r_list_length (t->cols);\n\t\tfor (i = 2; i < cols; i++) {\n\t\t\tif (names[i]) {\n\t\t\t\tif (names[i][0] != '.') {\n\t\t\t\t\tr_list_append (items, strdup (names[i]));\n\t\t\t\t}\n\t\t\t\tR_FREE (names[i]);\n\t\t\t} else {\n\t\t\t\tr_list_append (items, strdup (\"0\"));\n\t\t\t}\n\t\t}\n\t\tr_table_add_row_list (t, items);\n\t}\n\tif (r_table_query (t, (*input)?input + 1: \"\")) {\n\t\tchar *ts = isJson? r_table_tojson(t): r_table_tostring (t);\n\t\tif (ts) {\n\t\t\tr_cons_printf (\"%s%s\", ts, isJson ? \"\\n\" : \"\");\n\t\t\tfree (ts);\n\t\t}\n\t}\n\tr_table_free (t);\n\tr_core_seek (core, oseek, true);\n\tr_list_free (dbs);\n}\n\nstatic void _abo(RAnalBlock *bb) {\n\tint i;\n\tfor (i = 0; i < bb->ninstr; i++) {\n\t\tut64 at = r_anal_block_ninstr (bb, i);\n\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", at);\n\t}\n}\n\nstatic void abo(RCore *core) {\n\tRAnalBlock *bb = r_anal_get_block_at (core->anal, core->offset);\n\tif (bb) {\n\t\t_abo (bb);\n\t}\n}\n\nstatic void afbo(RCore *core) {\n\tRAnalFunction *f = r_anal_get_function_at (core->anal, core->offset);\n\tif (f) {\n\t\tRListIter *iter;\n\t\tRAnalBlock *bb;\n\t\tr_list_foreach (f->bbs, iter, bb) {\n\t\t\t_abo (bb);\n\t\t}\n\t}\n}\n\nR_API char *fcnshowr(RAnalFunction *function) {\n\tRAnal *a = function->anal;\n\t//PJ *pj = a->coreb.pjWithEncoding (a->coreb.core);\n\tconst char *realname = NULL, *import_substring = NULL;\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\n\tRFlagItem *flag = a->flag_get (a->flb.f, function->addr);\n\t// Can't access R_FLAGS_FS_IMPORTS, since it is defined in r_core.h\n\tif (flag && flag->space && !strcmp (flag->space->name, \"imports\")) {\n\t\t// Get substring after last dot\n\t\timport_substring = r_str_rchr (function->name, NULL, '.');\n\t\tif (import_substring) {\n\t\t\trealname = import_substring + 1;\n\t\t}\n\t} else {\n\t\trealname = function->name;\n\t}\n\n\tchar *args = strdup (\"\");\n\tchar *sdb_ret = r_str_newf (\"func.%s.ret\", realname);\n\tchar *sdb_args = r_str_newf (\"func.%s.args\", realname);\n\t// RList *args_list = r_list_newf ((RListFree) free);\n\t// const char *ret_type = sdb_const_get (a->sdb_types, sdb_ret, 0);\n\tconst char *argc_str = sdb_const_get (a->sdb_types, sdb_args, 0);\n\tconst int argc = argc_str? atoi (argc_str): 0;\n\n\tconst bool no_return = r_anal_noreturn_at_addr (a, function->addr);\n\tif (no_return) {\n\t\tr_strbuf_appendf (sb, \"tn %s\\n\", function->name);\n\t}\n\tif (function->cc) {\n\t\tr_strbuf_appendf (sb, \"afc %s\\n\", function->cc);\n\t}\n\tint i;\n\tfor (i = 0; i < argc; i++) {\n\t\tchar *sdb_arg_i = r_str_newf (\"func.%s.arg.%d\", realname, i);\n\t\tchar *type = sdb_get (a->sdb_types, sdb_arg_i, 0);\n\t\tif (!type) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *comma = strchr (type, ',');\n\t\tif (comma) {\n\t\t\t*comma = 0;\n\t\t\tr_strf_var (regname, 32, \"A%d\", i);\n\t\t\tconst char *cc_arg = r_reg_get_name (a->reg, r_reg_get_name_idx (regname));\n\t\t\tr_strbuf_appendf (sb, \"afvr %s %s %s\\n\", cc_arg, comma + 1, type);\n\t\t}\n\t\tfree (type);\n\t\tfree (sdb_arg_i);\n\t}\n\tfree (sdb_args);\n\tfree (sdb_ret);\n\tfree (args);\n\treturn r_strbuf_drain (sb);\n}\n\nstatic void cmd_afsr(RCore *core, const char *input) {\n\tut64 addr = core->offset;\n\tRAnalFunction *f;\n\tif ((f = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL))) {\n\t\tchar *res = fcnshowr (f);\n\t\tif (R_STR_ISNOTEMPTY (res)) {\n\t\t\tr_cons_println (res);\n\t\t}\n\t\tfree (res);\n\t} else {\n\t\tR_LOG_ERROR (\"No function defined at 0x%08\" PFMT64x, addr);\n\t}\n}\n\nstatic void cmd_afsj(RCore *core, const char *arg) {\n\tut64 a = r_num_math (core->num, arg);\n\tconst ut64 addr = a? a: core->offset;\n\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, addr, -1);\n\tif (f) {\n\t\tchar *s = r_anal_function_get_json (f);\n\t\tr_cons_printf (\"%s\\n\", s);\n\t\tfree (s);\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot find function in 0x%08\"PFMT64x, addr);\n\t}\n}\n\nstatic void cmd_afbc(RCore *core, const char *input) {\n\tr_return_if_fail (core && input);\n\tchar *ptr = strdup (input);\n\tif (!ptr) {\n\t\treturn;\n\t}\n\tif (*ptr == '?') {\n\t\tr_core_cmd_help_match (core, help_msg_afb, \"afbc\", true);\n\t} else if (!*ptr) {\n\t\tRAnalBlock *bb = r_anal_get_block_at (core->anal, core->offset);\n\t\tif (bb && (bb->color.r || bb->color.g || bb->color.b)) {\n\t\t\tchar *s = r_cons_rgb_str (NULL, -1, &bb->color);\n\t\t\tif (s) {\n\t\t\t\tchar *name = r_cons_rgb_tostring (bb->color.r, bb->color.g, bb->color.b);\n\t\t\t\tr_cons_printf (\"%s%s\"Color_RESET\"\\n\", s, name);\n\t\t\t\tfree (name);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tut64 addr = core->offset;\n\t\tconst bool del = (*ptr == '-');\n\t\tif (del) {\n\t\t\tptr++;\n\t\t}\n\n\t\tchar *space = strchr (ptr, ' ');\n\t\tif (space) {\n\t\t\t*space++ = 0;\n\t\t\taddr = r_num_math (core->num, space);\n\t\t}\n\t\tRColor color = {0};\n\t\tif (del) {\n\t\t\tptr--;\n\t\t} else {\n\t\t\t(void)r_cons_pal_parse (ptr, &color);\n\t\t}\n\t\tRAnalBlock *bb = r_anal_get_block_at (core->anal, addr);\n\t\tif (bb) {\n\t\t\tbb->color = color;\n\t\t}\n\t}\n\tfree (ptr);\n}\n\n// Fcn Xrefs Map\nstatic void xrefs_map(RCore *core, const char *input) {\n\tRListIter *iter, *iter2;\n\tRAnalFunction *f, *f2;\n\tint col = 0;\n\tint count = 0;\n\tdo {\n\t\tr_cons_print (\"             \");\n\t\tcount = 0;\n\t\tr_list_foreach (core->anal->fcns, iter, f) {\n\t\t\tint nlen = strlen (f->name);\n\t\t\tif (col >= nlen) {\n\t\t\t\tr_cons_printf (\"|\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tr_cons_printf (\"%c\", f->name[col]);\n\t\t}\n\t\tr_cons_newline ();\n\t\tcol++;\n\t} while (count);\n\n\tint total = 0;\n\tr_list_foreach (core->anal->fcns, iter, f) {\n\t\tRVecAnalRef *refs = r_anal_function_get_refs (f);\n\t\tr_cons_printf (\"0x%08\"PFMT64x\"  \", f->addr);\n\t\ttotal = 0;\n\t\tr_list_foreach (core->anal->fcns, iter2, f2) {\n\t\t\tint count = 0;\n\t\t\tRAnalRef *r;\n\t\t\tR_VEC_FOREACH (refs, r) {\n\t\t\t\tif (r->addr == f2->addr) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > 0) {\n\t\t\t\ttotal++;\n\t\t\t\tif (count < 10) {\n\t\t\t\t\tr_cons_printf (\"%d\", count);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"+\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\".\");\n\t\t\t}\n\t\t}\n\t\tif (total > 0) {\n\t\t\tr_cons_printf (\"  %s\\n\", f->name);\n\t\t} else {\n\t\t\tr_cons_printf (\"\\r\");\n\t\t}\n\t\tRVecAnalRef_free (refs);\n\t}\n}\n\nR_API void r_core_af(RCore *core, ut64 addr, const char *name, bool anal_calls) {\n\tint depth = r_config_get_i (core->config, \"anal.depth\");\n\n\t//r_core_anal_undefine (core, core->offset);\n\tr_core_anal_fcn (core, addr, UT64_MAX, R_ANAL_REF_TYPE_NULL, depth);\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\tif (fcn) {\n\t\t/* ensure we use a proper name */\n\t\t__setFunctionName (core, addr, fcn->name, false);\n\t\tif (core->anal->opt.vars) {\n\t\t\tr_core_recover_vars (core, fcn, true);\n\t\t}\n\t\t__add_vars_sdb (core, fcn);\n\t} else {\n\t\tif (core->anal->verbose) {\n\t\t\tR_LOG_WARN (\"Unable to analyze function at 0x%08\"PFMT64x, addr);\n\t\t}\n\t}\n\tif (anal_calls) {\n\t\tSetU *visited = set_u_new ();\n\t\tfcn = r_anal_get_fcn_in (core->anal, addr, 0); /// XXX wrong in case of nopskip\n\t\tif (fcn) {\n\t\t\tRVecAnalRef *refs = r_anal_function_get_refs (fcn);\n\t\t\tRAnalRef *ref;\n\t\t\tR_VEC_FOREACH (refs, ref) {\n\t\t\t\tif (set_u_contains (visited, ref->addr)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tset_u_add (visited, ref->addr);\n\t\t\t\tif (ref->addr == UT64_MAX) {\n\t\t\t\t\tR_LOG_DEBUG (\"ignore 0x%08\"PFMT64x\" call 0x%08\"PFMT64x, ref->at, ref->addr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint rt = R_ANAL_REF_TYPE_MASK (ref->type);\n\t\t\t\tif (rt != R_ANAL_REF_TYPE_CODE && rt != R_ANAL_REF_TYPE_CALL) {\n\t\t\t\t\t/* only follow code/call references */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!r_io_is_valid_offset (core->io, ref->addr, !core->anal->opt.noncode)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr_core_anal_fcn (core, ref->addr, fcn->addr, R_ANAL_REF_TYPE_CALL, depth - 1);\n\t\t\t\t/* use recursivity here */\n#if 1\n\t\t\t\tRAnalFunction *f = r_anal_get_function_at (core->anal, ref->addr);\n\t\t\t\tif (f) {\n\t\t\t\t\tRVecAnalRef *refs1 = r_anal_function_get_refs (f);\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tR_VEC_FOREACH (refs1, ref) {\n\t\t\t\t\t\tconst ut64 raddr = ref->addr;\n\t\t\t\t\t\tif (set_u_contains (visited, raddr)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tset_u_add (visited, raddr);\n\t\t\t\t\t\tif (!r_io_is_valid_offset (core->io, raddr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst int rt = R_ANAL_REF_TYPE_MASK (ref->type);\n\t\t\t\t\t\tif (rt != R_ANAL_REF_TYPE_CALL && rt != R_ANAL_REF_TYPE_CODE) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// recursively follow fcn->refs again and again\n\t\t\t\t\t\tif (!r_anal_get_function_at (core->anal, raddr)) {\n\t\t\t\t\t\t\t// do not reanalize if theres a function already there\n\t\t\t\t\t\t\tr_core_anal_fcn (core, raddr, f->addr, R_ANAL_REF_TYPE_CALL, depth - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tRVecAnalRef_free (refs1);\n\t\t\t\t} else {\n\t\t\t\t\tf = r_anal_get_fcn_in (core->anal, fcn->addr, 0);\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\t/* cut function */\n\t\t\t\t\t\tr_anal_function_resize (f, addr - fcn->addr);\n\t\t\t\t\t\tr_core_anal_fcn (core, ref->addr, fcn->addr, R_ANAL_REF_TYPE_CALL, depth - 1);\n\t\t\t\t\t\tf = r_anal_get_function_at (core->anal, fcn->addr);\n\t\t\t\t\t}\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tR_LOG_ERROR (\"af: Cannot find function at 0x%08\" PFMT64x, fcn->addr);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tRVecAnalRef_free (refs);\n\t\t\tif (core->anal->opt.vars) {\n\t\t\t\tr_core_recover_vars (core, fcn, true);\n\t\t\t}\n\t\t}\n\t\tset_u_free (visited);\n\t}\n\tif (name) {\n\t\tif (*name && !__setFunctionName (core, addr, name, true)) {\n\t\t\tR_LOG_ERROR (\"af: Cannot find function at 0x%08\" PFMT64x, addr);\n\t\t}\n\t}\n#if 0\n\t// XXX THIS IS VERY SLOW\n\t// r_core_anal_propagate_noreturn (core, addr);\n\tif (core->anal->opt.vars) {\n\t\tRListIter *iter;\n\t\tRAnalFunction *fcni = NULL;\n\t\tr_list_foreach (core->anal->fcns, iter, fcni) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_core_recover_vars (core, fcni, true);\n\t\t}\n\t}\n//\tflag_every_function (core);\n#endif\n}\n\nstatic void cmd_aflxj(RCore *core) {\n\tut64 addr = faddr (core, core->offset, NULL);\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_ANY);\n\tSdb *db = sdb_new0 ();\n\tRVecAnalRef *xrefs = r_anal_xrefs_get (core->anal, addr);\n\tif (xrefs) {\n\t\tRAnalRef *ref;\n\t\tR_VEC_FOREACH (xrefs, ref) {\n\t\t\tbool nr = false;\n\t\t\tut64 fa = faddr (core, ref->addr, &nr);\n\t\t\tchar *key = r_str_newf (\"0x%08\"PFMT64x, fa);\n\t\t\tsdb_array_add_num (db, key, ref->addr, 0);\n\t\t}\n\t}\n\tSdbList *keys = sdb_foreach_list (db, true);\n\tSdbListIter *liter;\n\tSdbKv *kv;\n\tPJ * pj = r_core_pj_new (core);\n\tif (pj) {\n\t\tpj_o (pj);\n\t}\n\tls_foreach (keys, liter, kv) {\n\t\tconst char *key = sdbkv_key (kv);\n\t\tconst char *value = sdbkv_value (kv);\n\t\tut64 fcn_xref_addr = r_num_get (NULL, key);\n\t\tut64 xref_addr = r_num_get (NULL, value);\n\t\tRAnalFunction *xref = r_anal_get_fcn_in (core->anal, fcn_xref_addr, R_ANAL_FCN_TYPE_ANY);\n\t\tif (fcn && xref) {\n\t\t\tpj_kn (pj, \"address\", fcn->addr);\n\t\t\tpj_ks (pj, \"name\", fcn->name);\n\t\t\tpj_ko (pj, \"xrefs\");\n\t\t\tpj_ka (pj, xref->name);\n\t\t\tpj_n (pj, xref_addr);\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t} else {\n\t\t\tR_LOG_WARN (\"No function defined here\");\n\t\t}\n\t}\n\tpj_end (pj);\n\tchar *s = pj_drain (pj);\n\tr_cons_printf (\"%s\\n\", s);\n\tfree (s);\n\tRVecAnalRef_free (xrefs);\n\tsdb_free (db);\n\tls_free (keys);\n}\n\nstatic void cmd_afci(RCore *core, RAnalFunction *fcn) {\n\tconst char *cc = (fcn && fcn->cc)? fcn->cc: \"reg\";\n\tr_core_cmdf (core, \"afcll~%s (\", cc);\n}\n\nstatic void cmd_afix(RCore *core, const char *input) {\n\tswitch (input[3]) {\n\tcase '?': // \"afix?\"\n\t\tr_core_cmd_help_match (core, help_msg_afi, \"afix\", false);\n\t\tbreak;\n\tcase 'q': // \"afixq\"\n\tcase 'j': // \"afixj\"\n\t\tr_core_anal_fcn_list (core, input + 4, input + 2);\n\t\tbreak;\n\tcase 0: // \"afix\"\n\t\tr_core_anal_fcn_list (core, \"\", \"x\\x01\");\n\t\tbreak;\n\tdefault:\n\t\tR_LOG_ERROR (\"Invalid argument\");\n\t\tbreak;\n\t}\n}\n\nstatic int cmd_af(RCore *core, const char *input) {\n\tr_cons_break_timeout (r_config_get_i (core->config, \"anal.timeout\"));\n\tswitch (input[1]) {\n\tcase '-': // \"af-\"\n\t\tif (!input[2]) { // \"af-\"\n\t\t\tcmd_af (core, \"f-$$\");\n\t\t\tr_core_anal_undefine (core, core->offset);\n\t\t} else if (!strcmp (input + 2, \"*\")) { // \"af-*\"\n\t\t\tRAnalFunction *f;\n\t\t\tRListIter *iter, *iter2;\n\t\t\tr_list_foreach_safe (core->anal->fcns, iter, iter2, f) {\n\t\t\t\tut64 addr = f->addr;\n\t\t\t\tr_anal_del_jmprefs (core->anal, f);\n\t\t\t\t// r_anal_function_del_locs (core->anal, f->addr);\n\t\t\t//\tr_anal_function_del (core->anal, addr);\n\t\t\t\tr_core_anal_undefine (core, addr);\n\t\t\t}\n\t\t} else {\n\t\t\tut64 addr = input[2]\n\t\t\t\t? r_num_math (core->num, input + 2)\n\t\t\t\t: core->offset;\n\t\t\t// r_anal_function_del_locs (core->anal, addr);\n\t\t\t// r_anal_function_del (core->anal, addr);\n\t\t\tr_core_anal_undefine (core, addr);\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"afj\"\n\t\t{\n\t\t\tRList *blocks = r_anal_get_blocks_in (core->anal, core->offset);\n\t\t\tRAnalBlock *block = r_list_first (blocks);\n\t\t\tif (block && !r_list_empty (block->fcns)) {\n\t\t\t\tchar *args = strdup (input + 2);\n\t\t\t\tRList *argv = r_str_split_list (args, \" \", 0);\n\t\t\t\tut64 table = r_num_math (core->num, r_list_get_n (argv, 1));\n\t\t\t\tut64 sz = r_num_math (core->num, r_list_get_n (argv, 2));\n\t\t\t\tut64 elements = r_num_math (core->num, r_list_get_n (argv, 3));\n\t\t\t\tut64 seg = r_num_math (core->num, r_list_get_n (argv, 4));\n\t\t\t\tint depth = 50;\n\t\t\t\ttry_walkthrough_jmptbl (core->anal, r_list_first (block->fcns), block,\n\t\t\t\t\tdepth, core->offset, 0, table, seg, sz, elements, 0, false);\n\t\t\t\tfree (args);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"No function defined here\");\n\t\t\t}\n\t\t\tr_list_free (blocks);\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"afa\"\n\t\tif (input[2] == 'l') { // \"afal\" : list function call arguments\n\t\t\tint show_args = r_config_get_i (core->config, \"dbg.funcarg\");\n\t\t\tif (show_args) {\n\t\t\t\tr_core_print_func_args (core);\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_print_func_args (core);\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"afd\"\n\t\t{\n\t\tut64 addr = 0;\n\t\tif (input[2] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_af, \"afd\", true);\n\t\t} else if (input[2] == ' ') {\n\t\t\taddr = r_num_math (core->num, input + 2);\n\t\t} else {\n\t\t\taddr = core->offset;\n\t\t}\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\tif (input[2] == 'j') { // afdj\n\t\t\tPJ *pj = r_core_pj_new (core);\n\t\t\tif (!pj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpj_o (pj);\n\t\t\tif (fcn) {\n\t\t\t\tpj_ks (pj, \"name\", fcn->name);\n\t\t\t\tpj_ki (pj, \"offset\", (int)(addr - fcn->addr));\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t} else {\n\t\t\tif (fcn) {\n\t\t\t\tif (fcn->addr != addr) {\n\t\t\t\t\tr_cons_printf (\"%s + %d\\n\", fcn->name,\n\t\t\t\t\t\t\t(int)(addr - fcn->addr));\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_println (fcn->name);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"afd: Cannot find function\");\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'u': // \"afu\"\n\t\tif (input[2] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_afu);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (input[2] != ' ') {\n\t\t\tR_LOG_ERROR (\"Missing argument\");\n\t\t\treturn false;\n\t\t}\n\n\t\tut64 addr = core->offset;\n\t\tut64 addr_end = r_num_math (core->num, input + 2);\n\t\tif (addr_end < addr) {\n\t\t\tR_LOG_ERROR (\"Invalid address ranges\");\n\t\t} else {\n\t\t\tut64 a, b;\n\t\t\tconst char *c;\n\t\t\ta = r_config_get_i (core->config, \"anal.from\");\n\t\t\tb = r_config_get_i (core->config, \"anal.to\");\n\t\t\tc = r_config_get (core->config, \"anal.limits\");\n\t\t\tr_config_set_i (core->config, \"anal.from\", addr);\n\t\t\tr_config_set_i (core->config, \"anal.to\", addr_end);\n\t\t\tr_config_set_b (core->config, \"anal.limits\", true);\n\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\tif (fcn) {\n\t\t\t\tr_anal_function_resize (fcn, addr_end - addr);\n\t\t\t}\n\t\t\tr_core_anal_fcn (core, addr, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n\t\t\tfcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\tif (fcn) {\n\t\t\t\tr_anal_function_resize (fcn, addr_end - addr);\n\t\t\t}\n\t\t\tr_config_set_i (core->config, \"anal.from\", a);\n\t\t\tr_config_set_i (core->config, \"anal.to\", b);\n\t\t\tr_config_set (core->config, \"anal.limits\", r_str_get (c));\n\t\t}\n\t\tbreak;\n\tcase '+': { // \"af+\"\n\t\tif (input[2] == '?' || !input[2]) {\n\t\t\tr_core_cmd_help (core, help_msg_af_plus);\n\t\t\tbreak;\n\t\t}\n\t\tchar *ptr = input[2]? r_str_trim_dup (input + 2): r_str_newf (\"0x%\"PFMT64x, core->offset);\n\t\tconst char *ptr2;\n\t\tint n = r_str_word_set0 (ptr);\n\t\tconst char *name = NULL;\n\t\tchar *hname = NULL; // heaped name\n\t\tut64 addr = UT64_MAX;\n\t\tRAnalDiff *diff = NULL;\n\t\tint type = R_ANAL_FCN_TYPE_FCN;\n\t\tif (n > 0) {\n\t\t\tswitch (n) {\n\t\t\tcase 4:\n\t\t\t\tptr2 = r_str_word_get0 (ptr, 3);\n\t\t\t\tif (!(diff = r_anal_diff_new ())) {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot initialize RAnalDiff\");\n\t\t\t\t\tfree (ptr);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (ptr2[0] == 'm') {\n\t\t\t\t\tdiff->type = R_ANAL_DIFF_TYPE_MATCH;\n\t\t\t\t} else if (ptr2[0] == 'u') {\n\t\t\t\t\tdiff->type = R_ANAL_DIFF_TYPE_UNMATCH;\n\t\t\t\t}\n\t\t\t\t/* fallthrough */\n\t\t\tcase 3:\n\t\t\t\tptr2 = r_str_word_get0 (ptr, 2);\n\t\t\t\tif (strchr (ptr2, 'l')) {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_LOC;\n\t\t\t\t} else if (strchr (ptr2, 'i')) {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_IMP;\n\t\t\t\t} else if (strchr (ptr2, 's')) {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_SYM;\n\t\t\t\t} else {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_FCN;\n\t\t\t\t}\n\t\t\t\t/* fallthrough */\n\t\t\tcase 2:\n\t\t\t\tname = r_str_word_get0 (ptr, 1);\n\t\t\t\t/* fallthrough */\n\t\t\tcase 1:\n\t\t\t\taddr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\t\tif (!name) {\n\t\t\t\t\tRFlagItem *fi = r_flag_get_at (core->flags, addr, false);\n\t\t\t\t\tname = hname = (fi)\n\t\t\t\t\t\t? strdup (fi->name)\n\t\t\t\t\t\t: r_str_newf (\"fcn.%08\"PFMT64x, addr);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRAnalFunction *fcn = r_anal_create_function (core->anal, name, addr, type, diff);\n\t\t\tif (!fcn) {\n\t\t\t\tR_LOG_ERROR (\"Cannot add function '%s' (duplicated) at 0x%08\"PFMT64x, name, addr);\n\t\t\t}\n\t\t\tfree (hname);\n\t\t}\n\t\tr_anal_diff_free (diff);\n\t\tfree (ptr);\n\t\t}\n\t\tbreak;\n\tcase 'o': // \"afo\"\n\t\tswitch (input[2]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help_match (core, help_msg_af, \"afo\", true);\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tPJ *pj = r_core_pj_new (core);\n\t\t\t\tif (!pj) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpj_o (pj);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tpj_ki (pj, \"address\", fcn->addr);\n\t\t\t\t}\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", fcn->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's': // \"afos\"\n\t\t\t{\n\t\t\t\tut64 addr = core->offset;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRList *list = r_anal_get_functions_in (core->anal, addr);\n\t\t\t\tRAnalFunction *fcn;\n\t\t\t\tr_list_foreach (list, iter, fcn) {\n\t\t\t\t\tr_cons_printf (\"= 0x%08\" PFMT64x \"\\n\", fcn->addr);\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn;\n\t\t\t\tut64 addr = r_num_math (core->num, input + 3);\n\t\t\t\tif (addr == 0LL) {\n\t\t\t\t\tfcn = r_anal_get_function_byname (core->anal, input + 3);\n\t\t\t\t} else {\n\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\t}\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", fcn->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"afi\"\n\t\tswitch (input[2]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_afi);\n\t\t\tbreak;\n\t\tcase 'x': // \"afix\"\n\t\t\tcmd_afix (core, input);\n\t\t\tbreak;\n\t\tcase '.': // \"afi.\"\n\t\t\t{\n\t\t\t\tut64 addr = core->offset;\n\t\t\t\tif (input[3] == ' ') {\n\t\t\t\t\taddr = r_num_math (core->num, input + 3);\n\t\t\t\t}\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", fcn->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l': // \"afil\"\n\t\t\tif (input[3] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_afll);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough */\n\t\tcase 'i': // \"afii\"\n\t\t\tif (input[3] == '-') {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_list_free (fcn->imports);\n\t\t\t\t\tfcn->imports = NULL;\n\t\t\t\t}\n\t\t\t} else if (input[3] == ' ') {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tif (!fcn->imports) {\n\t\t\t\t\t\tfcn->imports = r_list_newf ((RListFree)free);\n\t\t\t\t\t}\n\t\t\t\t\tr_list_append (fcn->imports, r_str_trim_dup (input + 4));\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"No function found\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn && fcn->imports) {\n\t\t\t\t\tchar *imp;\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tr_list_foreach (fcn->imports, iter, imp) {\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", imp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's': // \"afis\"\n\t\t\tif (input[3] == 'a') { // \"afisa\"\n\t\t\t\t__core_cmd_anal_fcn_allstats (core, input + 4);\n\t\t\t} else {\n\t\t\t\tsdb_free (__core_cmd_anal_fcn_stats (core, input + 3));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j': // \"afij\"\n\t\tcase '*': // \"afi*\"\n\t\t\tr_core_anal_fcn_list (core, input + 3, input + 2);\n\t\t\tbreak;\n\t\tcase 'p': // \"afip\"\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"is-pure: %s\\n\", r_str_bool (r_anal_function_purity (fcn)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '=':\n\t\tcase 'q':\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\t// TODO: add info about xrefs and call counts\n\t\t\t\t\tint nargs = r_type_func_args_count (core->anal->sdb_types, 0);\n\t\t\t\t\tint nvars = r_anal_var_count_locals (fcn);\n\t\t\t\t\tint nins = r_anal_function_instrcount (fcn);\n\t\t\t\t\tint ebbs = 0;\n\t\t\t\t\tint edges = r_anal_function_count_edges (fcn, &ebbs);\n\t\t\t\t\tr_anal_function_count_edges (fcn, NULL);\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" : %s\\n\", fcn->addr, fcn->name);\n\t\t\t\t\tchar *sig = r_core_cmd_strf (core, \"afcf @ 0x%\"PFMT64x, fcn->addr);\n\t\t\t\t\tif (sig) {\n\t\t\t\t\t\tr_str_trim (sig);\n\t\t\t\t\t\tr_cons_printf (\"  sign:  %s\\n\", sig);\n\t\t\t\t\t\tfree (sig);\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"  stack: 0x%08x (vars:%d args:%d)\\n\",\n\t\t\t\t\t\tfcn->maxstack, nvars , nargs);\n\t\t\t\t\tr_cons_printf (\"  size:  %d (0x%08\" PFMT64x \" .. 0x%08\" PFMT64x \")\\n\",\n\t\t\t\t\t\t(int)r_anal_function_realsize (fcn),\n\t\t\t\t\t\tr_anal_function_min_addr (fcn),\n\t\t\t\t\t\tr_anal_function_max_addr (fcn));\n\t\t\t\t\tr_cons_printf (\"  nbbs:  %d edges:%d ebbs:%d ninstr:%d\\n\",\n\t\t\t\t\t\tr_list_length (fcn->bbs), edges, ebbs, nins);\n\t\t\t\t\tr_cons_printf (\"  cost:  %d complexity:%d\\n\",\n\t\t\t\t\t\tr_anal_function_cost (fcn), r_anal_function_complexity (fcn));\n\t\t\t\t\tr_cons_printf (\"  attr:  \");\n\t\t\t\t\tif (r_anal_function_islineal (fcn)) {\n\t\t\t\t\t\tr_cons_printf (\"lineal\");\n\t\t\t\t\t}\n\t\t\t\t\tif (fcn->is_noreturn) {\n\t\t\t\t\t\tr_cons_printf (\"noreturn\");\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_newline ();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ':\n\t\tcase 0:\n\t\t\t{\n\t\t\t\tconst char *arg = input[2]? input + 2: \"\";\n\t\t\t\tconst char *sec = \"\\x01\";\n\t\t\t\tr_core_anal_fcn_list (core, arg, sec);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_afi);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'l': // \"afl\"\n\t\tswitch (input[2]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_afl);\n\t\t\tbreak;\n\t\tcase 'x': // \"aflx\"\n\t\t\tswitch (input[3]) {\n\t\t\tdefault:\n\t\t\tcase '?':\n\t\t\t\tr_core_cmd_help (core, help_msg_aflx);\n\t\t\t\treturn true;\n\t\t\tcase 'v': // \"aflxv\"\n\t\t\tcase '*': // \"aflx*\"\n\t\t\tcase 0: // default for \"aflx\"\n\t\t\t{\n\t\t\t\tut64 addr = faddr (core, core->offset, NULL);\n\t\t\t\tSdb *db = sdb_new0 ();\n\t\t\t\t// sort by function and uniq to avoid dupped results\n\t\t\t\tRVecAnalRef *xrefs = r_anal_xrefs_get (core->anal, addr);\n\t\t\t\tif (xrefs) {\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tR_VEC_FOREACH (xrefs, ref) {\n\t\t\t\t\t\tbool nr = false;\n\t\t\t\t\t\tut64 fa = faddr (core, ref->addr, &nr);\n\t\t\t\t\t\tchar *key = r_str_newf (\"0x%08\"PFMT64x, fa);\n\t\t\t\t\t\tsdb_array_add_num (db, key, ref->addr, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSdbList *keys = sdb_foreach_list (db, true);\n\t\t\t\tSdbListIter *liter;\n\t\t\t\tSdbKv *kv;\n\t\t\t\tbool rad = input[3] == '*';\n\t\t\t\tbool verbose = input[3] == 'v';\n\t\t\t\tls_foreach (keys, liter, kv) {\n\t\t\t\t\tconst char *key = sdbkv_key (kv);\n\t\t\t\t\tconst char *value = sdbkv_value (kv);\n\t\t\t\t    if (verbose) {\n\t\t\t\t\t\tut64 fcn_xref_addr = r_num_get (NULL, key);\n\t\t\t\t\t\tRAnalFunction *xref = r_anal_get_fcn_in (core->anal, fcn_xref_addr, R_ANAL_FCN_TYPE_ANY);\n\t\t\t\t\t\tif (xref) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s %s\\n\",  xref->name, value);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (rad) {                                                                                                                                                                                      r_cons_printf (\"s %s;af-;af;s-\\n\", (const char *)kv->base.key);\n\t\t\t\t\t\tr_cons_printf (\"s %s;af-;af;s-\\n\", key);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"%s %s\\n\", key, value);\n\t\t\t\t}\n\t\t\t\tsdb_free (db);\n\t\t\t\tls_free (keys);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'j': // \"aflxj\"\n\t\t\t\tcmd_aflxj (core);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's': // \"afls\"\n\t\t\tswitch (input[3]) {\n\t\t\tdefault:\n\t\t\tcase '?':\n\t\t\t\tr_core_cmd_help (core, help_msg_afls);\n\t\t\t\treturn true;\n\t\t\tcase 0: // default for \"afls\"\n\t\t\tcase 'a': // \"aflsa\"\n\t\t\t\tcore->anal->fcns->sorted = false;\n\t\t\t\tr_list_sort (core->anal->fcns, cmpaddr);\n\t\t\t\tbreak;\n\t\t\tcase 'b': // \"aflsb\"\n\t\t\t\tcore->anal->fcns->sorted = false;\n\t\t\t\tr_list_sort (core->anal->fcns, cmpbbs);\n\t\t\t\tbreak;\n\t\t\tcase 's': // \"aflss\"\n\t\t\t\tcore->anal->fcns->sorted = false;\n\t\t\t\tr_list_sort (core->anal->fcns, cmpsize);\n\t\t\t\tbreak;\n\t\t\tcase 'n': // \"aflsn\"\n\t\t\t\tcore->anal->fcns->sorted = false;\n\t\t\t\tr_list_sort (core->anal->fcns, cmpname);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l': // \"afll\"\n\t\t\tif (input[3] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_afll);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough */\n\t\tcase ',': // \"afl,\"\n\t\tcase 't': // \"aflt\"\n\t\tcase 'j': // \"aflj\"\n\t\tcase 'q': // \"aflq\"\n\t\tcase 'm': // \"aflm\"\n\t\tcase '+': // \"afl+\"\n\t\tcase '=': // \"afl=\"\n\t\tcase '*': // \"afl*\"\n\t\tcase '.': // \"afl*\"\n\t\t\tr_core_anal_fcn_list (core, NULL, input + 2);\n\t\t\tbreak;\n\t\tcase 'c': // \"aflc\"\n\t\t\tr_cons_printf (\"%d\\n\", r_list_length (core->anal->fcns));\n\t\t\tbreak;\n\t\tcase ' ': // \"afl [addr]\" argument ignored\n\t\tcase 0: // \"afl\"\n\t\t\tr_core_anal_fcn_list (core, NULL, \"o\");\n\t\t\tbreak;\n\t\tdefault: // \"afl \"\n\t\t\tr_core_cmd_help (core, help_msg_afl);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 's': // \"afs\"\n\t\tswitch (input[2]) {\n\t\tcase '!': { // \"afs!\"\n\t\t\tchar *sig = r_core_cmd_str (core, \"afs\");\n\t\t\tchar *data = r_core_editor (core, NULL, sig);\n\t\t\tif (sig && data) {\n\t\t\t\tr_core_cmd_callf (core, \"afs %s\", data);\n\t\t\t}\n\t\t\tfree (sig);\n\t\t\tfree (data);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'r': { // \"afsr\"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\t\tif (fcn) {\n\t\t\t\tchar *type = r_str_newf (\"type.%s\", input + 4);\n\t\t\t\tif (sdb_exists (core->anal->sdb_types, type)) {\n\t\t\t\t\tchar *query = r_str_newf (\"anal/types/func.%s.ret=%s\", fcn->name, input + 4);\n\t\t\t\t\tsdb_querys (core->sdb, NULL, 0, query);\n\t\t\t\t\tfree (query);\n\t\t\t\t}\n\t\t\t\tfree (type);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"There's no function defined here\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase '*': // \"afs*\"\n\t\t\tcmd_afsr (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'j': // \"afsj\"\n\t\t\tcmd_afsj (core, input + 2);\n\t\t\tbreak;\n\t\tcase 0:\n\t\tcase ' ': { // \"afs\"\n\t\t\tut64 addr = core->offset;\n\t\t\tRAnalFunction *f;\n\t\t\tconst char *arg = r_str_trim_head_ro (input + 2);\n\t\t\tif ((f = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL))) {\n\t\t\t\tif (R_STR_ISNOTEMPTY (arg)) {\n\t\t\t\t\t// parse function signature here\n\t\t\t\t\tchar *fcnstr = r_str_newf (\"%s;\", arg), *fcnstr_copy = strdup (fcnstr);\n\t\t\t\t\tchar *save_ptr = NULL;\n\t\t\t\t\tchar *fcnname_aux = r_str_tok_r (fcnstr_copy, \"(\", &save_ptr);\n\t\t\t\t\tr_str_trim_tail (fcnname_aux);\n\t\t\t\t\tconst char *ls = r_str_lchr (fcnname_aux, ' ');\n\t\t\t\t\tchar *fcnname = strdup (ls? ls: fcnname_aux);\n\t\t\t\t\tif (fcnname) {\n\t\t\t\t\t\t// TODO: move this into r_anal_str_to_fcn()\n\t\t\t\t\t\tif (strcmp (f->name, fcnname)) {\n\t\t\t\t\t\t\t(void)__setFunctionName (core, addr, fcnname, false);\n\t\t\t\t\t\t\tf = r_anal_get_fcn_in (core->anal, addr, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_str_to_fcn (core->anal, f, fcnstr);\n\t\t\t\t\t}\n\t\t\t\t\tfree (fcnname);\n\t\t\t\t\tfree (fcnstr_copy);\n\t\t\t\t\tfree (fcnstr);\n\t\t\t\t} else {\n\t\t\t\t\tchar *str = r_anal_function_get_signature (f);\n\t\t\t\t\tif (str) {\n\t\t\t\t\t\tr_cons_println (str);\n\t\t\t\t\t\tfree (str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"No function defined at 0x%08\" PFMT64x, addr);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t// case '?': // \"afs?\"\n\t\t\tr_core_cmd_help (core, help_msg_afs);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'm': // \"afm\" - merge two functions\n\t\tif (input[2] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_afm);\n\t\t\tbreak;\n\t\t}\n\t\tr_core_anal_fcn_merge (core, core->offset, r_num_math (core->num, input + 2));\n\t\tbreak;\n\tcase 'M': // \"afM\" - print functions map\n\t\tr_core_anal_fmap (core, input + 1);\n\t\tbreak;\n\tcase 'v': // \"afv\"\n\t\tvar_cmd (core, input + 2);\n\t\tbreak;\n\tcase 't': // \"aft\"\n\t\ttype_cmd (core, input + 2);\n\t\tbreak;\n\tcase 'C': // \"afC\"\n\t\tif (input[2] == 'c') {\n\t\t\tRAnalFunction *fcn;\n\t\t\tif ((fcn = r_anal_get_fcn_in (core->anal, core->offset, 0))) {\n\t\t\t\tr_cons_printf (\"%i\\n\", r_anal_function_complexity (fcn));\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot find function at 0x08%\" PFMT64x, core->offset);\n\t\t\t}\n\t\t} else if (input[2] == 'l') {\n\t\t\tRAnalFunction *fcn;\n\t\t\tif ((fcn = r_anal_get_fcn_in (core->anal, core->offset, 0))) {\n\t\t\t\tr_cons_printf (\"%d\\n\", r_anal_function_loops (fcn));\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot find function at 0x08%\" PFMT64x, core->offset);\n\t\t\t}\n\t\t} else if (input[2] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_afC);\n\t\t} else {\n\t\t\tafCc (core, r_str_trim_head_ro (input + 2));\n\t\t}\n\t\tbreak;\n\tcase 'c': { // \"afc\"\n\t\tRAnalFunction *fcn = NULL;\n\t\tif (!input[2] || input[2] == ' ' || input[2] == 'i' || input[2] == 'r' || input[2] == 'a') {\n\t\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tif (!fcn) {\n\t\t\t\tR_LOG_ERROR (\"afc: Cannot find function here\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch (input[2]) {\n\t\tcase '\\0': // \"afc\"\n\t\t\tr_cons_println (fcn->cc);\n\t\t\tbreak;\n\t\tcase ' ': { // \"afc \"\n\t\t\t\t  char *cc = r_str_trim_dup (input + 3);\n\t\t\t\t  if (!r_anal_cc_exist (core->anal, cc)) {\n\t\t\t\t\t  const char *asmOs = r_config_get (core->config, \"asm.os\");\n\t\t\t\t\t  R_LOG_ERROR (\"afc: Unknown calling convention '%s' for '%s'. See afcl for available types\", cc, asmOs);\n\t\t\t\t  } else {\n\t\t\t\t\t  fcn->cc = r_str_constpool_get (&core->anal->constpool, cc);\n\t\t\t\t  }\n\t\t\t\t  free (cc);\n\t\t\t  }\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tcmd_afci (core, fcn);\n\t\t\tbreak;\n\t\tcase 'f': // \"afcf\" \"afcfj\"\n\t\t\tcmd_anal_fcn_sig (core, input + 3);\n\t\t\tbreak;\n\t\tcase 'k': // \"afck\"\n\t\t\tcmd_afck (core, NULL);\n\t\t\tbreak;\n\t\tcase 'l': // \"afcl\" list all function Calling conventions.\n\t\t\tif (input[3] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_afc);\n\t\t\t} else {\n\t\t\t\tcmd_tcc (core, input + 3);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'o': { // \"afco\"\n\t\t\t\t  char *dbpath = r_str_trim_dup (input + 3);\n\t\t\t\t  if (R_STR_ISNOTEMPTY (dbpath) && r_file_exists (dbpath)) {\n\t\t\t\t\t  Sdb *db = sdb_new (0, dbpath, 0);\n\t\t\t\t\t  if (db) {\n\t\t\t\t\t\t  sdb_merge (core->anal->sdb_cc, db);\n\t\t\t\t\t\t  sdb_close (db);\n\t\t\t\t\t\t  sdb_free (db);\n\t\t\t\t\t  }\n\t\t\t\t  } else {\n\t\t\t\t\t  r_core_cmd_help_match (core, help_msg_afc, \"afco\", true);\n\t\t\t\t  }\n\t\t\t\t  free (dbpath);\n\t\t\t  }\n\t\t\tbreak;\n\t\tcase 'r': { // \"afcr\"\n\t\t\tint i;\n\t\t\tPJ *pj = NULL;\n\t\t\tbool json = input[3] == 'j';\n\t\t\tif (json) {\n\t\t\t\tpj = r_core_pj_new (core);\n\t\t\t\tif (!pj) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpj_o (pj);\n\t\t\t}\n\t\t\tchar *cmd = r_str_newf (\"cc.%s.ret\", fcn->cc);\n\t\t\tconst char *regname = sdb_const_get (core->anal->sdb_cc, cmd, 0);\n\t\t\tif (regname) {\n\t\t\t\tif (json) {\n\t\t\t\t\tpj_ks (pj, \"ret\", regname);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s: %s\\n\", cmd, regname);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (cmd);\n\t\t\tif (json) {\n\t\t\t\tpj_ka (pj, \"args\");\n\t\t\t}\n\t\t\tfor (i = 0; i < R_ANAL_CC_MAXARG; i++) {\n\t\t\t\tcmd = r_str_newf (\"cc.%s.arg%d\", fcn->cc, i);\n\t\t\t\tregname = sdb_const_get (core->anal->sdb_cc, cmd, 0);\n\t\t\t\tif (regname) {\n\t\t\t\t\tif (json) {\n\t\t\t\t\t\tpj_s (pj, regname);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s: %s\\n\", cmd, regname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (cmd);\n\t\t\t}\n\t\t\tif (json) {\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tcmd = r_str_newf (\"cc.%s.self\", fcn->cc);\n\t\t\tregname = sdb_const_get (core->anal->sdb_cc, cmd, 0);\n\t\t\tif (regname) {\n\t\t\t\tif (json) {\n\t\t\t\t\tpj_ks (pj, \"self\", regname);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s: %s\\n\", cmd, regname);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (cmd);\n\t\t\tcmd = r_str_newf (\"cc.%s.error\", fcn->cc);\n\t\t\tregname = sdb_const_get (core->anal->sdb_cc, cmd, 0);\n\t\t\tif (regname) {\n\t\t\t\tif (json) {\n\t\t\t\t\tpj_ks (pj, \"error\", regname);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s: %s\\n\", cmd, regname);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (cmd);\n\t\t\tif (json) {\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'R': { // \"afcR\"\n\t\t\t/* very slow, but im tired of waiting for having this, so this is the quickest implementation */\n\t\t\tint i;\n\t\t\tchar *cc = r_core_cmd_str (core, \"k anal/cc/default.cc\");\n\t\t\tr_str_trim (cc);\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tchar *res = r_core_cmd_strf (core, \"k anal/cc/cc.%s.arg%d\", cc, i);\n\t\t\t\tr_str_trim_nc (res);\n\t\t\t\tif (*res) {\n\t\t\t\t\tchar *row = r_core_cmd_strf (core, \"drr~%s 0x\", res);\n\t\t\t\t\tr_str_trim (row);\n\t\t\t\t\tr_cons_printf (\"arg[%d] %s\\n\", i, row);\n\t\t\t\t\tfree (row);\n\t\t\t\t}\n\t\t\t\tfree (res);\n\t\t\t}\n\t\t\tfree (cc);\n\t\t\tbreak;\n\t\t}\n\t\tcase '?': // \"afc?\"\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_afc);\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'B': // \"afB\" // set function bits\n\t\tif (input[2] == ' ') {\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tif (fcn) { // bits = 0 means unset\n\t\t\t\tint nbits = atoi (input + 3);\n\t\t\t\tint obits = core->anal->config->bits;\n\t\t\t\tif (nbits > 0) {\n\t\t\t\t\tr_anal_hint_set_bits (core->anal, r_anal_function_min_addr (fcn), nbits);\n\t\t\t\t\tr_anal_hint_set_bits (core->anal, r_anal_function_max_addr (fcn), obits);\n\t\t\t\t\tfcn->bits = nbits;\n\t\t\t\t} else {\n\t\t\t\t\tr_anal_hint_unset_bits (core->anal, r_anal_function_min_addr (fcn));\n\t\t\t\t\tfcn->bits = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"afB: Cannot find function to set bits at 0x%08\"PFMT64x, core->offset);\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_cmd_help_match (core, help_msg_af, \"afB\", true);\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"afb\"\n\t\tswitch (input[2]) {\n\t\tcase '-': // \"afb-\"\n\t\t\tanal_fcn_del_bb (core, r_str_trim_head_ro (input + 3));\n\t\t\tbreak;\n\t\tcase 'o': // \"afbo\"\n\t\t\tafbo (core);\n\t\t\tbreak;\n\t\tcase 'e': // \"afbe\"\n\t\t\tanal_bb_edge (core, r_str_trim_head_ro (input + 3));\n\t\t\tbreak;\n\t\tcase 'F': { // \"afbF\"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\tif (fcn) {\n\t\t\t\tRAnalBlock *bb = r_anal_function_bbget_in (core->anal, fcn, core->offset);\n\t\t\t\tif (bb) {\n\t\t\t\t\tif (input[3]) {\n\t\t\t\t\t\tint n = atoi (input + 3);\n\t\t\t\t\t\tbb->folded = n;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbb->folded = !bb->folded;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tr_warn_if_reached ();\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0:\n\t\tcase ' ': // \"afb \"\n\t\tcase 'q': // \"afbq\"\n\t\tcase 'r': // \"afbr\"\n\t\tcase '=': // \"afb=\"\n\t\tcase '*': // \"afb*\"\n\t\tcase 'j': // \"afbj\"\n\t\tcase 't': // \"afbt\"\n\t\t\tanal_fcn_list_bb (core, input + 2, false);\n\t\t\tbreak;\n\t\tcase 'i': // \"afbi\"\n\t\t\tanal_fcn_list_bb (core, input + 2, true);\n\t\t\tbreak;\n\t\tcase '.': // \"afb.\"\n\t\t\tanal_fcn_list_bb (core, input[2]? \" $$\": input + 2, true);\n\t\t\tbreak;\n\t\tcase '+': // \"afb+\"\n\t\t\tcmd_afbplus (core, input + 3);\n\t\t\tbreak;\n\t\tcase 'c': // \"afbc\"\n\t\t\tcmd_afbc (core, r_str_trim_head_ro (input + 3));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_afb);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'n': // \"afn\"\n\t\tswitch (input[2]) {\n\t\tcase 's': // \"afns\"\n\t\t\tif (input[3] == 'j') { // \"afnsj\"\n\t\t\t\tfree (r_core_anal_fcn_autoname (core, core->offset, 1, input[3]));\n\t\t\t} else {\n\t\t\t\tfree (r_core_anal_fcn_autoname (core, core->offset, 1, 0));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a': // \"afna\"\n\t\t\tif (input[3] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_afna);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchar *name = r_core_anal_fcn_autoname (core, core->offset, 0, 0);\n\t\t\tif (name) {\n\t\t\t\tr_cons_printf (\"afn %s 0x%08\" PFMT64x \"\\n\", name, core->offset);\n\t\t\t\tfree (name);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '.': // \"afn.\"\n\t\tcase 0: { // \"afn\"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\t\tif (fcn) {\n\t\t\t\tr_cons_printf (\"%s\\n\", fcn->name);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ': { // \"afn \"\n\t\t\tut64 off = core->offset;\n\t\t\tchar *p, *name = strdup (r_str_trim_head_ro (input + 3));\n\t\t\tif ((p = strchr (name, ' '))) {\n\t\t\t\t*p++ = 0;\n\t\t\t\toff = r_num_math (core->num, p);\n\t\t\t}\n\t\t\tif (*name == '?') {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_afn, \"afn\", true);\n\t\t\t} else {\n\t\t\t\tif (r_str_startswith (name, \"base64:\")) {\n\t\t\t\t\tchar *res = (char *)r_base64_decode_dyn (name + 7, -1);\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tfree (name);\n\t\t\t\t\t\tname = res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!*name || !__setFunctionName (core, off, name, false)) {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot find function at 0x%08\" PFMT64x, off);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (name);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_afn);\n\t\t\tbreak;\n\t\t} // end of switch (input[2])\n\t\tbreak;\n\tcase 'S': { // afS\"\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\tif (fcn) {\n\t\t\tfcn->maxstack = r_num_math (core->num, input + 3);\n\t\t\t//fcn->stack = fcn->maxstack;\n\t\t}\n\t\tbreak;\n\t}\n#if 0\n\t/* this is undocumented, broken and probably have no uses. plz discuss */\n\tcase 'e': // \"afe\"\n\t\t{\n\t\tRAnalFunction *fcn;\n\t\tut64 off = core->offset;\n\t\tchar *p, *name = strdup ((input[2]&&input[3])? input + 3: \"\");\n\t\tif ((p = strchr (name, ' '))) {\n\t\t\t*p = 0;\n\t\t\toff = r_num_math (core->num, p + 1);\n\t\t}\n\t\tfcn = r_anal_get_fcn_in (core->anal, off, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\tif (fcn) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tRAnalRef *r;\n\t\t\tr_list_foreach (fcn->refs, iter, r) {\n\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" -%c 0x%08\" PFMT64x \"\\n\", r->at, r->type, r->addr);\n\t\t\t}\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint ok = 0;\n\t\t\t\tif (b->type == R_ANAL_BB_TYPE_LAST) ok = 1;\n\t\t\t\tif (b->type == R_ANAL_BB_TYPE_FOOT) ok = 1;\n\t\t\t\tif (b->jump == UT64_MAX && b->fail == UT64_MAX) ok = 1;\n\t\t\t\tif (ok) {\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" -r\\n\", b->addr);\n\t\t\t\t\t// TODO: check if destination is outside the function boundaries\n\t\t\t\t}\n\t\t\t}\n\t\t} else eprintf (\"Cannot find function at 0x%08\" PFMT64x \"\\n\", core->offset);\n\t\tfree (name);\n\t\t}\n\t\tbreak;\n#endif\n\tcase 'x': // \"afx\"\n\t\tswitch (input[2]) {\n\t\tcase 'm': // \"afxm\"\n\t\t\txrefs_map (core, input + 1);\n\t\t\tbreak;\n\t\tcase '\\0': // \"afx\"\n\t\tcase 'j': // \"afxj\"\n\t\tcase ' ': // \"afx \"\n\t\t{\n\t\t\tPJ *pj = r_core_pj_new (core);\n\t\t\tif (input[2] == 'j') {\n\t\t\t\tpj_a (pj);\n\t\t\t}\n\t\t\tif (!pj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// list xrefs from current address\n\t\t\t{\n\t\t\t\tut64 addr = (input[2] == ' ')? r_num_math (core->num, input + 2): core->offset;\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tut64 oaddr = core->offset;\n\t\t\t\t\tRVecAnalRef *refs = r_anal_function_get_refs (fcn);\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tR_VEC_FOREACH (refs, ref) {\n\t\t\t\t\t\tif (input[2] == 'j') {\n\t\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\t\tpj_ks (pj, \"type\", r_anal_ref_type_tostring (ref->type));\n\t\t\t\t\t\t\tpj_kn (pj, \"from\", ref->at);\n\t\t\t\t\t\t\tpj_kn (pj, \"to\", ref->addr);\n\t\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"%c 0x%08\" PFMT64x \" -> \", ref->type, ref->at);\n\t\t\t\t\t\t\tswitch (R_ANAL_REF_TYPE_MASK (ref->type)) {\n\t\t\t\t\t\t\tcase R_ANAL_REF_TYPE_NULL:\n\t\t\t\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" \", ref->addr);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase R_ANAL_REF_TYPE_CODE:\n\t\t\t\t\t\t\tcase R_ANAL_REF_TYPE_ICOD:\n\t\t\t\t\t\t\tcase R_ANAL_REF_TYPE_JUMP:\n\t\t\t\t\t\t\tcase R_ANAL_REF_TYPE_CALL:\n\t\t\t\t\t\t\tcase R_ANAL_REF_TYPE_DATA:\n\t\t\t\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" \", ref->addr);\n\t\t\t\t\t\t\t\tr_core_seek (core, ref->at, 1);\n\t\t\t\t\t\t\t\tr_core_print_disasm_instructions (core, 0, 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase R_ANAL_REF_TYPE_STRN:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tchar *s = r_core_cmd_strf (core, \"pxr 8 @ 0x%08\"PFMT64x, ref->addr);\n\t\t\t\t\t\t\t\t\tchar *nl = strchr (s, '\\n');\n\t\t\t\t\t\t\t\t\tif (nl) {\n\t\t\t\t\t\t\t\t\t\t*nl = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t\t\t\t\t\t\tfree (s);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// ignore rwx\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tRVecAnalRef_free (refs);\n\t\t\t\t\tr_core_seek (core, oaddr, 1);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"afx: Cannot find function at 0x%08\"PFMT64x, addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (input[2] == 'j') {\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t}\n\t\t\tpj_free (pj);\n\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tR_LOG_ERROR (\"Invalid command. Look at af?\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'F': // \"afF\"\n\t\t{\n\t\t\tint val = input[2] && r_num_math (core->num, input + 2);\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\tif (fcn) {\n\t\t\t\tfcn->folded = input[2]? val: !fcn->folded;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '?': // \"af?\"\n\t\tr_core_cmd_help (core, help_msg_af);\n\t\tbreak;\n\tcase 'r': // \"afr\" // analyze function recursively\n\tcase ' ': // \"af \"\n\tcase '\\0': // \"af\"\n\t\t{\n\t\t\tbool anal_calls = r_config_get_b (core->config, \"anal.calls\");\n\t\t\tif (input[0] && input[1] == 'r') {\n\t\t\t\tinput++;\n\t\t\t\tanal_calls = true;\n\t\t\t}\n\t\t\tut64 addr = core->offset;\n\t\t\tconst char *name = NULL;\n\t\t\t// first undefine\n\t\t\tif (input[0] && input[1] == ' ') {\n\t\t\t\tname = r_str_trim_head_ro (input + 2);\n\t\t\t\tchar *uaddr = strchr (name, ' ');\n\t\t\t\tif (uaddr) {\n\t\t\t\t\t*uaddr++ = 0;\n\t\t\t\t\taddr = r_num_math (core->num, uaddr);\n\t\t\t\t}\n\t\t\t\t// depth = 1; // or 1?\n\t\t\t\t// disable hasnext\n\t\t\t}\n\t\t\tr_core_af (core, addr, name, anal_calls);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nR_API void r_core_anal_undefine(RCore *core, ut64 off) {\n\t// very slow\n\t// RAnalFunction *f = r_anal_get_fcn_in (core->anal, off, -1);\n\tRAnalFunction *f = r_anal_get_function_at (core->anal, off);\n\tif (f) {\n\t\tif (!strncmp (f->name, \"fcn.\", 4)) {\n\t\t\tr_flag_unset_name (core->flags, f->name);\n\t\t}\n\t\tr_meta_del (core->anal, R_META_TYPE_ANY, r_anal_function_min_addr (f), r_anal_function_linear_size (f));\n\t\tr_anal_function_del (core->anal, off);\n\t}\n\t//r_anal_function_del_locs (core->anal, off);\n\tr_anal_delete_block_at (core->anal, off);\n\tchar *abcmd = r_str_newf (\"ab-0x%\"PFMT64x, off);\n\tif (abcmd) {\n\t\tcmd_af (core, abcmd);\n\t\tfree (abcmd);\n\t}\n}\n\n// size: 0: bits; -1: any; >0: exact size\nstatic void __anal_reg_list(RCore *core, int type, int bits, char mode) {\n\tPJ *pj = NULL;\n\tif (mode == 'i') {\n\t\tr_core_debug_ri (core, core->anal->reg, 0);\n\t\treturn;\n\t} else if (mode == 'j') {\n\t\tpj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t}\n\tRReg *hack = core->dbg->reg;\n\tcore->dbg->reg = core->anal->reg;\n\tconst char *use_color;\n\tint use_colors = r_config_get_i (core->config, \"scr.color\");\n\tif (use_colors) {\n#undef ConsP\n#define ConsP(x) (core->cons && core->cons->context->pal.x)? core->cons->context->pal.x\n\t\tuse_color = ConsP (creg) : Color_BWHITE;\n\t} else {\n\t\tuse_color = NULL;\n\t}\n\tif (bits < 0) {\n\t\t// TODO Change the `size` argument of r_debug_reg_list to use -1 for any and 0 for anal->config->bits\n\t\tbits = 0;\n\t} else if (!bits) {\n\t\tbits = core->anal->config->bits;\n\t}\n\tint mode2 = mode;\n\tconst char *arch_name = get_arch_name (core);\n\tcore->dbg->reg = core->anal->reg;\n\t/* workaround for thumb */\n\tif (r_str_startswith (arch_name, \"arm\") && bits == 16) {\n\t\tbits = 32;\n\t} else {\n\t\tconst int defsz = r_reg_default_bits (core->anal->reg);\n\t\tif (defsz > 0) {\n\t\t\tbits = defsz;\n\t\t}\n\t}\n\t/* workaround for 6502 and avr*/\n\tif ((!strcmp (arch_name, \"6502\") && bits == 8)\n\t\t|| (!strcmp (arch_name, \"avr\") && bits == 8)) {\n\t\tif (mode == 'j') {\n\t\t\tmode2 = 'J';\n\t\t\tpj_o (pj);\n\t\t}\n\t\t// XXX detect which one is current usage\n\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, 16, pj, mode2, use_color);\n\t}\n#if 0\n\tif (mode == '=') {\n\t\tint pcbits = 0;\n\t\tconst char *pcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\t\tif (pcname) {\n\t\t\tRRegItem *reg = r_reg_get (core->anal->reg, pcname, 0);\n\t\t\tif (reg && bits != reg->size) {\n\t\t\t\tpcbits = reg->size;\n\t\t\t}\n\t\t\tif (pcbits) {\n\t\t\t\t// r_debug_reg_list (core->dbg, R_REG_TYPE_GPR, pcbits, NULL, mode, use_color); // XXX detect which one is current usage\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tr_debug_reg_list (core->dbg, type, bits, pj, mode2, use_color);\n\tif (mode == 'j') {\n\t\tif (mode2 == 'J') {\n\t\t\tpj_end (pj);\n\t\t}\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\n\tcore->dbg->reg = hack;\n}\n\nstatic RRegItem *reg_by_name_role(RCore *core, const char *n) {\n\tRRegItem *r = r_reg_get (core->anal->reg, n, -1);\n\tif (!r) {\n\t\tint role = r_reg_get_name_idx (n);\n\t\tif (role != -1) {\n\t\t\tconst char *alias = r_reg_get_name (core->anal->reg, role);\n\t\t\tif (alias) {\n\t\t\t\tr = r_reg_get (core->anal->reg, alias, -1);\n\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}\n\nstatic bool reg_name_roll_set(RCore *core, const char *name, ut64 n) {\n\tRRegItem *r = reg_by_name_role (core, name);\n\tif (r) {\n\t\tr_reg_set_value (core->anal->reg, r, n);\n\t\tr_debug_reg_sync (core->dbg, R_REG_TYPE_ALL, true);\n\t\tr_core_cmdf (core, \".dr*%d\", core->anal->config->bits); // XXX: replace in future\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n// XXX dup from drp :OOO\nvoid cmd_anal_reg(RCore *core, const char *str) {\n#if 0\n\tif (0) {\n\t\t/* enable this block when dr and ar use the same code but just using\n\t\t   core->dbg->reg or core->anal->reg and removing all the debugger\n\t\t   dependent code */\n\t\tRReg *reg = core->dbg->reg;\n\t\tcore->dbg->reg = core->anal->reg;\n\t\tcmd_debug_reg (core, str);\n\t\tcore->dbg->reg = reg;\n\t\treturn;\n\t}\n#endif\n\tint size = 0, i, type = R_REG_TYPE_GPR;\n\tint use_colors = r_config_get_i (core->config, \"scr.color\");\n\tconst char *use_color = NULL;\n\tconst char *name;\n\tchar *arg;\n\tchar *save_ptr = NULL;\n\n\tif (use_colors) {\n#define ConsP(x) (core->cons && core->cons->context->pal.x)? core->cons->context->pal.x\n\t\tuse_color = ConsP (creg) : Color_BWHITE;\n\t}\n\tswitch (str[0]) {\n\tcase 'l': // \"arl\"\n\t{\n\t\tconst bool use_json = str[1] == 'j';\n\t\tRRegSet *rs = r_reg_regset_get (core->anal->reg, R_REG_TYPE_GPR);\n\t\tif (rs) {\n\t\t\tRRegItem *r;\n\t\t\tRListIter *iter;\n\t\t\tPJ *pj = pj_new ();\n\t\t\tpj_a (pj);\n\t\t\tr_list_foreach (rs->regs, iter, r) {\n\t\t\t\tif (use_json) {\n\t\t\t\t\tpj_s (pj, r->name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_println (r->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (use_json) {\n\t\t\t\tpj_end (pj);\n\t\t\t\tconst char *s = pj_string (pj);\n\t\t\t\tr_cons_println (s);\n\t\t\t}\n\t\t\tpj_free (pj);\n\t\t}\n\t} break;\n\tcase ',': // \"ar,\"\n\t\t__tableRegList (core, core->anal->reg, str + 1);\n\t\tbreak;\n\tcase '0': // \"ar0\"\n\t\tr_reg_arena_zero (core->anal->reg);\n\t\tbreak;\n\tcase 'A': // \"arA\"\n\t\t{\n\t\t\tint nargs = 4;\n\t\t\tRReg *reg = core->anal->reg;\n\t\t\tfor (i = 0; i < nargs; i++) {\n\t\t\t\tr_strf_var (regname, 32, \"A%d\", i);\n\t\t\t\tconst char *name = r_reg_get_name (reg, r_reg_get_name_idx (regname));\n\t\t\t\tut64 off = r_reg_getv (core->anal->reg, name);\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" \", off);\n\t\t\t\t// XXX very ugly hack\n\t\t\t\tchar *s = r_core_cmd_strf (core, \"pxr 32 @ 0x%08\"PFMT64x, off);\n\t\t\t\tif (s) {\n\t\t\t\t\tchar *nl = strchr (s, '\\n');\n\t\t\t\t\tif (nl) {\n\t\t\t\t\t\t*nl = 0;\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t\t\t}\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n//\t\t\t\tr_core_cmd0 (core, \"ar A0,A1,A2,A3\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'C': // \"arC\"\n\t\tif (core->anal->reg->reg_profile_cmt) {\n\t\t\tr_cons_println (core->anal->reg->reg_profile_cmt);\n\t\t}\n\t\tbreak;\n\tcase 'w': // \"arw\"\n\t\tswitch (str[1]) {\n\t\tcase '?': {\n\t\t\tr_core_cmd_help (core, help_msg_arw);\n\t\t\tbreak;\n\t\t}\n\t\tcase ' ':\n\t\t\tr_reg_arena_set_bytes (core->anal->reg, str + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_arw);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"ara\"\n\t\tswitch (str[1]) {\n\t\tcase '?': // \"ara?\"\n\t\t\tr_core_cmd_help (core, help_msg_ara);\n\t\t\tbreak;\n\t\tcase 's': // \"aras\"\n\t\t\tr_reg_arena_swap (core->anal->reg, false);\n\t\t\tbreak;\n\t\tcase '+': // \"ara+\"\n\t\t\tr_reg_arena_push (core->anal->reg);\n\t\t\tbreak;\n\t\tcase '-': // \"ara-\"\n\t\t\tr_reg_arena_pop (core->anal->reg);\n\t\t\tbreak;\n\t\tdefault: {\n\t\t\tint i, j;\n\t\t\tRRegArena *a;\n\t\t\tRListIter *iter;\n\t\t\tfor (i = 0; i < R_REG_TYPE_LAST; i++) {\n\t\t\t\tRRegSet *rs = &core->anal->reg->regset[i];\n\t\t\t\tj = 0;\n\t\t\t\tr_list_foreach (rs->pool, iter, a) {\n\t\t\t\t\tr_cons_printf (\"%s %p %d %d %s %d\\n\",\n\t\t\t\t\t\t(a == rs->arena)? \"*\": \".\", a,\n\t\t\t\t\t\ti, j, r_reg_get_type (i), a->size);\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t\tbreak;\n\tcase '?': // \"ar?\"\n\t\tif (str[1]) {\n\t\t\tut64 off = r_reg_getv (core->anal->reg, str + 1);\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", off);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ar);\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"arr\"\n\t\tswitch (str[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help_match (core, help_msg_dr, \"drr\", false);\n\t\t\tbreak;\n\t\tcase 'j': // \"arrj\"\n\t\t\tr_core_debug_rr (core, core->anal->reg, 'j');\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_debug_rr (core, core->anal->reg, 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'S': { // \"arS\"\n\t\tint sz;\n\t\tut8 *buf = r_reg_get_bytes (core->anal->reg, R_REG_TYPE_GPR, &sz);\n\t\tr_cons_printf (\"%d\\n\", sz);\n\t\tfree (buf);\n\t\t} break;\n\tcase 'b': { // \"arb\" WORK IN PROGRESS // DEBUG COMMAND\n\t\tint len, type = R_REG_TYPE_GPR;\n\t\targ = strchr (str, ' ');\n\t\tif (arg) {\n\t\t\tchar *string = r_str_trim_dup (arg + 1);\n\t\t\tif (string) {\n\t\t\t\ttype = r_reg_type_by_name (string);\n\t\t\t\tif (type == -1 && string[0] != 'a') {\n\t\t\t\t\ttype = R_REG_TYPE_GPR;\n\t\t\t\t}\n\t\t\t\tfree (string);\n\t\t\t}\n\t\t}\n\t\tut8 *buf = r_reg_get_bytes (core->dbg->reg, type, &len);\n\t\tif (buf) {\n\t\t\tr_print_hexdump (core->print, 0LL, buf, len, 32, 4, 1);\n\t\t\tfree (buf);\n\t\t}\n\t\t} break;\n\tcase 'c': // \"arc\"\n\t\t// TODO: set flag values with drc zf=1\n\t\tif (str[1] == 'q') { // \"arcq\"\n\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\tif (rf) {\n\t\t\t\tr_cons_printf (\"s:%d z:%d c:%d o:%d p:%d\\n\",\n\t\t\t\t\t\trf->s, rf->z, rf->c, rf->o, rf->p);\n\t\t\t\tfree (rf);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (str[1] == 'c') { // \"arcc\"\n\t\t\tchar *s = r_reg_profile_to_cc (core->anal->reg);\n\t\t\tif (s) {\n\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t} else {\n\t\t\tRRegItem *r;\n\t\t\tconst char *name = r_str_trim_head_ro (str + 1);\n\t\t\tif (*name && name[1]) {\n\t\t\t\tr = r_reg_cond_get (core->dbg->reg, name);\n\t\t\t\tif (r) {\n\t\t\t\t\tr_cons_println (r->name);\n\t\t\t\t} else {\n\t\t\t\t\tint id = r_reg_cond_from_string (name);\n\t\t\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\t\t\tif (rf) {\n\t\t\t\t\t\tint o = r_reg_cond_bits (core->dbg->reg, id, rf);\n\t\t\t\t\t\tr_core_return_value (core, o);\n\t\t\t\t\t\t// ORLY?\n\t\t\t\t\t\tr_cons_printf (\"%d\\n\", o);\n\t\t\t\t\t\tfree (rf);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tR_LOG_ERROR (\"unknown conditional or flag register\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\t\tif (rf) {\n\t\t\t\t\tr_cons_printf (\"| s:%d z:%d c:%d o:%d p:%d\\n\",\n\t\t\t\t\t\trf->s, rf->z, rf->c, rf->o, rf->p);\n\t\t\t\t\tif (*name == '=') {\n\t\t\t\t\t\tfor (i = 0; i < R_REG_COND_LAST; i++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s:%d \",\n\t\t\t\t\t\t\t\tr_reg_cond_tostring (i),\n\t\t\t\t\t\t\t\tr_reg_cond_bits (core->dbg->reg, i, rf));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (i = 0; i < R_REG_COND_LAST; i++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%d %s\\n\",\n\t\t\t\t\t\t\t\tr_reg_cond_bits (core->dbg->reg, i, rf),\n\t\t\t\t\t\t\t\tr_reg_cond_tostring (i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (rf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 's': // \"ars\"\n\t\tswitch (str[1]) {\n\t\tcase '-': // \"ars-\"\n\t\t\tr_reg_arena_pop (core->dbg->reg);\n\t\t\t// restore debug registers if in debugger mode\n\t\t\tr_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, true);\n\t\t\tbreak;\n\t\tcase '+': // \"ars+\"\n\t\t\tr_reg_arena_push (core->dbg->reg);\n\t\t\tbreak;\n\t\tcase '?': { // \"ars?\"\n\t\t\t// TODO #7967 help refactor: dup from drp\n\t\t\tRCoreHelpMessage help_msg = {\n\t\t\t\t\"Usage:\", \"drs\", \" # Register states commands\",\n\t\t\t\t\"drs\", \"\", \"list register stack\",\n\t\t\t\t\"drs+\", \"\", \"push register state\",\n\t\t\t\t\"drs-\", \"\", \"pop register state\",\n\t\t\t\tNULL };\n\t\t\tr_core_cmd_help (core, help_msg);\n\t\t} break;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tvoid *p = core->dbg->reg->regset[0].pool;\n\t\t\t\tint len = p? r_list_length (p): 0;\n\t\t\t\tr_cons_printf (\"%d\\n\", len);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'p': // \"arp\"\n\t\t// XXX we have to break out .h for these cmd_xxx files.\n\t\tcmd_reg_profile (core, 'a', str);\n\t\tbreak;\n\tcase 't': // \"art\"\n\t\tif (str[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_dr, \"drt\", false);\n\t\t} else {\n\t\t\tfor (i = 0; (name = r_reg_get_type (i)); i++) {\n\t\t\t\tr_cons_println (name);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'n': // \"arn\"\n\t\tif (*(str + 1) == '\\0') {\n\t\t\tR_LOG_ERROR (\"Oops. try arn [PC|SP|BP|SN|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\");\n\t\t\tbreak;\n\t\t}\n\t\tname = r_reg_get_name (core->dbg->reg, r_reg_get_name_idx (str + 2));\n\t\tif (name && *name) {\n\t\t\tr_cons_println (name);\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Oops. try arn [PC|SP|BP|SN|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\");\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"ard\"\n\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, core->anal->config->bits,\n\t\t\tNULL, 3, use_color); // XXX detect which one is current usage\n\t\tbreak;\n\tcase 'o': // \"aro\"\n\t\tr_reg_arena_swap (core->dbg->reg, false);\n\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, core->anal->config->bits,\n\t\t\tNULL, 0, use_color); // XXX detect which one is current usage\n\t\tr_reg_arena_swap (core->dbg->reg, false);\n\t\tbreak;\n\tcase '=': // \"ar=\"\n\t\t{\n\t\t\tchar *p = NULL;\n\t\t\tchar *bitstr = NULL;\n\t\t\tif (str[1]) {\n\t\t\t\tp = r_str_trim_dup (str + 1);\n\t\t\t\tif (str[1] != ':') {\n\t\t\t\t\t// Bits were specified\n\t\t\t\t\tbitstr = r_str_tok_r (p, \":\", &save_ptr);\n\t\t\t\t\tif (r_str_isnumber (bitstr)) {\n\t\t\t\t\t\tst64 sz = r_num_math (core->num, bitstr);\n\t\t\t\t\t\tif (sz > 0) {\n\t\t\t\t\t\t\tsize = sz;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_core_cmd_help (core, help_msg_ar);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint len = bitstr ? strlen (bitstr) : 0;\n\t\t\t\tif (str[len + 1] == ':') {\n\t\t\t\t\t// We have some regs\n\t\t\t\t\tchar *regs = bitstr ? r_str_tok_r (NULL, \":\", &save_ptr) : r_str_tok_r ((char *)str + 1, \":\", &save_ptr);\n\t\t\t\t\tchar *reg = r_str_tok_r (regs, \" \", &save_ptr);\n\t\t\t\t\tRList *q_regs = r_list_new ();\n\t\t\t\t\tif (q_regs) {\n\t\t\t\t\t\twhile (reg) {\n\t\t\t\t\t\t\tr_list_append (q_regs, reg);\n\t\t\t\t\t\t\treg = r_str_tok_r (NULL, \" \", &save_ptr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcore->dbg->q_regs = q_regs;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (size < 32 && r_str_startswith (r_config_get (core->config, \"asm.arch\"), \"arm\")) {\n\t\t\t\tsize = 32;\n\t\t\t}\n\t\t\t__anal_reg_list (core, type, size, str[0]);\n\t\t\tif (!r_list_empty (core->dbg->q_regs)) {\n\t\t\t\tr_list_free (core->dbg->q_regs);\n\t\t\t}\n\t\t\tcore->dbg->q_regs = NULL;\n\t\t\tfree (p);\n\t\t}\n\t\tbreak;\n\tcase '.': // \"ar.\"\n\tcase '-': // \"ar-\"\n\tcase '*': // \"ar*\"\n\tcase 'R': // \"arR\"\n\tcase 'j': // \"arj\"\n\tcase 'i': // \"ari\"\n\tcase '\\0': // \"ar\"\n\t\t__anal_reg_list (core, type, size, str[0]);\n\t\tbreak;\n\tcase ' ': { // \"ar \"\n\t\targ = strchr (str + 1, '=');\n\t\tif (arg) {\n\t\t\t*arg = 0;\n\t\t\tut64 n = r_num_math (core->num, arg + 1);\n\t\t\tchar *ostr = r_str_trim_dup (str + 1);\n\t\t\tchar *regname = r_str_trim_nc (ostr);\n\t\t\tif (!reg_name_roll_set (core, regname, n)) {\n\t\t\t\tR_LOG_ERROR (\"ar: Unknown register '%s'\", regname);\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\treturn;\n\t\t}\n\t\tchar name[32];\n\t\tint i = 1, j;\n\t\twhile (str[i]) {\n\t\t\tif (str[i] == ',') {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tfor (j = i; str[++j] && str[j] != ','; );\n\t\t\t\tif (j - i + 1 <= sizeof name) {\n\t\t\t\t\tr_str_ncpy (name, str + i, j - i + 1);\n\t\t\t\t\tif (IS_DIGIT (name[0])) { // e.g. ar 32\n\t\t\t\t\t\t__anal_reg_list (core, R_REG_TYPE_GPR, atoi (name), '\\0');\n\t\t\t\t\t} else if (showreg (core, name) > 0) {\n\t\t\t\t\t\t// e.g. ar rax\n\t\t\t\t\t} else { // e.g. ar gpr ; ar all\n\t\t\t\t\t\ttype = r_reg_type_by_name (name);\n\t\t\t\t\t\t// TODO differentiate ALL and illegal register types and print error message for the latter\n\t\t\t\t\t\t__anal_reg_list (core, type, -1, '\\0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nR_API int r_core_esil_step(RCore *core, ut64 until_addr, const char *until_expr, ut64 *prev_addr, bool stepOver) {\n#define return_tail(x) { tail_return_value = x; goto tail_return; }\n\tint tail_return_value = 0;\n\tint ret;\n\tut8 code[32];\n\tRAnalOp op = {0};\n\tREsil *esil = core->anal->esil;\n\t// esil->trap = 0;\n\tconst char *_pcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (R_STR_ISEMPTY (_pcname)) {\n\t\tR_LOG_ERROR (\"Cannot find =PC in current reg profile\");\n\t\treturn 0;\n\t}\n\tchar *pcname = strdup (_pcname);\n\tconst bool r2wars = r_config_get_b (core->config, \"cfg.r2wars\");\n\tconst bool breakoninvalid = r_config_get_b (core->config, \"esil.breakoninvalid\");\n\tconst int esiltimeout = r_config_get_i (core->config, \"esil.timeout\");\n\tut64 startTime = 0;\n\n\tif (esiltimeout > 0) {\n\t\tstartTime = r_time_now_mono ();\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tut64 addr = -1;\n\tut64 oaddr = -1;\n\tint minopsz = r_arch_info (core->anal->arch, R_ARCH_INFO_MIN_OP_SIZE);\n\tut64 naddr = addr + minopsz;\n\tbool notfirst = false;\n\tfor (; true; r_anal_op_fini (&op)) {\n\t\tesil->trap = 0;\n\t\toaddr = addr;\n\t\taddr = r_reg_getv (core->anal->reg, \"PC\");\n\t\tif (notfirst && addr == oaddr) {\n\t\t\tr_reg_setv (core->anal->reg, \"PC\", naddr);\n\t\t\taddr = naddr;\n\t\t} else {\n\t\t\tnotfirst = true;\n\t\t}\n\t\tR_LOG_DEBUG (\"esil step at 0x%08\"PFMT64x, addr);\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tR_LOG_INFO (\"[+] ESIL emulation interrupted at 0x%08\" PFMT64x, addr);\n\t\t\treturn_tail (0);\n\t\t}\n\t\t// Break if we have exceeded esil.timeout\n\t\tif (esiltimeout > 0) {\n\t\t\tut64 elapsedTime = r_time_now_mono () - startTime;\n\t\t\telapsedTime >>= 20;\n\t\t\tif (elapsedTime >= esiltimeout) {\n\t\t\t\tR_LOG_INFO (\"[ESIL] Timeout exceeded\");\n\t\t\t\treturn_tail (0);\n\t\t\t}\n\t\t}\n\t\tif (prev_addr) {\n\t\t\t*prev_addr = addr;\n\t\t}\n\t\tconst int perm = esil->exectrap ? R_PERM_X: 0;\n\t\tif (!r_io_is_valid_offset (core->io, addr, perm)) {\n\t\t\tesil->trap = R_ANAL_TRAP_EXEC_ERR;\n\t\t\tesil->trap_code = addr;\n\t\t\tR_LOG_INFO (\"[ESIL] Trap, trying to execute on non-executable memory\");\n\t\t\treturn_tail (1);\n\t\t}\n\t\t// eprintf (\"addr %llx\\n\", addr);\n\t\tr_asm_set_pc (core->rasm, addr);\n\t\t// run esil pin command here\n\t\tconst char *pincmd = r_anal_pin_call (core->anal, addr);\n\t\tif (pincmd) {\n\t\t\tr_core_cmd0 (core, pincmd);\n\t\t\tut64 pc = r_reg_getv (core->anal->reg, pcname);\n\t\t\tif (addr != pc) {\n\t\t\t\tR_LOG_ERROR (\"pincmd fail\");\n\t\t\t\treturn_tail (1);\n\t\t\t}\n\t\t}\n\t\tint dataAlign = r_anal_archinfo (esil->anal, R_ANAL_ARCHINFO_DATA_ALIGN);\n\t\tif (dataAlign > 1) {\n\t\t\tif (addr % dataAlign) {\n\t\t\t\tif (esil->cmd && R_STR_ISNOTEMPTY (esil->cmd_trap)) {\n\t\t\t\t\tesil->cmd (esil, esil->cmd_trap, addr, R_ANAL_TRAP_UNALIGNED);\n\t\t\t\t}\n\t\t\t\tif (breakoninvalid) {\n\t\t\t\t\tR_LOG_INFO (\"Execution stopped on unaligned instruction (see e?esil.breakoninvalid)\");\n\t\t\t\t\treturn_tail (0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t(void) r_io_read_at (core->io, addr, code, sizeof (code));\n\t\t// TODO: sometimes this is dupe\n\t\tret = r_anal_op (core->anal, &op, addr, code, sizeof (code), R_ARCH_OP_MASK_ESIL | R_ARCH_OP_MASK_HINT);\n\t\tnaddr = addr + op.size;\n\t\t// if type is JMP then we execute the next N instructions\n\t\t// update the esil pointer because RAnal.op() can change it\n\t\tesil = core->anal->esil;\n\t\tif (op.size < 1 || ret < 1) {\n\t\t\t// eprintf (\"esil trap\\n\");\n\t\t\tif (esil->cmd && R_STR_ISNOTEMPTY (esil->cmd_trap)) {\n\t\t\t\tesil->cmd (esil, esil->cmd_trap, addr, R_ANAL_TRAP_INVALID);\n\t\t\t}\n\t\t\tif (breakoninvalid) {\n\t\t\t\tR_LOG_INFO (\"Stopped execution in an invalid instruction (see e??esil.breakoninvalid)\");\n\t\t\t\treturn_tail (0);\n\t\t\t}\n\t\t\tif (op.size < 1) {\n\t\t\t\top.size = 1; // avoid inverted stepping\n\t\t\t}\n\t\t}\n\t\tif (stepOver) {\n\t\t\tswitch (op.type) {\n\t\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tcase R_ANAL_OP_TYPE_CRET:\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\t\tif (addr == until_addr) {\n\t\t\t\t\treturn_tail (0);\n\t\t\t\t} else {\n\t\t\t\t\tr_reg_setv (core->anal->reg, pcname, op.addr + op.size);\n\t\t\t\t\tr_reg_setv (core->dbg->reg, pcname, op.addr + op.size);\n\t\t\t\t}\n\t\t\t\treturn_tail (1);\n\t\t\t}\n\t\t}\n\t\tif (r2wars) {\n\t\t\t// this is x86 and r2wars specific, shouldnt hurt outside x86\n\t\t\tut64 vECX = r_reg_getv (core->anal->reg, \"ecx\");\n\t\t\tif (op.prefix  & R_ANAL_OP_PREFIX_REP && vECX > 1) {\n\t\t\t\t//char *tmp = strstr (op.esil.ptr, \",ecx,?{,5,GOTO,}\");\n\t\t\t\tchar *tmp = strstr (op.esil.ptr, \",0,GOTO\");\n\t\t\t\tif (tmp) {\n\t\t\t\t\ttmp[0] = 0;\n\t\t\t\t\top.esil.len -= 7; //16;\n\t\t\t\t} else {\n\t\t\t\t\tr_reg_setv (core->anal->reg, pcname, addr + op.size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_reg_setv (core->anal->reg, pcname, addr + op.size);\n\t\t\t}\n\t\t} else {\n\t\t\tr_reg_setv (core->anal->reg, pcname, addr + op.size);\n\t\t}\n\t\tif (ret) {\n\t\t\tr_esil_set_pc (esil, addr);\n\t\t\tconst char *e = R_STRBUF_SAFEGET (&op.esil);\n\t\t\tif (core->dbg->trace->enabled) {\n\t\t\t\tRReg *reg = core->dbg->reg;\n\t\t\t\tcore->dbg->reg = core->anal->reg;\n\t\t\t\tr_debug_trace_op (core->dbg, &op);\n\t\t\t\tcore->dbg->reg = reg;\n\t\t\t} else if (R_STR_ISNOTEMPTY (e)) {\n\t\t\t\tr_esil_parse (esil, e);\n\t\t\t\tif (esil->trap) {\n\t\t\t\t\tR_LOG_WARN (\"ESIL TRAP %d/%d ON %s at 0x%08\"PFMT64x,\n\t\t\t\t\t\t\tesil->trap, esil->trap_code, e, addr);\n\t\t\t\t\tif (r_config_get_b (core->config, \"esil.exectrap\")) {\n\t\t\t\t\t\tR_LOG_INFO (\"ESIL TRAP ignored\");\n\t\t\t\t\t\tesil->trap = false;\n\t\t\t\t\t}\n\t\t\t\t}\n#if 0\n\t\t\t\t// XXX thats not related to arch plugins, and wonder if its useful at all or we want it as part of the anal or esil plugs\n\t\t\t\tif (core->anal->cur && core->anal->cur->esil_post_loop) {\n\t\t\t\t\tcore->anal->cur->esil_post_loop (esil, &op);\n\t\t\t\t}\n#endif\n\t\t\t\t// warn if esil stack is not empty\n\t\t\t\tr_esil_stack_free (esil);\n\t\t\t}\n\t\t\tbool isNextFall = false;\n\t\t\tif (op.type == R_ANAL_OP_TYPE_CJMP) {\n\t\t\t\tint err = 0;\n\t\t\t\tut64 pc = r_reg_getv (core->anal->reg, pcname);\n\t\t\t\tif (err) {\n\t\t\t\t\tR_LOG_ERROR (\"Missing PC register in the current profile\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (pc == addr + op.size) {\n\t\t\t\t\t// do not opdelay here\n\t\t\t\t\tisNextFall = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// only support 1 slot for now\n\t\t\tif (op.delay && !isNextFall) {\n\t\t\t\tut8 code2[32];\n\t\t\t\t// ut64 naddr = addr + op.size;\n\t\t\t\tRAnalOp op2 = {0};\n\t\t\t\t// emulate only 1 instruction\n\t\t\t\tr_esil_set_pc (esil, naddr);\n\t\t\t\t(void)r_io_read_at (core->io, naddr, code2, sizeof (code2));\n\t\t\t\t// TODO: sometimes this is dupe\n\t\t\t\tret = r_anal_op (core->anal, &op2, naddr, code2, sizeof (code2), R_ARCH_OP_MASK_ESIL | R_ARCH_OP_MASK_HINT);\n\t\t\t\tif (ret > 0) {\n\t\t\t\t\tswitch (op2.type) {\n\t\t\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_CRET:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\t\t\t\t// branches are illegal in a delay slot\n\t\t\t\t\t\tesil->trap = R_ANAL_TRAP_EXEC_ERR;\n\t\t\t\t\t\tesil->trap_code = addr;\n\t\t\t\t\t\tR_LOG_INFO (\"[ESIL] Trap, trying to execute a branch in a delay slot\");\n\t\t\t\t\t\treturn_tail (1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst char *e = R_STRBUF_SAFEGET (&op2.esil);\n\t\t\t\t\tif (R_STR_ISNOTEMPTY (e)) {\n\t\t\t\t\t\tr_esil_parse (esil, e);\n\t\t\t\t\t\tesil->trap = false; // ignore traps on delayed instructions for now\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Invalid instruction at 0x%08\"PFMT64x, naddr);\n\t\t\t\t}\n\t\t\t\tr_anal_op_fini (&op2);\n\t\t\t}\n\t\t\ttail_return_value = 1;\n\t\t}\n\t\t// esil->verbose ?\n\t\t// eprintf (\"REPE 0x%llx %s => 0x%llx\\n\", addr, R_STRBUF_SAFEGET (&op.esil), r_reg_getv (core->anal->reg, \"PC\"));\n\t\tut64 pc = r_reg_getv (core->anal->reg, pcname);\n\t\tif (pc == UT64_MAX || pc == UT32_MAX) {\n\t\t\tR_LOG_ERROR (\"Invalid program counter PC=-1 coming from 0x%08\"PFMT64x, addr);\n\t\t\tbreak;\n\t\t}\n\t\tif (core->anal->config->codealign > 0) {\n\t\t\tpc -= (pc % core->anal->config->codealign);\n\t\t\tr_reg_setv (core->anal->reg, pcname, pc);\n\t\t\tr_reg_setv (core->dbg->reg, pcname, pc);\n\t\t}\n\t\tst64 follow = (st64)r_config_get_i (core->config, \"dbg.follow\");\n\t\tif (follow > 0) {\n\t\t\tif ((pc < core->offset) || (pc > (core->offset + follow))) {\n\t\t\t\tr_core_seek (core, pc, true);\n\t\t\t}\n\t\t}\n\t\t// check breakpoints\n\t\tif (r_bp_get_at (core->dbg->bp, pc)) {\n\t\t\tR_LOG_INFO (\"esil breakpoint hit at 0x%\"PFMT64x, pc);\n\t\t\treturn_tail (0);\n\t\t}\n\t\t// check addr\n\t\tif (until_addr != UT64_MAX) {\n\t\t\tif (pc == until_addr) {\n\t\t\t\treturn_tail (0);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n#if 1\n\t\tif (esil->trap) {\n\t\t\tR_LOG_DEBUG (\"TRAP\");\n\t\t\treturn_tail (0);\n\t\t}\n#endif\n\t\tif (until_expr) {\n\t\t\t// eprintf (\"CHK %s\\n\", until_expr);\n\t\t\tif (r_esil_condition (esil, until_expr)) {\n\t\t\t\tR_LOG_INFO (\"ESIL BREAK!\");\n\t\t\t\treturn_tail (0);\n\t\t\t}\n\t\t\tesil->trap = false;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\ntail_return:\n\tr_anal_op_fini (&op);\n\tr_cons_break_pop ();\n\tfree (pcname);\n\treturn tail_return_value;\n}\n\nR_API bool r_core_esil_step_back(RCore *core) {\n\tr_return_val_if_fail (core && core->anal, false);\n#if 0\n\tif (!core->anal->esil || !core->anal->esil->trace) {\n\t\tR_LOG_INFO (\"Run `aeim` to initialize the esil VM and enable e dbg.trace=true\");\n\t\treturn false;\n\t}\n#endif\n\tREsil *esil = core->anal->esil;\n\tif (esil && esil->trace->idx > 0) {\n\t\tr_esil_trace_restore (esil, esil->trace->idx - 1);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void cmd_address_info(RCore *core, const char *addrstr, int fmt) {\n\tut64 addr = R_STR_ISEMPTY (addrstr)? core->offset: r_num_math (core->num, addrstr);\n\tut64 type = r_core_anal_address (core, addr);\n\tswitch (fmt) {\n\tcase 'j': {\n\t\tPJ *pj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_o (pj);\n\t\tif (type & R_ANAL_ADDR_TYPE_PROGRAM) {\n\t\t\tpj_ks (pj, \"program\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_LIBRARY) {\n\t\t\tpj_ks (pj, \"library\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_EXEC) {\n\t\t\tpj_ks (pj, \"exec\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_READ) {\n\t\t\tpj_ks (pj, \"read\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_WRITE) {\n\t\t\tpj_ks (pj, \"write\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_FLAG) {\n\t\t\tpj_ks (pj, \"flag\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_FUNC) {\n\t\t\tpj_ks (pj, \"func\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_STACK) {\n\t\t\tpj_ks (pj, \"stack\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_HEAP) {\n\t\t\tpj_ks (pj, \"heap\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_REG) {\n\t\t\tpj_ks (pj, \"reg\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_ASCII) {\n\t\t\tpj_ks (pj, \"ascii\", \"true\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_SEQUENCE) {\n\t\t\tpj_ks (pj, \"sequence\", \"true\");\n\t\t}\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (type & R_ANAL_ADDR_TYPE_PROGRAM) {\n\t\t\tr_cons_printf (\"program\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_LIBRARY) {\n\t\t\tr_cons_printf (\"library\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_EXEC) {\n\t\t\tr_cons_printf (\"exec\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_READ) {\n\t\t\tr_cons_printf (\"read\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_WRITE) {\n\t\t\tr_cons_printf (\"write\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_FLAG) {\n\t\t\tr_cons_printf (\"flag\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_FUNC) {\n\t\t\tr_cons_printf (\"func\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_STACK) {\n\t\t\tr_cons_printf (\"stack\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_HEAP) {\n\t\t\tr_cons_printf (\"heap\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_REG) {\n\t\t\tr_cons_printf (\"reg\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_ASCII) {\n\t\t\tr_cons_printf (\"ascii\\n\");\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_SEQUENCE) {\n\t\t\tr_cons_printf (\"sequence\\n\");\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_info(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_ai);\n\t\tbreak;\n\tcase ' ':\n\t\tcmd_address_info (core, input, 0);\n\t\tbreak;\n\tcase 'a': // \"aia\"\n\t\tif (input[1] == 'j') { // \"aiaj\"\n\t\t\tPJ *pj = pj_new ();\n\t\t\tpj_o (pj);\n\t\t\tint v = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\t\tpj_ki (pj, \"minopsz\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\t\tpj_ki (pj, \"maxopsz\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_INV_OP_SIZE);\n\t\t\tpj_ki (pj, \"invopsz\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_DATA_ALIGN);\n\t\t\tpj_ki (pj, \"dtalign\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tpj_ki (pj, \"codealign\", v);\n\t\t\tpj_end (pj);\n\t\t\tchar *s = pj_drain (pj);\n\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\tfree (s);\n\t\t} else {\n\t\t\tint v = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\t\tr_cons_printf (\"minopsz %d\\n\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\t\tr_cons_printf (\"maxopsz %d\\n\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_INV_OP_SIZE);\n\t\t\tr_cons_printf (\"invopsz %d\\n\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_DATA_ALIGN);\n\t\t\tr_cons_printf (\"dtalign %d\\n\", v);\n\t\t\tv = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tr_cons_printf (\"codealign %d\\n\", v);\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"aii\"\n\t\t// global imports\n\t\tif (input[1]) {\n\t\t\tif (input[1] == ' ') {\n\t\t\t\tchar *s = r_str_trim_dup (input + 1);\n\t\t\t\tif (s) {\n\t\t\t\t\tr_anal_add_import (core->anal, s);\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n\t\t\t} else if (input[1] == '-') {\n\t\t\t\tr_anal_purge_imports (core->anal);\n\t\t\t} else {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_ai, \"aii\", true);\n\t\t\t}\n\t\t} else {\n\t\t\tif (core->anal->imports) {\n\t\t\t\tchar *imp;\n\t\t\t\tRListIter *iter;\n\t\t\t\tr_list_foreach (core->anal->imports, iter, imp) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", imp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"aij\"\n\t\tcmd_address_info (core, input + 1, 'j');\n\t\tbreak;\n\tdefault:\n\t\tcmd_address_info (core, NULL, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void initialize_stack(RCore *core, ut64 addr, ut64 size) {\n\tconst char *mode = r_config_get (core->config, \"esil.fillstack\");\n\tif (mode && *mode && *mode != '0') {\n\t\tconst ut64 bs = 4096 * 32;\n\t\tut64 i;\n\t\tfor (i = 0; i < size; i += bs) {\n\t\t\tut64 left = R_MIN (bs, size - i);\n\t\t//\tr_core_cmdf (core, \"wx 10203040 @ 0x%llx\", addr);\n\t\t\tswitch (*mode) {\n\t\t\tcase 'd': // \"debrujn\"\n\t\t\t\tr_core_cmdf (core, \"wopD %\"PFMT64u\" @ 0x%\"PFMT64x, left, addr + i);\n\t\t\t\tbreak;\n\t\t\tcase 's': // \"seq\"\n\t\t\t\tr_core_cmdf (core, \"woe 1 0xff 1 4 @ 0x%\"PFMT64x\"!0x%\"PFMT64x, addr + i, left);\n\t\t\t\tbreak;\n\t\t\tcase 'r': // \"random\"\n\t\t\t\tr_core_cmdf (core, \"woR %\"PFMT64u\" @ 0x%\"PFMT64x\"!0x%\"PFMT64x, left, addr + i, left);\n\t\t\t\tbreak;\n\t\t\tcase 'z': // \"zero\"\n\t\t\tcase '0':\n\t\t\t\tr_core_cmdf (core, \"wow 00 @ 0x%\"PFMT64x\"!0x%\"PFMT64x, addr + i, left);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// eprintf (\"[*] Initializing ESIL stack with pattern\\n\");\n\t\t// r_core_cmdf (core, \"woe 0 10 4 @ 0x%\"PFMT64x, size, addr);\n\t}\n}\n\nstatic void cmd_esil_mem(RCore *core, const char *input) {\n\tREsil *esil = core->anal->esil;\n\tRIOMap *stack_map;\n\tut64 curoff = core->offset;\n\tconst char *patt = \"\";\n\tut64 addr = 0x100000;\n\tut32 size = 0xf0000;\n\tRFlagItem *fi;\n\tchar uri[32];\n\tchar nomalloc[256];\n\tif (*input == '?') {\n\t\tr_core_cmd_help (core, help_msg_aeim);\n\t\treturn;\n\t}\n\tif (r_config_get_b (core->config, \"cfg.debug\")) {\n\t\tR_LOG_WARN (\"When cfg.debug is set, I refuse to create a fake stack\");\n\t\treturn;\n\t}\n\n\tif (input[0] == 'p') {\n\t\tfi = r_flag_get (core->flags, \"aeim.stack\");\n\t\tif (fi) {\n\t\t\taddr = fi->offset;\n\t\t\tsize = fi->size;\n\t\t} else {\n\t\t\tcmd_esil_mem (core, \"\");\n\t\t}\n\t\tesil->stack_addr = addr;\n\t\tesil->stack_size = size;\n\t\tinitialize_stack (core, addr, size);\n\t\treturn;\n\t}\n\n\tif (R_STR_ISEMPTY (input)) {\n\t\tchar *fi = sdb_get (core->sdb, \"aeim.fd\", 0);\n\t\tif (fi) {\n\t\t\t// Close the fd associated with the aeim stack\n\t\t\tut64 fd = sdb_atoi (fi);\n\t\t\t(void)r_io_fd_close (core->io, fd);\n\t\t\tfree (fi);\n\t\t}\n\t}\n\tsize = r_config_get_i (core->config, \"esil.stack.size\");\n\taddr = r_config_get_i (core->config, \"esil.stack.addr\");\n\n\tif (r_io_map_is_mapped (core->io, addr)) {\n\t\taddr = core->offset;\n\t\tr_io_map_locate (core->io, &addr, size, 0x10000000);\n\t}\n\tpatt = r_config_get (core->config, \"esil.stack.pattern\");\n\tr_str_ncpy (nomalloc, input, 255);\n\tchar *p = nomalloc;\n\tchar *name = NULL;\n\tif ((p = strchr (p, ' '))) {\n\t\tp = (char *)r_str_trim_head_ro (p);\n\t\taddr = r_num_math (core->num, p);\n\t\tif ((p = strchr (p, ' '))) {\n\t\t\tp = (char *)r_str_trim_head_ro (p);\n\t\t\tsize = (ut32)r_num_math (core->num, p);\n\t\t\tif (size < 1) {\n\t\t\t\tsize = 0xf0000;\n\t\t\t}\n\t\t\tif ((p = strchr (p, ' '))) {\n\t\t\t\tp = (char *)r_str_trim_head_ro (p);\n\t\t\t\tname = r_str_newf (\"mem.%s\", p);\n\t\t\t} else {\n\t\t\t\tname = r_str_newf (\"mem.0x%\" PFMT64x \"_0x%x\", addr, size);\n\t\t\t}\n\t\t} else {\n\t\t\tname = r_str_newf (\"mem.0x%\" PFMT64x \"_0x%x\", addr, size);\n\t\t}\n\t} else {\n\t\tname = r_str_newf (\"mem.0x%\" PFMT64x \"_0x%x\", addr, size);\n\t}\n\tif (*input == '-') {\n\t\tif (esil->stack_fd > 2) { // 0, 1, 2 are reserved for stdio/stderr\n\t\t\tr_io_fd_close (core->io, esil->stack_fd);\n\t\t\t// no need to kill the maps, r_io_map_cleanup does that for us in the close\n\t\t\tesil->stack_fd = 0;\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot deinitialize %s\", name);\n\t\t}\n\t\tr_flag_unset_name (core->flags, name);\n\t\tr_flag_unset_name (core->flags, \"aeim.stack\");\n\t\tsdb_unset (core->sdb, \"aeim.fd\", 0);\n\t\tfree (name);\n\t\treturn;\n\t}\n\n\tsnprintf (uri, sizeof (uri), \"malloc://%d\", (int)size);\n\tesil->stack_fd = r_io_fd_open (core->io, uri, R_PERM_RW, 0);\n\tif (!(stack_map = r_io_map_add (core->io, esil->stack_fd, R_PERM_RW, 0LL, addr, size))) {\n\t\tr_io_fd_close (core->io, esil->stack_fd);\n\t\tR_LOG_ERROR (\"Cannot create map for tha stack, fd %d got closed again\", esil->stack_fd);\n\t\tesil->stack_fd = 0;\n\t\treturn;\n\t}\n\tr_io_map_set_name (stack_map, name);\n\tfree (name);\n\t// r_flag_set (core->flags, name, addr, size);\t//why is this here?\n\tchar val[128], *v;\n\tv = sdb_itoa (esil->stack_fd, 10, val, sizeof (val));\n\tsdb_set (core->sdb, \"aeim.fd\", v, 0);\n\n\tr_config_set_b (core->config, \"io.va\", true);\n\tif (R_STR_ISNOTEMPTY (patt)) {\n\t\tswitch (*patt) {\n\t\tcase '0':\n\t\t\t// do nothing\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tr_core_cmdf (core, \"wopD %d @ 0x%\"PFMT64x, size, addr);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tr_core_cmdf (core, \"woe 0 255 1 @ 0x%\"PFMT64x\"!%d\",addr, size);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tr_core_cmdf (core, \"woe 0 0xffff 1 4 @ 0x%\"PFMT64x\"!%d\",addr, size);\n\t\t\tbreak;\n\t\t}\n\t}\n\t// SP\n\tut64 sp = addr + (size / 2);\n\tr_reg_setv (core->anal->reg, \"SP\", sp);\n\tr_reg_setv (core->anal->reg, \"BP\", sp);\n\tr_reg_setv (core->anal->reg, \"PC\", curoff);\n\tr_core_cmd0 (core, \".ar*\");\n\tesil->stack_addr = addr;\n\tesil->stack_size = size;\n\tinitialize_stack (core, addr, size);\n\tr_core_seek (core, curoff, false);\n}\n\ntypedef struct {\n\tRList *regs;\n\tRList *regread;\n\tRList *regwrite;\n\tRList *regvalues;\n\tRList *inputregs;\n} AeaStats;\n\nstatic void aea_stats_init(AeaStats *stats) {\n\tstats->regs = r_list_newf (free);\n\tstats->regread = r_list_newf (free);\n\tstats->regwrite = r_list_newf (free);\n\tstats->regvalues = r_list_newf (free);\n\tstats->inputregs = r_list_newf (free);\n}\n\nstatic void aea_stats_fini(AeaStats *stats) {\n\tR_FREE (stats->regs);\n\tR_FREE (stats->regread);\n\tR_FREE (stats->regwrite);\n\tR_FREE (stats->inputregs);\n}\n\nstatic bool contains(RList *list, const char *name) {\n\tRListIter *iter;\n\tconst char *n;\n\tr_list_foreach (list, iter, n) {\n\t\tif (!strcmp (name, n))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic R_TH_LOCAL char *oldregread = NULL;\nstatic R_TH_LOCAL RList *mymemxsr = NULL;\nstatic R_TH_LOCAL RList *mymemxsw = NULL;\n\n#define R_NEW_DUP(x) memcpy((void*)malloc (sizeof (x)), &(x), sizeof (x))\ntypedef struct {\n\tut64 addr;\n\tint size;\n} AeaMemItem;\n\nstatic bool mymemwrite(REsil *esil, ut64 addr, const ut8 *buf, int len) {\n\tAeaMemItem *n;\n\tRListIter *iter;\n\tr_list_foreach (mymemxsw, iter, n) {\n\t\tif (addr == n->addr) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (!r_io_is_valid_offset (esil->anal->iob.io, addr, 0)) {\n\t\treturn false;\n\t}\n\tn = R_NEW (AeaMemItem);\n\tif (n) {\n\t\tn->addr = addr;\n\t\tn->size = len;\n\t\tr_list_push (mymemxsw, n);\n\t}\n\treturn true;\n}\n\nstatic bool mymemread(REsil *esil, ut64 addr, ut8 *buf, int len) {\n\tRListIter *iter;\n\tAeaMemItem *n;\n\tr_list_foreach (mymemxsr, iter, n) {\n\t\tif (addr == n->addr) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (!r_io_is_valid_offset (esil->anal->iob.io, addr, 0)) {\n\t\treturn false;\n\t}\n\tn = R_NEW (AeaMemItem);\n\tif (n) {\n\t\tn->addr = addr;\n\t\tn->size = len;\n\t\tr_list_push (mymemxsr, n);\n\t}\n\treturn true;\n}\n\nstatic bool myregwrite(REsil *esil, const char *name, ut64 *val) {\n\tAeaStats *stats = esil->user;\n\tif (oldregread && !strcmp (name, oldregread)) {\n\t\tr_list_pop (stats->regread);\n\t\tR_FREE (oldregread)\n\t}\n\tif (!IS_DIGIT (*name)) {\n\t\tif (!contains (stats->regs, name)) {\n\t\t\tr_list_push (stats->regs, strdup (name));\n\t\t}\n\t\tif (!contains (stats->regwrite, name)) {\n\t\t\tr_list_push (stats->regwrite, strdup (name));\n\t\t}\n\t\tchar *v = r_str_newf (\"%\"PFMT64d, *val);\n\t\tif (!contains (stats->regvalues, v)) {\n\t\t\tr_list_push (stats->regvalues, strdup (v));\n\t\t}\n\t\tfree (v);\n\t}\n\treturn false;\n}\n\nstatic bool myregread(REsil *esil, const char *name, ut64 *val, int *len) {\n\tAeaStats *stats = esil->user;\n\tif (!IS_DIGIT (*name)) {\n\t\tif (!contains (stats->inputregs, name)) {\n\t\t\tif (!contains (stats->regwrite, name)) {\n\t\t\t\tr_list_push (stats->inputregs, strdup (name));\n\t\t\t}\n\t\t}\n\t\tif (!contains (stats->regs, name)) {\n\t\t\tr_list_push (stats->regs, strdup (name));\n\t\t}\n\t\tif (!contains (stats->regread, name)) {\n\t\t\tr_list_push (stats->regread, strdup (name));\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void showregs(RList *list) {\n\tif (!r_list_empty (list)) {\n\t\tchar *reg;\n\t\tRListIter *iter;\n\t\tr_list_foreach (list, iter, reg) {\n\t\t\tr_cons_print (reg);\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_printf (\" \");\n\t\t\t}\n\t\t}\n\t}\n\tr_cons_newline ();\n}\n\nstatic void showmem(RList *list) {\n\tif (!r_list_empty (list)) {\n\t\tAeaMemItem *item;\n\t\tRListIter *iter;\n\t\tr_list_foreach (list, iter, item) {\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, item->addr);\n\n\t\t}\n\t}\n\tr_cons_newline ();\n}\n\nstatic void showregs_json(RList *list, PJ *pj) {\n\tpj_a (pj);\n\tif (!r_list_empty (list)) {\n\t\tchar *reg;\n\t\tRListIter *iter;\n\n\t\tr_list_foreach (list, iter, reg) {\n\t\t\tpj_s (pj, reg);\n\t\t}\n\t}\n\tpj_end (pj);\n}\n\nstatic void showmem_json(RList *list, PJ *pj) {\n\tpj_a (pj);\n\tif (!r_list_empty (list)) {\n\t\tRListIter *iter;\n\t\tAeaMemItem *item;\n\t\tr_list_foreach (list, iter, item) {\n\t\t\tpj_n (pj, item->addr);\n\t\t}\n\t}\n\tpj_end (pj);\n}\n\nstatic bool cmd_aea(RCore* core, int mode, ut64 addr, int length) {\n\tint ptr, ops, ops_end = 0, len, buf_sz;\n\tut64 addr_end;\n\tAeaStats stats;\n\tconst char *esilstr;\n\tRAnalOp aop = {0};\n\tRList* regnow;\n\tPJ *pj = NULL;\n\tif (!core) {\n\t\treturn false;\n\t}\n\tint maxopsize = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\tif (maxopsize < 1) {\n\t\tmaxopsize = 16;\n\t}\n\tif (mode & 1) {\n\t\t// number of bytes / length\n\t\tbuf_sz = length;\n\t} else {\n\t\t// number of instructions / opcodes\n\t\tops_end = length;\n\t\tif (ops_end < 1) {\n\t\t\tops_end = 1;\n\t\t}\n\t\tbuf_sz = ops_end * maxopsize;\n\t}\n\tif (buf_sz < 1) {\n\t\tbuf_sz = maxopsize;\n\t}\n\taddr_end = addr + buf_sz;\n\tut8 *buf = malloc (buf_sz);\n\tif (!buf) {\n\t\treturn false;\n\t}\n\t(void)r_io_read_at (core->io, addr, (ut8 *)buf, buf_sz);\n\taea_stats_init (&stats);\n\tr_reg_arena_push (core->anal->reg);\n\tconst bool cfg_r2wars = r_config_get_b (core->config, \"cfg.r2wars\");\n\tREsil *esil = esil_new_setup (core);\n\tif (!esil) {\n\t\tfree (buf);\n\t\treturn false;\n\t}\n#\tdefine hasNext(x) (x&1) ? (addr<addr_end) : (ops<ops_end)\n\n\tmymemxsr = r_list_new ();\n\tmymemxsw = r_list_new ();\n\tesil->user = &stats;\n\tesil->cb.hook_reg_write = myregwrite;\n\tesil->cb.hook_reg_read = myregread;\n\tesil->cb.hook_mem_write = mymemwrite;\n\tesil->cb.hook_mem_read = mymemread;\n\tesil->nowrite = true;\n\tr_cons_break_push (NULL, NULL);\n\tfor (ops = ptr = 0; ptr < buf_sz && hasNext (mode); ops++, ptr += len) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tlen = r_anal_op (core->anal, &aop, addr + ptr, buf + ptr, buf_sz - ptr, R_ARCH_OP_MASK_ESIL | R_ARCH_OP_MASK_HINT);\n\t\tesilstr = R_STRBUF_SAFEGET (&aop.esil);\n\t\tif (R_STR_ISNOTEMPTY (esilstr)) {\n\t\t\tif (len < 1) {\n\t\t\t\tR_LOG_ERROR (\"Invalid 0x%08\"PFMT64x\" instruction %02x %02x\",\n\t\t\t\t\taddr + ptr, buf[ptr], buf[ptr + 1]);\n\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cfg_r2wars) {\n\t\t\t\tif (aop.prefix  & R_ANAL_OP_PREFIX_REP) {\n\t\t\t\t\tchar *tmp = strstr (esilstr, \",0,GOTO\");\n\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\ttmp[0] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_esil_parse (esil, esilstr);\n\t\t\tr_esil_stack_free (esil);\n\t\t}\n\t\tr_anal_op_fini (&aop);\n\t\tif (len < 1) {\n\t\t\tlen = 1;\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\tesil->nowrite = false;\n\tesil->cb.hook_reg_write = NULL;\n\tesil->cb.hook_reg_read = NULL;\n\tr_esil_free (esil);\n\tr_reg_arena_pop (core->anal->reg);\n\tregnow = r_list_newf (free);\n\t{\n\t\tRListIter *iter;\n\t\tchar *reg;\n\t\tr_list_foreach (stats.regs, iter, reg) {\n\t\t\tif (!contains (stats.regwrite, reg)) {\n\t\t\t\tr_list_push (regnow, strdup (reg));\n\t\t\t}\n\t\t}\n\t}\n\tif ((mode >> 5) & 1) {\n\t\tRListIter *iter;\n\t\tAeaMemItem *n;\n\t\tint c = 0;\n\t\tr_cons_printf (\"f-mem.*\\n\");\n\t\tr_list_foreach (mymemxsr, iter, n) {\n\t\t\tr_cons_printf (\"f mem.read.%d 0x%08x @ 0x%08\"PFMT64x\"\\n\", c++, n->size, n->addr);\n\t\t}\n\t\tc = 0;\n\t\tr_list_foreach (mymemxsw, iter, n) {\n\t\t\tr_cons_printf (\"f mem.write.%d 0x%08x @ 0x%08\"PFMT64x\"\\n\", c++, n->size, n->addr);\n\t\t}\n\t}\n\n\t/* show registers used */\n\tif ((mode >> 1) & 1) {\n\t\tshowregs (stats.regread);\n\t} else if ((mode >> 2) & 1) {\n\t\tshowregs (stats.regwrite);\n\t} else if ((mode >> 3) & 1) {\n\t\tshowregs (regnow);\n\t} else if ((mode >> 4) & 1) {\n\t\tpj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn false;\n\t\t}\n\t\tpj_o (pj);\n\t\tpj_k (pj, \"A\");\n\t\tshowregs_json (stats.regs, pj);\n\t\tpj_k (pj, \"I\");\n\t\tshowregs_json (stats.inputregs, pj);\n\t\tpj_k (pj, \"R\");\n\t\tshowregs_json (stats.regread, pj);\n\t\tpj_k (pj, \"W\");\n\t\tshowregs_json (stats.regwrite, pj);\n\t\tif (!r_list_empty (stats.regvalues)) {\n\t\t\tpj_k (pj, \"V\");\n\t\t\tshowregs_json (stats.regvalues, pj);\n\t\t}\n\t\tif (!r_list_empty (regnow)) {\n\t\t\tpj_k (pj, \"N\");\n\t\t\tshowregs_json (regnow, pj);\n\t\t}\n\t\tif (!r_list_empty (mymemxsr)) {\n\t\t\tpj_k (pj, \"@R\");\n\t\t\tshowmem_json (mymemxsr, pj);\n\t\t}\n\t\tif (!r_list_empty (mymemxsw)) {\n\t\t\tpj_k (pj, \"@W\");\n\t\t\tshowmem_json (mymemxsw, pj);\n\t\t}\n\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t} else if ((mode >> 5) & 1) {\n\t\t// nothing\n\t} else {\n\t\tif (!r_list_empty (stats.inputregs)) {\n\t\t\tr_cons_printf (\" I: \");\n\t\t\tshowregs (stats.inputregs);\n\t\t}\n\t\tif (!r_list_empty (stats.regs)) {\n\t\t\tr_cons_printf (\" A: \");\n\t\t\tshowregs (stats.regs);\n\t\t}\n\t\tif (!r_list_empty (stats.regread)) {\n\t\t\tr_cons_printf (\" R: \");\n\t\t\tshowregs (stats.regread);\n\t\t}\n\t\tif (!r_list_empty (stats.regwrite)) {\n\t\t\tr_cons_printf (\" W: \");\n\t\t\tshowregs (stats.regwrite);\n\t\t}\n\t\tif (!r_list_empty (stats.regvalues)) {\n\t\t\tr_cons_printf (\" V: \");\n\t\t\tshowregs (stats.regvalues);\n\t\t}\n\t\tif (!r_list_empty (regnow)) {\n\t\t\tr_cons_printf (\" N: \");\n\t\t\tshowregs (regnow);\n\t\t}\n\t\tif (!r_list_empty (mymemxsr)) {\n\t\t\tr_cons_printf (\"@R:\");\n\t\t\tshowmem (mymemxsr);\n\t\t}\n\t\tif (!r_list_empty (mymemxsw)) {\n\t\t\tr_cons_printf (\"@W:\");\n\t\t\tshowmem (mymemxsw);\n\t\t}\n\t}\n\n\tr_list_free (mymemxsr);\n\tr_list_free (mymemxsw);\n\tmymemxsr = NULL;\n\tmymemxsw = NULL;\n\taea_stats_fini (&stats);\n\tfree (buf);\n\tR_FREE (regnow);\n\treturn true;\n}\n\nstatic void cmd_aespc(RCore *core, ut64 addr, ut64 until_addr, int ninstr) {\n\tREsil *esil = core->anal->esil;\n\tint i, j = 0;\n\tRAnalOp aop = {0};\n\tint ret , bsize = R_MAX (4096, core->blocksize);\n\tconst int mininstrsz = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tconst int minopcode = R_MAX (1, mininstrsz);\n\tconst char *pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);\n\n#if 0\n\t// eprintf (\"   aesB %llx %llx %d\\n\", addr, until_addr, off); // 0x%08llx %d  %s\\n\", aop.addr, ret, aop.mnemonic);\n\tif (!esil) {\n\t\tR_LOG_DEBUG (\"cmd_espc: creating new esil instance\");\n\t\tesil = esil_new_setup (core);\n\t\tif (!esil) {\n\t\t\treturn;\n\t\t}\n\t\tr_esil_free (core->anal->esil);\n\t\tcore->anal->esil = esil;\n\t}\n#endif\n\tut8 *buf = malloc (bsize);\n\tif (!buf) {\n\t\tR_LOG_ERROR (\"Cannot allocate %d byte(s)\", bsize);\n\t\treturn;\n\t}\n\tif (addr == UT64_MAX) {\n\t\taddr = r_reg_getv (core->dbg->reg, pc);\n\t}\n\tut64 cursp = r_reg_getv (core->dbg->reg, \"SP\");\n\tut64 oldoff = core->offset;\n\tconst ut64 flags = R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT | R_ARCH_OP_MASK_ESIL | R_ARCH_OP_MASK_DISASM;\n\tfor (i = 0, j = 0; j < ninstr; i++, j++) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tif (i >= (bsize - 32)) {\n\t\t\ti = 0;\n\t\t\tR_LOG_WARN (\"Chomp %d of %d\", i, bsize);\n\t\t}\n\t\tif (!i) {\n\t\t\tr_io_read_at (core->io, addr, buf, bsize);\n\t\t}\n\t\tif (addr == until_addr) {\n\t\t\tbreak;\n\t\t}\n\t\tret = r_anal_op (core->anal, &aop, addr, buf + i, bsize - i, flags);\n\t\tif (ret < 1) {\n\t\t\tR_LOG_ERROR (\"Failed analysis at 0x%08\"PFMT64x, addr);\n\t\t\tr_anal_op_fini (&aop);\n\t\t\tbreak;\n\t\t}\n\t\t// skip calls and such\n\t\tswitch (aop.type) {\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\tcase R_ANAL_OP_TYPE_CCALL:\n\t\tcase R_ANAL_OP_TYPE_UCCALL:\n\t\t\t// skip\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_reg_setv (core->anal->reg, \"PC\", aop.addr + aop.size);\n\t\t\tr_reg_setv (core->dbg->reg, \"PC\", aop.addr + aop.size);\n\t\t\tconst char *e = R_STRBUF_SAFEGET (&aop.esil);\n\t\t\tif (R_STR_ISNOTEMPTY (e)) {\n\t\t\t\t // eprintf (\"   0x%08llx %d  %s\\n\", aop.addr, ret, aop.mnemonic);\n\t\t\t\t(void)r_esil_parse (esil, e);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tint inc = (core->search->align > 0)? core->search->align - 1: ret - 1;\n\t\tif (inc < 0) {\n\t\t\tinc = minopcode;\n\t\t}\n\t\ti += inc;\n\t\taddr += aop.size;\n\t\tr_anal_op_fini (&aop);\n\t}\n\tfree (buf);\n\tr_core_seek (core, oldoff, true);\n\tr_reg_setv (core->dbg->reg, \"SP\", cursp);\n}\n\nstatic void r_anal_aefa(RCore *core, const char *arg) {\n\tut64 to = r_num_math (core->num, arg);\n\tut64 at, from = core->offset;\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, to, -1);\n\tif (!from || from == UT64_MAX) {\n\t\tif (fcn) {\n\t\t\tfrom = fcn->addr;\n\t\t} else {\n\t\t\tR_LOG_INFO (\"Usage: aefa [from] # if no from address is given, uses fcn.addr\");\n\t\t\treturn;\n\t\t}\n\t}\n\tR_LOG_INFO (\"Emulate from 0x%08\"PFMT64x\" to 0x%08\"PFMT64x, from, to);\n\tR_LOG_INFO (\"Resolve call args for 0x%08\"PFMT64x, to);\n\n\t// emulate\n\t// XXX do not use commands, here, just use the api\n\tr_core_cmd_call (core, \"aeim\"); // XXX\n\tut64 off = core->offset;\n\tfor (at = from; at < to ; at++) {\n\t\tr_core_cmdf (core, \"aepc 0x%08\"PFMT64x, at);\n\t\tr_core_cmd_call (core, \"aeso\");\n\t\tr_core_seek (core, at, true);\n\t\tint delta = r_num_get (core->num, \"$l\");\n\t\tif (delta < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tat += delta - 1;\n\t}\n\tr_core_seek (core, off, true);\n\n\t// the logic of identifying args by function types and\n\t// show json format and arg name goes into arA\n\tr_core_cmd_call (core, \"arA\");\n#if 0\n\t// get results\n\tconst char *fcn_type = r_type_func_ret (core->anal->sdb_types, fcn->name);\n\tconst char *key = resolve_fcn_name (core->anal, fcn->name);\n\tRList *list = r_core_get_func_args (core, key);\n\tif (!r_list_empty (list)) {\n\t\teprintf (\"HAS signature\\n\");\n\t}\n\tint i, nargs = 3; // r_type_func_args_count (core->anal->sdb_types, fcn->name);\n\tif (nargs > 0) {\n\t\tint i;\n\t\teprintf (\"NARGS %d (%s)\\n\", nargs, key);\n\t\tfor (i = 0; i < nargs; i++) {\n\t\t\tut64 v = r_debug_arg_get (core->dbg, \"reg\", i);\n\t\t\teprintf (\"arg: 0x%08\"PFMT64x\"\\n\", v);\n\t\t}\n\t}\n#endif\n}\n\nstatic void __core_anal_appcall(RCore *core, const char *input) {\n//\tr_reg_arena_push (core->dbg->reg);\n\tRListIter *iter;\n\tchar *arg;\n\tchar *inp = strdup (input);\n\tRList *args = r_str_split_list (inp, \" \", 0);\n\tint i = 0;\n\tr_list_foreach (args, iter, arg) {\n\t\tr_strf_var (alias, 32, \"A%d\", i);\n\t\tr_reg_setv (core->anal->reg, alias, r_num_math (core->num, arg));\n\t\ti++;\n\t}\n\tut64 sp = r_reg_getv (core->anal->reg, \"SP\");\n\tr_reg_setv (core->anal->reg, \"SP\", 0);\n\n\tr_reg_setv (core->anal->reg, \"PC\", core->offset);\n\tr_core_cmd_call (core, \"aesu 0\");\n\n\tr_reg_setv (core->anal->reg, \"SP\", sp);\n\tfree (inp);\n\n//\tr_reg_arena_pop (core->dbg->reg);\n}\n\nstatic void cmd_debug_stack_init(RCore *core, int argc, char **argv, char **envp) {\n\t// TODO: add support for 32 bit\n\tRBuffer *b = r_buf_new ();\n\tif (!b) {\n\t\treturn;\n\t}\n\tut64 sp = core->offset;\n\tint i;\n\tut64 dyld_call_from = UT64_MAX;\n\tr_buf_append_ut64 (b, dyld_call_from);\n\tr_buf_append_ut64 (b, 0); // rbp\n\tr_buf_append_ut64 (b, argc); // rbp\n\tint envp_count = 0;\n\tfor (i = 0; envp[i]; i++) {\n\t\tenvp_count++;\n\t}\n\tut64 strp = sp + 40 + (argc * 8) + (envp_count * 8);\n\t// pointer table\n\tfor (i = 0; i < argc && argv[i]; i++) {\n\t\tr_buf_append_ut64 (b, strp);\n\t\tstrp += strlen (argv[i]) + 1;\n\t}\n\tr_buf_append_ut64 (b, 0);\n\tfor (i = 0; i < envp_count; i++) {\n\t\tr_buf_append_ut64 (b, strp);\n\t\tstrp += strlen (envp[i]) + 1;\n\t}\n\tr_buf_append_ut64 (b, 0);\n\t// string table\n\tfor (i = 0; i < argc && argv[i]; i++) {\n\t\tr_buf_append_string (b, argv[i]);\n\t\tr_buf_append_ut8 (b, 0);\n\t}\n\tfor (i = 0; i < envp_count; i++) {\n\t\tr_buf_append_string (b, envp[i]);\n\t\tr_buf_append_ut8 (b, 0);\n\t}\n\tint slen = 0;\n\tut8 *s = r_buf_read_all (b, &slen);\n\tchar *x = r_hex_bin2strdup (s, slen);\n\tr_cons_printf (\"wx %s\\n\", x);\n\tfree (x);\n\tfree (s);\n\tr_buf_free (b);\n}\n\nR_IPI int core_type_by_addr(RCore *core, ut64 addr) {\n\tconst RList *list = r_flag_get_list (core->flags, addr);\n\tRListIter *iter;\n\tRFlagItem *item;\n\tbool has_flag = false;\n\tint type = R_ANAL_REF_TYPE_DATA;\n\tr_list_foreach (list, iter, item) {\n\t\tif (strchr (item->name, '.')) {\n\t\t\thas_flag = true;\n\t\t\tif (r_str_startswith (item->name, \"str\")) {\n\t\t\t\ttype = R_ANAL_REF_TYPE_STRN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!has_flag) {\n\t\treturn -1;\n\t}\n\treturn type;\n}\n\nstatic bool regwrite_hook(REsil *esil, const char *name, ut64 *val) {\n\tRCore *core = esil->user;\n\tint type = core_type_by_addr (core, *val);\n\tif (type != -1) {\n\t\tr_anal_xrefs_set (core->anal, esil->addr, *val, type);\n\t}\n\treturn false;\n}\n\nstatic void __anal_esil_function(RCore *core, ut64 addr) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n#if 0\n\tif (!core->anal->esil) {\n\t\tr_core_cmd_call (core, \"aei\");\n\t}\n#endif\n\tif (!sdb_const_get (core->sdb, \"aeim.fd\", 0)) {\n\t\tr_core_cmd_call (core, \"aeim\"); // should be set by default imho\n\t}\n\tvoid *u = core->anal->esil->user;\n\tcore->anal->esil->user = core;\n\tvoid *p = core->anal->esil->cb.hook_reg_write;\n\tcore->anal->esil->cb.hook_reg_write = regwrite_hook;\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal,\n\t\t\taddr, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\tconst char *pcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tconst ut64 old_pc = r_reg_getv (core->anal->reg, pcname);\n\tif (fcn) {\n\t\tbool anal_verbose = r_config_get_b (core->config, \"anal.verbose\");\n\t\t// emulate every instruction in the function recursively across all the basic blocks\n\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\tut64 pc = bb->addr;\n\t\t\tut64 end = bb->addr + bb->size;\n\t\t\tRAnalOp op;\n\t\t\tint ret, bbs = end - pc;\n\t\t\tif (bbs < 1 || bbs > 0xfffff || pc >= end) {\n\t\t\t\tR_LOG_ERROR (\"Invalid block size\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// eprintf (\"[*] Emulating 0x%08\"PFMT64x\" basic block 0x%08\" PFMT64x \" - 0x%08\" PFMT64x \"\\r[\", fcn->addr, pc, end);\n\t\t\tut8 *buf = calloc (1, bbs + 1);\n\t\t\tif (!buf) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// const char *pcname = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);\n\t\t\tr_io_read_at (core->io, pc, buf, bbs);\n\t\t\tint left;\n\t\t\twhile (pc < end) {\n\t\t\t\tleft = R_MIN (end - pc, 32);\n\t\t\t\t// r_asm_set_pc (core->rasm, pc);\n\t\t\t\tret = r_anal_op (core->anal, &op, pc, buf + pc - bb->addr, left, R_ARCH_OP_MASK_HINT | R_ARCH_OP_MASK_ESIL| R_ARCH_OP_MASK_DISASM); // read overflow\n\t\t\t\tif (ret) {\n\t\t\t\t\tbool opskip = false;\n#if 0\n\t\t\t\t\tswitch (op.type) {\n\t\t\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\t\t\t\topskip = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (!opskip) {\n\t\t\t\t\t\tconst char *esilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\t\t\t\t\t// eprintf (\"0x%08\"PFMT64x\"  %s\\n\", pc, op.mnemonic);\n\t\t\t\t\t\tif (R_STR_ISNOTEMPTY (esilstr)) {\n\t\t\t\t\t\t\tr_reg_setv (core->anal->reg, pcname, pc + op.size);\n\t\t\t\t\t\t\tr_esil_set_pc (core->anal->esil, pc);\n\t\t\t\t\t\t\tr_esil_parse (core->anal->esil, esilstr);\n\t\t\t\t\t\t\tif (anal_verbose) {\n\t\t\t\t\t\t\t\tr_esil_dumpstack (core->anal->esil);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr_esil_stack_free (core->anal->esil);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpc += op.size;\n\t\t\t\t} else {\n\t\t\t\t\tpc += 4; // XXX\n\t\t\t\t}\n\t\t\t\tr_anal_op_fini (&op);\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot find function at 0x%08\" PFMT64x, addr);\n\t}\n\tcore->anal->esil->cb.hook_reg_write = p;\n\tcore->anal->esil->user = u;\n\tr_reg_setv (core->anal->reg, pcname, old_pc);\n}\n\nstatic char *_aeg_get_title(void *data) {\n\tRAnalEsilDFGNode *enode = (RAnalEsilDFGNode *)data;\n\treturn r_str_newf (\"%d\", enode->idx);\n}\n\nstatic char *_aeg_get_body(void *data) {\n\tRAnalEsilDFGNode *enode = (RAnalEsilDFGNode *)data;\n\treturn r_str_newf (\"%s%s\",\n\t\t(enode->type & R_ANAL_ESIL_DFG_TAG_GENERATIVE)? \"generative:\": \"\",\n\t\tr_strbuf_get (enode->content));\n}\n\nstatic void cmd_aeg(RCore *core, int argc, char *argv[]) {\n\tr_return_if_fail (core && argc >= 0 && argv);\n\tRAGraphTransitionCBs cbs = {\n\t\t.get_title = _aeg_get_title,\n\t\t.get_body = _aeg_get_body\n\t};\n\tswitch (argv[0][1]) {\n\tcase '\\x00': // \"aeg\"\n\t\tif (argc == 1) {\n\t\t\tRAnalOp *aop = r_core_anal_op (core, core->offset, R_ARCH_OP_MASK_ESIL);\n\t\t\tif (!aop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst char *esilstr = r_strbuf_get (&aop->esil);\n\t\t\tif (R_STR_ISNOTEMPTY (esilstr)) {\n\t\t\t\tRAnalEsilDFG *dfg = r_anal_esil_dfg_expr (core->anal, NULL, esilstr,\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.mapinfo\"),\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.maps\"));\n\t\t\t\tif (!dfg) {\n\t\t\t\t\tr_anal_op_free (aop);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tRAGraph *agraph = r_agraph_new_from_graph (dfg->flow, &cbs);\n\t\t\t\tr_anal_esil_dfg_free (dfg);\n\t\t\t\tagraph->can->linemode = r_config_get_i (core->config, \"graph.linemode\");\n\t\t\t\tagraph->layout = r_config_get_i (core->config, \"graph.layout\");\n\t\t\t\tr_agraph_print (agraph);\n\t\t\t\tr_agraph_free (agraph);\n\t\t\t}\n\t\t\tr_anal_op_free (aop);\n\t\t} else {\n\t\t\tRStrBuf *sb = r_strbuf_new (\"\");\n\t\t\tint i;\n\t\t\tfor (i = 1; i < argc; i++) {\n\t\t\t\tif (r_strbuf_length (sb) > 0) {\n\t\t\t\t\tr_strbuf_append (sb, \",\");\n\t\t\t\t}\n\t\t\t\tr_strbuf_append (sb, argv[i]);\n\t\t\t}\n\t\t\tchar *esilexpr = r_strbuf_drain (sb);\n\t\t\tRAnalEsilDFG *dfg = r_anal_esil_dfg_expr (core->anal, NULL, esilexpr,\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.mapinfo\"),\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.maps\"));\n\t\t\tif (dfg) {\n\t\t\t\tRAGraph *agraph = r_agraph_new_from_graph (dfg->flow, &cbs);\n\t\t\t\tr_anal_esil_dfg_free (dfg);\n\t\t\t\tagraph->can->linemode = r_config_get_i (core->config, \"graph.linemode\");\n\t\t\t\tagraph->layout = r_config_get_i (core->config, \"graph.layout\");\n\t\t\t\tr_agraph_print (agraph);\n\t\t\t\tr_agraph_free (agraph);\n\t\t\t}\n\t\t\tfree (esilexpr);\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"aegb\"\n\t\tr_core_cmd0 (core, \"aeg `pieq $Fi`\");\n\t\tbreak;\n\tcase 'n': // \"aegn\"\n\t\tif (argc > 1) {\n\t\t\tint n = r_num_math (core->num, argv[1]);\n\t\t\tr_core_cmdf (core, \"aeg `pieq %d`\", n);\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Usage: aegn [number-of-instructions-to-combine-its-esil-essence]\");\n\t\t}\n\t\tbreak;\n\tcase 'v': // \"aegv\" - visual\n\t{\n\t\tRAGraph *agraph = NULL;\n\t\tif (argc == 1) {\n\t\t\tRAnalOp *aop = r_core_anal_op (core, core->offset, R_ARCH_OP_MASK_ESIL);\n\t\t\tif (!aop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst char *esilstr = r_strbuf_get (&aop->esil);\n\t\t\tif (R_STR_ISNOTEMPTY (esilstr)) {\n\t\t\t\tRAnalEsilDFG *dfg = r_anal_esil_dfg_expr (core->anal, NULL, esilstr,\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.mapinfo\"),\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.maps\"));\n\t\t\t\tif (!dfg) {\n\t\t\t\t\tr_anal_op_free (aop);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tagraph = r_agraph_new_from_graph (dfg->flow, &cbs);\n\t\t\t\tr_anal_esil_dfg_free (dfg);\n\t\t\t}\n\t\t\tr_anal_op_free (aop);\n\t\t} else {\n\t\t\tRAnalEsilDFG *dfg = r_anal_esil_dfg_expr (core->anal, NULL, argv[1],\n\t\t\t\tr_config_get_b (core->config, \"esil.dfg.mapinfo\"),\n\t\t\t\tr_config_get_b (core->config, \"esil.dfg.maps\"));\n\t\t\tr_return_if_fail (dfg);\n\t\t\tagraph = r_agraph_new_from_graph (dfg->flow, &cbs);\n\t\t\tr_anal_esil_dfg_free (dfg);\n\t\t}\n\t\tconst ut64 osc = r_config_get_i (core->config, \"scr.color\");\n\t\tr_config_set_i (core->config, \"scr.color\", 0);\n\t\tut64 oseek = core->offset;\n\t\tif (agraph) {\n\t\t\tagraph->need_update_dim = true;\n\t\t\t// layout\n\t\t\tagraph->layout = r_config_get_i (core->config, \"graph.layout\");\n\t\t\tagraph->need_set_layout = true;\n\t\t\tint update_seek = r_core_visual_graph (core, agraph, NULL, true);\n\t\t\tr_cons_show_cursor (true);\n\t\t\tr_cons_enable_mouse (false);\n\t\t\tif (update_seek != -1) {\n\t\t\t\tr_core_seek (core, oseek, false);\n\t\t\t}\n\t\t\tr_agraph_free (agraph);\n\t\t}\n\t\tr_config_set_i (core->config, \"scr.color\", osc);\n\t}\n\t\tbreak;\n\tcase 'f':\t// \"aegf\"\n\t{\n\t\tRStrBuf *filtered = r_anal_esil_dfg_filter_expr (core->anal, argv[1], argv[2],\n\t\t\tr_config_get_b (core->config, \"esil.dfg.mapinfo\"),\n\t\t\tr_config_get_b (core->config, \"esil.dfg.maps\"));\n\t\tif (filtered) {\n\t\t\tr_cons_printf (\"%s\\n\", r_strbuf_get (filtered));\n\t\t\tr_strbuf_free (filtered);\n\t\t}\n\t}\n\t\tbreak;\n#if 0\n\tcase 'c':\t// \"aegc\"\n\t{\n\t\tRAnalEsilDFG *dfg = r_anal_esil_dfg_expr (core->anal, NULL, argv[1]);\n\t\tif (!dfg) {\n\t\t\treturn;\n\t\t}\n\t\tr_anal_esil_dfg_fold_const (core->anal, dfg);\n\t\tif (argv[0][1] == 'f') {\t// \"aegcf\"\n\t\t\tRStrBuf *filtered = r_anal_esil_dfg_filter (dfg, argv[2]);\n\t\t\tif (filtered) {\n\t\t\t\tr_cons_printf (\"%s\\n\", r_strbuf_get (filtered));\n\t\t\t\tr_strbuf_free (filtered);\n\t\t\t}\n\t\t} else {\n\t\t\tprint_esil_dfg_as_commands (core, dfg);\n\t\t}\n\t\tr_anal_esil_dfg_free (dfg);\n\t}\n\t\tbreak;\n#endif\n\tcase '?': // \"aeg?\"\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_aeg);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_esil(RCore *core, const char *input, bool verbose) {\n\tREsil *esil = core->anal->esil;\n\tut64 addr = core->offset;\n\tut64 adr ;\n\tchar *n, *n1;\n\tint off;\n\tut64 until_addr = UT64_MAX;\n\n\tconst char *until_expr = NULL;\n\tRAnalOp *op = NULL;\n\n\tswitch (input[0]) {\n\tcase 'v': // \"aev\"\n\t\tr_core_visual_esil (core, r_str_trim_head_ro (input + 1));\n\t\tbreak;\n\tcase 'p': // \"aep\"\n\t\tswitch (input[1]) {\n\t\tcase 'a': // \"aepa\"\n\t\t\t{\n\t\t\t\tut64 at = core->offset;\n\t\t\t\tif (input[2] == ' ') {\n\t\t\t\t\tat = r_num_math (core->num, input + 2);\n\t\t\t\t}\n\t\t\t\t// get flag in current offset\n\t\t\t\t// find a pin named like the flag, skip dots if any\n\t\t\t\tRFlagItem *f = r_flag_get_by_spaces (core->flags, at, R_FLAGS_FS_SYMBOLS, R_FLAGS_FS_IMPORTS, NULL);\n\t\t\t\tif (!f) {\n\t\t\t\t\tf = r_flag_get_i (core->flags, at);\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tconst char *last = r_str_rchr (f->name, NULL, '.');\n\t\t\t\t\tconst char *pin_name = last? last + 1: f->name;\n\t\t\t\t\tconst char *havepin = r_anal_pin_get (core->anal, pin_name);\n\t\t\t\t\tif (havepin) {\n\t\t\t\t\t\tr_core_cmdf (core, \"aep %s @ 0x%08\" PFMT64x, pin_name, at);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '.': // \"aep.\"\n\t\t\t{\n\t\t\tconst char *n = r_anal_pin_at (core->anal, core->offset);\n\t\t\tif (R_STR_ISNOTEMPTY (n)) {\n\t\t\t\tr_cons_printf (\"%s\\n\", n);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c': // \"aepc\"\n\t\t\tif (input[2] == ' ' || input[2] == '=') {\n\t\t\t\t// seek to this address\n\t\t\t\treg_name_roll_set (core, \"PC\", r_num_math (core->num, input + 3));\n\t\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\t} else {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_aep, \"aepc\", true);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\t{\n\t\t\t\tchar *out = sdb_querys (core->anal->sdb_pins, NULL, 0, r_str_trim_head_ro (input + 3));\n\t\t\t\tif (out) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", out);\n\t\t\t\t\tfree (out);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '*':\n\t\tcase 0:\n\t\t\tr_anal_pin_list (core->anal);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tif (input[2] == '*') {\n\t\t\t\tr_anal_pin_init (core->anal);\n\t\t\t} else {\n\t\t\t\tif (input[2]) {\n\t\t\t\t\taddr = r_num_math (core->num, input + 2);\n\t\t\t\t}\n\t\t\t\tr_anal_pin_unset (core->anal, addr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tr_anal_pin (core->anal, addr, input + 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_aep);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"aer\"\n\t\t// 'aer' is an alias for 'ar'\n\t\tcmd_anal_reg (core, input + 1);\n\t\tbreak;\n\tcase '*': // \"aeq\"\n\t\t// XXX: this is wip, not working atm\n\t\tr_cons_printf (\"trap: %d\\n\", core->anal->esil->trap);\n\t\tr_cons_printf (\"trap-code: %d\\n\", core->anal->esil->trap_code);\n\t\tbreak;\n\tcase ' ':\n\tcase 'q': // \"aeq\"\n\t\tr_esil_set_pc (esil, core->offset);\n\t\tr_esil_parse (esil, r_str_trim_head_ro (input + 1));\n\t\tif (verbose && *input != 'q') {\n\t\t\tr_esil_dumpstack (esil);\n\t\t}\n\t\tr_esil_stack_free (esil);\n\t\tbreak;\n\tcase 's': // \"aes\" \"aeso\" \"aesu\" \"aesue\"\n#if 0\n\t\tr_core_cmd0 (core, \"ae `aoe@r:PC`\");\n\t\tr_core_cmd0 (core, \".ar*\");\n\t\tbreak;\n#endif\n\t\t// aes -> single step\n\t\t// aesb -> single step back\n\t\t// aeso -> single step over\n\t\t// aesu -> until address\n\t\t// aesue -> until esil expression\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_aes);\n\t\t\tbreak;\n\t\tcase 'l': // \"aesl\"\n\t\t{\n\t\t\tut64 pc = r_debug_reg_get (core->dbg, \"PC\");\n\t\t\tRAnalOp *op = r_core_anal_op (core, pc, R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT);\n\t\t\tif (!op) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_core_esil_step (core, UT64_MAX, NULL, NULL, false);\n\t\t\tr_debug_reg_set (core->dbg, \"PC\", pc + op->size);\n\t\t\tr_esil_set_pc (esil, pc + op->size);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tr_anal_op_free (op);\n\t\t} break;\n\t\tcase 'b': // \"aesb\"\n\t\t\tif (!r_core_esil_step_back (core)) {\n\t\t\t\tR_LOG_ERROR (\"Cannot step back\");\n\t\t\t}\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\tcase 'B': // \"aesB\"\n\t\t\tn = strchr (input + 2, ' ');\n\t\t\tif (n) {\n\t\t\t\tn = (char *)r_str_trim_head_ro (n + 1);\n\t\t\t}\n\t\t\tif (n) {\n\t\t\t\tchar *n2 = strchr (n, ' ');\n\t\t\t\tif (n2) {\n\t\t\t\t\t*n2++ = 0;\n\t\t\t\t}\n\t\t\t\tut64 off = r_num_math (core->num, n);\n\t\t\t\tut64 nth = n2? r_num_math (core->num, n2): 1;\n\t\t\t\tcmd_aespc (core, core->offset, off, (int)nth);\n\t\t\t} else {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_aes, \"aesB\", true);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u': // \"aesu\"\n\t\t\tuntil_expr = NULL;\n\t\t\tuntil_addr = UT64_MAX;\n\t\t\tif (r_str_endswith (input, \"?\")) {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_aes, \"aesu\", true);\n\t\t\t} else switch (input[2]) {\n\t\t\tcase 'e': // \"aesue\"\n\t\t\t\tuntil_expr = r_str_trim_head_ro (input + 3);\n\t\t\t\tbreak;\n\t\t\tcase ' ': // \"aesu\"\n\t\t\t\tuntil_addr = r_num_math (core->num, input + 2);\n\t\t\t\tbreak;\n\t\t\tcase 'o': // \"aesuo\"\n\t\t\t\tstep_until_optype (core, r_str_trim_head_ro (input + 3));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr_core_cmd0 (core, \"aes?~aesu\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (until_expr || until_addr != UT64_MAX) {\n\t\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL, false);\n\t\t\t}\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\tcase 's': // \"aess\"\n\t\t\tif (input[2] == 'u') { // \"aessu\"\n\t\t\t\tif (input[3] == 'e') {\n\t\t\t\t\tuntil_expr = input + 3;\n\t\t\t\t} else {\n\t\t\t\t\tuntil_addr = r_num_math (core->num, input + 2);\n\t\t\t\t}\n\t\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL, true);\n\t\t\t} else {\n\t\t\t\tr_core_esil_step (core, UT64_MAX, NULL, NULL, true);\n\t\t\t}\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\tcase 'o': // \"aeso\"\n\t\t\tif (input[2] == 'u') { // \"aesou\"\n\t\t\t\tif (input[3] == 'e') {\n\t\t\t\t\tuntil_expr = input + 3;\n\t\t\t\t} else {\n\t\t\t\t\tuntil_addr = r_num_math (core->num, input + 2);\n\t\t\t\t}\n\t\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL, true);\n\t\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\t} else if (!input[2] || input[2] == ' ') { // \"aeso [addr]\"\n\t\t\t\t// step over\n\t\t\t\top = r_core_anal_op (core, r_reg_getv (core->anal->reg,\n\t\t\t\t\tr_reg_get_name (core->anal->reg, R_REG_NAME_PC)), R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT);\n\t\t\t\tif (op && op->type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\t\tuntil_addr = op->addr + op->size;\n\t\t\t\t}\n\t\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL, false);\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\t} else {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_aes, \"aesou\", true);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p': //\"aesp\"\n\t\t\tn = strchr (input, ' ');\n\t\t\tn1 = R_STR_ISNOTEMPTY (n) ? strchr (n + 1, ' ') : NULL;\n\t\t\tif ((!n || !n1) || (!*n || !*n1)) {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_aes, \"aesp\", true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadr = R_STR_ISNOTEMPTY (n)? r_num_math (core->num, n + 1): 0;\n\t\t\toff = R_STR_ISNOTEMPTY (n1)? r_num_math (core->num, n1 + 1): 0;\n\t\t\tcmd_aespc (core, adr, -1, off);\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tn = strchr (input, ' ');\n\t\t\tn1 = n ? n + 1: NULL;\n\t\t\tif (!n1 || !*n1) {\n\t\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toff = r_num_math (core->num, n1);\n\t\t\tcmd_aespc (core, -1, -1, off);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL, false);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'C': // \"aeC\"\n\t\tif (input[1] == '?') { // \"aec?\"\n\t\t\tr_core_cmd_help (core, help_msg_aeC);\n\t\t} else {\n\t\t\t__core_anal_appcall (core, r_str_trim_head_ro (input + 1));\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"aec\"\n\t\tif (input[1] == '?') { // \"aec?\"\n\t\t\tr_core_cmd_help (core, help_msg_aec);\n\t\t} else if (input[1] == 's') { // \"aecs\"\n\t\t\tst64 maxsteps = r_config_get_i (core->config, \"esil.maxsteps\");\n\t\t\tut64 countsteps = 0;\n\t\t\tconst char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\t\t\tfor (; !maxsteps || countsteps < maxsteps; countsteps++) {\n\t\t\t\t// ignore return value is not an error, should 0, 1, -1 imho\n\t\t\t\t(void)r_core_esil_step (core, UT64_MAX, NULL, NULL, false);\n\t\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\t\taddr = r_reg_getv (core->anal->reg, pc);\n\t\t\t\top = r_core_anal_op (core, addr, R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT);\n\t\t\t\tif (!op) {\n\t\t\t\t\tR_LOG_ERROR (\"invalid instruction at 0x%08\" PFMT64x, addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op->type == R_ANAL_OP_TYPE_SWI) {\n\t\t\t\t\tR_LOG_INFO (\"syscall instruction at 0x%08\" PFMT64x, addr);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (op->type == R_ANAL_OP_TYPE_TRAP) {\n\t\t\t\t\tR_LOG_INFO (\"trap instruction at 0x%08\" PFMT64x, addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\top = NULL;\n\t\t\t\tif (core->anal->esil->trap || core->anal->esil->trap_code) {\n\t\t\t\t\tR_LOG_INFO (\"esil trap '%s' (%d) at 0x%08\" PFMT64x,\n\t\t\t\t\t\t\tr_esil_trapstr (core->anal->esil->trap),\n\t\t\t\t\t\t\tcore->anal->esil->trap_code, addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\top = NULL;\n\t\t\t}\n\t\t} else if (input[1] == 'c') { // \"aecc\"\n\t\t\tconst char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\t\t\tst64 maxsteps = r_config_get_i (core->config, \"esil.maxsteps\");\n\t\t\tut64 countsteps = 0;\n\t\t\tfor (; !maxsteps || countsteps < maxsteps; countsteps++) {\n\t\t\t\t(void)r_core_esil_step (core, UT64_MAX, NULL, NULL, false);\n\t\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\t\taddr = r_num_get (core->num, pc);\n\t\t\t\top = r_core_anal_op (core, addr, R_ARCH_OP_MASK_BASIC);\n\t\t\t\tif (!op) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op->type == R_ANAL_OP_TYPE_CALL || op->type == R_ANAL_OP_TYPE_UCALL) {\n\t\t\t\t\tR_LOG_INFO (\"stop in call instruction at 0x%08\" PFMT64x, addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\top = NULL;\n\t\t\t\tif (core->anal->esil->trap || core->anal->esil->trap_code) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t}\n\t\t} else {\n\t\t\t// \"aec\"  -> continue until ^C\n\t\t\t// \"aecu\" -> until address\n\t\t\t// \"aecue\" -> until esil expression\n\t\t\tif (input[1] == 'u' && input[2] == 'e') {\n\t\t\t\tuntil_expr = input + 3;\n\t\t\t} else if (input[1] == 'u') {\n\t\t\t\tuntil_addr = r_num_math (core->num, input + 2);\n\t\t\t} else {\n\t\t\t\tuntil_expr = \"0\";\n\t\t\t}\n\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL, false);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"aei\"\n\t\tswitch (input[1]) {\n\t\tcase 's': // \"aeis\"\n\t\t\t{\n\t\t\t\tchar *arg = r_str_trim_dup (input + 2);\n\t\t\t\tRList *args = r_str_split_list (arg, \" \", 0);\n\t\t\t\tint i, argc = atoi (r_list_pop_head (args));\n\t\t\t\tif (argc < 1) {\n\t\t\t\t\tr_core_cmd_help (core, help_msg_aei);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar **argv = calloc (argc + 1, sizeof (void *));\n\t\t\t\tfor (i = 0; i < argc; i++) {\n\t\t\t\t\tchar *arg = r_list_pop_head (args);\n\t\t\t\t\tif (!arg) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\targv[i] = arg;\n\t\t\t\t}\n\t\t\t\targv[i] = 0;\n\t\t\t\tchar **envp = calloc (r_list_length (args) + 1, sizeof (void *));\n\t\t\t\tfor (i = 0; ; i++) {\n\t\t\t\t\tchar *arg = r_list_pop_head (args);\n\t\t\t\t\tif (!arg) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tenvp[i] = arg;\n\t\t\t\t}\n\t\t\t\tenvp[i] = 0;\n#if R2__UNIX__\n\t\t\t\tif (strstr (input, \"$env\")) {\n\t\t\t\t\textern char **environ;\n\t\t\t\t\tcmd_debug_stack_init (core, argc, argv, environ);\n\t\t\t\t} else {\n\t\t\t\t\tcmd_debug_stack_init (core, argc, argv, envp);\n\t\t\t\t}\n#else\n\t\t\t\tcmd_debug_stack_init (core, argc, argv, envp);\n#endif\n\t\t\t\tfree (arg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'm': // \"aeim\"\n\t\t\tcmd_esil_mem (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'p': // \"aeip\" // initialize pc = $$\n\t\t\treg_name_roll_set (core, \"PC\", core->offset);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_aei);\n\t\t\tcmd_esil_mem (core, \"?\");\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tr_esil_reset (esil);\n\t\t\tbreak;\n\t\tcase 0: // \"aei\"\n\t\t\tesil = esil_new_setup (core);\n\t\t\tif (esil) {\n\t\t\t\tr_esil_free (core->anal->esil);\n\t\t\t\tcore->anal->esil = esil;\n\t\t\t\tr_esil_reset (esil);\n\t\t\t\tconst char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\t\t\t\tif (pc && r_reg_getv (core->anal->reg, pc) == 0LL) {\n\t\t\t\t\treg_name_roll_set (core, \"PC\", core->offset);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* restore user settings for interrupt handling */\n\t\t\t{\n\t\t\t\tconst char *s = r_config_get (core->config, \"cmd.esil.intr\");\n\t\t\t\tif (s) {\n\t\t\t\t\tchar *my = strdup (s);\n\t\t\t\t\tif (my) {\n\t\t\t\t\t\tr_config_set (core->config, \"cmd.esil.intr\", my);\n\t\t\t\t\t\tfree (my);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcmd_esil_mem (core, \"?\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'k': // \"aek\"\n\t\tswitch (input[1]) {\n\t\tcase '\\0':\n\t\t\tinput = \"*\";\n\t\t\t/* fall through */\n\t\tcase ' ':\n\t\t\tif (esil && esil->stats) {\n\t\t\t\tchar *out = sdb_querys (esil->stats, NULL, 0, input + 2);\n\t\t\t\tif (out) {\n\t\t\t\t\tr_cons_println (out);\n\t\t\t\t\tfree (out);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_INFO (\"esil.stats is empty. Run 'aei'\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tif (esil) {\n\t\t\t\tsdb_reset (esil->stats);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_aek);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'L': // \"aeL\" esil plugins\n\t\tif (input[1] == ' ') { // \"aeL\"\n\t\t\tconst char *name = r_str_trim_head_ro (input + 2);\n\t\t\tr_esil_plugin_activate (core->anal->esil, name);\n\t\t} else if (input[1] == '-') { // \"aeL-\"\n\t\t\tconst char *name = r_str_trim_head_ro (input + 2);\n\t\t\tr_esil_plugin_deactivate (core->anal->esil, name);\n\t\t} else {\n\t\t\tREsilPlugin *p;\n\t\t\tRListIter *iter;\n\t\t\tif (core->anal->esil) {\n\t\t\t\tr_list_foreach (core->anal->esil->plugins, iter, p) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", p->name);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_WARN (\"Run 'aei'\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'g': // \"aeg\"\n\t\t{\n\t\t\tint argc;\n\t\t\tchar **argv = r_str_argv (input, &argc);\n\t\t\tr_return_if_fail (argv);\n\t\t\tcmd_aeg (core, argc, argv);\n\t\t\tint i;\n\t\t\tfor (i = 0; i < argc; i++) {\n\t\t\t\tfree (argv[i]);\n\t\t\t}\n\t\t\tfree (argv);\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"aeb\"\n\t\t{\n\t\t\tut64 addr = r_num_math (core->num, input + 1);\n\t\t\tif (!addr || addr == UT64_MAX) {\n\t\t\t\taddr = core->offset;\n\t\t\t}\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t\t\tif (fcn) {\n\t\t\t\tRAnalBlock *bb = r_anal_function_bbget_in (core->anal, fcn, addr);\n\t\t\t\tif (bb) {\n\t\t\t\t\tcmd_aespc (core, bb->addr, bb->addr + bb->size, bb->ninstr);\n\t\t\t\t\t// r_core_cmdf (core, \"aesp `ab~addr[1]` `ab~ninstr[1]`\");\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"No basic block in this address\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"No function in this address\");\n\t\t\t}\n\t\t// ab~ninstr[1]\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"aef\"\n\t\tif (input[1] == 'a') { // \"aefa\"\n\t\t\tr_anal_aefa (core, r_str_trim_head_ro (input + 2));\n\t\t} else { // This should be aefb -> because its emulating all the bbs\n\t\t\t// anal ESIL to REIL.\n\t\t\t__anal_esil_function (core, core->offset);\n\t\t} break;\n\tcase 't': // \"aet\"\n\t\tswitch (input[1]) {\n\t\tcase 's': // \"aets\"\n\t\t\tswitch (input[2]) {\n\t\t\tcase '+': // \"aets+\"\n#if 0\n\t\t\t\tif (!esil) {\n\t\t\t\t\tR_LOG_ERROR (\"ESIL is not initialized. Use `aeim` first\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t\tif (esil->trace) {\n\t\t\t\t\tR_LOG_INFO (\"ESIL trace already started\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tesil->trace = r_esil_trace_new (esil);\n\t\t\t\tif (!esil->trace) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_config_set_b (core->config, \"dbg.trace\", true);\n\t\t\t\tbreak;\n\t\t\tcase '-': // \"aets-\"\n\t\t\t\tif (!esil) {\n\t\t\t\t\tR_LOG_ERROR (\"ESIL is not initialized. Use `aeim` first\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!esil->trace) {\n\t\t\t\t\tR_LOG_ERROR (\"No ESIL trace started\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_esil_trace_free (esil->trace);\n\t\t\t\tesil->trace = NULL;\n\t\t\t\tr_config_set_b (core->config, \"dbg.trace\", false);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr_core_cmd_help (core, help_msg_aets);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0: // \"aet\"\n\t\t\tr_esil_trace_list (core->anal->esil);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_ERROR (\"Unknown command\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'A': // \"aeA\"\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_aea);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tcmd_aea (core, 1 + (1<<1), core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tcmd_aea (core, 1 + (1<<2), core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tcmd_aea (core, 1 + (1<<3), core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tcmd_aea (core, 1 + (1<<4), core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tcmd_aea (core, 1 + (1<<5), core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'f': {\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\t\tif (fcn) {\n\t\t\t\tcmd_aea (core, 1, r_anal_function_min_addr (fcn), r_anal_function_linear_size (fcn));\n\t\t\t}\n\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tcmd_aea (core, 1, core->offset, (int)r_num_math (core->num, input[1]? input + 2:input + 1));\n\t\t}\n\t\tbreak;\n\tcase 'a': { // \"aea\"\n\t\tRReg *reg = core->anal->reg;\n\t\tut64 pc = r_reg_getv (reg, \"PC\");\n\t\tRAnalOp *op = r_core_anal_op (core, pc, 0);\n\t\tif (!op) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 newPC = core->offset + op->size;\n\t\tr_reg_setv (reg, \"PC\", newPC);\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_aea);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tcmd_aea (core, 1<<1, core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tcmd_aea (core, 1<<2, core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tcmd_aea (core, 1<<3, core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tcmd_aea (core, 1<<4, core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tcmd_aea (core, 1<<5, core->offset, r_num_math (core->num, input+2));\n\t\t\tbreak;\n\t\tcase 'B': { // \"aeaB\"\n\t\t\tbool json = input[2] == 'j';\n\t\t\tint a = json? 3: 2;\n\t\t\tut64 addr = (input[a] == ' ')? r_num_math (core->num, input + a): core->offset;\n\t\t\tRList *l = r_anal_get_blocks_in (core->anal, addr);\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (l, iter, b) {\n\t\t\t\tint mode = json? (1<<4): 1;\n\t\t\t\tcmd_aea (core, mode, b->addr, b->size);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'f': { // \"aeaf\"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\t\tif (fcn) {\n\t\t\t\tswitch (input[2]) {\n\t\t\t\tcase 'j': // \"aeafj\"\n\t\t\t\t\tcmd_aea (core, 1<<4, r_anal_function_min_addr (fcn), r_anal_function_linear_size (fcn));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcmd_aea (core, 1, r_anal_function_min_addr (fcn), r_anal_function_linear_size (fcn));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase 'b': { // \"aeab\"\n\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n\t\t\tif (bb) {\n\t\t\t\tswitch (input[2]) {\n\t\t\t\tcase 'j': // \"aeabj\"\n\t\t\t\t\tcmd_aea (core, 1 | (1<<4), bb->addr, bb->size);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcmd_aea (core, 1, bb->addr, bb->size);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault: {\n\t\t\tconst char *arg = input[1]? input + 2: \"\";\n\t\t\tut64 len = r_num_math (core->num, arg);\n\t\t\tcmd_aea (core, 0, core->offset, len);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tr_reg_setv (reg, \"PC\", pc);\n\t\tbreak;\n\t\t  }\n\tcase 'x':\n\t\tif (input[1] == ' ') { // \"aex\"\n\t\t\tchar *hex;\n\t\t\tint ret, bufsz;\n\n\t\t\tinput = r_str_trim_head_ro (input + 1);\n\t\t\thex = strdup (input);\n\t\t\tif (!hex) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tRAnalOp aop = {0};\n\t\t\tbufsz = r_hex_str2bin (hex, (ut8*)hex);\n\t\t\tret = r_anal_op (core->anal, &aop, core->offset,\n\t\t\t\t(const ut8*)hex, bufsz, R_ARCH_OP_MASK_ESIL);\n\t\t\tif (ret > 0) {\n\t\t\t\tconst char *str = R_STRBUF_SAFEGET (&aop.esil);\n\t\t\t\tchar *str2 = r_str_newf (\" %s\", str);\n\t\t\t\tcmd_anal_esil (core, str2, false);\n\t\t\t\tfree (str2);\n\t\t\t\tr_core_return_value (core, 1);\n\t\t\t} else {\n\t\t\t\t// fail to exevute, update code\n\t\t\t\tr_core_return_value (core, 0);\n\t\t\t}\n\t\t\tr_anal_op_fini (&aop);\n\t\t\tfree (hex);\n\t\t} else if (input[1] == 'a') { // \"aexa\"\n\t\t\tchar *bytes = r_core_cmd_strf (core, \"\\\"pa %s\\\"\", r_str_trim_head_ro (input + 2));\n\t\t\tif (R_STR_ISNOTEMPTY (bytes)) {\n\t\t\t\tr_core_cmdf (core, \"aex %s\", bytes);\n\t\t\t}\n\t\t\tfree (bytes);\n\t\t} else { // \"aex?\"\n\t\t\tr_core_cmd_help (core, help_msg_aex);\n\t\t}\n\t\tbreak;\n\tcase '?': // \"ae?\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_detail_ae);\n\t\t\tbreak;\n\t\t}\n\t\t/* fallthrough */\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ae);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_bytes(RCore *core, const char *input) {\n\tint len = core->blocksize;\n\tif (input[0]) {\n\t\tlen = (int)r_num_get (core->num, input + 1);\n\t}\n\tif (len < 1) {\n\t\treturn;\n\t}\n\tut8 *buf = calloc (len, 1);\n\tif (buf) {\n\t\tr_io_read_at (core->io, core->offset, buf, len);\n\t\tcore_anal_bytes (core, buf, len, 0, input[0]);\n\t\tfree (buf);\n\t}\n}\n\nstatic int compare_mnemonics(const char *a , const char *b) {\n\tif (!a || !b) {\n\t\treturn 0;\n\t}\n\tchar *sa = strdup (a);\n\tchar *sb = strdup (b);\n\tr_str_replace_ch (sa, ' ', ',', 0);\n\tr_str_replace_ch (sb, ' ', ',', 0);\n\tRList *la = r_str_split_list (sa, \",\", 0);\n\tRList *lb = r_str_split_list (sb, \",\", 0);\n\tint i = 0;\n\tfor (i = 0; i < 10; i++) {\n\t\tchar *wa = r_list_get_n (la, i);\n\t\tchar *wb = r_list_get_n (lb, i);\n\t\tif (!wa || !wb) {\n\t\t\ti = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp (wa, wb)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_list_free (la);\n\tr_list_free (lb);\n\tfree (sa);\n\tfree (sb);\n\treturn i;\n}\n\nstatic int intsort(const void *a, const void *b) {\n\tif (a > b) {\n\t\treturn 1;\n\t}\n\tif (a == b) {\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic void cmd_anal_opcode_bits(RCore *core, const char *arg, int mode) {\n\tut8 buf[32] = {0};\n\tif (R_STR_ISNOTEMPTY (arg)) {\n\t\tchar *choparg = r_str_ndup (arg, 8);\n\t\tint res = r_hex_str2bin (choparg, (ut8 *)buf);\n\t\tfree (choparg);\n\t\tif (res < 1) {\n\t\t\tR_LOG_ERROR (\"Invalid hex string\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tr_io_read_at (core->io, core->offset, buf, sizeof (buf));\n\t}\n\tRList *args[8];\n\tint i, j;\n\tRAnalOp analop, op;\n\tr_anal_op_init (&analop);\n\tr_anal_op_set_bytes (&analop, core->offset, buf, sizeof (ut64));\n\t(void)r_anal_op (core->anal, &analop, core->offset, buf, sizeof (buf), R_ARCH_OP_MASK_DISASM);\n\tint last = R_MIN (8, analop.size);\n\tPJ *pj = (mode == 'j')? r_core_pj_new (core): NULL;\n\tif (last < 1) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\targs[i] = r_list_new ();\n\t}\n\n\tif (pj) {\n\t\tpj_o (pj);\n\t\tpj_ks (pj, \"opstr\", analop.mnemonic);\n\t\tpj_kn (pj, \"size\", analop.size);\n\t\tpj_ko (pj, \"bytes\");\n\t}\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tfor (i = 0; i < last; i++) {\n\t\tut8 *byte = buf + i;\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t}\n\t\tif (i == 4) {\n\t\t\tr_strbuf_append (sb, \"| \");\n\t\t}\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tbool bit = R_BIT_CHK (byte, 7 - j);\n\t\t\tr_anal_op_init (&op);\n\t\t\tut8 newbuf[sizeof (ut64)] = {0};\n\t\t\tmemcpy (&newbuf, &buf, sizeof (ut64));\n\t\t\tut8 *newbyte = newbuf + i;\n\t\t\tif (bit) {\n\t\t\t\tnewbuf[i] = R_BIT_UNSET (newbyte, 7 - j);\n\t\t\t} else {\n\t\t\t\tnewbuf[i] = R_BIT_SET (newbyte, 7 - j);\n\t\t\t}\n\t\t\tr_anal_op_set_bytes (&op, core->offset, newbuf, sizeof (newbuf));\n\t\t\t(void)r_anal_op (core->anal, &op, core->offset, newbuf, sizeof (ut64), R_ARCH_OP_MASK_DISASM);\n\t\t\t// r_cons_printf (\"%d %s\\n%d %s\\n\\n\", (i*8) + j, analop.mnemonic, (i*8)+j, op.mnemonic);\n\t\t\tint word_change = compare_mnemonics (analop.mnemonic, op.mnemonic);\n\t\t\tr_anal_op_fini (&op);\n\t\t\tif (pj) {\n\t\t\t\tpj_n (pj, word_change);\n\t\t\t\tr_list_append (args[word_change], (void *)(size_t)((i * 8) + 7 - j));\n\t\t\t}\n\t\t\tr_strbuf_appendf (sb, \"%d\", word_change);\n\t\t}\n\t\tif (pj) {\n\t\t\tpj_end (pj);\n\t\t}\n\t\tr_strbuf_append (sb, \" \");\n\t}\n\tif (pj) {\n\t\tvoid *n;\n\t\tRListIter *iter;\n\t\tpj_end (pj);\n\t\tchar *s = r_strbuf_drain (sb);\n\t\tpj_ks (pj, \"flipstr\", s);\n\t\tfree (s);\n\t\tpj_ka (pj, \"args\");\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tif (r_list_empty (args[j])) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpj_a (pj);\n\t\t\tr_list_sort (args[j], intsort);\n\t\t\tr_list_foreach (args[j], iter, n) {\n\t\t\t\tint nn = (int)((size_t)n & ST32_MAX);\n\t\t\t\tpj_n (pj, nn);\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t\tpj_end (pj);\n\t\ts = pj_drain (pj);\n\t\tr_cons_printf (\"%s\\n\", s);\n\t\tfree (s);\n\t} else {\n\t\tif (mode == 'm') {\n\t\t\tint pi = 0;\n\t\t\tchar *s = r_strbuf_drain (sb);\n\t\t\tchar *p = s;\n\t\t\tut8 finalmask[8] = {0};\n\t\t\tfor (; *p; p++) {\n\t\t\t\tint byte_index = (pi / 8);\n\t\t\t\tint bit_index = (pi % 8);\n\t\t\t\tut8 *byte = finalmask + byte_index;\n\t\t\t\tif (*p == '0') {\n\t\t\t\t\t// only pick the bits that modify the 0th word\n\t\t\t\t\tR_BIT_SET (byte, bit_index);\n\t\t\t\t\tpi++;\n\t\t\t\t} else if (isalnum (*p)) {\n\t\t\t\t\tpi++;\n\t\t\t\t}\n\t\t\t\tif (byte_index >= last) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (s);\n\t\t\tfor (i = 0; i < 8 && i < last; i++) {\n\t\t\t\tr_cons_printf (\"%02x\", finalmask[i]);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t} else {\n\t\t\tr_strbuf_appendf (sb, \" : %s\", analop.mnemonic);\n\t\t\tchar *s = r_strbuf_drain (sb);\n\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\tfree (s);\n\t\t}\n\t}\n\tr_anal_op_fini (&analop);\n\tfor (i = 0; i < 8; i++) {\n\t\tr_list_free (args[i]);\n\t}\n}\n\nstatic void cmd_anal_opcode(RCore *core, const char *input) {\n\tint l, len = core->blocksize;\n\tut32 tbs = core->blocksize;\n\tr_core_block_read (core);\n\tswitch (input[0]) {\n\tcase 's': // \"aos\"\n\tcase 'j': // \"aoj\"\n\tcase 'e': // \"aoe\"\n\tcase 'r': { // \"aor\"\n\t\tint count = 1;\n\t\tint obs = core->blocksize;\n\t\tint fmt = input[0];\n\t\tif (input[0] == 'e') {\n\t\t\tswitch (input[1]) {\n\t\t\tcase 'q': // \"aoeq\"\n\t\t\t\tfmt = 'E'; // quiet esil\n\t\t\t\tinput++;\n\t\t\t\tbreak;\n\t\t\tcase 'm': // \"aoem\"\n\t\t\t\tfmt = 'm'; // memory esil\n\t\t\t\tinput++;\n\t\t\t\tbreak;\n\t\t\tcase '?': // \"aoe?\"\n\t\t\t\tr_core_cmd_help_match (core, help_msg_ao, \"aoe\", false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (input[1] && input[2]) {\n\t\t\tl = (int)r_num_get (core->num, input + 1);\n\t\t\tif (l > 0) {\n\t\t\t\tcount = l;\n\t\t\t}\n\t\t\tl *= 8;\n\t\t\tif (l > obs) {\n\t\t\t\tr_core_block_size (core, l);\n\t\t\t}\n\t\t} else {\n\t\t\tcount = 1;\n\t\t}\n\t\tcore_anal_bytes (core, core->block, core->blocksize, count, fmt);\n\t\tif (obs != core->blocksize) {\n\t\t\tr_core_block_size (core, obs);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 't': // \"aot\"\n\t\tif (input[1] == 'l') {\n\t\t\tr_core_cmd_call (core, \"/atl\");\n\t\t} else if (input[1] == '\\0') {\n\t\t\tr_core_cmd0 (core, \"ao~^type[1]\");\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_aot);\n\t\t}\n\t\tbreak;\n\tcase 'm': // \"aom\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_aom);\n\t\t} else if (input[1] == 'd') {\n\t\t\tconst int id = (input[2] == ' ')\n\t\t\t\t?(int)r_num_math (core->num, input + 2): -1;\n\t\t\tchar *ops = r_asm_mnemonics (core->rasm, id, false);\n\t\t\tif (ops) {\n\t\t\t\tchar *ptr = ops;\n\t\t\t\tchar *nl = strchr (ptr, '\\n');\n\t\t\t\twhile (nl) {\n\t\t\t\t\t*nl = 0;\n\t\t\t\t\tchar *desc = r_asm_describe (core->rasm, ptr);\n\t\t\t\t\tif (desc) {\n\t\t\t\t\t\tconst char *pad = r_str_pad (' ', 16 - strlen (ptr));\n\t\t\t\t\t\tr_cons_printf (\"%s%s%s\\n\", ptr, pad, desc);\n\t\t\t\t\t\tfree (desc);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", ptr);\n\t\t\t\t\t}\n\t\t\t\t\tptr = nl + 1;\n\t\t\t\t\tnl = strchr (ptr, '\\n');\n\t\t\t\t}\n\t\t\t\tfree (ops);\n\t\t\t}\n\t\t} else if (input[1] == 'l' || input[1] == '=' || input[1] == ' ' || input[1] == 'j') {\n\t\t\tif (input[1] == ' ' && !IS_DIGIT (input[2])) {\n\t\t\t\tr_cons_printf (\"%d\\n\", r_asm_mnemonics_byname (core->rasm, input + 2));\n\t\t\t} else {\n\t\t\t\t// \"aoml\"\n\t\t\t\tconst int id = (input[1] == ' ')\n\t\t\t\t\t?(int)r_num_math (core->num, input + 2): -1;\n\t\t\t\tchar *ops = r_asm_mnemonics (core->rasm, id, input[1] == 'j');\n\t\t\t\tif (ops) {\n\t\t\t\t\tr_str_trim (ops);\n\t\t\t\t\tr_cons_println (ops);\n\t\t\t\t\tfree (ops);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_cmd0 (core, \"ao~mnemonic[1]\");\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"aob\"\n\t\tif (input[1] == 'j') {\n\t\t\tcmd_anal_opcode_bits (core, r_str_trim_head_ro (input + 2), 'j');\n\t\t} else if (input[1] == 'm') {\n\t\t\tcmd_anal_opcode_bits (core, NULL, 'm');\n\t\t} else {\n\t\t\tcmd_anal_opcode_bits (core, r_str_trim_head_ro (input + 1), 0);\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"aoc\"\n\t{\n\t\tRList *hooks;\n\t\tRListIter *iter;\n\t\tRAnalCycleHook *hook;\n\t\tchar *instr_tmp = NULL;\n\t\tint ccl = input[1]? r_num_math (core->num, &input[2]): 0; //get cycles to look for\n\t\tbool cr = r_config_get_b (core->config, \"asm.cmt.right\");\n\t\tbool fu = r_config_get_b (core->config, \"asm.functions\");\n\t\tbool li = r_config_get_b (core->config, \"asm.lines\");\n\t\tbool xr = r_config_get_b (core->config, \"asm.xrefs\");\n\n\t\tr_config_set_b (core->config, \"asm.cmt.right\", true);\n\t\tr_config_set_b (core->config, \"asm.functions\", false);\n\t\tr_config_set_b (core->config, \"asm.lines\", false);\n\t\tr_config_set_b (core->config, \"asm.xrefs\", false);\n\n\t\thooks = r_core_anal_cycles (core, ccl); //analyse\n\t\tr_cons_clear_line (1);\n\t\tr_list_foreach (hooks, iter, hook) {\n\t\t\tinstr_tmp = r_core_disassemble_instr (core, hook->addr, 1);\n\t\t\tr_cons_printf (\"After %4i cycles:\\t%s\", (ccl - hook->cycles), instr_tmp);\n\t\t\tr_cons_flush ();\n\t\t\tfree (instr_tmp);\n\t\t}\n\t\tr_list_free (hooks);\n\n\t\tr_config_set_b (core->config, \"asm.cmt.right\", cr); //reset settings\n\t\tr_config_set_b (core->config, \"asm.functions\", fu);\n\t\tr_config_set_b (core->config, \"asm.lines\", li);\n\t\tr_config_set_b (core->config, \"asm.xrefs\", xr);\n\t}\n\tbreak;\n\tcase 'd': // \"aod\"\n\t\tif (input[1] == 'a') { // \"aoda\"\n\t\t\t// list sdb database\n\t\t\tsdb_foreach (core->rasm->pair, listOpDescriptions, core);\n\t\t} else if (input[1] == 0) {\n\t\t\tint cur = R_MAX (core->print->cur, 0);\n\t\t\t// XXX: we need cmd_xxx.h (cmd_anal.h)\n\t\t\tcore_anal_bytes (core, core->block + cur, core->blocksize, 1, 'd');\n\t\t} else if (input[1] == ' ') {\n\t\t\tchar *d = r_asm_describe (core->rasm, input + 2);\n\t\t\tif (d && *d) {\n\t\t\t\tr_cons_println (d);\n\t\t\t\tfree (d);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Unknown mnemonic\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_cmd_help_match (core, help_msg_ao, \"aod\", false);\n\t\t}\n\t\tbreak;\n\tcase '*':\n\t\tr_core_anal_hint_list (core->anal, input[0]);\n\t\tbreak;\n\tcase 0:\n\tcase ' ': {\n\t\t\tint count = 0;\n\t\t\tif (input[0]) {\n\t\t\t\tl = (int)r_num_get (core->num, input + 1);\n\t\t\t\tif (l > 0) {\n\t\t\t\t\tcount = l;\n\t\t\t\t}\n\t\t\t\tif (l > tbs) {\n\t\t\t\t\tr_core_block_size (core, l * 4);\n\t\t\t\t\t//len = l;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlen = l = core->blocksize;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t\tcore_anal_bytes (core, core->block, len, count, 0);\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"aof\"\n\t\tif (strlen (input + 1) > 1) {\n\t\t\tRAnalOp aop = {0};\n\t\t\tut8 data[32];\n\t\t\tr_io_read_at (core->io, core->offset, data, sizeof (data));\n\t\t\tint ret = r_anal_op (core->anal, &aop, core->offset, data, sizeof (data), R_ARCH_OP_MASK_ESIL);\n\t\t\tif (ret > 0) {\n\t\t\t\tconst char *arg = input + 2;\n\t\t\t\tconst char *expr = R_STRBUF_SAFEGET (&aop.esil);\n\t\t\t\tRStrBuf *b = r_anal_esil_dfg_filter_expr (core->anal, expr, arg,\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.mapinfo\"),\n\t\t\t\t\tr_config_get_b (core->config, \"esil.dfg.maps\"));\n\t\t\t\tif (b) {\n\t\t\t\t\tchar *s = r_strbuf_drain (b);\n\t\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_WARN (\"Unable to analyze instruction\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_ao);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_jumps(RCore *core, const char *input) {\n\tr_core_cmdf (core, \"af @@= `ax~ref.code.jmp[1]`\");\n}\n\n// TODO: cleanup to reuse code\nstatic void cmd_anal_aftertraps(RCore *core, const char *input) {\n\tint bufi, minop = 1; // 4\n\tut8 *buf;\n\tRAnalOp op = {0};\n\tut64 addr, addr_end;\n\tut64 len = r_num_math (core->num, input);\n\tif (len > ALLOC_SIZE_LIMIT) {\n\t\tR_LOG_ERROR (\"Length is too large\");\n\t\treturn;\n\t}\n\tRBinFile *bf = r_bin_cur (core->bin);\n\tif (!bf) {\n\t\treturn;\n\t}\n\taddr = core->offset;\n\tif (!len) {\n\t\t// ignore search.in to avoid problems. analysis != search\n\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\tif (map && (map->perm & R_PERM_X)) {\n\t\t\t// search in current section\n\t\t\tif (r_io_map_size (map) > bf->size) {\n\t\t\t\taddr = r_io_map_begin (map);\n\t\t\t\tif (bf->size > map->delta) {\n\t\t\t\t\tlen = bf->size - map->delta;\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Oops something went wrong aac\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr = r_io_map_begin (map);\n\t\t\t\tlen = r_io_map_size (map);\n\t\t\t}\n\t\t} else {\n\t\t\tif (map && r_io_map_begin (map) != map->delta && bf->size > (core->offset - r_io_map_begin (map) + map->delta)) {\n\t\t\t\tlen = bf->size - (core->offset - r_io_map_begin (map) + map->delta);\n\t\t\t} else {\n\t\t\t\tif (bf->size > core->offset) {\n\t\t\t\t\tlen = bf->size - core->offset;\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Oops invalid range\");\n\t\t\t\t\tlen = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taddr_end = addr + len;\n\tif (!(buf = malloc (4096))) {\n\t\treturn;\n\t}\n\tbufi = 0;\n\tint trapcount = 0;\n\tint nopcount = 0;\n\tr_cons_break_push (NULL, NULL);\n\twhile (addr < addr_end) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t// TODO: too many ioreads here\n\t\tif (bufi > 4000) {\n\t\t\tbufi = 0;\n\t\t}\n\t\tif (!bufi) {\n\t\t\tr_io_read_at (core->io, addr, buf, 4096);\n\t\t}\n\t\tif (r_anal_op (core->anal, &op, addr, buf + bufi, 4096 - bufi, R_ARCH_OP_MASK_BASIC)) {\n\t\t\tif (op.size < 1) {\n\t\t\t\t// XXX must be +4 on arm/mips/.. like we do in disasm.c\n\t\t\t\top.size = minop;\n\t\t\t}\n\t\t\tif (op.type == R_ANAL_OP_TYPE_TRAP) {\n\t\t\t\ttrapcount ++;\n\t\t\t} else if (op.type == R_ANAL_OP_TYPE_NOP) {\n\t\t\t\tnopcount ++;\n\t\t\t} else {\n\t\t\t\tif (nopcount > 1) {\n\t\t\t\t\tr_cons_printf (\"af @ 0x%08\"PFMT64x\"\\n\", addr);\n\t\t\t\t\tnopcount = 0;\n\t\t\t\t}\n\t\t\t\tif (trapcount > 0) {\n\t\t\t\t\tr_cons_printf (\"af @ 0x%08\"PFMT64x\"\\n\", addr);\n\t\t\t\t\ttrapcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\top.size = minop;\n\t\t}\n\t\taddr += (op.size > 0)? op.size : 1;\n\t\tbufi += (op.size > 0)? op.size : 1;\n\t\tr_anal_op_fini (&op);\n\t}\n\tr_cons_break_pop ();\n\tfree (buf);\n}\n\nstatic void cmd_anal_blocks(RCore *core, const char *input) {\n\tut64 from , to;\n\tchar *arg = strchr (input, ' ');\n\tr_cons_break_push (NULL, NULL);\n\tif (!arg) {\n\t\tr_core_cmd0 (core, \"abb $SS @ $S\");\n\t\tRList *list = r_core_get_boundaries_prot (core, R_PERM_X, NULL, \"anal\");\n\t\tRListIter *iter;\n\t\tRIOMap* map;\n\t\tif (!list) {\n\t\t\tgoto ctrl_c;\n\t\t}\n\t\tr_list_foreach (list, iter, map) {\n\t\t\tfrom = r_io_map_begin (map);\n\t\t\tto = r_io_map_end (map);\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto ctrl_c;\n\t\t\t}\n\t\t\tif (!from && !to) {\n\t\t\t\tR_LOG_ERROR (\"Cannot determine search boundaries\");\n\t\t\t} else if (to - from > UT32_MAX) {\n\t\t\t\tchar *unit = r_num_units (NULL, 0, to - from);\n\t\t\t\tR_LOG_WARN (\"Skipping huge range (%s)\", unit);\n\t\t\t\tfree (unit);\n\t\t\t} else {\n\t\t\t\tR_LOG_DEBUG (\"abb 0x%08\"PFMT64x\" @ 0x%08\"PFMT64x, (to - from), from);\n\t\t\t\tr_core_cmdf (core, \"abb 0x%08\"PFMT64x\" @ 0x%08\"PFMT64x, (to - from), from);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tst64 sz = r_num_math (core->num, arg + 1);\n\t\tif (sz < 1) {\n\t\t\tR_LOG_ERROR (\"Invalid range\");\n\t\t\treturn;\n\t\t}\n\t\tr_core_cmdf (core, \"abb 0x%08\"PFMT64x\" @ 0x%08\"PFMT64x, sz, core->offset);\n\t}\nctrl_c:\n\tr_cons_break_pop ();\n}\n\nstatic void _anal_calls(RCore *core, ut64 addr, ut64 addr_end, bool printCommands, bool importsOnly) {\n\tRAnalOp op = {0};\n\tint depth = r_config_get_i (core->config, \"anal.depth\");\n\tconst int addrbytes = core->io->addrbytes;\n\tconst int bsz = 4096;\n\tint bufi = 0;\n\tint bufi_max = bsz - 16;\n\tif (addr_end - addr > UT32_MAX) {\n\t\treturn;\n\t}\n\tut8 *buf = malloc (bsz);\n\tut8 *block0 = calloc (1, bsz);\n\tut8 *block1 = malloc (bsz);\n\tif (!buf || !block0 || !block1) {\n\t\tfree (buf);\n\t\tfree (block0);\n\t\tfree (block1);\n\t\treturn;\n\t}\n\tmemset (block1, -1, bsz);\n\tint minop = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tif (minop < 1) {\n\t\tminop = 1;\n\t}\n\tint setBits = r_config_get_i (core->config, \"asm.bits\");\n\tr_cons_break_push (NULL, NULL);\n\twhile (addr < addr_end && !r_cons_is_breaked ()) {\n\t\t// TODO: too many ioreads here\n\t\tif (bufi > bufi_max) {\n\t\t\tbufi = 0;\n\t\t}\n\t\tif (!bufi) {\n\t\t\t(void)r_io_read_at (core->io, addr, buf, bsz);\n\t\t}\n\t\tif (!memcmp (buf, block0, bsz) || !memcmp (buf, block1, bsz)) {\n\t\t\taddr += bsz;\n\t\t\tcontinue;\n\t\t}\n\t\tRAnalHint *hint = r_anal_hint_get (core->anal, addr);\n\t\tif (hint && hint->bits) {\n\t\t\tsetBits = hint->bits;\n\t\t}\n\t\tr_anal_hint_free (hint);\n\t\tif (setBits != core->rasm->config->bits) {\n\t\t\tr_config_set_i (core->config, \"asm.bits\", setBits);\n\t\t}\n\t\tif (r_anal_op (core->anal, &op, addr, buf + bufi, bsz - bufi, 0) > 0) {\n\t\t\tif (op.size < 1) {\n\t\t\t\top.size = minop;\n\t\t\t}\n\t\t\tif (op.type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\tbool isValidCall = true;\n\t\t\t\tif (importsOnly) {\n\t\t\t\t\tRFlagItem *f = r_flag_get_i (core->flags, op.jump);\n\t\t\t\t\tif (!f || !strstr (f->name, \"imp.\")) {\n\t\t\t\t\t\tisValidCall = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRBinReloc *rel = r_core_getreloc (core, addr, op.size);\n\t\t\t\tif (rel && (rel->import || rel->symbol)) {\n\t\t\t\t\tisValidCall = false;\n\t\t\t\t}\n\t\t\t\tif (isValidCall) {\n\t\t\t\t\tut8 zbuf[4] = {0};\n\t\t\t\t\tr_io_read_at (core->io, op.jump, zbuf, 4);\n\t\t\t\t\tisValidCall = memcmp (zbuf, \"\\x00\\x00\\x00\\x00\", 4);\n\t\t\t\t}\n\t\t\t\tif (isValidCall) {\n#if JAYRO_03\n\t\t\t\t\tif (!anal_is_bad_call (core, from, to, addr, buf, bufi)) {\n\t\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, op.jump, R_ANAL_FCN_TYPE_ROOT);\n\t\t\t\t\t\tif (!fcn) {\n\t\t\t\t\t\t\tr_core_anal_fcn (core, op.jump, addr, R_ANAL_REF_TYPE_CALL, depth - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#else\n\t\t\t\t\tif (printCommands) {\n\t\t\t\t\t\tr_cons_printf (\"ax 0x%08\" PFMT64x \" 0x%08\" PFMT64x \"\\n\", op.jump, addr);\n\t\t\t\t\t\tr_cons_printf (\"af @ 0x%08\" PFMT64x\"\\n\", op.jump);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// add xref here\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, addr, op.jump, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\t\tif (r_io_is_valid_offset (core->io, op.jump, 1)) {\n\t\t\t\t\t\t\tr_core_anal_fcn (core, op.jump, addr, R_ANAL_REF_TYPE_CALL, depth - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\top.size = minop;\n\t\t}\n\t\tif ((int)op.size < 1) {\n\t\t\top.size = minop;\n\t\t}\n\t\taddr += op.size;\n\t\tbufi += addrbytes * op.size;\n\t\tr_anal_op_fini (&op);\n\t}\n\tr_cons_break_pop ();\n\tfree (buf);\n\tfree (block0);\n\tfree (block1);\n}\n\nstatic void cmd_anal_calls(RCore *core, const char *input, bool printCommands, bool importsOnly) {\n\tRList *ranges = NULL;\n\tRIOMap *r;\n\tut64 addr;\n\tut64 len = r_num_math (core->num, input);\n\tif (len > 0xffffff) {\n\t\tR_LOG_ERROR (\"Too big\");\n\t\treturn;\n\t}\n\tRBinFile *binfile = r_bin_cur (core->bin);\n\taddr = core->offset;\n\tif (binfile) {\n\t\tif (len) {\n\t\t\tRIOMap *m = R_NEW0 (RIOMap);\n\t\t\tm->itv.addr = addr;\n\t\t\tm->itv.size = len;\n\t\t\tranges = r_list_newf ((RListFree)free);\n\t\t\tr_list_append (ranges, m);\n\t\t} else {\n\t\t\tranges = r_core_get_boundaries_prot (core, R_PERM_X, NULL, \"anal\");\n\t\t}\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tif (!binfile || (ranges && !r_list_length (ranges))) {\n\t\tRListIter *iter;\n\t\tRIOMap *map;\n\t\tr_list_free (ranges);\n\t\tranges = r_core_get_boundaries_prot (core, 0, NULL, \"anal\");\n\t\tif (ranges) {\n\t\t\tr_list_foreach (ranges, iter, map) {\n\t\t\t\tut64 addr = r_io_map_begin (map);\n\t\t\t\t_anal_calls (core, addr, r_io_map_end (map), printCommands, importsOnly);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tRListIter *iter;\n\t\tif (binfile) {\n\t\t\tr_list_foreach (ranges, iter, r) {\n\t\t\t\taddr = r->itv.addr;\n\t\t\t\t//this normally will happen on fuzzed binaries, dunno if with huge\n\t\t\t\t//binaries as well\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t_anal_calls (core, addr, r_itv_end (r->itv), printCommands, importsOnly);\n\t\t\t}\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\tr_list_free (ranges);\n}\n\nstatic void cmd_sdbk(Sdb *db, const char *input) {\n\tconst char *arg = (input[0] == ' ')? input + 1: \"*\";\n\tchar *out = sdb_querys (db, NULL, 0, arg);\n\tif (out) {\n\t\tr_cons_println (out);\n\t\tfree (out);\n\t} else {\n\t\tR_LOG_ERROR (\"Usage: ask [query]\");\n\t}\n}\n\nstatic void cmd_anal_syscall(RCore *core, const char *input) {\n\tchar snstr[32];\n\tPJ *pj = NULL;\n\tRSyscallItem *si;\n\tRListIter *iter;\n\tRList *list;\n\tint n;\n\n\tswitch (input[0]) {\n\tcase 'c': // \"asc\"\n\t\tif (input[1] == 'a') {\n\t\t\tif (input[2] == ' ') {\n\t\t\t\tif (!isalpha ((ut8)input[3]) && (n = r_num_math (core->num, input + 3)) >= 0 ) {\n\t\t\t\t\tsi = r_syscall_get (core->anal->syscall, n, -1);\n\t\t\t\t\tif (si) {\n\t\t\t\t\t\tr_cons_printf (\".equ SYS_%s %s\\n\", si->name, syscallNumber (snstr, n));\n\t\t\t\t\t\tr_syscall_item_free (si);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tR_LOG_ERROR (\"Unknown syscall number\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tn = r_syscall_get_num (core->anal->syscall, input + 3);\n\t\t\t\t\tif (n != -1) {\n\t\t\t\t\t\tr_cons_printf (\".equ SYS_%s %s\\n\", input + 3, syscallNumber (snstr, n));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tR_LOG_ERROR (\"Unknown syscall name\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlist = r_syscall_list (core->anal->syscall);\n\t\t\t\tr_list_foreach (list, iter, si) {\n\t\t\t\t\tr_cons_printf (\".equ SYS_%s %s\\n\", si->name, syscallNumber (snstr, si->num));\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t} else {\n\t\t\tif (input[1] == ' ') {\n\t\t\t\tif (!isalpha ((ut8)input[2]) && (n = r_num_math (core->num, input + 2)) >= 0) {\n\t\t\t\t\tsi = r_syscall_get (core->anal->syscall, n, -1);\n\t\t\t\t\tif (si) {\n\t\t\t\t\t\tr_cons_printf (\"#define SYS_%s %s\\n\", si->name, syscallNumber (snstr, n));\n\t\t\t\t\t\tr_syscall_item_free (si);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tR_LOG_ERROR (\"Unknown syscall number\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tn = r_syscall_get_num (core->anal->syscall, input + 2);\n\t\t\t\t\tif (n != -1) {\n\t\t\t\t\t\tr_cons_printf (\"#define SYS_%s %s\\n\", input + 2, syscallNumber (snstr, n));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tR_LOG_ERROR (\"Unknown syscall name\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlist = r_syscall_list (core->anal->syscall);\n\t\t\t\tr_list_foreach (list, iter, si) {\n\t\t\t\t\tr_cons_printf (\"#define SYS_%s %s\\n\",\n\t\t\t\t\t\tsi->name, syscallNumber (snstr, si->num));\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'k': // \"ask\"\n\t\tcmd_sdbk (core->anal->syscall->db, input + 1);\n\t\tbreak;\n\tcase 'l': // \"asl\"\n\t\tif (input[1] == ' ') {\n\t\t\tconst char *sc_name = r_str_trim_head_ro (input + 2);\n\t\t\tint sc_number = r_syscall_get_num (core->anal->syscall, sc_name);\n\t\t\tif (sc_number != 0) {\n\t\t\t\tr_cons_printf (\"%s\\n\", syscallNumber (snstr, sc_number));\n\t\t\t} else {\n\t\t\t\tsc_number = r_num_math (core->num, sc_name);\n\t\t\t\tsi = r_syscall_get (core->anal->syscall, sc_number, -1);\n\t\t\t\tif (!si) {\n\t\t\t\t\tsi = r_syscall_get (core->anal->syscall, -1, sc_number);\n\t\t\t\t}\n\t\t\t\tif (si) {\n\t\t\t\t\tr_cons_println (si->name);\n\t\t\t\t\tr_syscall_item_free (si);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Unknown syscall number\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlist = r_syscall_list (core->anal->syscall);\n\t\t\tr_list_foreach (list, iter, si) {\n\t\t\t\tr_cons_printf (\"%s = 0x%02x.%s\\n\",\n\t\t\t\t\tsi->name, si->swi, syscallNumber (snstr, si->num));\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"asj\"\n\t\tpj = pj_new ();\n\t\tpj_a (pj);\n\t\tlist = r_syscall_list (core->anal->syscall);\n\t\tr_list_foreach (list, iter, si) {\n\t\t\tpj_o (pj);\n\t\t\tpj_ks (pj, \"name\", si->name);\n\t\t\tpj_ki (pj, \"swi\", si->swi);\n\t\t\tpj_ki (pj, \"num\", si->num);\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t\tif (pj) {\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t}\n\t\tr_list_free (list);\n\t\tbreak;\n\tcase '\\0':\n\t\tcmd_syscall_do (core, -1, core->offset);\n\t\tbreak;\n\tcase ' ':\n\t\t{\n\t\tconst char *sn = r_str_trim_head_ro (input + 1);\n\t\tst64 num = r_syscall_get_num (core->anal->syscall, sn);\n\t\tif (num < 1) {\n\t\t\tnum = (int)r_num_get (core->num, sn);\n\t\t}\n\t\tcmd_syscall_do (core, num, -1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_as);\n\t\tbreak;\n\t}\n}\n\nstatic void anal_axg(RCore *core, const char *input, int level, Sdb *db, int opts, PJ* pj) {\n\tchar arg[32], pre[128];\n\tRAnalRef *ref;\n\tut64 addr = core->offset;\n\tbool is_json = opts & R_CORE_ANAL_JSON;\n\tbool is_r2 = opts & R_CORE_ANAL_GRAPHBODY;\n\tif (is_json && !pj) {\n\t\treturn;\n\t}\n\tif (input && *input) {\n\t\taddr = r_num_math (core->num, input);\n\t}\n\t// eprintf (\"Path between 0x%08\"PFMT64x\" .. 0x%08\"PFMT64x\"\\n\", core->offset, addr);\n\tint spaces = (level + 1) * 2;\n\tif (spaces > sizeof (pre) - 4) {\n\t\tspaces = sizeof (pre) - 4;\n\t}\n\tmemset (pre, ' ', sizeof (pre));\n\tstrcpy (pre + spaces, \"- \");\n\n\tRVecAnalRef *xrefs = r_anal_xrefs_get (core->anal, addr);\n\tbool open_object = false;\n\tif (xrefs && !RVecAnalRef_empty (xrefs)) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, -1);\n\t\tif (fcn) {\n\t\t\tif (is_r2) {\n\t\t\t\tr_cons_printf (\"agn 0x%08\"PFMT64x\" %s\\n\", fcn->addr, fcn->name);\n\t\t\t} else if (is_json) {\n\t\t\t\tchar taddr[64];\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_k (pj, sdb_itoa (addr, 10, taddr, sizeof (taddr)));\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"type\", \"fcn\");\n\t\t\t\tpj_kn (pj, \"fcn_addr\", fcn->addr);\n\t\t\t\tpj_ks (pj, \"name\", fcn->name);\n\t\t\t\tpj_k (pj, \"refs\");\n\t\t\t\tpj_a (pj);\n\t\t\t\topen_object = true;\n\t\t\t} else {\n\t\t\t\t//if (sdb_add (db, fcn->name, \"1\", 0)) {\n\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" fcn 0x%08\"PFMT64x\" %s\\n\",\n\t\t\t\t\tpre + 2, addr, fcn->addr, fcn->name);\n\t\t\t\t//}\n\t\t\t}\n\t\t} else {\n\t\t\tif (is_r2) {\n\t\t\t\tr_cons_printf (\"age 0x%08\"PFMT64x\"\\n\", addr);\n\t\t\t} else if (is_json) {\n\t\t\t\tchar taddr[64];\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_k (pj, sdb_itoa (addr, 10, taddr, sizeof (taddr)));\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_k (pj, \"refs\");\n\t\t\t\tpj_a (pj);\n\t\t\t\topen_object = true;\n\t\t\t} else {\n\t\t\t//snprintf (arg, sizeof (arg), \"0x%08\"PFMT64x, addr);\n\t\t\t//if (sdb_add (db, arg, \"1\", 0)) {\n\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\"\\n\", pre+2, addr);\n\t\t\t//}\n\t\t\t}\n\t\t}\n\t}\n\tif (xrefs) {\n\t\tR_VEC_FOREACH (xrefs, ref) {\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, ref->addr, -1);\n\t\t\tif (fcn) {\n\t\t\t\tif (is_r2) {\n\t\t\t\t\tr_cons_printf (\"agn 0x%08\"PFMT64x\" %s\\n\", fcn->addr, fcn->name);\n\t\t\t\t\tr_cons_printf (\"age 0x%08\"PFMT64x\" 0x%08\"PFMT64x\"\\n\", fcn->addr, addr);\n\t\t\t\t} else if (is_json) {\n\t\t\t\t\tif (level == 0) {\n\t\t\t\t\t\tchar taddr[64];\n\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\tpj_k (pj, sdb_itoa (ref->addr, 10, taddr, sizeof (taddr)));\n\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\tpj_ks (pj, \"type\", \"fcn\");\n\t\t\t\t\t\tpj_kn (pj, \"fcn_addr\", fcn->addr);\n\t\t\t\t\t\tpj_ks (pj, \"name\", fcn->name);\n\t\t\t\t\t\tpj_k (pj, \"refs\");\n\t\t\t\t\t\tpj_a (pj);\n\t\t\t\t\t\topen_object = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar taddr[64];\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\tpj_k (pj, sdb_itoa (ref->addr, 10, taddr, sizeof (taddr)));\n\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\tpj_ks (pj, \"type\", \"fcn\");\n\t\t\t\t\t\tpj_kn (pj, \"fcn_addr\", fcn->addr);\n\t\t\t\t\t\tpj_ks (pj, \"name\", fcn->name);\n\t\t\t\t\t\tpj_k (pj, \"refs\");\n\t\t\t\t\t\tpj_a (pj);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" fcn 0x%08\"PFMT64x\" %s\\n\", pre, ref->addr, fcn->addr, fcn->name);\n\t\t\t\t}\n\t\t\t\tif (sdb_add (db, fcn->name, \"1\", 0)) {\n\t\t\t\t\tsnprintf (arg, sizeof (arg), \"0x%08\"PFMT64x, fcn->addr);\n\t\t\t\t\tanal_axg (core, arg, level + 1, db, opts, pj);\n\t\t\t\t} else {\n\t\t\t\t\tif (is_json) {\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\topen_object = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (is_r2) {\n\t\t\t\t\tr_cons_printf (\"agn 0x%08\"PFMT64x\" ???\\n\", ref->addr);\n\t\t\t\t\tr_cons_printf (\"age 0x%08\"PFMT64x\" 0x%08\"PFMT64x\"\\n\", ref->addr, addr);\n\t\t\t\t} else if (is_json) {\n\t\t\t\t\tchar taddr[64];\n\t\t\t\t\tpj_o (pj);\n\t\t\t\t\tpj_k (pj, sdb_itoa (ref->addr, 10, taddr, sizeof (taddr)));\n\t\t\t\t\tpj_o (pj);\n\t\t\t\t\tpj_ks (pj, \"type\", \"???\");\n\t\t\t\t\tpj_k (pj, \"refs\");\n\t\t\t\t\tpj_a (pj);\n\t\t\t\t\topen_object = true;\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" ???\\n\", pre, ref->addr);\n\t\t\t\t}\n\t\t\t\tsnprintf (arg, sizeof (arg), \"0x%08\"PFMT64x, ref->addr);\n\t\t\t\tif (sdb_add (db, arg, \"1\", 0)) {\n\t\t\t\t\tanal_axg (core, arg, level + 1, db, opts, pj);\n\t\t\t\t} else {\n\t\t\t\t\tif (is_json) {\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\topen_object = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (is_json) {\n\t\tif (open_object) {\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t}\n\t\tif (level == 0) {\n\t\t\tif (open_object) {\n\t\t\t\tpj_end (pj);\n\t\t\t\tpj_end (pj);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t}\n\t}\n\tRVecAnalRef_free (xrefs);\n}\n\nstatic void cmd_anal_ucall_ref(RCore *core, ut64 addr) {\n\tRAnalFunction *fcn = r_anal_get_function_at (core->anal, addr);\n\tif (fcn) {\n\t\tr_cons_printf (\" ; %s\", fcn->name);\n\t} else {\n\t\tr_cons_printf (\" ; 0x%\" PFMT64x, addr);\n\t}\n}\n\nstatic char *get_op_ireg(void *user, ut64 addr) {\n\tRCore *core = (RCore *)user;\n\tchar *res = NULL;\n\tRAnalOp *op = r_core_anal_op (core, addr, 0);\n\tif (op && op->ireg) {\n\t\tres = strdup (op->ireg);\n\t}\n\tr_anal_op_free (op);\n\treturn res;\n}\n\nstatic char *get_buf_asm(RCore *core, ut64 from, ut64 addr, RAnalFunction *fcn, bool color) {\n\tint has_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\tchar str[512];\n\tconst int size = 12;\n\tut8 buf[12];\n\tRAnalOp asmop = {0};\n\tbool asm_subvar = r_config_get_b (core->config, \"asm.sub.var\");\n\tbool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->rasm->config);\n\tcore->parser->pseudo = r_config_get_b (core->config, \"asm.pseudo\");\n\tcore->parser->subrel = r_config_get_i (core->config, \"asm.sub.rel\");\n\tcore->parser->localvar_only = r_config_get_b (core->config, \"asm.sub.varonly\");\n\n\tif (core->parser->subrel) {\n\t\tcore->parser->subrel_addr = from;\n\t}\n\tr_io_read_at (core->io, addr, buf, size);\n\tr_asm_set_pc (core->rasm, addr);\n\tr_asm_disassemble (core->rasm, &asmop, buf, size);\n\tint ba_len = strlen (asmop.mnemonic) + 128;\n\tchar *ba = malloc (ba_len);\n\tstrcpy (ba, asmop.mnemonic);\n\tif (asm_subvar) {\n\t\tcore->parser->get_ptr_at = r_anal_function_get_var_stackptr_at;\n\t\tcore->parser->get_reg_at = r_anal_function_get_var_reg_at;\n\t\tcore->parser->get_op_ireg = get_op_ireg;\n\t\tr_parse_subvar (core->parser, fcn, addr, asmop.size, ba, ba, ba_len);\n\t}\n\tRAnalHint *hint = r_anal_hint_get (core->anal, addr);\n\tr_parse_filter (core->parser, addr, core->flags, hint, ba, str, sizeof (str), be);\n\tr_anal_hint_free (hint);\n\tr_anal_op_set_mnemonic (&asmop, asmop.addr, ba);\n\tfree (ba);\n\tchar *buf_asm = NULL;\n\tif (color && has_color) {\n\t\tbuf_asm = r_print_colorize_opcode (core->print, str,\n\t\t\t\tcore->cons->context->pal.reg, core->cons->context->pal.num, false, fcn ? fcn->addr : 0);\n\t} else {\n\t\tbuf_asm = r_str_new (str);\n\t}\n\treturn buf_asm;\n}\n\nstatic const char *axtm_name(RCore *core, ut64 addr) {\n\tconst char *name = NULL;\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, -1);\n\tif (fcn) {\n\t\tname = fcn->name;\n\t} else {\n\t\tRFlagItem *f = r_flag_get_at (core->flags, addr, false);\n\t\tif (f) {\n\t\t\tname = f->name;\n\t\t}\n\t}\n\treturn name;\n}\n\n// Alternative sorting, first by \"addr\"/\"from\", then by \"at\"/\"to\"\nstatic inline int compare_ref(const RAnalRef *a, const RAnalRef *b) {\n\tif (a->addr < b->addr) {\n\t\treturn -1;\n\t}\n\tif (a->addr > b->addr) {\n\t\treturn 1;\n\t}\n\tif (a->at < b->at) {\n\t\treturn -1;\n\t}\n\tif (a->at > b->at) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void axtm(RCore *core) {\n\tRVecAnalRef *refs = r_anal_xrefs_get (core->anal, UT64_MAX);\n\tif (refs && !RVecAnalRef_empty (refs)) {\n\t\tRVecAnalRef_sort (refs, compare_ref);\n\n\t\tut64 last_addr = UT64_MAX;\n\t\tRAnalRef *ref;\n\t\tR_VEC_FOREACH (refs, ref) {\n\t\t\tconst bool is_first = ref->addr != last_addr;\n\t\t\tconst char *name;\n\t\t\tif (is_first) {\n\t\t\t\tname = axtm_name (core, ref->addr);\n\t\t\t\tr_cons_printf (\"0x%\"PFMT64x\": %s\\n\", ref->addr, name? name: \"?\");\n\t\t\t}\n\n\t\t\tname = axtm_name (core, ref->at);\n\t\t\tr_cons_printf (\"  0x%\"PFMT64x\": %s\\n\", ref->at, name? name: \"?\");\n\n\t\t\tlast_addr = ref->addr;\n\t\t}\n\t}\n\n\tRVecAnalRef_free (refs);\n}\n\nstatic void axfm(RCore *core) {\n\tRVecAnalRef *refs = r_anal_xrefs_get_from (core->anal, UT64_MAX);\n\tif (refs && !RVecAnalRef_empty (refs)) {\n\t\tRVecAnalRef_sort (refs, compare_ref);\n\n\t\tut64 last_addr = UT64_MAX;\n\t\tRAnalRef *ref;\n\t\tR_VEC_FOREACH (refs, ref) {\n\t\t\tconst bool is_first = ref->addr != last_addr;\n\t\t\tconst char *name;\n\t\t\tif (is_first) {\n\t\t\t\tname = axtm_name (core, ref->addr);\n\t\t\t\tr_cons_printf (\"0x%\"PFMT64x\": %s\\n\", ref->addr, name? name: \"?\");\n\t\t\t}\n\n\t\t\tname = axtm_name (core, ref->at);\n\t\t\tr_cons_printf (\"  0x%\"PFMT64x\": %s\\n\", ref->at, name? name: \"?\");\n\n\t\t\tlast_addr = ref->addr;\n\t\t}\n\t}\n\tRVecAnalRef_free (refs);\n}\n\nstatic bool cmd_anal_refs(RCore *core, const char *input) {\n\tbool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->print->config);\n\tut64 addr = core->offset;\n\tswitch (input[0]) {\n\tcase '-': { // \"ax-\"\n\t\tchar *cp_inp = strdup (input + 1);\n\t\tchar *ptr = cp_inp;\n\t\tr_str_trim_head (ptr);\n\t\tif (!strcmp (ptr, \"*\")) { // \"ax-*\"\n\t\t\tr_anal_xrefs_init (core->anal);\n\t\t} else {\n\t\t\tint n = r_str_word_set0 (ptr);\n\t\t\tut64 from = UT64_MAX, to = UT64_MAX;\n\t\t\tswitch (n) {\n\t\t\tcase 2:\n\t\t\t\tfrom = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t\t//fall through\n\t\t\tcase 1: // get addr\n\t\t\t\tto = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tto = core->offset;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// R2_590 slow, we should add a function that deletes several xrefs\n\t\t\tRVecAnalRef *list = r_anal_xrefs_get (core->anal, to);\n\t\t\tRAnalRef *ref;\n\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\tif (from != UT64_MAX && from == ref->addr) {\n\t\t\t\t\tr_anal_xref_del (core->anal, ref->addr, ref->at);\n\t\t\t\t}\n\t\t\t\tif (from == UT64_MAX) {\n\t\t\t\t\tr_anal_xref_del (core->anal, ref->addr, ref->at);\n\t\t\t\t}\n\t\t\t}\n\t\t\tRVecAnalRef_free (list);\n\t\t}\n\t\tfree (cp_inp);\n\t} break;\n\tcase 'g': // \"axg\"\n\t\t{\n\t\t\tSdb *db = sdb_new0 ();\n\t\t\tif (input[1] == '*') {\n\t\t\t\tanal_axg (core, input + 2, 0, db, R_CORE_ANAL_GRAPHBODY, NULL); // r2 commands\n\t\t\t} else if (input[1] == 'j') {\n\t\t\t\tPJ *pj = pj_new ();\n\t\t\t\tanal_axg (core, input + 2, 0, db, R_CORE_ANAL_JSON, pj);\n\t\t\t\tr_cons_printf(\"%s\\n\", pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t} else {\n\t\t\t\tanal_axg (core, input[1] ? input + 2 : NULL, 0, db, 0, NULL);\n\t\t\t}\n\t\t\tsdb_free (db);\n\t\t}\n\t\tbreak;\n\tcase '\\0': // \"ax\"\n\tcase 'q': // \"axq\"\n\tcase '*': // \"ax*\"\n\tcase ',': // \"ax,\"\n\t\tr_anal_xrefs_list (core->anal, input[0], *input? r_str_trim_head_ro (input + 1): \"\");\n\t\tbreak;\n\tcase '.': { // \"ax.\"\n\t\tchar *tInput = strdup (input);\n\t\tif (r_str_replace_ch (tInput, '.', 't', false)) {\n\t\t\tcmd_anal_refs (core, tInput);\n\t\t}\n\t\tchar *fInput = strdup (input);\n\t\tif (r_str_replace_ch (fInput, '.', 'f', false)) {\n\t\t\tcmd_anal_refs (core, fInput);\n\t\t}\n\t\tfree (tInput);\n\t\tfree (fInput);\n\t} break;\n\tcase 'm': { // \"axm\"\n\t\tchar *ptr = strdup (r_str_trim_head_ro (input + 1));\n\t\tint n = r_str_word_set0 (ptr);\n\t\tut64 at = core->offset;\n\t\tut64 addr = UT64_MAX;\n\t\tswitch (n) {\n\t\tcase 2: // get at\n\t\t\tat = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t/* fall through */\n\t\tcase 1: // get addr\n\t\t\taddr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfree (ptr);\n\t\t\treturn false;\n\t\t}\n\t\t//get all xrefs pointing to addr\n\t\tRVecAnalRef *list = r_anal_xrefs_get (core->anal, addr);\n\t\tRAnalRef *ref;\n\t\tR_VEC_FOREACH (list, ref) {\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\" %s %s\\n\", ref->addr,\n\t\t\t\tr_anal_ref_perm_tostring (ref),\n\t\t\t\tr_anal_ref_type_tostring (ref->type));\n\t\t\tr_anal_xrefs_set (core->anal, ref->addr, at, ref->type);\n\t\t}\n\t\tRVecAnalRef_free (list);\n\t\tfree (ptr);\n\t} break;\n\tcase 'v': // \"axv\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_axv);\n\t\t} else {\n\t\t\tcmd_afvx (core, NULL, input[1] == 'j');\n\t\t}\n\t\tbreak;\n\tcase 'l': // \"axl\"\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_axl);\n\t\t\tbreak;\n\t\tcase 'j': // \"axlj\"\n\t\t\tr_anal_xrefs_list (core->anal, 'j', \"\");\n\t\t\tbreak;\n\t\tcase 'c': // \"axlc\"\n\t\t\t{\n\t\t\t\tut64 count = r_anal_xrefs_count (core->anal);\n\t\t\t\tr_cons_printf (\"%\"PFMT64d\"\\n\", count);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'q': // \"axlq\"\n\t\t\tr_core_cmd_call (core, \"axq\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_call (core, \"ax\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 't': { // \"axt\"\n\t\tif (input[1] == '?') { // \"axt?\"\n\t\t\tr_core_cmd_help (core, help_msg_axt);\n\t\t\tbreak;\n\t\t}\n\t\tif (input[1] == 'm') { // \"axtm\"\n\t\t\t// like aflm but reversed\n\t\t\taxtm (core);\n\t\t\tbreak;\n\t\t}\n\t\tRAnalFunction *fcn;\n\t\tchar *space = strchr (input, ' ');\n\t\tif (space) {\n\t\t\taddr = r_num_math (core->num, space + 1);\n\t\t\tif (core->num->nc.errors > 0) {\n\t\t\t\tR_LOG_ERROR (\"Invalid argument\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\taddr = core->offset;\n\t\t}\n\t\tRVecAnalRef *list = r_anal_xrefs_get (core->anal, addr);\n\t\tif (list) {\n\t\t\tif (input[1] == 'q') { // \"axtq\"\n\t\t\t\tRAnalRef *ref;\n\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", ref->addr);\n\t\t\t\t}\n\t\t\t} else if (input[1] == 'j') { // \"axtj\"\n\t\t\t\tPJ *pj = pj_new ();\n\t\t\t\tif (!pj) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpj_a (pj);\n\t\t\t\tRAnalRef *ref;\n\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, ref->addr, 0);\n\t\t\t\t\tchar *str = get_buf_asm (core, addr, ref->addr, fcn, false);\n\t\t\t\t\tpj_o (pj);\n\t\t\t\t\tpj_kn (pj, \"from\", ref->addr);\n\t\t\t\t\tif (ref->type) {\n\t\t\t\t\t\tpj_ks (pj, \"type\", r_anal_ref_type_tostring (ref->type));\n\t\t\t\t\t\tpj_ks (pj, \"perm\", r_anal_ref_perm_tostring (ref));\n\t\t\t\t\t}\n\t\t\t\t\tpj_ks (pj, \"opcode\", str);\n\t\t\t\t\tif (fcn) {\n\t\t\t\t\t\tpj_kn (pj, \"fcn_addr\", fcn->addr);\n\t\t\t\t\t\tpj_ks (pj, \"fcn_name\", fcn->name);\n\t\t\t\t\t}\n\t\t\t\t\tRFlagItem *fi = r_flag_get_at (core->flags, fcn? fcn->addr: ref->addr, true);\n\t\t\t\t\tif (fi) {\n\t\t\t\t\t\tif (fcn) {\n\t\t\t\t\t\t\tif (strcmp (fcn->name, fi->name)) {\n\t\t\t\t\t\t\t\tpj_ks (pj, \"flag\", fi->name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpj_k (pj, \"name\");\n\t\t\t\t\t\t\tif (fi->offset != ref->addr) {\n\t\t\t\t\t\t\t\tint delta = (int)(ref->addr - fi->offset);\n\t\t\t\t\t\t\t\tchar *name_ref = r_str_newf (\"%s+%d\", fi->name, delta);\n\t\t\t\t\t\t\t\tpj_s (pj, name_ref);\n\t\t\t\t\t\t\t\tfree (name_ref);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpj_s (pj, fi->name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (fi->realname && strcmp (fi->name, fi->realname)) {\n\t\t\t\t\t\t\tchar *escaped = r_str_escape (fi->realname);\n\t\t\t\t\t\t\tif (escaped) {\n\t\t\t\t\t\t\t\tpj_ks (pj, \"realname\", escaped);\n\t\t\t\t\t\t\t\tfree (escaped);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRFlagItem *fi = r_flag_get_at (core->flags, fcn? fcn->addr: ref->addr, false);\n\t\t\t\t\t\tif (fi) {\n\t\t\t\t\t\t\tpj_ks (pj, \"near_name\", fi->name);\n\t\t\t\t\t\t\tpj_kn (pj, \"near_addr\", fi->offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchar *refname = core->anal->coreb.getNameDelta (core, ref->at);\n\t\t\t\t\tif (refname) {\n\t\t\t\t\t\tr_str_replace_ch (refname, ' ', 0, true);\n\t\t\t\t\t\tpj_ks (pj, \"refname\", refname);\n\t\t\t\t\t\tfree (refname);\n\t\t\t\t\t}\n\t\t\t\t\tpj_end (pj);\n\t\t\t\t\tfree (str);\n\t\t\t\t}\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_printf (\"%s\", pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t\tr_cons_newline ();\n\t\t\t} else if (input[1] == 'g') { // axtg\n\t\t\t\tRAnalRef *ref;\n\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\tchar *str = r_core_cmd_strf (core, \"fd 0x%\"PFMT64x, ref->addr);\n\t\t\t\t\tif (!str) {\n\t\t\t\t\t\tstr = strdup (\"?\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tr_str_trim_tail (str);\n\t\t\t\t\tr_cons_printf (\"agn 0x%\" PFMT64x \" \\\"%s\\\"\\n\", ref->addr, str);\n\t\t\t\t\tfree (str);\n\t\t\t\t}\n\t\t\t\tif (input[2] != '*') {\n\t\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\t\t\tr_cons_printf (\"agn 0x%\" PFMT64x \" \\\"%s\\\"\\n\", addr, fcn?fcn->name: \"$$\");\n\t\t\t\t}\n\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\tr_cons_printf (\"age 0x%\" PFMT64x \" 0x%\"PFMT64x\"\\n\", ref->addr, addr);\n\t\t\t\t}\n\t\t\t} else if (input[1] == '*') { // axt*\n\t\t\t\t// TODO: implement multi-line comments\n\t\t\t\tconst ut64 length = RVecAnalRef_length (list);\n\t\t\t\tut64 i = 0;\n\t\t\t\tRAnalRef *ref;\n\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\tconst bool is_at_end = i == length;\n\t\t\t\t\tr_cons_printf (\"CCa 0x%\" PFMT64x \" \\\"XREF type %d at 0x%\" PFMT64x\"%s\\n\",\n\t\t\t\t\t\tref->addr, ref->type, addr, is_at_end? \"\": \",\");\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t} else if (input[1] == ' ' || input[1] == 0) { // \"axt\"\n\t\t\t\tRAnalFunction *fcn;\n\t\t\t\tRAnalRef *ref;\n\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, ref->addr, 0);\n\t\t\t\t\tchar *buf_asm = get_buf_asm (core, addr, ref->addr, fcn, true);\n\t\t\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, ref->addr);\n\t\t\t\t\tchar *print_comment = NULL;\n\t\t\t\t\tconst char *nl = comment ? strchr (comment, '\\n') : NULL;\n\t\t\t\t\tif (nl) { // display only until the first newline\n\t\t\t\t\t\tcomment = print_comment = r_str_ndup (comment, nl - comment);\n\t\t\t\t\t}\n\t\t\t\t\tchar *buf_fcn = comment\n\t\t\t\t\t\t? r_str_newf (\"%s; %s\", fcn ?  fcn->name : \"(nofunc)\", comment)\n\t\t\t\t\t\t: r_str_newf (\"%s\", fcn ? fcn->name : \"(nofunc)\");\n\t\t\t\t\tfree (print_comment);\n\t\t\t\t\tr_cons_printf (\"%s 0x%\" PFMT64x \" [%s:%s] %s\\n\",\n\t\t\t\t\t\tbuf_fcn, ref->addr, r_anal_ref_type_tostring (ref->type),\n\t\t\t\t\t\tr_anal_ref_perm_tostring (ref), buf_asm);\n\t\t\t\t\tfree (buf_asm);\n\t\t\t\t\tfree (buf_fcn);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_core_cmd_help (core, help_msg_axt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (input[1] == 'j') { // \"axtj\"\n\t\t\t\tPJ *pj = pj_new ();\n\t\t\t\tif (!pj) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpj_a (pj);\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t}\n\t\t}\n\t\tRVecAnalRef_free (list);\n\t} break;\n\tcase 'f':\n\t\tif (input[1] == 'f') { // \"axff\"\n\t\t\tRAnalFunction * fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\tPJ *pj = NULL;\n\t\t\tif (input[2] == 'j') { // \"axffj\"\n\t\t\t\t// start a new JSON object\n\t\t\t\tpj = pj_new ();\n\t\t\t\tpj_a (pj);\n\t\t\t}\n\t\t\tif (fcn) {\n\t\t\t\tRVecAnalRef *refs = r_anal_function_get_refs (fcn);\n\t\t\t\tRAnalRef *refi;\n\t\t\t\tR_VEC_FOREACH (refs, refi) {\n\t\t\t\t\tRFlagItem *f = r_flag_get_at (core->flags, refi->addr, true);\n\t\t\t\t\tconst char *name = f ? f->name: \"\";\n\t\t\t\t\tif (pj) {\n\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\tpj_ks (pj, \"type\", r_anal_ref_type_tostring(refi->type));\n\t\t\t\t\t\tpj_kn (pj, \"at\", refi->at);\n\t\t\t\t\t\tpj_kn (pj, \"ref\", refi->addr);\n\t\t\t\t\t\tpj_ks (pj, \"name\", name);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s\\n\",\n\t\t\t\t\t\t\tr_anal_ref_type_tostring(refi->type), refi->at, refi->addr, name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRVecAnalRef_free (refs);\n\t\t\t\tif (pj) {\n\t\t\t\t\tpj_end (pj);\n\t\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot find any function\");\n\t\t\t}\n\t\t\tpj_free (pj);\n\t\t} else { // \"axf\"\n\t\t\tif (input[1] == '?') { // \"axf?\"\n\t\t\t\tr_core_cmd_help (core, help_msg_axf);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (input[1] == 'm') { // \"axfm\"\n\t\t\t\t// like aflm but reversed\n\t\t\t\taxfm (core);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRAnalOp asmop;\n\t\t\tchar *space = strchr (input, ' ');\n\t\t\tif (space) {\n\t\t\t\taddr = r_num_math (core->num, space + 1);\n\t\t\t\tif (core->num->nc.errors > 0) {\n\t\t\t\t\tR_LOG_ERROR (\"Invalid argument\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr = core->offset;\n\t\t\t}\n\t\t\tRAnalFunction * fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\tRVecAnalRef *list;\n\t\t\tif (input[1] == '.') { // \"axf.\"\n\t\t\t\tlist = r_anal_xrefs_get_from (core->anal, addr);\n\t\t\t\tif (!list) {\n\t\t\t\t\tlist = r_anal_function_get_refs (fcn);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlist = r_anal_refs_get (core->anal, addr);\n\t\t\t}\n\n\t\t\tif (list) {\n\t\t\t\tif (input[1] == 'q') { // \"axfq\"\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", ref->at);\n\t\t\t\t\t}\n\t\t\t\t} else if (input[1] == 'j') { // \"axfj\"\n\t\t\t\t\tPJ *pj = pj_new ();\n\t\t\t\t\tif (!pj) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tpj_a (pj);\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\t\t// TODO: Use r_core_anal_op(DISASM) instead of all those 4 lines\n\t\t\t\t\t\tut8 buf[16];\n\t\t\t\t\t\tr_io_read_at (core->io, ref->addr, buf, sizeof (buf));\n\t\t\t\t\t\tr_asm_set_pc (core->rasm, ref->addr);\n\t\t\t\t\t\tr_asm_disassemble (core->rasm, &asmop, buf, sizeof (buf));\n\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\tpj_kn (pj, \"from\", ref->at);\n\t\t\t\t\t\tpj_kn (pj, \"to\", ref->addr);\n\t\t\t\t\t\tpj_ks (pj, \"type\", r_anal_ref_type_tostring (ref->type));\n\t\t\t\t\t\tpj_ks (pj, \"perm\", r_anal_ref_perm_tostring (ref));\n\t\t\t\t\t\tpj_ks (pj, \"opcode\", r_asm_op_get_asm (&asmop));\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t}\n\t\t\t\t\tpj_end (pj);\n\t\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\t\tpj_free (pj);\n\t\t\t\t} else if (input[1] == '*') { // \"axf*\"\n\t\t\t\t\t// TODO: implement multi-line comments\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\t\tr_cons_printf (\"CCa 0x%\" PFMT64x \" \\\"XREF from 0x%u \\n\",\n\t\t\t\t\t\t\t\tref->at, ref->type);\n\t\t\t\t\t}\n\t\t\t\t} else { // \"axf\"\n\t\t\t\t\tchar str[512];\n\t\t\t\t\tint has_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tR_VEC_FOREACH (list, ref) {\n\t\t\t\t\t\tut8 buf[16] = {0};\n\t\t\t\t\t\tchar *desc;\n\t\t\t\t\t\tchar *desc_to_free = NULL;\n\t\t\t\t\t\tRFlagItem *flag = r_flag_get_at (core->flags, ref->addr, false);\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\tdesc = flag->name;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_io_read_at (core->io, ref->addr, buf, sizeof (buf));\n\t\t\t\t\t\t\tr_asm_set_pc (core->rasm, ref->addr);\n\t\t\t\t\t\t\tr_asm_disassemble (core->rasm, &asmop, buf, sizeof (buf));\n\t\t\t\t\t\t\tRAnalHint *hint = r_anal_hint_get (core->anal, ref->addr);\n\t\t\t\t\t\t\tr_parse_filter (core->parser, ref->addr, core->flags, hint, r_asm_op_get_asm (&asmop),\n\t\t\t\t\t\t\t\t\tstr, sizeof (str), be);\n\t\t\t\t\t\t\tr_anal_hint_free (hint);\n\t\t\t\t\t\t\tif (has_color) {\n\t\t\t\t\t\t\t\tdesc = desc_to_free = r_print_colorize_opcode (core->print, str,\n\t\t\t\t\t\t\t\t\t\tcore->cons->context->pal.reg, core->cons->context->pal.num, false, fcn ? fcn->addr : 0);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdesc = str;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_printf (\"%s 0x%\" PFMT64x \" %s\",\n\t\t\t\t\t\t\t\tr_anal_ref_type_tostring (ref->type), ref->addr, desc);\n\n\t\t\t\t\t\tif (R_ANAL_REF_TYPE_MASK (ref->type) == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\t\t\t\tRAnalOp aop;\n\t\t\t\t\t\t\tr_anal_op (core->anal, &aop, ref->addr, buf, sizeof (buf), R_ARCH_OP_MASK_BASIC);\n\t\t\t\t\t\t\tif (aop.type == R_ANAL_OP_TYPE_UCALL) {\n\t\t\t\t\t\t\t\tcmd_anal_ucall_ref (core, ref->addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t\tfree (desc_to_free);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (input[1] == 'j') { // \"axfj\"\n\t\t\t\t\tr_cons_print (\"[]\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tRVecAnalRef_free (list);\n\t\t}\n\t\tbreak;\n\tcase 'F': // \"axF\"\n\t\tfind_refs (core, input + 1);\n\t\tbreak;\n\tcase 'C': // \"axC\"\n\tcase 'c': // \"axc\"\n\tcase 'i': // \"axi\"\n\tcase 'r': // \"axr\"\n\tcase 'w': // \"axw\"\n\tcase 'j': // \"axj\"\n\tcase 'd': // \"axd\"\n\tcase 's': // \"axs\"\n\tcase ' ': // \"ax \"\n\t\tif (input[1] == '?') {\n\t\t\tchar *s = r_str_newf (\"ax%c\", input[0]);\n\t\t\tr_core_cmd_help_match (core, help_msg_ax, s, true);\n\t\t\tfree (s);\n\t\t} else {\n\t\t\tchar *ptr = strdup (r_str_trim_head_ro ((char *)input + 1));\n\t\t\tint n = r_str_word_set0 (ptr);\n\t\t\tut64 at = core->offset;\n\t\t\tut64 addr = UT64_MAX;\n\t\t\tRAnalRefType reftype = r_anal_xrefs_type (input[0]);\n\t\t\tswitch (n) {\n\t\t\tcase 2: // get at\n\t\t\t\tat = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t/* fall through */\n\t\t\tcase 1: // get addr\n\t\t\t\taddr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfree (ptr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_anal_xrefs_set (core->anal, at, addr, reftype);\n\t\t\tfree (ptr);\n\t\t}\n\t   \tbreak;\n\tdefault:\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_ax);\n\t\tbreak;\n\t}\n\n\treturn true;\n}\nstatic void cmd_anal_hint(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase '?':\n\t\tif (input[1]) {\n\t\t\tut64 addr = r_num_math (core->num, input + 1);\n\t\t\tr_core_anal_hint_print (core->anal, addr, 0);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ah);\n\t\t}\n\t\tbreak;\n\tcase '.': // \"ah.\"\n\t\tr_core_anal_hint_print (core->anal, core->offset, 0);\n\t\tbreak;\n\tcase 'a': // \"aha\" set arch\n\t\tif (input[1] == ' ') {\n\t\t\tchar *ptr = strdup (input + 2);\n\t\t\tr_str_word_set0 (ptr);\n\t\t\tconst char *arch = r_str_word_get0 (ptr, 0);\n\t\t\tr_anal_hint_set_arch (core->anal, core->offset, !arch || strcmp (arch, \"0\") == 0 ? NULL : arch);\n\t\t\tfree (ptr);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_arch (core->anal, core->offset);\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Missing argument\");\n\t\t}\n\t\tbreak;\n\tcase 'o': // \"aho\"\n\t\tif (input[1] == '*') {\n\t\t\t// show in r2\n\t\t\tRAnalHint *hint = r_anal_hint_get (core->anal, core->offset);\n\t\t\tif (hint && hint->opcode) {\n\t\t\t\tr_cons_printf (\"aho %s @ 0x%08\"PFMT64x\"\\n\", hint->opcode, hint->addr);\n\t\t\t}\n\t\t\tr_anal_hint_free (hint);\n\t\t} else if (input[1] == 0) {\n\t\t\t// show if any\n\t\t\tRAnalHint *hint = r_anal_hint_get (core->anal, core->offset);\n\t\t\tif (hint && hint->type > 0) {\n\t\t\t\tr_cons_printf (\"%s\\n\", r_anal_optype_tostring (hint->type));\n\t\t\t}\n\t\t\tr_anal_hint_free (hint);\n\t\t}  else if (input[1] == '-') {\n\t\t\tut64 off = input[2]? r_num_math (core->num, input + 2): core->offset;\n\t\t\tr_anal_hint_unset_bits (core->anal, off);\n\t\t} else if (input[1] == ' ') {\n\t\t\tconst char *arg = r_str_trim_head_ro (input + 1);\n\t\t\tconst int type = r_anal_optype_from_string (arg);\n\t\t\tif (type != -1) {\n\t\t\t\tr_anal_hint_set_type (core->anal, core->offset, type);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Unknown opcode type. Try: io, acmp, add, sync, call, cjmp, cmp, nop,,,\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_aho);\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"ahb\" set bits\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_ahb);\n\t\t} else if (input[1] == ' ') {\n\t\t\tchar *ptr = r_str_trim_dup (input + 2);\n\t\t\tint bits;\n\t\t\tint i = r_str_word_set0 (ptr);\n\t\t\tif (i == 2) {\n\t\t\t\tr_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t}\n\t\t\tbits = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\tr_anal_hint_set_bits (core->anal, core->offset, bits);\n\t\t\tfree (ptr);\n\t\t}  else if (input[1] == '-') {\n\t\t\tif (!strcmp (input + 2, \"*\")) {\n\t\t\t\tr_anal_hint_unset_bits (core->anal, UT64_MAX);\n\t\t\t} else {\n\t\t\t\tut64 off = input[2]? r_num_math (core->num, input + 2): core->offset;\n\t\t\t\tr_anal_hint_unset_bits (core->anal, off);\n\t\t\t}\n\t\t} else {\n\t\t\tRAnalHint *hint = r_anal_hint_get (core->anal, core->offset);\n\t\t\tif (hint && hint->bits) {\n\t\t\t\tr_cons_printf (\"%d\\n\", hint->bits);\n\t\t\t}\n\t\t\tr_anal_hint_free (hint);\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"ahi\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_ahi);\n\t\t\tbreak;\n\t\t}\n\t\tif (input[1] == '-') { // \"ahi-\"\n\t\t\tut64 addr = r_num_get (core->num, input + 2);\n\t\t\t// add ahi-*\n\t\t\tr_anal_hint_set_immbase (core->anal, addr? addr: core->offset, 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (isdigit ((unsigned char)input[1])) {\n\t\t\tr_anal_hint_set_nword (core->anal, core->offset, input[1] - '0');\n\t\t\tinput++;\n\t\t}\n\t\tif (input[1] == ' ') {\n\t\t\t// You can either specify immbase with letters, or numbers\n\t\t\tint base;\n\t\t\tif (r_str_startswith (input + 2, \"10u\") || r_str_startswith (input + 2, \"du\")) {\n\t\t\t\tbase = 11;\n\t\t\t} else {\n\t\t\t\tbase = (input[2] == 's') ? 1 :\n\t\t\t\t       (input[2] == 'b') ? 2 :\n\t\t\t\t       (input[2] == 'p') ? 3 :\n\t\t\t\t       (input[2] == 'o') ? 8 :\n\t\t\t\t       (input[2] == 'd') ? 10 :\n\t\t\t\t       (input[2] == 'h') ? 16 :\n\t\t\t\t       (input[2] == 'i') ? 32 : // ip address\n\t\t\t\t       (input[2] == '3') ? 36 : // base36\n\t\t\t\t       (input[2] == 'S') ? 80 : // syscall\n\t\t\t\t       (int) r_num_math (core->num, input + 1);\n\t\t\t}\n\t\t\tr_anal_hint_set_immbase (core->anal, core->offset, base);\n\t\t} else if (!input[1]) {\n\t\t\tRAnalHint *hint = r_anal_hint_get (core->anal, core->offset);\n\t\t\tif (hint && hint->immbase) {\n\t\t\t\tr_cons_printf (\"%d\\n\", hint->immbase);\n\t\t\t}\n\t\t\tr_anal_hint_free (hint);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ahi);\n\t\t}\n\t\tbreak;\n\tcase 'h': // \"ahh\"\n\t\tif (input[1] == '-') {\n\t\t\tr_anal_hint_unset_high (core->anal, core->offset);\n\t\t} else if (input[1] == ' ') {\n\t\t\tr_anal_hint_set_high (core->anal, r_num_math (core->num, input + 1));\n\t\t} else {\n\t\t\tr_anal_hint_set_high (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"ahc\"\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_jump (\n\t\t\t\tcore->anal, core->offset,\n\t\t\t\tr_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_jump (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"ahf\"\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_fail (\n\t\t\t\tcore->anal, core->offset,\n\t\t\t\tr_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_fail (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 'F': // \"ahF\" set stackframe size\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_stackframe (\n\t\t\t\tcore->anal, core->offset,\n\t\t\t\tr_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_stackframe (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 's': // \"ahs\" set size (opcode length)\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_size (core->anal, core->offset, atoi (input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tif (input[2] == '*') {\n\t\t\t\tR_LOG_INFO (\"Not implemented\");\n\t\t\t\t// R2_590 - take arg to specify type of hint to remove .. r_anal_hint_clear (core->anal, );\n\t\t\t\t// r_anal_hint_unset_size (core->anal, UT64_MAX);\n\t\t\t\t// r_anal_hint_clear (core->anal);\n\t\t\t} else if (input[2]) {\n\t\t\t\tut64 at = r_num_math (core->num, input + 2);\n\t\t\t\tif (at != UT64_MAX) {\n\t\t\t\t\tr_anal_hint_unset_size (core->anal, at);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_anal_hint_unset_size (core->anal, core->offset);\n\t\t\t}\n\t\t} else if (input[1] == 0) {\n\t\t\tr_core_cmd0 (core, \"ah~size=\");\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ahs);\n\t\t}\n\t\tbreak;\n\tcase 'S': // \"ahS\" set asm.syntax\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_syntax (core->anal, core->offset, input + 2);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_syntax (core->anal, core->offset);\n\t\t} else {\n\t\t\tr_core_cmd_help_match (core, help_msg_ah, \"ahS\", true);\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"ahd\" set opcode string\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_opcode (core->anal, core->offset, input + 2);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_opcode (core->anal, core->offset);\n\t\t} else {\n\t\t\tr_core_cmd_help_match (core, help_msg_ah, \"ahd\", true);\n\t\t}\n\t\tbreak;\n\tcase 'e': // \"ahe\" set ESIL string\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_esil (core->anal, core->offset, input + 2);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_esil (core->anal, core->offset);\n\t\t} else {\n\t\t\tr_core_cmd_help_match (core, help_msg_ah, \"ahe\", true);\n\t\t}\n\t\tbreak;\n#if 0\n\tcase 'e': // set endian\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_opcode (core->anal, core->offset, atoi (input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_opcode (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n#endif\n\tcase 'p': // \"ahp\"\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_pointer (core->anal, core->offset, r_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') { // \"ahp-\"\n\t\t\tr_anal_hint_unset_pointer (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"ahr\"\n\t\t// XXX isnt this the same as 'aho ret' ?\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_ret (core->anal, core->offset, r_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') { // \"ahr-\"\n\t\t\tr_anal_hint_unset_ret (core->anal, core->offset);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ahr);\n\t\t}\n\t\tbreak;\n\tcase '*': // \"ah*\"\n\tcase 'j': // \"ahj\"\n\tcase '\\0': // \"ah\"\n\t\tif (input[0] && input[1] == ' ') {\n\t\t\tchar *ptr = strdup (r_str_trim_head_ro (input + 2));\n\t\t\tr_str_word_set0 (ptr);\n\t\t\tut64 addr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\tr_core_anal_hint_print (core->anal, addr, input[0]);\n\t\t\tfree (ptr);\n\t\t} else {\n\t\t\tr_core_anal_hint_list (core->anal, input[0]);\n\t\t}\n\t\tbreak;\n\tcase 'v': // \"ahv\"\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_val (\n\t\t\t\tcore->anal, core->offset,\n\t\t\t\tr_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_val (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase '-': // \"ah-\"\n\t\tif (input[1]) {\n\t\t\tif (input[1] == '*') {\n\t\t\t\tr_anal_hint_clear (core->anal);\n\t\t\t} else {\n\t\t\t\tchar *ptr = strdup (r_str_trim_head_ro (input + 1));\n\t\t\t\tut64 addr;\n\t\t\t\tint size = 1;\n\t\t\t\tint i = r_str_word_set0 (ptr);\n\t\t\t\tif (i == 2) {\n\t\t\t\t\tsize = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t\t}\n\t\t\t\tconst char *a0 = r_str_word_get0 (ptr, 0);\n\t\t\t\tif (a0 && *a0) {\n\t\t\t\t\taddr = r_num_math (core->num, a0);\n\t\t\t\t} else {\n\t\t\t\t\taddr = core->offset;\n\t\t\t\t}\n\t\t\t\tr_anal_hint_del (core->anal, addr, size);\n\t\t\t\tfree (ptr);\n\t\t\t}\n\t\t} else {\n\t\t\tr_anal_hint_clear (core->anal);\n\t\t} break;\n\tcase 't': // \"aht\"\n\t\tswitch (input[1]) {\n\t\tcase 's': { // \"ahts\"\n\t\t\tchar *off = strdup (input + 2);\n\t\t\tr_str_trim (off);\n\t\t\tint toff = r_num_math (NULL, off);\n\t\t\tif (toff) {\n\t\t\t\tRList *typeoffs = r_type_get_by_offset (core->anal->sdb_types, toff);\n\t\t\t\tRListIter *iter;\n\t\t\t\tchar *ty;\n\t\t\t\tr_list_foreach (typeoffs, iter, ty) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", ty);\n\t\t\t\t}\n\t\t\t\tr_list_free (typeoffs);\n\t\t\t}\n\t\t\tfree (off);\n\t\t\tbreak;\n\t\t}\n\t\tcase ' ': {\n\t\t\t// r_anal_hint_set_opcode (core->anal, core->offset, input + 2);\n\t\t\tconst char *off = NULL;\n\t\t\tchar *type = strdup (r_str_trim_head_ro (input + 2));\n\t\t\tchar *idx = strchr (type, ' ');\n\t\t\tif (idx) {\n\t\t\t\t*idx++ = 0;\n\t\t\t\toff = idx;\n\t\t\t}\n\t\t\tchar *ptr = strchr (type, '=');\n\t\t\tut64 offimm = 0;\n\t\t\tut64 addr;\n\n\t\t\tif (ptr) {\n\t\t\t\t*ptr++ = 0;\n\t\t\t\tr_str_trim (ptr);\n\t\t\t\tif (ptr && *ptr) {\n\t\t\t\t\taddr = r_num_math (core->num, ptr);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"address is not valid\");\n\t\t\t\t\tfree (type);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr = core->offset;\n\t\t\t}\n\t\t\tr_str_trim (type);\n\t\t\tRAnalOp asmop;\n\t\t\tRAnalOp op = {0};\n\t\t\tut8 code[128] = {0};\n\t\t\t(void)r_io_read_at (core->io, core->offset, code, sizeof (code));\n\t\t\tr_asm_set_pc (core->rasm, addr);\n\t\t\t(void)r_asm_disassemble (core->rasm, &asmop, code, sizeof (code));\n\t\t\tint ret = r_anal_op (core->anal, &op, core->offset, code, sizeof (code), R_ARCH_OP_MASK_VAL);\n\t\t\tif (ret >= 0) {\n\t\t\t\t// HACK: Just convert only the first imm seen\n\t\t\t\tRAnalValue *src = NULL;\n\t\t\t\tr_vector_foreach (&op.srcs, src) {\n\t\t\t\t\tif (src) {\n\t\t\t\t\t\tif (src->imm) {\n\t\t\t\t\t\t\toffimm = src->imm;\n\t\t\t\t\t\t} else if (src->delta) {\n\t\t\t\t\t\t\toffimm = src->delta;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!offimm) {\n\t\t\t\t\tRAnalValue *dst = r_vector_at (&op.dsts, 0);\n\t\t\t\t\tif (dst) {\n\t\t\t\t\t\tif (dst->imm) {\n\t\t\t\t\t\t\toffimm = dst->imm;\n\t\t\t\t\t\t} else if (dst->delta) {\n\t\t\t\t\t\t\toffimm = dst->delta;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (offimm != 0) {\n\t\t\t\t\tif (off) {\n\t\t\t\t\t\toffimm += r_num_math (NULL, off);\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: Allow to select from multiple choices\n\t\t\t\t\tRList *otypes = r_type_get_by_offset (core->anal->sdb_types, offimm);\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tchar *otype = NULL;\n\t\t\t\t\tr_list_foreach (otypes, iter, otype) {\n\t\t\t\t\t\t// TODO: I don't think we should silently error, it is confusing\n\t\t\t\t\t\tif (!strcmp (type, otype)) {\n\t\t\t\t\t\t\t//eprintf (\"Adding type offset %s\\n\", type);\n\t\t\t\t\t\t\tr_type_link_offset (core->anal->sdb_types, type, addr);\n\t\t\t\t\t\t\tr_anal_hint_set_offset (core->anal, addr, otype);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!otype) {\n\t\t\t\t\t\tR_LOG_ERROR (\"wrong type for opcode offset\");\n\t\t\t\t\t}\n\t\t\t\t\tr_list_free (otypes);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_anal_op_fini (&op);\n\t\t\tfree (type);\n\t\t} break;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_aht);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void agraph_print_node_gml(RANode *n, void *user) {\n\tr_cons_printf (\"  node [\\n\"\n\t\t\"    id  %d\\n\"\n\t\t\"    label  \\\"%s\\\"\\n\"\n\t\t\"  ]\\n\", n->gnode->idx, n->title);\n}\n\nstatic void agraph_print_edge_gml(RANode *from, RANode *to, void *user) {\n\tr_cons_printf (\"  edge [\\n\"\n\t\t\"    source  %d\\n\"\n\t\t\"    target  %d\\n\"\n\t\t\"  ]\\n\", from->gnode->idx, to->gnode->idx\n\t\t);\n}\n\nstatic void agraph_print_node_dot(RANode *n, void *user) {\n\tif (R_STR_ISEMPTY (n->body)) {\n\t\tr_cons_printf (\"\\\"%s\\\" [URL=\\\"%s\\\", color=\\\"lightgray\\\", label=\\\"%s\\\"]\\n\",\n\t\t\t\tn->title, n->title, n->title);\n\t} else {\n\t\tchar *label = strdup (n->body);\n\t\t//label = r_str_replace (label, \"\\n\", \"\\\\l\", 1);\n\t\tr_cons_printf (\"\\\"%s\\\" [URL=\\\"%s\\\", color=\\\"lightgray\\\", label=\\\"%s\\\\n%s\\\"]\\n\",\n\t\t\t\tn->title, n->title, n->title, label);\n\t\tfree (label);\n\t}\n}\n\nstatic void agraph_print_node(RANode *n, void *user) {\n\tsize_t len = strlen (n->body);\n\n\tif (len > 0 && n->body[len - 1] == '\\n') {\n\t\tlen--;\n\t}\n\tchar *encbody = r_base64_encode_dyn (n->body, len);\n\tchar *cmd = r_str_newf (\"agn \\\"%s\\\" base64:%s\\n\", n->title, encbody);\n\tr_cons_print (cmd);\n\tfree (cmd);\n\tfree (encbody);\n}\n\nstatic char *getViewerPath(void) {\n\tint i;\n\tconst char *viewers[] = {\n#if R2__WINDOWS__\n\t\t\"explorer\",\n#else\n\t\t\"open\",\n\t\t\"geeqie\",\n\t\t\"gqview\",\n\t\t\"eog\",\n\t\t\"xdg-open\",\n#endif\n\t\tNULL\n\t};\n\tfor (i = 0; viewers[i]; i++) {\n\t\tchar *viewerPath = r_file_path (viewers[i]);\n\t\tif (viewerPath) {\n\t\t\treturn viewerPath;\n\t\t}\n\t\tfree (viewerPath);\n\t}\n\treturn NULL;\n}\n\nstatic char *dot_executable_path(void) {\n\tchar *dotPath = r_file_path (\"dot\");\n\tif (!dotPath) {\n\t\tdotPath = r_file_path (\"xdot\");\n\t}\n\treturn dotPath;\n}\n\nstatic bool convert_dot_to_image(RCore *core, const char *dot_file, const char *save_path) {\n\tchar *dot = dot_executable_path ();\n\tbool result = false;\n\tif (!dot) {\n\t\tR_LOG_ERROR (\"Graphviz not found in PATH\");\n\t\treturn false;\n\t}\n\tconst char *ext = r_config_get (core->config, \"graph.gv.format\");\n\n\tchar *cmd = NULL;\n\tif (save_path && *save_path) {\n\t\tcmd = r_str_newf (\"!%s -T%s -o%s a.dot;\", dot, ext, save_path);\n\t} else {\n\t\tchar *viewer = getViewerPath();\n\t\tif (viewer) {\n\t\t\tcmd = r_str_newf (\"!%s -T%s -oa.%s a.dot;!%s a.%s\",\n\t\t\t\tdot, ext, ext, viewer, ext);\n\t\t\tfree (viewer);\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find a valid picture viewer\");\n\t\t\tgoto end;\n\t\t}\n\t}\n\tr_core_cmd0 (core, cmd);\n\tresult = true;\nend:\n\tfree (cmd);\n\tfree (dot);\n\treturn result;\n}\n\nstatic bool convert_dotcmd_to_image(RCore *core, char *r2_cmd, const char *save_path) {\n\tif (save_path && *save_path) {\n\t\tr_cons_printf (\"Saving to file '%s'...\\n\", save_path);\n\t\tr_cons_flush ();\n\t}\n\tr_core_cmdf (core, \"%s > a.dot\", r2_cmd); // TODO: check error here\n\treturn convert_dot_to_image (core, \"a.dot\", save_path);\n}\n\nstatic bool convert_dot_str_to_image(RCore *core, char *str, const char *save_path) {\n\tif (save_path && *save_path) {\n\t\tr_cons_printf (\"Saving to file '%s'...\\n\", save_path);\n\t\tr_cons_flush ();\n\t}\n\tif (!r_file_dump (\"a.dot\", (const unsigned char *)str, -1, false)) {\n\t\treturn false;\n\t}\n\treturn convert_dot_to_image (core, \"a.dot\", save_path);\n}\n\nstatic void agraph_print_edge_dot(RANode *from, RANode *to, void *user) {\n\tRCore *core = (RCore *)user;\n\tut64 a = r_num_math (NULL, from->title);\n\tut64 b = r_num_math (NULL, to->title);\n\tr_strf_var (k, 64, \"agraph.edge.0x%\"PFMT64x\"_0x%\"PFMT64x\".highlight\", a, b);\n\tif (sdb_exists (core->sdb, k)) {\n\t\tr_cons_printf (\"\\\"%s\\\" -> \\\"%s\\\" [color=cyan]\\n\", from->title, to->title);\n\t} else {\n\t\tr_cons_printf (\"\\\"%s\\\" -> \\\"%s\\\"\\n\", from->title, to->title);\n\t}\n}\n\nstatic void agraph_print_edge(RANode *from, RANode *to, void *user) {\n\tr_cons_printf (\"age \\\"%s\\\" \\\"%s\\\"\\n\", from->title, to->title);\n}\n\nstatic void cmd_agraph_node(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase ' ': { // \"agn\"\n\t\tchar *newbody = NULL;\n\t\tchar *body;\n\t\tint n_args, B_LEN = strlen (\"base64:\");\n\t\tchar *color = NULL;\n\t\tinput++;\n\t\tchar **args = r_str_argv (input, &n_args);\n\t\tif (n_args < 1 || n_args > 3) {\n\t\t\tR_LOG_ERROR (\"wrong arguments for agn\");\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\t\t// strdup cause there is double free in r_str_argv_free due to a realloc call\n\t\tif (n_args > 1) {\n\t\t\tbody = strdup (args[1]);\n\t\t\tif (strncmp (body, \"base64:\", B_LEN) == 0) {\n\t\t\t\tif (body[B_LEN]) {\n\t\t\t\t\tbody = r_str_replace (body, \"\\\\n\", \"\", true);\n\t\t\t\t\tnewbody = (char *)r_base64_decode_dyn (body + B_LEN, -1);\n\t\t\t\t\tif (!newbody) {\n\t\t\t\t\t\tR_LOG_ERROR (\"Invalid base64 string in agn (%s)\", body+B_LEN);\n\t\t\t\t\t\tr_str_argv_free (args);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree (body);\n\t\t\t\t\tbody = newbody;\n\t\t\t\t} else {\n\t\t\t\t\tfree (body);\n\t\t\t\t\tbody = strdup (\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbody = r_str_append (body, \"\\n\");\n\t\t\tif (n_args > 2) {\n\t\t\t\tRColor kolor = {0};\n\t\t\t\t(void)r_cons_pal_parse (args[2], &kolor);\n\t\t\t\tcolor = r_cons_rgb_str (NULL, -1, &kolor);\n\t\t\t}\n\t\t} else {\n\t\t\tbody = strdup (\"\");\n\t\t}\n\t\tr_agraph_add_node (core->graph, args[0], body, color);\n\t\tr_str_argv_free (args);\n\t\tfree (body);\n\t\tfree (color);\n\t\t// free newbody it's not necessary since r_str_append reallocate the space\n\t\tbreak;\n\t}\n\tcase '-': { // \"agn-\"\n\t\tinput++;\n\t\tint n_args;\n\t\tchar **args = r_str_argv (input, &n_args);\n\t\tif (n_args != 1) {\n\t\t\tR_LOG_ERROR (\"Wrong arguments\");\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\t\tr_agraph_del_node (core->graph, args[0]);\n\t\tr_str_argv_free (args);\n\t\tbreak;\n\t}\n\tcase '?':\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_agn);\n\t\tbreak;\n\t}\n}\n\nstatic bool cmd_ageh(RCore *core, const char *input) {\n\tif (!*input) {\n\t\tr_core_cmd0 (core, \"k~agraph.edge\");\n\t\treturn false;\n\t}\n\tbool add = true;\n\tif (*input == '-') {\n\t\tadd = false;\n\t\tinput++;\n\t}\n\tchar *arg = r_str_trim_dup (input + 1);\n\tchar *sp = strchr (arg, ' ');\n\tif (!sp) {\n\t\tfree (arg);\n\t\treturn false;\n\t}\n\t*sp++ = 0;\n\tut64 a = r_num_math (core->num, arg);\n\tut64 b = r_num_math (core->num, sp);\n\n\tr_strf_var (k, 64, \"agraph.edge.0x%\"PFMT64x\"_0x%\"PFMT64x\".highlight\", a, b);\n\tsdb_set (core->sdb, k, add? \"true\": \"\", 0);\n\tfree (arg);\n\treturn true;\n}\n\nstatic void cmd_agraph_edge(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase ' ': // \"age\"\n\tcase '-': { // \"age-\"\n\t\tRANode *u, *v;\n\t\tchar **args;\n\t\tint n_args;\n\n\t\targs = r_str_argv (input + 1, &n_args);\n\t\tif (n_args != 2) {\n\t\t\tr_cons_printf (\"Wrong arguments\\n\");\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\n\t\tu = r_agraph_get_node (core->graph, args[0]);\n\t\tv = r_agraph_get_node (core->graph, args[1]);\n\t\tif (!u || !v) {\n\t\t\tconst char *arg = args[u? 1: 0];\n\t\t\tr_cons_printf (\"Node %s not found!\\n\", arg);\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\t\tif (*input == ' ') {\n\t\t\tr_agraph_add_edge (core->graph, u, v, false);\n\t\t} else {\n\t\t\tr_agraph_del_edge (core->graph, u, v);\n\t\t}\n\t\tr_str_argv_free (args);\n\t\tbreak;\n\t}\n\tcase 'h':\n\t\tcmd_ageh (core, input + 1);\n\t\tbreak;\n\tcase '?':\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_age);\n\t\tbreak;\n\t}\n}\n\nR_API void cmd_agfb(RCore *core) {\n\tconst int c = r_config_get_b (core->config, \"scr.color\");\n\tr_config_set_i (core->config, \"scr.color\", 0);\n\tr_cons_push ();\n\tr_core_visual_graph (core, NULL, NULL, false);\n\tr_config_set_i (core->config, \"scr.color\", c);\n\tchar *s = strdup (r_cons_singleton()->context->buffer);\n\tr_cons_pop ();\n\tcmd_agfb2 (core, s);\n\tfree (s);\n}\n\nR_API void cmd_aggb(RCore *core) {\n\tconst int c = r_config_get_b (core->config, \"scr.color\");\n\tr_config_set_i (core->config, \"scr.color\", 0);\n\tr_cons_push ();\n\tint ograph_zoom = r_config_get_i (core->config, \"graph.zoom\");\n\tr_config_set_i (core->config, \"graph.zoom\", 1);\n\tr_core_cmd_call (core, \"agg\");\n\tr_config_set_i (core->config, \"scr.color\", c);\n\tchar *s = strdup (r_cons_singleton()->context->buffer);\n\tr_cons_pop ();\n\tcmd_agfb2 (core, s);\n\tr_config_set_i (core->config, \"graph.zoom\", ograph_zoom);\n\tfree (s);\n}\n\nR_API void cmd_agfb3(RCore *core, const char *s, int x, int y) {\n\tint h, w = r_str_size (s, &h);\n\tRConsPixel *p = r_cons_pixel_new (w, h);\n\tr_cons_pixel_sets (p, 0, 0, s);\n\tr_cons_pixel_flush (p, x, y);\n\tR_FREE (p);\n}\n\nR_API void cmd_agfb2(RCore *core, const char *s) {\n\tint h, w = r_str_size (s, &h);\n\tRConsPixel *p = r_cons_pixel_new (w, h);\n\tr_cons_pixel_sets (p, 0, 0, s);\n\tchar *pix = r_cons_pixel_drain (p);\n\tr_cons_printf (\"%s\\n\", pix);\n\tfree (pix);\n}\n\n\nstatic char *mermaid_sanitize_str(const char *str) {\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tsize_t len = strlen (str) * 4 + 1; // '\\n' -> \"\\x0a\"\n\tchar *buf = malloc (len);\n\tif (buf) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < len - 5 && *str;) {\n\t\t\tchar c = *str++;\n\t\t\tif (c < ' ' || c > '~' || c == '\\\\' || c == '\"' || c == '<') {\n\t\t\t\tsnprintf (buf + i, 5, \"\\\\x%02x\", c); // 5 b/c null byte\n\t\t\t\ti += 4;\n\t\t\t} else {\n\t\t\t\tbuf[i++] = c;\n\t\t\t}\n\t\t}\n\t\tbuf[i] = '\\0';\n\t}\n\t// buffer wont live long enough to merit a realloc\n\treturn buf;\n}\n\nstatic inline char *mermaid_title_body_node_str(const char *title, const char *body) {\n\tchar *t = mermaid_sanitize_str (title);\n\tchar *b = mermaid_sanitize_str (body);\n\tif (t && b) {\n\t\tchar *ret = r_str_newf (\"[%s]\\\\n%s\", t, b);\n\t\tfree (t);\n\t\tfree (b);\n\t\treturn ret;\n\t}\n\treturn t? t: b;\n}\n\nstatic char *mermaid_anod_body(RGraphNode *n) {\n\tRANode *an = (RANode *)n->data;\n\treturn mermaid_title_body_node_str (an->title, an->body);\n}\n\nstatic char *mermaid_nodeinfo_body(RGraphNode *n) {\n\tRGraphNodeInfo *nfo = (RGraphNodeInfo *)n->data;\n\treturn mermaid_title_body_node_str (nfo->title, nfo->body);\n}\n\ntypedef char *(*node_content_cb) (RGraphNode *);\nstatic void mermaid_graph(RGraph *graph, node_content_cb get_body) {\n\tif (!graph) {\n\t\treturn;\n\t}\n\tif (r_list_empty (graph->nodes)) {\n\t\tR_LOG_INFO (\"The graph is empty\");\n\t\treturn;\n\t}\n\tbool printit = true;\n\tRStrBuf *nodes = r_strbuf_new (\"stateDiagram-v2\\n\");\n\tRStrBuf *edges = r_strbuf_new (\"\");\n\tRGraphNode *n;\n\tRListIter *it;\n\tr_list_foreach (graph->nodes, it, n) {\n\t\tchar *free_body = get_body (n);\n\t\tchar *body = free_body? free_body: \"\";\n\t\tprintit &= r_strbuf_appendf (nodes, \"  state \\\"%s\\\" as node_%u\\n\", body, n->idx);\n\t\tfree (free_body);\n\n\t\t// edgdes\n\t\tRGraphNode *nxt;\n\t\tRListIter *itt;\n\t\tr_list_foreach (n->out_nodes, itt, nxt) {\n\t\t\tprintit &= r_strbuf_appendf (edges, \"  node_%u --> node_%u\\n\", n->idx, nxt->idx);\n\t\t}\n\t\tif (!printit) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (printit) {\n\t\tchar *n = r_strbuf_drain_nofree (nodes);\n\t\tchar *e = r_strbuf_drain_nofree (edges);\n\t\tif (n && e) {\n\t\t\tr_cons_print (n);\n\t\t\tr_cons_print (e);\n\t\t}\n\t\tfree (n);\n\t\tfree (e);\n\t}\n\tr_strbuf_free (nodes);\n\tr_strbuf_free (edges);\n}\n\ntypedef struct {\n\tRAnalFunction *fcn;\n\tchar *name;\n\tut64 addr;\n\tint size;\n\tint x;\n\tint y;\n\tint w;\n\tint h;\n} TreeMapItem;\n\nstatic void *add_item(RAnalFunction *f, const char *name, ut64 addr, ut64 size) {\n\tTreeMapItem *item = R_NEW0 (TreeMapItem);\n\titem->fcn = f;\n\titem->addr = addr;\n\titem->name = strdup (name);\n\titem->size = size;\n\treturn item;\n}\n\nstatic void free_item(void *a) {\n\tTreeMapItem *item = a;\n\tif (item) {\n\t\tfree (item->name);\n\t\tfree (item);\n\t}\n}\n\nstatic int bysize(const void *_a, const void *_b) {\n\tconst TreeMapItem *a = _a;\n\tconst TreeMapItem *b = _b;\n\treturn b->size - a->size;\n}\n\nstatic void treemap_layout(RConsCanvas *canvas, RList *maps) {\n\tRListIter *iter;\n\tTreeMapItem *mi;\n\tint i = 0;\n\tint n = r_list_length (maps);\n\tif (n == 0) {\n\t\treturn;\n\t}\n\tint nx = 0;\n\tint ny = 0;\n\tint nw = canvas->w;\n\tint nh = canvas->h;\n\tfloat mfact = 0.33;\n\tbool s = true; // layout\n\n\tr_list_sort (maps, bysize);\n\tr_list_foreach (maps, iter, mi) {\n\t\tif ((i % 2 && nh / 2 > 2 * mi->w) || (!(i % 2) && nw / 2 > 2 * mi->w)) {\n\t\t\tconst int imodfour = (i % 4);\n\t\t\tif (i < n - 1) {\n\t\t\t\tif (i % 2) {\n\t\t\t\t\tnh /= 2;\n\t\t\t\t} else {\n\t\t\t\t\tnw /= 2;\n\t\t\t\t}\n\t\t\t\tif (!s) {\n\t\t\t\t\tif (imodfour == 2) {\n\t\t\t\t\t\tnx += nw;\n\t\t\t\t\t} else if (imodfour == 3) {\n\t\t\t\t\t\tny += nh;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (imodfour) {\n\t\t\tcase 0:\n\t\t\t\tny += s? nh: -nh;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnx += nw;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tny += nh;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tnx += s? nw: -nw;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tif (n != 1) {\n\t\t\t\t\tnw = (int)(canvas->w * mfact);\n\t\t\t\t}\n\t\t\t\tny = 0;\n\t\t\t} else if (i == 1) {\n\t\t\t\tnw = canvas->w - nw;\n\t\t\t\tnx--;\n\t\t\t} else if (i == 2) {\n\t\t\t\tnh++;\n\t\t\t\t// ny--;\n\t\t\t}\n\t\t\tif (2== (i%4)) {\n\t\t\t\tnh++;\n\t\t\t\t// nw--;\n\t\t\t\tny--;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tmi->x = nx;\n\t\tmi->y = ny;\n\t\tmi->w = nw;\n\t\tmi->h = nh;\n\t}\n}\n\nR_API void r_core_agraph_treemap(RCore *core, int use_utf, const char *input) {\n\tint a = r_config_get_i (core->config, \"scr.color\");\n\tr_config_set_i (core->config, \"scr.color\", 0);\n\t// walk all the functions and create a treemap and render it\n\tint h, w = r_cons_get_size (&h);\n\tw--;\n\th--;\n\tRConsCanvas *canvas = r_cons_canvas_new (w, h);\n\tr_cons_canvas_box (canvas, 1, 1, w - 1, h - 1, \"\");\n\tRListIter *iter;\n\tRAnalFunction *fcn = NULL;\n\tRList *maps = r_list_newf (free_item);\n#if 1\n\tRList *list = r_anal_get_fcns (core->anal);\n\tr_list_foreach (list, iter, fcn) {\n\t\tut64 fsz = r_anal_function_realsize (fcn);\n\t\tr_list_append (maps, add_item (fcn, fcn->name, fcn->addr, fsz));\n\t}\n#else\n\tRAnalBlock *bb;\n\tif (!fcn) {\n\t\tfcn = r_anal_get_function_at (core->anal, core->offset);\n\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\tchar *name = r_str_newf (\"%d\", (int)(size_t)(bb->addr - fcn->addr));\n\t\t\tr_list_append (maps, add_item (fcn, name, bb->addr, bb->size));\n\t\t\tfree (name);\n\t\t}\n\t}\n#endif\n\ttreemap_layout (canvas, maps);\n\tTreeMapItem *mi;\n\tr_list_foreach (maps, iter, mi) {\n\t\t// char *s = r_core_cmd_strf (core, \"pdb@0x%\"PFMT64x\"@e:asm.byte=0@e:asm.bytes=0\", mi->addr);\n\t\tchar *s = r_core_cmd_strf (core, \"pid@0x%\"PFMT64x\"@e:asm.bytes=0\", mi->addr);\n\t\tif (mi->w > 4 && mi->h > 3) {\n\t\t\tchar *ns = r_str_crop (s, 0, 0, mi->w * 2, mi->h - 2);\n\t\t\tif (r_cons_canvas_gotoxy (canvas, mi->x + 2, mi->y + 2)) {\n\t\t\t\tr_cons_canvas_write (canvas, ns);\n\t\t\t}\n\t\t\tfree (ns);\n\t\t}\n\t\tfree (s);\n\t}\n\tr_list_foreach (maps, iter, mi) {\n\t\tif (r_cons_canvas_gotoxy (canvas, mi->x + 2, mi->y + 1)) {\n\t\t\tr_cons_canvas_write (canvas, mi->name);\n\t\t\tr_cons_canvas_box (canvas, mi->x, mi->y, mi->w, mi->h, \"\");\n\t\t}\n\t}\n\tchar *s = r_cons_canvas_tostring (canvas);\n\tif (s) {\n\t\tr_cons_println (s);\n\t\tfree (s);\n\t}\n\tr_list_free (maps);\n\tr_config_set_i (core->config, \"scr.color\", a);\n\tr_cons_canvas_free (canvas);\n}\n\nR_API void r_core_agraph_print(RCore *core, int use_utf, const char *input) {\n\tif (use_utf != -1) {\n\t\tr_config_set_i (core->config, \"scr.utf8\", use_utf);\n\t}\n\tswitch (*input) {\n\tcase 0:\n\t\tcore->graph->can->linemode = r_config_get_i (core->config, \"graph.linemode\");\n\t\tcore->graph->can->color = r_config_get_i (core->config, \"scr.color\");\n\t\tr_agraph_set_title (core->graph, r_config_get (core->config, \"graph.title\"));\n\t\tr_agraph_print (core->graph);\n\t\tbreak;\n\tcase 't': { // \"aggt\" - tiny graph\n\t\tcore->graph->is_tiny = true;\n\t\tint e = r_config_get_i (core->config, \"graph.edges\");\n\t\tr_config_set_i (core->config, \"graph.edges\", 0);\n\t\tr_core_visual_graph (core, core->graph, NULL, false);\n\t\tr_config_set_i (core->config, \"graph.edges\", e);\n\t\tcore->graph->is_tiny = false;\n\t\tbreak;\n\t}\n\tcase 'b': // \"aggb\"\n\t\tcmd_aggb (core);\n\t\tbreak;\n\tcase 'm': // \"aggm\"\n\t\tif (core->graph) {\n\t\t\tmermaid_graph (core->graph->graph, mermaid_anod_body);\n\t\t}\n\t\tbreak;\n\tcase 'k': // \"aggk\"\n\t{\n\t\tSdb *db = r_agraph_get_sdb (core->graph);\n\t\tif (db) {\n\t\t\tchar *o = sdb_querys (db, \"null\", 0, \"*\");\n\t\t\tif (o) {\n\t\t\t\tr_cons_print (o);\n\t\t\t\tfree (o);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'v': // \"aggv\" - open current core->graph in interactive visual mode\n\t{\n\t\tRANode *ran = r_agraph_get_first_node (core->graph);\n\t\tif (ran) {\n\t\t\tut64 oseek = core->offset;\n\t\t\tr_agraph_set_title (core->graph, r_config_get (core->config, \"graph.title\"));\n\t\t\tr_agraph_set_curnode (core->graph, ran);\n\t\t\tcore->graph->force_update_seek = true;\n\t\t\tcore->graph->need_set_layout = true;\n\t\t\tcore->graph->is_handmade = true;\n\t\t\tcore->graph->layout = r_config_get_i (core->config, \"graph.layout\");\n\t\t\tbool ov = r_cons_is_interactive ();\n\t\t\tcore->graph->need_update_dim = true;\n\t\t\tint update_seek = r_core_visual_graph (core, core->graph, NULL, true);\n\t\t\tr_config_set_b (core->config, \"scr.interactive\", ov);\n\t\t\tr_cons_show_cursor (true);\n\t\t\tcore->graph->is_handmade = false;\n\t\t\tr_cons_enable_mouse (false);\n\t\t\tif (update_seek != -1) {\n\t\t\t\tr_core_seek (core, oseek, false);\n\t\t\t}\n\t\t} else {\n\t\t\tR_LOG_INFO (\"This graph contains no nodes\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'd': { // \"aggd\" - dot format\n\t\tconst char *font = r_config_get (core->config, \"graph.font\");\n\t\tr_cons_printf (\"digraph code {\\nrankdir=LR;\\noutputorder=edgesfirst\\ngraph [bgcolor=azure];\\n\"\n\t\t\t\"edge [arrowhead=normal, color=\\\"#3030c0\\\" style=bold weight=2];\\n\"\n\t\t\t\"node [fillcolor=white, style=filled shape=box \"\n\t\t\t\"fontname=\\\"%s\\\" fontsize=\\\"8\\\"];\\n\",\n\t\t\tfont);\n\t\tr_agraph_foreach (core->graph, agraph_print_node_dot, core);\n\t\tr_agraph_foreach_edge (core->graph, agraph_print_edge_dot, core);\n\t\tr_cons_printf (\"}\\n\");\n\t\tbreak;\n\t}\n\tcase '*': // \"agg*\" -\n\t\tr_agraph_foreach (core->graph, agraph_print_node, core);\n\t\tr_agraph_foreach_edge (core->graph, agraph_print_edge, core);\n\t\tbreak;\n\tcase 'J':\n\tcase 'j': {\n\t\tPJ *pj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_o (pj);\n\t\tpj_k (pj, \"nodes\");\n\t\tpj_a (pj);\n\t\tr_agraph_print_json (core->graph, pj);\n\t\tpj_end (pj);\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\tbreak;\n\t\t}\n\tcase 'g':\n\t\tr_cons_printf (\"graph\\n[\\n\"\n\t\t\t       \"hierarchic 1\\n\"\n\t\t\t       \"label \\\"\\\"\\n\"\n\t\t\t       \"directed 1\\n\");\n\t\tr_agraph_foreach (core->graph, agraph_print_node_gml, NULL);\n\t\tr_agraph_foreach_edge (core->graph, agraph_print_edge_gml, NULL);\n\t\tr_cons_print (\"]\\n\");\n\t\tbreak;\n\tcase 'w': // \"aggw\"\n\t\t{\n\t\t\tconst char *filename = r_str_trim_head_ro (input + 1);\n\t\t\tconvert_dotcmd_to_image (core, \"aggd\", filename);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ag);\n\t\tbreak;\n\t}\n}\n\nstatic void print_graph_agg(RGraph /*RGraphNodeInfo*/ *graph) {\n\tRGraphNodeInfo *print_node;\n\tRGraphNode *node, *target;\n\tRListIter *it, *edge_it;\n\tr_list_foreach (graph->nodes, it, node) {\n\t\tchar *encbody;\n\t\tint len;\n\t\tprint_node = node->data;\n\t\tif (R_STR_ISNOTEMPTY (print_node->body)) {\n\t\t\tlen = strlen (print_node->body);\n\n\t\t\tif (len > 0 && print_node->body[len - 1] == '\\n') {\n\t\t\t\tlen--;\n\t\t\t}\n\t\t\tencbody = r_base64_encode_dyn (print_node->body, len);\n\t\t\tr_cons_printf (\"agn \\\"%s\\\" base64:%s\\n\", print_node->title, encbody);\n\t\t\tfree (encbody);\n\t\t} else {\n\t\t\tr_cons_printf (\"agn \\\"%s\\\"\\n\", print_node->title);\n\t\t}\n\t}\n\tr_list_foreach (graph->nodes, it, node) {\n\t\tprint_node = node->data;\n\t\tr_list_foreach (node->out_nodes, edge_it, target) {\n\t\t\tRGraphNodeInfo *to = target->data;\n\t\t\tr_cons_printf (\"age \\\"%s\\\" \\\"%s\\\"\\n\", print_node->title, to->title);\n\t\t}\n\t}\n}\n\nstatic char *print_graph_dot(RCore *core, RGraph /*<RGraphNodeInfo>*/ *graph) {\n\tconst char *font = r_config_get (core->config, \"graph.font\");\n\tchar *node_properties = r_str_newf (\"fontname=\\\"%s\\\"\", font);\n\tchar *result = r_graph_drawable_to_dot (graph, node_properties, NULL);\n\tfree (node_properties);\n\treturn result;\n}\n\nstatic char *_graph_node_info_get_title(void *data) {\n\tRGraphNodeInfo *info = (RGraphNodeInfo *)data;\n\treturn (info && info->title)? strdup (info->title): NULL;\n}\n\nstatic char *_graph_node_info_get_body(void *data) {\n\tRGraphNodeInfo *info = (RGraphNodeInfo *)data;\n\treturn (info && info->body)? strdup (info->body): NULL;\n}\n\nstatic void r_core_graph_print(RCore *core, RGraph /*<RGraphNodeInfo>*/ *graph, int use_utf, bool use_offset, const char *input) {\n\tRAGraph *agraph = NULL;\n\tRListIter *it;\n\tRListIter *edge_it;\n\tRGraphNode *graphNode, *target;\n\tRGraphNodeInfo *print_node;\n\tif (use_utf != -1) {\n\t\tr_config_set_b (core->config, \"scr.utf8\", use_utf);\n\t}\n\tswitch (*input) {\n\tcase 0:\n\tcase 't':\n\tcase 'k':\n\tcase 'v':\n\tcase 'i': {\n\t\tRAGraphTransitionCBs cbs = {\n\t\t\t.get_title = _graph_node_info_get_title,\n\t\t\t.get_body = _graph_node_info_get_body\n\t\t};\n\t\tagraph = r_agraph_new_from_graph (graph, &cbs);\n\t\tswitch (*input) {\n\t\tcase 0:\n\t\t\tagraph->can->linemode = r_config_get_i (core->config, \"graph.linemode\");\n\t\t\tagraph->can->color = r_config_get_i (core->config, \"scr.color\");\n\t\t\tr_agraph_set_title (agraph,\n\t\t\t\tr_config_get (core->config, \"graph.title\"));\n\t\t\tr_agraph_print (agraph);\n\t\t\tbreak;\n\t\tcase 't': { // \"ag_t\" - tiny graph\n\t\t\tagraph->is_tiny = true;\n\t\t\tint e = r_config_get_i (core->config, \"graph.edges\");\n\t\t\tr_config_set_i (core->config, \"graph.edges\", 0);\n\t\t\tr_core_visual_graph (core, agraph, NULL, false);\n\t\t\tr_config_set_i (core->config, \"graph.edges\", e);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'k': // \"ag_k\"\n\t\t{\n\t\t\tSdb *db = r_agraph_get_sdb (agraph);\n\t\t\tchar *o = sdb_querys (db, \"null\", 0, \"*\");\n\t\t\tr_cons_print (o);\n\t\t\tfree (o);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'v': // \"ag_v\"\n\t\tcase 'i': // \"ag_i\" - open current core->graph in interactive mode\n\t\t{\n\t\t\tRANode *ran = r_agraph_get_first_node (agraph);\n\t\t\tif (ran) {\n\t\t\t\tut64 oseek = core->offset;\n\t\t\t\tr_agraph_set_title (agraph, r_config_get (core->config, \"graph.title\"));\n\t\t\t\tr_agraph_set_curnode (agraph, ran);\n\t\t\t\tagraph->force_update_seek = true;\n\t\t\t\tagraph->need_set_layout = true;\n\t\t\t\tagraph->layout = r_config_get_i (core->config, \"graph.layout\");\n\t\t\t\tbool ov = r_cons_is_interactive ();\n\t\t\t\tagraph->need_update_dim = true;\n\t\t\t\tint update_seek = r_core_visual_graph (core, agraph, NULL, true);\n\t\t\t\tr_config_set_b (core->config, \"scr.interactive\", ov);\n\t\t\t\tr_cons_show_cursor (true);\n\t\t\t\tr_cons_enable_mouse (false);\n\t\t\t\tif (update_seek != -1) {\n\t\t\t\t\tr_core_seek (core, oseek, false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_INFO (\"This graph contains no nodes\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'd': { // \"ag_d\" - dot format\n\t\tchar *dot_text = print_graph_dot (core, graph);\n\t\tif (dot_text) {\n\t\t\tr_cons_print (dot_text);\n\t\t\tfree (dot_text);\n\t\t}\n\t\tbreak;\n\t}\n\tcase '*': // \"ag_*\" -\n\t\tprint_graph_agg (graph);\n\t\tbreak;\n\tcase 'J':\n\tcase 'j': {\n\t\tPJ *pj = pj_new ();\n\t\tif (pj) {\n\t\t\tr_graph_drawable_to_json (graph, pj, use_offset);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t}\n\t} break;\n\tcase 'g':\n\t\tr_cons_printf (\"graph\\n[\\n\"\n\t\t\t       \"hierarchic 1\\n\"\n\t\t\t       \"label \\\"\\\"\\n\"\n\t\t\t       \"directed 1\\n\");\n\t\tr_list_foreach (graph->nodes, it, graphNode) {\n\t\t\tprint_node = graphNode->data;\n\t\t\tr_cons_printf (\"  node [\\n\"\n\t\t\t\t       \"    id  %d\\n\"\n\t\t\t\t       \"    label  \\\"%s\\\"\\n\"\n\t\t\t\t       \"  ]\\n\",\n\t\t\t\tgraphNode->idx, print_node->title);\n\t\t}\n\t\tr_list_foreach (graph->nodes, it, graphNode) {\n\t\t\tprint_node = graphNode->data;\n\t\t\tr_list_foreach (graphNode->out_nodes, edge_it, target) {\n\t\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\t       \"    source  %d\\n\"\n\t\t\t\t\t       \"    target  %d\\n\"\n\t\t\t\t\t       \"  ]\\n\",\n\t\t\t\t\tgraphNode->idx, target->idx);\n\t\t\t}\n\t\t}\n\t\tr_cons_print (\"]\\n\");\n\t\tbreak;\n\tcase 'w': { // \"ag_w\"\n\t\tconst char *filename = r_str_trim_head_ro (input + 1);\n\t\tchar *dot_text = print_graph_dot (core, graph);\n\t\tif (dot_text) {\n\t\t\tconvert_dot_str_to_image (core, dot_text, filename);\n\t\t\tfree (dot_text);\n\t\t}\n\t\tbreak;\n\t\t}\n\tcase 'm':\n\t\tmermaid_graph (graph, mermaid_nodeinfo_body);\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ag);\n\t\tbreak;\n\t}\n}\n\nstatic inline bool mermaid_add_node_asm(RAnal *a, RAnalBlock *bb, RStrBuf *nodes) {\n\tut8 *bb_buf = calloc (1, bb->size);\n\tif (!bb_buf) {\n\t\treturn false;\n\t}\n\tif (!a->iob.read_at (a->iob.io, bb->addr, (ut8 *)bb_buf, bb->size)) {\n\t\treturn false;\n\t}\n\tRAnalOpMask mask = R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_DISASM | R_ANAL_OP_HINT_MASK;\n\tRAnalOp op = {0};\n\n\t// escaped newline to get out of title line\n\tbool ret = r_strbuf_append (nodes, \"\\\\n\");\n\tint i;\n\tfor (i = 0; i < bb->ninstr; i++) {\n\t\tconst ut64 prev_pos = r_anal_bb_offset_inst (bb, i);\n\t\tconst ut64 op_addr = r_anal_bb_opaddr_i (bb, i);\n\t\tif (prev_pos >= bb->size) {\n\t\t\tcontinue;\n\t\t}\n\t\tint buflen = bb->size - prev_pos;\n\t\tut8 *loc = bb_buf + prev_pos;\n\t\tif (r_anal_op (a, &op, op_addr, loc, buflen, mask) > 0) {\n\t\t\tret &= r_strbuf_appendf (nodes, \"%s\\\\n\", op.mnemonic);\n\t\t} else {\n\t\t\tret &= r_strbuf_append (nodes, \"...\\\\n\");\n\t\t}\n\t\tif (!ret) {\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_op_fini (&op);\n\t}\n\tfree (bb_buf);\n\treturn ret;\n}\n\nstatic inline bool fcn_siwtch_mermaid(RAnalBlock *b, RStrBuf *buf) {\n\tif (b->switch_op) {\n\t\tr_return_val_if_fail (b->switch_op->cases, false);\n\t\tRListIter *itt;\n\t\tRAnalCaseOp *c;\n\t\tr_list_foreach (b->switch_op->cases, itt, c) {\n\t\t\tif (!r_strbuf_appendf (buf, \"  _0x%\" PFMT64x \" --> _0x%\" PFMT64x \": Case %\" PFMT64d \"\\n\", b->addr, c->addr, c->value)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool cmd_graph_mermaid(RCore *core, bool add_asm) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\tif (!fcn || !fcn->bbs) {\n\t\treturn false;\n\t}\n\n\tbool ret = true;\n\n\t// for info on mermaid syntax: https://mermaid-js.github.io/mermaid/#/stateDiagram\n\tRStrBuf *nodes = r_strbuf_new (\"stateDiagram-v2\\n\");\n\tRStrBuf *edges = r_strbuf_new (\"\");\n\n\t// TODO: add themeing to nodes buff here -> https://mermaid-js.github.io/mermaid/#/theming\n\n\tRAnalBlock *b;\n\tRListIter *iter;\n\n\tr_list_sort (fcn->bbs, bb_cmp);\n\tr_list_foreach (fcn->bbs, iter, b) {\n\t\tret &= r_strbuf_appendf (nodes, \"  state \\\"[0x%\" PFMT64x \"]\", b->addr);\n\t\tif (b->addr == fcn->addr) {\n\t\t\tret &= r_strbuf_appendf (nodes, \" %s\", fcn->name);\n\t\t}\n\t\tif (add_asm) {\n\t\t\tret &= mermaid_add_node_asm (core->anal, b, nodes);\n\t\t}\n\t\t// ending of nodes string `... \" as _0xfffff`\n\t\t// node names start with _0x b/c 0x makes mermaids mad somehow\n\t\tret &= r_strbuf_appendf (nodes, \"\\\" as _0x%\" PFMT64x \"\\n\", b->addr);\n\n\t\tif (b->jump != UT64_MAX) {\n\t\t\tif (b->fail != UT64_MAX) {\n\t\t\t\tret &= r_strbuf_appendf (edges, \"  _0x%\" PFMT64x \" --> _0x%\" PFMT64x \": true\\n\", b->addr, b->jump);\n\t\t\t\tret &= r_strbuf_appendf (edges, \"  _0x%\" PFMT64x \" --> _0x%\" PFMT64x \": false\\n\", b->addr, b->fail);\n\t\t\t} else {\n\t\t\t\tret &= r_strbuf_appendf (edges, \"  _0x%\" PFMT64x \" --> _0x%\" PFMT64x \"\\n\", b->addr, b->jump);\n\t\t\t}\n\t\t} else if (b->fail != UT64_MAX) {\n\t\t\tret &= r_strbuf_appendf (edges, \"  _0x%\" PFMT64x \" --> _0x%\" PFMT64x \"\\n\", b->addr, b->fail);\n\t\t}\n\t\tret &= fcn_siwtch_mermaid (b, edges);\n\t\tif (!ret) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\tchar *n = r_strbuf_drain_nofree (nodes);\n\t\tchar *e = r_strbuf_drain_nofree (edges);\n\t\tif (n && e) {\n\t\t\tr_cons_print (n);\n\t\t\tr_cons_print (e);\n\t\t}\n\t\tfree (n);\n\t\tfree (e);\n\t}\n\tr_strbuf_free (nodes);\n\tr_strbuf_free (edges);\n\treturn ret;\n}\n\nstatic void cmd_anal_graph(RCore *core, const char *input) {\n\tcore->graph->show_node_titles = r_config_get_i (core->config, \"graph.ntitles\");\n\tr_cons_enable_highlight (false);\n\tif (*input == '?') {\n\t\tr_core_cmd_help (core, help_msg_ag);\n\t\treturn;\n\t}\n\tswitch (input[0]) {\n\tcase 'f': // \"agf\"\n\t\tswitch (input[1]) {\n\t\tcase 0: // \"agf\"\n\t\t\tr_core_visual_graph (core, NULL, NULL, false);\n\t\t\tbreak;\n\t\tcase 'b': // \"agfb\" // braile\n\t\t\tcmd_agfb (core);\n\t\t\tbreak;\n\t\tcase 'm': /// \"agfm\" // mermaid\n\t\t\tcmd_graph_mermaid (core, input[2] == 'a');\n\t\t\tbreak;\n\t\tcase ' ': { // \"agf \"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tr_core_visual_graph (core, NULL, fcn, false);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'v': // \"agfv\"\n\t\t{\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_ROOT);\n\t\t\tif (fcn) {\n\t\t\t\tr_core_visual_graph (core, NULL, fcn, 1);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"No function to graph\");\n\t\t\t}\n\t\t\tr_cons_enable_mouse (false);\n\t\t\tr_cons_show_cursor (true);\n\t\t}\n\t\t\tbreak;\n\t\tcase 't': { // \"agft\" - tiny graph\n\t\t\tint e = r_config_get_i (core->config, \"graph.edges\");\n\t\t\tr_config_set_i (core->config, \"graph.edges\", 0);\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tr_core_visual_graph (core, NULL, fcn, 2);\n\t\t\tr_config_set_i (core->config, \"graph.edges\", e);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase 'd': // \"agfd\"\n\t\t\tif (input[2] == 'm') { // \"agfdm\"\n\t\t\t\tr_core_anal_graph (core, r_num_math (core->num, input + 3),\n\t\t\t\t\tR_CORE_ANAL_GRAPHLINES);\n\t\t\t} else {\n\t\t\t\tr_core_anal_graph (core, r_num_math (core->num, input + 2),\n\t\t\t\t\tR_CORE_ANAL_GRAPHBODY);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j': // \"agfj\"\n\t\t\tr_core_anal_graph (core, r_num_math (core->num, input + 2), R_CORE_ANAL_JSON);\n\t\t\tbreak;\n\t\tcase 'J': { // \"agfJ\"\n\t\t\t// Honor asm.graph=false in json as well\n\t\t\tRConfigHold *hc = r_config_hold_new (core->config);\n\t\t\tr_config_hold (hc, \"asm.offset\", NULL);\n\t\t\tconst bool o_graph_offset = r_config_get_i (core->config, \"graph.offset\");\n\t\t\tr_config_set_i (core->config, \"asm.offset\", o_graph_offset);\n\t\t\tr_core_anal_graph (core, r_num_math (core->num, input + 2),\n\t\t\t\tR_CORE_ANAL_JSON | R_CORE_ANAL_JSON_FORMAT_DISASM);\n\t\t\tr_config_hold_restore (hc);\n\t\t\tr_config_hold_free (hc);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'g':{ // \"agfg\"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tr_core_print_bb_gml (core, fcn);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase 'k':{ // \"agfk\"\n\t\t\tr_core_cmdf (core, \"ag-; .agf* @ %\"PFMT64u\"; aggk\", core->offset);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase '*':{// \"agf*\"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tr_core_print_bb_custom (core, fcn);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase 'w': // \"agfw\"\n\t\t\t {\n\t\t\t\tchar *cmdargs = r_str_newf (\"agfd @ 0x%\"PFMT64x, core->offset);\n\t\t\t\tconvert_dotcmd_to_image (core, cmdargs, input + 2);\n\t\t\t\tfree (cmdargs);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_ag);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '-': // \"ag-\"\n\t\tr_agraph_reset (core->graph);\n\t\tbreak;\n\tcase 'n': // \"agn\"\n\t\tcmd_agraph_node (core, input + 1);\n\t\tbreak;\n\tcase 'e': // \"age\"\n\t\tcmd_agraph_edge (core, input + 1);\n\t\tbreak;\n\tcase 't': // \"agt\"\n\t\tr_core_agraph_treemap (core, -1, input + 1);\n\t\tbreak;\n\tcase 'g': // \"agg\"\n\t\tr_core_agraph_print (core, -1, input + 1);\n\t\tbreak;\n\tcase 's': // \"ags\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), 0);\n\t\tbreak;\n\tcase 'C': // \"agC\"\n\t\tswitch (input[1]) {\n\t\tcase 'm':\n\t\tcase 'v':\n\t\tcase 't':\n\t\tcase 'k':\n\t\tcase 'w':\n\t\tcase ' ':\n\t\tcase 0:\n\t\t\tcore->graph->is_callgraph = true;\n\t\t\tr_core_cmdf (core, \"ag-; .agC*;\");\n\t\t\tr_core_agraph_print(core, -1, input + 1);\n\t\t\tcore->graph->is_callgraph = false;\n\t\t\tbreak;\n\t\tcase 'J':\n\t\tcase 'j':\n\t\t\tr_core_anal_callgraph (core, UT64_MAX, R_GRAPH_FORMAT_JSON);\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tr_core_anal_callgraph (core, UT64_MAX, R_GRAPH_FORMAT_GML);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tr_core_anal_callgraph (core, UT64_MAX, R_GRAPH_FORMAT_DOT);\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tr_core_anal_callgraph (core, UT64_MAX, R_GRAPH_FORMAT_CMD);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_ag);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"agr\" references graph\n\t\tswitch (input[1]) {\n\t\tcase '*':\n\t\t\tr_core_anal_coderefs (core, core->offset);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcore->graph->is_callgraph = true;\n\t\t\tr_core_cmdf (core, \"ag-; .agr* @ %\"PFMT64u\";\", core->offset);\n\t\t\tr_core_agraph_print(core, -1, input + 1);\n\t\t\tcore->graph->is_callgraph = false;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'R': // \"agR\" global refs\n\t\tswitch (input[1]) {\n\t\tcase '*': {\n\t\t\tut64 from = r_config_get_i (core->config, \"graph.from\");\n\t\t\tut64 to = r_config_get_i (core->config, \"graph.to\");\n\t\t\tRListIter *it;\n\t\t\tRAnalFunction *fcn;\n\t\t\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\t\t\tif ((from == UT64_MAX && to == UT64_MAX) || R_BETWEEN (from, fcn->addr, to)) {\n\t\t\t\t\tr_core_anal_coderefs (core, fcn->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t}\n\t\tdefault: {\n\t\t\tcore->graph->is_callgraph = true;\n\t\t\tr_core_cmdf (core, \"ag-; .agR*;\");\n\t\t\tr_core_agraph_print(core, -1, input + 1);\n\t\t\tcore->graph->is_callgraph = false;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'x': {// \"agx\" cross refs\n\t\tRGraph *graph = r_core_anal_codexrefs (core, core->offset);\n\t\tif (!graph) {\n\t\t\tR_LOG_ERROR (\"Cannot create graph\");\n\t\t\tbreak;\n\t\t}\n\t\tr_core_graph_print (core, graph, -1, true, input + 1);\n\t\tr_graph_free (graph);\n\t\tbreak;\n\t}\n\tcase 'i': { // \"agi\" import graph\n\t\tRGraph *graph = r_core_anal_importxrefs (core);\n\t\tif (!graph) {\n\t\t\tR_LOG_ERROR (\"Cannot create graph\");\n\t\t\tbreak;\n\t\t}\n\t\tr_core_graph_print (core, graph, -1, true, input + 1);\n\t\tr_graph_free (graph);\n\t\tbreak;\n\t}\n\tcase 'c': // \"agc\"\n\t\tswitch (input[1]) {\n\t\tcase 'v':\n\t\tcase 't':\n\t\tcase 'k':\n\t\tcase 'w':\n\t\tcase 'm':\n\t\tcase ' ': {\n\t\t\tcore->graph->is_callgraph = true;\n\t\t\tr_core_cmdf (core, \"ag-; .agc* @ %\" PFMT64u \"; agg%s;\", core->offset, input + 1);\n\t\t\tcore->graph->is_callgraph = false;\n\t\t\tbreak;\n\t\t\t}\n\t\tcase 0:\n\t\t\tcore->graph->is_callgraph = true;\n\t\t\tr_core_cmd0 (core, \"ag-; .agc* $$; agg;\");\n\t\t\tcore->graph->is_callgraph = false;\n\t\t\tbreak;\n\t\tcase 'g': {\n\t\t\tr_core_anal_callgraph (core, core->offset, R_GRAPH_FORMAT_GMLFCN);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'd': {\n\t\t\tr_core_anal_callgraph (core, core->offset, R_GRAPH_FORMAT_DOT);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'J':\n\t\tcase 'j': {\n\t\t\tr_core_anal_callgraph (core, core->offset, R_GRAPH_FORMAT_JSON);\n\t\t\tbreak;\n\t\t}\n\t\tcase '*': {\n\t\t\tr_core_anal_callgraph (core, core->offset, R_GRAPH_FORMAT_CMD);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_ag);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"agj\" alias for agfj\n\t\tr_core_cmdf (core, \"agfj%s\", input + 1);\n\t\tbreak;\n\tcase 'J': // \"agJ\" alias for agfJ\n\t\tr_core_cmdf (core, \"agfJ%s\", input + 1);\n\t\tbreak;\n\tcase 'k': // \"agk\" alias for agfk\n\t\tr_core_cmdf (core, \"agfk%s\", input + 1);\n\t\tbreak;\n\tcase 'l': // \"agl\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), R_CORE_ANAL_GRAPHLINES);\n\t\tbreak;\n\tcase 'a': // \"aga\"\n\t\tswitch (input[1]) {\n\t\tcase '*': {\n\t\t\tr_core_anal_datarefs (core, core->offset);\n\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tr_core_cmdf (core, \"ag-; .aga* @ %\"PFMT64u\";\", core->offset);\n\t\t\tr_core_agraph_print(core, -1, input + 1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'A': // \"agA\" global data refs\n\t\tswitch (input[1]) {\n\t\tcase '*': {\n\t\t\tut64 from = r_config_get_i (core->config, \"graph.from\");\n\t\t\tut64 to = r_config_get_i (core->config, \"graph.to\");\n\t\t\tRListIter *it;\n\t\t\tRAnalFunction *fcn;\n\t\t\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\t\t\tif ((from == UT64_MAX && to == UT64_MAX) || R_BETWEEN (from, fcn->addr, to)) {\n\t\t\t\t\tr_core_anal_datarefs (core, fcn->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tr_core_cmdf (core, \"ag-; .agA*;\");\n\t\t\tr_core_agraph_print(core, -1, input + 1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'd': {// \"agd\"\n\t\tint diff_opt = R_CORE_ANAL_GRAPHBODY | R_CORE_ANAL_GRAPHDIFF;\n\t\tswitch (input[1]) {\n\t\tcase 'j': {\n\t\t\t\t  ut64 addr = input[2] ? r_num_math (core->num, input + 2) : core->offset;\n\t\t\t\t  r_core_gdiff_fcn (core, addr, core->offset);\n\t\t\t\t  r_core_anal_graph (core, addr, diff_opt | R_CORE_ANAL_JSON);\n\t\t\t\t  break;\n\t\t\t  }\n\t\tcase 'J': {\n\t\t\t\t  ut64 addr = input[2] ? r_num_math (core->num, input + 2) : core->offset;\n\t\t\t\t  r_core_gdiff_fcn (core, addr, core->offset);\n\t\t\t\t  r_core_anal_graph (core, addr, diff_opt | R_CORE_ANAL_JSON | R_CORE_ANAL_JSON_FORMAT_DISASM);\n\t\t\t\t  break;\n\t\t\t  }\n\t\tcase '*': {\n\t\t\t\t  ut64 addr = input[2] ? r_num_math (core->num, input + 2) : core->offset;\n\t\t\t\t  r_core_gdiff_fcn (core, addr, core->offset);\n\t\t\t\t  r_core_anal_graph (core, addr, diff_opt | R_CORE_ANAL_STAR);\n\t\t\t\t  break;\n\t\t\t  }\n\t\tcase ' ':\n\t\tcase 0:\n\t\tcase 't':\n\t\tcase 'k':\n\t\tcase 'v':\n\t\tcase 'm':\n\t\tcase 'g': {\n\t\t\t\t  ut64 addr = input[2]? r_num_math (core->num, input + 2): core->offset;\n\t\t\t\t  r_core_cmdf (core, \"ag-; .agd* @ %\"PFMT64u\"; agg%s;\", addr, input + 1);\n\t\t\t\t  break;\n\t\t\t  }\n\t\tcase 'd': {\n\t\t\t\t  ut64 addr = input[2]? r_num_math (core->num, input + 2): core->offset;\n\t\t\t\t  r_core_gdiff_fcn (core, addr, core->offset);\n\t\t\t\t  r_core_anal_graph (core, addr, diff_opt);\n\t\t\t\t  break;\n\t\t\t  }\n\t\tcase 'w': {\n\t\t\t\t  char *cmdargs = r_str_newf (\"agdd 0x%\"PFMT64x, core->offset);\n\t\t\t\t  convert_dotcmd_to_image (core, cmdargs, input + 2);\n\t\t\t\t  free (cmdargs);\n\t\t\t\t  break;\n\t\t\t  }\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'v': // \"agv\" alias for \"agfv\"\n\t\tr_core_cmdf (core, \"agfv%s\", input + 1);\n\t\tbreak;\n\tcase 'w':// \"agw\"\n\t\t{\n\t\t\tchar *cmdargs = r_str_newf (\"agfd @ 0x%\"PFMT64x, core->offset);\n\t\t\tconvert_dotcmd_to_image (core, cmdargs, input + 1);\n\t\t\tfree (cmdargs);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ag);\n\t\tbreak;\n\t}\n}\n\nR_API int r_core_anal_refs(RCore *core, const char *input) {\n\tconst bool cfg_debug = r_config_get_b (core->config, \"cfg.debug\");\n\tut64 from, to;\n\tint rad;\n\tPJ *pj = NULL;\n\tif (*input == '?') {\n\t\tr_core_cmd_help (core, help_msg_aar);\n\t\treturn 0;\n\t}\n\n\tif (*input == 'j' || *input == '*') {\n\t\trad = *input;\n\t\tinput++;\n\t\tif (rad == 'j') {\n\t\t\tpj = r_core_pj_new (core);\n\t\t\tif (!pj) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trad = 0;\n\t}\n\n\tfrom = to = 0;\n\tchar *ptr = r_str_trim_dup (input);\n\tint n = r_str_word_set0 (ptr);\n\tif (!n) {\n\t\t// get boundaries of current memory map, section or io map\n\t\tif (cfg_debug) {\n\t\t\tRDebugMap *map = r_debug_map_get (core->dbg, core->offset);\n\t\t\tif (map) {\n\t\t\t\tfrom = map->addr;\n\t\t\t\tto = map->addr_end;\n\t\t\t}\n\t\t} else {\n\t\t\tRList *list = r_core_get_boundaries_prot (core, R_PERM_X, NULL, \"anal\");\n\t\t\tRListIter *iter;\n\t\t\tRIOMap* map;\n\t\t\tif (!list) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (rad == 'j') {\n\t\t\t\tpj_o (pj);\n\t\t\t}\n\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\tfrom = r_io_map_begin (map);\n\t\t\t\tto = r_io_map_end (map);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!from && !to) {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot determine xref search boundaries\");\n\t\t\t\t} else if (to - from > UT32_MAX) {\n\t\t\t\t\tchar *unit = r_num_units (NULL, 0, to - from);\n\t\t\t\t\tR_LOG_WARN (\"Skipping huge range (%s)\", unit);\n\t\t\t\t\tfree (unit);\n\t\t\t\t} else {\n\t\t\t\t\tif (rad == 'j') {\n\t\t\t\t\t\tpj_ki (pj, \"mapid\", map->id);\n\t\t\t\t\t\tpj_ko (pj, \"refs\");\n\t\t\t\t\t}\n\t\t\t\t\tr_core_anal_search_xrefs (core, from, to, pj, rad);\n\t\t\t\t\tif (rad == 'j') {\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rad == 'j') {\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t}\n\t\t\tfree (ptr);\n\t\t\tr_list_free (list);\n\t\t\treturn 1;\n\t\t}\n\t} else if (n == 1) {\n\t\tfrom = core->offset;\n\t\tto = core->offset + r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t} else {\n\t\tR_LOG_ERROR (\"Invalid number of arguments\");\n\t}\n\tfree (ptr);\n\n\tif (from == UT64_MAX && to == UT64_MAX) {\n\t\treturn false;\n\t}\n\tif (!from && !to) {\n\t\treturn false;\n\t}\n\tif (to - from > r_io_size (core->io)) {\n\t\treturn false;\n\t}\n\tif (rad == 'j') {\n\t\tpj_o (pj);\n\t}\n\tbool res = r_core_anal_search_xrefs (core, from, to, pj, rad);\n\tif (rad == 'j') {\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\treturn res;\n}\n\nstatic int compute_coverage(RCore *core) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tint cov = 0;\n\tcov += r_meta_get_size(core->anal, R_META_TYPE_DATA);\n\tRIOBank *bank = r_io_bank_get (core->io, core->io->bank);\n\tif (bank) {\n\t\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\t\tRIOMapRef *mapref;\n\t\t\tRListIter *ator;\n\t\t\tr_list_foreach (bank->maprefs, ator, mapref) {\n\t\t\t\tRIOMap *map = r_io_map_get (core->io, mapref->id);\n\t\t\t\tif (map->perm & R_PERM_X) {\n\t\t\t\t\tut64 section_end = r_io_map_end (map);\n\t\t\t\t\tut64 s = r_anal_function_realsize (fcn);\n\t\t\t\t\tif (fcn->addr >= r_io_map_from (map) && (fcn->addr + s) < section_end) {\n\t\t\t\t\t\tcov += s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cov;\n}\n\nstatic int compute_code(RCore* core) {\n\tint code = 0;\n\tRIOBank *bank = r_io_bank_get (core->io, core->io->bank);\n\tif (bank) {\n\t\tRIOMapRef *mapref;\n\t\tRListIter *ator;\n\t\tr_list_foreach (bank->maprefs, ator, mapref) {\n\t\t\tRIOMap *map = r_io_map_get (core->io, mapref->id);\n\t\t\tif (map->perm & R_PERM_X) {\n\t\t\t\tcode += r_io_map_size (map);\n\t\t\t}\n\t\t}\n\t}\n\treturn code;\n}\n\nstatic int compute_calls(RCore *core) {\n\tint cov = 0;\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tRVecAnalRef *xrefs = r_anal_function_get_xrefs (fcn);\n\t\tif (xrefs) {\n\t\t\tcov += RVecAnalRef_length (xrefs);\n\t\t\tRVecAnalRef_free (xrefs);\n\t\t}\n\t}\n\treturn cov;\n}\n\nstatic void r_core_anal_info(RCore *core, const char *input) {\n\tint fcns = r_list_length (core->anal->fcns);\n\tint strs = r_flag_count (core->flags, \"str.*\");\n\tint syms = r_flag_count (core->flags, \"sym.*\");\n\tint imps = r_flag_count (core->flags, \"sym.imp.*\");\n\tint code = compute_code (core);\n\tint covr = compute_coverage (core);\n\tint call = compute_calls (core);\n\tint xrfs = r_anal_xrefs_count (core->anal);\n\tint cvpc = (code > 0)? (int)((covr * 100.0) / code): 0;\n\tif (*input == 'j') {\n\t\tPJ *pj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_o (pj);\n\t\tpj_ki (pj, \"fcns\", fcns);\n\t\tpj_ki (pj, \"xrefs\", xrfs);\n\t\tpj_ki (pj, \"calls\", call);\n\t\tpj_ki (pj, \"strings\", strs);\n\t\tpj_ki (pj, \"symbols\", syms);\n\t\tpj_ki (pj, \"imports\", imps);\n\t\tpj_ki (pj, \"covrage\", covr);\n\t\tpj_ki (pj, \"codesz\", code);\n\t\tpj_ki (pj, \"percent\", cvpc);\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t} else {\n\t\tr_cons_printf (\"fcns    %d\\n\", fcns);\n\t\tr_cons_printf (\"xrefs   %d\\n\", xrfs);\n\t\tr_cons_printf (\"calls   %d\\n\", call);\n\t\tr_cons_printf (\"strings %d\\n\", strs);\n\t\tr_cons_printf (\"symbols %d\\n\", syms);\n\t\tr_cons_printf (\"imports %d\\n\", imps);\n\t\tr_cons_printf (\"covrage %d\\n\", covr);\n\t\tr_cons_printf (\"codesz  %d\\n\", code);\n\t\tr_cons_printf (\"percent %d%%\\n\", cvpc);\n\t}\n}\n\nstatic void cmd_anal_aad(RCore *core, const char *input) {\n\tRVecAnalRef *list = r_anal_refs_get (core->anal, UT64_MAX);\n\tRAnalRef *ref;\n\tR_VEC_FOREACH (list, ref) {\n\t\tif (r_io_is_valid_offset (core->io, ref->addr, false)) {\n\t\t\tr_core_anal_fcn (core, ref->at, ref->addr, R_ANAL_REF_TYPE_NULL, 1);\n\t\t}\n\t}\n\tRVecAnalRef_free (list);\n}\n\nstatic bool archIsThumbable(RCore *core) {\n\tRArchConfig *ac = R_UNWRAP4 (core, anal, arch, cfg);\n\tif (ac && ac->bits <= 32) {\n\t\t// XXX for some reason this is null\n\t\tif (!strcmp (ac->arch, \"arm\")) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void _CbInRangeAav(RCore *core, ut64 from, ut64 to, int vsize, void *user) {\n\tbool asterisk = user;\n\tint arch_align = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_ALIGN);\n\tbool vinfun = r_config_get_b (core->config, \"anal.vinfun\");\n\tint searchAlign = r_config_get_i (core->config, \"search.align\");\n\tint align = (searchAlign > 0)? searchAlign: arch_align;\n\tif (align > 1) {\n\t\tif ((from % align) || (to % align)) {\n\t\t\tbool itsFine = false;\n\t\t\tif (archIsThumbable (core)) {\n\t\t\t\tif ((from & 1) || (to & 1)) {\n\t\t\t\t\titsFine = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!itsFine) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (core->anal->verbose) {\n\t\t\t\tR_LOG_WARN (\"aav: false positive in 0x%08\"PFMT64x, from);\n\t\t\t}\n\t\t}\n\t}\n\tif (!vinfun) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, from, -1);\n\t\tif (fcn) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (asterisk) {\n\t\tr_cons_printf (\"ax 0x%\"PFMT64x \" 0x%\"PFMT64x \"\\n\", to, from);\n\t\tr_cons_printf (\"Cd %d @ 0x%\"PFMT64x \"\\n\", vsize, from);\n\t\tr_cons_printf (\"f+ aav.0x%08\"PFMT64x \"= 0x%08\"PFMT64x, to, to);\n\t} else {\n\t\tr_anal_xrefs_set (core->anal, from, to, R_ANAL_REF_TYPE_NULL);\n\t\t// r_meta_set (core->anal, 'd', from, from + vsize, NULL);\n\t\tr_core_cmdf (core, \"Cd %d @ 0x%\"PFMT64x, vsize, from);\n\t\tif (!r_flag_get_at (core->flags, to, false)) {\n\t\t\tchar *name = r_str_newf (\"aav.0x%08\"PFMT64x, to);\n\t\t\tr_flag_set (core->flags, name, to, vsize);\n\t\t\tfree (name);\n\t\t}\n\t}\n}\n\nstatic void cmd_anal_aaw(RCore *core, const char *input) {\n\tbool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->print->config);\n\tint bits = core->anal->config->bits;\n\tRIntervalTreeIter it;\n\tRAnalMetaItem *item;\n\tr_interval_tree_foreach (&core->anal->meta, it, item) {\n\t\tRIntervalNode *node = r_interval_tree_iter_get (&it);\n\t\tut64 size = r_meta_item_size (node->start, node->end);\n\t\tif (item->type == R_META_TYPE_DATA && size == core->anal->config->bits / 8) {\n\t\t\tut8 buf[8] = {0};\n\t\t\tr_io_read_at (core->io, node->start, buf, 8);\n\t\t\tut64 n = r_read_ble (buf, be, bits);\n\t\t\tRFlagItem *fi = r_flag_get_at (core->flags, n, false);\n\t\t\tif (fi) {\n\t\t\t\tchar *fn = r_str_newf (\"r.%s\", fi->name);\n\t\t\t\tr_flag_set (core->flags, fn, node->start, true);\n\t\t\t\tfree (fn);\n\t\t\t} else if (core->anal->verbose) {\n\t\t\t\tR_LOG_WARN (\"Unknown pointer 0x%\"PFMT64x\" at 0x%\"PFMT64x, n, (ut64)node->start);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void cmd_anal_aav(RCore *core, const char *input) {\n#define seti(x,y) r_config_set_i(core->config, x, y);\n#define geti(x) r_config_get_i(core->config, x);\n\tr_return_if_fail (*input == 'v');\n\tbool relative = input[1] == 'r';\n\tut64 o_align = geti (\"search.align\");\n\tconst char *analin = r_config_get (core->config, \"anal.in\");\n\tchar *tmp = strdup (analin);\n\tbool asterisk = strchr (input, '*');\n\tconst bool is_debug = r_config_get_b (core->config, \"cfg.debug\");\n\tint archAlign = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_ALIGN);\n\tseti (\"search.align\", archAlign);\n\tr_config_set (core->config, \"anal.in\", \"io.maps.x\");\n\tR_LOG_INFO (\"Finding xrefs in noncode section (e anal.in=io.maps.x)\");\n\n\tint vsize = 4; // 32bit dword\n\tif (core->rasm->config->bits == 64) {\n\t\tvsize = 8;\n\t}\n\tR_LOG_INFO (\"Analyze value pointers (aav)\");\n\tr_cons_break_push (NULL, NULL);\n\tif (is_debug) {\n\t\tRList *list = r_core_get_boundaries_prot (core, 0, \"dbg.map\", \"anal\");\n\t\tRListIter *iter;\n\t\tRIOMap *map;\n\t\tif (!list) {\n\t\t\tgoto beach;\n\t\t}\n\t\tr_list_foreach (list, iter, map) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(void)r_core_search_value_in_range (core, relative, map->itv,\n\t\t\t\tr_io_map_begin (map), r_io_map_end (map), vsize, _CbInRangeAav, (void *)(size_t)asterisk);\n\t\t}\n\t\tr_list_free (list);\n\t} else {\n\t\tRList *list = r_core_get_boundaries_prot (core, 0, NULL, \"anal\");\n\t\tif (!list) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRListIter *iter, *iter2;\n\t\tRIOMap *map, *map2;\n\t\tut64 from = UT64_MAX;\n\t\tut64 to = UT64_MAX;\n\t\t// find values pointing to non-executable regions\n\t\tr_list_foreach (list, iter2, map2) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//TODO: Reduce multiple hits for same addr\n\t\t\tfrom = r_itv_begin (map2->itv);\n\t\t\tto = r_itv_end (map2->itv);\n\t\t\tif ((to - from) > MAX_SCAN_SIZE) {\n\t\t\t\tR_LOG_WARN (\"Skipping large region\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\tut64 begin = r_io_map_begin (map);\n\t\t\t\tut64 end = r_io_map_end (map);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (end - begin > UT32_MAX) {\n\t\t\t\t\tchar *unit = r_num_units (NULL, 0, end - begin);\n\t\t\t\t\tR_LOG_WARN (\"Skipping huge range (%s)\", unit);\n\t\t\t\t\tfree (unit);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tR_LOG_INFO (\"aav: 0x%08\"PFMT64x\"-0x%08\"PFMT64x\" in 0x%\"PFMT64x\"-0x%\"PFMT64x, from, to, begin, end);\n\t\t\t\t(void)r_core_search_value_in_range (core, relative, map->itv, from, to, vsize, _CbInRangeAav, (void *)(size_t)asterisk);\n\t\t\t}\n\t\t}\n\t\tr_list_free (list);\n\t}\nbeach:\n\tr_cons_break_pop ();\n\tr_config_set (core->config, \"anal.in\", tmp);\n\tfree (tmp);\n\tseti (\"search.align\", o_align);\n}\n\nstatic void cmd_anal_abt(RCore *core, const char *input) {\n\tRAnalBlock *bb = r_anal_get_block_at (core->anal, core->offset);\n\tif (bb) {\n\t\tif (R_STR_ISEMPTY (input)) {\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\"\\n\", bb->traced);\n\t\t} else if (*input == ' ') {\n\t\t\tchar *first = (char *)r_str_trim_head_ro (input);\n\t\t\tchar *arg = strchr (first, ' ');\n\t\t\tint tag = atoi (first);\n\t\t\tif (tag < 0 || tag > 63) {\n\t\t\t\tR_LOG_ERROR (\"Invalid trace tag number\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (arg) {\n\t\t\t\tRColor k = {0};\n\t\t\t\tchar *s = r_cons_pal_parse (arg + 1, &k);\n\t\t\t\tif (s)  {\n\t\t\t\t\tcore->anal->tracetagcolors[tag] = k;\n\t\t\t\t\tfree (s);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Invalid error\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbb->traced = tag;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot find any basic block here\");\n\t}\n}\n\nstatic void cmd_anal_abp(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase 'e': // \"abpe\"\n\t\t{\n\t\tint n = 1;\n\t\tchar *p = strchr (input + 1, ' ');\n\t\tif (!p) {\n\t\t\t// TODO use r_cons_cmd_help_match () instead\n\t\t\tr_core_cmd_help (core, help_msg_abp);\n\t\t\treturn;\n\t\t}\n\t\tut64 addr = r_num_math (core->num, p + 1);\n\t\tRList *paths = r_core_anal_graph_to (core, addr, n);\n\t\tif (paths) {\n\t\t\tRAnalBlock *bb;\n\t\t\tRList *path;\n\t\t\tRListIter *pathi;\n\t\t\tRListIter *bbi;\n\t\t\tr_cons_printf (\"f orip=`dr?PC`\\n\");\n\t\t\tr_list_foreach (paths, pathi, path) {\n\t\t\t\tr_list_foreach (path, bbi, bb) {\n\t\t\t\t\tr_cons_printf (\"# 0x%08\" PFMT64x \"\\n\", bb->addr);\n\t\t\t\t\tif (addr >= bb->addr && addr < bb->addr + bb->size) {\n\t\t\t\t\t\tr_cons_printf (\"aepc 0x%08\"PFMT64x\"\\n\", bb->addr);\n\t\t\t\t\t\tr_cons_printf (\"aesou 0x%08\"PFMT64x\"\\n\", addr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"aepc 0x%08\"PFMT64x\"\\n\", bb->addr);\n\t\t\t\t\t\tr_cons_printf (\"aesou 0x%08\"PFMT64x\"\\n\", bb->addr + bb->size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_cons_newline ();\n\t\t\t\tr_list_purge (path);\n\t\t\t\tfree (path);\n\t\t\t}\n\t\t\tr_list_purge (paths);\n\t\t\tr_cons_printf (\"aepc orip\\n\");\n\t\t\tfree (paths);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_abp);\n\t\tbreak;\n\tcase 'j': { // \"abpj\"\n\t\tut64 addr = r_num_math (core->num, input + 1);\n\t\tRAnalBlock *block = r_anal_get_block_at (core->anal, core->offset);\n\t\tif (!block) {\n\t\t\tbreak;\n\t\t}\n\t\tRList *path = r_anal_block_shortest_path (block, addr);\n\t\tPJ *pj = r_core_pj_new (core);\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t\tif (path) {\n\t\t\t\tRListIter *it;\n\t\t\t\tr_list_foreach (path, it, block) {\n\t\t\t\t\tpj_n (pj, block->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t}\n\t\tr_list_free (path);\n\t\tbreak;\n\t}\n\tcase ' ': {\n\t\tut64 addr = r_num_math (core->num, input + 1);\n\t\tif (addr == UT64_MAX || addr == 0) {\n\t\t\tR_LOG_ERROR (\"Invalid or missing address passed as argument\");\n\t\t} else {\n\t\t\tRAnalBlock *block = r_anal_get_block_at (core->anal, core->offset);\n\t\t\tif (!block) {\n\t\t\t\tR_LOG_ERROR (\"No basic block at\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRList *path = r_anal_block_shortest_path (block, addr);\n\t\t\tif (path) {\n\t\t\t\tRListIter *it;\n\t\t\t\tr_list_foreach (path, it, block) {\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", block->addr);\n\t\t\t\t}\n\t\t\t\tr_list_free (path);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase '\\0':\n\t\tr_core_cmdf (core, \"abl, addr/eq/0x%08\"PFMT64x, core->offset);\n\t\tbreak;\n\t}\n}\n\nstatic bool is_unknown_file(RCore *core) {\n\tif (core->bin->cur && core->bin->cur->bo) {\n\t\treturn r_list_empty (core->bin->cur->bo->sections);\n\t}\n\treturn true;\n}\n\nstatic bool is_apple_target(RCore *core) {\n\tconst char *arch = r_config_get (core->config, \"asm.arch\");\n\tif (!strstr (arch, \"ppc\") && !strstr (arch, \"arm\") && !strstr (arch, \"x86\")) {\n\t\treturn false;\n\t}\n\tRBinObject *bo = r_bin_cur_object (core->bin);\n\tr_return_val_if_fail (!bo || (bo->plugin && bo->plugin->name), false);\n\treturn bo? strstr (bo->plugin->name, \"mach\"): false;\n}\n\nstatic bool is_valid_code(RCore *core, ut64 addr, int n) {\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tRAnalOp *op = r_core_anal_op (core, addr, R_ARCH_OP_MASK_BASIC);\n\t\tif (op) {\n\t\t\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_NULL:\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_UNK:\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (op->size < 1) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\taddr += op->size;\n\t\t\tr_anal_op_free (op);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool is_executable(RCore *core, ut64 addr) {\n\tRBinObject *obj = r_bin_cur_object (core->bin);\n\tRListIter *it;\n\tRBinSection* sec;\n\tif (obj) {\n\t\tif (obj->info && obj->info->arch) {\n\t\t\treturn true;\n\t\t}\n\t\tr_list_foreach (obj->sections, it, sec) {\n\t\t\tut64 vaddr_end = sec->vaddr + sec->vsize;\n\t\t\tif (addr >= sec->vaddr && addr < vaddr_end) {\n\t\t\t\tif (sec->perm & R_PERM_X) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\tif (map) {\n\t\tif (map->perm & R_PERM_X) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool strnullpad_check(const ut8 *buf, int len, int clen, int inc, bool be) {\n\tint i;\n\tfor (i = 0; i < len; i += inc) {\n\t\tif (inc == 2) {\n\t\t\tif (be) {\n\t\t\t\tif (!buf[i] && !buf[i + 1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!IS_PRINTABLE (buf[i]) || buf[i + 1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!buf[i] && !buf[i + 1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (buf[i] || !IS_PRINTABLE (buf[i+1])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Invalid inc\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n// XXX from cmd_print.c\nstatic bool check_string_at(RCore *core, ut64 addr, bool and_print_it) {\n\tif (!r_io_is_valid_offset (core->io, addr, 0)) {\n\t\treturn false;\n\t}\n\tconst int len = core->blocksize; // max string length\n\tint i;\n\t// bool is_utf32le = false;\n\t// bool is_utf32be = false;\n\tbool is_pascal1 = false;\n\tbool is_pascal2 = false;\n\tbool is_utf8 = false;\n\tbool is_ascii = false;\n\tchar *out = NULL; // utf8 string containing the printable result\n\tut8 *buf = malloc (len);\n\tif (buf) {\n\t\tif (r_io_read_at (core->io, addr, buf, len) < 1) {\n\t\t\tfree (buf);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot allocate %d byte(s)\", len);\n\t\treturn false;\n\t}\n\tint nullbyte = r_str_nlen ((const char *)buf, len);\n\tif (nullbyte == len) {\n\t\t// full block, not null terminated somehow. lets check how printable it is first..\n\t\tbuf[len - 1] = 0;\n\t\tnullbyte--;\n\t}\n\tif (nullbyte < len && nullbyte > 3) {\n\t\tis_ascii = true;\n\t\t// it's a null terminated string!\n\t\tfor (i = 0; i < nullbyte; i++) {\n\t\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t\tis_ascii = false;\n\t\t\t}\n\t\t}\n\t\tif (!is_ascii) {\n\t\t\tis_utf8 = true;\n\t\t\tif ((buf[0] & 0xf0) == 0xf0 && (buf[1] & 0xf0) == 0xf0) {\n\t\t\t\tis_utf8 = false;\n\t\t\t}\n\t\t\tfor (i = 0; i < nullbyte; i++) {\n\t\t\t\tint us = r_utf8_size (buf + i);\n\t\t\t\tif (us < 1) {\n\t\t\t\t\tis_utf8 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti += us - 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// utf16le check\n\tif (strnullpad_check (buf, R_MIN (len, 10), 10, 2, false)) {\n\t\tout = malloc (len + 1);\n\t\tif (r_str_utf16_to_utf8 ((ut8*)out, len, buf, len, true) < 1) {\n\t\t\tR_FREE (out);\n\t\t}\n\t}\n\t// utf16be check\n\tif (strnullpad_check (buf, R_MIN (len, 10), 10, 2, true)) {\n\t\tout = malloc (len + 1);\n\t\tif (r_str_utf16_to_utf8 ((ut8*)out, len, buf, len, false) < 1) {\n\t\t\tR_FREE (out);\n\t\t}\n\t}\n\t// TODO: add support for utf32 strings and improve util apis\n\t// check for pascal string\n\t{\n\t\tut8 plen = buf[0];\n\t\tif (plen > 1 && plen < len) {\n\t\t\tis_pascal1 = true;\n\t\t\tint i;\n\t\t\tfor (i = 1; i < plen; i++) {\n\t\t\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t\t\tis_pascal1 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_pascal1) {\n\t\t\t\tchar *oout = r_str_ndup ((const char *)buf + 1, i);\n\t\t\t\tfree (out);\n\t\t\t\tout = oout;\n\t\t\t}\n\t\t}\n\t}\n\tif (!is_pascal1) {\n\t\tut8 plen = r_read_le16 (buf);\n\t\tif (plen > 2 && plen < len) {\n\t\t\tis_pascal2 = true;\n\t\t\tfor (i = 2; i < plen; i++) {\n\t\t\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t\t\tis_pascal2 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_pascal2) {\n\t\t\t\tchar *oout = r_str_ndup ((const char *)buf + 2, i);\n\t\t\t\tfree (out);\n\t\t\t\tout = oout;\n\t\t\t}\n\t\t}\n\t}\n\tif (!and_print_it) {\n\t\tfree (out);\n\t\treturn (is_ascii || is_utf8);\n\t}\n#if 0\n\teprintf (\"pascal %d\\n\", is_pascal1 + is_pascal2);\n\teprintf (\"utf8 %d\\n\", is_utf8);\n\teprintf (\"utf16 %d\\n\", is_utf16le+ is_utf16be);\n\teprintf (\"ascii %d\\n\", is_ascii);\n\teprintf (\"render\\n\");\n#endif\n\t// render the stuff\n\tif (out) {\n\t\tr_cons_printf (\"%s\\n\", out);\n\t\tfree (out);\n\t\tfree (buf);\n\t\treturn true;\n\t}\n\tif (is_ascii || is_utf8) {\n\t\tr_cons_printf (\"%s\\n\", buf);\n\t\tfree (buf);\n\t\treturn true;\n\t}\n\tfree (buf);\n\treturn false;\n}\n\nstatic bool funref(void *_core, ut64 from, ut64 addr) {\n\tRCore *core = _core;\n\tRAnalFunction *fcn = r_anal_get_function_at (core->anal, addr);\n\tif (!fcn && is_executable (core, addr)) {\n\t\tif (check_string_at (core, addr, false)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!is_valid_code (core, addr, 10)) {\n\t\t\treturn false;\n\t\t}\n\t\tr_core_cmdf (core, \"af@0x%08\"PFMT64x, addr);\n\t\t// r_core_anal_fcn (core, from, addr, 'c', 100);\n\t}\n\treturn true;\n}\n\nstatic void anal_aarr(RCore *core) {\n\tSetU *visited = set_u_new ();\n\tRAnalFunction *fcn;\n\tRListIter *it;\n\tr_list_foreach (core->anal->fcns, it, fcn) {\n#if 0\n\t\tr_anal_analyze_fcn_refs (core, fcn, depth);\n\t\tcontinue;\n#endif\n\t\tRVecAnalRef *refs = r_anal_function_get_refs (fcn);\n\t\tRAnalRef *refi;\n\t\tR_VEC_FOREACH (refs, refi) {\n\t\t\tut64 ra = refi->addr;\n\t\t\tif (set_u_contains (visited, ra)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tset_u_add (visited, ra);\n\t\t\tfunref (core, refi->at, ra);\n\t\t}\n\t\tRVecAnalRef_free (refs);\n\t}\n\tset_u_free (visited);\n}\n\nstatic int cmd_anal_all(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_aa);\n\t\tbreak;\n\tcase 'b': // \"aab\"\n\t\tcmd_anal_blocks (core, input + 1);\n\t\tbreak;\n\tcase 'f':\n\t\tif (input[1] == 'e') {  // \"aafe\"\n\t\t\tr_core_cmd0 (core, \"aef@@F\");\n\t\t} else if (input[1] == 'r') {\n\t\t\tut64 cur = core->offset;\n\t\t\tbool hasnext = r_config_get_b (core->config, \"anal.hasnext\");\n\t\t\tRListIter *iter;\n\t\t\tRIOMap *map;\n\t\t\tRList *list = r_core_get_boundaries_prot (core, R_PERM_X, NULL, \"anal\");\n\t\t\tif (!list) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\tr_core_seek (core, r_io_map_begin (map), true);\n\t\t\t\tr_config_set_b (core->config, \"anal.hasnext\", true);\n\t\t\t\tr_core_cmd_call (core, \"afr\");\n\t\t\t\tr_config_set_b (core->config, \"anal.hasnext\", hasnext);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t\tr_core_seek (core, cur, true);\n\t\t} else if (input[1] == 't') { // \"aaft\"\n\t\t\tcmd_anal_aaft (core);\n\t\t} else if (input[1] == 'f') { // \"aaff\"\n\t\t\tflag_every_function (core);\n\t\t} else if (input[1] == 's') { // \"aafs\"\n\t\t\tsingle_block_analysis (core);\n\t\t} else if (input[1] == 0) { // \"aaf\"\n\t\t\tconst bool analHasnext = r_config_get_b (core->config, \"anal.hasnext\");\n\t\t\tr_config_set_b (core->config, \"anal.hasnext\", true);\n\t\t\tr_core_cmd0 (core, \"afr@@c:isq\");\n\t\t\tr_config_set_b (core->config, \"anal.hasnext\", analHasnext);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_aaf);\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"aac\"\n\t\tswitch (input[1]) {\n\t\tcase '*': // \"aac*\"\n\t\t\tcmd_anal_calls (core, input + 1, true, false);\n\t\t\tbreak;\n\t\tcase 'i': // \"aaci\"\n\t\t\tcmd_anal_calls (core, input + 1, input[2] == '*', true);\n\t\t\tbreak;\n\t\tcase '?': // \"aac?\"\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aac\", false);\n\t\t\tbreak;\n\t\tdefault: // \"aac\"\n\t\t\tcmd_anal_calls (core, input + 1, false, false);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"aaj\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aaj\", true);\n\t\t} else {\n\t\t\tcmd_anal_jumps (core, input + 1);\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"aad\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aad\", true);\n\t\t} else {\n\t\t\tcmd_anal_aad (core, input);\n\t\t}\n\t\tbreak;\n\tcase 'v': // \"aav\"\n\t\tif (strchr (input + 1, '?')) {\n\t\t\tr_core_cmd_help (core, help_msg_aav);\n\t\t} else {\n\t\t\tcmd_anal_aav (core, input);\n\t\t}\n\t\tbreak;\n\tcase 'w': // \"aaw\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aaw\", true);\n\t\t} else {\n\t\t\tcmd_anal_aaw (core, input);\n\t\t}\n\t\tbreak;\n\tcase 'u': // \"aau\" - print areas not covered by functions\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aau\", true);\n\t\t} else {\n\t\t\tr_core_anal_nofunclist (core, input + 1);\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"aai\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aai\", true);\n\t\t} else {\n\t\t\tr_core_anal_info (core, input + 1);\n\t\t}\n\t\tbreak;\n\tcase 's': // \"aas\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aas\", true);\n\t\t} else {\n\t\t\tr_core_cmd0 (core, \"af @@= `isq~[0]`\");\n\t\t\tr_core_cmd0 (core, \"af @@f:entry*\");\n\t\t}\n\t\tbreak;\n\tcase 'S': // \"aaS\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aaS\", true);\n\t\t} else {\n\t\t\tr_core_cmd0 (core, \"af @@f:sym.*\");\n\t\t\tr_core_cmd0 (core, \"af @@f:entry*\");\n\t\t}\n\t\tbreak;\n\tcase 'F': // \"aaF\" \"aaFa\"\n\t\tif (!input[1] || input[1] == ' ' || input[1] == 'a') {\n\t\t\tr_core_anal_inflags (core, input + 1);\n\t\t} else {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aaF\", false);\n\t\t}\n\t\tbreak;\n\tcase 'n': // \"aan\"\n\t\tswitch (input[1]) {\n\t\tcase 'r': // \"aanr\" // all noreturn propagation\n\t\t\tr_core_anal_propagate_noreturn (core, UT64_MAX);\n\t\t\tbreak;\n\t\tcase 'g': // \"aang\"\n\t\t\tr_core_anal_autoname_all_golang_fcns (core);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_aan);\n\t\t\tbreak;\n\t\tcase 'f': // \"aanf\" same as \"aan\" but more friendly\n\t\tdefault: // \"aan\"\n\t\t\tr_core_anal_autoname_all_fcns (core);\n\t\t}\n\t\tbreak;\n\tcase 'p': // \"aap\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aap\", true);\n\t\t} else {\n\t\t\tr_core_search_preludes (core, true);\n\t\t}\n\t\tbreak;\n\tcase '\\0': // \"aa\"\n\tcase 'a':\n\t\tif (strchr (input, '?')) {\n\t\t\tr_core_cmd_help (core, help_msg_aaa);\n\t\t} else {\n\t\t\tbool didAap = false;\n\t\t\tchar *dh_orig = NULL;\n\t\t\tif (!strncmp (input, \"aaaaa\", 5)) {\n\t\t\t\tR_LOG_INFO (\"We fired the r2 developer that was heading to your location to help you analyze this binary\");\n\t\t\t\tR_LOG_INFO (\"Contact support for premium service\");\n\t\t\t\tif (r_cons_is_interactive ()) {\n\t\t\t\t\tr_cons_any_key (NULL);\n\t\t\t\t}\n\t\t\t\tgoto jacuzzi;\n\t\t\t}\n\t\t\tut64 curseek = core->offset;\n\t\t\tR_LOG_INFO (\"Analyze all flags starting with sym. and entry0 (aa)\");\n\t\t\tr_cons_break_push (NULL, NULL);\n\t\t\tr_cons_break_timeout (r_config_get_i (core->config, \"anal.timeout\"));\n\t\t\tr_core_anal_all (core);\n\t\t\tr_core_task_yield (&core->tasks);\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto jacuzzi;\n\t\t\t}\n\n\t\t\t// Run afvn in all fcns\n\t\t\tif (r_config_get_b (core->config, \"anal.vars\")) {\n\t\t\t\tR_LOG_INFO (\"Analyze all functions arguments/locals (afva@@@F)\");\n\t\t\t\t// r_core_cmd0 (core, \"afva@@f\");\n\t\t\t\tr_core_cmd0 (core, \"afva@@@F\");\n\t\t\t}\n\n\t\t\t// Run pending analysis immediately after analysis\n\t\t\t// Usefull when running commands with \";\" or via r2 -c,-i\n\t\t\tdh_orig = core->dbg->current\n\t\t\t\t? strdup (core->dbg->current->plugin.meta.name)\n\t\t\t\t: strdup (\"esil\");\n\t\t\tif (core->io->desc && core->io->desc->plugin && !core->io->desc->plugin->isdbg) {\n\t\t\t\t//use dh_origin if we are debugging\n\t\t\t\tR_FREE (dh_orig);\n\t\t\t}\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto jacuzzi;\n\t\t\t}\n\t\t\tr_cons_clear_line (1);\n\t\t\tbool cfg_debug = r_config_get_b (core->config, \"cfg.debug\");\n\t\t\tif (*input == 'a') { // \"aaa\" .. which is checked just in the case above\n\t\t\t\tif (r_str_startswith (r_config_get (core->config, \"bin.lang\"), \"go\")) {\n\t\t\t\t\tR_LOG_INFO (\"Find function and symbol names from golang binaries (aang)\");\n\t\t\t\t\tr_core_anal_autoname_all_golang_fcns (core);\n\t\t\t\t\tR_LOG_INFO (\"Analyze all flags starting with sym.go. (aF @@f:sym.go.*)\");\n\t\t\t\t\tr_core_cmd0 (core, \"aF @@@F:sym.go.*\");\n\t\t\t\t}\n\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\tif (!cfg_debug) {\n\t\t\t\t\tif (dh_orig && strcmp (dh_orig, \"esil\")) {\n\t\t\t\t\t\tr_core_cmd_call (core, \"dL esil\");\n\t\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// XXX do not override user settings!\n\t\t\t\t// int c = r_config_get_i (core->config, \"anal.calls\");\n\t\t\t\t// r_config_set_b (core->config, \"anal.calls\", true);\n\t\t\t\tr_core_cmd_call (core, \"s $S\");\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\n\t\t\t\tR_LOG_INFO (\"Analyze function calls (aac)\");\n\t\t\t\t(void)cmd_anal_calls (core, \"\", false, false); // \"aac\"\n\t\t\t\tr_core_seek (core, curseek, true);\n\t\t\t\t// R_LOG_INFO (\"Analyze data refs as code (LEA)\");\n\t\t\t\t// (void) cmd_anal_aad (core, NULL); // \"aad\"\n\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\n\t\t\t\tif (is_unknown_file (core)) {\n\t\t\t\t\tR_LOG_INFO (\"find and analyze function preludes (aap)\");\n\t\t\t\t\t(void)r_core_search_preludes (core, false); // \"aap\"\n\t\t\t\t\tdidAap = true;\n\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tR_LOG_INFO (\"Analyze len bytes of instructions for references (aar)\");\n\t\t\t\t(void)r_core_anal_refs (core, \"\"); // \"aar\"\n\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\t\t\t\tif (is_apple_target (core)) {\n\t\t\t\t\tR_LOG_INFO (\"Check for objc references (aao)\");\n\t\t\t\t\tcmd_anal_objc (core, input + 1, true);\n\t\t\t\t}\n\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\tR_LOG_INFO (\"Finding and parsing C++ vtables (avrr)\");\n\t\t\t\tr_core_cmd_call (core, \"avrr\");\n\t\t\t\tr_core_cmd0 (core, \"af @@ method.*\");\n\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t// r_config_set_b (core->config, \"anal.calls\", c);\n\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\t\t\t\tconst bool isPreludableArch = core->rasm->config->bits == 64 && r_str_startswith (r_config_get (core->config, \"asm.arch\"), \"arm\");\n\n\t\t\t\tif (!didAap && isPreludableArch) {\n\t\t\t\t\tdidAap = true;\n\t\t\t\t\tR_LOG_INFO (\"Finding function preludes (aap)\");\n\t\t\t\t\t(void)r_core_search_preludes (core, false); // \"aap\"\n\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t}\n\t\t\t\tif (!r_str_startswith (r_config_get (core->config, \"asm.arch\"), \"x86\")) {\n\t\t\t\t\tr_core_cmd_call (core, \"aav\");\n\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t\tif (cfg_debug) {\n\t\t\t\t\t\tR_LOG_INFO (\"Skipping function emulation in debugger mode (aaef)\");\n\t\t\t\t\t\t// nothing to do\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst bool io_cache = r_config_get_i (core->config, \"io.pcache\");\n\t\t\t\t\t\tr_config_set_b (core->config, \"io.pcache\", true);\n\t\t\t\t\t\tR_LOG_INFO (\"Emulate functions to find computed references (aaef)\");\n\t\t\t\t\t\tr_core_cmd_call (core, \"aaef\");\n\t\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t\t\tr_config_set_b (core->config, \"io.pcache\", io_cache);\n\t\t\t\t\t}\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (r_config_get_i (core->config, \"anal.autoname\")) {\n\t\t\t\t\tR_LOG_INFO (\"Speculatively constructing a function name for fcn.* and sym.func.* functions (aan)\");\n\t\t\t\t\tr_core_anal_autoname_all_fcns (core);\n\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t}\n\t\t\t\tif (core->anal->opt.vars) {\n\t\t\t\t\tRAnalFunction *fcni;\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tr_list_foreach (core->anal->fcns, iter, fcni) {\n\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tRList *list = r_anal_var_list (core->anal, fcni, 'r');\n\t\t\t\t\t\tif (!r_list_empty (list)) {\n\t\t\t\t\t\t\tr_list_free (list);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// extract only reg based var here\n\t\t\t\t\t\tr_core_recover_vars (core, fcni, true);\n\t\t\t\t\t\tr_list_free (list);\n\t\t\t\t\t}\n\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t}\n\t\t\t\tif (!sdb_isempty (core->anal->sdb_zigns)) {\n\t\t\t\t\tR_LOG_INFO (\"Check for zignature from zigns folder (z/)\");\n\t\t\t\t\tr_core_cmd_call (core, \"z/\");\n\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t}\n\t\t\t\tif (cfg_debug) {\n\t\t\t\t\tR_LOG_INFO (\"Skipping type matching analysis in debugger mode (aaft)\");\n\t\t\t\t\t// nothing to do\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_INFO (\"Type matching analysis for all functions (aaft)\");\n\t\t\t\t\tr_core_cmd_call (core, \"aaft\");\n\t\t\t\t}\n\t\t\t\tr_core_task_yield (&core->tasks);\n\n\t\t\t\tR_LOG_INFO (\"Propagate noreturn information (aanr)\");\n\t\t\t\tr_core_anal_propagate_noreturn (core, UT64_MAX);\n\t\t\t\tr_core_task_yield (&core->tasks);\n\n\t\t\t\t// apply dwarf function information\n\t\t\t\tSdb *dwarf_sdb = sdb_ns (core->anal->sdb, \"dwarf\", 0);\n\t\t\t\tif (dwarf_sdb) {\n\t\t\t\t\tR_LOG_INFO (\"Integrate dwarf function information\");\n\t\t\t\t\tr_anal_dwarf_integrate_functions (core->anal, core->flags, dwarf_sdb);\n\t\t\t\t}\n\n\t\t\t\tif (input[1] == 'a') { // \"aaaa\"\n\t\t\t\t\tR_LOG_INFO (\"Scanning for strings constructed in code (/azs)\");\n\t\t\t\t\tr_core_cmd_call (core, \"/azs\");\n\t\t\t\t\tif (!didAap) {\n\t\t\t\t\t\tdidAap = true;\n\t\t\t\t\t\tR_LOG_INFO (\"Finding function preludes (aap)\");\n\t\t\t\t\t\t(void)r_core_search_preludes (core, false); // \"aap\"\n\t\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t\t}\n\t\t\t\t\tR_LOG_INFO (\"Enable anal.types.constraint for experimental type propagation\");\n\t\t\t\t\tr_config_set_b (core->config, \"anal.types.constraint\", true);\n\t\t\t\t\tif (input[2] == 'a') { // \"aaaa\"\n\t\t\t\t\t\tR_LOG_INFO (\"Reanalizing graph references to improve function count (aarr)\");\n\t\t\t\t\t\tr_core_cmd_call (core, \"aarr\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_INFO (\"Use -AA or aaaa to perform additional experimental analysis\");\n\t\t\t\t}\n\t\t\t\tr_core_cmd_call (core, \"s-\");\n\t\t\t\tif (dh_orig) {\n\t\t\t\t\tr_core_cmdf (core, \"dL %s\", dh_orig);\n\t\t\t\t\tr_core_task_yield (&core->tasks);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_core_seek (core, curseek, true);\n\t\tjacuzzi:\n\t\t\t// XXX this shouldnt be called. flags muts be created wheen the function is registered\n\t\t\tflag_every_function (core);\n\t\t\tr_core_anal_propagate_noreturn (core, UT64_MAX);\n\t\t\tr_cons_break_pop ();\n\t\t\tR_FREE (dh_orig);\n\t\t}\n\t\tbreak;\n\tcase 't': // \"aat\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aat\", true);\n\t\t} else {\n\t\t\tchar *off = input[1]? r_str_trim_dup (input + 2): NULL;\n\t\t\tRAnalFunction *fcn;\n\t\t\tRListIter *it;\n\t\t\tif (off && *off) {\n\t\t\t\tut64 addr = r_num_math (NULL, off);\n\t\t\t\tfcn = r_anal_get_function_at (core->anal, core->offset);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_core_link_stroff (core, fcn);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot find function at %08\" PFMT64x, addr);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (r_list_empty (core->anal->fcns)) {\n\t\t\t\t\tR_LOG_ERROR (\"Couldn't find any functions\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tr_core_link_stroff (core, fcn);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (off);\n\t\t}\n\t\tbreak;\n\tcase 'T': // \"aaT\"\n\t\tcmd_anal_aftertraps (core, input + 1);\n\t\tbreak;\n\tcase 'o': // \"aao\"\n\t\tif (input[1] == '?') { // \"aao?\"\n\t\t\tr_core_cmd_help_match (core, help_msg_aa, \"aao\", true);\n\t\t} else {\n\t\t\tcmd_anal_objc (core, input + 1, false);\n\t\t}\n\t\tbreak;\n\tcase 'e': // \"aae\"\n\t\tif (input[1] == 'f') { // \"aaef\"\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_aae, \"aaef\", true);\n\t\t\t} else {\n\t\t\t\tr_core_cmd0 (core, \"aeim\");\n\t\t\t\tRListIter *it;\n\t\t\t\tRAnalFunction *fcn;\n\t\t\t\tut64 cur_seek = core->offset;\n\t\t\t\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\t\t\t\tr_core_seek (core, fcn->addr, true);\n\t\t\t\t\tr_core_anal_esil (core, \"f\", NULL);\n\t\t\t\t\t// __anal_esil_function (core, fcn->addr);\n\t\t\t\t}\n\t\t\t\tr_core_seek (core, cur_seek, true);\n\t\t\t}\n\t\t} else if (input[1] == '?') { // \"aae?\"\n\t\t\tr_core_cmd_help (core, help_msg_aae);\n\t\t} else if (input[1] == 'p') { // \"aaep\" // auto define all esil pins\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_aae, \"aaef\", true);\n\t\t\t} else {\n\t\t\t\tr_core_cmd0 (core, \"aep ret0@@@i\");\n\t\t\t\tr_core_cmd0 (core, \"aepa@@@i\");\n\t\t\t}\n\t\t} else if (input[1] == ' ') { // \"aae \"\n\t\t\tchar *arg = r_str_trim_dup (input + 1);\n\t\t\tconst char *len = (char *)arg;\n\t\t\tchar *addr = strchr (arg, ' ');\n\t\t\tif (addr) {\n\t\t\t\t*addr = 0;\n\t\t\t\taddr = (char *)r_str_trim_head_ro (addr + 1);\n\t\t\t}\n\t\t\tr_core_cmd0 (core, \"aeim\");\n\t\t\tr_core_anal_esil (core, len, addr);\n\t\t\tfree (arg);\n\t\t} else {\n\t\t\tut64 at = core->offset;\n\t\t\tRIOMap *map;\n\t\t\tRListIter *iter;\n\t\t\tRList *list = r_core_get_boundaries_prot (core, -1, NULL, \"anal\");\n\t\t\tif (!list) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!strcmp (\"range\", r_config_get (core->config, \"anal.in\"))) {\n\t\t\t\tut64 from = r_config_get_i (core->config, \"anal.from\");\n\t\t\t\tut64 to = r_config_get_i (core->config, \"anal.to\");\n\t\t\t\tif (to > from) {\n\t\t\t\t\tchar *len = r_str_newf (\" 0x%\"PFMT64x, to - from);\n\t\t\t\t\tr_core_seek (core, from, true);\n\t\t\t\t\tr_core_anal_esil (core, len, NULL);\n\t\t\t\t\tfree (len);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Assert: anal.from > anal.to\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\t\tif (map->perm & R_PERM_X) {\n\t\t\t\t\t\tchar *ss = r_str_newf (\" 0x%\"PFMT64x, r_io_map_size (map));\n\t\t\t\t\t\tr_core_seek (core, r_io_map_begin (map), true);\n\t\t\t\t\t\tr_core_anal_esil (core, ss, NULL);\n\t\t\t\t\t\tfree (ss);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t\tr_core_seek (core, at, true);\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"aar\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_aar);\n\t\t} else if (input[1] == 'r') { // \"aarr\"\n\t\t\tanal_aarr (core);\n\t\t} else {\n\t\t\t(void)r_core_anal_refs (core, input + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_aa);\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic bool anal_fcn_data(RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_ANY);\n\tif (fcn) {\n\t\tint i;\n\t\tbool gap = false;\n\t\tut64 gap_addr = UT64_MAX;\n\t\tut32 fcn_size = r_anal_function_size_from_entry (fcn);\n\t\tchar *bitmap = calloc (1, fcn_size);\n\t\tif (bitmap) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint f = b->addr - fcn->addr;\n\t\t\t\tint t = R_MIN (f + b->size, fcn_size);\n\t\t\t\tif (f >= 0) {\n\t\t\t\t\twhile (f < t) {\n\t\t\t\t\t\tbitmap[f++] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < fcn_size; i++) {\n\t\t\tut64 here = fcn->addr + i;\n\t\t\tif (bitmap && bitmap[i]) {\n\t\t\t\tif (gap) {\n\t\t\t\t\tr_cons_printf (\"Cd %\" PFMT64u \" @ 0x%08\"PFMT64x\"\\n\", here - gap_addr, gap_addr);\n\t\t\t\t\tgap = false;\n\t\t\t\t}\n\t\t\t\tgap_addr = UT64_MAX;\n\t\t\t} else {\n\t\t\t\tif (!gap) {\n\t\t\t\t\tgap = true;\n\t\t\t\t\tgap_addr = here;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gap) {\n\t\t\tr_cons_printf (\"Cd %\" PFMT64u \" @ 0x%08\" PFMT64x \"\\n\", fcn->addr + fcn_size - gap_addr, gap_addr);\n\t\t}\n\t\tfree (bitmap);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool anal_fcn_data_gaps(RCore *core, const char *input) {\n\tut64 end = UT64_MAX;\n\tRAnalFunction *fcn;\n\tRListIter *iter;\n\tint i, wordsize = (core->rasm->config->bits == 64)? 8: 4;\n\tr_list_sort (core->anal->fcns, cmpaddr);\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tif (end != UT64_MAX) {\n\t\t\tint range = fcn->addr - end;\n\t\t\tif (range > 0) {\n\t\t\t\tfor (i = 0; i + wordsize < range; i+= wordsize) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", wordsize, end + i);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", range - i, end + i);\n\t\t\t\t//r_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", range, end);\n\t\t\t}\n\t\t}\n\t\tend = fcn->addr + r_anal_function_size_from_entry (fcn);\n\t}\n\treturn true;\n}\n\nstatic void cmd_anal_rtti(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase '\\0': // \"avr\"\n\tcase 'j': // \"avrj\"\n\t\tr_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);\n\t\tbreak;\n\tcase 'a': // \"avra\"\n\t\tr_anal_rtti_print_all (core->anal, input[1]);\n\t\tbreak;\n\tcase 'r': // \"avrr\"\n\t\tr_anal_rtti_recover_all (core->anal);\n\t\tbreak;\n\tcase 'D': { // \"avrD\"\n\t\tchar *name = r_str_trim_dup (input + 1);\n\t\tchar *demangled = r_anal_rtti_demangle_class_name (core->anal, name);\n\t\tfree (name);\n\t\tif (demangled) {\n\t\t\tr_cons_println (demangled);\n\t\t\tfree (demangled);\n\t\t}\n\t\tbreak;\n\t}\n\tdefault :\n\t\tr_core_cmd_help (core, help_msg_av);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_avg(RCore *core, const char* input) {\n\tswitch (input[0]) {\n\tcase ' ':\n\t\tif (strchr (input + 1, ' ')) {\n\t\t\tchar *a = r_str_trim_dup (input + 1);\n\t\t\tchar *b = strchr (a, ' ');\n\t\t\tif (b) {\n\t\t\t\t*b++ = 0;\n\t\t\t\tr_anal_global_add (core->anal, core->offset, a, b);\n\t\t\t} else {\n\t\t\t\tRFlagItem *fi = r_anal_global_get (core->anal, core->offset);\n\t\t\t\tif (fi) {\n\t\t\t\t\tR_LOG_INFO (\"type %s\", fi->type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (a);\n\t\t}\n\t\tbreak;\n\tcase '-':\n\t\tr_anal_global_del (core->anal, core->offset);\n\t\tbreak;\n\tcase '\\0': // \"av\"\n\t\tr_core_cmd0 (core, \"fs+globals;f;fs-\");\n\t\tbreak;\n\tdefault :\n\t\tr_core_cmd_help (core, help_msg_avg);\n\t\tbreak;\n\t}\n}\nstatic void cmd_anal_virtual_functions(RCore *core, const char* input) {\n\tswitch (input[0]) {\n\tcase 'g':\n\t\tcmd_avg (core, input + 1);\n\t\tbreak;\n\tcase '\\0': // \"av\"\n\tcase '*': // \"av*\"\n\tcase 'j': // \"avj\"\n\t\tr_anal_list_vtables (core->anal, input[0]);\n\t\tbreak;\n\tcase 'r': // \"avr\"\n\t\tcmd_anal_rtti (core, input + 1);\n\t\tbreak;\n\tdefault :\n\t\tr_core_cmd_help (core, help_msg_av);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_class_method(RCore *core, const char *input) {\n\tRAnalClassErr err = R_ANAL_CLASS_ERR_SUCCESS;\n\tchar c = input[0];\n\tswitch (c) {\n\tcase ' ': // \"acm\"\n\tcase '-': // \"acm-\"\n\tcase 'n': { // \"acmn\"\n\t\tconst char *str = r_str_trim_head_ro (input + 1);\n\t\tif (!*str) {\n\t\t\tR_LOG_ERROR (\"No class name given\");\n\t\t\tbreak;\n\t\t}\n\t\tchar *cstr = strdup (str);\n\t\tif (!cstr) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *end = strchr (cstr, ' ');\n\t\tif (!end) {\n\t\t\tR_LOG_ERROR (\"No method name given\");\n\t\t\tfree (cstr);\n\t\t\tbreak;\n\t\t}\n\t\t*end = '\\0';\n\t\tchar *name_str = end + 1;\n\n\t\tif (c == ' ' || c == 'n') {\n\t\t\tend = strchr (name_str, ' ');\n\t\t\tif (!end) {\n\t\t\t\tif (c == ' ') {\n\t\t\t\t\tR_LOG_ERROR (\"No offset given\");\n\t\t\t\t} else if (c == 'n') {\n\t\t\t\t\tR_LOG_ERROR (\"No new method name given\");\n\t\t\t\t}\n\t\t\t\tfree (cstr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*end = '\\0';\n\t\t}\n\n\t\tif (c == ' ') {\n\t\t\tchar *addr_str = end + 1;\n\t\t\tend = strchr (addr_str, ' ');\n\t\t\tif (end) {\n\t\t\t\t*end = '\\0';\n\t\t\t}\n\n\t\t\tRAnalMethod meth;\n\t\t\tmeth.name = name_str;\n\t\t\tmeth.addr = r_num_get (core->num, addr_str);\n\t\t\tmeth.vtable_offset = -1;\n\t\t\tif (end) {\n\t\t\t\tmeth.vtable_offset = (int)r_num_get (core->num, end + 1);\n\t\t\t}\n\t\t\terr = r_anal_class_method_set (core->anal, cstr, &meth);\n\t\t} else if (c == 'n') {\n\t\t\tchar *new_name_str = end + 1;\n\t\t\tend = strchr (new_name_str, ' ');\n\t\t\tif (end) {\n\t\t\t\t*end = '\\0';\n\t\t\t}\n\n\t\t\terr = r_anal_class_method_rename (core->anal, cstr, name_str, new_name_str);\n\t\t} else if (c == '-') {\n\t\t\terr = r_anal_class_method_delete (core->anal, cstr, name_str);\n\t\t}\n\n\t\tfree (cstr);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ac);\n\t\tbreak;\n\t}\n\n\tswitch (err) {\n\tcase R_ANAL_CLASS_ERR_NONEXISTENT_CLASS:\n\t\tR_LOG_ERROR (\"Class does not exist\");\n\t\tbreak;\n\tcase R_ANAL_CLASS_ERR_NONEXISTENT_ATTR:\n\t\tR_LOG_ERROR (\"Method does not exist\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_class_base(RCore *core, const char *input) {\n\tRAnalClassErr err = R_ANAL_CLASS_ERR_SUCCESS;\n\tchar c = input[0];\n\tswitch (c) {\n\tcase ' ': // \"acb\"\n\tcase '-': { // \"acb-\"\n\t\tconst char *str = r_str_trim_head_ro (input + 1);\n\t\tif (!*str) {\n\t\t\tR_LOG_ERROR (\"No class name given\");\n\t\t\treturn;\n\t\t}\n\t\tchar *cstr = strdup (str);\n\t\tif (!cstr) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *end = strchr (cstr, ' ');\n\t\tif (end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\n\t\tif (!end || *end == '\\0') {\n\t\t\tif (c == ' ') {\n\t\t\t\tr_anal_class_list_bases (core->anal, cstr);\n\t\t\t} else /*if (c == '-')*/ {\n\t\t\t\tR_LOG_ERROR (\"No base id given\");\n\t\t\t}\n\t\t\tfree (cstr);\n\t\t\tbreak;\n\t\t}\n\n\t\tchar *base_str = end;\n\t\tend = strchr (base_str, ' ');\n\t\tif (end) {\n\t\t\t*end = '\\0';\n\t\t}\n\n\t\tif (c == '-') {\n\t\t\terr = r_anal_class_base_delete (core->anal, cstr, base_str);\n\t\t\tfree (cstr);\n\t\t\tbreak;\n\t\t}\n\n\t\tRAnalBaseClass base;\n\t\tbase.id = NULL;\n\t\tbase.offset = 0;\n\t\tbase.class_name = base_str;\n\n\t\tif (end) {\n\t\t\tbase.offset = r_num_get (core->num, end + 1);\n\t\t}\n\n\t\terr = r_anal_class_base_set (core->anal, cstr, &base);\n\t\tfree (base.id);\n\t\tfree (cstr);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ac);\n\t\tbreak;\n\t}\n\n\tif (err == R_ANAL_CLASS_ERR_NONEXISTENT_CLASS) {\n\t\tR_LOG_ERROR (\"Class does not exist\");\n\t}\n}\n\nstatic void cmd_anal_class_vtable(RCore *core, const char *input) {\n\tRAnalClassErr err = R_ANAL_CLASS_ERR_SUCCESS;\n\tchar c = input[0];\n\tswitch (c) {\n\tcase 'f': {// \"acvf\" [offset] ([class_name])\n\t\tconst char *str = r_str_trim_head_ro (input + 1);\n\t\tif (!*str) {\n\t\t\tR_LOG_ERROR (\"No offset given\");\n\t\t\treturn;\n\t\t}\n\t\tchar *cstr = strdup (str);\n\t\tif (!cstr) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *end = strchr (cstr, ' ');\n\t\tif (end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\t\tut64 offset_arg = r_num_get (core->num, cstr); // Should I allow negative offset?\n\t\tchar *class_arg = NULL;\n\t\tif (end) {\n\t\t\tclass_arg = (char *)r_str_trim_head_ro (end);\n\t\t}\n\n\t\tif (class_arg) {\n\t\t\tend = (char *)r_str_trim_head_wp (class_arg); // in case of extra unwanted stuff at the cmd end\n\t\t\t*end = '\\0';\n\t\t}\n\t\tr_anal_class_list_vtable_offset_functions (core->anal, class_arg, offset_arg);\n\n\t\tfree (cstr);\n\t\tbreak;\n\t}\n\tcase ' ': // \"acv\"\n\tcase '-': { // \"acv-\"\n\t\tconst char *str = r_str_trim_head_ro (input + 1);\n\t\tif (!*str) {\n\t\t\tR_LOG_ERROR (\"No class name given\");\n\t\t\treturn;\n\t\t}\n\t\tchar *cstr = strdup (str);\n\t\tif (!cstr) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *end = strchr (cstr, ' ');\n\t\tif (end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\n\t\tif (!end || *end == '\\0') {\n\t\t\tif (c == ' ') {\n\t\t\t\tr_anal_class_list_vtables (core->anal, cstr);\n\t\t\t} else /*if (c == '-')*/ {\n\t\t\t\tR_LOG_ERROR (\"No vtable id given. See acv [class name]\");\n\t\t\t}\n\t\t\tfree (cstr);\n\t\t\tbreak;\n\t\t}\n\n\t\tchar *arg1_str = end;\n\n\t\tif (c == '-') {\n\t\t\terr = r_anal_class_vtable_delete (core->anal, cstr, arg1_str);\n\t\t\tfree (cstr);\n\t\t\tbreak;\n\t\t}\n\n\t\tend = strchr (arg1_str, ' ');\n\t\tif (end) {\n\t\t\t*end = '\\0';\n\t\t}\n\n\t\tRAnalVTable vtable;\n\t\tvtable.id = NULL;\n\t\tvtable.addr = r_num_get (core->num, arg1_str);\n\t\tvtable.offset = 0;\n\t\tvtable.size = 0;\n\n\t\tchar *arg3_str = NULL;\n\t\tif (end) {\n\t\t\tvtable.offset = r_num_get (core->num, end + 1);\n\t\t\t// end + 1 won't work on extra whitespace between arguments, TODO\n\t\t\targ3_str = strchr (end + 1, ' ');\n\t\t}\n\n\t\tif (arg3_str) {\n\t\t\tvtable.size = r_num_get (core->num, arg3_str + 1);\n\t\t}\n\n\t\terr = r_anal_class_vtable_set (core->anal, cstr, &vtable);\n\t\tfree (vtable.id);\n\t\tfree (cstr);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ac);\n\t\tbreak;\n\t}\n\tif (err == R_ANAL_CLASS_ERR_NONEXISTENT_CLASS) {\n\t\tR_LOG_ERROR (\"Class does not exist\");\n\t}\n}\n\nstatic void cmd_anal_classes(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase 'l': // \"acl\"\n\t\tif (input[1] == 'l') { // \"acll\" (name)\n\t\t\tchar mode = 0;\n\t\t\tint arg_offset = 2;\n\t\t\tif (input[2] == 'j') {\n\t\t\t\targ_offset++;\n\t\t\t\tmode = 'j';\n\t\t\t}\n\t\t\tconst char *arg = r_str_trim_head_ro (input + arg_offset);\n\t\t\tif (*arg) { // if there is an argument\n\t\t\t\tchar *class_name = strdup (arg);\n\t\t\t\tif (!class_name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *name_end = (char *)r_str_trim_head_wp (class_name);\n\t\t\t\t*name_end = 0; // trim the whitespace around the name\n\t\t\t\tif (mode == 'j') {\n\t\t\t\t\tPJ *pj = pj_new ();\n\t\t\t\t\tr_anal_class_json (core->anal, pj, class_name);\n\t\t\t\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\t\t\t\tpj_free (pj);\n\t\t\t\t} else {\n\t\t\t\t\tr_anal_class_print (core->anal, class_name, true);\n\t\t\t\t}\n\t\t\t\tfree (class_name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tr_anal_class_list (core->anal, input[1]);\n\t\tbreak;\n\tcase ' ': // \"ac\"\n\tcase '-': // \"ac-\"\n\tcase 'n': { // \"acn\"\n\t\tconst char *str = r_str_trim_head_ro (input + 1);\n\t\tif (!*str) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *cstr = strdup (str);\n\t\tif (!cstr) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *end = strchr (cstr, ' ');\n\t\tif (end) {\n\t\t\t*end = '\\0';\n\t\t}\n\t\tif (input[0] == '-') {\n\t\t\tr_anal_class_delete (core->anal, cstr);\n\t\t} else if (input[0] == 'n') {\n\t\t\tif (!end) {\n\t\t\t\tR_LOG_ERROR (\"No new class name given\");\n\t\t\t} else {\n\t\t\t\tchar *new_name = end + 1;\n\t\t\t\tend = strchr (new_name, ' ');\n\t\t\t\tif (end) {\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t}\n\t\t\t\tRAnalClassErr err = r_anal_class_rename (core->anal, cstr, new_name);\n\t\t\t\tif (err == R_ANAL_CLASS_ERR_NONEXISTENT_CLASS) {\n\t\t\t\t\tR_LOG_ERROR (\"Class does not exist\");\n\t\t\t\t} else if (err == R_ANAL_CLASS_ERR_CLASH) {\n\t\t\t\t\tR_LOG_ERROR (\"A class with this name already exists\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tr_anal_class_create (core->anal, cstr);\n\t\t}\n\t\tfree (cstr);\n\t\tbreak;\n\t}\n\tcase 'v':\n\t\tcmd_anal_class_vtable (core, input + 1);\n\t\tbreak;\n\tcase 'b': // \"acb\"\n\t\tcmd_anal_class_base (core, input + 1);\n\t\tbreak;\n\tcase 'm': // \"acm\"\n\t\tcmd_anal_class_method (core, input + 1);\n\t\tbreak;\n\tcase 'g': { // \"acg\"\n\t\tRGraph *graph = r_anal_class_get_inheritance_graph (core->anal);\n\t\tif (!graph) {\n\t\t\tR_LOG_ERROR (\"Couldn't create graph\");\n\t\t\tbreak;\n\t\t}\n\t\tr_core_graph_print (core, graph, -1, false, input + 1);\n\t\tr_graph_free (graph);\n\t} break;\n\tdefault: // \"ac?\"\n\t\tr_core_cmd_help (core, help_msg_ac);\n\t\tbreak;\n\t}\n}\n\nstatic void show_reg_args(RCore *core, int nargs, RStrBuf *sb) {\n\tint i;\n\tchar regname[16];\n\tif (nargs < 0) {\n\t\tnargs = 4; // default args if not defined\n\t}\n\tfor (i = 0; i < nargs; i++) {\n\t\tsnprintf (regname, sizeof (regname), \"A%d\", i);\n\t\tut64 v = r_reg_getv (core->anal->reg, regname);\n\t\tif (sb) {\n\t\t\tr_strbuf_appendf (sb, \"%s0x%08\"PFMT64x, i? \", \": \"\", v);\n\t\t} else {\n\t\t\tr_cons_printf (\"A%d 0x%08\"PFMT64x\"\\n\", i, v);\n\t\t}\n\t}\n}\n\n// ripped from disasm.c: dupe code from there\n// TODO: Implement aC* and aCj\nstatic void cmd_anal_aC(RCore *core, const char *input) {\n\tbool is_aCer = false;\n\tconst char *cc = r_anal_cc_default (core->anal);\n\tRAnalFuncArg *arg;\n\tRListIter *iter;\n\tRListIter *nextele;\n\tconst char *iarg = strchr (input, ' ');\n\tif (input[0] == 'e' && input[1] == 'f') { // \"aCf\"\n\t\t// hacky :D\n\t\tr_core_cmdf (core, \".aCe* $$ @@=`pdr~call`\");\n\t\treturn;\n\t}\n\tif (iarg) {\n\t\tiarg++;\n\t}\n\tif (!iarg) {\n\t\tr_core_cmd_help (core, help_msg_aC);\n\t\treturn;\n\t}\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tut64 pcv = r_num_math (core->num, iarg);\n\tif (input[0] == 'e') { // \"aCe\"\n\t\tis_aCer = (input[1] == '*');\n\t\tr_core_cmdf (core, \".abpe 0x%08\"PFMT64x, pcv);\n\t}\n\tRAnalOp* op = r_core_anal_op (core, pcv, -1);\n\tif (!op) {\n\t\tr_strbuf_free (sb);\n\t\treturn;\n\t}\n\tbool go_on = true;\n\tif (op->type != R_ANAL_OP_TYPE_CALL) {\n\t\tshow_reg_args (core, -1, sb);\n\t\tgo_on = false;\n\t}\n\tconst char *fcn_name = NULL;\n\tRAnalFunction *fcn;\n\tif (go_on) {\n\t\tfcn = r_anal_get_function_at (core->anal, pcv);\n\t\tif (fcn) {\n\t\t\tfcn_name = fcn->name;\n\t\t} else {\n\t\t\tRFlagItem *item = r_flag_get_i (core->flags, op->jump);\n\t\t\tif (item) {\n\t\t\t\tfcn_name = item->name;\n\t\t\t}\n\t\t}\n\t\tchar *key = (fcn_name)? resolve_fcn_name (core->anal, fcn_name): NULL;\n\t\tif (key) {\n\t\t\tconst char *fcn_type = r_type_func_ret (core->anal->sdb_types, key);\n\t\t\tint nargs = r_type_func_args_count (core->anal->sdb_types, key);\n\t\t\t// remove other comments\n\t\t\tif (fcn_type) {\n\t\t\t\tr_strbuf_appendf (sb, \"%s%s%s(\", r_str_getf (fcn_type),\n\t\t\t\t\t\t(*fcn_type && fcn_type[strlen (fcn_type) - 1] == '*') ? \"\" : \" \",\n\t\t\t\t\t\tr_str_getf (key));\n\t\t\t\tif (!nargs) {\n\t\t\t\t\tr_strbuf_append (sb, \"void)\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot find any function signature\");\n\t\t\t}\n\t\t\tfree (key);\n\t\t} else {\n\t\t\tif (is_aCer) {\n\t\t\t\tshow_reg_args (core, -1, sb);\n\t\t\t\tgo_on = true;\n\t\t\t} else {\n\t\t\t\tshow_reg_args (core, -1, NULL);\n\t\t\t\tgo_on = false;\n\t\t\t}\n\t\t}\n\t}\n\tif (go_on) {\n\t\tut64 s_width = (core->anal->config->bits == 64)? 8: 4;\n\t\tconst char *sp = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\t\tut64 spv = r_reg_getv (core->anal->reg, sp);\n\t\tr_reg_setv (core->anal->reg, sp, spv + s_width); // temporarily set stack ptr to sync with carg.c\n\t\tRList *list = r_core_get_func_args (core, fcn_name);\n\t\tif (!r_list_empty (list)) {\n\t#if 0\n\t\t\tbool warning = false;\n\t\t\tbool on_stack = false;\n\t\t\tr_list_foreach (list, iter, arg) {\n\t\t\t\tif (r_str_startswith (arg->cc_source, \"stack\")) {\n\t\t\t\t\ton_stack = true;\n\t\t\t\t}\n\t\t\t\tif (!arg->size) {\n\t\t\t\t\tr_cons_printf (\"%s: unk_size\", arg->c_type);\n\t\t\t\t\twarning = true;\n\t\t\t\t}\n\t#endif\n\t\t\tr_list_foreach (list, iter, arg) {\n\t\t\t\tnextele = r_list_iter_get_next (iter);\n\t\t\t\tif (!arg->fmt) {\n\t\t\t\t\tr_strbuf_appendf (sb, \"?%s\", nextele? \", \": \"\");\n\t\t\t\t} else {\n\t\t\t\t\t// print_fcn_arg (core, arg->orig_c_type, arg->name, arg->fmt, arg->src, on_stack, 0);\n\t\t\t\t\t// const char *fmt = arg->orig_c_type;\n\t\t\t\t\tut64 addr = arg->src;\n\t\t\t\t\tchar *res = r_core_cmd_strf (core, \"pfq %s @ 0x%08\" PFMT64x, arg->fmt, addr);\n\t\t\t\t\t// r_cons_printf (\"pfq *%s @ 0x%08\" PFMT64x\"\\n\", arg->fmt, addr);\n\t\t\t\t\tr_str_trim (res);\n\t\t\t\t\tr_strbuf_appendf (sb, \"%s\", res);\n\t\t\t\t\tfree (res);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_strbuf_append (sb, \")\");\n\t\t} else {\n\t\t\t// function name not resolved\n\t\t\tint i, nargs = 4; // DEFAULT_NARGS;\n\t\t\tif (fcn) {\n\t\t\t\t// @TODO: fcn->nargs should be updated somewhere and used here instead\n\t\t\t\tnargs = r_anal_var_count_args (fcn);\n\t\t\t}\n\t\t\tif (nargs > 0) {\n\t\t\t\tif (fcn_name) {\n\t\t\t\t\tr_strbuf_appendf (sb, \"; %s(\", fcn_name);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (sb, \"; 0x%\"PFMT64x\"(\", pcv);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < nargs; i++) {\n\t\t\t\t\tut64 v = r_debug_arg_get (core->dbg, cc, i);\n\t\t\t\t\tr_strbuf_appendf (sb, \"%s0x%\"PFMT64x, i?\", \":\"\", v);\n\t\t\t\t}\n\t\t\t\tr_strbuf_append (sb, \")\");\n\t\t\t}\n\t\t}\n\t\tr_list_free (list);\n\t\tr_reg_setv (core->anal->reg, sp, spv); // reset stack ptr\n\t}\n\tr_anal_op_free (op);\n\tchar *s = r_strbuf_drain (sb);\n\tif (is_aCer) {\n\t\tchar *u = r_base64_encode_dyn (s, -1);\n\t\tif (u) {\n\t\t\tr_cons_printf (\"CCu base64:%s\\n\", u);\n\t\t\tfree (u);\n\t\t}\n\t} else {\n\t\tr_cons_println (s);\n\t}\n\tfree (s);\n}\n\nstatic bool core_anal_abf(RCore *core, const char* input) {\n\tif (strchr (input, '?')) {\n\t\tr_core_cmd_help_match (core, help_msg_ab, \"abf\", true);\n\t\treturn false;\n\t}\n\tut64 addr = r_num_math (core->num, input);\n\tif (!addr || addr == UT64_MAX) {\n\t\taddr = core->offset;\n\t}\n\n\tRAnalBlock *bb, *bb2;\n\tRListIter *iter, *iter2, *bbiter;\n\tRAnalFunction *fcn;\n\tRList *bbs = r_anal_get_blocks_in (core->anal, addr);\n\tr_list_foreach (bbs, bbiter, bb) {\n\t\tif (!bb) {\n\t\t\tR_LOG_ERROR (\"Cannot find basic block\");\n\t\t\treturn false;\n\t\t}\n\t\tr_list_foreach (bb->fcns, iter, fcn) {\n\t\t\tr_list_foreach (fcn->bbs, iter2, bb2) {\n\t\t\t\tif (bb == bb2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (bb2->jump != UT64_MAX && bb2->jump == bb->addr) {\n\t\t\t\t\tr_cons_printf (\"0x%\"PFMT64x\"\\n\", bb2->addr);\n\t\t\t\t}\n\t\t\t\tif (bb2->fail != UT64_MAX && bb2->fail == bb->addr) {\n\t\t\t\t\tr_cons_printf (\"0x%\"PFMT64x\"\\n\", bb2->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void match_prelude(RCore *core, const char *input) {\n\tconst ut8 *prelude = (const ut8*)\"\\xe9\\x2d\"; //:fffff000\";\n\tconst int prelude_sz = 2;\n\tconst int bufsz = 4096;\n\tut8 *buf = calloc (1, bufsz);\n\tut64 off = core->offset;\n\tif (input[1] == ' ') {\n\t\toff = r_num_math (core->num, input + 1);\n\t}\n\tr_io_read_at (core->io, off - bufsz + prelude_sz, buf, bufsz);\n\t//const char *prelude = \"\\x2d\\xe9\\xf0\\x47\"; //:fffff000\";\n\tr_mem_reverse (buf, bufsz);\n\t//r_print_hexdump (NULL, off, buf, bufsz, 16, -16);\n\tconst ut8 *pos = r_mem_mem (buf, bufsz, prelude, prelude_sz);\n\tif (pos) {\n\t\tint delta = (size_t)(pos - buf);\n\t\t// R_LOG_DEBUG (\"POS = %d\", delta);\n\t\t// R_LOG_DEBUG (\"HIT = 0x%\"PFMT64x, off - delta);\n\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", off - delta);\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot find prelude\");\n\t}\n\tfree (buf);\n}\n\nstatic int cmd_apt(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase '?':\n\t\tr_core_cmd_help_match (core, help_msg_ap, \"apt\", false);\n\t\tbreak;\n\tcase '=':\n\tcase ' ':\n\t\tr_anal_tid_select (core->anal, atoi (input + 1));\n\t\tcore->dbg->reg = core->anal->reg;\n\t\tbreak;\n\tcase '+':\n\t\t{\n\t\t\tint tid = r_anal_tid_add (core->anal, atoi (input + 1));\n\t\t\tif (tid != -1) {\n\t\t\t\tcore->anal->thread = tid;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '-':\n\t\tr_anal_tid_kill (core->anal, atoi (input + 1));\n\t\tbreak;\n\tcase 0:\n\t\t{\n\t\t\tRListIter *iter;\n\t\t\tRAnalThread *t;\n\t\t\tr_list_foreach (core->anal->threads, iter, t) {\n\t\t\t\tconst int diff = (r_time_now () - t->birth) / 1000000;\n\t\t\t\tconst char cur = (t->id == core->anal->thread)? '*': '-';\n\t\t\t\tr_cons_printf (\"%c %d map=%d age=%ds\\n\", cur, t->id, t->map, diff);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int cmd_anal(void *data, const char *input) {\n\tconst char *r;\n\tRCore *core = (RCore *)data;\n\tut32 tbs = core->blocksize;\n\tswitch (input[0]) {\n\tcase 'p': // \"ap\"\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_ap);\n\t\t\tbreak;\n\t\tcase 'l': // \"apl\"\n\t\t\t// list function preludes\n\t\t\t{\n\t\t\t\tRSearchKeyword *k;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRList *list = r_anal_preludes (core->anal);\n\t\t\t\tr_list_foreach (list, iter, k) {\n\t\t\t\t\tchar *hex0 = r_hex_bin2strdup (k->bin_keyword, k->keyword_length);\n\t\t\t\t\tchar *hex1 = r_hex_bin2strdup (k->bin_binmask, k->binmask_length);\n\t\t\t\t\t// XXX must add an align field\n\t\t\t\t\tr_cons_printf (\"ap+ %s %s\\n\", hex0, hex1);\n\t\t\t\t\tfree (hex0);\n\t\t\t\t\tfree (hex1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't': // \"apt\"\n\t\t\tcmd_apt (core, input + 2);\n\t\t\tbreak;\n\t\tcase ' ':\n\t\tcase 0:\n\t\t\tmatch_prelude (core, r_str_trim_head_ro (input));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_ap);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '8':  // \"a8\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_a8);\n\t\t\tbreak;\n\t\t}\n\t\tut8 *buf = malloc (strlen (input) + 1);\n\t\tif (buf) {\n\t\t\tint len = r_hex_str2bin (input + 1, buf);\n\t\t\tif (len > 0) {\n\t\t\t\tcore_anal_bytes (core, buf, len, 0, input[1]);\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"ab\"\n\t\tswitch (input[1]) {\n\t\tcase '.': // \"ab.\"\n\t\t\tr_core_cmd_call (core, \"ab $$\");\n\t\t\tbreak;\n\t\tcase 'a': // \"aba\"\n\t\t\tr_core_cmdf (core, \"aeab%s\", input + 1);\n\t\t\tbreak;\n\t\tcase 'b': // \"abb\"\n\t\t\tcore_anal_bbs (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'c': // \"abc\"\n\t\t\tcmd_afbc (core, r_str_trim_head_ro (input + 2));\n\t\t\tbreak;\n\t\tcase 'o': // \"abo\"\n\t\t\tabo (core);\n\t\t\tbreak;\n\t\tcase 'e': // \"aeb\"\n\t\t\tr_core_cmdf (core, \"aeb%s\", input + 2);\n\t\t\tbreak;\n\t\tcase 'f': // \"abf\"\n\t\t\tcore_anal_abf (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'r': // \"abr\"\n\t\t\tcore_anal_bbs_range (core, input + 2);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tcmd_anal_abt (core, input + 2);\n\t\t\tbreak;\n\t\tcase ',': // \"ab,\"\n\t\tcase 'p': // \"abp\"\n\t\t\tcmd_anal_abp (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'l': // \"abl\"\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_abl);\n\t\t\t} else {\n\t\t\t\tanal_bb_list (core, input + 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j': { // \"abj\"\n\t\t\tut64 addr = core->offset;\n\t\t\tif (input[2] && input[2] != '.') {\n\t\t\t\taddr = r_num_math (core->num, input + 2);\n\t\t\t}\n\t\t\tr_core_cmd_call_at (core, addr, \"afbij\");\n\t\t\tbreak;\n\t\t}\n\t\tcase '-': // \"ab-\"\n\t\t\t  if (input[2] == '*') {\n\t\t\t\t  r_anal_block_reset (core->anal);\n\t\t\t  } else {\n\t\t\t\t  ut64 addr = core->offset;\n\t\t\t\t  if (input[2] == ' ') {\n\t\t\t\t\t  addr = r_num_math (core->num, input + 1);\n\t\t\t\t  }\n\t\t\t\t  r_anal_delete_block_at (core->anal, addr);\n\t\t\t  }\n\t\t\t  break;\n\t\tcase 0:\n\t\tcase ' ': // \"ab \"\n\t\t\t{\n\t\t\t\t// find block\n\t\t\t\tut64 addr = core->offset;\n\t\t\t\tif (input[1] && input[1] != '.') {\n\t\t\t\t\taddr = r_num_math (core->num, input + 1);\n\t\t\t\t}\n\t\t\t\tr_core_cmd_call_at (core, addr, \"afbi\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_ab);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"ac\"\n\t\tcmd_anal_classes (core, input + 1);\n\t\tbreak;\n\tcase 'C': // \"aC\"\n\t\tcmd_anal_aC (core, input + 1);\n\t\tbreak;\n\tcase 'i': cmd_anal_info (core, input + 1); break; // \"ai\"\n\tcase 'r': cmd_anal_reg (core, input + 1); break;  // \"ar\"\n\tcase 'e': cmd_anal_esil (core, input + 1, true); break; // \"ae\"\n\tcase 'L':\n\t\tswitch (input[1]) {\n\t\tcase 'j':\n\t\tcase 'q':\n\t\tcase 0:\n\t\t\tranal2_list (core, NULL, input[1]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// help\n\t\t\tr_core_cmd_help (core, help_msg_La);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'o': // \"ao\"\n\t\tcmd_anal_opcode (core, input + 1);\n\t\tbreak;\n\tcase 'O': // \"aO\"\n\t\tcmd_anal_bytes (core, input + 1);\n\t\tbreak;\n\tcase 'F': // \"aF\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_aF);\n\t\t\tbreak;\n\t\t}\n\t\tr_core_anal_fcn (core, core->offset, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n\t\tbreak;\n\tcase 'l':\n\t\t{\n\t\t\tRList *l = r_asm_cpus (core->rasm);\n\t\t\tRListIter *iter;\n\t\t\tchar *c;\n\t\t\tr_list_foreach (l, iter, c) {\n\t\t\t\tr_cons_printf (\"- %s\\n\", c);\n\t\t\t}\n\t\t\tr_list_free (l);\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"af\"\n\t\tif (!cmd_af (core, input)) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase 'n': // \"an\"\n\t\t{\n\t\tconst char *name = \"\";\n\t\tint mode = 0;\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_an);\n\t\t\tmode = -1;\n\t\t\tbreak;\n\t\tcase 'j':\n\t\tcase '*':\n\t\t\tmode = input[1];\n\t\t\tinput++;\n\t\t\tbreak;\n\t\t}\n\t\tif (mode >= 0) {\n\t\t\tif (input[1] == ' ') {\n\t\t\t\tname = input + 1;\n\t\t\t\twhile (name[0] == ' ') {\n\t\t\t\t\tname++;\n\t\t\t\t}\n\t\t\t\tchar *end = strchr (name, ' ');\n\t\t\t\tif (end) {\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (R_STR_ISEMPTY (name)) {\n\t\t\t\tname = NULL;\n\t\t\t}\n\t\t\tcmd_an (core, name, mode);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'g': // \"ag\"\n\t\tcmd_anal_graph (core, input + 1);\n\t\tbreak;\n\tcase 's': // \"as\"\n\t\tcmd_anal_syscall (core, input + 1);\n\t\tbreak;\n\tcase 'v': // \"av\"\n\t\tcmd_anal_virtual_functions (core, input + 1);\n\t\tbreak;\n\tcase 'x': // \"ax\"\n\t\tif (!cmd_anal_refs (core, input + 1)) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase '*': // \"a*\"\n\t\tr_core_cmd_call (core, \"afl*\");\n\t\tr_core_cmd_call (core, \"ah*\");\n\t\tr_core_cmd_call (core, \"ax*\");\n\t\tbreak;\n\tcase 'a': // \"aa\"\n\t\tif (!cmd_anal_all (core, input + 1)) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"ad\"\n\t\tswitch (input[1]) {\n\t\tcase 'f': // \"adf\"\n\t\t\tif (input[2] == 'g') {\n\t\t\t\tanal_fcn_data_gaps (core, r_str_trim_head_ro (input + 1));\n\t\t\t} else {\n\t\t\t\tanal_fcn_data (core, input + 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't': // \"adt\"\n\t\t\tcmd_anal_trampoline (core, input + 2);\n\t\t\tbreak;\n\t\tcase '.': // \"ad.\"\n\t\tcase ' ': { // \"ad\" // asm describe maybe? see aod instead\n\t\t\tconst int default_depth = 1;\n\t\t\tconst char *p;\n\t\t\tint a, b;\n\t\t\ta = r_num_math (core->num, input + 2);\n\t\t\tp = strchr (input + 2, ' ');\n\t\t\tb = p? r_num_math (core->num, p + 1): default_depth;\n\t\t\tif (a < 1) {\n\t\t\t\ta = 1;\n\t\t\t}\n\t\t\tif (b < 1) {\n\t\t\t\tb = 1;\n\t\t\t}\n\t\t\tr_core_anal_data (core, core->offset, a, b, 0);\n\t\t} break;\n\t\tcase 'k': // \"adk\"\n\t\t\tr = r_anal_data_kind (core->anal, core->offset, core->block, core->blocksize);\n\t\t\tr_cons_println (r);\n\t\t\tbreak;\n\t\tcase '\\0': // \"ad\"\n\t\t\tr_core_anal_data (core, core->offset, 2 + (core->blocksize / 4), 1, 0);\n\t\t\tbreak;\n\t\tcase '4': // \"ad4\"\n\t\t\tr_core_anal_data (core, core->offset, 2 + (core->blocksize / 4), 1, 4);\n\t\t\tbreak;\n\t\tcase '8': // \"ad8\"\n\t\t\tr_core_anal_data (core, core->offset, 2 + (core->blocksize / 4), 1, 8);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_ad);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'h': // \"ah\"\n\t\tcmd_anal_hint (core, input + 1);\n\t\tbreak;\n\tcase ':': // \"a:\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_acolon);\n\t\t} else if (input[1] == 'l' || !input[1]) {\n\t\t\tRListIter *iter;\n\t\t\tRAnalPlugin *ap;\n\t\t\tr_list_foreach (core->anal->plugins, iter, ap) {\n\t\t\t\tr_cons_println (ap->meta.name);\n\t\t\t}\n\t\t} else {\n\t\t\tr_anal_cmd (core->anal, r_str_trim_head_ro (input + 1));\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"aj\"\n\t\tr_core_cmd_call (core, \"aflj\");\n\t\tbreak;\n\tcase 0: // \"a\"\n\t\tr_core_cmd_call (core, \"aai\");\n\t\tbreak;\n\tcase '?':\n\t\tif (input[1] == 'j') {\n\t\t\tr_cons_cmd_help_json (help_msg_a);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_a);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_a);\n\t\tbreak;\n\t}\n\tif (tbs != core->blocksize) {\n\t\tr_core_block_size (core, tbs);\n\t}\n\tif (r_cons_is_breaked ()) {\n\t\tr_cons_clear_line (1);\n\t}\n\treturn 0;\n}\n"], "filenames": ["libr/arch/p/bf/plugin.c", "libr/core/cmd_anal.c"], "buggy_code_start_loc": [16, 8722], "buggy_code_end_loc": [205, 9261], "fixing_code_start_loc": [16, 8722], "fixing_code_end_loc": [210, 9258], "type": "CWE-787", "message": "Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.9.0.", "other": {"cve": {"id": "CVE-2023-4322", "sourceIdentifier": "security@huntr.dev", "published": "2023-08-14T16:15:09.497", "lastModified": "2024-01-21T03:03:06.933", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.9.0."}, {"lang": "es", "value": "Una vulnerabilidad de desbordamiento de b\u00fafer en la regi\u00f3n Heap de la memoria en el repositorio de GitHub radareorg/radare2 antes de 5.9.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.8.8", "matchCriteriaId": "457C1F54-03FF-4118-B729-8656B691B0E3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/ba919adb74ac368bf76b150a00347ded78b572dd", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/06e2484c-d6f1-4497-af67-26549be9fffd", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/64KUV6OGEVQ75QOV35PUVVDOJTKSJHYN/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SOZ6XCADVAPAIHMVSV3FUAN742BHXF55/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/ba919adb74ac368bf76b150a00347ded78b572dd"}}