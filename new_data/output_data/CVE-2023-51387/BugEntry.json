{"buggy_code": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.dromara.hertzbeat.common.config;\n\nimport com.googlecode.aviator.AviatorEvaluator;\nimport com.googlecode.aviator.lexer.token.OperatorType;\nimport com.googlecode.aviator.runtime.function.AbstractFunction;\nimport com.googlecode.aviator.runtime.type.*;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.regex.Pattern;\n\n/**\n * @author tomsun28\n *\n */\n@Configuration\n@Slf4j\npublic class AviatorConfiguration {\n\n    private static final int AVIATOR_LRU_CACHE_SIZE = 1024;\n\n    @Bean\n    public void configAviatorEvaluator() {\n        // \u914d\u7f6eAviatorEvaluator\u4f7f\u7528LRU\u7f13\u5b58\u7f16\u8bd1\u540e\u7684\u8868\u8fbe\u5f0f\n        AviatorEvaluator.getInstance()\n                .useLRUExpressionCache(AVIATOR_LRU_CACHE_SIZE)\n                .addFunction(new StrEqualFunction());\n\n        // \u914d\u7f6e\u81ea\u5b9a\u4e49aviator\u51fd\u6570\n        AviatorEvaluator.getInstance().addOpFunction(OperatorType.BIT_OR, new AbstractFunction() {\n            @Override\n            public AviatorObject call(final Map<String, Object> env, final AviatorObject arg1,\n                                      final AviatorObject arg2) {\n                try {\n                    Object value1 = arg1.getValue(env);\n                    Object value2 = arg2.getValue(env);\n                    Object currentValue = value1 == null ? value2 : value1;\n                    if (arg1.getAviatorType() == AviatorType.String) {\n                        return new AviatorString(String.valueOf(currentValue));\n                    } else {\n                        return AviatorDouble.valueOf(currentValue);\n                    }\n                } catch (Exception e) {\n                    log.error(e.getMessage());\n                }\n                return arg1.bitOr(arg2, env);\n            }\n            @Override\n            public String getName() {\n                return OperatorType.BIT_OR.getToken();\n            }\n        });\n\n        AviatorEvaluator.getInstance().addFunction(new StrContainsFunction());\n        AviatorEvaluator.getInstance().addFunction(new ObjectExistsFunction());\n        AviatorEvaluator.getInstance().addFunction(new StrMatchesFunction());\n    }\n\n    /**\n     * \u81ea\u5b9a\u4e49aviator\u5224\u65ad\u5b57\u7b26\u4e32\u662f\u5426\u76f8\u7b49\u51fd\u6570\n     */\n    private static class StrEqualFunction extends AbstractFunction {\n        @Override\n        public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2) {\n            if (arg1 == null || arg2 == null) {\n                return AviatorBoolean.FALSE;\n            }\n            Object leftTmp = arg1.getValue(env);\n            Object rightTmp = arg2.getValue(env);\n            if (leftTmp == null || rightTmp == null) {\n                return AviatorBoolean.FALSE;\n            }\n            String left = String.valueOf(leftTmp);\n            String right = String.valueOf(rightTmp);\n            return AviatorBoolean.valueOf(left.equalsIgnoreCase(right));\n        }\n        @Override\n        public String getName() {\n            return \"equals\";\n        }\n    }\n\n    /**\n     * \u81ea\u5b9a\u4e49aviator\u5224\u65ad\u5b57\u7b26\u4e321\u662f\u5426\u5305\u542b\u5b57\u7b26\u4e322 (case-insensitive)\n     */\n    private static class StrContainsFunction extends AbstractFunction {\n        @Override\n        public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2) {\n            if (arg1 == null || arg2 == null) {\n                return AviatorBoolean.FALSE;\n            }\n            Object leftTmp = arg1.getValue(env);\n            Object rightTmp = arg2.getValue(env);\n            if (leftTmp == null || rightTmp == null) {\n                return AviatorBoolean.FALSE;\n            }\n            String left = String.valueOf(leftTmp);\n            String right = String.valueOf(rightTmp);\n            return AviatorBoolean.valueOf(StringUtils.containsIgnoreCase(left, right));\n        }\n        @Override\n        public String getName() {\n            return \"contains\";\n        }\n    }\n\n    /**\n     * \u81ea\u5b9a\u4e49aviator\u5224\u65ad\u73af\u5883\u4e2d\u6b64\u5bf9\u8c61\u662f\u5426\u5b58\u5728\u503c\n     */\n    private static class ObjectExistsFunction extends AbstractFunction {\n        @Override\n        public AviatorObject call(Map<String, Object> env, AviatorObject arg) {\n            if (arg == null) {\n                return AviatorBoolean.FALSE;\n            }\n            Object keyTmp = arg.getValue(env);\n            if (Objects.isNull(keyTmp)) {\n                return AviatorBoolean.FALSE;\n            } else {\n                String key = String.valueOf(keyTmp);\n                return AviatorBoolean.valueOf(StringUtils.isNotEmpty(key));\n            }\n        }\n        @Override\n        public String getName() {\n            return \"exists\";\n        }\n    }\n\n    /**\n     * \u81ea\u5b9a\u4e49aviator\u5224\u65ad\u5b57\u7b26\u4e32\u662f\u5426\u5339\u914dregex\n     * - regex\u9700\u8981\u52a0\u4e0a\"\"\u6216\u8005''\n     */\n    private static class StrMatchesFunction extends AbstractFunction {\n        @Override\n        public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2) {\n            if (arg1 == null || arg2 == null) {\n                return AviatorBoolean.FALSE;\n            }\n            Object strTmp = arg1.getValue(env);\n            Object regexTmp = arg2.getValue(env);\n            if (strTmp == null || regexTmp == null) {\n                return AviatorBoolean.FALSE;\n            }\n            String str = String.valueOf(strTmp);\n            String regex = String.valueOf(regexTmp);\n            boolean isMatch = Pattern.compile(regex).matcher(str).matches();\n            return AviatorBoolean.valueOf(isMatch);\n        }\n        @Override\n        public String getName() {\n            return \"matches\";\n        }\n    }\n}\n", "package org.dromara.hertzbeat.common.config;\n\nimport com.googlecode.aviator.AviatorEvaluator;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author mikezzb\n *\n */\nclass AviatorConfigurationTest {\n\n    @BeforeAll\n    static void setUp() {\n        AviatorConfiguration aviatorConfig = new AviatorConfiguration();\n        aviatorConfig.configAviatorEvaluator();\n    }\n\n    @Test\n    void testCustomStringFunctions() {\n        Map<String, Object> env = new HashMap<>();\n        env.put(\"k1\", \"Intel\");\n        env.put(\"k2\", \"intel\");\n        env.put(\"k3\", \"Ubuntu 18.04.6 LTS\");\n        env.put(\"k4\", \"ubuntu\");\n        env.put(\"k5\", \"Ubntu\");\n        env.put(\"k6\", null);\n\n        // test StrEqualFunction\n        String expr1 = \"equals(k1,k2)\"; // case-insensitive\n        Boolean res1 = (Boolean) AviatorEvaluator.compile(expr1).execute(env);\n        Assertions.assertTrue(res1);\n\n        String expr2 = \"equals(k1,k3)\";\n        Boolean res2 = (Boolean) AviatorEvaluator.compile(expr2).execute(env);\n        Assertions.assertFalse(res2);\n\n        // test StrContainsFunction\n        String expr3 = \"contains(k3,k4)\"; // case-insensitive\n        Boolean res3 = (Boolean) AviatorEvaluator.compile(expr3).execute(env);\n        Assertions.assertTrue(res3);\n\n        String expr4 = \"contains(k4,k3)\";\n        Boolean res4 = (Boolean) AviatorEvaluator.compile(expr4).execute(env);\n        Assertions.assertFalse(res4);\n\n        String expr5 = \"contains(k3,k5)\"; // subsequence\n        Boolean res5 = (Boolean) AviatorEvaluator.compile(expr5).execute(env);\n        Assertions.assertFalse(res5);\n\n        // test StrExistsFunction\n        String expr6 = \"exists('DNE_Key1')\";\n        Boolean res6 = (Boolean) AviatorEvaluator.compile(expr6).execute(env);\n        Assertions.assertTrue(res6);\n\n        String expr7 = \"exists(k6)\";\n        Boolean res7 = (Boolean) AviatorEvaluator.compile(expr7).execute(env);\n        Assertions.assertFalse(res7);\n        \n        String expr21 = \"exists('k5')\";\n        Boolean res21 = (Boolean) AviatorEvaluator.compile(expr21).execute(env);\n        Assertions.assertTrue(res21);\n        \n        String expr22 = \"exists(k5)\";\n        Boolean res22 = (Boolean) AviatorEvaluator.compile(expr22).execute(env);\n        Assertions.assertTrue(res22);\n\n        // test StrMatchesFunction\n        String regex1 = \"'^[a-zA-Z0-9]+$'\"; // only alphanumeric\n        String expr8 = \"matches(k6,\" + regex1 + \")\";\n        env.put(\"k6\", \"Ubntu50681269\");\n        Boolean res8 = (Boolean) AviatorEvaluator.compile(expr8).execute(env);\n        Assertions.assertTrue(res8);\n        env.put(\"k6\", \"Ubnt_u50681269\");\n        Boolean res9 = (Boolean) AviatorEvaluator.compile(expr8).execute(env);\n        Assertions.assertFalse(res9);\n\n        String regex2 = \"'^Ubuntu.*'\"; // starts with\n        String expr9 = \"matches(k3,\" + regex2 + \")\";\n        Boolean res10 = (Boolean) AviatorEvaluator.compile(expr9).execute(env);\n        Assertions.assertTrue(res10);\n        env.put(\"k3\", \"Ubunt_u50681269\");\n        Boolean res11 = (Boolean) AviatorEvaluator.compile(expr9).execute(env);\n        Assertions.assertFalse(res11);\n\n        String regex3 = \"\\\"^\\\\\\\\[LOG\\\\\\\\].*error$\\\"\"; // starts & ends with\n        String expr10 = \"matches(k7,\" + regex3 + \")\";\n        env.put(\"k7\", \"[LOG] detected system error\");\n        Boolean res12 = (Boolean) AviatorEvaluator.compile(expr10).execute(env);\n        Assertions.assertTrue(res12);\n        env.put(\"k7\", \"[LOG detected system error\");\n        Boolean res13 = (Boolean) AviatorEvaluator.compile(expr10).execute(env);\n        Assertions.assertFalse(res13);\n    }\n}\n"], "fixing_code": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.dromara.hertzbeat.common.config;\n\nimport com.googlecode.aviator.AviatorEvaluator;\nimport com.googlecode.aviator.AviatorEvaluatorInstance;\nimport com.googlecode.aviator.Feature;\nimport com.googlecode.aviator.Options;\nimport com.googlecode.aviator.lexer.token.OperatorType;\nimport com.googlecode.aviator.runtime.function.AbstractFunction;\nimport com.googlecode.aviator.runtime.type.*;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.regex.Pattern;\n\n/**\n * @author tomsun28\n *\n */\n@Configuration\n@Slf4j\npublic class AviatorConfiguration {\n\n    private static final int AVIATOR_LRU_CACHE_SIZE = 1024;\n\n    @Bean\n    public void configAviatorEvaluator() {\n        AviatorEvaluatorInstance instance = AviatorEvaluator.getInstance();\n\n        // \u914d\u7f6eAviatorEvaluator\u4f7f\u7528LRU\u7f13\u5b58\u7f16\u8bd1\u540e\u7684\u8868\u8fbe\u5f0f\n        instance\n                .useLRUExpressionCache(AVIATOR_LRU_CACHE_SIZE)\n                .addFunction(new StrEqualFunction());\n\n        // \u914d\u7f6eAviator\u8bed\u6cd5\u7279\u6027\u96c6\u5408\n        instance.setOption(Options.FEATURE_SET,\n                Feature.asSet(Feature.If,\n                        Feature.Assignment,\n                        Feature.Let,\n                        Feature.StringInterpolation));\n\n        // \u914d\u7f6e\u81ea\u5b9a\u4e49aviator\u51fd\u6570\n        instance.addOpFunction(OperatorType.BIT_OR, new AbstractFunction() {\n            @Override\n            public AviatorObject call(final Map<String, Object> env, final AviatorObject arg1,\n                                      final AviatorObject arg2) {\n                try {\n                    Object value1 = arg1.getValue(env);\n                    Object value2 = arg2.getValue(env);\n                    Object currentValue = value1 == null ? value2 : value1;\n                    if (arg1.getAviatorType() == AviatorType.String) {\n                        return new AviatorString(String.valueOf(currentValue));\n                    } else {\n                        return AviatorDouble.valueOf(currentValue);\n                    }\n                } catch (Exception e) {\n                    log.error(e.getMessage());\n                }\n                return arg1.bitOr(arg2, env);\n            }\n            @Override\n            public String getName() {\n                return OperatorType.BIT_OR.getToken();\n            }\n        });\n\n        instance.addFunction(new StrContainsFunction());\n        instance.addFunction(new ObjectExistsFunction());\n        instance.addFunction(new StrMatchesFunction());\n    }\n\n    /**\n     * \u81ea\u5b9a\u4e49aviator\u5224\u65ad\u5b57\u7b26\u4e32\u662f\u5426\u76f8\u7b49\u51fd\u6570\n     */\n    private static class StrEqualFunction extends AbstractFunction {\n        @Override\n        public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2) {\n            if (arg1 == null || arg2 == null) {\n                return AviatorBoolean.FALSE;\n            }\n            Object leftTmp = arg1.getValue(env);\n            Object rightTmp = arg2.getValue(env);\n            if (leftTmp == null || rightTmp == null) {\n                return AviatorBoolean.FALSE;\n            }\n            String left = String.valueOf(leftTmp);\n            String right = String.valueOf(rightTmp);\n            return AviatorBoolean.valueOf(left.equalsIgnoreCase(right));\n        }\n        @Override\n        public String getName() {\n            return \"equals\";\n        }\n    }\n\n    /**\n     * \u81ea\u5b9a\u4e49aviator\u5224\u65ad\u5b57\u7b26\u4e321\u662f\u5426\u5305\u542b\u5b57\u7b26\u4e322 (case-insensitive)\n     */\n    private static class StrContainsFunction extends AbstractFunction {\n        @Override\n        public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2) {\n            if (arg1 == null || arg2 == null) {\n                return AviatorBoolean.FALSE;\n            }\n            Object leftTmp = arg1.getValue(env);\n            Object rightTmp = arg2.getValue(env);\n            if (leftTmp == null || rightTmp == null) {\n                return AviatorBoolean.FALSE;\n            }\n            String left = String.valueOf(leftTmp);\n            String right = String.valueOf(rightTmp);\n            return AviatorBoolean.valueOf(StringUtils.containsIgnoreCase(left, right));\n        }\n        @Override\n        public String getName() {\n            return \"contains\";\n        }\n    }\n\n    /**\n     * \u81ea\u5b9a\u4e49aviator\u5224\u65ad\u73af\u5883\u4e2d\u6b64\u5bf9\u8c61\u662f\u5426\u5b58\u5728\u503c\n     */\n    private static class ObjectExistsFunction extends AbstractFunction {\n        @Override\n        public AviatorObject call(Map<String, Object> env, AviatorObject arg) {\n            if (arg == null) {\n                return AviatorBoolean.FALSE;\n            }\n            Object keyTmp = arg.getValue(env);\n            if (Objects.isNull(keyTmp)) {\n                return AviatorBoolean.FALSE;\n            } else {\n                String key = String.valueOf(keyTmp);\n                return AviatorBoolean.valueOf(StringUtils.isNotEmpty(key));\n            }\n        }\n        @Override\n        public String getName() {\n            return \"exists\";\n        }\n    }\n\n    /**\n     * \u81ea\u5b9a\u4e49aviator\u5224\u65ad\u5b57\u7b26\u4e32\u662f\u5426\u5339\u914dregex\n     * - regex\u9700\u8981\u52a0\u4e0a\"\"\u6216\u8005''\n     */\n    private static class StrMatchesFunction extends AbstractFunction {\n        @Override\n        public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2) {\n            if (arg1 == null || arg2 == null) {\n                return AviatorBoolean.FALSE;\n            }\n            Object strTmp = arg1.getValue(env);\n            Object regexTmp = arg2.getValue(env);\n            if (strTmp == null || regexTmp == null) {\n                return AviatorBoolean.FALSE;\n            }\n            String str = String.valueOf(strTmp);\n            String regex = String.valueOf(regexTmp);\n            boolean isMatch = Pattern.compile(regex).matcher(str).matches();\n            return AviatorBoolean.valueOf(isMatch);\n        }\n        @Override\n        public String getName() {\n            return \"matches\";\n        }\n    }\n}\n", "package org.dromara.hertzbeat.common.config;\n\nimport com.googlecode.aviator.AviatorEvaluator;\nimport com.googlecode.aviator.exception.UnsupportedFeatureException;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author mikezzb\n *\n */\nclass AviatorConfigurationTest {\n\n    @BeforeAll\n    static void setUp() {\n        AviatorConfiguration aviatorConfig = new AviatorConfiguration();\n        aviatorConfig.configAviatorEvaluator();\n    }\n\n    @Test\n    void testCustomStringFunctions() {\n        Map<String, Object> env = new HashMap<>();\n        env.put(\"k1\", \"Intel\");\n        env.put(\"k2\", \"intel\");\n        env.put(\"k3\", \"Ubuntu 18.04.6 LTS\");\n        env.put(\"k4\", \"ubuntu\");\n        env.put(\"k5\", \"Ubntu\");\n        env.put(\"k6\", null);\n\n        // test StrEqualFunction\n        String expr1 = \"equals(k1,k2)\"; // case-insensitive\n        Boolean res1 = (Boolean) AviatorEvaluator.compile(expr1).execute(env);\n        Assertions.assertTrue(res1);\n\n        String expr2 = \"equals(k1,k3)\";\n        Boolean res2 = (Boolean) AviatorEvaluator.compile(expr2).execute(env);\n        Assertions.assertFalse(res2);\n\n        // test StrContainsFunction\n        String expr3 = \"contains(k3,k4)\"; // case-insensitive\n        Boolean res3 = (Boolean) AviatorEvaluator.compile(expr3).execute(env);\n        Assertions.assertTrue(res3);\n\n        String expr4 = \"contains(k4,k3)\";\n        Boolean res4 = (Boolean) AviatorEvaluator.compile(expr4).execute(env);\n        Assertions.assertFalse(res4);\n\n        String expr5 = \"contains(k3,k5)\"; // subsequence\n        Boolean res5 = (Boolean) AviatorEvaluator.compile(expr5).execute(env);\n        Assertions.assertFalse(res5);\n\n        // test StrExistsFunction\n        String expr6 = \"exists('DNE_Key1')\";\n        Boolean res6 = (Boolean) AviatorEvaluator.compile(expr6).execute(env);\n        Assertions.assertTrue(res6);\n\n        String expr7 = \"exists(k6)\";\n        Boolean res7 = (Boolean) AviatorEvaluator.compile(expr7).execute(env);\n        Assertions.assertFalse(res7);\n        \n        String expr21 = \"exists('k5')\";\n        Boolean res21 = (Boolean) AviatorEvaluator.compile(expr21).execute(env);\n        Assertions.assertTrue(res21);\n        \n        String expr22 = \"exists(k5)\";\n        Boolean res22 = (Boolean) AviatorEvaluator.compile(expr22).execute(env);\n        Assertions.assertTrue(res22);\n\n        // test StrMatchesFunction\n        String regex1 = \"'^[a-zA-Z0-9]+$'\"; // only alphanumeric\n        String expr8 = \"matches(k6,\" + regex1 + \")\";\n        env.put(\"k6\", \"Ubntu50681269\");\n        Boolean res8 = (Boolean) AviatorEvaluator.compile(expr8).execute(env);\n        Assertions.assertTrue(res8);\n        env.put(\"k6\", \"Ubnt_u50681269\");\n        Boolean res9 = (Boolean) AviatorEvaluator.compile(expr8).execute(env);\n        Assertions.assertFalse(res9);\n\n        String regex2 = \"'^Ubuntu.*'\"; // starts with\n        String expr9 = \"matches(k3,\" + regex2 + \")\";\n        Boolean res10 = (Boolean) AviatorEvaluator.compile(expr9).execute(env);\n        Assertions.assertTrue(res10);\n        env.put(\"k3\", \"Ubunt_u50681269\");\n        Boolean res11 = (Boolean) AviatorEvaluator.compile(expr9).execute(env);\n        Assertions.assertFalse(res11);\n\n        String regex3 = \"\\\"^\\\\\\\\[LOG\\\\\\\\].*error$\\\"\"; // starts & ends with\n        String expr10 = \"matches(k7,\" + regex3 + \")\";\n        env.put(\"k7\", \"[LOG] detected system error\");\n        Boolean res12 = (Boolean) AviatorEvaluator.compile(expr10).execute(env);\n        Assertions.assertTrue(res12);\n        env.put(\"k7\", \"[LOG detected system error\");\n        Boolean res13 = (Boolean) AviatorEvaluator.compile(expr10).execute(env);\n        Assertions.assertFalse(res13);\n    }\n\n    @Test\n    void testRCE() {\n        // test if 'new' syntax is disabled to prevent RCE\n        Assertions.assertThrows(UnsupportedFeatureException.class, () -> {\n            String expr1 = \"let d = new java.util.Date();\\n\" +\n                    \"p(type(d));\\n\" +\n                    \"p(d);\";\n            AviatorEvaluator.compile(expr1, true).execute();\n        });\n        // test allowed features\n        String expr2 = \"let a = 0;\\n\" +\n                \"if (\\\"#{a}\\\" == \\\"0\\\") { a = -1; }\\n\" +\n                \"a == -1\";\n        Boolean result = (Boolean) AviatorEvaluator.compile(expr2, true).execute();\n        Assertions.assertTrue(result);\n    }\n}\n"], "filenames": ["common/src/main/java/org/dromara/hertzbeat/common/config/AviatorConfiguration.java", "common/src/test/java/org/dromara/hertzbeat/common/config/AviatorConfigurationTest.java"], "buggy_code_start_loc": [20, 3], "buggy_code_end_loc": [78, 98], "fixing_code_start_loc": [21, 4], "fixing_code_end_loc": [90, 117], "type": "CWE-94", "message": "Hertzbeat is an open source, real-time monitoring system. Hertzbeat uses aviatorscript to evaluate alert expressions. The alert expressions are supposed to be some simple expressions. However, due to improper sanitization for alert expressions in version prior to 1.4.1, a malicious user can use a crafted alert expression to execute any command on hertzbeat server. A malicious user who has access to alert define function can execute any command in hertzbeat instance. This issue is fixed in version 1.4.1.", "other": {"cve": {"id": "CVE-2023-51387", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-22T21:15:08.790", "lastModified": "2024-01-03T17:43:59.510", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Hertzbeat is an open source, real-time monitoring system. Hertzbeat uses aviatorscript to evaluate alert expressions. The alert expressions are supposed to be some simple expressions. However, due to improper sanitization for alert expressions in version prior to 1.4.1, a malicious user can use a crafted alert expression to execute any command on hertzbeat server. A malicious user who has access to alert define function can execute any command in hertzbeat instance. This issue is fixed in version 1.4.1."}, {"lang": "es", "value": "Hertzbeat es un sistema de monitoreo en tiempo real de c\u00f3digo abierto. Hertzbeat utiliza aviatorscript para evaluar expresiones de alerta. Se supone que las expresiones de alerta son expresiones simples. Sin embargo, debido a una sanitizaci\u00f3n inadecuada de las expresiones de alerta en versiones anteriores a la 1.4.1, un usuario malintencionado puede utilizar una expresi\u00f3n de alerta manipulada para ejecutar cualquier comando en el servidor hertzbeat. Un usuario malintencionado que tenga acceso a la funci\u00f3n de definici\u00f3n de alertas puede ejecutar cualquier comando en la instancia de Hertzbeat. Este problema se solucion\u00f3 en la versi\u00f3n 1.4.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dromara:hertzbeat:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.1", "matchCriteriaId": "FA9DA6B7-E31D-4037-BB20-38E777BF59BF"}]}]}], "references": [{"url": "https://github.com/dromara/hertzbeat/blob/6b599495763120ad1df6f4ed4b6713bb4885d8e2/home/blog/2023-09-26-hertzbeat-v1.4.1.md", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/dromara/hertzbeat/commit/8dcf050e27ca95d15460a7ba98a3df8a9cd1d3d2", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/dromara/hertzbeat/security/advisories/GHSA-4576-m8px-w9qj", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/dromara/hertzbeat/commit/8dcf050e27ca95d15460a7ba98a3df8a9cd1d3d2"}}