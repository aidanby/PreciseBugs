{"buggy_code": ["/*\n * Monkey's Audio lossless audio decoder\n * Copyright (c) 2007 Benjamin Zores <ben@geexbox.org>\n *  based upon libdemac from Dave Chapman.\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <inttypes.h>\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/channel_layout.h\"\n#include \"libavutil/opt.h\"\n#include \"lossless_audiodsp.h\"\n#include \"avcodec.h\"\n#include \"bswapdsp.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n#include \"get_bits.h\"\n#include \"unary.h\"\n\n/**\n * @file\n * Monkey's Audio lossless audio decoder\n */\n\n#define MAX_CHANNELS        2\n#define MAX_BYTESPERSAMPLE  3\n\n#define APE_FRAMECODE_MONO_SILENCE    1\n#define APE_FRAMECODE_STEREO_SILENCE  3\n#define APE_FRAMECODE_PSEUDO_STEREO   4\n\n#define HISTORY_SIZE 512\n#define PREDICTOR_ORDER 8\n/** Total size of all predictor histories */\n#define PREDICTOR_SIZE 50\n\n#define YDELAYA (18 + PREDICTOR_ORDER*4)\n#define YDELAYB (18 + PREDICTOR_ORDER*3)\n#define XDELAYA (18 + PREDICTOR_ORDER*2)\n#define XDELAYB (18 + PREDICTOR_ORDER)\n\n#define YADAPTCOEFFSA 18\n#define XADAPTCOEFFSA 14\n#define YADAPTCOEFFSB 10\n#define XADAPTCOEFFSB 5\n\n/**\n * Possible compression levels\n * @{\n */\nenum APECompressionLevel {\n    COMPRESSION_LEVEL_FAST       = 1000,\n    COMPRESSION_LEVEL_NORMAL     = 2000,\n    COMPRESSION_LEVEL_HIGH       = 3000,\n    COMPRESSION_LEVEL_EXTRA_HIGH = 4000,\n    COMPRESSION_LEVEL_INSANE     = 5000\n};\n/** @} */\n\n#define APE_FILTER_LEVELS 3\n\n/** Filter orders depending on compression level */\nstatic const uint16_t ape_filter_orders[5][APE_FILTER_LEVELS] = {\n    {  0,   0,    0 },\n    { 16,   0,    0 },\n    { 64,   0,    0 },\n    { 32, 256,    0 },\n    { 16, 256, 1280 }\n};\n\n/** Filter fraction bits depending on compression level */\nstatic const uint8_t ape_filter_fracbits[5][APE_FILTER_LEVELS] = {\n    {  0,  0,  0 },\n    { 11,  0,  0 },\n    { 11,  0,  0 },\n    { 10, 13,  0 },\n    { 11, 13, 15 }\n};\n\n\n/** Filters applied to the decoded data */\ntypedef struct APEFilter {\n    int16_t *coeffs;        ///< actual coefficients used in filtering\n    int16_t *adaptcoeffs;   ///< adaptive filter coefficients used for correcting of actual filter coefficients\n    int16_t *historybuffer; ///< filter memory\n    int16_t *delay;         ///< filtered values\n\n    int avg;\n} APEFilter;\n\ntypedef struct APERice {\n    uint32_t k;\n    uint32_t ksum;\n} APERice;\n\ntypedef struct APERangecoder {\n    uint32_t low;           ///< low end of interval\n    uint32_t range;         ///< length of interval\n    uint32_t help;          ///< bytes_to_follow resp. intermediate value\n    unsigned int buffer;    ///< buffer for input/output\n} APERangecoder;\n\n/** Filter histories */\ntypedef struct APEPredictor {\n    int32_t *buf;\n\n    int32_t lastA[2];\n\n    int32_t filterA[2];\n    int32_t filterB[2];\n\n    int32_t coeffsA[2][4];  ///< adaption coefficients\n    int32_t coeffsB[2][5];  ///< adaption coefficients\n    int32_t historybuffer[HISTORY_SIZE + PREDICTOR_SIZE];\n\n    unsigned int sample_pos;\n} APEPredictor;\n\n/** Decoder context */\ntypedef struct APEContext {\n    AVClass *class;                          ///< class for AVOptions\n    AVCodecContext *avctx;\n    BswapDSPContext bdsp;\n    LLAudDSPContext adsp;\n    int channels;\n    int samples;                             ///< samples left to decode in current frame\n    int bps;\n\n    int fileversion;                         ///< codec version, very important in decoding process\n    int compression_level;                   ///< compression levels\n    int fset;                                ///< which filter set to use (calculated from compression level)\n    int flags;                               ///< global decoder flags\n\n    uint32_t CRC;                            ///< frame CRC\n    int frameflags;                          ///< frame flags\n    APEPredictor predictor;                  ///< predictor used for final reconstruction\n\n    int32_t *decoded_buffer;\n    int decoded_size;\n    int32_t *decoded[MAX_CHANNELS];          ///< decoded data for each channel\n    int blocks_per_loop;                     ///< maximum number of samples to decode for each call\n\n    int16_t* filterbuf[APE_FILTER_LEVELS];   ///< filter memory\n\n    APERangecoder rc;                        ///< rangecoder used to decode actual values\n    APERice riceX;                           ///< rice code parameters for the second channel\n    APERice riceY;                           ///< rice code parameters for the first channel\n    APEFilter filters[APE_FILTER_LEVELS][2]; ///< filters used for reconstruction\n    GetBitContext gb;\n\n    uint8_t *data;                           ///< current frame data\n    uint8_t *data_end;                       ///< frame data end\n    int data_size;                           ///< frame data allocated size\n    const uint8_t *ptr;                      ///< current position in frame data\n\n    int error;\n\n    void (*entropy_decode_mono)(struct APEContext *ctx, int blockstodecode);\n    void (*entropy_decode_stereo)(struct APEContext *ctx, int blockstodecode);\n    void (*predictor_decode_mono)(struct APEContext *ctx, int count);\n    void (*predictor_decode_stereo)(struct APEContext *ctx, int count);\n} APEContext;\n\nstatic void ape_apply_filters(APEContext *ctx, int32_t *decoded0,\n                              int32_t *decoded1, int count);\n\nstatic void entropy_decode_mono_0000(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_stereo_0000(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_mono_3860(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_stereo_3860(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_mono_3900(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_stereo_3900(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_stereo_3930(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_mono_3990(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_stereo_3990(APEContext *ctx, int blockstodecode);\n\nstatic void predictor_decode_mono_3800(APEContext *ctx, int count);\nstatic void predictor_decode_stereo_3800(APEContext *ctx, int count);\nstatic void predictor_decode_mono_3930(APEContext *ctx, int count);\nstatic void predictor_decode_stereo_3930(APEContext *ctx, int count);\nstatic void predictor_decode_mono_3950(APEContext *ctx, int count);\nstatic void predictor_decode_stereo_3950(APEContext *ctx, int count);\n\nstatic av_cold int ape_decode_close(AVCodecContext *avctx)\n{\n    APEContext *s = avctx->priv_data;\n    int i;\n\n    for (i = 0; i < APE_FILTER_LEVELS; i++)\n        av_freep(&s->filterbuf[i]);\n\n    av_freep(&s->decoded_buffer);\n    av_freep(&s->data);\n    s->decoded_size = s->data_size = 0;\n\n    return 0;\n}\n\nstatic av_cold int ape_decode_init(AVCodecContext *avctx)\n{\n    APEContext *s = avctx->priv_data;\n    int i;\n\n    if (avctx->extradata_size != 6) {\n        av_log(avctx, AV_LOG_ERROR, \"Incorrect extradata\\n\");\n        return AVERROR(EINVAL);\n    }\n    if (avctx->channels > 2) {\n        av_log(avctx, AV_LOG_ERROR, \"Only mono and stereo is supported\\n\");\n        return AVERROR(EINVAL);\n    }\n    s->bps = avctx->bits_per_coded_sample;\n    switch (s->bps) {\n    case 8:\n        avctx->sample_fmt = AV_SAMPLE_FMT_U8P;\n        break;\n    case 16:\n        avctx->sample_fmt = AV_SAMPLE_FMT_S16P;\n        break;\n    case 24:\n        avctx->sample_fmt = AV_SAMPLE_FMT_S32P;\n        break;\n    default:\n        avpriv_request_sample(avctx,\n                              \"%d bits per coded sample\", s->bps);\n        return AVERROR_PATCHWELCOME;\n    }\n    s->avctx             = avctx;\n    s->channels          = avctx->channels;\n    s->fileversion       = AV_RL16(avctx->extradata);\n    s->compression_level = AV_RL16(avctx->extradata + 2);\n    s->flags             = AV_RL16(avctx->extradata + 4);\n\n    av_log(avctx, AV_LOG_VERBOSE, \"Compression Level: %d - Flags: %d\\n\",\n           s->compression_level, s->flags);\n    if (s->compression_level % 1000 || s->compression_level > COMPRESSION_LEVEL_INSANE ||\n        !s->compression_level ||\n        (s->fileversion < 3930 && s->compression_level == COMPRESSION_LEVEL_INSANE)) {\n        av_log(avctx, AV_LOG_ERROR, \"Incorrect compression level %d\\n\",\n               s->compression_level);\n        return AVERROR_INVALIDDATA;\n    }\n    s->fset = s->compression_level / 1000 - 1;\n    for (i = 0; i < APE_FILTER_LEVELS; i++) {\n        if (!ape_filter_orders[s->fset][i])\n            break;\n        FF_ALLOC_OR_GOTO(avctx, s->filterbuf[i],\n                         (ape_filter_orders[s->fset][i] * 3 + HISTORY_SIZE) * 4,\n                         filter_alloc_fail);\n    }\n\n    if (s->fileversion < 3860) {\n        s->entropy_decode_mono   = entropy_decode_mono_0000;\n        s->entropy_decode_stereo = entropy_decode_stereo_0000;\n    } else if (s->fileversion < 3900) {\n        s->entropy_decode_mono   = entropy_decode_mono_3860;\n        s->entropy_decode_stereo = entropy_decode_stereo_3860;\n    } else if (s->fileversion < 3930) {\n        s->entropy_decode_mono   = entropy_decode_mono_3900;\n        s->entropy_decode_stereo = entropy_decode_stereo_3900;\n    } else if (s->fileversion < 3990) {\n        s->entropy_decode_mono   = entropy_decode_mono_3900;\n        s->entropy_decode_stereo = entropy_decode_stereo_3930;\n    } else {\n        s->entropy_decode_mono   = entropy_decode_mono_3990;\n        s->entropy_decode_stereo = entropy_decode_stereo_3990;\n    }\n\n    if (s->fileversion < 3930) {\n        s->predictor_decode_mono   = predictor_decode_mono_3800;\n        s->predictor_decode_stereo = predictor_decode_stereo_3800;\n    } else if (s->fileversion < 3950) {\n        s->predictor_decode_mono   = predictor_decode_mono_3930;\n        s->predictor_decode_stereo = predictor_decode_stereo_3930;\n    } else {\n        s->predictor_decode_mono   = predictor_decode_mono_3950;\n        s->predictor_decode_stereo = predictor_decode_stereo_3950;\n    }\n\n    ff_bswapdsp_init(&s->bdsp);\n    ff_llauddsp_init(&s->adsp);\n    avctx->channel_layout = (avctx->channels==2) ? AV_CH_LAYOUT_STEREO : AV_CH_LAYOUT_MONO;\n\n    return 0;\nfilter_alloc_fail:\n    ape_decode_close(avctx);\n    return AVERROR(ENOMEM);\n}\n\n/**\n * @name APE range decoding functions\n * @{\n */\n\n#define CODE_BITS    32\n#define TOP_VALUE    ((unsigned int)1 << (CODE_BITS-1))\n#define SHIFT_BITS   (CODE_BITS - 9)\n#define EXTRA_BITS   ((CODE_BITS-2) % 8 + 1)\n#define BOTTOM_VALUE (TOP_VALUE >> 8)\n\n/** Start the decoder */\nstatic inline void range_start_decoding(APEContext *ctx)\n{\n    ctx->rc.buffer = bytestream_get_byte(&ctx->ptr);\n    ctx->rc.low    = ctx->rc.buffer >> (8 - EXTRA_BITS);\n    ctx->rc.range  = (uint32_t) 1 << EXTRA_BITS;\n}\n\n/** Perform normalization */\nstatic inline void range_dec_normalize(APEContext *ctx)\n{\n    while (ctx->rc.range <= BOTTOM_VALUE) {\n        ctx->rc.buffer <<= 8;\n        if(ctx->ptr < ctx->data_end) {\n            ctx->rc.buffer += *ctx->ptr;\n            ctx->ptr++;\n        } else {\n            ctx->error = 1;\n        }\n        ctx->rc.low    = (ctx->rc.low << 8)    | ((ctx->rc.buffer >> 1) & 0xFF);\n        ctx->rc.range  <<= 8;\n    }\n}\n\n/**\n * Calculate cumulative frequency for next symbol. Does NO update!\n * @param ctx decoder context\n * @param tot_f is the total frequency or (code_value)1<<shift\n * @return the cumulative frequency\n */\nstatic inline int range_decode_culfreq(APEContext *ctx, int tot_f)\n{\n    range_dec_normalize(ctx);\n    ctx->rc.help = ctx->rc.range / tot_f;\n    return ctx->rc.low / ctx->rc.help;\n}\n\n/**\n * Decode value with given size in bits\n * @param ctx decoder context\n * @param shift number of bits to decode\n */\nstatic inline int range_decode_culshift(APEContext *ctx, int shift)\n{\n    range_dec_normalize(ctx);\n    ctx->rc.help = ctx->rc.range >> shift;\n    return ctx->rc.low / ctx->rc.help;\n}\n\n\n/**\n * Update decoding state\n * @param ctx decoder context\n * @param sy_f the interval length (frequency of the symbol)\n * @param lt_f the lower end (frequency sum of < symbols)\n */\nstatic inline void range_decode_update(APEContext *ctx, int sy_f, int lt_f)\n{\n    ctx->rc.low  -= ctx->rc.help * lt_f;\n    ctx->rc.range = ctx->rc.help * sy_f;\n}\n\n/** Decode n bits (n <= 16) without modelling */\nstatic inline int range_decode_bits(APEContext *ctx, int n)\n{\n    int sym = range_decode_culshift(ctx, n);\n    range_decode_update(ctx, 1, sym);\n    return sym;\n}\n\n\n#define MODEL_ELEMENTS 64\n\n/**\n * Fixed probabilities for symbols in Monkey Audio version 3.97\n */\nstatic const uint16_t counts_3970[22] = {\n        0, 14824, 28224, 39348, 47855, 53994, 58171, 60926,\n    62682, 63786, 64463, 64878, 65126, 65276, 65365, 65419,\n    65450, 65469, 65480, 65487, 65491, 65493,\n};\n\n/**\n * Probability ranges for symbols in Monkey Audio version 3.97\n */\nstatic const uint16_t counts_diff_3970[21] = {\n    14824, 13400, 11124, 8507, 6139, 4177, 2755, 1756,\n    1104, 677, 415, 248, 150, 89, 54, 31,\n    19, 11, 7, 4, 2,\n};\n\n/**\n * Fixed probabilities for symbols in Monkey Audio version 3.98\n */\nstatic const uint16_t counts_3980[22] = {\n        0, 19578, 36160, 48417, 56323, 60899, 63265, 64435,\n    64971, 65232, 65351, 65416, 65447, 65466, 65476, 65482,\n    65485, 65488, 65490, 65491, 65492, 65493,\n};\n\n/**\n * Probability ranges for symbols in Monkey Audio version 3.98\n */\nstatic const uint16_t counts_diff_3980[21] = {\n    19578, 16582, 12257, 7906, 4576, 2366, 1170, 536,\n    261, 119, 65, 31, 19, 10, 6, 3,\n    3, 2, 1, 1, 1,\n};\n\n/**\n * Decode symbol\n * @param ctx decoder context\n * @param counts probability range start position\n * @param counts_diff probability range widths\n */\nstatic inline int range_get_symbol(APEContext *ctx,\n                                   const uint16_t counts[],\n                                   const uint16_t counts_diff[])\n{\n    int symbol, cf;\n\n    cf = range_decode_culshift(ctx, 16);\n\n    if(cf > 65492){\n        symbol= cf - 65535 + 63;\n        range_decode_update(ctx, 1, cf);\n        if(cf > 65535)\n            ctx->error=1;\n        return symbol;\n    }\n    /* figure out the symbol inefficiently; a binary search would be much better */\n    for (symbol = 0; counts[symbol + 1] <= cf; symbol++);\n\n    range_decode_update(ctx, counts_diff[symbol], counts[symbol]);\n\n    return symbol;\n}\n/** @} */ // group rangecoder\n\nstatic inline void update_rice(APERice *rice, unsigned int x)\n{\n    int lim = rice->k ? (1 << (rice->k + 4)) : 0;\n    rice->ksum += ((x + 1) / 2) - ((rice->ksum + 16) >> 5);\n\n    if (rice->ksum < lim)\n        rice->k--;\n    else if (rice->ksum >= (1 << (rice->k + 5)))\n        rice->k++;\n}\n\nstatic inline int get_rice_ook(GetBitContext *gb, int k)\n{\n    unsigned int x;\n\n    x = get_unary(gb, 1, get_bits_left(gb));\n\n    if (k)\n        x = (x << k) | get_bits(gb, k);\n\n    return x;\n}\n\nstatic inline int ape_decode_value_3860(APEContext *ctx, GetBitContext *gb,\n                                        APERice *rice)\n{\n    unsigned int x, overflow;\n\n    overflow = get_unary(gb, 1, get_bits_left(gb));\n\n    if (ctx->fileversion > 3880) {\n        while (overflow >= 16) {\n            overflow -= 16;\n            rice->k  += 4;\n        }\n    }\n\n    if (!rice->k)\n        x = overflow;\n    else if(rice->k <= MIN_CACHE_BITS) {\n        x = (overflow << rice->k) + get_bits(gb, rice->k);\n    } else {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"Too many bits: %\"PRIu32\"\\n\", rice->k);\n        return AVERROR_INVALIDDATA;\n    }\n    rice->ksum += x - (rice->ksum + 8 >> 4);\n    if (rice->ksum < (rice->k ? 1 << (rice->k + 4) : 0))\n        rice->k--;\n    else if (rice->ksum >= (1 << (rice->k + 5)) && rice->k < 24)\n        rice->k++;\n\n    /* Convert to signed */\n    return ((x >> 1) ^ ((x & 1) - 1)) + 1;\n}\n\nstatic inline int ape_decode_value_3900(APEContext *ctx, APERice *rice)\n{\n    unsigned int x, overflow;\n    int tmpk;\n\n    overflow = range_get_symbol(ctx, counts_3970, counts_diff_3970);\n\n    if (overflow == (MODEL_ELEMENTS - 1)) {\n        tmpk = range_decode_bits(ctx, 5);\n        overflow = 0;\n    } else\n        tmpk = (rice->k < 1) ? 0 : rice->k - 1;\n\n    if (tmpk <= 16 || ctx->fileversion < 3910) {\n        if (tmpk > 23) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"Too many bits: %d\\n\", tmpk);\n            return AVERROR_INVALIDDATA;\n        }\n        x = range_decode_bits(ctx, tmpk);\n    } else if (tmpk <= 31) {\n        x = range_decode_bits(ctx, 16);\n        x |= (range_decode_bits(ctx, tmpk - 16) << 16);\n    } else {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"Too many bits: %d\\n\", tmpk);\n        return AVERROR_INVALIDDATA;\n    }\n    x += overflow << tmpk;\n\n    update_rice(rice, x);\n\n    /* Convert to signed */\n    return ((x >> 1) ^ ((x & 1) - 1)) + 1;\n}\n\nstatic inline int ape_decode_value_3990(APEContext *ctx, APERice *rice)\n{\n    unsigned int x, overflow;\n    int base, pivot;\n\n    pivot = rice->ksum >> 5;\n    if (pivot == 0)\n        pivot = 1;\n\n    overflow = range_get_symbol(ctx, counts_3980, counts_diff_3980);\n\n    if (overflow == (MODEL_ELEMENTS - 1)) {\n        overflow  = range_decode_bits(ctx, 16) << 16;\n        overflow |= range_decode_bits(ctx, 16);\n    }\n\n    if (pivot < 0x10000) {\n        base = range_decode_culfreq(ctx, pivot);\n        range_decode_update(ctx, 1, base);\n    } else {\n        int base_hi = pivot, base_lo;\n        int bbits = 0;\n\n        while (base_hi & ~0xFFFF) {\n            base_hi >>= 1;\n            bbits++;\n        }\n        base_hi = range_decode_culfreq(ctx, base_hi + 1);\n        range_decode_update(ctx, 1, base_hi);\n        base_lo = range_decode_culfreq(ctx, 1 << bbits);\n        range_decode_update(ctx, 1, base_lo);\n\n        base = (base_hi << bbits) + base_lo;\n    }\n\n    x = base + overflow * pivot;\n\n    update_rice(rice, x);\n\n    /* Convert to signed */\n    return ((x >> 1) ^ ((x & 1) - 1)) + 1;\n}\n\nstatic void decode_array_0000(APEContext *ctx, GetBitContext *gb,\n                              int32_t *out, APERice *rice, int blockstodecode)\n{\n    int i;\n    int ksummax, ksummin;\n\n    rice->ksum = 0;\n    for (i = 0; i < FFMIN(blockstodecode, 5); i++) {\n        out[i] = get_rice_ook(&ctx->gb, 10);\n        rice->ksum += out[i];\n    }\n    rice->k = av_log2(rice->ksum / 10) + 1;\n    if (rice->k >= 24)\n        return;\n    for (; i < FFMIN(blockstodecode, 64); i++) {\n        out[i] = get_rice_ook(&ctx->gb, rice->k);\n        rice->ksum += out[i];\n        rice->k = av_log2(rice->ksum / ((i + 1) * 2)) + 1;\n        if (rice->k >= 24)\n            return;\n    }\n    ksummax = 1 << rice->k + 7;\n    ksummin = rice->k ? (1 << rice->k + 6) : 0;\n    for (; i < blockstodecode; i++) {\n        out[i] = get_rice_ook(&ctx->gb, rice->k);\n        rice->ksum += out[i] - out[i - 64];\n        while (rice->ksum < ksummin) {\n            rice->k--;\n            ksummin = rice->k ? ksummin >> 1 : 0;\n            ksummax >>= 1;\n        }\n        while (rice->ksum >= ksummax) {\n            rice->k++;\n            if (rice->k > 24)\n                return;\n            ksummax <<= 1;\n            ksummin = ksummin ? ksummin << 1 : 128;\n        }\n    }\n\n    for (i = 0; i < blockstodecode; i++)\n        out[i] = ((out[i] >> 1) ^ ((out[i] & 1) - 1)) + 1;\n}\n\nstatic void entropy_decode_mono_0000(APEContext *ctx, int blockstodecode)\n{\n    decode_array_0000(ctx, &ctx->gb, ctx->decoded[0], &ctx->riceY,\n                      blockstodecode);\n}\n\nstatic void entropy_decode_stereo_0000(APEContext *ctx, int blockstodecode)\n{\n    decode_array_0000(ctx, &ctx->gb, ctx->decoded[0], &ctx->riceY,\n                      blockstodecode);\n    decode_array_0000(ctx, &ctx->gb, ctx->decoded[1], &ctx->riceX,\n                      blockstodecode);\n}\n\nstatic void entropy_decode_mono_3860(APEContext *ctx, int blockstodecode)\n{\n    int32_t *decoded0 = ctx->decoded[0];\n\n    while (blockstodecode--)\n        *decoded0++ = ape_decode_value_3860(ctx, &ctx->gb, &ctx->riceY);\n}\n\nstatic void entropy_decode_stereo_3860(APEContext *ctx, int blockstodecode)\n{\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n    int blocks = blockstodecode;\n\n    while (blockstodecode--)\n        *decoded0++ = ape_decode_value_3860(ctx, &ctx->gb, &ctx->riceY);\n    while (blocks--)\n        *decoded1++ = ape_decode_value_3860(ctx, &ctx->gb, &ctx->riceX);\n}\n\nstatic void entropy_decode_mono_3900(APEContext *ctx, int blockstodecode)\n{\n    int32_t *decoded0 = ctx->decoded[0];\n\n    while (blockstodecode--)\n        *decoded0++ = ape_decode_value_3900(ctx, &ctx->riceY);\n}\n\nstatic void entropy_decode_stereo_3900(APEContext *ctx, int blockstodecode)\n{\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n    int blocks = blockstodecode;\n\n    while (blockstodecode--)\n        *decoded0++ = ape_decode_value_3900(ctx, &ctx->riceY);\n    range_dec_normalize(ctx);\n    // because of some implementation peculiarities we need to backpedal here\n    ctx->ptr -= 1;\n    range_start_decoding(ctx);\n    while (blocks--)\n        *decoded1++ = ape_decode_value_3900(ctx, &ctx->riceX);\n}\n\nstatic void entropy_decode_stereo_3930(APEContext *ctx, int blockstodecode)\n{\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n\n    while (blockstodecode--) {\n        *decoded0++ = ape_decode_value_3900(ctx, &ctx->riceY);\n        *decoded1++ = ape_decode_value_3900(ctx, &ctx->riceX);\n    }\n}\n\nstatic void entropy_decode_mono_3990(APEContext *ctx, int blockstodecode)\n{\n    int32_t *decoded0 = ctx->decoded[0];\n\n    while (blockstodecode--)\n        *decoded0++ = ape_decode_value_3990(ctx, &ctx->riceY);\n}\n\nstatic void entropy_decode_stereo_3990(APEContext *ctx, int blockstodecode)\n{\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n\n    while (blockstodecode--) {\n        *decoded0++ = ape_decode_value_3990(ctx, &ctx->riceY);\n        *decoded1++ = ape_decode_value_3990(ctx, &ctx->riceX);\n    }\n}\n\nstatic int init_entropy_decoder(APEContext *ctx)\n{\n    /* Read the CRC */\n    if (ctx->fileversion >= 3900) {\n        if (ctx->data_end - ctx->ptr < 6)\n            return AVERROR_INVALIDDATA;\n        ctx->CRC = bytestream_get_be32(&ctx->ptr);\n    } else {\n        ctx->CRC = get_bits_long(&ctx->gb, 32);\n    }\n\n    /* Read the frame flags if they exist */\n    ctx->frameflags = 0;\n    if ((ctx->fileversion > 3820) && (ctx->CRC & 0x80000000)) {\n        ctx->CRC &= ~0x80000000;\n\n        if (ctx->data_end - ctx->ptr < 6)\n            return AVERROR_INVALIDDATA;\n        ctx->frameflags = bytestream_get_be32(&ctx->ptr);\n    }\n\n    /* Initialize the rice structs */\n    ctx->riceX.k = 10;\n    ctx->riceX.ksum = (1 << ctx->riceX.k) * 16;\n    ctx->riceY.k = 10;\n    ctx->riceY.ksum = (1 << ctx->riceY.k) * 16;\n\n    if (ctx->fileversion >= 3900) {\n        /* The first 8 bits of input are ignored. */\n        ctx->ptr++;\n\n        range_start_decoding(ctx);\n    }\n\n    return 0;\n}\n\nstatic const int32_t initial_coeffs_fast_3320[1] = {\n    375,\n};\n\nstatic const int32_t initial_coeffs_a_3800[3] = {\n    64, 115, 64,\n};\n\nstatic const int32_t initial_coeffs_b_3800[2] = {\n    740, 0\n};\n\nstatic const int32_t initial_coeffs_3930[4] = {\n    360, 317, -109, 98\n};\n\nstatic void init_predictor_decoder(APEContext *ctx)\n{\n    APEPredictor *p = &ctx->predictor;\n\n    /* Zero the history buffers */\n    memset(p->historybuffer, 0, PREDICTOR_SIZE * sizeof(*p->historybuffer));\n    p->buf = p->historybuffer;\n\n    /* Initialize and zero the coefficients */\n    if (ctx->fileversion < 3930) {\n        if (ctx->compression_level == COMPRESSION_LEVEL_FAST) {\n            memcpy(p->coeffsA[0], initial_coeffs_fast_3320,\n                   sizeof(initial_coeffs_fast_3320));\n            memcpy(p->coeffsA[1], initial_coeffs_fast_3320,\n                   sizeof(initial_coeffs_fast_3320));\n        } else {\n            memcpy(p->coeffsA[0], initial_coeffs_a_3800,\n                   sizeof(initial_coeffs_a_3800));\n            memcpy(p->coeffsA[1], initial_coeffs_a_3800,\n                   sizeof(initial_coeffs_a_3800));\n        }\n    } else {\n        memcpy(p->coeffsA[0], initial_coeffs_3930, sizeof(initial_coeffs_3930));\n        memcpy(p->coeffsA[1], initial_coeffs_3930, sizeof(initial_coeffs_3930));\n    }\n    memset(p->coeffsB, 0, sizeof(p->coeffsB));\n    if (ctx->fileversion < 3930) {\n        memcpy(p->coeffsB[0], initial_coeffs_b_3800,\n               sizeof(initial_coeffs_b_3800));\n        memcpy(p->coeffsB[1], initial_coeffs_b_3800,\n               sizeof(initial_coeffs_b_3800));\n    }\n\n    p->filterA[0] = p->filterA[1] = 0;\n    p->filterB[0] = p->filterB[1] = 0;\n    p->lastA[0]   = p->lastA[1]   = 0;\n\n    p->sample_pos = 0;\n}\n\n/** Get inverse sign of integer (-1 for positive, 1 for negative and 0 for zero) */\nstatic inline int APESIGN(int32_t x) {\n    return (x < 0) - (x > 0);\n}\n\nstatic av_always_inline int filter_fast_3320(APEPredictor *p,\n                                             const int decoded, const int filter,\n                                             const int delayA)\n{\n    int32_t predictionA;\n\n    p->buf[delayA] = p->lastA[filter];\n    if (p->sample_pos < 3) {\n        p->lastA[filter]   = decoded;\n        p->filterA[filter] = decoded;\n        return decoded;\n    }\n\n    predictionA = p->buf[delayA] * 2 - p->buf[delayA - 1];\n    p->lastA[filter] = decoded + (predictionA  * p->coeffsA[filter][0] >> 9);\n\n    if ((decoded ^ predictionA) > 0)\n        p->coeffsA[filter][0]++;\n    else\n        p->coeffsA[filter][0]--;\n\n    p->filterA[filter] += p->lastA[filter];\n\n    return p->filterA[filter];\n}\n\nstatic av_always_inline int filter_3800(APEPredictor *p,\n                                        const int decoded, const int filter,\n                                        const int delayA,  const int delayB,\n                                        const int start,   const int shift)\n{\n    int32_t predictionA, predictionB, sign;\n    int32_t d0, d1, d2, d3, d4;\n\n    p->buf[delayA] = p->lastA[filter];\n    p->buf[delayB] = p->filterB[filter];\n    if (p->sample_pos < start) {\n        predictionA = decoded + p->filterA[filter];\n        p->lastA[filter]   = decoded;\n        p->filterB[filter] = decoded;\n        p->filterA[filter] = predictionA;\n        return predictionA;\n    }\n    d2 =  p->buf[delayA];\n    d1 = (p->buf[delayA] - p->buf[delayA - 1]) << 1;\n    d0 =  p->buf[delayA] + ((p->buf[delayA - 2] - p->buf[delayA - 1]) << 3);\n    d3 =  p->buf[delayB] * 2 - p->buf[delayB - 1];\n    d4 =  p->buf[delayB];\n\n    predictionA = d0 * p->coeffsA[filter][0] +\n                  d1 * p->coeffsA[filter][1] +\n                  d2 * p->coeffsA[filter][2];\n\n    sign = APESIGN(decoded);\n    p->coeffsA[filter][0] += (((d0 >> 30) & 2) - 1) * sign;\n    p->coeffsA[filter][1] += (((d1 >> 28) & 8) - 4) * sign;\n    p->coeffsA[filter][2] += (((d2 >> 28) & 8) - 4) * sign;\n\n    predictionB = d3 * p->coeffsB[filter][0] -\n                  d4 * p->coeffsB[filter][1];\n    p->lastA[filter] = decoded + (predictionA >> 11);\n    sign = APESIGN(p->lastA[filter]);\n    p->coeffsB[filter][0] += (((d3 >> 29) & 4) - 2) * sign;\n    p->coeffsB[filter][1] -= (((d4 >> 30) & 2) - 1) * sign;\n\n    p->filterB[filter] = p->lastA[filter] + (predictionB >> shift);\n    p->filterA[filter] = p->filterB[filter] + ((p->filterA[filter] * 31) >> 5);\n\n    return p->filterA[filter];\n}\n\nstatic void long_filter_high_3800(int32_t *buffer, int order, int shift, int length)\n{\n    int i, j;\n    int32_t dotprod, sign;\n    int32_t coeffs[256], delay[256];\n\n    if (order >= length)\n        return;\n\n    memset(coeffs, 0, order * sizeof(*coeffs));\n    for (i = 0; i < order; i++)\n        delay[i] = buffer[i];\n    for (i = order; i < length; i++) {\n        dotprod = 0;\n        sign = APESIGN(buffer[i]);\n        for (j = 0; j < order; j++) {\n            dotprod += delay[j] * coeffs[j];\n            coeffs[j] += ((delay[j] >> 31) | 1) * sign;\n        }\n        buffer[i] -= dotprod >> shift;\n        for (j = 0; j < order - 1; j++)\n            delay[j] = delay[j + 1];\n        delay[order - 1] = buffer[i];\n    }\n}\n\nstatic void long_filter_ehigh_3830(int32_t *buffer, int length)\n{\n    int i, j;\n    int32_t dotprod, sign;\n    int32_t coeffs[8] = { 0 }, delay[8] = { 0 };\n\n    for (i = 0; i < length; i++) {\n        dotprod = 0;\n        sign = APESIGN(buffer[i]);\n        for (j = 7; j >= 0; j--) {\n            dotprod += delay[j] * coeffs[j];\n            coeffs[j] += ((delay[j] >> 31) | 1) * sign;\n        }\n        for (j = 7; j > 0; j--)\n            delay[j] = delay[j - 1];\n        delay[0] = buffer[i];\n        buffer[i] -= dotprod >> 9;\n    }\n}\n\nstatic void predictor_decode_stereo_3800(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n    int start = 4, shift = 10;\n\n    if (ctx->compression_level == COMPRESSION_LEVEL_HIGH) {\n        start = 16;\n        long_filter_high_3800(decoded0, 16, 9, count);\n        long_filter_high_3800(decoded1, 16, 9, count);\n    } else if (ctx->compression_level == COMPRESSION_LEVEL_EXTRA_HIGH) {\n        int order = 128, shift2 = 11;\n\n        if (ctx->fileversion >= 3830) {\n            order <<= 1;\n            shift++;\n            shift2++;\n            long_filter_ehigh_3830(decoded0 + order, count - order);\n            long_filter_ehigh_3830(decoded1 + order, count - order);\n        }\n        start = order;\n        long_filter_high_3800(decoded0, order, shift2, count);\n        long_filter_high_3800(decoded1, order, shift2, count);\n    }\n\n    while (count--) {\n        int X = *decoded0, Y = *decoded1;\n        if (ctx->compression_level == COMPRESSION_LEVEL_FAST) {\n            *decoded0 = filter_fast_3320(p, Y, 0, YDELAYA);\n            decoded0++;\n            *decoded1 = filter_fast_3320(p, X, 1, XDELAYA);\n            decoded1++;\n        } else {\n            *decoded0 = filter_3800(p, Y, 0, YDELAYA, YDELAYB,\n                                    start, shift);\n            decoded0++;\n            *decoded1 = filter_3800(p, X, 1, XDELAYA, XDELAYB,\n                                    start, shift);\n            decoded1++;\n        }\n\n        /* Combined */\n        p->buf++;\n        p->sample_pos++;\n\n        /* Have we filled the history buffer? */\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n    }\n}\n\nstatic void predictor_decode_mono_3800(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n    int start = 4, shift = 10;\n\n    if (ctx->compression_level == COMPRESSION_LEVEL_HIGH) {\n        start = 16;\n        long_filter_high_3800(decoded0, 16, 9, count);\n    } else if (ctx->compression_level == COMPRESSION_LEVEL_EXTRA_HIGH) {\n        int order = 128, shift2 = 11;\n\n        if (ctx->fileversion >= 3830) {\n            order <<= 1;\n            shift++;\n            shift2++;\n            long_filter_ehigh_3830(decoded0 + order, count - order);\n        }\n        start = order;\n        long_filter_high_3800(decoded0, order, shift2, count);\n    }\n\n    while (count--) {\n        if (ctx->compression_level == COMPRESSION_LEVEL_FAST) {\n            *decoded0 = filter_fast_3320(p, *decoded0, 0, YDELAYA);\n            decoded0++;\n        } else {\n            *decoded0 = filter_3800(p, *decoded0, 0, YDELAYA, YDELAYB,\n                                    start, shift);\n            decoded0++;\n        }\n\n        /* Combined */\n        p->buf++;\n        p->sample_pos++;\n\n        /* Have we filled the history buffer? */\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n    }\n}\n\nstatic av_always_inline int predictor_update_3930(APEPredictor *p,\n                                                  const int decoded, const int filter,\n                                                  const int delayA)\n{\n    int32_t predictionA, sign;\n    int32_t d0, d1, d2, d3;\n\n    p->buf[delayA]     = p->lastA[filter];\n    d0 = p->buf[delayA    ];\n    d1 = p->buf[delayA    ] - p->buf[delayA - 1];\n    d2 = p->buf[delayA - 1] - p->buf[delayA - 2];\n    d3 = p->buf[delayA - 2] - p->buf[delayA - 3];\n\n    predictionA = d0 * p->coeffsA[filter][0] +\n                  d1 * p->coeffsA[filter][1] +\n                  d2 * p->coeffsA[filter][2] +\n                  d3 * p->coeffsA[filter][3];\n\n    p->lastA[filter] = decoded + (predictionA >> 9);\n    p->filterA[filter] = p->lastA[filter] + ((p->filterA[filter] * 31) >> 5);\n\n    sign = APESIGN(decoded);\n    p->coeffsA[filter][0] += ((d0 < 0) * 2 - 1) * sign;\n    p->coeffsA[filter][1] += ((d1 < 0) * 2 - 1) * sign;\n    p->coeffsA[filter][2] += ((d2 < 0) * 2 - 1) * sign;\n    p->coeffsA[filter][3] += ((d3 < 0) * 2 - 1) * sign;\n\n    return p->filterA[filter];\n}\n\nstatic void predictor_decode_stereo_3930(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n\n    ape_apply_filters(ctx, ctx->decoded[0], ctx->decoded[1], count);\n\n    while (count--) {\n        /* Predictor Y */\n        int Y = *decoded1, X = *decoded0;\n        *decoded0 = predictor_update_3930(p, Y, 0, YDELAYA);\n        decoded0++;\n        *decoded1 = predictor_update_3930(p, X, 1, XDELAYA);\n        decoded1++;\n\n        /* Combined */\n        p->buf++;\n\n        /* Have we filled the history buffer? */\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n    }\n}\n\nstatic void predictor_decode_mono_3930(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n\n    ape_apply_filters(ctx, ctx->decoded[0], NULL, count);\n\n    while (count--) {\n        *decoded0 = predictor_update_3930(p, *decoded0, 0, YDELAYA);\n        decoded0++;\n\n        p->buf++;\n\n        /* Have we filled the history buffer? */\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n    }\n}\n\nstatic av_always_inline int predictor_update_filter(APEPredictor *p,\n                                                    const int decoded, const int filter,\n                                                    const int delayA,  const int delayB,\n                                                    const int adaptA,  const int adaptB)\n{\n    int32_t predictionA, predictionB, sign;\n\n    p->buf[delayA]     = p->lastA[filter];\n    p->buf[adaptA]     = APESIGN(p->buf[delayA]);\n    p->buf[delayA - 1] = p->buf[delayA] - p->buf[delayA - 1];\n    p->buf[adaptA - 1] = APESIGN(p->buf[delayA - 1]);\n\n    predictionA = p->buf[delayA    ] * p->coeffsA[filter][0] +\n                  p->buf[delayA - 1] * p->coeffsA[filter][1] +\n                  p->buf[delayA - 2] * p->coeffsA[filter][2] +\n                  p->buf[delayA - 3] * p->coeffsA[filter][3];\n\n    /*  Apply a scaled first-order filter compression */\n    p->buf[delayB]     = p->filterA[filter ^ 1] - ((p->filterB[filter] * 31) >> 5);\n    p->buf[adaptB]     = APESIGN(p->buf[delayB]);\n    p->buf[delayB - 1] = p->buf[delayB] - p->buf[delayB - 1];\n    p->buf[adaptB - 1] = APESIGN(p->buf[delayB - 1]);\n    p->filterB[filter] = p->filterA[filter ^ 1];\n\n    predictionB = p->buf[delayB    ] * p->coeffsB[filter][0] +\n                  p->buf[delayB - 1] * p->coeffsB[filter][1] +\n                  p->buf[delayB - 2] * p->coeffsB[filter][2] +\n                  p->buf[delayB - 3] * p->coeffsB[filter][3] +\n                  p->buf[delayB - 4] * p->coeffsB[filter][4];\n\n    p->lastA[filter] = decoded + ((predictionA + (predictionB >> 1)) >> 10);\n    p->filterA[filter] = p->lastA[filter] + ((p->filterA[filter] * 31) >> 5);\n\n    sign = APESIGN(decoded);\n    p->coeffsA[filter][0] += p->buf[adaptA    ] * sign;\n    p->coeffsA[filter][1] += p->buf[adaptA - 1] * sign;\n    p->coeffsA[filter][2] += p->buf[adaptA - 2] * sign;\n    p->coeffsA[filter][3] += p->buf[adaptA - 3] * sign;\n    p->coeffsB[filter][0] += p->buf[adaptB    ] * sign;\n    p->coeffsB[filter][1] += p->buf[adaptB - 1] * sign;\n    p->coeffsB[filter][2] += p->buf[adaptB - 2] * sign;\n    p->coeffsB[filter][3] += p->buf[adaptB - 3] * sign;\n    p->coeffsB[filter][4] += p->buf[adaptB - 4] * sign;\n\n    return p->filterA[filter];\n}\n\nstatic void predictor_decode_stereo_3950(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n\n    ape_apply_filters(ctx, ctx->decoded[0], ctx->decoded[1], count);\n\n    while (count--) {\n        /* Predictor Y */\n        *decoded0 = predictor_update_filter(p, *decoded0, 0, YDELAYA, YDELAYB,\n                                            YADAPTCOEFFSA, YADAPTCOEFFSB);\n        decoded0++;\n        *decoded1 = predictor_update_filter(p, *decoded1, 1, XDELAYA, XDELAYB,\n                                            XADAPTCOEFFSA, XADAPTCOEFFSB);\n        decoded1++;\n\n        /* Combined */\n        p->buf++;\n\n        /* Have we filled the history buffer? */\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n    }\n}\n\nstatic void predictor_decode_mono_3950(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t predictionA, currentA, A, sign;\n\n    ape_apply_filters(ctx, ctx->decoded[0], NULL, count);\n\n    currentA = p->lastA[0];\n\n    while (count--) {\n        A = *decoded0;\n\n        p->buf[YDELAYA] = currentA;\n        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];\n\n        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +\n                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +\n                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +\n                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];\n\n        currentA = A + (predictionA >> 10);\n\n        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);\n        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);\n\n        sign = APESIGN(A);\n        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;\n        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;\n        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;\n        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;\n\n        p->buf++;\n\n        /* Have we filled the history buffer? */\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n\n        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);\n        *(decoded0++) = p->filterA[0];\n    }\n\n    p->lastA[0] = currentA;\n}\n\nstatic void do_init_filter(APEFilter *f, int16_t *buf, int order)\n{\n    f->coeffs = buf;\n    f->historybuffer = buf + order;\n    f->delay       = f->historybuffer + order * 2;\n    f->adaptcoeffs = f->historybuffer + order;\n\n    memset(f->historybuffer, 0, (order * 2) * sizeof(*f->historybuffer));\n    memset(f->coeffs, 0, order * sizeof(*f->coeffs));\n    f->avg = 0;\n}\n\nstatic void init_filter(APEContext *ctx, APEFilter *f, int16_t *buf, int order)\n{\n    do_init_filter(&f[0], buf, order);\n    do_init_filter(&f[1], buf + order * 3 + HISTORY_SIZE, order);\n}\n\nstatic void do_apply_filter(APEContext *ctx, int version, APEFilter *f,\n                            int32_t *data, int count, int order, int fracbits)\n{\n    int res;\n    int absres;\n\n    while (count--) {\n        /* round fixedpoint scalar product */\n        res = ctx->adsp.scalarproduct_and_madd_int16(f->coeffs,\n                                                     f->delay - order,\n                                                     f->adaptcoeffs - order,\n                                                     order, APESIGN(*data));\n        res = (res + (1 << (fracbits - 1))) >> fracbits;\n        res += *data;\n        *data++ = res;\n\n        /* Update the output history */\n        *f->delay++ = av_clip_int16(res);\n\n        if (version < 3980) {\n            /* Version ??? to < 3.98 files (untested) */\n            f->adaptcoeffs[0]  = (res == 0) ? 0 : ((res >> 28) & 8) - 4;\n            f->adaptcoeffs[-4] >>= 1;\n            f->adaptcoeffs[-8] >>= 1;\n        } else {\n            /* Version 3.98 and later files */\n\n            /* Update the adaption coefficients */\n            absres = FFABS(res);\n            if (absres)\n                *f->adaptcoeffs = APESIGN(res) *\n                                  (8 << ((absres > f->avg * 3) + (absres > f->avg * 4 / 3)));\n                /* equivalent to the following code\n                    if (absres <= f->avg * 4 / 3)\n                        *f->adaptcoeffs = APESIGN(res) * 8;\n                    else if (absres <= f->avg * 3)\n                        *f->adaptcoeffs = APESIGN(res) * 16;\n                    else\n                        *f->adaptcoeffs = APESIGN(res) * 32;\n                */\n            else\n                *f->adaptcoeffs = 0;\n\n            f->avg += (absres - f->avg) / 16;\n\n            f->adaptcoeffs[-1] >>= 1;\n            f->adaptcoeffs[-2] >>= 1;\n            f->adaptcoeffs[-8] >>= 1;\n        }\n\n        f->adaptcoeffs++;\n\n        /* Have we filled the history buffer? */\n        if (f->delay == f->historybuffer + HISTORY_SIZE + (order * 2)) {\n            memmove(f->historybuffer, f->delay - (order * 2),\n                    (order * 2) * sizeof(*f->historybuffer));\n            f->delay = f->historybuffer + order * 2;\n            f->adaptcoeffs = f->historybuffer + order;\n        }\n    }\n}\n\nstatic void apply_filter(APEContext *ctx, APEFilter *f,\n                         int32_t *data0, int32_t *data1,\n                         int count, int order, int fracbits)\n{\n    do_apply_filter(ctx, ctx->fileversion, &f[0], data0, count, order, fracbits);\n    if (data1)\n        do_apply_filter(ctx, ctx->fileversion, &f[1], data1, count, order, fracbits);\n}\n\nstatic void ape_apply_filters(APEContext *ctx, int32_t *decoded0,\n                              int32_t *decoded1, int count)\n{\n    int i;\n\n    for (i = 0; i < APE_FILTER_LEVELS; i++) {\n        if (!ape_filter_orders[ctx->fset][i])\n            break;\n        apply_filter(ctx, ctx->filters[i], decoded0, decoded1, count,\n                     ape_filter_orders[ctx->fset][i],\n                     ape_filter_fracbits[ctx->fset][i]);\n    }\n}\n\nstatic int init_frame_decoder(APEContext *ctx)\n{\n    int i, ret;\n    if ((ret = init_entropy_decoder(ctx)) < 0)\n        return ret;\n    init_predictor_decoder(ctx);\n\n    for (i = 0; i < APE_FILTER_LEVELS; i++) {\n        if (!ape_filter_orders[ctx->fset][i])\n            break;\n        init_filter(ctx, ctx->filters[i], ctx->filterbuf[i],\n                    ape_filter_orders[ctx->fset][i]);\n    }\n    return 0;\n}\n\nstatic void ape_unpack_mono(APEContext *ctx, int count)\n{\n    if (ctx->frameflags & APE_FRAMECODE_STEREO_SILENCE) {\n        /* We are pure silence, so we're done. */\n        av_log(ctx->avctx, AV_LOG_DEBUG, \"pure silence mono\\n\");\n        return;\n    }\n\n    ctx->entropy_decode_mono(ctx, count);\n\n    /* Now apply the predictor decoding */\n    ctx->predictor_decode_mono(ctx, count);\n\n    /* Pseudo-stereo - just copy left channel to right channel */\n    if (ctx->channels == 2) {\n        memcpy(ctx->decoded[1], ctx->decoded[0], count * sizeof(*ctx->decoded[1]));\n    }\n}\n\nstatic void ape_unpack_stereo(APEContext *ctx, int count)\n{\n    int32_t left, right;\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n\n    if ((ctx->frameflags & APE_FRAMECODE_STEREO_SILENCE) == APE_FRAMECODE_STEREO_SILENCE) {\n        /* We are pure silence, so we're done. */\n        av_log(ctx->avctx, AV_LOG_DEBUG, \"pure silence stereo\\n\");\n        return;\n    }\n\n    ctx->entropy_decode_stereo(ctx, count);\n\n    /* Now apply the predictor decoding */\n    ctx->predictor_decode_stereo(ctx, count);\n\n    /* Decorrelate and scale to output depth */\n    while (count--) {\n        left = *decoded1 - (*decoded0 / 2);\n        right = left + *decoded0;\n\n        *(decoded0++) = left;\n        *(decoded1++) = right;\n    }\n}\n\nstatic int ape_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame_ptr, AVPacket *avpkt)\n{\n    AVFrame *frame     = data;\n    const uint8_t *buf = avpkt->data;\n    APEContext *s = avctx->priv_data;\n    uint8_t *sample8;\n    int16_t *sample16;\n    int32_t *sample24;\n    int i, ch, ret;\n    int blockstodecode;\n\n    /* this should never be negative, but bad things will happen if it is, so\n       check it just to make sure. */\n    av_assert0(s->samples >= 0);\n\n    if(!s->samples){\n        uint32_t nblocks, offset;\n        int buf_size;\n\n        if (!avpkt->size) {\n            *got_frame_ptr = 0;\n            return 0;\n        }\n        if (avpkt->size < 8) {\n            av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        buf_size = avpkt->size & ~3;\n        if (buf_size != avpkt->size) {\n            av_log(avctx, AV_LOG_WARNING, \"packet size is not a multiple of 4. \"\n                   \"extra bytes at the end will be skipped.\\n\");\n        }\n        if (s->fileversion < 3950) // previous versions overread two bytes\n            buf_size += 2;\n        av_fast_padded_malloc(&s->data, &s->data_size, buf_size);\n        if (!s->data)\n            return AVERROR(ENOMEM);\n        s->bdsp.bswap_buf((uint32_t *) s->data, (const uint32_t *) buf,\n                          buf_size >> 2);\n        memset(s->data + (buf_size & ~3), 0, buf_size & 3);\n        s->ptr = s->data;\n        s->data_end = s->data + buf_size;\n\n        nblocks = bytestream_get_be32(&s->ptr);\n        offset  = bytestream_get_be32(&s->ptr);\n        if (s->fileversion >= 3900) {\n            if (offset > 3) {\n                av_log(avctx, AV_LOG_ERROR, \"Incorrect offset passed\\n\");\n                s->data = NULL;\n                return AVERROR_INVALIDDATA;\n            }\n            if (s->data_end - s->ptr < offset) {\n                av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            s->ptr += offset;\n        } else {\n            if ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0)\n                return ret;\n            if (s->fileversion > 3800)\n                skip_bits_long(&s->gb, offset * 8);\n            else\n                skip_bits_long(&s->gb, offset);\n        }\n\n        if (!nblocks || nblocks > INT_MAX) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample count: %\"PRIu32\".\\n\",\n                   nblocks);\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* Initialize the frame decoder */\n        if (init_frame_decoder(s) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Error reading frame header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        s->samples = nblocks;\n    }\n\n    if (!s->data) {\n        *got_frame_ptr = 0;\n        return avpkt->size;\n    }\n\n    blockstodecode = FFMIN(s->blocks_per_loop, s->samples);\n    // for old files coefficients were not interleaved,\n    // so we need to decode all of them at once\n    if (s->fileversion < 3930)\n        blockstodecode = s->samples;\n\n    /* reallocate decoded sample buffer if needed */\n    av_fast_malloc(&s->decoded_buffer, &s->decoded_size,\n                   2 * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer));\n    if (!s->decoded_buffer)\n        return AVERROR(ENOMEM);\n    memset(s->decoded_buffer, 0, s->decoded_size);\n    s->decoded[0] = s->decoded_buffer;\n    s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);\n\n    /* get output buffer */\n    frame->nb_samples = blockstodecode;\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        return ret;\n\n    s->error=0;\n\n    if ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO))\n        ape_unpack_mono(s, blockstodecode);\n    else\n        ape_unpack_stereo(s, blockstodecode);\n    emms_c();\n\n    if (s->error) {\n        s->samples=0;\n        av_log(avctx, AV_LOG_ERROR, \"Error decoding frame\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    switch (s->bps) {\n    case 8:\n        for (ch = 0; ch < s->channels; ch++) {\n            sample8 = (uint8_t *)frame->data[ch];\n            for (i = 0; i < blockstodecode; i++)\n                *sample8++ = (s->decoded[ch][i] + 0x80) & 0xff;\n        }\n        break;\n    case 16:\n        for (ch = 0; ch < s->channels; ch++) {\n            sample16 = (int16_t *)frame->data[ch];\n            for (i = 0; i < blockstodecode; i++)\n                *sample16++ = s->decoded[ch][i];\n        }\n        break;\n    case 24:\n        for (ch = 0; ch < s->channels; ch++) {\n            sample24 = (int32_t *)frame->data[ch];\n            for (i = 0; i < blockstodecode; i++)\n                *sample24++ = s->decoded[ch][i] << 8;\n        }\n        break;\n    }\n\n    s->samples -= blockstodecode;\n\n    *got_frame_ptr = 1;\n\n    return !s->samples ? avpkt->size : 0;\n}\n\nstatic void ape_flush(AVCodecContext *avctx)\n{\n    APEContext *s = avctx->priv_data;\n    s->samples= 0;\n}\n\n#define OFFSET(x) offsetof(APEContext, x)\n#define PAR (AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_AUDIO_PARAM)\nstatic const AVOption options[] = {\n    { \"max_samples\", \"maximum number of samples decoded per call\",             OFFSET(blocks_per_loop), AV_OPT_TYPE_INT,   { .i64 = 4608 },    1,       INT_MAX, PAR, \"max_samples\" },\n    { \"all\",         \"no maximum. decode all samples for each packet at once\", 0,                       AV_OPT_TYPE_CONST, { .i64 = INT_MAX }, INT_MIN, INT_MAX, PAR, \"max_samples\" },\n    { NULL},\n};\n\nstatic const AVClass ape_decoder_class = {\n    .class_name = \"APE decoder\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVCodec ff_ape_decoder = {\n    .name           = \"ape\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Monkey's Audio\"),\n    .type           = AVMEDIA_TYPE_AUDIO,\n    .id             = AV_CODEC_ID_APE,\n    .priv_data_size = sizeof(APEContext),\n    .init           = ape_decode_init,\n    .close          = ape_decode_close,\n    .decode         = ape_decode_frame,\n    .capabilities   = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DELAY |\n                      AV_CODEC_CAP_DR1,\n    .flush          = ape_flush,\n    .sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_U8P,\n                                                      AV_SAMPLE_FMT_S16P,\n                                                      AV_SAMPLE_FMT_S32P,\n                                                      AV_SAMPLE_FMT_NONE },\n    .priv_class     = &ape_decoder_class,\n};\n"], "fixing_code": ["/*\n * Monkey's Audio lossless audio decoder\n * Copyright (c) 2007 Benjamin Zores <ben@geexbox.org>\n *  based upon libdemac from Dave Chapman.\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <inttypes.h>\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/channel_layout.h\"\n#include \"libavutil/opt.h\"\n#include \"lossless_audiodsp.h\"\n#include \"avcodec.h\"\n#include \"bswapdsp.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n#include \"get_bits.h\"\n#include \"unary.h\"\n\n/**\n * @file\n * Monkey's Audio lossless audio decoder\n */\n\n#define MAX_CHANNELS        2\n#define MAX_BYTESPERSAMPLE  3\n\n#define APE_FRAMECODE_MONO_SILENCE    1\n#define APE_FRAMECODE_STEREO_SILENCE  3\n#define APE_FRAMECODE_PSEUDO_STEREO   4\n\n#define HISTORY_SIZE 512\n#define PREDICTOR_ORDER 8\n/** Total size of all predictor histories */\n#define PREDICTOR_SIZE 50\n\n#define YDELAYA (18 + PREDICTOR_ORDER*4)\n#define YDELAYB (18 + PREDICTOR_ORDER*3)\n#define XDELAYA (18 + PREDICTOR_ORDER*2)\n#define XDELAYB (18 + PREDICTOR_ORDER)\n\n#define YADAPTCOEFFSA 18\n#define XADAPTCOEFFSA 14\n#define YADAPTCOEFFSB 10\n#define XADAPTCOEFFSB 5\n\n/**\n * Possible compression levels\n * @{\n */\nenum APECompressionLevel {\n    COMPRESSION_LEVEL_FAST       = 1000,\n    COMPRESSION_LEVEL_NORMAL     = 2000,\n    COMPRESSION_LEVEL_HIGH       = 3000,\n    COMPRESSION_LEVEL_EXTRA_HIGH = 4000,\n    COMPRESSION_LEVEL_INSANE     = 5000\n};\n/** @} */\n\n#define APE_FILTER_LEVELS 3\n\n/** Filter orders depending on compression level */\nstatic const uint16_t ape_filter_orders[5][APE_FILTER_LEVELS] = {\n    {  0,   0,    0 },\n    { 16,   0,    0 },\n    { 64,   0,    0 },\n    { 32, 256,    0 },\n    { 16, 256, 1280 }\n};\n\n/** Filter fraction bits depending on compression level */\nstatic const uint8_t ape_filter_fracbits[5][APE_FILTER_LEVELS] = {\n    {  0,  0,  0 },\n    { 11,  0,  0 },\n    { 11,  0,  0 },\n    { 10, 13,  0 },\n    { 11, 13, 15 }\n};\n\n\n/** Filters applied to the decoded data */\ntypedef struct APEFilter {\n    int16_t *coeffs;        ///< actual coefficients used in filtering\n    int16_t *adaptcoeffs;   ///< adaptive filter coefficients used for correcting of actual filter coefficients\n    int16_t *historybuffer; ///< filter memory\n    int16_t *delay;         ///< filtered values\n\n    int avg;\n} APEFilter;\n\ntypedef struct APERice {\n    uint32_t k;\n    uint32_t ksum;\n} APERice;\n\ntypedef struct APERangecoder {\n    uint32_t low;           ///< low end of interval\n    uint32_t range;         ///< length of interval\n    uint32_t help;          ///< bytes_to_follow resp. intermediate value\n    unsigned int buffer;    ///< buffer for input/output\n} APERangecoder;\n\n/** Filter histories */\ntypedef struct APEPredictor {\n    int32_t *buf;\n\n    int32_t lastA[2];\n\n    int32_t filterA[2];\n    int32_t filterB[2];\n\n    int32_t coeffsA[2][4];  ///< adaption coefficients\n    int32_t coeffsB[2][5];  ///< adaption coefficients\n    int32_t historybuffer[HISTORY_SIZE + PREDICTOR_SIZE];\n\n    unsigned int sample_pos;\n} APEPredictor;\n\n/** Decoder context */\ntypedef struct APEContext {\n    AVClass *class;                          ///< class for AVOptions\n    AVCodecContext *avctx;\n    BswapDSPContext bdsp;\n    LLAudDSPContext adsp;\n    int channels;\n    int samples;                             ///< samples left to decode in current frame\n    int bps;\n\n    int fileversion;                         ///< codec version, very important in decoding process\n    int compression_level;                   ///< compression levels\n    int fset;                                ///< which filter set to use (calculated from compression level)\n    int flags;                               ///< global decoder flags\n\n    uint32_t CRC;                            ///< frame CRC\n    int frameflags;                          ///< frame flags\n    APEPredictor predictor;                  ///< predictor used for final reconstruction\n\n    int32_t *decoded_buffer;\n    int decoded_size;\n    int32_t *decoded[MAX_CHANNELS];          ///< decoded data for each channel\n    int blocks_per_loop;                     ///< maximum number of samples to decode for each call\n\n    int16_t* filterbuf[APE_FILTER_LEVELS];   ///< filter memory\n\n    APERangecoder rc;                        ///< rangecoder used to decode actual values\n    APERice riceX;                           ///< rice code parameters for the second channel\n    APERice riceY;                           ///< rice code parameters for the first channel\n    APEFilter filters[APE_FILTER_LEVELS][2]; ///< filters used for reconstruction\n    GetBitContext gb;\n\n    uint8_t *data;                           ///< current frame data\n    uint8_t *data_end;                       ///< frame data end\n    int data_size;                           ///< frame data allocated size\n    const uint8_t *ptr;                      ///< current position in frame data\n\n    int error;\n\n    void (*entropy_decode_mono)(struct APEContext *ctx, int blockstodecode);\n    void (*entropy_decode_stereo)(struct APEContext *ctx, int blockstodecode);\n    void (*predictor_decode_mono)(struct APEContext *ctx, int count);\n    void (*predictor_decode_stereo)(struct APEContext *ctx, int count);\n} APEContext;\n\nstatic void ape_apply_filters(APEContext *ctx, int32_t *decoded0,\n                              int32_t *decoded1, int count);\n\nstatic void entropy_decode_mono_0000(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_stereo_0000(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_mono_3860(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_stereo_3860(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_mono_3900(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_stereo_3900(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_stereo_3930(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_mono_3990(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_stereo_3990(APEContext *ctx, int blockstodecode);\n\nstatic void predictor_decode_mono_3800(APEContext *ctx, int count);\nstatic void predictor_decode_stereo_3800(APEContext *ctx, int count);\nstatic void predictor_decode_mono_3930(APEContext *ctx, int count);\nstatic void predictor_decode_stereo_3930(APEContext *ctx, int count);\nstatic void predictor_decode_mono_3950(APEContext *ctx, int count);\nstatic void predictor_decode_stereo_3950(APEContext *ctx, int count);\n\nstatic av_cold int ape_decode_close(AVCodecContext *avctx)\n{\n    APEContext *s = avctx->priv_data;\n    int i;\n\n    for (i = 0; i < APE_FILTER_LEVELS; i++)\n        av_freep(&s->filterbuf[i]);\n\n    av_freep(&s->decoded_buffer);\n    av_freep(&s->data);\n    s->decoded_size = s->data_size = 0;\n\n    return 0;\n}\n\nstatic av_cold int ape_decode_init(AVCodecContext *avctx)\n{\n    APEContext *s = avctx->priv_data;\n    int i;\n\n    if (avctx->extradata_size != 6) {\n        av_log(avctx, AV_LOG_ERROR, \"Incorrect extradata\\n\");\n        return AVERROR(EINVAL);\n    }\n    if (avctx->channels > 2) {\n        av_log(avctx, AV_LOG_ERROR, \"Only mono and stereo is supported\\n\");\n        return AVERROR(EINVAL);\n    }\n    s->bps = avctx->bits_per_coded_sample;\n    switch (s->bps) {\n    case 8:\n        avctx->sample_fmt = AV_SAMPLE_FMT_U8P;\n        break;\n    case 16:\n        avctx->sample_fmt = AV_SAMPLE_FMT_S16P;\n        break;\n    case 24:\n        avctx->sample_fmt = AV_SAMPLE_FMT_S32P;\n        break;\n    default:\n        avpriv_request_sample(avctx,\n                              \"%d bits per coded sample\", s->bps);\n        return AVERROR_PATCHWELCOME;\n    }\n    s->avctx             = avctx;\n    s->channels          = avctx->channels;\n    s->fileversion       = AV_RL16(avctx->extradata);\n    s->compression_level = AV_RL16(avctx->extradata + 2);\n    s->flags             = AV_RL16(avctx->extradata + 4);\n\n    av_log(avctx, AV_LOG_VERBOSE, \"Compression Level: %d - Flags: %d\\n\",\n           s->compression_level, s->flags);\n    if (s->compression_level % 1000 || s->compression_level > COMPRESSION_LEVEL_INSANE ||\n        !s->compression_level ||\n        (s->fileversion < 3930 && s->compression_level == COMPRESSION_LEVEL_INSANE)) {\n        av_log(avctx, AV_LOG_ERROR, \"Incorrect compression level %d\\n\",\n               s->compression_level);\n        return AVERROR_INVALIDDATA;\n    }\n    s->fset = s->compression_level / 1000 - 1;\n    for (i = 0; i < APE_FILTER_LEVELS; i++) {\n        if (!ape_filter_orders[s->fset][i])\n            break;\n        FF_ALLOC_OR_GOTO(avctx, s->filterbuf[i],\n                         (ape_filter_orders[s->fset][i] * 3 + HISTORY_SIZE) * 4,\n                         filter_alloc_fail);\n    }\n\n    if (s->fileversion < 3860) {\n        s->entropy_decode_mono   = entropy_decode_mono_0000;\n        s->entropy_decode_stereo = entropy_decode_stereo_0000;\n    } else if (s->fileversion < 3900) {\n        s->entropy_decode_mono   = entropy_decode_mono_3860;\n        s->entropy_decode_stereo = entropy_decode_stereo_3860;\n    } else if (s->fileversion < 3930) {\n        s->entropy_decode_mono   = entropy_decode_mono_3900;\n        s->entropy_decode_stereo = entropy_decode_stereo_3900;\n    } else if (s->fileversion < 3990) {\n        s->entropy_decode_mono   = entropy_decode_mono_3900;\n        s->entropy_decode_stereo = entropy_decode_stereo_3930;\n    } else {\n        s->entropy_decode_mono   = entropy_decode_mono_3990;\n        s->entropy_decode_stereo = entropy_decode_stereo_3990;\n    }\n\n    if (s->fileversion < 3930) {\n        s->predictor_decode_mono   = predictor_decode_mono_3800;\n        s->predictor_decode_stereo = predictor_decode_stereo_3800;\n    } else if (s->fileversion < 3950) {\n        s->predictor_decode_mono   = predictor_decode_mono_3930;\n        s->predictor_decode_stereo = predictor_decode_stereo_3930;\n    } else {\n        s->predictor_decode_mono   = predictor_decode_mono_3950;\n        s->predictor_decode_stereo = predictor_decode_stereo_3950;\n    }\n\n    ff_bswapdsp_init(&s->bdsp);\n    ff_llauddsp_init(&s->adsp);\n    avctx->channel_layout = (avctx->channels==2) ? AV_CH_LAYOUT_STEREO : AV_CH_LAYOUT_MONO;\n\n    return 0;\nfilter_alloc_fail:\n    ape_decode_close(avctx);\n    return AVERROR(ENOMEM);\n}\n\n/**\n * @name APE range decoding functions\n * @{\n */\n\n#define CODE_BITS    32\n#define TOP_VALUE    ((unsigned int)1 << (CODE_BITS-1))\n#define SHIFT_BITS   (CODE_BITS - 9)\n#define EXTRA_BITS   ((CODE_BITS-2) % 8 + 1)\n#define BOTTOM_VALUE (TOP_VALUE >> 8)\n\n/** Start the decoder */\nstatic inline void range_start_decoding(APEContext *ctx)\n{\n    ctx->rc.buffer = bytestream_get_byte(&ctx->ptr);\n    ctx->rc.low    = ctx->rc.buffer >> (8 - EXTRA_BITS);\n    ctx->rc.range  = (uint32_t) 1 << EXTRA_BITS;\n}\n\n/** Perform normalization */\nstatic inline void range_dec_normalize(APEContext *ctx)\n{\n    while (ctx->rc.range <= BOTTOM_VALUE) {\n        ctx->rc.buffer <<= 8;\n        if(ctx->ptr < ctx->data_end) {\n            ctx->rc.buffer += *ctx->ptr;\n            ctx->ptr++;\n        } else {\n            ctx->error = 1;\n        }\n        ctx->rc.low    = (ctx->rc.low << 8)    | ((ctx->rc.buffer >> 1) & 0xFF);\n        ctx->rc.range  <<= 8;\n    }\n}\n\n/**\n * Calculate cumulative frequency for next symbol. Does NO update!\n * @param ctx decoder context\n * @param tot_f is the total frequency or (code_value)1<<shift\n * @return the cumulative frequency\n */\nstatic inline int range_decode_culfreq(APEContext *ctx, int tot_f)\n{\n    range_dec_normalize(ctx);\n    ctx->rc.help = ctx->rc.range / tot_f;\n    return ctx->rc.low / ctx->rc.help;\n}\n\n/**\n * Decode value with given size in bits\n * @param ctx decoder context\n * @param shift number of bits to decode\n */\nstatic inline int range_decode_culshift(APEContext *ctx, int shift)\n{\n    range_dec_normalize(ctx);\n    ctx->rc.help = ctx->rc.range >> shift;\n    return ctx->rc.low / ctx->rc.help;\n}\n\n\n/**\n * Update decoding state\n * @param ctx decoder context\n * @param sy_f the interval length (frequency of the symbol)\n * @param lt_f the lower end (frequency sum of < symbols)\n */\nstatic inline void range_decode_update(APEContext *ctx, int sy_f, int lt_f)\n{\n    ctx->rc.low  -= ctx->rc.help * lt_f;\n    ctx->rc.range = ctx->rc.help * sy_f;\n}\n\n/** Decode n bits (n <= 16) without modelling */\nstatic inline int range_decode_bits(APEContext *ctx, int n)\n{\n    int sym = range_decode_culshift(ctx, n);\n    range_decode_update(ctx, 1, sym);\n    return sym;\n}\n\n\n#define MODEL_ELEMENTS 64\n\n/**\n * Fixed probabilities for symbols in Monkey Audio version 3.97\n */\nstatic const uint16_t counts_3970[22] = {\n        0, 14824, 28224, 39348, 47855, 53994, 58171, 60926,\n    62682, 63786, 64463, 64878, 65126, 65276, 65365, 65419,\n    65450, 65469, 65480, 65487, 65491, 65493,\n};\n\n/**\n * Probability ranges for symbols in Monkey Audio version 3.97\n */\nstatic const uint16_t counts_diff_3970[21] = {\n    14824, 13400, 11124, 8507, 6139, 4177, 2755, 1756,\n    1104, 677, 415, 248, 150, 89, 54, 31,\n    19, 11, 7, 4, 2,\n};\n\n/**\n * Fixed probabilities for symbols in Monkey Audio version 3.98\n */\nstatic const uint16_t counts_3980[22] = {\n        0, 19578, 36160, 48417, 56323, 60899, 63265, 64435,\n    64971, 65232, 65351, 65416, 65447, 65466, 65476, 65482,\n    65485, 65488, 65490, 65491, 65492, 65493,\n};\n\n/**\n * Probability ranges for symbols in Monkey Audio version 3.98\n */\nstatic const uint16_t counts_diff_3980[21] = {\n    19578, 16582, 12257, 7906, 4576, 2366, 1170, 536,\n    261, 119, 65, 31, 19, 10, 6, 3,\n    3, 2, 1, 1, 1,\n};\n\n/**\n * Decode symbol\n * @param ctx decoder context\n * @param counts probability range start position\n * @param counts_diff probability range widths\n */\nstatic inline int range_get_symbol(APEContext *ctx,\n                                   const uint16_t counts[],\n                                   const uint16_t counts_diff[])\n{\n    int symbol, cf;\n\n    cf = range_decode_culshift(ctx, 16);\n\n    if(cf > 65492){\n        symbol= cf - 65535 + 63;\n        range_decode_update(ctx, 1, cf);\n        if(cf > 65535)\n            ctx->error=1;\n        return symbol;\n    }\n    /* figure out the symbol inefficiently; a binary search would be much better */\n    for (symbol = 0; counts[symbol + 1] <= cf; symbol++);\n\n    range_decode_update(ctx, counts_diff[symbol], counts[symbol]);\n\n    return symbol;\n}\n/** @} */ // group rangecoder\n\nstatic inline void update_rice(APERice *rice, unsigned int x)\n{\n    int lim = rice->k ? (1 << (rice->k + 4)) : 0;\n    rice->ksum += ((x + 1) / 2) - ((rice->ksum + 16) >> 5);\n\n    if (rice->ksum < lim)\n        rice->k--;\n    else if (rice->ksum >= (1 << (rice->k + 5)))\n        rice->k++;\n}\n\nstatic inline int get_rice_ook(GetBitContext *gb, int k)\n{\n    unsigned int x;\n\n    x = get_unary(gb, 1, get_bits_left(gb));\n\n    if (k)\n        x = (x << k) | get_bits(gb, k);\n\n    return x;\n}\n\nstatic inline int ape_decode_value_3860(APEContext *ctx, GetBitContext *gb,\n                                        APERice *rice)\n{\n    unsigned int x, overflow;\n\n    overflow = get_unary(gb, 1, get_bits_left(gb));\n\n    if (ctx->fileversion > 3880) {\n        while (overflow >= 16) {\n            overflow -= 16;\n            rice->k  += 4;\n        }\n    }\n\n    if (!rice->k)\n        x = overflow;\n    else if(rice->k <= MIN_CACHE_BITS) {\n        x = (overflow << rice->k) + get_bits(gb, rice->k);\n    } else {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"Too many bits: %\"PRIu32\"\\n\", rice->k);\n        return AVERROR_INVALIDDATA;\n    }\n    rice->ksum += x - (rice->ksum + 8 >> 4);\n    if (rice->ksum < (rice->k ? 1 << (rice->k + 4) : 0))\n        rice->k--;\n    else if (rice->ksum >= (1 << (rice->k + 5)) && rice->k < 24)\n        rice->k++;\n\n    /* Convert to signed */\n    return ((x >> 1) ^ ((x & 1) - 1)) + 1;\n}\n\nstatic inline int ape_decode_value_3900(APEContext *ctx, APERice *rice)\n{\n    unsigned int x, overflow;\n    int tmpk;\n\n    overflow = range_get_symbol(ctx, counts_3970, counts_diff_3970);\n\n    if (overflow == (MODEL_ELEMENTS - 1)) {\n        tmpk = range_decode_bits(ctx, 5);\n        overflow = 0;\n    } else\n        tmpk = (rice->k < 1) ? 0 : rice->k - 1;\n\n    if (tmpk <= 16 || ctx->fileversion < 3910) {\n        if (tmpk > 23) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"Too many bits: %d\\n\", tmpk);\n            return AVERROR_INVALIDDATA;\n        }\n        x = range_decode_bits(ctx, tmpk);\n    } else if (tmpk <= 31) {\n        x = range_decode_bits(ctx, 16);\n        x |= (range_decode_bits(ctx, tmpk - 16) << 16);\n    } else {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"Too many bits: %d\\n\", tmpk);\n        return AVERROR_INVALIDDATA;\n    }\n    x += overflow << tmpk;\n\n    update_rice(rice, x);\n\n    /* Convert to signed */\n    return ((x >> 1) ^ ((x & 1) - 1)) + 1;\n}\n\nstatic inline int ape_decode_value_3990(APEContext *ctx, APERice *rice)\n{\n    unsigned int x, overflow;\n    int base, pivot;\n\n    pivot = rice->ksum >> 5;\n    if (pivot == 0)\n        pivot = 1;\n\n    overflow = range_get_symbol(ctx, counts_3980, counts_diff_3980);\n\n    if (overflow == (MODEL_ELEMENTS - 1)) {\n        overflow  = range_decode_bits(ctx, 16) << 16;\n        overflow |= range_decode_bits(ctx, 16);\n    }\n\n    if (pivot < 0x10000) {\n        base = range_decode_culfreq(ctx, pivot);\n        range_decode_update(ctx, 1, base);\n    } else {\n        int base_hi = pivot, base_lo;\n        int bbits = 0;\n\n        while (base_hi & ~0xFFFF) {\n            base_hi >>= 1;\n            bbits++;\n        }\n        base_hi = range_decode_culfreq(ctx, base_hi + 1);\n        range_decode_update(ctx, 1, base_hi);\n        base_lo = range_decode_culfreq(ctx, 1 << bbits);\n        range_decode_update(ctx, 1, base_lo);\n\n        base = (base_hi << bbits) + base_lo;\n    }\n\n    x = base + overflow * pivot;\n\n    update_rice(rice, x);\n\n    /* Convert to signed */\n    return ((x >> 1) ^ ((x & 1) - 1)) + 1;\n}\n\nstatic void decode_array_0000(APEContext *ctx, GetBitContext *gb,\n                              int32_t *out, APERice *rice, int blockstodecode)\n{\n    int i;\n    int ksummax, ksummin;\n\n    rice->ksum = 0;\n    for (i = 0; i < FFMIN(blockstodecode, 5); i++) {\n        out[i] = get_rice_ook(&ctx->gb, 10);\n        rice->ksum += out[i];\n    }\n    rice->k = av_log2(rice->ksum / 10) + 1;\n    if (rice->k >= 24)\n        return;\n    for (; i < FFMIN(blockstodecode, 64); i++) {\n        out[i] = get_rice_ook(&ctx->gb, rice->k);\n        rice->ksum += out[i];\n        rice->k = av_log2(rice->ksum / ((i + 1) * 2)) + 1;\n        if (rice->k >= 24)\n            return;\n    }\n    ksummax = 1 << rice->k + 7;\n    ksummin = rice->k ? (1 << rice->k + 6) : 0;\n    for (; i < blockstodecode; i++) {\n        out[i] = get_rice_ook(&ctx->gb, rice->k);\n        rice->ksum += out[i] - out[i - 64];\n        while (rice->ksum < ksummin) {\n            rice->k--;\n            ksummin = rice->k ? ksummin >> 1 : 0;\n            ksummax >>= 1;\n        }\n        while (rice->ksum >= ksummax) {\n            rice->k++;\n            if (rice->k > 24)\n                return;\n            ksummax <<= 1;\n            ksummin = ksummin ? ksummin << 1 : 128;\n        }\n    }\n\n    for (i = 0; i < blockstodecode; i++)\n        out[i] = ((out[i] >> 1) ^ ((out[i] & 1) - 1)) + 1;\n}\n\nstatic void entropy_decode_mono_0000(APEContext *ctx, int blockstodecode)\n{\n    decode_array_0000(ctx, &ctx->gb, ctx->decoded[0], &ctx->riceY,\n                      blockstodecode);\n}\n\nstatic void entropy_decode_stereo_0000(APEContext *ctx, int blockstodecode)\n{\n    decode_array_0000(ctx, &ctx->gb, ctx->decoded[0], &ctx->riceY,\n                      blockstodecode);\n    decode_array_0000(ctx, &ctx->gb, ctx->decoded[1], &ctx->riceX,\n                      blockstodecode);\n}\n\nstatic void entropy_decode_mono_3860(APEContext *ctx, int blockstodecode)\n{\n    int32_t *decoded0 = ctx->decoded[0];\n\n    while (blockstodecode--)\n        *decoded0++ = ape_decode_value_3860(ctx, &ctx->gb, &ctx->riceY);\n}\n\nstatic void entropy_decode_stereo_3860(APEContext *ctx, int blockstodecode)\n{\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n    int blocks = blockstodecode;\n\n    while (blockstodecode--)\n        *decoded0++ = ape_decode_value_3860(ctx, &ctx->gb, &ctx->riceY);\n    while (blocks--)\n        *decoded1++ = ape_decode_value_3860(ctx, &ctx->gb, &ctx->riceX);\n}\n\nstatic void entropy_decode_mono_3900(APEContext *ctx, int blockstodecode)\n{\n    int32_t *decoded0 = ctx->decoded[0];\n\n    while (blockstodecode--)\n        *decoded0++ = ape_decode_value_3900(ctx, &ctx->riceY);\n}\n\nstatic void entropy_decode_stereo_3900(APEContext *ctx, int blockstodecode)\n{\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n    int blocks = blockstodecode;\n\n    while (blockstodecode--)\n        *decoded0++ = ape_decode_value_3900(ctx, &ctx->riceY);\n    range_dec_normalize(ctx);\n    // because of some implementation peculiarities we need to backpedal here\n    ctx->ptr -= 1;\n    range_start_decoding(ctx);\n    while (blocks--)\n        *decoded1++ = ape_decode_value_3900(ctx, &ctx->riceX);\n}\n\nstatic void entropy_decode_stereo_3930(APEContext *ctx, int blockstodecode)\n{\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n\n    while (blockstodecode--) {\n        *decoded0++ = ape_decode_value_3900(ctx, &ctx->riceY);\n        *decoded1++ = ape_decode_value_3900(ctx, &ctx->riceX);\n    }\n}\n\nstatic void entropy_decode_mono_3990(APEContext *ctx, int blockstodecode)\n{\n    int32_t *decoded0 = ctx->decoded[0];\n\n    while (blockstodecode--)\n        *decoded0++ = ape_decode_value_3990(ctx, &ctx->riceY);\n}\n\nstatic void entropy_decode_stereo_3990(APEContext *ctx, int blockstodecode)\n{\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n\n    while (blockstodecode--) {\n        *decoded0++ = ape_decode_value_3990(ctx, &ctx->riceY);\n        *decoded1++ = ape_decode_value_3990(ctx, &ctx->riceX);\n    }\n}\n\nstatic int init_entropy_decoder(APEContext *ctx)\n{\n    /* Read the CRC */\n    if (ctx->fileversion >= 3900) {\n        if (ctx->data_end - ctx->ptr < 6)\n            return AVERROR_INVALIDDATA;\n        ctx->CRC = bytestream_get_be32(&ctx->ptr);\n    } else {\n        ctx->CRC = get_bits_long(&ctx->gb, 32);\n    }\n\n    /* Read the frame flags if they exist */\n    ctx->frameflags = 0;\n    if ((ctx->fileversion > 3820) && (ctx->CRC & 0x80000000)) {\n        ctx->CRC &= ~0x80000000;\n\n        if (ctx->data_end - ctx->ptr < 6)\n            return AVERROR_INVALIDDATA;\n        ctx->frameflags = bytestream_get_be32(&ctx->ptr);\n    }\n\n    /* Initialize the rice structs */\n    ctx->riceX.k = 10;\n    ctx->riceX.ksum = (1 << ctx->riceX.k) * 16;\n    ctx->riceY.k = 10;\n    ctx->riceY.ksum = (1 << ctx->riceY.k) * 16;\n\n    if (ctx->fileversion >= 3900) {\n        /* The first 8 bits of input are ignored. */\n        ctx->ptr++;\n\n        range_start_decoding(ctx);\n    }\n\n    return 0;\n}\n\nstatic const int32_t initial_coeffs_fast_3320[1] = {\n    375,\n};\n\nstatic const int32_t initial_coeffs_a_3800[3] = {\n    64, 115, 64,\n};\n\nstatic const int32_t initial_coeffs_b_3800[2] = {\n    740, 0\n};\n\nstatic const int32_t initial_coeffs_3930[4] = {\n    360, 317, -109, 98\n};\n\nstatic void init_predictor_decoder(APEContext *ctx)\n{\n    APEPredictor *p = &ctx->predictor;\n\n    /* Zero the history buffers */\n    memset(p->historybuffer, 0, PREDICTOR_SIZE * sizeof(*p->historybuffer));\n    p->buf = p->historybuffer;\n\n    /* Initialize and zero the coefficients */\n    if (ctx->fileversion < 3930) {\n        if (ctx->compression_level == COMPRESSION_LEVEL_FAST) {\n            memcpy(p->coeffsA[0], initial_coeffs_fast_3320,\n                   sizeof(initial_coeffs_fast_3320));\n            memcpy(p->coeffsA[1], initial_coeffs_fast_3320,\n                   sizeof(initial_coeffs_fast_3320));\n        } else {\n            memcpy(p->coeffsA[0], initial_coeffs_a_3800,\n                   sizeof(initial_coeffs_a_3800));\n            memcpy(p->coeffsA[1], initial_coeffs_a_3800,\n                   sizeof(initial_coeffs_a_3800));\n        }\n    } else {\n        memcpy(p->coeffsA[0], initial_coeffs_3930, sizeof(initial_coeffs_3930));\n        memcpy(p->coeffsA[1], initial_coeffs_3930, sizeof(initial_coeffs_3930));\n    }\n    memset(p->coeffsB, 0, sizeof(p->coeffsB));\n    if (ctx->fileversion < 3930) {\n        memcpy(p->coeffsB[0], initial_coeffs_b_3800,\n               sizeof(initial_coeffs_b_3800));\n        memcpy(p->coeffsB[1], initial_coeffs_b_3800,\n               sizeof(initial_coeffs_b_3800));\n    }\n\n    p->filterA[0] = p->filterA[1] = 0;\n    p->filterB[0] = p->filterB[1] = 0;\n    p->lastA[0]   = p->lastA[1]   = 0;\n\n    p->sample_pos = 0;\n}\n\n/** Get inverse sign of integer (-1 for positive, 1 for negative and 0 for zero) */\nstatic inline int APESIGN(int32_t x) {\n    return (x < 0) - (x > 0);\n}\n\nstatic av_always_inline int filter_fast_3320(APEPredictor *p,\n                                             const int decoded, const int filter,\n                                             const int delayA)\n{\n    int32_t predictionA;\n\n    p->buf[delayA] = p->lastA[filter];\n    if (p->sample_pos < 3) {\n        p->lastA[filter]   = decoded;\n        p->filterA[filter] = decoded;\n        return decoded;\n    }\n\n    predictionA = p->buf[delayA] * 2 - p->buf[delayA - 1];\n    p->lastA[filter] = decoded + (predictionA  * p->coeffsA[filter][0] >> 9);\n\n    if ((decoded ^ predictionA) > 0)\n        p->coeffsA[filter][0]++;\n    else\n        p->coeffsA[filter][0]--;\n\n    p->filterA[filter] += p->lastA[filter];\n\n    return p->filterA[filter];\n}\n\nstatic av_always_inline int filter_3800(APEPredictor *p,\n                                        const int decoded, const int filter,\n                                        const int delayA,  const int delayB,\n                                        const int start,   const int shift)\n{\n    int32_t predictionA, predictionB, sign;\n    int32_t d0, d1, d2, d3, d4;\n\n    p->buf[delayA] = p->lastA[filter];\n    p->buf[delayB] = p->filterB[filter];\n    if (p->sample_pos < start) {\n        predictionA = decoded + p->filterA[filter];\n        p->lastA[filter]   = decoded;\n        p->filterB[filter] = decoded;\n        p->filterA[filter] = predictionA;\n        return predictionA;\n    }\n    d2 =  p->buf[delayA];\n    d1 = (p->buf[delayA] - p->buf[delayA - 1]) << 1;\n    d0 =  p->buf[delayA] + ((p->buf[delayA - 2] - p->buf[delayA - 1]) << 3);\n    d3 =  p->buf[delayB] * 2 - p->buf[delayB - 1];\n    d4 =  p->buf[delayB];\n\n    predictionA = d0 * p->coeffsA[filter][0] +\n                  d1 * p->coeffsA[filter][1] +\n                  d2 * p->coeffsA[filter][2];\n\n    sign = APESIGN(decoded);\n    p->coeffsA[filter][0] += (((d0 >> 30) & 2) - 1) * sign;\n    p->coeffsA[filter][1] += (((d1 >> 28) & 8) - 4) * sign;\n    p->coeffsA[filter][2] += (((d2 >> 28) & 8) - 4) * sign;\n\n    predictionB = d3 * p->coeffsB[filter][0] -\n                  d4 * p->coeffsB[filter][1];\n    p->lastA[filter] = decoded + (predictionA >> 11);\n    sign = APESIGN(p->lastA[filter]);\n    p->coeffsB[filter][0] += (((d3 >> 29) & 4) - 2) * sign;\n    p->coeffsB[filter][1] -= (((d4 >> 30) & 2) - 1) * sign;\n\n    p->filterB[filter] = p->lastA[filter] + (predictionB >> shift);\n    p->filterA[filter] = p->filterB[filter] + ((p->filterA[filter] * 31) >> 5);\n\n    return p->filterA[filter];\n}\n\nstatic void long_filter_high_3800(int32_t *buffer, int order, int shift, int length)\n{\n    int i, j;\n    int32_t dotprod, sign;\n    int32_t coeffs[256], delay[256];\n\n    if (order >= length)\n        return;\n\n    memset(coeffs, 0, order * sizeof(*coeffs));\n    for (i = 0; i < order; i++)\n        delay[i] = buffer[i];\n    for (i = order; i < length; i++) {\n        dotprod = 0;\n        sign = APESIGN(buffer[i]);\n        for (j = 0; j < order; j++) {\n            dotprod += delay[j] * coeffs[j];\n            coeffs[j] += ((delay[j] >> 31) | 1) * sign;\n        }\n        buffer[i] -= dotprod >> shift;\n        for (j = 0; j < order - 1; j++)\n            delay[j] = delay[j + 1];\n        delay[order - 1] = buffer[i];\n    }\n}\n\nstatic void long_filter_ehigh_3830(int32_t *buffer, int length)\n{\n    int i, j;\n    int32_t dotprod, sign;\n    int32_t coeffs[8] = { 0 }, delay[8] = { 0 };\n\n    for (i = 0; i < length; i++) {\n        dotprod = 0;\n        sign = APESIGN(buffer[i]);\n        for (j = 7; j >= 0; j--) {\n            dotprod += delay[j] * coeffs[j];\n            coeffs[j] += ((delay[j] >> 31) | 1) * sign;\n        }\n        for (j = 7; j > 0; j--)\n            delay[j] = delay[j - 1];\n        delay[0] = buffer[i];\n        buffer[i] -= dotprod >> 9;\n    }\n}\n\nstatic void predictor_decode_stereo_3800(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n    int start = 4, shift = 10;\n\n    if (ctx->compression_level == COMPRESSION_LEVEL_HIGH) {\n        start = 16;\n        long_filter_high_3800(decoded0, 16, 9, count);\n        long_filter_high_3800(decoded1, 16, 9, count);\n    } else if (ctx->compression_level == COMPRESSION_LEVEL_EXTRA_HIGH) {\n        int order = 128, shift2 = 11;\n\n        if (ctx->fileversion >= 3830) {\n            order <<= 1;\n            shift++;\n            shift2++;\n            long_filter_ehigh_3830(decoded0 + order, count - order);\n            long_filter_ehigh_3830(decoded1 + order, count - order);\n        }\n        start = order;\n        long_filter_high_3800(decoded0, order, shift2, count);\n        long_filter_high_3800(decoded1, order, shift2, count);\n    }\n\n    while (count--) {\n        int X = *decoded0, Y = *decoded1;\n        if (ctx->compression_level == COMPRESSION_LEVEL_FAST) {\n            *decoded0 = filter_fast_3320(p, Y, 0, YDELAYA);\n            decoded0++;\n            *decoded1 = filter_fast_3320(p, X, 1, XDELAYA);\n            decoded1++;\n        } else {\n            *decoded0 = filter_3800(p, Y, 0, YDELAYA, YDELAYB,\n                                    start, shift);\n            decoded0++;\n            *decoded1 = filter_3800(p, X, 1, XDELAYA, XDELAYB,\n                                    start, shift);\n            decoded1++;\n        }\n\n        /* Combined */\n        p->buf++;\n        p->sample_pos++;\n\n        /* Have we filled the history buffer? */\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n    }\n}\n\nstatic void predictor_decode_mono_3800(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n    int start = 4, shift = 10;\n\n    if (ctx->compression_level == COMPRESSION_LEVEL_HIGH) {\n        start = 16;\n        long_filter_high_3800(decoded0, 16, 9, count);\n    } else if (ctx->compression_level == COMPRESSION_LEVEL_EXTRA_HIGH) {\n        int order = 128, shift2 = 11;\n\n        if (ctx->fileversion >= 3830) {\n            order <<= 1;\n            shift++;\n            shift2++;\n            long_filter_ehigh_3830(decoded0 + order, count - order);\n        }\n        start = order;\n        long_filter_high_3800(decoded0, order, shift2, count);\n    }\n\n    while (count--) {\n        if (ctx->compression_level == COMPRESSION_LEVEL_FAST) {\n            *decoded0 = filter_fast_3320(p, *decoded0, 0, YDELAYA);\n            decoded0++;\n        } else {\n            *decoded0 = filter_3800(p, *decoded0, 0, YDELAYA, YDELAYB,\n                                    start, shift);\n            decoded0++;\n        }\n\n        /* Combined */\n        p->buf++;\n        p->sample_pos++;\n\n        /* Have we filled the history buffer? */\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n    }\n}\n\nstatic av_always_inline int predictor_update_3930(APEPredictor *p,\n                                                  const int decoded, const int filter,\n                                                  const int delayA)\n{\n    int32_t predictionA, sign;\n    int32_t d0, d1, d2, d3;\n\n    p->buf[delayA]     = p->lastA[filter];\n    d0 = p->buf[delayA    ];\n    d1 = p->buf[delayA    ] - p->buf[delayA - 1];\n    d2 = p->buf[delayA - 1] - p->buf[delayA - 2];\n    d3 = p->buf[delayA - 2] - p->buf[delayA - 3];\n\n    predictionA = d0 * p->coeffsA[filter][0] +\n                  d1 * p->coeffsA[filter][1] +\n                  d2 * p->coeffsA[filter][2] +\n                  d3 * p->coeffsA[filter][3];\n\n    p->lastA[filter] = decoded + (predictionA >> 9);\n    p->filterA[filter] = p->lastA[filter] + ((p->filterA[filter] * 31) >> 5);\n\n    sign = APESIGN(decoded);\n    p->coeffsA[filter][0] += ((d0 < 0) * 2 - 1) * sign;\n    p->coeffsA[filter][1] += ((d1 < 0) * 2 - 1) * sign;\n    p->coeffsA[filter][2] += ((d2 < 0) * 2 - 1) * sign;\n    p->coeffsA[filter][3] += ((d3 < 0) * 2 - 1) * sign;\n\n    return p->filterA[filter];\n}\n\nstatic void predictor_decode_stereo_3930(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n\n    ape_apply_filters(ctx, ctx->decoded[0], ctx->decoded[1], count);\n\n    while (count--) {\n        /* Predictor Y */\n        int Y = *decoded1, X = *decoded0;\n        *decoded0 = predictor_update_3930(p, Y, 0, YDELAYA);\n        decoded0++;\n        *decoded1 = predictor_update_3930(p, X, 1, XDELAYA);\n        decoded1++;\n\n        /* Combined */\n        p->buf++;\n\n        /* Have we filled the history buffer? */\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n    }\n}\n\nstatic void predictor_decode_mono_3930(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n\n    ape_apply_filters(ctx, ctx->decoded[0], NULL, count);\n\n    while (count--) {\n        *decoded0 = predictor_update_3930(p, *decoded0, 0, YDELAYA);\n        decoded0++;\n\n        p->buf++;\n\n        /* Have we filled the history buffer? */\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n    }\n}\n\nstatic av_always_inline int predictor_update_filter(APEPredictor *p,\n                                                    const int decoded, const int filter,\n                                                    const int delayA,  const int delayB,\n                                                    const int adaptA,  const int adaptB)\n{\n    int32_t predictionA, predictionB, sign;\n\n    p->buf[delayA]     = p->lastA[filter];\n    p->buf[adaptA]     = APESIGN(p->buf[delayA]);\n    p->buf[delayA - 1] = p->buf[delayA] - p->buf[delayA - 1];\n    p->buf[adaptA - 1] = APESIGN(p->buf[delayA - 1]);\n\n    predictionA = p->buf[delayA    ] * p->coeffsA[filter][0] +\n                  p->buf[delayA - 1] * p->coeffsA[filter][1] +\n                  p->buf[delayA - 2] * p->coeffsA[filter][2] +\n                  p->buf[delayA - 3] * p->coeffsA[filter][3];\n\n    /*  Apply a scaled first-order filter compression */\n    p->buf[delayB]     = p->filterA[filter ^ 1] - ((p->filterB[filter] * 31) >> 5);\n    p->buf[adaptB]     = APESIGN(p->buf[delayB]);\n    p->buf[delayB - 1] = p->buf[delayB] - p->buf[delayB - 1];\n    p->buf[adaptB - 1] = APESIGN(p->buf[delayB - 1]);\n    p->filterB[filter] = p->filterA[filter ^ 1];\n\n    predictionB = p->buf[delayB    ] * p->coeffsB[filter][0] +\n                  p->buf[delayB - 1] * p->coeffsB[filter][1] +\n                  p->buf[delayB - 2] * p->coeffsB[filter][2] +\n                  p->buf[delayB - 3] * p->coeffsB[filter][3] +\n                  p->buf[delayB - 4] * p->coeffsB[filter][4];\n\n    p->lastA[filter] = decoded + ((predictionA + (predictionB >> 1)) >> 10);\n    p->filterA[filter] = p->lastA[filter] + ((p->filterA[filter] * 31) >> 5);\n\n    sign = APESIGN(decoded);\n    p->coeffsA[filter][0] += p->buf[adaptA    ] * sign;\n    p->coeffsA[filter][1] += p->buf[adaptA - 1] * sign;\n    p->coeffsA[filter][2] += p->buf[adaptA - 2] * sign;\n    p->coeffsA[filter][3] += p->buf[adaptA - 3] * sign;\n    p->coeffsB[filter][0] += p->buf[adaptB    ] * sign;\n    p->coeffsB[filter][1] += p->buf[adaptB - 1] * sign;\n    p->coeffsB[filter][2] += p->buf[adaptB - 2] * sign;\n    p->coeffsB[filter][3] += p->buf[adaptB - 3] * sign;\n    p->coeffsB[filter][4] += p->buf[adaptB - 4] * sign;\n\n    return p->filterA[filter];\n}\n\nstatic void predictor_decode_stereo_3950(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n\n    ape_apply_filters(ctx, ctx->decoded[0], ctx->decoded[1], count);\n\n    while (count--) {\n        /* Predictor Y */\n        *decoded0 = predictor_update_filter(p, *decoded0, 0, YDELAYA, YDELAYB,\n                                            YADAPTCOEFFSA, YADAPTCOEFFSB);\n        decoded0++;\n        *decoded1 = predictor_update_filter(p, *decoded1, 1, XDELAYA, XDELAYB,\n                                            XADAPTCOEFFSA, XADAPTCOEFFSB);\n        decoded1++;\n\n        /* Combined */\n        p->buf++;\n\n        /* Have we filled the history buffer? */\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n    }\n}\n\nstatic void predictor_decode_mono_3950(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t predictionA, currentA, A, sign;\n\n    ape_apply_filters(ctx, ctx->decoded[0], NULL, count);\n\n    currentA = p->lastA[0];\n\n    while (count--) {\n        A = *decoded0;\n\n        p->buf[YDELAYA] = currentA;\n        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];\n\n        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +\n                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +\n                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +\n                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];\n\n        currentA = A + (predictionA >> 10);\n\n        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);\n        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);\n\n        sign = APESIGN(A);\n        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;\n        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;\n        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;\n        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;\n\n        p->buf++;\n\n        /* Have we filled the history buffer? */\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n\n        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);\n        *(decoded0++) = p->filterA[0];\n    }\n\n    p->lastA[0] = currentA;\n}\n\nstatic void do_init_filter(APEFilter *f, int16_t *buf, int order)\n{\n    f->coeffs = buf;\n    f->historybuffer = buf + order;\n    f->delay       = f->historybuffer + order * 2;\n    f->adaptcoeffs = f->historybuffer + order;\n\n    memset(f->historybuffer, 0, (order * 2) * sizeof(*f->historybuffer));\n    memset(f->coeffs, 0, order * sizeof(*f->coeffs));\n    f->avg = 0;\n}\n\nstatic void init_filter(APEContext *ctx, APEFilter *f, int16_t *buf, int order)\n{\n    do_init_filter(&f[0], buf, order);\n    do_init_filter(&f[1], buf + order * 3 + HISTORY_SIZE, order);\n}\n\nstatic void do_apply_filter(APEContext *ctx, int version, APEFilter *f,\n                            int32_t *data, int count, int order, int fracbits)\n{\n    int res;\n    int absres;\n\n    while (count--) {\n        /* round fixedpoint scalar product */\n        res = ctx->adsp.scalarproduct_and_madd_int16(f->coeffs,\n                                                     f->delay - order,\n                                                     f->adaptcoeffs - order,\n                                                     order, APESIGN(*data));\n        res = (res + (1 << (fracbits - 1))) >> fracbits;\n        res += *data;\n        *data++ = res;\n\n        /* Update the output history */\n        *f->delay++ = av_clip_int16(res);\n\n        if (version < 3980) {\n            /* Version ??? to < 3.98 files (untested) */\n            f->adaptcoeffs[0]  = (res == 0) ? 0 : ((res >> 28) & 8) - 4;\n            f->adaptcoeffs[-4] >>= 1;\n            f->adaptcoeffs[-8] >>= 1;\n        } else {\n            /* Version 3.98 and later files */\n\n            /* Update the adaption coefficients */\n            absres = FFABS(res);\n            if (absres)\n                *f->adaptcoeffs = APESIGN(res) *\n                                  (8 << ((absres > f->avg * 3) + (absres > f->avg * 4 / 3)));\n                /* equivalent to the following code\n                    if (absres <= f->avg * 4 / 3)\n                        *f->adaptcoeffs = APESIGN(res) * 8;\n                    else if (absres <= f->avg * 3)\n                        *f->adaptcoeffs = APESIGN(res) * 16;\n                    else\n                        *f->adaptcoeffs = APESIGN(res) * 32;\n                */\n            else\n                *f->adaptcoeffs = 0;\n\n            f->avg += (absres - f->avg) / 16;\n\n            f->adaptcoeffs[-1] >>= 1;\n            f->adaptcoeffs[-2] >>= 1;\n            f->adaptcoeffs[-8] >>= 1;\n        }\n\n        f->adaptcoeffs++;\n\n        /* Have we filled the history buffer? */\n        if (f->delay == f->historybuffer + HISTORY_SIZE + (order * 2)) {\n            memmove(f->historybuffer, f->delay - (order * 2),\n                    (order * 2) * sizeof(*f->historybuffer));\n            f->delay = f->historybuffer + order * 2;\n            f->adaptcoeffs = f->historybuffer + order;\n        }\n    }\n}\n\nstatic void apply_filter(APEContext *ctx, APEFilter *f,\n                         int32_t *data0, int32_t *data1,\n                         int count, int order, int fracbits)\n{\n    do_apply_filter(ctx, ctx->fileversion, &f[0], data0, count, order, fracbits);\n    if (data1)\n        do_apply_filter(ctx, ctx->fileversion, &f[1], data1, count, order, fracbits);\n}\n\nstatic void ape_apply_filters(APEContext *ctx, int32_t *decoded0,\n                              int32_t *decoded1, int count)\n{\n    int i;\n\n    for (i = 0; i < APE_FILTER_LEVELS; i++) {\n        if (!ape_filter_orders[ctx->fset][i])\n            break;\n        apply_filter(ctx, ctx->filters[i], decoded0, decoded1, count,\n                     ape_filter_orders[ctx->fset][i],\n                     ape_filter_fracbits[ctx->fset][i]);\n    }\n}\n\nstatic int init_frame_decoder(APEContext *ctx)\n{\n    int i, ret;\n    if ((ret = init_entropy_decoder(ctx)) < 0)\n        return ret;\n    init_predictor_decoder(ctx);\n\n    for (i = 0; i < APE_FILTER_LEVELS; i++) {\n        if (!ape_filter_orders[ctx->fset][i])\n            break;\n        init_filter(ctx, ctx->filters[i], ctx->filterbuf[i],\n                    ape_filter_orders[ctx->fset][i]);\n    }\n    return 0;\n}\n\nstatic void ape_unpack_mono(APEContext *ctx, int count)\n{\n    if (ctx->frameflags & APE_FRAMECODE_STEREO_SILENCE) {\n        /* We are pure silence, so we're done. */\n        av_log(ctx->avctx, AV_LOG_DEBUG, \"pure silence mono\\n\");\n        return;\n    }\n\n    ctx->entropy_decode_mono(ctx, count);\n\n    /* Now apply the predictor decoding */\n    ctx->predictor_decode_mono(ctx, count);\n\n    /* Pseudo-stereo - just copy left channel to right channel */\n    if (ctx->channels == 2) {\n        memcpy(ctx->decoded[1], ctx->decoded[0], count * sizeof(*ctx->decoded[1]));\n    }\n}\n\nstatic void ape_unpack_stereo(APEContext *ctx, int count)\n{\n    int32_t left, right;\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n\n    if ((ctx->frameflags & APE_FRAMECODE_STEREO_SILENCE) == APE_FRAMECODE_STEREO_SILENCE) {\n        /* We are pure silence, so we're done. */\n        av_log(ctx->avctx, AV_LOG_DEBUG, \"pure silence stereo\\n\");\n        return;\n    }\n\n    ctx->entropy_decode_stereo(ctx, count);\n\n    /* Now apply the predictor decoding */\n    ctx->predictor_decode_stereo(ctx, count);\n\n    /* Decorrelate and scale to output depth */\n    while (count--) {\n        left = *decoded1 - (*decoded0 / 2);\n        right = left + *decoded0;\n\n        *(decoded0++) = left;\n        *(decoded1++) = right;\n    }\n}\n\nstatic int ape_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame_ptr, AVPacket *avpkt)\n{\n    AVFrame *frame     = data;\n    const uint8_t *buf = avpkt->data;\n    APEContext *s = avctx->priv_data;\n    uint8_t *sample8;\n    int16_t *sample16;\n    int32_t *sample24;\n    int i, ch, ret;\n    int blockstodecode;\n    uint64_t decoded_buffer_size;\n\n    /* this should never be negative, but bad things will happen if it is, so\n       check it just to make sure. */\n    av_assert0(s->samples >= 0);\n\n    if(!s->samples){\n        uint32_t nblocks, offset;\n        int buf_size;\n\n        if (!avpkt->size) {\n            *got_frame_ptr = 0;\n            return 0;\n        }\n        if (avpkt->size < 8) {\n            av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        buf_size = avpkt->size & ~3;\n        if (buf_size != avpkt->size) {\n            av_log(avctx, AV_LOG_WARNING, \"packet size is not a multiple of 4. \"\n                   \"extra bytes at the end will be skipped.\\n\");\n        }\n        if (s->fileversion < 3950) // previous versions overread two bytes\n            buf_size += 2;\n        av_fast_padded_malloc(&s->data, &s->data_size, buf_size);\n        if (!s->data)\n            return AVERROR(ENOMEM);\n        s->bdsp.bswap_buf((uint32_t *) s->data, (const uint32_t *) buf,\n                          buf_size >> 2);\n        memset(s->data + (buf_size & ~3), 0, buf_size & 3);\n        s->ptr = s->data;\n        s->data_end = s->data + buf_size;\n\n        nblocks = bytestream_get_be32(&s->ptr);\n        offset  = bytestream_get_be32(&s->ptr);\n        if (s->fileversion >= 3900) {\n            if (offset > 3) {\n                av_log(avctx, AV_LOG_ERROR, \"Incorrect offset passed\\n\");\n                s->data = NULL;\n                return AVERROR_INVALIDDATA;\n            }\n            if (s->data_end - s->ptr < offset) {\n                av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            s->ptr += offset;\n        } else {\n            if ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0)\n                return ret;\n            if (s->fileversion > 3800)\n                skip_bits_long(&s->gb, offset * 8);\n            else\n                skip_bits_long(&s->gb, offset);\n        }\n\n        if (!nblocks || nblocks > INT_MAX / 2 / sizeof(*s->decoded_buffer) - 8) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample count: %\"PRIu32\".\\n\",\n                   nblocks);\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* Initialize the frame decoder */\n        if (init_frame_decoder(s) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Error reading frame header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        s->samples = nblocks;\n    }\n\n    if (!s->data) {\n        *got_frame_ptr = 0;\n        return avpkt->size;\n    }\n\n    blockstodecode = FFMIN(s->blocks_per_loop, s->samples);\n    // for old files coefficients were not interleaved,\n    // so we need to decode all of them at once\n    if (s->fileversion < 3930)\n        blockstodecode = s->samples;\n\n    /* reallocate decoded sample buffer if needed */\n    decoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer);\n    av_assert0(decoded_buffer_size <= INT_MAX);\n    av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);\n    if (!s->decoded_buffer)\n        return AVERROR(ENOMEM);\n    memset(s->decoded_buffer, 0, s->decoded_size);\n    s->decoded[0] = s->decoded_buffer;\n    s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);\n\n    /* get output buffer */\n    frame->nb_samples = blockstodecode;\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        return ret;\n\n    s->error=0;\n\n    if ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO))\n        ape_unpack_mono(s, blockstodecode);\n    else\n        ape_unpack_stereo(s, blockstodecode);\n    emms_c();\n\n    if (s->error) {\n        s->samples=0;\n        av_log(avctx, AV_LOG_ERROR, \"Error decoding frame\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    switch (s->bps) {\n    case 8:\n        for (ch = 0; ch < s->channels; ch++) {\n            sample8 = (uint8_t *)frame->data[ch];\n            for (i = 0; i < blockstodecode; i++)\n                *sample8++ = (s->decoded[ch][i] + 0x80) & 0xff;\n        }\n        break;\n    case 16:\n        for (ch = 0; ch < s->channels; ch++) {\n            sample16 = (int16_t *)frame->data[ch];\n            for (i = 0; i < blockstodecode; i++)\n                *sample16++ = s->decoded[ch][i];\n        }\n        break;\n    case 24:\n        for (ch = 0; ch < s->channels; ch++) {\n            sample24 = (int32_t *)frame->data[ch];\n            for (i = 0; i < blockstodecode; i++)\n                *sample24++ = s->decoded[ch][i] << 8;\n        }\n        break;\n    }\n\n    s->samples -= blockstodecode;\n\n    *got_frame_ptr = 1;\n\n    return !s->samples ? avpkt->size : 0;\n}\n\nstatic void ape_flush(AVCodecContext *avctx)\n{\n    APEContext *s = avctx->priv_data;\n    s->samples= 0;\n}\n\n#define OFFSET(x) offsetof(APEContext, x)\n#define PAR (AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_AUDIO_PARAM)\nstatic const AVOption options[] = {\n    { \"max_samples\", \"maximum number of samples decoded per call\",             OFFSET(blocks_per_loop), AV_OPT_TYPE_INT,   { .i64 = 4608 },    1,       INT_MAX, PAR, \"max_samples\" },\n    { \"all\",         \"no maximum. decode all samples for each packet at once\", 0,                       AV_OPT_TYPE_CONST, { .i64 = INT_MAX }, INT_MIN, INT_MAX, PAR, \"max_samples\" },\n    { NULL},\n};\n\nstatic const AVClass ape_decoder_class = {\n    .class_name = \"APE decoder\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVCodec ff_ape_decoder = {\n    .name           = \"ape\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Monkey's Audio\"),\n    .type           = AVMEDIA_TYPE_AUDIO,\n    .id             = AV_CODEC_ID_APE,\n    .priv_data_size = sizeof(APEContext),\n    .init           = ape_decode_init,\n    .close          = ape_decode_close,\n    .decode         = ape_decode_frame,\n    .capabilities   = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DELAY |\n                      AV_CODEC_CAP_DR1,\n    .flush          = ape_flush,\n    .sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_U8P,\n                                                      AV_SAMPLE_FMT_S16P,\n                                                      AV_SAMPLE_FMT_S32P,\n                                                      AV_SAMPLE_FMT_NONE },\n    .priv_class     = &ape_decoder_class,\n};\n"], "filenames": ["libavcodec/apedec.c"], "buggy_code_start_loc": [1414], "buggy_code_end_loc": [1498], "fixing_code_start_loc": [1415], "fixing_code_end_loc": [1500], "type": "CWE-125", "message": "Integer overflow in the ape_decode_frame function in libavcodec/apedec.c in FFmpeg 2.4 through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access and application crash) or possibly have unspecified other impact via a crafted APE file.", "other": {"cve": {"id": "CVE-2017-11399", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-17T19:29:00.260", "lastModified": "2021-01-04T22:15:12.233", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer overflow in the ape_decode_frame function in libavcodec/apedec.c in FFmpeg 2.4 through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access and application crash) or possibly have unspecified other impact via a crafted APE file."}, {"lang": "es", "value": "Un desbordamiento de enteros en la funci\u00f3n ape_decode_frame en el archivo libavcodec/apedec.c en FFmpeg versi\u00f3n 2.4 hasta la versi\u00f3n 3.3.2, permite a los atacantes remotos causar una denegaci\u00f3n de servicio (acceso fuera de la matriz y bloqueo de aplicaci\u00f3n) o posiblemente tener otro impacto no especificado por medio de un archivo APE creado"}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.3.2", "matchCriteriaId": "7950917A-647C-431B-A872-67E914C135A5"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3957", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/100019", "source": "cve@mitre.org"}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/96349da5ec8eda9f0368446e557fe0c8ba0e66b7", "source": "cve@mitre.org"}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/ba4beaf6149f7241c8bd85fe853318c2f6837ad0", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/ba4beaf6149f7241c8bd85fe853318c2f6837ad0"}}