{"buggy_code": ["package db\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\tlog \"github.com/sirupsen/logrus\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\tapiv1 \"k8s.io/api/core/v1\"\n\tapierr \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/watch\"\n\t\"k8s.io/utils/pointer\"\n\n\t\"github.com/argoproj/argo-cd/v2/common\"\n\tappv1 \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/v2/util/collections\"\n\t\"github.com/argoproj/argo-cd/v2/util/settings\"\n)\n\nvar (\n\tlocalCluster = appv1.Cluster{\n\t\tName:            \"in-cluster\",\n\t\tServer:          appv1.KubernetesInternalAPIServerAddr,\n\t\tConnectionState: appv1.ConnectionState{Status: appv1.ConnectionStatusSuccessful},\n\t}\n\tinitLocalCluster sync.Once\n)\n\nfunc (db *db) getLocalCluster() *appv1.Cluster {\n\tinitLocalCluster.Do(func() {\n\t\tinfo, err := db.kubeclientset.Discovery().ServerVersion()\n\t\tif err == nil {\n\t\t\tlocalCluster.ServerVersion = fmt.Sprintf(\"%s.%s\", info.Major, info.Minor)\n\t\t\tlocalCluster.ConnectionState = appv1.ConnectionState{Status: appv1.ConnectionStatusSuccessful}\n\t\t} else {\n\t\t\tlocalCluster.ConnectionState = appv1.ConnectionState{\n\t\t\t\tStatus:  appv1.ConnectionStatusFailed,\n\t\t\t\tMessage: err.Error(),\n\t\t\t}\n\t\t}\n\t})\n\tcluster := localCluster.DeepCopy()\n\tnow := metav1.Now()\n\tcluster.ConnectionState.ModifiedAt = &now\n\treturn cluster\n}\n\n// ListClusters returns list of clusters\nfunc (db *db) ListClusters(ctx context.Context) (*appv1.ClusterList, error) {\n\tclusterSecrets, err := db.listSecretsByType(common.LabelValueSecretTypeCluster)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclusterList := appv1.ClusterList{\n\t\tItems: make([]appv1.Cluster, 0),\n\t}\n\tsettings, err := db.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tinClusterEnabled := settings.InClusterEnabled\n\thasInClusterCredentials := false\n\tfor _, clusterSecret := range clusterSecrets {\n\t\tcluster, err := SecretToCluster(clusterSecret)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"could not unmarshal cluster secret %s\", clusterSecret.Name)\n\t\t\tcontinue\n\t\t}\n\t\tif cluster.Server == appv1.KubernetesInternalAPIServerAddr {\n\t\t\tif inClusterEnabled {\n\t\t\t\thasInClusterCredentials = true\n\t\t\t\tclusterList.Items = append(clusterList.Items, *cluster)\n\t\t\t}\n\t\t} else {\n\t\t\tclusterList.Items = append(clusterList.Items, *cluster)\n\t\t}\n\t}\n\tif inClusterEnabled && !hasInClusterCredentials {\n\t\tclusterList.Items = append(clusterList.Items, *db.getLocalCluster())\n\t}\n\treturn &clusterList, nil\n}\n\n// CreateCluster creates a cluster\nfunc (db *db) CreateCluster(ctx context.Context, c *appv1.Cluster) (*appv1.Cluster, error) {\n\tsettings, err := db.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif c.Server == appv1.KubernetesInternalAPIServerAddr && !settings.InClusterEnabled {\n\t\treturn nil, status.Errorf(codes.InvalidArgument, \"cannot register cluster: in-cluster has been disabled\")\n\t}\n\tsecName, err := URIToSecretName(\"cluster\", c.Server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclusterSecret := &apiv1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: secName,\n\t\t},\n\t}\n\n\tif err = clusterToSecret(c, clusterSecret); err != nil {\n\t\treturn nil, err\n\t}\n\n\tclusterSecret, err = db.createSecret(ctx, clusterSecret)\n\tif err != nil {\n\t\tif apierr.IsAlreadyExists(err) {\n\t\t\treturn nil, status.Errorf(codes.AlreadyExists, \"cluster %q already exists\", c.Server)\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tcluster, err := SecretToCluster(clusterSecret)\n\tif err != nil {\n\t\treturn nil, status.Errorf(codes.InvalidArgument, \"could not unmarshal cluster secret %s\", clusterSecret.Name)\n\t}\n\treturn cluster, db.settingsMgr.ResyncInformers()\n}\n\n// ClusterEvent contains information about cluster event\ntype ClusterEvent struct {\n\tType    watch.EventType\n\tCluster *appv1.Cluster\n}\n\nfunc (db *db) WatchClusters(ctx context.Context,\n\thandleAddEvent func(cluster *appv1.Cluster),\n\thandleModEvent func(oldCluster *appv1.Cluster, newCluster *appv1.Cluster),\n\thandleDeleteEvent func(clusterServer string)) error {\n\tlocalCls, err := db.GetCluster(ctx, appv1.KubernetesInternalAPIServerAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\thandleAddEvent(localCls)\n\n\tdb.watchSecrets(\n\t\tctx,\n\t\tcommon.LabelValueSecretTypeCluster,\n\n\t\tfunc(secret *apiv1.Secret) {\n\t\t\tcluster, err := SecretToCluster(secret)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"could not unmarshal cluster secret %s\", secret.Name)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif cluster.Server == appv1.KubernetesInternalAPIServerAddr {\n\t\t\t\t// change local cluster event to modified or deleted, since it cannot be re-added or deleted\n\t\t\t\thandleModEvent(localCls, cluster)\n\t\t\t\tlocalCls = cluster\n\t\t\t\treturn\n\t\t\t}\n\t\t\thandleAddEvent(cluster)\n\t\t},\n\n\t\tfunc(oldSecret *apiv1.Secret, newSecret *apiv1.Secret) {\n\t\t\toldCluster, err := SecretToCluster(oldSecret)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"could not unmarshal cluster secret %s\", oldSecret.Name)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnewCluster, err := SecretToCluster(newSecret)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"could not unmarshal cluster secret %s\", newSecret.Name)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif newCluster.Server == appv1.KubernetesInternalAPIServerAddr {\n\t\t\t\tlocalCls = newCluster\n\t\t\t}\n\t\t\thandleModEvent(oldCluster, newCluster)\n\t\t},\n\n\t\tfunc(secret *apiv1.Secret) {\n\t\t\tif string(secret.Data[\"server\"]) == appv1.KubernetesInternalAPIServerAddr {\n\t\t\t\t// change local cluster event to modified or deleted, since it cannot be re-added or deleted\n\t\t\t\thandleModEvent(localCls, db.getLocalCluster())\n\t\t\t\tlocalCls = db.getLocalCluster()\n\t\t\t} else {\n\t\t\t\thandleDeleteEvent(string(secret.Data[\"server\"]))\n\t\t\t}\n\t\t},\n\t)\n\n\treturn err\n}\n\nfunc (db *db) getClusterSecret(server string) (*apiv1.Secret, error) {\n\tclusterSecrets, err := db.listSecretsByType(common.LabelValueSecretTypeCluster)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsrv := strings.TrimRight(server, \"/\")\n\tfor _, clusterSecret := range clusterSecrets {\n\t\tif strings.TrimRight(string(clusterSecret.Data[\"server\"]), \"/\") == srv {\n\t\t\treturn clusterSecret, nil\n\t\t}\n\t}\n\treturn nil, status.Errorf(codes.NotFound, \"cluster %q not found\", server)\n}\n\n// GetCluster returns a cluster from a query\nfunc (db *db) GetCluster(_ context.Context, server string) (*appv1.Cluster, error) {\n\tinformer, err := db.settingsMgr.GetSecretsInformer()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tres, err := informer.GetIndexer().ByIndex(settings.ByClusterURLIndexer, server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(res) > 0 {\n\t\treturn SecretToCluster(res[0].(*apiv1.Secret))\n\t}\n\tif server == appv1.KubernetesInternalAPIServerAddr {\n\t\treturn db.getLocalCluster(), nil\n\t}\n\n\treturn nil, status.Errorf(codes.NotFound, \"cluster %q not found\", server)\n}\n\n// GetProjectClusters return project scoped clusters by given project name\nfunc (db *db) GetProjectClusters(ctx context.Context, project string) ([]*appv1.Cluster, error) {\n\tinformer, err := db.settingsMgr.GetSecretsInformer()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get secrets informer: %w\", err)\n\t}\n\tsecrets, err := informer.GetIndexer().ByIndex(settings.ByProjectClusterIndexer, project)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get index by project cluster indexer for project %q: %w\", project, err)\n\t}\n\tvar res []*appv1.Cluster\n\tfor i := range secrets {\n\t\tcluster, err := SecretToCluster(secrets[i].(*apiv1.Secret))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to convert secret to cluster: %w\", err)\n\t\t}\n\t\tres = append(res, cluster)\n\t}\n\treturn res, nil\n}\n\nfunc (db *db) GetClusterServersByName(ctx context.Context, name string) ([]string, error) {\n\tinformer, err := db.settingsMgr.GetSecretsInformer()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// if local cluster name is not overridden and specified name is local cluster name, return local cluster server\n\tlocalClusterSecrets, err := informer.GetIndexer().ByIndex(settings.ByClusterURLIndexer, appv1.KubernetesInternalAPIServerAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(localClusterSecrets) == 0 && db.getLocalCluster().Name == name {\n\t\treturn []string{appv1.KubernetesInternalAPIServerAddr}, nil\n\t}\n\n\tsecrets, err := informer.GetIndexer().ByIndex(settings.ByClusterNameIndexer, name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar res []string\n\tfor i := range secrets {\n\t\ts := secrets[i].(*apiv1.Secret)\n\t\tres = append(res, strings.TrimRight(string(s.Data[\"server\"]), \"/\"))\n\t}\n\treturn res, nil\n}\n\n// UpdateCluster updates a cluster\nfunc (db *db) UpdateCluster(ctx context.Context, c *appv1.Cluster) (*appv1.Cluster, error) {\n\tclusterSecret, err := db.getClusterSecret(c.Server)\n\tif err != nil {\n\t\tif status.Code(err) == codes.NotFound {\n\t\t\treturn db.CreateCluster(ctx, c)\n\t\t}\n\t\treturn nil, err\n\t}\n\tif err := clusterToSecret(c, clusterSecret); err != nil {\n\t\treturn nil, err\n\t}\n\n\tclusterSecret, err = db.kubeclientset.CoreV1().Secrets(db.ns).Update(ctx, clusterSecret, metav1.UpdateOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcluster, err := SecretToCluster(clusterSecret)\n\tif err != nil {\n\t\tlog.Errorf(\"could not unmarshal cluster secret %s\", clusterSecret.Name)\n\t\treturn nil, err\n\t}\n\treturn cluster, db.settingsMgr.ResyncInformers()\n}\n\n// DeleteCluster deletes a cluster by name\nfunc (db *db) DeleteCluster(ctx context.Context, server string) error {\n\tsecret, err := db.getClusterSecret(server)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = db.deleteSecret(ctx, secret)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn db.settingsMgr.ResyncInformers()\n}\n\n// clusterToData converts a cluster object to string data for serialization to a secret\nfunc clusterToSecret(c *appv1.Cluster, secret *apiv1.Secret) error {\n\tdata := make(map[string][]byte)\n\tdata[\"server\"] = []byte(strings.TrimRight(c.Server, \"/\"))\n\tif c.Name == \"\" {\n\t\tdata[\"name\"] = []byte(c.Server)\n\t} else {\n\t\tdata[\"name\"] = []byte(c.Name)\n\t}\n\tif len(c.Namespaces) != 0 {\n\t\tdata[\"namespaces\"] = []byte(strings.Join(c.Namespaces, \",\"))\n\t}\n\tconfigBytes, err := json.Marshal(c.Config)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdata[\"config\"] = configBytes\n\tif c.Shard != nil {\n\t\tdata[\"shard\"] = []byte(strconv.Itoa(int(*c.Shard)))\n\t}\n\tif c.ClusterResources {\n\t\tdata[\"clusterResources\"] = []byte(\"true\")\n\t}\n\tif c.Project != \"\" {\n\t\tdata[\"project\"] = []byte(c.Project)\n\t}\n\tsecret.Data = data\n\n\tsecret.Labels = c.Labels\n\tsecret.Annotations = c.Annotations\n\n\tif secret.Annotations == nil {\n\t\tsecret.Annotations = make(map[string]string)\n\t}\n\n\tif c.RefreshRequestedAt != nil {\n\t\tsecret.Annotations[appv1.AnnotationKeyRefresh] = c.RefreshRequestedAt.Format(time.RFC3339)\n\t} else {\n\t\tdelete(secret.Annotations, appv1.AnnotationKeyRefresh)\n\t}\n\taddSecretMetadata(secret, common.LabelValueSecretTypeCluster)\n\treturn nil\n}\n\n// SecretToCluster converts a secret into a Cluster object\nfunc SecretToCluster(s *apiv1.Secret) (*appv1.Cluster, error) {\n\tvar config appv1.ClusterConfig\n\tif len(s.Data[\"config\"]) > 0 {\n\t\terr := json.Unmarshal(s.Data[\"config\"], &config)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal cluster config: %w\", err)\n\t\t}\n\t}\n\n\tvar namespaces []string\n\tfor _, ns := range strings.Split(string(s.Data[\"namespaces\"]), \",\") {\n\t\tif ns = strings.TrimSpace(ns); ns != \"\" {\n\t\t\tnamespaces = append(namespaces, ns)\n\t\t}\n\t}\n\tvar refreshRequestedAt *metav1.Time\n\tif v, found := s.Annotations[appv1.AnnotationKeyRefresh]; found {\n\t\trequestedAt, err := time.Parse(time.RFC3339, v)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Error while parsing date in cluster secret '%s': %v\", s.Name, err)\n\t\t} else {\n\t\t\trefreshRequestedAt = &metav1.Time{Time: requestedAt}\n\t\t}\n\t}\n\tvar shard *int64\n\tif shardStr := s.Data[\"shard\"]; shardStr != nil {\n\t\tif val, err := strconv.Atoi(string(shardStr)); err != nil {\n\t\t\tlog.Warnf(\"Error while parsing shard in cluster secret '%s': %v\", s.Name, err)\n\t\t} else {\n\t\t\tshard = pointer.Int64Ptr(int64(val))\n\t\t}\n\t}\n\n\t// copy labels and annotations excluding system ones\n\tlabels := map[string]string{}\n\tif s.Labels != nil {\n\t\tlabels = collections.CopyStringMap(s.Labels)\n\t\tdelete(labels, common.LabelKeySecretType)\n\t}\n\tannotations := map[string]string{}\n\tif s.Annotations != nil {\n\t\tannotations = collections.CopyStringMap(s.Annotations)\n\t\tdelete(annotations, common.AnnotationKeyManagedBy)\n\t}\n\n\tcluster := appv1.Cluster{\n\t\tID:                 string(s.UID),\n\t\tServer:             strings.TrimRight(string(s.Data[\"server\"]), \"/\"),\n\t\tName:               string(s.Data[\"name\"]),\n\t\tNamespaces:         namespaces,\n\t\tClusterResources:   string(s.Data[\"clusterResources\"]) == \"true\",\n\t\tConfig:             config,\n\t\tRefreshRequestedAt: refreshRequestedAt,\n\t\tShard:              shard,\n\t\tProject:            string(s.Data[\"project\"]),\n\t\tLabels:             labels,\n\t\tAnnotations:        annotations,\n\t}\n\treturn &cluster, nil\n}\n", "package db\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\tv1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/client-go/kubernetes/fake\"\n\n\t\"github.com/argoproj/argo-cd/v2/common\"\n\t\"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\tappv1 \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/v2/util/settings\"\n)\n\nconst (\n\tfakeNamespace = \"fake-ns\"\n)\n\nfunc Test_URIToSecretName(t *testing.T) {\n\tname, err := URIToSecretName(\"cluster\", \"http://foo\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"cluster-foo-752281925\", name)\n}\n\nfunc Test_secretToCluster(t *testing.T) {\n\tlabels := map[string]string{\"key1\": \"val1\"}\n\tannotations := map[string]string{\"key2\": \"val2\"}\n\tsecret := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:        \"mycluster\",\n\t\t\tNamespace:   fakeNamespace,\n\t\t\tLabels:      labels,\n\t\t\tAnnotations: annotations,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"name\":   []byte(\"test\"),\n\t\t\t\"server\": []byte(\"http://mycluster\"),\n\t\t\t\"config\": []byte(\"{\\\"username\\\":\\\"foo\\\"}\"),\n\t\t},\n\t}\n\tcluster, err := SecretToCluster(secret)\n\trequire.NoError(t, err)\n\tassert.Equal(t, *cluster, v1alpha1.Cluster{\n\t\tName:   \"test\",\n\t\tServer: \"http://mycluster\",\n\t\tConfig: v1alpha1.ClusterConfig{\n\t\t\tUsername: \"foo\",\n\t\t},\n\t\tLabels:      labels,\n\t\tAnnotations: annotations,\n\t})\n}\n\nfunc TestClusterToSecret(t *testing.T) {\n\tcluster := &appv1.Cluster{\n\t\tServer:      \"server\",\n\t\tLabels:      map[string]string{\"test\": \"label\"},\n\t\tAnnotations: map[string]string{\"test\": \"annotation\"},\n\t\tName:        \"test\",\n\t\tConfig:      v1alpha1.ClusterConfig{},\n\t\tProject:     \"project\",\n\t\tNamespaces:  []string{\"default\"},\n\t}\n\ts := &v1.Secret{}\n\terr := clusterToSecret(cluster, s)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, []byte(cluster.Server), s.Data[\"server\"])\n\tassert.Equal(t, []byte(cluster.Name), s.Data[\"name\"])\n\tassert.Equal(t, []byte(cluster.Project), s.Data[\"project\"])\n\tassert.Equal(t, []byte(\"default\"), s.Data[\"namespaces\"])\n\tassert.Equal(t, cluster.Annotations, s.Annotations)\n\tassert.Equal(t, cluster.Labels, s.Labels)\n}\n\nfunc Test_secretToCluster_NoConfig(t *testing.T) {\n\tsecret := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"mycluster\",\n\t\t\tNamespace: fakeNamespace,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"name\":   []byte(\"test\"),\n\t\t\t\"server\": []byte(\"http://mycluster\"),\n\t\t},\n\t}\n\tcluster, err := SecretToCluster(secret)\n\tassert.NoError(t, err)\n\tassert.Equal(t, *cluster, v1alpha1.Cluster{\n\t\tName:        \"test\",\n\t\tServer:      \"http://mycluster\",\n\t\tLabels:      map[string]string{},\n\t\tAnnotations: map[string]string{},\n\t})\n}\n\nfunc Test_secretToCluster_InvalidConfig(t *testing.T) {\n\tsecret := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"mycluster\",\n\t\t\tNamespace: fakeNamespace,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"name\":   []byte(\"test\"),\n\t\t\t\"server\": []byte(\"http://mycluster\"),\n\t\t\t\"config\": []byte(\"{'tlsClientConfig':{'insecure':false}}\"),\n\t\t},\n\t}\n\tcluster, err := SecretToCluster(secret)\n\trequire.Error(t, err)\n\tassert.Nil(t, cluster)\n}\n\nfunc TestUpdateCluster(t *testing.T) {\n\tkubeclientset := fake.NewSimpleClientset(&v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"mycluster\",\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\tcommon.LabelKeySecretType: common.LabelValueSecretTypeCluster,\n\t\t\t},\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"server\": []byte(\"http://mycluster\"),\n\t\t\t\"config\": []byte(\"{}\"),\n\t\t},\n\t})\n\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\trequestedAt := metav1.Now()\n\t_, err := db.UpdateCluster(context.Background(), &v1alpha1.Cluster{\n\t\tName:               \"test\",\n\t\tServer:             \"http://mycluster\",\n\t\tRefreshRequestedAt: &requestedAt,\n\t})\n\tif !assert.NoError(t, err) {\n\t\treturn\n\t}\n\n\tsecret, err := kubeclientset.CoreV1().Secrets(fakeNamespace).Get(context.Background(), \"mycluster\", metav1.GetOptions{})\n\tif !assert.NoError(t, err) {\n\t\treturn\n\t}\n\n\tassert.Equal(t, secret.Annotations[v1alpha1.AnnotationKeyRefresh], requestedAt.Format(time.RFC3339))\n}\n\nfunc TestDeleteUnknownCluster(t *testing.T) {\n\tkubeclientset := fake.NewSimpleClientset(&v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"mycluster\",\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\tcommon.LabelKeySecretType: common.LabelValueSecretTypeCluster,\n\t\t\t},\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"server\": []byte(\"http://mycluster\"),\n\t\t\t\"name\":   []byte(\"mycluster\"),\n\t\t},\n\t})\n\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\tassert.EqualError(t, db.DeleteCluster(context.Background(), \"http://unknown\"), `rpc error: code = NotFound desc = cluster \"http://unknown\" not found`)\n}\n\nfunc TestRejectCreationForInClusterWhenDisabled(t *testing.T) {\n\targoCDConfigMapWithInClusterServerAddressDisabled := &v1.ConfigMap{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      common.ArgoCDConfigMapName,\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app.kubernetes.io/part-of\": \"argocd\",\n\t\t\t},\n\t\t},\n\t\tData: map[string]string{\"cluster.inClusterEnabled\": \"false\"},\n\t}\n\targoCDSecret := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      common.ArgoCDSecretName,\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app.kubernetes.io/part-of\": \"argocd\",\n\t\t\t},\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"admin.password\":   nil,\n\t\t\t\"server.secretkey\": nil,\n\t\t},\n\t}\n\tkubeclientset := fake.NewSimpleClientset(argoCDConfigMapWithInClusterServerAddressDisabled, argoCDSecret)\n\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\t_, err := db.CreateCluster(context.Background(), &appv1.Cluster{\n\t\tServer: appv1.KubernetesInternalAPIServerAddr,\n\t\tName:   \"incluster-name\",\n\t})\n\tassert.Error(t, err)\n}\n\nfunc runWatchTest(t *testing.T, db ArgoDB, actions []func(old *v1alpha1.Cluster, new *v1alpha1.Cluster)) {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\ttimeout := time.Second * 5\n\n\tallDone := make(chan bool, 1)\n\n\tdoNext := func(old *v1alpha1.Cluster, new *v1alpha1.Cluster) {\n\t\tif len(actions) == 0 {\n\t\t\tassert.Fail(t, \"Unexpected event\")\n\t\t}\n\t\tnext := actions[0]\n\t\tnext(old, new)\n\t\tif t.Failed() {\n\t\t\tallDone <- true\n\t\t}\n\t\tif len(actions) == 1 {\n\t\t\tallDone <- true\n\t\t} else {\n\t\t\tactions = actions[1:]\n\t\t}\n\t}\n\n\tgo func() {\n\t\tassert.NoError(t, db.WatchClusters(ctx, func(cluster *v1alpha1.Cluster) {\n\t\t\tdoNext(nil, cluster)\n\t\t}, func(oldCluster *v1alpha1.Cluster, newCluster *v1alpha1.Cluster) {\n\t\t\tdoNext(oldCluster, newCluster)\n\t\t}, func(clusterServer string) {\n\t\t\tdoNext(&v1alpha1.Cluster{Server: clusterServer}, nil)\n\t\t}))\n\t}()\n\n\tselect {\n\tcase <-allDone:\n\tcase <-time.After(timeout):\n\t\tassert.Fail(t, \"Failed due to timeout\")\n\t}\n\n}\n\nfunc TestListClusters(t *testing.T) {\n\temptyArgoCDConfigMap := &v1.ConfigMap{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      common.ArgoCDConfigMapName,\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app.kubernetes.io/part-of\": \"argocd\",\n\t\t\t},\n\t\t},\n\t\tData: map[string]string{},\n\t}\n\targoCDConfigMapWithInClusterServerAddressDisabled := &v1.ConfigMap{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      common.ArgoCDConfigMapName,\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app.kubernetes.io/part-of\": \"argocd\",\n\t\t\t},\n\t\t},\n\t\tData: map[string]string{\"cluster.inClusterEnabled\": \"false\"},\n\t}\n\targoCDSecret := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      common.ArgoCDSecretName,\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app.kubernetes.io/part-of\": \"argocd\",\n\t\t\t},\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"admin.password\":   nil,\n\t\t\t\"server.secretkey\": nil,\n\t\t},\n\t}\n\tsecretForServerWithInClusterAddr := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"mycluster1\",\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\tcommon.LabelKeySecretType: common.LabelValueSecretTypeCluster,\n\t\t\t},\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"server\": []byte(appv1.KubernetesInternalAPIServerAddr),\n\t\t\t\"name\":   []byte(\"in-cluster\"),\n\t\t},\n\t}\n\n\tsecretForServerWithExternalClusterAddr := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"mycluster2\",\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\tcommon.LabelKeySecretType: common.LabelValueSecretTypeCluster,\n\t\t\t},\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"server\": []byte(\"http://mycluster2\"),\n\t\t\t\"name\":   []byte(\"mycluster2\"),\n\t\t},\n\t}\n\n\tinvalidSecret := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"mycluster3\",\n\t\t\tNamespace: fakeNamespace,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"name\":   []byte(\"test\"),\n\t\t\t\"server\": []byte(\"http://mycluster3\"),\n\t\t\t\"config\": []byte(\"{'tlsClientConfig':{'insecure':false}}\"),\n\t\t},\n\t}\n\n\tt.Run(\"Valid clusters\", func(t *testing.T) {\n\t\tkubeclientset := fake.NewSimpleClientset(secretForServerWithInClusterAddr, secretForServerWithExternalClusterAddr, emptyArgoCDConfigMap, argoCDSecret)\n\t\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\t\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\n\t\tclusters, err := db.ListClusters(context.TODO())\n\t\trequire.NoError(t, err)\n\t\tassert.Len(t, clusters.Items, 2)\n\t})\n\n\tt.Run(\"Cluster list with invalid cluster\", func(t *testing.T) {\n\t\tkubeclientset := fake.NewSimpleClientset(secretForServerWithInClusterAddr, secretForServerWithExternalClusterAddr, invalidSecret, emptyArgoCDConfigMap, argoCDSecret)\n\t\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\t\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\n\t\tclusters, err := db.ListClusters(context.TODO())\n\t\trequire.NoError(t, err)\n\t\tassert.Len(t, clusters.Items, 2)\n\t})\n\n\tt.Run(\"Implicit in-cluster secret\", func(t *testing.T) {\n\t\tkubeclientset := fake.NewSimpleClientset(secretForServerWithExternalClusterAddr, emptyArgoCDConfigMap, argoCDSecret)\n\t\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\t\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\n\t\tclusters, err := db.ListClusters(context.TODO())\n\t\trequire.NoError(t, err)\n\t\t// ListClusters() should have added an implicit in-cluster secret to the list\n\t\tassert.Len(t, clusters.Items, 2)\n\t})\n\n\tt.Run(\"ListClusters() should not add the cluster with in-cluster server address since in-cluster is disabled\", func(t *testing.T) {\n\t\tkubeclientset := fake.NewSimpleClientset(secretForServerWithInClusterAddr, argoCDConfigMapWithInClusterServerAddressDisabled, argoCDSecret)\n\t\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\t\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\n\t\tclusters, err := db.ListClusters(context.TODO())\n\t\trequire.NoError(t, err)\n\t\tassert.Len(t, clusters.Items, 0)\n\t})\n\n\tt.Run(\"ListClusters() should add this cluster since it does not contain in-cluster server address even though in-cluster is disabled\", func(t *testing.T) {\n\t\tkubeclientset := fake.NewSimpleClientset(secretForServerWithExternalClusterAddr, argoCDConfigMapWithInClusterServerAddressDisabled, argoCDSecret)\n\t\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\t\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\n\t\tclusters, err := db.ListClusters(context.TODO())\n\t\trequire.NoError(t, err)\n\t\tassert.Len(t, clusters.Items, 1)\n\t})\n}\n"], "fixing_code": ["package db\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\tlog \"github.com/sirupsen/logrus\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\tapiv1 \"k8s.io/api/core/v1\"\n\tapierr \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/watch\"\n\t\"k8s.io/utils/pointer\"\n\n\t\"github.com/argoproj/argo-cd/v2/common\"\n\tappv1 \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/v2/util/collections\"\n\t\"github.com/argoproj/argo-cd/v2/util/settings\"\n)\n\nvar (\n\tlocalCluster = appv1.Cluster{\n\t\tName:            \"in-cluster\",\n\t\tServer:          appv1.KubernetesInternalAPIServerAddr,\n\t\tConnectionState: appv1.ConnectionState{Status: appv1.ConnectionStatusSuccessful},\n\t}\n\tinitLocalCluster sync.Once\n)\n\nfunc (db *db) getLocalCluster() *appv1.Cluster {\n\tinitLocalCluster.Do(func() {\n\t\tinfo, err := db.kubeclientset.Discovery().ServerVersion()\n\t\tif err == nil {\n\t\t\tlocalCluster.ServerVersion = fmt.Sprintf(\"%s.%s\", info.Major, info.Minor)\n\t\t\tlocalCluster.ConnectionState = appv1.ConnectionState{Status: appv1.ConnectionStatusSuccessful}\n\t\t} else {\n\t\t\tlocalCluster.ConnectionState = appv1.ConnectionState{\n\t\t\t\tStatus:  appv1.ConnectionStatusFailed,\n\t\t\t\tMessage: err.Error(),\n\t\t\t}\n\t\t}\n\t})\n\tcluster := localCluster.DeepCopy()\n\tnow := metav1.Now()\n\tcluster.ConnectionState.ModifiedAt = &now\n\treturn cluster\n}\n\n// ListClusters returns list of clusters\nfunc (db *db) ListClusters(ctx context.Context) (*appv1.ClusterList, error) {\n\tclusterSecrets, err := db.listSecretsByType(common.LabelValueSecretTypeCluster)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclusterList := appv1.ClusterList{\n\t\tItems: make([]appv1.Cluster, 0),\n\t}\n\tsettings, err := db.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tinClusterEnabled := settings.InClusterEnabled\n\thasInClusterCredentials := false\n\tfor _, clusterSecret := range clusterSecrets {\n\t\tcluster, err := SecretToCluster(clusterSecret)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"could not unmarshal cluster secret %s\", clusterSecret.Name)\n\t\t\tcontinue\n\t\t}\n\t\tif cluster.Server == appv1.KubernetesInternalAPIServerAddr {\n\t\t\tif inClusterEnabled {\n\t\t\t\thasInClusterCredentials = true\n\t\t\t\tclusterList.Items = append(clusterList.Items, *cluster)\n\t\t\t}\n\t\t} else {\n\t\t\tclusterList.Items = append(clusterList.Items, *cluster)\n\t\t}\n\t}\n\tif inClusterEnabled && !hasInClusterCredentials {\n\t\tclusterList.Items = append(clusterList.Items, *db.getLocalCluster())\n\t}\n\treturn &clusterList, nil\n}\n\n// CreateCluster creates a cluster\nfunc (db *db) CreateCluster(ctx context.Context, c *appv1.Cluster) (*appv1.Cluster, error) {\n\tsettings, err := db.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif c.Server == appv1.KubernetesInternalAPIServerAddr && !settings.InClusterEnabled {\n\t\treturn nil, status.Errorf(codes.InvalidArgument, \"cannot register cluster: in-cluster has been disabled\")\n\t}\n\tsecName, err := URIToSecretName(\"cluster\", c.Server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclusterSecret := &apiv1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: secName,\n\t\t},\n\t}\n\n\tif err = clusterToSecret(c, clusterSecret); err != nil {\n\t\treturn nil, err\n\t}\n\n\tclusterSecret, err = db.createSecret(ctx, clusterSecret)\n\tif err != nil {\n\t\tif apierr.IsAlreadyExists(err) {\n\t\t\treturn nil, status.Errorf(codes.AlreadyExists, \"cluster %q already exists\", c.Server)\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tcluster, err := SecretToCluster(clusterSecret)\n\tif err != nil {\n\t\treturn nil, status.Errorf(codes.InvalidArgument, \"could not unmarshal cluster secret %s\", clusterSecret.Name)\n\t}\n\treturn cluster, db.settingsMgr.ResyncInformers()\n}\n\n// ClusterEvent contains information about cluster event\ntype ClusterEvent struct {\n\tType    watch.EventType\n\tCluster *appv1.Cluster\n}\n\nfunc (db *db) WatchClusters(ctx context.Context,\n\thandleAddEvent func(cluster *appv1.Cluster),\n\thandleModEvent func(oldCluster *appv1.Cluster, newCluster *appv1.Cluster),\n\thandleDeleteEvent func(clusterServer string)) error {\n\tlocalCls, err := db.GetCluster(ctx, appv1.KubernetesInternalAPIServerAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\thandleAddEvent(localCls)\n\n\tdb.watchSecrets(\n\t\tctx,\n\t\tcommon.LabelValueSecretTypeCluster,\n\n\t\tfunc(secret *apiv1.Secret) {\n\t\t\tcluster, err := SecretToCluster(secret)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"could not unmarshal cluster secret %s\", secret.Name)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif cluster.Server == appv1.KubernetesInternalAPIServerAddr {\n\t\t\t\t// change local cluster event to modified or deleted, since it cannot be re-added or deleted\n\t\t\t\thandleModEvent(localCls, cluster)\n\t\t\t\tlocalCls = cluster\n\t\t\t\treturn\n\t\t\t}\n\t\t\thandleAddEvent(cluster)\n\t\t},\n\n\t\tfunc(oldSecret *apiv1.Secret, newSecret *apiv1.Secret) {\n\t\t\toldCluster, err := SecretToCluster(oldSecret)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"could not unmarshal cluster secret %s\", oldSecret.Name)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnewCluster, err := SecretToCluster(newSecret)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"could not unmarshal cluster secret %s\", newSecret.Name)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif newCluster.Server == appv1.KubernetesInternalAPIServerAddr {\n\t\t\t\tlocalCls = newCluster\n\t\t\t}\n\t\t\thandleModEvent(oldCluster, newCluster)\n\t\t},\n\n\t\tfunc(secret *apiv1.Secret) {\n\t\t\tif string(secret.Data[\"server\"]) == appv1.KubernetesInternalAPIServerAddr {\n\t\t\t\t// change local cluster event to modified or deleted, since it cannot be re-added or deleted\n\t\t\t\thandleModEvent(localCls, db.getLocalCluster())\n\t\t\t\tlocalCls = db.getLocalCluster()\n\t\t\t} else {\n\t\t\t\thandleDeleteEvent(string(secret.Data[\"server\"]))\n\t\t\t}\n\t\t},\n\t)\n\n\treturn err\n}\n\nfunc (db *db) getClusterSecret(server string) (*apiv1.Secret, error) {\n\tclusterSecrets, err := db.listSecretsByType(common.LabelValueSecretTypeCluster)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsrv := strings.TrimRight(server, \"/\")\n\tfor _, clusterSecret := range clusterSecrets {\n\t\tif strings.TrimRight(string(clusterSecret.Data[\"server\"]), \"/\") == srv {\n\t\t\treturn clusterSecret, nil\n\t\t}\n\t}\n\treturn nil, status.Errorf(codes.NotFound, \"cluster %q not found\", server)\n}\n\n// GetCluster returns a cluster from a query\nfunc (db *db) GetCluster(_ context.Context, server string) (*appv1.Cluster, error) {\n\tinformer, err := db.settingsMgr.GetSecretsInformer()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tres, err := informer.GetIndexer().ByIndex(settings.ByClusterURLIndexer, server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(res) > 0 {\n\t\treturn SecretToCluster(res[0].(*apiv1.Secret))\n\t}\n\tif server == appv1.KubernetesInternalAPIServerAddr {\n\t\treturn db.getLocalCluster(), nil\n\t}\n\n\treturn nil, status.Errorf(codes.NotFound, \"cluster %q not found\", server)\n}\n\n// GetProjectClusters return project scoped clusters by given project name\nfunc (db *db) GetProjectClusters(ctx context.Context, project string) ([]*appv1.Cluster, error) {\n\tinformer, err := db.settingsMgr.GetSecretsInformer()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get secrets informer: %w\", err)\n\t}\n\tsecrets, err := informer.GetIndexer().ByIndex(settings.ByProjectClusterIndexer, project)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get index by project cluster indexer for project %q: %w\", project, err)\n\t}\n\tvar res []*appv1.Cluster\n\tfor i := range secrets {\n\t\tcluster, err := SecretToCluster(secrets[i].(*apiv1.Secret))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to convert secret to cluster: %w\", err)\n\t\t}\n\t\tres = append(res, cluster)\n\t}\n\treturn res, nil\n}\n\nfunc (db *db) GetClusterServersByName(ctx context.Context, name string) ([]string, error) {\n\tinformer, err := db.settingsMgr.GetSecretsInformer()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// if local cluster name is not overridden and specified name is local cluster name, return local cluster server\n\tlocalClusterSecrets, err := informer.GetIndexer().ByIndex(settings.ByClusterURLIndexer, appv1.KubernetesInternalAPIServerAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(localClusterSecrets) == 0 && db.getLocalCluster().Name == name {\n\t\treturn []string{appv1.KubernetesInternalAPIServerAddr}, nil\n\t}\n\n\tsecrets, err := informer.GetIndexer().ByIndex(settings.ByClusterNameIndexer, name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar res []string\n\tfor i := range secrets {\n\t\ts := secrets[i].(*apiv1.Secret)\n\t\tres = append(res, strings.TrimRight(string(s.Data[\"server\"]), \"/\"))\n\t}\n\treturn res, nil\n}\n\n// UpdateCluster updates a cluster\nfunc (db *db) UpdateCluster(ctx context.Context, c *appv1.Cluster) (*appv1.Cluster, error) {\n\tclusterSecret, err := db.getClusterSecret(c.Server)\n\tif err != nil {\n\t\tif status.Code(err) == codes.NotFound {\n\t\t\treturn db.CreateCluster(ctx, c)\n\t\t}\n\t\treturn nil, err\n\t}\n\tif err := clusterToSecret(c, clusterSecret); err != nil {\n\t\treturn nil, err\n\t}\n\n\tclusterSecret, err = db.kubeclientset.CoreV1().Secrets(db.ns).Update(ctx, clusterSecret, metav1.UpdateOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcluster, err := SecretToCluster(clusterSecret)\n\tif err != nil {\n\t\tlog.Errorf(\"could not unmarshal cluster secret %s\", clusterSecret.Name)\n\t\treturn nil, err\n\t}\n\treturn cluster, db.settingsMgr.ResyncInformers()\n}\n\n// DeleteCluster deletes a cluster by name\nfunc (db *db) DeleteCluster(ctx context.Context, server string) error {\n\tsecret, err := db.getClusterSecret(server)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = db.deleteSecret(ctx, secret)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn db.settingsMgr.ResyncInformers()\n}\n\n// clusterToData converts a cluster object to string data for serialization to a secret\nfunc clusterToSecret(c *appv1.Cluster, secret *apiv1.Secret) error {\n\tdata := make(map[string][]byte)\n\tdata[\"server\"] = []byte(strings.TrimRight(c.Server, \"/\"))\n\tif c.Name == \"\" {\n\t\tdata[\"name\"] = []byte(c.Server)\n\t} else {\n\t\tdata[\"name\"] = []byte(c.Name)\n\t}\n\tif len(c.Namespaces) != 0 {\n\t\tdata[\"namespaces\"] = []byte(strings.Join(c.Namespaces, \",\"))\n\t}\n\tconfigBytes, err := json.Marshal(c.Config)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdata[\"config\"] = configBytes\n\tif c.Shard != nil {\n\t\tdata[\"shard\"] = []byte(strconv.Itoa(int(*c.Shard)))\n\t}\n\tif c.ClusterResources {\n\t\tdata[\"clusterResources\"] = []byte(\"true\")\n\t}\n\tif c.Project != \"\" {\n\t\tdata[\"project\"] = []byte(c.Project)\n\t}\n\tsecret.Data = data\n\n\tsecret.Labels = c.Labels\n\tif c.Annotations != nil && c.Annotations[apiv1.LastAppliedConfigAnnotation] != \"\" {\n\t\treturn status.Errorf(codes.InvalidArgument, \"annotation %s cannot be set\", apiv1.LastAppliedConfigAnnotation)\n\t}\n\tsecret.Annotations = c.Annotations\n\n\tif secret.Annotations == nil {\n\t\tsecret.Annotations = make(map[string]string)\n\t}\n\n\tif c.RefreshRequestedAt != nil {\n\t\tsecret.Annotations[appv1.AnnotationKeyRefresh] = c.RefreshRequestedAt.Format(time.RFC3339)\n\t} else {\n\t\tdelete(secret.Annotations, appv1.AnnotationKeyRefresh)\n\t}\n\taddSecretMetadata(secret, common.LabelValueSecretTypeCluster)\n\treturn nil\n}\n\n// SecretToCluster converts a secret into a Cluster object\nfunc SecretToCluster(s *apiv1.Secret) (*appv1.Cluster, error) {\n\tvar config appv1.ClusterConfig\n\tif len(s.Data[\"config\"]) > 0 {\n\t\terr := json.Unmarshal(s.Data[\"config\"], &config)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal cluster config: %w\", err)\n\t\t}\n\t}\n\n\tvar namespaces []string\n\tfor _, ns := range strings.Split(string(s.Data[\"namespaces\"]), \",\") {\n\t\tif ns = strings.TrimSpace(ns); ns != \"\" {\n\t\t\tnamespaces = append(namespaces, ns)\n\t\t}\n\t}\n\tvar refreshRequestedAt *metav1.Time\n\tif v, found := s.Annotations[appv1.AnnotationKeyRefresh]; found {\n\t\trequestedAt, err := time.Parse(time.RFC3339, v)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Error while parsing date in cluster secret '%s': %v\", s.Name, err)\n\t\t} else {\n\t\t\trefreshRequestedAt = &metav1.Time{Time: requestedAt}\n\t\t}\n\t}\n\tvar shard *int64\n\tif shardStr := s.Data[\"shard\"]; shardStr != nil {\n\t\tif val, err := strconv.Atoi(string(shardStr)); err != nil {\n\t\t\tlog.Warnf(\"Error while parsing shard in cluster secret '%s': %v\", s.Name, err)\n\t\t} else {\n\t\t\tshard = pointer.Int64Ptr(int64(val))\n\t\t}\n\t}\n\n\t// copy labels and annotations excluding system ones\n\tlabels := map[string]string{}\n\tif s.Labels != nil {\n\t\tlabels = collections.CopyStringMap(s.Labels)\n\t\tdelete(labels, common.LabelKeySecretType)\n\t}\n\tannotations := map[string]string{}\n\tif s.Annotations != nil {\n\t\tannotations = collections.CopyStringMap(s.Annotations)\n\t\t// delete system annotations\n\t\tdelete(annotations, apiv1.LastAppliedConfigAnnotation)\n\t\tdelete(annotations, common.AnnotationKeyManagedBy)\n\t}\n\n\tcluster := appv1.Cluster{\n\t\tID:                 string(s.UID),\n\t\tServer:             strings.TrimRight(string(s.Data[\"server\"]), \"/\"),\n\t\tName:               string(s.Data[\"name\"]),\n\t\tNamespaces:         namespaces,\n\t\tClusterResources:   string(s.Data[\"clusterResources\"]) == \"true\",\n\t\tConfig:             config,\n\t\tRefreshRequestedAt: refreshRequestedAt,\n\t\tShard:              shard,\n\t\tProject:            string(s.Data[\"project\"]),\n\t\tLabels:             labels,\n\t\tAnnotations:        annotations,\n\t}\n\treturn &cluster, nil\n}\n", "package db\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\tv1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/client-go/kubernetes/fake\"\n\n\t\"github.com/argoproj/argo-cd/v2/common\"\n\t\"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\tappv1 \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/v2/util/settings\"\n)\n\nconst (\n\tfakeNamespace = \"fake-ns\"\n)\n\nfunc Test_URIToSecretName(t *testing.T) {\n\tname, err := URIToSecretName(\"cluster\", \"http://foo\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"cluster-foo-752281925\", name)\n}\n\nfunc Test_secretToCluster(t *testing.T) {\n\tlabels := map[string]string{\"key1\": \"val1\"}\n\tannotations := map[string]string{\"key2\": \"val2\"}\n\tsecret := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:        \"mycluster\",\n\t\t\tNamespace:   fakeNamespace,\n\t\t\tLabels:      labels,\n\t\t\tAnnotations: annotations,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"name\":   []byte(\"test\"),\n\t\t\t\"server\": []byte(\"http://mycluster\"),\n\t\t\t\"config\": []byte(\"{\\\"username\\\":\\\"foo\\\"}\"),\n\t\t},\n\t}\n\tcluster, err := SecretToCluster(secret)\n\trequire.NoError(t, err)\n\tassert.Equal(t, *cluster, v1alpha1.Cluster{\n\t\tName:   \"test\",\n\t\tServer: \"http://mycluster\",\n\t\tConfig: v1alpha1.ClusterConfig{\n\t\t\tUsername: \"foo\",\n\t\t},\n\t\tLabels:      labels,\n\t\tAnnotations: annotations,\n\t})\n}\n\nfunc Test_secretToCluster_LastAppliedConfigurationDropped(t *testing.T) {\n\tsecret := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:        \"mycluster\",\n\t\t\tNamespace:   fakeNamespace,\n\t\t\tAnnotations: map[string]string{v1.LastAppliedConfigAnnotation: \"val2\"},\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"name\":   []byte(\"test\"),\n\t\t\t\"server\": []byte(\"http://mycluster\"),\n\t\t\t\"config\": []byte(\"{\\\"username\\\":\\\"foo\\\"}\"),\n\t\t},\n\t}\n\tcluster, err := SecretToCluster(secret)\n\trequire.NoError(t, err)\n\tassert.Len(t, cluster.Annotations, 0)\n}\n\nfunc TestClusterToSecret(t *testing.T) {\n\tcluster := &appv1.Cluster{\n\t\tServer:      \"server\",\n\t\tLabels:      map[string]string{\"test\": \"label\"},\n\t\tAnnotations: map[string]string{\"test\": \"annotation\"},\n\t\tName:        \"test\",\n\t\tConfig:      v1alpha1.ClusterConfig{},\n\t\tProject:     \"project\",\n\t\tNamespaces:  []string{\"default\"},\n\t}\n\ts := &v1.Secret{}\n\terr := clusterToSecret(cluster, s)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, []byte(cluster.Server), s.Data[\"server\"])\n\tassert.Equal(t, []byte(cluster.Name), s.Data[\"name\"])\n\tassert.Equal(t, []byte(cluster.Project), s.Data[\"project\"])\n\tassert.Equal(t, []byte(\"default\"), s.Data[\"namespaces\"])\n\tassert.Equal(t, cluster.Annotations, s.Annotations)\n\tassert.Equal(t, cluster.Labels, s.Labels)\n}\n\nfunc TestClusterToSecret_LastAppliedConfigurationRejected(t *testing.T) {\n\tcluster := &appv1.Cluster{\n\t\tServer:      \"server\",\n\t\tAnnotations: map[string]string{v1.LastAppliedConfigAnnotation: \"val2\"},\n\t\tName:        \"test\",\n\t\tConfig:      v1alpha1.ClusterConfig{},\n\t\tProject:     \"project\",\n\t\tNamespaces:  []string{\"default\"},\n\t}\n\ts := &v1.Secret{}\n\terr := clusterToSecret(cluster, s)\n\trequire.Error(t, err)\n\trequire.Equal(t, codes.InvalidArgument, status.Code(err))\n}\n\nfunc Test_secretToCluster_NoConfig(t *testing.T) {\n\tsecret := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"mycluster\",\n\t\t\tNamespace: fakeNamespace,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"name\":   []byte(\"test\"),\n\t\t\t\"server\": []byte(\"http://mycluster\"),\n\t\t},\n\t}\n\tcluster, err := SecretToCluster(secret)\n\tassert.NoError(t, err)\n\tassert.Equal(t, *cluster, v1alpha1.Cluster{\n\t\tName:        \"test\",\n\t\tServer:      \"http://mycluster\",\n\t\tLabels:      map[string]string{},\n\t\tAnnotations: map[string]string{},\n\t})\n}\n\nfunc Test_secretToCluster_InvalidConfig(t *testing.T) {\n\tsecret := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"mycluster\",\n\t\t\tNamespace: fakeNamespace,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"name\":   []byte(\"test\"),\n\t\t\t\"server\": []byte(\"http://mycluster\"),\n\t\t\t\"config\": []byte(\"{'tlsClientConfig':{'insecure':false}}\"),\n\t\t},\n\t}\n\tcluster, err := SecretToCluster(secret)\n\trequire.Error(t, err)\n\tassert.Nil(t, cluster)\n}\n\nfunc TestUpdateCluster(t *testing.T) {\n\tkubeclientset := fake.NewSimpleClientset(&v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"mycluster\",\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\tcommon.LabelKeySecretType: common.LabelValueSecretTypeCluster,\n\t\t\t},\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"server\": []byte(\"http://mycluster\"),\n\t\t\t\"config\": []byte(\"{}\"),\n\t\t},\n\t})\n\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\trequestedAt := metav1.Now()\n\t_, err := db.UpdateCluster(context.Background(), &v1alpha1.Cluster{\n\t\tName:               \"test\",\n\t\tServer:             \"http://mycluster\",\n\t\tRefreshRequestedAt: &requestedAt,\n\t})\n\tif !assert.NoError(t, err) {\n\t\treturn\n\t}\n\n\tsecret, err := kubeclientset.CoreV1().Secrets(fakeNamespace).Get(context.Background(), \"mycluster\", metav1.GetOptions{})\n\tif !assert.NoError(t, err) {\n\t\treturn\n\t}\n\n\tassert.Equal(t, secret.Annotations[v1alpha1.AnnotationKeyRefresh], requestedAt.Format(time.RFC3339))\n}\n\nfunc TestDeleteUnknownCluster(t *testing.T) {\n\tkubeclientset := fake.NewSimpleClientset(&v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"mycluster\",\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\tcommon.LabelKeySecretType: common.LabelValueSecretTypeCluster,\n\t\t\t},\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"server\": []byte(\"http://mycluster\"),\n\t\t\t\"name\":   []byte(\"mycluster\"),\n\t\t},\n\t})\n\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\tassert.EqualError(t, db.DeleteCluster(context.Background(), \"http://unknown\"), `rpc error: code = NotFound desc = cluster \"http://unknown\" not found`)\n}\n\nfunc TestRejectCreationForInClusterWhenDisabled(t *testing.T) {\n\targoCDConfigMapWithInClusterServerAddressDisabled := &v1.ConfigMap{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      common.ArgoCDConfigMapName,\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app.kubernetes.io/part-of\": \"argocd\",\n\t\t\t},\n\t\t},\n\t\tData: map[string]string{\"cluster.inClusterEnabled\": \"false\"},\n\t}\n\targoCDSecret := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      common.ArgoCDSecretName,\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app.kubernetes.io/part-of\": \"argocd\",\n\t\t\t},\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"admin.password\":   nil,\n\t\t\t\"server.secretkey\": nil,\n\t\t},\n\t}\n\tkubeclientset := fake.NewSimpleClientset(argoCDConfigMapWithInClusterServerAddressDisabled, argoCDSecret)\n\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\t_, err := db.CreateCluster(context.Background(), &appv1.Cluster{\n\t\tServer: appv1.KubernetesInternalAPIServerAddr,\n\t\tName:   \"incluster-name\",\n\t})\n\tassert.Error(t, err)\n}\n\nfunc runWatchTest(t *testing.T, db ArgoDB, actions []func(old *v1alpha1.Cluster, new *v1alpha1.Cluster)) {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\ttimeout := time.Second * 5\n\n\tallDone := make(chan bool, 1)\n\n\tdoNext := func(old *v1alpha1.Cluster, new *v1alpha1.Cluster) {\n\t\tif len(actions) == 0 {\n\t\t\tassert.Fail(t, \"Unexpected event\")\n\t\t}\n\t\tnext := actions[0]\n\t\tnext(old, new)\n\t\tif t.Failed() {\n\t\t\tallDone <- true\n\t\t}\n\t\tif len(actions) == 1 {\n\t\t\tallDone <- true\n\t\t} else {\n\t\t\tactions = actions[1:]\n\t\t}\n\t}\n\n\tgo func() {\n\t\tassert.NoError(t, db.WatchClusters(ctx, func(cluster *v1alpha1.Cluster) {\n\t\t\tdoNext(nil, cluster)\n\t\t}, func(oldCluster *v1alpha1.Cluster, newCluster *v1alpha1.Cluster) {\n\t\t\tdoNext(oldCluster, newCluster)\n\t\t}, func(clusterServer string) {\n\t\t\tdoNext(&v1alpha1.Cluster{Server: clusterServer}, nil)\n\t\t}))\n\t}()\n\n\tselect {\n\tcase <-allDone:\n\tcase <-time.After(timeout):\n\t\tassert.Fail(t, \"Failed due to timeout\")\n\t}\n\n}\n\nfunc TestListClusters(t *testing.T) {\n\temptyArgoCDConfigMap := &v1.ConfigMap{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      common.ArgoCDConfigMapName,\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app.kubernetes.io/part-of\": \"argocd\",\n\t\t\t},\n\t\t},\n\t\tData: map[string]string{},\n\t}\n\targoCDConfigMapWithInClusterServerAddressDisabled := &v1.ConfigMap{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      common.ArgoCDConfigMapName,\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app.kubernetes.io/part-of\": \"argocd\",\n\t\t\t},\n\t\t},\n\t\tData: map[string]string{\"cluster.inClusterEnabled\": \"false\"},\n\t}\n\targoCDSecret := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      common.ArgoCDSecretName,\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app.kubernetes.io/part-of\": \"argocd\",\n\t\t\t},\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"admin.password\":   nil,\n\t\t\t\"server.secretkey\": nil,\n\t\t},\n\t}\n\tsecretForServerWithInClusterAddr := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"mycluster1\",\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\tcommon.LabelKeySecretType: common.LabelValueSecretTypeCluster,\n\t\t\t},\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"server\": []byte(appv1.KubernetesInternalAPIServerAddr),\n\t\t\t\"name\":   []byte(\"in-cluster\"),\n\t\t},\n\t}\n\n\tsecretForServerWithExternalClusterAddr := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"mycluster2\",\n\t\t\tNamespace: fakeNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\tcommon.LabelKeySecretType: common.LabelValueSecretTypeCluster,\n\t\t\t},\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"server\": []byte(\"http://mycluster2\"),\n\t\t\t\"name\":   []byte(\"mycluster2\"),\n\t\t},\n\t}\n\n\tinvalidSecret := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"mycluster3\",\n\t\t\tNamespace: fakeNamespace,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"name\":   []byte(\"test\"),\n\t\t\t\"server\": []byte(\"http://mycluster3\"),\n\t\t\t\"config\": []byte(\"{'tlsClientConfig':{'insecure':false}}\"),\n\t\t},\n\t}\n\n\tt.Run(\"Valid clusters\", func(t *testing.T) {\n\t\tkubeclientset := fake.NewSimpleClientset(secretForServerWithInClusterAddr, secretForServerWithExternalClusterAddr, emptyArgoCDConfigMap, argoCDSecret)\n\t\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\t\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\n\t\tclusters, err := db.ListClusters(context.TODO())\n\t\trequire.NoError(t, err)\n\t\tassert.Len(t, clusters.Items, 2)\n\t})\n\n\tt.Run(\"Cluster list with invalid cluster\", func(t *testing.T) {\n\t\tkubeclientset := fake.NewSimpleClientset(secretForServerWithInClusterAddr, secretForServerWithExternalClusterAddr, invalidSecret, emptyArgoCDConfigMap, argoCDSecret)\n\t\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\t\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\n\t\tclusters, err := db.ListClusters(context.TODO())\n\t\trequire.NoError(t, err)\n\t\tassert.Len(t, clusters.Items, 2)\n\t})\n\n\tt.Run(\"Implicit in-cluster secret\", func(t *testing.T) {\n\t\tkubeclientset := fake.NewSimpleClientset(secretForServerWithExternalClusterAddr, emptyArgoCDConfigMap, argoCDSecret)\n\t\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\t\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\n\t\tclusters, err := db.ListClusters(context.TODO())\n\t\trequire.NoError(t, err)\n\t\t// ListClusters() should have added an implicit in-cluster secret to the list\n\t\tassert.Len(t, clusters.Items, 2)\n\t})\n\n\tt.Run(\"ListClusters() should not add the cluster with in-cluster server address since in-cluster is disabled\", func(t *testing.T) {\n\t\tkubeclientset := fake.NewSimpleClientset(secretForServerWithInClusterAddr, argoCDConfigMapWithInClusterServerAddressDisabled, argoCDSecret)\n\t\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\t\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\n\t\tclusters, err := db.ListClusters(context.TODO())\n\t\trequire.NoError(t, err)\n\t\tassert.Len(t, clusters.Items, 0)\n\t})\n\n\tt.Run(\"ListClusters() should add this cluster since it does not contain in-cluster server address even though in-cluster is disabled\", func(t *testing.T) {\n\t\tkubeclientset := fake.NewSimpleClientset(secretForServerWithExternalClusterAddr, argoCDConfigMapWithInClusterServerAddressDisabled, argoCDSecret)\n\t\tsettingsManager := settings.NewSettingsManager(context.Background(), kubeclientset, fakeNamespace)\n\t\tdb := NewDB(fakeNamespace, settingsManager, kubeclientset)\n\n\t\tclusters, err := db.ListClusters(context.TODO())\n\t\trequire.NoError(t, err)\n\t\tassert.Len(t, clusters.Items, 1)\n\t})\n}\n"], "filenames": ["util/db/cluster.go", "util/db/cluster_test.go"], "buggy_code_start_loc": [347, 9], "buggy_code_end_loc": [405, 78], "fixing_code_start_loc": [348, 10], "fixing_code_end_loc": [411, 114], "type": "CWE-532", "message": "Argo CD is a declarative continuous deployment for Kubernetes. Argo CD Cluster secrets might be managed declaratively using Argo CD / kubectl apply. As a result, the full secret body is stored in`kubectl.kubernetes.io/last-applied-configuration` annotation. pull request #7139 introduced the ability to manage cluster labels and annotations. Since clusters are stored as secrets it also exposes the `kubectl.kubernetes.io/last-applied-configuration` annotation which includes full secret body. In order to view the cluster annotations via the Argo CD API, the user must have `clusters, get` RBAC access. **Note:** In many cases, cluster secrets do not contain any actually-secret information. But sometimes, as in bearer-token auth, the contents might be very sensitive. The bug has been patched in versions 2.8.3, 2.7.14, and 2.6.15. Users are advised to upgrade. Users unable to upgrade should update/deploy cluster secret with `server-side-apply` flag which does not use or rely on `kubectl.kubernetes.io/last-applied-configuration` annotation. Note: annotation for existing secrets will require manual removal.\n\n", "other": {"cve": {"id": "CVE-2023-40029", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-07T23:15:09.763", "lastModified": "2023-10-27T14:31:09.933", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Argo CD is a declarative continuous deployment for Kubernetes. Argo CD Cluster secrets might be managed declaratively using Argo CD / kubectl apply. As a result, the full secret body is stored in`kubectl.kubernetes.io/last-applied-configuration` annotation. pull request #7139 introduced the ability to manage cluster labels and annotations. Since clusters are stored as secrets it also exposes the `kubectl.kubernetes.io/last-applied-configuration` annotation which includes full secret body. In order to view the cluster annotations via the Argo CD API, the user must have `clusters, get` RBAC access. **Note:** In many cases, cluster secrets do not contain any actually-secret information. But sometimes, as in bearer-token auth, the contents might be very sensitive. The bug has been patched in versions 2.8.3, 2.7.14, and 2.6.15. Users are advised to upgrade. Users unable to upgrade should update/deploy cluster secret with `server-side-apply` flag which does not use or rely on `kubectl.kubernetes.io/last-applied-configuration` annotation. Note: annotation for existing secrets will require manual removal.\n\n"}, {"lang": "es", "value": "Argo CD es una implementaci\u00f3n continua declarativa para Kubernetes. Los secretos de Argo CD Cluster se pueden administrar de forma declarativa utilizando Argo CD / kubectl apply. Como resultado, el secret body completo se almacena en la anotaci\u00f3n `kubectl.kubernetes.io/last-applied-configuration`. La solicitud de extracci\u00f3n #7139 introdujo la capacidad de administrar etiquetas y anotaciones del cl\u00faster. Dado que los cl\u00fasteres se almacenan como secretos, tambi\u00e9n expone la anotaci\u00f3n `kubectl.kubernetes.io/last-applied-configuration` que incluye el secret body completo. Para ver las anotaciones del cl\u00faster a trav\u00e9s de la API de Argo CD, el usuario debe tener acceso RBAC \"clusters, get\". **Nota:** En muchos casos, los secretos del cl\u00faster no contienen ninguna informaci\u00f3n realmente secreta. Pero a veces, como en la autenticaci\u00f3n de token de portador, el contenido puede ser muy sensible. El error se corrigi\u00f3 en las versiones 2.8.3, 2.7.14 y 2.6.15. Se recomienda a los usuarios que actualicen. Los usuarios que no puedan actualizar deben actualizar/implementar el secreto del cl\u00faster con el indicador `server-side-apply` que no utiliza ni depende de la anotaci\u00f3n `kubectl.kubernetes.io/last-applied-configuration`. Nota: la anotaci\u00f3n de secretos existentes requerir\u00e1 eliminaci\u00f3n manual."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 5.8}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-532"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:argo_continuous_delivery:*:*:*:*:*:kubernetes:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.6.15", "matchCriteriaId": "58CD5BCA-BEB8-4FD1-A0A7-79C77BB9D3FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:argo_continuous_delivery:*:*:*:*:*:kubernetes:*:*", "versionStartIncluding": "2.7.0", "versionEndExcluding": "2.7.14", "matchCriteriaId": "C6C6D955-4989-4E0A-A8FF-96B580EB0328"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:argo_continuous_delivery:*:*:*:*:*:kubernetes:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.3", "matchCriteriaId": "DDAB88E7-A10B-4437-9FAE-8BBA6AB1689C"}]}]}], "references": [{"url": "https://github.com/argoproj/argo-cd/commit/4b2e5b06bff2ffd8ed1970654ddd8e55fc4a41c4", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/argoproj/argo-cd/pull/7139", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/argoproj/argo-cd/security/advisories/GHSA-fwr2-64vr-xv9m", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/argoproj/argo-cd/commit/4b2e5b06bff2ffd8ed1970654ddd8e55fc4a41c4"}}