{"buggy_code": ["/*****************************************************************\n|\n|    AP4 - Atom Based Sample Tables\n|\n|    Copyright 2002-2008 Axiomatic Systems, LLC\n|\n|\n|    This atom is part of AP4 (MP4 Audio Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the atom COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n ****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"Ap4AtomSampleTable.h\"\n#include \"Ap4ByteStream.h\"\n#include \"Ap4StsdAtom.h\"\n#include \"Ap4StscAtom.h\"\n#include \"Ap4StcoAtom.h\"\n#include \"Ap4Co64Atom.h\"\n#include \"Ap4StszAtom.h\"\n#include \"Ap4Stz2Atom.h\"\n#include \"Ap4SttsAtom.h\"\n#include \"Ap4CttsAtom.h\"\n#include \"Ap4StssAtom.h\"\n#include \"Ap4Sample.h\"\n#include \"Ap4Atom.h\"\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable Dynamic Cast Anchor\n+---------------------------------------------------------------------*/\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_AtomSampleTable)\n\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::AP4_AtomSampleTable\n+---------------------------------------------------------------------*/\nAP4_AtomSampleTable::AP4_AtomSampleTable(AP4_ContainerAtom* stbl, \n                                         AP4_ByteStream&    sample_stream) :\n    m_SampleStream(sample_stream)\n{\n    m_StscAtom = AP4_DYNAMIC_CAST(AP4_StscAtom, stbl->GetChild(AP4_ATOM_TYPE_STSC));\n    m_StcoAtom = AP4_DYNAMIC_CAST(AP4_StcoAtom, stbl->GetChild(AP4_ATOM_TYPE_STCO));\n    m_StszAtom = AP4_DYNAMIC_CAST(AP4_StszAtom, stbl->GetChild(AP4_ATOM_TYPE_STSZ));\n    m_Stz2Atom = AP4_DYNAMIC_CAST(AP4_Stz2Atom, stbl->GetChild(AP4_ATOM_TYPE_STZ2));\n    m_CttsAtom = AP4_DYNAMIC_CAST(AP4_CttsAtom, stbl->GetChild(AP4_ATOM_TYPE_CTTS));\n    m_SttsAtom = AP4_DYNAMIC_CAST(AP4_SttsAtom, stbl->GetChild(AP4_ATOM_TYPE_STTS));\n    m_StssAtom = AP4_DYNAMIC_CAST(AP4_StssAtom, stbl->GetChild(AP4_ATOM_TYPE_STSS));\n    m_StsdAtom = AP4_DYNAMIC_CAST(AP4_StsdAtom, stbl->GetChild(AP4_ATOM_TYPE_STSD));\n    m_Co64Atom = AP4_DYNAMIC_CAST(AP4_Co64Atom, stbl->GetChild(AP4_ATOM_TYPE_CO64));\n\n    // keep a reference to the sample stream\n    m_SampleStream.AddReference();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::~AP4_AtomSampleTable\n+---------------------------------------------------------------------*/\nAP4_AtomSampleTable::~AP4_AtomSampleTable()\n{\n    m_SampleStream.Release();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSample\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_AtomSampleTable::GetSample(AP4_Ordinal index, \n                               AP4_Sample& sample)\n{\n    AP4_Result result;\n\n    // check that we have a chunk offset table\n    if (m_StcoAtom == NULL && m_Co64Atom == NULL) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\n    // MP4 uses 1-based indexes internally, so adjust by one\n    index++;\n\n    // find out in which chunk this sample is located\n    AP4_Ordinal chunk, skip, desc;\n    result = m_StscAtom->GetChunkForSample(index, chunk, skip, desc);\n    if (AP4_FAILED(result)) return result;\n    \n    // check that the result is within bounds\n    if (skip > index) return AP4_ERROR_INTERNAL;\n\n    // get the atom offset for this chunk\n    AP4_UI64 offset;\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        result = m_StcoAtom->GetChunkOffset(chunk, offset_32);\n        offset = offset_32;\n    } else {\n        result = m_Co64Atom->GetChunkOffset(chunk, offset);\n    }\n    if (AP4_FAILED(result)) return result;\n    \n    // compute the additional offset inside the chunk\n    for (unsigned int i = index-skip; i < index; i++) {\n        AP4_Size size = 0;\n        if (m_StszAtom) {\n            result = m_StszAtom->GetSampleSize(i, size); \n        } else if (m_Stz2Atom) {\n            result = m_Stz2Atom->GetSampleSize(i, size); \n        } else {\n            result = AP4_ERROR_INVALID_FORMAT;\n        }\n        if (AP4_FAILED(result)) return result;\n        offset += size;\n    }\n\n    // set the description index\n    sample.SetDescriptionIndex(desc-1); // adjust for 0-based indexes\n\n    // set the dts and cts\n    AP4_UI32 cts_offset = 0;\n    AP4_UI64 dts        = 0;\n    AP4_UI32 duration   = 0;\n    result = m_SttsAtom->GetDts(index, dts, &duration);\n    if (AP4_FAILED(result)) return result;\n    sample.SetDuration(duration);\n    sample.SetDts(dts);\n    if (m_CttsAtom == NULL) {\n        sample.SetCts(dts);\n    } else {\n        result = m_CttsAtom->GetCtsOffset(index, cts_offset); \n\t    if (AP4_FAILED(result)) return result;\n        sample.SetCtsDelta(cts_offset);\n    }     \n\n    // set the size\n    AP4_Size sample_size = 0;\n    if (m_StszAtom) {\n        result = m_StszAtom->GetSampleSize(index, sample_size); \n    } else if (m_Stz2Atom) {\n        result = m_Stz2Atom->GetSampleSize(index, sample_size); \n    } else {\n        result = AP4_ERROR_INVALID_FORMAT;\n    }\n    if (AP4_FAILED(result)) return result;\n    sample.SetSize(sample_size);\n\n    // set the sync flag\n    if (m_StssAtom == NULL) {\n        sample.SetSync(true);\n    } else {\n        sample.SetSync(m_StssAtom->IsSampleSync(index));\n    }\n\n    // set the offset\n    sample.SetOffset(offset);\n\n    // set the data stream\n    sample.SetDataStream(m_SampleStream);\n\n\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleCount\n+---------------------------------------------------------------------*/\nAP4_Cardinal\nAP4_AtomSampleTable::GetSampleCount()\n{\n    if (m_StszAtom) {\n        return m_StszAtom->GetSampleCount();\n    } else if (m_Stz2Atom) {\n        return m_Stz2Atom->GetSampleCount();\n    } else {\n        return 0;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleDescription\n+---------------------------------------------------------------------*/\nAP4_SampleDescription*\nAP4_AtomSampleTable::GetSampleDescription(AP4_Ordinal index)\n{\n    return m_StsdAtom ? m_StsdAtom->GetSampleDescription(index) : NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleDescriptionCount\n+---------------------------------------------------------------------*/\nAP4_Cardinal\nAP4_AtomSampleTable::GetSampleDescriptionCount()\n{\n    return m_StsdAtom ? m_StsdAtom->GetSampleDescriptionCount() : 0;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleChunkPosition\n+---------------------------------------------------------------------*/\nAP4_Result   \nAP4_AtomSampleTable::GetSampleChunkPosition(AP4_Ordinal  sample_index, \n                                            AP4_Ordinal& chunk_index,\n                                            AP4_Ordinal& position_in_chunk)\n{\n    // default values\n    chunk_index       = 0;\n    position_in_chunk = 0;\n    \n    AP4_Ordinal sample_description_index;\n    return GetChunkForSample(sample_index, \n                             chunk_index, \n                             position_in_chunk, \n                             sample_description_index);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetChunkForSample\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::GetChunkForSample(AP4_Ordinal  sample_index,\n                                       AP4_Ordinal& chunk_index,\n                                       AP4_Ordinal& position_in_chunk,\n                                       AP4_Ordinal& sample_description_index)\n{\n    // default values\n    chunk_index              = 0;\n    position_in_chunk        = 0;\n    sample_description_index = 0;\n\n    // check that we an stsc atom\n    if (m_StscAtom == NULL) return AP4_ERROR_INVALID_STATE;\n    \n    // get the chunk info from the stsc atom\n    AP4_Ordinal chunk = 0;\n    AP4_Result result = m_StscAtom->GetChunkForSample(sample_index+1, // the atom API is 1-based \n                                                      chunk, \n                                                      position_in_chunk, \n                                                      sample_description_index);\n    if (AP4_FAILED(result)) return result;\n    if (chunk == 0) return AP4_ERROR_INTERNAL;\n\n    // the atom sample and chunk indexes are 1-based, so we need to translate\n    chunk_index = chunk-1;\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetChunkOffset\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::GetChunkOffset(AP4_Ordinal   chunk_index, \n                                    AP4_Position& offset)\n{\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        AP4_Result result = m_StcoAtom->GetChunkOffset(chunk_index+1, offset_32);\n        if (AP4_SUCCEEDED(result)) {\n            offset = offset_32;\n        } else {\n            offset = 0;\n        }\n        return result;\n    } else if (m_Co64Atom) {\n        return m_Co64Atom->GetChunkOffset(chunk_index+1, offset);\n    } else {\n        offset = 0;\n        return AP4_FAILURE;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::SetChunkOffset\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::SetChunkOffset(AP4_Ordinal  chunk_index, \n                                    AP4_Position offset)\n{\n    if (m_StcoAtom) {\n        if ((offset >> 32) != 0) return AP4_ERROR_OUT_OF_RANGE;\n        return m_StcoAtom->SetChunkOffset(chunk_index+1, (AP4_UI32)offset);\n    } else if (m_Co64Atom) {\n        return m_Co64Atom->SetChunkOffset(chunk_index+1, offset);\n    } else {\n        return AP4_FAILURE;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::SetSampleSize\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::SetSampleSize(AP4_Ordinal sample_index, AP4_Size size)\n{\n    if (m_StszAtom) {\n        return m_StszAtom->SetSampleSize(sample_index+1, size);\n    } else if (m_Stz2Atom) {\n        return m_Stz2Atom->SetSampleSize(sample_index+1, size);\n    } else {    \n        return AP4_FAILURE;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleIndexForTimeStamp\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::GetSampleIndexForTimeStamp(AP4_UI64     ts, \n                                                AP4_Ordinal& sample_index)\n{\n    return m_SttsAtom ? m_SttsAtom->GetSampleIndexForTimeStamp(ts, sample_index) \n                      : AP4_FAILURE;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetNearestSyncSampleIndex\n+---------------------------------------------------------------------*/\nAP4_Ordinal  \nAP4_AtomSampleTable::GetNearestSyncSampleIndex(AP4_Ordinal sample_index, bool before)\n{\n    // if we don't have an stss table, all samples match\n    if (m_StssAtom == NULL) return sample_index;\n    \n    sample_index += 1; // the table is 1-based\n    AP4_Cardinal entry_count = m_StssAtom->GetEntries().ItemCount();\n    if (before) {\n        AP4_Ordinal cursor = 0;    \n        for (unsigned int i=0; i<entry_count; i++) {\n            if (m_StssAtom->GetEntries()[i] >= sample_index) return cursor;\n            if (m_StssAtom->GetEntries()[i]) cursor = m_StssAtom->GetEntries()[i]-1;\n        }\n\n        // not found?\n        return cursor;\n    } else {\n        for (unsigned int i=0; i<entry_count; i++) {\n            if (m_StssAtom->GetEntries()[i] >= sample_index) {\n                return m_StssAtom->GetEntries()[i]?m_StssAtom->GetEntries()[i]-1:sample_index-1;\n            }\n        }\n\n        // not found?\n        return GetSampleCount();\n    }\n}\n\n", "/*****************************************************************\n|\n|    AP4 - avcC Atoms \n|\n|    Copyright 2002-2008 Axiomatic Systems, LLC\n|\n|\n|    This file is part of Bento4/AP4 (MP4 Atom Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the file COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"Ap4AvccAtom.h\"\n#include \"Ap4AtomFactory.h\"\n#include \"Ap4Utils.h\"\n#include \"Ap4Types.h\"\n\n/*----------------------------------------------------------------------\n|   dynamic cast support\n+---------------------------------------------------------------------*/\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_AvccAtom)\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::GetProfileName\n+---------------------------------------------------------------------*/\nconst char*\nAP4_AvccAtom::GetProfileName(AP4_UI08 profile)\n{\n    switch (profile) {\n        case AP4_AVC_PROFILE_BASELINE: return \"Baseline\";   \n        case AP4_AVC_PROFILE_MAIN:     return \"Main\";\n        case AP4_AVC_PROFILE_EXTENDED: return \"Extended\";\n        case AP4_AVC_PROFILE_HIGH:     return \"High\";\n        case AP4_AVC_PROFILE_HIGH_10:  return \"High 10\";\n        case AP4_AVC_PROFILE_HIGH_422: return \"High 4:2:2\";\n        case AP4_AVC_PROFILE_HIGH_444: return \"High 4:4:4\";\n    }\n\n    return NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::Create\n+---------------------------------------------------------------------*/\nAP4_AvccAtom* \nAP4_AvccAtom::Create(AP4_Size size, AP4_ByteStream& stream)\n{\n    // read the raw bytes in a buffer\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    AP4_DataBuffer payload_data(payload_size);\n    AP4_Result result = stream.Read(payload_data.UseData(), payload_size);\n    if (AP4_FAILED(result)) return NULL;\n    \n    // check the version\n    const AP4_UI08* payload = payload_data.GetData();\n    if (payload[0] != 1) {\n        return NULL;\n    }\n\n    // check the size\n    if (payload_size < 6) return NULL;\n    unsigned int num_seq_params = payload[5]&31;\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        if (cursor+2 > payload_size) return NULL;\n        cursor += 2+AP4_BytesToInt16BE(&payload[cursor]);\n        if (cursor > payload_size) return NULL;\n    }\n    unsigned int num_pic_params = payload[cursor++];\n    if (cursor > payload_size) return NULL;\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        if (cursor+2 > payload_size) return NULL;\n        cursor += 2+AP4_BytesToInt16BE(&payload[cursor]);\n        if (cursor > payload_size) return NULL;\n    }\n    return new AP4_AvccAtom(size, payload);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom() :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, AP4_ATOM_HEADER_SIZE),\n    m_ConfigurationVersion(1),\n    m_Profile(0),\n    m_Level(0),\n    m_ProfileCompatibility(0),\n    m_NaluLengthSize(0)\n{\n    UpdateRawBytes();\n    m_Size32 += m_RawBytes.GetDataSize();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom(const AP4_AvccAtom& other) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, other.m_Size32),\n    m_ConfigurationVersion(other.m_ConfigurationVersion),\n    m_Profile(other.m_Profile),\n    m_Level(other.m_Level),\n    m_ProfileCompatibility(other.m_ProfileCompatibility),\n    m_NaluLengthSize(other.m_NaluLengthSize),\n    m_RawBytes(other.m_RawBytes)\n{\n    // deep copy of the parameters\n    unsigned int i = 0;\n    for (i=0; i<other.m_SequenceParameters.ItemCount(); i++) {\n        m_SequenceParameters.Append(other.m_SequenceParameters[i]);\n    }\n    for (i=0; i<other.m_PictureParameters.ItemCount(); i++) {\n        m_PictureParameters.Append(other.m_PictureParameters[i]);\n    }    \n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n    // make a copy of our configuration bytes\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n\n    // parse the payload\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        m_SequenceParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        m_PictureParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_PictureParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n}\n\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom(AP4_UI08                         profile, \n                           AP4_UI08                         level, \n                           AP4_UI08                         profile_compatibility, \n                           AP4_UI08                         length_size, \n                           const AP4_Array<AP4_DataBuffer>& sequence_parameters, \n                           const AP4_Array<AP4_DataBuffer>& picture_parameters) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, AP4_ATOM_HEADER_SIZE),\n    m_ConfigurationVersion(1),\n    m_Profile(profile),\n    m_Level(level),\n    m_ProfileCompatibility(profile_compatibility),\n    m_NaluLengthSize(length_size)\n{\n    // deep copy of the parameters\n    unsigned int i = 0;\n    for (i=0; i<sequence_parameters.ItemCount(); i++) {\n        m_SequenceParameters.Append(sequence_parameters[i]);\n    }\n    for (i=0; i<picture_parameters.ItemCount(); i++) {\n        m_PictureParameters.Append(picture_parameters[i]);\n    }    \n\n    // compute the raw bytes\n    UpdateRawBytes();\n\n    // update the size\n    m_Size32 += m_RawBytes.GetDataSize();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::UpdateRawBytes\n+---------------------------------------------------------------------*/\nvoid\nAP4_AvccAtom::UpdateRawBytes()\n{\n    // compute the payload size\n    unsigned int payload_size = 6;    \n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        payload_size += 2+m_SequenceParameters[i].GetDataSize();\n    }\n    ++payload_size;\n    for (unsigned int i=0; i<m_PictureParameters.ItemCount(); i++) {\n        payload_size += 2+m_PictureParameters[i].GetDataSize();\n    }\n    m_RawBytes.SetDataSize(payload_size);\n    AP4_UI08* payload = m_RawBytes.UseData();\n\n    payload[0] = m_ConfigurationVersion;\n    payload[1] = m_Profile;\n    payload[2] = m_ProfileCompatibility;\n    payload[3] = m_Level;\n    payload[4] = 0xFC | (m_NaluLengthSize-1);\n    payload[5] = 0xE0 | (AP4_UI08)m_SequenceParameters.ItemCount();\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        AP4_UI16 param_length = (AP4_UI16)m_SequenceParameters[i].GetDataSize();\n        AP4_BytesFromUInt16BE(&payload[cursor], param_length);\n        cursor += 2;\n        AP4_CopyMemory(&payload[cursor], m_SequenceParameters[i].GetData(), param_length);\n        cursor += param_length;\n    }\n    payload[cursor++] = (AP4_UI08)m_PictureParameters.ItemCount();\n    for (unsigned int i=0; i<m_PictureParameters.ItemCount(); i++) {\n        AP4_UI16 param_length = (AP4_UI16)m_PictureParameters[i].GetDataSize();\n        AP4_BytesFromUInt16BE(&payload[cursor], param_length);\n        cursor += 2;\n        AP4_CopyMemory(&payload[cursor], m_PictureParameters[i].GetData(), param_length);\n        cursor += param_length;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_AvccAtom::WriteFields(AP4_ByteStream& stream)\n{\n    return stream.Write(m_RawBytes.GetData(), m_RawBytes.GetDataSize());\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_AvccAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"Configuration Version\", m_ConfigurationVersion);\n    const char* profile_name = GetProfileName(m_Profile);\n    if (profile_name) {\n        inspector.AddField(\"Profile\", profile_name);\n    } else {\n        inspector.AddField(\"Profile\", m_Profile);\n    }\n    inspector.AddField(\"Profile Compatibility\", m_ProfileCompatibility, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Level\", m_Level);\n    inspector.AddField(\"NALU Length Size\", m_NaluLengthSize);\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n    }\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n    }\n    return AP4_SUCCESS;\n}\n", "/*****************************************************************\n|\n|    AP4 - File Processor\n|\n|    Copyright 2002-2008 Axiomatic Systems, LLC\n|\n|\n|    This file is part of Bento4/AP4 (MP4 Atom Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the file COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"Ap4Processor.h\"\n#include \"Ap4AtomSampleTable.h\"\n#include \"Ap4MovieFragment.h\"\n#include \"Ap4FragmentSampleTable.h\"\n#include \"Ap4TfhdAtom.h\"\n#include \"Ap4AtomFactory.h\"\n#include \"Ap4Movie.h\"\n#include \"Ap4Array.h\"\n#include \"Ap4Sample.h\"\n#include \"Ap4TrakAtom.h\"\n#include \"Ap4TfraAtom.h\"\n#include \"Ap4TrunAtom.h\"\n#include \"Ap4TrexAtom.h\"\n#include \"Ap4TkhdAtom.h\"\n#include \"Ap4SidxAtom.h\"\n#include \"Ap4DataBuffer.h\"\n#include \"Ap4Debug.h\"\n\n/*----------------------------------------------------------------------\n|   types\n+---------------------------------------------------------------------*/\nstruct AP4_SampleLocator {\n    AP4_SampleLocator() : \n        m_TrakIndex(0), \n        m_SampleTable(NULL), \n        m_SampleIndex(0), \n        m_ChunkIndex(0) {}\n    AP4_Ordinal          m_TrakIndex;\n    AP4_AtomSampleTable* m_SampleTable;\n    AP4_Ordinal          m_SampleIndex;\n    AP4_Ordinal          m_ChunkIndex;\n    AP4_Sample           m_Sample;\n};\n\nstruct AP4_SampleCursor {\n    AP4_SampleCursor() : m_EndReached(false) {}\n    AP4_SampleLocator m_Locator;\n    bool              m_EndReached;\n};\n\nstruct AP4_AtomLocator {\n    AP4_AtomLocator(AP4_Atom* atom, AP4_UI64 offset) : \n        m_Atom(atom),\n        m_Offset(offset) {}\n    AP4_Atom* m_Atom;\n    AP4_UI64  m_Offset;\n};\n\n/*----------------------------------------------------------------------\n|   AP4_DefaultFragmentHandler\n+---------------------------------------------------------------------*/\nclass AP4_DefaultFragmentHandler: public AP4_Processor::FragmentHandler {\npublic:\n    AP4_DefaultFragmentHandler(AP4_Processor::TrackHandler* track_handler) :\n        m_TrackHandler(track_handler) {}\n    AP4_Result ProcessSample(AP4_DataBuffer& data_in,\n                             AP4_DataBuffer& data_out);\n                             \nprivate:\n    AP4_Processor::TrackHandler* m_TrackHandler;\n};\n\n/*----------------------------------------------------------------------\n|   AP4_DefaultFragmentHandler::ProcessSample\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_DefaultFragmentHandler::ProcessSample(AP4_DataBuffer& data_in, AP4_DataBuffer& data_out)\n{\n    if (m_TrackHandler == NULL) {\n        data_out.SetData(data_in.GetData(), data_in.GetDataSize());\n        return AP4_SUCCESS;\n    }\n    return m_TrackHandler->ProcessSample(data_in, data_out);\n}\n\n/*----------------------------------------------------------------------\n|   FragmentMapEntry\n+---------------------------------------------------------------------*/\ntypedef struct {\n    AP4_UI64 before;\n    AP4_UI64 after;\n} FragmentMapEntry;\n\n/*----------------------------------------------------------------------\n|   FindFragmentMapEntry\n+---------------------------------------------------------------------*/\nstatic const FragmentMapEntry*\nFindFragmentMapEntry(AP4_Array<FragmentMapEntry>& fragment_map, AP4_UI64 fragment_offset) {\n    int first = 0;\n    int last = fragment_map.ItemCount();\n    while (first < last) {\n        int middle = (last+first)/2;\n        AP4_UI64 middle_value = fragment_map[middle].before;\n        if (fragment_offset < middle_value) {\n            last = middle;\n        } else if (fragment_offset > middle_value) {\n            first = middle+1;\n        } else {\n            return &fragment_map[middle];\n        }\n    }\n    \n    return NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor::ProcessFragments\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_Processor::ProcessFragments(AP4_MoovAtom*              moov, \n                                AP4_List<AP4_AtomLocator>& atoms, \n                                AP4_ContainerAtom*         mfra,\n                                AP4_SidxAtom*              sidx,\n                                AP4_Position               sidx_position,\n                                AP4_ByteStream&            input, \n                                AP4_ByteStream&            output)\n{\n    unsigned int fragment_index = 0;\n    AP4_Array<FragmentMapEntry> fragment_map;\n    \n    for (AP4_List<AP4_AtomLocator>::Item* item = atoms.FirstItem();\n                                          item;\n                                          item = item->GetNext(), ++fragment_index) {\n        AP4_AtomLocator*   locator     = item->GetData();\n        AP4_Atom*          atom        = locator->m_Atom;\n        AP4_UI64           atom_offset = locator->m_Offset;\n        AP4_UI64           mdat_payload_offset = atom_offset+atom->GetSize()+AP4_ATOM_HEADER_SIZE;\n        AP4_Sample         sample;\n        AP4_DataBuffer     sample_data_in;\n        AP4_DataBuffer     sample_data_out;\n        AP4_Result         result;\n    \n        // if this is not a moof atom, just write it back and continue\n        if (atom->GetType() != AP4_ATOM_TYPE_MOOF) {\n            result = atom->Write(output);\n            if (AP4_FAILED(result)) return result;\n            continue;\n        }\n        \n        // parse the moof\n        AP4_ContainerAtom* moof = AP4_DYNAMIC_CAST(AP4_ContainerAtom, atom);\n        AP4_MovieFragment* fragment = new AP4_MovieFragment(moof);\n\n        // process all the traf atoms\n        AP4_Array<AP4_Processor::FragmentHandler*> handlers;\n        AP4_Array<AP4_FragmentSampleTable*> sample_tables;\n        for (;AP4_Atom* child = moof->GetChild(AP4_ATOM_TYPE_TRAF, handlers.ItemCount());) {\n            AP4_ContainerAtom* traf = AP4_DYNAMIC_CAST(AP4_ContainerAtom, child);\n            AP4_TfhdAtom* tfhd = AP4_DYNAMIC_CAST(AP4_TfhdAtom, traf->GetChild(AP4_ATOM_TYPE_TFHD));\n            \n            // find the 'trak' for this track\n            AP4_TrakAtom* trak = NULL;\n            for (AP4_List<AP4_Atom>::Item* child_item = moov->GetChildren().FirstItem();\n                                           child_item;\n                                           child_item = child_item->GetNext()) {\n                AP4_Atom* child_atom = child_item->GetData();\n                if (child_atom->GetType() == AP4_ATOM_TYPE_TRAK) {\n                    trak = AP4_DYNAMIC_CAST(AP4_TrakAtom, child_atom);\n                    if (trak) {\n                        AP4_TkhdAtom* tkhd = AP4_DYNAMIC_CAST(AP4_TkhdAtom, trak->GetChild(AP4_ATOM_TYPE_TKHD));\n                        if (tkhd && tkhd->GetTrackId() == tfhd->GetTrackId()) {\n                            break;\n                        }\n                    }\n                    trak = NULL;\n                }\n            }\n            \n            // find the 'trex' for this track\n            AP4_ContainerAtom* mvex = NULL;\n            AP4_TrexAtom*      trex = NULL;\n            mvex = AP4_DYNAMIC_CAST(AP4_ContainerAtom, moov->GetChild(AP4_ATOM_TYPE_MVEX));\n            if (mvex) {\n                for (AP4_List<AP4_Atom>::Item* child_item = mvex->GetChildren().FirstItem();\n                                               child_item;\n                                               child_item = child_item->GetNext()) {\n                    AP4_Atom* child_atom = child_item->GetData();\n                    if (child_atom->GetType() == AP4_ATOM_TYPE_TREX) {\n                        trex = AP4_DYNAMIC_CAST(AP4_TrexAtom, child_atom);\n                        if (trex && trex->GetTrackId() == tfhd->GetTrackId()) {\n                            break;\n                        }\n                        trex = NULL;\n                    }\n                }\n            }\n\n            // create the handler for this traf\n            AP4_Processor::FragmentHandler* handler = CreateFragmentHandler(trak, trex, traf, input, atom_offset);\n            if (handler) {\n                result = handler->ProcessFragment();\n                if (AP4_FAILED(result)) return result;\n            }\n            handlers.Append(handler);\n            \n            // create a sample table object so we can read the sample data\n            AP4_FragmentSampleTable* sample_table = NULL;\n            result = fragment->CreateSampleTable(moov, tfhd->GetTrackId(), &input, atom_offset, mdat_payload_offset, 0, sample_table);\n            if (AP4_FAILED(result)) return result;\n            sample_tables.Append(sample_table);\n            \n            // let the handler look at the samples before we process them\n            if (handler) result = handler->PrepareForSamples(sample_table);\n            if (AP4_FAILED(result)) return result;\n        }\n             \n        // write the moof\n        AP4_UI64 moof_out_start = 0;\n        output.Tell(moof_out_start);\n        moof->Write(output);\n        \n        // remember the location of this fragment\n        FragmentMapEntry map_entry = {atom_offset, moof_out_start};\n        fragment_map.Append(map_entry);\n\n        // write an mdat header\n        AP4_Position mdat_out_start;\n        AP4_UI64 mdat_size = AP4_ATOM_HEADER_SIZE;\n        output.Tell(mdat_out_start);\n        output.WriteUI32(0);\n        output.WriteUI32(AP4_ATOM_TYPE_MDAT);\n\n        // process all track runs\n        for (unsigned int i=0; i<handlers.ItemCount(); i++) {\n            AP4_Processor::FragmentHandler* handler = handlers[i];\n\n            // get the track ID\n            AP4_ContainerAtom* traf = AP4_DYNAMIC_CAST(AP4_ContainerAtom, moof->GetChild(AP4_ATOM_TYPE_TRAF, i));\n            if (traf == NULL) continue;\n            AP4_TfhdAtom* tfhd = AP4_DYNAMIC_CAST(AP4_TfhdAtom, traf->GetChild(AP4_ATOM_TYPE_TFHD));\n            \n            // compute the base data offset\n            AP4_UI64 base_data_offset;\n            if (tfhd->GetFlags() & AP4_TFHD_FLAG_BASE_DATA_OFFSET_PRESENT) {\n                base_data_offset = mdat_out_start+AP4_ATOM_HEADER_SIZE;\n            } else {\n                base_data_offset = moof_out_start;\n            }\n            \n            // build a list of all trun atoms\n            AP4_Array<AP4_TrunAtom*> truns;\n            for (AP4_List<AP4_Atom>::Item* child_item = traf->GetChildren().FirstItem();\n                                           child_item;\n                                           child_item = child_item->GetNext()) {\n                AP4_Atom* child_atom = child_item->GetData();\n                if (child_atom->GetType() == AP4_ATOM_TYPE_TRUN) {\n                    AP4_TrunAtom* trun = AP4_DYNAMIC_CAST(AP4_TrunAtom, child_atom);\n                    truns.Append(trun);\n                }\n            }    \n            AP4_Ordinal   trun_index        = 0;\n            AP4_Ordinal   trun_sample_index = 0;\n            AP4_TrunAtom* trun = truns[0];\n            trun->SetDataOffset((AP4_SI32)((mdat_out_start+mdat_size)-base_data_offset));\n            \n            // write the mdat\n            for (unsigned int j=0; j<sample_tables[i]->GetSampleCount(); j++, trun_sample_index++) {\n                // advance the trun index if necessary\n                if (trun_sample_index >= trun->GetEntries().ItemCount()) {\n                    trun = truns[++trun_index];\n                    trun->SetDataOffset((AP4_SI32)((mdat_out_start+mdat_size)-base_data_offset));\n                    trun_sample_index = 0;\n                }\n                \n                // get the next sample\n                result = sample_tables[i]->GetSample(j, sample);\n                if (AP4_FAILED(result)) return result;\n                sample.ReadData(sample_data_in);\n                \n                // process the sample data\n                if (handler) {\n                    result = handler->ProcessSample(sample_data_in, sample_data_out);\n                    if (AP4_FAILED(result)) return result;\n\n                    // write the sample data\n                    result = output.Write(sample_data_out.GetData(), sample_data_out.GetDataSize());\n                    if (AP4_FAILED(result)) return result;\n\n                    // update the mdat size\n                    mdat_size += sample_data_out.GetDataSize();\n                    \n                    // update the trun entry\n                    trun->UseEntries()[trun_sample_index].sample_size = sample_data_out.GetDataSize();\n                } else {\n                    // write the sample data (unmodified)\n                    result = output.Write(sample_data_in.GetData(), sample_data_in.GetDataSize());\n                    if (AP4_FAILED(result)) return result;\n\n                    // update the mdat size\n                    mdat_size += sample_data_in.GetDataSize();\n                }\n            }\n\n            if (handler) {\n                // update the tfhd header\n                if (tfhd->GetFlags() & AP4_TFHD_FLAG_BASE_DATA_OFFSET_PRESENT) {\n                    tfhd->SetBaseDataOffset(mdat_out_start+AP4_ATOM_HEADER_SIZE);\n                }\n                if (tfhd->GetFlags() & AP4_TFHD_FLAG_DEFAULT_SAMPLE_SIZE_PRESENT) {\n                    tfhd->SetDefaultSampleSize(trun->GetEntries()[0].sample_size);\n                }\n                \n                // give the handler a chance to update the atoms\n                handler->FinishFragment();\n            }\n        }\n\n        // update the mdat header\n        AP4_Position mdat_out_end;\n        output.Tell(mdat_out_end);\n#if defined(AP4_DEBUG)\n        AP4_ASSERT(mdat_out_end-mdat_out_start == mdat_size);\n#endif\n        output.Seek(mdat_out_start);\n        output.WriteUI32((AP4_UI32)mdat_size);\n        output.Seek(mdat_out_end);\n        \n        // update the moof if needed\n        output.Seek(moof_out_start);\n        moof->Write(output);\n        output.Seek(mdat_out_end);\n        \n        // update the sidx if we have one\n        if (sidx && fragment_index < sidx->GetReferences().ItemCount()) {\n            if (fragment_index == 0) {\n                sidx->SetFirstOffset(moof_out_start-(sidx_position+sidx->GetSize()));\n            }\n            AP4_LargeSize fragment_size = mdat_out_end-moof_out_start;\n            AP4_SidxAtom::Reference& sidx_ref = sidx->UseReferences()[fragment_index];\n            sidx_ref.m_ReferencedSize = (AP4_UI32)fragment_size;\n        }\n        \n        // cleanup\n        delete fragment;\n        \n        for (unsigned int i=0; i<handlers.ItemCount(); i++) {\n            delete handlers[i];\n        }\n        for (unsigned int i=0; i<sample_tables.ItemCount(); i++) {\n            delete sample_tables[i];\n        }\n    }\n    \n    // update the mfra if we have one\n    if (mfra) {\n        for (AP4_List<AP4_Atom>::Item* mfra_item = mfra->GetChildren().FirstItem();\n                                       mfra_item;\n                                       mfra_item = mfra_item->GetNext()) {\n            if (mfra_item->GetData()->GetType() != AP4_ATOM_TYPE_TFRA) continue;\n            AP4_TfraAtom* tfra = AP4_DYNAMIC_CAST(AP4_TfraAtom, mfra_item->GetData());\n            if (tfra == NULL) continue;\n            AP4_Array<AP4_TfraAtom::Entry>& entries     = tfra->GetEntries();\n            AP4_Cardinal                    entry_count = entries.ItemCount();\n            for (unsigned int i=0; i<entry_count; i++) {\n                const FragmentMapEntry* found = FindFragmentMapEntry(fragment_map, entries[i].m_MoofOffset);\n                if (found) {\n                    entries[i].m_MoofOffset = found->after;\n                }\n            }\n        }\n    }\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor::CreateFragmentHandler\n+---------------------------------------------------------------------*/\nAP4_Processor::FragmentHandler* \nAP4_Processor::CreateFragmentHandler(AP4_TrakAtom*      /* trak */,\n                                     AP4_TrexAtom*      /* trex */,\n                                     AP4_ContainerAtom* traf,\n                                     AP4_ByteStream&    /* moof_data   */,\n                                     AP4_Position       /* moof_offset */)\n{\n    // find the matching track handler\n    for (unsigned int i=0; i<m_TrackIds.ItemCount(); i++) {\n        AP4_TfhdAtom* tfhd = AP4_DYNAMIC_CAST(AP4_TfhdAtom, traf->GetChild(AP4_ATOM_TYPE_TFHD));\n        if (tfhd && m_TrackIds[i] == tfhd->GetTrackId()) {\n            return new AP4_DefaultFragmentHandler(m_TrackHandlers[i]);\n        }\n    }\n    \n    return NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor::Process\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_Processor::Process(AP4_ByteStream&   input, \n                       AP4_ByteStream&   output,\n                       AP4_ByteStream*   fragments,\n                       ProgressListener* listener,\n                       AP4_AtomFactory&  atom_factory)\n{\n    // read all atoms.\n    // keep all atoms except [mdat]\n    // keep a ref to [moov]\n    // put [moof] atoms in a separate list\n    AP4_AtomParent              top_level;\n    AP4_MoovAtom*               moov = NULL;\n    AP4_ContainerAtom*          mfra = NULL;\n    AP4_SidxAtom*               sidx = NULL;\n    AP4_List<AP4_AtomLocator>   frags;\n    AP4_UI64                    stream_offset = 0;\n    bool                        in_fragments = false;\n    unsigned int                sidx_count = 0;\n    for (AP4_Atom* atom = NULL;\n        AP4_SUCCEEDED(atom_factory.CreateAtomFromStream(input, atom));\n        input.Tell(stream_offset)) {\n        if (atom->GetType() == AP4_ATOM_TYPE_MDAT) {\n            delete atom;\n            continue;\n        } else if (atom->GetType() == AP4_ATOM_TYPE_MOOV) {\n            moov = AP4_DYNAMIC_CAST(AP4_MoovAtom, atom);\n            if (fragments) break;\n        } else if (atom->GetType() == AP4_ATOM_TYPE_MFRA) {\n            mfra = AP4_DYNAMIC_CAST(AP4_ContainerAtom, atom);\n            continue;\n        } else if (atom->GetType() == AP4_ATOM_TYPE_SIDX) {\n            // don't keep the index, it is likely to be invalidated, we will recompute it later\n            ++sidx_count;\n            if (sidx == NULL) {\n                sidx = AP4_DYNAMIC_CAST(AP4_SidxAtom, atom);\n            } else {\n                delete atom;\n                continue;\n            }\n        } else if (atom->GetType() == AP4_ATOM_TYPE_SSIX) {\n            // don't keep the index, it is likely to be invalidated\n            delete atom;\n            continue;\n        } else if (!fragments && (in_fragments || atom->GetType() == AP4_ATOM_TYPE_MOOF)) {\n            in_fragments = true;\n            frags.Add(new AP4_AtomLocator(atom, stream_offset));\n            continue;\n        }\n        top_level.AddChild(atom);\n    }\n\n    // check that we have at most one sidx (we can't deal with multi-sidx streams here\n    if (sidx_count > 1) {\n        top_level.RemoveChild(sidx);\n        delete sidx;\n        sidx = NULL;\n    }\n    \n    // if we have a fragments stream, get the fragment locators from there\n    if (fragments) {\n        stream_offset = 0;\n        for (AP4_Atom* atom = NULL;\n            AP4_SUCCEEDED(atom_factory.CreateAtomFromStream(*fragments, atom));\n            fragments->Tell(stream_offset)) {\n            if (atom->GetType() == AP4_ATOM_TYPE_MDAT) {\n                delete atom;\n                continue;\n            }\n            frags.Add(new AP4_AtomLocator(atom, stream_offset));\n        }\n    }\n    \n    // initialize the processor\n    AP4_Result result = Initialize(top_level, input);\n    if (AP4_FAILED(result)) return result;\n\n    // process the tracks if we have a moov atom\n    AP4_Array<AP4_SampleLocator> locators;\n    AP4_Cardinal                 track_count       = 0;\n    AP4_List<AP4_TrakAtom>*      trak_atoms        = NULL;\n    AP4_LargeSize                mdat_payload_size = 0;\n    AP4_SampleCursor*            cursors           = NULL;\n    if (moov) {\n        // build an array of track sample locators\n        trak_atoms = &moov->GetTrakAtoms();\n        track_count = trak_atoms->ItemCount();\n        cursors = new AP4_SampleCursor[track_count];\n        m_TrackHandlers.SetItemCount(track_count);\n        m_TrackIds.SetItemCount(track_count);\n        for (AP4_Ordinal i=0; i<track_count; i++) {\n            m_TrackHandlers[i] = NULL;\n            m_TrackIds[i] = 0;\n        }\n        \n        unsigned int index = 0;\n        for (AP4_List<AP4_TrakAtom>::Item* item = trak_atoms->FirstItem(); item; item=item->GetNext()) {\n            AP4_TrakAtom* trak = item->GetData();\n\n            // find the stsd atom\n            AP4_ContainerAtom* stbl = AP4_DYNAMIC_CAST(AP4_ContainerAtom, trak->FindChild(\"mdia/minf/stbl\"));\n            if (stbl == NULL) continue;\n            \n            // see if there's an external data source for this track\n            AP4_ByteStream* trak_data_stream = &input;\n            for (AP4_List<ExternalTrackData>::Item* ditem = m_ExternalTrackData.FirstItem(); ditem; ditem=ditem->GetNext()) {\n                ExternalTrackData* tdata = ditem->GetData();\n                if (tdata->m_TrackId == trak->GetId()) {\n                    trak_data_stream = tdata->m_MediaData;\n                    break;\n                }\n            }\n\n            // create the track handler    \n            m_TrackHandlers[index] = CreateTrackHandler(trak);\n            m_TrackIds[index]      = trak->GetId();\n            cursors[index].m_Locator.m_TrakIndex   = index;\n            cursors[index].m_Locator.m_SampleTable = new AP4_AtomSampleTable(stbl, *trak_data_stream);\n            cursors[index].m_Locator.m_SampleIndex = 0;\n            cursors[index].m_Locator.m_ChunkIndex  = 0;\n            if (cursors[index].m_Locator.m_SampleTable->GetSampleCount()) {\n                cursors[index].m_Locator.m_SampleTable->GetSample(0, cursors[index].m_Locator.m_Sample);\n            } else {\n                cursors[index].m_EndReached = true;\n            }\n\n            index++;            \n        }\n\n        // figure out the layout of the chunks\n        for (;;) {\n            // see which is the next sample to write\n            AP4_UI64 min_offset = (AP4_UI64)(-1);\n            int cursor = -1;\n            for (unsigned int i=0; i<track_count; i++) {\n                if (!cursors[i].m_EndReached &&\n                    cursors[i].m_Locator.m_Sample.GetOffset() <= min_offset) {\n                    min_offset = cursors[i].m_Locator.m_Sample.GetOffset();\n                    cursor = i;\n                }\n            }\n\n            // stop if all cursors are exhausted\n            if (cursor == -1) break;\n\n            // append this locator to the layout list\n            AP4_SampleLocator& locator = cursors[cursor].m_Locator;\n            locators.Append(locator);\n\n            // move the cursor to the next sample\n            locator.m_SampleIndex++;\n            if (locator.m_SampleIndex == locator.m_SampleTable->GetSampleCount()) {\n                // mark this track as completed\n                cursors[cursor].m_EndReached = true;\n            } else {\n                // get the next sample info\n                locator.m_SampleTable->GetSample(locator.m_SampleIndex, locator.m_Sample);\n                AP4_Ordinal skip, sdesc;\n                locator.m_SampleTable->GetChunkForSample(locator.m_SampleIndex,\n                                                         locator.m_ChunkIndex,\n                                                         skip, sdesc);\n            }\n        }\n\n        // update the stbl atoms and compute the mdat size\n        int current_track = -1;\n        int current_chunk = -1;\n        AP4_Position current_chunk_offset = 0;\n        AP4_Size current_chunk_size = 0;\n        for (AP4_Ordinal i=0; i<locators.ItemCount(); i++) {\n            AP4_SampleLocator& locator = locators[i];\n            if ((int)locator.m_TrakIndex  != current_track ||\n                (int)locator.m_ChunkIndex != current_chunk) {\n                // start a new chunk for this track\n                current_chunk_offset += current_chunk_size;\n                current_chunk_size = 0;\n                current_track = locator.m_TrakIndex;\n                current_chunk = locator.m_ChunkIndex;\n                locator.m_SampleTable->SetChunkOffset(locator.m_ChunkIndex, current_chunk_offset);\n            } \n            AP4_Size sample_size;\n            TrackHandler* handler = m_TrackHandlers[locator.m_TrakIndex];\n            if (handler) {\n                sample_size = handler->GetProcessedSampleSize(locator.m_Sample);\n                locator.m_SampleTable->SetSampleSize(locator.m_SampleIndex, sample_size);\n            } else {\n                sample_size = locator.m_Sample.GetSize();\n            }\n            current_chunk_size += sample_size;\n            mdat_payload_size  += sample_size;\n        }\n\n        // process the tracks (ex: sample descriptions processing)\n        for (AP4_Ordinal i=0; i<track_count; i++) {\n            TrackHandler* handler = m_TrackHandlers[i];\n            if (handler) handler->ProcessTrack();\n        }\n    }\n\n    // finalize the processor\n    Finalize(top_level);\n\n    if (!fragments) {\n        // calculate the size of all atoms combined\n        AP4_UI64 atoms_size = 0;\n        top_level.GetChildren().Apply(AP4_AtomSizeAdder(atoms_size));\n\n        // see if we need a 64-bit or 32-bit mdat\n        AP4_Size mdat_header_size = AP4_ATOM_HEADER_SIZE;\n        if (mdat_payload_size+mdat_header_size > 0xFFFFFFFF) {\n            // we need a 64-bit size\n            mdat_header_size += 8;\n        }\n        \n        // adjust the chunk offsets\n        for (AP4_Ordinal i=0; i<track_count; i++) {\n            AP4_TrakAtom* trak;\n            trak_atoms->Get(i, trak);\n            trak->AdjustChunkOffsets(atoms_size+mdat_header_size);\n        }\n\n        // write all atoms\n        top_level.GetChildren().Apply(AP4_AtomListWriter(output));\n\n        // write mdat header\n        if (mdat_payload_size) {\n            if (mdat_header_size == AP4_ATOM_HEADER_SIZE) {\n                // 32-bit size\n                output.WriteUI32((AP4_UI32)(mdat_header_size+mdat_payload_size));\n                output.WriteUI32(AP4_ATOM_TYPE_MDAT);\n            } else {\n                // 64-bit size\n                output.WriteUI32(1);\n                output.WriteUI32(AP4_ATOM_TYPE_MDAT);\n                output.WriteUI64(mdat_header_size+mdat_payload_size);\n            }\n        }        \n    }\n    \n    // write the samples\n    if (moov) {\n        if (!fragments) {\n#if defined(AP4_DEBUG)\n            AP4_Position before;\n            output.Tell(before);\n#endif\n            AP4_Sample     sample;\n            AP4_DataBuffer data_in;\n            AP4_DataBuffer data_out;\n            for (unsigned int i=0; i<locators.ItemCount(); i++) {\n                AP4_SampleLocator& locator = locators[i];\n                locator.m_Sample.ReadData(data_in);\n                TrackHandler* handler = m_TrackHandlers[locator.m_TrakIndex];\n                if (handler) {\n                    result = handler->ProcessSample(data_in, data_out);\n                    if (AP4_FAILED(result)) return result;\n                    output.Write(data_out.GetData(), data_out.GetDataSize());\n                } else {\n                    output.Write(data_in.GetData(), data_in.GetDataSize());            \n                }\n\n                // notify the progress listener\n                if (listener) {\n                    listener->OnProgress(i+1, locators.ItemCount());\n                }\n            }\n\n#if defined(AP4_DEBUG)\n            AP4_Position after;\n            output.Tell(after);\n            AP4_ASSERT(after-before == mdat_payload_size);\n#endif\n        }\n        \n        // find the position of the sidx atom\n        AP4_Position sidx_position = 0;\n        if (sidx) {\n            for (AP4_List<AP4_Atom>::Item* item = top_level.GetChildren().FirstItem();\n                                           item;\n                                           item = item->GetNext()) {\n                AP4_Atom* atom = item->GetData();\n                if (atom->GetType() == AP4_ATOM_TYPE_SIDX) {\n                    break;\n                }\n                sidx_position += atom->GetSize();\n            }\n        }\n        \n        // process the fragments, if any\n        result = ProcessFragments(moov, frags, mfra, sidx, sidx_position, fragments?*fragments:input, output);\n        if (AP4_FAILED(result)) return result;\n        \n        // update and re-write the sidx if we have one\n        if (sidx && sidx_position) {\n            AP4_Position where = 0;\n            output.Tell(where);\n            output.Seek(sidx_position);\n            result = sidx->Write(output);\n            if (AP4_FAILED(result)) return result;\n            output.Seek(where);\n        }\n        \n        if (!fragments) {\n            // write the mfra atom at the end if we have one\n            if (mfra) {\n                mfra->Write(output);\n            }\n        }\n        \n        // cleanup\n        for (AP4_Ordinal i=0; i<track_count; i++) {\n            delete cursors[i].m_Locator.m_SampleTable;\n            delete m_TrackHandlers[i];\n        }\n        m_TrackHandlers.Clear();\n        delete[] cursors;\n    }\n\n    // cleanup\n    frags.DeleteReferences();\n    delete mfra;\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor::Process\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_Processor::Process(AP4_ByteStream&   input, \n                       AP4_ByteStream&   output,\n                       ProgressListener* listener,\n                       AP4_AtomFactory&  atom_factory)\n{\n    return Process(input, output, NULL, listener, atom_factory);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor::Process\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_Processor::Process(AP4_ByteStream&   fragments, \n                       AP4_ByteStream&   output,\n                       AP4_ByteStream&   init,\n                       ProgressListener* listener,\n                       AP4_AtomFactory&  atom_factory)\n{\n    return Process(init, output, &fragments, listener, atom_factory);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor:Initialize\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_Processor::Initialize(AP4_AtomParent&   /* top_level */,\n                          AP4_ByteStream&   /* stream    */,\n                          ProgressListener* /* listener  */)\n{\n    // default implementation: do nothing\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor:Finalize\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_Processor::Finalize(AP4_AtomParent&   /* top_level */,\n                        ProgressListener* /* listener */ )\n{\n    // default implementation: do nothing\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor::TrackHandler Dynamic Cast Anchor\n+---------------------------------------------------------------------*/\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR_S(AP4_Processor::TrackHandler, TrackHandler)\n", "/*****************************************************************\n|\n|    AP4 - Version Numbers\n|\n|    Copyright 2002-2008 Axiomatic Systems, LLC\n|\n|\n|    This file is part of Bento4/AP4 (MP4 Atom Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the file COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n****************************************************************/\n\n#ifndef _AP4_VERSION_H_\n#define _AP4_VERSION_H_\n\n/*----------------------------------------------------------------------\n|   version constants\n+---------------------------------------------------------------------*/\n/**\n * Version number of the SDK\n */\n#define AP4_VERSION        0x01050000\n#define AP4_VERSION_STRING \"1.5.0.0\"\n\n#endif // _AP4_VERSION_H_\n"], "fixing_code": ["/*****************************************************************\n|\n|    AP4 - Atom Based Sample Tables\n|\n|    Copyright 2002-2008 Axiomatic Systems, LLC\n|\n|\n|    This atom is part of AP4 (MP4 Audio Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the atom COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n ****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"Ap4AtomSampleTable.h\"\n#include \"Ap4ByteStream.h\"\n#include \"Ap4StsdAtom.h\"\n#include \"Ap4StscAtom.h\"\n#include \"Ap4StcoAtom.h\"\n#include \"Ap4Co64Atom.h\"\n#include \"Ap4StszAtom.h\"\n#include \"Ap4Stz2Atom.h\"\n#include \"Ap4SttsAtom.h\"\n#include \"Ap4CttsAtom.h\"\n#include \"Ap4StssAtom.h\"\n#include \"Ap4Sample.h\"\n#include \"Ap4Atom.h\"\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable Dynamic Cast Anchor\n+---------------------------------------------------------------------*/\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_AtomSampleTable)\n\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::AP4_AtomSampleTable\n+---------------------------------------------------------------------*/\nAP4_AtomSampleTable::AP4_AtomSampleTable(AP4_ContainerAtom* stbl, \n                                         AP4_ByteStream&    sample_stream) :\n    m_SampleStream(sample_stream)\n{\n    m_StscAtom = AP4_DYNAMIC_CAST(AP4_StscAtom, stbl->GetChild(AP4_ATOM_TYPE_STSC));\n    m_StcoAtom = AP4_DYNAMIC_CAST(AP4_StcoAtom, stbl->GetChild(AP4_ATOM_TYPE_STCO));\n    m_StszAtom = AP4_DYNAMIC_CAST(AP4_StszAtom, stbl->GetChild(AP4_ATOM_TYPE_STSZ));\n    m_Stz2Atom = AP4_DYNAMIC_CAST(AP4_Stz2Atom, stbl->GetChild(AP4_ATOM_TYPE_STZ2));\n    m_CttsAtom = AP4_DYNAMIC_CAST(AP4_CttsAtom, stbl->GetChild(AP4_ATOM_TYPE_CTTS));\n    m_SttsAtom = AP4_DYNAMIC_CAST(AP4_SttsAtom, stbl->GetChild(AP4_ATOM_TYPE_STTS));\n    m_StssAtom = AP4_DYNAMIC_CAST(AP4_StssAtom, stbl->GetChild(AP4_ATOM_TYPE_STSS));\n    m_StsdAtom = AP4_DYNAMIC_CAST(AP4_StsdAtom, stbl->GetChild(AP4_ATOM_TYPE_STSD));\n    m_Co64Atom = AP4_DYNAMIC_CAST(AP4_Co64Atom, stbl->GetChild(AP4_ATOM_TYPE_CO64));\n\n    // keep a reference to the sample stream\n    m_SampleStream.AddReference();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::~AP4_AtomSampleTable\n+---------------------------------------------------------------------*/\nAP4_AtomSampleTable::~AP4_AtomSampleTable()\n{\n    m_SampleStream.Release();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSample\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_AtomSampleTable::GetSample(AP4_Ordinal index, \n                               AP4_Sample& sample)\n{\n    AP4_Result result;\n\n    // check that we have an stsc atom\n    if (!m_StscAtom) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n    \n    // check that we have a chunk offset table\n    if (m_StcoAtom == NULL && m_Co64Atom == NULL) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\n    // MP4 uses 1-based indexes internally, so adjust by one\n    index++;\n\n    // find out in which chunk this sample is located\n    AP4_Ordinal chunk, skip, desc;\n    result = m_StscAtom->GetChunkForSample(index, chunk, skip, desc);\n    if (AP4_FAILED(result)) return result;\n    \n    // check that the result is within bounds\n    if (skip > index) return AP4_ERROR_INTERNAL;\n\n    // get the atom offset for this chunk\n    AP4_UI64 offset;\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        result = m_StcoAtom->GetChunkOffset(chunk, offset_32);\n        offset = offset_32;\n    } else {\n        result = m_Co64Atom->GetChunkOffset(chunk, offset);\n    }\n    if (AP4_FAILED(result)) return result;\n    \n    // compute the additional offset inside the chunk\n    for (unsigned int i = index-skip; i < index; i++) {\n        AP4_Size size = 0;\n        if (m_StszAtom) {\n            result = m_StszAtom->GetSampleSize(i, size); \n        } else if (m_Stz2Atom) {\n            result = m_Stz2Atom->GetSampleSize(i, size); \n        } else {\n            result = AP4_ERROR_INVALID_FORMAT;\n        }\n        if (AP4_FAILED(result)) return result;\n        offset += size;\n    }\n\n    // set the description index\n    sample.SetDescriptionIndex(desc-1); // adjust for 0-based indexes\n\n    // set the dts and cts\n    AP4_UI32 cts_offset = 0;\n    AP4_UI64 dts        = 0;\n    AP4_UI32 duration   = 0;\n    result = m_SttsAtom->GetDts(index, dts, &duration);\n    if (AP4_FAILED(result)) return result;\n    sample.SetDuration(duration);\n    sample.SetDts(dts);\n    if (m_CttsAtom == NULL) {\n        sample.SetCts(dts);\n    } else {\n        result = m_CttsAtom->GetCtsOffset(index, cts_offset); \n\t    if (AP4_FAILED(result)) return result;\n        sample.SetCtsDelta(cts_offset);\n    }     \n\n    // set the size\n    AP4_Size sample_size = 0;\n    if (m_StszAtom) {\n        result = m_StszAtom->GetSampleSize(index, sample_size); \n    } else if (m_Stz2Atom) {\n        result = m_Stz2Atom->GetSampleSize(index, sample_size); \n    } else {\n        result = AP4_ERROR_INVALID_FORMAT;\n    }\n    if (AP4_FAILED(result)) return result;\n    sample.SetSize(sample_size);\n\n    // set the sync flag\n    if (m_StssAtom == NULL) {\n        sample.SetSync(true);\n    } else {\n        sample.SetSync(m_StssAtom->IsSampleSync(index));\n    }\n\n    // set the offset\n    sample.SetOffset(offset);\n\n    // set the data stream\n    sample.SetDataStream(m_SampleStream);\n\n\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleCount\n+---------------------------------------------------------------------*/\nAP4_Cardinal\nAP4_AtomSampleTable::GetSampleCount()\n{\n    if (m_StszAtom) {\n        return m_StszAtom->GetSampleCount();\n    } else if (m_Stz2Atom) {\n        return m_Stz2Atom->GetSampleCount();\n    } else {\n        return 0;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleDescription\n+---------------------------------------------------------------------*/\nAP4_SampleDescription*\nAP4_AtomSampleTable::GetSampleDescription(AP4_Ordinal index)\n{\n    return m_StsdAtom ? m_StsdAtom->GetSampleDescription(index) : NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleDescriptionCount\n+---------------------------------------------------------------------*/\nAP4_Cardinal\nAP4_AtomSampleTable::GetSampleDescriptionCount()\n{\n    return m_StsdAtom ? m_StsdAtom->GetSampleDescriptionCount() : 0;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleChunkPosition\n+---------------------------------------------------------------------*/\nAP4_Result   \nAP4_AtomSampleTable::GetSampleChunkPosition(AP4_Ordinal  sample_index, \n                                            AP4_Ordinal& chunk_index,\n                                            AP4_Ordinal& position_in_chunk)\n{\n    // default values\n    chunk_index       = 0;\n    position_in_chunk = 0;\n    \n    AP4_Ordinal sample_description_index;\n    return GetChunkForSample(sample_index, \n                             chunk_index, \n                             position_in_chunk, \n                             sample_description_index);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetChunkForSample\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::GetChunkForSample(AP4_Ordinal  sample_index,\n                                       AP4_Ordinal& chunk_index,\n                                       AP4_Ordinal& position_in_chunk,\n                                       AP4_Ordinal& sample_description_index)\n{\n    // default values\n    chunk_index              = 0;\n    position_in_chunk        = 0;\n    sample_description_index = 0;\n\n    // check that we an stsc atom\n    if (m_StscAtom == NULL) return AP4_ERROR_INVALID_STATE;\n    \n    // get the chunk info from the stsc atom\n    AP4_Ordinal chunk = 0;\n    AP4_Result result = m_StscAtom->GetChunkForSample(sample_index+1, // the atom API is 1-based \n                                                      chunk, \n                                                      position_in_chunk, \n                                                      sample_description_index);\n    if (AP4_FAILED(result)) return result;\n    if (chunk == 0) return AP4_ERROR_INTERNAL;\n\n    // the atom sample and chunk indexes are 1-based, so we need to translate\n    chunk_index = chunk-1;\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetChunkOffset\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::GetChunkOffset(AP4_Ordinal   chunk_index, \n                                    AP4_Position& offset)\n{\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        AP4_Result result = m_StcoAtom->GetChunkOffset(chunk_index+1, offset_32);\n        if (AP4_SUCCEEDED(result)) {\n            offset = offset_32;\n        } else {\n            offset = 0;\n        }\n        return result;\n    } else if (m_Co64Atom) {\n        return m_Co64Atom->GetChunkOffset(chunk_index+1, offset);\n    } else {\n        offset = 0;\n        return AP4_FAILURE;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::SetChunkOffset\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::SetChunkOffset(AP4_Ordinal  chunk_index, \n                                    AP4_Position offset)\n{\n    if (m_StcoAtom) {\n        if ((offset >> 32) != 0) return AP4_ERROR_OUT_OF_RANGE;\n        return m_StcoAtom->SetChunkOffset(chunk_index+1, (AP4_UI32)offset);\n    } else if (m_Co64Atom) {\n        return m_Co64Atom->SetChunkOffset(chunk_index+1, offset);\n    } else {\n        return AP4_FAILURE;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::SetSampleSize\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::SetSampleSize(AP4_Ordinal sample_index, AP4_Size size)\n{\n    if (m_StszAtom) {\n        return m_StszAtom->SetSampleSize(sample_index+1, size);\n    } else if (m_Stz2Atom) {\n        return m_Stz2Atom->SetSampleSize(sample_index+1, size);\n    } else {    \n        return AP4_FAILURE;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleIndexForTimeStamp\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::GetSampleIndexForTimeStamp(AP4_UI64     ts, \n                                                AP4_Ordinal& sample_index)\n{\n    return m_SttsAtom ? m_SttsAtom->GetSampleIndexForTimeStamp(ts, sample_index) \n                      : AP4_FAILURE;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetNearestSyncSampleIndex\n+---------------------------------------------------------------------*/\nAP4_Ordinal  \nAP4_AtomSampleTable::GetNearestSyncSampleIndex(AP4_Ordinal sample_index, bool before)\n{\n    // if we don't have an stss table, all samples match\n    if (m_StssAtom == NULL) return sample_index;\n    \n    sample_index += 1; // the table is 1-based\n    AP4_Cardinal entry_count = m_StssAtom->GetEntries().ItemCount();\n    if (before) {\n        AP4_Ordinal cursor = 0;    \n        for (unsigned int i=0; i<entry_count; i++) {\n            if (m_StssAtom->GetEntries()[i] >= sample_index) return cursor;\n            if (m_StssAtom->GetEntries()[i]) cursor = m_StssAtom->GetEntries()[i]-1;\n        }\n\n        // not found?\n        return cursor;\n    } else {\n        for (unsigned int i=0; i<entry_count; i++) {\n            if (m_StssAtom->GetEntries()[i] >= sample_index) {\n                return m_StssAtom->GetEntries()[i]?m_StssAtom->GetEntries()[i]-1:sample_index-1;\n            }\n        }\n\n        // not found?\n        return GetSampleCount();\n    }\n}\n\n", "/*****************************************************************\n|\n|    AP4 - avcC Atoms \n|\n|    Copyright 2002-2008 Axiomatic Systems, LLC\n|\n|\n|    This file is part of Bento4/AP4 (MP4 Atom Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the file COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"Ap4AvccAtom.h\"\n#include \"Ap4AtomFactory.h\"\n#include \"Ap4Utils.h\"\n#include \"Ap4Types.h\"\n\n/*----------------------------------------------------------------------\n|   dynamic cast support\n+---------------------------------------------------------------------*/\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_AvccAtom)\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::GetProfileName\n+---------------------------------------------------------------------*/\nconst char*\nAP4_AvccAtom::GetProfileName(AP4_UI08 profile)\n{\n    switch (profile) {\n        case AP4_AVC_PROFILE_BASELINE: return \"Baseline\";   \n        case AP4_AVC_PROFILE_MAIN:     return \"Main\";\n        case AP4_AVC_PROFILE_EXTENDED: return \"Extended\";\n        case AP4_AVC_PROFILE_HIGH:     return \"High\";\n        case AP4_AVC_PROFILE_HIGH_10:  return \"High 10\";\n        case AP4_AVC_PROFILE_HIGH_422: return \"High 4:2:2\";\n        case AP4_AVC_PROFILE_HIGH_444: return \"High 4:4:4\";\n    }\n\n    return NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::Create\n+---------------------------------------------------------------------*/\nAP4_AvccAtom* \nAP4_AvccAtom::Create(AP4_Size size, AP4_ByteStream& stream)\n{\n    // read the raw bytes in a buffer\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    AP4_DataBuffer payload_data(payload_size);\n    AP4_Result result = stream.Read(payload_data.UseData(), payload_size);\n    if (AP4_FAILED(result)) return NULL;\n    \n    // check the version\n    const AP4_UI08* payload = payload_data.GetData();\n    if (payload[0] != 1) {\n        return NULL;\n    }\n\n    // check the size\n    if (payload_size < 6) return NULL;\n    unsigned int num_seq_params = payload[5]&31;\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        if (cursor+2 > payload_size) return NULL;\n        cursor += 2+AP4_BytesToInt16BE(&payload[cursor]);\n        if (cursor > payload_size) return NULL;\n    }\n    unsigned int num_pic_params = payload[cursor++];\n    if (cursor > payload_size) return NULL;\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        if (cursor+2 > payload_size) return NULL;\n        cursor += 2+AP4_BytesToInt16BE(&payload[cursor]);\n        if (cursor > payload_size) return NULL;\n    }\n    return new AP4_AvccAtom(size, payload);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom() :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, AP4_ATOM_HEADER_SIZE),\n    m_ConfigurationVersion(1),\n    m_Profile(0),\n    m_Level(0),\n    m_ProfileCompatibility(0),\n    m_NaluLengthSize(0)\n{\n    UpdateRawBytes();\n    m_Size32 += m_RawBytes.GetDataSize();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom(const AP4_AvccAtom& other) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, other.m_Size32),\n    m_ConfigurationVersion(other.m_ConfigurationVersion),\n    m_Profile(other.m_Profile),\n    m_Level(other.m_Level),\n    m_ProfileCompatibility(other.m_ProfileCompatibility),\n    m_NaluLengthSize(other.m_NaluLengthSize),\n    m_RawBytes(other.m_RawBytes)\n{\n    // deep copy of the parameters\n    unsigned int i = 0;\n    for (i=0; i<other.m_SequenceParameters.ItemCount(); i++) {\n        m_SequenceParameters.Append(other.m_SequenceParameters[i]);\n    }\n    for (i=0; i<other.m_PictureParameters.ItemCount(); i++) {\n        m_PictureParameters.Append(other.m_PictureParameters[i]);\n    }    \n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n    // make a copy of our configuration bytes\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n\n    // parse the payload\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        m_SequenceParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        m_PictureParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_PictureParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n}\n\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom(AP4_UI08                         profile, \n                           AP4_UI08                         level, \n                           AP4_UI08                         profile_compatibility, \n                           AP4_UI08                         length_size, \n                           const AP4_Array<AP4_DataBuffer>& sequence_parameters, \n                           const AP4_Array<AP4_DataBuffer>& picture_parameters) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, AP4_ATOM_HEADER_SIZE),\n    m_ConfigurationVersion(1),\n    m_Profile(profile),\n    m_Level(level),\n    m_ProfileCompatibility(profile_compatibility),\n    m_NaluLengthSize(length_size)\n{\n    // deep copy of the parameters\n    unsigned int i = 0;\n    for (i=0; i<sequence_parameters.ItemCount(); i++) {\n        m_SequenceParameters.Append(sequence_parameters[i]);\n    }\n    for (i=0; i<picture_parameters.ItemCount(); i++) {\n        m_PictureParameters.Append(picture_parameters[i]);\n    }    \n\n    // compute the raw bytes\n    UpdateRawBytes();\n\n    // update the size\n    m_Size32 += m_RawBytes.GetDataSize();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::UpdateRawBytes\n+---------------------------------------------------------------------*/\nvoid\nAP4_AvccAtom::UpdateRawBytes()\n{\n    // compute the payload size\n    unsigned int payload_size = 6;    \n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        payload_size += 2+m_SequenceParameters[i].GetDataSize();\n    }\n    ++payload_size;\n    for (unsigned int i=0; i<m_PictureParameters.ItemCount(); i++) {\n        payload_size += 2+m_PictureParameters[i].GetDataSize();\n    }\n    m_RawBytes.SetDataSize(payload_size);\n    AP4_UI08* payload = m_RawBytes.UseData();\n\n    payload[0] = m_ConfigurationVersion;\n    payload[1] = m_Profile;\n    payload[2] = m_ProfileCompatibility;\n    payload[3] = m_Level;\n    payload[4] = 0xFC | (m_NaluLengthSize-1);\n    payload[5] = 0xE0 | (AP4_UI08)m_SequenceParameters.ItemCount();\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        AP4_UI16 param_length = (AP4_UI16)m_SequenceParameters[i].GetDataSize();\n        AP4_BytesFromUInt16BE(&payload[cursor], param_length);\n        cursor += 2;\n        AP4_CopyMemory(&payload[cursor], m_SequenceParameters[i].GetData(), param_length);\n        cursor += param_length;\n    }\n    payload[cursor++] = (AP4_UI08)m_PictureParameters.ItemCount();\n    for (unsigned int i=0; i<m_PictureParameters.ItemCount(); i++) {\n        AP4_UI16 param_length = (AP4_UI16)m_PictureParameters[i].GetDataSize();\n        AP4_BytesFromUInt16BE(&payload[cursor], param_length);\n        cursor += 2;\n        AP4_CopyMemory(&payload[cursor], m_PictureParameters[i].GetData(), param_length);\n        cursor += param_length;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_AvccAtom::WriteFields(AP4_ByteStream& stream)\n{\n    return stream.Write(m_RawBytes.GetData(), m_RawBytes.GetDataSize());\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_AvccAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"Configuration Version\", m_ConfigurationVersion);\n    const char* profile_name = GetProfileName(m_Profile);\n    if (profile_name) {\n        inspector.AddField(\"Profile\", profile_name);\n    } else {\n        inspector.AddField(\"Profile\", m_Profile);\n    }\n    inspector.AddField(\"Profile Compatibility\", m_ProfileCompatibility, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Level\", m_Level);\n    inspector.AddField(\"NALU Length Size\", m_NaluLengthSize);\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n    }\n    for (unsigned int i=0; i<m_PictureParameters.ItemCount(); i++) {\n        inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n    }\n    return AP4_SUCCESS;\n}\n", "/*****************************************************************\n|\n|    AP4 - File Processor\n|\n|    Copyright 2002-2008 Axiomatic Systems, LLC\n|\n|\n|    This file is part of Bento4/AP4 (MP4 Atom Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the file COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"Ap4Processor.h\"\n#include \"Ap4AtomSampleTable.h\"\n#include \"Ap4MovieFragment.h\"\n#include \"Ap4FragmentSampleTable.h\"\n#include \"Ap4TfhdAtom.h\"\n#include \"Ap4AtomFactory.h\"\n#include \"Ap4Movie.h\"\n#include \"Ap4Array.h\"\n#include \"Ap4Sample.h\"\n#include \"Ap4TrakAtom.h\"\n#include \"Ap4TfraAtom.h\"\n#include \"Ap4TrunAtom.h\"\n#include \"Ap4TrexAtom.h\"\n#include \"Ap4TkhdAtom.h\"\n#include \"Ap4SidxAtom.h\"\n#include \"Ap4DataBuffer.h\"\n#include \"Ap4Debug.h\"\n\n/*----------------------------------------------------------------------\n|   types\n+---------------------------------------------------------------------*/\nstruct AP4_SampleLocator {\n    AP4_SampleLocator() : \n        m_TrakIndex(0), \n        m_SampleTable(NULL), \n        m_SampleIndex(0), \n        m_ChunkIndex(0) {}\n    AP4_Ordinal          m_TrakIndex;\n    AP4_AtomSampleTable* m_SampleTable;\n    AP4_Ordinal          m_SampleIndex;\n    AP4_Ordinal          m_ChunkIndex;\n    AP4_Sample           m_Sample;\n};\n\nstruct AP4_SampleCursor {\n    AP4_SampleCursor() : m_EndReached(false) {}\n    AP4_SampleLocator m_Locator;\n    bool              m_EndReached;\n};\n\nstruct AP4_AtomLocator {\n    AP4_AtomLocator(AP4_Atom* atom, AP4_UI64 offset) : \n        m_Atom(atom),\n        m_Offset(offset) {}\n    AP4_Atom* m_Atom;\n    AP4_UI64  m_Offset;\n};\n\n/*----------------------------------------------------------------------\n|   AP4_DefaultFragmentHandler\n+---------------------------------------------------------------------*/\nclass AP4_DefaultFragmentHandler: public AP4_Processor::FragmentHandler {\npublic:\n    AP4_DefaultFragmentHandler(AP4_Processor::TrackHandler* track_handler) :\n        m_TrackHandler(track_handler) {}\n    AP4_Result ProcessSample(AP4_DataBuffer& data_in,\n                             AP4_DataBuffer& data_out);\n                             \nprivate:\n    AP4_Processor::TrackHandler* m_TrackHandler;\n};\n\n/*----------------------------------------------------------------------\n|   AP4_DefaultFragmentHandler::ProcessSample\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_DefaultFragmentHandler::ProcessSample(AP4_DataBuffer& data_in, AP4_DataBuffer& data_out)\n{\n    if (m_TrackHandler == NULL) {\n        data_out.SetData(data_in.GetData(), data_in.GetDataSize());\n        return AP4_SUCCESS;\n    }\n    return m_TrackHandler->ProcessSample(data_in, data_out);\n}\n\n/*----------------------------------------------------------------------\n|   FragmentMapEntry\n+---------------------------------------------------------------------*/\ntypedef struct {\n    AP4_UI64 before;\n    AP4_UI64 after;\n} FragmentMapEntry;\n\n/*----------------------------------------------------------------------\n|   FindFragmentMapEntry\n+---------------------------------------------------------------------*/\nstatic const FragmentMapEntry*\nFindFragmentMapEntry(AP4_Array<FragmentMapEntry>& fragment_map, AP4_UI64 fragment_offset) {\n    int first = 0;\n    int last = fragment_map.ItemCount();\n    while (first < last) {\n        int middle = (last+first)/2;\n        AP4_UI64 middle_value = fragment_map[middle].before;\n        if (fragment_offset < middle_value) {\n            last = middle;\n        } else if (fragment_offset > middle_value) {\n            first = middle+1;\n        } else {\n            return &fragment_map[middle];\n        }\n    }\n    \n    return NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor::ProcessFragments\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_Processor::ProcessFragments(AP4_MoovAtom*              moov, \n                                AP4_List<AP4_AtomLocator>& atoms, \n                                AP4_ContainerAtom*         mfra,\n                                AP4_SidxAtom*              sidx,\n                                AP4_Position               sidx_position,\n                                AP4_ByteStream&            input, \n                                AP4_ByteStream&            output)\n{\n    unsigned int fragment_index = 0;\n    AP4_Array<FragmentMapEntry> fragment_map;\n    \n    for (AP4_List<AP4_AtomLocator>::Item* item = atoms.FirstItem();\n                                          item;\n                                          item = item->GetNext(), ++fragment_index) {\n        AP4_AtomLocator*   locator     = item->GetData();\n        AP4_Atom*          atom        = locator->m_Atom;\n        AP4_UI64           atom_offset = locator->m_Offset;\n        AP4_UI64           mdat_payload_offset = atom_offset+atom->GetSize()+AP4_ATOM_HEADER_SIZE;\n        AP4_Sample         sample;\n        AP4_DataBuffer     sample_data_in;\n        AP4_DataBuffer     sample_data_out;\n        AP4_Result         result;\n    \n        // if this is not a moof atom, just write it back and continue\n        if (atom->GetType() != AP4_ATOM_TYPE_MOOF) {\n            result = atom->Write(output);\n            if (AP4_FAILED(result)) return result;\n            continue;\n        }\n        \n        // parse the moof\n        AP4_ContainerAtom* moof = AP4_DYNAMIC_CAST(AP4_ContainerAtom, atom);\n        AP4_MovieFragment* fragment = new AP4_MovieFragment(moof);\n\n        // process all the traf atoms\n        AP4_Array<AP4_Processor::FragmentHandler*> handlers;\n        AP4_Array<AP4_FragmentSampleTable*> sample_tables;\n        for (;AP4_Atom* child = moof->GetChild(AP4_ATOM_TYPE_TRAF, handlers.ItemCount());) {\n            AP4_ContainerAtom* traf = AP4_DYNAMIC_CAST(AP4_ContainerAtom, child);\n            AP4_TfhdAtom* tfhd = AP4_DYNAMIC_CAST(AP4_TfhdAtom, traf->GetChild(AP4_ATOM_TYPE_TFHD));\n            \n            // find the 'trak' for this track\n            AP4_TrakAtom* trak = NULL;\n            for (AP4_List<AP4_Atom>::Item* child_item = moov->GetChildren().FirstItem();\n                                           child_item;\n                                           child_item = child_item->GetNext()) {\n                AP4_Atom* child_atom = child_item->GetData();\n                if (child_atom->GetType() == AP4_ATOM_TYPE_TRAK) {\n                    trak = AP4_DYNAMIC_CAST(AP4_TrakAtom, child_atom);\n                    if (trak) {\n                        AP4_TkhdAtom* tkhd = AP4_DYNAMIC_CAST(AP4_TkhdAtom, trak->GetChild(AP4_ATOM_TYPE_TKHD));\n                        if (tkhd && tkhd->GetTrackId() == tfhd->GetTrackId()) {\n                            break;\n                        }\n                    }\n                    trak = NULL;\n                }\n            }\n            \n            // find the 'trex' for this track\n            AP4_ContainerAtom* mvex = NULL;\n            AP4_TrexAtom*      trex = NULL;\n            mvex = AP4_DYNAMIC_CAST(AP4_ContainerAtom, moov->GetChild(AP4_ATOM_TYPE_MVEX));\n            if (mvex) {\n                for (AP4_List<AP4_Atom>::Item* child_item = mvex->GetChildren().FirstItem();\n                                               child_item;\n                                               child_item = child_item->GetNext()) {\n                    AP4_Atom* child_atom = child_item->GetData();\n                    if (child_atom->GetType() == AP4_ATOM_TYPE_TREX) {\n                        trex = AP4_DYNAMIC_CAST(AP4_TrexAtom, child_atom);\n                        if (trex && trex->GetTrackId() == tfhd->GetTrackId()) {\n                            break;\n                        }\n                        trex = NULL;\n                    }\n                }\n            }\n\n            // create the handler for this traf\n            AP4_Processor::FragmentHandler* handler = CreateFragmentHandler(trak, trex, traf, input, atom_offset);\n            if (handler) {\n                result = handler->ProcessFragment();\n                if (AP4_FAILED(result)) return result;\n            }\n            handlers.Append(handler);\n            \n            // create a sample table object so we can read the sample data\n            AP4_FragmentSampleTable* sample_table = NULL;\n            result = fragment->CreateSampleTable(moov, tfhd->GetTrackId(), &input, atom_offset, mdat_payload_offset, 0, sample_table);\n            if (AP4_FAILED(result)) return result;\n            sample_tables.Append(sample_table);\n            \n            // let the handler look at the samples before we process them\n            if (handler) result = handler->PrepareForSamples(sample_table);\n            if (AP4_FAILED(result)) return result;\n        }\n             \n        // write the moof\n        AP4_UI64 moof_out_start = 0;\n        output.Tell(moof_out_start);\n        moof->Write(output);\n        \n        // remember the location of this fragment\n        FragmentMapEntry map_entry = {atom_offset, moof_out_start};\n        fragment_map.Append(map_entry);\n\n        // write an mdat header\n        AP4_Position mdat_out_start;\n        AP4_UI64 mdat_size = AP4_ATOM_HEADER_SIZE;\n        output.Tell(mdat_out_start);\n        output.WriteUI32(0);\n        output.WriteUI32(AP4_ATOM_TYPE_MDAT);\n\n        // process all track runs\n        for (unsigned int i=0; i<handlers.ItemCount(); i++) {\n            AP4_Processor::FragmentHandler* handler = handlers[i];\n\n            // get the track ID\n            AP4_ContainerAtom* traf = AP4_DYNAMIC_CAST(AP4_ContainerAtom, moof->GetChild(AP4_ATOM_TYPE_TRAF, i));\n            if (traf == NULL) continue;\n            AP4_TfhdAtom* tfhd = AP4_DYNAMIC_CAST(AP4_TfhdAtom, traf->GetChild(AP4_ATOM_TYPE_TFHD));\n            \n            // compute the base data offset\n            AP4_UI64 base_data_offset;\n            if (tfhd->GetFlags() & AP4_TFHD_FLAG_BASE_DATA_OFFSET_PRESENT) {\n                base_data_offset = mdat_out_start+AP4_ATOM_HEADER_SIZE;\n            } else {\n                base_data_offset = moof_out_start;\n            }\n            \n            // build a list of all trun atoms\n            AP4_Array<AP4_TrunAtom*> truns;\n            for (AP4_List<AP4_Atom>::Item* child_item = traf->GetChildren().FirstItem();\n                                           child_item;\n                                           child_item = child_item->GetNext()) {\n                AP4_Atom* child_atom = child_item->GetData();\n                if (child_atom->GetType() == AP4_ATOM_TYPE_TRUN) {\n                    AP4_TrunAtom* trun = AP4_DYNAMIC_CAST(AP4_TrunAtom, child_atom);\n                    truns.Append(trun);\n                }\n            }    \n            AP4_Ordinal   trun_index        = 0;\n            AP4_Ordinal   trun_sample_index = 0;\n            AP4_TrunAtom* trun = truns[0];\n            trun->SetDataOffset((AP4_SI32)((mdat_out_start+mdat_size)-base_data_offset));\n            \n            // write the mdat\n            for (unsigned int j=0; j<sample_tables[i]->GetSampleCount(); j++, trun_sample_index++) {\n                // advance the trun index if necessary\n                if (trun_sample_index >= trun->GetEntries().ItemCount()) {\n                    trun = truns[++trun_index];\n                    trun->SetDataOffset((AP4_SI32)((mdat_out_start+mdat_size)-base_data_offset));\n                    trun_sample_index = 0;\n                }\n                \n                // get the next sample\n                result = sample_tables[i]->GetSample(j, sample);\n                if (AP4_FAILED(result)) return result;\n                sample.ReadData(sample_data_in);\n                \n                // process the sample data\n                if (handler) {\n                    result = handler->ProcessSample(sample_data_in, sample_data_out);\n                    if (AP4_FAILED(result)) return result;\n\n                    // write the sample data\n                    result = output.Write(sample_data_out.GetData(), sample_data_out.GetDataSize());\n                    if (AP4_FAILED(result)) return result;\n\n                    // update the mdat size\n                    mdat_size += sample_data_out.GetDataSize();\n                    \n                    // update the trun entry\n                    trun->UseEntries()[trun_sample_index].sample_size = sample_data_out.GetDataSize();\n                } else {\n                    // write the sample data (unmodified)\n                    result = output.Write(sample_data_in.GetData(), sample_data_in.GetDataSize());\n                    if (AP4_FAILED(result)) return result;\n\n                    // update the mdat size\n                    mdat_size += sample_data_in.GetDataSize();\n                }\n            }\n\n            if (handler) {\n                // update the tfhd header\n                if (tfhd->GetFlags() & AP4_TFHD_FLAG_BASE_DATA_OFFSET_PRESENT) {\n                    tfhd->SetBaseDataOffset(mdat_out_start+AP4_ATOM_HEADER_SIZE);\n                }\n                if (tfhd->GetFlags() & AP4_TFHD_FLAG_DEFAULT_SAMPLE_SIZE_PRESENT) {\n                    tfhd->SetDefaultSampleSize(trun->GetEntries()[0].sample_size);\n                }\n                \n                // give the handler a chance to update the atoms\n                handler->FinishFragment();\n            }\n        }\n\n        // update the mdat header\n        AP4_Position mdat_out_end;\n        output.Tell(mdat_out_end);\n#if defined(AP4_DEBUG)\n        AP4_ASSERT(mdat_out_end-mdat_out_start == mdat_size);\n#endif\n        output.Seek(mdat_out_start);\n        output.WriteUI32((AP4_UI32)mdat_size);\n        output.Seek(mdat_out_end);\n        \n        // update the moof if needed\n        output.Seek(moof_out_start);\n        moof->Write(output);\n        output.Seek(mdat_out_end);\n        \n        // update the sidx if we have one\n        if (sidx && fragment_index < sidx->GetReferences().ItemCount()) {\n            if (fragment_index == 0) {\n                sidx->SetFirstOffset(moof_out_start-(sidx_position+sidx->GetSize()));\n            }\n            AP4_LargeSize fragment_size = mdat_out_end-moof_out_start;\n            AP4_SidxAtom::Reference& sidx_ref = sidx->UseReferences()[fragment_index];\n            sidx_ref.m_ReferencedSize = (AP4_UI32)fragment_size;\n        }\n        \n        // cleanup\n        delete fragment;\n        \n        for (unsigned int i=0; i<handlers.ItemCount(); i++) {\n            delete handlers[i];\n        }\n        for (unsigned int i=0; i<sample_tables.ItemCount(); i++) {\n            delete sample_tables[i];\n        }\n    }\n    \n    // update the mfra if we have one\n    if (mfra) {\n        for (AP4_List<AP4_Atom>::Item* mfra_item = mfra->GetChildren().FirstItem();\n                                       mfra_item;\n                                       mfra_item = mfra_item->GetNext()) {\n            if (mfra_item->GetData()->GetType() != AP4_ATOM_TYPE_TFRA) continue;\n            AP4_TfraAtom* tfra = AP4_DYNAMIC_CAST(AP4_TfraAtom, mfra_item->GetData());\n            if (tfra == NULL) continue;\n            AP4_Array<AP4_TfraAtom::Entry>& entries     = tfra->GetEntries();\n            AP4_Cardinal                    entry_count = entries.ItemCount();\n            for (unsigned int i=0; i<entry_count; i++) {\n                const FragmentMapEntry* found = FindFragmentMapEntry(fragment_map, entries[i].m_MoofOffset);\n                if (found) {\n                    entries[i].m_MoofOffset = found->after;\n                }\n            }\n        }\n    }\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor::CreateFragmentHandler\n+---------------------------------------------------------------------*/\nAP4_Processor::FragmentHandler* \nAP4_Processor::CreateFragmentHandler(AP4_TrakAtom*      /* trak */,\n                                     AP4_TrexAtom*      /* trex */,\n                                     AP4_ContainerAtom* traf,\n                                     AP4_ByteStream&    /* moof_data   */,\n                                     AP4_Position       /* moof_offset */)\n{\n    // find the matching track handler\n    for (unsigned int i=0; i<m_TrackIds.ItemCount(); i++) {\n        AP4_TfhdAtom* tfhd = AP4_DYNAMIC_CAST(AP4_TfhdAtom, traf->GetChild(AP4_ATOM_TYPE_TFHD));\n        if (tfhd && m_TrackIds[i] == tfhd->GetTrackId()) {\n            return new AP4_DefaultFragmentHandler(m_TrackHandlers[i]);\n        }\n    }\n    \n    return NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor::Process\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_Processor::Process(AP4_ByteStream&   input, \n                       AP4_ByteStream&   output,\n                       AP4_ByteStream*   fragments,\n                       ProgressListener* listener,\n                       AP4_AtomFactory&  atom_factory)\n{\n    // read all atoms.\n    // keep all atoms except [mdat]\n    // keep a ref to [moov]\n    // put [moof] atoms in a separate list\n    AP4_AtomParent              top_level;\n    AP4_MoovAtom*               moov = NULL;\n    AP4_ContainerAtom*          mfra = NULL;\n    AP4_SidxAtom*               sidx = NULL;\n    AP4_List<AP4_AtomLocator>   frags;\n    AP4_UI64                    stream_offset = 0;\n    bool                        in_fragments = false;\n    unsigned int                sidx_count = 0;\n    for (AP4_Atom* atom = NULL;\n        AP4_SUCCEEDED(atom_factory.CreateAtomFromStream(input, atom));\n        input.Tell(stream_offset)) {\n        if (atom->GetType() == AP4_ATOM_TYPE_MDAT) {\n            delete atom;\n            continue;\n        } else if (atom->GetType() == AP4_ATOM_TYPE_MOOV) {\n            moov = AP4_DYNAMIC_CAST(AP4_MoovAtom, atom);\n            if (fragments) break;\n        } else if (atom->GetType() == AP4_ATOM_TYPE_MFRA) {\n            mfra = AP4_DYNAMIC_CAST(AP4_ContainerAtom, atom);\n            continue;\n        } else if (atom->GetType() == AP4_ATOM_TYPE_SIDX) {\n            // don't keep the index, it is likely to be invalidated, we will recompute it later\n            ++sidx_count;\n            if (sidx == NULL) {\n                sidx = AP4_DYNAMIC_CAST(AP4_SidxAtom, atom);\n            } else {\n                delete atom;\n                continue;\n            }\n        } else if (atom->GetType() == AP4_ATOM_TYPE_SSIX) {\n            // don't keep the index, it is likely to be invalidated\n            delete atom;\n            continue;\n        } else if (!fragments && (in_fragments || atom->GetType() == AP4_ATOM_TYPE_MOOF)) {\n            in_fragments = true;\n            frags.Add(new AP4_AtomLocator(atom, stream_offset));\n            continue;\n        }\n        top_level.AddChild(atom);\n    }\n\n    // check that we have at most one sidx (we can't deal with multi-sidx streams here\n    if (sidx_count > 1) {\n        top_level.RemoveChild(sidx);\n        delete sidx;\n        sidx = NULL;\n    }\n    \n    // if we have a fragments stream, get the fragment locators from there\n    if (fragments) {\n        stream_offset = 0;\n        for (AP4_Atom* atom = NULL;\n            AP4_SUCCEEDED(atom_factory.CreateAtomFromStream(*fragments, atom));\n            fragments->Tell(stream_offset)) {\n            if (atom->GetType() == AP4_ATOM_TYPE_MDAT) {\n                delete atom;\n                continue;\n            }\n            frags.Add(new AP4_AtomLocator(atom, stream_offset));\n        }\n    }\n    \n    // initialize the processor\n    AP4_Result result = Initialize(top_level, input);\n    if (AP4_FAILED(result)) return result;\n\n    // process the tracks if we have a moov atom\n    AP4_Array<AP4_SampleLocator> locators;\n    AP4_Cardinal                 track_count       = 0;\n    AP4_List<AP4_TrakAtom>*      trak_atoms        = NULL;\n    AP4_LargeSize                mdat_payload_size = 0;\n    AP4_SampleCursor*            cursors           = NULL;\n    if (moov) {\n        // build an array of track sample locators\n        trak_atoms = &moov->GetTrakAtoms();\n        track_count = trak_atoms->ItemCount();\n        cursors = new AP4_SampleCursor[track_count];\n        m_TrackHandlers.SetItemCount(track_count);\n        m_TrackIds.SetItemCount(track_count);\n        for (AP4_Ordinal i=0; i<track_count; i++) {\n            m_TrackHandlers[i] = NULL;\n            m_TrackIds[i] = 0;\n        }\n        \n        unsigned int index = 0;\n        for (AP4_List<AP4_TrakAtom>::Item* item = trak_atoms->FirstItem(); item; item=item->GetNext()) {\n            AP4_TrakAtom* trak = item->GetData();\n\n            // find the stsd atom\n            AP4_ContainerAtom* stbl = AP4_DYNAMIC_CAST(AP4_ContainerAtom, trak->FindChild(\"mdia/minf/stbl\"));\n            if (stbl == NULL) continue;\n            \n            // see if there's an external data source for this track\n            AP4_ByteStream* trak_data_stream = &input;\n            for (AP4_List<ExternalTrackData>::Item* ditem = m_ExternalTrackData.FirstItem(); ditem; ditem=ditem->GetNext()) {\n                ExternalTrackData* tdata = ditem->GetData();\n                if (tdata->m_TrackId == trak->GetId()) {\n                    trak_data_stream = tdata->m_MediaData;\n                    break;\n                }\n            }\n\n            // create the track handler    \n            m_TrackHandlers[index] = CreateTrackHandler(trak);\n            m_TrackIds[index]      = trak->GetId();\n            cursors[index].m_Locator.m_TrakIndex   = index;\n            cursors[index].m_Locator.m_SampleTable = new AP4_AtomSampleTable(stbl, *trak_data_stream);\n            cursors[index].m_Locator.m_SampleIndex = 0;\n            cursors[index].m_Locator.m_ChunkIndex  = 0;\n            if (cursors[index].m_Locator.m_SampleTable->GetSampleCount()) {\n                cursors[index].m_Locator.m_SampleTable->GetSample(0, cursors[index].m_Locator.m_Sample);\n            } else {\n                cursors[index].m_EndReached = true;\n            }\n\n            index++;            \n        }\n\n        // figure out the layout of the chunks\n        for (;;) {\n            // see which is the next sample to write\n            AP4_UI64 min_offset = (AP4_UI64)(-1);\n            int cursor = -1;\n            for (unsigned int i=0; i<track_count; i++) {\n                if (!cursors[i].m_EndReached &&\n                    cursors[i].m_Locator.m_SampleTable &&\n                    cursors[i].m_Locator.m_Sample.GetOffset() <= min_offset) {\n                    min_offset = cursors[i].m_Locator.m_Sample.GetOffset();\n                    cursor = i;\n                }\n            }\n\n            // stop if all cursors are exhausted\n            if (cursor == -1) break;\n\n            // append this locator to the layout list\n            AP4_SampleLocator& locator = cursors[cursor].m_Locator;\n            locators.Append(locator);\n\n            // move the cursor to the next sample\n            locator.m_SampleIndex++;\n            if (locator.m_SampleIndex == locator.m_SampleTable->GetSampleCount()) {\n                // mark this track as completed\n                cursors[cursor].m_EndReached = true;\n            } else {\n                // get the next sample info\n                locator.m_SampleTable->GetSample(locator.m_SampleIndex, locator.m_Sample);\n                AP4_Ordinal skip, sdesc;\n                locator.m_SampleTable->GetChunkForSample(locator.m_SampleIndex,\n                                                         locator.m_ChunkIndex,\n                                                         skip, sdesc);\n            }\n        }\n\n        // update the stbl atoms and compute the mdat size\n        int current_track = -1;\n        int current_chunk = -1;\n        AP4_Position current_chunk_offset = 0;\n        AP4_Size current_chunk_size = 0;\n        for (AP4_Ordinal i=0; i<locators.ItemCount(); i++) {\n            AP4_SampleLocator& locator = locators[i];\n            if ((int)locator.m_TrakIndex  != current_track ||\n                (int)locator.m_ChunkIndex != current_chunk) {\n                // start a new chunk for this track\n                current_chunk_offset += current_chunk_size;\n                current_chunk_size = 0;\n                current_track = locator.m_TrakIndex;\n                current_chunk = locator.m_ChunkIndex;\n                locator.m_SampleTable->SetChunkOffset(locator.m_ChunkIndex, current_chunk_offset);\n            } \n            AP4_Size sample_size;\n            TrackHandler* handler = m_TrackHandlers[locator.m_TrakIndex];\n            if (handler) {\n                sample_size = handler->GetProcessedSampleSize(locator.m_Sample);\n                locator.m_SampleTable->SetSampleSize(locator.m_SampleIndex, sample_size);\n            } else {\n                sample_size = locator.m_Sample.GetSize();\n            }\n            current_chunk_size += sample_size;\n            mdat_payload_size  += sample_size;\n        }\n\n        // process the tracks (ex: sample descriptions processing)\n        for (AP4_Ordinal i=0; i<track_count; i++) {\n            TrackHandler* handler = m_TrackHandlers[i];\n            if (handler) handler->ProcessTrack();\n        }\n    }\n\n    // finalize the processor\n    Finalize(top_level);\n\n    if (!fragments) {\n        // calculate the size of all atoms combined\n        AP4_UI64 atoms_size = 0;\n        top_level.GetChildren().Apply(AP4_AtomSizeAdder(atoms_size));\n\n        // see if we need a 64-bit or 32-bit mdat\n        AP4_Size mdat_header_size = AP4_ATOM_HEADER_SIZE;\n        if (mdat_payload_size+mdat_header_size > 0xFFFFFFFF) {\n            // we need a 64-bit size\n            mdat_header_size += 8;\n        }\n        \n        // adjust the chunk offsets\n        for (AP4_Ordinal i=0; i<track_count; i++) {\n            AP4_TrakAtom* trak;\n            trak_atoms->Get(i, trak);\n            trak->AdjustChunkOffsets(atoms_size+mdat_header_size);\n        }\n\n        // write all atoms\n        top_level.GetChildren().Apply(AP4_AtomListWriter(output));\n\n        // write mdat header\n        if (mdat_payload_size) {\n            if (mdat_header_size == AP4_ATOM_HEADER_SIZE) {\n                // 32-bit size\n                output.WriteUI32((AP4_UI32)(mdat_header_size+mdat_payload_size));\n                output.WriteUI32(AP4_ATOM_TYPE_MDAT);\n            } else {\n                // 64-bit size\n                output.WriteUI32(1);\n                output.WriteUI32(AP4_ATOM_TYPE_MDAT);\n                output.WriteUI64(mdat_header_size+mdat_payload_size);\n            }\n        }        \n    }\n    \n    // write the samples\n    if (moov) {\n        if (!fragments) {\n#if defined(AP4_DEBUG)\n            AP4_Position before;\n            output.Tell(before);\n#endif\n            AP4_Sample     sample;\n            AP4_DataBuffer data_in;\n            AP4_DataBuffer data_out;\n            for (unsigned int i=0; i<locators.ItemCount(); i++) {\n                AP4_SampleLocator& locator = locators[i];\n                locator.m_Sample.ReadData(data_in);\n                TrackHandler* handler = m_TrackHandlers[locator.m_TrakIndex];\n                if (handler) {\n                    result = handler->ProcessSample(data_in, data_out);\n                    if (AP4_FAILED(result)) return result;\n                    output.Write(data_out.GetData(), data_out.GetDataSize());\n                } else {\n                    output.Write(data_in.GetData(), data_in.GetDataSize());            \n                }\n\n                // notify the progress listener\n                if (listener) {\n                    listener->OnProgress(i+1, locators.ItemCount());\n                }\n            }\n\n#if defined(AP4_DEBUG)\n            AP4_Position after;\n            output.Tell(after);\n            AP4_ASSERT(after-before == mdat_payload_size);\n#endif\n        }\n        \n        // find the position of the sidx atom\n        AP4_Position sidx_position = 0;\n        if (sidx) {\n            for (AP4_List<AP4_Atom>::Item* item = top_level.GetChildren().FirstItem();\n                                           item;\n                                           item = item->GetNext()) {\n                AP4_Atom* atom = item->GetData();\n                if (atom->GetType() == AP4_ATOM_TYPE_SIDX) {\n                    break;\n                }\n                sidx_position += atom->GetSize();\n            }\n        }\n        \n        // process the fragments, if any\n        result = ProcessFragments(moov, frags, mfra, sidx, sidx_position, fragments?*fragments:input, output);\n        if (AP4_FAILED(result)) return result;\n        \n        // update and re-write the sidx if we have one\n        if (sidx && sidx_position) {\n            AP4_Position where = 0;\n            output.Tell(where);\n            output.Seek(sidx_position);\n            result = sidx->Write(output);\n            if (AP4_FAILED(result)) return result;\n            output.Seek(where);\n        }\n        \n        if (!fragments) {\n            // write the mfra atom at the end if we have one\n            if (mfra) {\n                mfra->Write(output);\n            }\n        }\n        \n        // cleanup\n        for (AP4_Ordinal i=0; i<track_count; i++) {\n            delete cursors[i].m_Locator.m_SampleTable;\n            delete m_TrackHandlers[i];\n        }\n        m_TrackHandlers.Clear();\n        delete[] cursors;\n    }\n\n    // cleanup\n    frags.DeleteReferences();\n    delete mfra;\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor::Process\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_Processor::Process(AP4_ByteStream&   input, \n                       AP4_ByteStream&   output,\n                       ProgressListener* listener,\n                       AP4_AtomFactory&  atom_factory)\n{\n    return Process(input, output, NULL, listener, atom_factory);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor::Process\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_Processor::Process(AP4_ByteStream&   fragments, \n                       AP4_ByteStream&   output,\n                       AP4_ByteStream&   init,\n                       ProgressListener* listener,\n                       AP4_AtomFactory&  atom_factory)\n{\n    return Process(init, output, &fragments, listener, atom_factory);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor:Initialize\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_Processor::Initialize(AP4_AtomParent&   /* top_level */,\n                          AP4_ByteStream&   /* stream    */,\n                          ProgressListener* /* listener  */)\n{\n    // default implementation: do nothing\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor:Finalize\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_Processor::Finalize(AP4_AtomParent&   /* top_level */,\n                        ProgressListener* /* listener */ )\n{\n    // default implementation: do nothing\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Processor::TrackHandler Dynamic Cast Anchor\n+---------------------------------------------------------------------*/\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR_S(AP4_Processor::TrackHandler, TrackHandler)\n", "/*****************************************************************\n|\n|    AP4 - Version Numbers\n|\n|    Copyright 2002-2008 Axiomatic Systems, LLC\n|\n|\n|    This file is part of Bento4/AP4 (MP4 Atom Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the file COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n****************************************************************/\n\n#ifndef _AP4_VERSION_H_\n#define _AP4_VERSION_H_\n\n/*----------------------------------------------------------------------\n|   version constants\n+---------------------------------------------------------------------*/\n/**\n * Version number of the SDK\n */\n#define AP4_VERSION        0x01050001\n#define AP4_VERSION_STRING \"1.5.0.1\"\n\n#endif // _AP4_VERSION_H_\n"], "filenames": ["Source/C++/Core/Ap4AtomSampleTable.cpp", "Source/C++/Core/Ap4AvccAtom.cpp", "Source/C++/Core/Ap4Processor.cpp", "Source/C++/Core/Ap4Version.h"], "buggy_code_start_loc": [89, 273, 556, 40], "buggy_code_end_loc": [89, 274, 556, 42], "fixing_code_start_loc": [90, 273, 557, 40], "fixing_code_end_loc": [95, 274, 558, 42], "type": "CWE-476", "message": "The AP4_AvccAtom::InspectFields function in Core/Ap4AvccAtom.cpp in Bento4 mp4dump before 1.5.0-616 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted mp4 file.", "other": {"cve": {"id": "CVE-2017-12476", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-06T08:29:00.277", "lastModified": "2017-09-07T17:17:01.507", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The AP4_AvccAtom::InspectFields function in Core/Ap4AvccAtom.cpp in Bento4 mp4dump before 1.5.0-616 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted mp4 file."}, {"lang": "es", "value": "La funci\u00f3n AP4_AvccAtom::InspectFields en Core/Ap4AvccAtom.cpp en Bento4 mp4dump en versiones anteriores a la 1.5.0-616 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (desreferencia de puntero NULL y bloqueo de aplicaci\u00f3n) mediante un archivo mp4 manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bento4:bento4:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.5.0-615", "matchCriteriaId": "03DB20DA-7153-4678-A2D6-01464B589FC8"}]}]}], "references": [{"url": "https://drive.google.com/open?id=0B6wBkDmxMGMKUjNscThnbTlSZ2s", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://drive.google.com/open?id=0B9DojFnTUSNGZ1JfNUc1am9pcnc", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/axiomatic-systems/Bento4/commit/4d3f0bebd5f8518fd775f671c12bea58c68e814e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/axiomatic-systems/Bento4/commit/4d3f0bebd5f8518fd775f671c12bea58c68e814e"}}