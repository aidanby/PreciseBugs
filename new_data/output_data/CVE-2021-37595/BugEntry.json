{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Windows Clipboard Redirection\n *\n * Copyright 2012 Jason Champion\n * Copyright 2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#define CINTERFACE\n#define COBJMACROS\n\n#include <ole2.h>\n#include <shlobj.h>\n#include <windows.h>\n#include <winuser.h>\n\n#include <winpr/assert.h>\n\n#include <winpr/crt.h>\n#include <winpr/tchar.h>\n#include <winpr/stream.h>\n\n#include <freerdp/log.h>\n#include <freerdp/client/cliprdr.h>\n\n#include <strsafe.h>\n\n#include \"wf_cliprdr.h\"\n\n#define TAG CLIENT_TAG(\"windows\")\n\n#ifdef WITH_DEBUG_CLIPRDR\n#define DEBUG_CLIPRDR(...) WLog_DBG(TAG, __VA_ARGS__)\n#else\n#define DEBUG_CLIPRDR(...) \\\n\tdo                     \\\n\t{                      \\\n\t} while (0)\n#endif\n\ntypedef BOOL(WINAPI* fnAddClipboardFormatListener)(HWND hwnd);\ntypedef BOOL(WINAPI* fnRemoveClipboardFormatListener)(HWND hwnd);\ntypedef BOOL(WINAPI* fnGetUpdatedClipboardFormats)(PUINT lpuiFormats, UINT cFormats,\n                                                   PUINT pcFormatsOut);\n\nstruct format_mapping\n{\n\tUINT32 remote_format_id;\n\tUINT32 local_format_id;\n\tWCHAR* name;\n};\ntypedef struct format_mapping formatMapping;\n\nstruct _CliprdrEnumFORMATETC\n{\n\tIEnumFORMATETC iEnumFORMATETC;\n\n\tLONG m_lRefCount;\n\tLONG m_nIndex;\n\tLONG m_nNumFormats;\n\tFORMATETC* m_pFormatEtc;\n};\ntypedef struct _CliprdrEnumFORMATETC CliprdrEnumFORMATETC;\n\nstruct _CliprdrStream\n{\n\tIStream iStream;\n\n\tLONG m_lRefCount;\n\tULONG m_lIndex;\n\tULARGE_INTEGER m_lSize;\n\tULARGE_INTEGER m_lOffset;\n\tFILEDESCRIPTORW m_Dsc;\n\tvoid* m_pData;\n};\ntypedef struct _CliprdrStream CliprdrStream;\n\nstruct _CliprdrDataObject\n{\n\tIDataObject iDataObject;\n\n\tLONG m_lRefCount;\n\tFORMATETC* m_pFormatEtc;\n\tSTGMEDIUM* m_pStgMedium;\n\tULONG m_nNumFormats;\n\tULONG m_nStreams;\n\tIStream** m_pStream;\n\tvoid* m_pData;\n};\ntypedef struct _CliprdrDataObject CliprdrDataObject;\n\nstruct wf_clipboard\n{\n\twfContext* wfc;\n\trdpChannels* channels;\n\tCliprdrClientContext* context;\n\n\tBOOL sync;\n\tUINT32 capabilities;\n\n\tsize_t map_size;\n\tsize_t map_capacity;\n\tformatMapping* format_mappings;\n\n\tUINT32 requestedFormatId;\n\n\tHWND hwnd;\n\tHANDLE hmem;\n\tHANDLE thread;\n\tHANDLE response_data_event;\n\n\tLPDATAOBJECT data_obj;\n\tULONG req_fsize;\n\tchar* req_fdata;\n\tHANDLE req_fevent;\n\n\tsize_t nFiles;\n\tsize_t file_array_size;\n\tWCHAR** file_names;\n\tFILEDESCRIPTORW** fileDescriptor;\n\n\tBOOL legacyApi;\n\tHMODULE hUser32;\n\tHWND hWndNextViewer;\n\tfnAddClipboardFormatListener AddClipboardFormatListener;\n\tfnRemoveClipboardFormatListener RemoveClipboardFormatListener;\n\tfnGetUpdatedClipboardFormats GetUpdatedClipboardFormats;\n};\ntypedef struct wf_clipboard wfClipboard;\n\n#define WM_CLIPRDR_MESSAGE (WM_USER + 156)\n#define OLE_SETCLIPBOARD 1\n\nstatic BOOL wf_create_file_obj(wfClipboard* cliprdrrdr, IDataObject** ppDataObject);\nstatic void wf_destroy_file_obj(IDataObject* instance);\nstatic UINT32 get_remote_format_id(wfClipboard* clipboard, UINT32 local_format);\nstatic UINT cliprdr_send_data_request(wfClipboard* clipboard, UINT32 format);\nstatic UINT cliprdr_send_lock(wfClipboard* clipboard);\nstatic UINT cliprdr_send_unlock(wfClipboard* clipboard);\nstatic UINT cliprdr_send_request_filecontents(wfClipboard* clipboard, const void* streamid,\n                                              ULONG index, UINT32 flag, DWORD positionhigh,\n                                              DWORD positionlow, ULONG request);\n\nstatic void CliprdrDataObject_Delete(CliprdrDataObject* instance);\n\nstatic CliprdrEnumFORMATETC* CliprdrEnumFORMATETC_New(ULONG nFormats, FORMATETC* pFormatEtc);\nstatic void CliprdrEnumFORMATETC_Delete(CliprdrEnumFORMATETC* instance);\n\nstatic void CliprdrStream_Delete(CliprdrStream* instance);\n\nstatic BOOL try_open_clipboard(HWND hwnd)\n{\n\tsize_t x;\n\tfor (x = 0; x < 10; x++)\n\t{\n\t\tif (OpenClipboard(hwnd))\n\t\t\treturn TRUE;\n\t\tSleep(10);\n\t}\n\treturn FALSE;\n}\n\n/**\n * IStream\n */\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_QueryInterface(IStream* This, REFIID riid,\n                                                              void** ppvObject)\n{\n\tif (IsEqualIID(riid, &IID_IStream) || IsEqualIID(riid, &IID_IUnknown))\n\t{\n\t\tIStream_AddRef(This);\n\t\t*ppvObject = This;\n\t\treturn S_OK;\n\t}\n\telse\n\t{\n\t\t*ppvObject = 0;\n\t\treturn E_NOINTERFACE;\n\t}\n}\n\nstatic ULONG STDMETHODCALLTYPE CliprdrStream_AddRef(IStream* This)\n{\n\tCliprdrStream* instance = (CliprdrStream*)This;\n\n\tif (!instance)\n\t\treturn 0;\n\n\treturn InterlockedIncrement(&instance->m_lRefCount);\n}\n\nstatic ULONG STDMETHODCALLTYPE CliprdrStream_Release(IStream* This)\n{\n\tLONG count;\n\tCliprdrStream* instance = (CliprdrStream*)This;\n\n\tif (!instance)\n\t\treturn 0;\n\n\tcount = InterlockedDecrement(&instance->m_lRefCount);\n\n\tif (count == 0)\n\t{\n\t\tCliprdrStream_Delete(instance);\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn count;\n\t}\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_Read(IStream* This, void* pv, ULONG cb,\n                                                    ULONG* pcbRead)\n{\n\tint ret;\n\tCliprdrStream* instance = (CliprdrStream*)This;\n\twfClipboard* clipboard;\n\n\tif (!pv || !pcbRead || !instance)\n\t\treturn E_INVALIDARG;\n\n\tclipboard = (wfClipboard*)instance->m_pData;\n\t*pcbRead = 0;\n\n\tif (instance->m_lOffset.QuadPart >= instance->m_lSize.QuadPart)\n\t\treturn S_FALSE;\n\n\tret = cliprdr_send_request_filecontents(clipboard, (void*)This, instance->m_lIndex,\n\t                                        FILECONTENTS_RANGE, instance->m_lOffset.HighPart,\n\t                                        instance->m_lOffset.LowPart, cb);\n\n\tif (ret < 0)\n\t\treturn E_FAIL;\n\n\tif (clipboard->req_fdata)\n\t{\n\t\tCopyMemory(pv, clipboard->req_fdata, clipboard->req_fsize);\n\t\tfree(clipboard->req_fdata);\n\t}\n\n\t*pcbRead = clipboard->req_fsize;\n\tinstance->m_lOffset.QuadPart += clipboard->req_fsize;\n\n\tif (clipboard->req_fsize < cb)\n\t\treturn S_FALSE;\n\n\treturn S_OK;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_Write(IStream* This, const void* pv, ULONG cb,\n                                                     ULONG* pcbWritten)\n{\n\t(void)This;\n\t(void)pv;\n\t(void)cb;\n\t(void)pcbWritten;\n\treturn STG_E_ACCESSDENIED;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_Seek(IStream* This, LARGE_INTEGER dlibMove,\n                                                    DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition)\n{\n\tULONGLONG newoffset;\n\tCliprdrStream* instance = (CliprdrStream*)This;\n\n\tif (!instance)\n\t\treturn E_INVALIDARG;\n\n\tnewoffset = instance->m_lOffset.QuadPart;\n\n\tswitch (dwOrigin)\n\t{\n\t\tcase STREAM_SEEK_SET:\n\t\t\tnewoffset = dlibMove.QuadPart;\n\t\t\tbreak;\n\n\t\tcase STREAM_SEEK_CUR:\n\t\t\tnewoffset += dlibMove.QuadPart;\n\t\t\tbreak;\n\n\t\tcase STREAM_SEEK_END:\n\t\t\tnewoffset = instance->m_lSize.QuadPart + dlibMove.QuadPart;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn E_INVALIDARG;\n\t}\n\n\tif (newoffset < 0 || newoffset >= instance->m_lSize.QuadPart)\n\t\treturn E_FAIL;\n\n\tinstance->m_lOffset.QuadPart = newoffset;\n\n\tif (plibNewPosition)\n\t\tplibNewPosition->QuadPart = instance->m_lOffset.QuadPart;\n\n\treturn S_OK;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_SetSize(IStream* This, ULARGE_INTEGER libNewSize)\n{\n\t(void)This;\n\t(void)libNewSize;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_CopyTo(IStream* This, IStream* pstm,\n                                                      ULARGE_INTEGER cb, ULARGE_INTEGER* pcbRead,\n                                                      ULARGE_INTEGER* pcbWritten)\n{\n\t(void)This;\n\t(void)pstm;\n\t(void)cb;\n\t(void)pcbRead;\n\t(void)pcbWritten;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_Commit(IStream* This, DWORD grfCommitFlags)\n{\n\t(void)This;\n\t(void)grfCommitFlags;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_Revert(IStream* This)\n{\n\t(void)This;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_LockRegion(IStream* This, ULARGE_INTEGER libOffset,\n                                                          ULARGE_INTEGER cb, DWORD dwLockType)\n{\n\t(void)This;\n\t(void)libOffset;\n\t(void)cb;\n\t(void)dwLockType;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_UnlockRegion(IStream* This, ULARGE_INTEGER libOffset,\n                                                            ULARGE_INTEGER cb, DWORD dwLockType)\n{\n\t(void)This;\n\t(void)libOffset;\n\t(void)cb;\n\t(void)dwLockType;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_Stat(IStream* This, STATSTG* pstatstg,\n                                                    DWORD grfStatFlag)\n{\n\tCliprdrStream* instance = (CliprdrStream*)This;\n\n\tif (!instance)\n\t\treturn E_INVALIDARG;\n\n\tif (pstatstg == NULL)\n\t\treturn STG_E_INVALIDPOINTER;\n\n\tZeroMemory(pstatstg, sizeof(STATSTG));\n\n\tswitch (grfStatFlag)\n\t{\n\t\tcase STATFLAG_DEFAULT:\n\t\t\treturn STG_E_INSUFFICIENTMEMORY;\n\n\t\tcase STATFLAG_NONAME:\n\t\t\tpstatstg->cbSize.QuadPart = instance->m_lSize.QuadPart;\n\t\t\tpstatstg->grfLocksSupported = LOCK_EXCLUSIVE;\n\t\t\tpstatstg->grfMode = GENERIC_READ;\n\t\t\tpstatstg->grfStateBits = 0;\n\t\t\tpstatstg->type = STGTY_STREAM;\n\t\t\tbreak;\n\n\t\tcase STATFLAG_NOOPEN:\n\t\t\treturn STG_E_INVALIDFLAG;\n\n\t\tdefault:\n\t\t\treturn STG_E_INVALIDFLAG;\n\t}\n\n\treturn S_OK;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_Clone(IStream* This, IStream** ppstm)\n{\n\t(void)This;\n\t(void)ppstm;\n\treturn E_NOTIMPL;\n}\n\nstatic CliprdrStream* CliprdrStream_New(ULONG index, void* pData, const FILEDESCRIPTORW* dsc)\n{\n\tIStream* iStream;\n\tBOOL success = FALSE;\n\tBOOL isDir = FALSE;\n\tCliprdrStream* instance;\n\twfClipboard* clipboard = (wfClipboard*)pData;\n\tinstance = (CliprdrStream*)calloc(1, sizeof(CliprdrStream));\n\n\tif (instance)\n\t{\n\t\tinstance->m_Dsc = *dsc;\n\t\tiStream = &instance->iStream;\n\t\tiStream->lpVtbl = (IStreamVtbl*)calloc(1, sizeof(IStreamVtbl));\n\n\t\tif (iStream->lpVtbl)\n\t\t{\n\t\t\tiStream->lpVtbl->QueryInterface = CliprdrStream_QueryInterface;\n\t\t\tiStream->lpVtbl->AddRef = CliprdrStream_AddRef;\n\t\t\tiStream->lpVtbl->Release = CliprdrStream_Release;\n\t\t\tiStream->lpVtbl->Read = CliprdrStream_Read;\n\t\t\tiStream->lpVtbl->Write = CliprdrStream_Write;\n\t\t\tiStream->lpVtbl->Seek = CliprdrStream_Seek;\n\t\t\tiStream->lpVtbl->SetSize = CliprdrStream_SetSize;\n\t\t\tiStream->lpVtbl->CopyTo = CliprdrStream_CopyTo;\n\t\t\tiStream->lpVtbl->Commit = CliprdrStream_Commit;\n\t\t\tiStream->lpVtbl->Revert = CliprdrStream_Revert;\n\t\t\tiStream->lpVtbl->LockRegion = CliprdrStream_LockRegion;\n\t\t\tiStream->lpVtbl->UnlockRegion = CliprdrStream_UnlockRegion;\n\t\t\tiStream->lpVtbl->Stat = CliprdrStream_Stat;\n\t\t\tiStream->lpVtbl->Clone = CliprdrStream_Clone;\n\t\t\tinstance->m_lRefCount = 1;\n\t\t\tinstance->m_lIndex = index;\n\t\t\tinstance->m_pData = pData;\n\t\t\tinstance->m_lOffset.QuadPart = 0;\n\n\t\t\tif (instance->m_Dsc.dwFlags & FD_ATTRIBUTES)\n\t\t\t{\n\t\t\t\tif (instance->m_Dsc.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n\t\t\t\t\tisDir = TRUE;\n\t\t\t}\n\n\t\t\tif (((instance->m_Dsc.dwFlags & FD_FILESIZE) == 0) && !isDir)\n\t\t\t{\n\t\t\t\t/* get content size of this stream */\n\t\t\t\tif (cliprdr_send_request_filecontents(clipboard, (void*)instance,\n\t\t\t\t                                      instance->m_lIndex, FILECONTENTS_SIZE, 0, 0,\n\t\t\t\t                                      8) == CHANNEL_RC_OK)\n\t\t\t\t{\n\t\t\t\t\tsuccess = TRUE;\n\t\t\t\t}\n\n\t\t\t\tinstance->m_lSize.QuadPart = *((LONGLONG*)clipboard->req_fdata);\n\t\t\t\tfree(clipboard->req_fdata);\n\t\t\t}\n\t\t\telse\n\t\t\t\tsuccess = TRUE;\n\t\t}\n\t}\n\n\tif (!success)\n\t{\n\t\tCliprdrStream_Delete(instance);\n\t\tinstance = NULL;\n\t}\n\n\treturn instance;\n}\n\nvoid CliprdrStream_Delete(CliprdrStream* instance)\n{\n\tif (instance)\n\t{\n\t\tfree(instance->iStream.lpVtbl);\n\t\tfree(instance);\n\t}\n}\n\n/**\n * IDataObject\n */\n\nstatic LONG cliprdr_lookup_format(CliprdrDataObject* instance, FORMATETC* pFormatEtc)\n{\n\tULONG i;\n\n\tif (!instance || !pFormatEtc)\n\t\treturn -1;\n\n\tfor (i = 0; i < instance->m_nNumFormats; i++)\n\t{\n\t\tif ((pFormatEtc->tymed & instance->m_pFormatEtc[i].tymed) &&\n\t\t    pFormatEtc->cfFormat == instance->m_pFormatEtc[i].cfFormat &&\n\t\t    pFormatEtc->dwAspect & instance->m_pFormatEtc[i].dwAspect)\n\t\t{\n\t\t\treturn (LONG)i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_QueryInterface(IDataObject* This, REFIID riid,\n                                                                  void** ppvObject)\n{\n\t(void)This;\n\n\tif (!ppvObject)\n\t\treturn E_INVALIDARG;\n\n\tif (IsEqualIID(riid, &IID_IDataObject) || IsEqualIID(riid, &IID_IUnknown))\n\t{\n\t\tIDataObject_AddRef(This);\n\t\t*ppvObject = This;\n\t\treturn S_OK;\n\t}\n\telse\n\t{\n\t\t*ppvObject = 0;\n\t\treturn E_NOINTERFACE;\n\t}\n}\n\nstatic ULONG STDMETHODCALLTYPE CliprdrDataObject_AddRef(IDataObject* This)\n{\n\tCliprdrDataObject* instance = (CliprdrDataObject*)This;\n\n\tif (!instance)\n\t\treturn E_INVALIDARG;\n\n\treturn InterlockedIncrement(&instance->m_lRefCount);\n}\n\nstatic ULONG STDMETHODCALLTYPE CliprdrDataObject_Release(IDataObject* This)\n{\n\tLONG count;\n\tCliprdrDataObject* instance = (CliprdrDataObject*)This;\n\n\tif (!instance)\n\t\treturn E_INVALIDARG;\n\n\tcount = InterlockedDecrement(&instance->m_lRefCount);\n\n\tif (count == 0)\n\t{\n\t\tCliprdrDataObject_Delete(instance);\n\t\treturn 0;\n\t}\n\telse\n\t\treturn count;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_GetData(IDataObject* This, FORMATETC* pFormatEtc,\n                                                           STGMEDIUM* pMedium)\n{\n\tULONG i;\n\tLONG idx;\n\tCliprdrDataObject* instance = (CliprdrDataObject*)This;\n\twfClipboard* clipboard;\n\n\tif (!pFormatEtc || !pMedium || !instance)\n\t\treturn E_INVALIDARG;\n\n\tclipboard = (wfClipboard*)instance->m_pData;\n\n\tif (!clipboard)\n\t\treturn E_INVALIDARG;\n\n\tif ((idx = cliprdr_lookup_format(instance, pFormatEtc)) == -1)\n\t\treturn DV_E_FORMATETC;\n\n\tpMedium->tymed = instance->m_pFormatEtc[idx].tymed;\n\tpMedium->pUnkForRelease = 0;\n\n\tif (instance->m_pFormatEtc[idx].cfFormat == RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW))\n\t{\n\t\tFILEGROUPDESCRIPTOR* dsc;\n\t\tDWORD remote = get_remote_format_id(clipboard, instance->m_pFormatEtc[idx].cfFormat);\n\n\t\tif (cliprdr_send_data_request(clipboard, remote) != 0)\n\t\t\treturn E_UNEXPECTED;\n\n\t\tpMedium->hGlobal = clipboard->hmem; /* points to a FILEGROUPDESCRIPTOR structure */\n\t\t/* GlobalLock returns a pointer to the first byte of the memory block,\n\t\t * in which is a FILEGROUPDESCRIPTOR structure, whose first UINT member\n\t\t * is the number of FILEDESCRIPTOR's */\n\t\tdsc = (FILEGROUPDESCRIPTOR*)GlobalLock(clipboard->hmem);\n\t\tinstance->m_nStreams = dsc->cItems;\n\t\tGlobalUnlock(clipboard->hmem);\n\n\t\tif (instance->m_nStreams > 0)\n\t\t{\n\t\t\tif (!instance->m_pStream)\n\t\t\t{\n\t\t\t\tinstance->m_pStream = (LPSTREAM*)calloc(instance->m_nStreams, sizeof(LPSTREAM));\n\n\t\t\t\tif (instance->m_pStream)\n\t\t\t\t{\n\t\t\t\t\tfor (i = 0; i < instance->m_nStreams; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tinstance->m_pStream[i] =\n\t\t\t\t\t\t    (IStream*)CliprdrStream_New(i, clipboard, &dsc->fgd[i]);\n\n\t\t\t\t\t\tif (!instance->m_pStream[i])\n\t\t\t\t\t\t\treturn E_OUTOFMEMORY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!instance->m_pStream)\n\t\t{\n\t\t\tif (clipboard->hmem)\n\t\t\t{\n\t\t\t\tGlobalFree(clipboard->hmem);\n\t\t\t\tclipboard->hmem = NULL;\n\t\t\t}\n\n\t\t\tpMedium->hGlobal = NULL;\n\t\t\treturn E_OUTOFMEMORY;\n\t\t}\n\t}\n\telse if (instance->m_pFormatEtc[idx].cfFormat == RegisterClipboardFormat(CFSTR_FILECONTENTS))\n\t{\n\t\tif ((pFormatEtc->lindex >= 0) && ((ULONG)pFormatEtc->lindex < instance->m_nStreams))\n\t\t{\n\t\t\tpMedium->pstm = instance->m_pStream[pFormatEtc->lindex];\n\t\t\tIDataObject_AddRef(instance->m_pStream[pFormatEtc->lindex]);\n\t\t}\n\t\telse\n\t\t\treturn E_INVALIDARG;\n\t}\n\telse\n\t\treturn E_UNEXPECTED;\n\n\treturn S_OK;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_GetDataHere(IDataObject* This,\n                                                               FORMATETC* pformatetc,\n                                                               STGMEDIUM* pmedium)\n{\n\t(void)This;\n\t(void)pformatetc;\n\t(void)pmedium;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_QueryGetData(IDataObject* This,\n                                                                FORMATETC* pformatetc)\n{\n\tCliprdrDataObject* instance = (CliprdrDataObject*)This;\n\n\tif (!pformatetc)\n\t\treturn E_INVALIDARG;\n\n\tif (cliprdr_lookup_format(instance, pformatetc) == -1)\n\t\treturn DV_E_FORMATETC;\n\n\treturn S_OK;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_GetCanonicalFormatEtc(IDataObject* This,\n                                                                         FORMATETC* pformatectIn,\n                                                                         FORMATETC* pformatetcOut)\n{\n\t(void)This;\n\t(void)pformatectIn;\n\n\tif (!pformatetcOut)\n\t\treturn E_INVALIDARG;\n\n\tpformatetcOut->ptd = NULL;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_SetData(IDataObject* This, FORMATETC* pformatetc,\n                                                           STGMEDIUM* pmedium, BOOL fRelease)\n{\n\t(void)This;\n\t(void)pformatetc;\n\t(void)pmedium;\n\t(void)fRelease;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_EnumFormatEtc(IDataObject* This,\n                                                                 DWORD dwDirection,\n                                                                 IEnumFORMATETC** ppenumFormatEtc)\n{\n\tCliprdrDataObject* instance = (CliprdrDataObject*)This;\n\n\tif (!instance || !ppenumFormatEtc)\n\t\treturn E_INVALIDARG;\n\n\tif (dwDirection == DATADIR_GET)\n\t{\n\t\t*ppenumFormatEtc = (IEnumFORMATETC*)CliprdrEnumFORMATETC_New(instance->m_nNumFormats,\n\t\t                                                             instance->m_pFormatEtc);\n\t\treturn (*ppenumFormatEtc) ? S_OK : E_OUTOFMEMORY;\n\t}\n\telse\n\t{\n\t\treturn E_NOTIMPL;\n\t}\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_DAdvise(IDataObject* This, FORMATETC* pformatetc,\n                                                           DWORD advf, IAdviseSink* pAdvSink,\n                                                           DWORD* pdwConnection)\n{\n\t(void)This;\n\t(void)pformatetc;\n\t(void)advf;\n\t(void)pAdvSink;\n\t(void)pdwConnection;\n\treturn OLE_E_ADVISENOTSUPPORTED;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_DUnadvise(IDataObject* This, DWORD dwConnection)\n{\n\t(void)This;\n\t(void)dwConnection;\n\treturn OLE_E_ADVISENOTSUPPORTED;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_EnumDAdvise(IDataObject* This,\n                                                               IEnumSTATDATA** ppenumAdvise)\n{\n\t(void)This;\n\t(void)ppenumAdvise;\n\treturn OLE_E_ADVISENOTSUPPORTED;\n}\n\nstatic CliprdrDataObject* CliprdrDataObject_New(FORMATETC* fmtetc, STGMEDIUM* stgmed, ULONG count,\n                                                void* data)\n{\n\tCliprdrDataObject* instance;\n\tIDataObject* iDataObject;\n\tinstance = (CliprdrDataObject*)calloc(1, sizeof(CliprdrDataObject));\n\n\tif (!instance)\n\t\tgoto error;\n\n\tiDataObject = &instance->iDataObject;\n\tiDataObject->lpVtbl = (IDataObjectVtbl*)calloc(1, sizeof(IDataObjectVtbl));\n\n\tif (!iDataObject->lpVtbl)\n\t\tgoto error;\n\n\tiDataObject->lpVtbl->QueryInterface = CliprdrDataObject_QueryInterface;\n\tiDataObject->lpVtbl->AddRef = CliprdrDataObject_AddRef;\n\tiDataObject->lpVtbl->Release = CliprdrDataObject_Release;\n\tiDataObject->lpVtbl->GetData = CliprdrDataObject_GetData;\n\tiDataObject->lpVtbl->GetDataHere = CliprdrDataObject_GetDataHere;\n\tiDataObject->lpVtbl->QueryGetData = CliprdrDataObject_QueryGetData;\n\tiDataObject->lpVtbl->GetCanonicalFormatEtc = CliprdrDataObject_GetCanonicalFormatEtc;\n\tiDataObject->lpVtbl->SetData = CliprdrDataObject_SetData;\n\tiDataObject->lpVtbl->EnumFormatEtc = CliprdrDataObject_EnumFormatEtc;\n\tiDataObject->lpVtbl->DAdvise = CliprdrDataObject_DAdvise;\n\tiDataObject->lpVtbl->DUnadvise = CliprdrDataObject_DUnadvise;\n\tiDataObject->lpVtbl->EnumDAdvise = CliprdrDataObject_EnumDAdvise;\n\tinstance->m_lRefCount = 1;\n\tinstance->m_nNumFormats = count;\n\tinstance->m_pData = data;\n\tinstance->m_nStreams = 0;\n\tinstance->m_pStream = NULL;\n\n\tif (count > 0)\n\t{\n\t\tULONG i;\n\t\tinstance->m_pFormatEtc = (FORMATETC*)calloc(count, sizeof(FORMATETC));\n\n\t\tif (!instance->m_pFormatEtc)\n\t\t\tgoto error;\n\n\t\tinstance->m_pStgMedium = (STGMEDIUM*)calloc(count, sizeof(STGMEDIUM));\n\n\t\tif (!instance->m_pStgMedium)\n\t\t\tgoto error;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tinstance->m_pFormatEtc[i] = fmtetc[i];\n\t\t\tinstance->m_pStgMedium[i] = stgmed[i];\n\t\t}\n\t}\n\n\treturn instance;\nerror:\n\tCliprdrDataObject_Delete(instance);\n\treturn NULL;\n}\n\nvoid CliprdrDataObject_Delete(CliprdrDataObject* instance)\n{\n\tif (instance)\n\t{\n\t\tfree(instance->iDataObject.lpVtbl);\n\t\tfree(instance->m_pFormatEtc);\n\t\tfree(instance->m_pStgMedium);\n\n\t\tif (instance->m_pStream)\n\t\t{\n\t\t\tULONG i;\n\n\t\t\tfor (i = 0; i < instance->m_nStreams; i++)\n\t\t\t\tCliprdrStream_Release(instance->m_pStream[i]);\n\n\t\t\tfree(instance->m_pStream);\n\t\t}\n\n\t\tfree(instance);\n\t}\n}\n\nstatic BOOL wf_create_file_obj(wfClipboard* clipboard, IDataObject** ppDataObject)\n{\n\tFORMATETC fmtetc[2];\n\tSTGMEDIUM stgmeds[2];\n\n\tif (!ppDataObject)\n\t\treturn FALSE;\n\n\tfmtetc[0].cfFormat = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);\n\tfmtetc[0].dwAspect = DVASPECT_CONTENT;\n\tfmtetc[0].lindex = 0;\n\tfmtetc[0].ptd = NULL;\n\tfmtetc[0].tymed = TYMED_HGLOBAL;\n\tstgmeds[0].tymed = TYMED_HGLOBAL;\n\tstgmeds[0].hGlobal = NULL;\n\tstgmeds[0].pUnkForRelease = NULL;\n\tfmtetc[1].cfFormat = RegisterClipboardFormat(CFSTR_FILECONTENTS);\n\tfmtetc[1].dwAspect = DVASPECT_CONTENT;\n\tfmtetc[1].lindex = 0;\n\tfmtetc[1].ptd = NULL;\n\tfmtetc[1].tymed = TYMED_ISTREAM;\n\tstgmeds[1].tymed = TYMED_ISTREAM;\n\tstgmeds[1].pstm = NULL;\n\tstgmeds[1].pUnkForRelease = NULL;\n\t*ppDataObject = (IDataObject*)CliprdrDataObject_New(fmtetc, stgmeds, 2, clipboard);\n\treturn (*ppDataObject) ? TRUE : FALSE;\n}\n\nstatic void wf_destroy_file_obj(IDataObject* instance)\n{\n\tif (instance)\n\t\tIDataObject_Release(instance);\n}\n\n/**\n * IEnumFORMATETC\n */\n\nstatic void cliprdr_format_deep_copy(FORMATETC* dest, FORMATETC* source)\n{\n\t*dest = *source;\n\n\tif (source->ptd)\n\t{\n\t\tdest->ptd = (DVTARGETDEVICE*)CoTaskMemAlloc(sizeof(DVTARGETDEVICE));\n\n\t\tif (dest->ptd)\n\t\t\t*(dest->ptd) = *(source->ptd);\n\t}\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrEnumFORMATETC_QueryInterface(IEnumFORMATETC* This,\n                                                                     REFIID riid, void** ppvObject)\n{\n\t(void)This;\n\n\tif (IsEqualIID(riid, &IID_IEnumFORMATETC) || IsEqualIID(riid, &IID_IUnknown))\n\t{\n\t\tIEnumFORMATETC_AddRef(This);\n\t\t*ppvObject = This;\n\t\treturn S_OK;\n\t}\n\telse\n\t{\n\t\t*ppvObject = 0;\n\t\treturn E_NOINTERFACE;\n\t}\n}\n\nstatic ULONG STDMETHODCALLTYPE CliprdrEnumFORMATETC_AddRef(IEnumFORMATETC* This)\n{\n\tCliprdrEnumFORMATETC* instance = (CliprdrEnumFORMATETC*)This;\n\n\tif (!instance)\n\t\treturn 0;\n\n\treturn InterlockedIncrement(&instance->m_lRefCount);\n}\n\nstatic ULONG STDMETHODCALLTYPE CliprdrEnumFORMATETC_Release(IEnumFORMATETC* This)\n{\n\tLONG count;\n\tCliprdrEnumFORMATETC* instance = (CliprdrEnumFORMATETC*)This;\n\n\tif (!instance)\n\t\treturn 0;\n\n\tcount = InterlockedDecrement(&instance->m_lRefCount);\n\n\tif (count == 0)\n\t{\n\t\tCliprdrEnumFORMATETC_Delete(instance);\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn count;\n\t}\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrEnumFORMATETC_Next(IEnumFORMATETC* This, ULONG celt,\n                                                           FORMATETC* rgelt, ULONG* pceltFetched)\n{\n\tULONG copied = 0;\n\tCliprdrEnumFORMATETC* instance = (CliprdrEnumFORMATETC*)This;\n\n\tif (!instance || !celt || !rgelt)\n\t\treturn E_INVALIDARG;\n\n\twhile ((instance->m_nIndex < instance->m_nNumFormats) && (copied < celt))\n\t{\n\t\tcliprdr_format_deep_copy(&rgelt[copied++], &instance->m_pFormatEtc[instance->m_nIndex++]);\n\t}\n\n\tif (pceltFetched != 0)\n\t\t*pceltFetched = copied;\n\n\treturn (copied == celt) ? S_OK : E_FAIL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrEnumFORMATETC_Skip(IEnumFORMATETC* This, ULONG celt)\n{\n\tCliprdrEnumFORMATETC* instance = (CliprdrEnumFORMATETC*)This;\n\n\tif (!instance)\n\t\treturn E_INVALIDARG;\n\n\tif (instance->m_nIndex + (LONG)celt > instance->m_nNumFormats)\n\t\treturn E_FAIL;\n\n\tinstance->m_nIndex += celt;\n\treturn S_OK;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrEnumFORMATETC_Reset(IEnumFORMATETC* This)\n{\n\tCliprdrEnumFORMATETC* instance = (CliprdrEnumFORMATETC*)This;\n\n\tif (!instance)\n\t\treturn E_INVALIDARG;\n\n\tinstance->m_nIndex = 0;\n\treturn S_OK;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrEnumFORMATETC_Clone(IEnumFORMATETC* This,\n                                                            IEnumFORMATETC** ppEnum)\n{\n\tCliprdrEnumFORMATETC* instance = (CliprdrEnumFORMATETC*)This;\n\n\tif (!instance || !ppEnum)\n\t\treturn E_INVALIDARG;\n\n\t*ppEnum =\n\t    (IEnumFORMATETC*)CliprdrEnumFORMATETC_New(instance->m_nNumFormats, instance->m_pFormatEtc);\n\n\tif (!*ppEnum)\n\t\treturn E_OUTOFMEMORY;\n\n\t((CliprdrEnumFORMATETC*)*ppEnum)->m_nIndex = instance->m_nIndex;\n\treturn S_OK;\n}\n\nCliprdrEnumFORMATETC* CliprdrEnumFORMATETC_New(ULONG nFormats, FORMATETC* pFormatEtc)\n{\n\tULONG i;\n\tCliprdrEnumFORMATETC* instance;\n\tIEnumFORMATETC* iEnumFORMATETC;\n\n\tif ((nFormats != 0) && !pFormatEtc)\n\t\treturn NULL;\n\n\tinstance = (CliprdrEnumFORMATETC*)calloc(1, sizeof(CliprdrEnumFORMATETC));\n\n\tif (!instance)\n\t\tgoto error;\n\n\tiEnumFORMATETC = &instance->iEnumFORMATETC;\n\tiEnumFORMATETC->lpVtbl = (IEnumFORMATETCVtbl*)calloc(1, sizeof(IEnumFORMATETCVtbl));\n\n\tif (!iEnumFORMATETC->lpVtbl)\n\t\tgoto error;\n\n\tiEnumFORMATETC->lpVtbl->QueryInterface = CliprdrEnumFORMATETC_QueryInterface;\n\tiEnumFORMATETC->lpVtbl->AddRef = CliprdrEnumFORMATETC_AddRef;\n\tiEnumFORMATETC->lpVtbl->Release = CliprdrEnumFORMATETC_Release;\n\tiEnumFORMATETC->lpVtbl->Next = CliprdrEnumFORMATETC_Next;\n\tiEnumFORMATETC->lpVtbl->Skip = CliprdrEnumFORMATETC_Skip;\n\tiEnumFORMATETC->lpVtbl->Reset = CliprdrEnumFORMATETC_Reset;\n\tiEnumFORMATETC->lpVtbl->Clone = CliprdrEnumFORMATETC_Clone;\n\tinstance->m_lRefCount = 1;\n\tinstance->m_nIndex = 0;\n\tinstance->m_nNumFormats = nFormats;\n\n\tif (nFormats > 0)\n\t{\n\t\tinstance->m_pFormatEtc = (FORMATETC*)calloc(nFormats, sizeof(FORMATETC));\n\n\t\tif (!instance->m_pFormatEtc)\n\t\t\tgoto error;\n\n\t\tfor (i = 0; i < nFormats; i++)\n\t\t\tcliprdr_format_deep_copy(&instance->m_pFormatEtc[i], &pFormatEtc[i]);\n\t}\n\n\treturn instance;\nerror:\n\tCliprdrEnumFORMATETC_Delete(instance);\n\treturn NULL;\n}\n\nvoid CliprdrEnumFORMATETC_Delete(CliprdrEnumFORMATETC* instance)\n{\n\tLONG i;\n\n\tif (instance)\n\t{\n\t\tfree(instance->iEnumFORMATETC.lpVtbl);\n\n\t\tif (instance->m_pFormatEtc)\n\t\t{\n\t\t\tfor (i = 0; i < instance->m_nNumFormats; i++)\n\t\t\t{\n\t\t\t\tif (instance->m_pFormatEtc[i].ptd)\n\t\t\t\t\tCoTaskMemFree(instance->m_pFormatEtc[i].ptd);\n\t\t\t}\n\n\t\t\tfree(instance->m_pFormatEtc);\n\t\t}\n\n\t\tfree(instance);\n\t}\n}\n\n/***********************************************************************************/\n\nstatic UINT32 get_local_format_id_by_name(wfClipboard* clipboard, const TCHAR* format_name)\n{\n\tsize_t i;\n\tformatMapping* map;\n\tWCHAR* unicode_name;\n#if !defined(UNICODE)\n\tsize_t size;\n#endif\n\n\tif (!clipboard || !format_name)\n\t\treturn 0;\n\n#if defined(UNICODE)\n\tunicode_name = _wcsdup(format_name);\n#else\n\tsize = _tcslen(format_name);\n\tunicode_name = calloc(size + 1, sizeof(WCHAR));\n\n\tif (!unicode_name)\n\t\treturn 0;\n\n\tMultiByteToWideChar(CP_OEMCP, 0, format_name, strlen(format_name), unicode_name, size);\n#endif\n\n\tif (!unicode_name)\n\t\treturn 0;\n\n\tfor (i = 0; i < clipboard->map_size; i++)\n\t{\n\t\tmap = &clipboard->format_mappings[i];\n\n\t\tif (map->name)\n\t\t{\n\t\t\tif (wcscmp(map->name, unicode_name) == 0)\n\t\t\t{\n\t\t\t\tfree(unicode_name);\n\t\t\t\treturn map->local_format_id;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(unicode_name);\n\treturn 0;\n}\n\nstatic INLINE BOOL file_transferring(wfClipboard* clipboard)\n{\n\treturn get_local_format_id_by_name(clipboard, CFSTR_FILEDESCRIPTORW) ? TRUE : FALSE;\n}\n\nstatic UINT32 get_remote_format_id(wfClipboard* clipboard, UINT32 local_format)\n{\n\tUINT32 i;\n\tformatMapping* map;\n\n\tif (!clipboard)\n\t\treturn 0;\n\n\tfor (i = 0; i < clipboard->map_size; i++)\n\t{\n\t\tmap = &clipboard->format_mappings[i];\n\n\t\tif (map->local_format_id == local_format)\n\t\t\treturn map->remote_format_id;\n\t}\n\n\treturn local_format;\n}\n\nstatic void map_ensure_capacity(wfClipboard* clipboard)\n{\n\tif (!clipboard)\n\t\treturn;\n\n\tif (clipboard->map_size >= clipboard->map_capacity)\n\t{\n\t\tsize_t new_size;\n\t\tformatMapping* new_map;\n\t\tnew_size = clipboard->map_capacity * 2;\n\t\tnew_map =\n\t\t    (formatMapping*)realloc(clipboard->format_mappings, sizeof(formatMapping) * new_size);\n\n\t\tif (!new_map)\n\t\t\treturn;\n\n\t\tclipboard->format_mappings = new_map;\n\t\tclipboard->map_capacity = new_size;\n\t}\n}\n\nstatic BOOL clear_format_map(wfClipboard* clipboard)\n{\n\tsize_t i;\n\tformatMapping* map;\n\n\tif (!clipboard)\n\t\treturn FALSE;\n\n\tif (clipboard->format_mappings)\n\t{\n\t\tfor (i = 0; i < clipboard->map_capacity; i++)\n\t\t{\n\t\t\tmap = &clipboard->format_mappings[i];\n\t\t\tmap->remote_format_id = 0;\n\t\t\tmap->local_format_id = 0;\n\t\t\tfree(map->name);\n\t\t\tmap->name = NULL;\n\t\t}\n\t}\n\n\tclipboard->map_size = 0;\n\treturn TRUE;\n}\n\nstatic UINT cliprdr_send_tempdir(wfClipboard* clipboard)\n{\n\tCLIPRDR_TEMP_DIRECTORY tempDirectory;\n\n\tif (!clipboard)\n\t\treturn -1;\n\n\tif (GetEnvironmentVariableA(\"TEMP\", tempDirectory.szTempDir, sizeof(tempDirectory.szTempDir)) ==\n\t    0)\n\t\treturn -1;\n\n\treturn clipboard->context->TempDirectory(clipboard->context, &tempDirectory);\n}\n\nstatic BOOL cliprdr_GetUpdatedClipboardFormats(wfClipboard* clipboard, PUINT lpuiFormats,\n                                               UINT cFormats, PUINT pcFormatsOut)\n{\n\tUINT index = 0;\n\tUINT format = 0;\n\tBOOL clipboardOpen = FALSE;\n\n\tif (!clipboard->legacyApi)\n\t\treturn clipboard->GetUpdatedClipboardFormats(lpuiFormats, cFormats, pcFormatsOut);\n\n\tclipboardOpen = try_open_clipboard(clipboard->hwnd);\n\n\tif (!clipboardOpen)\n\t{\n\t\t*pcFormatsOut = 0;\n\t\treturn TRUE; /* Other app holding clipboard */\n\t}\n\n\twhile (index < cFormats)\n\t{\n\t\tformat = EnumClipboardFormats(format);\n\n\t\tif (!format)\n\t\t\tbreak;\n\n\t\tlpuiFormats[index] = format;\n\t\tindex++;\n\t}\n\n\t*pcFormatsOut = index;\n\tCloseClipboard();\n\treturn TRUE;\n}\n\nstatic UINT cliprdr_send_format_list(wfClipboard* clipboard)\n{\n\tUINT rc;\n\tint count = 0;\n\tUINT32 index;\n\tUINT32 numFormats = 0;\n\tUINT32 formatId = 0;\n\tchar formatName[1024];\n\tCLIPRDR_FORMAT* formats = NULL;\n\tCLIPRDR_FORMAT_LIST formatList = { 0 };\n\n\tif (!clipboard)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tZeroMemory(&formatList, sizeof(CLIPRDR_FORMAT_LIST));\n\n\t/* Ignore if other app is holding clipboard */\n\tif (try_open_clipboard(clipboard->hwnd))\n\t{\n\t\tcount = CountClipboardFormats();\n\t\tnumFormats = (UINT32)count;\n\t\tformats = (CLIPRDR_FORMAT*)calloc(numFormats, sizeof(CLIPRDR_FORMAT));\n\n\t\tif (!formats)\n\t\t{\n\t\t\tCloseClipboard();\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tindex = 0;\n\n\t\tif (IsClipboardFormatAvailable(CF_HDROP))\n\t\t{\n\t\t\tformats[index++].formatId = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);\n\t\t\tformats[index++].formatId = RegisterClipboardFormat(CFSTR_FILECONTENTS);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (formatId = EnumClipboardFormats(formatId))\n\t\t\t\tformats[index++].formatId = formatId;\n\t\t}\n\n\t\tnumFormats = index;\n\n\t\tif (!CloseClipboard())\n\t\t{\n\t\t\tfree(formats);\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t}\n\n\t\tfor (index = 0; index < numFormats; index++)\n\t\t{\n\t\t\tif (GetClipboardFormatNameA(formats[index].formatId, formatName, sizeof(formatName)))\n\t\t\t{\n\t\t\t\tformats[index].formatName = _strdup(formatName);\n\t\t\t}\n\t\t}\n\t}\n\n\tformatList.numFormats = numFormats;\n\tformatList.formats = formats;\n\tformatList.msgType = CB_FORMAT_LIST;\n\trc = clipboard->context->ClientFormatList(clipboard->context, &formatList);\n\n\tfor (index = 0; index < numFormats; index++)\n\t\tfree(formats[index].formatName);\n\n\tfree(formats);\n\treturn rc;\n}\n\nstatic UINT cliprdr_send_data_request(wfClipboard* clipboard, UINT32 formatId)\n{\n\tUINT rc;\n\tUINT32 remoteFormatId;\n\tCLIPRDR_FORMAT_DATA_REQUEST formatDataRequest;\n\n\tif (!clipboard || !clipboard->context || !clipboard->context->ClientFormatDataRequest)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tremoteFormatId = get_remote_format_id(clipboard, formatId);\n\n\tformatDataRequest.requestedFormatId = remoteFormatId;\n\tclipboard->requestedFormatId = formatId;\n\trc = clipboard->context->ClientFormatDataRequest(clipboard->context, &formatDataRequest);\n\n\tif (WaitForSingleObject(clipboard->response_data_event, INFINITE) != WAIT_OBJECT_0)\n\t\trc = ERROR_INTERNAL_ERROR;\n\telse if (!ResetEvent(clipboard->response_data_event))\n\t\trc = ERROR_INTERNAL_ERROR;\n\n\treturn rc;\n}\n\nUINT cliprdr_send_request_filecontents(wfClipboard* clipboard, const void* streamid, ULONG index,\n                                       UINT32 flag, DWORD positionhigh, DWORD positionlow,\n                                       ULONG nreq)\n{\n\tUINT rc;\n\tCLIPRDR_FILE_CONTENTS_REQUEST fileContentsRequest;\n\n\tif (!clipboard || !clipboard->context || !clipboard->context->ClientFileContentsRequest)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tfileContentsRequest.streamId = (UINT32)(ULONG_PTR)streamid;\n\tfileContentsRequest.listIndex = index;\n\tfileContentsRequest.dwFlags = flag;\n\tfileContentsRequest.nPositionLow = positionlow;\n\tfileContentsRequest.nPositionHigh = positionhigh;\n\tfileContentsRequest.cbRequested = nreq;\n\tfileContentsRequest.clipDataId = 0;\n\tfileContentsRequest.msgFlags = 0;\n\trc = clipboard->context->ClientFileContentsRequest(clipboard->context, &fileContentsRequest);\n\n\tif (WaitForSingleObject(clipboard->req_fevent, INFINITE) != WAIT_OBJECT_0)\n\t\trc = ERROR_INTERNAL_ERROR;\n\telse if (!ResetEvent(clipboard->req_fevent))\n\t\trc = ERROR_INTERNAL_ERROR;\n\n\treturn rc;\n}\n\nstatic UINT cliprdr_send_response_filecontents(wfClipboard* clipboard, UINT32 streamId, UINT32 size,\n                                               BYTE* data)\n{\n\tCLIPRDR_FILE_CONTENTS_RESPONSE fileContentsResponse;\n\n\tif (!clipboard || !clipboard->context || !clipboard->context->ClientFileContentsResponse)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tfileContentsResponse.streamId = streamId;\n\tfileContentsResponse.cbRequested = size;\n\tfileContentsResponse.requestedData = data;\n\tfileContentsResponse.msgFlags = CB_RESPONSE_OK;\n\treturn clipboard->context->ClientFileContentsResponse(clipboard->context,\n\t                                                      &fileContentsResponse);\n}\n\nstatic LRESULT CALLBACK cliprdr_proc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)\n{\n\tstatic wfClipboard* clipboard = NULL;\n\n\tswitch (Msg)\n\t{\n\t\tcase WM_CREATE:\n\t\t\tDEBUG_CLIPRDR(\"info: WM_CREATE\");\n\t\t\tclipboard = (wfClipboard*)((CREATESTRUCT*)lParam)->lpCreateParams;\n\t\t\tclipboard->hwnd = hWnd;\n\n\t\t\tif (!clipboard->legacyApi)\n\t\t\t\tclipboard->AddClipboardFormatListener(hWnd);\n\t\t\telse\n\t\t\t\tclipboard->hWndNextViewer = SetClipboardViewer(hWnd);\n\n\t\t\tbreak;\n\n\t\tcase WM_CLOSE:\n\t\t\tDEBUG_CLIPRDR(\"info: WM_CLOSE\");\n\n\t\t\tif (!clipboard->legacyApi)\n\t\t\t\tclipboard->RemoveClipboardFormatListener(hWnd);\n\n\t\t\tbreak;\n\n\t\tcase WM_DESTROY:\n\t\t\tif (clipboard->legacyApi)\n\t\t\t\tChangeClipboardChain(hWnd, clipboard->hWndNextViewer);\n\n\t\t\tbreak;\n\n\t\tcase WM_CLIPBOARDUPDATE:\n\t\t\tDEBUG_CLIPRDR(\"info: WM_CLIPBOARDUPDATE\");\n\n\t\t\tif (clipboard->sync)\n\t\t\t{\n\t\t\t\tif ((GetClipboardOwner() != clipboard->hwnd) &&\n\t\t\t\t    (S_FALSE == OleIsCurrentClipboard(clipboard->data_obj)))\n\t\t\t\t{\n\t\t\t\t\tif (clipboard->hmem)\n\t\t\t\t\t{\n\t\t\t\t\t\tGlobalFree(clipboard->hmem);\n\t\t\t\t\t\tclipboard->hmem = NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tcliprdr_send_format_list(clipboard);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase WM_RENDERALLFORMATS:\n\t\t\tDEBUG_CLIPRDR(\"info: WM_RENDERALLFORMATS\");\n\n\t\t\t/* discard all contexts in clipboard */\n\t\t\tif (!try_open_clipboard(clipboard->hwnd))\n\t\t\t{\n\t\t\t\tDEBUG_CLIPRDR(\"OpenClipboard failed with 0x%x\", GetLastError());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tEmptyClipboard();\n\t\t\tCloseClipboard();\n\t\t\tbreak;\n\n\t\tcase WM_RENDERFORMAT:\n\t\t\tDEBUG_CLIPRDR(\"info: WM_RENDERFORMAT\");\n\n\t\t\tif (cliprdr_send_data_request(clipboard, (UINT32)wParam) != 0)\n\t\t\t{\n\t\t\t\tDEBUG_CLIPRDR(\"error: cliprdr_send_data_request failed.\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!SetClipboardData((UINT)wParam, clipboard->hmem))\n\t\t\t{\n\t\t\t\tDEBUG_CLIPRDR(\"SetClipboardData failed with 0x%x\", GetLastError());\n\n\t\t\t\tif (clipboard->hmem)\n\t\t\t\t{\n\t\t\t\t\tGlobalFree(clipboard->hmem);\n\t\t\t\t\tclipboard->hmem = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Note: GlobalFree() is not needed when success */\n\t\t\tbreak;\n\n\t\tcase WM_DRAWCLIPBOARD:\n\t\t\tif (clipboard->legacyApi)\n\t\t\t{\n\t\t\t\tif ((GetClipboardOwner() != clipboard->hwnd) &&\n\t\t\t\t    (S_FALSE == OleIsCurrentClipboard(clipboard->data_obj)))\n\t\t\t\t{\n\t\t\t\t\tcliprdr_send_format_list(clipboard);\n\t\t\t\t}\n\n\t\t\t\tSendMessage(clipboard->hWndNextViewer, Msg, wParam, lParam);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase WM_CHANGECBCHAIN:\n\t\t\tif (clipboard->legacyApi)\n\t\t\t{\n\t\t\t\tHWND hWndCurrViewer = (HWND)wParam;\n\t\t\t\tHWND hWndNextViewer = (HWND)lParam;\n\n\t\t\t\tif (hWndCurrViewer == clipboard->hWndNextViewer)\n\t\t\t\t\tclipboard->hWndNextViewer = hWndNextViewer;\n\t\t\t\telse if (clipboard->hWndNextViewer)\n\t\t\t\t\tSendMessage(clipboard->hWndNextViewer, Msg, wParam, lParam);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase WM_CLIPRDR_MESSAGE:\n\t\t\tDEBUG_CLIPRDR(\"info: WM_CLIPRDR_MESSAGE\");\n\n\t\t\tswitch (wParam)\n\t\t\t{\n\t\t\t\tcase OLE_SETCLIPBOARD:\n\t\t\t\t\tDEBUG_CLIPRDR(\"info: OLE_SETCLIPBOARD\");\n\n\t\t\t\t\tif (S_FALSE == OleIsCurrentClipboard(clipboard->data_obj))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wf_create_file_obj(clipboard, &clipboard->data_obj))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (OleSetClipboard(clipboard->data_obj) != S_OK)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twf_destroy_file_obj(clipboard->data_obj);\n\t\t\t\t\t\t\t\tclipboard->data_obj = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase WM_DESTROYCLIPBOARD:\n\t\tcase WM_ASKCBFORMATNAME:\n\t\tcase WM_HSCROLLCLIPBOARD:\n\t\tcase WM_PAINTCLIPBOARD:\n\t\tcase WM_SIZECLIPBOARD:\n\t\tcase WM_VSCROLLCLIPBOARD:\n\t\tdefault:\n\t\t\treturn DefWindowProc(hWnd, Msg, wParam, lParam);\n\t}\n\n\treturn 0;\n}\n\nstatic int create_cliprdr_window(wfClipboard* clipboard)\n{\n\tWNDCLASSEX wnd_cls;\n\tZeroMemory(&wnd_cls, sizeof(WNDCLASSEX));\n\twnd_cls.cbSize = sizeof(WNDCLASSEX);\n\twnd_cls.style = CS_OWNDC;\n\twnd_cls.lpfnWndProc = cliprdr_proc;\n\twnd_cls.cbClsExtra = 0;\n\twnd_cls.cbWndExtra = 0;\n\twnd_cls.hIcon = NULL;\n\twnd_cls.hCursor = NULL;\n\twnd_cls.hbrBackground = NULL;\n\twnd_cls.lpszMenuName = NULL;\n\twnd_cls.lpszClassName = _T(\"ClipboardHiddenMessageProcessor\");\n\twnd_cls.hInstance = GetModuleHandle(NULL);\n\twnd_cls.hIconSm = NULL;\n\tRegisterClassEx(&wnd_cls);\n\tclipboard->hwnd =\n\t    CreateWindowEx(WS_EX_LEFT, _T(\"ClipboardHiddenMessageProcessor\"), _T(\"rdpclip\"), 0, 0, 0, 0,\n\t                   0, HWND_MESSAGE, NULL, GetModuleHandle(NULL), clipboard);\n\n\tif (!clipboard->hwnd)\n\t{\n\t\tDEBUG_CLIPRDR(\"error: CreateWindowEx failed with %x.\", GetLastError());\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic DWORD WINAPI cliprdr_thread_func(LPVOID arg)\n{\n\tint ret;\n\tMSG msg;\n\tBOOL mcode;\n\twfClipboard* clipboard = (wfClipboard*)arg;\n\tOleInitialize(0);\n\n\tif ((ret = create_cliprdr_window(clipboard)) != 0)\n\t{\n\t\tOleUninitialize();\n\t\tDEBUG_CLIPRDR(\"error: create clipboard window failed.\");\n\t\treturn 0;\n\t}\n\n\twhile ((mcode = GetMessage(&msg, 0, 0, 0)) != 0)\n\t{\n\t\tif (mcode == -1)\n\t\t{\n\t\t\tDEBUG_CLIPRDR(\"error: clipboard thread GetMessage failed.\");\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTranslateMessage(&msg);\n\t\t\tDispatchMessage(&msg);\n\t\t}\n\t}\n\n\tOleUninitialize();\n\treturn 0;\n}\n\nstatic void clear_file_array(wfClipboard* clipboard)\n{\n\tsize_t i;\n\n\tif (!clipboard)\n\t\treturn;\n\n\t/* clear file_names array */\n\tif (clipboard->file_names)\n\t{\n\t\tfor (i = 0; i < clipboard->nFiles; i++)\n\t\t{\n\t\t\tfree(clipboard->file_names[i]);\n\t\t\tclipboard->file_names[i] = NULL;\n\t\t}\n\n\t\tfree(clipboard->file_names);\n\t\tclipboard->file_names = NULL;\n\t}\n\n\t/* clear fileDescriptor array */\n\tif (clipboard->fileDescriptor)\n\t{\n\t\tfor (i = 0; i < clipboard->nFiles; i++)\n\t\t{\n\t\t\tfree(clipboard->fileDescriptor[i]);\n\t\t\tclipboard->fileDescriptor[i] = NULL;\n\t\t}\n\n\t\tfree(clipboard->fileDescriptor);\n\t\tclipboard->fileDescriptor = NULL;\n\t}\n\n\tclipboard->file_array_size = 0;\n\tclipboard->nFiles = 0;\n}\n\nstatic BOOL wf_cliprdr_get_file_contents(WCHAR* file_name, BYTE* buffer, LONG positionLow,\n                                         LONG positionHigh, DWORD nRequested, DWORD* puSize)\n{\n\tBOOL res = FALSE;\n\tHANDLE hFile;\n\tDWORD nGet, rc;\n\n\tif (!file_name || !buffer || !puSize)\n\t{\n\t\tWLog_ERR(TAG, \"get file contents Invalid Arguments.\");\n\t\treturn FALSE;\n\t}\n\n\thFile = CreateFileW(file_name, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,\n\t                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\n\tif (hFile == INVALID_HANDLE_VALUE)\n\t\treturn FALSE;\n\n\trc = SetFilePointer(hFile, positionLow, &positionHigh, FILE_BEGIN);\n\n\tif (rc == INVALID_SET_FILE_POINTER)\n\t\tgoto error;\n\n\tif (!ReadFile(hFile, buffer, nRequested, &nGet, NULL))\n\t{\n\t\tDEBUG_CLIPRDR(\"ReadFile failed with 0x%08lX.\", GetLastError());\n\t\tgoto error;\n\t}\n\n\tres = TRUE;\nerror:\n\n\tif (!CloseHandle(hFile))\n\t\tres = FALSE;\n\n\tif (res)\n\t\t*puSize = nGet;\n\n\treturn res;\n}\n\n/* path_name has a '\\' at the end. e.g. c:\\newfolder\\, file_name is c:\\newfolder\\new.txt */\nstatic FILEDESCRIPTORW* wf_cliprdr_get_file_descriptor(WCHAR* file_name, size_t pathLen)\n{\n\tHANDLE hFile;\n\tFILEDESCRIPTORW* fd;\n\tfd = (FILEDESCRIPTORW*)calloc(1, sizeof(FILEDESCRIPTORW));\n\n\tif (!fd)\n\t\treturn NULL;\n\n\thFile = CreateFileW(file_name, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,\n\t                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\n\tif (hFile == INVALID_HANDLE_VALUE)\n\t{\n\t\tfree(fd);\n\t\treturn NULL;\n\t}\n\n\tfd->dwFlags = FD_ATTRIBUTES | FD_FILESIZE | FD_WRITESTIME | FD_PROGRESSUI;\n\tfd->dwFileAttributes = GetFileAttributes(file_name);\n\n\tif (!GetFileTime(hFile, NULL, NULL, &fd->ftLastWriteTime))\n\t{\n\t\tfd->dwFlags &= ~FD_WRITESTIME;\n\t}\n\n\tfd->nFileSizeLow = GetFileSize(hFile, &fd->nFileSizeHigh);\n\twcscpy_s(fd->cFileName, sizeof(fd->cFileName) / 2, file_name + pathLen);\n\tCloseHandle(hFile);\n\treturn fd;\n}\n\nstatic BOOL wf_cliprdr_array_ensure_capacity(wfClipboard* clipboard)\n{\n\tif (!clipboard)\n\t\treturn FALSE;\n\n\tif (clipboard->nFiles == clipboard->file_array_size)\n\t{\n\t\tsize_t new_size;\n\t\tFILEDESCRIPTORW** new_fd;\n\t\tWCHAR** new_name;\n\t\tnew_size = (clipboard->file_array_size + 1) * 2;\n\t\tnew_fd = (FILEDESCRIPTORW**)realloc(clipboard->fileDescriptor,\n\t\t                                    new_size * sizeof(FILEDESCRIPTORW*));\n\n\t\tif (new_fd)\n\t\t\tclipboard->fileDescriptor = new_fd;\n\n\t\tnew_name = (WCHAR**)realloc(clipboard->file_names, new_size * sizeof(WCHAR*));\n\n\t\tif (new_name)\n\t\t\tclipboard->file_names = new_name;\n\n\t\tif (!new_fd || !new_name)\n\t\t\treturn FALSE;\n\n\t\tclipboard->file_array_size = new_size;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL wf_cliprdr_add_to_file_arrays(wfClipboard* clipboard, WCHAR* full_file_name,\n                                          size_t pathLen)\n{\n\tif (!wf_cliprdr_array_ensure_capacity(clipboard))\n\t\treturn FALSE;\n\n\t/* add to name array */\n\tclipboard->file_names[clipboard->nFiles] = (LPWSTR)malloc(MAX_PATH * 2);\n\n\tif (!clipboard->file_names[clipboard->nFiles])\n\t\treturn FALSE;\n\n\twcscpy_s(clipboard->file_names[clipboard->nFiles], MAX_PATH, full_file_name);\n\t/* add to descriptor array */\n\tclipboard->fileDescriptor[clipboard->nFiles] =\n\t    wf_cliprdr_get_file_descriptor(full_file_name, pathLen);\n\n\tif (!clipboard->fileDescriptor[clipboard->nFiles])\n\t{\n\t\tfree(clipboard->file_names[clipboard->nFiles]);\n\t\treturn FALSE;\n\t}\n\n\tclipboard->nFiles++;\n\treturn TRUE;\n}\n\nstatic BOOL wf_cliprdr_traverse_directory(wfClipboard* clipboard, WCHAR* Dir, size_t pathLen)\n{\n\tHANDLE hFind;\n\tWCHAR DirSpec[MAX_PATH];\n\tWIN32_FIND_DATA FindFileData;\n\n\tif (!clipboard || !Dir)\n\t\treturn FALSE;\n\n\tStringCchCopy(DirSpec, MAX_PATH, Dir);\n\tStringCchCat(DirSpec, MAX_PATH, TEXT(\"\\\\*\"));\n\thFind = FindFirstFile(DirSpec, &FindFileData);\n\n\tif (hFind == INVALID_HANDLE_VALUE)\n\t{\n\t\tDEBUG_CLIPRDR(\"FindFirstFile failed with 0x%x.\", GetLastError());\n\t\treturn FALSE;\n\t}\n\n\twhile (FindNextFile(hFind, &FindFileData))\n\t{\n\t\tif ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0 &&\n\t\t        wcscmp(FindFileData.cFileName, _T(\".\")) == 0 ||\n\t\t    wcscmp(FindFileData.cFileName, _T(\"..\")) == 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)\n\t\t{\n\t\t\tWCHAR DirAdd[MAX_PATH];\n\t\t\tStringCchCopy(DirAdd, MAX_PATH, Dir);\n\t\t\tStringCchCat(DirAdd, MAX_PATH, _T(\"\\\\\"));\n\t\t\tStringCchCat(DirAdd, MAX_PATH, FindFileData.cFileName);\n\n\t\t\tif (!wf_cliprdr_add_to_file_arrays(clipboard, DirAdd, pathLen))\n\t\t\t\treturn FALSE;\n\n\t\t\tif (!wf_cliprdr_traverse_directory(clipboard, DirAdd, pathLen))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWCHAR fileName[MAX_PATH];\n\t\t\tStringCchCopy(fileName, MAX_PATH, Dir);\n\t\t\tStringCchCat(fileName, MAX_PATH, _T(\"\\\\\"));\n\t\t\tStringCchCat(fileName, MAX_PATH, FindFileData.cFileName);\n\n\t\t\tif (!wf_cliprdr_add_to_file_arrays(clipboard, fileName, pathLen))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tFindClose(hFind);\n\treturn TRUE;\n}\n\nstatic UINT wf_cliprdr_send_client_capabilities(wfClipboard* clipboard)\n{\n\tCLIPRDR_CAPABILITIES capabilities;\n\tCLIPRDR_GENERAL_CAPABILITY_SET generalCapabilitySet;\n\n\tif (!clipboard || !clipboard->context || !clipboard->context->ClientCapabilities)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tcapabilities.cCapabilitiesSets = 1;\n\tcapabilities.capabilitySets = (CLIPRDR_CAPABILITY_SET*)&(generalCapabilitySet);\n\tgeneralCapabilitySet.capabilitySetType = CB_CAPSTYPE_GENERAL;\n\tgeneralCapabilitySet.capabilitySetLength = 12;\n\tgeneralCapabilitySet.version = CB_CAPS_VERSION_2;\n\tgeneralCapabilitySet.generalFlags =\n\t    CB_USE_LONG_FORMAT_NAMES | CB_STREAM_FILECLIP_ENABLED | CB_FILECLIP_NO_FILE_PATHS;\n\treturn clipboard->context->ClientCapabilities(clipboard->context, &capabilities);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT wf_cliprdr_monitor_ready(CliprdrClientContext* context,\n                                     const CLIPRDR_MONITOR_READY* monitorReady)\n{\n\tUINT rc;\n\twfClipboard* clipboard = (wfClipboard*)context->custom;\n\n\tif (!context || !monitorReady)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tclipboard->sync = TRUE;\n\trc = wf_cliprdr_send_client_capabilities(clipboard);\n\n\tif (rc != CHANNEL_RC_OK)\n\t\treturn rc;\n\n\treturn cliprdr_send_format_list(clipboard);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT wf_cliprdr_server_capabilities(CliprdrClientContext* context,\n                                           const CLIPRDR_CAPABILITIES* capabilities)\n{\n\tUINT32 index;\n\tCLIPRDR_CAPABILITY_SET* capabilitySet;\n\twfClipboard* clipboard = (wfClipboard*)context->custom;\n\n\tif (!context || !capabilities)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tfor (index = 0; index < capabilities->cCapabilitiesSets; index++)\n\t{\n\t\tcapabilitySet = &(capabilities->capabilitySets[index]);\n\n\t\tif ((capabilitySet->capabilitySetType == CB_CAPSTYPE_GENERAL) &&\n\t\t    (capabilitySet->capabilitySetLength >= CB_CAPSTYPE_GENERAL_LEN))\n\t\t{\n\t\t\tCLIPRDR_GENERAL_CAPABILITY_SET* generalCapabilitySet =\n\t\t\t    (CLIPRDR_GENERAL_CAPABILITY_SET*)capabilitySet;\n\t\t\tclipboard->capabilities = generalCapabilitySet->generalFlags;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT wf_cliprdr_server_format_list(CliprdrClientContext* context,\n                                          const CLIPRDR_FORMAT_LIST* formatList)\n{\n\tUINT rc = ERROR_INTERNAL_ERROR;\n\tUINT32 i;\n\tformatMapping* mapping;\n\tCLIPRDR_FORMAT* format;\n\twfClipboard* clipboard = (wfClipboard*)context->custom;\n\n\tif (!clear_format_map(clipboard))\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tfor (i = 0; i < formatList->numFormats; i++)\n\t{\n\t\tformat = &(formatList->formats[i]);\n\t\tmapping = &(clipboard->format_mappings[i]);\n\t\tmapping->remote_format_id = format->formatId;\n\n\t\tif (format->formatName)\n\t\t{\n\t\t\tint size = MultiByteToWideChar(CP_UTF8, 0, format->formatName,\n\t\t\t                               strlen(format->formatName), NULL, 0);\n\t\t\tmapping->name = calloc(size + 1, sizeof(WCHAR));\n\n\t\t\tif (mapping->name)\n\t\t\t{\n\t\t\t\tMultiByteToWideChar(CP_UTF8, 0, format->formatName, strlen(format->formatName),\n\t\t\t\t                    mapping->name, size);\n\t\t\t\tmapping->local_format_id = RegisterClipboardFormatW((LPWSTR)mapping->name);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmapping->name = NULL;\n\t\t\tmapping->local_format_id = mapping->remote_format_id;\n\t\t}\n\n\t\tclipboard->map_size++;\n\t\tmap_ensure_capacity(clipboard);\n\t}\n\n\tif (file_transferring(clipboard))\n\t{\n\t\tif (PostMessage(clipboard->hwnd, WM_CLIPRDR_MESSAGE, OLE_SETCLIPBOARD, 0))\n\t\t\trc = CHANNEL_RC_OK;\n\t}\n\telse\n\t{\n\t\tif (!try_open_clipboard(clipboard->hwnd))\n\t\t\treturn CHANNEL_RC_OK; /* Ignore, other app holding clipboard */\n\n\t\tif (EmptyClipboard())\n\t\t{\n\t\t\tfor (i = 0; i < (UINT32)clipboard->map_size; i++)\n\t\t\t\tSetClipboardData(clipboard->format_mappings[i].local_format_id, NULL);\n\n\t\t\trc = CHANNEL_RC_OK;\n\t\t}\n\n\t\tif (!CloseClipboard() && GetLastError())\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn rc;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT\nwf_cliprdr_server_format_list_response(CliprdrClientContext* context,\n                                       const CLIPRDR_FORMAT_LIST_RESPONSE* formatListResponse)\n{\n\t(void)context;\n\t(void)formatListResponse;\n\n\tif (formatListResponse->msgFlags != CB_RESPONSE_OK)\n\t\treturn E_FAIL;\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT\nwf_cliprdr_server_lock_clipboard_data(CliprdrClientContext* context,\n                                      const CLIPRDR_LOCK_CLIPBOARD_DATA* lockClipboardData)\n{\n\t(void)context;\n\t(void)lockClipboardData;\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT\nwf_cliprdr_server_unlock_clipboard_data(CliprdrClientContext* context,\n                                        const CLIPRDR_UNLOCK_CLIPBOARD_DATA* unlockClipboardData)\n{\n\t(void)context;\n\t(void)unlockClipboardData;\n\treturn CHANNEL_RC_OK;\n}\n\nstatic BOOL wf_cliprdr_process_filename(wfClipboard* clipboard, WCHAR* wFileName, size_t str_len)\n{\n\tsize_t pathLen;\n\tsize_t offset = str_len;\n\n\tif (!clipboard || !wFileName)\n\t\treturn FALSE;\n\n\t/* find the last '\\' in full file name */\n\twhile (offset > 0)\n\t{\n\t\tif (wFileName[offset] == L'\\\\')\n\t\t\tbreak;\n\t\telse\n\t\t\toffset--;\n\t}\n\n\tpathLen = offset + 1;\n\n\tif (!wf_cliprdr_add_to_file_arrays(clipboard, wFileName, pathLen))\n\t\treturn FALSE;\n\n\tif ((clipboard->fileDescriptor[clipboard->nFiles - 1]->dwFileAttributes &\n\t     FILE_ATTRIBUTE_DIRECTORY) != 0)\n\t{\n\t\t/* this is a directory */\n\t\tif (!wf_cliprdr_traverse_directory(clipboard, wFileName, pathLen))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT\nwf_cliprdr_server_format_data_request(CliprdrClientContext* context,\n                                      const CLIPRDR_FORMAT_DATA_REQUEST* formatDataRequest)\n{\n\tUINT rc;\n\tsize_t size = 0;\n\tvoid* buff = NULL;\n\tchar* globlemem = NULL;\n\tHANDLE hClipdata = NULL;\n\tUINT32 requestedFormatId;\n\tCLIPRDR_FORMAT_DATA_RESPONSE response;\n\twfClipboard* clipboard;\n\n\tif (!context || !formatDataRequest)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tclipboard = (wfClipboard*)context->custom;\n\n\tif (!clipboard)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\trequestedFormatId = formatDataRequest->requestedFormatId;\n\n\tif (requestedFormatId == RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW))\n\t{\n\t\tsize_t len;\n\t\tsize_t i;\n\t\tWCHAR* wFileName;\n\t\tHRESULT result;\n\t\tLPDATAOBJECT dataObj;\n\t\tFORMATETC format_etc;\n\t\tSTGMEDIUM stg_medium;\n\t\tDROPFILES* dropFiles;\n\t\tFILEGROUPDESCRIPTORW* groupDsc;\n\t\tresult = OleGetClipboard(&dataObj);\n\n\t\tif (FAILED(result))\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\n\t\tZeroMemory(&format_etc, sizeof(FORMATETC));\n\t\tZeroMemory(&stg_medium, sizeof(STGMEDIUM));\n\t\t/* get DROPFILES struct from OLE */\n\t\tformat_etc.cfFormat = CF_HDROP;\n\t\tformat_etc.tymed = TYMED_HGLOBAL;\n\t\tformat_etc.dwAspect = 1;\n\t\tformat_etc.lindex = -1;\n\t\tresult = IDataObject_GetData(dataObj, &format_etc, &stg_medium);\n\n\t\tif (FAILED(result))\n\t\t{\n\t\t\tDEBUG_CLIPRDR(\"dataObj->GetData failed.\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tdropFiles = (DROPFILES*)GlobalLock(stg_medium.hGlobal);\n\n\t\tif (!dropFiles)\n\t\t{\n\t\t\tGlobalUnlock(stg_medium.hGlobal);\n\t\t\tReleaseStgMedium(&stg_medium);\n\t\t\tclipboard->nFiles = 0;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tclear_file_array(clipboard);\n\n\t\tif (dropFiles->fWide)\n\t\t{\n\t\t\t/* dropFiles contains file names */\n\t\t\tfor (wFileName = (WCHAR*)((char*)dropFiles + dropFiles->pFiles);\n\t\t\t     (len = wcslen(wFileName)) > 0; wFileName += len + 1)\n\t\t\t{\n\t\t\t\twf_cliprdr_process_filename(clipboard, wFileName, wcslen(wFileName));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar* p;\n\n\t\t\tfor (p = (char*)((char*)dropFiles + dropFiles->pFiles); (len = strlen(p)) > 0;\n\t\t\t     p += len + 1, clipboard->nFiles++)\n\t\t\t{\n\t\t\t\tint cchWideChar;\n\t\t\t\tWCHAR* wFileName;\n\t\t\t\tcchWideChar = MultiByteToWideChar(CP_ACP, MB_COMPOSITE, p, len, NULL, 0);\n\t\t\t\twFileName = (LPWSTR)calloc(cchWideChar, sizeof(WCHAR));\n\t\t\t\tMultiByteToWideChar(CP_ACP, MB_COMPOSITE, p, len, wFileName, cchWideChar);\n\t\t\t\twf_cliprdr_process_filename(clipboard, wFileName, cchWideChar);\n\t\t\t}\n\t\t}\n\n\t\tGlobalUnlock(stg_medium.hGlobal);\n\t\tReleaseStgMedium(&stg_medium);\n\texit:\n\t\tsize = 4 + clipboard->nFiles * sizeof(FILEDESCRIPTORW);\n\t\tgroupDsc = (FILEGROUPDESCRIPTORW*)malloc(size);\n\n\t\tif (groupDsc)\n\t\t{\n\t\t\tgroupDsc->cItems = clipboard->nFiles;\n\n\t\t\tfor (i = 0; i < clipboard->nFiles; i++)\n\t\t\t{\n\t\t\t\tif (clipboard->fileDescriptor[i])\n\t\t\t\t\tgroupDsc->fgd[i] = *clipboard->fileDescriptor[i];\n\t\t\t}\n\n\t\t\tbuff = groupDsc;\n\t\t}\n\n\t\tIDataObject_Release(dataObj);\n\t}\n\telse\n\t{\n\t\t/* Ignore if other app is holding the clipboard */\n\t\tif (try_open_clipboard(clipboard->hwnd))\n\t\t{\n\t\t\thClipdata = GetClipboardData(requestedFormatId);\n\n\t\t\tif (!hClipdata)\n\t\t\t{\n\t\t\t\tCloseClipboard();\n\t\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t\t}\n\n\t\t\tgloblemem = (char*)GlobalLock(hClipdata);\n\t\t\tsize = (int)GlobalSize(hClipdata);\n\t\t\tbuff = malloc(size);\n\t\t\tCopyMemory(buff, globlemem, size);\n\t\t\tGlobalUnlock(hClipdata);\n\t\t\tCloseClipboard();\n\t\t}\n\t}\n\n\tresponse.msgFlags = CB_RESPONSE_OK;\n\tresponse.dataLen = size;\n\tresponse.requestedFormatData = (BYTE*)buff;\n\trc = clipboard->context->ClientFormatDataResponse(clipboard->context, &response);\n\tfree(buff);\n\treturn rc;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT\nwf_cliprdr_server_format_data_response(CliprdrClientContext* context,\n                                       const CLIPRDR_FORMAT_DATA_RESPONSE* formatDataResponse)\n{\n\tBYTE* data;\n\tHANDLE hMem;\n\twfClipboard* clipboard;\n\n\tif (!context || !formatDataResponse)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tif (formatDataResponse->msgFlags != CB_RESPONSE_OK)\n\t\treturn E_FAIL;\n\n\tclipboard = (wfClipboard*)context->custom;\n\n\tif (!clipboard)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\thMem = GlobalAlloc(GMEM_MOVEABLE, formatDataResponse->dataLen);\n\n\tif (!hMem)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tdata = (BYTE*)GlobalLock(hMem);\n\n\tif (!data)\n\t{\n\t\tGlobalFree(hMem);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(data, formatDataResponse->requestedFormatData, formatDataResponse->dataLen);\n\n\tif (!GlobalUnlock(hMem) && GetLastError())\n\t{\n\t\tGlobalFree(hMem);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\tclipboard->hmem = hMem;\n\n\tif (!SetEvent(clipboard->response_data_event))\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT\nwf_cliprdr_server_file_contents_request(CliprdrClientContext* context,\n                                        const CLIPRDR_FILE_CONTENTS_REQUEST* fileContentsRequest)\n{\n\tDWORD uSize = 0;\n\tBYTE* pData = NULL;\n\tHRESULT hRet = S_OK;\n\tFORMATETC vFormatEtc;\n\tLPDATAOBJECT pDataObj = NULL;\n\tSTGMEDIUM vStgMedium;\n\tBOOL bIsStreamFile = TRUE;\n\tstatic LPSTREAM pStreamStc = NULL;\n\tstatic UINT32 uStreamIdStc = 0;\n\twfClipboard* clipboard;\n\tUINT rc = ERROR_INTERNAL_ERROR;\n\tUINT sRc;\n\tUINT32 cbRequested;\n\n\tif (!context || !fileContentsRequest)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tclipboard = (wfClipboard*)context->custom;\n\n\tif (!clipboard)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tcbRequested = fileContentsRequest->cbRequested;\n\tif (fileContentsRequest->dwFlags == FILECONTENTS_SIZE)\n\t\tcbRequested = sizeof(UINT64);\n\n\tpData = (BYTE*)calloc(1, cbRequested);\n\n\tif (!pData)\n\t\tgoto error;\n\n\thRet = OleGetClipboard(&pDataObj);\n\n\tif (FAILED(hRet))\n\t{\n\t\tWLog_ERR(TAG, \"filecontents: get ole clipboard failed.\");\n\t\tgoto error;\n\t}\n\n\tZeroMemory(&vFormatEtc, sizeof(FORMATETC));\n\tZeroMemory(&vStgMedium, sizeof(STGMEDIUM));\n\tvFormatEtc.cfFormat = RegisterClipboardFormat(CFSTR_FILECONTENTS);\n\tvFormatEtc.tymed = TYMED_ISTREAM;\n\tvFormatEtc.dwAspect = 1;\n\tvFormatEtc.lindex = fileContentsRequest->listIndex;\n\tvFormatEtc.ptd = NULL;\n\n\tif ((uStreamIdStc != fileContentsRequest->streamId) || !pStreamStc)\n\t{\n\t\tLPENUMFORMATETC pEnumFormatEtc;\n\t\tULONG CeltFetched;\n\t\tFORMATETC vFormatEtc2;\n\n\t\tif (pStreamStc)\n\t\t{\n\t\t\tIStream_Release(pStreamStc);\n\t\t\tpStreamStc = NULL;\n\t\t}\n\n\t\tbIsStreamFile = FALSE;\n\t\thRet = IDataObject_EnumFormatEtc(pDataObj, DATADIR_GET, &pEnumFormatEtc);\n\n\t\tif (hRet == S_OK)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\thRet = IEnumFORMATETC_Next(pEnumFormatEtc, 1, &vFormatEtc2, &CeltFetched);\n\n\t\t\t\tif (hRet == S_OK)\n\t\t\t\t{\n\t\t\t\t\tif (vFormatEtc2.cfFormat == RegisterClipboardFormat(CFSTR_FILECONTENTS))\n\t\t\t\t\t{\n\t\t\t\t\t\thRet = IDataObject_GetData(pDataObj, &vFormatEtc, &vStgMedium);\n\n\t\t\t\t\t\tif (hRet == S_OK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpStreamStc = vStgMedium.pstm;\n\t\t\t\t\t\t\tuStreamIdStc = fileContentsRequest->streamId;\n\t\t\t\t\t\t\tbIsStreamFile = TRUE;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (hRet == S_OK);\n\t\t}\n\t}\n\n\tif (bIsStreamFile == TRUE)\n\t{\n\t\tif (fileContentsRequest->dwFlags == FILECONTENTS_SIZE)\n\t\t{\n\t\t\tSTATSTG vStatStg;\n\t\t\tZeroMemory(&vStatStg, sizeof(STATSTG));\n\t\t\thRet = IStream_Stat(pStreamStc, &vStatStg, STATFLAG_NONAME);\n\n\t\t\tif (hRet == S_OK)\n\t\t\t{\n\t\t\t\t*((UINT32*)&pData[0]) = vStatStg.cbSize.LowPart;\n\t\t\t\t*((UINT32*)&pData[4]) = vStatStg.cbSize.HighPart;\n\t\t\t\tuSize = cbRequested;\n\t\t\t}\n\t\t}\n\t\telse if (fileContentsRequest->dwFlags == FILECONTENTS_RANGE)\n\t\t{\n\t\t\tLARGE_INTEGER dlibMove;\n\t\t\tULARGE_INTEGER dlibNewPosition;\n\t\t\tdlibMove.HighPart = fileContentsRequest->nPositionHigh;\n\t\t\tdlibMove.LowPart = fileContentsRequest->nPositionLow;\n\t\t\thRet = IStream_Seek(pStreamStc, dlibMove, STREAM_SEEK_SET, &dlibNewPosition);\n\n\t\t\tif (SUCCEEDED(hRet))\n\t\t\t\thRet = IStream_Read(pStreamStc, pData, cbRequested, (PULONG)&uSize);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (fileContentsRequest->dwFlags == FILECONTENTS_SIZE)\n\t\t{\n\t\t\t*((UINT32*)&pData[0]) =\n\t\t\t    clipboard->fileDescriptor[fileContentsRequest->listIndex]->nFileSizeLow;\n\t\t\t*((UINT32*)&pData[4]) =\n\t\t\t    clipboard->fileDescriptor[fileContentsRequest->listIndex]->nFileSizeHigh;\n\t\t\tuSize = cbRequested;\n\t\t}\n\t\telse if (fileContentsRequest->dwFlags == FILECONTENTS_RANGE)\n\t\t{\n\t\t\tBOOL bRet;\n\t\t\tbRet = wf_cliprdr_get_file_contents(\n\t\t\t    clipboard->file_names[fileContentsRequest->listIndex], pData,\n\t\t\t    fileContentsRequest->nPositionLow, fileContentsRequest->nPositionHigh, cbRequested,\n\t\t\t    &uSize);\n\n\t\t\tif (bRet == FALSE)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"get file contents failed.\");\n\t\t\t\tuSize = 0;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = CHANNEL_RC_OK;\nerror:\n\n\tif (pDataObj)\n\t\tIDataObject_Release(pDataObj);\n\n\tif (uSize == 0)\n\t{\n\t\tfree(pData);\n\t\tpData = NULL;\n\t}\n\n\tsRc =\n\t    cliprdr_send_response_filecontents(clipboard, fileContentsRequest->streamId, uSize, pData);\n\tfree(pData);\n\n\tif (sRc != CHANNEL_RC_OK)\n\t\treturn sRc;\n\n\treturn rc;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT\nwf_cliprdr_server_file_contents_response(CliprdrClientContext* context,\n                                         const CLIPRDR_FILE_CONTENTS_RESPONSE* fileContentsResponse)\n{\n\twfClipboard* clipboard;\n\n\tif (!context || !fileContentsResponse)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tif (fileContentsResponse->msgFlags != CB_RESPONSE_OK)\n\t\treturn E_FAIL;\n\n\tclipboard = (wfClipboard*)context->custom;\n\n\tif (!clipboard)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tclipboard->req_fsize = fileContentsResponse->cbRequested;\n\tclipboard->req_fdata = (char*)malloc(fileContentsResponse->cbRequested);\n\n\tif (!clipboard->req_fdata)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tCopyMemory(clipboard->req_fdata, fileContentsResponse->requestedData,\n\t           fileContentsResponse->cbRequested);\n\n\tif (!SetEvent(clipboard->req_fevent))\n\t{\n\t\tfree(clipboard->req_fdata);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\nBOOL wf_cliprdr_init(wfContext* wfc, CliprdrClientContext* cliprdr)\n{\n\twfClipboard* clipboard;\n\trdpContext* context = (rdpContext*)wfc;\n\n\tif (!context || !cliprdr)\n\t\treturn FALSE;\n\n\twfc->clipboard = (wfClipboard*)calloc(1, sizeof(wfClipboard));\n\n\tif (!wfc->clipboard)\n\t\treturn FALSE;\n\n\tclipboard = wfc->clipboard;\n\tclipboard->wfc = wfc;\n\tclipboard->context = cliprdr;\n\tclipboard->channels = context->channels;\n\tclipboard->sync = FALSE;\n\tclipboard->map_capacity = 32;\n\tclipboard->map_size = 0;\n\tclipboard->hUser32 = LoadLibraryA(\"user32.dll\");\n\n\tif (clipboard->hUser32)\n\t{\n\t\tclipboard->AddClipboardFormatListener = (fnAddClipboardFormatListener)GetProcAddress(\n\t\t    clipboard->hUser32, \"AddClipboardFormatListener\");\n\t\tclipboard->RemoveClipboardFormatListener = (fnRemoveClipboardFormatListener)GetProcAddress(\n\t\t    clipboard->hUser32, \"RemoveClipboardFormatListener\");\n\t\tclipboard->GetUpdatedClipboardFormats = (fnGetUpdatedClipboardFormats)GetProcAddress(\n\t\t    clipboard->hUser32, \"GetUpdatedClipboardFormats\");\n\t}\n\n\tif (!(clipboard->hUser32 && clipboard->AddClipboardFormatListener &&\n\t      clipboard->RemoveClipboardFormatListener && clipboard->GetUpdatedClipboardFormats))\n\t\tclipboard->legacyApi = TRUE;\n\n\tif (!(clipboard->format_mappings =\n\t          (formatMapping*)calloc(clipboard->map_capacity, sizeof(formatMapping))))\n\t\tgoto error;\n\n\tif (!(clipboard->response_data_event = CreateEvent(NULL, TRUE, FALSE, NULL)))\n\t\tgoto error;\n\n\tif (!(clipboard->req_fevent = CreateEvent(NULL, TRUE, FALSE, NULL)))\n\t\tgoto error;\n\n\tif (!(clipboard->thread = CreateThread(NULL, 0, cliprdr_thread_func, clipboard, 0, NULL)))\n\t\tgoto error;\n\n\tcliprdr->MonitorReady = wf_cliprdr_monitor_ready;\n\tcliprdr->ServerCapabilities = wf_cliprdr_server_capabilities;\n\tcliprdr->ServerFormatList = wf_cliprdr_server_format_list;\n\tcliprdr->ServerFormatListResponse = wf_cliprdr_server_format_list_response;\n\tcliprdr->ServerLockClipboardData = wf_cliprdr_server_lock_clipboard_data;\n\tcliprdr->ServerUnlockClipboardData = wf_cliprdr_server_unlock_clipboard_data;\n\tcliprdr->ServerFormatDataRequest = wf_cliprdr_server_format_data_request;\n\tcliprdr->ServerFormatDataResponse = wf_cliprdr_server_format_data_response;\n\tcliprdr->ServerFileContentsRequest = wf_cliprdr_server_file_contents_request;\n\tcliprdr->ServerFileContentsResponse = wf_cliprdr_server_file_contents_response;\n\tcliprdr->custom = (void*)wfc->clipboard;\n\treturn TRUE;\nerror:\n\twf_cliprdr_uninit(wfc, cliprdr);\n\treturn FALSE;\n}\n\nBOOL wf_cliprdr_uninit(wfContext* wfc, CliprdrClientContext* cliprdr)\n{\n\twfClipboard* clipboard;\n\n\tif (!wfc || !cliprdr)\n\t\treturn FALSE;\n\n\tclipboard = wfc->clipboard;\n\n\tif (!clipboard)\n\t\treturn FALSE;\n\n\tcliprdr->custom = NULL;\n\n\tif (clipboard->hwnd)\n\t\tPostMessage(clipboard->hwnd, WM_QUIT, 0, 0);\n\n\tif (clipboard->thread)\n\t{\n\t\tWaitForSingleObject(clipboard->thread, INFINITE);\n\t\tCloseHandle(clipboard->thread);\n\t}\n\n\tif (clipboard->response_data_event)\n\t\tCloseHandle(clipboard->response_data_event);\n\n\tif (clipboard->req_fevent)\n\t\tCloseHandle(clipboard->req_fevent);\n\n\tclear_file_array(clipboard);\n\tclear_format_map(clipboard);\n\tfree(clipboard->format_mappings);\n\tfree(clipboard);\n\treturn TRUE;\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Windows Clipboard Redirection\n *\n * Copyright 2012 Jason Champion\n * Copyright 2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#define CINTERFACE\n#define COBJMACROS\n\n#include <ole2.h>\n#include <shlobj.h>\n#include <windows.h>\n#include <winuser.h>\n\n#include <winpr/assert.h>\n\n#include <winpr/crt.h>\n#include <winpr/tchar.h>\n#include <winpr/stream.h>\n\n#include <freerdp/log.h>\n#include <freerdp/client/cliprdr.h>\n\n#include <strsafe.h>\n\n#include \"wf_cliprdr.h\"\n\n#define TAG CLIENT_TAG(\"windows\")\n\n#ifdef WITH_DEBUG_CLIPRDR\n#define DEBUG_CLIPRDR(...) WLog_DBG(TAG, __VA_ARGS__)\n#else\n#define DEBUG_CLIPRDR(...) \\\n\tdo                     \\\n\t{                      \\\n\t} while (0)\n#endif\n\ntypedef BOOL(WINAPI* fnAddClipboardFormatListener)(HWND hwnd);\ntypedef BOOL(WINAPI* fnRemoveClipboardFormatListener)(HWND hwnd);\ntypedef BOOL(WINAPI* fnGetUpdatedClipboardFormats)(PUINT lpuiFormats, UINT cFormats,\n                                                   PUINT pcFormatsOut);\n\nstruct format_mapping\n{\n\tUINT32 remote_format_id;\n\tUINT32 local_format_id;\n\tWCHAR* name;\n};\ntypedef struct format_mapping formatMapping;\n\nstruct _CliprdrEnumFORMATETC\n{\n\tIEnumFORMATETC iEnumFORMATETC;\n\n\tLONG m_lRefCount;\n\tLONG m_nIndex;\n\tLONG m_nNumFormats;\n\tFORMATETC* m_pFormatEtc;\n};\ntypedef struct _CliprdrEnumFORMATETC CliprdrEnumFORMATETC;\n\nstruct _CliprdrStream\n{\n\tIStream iStream;\n\n\tLONG m_lRefCount;\n\tULONG m_lIndex;\n\tULARGE_INTEGER m_lSize;\n\tULARGE_INTEGER m_lOffset;\n\tFILEDESCRIPTORW m_Dsc;\n\tvoid* m_pData;\n};\ntypedef struct _CliprdrStream CliprdrStream;\n\nstruct _CliprdrDataObject\n{\n\tIDataObject iDataObject;\n\n\tLONG m_lRefCount;\n\tFORMATETC* m_pFormatEtc;\n\tSTGMEDIUM* m_pStgMedium;\n\tULONG m_nNumFormats;\n\tULONG m_nStreams;\n\tIStream** m_pStream;\n\tvoid* m_pData;\n};\ntypedef struct _CliprdrDataObject CliprdrDataObject;\n\nstruct wf_clipboard\n{\n\twfContext* wfc;\n\trdpChannels* channels;\n\tCliprdrClientContext* context;\n\n\tBOOL sync;\n\tUINT32 capabilities;\n\n\tsize_t map_size;\n\tsize_t map_capacity;\n\tformatMapping* format_mappings;\n\n\tUINT32 requestedFormatId;\n\n\tHWND hwnd;\n\tHANDLE hmem;\n\tHANDLE thread;\n\tHANDLE response_data_event;\n\n\tLPDATAOBJECT data_obj;\n\tULONG req_fsize;\n\tchar* req_fdata;\n\tHANDLE req_fevent;\n\n\tsize_t nFiles;\n\tsize_t file_array_size;\n\tWCHAR** file_names;\n\tFILEDESCRIPTORW** fileDescriptor;\n\n\tBOOL legacyApi;\n\tHMODULE hUser32;\n\tHWND hWndNextViewer;\n\tfnAddClipboardFormatListener AddClipboardFormatListener;\n\tfnRemoveClipboardFormatListener RemoveClipboardFormatListener;\n\tfnGetUpdatedClipboardFormats GetUpdatedClipboardFormats;\n};\ntypedef struct wf_clipboard wfClipboard;\n\n#define WM_CLIPRDR_MESSAGE (WM_USER + 156)\n#define OLE_SETCLIPBOARD 1\n\nstatic BOOL wf_create_file_obj(wfClipboard* cliprdrrdr, IDataObject** ppDataObject);\nstatic void wf_destroy_file_obj(IDataObject* instance);\nstatic UINT32 get_remote_format_id(wfClipboard* clipboard, UINT32 local_format);\nstatic UINT cliprdr_send_data_request(wfClipboard* clipboard, UINT32 format);\nstatic UINT cliprdr_send_lock(wfClipboard* clipboard);\nstatic UINT cliprdr_send_unlock(wfClipboard* clipboard);\nstatic UINT cliprdr_send_request_filecontents(wfClipboard* clipboard, const void* streamid,\n                                              ULONG index, UINT32 flag, DWORD positionhigh,\n                                              DWORD positionlow, ULONG request);\n\nstatic void CliprdrDataObject_Delete(CliprdrDataObject* instance);\n\nstatic CliprdrEnumFORMATETC* CliprdrEnumFORMATETC_New(ULONG nFormats, FORMATETC* pFormatEtc);\nstatic void CliprdrEnumFORMATETC_Delete(CliprdrEnumFORMATETC* instance);\n\nstatic void CliprdrStream_Delete(CliprdrStream* instance);\n\nstatic BOOL try_open_clipboard(HWND hwnd)\n{\n\tsize_t x;\n\tfor (x = 0; x < 10; x++)\n\t{\n\t\tif (OpenClipboard(hwnd))\n\t\t\treturn TRUE;\n\t\tSleep(10);\n\t}\n\treturn FALSE;\n}\n\n/**\n * IStream\n */\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_QueryInterface(IStream* This, REFIID riid,\n                                                              void** ppvObject)\n{\n\tif (IsEqualIID(riid, &IID_IStream) || IsEqualIID(riid, &IID_IUnknown))\n\t{\n\t\tIStream_AddRef(This);\n\t\t*ppvObject = This;\n\t\treturn S_OK;\n\t}\n\telse\n\t{\n\t\t*ppvObject = 0;\n\t\treturn E_NOINTERFACE;\n\t}\n}\n\nstatic ULONG STDMETHODCALLTYPE CliprdrStream_AddRef(IStream* This)\n{\n\tCliprdrStream* instance = (CliprdrStream*)This;\n\n\tif (!instance)\n\t\treturn 0;\n\n\treturn InterlockedIncrement(&instance->m_lRefCount);\n}\n\nstatic ULONG STDMETHODCALLTYPE CliprdrStream_Release(IStream* This)\n{\n\tLONG count;\n\tCliprdrStream* instance = (CliprdrStream*)This;\n\n\tif (!instance)\n\t\treturn 0;\n\n\tcount = InterlockedDecrement(&instance->m_lRefCount);\n\n\tif (count == 0)\n\t{\n\t\tCliprdrStream_Delete(instance);\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn count;\n\t}\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_Read(IStream* This, void* pv, ULONG cb,\n                                                    ULONG* pcbRead)\n{\n\tint ret;\n\tCliprdrStream* instance = (CliprdrStream*)This;\n\twfClipboard* clipboard;\n\n\tif (!pv || !pcbRead || !instance)\n\t\treturn E_INVALIDARG;\n\n\tclipboard = (wfClipboard*)instance->m_pData;\n\t*pcbRead = 0;\n\n\tif (instance->m_lOffset.QuadPart >= instance->m_lSize.QuadPart)\n\t\treturn S_FALSE;\n\n\tret = cliprdr_send_request_filecontents(clipboard, (void*)This, instance->m_lIndex,\n\t                                        FILECONTENTS_RANGE, instance->m_lOffset.HighPart,\n\t                                        instance->m_lOffset.LowPart, cb);\n\n\tif (ret < 0)\n\t\treturn E_FAIL;\n\n\tif (clipboard->req_fdata)\n\t{\n\t\tCopyMemory(pv, clipboard->req_fdata, clipboard->req_fsize);\n\t\tfree(clipboard->req_fdata);\n\t}\n\n\t*pcbRead = clipboard->req_fsize;\n\tinstance->m_lOffset.QuadPart += clipboard->req_fsize;\n\n\tif (clipboard->req_fsize < cb)\n\t\treturn S_FALSE;\n\n\treturn S_OK;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_Write(IStream* This, const void* pv, ULONG cb,\n                                                     ULONG* pcbWritten)\n{\n\t(void)This;\n\t(void)pv;\n\t(void)cb;\n\t(void)pcbWritten;\n\treturn STG_E_ACCESSDENIED;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_Seek(IStream* This, LARGE_INTEGER dlibMove,\n                                                    DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition)\n{\n\tULONGLONG newoffset;\n\tCliprdrStream* instance = (CliprdrStream*)This;\n\n\tif (!instance)\n\t\treturn E_INVALIDARG;\n\n\tnewoffset = instance->m_lOffset.QuadPart;\n\n\tswitch (dwOrigin)\n\t{\n\t\tcase STREAM_SEEK_SET:\n\t\t\tnewoffset = dlibMove.QuadPart;\n\t\t\tbreak;\n\n\t\tcase STREAM_SEEK_CUR:\n\t\t\tnewoffset += dlibMove.QuadPart;\n\t\t\tbreak;\n\n\t\tcase STREAM_SEEK_END:\n\t\t\tnewoffset = instance->m_lSize.QuadPart + dlibMove.QuadPart;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn E_INVALIDARG;\n\t}\n\n\tif (newoffset < 0 || newoffset >= instance->m_lSize.QuadPart)\n\t\treturn E_FAIL;\n\n\tinstance->m_lOffset.QuadPart = newoffset;\n\n\tif (plibNewPosition)\n\t\tplibNewPosition->QuadPart = instance->m_lOffset.QuadPart;\n\n\treturn S_OK;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_SetSize(IStream* This, ULARGE_INTEGER libNewSize)\n{\n\t(void)This;\n\t(void)libNewSize;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_CopyTo(IStream* This, IStream* pstm,\n                                                      ULARGE_INTEGER cb, ULARGE_INTEGER* pcbRead,\n                                                      ULARGE_INTEGER* pcbWritten)\n{\n\t(void)This;\n\t(void)pstm;\n\t(void)cb;\n\t(void)pcbRead;\n\t(void)pcbWritten;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_Commit(IStream* This, DWORD grfCommitFlags)\n{\n\t(void)This;\n\t(void)grfCommitFlags;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_Revert(IStream* This)\n{\n\t(void)This;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_LockRegion(IStream* This, ULARGE_INTEGER libOffset,\n                                                          ULARGE_INTEGER cb, DWORD dwLockType)\n{\n\t(void)This;\n\t(void)libOffset;\n\t(void)cb;\n\t(void)dwLockType;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_UnlockRegion(IStream* This, ULARGE_INTEGER libOffset,\n                                                            ULARGE_INTEGER cb, DWORD dwLockType)\n{\n\t(void)This;\n\t(void)libOffset;\n\t(void)cb;\n\t(void)dwLockType;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_Stat(IStream* This, STATSTG* pstatstg,\n                                                    DWORD grfStatFlag)\n{\n\tCliprdrStream* instance = (CliprdrStream*)This;\n\n\tif (!instance)\n\t\treturn E_INVALIDARG;\n\n\tif (pstatstg == NULL)\n\t\treturn STG_E_INVALIDPOINTER;\n\n\tZeroMemory(pstatstg, sizeof(STATSTG));\n\n\tswitch (grfStatFlag)\n\t{\n\t\tcase STATFLAG_DEFAULT:\n\t\t\treturn STG_E_INSUFFICIENTMEMORY;\n\n\t\tcase STATFLAG_NONAME:\n\t\t\tpstatstg->cbSize.QuadPart = instance->m_lSize.QuadPart;\n\t\t\tpstatstg->grfLocksSupported = LOCK_EXCLUSIVE;\n\t\t\tpstatstg->grfMode = GENERIC_READ;\n\t\t\tpstatstg->grfStateBits = 0;\n\t\t\tpstatstg->type = STGTY_STREAM;\n\t\t\tbreak;\n\n\t\tcase STATFLAG_NOOPEN:\n\t\t\treturn STG_E_INVALIDFLAG;\n\n\t\tdefault:\n\t\t\treturn STG_E_INVALIDFLAG;\n\t}\n\n\treturn S_OK;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrStream_Clone(IStream* This, IStream** ppstm)\n{\n\t(void)This;\n\t(void)ppstm;\n\treturn E_NOTIMPL;\n}\n\nstatic CliprdrStream* CliprdrStream_New(ULONG index, void* pData, const FILEDESCRIPTORW* dsc)\n{\n\tIStream* iStream;\n\tBOOL success = FALSE;\n\tBOOL isDir = FALSE;\n\tCliprdrStream* instance;\n\twfClipboard* clipboard = (wfClipboard*)pData;\n\tinstance = (CliprdrStream*)calloc(1, sizeof(CliprdrStream));\n\n\tif (instance)\n\t{\n\t\tinstance->m_Dsc = *dsc;\n\t\tiStream = &instance->iStream;\n\t\tiStream->lpVtbl = (IStreamVtbl*)calloc(1, sizeof(IStreamVtbl));\n\n\t\tif (iStream->lpVtbl)\n\t\t{\n\t\t\tiStream->lpVtbl->QueryInterface = CliprdrStream_QueryInterface;\n\t\t\tiStream->lpVtbl->AddRef = CliprdrStream_AddRef;\n\t\t\tiStream->lpVtbl->Release = CliprdrStream_Release;\n\t\t\tiStream->lpVtbl->Read = CliprdrStream_Read;\n\t\t\tiStream->lpVtbl->Write = CliprdrStream_Write;\n\t\t\tiStream->lpVtbl->Seek = CliprdrStream_Seek;\n\t\t\tiStream->lpVtbl->SetSize = CliprdrStream_SetSize;\n\t\t\tiStream->lpVtbl->CopyTo = CliprdrStream_CopyTo;\n\t\t\tiStream->lpVtbl->Commit = CliprdrStream_Commit;\n\t\t\tiStream->lpVtbl->Revert = CliprdrStream_Revert;\n\t\t\tiStream->lpVtbl->LockRegion = CliprdrStream_LockRegion;\n\t\t\tiStream->lpVtbl->UnlockRegion = CliprdrStream_UnlockRegion;\n\t\t\tiStream->lpVtbl->Stat = CliprdrStream_Stat;\n\t\t\tiStream->lpVtbl->Clone = CliprdrStream_Clone;\n\t\t\tinstance->m_lRefCount = 1;\n\t\t\tinstance->m_lIndex = index;\n\t\t\tinstance->m_pData = pData;\n\t\t\tinstance->m_lOffset.QuadPart = 0;\n\n\t\t\tif (instance->m_Dsc.dwFlags & FD_ATTRIBUTES)\n\t\t\t{\n\t\t\t\tif (instance->m_Dsc.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n\t\t\t\t\tisDir = TRUE;\n\t\t\t}\n\n\t\t\tif (((instance->m_Dsc.dwFlags & FD_FILESIZE) == 0) && !isDir)\n\t\t\t{\n\t\t\t\t/* get content size of this stream */\n\t\t\t\tif (cliprdr_send_request_filecontents(clipboard, (void*)instance,\n\t\t\t\t                                      instance->m_lIndex, FILECONTENTS_SIZE, 0, 0,\n\t\t\t\t                                      8) == CHANNEL_RC_OK)\n\t\t\t\t{\n\t\t\t\t\tsuccess = TRUE;\n\t\t\t\t}\n\n\t\t\t\tinstance->m_lSize.QuadPart = *((LONGLONG*)clipboard->req_fdata);\n\t\t\t\tfree(clipboard->req_fdata);\n\t\t\t}\n\t\t\telse\n\t\t\t\tsuccess = TRUE;\n\t\t}\n\t}\n\n\tif (!success)\n\t{\n\t\tCliprdrStream_Delete(instance);\n\t\tinstance = NULL;\n\t}\n\n\treturn instance;\n}\n\nvoid CliprdrStream_Delete(CliprdrStream* instance)\n{\n\tif (instance)\n\t{\n\t\tfree(instance->iStream.lpVtbl);\n\t\tfree(instance);\n\t}\n}\n\n/**\n * IDataObject\n */\n\nstatic LONG cliprdr_lookup_format(CliprdrDataObject* instance, FORMATETC* pFormatEtc)\n{\n\tULONG i;\n\n\tif (!instance || !pFormatEtc)\n\t\treturn -1;\n\n\tfor (i = 0; i < instance->m_nNumFormats; i++)\n\t{\n\t\tif ((pFormatEtc->tymed & instance->m_pFormatEtc[i].tymed) &&\n\t\t    pFormatEtc->cfFormat == instance->m_pFormatEtc[i].cfFormat &&\n\t\t    pFormatEtc->dwAspect & instance->m_pFormatEtc[i].dwAspect)\n\t\t{\n\t\t\treturn (LONG)i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_QueryInterface(IDataObject* This, REFIID riid,\n                                                                  void** ppvObject)\n{\n\t(void)This;\n\n\tif (!ppvObject)\n\t\treturn E_INVALIDARG;\n\n\tif (IsEqualIID(riid, &IID_IDataObject) || IsEqualIID(riid, &IID_IUnknown))\n\t{\n\t\tIDataObject_AddRef(This);\n\t\t*ppvObject = This;\n\t\treturn S_OK;\n\t}\n\telse\n\t{\n\t\t*ppvObject = 0;\n\t\treturn E_NOINTERFACE;\n\t}\n}\n\nstatic ULONG STDMETHODCALLTYPE CliprdrDataObject_AddRef(IDataObject* This)\n{\n\tCliprdrDataObject* instance = (CliprdrDataObject*)This;\n\n\tif (!instance)\n\t\treturn E_INVALIDARG;\n\n\treturn InterlockedIncrement(&instance->m_lRefCount);\n}\n\nstatic ULONG STDMETHODCALLTYPE CliprdrDataObject_Release(IDataObject* This)\n{\n\tLONG count;\n\tCliprdrDataObject* instance = (CliprdrDataObject*)This;\n\n\tif (!instance)\n\t\treturn E_INVALIDARG;\n\n\tcount = InterlockedDecrement(&instance->m_lRefCount);\n\n\tif (count == 0)\n\t{\n\t\tCliprdrDataObject_Delete(instance);\n\t\treturn 0;\n\t}\n\telse\n\t\treturn count;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_GetData(IDataObject* This, FORMATETC* pFormatEtc,\n                                                           STGMEDIUM* pMedium)\n{\n\tULONG i;\n\tLONG idx;\n\tCliprdrDataObject* instance = (CliprdrDataObject*)This;\n\twfClipboard* clipboard;\n\n\tif (!pFormatEtc || !pMedium || !instance)\n\t\treturn E_INVALIDARG;\n\n\tclipboard = (wfClipboard*)instance->m_pData;\n\n\tif (!clipboard)\n\t\treturn E_INVALIDARG;\n\n\tif ((idx = cliprdr_lookup_format(instance, pFormatEtc)) == -1)\n\t\treturn DV_E_FORMATETC;\n\n\tpMedium->tymed = instance->m_pFormatEtc[idx].tymed;\n\tpMedium->pUnkForRelease = 0;\n\n\tif (instance->m_pFormatEtc[idx].cfFormat == RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW))\n\t{\n\t\tFILEGROUPDESCRIPTOR* dsc;\n\t\tDWORD remote = get_remote_format_id(clipboard, instance->m_pFormatEtc[idx].cfFormat);\n\n\t\tif (cliprdr_send_data_request(clipboard, remote) != 0)\n\t\t\treturn E_UNEXPECTED;\n\n\t\tpMedium->hGlobal = clipboard->hmem; /* points to a FILEGROUPDESCRIPTOR structure */\n\t\t/* GlobalLock returns a pointer to the first byte of the memory block,\n\t\t * in which is a FILEGROUPDESCRIPTOR structure, whose first UINT member\n\t\t * is the number of FILEDESCRIPTOR's */\n\t\tdsc = (FILEGROUPDESCRIPTOR*)GlobalLock(clipboard->hmem);\n\t\tinstance->m_nStreams = dsc->cItems;\n\t\tGlobalUnlock(clipboard->hmem);\n\n\t\tif (instance->m_nStreams > 0)\n\t\t{\n\t\t\tif (!instance->m_pStream)\n\t\t\t{\n\t\t\t\tinstance->m_pStream = (LPSTREAM*)calloc(instance->m_nStreams, sizeof(LPSTREAM));\n\n\t\t\t\tif (instance->m_pStream)\n\t\t\t\t{\n\t\t\t\t\tfor (i = 0; i < instance->m_nStreams; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tinstance->m_pStream[i] =\n\t\t\t\t\t\t    (IStream*)CliprdrStream_New(i, clipboard, &dsc->fgd[i]);\n\n\t\t\t\t\t\tif (!instance->m_pStream[i])\n\t\t\t\t\t\t\treturn E_OUTOFMEMORY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!instance->m_pStream)\n\t\t{\n\t\t\tif (clipboard->hmem)\n\t\t\t{\n\t\t\t\tGlobalFree(clipboard->hmem);\n\t\t\t\tclipboard->hmem = NULL;\n\t\t\t}\n\n\t\t\tpMedium->hGlobal = NULL;\n\t\t\treturn E_OUTOFMEMORY;\n\t\t}\n\t}\n\telse if (instance->m_pFormatEtc[idx].cfFormat == RegisterClipboardFormat(CFSTR_FILECONTENTS))\n\t{\n\t\tif ((pFormatEtc->lindex >= 0) && ((ULONG)pFormatEtc->lindex < instance->m_nStreams))\n\t\t{\n\t\t\tpMedium->pstm = instance->m_pStream[pFormatEtc->lindex];\n\t\t\tIDataObject_AddRef(instance->m_pStream[pFormatEtc->lindex]);\n\t\t}\n\t\telse\n\t\t\treturn E_INVALIDARG;\n\t}\n\telse\n\t\treturn E_UNEXPECTED;\n\n\treturn S_OK;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_GetDataHere(IDataObject* This,\n                                                               FORMATETC* pformatetc,\n                                                               STGMEDIUM* pmedium)\n{\n\t(void)This;\n\t(void)pformatetc;\n\t(void)pmedium;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_QueryGetData(IDataObject* This,\n                                                                FORMATETC* pformatetc)\n{\n\tCliprdrDataObject* instance = (CliprdrDataObject*)This;\n\n\tif (!pformatetc)\n\t\treturn E_INVALIDARG;\n\n\tif (cliprdr_lookup_format(instance, pformatetc) == -1)\n\t\treturn DV_E_FORMATETC;\n\n\treturn S_OK;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_GetCanonicalFormatEtc(IDataObject* This,\n                                                                         FORMATETC* pformatectIn,\n                                                                         FORMATETC* pformatetcOut)\n{\n\t(void)This;\n\t(void)pformatectIn;\n\n\tif (!pformatetcOut)\n\t\treturn E_INVALIDARG;\n\n\tpformatetcOut->ptd = NULL;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_SetData(IDataObject* This, FORMATETC* pformatetc,\n                                                           STGMEDIUM* pmedium, BOOL fRelease)\n{\n\t(void)This;\n\t(void)pformatetc;\n\t(void)pmedium;\n\t(void)fRelease;\n\treturn E_NOTIMPL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_EnumFormatEtc(IDataObject* This,\n                                                                 DWORD dwDirection,\n                                                                 IEnumFORMATETC** ppenumFormatEtc)\n{\n\tCliprdrDataObject* instance = (CliprdrDataObject*)This;\n\n\tif (!instance || !ppenumFormatEtc)\n\t\treturn E_INVALIDARG;\n\n\tif (dwDirection == DATADIR_GET)\n\t{\n\t\t*ppenumFormatEtc = (IEnumFORMATETC*)CliprdrEnumFORMATETC_New(instance->m_nNumFormats,\n\t\t                                                             instance->m_pFormatEtc);\n\t\treturn (*ppenumFormatEtc) ? S_OK : E_OUTOFMEMORY;\n\t}\n\telse\n\t{\n\t\treturn E_NOTIMPL;\n\t}\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_DAdvise(IDataObject* This, FORMATETC* pformatetc,\n                                                           DWORD advf, IAdviseSink* pAdvSink,\n                                                           DWORD* pdwConnection)\n{\n\t(void)This;\n\t(void)pformatetc;\n\t(void)advf;\n\t(void)pAdvSink;\n\t(void)pdwConnection;\n\treturn OLE_E_ADVISENOTSUPPORTED;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_DUnadvise(IDataObject* This, DWORD dwConnection)\n{\n\t(void)This;\n\t(void)dwConnection;\n\treturn OLE_E_ADVISENOTSUPPORTED;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrDataObject_EnumDAdvise(IDataObject* This,\n                                                               IEnumSTATDATA** ppenumAdvise)\n{\n\t(void)This;\n\t(void)ppenumAdvise;\n\treturn OLE_E_ADVISENOTSUPPORTED;\n}\n\nstatic CliprdrDataObject* CliprdrDataObject_New(FORMATETC* fmtetc, STGMEDIUM* stgmed, ULONG count,\n                                                void* data)\n{\n\tCliprdrDataObject* instance;\n\tIDataObject* iDataObject;\n\tinstance = (CliprdrDataObject*)calloc(1, sizeof(CliprdrDataObject));\n\n\tif (!instance)\n\t\tgoto error;\n\n\tiDataObject = &instance->iDataObject;\n\tiDataObject->lpVtbl = (IDataObjectVtbl*)calloc(1, sizeof(IDataObjectVtbl));\n\n\tif (!iDataObject->lpVtbl)\n\t\tgoto error;\n\n\tiDataObject->lpVtbl->QueryInterface = CliprdrDataObject_QueryInterface;\n\tiDataObject->lpVtbl->AddRef = CliprdrDataObject_AddRef;\n\tiDataObject->lpVtbl->Release = CliprdrDataObject_Release;\n\tiDataObject->lpVtbl->GetData = CliprdrDataObject_GetData;\n\tiDataObject->lpVtbl->GetDataHere = CliprdrDataObject_GetDataHere;\n\tiDataObject->lpVtbl->QueryGetData = CliprdrDataObject_QueryGetData;\n\tiDataObject->lpVtbl->GetCanonicalFormatEtc = CliprdrDataObject_GetCanonicalFormatEtc;\n\tiDataObject->lpVtbl->SetData = CliprdrDataObject_SetData;\n\tiDataObject->lpVtbl->EnumFormatEtc = CliprdrDataObject_EnumFormatEtc;\n\tiDataObject->lpVtbl->DAdvise = CliprdrDataObject_DAdvise;\n\tiDataObject->lpVtbl->DUnadvise = CliprdrDataObject_DUnadvise;\n\tiDataObject->lpVtbl->EnumDAdvise = CliprdrDataObject_EnumDAdvise;\n\tinstance->m_lRefCount = 1;\n\tinstance->m_nNumFormats = count;\n\tinstance->m_pData = data;\n\tinstance->m_nStreams = 0;\n\tinstance->m_pStream = NULL;\n\n\tif (count > 0)\n\t{\n\t\tULONG i;\n\t\tinstance->m_pFormatEtc = (FORMATETC*)calloc(count, sizeof(FORMATETC));\n\n\t\tif (!instance->m_pFormatEtc)\n\t\t\tgoto error;\n\n\t\tinstance->m_pStgMedium = (STGMEDIUM*)calloc(count, sizeof(STGMEDIUM));\n\n\t\tif (!instance->m_pStgMedium)\n\t\t\tgoto error;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tinstance->m_pFormatEtc[i] = fmtetc[i];\n\t\t\tinstance->m_pStgMedium[i] = stgmed[i];\n\t\t}\n\t}\n\n\treturn instance;\nerror:\n\tCliprdrDataObject_Delete(instance);\n\treturn NULL;\n}\n\nvoid CliprdrDataObject_Delete(CliprdrDataObject* instance)\n{\n\tif (instance)\n\t{\n\t\tfree(instance->iDataObject.lpVtbl);\n\t\tfree(instance->m_pFormatEtc);\n\t\tfree(instance->m_pStgMedium);\n\n\t\tif (instance->m_pStream)\n\t\t{\n\t\t\tULONG i;\n\n\t\t\tfor (i = 0; i < instance->m_nStreams; i++)\n\t\t\t\tCliprdrStream_Release(instance->m_pStream[i]);\n\n\t\t\tfree(instance->m_pStream);\n\t\t}\n\n\t\tfree(instance);\n\t}\n}\n\nstatic BOOL wf_create_file_obj(wfClipboard* clipboard, IDataObject** ppDataObject)\n{\n\tFORMATETC fmtetc[2];\n\tSTGMEDIUM stgmeds[2];\n\n\tif (!ppDataObject)\n\t\treturn FALSE;\n\n\tfmtetc[0].cfFormat = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);\n\tfmtetc[0].dwAspect = DVASPECT_CONTENT;\n\tfmtetc[0].lindex = 0;\n\tfmtetc[0].ptd = NULL;\n\tfmtetc[0].tymed = TYMED_HGLOBAL;\n\tstgmeds[0].tymed = TYMED_HGLOBAL;\n\tstgmeds[0].hGlobal = NULL;\n\tstgmeds[0].pUnkForRelease = NULL;\n\tfmtetc[1].cfFormat = RegisterClipboardFormat(CFSTR_FILECONTENTS);\n\tfmtetc[1].dwAspect = DVASPECT_CONTENT;\n\tfmtetc[1].lindex = 0;\n\tfmtetc[1].ptd = NULL;\n\tfmtetc[1].tymed = TYMED_ISTREAM;\n\tstgmeds[1].tymed = TYMED_ISTREAM;\n\tstgmeds[1].pstm = NULL;\n\tstgmeds[1].pUnkForRelease = NULL;\n\t*ppDataObject = (IDataObject*)CliprdrDataObject_New(fmtetc, stgmeds, 2, clipboard);\n\treturn (*ppDataObject) ? TRUE : FALSE;\n}\n\nstatic void wf_destroy_file_obj(IDataObject* instance)\n{\n\tif (instance)\n\t\tIDataObject_Release(instance);\n}\n\n/**\n * IEnumFORMATETC\n */\n\nstatic void cliprdr_format_deep_copy(FORMATETC* dest, FORMATETC* source)\n{\n\t*dest = *source;\n\n\tif (source->ptd)\n\t{\n\t\tdest->ptd = (DVTARGETDEVICE*)CoTaskMemAlloc(sizeof(DVTARGETDEVICE));\n\n\t\tif (dest->ptd)\n\t\t\t*(dest->ptd) = *(source->ptd);\n\t}\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrEnumFORMATETC_QueryInterface(IEnumFORMATETC* This,\n                                                                     REFIID riid, void** ppvObject)\n{\n\t(void)This;\n\n\tif (IsEqualIID(riid, &IID_IEnumFORMATETC) || IsEqualIID(riid, &IID_IUnknown))\n\t{\n\t\tIEnumFORMATETC_AddRef(This);\n\t\t*ppvObject = This;\n\t\treturn S_OK;\n\t}\n\telse\n\t{\n\t\t*ppvObject = 0;\n\t\treturn E_NOINTERFACE;\n\t}\n}\n\nstatic ULONG STDMETHODCALLTYPE CliprdrEnumFORMATETC_AddRef(IEnumFORMATETC* This)\n{\n\tCliprdrEnumFORMATETC* instance = (CliprdrEnumFORMATETC*)This;\n\n\tif (!instance)\n\t\treturn 0;\n\n\treturn InterlockedIncrement(&instance->m_lRefCount);\n}\n\nstatic ULONG STDMETHODCALLTYPE CliprdrEnumFORMATETC_Release(IEnumFORMATETC* This)\n{\n\tLONG count;\n\tCliprdrEnumFORMATETC* instance = (CliprdrEnumFORMATETC*)This;\n\n\tif (!instance)\n\t\treturn 0;\n\n\tcount = InterlockedDecrement(&instance->m_lRefCount);\n\n\tif (count == 0)\n\t{\n\t\tCliprdrEnumFORMATETC_Delete(instance);\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn count;\n\t}\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrEnumFORMATETC_Next(IEnumFORMATETC* This, ULONG celt,\n                                                           FORMATETC* rgelt, ULONG* pceltFetched)\n{\n\tULONG copied = 0;\n\tCliprdrEnumFORMATETC* instance = (CliprdrEnumFORMATETC*)This;\n\n\tif (!instance || !celt || !rgelt)\n\t\treturn E_INVALIDARG;\n\n\twhile ((instance->m_nIndex < instance->m_nNumFormats) && (copied < celt))\n\t{\n\t\tcliprdr_format_deep_copy(&rgelt[copied++], &instance->m_pFormatEtc[instance->m_nIndex++]);\n\t}\n\n\tif (pceltFetched != 0)\n\t\t*pceltFetched = copied;\n\n\treturn (copied == celt) ? S_OK : E_FAIL;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrEnumFORMATETC_Skip(IEnumFORMATETC* This, ULONG celt)\n{\n\tCliprdrEnumFORMATETC* instance = (CliprdrEnumFORMATETC*)This;\n\n\tif (!instance)\n\t\treturn E_INVALIDARG;\n\n\tif (instance->m_nIndex + (LONG)celt > instance->m_nNumFormats)\n\t\treturn E_FAIL;\n\n\tinstance->m_nIndex += celt;\n\treturn S_OK;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrEnumFORMATETC_Reset(IEnumFORMATETC* This)\n{\n\tCliprdrEnumFORMATETC* instance = (CliprdrEnumFORMATETC*)This;\n\n\tif (!instance)\n\t\treturn E_INVALIDARG;\n\n\tinstance->m_nIndex = 0;\n\treturn S_OK;\n}\n\nstatic HRESULT STDMETHODCALLTYPE CliprdrEnumFORMATETC_Clone(IEnumFORMATETC* This,\n                                                            IEnumFORMATETC** ppEnum)\n{\n\tCliprdrEnumFORMATETC* instance = (CliprdrEnumFORMATETC*)This;\n\n\tif (!instance || !ppEnum)\n\t\treturn E_INVALIDARG;\n\n\t*ppEnum =\n\t    (IEnumFORMATETC*)CliprdrEnumFORMATETC_New(instance->m_nNumFormats, instance->m_pFormatEtc);\n\n\tif (!*ppEnum)\n\t\treturn E_OUTOFMEMORY;\n\n\t((CliprdrEnumFORMATETC*)*ppEnum)->m_nIndex = instance->m_nIndex;\n\treturn S_OK;\n}\n\nCliprdrEnumFORMATETC* CliprdrEnumFORMATETC_New(ULONG nFormats, FORMATETC* pFormatEtc)\n{\n\tULONG i;\n\tCliprdrEnumFORMATETC* instance;\n\tIEnumFORMATETC* iEnumFORMATETC;\n\n\tif ((nFormats != 0) && !pFormatEtc)\n\t\treturn NULL;\n\n\tinstance = (CliprdrEnumFORMATETC*)calloc(1, sizeof(CliprdrEnumFORMATETC));\n\n\tif (!instance)\n\t\tgoto error;\n\n\tiEnumFORMATETC = &instance->iEnumFORMATETC;\n\tiEnumFORMATETC->lpVtbl = (IEnumFORMATETCVtbl*)calloc(1, sizeof(IEnumFORMATETCVtbl));\n\n\tif (!iEnumFORMATETC->lpVtbl)\n\t\tgoto error;\n\n\tiEnumFORMATETC->lpVtbl->QueryInterface = CliprdrEnumFORMATETC_QueryInterface;\n\tiEnumFORMATETC->lpVtbl->AddRef = CliprdrEnumFORMATETC_AddRef;\n\tiEnumFORMATETC->lpVtbl->Release = CliprdrEnumFORMATETC_Release;\n\tiEnumFORMATETC->lpVtbl->Next = CliprdrEnumFORMATETC_Next;\n\tiEnumFORMATETC->lpVtbl->Skip = CliprdrEnumFORMATETC_Skip;\n\tiEnumFORMATETC->lpVtbl->Reset = CliprdrEnumFORMATETC_Reset;\n\tiEnumFORMATETC->lpVtbl->Clone = CliprdrEnumFORMATETC_Clone;\n\tinstance->m_lRefCount = 1;\n\tinstance->m_nIndex = 0;\n\tinstance->m_nNumFormats = nFormats;\n\n\tif (nFormats > 0)\n\t{\n\t\tinstance->m_pFormatEtc = (FORMATETC*)calloc(nFormats, sizeof(FORMATETC));\n\n\t\tif (!instance->m_pFormatEtc)\n\t\t\tgoto error;\n\n\t\tfor (i = 0; i < nFormats; i++)\n\t\t\tcliprdr_format_deep_copy(&instance->m_pFormatEtc[i], &pFormatEtc[i]);\n\t}\n\n\treturn instance;\nerror:\n\tCliprdrEnumFORMATETC_Delete(instance);\n\treturn NULL;\n}\n\nvoid CliprdrEnumFORMATETC_Delete(CliprdrEnumFORMATETC* instance)\n{\n\tLONG i;\n\n\tif (instance)\n\t{\n\t\tfree(instance->iEnumFORMATETC.lpVtbl);\n\n\t\tif (instance->m_pFormatEtc)\n\t\t{\n\t\t\tfor (i = 0; i < instance->m_nNumFormats; i++)\n\t\t\t{\n\t\t\t\tif (instance->m_pFormatEtc[i].ptd)\n\t\t\t\t\tCoTaskMemFree(instance->m_pFormatEtc[i].ptd);\n\t\t\t}\n\n\t\t\tfree(instance->m_pFormatEtc);\n\t\t}\n\n\t\tfree(instance);\n\t}\n}\n\n/***********************************************************************************/\n\nstatic UINT32 get_local_format_id_by_name(wfClipboard* clipboard, const TCHAR* format_name)\n{\n\tsize_t i;\n\tformatMapping* map;\n\tWCHAR* unicode_name;\n#if !defined(UNICODE)\n\tsize_t size;\n#endif\n\n\tif (!clipboard || !format_name)\n\t\treturn 0;\n\n#if defined(UNICODE)\n\tunicode_name = _wcsdup(format_name);\n#else\n\tsize = _tcslen(format_name);\n\tunicode_name = calloc(size + 1, sizeof(WCHAR));\n\n\tif (!unicode_name)\n\t\treturn 0;\n\n\tMultiByteToWideChar(CP_OEMCP, 0, format_name, strlen(format_name), unicode_name, size);\n#endif\n\n\tif (!unicode_name)\n\t\treturn 0;\n\n\tfor (i = 0; i < clipboard->map_size; i++)\n\t{\n\t\tmap = &clipboard->format_mappings[i];\n\n\t\tif (map->name)\n\t\t{\n\t\t\tif (wcscmp(map->name, unicode_name) == 0)\n\t\t\t{\n\t\t\t\tfree(unicode_name);\n\t\t\t\treturn map->local_format_id;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(unicode_name);\n\treturn 0;\n}\n\nstatic INLINE BOOL file_transferring(wfClipboard* clipboard)\n{\n\treturn get_local_format_id_by_name(clipboard, CFSTR_FILEDESCRIPTORW) ? TRUE : FALSE;\n}\n\nstatic UINT32 get_remote_format_id(wfClipboard* clipboard, UINT32 local_format)\n{\n\tUINT32 i;\n\tformatMapping* map;\n\n\tif (!clipboard)\n\t\treturn 0;\n\n\tfor (i = 0; i < clipboard->map_size; i++)\n\t{\n\t\tmap = &clipboard->format_mappings[i];\n\n\t\tif (map->local_format_id == local_format)\n\t\t\treturn map->remote_format_id;\n\t}\n\n\treturn local_format;\n}\n\nstatic void map_ensure_capacity(wfClipboard* clipboard)\n{\n\tif (!clipboard)\n\t\treturn;\n\n\tif (clipboard->map_size >= clipboard->map_capacity)\n\t{\n\t\tsize_t new_size;\n\t\tformatMapping* new_map;\n\t\tnew_size = clipboard->map_capacity * 2;\n\t\tnew_map =\n\t\t    (formatMapping*)realloc(clipboard->format_mappings, sizeof(formatMapping) * new_size);\n\n\t\tif (!new_map)\n\t\t\treturn;\n\n\t\tclipboard->format_mappings = new_map;\n\t\tclipboard->map_capacity = new_size;\n\t}\n}\n\nstatic BOOL clear_format_map(wfClipboard* clipboard)\n{\n\tsize_t i;\n\tformatMapping* map;\n\n\tif (!clipboard)\n\t\treturn FALSE;\n\n\tif (clipboard->format_mappings)\n\t{\n\t\tfor (i = 0; i < clipboard->map_capacity; i++)\n\t\t{\n\t\t\tmap = &clipboard->format_mappings[i];\n\t\t\tmap->remote_format_id = 0;\n\t\t\tmap->local_format_id = 0;\n\t\t\tfree(map->name);\n\t\t\tmap->name = NULL;\n\t\t}\n\t}\n\n\tclipboard->map_size = 0;\n\treturn TRUE;\n}\n\nstatic UINT cliprdr_send_tempdir(wfClipboard* clipboard)\n{\n\tCLIPRDR_TEMP_DIRECTORY tempDirectory;\n\n\tif (!clipboard)\n\t\treturn -1;\n\n\tif (GetEnvironmentVariableA(\"TEMP\", tempDirectory.szTempDir, sizeof(tempDirectory.szTempDir)) ==\n\t    0)\n\t\treturn -1;\n\n\treturn clipboard->context->TempDirectory(clipboard->context, &tempDirectory);\n}\n\nstatic BOOL cliprdr_GetUpdatedClipboardFormats(wfClipboard* clipboard, PUINT lpuiFormats,\n                                               UINT cFormats, PUINT pcFormatsOut)\n{\n\tUINT index = 0;\n\tUINT format = 0;\n\tBOOL clipboardOpen = FALSE;\n\n\tif (!clipboard->legacyApi)\n\t\treturn clipboard->GetUpdatedClipboardFormats(lpuiFormats, cFormats, pcFormatsOut);\n\n\tclipboardOpen = try_open_clipboard(clipboard->hwnd);\n\n\tif (!clipboardOpen)\n\t{\n\t\t*pcFormatsOut = 0;\n\t\treturn TRUE; /* Other app holding clipboard */\n\t}\n\n\twhile (index < cFormats)\n\t{\n\t\tformat = EnumClipboardFormats(format);\n\n\t\tif (!format)\n\t\t\tbreak;\n\n\t\tlpuiFormats[index] = format;\n\t\tindex++;\n\t}\n\n\t*pcFormatsOut = index;\n\tCloseClipboard();\n\treturn TRUE;\n}\n\nstatic UINT cliprdr_send_format_list(wfClipboard* clipboard)\n{\n\tUINT rc;\n\tint count = 0;\n\tUINT32 index;\n\tUINT32 numFormats = 0;\n\tUINT32 formatId = 0;\n\tchar formatName[1024];\n\tCLIPRDR_FORMAT* formats = NULL;\n\tCLIPRDR_FORMAT_LIST formatList = { 0 };\n\n\tif (!clipboard)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tZeroMemory(&formatList, sizeof(CLIPRDR_FORMAT_LIST));\n\n\t/* Ignore if other app is holding clipboard */\n\tif (try_open_clipboard(clipboard->hwnd))\n\t{\n\t\tcount = CountClipboardFormats();\n\t\tnumFormats = (UINT32)count;\n\t\tformats = (CLIPRDR_FORMAT*)calloc(numFormats, sizeof(CLIPRDR_FORMAT));\n\n\t\tif (!formats)\n\t\t{\n\t\t\tCloseClipboard();\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tindex = 0;\n\n\t\tif (IsClipboardFormatAvailable(CF_HDROP))\n\t\t{\n\t\t\tformats[index++].formatId = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);\n\t\t\tformats[index++].formatId = RegisterClipboardFormat(CFSTR_FILECONTENTS);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (formatId = EnumClipboardFormats(formatId))\n\t\t\t\tformats[index++].formatId = formatId;\n\t\t}\n\n\t\tnumFormats = index;\n\n\t\tif (!CloseClipboard())\n\t\t{\n\t\t\tfree(formats);\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t}\n\n\t\tfor (index = 0; index < numFormats; index++)\n\t\t{\n\t\t\tif (GetClipboardFormatNameA(formats[index].formatId, formatName, sizeof(formatName)))\n\t\t\t{\n\t\t\t\tformats[index].formatName = _strdup(formatName);\n\t\t\t}\n\t\t}\n\t}\n\n\tformatList.numFormats = numFormats;\n\tformatList.formats = formats;\n\tformatList.msgType = CB_FORMAT_LIST;\n\trc = clipboard->context->ClientFormatList(clipboard->context, &formatList);\n\n\tfor (index = 0; index < numFormats; index++)\n\t\tfree(formats[index].formatName);\n\n\tfree(formats);\n\treturn rc;\n}\n\nstatic UINT cliprdr_send_data_request(wfClipboard* clipboard, UINT32 formatId)\n{\n\tUINT rc;\n\tUINT32 remoteFormatId;\n\tCLIPRDR_FORMAT_DATA_REQUEST formatDataRequest;\n\n\tif (!clipboard || !clipboard->context || !clipboard->context->ClientFormatDataRequest)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tremoteFormatId = get_remote_format_id(clipboard, formatId);\n\n\tformatDataRequest.requestedFormatId = remoteFormatId;\n\tclipboard->requestedFormatId = formatId;\n\trc = clipboard->context->ClientFormatDataRequest(clipboard->context, &formatDataRequest);\n\n\tif (WaitForSingleObject(clipboard->response_data_event, INFINITE) != WAIT_OBJECT_0)\n\t\trc = ERROR_INTERNAL_ERROR;\n\telse if (!ResetEvent(clipboard->response_data_event))\n\t\trc = ERROR_INTERNAL_ERROR;\n\n\treturn rc;\n}\n\nUINT cliprdr_send_request_filecontents(wfClipboard* clipboard, const void* streamid, ULONG index,\n                                       UINT32 flag, DWORD positionhigh, DWORD positionlow,\n                                       ULONG nreq)\n{\n\tUINT rc;\n\tCLIPRDR_FILE_CONTENTS_REQUEST fileContentsRequest;\n\n\tif (!clipboard || !clipboard->context || !clipboard->context->ClientFileContentsRequest)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tfileContentsRequest.streamId = (UINT32)(ULONG_PTR)streamid;\n\tfileContentsRequest.listIndex = index;\n\tfileContentsRequest.dwFlags = flag;\n\tfileContentsRequest.nPositionLow = positionlow;\n\tfileContentsRequest.nPositionHigh = positionhigh;\n\tfileContentsRequest.cbRequested = nreq;\n\tfileContentsRequest.clipDataId = 0;\n\tfileContentsRequest.msgFlags = 0;\n\trc = clipboard->context->ClientFileContentsRequest(clipboard->context, &fileContentsRequest);\n\n\tif (WaitForSingleObject(clipboard->req_fevent, INFINITE) != WAIT_OBJECT_0)\n\t\trc = ERROR_INTERNAL_ERROR;\n\telse if (!ResetEvent(clipboard->req_fevent))\n\t\trc = ERROR_INTERNAL_ERROR;\n\n\treturn rc;\n}\n\nstatic UINT cliprdr_send_response_filecontents(wfClipboard* clipboard, UINT32 streamId, UINT32 size,\n                                               BYTE* data)\n{\n\tCLIPRDR_FILE_CONTENTS_RESPONSE fileContentsResponse;\n\n\tif (!clipboard || !clipboard->context || !clipboard->context->ClientFileContentsResponse)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tfileContentsResponse.streamId = streamId;\n\tfileContentsResponse.cbRequested = size;\n\tfileContentsResponse.requestedData = data;\n\tfileContentsResponse.msgFlags = CB_RESPONSE_OK;\n\treturn clipboard->context->ClientFileContentsResponse(clipboard->context,\n\t                                                      &fileContentsResponse);\n}\n\nstatic LRESULT CALLBACK cliprdr_proc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)\n{\n\tstatic wfClipboard* clipboard = NULL;\n\n\tswitch (Msg)\n\t{\n\t\tcase WM_CREATE:\n\t\t\tDEBUG_CLIPRDR(\"info: WM_CREATE\");\n\t\t\tclipboard = (wfClipboard*)((CREATESTRUCT*)lParam)->lpCreateParams;\n\t\t\tclipboard->hwnd = hWnd;\n\n\t\t\tif (!clipboard->legacyApi)\n\t\t\t\tclipboard->AddClipboardFormatListener(hWnd);\n\t\t\telse\n\t\t\t\tclipboard->hWndNextViewer = SetClipboardViewer(hWnd);\n\n\t\t\tbreak;\n\n\t\tcase WM_CLOSE:\n\t\t\tDEBUG_CLIPRDR(\"info: WM_CLOSE\");\n\n\t\t\tif (!clipboard->legacyApi)\n\t\t\t\tclipboard->RemoveClipboardFormatListener(hWnd);\n\n\t\t\tbreak;\n\n\t\tcase WM_DESTROY:\n\t\t\tif (clipboard->legacyApi)\n\t\t\t\tChangeClipboardChain(hWnd, clipboard->hWndNextViewer);\n\n\t\t\tbreak;\n\n\t\tcase WM_CLIPBOARDUPDATE:\n\t\t\tDEBUG_CLIPRDR(\"info: WM_CLIPBOARDUPDATE\");\n\n\t\t\tif (clipboard->sync)\n\t\t\t{\n\t\t\t\tif ((GetClipboardOwner() != clipboard->hwnd) &&\n\t\t\t\t    (S_FALSE == OleIsCurrentClipboard(clipboard->data_obj)))\n\t\t\t\t{\n\t\t\t\t\tif (clipboard->hmem)\n\t\t\t\t\t{\n\t\t\t\t\t\tGlobalFree(clipboard->hmem);\n\t\t\t\t\t\tclipboard->hmem = NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tcliprdr_send_format_list(clipboard);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase WM_RENDERALLFORMATS:\n\t\t\tDEBUG_CLIPRDR(\"info: WM_RENDERALLFORMATS\");\n\n\t\t\t/* discard all contexts in clipboard */\n\t\t\tif (!try_open_clipboard(clipboard->hwnd))\n\t\t\t{\n\t\t\t\tDEBUG_CLIPRDR(\"OpenClipboard failed with 0x%x\", GetLastError());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tEmptyClipboard();\n\t\t\tCloseClipboard();\n\t\t\tbreak;\n\n\t\tcase WM_RENDERFORMAT:\n\t\t\tDEBUG_CLIPRDR(\"info: WM_RENDERFORMAT\");\n\n\t\t\tif (cliprdr_send_data_request(clipboard, (UINT32)wParam) != 0)\n\t\t\t{\n\t\t\t\tDEBUG_CLIPRDR(\"error: cliprdr_send_data_request failed.\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!SetClipboardData((UINT)wParam, clipboard->hmem))\n\t\t\t{\n\t\t\t\tDEBUG_CLIPRDR(\"SetClipboardData failed with 0x%x\", GetLastError());\n\n\t\t\t\tif (clipboard->hmem)\n\t\t\t\t{\n\t\t\t\t\tGlobalFree(clipboard->hmem);\n\t\t\t\t\tclipboard->hmem = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Note: GlobalFree() is not needed when success */\n\t\t\tbreak;\n\n\t\tcase WM_DRAWCLIPBOARD:\n\t\t\tif (clipboard->legacyApi)\n\t\t\t{\n\t\t\t\tif ((GetClipboardOwner() != clipboard->hwnd) &&\n\t\t\t\t    (S_FALSE == OleIsCurrentClipboard(clipboard->data_obj)))\n\t\t\t\t{\n\t\t\t\t\tcliprdr_send_format_list(clipboard);\n\t\t\t\t}\n\n\t\t\t\tSendMessage(clipboard->hWndNextViewer, Msg, wParam, lParam);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase WM_CHANGECBCHAIN:\n\t\t\tif (clipboard->legacyApi)\n\t\t\t{\n\t\t\t\tHWND hWndCurrViewer = (HWND)wParam;\n\t\t\t\tHWND hWndNextViewer = (HWND)lParam;\n\n\t\t\t\tif (hWndCurrViewer == clipboard->hWndNextViewer)\n\t\t\t\t\tclipboard->hWndNextViewer = hWndNextViewer;\n\t\t\t\telse if (clipboard->hWndNextViewer)\n\t\t\t\t\tSendMessage(clipboard->hWndNextViewer, Msg, wParam, lParam);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase WM_CLIPRDR_MESSAGE:\n\t\t\tDEBUG_CLIPRDR(\"info: WM_CLIPRDR_MESSAGE\");\n\n\t\t\tswitch (wParam)\n\t\t\t{\n\t\t\t\tcase OLE_SETCLIPBOARD:\n\t\t\t\t\tDEBUG_CLIPRDR(\"info: OLE_SETCLIPBOARD\");\n\n\t\t\t\t\tif (S_FALSE == OleIsCurrentClipboard(clipboard->data_obj))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wf_create_file_obj(clipboard, &clipboard->data_obj))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (OleSetClipboard(clipboard->data_obj) != S_OK)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twf_destroy_file_obj(clipboard->data_obj);\n\t\t\t\t\t\t\t\tclipboard->data_obj = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase WM_DESTROYCLIPBOARD:\n\t\tcase WM_ASKCBFORMATNAME:\n\t\tcase WM_HSCROLLCLIPBOARD:\n\t\tcase WM_PAINTCLIPBOARD:\n\t\tcase WM_SIZECLIPBOARD:\n\t\tcase WM_VSCROLLCLIPBOARD:\n\t\tdefault:\n\t\t\treturn DefWindowProc(hWnd, Msg, wParam, lParam);\n\t}\n\n\treturn 0;\n}\n\nstatic int create_cliprdr_window(wfClipboard* clipboard)\n{\n\tWNDCLASSEX wnd_cls;\n\tZeroMemory(&wnd_cls, sizeof(WNDCLASSEX));\n\twnd_cls.cbSize = sizeof(WNDCLASSEX);\n\twnd_cls.style = CS_OWNDC;\n\twnd_cls.lpfnWndProc = cliprdr_proc;\n\twnd_cls.cbClsExtra = 0;\n\twnd_cls.cbWndExtra = 0;\n\twnd_cls.hIcon = NULL;\n\twnd_cls.hCursor = NULL;\n\twnd_cls.hbrBackground = NULL;\n\twnd_cls.lpszMenuName = NULL;\n\twnd_cls.lpszClassName = _T(\"ClipboardHiddenMessageProcessor\");\n\twnd_cls.hInstance = GetModuleHandle(NULL);\n\twnd_cls.hIconSm = NULL;\n\tRegisterClassEx(&wnd_cls);\n\tclipboard->hwnd =\n\t    CreateWindowEx(WS_EX_LEFT, _T(\"ClipboardHiddenMessageProcessor\"), _T(\"rdpclip\"), 0, 0, 0, 0,\n\t                   0, HWND_MESSAGE, NULL, GetModuleHandle(NULL), clipboard);\n\n\tif (!clipboard->hwnd)\n\t{\n\t\tDEBUG_CLIPRDR(\"error: CreateWindowEx failed with %x.\", GetLastError());\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic DWORD WINAPI cliprdr_thread_func(LPVOID arg)\n{\n\tint ret;\n\tMSG msg;\n\tBOOL mcode;\n\twfClipboard* clipboard = (wfClipboard*)arg;\n\tOleInitialize(0);\n\n\tif ((ret = create_cliprdr_window(clipboard)) != 0)\n\t{\n\t\tOleUninitialize();\n\t\tDEBUG_CLIPRDR(\"error: create clipboard window failed.\");\n\t\treturn 0;\n\t}\n\n\twhile ((mcode = GetMessage(&msg, 0, 0, 0)) != 0)\n\t{\n\t\tif (mcode == -1)\n\t\t{\n\t\t\tDEBUG_CLIPRDR(\"error: clipboard thread GetMessage failed.\");\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTranslateMessage(&msg);\n\t\t\tDispatchMessage(&msg);\n\t\t}\n\t}\n\n\tOleUninitialize();\n\treturn 0;\n}\n\nstatic void clear_file_array(wfClipboard* clipboard)\n{\n\tsize_t i;\n\n\tif (!clipboard)\n\t\treturn;\n\n\t/* clear file_names array */\n\tif (clipboard->file_names)\n\t{\n\t\tfor (i = 0; i < clipboard->nFiles; i++)\n\t\t{\n\t\t\tfree(clipboard->file_names[i]);\n\t\t\tclipboard->file_names[i] = NULL;\n\t\t}\n\n\t\tfree(clipboard->file_names);\n\t\tclipboard->file_names = NULL;\n\t}\n\n\t/* clear fileDescriptor array */\n\tif (clipboard->fileDescriptor)\n\t{\n\t\tfor (i = 0; i < clipboard->nFiles; i++)\n\t\t{\n\t\t\tfree(clipboard->fileDescriptor[i]);\n\t\t\tclipboard->fileDescriptor[i] = NULL;\n\t\t}\n\n\t\tfree(clipboard->fileDescriptor);\n\t\tclipboard->fileDescriptor = NULL;\n\t}\n\n\tclipboard->file_array_size = 0;\n\tclipboard->nFiles = 0;\n}\n\nstatic BOOL wf_cliprdr_get_file_contents(WCHAR* file_name, BYTE* buffer, LONG positionLow,\n                                         LONG positionHigh, DWORD nRequested, DWORD* puSize)\n{\n\tBOOL res = FALSE;\n\tHANDLE hFile;\n\tDWORD nGet, rc;\n\n\tif (!file_name || !buffer || !puSize)\n\t{\n\t\tWLog_ERR(TAG, \"get file contents Invalid Arguments.\");\n\t\treturn FALSE;\n\t}\n\n\thFile = CreateFileW(file_name, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,\n\t                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\n\tif (hFile == INVALID_HANDLE_VALUE)\n\t\treturn FALSE;\n\n\trc = SetFilePointer(hFile, positionLow, &positionHigh, FILE_BEGIN);\n\n\tif (rc == INVALID_SET_FILE_POINTER)\n\t\tgoto error;\n\n\tif (!ReadFile(hFile, buffer, nRequested, &nGet, NULL))\n\t{\n\t\tDEBUG_CLIPRDR(\"ReadFile failed with 0x%08lX.\", GetLastError());\n\t\tgoto error;\n\t}\n\n\tres = TRUE;\nerror:\n\n\tif (!CloseHandle(hFile))\n\t\tres = FALSE;\n\n\tif (res)\n\t\t*puSize = nGet;\n\n\treturn res;\n}\n\n/* path_name has a '\\' at the end. e.g. c:\\newfolder\\, file_name is c:\\newfolder\\new.txt */\nstatic FILEDESCRIPTORW* wf_cliprdr_get_file_descriptor(WCHAR* file_name, size_t pathLen)\n{\n\tHANDLE hFile;\n\tFILEDESCRIPTORW* fd;\n\tfd = (FILEDESCRIPTORW*)calloc(1, sizeof(FILEDESCRIPTORW));\n\n\tif (!fd)\n\t\treturn NULL;\n\n\thFile = CreateFileW(file_name, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,\n\t                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\n\tif (hFile == INVALID_HANDLE_VALUE)\n\t{\n\t\tfree(fd);\n\t\treturn NULL;\n\t}\n\n\tfd->dwFlags = FD_ATTRIBUTES | FD_FILESIZE | FD_WRITESTIME | FD_PROGRESSUI;\n\tfd->dwFileAttributes = GetFileAttributes(file_name);\n\n\tif (!GetFileTime(hFile, NULL, NULL, &fd->ftLastWriteTime))\n\t{\n\t\tfd->dwFlags &= ~FD_WRITESTIME;\n\t}\n\n\tfd->nFileSizeLow = GetFileSize(hFile, &fd->nFileSizeHigh);\n\twcscpy_s(fd->cFileName, sizeof(fd->cFileName) / 2, file_name + pathLen);\n\tCloseHandle(hFile);\n\treturn fd;\n}\n\nstatic BOOL wf_cliprdr_array_ensure_capacity(wfClipboard* clipboard)\n{\n\tif (!clipboard)\n\t\treturn FALSE;\n\n\tif (clipboard->nFiles == clipboard->file_array_size)\n\t{\n\t\tsize_t new_size;\n\t\tFILEDESCRIPTORW** new_fd;\n\t\tWCHAR** new_name;\n\t\tnew_size = (clipboard->file_array_size + 1) * 2;\n\t\tnew_fd = (FILEDESCRIPTORW**)realloc(clipboard->fileDescriptor,\n\t\t                                    new_size * sizeof(FILEDESCRIPTORW*));\n\n\t\tif (new_fd)\n\t\t\tclipboard->fileDescriptor = new_fd;\n\n\t\tnew_name = (WCHAR**)realloc(clipboard->file_names, new_size * sizeof(WCHAR*));\n\n\t\tif (new_name)\n\t\t\tclipboard->file_names = new_name;\n\n\t\tif (!new_fd || !new_name)\n\t\t\treturn FALSE;\n\n\t\tclipboard->file_array_size = new_size;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL wf_cliprdr_add_to_file_arrays(wfClipboard* clipboard, WCHAR* full_file_name,\n                                          size_t pathLen)\n{\n\tif (!wf_cliprdr_array_ensure_capacity(clipboard))\n\t\treturn FALSE;\n\n\t/* add to name array */\n\tclipboard->file_names[clipboard->nFiles] = (LPWSTR)malloc(MAX_PATH * 2);\n\n\tif (!clipboard->file_names[clipboard->nFiles])\n\t\treturn FALSE;\n\n\twcscpy_s(clipboard->file_names[clipboard->nFiles], MAX_PATH, full_file_name);\n\t/* add to descriptor array */\n\tclipboard->fileDescriptor[clipboard->nFiles] =\n\t    wf_cliprdr_get_file_descriptor(full_file_name, pathLen);\n\n\tif (!clipboard->fileDescriptor[clipboard->nFiles])\n\t{\n\t\tfree(clipboard->file_names[clipboard->nFiles]);\n\t\treturn FALSE;\n\t}\n\n\tclipboard->nFiles++;\n\treturn TRUE;\n}\n\nstatic BOOL wf_cliprdr_traverse_directory(wfClipboard* clipboard, WCHAR* Dir, size_t pathLen)\n{\n\tHANDLE hFind;\n\tWCHAR DirSpec[MAX_PATH];\n\tWIN32_FIND_DATA FindFileData;\n\n\tif (!clipboard || !Dir)\n\t\treturn FALSE;\n\n\tStringCchCopy(DirSpec, MAX_PATH, Dir);\n\tStringCchCat(DirSpec, MAX_PATH, TEXT(\"\\\\*\"));\n\thFind = FindFirstFile(DirSpec, &FindFileData);\n\n\tif (hFind == INVALID_HANDLE_VALUE)\n\t{\n\t\tDEBUG_CLIPRDR(\"FindFirstFile failed with 0x%x.\", GetLastError());\n\t\treturn FALSE;\n\t}\n\n\twhile (FindNextFile(hFind, &FindFileData))\n\t{\n\t\tif ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0 &&\n\t\t        wcscmp(FindFileData.cFileName, _T(\".\")) == 0 ||\n\t\t    wcscmp(FindFileData.cFileName, _T(\"..\")) == 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)\n\t\t{\n\t\t\tWCHAR DirAdd[MAX_PATH];\n\t\t\tStringCchCopy(DirAdd, MAX_PATH, Dir);\n\t\t\tStringCchCat(DirAdd, MAX_PATH, _T(\"\\\\\"));\n\t\t\tStringCchCat(DirAdd, MAX_PATH, FindFileData.cFileName);\n\n\t\t\tif (!wf_cliprdr_add_to_file_arrays(clipboard, DirAdd, pathLen))\n\t\t\t\treturn FALSE;\n\n\t\t\tif (!wf_cliprdr_traverse_directory(clipboard, DirAdd, pathLen))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWCHAR fileName[MAX_PATH];\n\t\t\tStringCchCopy(fileName, MAX_PATH, Dir);\n\t\t\tStringCchCat(fileName, MAX_PATH, _T(\"\\\\\"));\n\t\t\tStringCchCat(fileName, MAX_PATH, FindFileData.cFileName);\n\n\t\t\tif (!wf_cliprdr_add_to_file_arrays(clipboard, fileName, pathLen))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tFindClose(hFind);\n\treturn TRUE;\n}\n\nstatic UINT wf_cliprdr_send_client_capabilities(wfClipboard* clipboard)\n{\n\tCLIPRDR_CAPABILITIES capabilities;\n\tCLIPRDR_GENERAL_CAPABILITY_SET generalCapabilitySet;\n\n\tif (!clipboard || !clipboard->context || !clipboard->context->ClientCapabilities)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tcapabilities.cCapabilitiesSets = 1;\n\tcapabilities.capabilitySets = (CLIPRDR_CAPABILITY_SET*)&(generalCapabilitySet);\n\tgeneralCapabilitySet.capabilitySetType = CB_CAPSTYPE_GENERAL;\n\tgeneralCapabilitySet.capabilitySetLength = 12;\n\tgeneralCapabilitySet.version = CB_CAPS_VERSION_2;\n\tgeneralCapabilitySet.generalFlags =\n\t    CB_USE_LONG_FORMAT_NAMES | CB_STREAM_FILECLIP_ENABLED | CB_FILECLIP_NO_FILE_PATHS;\n\treturn clipboard->context->ClientCapabilities(clipboard->context, &capabilities);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT wf_cliprdr_monitor_ready(CliprdrClientContext* context,\n                                     const CLIPRDR_MONITOR_READY* monitorReady)\n{\n\tUINT rc;\n\twfClipboard* clipboard = (wfClipboard*)context->custom;\n\n\tif (!context || !monitorReady)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tclipboard->sync = TRUE;\n\trc = wf_cliprdr_send_client_capabilities(clipboard);\n\n\tif (rc != CHANNEL_RC_OK)\n\t\treturn rc;\n\n\treturn cliprdr_send_format_list(clipboard);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT wf_cliprdr_server_capabilities(CliprdrClientContext* context,\n                                           const CLIPRDR_CAPABILITIES* capabilities)\n{\n\tUINT32 index;\n\tCLIPRDR_CAPABILITY_SET* capabilitySet;\n\twfClipboard* clipboard = (wfClipboard*)context->custom;\n\n\tif (!context || !capabilities)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tfor (index = 0; index < capabilities->cCapabilitiesSets; index++)\n\t{\n\t\tcapabilitySet = &(capabilities->capabilitySets[index]);\n\n\t\tif ((capabilitySet->capabilitySetType == CB_CAPSTYPE_GENERAL) &&\n\t\t    (capabilitySet->capabilitySetLength >= CB_CAPSTYPE_GENERAL_LEN))\n\t\t{\n\t\t\tCLIPRDR_GENERAL_CAPABILITY_SET* generalCapabilitySet =\n\t\t\t    (CLIPRDR_GENERAL_CAPABILITY_SET*)capabilitySet;\n\t\t\tclipboard->capabilities = generalCapabilitySet->generalFlags;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT wf_cliprdr_server_format_list(CliprdrClientContext* context,\n                                          const CLIPRDR_FORMAT_LIST* formatList)\n{\n\tUINT rc = ERROR_INTERNAL_ERROR;\n\tUINT32 i;\n\tformatMapping* mapping;\n\tCLIPRDR_FORMAT* format;\n\twfClipboard* clipboard = (wfClipboard*)context->custom;\n\n\tif (!clear_format_map(clipboard))\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tfor (i = 0; i < formatList->numFormats; i++)\n\t{\n\t\tformat = &(formatList->formats[i]);\n\t\tmapping = &(clipboard->format_mappings[i]);\n\t\tmapping->remote_format_id = format->formatId;\n\n\t\tif (format->formatName)\n\t\t{\n\t\t\tint size = MultiByteToWideChar(CP_UTF8, 0, format->formatName,\n\t\t\t                               strlen(format->formatName), NULL, 0);\n\t\t\tmapping->name = calloc(size + 1, sizeof(WCHAR));\n\n\t\t\tif (mapping->name)\n\t\t\t{\n\t\t\t\tMultiByteToWideChar(CP_UTF8, 0, format->formatName, strlen(format->formatName),\n\t\t\t\t                    mapping->name, size);\n\t\t\t\tmapping->local_format_id = RegisterClipboardFormatW((LPWSTR)mapping->name);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmapping->name = NULL;\n\t\t\tmapping->local_format_id = mapping->remote_format_id;\n\t\t}\n\n\t\tclipboard->map_size++;\n\t\tmap_ensure_capacity(clipboard);\n\t}\n\n\tif (file_transferring(clipboard))\n\t{\n\t\tif (PostMessage(clipboard->hwnd, WM_CLIPRDR_MESSAGE, OLE_SETCLIPBOARD, 0))\n\t\t\trc = CHANNEL_RC_OK;\n\t}\n\telse\n\t{\n\t\tif (!try_open_clipboard(clipboard->hwnd))\n\t\t\treturn CHANNEL_RC_OK; /* Ignore, other app holding clipboard */\n\n\t\tif (EmptyClipboard())\n\t\t{\n\t\t\tfor (i = 0; i < (UINT32)clipboard->map_size; i++)\n\t\t\t\tSetClipboardData(clipboard->format_mappings[i].local_format_id, NULL);\n\n\t\t\trc = CHANNEL_RC_OK;\n\t\t}\n\n\t\tif (!CloseClipboard() && GetLastError())\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn rc;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT\nwf_cliprdr_server_format_list_response(CliprdrClientContext* context,\n                                       const CLIPRDR_FORMAT_LIST_RESPONSE* formatListResponse)\n{\n\t(void)context;\n\t(void)formatListResponse;\n\n\tif (formatListResponse->msgFlags != CB_RESPONSE_OK)\n\t\treturn E_FAIL;\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT\nwf_cliprdr_server_lock_clipboard_data(CliprdrClientContext* context,\n                                      const CLIPRDR_LOCK_CLIPBOARD_DATA* lockClipboardData)\n{\n\t(void)context;\n\t(void)lockClipboardData;\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT\nwf_cliprdr_server_unlock_clipboard_data(CliprdrClientContext* context,\n                                        const CLIPRDR_UNLOCK_CLIPBOARD_DATA* unlockClipboardData)\n{\n\t(void)context;\n\t(void)unlockClipboardData;\n\treturn CHANNEL_RC_OK;\n}\n\nstatic BOOL wf_cliprdr_process_filename(wfClipboard* clipboard, WCHAR* wFileName, size_t str_len)\n{\n\tsize_t pathLen;\n\tsize_t offset = str_len;\n\n\tif (!clipboard || !wFileName)\n\t\treturn FALSE;\n\n\t/* find the last '\\' in full file name */\n\twhile (offset > 0)\n\t{\n\t\tif (wFileName[offset] == L'\\\\')\n\t\t\tbreak;\n\t\telse\n\t\t\toffset--;\n\t}\n\n\tpathLen = offset + 1;\n\n\tif (!wf_cliprdr_add_to_file_arrays(clipboard, wFileName, pathLen))\n\t\treturn FALSE;\n\n\tif ((clipboard->fileDescriptor[clipboard->nFiles - 1]->dwFileAttributes &\n\t     FILE_ATTRIBUTE_DIRECTORY) != 0)\n\t{\n\t\t/* this is a directory */\n\t\tif (!wf_cliprdr_traverse_directory(clipboard, wFileName, pathLen))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT\nwf_cliprdr_server_format_data_request(CliprdrClientContext* context,\n                                      const CLIPRDR_FORMAT_DATA_REQUEST* formatDataRequest)\n{\n\tUINT rc;\n\tsize_t size = 0;\n\tvoid* buff = NULL;\n\tchar* globlemem = NULL;\n\tHANDLE hClipdata = NULL;\n\tUINT32 requestedFormatId;\n\tCLIPRDR_FORMAT_DATA_RESPONSE response;\n\twfClipboard* clipboard;\n\n\tif (!context || !formatDataRequest)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tclipboard = (wfClipboard*)context->custom;\n\n\tif (!clipboard)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\trequestedFormatId = formatDataRequest->requestedFormatId;\n\n\tif (requestedFormatId == RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW))\n\t{\n\t\tsize_t len;\n\t\tsize_t i;\n\t\tWCHAR* wFileName;\n\t\tHRESULT result;\n\t\tLPDATAOBJECT dataObj;\n\t\tFORMATETC format_etc;\n\t\tSTGMEDIUM stg_medium;\n\t\tDROPFILES* dropFiles;\n\t\tFILEGROUPDESCRIPTORW* groupDsc;\n\t\tresult = OleGetClipboard(&dataObj);\n\n\t\tif (FAILED(result))\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\n\t\tZeroMemory(&format_etc, sizeof(FORMATETC));\n\t\tZeroMemory(&stg_medium, sizeof(STGMEDIUM));\n\t\t/* get DROPFILES struct from OLE */\n\t\tformat_etc.cfFormat = CF_HDROP;\n\t\tformat_etc.tymed = TYMED_HGLOBAL;\n\t\tformat_etc.dwAspect = 1;\n\t\tformat_etc.lindex = -1;\n\t\tresult = IDataObject_GetData(dataObj, &format_etc, &stg_medium);\n\n\t\tif (FAILED(result))\n\t\t{\n\t\t\tDEBUG_CLIPRDR(\"dataObj->GetData failed.\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tdropFiles = (DROPFILES*)GlobalLock(stg_medium.hGlobal);\n\n\t\tif (!dropFiles)\n\t\t{\n\t\t\tGlobalUnlock(stg_medium.hGlobal);\n\t\t\tReleaseStgMedium(&stg_medium);\n\t\t\tclipboard->nFiles = 0;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tclear_file_array(clipboard);\n\n\t\tif (dropFiles->fWide)\n\t\t{\n\t\t\t/* dropFiles contains file names */\n\t\t\tfor (wFileName = (WCHAR*)((char*)dropFiles + dropFiles->pFiles);\n\t\t\t     (len = wcslen(wFileName)) > 0; wFileName += len + 1)\n\t\t\t{\n\t\t\t\twf_cliprdr_process_filename(clipboard, wFileName, wcslen(wFileName));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar* p;\n\n\t\t\tfor (p = (char*)((char*)dropFiles + dropFiles->pFiles); (len = strlen(p)) > 0;\n\t\t\t     p += len + 1, clipboard->nFiles++)\n\t\t\t{\n\t\t\t\tint cchWideChar;\n\t\t\t\tWCHAR* wFileName;\n\t\t\t\tcchWideChar = MultiByteToWideChar(CP_ACP, MB_COMPOSITE, p, len, NULL, 0);\n\t\t\t\twFileName = (LPWSTR)calloc(cchWideChar, sizeof(WCHAR));\n\t\t\t\tMultiByteToWideChar(CP_ACP, MB_COMPOSITE, p, len, wFileName, cchWideChar);\n\t\t\t\twf_cliprdr_process_filename(clipboard, wFileName, cchWideChar);\n\t\t\t}\n\t\t}\n\n\t\tGlobalUnlock(stg_medium.hGlobal);\n\t\tReleaseStgMedium(&stg_medium);\n\texit:\n\t\tsize = 4 + clipboard->nFiles * sizeof(FILEDESCRIPTORW);\n\t\tgroupDsc = (FILEGROUPDESCRIPTORW*)malloc(size);\n\n\t\tif (groupDsc)\n\t\t{\n\t\t\tgroupDsc->cItems = clipboard->nFiles;\n\n\t\t\tfor (i = 0; i < clipboard->nFiles; i++)\n\t\t\t{\n\t\t\t\tif (clipboard->fileDescriptor[i])\n\t\t\t\t\tgroupDsc->fgd[i] = *clipboard->fileDescriptor[i];\n\t\t\t}\n\n\t\t\tbuff = groupDsc;\n\t\t}\n\n\t\tIDataObject_Release(dataObj);\n\t}\n\telse\n\t{\n\t\t/* Ignore if other app is holding the clipboard */\n\t\tif (try_open_clipboard(clipboard->hwnd))\n\t\t{\n\t\t\thClipdata = GetClipboardData(requestedFormatId);\n\n\t\t\tif (!hClipdata)\n\t\t\t{\n\t\t\t\tCloseClipboard();\n\t\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t\t}\n\n\t\t\tgloblemem = (char*)GlobalLock(hClipdata);\n\t\t\tsize = (int)GlobalSize(hClipdata);\n\t\t\tbuff = malloc(size);\n\t\t\tCopyMemory(buff, globlemem, size);\n\t\t\tGlobalUnlock(hClipdata);\n\t\t\tCloseClipboard();\n\t\t}\n\t}\n\n\tresponse.msgFlags = CB_RESPONSE_OK;\n\tresponse.dataLen = size;\n\tresponse.requestedFormatData = (BYTE*)buff;\n\trc = clipboard->context->ClientFormatDataResponse(clipboard->context, &response);\n\tfree(buff);\n\treturn rc;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT\nwf_cliprdr_server_format_data_response(CliprdrClientContext* context,\n                                       const CLIPRDR_FORMAT_DATA_RESPONSE* formatDataResponse)\n{\n\tBYTE* data;\n\tHANDLE hMem;\n\twfClipboard* clipboard;\n\n\tif (!context || !formatDataResponse)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tif (formatDataResponse->msgFlags != CB_RESPONSE_OK)\n\t\treturn E_FAIL;\n\n\tclipboard = (wfClipboard*)context->custom;\n\n\tif (!clipboard)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\thMem = GlobalAlloc(GMEM_MOVEABLE, formatDataResponse->dataLen);\n\n\tif (!hMem)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tdata = (BYTE*)GlobalLock(hMem);\n\n\tif (!data)\n\t{\n\t\tGlobalFree(hMem);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(data, formatDataResponse->requestedFormatData, formatDataResponse->dataLen);\n\n\tif (!GlobalUnlock(hMem) && GetLastError())\n\t{\n\t\tGlobalFree(hMem);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\tclipboard->hmem = hMem;\n\n\tif (!SetEvent(clipboard->response_data_event))\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT\nwf_cliprdr_server_file_contents_request(CliprdrClientContext* context,\n                                        const CLIPRDR_FILE_CONTENTS_REQUEST* fileContentsRequest)\n{\n\tDWORD uSize = 0;\n\tBYTE* pData = NULL;\n\tHRESULT hRet = S_OK;\n\tFORMATETC vFormatEtc;\n\tLPDATAOBJECT pDataObj = NULL;\n\tSTGMEDIUM vStgMedium;\n\tBOOL bIsStreamFile = TRUE;\n\tstatic LPSTREAM pStreamStc = NULL;\n\tstatic UINT32 uStreamIdStc = 0;\n\twfClipboard* clipboard;\n\tUINT rc = ERROR_INTERNAL_ERROR;\n\tUINT sRc;\n\tUINT32 cbRequested;\n\n\tif (!context || !fileContentsRequest)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tclipboard = (wfClipboard*)context->custom;\n\n\tif (!clipboard)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tcbRequested = fileContentsRequest->cbRequested;\n\tif (fileContentsRequest->dwFlags == FILECONTENTS_SIZE)\n\t\tcbRequested = sizeof(UINT64);\n\n\tpData = (BYTE*)calloc(1, cbRequested);\n\n\tif (!pData)\n\t\tgoto error;\n\n\thRet = OleGetClipboard(&pDataObj);\n\n\tif (FAILED(hRet))\n\t{\n\t\tWLog_ERR(TAG, \"filecontents: get ole clipboard failed.\");\n\t\tgoto error;\n\t}\n\n\tZeroMemory(&vFormatEtc, sizeof(FORMATETC));\n\tZeroMemory(&vStgMedium, sizeof(STGMEDIUM));\n\tvFormatEtc.cfFormat = RegisterClipboardFormat(CFSTR_FILECONTENTS);\n\tvFormatEtc.tymed = TYMED_ISTREAM;\n\tvFormatEtc.dwAspect = 1;\n\tvFormatEtc.lindex = fileContentsRequest->listIndex;\n\tvFormatEtc.ptd = NULL;\n\n\tif ((uStreamIdStc != fileContentsRequest->streamId) || !pStreamStc)\n\t{\n\t\tLPENUMFORMATETC pEnumFormatEtc;\n\t\tULONG CeltFetched;\n\t\tFORMATETC vFormatEtc2;\n\n\t\tif (pStreamStc)\n\t\t{\n\t\t\tIStream_Release(pStreamStc);\n\t\t\tpStreamStc = NULL;\n\t\t}\n\n\t\tbIsStreamFile = FALSE;\n\t\thRet = IDataObject_EnumFormatEtc(pDataObj, DATADIR_GET, &pEnumFormatEtc);\n\n\t\tif (hRet == S_OK)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\thRet = IEnumFORMATETC_Next(pEnumFormatEtc, 1, &vFormatEtc2, &CeltFetched);\n\n\t\t\t\tif (hRet == S_OK)\n\t\t\t\t{\n\t\t\t\t\tif (vFormatEtc2.cfFormat == RegisterClipboardFormat(CFSTR_FILECONTENTS))\n\t\t\t\t\t{\n\t\t\t\t\t\thRet = IDataObject_GetData(pDataObj, &vFormatEtc, &vStgMedium);\n\n\t\t\t\t\t\tif (hRet == S_OK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpStreamStc = vStgMedium.pstm;\n\t\t\t\t\t\t\tuStreamIdStc = fileContentsRequest->streamId;\n\t\t\t\t\t\t\tbIsStreamFile = TRUE;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (hRet == S_OK);\n\t\t}\n\t}\n\n\tif (bIsStreamFile == TRUE)\n\t{\n\t\tif (fileContentsRequest->dwFlags == FILECONTENTS_SIZE)\n\t\t{\n\t\t\tSTATSTG vStatStg;\n\t\t\tZeroMemory(&vStatStg, sizeof(STATSTG));\n\t\t\thRet = IStream_Stat(pStreamStc, &vStatStg, STATFLAG_NONAME);\n\n\t\t\tif (hRet == S_OK)\n\t\t\t{\n\t\t\t\t*((UINT32*)&pData[0]) = vStatStg.cbSize.LowPart;\n\t\t\t\t*((UINT32*)&pData[4]) = vStatStg.cbSize.HighPart;\n\t\t\t\tuSize = cbRequested;\n\t\t\t}\n\t\t}\n\t\telse if (fileContentsRequest->dwFlags == FILECONTENTS_RANGE)\n\t\t{\n\t\t\tLARGE_INTEGER dlibMove;\n\t\t\tULARGE_INTEGER dlibNewPosition;\n\t\t\tdlibMove.HighPart = fileContentsRequest->nPositionHigh;\n\t\t\tdlibMove.LowPart = fileContentsRequest->nPositionLow;\n\t\t\thRet = IStream_Seek(pStreamStc, dlibMove, STREAM_SEEK_SET, &dlibNewPosition);\n\n\t\t\tif (SUCCEEDED(hRet))\n\t\t\t\thRet = IStream_Read(pStreamStc, pData, cbRequested, (PULONG)&uSize);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (fileContentsRequest->dwFlags == FILECONTENTS_SIZE)\n\t\t{\n\t\t\tif (clipboard->nFiles <= fileContentsRequest->listIndex)\n\t\t\t\tgoto error;\n\t\t\t*((UINT32*)&pData[0]) =\n\t\t\t    clipboard->fileDescriptor[fileContentsRequest->listIndex]->nFileSizeLow;\n\t\t\t*((UINT32*)&pData[4]) =\n\t\t\t    clipboard->fileDescriptor[fileContentsRequest->listIndex]->nFileSizeHigh;\n\t\t\tuSize = cbRequested;\n\t\t}\n\t\telse if (fileContentsRequest->dwFlags == FILECONTENTS_RANGE)\n\t\t{\n\t\t\tBOOL bRet;\n\t\t\tif (clipboard->nFiles <= fileContentsRequest->listIndex)\n\t\t\t\tgoto error;\n\t\t\tbRet = wf_cliprdr_get_file_contents(\n\t\t\t    clipboard->file_names[fileContentsRequest->listIndex], pData,\n\t\t\t    fileContentsRequest->nPositionLow, fileContentsRequest->nPositionHigh, cbRequested,\n\t\t\t    &uSize);\n\n\t\t\tif (bRet == FALSE)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"get file contents failed.\");\n\t\t\t\tuSize = 0;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = CHANNEL_RC_OK;\nerror:\n\n\tif (pDataObj)\n\t\tIDataObject_Release(pDataObj);\n\n\tif (uSize == 0)\n\t{\n\t\tfree(pData);\n\t\tpData = NULL;\n\t}\n\n\tsRc =\n\t    cliprdr_send_response_filecontents(clipboard, fileContentsRequest->streamId, uSize, pData);\n\tfree(pData);\n\n\tif (sRc != CHANNEL_RC_OK)\n\t\treturn sRc;\n\n\treturn rc;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT\nwf_cliprdr_server_file_contents_response(CliprdrClientContext* context,\n                                         const CLIPRDR_FILE_CONTENTS_RESPONSE* fileContentsResponse)\n{\n\twfClipboard* clipboard;\n\n\tif (!context || !fileContentsResponse)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tif (fileContentsResponse->msgFlags != CB_RESPONSE_OK)\n\t\treturn E_FAIL;\n\n\tclipboard = (wfClipboard*)context->custom;\n\n\tif (!clipboard)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tclipboard->req_fsize = fileContentsResponse->cbRequested;\n\tclipboard->req_fdata = (char*)malloc(fileContentsResponse->cbRequested);\n\n\tif (!clipboard->req_fdata)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tCopyMemory(clipboard->req_fdata, fileContentsResponse->requestedData,\n\t           fileContentsResponse->cbRequested);\n\n\tif (!SetEvent(clipboard->req_fevent))\n\t{\n\t\tfree(clipboard->req_fdata);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\nBOOL wf_cliprdr_init(wfContext* wfc, CliprdrClientContext* cliprdr)\n{\n\twfClipboard* clipboard;\n\trdpContext* context = (rdpContext*)wfc;\n\n\tif (!context || !cliprdr)\n\t\treturn FALSE;\n\n\twfc->clipboard = (wfClipboard*)calloc(1, sizeof(wfClipboard));\n\n\tif (!wfc->clipboard)\n\t\treturn FALSE;\n\n\tclipboard = wfc->clipboard;\n\tclipboard->wfc = wfc;\n\tclipboard->context = cliprdr;\n\tclipboard->channels = context->channels;\n\tclipboard->sync = FALSE;\n\tclipboard->map_capacity = 32;\n\tclipboard->map_size = 0;\n\tclipboard->hUser32 = LoadLibraryA(\"user32.dll\");\n\n\tif (clipboard->hUser32)\n\t{\n\t\tclipboard->AddClipboardFormatListener = (fnAddClipboardFormatListener)GetProcAddress(\n\t\t    clipboard->hUser32, \"AddClipboardFormatListener\");\n\t\tclipboard->RemoveClipboardFormatListener = (fnRemoveClipboardFormatListener)GetProcAddress(\n\t\t    clipboard->hUser32, \"RemoveClipboardFormatListener\");\n\t\tclipboard->GetUpdatedClipboardFormats = (fnGetUpdatedClipboardFormats)GetProcAddress(\n\t\t    clipboard->hUser32, \"GetUpdatedClipboardFormats\");\n\t}\n\n\tif (!(clipboard->hUser32 && clipboard->AddClipboardFormatListener &&\n\t      clipboard->RemoveClipboardFormatListener && clipboard->GetUpdatedClipboardFormats))\n\t\tclipboard->legacyApi = TRUE;\n\n\tif (!(clipboard->format_mappings =\n\t          (formatMapping*)calloc(clipboard->map_capacity, sizeof(formatMapping))))\n\t\tgoto error;\n\n\tif (!(clipboard->response_data_event = CreateEvent(NULL, TRUE, FALSE, NULL)))\n\t\tgoto error;\n\n\tif (!(clipboard->req_fevent = CreateEvent(NULL, TRUE, FALSE, NULL)))\n\t\tgoto error;\n\n\tif (!(clipboard->thread = CreateThread(NULL, 0, cliprdr_thread_func, clipboard, 0, NULL)))\n\t\tgoto error;\n\n\tcliprdr->MonitorReady = wf_cliprdr_monitor_ready;\n\tcliprdr->ServerCapabilities = wf_cliprdr_server_capabilities;\n\tcliprdr->ServerFormatList = wf_cliprdr_server_format_list;\n\tcliprdr->ServerFormatListResponse = wf_cliprdr_server_format_list_response;\n\tcliprdr->ServerLockClipboardData = wf_cliprdr_server_lock_clipboard_data;\n\tcliprdr->ServerUnlockClipboardData = wf_cliprdr_server_unlock_clipboard_data;\n\tcliprdr->ServerFormatDataRequest = wf_cliprdr_server_format_data_request;\n\tcliprdr->ServerFormatDataResponse = wf_cliprdr_server_format_data_response;\n\tcliprdr->ServerFileContentsRequest = wf_cliprdr_server_file_contents_request;\n\tcliprdr->ServerFileContentsResponse = wf_cliprdr_server_file_contents_response;\n\tcliprdr->custom = (void*)wfc->clipboard;\n\treturn TRUE;\nerror:\n\twf_cliprdr_uninit(wfc, cliprdr);\n\treturn FALSE;\n}\n\nBOOL wf_cliprdr_uninit(wfContext* wfc, CliprdrClientContext* cliprdr)\n{\n\twfClipboard* clipboard;\n\n\tif (!wfc || !cliprdr)\n\t\treturn FALSE;\n\n\tclipboard = wfc->clipboard;\n\n\tif (!clipboard)\n\t\treturn FALSE;\n\n\tcliprdr->custom = NULL;\n\n\tif (clipboard->hwnd)\n\t\tPostMessage(clipboard->hwnd, WM_QUIT, 0, 0);\n\n\tif (clipboard->thread)\n\t{\n\t\tWaitForSingleObject(clipboard->thread, INFINITE);\n\t\tCloseHandle(clipboard->thread);\n\t}\n\n\tif (clipboard->response_data_event)\n\t\tCloseHandle(clipboard->response_data_event);\n\n\tif (clipboard->req_fevent)\n\t\tCloseHandle(clipboard->req_fevent);\n\n\tclear_file_array(clipboard);\n\tclear_format_map(clipboard);\n\tfree(clipboard->format_mappings);\n\tfree(clipboard);\n\treturn TRUE;\n}\n"], "filenames": ["client/Windows/wf_cliprdr.c"], "buggy_code_start_loc": [2365], "buggy_code_end_loc": [2374], "fixing_code_start_loc": [2366], "fixing_code_end_loc": [2379], "type": "CWE-20", "message": "In FreeRDP before 2.4.0 on Windows, wf_cliprdr_server_file_contents_request in client/Windows/wf_cliprdr.c has missing input checks for a FILECONTENTS_RANGE File Contents Request PDU.", "other": {"cve": {"id": "CVE-2021-37595", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-30T14:15:18.673", "lastModified": "2021-08-09T15:16:16.873", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRDP before 2.4.0 on Windows, wf_cliprdr_server_file_contents_request in client/Windows/wf_cliprdr.c has missing input checks for a FILECONTENTS_RANGE File Contents Request PDU."}, {"lang": "es", "value": "En FreeRDP versiones anteriores a 2.4.0 en Windows, la funci\u00f3n wf_cliprdr_server_file_contents_request en el archivo client/Windows/wf_cliprdr.c presenta una falta de comprobaciones de entrada para un PDU de petici\u00f3n de contenido de archivo FILECONTENTS_RANGE"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.0", "matchCriteriaId": "35FC9E54-273F-40C5-8B43-B4D51BAD20E7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:microsoft:windows:-:*:*:*:*:*:*:*", "matchCriteriaId": "A2572D17-1DE6-457B-99CC-64AFD54487EA"}]}]}], "references": [{"url": "https://github.com/FreeRDP/FreeRDP/commit/0d79670a28c0ab049af08613621aa0c267f977e9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/compare/2.3.2...2.4.0", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/0d79670a28c0ab049af08613621aa0c267f977e9"}}