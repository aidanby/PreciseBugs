{"buggy_code": ["// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! # EVM Pallet\n//!\n//! The EVM pallet allows unmodified EVM code to be executed in a Substrate-based blockchain.\n//! - [`evm::Config`]\n//!\n//! ## EVM Engine\n//!\n//! The EVM pallet uses [`SputnikVM`](https://github.com/rust-blockchain/evm) as the underlying EVM engine.\n//! The engine is overhauled so that it's [`modular`](https://github.com/corepaper/evm).\n//!\n//! ## Execution Lifecycle\n//!\n//! There are a separate set of accounts managed by the EVM pallet. Substrate based accounts can call the EVM Pallet\n//! to deposit or withdraw balance from the Substrate base-currency into a different balance managed and used by\n//! the EVM pallet. Once a user has populated their balance, they can create and call smart contracts using this pallet.\n//!\n//! There's one-to-one mapping from Substrate accounts and EVM external accounts that is defined by a conversion function.\n//!\n//! ## EVM Pallet vs Ethereum Network\n//!\n//! The EVM pallet should be able to produce nearly identical results compared to the Ethereum mainnet,\n//! including gas cost and balance changes.\n//!\n//! Observable differences include:\n//!\n//! - The available length of block hashes may not be 256 depending on the configuration of the System pallet\n//! in the Substrate runtime.\n//! - Difficulty and coinbase, which do not make sense in this pallet and is currently hard coded to zero.\n//!\n//! We currently do not aim to make unobservable behaviors, such as state root, to be the same. We also don't aim to follow\n//! the exact same transaction / receipt format. However, given one Ethereum transaction and one Substrate account's\n//! private key, one should be able to convert any Ethereum transaction into a transaction compatible with this pallet.\n//!\n//! The gas configurations are configurable. Right now, a pre-defined London hard fork configuration option is provided.\n\n// Ensure we're `no_std` when compiling for Wasm.\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#![warn(unused_crate_dependencies)]\n#![allow(clippy::too_many_arguments)]\n\n#[cfg(feature = \"runtime-benchmarks\")]\npub mod benchmarking;\n\n#[cfg(test)]\nmod mock;\npub mod runner;\n#[cfg(test)]\nmod tests;\npub mod weights;\n\npub use evm::{\n\tConfig as EvmConfig, Context, ExitError, ExitFatal, ExitReason, ExitRevert, ExitSucceed,\n};\nuse hash_db::Hasher;\nuse impl_trait_for_tuples::impl_for_tuples;\nuse scale_codec::{Decode, Encode, MaxEncodedLen};\nuse scale_info::TypeInfo;\n// Substrate\nuse frame_support::{\n\tdispatch::{DispatchResultWithPostInfo, Pays, PostDispatchInfo},\n\ttraits::{\n\t\ttokens::{\n\t\t\tcurrency::Currency,\n\t\t\tfungible::Inspect,\n\t\t\timbalance::{Imbalance, OnUnbalanced, SignedImbalance},\n\t\t\tExistenceRequirement, Fortitude, Preservation, WithdrawReasons,\n\t\t},\n\t\tFindAuthor, Get, Time,\n\t},\n\tweights::Weight,\n};\nuse frame_system::RawOrigin;\nuse sp_core::{H160, H256, U256};\nuse sp_runtime::{\n\ttraits::{BadOrigin, NumberFor, Saturating, UniqueSaturatedInto, Zero},\n\tAccountId32, DispatchErrorWithPostInfo,\n};\nuse sp_std::{cmp::min, collections::btree_map::BTreeMap, vec::Vec};\n// Frontier\nuse fp_account::AccountId20;\nuse fp_evm::GenesisAccount;\npub use fp_evm::{\n\tAccount, CallInfo, CreateInfo, ExecutionInfoV2 as ExecutionInfo, FeeCalculator,\n\tIsPrecompileResult, LinearCostPrecompile, Log, Precompile, PrecompileFailure, PrecompileHandle,\n\tPrecompileOutput, PrecompileResult, PrecompileSet, TransactionValidationError, Vicinity,\n};\n\npub use self::{\n\tpallet::*,\n\trunner::{Runner, RunnerError},\n\tweights::WeightInfo,\n};\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_system::pallet_prelude::*;\n\n\t#[pallet::pallet]\n\t#[pallet::without_storage_info]\n\tpub struct Pallet<T>(PhantomData<T>);\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config {\n\t\t/// Calculator for current gas price.\n\t\ttype FeeCalculator: FeeCalculator;\n\n\t\t/// Maps Ethereum gas to Substrate weight.\n\t\ttype GasWeightMapping: GasWeightMapping;\n\n\t\t/// Weight corresponding to a gas unit.\n\t\ttype WeightPerGas: Get<Weight>;\n\n\t\t/// Block number to block hash.\n\t\ttype BlockHashMapping: BlockHashMapping;\n\n\t\t/// Allow the origin to call on behalf of given address.\n\t\ttype CallOrigin: EnsureAddressOrigin<Self::RuntimeOrigin>;\n\t\t/// Allow the origin to withdraw on behalf of given address.\n\t\ttype WithdrawOrigin: EnsureAddressOrigin<Self::RuntimeOrigin, Success = Self::AccountId>;\n\n\t\t/// Mapping from address to account id.\n\t\ttype AddressMapping: AddressMapping<Self::AccountId>;\n\t\t/// Currency type for withdraw and balance storage.\n\t\ttype Currency: Currency<Self::AccountId> + Inspect<Self::AccountId>;\n\n\t\t/// The overarching event type.\n\t\ttype RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;\n\t\t/// Precompiles associated with this EVM engine.\n\t\ttype PrecompilesType: PrecompileSet;\n\t\ttype PrecompilesValue: Get<Self::PrecompilesType>;\n\t\t/// Chain ID of EVM.\n\t\ttype ChainId: Get<u64>;\n\t\t/// The block gas limit. Can be a simple constant, or an adjustment algorithm in another pallet.\n\t\ttype BlockGasLimit: Get<U256>;\n\t\t/// EVM execution runner.\n\t\ttype Runner: Runner<Self>;\n\n\t\t/// To handle fee deduction for EVM transactions. An example is this pallet being used by `pallet_ethereum`\n\t\t/// where the chain implementing `pallet_ethereum` should be able to configure what happens to the fees\n\t\t/// Similar to `OnChargeTransaction` of `pallet_transaction_payment`\n\t\ttype OnChargeTransaction: OnChargeEVMTransaction<Self>;\n\n\t\t/// Called on create calls, used to record owner\n\t\ttype OnCreate: OnCreate<Self>;\n\n\t\t/// Find author for the current block.\n\t\ttype FindAuthor: FindAuthor<H160>;\n\n\t\t/// Gas limit Pov size ratio.\n\t\ttype GasLimitPovSizeRatio: Get<u64>;\n\n\t\t/// Get the timestamp for the current block.\n\t\ttype Timestamp: Time;\n\n\t\t/// Weight information for extrinsics in this pallet.\n\t\ttype WeightInfo: WeightInfo;\n\n\t\t/// EVM config used in the module.\n\t\tfn config() -> &'static EvmConfig {\n\t\t\t&SHANGHAI_CONFIG\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T> {\n\t\t/// Withdraw balance from EVM into currency/balances pallet.\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(<T as pallet::Config>::WeightInfo::withdraw())]\n\t\tpub fn withdraw(\n\t\t\torigin: OriginFor<T>,\n\t\t\taddress: H160,\n\t\t\tvalue: BalanceOf<T>,\n\t\t) -> DispatchResult {\n\t\t\tlet destination = T::WithdrawOrigin::ensure_address_origin(&address, origin)?;\n\t\t\tlet address_account_id = T::AddressMapping::into_account_id(address);\n\n\t\t\tT::Currency::transfer(\n\t\t\t\t&address_account_id,\n\t\t\t\t&destination,\n\t\t\t\tvalue,\n\t\t\t\tExistenceRequirement::AllowDeath,\n\t\t\t)?;\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Issue an EVM call operation. This is similar to a message call transaction in Ethereum.\n\t\t#[pallet::call_index(1)]\n\t\t#[pallet::weight({\n\t\t\tlet without_base_extrinsic_weight = true;\n\t\t\tT::GasWeightMapping::gas_to_weight(*gas_limit, without_base_extrinsic_weight)\n\t\t})]\n\t\tpub fn call(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\ttarget: H160,\n\t\t\tinput: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\n\t\t\tlet is_transactional = true;\n\t\t\tlet validate = true;\n\t\t\tlet info = match T::Runner::call(\n\t\t\t\tsource,\n\t\t\t\ttarget,\n\t\t\t\tinput,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tvalidate,\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmatch info.exit_reason {\n\t\t\t\tExitReason::Succeed(_) => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Executed { address: target });\n\t\t\t\t}\n\t\t\t\t_ => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::ExecutedFailed { address: target });\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: {\n\t\t\t\t\tlet mut gas_to_weight = T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\t\tinfo.used_gas.standard.unique_saturated_into(),\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t);\n\t\t\t\t\tif let Some(weight_info) = info.weight_info {\n\t\t\t\t\t\tif let Some(proof_size_usage) = weight_info.proof_size_usage {\n\t\t\t\t\t\t\t*gas_to_weight.proof_size_mut() = proof_size_usage;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSome(gas_to_weight)\n\t\t\t\t},\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\n\t\t/// Issue an EVM create operation. This is similar to a contract creation transaction in\n\t\t/// Ethereum.\n\t\t#[pallet::call_index(2)]\n\t\t#[pallet::weight({\n\t\t\tlet without_base_extrinsic_weight = true;\n\t\t\tT::GasWeightMapping::gas_to_weight(*gas_limit, without_base_extrinsic_weight)\n\t\t})]\n\t\tpub fn create(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\tinit: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\n\t\t\tlet is_transactional = true;\n\t\t\tlet validate = true;\n\t\t\tlet info = match T::Runner::create(\n\t\t\t\tsource,\n\t\t\t\tinit,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tvalidate,\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmatch info {\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: ExitReason::Succeed(_),\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Created {\n\t\t\t\t\t\taddress: create_address,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: _,\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::CreatedFailed {\n\t\t\t\t\t\taddress: create_address,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: {\n\t\t\t\t\tlet mut gas_to_weight = T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\t\tinfo.used_gas.standard.unique_saturated_into(),\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t);\n\t\t\t\t\tif let Some(weight_info) = info.weight_info {\n\t\t\t\t\t\tif let Some(proof_size_usage) = weight_info.proof_size_usage {\n\t\t\t\t\t\t\t*gas_to_weight.proof_size_mut() = proof_size_usage;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSome(gas_to_weight)\n\t\t\t\t},\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\n\t\t/// Issue an EVM create2 operation.\n\t\t#[pallet::call_index(3)]\n\t\t#[pallet::weight({\n\t\t\tlet without_base_extrinsic_weight = true;\n\t\t\tT::GasWeightMapping::gas_to_weight(*gas_limit, without_base_extrinsic_weight)\n\t\t})]\n\t\tpub fn create2(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\tinit: Vec<u8>,\n\t\t\tsalt: H256,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\n\t\t\tlet is_transactional = true;\n\t\t\tlet validate = true;\n\t\t\tlet info = match T::Runner::create2(\n\t\t\t\tsource,\n\t\t\t\tinit,\n\t\t\t\tsalt,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tvalidate,\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmatch info {\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: ExitReason::Succeed(_),\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Created {\n\t\t\t\t\t\taddress: create_address,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: _,\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::CreatedFailed {\n\t\t\t\t\t\taddress: create_address,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: {\n\t\t\t\t\tlet mut gas_to_weight = T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\t\tinfo.used_gas.standard.unique_saturated_into(),\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t);\n\t\t\t\t\tif let Some(weight_info) = info.weight_info {\n\t\t\t\t\t\tif let Some(proof_size_usage) = weight_info.proof_size_usage {\n\t\t\t\t\t\t\t*gas_to_weight.proof_size_mut() = proof_size_usage;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSome(gas_to_weight)\n\t\t\t\t},\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event<T: Config> {\n\t\t/// Ethereum events from contracts.\n\t\tLog { log: Log },\n\t\t/// A contract has been created at given address.\n\t\tCreated { address: H160 },\n\t\t/// A contract was attempted to be created, but the execution failed.\n\t\tCreatedFailed { address: H160 },\n\t\t/// A contract has been executed successfully with states applied.\n\t\tExecuted { address: H160 },\n\t\t/// A contract has been executed with errors. States are reverted with only gas fees applied.\n\t\tExecutedFailed { address: H160 },\n\t}\n\n\t#[pallet::error]\n\tpub enum Error<T> {\n\t\t/// Not enough balance to perform action\n\t\tBalanceLow,\n\t\t/// Calculating total fee overflowed\n\t\tFeeOverflow,\n\t\t/// Calculating total payment overflowed\n\t\tPaymentOverflow,\n\t\t/// Withdraw fee failed\n\t\tWithdrawFailed,\n\t\t/// Gas price is too low.\n\t\tGasPriceTooLow,\n\t\t/// Nonce is invalid\n\t\tInvalidNonce,\n\t\t/// Gas limit is too low.\n\t\tGasLimitTooLow,\n\t\t/// Gas limit is too high.\n\t\tGasLimitTooHigh,\n\t\t/// Undefined error.\n\t\tUndefined,\n\t\t/// EVM reentrancy\n\t\tReentrancy,\n\t\t/// EIP-3607,\n\t\tTransactionMustComeFromEOA,\n\t}\n\n\timpl<T> From<TransactionValidationError> for Error<T> {\n\t\tfn from(validation_error: TransactionValidationError) -> Self {\n\t\t\tmatch validation_error {\n\t\t\t\tTransactionValidationError::GasLimitTooLow => Error::<T>::GasLimitTooLow,\n\t\t\t\tTransactionValidationError::GasLimitTooHigh => Error::<T>::GasLimitTooHigh,\n\t\t\t\tTransactionValidationError::BalanceTooLow => Error::<T>::BalanceLow,\n\t\t\t\tTransactionValidationError::TxNonceTooLow => Error::<T>::InvalidNonce,\n\t\t\t\tTransactionValidationError::TxNonceTooHigh => Error::<T>::InvalidNonce,\n\t\t\t\tTransactionValidationError::GasPriceTooLow => Error::<T>::GasPriceTooLow,\n\t\t\t\tTransactionValidationError::PriorityFeeTooHigh => Error::<T>::GasPriceTooLow,\n\t\t\t\tTransactionValidationError::InvalidFeeInput => Error::<T>::GasPriceTooLow,\n\t\t\t\t_ => Error::<T>::Undefined,\n\t\t\t}\n\t\t}\n\t}\n\n\t#[pallet::genesis_config]\n\t#[derive(frame_support::DefaultNoBound)]\n\tpub struct GenesisConfig<T> {\n\t\tpub accounts: BTreeMap<H160, GenesisAccount>,\n\t\t#[serde(skip)]\n\t\tpub _marker: PhantomData<T>,\n\t}\n\n\t#[pallet::genesis_build]\n\timpl<T: Config> BuildGenesisConfig for GenesisConfig<T>\n\twhere\n\t\tU256: UniqueSaturatedInto<BalanceOf<T>>,\n\t{\n\t\tfn build(&self) {\n\t\t\tconst MAX_ACCOUNT_NONCE: usize = 100;\n\n\t\t\tfor (address, account) in &self.accounts {\n\t\t\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\n\t\t\t\t// ASSUME: in one single EVM transaction, the nonce will not increase more than\n\t\t\t\t// `u128::max_value()`.\n\t\t\t\tfor _ in 0..min(\n\t\t\t\t\tMAX_ACCOUNT_NONCE,\n\t\t\t\t\tUniqueSaturatedInto::<usize>::unique_saturated_into(account.nonce),\n\t\t\t\t) {\n\t\t\t\t\tframe_system::Pallet::<T>::inc_account_nonce(&account_id);\n\t\t\t\t}\n\n\t\t\t\tT::Currency::deposit_creating(&account_id, account.balance.unique_saturated_into());\n\n\t\t\t\tPallet::<T>::create_account(*address, account.code.clone());\n\n\t\t\t\tfor (index, value) in &account.storage {\n\t\t\t\t\t<AccountStorages<T>>::insert(address, index, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t#[pallet::storage]\n\tpub type AccountCodes<T: Config> = StorageMap<_, Blake2_128Concat, H160, Vec<u8>, ValueQuery>;\n\n\t#[pallet::storage]\n\tpub type AccountCodesMetadata<T: Config> =\n\t\tStorageMap<_, Blake2_128Concat, H160, CodeMetadata, OptionQuery>;\n\n\t#[pallet::storage]\n\tpub type AccountStorages<T: Config> =\n\t\tStorageDoubleMap<_, Blake2_128Concat, H160, Blake2_128Concat, H256, H256, ValueQuery>;\n}\n\n/// Type alias for currency balance.\npub type BalanceOf<T> =\n\t<<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;\n\n/// Type alias for negative imbalance during fees\ntype NegativeImbalanceOf<C, T> =\n\t<C as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance;\n\n#[derive(\n\tDebug,\n\tClone,\n\tCopy,\n\tEq,\n\tPartialEq,\n\tEncode,\n\tDecode,\n\tTypeInfo,\n\tMaxEncodedLen\n)]\npub struct CodeMetadata {\n\tpub size: u64,\n\tpub hash: H256,\n}\n\nimpl CodeMetadata {\n\tfn from_code(code: &[u8]) -> Self {\n\t\tlet size = code.len() as u64;\n\t\tlet hash = H256::from(sp_io::hashing::keccak_256(code));\n\n\t\tSelf { size, hash }\n\t}\n}\n\npub trait EnsureAddressOrigin<OuterOrigin> {\n\t/// Success return type.\n\ttype Success;\n\n\t/// Perform the origin check.\n\tfn ensure_address_origin(\n\t\taddress: &H160,\n\t\torigin: OuterOrigin,\n\t) -> Result<Self::Success, BadOrigin> {\n\t\tSelf::try_address_origin(address, origin).map_err(|_| BadOrigin)\n\t}\n\n\t/// Try with origin.\n\tfn try_address_origin(\n\t\taddress: &H160,\n\t\torigin: OuterOrigin,\n\t) -> Result<Self::Success, OuterOrigin>;\n}\n\n/// Ensure that the EVM address is the same as the Substrate address. This only works if the account\n/// ID is `H160`.\npub struct EnsureAddressSame;\n\nimpl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressSame\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<H160>, OuterOrigin>> + From<RawOrigin<H160>>,\n{\n\ttype Success = H160;\n\n\tfn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<H160, OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Signed(who) if &who == address => Ok(who),\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\n\n/// Ensure that the origin is root.\npub struct EnsureAddressRoot<AccountId>(sp_std::marker::PhantomData<AccountId>);\n\nimpl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressRoot<AccountId>\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<AccountId>, OuterOrigin>> + From<RawOrigin<AccountId>>,\n{\n\ttype Success = ();\n\n\tfn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<(), OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Root => Ok(()),\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\n\n/// Ensure that the origin never happens.\npub struct EnsureAddressNever<AccountId>(sp_std::marker::PhantomData<AccountId>);\n\nimpl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressNever<AccountId> {\n\ttype Success = AccountId;\n\n\tfn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<AccountId, OuterOrigin> {\n\t\tErr(origin)\n\t}\n}\n\n/// Ensure that the address is truncated hash of the origin. Only works if the account id is\n/// `AccountId32`.\npub struct EnsureAddressTruncated;\n\nimpl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressTruncated\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<AccountId32>, OuterOrigin>> + From<RawOrigin<AccountId32>>,\n{\n\ttype Success = AccountId32;\n\n\tfn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<AccountId32, OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Signed(who) if AsRef::<[u8; 32]>::as_ref(&who)[0..20] == address[0..20] => {\n\t\t\t\tOk(who)\n\t\t\t}\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\n\n/// Ensure that the address is AccountId20.\npub struct EnsureAccountId20;\n\nimpl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAccountId20\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<AccountId20>, OuterOrigin>> + From<RawOrigin<AccountId20>>,\n{\n\ttype Success = AccountId20;\n\n\tfn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<AccountId20, OuterOrigin> {\n\t\tlet acc: AccountId20 = AccountId20::from(*address);\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Signed(who) if who == acc => Ok(who),\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\n\n/// Trait to be implemented for evm address mapping.\npub trait AddressMapping<A> {\n\tfn into_account_id(address: H160) -> A;\n}\n\n/// Identity address mapping.\npub struct IdentityAddressMapping;\n\nimpl<T: From<H160>> AddressMapping<T> for IdentityAddressMapping {\n\tfn into_account_id(address: H160) -> T {\n\t\taddress.into()\n\t}\n}\n\n/// Hashed address mapping.\npub struct HashedAddressMapping<H>(sp_std::marker::PhantomData<H>);\n\nimpl<H: Hasher<Out = H256>> AddressMapping<AccountId32> for HashedAddressMapping<H> {\n\tfn into_account_id(address: H160) -> AccountId32 {\n\t\tlet mut data = [0u8; 24];\n\t\tdata[0..4].copy_from_slice(b\"evm:\");\n\t\tdata[4..24].copy_from_slice(&address[..]);\n\t\tlet hash = H::hash(&data);\n\n\t\tAccountId32::from(Into::<[u8; 32]>::into(hash))\n\t}\n}\n\n/// A trait for getting a block hash by number.\npub trait BlockHashMapping {\n\tfn block_hash(number: u32) -> H256;\n}\n\n/// Returns the Substrate block hash by number.\npub struct SubstrateBlockHashMapping<T>(sp_std::marker::PhantomData<T>);\nimpl<T: Config> BlockHashMapping for SubstrateBlockHashMapping<T> {\n\tfn block_hash(number: u32) -> H256 {\n\t\tlet number = <NumberFor<T::Block>>::from(number);\n\t\tH256::from_slice(frame_system::Pallet::<T>::block_hash(number).as_ref())\n\t}\n}\n\n/// A mapping function that converts Ethereum gas to Substrate weight\npub trait GasWeightMapping {\n\tfn gas_to_weight(gas: u64, without_base_weight: bool) -> Weight;\n\tfn weight_to_gas(weight: Weight) -> u64;\n}\n\npub struct FixedGasWeightMapping<T>(sp_std::marker::PhantomData<T>);\nimpl<T: Config> GasWeightMapping for FixedGasWeightMapping<T> {\n\tfn gas_to_weight(gas: u64, without_base_weight: bool) -> Weight {\n\t\tlet mut weight = T::WeightPerGas::get().saturating_mul(gas);\n\t\tif without_base_weight {\n\t\t\tweight = weight.saturating_sub(\n\t\t\t\tT::BlockWeights::get()\n\t\t\t\t\t.get(frame_support::dispatch::DispatchClass::Normal)\n\t\t\t\t\t.base_extrinsic,\n\t\t\t);\n\t\t}\n\t\t// Apply a gas to proof size ratio based on BlockGasLimit\n\t\tlet ratio = T::GasLimitPovSizeRatio::get();\n\t\tif ratio > 0 {\n\t\t\tlet proof_size = gas.saturating_div(ratio);\n\t\t\t*weight.proof_size_mut() = proof_size;\n\t\t}\n\n\t\tweight\n\t}\n\tfn weight_to_gas(weight: Weight) -> u64 {\n\t\tweight.div(T::WeightPerGas::get().ref_time()).ref_time()\n\t}\n}\n\nstatic SHANGHAI_CONFIG: EvmConfig = EvmConfig::shanghai();\n\nimpl<T: Config> Pallet<T> {\n\t/// Check whether an account is empty.\n\tpub fn is_account_empty(address: &H160) -> bool {\n\t\tlet (account, _) = Self::account_basic(address);\n\t\tlet code_len = <AccountCodes<T>>::decode_len(address).unwrap_or(0);\n\n\t\taccount.nonce == U256::zero() && account.balance == U256::zero() && code_len == 0\n\t}\n\n\t/// Remove an account if its empty.\n\tpub fn remove_account_if_empty(address: &H160) {\n\t\tif Self::is_account_empty(address) {\n\t\t\tSelf::remove_account(address);\n\t\t}\n\t}\n\n\t/// Remove an account.\n\tpub fn remove_account(address: &H160) {\n\t\tif <AccountCodes<T>>::contains_key(address) {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\t\t\tlet _ = frame_system::Pallet::<T>::dec_sufficients(&account_id);\n\t\t}\n\n\t\t<AccountCodes<T>>::remove(address);\n\t\t<AccountCodesMetadata<T>>::remove(address);\n\t\t#[allow(deprecated)]\n\t\tlet _ = <AccountStorages<T>>::remove_prefix(address, None);\n\t}\n\n\t/// Create an account.\n\tpub fn create_account(address: H160, code: Vec<u8>) {\n\t\tif code.is_empty() {\n\t\t\treturn;\n\t\t}\n\n\t\tif !<AccountCodes<T>>::contains_key(address) {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(address);\n\t\t\tlet _ = frame_system::Pallet::<T>::inc_sufficients(&account_id);\n\t\t}\n\n\t\t// Update metadata.\n\t\tlet meta = CodeMetadata::from_code(&code);\n\t\t<AccountCodesMetadata<T>>::insert(address, meta);\n\n\t\t<AccountCodes<T>>::insert(address, code);\n\t}\n\n\t/// Get the account metadata (hash and size) from storage if it exists,\n\t/// or compute it from code and store it if it doesn't exist.\n\tpub fn account_code_metadata(address: H160) -> CodeMetadata {\n\t\tif let Some(meta) = <AccountCodesMetadata<T>>::get(address) {\n\t\t\treturn meta;\n\t\t}\n\n\t\tlet code = <AccountCodes<T>>::get(address);\n\n\t\t// If code is empty we return precomputed hash for empty code.\n\t\t// We don't store it as this address could get code deployed in the future.\n\t\tif code.is_empty() {\n\t\t\tconst EMPTY_CODE_HASH: [u8; 32] = hex_literal::hex!(\n\t\t\t\t\"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\"\n\t\t\t);\n\t\t\treturn CodeMetadata {\n\t\t\t\tsize: 0,\n\t\t\t\thash: EMPTY_CODE_HASH.into(),\n\t\t\t};\n\t\t}\n\n\t\tlet meta = CodeMetadata::from_code(&code);\n\n\t\t<AccountCodesMetadata<T>>::insert(address, meta);\n\t\tmeta\n\t}\n\n\t/// Get the account basic in EVM format.\n\tpub fn account_basic(address: &H160) -> (Account, frame_support::weights::Weight) {\n\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\n\t\tlet nonce = frame_system::Pallet::<T>::account_nonce(&account_id);\n\t\t// keepalive `true` takes into account ExistentialDeposit as part of what's considered liquid balance.\n\t\tlet balance =\n\t\t\tT::Currency::reducible_balance(&account_id, Preservation::Preserve, Fortitude::Polite);\n\n\t\t(\n\t\t\tAccount {\n\t\t\t\tnonce: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(nonce)),\n\t\t\t\tbalance: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(balance)),\n\t\t\t},\n\t\t\tT::DbWeight::get().reads(2),\n\t\t)\n\t}\n\n\t/// Get the author using the FindAuthor trait.\n\tpub fn find_author() -> H160 {\n\t\tlet digest = <frame_system::Pallet<T>>::digest();\n\t\tlet pre_runtime_digests = digest.logs.iter().filter_map(|d| d.as_pre_runtime());\n\n\t\tT::FindAuthor::find_author(pre_runtime_digests).unwrap_or_default()\n\t}\n}\n\n/// Handle withdrawing, refunding and depositing of transaction fees.\n/// Similar to `OnChargeTransaction` of `pallet_transaction_payment`\npub trait OnChargeEVMTransaction<T: Config> {\n\ttype LiquidityInfo: Default;\n\n\t/// Before the transaction is executed the payment of the transaction fees\n\t/// need to be secured.\n\tfn withdraw_fee(who: &H160, fee: U256) -> Result<Self::LiquidityInfo, Error<T>>;\n\n\t/// After the transaction was executed the actual fee can be calculated.\n\t/// This function should refund any overpaid fees and optionally deposit\n\t/// the corrected amount, and handles the base fee rationing using the provided\n\t/// `OnUnbalanced` implementation.\n\t/// Returns the `NegativeImbalance` - if any - produced by the priority fee.\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo;\n\n\t/// Introduced in EIP1559 to handle the priority tip.\n\tfn pay_priority_fee(tip: Self::LiquidityInfo);\n}\n\n/// Implements the transaction payment for a pallet implementing the `Currency`\n/// trait (eg. the pallet_balances) using an unbalance handler (implementing\n/// `OnUnbalanced`).\n/// Similar to `CurrencyAdapter` of `pallet_transaction_payment`\npub struct EVMCurrencyAdapter<C, OU>(sp_std::marker::PhantomData<(C, OU)>);\n\nimpl<T, C, OU> OnChargeEVMTransaction<T> for EVMCurrencyAdapter<C, OU>\nwhere\n\tT: Config,\n\tC: Currency<<T as frame_system::Config>::AccountId>,\n\tC::PositiveImbalance: Imbalance<\n\t\t<C as Currency<<T as frame_system::Config>::AccountId>>::Balance,\n\t\tOpposite = C::NegativeImbalance,\n\t>,\n\tC::NegativeImbalance: Imbalance<\n\t\t<C as Currency<<T as frame_system::Config>::AccountId>>::Balance,\n\t\tOpposite = C::PositiveImbalance,\n\t>,\n\tOU: OnUnbalanced<NegativeImbalanceOf<C, T>>,\n\tU256: UniqueSaturatedInto<<C as Currency<<T as frame_system::Config>::AccountId>>::Balance>,\n{\n\t// Kept type as Option to satisfy bound of Default\n\ttype LiquidityInfo = Option<NegativeImbalanceOf<C, T>>;\n\n\tfn withdraw_fee(who: &H160, fee: U256) -> Result<Self::LiquidityInfo, Error<T>> {\n\t\tif fee.is_zero() {\n\t\t\treturn Ok(None);\n\t\t}\n\t\tlet account_id = T::AddressMapping::into_account_id(*who);\n\t\tlet imbalance = C::withdraw(\n\t\t\t&account_id,\n\t\t\tfee.unique_saturated_into(),\n\t\t\tWithdrawReasons::FEE,\n\t\t\tExistenceRequirement::AllowDeath,\n\t\t)\n\t\t.map_err(|_| Error::<T>::BalanceLow)?;\n\t\tOk(Some(imbalance))\n\t}\n\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo {\n\t\tif let Some(paid) = already_withdrawn {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(*who);\n\n\t\t\t// Calculate how much refund we should return\n\t\t\tlet refund_amount = paid\n\t\t\t\t.peek()\n\t\t\t\t.saturating_sub(corrected_fee.unique_saturated_into());\n\t\t\t// refund to the account that paid the fees. If this fails, the\n\t\t\t// account might have dropped below the existential balance. In\n\t\t\t// that case we don't refund anything.\n\t\t\tlet refund_imbalance = C::deposit_into_existing(&account_id, refund_amount)\n\t\t\t\t.unwrap_or_else(|_| C::PositiveImbalance::zero());\n\n\t\t\t// Make sure this works with 0 ExistentialDeposit\n\t\t\t// https://github.com/paritytech/substrate/issues/10117\n\t\t\t// If we tried to refund something, the account still empty and the ED is set to 0,\n\t\t\t// we call `make_free_balance_be` with the refunded amount.\n\t\t\tlet refund_imbalance = if C::minimum_balance().is_zero()\n\t\t\t\t&& refund_amount > C::Balance::zero()\n\t\t\t\t&& C::total_balance(&account_id).is_zero()\n\t\t\t{\n\t\t\t\t// Known bug: Substrate tried to refund to a zeroed AccountData, but\n\t\t\t\t// interpreted the account to not exist.\n\t\t\t\tmatch C::make_free_balance_be(&account_id, refund_amount) {\n\t\t\t\t\tSignedImbalance::Positive(p) => p,\n\t\t\t\t\t_ => C::PositiveImbalance::zero(),\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trefund_imbalance\n\t\t\t};\n\n\t\t\t// merge the imbalance caused by paying the fees and refunding parts of it again.\n\t\t\tlet adjusted_paid = paid\n\t\t\t\t.offset(refund_imbalance)\n\t\t\t\t.same()\n\t\t\t\t.unwrap_or_else(|_| C::NegativeImbalance::zero());\n\n\t\t\tlet (base_fee, tip) = adjusted_paid.split(base_fee.unique_saturated_into());\n\t\t\t// Handle base fee. Can be either burned, rationed, etc ...\n\t\t\tOU::on_unbalanced(base_fee);\n\t\t\treturn Some(tip);\n\t\t}\n\t\tNone\n\t}\n\n\tfn pay_priority_fee(tip: Self::LiquidityInfo) {\n\t\t// Default Ethereum behaviour: issue the tip to the block author.\n\t\tif let Some(tip) = tip {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(<Pallet<T>>::find_author());\n\t\t\tlet _ = C::deposit_into_existing(&account_id, tip.peek());\n\t\t}\n\t}\n}\n\n/// Implementation for () does not specify what to do with imbalance\nimpl<T> OnChargeEVMTransaction<T> for ()\n\twhere\n\tT: Config,\n\t<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::PositiveImbalance:\n\t\tImbalance<<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance, Opposite = <T::Currency as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance>,\n\t<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance:\nImbalance<<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance, Opposite = <T::Currency as Currency<<T as frame_system::Config>::AccountId>>::PositiveImbalance>,\nU256: UniqueSaturatedInto<BalanceOf<T>>,\n\n{\n\t// Kept type as Option to satisfy bound of Default\n\ttype LiquidityInfo = Option<NegativeImbalanceOf<T::Currency, T>>;\n\n\tfn withdraw_fee(\n\t\twho: &H160,\n\t\tfee: U256,\n\t) -> Result<Self::LiquidityInfo, Error<T>> {\n\t\tEVMCurrencyAdapter::<<T as Config>::Currency, ()>::withdraw_fee(who, fee)\n\t}\n\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo {\n\t\t<EVMCurrencyAdapter::<<T as Config>::Currency, ()> as OnChargeEVMTransaction<T>>::correct_and_deposit_fee(who, corrected_fee, base_fee, already_withdrawn)\n\t}\n\n\tfn pay_priority_fee(tip: Self::LiquidityInfo) {\n\t\t<EVMCurrencyAdapter::<<T as Config>::Currency, ()> as OnChargeEVMTransaction<T>>::pay_priority_fee(tip);\n\t}\n}\n\npub trait OnCreate<T> {\n\tfn on_create(owner: H160, contract: H160);\n}\n\nimpl<T> OnCreate<T> for () {\n\tfn on_create(_owner: H160, _contract: H160) {}\n}\n\n#[impl_for_tuples(1, 12)]\nimpl<T> OnCreate<T> for Tuple {\n\tfn on_create(owner: H160, contract: H160) {\n\t\tfor_tuples!(#(\n\t\t\tTuple::on_create(owner, contract);\n\t\t)*)\n\t}\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![cfg(test)]\n\nuse super::*;\nuse crate::mock::*;\n\nuse frame_support::{\n\tassert_ok,\n\ttraits::{LockIdentifier, LockableCurrency, WithdrawReasons},\n};\nuse sp_runtime::BuildStorage;\nuse std::{collections::BTreeMap, str::FromStr};\n\nmod proof_size_test {\n\tuse super::*;\n\tuse fp_evm::{\n\t\tCreateInfo, ACCOUNT_BASIC_PROOF_SIZE, ACCOUNT_CODES_METADATA_PROOF_SIZE,\n\t\tACCOUNT_STORAGE_PROOF_SIZE, IS_EMPTY_CHECK_PROOF_SIZE, WRITE_PROOF_SIZE,\n\t};\n\tuse frame_support::traits::StorageInfoTrait;\n\t// pragma solidity ^0.8.2;\n\t// contract Callee {\n\t//     // ac4c25b2\n\t//     function void() public {\n\t//         uint256 foo = 1;\n\t//     }\n\t// }\n\tpub const PROOF_SIZE_TEST_CALLEE_CONTRACT_BYTECODE: &str =\n\t\tinclude_str!(\"./res/proof_size_test_callee_contract_bytecode.txt\");\n\t// pragma solidity ^0.8.2;\n\t// contract ProofSizeTest {\n\t//     uint256 foo;\n\t//     constructor() {\n\t//         foo = 6;\n\t//     }\n\t//     // 35f56c3b\n\t//     function test_balance(address who) public {\n\t//         // cold\n\t//         uint256 a = address(who).balance;\n\t//         // warm\n\t//         uint256 b = address(who).balance;\n\t//     }\n\t//     // e27a0ecd\n\t//     function test_sload() public returns (uint256) {\n\t//         // cold\n\t//         uint256 a = foo;\n\t//         // warm\n\t//         uint256 b = foo;\n\t//         return b;\n\t//     }\n\t//     // 4f3080a9\n\t//     function test_sstore() public {\n\t//         // cold\n\t//         foo = 4;\n\t//         // warm\n\t//         foo = 5;\n\t//     }\n\t//     // c6d6f606\n\t//     function test_call(Callee _callee) public {\n\t//         _callee.void();\n\t//     }\n\t//     // 944ddc62\n\t//     function test_oog() public {\n\t//         uint256 i = 1;\n\t//         while(true) {\n\t//             address who = address(uint160(uint256(keccak256(abi.encodePacked(bytes32(i))))));\n\t//             uint256 a = address(who).balance;\n\t//             i = i + 1;\n\t//         }\n\t//     }\n\t// }\n\tpub const PROOF_SIZE_TEST_CONTRACT_BYTECODE: &str =\n\t\tinclude_str!(\"./res/proof_size_test_contract_bytecode.txt\");\n\n\tfn create_proof_size_test_callee_contract(\n\t\tgas_limit: u64,\n\t\tweight_limit: Option<Weight>,\n\t) -> Result<CreateInfo, crate::RunnerError<crate::Error<Test>>> {\n\t\t<Test as Config>::Runner::create(\n\t\t\tH160::default(),\n\t\t\thex::decode(PROOF_SIZE_TEST_CALLEE_CONTRACT_BYTECODE.trim_end()).unwrap(),\n\t\t\tU256::zero(),\n\t\t\tgas_limit,\n\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\ttrue, // transactional\n\t\t\ttrue, // must be validated\n\t\t\tweight_limit,\n\t\t\tSome(0),\n\t\t\t&<Test as Config>::config().clone(),\n\t\t)\n\t}\n\n\tfn create_proof_size_test_contract(\n\t\tgas_limit: u64,\n\t\tweight_limit: Option<Weight>,\n\t) -> Result<CreateInfo, crate::RunnerError<crate::Error<Test>>> {\n\t\t<Test as Config>::Runner::create(\n\t\t\tH160::default(),\n\t\t\thex::decode(PROOF_SIZE_TEST_CONTRACT_BYTECODE.trim_end()).unwrap(),\n\t\t\tU256::zero(),\n\t\t\tgas_limit,\n\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\ttrue, // non-transactional\n\t\t\ttrue, // must be validated\n\t\t\tweight_limit,\n\t\t\tSome(0),\n\t\t\t&<Test as Config>::config().clone(),\n\t\t)\n\t}\n\n\t#[test]\n\tfn account_basic_proof_size_constant_matches() {\n\t\tassert_eq!(\n\t\t\tACCOUNT_BASIC_PROOF_SIZE,\n\t\t\tframe_system::Account::<Test>::storage_info()\n\t\t\t\t.get(0)\n\t\t\t\t.expect(\"item\")\n\t\t\t\t.max_size\n\t\t\t\t.expect(\"size\") as u64\n\t\t);\n\t}\n\n\t#[test]\n\tfn account_storage_proof_size_constant_matches() {\n\t\tassert_eq!(\n\t\t\tACCOUNT_STORAGE_PROOF_SIZE,\n\t\t\tAccountStorages::<Test>::storage_info()\n\t\t\t\t.get(0)\n\t\t\t\t.expect(\"item\")\n\t\t\t\t.max_size\n\t\t\t\t.expect(\"size\") as u64\n\t\t);\n\t}\n\n\t#[test]\n\tfn account_codes_metadata_proof_size_constant_matches() {\n\t\tassert_eq!(\n\t\t\tACCOUNT_CODES_METADATA_PROOF_SIZE,\n\t\t\tAccountCodesMetadata::<Test>::storage_info()\n\t\t\t\t.get(0)\n\t\t\t\t.expect(\"item\")\n\t\t\t\t.max_size\n\t\t\t\t.expect(\"size\") as u64\n\t\t);\n\t}\n\n\t#[test]\n\tfn proof_size_create_accounting_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\tlet gas_limit: u64 = 1_000_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\n\t\t\tlet result = create_proof_size_test_callee_contract(gas_limit, Some(weight_limit))\n\t\t\t\t.expect(\"create succeeds\");\n\n\t\t\t// Creating a new contract does not involve reading the code from storage.\n\t\t\t// We account for a fixed hash proof size write, an empty check and .\n\t\t\tlet write_cost = WRITE_PROOF_SIZE;\n\t\t\tlet is_empty_check = IS_EMPTY_CHECK_PROOF_SIZE;\n\t\t\tlet nonce_increases = ACCOUNT_BASIC_PROOF_SIZE * 2;\n\t\t\tlet expected_proof_size = write_cost + is_empty_check + nonce_increases;\n\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(expected_proof_size, actual_proof_size);\n\t\t});\n\t}\n\n\t#[test]\n\tfn proof_size_subcall_accounting_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\t// Create callee contract A\n\t\t\tlet gas_limit: u64 = 1_000_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\t\t\tlet result =\n\t\t\t\tcreate_proof_size_test_callee_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet subcall_contract_address = result.value;\n\n\t\t\t// Create proof size test contract B\n\t\t\tlet result = create_proof_size_test_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet call_contract_address = result.value;\n\n\t\t\t// Call B, that calls A, with weight limit\n\t\t\t// selector for ProofSizeTest::test_call function..\n\t\t\tlet mut call_data: String = \"c6d6f606000000000000000000000000\".to_owned();\n\t\t\t// ..encode the callee address argument\n\t\t\tcall_data.push_str(&format!(\"{:x}\", subcall_contract_address));\n\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tcall_contract_address,\n\t\t\t\thex::decode(&call_data).unwrap(),\n\t\t\t\tU256::zero(),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&<Test as Config>::config().clone(),\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\t// Expected proof size\n\t\t\tlet reading_main_contract_len = AccountCodes::<Test>::get(call_contract_address).len();\n\t\t\tlet reading_contract_len = AccountCodes::<Test>::get(subcall_contract_address).len();\n\t\t\tlet read_account_metadata = ACCOUNT_CODES_METADATA_PROOF_SIZE as usize;\n\t\t\tlet is_empty_check = (IS_EMPTY_CHECK_PROOF_SIZE * 2) as usize;\n\t\t\tlet increase_nonce = (ACCOUNT_BASIC_PROOF_SIZE * 3) as usize;\n\t\t\tlet expected_proof_size = ((read_account_metadata * 2)\n\t\t\t\t+ reading_contract_len\n\t\t\t\t+ reading_main_contract_len\n\t\t\t\t+ is_empty_check + increase_nonce) as u64;\n\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(expected_proof_size, actual_proof_size);\n\t\t});\n\t}\n\n\t#[test]\n\tfn proof_size_balance_accounting_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\tlet gas_limit: u64 = 1_000_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\n\t\t\t// Create proof size test contract\n\t\t\tlet result = create_proof_size_test_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet call_contract_address = result.value;\n\n\t\t\t// selector for ProofSizeTest::balance function..\n\t\t\tlet mut call_data: String = \"35f56c3b000000000000000000000000\".to_owned();\n\t\t\t// ..encode bobs address\n\t\t\tcall_data.push_str(&format!(\"{:x}\", H160::random()));\n\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tcall_contract_address,\n\t\t\t\thex::decode(&call_data).unwrap(),\n\t\t\t\tU256::zero(),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&<Test as Config>::config().clone(),\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\t// - Three account reads.\n\t\t\t// - Main contract code read.\n\t\t\t// - One metadata read.\n\t\t\tlet basic_account_size = (ACCOUNT_BASIC_PROOF_SIZE * 3) as usize;\n\t\t\tlet read_account_metadata = ACCOUNT_CODES_METADATA_PROOF_SIZE as usize;\n\t\t\tlet is_empty_check = IS_EMPTY_CHECK_PROOF_SIZE as usize;\n\t\t\tlet increase_nonce = ACCOUNT_BASIC_PROOF_SIZE as usize;\n\t\t\tlet reading_main_contract_len = AccountCodes::<Test>::get(call_contract_address).len();\n\t\t\tlet expected_proof_size = (basic_account_size\n\t\t\t\t+ read_account_metadata\n\t\t\t\t+ reading_main_contract_len\n\t\t\t\t+ is_empty_check + increase_nonce) as u64;\n\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(expected_proof_size, actual_proof_size);\n\t\t});\n\t}\n\n\t#[test]\n\tfn proof_size_sload_accounting_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\tlet gas_limit: u64 = 1_000_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\n\t\t\t// Create proof size test contract\n\t\t\tlet result = create_proof_size_test_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet call_contract_address = result.value;\n\n\t\t\t// selector for ProofSizeTest::test_sload function..\n\t\t\tlet call_data: String = \"e27a0ecd\".to_owned();\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tcall_contract_address,\n\t\t\t\thex::decode(call_data).unwrap(),\n\t\t\t\tU256::zero(),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&<Test as Config>::config().clone(),\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\tlet reading_main_contract_len =\n\t\t\t\tAccountCodes::<Test>::get(call_contract_address).len() as u64;\n\t\t\tlet expected_proof_size = reading_main_contract_len\n\t\t\t\t+ ACCOUNT_STORAGE_PROOF_SIZE\n\t\t\t\t+ ACCOUNT_CODES_METADATA_PROOF_SIZE\n\t\t\t\t+ IS_EMPTY_CHECK_PROOF_SIZE\n\t\t\t\t+ (ACCOUNT_BASIC_PROOF_SIZE * 2);\n\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(expected_proof_size, actual_proof_size);\n\t\t});\n\t}\n\n\t#[test]\n\tfn proof_size_sstore_accounting_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\tlet gas_limit: u64 = 1_000_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\n\t\t\t// Create proof size test contract\n\t\t\tlet result = create_proof_size_test_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet call_contract_address = result.value;\n\n\t\t\t// selector for ProofSizeTest::test_sstore function..\n\t\t\tlet call_data: String = \"4f3080a9\".to_owned();\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tcall_contract_address,\n\t\t\t\thex::decode(call_data).unwrap(),\n\t\t\t\tU256::zero(),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&<Test as Config>::config().clone(),\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\tlet reading_main_contract_len =\n\t\t\t\tAccountCodes::<Test>::get(call_contract_address).len() as u64;\n\t\t\tlet expected_proof_size = reading_main_contract_len\n\t\t\t\t+ WRITE_PROOF_SIZE\n\t\t\t\t+ ACCOUNT_CODES_METADATA_PROOF_SIZE\n\t\t\t\t+ ACCOUNT_STORAGE_PROOF_SIZE\n\t\t\t\t+ IS_EMPTY_CHECK_PROOF_SIZE\n\t\t\t\t+ (ACCOUNT_BASIC_PROOF_SIZE * 2);\n\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(expected_proof_size, actual_proof_size);\n\t\t});\n\t}\n\n\t#[test]\n\tfn proof_size_oog_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\tlet gas_limit: u64 = 1_000_000;\n\t\t\tlet mut weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\n\t\t\t// Artifically set a lower proof size limit so we OOG this instead gas.\n\t\t\t*weight_limit.proof_size_mut() = weight_limit.proof_size() / 2;\n\n\t\t\t// Create proof size test contract\n\t\t\tlet result = create_proof_size_test_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet call_contract_address = result.value;\n\n\t\t\t// selector for ProofSizeTest::test_oog function..\n\t\t\tlet call_data: String = \"944ddc62\".to_owned();\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tcall_contract_address,\n\t\t\t\thex::decode(call_data).unwrap(),\n\t\t\t\tU256::zero(),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&<Test as Config>::config().clone(),\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\t// Find how many random balance reads can we do with the available proof size.\n\t\t\tlet reading_main_contract_len =\n\t\t\t\tAccountCodes::<Test>::get(call_contract_address).len() as u64;\n\t\t\tlet overhead = reading_main_contract_len\n\t\t\t\t+ ACCOUNT_CODES_METADATA_PROOF_SIZE\n\t\t\t\t+ IS_EMPTY_CHECK_PROOF_SIZE;\n\t\t\tlet available_proof_size = weight_limit.proof_size() - overhead;\n\t\t\tlet number_balance_reads =\n\t\t\t\tavailable_proof_size.saturating_div(ACCOUNT_BASIC_PROOF_SIZE);\n\t\t\t// The actual proof size consumed by those balance reads.\n\t\t\tlet expected_proof_size = overhead + (number_balance_reads * ACCOUNT_BASIC_PROOF_SIZE);\n\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(expected_proof_size, actual_proof_size);\n\t\t});\n\t}\n\n\t#[test]\n\tfn uncached_account_code_proof_size_accounting_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\t// Create callee contract A\n\t\t\tlet gas_limit: u64 = 1_000_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\t\t\tlet result =\n\t\t\t\tcreate_proof_size_test_callee_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet subcall_contract_address = result.value;\n\n\t\t\t// Expect callee contract code hash and size to be cached\n\t\t\tlet _ = <AccountCodesMetadata<Test>>::get(subcall_contract_address)\n\t\t\t\t.expect(\"contract code hash and size are cached\");\n\n\t\t\t// Remove callee cache\n\t\t\t<AccountCodesMetadata<Test>>::remove(subcall_contract_address);\n\n\t\t\t// Create proof size test contract B\n\t\t\tlet result = create_proof_size_test_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet call_contract_address = result.value;\n\n\t\t\t// Call B, that calls A, with weight limit\n\t\t\t// selector for ProofSizeTest::test_call function..\n\t\t\tlet mut call_data: String = \"c6d6f606000000000000000000000000\".to_owned();\n\t\t\t// ..encode the callee address argument\n\t\t\tcall_data.push_str(&format!(\"{:x}\", subcall_contract_address));\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tcall_contract_address,\n\t\t\t\thex::decode(&call_data).unwrap(),\n\t\t\t\tU256::zero(),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&<Test as Config>::config().clone(),\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\t// Expected proof size\n\t\t\tlet read_account_metadata = ACCOUNT_CODES_METADATA_PROOF_SIZE as usize;\n\t\t\tlet is_empty_check = (IS_EMPTY_CHECK_PROOF_SIZE * 2) as usize;\n\t\t\tlet increase_nonce = (ACCOUNT_BASIC_PROOF_SIZE * 3) as usize;\n\t\t\tlet reading_main_contract_len = AccountCodes::<Test>::get(call_contract_address).len();\n\t\t\tlet reading_callee_contract_len =\n\t\t\t\tAccountCodes::<Test>::get(subcall_contract_address).len();\n\t\t\t// In order to do the subcall, we need to check metadata 3 times -\n\t\t\t// one for each contract + one for the call opcode -, load two bytecodes - caller and callee.\n\t\t\tlet expected_proof_size = ((read_account_metadata * 2)\n\t\t\t\t+ reading_callee_contract_len\n\t\t\t\t+ reading_main_contract_len\n\t\t\t\t+ is_empty_check + increase_nonce) as u64;\n\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(expected_proof_size, actual_proof_size);\n\t\t});\n\t}\n\n\t#[test]\n\tfn proof_size_breaks_standard_transfer() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\t// In this test we do a simple transfer to an address with an stored code which is\n\t\t\t// greater in size (and thus load cost) than the transfer flat fee of 21_000.\n\n\t\t\t// We assert that providing 21_000 gas limit will not work, because the pov size limit\n\t\t\t// will OOG.\n\t\t\tlet fake_contract_address = H160::random();\n\t\t\tlet config = <Test as Config>::config().clone();\n\t\t\tlet fake_contract_code = vec![0; config.create_contract_limit.expect(\"a value\")];\n\t\t\tAccountCodes::<Test>::insert(fake_contract_address, fake_contract_code);\n\n\t\t\tlet gas_limit: u64 = 21_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tfake_contract_address,\n\t\t\t\tVec::new(),\n\t\t\t\tU256::from(777),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&config,\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\tassert_eq!(\n\t\t\t\tresult.exit_reason,\n\t\t\t\tcrate::ExitReason::Error(crate::ExitError::OutOfGas)\n\t\t\t);\n\t\t});\n\t}\n\n\t#[test]\n\tfn proof_size_based_refunding_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\t// In this test we do a simple transfer to an address with an stored code which is\n\t\t\t// greater in size (and thus load cost) than the transfer flat fee of 21_000.\n\n\t\t\t// Assert that if we provide enough gas limit, the refund will be based on the pov\n\t\t\t// size consumption, not the 21_000 gas.\n\t\t\tlet fake_contract_address = H160::random();\n\t\t\tlet config = <Test as Config>::config().clone();\n\t\t\tlet fake_contract_code = vec![0; config.create_contract_limit.expect(\"a value\")];\n\t\t\tAccountCodes::<Test>::insert(fake_contract_address, fake_contract_code);\n\n\t\t\tlet gas_limit: u64 = 700_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tfake_contract_address,\n\t\t\t\tVec::new(),\n\t\t\t\tU256::from(777),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&config,\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\tlet ratio = <<Test as Config>::GasLimitPovSizeRatio as Get<u64>>::get();\n\t\t\tlet used_gas = result.used_gas;\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(used_gas.standard, U256::from(21_000));\n\t\t\tassert_eq!(used_gas.effective, U256::from(actual_proof_size * ratio));\n\t\t});\n\t}\n}\n\ntype Balances = pallet_balances::Pallet<Test>;\n#[allow(clippy::upper_case_acronyms)]\ntype EVM = Pallet<Test>;\n\npub fn new_test_ext() -> sp_io::TestExternalities {\n\tlet mut t = frame_system::GenesisConfig::<Test>::default()\n\t\t.build_storage()\n\t\t.unwrap();\n\n\tlet mut accounts = BTreeMap::new();\n\taccounts.insert(\n\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\tGenesisAccount {\n\t\t\tnonce: U256::from(1),\n\t\t\tbalance: U256::from(1000000),\n\t\t\tstorage: Default::default(),\n\t\t\tcode: vec![\n\t\t\t\t0x00, // STOP\n\t\t\t],\n\t\t},\n\t);\n\taccounts.insert(\n\t\tH160::from_str(\"1000000000000000000000000000000000000002\").unwrap(),\n\t\tGenesisAccount {\n\t\t\tnonce: U256::from(1),\n\t\t\tbalance: U256::from(1000000),\n\t\t\tstorage: Default::default(),\n\t\t\tcode: vec![\n\t\t\t\t0xff, // INVALID\n\t\t\t],\n\t\t},\n\t);\n\taccounts.insert(\n\t\tH160::default(), // root\n\t\tGenesisAccount {\n\t\t\tnonce: U256::from(1),\n\t\t\tbalance: U256::max_value(),\n\t\t\tstorage: Default::default(),\n\t\t\tcode: vec![],\n\t\t},\n\t);\n\n\tpallet_balances::GenesisConfig::<Test> {\n\t\t// Create the block author account with some balance.\n\t\tbalances: vec![(\n\t\t\tH160::from_str(\"0x1234500000000000000000000000000000000000\").unwrap(),\n\t\t\t12345,\n\t\t)],\n\t}\n\t.assimilate_storage(&mut t)\n\t.expect(\"Pallet balances storage can be assimilated\");\n\n\tcrate::GenesisConfig::<Test> {\n\t\taccounts,\n\t\t..Default::default()\n\t}\n\t.assimilate_storage(&mut t)\n\t.unwrap();\n\n\tt.into()\n}\n\n#[test]\nfn fail_call_return_ok() {\n\tnew_test_ext().execute_with(|| {\n\t\tassert_ok!(EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::default(),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t));\n\n\t\tassert_ok!(EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000002\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::default(),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t));\n\t});\n}\n\n#[test]\nfn fee_deduction() {\n\tnew_test_ext().execute_with(|| {\n\t\t// Create an EVM address and the corresponding Substrate address that will be charged fees and refunded\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000003\").unwrap();\n\t\tlet substrate_addr = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\n\t\t// Seed account\n\t\tlet _ = <Test as Config>::Currency::deposit_creating(&substrate_addr, 100);\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 100);\n\n\t\t// Deduct fees as 10 units\n\t\tlet imbalance = <<Test as Config>::OnChargeTransaction as OnChargeEVMTransaction<Test>>::withdraw_fee(&evm_addr, U256::from(10)).unwrap();\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 90);\n\n\t\t// Refund fees as 5 units\n\t\t<<Test as Config>::OnChargeTransaction as OnChargeEVMTransaction<Test>>::correct_and_deposit_fee(&evm_addr, U256::from(5), U256::from(5), imbalance);\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 95);\n\t});\n}\n\n#[test]\nfn ed_0_refund_patch_works() {\n\tnew_test_ext().execute_with(|| {\n\t\t// Verifies that the OnChargeEVMTransaction patch is applied and fixes a known bug in Substrate for evm transactions.\n\t\t// https://github.com/paritytech/substrate/issues/10117\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000003\").unwrap();\n\t\tlet substrate_addr = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\n\t\tlet _ = <Test as Config>::Currency::deposit_creating(&substrate_addr, 21_777_000_000_000);\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 21_777_000_000_000);\n\n\t\tlet _ = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tevm_addr,\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1_000_000_000),\n\t\t\t21776,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tNone,\n\t\t\tSome(U256::from(0)),\n\t\t\tVec::new(),\n\t\t);\n\t\t// All that was due, was refunded.\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 776_000_000_000);\n\t});\n}\n\n#[test]\nfn ed_0_refund_patch_is_required() {\n\tnew_test_ext().execute_with(|| {\n\t\t// This test proves that the patch is required, verifying that the current Substrate behaviour is incorrect\n\t\t// for ED 0 configured chains.\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000003\").unwrap();\n\t\tlet substrate_addr = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\n\t\tlet _ = <Test as Config>::Currency::deposit_creating(&substrate_addr, 100);\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 100);\n\n\t\t// Drain funds\n\t\tlet _ =\n\t\t\t<<Test as Config>::OnChargeTransaction as OnChargeEVMTransaction<Test>>::withdraw_fee(\n\t\t\t\t&evm_addr,\n\t\t\t\tU256::from(100),\n\t\t\t)\n\t\t\t.unwrap();\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 0);\n\n\t\t// Try to refund. With ED 0, although the balance is now 0, the account still exists.\n\t\t// So its expected that calling `deposit_into_existing` results in the AccountData to increase the Balance.\n\t\t//\n\t\t// Is not the case, and this proves that the refund logic needs to be handled taking this into account.\n\t\tassert!(\n\t\t\t<Test as Config>::Currency::deposit_into_existing(&substrate_addr, 5u32.into())\n\t\t\t\t.is_err()\n\t\t);\n\t\t// Balance didn't change, and should be 5.\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 0);\n\t});\n}\n\n#[test]\nfn find_author() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tassert_eq!(\n\t\t\tauthor,\n\t\t\tH160::from_str(\"1234500000000000000000000000000000000000\").unwrap()\n\t\t);\n\t});\n}\n\n#[test]\nfn reducible_balance() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000001\").unwrap();\n\t\tlet account_id = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\t\tlet existential = ExistentialDeposit::get();\n\n\t\t// Genesis Balance.\n\t\tlet genesis_balance = EVM::account_basic(&evm_addr).0.balance;\n\n\t\t// Lock identifier.\n\t\tlet lock_id: LockIdentifier = *b\"te/stlok\";\n\t\t// Reserve some funds.\n\t\tlet to_lock = 1000;\n\t\tBalances::set_lock(lock_id, &account_id, to_lock, WithdrawReasons::RESERVE);\n\t\t// Reducible is, as currently configured in `account_basic`, (balance - lock - existential).\n\t\tlet reducible_balance = EVM::account_basic(&evm_addr).0.balance;\n\t\tassert_eq!(reducible_balance, (genesis_balance - to_lock - existential));\n\t});\n}\n\n#[test]\nfn author_should_get_tip() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tlet before_tip = EVM::account_basic(&author).0.balance;\n\t\tlet result = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(2_000_000_000),\n\t\t\tSome(U256::from(1)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tresult.expect(\"EVM can be called\");\n\t\tlet after_tip = EVM::account_basic(&author).0.balance;\n\t\tassert_eq!(after_tip, (before_tip + 21000));\n\t});\n}\n\n#[test]\nfn issuance_after_tip() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet before_tip = <Test as Config>::Currency::total_issuance();\n\t\tlet result = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(2_000_000_000),\n\t\t\tSome(U256::from(1)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tresult.expect(\"EVM can be called\");\n\t\tlet after_tip = <Test as Config>::Currency::total_issuance();\n\t\t// Only base fee is burned\n\t\tlet base_fee: u64 = <Test as Config>::FeeCalculator::min_gas_price()\n\t\t\t.0\n\t\t\t.unique_saturated_into();\n\t\tassert_eq!(after_tip, (before_tip - (base_fee * 21_000)));\n\t});\n}\n\n#[test]\nfn author_same_balance_without_tip() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tlet before_tip = EVM::account_basic(&author).0.balance;\n\t\tlet _ = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::default(),\n\t\t\t1000000,\n\t\t\tU256::default(),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tlet after_tip = EVM::account_basic(&author).0.balance;\n\t\tassert_eq!(after_tip, before_tip);\n\t});\n}\n\n#[test]\nfn refunds_should_work() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet before_call = EVM::account_basic(&H160::default()).0.balance;\n\t\t// Gas price is not part of the actual fee calculations anymore, only the base fee.\n\t\t//\n\t\t// Because we first deduct max_fee_per_gas * gas_limit (2_000_000_000 * 1000000) we need\n\t\t// to ensure that the difference (max fee VS base fee) is refunded.\n\t\tlet _ = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(2_000_000_000),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tlet (base_fee, _) = <Test as Config>::FeeCalculator::min_gas_price();\n\t\tlet total_cost = (U256::from(21_000) * base_fee) + U256::from(1);\n\t\tlet after_call = EVM::account_basic(&H160::default()).0.balance;\n\t\tassert_eq!(after_call, before_call - total_cost);\n\t});\n}\n\n#[test]\nfn refunds_and_priority_should_work() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tlet before_tip = EVM::account_basic(&author).0.balance;\n\t\tlet before_call = EVM::account_basic(&H160::default()).0.balance;\n\t\t// We deliberately set a base fee + max tip > max fee.\n\t\t// The effective priority tip will be 1GWEI instead 1.5GWEI:\n\t\t// \t\t(max_fee_per_gas - base_fee).min(max_priority_fee)\n\t\t//\t\t(2 - 1).min(1.5)\n\t\tlet tip = U256::from(1_500_000_000);\n\t\tlet max_fee_per_gas = U256::from(2_000_000_000);\n\t\tlet used_gas = U256::from(21_000);\n\t\tlet _ = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tmax_fee_per_gas,\n\t\t\tSome(tip),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tlet (base_fee, _) = <Test as Config>::FeeCalculator::min_gas_price();\n\t\tlet actual_tip = (max_fee_per_gas - base_fee).min(tip) * used_gas;\n\t\tlet total_cost = (used_gas * base_fee) + actual_tip + U256::from(1);\n\t\tlet after_call = EVM::account_basic(&H160::default()).0.balance;\n\t\t// The tip is deducted but never refunded to the caller.\n\t\tassert_eq!(after_call, before_call - total_cost);\n\n\t\tlet after_tip = EVM::account_basic(&author).0.balance;\n\t\tassert_eq!(after_tip, (before_tip + actual_tip));\n\t});\n}\n\n#[test]\nfn call_should_fail_with_priority_greater_than_max_fee() {\n\tnew_test_ext().execute_with(|| {\n\t\t// Max priority greater than max fee should fail.\n\t\tlet tip: u128 = 1_100_000_000;\n\t\tlet result = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tSome(U256::from(tip)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tassert!(result.is_err());\n\t\t// Some used weight is returned as part of the error.\n\t\tassert_eq!(\n\t\t\tresult.unwrap_err().post_info.actual_weight,\n\t\t\tSome(Weight::from_parts(7, 0))\n\t\t);\n\t});\n}\n\n#[test]\nfn call_should_succeed_with_priority_equal_to_max_fee() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet tip: u128 = 1_000_000_000;\n\t\t// Mimics the input for pre-eip-1559 transaction types where `gas_price`\n\t\t// is used for both `max_fee_per_gas` and `max_priority_fee_per_gas`.\n\t\tlet result = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tSome(U256::from(tip)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tassert!(result.is_ok());\n\t});\n}\n\n#[test]\nfn handle_sufficient_reference() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet addr = H160::from_str(\"1230000000000000000000000000000000000001\").unwrap();\n\t\tlet addr_2 = H160::from_str(\"1234000000000000000000000000000000000001\").unwrap();\n\t\tlet substrate_addr: <Test as frame_system::Config>::AccountId =\n\t\t\t<Test as Config>::AddressMapping::into_account_id(addr);\n\t\tlet substrate_addr_2: <Test as frame_system::Config>::AccountId =\n\t\t\t<Test as Config>::AddressMapping::into_account_id(addr_2);\n\n\t\t// Sufficients should increase when creating EVM accounts.\n\t\t<crate::AccountCodes<Test>>::insert(addr, vec![0]);\n\t\tlet account = frame_system::Account::<Test>::get(substrate_addr);\n\t\t// Using storage is not correct as it leads to a sufficient reference mismatch.\n\t\tassert_eq!(account.sufficients, 0);\n\n\t\t// Using the create / remove account functions is the correct way to handle it.\n\t\tEVM::create_account(addr_2, vec![1, 2, 3]);\n\t\tlet account_2 = frame_system::Account::<Test>::get(substrate_addr_2);\n\t\t// We increased the sufficient reference by 1.\n\t\tassert_eq!(account_2.sufficients, 1);\n\t\tEVM::remove_account(&addr_2);\n\t\tlet account_2 = frame_system::Account::<Test>::get(substrate_addr_2);\n\t\t// We decreased the sufficient reference by 1 on removing the account.\n\t\tassert_eq!(account_2.sufficients, 0);\n\t});\n}\n\n#[test]\nfn runner_non_transactional_calls_with_non_balance_accounts_is_ok_without_gas_price() {\n\t// Expect to skip checks for gas price and account balance when both:\n\t//\t- The call is non transactional (`is_transactional == false`).\n\t//\t- The `max_fee_per_gas` is None.\n\tnew_test_ext().execute_with(|| {\n\t\tlet non_balance_account =\n\t\t\tH160::from_str(\"7700000000000000000000000000000000000001\").unwrap();\n\t\tassert_eq!(\n\t\t\tEVM::account_basic(&non_balance_account).0.balance,\n\t\t\tU256::zero()\n\t\t);\n\t\tlet _ = <Test as Config>::Runner::call(\n\t\t\tnon_balance_account,\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\tfalse, // non-transactional\n\t\t\ttrue,  // must be validated\n\t\t\tNone,\n\t\t\tNone,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t)\n\t\t.expect(\"Non transactional call succeeds\");\n\t\tassert_eq!(\n\t\t\tEVM::account_basic(&non_balance_account).0.balance,\n\t\t\tU256::zero()\n\t\t);\n\t});\n}\n\n#[test]\nfn runner_non_transactional_calls_with_non_balance_accounts_is_err_with_gas_price() {\n\t// In non transactional calls where `Some(gas_price)` is defined, expect it to be\n\t// checked against the `BaseFee`, and expect the account to have enough balance\n\t// to pay for the call.\n\tnew_test_ext().execute_with(|| {\n\t\tlet non_balance_account =\n\t\t\tH160::from_str(\"7700000000000000000000000000000000000001\").unwrap();\n\t\tassert_eq!(\n\t\t\tEVM::account_basic(&non_balance_account).0.balance,\n\t\t\tU256::zero()\n\t\t);\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tnon_balance_account,\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tSome(U256::from(1_000_000_000)),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\tfalse, // non-transactional\n\t\t\ttrue,  // must be validated\n\t\t\tNone,\n\t\t\tNone,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t});\n}\n\n#[test]\nfn runner_transactional_call_with_zero_gas_price_fails() {\n\t// Transactional calls are rejected when `max_fee_per_gas == None`.\n\tnew_test_ext().execute_with(|| {\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\ttrue, // transactional\n\t\t\ttrue, // must be validated\n\t\t\tNone,\n\t\t\tNone,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t});\n}\n\n#[test]\nfn runner_max_fee_per_gas_gte_max_priority_fee_per_gas() {\n\t// Transactional and non transactional calls enforce `max_fee_per_gas >= max_priority_fee_per_gas`.\n\tnew_test_ext().execute_with(|| {\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tSome(U256::from(1_000_000_000)),\n\t\t\tSome(U256::from(2_000_000_000)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\ttrue, // transactional\n\t\t\ttrue, // must be validated\n\t\t\tNone,\n\t\t\tNone,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tSome(U256::from(1_000_000_000)),\n\t\t\tSome(U256::from(2_000_000_000)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\tfalse, // non-transactional\n\t\t\ttrue,  // must be validated\n\t\t\tNone,\n\t\t\tNone,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t});\n}\n\n#[test]\nfn eip3607_transaction_from_contract() {\n\tnew_test_ext().execute_with(|| {\n\t\t// external transaction\n\t\tmatch <Test as Config>::Runner::call(\n\t\t\t// Contract address.\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\ttrue,  // transactional\n\t\t\tfalse, // not sure be validated\n\t\t\tNone,\n\t\t\tNone,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t) {\n\t\t\tErr(RunnerError {\n\t\t\t\terror: Error::TransactionMustComeFromEOA,\n\t\t\t\t..\n\t\t\t}) => (),\n\t\t\t_ => panic!(\"Should have failed\"),\n\t\t}\n\n\t\t// internal call\n\t\tassert!(<Test as Config>::Runner::call(\n\t\t\t// Contract address.\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\tfalse, // non-transactional\n\t\t\ttrue,  // must be validated\n\t\t\tNone,\n\t\t\tNone,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t)\n\t\t.is_ok());\n\t});\n}\n\n#[test]\nfn metadata_code_gets_cached() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet address = H160::repeat_byte(0xaa);\n\n\t\tcrate::Pallet::<Test>::create_account(address, b\"Exemple\".to_vec());\n\n\t\tlet metadata = crate::Pallet::<Test>::account_code_metadata(address);\n\t\tassert_eq!(metadata.size, 7);\n\t\tassert_eq!(\n\t\t\tmetadata.hash,\n\t\t\thex_literal::hex!(\"e8396a990fe08f2402e64a00647e41dadf360ba078a59ba79f55e876e67ed4bc\")\n\t\t\t\t.into()\n\t\t);\n\n\t\tlet metadata2 = <AccountCodesMetadata<Test>>::get(address).expect(\"to have metadata set\");\n\t\tassert_eq!(metadata, metadata2);\n\t});\n}\n\n#[test]\nfn metadata_empty_dont_code_gets_cached() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet address = H160::repeat_byte(0xaa);\n\n\t\tlet metadata = crate::Pallet::<Test>::account_code_metadata(address);\n\t\tassert_eq!(metadata.size, 0);\n\t\tassert_eq!(\n\t\t\tmetadata.hash,\n\t\t\thex_literal::hex!(\"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\")\n\t\t\t\t.into()\n\t\t);\n\n\t\tassert!(<AccountCodesMetadata<Test>>::get(address).is_none());\n\t});\n}\n"], "fixing_code": ["// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! # EVM Pallet\n//!\n//! The EVM pallet allows unmodified EVM code to be executed in a Substrate-based blockchain.\n//! - [`evm::Config`]\n//!\n//! ## EVM Engine\n//!\n//! The EVM pallet uses [`SputnikVM`](https://github.com/rust-blockchain/evm) as the underlying EVM engine.\n//! The engine is overhauled so that it's [`modular`](https://github.com/corepaper/evm).\n//!\n//! ## Execution Lifecycle\n//!\n//! There are a separate set of accounts managed by the EVM pallet. Substrate based accounts can call the EVM Pallet\n//! to deposit or withdraw balance from the Substrate base-currency into a different balance managed and used by\n//! the EVM pallet. Once a user has populated their balance, they can create and call smart contracts using this pallet.\n//!\n//! There's one-to-one mapping from Substrate accounts and EVM external accounts that is defined by a conversion function.\n//!\n//! ## EVM Pallet vs Ethereum Network\n//!\n//! The EVM pallet should be able to produce nearly identical results compared to the Ethereum mainnet,\n//! including gas cost and balance changes.\n//!\n//! Observable differences include:\n//!\n//! - The available length of block hashes may not be 256 depending on the configuration of the System pallet\n//! in the Substrate runtime.\n//! - Difficulty and coinbase, which do not make sense in this pallet and is currently hard coded to zero.\n//!\n//! We currently do not aim to make unobservable behaviors, such as state root, to be the same. We also don't aim to follow\n//! the exact same transaction / receipt format. However, given one Ethereum transaction and one Substrate account's\n//! private key, one should be able to convert any Ethereum transaction into a transaction compatible with this pallet.\n//!\n//! The gas configurations are configurable. Right now, a pre-defined London hard fork configuration option is provided.\n\n// Ensure we're `no_std` when compiling for Wasm.\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#![warn(unused_crate_dependencies)]\n#![allow(clippy::too_many_arguments)]\n\n#[cfg(feature = \"runtime-benchmarks\")]\npub mod benchmarking;\n\n#[cfg(test)]\nmod mock;\npub mod runner;\n#[cfg(test)]\nmod tests;\npub mod weights;\n\npub use evm::{\n\tConfig as EvmConfig, Context, ExitError, ExitFatal, ExitReason, ExitRevert, ExitSucceed,\n};\nuse hash_db::Hasher;\nuse impl_trait_for_tuples::impl_for_tuples;\nuse scale_codec::{Decode, Encode, MaxEncodedLen};\nuse scale_info::TypeInfo;\n// Substrate\nuse frame_support::{\n\tdispatch::{DispatchResultWithPostInfo, Pays, PostDispatchInfo},\n\ttraits::{\n\t\ttokens::{\n\t\t\tcurrency::Currency,\n\t\t\tfungible::Inspect,\n\t\t\timbalance::{Imbalance, OnUnbalanced, SignedImbalance},\n\t\t\tExistenceRequirement, Fortitude, Preservation, WithdrawReasons,\n\t\t},\n\t\tFindAuthor, Get, Time,\n\t},\n\tweights::Weight,\n};\nuse frame_system::RawOrigin;\nuse sp_core::{H160, H256, U256};\nuse sp_runtime::{\n\ttraits::{BadOrigin, NumberFor, Saturating, UniqueSaturatedInto, Zero},\n\tAccountId32, DispatchErrorWithPostInfo,\n};\nuse sp_std::{cmp::min, collections::btree_map::BTreeMap, vec::Vec};\n// Frontier\nuse fp_account::AccountId20;\nuse fp_evm::GenesisAccount;\npub use fp_evm::{\n\tAccount, CallInfo, CreateInfo, ExecutionInfoV2 as ExecutionInfo, FeeCalculator,\n\tIsPrecompileResult, LinearCostPrecompile, Log, Precompile, PrecompileFailure, PrecompileHandle,\n\tPrecompileOutput, PrecompileResult, PrecompileSet, TransactionValidationError, Vicinity,\n};\n\npub use self::{\n\tpallet::*,\n\trunner::{Runner, RunnerError},\n\tweights::WeightInfo,\n};\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_system::pallet_prelude::*;\n\n\t#[pallet::pallet]\n\t#[pallet::without_storage_info]\n\tpub struct Pallet<T>(PhantomData<T>);\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config {\n\t\t/// Calculator for current gas price.\n\t\ttype FeeCalculator: FeeCalculator;\n\n\t\t/// Maps Ethereum gas to Substrate weight.\n\t\ttype GasWeightMapping: GasWeightMapping;\n\n\t\t/// Weight corresponding to a gas unit.\n\t\ttype WeightPerGas: Get<Weight>;\n\n\t\t/// Block number to block hash.\n\t\ttype BlockHashMapping: BlockHashMapping;\n\n\t\t/// Allow the origin to call on behalf of given address.\n\t\ttype CallOrigin: EnsureAddressOrigin<Self::RuntimeOrigin>;\n\t\t/// Allow the origin to withdraw on behalf of given address.\n\t\ttype WithdrawOrigin: EnsureAddressOrigin<Self::RuntimeOrigin, Success = Self::AccountId>;\n\n\t\t/// Mapping from address to account id.\n\t\ttype AddressMapping: AddressMapping<Self::AccountId>;\n\t\t/// Currency type for withdraw and balance storage.\n\t\ttype Currency: Currency<Self::AccountId> + Inspect<Self::AccountId>;\n\n\t\t/// The overarching event type.\n\t\ttype RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;\n\t\t/// Precompiles associated with this EVM engine.\n\t\ttype PrecompilesType: PrecompileSet;\n\t\ttype PrecompilesValue: Get<Self::PrecompilesType>;\n\t\t/// Chain ID of EVM.\n\t\ttype ChainId: Get<u64>;\n\t\t/// The block gas limit. Can be a simple constant, or an adjustment algorithm in another pallet.\n\t\ttype BlockGasLimit: Get<U256>;\n\t\t/// EVM execution runner.\n\t\ttype Runner: Runner<Self>;\n\n\t\t/// To handle fee deduction for EVM transactions. An example is this pallet being used by `pallet_ethereum`\n\t\t/// where the chain implementing `pallet_ethereum` should be able to configure what happens to the fees\n\t\t/// Similar to `OnChargeTransaction` of `pallet_transaction_payment`\n\t\ttype OnChargeTransaction: OnChargeEVMTransaction<Self>;\n\n\t\t/// Called on create calls, used to record owner\n\t\ttype OnCreate: OnCreate<Self>;\n\n\t\t/// Find author for the current block.\n\t\ttype FindAuthor: FindAuthor<H160>;\n\n\t\t/// Gas limit Pov size ratio.\n\t\ttype GasLimitPovSizeRatio: Get<u64>;\n\n\t\t/// Get the timestamp for the current block.\n\t\ttype Timestamp: Time;\n\n\t\t/// Weight information for extrinsics in this pallet.\n\t\ttype WeightInfo: WeightInfo;\n\n\t\t/// EVM config used in the module.\n\t\tfn config() -> &'static EvmConfig {\n\t\t\t&SHANGHAI_CONFIG\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T> {\n\t\t/// Withdraw balance from EVM into currency/balances pallet.\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(<T as pallet::Config>::WeightInfo::withdraw())]\n\t\tpub fn withdraw(\n\t\t\torigin: OriginFor<T>,\n\t\t\taddress: H160,\n\t\t\tvalue: BalanceOf<T>,\n\t\t) -> DispatchResult {\n\t\t\tlet destination = T::WithdrawOrigin::ensure_address_origin(&address, origin)?;\n\t\t\tlet address_account_id = T::AddressMapping::into_account_id(address);\n\n\t\t\tT::Currency::transfer(\n\t\t\t\t&address_account_id,\n\t\t\t\t&destination,\n\t\t\t\tvalue,\n\t\t\t\tExistenceRequirement::AllowDeath,\n\t\t\t)?;\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Issue an EVM call operation. This is similar to a message call transaction in Ethereum.\n\t\t#[pallet::call_index(1)]\n\t\t#[pallet::weight({\n\t\t\tlet without_base_extrinsic_weight = true;\n\t\t\tT::GasWeightMapping::gas_to_weight(*gas_limit, without_base_extrinsic_weight)\n\t\t})]\n\t\tpub fn call(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\ttarget: H160,\n\t\t\tinput: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\n\t\t\tlet is_transactional = true;\n\t\t\tlet validate = true;\n\t\t\tlet info = match T::Runner::call(\n\t\t\t\tsource,\n\t\t\t\ttarget,\n\t\t\t\tinput,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tvalidate,\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmatch info.exit_reason {\n\t\t\t\tExitReason::Succeed(_) => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Executed { address: target });\n\t\t\t\t}\n\t\t\t\t_ => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::ExecutedFailed { address: target });\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: {\n\t\t\t\t\tlet mut gas_to_weight = T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\t\tinfo.used_gas.standard.unique_saturated_into(),\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t);\n\t\t\t\t\tif let Some(weight_info) = info.weight_info {\n\t\t\t\t\t\tif let Some(proof_size_usage) = weight_info.proof_size_usage {\n\t\t\t\t\t\t\t*gas_to_weight.proof_size_mut() = proof_size_usage;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSome(gas_to_weight)\n\t\t\t\t},\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\n\t\t/// Issue an EVM create operation. This is similar to a contract creation transaction in\n\t\t/// Ethereum.\n\t\t#[pallet::call_index(2)]\n\t\t#[pallet::weight({\n\t\t\tlet without_base_extrinsic_weight = true;\n\t\t\tT::GasWeightMapping::gas_to_weight(*gas_limit, without_base_extrinsic_weight)\n\t\t})]\n\t\tpub fn create(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\tinit: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\n\t\t\tlet is_transactional = true;\n\t\t\tlet validate = true;\n\t\t\tlet info = match T::Runner::create(\n\t\t\t\tsource,\n\t\t\t\tinit,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tvalidate,\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmatch info {\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: ExitReason::Succeed(_),\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Created {\n\t\t\t\t\t\taddress: create_address,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: _,\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::CreatedFailed {\n\t\t\t\t\t\taddress: create_address,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: {\n\t\t\t\t\tlet mut gas_to_weight = T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\t\tinfo.used_gas.standard.unique_saturated_into(),\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t);\n\t\t\t\t\tif let Some(weight_info) = info.weight_info {\n\t\t\t\t\t\tif let Some(proof_size_usage) = weight_info.proof_size_usage {\n\t\t\t\t\t\t\t*gas_to_weight.proof_size_mut() = proof_size_usage;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSome(gas_to_weight)\n\t\t\t\t},\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\n\t\t/// Issue an EVM create2 operation.\n\t\t#[pallet::call_index(3)]\n\t\t#[pallet::weight({\n\t\t\tlet without_base_extrinsic_weight = true;\n\t\t\tT::GasWeightMapping::gas_to_weight(*gas_limit, without_base_extrinsic_weight)\n\t\t})]\n\t\tpub fn create2(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\tinit: Vec<u8>,\n\t\t\tsalt: H256,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\n\t\t\tlet is_transactional = true;\n\t\t\tlet validate = true;\n\t\t\tlet info = match T::Runner::create2(\n\t\t\t\tsource,\n\t\t\t\tinit,\n\t\t\t\tsalt,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tvalidate,\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmatch info {\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: ExitReason::Succeed(_),\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Created {\n\t\t\t\t\t\taddress: create_address,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: _,\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::CreatedFailed {\n\t\t\t\t\t\taddress: create_address,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: {\n\t\t\t\t\tlet mut gas_to_weight = T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\t\tinfo.used_gas.standard.unique_saturated_into(),\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t);\n\t\t\t\t\tif let Some(weight_info) = info.weight_info {\n\t\t\t\t\t\tif let Some(proof_size_usage) = weight_info.proof_size_usage {\n\t\t\t\t\t\t\t*gas_to_weight.proof_size_mut() = proof_size_usage;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSome(gas_to_weight)\n\t\t\t\t},\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event<T: Config> {\n\t\t/// Ethereum events from contracts.\n\t\tLog { log: Log },\n\t\t/// A contract has been created at given address.\n\t\tCreated { address: H160 },\n\t\t/// A contract was attempted to be created, but the execution failed.\n\t\tCreatedFailed { address: H160 },\n\t\t/// A contract has been executed successfully with states applied.\n\t\tExecuted { address: H160 },\n\t\t/// A contract has been executed with errors. States are reverted with only gas fees applied.\n\t\tExecutedFailed { address: H160 },\n\t}\n\n\t#[pallet::error]\n\tpub enum Error<T> {\n\t\t/// Not enough balance to perform action\n\t\tBalanceLow,\n\t\t/// Calculating total fee overflowed\n\t\tFeeOverflow,\n\t\t/// Calculating total payment overflowed\n\t\tPaymentOverflow,\n\t\t/// Withdraw fee failed\n\t\tWithdrawFailed,\n\t\t/// Gas price is too low.\n\t\tGasPriceTooLow,\n\t\t/// Nonce is invalid\n\t\tInvalidNonce,\n\t\t/// Gas limit is too low.\n\t\tGasLimitTooLow,\n\t\t/// Gas limit is too high.\n\t\tGasLimitTooHigh,\n\t\t/// Undefined error.\n\t\tUndefined,\n\t\t/// EVM reentrancy\n\t\tReentrancy,\n\t\t/// EIP-3607,\n\t\tTransactionMustComeFromEOA,\n\t}\n\n\timpl<T> From<TransactionValidationError> for Error<T> {\n\t\tfn from(validation_error: TransactionValidationError) -> Self {\n\t\t\tmatch validation_error {\n\t\t\t\tTransactionValidationError::GasLimitTooLow => Error::<T>::GasLimitTooLow,\n\t\t\t\tTransactionValidationError::GasLimitTooHigh => Error::<T>::GasLimitTooHigh,\n\t\t\t\tTransactionValidationError::BalanceTooLow => Error::<T>::BalanceLow,\n\t\t\t\tTransactionValidationError::TxNonceTooLow => Error::<T>::InvalidNonce,\n\t\t\t\tTransactionValidationError::TxNonceTooHigh => Error::<T>::InvalidNonce,\n\t\t\t\tTransactionValidationError::GasPriceTooLow => Error::<T>::GasPriceTooLow,\n\t\t\t\tTransactionValidationError::PriorityFeeTooHigh => Error::<T>::GasPriceTooLow,\n\t\t\t\tTransactionValidationError::InvalidFeeInput => Error::<T>::GasPriceTooLow,\n\t\t\t\t_ => Error::<T>::Undefined,\n\t\t\t}\n\t\t}\n\t}\n\n\t#[pallet::genesis_config]\n\t#[derive(frame_support::DefaultNoBound)]\n\tpub struct GenesisConfig<T> {\n\t\tpub accounts: BTreeMap<H160, GenesisAccount>,\n\t\t#[serde(skip)]\n\t\tpub _marker: PhantomData<T>,\n\t}\n\n\t#[pallet::genesis_build]\n\timpl<T: Config> BuildGenesisConfig for GenesisConfig<T>\n\twhere\n\t\tU256: UniqueSaturatedInto<BalanceOf<T>>,\n\t{\n\t\tfn build(&self) {\n\t\t\tconst MAX_ACCOUNT_NONCE: usize = 100;\n\n\t\t\tfor (address, account) in &self.accounts {\n\t\t\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\n\t\t\t\t// ASSUME: in one single EVM transaction, the nonce will not increase more than\n\t\t\t\t// `u128::max_value()`.\n\t\t\t\tfor _ in 0..min(\n\t\t\t\t\tMAX_ACCOUNT_NONCE,\n\t\t\t\t\tUniqueSaturatedInto::<usize>::unique_saturated_into(account.nonce),\n\t\t\t\t) {\n\t\t\t\t\tframe_system::Pallet::<T>::inc_account_nonce(&account_id);\n\t\t\t\t}\n\n\t\t\t\tT::Currency::deposit_creating(&account_id, account.balance.unique_saturated_into());\n\n\t\t\t\tPallet::<T>::create_account(*address, account.code.clone());\n\n\t\t\t\tfor (index, value) in &account.storage {\n\t\t\t\t\t<AccountStorages<T>>::insert(address, index, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t#[pallet::storage]\n\tpub type AccountCodes<T: Config> = StorageMap<_, Blake2_128Concat, H160, Vec<u8>, ValueQuery>;\n\n\t#[pallet::storage]\n\tpub type AccountCodesMetadata<T: Config> =\n\t\tStorageMap<_, Blake2_128Concat, H160, CodeMetadata, OptionQuery>;\n\n\t#[pallet::storage]\n\tpub type AccountStorages<T: Config> =\n\t\tStorageDoubleMap<_, Blake2_128Concat, H160, Blake2_128Concat, H256, H256, ValueQuery>;\n\n\t#[pallet::storage]\n\tpub type Suicided<T: Config> = StorageMap<_, Blake2_128Concat, H160, (), OptionQuery>;\n}\n\n/// Type alias for currency balance.\npub type BalanceOf<T> =\n\t<<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;\n\n/// Type alias for negative imbalance during fees\ntype NegativeImbalanceOf<C, T> =\n\t<C as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance;\n\n#[derive(\n\tDebug,\n\tClone,\n\tCopy,\n\tEq,\n\tPartialEq,\n\tEncode,\n\tDecode,\n\tTypeInfo,\n\tMaxEncodedLen\n)]\npub struct CodeMetadata {\n\tpub size: u64,\n\tpub hash: H256,\n}\n\nimpl CodeMetadata {\n\tfn from_code(code: &[u8]) -> Self {\n\t\tlet size = code.len() as u64;\n\t\tlet hash = H256::from(sp_io::hashing::keccak_256(code));\n\n\t\tSelf { size, hash }\n\t}\n}\n\npub trait EnsureAddressOrigin<OuterOrigin> {\n\t/// Success return type.\n\ttype Success;\n\n\t/// Perform the origin check.\n\tfn ensure_address_origin(\n\t\taddress: &H160,\n\t\torigin: OuterOrigin,\n\t) -> Result<Self::Success, BadOrigin> {\n\t\tSelf::try_address_origin(address, origin).map_err(|_| BadOrigin)\n\t}\n\n\t/// Try with origin.\n\tfn try_address_origin(\n\t\taddress: &H160,\n\t\torigin: OuterOrigin,\n\t) -> Result<Self::Success, OuterOrigin>;\n}\n\n/// Ensure that the EVM address is the same as the Substrate address. This only works if the account\n/// ID is `H160`.\npub struct EnsureAddressSame;\n\nimpl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressSame\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<H160>, OuterOrigin>> + From<RawOrigin<H160>>,\n{\n\ttype Success = H160;\n\n\tfn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<H160, OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Signed(who) if &who == address => Ok(who),\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\n\n/// Ensure that the origin is root.\npub struct EnsureAddressRoot<AccountId>(sp_std::marker::PhantomData<AccountId>);\n\nimpl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressRoot<AccountId>\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<AccountId>, OuterOrigin>> + From<RawOrigin<AccountId>>,\n{\n\ttype Success = ();\n\n\tfn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<(), OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Root => Ok(()),\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\n\n/// Ensure that the origin never happens.\npub struct EnsureAddressNever<AccountId>(sp_std::marker::PhantomData<AccountId>);\n\nimpl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressNever<AccountId> {\n\ttype Success = AccountId;\n\n\tfn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<AccountId, OuterOrigin> {\n\t\tErr(origin)\n\t}\n}\n\n/// Ensure that the address is truncated hash of the origin. Only works if the account id is\n/// `AccountId32`.\npub struct EnsureAddressTruncated;\n\nimpl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressTruncated\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<AccountId32>, OuterOrigin>> + From<RawOrigin<AccountId32>>,\n{\n\ttype Success = AccountId32;\n\n\tfn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<AccountId32, OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Signed(who) if AsRef::<[u8; 32]>::as_ref(&who)[0..20] == address[0..20] => {\n\t\t\t\tOk(who)\n\t\t\t}\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\n\n/// Ensure that the address is AccountId20.\npub struct EnsureAccountId20;\n\nimpl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAccountId20\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<AccountId20>, OuterOrigin>> + From<RawOrigin<AccountId20>>,\n{\n\ttype Success = AccountId20;\n\n\tfn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<AccountId20, OuterOrigin> {\n\t\tlet acc: AccountId20 = AccountId20::from(*address);\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Signed(who) if who == acc => Ok(who),\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\n\n/// Trait to be implemented for evm address mapping.\npub trait AddressMapping<A> {\n\tfn into_account_id(address: H160) -> A;\n}\n\n/// Identity address mapping.\npub struct IdentityAddressMapping;\n\nimpl<T: From<H160>> AddressMapping<T> for IdentityAddressMapping {\n\tfn into_account_id(address: H160) -> T {\n\t\taddress.into()\n\t}\n}\n\n/// Hashed address mapping.\npub struct HashedAddressMapping<H>(sp_std::marker::PhantomData<H>);\n\nimpl<H: Hasher<Out = H256>> AddressMapping<AccountId32> for HashedAddressMapping<H> {\n\tfn into_account_id(address: H160) -> AccountId32 {\n\t\tlet mut data = [0u8; 24];\n\t\tdata[0..4].copy_from_slice(b\"evm:\");\n\t\tdata[4..24].copy_from_slice(&address[..]);\n\t\tlet hash = H::hash(&data);\n\n\t\tAccountId32::from(Into::<[u8; 32]>::into(hash))\n\t}\n}\n\n/// A trait for getting a block hash by number.\npub trait BlockHashMapping {\n\tfn block_hash(number: u32) -> H256;\n}\n\n/// Returns the Substrate block hash by number.\npub struct SubstrateBlockHashMapping<T>(sp_std::marker::PhantomData<T>);\nimpl<T: Config> BlockHashMapping for SubstrateBlockHashMapping<T> {\n\tfn block_hash(number: u32) -> H256 {\n\t\tlet number = <NumberFor<T::Block>>::from(number);\n\t\tH256::from_slice(frame_system::Pallet::<T>::block_hash(number).as_ref())\n\t}\n}\n\n/// A mapping function that converts Ethereum gas to Substrate weight\npub trait GasWeightMapping {\n\tfn gas_to_weight(gas: u64, without_base_weight: bool) -> Weight;\n\tfn weight_to_gas(weight: Weight) -> u64;\n}\n\npub struct FixedGasWeightMapping<T>(sp_std::marker::PhantomData<T>);\nimpl<T: Config> GasWeightMapping for FixedGasWeightMapping<T> {\n\tfn gas_to_weight(gas: u64, without_base_weight: bool) -> Weight {\n\t\tlet mut weight = T::WeightPerGas::get().saturating_mul(gas);\n\t\tif without_base_weight {\n\t\t\tweight = weight.saturating_sub(\n\t\t\t\tT::BlockWeights::get()\n\t\t\t\t\t.get(frame_support::dispatch::DispatchClass::Normal)\n\t\t\t\t\t.base_extrinsic,\n\t\t\t);\n\t\t}\n\t\t// Apply a gas to proof size ratio based on BlockGasLimit\n\t\tlet ratio = T::GasLimitPovSizeRatio::get();\n\t\tif ratio > 0 {\n\t\t\tlet proof_size = gas.saturating_div(ratio);\n\t\t\t*weight.proof_size_mut() = proof_size;\n\t\t}\n\n\t\tweight\n\t}\n\tfn weight_to_gas(weight: Weight) -> u64 {\n\t\tweight.div(T::WeightPerGas::get().ref_time()).ref_time()\n\t}\n}\n\nstatic SHANGHAI_CONFIG: EvmConfig = EvmConfig::shanghai();\n\nimpl<T: Config> Pallet<T> {\n\t/// Check whether an account is empty.\n\tpub fn is_account_empty(address: &H160) -> bool {\n\t\tlet (account, _) = Self::account_basic(address);\n\t\tlet code_len = <AccountCodes<T>>::decode_len(address).unwrap_or(0);\n\n\t\taccount.nonce == U256::zero() && account.balance == U256::zero() && code_len == 0\n\t}\n\n\t/// Remove an account if its empty.\n\tpub fn remove_account_if_empty(address: &H160) {\n\t\tif Self::is_account_empty(address) {\n\t\t\tSelf::remove_account(address);\n\t\t}\n\t}\n\n\t/// Remove an account.\n\tpub fn remove_account(address: &H160) {\n\t\tif <AccountCodes<T>>::contains_key(address) {\n\t\t\t// Remember to call `dec_sufficients` when clearing Suicided.\n\t\t\t<Suicided<T>>::insert(address, ());\n\n\t\t\t// In theory, we can always have pre-EIP161 contracts, so we\n\t\t\t// make sure the account nonce is at least one.\n\t\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\t\t\tframe_system::Pallet::<T>::inc_account_nonce(&account_id);\n\t\t}\n\n\t\t<AccountCodes<T>>::remove(address);\n\t\t<AccountCodesMetadata<T>>::remove(address);\n\t}\n\n\t/// Create an account.\n\tpub fn create_account(address: H160, code: Vec<u8>) {\n\t\tif <Suicided<T>>::contains_key(address) {\n\t\t\t// This branch should never trigger, because when Suicided\n\t\t\t// contains an address, then its nonce will be at least one,\n\t\t\t// which causes CreateCollision error in EVM, but we add it\n\t\t\t// here for safeguard.\n\t\t\treturn;\n\t\t}\n\n\t\tif code.is_empty() {\n\t\t\treturn;\n\t\t}\n\n\t\tif !<AccountCodes<T>>::contains_key(address) {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(address);\n\t\t\tlet _ = frame_system::Pallet::<T>::inc_sufficients(&account_id);\n\t\t}\n\n\t\t// Update metadata.\n\t\tlet meta = CodeMetadata::from_code(&code);\n\t\t<AccountCodesMetadata<T>>::insert(address, meta);\n\n\t\t<AccountCodes<T>>::insert(address, code);\n\t}\n\n\t/// Get the account metadata (hash and size) from storage if it exists,\n\t/// or compute it from code and store it if it doesn't exist.\n\tpub fn account_code_metadata(address: H160) -> CodeMetadata {\n\t\tif let Some(meta) = <AccountCodesMetadata<T>>::get(address) {\n\t\t\treturn meta;\n\t\t}\n\n\t\tlet code = <AccountCodes<T>>::get(address);\n\n\t\t// If code is empty we return precomputed hash for empty code.\n\t\t// We don't store it as this address could get code deployed in the future.\n\t\tif code.is_empty() {\n\t\t\tconst EMPTY_CODE_HASH: [u8; 32] = hex_literal::hex!(\n\t\t\t\t\"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\"\n\t\t\t);\n\t\t\treturn CodeMetadata {\n\t\t\t\tsize: 0,\n\t\t\t\thash: EMPTY_CODE_HASH.into(),\n\t\t\t};\n\t\t}\n\n\t\tlet meta = CodeMetadata::from_code(&code);\n\n\t\t<AccountCodesMetadata<T>>::insert(address, meta);\n\t\tmeta\n\t}\n\n\t/// Get the account basic in EVM format.\n\tpub fn account_basic(address: &H160) -> (Account, frame_support::weights::Weight) {\n\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\n\t\tlet nonce = frame_system::Pallet::<T>::account_nonce(&account_id);\n\t\t// keepalive `true` takes into account ExistentialDeposit as part of what's considered liquid balance.\n\t\tlet balance =\n\t\t\tT::Currency::reducible_balance(&account_id, Preservation::Preserve, Fortitude::Polite);\n\n\t\t(\n\t\t\tAccount {\n\t\t\t\tnonce: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(nonce)),\n\t\t\t\tbalance: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(balance)),\n\t\t\t},\n\t\t\tT::DbWeight::get().reads(2),\n\t\t)\n\t}\n\n\t/// Get the author using the FindAuthor trait.\n\tpub fn find_author() -> H160 {\n\t\tlet digest = <frame_system::Pallet<T>>::digest();\n\t\tlet pre_runtime_digests = digest.logs.iter().filter_map(|d| d.as_pre_runtime());\n\n\t\tT::FindAuthor::find_author(pre_runtime_digests).unwrap_or_default()\n\t}\n}\n\n/// Handle withdrawing, refunding and depositing of transaction fees.\n/// Similar to `OnChargeTransaction` of `pallet_transaction_payment`\npub trait OnChargeEVMTransaction<T: Config> {\n\ttype LiquidityInfo: Default;\n\n\t/// Before the transaction is executed the payment of the transaction fees\n\t/// need to be secured.\n\tfn withdraw_fee(who: &H160, fee: U256) -> Result<Self::LiquidityInfo, Error<T>>;\n\n\t/// After the transaction was executed the actual fee can be calculated.\n\t/// This function should refund any overpaid fees and optionally deposit\n\t/// the corrected amount, and handles the base fee rationing using the provided\n\t/// `OnUnbalanced` implementation.\n\t/// Returns the `NegativeImbalance` - if any - produced by the priority fee.\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo;\n\n\t/// Introduced in EIP1559 to handle the priority tip.\n\tfn pay_priority_fee(tip: Self::LiquidityInfo);\n}\n\n/// Implements the transaction payment for a pallet implementing the `Currency`\n/// trait (eg. the pallet_balances) using an unbalance handler (implementing\n/// `OnUnbalanced`).\n/// Similar to `CurrencyAdapter` of `pallet_transaction_payment`\npub struct EVMCurrencyAdapter<C, OU>(sp_std::marker::PhantomData<(C, OU)>);\n\nimpl<T, C, OU> OnChargeEVMTransaction<T> for EVMCurrencyAdapter<C, OU>\nwhere\n\tT: Config,\n\tC: Currency<<T as frame_system::Config>::AccountId>,\n\tC::PositiveImbalance: Imbalance<\n\t\t<C as Currency<<T as frame_system::Config>::AccountId>>::Balance,\n\t\tOpposite = C::NegativeImbalance,\n\t>,\n\tC::NegativeImbalance: Imbalance<\n\t\t<C as Currency<<T as frame_system::Config>::AccountId>>::Balance,\n\t\tOpposite = C::PositiveImbalance,\n\t>,\n\tOU: OnUnbalanced<NegativeImbalanceOf<C, T>>,\n\tU256: UniqueSaturatedInto<<C as Currency<<T as frame_system::Config>::AccountId>>::Balance>,\n{\n\t// Kept type as Option to satisfy bound of Default\n\ttype LiquidityInfo = Option<NegativeImbalanceOf<C, T>>;\n\n\tfn withdraw_fee(who: &H160, fee: U256) -> Result<Self::LiquidityInfo, Error<T>> {\n\t\tif fee.is_zero() {\n\t\t\treturn Ok(None);\n\t\t}\n\t\tlet account_id = T::AddressMapping::into_account_id(*who);\n\t\tlet imbalance = C::withdraw(\n\t\t\t&account_id,\n\t\t\tfee.unique_saturated_into(),\n\t\t\tWithdrawReasons::FEE,\n\t\t\tExistenceRequirement::AllowDeath,\n\t\t)\n\t\t.map_err(|_| Error::<T>::BalanceLow)?;\n\t\tOk(Some(imbalance))\n\t}\n\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo {\n\t\tif let Some(paid) = already_withdrawn {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(*who);\n\n\t\t\t// Calculate how much refund we should return\n\t\t\tlet refund_amount = paid\n\t\t\t\t.peek()\n\t\t\t\t.saturating_sub(corrected_fee.unique_saturated_into());\n\t\t\t// refund to the account that paid the fees. If this fails, the\n\t\t\t// account might have dropped below the existential balance. In\n\t\t\t// that case we don't refund anything.\n\t\t\tlet refund_imbalance = C::deposit_into_existing(&account_id, refund_amount)\n\t\t\t\t.unwrap_or_else(|_| C::PositiveImbalance::zero());\n\n\t\t\t// Make sure this works with 0 ExistentialDeposit\n\t\t\t// https://github.com/paritytech/substrate/issues/10117\n\t\t\t// If we tried to refund something, the account still empty and the ED is set to 0,\n\t\t\t// we call `make_free_balance_be` with the refunded amount.\n\t\t\tlet refund_imbalance = if C::minimum_balance().is_zero()\n\t\t\t\t&& refund_amount > C::Balance::zero()\n\t\t\t\t&& C::total_balance(&account_id).is_zero()\n\t\t\t{\n\t\t\t\t// Known bug: Substrate tried to refund to a zeroed AccountData, but\n\t\t\t\t// interpreted the account to not exist.\n\t\t\t\tmatch C::make_free_balance_be(&account_id, refund_amount) {\n\t\t\t\t\tSignedImbalance::Positive(p) => p,\n\t\t\t\t\t_ => C::PositiveImbalance::zero(),\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trefund_imbalance\n\t\t\t};\n\n\t\t\t// merge the imbalance caused by paying the fees and refunding parts of it again.\n\t\t\tlet adjusted_paid = paid\n\t\t\t\t.offset(refund_imbalance)\n\t\t\t\t.same()\n\t\t\t\t.unwrap_or_else(|_| C::NegativeImbalance::zero());\n\n\t\t\tlet (base_fee, tip) = adjusted_paid.split(base_fee.unique_saturated_into());\n\t\t\t// Handle base fee. Can be either burned, rationed, etc ...\n\t\t\tOU::on_unbalanced(base_fee);\n\t\t\treturn Some(tip);\n\t\t}\n\t\tNone\n\t}\n\n\tfn pay_priority_fee(tip: Self::LiquidityInfo) {\n\t\t// Default Ethereum behaviour: issue the tip to the block author.\n\t\tif let Some(tip) = tip {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(<Pallet<T>>::find_author());\n\t\t\tlet _ = C::deposit_into_existing(&account_id, tip.peek());\n\t\t}\n\t}\n}\n\n/// Implementation for () does not specify what to do with imbalance\nimpl<T> OnChargeEVMTransaction<T> for ()\n\twhere\n\tT: Config,\n\t<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::PositiveImbalance:\n\t\tImbalance<<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance, Opposite = <T::Currency as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance>,\n\t<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance:\nImbalance<<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance, Opposite = <T::Currency as Currency<<T as frame_system::Config>::AccountId>>::PositiveImbalance>,\nU256: UniqueSaturatedInto<BalanceOf<T>>,\n\n{\n\t// Kept type as Option to satisfy bound of Default\n\ttype LiquidityInfo = Option<NegativeImbalanceOf<T::Currency, T>>;\n\n\tfn withdraw_fee(\n\t\twho: &H160,\n\t\tfee: U256,\n\t) -> Result<Self::LiquidityInfo, Error<T>> {\n\t\tEVMCurrencyAdapter::<<T as Config>::Currency, ()>::withdraw_fee(who, fee)\n\t}\n\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo {\n\t\t<EVMCurrencyAdapter::<<T as Config>::Currency, ()> as OnChargeEVMTransaction<T>>::correct_and_deposit_fee(who, corrected_fee, base_fee, already_withdrawn)\n\t}\n\n\tfn pay_priority_fee(tip: Self::LiquidityInfo) {\n\t\t<EVMCurrencyAdapter::<<T as Config>::Currency, ()> as OnChargeEVMTransaction<T>>::pay_priority_fee(tip);\n\t}\n}\n\npub trait OnCreate<T> {\n\tfn on_create(owner: H160, contract: H160);\n}\n\nimpl<T> OnCreate<T> for () {\n\tfn on_create(_owner: H160, _contract: H160) {}\n}\n\n#[impl_for_tuples(1, 12)]\nimpl<T> OnCreate<T> for Tuple {\n\tfn on_create(owner: H160, contract: H160) {\n\t\tfor_tuples!(#(\n\t\t\tTuple::on_create(owner, contract);\n\t\t)*)\n\t}\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![cfg(test)]\n\nuse super::*;\nuse crate::mock::*;\n\nuse frame_support::{\n\tassert_ok,\n\ttraits::{LockIdentifier, LockableCurrency, WithdrawReasons},\n};\nuse sp_runtime::BuildStorage;\nuse std::{collections::BTreeMap, str::FromStr};\n\nmod proof_size_test {\n\tuse super::*;\n\tuse fp_evm::{\n\t\tCreateInfo, ACCOUNT_BASIC_PROOF_SIZE, ACCOUNT_CODES_METADATA_PROOF_SIZE,\n\t\tACCOUNT_STORAGE_PROOF_SIZE, IS_EMPTY_CHECK_PROOF_SIZE, WRITE_PROOF_SIZE,\n\t};\n\tuse frame_support::traits::StorageInfoTrait;\n\t// pragma solidity ^0.8.2;\n\t// contract Callee {\n\t//     // ac4c25b2\n\t//     function void() public {\n\t//         uint256 foo = 1;\n\t//     }\n\t// }\n\tpub const PROOF_SIZE_TEST_CALLEE_CONTRACT_BYTECODE: &str =\n\t\tinclude_str!(\"./res/proof_size_test_callee_contract_bytecode.txt\");\n\t// pragma solidity ^0.8.2;\n\t// contract ProofSizeTest {\n\t//     uint256 foo;\n\t//     constructor() {\n\t//         foo = 6;\n\t//     }\n\t//     // 35f56c3b\n\t//     function test_balance(address who) public {\n\t//         // cold\n\t//         uint256 a = address(who).balance;\n\t//         // warm\n\t//         uint256 b = address(who).balance;\n\t//     }\n\t//     // e27a0ecd\n\t//     function test_sload() public returns (uint256) {\n\t//         // cold\n\t//         uint256 a = foo;\n\t//         // warm\n\t//         uint256 b = foo;\n\t//         return b;\n\t//     }\n\t//     // 4f3080a9\n\t//     function test_sstore() public {\n\t//         // cold\n\t//         foo = 4;\n\t//         // warm\n\t//         foo = 5;\n\t//     }\n\t//     // c6d6f606\n\t//     function test_call(Callee _callee) public {\n\t//         _callee.void();\n\t//     }\n\t//     // 944ddc62\n\t//     function test_oog() public {\n\t//         uint256 i = 1;\n\t//         while(true) {\n\t//             address who = address(uint160(uint256(keccak256(abi.encodePacked(bytes32(i))))));\n\t//             uint256 a = address(who).balance;\n\t//             i = i + 1;\n\t//         }\n\t//     }\n\t// }\n\tpub const PROOF_SIZE_TEST_CONTRACT_BYTECODE: &str =\n\t\tinclude_str!(\"./res/proof_size_test_contract_bytecode.txt\");\n\n\tfn create_proof_size_test_callee_contract(\n\t\tgas_limit: u64,\n\t\tweight_limit: Option<Weight>,\n\t) -> Result<CreateInfo, crate::RunnerError<crate::Error<Test>>> {\n\t\t<Test as Config>::Runner::create(\n\t\t\tH160::default(),\n\t\t\thex::decode(PROOF_SIZE_TEST_CALLEE_CONTRACT_BYTECODE.trim_end()).unwrap(),\n\t\t\tU256::zero(),\n\t\t\tgas_limit,\n\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\ttrue, // transactional\n\t\t\ttrue, // must be validated\n\t\t\tweight_limit,\n\t\t\tSome(0),\n\t\t\t&<Test as Config>::config().clone(),\n\t\t)\n\t}\n\n\tfn create_proof_size_test_contract(\n\t\tgas_limit: u64,\n\t\tweight_limit: Option<Weight>,\n\t) -> Result<CreateInfo, crate::RunnerError<crate::Error<Test>>> {\n\t\t<Test as Config>::Runner::create(\n\t\t\tH160::default(),\n\t\t\thex::decode(PROOF_SIZE_TEST_CONTRACT_BYTECODE.trim_end()).unwrap(),\n\t\t\tU256::zero(),\n\t\t\tgas_limit,\n\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\ttrue, // non-transactional\n\t\t\ttrue, // must be validated\n\t\t\tweight_limit,\n\t\t\tSome(0),\n\t\t\t&<Test as Config>::config().clone(),\n\t\t)\n\t}\n\n\t#[test]\n\tfn account_basic_proof_size_constant_matches() {\n\t\tassert_eq!(\n\t\t\tACCOUNT_BASIC_PROOF_SIZE,\n\t\t\tframe_system::Account::<Test>::storage_info()\n\t\t\t\t.get(0)\n\t\t\t\t.expect(\"item\")\n\t\t\t\t.max_size\n\t\t\t\t.expect(\"size\") as u64\n\t\t);\n\t}\n\n\t#[test]\n\tfn account_storage_proof_size_constant_matches() {\n\t\tassert_eq!(\n\t\t\tACCOUNT_STORAGE_PROOF_SIZE,\n\t\t\tAccountStorages::<Test>::storage_info()\n\t\t\t\t.get(0)\n\t\t\t\t.expect(\"item\")\n\t\t\t\t.max_size\n\t\t\t\t.expect(\"size\") as u64\n\t\t);\n\t}\n\n\t#[test]\n\tfn account_codes_metadata_proof_size_constant_matches() {\n\t\tassert_eq!(\n\t\t\tACCOUNT_CODES_METADATA_PROOF_SIZE,\n\t\t\tAccountCodesMetadata::<Test>::storage_info()\n\t\t\t\t.get(0)\n\t\t\t\t.expect(\"item\")\n\t\t\t\t.max_size\n\t\t\t\t.expect(\"size\") as u64\n\t\t);\n\t}\n\n\t#[test]\n\tfn proof_size_create_accounting_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\tlet gas_limit: u64 = 1_000_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\n\t\t\tlet result = create_proof_size_test_callee_contract(gas_limit, Some(weight_limit))\n\t\t\t\t.expect(\"create succeeds\");\n\n\t\t\t// Creating a new contract does not involve reading the code from storage.\n\t\t\t// We account for a fixed hash proof size write, an empty check and .\n\t\t\tlet write_cost = WRITE_PROOF_SIZE;\n\t\t\tlet is_empty_check = IS_EMPTY_CHECK_PROOF_SIZE;\n\t\t\tlet nonce_increases = ACCOUNT_BASIC_PROOF_SIZE * 2;\n\t\t\tlet expected_proof_size = write_cost + is_empty_check + nonce_increases;\n\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(expected_proof_size, actual_proof_size);\n\t\t});\n\t}\n\n\t#[test]\n\tfn proof_size_subcall_accounting_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\t// Create callee contract A\n\t\t\tlet gas_limit: u64 = 1_000_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\t\t\tlet result =\n\t\t\t\tcreate_proof_size_test_callee_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet subcall_contract_address = result.value;\n\n\t\t\t// Create proof size test contract B\n\t\t\tlet result = create_proof_size_test_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet call_contract_address = result.value;\n\n\t\t\t// Call B, that calls A, with weight limit\n\t\t\t// selector for ProofSizeTest::test_call function..\n\t\t\tlet mut call_data: String = \"c6d6f606000000000000000000000000\".to_owned();\n\t\t\t// ..encode the callee address argument\n\t\t\tcall_data.push_str(&format!(\"{:x}\", subcall_contract_address));\n\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tcall_contract_address,\n\t\t\t\thex::decode(&call_data).unwrap(),\n\t\t\t\tU256::zero(),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&<Test as Config>::config().clone(),\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\t// Expected proof size\n\t\t\tlet reading_main_contract_len = AccountCodes::<Test>::get(call_contract_address).len();\n\t\t\tlet reading_contract_len = AccountCodes::<Test>::get(subcall_contract_address).len();\n\t\t\tlet read_account_metadata = ACCOUNT_CODES_METADATA_PROOF_SIZE as usize;\n\t\t\tlet is_empty_check = (IS_EMPTY_CHECK_PROOF_SIZE * 2) as usize;\n\t\t\tlet increase_nonce = (ACCOUNT_BASIC_PROOF_SIZE * 3) as usize;\n\t\t\tlet expected_proof_size = ((read_account_metadata * 2)\n\t\t\t\t+ reading_contract_len\n\t\t\t\t+ reading_main_contract_len\n\t\t\t\t+ is_empty_check + increase_nonce) as u64;\n\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(expected_proof_size, actual_proof_size);\n\t\t});\n\t}\n\n\t#[test]\n\tfn proof_size_balance_accounting_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\tlet gas_limit: u64 = 1_000_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\n\t\t\t// Create proof size test contract\n\t\t\tlet result = create_proof_size_test_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet call_contract_address = result.value;\n\n\t\t\t// selector for ProofSizeTest::balance function..\n\t\t\tlet mut call_data: String = \"35f56c3b000000000000000000000000\".to_owned();\n\t\t\t// ..encode bobs address\n\t\t\tcall_data.push_str(&format!(\"{:x}\", H160::random()));\n\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tcall_contract_address,\n\t\t\t\thex::decode(&call_data).unwrap(),\n\t\t\t\tU256::zero(),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&<Test as Config>::config().clone(),\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\t// - Three account reads.\n\t\t\t// - Main contract code read.\n\t\t\t// - One metadata read.\n\t\t\tlet basic_account_size = (ACCOUNT_BASIC_PROOF_SIZE * 3) as usize;\n\t\t\tlet read_account_metadata = ACCOUNT_CODES_METADATA_PROOF_SIZE as usize;\n\t\t\tlet is_empty_check = IS_EMPTY_CHECK_PROOF_SIZE as usize;\n\t\t\tlet increase_nonce = ACCOUNT_BASIC_PROOF_SIZE as usize;\n\t\t\tlet reading_main_contract_len = AccountCodes::<Test>::get(call_contract_address).len();\n\t\t\tlet expected_proof_size = (basic_account_size\n\t\t\t\t+ read_account_metadata\n\t\t\t\t+ reading_main_contract_len\n\t\t\t\t+ is_empty_check + increase_nonce) as u64;\n\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(expected_proof_size, actual_proof_size);\n\t\t});\n\t}\n\n\t#[test]\n\tfn proof_size_sload_accounting_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\tlet gas_limit: u64 = 1_000_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\n\t\t\t// Create proof size test contract\n\t\t\tlet result = create_proof_size_test_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet call_contract_address = result.value;\n\n\t\t\t// selector for ProofSizeTest::test_sload function..\n\t\t\tlet call_data: String = \"e27a0ecd\".to_owned();\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tcall_contract_address,\n\t\t\t\thex::decode(call_data).unwrap(),\n\t\t\t\tU256::zero(),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&<Test as Config>::config().clone(),\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\tlet reading_main_contract_len =\n\t\t\t\tAccountCodes::<Test>::get(call_contract_address).len() as u64;\n\t\t\tlet expected_proof_size = reading_main_contract_len\n\t\t\t\t+ ACCOUNT_STORAGE_PROOF_SIZE\n\t\t\t\t+ ACCOUNT_CODES_METADATA_PROOF_SIZE\n\t\t\t\t+ IS_EMPTY_CHECK_PROOF_SIZE\n\t\t\t\t+ (ACCOUNT_BASIC_PROOF_SIZE * 2);\n\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(expected_proof_size, actual_proof_size);\n\t\t});\n\t}\n\n\t#[test]\n\tfn proof_size_sstore_accounting_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\tlet gas_limit: u64 = 1_000_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\n\t\t\t// Create proof size test contract\n\t\t\tlet result = create_proof_size_test_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet call_contract_address = result.value;\n\n\t\t\t// selector for ProofSizeTest::test_sstore function..\n\t\t\tlet call_data: String = \"4f3080a9\".to_owned();\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tcall_contract_address,\n\t\t\t\thex::decode(call_data).unwrap(),\n\t\t\t\tU256::zero(),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&<Test as Config>::config().clone(),\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\tlet reading_main_contract_len =\n\t\t\t\tAccountCodes::<Test>::get(call_contract_address).len() as u64;\n\t\t\tlet expected_proof_size = reading_main_contract_len\n\t\t\t\t+ WRITE_PROOF_SIZE\n\t\t\t\t+ ACCOUNT_CODES_METADATA_PROOF_SIZE\n\t\t\t\t+ ACCOUNT_STORAGE_PROOF_SIZE\n\t\t\t\t+ IS_EMPTY_CHECK_PROOF_SIZE\n\t\t\t\t+ (ACCOUNT_BASIC_PROOF_SIZE * 2);\n\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(expected_proof_size, actual_proof_size);\n\t\t});\n\t}\n\n\t#[test]\n\tfn proof_size_oog_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\tlet gas_limit: u64 = 1_000_000;\n\t\t\tlet mut weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\n\t\t\t// Artifically set a lower proof size limit so we OOG this instead gas.\n\t\t\t*weight_limit.proof_size_mut() = weight_limit.proof_size() / 2;\n\n\t\t\t// Create proof size test contract\n\t\t\tlet result = create_proof_size_test_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet call_contract_address = result.value;\n\n\t\t\t// selector for ProofSizeTest::test_oog function..\n\t\t\tlet call_data: String = \"944ddc62\".to_owned();\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tcall_contract_address,\n\t\t\t\thex::decode(call_data).unwrap(),\n\t\t\t\tU256::zero(),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&<Test as Config>::config().clone(),\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\t// Find how many random balance reads can we do with the available proof size.\n\t\t\tlet reading_main_contract_len =\n\t\t\t\tAccountCodes::<Test>::get(call_contract_address).len() as u64;\n\t\t\tlet overhead = reading_main_contract_len\n\t\t\t\t+ ACCOUNT_CODES_METADATA_PROOF_SIZE\n\t\t\t\t+ IS_EMPTY_CHECK_PROOF_SIZE;\n\t\t\tlet available_proof_size = weight_limit.proof_size() - overhead;\n\t\t\tlet number_balance_reads =\n\t\t\t\tavailable_proof_size.saturating_div(ACCOUNT_BASIC_PROOF_SIZE);\n\t\t\t// The actual proof size consumed by those balance reads.\n\t\t\tlet expected_proof_size = overhead + (number_balance_reads * ACCOUNT_BASIC_PROOF_SIZE);\n\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(expected_proof_size, actual_proof_size);\n\t\t});\n\t}\n\n\t#[test]\n\tfn uncached_account_code_proof_size_accounting_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\t// Create callee contract A\n\t\t\tlet gas_limit: u64 = 1_000_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\t\t\tlet result =\n\t\t\t\tcreate_proof_size_test_callee_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet subcall_contract_address = result.value;\n\n\t\t\t// Expect callee contract code hash and size to be cached\n\t\t\tlet _ = <AccountCodesMetadata<Test>>::get(subcall_contract_address)\n\t\t\t\t.expect(\"contract code hash and size are cached\");\n\n\t\t\t// Remove callee cache\n\t\t\t<AccountCodesMetadata<Test>>::remove(subcall_contract_address);\n\n\t\t\t// Create proof size test contract B\n\t\t\tlet result = create_proof_size_test_contract(gas_limit, None).expect(\"create succeeds\");\n\n\t\t\tlet call_contract_address = result.value;\n\n\t\t\t// Call B, that calls A, with weight limit\n\t\t\t// selector for ProofSizeTest::test_call function..\n\t\t\tlet mut call_data: String = \"c6d6f606000000000000000000000000\".to_owned();\n\t\t\t// ..encode the callee address argument\n\t\t\tcall_data.push_str(&format!(\"{:x}\", subcall_contract_address));\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tcall_contract_address,\n\t\t\t\thex::decode(&call_data).unwrap(),\n\t\t\t\tU256::zero(),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&<Test as Config>::config().clone(),\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\t// Expected proof size\n\t\t\tlet read_account_metadata = ACCOUNT_CODES_METADATA_PROOF_SIZE as usize;\n\t\t\tlet is_empty_check = (IS_EMPTY_CHECK_PROOF_SIZE * 2) as usize;\n\t\t\tlet increase_nonce = (ACCOUNT_BASIC_PROOF_SIZE * 3) as usize;\n\t\t\tlet reading_main_contract_len = AccountCodes::<Test>::get(call_contract_address).len();\n\t\t\tlet reading_callee_contract_len =\n\t\t\t\tAccountCodes::<Test>::get(subcall_contract_address).len();\n\t\t\t// In order to do the subcall, we need to check metadata 3 times -\n\t\t\t// one for each contract + one for the call opcode -, load two bytecodes - caller and callee.\n\t\t\tlet expected_proof_size = ((read_account_metadata * 2)\n\t\t\t\t+ reading_callee_contract_len\n\t\t\t\t+ reading_main_contract_len\n\t\t\t\t+ is_empty_check + increase_nonce) as u64;\n\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(expected_proof_size, actual_proof_size);\n\t\t});\n\t}\n\n\t#[test]\n\tfn proof_size_breaks_standard_transfer() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\t// In this test we do a simple transfer to an address with an stored code which is\n\t\t\t// greater in size (and thus load cost) than the transfer flat fee of 21_000.\n\n\t\t\t// We assert that providing 21_000 gas limit will not work, because the pov size limit\n\t\t\t// will OOG.\n\t\t\tlet fake_contract_address = H160::random();\n\t\t\tlet config = <Test as Config>::config().clone();\n\t\t\tlet fake_contract_code = vec![0; config.create_contract_limit.expect(\"a value\")];\n\t\t\tAccountCodes::<Test>::insert(fake_contract_address, fake_contract_code);\n\n\t\t\tlet gas_limit: u64 = 21_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tfake_contract_address,\n\t\t\t\tVec::new(),\n\t\t\t\tU256::from(777),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&config,\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\tassert_eq!(\n\t\t\t\tresult.exit_reason,\n\t\t\t\tcrate::ExitReason::Error(crate::ExitError::OutOfGas)\n\t\t\t);\n\t\t});\n\t}\n\n\t#[test]\n\tfn proof_size_based_refunding_works() {\n\t\tnew_test_ext().execute_with(|| {\n\t\t\t// In this test we do a simple transfer to an address with an stored code which is\n\t\t\t// greater in size (and thus load cost) than the transfer flat fee of 21_000.\n\n\t\t\t// Assert that if we provide enough gas limit, the refund will be based on the pov\n\t\t\t// size consumption, not the 21_000 gas.\n\t\t\tlet fake_contract_address = H160::random();\n\t\t\tlet config = <Test as Config>::config().clone();\n\t\t\tlet fake_contract_code = vec![0; config.create_contract_limit.expect(\"a value\")];\n\t\t\tAccountCodes::<Test>::insert(fake_contract_address, fake_contract_code);\n\n\t\t\tlet gas_limit: u64 = 700_000;\n\t\t\tlet weight_limit = FixedGasWeightMapping::<Test>::gas_to_weight(gas_limit, true);\n\n\t\t\tlet result = <Test as Config>::Runner::call(\n\t\t\t\tH160::default(),\n\t\t\t\tfake_contract_address,\n\t\t\t\tVec::new(),\n\t\t\t\tU256::from(777),\n\t\t\t\tgas_limit,\n\t\t\t\tSome(FixedGasPrice::min_gas_price().0),\n\t\t\t\tNone,\n\t\t\t\tNone,\n\t\t\t\tVec::new(),\n\t\t\t\ttrue, // transactional\n\t\t\t\ttrue, // must be validated\n\t\t\t\tSome(weight_limit),\n\t\t\t\tSome(0),\n\t\t\t\t&config,\n\t\t\t)\n\t\t\t.expect(\"call succeeds\");\n\n\t\t\tlet ratio = <<Test as Config>::GasLimitPovSizeRatio as Get<u64>>::get();\n\t\t\tlet used_gas = result.used_gas;\n\t\t\tlet actual_proof_size = result\n\t\t\t\t.weight_info\n\t\t\t\t.expect(\"weight info\")\n\t\t\t\t.proof_size_usage\n\t\t\t\t.expect(\"proof size usage\");\n\n\t\t\tassert_eq!(used_gas.standard, U256::from(21_000));\n\t\t\tassert_eq!(used_gas.effective, U256::from(actual_proof_size * ratio));\n\t\t});\n\t}\n}\n\ntype Balances = pallet_balances::Pallet<Test>;\n#[allow(clippy::upper_case_acronyms)]\ntype EVM = Pallet<Test>;\n\npub fn new_test_ext() -> sp_io::TestExternalities {\n\tlet mut t = frame_system::GenesisConfig::<Test>::default()\n\t\t.build_storage()\n\t\t.unwrap();\n\n\tlet mut accounts = BTreeMap::new();\n\taccounts.insert(\n\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\tGenesisAccount {\n\t\t\tnonce: U256::from(1),\n\t\t\tbalance: U256::from(1000000),\n\t\t\tstorage: Default::default(),\n\t\t\tcode: vec![\n\t\t\t\t0x00, // STOP\n\t\t\t],\n\t\t},\n\t);\n\taccounts.insert(\n\t\tH160::from_str(\"1000000000000000000000000000000000000002\").unwrap(),\n\t\tGenesisAccount {\n\t\t\tnonce: U256::from(1),\n\t\t\tbalance: U256::from(1000000),\n\t\t\tstorage: Default::default(),\n\t\t\tcode: vec![\n\t\t\t\t0xff, // INVALID\n\t\t\t],\n\t\t},\n\t);\n\taccounts.insert(\n\t\tH160::default(), // root\n\t\tGenesisAccount {\n\t\t\tnonce: U256::from(1),\n\t\t\tbalance: U256::max_value(),\n\t\t\tstorage: Default::default(),\n\t\t\tcode: vec![],\n\t\t},\n\t);\n\n\tpallet_balances::GenesisConfig::<Test> {\n\t\t// Create the block author account with some balance.\n\t\tbalances: vec![(\n\t\t\tH160::from_str(\"0x1234500000000000000000000000000000000000\").unwrap(),\n\t\t\t12345,\n\t\t)],\n\t}\n\t.assimilate_storage(&mut t)\n\t.expect(\"Pallet balances storage can be assimilated\");\n\n\tcrate::GenesisConfig::<Test> {\n\t\taccounts,\n\t\t..Default::default()\n\t}\n\t.assimilate_storage(&mut t)\n\t.unwrap();\n\n\tt.into()\n}\n\n#[test]\nfn fail_call_return_ok() {\n\tnew_test_ext().execute_with(|| {\n\t\tassert_ok!(EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::default(),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t));\n\n\t\tassert_ok!(EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000002\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::default(),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t));\n\t});\n}\n\n#[test]\nfn fee_deduction() {\n\tnew_test_ext().execute_with(|| {\n\t\t// Create an EVM address and the corresponding Substrate address that will be charged fees and refunded\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000003\").unwrap();\n\t\tlet substrate_addr = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\n\t\t// Seed account\n\t\tlet _ = <Test as Config>::Currency::deposit_creating(&substrate_addr, 100);\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 100);\n\n\t\t// Deduct fees as 10 units\n\t\tlet imbalance = <<Test as Config>::OnChargeTransaction as OnChargeEVMTransaction<Test>>::withdraw_fee(&evm_addr, U256::from(10)).unwrap();\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 90);\n\n\t\t// Refund fees as 5 units\n\t\t<<Test as Config>::OnChargeTransaction as OnChargeEVMTransaction<Test>>::correct_and_deposit_fee(&evm_addr, U256::from(5), U256::from(5), imbalance);\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 95);\n\t});\n}\n\n#[test]\nfn ed_0_refund_patch_works() {\n\tnew_test_ext().execute_with(|| {\n\t\t// Verifies that the OnChargeEVMTransaction patch is applied and fixes a known bug in Substrate for evm transactions.\n\t\t// https://github.com/paritytech/substrate/issues/10117\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000003\").unwrap();\n\t\tlet substrate_addr = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\n\t\tlet _ = <Test as Config>::Currency::deposit_creating(&substrate_addr, 21_777_000_000_000);\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 21_777_000_000_000);\n\n\t\tlet _ = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tevm_addr,\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1_000_000_000),\n\t\t\t21776,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tNone,\n\t\t\tSome(U256::from(0)),\n\t\t\tVec::new(),\n\t\t);\n\t\t// All that was due, was refunded.\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 776_000_000_000);\n\t});\n}\n\n#[test]\nfn ed_0_refund_patch_is_required() {\n\tnew_test_ext().execute_with(|| {\n\t\t// This test proves that the patch is required, verifying that the current Substrate behaviour is incorrect\n\t\t// for ED 0 configured chains.\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000003\").unwrap();\n\t\tlet substrate_addr = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\n\t\tlet _ = <Test as Config>::Currency::deposit_creating(&substrate_addr, 100);\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 100);\n\n\t\t// Drain funds\n\t\tlet _ =\n\t\t\t<<Test as Config>::OnChargeTransaction as OnChargeEVMTransaction<Test>>::withdraw_fee(\n\t\t\t\t&evm_addr,\n\t\t\t\tU256::from(100),\n\t\t\t)\n\t\t\t.unwrap();\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 0);\n\n\t\t// Try to refund. With ED 0, although the balance is now 0, the account still exists.\n\t\t// So its expected that calling `deposit_into_existing` results in the AccountData to increase the Balance.\n\t\t//\n\t\t// Is not the case, and this proves that the refund logic needs to be handled taking this into account.\n\t\tassert!(\n\t\t\t<Test as Config>::Currency::deposit_into_existing(&substrate_addr, 5u32.into())\n\t\t\t\t.is_err()\n\t\t);\n\t\t// Balance didn't change, and should be 5.\n\t\tassert_eq!(Balances::free_balance(substrate_addr), 0);\n\t});\n}\n\n#[test]\nfn find_author() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tassert_eq!(\n\t\t\tauthor,\n\t\t\tH160::from_str(\"1234500000000000000000000000000000000000\").unwrap()\n\t\t);\n\t});\n}\n\n#[test]\nfn reducible_balance() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000001\").unwrap();\n\t\tlet account_id = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\t\tlet existential = ExistentialDeposit::get();\n\n\t\t// Genesis Balance.\n\t\tlet genesis_balance = EVM::account_basic(&evm_addr).0.balance;\n\n\t\t// Lock identifier.\n\t\tlet lock_id: LockIdentifier = *b\"te/stlok\";\n\t\t// Reserve some funds.\n\t\tlet to_lock = 1000;\n\t\tBalances::set_lock(lock_id, &account_id, to_lock, WithdrawReasons::RESERVE);\n\t\t// Reducible is, as currently configured in `account_basic`, (balance - lock - existential).\n\t\tlet reducible_balance = EVM::account_basic(&evm_addr).0.balance;\n\t\tassert_eq!(reducible_balance, (genesis_balance - to_lock - existential));\n\t});\n}\n\n#[test]\nfn author_should_get_tip() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tlet before_tip = EVM::account_basic(&author).0.balance;\n\t\tlet result = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(2_000_000_000),\n\t\t\tSome(U256::from(1)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tresult.expect(\"EVM can be called\");\n\t\tlet after_tip = EVM::account_basic(&author).0.balance;\n\t\tassert_eq!(after_tip, (before_tip + 21000));\n\t});\n}\n\n#[test]\nfn issuance_after_tip() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet before_tip = <Test as Config>::Currency::total_issuance();\n\t\tlet result = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(2_000_000_000),\n\t\t\tSome(U256::from(1)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tresult.expect(\"EVM can be called\");\n\t\tlet after_tip = <Test as Config>::Currency::total_issuance();\n\t\t// Only base fee is burned\n\t\tlet base_fee: u64 = <Test as Config>::FeeCalculator::min_gas_price()\n\t\t\t.0\n\t\t\t.unique_saturated_into();\n\t\tassert_eq!(after_tip, (before_tip - (base_fee * 21_000)));\n\t});\n}\n\n#[test]\nfn author_same_balance_without_tip() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tlet before_tip = EVM::account_basic(&author).0.balance;\n\t\tlet _ = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::default(),\n\t\t\t1000000,\n\t\t\tU256::default(),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tlet after_tip = EVM::account_basic(&author).0.balance;\n\t\tassert_eq!(after_tip, before_tip);\n\t});\n}\n\n#[test]\nfn refunds_should_work() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet before_call = EVM::account_basic(&H160::default()).0.balance;\n\t\t// Gas price is not part of the actual fee calculations anymore, only the base fee.\n\t\t//\n\t\t// Because we first deduct max_fee_per_gas * gas_limit (2_000_000_000 * 1000000) we need\n\t\t// to ensure that the difference (max fee VS base fee) is refunded.\n\t\tlet _ = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(2_000_000_000),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tlet (base_fee, _) = <Test as Config>::FeeCalculator::min_gas_price();\n\t\tlet total_cost = (U256::from(21_000) * base_fee) + U256::from(1);\n\t\tlet after_call = EVM::account_basic(&H160::default()).0.balance;\n\t\tassert_eq!(after_call, before_call - total_cost);\n\t});\n}\n\n#[test]\nfn refunds_and_priority_should_work() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tlet before_tip = EVM::account_basic(&author).0.balance;\n\t\tlet before_call = EVM::account_basic(&H160::default()).0.balance;\n\t\t// We deliberately set a base fee + max tip > max fee.\n\t\t// The effective priority tip will be 1GWEI instead 1.5GWEI:\n\t\t// \t\t(max_fee_per_gas - base_fee).min(max_priority_fee)\n\t\t//\t\t(2 - 1).min(1.5)\n\t\tlet tip = U256::from(1_500_000_000);\n\t\tlet max_fee_per_gas = U256::from(2_000_000_000);\n\t\tlet used_gas = U256::from(21_000);\n\t\tlet _ = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tmax_fee_per_gas,\n\t\t\tSome(tip),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tlet (base_fee, _) = <Test as Config>::FeeCalculator::min_gas_price();\n\t\tlet actual_tip = (max_fee_per_gas - base_fee).min(tip) * used_gas;\n\t\tlet total_cost = (used_gas * base_fee) + actual_tip + U256::from(1);\n\t\tlet after_call = EVM::account_basic(&H160::default()).0.balance;\n\t\t// The tip is deducted but never refunded to the caller.\n\t\tassert_eq!(after_call, before_call - total_cost);\n\n\t\tlet after_tip = EVM::account_basic(&author).0.balance;\n\t\tassert_eq!(after_tip, (before_tip + actual_tip));\n\t});\n}\n\n#[test]\nfn call_should_fail_with_priority_greater_than_max_fee() {\n\tnew_test_ext().execute_with(|| {\n\t\t// Max priority greater than max fee should fail.\n\t\tlet tip: u128 = 1_100_000_000;\n\t\tlet result = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tSome(U256::from(tip)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tassert!(result.is_err());\n\t\t// Some used weight is returned as part of the error.\n\t\tassert_eq!(\n\t\t\tresult.unwrap_err().post_info.actual_weight,\n\t\t\tSome(Weight::from_parts(7, 0))\n\t\t);\n\t});\n}\n\n#[test]\nfn call_should_succeed_with_priority_equal_to_max_fee() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet tip: u128 = 1_000_000_000;\n\t\t// Mimics the input for pre-eip-1559 transaction types where `gas_price`\n\t\t// is used for both `max_fee_per_gas` and `max_priority_fee_per_gas`.\n\t\tlet result = EVM::call(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tSome(U256::from(tip)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tassert!(result.is_ok());\n\t});\n}\n\n#[test]\nfn handle_sufficient_reference() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet addr = H160::from_str(\"1230000000000000000000000000000000000001\").unwrap();\n\t\tlet addr_2 = H160::from_str(\"1234000000000000000000000000000000000001\").unwrap();\n\t\tlet substrate_addr: <Test as frame_system::Config>::AccountId =\n\t\t\t<Test as Config>::AddressMapping::into_account_id(addr);\n\t\tlet substrate_addr_2: <Test as frame_system::Config>::AccountId =\n\t\t\t<Test as Config>::AddressMapping::into_account_id(addr_2);\n\n\t\t// Sufficients should increase when creating EVM accounts.\n\t\t<crate::AccountCodes<Test>>::insert(addr, vec![0]);\n\t\tlet account = frame_system::Account::<Test>::get(substrate_addr);\n\t\t// Using storage is not correct as it leads to a sufficient reference mismatch.\n\t\tassert_eq!(account.sufficients, 0);\n\n\t\t// Using the create / remove account functions is the correct way to handle it.\n\t\tEVM::create_account(addr_2, vec![1, 2, 3]);\n\t\tlet account_2 = frame_system::Account::<Test>::get(substrate_addr_2);\n\t\t// We increased the sufficient reference by 1.\n\t\tassert_eq!(account_2.sufficients, 1);\n\t\tEVM::remove_account(&addr_2);\n\t\tlet account_2 = frame_system::Account::<Test>::get(substrate_addr_2);\n\t\tassert_eq!(account_2.sufficients, 1);\n\t});\n}\n\n#[test]\nfn runner_non_transactional_calls_with_non_balance_accounts_is_ok_without_gas_price() {\n\t// Expect to skip checks for gas price and account balance when both:\n\t//\t- The call is non transactional (`is_transactional == false`).\n\t//\t- The `max_fee_per_gas` is None.\n\tnew_test_ext().execute_with(|| {\n\t\tlet non_balance_account =\n\t\t\tH160::from_str(\"7700000000000000000000000000000000000001\").unwrap();\n\t\tassert_eq!(\n\t\t\tEVM::account_basic(&non_balance_account).0.balance,\n\t\t\tU256::zero()\n\t\t);\n\t\tlet _ = <Test as Config>::Runner::call(\n\t\t\tnon_balance_account,\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\tfalse, // non-transactional\n\t\t\ttrue,  // must be validated\n\t\t\tNone,\n\t\t\tNone,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t)\n\t\t.expect(\"Non transactional call succeeds\");\n\t\tassert_eq!(\n\t\t\tEVM::account_basic(&non_balance_account).0.balance,\n\t\t\tU256::zero()\n\t\t);\n\t});\n}\n\n#[test]\nfn runner_non_transactional_calls_with_non_balance_accounts_is_err_with_gas_price() {\n\t// In non transactional calls where `Some(gas_price)` is defined, expect it to be\n\t// checked against the `BaseFee`, and expect the account to have enough balance\n\t// to pay for the call.\n\tnew_test_ext().execute_with(|| {\n\t\tlet non_balance_account =\n\t\t\tH160::from_str(\"7700000000000000000000000000000000000001\").unwrap();\n\t\tassert_eq!(\n\t\t\tEVM::account_basic(&non_balance_account).0.balance,\n\t\t\tU256::zero()\n\t\t);\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tnon_balance_account,\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tSome(U256::from(1_000_000_000)),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\tfalse, // non-transactional\n\t\t\ttrue,  // must be validated\n\t\t\tNone,\n\t\t\tNone,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t});\n}\n\n#[test]\nfn runner_transactional_call_with_zero_gas_price_fails() {\n\t// Transactional calls are rejected when `max_fee_per_gas == None`.\n\tnew_test_ext().execute_with(|| {\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\ttrue, // transactional\n\t\t\ttrue, // must be validated\n\t\t\tNone,\n\t\t\tNone,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t});\n}\n\n#[test]\nfn runner_max_fee_per_gas_gte_max_priority_fee_per_gas() {\n\t// Transactional and non transactional calls enforce `max_fee_per_gas >= max_priority_fee_per_gas`.\n\tnew_test_ext().execute_with(|| {\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tSome(U256::from(1_000_000_000)),\n\t\t\tSome(U256::from(2_000_000_000)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\ttrue, // transactional\n\t\t\ttrue, // must be validated\n\t\t\tNone,\n\t\t\tNone,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tSome(U256::from(1_000_000_000)),\n\t\t\tSome(U256::from(2_000_000_000)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\tfalse, // non-transactional\n\t\t\ttrue,  // must be validated\n\t\t\tNone,\n\t\t\tNone,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t});\n}\n\n#[test]\nfn eip3607_transaction_from_contract() {\n\tnew_test_ext().execute_with(|| {\n\t\t// external transaction\n\t\tmatch <Test as Config>::Runner::call(\n\t\t\t// Contract address.\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\ttrue,  // transactional\n\t\t\tfalse, // not sure be validated\n\t\t\tNone,\n\t\t\tNone,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t) {\n\t\t\tErr(RunnerError {\n\t\t\t\terror: Error::TransactionMustComeFromEOA,\n\t\t\t\t..\n\t\t\t}) => (),\n\t\t\t_ => panic!(\"Should have failed\"),\n\t\t}\n\n\t\t// internal call\n\t\tassert!(<Test as Config>::Runner::call(\n\t\t\t// Contract address.\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\tfalse, // non-transactional\n\t\t\ttrue,  // must be validated\n\t\t\tNone,\n\t\t\tNone,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t)\n\t\t.is_ok());\n\t});\n}\n\n#[test]\nfn metadata_code_gets_cached() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet address = H160::repeat_byte(0xaa);\n\n\t\tcrate::Pallet::<Test>::create_account(address, b\"Exemple\".to_vec());\n\n\t\tlet metadata = crate::Pallet::<Test>::account_code_metadata(address);\n\t\tassert_eq!(metadata.size, 7);\n\t\tassert_eq!(\n\t\t\tmetadata.hash,\n\t\t\thex_literal::hex!(\"e8396a990fe08f2402e64a00647e41dadf360ba078a59ba79f55e876e67ed4bc\")\n\t\t\t\t.into()\n\t\t);\n\n\t\tlet metadata2 = <AccountCodesMetadata<Test>>::get(address).expect(\"to have metadata set\");\n\t\tassert_eq!(metadata, metadata2);\n\t});\n}\n\n#[test]\nfn metadata_empty_dont_code_gets_cached() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet address = H160::repeat_byte(0xaa);\n\n\t\tlet metadata = crate::Pallet::<Test>::account_code_metadata(address);\n\t\tassert_eq!(metadata.size, 0);\n\t\tassert_eq!(\n\t\t\tmetadata.hash,\n\t\t\thex_literal::hex!(\"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\")\n\t\t\t\t.into()\n\t\t);\n\n\t\tassert!(<AccountCodesMetadata<Test>>::get(address).is_none());\n\t});\n}\n"], "filenames": ["frame/evm/src/lib.rs", "frame/evm/src/tests.rs"], "buggy_code_start_loc": [563, 1040], "buggy_code_end_loc": [807, 1042], "fixing_code_start_loc": [564, 1040], "fixing_code_end_loc": [822, 1041], "type": "CWE-770", "message": "Frontier is Substrate's Ethereum compatibility layer. Prior to commit aea528198b3b226e0d20cce878551fd4c0e3d5d0, at the end of a contract execution, when opcode SUICIDE marks a contract to be deleted, the software uses `storage::remove_prefix` (now renamed to `storage::clear_prefix`) to remove all storages associated with it. This is a single IO primitive call passing the WebAssembly boundary. For large contracts, the call (without providing a `limit` parameter) can be slow. In addition, for parachains, all storages to be deleted will be part of the PoV, which easily exceed relay chain PoV size limit. On the other hand, Frontier's maintainers only charge a fixed cost for opcode SUICIDE. The maintainers consider the severity of this issue high, because an attacker can craft a contract with a lot of storage values on a parachain, and then call opcode SUICIDE on the contract. If the transaction makes into a parachain block, the parachain will then stall because the PoV size will exceed relay chain's limit. This is especially an issue for XCM transactions, because they can't be skipped. Commit aea528198b3b226e0d20cce878551fd4c0e3d5d0 contains a patch for this issue. For parachains, it's recommended to issue an emergency runtime upgrade as soon as possible. For standalone chains, the impact is less severe because the issue mainly affects PoV sizes. It's recommended to issue a normal runtime upgrade as soon as possible. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-45130", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-13T13:15:11.827", "lastModified": "2023-10-24T13:56:46.973", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Frontier is Substrate's Ethereum compatibility layer. Prior to commit aea528198b3b226e0d20cce878551fd4c0e3d5d0, at the end of a contract execution, when opcode SUICIDE marks a contract to be deleted, the software uses `storage::remove_prefix` (now renamed to `storage::clear_prefix`) to remove all storages associated with it. This is a single IO primitive call passing the WebAssembly boundary. For large contracts, the call (without providing a `limit` parameter) can be slow. In addition, for parachains, all storages to be deleted will be part of the PoV, which easily exceed relay chain PoV size limit. On the other hand, Frontier's maintainers only charge a fixed cost for opcode SUICIDE. The maintainers consider the severity of this issue high, because an attacker can craft a contract with a lot of storage values on a parachain, and then call opcode SUICIDE on the contract. If the transaction makes into a parachain block, the parachain will then stall because the PoV size will exceed relay chain's limit. This is especially an issue for XCM transactions, because they can't be skipped. Commit aea528198b3b226e0d20cce878551fd4c0e3d5d0 contains a patch for this issue. For parachains, it's recommended to issue an emergency runtime upgrade as soon as possible. For standalone chains, the impact is less severe because the issue mainly affects PoV sizes. It's recommended to issue a normal runtime upgrade as soon as possible. There are no known workarounds."}, {"lang": "es", "value": "Frontier es la capa de compatibilidad con Ethereum de Substrate. Antes del commit aea528198b3b226e0d20cce878551fd4c0e3d5d0, al final de la ejecuci\u00f3n de un contrato, cuando el c\u00f3digo de operaci\u00f3n SUICIDE marca un contrato para ser eliminado, el software utiliza `storage::remove_prefix` (ahora renombrado a `storage::clear_prefix`) para eliminar todos los almacenamientos asociados con \u00e9l. Esta es una \u00fanica llamada primitiva de IO que pasa el l\u00edmite de WebAssembly. Para contratos grandes, la llamada (sin proporcionar un par\u00e1metro de \"limit\") puede ser lenta. Adem\u00e1s, para las parachains, todos los almacenamientos que se eliminar\u00e1n formar\u00e1n parte del PoV, que excede f\u00e1cilmente el l\u00edmite de tama\u00f1o de PoV de la cadena de retransmisi\u00f3n. Por otro lado, los mantenedores de Frontier solo cobran un costo fijo por el c\u00f3digo de operaci\u00f3n SUICIDE. Los mantenedores consideran que la gravedad de este problema es alta, porque un atacante puede crear un contrato con muchos valores de almacenamiento en una parachain y luego llamar al c\u00f3digo de operaci\u00f3n SUICIDE en el contrato. Si la transacci\u00f3n se convierte en un bloque de parachain, la parachain se detendr\u00e1 porque el tama\u00f1o del PoV exceder\u00e1 el l\u00edmite de la cadena de retransmisi\u00f3n. Esto es especialmente un problema para las transacciones XCM, porque no se pueden omitir. El commit aea528198b3b226e0d20cce878551fd4c0e3d5d0 contiene un parche para este problema. Para las parachains, se recomienda publicar una actualizaci\u00f3n de emergencia del tiempo de ejecuci\u00f3n lo antes posible. Para las cadenas independientes, el impacto es menos grave porque el problema afecta principalmente a los tama\u00f1os de PoV. Se recomienda publicar una actualizaci\u00f3n del tiempo de ejecuci\u00f3n normal lo antes posible. No se conocen workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parity:frontier:*:*:*:*:*:rust:*:*", "versionEndIncluding": "0.1.0", "matchCriteriaId": "20043267-E766-4C8E-B0BD-3F91289C2F4C"}]}]}], "references": [{"url": "https://github.com/paritytech/frontier/commit/aea528198b3b226e0d20cce878551fd4c0e3d5d0", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/paritytech/frontier/pull/1212", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/paritytech/frontier/security/advisories/GHSA-gc88-2gvv-gp3v", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/paritytech/frontier/commit/aea528198b3b226e0d20cce878551fd4c0e3d5d0"}}