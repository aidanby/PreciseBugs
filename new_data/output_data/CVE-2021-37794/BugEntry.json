{"buggy_code": ["package http\n\nimport (\n\t\"io/fs\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\n\t\"github.com/filebrowser/filebrowser/v2/settings\"\n\t\"github.com/filebrowser/filebrowser/v2/storage\"\n)\n\ntype modifyRequest struct {\n\tWhat  string   `json:\"what\"`  // Answer to: what data type?\n\tWhich []string `json:\"which\"` // Answer to: which fields?\n}\n\nfunc NewHandler(\n\timgSvc ImgService,\n\tfileCache FileCache,\n\tstore *storage.Storage,\n\tserver *settings.Server,\n\tassetsFs fs.FS,\n) (http.Handler, error) {\n\tserver.Clean()\n\n\tr := mux.NewRouter()\n\tindex, static := getStaticHandlers(store, server, assetsFs)\n\n\t// NOTE: This fixes the issue where it would redirect if people did not put a\n\t// trailing slash in the end. I hate this decision since this allows some awful\n\t// URLs https://www.gorillatoolkit.org/pkg/mux#Router.SkipClean\n\tr = r.SkipClean(true)\n\n\tmonkey := func(fn handleFunc, prefix string) http.Handler {\n\t\treturn handle(fn, prefix, store, server)\n\t}\n\n\tr.HandleFunc(\"/health\", healthHandler)\n\tr.PathPrefix(\"/static\").Handler(static)\n\tr.NotFoundHandler = index\n\n\tapi := r.PathPrefix(\"/api\").Subrouter()\n\n\tapi.Handle(\"/login\", monkey(loginHandler, \"\"))\n\tapi.Handle(\"/signup\", monkey(signupHandler, \"\"))\n\tapi.Handle(\"/renew\", monkey(renewHandler, \"\"))\n\n\tusers := api.PathPrefix(\"/users\").Subrouter()\n\tusers.Handle(\"\", monkey(usersGetHandler, \"\")).Methods(\"GET\")\n\tusers.Handle(\"\", monkey(userPostHandler, \"\")).Methods(\"POST\")\n\tusers.Handle(\"/{id:[0-9]+}\", monkey(userPutHandler, \"\")).Methods(\"PUT\")\n\tusers.Handle(\"/{id:[0-9]+}\", monkey(userGetHandler, \"\")).Methods(\"GET\")\n\tusers.Handle(\"/{id:[0-9]+}\", monkey(userDeleteHandler, \"\")).Methods(\"DELETE\")\n\n\tapi.PathPrefix(\"/resources\").Handler(monkey(resourceGetHandler, \"/api/resources\")).Methods(\"GET\")\n\tapi.PathPrefix(\"/resources\").Handler(monkey(resourceDeleteHandler(fileCache), \"/api/resources\")).Methods(\"DELETE\")\n\tapi.PathPrefix(\"/resources\").Handler(monkey(resourcePostHandler(fileCache), \"/api/resources\")).Methods(\"POST\")\n\tapi.PathPrefix(\"/resources\").Handler(monkey(resourcePutHandler, \"/api/resources\")).Methods(\"PUT\")\n\tapi.PathPrefix(\"/resources\").Handler(monkey(resourcePatchHandler(fileCache), \"/api/resources\")).Methods(\"PATCH\")\n\n\tapi.Path(\"/shares\").Handler(monkey(shareListHandler, \"/api/shares\")).Methods(\"GET\")\n\tapi.PathPrefix(\"/share\").Handler(monkey(shareGetsHandler, \"/api/share\")).Methods(\"GET\")\n\tapi.PathPrefix(\"/share\").Handler(monkey(sharePostHandler, \"/api/share\")).Methods(\"POST\")\n\tapi.PathPrefix(\"/share\").Handler(monkey(shareDeleteHandler, \"/api/share\")).Methods(\"DELETE\")\n\n\tapi.Handle(\"/settings\", monkey(settingsGetHandler, \"\")).Methods(\"GET\")\n\tapi.Handle(\"/settings\", monkey(settingsPutHandler, \"\")).Methods(\"PUT\")\n\n\tapi.PathPrefix(\"/raw\").Handler(monkey(rawHandler, \"/api/raw\")).Methods(\"GET\")\n\tapi.PathPrefix(\"/preview/{size}/{path:.*}\").\n\t\tHandler(monkey(previewHandler(imgSvc, fileCache, server.EnableThumbnails, server.ResizePreview), \"/api/preview\")).Methods(\"GET\")\n\tapi.PathPrefix(\"/command\").Handler(monkey(commandsHandler, \"/api/command\")).Methods(\"GET\")\n\tapi.PathPrefix(\"/search\").Handler(monkey(searchHandler, \"/api/search\")).Methods(\"GET\")\n\n\tpublic := api.PathPrefix(\"/public\").Subrouter()\n\tpublic.PathPrefix(\"/dl\").Handler(monkey(publicDlHandler, \"/api/public/dl/\")).Methods(\"GET\")\n\tpublic.PathPrefix(\"/share\").Handler(monkey(publicShareHandler, \"/api/public/share/\")).Methods(\"GET\")\n\n\treturn stripPrefix(server.BaseURL, r), nil\n}\n"], "fixing_code": ["package http\n\nimport (\n\t\"io/fs\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\n\t\"github.com/filebrowser/filebrowser/v2/settings\"\n\t\"github.com/filebrowser/filebrowser/v2/storage\"\n)\n\ntype modifyRequest struct {\n\tWhat  string   `json:\"what\"`  // Answer to: what data type?\n\tWhich []string `json:\"which\"` // Answer to: which fields?\n}\n\nfunc NewHandler(\n\timgSvc ImgService,\n\tfileCache FileCache,\n\tstore *storage.Storage,\n\tserver *settings.Server,\n\tassetsFs fs.FS,\n) (http.Handler, error) {\n\tserver.Clean()\n\n\tr := mux.NewRouter()\n\tr.Use(func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Header().Set(\"Content-Security-Policy\", `default-src 'self'`)\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t})\n\tindex, static := getStaticHandlers(store, server, assetsFs)\n\n\t// NOTE: This fixes the issue where it would redirect if people did not put a\n\t// trailing slash in the end. I hate this decision since this allows some awful\n\t// URLs https://www.gorillatoolkit.org/pkg/mux#Router.SkipClean\n\tr = r.SkipClean(true)\n\n\tmonkey := func(fn handleFunc, prefix string) http.Handler {\n\t\treturn handle(fn, prefix, store, server)\n\t}\n\n\tr.HandleFunc(\"/health\", healthHandler)\n\tr.PathPrefix(\"/static\").Handler(static)\n\tr.NotFoundHandler = index\n\n\tapi := r.PathPrefix(\"/api\").Subrouter()\n\n\tapi.Handle(\"/login\", monkey(loginHandler, \"\"))\n\tapi.Handle(\"/signup\", monkey(signupHandler, \"\"))\n\tapi.Handle(\"/renew\", monkey(renewHandler, \"\"))\n\n\tusers := api.PathPrefix(\"/users\").Subrouter()\n\tusers.Handle(\"\", monkey(usersGetHandler, \"\")).Methods(\"GET\")\n\tusers.Handle(\"\", monkey(userPostHandler, \"\")).Methods(\"POST\")\n\tusers.Handle(\"/{id:[0-9]+}\", monkey(userPutHandler, \"\")).Methods(\"PUT\")\n\tusers.Handle(\"/{id:[0-9]+}\", monkey(userGetHandler, \"\")).Methods(\"GET\")\n\tusers.Handle(\"/{id:[0-9]+}\", monkey(userDeleteHandler, \"\")).Methods(\"DELETE\")\n\n\tapi.PathPrefix(\"/resources\").Handler(monkey(resourceGetHandler, \"/api/resources\")).Methods(\"GET\")\n\tapi.PathPrefix(\"/resources\").Handler(monkey(resourceDeleteHandler(fileCache), \"/api/resources\")).Methods(\"DELETE\")\n\tapi.PathPrefix(\"/resources\").Handler(monkey(resourcePostHandler(fileCache), \"/api/resources\")).Methods(\"POST\")\n\tapi.PathPrefix(\"/resources\").Handler(monkey(resourcePutHandler, \"/api/resources\")).Methods(\"PUT\")\n\tapi.PathPrefix(\"/resources\").Handler(monkey(resourcePatchHandler(fileCache), \"/api/resources\")).Methods(\"PATCH\")\n\n\tapi.Path(\"/shares\").Handler(monkey(shareListHandler, \"/api/shares\")).Methods(\"GET\")\n\tapi.PathPrefix(\"/share\").Handler(monkey(shareGetsHandler, \"/api/share\")).Methods(\"GET\")\n\tapi.PathPrefix(\"/share\").Handler(monkey(sharePostHandler, \"/api/share\")).Methods(\"POST\")\n\tapi.PathPrefix(\"/share\").Handler(monkey(shareDeleteHandler, \"/api/share\")).Methods(\"DELETE\")\n\n\tapi.Handle(\"/settings\", monkey(settingsGetHandler, \"\")).Methods(\"GET\")\n\tapi.Handle(\"/settings\", monkey(settingsPutHandler, \"\")).Methods(\"PUT\")\n\n\tapi.PathPrefix(\"/raw\").Handler(monkey(rawHandler, \"/api/raw\")).Methods(\"GET\")\n\tapi.PathPrefix(\"/preview/{size}/{path:.*}\").\n\t\tHandler(monkey(previewHandler(imgSvc, fileCache, server.EnableThumbnails, server.ResizePreview), \"/api/preview\")).Methods(\"GET\")\n\tapi.PathPrefix(\"/command\").Handler(monkey(commandsHandler, \"/api/command\")).Methods(\"GET\")\n\tapi.PathPrefix(\"/search\").Handler(monkey(searchHandler, \"/api/search\")).Methods(\"GET\")\n\n\tpublic := api.PathPrefix(\"/public\").Subrouter()\n\tpublic.PathPrefix(\"/dl\").Handler(monkey(publicDlHandler, \"/api/public/dl/\")).Methods(\"GET\")\n\tpublic.PathPrefix(\"/share\").Handler(monkey(publicShareHandler, \"/api/public/share/\")).Methods(\"GET\")\n\n\treturn stripPrefix(server.BaseURL, r), nil\n}\n"], "filenames": ["http/http.go"], "buggy_code_start_loc": [27], "buggy_code_end_loc": [27], "fixing_code_start_loc": [28], "fixing_code_end_loc": [34], "type": "CWE-79", "message": "A stored cross-site scripting (XSS) vulnerability exists in FileBrowser < v2.16.0 that allows an authenticated user authorized to upload a malicious .svg file which acts as a stored XSS payload. If this stored XSS payload is triggered by an administrator it will trigger malicious OS commands on the server running the FileBrowser instance.", "other": {"cve": {"id": "CVE-2021-37794", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-31T18:15:08.317", "lastModified": "2021-09-08T17:27:36.207", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A stored cross-site scripting (XSS) vulnerability exists in FileBrowser < v2.16.0 that allows an authenticated user authorized to upload a malicious .svg file which acts as a stored XSS payload. If this stored XSS payload is triggered by an administrator it will trigger malicious OS commands on the server running the FileBrowser instance."}, {"lang": "es", "value": "Se presenta una vulnerabilidad de tipo cross-site scripting (XSS) almacenado en FileBrowser versiones anteriores a v2.16.0, que permite a un usuario autenticado y autorizado cargar un archivo .svg malicioso que act\u00faa como carga \u00fatil de tipo XSS almacenado. Si esta carga \u00fatil de tipo XSS almacenado es desencadenada por un administrador, activar\u00e1 comandos maliciosos del Sistema Operativo en el servidor ejecutando la instancia de FileBrowser"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:filebrowser_project:filebrowser:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.16.0", "matchCriteriaId": "83F268EF-0819-44B9-83CD-10569102DDFA"}]}]}], "references": [{"url": "https://gist.github.com/omriinbar/1e28649f31d795b0e9b7698a9d255b5c", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/filebrowser/filebrowser", "source": "cve@mitre.org", "tags": ["Product", "Third Party Advisory"]}, {"url": "https://github.com/filebrowser/filebrowser/commit/201329abce4e92ae9071b9ded81e267aae159fbd", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/filebrowser/filebrowser/commit/201329abce4e92ae9071b9ded81e267aae159fbd"}}