{"buggy_code": ["/*\nDeveloped by ESN, an Electronic Arts Inc. studio.\nCopyright (c) 2014, Electronic Arts Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n* Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n* Neither the name of ESN, Electronic Arts Inc. nor the\nnames of its contributors may be used to endorse or promote products\nderived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL ELECTRONIC ARTS INC. BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nPortions of code from MODP_ASCII - Ascii transformations (upper/lower, etc)\nhttps://github.com/client9/stringencoders\nCopyright (c) 2007  Nick Galbreath -- nickg [at] modp [dot] com. All rights reserved.\n\nNumeric decoder derived from from TCL library\nhttps://opensource.apple.com/source/tcl/tcl-14/tcl/license.terms\n* Copyright (c) 1988-1993 The Regents of the University of California.\n* Copyright (c) 1994 Sun Microsystems, Inc.\n*/\n\n#include \"ultrajson.h\"\n#include <math.h>\n#include <assert.h>\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n\n#ifndef TRUE\n#define TRUE 1\n#define FALSE 0\n#endif\n#ifndef NULL\n#define NULL 0\n#endif\n\nstruct DecoderState\n{\n  char *start;\n  char *end;\n  JSUINT32 *escStart;\n  JSUINT32 *escEnd;\n  int escHeap;\n  int lastType;\n  JSUINT32 objDepth;\n  void *prv;\n  JSONObjectDecoder *dec;\n};\n\nstatic JSOBJ FASTCALL_MSVC decode_any( struct DecoderState *ds) FASTCALL_ATTR;\ntypedef JSOBJ (*PFN_DECODER)( struct DecoderState *ds);\n\nstatic JSOBJ SetError( struct DecoderState *ds, int offset, const char *message)\n{\n  ds->dec->errorOffset = ds->start + offset;\n  ds->dec->errorStr = (char *) message;\n  return NULL;\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decodeDouble(struct DecoderState *ds)\n{\n  int processed_characters_count;\n  int len = (int)(ds->end - ds->start);\n  double value = dconv_s2d(ds->dec->s2d, ds->start, len, &processed_characters_count);\n  ds->lastType = JT_DOUBLE;\n  ds->start += processed_characters_count;\n  return ds->dec->newDouble(ds->prv, value);\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_numeric (struct DecoderState *ds)\n{\n  int intNeg = 1;\n  int hasError = 0;\n  JSUINT64 intValue;\n  JSUINT64 addIntValue;\n  int chr;\n  char *offset = ds->start;\n\n  JSUINT64 maxIntValue = ULLONG_MAX;\n  JSUINT64 overflowLimit = maxIntValue / 10LLU;\n\n  if (*(offset) == 'I')\n  {\n    goto DECODE_INF;\n  }\n  else if (*(offset) == 'N')\n  {\n    goto DECODE_NAN;\n  }\n  else if (*(offset) == '-')\n  {\n    offset++;\n    intNeg = -1;\n    if (*(offset) == 'I')\n    {\n      goto DECODE_INF;\n    }\n    maxIntValue = -(JSUINT64) LLONG_MIN;\n    overflowLimit = maxIntValue / 10LL;\n  }\n\n  // Scan integer part\n  intValue = 0;\n\n  while (1)\n  {\n    chr = (int) (unsigned char) *(offset);\n\n    switch (chr)\n    {\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      {\n        // check whether multiplication would be out of bounds\n        if (intValue > overflowLimit)\n        {\n          hasError = 1;\n        }\n        intValue *= 10ULL;\n        addIntValue = (JSUINT64) (chr - 48);\n\n        // check whether addition would be out of bounds\n        if (maxIntValue - intValue < addIntValue)\n        {\n          hasError = 1;\n        }\n\n        intValue += addIntValue;\n        offset ++;\n        break;\n      }\n      case '.':\n      {\n        offset ++;\n        return decodeDouble(ds);\n      }\n      case 'e':\n      case 'E':\n      {\n        offset ++;\n        return decodeDouble(ds);\n      }\n\n      default:\n      {\n        if (hasError)\n        {\n          char *strStart = ds->start;\n          ds->lastType = JT_INT;\n          ds->start = offset;\n          return ds->dec->newIntegerFromString(ds->prv, strStart, offset - strStart);\n        }\n        goto BREAK_INT_LOOP;\n        break;\n      }\n    }\n  }\n\nBREAK_INT_LOOP:\n\n  ds->lastType = JT_INT;\n  ds->start = offset;\n\n  if (intNeg == 1 && (intValue & 0x8000000000000000ULL) != 0)\n  {\n    return ds->dec->newUnsignedLong(ds->prv, intValue);\n  }\n  else if ((intValue >> 31))\n  {\n    return ds->dec->newLong(ds->prv, (JSINT64) (intValue * (JSINT64) intNeg));\n  }\n  else\n  {\n    return ds->dec->newInt(ds->prv, (JSINT32) (intValue * intNeg));\n  }\n\nDECODE_NAN:\n    offset++;\n    if (*(offset++) != 'a') goto SET_NAN_ERROR;\n    if (*(offset++) != 'N') goto SET_NAN_ERROR;\n\n    ds->lastType = JT_NAN;\n    ds->start = offset;\n    return ds->dec->newNaN(ds->prv);\n\nSET_NAN_ERROR:\n    return SetError(ds, -1, \"Unexpected character found when decoding 'NaN'\");\n\nDECODE_INF:\n    offset++;\n    if (*(offset++) != 'n') goto SET_INF_ERROR;\n    if (*(offset++) != 'f') goto SET_INF_ERROR;\n    if (*(offset++) != 'i') goto SET_INF_ERROR;\n    if (*(offset++) != 'n') goto SET_INF_ERROR;\n    if (*(offset++) != 'i') goto SET_INF_ERROR;\n    if (*(offset++) != 't') goto SET_INF_ERROR;\n    if (*(offset++) != 'y') goto SET_INF_ERROR;\n\n    ds->start = offset;\n\n    if (intNeg == 1) {\n      ds->lastType = JT_POS_INF;\n      return ds->dec->newPosInf(ds->prv);\n    } else {\n      ds->lastType = JT_NEG_INF;\n      return ds->dec->newNegInf(ds->prv);\n    }\n\nSET_INF_ERROR:\n    if (intNeg == 1) {\n      const char *msg = \"Unexpected character found when decoding 'Infinity'\";\n      return SetError(ds, -1, msg);\n    } else {\n      const char *msg = \"Unexpected character found when decoding '-Infinity'\";\n      return SetError(ds, -1, msg);\n    }\n\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_true ( struct DecoderState *ds)\n{\n  char *offset = ds->start;\n  offset ++;\n\n  if (*(offset++) != 'r')\n    goto SETERROR;\n  if (*(offset++) != 'u')\n    goto SETERROR;\n  if (*(offset++) != 'e')\n    goto SETERROR;\n\n  ds->lastType = JT_TRUE;\n  ds->start = offset;\n  return ds->dec->newTrue(ds->prv);\n\nSETERROR:\n  return SetError(ds, -1, \"Unexpected character found when decoding 'true'\");\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_false ( struct DecoderState *ds)\n{\n  char *offset = ds->start;\n  offset ++;\n\n  if (*(offset++) != 'a')\n    goto SETERROR;\n  if (*(offset++) != 'l')\n    goto SETERROR;\n  if (*(offset++) != 's')\n    goto SETERROR;\n  if (*(offset++) != 'e')\n    goto SETERROR;\n\n  ds->lastType = JT_FALSE;\n  ds->start = offset;\n  return ds->dec->newFalse(ds->prv);\n\nSETERROR:\n  return SetError(ds, -1, \"Unexpected character found when decoding 'false'\");\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_null ( struct DecoderState *ds)\n{\n  char *offset = ds->start;\n  offset ++;\n\n  if (*(offset++) != 'u')\n    goto SETERROR;\n  if (*(offset++) != 'l')\n    goto SETERROR;\n  if (*(offset++) != 'l')\n    goto SETERROR;\n\n  ds->lastType = JT_NULL;\n  ds->start = offset;\n  return ds->dec->newNull(ds->prv);\n\nSETERROR:\n  return SetError(ds, -1, \"Unexpected character found when decoding 'null'\");\n}\n\nstatic FASTCALL_ATTR void FASTCALL_MSVC SkipWhitespace(struct DecoderState *ds)\n{\n  char *offset = ds->start;\n\n  for (;;)\n  {\n    switch (*offset)\n    {\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        offset ++;\n        break;\n\n      default:\n        ds->start = offset;\n        return;\n    }\n  }\n}\n\nenum DECODESTRINGSTATE\n{\n  DS_ISNULL = 0x32,\n  DS_ISQUOTE,\n  DS_ISESCAPE,\n  DS_UTFLENERROR,\n\n};\n\nstatic const JSUINT8 g_decoderLookup[256] =\n{\n  /* 0x00 */ DS_ISNULL, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x10 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x20 */ 1, 1, DS_ISQUOTE, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x30 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x40 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x50 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, DS_ISESCAPE, 1, 1, 1,\n  /* 0x60 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x70 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x80 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x90 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0xa0 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0xb0 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0xc0 */ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  /* 0xd0 */ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  /* 0xe0 */ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  /* 0xf0 */ 4, 4, 4, 4, 4, 4, 4, 4, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR,\n};\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_string ( struct DecoderState *ds)\n{\n  int index;\n  JSUINT32 *escOffset;\n  JSUINT32 *escStart;\n  size_t escLen = (ds->escEnd - ds->escStart);\n  JSUINT8 *inputOffset;\n  JSUTF16 ch = 0;\n  JSUINT8 *lastHighSurrogate = NULL;\n  JSUINT8 oct;\n  JSUTF32 ucs;\n  ds->lastType = JT_INVALID;\n  ds->start ++;\n\n  if ( (size_t) (ds->end - ds->start) > escLen)\n  {\n    size_t newSize = (ds->end - ds->start);\n\n    if (ds->escHeap)\n    {\n      if (newSize > (SIZE_MAX / sizeof(JSUINT32)))\n      {\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      escStart = (JSUINT32 *)ds->dec->realloc(ds->escStart, newSize * sizeof(JSUINT32));\n      if (!escStart)\n      {\n        ds->dec->free(ds->escStart);\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      ds->escStart = escStart;\n    }\n    else\n    {\n      JSUINT32 *oldStart = ds->escStart;\n      if (newSize > (SIZE_MAX / sizeof(JSUINT32)))\n      {\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      ds->escStart = (JSUINT32 *) ds->dec->malloc(newSize * sizeof(JSUINT32));\n      if (!ds->escStart)\n      {\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      ds->escHeap = 1;\n      memcpy(ds->escStart, oldStart, escLen * sizeof(JSUINT32));\n    }\n\n    ds->escEnd = ds->escStart + newSize;\n  }\n\n  escOffset = ds->escStart;\n  inputOffset = (JSUINT8 *) ds->start;\n\n  for (;;)\n  {\n    switch (g_decoderLookup[(JSUINT8)(*inputOffset)])\n    {\n      case DS_ISNULL:\n      {\n        return SetError(ds, -1, \"Unmatched '\\\"' when decoding 'string'\");\n      }\n      case DS_ISQUOTE:\n      {\n        ds->lastType = JT_UTF8;\n        inputOffset ++;\n        ds->start += ( (char *) inputOffset - (ds->start));\n        return ds->dec->newString(ds->prv, ds->escStart, escOffset);\n      }\n      case DS_UTFLENERROR:\n      {\n        return SetError (ds, -1, \"Invalid UTF-8 sequence length when decoding 'string'\");\n      }\n      case DS_ISESCAPE:\n      {\n        inputOffset ++;\n        switch (*inputOffset)\n        {\n          case '\\\\': *(escOffset++) = '\\\\'; inputOffset++; continue;\n          case '\\\"': *(escOffset++) = '\\\"'; inputOffset++; continue;\n          case '/':  *(escOffset++) = '/';  inputOffset++; continue;\n          case 'b':  *(escOffset++) = '\\b'; inputOffset++; continue;\n          case 'f':  *(escOffset++) = '\\f'; inputOffset++; continue;\n          case 'n':  *(escOffset++) = '\\n'; inputOffset++; continue;\n          case 'r':  *(escOffset++) = '\\r'; inputOffset++; continue;\n          case 't':  *(escOffset++) = '\\t'; inputOffset++; continue;\n\n          case 'u':\n          {\n            int index;\n            inputOffset ++;\n\n            for (index = 0; index < 4; index ++)\n            {\n              switch (*inputOffset)\n              {\n                case '\\0': return SetError (ds, -1, \"Unterminated unicode escape sequence when decoding 'string'\");\n                default: return SetError (ds, -1, \"Unexpected character in unicode escape sequence when decoding 'string'\");\n\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9':\n                  ch = (ch << 4) + (JSUTF16) (*inputOffset - '0');\n                  break;\n\n                case 'a':\n                case 'b':\n                case 'c':\n                case 'd':\n                case 'e':\n                case 'f':\n                  ch = (ch << 4) + 10 + (JSUTF16) (*inputOffset - 'a');\n                  break;\n\n                case 'A':\n                case 'B':\n                case 'C':\n                case 'D':\n                case 'E':\n                case 'F':\n                  ch = (ch << 4) + 10 + (JSUTF16) (*inputOffset - 'A');\n                  break;\n              }\n\n              inputOffset ++;\n            }\n\n            if ((ch & 0xfc00) == 0xdc00 && lastHighSurrogate == inputOffset - 6 * sizeof(*inputOffset))\n            {\n              // Low surrogate immediately following a high surrogate\n              // Overwrite existing high surrogate with combined character\n              *(escOffset-1) = (((*(escOffset-1) - 0xd800) <<10) | (ch - 0xdc00)) + 0x10000;\n            }\n            else\n            {\n              *(escOffset++) = (JSUINT32) ch;\n            }\n            if ((ch & 0xfc00) == 0xd800)\n            {\n              lastHighSurrogate = inputOffset;\n            }\n            break;\n          }\n\n          case '\\0': return SetError(ds, -1, \"Unterminated escape sequence when decoding 'string'\");\n          default: return SetError(ds, -1, \"Unrecognized escape sequence when decoding 'string'\");\n        }\n        break;\n      }\n\n      case 1:\n      {\n        *(escOffset++) = (JSUINT32) (*inputOffset++);\n        break;\n      }\n\n      case 2:\n      {\n        ucs = (*inputOffset++) & 0x1f;\n        ucs <<= 6;\n        if (((*inputOffset) & 0x80) != 0x80)\n        {\n          return SetError(ds, -1, \"Invalid octet in UTF-8 sequence when decoding 'string'\");\n        }\n        ucs |= (*inputOffset++) & 0x3f;\n        if (ucs < 0x80) return SetError (ds, -1, \"Overlong 2 byte UTF-8 sequence detected when decoding 'string'\");\n        *(escOffset++) = (JSUINT32) ucs;\n        break;\n      }\n\n      case 3:\n      {\n        JSUTF32 ucs = 0;\n        ucs |= (*inputOffset++) & 0x0f;\n\n        for (index = 0; index < 2; index ++)\n        {\n          ucs <<= 6;\n          oct = (*inputOffset++);\n\n          if ((oct & 0x80) != 0x80)\n          {\n            return SetError(ds, -1, \"Invalid octet in UTF-8 sequence when decoding 'string'\");\n          }\n\n          ucs |= oct & 0x3f;\n        }\n\n        if (ucs < 0x800) return SetError (ds, -1, \"Overlong 3 byte UTF-8 sequence detected when encoding string\");\n        *(escOffset++) = (JSUINT32) ucs;\n        break;\n      }\n\n      case 4:\n      {\n        JSUTF32 ucs = 0;\n        ucs |= (*inputOffset++) & 0x07;\n\n        for (index = 0; index < 3; index ++)\n        {\n          ucs <<= 6;\n          oct = (*inputOffset++);\n\n          if ((oct & 0x80) != 0x80)\n          {\n            return SetError(ds, -1, \"Invalid octet in UTF-8 sequence when decoding 'string'\");\n          }\n\n          ucs |= oct & 0x3f;\n        }\n\n        if (ucs < 0x10000) return SetError (ds, -1, \"Overlong 4 byte UTF-8 sequence detected when decoding 'string'\");\n\n        *(escOffset++) = (JSUINT32) ucs;\n        break;\n      }\n    }\n  }\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_array(struct DecoderState *ds)\n{\n  JSOBJ itemValue;\n  JSOBJ newObj;\n  int len;\n  ds->objDepth++;\n  if (ds->objDepth > JSON_MAX_OBJECT_DEPTH) {\n    return SetError(ds, -1, \"Reached object decoding depth limit\");\n  }\n\n  newObj = ds->dec->newArray(ds->prv);\n  len = 0;\n\n  ds->lastType = JT_INVALID;\n  ds->start ++;\n\n  for (;;)\n  {\n    SkipWhitespace(ds);\n\n    if ((*ds->start) == ']')\n    {\n      ds->objDepth--;\n      if (len == 0)\n      {\n        ds->start ++;\n        return newObj;\n      }\n\n      ds->dec->releaseObject(ds->prv, newObj);\n      return SetError(ds, -1, \"Unexpected character found when decoding array value (1)\");\n    }\n\n    itemValue = decode_any(ds);\n\n    if (itemValue == NULL)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      return NULL;\n    }\n\n    ds->dec->arrayAddItem (ds->prv, newObj, itemValue);\n\n    SkipWhitespace(ds);\n\n    switch (*(ds->start++))\n    {\n    case ']':\n    {\n      ds->objDepth--;\n      return newObj;\n    }\n    case ',':\n      break;\n\n    default:\n      ds->dec->releaseObject(ds->prv, newObj);\n      return SetError(ds, -1, \"Unexpected character found when decoding array value (2)\");\n    }\n\n    len++;\n  }\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_object( struct DecoderState *ds)\n{\n  JSOBJ itemName;\n  JSOBJ itemValue;\n  JSOBJ newObj;\n  int len;\n\n  ds->objDepth++;\n  if (ds->objDepth > JSON_MAX_OBJECT_DEPTH)\n  {\n    return SetError(ds, -1, \"Reached object decoding depth limit\");\n  }\n\n  newObj = ds->dec->newObject(ds->prv);\n  len = 0;\n\n  ds->start ++;\n\n  for (;;)\n  {\n    SkipWhitespace(ds);\n\n    if ((*ds->start) == '}')\n    {\n      ds->objDepth--;\n      if (len == 0)\n      {\n        ds->start ++;\n        return newObj;\n      }\n\n      ds->dec->releaseObject(ds->prv, newObj);\n      return SetError(ds, -1, \"Unexpected character in found when decoding object value\");\n    }\n\n    ds->lastType = JT_INVALID;\n    itemName = decode_any(ds);\n\n    if (itemName == NULL)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      return NULL;\n    }\n\n    if (ds->lastType != JT_UTF8)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      ds->dec->releaseObject(ds->prv, itemName);\n      return SetError(ds, -1, \"Key name of object must be 'string' when decoding 'object'\");\n    }\n\n    SkipWhitespace(ds);\n\n    if (*(ds->start++) != ':')\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      ds->dec->releaseObject(ds->prv, itemName);\n      return SetError(ds, -1, \"No ':' found when decoding object value\");\n    }\n\n    SkipWhitespace(ds);\n\n    itemValue = decode_any(ds);\n\n    if (itemValue == NULL)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      ds->dec->releaseObject(ds->prv, itemName);\n      return NULL;\n    }\n\n    ds->dec->objectAddKey (ds->prv, newObj, itemName, itemValue);\n\n    SkipWhitespace(ds);\n\n    switch (*(ds->start++))\n    {\n      case '}':\n      {\n        ds->objDepth--;\n        return newObj;\n      }\n      case ',':\n        break;\n\n      default:\n        ds->dec->releaseObject(ds->prv, newObj);\n        return SetError(ds, -1, \"Unexpected character in found when decoding object value\");\n    }\n\n    len++;\n  }\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_any(struct DecoderState *ds)\n{\n  for (;;)\n  {\n    switch (*ds->start)\n    {\n      case '\\\"':\n        return decode_string (ds);\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case 'I':\n      case 'N':\n      case '-':\n        return decode_numeric (ds);\n\n      case '[': return decode_array (ds);\n      case '{': return decode_object (ds);\n      case 't': return decode_true (ds);\n      case 'f': return decode_false (ds);\n      case 'n': return decode_null (ds);\n\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        // White space\n        ds->start ++;\n        break;\n\n      default:\n        return SetError(ds, -1, \"Expected object or value\");\n    }\n  }\n}\n\nJSOBJ JSON_DecodeObject(JSONObjectDecoder *dec, const char *buffer, size_t cbBuffer)\n{\n  /*\n  FIXME: Base the size of escBuffer of that of cbBuffer so that the unicode escaping doesn't run into the wall each time */\n  struct DecoderState ds;\n  JSUINT32 escBuffer[(JSON_MAX_STACK_BUFFER_SIZE / sizeof(JSUINT32))];\n  JSOBJ ret;\n\n  ds.start = (char *) buffer;\n  ds.end = ds.start + cbBuffer;\n\n  ds.escStart = escBuffer;\n  ds.escEnd = ds.escStart + (JSON_MAX_STACK_BUFFER_SIZE / sizeof(JSUINT32));\n  ds.escHeap = 0;\n  ds.prv = dec->prv;\n  ds.dec = dec;\n  ds.dec->errorStr = NULL;\n  ds.dec->errorOffset = NULL;\n  ds.objDepth = 0;\n\n  ds.dec = dec;\n\n  ret = decode_any (&ds);\n\n  if (ds.escHeap)\n  {\n    dec->free(ds.escStart);\n  }\n\n  if (!(dec->errorStr))\n  {\n    if ((ds.end - ds.start) > 0)\n    {\n      SkipWhitespace(&ds);\n    }\n\n    if (ds.start != ds.end && ret)\n    {\n      dec->releaseObject(ds.prv, ret);\n      return SetError(&ds, -1, \"Trailing data\");\n    }\n  }\n\n  return ret;\n}\n"], "fixing_code": ["/*\nDeveloped by ESN, an Electronic Arts Inc. studio.\nCopyright (c) 2014, Electronic Arts Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n* Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n* Neither the name of ESN, Electronic Arts Inc. nor the\nnames of its contributors may be used to endorse or promote products\nderived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL ELECTRONIC ARTS INC. BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nPortions of code from MODP_ASCII - Ascii transformations (upper/lower, etc)\nhttps://github.com/client9/stringencoders\nCopyright (c) 2007  Nick Galbreath -- nickg [at] modp [dot] com. All rights reserved.\n\nNumeric decoder derived from from TCL library\nhttps://opensource.apple.com/source/tcl/tcl-14/tcl/license.terms\n* Copyright (c) 1988-1993 The Regents of the University of California.\n* Copyright (c) 1994 Sun Microsystems, Inc.\n*/\n\n#include \"ultrajson.h\"\n#include <math.h>\n#include <assert.h>\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n\n#ifndef TRUE\n#define TRUE 1\n#define FALSE 0\n#endif\n#ifndef NULL\n#define NULL 0\n#endif\n\nstruct DecoderState\n{\n  char *start;\n  char *end;\n  JSUINT32 *escStart;\n  JSUINT32 *escEnd;\n  int escHeap;\n  int lastType;\n  JSUINT32 objDepth;\n  void *prv;\n  JSONObjectDecoder *dec;\n};\n\nstatic JSOBJ FASTCALL_MSVC decode_any( struct DecoderState *ds) FASTCALL_ATTR;\ntypedef JSOBJ (*PFN_DECODER)( struct DecoderState *ds);\n\nstatic JSOBJ SetError( struct DecoderState *ds, int offset, const char *message)\n{\n  ds->dec->errorOffset = ds->start + offset;\n  ds->dec->errorStr = (char *) message;\n  return NULL;\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decodeDouble(struct DecoderState *ds)\n{\n  int processed_characters_count;\n  int len = (int)(ds->end - ds->start);\n  double value = dconv_s2d(ds->dec->s2d, ds->start, len, &processed_characters_count);\n  ds->lastType = JT_DOUBLE;\n  ds->start += processed_characters_count;\n  return ds->dec->newDouble(ds->prv, value);\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_numeric (struct DecoderState *ds)\n{\n  int intNeg = 1;\n  int hasError = 0;\n  JSUINT64 intValue;\n  JSUINT64 addIntValue;\n  int chr;\n  char *offset = ds->start;\n\n  JSUINT64 maxIntValue = ULLONG_MAX;\n  JSUINT64 overflowLimit = maxIntValue / 10LLU;\n\n  if (*(offset) == 'I')\n  {\n    goto DECODE_INF;\n  }\n  else if (*(offset) == 'N')\n  {\n    goto DECODE_NAN;\n  }\n  else if (*(offset) == '-')\n  {\n    offset++;\n    intNeg = -1;\n    if (*(offset) == 'I')\n    {\n      goto DECODE_INF;\n    }\n    maxIntValue = -(JSUINT64) LLONG_MIN;\n    overflowLimit = maxIntValue / 10LL;\n  }\n\n  // Scan integer part\n  intValue = 0;\n\n  while (1)\n  {\n    chr = (int) (unsigned char) *(offset);\n\n    switch (chr)\n    {\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      {\n        // check whether multiplication would be out of bounds\n        if (intValue > overflowLimit)\n        {\n          hasError = 1;\n        }\n        intValue *= 10ULL;\n        addIntValue = (JSUINT64) (chr - 48);\n\n        // check whether addition would be out of bounds\n        if (maxIntValue - intValue < addIntValue)\n        {\n          hasError = 1;\n        }\n\n        intValue += addIntValue;\n        offset ++;\n        break;\n      }\n      case '.':\n      {\n        offset ++;\n        return decodeDouble(ds);\n      }\n      case 'e':\n      case 'E':\n      {\n        offset ++;\n        return decodeDouble(ds);\n      }\n\n      default:\n      {\n        if (hasError)\n        {\n          char *strStart = ds->start;\n          ds->lastType = JT_INT;\n          ds->start = offset;\n          return ds->dec->newIntegerFromString(ds->prv, strStart, offset - strStart);\n        }\n        goto BREAK_INT_LOOP;\n        break;\n      }\n    }\n  }\n\nBREAK_INT_LOOP:\n\n  ds->lastType = JT_INT;\n  ds->start = offset;\n\n  if (intNeg == 1 && (intValue & 0x8000000000000000ULL) != 0)\n  {\n    return ds->dec->newUnsignedLong(ds->prv, intValue);\n  }\n  else if ((intValue >> 31))\n  {\n    return ds->dec->newLong(ds->prv, (JSINT64) (intValue * (JSINT64) intNeg));\n  }\n  else\n  {\n    return ds->dec->newInt(ds->prv, (JSINT32) (intValue * intNeg));\n  }\n\nDECODE_NAN:\n    offset++;\n    if (*(offset++) != 'a') goto SET_NAN_ERROR;\n    if (*(offset++) != 'N') goto SET_NAN_ERROR;\n\n    ds->lastType = JT_NAN;\n    ds->start = offset;\n    return ds->dec->newNaN(ds->prv);\n\nSET_NAN_ERROR:\n    return SetError(ds, -1, \"Unexpected character found when decoding 'NaN'\");\n\nDECODE_INF:\n    offset++;\n    if (*(offset++) != 'n') goto SET_INF_ERROR;\n    if (*(offset++) != 'f') goto SET_INF_ERROR;\n    if (*(offset++) != 'i') goto SET_INF_ERROR;\n    if (*(offset++) != 'n') goto SET_INF_ERROR;\n    if (*(offset++) != 'i') goto SET_INF_ERROR;\n    if (*(offset++) != 't') goto SET_INF_ERROR;\n    if (*(offset++) != 'y') goto SET_INF_ERROR;\n\n    ds->start = offset;\n\n    if (intNeg == 1) {\n      ds->lastType = JT_POS_INF;\n      return ds->dec->newPosInf(ds->prv);\n    } else {\n      ds->lastType = JT_NEG_INF;\n      return ds->dec->newNegInf(ds->prv);\n    }\n\nSET_INF_ERROR:\n    if (intNeg == 1) {\n      const char *msg = \"Unexpected character found when decoding 'Infinity'\";\n      return SetError(ds, -1, msg);\n    } else {\n      const char *msg = \"Unexpected character found when decoding '-Infinity'\";\n      return SetError(ds, -1, msg);\n    }\n\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_true ( struct DecoderState *ds)\n{\n  char *offset = ds->start;\n  offset ++;\n\n  if (*(offset++) != 'r')\n    goto SETERROR;\n  if (*(offset++) != 'u')\n    goto SETERROR;\n  if (*(offset++) != 'e')\n    goto SETERROR;\n\n  ds->lastType = JT_TRUE;\n  ds->start = offset;\n  return ds->dec->newTrue(ds->prv);\n\nSETERROR:\n  return SetError(ds, -1, \"Unexpected character found when decoding 'true'\");\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_false ( struct DecoderState *ds)\n{\n  char *offset = ds->start;\n  offset ++;\n\n  if (*(offset++) != 'a')\n    goto SETERROR;\n  if (*(offset++) != 'l')\n    goto SETERROR;\n  if (*(offset++) != 's')\n    goto SETERROR;\n  if (*(offset++) != 'e')\n    goto SETERROR;\n\n  ds->lastType = JT_FALSE;\n  ds->start = offset;\n  return ds->dec->newFalse(ds->prv);\n\nSETERROR:\n  return SetError(ds, -1, \"Unexpected character found when decoding 'false'\");\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_null ( struct DecoderState *ds)\n{\n  char *offset = ds->start;\n  offset ++;\n\n  if (*(offset++) != 'u')\n    goto SETERROR;\n  if (*(offset++) != 'l')\n    goto SETERROR;\n  if (*(offset++) != 'l')\n    goto SETERROR;\n\n  ds->lastType = JT_NULL;\n  ds->start = offset;\n  return ds->dec->newNull(ds->prv);\n\nSETERROR:\n  return SetError(ds, -1, \"Unexpected character found when decoding 'null'\");\n}\n\nstatic FASTCALL_ATTR void FASTCALL_MSVC SkipWhitespace(struct DecoderState *ds)\n{\n  char *offset = ds->start;\n\n  for (;;)\n  {\n    switch (*offset)\n    {\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        offset ++;\n        break;\n\n      default:\n        ds->start = offset;\n        return;\n    }\n  }\n}\n\nenum DECODESTRINGSTATE\n{\n  DS_ISNULL = 0x32,\n  DS_ISQUOTE,\n  DS_ISESCAPE,\n  DS_UTFLENERROR,\n\n};\n\nstatic const JSUINT8 g_decoderLookup[256] =\n{\n  /* 0x00 */ DS_ISNULL, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x10 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x20 */ 1, 1, DS_ISQUOTE, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x30 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x40 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x50 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, DS_ISESCAPE, 1, 1, 1,\n  /* 0x60 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x70 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x80 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x90 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0xa0 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0xb0 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0xc0 */ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  /* 0xd0 */ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  /* 0xe0 */ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  /* 0xf0 */ 4, 4, 4, 4, 4, 4, 4, 4, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR,\n};\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_string ( struct DecoderState *ds)\n{\n  int index;\n  JSUINT32 *escOffset;\n  JSUINT32 *escStart;\n  size_t escLen = (ds->escEnd - ds->escStart);\n  JSUINT8 *inputOffset;\n  JSUTF16 ch = 0;\n  JSUINT8 *lastHighSurrogate = NULL;\n  JSUINT8 oct;\n  JSUTF32 ucs;\n  ds->lastType = JT_INVALID;\n  ds->start ++;\n\n  if ( (size_t) (ds->end - ds->start) > escLen)\n  {\n    size_t newSize = (ds->end - ds->start);\n\n    if (ds->escHeap)\n    {\n      if (newSize > (SIZE_MAX / sizeof(JSUINT32)))\n      {\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      escStart = (JSUINT32 *)ds->dec->realloc(ds->escStart, newSize * sizeof(JSUINT32));\n      if (!escStart)\n      {\n        // Don't free ds->escStart here; it gets handled in JSON_DecodeObject.\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      ds->escStart = escStart;\n    }\n    else\n    {\n      JSUINT32 *oldStart = ds->escStart;\n      if (newSize > (SIZE_MAX / sizeof(JSUINT32)))\n      {\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      ds->escStart = (JSUINT32 *) ds->dec->malloc(newSize * sizeof(JSUINT32));\n      if (!ds->escStart)\n      {\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      ds->escHeap = 1;\n      memcpy(ds->escStart, oldStart, escLen * sizeof(JSUINT32));\n    }\n\n    ds->escEnd = ds->escStart + newSize;\n  }\n\n  escOffset = ds->escStart;\n  inputOffset = (JSUINT8 *) ds->start;\n\n  for (;;)\n  {\n    switch (g_decoderLookup[(JSUINT8)(*inputOffset)])\n    {\n      case DS_ISNULL:\n      {\n        return SetError(ds, -1, \"Unmatched '\\\"' when decoding 'string'\");\n      }\n      case DS_ISQUOTE:\n      {\n        ds->lastType = JT_UTF8;\n        inputOffset ++;\n        ds->start += ( (char *) inputOffset - (ds->start));\n        return ds->dec->newString(ds->prv, ds->escStart, escOffset);\n      }\n      case DS_UTFLENERROR:\n      {\n        return SetError (ds, -1, \"Invalid UTF-8 sequence length when decoding 'string'\");\n      }\n      case DS_ISESCAPE:\n      {\n        inputOffset ++;\n        switch (*inputOffset)\n        {\n          case '\\\\': *(escOffset++) = '\\\\'; inputOffset++; continue;\n          case '\\\"': *(escOffset++) = '\\\"'; inputOffset++; continue;\n          case '/':  *(escOffset++) = '/';  inputOffset++; continue;\n          case 'b':  *(escOffset++) = '\\b'; inputOffset++; continue;\n          case 'f':  *(escOffset++) = '\\f'; inputOffset++; continue;\n          case 'n':  *(escOffset++) = '\\n'; inputOffset++; continue;\n          case 'r':  *(escOffset++) = '\\r'; inputOffset++; continue;\n          case 't':  *(escOffset++) = '\\t'; inputOffset++; continue;\n\n          case 'u':\n          {\n            int index;\n            inputOffset ++;\n\n            for (index = 0; index < 4; index ++)\n            {\n              switch (*inputOffset)\n              {\n                case '\\0': return SetError (ds, -1, \"Unterminated unicode escape sequence when decoding 'string'\");\n                default: return SetError (ds, -1, \"Unexpected character in unicode escape sequence when decoding 'string'\");\n\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9':\n                  ch = (ch << 4) + (JSUTF16) (*inputOffset - '0');\n                  break;\n\n                case 'a':\n                case 'b':\n                case 'c':\n                case 'd':\n                case 'e':\n                case 'f':\n                  ch = (ch << 4) + 10 + (JSUTF16) (*inputOffset - 'a');\n                  break;\n\n                case 'A':\n                case 'B':\n                case 'C':\n                case 'D':\n                case 'E':\n                case 'F':\n                  ch = (ch << 4) + 10 + (JSUTF16) (*inputOffset - 'A');\n                  break;\n              }\n\n              inputOffset ++;\n            }\n\n            if ((ch & 0xfc00) == 0xdc00 && lastHighSurrogate == inputOffset - 6 * sizeof(*inputOffset))\n            {\n              // Low surrogate immediately following a high surrogate\n              // Overwrite existing high surrogate with combined character\n              *(escOffset-1) = (((*(escOffset-1) - 0xd800) <<10) | (ch - 0xdc00)) + 0x10000;\n            }\n            else\n            {\n              *(escOffset++) = (JSUINT32) ch;\n            }\n            if ((ch & 0xfc00) == 0xd800)\n            {\n              lastHighSurrogate = inputOffset;\n            }\n            break;\n          }\n\n          case '\\0': return SetError(ds, -1, \"Unterminated escape sequence when decoding 'string'\");\n          default: return SetError(ds, -1, \"Unrecognized escape sequence when decoding 'string'\");\n        }\n        break;\n      }\n\n      case 1:\n      {\n        *(escOffset++) = (JSUINT32) (*inputOffset++);\n        break;\n      }\n\n      case 2:\n      {\n        ucs = (*inputOffset++) & 0x1f;\n        ucs <<= 6;\n        if (((*inputOffset) & 0x80) != 0x80)\n        {\n          return SetError(ds, -1, \"Invalid octet in UTF-8 sequence when decoding 'string'\");\n        }\n        ucs |= (*inputOffset++) & 0x3f;\n        if (ucs < 0x80) return SetError (ds, -1, \"Overlong 2 byte UTF-8 sequence detected when decoding 'string'\");\n        *(escOffset++) = (JSUINT32) ucs;\n        break;\n      }\n\n      case 3:\n      {\n        JSUTF32 ucs = 0;\n        ucs |= (*inputOffset++) & 0x0f;\n\n        for (index = 0; index < 2; index ++)\n        {\n          ucs <<= 6;\n          oct = (*inputOffset++);\n\n          if ((oct & 0x80) != 0x80)\n          {\n            return SetError(ds, -1, \"Invalid octet in UTF-8 sequence when decoding 'string'\");\n          }\n\n          ucs |= oct & 0x3f;\n        }\n\n        if (ucs < 0x800) return SetError (ds, -1, \"Overlong 3 byte UTF-8 sequence detected when encoding string\");\n        *(escOffset++) = (JSUINT32) ucs;\n        break;\n      }\n\n      case 4:\n      {\n        JSUTF32 ucs = 0;\n        ucs |= (*inputOffset++) & 0x07;\n\n        for (index = 0; index < 3; index ++)\n        {\n          ucs <<= 6;\n          oct = (*inputOffset++);\n\n          if ((oct & 0x80) != 0x80)\n          {\n            return SetError(ds, -1, \"Invalid octet in UTF-8 sequence when decoding 'string'\");\n          }\n\n          ucs |= oct & 0x3f;\n        }\n\n        if (ucs < 0x10000) return SetError (ds, -1, \"Overlong 4 byte UTF-8 sequence detected when decoding 'string'\");\n\n        *(escOffset++) = (JSUINT32) ucs;\n        break;\n      }\n    }\n  }\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_array(struct DecoderState *ds)\n{\n  JSOBJ itemValue;\n  JSOBJ newObj;\n  int len;\n  ds->objDepth++;\n  if (ds->objDepth > JSON_MAX_OBJECT_DEPTH) {\n    return SetError(ds, -1, \"Reached object decoding depth limit\");\n  }\n\n  newObj = ds->dec->newArray(ds->prv);\n  len = 0;\n\n  ds->lastType = JT_INVALID;\n  ds->start ++;\n\n  for (;;)\n  {\n    SkipWhitespace(ds);\n\n    if ((*ds->start) == ']')\n    {\n      ds->objDepth--;\n      if (len == 0)\n      {\n        ds->start ++;\n        return newObj;\n      }\n\n      ds->dec->releaseObject(ds->prv, newObj);\n      return SetError(ds, -1, \"Unexpected character found when decoding array value (1)\");\n    }\n\n    itemValue = decode_any(ds);\n\n    if (itemValue == NULL)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      return NULL;\n    }\n\n    ds->dec->arrayAddItem (ds->prv, newObj, itemValue);\n\n    SkipWhitespace(ds);\n\n    switch (*(ds->start++))\n    {\n    case ']':\n    {\n      ds->objDepth--;\n      return newObj;\n    }\n    case ',':\n      break;\n\n    default:\n      ds->dec->releaseObject(ds->prv, newObj);\n      return SetError(ds, -1, \"Unexpected character found when decoding array value (2)\");\n    }\n\n    len++;\n  }\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_object( struct DecoderState *ds)\n{\n  JSOBJ itemName;\n  JSOBJ itemValue;\n  JSOBJ newObj;\n  int len;\n\n  ds->objDepth++;\n  if (ds->objDepth > JSON_MAX_OBJECT_DEPTH)\n  {\n    return SetError(ds, -1, \"Reached object decoding depth limit\");\n  }\n\n  newObj = ds->dec->newObject(ds->prv);\n  len = 0;\n\n  ds->start ++;\n\n  for (;;)\n  {\n    SkipWhitespace(ds);\n\n    if ((*ds->start) == '}')\n    {\n      ds->objDepth--;\n      if (len == 0)\n      {\n        ds->start ++;\n        return newObj;\n      }\n\n      ds->dec->releaseObject(ds->prv, newObj);\n      return SetError(ds, -1, \"Unexpected character in found when decoding object value\");\n    }\n\n    ds->lastType = JT_INVALID;\n    itemName = decode_any(ds);\n\n    if (itemName == NULL)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      return NULL;\n    }\n\n    if (ds->lastType != JT_UTF8)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      ds->dec->releaseObject(ds->prv, itemName);\n      return SetError(ds, -1, \"Key name of object must be 'string' when decoding 'object'\");\n    }\n\n    SkipWhitespace(ds);\n\n    if (*(ds->start++) != ':')\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      ds->dec->releaseObject(ds->prv, itemName);\n      return SetError(ds, -1, \"No ':' found when decoding object value\");\n    }\n\n    SkipWhitespace(ds);\n\n    itemValue = decode_any(ds);\n\n    if (itemValue == NULL)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      ds->dec->releaseObject(ds->prv, itemName);\n      return NULL;\n    }\n\n    ds->dec->objectAddKey (ds->prv, newObj, itemName, itemValue);\n\n    SkipWhitespace(ds);\n\n    switch (*(ds->start++))\n    {\n      case '}':\n      {\n        ds->objDepth--;\n        return newObj;\n      }\n      case ',':\n        break;\n\n      default:\n        ds->dec->releaseObject(ds->prv, newObj);\n        return SetError(ds, -1, \"Unexpected character in found when decoding object value\");\n    }\n\n    len++;\n  }\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_any(struct DecoderState *ds)\n{\n  for (;;)\n  {\n    switch (*ds->start)\n    {\n      case '\\\"':\n        return decode_string (ds);\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case 'I':\n      case 'N':\n      case '-':\n        return decode_numeric (ds);\n\n      case '[': return decode_array (ds);\n      case '{': return decode_object (ds);\n      case 't': return decode_true (ds);\n      case 'f': return decode_false (ds);\n      case 'n': return decode_null (ds);\n\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        // White space\n        ds->start ++;\n        break;\n\n      default:\n        return SetError(ds, -1, \"Expected object or value\");\n    }\n  }\n}\n\nJSOBJ JSON_DecodeObject(JSONObjectDecoder *dec, const char *buffer, size_t cbBuffer)\n{\n  /*\n  FIXME: Base the size of escBuffer of that of cbBuffer so that the unicode escaping doesn't run into the wall each time */\n  struct DecoderState ds;\n  JSUINT32 escBuffer[(JSON_MAX_STACK_BUFFER_SIZE / sizeof(JSUINT32))];\n  JSOBJ ret;\n\n  ds.start = (char *) buffer;\n  ds.end = ds.start + cbBuffer;\n\n  ds.escStart = escBuffer;\n  ds.escEnd = ds.escStart + (JSON_MAX_STACK_BUFFER_SIZE / sizeof(JSUINT32));\n  ds.escHeap = 0;\n  ds.prv = dec->prv;\n  ds.dec = dec;\n  ds.dec->errorStr = NULL;\n  ds.dec->errorOffset = NULL;\n  ds.objDepth = 0;\n\n  ds.dec = dec;\n\n  ret = decode_any (&ds);\n\n  if (ds.escHeap)\n  {\n    dec->free(ds.escStart);\n  }\n\n  if (!(dec->errorStr))\n  {\n    if ((ds.end - ds.start) > 0)\n    {\n      SkipWhitespace(&ds);\n    }\n\n    if (ds.start != ds.end && ret)\n    {\n      dec->releaseObject(ds.prv, ret);\n      return SetError(&ds, -1, \"Trailing data\");\n    }\n  }\n\n  return ret;\n}\n"], "filenames": ["lib/ultrajsondec.c"], "buggy_code_start_loc": [387], "buggy_code_end_loc": [388], "fixing_code_start_loc": [387], "fixing_code_end_loc": [388], "type": "CWE-415", "message": "UltraJSON is a fast JSON encoder and decoder written in pure C with bindings for Python 3.7+. In versions prior to 5.4.0 an error occurring while reallocating a buffer for string decoding can cause the buffer to get freed twice. Due to how UltraJSON uses the internal decoder, this double free is impossible to trigger from Python. This issue has been resolved in version 5.4.0 and all users should upgrade to UltraJSON 5.4.0. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-31117", "sourceIdentifier": "security-advisories@github.com", "published": "2022-07-05T18:15:08.087", "lastModified": "2022-11-05T02:47:26.830", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "UltraJSON is a fast JSON encoder and decoder written in pure C with bindings for Python 3.7+. In versions prior to 5.4.0 an error occurring while reallocating a buffer for string decoding can cause the buffer to get freed twice. Due to how UltraJSON uses the internal decoder, this double free is impossible to trigger from Python. This issue has been resolved in version 5.4.0 and all users should upgrade to UltraJSON 5.4.0. There are no known workarounds for this issue."}, {"lang": "es", "value": "UltraJSON es un codificador y decodificador JSON r\u00e1pido escrito en C puro con enlaces para Python versiones 3.7+.&#xa0;En versiones anteriores a la 5.4.0, un error al reasignar un b\u00fafer para la decodificaci\u00f3n de cadenas puede hacer que el b\u00fafer se libere dos veces.&#xa0;Debido a c\u00f3mo UltraJSON usa el decodificador interno, esta doble liberaci\u00f3n es imposible de activar desde Python.&#xa0;Este problema ha sido resuelto en la versi\u00f3n 5.4.0 y todos los usuarios deben actualizar a UltraJSON 5.4.0.&#xa0;No se conocen mitigaciones adicionales para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ultrajson_project:ultrajson:*:*:*:*:*:python:*:*", "versionEndExcluding": "5.4.0", "matchCriteriaId": "85A0E25D-E50B-4669-A1F2-1BAAEC9DFE16"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/ultrajson/ultrajson/commit/9c20de0f77b391093967e25d01fb48671104b15b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ultrajson/ultrajson/security/advisories/GHSA-fm67-cv37-96ff", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NAU5N4A7EUK2AMUCOLYDD5ARXAJYZBD2/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OPPU5FZP3LCTXYORFH7NHUMYA5X66IA7/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ultrajson/ultrajson/commit/9c20de0f77b391093967e25d01fb48671104b15b"}}