{"buggy_code": ["//\n// beh (\"Backend Error Handler\") wrapper backend to extend the possibilities\n// of handling errors of backends.\n//\n// Copyright 2015 by Till Kamppeter\n//\n// This is based on dnssd.c of CUPS\n// dnssd.c copyright notice is as follows:\n//\n// Copyright 2008-2015 by Apple Inc.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers.\n//\n\n#include <config.h>\n#include <cups/cups.h>\n#include <cups/backend.h>\n#include <cups/array.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <signal.h>\n#include <string.h>\n#include <errno.h>\n\n\n//\n// Local globals...\n//\n\nstatic int\t\tjob_canceled = 0; // Set to 1 on SIGTERM\n\n\n//\n// Local functions...\n//\n\nstatic int\t\tcall_backend(char *uri, int argc, char **argv,\n\t\t\t\t     char *tempfile);\nstatic void\t\tsigterm_handler(int sig);\n\n\n//\n// 'main()' - Browse for printers.\n//\n\nint\t\t\t\t\t// O - Exit status\nmain(int  argc,\t\t\t\t// I - Number of command-line args\n     char *argv[])\t\t\t// I - Command-line arguments\n{\n  char *uri, *ptr, *filename;\n  char tmpfilename[1024], buf[8192];\n  int dd, att, delay, retval;\n#if defined(HAVE_SIGACTION) && !defined(HAVE_SIGSET)\n  struct sigaction action;\t\t// Actions for POSIX signals\n#endif // HAVE_SIGACTION && !HAVE_SIGSET\n\n  //\n  // Don't buffer stderr, and catch SIGTERM...\n  //\n\n  setbuf(stderr, NULL);\n\n#ifdef HAVE_SIGSET // Use System V signals over POSIX to avoid bugs\n  sigset(SIGTERM, sigterm_handler);\n#elif defined(HAVE_SIGACTION)\n  memset(&action, 0, sizeof(action));\n\n  sigemptyset(&action.sa_mask);\n  action.sa_handler = sigterm_handler;\n  sigaction(SIGTERM, &action, NULL);\n#else\n  signal(SIGTERM, sigterm_handler);\n#endif // HAVE_SIGSET\n\n  //\n  // Check command-line...\n  //\n\n  if (argc == 1)\n  {\n    if ((ptr = strrchr(argv[0], '/')) != NULL)\n      ptr ++;\n    else\n      ptr = argv[0];\n    printf(\"network %s \\\"Unknown\\\" \\\"Backend Error Handler\\\"\\n\",\n\t   ptr);\n    return (CUPS_BACKEND_OK);\n  }\n  else if (argc < 6)\n  {\n    fprintf(stderr,\n\t    \"Usage: %s job-id user title copies options [file]\\n\",\n\t    argv[0]);\n    return (CUPS_BACKEND_FAILED);\n  }\n\n  //\n  // Read out the parameters\n  //\n\n  uri = getenv(\"DEVICE_URI\");\n  if (!uri)\n  {\n    fprintf(stderr,\n\t    \"ERROR: No device URI supplied!\");\n    return (CUPS_BACKEND_FAILED);\n  }\n\n  ptr = strstr(uri, \":/\");\n  if (!ptr)\n    goto bad_uri;\n  ptr += 2;\n  if (*ptr == '0')\n    dd = 0;\n  else if (*ptr == '1')\n    dd = 1;\n  else\n    goto bad_uri;\n  ptr ++;\n  if (*ptr != '/')\n    goto bad_uri;\n  ptr ++;\n  att = 0;\n  while (isdigit(*ptr))\n  {\n    att = att * 10 + (int)(*ptr) - 48;\n    ptr ++;\n  }\n  if (*ptr != '/')\n    goto bad_uri;\n  ptr ++;\n  delay = 0;\n  while (isdigit(*ptr))\n  {\n    delay = delay * 10 + (int)(*ptr) - 48;\n    ptr ++;\n  }\n  if (*ptr != '/')\n    goto bad_uri;\n  ptr ++;\n  fprintf(stderr,\n\t  \"DEBUG: beh: Don't disable: %d; Attempts: %d; Delay: %d; Destination URI: %s\\n\",\n\t  dd, att, delay, ptr);\n\n  //\n  // If reading from stdin, write everything into a temporary file\n  //\n\n  if (argc == 6)\n  {\n    char *tmpdir;\n    int fd;\n    FILE *tmpfile;\n    size_t bytes;\n\n    tmpdir = getenv(\"TMPDIR\");\n    if (!tmpdir)\n      tmpdir = \"/tmp\";\n    snprintf(tmpfilename, sizeof(tmpfilename), \"%s/beh-XXXXXX\", tmpdir);\n    fd = mkstemp(tmpfilename);\n    if (fd < 0)\n    {\n      fprintf(stderr,\n\t      \"ERROR: beh: Could not create temporary file: %s\\n\",\n\t      strerror(errno));\n      return (CUPS_BACKEND_FAILED);\n    }\n    tmpfile = fdopen(fd, \"r+\");\n    while ((bytes = fread(buf, 1, sizeof(buf), stdin)))\n      fwrite(buf, 1, bytes, tmpfile);\n    fclose(tmpfile);\n\t\t    \n    filename = tmpfilename;\n  }\n  else\n  {\n    tmpfilename[0] = '\\0';\n    filename = argv[6];\n  }\n\n  //\n  // Do it!\n  //\n\n  while ((retval = call_backend(ptr, argc, argv, filename)) !=\n\t CUPS_BACKEND_OK &&\n\t !job_canceled)\n  {\n    if (att > 0)\n    {\n      att --;\n      if (att == 0)\n\tbreak;\n    }\n    if (delay > 0)\n      sleep (delay);\n  }\n\n  if (strlen(tmpfilename) > 0)\n    unlink(tmpfilename);\n\n  //\n  // Return the exit value of the backend only if requested\n  //\n\n  if (!dd)\n    return (retval);\n  else\n    return (CUPS_BACKEND_OK);\n\n  //\n  // Error handling\n  //\n\n bad_uri:\n\n  fprintf(stderr,\n\t  \"ERROR: URI must be \\\"beh:/<dd>/<att>/<delay>/<original uri>\\\"!\\n\");\n  return (CUPS_BACKEND_FAILED);\n}\n\n\n//\n// 'call_backend()' - Execute the command line of the destination backend\n//\n\nstatic int\ncall_backend(char *uri,                 // I - URI of final destination\n\t     int  argc,                 // I - Number of command line\n\t                                //     arguments\n\t     char **argv,\t\t// I - Command-line arguments\n\t     char *filename)            // I - File name of input data\n{\n  const char\t*cups_serverbin;\t// Location of programs\n  char\t\tscheme[1024],           // Scheme from URI\n                *ptr,\t\t\t// Pointer into scheme\n\t\tcmdline[65536];\t\t// Backend command line\n  int           retval;\n\n  //\n  // Build the backend command line...\n  //\n\n  strncpy(scheme, uri, sizeof(scheme) - 1);\n  if (strlen(uri) > 1023)\n    scheme[1023] = '\\0';\n  if ((ptr = strchr(scheme, ':')) != NULL)\n    *ptr = '\\0';\n\n  if ((cups_serverbin = getenv(\"CUPS_SERVERBIN\")) == NULL)\n    cups_serverbin = CUPS_SERVERBIN;\n\n  if (!strncasecmp(uri, \"file:\", 5) || uri[0] == '/')\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Direct output into a file not supported.\\n\");\n    exit (CUPS_BACKEND_FAILED);\n  }\n  else\n    snprintf(cmdline, sizeof(cmdline),\n\t     \"%s/backend/%s '%s' '%s' '%s' '%s' '%s' %s\",\n\t     cups_serverbin, scheme, argv[1], argv[2], argv[3],\n\t     // Apply number of copies only if beh was called with a\n\t     // file name and not with the print data in stdin, as\n\t     // backends should handle copies only if they are called\n\t     // with a file name\n\t     (argc == 6 ? \"1\" : argv[4]),\n\t     argv[5], filename);\n\n  //\n  // Overwrite the device URI and run the actual backend...\n  //\n\n  setenv(\"DEVICE_URI\", uri, 1);\n\n  fprintf(stderr,\n\t  \"DEBUG: beh: Executing backend command line \\\"%s\\\"...\\n\",\n\t  cmdline);\n  fprintf(stderr,\n\t  \"DEBUG: beh: Using device URI: %s\\n\",\n\t  uri);\n\n  retval = system(cmdline) >> 8;\n\n  if (retval == -1)\n    fprintf(stderr, \"ERROR: Unable to execute backend command line: %s\\n\",\n\t    strerror(errno));\n\n  return (retval);\n}\n\n\n//\n// 'sigterm_handler()' - Handle termination signals.\n//\n\nstatic void\nsigterm_handler(int sig)\t\t// I - Signal number (unused)\n{\n  (void)sig;\n\n  fprintf(stderr,\n\t  \"DEBUG: beh: Job canceled.\\n\");\n\n  if (job_canceled)\n    _exit(CUPS_BACKEND_OK);\n  else\n    job_canceled = 1;\n}\n"], "fixing_code": ["//\n// beh (\"Backend Error Handler\") wrapper backend to extend the possibilities\n// of handling errors of backends.\n//\n// Copyright 2015 by Till Kamppeter\n//\n// This is based on dnssd.c of CUPS\n// dnssd.c copyright notice is as follows:\n//\n// Copyright 2008-2015 by Apple Inc.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers.\n//\n\n#include <config.h>\n#include <cups/cups.h>\n#include <cups/backend.h>\n#include <cups/array.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <signal.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/wait.h>\n\n\n//\n// Local globals...\n//\n\nstatic volatile int\tjob_canceled = 0; // Set to 1 on SIGTERM\n\n\n//\n// Local functions...\n//\n\nstatic int\t\tcall_backend(char *uri, int argc, char **argv,\n\t\t\t\t     char *tempfile);\nstatic void\t\tsigterm_handler(int sig);\n\n\n//\n// 'main()' - Browse for printers.\n//\n\nint\t\t\t\t\t// O - Exit status\nmain(int  argc,\t\t\t\t// I - Number of command-line args\n     char *argv[])\t\t\t// I - Command-line arguments\n{\n  char *uri, *ptr, *filename;\n  char tmpfilename[1024], buf[8192];\n  int dd, att, delay, retval;\n#if defined(HAVE_SIGACTION) && !defined(HAVE_SIGSET)\n  struct sigaction action;\t\t// Actions for POSIX signals\n#endif // HAVE_SIGACTION && !HAVE_SIGSET\n\n  //\n  // Don't buffer stderr, and catch SIGTERM...\n  //\n\n  setbuf(stderr, NULL);\n\n#ifdef HAVE_SIGSET // Use System V signals over POSIX to avoid bugs\n  sigset(SIGTERM, sigterm_handler);\n#elif defined(HAVE_SIGACTION)\n  memset(&action, 0, sizeof(action));\n\n  sigemptyset(&action.sa_mask);\n  action.sa_handler = sigterm_handler;\n  sigaction(SIGTERM, &action, NULL);\n#else\n  signal(SIGTERM, sigterm_handler);\n#endif // HAVE_SIGSET\n\n  //\n  // Check command-line...\n  //\n\n  if (argc == 1)\n  {\n    if ((ptr = strrchr(argv[0], '/')) != NULL)\n      ptr ++;\n    else\n      ptr = argv[0];\n    printf(\"network %s \\\"Unknown\\\" \\\"Backend Error Handler\\\"\\n\",\n\t   ptr);\n    return (CUPS_BACKEND_OK);\n  }\n  else if (argc < 6)\n  {\n    fprintf(stderr,\n\t    \"Usage: %s job-id user title copies options [file]\\n\",\n\t    argv[0]);\n    return (CUPS_BACKEND_FAILED);\n  }\n\n  //\n  // Read out the parameters\n  //\n\n  uri = getenv(\"DEVICE_URI\");\n  if (!uri)\n  {\n    fprintf(stderr,\n\t    \"ERROR: No device URI supplied!\");\n    return (CUPS_BACKEND_FAILED);\n  }\n\n  ptr = strstr(uri, \":/\");\n  if (!ptr)\n    goto bad_uri;\n  ptr += 2;\n  if (*ptr == '0')\n    dd = 0;\n  else if (*ptr == '1')\n    dd = 1;\n  else\n    goto bad_uri;\n  ptr ++;\n  if (*ptr != '/')\n    goto bad_uri;\n  ptr ++;\n  att = 0;\n  while (isdigit(*ptr))\n  {\n    att = att * 10 + (int)(*ptr) - 48;\n    ptr ++;\n  }\n  if (*ptr != '/')\n    goto bad_uri;\n  ptr ++;\n  delay = 0;\n  while (isdigit(*ptr))\n  {\n    delay = delay * 10 + (int)(*ptr) - 48;\n    ptr ++;\n  }\n  if (*ptr != '/')\n    goto bad_uri;\n  ptr ++;\n  fprintf(stderr,\n\t  \"DEBUG: beh: Don't disable: %d; Attempts: %d; Delay: %d; Destination URI: %s\\n\",\n\t  dd, att, delay, ptr);\n\n  //\n  // If reading from stdin, write everything into a temporary file\n  //\n\n  if (argc == 6)\n  {\n    char *tmpdir;\n    int fd;\n    FILE *tmpfile;\n    size_t bytes;\n\n    tmpdir = getenv(\"TMPDIR\");\n    if (!tmpdir)\n      tmpdir = \"/tmp\";\n    snprintf(tmpfilename, sizeof(tmpfilename), \"%s/beh-XXXXXX\", tmpdir);\n    fd = mkstemp(tmpfilename);\n    if (fd < 0)\n    {\n      fprintf(stderr,\n\t      \"ERROR: beh: Could not create temporary file: %s\\n\",\n\t      strerror(errno));\n      return (CUPS_BACKEND_FAILED);\n    }\n    tmpfile = fdopen(fd, \"r+\");\n    while ((bytes = fread(buf, 1, sizeof(buf), stdin)))\n      fwrite(buf, 1, bytes, tmpfile);\n    fclose(tmpfile);\n\t\t    \n    filename = tmpfilename;\n  }\n  else\n  {\n    tmpfilename[0] = '\\0';\n    filename = argv[6];\n  }\n\n  //\n  // Do it!\n  //\n\n  while ((retval = call_backend(ptr, argc, argv, filename)) !=\n\t CUPS_BACKEND_OK &&\n\t !job_canceled)\n  {\n    if (att > 0)\n    {\n      att --;\n      if (att == 0)\n\tbreak;\n    }\n    if (delay > 0)\n      sleep (delay);\n  }\n\n  if (strlen(tmpfilename) > 0)\n    unlink(tmpfilename);\n\n  //\n  // Return the exit value of the backend only if requested\n  //\n\n  if (!dd)\n    return (retval);\n  else\n    return (CUPS_BACKEND_OK);\n\n  //\n  // Error handling\n  //\n\n bad_uri:\n\n  fprintf(stderr,\n\t  \"ERROR: URI must be \\\"beh:/<dd>/<att>/<delay>/<original uri>\\\"!\\n\");\n  return (CUPS_BACKEND_FAILED);\n}\n\n\n//\n// 'call_backend()' - Execute the command line of the destination backend\n//\n\nstatic int\ncall_backend(char *uri,                 // I - URI of final destination\n\t     int  argc,                 // I - Number of command line\n\t                                //     arguments\n\t     char **argv,\t\t// I - Command-line arguments\n\t     char *filename)            // I - File name of input data\n{\n  const char\t*cups_serverbin;\t// Location of programs\n  char          *backend_argv[8];       // Arguments for called CUPS backend\n  char\t\tscheme[1024],           // Scheme from URI\n                *ptr,\t\t\t// Pointer into scheme\n\t\tbackend_path[2048];\t// Backend path\n  int           pid,\n                wait_pid,\n                wait_status,\n                retval = 0;\n  int           bytes;\n\n\n  //\n  // Build the backend command line...\n  //\n\n  scheme[0] = '\\0';\n  strncat(scheme, uri, sizeof(scheme) - 1);\n  if ((ptr = strchr(scheme, ':')) != NULL)\n    *ptr = '\\0';\n  else\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Invalid URI, no colon (':') to mark end of scheme part.\\n\");\n    exit (CUPS_BACKEND_FAILED);\n  }\n  if (strchr(scheme, '/'))\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Invalid URI, scheme contains a slash ('/').\\n\");\n    exit (CUPS_BACKEND_FAILED);\n  }\n  if (!strcmp(scheme, \".\") || !strcmp(scheme, \"..\"))\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Invalid URI, scheme (\\\"%s\\\") is a directory.\\n\",\n\t    scheme);\n    exit (CUPS_BACKEND_FAILED);\n  }\n  if ((cups_serverbin = getenv(\"CUPS_SERVERBIN\")) == NULL)\n    cups_serverbin = CUPS_SERVERBIN;\n\n  if (!strncasecmp(uri, \"file:\", 5) || uri[0] == '/')\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Direct output into a file not supported.\\n\");\n    exit (CUPS_BACKEND_FAILED);\n  }\n\n  backend_argv[0] = uri;\n  backend_argv[1] = argv[1];\n  backend_argv[2] = argv[2];\n  backend_argv[3] = argv[3];\n  backend_argv[4] = (argc == 6 ? \"1\" : argv[4]);\n  backend_argv[5] = argv[5];\n  backend_argv[6] = filename;\n  backend_argv[7] = NULL;\n\n  bytes = snprintf(backend_path, sizeof(backend_path),\n\t\t   \"%s/backend/%s\", cups_serverbin, scheme);\n  if (bytes < 0 || bytes >= sizeof(backend_path))\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Invalid scheme (\\\"%s\\\"), could not determing backend path.\\n\",\n\t    scheme);\n    exit (CUPS_BACKEND_FAILED);\n  }\n\n  //\n  // Overwrite the device URI and run the actual backend...\n  //\n\n  setenv(\"DEVICE_URI\", uri, 1);\n\n  fprintf(stderr,\n\t  \"DEBUG: beh: Executing backend command line \\\"%s '%s' '%s' '%s' '%s' '%s'%s%s\\\"...\\n\",\n\t  backend_path, backend_argv[1], backend_argv[2], backend_argv[3],\n\t  backend_argv[4], backend_argv[5],\n\t  (backend_argv[6] && backend_argv[6][0] ? \" \" : \"\"),\n\t  (backend_argv[6] && backend_argv[6][0] ? backend_argv[6] : \"\"));\n  fprintf(stderr,\n\t  \"DEBUG: beh: Using device URI: %s\\n\",\n\t  uri);\n\n  if ((pid = fork()) == 0)\n  {\n    retval = execv(backend_path, backend_argv);\n\n    if (retval == -1)\n      fprintf(stderr, \"ERROR: Unable to execute backend: %s\\n\",\n\t      strerror(errno));\n    exit (CUPS_BACKEND_FAILED);\n  }\n  else if (pid < 0)\n  {\n    fprintf(stderr, \"ERROR: Unable to fork for backend\\n\");\n    return (CUPS_BACKEND_FAILED);\n  }\n\n  while ((wait_pid = wait(&wait_status)) < 0 && errno == EINTR);\n\n  if (wait_pid >= 0 && wait_status)\n  {\n    if (WIFEXITED(wait_status))\n      retval = WEXITSTATUS(wait_status);\n    else if (WTERMSIG(wait_status) != SIGTERM)\n      retval = WTERMSIG(wait_status);\n    else\n      retval = 0;\n  }\n\n  return (retval);\n}\n\n\n//\n// 'sigterm_handler()' - Handle termination signals.\n//\n\nstatic void\nsigterm_handler(int sig)\t\t// I - Signal number (unused)\n{\n  (void)sig;\n\n  const char * const msg = \"DEBUG: beh: Job canceled.\\n\";\n  // The if() is to eliminate the return value and silence the warning\n  // about an unused return value.\n  if (write(2, msg, strlen(msg)));\n\n  if (job_canceled)\n    _exit(CUPS_BACKEND_OK);\n  else\n    job_canceled = 1;\n}\n"], "filenames": ["backend/beh.c"], "buggy_code_start_loc": [28], "buggy_code_end_loc": [309], "fixing_code_start_loc": [29], "fixing_code_end_loc": [368], "type": "CWE-78", "message": "cups-filters contains backends, filters, and other software required to get the cups printing service working on operating systems other than macos. If you use the Backend Error Handler (beh) to create an accessible network printer, this security vulnerability can cause remote code execution. `beh.c` contains the line `retval = system(cmdline) >> 8;` which calls the `system` command with the operand `cmdline`. `cmdline` contains multiple user controlled, unsanitized values. As a result an attacker with network access to the hosted print server can exploit this vulnerability to inject system commands which are executed in the context of the running server. This issue has been addressed in commit `8f2740357` and is expected to be bundled in the next release. Users are advised to upgrade when possible and to restrict access to network printers in the meantime.", "other": {"cve": {"id": "CVE-2023-24805", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-17T18:15:09.177", "lastModified": "2023-05-25T17:05:06.890", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "cups-filters contains backends, filters, and other software required to get the cups printing service working on operating systems other than macos. If you use the Backend Error Handler (beh) to create an accessible network printer, this security vulnerability can cause remote code execution. `beh.c` contains the line `retval = system(cmdline) >> 8;` which calls the `system` command with the operand `cmdline`. `cmdline` contains multiple user controlled, unsanitized values. As a result an attacker with network access to the hosted print server can exploit this vulnerability to inject system commands which are executed in the context of the running server. This issue has been addressed in commit `8f2740357` and is expected to be bundled in the next release. Users are advised to upgrade when possible and to restrict access to network printers in the meantime."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:cups-filters:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0", "matchCriteriaId": "4B3F579A-B8F0-4F15-A8DA-7D58BF94740A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:cups-filters:2.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "216CAAD0-DBE1-4732-9E7D-1E2F681DC3F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:cups-filters:2.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "528C776A-D684-4A2B-BD40-4798321169E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:cups-filters:2.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "04694E1A-63CE-41E8-A8CA-31368D058EDB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:cups-filters:2.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "DADB252D-65B1-4591-B3F3-DBCEFD49CC52"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/OpenPrinting/cups-filters/commit/8f274035756c04efeb77eb654e9d4c4447287d65", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/OpenPrinting/cups-filters/security/advisories/GHSA-gpxc-v2m8-fr3x", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/05/msg00021.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KL2SJMZQ5T5JIH3PMQ2CGCY5TUUE255Y/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Release Notes"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YNCGL2ZTAS2GFF23QFT55UFWIDMI4ZJK/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Release Notes"]}, {"url": "https://www.debian.org/security/2023/dsa-5407", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OpenPrinting/cups-filters/commit/8f274035756c04efeb77eb654e9d4c4447287d65"}}