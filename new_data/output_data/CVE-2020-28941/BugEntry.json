{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n#include <linux/types.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/slab.h>\n\n#include \"speakup.h\"\n#include \"spk_types.h\"\n#include \"spk_priv.h\"\n\nstruct spk_ldisc_data {\n\tchar buf;\n\tstruct completion completion;\n\tbool buf_free;\n};\n\nstatic struct spk_synth *spk_ttyio_synth;\nstatic struct tty_struct *speakup_tty;\n/* mutex to protect against speakup_tty disappearing from underneath us while\n * we are using it. this can happen when the device physically unplugged,\n * while in use. it also serialises access to speakup_tty.\n */\nstatic DEFINE_MUTEX(speakup_tty_mutex);\n\nstatic int ser_to_dev(int ser, dev_t *dev_no)\n{\n\tif (ser < 0 || ser > (255 - 64)) {\n\t\tpr_err(\"speakup: Invalid ser param. Must be between 0 and 191 inclusive.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*dev_no = MKDEV(4, (64 + ser));\n\treturn 0;\n}\n\nstatic int get_dev_to_use(struct spk_synth *synth, dev_t *dev_no)\n{\n\t/* use ser only when dev is not specified */\n\tif (strcmp(synth->dev_name, SYNTH_DEFAULT_DEV) ||\n\t    synth->ser == SYNTH_DEFAULT_SER)\n\t\treturn tty_dev_name_to_number(synth->dev_name, dev_no);\n\n\treturn ser_to_dev(synth->ser, dev_no);\n}\n\nstatic int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\tspeakup_tty = tty;\n\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\n\treturn 0;\n}\n\nstatic void spk_ttyio_ldisc_close(struct tty_struct *tty)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tkfree(speakup_tty->disc_data);\n\tspeakup_tty = NULL;\n\tmutex_unlock(&speakup_tty_mutex);\n}\n\nstatic int spk_ttyio_receive_buf2(struct tty_struct *tty,\n\t\t\t\t  const unsigned char *cp, char *fp, int count)\n{\n\tstruct spk_ldisc_data *ldisc_data = tty->disc_data;\n\n\tif (spk_ttyio_synth->read_buff_add) {\n\t\tint i;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t\tspk_ttyio_synth->read_buff_add(cp[i]);\n\n\t\treturn count;\n\t}\n\n\tif (!ldisc_data->buf_free)\n\t\t/* ttyio_in will tty_schedule_flip */\n\t\treturn 0;\n\n\t/* Make sure the consumer has read buf before we have seen\n\t * buf_free == true and overwrite buf\n\t */\n\tmb();\n\n\tldisc_data->buf = cp[0];\n\tldisc_data->buf_free = false;\n\tcomplete(&ldisc_data->completion);\n\n\treturn 1;\n}\n\nstatic struct tty_ldisc_ops spk_ttyio_ldisc_ops = {\n\t.owner          = THIS_MODULE,\n\t.magic          = TTY_LDISC_MAGIC,\n\t.name           = \"speakup_ldisc\",\n\t.open           = spk_ttyio_ldisc_open,\n\t.close          = spk_ttyio_ldisc_close,\n\t.receive_buf2\t= spk_ttyio_receive_buf2,\n};\n\nstatic int spk_ttyio_out(struct spk_synth *in_synth, const char ch);\nstatic int spk_ttyio_out_unicode(struct spk_synth *in_synth, u16 ch);\nstatic void spk_ttyio_send_xchar(char ch);\nstatic void spk_ttyio_tiocmset(unsigned int set, unsigned int clear);\nstatic unsigned char spk_ttyio_in(void);\nstatic unsigned char spk_ttyio_in_nowait(void);\nstatic void spk_ttyio_flush_buffer(void);\nstatic int spk_ttyio_wait_for_xmitr(struct spk_synth *in_synth);\n\nstruct spk_io_ops spk_ttyio_ops = {\n\t.synth_out = spk_ttyio_out,\n\t.synth_out_unicode = spk_ttyio_out_unicode,\n\t.send_xchar = spk_ttyio_send_xchar,\n\t.tiocmset = spk_ttyio_tiocmset,\n\t.synth_in = spk_ttyio_in,\n\t.synth_in_nowait = spk_ttyio_in_nowait,\n\t.flush_buffer = spk_ttyio_flush_buffer,\n\t.wait_for_xmitr = spk_ttyio_wait_for_xmitr,\n};\nEXPORT_SYMBOL_GPL(spk_ttyio_ops);\n\nstatic inline void get_termios(struct tty_struct *tty,\n\t\t\t       struct ktermios *out_termios)\n{\n\tdown_read(&tty->termios_rwsem);\n\t*out_termios = tty->termios;\n\tup_read(&tty->termios_rwsem);\n}\n\nstatic int spk_ttyio_initialise_ldisc(struct spk_synth *synth)\n{\n\tint ret = 0;\n\tstruct tty_struct *tty;\n\tstruct ktermios tmp_termios;\n\tdev_t dev;\n\n\tret = get_dev_to_use(synth, &dev);\n\tif (ret)\n\t\treturn ret;\n\n\ttty = tty_kopen(dev);\n\tif (IS_ERR(tty))\n\t\treturn PTR_ERR(tty);\n\n\tif (tty->ops->open)\n\t\tret = tty->ops->open(tty, NULL);\n\telse\n\t\tret = -ENODEV;\n\n\tif (ret) {\n\t\ttty_unlock(tty);\n\t\treturn ret;\n\t}\n\n\tclear_bit(TTY_HUPPED, &tty->flags);\n\t/* ensure hardware flow control is enabled */\n\tget_termios(tty, &tmp_termios);\n\tif (!(tmp_termios.c_cflag & CRTSCTS)) {\n\t\ttmp_termios.c_cflag |= CRTSCTS;\n\t\ttty_set_termios(tty, &tmp_termios);\n\t\t/*\n\t\t * check c_cflag to see if it's updated as tty_set_termios\n\t\t * may not return error even when no tty bits are\n\t\t * changed by the request.\n\t\t */\n\t\tget_termios(tty, &tmp_termios);\n\t\tif (!(tmp_termios.c_cflag & CRTSCTS))\n\t\t\tpr_warn(\"speakup: Failed to set hardware flow control\\n\");\n\t}\n\n\ttty_unlock(tty);\n\n\tret = tty_set_ldisc(tty, N_SPEAKUP);\n\tif (ret)\n\t\tpr_err(\"speakup: Failed to set N_SPEAKUP on tty\\n\");\n\n\treturn ret;\n}\n\nvoid spk_ttyio_register_ldisc(void)\n{\n\tif (tty_register_ldisc(N_SPEAKUP, &spk_ttyio_ldisc_ops))\n\t\tpr_warn(\"speakup: Error registering line discipline. Most synths won't work.\\n\");\n}\n\nvoid spk_ttyio_unregister_ldisc(void)\n{\n\tif (tty_unregister_ldisc(N_SPEAKUP))\n\t\tpr_warn(\"speakup: Couldn't unregister ldisc\\n\");\n}\n\nstatic int spk_ttyio_out(struct spk_synth *in_synth, const char ch)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tif (in_synth->alive && speakup_tty && speakup_tty->ops->write) {\n\t\tint ret = speakup_tty->ops->write(speakup_tty, &ch, 1);\n\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\tif (ret == 0)\n\t\t\t/* No room */\n\t\t\treturn 0;\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"%s: I/O error, deactivating speakup\\n\",\n\t\t\t\tin_synth->long_name);\n\t\t\t/* No synth any more, so nobody will restart TTYs,\n\t\t\t * and we thus need to do it ourselves.  Now that there\n\t\t\t * is no synth we can let application flood anyway\n\t\t\t */\n\t\t\tin_synth->alive = 0;\n\t\t\tspeakup_start_ttys();\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tmutex_unlock(&speakup_tty_mutex);\n\treturn 0;\n}\n\nstatic int spk_ttyio_out_unicode(struct spk_synth *in_synth, u16 ch)\n{\n\tint ret;\n\n\tif (ch < 0x80) {\n\t\tret = spk_ttyio_out(in_synth, ch);\n\t} else if (ch < 0x800) {\n\t\tret  = spk_ttyio_out(in_synth, 0xc0 | (ch >> 6));\n\t\tret &= spk_ttyio_out(in_synth, 0x80 | (ch & 0x3f));\n\t} else {\n\t\tret  = spk_ttyio_out(in_synth, 0xe0 | (ch >> 12));\n\t\tret &= spk_ttyio_out(in_synth, 0x80 | ((ch >> 6) & 0x3f));\n\t\tret &= spk_ttyio_out(in_synth, 0x80 | (ch & 0x3f));\n\t}\n\treturn ret;\n}\n\nstatic int check_tty(struct tty_struct *tty)\n{\n\tif (!tty) {\n\t\tpr_warn(\"%s: I/O error, deactivating speakup\\n\",\n\t\t\tspk_ttyio_synth->long_name);\n\t\t/* No synth any more, so nobody will restart TTYs, and we thus\n\t\t * need to do it ourselves.  Now that there is no synth we can\n\t\t * let application flood anyway\n\t\t */\n\t\tspk_ttyio_synth->alive = 0;\n\t\tspeakup_start_ttys();\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void spk_ttyio_send_xchar(char ch)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tif (check_tty(speakup_tty)) {\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn;\n\t}\n\n\tif (speakup_tty->ops->send_xchar)\n\t\tspeakup_tty->ops->send_xchar(speakup_tty, ch);\n\tmutex_unlock(&speakup_tty_mutex);\n}\n\nstatic void spk_ttyio_tiocmset(unsigned int set, unsigned int clear)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tif (check_tty(speakup_tty)) {\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn;\n\t}\n\n\tif (speakup_tty->ops->tiocmset)\n\t\tspeakup_tty->ops->tiocmset(speakup_tty, set, clear);\n\tmutex_unlock(&speakup_tty_mutex);\n}\n\nstatic int spk_ttyio_wait_for_xmitr(struct spk_synth *in_synth)\n{\n\treturn 1;\n}\n\nstatic unsigned char ttyio_in(int timeout)\n{\n\tstruct spk_ldisc_data *ldisc_data = speakup_tty->disc_data;\n\tchar rv;\n\n\tif (wait_for_completion_timeout(&ldisc_data->completion,\n\t\t\t\t\tusecs_to_jiffies(timeout)) == 0) {\n\t\tif (timeout)\n\t\t\tpr_warn(\"spk_ttyio: timeout (%d)  while waiting for input\\n\",\n\t\t\t\ttimeout);\n\t\treturn 0xff;\n\t}\n\n\trv = ldisc_data->buf;\n\t/* Make sure we have read buf before we set buf_free to let\n\t * the producer overwrite it\n\t */\n\tmb();\n\tldisc_data->buf_free = true;\n\t/* Let TTY push more characters */\n\ttty_schedule_flip(speakup_tty->port);\n\n\treturn rv;\n}\n\nstatic unsigned char spk_ttyio_in(void)\n{\n\treturn ttyio_in(SPK_SYNTH_TIMEOUT);\n}\n\nstatic unsigned char spk_ttyio_in_nowait(void)\n{\n\tu8 rv = ttyio_in(0);\n\n\treturn (rv == 0xff) ? 0 : rv;\n}\n\nstatic void spk_ttyio_flush_buffer(void)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tif (check_tty(speakup_tty)) {\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn;\n\t}\n\n\tif (speakup_tty->ops->flush_buffer)\n\t\tspeakup_tty->ops->flush_buffer(speakup_tty);\n\n\tmutex_unlock(&speakup_tty_mutex);\n}\n\nint spk_ttyio_synth_probe(struct spk_synth *synth)\n{\n\tint rv = spk_ttyio_initialise_ldisc(synth);\n\n\tif (rv)\n\t\treturn rv;\n\n\tsynth->alive = 1;\n\tspk_ttyio_synth = synth;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(spk_ttyio_synth_probe);\n\nvoid spk_ttyio_release(void)\n{\n\tif (!speakup_tty)\n\t\treturn;\n\n\ttty_lock(speakup_tty);\n\n\tif (speakup_tty->ops->close)\n\t\tspeakup_tty->ops->close(speakup_tty, NULL);\n\n\ttty_ldisc_flush(speakup_tty);\n\ttty_unlock(speakup_tty);\n\ttty_kclose(speakup_tty);\n}\nEXPORT_SYMBOL_GPL(spk_ttyio_release);\n\nconst char *spk_ttyio_synth_immediate(struct spk_synth *synth, const char *buff)\n{\n\tu_char ch;\n\n\twhile ((ch = *buff)) {\n\t\tif (ch == '\\n')\n\t\t\tch = synth->procspeech;\n\t\tif (tty_write_room(speakup_tty) < 1 ||\n\t\t    !synth->io_ops->synth_out(synth, ch))\n\t\t\treturn buff;\n\t\tbuff++;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(spk_ttyio_synth_immediate);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n#include <linux/types.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/slab.h>\n\n#include \"speakup.h\"\n#include \"spk_types.h\"\n#include \"spk_priv.h\"\n\nstruct spk_ldisc_data {\n\tchar buf;\n\tstruct completion completion;\n\tbool buf_free;\n};\n\nstatic struct spk_synth *spk_ttyio_synth;\nstatic struct tty_struct *speakup_tty;\n/* mutex to protect against speakup_tty disappearing from underneath us while\n * we are using it. this can happen when the device physically unplugged,\n * while in use. it also serialises access to speakup_tty.\n */\nstatic DEFINE_MUTEX(speakup_tty_mutex);\n\nstatic int ser_to_dev(int ser, dev_t *dev_no)\n{\n\tif (ser < 0 || ser > (255 - 64)) {\n\t\tpr_err(\"speakup: Invalid ser param. Must be between 0 and 191 inclusive.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*dev_no = MKDEV(4, (64 + ser));\n\treturn 0;\n}\n\nstatic int get_dev_to_use(struct spk_synth *synth, dev_t *dev_no)\n{\n\t/* use ser only when dev is not specified */\n\tif (strcmp(synth->dev_name, SYNTH_DEFAULT_DEV) ||\n\t    synth->ser == SYNTH_DEFAULT_SER)\n\t\treturn tty_dev_name_to_number(synth->dev_name, dev_no);\n\n\treturn ser_to_dev(synth->ser, dev_no);\n}\n\nstatic int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&speakup_tty_mutex);\n\tif (speakup_tty) {\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn -EBUSY;\n\t}\n\tspeakup_tty = tty;\n\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data) {\n\t\tspeakup_tty = NULL;\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\tmutex_unlock(&speakup_tty_mutex);\n\n\treturn 0;\n}\n\nstatic void spk_ttyio_ldisc_close(struct tty_struct *tty)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tkfree(speakup_tty->disc_data);\n\tspeakup_tty = NULL;\n\tmutex_unlock(&speakup_tty_mutex);\n}\n\nstatic int spk_ttyio_receive_buf2(struct tty_struct *tty,\n\t\t\t\t  const unsigned char *cp, char *fp, int count)\n{\n\tstruct spk_ldisc_data *ldisc_data = tty->disc_data;\n\n\tif (spk_ttyio_synth->read_buff_add) {\n\t\tint i;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t\tspk_ttyio_synth->read_buff_add(cp[i]);\n\n\t\treturn count;\n\t}\n\n\tif (!ldisc_data->buf_free)\n\t\t/* ttyio_in will tty_schedule_flip */\n\t\treturn 0;\n\n\t/* Make sure the consumer has read buf before we have seen\n\t * buf_free == true and overwrite buf\n\t */\n\tmb();\n\n\tldisc_data->buf = cp[0];\n\tldisc_data->buf_free = false;\n\tcomplete(&ldisc_data->completion);\n\n\treturn 1;\n}\n\nstatic struct tty_ldisc_ops spk_ttyio_ldisc_ops = {\n\t.owner          = THIS_MODULE,\n\t.magic          = TTY_LDISC_MAGIC,\n\t.name           = \"speakup_ldisc\",\n\t.open           = spk_ttyio_ldisc_open,\n\t.close          = spk_ttyio_ldisc_close,\n\t.receive_buf2\t= spk_ttyio_receive_buf2,\n};\n\nstatic int spk_ttyio_out(struct spk_synth *in_synth, const char ch);\nstatic int spk_ttyio_out_unicode(struct spk_synth *in_synth, u16 ch);\nstatic void spk_ttyio_send_xchar(char ch);\nstatic void spk_ttyio_tiocmset(unsigned int set, unsigned int clear);\nstatic unsigned char spk_ttyio_in(void);\nstatic unsigned char spk_ttyio_in_nowait(void);\nstatic void spk_ttyio_flush_buffer(void);\nstatic int spk_ttyio_wait_for_xmitr(struct spk_synth *in_synth);\n\nstruct spk_io_ops spk_ttyio_ops = {\n\t.synth_out = spk_ttyio_out,\n\t.synth_out_unicode = spk_ttyio_out_unicode,\n\t.send_xchar = spk_ttyio_send_xchar,\n\t.tiocmset = spk_ttyio_tiocmset,\n\t.synth_in = spk_ttyio_in,\n\t.synth_in_nowait = spk_ttyio_in_nowait,\n\t.flush_buffer = spk_ttyio_flush_buffer,\n\t.wait_for_xmitr = spk_ttyio_wait_for_xmitr,\n};\nEXPORT_SYMBOL_GPL(spk_ttyio_ops);\n\nstatic inline void get_termios(struct tty_struct *tty,\n\t\t\t       struct ktermios *out_termios)\n{\n\tdown_read(&tty->termios_rwsem);\n\t*out_termios = tty->termios;\n\tup_read(&tty->termios_rwsem);\n}\n\nstatic int spk_ttyio_initialise_ldisc(struct spk_synth *synth)\n{\n\tint ret = 0;\n\tstruct tty_struct *tty;\n\tstruct ktermios tmp_termios;\n\tdev_t dev;\n\n\tret = get_dev_to_use(synth, &dev);\n\tif (ret)\n\t\treturn ret;\n\n\ttty = tty_kopen(dev);\n\tif (IS_ERR(tty))\n\t\treturn PTR_ERR(tty);\n\n\tif (tty->ops->open)\n\t\tret = tty->ops->open(tty, NULL);\n\telse\n\t\tret = -ENODEV;\n\n\tif (ret) {\n\t\ttty_unlock(tty);\n\t\treturn ret;\n\t}\n\n\tclear_bit(TTY_HUPPED, &tty->flags);\n\t/* ensure hardware flow control is enabled */\n\tget_termios(tty, &tmp_termios);\n\tif (!(tmp_termios.c_cflag & CRTSCTS)) {\n\t\ttmp_termios.c_cflag |= CRTSCTS;\n\t\ttty_set_termios(tty, &tmp_termios);\n\t\t/*\n\t\t * check c_cflag to see if it's updated as tty_set_termios\n\t\t * may not return error even when no tty bits are\n\t\t * changed by the request.\n\t\t */\n\t\tget_termios(tty, &tmp_termios);\n\t\tif (!(tmp_termios.c_cflag & CRTSCTS))\n\t\t\tpr_warn(\"speakup: Failed to set hardware flow control\\n\");\n\t}\n\n\ttty_unlock(tty);\n\n\tret = tty_set_ldisc(tty, N_SPEAKUP);\n\tif (ret)\n\t\tpr_err(\"speakup: Failed to set N_SPEAKUP on tty\\n\");\n\n\treturn ret;\n}\n\nvoid spk_ttyio_register_ldisc(void)\n{\n\tif (tty_register_ldisc(N_SPEAKUP, &spk_ttyio_ldisc_ops))\n\t\tpr_warn(\"speakup: Error registering line discipline. Most synths won't work.\\n\");\n}\n\nvoid spk_ttyio_unregister_ldisc(void)\n{\n\tif (tty_unregister_ldisc(N_SPEAKUP))\n\t\tpr_warn(\"speakup: Couldn't unregister ldisc\\n\");\n}\n\nstatic int spk_ttyio_out(struct spk_synth *in_synth, const char ch)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tif (in_synth->alive && speakup_tty && speakup_tty->ops->write) {\n\t\tint ret = speakup_tty->ops->write(speakup_tty, &ch, 1);\n\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\tif (ret == 0)\n\t\t\t/* No room */\n\t\t\treturn 0;\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"%s: I/O error, deactivating speakup\\n\",\n\t\t\t\tin_synth->long_name);\n\t\t\t/* No synth any more, so nobody will restart TTYs,\n\t\t\t * and we thus need to do it ourselves.  Now that there\n\t\t\t * is no synth we can let application flood anyway\n\t\t\t */\n\t\t\tin_synth->alive = 0;\n\t\t\tspeakup_start_ttys();\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tmutex_unlock(&speakup_tty_mutex);\n\treturn 0;\n}\n\nstatic int spk_ttyio_out_unicode(struct spk_synth *in_synth, u16 ch)\n{\n\tint ret;\n\n\tif (ch < 0x80) {\n\t\tret = spk_ttyio_out(in_synth, ch);\n\t} else if (ch < 0x800) {\n\t\tret  = spk_ttyio_out(in_synth, 0xc0 | (ch >> 6));\n\t\tret &= spk_ttyio_out(in_synth, 0x80 | (ch & 0x3f));\n\t} else {\n\t\tret  = spk_ttyio_out(in_synth, 0xe0 | (ch >> 12));\n\t\tret &= spk_ttyio_out(in_synth, 0x80 | ((ch >> 6) & 0x3f));\n\t\tret &= spk_ttyio_out(in_synth, 0x80 | (ch & 0x3f));\n\t}\n\treturn ret;\n}\n\nstatic int check_tty(struct tty_struct *tty)\n{\n\tif (!tty) {\n\t\tpr_warn(\"%s: I/O error, deactivating speakup\\n\",\n\t\t\tspk_ttyio_synth->long_name);\n\t\t/* No synth any more, so nobody will restart TTYs, and we thus\n\t\t * need to do it ourselves.  Now that there is no synth we can\n\t\t * let application flood anyway\n\t\t */\n\t\tspk_ttyio_synth->alive = 0;\n\t\tspeakup_start_ttys();\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void spk_ttyio_send_xchar(char ch)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tif (check_tty(speakup_tty)) {\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn;\n\t}\n\n\tif (speakup_tty->ops->send_xchar)\n\t\tspeakup_tty->ops->send_xchar(speakup_tty, ch);\n\tmutex_unlock(&speakup_tty_mutex);\n}\n\nstatic void spk_ttyio_tiocmset(unsigned int set, unsigned int clear)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tif (check_tty(speakup_tty)) {\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn;\n\t}\n\n\tif (speakup_tty->ops->tiocmset)\n\t\tspeakup_tty->ops->tiocmset(speakup_tty, set, clear);\n\tmutex_unlock(&speakup_tty_mutex);\n}\n\nstatic int spk_ttyio_wait_for_xmitr(struct spk_synth *in_synth)\n{\n\treturn 1;\n}\n\nstatic unsigned char ttyio_in(int timeout)\n{\n\tstruct spk_ldisc_data *ldisc_data = speakup_tty->disc_data;\n\tchar rv;\n\n\tif (wait_for_completion_timeout(&ldisc_data->completion,\n\t\t\t\t\tusecs_to_jiffies(timeout)) == 0) {\n\t\tif (timeout)\n\t\t\tpr_warn(\"spk_ttyio: timeout (%d)  while waiting for input\\n\",\n\t\t\t\ttimeout);\n\t\treturn 0xff;\n\t}\n\n\trv = ldisc_data->buf;\n\t/* Make sure we have read buf before we set buf_free to let\n\t * the producer overwrite it\n\t */\n\tmb();\n\tldisc_data->buf_free = true;\n\t/* Let TTY push more characters */\n\ttty_schedule_flip(speakup_tty->port);\n\n\treturn rv;\n}\n\nstatic unsigned char spk_ttyio_in(void)\n{\n\treturn ttyio_in(SPK_SYNTH_TIMEOUT);\n}\n\nstatic unsigned char spk_ttyio_in_nowait(void)\n{\n\tu8 rv = ttyio_in(0);\n\n\treturn (rv == 0xff) ? 0 : rv;\n}\n\nstatic void spk_ttyio_flush_buffer(void)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tif (check_tty(speakup_tty)) {\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn;\n\t}\n\n\tif (speakup_tty->ops->flush_buffer)\n\t\tspeakup_tty->ops->flush_buffer(speakup_tty);\n\n\tmutex_unlock(&speakup_tty_mutex);\n}\n\nint spk_ttyio_synth_probe(struct spk_synth *synth)\n{\n\tint rv = spk_ttyio_initialise_ldisc(synth);\n\n\tif (rv)\n\t\treturn rv;\n\n\tsynth->alive = 1;\n\tspk_ttyio_synth = synth;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(spk_ttyio_synth_probe);\n\nvoid spk_ttyio_release(void)\n{\n\tif (!speakup_tty)\n\t\treturn;\n\n\ttty_lock(speakup_tty);\n\n\tif (speakup_tty->ops->close)\n\t\tspeakup_tty->ops->close(speakup_tty, NULL);\n\n\ttty_ldisc_flush(speakup_tty);\n\ttty_unlock(speakup_tty);\n\ttty_kclose(speakup_tty);\n}\nEXPORT_SYMBOL_GPL(spk_ttyio_release);\n\nconst char *spk_ttyio_synth_immediate(struct spk_synth *synth, const char *buff)\n{\n\tu_char ch;\n\n\twhile ((ch = *buff)) {\n\t\tif (ch == '\\n')\n\t\t\tch = synth->procspeech;\n\t\tif (tty_write_room(speakup_tty) < 1 ||\n\t\t    !synth->io_ops->synth_out(synth, ch))\n\t\t\treturn buff;\n\t\tbuff++;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(spk_ttyio_synth_immediate);\n"], "filenames": ["drivers/accessibility/speakup/spk_ttyio.c"], "buggy_code_start_loc": [51], "buggy_code_end_loc": [60], "fixing_code_start_loc": [52], "fixing_code_end_loc": [71], "type": "CWE-763", "message": "An issue was discovered in drivers/accessibility/speakup/spk_ttyio.c in the Linux kernel through 5.9.9. Local attackers on systems with the speakup driver could cause a local denial of service attack, aka CID-d41227544427. This occurs because of an invalid free when the line discipline is used more than once.", "other": {"cve": {"id": "CVE-2020-28941", "sourceIdentifier": "cve@mitre.org", "published": "2020-11-19T19:15:11.797", "lastModified": "2022-10-19T14:44:28.457", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in drivers/accessibility/speakup/spk_ttyio.c in the Linux kernel through 5.9.9. Local attackers on systems with the speakup driver could cause a local denial of service attack, aka CID-d41227544427. This occurs because of an invalid free when the line discipline is used more than once."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el archivo drivers/accessibility/speakup/spk_ttyio.c en el kernel de Linux versiones hasta 5.9.9.&#xa0;Los atacantes locales en sistemas con el controlador speakup podr\u00edan causar un ataque local de denegaci\u00f3n de servicio, tambi\u00e9n se conoce como CID-d41227544427.&#xa0;Esto ocurre debido a una liberaci\u00f3n no v\u00e1lida cuando la disciplina de l\u00ednea se usa m\u00e1s de una vez"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-763"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.9.9", "matchCriteriaId": "CA9FD489-2FF3-4B82-9FB2-0D48920CDF88"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2020/11/19/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=d4122754442799187d5d537a9c039a49a67e57f1", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty.git/commit/?h=tty-linus&id=d4122754442799187d5d537a9c039a49a67e57f1", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/d4122754442799187d5d537a9c039a49a67e57f1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/12/msg00015.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TITJQPYDWZ4NB2ONJWUXW75KSQIPF35T/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZF4OGZPKTAJJXWHPIFP3LHEWWEMR5LPT/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2020/11/19/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/d4122754442799187d5d537a9c039a49a67e57f1"}}