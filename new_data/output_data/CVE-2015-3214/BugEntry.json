{"buggy_code": ["/*\n * 8253/8254 interval timer emulation\n *\n * Copyright (c) 2003-2004 Fabrice Bellard\n * Copyright (c) 2006 Intel Corporation\n * Copyright (c) 2007 Keir Fraser, XenSource Inc\n * Copyright (c) 2008 Intel Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * Authors:\n *   Sheng Yang <sheng.yang@intel.com>\n *   Based on QEMU and Xen.\n */\n\n#define pr_fmt(fmt) \"pit: \" fmt\n\n#include <linux/kvm_host.h>\n\n#include \"irq.h\"\n#include \"i8254.h\"\n\n#ifndef CONFIG_X86_64\n#define mod_64(x, y) ((x) - (y) * div64_u64(x, y))\n#else\n#define mod_64(x, y) ((x) % (y))\n#endif\n\n#define RW_STATE_LSB 1\n#define RW_STATE_MSB 2\n#define RW_STATE_WORD0 3\n#define RW_STATE_WORD1 4\n\n/* Compute with 96 bit intermediate result: (a*b)/c */\nstatic u64 muldiv64(u64 a, u32 b, u32 c)\n{\n\tunion {\n\t\tu64 ll;\n\t\tstruct {\n\t\t\tu32 low, high;\n\t\t} l;\n\t} u, res;\n\tu64 rl, rh;\n\n\tu.ll = a;\n\trl = (u64)u.l.low * (u64)b;\n\trh = (u64)u.l.high * (u64)b;\n\trh += (rl >> 32);\n\tres.l.high = div64_u64(rh, c);\n\tres.l.low = div64_u64(((mod_64(rh, c) << 32) + (rl & 0xffffffff)), c);\n\treturn res.ll;\n}\n\nstatic void pit_set_gate(struct kvm *kvm, int channel, u32 val)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\tcase 4:\n\t\t/* XXX: just disable/enable counting */\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 5:\n\t\t/* Restart counting on rising edge. */\n\t\tif (c->gate < val)\n\t\t\tc->count_load_time = ktime_get();\n\t\tbreak;\n\t}\n\n\tc->gate = val;\n}\n\nstatic int pit_get_gate(struct kvm *kvm, int channel)\n{\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\treturn kvm->arch.vpit->pit_state.channels[channel].gate;\n}\n\nstatic s64 __kpit_elapsed(struct kvm *kvm)\n{\n\ts64 elapsed;\n\tktime_t remaining;\n\tstruct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;\n\n\tif (!ps->pit_timer.period)\n\t\treturn 0;\n\n\t/*\n\t * The Counter does not stop when it reaches zero. In\n\t * Modes 0, 1, 4, and 5 the Counter ``wraps around'' to\n\t * the highest count, either FFFF hex for binary counting\n\t * or 9999 for BCD counting, and continues counting.\n\t * Modes 2 and 3 are periodic; the Counter reloads\n\t * itself with the initial count and continues counting\n\t * from there.\n\t */\n\tremaining = hrtimer_get_remaining(&ps->pit_timer.timer);\n\telapsed = ps->pit_timer.period - ktime_to_ns(remaining);\n\telapsed = mod_64(elapsed, ps->pit_timer.period);\n\n\treturn elapsed;\n}\n\nstatic s64 kpit_elapsed(struct kvm *kvm, struct kvm_kpit_channel_state *c,\n\t\t\tint channel)\n{\n\tif (channel == 0)\n\t\treturn __kpit_elapsed(kvm);\n\n\treturn ktime_to_ns(ktime_sub(ktime_get(), c->count_load_time));\n}\n\nstatic int pit_get_count(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\ts64 d, t;\n\tint counter;\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tt = kpit_elapsed(kvm, c, channel);\n\td = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 4:\n\tcase 5:\n\t\tcounter = (c->count - d) & 0xffff;\n\t\tbreak;\n\tcase 3:\n\t\t/* XXX: may be incorrect for odd counts */\n\t\tcounter = c->count - (mod_64((2 * d), c->count));\n\t\tbreak;\n\tdefault:\n\t\tcounter = c->count - mod_64(d, c->count);\n\t\tbreak;\n\t}\n\treturn counter;\n}\n\nstatic int pit_get_out(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\ts64 d, t;\n\tint out;\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tt = kpit_elapsed(kvm, c, channel);\n\td = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\t\tout = (d >= c->count);\n\t\tbreak;\n\tcase 1:\n\t\tout = (d < c->count);\n\t\tbreak;\n\tcase 2:\n\t\tout = ((mod_64(d, c->count) == 0) && (d != 0));\n\t\tbreak;\n\tcase 3:\n\t\tout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tout = (d == c->count);\n\t\tbreak;\n\t}\n\n\treturn out;\n}\n\nstatic void pit_latch_count(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tif (!c->count_latched) {\n\t\tc->latched_count = pit_get_count(kvm, channel);\n\t\tc->count_latched = c->rw_mode;\n\t}\n}\n\nstatic void pit_latch_status(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tif (!c->status_latched) {\n\t\t/* TODO: Return NULL COUNT (bit 6). */\n\t\tc->status = ((pit_get_out(kvm, channel) << 7) |\n\t\t\t\t(c->rw_mode << 4) |\n\t\t\t\t(c->mode << 1) |\n\t\t\t\tc->bcd);\n\t\tc->status_latched = 1;\n\t}\n}\n\nint pit_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\n\tif (pit && kvm_vcpu_is_bsp(vcpu) && pit->pit_state.irq_ack)\n\t\treturn atomic_read(&pit->pit_state.pit_timer.pending);\n\treturn 0;\n}\n\nstatic void kvm_pit_ack_irq(struct kvm_irq_ack_notifier *kian)\n{\n\tstruct kvm_kpit_state *ps = container_of(kian, struct kvm_kpit_state,\n\t\t\t\t\t\t irq_ack_notifier);\n\tspin_lock(&ps->inject_lock);\n\tif (atomic_dec_return(&ps->pit_timer.pending) < 0)\n\t\tatomic_inc(&ps->pit_timer.pending);\n\tps->irq_ack = 1;\n\tspin_unlock(&ps->inject_lock);\n}\n\nvoid __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n\t\treturn;\n\n\ttimer = &pit->pit_state.pit_timer.timer;\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n}\n\nstatic void destroy_pit_timer(struct kvm_timer *pt)\n{\n\tpr_debug(\"execute del timer!\\n\");\n\thrtimer_cancel(&pt->timer);\n}\n\nstatic bool kpit_is_periodic(struct kvm_timer *ktimer)\n{\n\tstruct kvm_kpit_state *ps = container_of(ktimer, struct kvm_kpit_state,\n\t\t\t\t\t\t pit_timer);\n\treturn ps->is_periodic;\n}\n\nstatic struct kvm_timer_ops kpit_ops = {\n\t.is_periodic = kpit_is_periodic,\n};\n\nstatic void create_pit_timer(struct kvm_kpit_state *ps, u32 val, int is_period)\n{\n\tstruct kvm_timer *pt = &ps->pit_timer;\n\ts64 interval;\n\n\tinterval = muldiv64(val, NSEC_PER_SEC, KVM_PIT_FREQ);\n\n\tpr_debug(\"create pit timer, interval is %llu nsec\\n\", interval);\n\n\t/* TODO The new value only affected after the retriggered */\n\thrtimer_cancel(&pt->timer);\n\tpt->period = interval;\n\tps->is_periodic = is_period;\n\n\tpt->timer.function = kvm_timer_fn;\n\tpt->t_ops = &kpit_ops;\n\tpt->kvm = ps->pit->kvm;\n\tpt->vcpu = pt->kvm->bsp_vcpu;\n\n\tatomic_set(&pt->pending, 0);\n\tps->irq_ack = 1;\n\n\thrtimer_start(&pt->timer, ktime_add_ns(ktime_get(), interval),\n\t\t      HRTIMER_MODE_ABS);\n}\n\nstatic void pit_load_count(struct kvm *kvm, int channel, u32 val)\n{\n\tstruct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;\n\n\tWARN_ON(!mutex_is_locked(&ps->lock));\n\n\tpr_debug(\"load_count val is %d, channel is %d\\n\", val, channel);\n\n\t/*\n\t * The largest possible initial count is 0; this is equivalent\n\t * to 216 for binary counting and 104 for BCD counting.\n\t */\n\tif (val == 0)\n\t\tval = 0x10000;\n\n\tps->channels[channel].count = val;\n\n\tif (channel != 0) {\n\t\tps->channels[channel].count_load_time = ktime_get();\n\t\treturn;\n\t}\n\n\t/* Two types of timer\n\t * mode 1 is one shot, mode 2 is period, otherwise del timer */\n\tswitch (ps->channels[0].mode) {\n\tcase 0:\n\tcase 1:\n        /* FIXME: enhance mode 4 precision */\n\tcase 4:\n\t\tif (!(ps->flags & KVM_PIT_FLAGS_HPET_LEGACY)) {\n\t\t\tcreate_pit_timer(ps, val, 0);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tif (!(ps->flags & KVM_PIT_FLAGS_HPET_LEGACY)){\n\t\t\tcreate_pit_timer(ps, val, 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdestroy_pit_timer(&ps->pit_timer);\n\t}\n}\n\nvoid kvm_pit_load_count(struct kvm *kvm, int channel, u32 val, int hpet_legacy_start)\n{\n\tu8 saved_mode;\n\tif (hpet_legacy_start) {\n\t\t/* save existing mode for later reenablement */\n\t\tsaved_mode = kvm->arch.vpit->pit_state.channels[0].mode;\n\t\tkvm->arch.vpit->pit_state.channels[0].mode = 0xff; /* disable timer */\n\t\tpit_load_count(kvm, channel, val);\n\t\tkvm->arch.vpit->pit_state.channels[0].mode = saved_mode;\n\t} else {\n\t\tpit_load_count(kvm, channel, val);\n\t}\n}\n\nstatic inline struct kvm_pit *dev_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, dev);\n}\n\nstatic inline struct kvm_pit *speaker_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, speaker_dev);\n}\n\nstatic inline int pit_in_range(gpa_t addr)\n{\n\treturn ((addr >= KVM_PIT_BASE_ADDRESS) &&\n\t\t(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));\n}\n\nstatic int pit_ioport_write(struct kvm_io_device *this,\n\t\t\t    gpa_t addr, int len, const void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint channel, access;\n\tstruct kvm_kpit_channel_state *s;\n\tu32 val = *(u32 *) data;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tval  &= 0xff;\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\n\tmutex_lock(&pit_state->lock);\n\n\tif (val != 0)\n\t\tpr_debug(\"write addr is 0x%x, len is %d, val is 0x%x\\n\",\n\t\t\t (unsigned int)addr, len, val);\n\n\tif (addr == 3) {\n\t\tchannel = val >> 6;\n\t\tif (channel == 3) {\n\t\t\t/* Read-Back Command. */\n\t\t\tfor (channel = 0; channel < 3; channel++) {\n\t\t\t\ts = &pit_state->channels[channel];\n\t\t\t\tif (val & (2 << channel)) {\n\t\t\t\t\tif (!(val & 0x20))\n\t\t\t\t\t\tpit_latch_count(kvm, channel);\n\t\t\t\t\tif (!(val & 0x10))\n\t\t\t\t\t\tpit_latch_status(kvm, channel);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* Select Counter <channel>. */\n\t\t\ts = &pit_state->channels[channel];\n\t\t\taccess = (val >> 4) & KVM_PIT_CHANNEL_MASK;\n\t\t\tif (access == 0) {\n\t\t\t\tpit_latch_count(kvm, channel);\n\t\t\t} else {\n\t\t\t\ts->rw_mode = access;\n\t\t\t\ts->read_state = access;\n\t\t\t\ts->write_state = access;\n\t\t\t\ts->mode = (val >> 1) & 7;\n\t\t\t\tif (s->mode > 5)\n\t\t\t\t\ts->mode -= 4;\n\t\t\t\ts->bcd = val & 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Write Count. */\n\t\ts = &pit_state->channels[addr];\n\t\tswitch (s->write_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tpit_load_count(kvm, addr, val);\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tpit_load_count(kvm, addr, val << 8);\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\ts->write_latch = val;\n\t\t\ts->write_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tpit_load_count(kvm, addr, s->write_latch | (val << 8));\n\t\t\ts->write_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nstatic int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\ts = &pit_state->channels[addr];\n\n\tmutex_lock(&pit_state->lock);\n\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nstatic int speaker_ioport_write(struct kvm_io_device *this,\n\t\t\t\tgpa_t addr, int len, const void *data)\n{\n\tstruct kvm_pit *pit = speaker_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tu32 val = *(u32 *) data;\n\tif (addr != KVM_SPEAKER_BASE_ADDRESS)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&pit_state->lock);\n\tpit_state->speaker_data_on = (val >> 1) & 1;\n\tpit_set_gate(kvm, 2, val & 1);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nstatic int speaker_ioport_read(struct kvm_io_device *this,\n\t\t\t       gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = speaker_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tunsigned int refresh_clock;\n\tint ret;\n\tif (addr != KVM_SPEAKER_BASE_ADDRESS)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Refresh clock toggles at about 15us. We approximate as 2^14ns. */\n\trefresh_clock = ((unsigned int)ktime_to_ns(ktime_get()) >> 14) & 1;\n\n\tmutex_lock(&pit_state->lock);\n\tret = ((pit_state->speaker_data_on << 1) | pit_get_gate(kvm, 2) |\n\t\t(pit_get_out(kvm, 2) << 5) | (refresh_clock << 4));\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nvoid kvm_pit_reset(struct kvm_pit *pit)\n{\n\tint i;\n\tstruct kvm_kpit_channel_state *c;\n\n\tmutex_lock(&pit->pit_state.lock);\n\tpit->pit_state.flags = 0;\n\tfor (i = 0; i < 3; i++) {\n\t\tc = &pit->pit_state.channels[i];\n\t\tc->mode = 0xff;\n\t\tc->gate = (i != 2);\n\t\tpit_load_count(pit->kvm, i, 0);\n\t}\n\tmutex_unlock(&pit->pit_state.lock);\n\n\tatomic_set(&pit->pit_state.pit_timer.pending, 0);\n\tpit->pit_state.irq_ack = 1;\n}\n\nstatic void pit_mask_notifer(struct kvm_irq_mask_notifier *kimn, bool mask)\n{\n\tstruct kvm_pit *pit = container_of(kimn, struct kvm_pit, mask_notifier);\n\n\tif (!mask) {\n\t\tatomic_set(&pit->pit_state.pit_timer.pending, 0);\n\t\tpit->pit_state.irq_ack = 1;\n\t}\n}\n\nstatic const struct kvm_io_device_ops pit_dev_ops = {\n\t.read     = pit_ioport_read,\n\t.write    = pit_ioport_write,\n};\n\nstatic const struct kvm_io_device_ops speaker_dev_ops = {\n\t.read     = speaker_ioport_read,\n\t.write    = speaker_ioport_write,\n};\n\n/* Caller must have writers lock on slots_lock */\nstruct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)\n{\n\tstruct kvm_pit *pit;\n\tstruct kvm_kpit_state *pit_state;\n\tint ret;\n\n\tpit = kzalloc(sizeof(struct kvm_pit), GFP_KERNEL);\n\tif (!pit)\n\t\treturn NULL;\n\n\tpit->irq_source_id = kvm_request_irq_source_id(kvm);\n\tif (pit->irq_source_id < 0) {\n\t\tkfree(pit);\n\t\treturn NULL;\n\t}\n\n\tmutex_init(&pit->pit_state.lock);\n\tmutex_lock(&pit->pit_state.lock);\n\tspin_lock_init(&pit->pit_state.inject_lock);\n\n\tkvm->arch.vpit = pit;\n\tpit->kvm = kvm;\n\n\tpit_state = &pit->pit_state;\n\tpit_state->pit = pit;\n\thrtimer_init(&pit_state->pit_timer.timer,\n\t\t     CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tpit_state->irq_ack_notifier.gsi = 0;\n\tpit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;\n\tkvm_register_irq_ack_notifier(kvm, &pit_state->irq_ack_notifier);\n\tpit_state->pit_timer.reinject = true;\n\tmutex_unlock(&pit->pit_state.lock);\n\n\tkvm_pit_reset(pit);\n\n\tpit->mask_notifier.func = pit_mask_notifer;\n\tkvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\n\tkvm_iodevice_init(&pit->dev, &pit_dev_ops);\n\tret = __kvm_io_bus_register_dev(&kvm->pio_bus, &pit->dev);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (flags & KVM_PIT_SPEAKER_DUMMY) {\n\t\tkvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops);\n\t\tret = __kvm_io_bus_register_dev(&kvm->pio_bus,\n\t\t\t\t\t\t&pit->speaker_dev);\n\t\tif (ret < 0)\n\t\t\tgoto fail_unregister;\n\t}\n\n\treturn pit;\n\nfail_unregister:\n\t__kvm_io_bus_unregister_dev(&kvm->pio_bus, &pit->dev);\n\nfail:\n\tif (pit->irq_source_id >= 0)\n\t\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\n\n\tkfree(pit);\n\treturn NULL;\n}\n\nvoid kvm_free_pit(struct kvm *kvm)\n{\n\tstruct hrtimer *timer;\n\n\tif (kvm->arch.vpit) {\n\t\tkvm_unregister_irq_mask_notifier(kvm, 0,\n\t\t\t\t\t       &kvm->arch.vpit->mask_notifier);\n\t\tkvm_unregister_irq_ack_notifier(kvm,\n\t\t\t\t&kvm->arch.vpit->pit_state.irq_ack_notifier);\n\t\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\t\ttimer = &kvm->arch.vpit->pit_state.pit_timer.timer;\n\t\thrtimer_cancel(timer);\n\t\tkvm_free_irq_source_id(kvm, kvm->arch.vpit->irq_source_id);\n\t\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\t\tkfree(kvm->arch.vpit);\n\t}\n}\n\nstatic void __inject_pit_timer_intr(struct kvm *kvm)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tkvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 1);\n\tkvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 0);\n\n\t/*\n\t * Provides NMI watchdog support via Virtual Wire mode.\n\t * The route is: PIT -> PIC -> LVT0 in NMI mode.\n\t *\n\t * Note: Our Virtual Wire implementation is simplified, only\n\t * propagating PIT interrupts to all VCPUs when they have set\n\t * LVT0 to NMI delivery. Other PIC interrupts are just sent to\n\t * VCPU0, and only if its LVT0 is in EXTINT mode.\n\t */\n\tif (kvm->arch.vapics_in_nmi_mode > 0)\n\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\tkvm_apic_nmi_wd_deliver(vcpu);\n}\n\nvoid kvm_inject_pit_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_kpit_state *ps;\n\n\tif (pit) {\n\t\tint inject = 0;\n\t\tps = &pit->pit_state;\n\n\t\t/* Try to inject pending interrupts when\n\t\t * last one has been acked.\n\t\t */\n\t\tspin_lock(&ps->inject_lock);\n\t\tif (atomic_read(&ps->pit_timer.pending) && ps->irq_ack) {\n\t\t\tps->irq_ack = 0;\n\t\t\tinject = 1;\n\t\t}\n\t\tspin_unlock(&ps->inject_lock);\n\t\tif (inject)\n\t\t\t__inject_pit_timer_intr(kvm);\n\t}\n}\n"], "fixing_code": ["/*\n * 8253/8254 interval timer emulation\n *\n * Copyright (c) 2003-2004 Fabrice Bellard\n * Copyright (c) 2006 Intel Corporation\n * Copyright (c) 2007 Keir Fraser, XenSource Inc\n * Copyright (c) 2008 Intel Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * Authors:\n *   Sheng Yang <sheng.yang@intel.com>\n *   Based on QEMU and Xen.\n */\n\n#define pr_fmt(fmt) \"pit: \" fmt\n\n#include <linux/kvm_host.h>\n\n#include \"irq.h\"\n#include \"i8254.h\"\n\n#ifndef CONFIG_X86_64\n#define mod_64(x, y) ((x) - (y) * div64_u64(x, y))\n#else\n#define mod_64(x, y) ((x) % (y))\n#endif\n\n#define RW_STATE_LSB 1\n#define RW_STATE_MSB 2\n#define RW_STATE_WORD0 3\n#define RW_STATE_WORD1 4\n\n/* Compute with 96 bit intermediate result: (a*b)/c */\nstatic u64 muldiv64(u64 a, u32 b, u32 c)\n{\n\tunion {\n\t\tu64 ll;\n\t\tstruct {\n\t\t\tu32 low, high;\n\t\t} l;\n\t} u, res;\n\tu64 rl, rh;\n\n\tu.ll = a;\n\trl = (u64)u.l.low * (u64)b;\n\trh = (u64)u.l.high * (u64)b;\n\trh += (rl >> 32);\n\tres.l.high = div64_u64(rh, c);\n\tres.l.low = div64_u64(((mod_64(rh, c) << 32) + (rl & 0xffffffff)), c);\n\treturn res.ll;\n}\n\nstatic void pit_set_gate(struct kvm *kvm, int channel, u32 val)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\tcase 4:\n\t\t/* XXX: just disable/enable counting */\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 5:\n\t\t/* Restart counting on rising edge. */\n\t\tif (c->gate < val)\n\t\t\tc->count_load_time = ktime_get();\n\t\tbreak;\n\t}\n\n\tc->gate = val;\n}\n\nstatic int pit_get_gate(struct kvm *kvm, int channel)\n{\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\treturn kvm->arch.vpit->pit_state.channels[channel].gate;\n}\n\nstatic s64 __kpit_elapsed(struct kvm *kvm)\n{\n\ts64 elapsed;\n\tktime_t remaining;\n\tstruct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;\n\n\tif (!ps->pit_timer.period)\n\t\treturn 0;\n\n\t/*\n\t * The Counter does not stop when it reaches zero. In\n\t * Modes 0, 1, 4, and 5 the Counter ``wraps around'' to\n\t * the highest count, either FFFF hex for binary counting\n\t * or 9999 for BCD counting, and continues counting.\n\t * Modes 2 and 3 are periodic; the Counter reloads\n\t * itself with the initial count and continues counting\n\t * from there.\n\t */\n\tremaining = hrtimer_get_remaining(&ps->pit_timer.timer);\n\telapsed = ps->pit_timer.period - ktime_to_ns(remaining);\n\telapsed = mod_64(elapsed, ps->pit_timer.period);\n\n\treturn elapsed;\n}\n\nstatic s64 kpit_elapsed(struct kvm *kvm, struct kvm_kpit_channel_state *c,\n\t\t\tint channel)\n{\n\tif (channel == 0)\n\t\treturn __kpit_elapsed(kvm);\n\n\treturn ktime_to_ns(ktime_sub(ktime_get(), c->count_load_time));\n}\n\nstatic int pit_get_count(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\ts64 d, t;\n\tint counter;\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tt = kpit_elapsed(kvm, c, channel);\n\td = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 4:\n\tcase 5:\n\t\tcounter = (c->count - d) & 0xffff;\n\t\tbreak;\n\tcase 3:\n\t\t/* XXX: may be incorrect for odd counts */\n\t\tcounter = c->count - (mod_64((2 * d), c->count));\n\t\tbreak;\n\tdefault:\n\t\tcounter = c->count - mod_64(d, c->count);\n\t\tbreak;\n\t}\n\treturn counter;\n}\n\nstatic int pit_get_out(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\ts64 d, t;\n\tint out;\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tt = kpit_elapsed(kvm, c, channel);\n\td = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\t\tout = (d >= c->count);\n\t\tbreak;\n\tcase 1:\n\t\tout = (d < c->count);\n\t\tbreak;\n\tcase 2:\n\t\tout = ((mod_64(d, c->count) == 0) && (d != 0));\n\t\tbreak;\n\tcase 3:\n\t\tout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tout = (d == c->count);\n\t\tbreak;\n\t}\n\n\treturn out;\n}\n\nstatic void pit_latch_count(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tif (!c->count_latched) {\n\t\tc->latched_count = pit_get_count(kvm, channel);\n\t\tc->count_latched = c->rw_mode;\n\t}\n}\n\nstatic void pit_latch_status(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tif (!c->status_latched) {\n\t\t/* TODO: Return NULL COUNT (bit 6). */\n\t\tc->status = ((pit_get_out(kvm, channel) << 7) |\n\t\t\t\t(c->rw_mode << 4) |\n\t\t\t\t(c->mode << 1) |\n\t\t\t\tc->bcd);\n\t\tc->status_latched = 1;\n\t}\n}\n\nint pit_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\n\tif (pit && kvm_vcpu_is_bsp(vcpu) && pit->pit_state.irq_ack)\n\t\treturn atomic_read(&pit->pit_state.pit_timer.pending);\n\treturn 0;\n}\n\nstatic void kvm_pit_ack_irq(struct kvm_irq_ack_notifier *kian)\n{\n\tstruct kvm_kpit_state *ps = container_of(kian, struct kvm_kpit_state,\n\t\t\t\t\t\t irq_ack_notifier);\n\tspin_lock(&ps->inject_lock);\n\tif (atomic_dec_return(&ps->pit_timer.pending) < 0)\n\t\tatomic_inc(&ps->pit_timer.pending);\n\tps->irq_ack = 1;\n\tspin_unlock(&ps->inject_lock);\n}\n\nvoid __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n\t\treturn;\n\n\ttimer = &pit->pit_state.pit_timer.timer;\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n}\n\nstatic void destroy_pit_timer(struct kvm_timer *pt)\n{\n\tpr_debug(\"execute del timer!\\n\");\n\thrtimer_cancel(&pt->timer);\n}\n\nstatic bool kpit_is_periodic(struct kvm_timer *ktimer)\n{\n\tstruct kvm_kpit_state *ps = container_of(ktimer, struct kvm_kpit_state,\n\t\t\t\t\t\t pit_timer);\n\treturn ps->is_periodic;\n}\n\nstatic struct kvm_timer_ops kpit_ops = {\n\t.is_periodic = kpit_is_periodic,\n};\n\nstatic void create_pit_timer(struct kvm_kpit_state *ps, u32 val, int is_period)\n{\n\tstruct kvm_timer *pt = &ps->pit_timer;\n\ts64 interval;\n\n\tinterval = muldiv64(val, NSEC_PER_SEC, KVM_PIT_FREQ);\n\n\tpr_debug(\"create pit timer, interval is %llu nsec\\n\", interval);\n\n\t/* TODO The new value only affected after the retriggered */\n\thrtimer_cancel(&pt->timer);\n\tpt->period = interval;\n\tps->is_periodic = is_period;\n\n\tpt->timer.function = kvm_timer_fn;\n\tpt->t_ops = &kpit_ops;\n\tpt->kvm = ps->pit->kvm;\n\tpt->vcpu = pt->kvm->bsp_vcpu;\n\n\tatomic_set(&pt->pending, 0);\n\tps->irq_ack = 1;\n\n\thrtimer_start(&pt->timer, ktime_add_ns(ktime_get(), interval),\n\t\t      HRTIMER_MODE_ABS);\n}\n\nstatic void pit_load_count(struct kvm *kvm, int channel, u32 val)\n{\n\tstruct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;\n\n\tWARN_ON(!mutex_is_locked(&ps->lock));\n\n\tpr_debug(\"load_count val is %d, channel is %d\\n\", val, channel);\n\n\t/*\n\t * The largest possible initial count is 0; this is equivalent\n\t * to 216 for binary counting and 104 for BCD counting.\n\t */\n\tif (val == 0)\n\t\tval = 0x10000;\n\n\tps->channels[channel].count = val;\n\n\tif (channel != 0) {\n\t\tps->channels[channel].count_load_time = ktime_get();\n\t\treturn;\n\t}\n\n\t/* Two types of timer\n\t * mode 1 is one shot, mode 2 is period, otherwise del timer */\n\tswitch (ps->channels[0].mode) {\n\tcase 0:\n\tcase 1:\n        /* FIXME: enhance mode 4 precision */\n\tcase 4:\n\t\tif (!(ps->flags & KVM_PIT_FLAGS_HPET_LEGACY)) {\n\t\t\tcreate_pit_timer(ps, val, 0);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tif (!(ps->flags & KVM_PIT_FLAGS_HPET_LEGACY)){\n\t\t\tcreate_pit_timer(ps, val, 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdestroy_pit_timer(&ps->pit_timer);\n\t}\n}\n\nvoid kvm_pit_load_count(struct kvm *kvm, int channel, u32 val, int hpet_legacy_start)\n{\n\tu8 saved_mode;\n\tif (hpet_legacy_start) {\n\t\t/* save existing mode for later reenablement */\n\t\tsaved_mode = kvm->arch.vpit->pit_state.channels[0].mode;\n\t\tkvm->arch.vpit->pit_state.channels[0].mode = 0xff; /* disable timer */\n\t\tpit_load_count(kvm, channel, val);\n\t\tkvm->arch.vpit->pit_state.channels[0].mode = saved_mode;\n\t} else {\n\t\tpit_load_count(kvm, channel, val);\n\t}\n}\n\nstatic inline struct kvm_pit *dev_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, dev);\n}\n\nstatic inline struct kvm_pit *speaker_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, speaker_dev);\n}\n\nstatic inline int pit_in_range(gpa_t addr)\n{\n\treturn ((addr >= KVM_PIT_BASE_ADDRESS) &&\n\t\t(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));\n}\n\nstatic int pit_ioport_write(struct kvm_io_device *this,\n\t\t\t    gpa_t addr, int len, const void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint channel, access;\n\tstruct kvm_kpit_channel_state *s;\n\tu32 val = *(u32 *) data;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tval  &= 0xff;\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\n\tmutex_lock(&pit_state->lock);\n\n\tif (val != 0)\n\t\tpr_debug(\"write addr is 0x%x, len is %d, val is 0x%x\\n\",\n\t\t\t (unsigned int)addr, len, val);\n\n\tif (addr == 3) {\n\t\tchannel = val >> 6;\n\t\tif (channel == 3) {\n\t\t\t/* Read-Back Command. */\n\t\t\tfor (channel = 0; channel < 3; channel++) {\n\t\t\t\ts = &pit_state->channels[channel];\n\t\t\t\tif (val & (2 << channel)) {\n\t\t\t\t\tif (!(val & 0x20))\n\t\t\t\t\t\tpit_latch_count(kvm, channel);\n\t\t\t\t\tif (!(val & 0x10))\n\t\t\t\t\t\tpit_latch_status(kvm, channel);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* Select Counter <channel>. */\n\t\t\ts = &pit_state->channels[channel];\n\t\t\taccess = (val >> 4) & KVM_PIT_CHANNEL_MASK;\n\t\t\tif (access == 0) {\n\t\t\t\tpit_latch_count(kvm, channel);\n\t\t\t} else {\n\t\t\t\ts->rw_mode = access;\n\t\t\t\ts->read_state = access;\n\t\t\t\ts->write_state = access;\n\t\t\t\ts->mode = (val >> 1) & 7;\n\t\t\t\tif (s->mode > 5)\n\t\t\t\t\ts->mode -= 4;\n\t\t\t\ts->bcd = val & 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Write Count. */\n\t\ts = &pit_state->channels[addr];\n\t\tswitch (s->write_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tpit_load_count(kvm, addr, val);\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tpit_load_count(kvm, addr, val << 8);\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\ts->write_latch = val;\n\t\t\ts->write_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tpit_load_count(kvm, addr, s->write_latch | (val << 8));\n\t\t\ts->write_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nstatic int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\tif (addr == 3)\n\t\treturn 0;\n\n\ts = &pit_state->channels[addr];\n\n\tmutex_lock(&pit_state->lock);\n\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nstatic int speaker_ioport_write(struct kvm_io_device *this,\n\t\t\t\tgpa_t addr, int len, const void *data)\n{\n\tstruct kvm_pit *pit = speaker_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tu32 val = *(u32 *) data;\n\tif (addr != KVM_SPEAKER_BASE_ADDRESS)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&pit_state->lock);\n\tpit_state->speaker_data_on = (val >> 1) & 1;\n\tpit_set_gate(kvm, 2, val & 1);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nstatic int speaker_ioport_read(struct kvm_io_device *this,\n\t\t\t       gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = speaker_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tunsigned int refresh_clock;\n\tint ret;\n\tif (addr != KVM_SPEAKER_BASE_ADDRESS)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Refresh clock toggles at about 15us. We approximate as 2^14ns. */\n\trefresh_clock = ((unsigned int)ktime_to_ns(ktime_get()) >> 14) & 1;\n\n\tmutex_lock(&pit_state->lock);\n\tret = ((pit_state->speaker_data_on << 1) | pit_get_gate(kvm, 2) |\n\t\t(pit_get_out(kvm, 2) << 5) | (refresh_clock << 4));\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nvoid kvm_pit_reset(struct kvm_pit *pit)\n{\n\tint i;\n\tstruct kvm_kpit_channel_state *c;\n\n\tmutex_lock(&pit->pit_state.lock);\n\tpit->pit_state.flags = 0;\n\tfor (i = 0; i < 3; i++) {\n\t\tc = &pit->pit_state.channels[i];\n\t\tc->mode = 0xff;\n\t\tc->gate = (i != 2);\n\t\tpit_load_count(pit->kvm, i, 0);\n\t}\n\tmutex_unlock(&pit->pit_state.lock);\n\n\tatomic_set(&pit->pit_state.pit_timer.pending, 0);\n\tpit->pit_state.irq_ack = 1;\n}\n\nstatic void pit_mask_notifer(struct kvm_irq_mask_notifier *kimn, bool mask)\n{\n\tstruct kvm_pit *pit = container_of(kimn, struct kvm_pit, mask_notifier);\n\n\tif (!mask) {\n\t\tatomic_set(&pit->pit_state.pit_timer.pending, 0);\n\t\tpit->pit_state.irq_ack = 1;\n\t}\n}\n\nstatic const struct kvm_io_device_ops pit_dev_ops = {\n\t.read     = pit_ioport_read,\n\t.write    = pit_ioport_write,\n};\n\nstatic const struct kvm_io_device_ops speaker_dev_ops = {\n\t.read     = speaker_ioport_read,\n\t.write    = speaker_ioport_write,\n};\n\n/* Caller must have writers lock on slots_lock */\nstruct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)\n{\n\tstruct kvm_pit *pit;\n\tstruct kvm_kpit_state *pit_state;\n\tint ret;\n\n\tpit = kzalloc(sizeof(struct kvm_pit), GFP_KERNEL);\n\tif (!pit)\n\t\treturn NULL;\n\n\tpit->irq_source_id = kvm_request_irq_source_id(kvm);\n\tif (pit->irq_source_id < 0) {\n\t\tkfree(pit);\n\t\treturn NULL;\n\t}\n\n\tmutex_init(&pit->pit_state.lock);\n\tmutex_lock(&pit->pit_state.lock);\n\tspin_lock_init(&pit->pit_state.inject_lock);\n\n\tkvm->arch.vpit = pit;\n\tpit->kvm = kvm;\n\n\tpit_state = &pit->pit_state;\n\tpit_state->pit = pit;\n\thrtimer_init(&pit_state->pit_timer.timer,\n\t\t     CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tpit_state->irq_ack_notifier.gsi = 0;\n\tpit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;\n\tkvm_register_irq_ack_notifier(kvm, &pit_state->irq_ack_notifier);\n\tpit_state->pit_timer.reinject = true;\n\tmutex_unlock(&pit->pit_state.lock);\n\n\tkvm_pit_reset(pit);\n\n\tpit->mask_notifier.func = pit_mask_notifer;\n\tkvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\n\tkvm_iodevice_init(&pit->dev, &pit_dev_ops);\n\tret = __kvm_io_bus_register_dev(&kvm->pio_bus, &pit->dev);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (flags & KVM_PIT_SPEAKER_DUMMY) {\n\t\tkvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops);\n\t\tret = __kvm_io_bus_register_dev(&kvm->pio_bus,\n\t\t\t\t\t\t&pit->speaker_dev);\n\t\tif (ret < 0)\n\t\t\tgoto fail_unregister;\n\t}\n\n\treturn pit;\n\nfail_unregister:\n\t__kvm_io_bus_unregister_dev(&kvm->pio_bus, &pit->dev);\n\nfail:\n\tif (pit->irq_source_id >= 0)\n\t\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\n\n\tkfree(pit);\n\treturn NULL;\n}\n\nvoid kvm_free_pit(struct kvm *kvm)\n{\n\tstruct hrtimer *timer;\n\n\tif (kvm->arch.vpit) {\n\t\tkvm_unregister_irq_mask_notifier(kvm, 0,\n\t\t\t\t\t       &kvm->arch.vpit->mask_notifier);\n\t\tkvm_unregister_irq_ack_notifier(kvm,\n\t\t\t\t&kvm->arch.vpit->pit_state.irq_ack_notifier);\n\t\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\t\ttimer = &kvm->arch.vpit->pit_state.pit_timer.timer;\n\t\thrtimer_cancel(timer);\n\t\tkvm_free_irq_source_id(kvm, kvm->arch.vpit->irq_source_id);\n\t\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\t\tkfree(kvm->arch.vpit);\n\t}\n}\n\nstatic void __inject_pit_timer_intr(struct kvm *kvm)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tkvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 1);\n\tkvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 0);\n\n\t/*\n\t * Provides NMI watchdog support via Virtual Wire mode.\n\t * The route is: PIT -> PIC -> LVT0 in NMI mode.\n\t *\n\t * Note: Our Virtual Wire implementation is simplified, only\n\t * propagating PIT interrupts to all VCPUs when they have set\n\t * LVT0 to NMI delivery. Other PIC interrupts are just sent to\n\t * VCPU0, and only if its LVT0 is in EXTINT mode.\n\t */\n\tif (kvm->arch.vapics_in_nmi_mode > 0)\n\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\tkvm_apic_nmi_wd_deliver(vcpu);\n}\n\nvoid kvm_inject_pit_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_kpit_state *ps;\n\n\tif (pit) {\n\t\tint inject = 0;\n\t\tps = &pit->pit_state;\n\n\t\t/* Try to inject pending interrupts when\n\t\t * last one has been acked.\n\t\t */\n\t\tspin_lock(&ps->inject_lock);\n\t\tif (atomic_read(&ps->pit_timer.pending) && ps->irq_ack) {\n\t\t\tps->irq_ack = 0;\n\t\t\tinject = 1;\n\t\t}\n\t\tspin_unlock(&ps->inject_lock);\n\t\tif (inject)\n\t\t\t__inject_pit_timer_intr(kvm);\n\t}\n}\n"], "filenames": ["arch/x86/kvm/i8254.c"], "buggy_code_start_loc": [469], "buggy_code_end_loc": [469], "fixing_code_start_loc": [470], "fixing_code_end_loc": [473], "type": "CWE-119", "message": "The pit_ioport_read in i8254.c in the Linux kernel before 2.6.33 and QEMU before 2.3.1 does not distinguish between read lengths and write lengths, which might allow guest OS users to execute arbitrary code on the host OS by triggering use of an invalid index.", "other": {"cve": {"id": "CVE-2015-3214", "sourceIdentifier": "secalert@redhat.com", "published": "2015-08-31T10:59:07.580", "lastModified": "2023-02-13T00:48:24.553", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The pit_ioport_read in i8254.c in the Linux kernel before 2.6.33 and QEMU before 2.3.1 does not distinguish between read lengths and write lengths, which might allow guest OS users to execute arbitrary code on the host OS by triggering use of an invalid index."}, {"lang": "es", "value": "Vulnerabilidad en pit_ioport_read en i8254.c en el kernel de Linux en versiones anteriores a 2.6.33 y en QEMU en versiones anteriores a 2.3.1, no distingue entre longitudes de lectura y longitudes de escritura, lo que podr\u00eda permitir a los usuarios invitados del SO ejecutar c\u00f3digo arbitrario en el host del SO desencadenando el uso de un \u00edndice no v\u00e1lido."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qemu:qemu:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.3.0", "matchCriteriaId": "ABF17A18-4BE8-41B7-B50C-F4A137B3B2F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.32", "matchCriteriaId": "4367A8B9-ABB9-4E4E-9A2A-85719CBE8DAC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:arista:eos:4.12:*:*:*:*:*:*:*", "matchCriteriaId": "FDDF9823-D999-41A4-BB7B-A63C00ACE11B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:arista:eos:4.13:*:*:*:*:*:*:*", "matchCriteriaId": "51F7426A-46F7-4BE0-806F-F4598C8B0426"}, {"vulnerable": true, "criteria": "cpe:2.3:o:arista:eos:4.14:*:*:*:*:*:*:*", "matchCriteriaId": "E7F71EBA-27AC-464B-8708-4E8971BC75A7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:arista:eos:4.15:*:*:*:*:*:*:*", "matchCriteriaId": "8705CF80-DEFC-4425-8E23-D98FFD678157"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:lenovo:emc_px12-400r_ivx:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.10.33264", "matchCriteriaId": "19E383C6-5DB4-4D42-BC8E-70CEA527FAEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:lenovo:emc_px12-450r_ivx:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.10.33264", "matchCriteriaId": "811FD71F-FC60-478B-B257-A7019AE6F88A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "B152EDF3-3140-4343-802F-F4F1C329F5C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "31EC146C-A6F6-4C0D-AF87-685286262DAA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:virtualization:3.0:*:*:*:*:*:*:*", "matchCriteriaId": "D86166F9-BBF0-4650-8CCD-0F9C97104D21"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_compute_node_eus:7.1:*:*:*:*:*:*:*", "matchCriteriaId": "9835B192-FE11-4FB6-B1D8-C47530A46014"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_compute_node_eus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "19F5A4C6-E90F-4B33-8B28-D57FC36E3866"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_compute_node_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "39E542B7-500F-4B9E-B712-886C593525E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_compute_node_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D9F97AEB-F4DB-4F1F-A69C-5EF8CBBFAFE6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_compute_node_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "D0C69E57-48DE-467F-8ADD-B4601CE1611E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_compute_node_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "35A9FD70-E9CA-43AF-A453-E41EAB430E7F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_compute_node_eus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "742A198F-D40F-4B32-BB9C-C5EF5B09C3E7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_big_endian:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "1CDCFF34-6F1D-45A1-BE37-6A0E17B04801"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_big_endian_eus:7.1_ppc64:*:*:*:*:*:*:*", "matchCriteriaId": "5B6ED0AA-CD87-47A5-8E82-C9C7BD14F1AE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_big_endian_eus:7.2_ppc64:*:*:*:*:*:*:*", "matchCriteriaId": "8E5B5F9E-D749-45E5-8538-7CED9620C00C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_big_endian_eus:7.3_ppc64:*:*:*:*:*:*:*", "matchCriteriaId": "188019BF-3700-4B3F-BFA5-553B2B545B7F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_big_endian_eus:7.4_ppc64:*:*:*:*:*:*:*", "matchCriteriaId": "9B8B2E32-B838-4E51-BAA2-764089D2A684"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_big_endian_eus:7.5_ppc64:*:*:*:*:*:*:*", "matchCriteriaId": "4319B943-7B19-468D-A160-5895F7F997A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_big_endian_eus:7.6_ppc64:*:*:*:*:*:*:*", "matchCriteriaId": "39C1ABF5-4070-4AA7-BAB8-4F63E1BD91FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_big_endian_eus:7.7_ppc64:*:*:*:*:*:*:*", "matchCriteriaId": "8036E2AE-4E44-4FA5-AFFB-A3724BFDD654"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_scientific_computing:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "37CE1DC7-72C5-483C-8921-0B462C8284D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "98381E61-F082-4302-B51F-5648884F998B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "7431ABC1-9252-419E-8CC1-311B41360078"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.1:*:*:*:*:*:*:*", "matchCriteriaId": "0E8CD4EF-DC90-40BB-A721-6EC087507906"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "44B067C7-735E-43C9-9188-7E1522A02491"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "A8442C20-41F9-47FD-9A12-E724D3A31FD7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "9EC0D196-F7B8-4BDD-9050-779F7A7FBEE4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "21690BAC-2129-4A33-9B48-1F3BF30072A9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_from_rhui:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "F732C7C9-A9CC-4DEF-A8BE-D0F18C944C78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "24C0F4E1-C52C-41E0-9F14-F83ADD5CC7ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "17F256A9-D3B9-4C72-B013-4EFD878BFEA8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_update_services_for_sap_solutions:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "55DF5F02-550E-41E0-86A3-862F2785270C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_update_services_for_sap_solutions:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "AA5F8426-5EEB-4013-BE49-8E705DA140B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_update_services_for_sap_solutions:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "8C7E9628-0915-4C49-8929-F5E060A20CBB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_update_services_for_sap_solutions:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "5C450C83-695F-4408-8B4F-0E7D6DDAE345"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_update_services_for_sap_solutions:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "3707B08D-8A78-48CB-914C-33A753D13FC7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ee73f656a604d5aa9df86a97102e4e462dd79924", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://mirror.linux.org.au/linux/kernel/v2.6/ChangeLog-2.6.33", "source": "secalert@redhat.com", "tags": ["Broken Link", "Vendor Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-1507.html", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-1508.html", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-1512.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2015/dsa-3348", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/06/25/7", "source": "secalert@redhat.com", "tags": ["Mailing List"]}, {"url": "http://www.securityfocus.com/bid/75273", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1032598", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1229640", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/ee73f656a604d5aa9df86a97102e4e462dd79924", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201510-02", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://support.lenovo.com/product_security/qemu", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://support.lenovo.com/us/en/product_security/qemu", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.arista.com/en/support/advisories-notices/security-advisories/1180-security-advisory-13", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/37990/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://www.mail-archive.com/qemu-devel%40nongnu.org/msg304138.html", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/ee73f656a604d5aa9df86a97102e4e462dd79924"}}