{"buggy_code": ["# sqldump\n\nA small tool for assisting in administration of databases. My first 48 hours in Golang.\n\nUnfortunately I do not have that much time, so it's just close to the backend with some basic html. \nUse your fantasy for best UX and choose high levels of abstraction and imagination for fancy output with latest js-technology. \n\n## prepare\n\n    sudo mysqladmin --defaults-file=/etc/mysql/debian.cnf create gotestdb\n    sudo mysql --defaults-file=/etc/mysql/debian.cnf -e \"GRANT ALL PRIVILEGES  ON gotestdb.*  TO 'go_user'@'localhost' IDENTIFIED BY 'mypassword'  WITH GRANT OPTION;\"\n    mysql -p\"mypassword\" -u go_user gotestdb -e 'create table posts (title varchar(64) default null, start date default null);'\n    mysql -p\"mypassword\" -u go_user gotestdb -e 'insert into posts values(\"hello\",\"2015-01-01\");'\n    mysql -p\"mypassword\" -u go_user gotestdb -e 'insert into posts values(\"more\",\"2015-01-03\");'\n    mysql -p\"mypassword\" -u go_user gotestdb -e 'insert into posts values(\"end\",\"2015-01-23\");'\n    mysql -p\"mypassword\" -u go_user gotestdb -B -e 'select * from posts;'\n\n## install\n\n    export GOPATH=$PWD\n    git clone https://github.com/gophergala/sqldump .\n    go get github.com/go-sql-driver/mysql\n    go get github.com/gorilla/securecookie\n\n## run\n\n    go run sqldump.go auth.go dump.go aux.go\n\n## usage\n\n[http://localhost:8080](http://localhost:8080)\n\n## caveats\n\n- A database named 'favicon.ico' can't be accessed\n- restriction on names of databases, tables, columns \n- basic protection against sql injection via URI\n\n## perspectives\n\n. output in tables\n- choice for different database drivers\n- insert and edit records\n\n\n", "/* no Credentials management needed\n * Credentials are stored at user side using secure cookies\n *\n * credits:\n * http://www.mschoebel.info/2014/03/09/snippet-golang-webapp-login-logout.html\n */\n\npackage main\n\nimport (\n\t\"github.com/gorilla/securecookie\"\n\t\"net/http\"\n)\n\nvar cookieHandler = securecookie.New(\n\tsecurecookie.GenerateRandomKey(64),\n\tsecurecookie.GenerateRandomKey(32))\n\nfunc getCredentials(request *http.Request) (userName string, password string) {\n\tif cookie, err := request.Cookie(\"Credentials\"); err == nil {\n\t\tcookieValue := make(map[string]string)\n\t\tif err = cookieHandler.Decode(\"Credentials\", cookie.Value, &cookieValue); err == nil {\n\t\t\tuserName = cookieValue[\"user\"]\n\t\t\tpassword = cookieValue[\"passwd\"]\n\t\t}\n\t}\n\treturn userName, password\n}\n\nfunc setCredentials(userName string, pw string, w http.ResponseWriter) {\n\tvalue := map[string]string{\n\t\t\"user\":   userName,\n\t\t\"passwd\": pw,\n\t}\n\tif encoded, err := cookieHandler.Encode(\"Credentials\", value); err == nil {\n\t\tcookie := &http.Cookie{\n\t\t\tName:  \"Credentials\",\n\t\t\tValue: encoded,\n\t\t\tPath:  \"/\",\n\t\t}\n\t\thttp.SetCookie(w, cookie)\n\t}\n}\n\nfunc clearCredentials(w http.ResponseWriter) {\n\tcookie := &http.Cookie{\n\t\tName:   \"Credentials\",\n\t\tValue:  \"\",\n\t\tPath:   \"/\",\n\t\tMaxAge: -1,\n\t}\n\thttp.SetCookie(w, cookie)\n}\n\nfunc loginHandler(w http.ResponseWriter, request *http.Request) {\n\tuser := request.FormValue(\"user\")\n\tpass := request.FormValue(\"password\")\n\tif user != \"\" && pass != \"\" {\n\t\tsetCredentials(user, pass, w)\n\t}\n\thttp.Redirect(w, request, \"/\", 302)\n}\n\nfunc logoutHandler(w http.ResponseWriter, request *http.Request) {\n\tclearCredentials(w)\n\thttp.Redirect(w, request, \"/\", 302)\n}\n\nconst loginPage = `\n<h1>Login</h1>\n<form method=\"post\" action=\"/login\">\n   <label for=\"user\">User name</label><input type=\"text\" id=\"user\" name=\"user\">\n   <label for=\"password\">Password</label><input type=\"password\" id=\"password\" name=\"password\">\n   <button type=\"submit\">Login</button>\n</form>\n`\n", "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n)\n\n// simple error checker\nfunc checkY(err error) {\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n}\n\n// will create a link into one level deeper\nfunc linkDeeper(cwd string, link string, name string) string {\n\treturn \"<a href=\\\"\" + cwd + \"/\" + link + \"\\\">\" + name + \"</a>\"\n}\n\n// Compose dataSourceName from components and globals\nfunc dsn(user string, pw string, db string) string {\n\treturn user + \":\" + pw + \"@tcp(\" + host + \":\" + port + \")/\" + db\n}\n\n// Converts an URL into an array of strings\nfunc url2array(r *http.Request) []string {\n\tpath := r.URL.Path\n\tpath = strings.TrimSpace(path)\n\tif strings.HasPrefix(path, \"/\") {\n\t\tpath = path[1:]\n\t}\n\tif strings.HasSuffix(path, \"/\") {\n\t\tpath = path[:len(path)-1]\n\t}\n\treturn strings.Split(path, \"/\")\n}\n", "package main\n\n/* TODO\n * turn into generic functions\n */\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Shows selection of databases at top level\nfunc home(w http.ResponseWriter, r *http.Request) {\n\n\tuser, pw := getCredentials(r)\n\tconn, err := sql.Open(\"mysql\", dsn(user, pw, database))\n\tcheckY(err)\n\tdefer conn.Close()\n\n\tstatement, err := conn.Prepare(\"show databases\")\n\tcheckY(err)\n\n\trows, err := statement.Query()\n\tcheckY(err)\n\tdefer rows.Close()\n\n\tvar n int = 1\n\tfor rows.Next() {\n\t\tvar field string\n\t\trows.Scan(&field)\n\t\tfmt.Fprint(w, linkDeeper(\"\", field, \"DB[\"+strconv.Itoa(n)+\"]\"))\n\t\tfmt.Fprintln(w, \" \", field, \"<br>\")\n\t\tn = n + 1\n\t}\n}\n\n//  Dump all tables of a database\nfunc dumpdb(w http.ResponseWriter, r *http.Request, parray []string) {\n\n\tuser, pw := getCredentials(r)\n\tdatabase := parray[0]\n\tconn, err := sql.Open(\"mysql\", dsn(user, pw, database))\n\tcheckY(err)\n\tdefer conn.Close()\n\n\tstatement, err := conn.Prepare(\"show tables\")\n\tcheckY(err)\n\n\trows, err := statement.Query()\n\tcheckY(err)\n\tdefer rows.Close()\n\n\tvar n int = 1\n\tfor rows.Next() {\n\t\tvar field string\n\t\trows.Scan(&field)\n\t\tfmt.Fprint(w, linkDeeper(r.URL.Path, field, \"T[\"+strconv.Itoa(n)+\"]\"))\n\t\tfmt.Fprintln(w, \"  \", field, \"<br>\")\n\t\tn = n + 1\n\t}\n}\n\n//  Dump all records of a table, one per line\nfunc dumptable(w http.ResponseWriter, r *http.Request, parray []string) {\n\n\tuser, pw := getCredentials(r)\n\tdatabase := parray[0]\n\ttable := parray[1]\n\n\tconn, err := sql.Open(\"mysql\", dsn(user, pw, database))\n\tcheckY(err)\n\tdefer conn.Close()\n\n\tstatement, err := conn.Prepare(\"select * from ?\")\n\tcheckY(err)\n\n\trows, err := statement.Query(table)\n\tcheckY(err)\n\tdefer rows.Close()\n\n\tcols, err := rows.Columns()\n\tcheckY(err)\n\tfmt.Fprintln(w, \"<p>\"+\"# \"+strings.Join(cols, \" \")+\"</p>\")\n\n\t/*  credits:\n\t * \thttp://stackoverflow.com/questions/19991541/dumping-mysql-tables-to-json-with-golang\n\t * \thttp://go-database-sql.org/varcols.html\n\t */\n\n\traw := make([]interface{}, len(cols))\n\tval := make([]interface{}, len(cols))\n\n\tfor i := range val {\n\t\traw[i] = &val[i]\n\t}\n\n\tvar n int = 1\n\tfor rows.Next() {\n\n\t\tfmt.Fprint(w, linkDeeper(r.URL.Path, strconv.Itoa(n), strconv.Itoa(n)))\n\t\terr = rows.Scan(raw...)\n\t\tcheckY(err)\n\n\t\tfor _, col := range val {\n\t\t\tif col != nil {\n\t\t\t\tfmt.Fprintf(w, \"%s \", string(col.([]byte)))\n\t\t\t}\n\t\t}\n\t\tfmt.Fprintln(w, \"<br>\")\n\t\tn = n + 1\n\t}\n}\n\n// Dump all fields of a record, one column per line\nfunc dumprecord(w http.ResponseWriter, r *http.Request, parray []string) {\n\n\tdatabase := parray[0]\n\ttable := parray[1]\n\trec, err := strconv.Atoi(parray[2])\n\tcheckY(err)\n\n\tuser, pw := getCredentials(r)\n\tconn, err := sql.Open(\"mysql\", dsn(user, pw, database))\n\tcheckY(err)\n\tdefer conn.Close()\n\n\tstatement, err := conn.Prepare(\"select * from ?\")\n\tcheckY(err)\n\n\trows, err := statement.Query(table)\n\tcheckY(err)\n\tdefer rows.Close()\n\n\tcolumns, err := rows.Columns()\n\tcheckY(err)\n\n\traw := make([]interface{}, len(columns))\n\tval := make([]interface{}, len(columns))\n\n\tfor i := range val {\n\t\traw[i] = &val[i]\n\t}\n\n\tvar n int = 1\n\nrowLoop:\n\tfor rows.Next() {\n\n\t\t// unfortunately we have to iterate up to row of interest\n\t\tif n == rec {\n\t\t\terr = rows.Scan(raw...)\n\t\t\tcheckY(err)\n\n\t\t\tfmt.Fprintln(w, \"<p>\")\n\t\t\tfor i, col := range val {\n\t\t\t\tif col != nil {\n\t\t\t\t\tfmt.Fprintln(w, columns[i], \":\", string(col.([]byte)), \"<br>\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tfmt.Fprintln(w, \"</p>\")\n\t\t\tbreak rowLoop\n\t\t}\n\t\tn = n + 1\n\t}\n}\n", "package main\n\nimport (\n\t\"fmt\"\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"net/http\"\n)\n\nvar base_url = \"http://localhost\"\nvar host = \"localhost\"\nvar port = \"3306\"\nvar database = \"information_schema\"\n\nfunc faviconHandler(w http.ResponseWriter, r *http.Request) {\n\thttp.StatusText(404)\n}\n\nfunc loginPageHandler(w http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(w, loginPage)\n}\n\nfunc pathHandler(w http.ResponseWriter, r *http.Request) {\n\n\tif r.URL.Path == \"/\" {\n\t\thome(w, r)\n\t} else {\n\t\tparray := url2array(r)\n\n\t\tswitch len(parray) {\n\t\tcase 1:\n\t\t\tdumpdb(w, r, parray)\n\t\tcase 2:\n\t\t\tdumptable(w, r, parray)\n\t\tcase 3:\n\t\t\tdumprecord(w, r, parray)\n\t\t}\n\t}\n}\n\nfunc indexHandler(w http.ResponseWriter, r *http.Request) {\n\tu, _ := getCredentials(r)\n\n\tif u != \"\" {\n\t\tfmt.Fprintln(w, \"<h1>\", u, \"</h1>\")\n\t\tpathHandler(w, r)\n\t} else {\n\t\tloginPageHandler(w, r)\n\t}\n}\n\nfunc main() {\n\n\thttp.HandleFunc(\"/favicon.ico\", faviconHandler)\n\thttp.HandleFunc(\"/login\", loginHandler)\n\thttp.HandleFunc(\"/logout\", logoutHandler)\n\thttp.HandleFunc(\"/\", indexHandler)\n\n\tfmt.Println(\"Listening at localhost:8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}\n"], "fixing_code": ["# sqldump\n\nA small tool for assisting in administration of databases. My first 48 hours in Golang.\n\nUnfortunately I do not have that much time, so it's just close to the backend with some basic html. \nUse your fantasy for best UX and choose high levels of abstraction and imagination for fancy output with latest js-technology. \n\n## prepare\n\n    sudo mysqladmin --defaults-file=/etc/mysql/debian.cnf create galadb\n    sudo mysql --defaults-file=/etc/mysql/debian.cnf -e \"GRANT ALL PRIVILEGES  ON galadb.*  TO 'galagopher'@'localhost' IDENTIFIED BY 'mypassword'  WITH GRANT OPTION;\"\n    mysql -p\"mypassword\" -u galagopher galadb -e 'create table posts (title varchar(64) default null, start date default null);'\n    mysql -p\"mypassword\" -u galagopher galadb -e 'insert into posts values(\"hello\",\"2015-01-01\");'\n    mysql -p\"mypassword\" -u galagopher galadb -e 'insert into posts values(\"more\",\"2015-01-03\");'\n    mysql -p\"mypassword\" -u galagopher galadb -e 'insert into posts values(\"end\",\"2015-01-23\");'\n    mysql -p\"mypassword\" -u galagopher galadb -B -e 'select * from posts;'\n\n## install\n\n    export GOPATH=$PWD\n    git clone https://github.com/gophergala/sqldump .\n    go get github.com/go-sql-driver/mysql\n    go get github.com/gorilla/securecookie\n\n## run\n\n    go run sqldump.go auth.go dump.go aux.go\n\n## usage\n\n[http://localhost:8080](http://localhost:8080)\n\n## caveats\n\n- A database named 'favicon.ico' can't be accessed\n- restriction on names of databases, tables, columns \n- basic protection against sql injection via URI\n\n## perspectives\n\n- output in tables\n- menu line\n- choice for different database drivers\n- insert and edit records\n\n\n", "/* no session management needed\n * Credentials are stored at user side using secure cookies\n *\n * credits:\n * http://www.mschoebel.info/2014/03/09/snippet-golang-webapp-login-logout.html\n */\n\npackage main\n\nimport (\n\t\"github.com/gorilla/securecookie\"\n\t\"net/http\"\n)\n\nvar cookieHandler = securecookie.New(\n\tsecurecookie.GenerateRandomKey(64),\n\tsecurecookie.GenerateRandomKey(32))\n\nfunc getCredentials(request *http.Request) (userName string, password string, host string, port string) {\n\tif cookie, err := request.Cookie(\"Datasource\"); err == nil {\n\t\tcookieValue := make(map[string]string)\n\t\tif err = cookieHandler.Decode(\"Datasource\", cookie.Value, &cookieValue); err == nil {\n\t\t\tuserName = cookieValue[\"user\"]\n\t\t\tpassword = cookieValue[\"passwd\"]\n\t\t\thost = cookieValue[\"host\"]\n\t\t\tport = cookieValue[\"port\"]\n\t\t}\n\t}\n\treturn userName, password, host, port\n}\n\nfunc setCredentials( w http.ResponseWriter, userName string, pw string, host string, port string) {\n\tvalue := map[string]string{\n\t\t\"user\":   userName,\n\t\t\"passwd\": pw,\n\t\t\"host\": host,\n\t\t\"port\": port,\n\t}\n\tif encoded, err := cookieHandler.Encode(\"Datasource\", value); err == nil {\n\t\tcookie := &http.Cookie{\n\t\t\tName:  \"Datasource\",\n\t\t\tValue: encoded,\n\t\t\tPath:  \"/\",\n\t\t}\n\t\thttp.SetCookie(w, cookie)\n\t}\n}\n\nfunc clearCredentials(w http.ResponseWriter) {\n\tcookie := &http.Cookie{\n\t\tName:   \"Datasource\",\n\t\tValue:  \"\",\n\t\tPath:   \"/\",\n\t\tMaxAge: -1,\n\t}\n\thttp.SetCookie(w, cookie)\n}\n\nfunc loginHandler(w http.ResponseWriter, request *http.Request) {\n\tuser := request.FormValue(\"user\")\n\tpass := request.FormValue(\"password\")\n\thost := request.FormValue(\"host\")\n\tport := request.FormValue(\"port\")\n\tif user != \"\" && pass != \"\" {\n\t\tsetCredentials(w, user, pass, host, port)\n\t}\n\thttp.Redirect(w, request, \"/\", 302)\n}\n\nfunc logoutHandler(w http.ResponseWriter, request *http.Request) {\n\tclearCredentials(w)\n\thttp.Redirect(w, request, \"/\", 302)\n}\n\nconst loginPage = `\n<h1>Login</h1>\n<form method=\"post\" action=\"/login\">\n   <label for=\"user\">User name</label><input type=\"text\" id=\"user\" name=\"user\"><br>\n   <label for=\"password\">Password</label><input type=\"password\" id=\"password\" name=\"password\"><br>\n   <label for=\"host\">Host</label><input type=\"text\" id=\"host\" name=\"host\" value=\"localhost\"><br>\n   <label for=\"port\">Port</label><input type=\"text\" id=\"port\" name=\"port\" value=\"3306\"><br>\n   <button type=\"submit\">Login</button>\n</form>\n`\n", "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n)\n\n// simple error checker\nfunc checkY(err error) {\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n}\n\n// will create a link into one level deeper\nfunc linkDeeper(cwd string, link string, name string) string {\n\treturn \"<a href=\\\"\" + cwd + \"/\" + link + \"\\\">\" + name + \"</a>\"\n}\n\n// Compose dataSourceName from components and globals\nfunc dsn(user string, pw string, host string, port string, db string) string {\n\treturn user + \":\" + pw + \"@tcp(\" + host + \":\" + port + \")/\" + db\n}\n\n// Converts an URL into an array of strings\nfunc url2array(r *http.Request) []string {\n\tpath := r.URL.Path\n\tpath = strings.TrimSpace(path)\n\tif strings.HasPrefix(path, \"/\") {\n\t\tpath = path[1:]\n\t}\n\tif strings.HasSuffix(path, \"/\") {\n\t\tpath = path[:len(path)-1]\n\t}\n\treturn strings.Split(path, \"/\")\n}\n", "package main\n\n/* TODO\n * turn into more generic functions for printing into tables\n */\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"text/template\"\n)\n\n// Shows selection of databases at top level\nfunc home(w http.ResponseWriter, r *http.Request) {\n\n\tuser, pw, h , p := getCredentials(r)\n\tconn, err := sql.Open(\"mysql\", dsn(user, pw, h, p, database))\n\tcheckY(err)\n\tdefer conn.Close()\n\n\tstatement, err := conn.Prepare(\"show databases\")\n\tcheckY(err)\n\n\trows, err := statement.Query()\n\tcheckY(err)\n\tdefer rows.Close()\n\n\tvar n int = 1\n\tfor rows.Next() {\n\t\tvar field string\n\t\trows.Scan(&field)\n\t\tfmt.Fprint(w, linkDeeper(\"\", field, \"DB[\"+strconv.Itoa(n)+\"]\"))\n\t\tfmt.Fprintln(w, \" \", field, \"<br>\")\n\t\tn = n + 1\n\t}\n}\n\n//  Dump all tables of a database\nfunc dumpdb(w http.ResponseWriter, r *http.Request, parray []string) {\n\n\tuser, pw, h, p := getCredentials(r)\n\tdatabase := parray[0]\n\tconn, err := sql.Open(\"mysql\", dsn(user, pw, h, p, database))\n\tcheckY(err)\n\tdefer conn.Close()\n\n\tstatement, err := conn.Prepare(\"show tables\")\n\tcheckY(err)\n\n\trows, err := statement.Query()\n\tcheckY(err)\n\tdefer rows.Close()\n\n\tvar n int = 1\n\tfor rows.Next() {\n\t\tvar field string\n\t\trows.Scan(&field)\n\t\tfmt.Fprint(w, linkDeeper(r.URL.Path, field, \"T[\"+strconv.Itoa(n)+\"]\"))\n\t\tfmt.Fprintln(w, \"  \", field, \"<br>\")\n\t\tn = n + 1\n\t}\n}\n\n//  Dump all records of a table, one per line\nfunc dumptable(w http.ResponseWriter, r *http.Request, parray []string) {\n\n\tuser, pw, h, p := getCredentials(r)\n\tdatabase := parray[0]\n\ttable := parray[1]\n\n\tconn, err := sql.Open(\"mysql\", dsn(user, pw, h, p, database))\n\tcheckY(err)\n\tdefer conn.Close()\n\n\tstatement, err := conn.Prepare(\"select * from \" + template.HTMLEscapeString(table))\n\tcheckY(err)\n\n\trows, err := statement.Query()\n\tcheckY(err)\n\tdefer rows.Close()\n\n\tcols, err := rows.Columns()\n\tcheckY(err)\n\tfmt.Fprintln(w, \"<p>\"+\"# \"+strings.Join(cols, \" \")+\"</p>\")\n\n\t/*  credits:\n\t * \thttp://stackoverflow.com/questions/19991541/dumping-mysql-tables-to-json-with-golang\n\t * \thttp://go-database-sql.org/varcols.html\n\t */\n\n\traw := make([]interface{}, len(cols))\n\tval := make([]interface{}, len(cols))\n\n\tfor i := range val {\n\t\traw[i] = &val[i]\n\t}\n\n\tvar n int = 1\n\tfor rows.Next() {\n\n\t\tfmt.Fprint(w, linkDeeper(r.URL.Path, strconv.Itoa(n), strconv.Itoa(n)))\n\t\terr = rows.Scan(raw...)\n\t\tcheckY(err)\n\n\t\tfor _, col := range val {\n\t\t\tif col != nil {\n\t\t\t\tfmt.Fprintf(w, \"%s \", string(col.([]byte)))\n\t\t\t}\n\t\t}\n\t\tfmt.Fprintln(w, \"<br>\")\n\t\tn = n + 1\n\t}\n}\n\n// Dump all fields of a record, one column per line\nfunc dumprecord(w http.ResponseWriter, r *http.Request, parray []string) {\n\n\tdatabase := parray[0]\n\ttable := parray[1]\n\trec, err := strconv.Atoi(parray[2])\n\tcheckY(err)\n\n\tuser, pw, h, p := getCredentials(r)\n\tconn, err := sql.Open(\"mysql\", dsn(user, pw, h, p, database))\n\tcheckY(err)\n\tdefer conn.Close()\n\n\tstatement, err := conn.Prepare(\"select * from \" + template.HTMLEscapeString(table))\n\tcheckY(err)\n\n\trows, err := statement.Query()\n\tcheckY(err)\n\tdefer rows.Close()\n\n\tcolumns, err := rows.Columns()\n\tcheckY(err)\n\n\traw := make([]interface{}, len(columns))\n\tval := make([]interface{}, len(columns))\n\n\tfor i := range val {\n\t\traw[i] = &val[i]\n\t}\n\n\tvar n int = 1\n\nrowLoop:\n\tfor rows.Next() {\n\n\t\t// unfortunately we have to iterate up to row of interest\n\t\tif n == rec {\n\t\t\terr = rows.Scan(raw...)\n\t\t\tcheckY(err)\n\n\t\t\tfmt.Fprintln(w, \"<p>\")\n\t\t\tfor i, col := range val {\n\t\t\t\tif col != nil {\n\t\t\t\t\tfmt.Fprintln(w, columns[i], \":\", string(col.([]byte)), \"<br>\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tfmt.Fprintln(w, \"</p>\")\n\t\t\tbreak rowLoop\n\t\t}\n\t\tn = n + 1\n\t}\n}\n", "package main\n\nimport (\n\t\"fmt\"\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"net/http\"\n)\n\nvar base_url = \"http://localhost\"\nvar database = \"information_schema\"\n\nfunc faviconHandler(w http.ResponseWriter, r *http.Request) {\n\thttp.StatusText(404)\n}\n\nfunc loginPageHandler(w http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(w, loginPage)\n}\n\nfunc pathHandler(w http.ResponseWriter, r *http.Request) {\n\n\tif r.URL.Path == \"/\" {\n\t\thome(w, r)\n\t} else {\n\t\tparray := url2array(r)\n\n\t\tswitch len(parray) {\n\t\tcase 1:\n\t\t\tdumpdb(w, r, parray)\n\t\tcase 2:\n\t\t\tdumptable(w, r, parray)\n\t\tcase 3:\n\t\t\tdumprecord(w, r, parray)\n\t\t}\n\t}\n}\n\nfunc indexHandler(w http.ResponseWriter, r *http.Request) {\n\tuser , _ , host , port := getCredentials(r)\n\n\tif user != \"\" {\n\t\tfmt.Fprintln(w, \"<p>\", user + \"@\" + host + \":\" + port, \"</p>\")\n\t\tpathHandler(w, r)\n\t} else {\n\t\tloginPageHandler(w, r)\n\t}\n}\n\nfunc main() {\n\n\thttp.HandleFunc(\"/favicon.ico\", faviconHandler)\n\thttp.HandleFunc(\"/login\", loginHandler)\n\thttp.HandleFunc(\"/logout\", logoutHandler)\n\thttp.HandleFunc(\"/\", indexHandler)\n\n\tfmt.Println(\"Listening at localhost:8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}\n"], "filenames": ["README.md", "auth.go", "aux.go", "dump.go", "sqldump.go"], "buggy_code_start_loc": [10, 1, 24, 4, 10], "buggy_code_end_loc": [42, 74, 25, 135, 45], "fixing_code_start_loc": [10, 1, 24, 4, 9], "fixing_code_end_loc": [43, 82, 25, 136, 43], "type": "CWE-89", "message": "A vulnerability classified as critical was found in gophergala sqldump. This vulnerability affects unknown code. The manipulation leads to sql injection. The name of the patch is 76db54e9073b5248b8863e71a63d66a32d567d21. It is recommended to apply a patch to fix this issue. VDB-218350 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2015-10044", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-15T10:15:08.913", "lastModified": "2023-01-24T14:47:07.033", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as critical was found in gophergala sqldump. This vulnerability affects unknown code. The manipulation leads to sql injection. The name of the patch is 76db54e9073b5248b8863e71a63d66a32d567d21. It is recommended to apply a patch to fix this issue. VDB-218350 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sqldump_project:sqldump:*:*:*:*:*:*:*:*", "versionEndExcluding": "2015-01-24", "matchCriteriaId": "0F6AC665-8DCF-48F5-9226-0AB86C0374CB"}]}]}], "references": [{"url": "https://github.com/gophergala/sqldump/commit/76db54e9073b5248b8863e71a63d66a32d567d21", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218350", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.218350", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gophergala/sqldump/commit/76db54e9073b5248b8863e71a63d66a32d567d21"}}