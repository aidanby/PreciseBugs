{"buggy_code": ["/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2009,2018-2019 Free Software Foundation, Inc.              */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * bits.c: low level read and write functions\n * written by Felipe Castro\n * modified by Felipe Corr\u00eaa da Silva Sances\n * modified by Rodrigo Rodrigues da Silva\n * modified by James Mike Dupont\n * modified by Reini Urban\n */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdint.h>\n#include <inttypes.h>\n#if defined(HAVE_WCHAR_H) && defined(SIZEOF_WCHAR_T) && SIZEOF_WCHAR_T == 2\n#  include <wchar.h>\n#endif\n// else we roll our own, Latin-1 only.\n\n#ifdef DWG_ABORT\nstatic unsigned int errors = 0;\n#  ifndef DWG_ABORT_LIMIT\n#    define DWG_ABORT_LIMIT 200\n#  endif\n#endif\n\nstatic unsigned int loglevel;\n#define DWG_LOGLEVEL loglevel\n#include \"logging.h\"\n#include \"bits.h\"\n\n/*------------------------------------------------------------------------------\n * Public functions\n */\n\n/* Advance bits (forward or backward)\n */\nvoid\nbit_advance_position (Bit_Chain *dat, long advance)\n{\n  long endpos = (long)dat->bit + advance;\n  if (dat->byte >= dat->size - 1 && endpos > 7)\n    {\n      // but allow pointing to the very end.\n      if (dat->byte != dat->size - 1 || dat->bit != 0)\n        {\n          loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n          LOG_ERROR (\"%s buffer overflow at pos %lu, size %lu, advance by %ld\",\n                     __FUNCTION__, dat->byte, dat->size, advance)\n        }\n      dat->byte = dat->size - 1;\n      dat->bit = 0;\n      return;\n    }\n  if ((long)dat->byte + (endpos / 8) < 0)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"buffer underflow at pos %lu, size %lu, advance by %ld\",\n                 dat->byte, dat->size, advance)\n      dat->byte = 0;\n      dat->bit = 0;\n      return;\n    }\n  dat->byte += (endpos >> 3);\n  dat->bit = endpos & 7;\n}\n\n/* Absolute get in bits\n */\nunsigned long\nbit_position (Bit_Chain *dat)\n{\n  return (dat->byte * 8) + (dat->bit & 7);\n}\n\n/* Absolute set in bits\n */\nvoid\nbit_set_position (Bit_Chain *dat, unsigned long bitpos)\n{\n  dat->byte = bitpos >> 3;\n  dat->bit = bitpos & 7;\n  if (dat->byte > dat->size || (dat->byte == dat->size && dat->bit))\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"%s buffer overflow at %lu, have %lu\", __FUNCTION__,\n                 dat->byte, dat->size)\n    }\n}\n\n/* Set the chain so that dat->byte starts at 0 */\nvoid\nbit_reset_chain (Bit_Chain *dat)\n{\n  unsigned long pos = dat->byte;\n  dat->byte = 0;\n  if (pos < dat->size) // not already overflowed\n    dat->chain += pos;\n  if (dat->size > 0)\n    dat->size -= pos;\n}\n\n/** Read 1 bit.\n */\nBITCODE_B\nbit_read_B (Bit_Chain *dat)\n{\n  unsigned char result;\n  unsigned char byte;\n\n  if (dat->byte >= dat->size)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"%s buffer overflow at %lu\", __FUNCTION__, dat->byte)\n#ifdef DWG_ABORT\n      if (++errors > DWG_ABORT_LIMIT)\n        abort();\n#endif\n      return 0;\n    }\n  byte = dat->chain[dat->byte];\n  result = (byte & (0x80 >> dat->bit)) >> (7 - dat->bit);\n\n  bit_advance_position (dat, 1);\n  return result;\n}\n\n/** Write 1 bit.\n */\nvoid\nbit_write_B (Bit_Chain *dat, unsigned char value)\n{\n  if (dat->byte >= dat->size - 1)\n    bit_chain_alloc (dat);\n\n  if (value)\n    dat->chain[dat->byte] |= 0x80 >> dat->bit;\n  else\n    dat->chain[dat->byte] &= ~(0x80 >> dat->bit);\n\n  bit_advance_position (dat, 1);\n}\n\n/** Read 2 bits.\n */\nBITCODE_BB\nbit_read_BB (Bit_Chain *dat)\n{\n  unsigned char result;\n  unsigned char byte;\n\n  if (dat->byte >= dat->size)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"%s buffer overflow at %lu\", __FUNCTION__, dat->byte)\n#ifdef DWG_ABORT\n      if (++errors > DWG_ABORT_LIMIT)\n        abort();\n#endif\n      return 0;\n    }\n  byte = dat->chain[dat->byte];\n  if (dat->bit < 7)\n    result = (byte & (0xc0 >> dat->bit)) >> (6 - dat->bit);\n  else\n    {\n      result = (byte & 0x01) << 1;\n      if (dat->byte < dat->size - 1)\n        {\n          byte = dat->chain[dat->byte + 1];\n          result |= (byte & 0x80) >> 7;\n        }\n    }\n\n  bit_advance_position (dat, 2);\n  return result;\n}\n\n/** Write 2 bits.\n */\nvoid\nbit_write_BB (Bit_Chain *dat, unsigned char value)\n{\n  unsigned char mask;\n  unsigned char byte;\n\n  if (dat->byte >= dat->size - 1)\n    bit_chain_alloc (dat);\n\n  byte = dat->chain[dat->byte];\n  if (dat->bit < 7)\n    {\n      mask = 0xc0 >> dat->bit;\n      dat->chain[dat->byte] = (byte & ~mask) | (value << (6 - dat->bit));\n    }\n  else\n    {\n      dat->chain[dat->byte] = (byte & 0xfe) | (value >> 1);\n      if (dat->byte < dat->size - 1)\n        {\n          byte = dat->chain[dat->byte + 1];\n          dat->chain[dat->byte + 1] = (byte & 0x7f) | ((value & 0x01) << 7);\n        }\n    }\n\n  bit_advance_position (dat, 2);\n}\n\n/** Read 1-3 bits\n *  Keep reading bits until a zero bit is encountered, => 0,2,6,7.\n *  0: 0, 10: 2, 110: 6, 111: 7. 100 for 4 or 101 for 5 is invalid.\n */\nBITCODE_3B\nbit_read_3B (Bit_Chain *dat)\n{\n  BITCODE_3B result = bit_read_B (dat);\n  if (result)\n    {\n      BITCODE_3B next = bit_read_B (dat);\n      if (next)\n        {\n          next = bit_read_B (dat);\n          return next ? 7 : 6;\n        }\n      else\n        {\n          return 2;\n        }\n    }\n  else\n    {\n      return 0;\n    }\n}\n\n/** Write 1-3 bits\n */\nvoid\nbit_write_3B (Bit_Chain *dat, unsigned char value)\n{\n  if (value > 7)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"Invalid bit_write_3B value %d > 7\", value)\n      return;\n    }\n  bit_write_B (dat, value & 1);\n  if (value)\n    {\n      value >>= 1;\n      bit_write_B (dat, value & 1);\n      if (value)\n        {\n          value >>= 1;\n          bit_write_B (dat, value & 1);\n        }\n    }\n}\n\n/** Read 4 bits.\n */\nBITCODE_4BITS\nbit_read_4BITS (Bit_Chain *dat)\n{\n  // clang-format off\n  BITCODE_4BITS b =\n         bit_read_B (dat) << 3 |\n         bit_read_B (dat) << 2 |\n         bit_read_B (dat) << 1 |\n         bit_read_B (dat);\n  // clang-format on\n  return b;\n}\n\n/** Write 4 bits.\n */\nvoid\nbit_write_4BITS (Bit_Chain *dat, unsigned char value)\n{\n  bit_write_B (dat, value & 8);\n  bit_write_B (dat, value & 4);\n  bit_write_B (dat, value & 2);\n  bit_write_B (dat, value & 1);\n}\n\n/** Read 1 byte (raw char).\n */\nBITCODE_RC\nbit_read_RC (Bit_Chain *dat)\n{\n  unsigned char result;\n  unsigned char byte;\n\n  if (dat->byte >= dat->size)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"%s buffer overflow at %lu\", __FUNCTION__, dat->byte)\n#ifdef DWG_ABORT\n      if (++errors > DWG_ABORT_LIMIT)\n        abort();\n#endif\n      return 0;\n    }\n  byte = dat->chain[dat->byte];\n  if (dat->bit == 0)\n    result = byte;\n  else\n    {\n      result = byte << dat->bit;\n      if (dat->byte < dat->size - 1)\n        {\n          byte = dat->chain[dat->byte + 1];\n          result |= byte >> (8 - dat->bit);\n        }\n      else\n        {\n          loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n          LOG_ERROR (\"%s buffer overflow at %lu\", __FUNCTION__, dat->byte + 1)\n          return 0;\n        }\n    }\n\n  bit_advance_position (dat, 8);\n  return ((unsigned char)result);\n}\n\n/** Write 1 byte (raw char).\n */\nvoid\nbit_write_RC (Bit_Chain *dat, unsigned char value)\n{\n  unsigned char byte;\n  unsigned char remainder;\n\n  if (dat->byte >= dat->size - 1)\n    bit_chain_alloc (dat);\n\n  if (dat->bit == 0)\n    {\n      dat->chain[dat->byte] = value;\n    }\n  else\n    {\n      byte = dat->chain[dat->byte];\n      remainder = byte & (0xff << (8 - dat->bit));\n      dat->chain[dat->byte] = remainder | (value >> dat->bit);\n      if (dat->byte < dat->size - 1)\n        {\n          byte = dat->chain[dat->byte + 1];\n          remainder = byte & (0xff >> dat->bit);\n          dat->chain[dat->byte + 1] = remainder | (value << (8 - dat->bit));\n        }\n    }\n\n  bit_advance_position (dat, 8);\n}\n\n/** Read 1 raw short (BE short).\n */\nBITCODE_RS\nbit_read_RS (Bit_Chain *dat)\n{\n  unsigned char byte1, byte2;\n\n  // least significant byte first:\n  byte1 = bit_read_RC (dat);\n  byte2 = bit_read_RC (dat);\n  return (BITCODE_RS) ((byte2 << 8) | byte1);\n}\n\n/** Read 1 raw short little-endian.\n */\nBITCODE_RS\nbit_read_RS_LE (Bit_Chain *dat)\n{\n  unsigned char byte1, byte2;\n  byte1 = bit_read_RC (dat);\n  byte2 = bit_read_RC (dat);\n  return (BITCODE_RS) ((byte1 << 8) | byte2);\n}\n\n/** Write 1 raw short (BE short).\n */\nvoid\nbit_write_RS (Bit_Chain *dat, BITCODE_RS value)\n{\n  // least significant byte first:\n  bit_write_RC (dat, value & 0xFF);\n  bit_write_RC (dat, value >> 8);\n}\n\n/** Write 1 raw short little-endian.\n */\nvoid\nbit_write_RS_LE (Bit_Chain *dat, BITCODE_RS value)\n{\n  bit_write_RC (dat, value >> 8);\n  bit_write_RC (dat, value & 0xFF);\n}\n\n/** Read 1 raw long (4 byte, BE).\n */\nBITCODE_RL\nbit_read_RL (Bit_Chain *dat)\n{\n  BITCODE_RS word1, word2;\n\n  // least significant word first\n  word1 = bit_read_RS (dat);\n  word2 = bit_read_RS (dat);\n  return ((((uint32_t)word2) << 16) | ((uint32_t)word1));\n}\n\n/** Write 1 raw long (4 byte, BE).\n */\nvoid\nbit_write_RL (Bit_Chain *dat, BITCODE_RL value)\n{\n  const uint32_t l = value;\n  // least significant word first:\n  bit_write_RS (dat, l & 0xFFFF);\n  bit_write_RS (dat, l >> 16);\n}\n\n/** Read 1 raw long (4 byte, LE).\n */\nBITCODE_RL\nbit_read_RL_LE (Bit_Chain *dat)\n{\n  BITCODE_RS word1, word2;\n\n  // most significant word first\n  word1 = bit_read_RS_LE (dat);\n  word2 = bit_read_RS_LE (dat);\n  return ((((uint32_t)word1) << 16) | ((uint32_t)word2));\n}\n\n/** Write 1 raw long (4 byte, LE).\n */\nvoid\nbit_write_RL_LE (Bit_Chain *dat, BITCODE_RL value)\n{\n  // most significant word first:\n  bit_write_RS_LE (dat, value >> 16);\n  bit_write_RS_LE (dat, value & 0xFFFF);\n}\n\n/** Read 1 raw 64bit long (8 byte, BE).\n */\nBITCODE_RLL\nbit_read_RLL (Bit_Chain *dat)\n{\n  BITCODE_RL word1, word2;\n\n  // least significant word first\n  word1 = bit_read_RL (dat);\n  word2 = bit_read_RL (dat);\n  return ((((uint64_t)word2) << 32) | ((uint64_t)word1));\n}\n\n/** Write 1 raw 64bit long  (8 byte, BE).\n */\nvoid\nbit_write_RLL (Bit_Chain *dat, BITCODE_RLL value)\n{\n  // least significant word first\n  bit_write_RL (dat, value & 0xFFFFFFFF);\n  bit_write_RL (dat, value >> 32);\n}\n\n/** Read 1 raw double (8 bytes, IEEE-754).\n */\nBITCODE_RD\nbit_read_RD (Bit_Chain *dat)\n{\n  int i;\n  unsigned char byte[8];\n  double *result;\n\n  // TODO: I think it might not work on big-endian platforms:\n  for (i = 0; i < 8; i++)\n    byte[i] = bit_read_RC (dat);\n\n  result = (double *)byte;\n  return (*result);\n}\n\n/** Write 1 raw double (8 bytes, IEEE-754).\n */\nvoid\nbit_write_RD (Bit_Chain *dat, double value)\n{\n  int i;\n  unsigned char *val;\n\n  // TODO: I think it might not work on big-endian platforms:\n  val = (unsigned char *)&value;\n\n  for (i = 0; i < 8; i++)\n    bit_write_RC (dat, val[i]);\n}\n\n/** Read 1 bitshort (compacted data).\n */\nBITCODE_BS\nbit_read_BS (Bit_Chain *dat)\n{\n  const unsigned char two_bit_code = bit_read_BB (dat);\n  if (two_bit_code == 0)\n    return bit_read_RS (dat);\n  else if (two_bit_code == 1)\n    return (BITCODE_BS)bit_read_RC (dat) & 0xFF;\n  else if (two_bit_code == 2)\n    return 0;\n  else /* if (two_bit_code == 3) */\n    return 256;\n}\n\n/** Write 1 bitshort (compacted data).\n */\nvoid\nbit_write_BS (Bit_Chain *dat, BITCODE_BS value)\n{\n  // BITCODE_BS is defined as uint16_t, but better safe than sorry\n  const uint16_t l = value;\n  if (l > 256)\n    {\n      bit_write_BB (dat, 0);\n      bit_write_RS (dat, value);\n    }\n  else if (value == 0)\n    bit_write_BB (dat, 2);\n  else if (value == 256)\n    bit_write_BB (dat, 3);\n  else\n    {\n      bit_write_BB (dat, 1);\n      bit_write_RC (dat, value);\n    }\n}\n\n/** Read 1 bitlong (compacted data).\n */\nBITCODE_BL\nbit_read_BL (Bit_Chain *dat)\n{\n  const unsigned char two_bit_code = bit_read_BB (dat);\n  if (two_bit_code == 0)\n    return bit_read_RL (dat);\n  else if (two_bit_code == 1)\n    return bit_read_RC (dat) & 0xFF;\n  else if (two_bit_code == 2)\n    return 0;\n  else /* if (two_bit_code == 3) */\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"bit_read_BL: unexpected 2-bit code: '11'\")\n      return 256;\n    }\n}\n\n/** Write 1 bitlong (compacted data).\n */\nvoid\nbit_write_BL (Bit_Chain *dat, BITCODE_BL value)\n{\n  // BITCODE_BL is signed int32_t\n  const uint32_t l = value;\n  if (l > 255)\n    {\n      bit_write_BB (dat, 0);\n      bit_write_RL (dat, value);\n    }\n  else if (l == 0)\n    bit_write_BB (dat, 2);\n  else\n    {\n      bit_write_BB (dat, 1);\n      bit_write_RC (dat, value);\n    }\n}\n\n/** Write signed bitlong (compacted data).\n */\nvoid\nbit_write_BLd (Bit_Chain *dat, BITCODE_BLd value)\n{\n  const BITCODE_BL l = value;\n  if (l > 255)\n    {\n      bit_write_BB (dat, 0);\n      bit_write_RL (dat, (BITCODE_RL)value);\n    }\n  else if (l == 0)\n    bit_write_BB (dat, 2);\n  else\n    {\n      bit_write_BB (dat, 1);\n      bit_write_RC (dat, value);\n    }\n}\n\n/** Read object type 2010+ (BB + 1 or 2 bytes).\n *  par 2.12\n */\nBITCODE_BS\nbit_read_BOT (Bit_Chain *dat)\n{\n  unsigned char two_bit_code;\n\n  two_bit_code = bit_read_BB (dat);\n\n  if (two_bit_code == 0)\n    return bit_read_RC (dat);\n  else if (two_bit_code == 1)\n    return bit_read_RC (dat) + 0x1f0;\n  else\n    return bit_read_RS (dat);\n}\n\n/** Write object type 2010+ (BB + 1 or 2 bytes).\n */\nvoid\nbit_write_BOT (Bit_Chain *dat, BITCODE_BS value)\n{\n  if (value < 256)\n    {\n      bit_write_BB (dat, 0);\n      bit_write_RC (dat, value);\n    }\n  else if (value < 0x7fff)\n    {\n      bit_write_BB (dat, 1);\n      bit_write_RC (dat, value - 0x1f0);\n    }\n  else\n    {\n      bit_write_BB (dat, 1);\n      bit_write_RS (dat, value);\n    }\n}\n\n/** Read 1 bitlonglong (compacted uint64_t) for REQUIREDVERSIONS, preview_size.\n *  ODA doc bug. ODA say 1-3 bits until the first 0 bit. See 3BLL.\n *  The first 3 bits indicate the length l (see paragraph 2.1). Then\n *  l bytes follow, which represent the number (the least significant\n *  byte is first).\n */\nBITCODE_BLL\nbit_read_BLL (Bit_Chain *dat)\n{\n  unsigned int i, len;\n  BITCODE_BLL result = 0ULL;\n  len = bit_read_BB (dat) << 1 | bit_read_B (dat);\n  switch (len)\n    {\n    case 1:\n      return bit_read_RC (dat);\n    case 2:\n      return bit_read_RS (dat);\n    case 4:\n      return bit_read_RL (dat);\n    default:\n      for (i = 0; i < len; i++)\n        {\n          result <<= 8;\n          result |= bit_read_RC (dat);\n        }\n      return result;\n    }\n}\n\n/** Read 1 bitlonglong (compacted uint64_t) as documented (but unused).\n *  The first 1-3 bits indicate the length l (see paragraph 2.1). Then\n *  l bytes follow, which represent the number (the least significant\n *  byte is first).\n */\nBITCODE_BLL\nbit_read_3BLL (Bit_Chain *dat)\n{\n  unsigned int i, len;\n  BITCODE_BLL result = 0ULL;\n  len = bit_read_3B (dat);\n  for (i = 0; i < len; i++)\n    {\n      result <<= 8;\n      result |= bit_read_RC (dat);\n    }\n  return result;\n}\n\n/** Write 1 bitlonglong (compacted data).\n */\nvoid\nbit_write_BLL (Bit_Chain *dat, BITCODE_BLL value)\n{\n  // 64bit into how many bytes?\n  int i;\n  int len = 0;\n  BITCODE_BLL umax = 0xf000000000000000ULL;\n  for (i = 16; i; i--, umax >>= 8)\n    {\n      if (value & umax)\n        {\n          len = i;\n          break;\n        }\n    }\n  bit_write_BB (dat, len << 2);\n  bit_write_B (dat, len & 1);\n  for (i = 0; i < len; i++)\n    {\n      // least significant byte first\n      bit_write_RC (dat, value & 0xFF);\n      value >>= 8;\n    }\n}\nvoid\nbit_write_3BLL (Bit_Chain *dat, BITCODE_BLL value)\n{\n  // 64bit into how many bytes?\n  int i;\n  int len = 0;\n  BITCODE_BLL umax = 0xf000000000000000ULL;\n  for (i = 16; i; i--, umax >>= 8)\n    {\n      if (value & umax)\n        {\n          len = i;\n          break;\n        }\n    }\n  bit_write_3B (dat, len);\n  for (i = 0; i < len; i++)\n    {\n      // least significant byte first\n      bit_write_RC (dat, value & 0xFF);\n      value >>= 8;\n    }\n}\n\n/** Read 1 bitdouble (compacted data).\n */\nBITCODE_BD\nbit_read_BD (Bit_Chain *dat)\n{\n  unsigned char two_bit_code;\n\n  two_bit_code = bit_read_BB (dat);\n  if (two_bit_code == 0)\n    return bit_read_RD (dat);\n  else if (two_bit_code == 1)\n    return 1.0;\n  else if (two_bit_code == 2)\n    return 0.0;\n  else /* if (two_bit_code == 3) */\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"bit_read_BD: unexpected 2-bit code: '11'\")\n      return bit_nan ();\n    }\n}\n\n/* create a Not-A-Number (NaN) without libm dependency */\nBITCODE_BD\nbit_nan (void)\n{\n  double result;\n  int32_t *res = (int32_t *)&result;\n  res[0] = -1;\n  res[1] = -1;\n  return result;\n}\n\nint\nbit_isnan (BITCODE_BD number)\n{\n  int32_t *res = (int32_t *)&number;\n  return (res[0] == -1 && res[1] == -1);\n}\n\n/** Write 1 bitdouble (compacted data).\n */\nvoid\nbit_write_BD (Bit_Chain *dat, double value)\n{\n  if (value == 0.0)\n    bit_write_BB (dat, 2);\n  else if (value == 1.0)\n    bit_write_BB (dat, 1);\n  else\n    {\n      bit_write_BB (dat, 0);\n      bit_write_RD (dat, value);\n    }\n}\n\n/** Read 1 modular char (max 5 bytes, signed).\n    Read bytes until the high bit of the byte is 0, drop the highest bit and\n pad with 0. If the last byte has 0x40 set, it's negative. Since the result is\n int32_t (4 byte), but there needs to be the high/follow bit set, the stream\n can be max 5 byte long (5*7 = 35 bit) 10000000 10000000 10000000 10000000\n 00000100\n =>  0000000  0000000  0000000  0000000  0000100 (5*7 = 35)\n => 00001000 00000000 00000000 00000000          (4*8 = 32)\n */\nBITCODE_MC\nbit_read_MC (Bit_Chain *dat)\n{\n  int i, j;\n  int negative;\n  unsigned char byte[5];\n  BITCODE_UMC result;\n\n  negative = 0;\n  result = 0;\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = bit_read_RC (dat);\n      if (!(byte[i] & 0x80))\n        {\n          if ((byte[i] & 0x40))\n            {\n              negative = 1;\n              byte[i] &= 0xbf;\n            }\n          result |= (((BITCODE_UMC)byte[i]) << j);\n          return (negative ? -((BITCODE_MC)result) : (BITCODE_MC)result);\n        }\n      else\n        byte[i] &= 0x7f;\n\n      result |= ((BITCODE_UMC)byte[i]) << j;\n    }\n\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n  LOG_ERROR (\n      \"bit_read_MC: error parsing modular char. i=%d, j=%d, result=0x%lx,\\n\"\n      \" @%lu.@%u: [0x%x 0x%x 0x%x 0x%x 0x%x]\",\n      i, j, result, dat->byte - 5, dat->bit, dat->chain[dat->byte - 5],\n      dat->chain[dat->byte - 4], dat->chain[dat->byte - 3],\n      dat->chain[dat->byte - 2], dat->chain[dat->byte - 1])\n  return 0; /* error... */\n}\n\n/** Write 1 modular char (max 5 bytes, signed).\n */\nvoid\nbit_write_MC (Bit_Chain *dat, BITCODE_MC val)\n{\n  int i, j;\n  int negative = 0;\n  unsigned char byte[5];\n  BITCODE_UMC mask = 0x0000007f;\n  BITCODE_UMC value = (BITCODE_UMC)val;\n\n  if (val < 0)\n    {\n      negative = 1;\n      value = (BITCODE_UMC)-val;\n    }\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  if (negative)\n    byte[i] |= 0x40;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}\n\n/** Read unsigned modular char (max 5 bytes, unsigned).\n    Can be quite large if there are many deleted handles.\n */\nBITCODE_UMC\nbit_read_UMC (Bit_Chain *dat)\n{\n  int i, j;\n  // eg handle FD485E65F\n  #define MAX_BYTE_UMC 6\n  unsigned char byte[MAX_BYTE_UMC];\n  BITCODE_UMC result;\n\n  result = 0;\n  for (i = MAX_BYTE_UMC-1, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = bit_read_RC (dat);\n      if (!(byte[i] & 0x80))\n        {\n          result |= (((BITCODE_UMC)byte[i]) << j);\n          return result;\n        }\n      else\n        byte[i] &= 0x7f;\n\n      result |= ((BITCODE_UMC)byte[i]) << j;\n    }\n\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n  LOG_ERROR (\n      \"bit_read_UMC: error parsing modular char, i=%d,j=%d,result=0x%lx\", i, j,\n      result)\n  LOG_HANDLE (\"  @%lu.%u: [0x%x 0x%x 0x%x 0x%x 0x%x]\\n\", dat->byte - 5,\n            dat->bit, dat->chain[dat->byte - 5], dat->chain[dat->byte - 4],\n            dat->chain[dat->byte - 3], dat->chain[dat->byte - 2],\n            dat->chain[dat->byte - 1])\n  return 0; /* error... */\n}\n\n/** Write 1 modular char (max 5 bytes, unsigned).\n */\nvoid\nbit_write_UMC (Bit_Chain *dat, BITCODE_UMC val)\n{\n  int i, j;\n  int negative;\n  unsigned char byte[5];\n  BITCODE_UMC mask;\n  BITCODE_UMC value;\n\n  value = val;\n  mask = 0x0000007f;\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}\n\n/** Read 1 modular short (max 2 words).\n */\nBITCODE_MS\nbit_read_MS (Bit_Chain *dat)\n{\n  int i, j;\n  BITCODE_RS word[2];\n  BITCODE_MS result;\n\n  result = 0;\n  for (i = 1, j = 0; i > -1; i--, j += 15)\n    {\n      word[i] = bit_read_RS (dat);\n      if (!(word[i] & 0x8000))\n        {\n          result |= (((BITCODE_MS)word[i]) << j);\n          return (BITCODE_MS)result;\n        }\n      else\n        word[i] &= 0x7fff;\n      result |= ((BITCODE_MS)word[i]) << j;\n    }\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n  LOG_ERROR (\"bit_read_MS: error parsing modular short, i=%d,j=%d\", i, j)\n  return 0; /* error... */\n}\n\n/** Write 1 modular short (max 2 words).\n */\nvoid\nbit_write_MS (Bit_Chain *dat, BITCODE_MS value)\n{\n  if (value > 0x7fff)\n    {\n      bit_write_RS (dat, (value & 0xffff8000) >> 15);\n      bit_write_RS (dat, value & 0x7fff);\n    }\n  else\n    {\n      bit_write_RS (dat, value);\n    }\n}\n\n/** Read bit-extrusion.\n */\nvoid\nbit_read_BE (Bit_Chain *restrict dat, double *restrict x, double *restrict y,\n             double *restrict z)\n{\n  if (dat->version >= R_2000 && bit_read_B (dat))\n    {\n      *x = 0.0;\n      *y = 0.0;\n      *z = 1.0;\n    }\n  else\n    {\n      *x = bit_read_BD (dat);\n      *y = bit_read_BD (dat);\n      *z = bit_read_BD (dat);\n    }\n}\n\n/** Write bit-extrusion.\n */\nvoid\nbit_write_BE (Bit_Chain *dat, double x, double y, double z)\n{\n  if (dat->version >= R_2000 && x == 0.0 && y == 0.0 && z == 1.0)\n    bit_write_B (dat, 1);\n  else\n    {\n      bit_write_B (dat, 0);\n      bit_write_BD (dat, x);\n      bit_write_BD (dat, y);\n      bit_write_BD (dat, z);\n    }\n}\n\n/** Read bit-double with default.\n */\nBITCODE_DD\nbit_read_DD (Bit_Chain *dat, double default_value)\n{\n  unsigned char two_bit_code;\n  unsigned char *uchar_result;\n\n  two_bit_code = bit_read_BB (dat);\n  if (two_bit_code == 0)\n    return default_value;\n  if (two_bit_code == 3)\n    return (bit_read_RD (dat));\n  if (two_bit_code == 2)\n    {\n      uchar_result = (unsigned char *)&default_value;\n      uchar_result[4] = bit_read_RC (dat);\n      uchar_result[5] = bit_read_RC (dat);\n      uchar_result[0] = bit_read_RC (dat);\n      uchar_result[1] = bit_read_RC (dat);\n      uchar_result[2] = bit_read_RC (dat);\n      uchar_result[3] = bit_read_RC (dat);\n\n      return default_value;\n    }\n  else /* if (two_bit_code == 1) */\n    {\n      uchar_result = (unsigned char *)&default_value;\n      uchar_result[0] = bit_read_RC (dat);\n      uchar_result[1] = bit_read_RC (dat);\n      uchar_result[2] = bit_read_RC (dat);\n      uchar_result[3] = bit_read_RC (dat);\n\n      return default_value;\n    }\n}\n\n/** Write bit-double with default.\n */\nvoid\nbit_write_DD (Bit_Chain *dat, double value, double default_value)\n{\n  unsigned char *uchar_value;\n\n  unsigned int *uint_value;\n  unsigned int *uint_default;\n\n  if (value == default_value)\n    bit_write_BB (dat, 0);\n  else\n    {\n      uchar_value = (unsigned char *)&value;\n      uint_value = (unsigned int *)&value;\n      uint_default = (unsigned int *)&default_value;\n      if (uint_value[0] == uint_default[0])\n        {\n          if (uint_value[1] != uint_default[1])\n            {\n              bit_write_BB (dat, 2);\n              bit_write_RC (dat, uchar_value[4]);\n              bit_write_RC (dat, uchar_value[5]);\n              bit_write_RC (dat, uchar_value[0]);\n              bit_write_RC (dat, uchar_value[1]);\n              bit_write_RC (dat, uchar_value[2]);\n              bit_write_RC (dat, uchar_value[3]);\n            }\n          else\n            {\n              bit_write_BB (dat, 1);\n              bit_write_RC (dat, uchar_value[0]);\n              bit_write_RC (dat, uchar_value[1]);\n              bit_write_RC (dat, uchar_value[2]);\n              bit_write_RC (dat, uchar_value[3]);\n            }\n        }\n      else\n        {\n          bit_write_BB (dat, 3);\n          bit_write_RD (dat, value);\n        }\n    }\n}\n\n/** Read bit-thickness.\n */\nBITCODE_BT\nbit_read_BT (Bit_Chain *dat)\n{\n  int mode = 0;\n\n  if (dat->version >= R_2000)\n    mode = bit_read_B (dat);\n\n  return (mode ? 0.0 : bit_read_BD (dat));\n}\n\n/** Write bit-thickness.\n */\nvoid\nbit_write_BT (Bit_Chain *dat, double value)\n{\n  if (dat->version >= R_2000 && value == 0.0)\n    bit_write_B (dat, 1);\n  else\n    {\n      bit_write_B (dat, 0);\n      bit_write_BD (dat, value);\n    }\n}\n\n/** Read handle-references. Returns error code: DWG_ERR_INVALIDHANDLE\n *  or 0 on success.\n */\nint\nbit_read_H (Bit_Chain *restrict dat, Dwg_Handle *restrict handle)\n{\n  int i;\n\n  handle->code = bit_read_RC (dat);\n  handle->size = handle->code & 0x0f;\n  handle->code = (handle->code & 0xf0) >> 4;\n\n  handle->value = 0;\n  if (handle->size > sizeof(BITCODE_RC *) || handle->code > 14)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_WARN (\"Invalid handle-reference, longer than 8 bytes: \" FORMAT_H,\n                ARGS_H (*handle))\n      return DWG_ERR_INVALIDHANDLE;\n    }\n\n  // TODO: little-endian only\n  // x86_64 gcc-9 miscompilation with val[i]: (%rbx) being dat+1\n#if defined(__GNUC__) && (__GNUC__ == 9) && (__GNUC_MINOR__ <= 2) \\\n  && (SIZEOF_SIZE_T == 8)                                         \\\n  && (defined(__x86_64__) || defined(__x86_64) || defined(_M_AMD64) || defined(_M_X64))\n  {\n#warning x86_64 gcc-9.2 codegen is seriously broken! better use an older version\n    BITCODE_RC *restrict val;\n    val = (BITCODE_RC *)&(handle->value);\n    for (i = handle->size - 1; i >= 0; i--)\n      {\n        BITCODE_RC c = bit_read_RC (dat);\n        val[i] = c;\n      }\n  }\n#else\n  {\n    BITCODE_RC *restrict val;\n    val = (BITCODE_RC *)&(handle->value);\n    for (i = handle->size - 1; i >= 0; i--)\n      val[i] = bit_read_RC (dat);\n  }\n#endif\n\n  return 0;\n}\n\n/** Write handle-references.\n */\nvoid\nbit_write_H (Bit_Chain *restrict dat, Dwg_Handle *restrict handle)\n{\n  int i;\n  unsigned char *val;\n  unsigned char size;\n\n  if (!handle)\n    {\n      bit_write_RC (dat, 0);\n      return;\n    }\n  if (handle->value == 0)\n    {\n      bit_write_RC (dat, handle->code << 4);\n      return;\n    }\n\n  // TODO: little-endian only. support sizes <= 8, not just 4\n  memset (&val, 0, sizeof(val));\n  val = (unsigned char *)&handle->value;\n  for (i = sizeof(val) - 1; i >= 0; i--)\n    if (val[i])\n      break;\n\n  size = handle->code << 4;\n  size |= i + 1;\n  bit_write_RC (dat, size);\n\n  for (; i >= 0; i--)\n    bit_write_RC (dat, val[i]);\n}\n\n/** Only read old 16bit CRC-numbers, without checking, only in order\n *  to go to the next byte, while skipping non-aligned bits.\n */\nuint16_t\nbit_read_CRC (Bit_Chain *dat)\n{\n  uint16_t result;\n  long unsigned int start_address;\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n\n  if (dat->bit > 0)\n    {\n      dat->byte++;\n      dat->bit = 0;\n    }\n  start_address = dat->byte;\n  result = bit_read_RS (dat);\n  LOG_TRACE (\"read CRC at %lu: %04X\\n\", start_address, result)\n\n  return result;\n}\n\n/** Read and check old 16bit CRC.\n */\nint\nbit_check_CRC (Bit_Chain *dat, long unsigned int start_address, uint16_t seed)\n{\n  uint16_t calculated;\n  uint16_t read;\n  long size;\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n\n  if (dat->bit > 0)\n    {\n      dat->byte++;\n      dat->bit = 0;\n    }\n\n  if (start_address > dat->byte || dat->byte >= dat->size)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"%s buffer overflow at pos %lu-%lu, size %lu\", __FUNCTION__,\n                 start_address, dat->byte, dat->size)\n      return 0;\n    }\n\n  size = dat->byte - start_address;\n  calculated = bit_calc_CRC (seed, &dat->chain[start_address], size);\n  read = bit_read_RS (dat);\n  LOG_TRACE (\"crc: %04X [RSx]\\n\", read);\n  if (calculated == read)\n    {\n      LOG_HANDLE (\" check_CRC %lu-%lu = %ld: %04X == %04X\\n\", start_address,\n                  dat->byte - 2, size, calculated, read)\n      return 1;\n    }\n  else\n    {\n      LOG_WARN (\"check_CRC mismatch %lu-%lu = %ld: %04X <=> %04X\\n\",\n                start_address, dat->byte - 2, size, calculated, read)\n      return 0;\n    }\n}\n\n/** Create and write old 16bit CRC.\n */\nuint16_t\nbit_write_CRC (Bit_Chain *dat, long unsigned int start_address, uint16_t seed)\n{\n  uint16_t crc;\n  long size;\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n\n  while (dat->bit > 0)\n    bit_write_B (dat, 0);\n\n  size = dat->byte - start_address;\n  crc = bit_calc_CRC (seed, &dat->chain[start_address], size);\n\n  LOG_TRACE (\"write CRC %04X from %lu-%lu = %ld\\n\", crc, start_address,\n             dat->byte, size);\n  bit_write_RS (dat, crc);\n  return crc;\n}\n\nuint16_t\nbit_write_CRC_LE (Bit_Chain *dat, long unsigned int start_address, uint16_t seed)\n{\n  uint16_t crc;\n  long size;\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n\n  while (dat->bit > 0)\n    bit_write_B (dat, 0);\n\n  size = dat->byte - start_address;\n  crc = bit_calc_CRC (seed, &dat->chain[start_address], size);\n\n  LOG_TRACE (\"write CRC %04X from %lu-%lu = %ld\\n\", crc, start_address,\n             dat->byte, size);\n  bit_write_RS_LE (dat, crc);\n  return crc;\n}\n\nvoid\nbit_read_fixed (Bit_Chain *restrict dat, BITCODE_RC *restrict dest, int length)\n{\n  for (int i = 0; i < length; i++)\n    {\n      dest[i] = bit_read_RC (dat);\n    }\n}\n\n/** Read fixed text with zero-termination.\n *  After usage, the allocated memory must be properly freed.\n *  preR11\n */\nBITCODE_TF\nbit_read_TF (Bit_Chain *restrict dat, int length)\n{\n  BITCODE_RC *chain = malloc (length + 1);\n\n  bit_read_fixed (dat, chain, length);\n  chain[length] = '\\0';\n\n  return (BITCODE_TF)chain;\n}\n\n/** Write fixed text. Without ending \\0\n */\nvoid\nbit_write_TF (Bit_Chain *restrict dat, BITCODE_TF restrict chain, int length)\n{\n  int i;\n  for (i = 0; i < length; i++)\n    bit_write_RC (dat, (BITCODE_RC)chain[i]);\n}\n\n/** Read simple text. After usage, the allocated memory must be properly freed.\n */\nBITCODE_TV\nbit_read_TV (Bit_Chain *restrict dat)\n{\n  unsigned int i;\n  unsigned int length;\n  unsigned char *chain;\n\n  length = bit_read_BS (dat);\n  if (dat->byte + length >= dat->size)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"%s buffer overflow at %lu, length %u\", __FUNCTION__,\n                 dat->byte, length)\n      return NULL;\n    }\n  chain = (unsigned char *)malloc (length + 1);\n  for (i = 0; i < length; i++)\n    {\n      chain[i] = bit_read_RC (dat);\n#if 0\n      /* we support encode and codepages */\n      if (!isprint (chain[i]))\n        chain[i] = '~';\n#endif\n    }\n  chain[i] = '\\0';\n\n  return (char *)chain;\n}\n\n/** Write simple text.\n */\nvoid\nbit_write_TV (Bit_Chain *restrict dat, BITCODE_TV restrict chain)\n{\n  int i;\n  int length;\n\n  length = chain ? strlen ((const char *)chain) + 1 : 0;\n  bit_write_BS (dat, length);\n  for (i = 0; i < length; i++)\n    bit_write_RC (dat, (unsigned char)chain[i]);\n}\n\n/** Read UCS-2 unicode text. no supplementary planes\n * See also bfr_read_string()\n */\nBITCODE_TU\nbit_read_TU (Bit_Chain *restrict dat)\n{\n  unsigned int i;\n  unsigned int length;\n  BITCODE_TU chain;\n\n  length = bit_read_BS (dat);\n  if (dat->byte + (length * 2) >= dat->size)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"%s buffer overflow at %lu, length %u\", __FUNCTION__,\n                 dat->byte, length)\n      return NULL;\n    }\n  chain = (BITCODE_TU)malloc ((length + 1) * 2);\n  for (i = 0; i < length; i++)\n    {\n      chain[i] = bit_read_RS (dat); // probably without byte swapping\n    }\n  chain[length] = 0;\n\n  return chain;\n}\n\n/** Write UCS-2 unicode text. Must be zero-delimited.\n */\nvoid\nbit_write_TU (Bit_Chain *restrict dat, BITCODE_TU restrict chain)\n{\n  unsigned int i;\n  unsigned int length;\n\n  if (chain)\n    {\n#if defined(HAVE_WCHAR_H) && defined(SIZEOF_WCHAR_T) && SIZEOF_WCHAR_T == 2\n      length = wcslen (chain) + 1;\n#else\n      for (length = 0; chain[length]; length++)\n        ;\n      length++;\n#endif\n    }\n  else\n    length = 0;\n\n  bit_write_BS (dat, length);\n  for (i = 0; i < length; i++)\n    {\n      bit_write_RS (dat, chain[i]); // probably without byte swapping\n    }\n  bit_write_RS (dat, 0); //?? unsure about that\n}\n\nBITCODE_T\nbit_read_T (Bit_Chain *restrict dat)\n{\n  if (dat->version >= R_2007)\n    return (BITCODE_T)bit_read_TU (dat);\n  else\n    return (BITCODE_T)bit_read_TV (dat);\n}\n\nvoid\nbit_write_T (Bit_Chain *restrict dat, BITCODE_T restrict chain)\n{\n  if (dat->version >= R_2007)\n    return bit_write_TU (dat, (BITCODE_TU)chain);\n  else\n    return bit_write_TV (dat, chain);\n}\n\n/* converts UCS-2 to UTF-8 */\nchar *\nbit_convert_TU (BITCODE_TU restrict wstr)\n{\n  BITCODE_TU tmp = wstr;\n  char *str;\n  int i, len = 0;\n  uint16_t c = 0;\n\n  if (!wstr)\n    return NULL;\n#ifdef HAVE_ALIGNED_ACCESS_REQUIRED\n  /* access bytewise. cannot copy to heap yet, because we have no length */\n  if ((uintptr_t)wstr % SIZEOF_SIZE_T)\n    {\n      unsigned char *b = (unsigned char*)wstr;\n      c = (b[0] << 8) + b[1];\n      while (c)\n        {\n          len++;\n          if (c >= 256)\n            len++;\n          if (c >= 0x800)\n            len++;\n          b += 2;\n          c = (b[0] << 8) + b[1];\n        }\n    }\n  else\n#endif\n  while ((c = *tmp++))\n    {\n      len++;\n      if (c >= 256)\n        len++;\n      if (c >= 0x800)\n        len++;\n#if 0\n        loglevel = 5;\n        LOG_INSANE (\"U+%04X \", c);\n#endif\n    }\n  str = malloc (len + 1);\n  i = 0;\n#ifdef HAVE_ALIGNED_ACCESS_REQUIRED\n  if ((uintptr_t)wstr % SIZEOF_SIZE_T)\n    {\n      unsigned char *b = (unsigned char*)wstr;\n      c = (b[0] << 8) + b[1];\n      while (c)\n        {\n          if (c < 256)\n            {\n              str[i++] = c & 0xFF;\n            }\n          else if (c < 0x800)\n            {\n              str[i++] = (c >> 6) | 0xC0;\n              str[i++] = (c & 0x3F) | 0x80;\n            }\n          else /* if (c < 0x10000) */\n            {\n              str[i++] = (c >> 12) | 0xE0;\n              str[i++] = ((c >> 6) & 0x3F) | 0x80;\n              str[i++] = (c & 0x3F) | 0x80;\n            }\n\n          b += 2;\n          c = (b[0] << 8) + b[1];\n        }\n    }\n  else\n#endif\n  while ((c = *wstr++))\n    {\n      if (c < 256)\n        {\n          str[i++] = c & 0xFF;\n        }\n      else if (c < 0x800)\n        {\n          str[i++] = (c >> 6) | 0xC0;\n          str[i++] = (c & 0x3F) | 0x80;\n        }\n      else /* if (c < 0x10000) */\n        { /* windows ucs-2 has no D800-DC00 surrogate pairs. go straight up */\n          /*if (i+3 > len) {\n            str = realloc(str, i+3);\n            len = i+2;\n          }*/\n          str[i++] = (c >> 12) | 0xE0;\n          str[i++] = ((c >> 6) & 0x3F) | 0x80;\n          str[i++] = (c & 0x3F) | 0x80;\n        }\n      /*\n      else if (c < 0x110000)\n        {\n          str[i++] = (c >> 18) | 0xF0;\n          str[i++] = ((c >> 12) & 0x3F) | 0x80;\n          str[i++] = ((c >> 6) & 0x3F) | 0x80;\n          str[i++] = (c & 0x3F) | 0x80;\n        }\n      else\n        fprintf (stderr, \"ERROR: overlarge unicode codepoint U+%0X\", c);\n     */\n    }\n  str[i] = '\\0';\n  return str;\n}\n\n/** converts UTF-8 to UCS-2. Returns a copy */\nBITCODE_TU\nbit_utf8_to_TU (char *restrict str)\n{\n  BITCODE_TU wstr;\n  int i = 0;\n  int len = strlen (str);\n  unsigned char c;\n\n  wstr = malloc (2 * (len + 1));\n  while ((c = *str++))\n    {\n      if (c < 128)\n        {\n          wstr[i++] = c;\n        }\n      else if ((c & 0xe0) == 0xc0)\n        {\n          /* ignore invalid utf8 for now */\n          wstr[i++] = ((c & 0x1f) << 6) | (str[1] & 0x3f);\n          str++;\n        }\n      else if ((c & 0xf0) == 0xe0)\n        {\n          /* ignore invalid utf8? */\n          if ((unsigned char)str[1] < 0x80 || (unsigned char)str[1] > 0xBF\n              || (unsigned char)str[2] < 0x80 || (unsigned char)str[2] > 0xBF)\n            {\n              LOG_WARN (\"utf-8: BAD_CONTINUATION_BYTE %s\", str);\n            }\n          if (c == 0xe0 && (unsigned char)str[1] < 0xa0)\n            {\n              LOG_WARN (\"utf-8: NON_SHORTEST %s\", str);\n            }\n          wstr[i++]\n              = ((c & 0x0f) << 12) | ((str[1] & 0x3f) << 6) | (str[2] & 0x3f);\n          str++;\n          str++;\n        }\n      /* everything above 0xf0 exceeds ucs-2, 4-6 byte seqs */\n    }\n  wstr[i] = '\\0';\n  return wstr;\n}\n\n/* compare an ASCII/utf-8 string to a r2007+ name */\nint\nbit_eq_TU (const char *restrict str, BITCODE_TU restrict wstr)\n{\n  char *utf8 = bit_convert_TU (wstr);\n  int result = strcmp (str, utf8) ? 0 : 1;\n  free (utf8);\n  return result;\n}\n\n/** Read 1 bitlong according to normal order\n */\nBITCODE_RL\nbit_read_L (Bit_Chain *dat) { return bit_read_RL_LE (dat); }\n\n/** Write 1 bitlong according to normal order\n */\nvoid\nbit_write_L (Bit_Chain *dat, BITCODE_RL value)\n{\n  bit_write_RL_LE (dat, value);\n  return;\n}\n\n/** Read 2 time BL bitlong (compacted data).\n *  julian day + milliseconds\n *  used for TDCREATE, TDUPDATE, and all other DATE variables.\n *  pre-R13 read 2xRL\n */\nBITCODE_TIMEBLL\nbit_read_TIMEBLL (Bit_Chain *dat)\n{\n  BITCODE_TIMEBLL date;\n  BITCODE_BD ms;\n\n  if (dat->version < R_13)\n    {\n      date.days = bit_read_RL (dat);\n      date.ms = bit_read_RL (dat);\n    }\n  else\n    {\n      date.days = bit_read_BL (dat);\n      date.ms = bit_read_BL (dat);\n    }\n  ms = (double)date.ms;\n  while (ms > 1.0)\n    ms /= 10.0;\n  date.value = date.days + ms; // just for display, not calculations\n  return date;\n}\n\n/** Write 2 time BL bitlong (compacted data).\n * Ignores the double value.\n */\nvoid\nbit_write_TIMEBLL (Bit_Chain *dat, BITCODE_TIMEBLL date)\n{\n  if (dat->version < R_13)\n    {\n      bit_write_RL (dat, date.days);\n      bit_write_RL (dat, date.ms);\n    }\n  else\n    {\n      bit_write_BL (dat, date.days);\n      bit_write_BL (dat, date.ms);\n    }\n}\n\nBITCODE_TIMERLL\nbit_read_TIMERLL (Bit_Chain *dat)\n{\n  BITCODE_TIMERLL date;\n  BITCODE_BD ms;\n  date.days = bit_read_RL (dat);\n  date.ms = bit_read_RL (dat);\n  ms = (double)date.ms;\n  while (ms > 1.0)\n    ms /= 10.0;\n  date.value = date.days + ms; // just for display, not calculations\n  return date;\n}\n\n/** Write 2x time RL.\n *  Ignores the double value.\n */\nvoid\nbit_write_TIMERLL (Bit_Chain *dat, BITCODE_TIMERLL date)\n{\n  bit_write_RL (dat, date.days);\n  bit_write_RL (dat, date.ms);\n}\n\n/** Read color\n */\nvoid\nbit_read_CMC (Bit_Chain *restrict dat, Dwg_Color *restrict color)\n{\n  memset (color, 0, sizeof (Dwg_Color));\n  color->index = bit_read_BS (dat);\n  if (dat->version >= R_2004)\n    {\n      color->rgb = bit_read_BL (dat);\n      color->flag = bit_read_RC (dat);\n      // wide?\n      color->name = (color->flag & 1) ? (char *)bit_read_TV (dat) : NULL;\n      color->book_name = (color->flag & 2) ? (char *)bit_read_TV (dat) : NULL;\n    }\n}\n\n/** Write color\n */\nvoid\nbit_write_CMC (Bit_Chain *restrict dat, Dwg_Color *restrict color)\n{\n  bit_write_BS (dat, color->index);\n  if (dat->version >= R_2004)\n    {\n      bit_write_BL (dat, color->rgb);\n      bit_write_RC (dat, color->flag);\n      // wide?\n      if (color->flag & 1)\n        bit_write_TV (dat, color->name);\n      if (color->flag & 2)\n        bit_write_TV (dat, color->book_name);\n    }\n}\n\n/** Read entity color (2004+) (truecolor rgb and alpha support)\n *  Does also references, DBCOLOR lookups.\n */\nvoid\nbit_read_ENC (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n              Dwg_Color *restrict color)\n{\n  color->index = bit_read_BS (dat);\n  if (dat->version >= R_2004)\n    {\n      uint16_t flag = (((uint32_t)color->index) >> 8) & 0xff;\n      color->index &= 0x1ff;\n      if (flag & 0x80)\n        color->rgb = bit_read_BL (dat); // ODA bug, documented as BS\n      if (flag & 0x40)\n        {\n          color->handle = calloc (1, sizeof (Dwg_Object_Ref));\n          bit_read_H (hdl_dat, &(color->handle->handleref)); // => DBCOLOR\n          // else defer to dwg_decode_common_entity_handle_data ()\n        }\n      if (flag & 0x20)\n        {\n          BITCODE_BL alpha = bit_read_BL (dat);\n          color->alpha_type = alpha & 0xff; // 0, 1 or 3\n          color->alpha = alpha >> 8;\n        }\n      color->flag = (uint16_t)flag;\n    }\n}\n\n/** Write entity color (2004+)\n */\nvoid\nbit_write_ENC (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n               Dwg_Color *restrict color)\n{\n  bit_write_BS (dat, (color->index & 0x1ff) | (color->flag << 8));\n  if (dat->version >= R_2004)\n    {\n      uint16_t flag = color->flag;\n      if (flag & 0x20)\n        bit_write_BL (dat, color->alpha);\n      if (!(flag & 0x40) && (flag & 0x80))\n        bit_write_BL (dat, color->rgb);\n      // ?? wide?\n      if ((flag & 0x41) == 0x41)\n        bit_write_T (str_dat, color->name);\n      if ((flag & 0x42) == 0x42)\n        bit_write_T (str_dat, color->book_name);\n      if (flag & 0x40)\n        bit_write_H (hdl_dat, &(color->handle->handleref)); // => DBCOLOR\n    }\n}\n\n/** Search for a sentinel; if found, positions \"dat->byte\" immediately after it\n    and returns -1\n */\nint\nbit_search_sentinel (Bit_Chain *dat, unsigned char sentinel[16])\n{\n  long unsigned int i, j;\n\n  for (i = 0; i < dat->size; i++)\n    {\n      for (j = 0; j < 16; j++)\n        {\n          if (dat->chain[i + j] != sentinel[j])\n            break;\n        }\n      if (j == 16)\n        {\n          dat->byte = i + j;\n          dat->bit = 0;\n          return -1;\n        }\n    }\n  return 0;\n}\n\nvoid\nbit_write_sentinel (Bit_Chain *dat, unsigned char sentinel[16])\n{\n  int i;\n\n  for (i = 0; i < 16; i++)\n    bit_write_RC (dat, sentinel[i]);\n}\n\n/*\n * Allocates memory space for bit_chain\n * adds 10 4kB pages.\n */\n#define CHAIN_BLOCK 40960\nvoid\nbit_chain_alloc (Bit_Chain *dat)\n{\n  if (dat->size == 0)\n    {\n      dat->chain = (unsigned char *)calloc (1, CHAIN_BLOCK);\n      dat->size = CHAIN_BLOCK;\n      dat->byte = 0;\n      dat->bit = 0;\n    }\n  else\n    {\n      dat->chain\n          = (unsigned char *)realloc (dat->chain, dat->size + CHAIN_BLOCK);\n      dat->size += CHAIN_BLOCK;\n    }\n}\n\nvoid\nbit_print (Bit_Chain *dat, long unsigned int size)\n{\n  unsigned char sig;\n  long unsigned int i, j;\n\n  printf (\"---------------------------------------------------------\");\n  if (size > dat->size)\n    size = dat->size;\n  for (i = 0; i < size; i++)\n    {\n      if (i % 16 == 0)\n        printf (\"\\n[0x%04X]: \", (unsigned int)i);\n      printf (\"%02X \", (unsigned char)dat->chain[i]);\n      if (i % 16 == 15)\n        for (j = i - 15; j <= i; j++)\n          {\n            sig = dat->chain[j];\n            printf (\"%c\", sig >= ' ' && sig < 128 ? sig : '.');\n          }\n    }\n  puts (\"\");\n  puts (\"---------------------------------------------------------\");\n}\n\n// The i-th bit of a string.\n// 0b1000_0000,0 >> 8 = 1\n#define BIT(b, i) (((b)[(i) / 8] & (0x80 >> (i) % 8)) >> (7 - (i) % 8))\n\nvoid\nbit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)\n{\n  char *p = (char *)bits;\n  for (; *p; p++)\n    {\n      if (*p == '0' || *p == '1')\n        bit_write_B (dat, *p != '0');\n      else\n        {\n          fprintf (stderr, \"Invalid binary input %s\\n\", p);\n          return;\n        }\n    }\n}\n\n// accept a string of hex bytes with optional whitespace\nlong\nbit_write_hexbits (Bit_Chain *restrict dat, const char *restrict bytes)\n{\n  char *p = (char *)bytes;\n  long len = 0;\n  unsigned char b = '\\0';\n\n  for (; *p; p++)\n    {\n      if (*p != ' ' && *p != '\\n')\n        {\n          len++;\n          if (*p >= 'a' && *p <= 'f')\n            {\n              if (len % 2)\n                b = (*p + 10 - 'a') << 4;\n              else\n                bit_write_RC (dat, b + *p + 10 - 'a');\n            }\n          else if (*p >= 'A' && *p <= 'F')\n            {\n              if (len % 2)\n                b = (*p + 10 - 'A') << 4;\n              else\n                bit_write_RC (dat, b + *p + 10 - 'A');\n            }\n          else if (*p >= '0' && *p <= '9')\n            {\n              if (len % 2)\n                b = (*p - '0') << 4;\n              else\n                bit_write_RC (dat, b + *p - '0');\n            }\n          else\n            {\n              fprintf (stderr, \"Invalid hex input %s\\n\", p);\n              return 0;\n            }\n        }\n    }\n  return len;\n}\n\nvoid\nbit_print_bits (unsigned char *bits, long unsigned int size)\n{\n  for (long unsigned int i = 0; i < size; i++)\n    {\n      unsigned char bit = i % 8;\n      unsigned char result = (bits[i / 8] & (0x80 >> bit)) >> (7 - bit);\n      // if (i && (i % 8 == 0)) printf(\" \");\n      printf (\"%d\", result ? 1 : 0);\n    }\n  printf (\"\\n\");\n}\n\nvoid\nbit_fprint_bits (FILE *fp, unsigned char *bits, long unsigned int size)\n{\n  for (long unsigned int i = 0; i < size; i++)\n    {\n      unsigned char bit = i % 8;\n      unsigned char result = (bits[i / 8] & (0x80 >> bit)) >> (7 - bit);\n      if (i && !bit)\n        printf (\" \");\n      fprintf (fp, \"%d\", result ? 1 : 0);\n      // fprintf(fp, \"%d\", BIT(bits, i) ? 1 : 0);\n    }\n}\n\nvoid\nbit_explore_chain (Bit_Chain *dat, long unsigned int size)\n{\n  unsigned char sig;\n  long unsigned int i, k;\n\n  if (size > dat->size)\n    size = dat->size;\n\n  for (k = 0; k < 8; k++)\n    {\n      printf (\"---------------------------------------------------------\");\n      dat->byte = 0;\n      dat->bit = k;\n      for (i = 0; i < size - 1; i++)\n        {\n          if (i % 16 == 0)\n            printf (\"\\n[0x%04X]: \", (unsigned int)i);\n          sig = bit_read_RC (dat);\n          printf (\"%c\", sig >= ' ' && sig < 128 ? sig : '.');\n        }\n      puts (\"\");\n    }\n  puts (\"---------------------------------------------------------\");\n}\n\nuint16_t\nbit_calc_CRC (const uint16_t seed, unsigned char *addr, long len)\n{\n  register unsigned char al;\n  register uint16_t dx = seed;\n\n  static const uint16_t crctable[256] = {\n    0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601,\n    0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440, 0xCC01, 0x0CC0,\n    0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81,\n    0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841, 0xD801, 0x18C0, 0x1980, 0xD941,\n    0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01,\n    0x1DC0, 0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0,\n    0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081,\n    0x1040, 0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,\n    0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00,\n    0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0,\n    0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981,\n    0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41,\n    0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541, 0x2700,\n    0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0,\n    0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281,\n    0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,\n    0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01,\n    0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1,\n    0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80,\n    0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541,\n    0x7700, 0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101,\n    0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0,\n    0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481,\n    0x5440, 0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,\n    0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841, 0x8801,\n    0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1,\n    0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400, 0x84C1, 0x8581,\n    0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341,\n    0x4100, 0x81C1, 0x8081, 0x4040\n  };\n\n  for (; len > 0; len--)\n    {\n      al = (unsigned char)((*addr) ^ ((unsigned char)(dx & 0xFF)));\n      dx = ((dx >> 8) & 0xFF) ^ crctable[al];\n      addr++;\n    }\n  return dx;\n}\n\nuint32_t\nbit_calc_CRC32 (const uint32_t seed, unsigned char *addr, long len)\n{\n  register unsigned char al;\n  register uint32_t dx = ~seed; /* inverted */\n\n  static const uint32_t crctable[256] = {\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\n    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\n    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\n    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,\n    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\n    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,\n    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\n    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\n    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\n    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\n    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\n    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\n    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\n    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\n    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\n    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\n    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\n    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\n    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\n    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\n    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\n    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\n    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\n    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\n    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\n    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n  };\n\n  for (; len > 0; len--)\n    {\n      al = (unsigned char)((*addr) ^ ((unsigned char)(dx & 0xFF)));\n      dx = ((dx >> 8) & 0xFF) ^ crctable[al];\n      addr++;\n    }\n  return ~dx;\n}\n"], "fixing_code": ["/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2009,2018-2019 Free Software Foundation, Inc.              */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * bits.c: low level read and write functions\n * written by Felipe Castro\n * modified by Felipe Corr\u00eaa da Silva Sances\n * modified by Rodrigo Rodrigues da Silva\n * modified by James Mike Dupont\n * modified by Reini Urban\n */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdint.h>\n#include <inttypes.h>\n#if defined(HAVE_WCHAR_H) && defined(SIZEOF_WCHAR_T) && SIZEOF_WCHAR_T == 2\n#  include <wchar.h>\n#endif\n// else we roll our own, Latin-1 only.\n\n#ifdef DWG_ABORT\nstatic unsigned int errors = 0;\n#  ifndef DWG_ABORT_LIMIT\n#    define DWG_ABORT_LIMIT 200\n#  endif\n#endif\n\nstatic unsigned int loglevel;\n#define DWG_LOGLEVEL loglevel\n#include \"logging.h\"\n#include \"bits.h\"\n\n/*------------------------------------------------------------------------------\n * Public functions\n */\n\n/* Advance bits (forward or backward)\n */\nvoid\nbit_advance_position (Bit_Chain *dat, long advance)\n{\n  long endpos = (long)dat->bit + advance;\n  if (dat->byte >= dat->size - 1 && endpos > 7)\n    {\n      // but allow pointing to the very end.\n      if (dat->byte != dat->size - 1 || dat->bit != 0)\n        {\n          loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n          LOG_ERROR (\"%s buffer overflow at pos %lu, size %lu, advance by %ld\",\n                     __FUNCTION__, dat->byte, dat->size, advance)\n        }\n      dat->byte = dat->size - 1;\n      dat->bit = 0;\n      return;\n    }\n  if ((long)dat->byte + (endpos / 8) < 0)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"buffer underflow at pos %lu, size %lu, advance by %ld\",\n                 dat->byte, dat->size, advance)\n      dat->byte = 0;\n      dat->bit = 0;\n      return;\n    }\n  dat->byte += (endpos >> 3);\n  dat->bit = endpos & 7;\n}\n\n/* Absolute get in bits\n */\nunsigned long\nbit_position (Bit_Chain *dat)\n{\n  return (dat->byte * 8) + (dat->bit & 7);\n}\n\n/* Absolute set in bits\n */\nvoid\nbit_set_position (Bit_Chain *dat, unsigned long bitpos)\n{\n  dat->byte = bitpos >> 3;\n  dat->bit = bitpos & 7;\n  if (dat->byte > dat->size || (dat->byte == dat->size && dat->bit))\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"%s buffer overflow at %lu, have %lu\", __FUNCTION__,\n                 dat->byte, dat->size)\n    }\n}\n\n/* Set the chain so that dat->byte starts at 0 */\nvoid\nbit_reset_chain (Bit_Chain *dat)\n{\n  unsigned long pos = dat->byte;\n  dat->byte = 0;\n  if (pos < dat->size) // not already overflowed\n    dat->chain += pos;\n  if (dat->size > 0)\n    dat->size -= pos;\n}\n\n/** Read 1 bit.\n */\nBITCODE_B\nbit_read_B (Bit_Chain *dat)\n{\n  unsigned char result;\n  unsigned char byte;\n\n  if (dat->byte >= dat->size)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"%s buffer overflow at %lu\", __FUNCTION__, dat->byte)\n#ifdef DWG_ABORT\n      if (++errors > DWG_ABORT_LIMIT)\n        abort();\n#endif\n      return 0;\n    }\n  byte = dat->chain[dat->byte];\n  result = (byte & (0x80 >> dat->bit)) >> (7 - dat->bit);\n\n  bit_advance_position (dat, 1);\n  return result;\n}\n\n/** Write 1 bit.\n */\nvoid\nbit_write_B (Bit_Chain *dat, unsigned char value)\n{\n  if (dat->byte >= dat->size - 1)\n    bit_chain_alloc (dat);\n\n  if (value)\n    dat->chain[dat->byte] |= 0x80 >> dat->bit;\n  else\n    dat->chain[dat->byte] &= ~(0x80 >> dat->bit);\n\n  bit_advance_position (dat, 1);\n}\n\n/** Read 2 bits.\n */\nBITCODE_BB\nbit_read_BB (Bit_Chain *dat)\n{\n  unsigned char result;\n  unsigned char byte;\n\n  if (dat->byte >= dat->size)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"%s buffer overflow at %lu\", __FUNCTION__, dat->byte)\n#ifdef DWG_ABORT\n      if (++errors > DWG_ABORT_LIMIT)\n        abort();\n#endif\n      return 0;\n    }\n  byte = dat->chain[dat->byte];\n  if (dat->bit < 7)\n    result = (byte & (0xc0 >> dat->bit)) >> (6 - dat->bit);\n  else\n    {\n      result = (byte & 0x01) << 1;\n      if (dat->byte < dat->size - 1)\n        {\n          byte = dat->chain[dat->byte + 1];\n          result |= (byte & 0x80) >> 7;\n        }\n    }\n\n  bit_advance_position (dat, 2);\n  return result;\n}\n\n/** Write 2 bits.\n */\nvoid\nbit_write_BB (Bit_Chain *dat, unsigned char value)\n{\n  unsigned char mask;\n  unsigned char byte;\n\n  if (dat->byte >= dat->size - 1)\n    bit_chain_alloc (dat);\n\n  byte = dat->chain[dat->byte];\n  if (dat->bit < 7)\n    {\n      mask = 0xc0 >> dat->bit;\n      dat->chain[dat->byte] = (byte & ~mask) | (value << (6 - dat->bit));\n    }\n  else\n    {\n      dat->chain[dat->byte] = (byte & 0xfe) | (value >> 1);\n      if (dat->byte < dat->size - 1)\n        {\n          byte = dat->chain[dat->byte + 1];\n          dat->chain[dat->byte + 1] = (byte & 0x7f) | ((value & 0x01) << 7);\n        }\n    }\n\n  bit_advance_position (dat, 2);\n}\n\n/** Read 1-3 bits\n *  Keep reading bits until a zero bit is encountered, => 0,2,6,7.\n *  0: 0, 10: 2, 110: 6, 111: 7. 100 for 4 or 101 for 5 is invalid.\n */\nBITCODE_3B\nbit_read_3B (Bit_Chain *dat)\n{\n  BITCODE_3B result = bit_read_B (dat);\n  if (result)\n    {\n      BITCODE_3B next = bit_read_B (dat);\n      if (next)\n        {\n          next = bit_read_B (dat);\n          return next ? 7 : 6;\n        }\n      else\n        {\n          return 2;\n        }\n    }\n  else\n    {\n      return 0;\n    }\n}\n\n/** Write 1-3 bits\n */\nvoid\nbit_write_3B (Bit_Chain *dat, unsigned char value)\n{\n  if (value > 7)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"Invalid bit_write_3B value %d > 7\", value)\n      return;\n    }\n  bit_write_B (dat, value & 1);\n  if (value)\n    {\n      value >>= 1;\n      bit_write_B (dat, value & 1);\n      if (value)\n        {\n          value >>= 1;\n          bit_write_B (dat, value & 1);\n        }\n    }\n}\n\n/** Read 4 bits.\n */\nBITCODE_4BITS\nbit_read_4BITS (Bit_Chain *dat)\n{\n  // clang-format off\n  BITCODE_4BITS b =\n         bit_read_B (dat) << 3 |\n         bit_read_B (dat) << 2 |\n         bit_read_B (dat) << 1 |\n         bit_read_B (dat);\n  // clang-format on\n  return b;\n}\n\n/** Write 4 bits.\n */\nvoid\nbit_write_4BITS (Bit_Chain *dat, unsigned char value)\n{\n  bit_write_B (dat, value & 8);\n  bit_write_B (dat, value & 4);\n  bit_write_B (dat, value & 2);\n  bit_write_B (dat, value & 1);\n}\n\n/** Read 1 byte (raw char).\n */\nBITCODE_RC\nbit_read_RC (Bit_Chain *dat)\n{\n  unsigned char result;\n  unsigned char byte;\n\n  if (dat->byte >= dat->size)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"%s buffer overflow at %lu\", __FUNCTION__, dat->byte)\n#ifdef DWG_ABORT\n      if (++errors > DWG_ABORT_LIMIT)\n        abort();\n#endif\n      return 0;\n    }\n  byte = dat->chain[dat->byte];\n  if (dat->bit == 0)\n    result = byte;\n  else\n    {\n      result = byte << dat->bit;\n      if (dat->byte < dat->size - 1)\n        {\n          byte = dat->chain[dat->byte + 1];\n          result |= byte >> (8 - dat->bit);\n        }\n      else\n        {\n          loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n          LOG_ERROR (\"%s buffer overflow at %lu\", __FUNCTION__, dat->byte + 1)\n          return 0;\n        }\n    }\n\n  bit_advance_position (dat, 8);\n  return ((unsigned char)result);\n}\n\n/** Write 1 byte (raw char).\n */\nvoid\nbit_write_RC (Bit_Chain *dat, unsigned char value)\n{\n  unsigned char byte;\n  unsigned char remainder;\n\n  if (dat->byte >= dat->size - 1)\n    bit_chain_alloc (dat);\n\n  if (dat->bit == 0)\n    {\n      dat->chain[dat->byte] = value;\n    }\n  else\n    {\n      byte = dat->chain[dat->byte];\n      remainder = byte & (0xff << (8 - dat->bit));\n      dat->chain[dat->byte] = remainder | (value >> dat->bit);\n      if (dat->byte < dat->size - 1)\n        {\n          byte = dat->chain[dat->byte + 1];\n          remainder = byte & (0xff >> dat->bit);\n          dat->chain[dat->byte + 1] = remainder | (value << (8 - dat->bit));\n        }\n    }\n\n  bit_advance_position (dat, 8);\n}\n\n/** Read 1 raw short (BE short).\n */\nBITCODE_RS\nbit_read_RS (Bit_Chain *dat)\n{\n  unsigned char byte1, byte2;\n\n  // least significant byte first:\n  byte1 = bit_read_RC (dat);\n  byte2 = bit_read_RC (dat);\n  return (BITCODE_RS) ((byte2 << 8) | byte1);\n}\n\n/** Read 1 raw short little-endian.\n */\nBITCODE_RS\nbit_read_RS_LE (Bit_Chain *dat)\n{\n  unsigned char byte1, byte2;\n  byte1 = bit_read_RC (dat);\n  byte2 = bit_read_RC (dat);\n  return (BITCODE_RS) ((byte1 << 8) | byte2);\n}\n\n/** Write 1 raw short (BE short).\n */\nvoid\nbit_write_RS (Bit_Chain *dat, BITCODE_RS value)\n{\n  // least significant byte first:\n  bit_write_RC (dat, value & 0xFF);\n  bit_write_RC (dat, value >> 8);\n}\n\n/** Write 1 raw short little-endian.\n */\nvoid\nbit_write_RS_LE (Bit_Chain *dat, BITCODE_RS value)\n{\n  bit_write_RC (dat, value >> 8);\n  bit_write_RC (dat, value & 0xFF);\n}\n\n/** Read 1 raw long (4 byte, BE).\n */\nBITCODE_RL\nbit_read_RL (Bit_Chain *dat)\n{\n  BITCODE_RS word1, word2;\n\n  // least significant word first\n  word1 = bit_read_RS (dat);\n  word2 = bit_read_RS (dat);\n  return ((((uint32_t)word2) << 16) | ((uint32_t)word1));\n}\n\n/** Write 1 raw long (4 byte, BE).\n */\nvoid\nbit_write_RL (Bit_Chain *dat, BITCODE_RL value)\n{\n  const uint32_t l = value;\n  // least significant word first:\n  bit_write_RS (dat, l & 0xFFFF);\n  bit_write_RS (dat, l >> 16);\n}\n\n/** Read 1 raw long (4 byte, LE).\n */\nBITCODE_RL\nbit_read_RL_LE (Bit_Chain *dat)\n{\n  BITCODE_RS word1, word2;\n\n  // most significant word first\n  word1 = bit_read_RS_LE (dat);\n  word2 = bit_read_RS_LE (dat);\n  return ((((uint32_t)word1) << 16) | ((uint32_t)word2));\n}\n\n/** Write 1 raw long (4 byte, LE).\n */\nvoid\nbit_write_RL_LE (Bit_Chain *dat, BITCODE_RL value)\n{\n  // most significant word first:\n  bit_write_RS_LE (dat, value >> 16);\n  bit_write_RS_LE (dat, value & 0xFFFF);\n}\n\n/** Read 1 raw 64bit long (8 byte, BE).\n */\nBITCODE_RLL\nbit_read_RLL (Bit_Chain *dat)\n{\n  BITCODE_RL word1, word2;\n\n  // least significant word first\n  word1 = bit_read_RL (dat);\n  word2 = bit_read_RL (dat);\n  return ((((uint64_t)word2) << 32) | ((uint64_t)word1));\n}\n\n/** Write 1 raw 64bit long  (8 byte, BE).\n */\nvoid\nbit_write_RLL (Bit_Chain *dat, BITCODE_RLL value)\n{\n  // least significant word first\n  bit_write_RL (dat, value & 0xFFFFFFFF);\n  bit_write_RL (dat, value >> 32);\n}\n\n/** Read 1 raw double (8 bytes, IEEE-754).\n */\nBITCODE_RD\nbit_read_RD (Bit_Chain *dat)\n{\n  int i;\n  unsigned char byte[8];\n  double *result;\n\n  // TODO: I think it might not work on big-endian platforms:\n  for (i = 0; i < 8; i++)\n    byte[i] = bit_read_RC (dat);\n\n  result = (double *)byte;\n  return (*result);\n}\n\n/** Write 1 raw double (8 bytes, IEEE-754).\n */\nvoid\nbit_write_RD (Bit_Chain *dat, double value)\n{\n  int i;\n  unsigned char *val;\n\n  // TODO: I think it might not work on big-endian platforms:\n  val = (unsigned char *)&value;\n\n  for (i = 0; i < 8; i++)\n    bit_write_RC (dat, val[i]);\n}\n\n/** Read 1 bitshort (compacted data).\n */\nBITCODE_BS\nbit_read_BS (Bit_Chain *dat)\n{\n  const unsigned char two_bit_code = bit_read_BB (dat);\n  if (two_bit_code == 0)\n    return bit_read_RS (dat);\n  else if (two_bit_code == 1)\n    return (BITCODE_BS)bit_read_RC (dat) & 0xFF;\n  else if (two_bit_code == 2)\n    return 0;\n  else /* if (two_bit_code == 3) */\n    return 256;\n}\n\n/** Write 1 bitshort (compacted data).\n */\nvoid\nbit_write_BS (Bit_Chain *dat, BITCODE_BS value)\n{\n  // BITCODE_BS is defined as uint16_t, but better safe than sorry\n  const uint16_t l = value;\n  if (l > 256)\n    {\n      bit_write_BB (dat, 0);\n      bit_write_RS (dat, value);\n    }\n  else if (value == 0)\n    bit_write_BB (dat, 2);\n  else if (value == 256)\n    bit_write_BB (dat, 3);\n  else\n    {\n      bit_write_BB (dat, 1);\n      bit_write_RC (dat, value);\n    }\n}\n\n/** Read 1 bitlong (compacted data).\n */\nBITCODE_BL\nbit_read_BL (Bit_Chain *dat)\n{\n  const unsigned char two_bit_code = bit_read_BB (dat);\n  if (two_bit_code == 0)\n    return bit_read_RL (dat);\n  else if (two_bit_code == 1)\n    return bit_read_RC (dat) & 0xFF;\n  else if (two_bit_code == 2)\n    return 0;\n  else /* if (two_bit_code == 3) */\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"bit_read_BL: unexpected 2-bit code: '11'\")\n      return 256;\n    }\n}\n\n/** Write 1 bitlong (compacted data).\n */\nvoid\nbit_write_BL (Bit_Chain *dat, BITCODE_BL value)\n{\n  // BITCODE_BL is signed int32_t\n  const uint32_t l = value;\n  if (l > 255)\n    {\n      bit_write_BB (dat, 0);\n      bit_write_RL (dat, value);\n    }\n  else if (l == 0)\n    bit_write_BB (dat, 2);\n  else\n    {\n      bit_write_BB (dat, 1);\n      bit_write_RC (dat, value);\n    }\n}\n\n/** Write signed bitlong (compacted data).\n */\nvoid\nbit_write_BLd (Bit_Chain *dat, BITCODE_BLd value)\n{\n  const BITCODE_BL l = value;\n  if (l > 255)\n    {\n      bit_write_BB (dat, 0);\n      bit_write_RL (dat, (BITCODE_RL)value);\n    }\n  else if (l == 0)\n    bit_write_BB (dat, 2);\n  else\n    {\n      bit_write_BB (dat, 1);\n      bit_write_RC (dat, value);\n    }\n}\n\n/** Read object type 2010+ (BB + 1 or 2 bytes).\n *  par 2.12\n */\nBITCODE_BS\nbit_read_BOT (Bit_Chain *dat)\n{\n  unsigned char two_bit_code;\n\n  two_bit_code = bit_read_BB (dat);\n\n  if (two_bit_code == 0)\n    return bit_read_RC (dat);\n  else if (two_bit_code == 1)\n    return bit_read_RC (dat) + 0x1f0;\n  else\n    return bit_read_RS (dat);\n}\n\n/** Write object type 2010+ (BB + 1 or 2 bytes).\n */\nvoid\nbit_write_BOT (Bit_Chain *dat, BITCODE_BS value)\n{\n  if (value < 256)\n    {\n      bit_write_BB (dat, 0);\n      bit_write_RC (dat, value);\n    }\n  else if (value < 0x7fff)\n    {\n      bit_write_BB (dat, 1);\n      bit_write_RC (dat, value - 0x1f0);\n    }\n  else\n    {\n      bit_write_BB (dat, 1);\n      bit_write_RS (dat, value);\n    }\n}\n\n/** Read 1 bitlonglong (compacted uint64_t) for REQUIREDVERSIONS, preview_size.\n *  ODA doc bug. ODA say 1-3 bits until the first 0 bit. See 3BLL.\n *  The first 3 bits indicate the length l (see paragraph 2.1). Then\n *  l bytes follow, which represent the number (the least significant\n *  byte is first).\n */\nBITCODE_BLL\nbit_read_BLL (Bit_Chain *dat)\n{\n  unsigned int i, len;\n  BITCODE_BLL result = 0ULL;\n  len = bit_read_BB (dat) << 1 | bit_read_B (dat);\n  switch (len)\n    {\n    case 1:\n      return bit_read_RC (dat);\n    case 2:\n      return bit_read_RS (dat);\n    case 4:\n      return bit_read_RL (dat);\n    default:\n      for (i = 0; i < len; i++)\n        {\n          result <<= 8;\n          result |= bit_read_RC (dat);\n        }\n      return result;\n    }\n}\n\n/** Read 1 bitlonglong (compacted uint64_t) as documented (but unused).\n *  The first 1-3 bits indicate the length l (see paragraph 2.1). Then\n *  l bytes follow, which represent the number (the least significant\n *  byte is first).\n */\nBITCODE_BLL\nbit_read_3BLL (Bit_Chain *dat)\n{\n  unsigned int i, len;\n  BITCODE_BLL result = 0ULL;\n  len = bit_read_3B (dat);\n  for (i = 0; i < len; i++)\n    {\n      result <<= 8;\n      result |= bit_read_RC (dat);\n    }\n  return result;\n}\n\n/** Write 1 bitlonglong (compacted data).\n */\nvoid\nbit_write_BLL (Bit_Chain *dat, BITCODE_BLL value)\n{\n  // 64bit into how many bytes?\n  int i;\n  int len = 0;\n  BITCODE_BLL umax = 0xf000000000000000ULL;\n  for (i = 16; i; i--, umax >>= 8)\n    {\n      if (value & umax)\n        {\n          len = i;\n          break;\n        }\n    }\n  bit_write_BB (dat, len << 2);\n  bit_write_B (dat, len & 1);\n  for (i = 0; i < len; i++)\n    {\n      // least significant byte first\n      bit_write_RC (dat, value & 0xFF);\n      value >>= 8;\n    }\n}\nvoid\nbit_write_3BLL (Bit_Chain *dat, BITCODE_BLL value)\n{\n  // 64bit into how many bytes?\n  int i;\n  int len = 0;\n  BITCODE_BLL umax = 0xf000000000000000ULL;\n  for (i = 16; i; i--, umax >>= 8)\n    {\n      if (value & umax)\n        {\n          len = i;\n          break;\n        }\n    }\n  bit_write_3B (dat, len);\n  for (i = 0; i < len; i++)\n    {\n      // least significant byte first\n      bit_write_RC (dat, value & 0xFF);\n      value >>= 8;\n    }\n}\n\n/** Read 1 bitdouble (compacted data).\n */\nBITCODE_BD\nbit_read_BD (Bit_Chain *dat)\n{\n  unsigned char two_bit_code;\n\n  two_bit_code = bit_read_BB (dat);\n  if (two_bit_code == 0)\n    return bit_read_RD (dat);\n  else if (two_bit_code == 1)\n    return 1.0;\n  else if (two_bit_code == 2)\n    return 0.0;\n  else /* if (two_bit_code == 3) */\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"bit_read_BD: unexpected 2-bit code: '11'\")\n      return bit_nan ();\n    }\n}\n\n/* create a Not-A-Number (NaN) without libm dependency */\nBITCODE_BD\nbit_nan (void)\n{\n  double result;\n  int32_t *res = (int32_t *)&result;\n  res[0] = -1;\n  res[1] = -1;\n  return result;\n}\n\nint\nbit_isnan (BITCODE_BD number)\n{\n  int32_t *res = (int32_t *)&number;\n  return (res[0] == -1 && res[1] == -1);\n}\n\n/** Write 1 bitdouble (compacted data).\n */\nvoid\nbit_write_BD (Bit_Chain *dat, double value)\n{\n  if (value == 0.0)\n    bit_write_BB (dat, 2);\n  else if (value == 1.0)\n    bit_write_BB (dat, 1);\n  else\n    {\n      bit_write_BB (dat, 0);\n      bit_write_RD (dat, value);\n    }\n}\n\n/** Read 1 modular char (max 5 bytes, signed).\n    Read bytes until the high bit of the byte is 0, drop the highest bit and\n pad with 0. If the last byte has 0x40 set, it's negative. Since the result is\n int32_t (4 byte), but there needs to be the high/follow bit set, the stream\n can be max 5 byte long (5*7 = 35 bit) 10000000 10000000 10000000 10000000\n 00000100\n =>  0000000  0000000  0000000  0000000  0000100 (5*7 = 35)\n => 00001000 00000000 00000000 00000000          (4*8 = 32)\n */\nBITCODE_MC\nbit_read_MC (Bit_Chain *dat)\n{\n  int i, j;\n  int negative;\n  unsigned char byte[5];\n  BITCODE_UMC result;\n\n  negative = 0;\n  result = 0;\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = bit_read_RC (dat);\n      if (!(byte[i] & 0x80))\n        {\n          if ((byte[i] & 0x40))\n            {\n              negative = 1;\n              byte[i] &= 0xbf;\n            }\n          result |= (((BITCODE_UMC)byte[i]) << j);\n          return (negative ? -((BITCODE_MC)result) : (BITCODE_MC)result);\n        }\n      else\n        byte[i] &= 0x7f;\n\n      result |= ((BITCODE_UMC)byte[i]) << j;\n    }\n\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n  LOG_ERROR (\n      \"bit_read_MC: error parsing modular char. i=%d, j=%d, result=0x%lx,\\n\"\n      \" @%lu.@%u: [0x%x 0x%x 0x%x 0x%x 0x%x]\",\n      i, j, result, dat->byte - 5, dat->bit, dat->chain[dat->byte - 5],\n      dat->chain[dat->byte - 4], dat->chain[dat->byte - 3],\n      dat->chain[dat->byte - 2], dat->chain[dat->byte - 1])\n  return 0; /* error... */\n}\n\n/** Write 1 modular char (max 5 bytes, signed).\n */\nvoid\nbit_write_MC (Bit_Chain *dat, BITCODE_MC val)\n{\n  int i, j;\n  int negative = 0;\n  unsigned char byte[5];\n  BITCODE_UMC mask = 0x0000007f;\n  BITCODE_UMC value = (BITCODE_UMC)val;\n\n  if (val < 0)\n    {\n      negative = 1;\n      value = (BITCODE_UMC)-val;\n    }\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  if (negative)\n    byte[i] |= 0x40;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}\n\n/** Read unsigned modular char (max 5 bytes, unsigned).\n    Can be quite large if there are many deleted handles.\n */\nBITCODE_UMC\nbit_read_UMC (Bit_Chain *dat)\n{\n  int i, j;\n  // eg handle FD485E65F\n  #define MAX_BYTE_UMC 6\n  unsigned char byte[MAX_BYTE_UMC];\n  BITCODE_UMC result;\n\n  result = 0;\n  for (i = MAX_BYTE_UMC-1, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = bit_read_RC (dat);\n      if (!(byte[i] & 0x80))\n        {\n          result |= (((BITCODE_UMC)byte[i]) << j);\n          return result;\n        }\n      else\n        byte[i] &= 0x7f;\n\n      result |= ((BITCODE_UMC)byte[i]) << j;\n    }\n\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n  LOG_ERROR (\n      \"bit_read_UMC: error parsing modular char, i=%d,j=%d,result=0x%lx\", i, j,\n      result)\n  LOG_HANDLE (\"  @%lu.%u: [0x%x 0x%x 0x%x 0x%x 0x%x]\\n\", dat->byte - 5,\n            dat->bit, dat->chain[dat->byte - 5], dat->chain[dat->byte - 4],\n            dat->chain[dat->byte - 3], dat->chain[dat->byte - 2],\n            dat->chain[dat->byte - 1])\n  return 0; /* error... */\n}\n\n/** Write 1 modular char (max 5 bytes, unsigned).\n */\nvoid\nbit_write_UMC (Bit_Chain *dat, BITCODE_UMC val)\n{\n  int i, j;\n  int negative;\n  unsigned char byte[5];\n  BITCODE_UMC mask;\n  BITCODE_UMC value;\n\n  value = val;\n  mask = 0x0000007f;\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n\n  if (byte[i] & 0x40 && i > 0)\n    i--;\n  byte[i] &= 0x7f;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}\n\n/** Read 1 modular short (max 2 words).\n */\nBITCODE_MS\nbit_read_MS (Bit_Chain *dat)\n{\n  int i, j;\n  BITCODE_RS word[2];\n  BITCODE_MS result;\n\n  result = 0;\n  for (i = 1, j = 0; i > -1; i--, j += 15)\n    {\n      word[i] = bit_read_RS (dat);\n      if (!(word[i] & 0x8000))\n        {\n          result |= (((BITCODE_MS)word[i]) << j);\n          return (BITCODE_MS)result;\n        }\n      else\n        word[i] &= 0x7fff;\n      result |= ((BITCODE_MS)word[i]) << j;\n    }\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n  LOG_ERROR (\"bit_read_MS: error parsing modular short, i=%d,j=%d\", i, j)\n  return 0; /* error... */\n}\n\n/** Write 1 modular short (max 2 words).\n */\nvoid\nbit_write_MS (Bit_Chain *dat, BITCODE_MS value)\n{\n  if (value > 0x7fff)\n    {\n      bit_write_RS (dat, (value & 0xffff8000) >> 15);\n      bit_write_RS (dat, value & 0x7fff);\n    }\n  else\n    {\n      bit_write_RS (dat, value);\n    }\n}\n\n/** Read bit-extrusion.\n */\nvoid\nbit_read_BE (Bit_Chain *restrict dat, double *restrict x, double *restrict y,\n             double *restrict z)\n{\n  if (dat->version >= R_2000 && bit_read_B (dat))\n    {\n      *x = 0.0;\n      *y = 0.0;\n      *z = 1.0;\n    }\n  else\n    {\n      *x = bit_read_BD (dat);\n      *y = bit_read_BD (dat);\n      *z = bit_read_BD (dat);\n    }\n}\n\n/** Write bit-extrusion.\n */\nvoid\nbit_write_BE (Bit_Chain *dat, double x, double y, double z)\n{\n  if (dat->version >= R_2000 && x == 0.0 && y == 0.0 && z == 1.0)\n    bit_write_B (dat, 1);\n  else\n    {\n      bit_write_B (dat, 0);\n      bit_write_BD (dat, x);\n      bit_write_BD (dat, y);\n      bit_write_BD (dat, z);\n    }\n}\n\n/** Read bit-double with default.\n */\nBITCODE_DD\nbit_read_DD (Bit_Chain *dat, double default_value)\n{\n  unsigned char two_bit_code;\n  unsigned char *uchar_result;\n\n  two_bit_code = bit_read_BB (dat);\n  if (two_bit_code == 0)\n    return default_value;\n  if (two_bit_code == 3)\n    return (bit_read_RD (dat));\n  if (two_bit_code == 2)\n    {\n      uchar_result = (unsigned char *)&default_value;\n      uchar_result[4] = bit_read_RC (dat);\n      uchar_result[5] = bit_read_RC (dat);\n      uchar_result[0] = bit_read_RC (dat);\n      uchar_result[1] = bit_read_RC (dat);\n      uchar_result[2] = bit_read_RC (dat);\n      uchar_result[3] = bit_read_RC (dat);\n\n      return default_value;\n    }\n  else /* if (two_bit_code == 1) */\n    {\n      uchar_result = (unsigned char *)&default_value;\n      uchar_result[0] = bit_read_RC (dat);\n      uchar_result[1] = bit_read_RC (dat);\n      uchar_result[2] = bit_read_RC (dat);\n      uchar_result[3] = bit_read_RC (dat);\n\n      return default_value;\n    }\n}\n\n/** Write bit-double with default.\n */\nvoid\nbit_write_DD (Bit_Chain *dat, double value, double default_value)\n{\n  unsigned char *uchar_value;\n\n  unsigned int *uint_value;\n  unsigned int *uint_default;\n\n  if (value == default_value)\n    bit_write_BB (dat, 0);\n  else\n    {\n      uchar_value = (unsigned char *)&value;\n      uint_value = (unsigned int *)&value;\n      uint_default = (unsigned int *)&default_value;\n      if (uint_value[0] == uint_default[0])\n        {\n          if (uint_value[1] != uint_default[1])\n            {\n              bit_write_BB (dat, 2);\n              bit_write_RC (dat, uchar_value[4]);\n              bit_write_RC (dat, uchar_value[5]);\n              bit_write_RC (dat, uchar_value[0]);\n              bit_write_RC (dat, uchar_value[1]);\n              bit_write_RC (dat, uchar_value[2]);\n              bit_write_RC (dat, uchar_value[3]);\n            }\n          else\n            {\n              bit_write_BB (dat, 1);\n              bit_write_RC (dat, uchar_value[0]);\n              bit_write_RC (dat, uchar_value[1]);\n              bit_write_RC (dat, uchar_value[2]);\n              bit_write_RC (dat, uchar_value[3]);\n            }\n        }\n      else\n        {\n          bit_write_BB (dat, 3);\n          bit_write_RD (dat, value);\n        }\n    }\n}\n\n/** Read bit-thickness.\n */\nBITCODE_BT\nbit_read_BT (Bit_Chain *dat)\n{\n  int mode = 0;\n\n  if (dat->version >= R_2000)\n    mode = bit_read_B (dat);\n\n  return (mode ? 0.0 : bit_read_BD (dat));\n}\n\n/** Write bit-thickness.\n */\nvoid\nbit_write_BT (Bit_Chain *dat, double value)\n{\n  if (dat->version >= R_2000 && value == 0.0)\n    bit_write_B (dat, 1);\n  else\n    {\n      bit_write_B (dat, 0);\n      bit_write_BD (dat, value);\n    }\n}\n\n/** Read handle-references. Returns error code: DWG_ERR_INVALIDHANDLE\n *  or 0 on success.\n */\nint\nbit_read_H (Bit_Chain *restrict dat, Dwg_Handle *restrict handle)\n{\n  int i;\n\n  handle->code = bit_read_RC (dat);\n  handle->size = handle->code & 0x0f;\n  handle->code = (handle->code & 0xf0) >> 4;\n\n  handle->value = 0;\n  if (handle->size > sizeof(BITCODE_RC *) || handle->code > 14)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_WARN (\"Invalid handle-reference, longer than 8 bytes: \" FORMAT_H,\n                ARGS_H (*handle))\n      return DWG_ERR_INVALIDHANDLE;\n    }\n\n  // TODO: little-endian only\n  // x86_64 gcc-9 miscompilation with val[i]: (%rbx) being dat+1\n#if defined(__GNUC__) && (__GNUC__ == 9) && (__GNUC_MINOR__ <= 2) \\\n  && (SIZEOF_SIZE_T == 8)                                         \\\n  && (defined(__x86_64__) || defined(__x86_64) || defined(_M_AMD64) || defined(_M_X64))\n  {\n#warning x86_64 gcc-9.2 codegen is seriously broken! better use an older version\n    BITCODE_RC *restrict val;\n    val = (BITCODE_RC *)&(handle->value);\n    for (i = handle->size - 1; i >= 0; i--)\n      {\n        BITCODE_RC c = bit_read_RC (dat);\n        val[i] = c;\n      }\n  }\n#else\n  {\n    BITCODE_RC *restrict val;\n    val = (BITCODE_RC *)&(handle->value);\n    for (i = handle->size - 1; i >= 0; i--)\n      val[i] = bit_read_RC (dat);\n  }\n#endif\n\n  return 0;\n}\n\n/** Write handle-references.\n */\nvoid\nbit_write_H (Bit_Chain *restrict dat, Dwg_Handle *restrict handle)\n{\n  int i;\n  unsigned char *val;\n  unsigned char size;\n\n  if (!handle)\n    {\n      bit_write_RC (dat, 0);\n      return;\n    }\n  if (handle->value == 0)\n    {\n      bit_write_RC (dat, handle->code << 4);\n      return;\n    }\n\n  // TODO: little-endian only. support sizes <= 8, not just 4\n  memset (&val, 0, sizeof(val));\n  val = (unsigned char *)&handle->value;\n  for (i = sizeof(val) - 1; i >= 0; i--)\n    if (val[i])\n      break;\n\n  size = handle->code << 4;\n  size |= i + 1;\n  bit_write_RC (dat, size);\n\n  for (; i >= 0; i--)\n    bit_write_RC (dat, val[i]);\n}\n\n/** Only read old 16bit CRC-numbers, without checking, only in order\n *  to go to the next byte, while skipping non-aligned bits.\n */\nuint16_t\nbit_read_CRC (Bit_Chain *dat)\n{\n  uint16_t result;\n  long unsigned int start_address;\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n\n  if (dat->bit > 0)\n    {\n      dat->byte++;\n      dat->bit = 0;\n    }\n  start_address = dat->byte;\n  result = bit_read_RS (dat);\n  LOG_TRACE (\"read CRC at %lu: %04X\\n\", start_address, result)\n\n  return result;\n}\n\n/** Read and check old 16bit CRC.\n */\nint\nbit_check_CRC (Bit_Chain *dat, long unsigned int start_address, uint16_t seed)\n{\n  uint16_t calculated;\n  uint16_t read;\n  long size;\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n\n  if (dat->bit > 0)\n    {\n      dat->byte++;\n      dat->bit = 0;\n    }\n\n  if (start_address > dat->byte || dat->byte >= dat->size)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"%s buffer overflow at pos %lu-%lu, size %lu\", __FUNCTION__,\n                 start_address, dat->byte, dat->size)\n      return 0;\n    }\n\n  size = dat->byte - start_address;\n  calculated = bit_calc_CRC (seed, &dat->chain[start_address], size);\n  read = bit_read_RS (dat);\n  LOG_TRACE (\"crc: %04X [RSx]\\n\", read);\n  if (calculated == read)\n    {\n      LOG_HANDLE (\" check_CRC %lu-%lu = %ld: %04X == %04X\\n\", start_address,\n                  dat->byte - 2, size, calculated, read)\n      return 1;\n    }\n  else\n    {\n      LOG_WARN (\"check_CRC mismatch %lu-%lu = %ld: %04X <=> %04X\\n\",\n                start_address, dat->byte - 2, size, calculated, read)\n      return 0;\n    }\n}\n\n/** Create and write old 16bit CRC.\n */\nuint16_t\nbit_write_CRC (Bit_Chain *dat, long unsigned int start_address, uint16_t seed)\n{\n  uint16_t crc;\n  long size;\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n\n  while (dat->bit > 0)\n    bit_write_B (dat, 0);\n\n  size = dat->byte - start_address;\n  crc = bit_calc_CRC (seed, &dat->chain[start_address], size);\n\n  LOG_TRACE (\"write CRC %04X from %lu-%lu = %ld\\n\", crc, start_address,\n             dat->byte, size);\n  bit_write_RS (dat, crc);\n  return crc;\n}\n\nuint16_t\nbit_write_CRC_LE (Bit_Chain *dat, long unsigned int start_address, uint16_t seed)\n{\n  uint16_t crc;\n  long size;\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n\n  while (dat->bit > 0)\n    bit_write_B (dat, 0);\n\n  size = dat->byte - start_address;\n  crc = bit_calc_CRC (seed, &dat->chain[start_address], size);\n\n  LOG_TRACE (\"write CRC %04X from %lu-%lu = %ld\\n\", crc, start_address,\n             dat->byte, size);\n  bit_write_RS_LE (dat, crc);\n  return crc;\n}\n\nvoid\nbit_read_fixed (Bit_Chain *restrict dat, BITCODE_RC *restrict dest, int length)\n{\n  for (int i = 0; i < length; i++)\n    {\n      dest[i] = bit_read_RC (dat);\n    }\n}\n\n/** Read fixed text with zero-termination.\n *  After usage, the allocated memory must be properly freed.\n *  preR11\n */\nBITCODE_TF\nbit_read_TF (Bit_Chain *restrict dat, int length)\n{\n  BITCODE_RC *chain = malloc (length + 1);\n\n  bit_read_fixed (dat, chain, length);\n  chain[length] = '\\0';\n\n  return (BITCODE_TF)chain;\n}\n\n/** Write fixed text. Without ending \\0\n */\nvoid\nbit_write_TF (Bit_Chain *restrict dat, BITCODE_TF restrict chain, int length)\n{\n  int i;\n  for (i = 0; i < length; i++)\n    bit_write_RC (dat, (BITCODE_RC)chain[i]);\n}\n\n/** Read simple text. After usage, the allocated memory must be properly freed.\n */\nBITCODE_TV\nbit_read_TV (Bit_Chain *restrict dat)\n{\n  unsigned int i;\n  unsigned int length;\n  unsigned char *chain;\n\n  length = bit_read_BS (dat);\n  if (dat->byte + length >= dat->size)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"%s buffer overflow at %lu, length %u\", __FUNCTION__,\n                 dat->byte, length)\n      return NULL;\n    }\n  chain = (unsigned char *)malloc (length + 1);\n  for (i = 0; i < length; i++)\n    {\n      chain[i] = bit_read_RC (dat);\n#if 0\n      /* we support encode and codepages */\n      if (!isprint (chain[i]))\n        chain[i] = '~';\n#endif\n    }\n  chain[i] = '\\0';\n\n  return (char *)chain;\n}\n\n/** Write simple text.\n */\nvoid\nbit_write_TV (Bit_Chain *restrict dat, BITCODE_TV restrict chain)\n{\n  int i;\n  int length;\n\n  length = chain ? strlen ((const char *)chain) + 1 : 0;\n  bit_write_BS (dat, length);\n  for (i = 0; i < length; i++)\n    bit_write_RC (dat, (unsigned char)chain[i]);\n}\n\n/** Read UCS-2 unicode text. no supplementary planes\n * See also bfr_read_string()\n */\nBITCODE_TU\nbit_read_TU (Bit_Chain *restrict dat)\n{\n  unsigned int i;\n  unsigned int length;\n  BITCODE_TU chain;\n\n  length = bit_read_BS (dat);\n  if (dat->byte + (length * 2) >= dat->size)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"%s buffer overflow at %lu, length %u\", __FUNCTION__,\n                 dat->byte, length)\n      return NULL;\n    }\n  chain = (BITCODE_TU)malloc ((length + 1) * 2);\n  for (i = 0; i < length; i++)\n    {\n      chain[i] = bit_read_RS (dat); // probably without byte swapping\n    }\n  chain[length] = 0;\n\n  return chain;\n}\n\n/** Write UCS-2 unicode text. Must be zero-delimited.\n */\nvoid\nbit_write_TU (Bit_Chain *restrict dat, BITCODE_TU restrict chain)\n{\n  unsigned int i;\n  unsigned int length;\n\n  if (chain)\n    {\n#if defined(HAVE_WCHAR_H) && defined(SIZEOF_WCHAR_T) && SIZEOF_WCHAR_T == 2\n      length = wcslen (chain) + 1;\n#else\n      for (length = 0; chain[length]; length++)\n        ;\n      length++;\n#endif\n    }\n  else\n    length = 0;\n\n  bit_write_BS (dat, length);\n  for (i = 0; i < length; i++)\n    {\n      bit_write_RS (dat, chain[i]); // probably without byte swapping\n    }\n  bit_write_RS (dat, 0); //?? unsure about that\n}\n\nBITCODE_T\nbit_read_T (Bit_Chain *restrict dat)\n{\n  if (dat->version >= R_2007)\n    return (BITCODE_T)bit_read_TU (dat);\n  else\n    return (BITCODE_T)bit_read_TV (dat);\n}\n\nvoid\nbit_write_T (Bit_Chain *restrict dat, BITCODE_T restrict chain)\n{\n  if (dat->version >= R_2007)\n    return bit_write_TU (dat, (BITCODE_TU)chain);\n  else\n    return bit_write_TV (dat, chain);\n}\n\n/* converts UCS-2 to UTF-8 */\nchar *\nbit_convert_TU (BITCODE_TU restrict wstr)\n{\n  BITCODE_TU tmp = wstr;\n  char *str;\n  int i, len = 0;\n  uint16_t c = 0;\n\n  if (!wstr)\n    return NULL;\n#ifdef HAVE_ALIGNED_ACCESS_REQUIRED\n  /* access bytewise. cannot copy to heap yet, because we have no length */\n  if ((uintptr_t)wstr % SIZEOF_SIZE_T)\n    {\n      unsigned char *b = (unsigned char*)wstr;\n      c = (b[0] << 8) + b[1];\n      while (c)\n        {\n          len++;\n          if (c >= 256)\n            len++;\n          if (c >= 0x800)\n            len++;\n          b += 2;\n          c = (b[0] << 8) + b[1];\n        }\n    }\n  else\n#endif\n  while ((c = *tmp++))\n    {\n      len++;\n      if (c >= 256)\n        len++;\n      if (c >= 0x800)\n        len++;\n#if 0\n        loglevel = 5;\n        LOG_INSANE (\"U+%04X \", c);\n#endif\n    }\n  str = malloc (len + 1);\n  i = 0;\n#ifdef HAVE_ALIGNED_ACCESS_REQUIRED\n  if ((uintptr_t)wstr % SIZEOF_SIZE_T)\n    {\n      unsigned char *b = (unsigned char*)wstr;\n      c = (b[0] << 8) + b[1];\n      while (c)\n        {\n          if (c < 256)\n            {\n              str[i++] = c & 0xFF;\n            }\n          else if (c < 0x800)\n            {\n              str[i++] = (c >> 6) | 0xC0;\n              str[i++] = (c & 0x3F) | 0x80;\n            }\n          else /* if (c < 0x10000) */\n            {\n              str[i++] = (c >> 12) | 0xE0;\n              str[i++] = ((c >> 6) & 0x3F) | 0x80;\n              str[i++] = (c & 0x3F) | 0x80;\n            }\n\n          b += 2;\n          c = (b[0] << 8) + b[1];\n        }\n    }\n  else\n#endif\n  while ((c = *wstr++))\n    {\n      if (c < 256)\n        {\n          str[i++] = c & 0xFF;\n        }\n      else if (c < 0x800)\n        {\n          str[i++] = (c >> 6) | 0xC0;\n          str[i++] = (c & 0x3F) | 0x80;\n        }\n      else /* if (c < 0x10000) */\n        { /* windows ucs-2 has no D800-DC00 surrogate pairs. go straight up */\n          /*if (i+3 > len) {\n            str = realloc(str, i+3);\n            len = i+2;\n          }*/\n          str[i++] = (c >> 12) | 0xE0;\n          str[i++] = ((c >> 6) & 0x3F) | 0x80;\n          str[i++] = (c & 0x3F) | 0x80;\n        }\n      /*\n      else if (c < 0x110000)\n        {\n          str[i++] = (c >> 18) | 0xF0;\n          str[i++] = ((c >> 12) & 0x3F) | 0x80;\n          str[i++] = ((c >> 6) & 0x3F) | 0x80;\n          str[i++] = (c & 0x3F) | 0x80;\n        }\n      else\n        fprintf (stderr, \"ERROR: overlarge unicode codepoint U+%0X\", c);\n     */\n    }\n  str[i] = '\\0';\n  return str;\n}\n\n/** converts UTF-8 to UCS-2. Returns a copy */\nBITCODE_TU\nbit_utf8_to_TU (char *restrict str)\n{\n  BITCODE_TU wstr;\n  int i = 0;\n  int len = strlen (str);\n  unsigned char c;\n\n  wstr = malloc (2 * (len + 1));\n  while ((c = *str++))\n    {\n      if (c < 128)\n        {\n          wstr[i++] = c;\n        }\n      else if ((c & 0xe0) == 0xc0)\n        {\n          /* ignore invalid utf8 for now */\n          wstr[i++] = ((c & 0x1f) << 6) | (str[1] & 0x3f);\n          str++;\n        }\n      else if ((c & 0xf0) == 0xe0)\n        {\n          /* ignore invalid utf8? */\n          if ((unsigned char)str[1] < 0x80 || (unsigned char)str[1] > 0xBF\n              || (unsigned char)str[2] < 0x80 || (unsigned char)str[2] > 0xBF)\n            {\n              LOG_WARN (\"utf-8: BAD_CONTINUATION_BYTE %s\", str);\n            }\n          if (c == 0xe0 && (unsigned char)str[1] < 0xa0)\n            {\n              LOG_WARN (\"utf-8: NON_SHORTEST %s\", str);\n            }\n          wstr[i++]\n              = ((c & 0x0f) << 12) | ((str[1] & 0x3f) << 6) | (str[2] & 0x3f);\n          str++;\n          str++;\n        }\n      /* everything above 0xf0 exceeds ucs-2, 4-6 byte seqs */\n    }\n  wstr[i] = '\\0';\n  return wstr;\n}\n\n/* compare an ASCII/utf-8 string to a r2007+ name */\nint\nbit_eq_TU (const char *restrict str, BITCODE_TU restrict wstr)\n{\n  char *utf8 = bit_convert_TU (wstr);\n  int result = strcmp (str, utf8) ? 0 : 1;\n  free (utf8);\n  return result;\n}\n\n/** Read 1 bitlong according to normal order\n */\nBITCODE_RL\nbit_read_L (Bit_Chain *dat) { return bit_read_RL_LE (dat); }\n\n/** Write 1 bitlong according to normal order\n */\nvoid\nbit_write_L (Bit_Chain *dat, BITCODE_RL value)\n{\n  bit_write_RL_LE (dat, value);\n  return;\n}\n\n/** Read 2 time BL bitlong (compacted data).\n *  julian day + milliseconds\n *  used for TDCREATE, TDUPDATE, and all other DATE variables.\n *  pre-R13 read 2xRL\n */\nBITCODE_TIMEBLL\nbit_read_TIMEBLL (Bit_Chain *dat)\n{\n  BITCODE_TIMEBLL date;\n  BITCODE_BD ms;\n\n  if (dat->version < R_13)\n    {\n      date.days = bit_read_RL (dat);\n      date.ms = bit_read_RL (dat);\n    }\n  else\n    {\n      date.days = bit_read_BL (dat);\n      date.ms = bit_read_BL (dat);\n    }\n  ms = (double)date.ms;\n  while (ms > 1.0)\n    ms /= 10.0;\n  date.value = date.days + ms; // just for display, not calculations\n  return date;\n}\n\n/** Write 2 time BL bitlong (compacted data).\n * Ignores the double value.\n */\nvoid\nbit_write_TIMEBLL (Bit_Chain *dat, BITCODE_TIMEBLL date)\n{\n  if (dat->version < R_13)\n    {\n      bit_write_RL (dat, date.days);\n      bit_write_RL (dat, date.ms);\n    }\n  else\n    {\n      bit_write_BL (dat, date.days);\n      bit_write_BL (dat, date.ms);\n    }\n}\n\nBITCODE_TIMERLL\nbit_read_TIMERLL (Bit_Chain *dat)\n{\n  BITCODE_TIMERLL date;\n  BITCODE_BD ms;\n  date.days = bit_read_RL (dat);\n  date.ms = bit_read_RL (dat);\n  ms = (double)date.ms;\n  while (ms > 1.0)\n    ms /= 10.0;\n  date.value = date.days + ms; // just for display, not calculations\n  return date;\n}\n\n/** Write 2x time RL.\n *  Ignores the double value.\n */\nvoid\nbit_write_TIMERLL (Bit_Chain *dat, BITCODE_TIMERLL date)\n{\n  bit_write_RL (dat, date.days);\n  bit_write_RL (dat, date.ms);\n}\n\n/** Read color\n */\nvoid\nbit_read_CMC (Bit_Chain *restrict dat, Dwg_Color *restrict color)\n{\n  memset (color, 0, sizeof (Dwg_Color));\n  color->index = bit_read_BS (dat);\n  if (dat->version >= R_2004)\n    {\n      color->rgb = bit_read_BL (dat);\n      color->flag = bit_read_RC (dat);\n      // wide?\n      color->name = (color->flag & 1) ? (char *)bit_read_TV (dat) : NULL;\n      color->book_name = (color->flag & 2) ? (char *)bit_read_TV (dat) : NULL;\n    }\n}\n\n/** Write color\n */\nvoid\nbit_write_CMC (Bit_Chain *restrict dat, Dwg_Color *restrict color)\n{\n  bit_write_BS (dat, color->index);\n  if (dat->version >= R_2004)\n    {\n      bit_write_BL (dat, color->rgb);\n      bit_write_RC (dat, color->flag);\n      // wide?\n      if (color->flag & 1)\n        bit_write_TV (dat, color->name);\n      if (color->flag & 2)\n        bit_write_TV (dat, color->book_name);\n    }\n}\n\n/** Read entity color (2004+) (truecolor rgb and alpha support)\n *  Does also references, DBCOLOR lookups.\n */\nvoid\nbit_read_ENC (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n              Dwg_Color *restrict color)\n{\n  color->index = bit_read_BS (dat);\n  if (dat->version >= R_2004)\n    {\n      uint16_t flag = (((uint32_t)color->index) >> 8) & 0xff;\n      color->index &= 0x1ff;\n      if (flag & 0x80)\n        color->rgb = bit_read_BL (dat); // ODA bug, documented as BS\n      if (flag & 0x40)\n        {\n          color->handle = calloc (1, sizeof (Dwg_Object_Ref));\n          bit_read_H (hdl_dat, &(color->handle->handleref)); // => DBCOLOR\n          // else defer to dwg_decode_common_entity_handle_data ()\n        }\n      if (flag & 0x20)\n        {\n          BITCODE_BL alpha = bit_read_BL (dat);\n          color->alpha_type = alpha & 0xff; // 0, 1 or 3\n          color->alpha = alpha >> 8;\n        }\n      color->flag = (uint16_t)flag;\n    }\n}\n\n/** Write entity color (2004+)\n */\nvoid\nbit_write_ENC (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n               Dwg_Color *restrict color)\n{\n  bit_write_BS (dat, (color->index & 0x1ff) | (color->flag << 8));\n  if (dat->version >= R_2004)\n    {\n      uint16_t flag = color->flag;\n      if (flag & 0x20)\n        bit_write_BL (dat, color->alpha);\n      if (!(flag & 0x40) && (flag & 0x80))\n        bit_write_BL (dat, color->rgb);\n      // ?? wide?\n      if ((flag & 0x41) == 0x41)\n        bit_write_T (str_dat, color->name);\n      if ((flag & 0x42) == 0x42)\n        bit_write_T (str_dat, color->book_name);\n      if (flag & 0x40)\n        bit_write_H (hdl_dat, &(color->handle->handleref)); // => DBCOLOR\n    }\n}\n\n/** Search for a sentinel; if found, positions \"dat->byte\" immediately after it\n    and returns -1\n */\nint\nbit_search_sentinel (Bit_Chain *dat, unsigned char sentinel[16])\n{\n  long unsigned int i, j;\n\n  for (i = 0; i < dat->size; i++)\n    {\n      for (j = 0; j < 16; j++)\n        {\n          if (dat->chain[i + j] != sentinel[j])\n            break;\n        }\n      if (j == 16)\n        {\n          dat->byte = i + j;\n          dat->bit = 0;\n          return -1;\n        }\n    }\n  return 0;\n}\n\nvoid\nbit_write_sentinel (Bit_Chain *dat, unsigned char sentinel[16])\n{\n  int i;\n\n  for (i = 0; i < 16; i++)\n    bit_write_RC (dat, sentinel[i]);\n}\n\n/*\n * Allocates memory space for bit_chain\n * adds 10 4kB pages.\n */\n#define CHAIN_BLOCK 40960\nvoid\nbit_chain_alloc (Bit_Chain *dat)\n{\n  if (dat->size == 0)\n    {\n      dat->chain = (unsigned char *)calloc (1, CHAIN_BLOCK);\n      dat->size = CHAIN_BLOCK;\n      dat->byte = 0;\n      dat->bit = 0;\n    }\n  else\n    {\n      dat->chain\n          = (unsigned char *)realloc (dat->chain, dat->size + CHAIN_BLOCK);\n      dat->size += CHAIN_BLOCK;\n    }\n}\n\nvoid\nbit_print (Bit_Chain *dat, long unsigned int size)\n{\n  unsigned char sig;\n  long unsigned int i, j;\n\n  printf (\"---------------------------------------------------------\");\n  if (size > dat->size)\n    size = dat->size;\n  for (i = 0; i < size; i++)\n    {\n      if (i % 16 == 0)\n        printf (\"\\n[0x%04X]: \", (unsigned int)i);\n      printf (\"%02X \", (unsigned char)dat->chain[i]);\n      if (i % 16 == 15)\n        for (j = i - 15; j <= i; j++)\n          {\n            sig = dat->chain[j];\n            printf (\"%c\", sig >= ' ' && sig < 128 ? sig : '.');\n          }\n    }\n  puts (\"\");\n  puts (\"---------------------------------------------------------\");\n}\n\n// The i-th bit of a string.\n// 0b1000_0000,0 >> 8 = 1\n#define BIT(b, i) (((b)[(i) / 8] & (0x80 >> (i) % 8)) >> (7 - (i) % 8))\n\nvoid\nbit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)\n{\n  char *p = (char *)bits;\n  for (; *p; p++)\n    {\n      if (*p == '0' || *p == '1')\n        bit_write_B (dat, *p != '0');\n      else\n        {\n          fprintf (stderr, \"Invalid binary input %s\\n\", p);\n          return;\n        }\n    }\n}\n\n// accept a string of hex bytes with optional whitespace\nlong\nbit_write_hexbits (Bit_Chain *restrict dat, const char *restrict bytes)\n{\n  char *p = (char *)bytes;\n  long len = 0;\n  unsigned char b = '\\0';\n\n  for (; *p; p++)\n    {\n      if (*p != ' ' && *p != '\\n')\n        {\n          len++;\n          if (*p >= 'a' && *p <= 'f')\n            {\n              if (len % 2)\n                b = (*p + 10 - 'a') << 4;\n              else\n                bit_write_RC (dat, b + *p + 10 - 'a');\n            }\n          else if (*p >= 'A' && *p <= 'F')\n            {\n              if (len % 2)\n                b = (*p + 10 - 'A') << 4;\n              else\n                bit_write_RC (dat, b + *p + 10 - 'A');\n            }\n          else if (*p >= '0' && *p <= '9')\n            {\n              if (len % 2)\n                b = (*p - '0') << 4;\n              else\n                bit_write_RC (dat, b + *p - '0');\n            }\n          else\n            {\n              fprintf (stderr, \"Invalid hex input %s\\n\", p);\n              return 0;\n            }\n        }\n    }\n  return len;\n}\n\nvoid\nbit_print_bits (unsigned char *bits, long unsigned int size)\n{\n  for (long unsigned int i = 0; i < size; i++)\n    {\n      unsigned char bit = i % 8;\n      unsigned char result = (bits[i / 8] & (0x80 >> bit)) >> (7 - bit);\n      // if (i && (i % 8 == 0)) printf(\" \");\n      printf (\"%d\", result ? 1 : 0);\n    }\n  printf (\"\\n\");\n}\n\nvoid\nbit_fprint_bits (FILE *fp, unsigned char *bits, long unsigned int size)\n{\n  for (long unsigned int i = 0; i < size; i++)\n    {\n      unsigned char bit = i % 8;\n      unsigned char result = (bits[i / 8] & (0x80 >> bit)) >> (7 - bit);\n      if (i && !bit)\n        printf (\" \");\n      fprintf (fp, \"%d\", result ? 1 : 0);\n      // fprintf(fp, \"%d\", BIT(bits, i) ? 1 : 0);\n    }\n}\n\nvoid\nbit_explore_chain (Bit_Chain *dat, long unsigned int size)\n{\n  unsigned char sig;\n  long unsigned int i, k;\n\n  if (size > dat->size)\n    size = dat->size;\n\n  for (k = 0; k < 8; k++)\n    {\n      printf (\"---------------------------------------------------------\");\n      dat->byte = 0;\n      dat->bit = k;\n      for (i = 0; i < size - 1; i++)\n        {\n          if (i % 16 == 0)\n            printf (\"\\n[0x%04X]: \", (unsigned int)i);\n          sig = bit_read_RC (dat);\n          printf (\"%c\", sig >= ' ' && sig < 128 ? sig : '.');\n        }\n      puts (\"\");\n    }\n  puts (\"---------------------------------------------------------\");\n}\n\nuint16_t\nbit_calc_CRC (const uint16_t seed, unsigned char *addr, long len)\n{\n  register unsigned char al;\n  register uint16_t dx = seed;\n\n  static const uint16_t crctable[256] = {\n    0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601,\n    0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440, 0xCC01, 0x0CC0,\n    0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81,\n    0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841, 0xD801, 0x18C0, 0x1980, 0xD941,\n    0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01,\n    0x1DC0, 0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0,\n    0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081,\n    0x1040, 0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,\n    0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00,\n    0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0,\n    0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981,\n    0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41,\n    0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541, 0x2700,\n    0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0,\n    0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281,\n    0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,\n    0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01,\n    0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1,\n    0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80,\n    0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541,\n    0x7700, 0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101,\n    0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0,\n    0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481,\n    0x5440, 0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,\n    0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841, 0x8801,\n    0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1,\n    0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400, 0x84C1, 0x8581,\n    0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341,\n    0x4100, 0x81C1, 0x8081, 0x4040\n  };\n\n  for (; len > 0; len--)\n    {\n      al = (unsigned char)((*addr) ^ ((unsigned char)(dx & 0xFF)));\n      dx = ((dx >> 8) & 0xFF) ^ crctable[al];\n      addr++;\n    }\n  return dx;\n}\n\nuint32_t\nbit_calc_CRC32 (const uint32_t seed, unsigned char *addr, long len)\n{\n  register unsigned char al;\n  register uint32_t dx = ~seed; /* inverted */\n\n  static const uint32_t crctable[256] = {\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\n    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\n    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\n    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,\n    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\n    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,\n    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\n    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\n    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\n    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\n    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\n    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\n    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\n    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\n    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\n    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\n    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\n    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\n    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\n    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\n    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\n    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\n    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\n    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\n    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\n    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n  };\n\n  for (; len > 0; len--)\n    {\n      al = (unsigned char)((*addr) ^ ((unsigned char)(dx & 0xFF)));\n      dx = ((dx >> 8) & 0xFF) ^ crctable[al];\n      addr++;\n    }\n  return ~dx;\n}\n"], "filenames": ["src/bits.c"], "buggy_code_start_loc": [956], "buggy_code_end_loc": [957], "fixing_code_start_loc": [956], "fixing_code_end_loc": [957], "type": "CWE-787", "message": "An issue was discovered in GNU LibreDWG through 0.9.3. Crafted input will lead to a stack overflow in bits.c, possibly related to bit_read_TF.", "other": {"cve": {"id": "CVE-2019-20912", "sourceIdentifier": "cve@mitre.org", "published": "2020-07-16T18:15:13.407", "lastModified": "2020-07-22T18:18:08.523", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in GNU LibreDWG through 0.9.3. Crafted input will lead to a stack overflow in bits.c, possibly related to bit_read_TF."}, {"lang": "es", "value": "Se detect\u00f3 un problema en GNU LibreDWG versiones hasta 0.9.3. Una entrada dise\u00f1ada conllevar\u00e1 a un desbordamiento de la pila en el archivo bits.c, posiblemente relacionado con la funci\u00f3n bit_read_TF"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnu:libredwg:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.3", "matchCriteriaId": "28E3A7DE-65A0-4A6B-BF63-00F627CF17CB"}]}]}], "references": [{"url": "https://github.com/LibreDWG/libredwg/commit/b84c2cab55948a5ee70860779b2640913e3ee1ed", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibreDWG/libredwg/issues/178", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibreDWG/libredwg/commit/b84c2cab55948a5ee70860779b2640913e3ee1ed"}}