{"buggy_code": ["class Uke::Finder\n  attr_accessor :q, :limit, :results, :results_voice, :results_digital, :location, :location_radius, :active_import\n\n  def initialize\n    @results = @results_voice = @results_digital = []\n\n    @active_import = UkeImport.find_by_active(true)\n    raise 'There is no active import' if active_import.nil?\n  end\n\n  def any?\n    (@results.count > 0)\n  end\n\n  def query(value, limit = 2500)\n    @q = value.to_s\n    @limit = limit\n\n    @results = nil\n    @results = by_news\n    @results = by_location  if @results.nil?\n    @results = by_frq_range if @results.nil?\n    @results = by_frq       if @results.nil?\n    @results = by_string    if @results.nil?\n    @results = []           if @results.nil?\n\n    @results_voice   = @results.dup.keep_if{|station| Uke::Net::voice?(station[:net]) }\n    @results_digital = @results.dup.keep_if{|station| Uke::Net::digital?(station[:net]) }\n\n    self\n  end\n\n  def by_news\n    return nil if @q.strip[0..4] != 'news:' || (@location = Geocoder.search(@q.gsub('news:', '').strip).first).nil?\n    \n    bounds_ne = @location.geometry['bounds']['northeast']\n    bounds_sw = @location.geometry['bounds']['southwest']\n    @location_radius = (distance_between_points([bounds_ne['lat'], bounds_ne['lng']], [bounds_sw['lat'], bounds_sw['lng']])/1000).round(0)\n    \n    sql = <<-SQL\n          SELECT DISTINCT us.id,\n                 (3959 * acos(cos(radians(:lat))*cos(radians(lat))*cos(radians(lon)-radians(:lon))+sin(radians(:lat))*sin(radians(lat)))) AS distance\n            FROM uke_import_news n\n      INNER JOIN uke_stations AS us ON (us.id = n.uke_station_id)\n           WHERE n.uke_import_id = :uke_import_id\n             AND lat BETWEEN :lat_sw AND :lat_ne\n             AND lon BETWEEN :lon_sw AND :lon_ne\n        ORDER BY distance ASC\n    SQL\n    \n    sql.gsub!(':uke_import_id', @active_import.id.to_s)\n    sql.gsub!(':lat_ne', conn.quote_string(bounds_ne['lat'].to_s))\n    sql.gsub!(':lat_sw', conn.quote_string(bounds_sw['lat'].to_s))\n    sql.gsub!(':lon_ne', conn.quote_string(bounds_ne['lng'].to_s))\n    sql.gsub!(':lon_sw', conn.quote_string(bounds_sw['lng'].to_s))\n    sql.gsub!(':lat', conn.quote_string(@location.latitude.to_s))\n    sql.gsub!(':lon', conn.quote_string(@location.longitude.to_s))\n    \n    result_to_hash select_using_uke_stations_result(sql)\n  end\n\n  def by_location\n    return nil if @q.strip[0..3] != 'loc:' || (@location = Geocoder.search(@q.gsub('loc:', '').strip).first).nil?\n\n    bounds_ne = @location.geometry['bounds']['northeast']\n    bounds_sw = @location.geometry['bounds']['southwest']\n    @location_radius = (distance_between_points([bounds_ne['lat'], bounds_ne['lng']], [bounds_sw['lat'], bounds_sw['lng']])/1000).round(0)\n    \n    sql = <<-SQL\n         SELECT DISTINCT us.id,\n                (3959 * acos(cos(radians(:lat))*cos(radians(lat))*cos(radians(lon)-radians(:lon))+sin(radians(:lat))*sin(radians(lat)))) AS distance\n           FROM uke_stations AS us\n          WHERE us.uke_import_id = :uke_import_id\n             AND lat BETWEEN :lat_sw AND :lat_ne\n             AND lon BETWEEN :lon_sw AND :lon_ne\n       ORDER BY distance ASC\n    SQL\n\n    sql.gsub!(':uke_import_id', @active_import.id.to_s)\n    sql.gsub!(':lat_ne', conn.quote_string(bounds_ne['lat'].to_s))\n    sql.gsub!(':lat_sw', conn.quote_string(bounds_sw['lat'].to_s))\n    sql.gsub!(':lon_ne', conn.quote_string(bounds_ne['lng'].to_s))\n    sql.gsub!(':lon_sw', conn.quote_string(bounds_sw['lng'].to_s))\n    sql.gsub!(':lat', conn.quote_string(@location.latitude.to_s))\n    sql.gsub!(':lon', conn.quote_string(@location.longitude.to_s))\n\n    result_to_hash select_using_uke_stations_result(sql)\n  end\n\n  def by_frq_range\n    return nil if @q.strip[0..3] != 'rng:' || (first = Uke::Unifier::frq_string(@q[4..@q.length].split('-').first)) < 1 || (last =  Uke::Unifier::frq_string(@q[4..@q.length].split('-').last)) < 1\n\n    sql = <<-SQL\n         SELECT DISTINCT fa.subject_id\n           FROM frequencies f\n     INNER JOIN frequency_assignments fa ON (fa.frequency_id = f.id AND fa.subject_type = 'UkeStation' AND fa.uke_import_id = :uke_import_id)\n          WHERE (f.mhz BETWEEN :mhz_start AND :mhz_end)\n    SQL\n\n    result_to_hash select_using_uke_stations_sql(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':mhz_start', conn.quote_string(first.to_s)).gsub(':mhz_end', conn.quote_string(last.to_s)))\n  end\n\n  def by_frq\n    return nil if @q.length < 4 || Uke::Unifier::frq_string(@q) < 1\n\n    sql = <<-SQL\n         SELECT DISTINCT subject_id\n           FROM frequencies f\n     INNER JOIN frequency_assignments fa ON (fa.frequency_id = f.id AND fa.subject_type = 'UkeStation' AND fa.uke_import_id = :uke_import_id)\n          WHERE f.mhz = :mhz\n    SQL\n\n    result_to_hash select_using_uke_stations_sql(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':mhz', conn.quote_string(Uke::Unifier::frq_string(@q).to_s)))\n  end\n\n  def by_string\n    return nil if @q.length < 4\n\n    sql = <<-SQL\n        SELECT us.id\n          FROM uke_stations us\n          JOIN uke_operators uo on (uo.id = us.uke_operator_id)\n         WHERE us.uke_import_id = :uke_import_id\n           AND (us.location LIKE '%:like%' OR us.name LIKE '%:like%' OR uo.name LIKE '%:like%')\n    SQL\n\n    result_to_hash select_using_uke_stations_sql(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':like', conn.quote_string(@q)))\n  end\n\n  def by_frq_order_by_distance\n    return nil if @location.nil? || @q.to_f == 0\n\n    sql = <<-SQL\n          SELECT uo.name AS owner,\n                 CONCAT(us.name, ' ', us.location) AS display_name,\n                 us.net,\n                 us.radius,\n                 us.lat,\n                 us.lon,\n                 (3959 * acos(cos(radians(:lat))*cos(radians(lat))*cos(radians(lon)-radians(:lon))+sin(radians(:lat))*sin(radians(lat)))) AS distance,\n                 fa.id AS frequency_assignment_id\n            FROM frequencies f\n      INNER JOIN frequency_assignments fa ON (fa.frequency_id = f.id AND fa.subject_type = 'UkeStation' AND fa.uke_import_id = :uke_import_id)\n      INNER JOIN uke_stations us ON us.id = fa.subject_id\n      INNER JOIN uke_operators uo ON uo.id = us.uke_operator_id\n           WHERE f.mhz = :mhz\n             AND fa.usage = 'TX'\n          HAVING distance <= 100\n        ORDER BY distance ASC\n    SQL\n\n    result_to_hash(conn.select_all(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':lat', conn.quote_string(@location.latitude.to_s)).gsub(':lon', conn.quote_string(@location.longitude.to_s)).gsub(':mhz', conn.quote_string(Uke::Unifier::frq_string(@q).to_s))))\n  end\n\n  private\n\n  def conn\n    ActiveRecord::Base.connection\n  end\n\n  def select_using_uke_stations_result(sql)\n    result = conn.select_all sql\n    return result unless result.rows.any?\n    \n    sids = result.rows.map{|row|row[0]}.join(',')\n    select_using_uke_stations_sql(sids, \"FIND_IN_SET(us.id, '#{sids}')\")\n  end\n\n  def select_using_uke_stations_sql(stations_sql, sort = 'uo.name_unified')\n    sql = <<-SQL\n              SELECT uo.name AS owner,\n                 us.name,\n                 us.location,\n                 us.net,\n                 us.radius,\n                 us.lat,\n                 us.lon,\n                 GROUP_CONCAT(DISTINCT f_tx.mhz) AS tx_frequencies,\n                 GROUP_CONCAT(DISTINCT f_rx.mhz) AS rx_frequencies\n            FROM uke_stations us\n      INNER JOIN uke_operators uo            ON (uo.id = us.uke_operator_id)\n       LEFT JOIN frequency_assignments fa_tx ON (fa_tx.subject_type = 'UkeStation' AND fa_tx.subject_id = us.id AND fa_tx.usage = 'TX')\n       LEFT JOIN frequencies f_tx            ON (f_tx.id = fa_tx.frequency_id)\n       LEFT JOIN frequency_assignments fa_rx ON (fa_rx.subject_type = 'UkeStation' AND fa_rx.subject_id = us.id AND fa_rx.usage = 'RX')\n       LEFT JOIN frequencies f_rx            ON (f_rx.id = fa_rx.frequency_id)\n           WHERE us.id IN (:stations_sql)\n        GROUP BY us.id\n        ORDER BY :sort\n           LIMIT :limit\n    SQL\n\n    conn.select_all sql.gsub(':stations_sql', stations_sql).gsub(':sort', sort).gsub(':limit', @limit.to_s)\n  end\n\n  def result_to_hash(result)\n    columns = result.columns.map{|column| column.to_sym}\n    result.rows.map { |row| Hash[columns.zip(row)] }\n  end\n  \n  def distance_between_points(a, b)\n    rad_per_deg = Math::PI/180  # PI / 180\n    rkm = 6371                  # Earth radius in kilometers\n    rm = rkm * 1000             # Radius in meters\n      \n    dlon_rad = (b[1]-a[1]) * rad_per_deg  # Delta, converted to rad\n    dlat_rad = (b[0]-a[0]) * rad_per_deg\n          \n    lat1_rad, lon1_rad = a.map! {|i| i * rad_per_deg }\n    lat2_rad, lon2_rad = b.map! {|i| i * rad_per_deg }\n            \n    a = Math.sin(dlat_rad/2)**2 + Math.cos(lat1_rad) * Math.cos(lat2_rad) * Math.sin(dlon_rad/2)**2\n    c = 2 * Math::atan2(Math::sqrt(a), Math::sqrt(1-a))\n                  \n    rm * c # Delta in meters\n  end\nend\n"], "fixing_code": ["class Uke::Finder\n  attr_accessor :q, :limit, :results, :results_voice, :results_digital, :location, :location_radius, :active_import\n\n  def initialize\n    @results = @results_voice = @results_digital = []\n\n    @active_import = UkeImport.find_by_active(true)\n    raise 'There is no active import' if active_import.nil?\n  end\n\n  def any?\n    (@results.count > 0)\n  end\n\n  def query(value, limit = 2500)\n    @q = value.to_s\n    @limit = limit\n\n    @results = nil\n    @results = by_news\n    @results = by_location  if @results.nil?\n    @results = by_frq_range if @results.nil?\n    @results = by_frq       if @results.nil?\n    @results = by_string    if @results.nil?\n    @results = []           if @results.nil?\n\n    @results_voice   = @results.dup.keep_if{|station| Uke::Net::voice?(station[:net]) }\n    @results_digital = @results.dup.keep_if{|station| Uke::Net::digital?(station[:net]) }\n\n    self\n  end\n\n  def by_news\n    return nil if @q.strip[0..4] != 'news:' || (@location = Geocoder.search(@q.gsub('news:', '').strip).first).nil?\n    \n    bounds_ne = @location.geometry['bounds']['northeast']\n    bounds_sw = @location.geometry['bounds']['southwest']\n    @location_radius = (distance_between_points([bounds_ne['lat'], bounds_ne['lng']], [bounds_sw['lat'], bounds_sw['lng']])/1000).round(0)\n    \n    sql = <<-SQL\n          SELECT DISTINCT us.id,\n                 (3959 * acos(cos(radians(:lat))*cos(radians(lat))*cos(radians(lon)-radians(:lon))+sin(radians(:lat))*sin(radians(lat)))) AS distance\n            FROM uke_import_news n\n      INNER JOIN uke_stations AS us ON (us.id = n.uke_station_id)\n           WHERE n.uke_import_id = :uke_import_id\n             AND lat BETWEEN :lat_sw AND :lat_ne\n             AND lon BETWEEN :lon_sw AND :lon_ne\n        ORDER BY distance ASC\n    SQL\n    \n    sql.gsub!(':uke_import_id', @active_import.id.to_s)\n    sql.gsub!(':lat_ne', conn.quote(bounds_ne['lat'].to_s))\n    sql.gsub!(':lat_sw', conn.quote(bounds_sw['lat'].to_s))\n    sql.gsub!(':lon_ne', conn.quote(bounds_ne['lng'].to_s))\n    sql.gsub!(':lon_sw', conn.quote(bounds_sw['lng'].to_s))\n    sql.gsub!(':lat', conn.quote(@location.latitude.to_s))\n    sql.gsub!(':lon', conn.quote(@location.longitude.to_s))\n    \n    result_to_hash select_using_uke_stations_result(sql)\n  end\n\n  def by_location\n    return nil if @q.strip[0..3] != 'loc:' || (@location = Geocoder.search(@q.gsub('loc:', '').strip).first).nil?\n\n    bounds_ne = @location.geometry['bounds']['northeast']\n    bounds_sw = @location.geometry['bounds']['southwest']\n    @location_radius = (distance_between_points([bounds_ne['lat'], bounds_ne['lng']], [bounds_sw['lat'], bounds_sw['lng']])/1000).round(0)\n    \n    sql = <<-SQL\n         SELECT DISTINCT us.id,\n                (3959 * acos(cos(radians(:lat))*cos(radians(lat))*cos(radians(lon)-radians(:lon))+sin(radians(:lat))*sin(radians(lat)))) AS distance\n           FROM uke_stations AS us\n          WHERE us.uke_import_id = :uke_import_id\n             AND lat BETWEEN :lat_sw AND :lat_ne\n             AND lon BETWEEN :lon_sw AND :lon_ne\n       ORDER BY distance ASC\n    SQL\n\n    sql.gsub!(':uke_import_id', @active_import.id.to_s)\n    sql.gsub!(':lat_ne', conn.quote(bounds_ne['lat'].to_s))\n    sql.gsub!(':lat_sw', conn.quote(bounds_sw['lat'].to_s))\n    sql.gsub!(':lon_ne', conn.quote(bounds_ne['lng'].to_s))\n    sql.gsub!(':lon_sw', conn.quote(bounds_sw['lng'].to_s))\n    sql.gsub!(':lat', conn.quote(@location.latitude.to_s))\n    sql.gsub!(':lon', conn.quote(@location.longitude.to_s))\n\n    result_to_hash select_using_uke_stations_result(sql)\n  end\n\n  def by_frq_range\n    return nil if @q.strip[0..3] != 'rng:' || (first = Uke::Unifier::frq_string(@q[4..@q.length].split('-').first)) < 1 || (last =  Uke::Unifier::frq_string(@q[4..@q.length].split('-').last)) < 1\n\n    sql = <<-SQL\n         SELECT DISTINCT fa.subject_id\n           FROM frequencies f\n     INNER JOIN frequency_assignments fa ON (fa.frequency_id = f.id AND fa.subject_type = 'UkeStation' AND fa.uke_import_id = :uke_import_id)\n          WHERE (f.mhz BETWEEN :mhz_start AND :mhz_end)\n    SQL\n\n    result_to_hash select_using_uke_stations_sql(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':mhz_start', conn.quote(first.to_s)).gsub(':mhz_end', conn.quote(last.to_s)))\n  end\n\n  def by_frq\n    return nil if @q.length < 4 || Uke::Unifier::frq_string(@q) < 1\n\n    sql = <<-SQL\n         SELECT DISTINCT subject_id\n           FROM frequencies f\n     INNER JOIN frequency_assignments fa ON (fa.frequency_id = f.id AND fa.subject_type = 'UkeStation' AND fa.uke_import_id = :uke_import_id)\n          WHERE f.mhz = :mhz\n    SQL\n\n    result_to_hash select_using_uke_stations_sql(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':mhz', conn.quote(Uke::Unifier::frq_string(@q).to_s)))\n  end\n\n  def by_string\n    return nil if @q.length < 4\n\n    sql = <<-SQL\n        SELECT us.id\n          FROM uke_stations us\n          JOIN uke_operators uo on (uo.id = us.uke_operator_id)\n         WHERE us.uke_import_id = :uke_import_id\n           AND (us.location LIKE :like OR us.name LIKE :like OR uo.name LIKE :like)\n    SQL\n\n    result_to_hash select_using_uke_stations_sql(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':like', conn.quote('%'+@q.to_s+'%')))\n  end\n\n  def by_frq_order_by_distance\n    return nil if @location.nil? || @q.to_f == 0\n\n    sql = <<-SQL\n          SELECT uo.name AS owner,\n                 CONCAT(us.name, ' ', us.location) AS display_name,\n                 us.net,\n                 us.radius,\n                 us.lat,\n                 us.lon,\n                 (3959 * acos(cos(radians(:lat))*cos(radians(lat))*cos(radians(lon)-radians(:lon))+sin(radians(:lat))*sin(radians(lat)))) AS distance,\n                 fa.id AS frequency_assignment_id\n            FROM frequencies f\n      INNER JOIN frequency_assignments fa ON (fa.frequency_id = f.id AND fa.subject_type = 'UkeStation' AND fa.uke_import_id = :uke_import_id)\n      INNER JOIN uke_stations us ON us.id = fa.subject_id\n      INNER JOIN uke_operators uo ON uo.id = us.uke_operator_id\n           WHERE f.mhz = :mhz\n             AND fa.usage = 'TX'\n          HAVING distance <= 100\n        ORDER BY distance ASC\n    SQL\n\n    result_to_hash(conn.select_all(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':lat', conn.quote(@location.latitude.to_s)).gsub(':lon', conn.quote(@location.longitude.to_s)).gsub(':mhz', conn.quote(Uke::Unifier::frq_string(@q).to_s))))\n  end\n\n  private\n\n  def conn\n    ActiveRecord::Base.connection\n  end\n\n  def select_using_uke_stations_result(sql)\n    result = conn.select_all sql\n    return result unless result.rows.any?\n    \n    sids = result.rows.map{|row|row[0]}.join(',')\n    select_using_uke_stations_sql(sids, \"FIND_IN_SET(us.id, '#{sids}')\")\n  end\n\n  def select_using_uke_stations_sql(stations_sql, sort = 'uo.name_unified')\n    sql = <<-SQL\n              SELECT uo.name AS owner,\n                 us.name,\n                 us.location,\n                 us.net,\n                 us.radius,\n                 us.lat,\n                 us.lon,\n                 GROUP_CONCAT(DISTINCT f_tx.mhz) AS tx_frequencies,\n                 GROUP_CONCAT(DISTINCT f_rx.mhz) AS rx_frequencies\n            FROM uke_stations us\n      INNER JOIN uke_operators uo            ON (uo.id = us.uke_operator_id)\n       LEFT JOIN frequency_assignments fa_tx ON (fa_tx.subject_type = 'UkeStation' AND fa_tx.subject_id = us.id AND fa_tx.usage = 'TX')\n       LEFT JOIN frequencies f_tx            ON (f_tx.id = fa_tx.frequency_id)\n       LEFT JOIN frequency_assignments fa_rx ON (fa_rx.subject_type = 'UkeStation' AND fa_rx.subject_id = us.id AND fa_rx.usage = 'RX')\n       LEFT JOIN frequencies f_rx            ON (f_rx.id = fa_rx.frequency_id)\n           WHERE us.id IN (:stations_sql)\n        GROUP BY us.id\n        ORDER BY :sort\n           LIMIT :limit\n    SQL\n\n    conn.select_all sql.gsub(':stations_sql', stations_sql).gsub(':sort', sort).gsub(':limit', @limit.to_s)\n  end\n\n  def result_to_hash(result)\n    columns = result.columns.map{|column| column.to_sym}\n    result.rows.map { |row| Hash[columns.zip(row)] }\n  end\n  \n  def distance_between_points(a, b)\n    rad_per_deg = Math::PI/180  # PI / 180\n    rkm = 6371                  # Earth radius in kilometers\n    rm = rkm * 1000             # Radius in meters\n      \n    dlon_rad = (b[1]-a[1]) * rad_per_deg  # Delta, converted to rad\n    dlat_rad = (b[0]-a[0]) * rad_per_deg\n          \n    lat1_rad, lon1_rad = a.map! {|i| i * rad_per_deg }\n    lat2_rad, lon2_rad = b.map! {|i| i * rad_per_deg }\n            \n    a = Math.sin(dlat_rad/2)**2 + Math.cos(lat1_rad) * Math.cos(lat2_rad) * Math.sin(dlon_rad/2)**2\n    c = 2 * Math::atan2(Math::sqrt(a), Math::sqrt(1-a))\n                  \n    rm * c # Delta in meters\n  end\nend\n"], "filenames": ["lib/uke/finder.rb"], "buggy_code_start_loc": [52], "buggy_code_end_loc": [153], "fixing_code_start_loc": [52], "fixing_code_end_loc": [153], "type": "CWE-89", "message": "A vulnerability classified as critical has been found in arekk uke. This affects an unknown part of the file lib/uke/finder.rb. The manipulation leads to sql injection. The name of the patch is 52fd3b2d0bc16227ef57b7b98a3658bb67c1833f. It is recommended to apply a patch to fix this issue. The identifier VDB-217485 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2015-10014", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-05T14:15:08.610", "lastModified": "2023-01-11T19:37:21.617", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as critical has been found in arekk uke. This affects an unknown part of the file lib/uke/finder.rb. The manipulation leads to sql injection. The name of the patch is 52fd3b2d0bc16227ef57b7b98a3658bb67c1833f. It is recommended to apply a patch to fix this issue. The identifier VDB-217485 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uke_project:uke:*:*:*:*:*:*:*:*", "versionEndExcluding": "2015-11-17", "matchCriteriaId": "5198CA00-81E2-44F6-B76B-8B8F6E5B488D"}]}]}], "references": [{"url": "https://github.com/arekk/uke/commit/52fd3b2d0bc16227ef57b7b98a3658bb67c1833f", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217485", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217485", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/arekk/uke/commit/52fd3b2d0bc16227ef57b7b98a3658bb67c1833f"}}