{"buggy_code": ["/**\n * SPDX-FileCopyrightText: 2013 Albert Vaca <albertvaka@gmail.com>\n *\n * SPDX-License-Identifier: GPL-2.0-only OR GPL-3.0-only OR LicenseRef-KDE-Accepted-GPL\n */\n\n#include \"lanlinkprovider.h\"\n#include \"core_debug.h\"\n\n#ifndef Q_OS_WIN\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <netdb.h>\n#endif\n\n#include <QHostInfo>\n#include <QTcpServer>\n#include <QMetaEnum>\n#include <QNetworkProxy>\n#include <QUdpSocket>\n#include <QNetworkSession>\n#include <QNetworkConfigurationManager>\n#include <QSslCipher>\n#include <QSslConfiguration>\n#include <QSslKey>\n\n#include \"daemon.h\"\n#include \"landevicelink.h\"\n#include \"lanpairinghandler.h\"\n#include \"kdeconnectconfig.h\"\n#include \"qtcompat_p.h\"\n\n#define MIN_VERSION_WITH_SSL_SUPPORT 6\n\nLanLinkProvider::LanLinkProvider(\n        bool testMode,\n        quint16 udpBroadcastPort,\n        quint16 udpListenPort\n        )\n    : m_server(new Server(this))\n    , m_udpSocket(this)\n    , m_tcpPort(0)\n    , m_udpBroadcastPort(udpBroadcastPort)\n    , m_udpListenPort(udpListenPort)\n    , m_testMode(testMode)\n    , m_combineBroadcastsTimer(this)\n{\n\n    m_combineBroadcastsTimer.setInterval(0); // increase this if waiting a single event-loop iteration is not enough\n    m_combineBroadcastsTimer.setSingleShot(true);\n    connect(&m_combineBroadcastsTimer, &QTimer::timeout, this, &LanLinkProvider::broadcastToNetwork);\n\n    connect(&m_udpSocket, &QIODevice::readyRead, this, &LanLinkProvider::udpBroadcastReceived);\n\n    m_server->setProxy(QNetworkProxy::NoProxy);\n    connect(m_server, &QTcpServer::newConnection, this, &LanLinkProvider::newConnection);\n\n    m_udpSocket.setProxy(QNetworkProxy::NoProxy);\n\n    //Detect when a network interface changes status, so we announce ourselves in the new network\n    QNetworkConfigurationManager* networkManager = new QNetworkConfigurationManager(this);\n    connect(networkManager, &QNetworkConfigurationManager::configurationChanged, this, &LanLinkProvider::onNetworkConfigurationChanged);\n\n}\n\nvoid LanLinkProvider::onNetworkConfigurationChanged(const QNetworkConfiguration& config)\n{\n    if (m_lastConfig != config && config.state() == QNetworkConfiguration::Active) {\n        m_lastConfig = config;\n        onNetworkChange();\n    }\n}\n\nLanLinkProvider::~LanLinkProvider()\n{\n}\n\nvoid LanLinkProvider::onStart()\n{\n    const QHostAddress bindAddress = m_testMode? QHostAddress::LocalHost : QHostAddress::Any;\n\n    bool success = m_udpSocket.bind(bindAddress, m_udpListenPort, QUdpSocket::ShareAddress);\n    if (!success) {\n        QAbstractSocket::SocketError sockErr = m_udpSocket.error();\n        // Refer to https://doc.qt.io/qt-5/qabstractsocket.html#SocketError-enum to decode socket error number\n        QString errorMessage = QString::fromLatin1(QMetaEnum::fromType<QAbstractSocket::SocketError>().valueToKey(sockErr));\n        qCritical(KDECONNECT_CORE)\n                << QLatin1String(\"Failed to bind UDP socket on port\")\n                << m_udpListenPort\n                << QLatin1String(\"with error\")\n                << errorMessage;\n    }\n    Q_ASSERT(success);\n\n    m_tcpPort = MIN_TCP_PORT;\n    while (!m_server->listen(bindAddress, m_tcpPort)) {\n        m_tcpPort++;\n        if (m_tcpPort > MAX_TCP_PORT) { //No ports available?\n            qCritical(KDECONNECT_CORE) << \"Error opening a port in range\" << MIN_TCP_PORT << \"-\" << MAX_TCP_PORT;\n            m_tcpPort = 0;\n            return;\n        }\n    }\n\n    onNetworkChange();\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider started\";\n}\n\nvoid LanLinkProvider::onStop()\n{\n    m_udpSocket.close();\n    m_server->close();\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider stopped\";\n}\n\nvoid LanLinkProvider::onNetworkChange()\n{\n    if (m_combineBroadcastsTimer.isActive()) {\n        qCDebug(KDECONNECT_CORE) << \"Preventing duplicate broadcasts\";\n        return;\n    }\n    m_combineBroadcastsTimer.start();\n}\n\n//I'm in a new network, let's be polite and introduce myself\nvoid LanLinkProvider::broadcastToNetwork()\n{\n    if (!m_server->isListening()) {\n        //Not started\n        return;\n    }\n\n    Q_ASSERT(m_tcpPort != 0);\n\n    qCDebug(KDECONNECT_CORE()) << \"Broadcasting identity packet\";\n\n    QList<QHostAddress> destinations = getBroadcastAddresses();\n\n    NetworkPacket np;\n    NetworkPacket::createIdentityPacket(&np);\n    np.set(QStringLiteral(\"tcpPort\"), m_tcpPort);\n\n#ifdef Q_OS_WIN\n    //On Windows we need to broadcast from every local IP address to reach all networks\n    QUdpSocket sendSocket;\n    sendSocket.setProxy(QNetworkProxy::NoProxy);\n    for (const QNetworkInterface& iface : QNetworkInterface::allInterfaces()) {\n        if ( (iface.flags() & QNetworkInterface::IsUp)\n             && (iface.flags() & QNetworkInterface::IsRunning)\n             && (iface.flags() & QNetworkInterface::CanBroadcast)) {\n            for (const QNetworkAddressEntry& ifaceAddress : iface.addressEntries()) {\n                QHostAddress sourceAddress = ifaceAddress.ip();\n                if (sourceAddress.protocol() == QAbstractSocket::IPv4Protocol && sourceAddress != QHostAddress::LocalHost) {\n                    qCDebug(KDECONNECT_CORE()) << \"Broadcasting as\" << sourceAddress;\n                    sendBroadcasts(sendSocket, np, destinations);\n                    sendSocket.close();\n                }\n            }\n        }\n    }\n#else\n    sendBroadcasts(m_udpSocket, np, destinations);\n#endif\n}\n\nQList<QHostAddress> LanLinkProvider::getBroadcastAddresses()\n{\n    const QStringList customDevices = KdeConnectConfig::instance().customDevices();\n\n    QList<QHostAddress> destinations;\n    destinations.reserve(customDevices.length() + 1);\n\n    // Default broadcast address\n    destinations.append(m_testMode ? QHostAddress::LocalHost : QHostAddress::Broadcast);\n\n    // Custom device addresses\n    for (auto& customDevice : customDevices) {\n        QHostAddress address(customDevice);\n        if (address.isNull()) {\n            qCWarning(KDECONNECT_CORE) << \"Invalid custom device address\" << customDevice;\n        } else {\n            destinations.append(address);\n        }\n    }\n\n    return destinations;\n}\n\nvoid LanLinkProvider::sendBroadcasts(\n        QUdpSocket& socket, const NetworkPacket& np, const QList<QHostAddress>& addresses)\n{\n    const QByteArray payload = np.serialize();\n\n    for (auto& address : addresses) {\n        socket.writeDatagram(payload, address, m_udpBroadcastPort);\n    }\n}\n\n//I'm the existing device, a new device is kindly introducing itself.\n//I will create a TcpSocket and try to connect. This can result in either tcpSocketConnected() or connectError().\nvoid LanLinkProvider::udpBroadcastReceived()\n{\n    while (m_udpSocket.hasPendingDatagrams()) {\n\n        QByteArray datagram;\n        datagram.resize(m_udpSocket.pendingDatagramSize());\n        QHostAddress sender;\n\n        m_udpSocket.readDatagram(datagram.data(), datagram.size(), &sender);\n\n        if (sender.isLoopback() && !m_testMode)\n            continue;\n\n        NetworkPacket* receivedPacket = new NetworkPacket(QLatin1String(\"\"));\n        bool success = NetworkPacket::unserialize(datagram, receivedPacket);\n\n        //qCDebug(KDECONNECT_CORE) << \"udp connection from \" << receivedPacket->;\n\n        //qCDebug(KDECONNECT_CORE) << \"Datagram \" << datagram.data() ;\n\n        if (!success) {\n            qCDebug(KDECONNECT_CORE) << \"Could not unserialize UDP packet\";\n            delete receivedPacket;\n            continue;\n        }\n\n        if (receivedPacket->type() != PACKET_TYPE_IDENTITY) {\n            qCDebug(KDECONNECT_CORE) << \"Received a UDP packet of wrong type\" << receivedPacket->type();\n            delete receivedPacket;\n            continue;\n        }\n\n        if (receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) == KdeConnectConfig::instance().deviceId()) {\n            //qCDebug(KDECONNECT_CORE) << \"Ignoring my own broadcast\";\n            delete receivedPacket;\n            continue;\n        }\n\n        int tcpPort = receivedPacket->get<int>(QStringLiteral(\"tcpPort\"));\n\n        //qCDebug(KDECONNECT_CORE) << \"Received Udp identity packet from\" << sender << \" asking for a tcp connection on port \" << tcpPort;\n\n        QSslSocket* socket = new QSslSocket(this);\n        socket->setProxy(QNetworkProxy::NoProxy);\n        m_receivedIdentityPackets[socket].np = receivedPacket;\n        m_receivedIdentityPackets[socket].sender = sender;\n        connect(socket, &QAbstractSocket::connected, this, &LanLinkProvider::tcpSocketConnected);\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n        connect(socket, QOverload<QAbstractSocket::SocketError>::of(&QAbstractSocket::error), this, &LanLinkProvider::connectError);\n#else\n        connect(socket, &QAbstractSocket::errorOccurred, this, &LanLinkProvider::connectError);\n#endif\n        socket->connectToHost(sender, tcpPort);\n    }\n}\n\nvoid LanLinkProvider::connectError(QAbstractSocket::SocketError socketError)\n{\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n    if (!socket) return;\n\n    qCDebug(KDECONNECT_CORE) << \"Socket error\" << socketError;\n    qCDebug(KDECONNECT_CORE) << \"Fallback (1), try reverse connection (send udp packet)\" << socket->errorString();\n    NetworkPacket np(QLatin1String(\"\"));\n    NetworkPacket::createIdentityPacket(&np);\n    np.set(QStringLiteral(\"tcpPort\"), m_tcpPort);\n    m_udpSocket.writeDatagram(np.serialize(), m_receivedIdentityPackets[socket].sender, m_udpBroadcastPort);\n\n    //The socket we created didn't work, and we didn't manage\n    //to create a LanDeviceLink from it, deleting everything.\n    delete m_receivedIdentityPackets.take(socket).np;\n    socket->deleteLater();\n}\n\n//We received a UDP packet and answered by connecting to them by TCP. This gets called on a successful connection.\nvoid LanLinkProvider::tcpSocketConnected()\n{\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n\n    if (!socket) return;\n    // TODO Delete me?\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n    disconnect(socket, QOverload<QAbstractSocket::SocketError>::of(&QAbstractSocket::error), this, &LanLinkProvider::connectError);\n#else\n    disconnect(socket, &QAbstractSocket::errorOccurred, this, &LanLinkProvider::connectError);\n#endif\n\n    configureSocket(socket);\n\n    // If socket disconnects due to any reason after connection, link on ssl failure\n    connect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n\n    NetworkPacket* receivedPacket = m_receivedIdentityPackets[socket].np;\n    const QString& deviceId = receivedPacket->get<QString>(QStringLiteral(\"deviceId\"));\n    //qCDebug(KDECONNECT_CORE) << \"tcpSocketConnected\" << socket->isWritable();\n\n    // If network is on ssl, do not believe when they are connected, believe when handshake is completed\n    NetworkPacket np2(QLatin1String(\"\"));\n    NetworkPacket::createIdentityPacket(&np2);\n    socket->write(np2.serialize());\n    bool success = socket->waitForBytesWritten();\n\n    if (success) {\n\n        qCDebug(KDECONNECT_CORE) << \"TCP connection done (i'm the existing device)\";\n\n        // if ssl supported\n        if (receivedPacket->get<int>(QStringLiteral(\"protocolVersion\")) >= MIN_VERSION_WITH_SSL_SUPPORT) {\n\n            bool isDeviceTrusted = KdeConnectConfig::instance().trustedDevices().contains(deviceId);\n            configureSslSocket(socket, deviceId, isDeviceTrusted);\n\n            qCDebug(KDECONNECT_CORE) << \"Starting server ssl (I'm the client TCP socket)\";\n\n            connect(socket, &QSslSocket::encrypted, this, &LanLinkProvider::encrypted);\n\n            connect(socket, QOverload<const QList<QSslError> &>::of(&QSslSocket::sslErrors), this, &LanLinkProvider::sslErrors);\n\n            socket->startServerEncryption();\n\n            return; // Return statement prevents from deleting received packet, needed in slot \"encrypted\"\n        } else {\n            qWarning() << receivedPacket->get<QString>(QStringLiteral(\"deviceName\")) << \"uses an old protocol version, this won't work\";\n            //addLink(deviceId, socket, receivedPacket, LanDeviceLink::Remotely);\n        }\n\n    } else {\n        //I think this will never happen, but if it happens the deviceLink\n        //(or the socket that is now inside it) might not be valid. Delete them.\n        qCDebug(KDECONNECT_CORE) << \"Fallback (2), try reverse connection (send udp packet)\";\n        m_udpSocket.writeDatagram(np2.serialize(), m_receivedIdentityPackets[socket].sender, m_udpBroadcastPort);\n    }\n\n    delete m_receivedIdentityPackets.take(socket).np;\n    //We don't delete the socket because now it's owned by the LanDeviceLink\n}\n\nvoid LanLinkProvider::encrypted()\n{\n    qCDebug(KDECONNECT_CORE) << \"Socket successfully established an SSL connection\";\n\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n    if (!socket) return;\n\n    Q_ASSERT(socket->mode() != QSslSocket::UnencryptedMode);\n    LanDeviceLink::ConnectionStarted connectionOrigin = (socket->mode() == QSslSocket::SslClientMode)? LanDeviceLink::Locally : LanDeviceLink::Remotely;\n\n    NetworkPacket* receivedPacket = m_receivedIdentityPackets[socket].np;\n    const QString& deviceId = receivedPacket->get<QString>(QStringLiteral(\"deviceId\"));\n\n    addLink(deviceId, socket, receivedPacket, connectionOrigin);\n\n    // Copied from tcpSocketConnected slot, now delete received packet\n    delete m_receivedIdentityPackets.take(socket).np;\n}\n\nvoid LanLinkProvider::sslErrors(const QList<QSslError>& errors)\n{\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n    if (!socket) return;\n\n    bool fatal = false;\n    for (const QSslError& error : errors) {\n        if (error.error() != QSslError::SelfSignedCertificate) {\n            qCCritical(KDECONNECT_CORE) << \"Disconnecting due to fatal SSL Error: \" << error;\n            fatal = true;\n        } else {\n            qCDebug(KDECONNECT_CORE) << \"Ignoring self-signed cert error\";\n        }\n    }\n\n    if (fatal) {\n        socket->disconnectFromHost();\n        delete m_receivedIdentityPackets.take(socket).np;\n    }\n}\n\n//I'm the new device and this is the answer to my UDP identity packet (no data received yet). They are connecting to us through TCP, and they should send an identity.\nvoid LanLinkProvider::newConnection()\n{\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider newConnection\";\n\n    while (m_server->hasPendingConnections()) {\n        QSslSocket* socket = m_server->nextPendingConnection();\n        configureSocket(socket);\n        //This socket is still managed by us (and child of the QTcpServer), if\n        //it disconnects before we manage to pass it to a LanDeviceLink, it's\n        //our responsibility to delete it. We do so with this connection.\n        connect(socket, &QAbstractSocket::disconnected,\n                socket, &QObject::deleteLater);\n        connect(socket, &QIODevice::readyRead,\n                this, &LanLinkProvider::dataReceived);\n\n    }\n}\n\n//I'm the new device and this is the answer to my UDP identity packet (data received)\nvoid LanLinkProvider::dataReceived()\n{\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n    //the size here is arbitrary and is now at 8192 bytes. It needs to be considerably long as it includes the capabilities but there needs to be a limit\n    //Tested between my systems and I get around 2000 per identity package.\n    if (socket->bytesAvailable() > 8192) {\n        qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Suspiciously long identity package received. Closing connection.\" << socket->peerAddress() << socket->bytesAvailable();\n        socket->disconnectFromHost();\n        return;\n    }\n\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!socket->canReadLine())\n        return;\n#else\n    socket->startTransaction();\n#endif\n\n    const QByteArray data = socket->readLine();\n\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider received reply:\" << data;\n\n    NetworkPacket* np = new NetworkPacket(QLatin1String(\"\"));\n    bool success = NetworkPacket::unserialize(data, np);\n\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!success) {\n        delete np;\n        return;\n    }\n#else\n    if (!success) {\n        delete np;\n        socket->rollbackTransaction();\n        return;\n    }\n    socket->commitTransaction();\n#endif\n\n    if (np->type() != PACKET_TYPE_IDENTITY) {\n        qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Expected identity, received \" << np->type();\n        delete np;\n        return;\n    }\n\n    // Needed in \"encrypted\" if ssl is used, similar to \"tcpSocketConnected\"\n    m_receivedIdentityPackets[socket].np = np;\n\n    const QString& deviceId = np->get<QString>(QStringLiteral(\"deviceId\"));\n    //qCDebug(KDECONNECT_CORE) << \"Handshaking done (i'm the new device)\";\n\n    //This socket will now be owned by the LanDeviceLink or we don't want more data to be received, forget about it\n    disconnect(socket, &QIODevice::readyRead, this, &LanLinkProvider::dataReceived);\n\n    if (np->get<int>(QStringLiteral(\"protocolVersion\")) >= MIN_VERSION_WITH_SSL_SUPPORT) {\n\n        bool isDeviceTrusted = KdeConnectConfig::instance().trustedDevices().contains(deviceId);\n        configureSslSocket(socket, deviceId, isDeviceTrusted);\n\n        qCDebug(KDECONNECT_CORE) << \"Starting client ssl (but I'm the server TCP socket)\";\n\n        connect(socket, &QSslSocket::encrypted, this, &LanLinkProvider::encrypted);\n\n        if (isDeviceTrusted) {\n            connect(socket, QOverload<const QList<QSslError> &>::of(&QSslSocket::sslErrors), this, &LanLinkProvider::sslErrors);\n        }\n\n        socket->startClientEncryption();\n\n    } else {\n        qWarning() << np->get<QString>(QStringLiteral(\"deviceName\")) << \"uses an old protocol version, this won't work\";\n        //addLink(deviceId, socket, np, LanDeviceLink::Locally);\n        delete m_receivedIdentityPackets.take(socket).np;\n    }\n}\n\nvoid LanLinkProvider::deviceLinkDestroyed(QObject* destroyedDeviceLink)\n{\n    const QString id = destroyedDeviceLink->property(\"deviceId\").toString();\n    //qCDebug(KDECONNECT_CORE) << \"deviceLinkDestroyed\" << id;\n    QMap< QString, LanDeviceLink* >::iterator linkIterator = m_links.find(id);\n    Q_ASSERT(linkIterator != m_links.end());\n    if (linkIterator != m_links.end()) {\n        Q_ASSERT(linkIterator.value() == destroyedDeviceLink);\n        m_links.erase(linkIterator);\n        auto pairingHandler = m_pairingHandlers.take(id);\n        if (pairingHandler) {\n            pairingHandler->deleteLater();\n        }\n    }\n\n}\n\nvoid LanLinkProvider::configureSslSocket(QSslSocket* socket, const QString& deviceId, bool isDeviceTrusted)\n{\n    // Setting supported ciphers manually, to match those on Android (FIXME: Test if this can be left unconfigured and still works for Android 4)\n    QList<QSslCipher> socketCiphers;\n    socketCiphers.append(QSslCipher(QStringLiteral(\"ECDHE-ECDSA-AES256-GCM-SHA384\")));\n    socketCiphers.append(QSslCipher(QStringLiteral(\"ECDHE-ECDSA-AES128-GCM-SHA256\")));\n    socketCiphers.append(QSslCipher(QStringLiteral(\"ECDHE-RSA-AES128-SHA\")));\n\n    // Configure for ssl\n    QSslConfiguration sslConfig;\n    sslConfig.setCiphers(socketCiphers);\n    sslConfig.setLocalCertificate(KdeConnectConfig::instance().certificate());\n\n    QFile privateKeyFile(KdeConnectConfig::instance().privateKeyPath());\n    QSslKey privateKey;\n    if (privateKeyFile.open(QIODevice::ReadOnly)) {\n        privateKey = QSslKey(privateKeyFile.readAll(), QSsl::Rsa);\n    }\n    privateKeyFile.close();\n    sslConfig.setPrivateKey(privateKey);\n\n    if (isDeviceTrusted) {\n        QString certString = KdeConnectConfig::instance().getDeviceProperty(deviceId, QStringLiteral(\"certificate\"), QString());\n        sslConfig.setCaCertificates({QSslCertificate(certString.toLatin1())});\n        sslConfig.setPeerVerifyMode(QSslSocket::VerifyPeer);\n    } else {\n        sslConfig.setPeerVerifyMode(QSslSocket::QueryPeer);\n    }\n    socket->setSslConfiguration(sslConfig);\n    socket->setPeerVerifyName(deviceId);\n\n\n    //Usually SSL errors are only bad for trusted devices. Uncomment this section to log errors in any case, for debugging.\n    //QObject::connect(socket, static_cast<void (QSslSocket::*)(const QList<QSslError>&)>(&QSslSocket::sslErrors), [](const QList<QSslError>& errors)\n    //{\n    //    Q_FOREACH (const QSslError& error, errors) {\n    //        qCDebug(KDECONNECT_CORE) << \"SSL Error:\" << error.errorString();\n    //    }\n    //});\n}\n\nvoid LanLinkProvider::configureSocket(QSslSocket* socket) {\n\n    socket->setProxy(QNetworkProxy::NoProxy);\n\n    socket->setSocketOption(QAbstractSocket::KeepAliveOption, QVariant(1));\n\n#ifdef TCP_KEEPIDLE\n    // time to start sending keepalive packets (seconds)\n    int maxIdle = 10;\n    setsockopt(socket->socketDescriptor(), IPPROTO_TCP, TCP_KEEPIDLE, &maxIdle, sizeof(maxIdle));\n#endif\n\n#ifdef TCP_KEEPINTVL\n    // interval between keepalive packets after the initial period (seconds)\n    int interval = 5;\n    setsockopt(socket->socketDescriptor(), IPPROTO_TCP, TCP_KEEPINTVL, &interval, sizeof(interval));\n#endif\n\n#ifdef TCP_KEEPCNT\n    // number of missed keepalive packets before disconnecting\n    int count = 3;\n    setsockopt(socket->socketDescriptor(), IPPROTO_TCP, TCP_KEEPCNT, &count, sizeof(count));\n#endif\n\n}\n\nvoid LanLinkProvider::addLink(const QString& deviceId, QSslSocket* socket, NetworkPacket* receivedPacket, LanDeviceLink::ConnectionStarted connectionOrigin)\n{\n    // Socket disconnection will now be handled by LanDeviceLink\n    disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n\n    LanDeviceLink* deviceLink;\n    //Do we have a link for this device already?\n    QMap< QString, LanDeviceLink* >::iterator linkIterator = m_links.find(deviceId);\n    if (linkIterator != m_links.end()) {\n        //qCDebug(KDECONNECT_CORE) << \"Reusing link to\" << deviceId;\n        deviceLink = linkIterator.value();\n        deviceLink->reset(socket, connectionOrigin);\n    } else {\n        deviceLink = new LanDeviceLink(deviceId, this, socket, connectionOrigin);\n        connect(deviceLink, &QObject::destroyed, this, &LanLinkProvider::deviceLinkDestroyed);\n        m_links[deviceId] = deviceLink;\n        if (m_pairingHandlers.contains(deviceId)) {\n            //We shouldn't have a pairinghandler if we didn't have a link.\n            //Crash if debug, recover if release (by setting the new devicelink to the old pairinghandler)\n            Q_ASSERT(m_pairingHandlers.contains(deviceId));\n            m_pairingHandlers[deviceId]->setDeviceLink(deviceLink);\n        }\n    }\n    Q_EMIT onConnectionReceived(*receivedPacket, deviceLink);\n}\n\nLanPairingHandler* LanLinkProvider::createPairingHandler(DeviceLink* link)\n{\n    LanPairingHandler* ph = m_pairingHandlers.value(link->deviceId());\n    if (!ph) {\n        ph = new LanPairingHandler(link);\n        qCDebug(KDECONNECT_CORE) << \"creating pairing handler for\" << link->deviceId();\n        connect (ph, &LanPairingHandler::pairingError, link, &DeviceLink::pairingError);\n        m_pairingHandlers[link->deviceId()] = ph;\n    }\n    return ph;\n}\n\nvoid LanLinkProvider::userRequestsPair(const QString& deviceId)\n{\n    LanPairingHandler* ph = createPairingHandler(m_links.value(deviceId));\n    ph->requestPairing();\n}\n\nvoid LanLinkProvider::userRequestsUnpair(const QString& deviceId)\n{\n    LanPairingHandler* ph = createPairingHandler(m_links.value(deviceId));\n    ph->unpair();\n}\n\nvoid LanLinkProvider::incomingPairPacket(DeviceLink* deviceLink, const NetworkPacket& np)\n{\n    LanPairingHandler* ph = createPairingHandler(deviceLink);\n    ph->packetReceived(np);\n}\n\n"], "fixing_code": ["/**\n * SPDX-FileCopyrightText: 2013 Albert Vaca <albertvaka@gmail.com>\n *\n * SPDX-License-Identifier: GPL-2.0-only OR GPL-3.0-only OR LicenseRef-KDE-Accepted-GPL\n */\n\n#include \"lanlinkprovider.h\"\n#include \"core_debug.h\"\n\n#ifndef Q_OS_WIN\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <netdb.h>\n#endif\n\n#include <QHostInfo>\n#include <QTcpServer>\n#include <QMetaEnum>\n#include <QNetworkProxy>\n#include <QUdpSocket>\n#include <QNetworkSession>\n#include <QNetworkConfigurationManager>\n#include <QSslCipher>\n#include <QSslConfiguration>\n#include <QSslKey>\n\n#include \"daemon.h\"\n#include \"landevicelink.h\"\n#include \"lanpairinghandler.h\"\n#include \"kdeconnectconfig.h\"\n#include \"qtcompat_p.h\"\n\n#define MIN_VERSION_WITH_SSL_SUPPORT 6\n\nLanLinkProvider::LanLinkProvider(\n        bool testMode,\n        quint16 udpBroadcastPort,\n        quint16 udpListenPort\n        )\n    : m_server(new Server(this))\n    , m_udpSocket(this)\n    , m_tcpPort(0)\n    , m_udpBroadcastPort(udpBroadcastPort)\n    , m_udpListenPort(udpListenPort)\n    , m_testMode(testMode)\n    , m_combineBroadcastsTimer(this)\n{\n\n    m_combineBroadcastsTimer.setInterval(0); // increase this if waiting a single event-loop iteration is not enough\n    m_combineBroadcastsTimer.setSingleShot(true);\n    connect(&m_combineBroadcastsTimer, &QTimer::timeout, this, &LanLinkProvider::broadcastToNetwork);\n\n    connect(&m_udpSocket, &QIODevice::readyRead, this, &LanLinkProvider::udpBroadcastReceived);\n\n    m_server->setProxy(QNetworkProxy::NoProxy);\n    connect(m_server, &QTcpServer::newConnection, this, &LanLinkProvider::newConnection);\n\n    m_udpSocket.setProxy(QNetworkProxy::NoProxy);\n\n    //Detect when a network interface changes status, so we announce ourselves in the new network\n    QNetworkConfigurationManager* networkManager = new QNetworkConfigurationManager(this);\n    connect(networkManager, &QNetworkConfigurationManager::configurationChanged, this, &LanLinkProvider::onNetworkConfigurationChanged);\n\n}\n\nvoid LanLinkProvider::onNetworkConfigurationChanged(const QNetworkConfiguration& config)\n{\n    if (m_lastConfig != config && config.state() == QNetworkConfiguration::Active) {\n        m_lastConfig = config;\n        onNetworkChange();\n    }\n}\n\nLanLinkProvider::~LanLinkProvider()\n{\n}\n\nvoid LanLinkProvider::onStart()\n{\n    const QHostAddress bindAddress = m_testMode? QHostAddress::LocalHost : QHostAddress::Any;\n\n    bool success = m_udpSocket.bind(bindAddress, m_udpListenPort, QUdpSocket::ShareAddress);\n    if (!success) {\n        QAbstractSocket::SocketError sockErr = m_udpSocket.error();\n        // Refer to https://doc.qt.io/qt-5/qabstractsocket.html#SocketError-enum to decode socket error number\n        QString errorMessage = QString::fromLatin1(QMetaEnum::fromType<QAbstractSocket::SocketError>().valueToKey(sockErr));\n        qCritical(KDECONNECT_CORE)\n                << QLatin1String(\"Failed to bind UDP socket on port\")\n                << m_udpListenPort\n                << QLatin1String(\"with error\")\n                << errorMessage;\n    }\n    Q_ASSERT(success);\n\n    m_tcpPort = MIN_TCP_PORT;\n    while (!m_server->listen(bindAddress, m_tcpPort)) {\n        m_tcpPort++;\n        if (m_tcpPort > MAX_TCP_PORT) { //No ports available?\n            qCritical(KDECONNECT_CORE) << \"Error opening a port in range\" << MIN_TCP_PORT << \"-\" << MAX_TCP_PORT;\n            m_tcpPort = 0;\n            return;\n        }\n    }\n\n    onNetworkChange();\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider started\";\n}\n\nvoid LanLinkProvider::onStop()\n{\n    m_udpSocket.close();\n    m_server->close();\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider stopped\";\n}\n\nvoid LanLinkProvider::onNetworkChange()\n{\n    if (m_combineBroadcastsTimer.isActive()) {\n        qCDebug(KDECONNECT_CORE) << \"Preventing duplicate broadcasts\";\n        return;\n    }\n    m_combineBroadcastsTimer.start();\n}\n\n//I'm in a new network, let's be polite and introduce myself\nvoid LanLinkProvider::broadcastToNetwork()\n{\n    if (!m_server->isListening()) {\n        //Not started\n        return;\n    }\n\n    Q_ASSERT(m_tcpPort != 0);\n\n    qCDebug(KDECONNECT_CORE()) << \"Broadcasting identity packet\";\n\n    QList<QHostAddress> destinations = getBroadcastAddresses();\n\n    NetworkPacket np;\n    NetworkPacket::createIdentityPacket(&np);\n    np.set(QStringLiteral(\"tcpPort\"), m_tcpPort);\n\n#ifdef Q_OS_WIN\n    //On Windows we need to broadcast from every local IP address to reach all networks\n    QUdpSocket sendSocket;\n    sendSocket.setProxy(QNetworkProxy::NoProxy);\n    for (const QNetworkInterface& iface : QNetworkInterface::allInterfaces()) {\n        if ( (iface.flags() & QNetworkInterface::IsUp)\n             && (iface.flags() & QNetworkInterface::IsRunning)\n             && (iface.flags() & QNetworkInterface::CanBroadcast)) {\n            for (const QNetworkAddressEntry& ifaceAddress : iface.addressEntries()) {\n                QHostAddress sourceAddress = ifaceAddress.ip();\n                if (sourceAddress.protocol() == QAbstractSocket::IPv4Protocol && sourceAddress != QHostAddress::LocalHost) {\n                    qCDebug(KDECONNECT_CORE()) << \"Broadcasting as\" << sourceAddress;\n                    sendBroadcasts(sendSocket, np, destinations);\n                    sendSocket.close();\n                }\n            }\n        }\n    }\n#else\n    sendBroadcasts(m_udpSocket, np, destinations);\n#endif\n}\n\nQList<QHostAddress> LanLinkProvider::getBroadcastAddresses()\n{\n    const QStringList customDevices = KdeConnectConfig::instance().customDevices();\n\n    QList<QHostAddress> destinations;\n    destinations.reserve(customDevices.length() + 1);\n\n    // Default broadcast address\n    destinations.append(m_testMode ? QHostAddress::LocalHost : QHostAddress::Broadcast);\n\n    // Custom device addresses\n    for (auto& customDevice : customDevices) {\n        QHostAddress address(customDevice);\n        if (address.isNull()) {\n            qCWarning(KDECONNECT_CORE) << \"Invalid custom device address\" << customDevice;\n        } else {\n            destinations.append(address);\n        }\n    }\n\n    return destinations;\n}\n\nvoid LanLinkProvider::sendBroadcasts(\n        QUdpSocket& socket, const NetworkPacket& np, const QList<QHostAddress>& addresses)\n{\n    const QByteArray payload = np.serialize();\n\n    for (auto& address : addresses) {\n        socket.writeDatagram(payload, address, m_udpBroadcastPort);\n    }\n}\n\n//I'm the existing device, a new device is kindly introducing itself.\n//I will create a TcpSocket and try to connect. This can result in either tcpSocketConnected() or connectError().\nvoid LanLinkProvider::udpBroadcastReceived()\n{\n    while (m_udpSocket.hasPendingDatagrams()) {\n\n        QByteArray datagram;\n        datagram.resize(m_udpSocket.pendingDatagramSize());\n        QHostAddress sender;\n\n        m_udpSocket.readDatagram(datagram.data(), datagram.size(), &sender);\n\n        if (sender.isLoopback() && !m_testMode)\n            continue;\n\n        NetworkPacket* receivedPacket = new NetworkPacket(QLatin1String(\"\"));\n        bool success = NetworkPacket::unserialize(datagram, receivedPacket);\n\n        //qCDebug(KDECONNECT_CORE) << \"udp connection from \" << receivedPacket->;\n\n        //qCDebug(KDECONNECT_CORE) << \"Datagram \" << datagram.data() ;\n\n        if (!success) {\n            qCDebug(KDECONNECT_CORE) << \"Could not unserialize UDP packet\";\n            delete receivedPacket;\n            continue;\n        }\n\n        if (receivedPacket->type() != PACKET_TYPE_IDENTITY) {\n            qCDebug(KDECONNECT_CORE) << \"Received a UDP packet of wrong type\" << receivedPacket->type();\n            delete receivedPacket;\n            continue;\n        }\n\n        if (receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) == KdeConnectConfig::instance().deviceId()) {\n            //qCDebug(KDECONNECT_CORE) << \"Ignoring my own broadcast\";\n            delete receivedPacket;\n            continue;\n        }\n\n        int tcpPort = receivedPacket->get<int>(QStringLiteral(\"tcpPort\"));\n\n        //qCDebug(KDECONNECT_CORE) << \"Received Udp identity packet from\" << sender << \" asking for a tcp connection on port \" << tcpPort;\n\n        QSslSocket* socket = new QSslSocket(this);\n        socket->setProxy(QNetworkProxy::NoProxy);\n        m_receivedIdentityPackets[socket].np = receivedPacket;\n        m_receivedIdentityPackets[socket].sender = sender;\n        connect(socket, &QAbstractSocket::connected, this, &LanLinkProvider::tcpSocketConnected);\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n        connect(socket, QOverload<QAbstractSocket::SocketError>::of(&QAbstractSocket::error), this, &LanLinkProvider::connectError);\n#else\n        connect(socket, &QAbstractSocket::errorOccurred, this, &LanLinkProvider::connectError);\n#endif\n        socket->connectToHost(sender, tcpPort);\n    }\n}\n\nvoid LanLinkProvider::connectError(QAbstractSocket::SocketError socketError)\n{\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n    if (!socket) return;\n\n    qCDebug(KDECONNECT_CORE) << \"Socket error\" << socketError;\n    qCDebug(KDECONNECT_CORE) << \"Fallback (1), try reverse connection (send udp packet)\" << socket->errorString();\n    NetworkPacket np(QLatin1String(\"\"));\n    NetworkPacket::createIdentityPacket(&np);\n    np.set(QStringLiteral(\"tcpPort\"), m_tcpPort);\n    m_udpSocket.writeDatagram(np.serialize(), m_receivedIdentityPackets[socket].sender, m_udpBroadcastPort);\n\n    //The socket we created didn't work, and we didn't manage\n    //to create a LanDeviceLink from it, deleting everything.\n    delete m_receivedIdentityPackets.take(socket).np;\n    socket->deleteLater();\n}\n\n//We received a UDP packet and answered by connecting to them by TCP. This gets called on a successful connection.\nvoid LanLinkProvider::tcpSocketConnected()\n{\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n\n    if (!socket) return;\n    // TODO Delete me?\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n    disconnect(socket, QOverload<QAbstractSocket::SocketError>::of(&QAbstractSocket::error), this, &LanLinkProvider::connectError);\n#else\n    disconnect(socket, &QAbstractSocket::errorOccurred, this, &LanLinkProvider::connectError);\n#endif\n\n    configureSocket(socket);\n\n    // If socket disconnects due to any reason after connection, link on ssl failure\n    connect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n\n    NetworkPacket* receivedPacket = m_receivedIdentityPackets[socket].np;\n    const QString& deviceId = receivedPacket->get<QString>(QStringLiteral(\"deviceId\"));\n    //qCDebug(KDECONNECT_CORE) << \"tcpSocketConnected\" << socket->isWritable();\n\n    // If network is on ssl, do not believe when they are connected, believe when handshake is completed\n    NetworkPacket np2(QLatin1String(\"\"));\n    NetworkPacket::createIdentityPacket(&np2);\n    socket->write(np2.serialize());\n    bool success = socket->waitForBytesWritten();\n\n    if (success) {\n\n        qCDebug(KDECONNECT_CORE) << \"TCP connection done (i'm the existing device)\";\n\n        // if ssl supported\n        if (receivedPacket->get<int>(QStringLiteral(\"protocolVersion\")) >= MIN_VERSION_WITH_SSL_SUPPORT) {\n\n            bool isDeviceTrusted = KdeConnectConfig::instance().trustedDevices().contains(deviceId);\n            configureSslSocket(socket, deviceId, isDeviceTrusted);\n\n            qCDebug(KDECONNECT_CORE) << \"Starting server ssl (I'm the client TCP socket)\";\n\n            connect(socket, &QSslSocket::encrypted, this, &LanLinkProvider::encrypted);\n\n            connect(socket, QOverload<const QList<QSslError> &>::of(&QSslSocket::sslErrors), this, &LanLinkProvider::sslErrors);\n\n            socket->startServerEncryption();\n\n            return; // Return statement prevents from deleting received packet, needed in slot \"encrypted\"\n        } else {\n            qWarning() << receivedPacket->get<QString>(QStringLiteral(\"deviceName\")) << \"uses an old protocol version, this won't work\";\n            //addLink(deviceId, socket, receivedPacket, LanDeviceLink::Remotely);\n        }\n\n    } else {\n        //I think this will never happen, but if it happens the deviceLink\n        //(or the socket that is now inside it) might not be valid. Delete them.\n        qCDebug(KDECONNECT_CORE) << \"Fallback (2), try reverse connection (send udp packet)\";\n        m_udpSocket.writeDatagram(np2.serialize(), m_receivedIdentityPackets[socket].sender, m_udpBroadcastPort);\n    }\n\n    delete m_receivedIdentityPackets.take(socket).np;\n    //We don't delete the socket because now it's owned by the LanDeviceLink\n}\n\nvoid LanLinkProvider::encrypted()\n{\n    qCDebug(KDECONNECT_CORE) << \"Socket successfully established an SSL connection\";\n\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n    if (!socket) return;\n\n    Q_ASSERT(socket->mode() != QSslSocket::UnencryptedMode);\n    LanDeviceLink::ConnectionStarted connectionOrigin = (socket->mode() == QSslSocket::SslClientMode)? LanDeviceLink::Locally : LanDeviceLink::Remotely;\n\n    NetworkPacket* receivedPacket = m_receivedIdentityPackets[socket].np;\n    const QString& deviceId = receivedPacket->get<QString>(QStringLiteral(\"deviceId\"));\n\n    addLink(deviceId, socket, receivedPacket, connectionOrigin);\n\n    // Copied from tcpSocketConnected slot, now delete received packet\n    delete m_receivedIdentityPackets.take(socket).np;\n}\n\nvoid LanLinkProvider::sslErrors(const QList<QSslError>& errors)\n{\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n    if (!socket) return;\n\n    bool fatal = false;\n    for (const QSslError& error : errors) {\n        if (error.error() != QSslError::SelfSignedCertificate) {\n            qCCritical(KDECONNECT_CORE) << \"Disconnecting due to fatal SSL Error: \" << error;\n            fatal = true;\n        } else {\n            qCDebug(KDECONNECT_CORE) << \"Ignoring self-signed cert error\";\n        }\n    }\n\n    if (fatal) {\n        socket->disconnectFromHost();\n        delete m_receivedIdentityPackets.take(socket).np;\n    }\n}\n\n//I'm the new device and this is the answer to my UDP identity packet (no data received yet). They are connecting to us through TCP, and they should send an identity.\nvoid LanLinkProvider::newConnection()\n{\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider newConnection\";\n\n    while (m_server->hasPendingConnections()) {\n        QSslSocket* socket = m_server->nextPendingConnection();\n        configureSocket(socket);\n        //This socket is still managed by us (and child of the QTcpServer), if\n        //it disconnects before we manage to pass it to a LanDeviceLink, it's\n        //our responsibility to delete it. We do so with this connection.\n        connect(socket, &QAbstractSocket::disconnected,\n                socket, &QObject::deleteLater);\n        connect(socket, &QIODevice::readyRead,\n                this, &LanLinkProvider::dataReceived);\n\n        QTimer* timer = new QTimer(socket);\n        timer->setSingleShot(true);\n        timer->setInterval(1000);\n        connect(socket, &QSslSocket::encrypted,\n                timer, &QObject::deleteLater);\n        connect(timer, &QTimer::timeout, socket, [socket] {\n            qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Host timed out without sending any identity.\" << socket->peerAddress();\n            socket->disconnectFromHost();\n        });\n        timer->start();\n    }\n}\n\n//I'm the new device and this is the answer to my UDP identity packet (data received)\nvoid LanLinkProvider::dataReceived()\n{\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n    //the size here is arbitrary and is now at 8192 bytes. It needs to be considerably long as it includes the capabilities but there needs to be a limit\n    //Tested between my systems and I get around 2000 per identity package.\n    if (socket->bytesAvailable() > 8192) {\n        qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Suspiciously long identity package received. Closing connection.\" << socket->peerAddress() << socket->bytesAvailable();\n        socket->disconnectFromHost();\n        return;\n    }\n\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!socket->canReadLine())\n        return;\n#else\n    socket->startTransaction();\n#endif\n\n    const QByteArray data = socket->readLine();\n\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider received reply:\" << data;\n\n    NetworkPacket* np = new NetworkPacket(QLatin1String(\"\"));\n    bool success = NetworkPacket::unserialize(data, np);\n\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!success) {\n        delete np;\n        return;\n    }\n#else\n    if (!success) {\n        delete np;\n        socket->rollbackTransaction();\n        return;\n    }\n    socket->commitTransaction();\n#endif\n\n    if (np->type() != PACKET_TYPE_IDENTITY) {\n        qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Expected identity, received \" << np->type();\n        delete np;\n        return;\n    }\n\n    // Needed in \"encrypted\" if ssl is used, similar to \"tcpSocketConnected\"\n    m_receivedIdentityPackets[socket].np = np;\n\n    const QString& deviceId = np->get<QString>(QStringLiteral(\"deviceId\"));\n    //qCDebug(KDECONNECT_CORE) << \"Handshaking done (i'm the new device)\";\n\n    //This socket will now be owned by the LanDeviceLink or we don't want more data to be received, forget about it\n    disconnect(socket, &QIODevice::readyRead, this, &LanLinkProvider::dataReceived);\n\n    if (np->get<int>(QStringLiteral(\"protocolVersion\")) >= MIN_VERSION_WITH_SSL_SUPPORT) {\n\n        bool isDeviceTrusted = KdeConnectConfig::instance().trustedDevices().contains(deviceId);\n        configureSslSocket(socket, deviceId, isDeviceTrusted);\n\n        qCDebug(KDECONNECT_CORE) << \"Starting client ssl (but I'm the server TCP socket)\";\n\n        connect(socket, &QSslSocket::encrypted, this, &LanLinkProvider::encrypted);\n\n        if (isDeviceTrusted) {\n            connect(socket, QOverload<const QList<QSslError> &>::of(&QSslSocket::sslErrors), this, &LanLinkProvider::sslErrors);\n        }\n\n        socket->startClientEncryption();\n\n    } else {\n        qWarning() << np->get<QString>(QStringLiteral(\"deviceName\")) << \"uses an old protocol version, this won't work\";\n        //addLink(deviceId, socket, np, LanDeviceLink::Locally);\n        delete m_receivedIdentityPackets.take(socket).np;\n    }\n}\n\nvoid LanLinkProvider::deviceLinkDestroyed(QObject* destroyedDeviceLink)\n{\n    const QString id = destroyedDeviceLink->property(\"deviceId\").toString();\n    //qCDebug(KDECONNECT_CORE) << \"deviceLinkDestroyed\" << id;\n    QMap< QString, LanDeviceLink* >::iterator linkIterator = m_links.find(id);\n    Q_ASSERT(linkIterator != m_links.end());\n    if (linkIterator != m_links.end()) {\n        Q_ASSERT(linkIterator.value() == destroyedDeviceLink);\n        m_links.erase(linkIterator);\n        auto pairingHandler = m_pairingHandlers.take(id);\n        if (pairingHandler) {\n            pairingHandler->deleteLater();\n        }\n    }\n\n}\n\nvoid LanLinkProvider::configureSslSocket(QSslSocket* socket, const QString& deviceId, bool isDeviceTrusted)\n{\n    // Setting supported ciphers manually, to match those on Android (FIXME: Test if this can be left unconfigured and still works for Android 4)\n    QList<QSslCipher> socketCiphers;\n    socketCiphers.append(QSslCipher(QStringLiteral(\"ECDHE-ECDSA-AES256-GCM-SHA384\")));\n    socketCiphers.append(QSslCipher(QStringLiteral(\"ECDHE-ECDSA-AES128-GCM-SHA256\")));\n    socketCiphers.append(QSslCipher(QStringLiteral(\"ECDHE-RSA-AES128-SHA\")));\n\n    // Configure for ssl\n    QSslConfiguration sslConfig;\n    sslConfig.setCiphers(socketCiphers);\n    sslConfig.setLocalCertificate(KdeConnectConfig::instance().certificate());\n\n    QFile privateKeyFile(KdeConnectConfig::instance().privateKeyPath());\n    QSslKey privateKey;\n    if (privateKeyFile.open(QIODevice::ReadOnly)) {\n        privateKey = QSslKey(privateKeyFile.readAll(), QSsl::Rsa);\n    }\n    privateKeyFile.close();\n    sslConfig.setPrivateKey(privateKey);\n\n    if (isDeviceTrusted) {\n        QString certString = KdeConnectConfig::instance().getDeviceProperty(deviceId, QStringLiteral(\"certificate\"), QString());\n        sslConfig.setCaCertificates({QSslCertificate(certString.toLatin1())});\n        sslConfig.setPeerVerifyMode(QSslSocket::VerifyPeer);\n    } else {\n        sslConfig.setPeerVerifyMode(QSslSocket::QueryPeer);\n    }\n    socket->setSslConfiguration(sslConfig);\n    socket->setPeerVerifyName(deviceId);\n\n\n    //Usually SSL errors are only bad for trusted devices. Uncomment this section to log errors in any case, for debugging.\n    //QObject::connect(socket, static_cast<void (QSslSocket::*)(const QList<QSslError>&)>(&QSslSocket::sslErrors), [](const QList<QSslError>& errors)\n    //{\n    //    Q_FOREACH (const QSslError& error, errors) {\n    //        qCDebug(KDECONNECT_CORE) << \"SSL Error:\" << error.errorString();\n    //    }\n    //});\n}\n\nvoid LanLinkProvider::configureSocket(QSslSocket* socket) {\n\n    socket->setProxy(QNetworkProxy::NoProxy);\n\n    socket->setSocketOption(QAbstractSocket::KeepAliveOption, QVariant(1));\n\n#ifdef TCP_KEEPIDLE\n    // time to start sending keepalive packets (seconds)\n    int maxIdle = 10;\n    setsockopt(socket->socketDescriptor(), IPPROTO_TCP, TCP_KEEPIDLE, &maxIdle, sizeof(maxIdle));\n#endif\n\n#ifdef TCP_KEEPINTVL\n    // interval between keepalive packets after the initial period (seconds)\n    int interval = 5;\n    setsockopt(socket->socketDescriptor(), IPPROTO_TCP, TCP_KEEPINTVL, &interval, sizeof(interval));\n#endif\n\n#ifdef TCP_KEEPCNT\n    // number of missed keepalive packets before disconnecting\n    int count = 3;\n    setsockopt(socket->socketDescriptor(), IPPROTO_TCP, TCP_KEEPCNT, &count, sizeof(count));\n#endif\n\n}\n\nvoid LanLinkProvider::addLink(const QString& deviceId, QSslSocket* socket, NetworkPacket* receivedPacket, LanDeviceLink::ConnectionStarted connectionOrigin)\n{\n    // Socket disconnection will now be handled by LanDeviceLink\n    disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n\n    LanDeviceLink* deviceLink;\n    //Do we have a link for this device already?\n    QMap< QString, LanDeviceLink* >::iterator linkIterator = m_links.find(deviceId);\n    if (linkIterator != m_links.end()) {\n        //qCDebug(KDECONNECT_CORE) << \"Reusing link to\" << deviceId;\n        deviceLink = linkIterator.value();\n        deviceLink->reset(socket, connectionOrigin);\n    } else {\n        deviceLink = new LanDeviceLink(deviceId, this, socket, connectionOrigin);\n        connect(deviceLink, &QObject::destroyed, this, &LanLinkProvider::deviceLinkDestroyed);\n        m_links[deviceId] = deviceLink;\n        if (m_pairingHandlers.contains(deviceId)) {\n            //We shouldn't have a pairinghandler if we didn't have a link.\n            //Crash if debug, recover if release (by setting the new devicelink to the old pairinghandler)\n            Q_ASSERT(m_pairingHandlers.contains(deviceId));\n            m_pairingHandlers[deviceId]->setDeviceLink(deviceLink);\n        }\n    }\n    Q_EMIT onConnectionReceived(*receivedPacket, deviceLink);\n}\n\nLanPairingHandler* LanLinkProvider::createPairingHandler(DeviceLink* link)\n{\n    LanPairingHandler* ph = m_pairingHandlers.value(link->deviceId());\n    if (!ph) {\n        ph = new LanPairingHandler(link);\n        qCDebug(KDECONNECT_CORE) << \"creating pairing handler for\" << link->deviceId();\n        connect (ph, &LanPairingHandler::pairingError, link, &DeviceLink::pairingError);\n        m_pairingHandlers[link->deviceId()] = ph;\n    }\n    return ph;\n}\n\nvoid LanLinkProvider::userRequestsPair(const QString& deviceId)\n{\n    LanPairingHandler* ph = createPairingHandler(m_links.value(deviceId));\n    ph->requestPairing();\n}\n\nvoid LanLinkProvider::userRequestsUnpair(const QString& deviceId)\n{\n    LanPairingHandler* ph = createPairingHandler(m_links.value(deviceId));\n    ph->unpair();\n}\n\nvoid LanLinkProvider::incomingPairPacket(DeviceLink* deviceLink, const NetworkPacket& np)\n{\n    LanPairingHandler* ph = createPairingHandler(deviceLink);\n    ph->packetReceived(np);\n}\n\n"], "filenames": ["core/backends/lan/lanlinkprovider.cpp"], "buggy_code_start_loc": [394], "buggy_code_end_loc": [394], "fixing_code_start_loc": [395], "fixing_code_end_loc": [405], "type": "CWE-400", "message": "In kdeconnect-kde (aka KDE Connect) before 20.08.2, an attacker on the local network could send crafted packets that trigger use of large amounts of CPU, memory, or network connection slots, aka a Denial of Service attack.", "other": {"cve": {"id": "CVE-2020-26164", "sourceIdentifier": "cve@mitre.org", "published": "2020-10-07T19:15:12.987", "lastModified": "2023-01-31T21:44:01.613", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In kdeconnect-kde (aka KDE Connect) before 20.08.2, an attacker on the local network could send crafted packets that trigger use of large amounts of CPU, memory, or network connection slots, aka a Denial of Service attack."}, {"lang": "es", "value": "En kdeconnect-kde (tambi\u00e9n se conoce como KDE Connect) versiones anteriores a 20.08.2, un atacante en la red local podr\u00eda enviar paquetes dise\u00f1ados que desencadenan el uso de grandes cantidades de CPU, memoria o slots de conexi\u00f3n de red, tambi\u00e9n se conoce como un ataque de Denegaci\u00f3n de Servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kde:kdeconnect:*:*:*:*:*:*:*:*", "versionEndExcluding": "20.08.2", "matchCriteriaId": "88091C4B-7C19-443E-91ED-D8C5869FE492"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:backports_sle:15.0:sp1:*:*:*:*:*:*", "matchCriteriaId": "40513095-7E6E-46B3-B604-C926F1BA3568"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:backports_sle:15.0:sp2:*:*:*:*:*:*", "matchCriteriaId": "67E82302-4B77-44F3-97B1-24C18AC4A35D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-10/msg00016.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-10/msg00018.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2020/10/13/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2020/10/13/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2020/10/14/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2020/11/30/1", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1176268", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/KDE/kdeconnect-kde/commit/024e5f23db8d8ad3449714b906b46094baaffb89", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/KDE/kdeconnect-kde/commit/4fbd01a3d44a0bcca888c49a77ec7cfd10e113d7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/KDE/kdeconnect-kde/commit/542d94a70c56aa386c8d4d793481ce181b0422e8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/KDE/kdeconnect-kde/commit/613899be24b6e2a6b3e5cc719efce8ae8a122991", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/KDE/kdeconnect-kde/commit/8112729eb0f13e6947984416118531078e65580d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/KDE/kdeconnect-kde/commit/ce0f00fc2d3eccb51d0af4eba61a4f60de086a59", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/KDE/kdeconnect-kde/releases", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://kde.org/info/security/advisory-20201002-1.txt", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "Vendor Advisory"]}, {"url": "https://kdeconnect.kde.org/official/", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://lists.opensuse.org/opensuse-security-announce/2020-10/msg00014.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202101-16", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/KDE/kdeconnect-kde/commit/024e5f23db8d8ad3449714b906b46094baaffb89"}}