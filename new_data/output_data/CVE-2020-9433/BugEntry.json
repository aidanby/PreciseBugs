{"buggy_code": ["/***\nx509 modules for lua-openssl binding\ncreate and manage x509 certificate\n@module x509\n@usage\n x509 = require'openssl'.x509\n*/\n\n\n#include \"openssl.h\"\n#include \"private.h\"\n#define CRYPTO_LOCK_REF\n#include \"sk.h\"\n\n#define MYNAME    \"x509\"\n#define MYVERSION MYNAME \" library for \" LUA_VERSION \" / Nov 2014 / \"\\\n  \"based on OpenSSL \" SHLIB_VERSION_NUMBER\n\n#if OPENSSL_VERSION_NUMBER < 0x1010000fL || \\\n\t(defined(LIBRESSL_VERSION_NUMBER) && (LIBRESSL_VERSION_NUMBER < 0x20700000L))\n#define X509_get0_notBefore X509_get_notBefore\n#define X509_get0_notAfter X509_get_notAfter\n#define X509_set1_notBefore X509_set_notBefore\n#define X509_set1_notAfter X509_set_notAfter\n#endif\n\nstatic int openssl_push_purpose(lua_State*L, X509_PURPOSE* purpose)\n{\n  lua_newtable(L);\n\n  AUXILIAR_SET(L, -1, \"purpose\", purpose->purpose, integer);\n  AUXILIAR_SET(L, -1, \"trust\", purpose->trust, integer);\n  AUXILIAR_SET(L, -1, \"flags\", purpose->flags, integer);\n\n  AUXILIAR_SET(L, -1, \"name\", purpose->name, string);\n  AUXILIAR_SET(L, -1, \"sname\", purpose->sname, string);\n\n  return 1;\n};\n\n/***\nreturn all supported purpose as table\n@function purpose\n@treturn table\n*/\n/*\nget special purpose info as table\n@function purpose\n@tparam number|string purpose id or short name\n@treturn table\n*/\nstatic int openssl_x509_purpose(lua_State*L)\n{\n  if (lua_isnone(L, 1))\n  {\n    int count = X509_PURPOSE_get_count();\n    int i;\n    lua_newtable(L);\n    for (i = 0; i < count; i++)\n    {\n      X509_PURPOSE* purpose = X509_PURPOSE_get0(i);\n      openssl_push_purpose(L, purpose);\n      lua_rawseti(L, -2, i + 1);\n    }\n    return 1;\n  }\n  else if (lua_isnumber(L, 1))\n  {\n    int idx = X509_PURPOSE_get_by_id(lua_tointeger(L, 1));\n    if (idx >= 0)\n    {\n      X509_PURPOSE* purpose = X509_PURPOSE_get0(idx);\n      openssl_push_purpose(L, purpose);\n    }\n    else\n      lua_pushnil(L);\n    return 1;\n  }\n  else if (lua_isstring(L, 1))\n  {\n    char* name = (char*)lua_tostring(L, 1);\n    int idx = X509_PURPOSE_get_by_sname(name);\n    if (idx >= 0)\n    {\n      X509_PURPOSE* purpose = X509_PURPOSE_get0(idx);\n      openssl_push_purpose(L, purpose);\n    }\n    else\n      lua_pushnil(L);\n    return 1;\n  }\n  else\n    luaL_argerror(L, 1, \"only accpet none, string or number as nid or short name\");\n\n  return 0;\n};\n\nstatic const char* usage_mode[] =\n{\n  \"standard\",\n  \"netscape\",\n  \"extend\",\n  NULL\n};\n\n/***\nget support certtypes\n@function certtypes\n@tparam[opt='standard'] string type support 'standard','netscape','extend'\n@treturn table if type is 'standard' or 'netscape', contains node with {lname=...,sname=...,bitname=...},\n               if type is 'extend', contains node with {lname=...,sname=...,nid=...}\n*/\nstatic int openssl_x509_certtypes(lua_State*L)\n{\n  int mode = luaL_checkoption(L, 1, \"standard\", usage_mode);\n  int i;\n  const BIT_STRING_BITNAME* bitname;\n\n  switch (mode)\n  {\n  case 0:\n  {\n    const static BIT_STRING_BITNAME key_usage_type_table[] =\n    {\n      {0, \"Digital Signature\", \"digitalSignature\"},\n      {1, \"Non Repudiation\", \"nonRepudiation\"},\n      {2, \"Key Encipherment\", \"keyEncipherment\"},\n      {3, \"Data Encipherment\", \"dataEncipherment\"},\n      {4, \"Key Agreement\", \"keyAgreement\"},\n      {5, \"Certificate Sign\", \"keyCertSign\"},\n      {6, \"CRL Sign\", \"cRLSign\"},\n      {7, \"Encipher Only\", \"encipherOnly\"},\n      {8, \"Decipher Only\", \"decipherOnly\"},\n      { -1, NULL, NULL}\n    };\n    lua_newtable(L);\n    for (i = 0, bitname = &key_usage_type_table[i]; bitname->bitnum != -1; i++, bitname = &key_usage_type_table[i])\n    {\n      openssl_push_bit_string_bitname(L, bitname);\n      lua_rawseti(L, -2, i + 1);\n    }\n    return 1;\n\n  }\n  case 1:\n  {\n    const static BIT_STRING_BITNAME ns_cert_type_table[] =\n    {\n      {0, \"SSL Client\", \"client\"},\n      {1, \"SSL Server\", \"server\"},\n      {2, \"S/MIME\", \"email\"},\n      {3, \"Object Signing\", \"objsign\"},\n      {4, \"Unused\", \"reserved\"},\n      {5, \"SSL CA\", \"sslCA\"},\n      {6, \"S/MIME CA\", \"emailCA\"},\n      {7, \"Object Signing CA\", \"objCA\"},\n      { -1, NULL, NULL}\n    };\n    lua_newtable(L);\n    for (i = 0, bitname = &ns_cert_type_table[i]; bitname->bitnum != -1; i++, bitname = &ns_cert_type_table[i])\n    {\n      openssl_push_bit_string_bitname(L, bitname);\n      lua_rawseti(L, -2, i + 1);\n    }\n    return 1;\n  }\n  case 2:\n  {\n    static const int ext_nids[] =\n    {\n      NID_server_auth,\n      NID_client_auth,\n      NID_email_protect,\n      NID_code_sign,\n      NID_ms_sgc,\n      NID_ns_sgc,\n      NID_OCSP_sign,\n      NID_time_stamp,\n      NID_dvcs,\n      NID_anyExtendedKeyUsage\n    };\n    int count = sizeof(ext_nids) / sizeof(int);\n    int nid;\n    lua_newtable(L);\n    for (i = 0; i < count; i++)\n    {\n      nid = ext_nids[i];\n      lua_newtable(L);\n      lua_pushstring(L, OBJ_nid2ln(nid));\n      lua_setfield(L, -2, \"lname\");\n      lua_pushstring(L, OBJ_nid2sn(nid));\n      lua_setfield(L, -2, \"sname\");\n      lua_pushinteger(L, nid);\n      lua_setfield(L, -2, \"nid\");\n      lua_rawseti(L, -2, i + 1);\n    };\n    return 1;\n  }\n  }\n  return 0;\n}\n\n/***\nget certificate verify result string message\n@function verify_cert_error_string\n@tparam number verify_result\n@treturn string result message\n*/\nstatic int openssl_verify_cert_error_string(lua_State*L)\n{\n  int v = luaL_checkint(L, 1);\n  const char*s = X509_verify_cert_error_string(v);\n  lua_pushstring(L, s);\n  return 1;\n}\n\n/***\nread x509 from string or bio input\n@function read\n@tparam bio|string input input data\n@tparam[opt='auto'] string format support 'auto','pem','der'\n@treturn x509 certificate object\n*/\nstatic LUA_FUNCTION(openssl_x509_read)\n{\n  X509 *cert = NULL;\n  BIO *in = load_bio_object(L, 1);\n  int fmt = luaL_checkoption(L, 2, \"auto\", format);\n  if (fmt == FORMAT_AUTO)\n  {\n    fmt = bio_is_der(in) ? FORMAT_DER : FORMAT_PEM;\n  }\n\n  if (fmt == FORMAT_DER)\n  {\n    cert = d2i_X509_bio(in, NULL);\n  }\n  else if (fmt == FORMAT_PEM)\n  {\n    cert = PEM_read_bio_X509(in, NULL, NULL, NULL);\n  }\n\n  BIO_free(in);\n\n  if (cert)\n  {\n    PUSH_OBJECT(cert, \"openssl.x509\");\n    return 1;\n  }\n  return openssl_pushresult(L, 0);\n}\n\n/***\ncreate or generate a new x509 object.\n@function new\n@tparam[opt] openssl.bn serial serial number\n@tparam[opt] x509_req csr,copy x509_name, pubkey and extension to new object\n@tparam[opt] x509_name subject subject name set to x509_req\n@tparam[opt] stack_of_x509_extension extensions add to x509\n@tparam[opt] stack_of_x509_attribute attributes add to x509\n@treturn x509 certificate object\n*/\nstatic int openssl_x509_new(lua_State* L)\n{\n  int i = 1;\n  int ret = 1;\n  int n = lua_gettop(L);\n  X509 *x = X509_new();\n\n  ret = X509_set_version(x, 2);\n  if (ret == 1 && (\n        auxiliar_getclassudata(L, \"openssl.bn\", i) ||\n        lua_isstring(L, i) || lua_isnumber(L, i)\n      ))\n  {\n    BIGNUM *bn = BN_get(L, i);\n    ASN1_INTEGER* ai = BN_to_ASN1_INTEGER(bn, NULL);\n    BN_free(bn);\n    ret = X509_set_serialNumber(x, ai);\n    ASN1_INTEGER_free(ai);\n    i++;\n  }\n\n  for (; i <= n; i++)\n  {\n    if (ret == 1 && auxiliar_getclassudata(L, \"openssl.x509_req\", i))\n    {\n      X509_REQ* csr = CHECK_OBJECT(i, X509_REQ, \"openssl.x509_req\");\n      X509_NAME* xn = X509_REQ_get_subject_name(csr);\n      ret = X509_set_subject_name(x, xn);\n\n      if (ret == 1)\n      {\n        STACK_OF(X509_EXTENSION) *exts = X509_REQ_get_extensions(csr);\n        int j, n1;\n        n1 = sk_X509_EXTENSION_num(exts);\n        for (j = 0; ret == 1 && j < n1; j++)\n        {\n          ret = X509_add_ext(x, sk_X509_EXTENSION_value(exts, j), j);\n        }\n        sk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);\n      }\n      if (ret == 1)\n      {\n        EVP_PKEY* pkey = X509_REQ_get_pubkey(csr);\n        ret = X509_set_pubkey(x, pkey);\n        EVP_PKEY_free(pkey);\n      }\n      i++;\n    };\n\n    if (ret == 1 && auxiliar_getclassudata(L, \"openssl.x509_name\", i))\n    {\n      X509_NAME *xn = CHECK_OBJECT(i, X509_NAME, \"openssl.x509_name\");\n      ret = X509_set_subject_name(x, xn);\n      i++;\n    }\n  }\n\n  if (ret == 1)\n  {\n    PUSH_OBJECT(x, \"openssl.x509\");\n    return 1;\n  }\n  else\n  {\n    X509_free(x);\n    return openssl_pushresult(L, ret);\n  }\n};\n\nstatic luaL_Reg R[] =\n{\n  {\"new\",           openssl_x509_new },\n  {\"read\",          openssl_x509_read },\n  {\"purpose\",       openssl_x509_purpose },\n  {\"certtypes\",     openssl_x509_certtypes },\n  {\"verify_cert_error_string\", openssl_verify_cert_error_string },\n\n  {NULL,    NULL}\n};\n\nint openssl_push_general_name(lua_State*L, const GENERAL_NAME* general_name)\n{\n  if (general_name == NULL)\n  {\n    lua_pushnil(L);\n    return 1;\n  }\n  lua_newtable(L);\n\n  switch (general_name->type)\n  {\n  case GEN_OTHERNAME:\n  {\n    OTHERNAME *otherName = general_name->d.otherName;\n    lua_newtable(L);\n    openssl_push_asn1object(L, otherName->type_id);\n    PUSH_ASN1_STRING(L, otherName->value->value.asn1_string);\n    lua_settable(L, -3);\n    lua_setfield(L, -2, \"otherName\");\n\n    lua_pushstring(L, \"otherName\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  }\n  case GEN_EMAIL:\n    PUSH_ASN1_STRING(L, general_name->d.rfc822Name);\n    lua_setfield(L, -2, \"rfc822Name\");\n\n    lua_pushstring(L, \"rfc822Name\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  case GEN_DNS:\n    PUSH_ASN1_STRING(L, general_name->d.dNSName);\n    lua_setfield(L, -2, \"dNSName\");\n    lua_pushstring(L, \"dNSName\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  case GEN_X400:\n    openssl_push_asn1type(L, general_name->d.x400Address);\n    lua_setfield(L, -2, \"x400Address\");\n    lua_pushstring(L, \"x400Address\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  case GEN_DIRNAME:\n  {\n    X509_NAME* xn = general_name->d.directoryName;\n    openssl_push_xname_asobject(L, xn);\n    lua_setfield(L, -2, \"directoryName\");\n    lua_pushstring(L, \"directoryName\");\n    lua_setfield(L, -2, \"type\");\n  }\n  break;\n  case GEN_URI:\n    PUSH_ASN1_STRING(L, general_name->d.uniformResourceIdentifier);\n    lua_setfield(L, -2, \"uniformResourceIdentifier\");\n    lua_pushstring(L, \"uniformResourceIdentifier\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  case GEN_IPADD:\n    lua_newtable(L);\n    PUSH_ASN1_OCTET_STRING(L, general_name->d.iPAddress);\n    lua_setfield(L, -2, \"iPAddress\");\n    lua_pushstring(L, \"iPAddress\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  case GEN_EDIPARTY:\n    lua_newtable(L);\n    PUSH_ASN1_STRING(L, general_name->d.ediPartyName->nameAssigner);\n    lua_setfield(L, -2, \"nameAssigner\");\n    PUSH_ASN1_STRING(L, general_name->d.ediPartyName->partyName);\n    lua_setfield(L, -2, \"partyName\");\n    lua_setfield(L, -2, \"ediPartyName\");\n\n    lua_pushstring(L, \"ediPartyName\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  case GEN_RID:\n    lua_newtable(L);\n    openssl_push_asn1object(L, general_name->d.registeredID);\n    lua_setfield(L, -2, \"registeredID\");\n    lua_pushstring(L, \"registeredID\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  default:\n    lua_pushstring(L, \"unsupport\");\n    lua_setfield(L, -2, \"type\");\n  }\n  return 1;\n};\n\nstatic int check_cert(X509_STORE *ca, X509 *x, STACK_OF(X509) *untrustedchain, int purpose)\n{\n  int ret = 0;\n  X509_STORE_CTX *csc = X509_STORE_CTX_new();\n  if (csc)\n  {\n    X509_STORE_set_flags(ca, X509_V_FLAG_CHECK_SS_SIGNATURE);\n    if (X509_STORE_CTX_init(csc, ca, x, untrustedchain) == 1)\n    {\n      if (purpose > 0)\n      {\n        X509_STORE_CTX_set_purpose(csc, purpose);\n      }\n      ret = X509_verify_cert(csc);\n      if (ret == 1)\n        ret = X509_V_OK;\n      else\n        ret = X509_STORE_CTX_get_error(csc);\n    }\n    X509_STORE_CTX_free(csc);\n    return ret;\n  }\n\n  return X509_V_ERR_OUT_OF_MEM;\n}\n\n/***\nopenssl.x509 object\n@type x509\n*/\n/***\nexport x509_req to string\n@function export\n@tparam[opt='pem'] string format, 'der' or 'pem' default\n@tparam[opt='true'] boolean noext not export extension\n@treturn string\n*/\nstatic LUA_FUNCTION(openssl_x509_export)\n{\n  X509 *cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  int fmt = luaL_checkoption(L, 2, \"pem\", format);\n  int notext = lua_isnone(L, 3) ? 1 : lua_toboolean(L, 3);\n  BIO* out = NULL;\n\n  if (fmt != FORMAT_DER && fmt != FORMAT_PEM)\n  {\n    luaL_argerror(L, 2, \"format only accept pem or der\");\n  }\n\n  out  = BIO_new(BIO_s_mem());\n  if (fmt == FORMAT_PEM)\n  {\n    if (!notext)\n    {\n      X509_print(out, cert);\n    }\n\n    if (PEM_write_bio_X509(out, cert))\n    {\n      BUF_MEM *bio_buf;\n      BIO_get_mem_ptr(out, &bio_buf);\n      lua_pushlstring(L, bio_buf->data, bio_buf->length);\n    }\n    else\n      lua_pushnil(L);\n  }\n  else\n  {\n    if (i2d_X509_bio(out, cert))\n    {\n      BUF_MEM *bio_buf;\n      BIO_get_mem_ptr(out, &bio_buf);\n      lua_pushlstring(L, bio_buf->data, bio_buf->length);\n    }\n    else\n      lua_pushnil(L);\n  }\n\n  BIO_free(out);\n  return 1;\n};\n\n/***\nparse x509 object as table\n@function parse\n@tparam[opt=true] shortname default will use short object name\n@treturn table result which all x509 information\n*/\nstatic LUA_FUNCTION(openssl_x509_parse)\n{\n  int i;\n  X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  X509_ALGOR* alg = 0;\n  lua_newtable(L);\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n  if (cert->name)\n  {\n    AUXILIAR_SET(L, -1, \"name\", cert->name, string);\n  }\n  AUXILIAR_SET(L, -1, \"valid\", cert->valid, boolean);\n#endif\n  AUXILIAR_SET(L, -1, \"version\", X509_get_version(cert), integer);\n\n  openssl_push_xname_asobject(L, X509_get_subject_name(cert));\n  lua_setfield(L, -2, \"subject\");\n  openssl_push_xname_asobject(L, X509_get_issuer_name(cert));\n  lua_setfield(L, -2, \"issuer\");\n  {\n    char buf[32];\n    snprintf(buf, sizeof(buf), \"%08lx\", X509_subject_name_hash(cert));\n    AUXILIAR_SET(L, -1, \"hash\", buf, string);\n  }\n\n  PUSH_ASN1_INTEGER(L, X509_get0_serialNumber(cert));\n  lua_setfield(L, -2, \"serialNumber\");\n\n  PUSH_ASN1_TIME(L, X509_get0_notBefore(cert));\n  lua_setfield(L, -2, \"notBefore\");\n  PUSH_ASN1_TIME(L, X509_get0_notAfter(cert));\n  lua_setfield(L, -2, \"notAfter\");\n\n  {\n    CONSTIFY_X509_get0 X509_ALGOR *palg = NULL;\n    CONSTIFY_X509_get0 ASN1_BIT_STRING *psig = NULL;\n\n    X509_get0_signature(&psig, &palg, cert);\n    if (palg != NULL)\n    {\n      alg = X509_ALGOR_dup((X509_ALGOR*)palg);\n      PUSH_OBJECT(alg, \"openssl.x509_algor\");\n      lua_setfield(L, -2, \"sig_alg\");\n    }\n    if (psig != NULL)\n    {\n      lua_pushlstring(L, (const char *)psig->data, psig->length);\n      lua_setfield(L, -2, \"sig\");\n    }\n  }\n\n  {\n    int l = 0;\n    char* tmpstr = (char *)X509_alias_get0(cert, &l);\n    if (tmpstr)\n    {\n      AUXILIAR_SETLSTR(L, -1, \"alias\", tmpstr, l);\n    }\n  }\n\n  AUXILIAR_SET(L, -1, \"ca\", X509_check_ca(cert), boolean);\n\n  lua_newtable(L);\n  for (i = 0; i < X509_PURPOSE_get_count(); i++)\n  {\n    int set;\n    X509_PURPOSE *purp = X509_PURPOSE_get0(i);\n    int id = X509_PURPOSE_get_id(purp);\n    const char * pname = X509_PURPOSE_get0_sname(purp);\n\n    set = X509_check_purpose(cert, id, 0);\n    if (set)\n    {\n      AUXILIAR_SET(L, -1, pname, 1, boolean);\n    }\n    set = X509_check_purpose(cert, id, 1);\n    if (set)\n    {\n      lua_pushfstring(L, \"%s CA\", pname);\n      pname = lua_tostring(L, -1);\n      AUXILIAR_SET(L, -2, pname, 1, boolean);\n      lua_pop(L, 1);\n    }\n  }\n  lua_setfield(L, -2, \"purposes\");\n\n  {\n    int n = X509_get_ext_count(cert);\n    if (n > 0)\n    {\n      lua_pushstring(L, \"extensions\");\n      lua_newtable(L);\n      for (i = 0; i < n; i++)\n      {\n        X509_EXTENSION *ext = X509_get_ext(cert, i);\n        ext = X509_EXTENSION_dup(ext);\n        lua_pushinteger(L, i + 1);\n        PUSH_OBJECT(ext, \"openssl.x509_extension\");\n        lua_rawset(L, -3);\n      }\n      lua_rawset(L, -3);\n    }\n  }\n\n  return 1;\n}\n\nstatic LUA_FUNCTION(openssl_x509_free)\n{\n  X509 *cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  X509_free(cert);\n  return 0;\n}\n\n/***\nget public key of x509\n@function pubkey\n@treturn evp_pkey public key\n*/\n/***\nset public key of x509\n@function pubkey\n@tparam evp_pkey pubkey public key set to x509\n@treturn boolean result, true for success\n*/\nstatic LUA_FUNCTION(openssl_x509_public_key)\n{\n  X509 *cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    EVP_PKEY *pkey = X509_get_pubkey(cert);\n    PUSH_OBJECT(pkey, \"openssl.evp_pkey\");\n    return 1;\n  }\n  else\n  {\n    EVP_PKEY* pkey = CHECK_OBJECT(2, EVP_PKEY, \"openssl.evp_pkey\");\n    int ret = X509_set_pubkey(cert, pkey);\n    return openssl_pushresult(L, ret);\n  }\n}\n\n#if 0\nstatic int verify_cb(int ok, X509_STORE_CTX *ctx)\n{\n  int err;\n  X509 *err_cert;\n\n  /*\n  * it is ok to use a self signed certificate This case will catch both\n  * the initial ok == 0 and the final ok == 1 calls to this function\n  */\n  err = X509_STORE_CTX_get_error(ctx);\n  if (err == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT)\n    return 1;\n\n  /*\n  * BAD we should have gotten an error.  Normally if everything worked\n  * X509_STORE_CTX_get_error(ctx) will still be set to\n  * DEPTH_ZERO_SELF_....\n  */\n  if (ok)\n  {\n    //BIO_printf(bio_err, \"error with certificate to be certified - should be self signed\\n\");\n    return 0;\n  }\n  else\n  {\n    err_cert = X509_STORE_CTX_get_current_cert(ctx);\n    //print_name(bio_err, NULL, X509_get_subject_name(err_cert), 0);\n    //BIO_printf(bio_err, \"error with certificate - error %d at depth %d\\n%s\\n\", err, X509_STORE_CTX_get_error_depth(ctx), X509_verify_cert_error_string(err));\n    return 1;\n  }\n}\n#endif\n\n/***\ncheck x509 with ca certchian and option purpose\npurpose can be one of: ssl_client, ssl_server, ns_ssl_server, smime_sign, smime_encrypt, crl_sign, any, ocsp_helper, timestamp_sign\n@function check\n@tparam x509_store cacerts\n@tparam x509_store untrusted certs  containing a bunch of certs that are not trusted but may be useful in validating the certificate.\n@tparam[opt] string purpose to check supported\n@treturn boolean result true for check pass\n@treturn integer verify result\n@see verify_cert_error_string\n*/\n/***\ncheck x509 with evp_pkey\n@function check\n@tparam evp_pkey pkey private key witch match with x509 pubkey\n@treturn boolean result true for check pass\n*/\nstatic LUA_FUNCTION(openssl_x509_check)\n{\n  X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (auxiliar_getclassudata(L, \"openssl.evp_pkey\", 2))\n  {\n    EVP_PKEY * key = CHECK_OBJECT(2, EVP_PKEY, \"openssl.evp_pkey\");\n    lua_pushboolean(L, X509_check_private_key(cert, key));\n    return 1;\n  }\n  else\n  {\n    X509_STORE* store = CHECK_OBJECT(2, X509_STORE, \"openssl.x509_store\");\n    STACK_OF(X509)* untrustedchain = lua_isnoneornil(L, 3) ?  NULL : openssl_sk_x509_fromtable(L, 3);\n    int purpose = 0;\n    int ret = 0;\n    if (!lua_isnone(L, 4))\n    {\n      int purpose_id = X509_PURPOSE_get_by_sname((char*)luaL_optstring(L, 4, \"any\"));\n      if (purpose_id >= 0)\n      {\n        X509_PURPOSE* ppurpose = X509_PURPOSE_get0(purpose_id);\n        if (ppurpose)\n        {\n          purpose = ppurpose->purpose;\n        }\n      }\n    }\n#if 0\n    X509_STORE_set_verify_cb_func(store, verify_cb);\n#endif\n    if (untrustedchain!=NULL)\n      sk_X509_pop_free(untrustedchain, X509_free);\n    ret = check_cert(store, cert, untrustedchain, purpose);\n    lua_pushboolean(L, ret == X509_V_OK);\n    lua_pushinteger(L, ret);\n\n    return 2;\n  }\n}\n\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\n/***\ncheck x509 for host (only for openssl 1.0.2 or greater)\n@function check_host\n@tparam string host hostname to check for match match with x509 subject\n@treturn boolean result true if host is present and matches the certificate\n*/\nstatic LUA_FUNCTION(openssl_x509_check_host)\n{\n  X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isstring(L, 2))\n  {\n    const char *hostname = lua_tostring(L, 2);\n    lua_pushboolean(L, X509_check_host(cert, hostname, strlen(hostname), 0, NULL));\n  }\n  else\n  {\n    lua_pushboolean(L, 0);\n  }\n  return 1;\n}\n/***\ncheck x509 for email address (only for openssl 1.0.2 or greater)\n@tparam string email to check for match match with x509 subject\n@treturn boolean result true if host is present and matches the certificate\n@function check_email\n*/\nstatic LUA_FUNCTION(openssl_x509_check_email)\n{\n  X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isstring(L, 2))\n  {\n    const char *email = lua_tostring(L, 2);\n    lua_pushboolean(L, X509_check_email(cert, email, strlen(email), 0));\n  }\n  else\n  {\n    lua_pushboolean(L, 0);\n  }\n  return 1;\n}\n\n/***\ncheck x509 for ip address (ipv4 or ipv6, only for openssl 1.0.2 or greater)\n@function check_ip_asc\n@tparam string ip to check for match match with x509 subject\n@treturn boolean result true if host is present and matches the certificate\n*/\nstatic LUA_FUNCTION(openssl_x509_check_ip_asc)\n{\n  X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isstring(L, 2))\n  {\n    const char *ip_asc = lua_tostring(L, 2);\n    lua_pushboolean(L, X509_check_ip_asc(cert, ip_asc, 0));\n  }\n  else\n  {\n    lua_pushboolean(L, 0);\n  }\n  return 1;\n}\n#endif\n\nIMP_LUA_SK(X509, x509)\n\n#if 0\nstatic STACK_OF(X509) * load_all_certs_from_file(BIO *in)\n{\n  STACK_OF(X509) *stack = sk_X509_new_null();\n  if (stack)\n  {\n    STACK_OF(X509_INFO) *sk = PEM_X509_INFO_read_bio(in, NULL, NULL, NULL);\n    /* scan over it and pull out the certs */\n    while (sk_X509_INFO_num(sk))\n    {\n      X509_INFO *xi = sk_X509_INFO_shift(sk);\n      if (xi->x509 != NULL)\n      {\n        sk_X509_push(stack, xi->x509);\n        xi->x509 = NULL;\n      }\n      X509_INFO_free(xi);\n    }\n    sk_X509_INFO_free(sk);\n  };\n\n  if (sk_X509_num(stack) == 0)\n  {\n    sk_X509_free(stack);\n    stack = NULL;\n  }\n  return stack;\n};\n#endif\n\n/***\nget subject name of x509\n@function subject\n@treturn x509_name subject name\n*/\n/***\nset subject name of x509\n@function subject\n@tparam x509_name subject\n@treturn boolean result true for success\n*/\nstatic int openssl_x509_subject(lua_State* L)\n{\n  X509* cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    X509_NAME* xn = X509_get_subject_name(cert);\n    return openssl_push_xname_asobject(L, xn);\n  }\n  else\n  {\n    X509_NAME *xn = CHECK_OBJECT(2, X509_NAME, \"openssl.x509_name\");\n    int ret = X509_set_subject_name(cert, xn);\n    return openssl_pushresult(L, ret);\n  }\n}\n\n/***\nget issuer name of x509\n@function issuer\n@tparam[opt=false] boolean asobject, true for return as x509_name object, or as table\n@treturn[1] x509_name issuer\n@treturn[1] table issuer name as table\n*/\n/***\nset issuer name of x509\n@function issuer\n@tparam x509_name name\n@treturn boolean result true for success\n*/\nstatic int openssl_x509_issuer(lua_State* L)\n{\n  X509* cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    X509_NAME* xn = X509_get_issuer_name(cert);\n    return openssl_push_xname_asobject(L, xn);\n  }\n  else\n  {\n    X509_NAME* xn = CHECK_OBJECT(2, X509_NAME, \"openssl.x509_name\");\n    int ret = X509_set_issuer_name(cert, xn);\n    return openssl_pushresult(L, ret);\n  }\n}\n\n/***\nget digest of x509 object\n@function digest\n@tparam[opt='sha1'] evp_digest|string md_alg, default use 'sha1'\n@treturn string digest result\n*/\nstatic int openssl_x509_digest(lua_State* L)\n{\n  unsigned int bytes;\n  unsigned char buffer[EVP_MAX_MD_SIZE];\n  char hex_buffer[EVP_MAX_MD_SIZE * 2];\n  X509 *cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  const EVP_MD *digest = get_digest(L, 2, \"sha256\");\n  int ret;\n  if (!digest)\n  {\n    lua_pushnil(L);\n    lua_pushfstring(L, \"digest algorithm not supported (%s)\", lua_tostring(L, 2));\n    return 2;\n  }\n  ret = X509_digest(cert, digest, buffer, &bytes);\n  if (ret)\n  {\n    to_hex((char*)buffer, bytes, hex_buffer);\n    lua_pushlstring(L, hex_buffer, bytes * 2);\n    return 1;\n  }\n  return openssl_pushresult(L, ret);\n};\n\n/***\nget notbefore valid time of x509\n@function notbefore\n@treturn string notbefore time string\n*/\n/***\nset notbefore valid time of x509\n@function notbefore\n@tparam string|number notbefore\n*/\nstatic int openssl_x509_notbefore(lua_State *L)\n{\n  X509* cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    return PUSH_ASN1_TIME(L, X509_get0_notBefore(cert));\n  }\n  else\n  {\n    ASN1_TIME* at = NULL;\n    int ret = 1;\n    if (lua_isnumber(L, 2))\n    {\n      time_t time = lua_tointeger(L, 2);\n      at = ASN1_TIME_new();\n      ASN1_TIME_set(at, time);\n    }\n    else if (lua_isstring(L, 2))\n    {\n      const char* time = lua_tostring(L, 2);\n      at = ASN1_TIME_new();\n      if (ASN1_TIME_set_string(at, time) != 1)\n      {\n        ASN1_TIME_free(at);\n        at = NULL;\n      }\n    }\n    if (at)\n    {\n      ret = X509_set1_notBefore(cert, at);\n      ASN1_TIME_free(at);\n    }\n    else\n      ret = 0;\n    return openssl_pushresult(L, ret);\n  };\n}\n\n/***\nget notafter valid time of x509\n@function notafter\n@treturn string notafter time string\n*/\n/***\nset notafter valid time of x509\n@function notafter\n@tparam string|number notafter\n*/\nstatic int openssl_x509_notafter(lua_State *L)\n{\n  X509* cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    return PUSH_ASN1_TIME(L, X509_get0_notAfter(cert));\n  }\n  else\n  {\n    ASN1_TIME* at = NULL;\n    int ret = 1;\n    if (lua_isnumber(L, 2))\n    {\n      time_t time = lua_tointeger(L, 2);\n      at = ASN1_TIME_new();\n      ASN1_TIME_set(at, time);\n    }\n    else if (lua_isstring(L, 2))\n    {\n      const char* time = lua_tostring(L, 2);\n      at = ASN1_TIME_new();\n      if (ASN1_TIME_set_string(at, time) != 1)\n      {\n        ASN1_TIME_free(at);\n        at = NULL;\n      }\n    }\n    if (at)\n    {\n      ret = X509_set1_notAfter(cert, at);\n      ASN1_TIME_free(at);\n    }\n    else\n      ret = 0;\n    return openssl_pushresult(L, ret);\n  }\n}\n\n/***\ncheck x509 valid\n@function validat\n@tparam[opt] number time, default will use now time\n@treturn boolean result true for valid, or for invalid\n@treturn string notbefore\n@treturn string notafter\n*/\n/***\nset valid time, notbefore and notafter\n@function validat\n@tparam number notbefore\n@tparam number notafter\n@treturn boolean result, true for success\n*/\nstatic int openssl_x509_valid_at(lua_State* L)\n{\n  X509* cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    time_t now = 0;;\n    time(&now);\n\n    lua_pushboolean(L, (X509_cmp_time(X509_get0_notAfter(cert), &now)     >= 0\n                        && X509_cmp_time(X509_get0_notBefore(cert), &now) <= 0));\n    PUSH_ASN1_TIME(L, X509_get0_notBefore(cert));\n    PUSH_ASN1_TIME(L, X509_get0_notAfter(cert));\n    return 3;\n  }\n  else if (lua_gettop(L) == 2)\n  {\n    time_t time = luaL_checkinteger(L, 2);\n    lua_pushboolean(L, (X509_cmp_time(X509_get0_notAfter(cert), &time)     >= 0\n                        && X509_cmp_time(X509_get0_notBefore(cert), &time) <= 0));\n    PUSH_ASN1_TIME(L, X509_get0_notBefore(cert));\n    PUSH_ASN1_TIME(L, X509_get0_notAfter(cert));\n    return 3;\n  }\n  else if (lua_gettop(L) == 3)\n  {\n    time_t before, after;\n    ASN1_TIME *ab, *aa;\n    int ret = 1;\n    before = lua_tointeger(L, 2);\n    after  = lua_tointeger(L, 3);\n\n    ab = ASN1_TIME_new();\n    aa = ASN1_TIME_new();\n    ASN1_TIME_set(ab, before);\n    ASN1_TIME_set(aa, after);\n    ret = X509_set1_notBefore(cert, ab);\n    if (ret == 1)\n      ret = X509_set1_notAfter(cert, aa);\n\n    ASN1_TIME_free(ab);\n    ASN1_TIME_free(aa);\n\n    return openssl_pushresult(L, ret);\n  }\n  return 0;\n}\n\n/***\nget serial number of x509\n@function serial\n@tparam[opt=true] boolean asobject\n@treturn[1] bn object\n@treturn[2] string result\n*/\n/***\nset serial number of x509\n@function serial\n@tparam string|number|bn serail\n@treturn boolean result true for success\n*/\nstatic int openssl_x509_serial(lua_State *L)\n{\n  X509* cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  ASN1_INTEGER *serial = X509_get_serialNumber(cert);\n  if (lua_isboolean(L, 2))\n  {\n    int asobj = lua_toboolean(L, 2);\n    if (asobj)\n    {\n      PUSH_ASN1_INTEGER(L, serial);\n    }\n    else\n    {\n      BIGNUM *bn = ASN1_INTEGER_to_BN(serial, NULL);\n      PUSH_OBJECT(bn, \"openssl.bn\");\n    }\n  }\n  else if (lua_isnone(L, 2))\n  {\n    BIGNUM *bn = ASN1_INTEGER_to_BN(serial, NULL);\n    char *tmp = BN_bn2hex(bn);\n    lua_pushstring(L, tmp);\n    OPENSSL_free(tmp);\n    BN_free(bn);\n  }\n  else\n  {\n    int ret;\n    if (auxiliar_getclassudata(L, \"openssl.asn1_string\", 2))\n    {\n      serial = CHECK_OBJECT(2, ASN1_STRING, \"openssl.asn1_string\");\n    }\n    else\n    {\n      BIGNUM *bn = BN_get(L, 2);\n      serial = BN_to_ASN1_INTEGER(bn, NULL);\n      BN_free(bn);\n    }\n    luaL_argcheck(L, serial != NULL, 2, \"not accept\");\n    ret = X509_set_serialNumber(cert, serial);\n    ASN1_INTEGER_free(serial);\n    return openssl_pushresult(L, ret);\n  }\n  return 1;\n}\n\n/***\nget version number of x509\n@function version\n@treturn number version of x509\n*/\n/***\nset version number of x509\n@function version\n@tparam number version\n@treturn boolean result true for result\n*/\nstatic int openssl_x509_version(lua_State *L)\n{\n  int version;\n  X509* cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    version = X509_get_version(cert);\n    lua_pushinteger(L, version);\n    return 1;\n  }\n  else\n  {\n    int ret;\n    version = luaL_checkint(L, 2);\n    ret = X509_set_version(cert, version);\n    return openssl_pushresult(L, ret);\n  }\n}\n\n/***\nget extensions of x509 object\n@function extensions\n@tparam[opt=false] boolean asobject, true for return as stack_of_x509_extension or as table\n@treturn[1] stack_of_x509_extension object when param set true\n@treturn[2] table contain all x509_extension when param set false or nothing\n*/\n/***\nset extension of x509 object\n@function extensions\n@tparam stack_of_x509_extension extensions\n@treturn boolean result true for success\n*/\nstatic int openssl_x509_extensions(lua_State* L)\n{\n  X509 *self = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  STACK_OF(X509_EXTENSION) *exts = (STACK_OF(X509_EXTENSION) *)X509_get0_extensions(self);\n  if (lua_isnone(L, 2))\n  {\n    if (exts)\n    {\n      openssl_sk_x509_extension_totable(L, exts);\n    }\n    else\n      lua_pushnil(L);\n    return 1;\n  }\n  else\n  {\n    STACK_OF(X509_EXTENSION) *others = (STACK_OF(X509_EXTENSION) *)openssl_sk_x509_extension_fromtable(L, 2);\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    sk_X509_EXTENSION_pop_free(self->cert_info->extensions, X509_EXTENSION_free);\n    self->cert_info->extensions = others;\n#else\n    int i;\n    int n = sk_X509_EXTENSION_num(exts);\n    for (i = 0; i < n; i++)\n      sk_X509_EXTENSION_delete(exts, i);\n    n = sk_X509_EXTENSION_num(others);\n    for (i = 0; i < n; i++)\n    {\n      X509_EXTENSION* ext = sk_X509_EXTENSION_value(others, i);\n      if (exts!=NULL)\n        sk_X509_EXTENSION_push(exts, ext);\n      else\n        X509_add_ext(self, ext, -1);\n    }\n    sk_X509_EXTENSION_pop_free(others, X509_EXTENSION_free);\n#endif\n    return openssl_pushresult(L, 1);\n  }\n}\n\n/***\nsign x509\n@function sign\n@tparam evp_pkey pkey private key to sign x509\n@tparam x509|x509_name cacert or cacert x509_name\n@tparam[opt='sha1WithRSAEncryption'] string|md_digest md_alg\n@treturn boolean result true for check pass\n*/\nstatic int openssl_x509_sign(lua_State*L)\n{\n  X509* x = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    unsigned char *out = NULL;\n    int len = i2d_re_X509_tbs(x, &out);\n    if (len > 0)\n    {\n      lua_pushlstring(L, (const char *)out, len);\n      OPENSSL_free(out);\n      return 1;\n    }\n    return openssl_pushresult(L, len);\n  }\n  else if (auxiliar_getclassudata(L, \"openssl.evp_pkey\", 2))\n  {\n    EVP_PKEY* pkey = CHECK_OBJECT(2, EVP_PKEY, \"openssl.evp_pkey\");\n    const EVP_MD *md;\n    int ret = 1;\n    int i = 3;\n    if (auxiliar_getclassudata(L, \"openssl.x509_name\", 3))\n    {\n      X509_NAME* xn = CHECK_OBJECT(3, X509_NAME, \"openssl.x509_name\");\n      ret = X509_set_issuer_name(x, xn);\n      i++;\n    }\n    else\n    {\n      X509* ca = CHECK_OBJECT(3, X509, \"openssl.x509\");\n      X509_NAME* xn = X509_get_subject_name(ca);\n      ret = X509_check_private_key(ca, pkey);\n      if (ret == 1)\n      {\n        ret = X509_set_issuer_name(x, xn);\n      }\n      i++;\n    }\n\n    if (ret == 1)\n    {\n      md = get_digest(L, i, \"sha256\");\n      ret = X509_sign(x, pkey, md);\n      if (ret > 0)\n        ret = 1;\n    }\n    return openssl_pushresult(L, ret);\n  }\n  else\n  {\n    size_t sig_len;\n    const char* sig = luaL_checklstring(L, 2, &sig_len);\n    ASN1_OBJECT *obj = openssl_get_asn1object(L, 3, 0);\n    CONSTIFY_X509_get0 ASN1_BIT_STRING *psig = NULL;\n    CONSTIFY_X509_get0 X509_ALGOR *palg = NULL;\n    int ret;\n\n    X509_get0_signature(&psig, &palg, x);\n    ret = ASN1_BIT_STRING_set((ASN1_BIT_STRING*)psig, (unsigned char*)sig, (int)sig_len);\n    if (ret == 1)\n    {\n      ret = X509_ALGOR_set0((X509_ALGOR*)palg, obj, V_ASN1_UNDEF, NULL);\n    }\n    else\n      ASN1_OBJECT_free(obj);\n    return openssl_pushresult(L, ret);\n  }\n}\n\nstatic int openssl_x509_verify(lua_State*L)\n{\n  X509* x = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    unsigned char *out = NULL;\n    int len = i2d_re_X509_tbs(x, &out);\n    if (len > 0)\n    {\n      CONSTIFY_X509_get0 ASN1_BIT_STRING *psig = NULL;\n      CONSTIFY_X509_get0 X509_ALGOR *palg = NULL;\n\n      lua_pushlstring(L, (const char *)out, len);\n      OPENSSL_free(out);\n\n      X509_get0_signature(&psig, &palg, x);\n      if (psig != NULL)\n      {\n        lua_pushlstring(L, (const char *)psig->data, psig->length);\n      }\n      else\n        lua_pushnil(L);\n\n      if (palg)\n      {\n        X509_ALGOR *alg = X509_ALGOR_dup((X509_ALGOR *)palg);\n        PUSH_OBJECT(alg, \"openssl.x509_algor\");\n      }\n      else\n        lua_pushnil(L);\n      return 3;\n    }\n    return openssl_pushresult(L, len);\n  }\n  else\n  {\n    EVP_PKEY *pkey = CHECK_OBJECT(2, EVP_PKEY, \"openssl.evp_pkey\");\n    int ret = X509_verify(x, pkey);\n    return openssl_pushresult(L, ret);\n  }\n}\n\nstatic luaL_Reg x509_funcs[] =\n{\n  {\"parse\",       openssl_x509_parse},\n  {\"export\",      openssl_x509_export},\n  {\"check\",       openssl_x509_check},\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\n  {\"check_host\",  openssl_x509_check_host},\n  {\"check_email\", openssl_x509_check_email},\n  {\"check_ip_asc\", openssl_x509_check_ip_asc},\n#endif\n  {\"pubkey\",      openssl_x509_public_key},\n  {\"version\",     openssl_x509_version},\n\n  {\"__gc\",        openssl_x509_free},\n  {\"__tostring\",  auxiliar_tostring},\n\n  /* compat with luasec */\n  {\"digest\",     openssl_x509_digest},\n  {\"extensions\", openssl_x509_extensions},\n  {\"issuer\",     openssl_x509_issuer},\n  {\"notbefore\",  openssl_x509_notbefore},\n  {\"notafter\",   openssl_x509_notafter},\n  {\"serial\",     openssl_x509_serial},\n  {\"subject\",    openssl_x509_subject},\n  {\"validat\",    openssl_x509_valid_at},\n\n  {\"sign\",       openssl_x509_sign},\n  {\"verify\",     openssl_x509_verify},\n\n  {NULL,      NULL},\n};\n\nint luaopen_x509(lua_State *L)\n{\n  auxiliar_newclass(L, \"openssl.x509\", x509_funcs);\n\n  lua_newtable(L);\n  luaL_setfuncs(L, R, 0);\n\n  openssl_register_xname(L);\n  lua_setfield(L, -2, \"name\");\n  openssl_register_xattribute(L);\n  lua_setfield(L, -2, \"attribute\");\n  openssl_register_xextension(L);\n  lua_setfield(L, -2, \"extension\");\n  openssl_register_xstore(L);\n  lua_setfield(L, -2, \"store\");\n  openssl_register_xalgor(L);\n  lua_setfield(L, -2, \"algor\");\n\n  luaopen_x509_req(L);\n  lua_setfield(L, -2, \"req\");\n  luaopen_x509_crl(L);\n  lua_setfield(L, -2, \"crl\");\n\n  lua_pushliteral(L, \"version\");    /** version */\n  lua_pushliteral(L, MYVERSION);\n  lua_settable(L, -3);\n\n  return 1;\n}\n"], "fixing_code": ["/***\nx509 modules for lua-openssl binding\ncreate and manage x509 certificate\n@module x509\n@usage\n x509 = require'openssl'.x509\n*/\n\n\n#include \"openssl.h\"\n#include \"private.h\"\n#define CRYPTO_LOCK_REF\n#include \"sk.h\"\n\n#define MYNAME    \"x509\"\n#define MYVERSION MYNAME \" library for \" LUA_VERSION \" / Nov 2014 / \"\\\n  \"based on OpenSSL \" SHLIB_VERSION_NUMBER\n\n#if OPENSSL_VERSION_NUMBER < 0x1010000fL || \\\n\t(defined(LIBRESSL_VERSION_NUMBER) && (LIBRESSL_VERSION_NUMBER < 0x20700000L))\n#define X509_get0_notBefore X509_get_notBefore\n#define X509_get0_notAfter X509_get_notAfter\n#define X509_set1_notBefore X509_set_notBefore\n#define X509_set1_notAfter X509_set_notAfter\n#endif\n\nstatic int openssl_push_purpose(lua_State*L, X509_PURPOSE* purpose)\n{\n  lua_newtable(L);\n\n  AUXILIAR_SET(L, -1, \"purpose\", purpose->purpose, integer);\n  AUXILIAR_SET(L, -1, \"trust\", purpose->trust, integer);\n  AUXILIAR_SET(L, -1, \"flags\", purpose->flags, integer);\n\n  AUXILIAR_SET(L, -1, \"name\", purpose->name, string);\n  AUXILIAR_SET(L, -1, \"sname\", purpose->sname, string);\n\n  return 1;\n};\n\n/***\nreturn all supported purpose as table\n@function purpose\n@treturn table\n*/\n/*\nget special purpose info as table\n@function purpose\n@tparam number|string purpose id or short name\n@treturn table\n*/\nstatic int openssl_x509_purpose(lua_State*L)\n{\n  if (lua_isnone(L, 1))\n  {\n    int count = X509_PURPOSE_get_count();\n    int i;\n    lua_newtable(L);\n    for (i = 0; i < count; i++)\n    {\n      X509_PURPOSE* purpose = X509_PURPOSE_get0(i);\n      openssl_push_purpose(L, purpose);\n      lua_rawseti(L, -2, i + 1);\n    }\n    return 1;\n  }\n  else if (lua_isnumber(L, 1))\n  {\n    int idx = X509_PURPOSE_get_by_id(lua_tointeger(L, 1));\n    if (idx >= 0)\n    {\n      X509_PURPOSE* purpose = X509_PURPOSE_get0(idx);\n      openssl_push_purpose(L, purpose);\n    }\n    else\n      lua_pushnil(L);\n    return 1;\n  }\n  else if (lua_isstring(L, 1))\n  {\n    char* name = (char*)lua_tostring(L, 1);\n    int idx = X509_PURPOSE_get_by_sname(name);\n    if (idx >= 0)\n    {\n      X509_PURPOSE* purpose = X509_PURPOSE_get0(idx);\n      openssl_push_purpose(L, purpose);\n    }\n    else\n      lua_pushnil(L);\n    return 1;\n  }\n  else\n    luaL_argerror(L, 1, \"only accpet none, string or number as nid or short name\");\n\n  return 0;\n};\n\nstatic const char* usage_mode[] =\n{\n  \"standard\",\n  \"netscape\",\n  \"extend\",\n  NULL\n};\n\n/***\nget support certtypes\n@function certtypes\n@tparam[opt='standard'] string type support 'standard','netscape','extend'\n@treturn table if type is 'standard' or 'netscape', contains node with {lname=...,sname=...,bitname=...},\n               if type is 'extend', contains node with {lname=...,sname=...,nid=...}\n*/\nstatic int openssl_x509_certtypes(lua_State*L)\n{\n  int mode = luaL_checkoption(L, 1, \"standard\", usage_mode);\n  int i;\n  const BIT_STRING_BITNAME* bitname;\n\n  switch (mode)\n  {\n  case 0:\n  {\n    const static BIT_STRING_BITNAME key_usage_type_table[] =\n    {\n      {0, \"Digital Signature\", \"digitalSignature\"},\n      {1, \"Non Repudiation\", \"nonRepudiation\"},\n      {2, \"Key Encipherment\", \"keyEncipherment\"},\n      {3, \"Data Encipherment\", \"dataEncipherment\"},\n      {4, \"Key Agreement\", \"keyAgreement\"},\n      {5, \"Certificate Sign\", \"keyCertSign\"},\n      {6, \"CRL Sign\", \"cRLSign\"},\n      {7, \"Encipher Only\", \"encipherOnly\"},\n      {8, \"Decipher Only\", \"decipherOnly\"},\n      { -1, NULL, NULL}\n    };\n    lua_newtable(L);\n    for (i = 0, bitname = &key_usage_type_table[i]; bitname->bitnum != -1; i++, bitname = &key_usage_type_table[i])\n    {\n      openssl_push_bit_string_bitname(L, bitname);\n      lua_rawseti(L, -2, i + 1);\n    }\n    return 1;\n\n  }\n  case 1:\n  {\n    const static BIT_STRING_BITNAME ns_cert_type_table[] =\n    {\n      {0, \"SSL Client\", \"client\"},\n      {1, \"SSL Server\", \"server\"},\n      {2, \"S/MIME\", \"email\"},\n      {3, \"Object Signing\", \"objsign\"},\n      {4, \"Unused\", \"reserved\"},\n      {5, \"SSL CA\", \"sslCA\"},\n      {6, \"S/MIME CA\", \"emailCA\"},\n      {7, \"Object Signing CA\", \"objCA\"},\n      { -1, NULL, NULL}\n    };\n    lua_newtable(L);\n    for (i = 0, bitname = &ns_cert_type_table[i]; bitname->bitnum != -1; i++, bitname = &ns_cert_type_table[i])\n    {\n      openssl_push_bit_string_bitname(L, bitname);\n      lua_rawseti(L, -2, i + 1);\n    }\n    return 1;\n  }\n  case 2:\n  {\n    static const int ext_nids[] =\n    {\n      NID_server_auth,\n      NID_client_auth,\n      NID_email_protect,\n      NID_code_sign,\n      NID_ms_sgc,\n      NID_ns_sgc,\n      NID_OCSP_sign,\n      NID_time_stamp,\n      NID_dvcs,\n      NID_anyExtendedKeyUsage\n    };\n    int count = sizeof(ext_nids) / sizeof(int);\n    int nid;\n    lua_newtable(L);\n    for (i = 0; i < count; i++)\n    {\n      nid = ext_nids[i];\n      lua_newtable(L);\n      lua_pushstring(L, OBJ_nid2ln(nid));\n      lua_setfield(L, -2, \"lname\");\n      lua_pushstring(L, OBJ_nid2sn(nid));\n      lua_setfield(L, -2, \"sname\");\n      lua_pushinteger(L, nid);\n      lua_setfield(L, -2, \"nid\");\n      lua_rawseti(L, -2, i + 1);\n    };\n    return 1;\n  }\n  }\n  return 0;\n}\n\n/***\nget certificate verify result string message\n@function verify_cert_error_string\n@tparam number verify_result\n@treturn string result message\n*/\nstatic int openssl_verify_cert_error_string(lua_State*L)\n{\n  int v = luaL_checkint(L, 1);\n  const char*s = X509_verify_cert_error_string(v);\n  lua_pushstring(L, s);\n  return 1;\n}\n\n/***\nread x509 from string or bio input\n@function read\n@tparam bio|string input input data\n@tparam[opt='auto'] string format support 'auto','pem','der'\n@treturn x509 certificate object\n*/\nstatic LUA_FUNCTION(openssl_x509_read)\n{\n  X509 *cert = NULL;\n  BIO *in = load_bio_object(L, 1);\n  int fmt = luaL_checkoption(L, 2, \"auto\", format);\n  if (fmt == FORMAT_AUTO)\n  {\n    fmt = bio_is_der(in) ? FORMAT_DER : FORMAT_PEM;\n  }\n\n  if (fmt == FORMAT_DER)\n  {\n    cert = d2i_X509_bio(in, NULL);\n  }\n  else if (fmt == FORMAT_PEM)\n  {\n    cert = PEM_read_bio_X509(in, NULL, NULL, NULL);\n  }\n\n  BIO_free(in);\n\n  if (cert)\n  {\n    PUSH_OBJECT(cert, \"openssl.x509\");\n    return 1;\n  }\n  return openssl_pushresult(L, 0);\n}\n\n/***\ncreate or generate a new x509 object.\n@function new\n@tparam[opt] openssl.bn serial serial number\n@tparam[opt] x509_req csr,copy x509_name, pubkey and extension to new object\n@tparam[opt] x509_name subject subject name set to x509_req\n@tparam[opt] stack_of_x509_extension extensions add to x509\n@tparam[opt] stack_of_x509_attribute attributes add to x509\n@treturn x509 certificate object\n*/\nstatic int openssl_x509_new(lua_State* L)\n{\n  int i = 1;\n  int ret = 1;\n  int n = lua_gettop(L);\n  X509 *x = X509_new();\n\n  ret = X509_set_version(x, 2);\n  if (ret == 1 && (\n        auxiliar_getclassudata(L, \"openssl.bn\", i) ||\n        lua_isstring(L, i) || lua_isnumber(L, i)\n      ))\n  {\n    BIGNUM *bn = BN_get(L, i);\n    ASN1_INTEGER* ai = BN_to_ASN1_INTEGER(bn, NULL);\n    BN_free(bn);\n    ret = X509_set_serialNumber(x, ai);\n    ASN1_INTEGER_free(ai);\n    i++;\n  }\n\n  for (; i <= n; i++)\n  {\n    if (ret == 1 && auxiliar_getclassudata(L, \"openssl.x509_req\", i))\n    {\n      X509_REQ* csr = CHECK_OBJECT(i, X509_REQ, \"openssl.x509_req\");\n      X509_NAME* xn = X509_REQ_get_subject_name(csr);\n      ret = X509_set_subject_name(x, xn);\n\n      if (ret == 1)\n      {\n        STACK_OF(X509_EXTENSION) *exts = X509_REQ_get_extensions(csr);\n        int j, n1;\n        n1 = sk_X509_EXTENSION_num(exts);\n        for (j = 0; ret == 1 && j < n1; j++)\n        {\n          ret = X509_add_ext(x, sk_X509_EXTENSION_value(exts, j), j);\n        }\n        sk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);\n      }\n      if (ret == 1)\n      {\n        EVP_PKEY* pkey = X509_REQ_get_pubkey(csr);\n        ret = X509_set_pubkey(x, pkey);\n        EVP_PKEY_free(pkey);\n      }\n      i++;\n    };\n\n    if (ret == 1 && auxiliar_getclassudata(L, \"openssl.x509_name\", i))\n    {\n      X509_NAME *xn = CHECK_OBJECT(i, X509_NAME, \"openssl.x509_name\");\n      ret = X509_set_subject_name(x, xn);\n      i++;\n    }\n  }\n\n  if (ret == 1)\n  {\n    PUSH_OBJECT(x, \"openssl.x509\");\n    return 1;\n  }\n  else\n  {\n    X509_free(x);\n    return openssl_pushresult(L, ret);\n  }\n};\n\nstatic luaL_Reg R[] =\n{\n  {\"new\",           openssl_x509_new },\n  {\"read\",          openssl_x509_read },\n  {\"purpose\",       openssl_x509_purpose },\n  {\"certtypes\",     openssl_x509_certtypes },\n  {\"verify_cert_error_string\", openssl_verify_cert_error_string },\n\n  {NULL,    NULL}\n};\n\nint openssl_push_general_name(lua_State*L, const GENERAL_NAME* general_name)\n{\n  if (general_name == NULL)\n  {\n    lua_pushnil(L);\n    return 1;\n  }\n  lua_newtable(L);\n\n  switch (general_name->type)\n  {\n  case GEN_OTHERNAME:\n  {\n    OTHERNAME *otherName = general_name->d.otherName;\n    lua_newtable(L);\n    openssl_push_asn1object(L, otherName->type_id);\n    PUSH_ASN1_STRING(L, otherName->value->value.asn1_string);\n    lua_settable(L, -3);\n    lua_setfield(L, -2, \"otherName\");\n\n    lua_pushstring(L, \"otherName\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  }\n  case GEN_EMAIL:\n    PUSH_ASN1_STRING(L, general_name->d.rfc822Name);\n    lua_setfield(L, -2, \"rfc822Name\");\n\n    lua_pushstring(L, \"rfc822Name\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  case GEN_DNS:\n    PUSH_ASN1_STRING(L, general_name->d.dNSName);\n    lua_setfield(L, -2, \"dNSName\");\n    lua_pushstring(L, \"dNSName\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  case GEN_X400:\n    openssl_push_asn1type(L, general_name->d.x400Address);\n    lua_setfield(L, -2, \"x400Address\");\n    lua_pushstring(L, \"x400Address\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  case GEN_DIRNAME:\n  {\n    X509_NAME* xn = general_name->d.directoryName;\n    openssl_push_xname_asobject(L, xn);\n    lua_setfield(L, -2, \"directoryName\");\n    lua_pushstring(L, \"directoryName\");\n    lua_setfield(L, -2, \"type\");\n  }\n  break;\n  case GEN_URI:\n    PUSH_ASN1_STRING(L, general_name->d.uniformResourceIdentifier);\n    lua_setfield(L, -2, \"uniformResourceIdentifier\");\n    lua_pushstring(L, \"uniformResourceIdentifier\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  case GEN_IPADD:\n    lua_newtable(L);\n    PUSH_ASN1_OCTET_STRING(L, general_name->d.iPAddress);\n    lua_setfield(L, -2, \"iPAddress\");\n    lua_pushstring(L, \"iPAddress\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  case GEN_EDIPARTY:\n    lua_newtable(L);\n    PUSH_ASN1_STRING(L, general_name->d.ediPartyName->nameAssigner);\n    lua_setfield(L, -2, \"nameAssigner\");\n    PUSH_ASN1_STRING(L, general_name->d.ediPartyName->partyName);\n    lua_setfield(L, -2, \"partyName\");\n    lua_setfield(L, -2, \"ediPartyName\");\n\n    lua_pushstring(L, \"ediPartyName\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  case GEN_RID:\n    lua_newtable(L);\n    openssl_push_asn1object(L, general_name->d.registeredID);\n    lua_setfield(L, -2, \"registeredID\");\n    lua_pushstring(L, \"registeredID\");\n    lua_setfield(L, -2, \"type\");\n    break;\n  default:\n    lua_pushstring(L, \"unsupport\");\n    lua_setfield(L, -2, \"type\");\n  }\n  return 1;\n};\n\nstatic int check_cert(X509_STORE *ca, X509 *x, STACK_OF(X509) *untrustedchain, int purpose)\n{\n  int ret = 0;\n  X509_STORE_CTX *csc = X509_STORE_CTX_new();\n  if (csc)\n  {\n    X509_STORE_set_flags(ca, X509_V_FLAG_CHECK_SS_SIGNATURE);\n    if (X509_STORE_CTX_init(csc, ca, x, untrustedchain) == 1)\n    {\n      if (purpose > 0)\n      {\n        X509_STORE_CTX_set_purpose(csc, purpose);\n      }\n      ret = X509_verify_cert(csc);\n      if (ret == 1)\n        ret = X509_V_OK;\n      else\n        ret = X509_STORE_CTX_get_error(csc);\n    }\n    X509_STORE_CTX_free(csc);\n    return ret;\n  }\n\n  return X509_V_ERR_OUT_OF_MEM;\n}\n\n/***\nopenssl.x509 object\n@type x509\n*/\n/***\nexport x509_req to string\n@function export\n@tparam[opt='pem'] string format, 'der' or 'pem' default\n@tparam[opt='true'] boolean noext not export extension\n@treturn string\n*/\nstatic LUA_FUNCTION(openssl_x509_export)\n{\n  X509 *cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  int fmt = luaL_checkoption(L, 2, \"pem\", format);\n  int notext = lua_isnone(L, 3) ? 1 : lua_toboolean(L, 3);\n  BIO* out = NULL;\n\n  if (fmt != FORMAT_DER && fmt != FORMAT_PEM)\n  {\n    luaL_argerror(L, 2, \"format only accept pem or der\");\n  }\n\n  out  = BIO_new(BIO_s_mem());\n  if (fmt == FORMAT_PEM)\n  {\n    if (!notext)\n    {\n      X509_print(out, cert);\n    }\n\n    if (PEM_write_bio_X509(out, cert))\n    {\n      BUF_MEM *bio_buf;\n      BIO_get_mem_ptr(out, &bio_buf);\n      lua_pushlstring(L, bio_buf->data, bio_buf->length);\n    }\n    else\n      lua_pushnil(L);\n  }\n  else\n  {\n    if (i2d_X509_bio(out, cert))\n    {\n      BUF_MEM *bio_buf;\n      BIO_get_mem_ptr(out, &bio_buf);\n      lua_pushlstring(L, bio_buf->data, bio_buf->length);\n    }\n    else\n      lua_pushnil(L);\n  }\n\n  BIO_free(out);\n  return 1;\n};\n\n/***\nparse x509 object as table\n@function parse\n@tparam[opt=true] shortname default will use short object name\n@treturn table result which all x509 information\n*/\nstatic LUA_FUNCTION(openssl_x509_parse)\n{\n  int i;\n  X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  X509_ALGOR* alg = 0;\n  lua_newtable(L);\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n  if (cert->name)\n  {\n    AUXILIAR_SET(L, -1, \"name\", cert->name, string);\n  }\n  AUXILIAR_SET(L, -1, \"valid\", cert->valid, boolean);\n#endif\n  AUXILIAR_SET(L, -1, \"version\", X509_get_version(cert), integer);\n\n  openssl_push_xname_asobject(L, X509_get_subject_name(cert));\n  lua_setfield(L, -2, \"subject\");\n  openssl_push_xname_asobject(L, X509_get_issuer_name(cert));\n  lua_setfield(L, -2, \"issuer\");\n  {\n    char buf[32];\n    snprintf(buf, sizeof(buf), \"%08lx\", X509_subject_name_hash(cert));\n    AUXILIAR_SET(L, -1, \"hash\", buf, string);\n  }\n\n  PUSH_ASN1_INTEGER(L, X509_get0_serialNumber(cert));\n  lua_setfield(L, -2, \"serialNumber\");\n\n  PUSH_ASN1_TIME(L, X509_get0_notBefore(cert));\n  lua_setfield(L, -2, \"notBefore\");\n  PUSH_ASN1_TIME(L, X509_get0_notAfter(cert));\n  lua_setfield(L, -2, \"notAfter\");\n\n  {\n    CONSTIFY_X509_get0 X509_ALGOR *palg = NULL;\n    CONSTIFY_X509_get0 ASN1_BIT_STRING *psig = NULL;\n\n    X509_get0_signature(&psig, &palg, cert);\n    if (palg != NULL)\n    {\n      alg = X509_ALGOR_dup((X509_ALGOR*)palg);\n      PUSH_OBJECT(alg, \"openssl.x509_algor\");\n      lua_setfield(L, -2, \"sig_alg\");\n    }\n    if (psig != NULL)\n    {\n      lua_pushlstring(L, (const char *)psig->data, psig->length);\n      lua_setfield(L, -2, \"sig\");\n    }\n  }\n\n  {\n    int l = 0;\n    char* tmpstr = (char *)X509_alias_get0(cert, &l);\n    if (tmpstr)\n    {\n      AUXILIAR_SETLSTR(L, -1, \"alias\", tmpstr, l);\n    }\n  }\n\n  AUXILIAR_SET(L, -1, \"ca\", X509_check_ca(cert), boolean);\n\n  lua_newtable(L);\n  for (i = 0; i < X509_PURPOSE_get_count(); i++)\n  {\n    int set;\n    X509_PURPOSE *purp = X509_PURPOSE_get0(i);\n    int id = X509_PURPOSE_get_id(purp);\n    const char * pname = X509_PURPOSE_get0_sname(purp);\n\n    set = X509_check_purpose(cert, id, 0);\n    if (set)\n    {\n      AUXILIAR_SET(L, -1, pname, 1, boolean);\n    }\n    set = X509_check_purpose(cert, id, 1);\n    if (set)\n    {\n      lua_pushfstring(L, \"%s CA\", pname);\n      pname = lua_tostring(L, -1);\n      AUXILIAR_SET(L, -2, pname, 1, boolean);\n      lua_pop(L, 1);\n    }\n  }\n  lua_setfield(L, -2, \"purposes\");\n\n  {\n    int n = X509_get_ext_count(cert);\n    if (n > 0)\n    {\n      lua_pushstring(L, \"extensions\");\n      lua_newtable(L);\n      for (i = 0; i < n; i++)\n      {\n        X509_EXTENSION *ext = X509_get_ext(cert, i);\n        ext = X509_EXTENSION_dup(ext);\n        lua_pushinteger(L, i + 1);\n        PUSH_OBJECT(ext, \"openssl.x509_extension\");\n        lua_rawset(L, -3);\n      }\n      lua_rawset(L, -3);\n    }\n  }\n\n  return 1;\n}\n\nstatic LUA_FUNCTION(openssl_x509_free)\n{\n  X509 *cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  X509_free(cert);\n  return 0;\n}\n\n/***\nget public key of x509\n@function pubkey\n@treturn evp_pkey public key\n*/\n/***\nset public key of x509\n@function pubkey\n@tparam evp_pkey pubkey public key set to x509\n@treturn boolean result, true for success\n*/\nstatic LUA_FUNCTION(openssl_x509_public_key)\n{\n  X509 *cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    EVP_PKEY *pkey = X509_get_pubkey(cert);\n    PUSH_OBJECT(pkey, \"openssl.evp_pkey\");\n    return 1;\n  }\n  else\n  {\n    EVP_PKEY* pkey = CHECK_OBJECT(2, EVP_PKEY, \"openssl.evp_pkey\");\n    int ret = X509_set_pubkey(cert, pkey);\n    return openssl_pushresult(L, ret);\n  }\n}\n\n#if 0\nstatic int verify_cb(int ok, X509_STORE_CTX *ctx)\n{\n  int err;\n  X509 *err_cert;\n\n  /*\n  * it is ok to use a self signed certificate This case will catch both\n  * the initial ok == 0 and the final ok == 1 calls to this function\n  */\n  err = X509_STORE_CTX_get_error(ctx);\n  if (err == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT)\n    return 1;\n\n  /*\n  * BAD we should have gotten an error.  Normally if everything worked\n  * X509_STORE_CTX_get_error(ctx) will still be set to\n  * DEPTH_ZERO_SELF_....\n  */\n  if (ok)\n  {\n    //BIO_printf(bio_err, \"error with certificate to be certified - should be self signed\\n\");\n    return 0;\n  }\n  else\n  {\n    err_cert = X509_STORE_CTX_get_current_cert(ctx);\n    //print_name(bio_err, NULL, X509_get_subject_name(err_cert), 0);\n    //BIO_printf(bio_err, \"error with certificate - error %d at depth %d\\n%s\\n\", err, X509_STORE_CTX_get_error_depth(ctx), X509_verify_cert_error_string(err));\n    return 1;\n  }\n}\n#endif\n\n/***\ncheck x509 with ca certchian and option purpose\npurpose can be one of: ssl_client, ssl_server, ns_ssl_server, smime_sign, smime_encrypt, crl_sign, any, ocsp_helper, timestamp_sign\n@function check\n@tparam x509_store cacerts\n@tparam x509_store untrusted certs  containing a bunch of certs that are not trusted but may be useful in validating the certificate.\n@tparam[opt] string purpose to check supported\n@treturn boolean result true for check pass\n@treturn integer verify result\n@see verify_cert_error_string\n*/\n/***\ncheck x509 with evp_pkey\n@function check\n@tparam evp_pkey pkey private key witch match with x509 pubkey\n@treturn boolean result true for check pass\n*/\nstatic LUA_FUNCTION(openssl_x509_check)\n{\n  X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (auxiliar_getclassudata(L, \"openssl.evp_pkey\", 2))\n  {\n    EVP_PKEY * key = CHECK_OBJECT(2, EVP_PKEY, \"openssl.evp_pkey\");\n    lua_pushboolean(L, X509_check_private_key(cert, key));\n    return 1;\n  }\n  else\n  {\n    X509_STORE* store = CHECK_OBJECT(2, X509_STORE, \"openssl.x509_store\");\n    STACK_OF(X509)* untrustedchain = lua_isnoneornil(L, 3) ?  NULL : openssl_sk_x509_fromtable(L, 3);\n    int purpose = 0;\n    int ret = 0;\n    if (!lua_isnone(L, 4))\n    {\n      int purpose_id = X509_PURPOSE_get_by_sname((char*)luaL_optstring(L, 4, \"any\"));\n      if (purpose_id >= 0)\n      {\n        X509_PURPOSE* ppurpose = X509_PURPOSE_get0(purpose_id);\n        if (ppurpose)\n        {\n          purpose = ppurpose->purpose;\n        }\n      }\n    }\n#if 0\n    X509_STORE_set_verify_cb_func(store, verify_cb);\n#endif\n    if (untrustedchain!=NULL)\n      sk_X509_pop_free(untrustedchain, X509_free);\n    ret = check_cert(store, cert, untrustedchain, purpose);\n    lua_pushboolean(L, ret == X509_V_OK);\n    lua_pushinteger(L, ret);\n\n    return 2;\n  }\n}\n\n/***\nThe functions return 1 for a successful match, 0 for a failed match and -1 for\nan internal error: typically a memory allocation failure or an ASN.1 decoding\nerror.\n\nAll functions can also return -2 if the input is malformed. For example,\nX509_check_host() returns -2 if the provided name contains embedded NULs.\n*/\nstatic int openssl_push_check_result(lua_State *L, int ret, const char* name)\n{\n  switch (ret)\n  {\n  case 1:\n    lua_pushboolean(L, 1);\n    if (name)\n    {\n      lua_pushstring(L, name);\n      ret = 2;\n    }\n    break;\n  case 0:\n    lua_pushboolean(L, 0);\n    ret = 1;\n    break;\n  case -1:\n    lua_pushnil(L);\n    lua_pushliteral(L, \"internal\");\n    ret = 2;\n  case -2:\n    lua_pushnil(L);\n    lua_pushliteral(L, \"malformed\");\n    ret = 2;\n  default:\n    lua_pushnil(L);\n    lua_pushinteger(L, ret);\n    ret = 2;\n  }\n  return ret;\n}\n\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\n/***\ncheck x509 for host (only for openssl 1.0.2 or greater)\n@function check_host\n@tparam string host hostname to check for match match with x509 subject\n@treturn boolean result true if host is present and matches the certificate\n*/\nstatic LUA_FUNCTION(openssl_x509_check_host)\n{\n  X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  size_t sz;\n  const char* hostname = luaL_checklstring(L, 2, &sz);\n  int flags = luaL_optint(L, 3, 0);\n  char *peer = NULL;\n\n  int ret = X509_check_host(cert, hostname, sz, flags, &peer);\n  ret = openssl_push_check_result(L, ret, peer);\n  OPENSSL_free(peer);\n  return ret;\n}\n\n/***\ncheck x509 for email address (only for openssl 1.0.2 or greater)\n@tparam string email to check for match match with x509 subject\n@treturn boolean result true if host is present and matches the certificate\n@function check_email\n*/\nstatic LUA_FUNCTION(openssl_x509_check_email)\n{\n  X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  size_t sz;\n  const char *email = luaL_checklstring(L, 2, &sz);\n  int flags = luaL_optint(L, 3, 0);\n  int ret = X509_check_email(cert, email, sz, flags);\n  return openssl_push_check_result(L, ret, NULL);\n}\n\n/***\ncheck x509 for ip address (ipv4 or ipv6, only for openssl 1.0.2 or greater)\n@function check_ip_asc\n@tparam string ip to check for match match with x509 subject\n@treturn boolean result true if host is present and matches the certificate\n*/\nstatic LUA_FUNCTION(openssl_x509_check_ip)\n{\n  X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  size_t sz;\n  const char *ip = luaL_checklstring(L, 2, &sz);\n  int flags = luaL_optint(L, 3, 0);\n  int ret = X509_check_ip(cert, (const unsigned char*)ip, sz, flags);\n  return openssl_push_check_result(L, ret, NULL);\n}\n#endif\n\nIMP_LUA_SK(X509, x509)\n\n#if 0\nstatic STACK_OF(X509) * load_all_certs_from_file(BIO *in)\n{\n  STACK_OF(X509) *stack = sk_X509_new_null();\n  if (stack)\n  {\n    STACK_OF(X509_INFO) *sk = PEM_X509_INFO_read_bio(in, NULL, NULL, NULL);\n    /* scan over it and pull out the certs */\n    while (sk_X509_INFO_num(sk))\n    {\n      X509_INFO *xi = sk_X509_INFO_shift(sk);\n      if (xi->x509 != NULL)\n      {\n        sk_X509_push(stack, xi->x509);\n        xi->x509 = NULL;\n      }\n      X509_INFO_free(xi);\n    }\n    sk_X509_INFO_free(sk);\n  };\n\n  if (sk_X509_num(stack) == 0)\n  {\n    sk_X509_free(stack);\n    stack = NULL;\n  }\n  return stack;\n};\n#endif\n\n/***\nget subject name of x509\n@function subject\n@treturn x509_name subject name\n*/\n/***\nset subject name of x509\n@function subject\n@tparam x509_name subject\n@treturn boolean result true for success\n*/\nstatic int openssl_x509_subject(lua_State* L)\n{\n  X509* cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    X509_NAME* xn = X509_get_subject_name(cert);\n    return openssl_push_xname_asobject(L, xn);\n  }\n  else\n  {\n    X509_NAME *xn = CHECK_OBJECT(2, X509_NAME, \"openssl.x509_name\");\n    int ret = X509_set_subject_name(cert, xn);\n    return openssl_pushresult(L, ret);\n  }\n}\n\n/***\nget issuer name of x509\n@function issuer\n@tparam[opt=false] boolean asobject, true for return as x509_name object, or as table\n@treturn[1] x509_name issuer\n@treturn[1] table issuer name as table\n*/\n/***\nset issuer name of x509\n@function issuer\n@tparam x509_name name\n@treturn boolean result true for success\n*/\nstatic int openssl_x509_issuer(lua_State* L)\n{\n  X509* cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    X509_NAME* xn = X509_get_issuer_name(cert);\n    return openssl_push_xname_asobject(L, xn);\n  }\n  else\n  {\n    X509_NAME* xn = CHECK_OBJECT(2, X509_NAME, \"openssl.x509_name\");\n    int ret = X509_set_issuer_name(cert, xn);\n    return openssl_pushresult(L, ret);\n  }\n}\n\n/***\nget digest of x509 object\n@function digest\n@tparam[opt='sha1'] evp_digest|string md_alg, default use 'sha1'\n@treturn string digest result\n*/\nstatic int openssl_x509_digest(lua_State* L)\n{\n  unsigned int bytes;\n  unsigned char buffer[EVP_MAX_MD_SIZE];\n  char hex_buffer[EVP_MAX_MD_SIZE * 2];\n  X509 *cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  const EVP_MD *digest = get_digest(L, 2, \"sha256\");\n  int ret;\n  if (!digest)\n  {\n    lua_pushnil(L);\n    lua_pushfstring(L, \"digest algorithm not supported (%s)\", lua_tostring(L, 2));\n    return 2;\n  }\n  ret = X509_digest(cert, digest, buffer, &bytes);\n  if (ret)\n  {\n    to_hex((char*)buffer, bytes, hex_buffer);\n    lua_pushlstring(L, hex_buffer, bytes * 2);\n    return 1;\n  }\n  return openssl_pushresult(L, ret);\n};\n\n/***\nget notbefore valid time of x509\n@function notbefore\n@treturn string notbefore time string\n*/\n/***\nset notbefore valid time of x509\n@function notbefore\n@tparam string|number notbefore\n*/\nstatic int openssl_x509_notbefore(lua_State *L)\n{\n  X509* cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    return PUSH_ASN1_TIME(L, X509_get0_notBefore(cert));\n  }\n  else\n  {\n    ASN1_TIME* at = NULL;\n    int ret = 1;\n    if (lua_isnumber(L, 2))\n    {\n      time_t time = lua_tointeger(L, 2);\n      at = ASN1_TIME_new();\n      ASN1_TIME_set(at, time);\n    }\n    else if (lua_isstring(L, 2))\n    {\n      const char* time = lua_tostring(L, 2);\n      at = ASN1_TIME_new();\n      if (ASN1_TIME_set_string(at, time) != 1)\n      {\n        ASN1_TIME_free(at);\n        at = NULL;\n      }\n    }\n    if (at)\n    {\n      ret = X509_set1_notBefore(cert, at);\n      ASN1_TIME_free(at);\n    }\n    else\n      ret = 0;\n    return openssl_pushresult(L, ret);\n  };\n}\n\n/***\nget notafter valid time of x509\n@function notafter\n@treturn string notafter time string\n*/\n/***\nset notafter valid time of x509\n@function notafter\n@tparam string|number notafter\n*/\nstatic int openssl_x509_notafter(lua_State *L)\n{\n  X509* cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    return PUSH_ASN1_TIME(L, X509_get0_notAfter(cert));\n  }\n  else\n  {\n    ASN1_TIME* at = NULL;\n    int ret = 1;\n    if (lua_isnumber(L, 2))\n    {\n      time_t time = lua_tointeger(L, 2);\n      at = ASN1_TIME_new();\n      ASN1_TIME_set(at, time);\n    }\n    else if (lua_isstring(L, 2))\n    {\n      const char* time = lua_tostring(L, 2);\n      at = ASN1_TIME_new();\n      if (ASN1_TIME_set_string(at, time) != 1)\n      {\n        ASN1_TIME_free(at);\n        at = NULL;\n      }\n    }\n    if (at)\n    {\n      ret = X509_set1_notAfter(cert, at);\n      ASN1_TIME_free(at);\n    }\n    else\n      ret = 0;\n    return openssl_pushresult(L, ret);\n  }\n}\n\n/***\ncheck x509 valid\n@function validat\n@tparam[opt] number time, default will use now time\n@treturn boolean result true for valid, or for invalid\n@treturn string notbefore\n@treturn string notafter\n*/\n/***\nset valid time, notbefore and notafter\n@function validat\n@tparam number notbefore\n@tparam number notafter\n@treturn boolean result, true for success\n*/\nstatic int openssl_x509_valid_at(lua_State* L)\n{\n  X509* cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    time_t now = 0;;\n    time(&now);\n\n    lua_pushboolean(L, (X509_cmp_time(X509_get0_notAfter(cert), &now)     >= 0\n                        && X509_cmp_time(X509_get0_notBefore(cert), &now) <= 0));\n    PUSH_ASN1_TIME(L, X509_get0_notBefore(cert));\n    PUSH_ASN1_TIME(L, X509_get0_notAfter(cert));\n    return 3;\n  }\n  else if (lua_gettop(L) == 2)\n  {\n    time_t time = luaL_checkinteger(L, 2);\n    lua_pushboolean(L, (X509_cmp_time(X509_get0_notAfter(cert), &time)     >= 0\n                        && X509_cmp_time(X509_get0_notBefore(cert), &time) <= 0));\n    PUSH_ASN1_TIME(L, X509_get0_notBefore(cert));\n    PUSH_ASN1_TIME(L, X509_get0_notAfter(cert));\n    return 3;\n  }\n  else if (lua_gettop(L) == 3)\n  {\n    time_t before, after;\n    ASN1_TIME *ab, *aa;\n    int ret = 1;\n    before = lua_tointeger(L, 2);\n    after  = lua_tointeger(L, 3);\n\n    ab = ASN1_TIME_new();\n    aa = ASN1_TIME_new();\n    ASN1_TIME_set(ab, before);\n    ASN1_TIME_set(aa, after);\n    ret = X509_set1_notBefore(cert, ab);\n    if (ret == 1)\n      ret = X509_set1_notAfter(cert, aa);\n\n    ASN1_TIME_free(ab);\n    ASN1_TIME_free(aa);\n\n    return openssl_pushresult(L, ret);\n  }\n  return 0;\n}\n\n/***\nget serial number of x509\n@function serial\n@tparam[opt=true] boolean asobject\n@treturn[1] bn object\n@treturn[2] string result\n*/\n/***\nset serial number of x509\n@function serial\n@tparam string|number|bn serail\n@treturn boolean result true for success\n*/\nstatic int openssl_x509_serial(lua_State *L)\n{\n  X509* cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  ASN1_INTEGER *serial = X509_get_serialNumber(cert);\n  if (lua_isboolean(L, 2))\n  {\n    int asobj = lua_toboolean(L, 2);\n    if (asobj)\n    {\n      PUSH_ASN1_INTEGER(L, serial);\n    }\n    else\n    {\n      BIGNUM *bn = ASN1_INTEGER_to_BN(serial, NULL);\n      PUSH_OBJECT(bn, \"openssl.bn\");\n    }\n  }\n  else if (lua_isnone(L, 2))\n  {\n    BIGNUM *bn = ASN1_INTEGER_to_BN(serial, NULL);\n    char *tmp = BN_bn2hex(bn);\n    lua_pushstring(L, tmp);\n    OPENSSL_free(tmp);\n    BN_free(bn);\n  }\n  else\n  {\n    int ret;\n    if (auxiliar_getclassudata(L, \"openssl.asn1_string\", 2))\n    {\n      serial = CHECK_OBJECT(2, ASN1_STRING, \"openssl.asn1_string\");\n    }\n    else\n    {\n      BIGNUM *bn = BN_get(L, 2);\n      serial = BN_to_ASN1_INTEGER(bn, NULL);\n      BN_free(bn);\n    }\n    luaL_argcheck(L, serial != NULL, 2, \"not accept\");\n    ret = X509_set_serialNumber(cert, serial);\n    ASN1_INTEGER_free(serial);\n    return openssl_pushresult(L, ret);\n  }\n  return 1;\n}\n\n/***\nget version number of x509\n@function version\n@treturn number version of x509\n*/\n/***\nset version number of x509\n@function version\n@tparam number version\n@treturn boolean result true for result\n*/\nstatic int openssl_x509_version(lua_State *L)\n{\n  int version;\n  X509* cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    version = X509_get_version(cert);\n    lua_pushinteger(L, version);\n    return 1;\n  }\n  else\n  {\n    int ret;\n    version = luaL_checkint(L, 2);\n    ret = X509_set_version(cert, version);\n    return openssl_pushresult(L, ret);\n  }\n}\n\n/***\nget extensions of x509 object\n@function extensions\n@tparam[opt=false] boolean asobject, true for return as stack_of_x509_extension or as table\n@treturn[1] stack_of_x509_extension object when param set true\n@treturn[2] table contain all x509_extension when param set false or nothing\n*/\n/***\nset extension of x509 object\n@function extensions\n@tparam stack_of_x509_extension extensions\n@treturn boolean result true for success\n*/\nstatic int openssl_x509_extensions(lua_State* L)\n{\n  X509 *self = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  STACK_OF(X509_EXTENSION) *exts = (STACK_OF(X509_EXTENSION) *)X509_get0_extensions(self);\n  if (lua_isnone(L, 2))\n  {\n    if (exts)\n    {\n      openssl_sk_x509_extension_totable(L, exts);\n    }\n    else\n      lua_pushnil(L);\n    return 1;\n  }\n  else\n  {\n    STACK_OF(X509_EXTENSION) *others = (STACK_OF(X509_EXTENSION) *)openssl_sk_x509_extension_fromtable(L, 2);\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    sk_X509_EXTENSION_pop_free(self->cert_info->extensions, X509_EXTENSION_free);\n    self->cert_info->extensions = others;\n#else\n    int i;\n    int n = sk_X509_EXTENSION_num(exts);\n    for (i = 0; i < n; i++)\n      sk_X509_EXTENSION_delete(exts, i);\n    n = sk_X509_EXTENSION_num(others);\n    for (i = 0; i < n; i++)\n    {\n      X509_EXTENSION* ext = sk_X509_EXTENSION_value(others, i);\n      if (exts!=NULL)\n        sk_X509_EXTENSION_push(exts, ext);\n      else\n        X509_add_ext(self, ext, -1);\n    }\n    sk_X509_EXTENSION_pop_free(others, X509_EXTENSION_free);\n#endif\n    return openssl_pushresult(L, 1);\n  }\n}\n\n/***\nsign x509\n@function sign\n@tparam evp_pkey pkey private key to sign x509\n@tparam x509|x509_name cacert or cacert x509_name\n@tparam[opt='sha1WithRSAEncryption'] string|md_digest md_alg\n@treturn boolean result true for check pass\n*/\nstatic int openssl_x509_sign(lua_State*L)\n{\n  X509* x = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    unsigned char *out = NULL;\n    int len = i2d_re_X509_tbs(x, &out);\n    if (len > 0)\n    {\n      lua_pushlstring(L, (const char *)out, len);\n      OPENSSL_free(out);\n      return 1;\n    }\n    return openssl_pushresult(L, len);\n  }\n  else if (auxiliar_getclassudata(L, \"openssl.evp_pkey\", 2))\n  {\n    EVP_PKEY* pkey = CHECK_OBJECT(2, EVP_PKEY, \"openssl.evp_pkey\");\n    const EVP_MD *md;\n    int ret = 1;\n    int i = 3;\n    if (auxiliar_getclassudata(L, \"openssl.x509_name\", 3))\n    {\n      X509_NAME* xn = CHECK_OBJECT(3, X509_NAME, \"openssl.x509_name\");\n      ret = X509_set_issuer_name(x, xn);\n      i++;\n    }\n    else\n    {\n      X509* ca = CHECK_OBJECT(3, X509, \"openssl.x509\");\n      X509_NAME* xn = X509_get_subject_name(ca);\n      ret = X509_check_private_key(ca, pkey);\n      if (ret == 1)\n      {\n        ret = X509_set_issuer_name(x, xn);\n      }\n      i++;\n    }\n\n    if (ret == 1)\n    {\n      md = get_digest(L, i, \"sha256\");\n      ret = X509_sign(x, pkey, md);\n      if (ret > 0)\n        ret = 1;\n    }\n    return openssl_pushresult(L, ret);\n  }\n  else\n  {\n    size_t sig_len;\n    const char* sig = luaL_checklstring(L, 2, &sig_len);\n    ASN1_OBJECT *obj = openssl_get_asn1object(L, 3, 0);\n    CONSTIFY_X509_get0 ASN1_BIT_STRING *psig = NULL;\n    CONSTIFY_X509_get0 X509_ALGOR *palg = NULL;\n    int ret;\n\n    X509_get0_signature(&psig, &palg, x);\n    ret = ASN1_BIT_STRING_set((ASN1_BIT_STRING*)psig, (unsigned char*)sig, (int)sig_len);\n    if (ret == 1)\n    {\n      ret = X509_ALGOR_set0((X509_ALGOR*)palg, obj, V_ASN1_UNDEF, NULL);\n    }\n    else\n      ASN1_OBJECT_free(obj);\n    return openssl_pushresult(L, ret);\n  }\n}\n\nstatic int openssl_x509_verify(lua_State*L)\n{\n  X509* x = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isnone(L, 2))\n  {\n    unsigned char *out = NULL;\n    int len = i2d_re_X509_tbs(x, &out);\n    if (len > 0)\n    {\n      CONSTIFY_X509_get0 ASN1_BIT_STRING *psig = NULL;\n      CONSTIFY_X509_get0 X509_ALGOR *palg = NULL;\n\n      lua_pushlstring(L, (const char *)out, len);\n      OPENSSL_free(out);\n\n      X509_get0_signature(&psig, &palg, x);\n      if (psig != NULL)\n      {\n        lua_pushlstring(L, (const char *)psig->data, psig->length);\n      }\n      else\n        lua_pushnil(L);\n\n      if (palg)\n      {\n        X509_ALGOR *alg = X509_ALGOR_dup((X509_ALGOR *)palg);\n        PUSH_OBJECT(alg, \"openssl.x509_algor\");\n      }\n      else\n        lua_pushnil(L);\n      return 3;\n    }\n    return openssl_pushresult(L, len);\n  }\n  else\n  {\n    EVP_PKEY *pkey = CHECK_OBJECT(2, EVP_PKEY, \"openssl.evp_pkey\");\n    int ret = X509_verify(x, pkey);\n    return openssl_pushresult(L, ret);\n  }\n}\n\nstatic luaL_Reg x509_funcs[] =\n{\n  {\"parse\",       openssl_x509_parse},\n  {\"export\",      openssl_x509_export},\n  {\"check\",       openssl_x509_check},\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\n  {\"check_host\",  openssl_x509_check_host},\n  {\"check_email\", openssl_x509_check_email},\n  {\"check_ip_asc\", openssl_x509_check_ip},\n#endif\n  {\"pubkey\",      openssl_x509_public_key},\n  {\"version\",     openssl_x509_version},\n\n  {\"__gc\",        openssl_x509_free},\n  {\"__tostring\",  auxiliar_tostring},\n\n  /* compat with luasec */\n  {\"digest\",     openssl_x509_digest},\n  {\"extensions\", openssl_x509_extensions},\n  {\"issuer\",     openssl_x509_issuer},\n  {\"notbefore\",  openssl_x509_notbefore},\n  {\"notafter\",   openssl_x509_notafter},\n  {\"serial\",     openssl_x509_serial},\n  {\"subject\",    openssl_x509_subject},\n  {\"validat\",    openssl_x509_valid_at},\n\n  {\"sign\",       openssl_x509_sign},\n  {\"verify\",     openssl_x509_verify},\n\n  {NULL,      NULL},\n};\n\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\nstatic LuaL_Enumeration check_flags_const[] =\n{\n#define DEFINE_ENUM(x)  \\\n  {#x,  X509_CHECK_FLAG_##x}\n  DEFINE_ENUM(ALWAYS_CHECK_SUBJECT),\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n  DEFINE_ENUM(NEVER_CHECK_SUBJECT),\n#endif\n  DEFINE_ENUM(NO_WILDCARDS),\n  DEFINE_ENUM(NO_PARTIAL_WILDCARDS),\n  DEFINE_ENUM(MULTI_LABEL_WILDCARDS),\n  DEFINE_ENUM(SINGLE_LABEL_SUBDOMAINS),\n#undef DEFINE_ENUM\n\n  {NULL,           0}\n};\n#endif\n\nint luaopen_x509(lua_State *L)\n{\n  auxiliar_newclass(L, \"openssl.x509\", x509_funcs);\n\n  lua_newtable(L);\n  luaL_setfuncs(L, R, 0);\n\n  openssl_register_xname(L);\n  lua_setfield(L, -2, \"name\");\n  openssl_register_xattribute(L);\n  lua_setfield(L, -2, \"attribute\");\n  openssl_register_xextension(L);\n  lua_setfield(L, -2, \"extension\");\n  openssl_register_xstore(L);\n  lua_setfield(L, -2, \"store\");\n  openssl_register_xalgor(L);\n  lua_setfield(L, -2, \"algor\");\n\n  luaopen_x509_req(L);\n  lua_setfield(L, -2, \"req\");\n  luaopen_x509_crl(L);\n  lua_setfield(L, -2, \"crl\");\n\n  lua_pushliteral(L, \"version\");    /** version */\n  lua_pushliteral(L, MYVERSION);\n  lua_settable(L, -3);\n\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\n  lua_pushliteral(L, \"check_flag\");\n  lua_newtable(L);\n  auxiliar_enumerate(L, -1, check_flags_const);\n  lua_settable(L, -3);\n#endif\n\n  return 1;\n}\n"], "filenames": ["src/x509.c"], "buggy_code_start_loc": [753], "buggy_code_end_loc": [1413], "fixing_code_start_loc": [754], "fixing_code_end_loc": [1470], "type": "CWE-295", "message": "openssl_x509_check_email in lua-openssl 0.7.7-1 mishandles X.509 certificate validation because it uses lua_pushboolean for certain non-boolean return values.", "other": {"cve": {"id": "CVE-2020-9433", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-27T23:15:13.187", "lastModified": "2020-02-28T16:32:28.810", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "openssl_x509_check_email in lua-openssl 0.7.7-1 mishandles X.509 certificate validation because it uses lua_pushboolean for certain non-boolean return values."}, {"lang": "es", "value": "openssl_x509_check_email en lua-openssl versi\u00f3n 0.7.7-1, maneja inapropiadamente la comprobaci\u00f3n del certificado X.509 porque usa lua_pushboolean para determinados valores de retorno no booleanos."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lua-openssl_project:lua-openssl:0.7.7-1:*:*:*:*:*:*:*", "matchCriteriaId": "A8172202-5313-4B8D-8986-95A22F070785"}]}]}], "references": [{"url": "https://github.com/zhaozg/lua-openssl/commit/a6dc186dd4b6b9e329a93cca3e7e3cfccfdf3cca", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zhaozg/lua-openssl/commit/a6dc186dd4b6b9e329a93cca3e7e3cfccfdf3cca"}}