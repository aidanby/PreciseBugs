{"buggy_code": ["from __future__ import division, absolute_import, print_function\n\nimport sys\nfrom tempfile import NamedTemporaryFile, TemporaryFile, mktemp\nimport os\n\nfrom numpy import memmap\nfrom numpy import arange, allclose, asarray\nfrom numpy.testing import *\n\nclass TestMemmap(TestCase):\n    def setUp(self):\n        self.tmpfp = NamedTemporaryFile(prefix='mmap')\n        self.shape = (3, 4)\n        self.dtype = 'float32'\n        self.data = arange(12, dtype=self.dtype)\n        self.data.resize(self.shape)\n\n    def tearDown(self):\n        self.tmpfp.close()\n\n    def test_roundtrip(self):\n        # Write data to file\n        fp = memmap(self.tmpfp, dtype=self.dtype, mode='w+',\n                    shape=self.shape)\n        fp[:] = self.data[:]\n        del fp # Test __del__ machinery, which handles cleanup\n\n        # Read data back from file\n        newfp = memmap(self.tmpfp, dtype=self.dtype, mode='r',\n                       shape=self.shape)\n        assert_(allclose(self.data, newfp))\n        assert_array_equal(self.data, newfp)\n\n    def test_open_with_filename(self):\n        tmpname = mktemp('', 'mmap')\n        fp = memmap(tmpname, dtype=self.dtype, mode='w+',\n                       shape=self.shape)\n        fp[:] = self.data[:]\n        del fp\n        os.unlink(tmpname)\n\n    def test_unnamed_file(self):\n        with TemporaryFile() as f:\n            fp = memmap(f, dtype=self.dtype, shape=self.shape)\n            del fp\n\n    def test_attributes(self):\n        offset = 1\n        mode = \"w+\"\n        fp = memmap(self.tmpfp, dtype=self.dtype, mode=mode,\n                    shape=self.shape, offset=offset)\n        self.assertEqual(offset, fp.offset)\n        self.assertEqual(mode, fp.mode)\n        del fp\n\n    def test_filename(self):\n        tmpname = mktemp('', 'mmap')\n        fp = memmap(tmpname, dtype=self.dtype, mode='w+',\n                       shape=self.shape)\n        abspath = os.path.abspath(tmpname)\n        fp[:] = self.data[:]\n        self.assertEqual(abspath, fp.filename)\n        b = fp[:1]\n        self.assertEqual(abspath, b.filename)\n        del b\n        del fp\n        os.unlink(tmpname)\n\n    def test_filename_fileobj(self):\n        fp = memmap(self.tmpfp, dtype=self.dtype, mode=\"w+\",\n                    shape=self.shape)\n        self.assertEqual(fp.filename, self.tmpfp.name)\n\n    @dec.knownfailureif(sys.platform=='gnu0', \"This test is known to fail on hurd\")\n    def test_flush(self):\n        fp = memmap(self.tmpfp, dtype=self.dtype, mode='w+',\n                    shape=self.shape)\n        fp[:] = self.data[:]\n        assert_equal(fp[0], self.data[0])\n        fp.flush()\n\n    def test_del(self):\n        # Make sure a view does not delete the underlying mmap\n        fp_base = memmap(self.tmpfp, dtype=self.dtype, mode='w+',\n                    shape=self.shape)\n        fp_base[0] = 5\n        fp_view = fp_base[0:1]\n        assert_equal(fp_view[0], 5)\n        del fp_view\n        # Should still be able to access and assign values after\n        # deleting the view\n        assert_equal(fp_base[0], 5)\n        fp_base[0] = 6\n        assert_equal(fp_base[0], 6)\n\n    def test_arithmetic_drops_references(self):\n        fp = memmap(self.tmpfp, dtype=self.dtype, mode='w+',\n                    shape=self.shape)\n        tmp = (fp + 10)\n        if isinstance(tmp, memmap):\n            assert tmp._mmap is not fp._mmap\n\n    def test_indexing_drops_references(self):\n        fp = memmap(self.tmpfp, dtype=self.dtype, mode='w+',\n                    shape=self.shape)\n        tmp = fp[[(1, 2), (2, 3)]]\n        if isinstance(tmp, memmap):\n            assert tmp._mmap is not fp._mmap\n\n    def test_slicing_keeps_references(self):\n        fp = memmap(self.tmpfp, dtype=self.dtype, mode='w+',\n                    shape=self.shape)\n        assert fp[:2, :2]._mmap is fp._mmap\n\n    def test_view(self):\n        fp = memmap(self.tmpfp, dtype=self.dtype, shape=self.shape)\n        new1 = fp.view()\n        new2 = new1.view()\n        assert(new1.base is fp)\n        assert(new2.base is fp)\n        new_array = asarray(fp)\n        assert(new_array.base is fp)\n\nif __name__ == \"__main__\":\n    run_module_suite()\n", "from __future__ import division, absolute_import, print_function\n\nimport tempfile\nimport sys\nimport os\nimport warnings\nimport operator\nimport io\nif sys.version_info[0] >= 3:\n    import builtins\nelse:\n    import __builtin__ as builtins\n\nimport numpy as np\nfrom nose import SkipTest\nfrom numpy.core import *\nfrom numpy.compat import asbytes, getexception, strchar, sixu\nfrom test_print import in_foreign_locale\nfrom numpy.core.multiarray_tests import (\n        test_neighborhood_iterator, test_neighborhood_iterator_oob,\n        test_pydatamem_seteventhook_start, test_pydatamem_seteventhook_end,\n        test_inplace_increment, get_buffer_info\n        )\nfrom numpy.testing import (\n        TestCase, run_module_suite, assert_, assert_raises,\n        assert_equal, assert_almost_equal, assert_array_equal,\n        assert_array_almost_equal, assert_allclose,\n        assert_array_less, runstring, dec\n        )\n\n# Need to test an object that does not fully implement math interface\nfrom datetime import timedelta\n\n\nif sys.version_info[:2] > (3, 2):\n    # In Python 3.3 the representation of empty shape, strides and suboffsets\n    # is an empty tuple instead of None.\n    # http://docs.python.org/dev/whatsnew/3.3.html#api-changes\n    EMPTY = ()\nelse:\n    EMPTY = None\n\n\nclass TestFlags(TestCase):\n    def setUp(self):\n        self.a = arange(10)\n\n    def test_writeable(self):\n        mydict = locals()\n        self.a.flags.writeable = False\n        self.assertRaises(ValueError, runstring, 'self.a[0] = 3', mydict)\n        self.assertRaises(ValueError, runstring, 'self.a[0:1].itemset(3)', mydict)\n        self.a.flags.writeable = True\n        self.a[0] = 5\n        self.a[0] = 0\n\n    def test_otherflags(self):\n        assert_equal(self.a.flags.carray, True)\n        assert_equal(self.a.flags.farray, False)\n        assert_equal(self.a.flags.behaved, True)\n        assert_equal(self.a.flags.fnc, False)\n        assert_equal(self.a.flags.forc, True)\n        assert_equal(self.a.flags.owndata, True)\n        assert_equal(self.a.flags.writeable, True)\n        assert_equal(self.a.flags.aligned, True)\n        assert_equal(self.a.flags.updateifcopy, False)\n\nclass TestHash(TestCase):\n    # see #3793\n    def test_int(self):\n        for st, ut, s in [(np.int8, np.uint8, 8),\n                          (np.int16, np.uint16, 16),\n                          (np.int32, np.uint32, 32),\n                          (np.int64, np.uint64, 64)]:\n            for i in range(1, s):\n                assert_equal(hash(st(-2**i)), hash(-2**i),\n                             err_msg=\"%r: -2**%d\" % (st, i))\n                assert_equal(hash(st(2**(i - 1))), hash(2**(i - 1)),\n                             err_msg=\"%r: 2**%d\" % (st, i - 1))\n                assert_equal(hash(st(2**i - 1)), hash(2**i - 1),\n                             err_msg=\"%r: 2**%d - 1\" % (st, i))\n\n                i = max(i - 1, 1)\n                assert_equal(hash(ut(2**(i - 1))), hash(2**(i - 1)),\n                             err_msg=\"%r: 2**%d\" % (ut, i - 1))\n                assert_equal(hash(ut(2**i - 1)), hash(2**i - 1),\n                             err_msg=\"%r: 2**%d - 1\" % (ut, i))\n\nclass TestAttributes(TestCase):\n    def setUp(self):\n        self.one = arange(10)\n        self.two = arange(20).reshape(4, 5)\n        self.three = arange(60, dtype=float64).reshape(2, 5, 6)\n\n    def test_attributes(self):\n        assert_equal(self.one.shape, (10,))\n        assert_equal(self.two.shape, (4, 5))\n        assert_equal(self.three.shape, (2, 5, 6))\n        self.three.shape = (10, 3, 2)\n        assert_equal(self.three.shape, (10, 3, 2))\n        self.three.shape = (2, 5, 6)\n        assert_equal(self.one.strides, (self.one.itemsize,))\n        num = self.two.itemsize\n        assert_equal(self.two.strides, (5*num, num))\n        num = self.three.itemsize\n        assert_equal(self.three.strides, (30*num, 6*num, num))\n        assert_equal(self.one.ndim, 1)\n        assert_equal(self.two.ndim, 2)\n        assert_equal(self.three.ndim, 3)\n        num = self.two.itemsize\n        assert_equal(self.two.size, 20)\n        assert_equal(self.two.nbytes, 20*num)\n        assert_equal(self.two.itemsize, self.two.dtype.itemsize)\n        assert_equal(self.two.base, arange(20))\n\n    def test_dtypeattr(self):\n        assert_equal(self.one.dtype, dtype(int_))\n        assert_equal(self.three.dtype, dtype(float_))\n        assert_equal(self.one.dtype.char, 'l')\n        assert_equal(self.three.dtype.char, 'd')\n        self.assertTrue(self.three.dtype.str[0] in '<>')\n        assert_equal(self.one.dtype.str[1], 'i')\n        assert_equal(self.three.dtype.str[1], 'f')\n\n    def test_int_subclassing(self):\n        # Regression test for https://github.com/numpy/numpy/pull/3526\n\n        numpy_int = np.int_(0)\n\n        if sys.version_info[0] >= 3:\n            # On Py3k int_ should not inherit from int, because it's not fixed-width anymore\n            assert_equal(isinstance(numpy_int, int), False)\n        else:\n            # Otherwise, it should inherit from int...\n            assert_equal(isinstance(numpy_int, int), True)\n\n            # ... and fast-path checks on C-API level should also work\n            from numpy.core.multiarray_tests import test_int_subclass\n            assert_equal(test_int_subclass(numpy_int), True)\n\n    def test_stridesattr(self):\n        x = self.one\n        def make_array(size, offset, strides):\n            return ndarray(size, buffer=x, dtype=int,\n                           offset=offset*x.itemsize,\n                           strides=strides*x.itemsize)\n        assert_equal(make_array(4, 4, -1), array([4, 3, 2, 1]))\n        self.assertRaises(ValueError, make_array, 4, 4, -2)\n        self.assertRaises(ValueError, make_array, 4, 2, -1)\n        self.assertRaises(ValueError, make_array, 8, 3, 1)\n        assert_equal(make_array(8, 3, 0), np.array([3]*8))\n        # Check behavior reported in gh-2503:\n        self.assertRaises(ValueError, make_array, (2, 3), 5, array([-2, -3]))\n        make_array(0, 0, 10)\n\n    def test_set_stridesattr(self):\n        x = self.one\n        def make_array(size, offset, strides):\n            try:\n                r = ndarray([size], dtype=int, buffer=x, offset=offset*x.itemsize)\n            except:\n                raise RuntimeError(getexception())\n            r.strides = strides=strides*x.itemsize\n            return r\n        assert_equal(make_array(4, 4, -1), array([4, 3, 2, 1]))\n        assert_equal(make_array(7, 3, 1), array([3, 4, 5, 6, 7, 8, 9]))\n        self.assertRaises(ValueError, make_array, 4, 4, -2)\n        self.assertRaises(ValueError, make_array, 4, 2, -1)\n        self.assertRaises(RuntimeError, make_array, 8, 3, 1)\n        # Check that the true extent of the array is used.\n        # Test relies on as_strided base not exposing a buffer.\n        x = np.lib.stride_tricks.as_strided(arange(1), (10, 10), (0, 0))\n        def set_strides(arr, strides):\n            arr.strides = strides\n        self.assertRaises(ValueError, set_strides, x, (10*x.itemsize, x.itemsize))\n\n        # Test for offset calculations:\n        x = np.lib.stride_tricks.as_strided(np.arange(10, dtype=np.int8)[-1],\n                                                    shape=(10,), strides=(-1,))\n        self.assertRaises(ValueError, set_strides, x[::-1], -1)\n        a = x[::-1]\n        a.strides = 1\n        a[::2].strides = 2\n\n    def test_fill(self):\n        for t in \"?bhilqpBHILQPfdgFDGO\":\n            x = empty((3, 2, 1), t)\n            y = empty((3, 2, 1), t)\n            x.fill(1)\n            y[...] = 1\n            assert_equal(x, y)\n\n    def test_fill_struct_array(self):\n        # Filling from a scalar\n        x = array([(0, 0.0), (1, 1.0)], dtype='i4,f8')\n        x.fill(x[0])\n        assert_equal(x['f1'][1], x['f1'][0])\n        # Filling from a tuple that can be converted\n        # to a scalar\n        x = np.zeros(2, dtype=[('a', 'f8'), ('b', 'i4')])\n        x.fill((3.5, -2))\n        assert_array_equal(x['a'], [3.5, 3.5])\n        assert_array_equal(x['b'], [-2, -2])\n\n\nclass TestArrayConstruction(TestCase):\n    def test_array(self):\n        d = np.ones(6)\n        r = np.array([d, d])\n        assert_equal(r, np.ones((2, 6)))\n\n        d = np.ones(6)\n        tgt = np.ones((2, 6))\n        r = np.array([d, d])\n        assert_equal(r, tgt)\n        tgt[1] = 2\n        r = np.array([d, d + 1])\n        assert_equal(r, tgt)\n\n        d = np.ones(6)\n        r = np.array([[d, d]])\n        assert_equal(r, np.ones((1, 2, 6)))\n\n        d = np.ones(6)\n        r = np.array([[d, d], [d, d]])\n        assert_equal(r, np.ones((2, 2, 6)))\n\n        d = np.ones((6, 6))\n        r = np.array([d, d])\n        assert_equal(r, np.ones((2, 6, 6)))\n\n        d = np.ones((6, ))\n        r = np.array([[d, d + 1], d + 2])\n        assert_equal(len(r), 2)\n        assert_equal(r[0], [d, d + 1])\n        assert_equal(r[1], d + 2)\n\n        tgt = np.ones((2, 3), dtype=np.bool)\n        tgt[0, 2] = False\n        tgt[1, 0:2] = False\n        r = np.array([[True, True, False], [False, False, True]])\n        assert_equal(r, tgt)\n        r = np.array([[True, False], [True, False], [False, True]])\n        assert_equal(r, tgt.T)\n\n\nclass TestAssignment(TestCase):\n    def test_assignment_broadcasting(self):\n        a = np.arange(6).reshape(2, 3)\n\n        # Broadcasting the input to the output\n        a[...] = np.arange(3)\n        assert_equal(a, [[0, 1, 2], [0, 1, 2]])\n        a[...] = np.arange(2).reshape(2, 1)\n        assert_equal(a, [[0, 0, 0], [1, 1, 1]])\n\n        # For compatibility with <= 1.5, a limited version of broadcasting\n        # the output to the input.\n        #\n        # This behavior is inconsistent with NumPy broadcasting\n        # in general, because it only uses one of the two broadcasting\n        # rules (adding a new \"1\" dimension to the left of the shape),\n        # applied to the output instead of an input. In NumPy 2.0, this kind\n        # of broadcasting assignment will likely be disallowed.\n        a[...] = np.arange(6)[::-1].reshape(1, 2, 3)\n        assert_equal(a, [[5, 4, 3], [2, 1, 0]])\n        # The other type of broadcasting would require a reduction operation.\n        def assign(a, b):\n            a[...] = b\n        assert_raises(ValueError, assign, a, np.arange(12).reshape(2, 2, 3))\n\n    def test_assignment_errors(self):\n        # Address issue #2276\n        class C:\n            pass\n        a = np.zeros(1)\n        def assign(v):\n            a[0] = v\n        assert_raises((AttributeError, TypeError), assign, C())\n        assert_raises(ValueError, assign, [1])\n\nclass TestDtypedescr(TestCase):\n    def test_construction(self):\n        d1 = dtype('i4')\n        assert_equal(d1, dtype(int32))\n        d2 = dtype('f8')\n        assert_equal(d2, dtype(float64))\n\nclass TestZeroRank(TestCase):\n    def setUp(self):\n        self.d = array(0), array('x', object)\n\n    def test_ellipsis_subscript(self):\n        a, b = self.d\n        self.assertEqual(a[...], 0)\n        self.assertEqual(b[...], 'x')\n        self.assertTrue(a[...] is a)\n        self.assertTrue(b[...] is b)\n\n    def test_empty_subscript(self):\n        a, b = self.d\n        self.assertEqual(a[()], 0)\n        self.assertEqual(b[()], 'x')\n        self.assertTrue(type(a[()]) is a.dtype.type)\n        self.assertTrue(type(b[()]) is str)\n\n    def test_invalid_subscript(self):\n        a, b = self.d\n        self.assertRaises(IndexError, lambda x: x[0], a)\n        self.assertRaises(IndexError, lambda x: x[0], b)\n        self.assertRaises(IndexError, lambda x: x[array([], int)], a)\n        self.assertRaises(IndexError, lambda x: x[array([], int)], b)\n\n    def test_ellipsis_subscript_assignment(self):\n        a, b = self.d\n        a[...] = 42\n        self.assertEqual(a, 42)\n        b[...] = ''\n        self.assertEqual(b.item(), '')\n\n    def test_empty_subscript_assignment(self):\n        a, b = self.d\n        a[()] = 42\n        self.assertEqual(a, 42)\n        b[()] = ''\n        self.assertEqual(b.item(), '')\n\n    def test_invalid_subscript_assignment(self):\n        a, b = self.d\n        def assign(x, i, v):\n            x[i] = v\n        self.assertRaises(IndexError, assign, a, 0, 42)\n        self.assertRaises(IndexError, assign, b, 0, '')\n        self.assertRaises(ValueError, assign, a, (), '')\n\n    def test_newaxis(self):\n        a, b = self.d\n        self.assertEqual(a[newaxis].shape, (1,))\n        self.assertEqual(a[..., newaxis].shape, (1,))\n        self.assertEqual(a[newaxis, ...].shape, (1,))\n        self.assertEqual(a[..., newaxis].shape, (1,))\n        self.assertEqual(a[newaxis, ..., newaxis].shape, (1, 1))\n        self.assertEqual(a[..., newaxis, newaxis].shape, (1, 1))\n        self.assertEqual(a[newaxis, newaxis, ...].shape, (1, 1))\n        self.assertEqual(a[(newaxis,)*10].shape, (1,)*10)\n\n    def test_invalid_newaxis(self):\n        a, b = self.d\n        def subscript(x, i): x[i]\n        self.assertRaises(IndexError, subscript, a, (newaxis, 0))\n        self.assertRaises(IndexError, subscript, a, (newaxis,)*50)\n\n    def test_constructor(self):\n        x = ndarray(())\n        x[()] = 5\n        self.assertEqual(x[()], 5)\n        y = ndarray((), buffer=x)\n        y[()] = 6\n        self.assertEqual(x[()], 6)\n\n    def test_output(self):\n        x = array(2)\n        self.assertRaises(ValueError, add, x, [1], x)\n\n\nclass TestScalarIndexing(TestCase):\n    def setUp(self):\n        self.d = array([0, 1])[0]\n\n    def test_ellipsis_subscript(self):\n        a = self.d\n        self.assertEqual(a[...], 0)\n        self.assertEqual(a[...].shape, ())\n\n    def test_empty_subscript(self):\n        a = self.d\n        self.assertEqual(a[()], 0)\n        self.assertEqual(a[()].shape, ())\n\n    def test_invalid_subscript(self):\n        a = self.d\n        self.assertRaises(IndexError, lambda x: x[0], a)\n        self.assertRaises(IndexError, lambda x: x[array([], int)], a)\n\n    def test_invalid_subscript_assignment(self):\n        a = self.d\n        def assign(x, i, v):\n            x[i] = v\n        self.assertRaises(TypeError, assign, a, 0, 42)\n\n    def test_newaxis(self):\n        a = self.d\n        self.assertEqual(a[newaxis].shape, (1,))\n        self.assertEqual(a[..., newaxis].shape, (1,))\n        self.assertEqual(a[newaxis, ...].shape, (1,))\n        self.assertEqual(a[..., newaxis].shape, (1,))\n        self.assertEqual(a[newaxis, ..., newaxis].shape, (1, 1))\n        self.assertEqual(a[..., newaxis, newaxis].shape, (1, 1))\n        self.assertEqual(a[newaxis, newaxis, ...].shape, (1, 1))\n        self.assertEqual(a[(newaxis,)*10].shape, (1,)*10)\n\n    def test_invalid_newaxis(self):\n        a = self.d\n        def subscript(x, i): x[i]\n        self.assertRaises(IndexError, subscript, a, (newaxis, 0))\n        self.assertRaises(IndexError, subscript, a, (newaxis,)*50)\n\n    def test_overlapping_assignment(self):\n        # With positive strides\n        a = np.arange(4)\n        a[:-1] = a[1:]\n        assert_equal(a, [1, 2, 3, 3])\n\n        a = np.arange(4)\n        a[1:] = a[:-1]\n        assert_equal(a, [0, 0, 1, 2])\n\n        # With positive and negative strides\n        a = np.arange(4)\n        a[:] = a[::-1]\n        assert_equal(a, [3, 2, 1, 0])\n\n        a = np.arange(6).reshape(2, 3)\n        a[::-1,:] = a[:, ::-1]\n        assert_equal(a, [[5, 4, 3], [2, 1, 0]])\n\n        a = np.arange(6).reshape(2, 3)\n        a[::-1, ::-1] = a[:, ::-1]\n        assert_equal(a, [[3, 4, 5], [0, 1, 2]])\n\n        # With just one element overlapping\n        a = np.arange(5)\n        a[:3] = a[2:]\n        assert_equal(a, [2, 3, 4, 3, 4])\n\n        a = np.arange(5)\n        a[2:] = a[:3]\n        assert_equal(a, [0, 1, 0, 1, 2])\n\n        a = np.arange(5)\n        a[2::-1] = a[2:]\n        assert_equal(a, [4, 3, 2, 3, 4])\n\n        a = np.arange(5)\n        a[2:] = a[2::-1]\n        assert_equal(a, [0, 1, 2, 1, 0])\n\n        a = np.arange(5)\n        a[2::-1] = a[:1:-1]\n        assert_equal(a, [2, 3, 4, 3, 4])\n\n        a = np.arange(5)\n        a[:1:-1] = a[2::-1]\n        assert_equal(a, [0, 1, 0, 1, 2])\n\nclass TestCreation(TestCase):\n    def test_from_attribute(self):\n        class x(object):\n            def __array__(self, dtype=None):\n                pass\n        self.assertRaises(ValueError, array, x())\n\n    def test_from_string(self) :\n        types = np.typecodes['AllInteger'] + np.typecodes['Float']\n        nstr = ['123', '123']\n        result = array([123, 123], dtype=int)\n        for type in types :\n            msg = 'String conversion for %s' % type\n            assert_equal(array(nstr, dtype=type), result, err_msg=msg)\n\n    def test_void(self):\n        arr = np.array([], dtype='V')\n        assert_equal(arr.dtype.kind, 'V')\n\n    def test_zeros(self):\n        types = np.typecodes['AllInteger'] + np.typecodes['AllFloat']\n        for dt in types:\n            d = np.zeros((13,), dtype=dt)\n            assert_equal(np.count_nonzero(d), 0)\n            # true for ieee floats\n            assert_equal(d.sum(), 0)\n            assert_(not d.any())\n\n            d = np.zeros(2, dtype='(2,4)i4')\n            assert_equal(np.count_nonzero(d), 0)\n            assert_equal(d.sum(), 0)\n            assert_(not d.any())\n\n            d = np.zeros(2, dtype='4i4')\n            assert_equal(np.count_nonzero(d), 0)\n            assert_equal(d.sum(), 0)\n            assert_(not d.any())\n\n            d = np.zeros(2, dtype='(2,4)i4, (2,4)i4')\n            assert_equal(np.count_nonzero(d), 0)\n\n    @dec.slow\n    def test_zeros_big(self):\n        # test big array as they might be allocated different by the sytem\n        types = np.typecodes['AllInteger'] + np.typecodes['AllFloat']\n        for dt in types:\n            d = np.zeros((30 * 1024**2,), dtype=dt)\n            assert_(not d.any())\n\n    def test_zeros_obj(self):\n        # test initialization from PyLong(0)\n        d = np.zeros((13,), dtype=object)\n        assert_array_equal(d, [0] * 13)\n        assert_equal(np.count_nonzero(d), 0)\n\n    def test_non_sequence_sequence(self):\n        \"\"\"Should not segfault.\n\n        Class Fail breaks the sequence protocol for new style classes, i.e.,\n        those derived from object. Class Map is a mapping type indicated by\n        raising a ValueError. At some point we may raise a warning instead\n        of an error in the Fail case.\n\n        \"\"\"\n        class Fail(object):\n            def __len__(self):\n                return 1\n\n            def __getitem__(self, index):\n                raise ValueError()\n\n        class Map(object):\n            def __len__(self):\n                return 1\n\n            def __getitem__(self, index):\n                raise KeyError()\n\n        a = np.array([Map()])\n        assert_(a.shape == (1,))\n        assert_(a.dtype == np.dtype(object))\n        assert_raises(ValueError, np.array, [Fail()])\n\n\nclass TestStructured(TestCase):\n    def test_subarray_field_access(self):\n        a = np.zeros((3, 5), dtype=[('a', ('i4', (2, 2)))])\n        a['a'] = np.arange(60).reshape(3, 5, 2, 2)\n\n        # Since the subarray is always in C-order, these aren't equal\n        assert_(np.any(a['a'].T != a.T['a']))\n\n        # In Fortran order, the subarray gets appended\n        # like in all other cases, not prepended as a special case\n        b = a.copy(order='F')\n        assert_equal(a['a'].shape, b['a'].shape)\n        assert_equal(a.T['a'].shape, a.T.copy()['a'].shape)\n\n    def test_subarray_comparison(self):\n        # Check that comparisons between record arrays with\n        # multi-dimensional field types work properly\n        a = np.rec.fromrecords(\n            [([1, 2, 3], 'a', [[1, 2], [3, 4]]), ([3, 3, 3], 'b', [[0, 0], [0, 0]])],\n            dtype=[('a', ('f4', 3)), ('b', np.object), ('c', ('i4', (2, 2)))])\n        b = a.copy()\n        assert_equal(a==b, [True, True])\n        assert_equal(a!=b, [False, False])\n        b[1].b = 'c'\n        assert_equal(a==b, [True, False])\n        assert_equal(a!=b, [False, True])\n        for i in range(3):\n            b[0].a = a[0].a\n            b[0].a[i] = 5\n            assert_equal(a==b, [False, False])\n            assert_equal(a!=b, [True, True])\n        for i in range(2):\n            for j in range(2):\n                b = a.copy()\n                b[0].c[i, j] = 10\n                assert_equal(a==b, [False, True])\n                assert_equal(a!=b, [True, False])\n\n        # Check that broadcasting with a subarray works\n        a = np.array([[(0,)], [(1,)]], dtype=[('a', 'f8')])\n        b = np.array([(0,), (0,), (1,)], dtype=[('a', 'f8')])\n        assert_equal(a==b, [[True, True, False], [False, False, True]])\n        assert_equal(b==a, [[True, True, False], [False, False, True]])\n        a = np.array([[(0,)], [(1,)]], dtype=[('a', 'f8', (1,))])\n        b = np.array([(0,), (0,), (1,)], dtype=[('a', 'f8', (1,))])\n        assert_equal(a==b, [[True, True, False], [False, False, True]])\n        assert_equal(b==a, [[True, True, False], [False, False, True]])\n        a = np.array([[([0, 0],)], [([1, 1],)]], dtype=[('a', 'f8', (2,))])\n        b = np.array([([0, 0],), ([0, 1],), ([1, 1],)], dtype=[('a', 'f8', (2,))])\n        assert_equal(a==b, [[True, False, False], [False, False, True]])\n        assert_equal(b==a, [[True, False, False], [False, False, True]])\n\n        # Check that broadcasting Fortran-style arrays with a subarray work\n        a = np.array([[([0, 0],)], [([1, 1],)]], dtype=[('a', 'f8', (2,))], order='F')\n        b = np.array([([0, 0],), ([0, 1],), ([1, 1],)], dtype=[('a', 'f8', (2,))])\n        assert_equal(a==b, [[True, False, False], [False, False, True]])\n        assert_equal(b==a, [[True, False, False], [False, False, True]])\n\n        # Check that incompatible sub-array shapes don't result to broadcasting\n        x = np.zeros((1,), dtype=[('a', ('f4', (1, 2))), ('b', 'i1')])\n        y = np.zeros((1,), dtype=[('a', ('f4', (2,))), ('b', 'i1')])\n        assert_equal(x == y, False)\n\n        x = np.zeros((1,), dtype=[('a', ('f4', (2, 1))), ('b', 'i1')])\n        y = np.zeros((1,), dtype=[('a', ('f4', (2,))), ('b', 'i1')])\n        assert_equal(x == y, False)\n\n\nclass TestBool(TestCase):\n    def test_test_interning(self):\n        a0 = bool_(0)\n        b0 = bool_(False)\n        self.assertTrue(a0 is b0)\n        a1 = bool_(1)\n        b1 = bool_(True)\n        self.assertTrue(a1 is b1)\n        self.assertTrue(array([True])[0] is a1)\n        self.assertTrue(array(True)[()] is a1)\n\n    def test_sum(self):\n        d = np.ones(101, dtype=np.bool);\n        assert_equal(d.sum(), d.size)\n        assert_equal(d[::2].sum(), d[::2].size)\n        assert_equal(d[::-2].sum(), d[::-2].size)\n\n        d = np.frombuffer(b'\\xff\\xff' * 100, dtype=bool)\n        assert_equal(d.sum(), d.size)\n        assert_equal(d[::2].sum(), d[::2].size)\n        assert_equal(d[::-2].sum(), d[::-2].size)\n\n    def check_count_nonzero(self, power, length):\n        powers = [2 ** i for i in range(length)]\n        for i in range(2**power):\n            l = [(i & x) != 0 for x in powers]\n            a = np.array(l, dtype=np.bool)\n            c = builtins.sum(l)\n            self.assertEqual(np.count_nonzero(a), c)\n            av = a.view(np.uint8)\n            av *= 3\n            self.assertEqual(np.count_nonzero(a), c)\n            av *= 4\n            self.assertEqual(np.count_nonzero(a), c)\n            av[av != 0] = 0xFF\n            self.assertEqual(np.count_nonzero(a), c)\n\n    def test_count_nonzero(self):\n        # check all 12 bit combinations in a length 17 array\n        # covers most cases of the 16 byte unrolled code\n        self.check_count_nonzero(12, 17)\n\n    @dec.slow\n    def test_count_nonzero_all(self):\n        # check all combinations in a length 17 array\n        # covers all cases of the 16 byte unrolled code\n        self.check_count_nonzero(17, 17)\n\n    def test_count_nonzero_unaligned(self):\n        # prevent mistakes as e.g. gh-4060\n        for o in range(7):\n            a = np.zeros((18,), dtype=np.bool)[o+1:]\n            a[:o] = True\n            self.assertEqual(np.count_nonzero(a), builtins.sum(a.tolist()))\n            a = np.ones((18,), dtype=np.bool)[o+1:]\n            a[:o] = False\n            self.assertEqual(np.count_nonzero(a), builtins.sum(a.tolist()))\n\nclass TestMethods(TestCase):\n    def test_test_round(self):\n        assert_equal(array([1.2, 1.5]).round(), [1, 2])\n        assert_equal(array(1.5).round(), 2)\n        assert_equal(array([12.2, 15.5]).round(-1), [10, 20])\n        assert_equal(array([12.15, 15.51]).round(1), [12.2, 15.5])\n\n    def test_transpose(self):\n        a = array([[1, 2], [3, 4]])\n        assert_equal(a.transpose(), [[1, 3], [2, 4]])\n        self.assertRaises(ValueError, lambda: a.transpose(0))\n        self.assertRaises(ValueError, lambda: a.transpose(0, 0))\n        self.assertRaises(ValueError, lambda: a.transpose(0, 1, 2))\n\n    def test_sort(self):\n        # test ordering for floats and complex containing nans. It is only\n        # necessary to check the lessthan comparison, so sorts that\n        # only follow the insertion sort path are sufficient. We only\n        # test doubles and complex doubles as the logic is the same.\n\n        # check doubles\n        msg = \"Test real sort order with nans\"\n        a = np.array([np.nan, 1, 0])\n        b = sort(a)\n        assert_equal(b, a[::-1], msg)\n        # check complex\n        msg = \"Test complex sort order with nans\"\n        a = np.zeros(9, dtype=np.complex128)\n        a.real += [np.nan, np.nan, np.nan, 1, 0, 1, 1, 0, 0]\n        a.imag += [np.nan, 1, 0, np.nan, np.nan, 1, 0, 1, 0]\n        b = sort(a)\n        assert_equal(b, a[::-1], msg)\n\n        # all c scalar sorts use the same code with different types\n        # so it suffices to run a quick check with one type. The number\n        # of sorted items must be greater than ~50 to check the actual\n        # algorithm because quick and merge sort fall over to insertion\n        # sort for small arrays.\n        a = np.arange(101)\n        b = a[::-1].copy()\n        for kind in ['q', 'm', 'h'] :\n            msg = \"scalar sort, kind=%s\" % kind\n            c = a.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n            c = b.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n\n        # test complex sorts. These use the same code as the scalars\n        # but the compare fuction differs.\n        ai = a*1j + 1\n        bi = b*1j + 1\n        for kind in ['q', 'm', 'h'] :\n            msg = \"complex sort, real part == 1, kind=%s\" % kind\n            c = ai.copy();\n            c.sort(kind=kind)\n            assert_equal(c, ai, msg)\n            c = bi.copy();\n            c.sort(kind=kind)\n            assert_equal(c, ai, msg)\n        ai = a + 1j\n        bi = b + 1j\n        for kind in ['q', 'm', 'h'] :\n            msg = \"complex sort, imag part == 1, kind=%s\" % kind\n            c = ai.copy();\n            c.sort(kind=kind)\n            assert_equal(c, ai, msg)\n            c = bi.copy();\n            c.sort(kind=kind)\n            assert_equal(c, ai, msg)\n\n        # test string sorts.\n        s = 'aaaaaaaa'\n        a = np.array([s + chr(i) for i in range(101)])\n        b = a[::-1].copy()\n        for kind in ['q', 'm', 'h'] :\n            msg = \"string sort, kind=%s\" % kind\n            c = a.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n            c = b.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n\n        # test unicode sorts.\n        s = 'aaaaaaaa'\n        a = np.array([s + chr(i) for i in range(101)], dtype=np.unicode)\n        b = a[::-1].copy()\n        for kind in ['q', 'm', 'h'] :\n            msg = \"unicode sort, kind=%s\" % kind\n            c = a.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n            c = b.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n\n        # test object array sorts.\n        a = np.empty((101,), dtype=np.object)\n        a[:] = list(range(101))\n        b = a[::-1]\n        for kind in ['q', 'h', 'm'] :\n            msg = \"object sort, kind=%s\" % kind\n            c = a.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n            c = b.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n\n        # test record array sorts.\n        dt = np.dtype([('f', float), ('i', int)])\n        a = array([(i, i) for i in range(101)], dtype = dt)\n        b = a[::-1]\n        for kind in ['q', 'h', 'm'] :\n            msg = \"object sort, kind=%s\" % kind\n            c = a.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n            c = b.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n\n        # test datetime64 sorts.\n        a = np.arange(0, 101, dtype='datetime64[D]')\n        b = a[::-1]\n        for kind in ['q', 'h', 'm'] :\n            msg = \"datetime64 sort, kind=%s\" % kind\n            c = a.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n            c = b.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n\n        # test timedelta64 sorts.\n        a = np.arange(0, 101, dtype='timedelta64[D]')\n        b = a[::-1]\n        for kind in ['q', 'h', 'm'] :\n            msg = \"timedelta64 sort, kind=%s\" % kind\n            c = a.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n            c = b.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n\n        # check axis handling. This should be the same for all type\n        # specific sorts, so we only check it for one type and one kind\n        a = np.array([[3, 2], [1, 0]])\n        b = np.array([[1, 0], [3, 2]])\n        c = np.array([[2, 3], [0, 1]])\n        d = a.copy()\n        d.sort(axis=0)\n        assert_equal(d, b, \"test sort with axis=0\")\n        d = a.copy()\n        d.sort(axis=1)\n        assert_equal(d, c, \"test sort with axis=1\")\n        d = a.copy()\n        d.sort()\n        assert_equal(d, c, \"test sort with default axis\")\n\n    def test_copy(self):\n        def assert_fortran(arr):\n            assert_(arr.flags.fortran)\n            assert_(arr.flags.f_contiguous)\n            assert_(not arr.flags.c_contiguous)\n\n        def assert_c(arr):\n            assert_(not arr.flags.fortran)\n            assert_(not arr.flags.f_contiguous)\n            assert_(arr.flags.c_contiguous)\n\n        a = np.empty((2, 2), order='F')\n        # Test copying a Fortran array\n        assert_c(a.copy())\n        assert_c(a.copy('C'))\n        assert_fortran(a.copy('F'))\n        assert_fortran(a.copy('A'))\n\n        # Now test starting with a C array.\n        a = np.empty((2, 2), order='C')\n        assert_c(a.copy())\n        assert_c(a.copy('C'))\n        assert_fortran(a.copy('F'))\n        assert_c(a.copy('A'))\n\n    def test_sort_order(self):\n        # Test sorting an array with fields\n        x1=np.array([21, 32, 14])\n        x2=np.array(['my', 'first', 'name'])\n        x3=np.array([3.1, 4.5, 6.2])\n        r=np.rec.fromarrays([x1, x2, x3], names='id,word,number')\n\n        r.sort(order=['id'])\n        assert_equal(r.id, array([14, 21, 32]))\n        assert_equal(r.word, array(['name', 'my', 'first']))\n        assert_equal(r.number, array([6.2, 3.1, 4.5]))\n\n        r.sort(order=['word'])\n        assert_equal(r.id, array([32, 21, 14]))\n        assert_equal(r.word, array(['first', 'my', 'name']))\n        assert_equal(r.number, array([4.5, 3.1, 6.2]))\n\n        r.sort(order=['number'])\n        assert_equal(r.id, array([21, 32, 14]))\n        assert_equal(r.word, array(['my', 'first', 'name']))\n        assert_equal(r.number, array([3.1, 4.5, 6.2]))\n\n        if sys.byteorder == 'little':\n            strtype = '>i2'\n        else:\n            strtype = '<i2'\n        mydtype = [('name', strchar + '5'), ('col2', strtype)]\n        r = np.array([('a', 1), ('b', 255), ('c', 3), ('d', 258)],\n                     dtype= mydtype)\n        r.sort(order='col2')\n        assert_equal(r['col2'], [1, 3, 255, 258])\n        assert_equal(r, np.array([('a', 1), ('c', 3), ('b', 255), ('d', 258)],\n                                 dtype=mydtype))\n\n    def test_argsort(self):\n        # all c scalar argsorts use the same code with different types\n        # so it suffices to run a quick check with one type. The number\n        # of sorted items must be greater than ~50 to check the actual\n        # algorithm because quick and merge sort fall over to insertion\n        # sort for small arrays.\n        a = np.arange(101)\n        b = a[::-1].copy()\n        for kind in ['q', 'm', 'h'] :\n            msg = \"scalar argsort, kind=%s\" % kind\n            assert_equal(a.copy().argsort(kind=kind), a, msg)\n            assert_equal(b.copy().argsort(kind=kind), b, msg)\n\n        # test complex argsorts. These use the same code as the scalars\n        # but the compare fuction differs.\n        ai = a*1j + 1\n        bi = b*1j + 1\n        for kind in ['q', 'm', 'h'] :\n            msg = \"complex argsort, kind=%s\" % kind\n            assert_equal(ai.copy().argsort(kind=kind), a, msg)\n            assert_equal(bi.copy().argsort(kind=kind), b, msg)\n        ai = a + 1j\n        bi = b + 1j\n        for kind in ['q', 'm', 'h'] :\n            msg = \"complex argsort, kind=%s\" % kind\n            assert_equal(ai.copy().argsort(kind=kind), a, msg)\n            assert_equal(bi.copy().argsort(kind=kind), b, msg)\n\n        # test string argsorts.\n        s = 'aaaaaaaa'\n        a = np.array([s + chr(i) for i in range(101)])\n        b = a[::-1].copy()\n        r = np.arange(101)\n        rr = r[::-1]\n        for kind in ['q', 'm', 'h'] :\n            msg = \"string argsort, kind=%s\" % kind\n            assert_equal(a.copy().argsort(kind=kind), r, msg)\n            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n\n        # test unicode argsorts.\n        s = 'aaaaaaaa'\n        a = np.array([s + chr(i) for i in range(101)], dtype=np.unicode)\n        b = a[::-1]\n        r = np.arange(101)\n        rr = r[::-1]\n        for kind in ['q', 'm', 'h'] :\n            msg = \"unicode argsort, kind=%s\" % kind\n            assert_equal(a.copy().argsort(kind=kind), r, msg)\n            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n\n        # test object array argsorts.\n        a = np.empty((101,), dtype=np.object)\n        a[:] = list(range(101))\n        b = a[::-1]\n        r = np.arange(101)\n        rr = r[::-1]\n        for kind in ['q', 'm', 'h'] :\n            msg = \"object argsort, kind=%s\" % kind\n            assert_equal(a.copy().argsort(kind=kind), r, msg)\n            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n\n        # test structured array argsorts.\n        dt = np.dtype([('f', float), ('i', int)])\n        a = array([(i, i) for i in range(101)], dtype = dt)\n        b = a[::-1]\n        r = np.arange(101)\n        rr = r[::-1]\n        for kind in ['q', 'm', 'h'] :\n            msg = \"structured array argsort, kind=%s\" % kind\n            assert_equal(a.copy().argsort(kind=kind), r, msg)\n            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n\n        # test datetime64 argsorts.\n        a = np.arange(0, 101, dtype='datetime64[D]')\n        b = a[::-1]\n        r = np.arange(101)\n        rr = r[::-1]\n        for kind in ['q', 'h', 'm'] :\n            msg = \"datetime64 argsort, kind=%s\" % kind\n            assert_equal(a.copy().argsort(kind=kind), r, msg)\n            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n\n        # test timedelta64 argsorts.\n        a = np.arange(0, 101, dtype='timedelta64[D]')\n        b = a[::-1]\n        r = np.arange(101)\n        rr = r[::-1]\n        for kind in ['q', 'h', 'm'] :\n            msg = \"timedelta64 argsort, kind=%s\" % kind\n            assert_equal(a.copy().argsort(kind=kind), r, msg)\n            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n\n\n        # check axis handling. This should be the same for all type\n        # specific argsorts, so we only check it for one type and one kind\n        a = np.array([[3, 2], [1, 0]])\n        b = np.array([[1, 1], [0, 0]])\n        c = np.array([[1, 0], [1, 0]])\n        assert_equal(a.copy().argsort(axis=0), b)\n        assert_equal(a.copy().argsort(axis=1), c)\n        assert_equal(a.copy().argsort(), c)\n        # using None is known fail at this point\n        #assert_equal(a.copy().argsort(axis=None, c)\n\n        # check that stable argsorts are stable\n        r = np.arange(100)\n        # scalars\n        a = np.zeros(100)\n        assert_equal(a.argsort(kind='m'), r)\n        # complex\n        a = np.zeros(100, dtype=np.complex)\n        assert_equal(a.argsort(kind='m'), r)\n        # string\n        a = np.array(['aaaaaaaaa' for i in range(100)])\n        assert_equal(a.argsort(kind='m'), r)\n        # unicode\n        a = np.array(['aaaaaaaaa' for i in range(100)], dtype=np.unicode)\n        assert_equal(a.argsort(kind='m'), r)\n\n    def test_searchsorted(self):\n        # test for floats and complex containing nans. The logic is the\n        # same for all float types so only test double types for now.\n        # The search sorted routines use the compare functions for the\n        # array type, so this checks if that is consistent with the sort\n        # order.\n\n        # check double\n        a = np.array([0, 1, np.nan])\n        msg = \"Test real searchsorted with nans, side='l'\"\n        b = a.searchsorted(a, side='l')\n        assert_equal(b, np.arange(3), msg)\n        msg = \"Test real searchsorted with nans, side='r'\"\n        b = a.searchsorted(a, side='r')\n        assert_equal(b, np.arange(1, 4), msg)\n        # check double complex\n        a = np.zeros(9, dtype=np.complex128)\n        a.real += [0, 0, 1, 1, 0, 1, np.nan, np.nan, np.nan]\n        a.imag += [0, 1, 0, 1, np.nan, np.nan, 0, 1, np.nan]\n        msg = \"Test complex searchsorted with nans, side='l'\"\n        b = a.searchsorted(a, side='l')\n        assert_equal(b, np.arange(9), msg)\n        msg = \"Test complex searchsorted with nans, side='r'\"\n        b = a.searchsorted(a, side='r')\n        assert_equal(b, np.arange(1, 10), msg)\n        msg = \"Test searchsorted with little endian, side='l'\"\n        a = np.array([0, 128], dtype='<i4')\n        b = a.searchsorted(np.array(128, dtype='<i4'))\n        assert_equal(b, 1, msg)\n        msg = \"Test searchsorted with big endian, side='l'\"\n        a = np.array([0, 128], dtype='>i4')\n        b = a.searchsorted(np.array(128, dtype='>i4'))\n        assert_equal(b, 1, msg)\n\n        # Check 0 elements\n        a = np.ones(0)\n        b = a.searchsorted([0, 1, 2], 'l')\n        assert_equal(b, [0, 0, 0])\n        b = a.searchsorted([0, 1, 2], 'r')\n        assert_equal(b, [0, 0, 0])\n        a = np.ones(1)\n        # Check 1 element\n        b = a.searchsorted([0, 1, 2], 'l')\n        assert_equal(b, [0, 0, 1])\n        b = a.searchsorted([0, 1, 2], 'r')\n        assert_equal(b, [0, 1, 1])\n        # Check all elements equal\n        a = np.ones(2)\n        b = a.searchsorted([0, 1, 2], 'l')\n        assert_equal(b, [0, 0, 2])\n        b = a.searchsorted([0, 1, 2], 'r')\n        assert_equal(b, [0, 2, 2])\n\n        # Test searching unaligned array\n        a = np.arange(10)\n        aligned = np.empty(a.itemsize * a.size + 1, 'uint8')\n        unaligned = aligned[1:].view(a.dtype)\n        unaligned[:] = a\n        # Test searching unaligned array\n        b = unaligned.searchsorted(a, 'l')\n        assert_equal(b, a)\n        b = unaligned.searchsorted(a, 'r')\n        assert_equal(b, a + 1)\n        # Test searching for unaligned keys\n        b = a.searchsorted(unaligned, 'l')\n        assert_equal(b, a)\n        b = a.searchsorted(unaligned, 'r')\n        assert_equal(b, a + 1)\n\n    def test_searchsorted_unicode(self):\n        # Test searchsorted on unicode strings.\n\n        # 1.6.1 contained a string length miscalculation in\n        # arraytypes.c.src:UNICODE_compare() which manifested as\n        # incorrect/inconsistent results from searchsorted.\n        a = np.array(['P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100185_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100186_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100187_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100189_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100190_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100191_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100192_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100193_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100194_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100195_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100196_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100197_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100198_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100199_1'],\n                      dtype=np.unicode)\n        ind = np.arange(len(a))\n        assert_equal([a.searchsorted(v, 'left') for v in a], ind)\n        assert_equal([a.searchsorted(v, 'right') for v in a], ind + 1)\n        assert_equal([a.searchsorted(a[i], 'left') for i in ind], ind)\n        assert_equal([a.searchsorted(a[i], 'right') for i in ind], ind + 1)\n\n    def test_searchsorted_with_sorter(self):\n        a = np.array([5, 2, 1, 3, 4])\n        s = np.argsort(a)\n        assert_raises(TypeError, np.searchsorted, a, 0, sorter=(1, (2, 3)))\n        assert_raises(TypeError, np.searchsorted, a, 0, sorter=[1.1])\n        assert_raises(ValueError, np.searchsorted, a, 0, sorter=[1, 2, 3, 4])\n        assert_raises(ValueError, np.searchsorted, a, 0, sorter=[1, 2, 3, 4, 5, 6])\n\n        # bounds check\n        assert_raises(ValueError, np.searchsorted, a, 4, sorter=[0, 1, 2, 3, 5])\n        assert_raises(ValueError, np.searchsorted, a, 0, sorter=[-1, 0, 1, 2, 3])\n        assert_raises(ValueError, np.searchsorted, a, 0, sorter=[4, 0, -1, 2, 3])\n\n        a = np.random.rand(300)\n        s = a.argsort()\n        b = np.sort(a)\n        k = np.linspace(0, 1, 20)\n        assert_equal(b.searchsorted(k), a.searchsorted(k, sorter=s))\n\n        a = np.array([0, 1, 2, 3, 5]*20)\n        s = a.argsort()\n        k = [0, 1, 2, 3, 5]\n        expected = [0, 20, 40, 60, 80]\n        assert_equal(a.searchsorted(k, side='l', sorter=s), expected)\n        expected = [20, 40, 60, 80, 100]\n        assert_equal(a.searchsorted(k, side='r', sorter=s), expected)\n\n        # Test searching unaligned array\n        keys = np.arange(10)\n        a = keys.copy()\n        np.random.shuffle(s)\n        s = a.argsort()\n        aligned = np.empty(a.itemsize * a.size + 1, 'uint8')\n        unaligned = aligned[1:].view(a.dtype)\n        # Test searching unaligned array\n        unaligned[:] = a\n        b = unaligned.searchsorted(keys, 'l', s)\n        assert_equal(b, keys)\n        b = unaligned.searchsorted(keys, 'r', s)\n        assert_equal(b, keys + 1)\n        # Test searching for unaligned keys\n        unaligned[:] = keys\n        b = a.searchsorted(unaligned, 'l', s)\n        assert_equal(b, keys)\n        b = a.searchsorted(unaligned, 'r', s)\n        assert_equal(b, keys + 1)\n\n\n    def test_partition(self):\n        d = np.arange(10)\n        assert_raises(TypeError, np.partition, d, 2, kind=1)\n        assert_raises(ValueError, np.partition, d, 2, kind=\"nonsense\")\n        assert_raises(ValueError, np.argpartition, d, 2, kind=\"nonsense\")\n        assert_raises(ValueError, d.partition, 2, axis=0, kind=\"nonsense\")\n        assert_raises(ValueError, d.argpartition, 2, axis=0, kind=\"nonsense\")\n        for k in (\"introselect\",):\n            d = np.array([])\n            assert_array_equal(np.partition(d, 0, kind=k), d)\n            assert_array_equal(np.argpartition(d, 0, kind=k), d)\n            d = np.ones((1))\n            assert_array_equal(np.partition(d, 0, kind=k)[0], d)\n            assert_array_equal(d[np.argpartition(d, 0, kind=k)],\n                               np.partition(d, 0, kind=k))\n\n            # kth not modified\n            kth = np.array([30, 15, 5])\n            okth = kth.copy()\n            np.partition(np.arange(40), kth)\n            assert_array_equal(kth, okth)\n\n            for r in ([2, 1], [1, 2], [1, 1]):\n                d = np.array(r)\n                tgt = np.sort(d)\n                assert_array_equal(np.partition(d, 0, kind=k)[0], tgt[0])\n                assert_array_equal(np.partition(d, 1, kind=k)[1], tgt[1])\n                assert_array_equal(d[np.argpartition(d, 0, kind=k)],\n                                   np.partition(d, 0, kind=k))\n                assert_array_equal(d[np.argpartition(d, 1, kind=k)],\n                                   np.partition(d, 1, kind=k))\n                for i in range(d.size):\n                    d[i:].partition(0, kind=k)\n                assert_array_equal(d, tgt)\n\n            for r in ([3, 2, 1], [1, 2, 3], [2, 1, 3], [2, 3, 1],\n                      [1, 1, 1], [1, 2, 2], [2, 2, 1], [1, 2, 1]):\n                d = np.array(r)\n                tgt = np.sort(d)\n                assert_array_equal(np.partition(d, 0, kind=k)[0], tgt[0])\n                assert_array_equal(np.partition(d, 1, kind=k)[1], tgt[1])\n                assert_array_equal(np.partition(d, 2, kind=k)[2], tgt[2])\n                assert_array_equal(d[np.argpartition(d, 0, kind=k)],\n                                   np.partition(d, 0, kind=k))\n                assert_array_equal(d[np.argpartition(d, 1, kind=k)],\n                                   np.partition(d, 1, kind=k))\n                assert_array_equal(d[np.argpartition(d, 2, kind=k)],\n                                   np.partition(d, 2, kind=k))\n                for i in range(d.size):\n                    d[i:].partition(0, kind=k)\n                assert_array_equal(d, tgt)\n\n            d = np.ones((50))\n            assert_array_equal(np.partition(d, 0, kind=k), d)\n            assert_array_equal(d[np.argpartition(d, 0, kind=k)],\n                               np.partition(d, 0, kind=k))\n\n            # sorted\n            d = np.arange((49))\n            self.assertEqual(np.partition(d, 5, kind=k)[5], 5)\n            self.assertEqual(np.partition(d, 15, kind=k)[15], 15)\n            assert_array_equal(d[np.argpartition(d, 5, kind=k)],\n                               np.partition(d, 5, kind=k))\n            assert_array_equal(d[np.argpartition(d, 15, kind=k)],\n                               np.partition(d, 15, kind=k))\n\n            # rsorted\n            d = np.arange((47))[::-1]\n            self.assertEqual(np.partition(d, 6, kind=k)[6], 6)\n            self.assertEqual(np.partition(d, 16, kind=k)[16], 16)\n            assert_array_equal(d[np.argpartition(d, 6, kind=k)],\n                               np.partition(d, 6, kind=k))\n            assert_array_equal(d[np.argpartition(d, 16, kind=k)],\n                               np.partition(d, 16, kind=k))\n\n            assert_array_equal(np.partition(d, -6, kind=k),\n                               np.partition(d, 41, kind=k))\n            assert_array_equal(np.partition(d, -16, kind=k),\n                               np.partition(d, 31, kind=k))\n            assert_array_equal(d[np.argpartition(d, -6, kind=k)],\n                               np.partition(d, 41, kind=k))\n\n            # median of 3 killer, O(n^2) on pure median 3 pivot quickselect\n            # exercises the median of median of 5 code used to keep O(n)\n            d = np.arange(1000000)\n            x = np.roll(d, d.size // 2)\n            mid = x.size // 2 + 1\n            assert_equal(np.partition(x, mid)[mid], mid)\n            d = np.arange(1000001)\n            x = np.roll(d, d.size // 2 + 1)\n            mid = x.size // 2 + 1\n            assert_equal(np.partition(x, mid)[mid], mid)\n\n            # equal elements\n            d = np.arange((47)) % 7\n            tgt = np.sort(np.arange((47)) % 7)\n            np.random.shuffle(d)\n            for i in range(d.size):\n                self.assertEqual(np.partition(d, i, kind=k)[i], tgt[i])\n            assert_array_equal(d[np.argpartition(d, 6, kind=k)],\n                               np.partition(d, 6, kind=k))\n            assert_array_equal(d[np.argpartition(d, 16, kind=k)],\n                               np.partition(d, 16, kind=k))\n            for i in range(d.size):\n                d[i:].partition(0, kind=k)\n            assert_array_equal(d, tgt)\n\n            d = np.array([2, 1])\n            d.partition(0, kind=k)\n            assert_raises(ValueError, d.partition, 2)\n            assert_raises(ValueError, d.partition, 3, axis=1)\n            assert_raises(ValueError, np.partition, d, 2)\n            assert_raises(ValueError, np.partition, d, 2, axis=1)\n            assert_raises(ValueError, d.argpartition, 2)\n            assert_raises(ValueError, d.argpartition, 3, axis=1)\n            assert_raises(ValueError, np.argpartition, d, 2)\n            assert_raises(ValueError, np.argpartition, d, 2, axis=1)\n            d = np.arange(10).reshape((2, 5))\n            d.partition(1, axis=0, kind=k)\n            d.partition(4, axis=1, kind=k)\n            np.partition(d, 1, axis=0, kind=k)\n            np.partition(d, 4, axis=1, kind=k)\n            np.partition(d, 1, axis=None, kind=k)\n            np.partition(d, 9, axis=None, kind=k)\n            d.argpartition(1, axis=0, kind=k)\n            d.argpartition(4, axis=1, kind=k)\n            np.argpartition(d, 1, axis=0, kind=k)\n            np.argpartition(d, 4, axis=1, kind=k)\n            np.argpartition(d, 1, axis=None, kind=k)\n            np.argpartition(d, 9, axis=None, kind=k)\n            assert_raises(ValueError, d.partition, 2, axis=0)\n            assert_raises(ValueError, d.partition, 11, axis=1)\n            assert_raises(TypeError, d.partition, 2, axis=None)\n            assert_raises(ValueError, np.partition, d, 9, axis=1)\n            assert_raises(ValueError, np.partition, d, 11, axis=None)\n            assert_raises(ValueError, d.argpartition, 2, axis=0)\n            assert_raises(ValueError, d.argpartition, 11, axis=1)\n            assert_raises(ValueError, np.argpartition, d, 9, axis=1)\n            assert_raises(ValueError, np.argpartition, d, 11, axis=None)\n\n            td = [(dt, s) for dt in [np.int32, np.float32, np.complex64]\n                          for s in (9, 16)]\n            for dt, s in td:\n                aae = assert_array_equal\n                at = self.assertTrue\n\n                d = np.arange(s, dtype=dt)\n                np.random.shuffle(d)\n                d1 = np.tile(np.arange(s, dtype=dt), (4, 1))\n                map(np.random.shuffle, d1)\n                d0 = np.transpose(d1)\n                for i in range(d.size):\n                    p = np.partition(d, i, kind=k)\n                    self.assertEqual(p[i], i)\n                    # all before are smaller\n                    assert_array_less(p[:i], p[i])\n                    # all after are larger\n                    assert_array_less(p[i], p[i + 1:])\n                    aae(p, d[np.argpartition(d, i, kind=k)])\n\n                    p = np.partition(d1, i, axis=1, kind=k)\n                    aae(p[:, i], np.array([i] * d1.shape[0], dtype=dt))\n                    # array_less does not seem to work right\n                    at((p[:, :i].T <= p[:, i]).all(),\n                       msg=\"%d: %r <= %r\" % (i, p[:, i], p[:, :i].T))\n                    at((p[:, i + 1:].T > p[:, i]).all(),\n                       msg=\"%d: %r < %r\" % (i, p[:, i], p[:, i + 1:].T))\n                    aae(p, d1[np.arange(d1.shape[0])[:, None],\n                        np.argpartition(d1, i, axis=1, kind=k)])\n\n                    p = np.partition(d0, i, axis=0, kind=k)\n                    aae(p[i,:], np.array([i] * d1.shape[0],\n                                                         dtype=dt))\n                    # array_less does not seem to work right\n                    at((p[:i,:] <= p[i,:]).all(),\n                       msg=\"%d: %r <= %r\" % (i, p[i,:], p[:i,:]))\n                    at((p[i + 1:,:] > p[i,:]).all(),\n                       msg=\"%d: %r < %r\" % (i, p[i,:], p[:, i + 1:]))\n                    aae(p, d0[np.argpartition(d0, i, axis=0, kind=k),\n                        np.arange(d0.shape[1])[None,:]])\n\n                    # check inplace\n                    dc = d.copy()\n                    dc.partition(i, kind=k)\n                    assert_equal(dc, np.partition(d, i, kind=k))\n                    dc = d0.copy()\n                    dc.partition(i, axis=0, kind=k)\n                    assert_equal(dc, np.partition(d0, i, axis=0, kind=k))\n                    dc = d1.copy()\n                    dc.partition(i, axis=1, kind=k)\n                    assert_equal(dc, np.partition(d1, i, axis=1, kind=k))\n\n\n    def assert_partitioned(self, d, kth):\n        prev = 0\n        for k in np.sort(kth):\n            assert_array_less(d[prev:k], d[k], err_msg='kth %d' % k)\n            assert_((d[k:] >= d[k]).all(),\n                    msg=\"kth %d, %r not greater equal %d\" % (k, d[k:], d[k]))\n            prev = k + 1\n\n\n    def test_partition_iterative(self):\n            d = np.arange(17)\n            kth = (0, 1, 2, 429, 231)\n            assert_raises(ValueError, d.partition, kth)\n            assert_raises(ValueError, d.argpartition, kth)\n            d = np.arange(10).reshape((2, 5))\n            assert_raises(ValueError, d.partition, kth, axis=0)\n            assert_raises(ValueError, d.partition, kth, axis=1)\n            assert_raises(ValueError, np.partition, d, kth, axis=1)\n            assert_raises(ValueError, np.partition, d, kth, axis=None)\n\n            d = np.array([3, 4, 2, 1])\n            p = np.partition(d, (0, 3))\n            self.assert_partitioned(p, (0, 3))\n            self.assert_partitioned(d[np.argpartition(d, (0, 3))], (0, 3))\n\n            assert_array_equal(p, np.partition(d, (-3, -1)))\n            assert_array_equal(p, d[np.argpartition(d, (-3, -1))])\n\n            d = np.arange(17)\n            np.random.shuffle(d)\n            d.partition(range(d.size))\n            assert_array_equal(np.arange(17), d)\n            np.random.shuffle(d)\n            assert_array_equal(np.arange(17), d[d.argpartition(range(d.size))])\n\n            # test unsorted kth\n            d = np.arange(17)\n            np.random.shuffle(d)\n            keys = np.array([1, 3, 8, -2])\n            np.random.shuffle(d)\n            p = np.partition(d, keys)\n            self.assert_partitioned(p, keys)\n            p = d[np.argpartition(d, keys)]\n            self.assert_partitioned(p, keys)\n            np.random.shuffle(keys)\n            assert_array_equal(np.partition(d, keys), p)\n            assert_array_equal(d[np.argpartition(d, keys)], p)\n\n            # equal kth\n            d = np.arange(20)[::-1]\n            self.assert_partitioned(np.partition(d, [5]*4), [5])\n            self.assert_partitioned(np.partition(d, [5]*4 + [6, 13]),\n                                    [5]*4 + [6, 13])\n            self.assert_partitioned(d[np.argpartition(d, [5]*4)], [5])\n            self.assert_partitioned(d[np.argpartition(d, [5]*4 + [6, 13])],\n                                    [5]*4 + [6, 13])\n\n            d = np.arange(12)\n            np.random.shuffle(d)\n            d1 = np.tile(np.arange(12), (4, 1))\n            map(np.random.shuffle, d1)\n            d0 = np.transpose(d1)\n\n            kth = (1, 6, 7, -1)\n            p = np.partition(d1, kth, axis=1)\n            pa = d1[np.arange(d1.shape[0])[:, None],\n                    d1.argpartition(kth, axis=1)]\n            assert_array_equal(p, pa)\n            for i in range(d1.shape[0]):\n                self.assert_partitioned(p[i,:], kth)\n            p = np.partition(d0, kth, axis=0)\n            pa = d0[np.argpartition(d0, kth, axis=0),\n                    np.arange(d0.shape[1])[None,:]]\n            assert_array_equal(p, pa)\n            for i in range(d0.shape[1]):\n                self.assert_partitioned(p[:, i], kth)\n\n\n    def test_partition_cdtype(self):\n        d = array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),\n                   ('Lancelot', 1.9, 38)],\n                  dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])\n\n        tgt = np.sort(d, order=['age', 'height'])\n        assert_array_equal(np.partition(d, range(d.size),\n                                        order=['age', 'height']),\n                           tgt)\n        assert_array_equal(d[np.argpartition(d, range(d.size),\n                                             order=['age', 'height'])],\n                           tgt)\n        for k in range(d.size):\n            assert_equal(np.partition(d, k, order=['age', 'height'])[k],\n                        tgt[k])\n            assert_equal(d[np.argpartition(d, k, order=['age', 'height'])][k],\n                         tgt[k])\n\n        d = array(['Galahad', 'Arthur', 'zebra', 'Lancelot'])\n        tgt = np.sort(d)\n        assert_array_equal(np.partition(d, range(d.size)), tgt)\n        for k in range(d.size):\n            assert_equal(np.partition(d, k)[k], tgt[k])\n            assert_equal(d[np.argpartition(d, k)][k], tgt[k])\n\n\n    def test_flatten(self):\n        x0 = np.array([[1, 2, 3], [4, 5, 6]], np.int32)\n        x1 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]], np.int32)\n        y0 = np.array([1, 2, 3, 4, 5, 6], np.int32)\n        y0f = np.array([1, 4, 2, 5, 3, 6], np.int32)\n        y1 = np.array([1, 2, 3, 4, 5, 6, 7, 8], np.int32)\n        y1f = np.array([1, 5, 3, 7, 2, 6, 4, 8], np.int32)\n        assert_equal(x0.flatten(), y0)\n        assert_equal(x0.flatten('F'), y0f)\n        assert_equal(x0.flatten('F'), x0.T.flatten())\n        assert_equal(x1.flatten(), y1)\n        assert_equal(x1.flatten('F'), y1f)\n        assert_equal(x1.flatten('F'), x1.T.flatten())\n\n    def test_dot(self):\n        a = np.array([[1, 0], [0, 1]])\n        b = np.array([[0, 1], [1, 0]])\n        c = np.array([[9, 1], [1, -9]])\n\n        assert_equal(np.dot(a, b), a.dot(b))\n        assert_equal(np.dot(np.dot(a, b), c), a.dot(b).dot(c))\n\n        # test passing in an output array\n        c = np.zeros_like(a)\n        a.dot(b, c)\n        assert_equal(c, np.dot(a, b))\n\n        # test keyword args\n        c = np.zeros_like(a)\n        a.dot(b=b, out=c)\n        assert_equal(c, np.dot(a, b))\n\n    def test_dot_override(self):\n        class A(object):\n            def __numpy_ufunc__(self, ufunc, method, pos, inputs, **kwargs):\n                return \"A\"\n\n        class B(object):\n            def __numpy_ufunc__(self, ufunc, method, pos, inputs, **kwargs):\n                return NotImplemented\n\n        a = A()\n        b = B()\n        c = np.array([[1]])\n\n        assert_equal(np.dot(a, b), \"A\")\n        assert_equal(c.dot(a), \"A\")\n        assert_raises(TypeError, np.dot, b, c)\n        assert_raises(TypeError, c.dot, b)\n\n    def test_diagonal(self):\n        a = np.arange(12).reshape((3, 4))\n        assert_equal(a.diagonal(), [0, 5, 10])\n        assert_equal(a.diagonal(0), [0, 5, 10])\n        assert_equal(a.diagonal(1), [1, 6, 11])\n        assert_equal(a.diagonal(-1), [4, 9])\n\n        b = np.arange(8).reshape((2, 2, 2))\n        assert_equal(b.diagonal(), [[0, 6], [1, 7]])\n        assert_equal(b.diagonal(0), [[0, 6], [1, 7]])\n        assert_equal(b.diagonal(1), [[2], [3]])\n        assert_equal(b.diagonal(-1), [[4], [5]])\n        assert_raises(ValueError, b.diagonal, axis1=0, axis2=0)\n        assert_equal(b.diagonal(0, 1, 2), [[0, 3], [4, 7]])\n        assert_equal(b.diagonal(0, 0, 1), [[0, 6], [1, 7]])\n        assert_equal(b.diagonal(offset=1, axis1=0, axis2=2), [[1], [3]])\n        # Order of axis argument doesn't matter:\n        assert_equal(b.diagonal(0, 2, 1), [[0, 3], [4, 7]])\n\n    def test_diagonal_view_notwriteable(self):\n        # this test is only for 1.9, the diagonal view will be\n        # writeable in 1.10.\n        a = np.eye(3).diagonal()\n        assert_(not a.flags.writeable)\n        assert_(not a.flags.owndata)\n\n        a = np.diagonal(np.eye(3))\n        assert_(not a.flags.writeable)\n        assert_(not a.flags.owndata)\n\n        a = np.diag(np.eye(3))\n        assert_(not a.flags.writeable)\n        assert_(not a.flags.owndata)\n\n    def test_diagonal_memleak(self):\n        # Regression test for a bug that crept in at one point\n        a = np.zeros((100, 100))\n        assert_(sys.getrefcount(a) < 50)\n        for i in range(100):\n            a.diagonal()\n        assert_(sys.getrefcount(a) < 50)\n\n    def test_ravel(self):\n        a = np.array([[0, 1], [2, 3]])\n        assert_equal(a.ravel(), [0, 1, 2, 3])\n        assert_(not a.ravel().flags.owndata)\n        assert_equal(a.ravel('F'), [0, 2, 1, 3])\n        assert_equal(a.ravel(order='C'), [0, 1, 2, 3])\n        assert_equal(a.ravel(order='F'), [0, 2, 1, 3])\n        assert_equal(a.ravel(order='A'), [0, 1, 2, 3])\n        assert_(not a.ravel(order='A').flags.owndata)\n        assert_equal(a.ravel(order='K'), [0, 1, 2, 3])\n        assert_(not a.ravel(order='K').flags.owndata)\n        assert_equal(a.ravel(), a.reshape(-1))\n\n        a = np.array([[0, 1], [2, 3]], order='F')\n        assert_equal(a.ravel(), [0, 1, 2, 3])\n        assert_equal(a.ravel(order='A'), [0, 2, 1, 3])\n        assert_equal(a.ravel(order='K'), [0, 2, 1, 3])\n        assert_(not a.ravel(order='A').flags.owndata)\n        assert_(not a.ravel(order='K').flags.owndata)\n        assert_equal(a.ravel(), a.reshape(-1))\n        assert_equal(a.ravel(order='A'), a.reshape(-1, order='A'))\n\n        a = np.array([[0, 1], [2, 3]])[::-1,:]\n        assert_equal(a.ravel(), [2, 3, 0, 1])\n        assert_equal(a.ravel(order='C'), [2, 3, 0, 1])\n        assert_equal(a.ravel(order='F'), [2, 0, 3, 1])\n        assert_equal(a.ravel(order='A'), [2, 3, 0, 1])\n        # 'K' doesn't reverse the axes of negative strides\n        assert_equal(a.ravel(order='K'), [2, 3, 0, 1])\n        assert_(a.ravel(order='K').flags.owndata)\n\n\nclass TestBinop(object):\n    def test_ufunc_override_rop_precedence(self):\n        # Check that __rmul__ and other right-hand operations have\n        # precedence over __numpy_ufunc__\n\n        ops = {\n            '__add__':      ('__radd__', np.add, True),\n            '__sub__':      ('__rsub__', np.subtract, True),\n            '__mul__':      ('__rmul__', np.multiply, True),\n            '__truediv__':  ('__rtruediv__', np.true_divide, True),\n            '__floordiv__': ('__rfloordiv__', np.floor_divide, True),\n            '__mod__':      ('__rmod__', np.remainder, True),\n            '__divmod__':   ('__rdivmod__', None, False),\n            '__pow__':      ('__rpow__', np.power, True),\n            '__lshift__':   ('__rlshift__', np.left_shift, True),\n            '__rshift__':   ('__rrshift__', np.right_shift, True),\n            '__and__':      ('__rand__', np.bitwise_and, True),\n            '__xor__':      ('__rxor__', np.bitwise_xor, True),\n            '__or__':       ('__ror__', np.bitwise_or, True),\n            '__ge__':       ('__le__', np.less_equal, False),\n            '__gt__':       ('__lt__', np.less, False),\n            '__le__':       ('__ge__', np.greater_equal, False),\n            '__lt__':       ('__gt__', np.greater, False),\n            '__eq__':       ('__eq__', np.equal, False),\n            '__ne__':       ('__ne__', np.not_equal, False),\n        }\n\n        class OtherNdarraySubclass(ndarray):\n            pass\n\n        class OtherNdarraySubclassWithOverride(ndarray):\n            def __numpy_ufunc__(self, *a, **kw):\n                raise AssertionError((\"__numpy_ufunc__ %r %r shouldn't have \"\n                                      \"been called!\") % (a, kw))\n\n        def check(op_name, ndsubclass):\n            rop_name, np_op, has_iop = ops[op_name]\n\n            if has_iop:\n                iop_name = '__i' + op_name[2:]\n                iop = getattr(operator, iop_name)\n\n            if op_name == \"__divmod__\":\n                op = divmod\n            else:\n                op = getattr(operator, op_name)\n\n            # Dummy class\n            def __init__(self, *a, **kw):\n                pass\n\n            def __numpy_ufunc__(self, *a, **kw):\n                raise AssertionError((\"__numpy_ufunc__ %r %r shouldn't have \"\n                                      \"been called!\") % (a, kw))\n\n            def __op__(self, *other):\n                return \"op\"\n\n            def __rop__(self, *other):\n                return \"rop\"\n\n            if ndsubclass:\n                bases = (ndarray,)\n            else:\n                bases = (object,)\n\n            dct = {'__init__': __init__,\n                   '__numpy_ufunc__': __numpy_ufunc__,\n                   op_name: __op__}\n            if op_name != rop_name:\n                dct[rop_name] = __rop__\n\n            cls = type(\"Rop\" + rop_name, bases, dct)\n\n            # Check behavior against both bare ndarray objects and a\n            # ndarray subclasses with and without their own override\n            obj = cls((1,), buffer=np.ones(1,))\n\n            arr_objs = [np.array([1]),\n                        np.array([2]).view(OtherNdarraySubclass),\n                        np.array([3]).view(OtherNdarraySubclassWithOverride),\n                        ]\n\n            for arr in arr_objs:\n                err_msg = \"%r %r\" % (op_name, arr,)\n\n                # Check that ndarray op gives up if it sees a non-subclass\n                if not isinstance(obj, arr.__class__):\n                    assert_equal(getattr(arr, op_name)(obj),\n                                 NotImplemented, err_msg=err_msg)\n\n                # Check that the Python binops have priority\n                assert_equal(op(obj, arr), \"op\", err_msg=err_msg)\n                if op_name == rop_name:\n                    assert_equal(op(arr, obj), \"op\", err_msg=err_msg)\n                else:\n                    assert_equal(op(arr, obj), \"rop\", err_msg=err_msg)\n\n                # Check that Python binops have priority also for in-place ops\n                if has_iop:\n                    assert_equal(getattr(arr, iop_name)(obj),\n                                 NotImplemented, err_msg=err_msg)\n                    if op_name != \"__pow__\":\n                        # inplace pow requires the other object to be\n                        # integer-like?\n                        assert_equal(iop(arr, obj), \"rop\", err_msg=err_msg)\n\n                # Check that ufunc call __numpy_ufunc__ normally\n                if np_op is not None:\n                    assert_raises(AssertionError, np_op, arr, obj,\n                                  err_msg=err_msg)\n                    assert_raises(AssertionError, np_op, obj, arr,\n                                  err_msg=err_msg)\n\n        # Check all binary operations\n        for op_name in sorted(ops.keys()):\n            yield check, op_name, True\n            yield check, op_name, False\n\n    def test_ufunc_override_rop_simple(self):\n        # Check parts of the binary op overriding behavior in an\n        # explicit test case that is easier to understand.\n\n        class SomeClass(object):\n            def __numpy_ufunc__(self, *a, **kw):\n                return \"ufunc\"\n            def __mul__(self, other):\n                return 123\n            def __rmul__(self, other):\n                return 321\n            def __gt__(self, other):\n                return \"yep\"\n            def __lt__(self, other):\n                return \"nope\"\n\n        class SomeClass2(SomeClass, ndarray):\n            def __numpy_ufunc__(self, ufunc, method, i, inputs, **kw):\n                if ufunc is np.multiply:\n                    return \"ufunc\"\n                else:\n                    inputs = list(inputs)\n                    inputs[i] = np.asarray(self)\n                    func = getattr(ufunc, method)\n                    r = func(*inputs, **kw)\n                    if 'out' in kw:\n                        return r\n                    else:\n                        x = SomeClass2(r.shape, dtype=r.dtype)\n                        x[...] = r\n                        return x\n\n        arr = np.array([0])\n        obj = SomeClass()\n        obj2 = SomeClass2((1,), dtype=np.int_)\n        obj2[0] = 9\n\n        assert_equal(obj * arr, 123)\n        assert_equal(arr * obj, 321)\n        assert_equal(arr > obj, \"nope\")\n        assert_equal(arr < obj, \"yep\")\n        assert_equal(np.multiply(arr, obj), \"ufunc\")\n        arr *= obj\n        assert_equal(arr, 321)\n\n        assert_equal(obj2 * arr, 123)\n        assert_equal(arr * obj2, 321)\n        assert_equal(arr > obj2, \"nope\")\n        assert_equal(arr < obj2, \"yep\")\n        assert_equal(np.multiply(arr, obj2), \"ufunc\")\n        arr *= obj2\n        assert_equal(arr, 321)\n\n        obj2 += 33\n        assert_equal(obj2[0], 42)\n        assert_equal(obj2.sum(), 42)\n        assert_(isinstance(obj2, SomeClass2))\n\n\nclass TestSubscripting(TestCase):\n    def test_test_zero_rank(self):\n        x = array([1, 2, 3])\n        self.assertTrue(isinstance(x[0], np.int_))\n        if sys.version_info[0] < 3:\n            self.assertTrue(isinstance(x[0], int))\n        self.assertTrue(type(x[0, ...]) is ndarray)\n\n\nclass TestPickling(TestCase):\n    def test_roundtrip(self):\n        import pickle\n        carray = array([[2, 9], [7, 0], [3, 8]])\n        DATA = [\n            carray,\n            transpose(carray),\n            array([('xxx', 1, 2.0)], dtype=[('a', (str, 3)), ('b', int),\n                                            ('c', float)])\n        ]\n\n        for a in DATA:\n            assert_equal(a, pickle.loads(a.dumps()), err_msg=\"%r\" % a)\n\n    def _loads(self, obj):\n        if sys.version_info[0] >= 3:\n            return loads(obj, encoding='latin1')\n        else:\n            return loads(obj)\n\n    # version 0 pickles, using protocol=2 to pickle\n    # version 0 doesn't have a version field\n    def test_version0_int8(self):\n        s = '\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x04\\x85cnumpy\\ndtype\\nq\\x04U\\x02i1K\\x00K\\x01\\x87Rq\\x05(U\\x01|NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89U\\x04\\x01\\x02\\x03\\x04tb.'\n        a = array([1, 2, 3, 4], dtype=int8)\n        p = self._loads(asbytes(s))\n        assert_equal(a, p)\n\n    def test_version0_float32(self):\n        s = '\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x04\\x85cnumpy\\ndtype\\nq\\x04U\\x02f4K\\x00K\\x01\\x87Rq\\x05(U\\x01<NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89U\\x10\\x00\\x00\\x80?\\x00\\x00\\x00@\\x00\\x00@@\\x00\\x00\\x80@tb.'\n        a = array([1.0, 2.0, 3.0, 4.0], dtype=float32)\n        p = self._loads(asbytes(s))\n        assert_equal(a, p)\n\n    def test_version0_object(self):\n        s = '\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x02\\x85cnumpy\\ndtype\\nq\\x04U\\x02O8K\\x00K\\x01\\x87Rq\\x05(U\\x01|NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89]q\\x06(}q\\x07U\\x01aK\\x01s}q\\x08U\\x01bK\\x02setb.'\n        a = np.array([{'a':1}, {'b':2}])\n        p = self._loads(asbytes(s))\n        assert_equal(a, p)\n\n    # version 1 pickles, using protocol=2 to pickle\n    def test_version1_int8(self):\n        s = '\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x01K\\x04\\x85cnumpy\\ndtype\\nq\\x04U\\x02i1K\\x00K\\x01\\x87Rq\\x05(K\\x01U\\x01|NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89U\\x04\\x01\\x02\\x03\\x04tb.'\n        a = array([1, 2, 3, 4], dtype=int8)\n        p = self._loads(asbytes(s))\n        assert_equal(a, p)\n\n    def test_version1_float32(self):\n        s = '\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x01K\\x04\\x85cnumpy\\ndtype\\nq\\x04U\\x02f4K\\x00K\\x01\\x87Rq\\x05(K\\x01U\\x01<NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89U\\x10\\x00\\x00\\x80?\\x00\\x00\\x00@\\x00\\x00@@\\x00\\x00\\x80@tb.'\n        a = array([1.0, 2.0, 3.0, 4.0], dtype=float32)\n        p = self._loads(asbytes(s))\n        assert_equal(a, p)\n\n    def test_version1_object(self):\n        s = '\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x01K\\x02\\x85cnumpy\\ndtype\\nq\\x04U\\x02O8K\\x00K\\x01\\x87Rq\\x05(K\\x01U\\x01|NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89]q\\x06(}q\\x07U\\x01aK\\x01s}q\\x08U\\x01bK\\x02setb.'\n        a = array([{'a':1}, {'b':2}])\n        p = self._loads(asbytes(s))\n        assert_equal(a, p)\n\n    def test_subarray_int_shape(self):\n        s = \"cnumpy.core.multiarray\\n_reconstruct\\np0\\n(cnumpy\\nndarray\\np1\\n(I0\\ntp2\\nS'b'\\np3\\ntp4\\nRp5\\n(I1\\n(I1\\ntp6\\ncnumpy\\ndtype\\np7\\n(S'V6'\\np8\\nI0\\nI1\\ntp9\\nRp10\\n(I3\\nS'|'\\np11\\nN(S'a'\\np12\\ng3\\ntp13\\n(dp14\\ng12\\n(g7\\n(S'V4'\\np15\\nI0\\nI1\\ntp16\\nRp17\\n(I3\\nS'|'\\np18\\n(g7\\n(S'i1'\\np19\\nI0\\nI1\\ntp20\\nRp21\\n(I3\\nS'|'\\np22\\nNNNI-1\\nI-1\\nI0\\ntp23\\nb(I2\\nI2\\ntp24\\ntp25\\nNNI4\\nI1\\nI0\\ntp26\\nbI0\\ntp27\\nsg3\\n(g7\\n(S'V2'\\np28\\nI0\\nI1\\ntp29\\nRp30\\n(I3\\nS'|'\\np31\\n(g21\\nI2\\ntp32\\nNNI2\\nI1\\nI0\\ntp33\\nbI4\\ntp34\\nsI6\\nI1\\nI0\\ntp35\\nbI00\\nS'\\\\x01\\\\x01\\\\x01\\\\x01\\\\x01\\\\x02'\\np36\\ntp37\\nb.\"\n        a = np.array([(1, (1, 2))], dtype=[('a', 'i1', (2, 2)), ('b', 'i1', 2)])\n        p = self._loads(asbytes(s))\n        assert_equal(a, p)\n\n\nclass TestFancyIndexing(TestCase):\n    def test_list(self):\n        x = ones((1, 1))\n        x[:, [0]] = 2.0\n        assert_array_equal(x, array([[2.0]]))\n\n        x = ones((1, 1, 1))\n        x[:,:, [0]] = 2.0\n        assert_array_equal(x, array([[[2.0]]]))\n\n    def test_tuple(self):\n        x = ones((1, 1))\n        x[:, (0,)] = 2.0\n        assert_array_equal(x, array([[2.0]]))\n        x = ones((1, 1, 1))\n        x[:,:, (0,)] = 2.0\n        assert_array_equal(x, array([[[2.0]]]))\n\n    def test_mask(self):\n        x = array([1, 2, 3, 4])\n        m = array([0, 1], bool)\n        assert_array_equal(x[m], array([2]))\n\n    def test_mask2(self):\n        x = array([[1, 2, 3, 4], [5, 6, 7, 8]])\n        m = array([0, 1], bool)\n        m2 = array([[0, 1], [1, 0]], bool)\n        m3 = array([[0, 1]], bool)\n        assert_array_equal(x[m], array([[5, 6, 7, 8]]))\n        assert_array_equal(x[m2], array([2, 5]))\n        assert_array_equal(x[m3], array([2]))\n\n    def test_assign_mask(self):\n        x = array([1, 2, 3, 4])\n        m = array([0, 1], bool)\n        x[m] = 5\n        assert_array_equal(x, array([1, 5, 3, 4]))\n\n    def test_assign_mask2(self):\n        xorig = array([[1, 2, 3, 4], [5, 6, 7, 8]])\n        m = array([0, 1], bool)\n        m2 = array([[0, 1], [1, 0]], bool)\n        m3 = array([[0, 1]], bool)\n        x = xorig.copy()\n        x[m] = 10\n        assert_array_equal(x, array([[1, 2, 3, 4], [10, 10, 10, 10]]))\n        x = xorig.copy()\n        x[m2] = 10\n        assert_array_equal(x, array([[1, 10, 3, 4], [10, 6, 7, 8]]))\n        x = xorig.copy()\n        x[m3] = 10\n        assert_array_equal(x, array([[1, 10, 3, 4], [5, 6, 7, 8]]))\n\n\nclass TestStringCompare(TestCase):\n    def test_string(self):\n        g1 = array([\"This\", \"is\", \"example\"])\n        g2 = array([\"This\", \"was\", \"example\"])\n        assert_array_equal(g1 == g2, [g1[i] == g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 != g2, [g1[i] != g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 <= g2, [g1[i] <= g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 >= g2, [g1[i] >= g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 < g2, [g1[i] < g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 > g2, [g1[i] > g2[i] for i in [0, 1, 2]])\n\n    def test_mixed(self):\n        g1 = array([\"spam\", \"spa\", \"spammer\", \"and eggs\"])\n        g2 = \"spam\"\n        assert_array_equal(g1 == g2, [x == g2 for x in g1])\n        assert_array_equal(g1 != g2, [x != g2 for x in g1])\n        assert_array_equal(g1 < g2, [x < g2 for x in g1])\n        assert_array_equal(g1 > g2, [x > g2 for x in g1])\n        assert_array_equal(g1 <= g2, [x <= g2 for x in g1])\n        assert_array_equal(g1 >= g2, [x >= g2 for x in g1])\n\n\n    def test_unicode(self):\n        g1 = array([sixu(\"This\"), sixu(\"is\"), sixu(\"example\")])\n        g2 = array([sixu(\"This\"), sixu(\"was\"), sixu(\"example\")])\n        assert_array_equal(g1 == g2, [g1[i] == g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 != g2, [g1[i] != g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 <= g2, [g1[i] <= g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 >= g2, [g1[i] >= g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 < g2,  [g1[i] < g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 > g2,  [g1[i] > g2[i] for i in [0, 1, 2]])\n\n\nclass TestArgmax(TestCase):\n\n    nan_arr = [\n        ([0, 1, 2, 3, np.nan], 4),\n        ([0, 1, 2, np.nan, 3], 3),\n        ([np.nan, 0, 1, 2, 3], 0),\n        ([np.nan, 0, np.nan, 2, 3], 0),\n        ([0, 1, 2, 3, complex(0, np.nan)], 4),\n        ([0, 1, 2, 3, complex(np.nan, 0)], 4),\n        ([0, 1, 2, complex(np.nan, 0), 3], 3),\n        ([0, 1, 2, complex(0, np.nan), 3], 3),\n        ([complex(0, np.nan), 0, 1, 2, 3], 0),\n        ([complex(np.nan, np.nan), 0, 1, 2, 3], 0),\n        ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, 1)], 0),\n        ([complex(np.nan, np.nan), complex(np.nan, 2), complex(np.nan, 1)], 0),\n        ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, np.nan)], 0),\n\n        ([complex(0, 0), complex(0, 2), complex(0, 1)], 1),\n        ([complex(1, 0), complex(0, 2), complex(0, 1)], 0),\n        ([complex(1, 0), complex(0, 2), complex(1, 1)], 2),\n\n        ([np.datetime64('1923-04-14T12:43:12'),\n          np.datetime64('1994-06-21T14:43:15'),\n          np.datetime64('2001-10-15T04:10:32'),\n          np.datetime64('1995-11-25T16:02:16'),\n          np.datetime64('2005-01-04T03:14:12'),\n          np.datetime64('2041-12-03T14:05:03')], 5),\n        ([np.datetime64('1935-09-14T04:40:11'),\n          np.datetime64('1949-10-12T12:32:11'),\n          np.datetime64('2010-01-03T05:14:12'),\n          np.datetime64('2015-11-20T12:20:59'),\n          np.datetime64('1932-09-23T10:10:13'),\n          np.datetime64('2014-10-10T03:50:30')], 3),\n        ([np.datetime64('2059-03-14T12:43:12'),\n          np.datetime64('1996-09-21T14:43:15'),\n          np.datetime64('2001-10-15T04:10:32'),\n          np.datetime64('2022-12-25T16:02:16'),\n          np.datetime64('1963-10-04T03:14:12'),\n          np.datetime64('2013-05-08T18:15:23')], 0),\n\n        ([timedelta(days=5, seconds=14), timedelta(days=2, seconds=35),\n          timedelta(days=-1, seconds=23)], 0),\n        ([timedelta(days=1, seconds=43), timedelta(days=10, seconds=5),\n          timedelta(days=5, seconds=14)], 1),\n        ([timedelta(days=10, seconds=24), timedelta(days=10, seconds=5),\n          timedelta(days=10, seconds=43)], 2),\n\n        # Can't reduce a \"flexible type\"\n        #(['a', 'z', 'aa', 'zz'], 3),\n        #(['zz', 'a', 'aa', 'a'], 0),\n        #(['aa', 'z', 'zz', 'a'], 2),\n    ]\n\n    def test_all(self):\n        a = np.random.normal(0, 1, (4, 5, 6, 7, 8))\n        for i in range(a.ndim):\n            amax = a.max(i)\n            aargmax = a.argmax(i)\n            axes = list(range(a.ndim))\n            axes.remove(i)\n            assert_(all(amax == aargmax.choose(*a.transpose(i,*axes))))\n\n    def test_combinations(self):\n        for arr, pos in self.nan_arr:\n            assert_equal(np.argmax(arr), pos, err_msg=\"%r\"%arr)\n            assert_equal(arr[np.argmax(arr)], np.max(arr), err_msg=\"%r\"%arr)\n\n    def test_output_shape(self):\n        # see also gh-616\n        a = np.ones((10, 5))\n        # Check some simple shape mismatches\n        out = np.ones(11, dtype=np.int_)\n        assert_raises(ValueError, a.argmax, -1, out)\n\n        out = np.ones((2, 5), dtype=np.int_)\n        assert_raises(ValueError, a.argmax, -1, out)\n\n        # these could be relaxed possibly (used to allow even the previous)\n        out = np.ones((1, 10), dtype=np.int_)\n        assert_raises(ValueError, a.argmax, -1, np.ones((1, 10)))\n\n        out = np.ones(10, dtype=np.int_)\n        a.argmax(-1, out=out)\n        assert_equal(out, a.argmax(-1))\n\n\nclass TestArgmin(TestCase):\n\n    nan_arr = [\n        ([0, 1, 2, 3, np.nan], 4),\n        ([0, 1, 2, np.nan, 3], 3),\n        ([np.nan, 0, 1, 2, 3], 0),\n        ([np.nan, 0, np.nan, 2, 3], 0),\n        ([0, 1, 2, 3, complex(0, np.nan)], 4),\n        ([0, 1, 2, 3, complex(np.nan, 0)], 4),\n        ([0, 1, 2, complex(np.nan, 0), 3], 3),\n        ([0, 1, 2, complex(0, np.nan), 3], 3),\n        ([complex(0, np.nan), 0, 1, 2, 3], 0),\n        ([complex(np.nan, np.nan), 0, 1, 2, 3], 0),\n        ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, 1)], 0),\n        ([complex(np.nan, np.nan), complex(np.nan, 2), complex(np.nan, 1)], 0),\n        ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, np.nan)], 0),\n\n        ([complex(0, 0), complex(0, 2), complex(0, 1)], 0),\n        ([complex(1, 0), complex(0, 2), complex(0, 1)], 2),\n        ([complex(1, 0), complex(0, 2), complex(1, 1)], 1),\n\n        ([np.datetime64('1923-04-14T12:43:12'),\n          np.datetime64('1994-06-21T14:43:15'),\n          np.datetime64('2001-10-15T04:10:32'),\n          np.datetime64('1995-11-25T16:02:16'),\n          np.datetime64('2005-01-04T03:14:12'),\n          np.datetime64('2041-12-03T14:05:03')], 0),\n        ([np.datetime64('1935-09-14T04:40:11'),\n          np.datetime64('1949-10-12T12:32:11'),\n          np.datetime64('2010-01-03T05:14:12'),\n          np.datetime64('2014-11-20T12:20:59'),\n          np.datetime64('2015-09-23T10:10:13'),\n          np.datetime64('1932-10-10T03:50:30')], 5),\n        ([np.datetime64('2059-03-14T12:43:12'),\n          np.datetime64('1996-09-21T14:43:15'),\n          np.datetime64('2001-10-15T04:10:32'),\n          np.datetime64('2022-12-25T16:02:16'),\n          np.datetime64('1963-10-04T03:14:12'),\n          np.datetime64('2013-05-08T18:15:23')], 4),\n\n        ([timedelta(days=5, seconds=14), timedelta(days=2, seconds=35),\n          timedelta(days=-1, seconds=23)], 2),\n        ([timedelta(days=1, seconds=43), timedelta(days=10, seconds=5),\n          timedelta(days=5, seconds=14)], 0),\n        ([timedelta(days=10, seconds=24), timedelta(days=10, seconds=5),\n          timedelta(days=10, seconds=43)], 1),\n\n        # Can't reduce a \"flexible type\"\n        #(['a', 'z', 'aa', 'zz'], 0),\n        #(['zz', 'a', 'aa', 'a'], 1),\n        #(['aa', 'z', 'zz', 'a'], 3),\n    ]\n\n    def test_all(self):\n        a = np.random.normal(0, 1, (4, 5, 6, 7, 8))\n        for i in range(a.ndim):\n            amin = a.min(i)\n            aargmin = a.argmin(i)\n            axes = list(range(a.ndim))\n            axes.remove(i)\n            assert_(all(amin == aargmin.choose(*a.transpose(i,*axes))))\n\n    def test_combinations(self):\n        for arr, pos in self.nan_arr:\n            assert_equal(np.argmin(arr), pos, err_msg=\"%r\"%arr)\n            assert_equal(arr[np.argmin(arr)], np.min(arr), err_msg=\"%r\"%arr)\n\n    def test_minimum_signed_integers(self):\n\n        a = np.array([1, -2**7, -2**7 + 1], dtype=np.int8)\n        assert_equal(np.argmin(a), 1)\n\n        a = np.array([1, -2**15, -2**15 + 1], dtype=np.int16)\n        assert_equal(np.argmin(a), 1)\n\n        a = np.array([1, -2**31, -2**31 + 1], dtype=np.int32)\n        assert_equal(np.argmin(a), 1)\n\n        a = np.array([1, -2**63, -2**63 + 1], dtype=np.int64)\n        assert_equal(np.argmin(a), 1)\n\n    def test_output_shape(self):\n        # see also gh-616\n        a = np.ones((10, 5))\n        # Check some simple shape mismatches\n        out = np.ones(11, dtype=np.int_)\n        assert_raises(ValueError, a.argmin, -1, out)\n\n        out = np.ones((2, 5), dtype=np.int_)\n        assert_raises(ValueError, a.argmin, -1, out)\n\n        # these could be relaxed possibly (used to allow even the previous)\n        out = np.ones((1, 10), dtype=np.int_)\n        assert_raises(ValueError, a.argmin, -1, np.ones((1, 10)))\n\n        out = np.ones(10, dtype=np.int_)\n        a.argmin(-1, out=out)\n        assert_equal(out, a.argmin(-1))\n\n\nclass TestMinMax(TestCase):\n    def test_scalar(self):\n        assert_raises(ValueError, np.amax, 1, 1)\n        assert_raises(ValueError, np.amin, 1, 1)\n\n        assert_equal(np.amax(1, axis=0), 1)\n        assert_equal(np.amin(1, axis=0), 1)\n        assert_equal(np.amax(1, axis=None), 1)\n        assert_equal(np.amin(1, axis=None), 1)\n\n    def test_axis(self):\n        assert_raises(ValueError, np.amax, [1, 2, 3], 1000)\n        assert_equal(np.amax([[1, 2, 3]], axis=1), 3)\n\nclass TestNewaxis(TestCase):\n    def test_basic(self):\n        sk = array([0, -0.1, 0.1])\n        res = 250*sk[:, newaxis]\n        assert_almost_equal(res.ravel(), 250*sk)\n\n\nclass TestClip(TestCase):\n    def _check_range(self, x, cmin, cmax):\n        assert_(np.all(x >= cmin))\n        assert_(np.all(x <= cmax))\n\n    def _clip_type(self,type_group,array_max,\n                   clip_min,clip_max,inplace=False,\n                   expected_min=None,expected_max=None):\n        if expected_min is None:\n            expected_min = clip_min\n        if expected_max is None:\n            expected_max = clip_max\n\n        for T in np.sctypes[type_group]:\n            if sys.byteorder == 'little':\n                byte_orders = ['=', '>']\n            else:\n                byte_orders = ['<', '=']\n\n            for byteorder in byte_orders:\n                dtype = np.dtype(T).newbyteorder(byteorder)\n\n                x = (np.random.random(1000) * array_max).astype(dtype)\n                if inplace:\n                    x.clip(clip_min, clip_max, x)\n                else:\n                    x = x.clip(clip_min, clip_max)\n                    byteorder = '='\n\n                if x.dtype.byteorder == '|': byteorder = '|'\n                assert_equal(x.dtype.byteorder, byteorder)\n                self._check_range(x, expected_min, expected_max)\n        return x\n\n    def test_basic(self):\n        for inplace in [False, True]:\n            self._clip_type('float', 1024, -12.8, 100.2, inplace=inplace)\n            self._clip_type('float', 1024, 0, 0, inplace=inplace)\n\n            self._clip_type('int', 1024, -120, 100.5, inplace=inplace)\n            self._clip_type('int', 1024, 0, 0, inplace=inplace)\n\n            x = self._clip_type('uint', 1024, -120, 100, expected_min=0,\n                    inplace=inplace)\n            x = self._clip_type('uint', 1024, 0, 0, inplace=inplace)\n\n    def test_record_array(self):\n        rec = np.array([(-5, 2.0, 3.0), (5.0, 4.0, 3.0)],\n                      dtype=[('x', '<f8'), ('y', '<f8'), ('z', '<f8')])\n        y = rec['x'].clip(-0.3, 0.5)\n        self._check_range(y, -0.3, 0.5)\n\n    def test_max_or_min(self):\n        val = np.array([0, 1, 2, 3, 4, 5, 6, 7])\n        x = val.clip(3)\n        assert_(np.all(x >= 3))\n        x = val.clip(min=3)\n        assert_(np.all(x >= 3))\n        x = val.clip(max=4)\n        assert_(np.all(x <= 4))\n\n\nclass TestPutmask(object):\n    def tst_basic(self, x, T, mask, val):\n        np.putmask(x, mask, val)\n        assert_(np.all(x[mask] == T(val)))\n        assert_(x.dtype == T)\n\n    def test_ip_types(self):\n        unchecked_types = [str, unicode, np.void, object]\n\n        x = np.random.random(1000)*100\n        mask = x < 40\n\n        for val in [-100, 0, 15]:\n            for types in np.sctypes.values():\n                for T in types:\n                    if T not in unchecked_types:\n                        yield self.tst_basic, x.copy().astype(T), T, mask, val\n\n    def test_mask_size(self):\n        assert_raises(ValueError, np.putmask, np.array([1, 2, 3]), [True], 5)\n\n    def tst_byteorder(self, dtype):\n        x = np.array([1, 2, 3], dtype)\n        np.putmask(x, [True, False, True], -1)\n        assert_array_equal(x, [-1, 2, -1])\n\n    def test_ip_byteorder(self):\n        for dtype in ('>i4', '<i4'):\n            yield self.tst_byteorder, dtype\n\n    def test_record_array(self):\n        # Note mixed byteorder.\n        rec = np.array([(-5, 2.0, 3.0), (5.0, 4.0, 3.0)],\n                      dtype=[('x', '<f8'), ('y', '>f8'), ('z', '<f8')])\n        np.putmask(rec['x'], [True, False], 10)\n        assert_array_equal(rec['x'], [10, 5])\n        assert_array_equal(rec['y'], [2, 4])\n        assert_array_equal(rec['z'], [3, 3])\n        np.putmask(rec['y'], [True, False], 11)\n        assert_array_equal(rec['x'], [10, 5])\n        assert_array_equal(rec['y'], [11, 4])\n        assert_array_equal(rec['z'], [3, 3])\n\n    def test_masked_array(self):\n        ## x = np.array([1,2,3])\n        ## z = np.ma.array(x,mask=[True,False,False])\n        ## np.putmask(z,[True,True,True],3)\n        pass\n\n\nclass TestTake(object):\n    def tst_basic(self, x):\n        ind = list(range(x.shape[0]))\n        assert_array_equal(x.take(ind, axis=0), x)\n\n    def test_ip_types(self):\n        unchecked_types = [str, unicode, np.void, object]\n\n        x = np.random.random(24)*100\n        x.shape = 2, 3, 4\n        for types in np.sctypes.values():\n            for T in types:\n                if T not in unchecked_types:\n                    yield self.tst_basic, x.copy().astype(T)\n\n    def test_raise(self):\n        x = np.random.random(24)*100\n        x.shape = 2, 3, 4\n        assert_raises(IndexError, x.take, [0, 1, 2], axis=0)\n        assert_raises(IndexError, x.take, [-3], axis=0)\n        assert_array_equal(x.take([-1], axis=0)[0], x[1])\n\n    def test_clip(self):\n        x = np.random.random(24)*100\n        x.shape = 2, 3, 4\n        assert_array_equal(x.take([-1], axis=0, mode='clip')[0], x[0])\n        assert_array_equal(x.take([2], axis=0, mode='clip')[0], x[1])\n\n    def test_wrap(self):\n        x = np.random.random(24)*100\n        x.shape = 2, 3, 4\n        assert_array_equal(x.take([-1], axis=0, mode='wrap')[0], x[1])\n        assert_array_equal(x.take([2], axis=0, mode='wrap')[0], x[0])\n        assert_array_equal(x.take([3], axis=0, mode='wrap')[0], x[1])\n\n    def tst_byteorder(self, dtype):\n        x = np.array([1, 2, 3], dtype)\n        assert_array_equal(x.take([0, 2, 1]), [1, 3, 2])\n\n    def test_ip_byteorder(self):\n        for dtype in ('>i4', '<i4'):\n            yield self.tst_byteorder, dtype\n\n    def test_record_array(self):\n        # Note mixed byteorder.\n        rec = np.array([(-5, 2.0, 3.0), (5.0, 4.0, 3.0)],\n                      dtype=[('x', '<f8'), ('y', '>f8'), ('z', '<f8')])\n        rec1 = rec.take([1])\n        assert_(rec1['x'] == 5.0 and rec1['y'] == 4.0)\n\n\nclass TestLexsort(TestCase):\n    def test_basic(self):\n        a = [1, 2, 1, 3, 1, 5]\n        b = [0, 4, 5, 6, 2, 3]\n        idx = np.lexsort((b, a))\n        expected_idx = np.array([0, 4, 2, 1, 3, 5])\n        assert_array_equal(idx, expected_idx)\n\n        x = np.vstack((b, a))\n        idx = np.lexsort(x)\n        assert_array_equal(idx, expected_idx)\n\n        assert_array_equal(x[1][idx], np.sort(x[1]))\n\n    def test_datetime(self):\n        a = np.array([0,0,0], dtype='datetime64[D]')\n        b = np.array([2,1,0], dtype='datetime64[D]')\n        idx = np.lexsort((b, a))\n        expected_idx = np.array([2, 1, 0])\n        assert_array_equal(idx, expected_idx)\n\n        a = np.array([0,0,0], dtype='timedelta64[D]')\n        b = np.array([2,1,0], dtype='timedelta64[D]')\n        idx = np.lexsort((b, a))\n        expected_idx = np.array([2, 1, 0])\n        assert_array_equal(idx, expected_idx)\n\n\nclass TestIO(object):\n    \"\"\"Test tofile, fromfile, tostring, and fromstring\"\"\"\n\n    def setUp(self):\n        shape = (2, 4, 3)\n        rand = np.random.random\n        self.x = rand(shape) + rand(shape).astype(np.complex)*1j\n        self.x[0,:, 1] = [nan, inf, -inf, nan]\n        self.dtype = self.x.dtype\n        self.filename = tempfile.mktemp()\n\n    def tearDown(self):\n        if os.path.isfile(self.filename):\n            os.unlink(self.filename)\n            #tmp_file.close()\n\n    def test_bool_fromstring(self):\n        v = np.array([True, False, True, False], dtype=np.bool_)\n        y = np.fromstring('1 0 -2.3 0.0', sep=' ', dtype=np.bool_)\n        assert_array_equal(v, y)\n\n    def test_empty_files_binary(self):\n        f = open(self.filename, 'w')\n        f.close()\n        y = fromfile(self.filename)\n        assert_(y.size == 0, \"Array not empty\")\n\n    def test_empty_files_text(self):\n        f = open(self.filename, 'w')\n        f.close()\n        y = fromfile(self.filename, sep=\" \")\n        assert_(y.size == 0, \"Array not empty\")\n\n    def test_roundtrip_file(self):\n        f = open(self.filename, 'wb')\n        self.x.tofile(f)\n        f.close()\n        # NB. doesn't work with flush+seek, due to use of C stdio\n        f = open(self.filename, 'rb')\n        y = np.fromfile(f, dtype=self.dtype)\n        f.close()\n        assert_array_equal(y, self.x.flat)\n        os.unlink(self.filename)\n\n    def test_roundtrip_filename(self):\n        self.x.tofile(self.filename)\n        y = np.fromfile(self.filename, dtype=self.dtype)\n        assert_array_equal(y, self.x.flat)\n\n    def test_roundtrip_binary_str(self):\n        s = self.x.tostring()\n        y = np.fromstring(s, dtype=self.dtype)\n        assert_array_equal(y, self.x.flat)\n\n        s = self.x.tostring('F')\n        y = np.fromstring(s, dtype=self.dtype)\n        assert_array_equal(y, self.x.flatten('F'))\n\n    def test_roundtrip_str(self):\n        x = self.x.real.ravel()\n        s = \"@\".join(map(str, x))\n        y = np.fromstring(s, sep=\"@\")\n        # NB. str imbues less precision\n        nan_mask = ~np.isfinite(x)\n        assert_array_equal(x[nan_mask], y[nan_mask])\n        assert_array_almost_equal(x[~nan_mask], y[~nan_mask], decimal=5)\n\n    def test_roundtrip_repr(self):\n        x = self.x.real.ravel()\n        s = \"@\".join(map(repr, x))\n        y = np.fromstring(s, sep=\"@\")\n        assert_array_equal(x, y)\n\n    def test_file_position_after_fromfile(self):\n        # gh-4118\n        sizes = [io.DEFAULT_BUFFER_SIZE//8,\n                 io.DEFAULT_BUFFER_SIZE,\n                 io.DEFAULT_BUFFER_SIZE*8]\n\n        for size in sizes:\n            f = open(self.filename, 'wb')\n            f.seek(size-1)\n            f.write(b'\\0')\n            f.close()\n\n            for mode in ['rb', 'r+b']:\n                err_msg = \"%d %s\" % (size, mode)\n\n                f = open(self.filename, mode)\n                f.read(2)\n                np.fromfile(f, dtype=np.float64, count=1)\n                pos = f.tell()\n                f.close()\n                assert_equal(pos, 10, err_msg=err_msg)\n\n        os.unlink(self.filename)\n\n    def test_file_position_after_tofile(self):\n        # gh-4118\n        sizes = [io.DEFAULT_BUFFER_SIZE//8,\n                 io.DEFAULT_BUFFER_SIZE,\n                 io.DEFAULT_BUFFER_SIZE*8]\n\n        for size in sizes:\n            err_msg = \"%d\" % (size,)\n\n            f = open(self.filename, 'wb')\n            f.seek(size-1)\n            f.write(b'\\0')\n            f.seek(10)\n            f.write(b'12')\n            np.array([0], dtype=np.float64).tofile(f)\n            pos = f.tell()\n            f.close()\n            assert_equal(pos, 10 + 2 + 8, err_msg=err_msg)\n\n            f = open(self.filename, 'r+b')\n            f.read(2)\n            f.seek(0, 1) # seek between read&write required by ANSI C\n            np.array([0], dtype=np.float64).tofile(f)\n            pos = f.tell()\n            f.close()\n            assert_equal(pos, 10, err_msg=err_msg)\n\n        os.unlink(self.filename)\n\n    def _check_from(self, s, value, **kw):\n        y = np.fromstring(asbytes(s), **kw)\n        assert_array_equal(y, value)\n\n        f = open(self.filename, 'wb')\n        f.write(asbytes(s))\n        f.close()\n        y = np.fromfile(self.filename, **kw)\n        assert_array_equal(y, value)\n\n    def test_nan(self):\n        self._check_from(\"nan +nan -nan NaN nan(foo) +NaN(BAR) -NAN(q_u_u_x_)\",\n                         [nan, nan, nan, nan, nan, nan, nan],\n                         sep=' ')\n\n    def test_inf(self):\n        self._check_from(\"inf +inf -inf infinity -Infinity iNfInItY -inF\",\n                         [inf, inf, -inf, inf, -inf, inf, -inf], sep=' ')\n\n    def test_numbers(self):\n        self._check_from(\"1.234 -1.234 .3 .3e55 -123133.1231e+133\",\n                         [1.234, -1.234, .3, .3e55, -123133.1231e+133], sep=' ')\n\n    def test_binary(self):\n        self._check_from('\\x00\\x00\\x80?\\x00\\x00\\x00@\\x00\\x00@@\\x00\\x00\\x80@',\n                         array([1, 2, 3, 4]),\n                         dtype='<f4')\n\n    @dec.slow # takes > 1 minute on mechanical hard drive\n    def test_big_binary(self):\n        \"\"\"Test workarounds for 32-bit limited fwrite, fseek, and ftell\n        calls in windows. These normally would hang doing something like this.\n        See http://projects.scipy.org/numpy/ticket/1660\"\"\"\n        if sys.platform != 'win32':\n            return\n        try:\n            # before workarounds, only up to 2**32-1 worked\n            fourgbplus = 2**32 + 2**16\n            testbytes = np.arange(8, dtype=np.int8)\n            n = len(testbytes)\n            flike = tempfile.NamedTemporaryFile()\n            f = flike.file\n            np.tile(testbytes, fourgbplus // testbytes.nbytes).tofile(f)\n            flike.seek(0)\n            a = np.fromfile(f, dtype=np.int8)\n            flike.close()\n            assert_(len(a) == fourgbplus)\n            # check only start and end for speed:\n            assert_((a[:n] == testbytes).all())\n            assert_((a[-n:] == testbytes).all())\n        except (MemoryError, ValueError):\n            pass\n\n    def test_string(self):\n        self._check_from('1,2,3,4', [1., 2., 3., 4.], sep=',')\n\n    def test_counted_string(self):\n        self._check_from('1,2,3,4', [1., 2., 3., 4.], count=4, sep=',')\n        self._check_from('1,2,3,4', [1., 2., 3.], count=3, sep=',')\n        self._check_from('1,2,3,4', [1., 2., 3., 4.], count=-1, sep=',')\n\n    def test_string_with_ws(self):\n        self._check_from('1 2  3     4   ', [1, 2, 3, 4], dtype=int, sep=' ')\n\n    def test_counted_string_with_ws(self):\n        self._check_from('1 2  3     4   ', [1, 2, 3], count=3, dtype=int,\n                         sep=' ')\n\n    def test_ascii(self):\n        self._check_from('1 , 2 , 3 , 4', [1., 2., 3., 4.], sep=',')\n        self._check_from('1,2,3,4', [1., 2., 3., 4.], dtype=float, sep=',')\n\n    def test_malformed(self):\n        self._check_from('1.234 1,234', [1.234, 1.], sep=' ')\n\n    def test_long_sep(self):\n        self._check_from('1_x_3_x_4_x_5', [1, 3, 4, 5], sep='_x_')\n\n    def test_dtype(self):\n        v = np.array([1, 2, 3, 4], dtype=np.int_)\n        self._check_from('1,2,3,4', v, sep=',', dtype=np.int_)\n\n    def test_dtype_bool(self):\n        # can't use _check_from because fromstring can't handle True/False\n        v = np.array([True, False, True, False], dtype=np.bool_)\n        s = '1,0,-2.3,0'\n        f = open(self.filename, 'wb')\n        f.write(asbytes(s))\n        f.close()\n        y = np.fromfile(self.filename, sep=',', dtype=np.bool_)\n        assert_(y.dtype == '?')\n        assert_array_equal(y, v)\n\n    def test_tofile_sep(self):\n        x = np.array([1.51, 2, 3.51, 4], dtype=float)\n        f = open(self.filename, 'w')\n        x.tofile(f, sep=',')\n        f.close()\n        f = open(self.filename, 'r')\n        s = f.read()\n        f.close()\n        assert_equal(s, '1.51,2.0,3.51,4.0')\n        os.unlink(self.filename)\n\n    def test_tofile_format(self):\n        x = np.array([1.51, 2, 3.51, 4], dtype=float)\n        f = open(self.filename, 'w')\n        x.tofile(f, sep=',', format='%.2f')\n        f.close()\n        f = open(self.filename, 'r')\n        s = f.read()\n        f.close()\n        assert_equal(s, '1.51,2.00,3.51,4.00')\n\n    def test_locale(self):\n        in_foreign_locale(self.test_numbers)()\n        in_foreign_locale(self.test_nan)()\n        in_foreign_locale(self.test_inf)()\n        in_foreign_locale(self.test_counted_string)()\n        in_foreign_locale(self.test_ascii)()\n        in_foreign_locale(self.test_malformed)()\n        in_foreign_locale(self.test_tofile_sep)()\n        in_foreign_locale(self.test_tofile_format)()\n\n\nclass TestFromBuffer(object):\n    def tst_basic(self, buffer, expected, kwargs):\n        assert_array_equal(np.frombuffer(buffer,**kwargs), expected)\n\n    def test_ip_basic(self):\n        for byteorder in ['<', '>']:\n            for dtype in [float, int, np.complex]:\n                dt = np.dtype(dtype).newbyteorder(byteorder)\n                x = (np.random.random((4, 7))*5).astype(dt)\n                buf = x.tostring()\n                yield self.tst_basic, buf, x.flat, {'dtype':dt}\n\n    def test_empty(self):\n        yield self.tst_basic, asbytes(''), np.array([]), {}\n\n\nclass TestFlat(TestCase):\n    def setUp(self):\n        a0 = arange(20.0)\n        a = a0.reshape(4, 5)\n        a0.shape = (4, 5)\n        a.flags.writeable = False\n        self.a = a\n        self.b = a[::2, ::2]\n        self.a0 = a0\n        self.b0 = a0[::2, ::2]\n\n    def test_contiguous(self):\n        testpassed = False\n        try:\n            self.a.flat[12] = 100.0\n        except ValueError:\n            testpassed = True\n        assert testpassed\n        assert self.a.flat[12] == 12.0\n\n    def test_discontiguous(self):\n        testpassed = False\n        try:\n            self.b.flat[4] = 100.0\n        except ValueError:\n            testpassed = True\n        assert testpassed\n        assert self.b.flat[4] == 12.0\n\n    def test___array__(self):\n        c = self.a.flat.__array__()\n        d = self.b.flat.__array__()\n        e = self.a0.flat.__array__()\n        f = self.b0.flat.__array__()\n\n        assert c.flags.writeable is False\n        assert d.flags.writeable is False\n        assert e.flags.writeable is True\n        assert f.flags.writeable is True\n\n        assert c.flags.updateifcopy is False\n        assert d.flags.updateifcopy is False\n        assert e.flags.updateifcopy is False\n        assert f.flags.updateifcopy is True\n        assert f.base is self.b0\n\nclass TestResize(TestCase):\n    def test_basic(self):\n        x = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        x.resize((5, 5))\n        assert_array_equal(x.flat[:9],\n                np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]).flat)\n        assert_array_equal(x[9:].flat, 0)\n\n    def test_check_reference(self):\n        x = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        y = x\n        self.assertRaises(ValueError, x.resize, (5, 1))\n\n    def test_int_shape(self):\n        x = np.eye(3)\n        x.resize(3)\n        assert_array_equal(x, np.eye(3)[0,:])\n\n    def test_none_shape(self):\n        x = np.eye(3)\n        x.resize(None)\n        assert_array_equal(x, np.eye(3))\n        x.resize()\n        assert_array_equal(x, np.eye(3))\n\n    def test_invalid_arguements(self):\n        self.assertRaises(TypeError, np.eye(3).resize, 'hi')\n        self.assertRaises(ValueError, np.eye(3).resize, -1)\n        self.assertRaises(TypeError, np.eye(3).resize, order=1)\n        self.assertRaises(TypeError, np.eye(3).resize, refcheck='hi')\n\n    def test_freeform_shape(self):\n        x = np.eye(3)\n        x.resize(3, 2, 1)\n        assert_(x.shape == (3, 2, 1))\n\n    def test_zeros_appended(self):\n        x = np.eye(3)\n        x.resize(2, 3, 3)\n        assert_array_equal(x[0], np.eye(3))\n        assert_array_equal(x[1], np.zeros((3, 3)))\n\n\nclass TestRecord(TestCase):\n    def test_field_rename(self):\n        dt = np.dtype([('f', float), ('i', int)])\n        dt.names = ['p', 'q']\n        assert_equal(dt.names, ['p', 'q'])\n\n    if sys.version_info[0] >= 3:\n        def test_bytes_fields(self):\n            # Bytes are not allowed in field names and not recognized in titles\n            # on Py3\n            assert_raises(TypeError, np.dtype, [(asbytes('a'), int)])\n            assert_raises(TypeError, np.dtype, [(('b', asbytes('a')), int)])\n\n            dt = np.dtype([((asbytes('a'), 'b'), int)])\n            assert_raises(ValueError, dt.__getitem__, asbytes('a'))\n\n            x = np.array([(1,), (2,), (3,)], dtype=dt)\n            assert_raises(ValueError, x.__getitem__, asbytes('a'))\n\n            y = x[0]\n            assert_raises(IndexError, y.__getitem__, asbytes('a'))\n    else:\n        def test_unicode_field_titles(self):\n            # Unicode field titles are added to field dict on Py2\n            title = unicode('b')\n            dt = np.dtype([((title, 'a'), int)])\n            dt[title]\n            dt['a']\n            x = np.array([(1,), (2,), (3,)], dtype=dt)\n            x[title]\n            x['a']\n            y = x[0]\n            y[title]\n            y['a']\n\n        def test_unicode_field_names(self):\n            # Unicode field names are not allowed on Py2\n            title = unicode('b')\n            assert_raises(TypeError, np.dtype, [(title, int)])\n            assert_raises(TypeError, np.dtype, [(('a', title), int)])\n\n    def test_field_names(self):\n        # Test unicode and 8-bit / byte strings can be used\n        a = np.zeros((1,), dtype=[('f1', 'i4'),\n                                  ('f2', 'i4'),\n                                  ('f3', [('sf1', 'i4')])])\n        is_py3 = sys.version_info[0] >= 3\n        if is_py3:\n            funcs = (str,)\n            # byte string indexing fails gracefully\n            assert_raises(ValueError, a.__setitem__, asbytes('f1'), 1)\n            assert_raises(ValueError, a.__getitem__, asbytes('f1'))\n            assert_raises(ValueError, a['f1'].__setitem__, asbytes('sf1'), 1)\n            assert_raises(ValueError, a['f1'].__getitem__, asbytes('sf1'))\n        else:\n            funcs = (str, unicode)\n        for func in funcs:\n            b = a.copy()\n            fn1 = func('f1')\n            b[fn1] = 1\n            assert_equal(b[fn1], 1)\n            fnn = func('not at all')\n            assert_raises(ValueError, b.__setitem__, fnn, 1)\n            assert_raises(ValueError, b.__getitem__, fnn)\n            b[0][fn1] = 2\n            assert_equal(b[fn1], 2)\n            # Subfield\n            assert_raises(IndexError, b[0].__setitem__, fnn, 1)\n            assert_raises(IndexError, b[0].__getitem__, fnn)\n            # Subfield\n            fn3 = func('f3')\n            sfn1 = func('sf1')\n            b[fn3][sfn1] = 1\n            assert_equal(b[fn3][sfn1], 1)\n            assert_raises(ValueError, b[fn3].__setitem__, fnn, 1)\n            assert_raises(ValueError, b[fn3].__getitem__, fnn)\n            # multiple Subfields\n            fn2 = func('f2')\n            b[fn2] = 3\n            assert_equal(b[['f1', 'f2']][0].tolist(), (2, 3))\n            assert_equal(b[['f2', 'f1']][0].tolist(), (3, 2))\n            assert_equal(b[['f1', 'f3']][0].tolist(), (2, (1,)))\n            # view of subfield view/copy\n            assert_equal(b[['f1', 'f2']][0].view(('i4', 2)).tolist(), (2, 3))\n            assert_equal(b[['f2', 'f1']][0].view(('i4', 2)).tolist(), (3, 2))\n            view_dtype=[('f1', 'i4'), ('f3', [('', 'i4')])]\n            assert_equal(b[['f1', 'f3']][0].view(view_dtype).tolist(), (2, (1,)))\n        # non-ascii unicode field indexing is well behaved\n        if not is_py3:\n            raise SkipTest('non ascii unicode field indexing skipped; '\n                           'raises segfault on python 2.x')\n        else:\n            assert_raises(ValueError, a.__setitem__, sixu('\\u03e0'), 1)\n            assert_raises(ValueError, a.__getitem__, sixu('\\u03e0'))\n\n    def test_field_names_deprecation(self):\n\n        def collect_warning_types(f, *args, **kwargs):\n            with warnings.catch_warnings(record=True) as log:\n                warnings.simplefilter(\"always\")\n                f(*args, **kwargs)\n            return [w.category for w in log]\n\n        a = np.zeros((1,), dtype=[('f1', 'i4'),\n                                  ('f2', 'i4'),\n                                  ('f3', [('sf1', 'i4')])])\n        a['f1'][0] = 1\n        a['f2'][0] = 2\n        a['f3'][0] = (3,)\n        b = np.zeros((1,), dtype=[('f1', 'i4'),\n                                  ('f2', 'i4'),\n                                  ('f3', [('sf1', 'i4')])])\n        b['f1'][0] = 1\n        b['f2'][0] = 2\n        b['f3'][0] = (3,)\n\n        # All the different functions raise a warning, but not an error, and\n        # 'a' is not modified:\n        assert_equal(collect_warning_types(a[['f1', 'f2']].__setitem__, 0, (10, 20)),\n                     [FutureWarning])\n        assert_equal(a, b)\n        # Views also warn\n        subset = a[['f1', 'f2']]\n        subset_view = subset.view()\n        assert_equal(collect_warning_types(subset_view['f1'].__setitem__, 0, 10),\n                     [FutureWarning])\n        # But the write goes through:\n        assert_equal(subset['f1'][0], 10)\n        # Only one warning per multiple field indexing, though (even if there are\n        # multiple views involved):\n        assert_equal(collect_warning_types(subset['f1'].__setitem__, 0, 10),\n                     [])\n\n    def test_record_hash(self):\n        a = np.array([(1, 2), (1, 2)], dtype='i1,i2')\n        a.flags.writeable = False\n        b = np.array([(1, 2), (3, 4)], dtype=[('num1', 'i1'), ('num2', 'i2')])\n        b.flags.writeable = False\n        c = np.array([(1, 2), (3, 4)], dtype='i1,i2')\n        c.flags.writeable = False\n        self.assertTrue(hash(a[0]) == hash(a[1]))\n        self.assertTrue(hash(a[0]) == hash(b[0]))\n        self.assertTrue(hash(a[0]) != hash(b[1]))\n        self.assertTrue(hash(c[0]) == hash(a[0]) and c[0] == a[0])\n\n    def test_record_no_hash(self):\n        a = np.array([(1, 2), (1, 2)], dtype='i1,i2')\n        self.assertRaises(TypeError, hash, a[0])\n\nclass TestView(TestCase):\n    def test_basic(self):\n        x = np.array([(1, 2, 3, 4), (5, 6, 7, 8)], dtype=[('r', np.int8), ('g', np.int8),\n                                                  ('b', np.int8), ('a', np.int8)])\n        # We must be specific about the endianness here:\n        y = x.view(dtype='<i4')\n        # ... and again without the keyword.\n        z = x.view('<i4')\n        assert_array_equal(y, z)\n        assert_array_equal(y, [67305985, 134678021])\n\ndef _mean(a, **args):\n    return a.mean(**args)\n\ndef _var(a, **args):\n    return a.var(**args)\n\ndef _std(a, **args):\n    return a.std(**args)\n\nclass TestStats(TestCase):\n\n    funcs = [_mean, _var, _std]\n\n    def setUp(self):\n        np.random.seed(range(3))\n        self.rmat = np.random.random((4, 5))\n        self.cmat = self.rmat + 1j * self.rmat\n\n    def test_keepdims(self):\n        mat = np.eye(3)\n        for f in self.funcs:\n            for axis in [0, 1]:\n                res = f(mat, axis=axis, keepdims=True)\n                assert_(res.ndim == mat.ndim)\n                assert_(res.shape[axis] == 1)\n            for axis in [None]:\n                res = f(mat, axis=axis, keepdims=True)\n                assert_(res.shape == (1, 1))\n\n    def test_out(self):\n        mat = np.eye(3)\n        for f in self.funcs:\n            out = np.zeros(3)\n            tgt = f(mat, axis=1)\n            res = f(mat, axis=1, out=out)\n            assert_almost_equal(res, out)\n            assert_almost_equal(res, tgt)\n        out = np.empty(2)\n        assert_raises(ValueError, f, mat, axis=1, out=out)\n        out = np.empty((2, 2))\n        assert_raises(ValueError, f, mat, axis=1, out=out)\n\n    def test_dtype_from_input(self):\n        icodes = np.typecodes['AllInteger']\n        fcodes = np.typecodes['AllFloat']\n\n        # integer types\n        for f in self.funcs:\n            for c in icodes:\n                mat = np.eye(3, dtype=c)\n                tgt = np.float64\n                res = f(mat, axis=1).dtype.type\n                assert_(res is tgt)\n                # scalar case\n                res = f(mat, axis=None).dtype.type\n                assert_(res is tgt)\n        # mean for float types\n        for f in [_mean]:\n            for c in fcodes:\n                mat = np.eye(3, dtype=c)\n                tgt = mat.dtype.type\n                res = f(mat, axis=1).dtype.type\n                assert_(res is tgt)\n                # scalar case\n                res = f(mat, axis=None).dtype.type\n                assert_(res is tgt)\n        # var, std for float types\n        for f in [_var, _std]:\n            for c in fcodes:\n                mat = np.eye(3, dtype=c)\n                tgt = mat.real.dtype.type\n                res = f(mat, axis=1).dtype.type\n                assert_(res is tgt)\n                # scalar case\n                res = f(mat, axis=None).dtype.type\n                assert_(res is tgt)\n\n    def test_dtype_from_dtype(self):\n        icodes = np.typecodes['AllInteger']\n        fcodes = np.typecodes['AllFloat']\n        mat = np.eye(3)\n\n        # stats for integer types\n        # fixme:\n        # this needs definition as there are lots places along the line\n        # where type casting may take place.\n        #for f in self.funcs:\n            #for c in icodes:\n                #tgt = np.dtype(c).type\n                #res = f(mat, axis=1, dtype=c).dtype.type\n                #assert_(res is tgt)\n                ## scalar case\n                #res = f(mat, axis=None, dtype=c).dtype.type\n                #assert_(res is tgt)\n\n        # stats for float types\n        for f in self.funcs:\n            for c in fcodes:\n                tgt = np.dtype(c).type\n                res = f(mat, axis=1, dtype=c).dtype.type\n                assert_(res is tgt)\n                # scalar case\n                res = f(mat, axis=None, dtype=c).dtype.type\n                assert_(res is tgt)\n\n    def test_ddof(self):\n        for f in [_var]:\n            for ddof in range(3):\n                dim = self.rmat.shape[1]\n                tgt = f(self.rmat, axis=1) * dim\n                res = f(self.rmat, axis=1, ddof=ddof) * (dim - ddof)\n        for f in [_std]:\n            for ddof in range(3):\n                dim = self.rmat.shape[1]\n                tgt = f(self.rmat, axis=1) * np.sqrt(dim)\n                res = f(self.rmat, axis=1, ddof=ddof) * np.sqrt(dim - ddof)\n                assert_almost_equal(res, tgt)\n                assert_almost_equal(res, tgt)\n\n    def test_ddof_too_big(self):\n        dim = self.rmat.shape[1]\n        for f in [_var, _std]:\n            for ddof in range(dim, dim + 2):\n                with warnings.catch_warnings(record=True) as w:\n                    warnings.simplefilter('always')\n                    res = f(self.rmat, axis=1, ddof=ddof)\n                    assert_(not (res < 0).any())\n                    assert_(len(w) > 0)\n                    assert_(issubclass(w[0].category, RuntimeWarning))\n\n    def test_empty(self):\n        A = np.zeros((0, 3))\n        for f in self.funcs:\n            for axis in [0, None]:\n                with warnings.catch_warnings(record=True) as w:\n                    warnings.simplefilter('always')\n                    assert_(np.isnan(f(A, axis=axis)).all())\n                    assert_(len(w) > 0)\n                    assert_(issubclass(w[0].category, RuntimeWarning))\n            for axis in [1]:\n                with warnings.catch_warnings(record=True) as w:\n                    warnings.simplefilter('always')\n                    assert_equal(f(A, axis=axis), np.zeros([]))\n\n    def test_mean_values(self):\n        for mat in [self.rmat, self.cmat]:\n            for axis in [0, 1]:\n                tgt = mat.sum(axis=axis)\n                res = _mean(mat, axis=axis) * mat.shape[axis]\n                assert_almost_equal(res, tgt)\n            for axis in [None]:\n                tgt = mat.sum(axis=axis)\n                res = _mean(mat, axis=axis) * np.prod(mat.shape)\n                assert_almost_equal(res, tgt)\n\n    def test_var_values(self):\n        for mat in [self.rmat, self.cmat]:\n            for axis in [0, 1, None]:\n                msqr = _mean(mat * mat.conj(), axis=axis)\n                mean = _mean(mat, axis=axis)\n                tgt = msqr - mean * mean.conj()\n                res = _var(mat, axis=axis)\n                assert_almost_equal(res, tgt)\n\n    def test_std_values(self):\n        for mat in [self.rmat, self.cmat]:\n            for axis in [0, 1, None]:\n                tgt = np.sqrt(_var(mat, axis=axis))\n                res = _std(mat, axis=axis)\n                assert_almost_equal(res, tgt)\n\n\n    def test_subclass(self):\n        class TestArray(np.ndarray):\n            def __new__(cls, data, info):\n                result = np.array(data)\n                result = result.view(cls)\n                result.info = info\n                return result\n            def __array_finalize__(self, obj):\n                self.info = getattr(obj, \"info\", '')\n\n        dat = TestArray([[1, 2, 3, 4], [5, 6, 7, 8]], 'jubba')\n        res = dat.mean(1)\n        assert_(res.info == dat.info)\n        res = dat.std(1)\n        assert_(res.info == dat.info)\n        res = dat.var(1)\n        assert_(res.info == dat.info)\n\nclass TestDot(TestCase):\n    def test_dot_2args(self):\n        from numpy.core.multiarray import dot\n\n        a = np.array([[1, 2], [3, 4]], dtype=float)\n        b = np.array([[1, 0], [1, 1]], dtype=float)\n        c = np.array([[3, 2], [7, 4]], dtype=float)\n\n        d = dot(a, b)\n        assert_allclose(c, d)\n\n    def test_dot_3args(self):\n        from numpy.core.multiarray import dot\n\n        np.random.seed(22)\n        f = np.random.random_sample((1024, 16))\n        v = np.random.random_sample((16, 32))\n\n        r = np.empty((1024, 32))\n        for i in range(12):\n            dot(f, v, r)\n        assert_equal(sys.getrefcount(r), 2)\n        r2 = dot(f, v, out=None)\n        assert_array_equal(r2, r)\n        assert_(r is dot(f, v, out=r))\n\n        v = v[:, 0].copy() # v.shape == (16,)\n        r = r[:, 0].copy() # r.shape == (1024,)\n        r2 = dot(f, v)\n        assert_(r is dot(f, v, r))\n        assert_array_equal(r2, r)\n\n    def test_dot_3args_errors(self):\n        from numpy.core.multiarray import dot\n\n        np.random.seed(22)\n        f = np.random.random_sample((1024, 16))\n        v = np.random.random_sample((16, 32))\n\n        r = np.empty((1024, 31))\n        assert_raises(ValueError, dot, f, v, r)\n\n        r = np.empty((1024,))\n        assert_raises(ValueError, dot, f, v, r)\n\n        r = np.empty((32,))\n        assert_raises(ValueError, dot, f, v, r)\n\n        r = np.empty((32, 1024))\n        assert_raises(ValueError, dot, f, v, r)\n        assert_raises(ValueError, dot, f, v, r.T)\n\n        r = np.empty((1024, 64))\n        assert_raises(ValueError, dot, f, v, r[:, ::2])\n        assert_raises(ValueError, dot, f, v, r[:, :32])\n\n        r = np.empty((1024, 32), dtype=np.float32)\n        assert_raises(ValueError, dot, f, v, r)\n\n        r = np.empty((1024, 32), dtype=int)\n        assert_raises(ValueError, dot, f, v, r)\n\n\nclass TestSummarization(TestCase):\n    def test_1d(self):\n        A = np.arange(1001)\n        strA = '[   0    1    2 ...,  998  999 1000]'\n        assert_(str(A) == strA)\n\n        reprA = 'array([   0,    1,    2, ...,  998,  999, 1000])'\n        assert_(repr(A) == reprA)\n\n    def test_2d(self):\n        A = np.arange(1002).reshape(2, 501)\n        strA = '[[   0    1    2 ...,  498  499  500]\\n' \\\n               ' [ 501  502  503 ...,  999 1000 1001]]'\n        assert_(str(A) == strA)\n\n        reprA = 'array([[   0,    1,    2, ...,  498,  499,  500],\\n' \\\n                '       [ 501,  502,  503, ...,  999, 1000, 1001]])'\n        assert_(repr(A) == reprA)\n\n\nclass TestChoose(TestCase):\n    def setUp(self):\n        self.x = 2*ones((3,), dtype=int)\n        self.y = 3*ones((3,), dtype=int)\n        self.x2 = 2*ones((2, 3), dtype=int)\n        self.y2 = 3*ones((2, 3), dtype=int)\n        self.ind = [0, 0, 1]\n\n    def test_basic(self):\n        A = np.choose(self.ind, (self.x, self.y))\n        assert_equal(A, [2, 2, 3])\n\n    def test_broadcast1(self):\n        A = np.choose(self.ind, (self.x2, self.y2))\n        assert_equal(A, [[2, 2, 3], [2, 2, 3]])\n\n    def test_broadcast2(self):\n        A = np.choose(self.ind, (self.x, self.y2))\n        assert_equal(A, [[2, 2, 3], [2, 2, 3]])\n\ndef can_use_decimal():\n    try:\n        from decimal import Decimal\n        return True\n    except ImportError:\n        return False\n\n# TODO: test for multidimensional\nNEIGH_MODE = {'zero': 0, 'one': 1, 'constant': 2, 'circular': 3, 'mirror': 4}\nclass TestNeighborhoodIter(TestCase):\n    # Simple, 2d tests\n    def _test_simple2d(self, dt):\n        # Test zero and one padding for simple data type\n        x = np.array([[0, 1], [2, 3]], dtype=dt)\n        r = [np.array([[0, 0, 0], [0, 0, 1]], dtype=dt),\n             np.array([[0, 0, 0], [0, 1, 0]], dtype=dt),\n             np.array([[0, 0, 1], [0, 2, 3]], dtype=dt),\n             np.array([[0, 1, 0], [2, 3, 0]], dtype=dt)]\n        l = test_neighborhood_iterator(x, [-1, 0, -1, 1], x[0],\n                NEIGH_MODE['zero'])\n        assert_array_equal(l, r)\n\n        r = [np.array([[1, 1, 1], [1, 0, 1]], dtype=dt),\n             np.array([[1, 1, 1], [0, 1, 1]], dtype=dt),\n             np.array([[1, 0, 1], [1, 2, 3]], dtype=dt),\n             np.array([[0, 1, 1], [2, 3, 1]], dtype=dt)]\n        l = test_neighborhood_iterator(x, [-1, 0, -1, 1], x[0],\n                NEIGH_MODE['one'])\n        assert_array_equal(l, r)\n\n        r = [np.array([[4, 4, 4], [4, 0, 1]], dtype=dt),\n             np.array([[4, 4, 4], [0, 1, 4]], dtype=dt),\n             np.array([[4, 0, 1], [4, 2, 3]], dtype=dt),\n             np.array([[0, 1, 4], [2, 3, 4]], dtype=dt)]\n        l = test_neighborhood_iterator(x, [-1, 0, -1, 1], 4,\n                NEIGH_MODE['constant'])\n        assert_array_equal(l, r)\n\n    def test_simple2d(self):\n        self._test_simple2d(np.float)\n\n    @dec.skipif(not can_use_decimal(),\n            \"Skip neighborhood iterator tests for decimal objects \" \\\n            \"(decimal module not available\")\n    def test_simple2d_object(self):\n        from decimal import Decimal\n        self._test_simple2d(Decimal)\n\n    def _test_mirror2d(self, dt):\n        x = np.array([[0, 1], [2, 3]], dtype=dt)\n        r = [np.array([[0, 0, 1], [0, 0, 1]], dtype=dt),\n             np.array([[0, 1, 1], [0, 1, 1]], dtype=dt),\n             np.array([[0, 0, 1], [2, 2, 3]], dtype=dt),\n             np.array([[0, 1, 1], [2, 3, 3]], dtype=dt)]\n        l = test_neighborhood_iterator(x, [-1, 0, -1, 1], x[0],\n                NEIGH_MODE['mirror'])\n        assert_array_equal(l, r)\n\n    def test_mirror2d(self):\n        self._test_mirror2d(np.float)\n\n    @dec.skipif(not can_use_decimal(),\n            \"Skip neighborhood iterator tests for decimal objects \" \\\n            \"(decimal module not available\")\n    def test_mirror2d_object(self):\n        from decimal import Decimal\n        self._test_mirror2d(Decimal)\n\n    # Simple, 1d tests\n    def _test_simple(self, dt):\n        # Test padding with constant values\n        x = np.linspace(1, 5, 5).astype(dt)\n        r = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 0]]\n        l = test_neighborhood_iterator(x, [-1, 1], x[0], NEIGH_MODE['zero'])\n        assert_array_equal(l, r)\n\n        r = [[1, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 1]]\n        l = test_neighborhood_iterator(x, [-1, 1], x[0], NEIGH_MODE['one'])\n        assert_array_equal(l, r)\n\n        r = [[x[4], 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, x[4]]]\n        l = test_neighborhood_iterator(x, [-1, 1], x[4], NEIGH_MODE['constant'])\n        assert_array_equal(l, r)\n\n    def test_simple_float(self):\n        self._test_simple(np.float)\n\n    @dec.skipif(not can_use_decimal(),\n            \"Skip neighborhood iterator tests for decimal objects \" \\\n            \"(decimal module not available\")\n    def test_simple_object(self):\n        from decimal import Decimal\n        self._test_simple(Decimal)\n\n    # Test mirror modes\n    def _test_mirror(self, dt):\n        x = np.linspace(1, 5, 5).astype(dt)\n        r = np.array([[2, 1, 1, 2, 3], [1, 1, 2, 3, 4], [1, 2, 3, 4, 5],\n                [2, 3, 4, 5, 5], [3, 4, 5, 5, 4]], dtype=dt)\n        l = test_neighborhood_iterator(x, [-2, 2], x[1], NEIGH_MODE['mirror'])\n        self.assertTrue([i.dtype == dt for i in l])\n        assert_array_equal(l, r)\n\n    def test_mirror(self):\n        self._test_mirror(np.float)\n\n    @dec.skipif(not can_use_decimal(),\n            \"Skip neighborhood iterator tests for decimal objects \" \\\n            \"(decimal module not available\")\n    def test_mirror_object(self):\n        from decimal import Decimal\n        self._test_mirror(Decimal)\n\n    # Circular mode\n    def _test_circular(self, dt):\n        x = np.linspace(1, 5, 5).astype(dt)\n        r = np.array([[4, 5, 1, 2, 3], [5, 1, 2, 3, 4], [1, 2, 3, 4, 5],\n                [2, 3, 4, 5, 1], [3, 4, 5, 1, 2]], dtype=dt)\n        l = test_neighborhood_iterator(x, [-2, 2], x[0], NEIGH_MODE['circular'])\n        assert_array_equal(l, r)\n\n    def test_circular(self):\n        self._test_circular(np.float)\n\n    @dec.skipif(not can_use_decimal(),\n            \"Skip neighborhood iterator tests for decimal objects \" \\\n            \"(decimal module not available\")\n    def test_circular_object(self):\n        from decimal import Decimal\n        self._test_circular(Decimal)\n\n# Test stacking neighborhood iterators\nclass TestStackedNeighborhoodIter(TestCase):\n    # Simple, 1d test: stacking 2 constant-padded neigh iterators\n    def test_simple_const(self):\n        dt = np.float64\n        # Test zero and one padding for simple data type\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([0], dtype=dt),\n             np.array([0], dtype=dt),\n             np.array([1], dtype=dt),\n             np.array([2], dtype=dt),\n             np.array([3], dtype=dt),\n             np.array([0], dtype=dt),\n             np.array([0], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-2, 4], NEIGH_MODE['zero'],\n                [0, 0], NEIGH_MODE['zero'])\n        assert_array_equal(l, r)\n\n        r = [np.array([1, 0, 1], dtype=dt),\n             np.array([0, 1, 2], dtype=dt),\n             np.array([1, 2, 3], dtype=dt),\n             np.array([2, 3, 0], dtype=dt),\n             np.array([3, 0, 1], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n                [-1, 1], NEIGH_MODE['one'])\n        assert_array_equal(l, r)\n\n    # 2nd simple, 1d test: stacking 2 neigh iterators, mixing const padding and\n    # mirror padding\n    def test_simple_mirror(self):\n        dt = np.float64\n        # Stacking zero on top of mirror\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([0, 1, 1], dtype=dt),\n             np.array([1, 1, 2], dtype=dt),\n             np.array([1, 2, 3], dtype=dt),\n             np.array([2, 3, 3], dtype=dt),\n             np.array([3, 3, 0], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['mirror'],\n                [-1, 1], NEIGH_MODE['zero'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([1, 0, 0], dtype=dt),\n             np.array([0, 0, 1], dtype=dt),\n             np.array([0, 1, 2], dtype=dt),\n             np.array([1, 2, 3], dtype=dt),\n             np.array([2, 3, 0], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n                [-2, 0], NEIGH_MODE['mirror'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero: 2nd\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([0, 1, 2], dtype=dt),\n             np.array([1, 2, 3], dtype=dt),\n             np.array([2, 3, 0], dtype=dt),\n             np.array([3, 0, 0], dtype=dt),\n             np.array([0, 0, 3], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n                [0, 2], NEIGH_MODE['mirror'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero: 3rd\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([1, 0, 0, 1, 2], dtype=dt),\n             np.array([0, 0, 1, 2, 3], dtype=dt),\n             np.array([0, 1, 2, 3, 0], dtype=dt),\n             np.array([1, 2, 3, 0, 0], dtype=dt),\n             np.array([2, 3, 0, 0, 3], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n                [-2, 2], NEIGH_MODE['mirror'])\n        assert_array_equal(l, r)\n\n    # 3rd simple, 1d test: stacking 2 neigh iterators, mixing const padding and\n    # circular padding\n    def test_simple_circular(self):\n        dt = np.float64\n        # Stacking zero on top of mirror\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([0, 3, 1], dtype=dt),\n             np.array([3, 1, 2], dtype=dt),\n             np.array([1, 2, 3], dtype=dt),\n             np.array([2, 3, 1], dtype=dt),\n             np.array([3, 1, 0], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['circular'],\n                [-1, 1], NEIGH_MODE['zero'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([3, 0, 0], dtype=dt),\n             np.array([0, 0, 1], dtype=dt),\n             np.array([0, 1, 2], dtype=dt),\n             np.array([1, 2, 3], dtype=dt),\n             np.array([2, 3, 0], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n                [-2, 0], NEIGH_MODE['circular'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero: 2nd\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([0, 1, 2], dtype=dt),\n             np.array([1, 2, 3], dtype=dt),\n             np.array([2, 3, 0], dtype=dt),\n             np.array([3, 0, 0], dtype=dt),\n             np.array([0, 0, 1], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n                [0, 2], NEIGH_MODE['circular'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero: 3rd\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([3, 0, 0, 1, 2], dtype=dt),\n             np.array([0, 0, 1, 2, 3], dtype=dt),\n             np.array([0, 1, 2, 3, 0], dtype=dt),\n             np.array([1, 2, 3, 0, 0], dtype=dt),\n             np.array([2, 3, 0, 0, 1], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n                [-2, 2], NEIGH_MODE['circular'])\n        assert_array_equal(l, r)\n\n    # 4th simple, 1d test: stacking 2 neigh iterators, but with lower iterator\n    # being strictly within the array\n    def test_simple_strict_within(self):\n        dt = np.float64\n        # Stacking zero on top of zero, first neighborhood strictly inside the\n        # array\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([1, 2, 3, 0], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [1, 1], NEIGH_MODE['zero'],\n                [-1, 2], NEIGH_MODE['zero'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero, first neighborhood strictly inside the\n        # array\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([1, 2, 3, 3], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [1, 1], NEIGH_MODE['zero'],\n                [-1, 2], NEIGH_MODE['mirror'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero, first neighborhood strictly inside the\n        # array\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([1, 2, 3, 1], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [1, 1], NEIGH_MODE['zero'],\n                [-1, 2], NEIGH_MODE['circular'])\n        assert_array_equal(l, r)\n\nclass TestWarnings(object):\n\n    def test_complex_warning(self):\n        x = np.array([1, 2])\n        y = np.array([1-2j, 1+2j])\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"error\", np.ComplexWarning)\n            assert_raises(np.ComplexWarning, x.__setitem__, slice(None), y)\n            assert_equal(x, [1, 2])\n\nclass TestMinScalarType(object):\n\n    def test_usigned_shortshort(self):\n        dt = np.min_scalar_type(2**8-1)\n        wanted = np.dtype('uint8')\n        assert_equal(wanted, dt)\n\n    def test_usigned_short(self):\n        dt = np.min_scalar_type(2**16-1)\n        wanted = np.dtype('uint16')\n        assert_equal(wanted, dt)\n\n    def test_usigned_int(self):\n        dt = np.min_scalar_type(2**32-1)\n        wanted = np.dtype('uint32')\n        assert_equal(wanted, dt)\n\n    def test_usigned_longlong(self):\n        dt = np.min_scalar_type(2**63-1)\n        wanted = np.dtype('uint64')\n        assert_equal(wanted, dt)\n\n    def test_object(self):\n        dt = np.min_scalar_type(2**64)\n        wanted = np.dtype('O')\n        assert_equal(wanted, dt)\n\n\nif sys.version_info[:2] == (2, 6):\n    from numpy.core.multiarray import memorysimpleview as memoryview\n\nfrom numpy.core._internal import _dtype_from_pep3118\n\nclass TestPEP3118Dtype(object):\n    def _check(self, spec, wanted):\n        dt = np.dtype(wanted)\n        if isinstance(wanted, list) and isinstance(wanted[-1], tuple):\n            if wanted[-1][0] == '':\n                names = list(dt.names)\n                names[-1] = ''\n                dt.names = tuple(names)\n        assert_equal(_dtype_from_pep3118(spec), dt,\n                     err_msg=\"spec %r != dtype %r\" % (spec, wanted))\n\n    def test_native_padding(self):\n        align = np.dtype('i').alignment\n        for j in range(8):\n            if j == 0:\n                s = 'bi'\n            else:\n                s = 'b%dxi' % j\n            self._check('@'+s, {'f0': ('i1', 0),\n                                'f1': ('i', align*(1 + j//align))})\n            self._check('='+s, {'f0': ('i1', 0),\n                                'f1': ('i', 1+j)})\n\n    def test_native_padding_2(self):\n        # Native padding should work also for structs and sub-arrays\n        self._check('x3T{xi}', {'f0': (({'f0': ('i', 4)}, (3,)), 4)})\n        self._check('^x3T{xi}', {'f0': (({'f0': ('i', 1)}, (3,)), 1)})\n\n    def test_trailing_padding(self):\n        # Trailing padding should be included, *and*, the item size\n        # should match the alignment if in aligned mode\n        align = np.dtype('i').alignment\n        def VV(n):\n            return 'V%d' % (align*(1 + (n-1)//align))\n\n        self._check('ix', [('f0', 'i'), ('', VV(1))])\n        self._check('ixx', [('f0', 'i'), ('', VV(2))])\n        self._check('ixxx', [('f0', 'i'), ('', VV(3))])\n        self._check('ixxxx', [('f0', 'i'), ('', VV(4))])\n        self._check('i7x', [('f0', 'i'), ('', VV(7))])\n\n        self._check('^ix', [('f0', 'i'), ('', 'V1')])\n        self._check('^ixx', [('f0', 'i'), ('', 'V2')])\n        self._check('^ixxx', [('f0', 'i'), ('', 'V3')])\n        self._check('^ixxxx', [('f0', 'i'), ('', 'V4')])\n        self._check('^i7x', [('f0', 'i'), ('', 'V7')])\n\n    def test_native_padding_3(self):\n        dt = np.dtype(\n                [('a', 'b'), ('b', 'i'),\n                    ('sub', np.dtype('b,i')), ('c', 'i')],\n                align=True)\n        self._check(\"T{b:a:xxxi:b:T{b:f0:=i:f1:}:sub:xxxi:c:}\", dt)\n\n        dt = np.dtype(\n                [('a', 'b'), ('b', 'i'), ('c', 'b'), ('d', 'b'),\n                    ('e', 'b'), ('sub', np.dtype('b,i', align=True))])\n        self._check(\"T{b:a:=i:b:b:c:b:d:b:e:T{b:f0:xxxi:f1:}:sub:}\", dt)\n\n    def test_padding_with_array_inside_struct(self):\n        dt = np.dtype(\n                [('a', 'b'), ('b', 'i'), ('c', 'b', (3,)),\n                    ('d', 'i')],\n                align=True)\n        self._check(\"T{b:a:xxxi:b:3b:c:xi:d:}\", dt)\n\n    def test_byteorder_inside_struct(self):\n        # The byte order after @T{=i} should be '=', not '@'.\n        # Check this by noting the absence of native alignment.\n        self._check('@T{^i}xi', {'f0': ({'f0': ('i', 0)}, 0),\n                                 'f1': ('i', 5)})\n\n    def test_intra_padding(self):\n        # Natively aligned sub-arrays may require some internal padding\n        align = np.dtype('i').alignment\n        def VV(n):\n            return 'V%d' % (align*(1 + (n-1)//align))\n\n        self._check('(3)T{ix}', ({'f0': ('i', 0), '': (VV(1), 4)}, (3,)))\n\nclass TestNewBufferProtocol(object):\n    def _check_roundtrip(self, obj):\n        obj = np.asarray(obj)\n        x = memoryview(obj)\n        y = np.asarray(x)\n        y2 = np.array(x)\n        assert_(not y.flags.owndata)\n        assert_(y2.flags.owndata)\n\n        assert_equal(y.dtype, obj.dtype)\n        assert_equal(y.shape, obj.shape)\n        assert_array_equal(obj, y)\n\n        assert_equal(y2.dtype, obj.dtype)\n        assert_equal(y2.shape, obj.shape)\n        assert_array_equal(obj, y2)\n\n    def test_roundtrip(self):\n        x = np.array([1, 2, 3, 4, 5], dtype='i4')\n        self._check_roundtrip(x)\n\n        x = np.array([[1, 2], [3, 4]], dtype=np.float64)\n        self._check_roundtrip(x)\n\n        x = np.zeros((3, 3, 3), dtype=np.float32)[:, 0,:]\n        self._check_roundtrip(x)\n\n        dt = [('a', 'b'),\n              ('b', 'h'),\n              ('c', 'i'),\n              ('d', 'l'),\n              ('dx', 'q'),\n              ('e', 'B'),\n              ('f', 'H'),\n              ('g', 'I'),\n              ('h', 'L'),\n              ('hx', 'Q'),\n              ('i', np.single),\n              ('j', np.double),\n              ('k', np.longdouble),\n              ('ix', np.csingle),\n              ('jx', np.cdouble),\n              ('kx', np.clongdouble),\n              ('l', 'S4'),\n              ('m', 'U4'),\n              ('n', 'V3'),\n              ('o', '?'),\n              ('p', np.half),\n             ]\n        x = np.array(\n                [(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                    asbytes('aaaa'), 'bbbb', asbytes('xxx'), True, 1.0)],\n                dtype=dt)\n        self._check_roundtrip(x)\n\n        x = np.array(([[1, 2], [3, 4]],), dtype=[('a', (int, (2, 2)))])\n        self._check_roundtrip(x)\n\n        x = np.array([1, 2, 3], dtype='>i2')\n        self._check_roundtrip(x)\n\n        x = np.array([1, 2, 3], dtype='<i2')\n        self._check_roundtrip(x)\n\n        x = np.array([1, 2, 3], dtype='>i4')\n        self._check_roundtrip(x)\n\n        x = np.array([1, 2, 3], dtype='<i4')\n        self._check_roundtrip(x)\n\n        # check long long can be represented as non-native\n        x = np.array([1, 2, 3], dtype='>q')\n        self._check_roundtrip(x)\n\n        # Native-only data types can be passed through the buffer interface\n        # only in native byte order\n        if sys.byteorder == 'little':\n            x = np.array([1, 2, 3], dtype='>g')\n            assert_raises(ValueError, self._check_roundtrip, x)\n            x = np.array([1, 2, 3], dtype='<g')\n            self._check_roundtrip(x)\n        else:\n            x = np.array([1, 2, 3], dtype='>g')\n            self._check_roundtrip(x)\n            x = np.array([1, 2, 3], dtype='<g')\n            assert_raises(ValueError, self._check_roundtrip, x)\n\n    def test_roundtrip_half(self):\n        half_list = [\n            1.0,\n            -2.0,\n            6.5504 * 10**4, #  (max half precision)\n            2**-14, # ~= 6.10352 * 10**-5 (minimum positive normal)\n            2**-24, # ~= 5.96046 * 10**-8 (minimum strictly positive subnormal)\n            0.0,\n            -0.0,\n            float('+inf'),\n            float('-inf'),\n            0.333251953125, # ~= 1/3\n        ]\n\n        x = np.array(half_list, dtype='>e')\n        self._check_roundtrip(x)\n        x = np.array(half_list, dtype='<e')\n        self._check_roundtrip(x)\n\n    def test_roundtrip_single_types(self):\n        for typ in np.typeDict.values():\n            dtype = np.dtype(typ)\n\n            if dtype.char in 'Mm':\n                # datetimes cannot be used in buffers\n                continue\n            if dtype.char == 'V':\n                # skip void\n                continue\n\n            x = np.zeros(4, dtype=dtype)\n            self._check_roundtrip(x)\n\n            if dtype.char not in 'qQgG':\n                dt = dtype.newbyteorder('<')\n                x = np.zeros(4, dtype=dt)\n                self._check_roundtrip(x)\n\n                dt = dtype.newbyteorder('>')\n                x = np.zeros(4, dtype=dt)\n                self._check_roundtrip(x)\n\n    def test_roundtrip_scalar(self):\n        # Issue #4015.\n        self._check_roundtrip(0)\n\n    def test_export_simple_1d(self):\n        x = np.array([1, 2, 3, 4, 5], dtype='i')\n        y = memoryview(x)\n        assert_equal(y.format, 'i')\n        assert_equal(y.shape, (5,))\n        assert_equal(y.ndim, 1)\n        assert_equal(y.strides, (4,))\n        assert_equal(y.suboffsets, EMPTY)\n        assert_equal(y.itemsize, 4)\n\n    def test_export_simple_nd(self):\n        x = np.array([[1, 2], [3, 4]], dtype=np.float64)\n        y = memoryview(x)\n        assert_equal(y.format, 'd')\n        assert_equal(y.shape, (2, 2))\n        assert_equal(y.ndim, 2)\n        assert_equal(y.strides, (16, 8))\n        assert_equal(y.suboffsets, EMPTY)\n        assert_equal(y.itemsize, 8)\n\n    def test_export_discontiguous(self):\n        x = np.zeros((3, 3, 3), dtype=np.float32)[:, 0,:]\n        y = memoryview(x)\n        assert_equal(y.format, 'f')\n        assert_equal(y.shape, (3, 3))\n        assert_equal(y.ndim, 2)\n        assert_equal(y.strides, (36, 4))\n        assert_equal(y.suboffsets, EMPTY)\n        assert_equal(y.itemsize, 4)\n\n    def test_export_record(self):\n        dt = [('a', 'b'),\n              ('b', 'h'),\n              ('c', 'i'),\n              ('d', 'l'),\n              ('dx', 'q'),\n              ('e', 'B'),\n              ('f', 'H'),\n              ('g', 'I'),\n              ('h', 'L'),\n              ('hx', 'Q'),\n              ('i', np.single),\n              ('j', np.double),\n              ('k', np.longdouble),\n              ('ix', np.csingle),\n              ('jx', np.cdouble),\n              ('kx', np.clongdouble),\n              ('l', 'S4'),\n              ('m', 'U4'),\n              ('n', 'V3'),\n              ('o', '?'),\n              ('p', np.half),\n             ]\n        x = np.array(\n                [(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                    asbytes('aaaa'), 'bbbb', asbytes('   '), True, 1.0)],\n                dtype=dt)\n        y = memoryview(x)\n        assert_equal(y.shape, (1,))\n        assert_equal(y.ndim, 1)\n        assert_equal(y.suboffsets, EMPTY)\n\n        sz = sum([dtype(b).itemsize for a, b in dt])\n        if dtype('l').itemsize == 4:\n            assert_equal(y.format, 'T{b:a:=h:b:i:c:l:d:q:dx:B:e:@H:f:=I:g:L:h:Q:hx:f:i:d:j:^g:k:=Zf:ix:Zd:jx:^Zg:kx:4s:l:=4w:m:3x:n:?:o:@e:p:}')\n        else:\n            assert_equal(y.format, 'T{b:a:=h:b:i:c:q:d:q:dx:B:e:@H:f:=I:g:Q:h:Q:hx:f:i:d:j:^g:k:=Zf:ix:Zd:jx:^Zg:kx:4s:l:=4w:m:3x:n:?:o:@e:p:}')\n        # Cannot test if NPY_RELAXED_STRIDES_CHECKING changes the strides\n        if not (np.ones(1).strides[0] == np.iinfo(np.intp).max):\n            assert_equal(y.strides, (sz,))\n        assert_equal(y.itemsize, sz)\n\n    def test_export_subarray(self):\n        x = np.array(([[1, 2], [3, 4]],), dtype=[('a', ('i', (2, 2)))])\n        y = memoryview(x)\n        assert_equal(y.format, 'T{(2,2)i:a:}')\n        assert_equal(y.shape, EMPTY)\n        assert_equal(y.ndim, 0)\n        assert_equal(y.strides, EMPTY)\n        assert_equal(y.suboffsets, EMPTY)\n        assert_equal(y.itemsize, 16)\n\n    def test_export_endian(self):\n        x = np.array([1, 2, 3], dtype='>i')\n        y = memoryview(x)\n        if sys.byteorder == 'little':\n            assert_equal(y.format, '>i')\n        else:\n            assert_equal(y.format, 'i')\n\n        x = np.array([1, 2, 3], dtype='<i')\n        y = memoryview(x)\n        if sys.byteorder == 'little':\n            assert_equal(y.format, 'i')\n        else:\n            assert_equal(y.format, '<i')\n\n    def test_export_flags(self):\n        # Check SIMPLE flag, see also gh-3613 (exception should be BufferError)\n        assert_raises(ValueError, get_buffer_info, np.arange(5)[::2], ('SIMPLE',))\n\n    def test_padding(self):\n        for j in range(8):\n            x = np.array([(1,), (2,)], dtype={'f0': (int, j)})\n            self._check_roundtrip(x)\n\n    def test_reference_leak(self):\n        count_1 = sys.getrefcount(np.core._internal)\n        a = np.zeros(4)\n        b = memoryview(a)\n        c = np.asarray(b)\n        count_2 = sys.getrefcount(np.core._internal)\n        assert_equal(count_1, count_2)\n\n    def test_padded_struct_array(self):\n        dt1 = np.dtype(\n                [('a', 'b'), ('b', 'i'), ('sub', np.dtype('b,i')), ('c', 'i')],\n                align=True)\n        x1 = np.arange(dt1.itemsize, dtype=np.int8).view(dt1)\n        self._check_roundtrip(x1)\n\n        dt2 = np.dtype(\n                [('a', 'b'), ('b', 'i'), ('c', 'b', (3,)), ('d', 'i')],\n                align=True)\n        x2 = np.arange(dt2.itemsize, dtype=np.int8).view(dt2)\n        self._check_roundtrip(x2)\n\n        dt3 = np.dtype(\n                [('a', 'b'), ('b', 'i'), ('c', 'b'), ('d', 'b'),\n                    ('e', 'b'), ('sub', np.dtype('b,i', align=True))])\n        x3 = np.arange(dt3.itemsize, dtype=np.int8).view(dt3)\n        self._check_roundtrip(x3)\n\n\nclass TestArrayAttributeDeletion(object):\n\n    def test_multiarray_writable_attributes_deletion(self):\n        \"\"\"ticket #2046, should not seqfault, raise AttributeError\"\"\"\n        a = np.ones(2)\n        attr =  ['shape', 'strides', 'data', 'dtype', 'real', 'imag', 'flat']\n        for s in attr:\n            assert_raises(AttributeError, delattr, a, s)\n\n\n    def test_multiarray_not_writable_attributes_deletion(self):\n        a = np.ones(2)\n        attr = [\"ndim\", \"flags\", \"itemsize\", \"size\", \"nbytes\", \"base\",\n                \"ctypes\", \"T\", \"__array_interface__\", \"__array_struct__\",\n                \"__array_priority__\", \"__array_finalize__\"]\n        for s in attr:\n            assert_raises(AttributeError, delattr, a, s)\n\n\n    def test_multiarray_flags_writable_attribute_deletion(self):\n        a = np.ones(2).flags\n        attr = ['updateifcopy', 'aligned', 'writeable']\n        for s in attr:\n            assert_raises(AttributeError, delattr, a, s)\n\n\n    def test_multiarray_flags_not_writable_attribute_deletion(self):\n        a = np.ones(2).flags\n        attr = [\"contiguous\", \"c_contiguous\", \"f_contiguous\", \"fortran\",\n                \"owndata\", \"fnc\", \"forc\", \"behaved\", \"carray\", \"farray\",\n                \"num\"]\n        for s in attr:\n            assert_raises(AttributeError, delattr, a, s)\n\n\ndef test_array_interface():\n    # Test scalar coercion within the array interface\n    class Foo(object):\n        def __init__(self, value):\n            self.value = value\n            self.iface = {'typestr' : '=f8'}\n        def __float__(self):\n            return float(self.value)\n        @property\n        def __array_interface__(self):\n            return self.iface\n    f = Foo(0.5)\n    assert_equal(np.array(f), 0.5)\n    assert_equal(np.array([f]), [0.5])\n    assert_equal(np.array([f, f]), [0.5, 0.5])\n    assert_equal(np.array(f).dtype, np.dtype('=f8'))\n    # Test various shape definitions\n    f.iface['shape'] = ()\n    assert_equal(np.array(f), 0.5)\n    f.iface['shape'] = None\n    assert_raises(TypeError, np.array, f)\n    f.iface['shape'] = (1, 1)\n    assert_equal(np.array(f), [[0.5]])\n    f.iface['shape'] = (2,)\n    assert_raises(ValueError, np.array, f)\n\n    # test scalar with no shape\n    class ArrayLike(object):\n        array = np.array(1)\n        __array_interface__ = array.__array_interface__\n    assert_equal(np.array(ArrayLike()), 1)\n\n\ndef test_flat_element_deletion():\n    it = np.ones(3).flat\n    try:\n        del it[1]\n        del it[1:2]\n    except TypeError:\n        pass\n    except:\n        raise AssertionError\n\ndef test_scalar_element_deletion():\n    a = np.zeros(2, dtype=[('x', 'int'), ('y', 'int')])\n    assert_raises(ValueError, a[0].__delitem__, 'x')\n\nclass TestMemEventHook(TestCase):\n    def test_mem_seteventhook(self):\n        # The actual tests are within the C code in\n        # multiarray/multiarray_tests.c.src\n        test_pydatamem_seteventhook_start()\n        # force an allocation and free of a numpy array\n        a = np.zeros(10)\n        del a\n        test_pydatamem_seteventhook_end()\n\nclass TestMapIter(TestCase):\n    def test_mapiter(self):\n        # The actual tests are within the C code in\n        # multiarray/multiarray_tests.c.src\n\n        a = arange(12).reshape((3, 4)).astype(float)\n        index = ([1, 1, 2, 0],\n                 [0, 0, 2, 3])\n        vals = [50, 50, 30, 16]\n\n        test_inplace_increment(a, index, vals)\n        assert_equal(a, [[   0.,   1.,    2.,   19.,],\n                         [ 104.,    5.,    6.,    7.,],\n                         [   8.,    9.,   40.,   11.,]])\n\n        b = arange(6).astype(float)\n        index = (array([1, 2, 0]),)\n        vals = [50, 4, 100.1]\n        test_inplace_increment(b, index, vals)\n        assert_equal(b, [ 100.1,  51.,   6.,   3.,   4.,   5. ])\n\n\nclass PriorityNdarray():\n    __array_priority__ = 1000\n\n    def __init__(self, array):\n        self.array = array\n\n    def __lt__(self, array):\n        if isinstance(array, PriorityNdarray):\n            array = array.array\n        return PriorityNdarray(self.array < array)\n\n    def __gt__(self, array):\n        if isinstance(array, PriorityNdarray):\n            array = array.array\n        return PriorityNdarray(self.array > array)\n\n    def __le__(self, array):\n        if isinstance(array, PriorityNdarray):\n            array = array.array\n        return PriorityNdarray(self.array <= array)\n\n    def __ge__(self, array):\n        if isinstance(array, PriorityNdarray):\n            array = array.array\n        return PriorityNdarray(self.array >= array)\n\n    def __eq__(self, array):\n        if isinstance(array, PriorityNdarray):\n            array = array.array\n        return PriorityNdarray(self.array == array)\n\n    def __ne__(self, array):\n        if isinstance(array, PriorityNdarray):\n            array = array.array\n        return PriorityNdarray(self.array != array)\n\n\nclass TestArrayPriority(TestCase):\n    def test_lt(self):\n        l = np.asarray([0., -1., 1.], dtype=dtype)\n        r = np.asarray([0., 1., -1.], dtype=dtype)\n        lp = PriorityNdarray(l)\n        rp = PriorityNdarray(r)\n        res1 = l < r\n        res2 = l < rp\n        res3 = lp < r\n        res4 = lp < rp\n\n        assert_array_equal(res1, res2.array)\n        assert_array_equal(res1, res3.array)\n        assert_array_equal(res1, res4.array)\n        assert_(isinstance(res1, np.ndarray))\n        assert_(isinstance(res2, PriorityNdarray))\n        assert_(isinstance(res3, PriorityNdarray))\n        assert_(isinstance(res4, PriorityNdarray))\n\n    def test_gt(self):\n        l = np.asarray([0., -1., 1.], dtype=dtype)\n        r = np.asarray([0., 1., -1.], dtype=dtype)\n        lp = PriorityNdarray(l)\n        rp = PriorityNdarray(r)\n        res1 = l > r\n        res2 = l > rp\n        res3 = lp > r\n        res4 = lp > rp\n\n        assert_array_equal(res1, res2.array)\n        assert_array_equal(res1, res3.array)\n        assert_array_equal(res1, res4.array)\n        assert_(isinstance(res1, np.ndarray))\n        assert_(isinstance(res2, PriorityNdarray))\n        assert_(isinstance(res3, PriorityNdarray))\n        assert_(isinstance(res4, PriorityNdarray))\n\n    def test_le(self):\n        l = np.asarray([0., -1., 1.], dtype=dtype)\n        r = np.asarray([0., 1., -1.], dtype=dtype)\n        lp = PriorityNdarray(l)\n        rp = PriorityNdarray(r)\n        res1 = l <= r\n        res2 = l <= rp\n        res3 = lp <= r\n        res4 = lp <= rp\n\n        assert_array_equal(res1, res2.array)\n        assert_array_equal(res1, res3.array)\n        assert_array_equal(res1, res4.array)\n        assert_(isinstance(res1, np.ndarray))\n        assert_(isinstance(res2, PriorityNdarray))\n        assert_(isinstance(res3, PriorityNdarray))\n        assert_(isinstance(res4, PriorityNdarray))\n\n    def test_ge(self):\n        l = np.asarray([0., -1., 1.], dtype=dtype)\n        r = np.asarray([0., 1., -1.], dtype=dtype)\n        lp = PriorityNdarray(l)\n        rp = PriorityNdarray(r)\n        res1 = l >= r\n        res2 = l >= rp\n        res3 = lp >= r\n        res4 = lp >= rp\n\n        assert_array_equal(res1, res2.array)\n        assert_array_equal(res1, res3.array)\n        assert_array_equal(res1, res4.array)\n        assert_(isinstance(res1, np.ndarray))\n        assert_(isinstance(res2, PriorityNdarray))\n        assert_(isinstance(res3, PriorityNdarray))\n        assert_(isinstance(res4, PriorityNdarray))\n\n    def test_eq(self):\n        l = np.asarray([0., -1., 1.], dtype=dtype)\n        r = np.asarray([0., 1., -1.], dtype=dtype)\n        lp = PriorityNdarray(l)\n        rp = PriorityNdarray(r)\n        res1 = l == r\n        res2 = l == rp\n        res3 = lp == r\n        res4 = lp == rp\n\n        assert_array_equal(res1, res2.array)\n        assert_array_equal(res1, res3.array)\n        assert_array_equal(res1, res4.array)\n        assert_(isinstance(res1, np.ndarray))\n        assert_(isinstance(res2, PriorityNdarray))\n        assert_(isinstance(res3, PriorityNdarray))\n        assert_(isinstance(res4, PriorityNdarray))\n\n    def test_ne(self):\n        l = np.asarray([0., -1., 1.], dtype=dtype)\n        r = np.asarray([0., 1., -1.], dtype=dtype)\n        lp = PriorityNdarray(l)\n        rp = PriorityNdarray(r)\n        res1 = l != r\n        res2 = l != rp\n        res3 = lp != r\n        res4 = lp != rp\n\n        assert_array_equal(res1, res2.array)\n        assert_array_equal(res1, res3.array)\n        assert_array_equal(res1, res4.array)\n        assert_(isinstance(res1, np.ndarray))\n        assert_(isinstance(res2, PriorityNdarray))\n        assert_(isinstance(res3, PriorityNdarray))\n        assert_(isinstance(res4, PriorityNdarray))\n\n\nclass TestConversion(TestCase):\n    def test_array_scalar_relational_operation(self):\n        #All integer\n        for dt1 in np.typecodes['AllInteger']:\n            assert_(1 > np.array(0, dtype=dt1), \"type %s failed\" % (dt1,))\n            assert_(not 1 < np.array(0, dtype=dt1), \"type %s failed\" % (dt1,))\n\n            for dt2 in np.typecodes['AllInteger']:\n                assert_(np.array(1, dtype=dt1) > np.array(0, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n                assert_(not np.array(1, dtype=dt1) < np.array(0, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n\n        #Unsigned integers\n        for dt1 in 'BHILQP':\n            assert_(-1 < np.array(1, dtype=dt1), \"type %s failed\" % (dt1,))\n            assert_(not -1 > np.array(1, dtype=dt1), \"type %s failed\" % (dt1,))\n            assert_(-1 != np.array(1, dtype=dt1), \"type %s failed\" % (dt1,))\n\n            #unsigned vs signed\n            for dt2 in 'bhilqp':\n                assert_(np.array(1, dtype=dt1) > np.array(-1, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n                assert_(not np.array(1, dtype=dt1) < np.array(-1, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n                assert_(np.array(1, dtype=dt1) != np.array(-1, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n\n        #Signed integers and floats\n        for dt1 in 'bhlqp' + np.typecodes['Float']:\n            assert_(1 > np.array(-1, dtype=dt1), \"type %s failed\" % (dt1,))\n            assert_(not 1 < np.array(-1, dtype=dt1), \"type %s failed\" % (dt1,))\n            assert_(-1 == np.array(-1, dtype=dt1), \"type %s failed\" % (dt1,))\n\n            for dt2 in 'bhlqp' + np.typecodes['Float']:\n                assert_(np.array(1, dtype=dt1) > np.array(-1, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n                assert_(not np.array(1, dtype=dt1) < np.array(-1, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n                assert_(np.array(-1, dtype=dt1) == np.array(-1, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n\n\nclass TestWhere(TestCase):\n    def test_basic(self):\n        dts = [np.bool, np.int16, np.int32, np.int64, np.double, np.complex128,\n               np.longdouble, np.clongdouble]\n        for dt in dts:\n            c = np.ones(53, dtype=np.bool)\n            assert_equal(np.where( c, dt(0), dt(1)), dt(0))\n            assert_equal(np.where(~c, dt(0), dt(1)), dt(1))\n            assert_equal(np.where(True, dt(0), dt(1)), dt(0))\n            assert_equal(np.where(False, dt(0), dt(1)), dt(1))\n            d = np.ones_like(c).astype(dt)\n            e = np.zeros_like(d)\n            r = d.astype(dt)\n            c[7] = False\n            r[7] = e[7]\n            assert_equal(np.where(c, e, e), e)\n            assert_equal(np.where(c, d, e), r)\n            assert_equal(np.where(c, d, e[0]), r)\n            assert_equal(np.where(c, d[0], e), r)\n            assert_equal(np.where(c[::2], d[::2], e[::2]), r[::2])\n            assert_equal(np.where(c[1::2], d[1::2], e[1::2]), r[1::2])\n            assert_equal(np.where(c[::3], d[::3], e[::3]), r[::3])\n            assert_equal(np.where(c[1::3], d[1::3], e[1::3]), r[1::3])\n            assert_equal(np.where(c[::-2], d[::-2], e[::-2]), r[::-2])\n            assert_equal(np.where(c[::-3], d[::-3], e[::-3]), r[::-3])\n            assert_equal(np.where(c[1::-3], d[1::-3], e[1::-3]), r[1::-3])\n\n    def test_exotic(self):\n        # object\n        assert_array_equal(np.where(True, None, None), np.array(None))\n        # zero sized\n        m = np.array([], dtype=bool).reshape(0, 3)\n        b = np.array([], dtype=np.float64).reshape(0, 3)\n        assert_array_equal(np.where(m, 0, b), np.array([]).reshape(0, 3))\n\n        # object cast\n        d = np.array([-1.34, -0.16, -0.54, -0.31, -0.08, -0.95, 0.000, 0.313,\n                      0.547, -0.18, 0.876, 0.236, 1.969, 0.310, 0.699, 1.013,\n                      1.267, 0.229, -1.39, 0.487])\n        nan = float('NaN')\n        e = np.array(['5z', '0l', nan, 'Wz', nan, nan, 'Xq', 'cs', nan, nan,\n                     'QN', nan, nan, 'Fd', nan, nan, 'kp', nan, '36', 'i1'],\n                     dtype=object);\n        m = np.array([0,0,1,0,1,1,0,0,1,1,0,1,1,0,1,1,0,1,0,0], dtype=bool)\n\n        r = e[:]\n        r[np.where(m)] = d[np.where(m)]\n        assert_array_equal(np.where(m, d, e), r)\n\n        r = e[:]\n        r[np.where(~m)] = d[np.where(~m)]\n        assert_array_equal(np.where(m, e, d), r)\n\n        assert_array_equal(np.where(m, e, e), e)\n\n        # minimal dtype result with NaN scalar (e.g required by pandas)\n        d =  np.array([1., 2.], dtype=np.float32)\n        e =  float('NaN')\n        assert_equal(np.where(True, d, e).dtype, np.float32)\n        e =  float('Infinity')\n        assert_equal(np.where(True, d, e).dtype, np.float32)\n        e =  float('-Infinity')\n        assert_equal(np.where(True, d, e).dtype, np.float32)\n        # also check upcast\n        e =  float(1e150)\n        assert_equal(np.where(True, d, e).dtype, np.float64)\n\n    def test_ndim(self):\n        c = [True, False]\n        a = np.zeros((2, 25))\n        b = np.ones((2, 25))\n        r = np.where(np.array(c)[:,np.newaxis], a, b)\n        assert_array_equal(r[0], a[0])\n        assert_array_equal(r[1], b[0])\n\n        a = a.T\n        b = b.T\n        r = np.where(c, a, b)\n        assert_array_equal(r[:,0], a[:,0])\n        assert_array_equal(r[:,1], b[:,0])\n\n    def test_dtype_mix(self):\n        c = np.array([False, True, False, False, False, False, True, False,\n                     False, False, True, False])\n        a = np.uint32(1)\n        b =  np.array([5., 0., 3., 2., -1., -4., 0., -10., 10., 1., 0., 3.],\n                      dtype=np.float64)\n        r = np.array([5., 1., 3., 2., -1., -4., 1., -10., 10., 1., 1., 3.],\n                     dtype=np.float64)\n        assert_equal(np.where(c, a, b), r)\n\n        a = a.astype(np.float32)\n        b = b.astype(np.int64)\n        assert_equal(np.where(c, a, b), r)\n\n        # non bool mask\n        c = c.astype(np.int)\n        c[c != 0] = 34242324\n        assert_equal(np.where(c, a, b), r)\n        # invert\n        tmpmask = c != 0\n        c[c == 0] = 41247212\n        c[tmpmask] = 0\n        assert_equal(np.where(c, b, a), r)\n\n    def test_foreign(self):\n        c = np.array([False, True, False, False, False, False, True, False,\n                     False, False, True, False])\n        r = np.array([5., 1., 3., 2., -1., -4., 1., -10., 10., 1., 1., 3.],\n                     dtype=np.float64)\n        a = np.ones(1, dtype='>i4')\n        b =  np.array([5., 0., 3., 2., -1., -4., 0., -10., 10., 1., 0., 3.],\n                      dtype=np.float64)\n        assert_equal(np.where(c, a, b), r)\n\n        b = b.astype('>f8')\n        assert_equal(np.where(c, a, b), r)\n\n        a = a.astype('<i4')\n        assert_equal(np.where(c, a, b), r)\n\n        c = c.astype('>i4')\n        assert_equal(np.where(c, a, b), r)\n\n    def test_error(self):\n        c = [True, True]\n        a = np.ones((4, 5))\n        b = np.ones((5, 5))\n        assert_raises(ValueError, np.where, c, a, a)\n        assert_raises(ValueError, np.where, c[0], a, b)\n\n\nif __name__ == \"__main__\":\n    run_module_suite()\n", "#!/usr/bin/env python\nfrom __future__ import division, absolute_import, print_function\n\n__all__ = ['run_main', 'compile', 'f2py_testing']\n\nimport os\nimport sys\nimport subprocess\n\nfrom . import f2py2e\nfrom . import f2py_testing\nfrom . import diagnose\n\nfrom .info import __doc__\n\nrun_main = f2py2e.run_main\nmain = f2py2e.main\n\ndef compile(source,\n            modulename = 'untitled',\n            extra_args = '',\n            verbose = 1,\n            source_fn = None\n            ):\n    ''' Build extension module from processing source with f2py.\n    Read the source of this function for more information.\n    '''\n    from numpy.distutils.exec_command import exec_command\n    import tempfile\n    if source_fn is None:\n        fname = os.path.join(tempfile.mktemp()+'.f')\n    else:\n        fname = source_fn\n\n    f = open(fname, 'w')\n    f.write(source)\n    f.close()\n\n    args = ' -c -m %s %s %s'%(modulename, fname, extra_args)\n    c = '%s -c \"import numpy.f2py as f2py2e;f2py2e.main()\" %s' %(sys.executable, args)\n    s, o = exec_command(c)\n    if source_fn is None:\n        try: os.remove(fname)\n        except OSError: pass\n    return s\n\nfrom numpy.testing import Tester\ntest = Tester().test\nbench = Tester().bench\n", "#!/usr/bin/env python\n\"\"\"\n\nf2py2e - Fortran to Python C/API generator. 2nd Edition.\n         See __usage__ below.\n\nCopyright 1999--2011 Pearu Peterson all rights reserved,\nPearu Peterson <pearu@cens.ioc.ee>\nPermission to use, modify, and distribute this software is given under the\nterms of the NumPy License.\n\nNO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.\n$Date: 2005/05/06 08:31:19 $\nPearu Peterson\n\n\"\"\"\nfrom __future__ import division, absolute_import, print_function\n\nimport sys\nimport os\nimport pprint\nimport re\n\nfrom . import crackfortran\nfrom . import rules\nfrom . import cb_rules\nfrom . import auxfuncs\nfrom . import cfuncs\nfrom . import f90mod_rules\nfrom . import __version__\n\nf2py_version = __version__.version\nerrmess = sys.stderr.write\n#outmess=sys.stdout.write\nshow = pprint.pprint\noutmess = auxfuncs.outmess\n\ntry:\n    from numpy import __version__ as numpy_version\nexcept ImportError:\n    numpy_version = 'N/A'\n\n__usage__ = \"\"\"\\\nUsage:\n\n1) To construct extension module sources:\n\n      f2py [<options>] <fortran files> [[[only:]||[skip:]] \\\\\n                                        <fortran functions> ] \\\\\n                                       [: <fortran files> ...]\n\n2) To compile fortran files and build extension modules:\n\n      f2py -c [<options>, <build_flib options>, <extra options>] <fortran files>\n\n3) To generate signature files:\n\n      f2py -h <filename.pyf> ...< same options as in (1) >\n\nDescription: This program generates a Python C/API file (<modulename>module.c)\n             that contains wrappers for given fortran functions so that they\n             can be called from Python. With the -c option the corresponding\n             extension modules are built.\n\nOptions:\n\n  --2d-numpy       Use numpy.f2py tool with NumPy support. [DEFAULT]\n  --2d-numeric     Use f2py2e tool with Numeric support.\n  --2d-numarray    Use f2py2e tool with Numarray support.\n  --g3-numpy       Use 3rd generation f2py from the separate f2py package.\n                   [NOT AVAILABLE YET]\n\n  -h <filename>    Write signatures of the fortran routines to file <filename>\n                   and exit. You can then edit <filename> and use it instead\n                   of <fortran files>. If <filename>==stdout then the\n                   signatures are printed to stdout.\n  <fortran functions>  Names of fortran routines for which Python C/API\n                   functions will be generated. Default is all that are found\n                   in <fortran files>.\n  <fortran files>  Paths to fortran/signature files that will be scanned for\n                   <fortran functions> in order to determine their signatures.\n  skip:            Ignore fortran functions that follow until `:'.\n  only:            Use only fortran functions that follow until `:'.\n  :                Get back to <fortran files> mode.\n\n  -m <modulename>  Name of the module; f2py generates a Python/C API\n                   file <modulename>module.c or extension module <modulename>.\n                   Default is 'untitled'.\n\n  --[no-]lower     Do [not] lower the cases in <fortran files>. By default,\n                   --lower is assumed with -h key, and --no-lower without -h key.\n\n  --build-dir <dirname>  All f2py generated files are created in <dirname>.\n                   Default is tempfile.mktemp().\n\n  --overwrite-signature  Overwrite existing signature file.\n\n  --[no-]latex-doc Create (or not) <modulename>module.tex.\n                   Default is --no-latex-doc.\n  --short-latex    Create 'incomplete' LaTeX document (without commands\n                   \\\\documentclass, \\\\tableofcontents, and \\\\begin{document},\n                   \\\\end{document}).\n\n  --[no-]rest-doc Create (or not) <modulename>module.rst.\n                   Default is --no-rest-doc.\n\n  --debug-capi     Create C/API code that reports the state of the wrappers\n                   during runtime. Useful for debugging.\n\n  --[no-]wrap-functions    Create Fortran subroutine wrappers to Fortran 77\n                   functions. --wrap-functions is default because it ensures\n                   maximum portability/compiler independence.\n\n  --include-paths <path1>:<path2>:...   Search include files from the given\n                   directories.\n\n  --help-link [..] List system resources found by system_info.py. See also\n                   --link-<resource> switch below. [..] is optional list\n                   of resources names. E.g. try 'f2py --help-link lapack_opt'.\n\n  --quiet          Run quietly.\n  --verbose        Run with extra verbosity.\n  -v               Print f2py version ID and exit.\n\n\nnumpy.distutils options (only effective with -c):\n\n  --fcompiler=         Specify Fortran compiler type by vendor\n  --compiler=          Specify C compiler type (as defined by distutils)\n\n  --help-fcompiler     List available Fortran compilers and exit\n  --f77exec=           Specify the path to F77 compiler\n  --f90exec=           Specify the path to F90 compiler\n  --f77flags=          Specify F77 compiler flags\n  --f90flags=          Specify F90 compiler flags\n  --opt=               Specify optimization flags\n  --arch=              Specify architecture specific optimization flags\n  --noopt              Compile without optimization\n  --noarch             Compile without arch-dependent optimization\n  --debug              Compile with debugging information\n\nExtra options (only effective with -c):\n\n  --link-<resource>    Link extension module with <resource> as defined\n                       by numpy.distutils/system_info.py. E.g. to link\n                       with optimized LAPACK libraries (vecLib on MacOSX,\n                       ATLAS elsewhere), use --link-lapack_opt.\n                       See also --help-link switch.\n\n  -L/path/to/lib/ -l<libname>\n  -D<define> -U<name>\n  -I/path/to/include/\n  <filename>.o <filename>.so <filename>.a\n\n  Using the following macros may be required with non-gcc Fortran\n  compilers:\n    -DPREPEND_FORTRAN -DNO_APPEND_FORTRAN -DUPPERCASE_FORTRAN\n    -DUNDERSCORE_G77\n\n  When using -DF2PY_REPORT_ATEXIT, a performance report of F2PY\n  interface is printed out at exit (platforms: Linux).\n\n  When using -DF2PY_REPORT_ON_ARRAY_COPY=<int>, a message is\n  sent to stderr whenever F2PY interface makes a copy of an\n  array. Integer <int> sets the threshold for array sizes when\n  a message should be shown.\n\nVersion:     %s\nnumpy Version: %s\nRequires:    Python 2.3 or higher.\nLicense:     NumPy license (see LICENSE.txt in the NumPy source code)\nCopyright 1999 - 2011 Pearu Peterson all rights reserved.\nhttp://cens.ioc.ee/projects/f2py2e/\"\"\"%(f2py_version, numpy_version)\n\ndef scaninputline(inputline):\n    files, funcs, skipfuncs, onlyfuncs, debug=[], [], [], [], []\n    f, f2, f3, f4, f5, f6, f7, f8, f9=1, 0, 0, 0, 0, 0, 0, 0, 0\n    verbose = 1\n    dolc=-1\n    dolatexdoc = 0\n    dorestdoc = 0\n    wrapfuncs = 1\n    buildpath = '.'\n    include_paths = []\n    signsfile, modulename=None, None\n    options = {'buildpath':buildpath,\n               'coutput': None,\n               'f2py_wrapper_output': None}\n    for l in inputline:\n        if l=='': pass\n        elif l=='only:': f=0\n        elif l=='skip:': f=-1\n        elif l==':': f=1;f4=0\n        elif l[:8]=='--debug-': debug.append(l[8:])\n        elif l=='--lower': dolc=1\n        elif l=='--build-dir': f6=1\n        elif l=='--no-lower': dolc=0\n        elif l=='--quiet': verbose = 0\n        elif l=='--verbose': verbose += 1\n        elif l=='--latex-doc': dolatexdoc=1\n        elif l=='--no-latex-doc': dolatexdoc=0\n        elif l=='--rest-doc': dorestdoc=1\n        elif l=='--no-rest-doc': dorestdoc=0\n        elif l=='--wrap-functions': wrapfuncs=1\n        elif l=='--no-wrap-functions': wrapfuncs=0\n        elif l=='--short-latex': options['shortlatex']=1\n        elif l=='--coutput': f8=1\n        elif l=='--f2py-wrapper-output': f9=1\n        elif l=='--overwrite-signature': options['h-overwrite']=1\n        elif l=='-h': f2=1\n        elif l=='-m': f3=1\n        elif l[:2]=='-v':\n            print(f2py_version)\n            sys.exit()\n        elif l=='--show-compilers':\n            f5=1\n        elif l[:8]=='-include':\n            cfuncs.outneeds['userincludes'].append(l[9:-1])\n            cfuncs.userincludes[l[9:-1]]='#include '+l[8:]\n        elif l[:15] in '--include_paths':\n            outmess('f2py option --include_paths is deprecated, use --include-paths instead.\\n')\n            f7=1\n        elif l[:15] in '--include-paths':\n            f7=1\n        elif l[0]=='-':\n            errmess('Unknown option %s\\n'%repr(l))\n            sys.exit()\n        elif f2: f2=0;signsfile=l\n        elif f3: f3=0;modulename=l\n        elif f6: f6=0;buildpath=l\n        elif f7: f7=0;include_paths.extend(l.split(os.pathsep))\n        elif f8: f8=0;options[\"coutput\"]=l\n        elif f9: f9=0;options[\"f2py_wrapper_output\"]=l\n        elif f==1:\n            try:\n                open(l).close()\n                files.append(l)\n            except IOError as detail:\n                errmess('IOError: %s. Skipping file \"%s\".\\n'%(str(detail), l))\n        elif f==-1: skipfuncs.append(l)\n        elif f==0: onlyfuncs.append(l)\n    if not f5 and not files and not modulename:\n        print(__usage__)\n        sys.exit()\n    if not os.path.isdir(buildpath):\n        if not verbose:\n            outmess('Creating build directory %s'%(buildpath))\n        os.mkdir(buildpath)\n    if signsfile:\n        signsfile = os.path.join(buildpath, signsfile)\n    if signsfile and os.path.isfile(signsfile) and 'h-overwrite' not in options:\n        errmess('Signature file \"%s\" exists!!! Use --overwrite-signature to overwrite.\\n'%(signsfile))\n        sys.exit()\n\n    options['debug']=debug\n    options['verbose']=verbose\n    if dolc==-1 and not signsfile: options['do-lower']=0\n    else: options['do-lower']=dolc\n    if modulename: options['module']=modulename\n    if signsfile: options['signsfile']=signsfile\n    if onlyfuncs: options['onlyfuncs']=onlyfuncs\n    if skipfuncs: options['skipfuncs']=skipfuncs\n    options['dolatexdoc'] = dolatexdoc\n    options['dorestdoc'] = dorestdoc\n    options['wrapfuncs'] = wrapfuncs\n    options['buildpath']=buildpath\n    options['include_paths']=include_paths\n    return files, options\n\ndef callcrackfortran(files, options):\n    rules.options=options\n    funcs=[]\n    crackfortran.debug=options['debug']\n    crackfortran.verbose=options['verbose']\n    if 'module' in options:\n        crackfortran.f77modulename=options['module']\n    if 'skipfuncs' in options:\n        crackfortran.skipfuncs=options['skipfuncs']\n    if 'onlyfuncs' in options:\n        crackfortran.onlyfuncs=options['onlyfuncs']\n    crackfortran.include_paths[:]=options['include_paths']\n    crackfortran.dolowercase=options['do-lower']\n    postlist=crackfortran.crackfortran(files)\n    if 'signsfile' in options:\n        outmess('Saving signatures to file \"%s\"\\n'%(options['signsfile']))\n        pyf=crackfortran.crack2fortran(postlist)\n        if options['signsfile'][-6:]=='stdout':\n            sys.stdout.write(pyf)\n        else:\n            f=open(options['signsfile'], 'w')\n            f.write(pyf)\n            f.close()\n    if options[\"coutput\"] is None:\n        for mod in postlist:\n            mod[\"coutput\"] = \"%smodule.c\" % mod[\"name\"]\n    else:\n        for mod in postlist:\n            mod[\"coutput\"] = options[\"coutput\"]\n    if options[\"f2py_wrapper_output\"] is None:\n        for mod in postlist:\n            mod[\"f2py_wrapper_output\"] = \"%s-f2pywrappers.f\" % mod[\"name\"]\n    else:\n        for mod in postlist:\n            mod[\"f2py_wrapper_output\"] = options[\"f2py_wrapper_output\"]\n    return postlist\n\ndef buildmodules(lst):\n    cfuncs.buildcfuncs()\n    outmess('Building modules...\\n')\n    modules, mnames, isusedby=[], [], {}\n    for i in range(len(lst)):\n        if '__user__' in lst[i]['name']:\n            cb_rules.buildcallbacks(lst[i])\n        else:\n            if 'use' in lst[i]:\n                for u in lst[i]['use'].keys():\n                    if u not in isusedby:\n                        isusedby[u]=[]\n                    isusedby[u].append(lst[i]['name'])\n            modules.append(lst[i])\n            mnames.append(lst[i]['name'])\n    ret = {}\n    for i in range(len(mnames)):\n        if mnames[i] in isusedby:\n            outmess('\\tSkipping module \"%s\" which is used by %s.\\n'%(mnames[i], ','.join(['\"%s\"'%s for s in isusedby[mnames[i]]])))\n        else:\n            um=[]\n            if 'use' in modules[i]:\n                for u in modules[i]['use'].keys():\n                    if u in isusedby and u in mnames:\n                        um.append(modules[mnames.index(u)])\n                    else:\n                        outmess('\\tModule \"%s\" uses nonexisting \"%s\" which will be ignored.\\n'%(mnames[i], u))\n            ret[mnames[i]] = {}\n            dict_append(ret[mnames[i]], rules.buildmodule(modules[i], um))\n    return ret\n\ndef dict_append(d_out, d_in):\n    for (k, v) in d_in.items():\n        if k not in d_out:\n            d_out[k] = []\n        if isinstance(v, list):\n            d_out[k] = d_out[k] + v\n        else:\n            d_out[k].append(v)\n\ndef run_main(comline_list):\n    \"\"\"Run f2py as if string.join(comline_list,' ') is used as a command line.\n    In case of using -h flag, return None.\n    \"\"\"\n    crackfortran.reset_global_f2py_vars()\n    f2pydir=os.path.dirname(os.path.abspath(cfuncs.__file__))\n    fobjhsrc = os.path.join(f2pydir, 'src', 'fortranobject.h')\n    fobjcsrc = os.path.join(f2pydir, 'src', 'fortranobject.c')\n    files, options=scaninputline(comline_list)\n    auxfuncs.options=options\n    postlist=callcrackfortran(files, options)\n    isusedby={}\n    for i in range(len(postlist)):\n        if 'use' in postlist[i]:\n            for u in postlist[i]['use'].keys():\n                if u not in isusedby:\n                    isusedby[u]=[]\n                isusedby[u].append(postlist[i]['name'])\n    for i in range(len(postlist)):\n        if postlist[i]['block']=='python module' and '__user__' in postlist[i]['name']:\n            if postlist[i]['name'] in isusedby:\n                #if not quiet:\n                outmess('Skipping Makefile build for module \"%s\" which is used by %s\\n'%(postlist[i]['name'], ','.join(['\"%s\"'%s for s in isusedby[postlist[i]['name']]])))\n    if 'signsfile' in options:\n        if options['verbose']>1:\n            outmess('Stopping. Edit the signature file and then run f2py on the signature file: ')\n            outmess('%s %s\\n'%(os.path.basename(sys.argv[0]), options['signsfile']))\n        return\n    for i in range(len(postlist)):\n        if postlist[i]['block']!='python module':\n            if 'python module' not in options:\n                errmess('Tip: If your original code is Fortran source then you must use -m option.\\n')\n            raise TypeError('All blocks must be python module blocks but got %s'%(repr(postlist[i]['block'])))\n    auxfuncs.debugoptions=options['debug']\n    f90mod_rules.options=options\n    auxfuncs.wrapfuncs=options['wrapfuncs']\n\n    ret=buildmodules(postlist)\n\n    for mn in ret.keys():\n        dict_append(ret[mn], {'csrc':fobjcsrc,'h':fobjhsrc})\n    return ret\n\ndef filter_files(prefix,suffix,files,remove_prefix=None):\n    \"\"\"\n    Filter files by prefix and suffix.\n    \"\"\"\n    filtered, rest = [], []\n    match = re.compile(prefix+r'.*'+suffix+r'\\Z').match\n    if remove_prefix:\n        ind = len(prefix)\n    else:\n        ind = 0\n    for file in [x.strip() for x in files]:\n        if match(file): filtered.append(file[ind:])\n        else: rest.append(file)\n    return filtered, rest\n\ndef get_prefix(module):\n    p = os.path.dirname(os.path.dirname(module.__file__))\n    return p\n\ndef run_compile():\n    \"\"\"\n    Do it all in one call!\n    \"\"\"\n    import tempfile\n\n    i = sys.argv.index('-c')\n    del sys.argv[i]\n\n    remove_build_dir = 0\n    try: i = sys.argv.index('--build-dir')\n    except ValueError: i=None\n    if i is not None:\n        build_dir = sys.argv[i+1]\n        del sys.argv[i+1]\n        del sys.argv[i]\n    else:\n        remove_build_dir = 1\n        build_dir = os.path.join(tempfile.mktemp())\n\n    _reg1 = re.compile(r'[-][-]link[-]')\n    sysinfo_flags = [_m for _m in sys.argv[1:] if _reg1.match(_m)]\n    sys.argv = [_m for _m in sys.argv if _m not in sysinfo_flags]\n    if sysinfo_flags:\n        sysinfo_flags = [f[7:] for f in sysinfo_flags]\n\n    _reg2 = re.compile(r'[-][-]((no[-]|)(wrap[-]functions|lower)|debug[-]capi|quiet)|[-]include')\n    f2py_flags = [_m for _m in sys.argv[1:] if _reg2.match(_m)]\n    sys.argv = [_m for _m in sys.argv if _m not in f2py_flags]\n    f2py_flags2 = []\n    fl = 0\n    for a in sys.argv[1:]:\n        if a in ['only:', 'skip:']:\n            fl = 1\n        elif a==':':\n            fl = 0\n        if fl or a==':':\n            f2py_flags2.append(a)\n    if f2py_flags2 and f2py_flags2[-1]!=':':\n        f2py_flags2.append(':')\n    f2py_flags.extend(f2py_flags2)\n\n    sys.argv = [_m for _m in sys.argv if _m not in f2py_flags2]\n    _reg3 = re.compile(r'[-][-]((f(90)?compiler([-]exec|)|compiler)=|help[-]compiler)')\n    flib_flags = [_m for _m in sys.argv[1:] if _reg3.match(_m)]\n    sys.argv = [_m for _m in sys.argv if _m not in flib_flags]\n    _reg4 = re.compile(r'[-][-]((f(77|90)(flags|exec)|opt|arch)=|(debug|noopt|noarch|help[-]fcompiler))')\n    fc_flags = [_m for _m in sys.argv[1:] if _reg4.match(_m)]\n    sys.argv = [_m for _m in sys.argv if _m not in fc_flags]\n\n    if 1:\n        del_list = []\n        for s in flib_flags:\n            v = '--fcompiler='\n            if s[:len(v)]==v:\n                from numpy.distutils import fcompiler\n                fcompiler.load_all_fcompiler_classes()\n                allowed_keys = list(fcompiler.fcompiler_class.keys())\n                nv = ov = s[len(v):].lower()\n                if ov not in allowed_keys:\n                    vmap = {} # XXX\n                    try:\n                        nv = vmap[ov]\n                    except KeyError:\n                        if ov not in vmap.values():\n                            print('Unknown vendor: \"%s\"' % (s[len(v):]))\n                    nv = ov\n                i = flib_flags.index(s)\n                flib_flags[i] = '--fcompiler=' + nv\n                continue\n        for s in del_list:\n            i = flib_flags.index(s)\n            del flib_flags[i]\n        assert len(flib_flags)<=2, repr(flib_flags)\n\n    _reg5 = re.compile(r'[-][-](verbose)')\n    setup_flags = [_m for _m in sys.argv[1:] if _reg5.match(_m)]\n    sys.argv = [_m for _m in sys.argv if _m not in setup_flags]\n\n    if '--quiet' in f2py_flags:\n        setup_flags.append('--quiet')\n\n    modulename = 'untitled'\n    sources = sys.argv[1:]\n\n    for optname in ['--include_paths', '--include-paths']:\n        if optname in sys.argv:\n            i = sys.argv.index (optname)\n            f2py_flags.extend (sys.argv[i:i+2])\n            del sys.argv[i+1], sys.argv[i]\n            sources = sys.argv[1:]\n\n    if '-m' in sys.argv:\n        i = sys.argv.index('-m')\n        modulename = sys.argv[i+1]\n        del sys.argv[i+1], sys.argv[i]\n        sources = sys.argv[1:]\n    else:\n        from numpy.distutils.command.build_src import get_f2py_modulename\n        pyf_files, sources = filter_files('', '[.]pyf([.]src|)', sources)\n        sources = pyf_files + sources\n        for f in pyf_files:\n            modulename = get_f2py_modulename(f)\n            if modulename:\n                break\n\n    extra_objects, sources = filter_files('', '[.](o|a|so)', sources)\n    include_dirs, sources = filter_files('-I', '', sources, remove_prefix=1)\n    library_dirs, sources = filter_files('-L', '', sources, remove_prefix=1)\n    libraries, sources = filter_files('-l', '', sources, remove_prefix=1)\n    undef_macros, sources = filter_files('-U', '', sources, remove_prefix=1)\n    define_macros, sources = filter_files('-D', '', sources, remove_prefix=1)\n    using_numarray = 0\n    using_numeric = 0\n    for i in range(len(define_macros)):\n        name_value = define_macros[i].split('=', 1)\n        if len(name_value)==1:\n            name_value.append(None)\n        if len(name_value)==2:\n            define_macros[i] = tuple(name_value)\n        else:\n            print('Invalid use of -D:', name_value)\n\n    from numpy.distutils.system_info import get_info\n\n    num_include_dir = None\n    num_info = {}\n    #import numpy\n    #n = 'numpy'\n    #p = get_prefix(numpy)\n    #from numpy.distutils.misc_util import get_numpy_include_dirs\n    #num_info = {'include_dirs': get_numpy_include_dirs()}\n\n    if num_info:\n        include_dirs.extend(num_info.get('include_dirs', []))\n\n    from numpy.distutils.core import setup, Extension\n    ext_args = {'name': modulename, 'sources': sources,\n                'include_dirs': include_dirs,\n                'library_dirs': library_dirs,\n                'libraries': libraries,\n                'define_macros': define_macros,\n                'undef_macros': undef_macros,\n                'extra_objects': extra_objects,\n                'f2py_options': f2py_flags,\n                }\n\n    if sysinfo_flags:\n        from numpy.distutils.misc_util import dict_append\n        for n in sysinfo_flags:\n            i = get_info(n)\n            if not i:\n                outmess('No %s resources found in system'\\\n                        ' (try `f2py --help-link`)\\n' % (repr(n)))\n            dict_append(ext_args,**i)\n\n    ext = Extension(**ext_args)\n    sys.argv = [sys.argv[0]] + setup_flags\n    sys.argv.extend(['build',\n                     '--build-temp', build_dir,\n                     '--build-base', build_dir,\n                     '--build-platlib', '.'])\n    if fc_flags:\n        sys.argv.extend(['config_fc']+fc_flags)\n    if flib_flags:\n        sys.argv.extend(['build_ext']+flib_flags)\n\n    setup(ext_modules = [ext])\n\n    if remove_build_dir and os.path.exists(build_dir):\n        import shutil\n        outmess('Removing build directory %s\\n'%(build_dir))\n        shutil.rmtree(build_dir)\n\ndef main():\n    if '--help-link' in sys.argv[1:]:\n        sys.argv.remove('--help-link')\n        from numpy.distutils.system_info import show_all\n        show_all()\n        return\n    if '-c' in sys.argv[1:]:\n        run_compile()\n    else:\n        run_main(sys.argv[1:])\n\n#if __name__ == \"__main__\":\n#    main()\n\n\n# EOF\n", "from __future__ import division, absolute_import, print_function\n\nimport sys\nimport gzip\nimport os\nimport threading\nfrom tempfile import mkstemp, mktemp, NamedTemporaryFile\nimport time\nimport warnings\nimport gc\nfrom io import BytesIO\nfrom datetime import datetime\n\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy.lib._iotools import (ConverterError, ConverterLockError,\n                                ConversionWarning)\nfrom numpy.compat import asbytes, asbytes_nested, bytes, asstr\nfrom nose import SkipTest\nfrom numpy.ma.testutils import (TestCase, assert_equal, assert_array_equal,\n                                assert_raises, run_module_suite)\nfrom numpy.testing import assert_warns, assert_, build_err_msg\n\n\nclass TextIO(BytesIO):\n    \"\"\"Helper IO class.\n\n    Writes encode strings to bytes if needed, reads return bytes.\n    This makes it easier to emulate files opened in binary mode\n    without needing to explicitly convert strings to bytes in\n    setting up the test data.\n\n    \"\"\"\n    def __init__(self, s=\"\"):\n        BytesIO.__init__(self, asbytes(s))\n\n    def write(self, s):\n        BytesIO.write(self, asbytes(s))\n\n    def writelines(self, lines):\n        BytesIO.writelines(self, [asbytes(s) for s in lines])\n\n\nMAJVER, MINVER = sys.version_info[:2]\nIS_64BIT = sys.maxsize > 2**32\n\n\ndef strptime(s, fmt=None):\n    \"\"\"This function is available in the datetime module only\n    from Python >= 2.5.\n\n    \"\"\"\n    if sys.version_info[0] >= 3:\n        return datetime(*time.strptime(s.decode('latin1'), fmt)[:3])\n    else:\n        return datetime(*time.strptime(s, fmt)[:3])\n\n\nclass RoundtripTest(object):\n    def roundtrip(self, save_func, *args, **kwargs):\n        \"\"\"\n        save_func : callable\n            Function used to save arrays to file.\n        file_on_disk : bool\n            If true, store the file on disk, instead of in a\n            string buffer.\n        save_kwds : dict\n            Parameters passed to `save_func`.\n        load_kwds : dict\n            Parameters passed to `numpy.load`.\n        args : tuple of arrays\n            Arrays stored to file.\n\n        \"\"\"\n        save_kwds = kwargs.get('save_kwds', {})\n        load_kwds = kwargs.get('load_kwds', {})\n        file_on_disk = kwargs.get('file_on_disk', False)\n\n        if file_on_disk:\n            # Do not delete the file on windows, because we can't\n            # reopen an already opened file on that platform, so we\n            # need to close the file and reopen it, implying no\n            # automatic deletion.\n            if sys.platform == 'win32' and MAJVER >= 2 and MINVER >= 6:\n                target_file = NamedTemporaryFile(delete=False)\n            else:\n                target_file = NamedTemporaryFile()\n            load_file = target_file.name\n        else:\n            target_file = BytesIO()\n            load_file = target_file\n\n        arr = args\n\n        save_func(target_file, *arr, **save_kwds)\n        target_file.flush()\n        target_file.seek(0)\n\n        if sys.platform == 'win32' and not isinstance(target_file, BytesIO):\n            target_file.close()\n\n        arr_reloaded = np.load(load_file, **load_kwds)\n\n        self.arr = arr\n        self.arr_reloaded = arr_reloaded\n\n    def check_roundtrips(self, a):\n        self.roundtrip(a)\n        self.roundtrip(a, file_on_disk=True)\n        self.roundtrip(np.asfortranarray(a))\n        self.roundtrip(np.asfortranarray(a), file_on_disk=True)\n        if a.shape[0] > 1:\n            # neither C nor Fortran contiguous for 2D arrays or more\n            self.roundtrip(np.asfortranarray(a)[1:])\n            self.roundtrip(np.asfortranarray(a)[1:], file_on_disk=True)\n\n    def test_array(self):\n        a = np.array([], float)\n        self.check_roundtrips(a)\n\n        a = np.array([[1, 2], [3, 4]], float)\n        self.check_roundtrips(a)\n\n        a = np.array([[1, 2], [3, 4]], int)\n        self.check_roundtrips(a)\n\n        a = np.array([[1 + 5j, 2 + 6j], [3 + 7j, 4 + 8j]], dtype=np.csingle)\n        self.check_roundtrips(a)\n\n        a = np.array([[1 + 5j, 2 + 6j], [3 + 7j, 4 + 8j]], dtype=np.cdouble)\n        self.check_roundtrips(a)\n\n    def test_array_object(self):\n        if sys.version_info[:2] >= (2, 7):\n            a = np.array([], object)\n            self.check_roundtrips(a)\n\n            a = np.array([[1, 2], [3, 4]], object)\n            self.check_roundtrips(a)\n        # Fails with UnpicklingError: could not find MARK on Python 2.6\n\n    def test_1D(self):\n        a = np.array([1, 2, 3, 4], int)\n        self.roundtrip(a)\n\n    @np.testing.dec.knownfailureif(sys.platform == 'win32', \"Fail on Win32\")\n    def test_mmap(self):\n        a = np.array([[1, 2.5], [4, 7.3]])\n        self.roundtrip(a, file_on_disk=True, load_kwds={'mmap_mode': 'r'})\n\n        a = np.asfortranarray([[1, 2.5], [4, 7.3]])\n        self.roundtrip(a, file_on_disk=True, load_kwds={'mmap_mode': 'r'})\n\n    def test_record(self):\n        a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])\n        self.check_roundtrips(a)\n\n\nclass TestSaveLoad(RoundtripTest, TestCase):\n    def roundtrip(self, *args, **kwargs):\n        RoundtripTest.roundtrip(self, np.save, *args, **kwargs)\n        assert_equal(self.arr[0], self.arr_reloaded)\n        assert_equal(self.arr[0].dtype, self.arr_reloaded.dtype)\n        assert_equal(self.arr[0].flags.fnc, self.arr_reloaded.flags.fnc)\n\n\nclass TestSavezLoad(RoundtripTest, TestCase):\n    def roundtrip(self, *args, **kwargs):\n        RoundtripTest.roundtrip(self, np.savez, *args, **kwargs)\n        for n, arr in enumerate(self.arr):\n            reloaded = self.arr_reloaded['arr_%d' % n]\n            assert_equal(arr, reloaded)\n            assert_equal(arr.dtype, reloaded.dtype)\n            assert_equal(arr.flags.fnc, reloaded.flags.fnc)\n\n    @np.testing.dec.skipif(not IS_64BIT, \"Works only with 64bit systems\")\n    @np.testing.dec.slow\n    def test_big_arrays(self):\n        L = (1 << 31) + 100000\n        tmp = mktemp(suffix='.npz')\n        a = np.empty(L, dtype=np.uint8)\n        np.savez(tmp, a=a)\n        del a\n        npfile = np.load(tmp)\n        a = npfile['a']\n        npfile.close()\n        os.remove(tmp)\n\n    def test_multiple_arrays(self):\n        a = np.array([[1, 2], [3, 4]], float)\n        b = np.array([[1 + 2j, 2 + 7j], [3 - 6j, 4 + 12j]], complex)\n        self.roundtrip(a, b)\n\n    def test_named_arrays(self):\n        a = np.array([[1, 2], [3, 4]], float)\n        b = np.array([[1 + 2j, 2 + 7j], [3 - 6j, 4 + 12j]], complex)\n        c = BytesIO()\n        np.savez(c, file_a=a, file_b=b)\n        c.seek(0)\n        l = np.load(c)\n        assert_equal(a, l['file_a'])\n        assert_equal(b, l['file_b'])\n\n    def test_savez_filename_clashes(self):\n        # Test that issue #852 is fixed\n        # and savez functions in multithreaded environment\n\n        def writer(error_list):\n            fd, tmp = mkstemp(suffix='.npz')\n            os.close(fd)\n            try:\n                arr = np.random.randn(500, 500)\n                try:\n                    np.savez(tmp, arr=arr)\n                except OSError as err:\n                    error_list.append(err)\n            finally:\n                os.remove(tmp)\n\n        errors = []\n        threads = [threading.Thread(target=writer, args=(errors,))\n                   for j in range(3)]\n        for t in threads:\n            t.start()\n        for t in threads:\n            t.join()\n\n        if errors:\n            raise AssertionError(errors)\n\n    def test_not_closing_opened_fid(self):\n        # Test that issue #2178 is fixed:\n        # verify could seek on 'loaded' file\n\n        fd, tmp = mkstemp(suffix='.npz')\n        os.close(fd)\n        try:\n            fp = open(tmp, 'wb')\n            np.savez(fp, data='LOVELY LOAD')\n            fp.close()\n\n            fp = open(tmp, 'rb', 10000)\n            fp.seek(0)\n            assert_(not fp.closed)\n            _ = np.load(fp)['data']\n            assert_(not fp.closed)\n                    # must not get closed by .load(opened fp)\n            fp.seek(0)\n            assert_(not fp.closed)\n\n        finally:\n            fp.close()\n            os.remove(tmp)\n\n    def test_closing_fid(self):\n        # Test that issue #1517 (too many opened files) remains closed\n        # It might be a \"weak\" test since failed to get triggered on\n        # e.g. Debian sid of 2012 Jul 05 but was reported to\n        # trigger the failure on Ubuntu 10.04:\n        # http://projects.scipy.org/numpy/ticket/1517#comment:2\n        fd, tmp = mkstemp(suffix='.npz')\n        os.close(fd)\n\n        try:\n            fp = open(tmp, 'wb')\n            np.savez(fp, data='LOVELY LOAD')\n            fp.close()\n            # We need to check if the garbage collector can properly close\n            # numpy npz file returned by np.load when their reference count\n            # goes to zero.  Python 3 running in debug mode raises a\n            # ResourceWarning when file closing is left to the garbage\n            # collector, so we catch the warnings.  Because ResourceWarning\n            # is unknown in Python < 3.x, we take the easy way out and\n            # catch all warnings.\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"ignore\")\n                for i in range(1, 1025):\n                    try:\n                        np.load(tmp)[\"data\"]\n                    except Exception as e:\n                        msg = \"Failed to load data from a file: %s\" % e\n                        raise AssertionError(msg)\n        finally:\n            os.remove(tmp)\n\n    def test_closing_zipfile_after_load(self):\n        # Check that zipfile owns file and can close it.\n        # This needs to pass a file name to load for the\n        # test.\n        fd, tmp = mkstemp(suffix='.npz')\n        os.close(fd)\n        np.savez(tmp, lab='place holder')\n        data = np.load(tmp)\n        fp = data.zip.fp\n        data.close()\n        assert_(fp.closed)\n\n\nclass TestSaveTxt(TestCase):\n    def test_array(self):\n        a = np.array([[1, 2], [3, 4]], float)\n        fmt = \"%.18e\"\n        c = BytesIO()\n        np.savetxt(c, a, fmt=fmt)\n        c.seek(0)\n        assert_equal(c.readlines(),\n                     [asbytes((fmt + ' ' + fmt + '\\n') % (1, 2)),\n                      asbytes((fmt + ' ' + fmt + '\\n') % (3, 4))])\n\n        a = np.array([[1, 2], [3, 4]], int)\n        c = BytesIO()\n        np.savetxt(c, a, fmt='%d')\n        c.seek(0)\n        assert_equal(c.readlines(), [b'1 2\\n', b'3 4\\n'])\n\n    def test_1D(self):\n        a = np.array([1, 2, 3, 4], int)\n        c = BytesIO()\n        np.savetxt(c, a, fmt='%d')\n        c.seek(0)\n        lines = c.readlines()\n        assert_equal(lines, [b'1\\n', b'2\\n', b'3\\n', b'4\\n'])\n\n    def test_record(self):\n        a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])\n        c = BytesIO()\n        np.savetxt(c, a, fmt='%d')\n        c.seek(0)\n        assert_equal(c.readlines(), [b'1 2\\n', b'3 4\\n'])\n\n    def test_delimiter(self):\n        a = np.array([[1., 2.], [3., 4.]])\n        c = BytesIO()\n        np.savetxt(c, a, delimiter=',', fmt='%d')\n        c.seek(0)\n        assert_equal(c.readlines(), [b'1,2\\n', b'3,4\\n'])\n\n    def test_format(self):\n        a = np.array([(1, 2), (3, 4)])\n        c = BytesIO()\n        # Sequence of formats\n        np.savetxt(c, a, fmt=['%02d', '%3.1f'])\n        c.seek(0)\n        assert_equal(c.readlines(), [b'01 2.0\\n', b'03 4.0\\n'])\n\n        # A single multiformat string\n        c = BytesIO()\n        np.savetxt(c, a, fmt='%02d : %3.1f')\n        c.seek(0)\n        lines = c.readlines()\n        assert_equal(lines, [b'01 : 2.0\\n', b'03 : 4.0\\n'])\n\n        # Specify delimiter, should be overiden\n        c = BytesIO()\n        np.savetxt(c, a, fmt='%02d : %3.1f', delimiter=',')\n        c.seek(0)\n        lines = c.readlines()\n        assert_equal(lines, [b'01 : 2.0\\n', b'03 : 4.0\\n'])\n\n        # Bad fmt, should raise a ValueError\n        c = BytesIO()\n        assert_raises(ValueError, np.savetxt, c, a, fmt=99)\n\n    def test_header_footer(self):\n        \"\"\"\n        Test the functionality of the header and footer keyword argument.\n        \"\"\"\n        c = BytesIO()\n        a = np.array([(1, 2), (3, 4)], dtype=np.int)\n        test_header_footer = 'Test header / footer'\n        # Test the header keyword argument\n        np.savetxt(c, a, fmt='%1d', header=test_header_footer)\n        c.seek(0)\n        assert_equal(c.read(),\n                     asbytes('# ' + test_header_footer + '\\n1 2\\n3 4\\n'))\n        # Test the footer keyword argument\n        c = BytesIO()\n        np.savetxt(c, a, fmt='%1d', footer=test_header_footer)\n        c.seek(0)\n        assert_equal(c.read(),\n                     asbytes('1 2\\n3 4\\n# ' + test_header_footer + '\\n'))\n        # Test the commentstr keyword argument used on the header\n        c = BytesIO()\n        commentstr = '% '\n        np.savetxt(c, a, fmt='%1d',\n                   header=test_header_footer, comments=commentstr)\n        c.seek(0)\n        assert_equal(c.read(),\n                     asbytes(commentstr + test_header_footer + '\\n' + '1 2\\n3 4\\n'))\n        # Test the commentstr keyword argument used on the footer\n        c = BytesIO()\n        commentstr = '% '\n        np.savetxt(c, a, fmt='%1d',\n                   footer=test_header_footer, comments=commentstr)\n        c.seek(0)\n        assert_equal(c.read(),\n                     asbytes('1 2\\n3 4\\n' + commentstr + test_header_footer + '\\n'))\n\n    def test_file_roundtrip(self):\n        f, name = mkstemp()\n        os.close(f)\n        try:\n            a = np.array([(1, 2), (3, 4)])\n            np.savetxt(name, a)\n            b = np.loadtxt(name)\n            assert_array_equal(a, b)\n        finally:\n            os.unlink(name)\n\n    def test_complex_arrays(self):\n        ncols = 2\n        nrows = 2\n        a = np.zeros((ncols, nrows), dtype=np.complex128)\n        re = np.pi\n        im = np.e\n        a[:] = re + 1.0j * im\n\n        # One format only\n        c = BytesIO()\n        np.savetxt(c, a, fmt=' %+.3e')\n        c.seek(0)\n        lines = c.readlines()\n        assert_equal(\n            lines,\n            [b' ( +3.142e+00+ +2.718e+00j)  ( +3.142e+00+ +2.718e+00j)\\n',\n             b' ( +3.142e+00+ +2.718e+00j)  ( +3.142e+00+ +2.718e+00j)\\n'])\n\n        # One format for each real and imaginary part\n        c = BytesIO()\n        np.savetxt(c, a, fmt='  %+.3e' * 2 * ncols)\n        c.seek(0)\n        lines = c.readlines()\n        assert_equal(\n            lines,\n            [b'  +3.142e+00  +2.718e+00  +3.142e+00  +2.718e+00\\n',\n             b'  +3.142e+00  +2.718e+00  +3.142e+00  +2.718e+00\\n'])\n\n        # One format for each complex number\n        c = BytesIO()\n        np.savetxt(c, a, fmt=['(%.3e%+.3ej)'] * ncols)\n        c.seek(0)\n        lines = c.readlines()\n        assert_equal(\n            lines,\n            [b'(3.142e+00+2.718e+00j) (3.142e+00+2.718e+00j)\\n',\n             b'(3.142e+00+2.718e+00j) (3.142e+00+2.718e+00j)\\n'])\n\n    def test_custom_writer(self):\n\n        class CustomWriter(list):\n            def write(self, text):\n                self.extend(text.split(b'\\n'))\n\n        w = CustomWriter()\n        a = np.array([(1, 2), (3, 4)])\n        np.savetxt(w, a)\n        b = np.loadtxt(w)\n        assert_array_equal(a, b)\n\n\nclass TestLoadTxt(TestCase):\n    def test_record(self):\n        c = TextIO()\n        c.write('1 2\\n3 4')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=[('x', np.int32), ('y', np.int32)])\n        a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])\n        assert_array_equal(x, a)\n\n        d = TextIO()\n        d.write('M 64.0 75.0\\nF 25.0 60.0')\n        d.seek(0)\n        mydescriptor = {'names': ('gender', 'age', 'weight'),\n                        'formats': ('S1', 'i4', 'f4')}\n        b = np.array([('M', 64.0, 75.0),\n                      ('F', 25.0, 60.0)], dtype=mydescriptor)\n        y = np.loadtxt(d, dtype=mydescriptor)\n        assert_array_equal(y, b)\n\n    def test_array(self):\n        c = TextIO()\n        c.write('1 2\\n3 4')\n\n        c.seek(0)\n        x = np.loadtxt(c, dtype=np.int)\n        a = np.array([[1, 2], [3, 4]], int)\n        assert_array_equal(x, a)\n\n        c.seek(0)\n        x = np.loadtxt(c, dtype=float)\n        a = np.array([[1, 2], [3, 4]], float)\n        assert_array_equal(x, a)\n\n    def test_1D(self):\n        c = TextIO()\n        c.write('1\\n2\\n3\\n4\\n')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int)\n        a = np.array([1, 2, 3, 4], int)\n        assert_array_equal(x, a)\n\n        c = TextIO()\n        c.write('1,2,3,4\\n')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int, delimiter=',')\n        a = np.array([1, 2, 3, 4], int)\n        assert_array_equal(x, a)\n\n    def test_missing(self):\n        c = TextIO()\n        c.write('1,2,3,,5\\n')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int, delimiter=',',\n                       converters={3: lambda s: int(s or - 999)})\n        a = np.array([1, 2, 3, -999, 5], int)\n        assert_array_equal(x, a)\n\n    def test_converters_with_usecols(self):\n        c = TextIO()\n        c.write('1,2,3,,5\\n6,7,8,9,10\\n')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int, delimiter=',',\n                       converters={3: lambda s: int(s or - 999)},\n                       usecols=(1, 3,))\n        a = np.array([[2, -999], [7, 9]], int)\n        assert_array_equal(x, a)\n\n    def test_comments(self):\n        c = TextIO()\n        c.write('# comment\\n1,2,3,5\\n')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int, delimiter=',',\n                       comments='#')\n        a = np.array([1, 2, 3, 5], int)\n        assert_array_equal(x, a)\n\n    def test_skiprows(self):\n        c = TextIO()\n        c.write('comment\\n1,2,3,5\\n')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int, delimiter=',',\n                       skiprows=1)\n        a = np.array([1, 2, 3, 5], int)\n        assert_array_equal(x, a)\n\n        c = TextIO()\n        c.write('# comment\\n1,2,3,5\\n')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int, delimiter=',',\n                       skiprows=1)\n        a = np.array([1, 2, 3, 5], int)\n        assert_array_equal(x, a)\n\n    def test_usecols(self):\n        a = np.array([[1, 2], [3, 4]], float)\n        c = BytesIO()\n        np.savetxt(c, a)\n        c.seek(0)\n        x = np.loadtxt(c, dtype=float, usecols=(1,))\n        assert_array_equal(x, a[:, 1])\n\n        a = np.array([[1, 2, 3], [3, 4, 5]], float)\n        c = BytesIO()\n        np.savetxt(c, a)\n        c.seek(0)\n        x = np.loadtxt(c, dtype=float, usecols=(1, 2))\n        assert_array_equal(x, a[:, 1:])\n\n        # Testing with arrays instead of tuples.\n        c.seek(0)\n        x = np.loadtxt(c, dtype=float, usecols=np.array([1, 2]))\n        assert_array_equal(x, a[:, 1:])\n\n        # Checking with dtypes defined converters.\n        data = '''JOE 70.1 25.3\n                BOB 60.5 27.9\n                '''\n        c = TextIO(data)\n        names = ['stid', 'temp']\n        dtypes = ['S4', 'f8']\n        arr = np.loadtxt(c, usecols=(0, 2), dtype=list(zip(names, dtypes)))\n        assert_equal(arr['stid'], [b\"JOE\", b\"BOB\"])\n        assert_equal(arr['temp'], [25.3, 27.9])\n\n    def test_fancy_dtype(self):\n        c = TextIO()\n        c.write('1,2,3.0\\n4,5,6.0\\n')\n        c.seek(0)\n        dt = np.dtype([('x', int), ('y', [('t', int), ('s', float)])])\n        x = np.loadtxt(c, dtype=dt, delimiter=',')\n        a = np.array([(1, (2, 3.0)), (4, (5, 6.0))], dt)\n        assert_array_equal(x, a)\n\n    def test_shaped_dtype(self):\n        c = TextIO(\"aaaa  1.0  8.0  1 2 3 4 5 6\")\n        dt = np.dtype([('name', 'S4'), ('x', float), ('y', float),\n                       ('block', int, (2, 3))])\n        x = np.loadtxt(c, dtype=dt)\n        a = np.array([('aaaa', 1.0, 8.0, [[1, 2, 3], [4, 5, 6]])],\n                     dtype=dt)\n        assert_array_equal(x, a)\n\n    def test_3d_shaped_dtype(self):\n        c = TextIO(\"aaaa  1.0  8.0  1 2 3 4 5 6 7 8 9 10 11 12\")\n        dt = np.dtype([('name', 'S4'), ('x', float), ('y', float),\n                       ('block', int, (2, 2, 3))])\n        x = np.loadtxt(c, dtype=dt)\n        a = np.array([('aaaa', 1.0, 8.0,\n                       [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])],\n                     dtype=dt)\n        assert_array_equal(x, a)\n\n    def test_empty_file(self):\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\",\n                                    message=\"loadtxt: Empty input file:\")\n            c = TextIO()\n            x = np.loadtxt(c)\n            assert_equal(x.shape, (0,))\n            x = np.loadtxt(c, dtype=np.int64)\n            assert_equal(x.shape, (0,))\n            assert_(x.dtype == np.int64)\n\n    def test_unused_converter(self):\n        c = TextIO()\n        c.writelines(['1 21\\n', '3 42\\n'])\n        c.seek(0)\n        data = np.loadtxt(c, usecols=(1,),\n                          converters={0: lambda s: int(s, 16)})\n        assert_array_equal(data, [21, 42])\n\n        c.seek(0)\n        data = np.loadtxt(c, usecols=(1,),\n                          converters={1: lambda s: int(s, 16)})\n        assert_array_equal(data, [33, 66])\n\n    def test_dtype_with_object(self):\n        \"Test using an explicit dtype with an object\"\n        from datetime import date\n        import time\n        data = \"\"\" 1; 2001-01-01\n                   2; 2002-01-31 \"\"\"\n        ndtype = [('idx', int), ('code', np.object)]\n        func = lambda s: strptime(s.strip(), \"%Y-%m-%d\")\n        converters = {1: func}\n        test = np.loadtxt(TextIO(data), delimiter=\";\", dtype=ndtype,\n                          converters=converters)\n        control = np.array(\n            [(1, datetime(2001, 1, 1)), (2, datetime(2002, 1, 31))],\n            dtype=ndtype)\n        assert_equal(test, control)\n\n    def test_uint64_type(self):\n        tgt = (9223372043271415339, 9223372043271415853)\n        c = TextIO()\n        c.write(\"%s %s\" % tgt)\n        c.seek(0)\n        res = np.loadtxt(c, dtype=np.uint64)\n        assert_equal(res, tgt)\n\n    def test_int64_type(self):\n        tgt = (-9223372036854775807, 9223372036854775807)\n        c = TextIO()\n        c.write(\"%s %s\" % tgt)\n        c.seek(0)\n        res = np.loadtxt(c, dtype=np.int64)\n        assert_equal(res, tgt)\n\n    def test_universal_newline(self):\n        f, name = mkstemp()\n        os.write(f, b'1 21\\r3 42\\r')\n        os.close(f)\n\n        try:\n            data = np.loadtxt(name)\n            assert_array_equal(data, [[1, 21], [3, 42]])\n        finally:\n            os.unlink(name)\n\n    def test_empty_field_after_tab(self):\n        c = TextIO()\n        c.write('1 \\t2 \\t3\\tstart \\n4\\t5\\t6\\t  \\n7\\t8\\t9.5\\t')\n        c.seek(0)\n        dt = {'names': ('x', 'y', 'z', 'comment'),\n              'formats': ('<i4', '<i4', '<f4', '|S8')}\n        x = np.loadtxt(c, dtype=dt, delimiter='\\t')\n        a = np.array([b'start ', b'  ', b''])\n        assert_array_equal(x['comment'], a)\n\n    def test_structure_unpack(self):\n        txt = TextIO(\"M 21 72\\nF 35 58\")\n        dt = {'names': ('a', 'b', 'c'), 'formats': ('|S1', '<i4', '<f4')}\n        a, b, c = np.loadtxt(txt, dtype=dt, unpack=True)\n        assert_(a.dtype.str == '|S1')\n        assert_(b.dtype.str == '<i4')\n        assert_(c.dtype.str == '<f4')\n        assert_array_equal(a, np.array([b'M', b'F']))\n        assert_array_equal(b, np.array([21, 35]))\n        assert_array_equal(c, np.array([72.,  58.]))\n\n    def test_ndmin_keyword(self):\n        c = TextIO()\n        c.write('1,2,3\\n4,5,6')\n        c.seek(0)\n        assert_raises(ValueError, np.loadtxt, c, ndmin=3)\n        c.seek(0)\n        assert_raises(ValueError, np.loadtxt, c, ndmin=1.5)\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int, delimiter=',', ndmin=1)\n        a = np.array([[1, 2, 3], [4, 5, 6]])\n        assert_array_equal(x, a)\n\n        d = TextIO()\n        d.write('0,1,2')\n        d.seek(0)\n        x = np.loadtxt(d, dtype=int, delimiter=',', ndmin=2)\n        assert_(x.shape == (1, 3))\n        d.seek(0)\n        x = np.loadtxt(d, dtype=int, delimiter=',', ndmin=1)\n        assert_(x.shape == (3,))\n        d.seek(0)\n        x = np.loadtxt(d, dtype=int, delimiter=',', ndmin=0)\n        assert_(x.shape == (3,))\n\n        e = TextIO()\n        e.write('0\\n1\\n2')\n        e.seek(0)\n        x = np.loadtxt(e, dtype=int, delimiter=',', ndmin=2)\n        assert_(x.shape == (3, 1))\n        e.seek(0)\n        x = np.loadtxt(e, dtype=int, delimiter=',', ndmin=1)\n        assert_(x.shape == (3,))\n        e.seek(0)\n        x = np.loadtxt(e, dtype=int, delimiter=',', ndmin=0)\n        assert_(x.shape == (3,))\n\n        # Test ndmin kw with empty file.\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\",\n                                    message=\"loadtxt: Empty input file:\")\n            f = TextIO()\n            assert_(np.loadtxt(f, ndmin=2).shape == (0, 1,))\n            assert_(np.loadtxt(f, ndmin=1).shape == (0,))\n\n    def test_generator_source(self):\n        def count():\n            for i in range(10):\n                yield \"%d\" % i\n\n        res = np.loadtxt(count())\n        assert_array_equal(res, np.arange(10))\n\n\nclass Testfromregex(TestCase):\n    # np.fromregex expects files opened in binary mode.\n    def test_record(self):\n        c = TextIO()\n        c.write('1.312 foo\\n1.534 bar\\n4.444 qux')\n        c.seek(0)\n\n        dt = [('num', np.float64), ('val', 'S3')]\n        x = np.fromregex(c, r\"([0-9.]+)\\s+(...)\", dt)\n        a = np.array([(1.312, 'foo'), (1.534, 'bar'), (4.444, 'qux')],\n                     dtype=dt)\n        assert_array_equal(x, a)\n\n    def test_record_2(self):\n        c = TextIO()\n        c.write('1312 foo\\n1534 bar\\n4444 qux')\n        c.seek(0)\n\n        dt = [('num', np.int32), ('val', 'S3')]\n        x = np.fromregex(c, r\"(\\d+)\\s+(...)\", dt)\n        a = np.array([(1312, 'foo'), (1534, 'bar'), (4444, 'qux')],\n                     dtype=dt)\n        assert_array_equal(x, a)\n\n    def test_record_3(self):\n        c = TextIO()\n        c.write('1312 foo\\n1534 bar\\n4444 qux')\n        c.seek(0)\n\n        dt = [('num', np.float64)]\n        x = np.fromregex(c, r\"(\\d+)\\s+...\", dt)\n        a = np.array([(1312,), (1534,), (4444,)], dtype=dt)\n        assert_array_equal(x, a)\n\n\n#####--------------------------------------------------------------------------\n\n\nclass TestFromTxt(TestCase):\n    #\n    def test_record(self):\n        \"Test w/ explicit dtype\"\n        data = TextIO('1 2\\n3 4')\n#        data.seek(0)\n        test = np.ndfromtxt(data, dtype=[('x', np.int32), ('y', np.int32)])\n        control = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])\n        assert_equal(test, control)\n        #\n        data = TextIO('M 64.0 75.0\\nF 25.0 60.0')\n#        data.seek(0)\n        descriptor = {'names': ('gender', 'age', 'weight'),\n                      'formats': ('S1', 'i4', 'f4')}\n        control = np.array([('M', 64.0, 75.0), ('F', 25.0, 60.0)],\n                           dtype=descriptor)\n        test = np.ndfromtxt(data, dtype=descriptor)\n        assert_equal(test, control)\n\n    def test_array(self):\n        \"Test outputing a standard ndarray\"\n        data = TextIO('1 2\\n3 4')\n        control = np.array([[1, 2], [3, 4]], dtype=int)\n        test = np.ndfromtxt(data, dtype=int)\n        assert_array_equal(test, control)\n        #\n        data.seek(0)\n        control = np.array([[1, 2], [3, 4]], dtype=float)\n        test = np.loadtxt(data, dtype=float)\n        assert_array_equal(test, control)\n\n    def test_1D(self):\n        \"Test squeezing to 1D\"\n        control = np.array([1, 2, 3, 4], int)\n        #\n        data = TextIO('1\\n2\\n3\\n4\\n')\n        test = np.ndfromtxt(data, dtype=int)\n        assert_array_equal(test, control)\n        #\n        data = TextIO('1,2,3,4\\n')\n        test = np.ndfromtxt(data, dtype=int, delimiter=',')\n        assert_array_equal(test, control)\n\n    def test_comments(self):\n        \"Test the stripping of comments\"\n        control = np.array([1, 2, 3, 5], int)\n        # Comment on its own line\n        data = TextIO('# comment\\n1,2,3,5\\n')\n        test = np.ndfromtxt(data, dtype=int, delimiter=',', comments='#')\n        assert_equal(test, control)\n        # Comment at the end of a line\n        data = TextIO('1,2,3,5# comment\\n')\n        test = np.ndfromtxt(data, dtype=int, delimiter=',', comments='#')\n        assert_equal(test, control)\n\n    def test_skiprows(self):\n        \"Test row skipping\"\n        control = np.array([1, 2, 3, 5], int)\n        kwargs = dict(dtype=int, delimiter=',')\n        #\n        data = TextIO('comment\\n1,2,3,5\\n')\n        test = np.ndfromtxt(data, skip_header=1, **kwargs)\n        assert_equal(test, control)\n        #\n        data = TextIO('# comment\\n1,2,3,5\\n')\n        test = np.loadtxt(data, skiprows=1, **kwargs)\n        assert_equal(test, control)\n\n    def test_skip_footer(self):\n        data = [\"# %i\" % i for i in range(1, 6)]\n        data.append(\"A, B, C\")\n        data.extend([\"%i,%3.1f,%03s\" % (i, i, i) for i in range(51)])\n        data[-1] = \"99,99\"\n        kwargs = dict(delimiter=\",\", names=True, skip_header=5, skip_footer=10)\n        test = np.genfromtxt(TextIO(\"\\n\".join(data)), **kwargs)\n        ctrl = np.array([(\"%f\" % i, \"%f\" % i, \"%f\" % i) for i in range(41)],\n                        dtype=[(_, float) for _ in \"ABC\"])\n        assert_equal(test, ctrl)\n\n    def test_skip_footer_with_invalid(self):\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\")\n            basestr = '1 1\\n2 2\\n3 3\\n4 4\\n5  \\n6  \\n7  \\n'\n            # Footer too small to get rid of all invalid values\n            assert_raises(ValueError, np.genfromtxt,\n                          TextIO(basestr), skip_footer=1)\n    #        except ValueError:\n    #            pass\n            a = np.genfromtxt(\n                TextIO(basestr), skip_footer=1, invalid_raise=False)\n            assert_equal(a, np.array([[1., 1.], [2., 2.], [3., 3.], [4., 4.]]))\n            #\n            a = np.genfromtxt(TextIO(basestr), skip_footer=3)\n            assert_equal(a, np.array([[1., 1.], [2., 2.], [3., 3.], [4., 4.]]))\n            #\n            basestr = '1 1\\n2  \\n3 3\\n4 4\\n5  \\n6 6\\n7 7\\n'\n            a = np.genfromtxt(\n                TextIO(basestr), skip_footer=1, invalid_raise=False)\n            assert_equal(a, np.array([[1., 1.], [3., 3.], [4., 4.], [6., 6.]]))\n            a = np.genfromtxt(\n                TextIO(basestr), skip_footer=3, invalid_raise=False)\n            assert_equal(a, np.array([[1., 1.], [3., 3.], [4., 4.]]))\n\n    def test_header(self):\n        \"Test retrieving a header\"\n        data = TextIO('gender age weight\\nM 64.0 75.0\\nF 25.0 60.0')\n        test = np.ndfromtxt(data, dtype=None, names=True)\n        control = {'gender': np.array([b'M', b'F']),\n                   'age': np.array([64.0, 25.0]),\n                   'weight': np.array([75.0, 60.0])}\n        assert_equal(test['gender'], control['gender'])\n        assert_equal(test['age'], control['age'])\n        assert_equal(test['weight'], control['weight'])\n\n    def test_auto_dtype(self):\n        \"Test the automatic definition of the output dtype\"\n        data = TextIO('A 64 75.0 3+4j True\\nBCD 25 60.0 5+6j False')\n        test = np.ndfromtxt(data, dtype=None)\n        control = [np.array([b'A', b'BCD']),\n                   np.array([64, 25]),\n                   np.array([75.0, 60.0]),\n                   np.array([3 + 4j, 5 + 6j]),\n                   np.array([True, False]), ]\n        assert_equal(test.dtype.names, ['f0', 'f1', 'f2', 'f3', 'f4'])\n        for (i, ctrl) in enumerate(control):\n            assert_equal(test['f%i' % i], ctrl)\n\n    def test_auto_dtype_uniform(self):\n        \"Tests whether the output dtype can be uniformized\"\n        data = TextIO('1 2 3 4\\n5 6 7 8\\n')\n        test = np.ndfromtxt(data, dtype=None)\n        control = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\n        assert_equal(test, control)\n\n    def test_fancy_dtype(self):\n        \"Check that a nested dtype isn't MIA\"\n        data = TextIO('1,2,3.0\\n4,5,6.0\\n')\n        fancydtype = np.dtype([('x', int), ('y', [('t', int), ('s', float)])])\n        test = np.ndfromtxt(data, dtype=fancydtype, delimiter=',')\n        control = np.array([(1, (2, 3.0)), (4, (5, 6.0))], dtype=fancydtype)\n        assert_equal(test, control)\n\n    def test_names_overwrite(self):\n        \"Test overwriting the names of the dtype\"\n        descriptor = {'names': ('g', 'a', 'w'),\n                      'formats': ('S1', 'i4', 'f4')}\n        data = TextIO(b'M 64.0 75.0\\nF 25.0 60.0')\n        names = ('gender', 'age', 'weight')\n        test = np.ndfromtxt(data, dtype=descriptor, names=names)\n        descriptor['names'] = names\n        control = np.array([('M', 64.0, 75.0),\n                            ('F', 25.0, 60.0)], dtype=descriptor)\n        assert_equal(test, control)\n\n    def test_commented_header(self):\n        \"Check that names can be retrieved even if the line is commented out.\"\n        data = TextIO(\"\"\"\n#gender age weight\nM   21  72.100000\nF   35  58.330000\nM   33  21.99\n        \"\"\")\n        # The # is part of the first name and should be deleted automatically.\n        test = np.genfromtxt(data, names=True, dtype=None)\n        ctrl = np.array([('M', 21, 72.1), ('F', 35, 58.33), ('M', 33, 21.99)],\n                        dtype=[('gender', '|S1'), ('age', int), ('weight', float)])\n        assert_equal(test, ctrl)\n        # Ditto, but we should get rid of the first element\n        data = TextIO(b\"\"\"\n# gender age weight\nM   21  72.100000\nF   35  58.330000\nM   33  21.99\n        \"\"\")\n        test = np.genfromtxt(data, names=True, dtype=None)\n        assert_equal(test, ctrl)\n\n    def test_autonames_and_usecols(self):\n        \"Tests names and usecols\"\n        data = TextIO('A B C D\\n aaaa 121 45 9.1')\n        test = np.ndfromtxt(data, usecols=('A', 'C', 'D'),\n                            names=True, dtype=None)\n        control = np.array(('aaaa', 45, 9.1),\n                           dtype=[('A', '|S4'), ('C', int), ('D', float)])\n        assert_equal(test, control)\n\n    def test_converters_with_usecols(self):\n        \"Test the combination user-defined converters and usecol\"\n        data = TextIO('1,2,3,,5\\n6,7,8,9,10\\n')\n        test = np.ndfromtxt(data, dtype=int, delimiter=',',\n                            converters={3: lambda s: int(s or - 999)},\n                            usecols=(1, 3,))\n        control = np.array([[2, -999], [7, 9]], int)\n        assert_equal(test, control)\n\n    def test_converters_with_usecols_and_names(self):\n        \"Tests names and usecols\"\n        data = TextIO('A B C D\\n aaaa 121 45 9.1')\n        test = np.ndfromtxt(data, usecols=('A', 'C', 'D'), names=True,\n                            dtype=None, converters={'C': lambda s: 2 * int(s)})\n        control = np.array(('aaaa', 90, 9.1),\n                           dtype=[('A', '|S4'), ('C', int), ('D', float)])\n        assert_equal(test, control)\n\n    def test_converters_cornercases(self):\n        \"Test the conversion to datetime.\"\n        converter = {\n            'date': lambda s: strptime(s, '%Y-%m-%d %H:%M:%SZ')}\n        data = TextIO('2009-02-03 12:00:00Z, 72214.0')\n        test = np.ndfromtxt(data, delimiter=',', dtype=None,\n                            names=['date', 'stid'], converters=converter)\n        control = np.array((datetime(2009, 2, 3), 72214.),\n                           dtype=[('date', np.object_), ('stid', float)])\n        assert_equal(test, control)\n\n    def test_converters_cornercases2(self):\n        \"Test the conversion to datetime64.\"\n        converter = {\n            'date': lambda s: np.datetime64(strptime(s, '%Y-%m-%d %H:%M:%SZ'))}\n        data = TextIO('2009-02-03 12:00:00Z, 72214.0')\n        test = np.ndfromtxt(data, delimiter=',', dtype=None,\n                            names=['date', 'stid'], converters=converter)\n        control = np.array((datetime(2009, 2, 3), 72214.),\n                           dtype=[('date', 'datetime64[us]'), ('stid', float)])\n        assert_equal(test, control)\n\n    def test_unused_converter(self):\n        \"Test whether unused converters are forgotten\"\n        data = TextIO(\"1 21\\n  3 42\\n\")\n        test = np.ndfromtxt(data, usecols=(1,),\n                            converters={0: lambda s: int(s, 16)})\n        assert_equal(test, [21, 42])\n        #\n        data.seek(0)\n        test = np.ndfromtxt(data, usecols=(1,),\n                            converters={1: lambda s: int(s, 16)})\n        assert_equal(test, [33, 66])\n\n    def test_invalid_converter(self):\n        strip_rand = lambda x: float((b'r' in x.lower() and x.split()[-1]) or\n                                     (b'r' not in x.lower() and x.strip() or 0.0))\n        strip_per = lambda x: float((b'%' in x.lower() and x.split()[0]) or\n                                    (b'%' not in x.lower() and x.strip() or 0.0))\n        s = TextIO(\"D01N01,10/1/2003 ,1 %,R 75,400,600\\r\\n\"\n                   \"L24U05,12/5/2003, 2 %,1,300, 150.5\\r\\n\"\n                   \"D02N03,10/10/2004,R 1,,7,145.55\")\n        kwargs = dict(\n            converters={2: strip_per, 3: strip_rand}, delimiter=\",\",\n            dtype=None)\n        assert_raises(ConverterError, np.genfromtxt, s, **kwargs)\n\n    def test_tricky_converter_bug1666(self):\n        \"Test some corner case\"\n        s = TextIO('q1,2\\nq3,4')\n        cnv = lambda s: float(s[1:])\n        test = np.genfromtxt(s, delimiter=',', converters={0: cnv})\n        control = np.array([[1., 2.], [3., 4.]])\n        assert_equal(test, control)\n\n    def test_dtype_with_converters(self):\n        dstr = \"2009; 23; 46\"\n        test = np.ndfromtxt(TextIO(dstr,),\n                            delimiter=\";\", dtype=float, converters={0: bytes})\n        control = np.array([('2009', 23., 46)],\n                           dtype=[('f0', '|S4'), ('f1', float), ('f2', float)])\n        assert_equal(test, control)\n        test = np.ndfromtxt(TextIO(dstr,),\n                            delimiter=\";\", dtype=float, converters={0: float})\n        control = np.array([2009., 23., 46],)\n        assert_equal(test, control)\n\n    def test_dtype_with_object(self):\n        \"Test using an explicit dtype with an object\"\n        from datetime import date\n        import time\n        data = \"\"\" 1; 2001-01-01\n                   2; 2002-01-31 \"\"\"\n        ndtype = [('idx', int), ('code', np.object)]\n        func = lambda s: strptime(s.strip(), \"%Y-%m-%d\")\n        converters = {1: func}\n        test = np.genfromtxt(TextIO(data), delimiter=\";\", dtype=ndtype,\n                             converters=converters)\n        control = np.array(\n            [(1, datetime(2001, 1, 1)), (2, datetime(2002, 1, 31))],\n            dtype=ndtype)\n        assert_equal(test, control)\n        #\n        ndtype = [('nest', [('idx', int), ('code', np.object)])]\n        try:\n            test = np.genfromtxt(TextIO(data), delimiter=\";\",\n                                 dtype=ndtype, converters=converters)\n        except NotImplementedError:\n            pass\n        else:\n            errmsg = \"Nested dtype involving objects should be supported.\"\n            raise AssertionError(errmsg)\n\n    def test_userconverters_with_explicit_dtype(self):\n        \"Test user_converters w/ explicit (standard) dtype\"\n        data = TextIO('skip,skip,2001-01-01,1.0,skip')\n        test = np.genfromtxt(data, delimiter=\",\", names=None, dtype=float,\n                             usecols=(2, 3), converters={2: bytes})\n        control = np.array([('2001-01-01', 1.)],\n                           dtype=[('', '|S10'), ('', float)])\n        assert_equal(test, control)\n\n    def test_spacedelimiter(self):\n        \"Test space delimiter\"\n        data = TextIO(\"1  2  3  4   5\\n6  7  8  9  10\")\n        test = np.ndfromtxt(data)\n        control = np.array([[1., 2., 3., 4., 5.],\n                            [6., 7., 8., 9., 10.]])\n        assert_equal(test, control)\n\n    def test_integer_delimiter(self):\n        \"Test using an integer for delimiter\"\n        data = \"  1  2  3\\n  4  5 67\\n890123  4\"\n        test = np.genfromtxt(TextIO(data), delimiter=3)\n        control = np.array([[1, 2, 3], [4, 5, 67], [890, 123, 4]])\n        assert_equal(test, control)\n\n    def test_missing(self):\n        data = TextIO('1,2,3,,5\\n')\n        test = np.ndfromtxt(data, dtype=int, delimiter=',',\n                            converters={3: lambda s: int(s or - 999)})\n        control = np.array([1, 2, 3, -999, 5], int)\n        assert_equal(test, control)\n\n    def test_missing_with_tabs(self):\n        \"Test w/ a delimiter tab\"\n        txt = \"1\\t2\\t3\\n\\t2\\t\\n1\\t\\t3\"\n        test = np.genfromtxt(TextIO(txt), delimiter=\"\\t\",\n                             usemask=True,)\n        ctrl_d = np.array([(1, 2, 3), (np.nan, 2, np.nan), (1, np.nan, 3)],)\n        ctrl_m = np.array([(0, 0, 0), (1, 0, 1), (0, 1, 0)], dtype=bool)\n        assert_equal(test.data, ctrl_d)\n        assert_equal(test.mask, ctrl_m)\n\n    def test_usecols(self):\n        \"Test the selection of columns\"\n        # Select 1 column\n        control = np.array([[1, 2], [3, 4]], float)\n        data = TextIO()\n        np.savetxt(data, control)\n        data.seek(0)\n        test = np.ndfromtxt(data, dtype=float, usecols=(1,))\n        assert_equal(test, control[:, 1])\n        #\n        control = np.array([[1, 2, 3], [3, 4, 5]], float)\n        data = TextIO()\n        np.savetxt(data, control)\n        data.seek(0)\n        test = np.ndfromtxt(data, dtype=float, usecols=(1, 2))\n        assert_equal(test, control[:, 1:])\n        # Testing with arrays instead of tuples.\n        data.seek(0)\n        test = np.ndfromtxt(data, dtype=float, usecols=np.array([1, 2]))\n        assert_equal(test, control[:, 1:])\n\n    def test_usecols_as_css(self):\n        \"Test giving usecols with a comma-separated string\"\n        data = \"1 2 3\\n4 5 6\"\n        test = np.genfromtxt(TextIO(data),\n                             names=\"a, b, c\", usecols=\"a, c\")\n        ctrl = np.array([(1, 3), (4, 6)], dtype=[(_, float) for _ in \"ac\"])\n        assert_equal(test, ctrl)\n\n    def test_usecols_with_structured_dtype(self):\n        \"Test usecols with an explicit structured dtype\"\n        data = TextIO(\"JOE 70.1 25.3\\nBOB 60.5 27.9\")\n        names = ['stid', 'temp']\n        dtypes = ['S4', 'f8']\n        test = np.ndfromtxt(\n            data, usecols=(0, 2), dtype=list(zip(names, dtypes)))\n        assert_equal(test['stid'], [b\"JOE\", b\"BOB\"])\n        assert_equal(test['temp'], [25.3, 27.9])\n\n    def test_usecols_with_integer(self):\n        \"Test usecols with an integer\"\n        test = np.genfromtxt(TextIO(b\"1 2 3\\n4 5 6\"), usecols=0)\n        assert_equal(test, np.array([1., 4.]))\n\n    def test_usecols_with_named_columns(self):\n        \"Test usecols with named columns\"\n        ctrl = np.array([(1, 3), (4, 6)], dtype=[('a', float), ('c', float)])\n        data = \"1 2 3\\n4 5 6\"\n        kwargs = dict(names=\"a, b, c\")\n        test = np.genfromtxt(TextIO(data), usecols=(0, -1), **kwargs)\n        assert_equal(test, ctrl)\n        test = np.genfromtxt(TextIO(data),\n                             usecols=('a', 'c'), **kwargs)\n        assert_equal(test, ctrl)\n\n    def test_empty_file(self):\n        \"Test that an empty file raises the proper warning.\"\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\",\n                                    message=\"genfromtxt: Empty input file:\")\n            data = TextIO()\n            test = np.genfromtxt(data)\n            assert_equal(test, np.array([]))\n\n    def test_fancy_dtype_alt(self):\n        \"Check that a nested dtype isn't MIA\"\n        data = TextIO('1,2,3.0\\n4,5,6.0\\n')\n        fancydtype = np.dtype([('x', int), ('y', [('t', int), ('s', float)])])\n        test = np.mafromtxt(data, dtype=fancydtype, delimiter=',')\n        control = ma.array([(1, (2, 3.0)), (4, (5, 6.0))], dtype=fancydtype)\n        assert_equal(test, control)\n\n    def test_shaped_dtype(self):\n        c = TextIO(\"aaaa  1.0  8.0  1 2 3 4 5 6\")\n        dt = np.dtype([('name', 'S4'), ('x', float), ('y', float),\n                       ('block', int, (2, 3))])\n        x = np.ndfromtxt(c, dtype=dt)\n        a = np.array([('aaaa', 1.0, 8.0, [[1, 2, 3], [4, 5, 6]])],\n                     dtype=dt)\n        assert_array_equal(x, a)\n\n    def test_withmissing(self):\n        data = TextIO('A,B\\n0,1\\n2,N/A')\n        kwargs = dict(delimiter=\",\", missing_values=\"N/A\", names=True)\n        test = np.mafromtxt(data, dtype=None, **kwargs)\n        control = ma.array([(0, 1), (2, -1)],\n                           mask=[(False, False), (False, True)],\n                           dtype=[('A', np.int), ('B', np.int)])\n        assert_equal(test, control)\n        assert_equal(test.mask, control.mask)\n        #\n        data.seek(0)\n        test = np.mafromtxt(data, **kwargs)\n        control = ma.array([(0, 1), (2, -1)],\n                           mask=[(False, False), (False, True)],\n                           dtype=[('A', np.float), ('B', np.float)])\n        assert_equal(test, control)\n        assert_equal(test.mask, control.mask)\n\n    def test_user_missing_values(self):\n        data = \"A, B, C\\n0, 0., 0j\\n1, N/A, 1j\\n-9, 2.2, N/A\\n3, -99, 3j\"\n        basekwargs = dict(dtype=None, delimiter=\",\", names=True,)\n        mdtype = [('A', int), ('B', float), ('C', complex)]\n        #\n        test = np.mafromtxt(TextIO(data), missing_values=\"N/A\",\n                            **basekwargs)\n        control = ma.array([(0, 0.0, 0j), (1, -999, 1j),\n                            (-9, 2.2, -999j), (3, -99, 3j)],\n                           mask=[(0, 0, 0), (0, 1, 0), (0, 0, 1), (0, 0, 0)],\n                           dtype=mdtype)\n        assert_equal(test, control)\n        #\n        basekwargs['dtype'] = mdtype\n        test = np.mafromtxt(TextIO(data),\n                            missing_values={0: -9, 1: -99, 2: -999j}, **basekwargs)\n        control = ma.array([(0, 0.0, 0j), (1, -999, 1j),\n                            (-9, 2.2, -999j), (3, -99, 3j)],\n                           mask=[(0, 0, 0), (0, 1, 0), (1, 0, 1), (0, 1, 0)],\n                           dtype=mdtype)\n        assert_equal(test, control)\n        #\n        test = np.mafromtxt(TextIO(data),\n                            missing_values={0: -9, 'B': -99, 'C': -999j},\n                            **basekwargs)\n        control = ma.array([(0, 0.0, 0j), (1, -999, 1j),\n                            (-9, 2.2, -999j), (3, -99, 3j)],\n                           mask=[(0, 0, 0), (0, 1, 0), (1, 0, 1), (0, 1, 0)],\n                           dtype=mdtype)\n        assert_equal(test, control)\n\n    def test_user_filling_values(self):\n        \"Test with missing and filling values\"\n        ctrl = np.array([(0, 3), (4, -999)], dtype=[('a', int), ('b', int)])\n        data = \"N/A, 2, 3\\n4, ,???\"\n        kwargs = dict(delimiter=\",\",\n                      dtype=int,\n                      names=\"a,b,c\",\n                      missing_values={0: \"N/A\", 'b': \" \", 2: \"???\"},\n                      filling_values={0: 0, 'b': 0, 2: -999})\n        test = np.genfromtxt(TextIO(data), **kwargs)\n        ctrl = np.array([(0, 2, 3), (4, 0, -999)],\n                        dtype=[(_, int) for _ in \"abc\"])\n        assert_equal(test, ctrl)\n        #\n        test = np.genfromtxt(TextIO(data), usecols=(0, -1), **kwargs)\n        ctrl = np.array([(0, 3), (4, -999)], dtype=[(_, int) for _ in \"ac\"])\n        assert_equal(test, ctrl)\n\n    def test_withmissing_float(self):\n        data = TextIO('A,B\\n0,1.5\\n2,-999.00')\n        test = np.mafromtxt(data, dtype=None, delimiter=',',\n                            missing_values='-999.0', names=True,)\n        control = ma.array([(0, 1.5), (2, -1.)],\n                           mask=[(False, False), (False, True)],\n                           dtype=[('A', np.int), ('B', np.float)])\n        assert_equal(test, control)\n        assert_equal(test.mask, control.mask)\n\n    def test_with_masked_column_uniform(self):\n        \"Test masked column\"\n        data = TextIO('1 2 3\\n4 5 6\\n')\n        test = np.genfromtxt(data, dtype=None,\n                             missing_values='2,5', usemask=True)\n        control = ma.array([[1, 2, 3], [4, 5, 6]], mask=[[0, 1, 0], [0, 1, 0]])\n        assert_equal(test, control)\n\n    def test_with_masked_column_various(self):\n        \"Test masked column\"\n        data = TextIO('True 2 3\\nFalse 5 6\\n')\n        test = np.genfromtxt(data, dtype=None,\n                             missing_values='2,5', usemask=True)\n        control = ma.array([(1, 2, 3), (0, 5, 6)],\n                           mask=[(0, 1, 0), (0, 1, 0)],\n                           dtype=[('f0', bool), ('f1', bool), ('f2', int)])\n        assert_equal(test, control)\n\n    def test_invalid_raise(self):\n        \"Test invalid raise\"\n        data = [\"1, 1, 1, 1, 1\"] * 50\n        for i in range(5):\n            data[10 * i] = \"2, 2, 2, 2 2\"\n        data.insert(0, \"a, b, c, d, e\")\n        mdata = TextIO(\"\\n\".join(data))\n        #\n        kwargs = dict(delimiter=\",\", dtype=None, names=True)\n        # XXX: is there a better way to get the return value of the callable in\n        # assert_warns ?\n        ret = {}\n\n        def f(_ret={}):\n            _ret['mtest'] = np.ndfromtxt(mdata, invalid_raise=False, **kwargs)\n        assert_warns(ConversionWarning, f, _ret=ret)\n        mtest = ret['mtest']\n        assert_equal(len(mtest), 45)\n        assert_equal(mtest, np.ones(45, dtype=[(_, int) for _ in 'abcde']))\n        #\n        mdata.seek(0)\n        assert_raises(ValueError, np.ndfromtxt, mdata,\n                      delimiter=\",\", names=True)\n\n    def test_invalid_raise_with_usecols(self):\n        \"Test invalid_raise with usecols\"\n        data = [\"1, 1, 1, 1, 1\"] * 50\n        for i in range(5):\n            data[10 * i] = \"2, 2, 2, 2 2\"\n        data.insert(0, \"a, b, c, d, e\")\n        mdata = TextIO(\"\\n\".join(data))\n        kwargs = dict(delimiter=\",\", dtype=None, names=True,\n                      invalid_raise=False)\n        # XXX: is there a better way to get the return value of the callable in\n        # assert_warns ?\n        ret = {}\n\n        def f(_ret={}):\n            _ret['mtest'] = np.ndfromtxt(mdata, usecols=(0, 4), **kwargs)\n        assert_warns(ConversionWarning, f, _ret=ret)\n        mtest = ret['mtest']\n        assert_equal(len(mtest), 45)\n        assert_equal(mtest, np.ones(45, dtype=[(_, int) for _ in 'ae']))\n        #\n        mdata.seek(0)\n        mtest = np.ndfromtxt(mdata, usecols=(0, 1), **kwargs)\n        assert_equal(len(mtest), 50)\n        control = np.ones(50, dtype=[(_, int) for _ in 'ab'])\n        control[[10 * _ for _ in range(5)]] = (2, 2)\n        assert_equal(mtest, control)\n\n    def test_inconsistent_dtype(self):\n        \"Test inconsistent dtype\"\n        data = [\"1, 1, 1, 1, -1.1\"] * 50\n        mdata = TextIO(\"\\n\".join(data))\n\n        converters = {4: lambda x: \"(%s)\" % x}\n        kwargs = dict(delimiter=\",\", converters=converters,\n                      dtype=[(_, int) for _ in 'abcde'],)\n        assert_raises(ValueError, np.genfromtxt, mdata, **kwargs)\n\n    def test_default_field_format(self):\n        \"Test default format\"\n        data = \"0, 1, 2.3\\n4, 5, 6.7\"\n        mtest = np.ndfromtxt(TextIO(data),\n                             delimiter=\",\", dtype=None, defaultfmt=\"f%02i\")\n        ctrl = np.array([(0, 1, 2.3), (4, 5, 6.7)],\n                        dtype=[(\"f00\", int), (\"f01\", int), (\"f02\", float)])\n        assert_equal(mtest, ctrl)\n\n    def test_single_dtype_wo_names(self):\n        \"Test single dtype w/o names\"\n        data = \"0, 1, 2.3\\n4, 5, 6.7\"\n        mtest = np.ndfromtxt(TextIO(data),\n                             delimiter=\",\", dtype=float, defaultfmt=\"f%02i\")\n        ctrl = np.array([[0., 1., 2.3], [4., 5., 6.7]], dtype=float)\n        assert_equal(mtest, ctrl)\n\n    def test_single_dtype_w_explicit_names(self):\n        \"Test single dtype w explicit names\"\n        data = \"0, 1, 2.3\\n4, 5, 6.7\"\n        mtest = np.ndfromtxt(TextIO(data),\n                             delimiter=\",\", dtype=float, names=\"a, b, c\")\n        ctrl = np.array([(0., 1., 2.3), (4., 5., 6.7)],\n                        dtype=[(_, float) for _ in \"abc\"])\n        assert_equal(mtest, ctrl)\n\n    def test_single_dtype_w_implicit_names(self):\n        \"Test single dtype w implicit names\"\n        data = \"a, b, c\\n0, 1, 2.3\\n4, 5, 6.7\"\n        mtest = np.ndfromtxt(TextIO(data),\n                             delimiter=\",\", dtype=float, names=True)\n        ctrl = np.array([(0., 1., 2.3), (4., 5., 6.7)],\n                        dtype=[(_, float) for _ in \"abc\"])\n        assert_equal(mtest, ctrl)\n\n    def test_easy_structured_dtype(self):\n        \"Test easy structured dtype\"\n        data = \"0, 1, 2.3\\n4, 5, 6.7\"\n        mtest = np.ndfromtxt(TextIO(data), delimiter=\",\",\n                             dtype=(int, float, float), defaultfmt=\"f_%02i\")\n        ctrl = np.array([(0, 1., 2.3), (4, 5., 6.7)],\n                        dtype=[(\"f_00\", int), (\"f_01\", float), (\"f_02\", float)])\n        assert_equal(mtest, ctrl)\n\n    def test_autostrip(self):\n        \"Test autostrip\"\n        data = \"01/01/2003  , 1.3,   abcde\"\n        kwargs = dict(delimiter=\",\", dtype=None)\n        mtest = np.ndfromtxt(TextIO(data), **kwargs)\n        ctrl = np.array([('01/01/2003  ', 1.3, '   abcde')],\n                        dtype=[('f0', '|S12'), ('f1', float), ('f2', '|S8')])\n        assert_equal(mtest, ctrl)\n        mtest = np.ndfromtxt(TextIO(data), autostrip=True, **kwargs)\n        ctrl = np.array([('01/01/2003', 1.3, 'abcde')],\n                        dtype=[('f0', '|S10'), ('f1', float), ('f2', '|S5')])\n        assert_equal(mtest, ctrl)\n\n    def test_replace_space(self):\n        \"Test the 'replace_space' option\"\n        txt = \"A.A, B (B), C:C\\n1, 2, 3.14\"\n        # Test default: replace ' ' by '_' and delete non-alphanum chars\n        test = np.genfromtxt(TextIO(txt),\n                             delimiter=\",\", names=True, dtype=None)\n        ctrl_dtype = [(\"AA\", int), (\"B_B\", int), (\"CC\", float)]\n        ctrl = np.array((1, 2, 3.14), dtype=ctrl_dtype)\n        assert_equal(test, ctrl)\n        # Test: no replace, no delete\n        test = np.genfromtxt(TextIO(txt),\n                             delimiter=\",\", names=True, dtype=None,\n                             replace_space='', deletechars='')\n        ctrl_dtype = [(\"A.A\", int), (\"B (B)\", int), (\"C:C\", float)]\n        ctrl = np.array((1, 2, 3.14), dtype=ctrl_dtype)\n        assert_equal(test, ctrl)\n        # Test: no delete (spaces are replaced by _)\n        test = np.genfromtxt(TextIO(txt),\n                             delimiter=\",\", names=True, dtype=None,\n                             deletechars='')\n        ctrl_dtype = [(\"A.A\", int), (\"B_(B)\", int), (\"C:C\", float)]\n        ctrl = np.array((1, 2, 3.14), dtype=ctrl_dtype)\n        assert_equal(test, ctrl)\n\n    def test_incomplete_names(self):\n        \"Test w/ incomplete names\"\n        data = \"A,,C\\n0,1,2\\n3,4,5\"\n        kwargs = dict(delimiter=\",\", names=True)\n        # w/ dtype=None\n        ctrl = np.array([(0, 1, 2), (3, 4, 5)],\n                        dtype=[(_, int) for _ in ('A', 'f0', 'C')])\n        test = np.ndfromtxt(TextIO(data), dtype=None, **kwargs)\n        assert_equal(test, ctrl)\n        # w/ default dtype\n        ctrl = np.array([(0, 1, 2), (3, 4, 5)],\n                        dtype=[(_, float) for _ in ('A', 'f0', 'C')])\n        test = np.ndfromtxt(TextIO(data), **kwargs)\n\n    def test_names_auto_completion(self):\n        \"Make sure that names are properly completed\"\n        data = \"1 2 3\\n 4 5 6\"\n        test = np.genfromtxt(TextIO(data),\n                             dtype=(int, float, int), names=\"a\")\n        ctrl = np.array([(1, 2, 3), (4, 5, 6)],\n                        dtype=[('a', int), ('f0', float), ('f1', int)])\n        assert_equal(test, ctrl)\n\n    def test_names_with_usecols_bug1636(self):\n        \"Make sure we pick up the right names w/ usecols\"\n        data = \"A,B,C,D,E\\n0,1,2,3,4\\n0,1,2,3,4\\n0,1,2,3,4\"\n        ctrl_names = (\"A\", \"C\", \"E\")\n        test = np.genfromtxt(TextIO(data),\n                             dtype=(int, int, int), delimiter=\",\",\n                             usecols=(0, 2, 4), names=True)\n        assert_equal(test.dtype.names, ctrl_names)\n        #\n        test = np.genfromtxt(TextIO(data),\n                             dtype=(int, int, int), delimiter=\",\",\n                             usecols=(\"A\", \"C\", \"E\"), names=True)\n        assert_equal(test.dtype.names, ctrl_names)\n        #\n        test = np.genfromtxt(TextIO(data),\n                             dtype=int, delimiter=\",\",\n                             usecols=(\"A\", \"C\", \"E\"), names=True)\n        assert_equal(test.dtype.names, ctrl_names)\n\n    def test_fixed_width_names(self):\n        \"Test fix-width w/ names\"\n        data = \"    A    B   C\\n    0    1 2.3\\n   45   67   9.\"\n        kwargs = dict(delimiter=(5, 5, 4), names=True, dtype=None)\n        ctrl = np.array([(0, 1, 2.3), (45, 67, 9.)],\n                        dtype=[('A', int), ('B', int), ('C', float)])\n        test = np.ndfromtxt(TextIO(data), **kwargs)\n        assert_equal(test, ctrl)\n        #\n        kwargs = dict(delimiter=5, names=True, dtype=None)\n        ctrl = np.array([(0, 1, 2.3), (45, 67, 9.)],\n                        dtype=[('A', int), ('B', int), ('C', float)])\n        test = np.ndfromtxt(TextIO(data), **kwargs)\n        assert_equal(test, ctrl)\n\n    def test_filling_values(self):\n        \"Test missing values\"\n        data = b\"1, 2, 3\\n1, , 5\\n0, 6, \\n\"\n        kwargs = dict(delimiter=\",\", dtype=None, filling_values=-999)\n        ctrl = np.array([[1, 2, 3], [1, -999, 5], [0, 6, -999]], dtype=int)\n        test = np.ndfromtxt(TextIO(data), **kwargs)\n        assert_equal(test, ctrl)\n\n    def test_comments_is_none(self):\n        # Github issue 329 (None was previously being converted to 'None').\n        test = np.genfromtxt(TextIO(\"test1,testNonetherestofthedata\"),\n                             dtype=None, comments=None, delimiter=',')\n        assert_equal(test[1], b'testNonetherestofthedata')\n        test = np.genfromtxt(TextIO(\"test1, testNonetherestofthedata\"),\n                             dtype=None, comments=None, delimiter=',')\n        assert_equal(test[1], b' testNonetherestofthedata')\n\n    def test_recfromtxt(self):\n        #\n        data = TextIO('A,B\\n0,1\\n2,3')\n        kwargs = dict(delimiter=\",\", missing_values=\"N/A\", names=True)\n        test = np.recfromtxt(data, **kwargs)\n        control = np.array([(0, 1), (2, 3)],\n                           dtype=[('A', np.int), ('B', np.int)])\n        self.assertTrue(isinstance(test, np.recarray))\n        assert_equal(test, control)\n        #\n        data = TextIO('A,B\\n0,1\\n2,N/A')\n        test = np.recfromtxt(data, dtype=None, usemask=True, **kwargs)\n        control = ma.array([(0, 1), (2, -1)],\n                           mask=[(False, False), (False, True)],\n                           dtype=[('A', np.int), ('B', np.int)])\n        assert_equal(test, control)\n        assert_equal(test.mask, control.mask)\n        assert_equal(test.A, [0, 2])\n\n    def test_recfromcsv(self):\n        #\n        data = TextIO('A,B\\n0,1\\n2,3')\n        kwargs = dict(missing_values=\"N/A\", names=True, case_sensitive=True)\n        test = np.recfromcsv(data, dtype=None, **kwargs)\n        control = np.array([(0, 1), (2, 3)],\n                           dtype=[('A', np.int), ('B', np.int)])\n        self.assertTrue(isinstance(test, np.recarray))\n        assert_equal(test, control)\n        #\n        data = TextIO('A,B\\n0,1\\n2,N/A')\n        test = np.recfromcsv(data, dtype=None, usemask=True, **kwargs)\n        control = ma.array([(0, 1), (2, -1)],\n                           mask=[(False, False), (False, True)],\n                           dtype=[('A', np.int), ('B', np.int)])\n        assert_equal(test, control)\n        assert_equal(test.mask, control.mask)\n        assert_equal(test.A, [0, 2])\n        #\n        data = TextIO('A,B\\n0,1\\n2,3')\n        test = np.recfromcsv(data, missing_values='N/A',)\n        control = np.array([(0, 1), (2, 3)],\n                           dtype=[('a', np.int), ('b', np.int)])\n        self.assertTrue(isinstance(test, np.recarray))\n        assert_equal(test, control)\n\n    def test_gft_using_filename(self):\n        # Test that we can load data from a filename as well as a file object\n        wanted = np.arange(6).reshape((2, 3))\n        if sys.version_info[0] >= 3:\n            # python 3k is known to fail for '\\r'\n            linesep = ('\\n', '\\r\\n')\n        else:\n            linesep = ('\\n', '\\r\\n', '\\r')\n\n        for sep in linesep:\n            data = '0 1 2' + sep + '3 4 5'\n            f, name = mkstemp()\n            # We can't use NamedTemporaryFile on windows, because we cannot\n            # reopen the file.\n            try:\n                os.write(f, asbytes(data))\n                assert_array_equal(np.genfromtxt(name), wanted)\n            finally:\n                os.close(f)\n                os.unlink(name)\n\n    def test_gft_using_generator(self):\n        # gft doesn't work with unicode.\n        def count():\n            for i in range(10):\n                yield asbytes(\"%d\" % i)\n\n        res = np.genfromtxt(count())\n        assert_array_equal(res, np.arange(10))\n\n\ndef test_gzip_load():\n    a = np.random.random((5, 5))\n\n    s = BytesIO()\n    f = gzip.GzipFile(fileobj=s, mode=\"w\")\n\n    np.save(f, a)\n    f.close()\n    s.seek(0)\n\n    f = gzip.GzipFile(fileobj=s, mode=\"r\")\n    assert_array_equal(np.load(f), a)\n\n\ndef test_gzip_loadtxt():\n    # Thanks to another windows brokeness, we can't use\n    # NamedTemporaryFile: a file created from this function cannot be\n    # reopened by another open call. So we first put the gzipped string\n    # of the test reference array, write it to a securely opened file,\n    # which is then read from by the loadtxt function\n    s = BytesIO()\n    g = gzip.GzipFile(fileobj=s, mode='w')\n    g.write(b'1 2 3\\n')\n    g.close()\n    s.seek(0)\n\n    f, name = mkstemp(suffix='.gz')\n    try:\n        os.write(f, s.read())\n        s.close()\n        assert_array_equal(np.loadtxt(name), [1, 2, 3])\n    finally:\n        os.close(f)\n        os.unlink(name)\n\n\ndef test_gzip_loadtxt_from_string():\n    s = BytesIO()\n    f = gzip.GzipFile(fileobj=s, mode=\"w\")\n    f.write(b'1 2 3\\n')\n    f.close()\n    s.seek(0)\n\n    f = gzip.GzipFile(fileobj=s, mode=\"r\")\n    assert_array_equal(np.loadtxt(f), [1, 2, 3])\n\n\ndef test_npzfile_dict():\n    s = BytesIO()\n    x = np.zeros((3, 3))\n    y = np.zeros((3, 3))\n\n    np.savez(s, x=x, y=y)\n    s.seek(0)\n\n    z = np.load(s)\n\n    assert_('x' in z)\n    assert_('y' in z)\n    assert_('x' in z.keys())\n    assert_('y' in z.keys())\n\n    for f, a in z.items():\n        assert_(f in ['x', 'y'])\n        assert_equal(a.shape, (3, 3))\n\n    assert_(len(z.items()) == 2)\n\n    for f in z:\n        assert_(f in ['x', 'y'])\n\n    assert_('x' in z.keys())\n\n\ndef test_load_refcount():\n    # Check that objects returned by np.load are directly freed based on\n    # their refcount, rather than needing the gc to collect them.\n\n    f = BytesIO()\n    np.savez(f, [1, 2, 3])\n    f.seek(0)\n\n    gc.collect()\n    n_before = len(gc.get_objects())\n    np.load(f)\n    n_after = len(gc.get_objects())\n\n    assert_equal(n_before, n_after)\n\nif __name__ == \"__main__\":\n    run_module_suite()\n"], "fixing_code": ["from __future__ import division, absolute_import, print_function\n\nimport sys\nfrom tempfile import NamedTemporaryFile, TemporaryFile\nimport os\n\nfrom numpy import memmap\nfrom numpy import arange, allclose, asarray\nfrom numpy.testing import *\n\nclass TestMemmap(TestCase):\n    def setUp(self):\n        self.tmpfp = NamedTemporaryFile(prefix='mmap')\n        self.shape = (3, 4)\n        self.dtype = 'float32'\n        self.data = arange(12, dtype=self.dtype)\n        self.data.resize(self.shape)\n\n    def tearDown(self):\n        self.tmpfp.close()\n\n    def test_roundtrip(self):\n        # Write data to file\n        fp = memmap(self.tmpfp, dtype=self.dtype, mode='w+',\n                    shape=self.shape)\n        fp[:] = self.data[:]\n        del fp # Test __del__ machinery, which handles cleanup\n\n        # Read data back from file\n        newfp = memmap(self.tmpfp, dtype=self.dtype, mode='r',\n                       shape=self.shape)\n        assert_(allclose(self.data, newfp))\n        assert_array_equal(self.data, newfp)\n\n    def test_open_with_filename(self):\n        with NamedTemporaryFile() as tmp:\n            fp = memmap(tmp.name, dtype=self.dtype, mode='w+',\n                        shape=self.shape)\n            fp[:] = self.data[:]\n            del fp\n\n    def test_unnamed_file(self):\n        with TemporaryFile() as f:\n            fp = memmap(f, dtype=self.dtype, shape=self.shape)\n            del fp\n\n    def test_attributes(self):\n        offset = 1\n        mode = \"w+\"\n        fp = memmap(self.tmpfp, dtype=self.dtype, mode=mode,\n                    shape=self.shape, offset=offset)\n        self.assertEqual(offset, fp.offset)\n        self.assertEqual(mode, fp.mode)\n        del fp\n\n    def test_filename(self):\n        with NamedTemporaryFile() as tmp:\n            fp = memmap(tmp.name, dtype=self.dtype, mode='w+',\n                        shape=self.shape)\n            abspath = os.path.abspath(tmp.name)\n            fp[:] = self.data[:]\n            self.assertEqual(abspath, fp.filename)\n            b = fp[:1]\n            self.assertEqual(abspath, b.filename)\n            del b\n            del fp\n\n    def test_filename_fileobj(self):\n        fp = memmap(self.tmpfp, dtype=self.dtype, mode=\"w+\",\n                    shape=self.shape)\n        self.assertEqual(fp.filename, self.tmpfp.name)\n\n    @dec.knownfailureif(sys.platform=='gnu0', \"This test is known to fail on hurd\")\n    def test_flush(self):\n        fp = memmap(self.tmpfp, dtype=self.dtype, mode='w+',\n                    shape=self.shape)\n        fp[:] = self.data[:]\n        assert_equal(fp[0], self.data[0])\n        fp.flush()\n\n    def test_del(self):\n        # Make sure a view does not delete the underlying mmap\n        fp_base = memmap(self.tmpfp, dtype=self.dtype, mode='w+',\n                    shape=self.shape)\n        fp_base[0] = 5\n        fp_view = fp_base[0:1]\n        assert_equal(fp_view[0], 5)\n        del fp_view\n        # Should still be able to access and assign values after\n        # deleting the view\n        assert_equal(fp_base[0], 5)\n        fp_base[0] = 6\n        assert_equal(fp_base[0], 6)\n\n    def test_arithmetic_drops_references(self):\n        fp = memmap(self.tmpfp, dtype=self.dtype, mode='w+',\n                    shape=self.shape)\n        tmp = (fp + 10)\n        if isinstance(tmp, memmap):\n            assert tmp._mmap is not fp._mmap\n\n    def test_indexing_drops_references(self):\n        fp = memmap(self.tmpfp, dtype=self.dtype, mode='w+',\n                    shape=self.shape)\n        tmp = fp[[(1, 2), (2, 3)]]\n        if isinstance(tmp, memmap):\n            assert tmp._mmap is not fp._mmap\n\n    def test_slicing_keeps_references(self):\n        fp = memmap(self.tmpfp, dtype=self.dtype, mode='w+',\n                    shape=self.shape)\n        assert fp[:2, :2]._mmap is fp._mmap\n\n    def test_view(self):\n        fp = memmap(self.tmpfp, dtype=self.dtype, shape=self.shape)\n        new1 = fp.view()\n        new2 = new1.view()\n        assert(new1.base is fp)\n        assert(new2.base is fp)\n        new_array = asarray(fp)\n        assert(new_array.base is fp)\n\nif __name__ == \"__main__\":\n    run_module_suite()\n", "from __future__ import division, absolute_import, print_function\n\nimport tempfile\nimport sys\nimport os\nimport warnings\nimport operator\nimport io\nif sys.version_info[0] >= 3:\n    import builtins\nelse:\n    import __builtin__ as builtins\n\nimport numpy as np\nfrom nose import SkipTest\nfrom numpy.core import *\nfrom numpy.compat import asbytes, getexception, strchar, sixu\nfrom test_print import in_foreign_locale\nfrom numpy.core.multiarray_tests import (\n        test_neighborhood_iterator, test_neighborhood_iterator_oob,\n        test_pydatamem_seteventhook_start, test_pydatamem_seteventhook_end,\n        test_inplace_increment, get_buffer_info\n        )\nfrom numpy.testing import (\n        TestCase, run_module_suite, assert_, assert_raises,\n        assert_equal, assert_almost_equal, assert_array_equal,\n        assert_array_almost_equal, assert_allclose,\n        assert_array_less, runstring, dec\n        )\n\n# Need to test an object that does not fully implement math interface\nfrom datetime import timedelta\n\n\nif sys.version_info[:2] > (3, 2):\n    # In Python 3.3 the representation of empty shape, strides and suboffsets\n    # is an empty tuple instead of None.\n    # http://docs.python.org/dev/whatsnew/3.3.html#api-changes\n    EMPTY = ()\nelse:\n    EMPTY = None\n\n\nclass TestFlags(TestCase):\n    def setUp(self):\n        self.a = arange(10)\n\n    def test_writeable(self):\n        mydict = locals()\n        self.a.flags.writeable = False\n        self.assertRaises(ValueError, runstring, 'self.a[0] = 3', mydict)\n        self.assertRaises(ValueError, runstring, 'self.a[0:1].itemset(3)', mydict)\n        self.a.flags.writeable = True\n        self.a[0] = 5\n        self.a[0] = 0\n\n    def test_otherflags(self):\n        assert_equal(self.a.flags.carray, True)\n        assert_equal(self.a.flags.farray, False)\n        assert_equal(self.a.flags.behaved, True)\n        assert_equal(self.a.flags.fnc, False)\n        assert_equal(self.a.flags.forc, True)\n        assert_equal(self.a.flags.owndata, True)\n        assert_equal(self.a.flags.writeable, True)\n        assert_equal(self.a.flags.aligned, True)\n        assert_equal(self.a.flags.updateifcopy, False)\n\nclass TestHash(TestCase):\n    # see #3793\n    def test_int(self):\n        for st, ut, s in [(np.int8, np.uint8, 8),\n                          (np.int16, np.uint16, 16),\n                          (np.int32, np.uint32, 32),\n                          (np.int64, np.uint64, 64)]:\n            for i in range(1, s):\n                assert_equal(hash(st(-2**i)), hash(-2**i),\n                             err_msg=\"%r: -2**%d\" % (st, i))\n                assert_equal(hash(st(2**(i - 1))), hash(2**(i - 1)),\n                             err_msg=\"%r: 2**%d\" % (st, i - 1))\n                assert_equal(hash(st(2**i - 1)), hash(2**i - 1),\n                             err_msg=\"%r: 2**%d - 1\" % (st, i))\n\n                i = max(i - 1, 1)\n                assert_equal(hash(ut(2**(i - 1))), hash(2**(i - 1)),\n                             err_msg=\"%r: 2**%d\" % (ut, i - 1))\n                assert_equal(hash(ut(2**i - 1)), hash(2**i - 1),\n                             err_msg=\"%r: 2**%d - 1\" % (ut, i))\n\nclass TestAttributes(TestCase):\n    def setUp(self):\n        self.one = arange(10)\n        self.two = arange(20).reshape(4, 5)\n        self.three = arange(60, dtype=float64).reshape(2, 5, 6)\n\n    def test_attributes(self):\n        assert_equal(self.one.shape, (10,))\n        assert_equal(self.two.shape, (4, 5))\n        assert_equal(self.three.shape, (2, 5, 6))\n        self.three.shape = (10, 3, 2)\n        assert_equal(self.three.shape, (10, 3, 2))\n        self.three.shape = (2, 5, 6)\n        assert_equal(self.one.strides, (self.one.itemsize,))\n        num = self.two.itemsize\n        assert_equal(self.two.strides, (5*num, num))\n        num = self.three.itemsize\n        assert_equal(self.three.strides, (30*num, 6*num, num))\n        assert_equal(self.one.ndim, 1)\n        assert_equal(self.two.ndim, 2)\n        assert_equal(self.three.ndim, 3)\n        num = self.two.itemsize\n        assert_equal(self.two.size, 20)\n        assert_equal(self.two.nbytes, 20*num)\n        assert_equal(self.two.itemsize, self.two.dtype.itemsize)\n        assert_equal(self.two.base, arange(20))\n\n    def test_dtypeattr(self):\n        assert_equal(self.one.dtype, dtype(int_))\n        assert_equal(self.three.dtype, dtype(float_))\n        assert_equal(self.one.dtype.char, 'l')\n        assert_equal(self.three.dtype.char, 'd')\n        self.assertTrue(self.three.dtype.str[0] in '<>')\n        assert_equal(self.one.dtype.str[1], 'i')\n        assert_equal(self.three.dtype.str[1], 'f')\n\n    def test_int_subclassing(self):\n        # Regression test for https://github.com/numpy/numpy/pull/3526\n\n        numpy_int = np.int_(0)\n\n        if sys.version_info[0] >= 3:\n            # On Py3k int_ should not inherit from int, because it's not fixed-width anymore\n            assert_equal(isinstance(numpy_int, int), False)\n        else:\n            # Otherwise, it should inherit from int...\n            assert_equal(isinstance(numpy_int, int), True)\n\n            # ... and fast-path checks on C-API level should also work\n            from numpy.core.multiarray_tests import test_int_subclass\n            assert_equal(test_int_subclass(numpy_int), True)\n\n    def test_stridesattr(self):\n        x = self.one\n        def make_array(size, offset, strides):\n            return ndarray(size, buffer=x, dtype=int,\n                           offset=offset*x.itemsize,\n                           strides=strides*x.itemsize)\n        assert_equal(make_array(4, 4, -1), array([4, 3, 2, 1]))\n        self.assertRaises(ValueError, make_array, 4, 4, -2)\n        self.assertRaises(ValueError, make_array, 4, 2, -1)\n        self.assertRaises(ValueError, make_array, 8, 3, 1)\n        assert_equal(make_array(8, 3, 0), np.array([3]*8))\n        # Check behavior reported in gh-2503:\n        self.assertRaises(ValueError, make_array, (2, 3), 5, array([-2, -3]))\n        make_array(0, 0, 10)\n\n    def test_set_stridesattr(self):\n        x = self.one\n        def make_array(size, offset, strides):\n            try:\n                r = ndarray([size], dtype=int, buffer=x, offset=offset*x.itemsize)\n            except:\n                raise RuntimeError(getexception())\n            r.strides = strides=strides*x.itemsize\n            return r\n        assert_equal(make_array(4, 4, -1), array([4, 3, 2, 1]))\n        assert_equal(make_array(7, 3, 1), array([3, 4, 5, 6, 7, 8, 9]))\n        self.assertRaises(ValueError, make_array, 4, 4, -2)\n        self.assertRaises(ValueError, make_array, 4, 2, -1)\n        self.assertRaises(RuntimeError, make_array, 8, 3, 1)\n        # Check that the true extent of the array is used.\n        # Test relies on as_strided base not exposing a buffer.\n        x = np.lib.stride_tricks.as_strided(arange(1), (10, 10), (0, 0))\n        def set_strides(arr, strides):\n            arr.strides = strides\n        self.assertRaises(ValueError, set_strides, x, (10*x.itemsize, x.itemsize))\n\n        # Test for offset calculations:\n        x = np.lib.stride_tricks.as_strided(np.arange(10, dtype=np.int8)[-1],\n                                                    shape=(10,), strides=(-1,))\n        self.assertRaises(ValueError, set_strides, x[::-1], -1)\n        a = x[::-1]\n        a.strides = 1\n        a[::2].strides = 2\n\n    def test_fill(self):\n        for t in \"?bhilqpBHILQPfdgFDGO\":\n            x = empty((3, 2, 1), t)\n            y = empty((3, 2, 1), t)\n            x.fill(1)\n            y[...] = 1\n            assert_equal(x, y)\n\n    def test_fill_struct_array(self):\n        # Filling from a scalar\n        x = array([(0, 0.0), (1, 1.0)], dtype='i4,f8')\n        x.fill(x[0])\n        assert_equal(x['f1'][1], x['f1'][0])\n        # Filling from a tuple that can be converted\n        # to a scalar\n        x = np.zeros(2, dtype=[('a', 'f8'), ('b', 'i4')])\n        x.fill((3.5, -2))\n        assert_array_equal(x['a'], [3.5, 3.5])\n        assert_array_equal(x['b'], [-2, -2])\n\n\nclass TestArrayConstruction(TestCase):\n    def test_array(self):\n        d = np.ones(6)\n        r = np.array([d, d])\n        assert_equal(r, np.ones((2, 6)))\n\n        d = np.ones(6)\n        tgt = np.ones((2, 6))\n        r = np.array([d, d])\n        assert_equal(r, tgt)\n        tgt[1] = 2\n        r = np.array([d, d + 1])\n        assert_equal(r, tgt)\n\n        d = np.ones(6)\n        r = np.array([[d, d]])\n        assert_equal(r, np.ones((1, 2, 6)))\n\n        d = np.ones(6)\n        r = np.array([[d, d], [d, d]])\n        assert_equal(r, np.ones((2, 2, 6)))\n\n        d = np.ones((6, 6))\n        r = np.array([d, d])\n        assert_equal(r, np.ones((2, 6, 6)))\n\n        d = np.ones((6, ))\n        r = np.array([[d, d + 1], d + 2])\n        assert_equal(len(r), 2)\n        assert_equal(r[0], [d, d + 1])\n        assert_equal(r[1], d + 2)\n\n        tgt = np.ones((2, 3), dtype=np.bool)\n        tgt[0, 2] = False\n        tgt[1, 0:2] = False\n        r = np.array([[True, True, False], [False, False, True]])\n        assert_equal(r, tgt)\n        r = np.array([[True, False], [True, False], [False, True]])\n        assert_equal(r, tgt.T)\n\n\nclass TestAssignment(TestCase):\n    def test_assignment_broadcasting(self):\n        a = np.arange(6).reshape(2, 3)\n\n        # Broadcasting the input to the output\n        a[...] = np.arange(3)\n        assert_equal(a, [[0, 1, 2], [0, 1, 2]])\n        a[...] = np.arange(2).reshape(2, 1)\n        assert_equal(a, [[0, 0, 0], [1, 1, 1]])\n\n        # For compatibility with <= 1.5, a limited version of broadcasting\n        # the output to the input.\n        #\n        # This behavior is inconsistent with NumPy broadcasting\n        # in general, because it only uses one of the two broadcasting\n        # rules (adding a new \"1\" dimension to the left of the shape),\n        # applied to the output instead of an input. In NumPy 2.0, this kind\n        # of broadcasting assignment will likely be disallowed.\n        a[...] = np.arange(6)[::-1].reshape(1, 2, 3)\n        assert_equal(a, [[5, 4, 3], [2, 1, 0]])\n        # The other type of broadcasting would require a reduction operation.\n        def assign(a, b):\n            a[...] = b\n        assert_raises(ValueError, assign, a, np.arange(12).reshape(2, 2, 3))\n\n    def test_assignment_errors(self):\n        # Address issue #2276\n        class C:\n            pass\n        a = np.zeros(1)\n        def assign(v):\n            a[0] = v\n        assert_raises((AttributeError, TypeError), assign, C())\n        assert_raises(ValueError, assign, [1])\n\nclass TestDtypedescr(TestCase):\n    def test_construction(self):\n        d1 = dtype('i4')\n        assert_equal(d1, dtype(int32))\n        d2 = dtype('f8')\n        assert_equal(d2, dtype(float64))\n\nclass TestZeroRank(TestCase):\n    def setUp(self):\n        self.d = array(0), array('x', object)\n\n    def test_ellipsis_subscript(self):\n        a, b = self.d\n        self.assertEqual(a[...], 0)\n        self.assertEqual(b[...], 'x')\n        self.assertTrue(a[...] is a)\n        self.assertTrue(b[...] is b)\n\n    def test_empty_subscript(self):\n        a, b = self.d\n        self.assertEqual(a[()], 0)\n        self.assertEqual(b[()], 'x')\n        self.assertTrue(type(a[()]) is a.dtype.type)\n        self.assertTrue(type(b[()]) is str)\n\n    def test_invalid_subscript(self):\n        a, b = self.d\n        self.assertRaises(IndexError, lambda x: x[0], a)\n        self.assertRaises(IndexError, lambda x: x[0], b)\n        self.assertRaises(IndexError, lambda x: x[array([], int)], a)\n        self.assertRaises(IndexError, lambda x: x[array([], int)], b)\n\n    def test_ellipsis_subscript_assignment(self):\n        a, b = self.d\n        a[...] = 42\n        self.assertEqual(a, 42)\n        b[...] = ''\n        self.assertEqual(b.item(), '')\n\n    def test_empty_subscript_assignment(self):\n        a, b = self.d\n        a[()] = 42\n        self.assertEqual(a, 42)\n        b[()] = ''\n        self.assertEqual(b.item(), '')\n\n    def test_invalid_subscript_assignment(self):\n        a, b = self.d\n        def assign(x, i, v):\n            x[i] = v\n        self.assertRaises(IndexError, assign, a, 0, 42)\n        self.assertRaises(IndexError, assign, b, 0, '')\n        self.assertRaises(ValueError, assign, a, (), '')\n\n    def test_newaxis(self):\n        a, b = self.d\n        self.assertEqual(a[newaxis].shape, (1,))\n        self.assertEqual(a[..., newaxis].shape, (1,))\n        self.assertEqual(a[newaxis, ...].shape, (1,))\n        self.assertEqual(a[..., newaxis].shape, (1,))\n        self.assertEqual(a[newaxis, ..., newaxis].shape, (1, 1))\n        self.assertEqual(a[..., newaxis, newaxis].shape, (1, 1))\n        self.assertEqual(a[newaxis, newaxis, ...].shape, (1, 1))\n        self.assertEqual(a[(newaxis,)*10].shape, (1,)*10)\n\n    def test_invalid_newaxis(self):\n        a, b = self.d\n        def subscript(x, i): x[i]\n        self.assertRaises(IndexError, subscript, a, (newaxis, 0))\n        self.assertRaises(IndexError, subscript, a, (newaxis,)*50)\n\n    def test_constructor(self):\n        x = ndarray(())\n        x[()] = 5\n        self.assertEqual(x[()], 5)\n        y = ndarray((), buffer=x)\n        y[()] = 6\n        self.assertEqual(x[()], 6)\n\n    def test_output(self):\n        x = array(2)\n        self.assertRaises(ValueError, add, x, [1], x)\n\n\nclass TestScalarIndexing(TestCase):\n    def setUp(self):\n        self.d = array([0, 1])[0]\n\n    def test_ellipsis_subscript(self):\n        a = self.d\n        self.assertEqual(a[...], 0)\n        self.assertEqual(a[...].shape, ())\n\n    def test_empty_subscript(self):\n        a = self.d\n        self.assertEqual(a[()], 0)\n        self.assertEqual(a[()].shape, ())\n\n    def test_invalid_subscript(self):\n        a = self.d\n        self.assertRaises(IndexError, lambda x: x[0], a)\n        self.assertRaises(IndexError, lambda x: x[array([], int)], a)\n\n    def test_invalid_subscript_assignment(self):\n        a = self.d\n        def assign(x, i, v):\n            x[i] = v\n        self.assertRaises(TypeError, assign, a, 0, 42)\n\n    def test_newaxis(self):\n        a = self.d\n        self.assertEqual(a[newaxis].shape, (1,))\n        self.assertEqual(a[..., newaxis].shape, (1,))\n        self.assertEqual(a[newaxis, ...].shape, (1,))\n        self.assertEqual(a[..., newaxis].shape, (1,))\n        self.assertEqual(a[newaxis, ..., newaxis].shape, (1, 1))\n        self.assertEqual(a[..., newaxis, newaxis].shape, (1, 1))\n        self.assertEqual(a[newaxis, newaxis, ...].shape, (1, 1))\n        self.assertEqual(a[(newaxis,)*10].shape, (1,)*10)\n\n    def test_invalid_newaxis(self):\n        a = self.d\n        def subscript(x, i): x[i]\n        self.assertRaises(IndexError, subscript, a, (newaxis, 0))\n        self.assertRaises(IndexError, subscript, a, (newaxis,)*50)\n\n    def test_overlapping_assignment(self):\n        # With positive strides\n        a = np.arange(4)\n        a[:-1] = a[1:]\n        assert_equal(a, [1, 2, 3, 3])\n\n        a = np.arange(4)\n        a[1:] = a[:-1]\n        assert_equal(a, [0, 0, 1, 2])\n\n        # With positive and negative strides\n        a = np.arange(4)\n        a[:] = a[::-1]\n        assert_equal(a, [3, 2, 1, 0])\n\n        a = np.arange(6).reshape(2, 3)\n        a[::-1,:] = a[:, ::-1]\n        assert_equal(a, [[5, 4, 3], [2, 1, 0]])\n\n        a = np.arange(6).reshape(2, 3)\n        a[::-1, ::-1] = a[:, ::-1]\n        assert_equal(a, [[3, 4, 5], [0, 1, 2]])\n\n        # With just one element overlapping\n        a = np.arange(5)\n        a[:3] = a[2:]\n        assert_equal(a, [2, 3, 4, 3, 4])\n\n        a = np.arange(5)\n        a[2:] = a[:3]\n        assert_equal(a, [0, 1, 0, 1, 2])\n\n        a = np.arange(5)\n        a[2::-1] = a[2:]\n        assert_equal(a, [4, 3, 2, 3, 4])\n\n        a = np.arange(5)\n        a[2:] = a[2::-1]\n        assert_equal(a, [0, 1, 2, 1, 0])\n\n        a = np.arange(5)\n        a[2::-1] = a[:1:-1]\n        assert_equal(a, [2, 3, 4, 3, 4])\n\n        a = np.arange(5)\n        a[:1:-1] = a[2::-1]\n        assert_equal(a, [0, 1, 0, 1, 2])\n\nclass TestCreation(TestCase):\n    def test_from_attribute(self):\n        class x(object):\n            def __array__(self, dtype=None):\n                pass\n        self.assertRaises(ValueError, array, x())\n\n    def test_from_string(self) :\n        types = np.typecodes['AllInteger'] + np.typecodes['Float']\n        nstr = ['123', '123']\n        result = array([123, 123], dtype=int)\n        for type in types :\n            msg = 'String conversion for %s' % type\n            assert_equal(array(nstr, dtype=type), result, err_msg=msg)\n\n    def test_void(self):\n        arr = np.array([], dtype='V')\n        assert_equal(arr.dtype.kind, 'V')\n\n    def test_zeros(self):\n        types = np.typecodes['AllInteger'] + np.typecodes['AllFloat']\n        for dt in types:\n            d = np.zeros((13,), dtype=dt)\n            assert_equal(np.count_nonzero(d), 0)\n            # true for ieee floats\n            assert_equal(d.sum(), 0)\n            assert_(not d.any())\n\n            d = np.zeros(2, dtype='(2,4)i4')\n            assert_equal(np.count_nonzero(d), 0)\n            assert_equal(d.sum(), 0)\n            assert_(not d.any())\n\n            d = np.zeros(2, dtype='4i4')\n            assert_equal(np.count_nonzero(d), 0)\n            assert_equal(d.sum(), 0)\n            assert_(not d.any())\n\n            d = np.zeros(2, dtype='(2,4)i4, (2,4)i4')\n            assert_equal(np.count_nonzero(d), 0)\n\n    @dec.slow\n    def test_zeros_big(self):\n        # test big array as they might be allocated different by the sytem\n        types = np.typecodes['AllInteger'] + np.typecodes['AllFloat']\n        for dt in types:\n            d = np.zeros((30 * 1024**2,), dtype=dt)\n            assert_(not d.any())\n\n    def test_zeros_obj(self):\n        # test initialization from PyLong(0)\n        d = np.zeros((13,), dtype=object)\n        assert_array_equal(d, [0] * 13)\n        assert_equal(np.count_nonzero(d), 0)\n\n    def test_non_sequence_sequence(self):\n        \"\"\"Should not segfault.\n\n        Class Fail breaks the sequence protocol for new style classes, i.e.,\n        those derived from object. Class Map is a mapping type indicated by\n        raising a ValueError. At some point we may raise a warning instead\n        of an error in the Fail case.\n\n        \"\"\"\n        class Fail(object):\n            def __len__(self):\n                return 1\n\n            def __getitem__(self, index):\n                raise ValueError()\n\n        class Map(object):\n            def __len__(self):\n                return 1\n\n            def __getitem__(self, index):\n                raise KeyError()\n\n        a = np.array([Map()])\n        assert_(a.shape == (1,))\n        assert_(a.dtype == np.dtype(object))\n        assert_raises(ValueError, np.array, [Fail()])\n\n\nclass TestStructured(TestCase):\n    def test_subarray_field_access(self):\n        a = np.zeros((3, 5), dtype=[('a', ('i4', (2, 2)))])\n        a['a'] = np.arange(60).reshape(3, 5, 2, 2)\n\n        # Since the subarray is always in C-order, these aren't equal\n        assert_(np.any(a['a'].T != a.T['a']))\n\n        # In Fortran order, the subarray gets appended\n        # like in all other cases, not prepended as a special case\n        b = a.copy(order='F')\n        assert_equal(a['a'].shape, b['a'].shape)\n        assert_equal(a.T['a'].shape, a.T.copy()['a'].shape)\n\n    def test_subarray_comparison(self):\n        # Check that comparisons between record arrays with\n        # multi-dimensional field types work properly\n        a = np.rec.fromrecords(\n            [([1, 2, 3], 'a', [[1, 2], [3, 4]]), ([3, 3, 3], 'b', [[0, 0], [0, 0]])],\n            dtype=[('a', ('f4', 3)), ('b', np.object), ('c', ('i4', (2, 2)))])\n        b = a.copy()\n        assert_equal(a==b, [True, True])\n        assert_equal(a!=b, [False, False])\n        b[1].b = 'c'\n        assert_equal(a==b, [True, False])\n        assert_equal(a!=b, [False, True])\n        for i in range(3):\n            b[0].a = a[0].a\n            b[0].a[i] = 5\n            assert_equal(a==b, [False, False])\n            assert_equal(a!=b, [True, True])\n        for i in range(2):\n            for j in range(2):\n                b = a.copy()\n                b[0].c[i, j] = 10\n                assert_equal(a==b, [False, True])\n                assert_equal(a!=b, [True, False])\n\n        # Check that broadcasting with a subarray works\n        a = np.array([[(0,)], [(1,)]], dtype=[('a', 'f8')])\n        b = np.array([(0,), (0,), (1,)], dtype=[('a', 'f8')])\n        assert_equal(a==b, [[True, True, False], [False, False, True]])\n        assert_equal(b==a, [[True, True, False], [False, False, True]])\n        a = np.array([[(0,)], [(1,)]], dtype=[('a', 'f8', (1,))])\n        b = np.array([(0,), (0,), (1,)], dtype=[('a', 'f8', (1,))])\n        assert_equal(a==b, [[True, True, False], [False, False, True]])\n        assert_equal(b==a, [[True, True, False], [False, False, True]])\n        a = np.array([[([0, 0],)], [([1, 1],)]], dtype=[('a', 'f8', (2,))])\n        b = np.array([([0, 0],), ([0, 1],), ([1, 1],)], dtype=[('a', 'f8', (2,))])\n        assert_equal(a==b, [[True, False, False], [False, False, True]])\n        assert_equal(b==a, [[True, False, False], [False, False, True]])\n\n        # Check that broadcasting Fortran-style arrays with a subarray work\n        a = np.array([[([0, 0],)], [([1, 1],)]], dtype=[('a', 'f8', (2,))], order='F')\n        b = np.array([([0, 0],), ([0, 1],), ([1, 1],)], dtype=[('a', 'f8', (2,))])\n        assert_equal(a==b, [[True, False, False], [False, False, True]])\n        assert_equal(b==a, [[True, False, False], [False, False, True]])\n\n        # Check that incompatible sub-array shapes don't result to broadcasting\n        x = np.zeros((1,), dtype=[('a', ('f4', (1, 2))), ('b', 'i1')])\n        y = np.zeros((1,), dtype=[('a', ('f4', (2,))), ('b', 'i1')])\n        assert_equal(x == y, False)\n\n        x = np.zeros((1,), dtype=[('a', ('f4', (2, 1))), ('b', 'i1')])\n        y = np.zeros((1,), dtype=[('a', ('f4', (2,))), ('b', 'i1')])\n        assert_equal(x == y, False)\n\n\nclass TestBool(TestCase):\n    def test_test_interning(self):\n        a0 = bool_(0)\n        b0 = bool_(False)\n        self.assertTrue(a0 is b0)\n        a1 = bool_(1)\n        b1 = bool_(True)\n        self.assertTrue(a1 is b1)\n        self.assertTrue(array([True])[0] is a1)\n        self.assertTrue(array(True)[()] is a1)\n\n    def test_sum(self):\n        d = np.ones(101, dtype=np.bool);\n        assert_equal(d.sum(), d.size)\n        assert_equal(d[::2].sum(), d[::2].size)\n        assert_equal(d[::-2].sum(), d[::-2].size)\n\n        d = np.frombuffer(b'\\xff\\xff' * 100, dtype=bool)\n        assert_equal(d.sum(), d.size)\n        assert_equal(d[::2].sum(), d[::2].size)\n        assert_equal(d[::-2].sum(), d[::-2].size)\n\n    def check_count_nonzero(self, power, length):\n        powers = [2 ** i for i in range(length)]\n        for i in range(2**power):\n            l = [(i & x) != 0 for x in powers]\n            a = np.array(l, dtype=np.bool)\n            c = builtins.sum(l)\n            self.assertEqual(np.count_nonzero(a), c)\n            av = a.view(np.uint8)\n            av *= 3\n            self.assertEqual(np.count_nonzero(a), c)\n            av *= 4\n            self.assertEqual(np.count_nonzero(a), c)\n            av[av != 0] = 0xFF\n            self.assertEqual(np.count_nonzero(a), c)\n\n    def test_count_nonzero(self):\n        # check all 12 bit combinations in a length 17 array\n        # covers most cases of the 16 byte unrolled code\n        self.check_count_nonzero(12, 17)\n\n    @dec.slow\n    def test_count_nonzero_all(self):\n        # check all combinations in a length 17 array\n        # covers all cases of the 16 byte unrolled code\n        self.check_count_nonzero(17, 17)\n\n    def test_count_nonzero_unaligned(self):\n        # prevent mistakes as e.g. gh-4060\n        for o in range(7):\n            a = np.zeros((18,), dtype=np.bool)[o+1:]\n            a[:o] = True\n            self.assertEqual(np.count_nonzero(a), builtins.sum(a.tolist()))\n            a = np.ones((18,), dtype=np.bool)[o+1:]\n            a[:o] = False\n            self.assertEqual(np.count_nonzero(a), builtins.sum(a.tolist()))\n\nclass TestMethods(TestCase):\n    def test_test_round(self):\n        assert_equal(array([1.2, 1.5]).round(), [1, 2])\n        assert_equal(array(1.5).round(), 2)\n        assert_equal(array([12.2, 15.5]).round(-1), [10, 20])\n        assert_equal(array([12.15, 15.51]).round(1), [12.2, 15.5])\n\n    def test_transpose(self):\n        a = array([[1, 2], [3, 4]])\n        assert_equal(a.transpose(), [[1, 3], [2, 4]])\n        self.assertRaises(ValueError, lambda: a.transpose(0))\n        self.assertRaises(ValueError, lambda: a.transpose(0, 0))\n        self.assertRaises(ValueError, lambda: a.transpose(0, 1, 2))\n\n    def test_sort(self):\n        # test ordering for floats and complex containing nans. It is only\n        # necessary to check the lessthan comparison, so sorts that\n        # only follow the insertion sort path are sufficient. We only\n        # test doubles and complex doubles as the logic is the same.\n\n        # check doubles\n        msg = \"Test real sort order with nans\"\n        a = np.array([np.nan, 1, 0])\n        b = sort(a)\n        assert_equal(b, a[::-1], msg)\n        # check complex\n        msg = \"Test complex sort order with nans\"\n        a = np.zeros(9, dtype=np.complex128)\n        a.real += [np.nan, np.nan, np.nan, 1, 0, 1, 1, 0, 0]\n        a.imag += [np.nan, 1, 0, np.nan, np.nan, 1, 0, 1, 0]\n        b = sort(a)\n        assert_equal(b, a[::-1], msg)\n\n        # all c scalar sorts use the same code with different types\n        # so it suffices to run a quick check with one type. The number\n        # of sorted items must be greater than ~50 to check the actual\n        # algorithm because quick and merge sort fall over to insertion\n        # sort for small arrays.\n        a = np.arange(101)\n        b = a[::-1].copy()\n        for kind in ['q', 'm', 'h'] :\n            msg = \"scalar sort, kind=%s\" % kind\n            c = a.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n            c = b.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n\n        # test complex sorts. These use the same code as the scalars\n        # but the compare fuction differs.\n        ai = a*1j + 1\n        bi = b*1j + 1\n        for kind in ['q', 'm', 'h'] :\n            msg = \"complex sort, real part == 1, kind=%s\" % kind\n            c = ai.copy();\n            c.sort(kind=kind)\n            assert_equal(c, ai, msg)\n            c = bi.copy();\n            c.sort(kind=kind)\n            assert_equal(c, ai, msg)\n        ai = a + 1j\n        bi = b + 1j\n        for kind in ['q', 'm', 'h'] :\n            msg = \"complex sort, imag part == 1, kind=%s\" % kind\n            c = ai.copy();\n            c.sort(kind=kind)\n            assert_equal(c, ai, msg)\n            c = bi.copy();\n            c.sort(kind=kind)\n            assert_equal(c, ai, msg)\n\n        # test string sorts.\n        s = 'aaaaaaaa'\n        a = np.array([s + chr(i) for i in range(101)])\n        b = a[::-1].copy()\n        for kind in ['q', 'm', 'h'] :\n            msg = \"string sort, kind=%s\" % kind\n            c = a.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n            c = b.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n\n        # test unicode sorts.\n        s = 'aaaaaaaa'\n        a = np.array([s + chr(i) for i in range(101)], dtype=np.unicode)\n        b = a[::-1].copy()\n        for kind in ['q', 'm', 'h'] :\n            msg = \"unicode sort, kind=%s\" % kind\n            c = a.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n            c = b.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n\n        # test object array sorts.\n        a = np.empty((101,), dtype=np.object)\n        a[:] = list(range(101))\n        b = a[::-1]\n        for kind in ['q', 'h', 'm'] :\n            msg = \"object sort, kind=%s\" % kind\n            c = a.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n            c = b.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n\n        # test record array sorts.\n        dt = np.dtype([('f', float), ('i', int)])\n        a = array([(i, i) for i in range(101)], dtype = dt)\n        b = a[::-1]\n        for kind in ['q', 'h', 'm'] :\n            msg = \"object sort, kind=%s\" % kind\n            c = a.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n            c = b.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n\n        # test datetime64 sorts.\n        a = np.arange(0, 101, dtype='datetime64[D]')\n        b = a[::-1]\n        for kind in ['q', 'h', 'm'] :\n            msg = \"datetime64 sort, kind=%s\" % kind\n            c = a.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n            c = b.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n\n        # test timedelta64 sorts.\n        a = np.arange(0, 101, dtype='timedelta64[D]')\n        b = a[::-1]\n        for kind in ['q', 'h', 'm'] :\n            msg = \"timedelta64 sort, kind=%s\" % kind\n            c = a.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n            c = b.copy();\n            c.sort(kind=kind)\n            assert_equal(c, a, msg)\n\n        # check axis handling. This should be the same for all type\n        # specific sorts, so we only check it for one type and one kind\n        a = np.array([[3, 2], [1, 0]])\n        b = np.array([[1, 0], [3, 2]])\n        c = np.array([[2, 3], [0, 1]])\n        d = a.copy()\n        d.sort(axis=0)\n        assert_equal(d, b, \"test sort with axis=0\")\n        d = a.copy()\n        d.sort(axis=1)\n        assert_equal(d, c, \"test sort with axis=1\")\n        d = a.copy()\n        d.sort()\n        assert_equal(d, c, \"test sort with default axis\")\n\n    def test_copy(self):\n        def assert_fortran(arr):\n            assert_(arr.flags.fortran)\n            assert_(arr.flags.f_contiguous)\n            assert_(not arr.flags.c_contiguous)\n\n        def assert_c(arr):\n            assert_(not arr.flags.fortran)\n            assert_(not arr.flags.f_contiguous)\n            assert_(arr.flags.c_contiguous)\n\n        a = np.empty((2, 2), order='F')\n        # Test copying a Fortran array\n        assert_c(a.copy())\n        assert_c(a.copy('C'))\n        assert_fortran(a.copy('F'))\n        assert_fortran(a.copy('A'))\n\n        # Now test starting with a C array.\n        a = np.empty((2, 2), order='C')\n        assert_c(a.copy())\n        assert_c(a.copy('C'))\n        assert_fortran(a.copy('F'))\n        assert_c(a.copy('A'))\n\n    def test_sort_order(self):\n        # Test sorting an array with fields\n        x1=np.array([21, 32, 14])\n        x2=np.array(['my', 'first', 'name'])\n        x3=np.array([3.1, 4.5, 6.2])\n        r=np.rec.fromarrays([x1, x2, x3], names='id,word,number')\n\n        r.sort(order=['id'])\n        assert_equal(r.id, array([14, 21, 32]))\n        assert_equal(r.word, array(['name', 'my', 'first']))\n        assert_equal(r.number, array([6.2, 3.1, 4.5]))\n\n        r.sort(order=['word'])\n        assert_equal(r.id, array([32, 21, 14]))\n        assert_equal(r.word, array(['first', 'my', 'name']))\n        assert_equal(r.number, array([4.5, 3.1, 6.2]))\n\n        r.sort(order=['number'])\n        assert_equal(r.id, array([21, 32, 14]))\n        assert_equal(r.word, array(['my', 'first', 'name']))\n        assert_equal(r.number, array([3.1, 4.5, 6.2]))\n\n        if sys.byteorder == 'little':\n            strtype = '>i2'\n        else:\n            strtype = '<i2'\n        mydtype = [('name', strchar + '5'), ('col2', strtype)]\n        r = np.array([('a', 1), ('b', 255), ('c', 3), ('d', 258)],\n                     dtype= mydtype)\n        r.sort(order='col2')\n        assert_equal(r['col2'], [1, 3, 255, 258])\n        assert_equal(r, np.array([('a', 1), ('c', 3), ('b', 255), ('d', 258)],\n                                 dtype=mydtype))\n\n    def test_argsort(self):\n        # all c scalar argsorts use the same code with different types\n        # so it suffices to run a quick check with one type. The number\n        # of sorted items must be greater than ~50 to check the actual\n        # algorithm because quick and merge sort fall over to insertion\n        # sort for small arrays.\n        a = np.arange(101)\n        b = a[::-1].copy()\n        for kind in ['q', 'm', 'h'] :\n            msg = \"scalar argsort, kind=%s\" % kind\n            assert_equal(a.copy().argsort(kind=kind), a, msg)\n            assert_equal(b.copy().argsort(kind=kind), b, msg)\n\n        # test complex argsorts. These use the same code as the scalars\n        # but the compare fuction differs.\n        ai = a*1j + 1\n        bi = b*1j + 1\n        for kind in ['q', 'm', 'h'] :\n            msg = \"complex argsort, kind=%s\" % kind\n            assert_equal(ai.copy().argsort(kind=kind), a, msg)\n            assert_equal(bi.copy().argsort(kind=kind), b, msg)\n        ai = a + 1j\n        bi = b + 1j\n        for kind in ['q', 'm', 'h'] :\n            msg = \"complex argsort, kind=%s\" % kind\n            assert_equal(ai.copy().argsort(kind=kind), a, msg)\n            assert_equal(bi.copy().argsort(kind=kind), b, msg)\n\n        # test string argsorts.\n        s = 'aaaaaaaa'\n        a = np.array([s + chr(i) for i in range(101)])\n        b = a[::-1].copy()\n        r = np.arange(101)\n        rr = r[::-1]\n        for kind in ['q', 'm', 'h'] :\n            msg = \"string argsort, kind=%s\" % kind\n            assert_equal(a.copy().argsort(kind=kind), r, msg)\n            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n\n        # test unicode argsorts.\n        s = 'aaaaaaaa'\n        a = np.array([s + chr(i) for i in range(101)], dtype=np.unicode)\n        b = a[::-1]\n        r = np.arange(101)\n        rr = r[::-1]\n        for kind in ['q', 'm', 'h'] :\n            msg = \"unicode argsort, kind=%s\" % kind\n            assert_equal(a.copy().argsort(kind=kind), r, msg)\n            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n\n        # test object array argsorts.\n        a = np.empty((101,), dtype=np.object)\n        a[:] = list(range(101))\n        b = a[::-1]\n        r = np.arange(101)\n        rr = r[::-1]\n        for kind in ['q', 'm', 'h'] :\n            msg = \"object argsort, kind=%s\" % kind\n            assert_equal(a.copy().argsort(kind=kind), r, msg)\n            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n\n        # test structured array argsorts.\n        dt = np.dtype([('f', float), ('i', int)])\n        a = array([(i, i) for i in range(101)], dtype = dt)\n        b = a[::-1]\n        r = np.arange(101)\n        rr = r[::-1]\n        for kind in ['q', 'm', 'h'] :\n            msg = \"structured array argsort, kind=%s\" % kind\n            assert_equal(a.copy().argsort(kind=kind), r, msg)\n            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n\n        # test datetime64 argsorts.\n        a = np.arange(0, 101, dtype='datetime64[D]')\n        b = a[::-1]\n        r = np.arange(101)\n        rr = r[::-1]\n        for kind in ['q', 'h', 'm'] :\n            msg = \"datetime64 argsort, kind=%s\" % kind\n            assert_equal(a.copy().argsort(kind=kind), r, msg)\n            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n\n        # test timedelta64 argsorts.\n        a = np.arange(0, 101, dtype='timedelta64[D]')\n        b = a[::-1]\n        r = np.arange(101)\n        rr = r[::-1]\n        for kind in ['q', 'h', 'm'] :\n            msg = \"timedelta64 argsort, kind=%s\" % kind\n            assert_equal(a.copy().argsort(kind=kind), r, msg)\n            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n\n\n        # check axis handling. This should be the same for all type\n        # specific argsorts, so we only check it for one type and one kind\n        a = np.array([[3, 2], [1, 0]])\n        b = np.array([[1, 1], [0, 0]])\n        c = np.array([[1, 0], [1, 0]])\n        assert_equal(a.copy().argsort(axis=0), b)\n        assert_equal(a.copy().argsort(axis=1), c)\n        assert_equal(a.copy().argsort(), c)\n        # using None is known fail at this point\n        #assert_equal(a.copy().argsort(axis=None, c)\n\n        # check that stable argsorts are stable\n        r = np.arange(100)\n        # scalars\n        a = np.zeros(100)\n        assert_equal(a.argsort(kind='m'), r)\n        # complex\n        a = np.zeros(100, dtype=np.complex)\n        assert_equal(a.argsort(kind='m'), r)\n        # string\n        a = np.array(['aaaaaaaaa' for i in range(100)])\n        assert_equal(a.argsort(kind='m'), r)\n        # unicode\n        a = np.array(['aaaaaaaaa' for i in range(100)], dtype=np.unicode)\n        assert_equal(a.argsort(kind='m'), r)\n\n    def test_searchsorted(self):\n        # test for floats and complex containing nans. The logic is the\n        # same for all float types so only test double types for now.\n        # The search sorted routines use the compare functions for the\n        # array type, so this checks if that is consistent with the sort\n        # order.\n\n        # check double\n        a = np.array([0, 1, np.nan])\n        msg = \"Test real searchsorted with nans, side='l'\"\n        b = a.searchsorted(a, side='l')\n        assert_equal(b, np.arange(3), msg)\n        msg = \"Test real searchsorted with nans, side='r'\"\n        b = a.searchsorted(a, side='r')\n        assert_equal(b, np.arange(1, 4), msg)\n        # check double complex\n        a = np.zeros(9, dtype=np.complex128)\n        a.real += [0, 0, 1, 1, 0, 1, np.nan, np.nan, np.nan]\n        a.imag += [0, 1, 0, 1, np.nan, np.nan, 0, 1, np.nan]\n        msg = \"Test complex searchsorted with nans, side='l'\"\n        b = a.searchsorted(a, side='l')\n        assert_equal(b, np.arange(9), msg)\n        msg = \"Test complex searchsorted with nans, side='r'\"\n        b = a.searchsorted(a, side='r')\n        assert_equal(b, np.arange(1, 10), msg)\n        msg = \"Test searchsorted with little endian, side='l'\"\n        a = np.array([0, 128], dtype='<i4')\n        b = a.searchsorted(np.array(128, dtype='<i4'))\n        assert_equal(b, 1, msg)\n        msg = \"Test searchsorted with big endian, side='l'\"\n        a = np.array([0, 128], dtype='>i4')\n        b = a.searchsorted(np.array(128, dtype='>i4'))\n        assert_equal(b, 1, msg)\n\n        # Check 0 elements\n        a = np.ones(0)\n        b = a.searchsorted([0, 1, 2], 'l')\n        assert_equal(b, [0, 0, 0])\n        b = a.searchsorted([0, 1, 2], 'r')\n        assert_equal(b, [0, 0, 0])\n        a = np.ones(1)\n        # Check 1 element\n        b = a.searchsorted([0, 1, 2], 'l')\n        assert_equal(b, [0, 0, 1])\n        b = a.searchsorted([0, 1, 2], 'r')\n        assert_equal(b, [0, 1, 1])\n        # Check all elements equal\n        a = np.ones(2)\n        b = a.searchsorted([0, 1, 2], 'l')\n        assert_equal(b, [0, 0, 2])\n        b = a.searchsorted([0, 1, 2], 'r')\n        assert_equal(b, [0, 2, 2])\n\n        # Test searching unaligned array\n        a = np.arange(10)\n        aligned = np.empty(a.itemsize * a.size + 1, 'uint8')\n        unaligned = aligned[1:].view(a.dtype)\n        unaligned[:] = a\n        # Test searching unaligned array\n        b = unaligned.searchsorted(a, 'l')\n        assert_equal(b, a)\n        b = unaligned.searchsorted(a, 'r')\n        assert_equal(b, a + 1)\n        # Test searching for unaligned keys\n        b = a.searchsorted(unaligned, 'l')\n        assert_equal(b, a)\n        b = a.searchsorted(unaligned, 'r')\n        assert_equal(b, a + 1)\n\n    def test_searchsorted_unicode(self):\n        # Test searchsorted on unicode strings.\n\n        # 1.6.1 contained a string length miscalculation in\n        # arraytypes.c.src:UNICODE_compare() which manifested as\n        # incorrect/inconsistent results from searchsorted.\n        a = np.array(['P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100185_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100186_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100187_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100189_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100190_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100191_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100192_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100193_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100194_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100195_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100196_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100197_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100198_1',\n                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100199_1'],\n                      dtype=np.unicode)\n        ind = np.arange(len(a))\n        assert_equal([a.searchsorted(v, 'left') for v in a], ind)\n        assert_equal([a.searchsorted(v, 'right') for v in a], ind + 1)\n        assert_equal([a.searchsorted(a[i], 'left') for i in ind], ind)\n        assert_equal([a.searchsorted(a[i], 'right') for i in ind], ind + 1)\n\n    def test_searchsorted_with_sorter(self):\n        a = np.array([5, 2, 1, 3, 4])\n        s = np.argsort(a)\n        assert_raises(TypeError, np.searchsorted, a, 0, sorter=(1, (2, 3)))\n        assert_raises(TypeError, np.searchsorted, a, 0, sorter=[1.1])\n        assert_raises(ValueError, np.searchsorted, a, 0, sorter=[1, 2, 3, 4])\n        assert_raises(ValueError, np.searchsorted, a, 0, sorter=[1, 2, 3, 4, 5, 6])\n\n        # bounds check\n        assert_raises(ValueError, np.searchsorted, a, 4, sorter=[0, 1, 2, 3, 5])\n        assert_raises(ValueError, np.searchsorted, a, 0, sorter=[-1, 0, 1, 2, 3])\n        assert_raises(ValueError, np.searchsorted, a, 0, sorter=[4, 0, -1, 2, 3])\n\n        a = np.random.rand(300)\n        s = a.argsort()\n        b = np.sort(a)\n        k = np.linspace(0, 1, 20)\n        assert_equal(b.searchsorted(k), a.searchsorted(k, sorter=s))\n\n        a = np.array([0, 1, 2, 3, 5]*20)\n        s = a.argsort()\n        k = [0, 1, 2, 3, 5]\n        expected = [0, 20, 40, 60, 80]\n        assert_equal(a.searchsorted(k, side='l', sorter=s), expected)\n        expected = [20, 40, 60, 80, 100]\n        assert_equal(a.searchsorted(k, side='r', sorter=s), expected)\n\n        # Test searching unaligned array\n        keys = np.arange(10)\n        a = keys.copy()\n        np.random.shuffle(s)\n        s = a.argsort()\n        aligned = np.empty(a.itemsize * a.size + 1, 'uint8')\n        unaligned = aligned[1:].view(a.dtype)\n        # Test searching unaligned array\n        unaligned[:] = a\n        b = unaligned.searchsorted(keys, 'l', s)\n        assert_equal(b, keys)\n        b = unaligned.searchsorted(keys, 'r', s)\n        assert_equal(b, keys + 1)\n        # Test searching for unaligned keys\n        unaligned[:] = keys\n        b = a.searchsorted(unaligned, 'l', s)\n        assert_equal(b, keys)\n        b = a.searchsorted(unaligned, 'r', s)\n        assert_equal(b, keys + 1)\n\n\n    def test_partition(self):\n        d = np.arange(10)\n        assert_raises(TypeError, np.partition, d, 2, kind=1)\n        assert_raises(ValueError, np.partition, d, 2, kind=\"nonsense\")\n        assert_raises(ValueError, np.argpartition, d, 2, kind=\"nonsense\")\n        assert_raises(ValueError, d.partition, 2, axis=0, kind=\"nonsense\")\n        assert_raises(ValueError, d.argpartition, 2, axis=0, kind=\"nonsense\")\n        for k in (\"introselect\",):\n            d = np.array([])\n            assert_array_equal(np.partition(d, 0, kind=k), d)\n            assert_array_equal(np.argpartition(d, 0, kind=k), d)\n            d = np.ones((1))\n            assert_array_equal(np.partition(d, 0, kind=k)[0], d)\n            assert_array_equal(d[np.argpartition(d, 0, kind=k)],\n                               np.partition(d, 0, kind=k))\n\n            # kth not modified\n            kth = np.array([30, 15, 5])\n            okth = kth.copy()\n            np.partition(np.arange(40), kth)\n            assert_array_equal(kth, okth)\n\n            for r in ([2, 1], [1, 2], [1, 1]):\n                d = np.array(r)\n                tgt = np.sort(d)\n                assert_array_equal(np.partition(d, 0, kind=k)[0], tgt[0])\n                assert_array_equal(np.partition(d, 1, kind=k)[1], tgt[1])\n                assert_array_equal(d[np.argpartition(d, 0, kind=k)],\n                                   np.partition(d, 0, kind=k))\n                assert_array_equal(d[np.argpartition(d, 1, kind=k)],\n                                   np.partition(d, 1, kind=k))\n                for i in range(d.size):\n                    d[i:].partition(0, kind=k)\n                assert_array_equal(d, tgt)\n\n            for r in ([3, 2, 1], [1, 2, 3], [2, 1, 3], [2, 3, 1],\n                      [1, 1, 1], [1, 2, 2], [2, 2, 1], [1, 2, 1]):\n                d = np.array(r)\n                tgt = np.sort(d)\n                assert_array_equal(np.partition(d, 0, kind=k)[0], tgt[0])\n                assert_array_equal(np.partition(d, 1, kind=k)[1], tgt[1])\n                assert_array_equal(np.partition(d, 2, kind=k)[2], tgt[2])\n                assert_array_equal(d[np.argpartition(d, 0, kind=k)],\n                                   np.partition(d, 0, kind=k))\n                assert_array_equal(d[np.argpartition(d, 1, kind=k)],\n                                   np.partition(d, 1, kind=k))\n                assert_array_equal(d[np.argpartition(d, 2, kind=k)],\n                                   np.partition(d, 2, kind=k))\n                for i in range(d.size):\n                    d[i:].partition(0, kind=k)\n                assert_array_equal(d, tgt)\n\n            d = np.ones((50))\n            assert_array_equal(np.partition(d, 0, kind=k), d)\n            assert_array_equal(d[np.argpartition(d, 0, kind=k)],\n                               np.partition(d, 0, kind=k))\n\n            # sorted\n            d = np.arange((49))\n            self.assertEqual(np.partition(d, 5, kind=k)[5], 5)\n            self.assertEqual(np.partition(d, 15, kind=k)[15], 15)\n            assert_array_equal(d[np.argpartition(d, 5, kind=k)],\n                               np.partition(d, 5, kind=k))\n            assert_array_equal(d[np.argpartition(d, 15, kind=k)],\n                               np.partition(d, 15, kind=k))\n\n            # rsorted\n            d = np.arange((47))[::-1]\n            self.assertEqual(np.partition(d, 6, kind=k)[6], 6)\n            self.assertEqual(np.partition(d, 16, kind=k)[16], 16)\n            assert_array_equal(d[np.argpartition(d, 6, kind=k)],\n                               np.partition(d, 6, kind=k))\n            assert_array_equal(d[np.argpartition(d, 16, kind=k)],\n                               np.partition(d, 16, kind=k))\n\n            assert_array_equal(np.partition(d, -6, kind=k),\n                               np.partition(d, 41, kind=k))\n            assert_array_equal(np.partition(d, -16, kind=k),\n                               np.partition(d, 31, kind=k))\n            assert_array_equal(d[np.argpartition(d, -6, kind=k)],\n                               np.partition(d, 41, kind=k))\n\n            # median of 3 killer, O(n^2) on pure median 3 pivot quickselect\n            # exercises the median of median of 5 code used to keep O(n)\n            d = np.arange(1000000)\n            x = np.roll(d, d.size // 2)\n            mid = x.size // 2 + 1\n            assert_equal(np.partition(x, mid)[mid], mid)\n            d = np.arange(1000001)\n            x = np.roll(d, d.size // 2 + 1)\n            mid = x.size // 2 + 1\n            assert_equal(np.partition(x, mid)[mid], mid)\n\n            # equal elements\n            d = np.arange((47)) % 7\n            tgt = np.sort(np.arange((47)) % 7)\n            np.random.shuffle(d)\n            for i in range(d.size):\n                self.assertEqual(np.partition(d, i, kind=k)[i], tgt[i])\n            assert_array_equal(d[np.argpartition(d, 6, kind=k)],\n                               np.partition(d, 6, kind=k))\n            assert_array_equal(d[np.argpartition(d, 16, kind=k)],\n                               np.partition(d, 16, kind=k))\n            for i in range(d.size):\n                d[i:].partition(0, kind=k)\n            assert_array_equal(d, tgt)\n\n            d = np.array([2, 1])\n            d.partition(0, kind=k)\n            assert_raises(ValueError, d.partition, 2)\n            assert_raises(ValueError, d.partition, 3, axis=1)\n            assert_raises(ValueError, np.partition, d, 2)\n            assert_raises(ValueError, np.partition, d, 2, axis=1)\n            assert_raises(ValueError, d.argpartition, 2)\n            assert_raises(ValueError, d.argpartition, 3, axis=1)\n            assert_raises(ValueError, np.argpartition, d, 2)\n            assert_raises(ValueError, np.argpartition, d, 2, axis=1)\n            d = np.arange(10).reshape((2, 5))\n            d.partition(1, axis=0, kind=k)\n            d.partition(4, axis=1, kind=k)\n            np.partition(d, 1, axis=0, kind=k)\n            np.partition(d, 4, axis=1, kind=k)\n            np.partition(d, 1, axis=None, kind=k)\n            np.partition(d, 9, axis=None, kind=k)\n            d.argpartition(1, axis=0, kind=k)\n            d.argpartition(4, axis=1, kind=k)\n            np.argpartition(d, 1, axis=0, kind=k)\n            np.argpartition(d, 4, axis=1, kind=k)\n            np.argpartition(d, 1, axis=None, kind=k)\n            np.argpartition(d, 9, axis=None, kind=k)\n            assert_raises(ValueError, d.partition, 2, axis=0)\n            assert_raises(ValueError, d.partition, 11, axis=1)\n            assert_raises(TypeError, d.partition, 2, axis=None)\n            assert_raises(ValueError, np.partition, d, 9, axis=1)\n            assert_raises(ValueError, np.partition, d, 11, axis=None)\n            assert_raises(ValueError, d.argpartition, 2, axis=0)\n            assert_raises(ValueError, d.argpartition, 11, axis=1)\n            assert_raises(ValueError, np.argpartition, d, 9, axis=1)\n            assert_raises(ValueError, np.argpartition, d, 11, axis=None)\n\n            td = [(dt, s) for dt in [np.int32, np.float32, np.complex64]\n                          for s in (9, 16)]\n            for dt, s in td:\n                aae = assert_array_equal\n                at = self.assertTrue\n\n                d = np.arange(s, dtype=dt)\n                np.random.shuffle(d)\n                d1 = np.tile(np.arange(s, dtype=dt), (4, 1))\n                map(np.random.shuffle, d1)\n                d0 = np.transpose(d1)\n                for i in range(d.size):\n                    p = np.partition(d, i, kind=k)\n                    self.assertEqual(p[i], i)\n                    # all before are smaller\n                    assert_array_less(p[:i], p[i])\n                    # all after are larger\n                    assert_array_less(p[i], p[i + 1:])\n                    aae(p, d[np.argpartition(d, i, kind=k)])\n\n                    p = np.partition(d1, i, axis=1, kind=k)\n                    aae(p[:, i], np.array([i] * d1.shape[0], dtype=dt))\n                    # array_less does not seem to work right\n                    at((p[:, :i].T <= p[:, i]).all(),\n                       msg=\"%d: %r <= %r\" % (i, p[:, i], p[:, :i].T))\n                    at((p[:, i + 1:].T > p[:, i]).all(),\n                       msg=\"%d: %r < %r\" % (i, p[:, i], p[:, i + 1:].T))\n                    aae(p, d1[np.arange(d1.shape[0])[:, None],\n                        np.argpartition(d1, i, axis=1, kind=k)])\n\n                    p = np.partition(d0, i, axis=0, kind=k)\n                    aae(p[i,:], np.array([i] * d1.shape[0],\n                                                         dtype=dt))\n                    # array_less does not seem to work right\n                    at((p[:i,:] <= p[i,:]).all(),\n                       msg=\"%d: %r <= %r\" % (i, p[i,:], p[:i,:]))\n                    at((p[i + 1:,:] > p[i,:]).all(),\n                       msg=\"%d: %r < %r\" % (i, p[i,:], p[:, i + 1:]))\n                    aae(p, d0[np.argpartition(d0, i, axis=0, kind=k),\n                        np.arange(d0.shape[1])[None,:]])\n\n                    # check inplace\n                    dc = d.copy()\n                    dc.partition(i, kind=k)\n                    assert_equal(dc, np.partition(d, i, kind=k))\n                    dc = d0.copy()\n                    dc.partition(i, axis=0, kind=k)\n                    assert_equal(dc, np.partition(d0, i, axis=0, kind=k))\n                    dc = d1.copy()\n                    dc.partition(i, axis=1, kind=k)\n                    assert_equal(dc, np.partition(d1, i, axis=1, kind=k))\n\n\n    def assert_partitioned(self, d, kth):\n        prev = 0\n        for k in np.sort(kth):\n            assert_array_less(d[prev:k], d[k], err_msg='kth %d' % k)\n            assert_((d[k:] >= d[k]).all(),\n                    msg=\"kth %d, %r not greater equal %d\" % (k, d[k:], d[k]))\n            prev = k + 1\n\n\n    def test_partition_iterative(self):\n            d = np.arange(17)\n            kth = (0, 1, 2, 429, 231)\n            assert_raises(ValueError, d.partition, kth)\n            assert_raises(ValueError, d.argpartition, kth)\n            d = np.arange(10).reshape((2, 5))\n            assert_raises(ValueError, d.partition, kth, axis=0)\n            assert_raises(ValueError, d.partition, kth, axis=1)\n            assert_raises(ValueError, np.partition, d, kth, axis=1)\n            assert_raises(ValueError, np.partition, d, kth, axis=None)\n\n            d = np.array([3, 4, 2, 1])\n            p = np.partition(d, (0, 3))\n            self.assert_partitioned(p, (0, 3))\n            self.assert_partitioned(d[np.argpartition(d, (0, 3))], (0, 3))\n\n            assert_array_equal(p, np.partition(d, (-3, -1)))\n            assert_array_equal(p, d[np.argpartition(d, (-3, -1))])\n\n            d = np.arange(17)\n            np.random.shuffle(d)\n            d.partition(range(d.size))\n            assert_array_equal(np.arange(17), d)\n            np.random.shuffle(d)\n            assert_array_equal(np.arange(17), d[d.argpartition(range(d.size))])\n\n            # test unsorted kth\n            d = np.arange(17)\n            np.random.shuffle(d)\n            keys = np.array([1, 3, 8, -2])\n            np.random.shuffle(d)\n            p = np.partition(d, keys)\n            self.assert_partitioned(p, keys)\n            p = d[np.argpartition(d, keys)]\n            self.assert_partitioned(p, keys)\n            np.random.shuffle(keys)\n            assert_array_equal(np.partition(d, keys), p)\n            assert_array_equal(d[np.argpartition(d, keys)], p)\n\n            # equal kth\n            d = np.arange(20)[::-1]\n            self.assert_partitioned(np.partition(d, [5]*4), [5])\n            self.assert_partitioned(np.partition(d, [5]*4 + [6, 13]),\n                                    [5]*4 + [6, 13])\n            self.assert_partitioned(d[np.argpartition(d, [5]*4)], [5])\n            self.assert_partitioned(d[np.argpartition(d, [5]*4 + [6, 13])],\n                                    [5]*4 + [6, 13])\n\n            d = np.arange(12)\n            np.random.shuffle(d)\n            d1 = np.tile(np.arange(12), (4, 1))\n            map(np.random.shuffle, d1)\n            d0 = np.transpose(d1)\n\n            kth = (1, 6, 7, -1)\n            p = np.partition(d1, kth, axis=1)\n            pa = d1[np.arange(d1.shape[0])[:, None],\n                    d1.argpartition(kth, axis=1)]\n            assert_array_equal(p, pa)\n            for i in range(d1.shape[0]):\n                self.assert_partitioned(p[i,:], kth)\n            p = np.partition(d0, kth, axis=0)\n            pa = d0[np.argpartition(d0, kth, axis=0),\n                    np.arange(d0.shape[1])[None,:]]\n            assert_array_equal(p, pa)\n            for i in range(d0.shape[1]):\n                self.assert_partitioned(p[:, i], kth)\n\n\n    def test_partition_cdtype(self):\n        d = array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),\n                   ('Lancelot', 1.9, 38)],\n                  dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])\n\n        tgt = np.sort(d, order=['age', 'height'])\n        assert_array_equal(np.partition(d, range(d.size),\n                                        order=['age', 'height']),\n                           tgt)\n        assert_array_equal(d[np.argpartition(d, range(d.size),\n                                             order=['age', 'height'])],\n                           tgt)\n        for k in range(d.size):\n            assert_equal(np.partition(d, k, order=['age', 'height'])[k],\n                        tgt[k])\n            assert_equal(d[np.argpartition(d, k, order=['age', 'height'])][k],\n                         tgt[k])\n\n        d = array(['Galahad', 'Arthur', 'zebra', 'Lancelot'])\n        tgt = np.sort(d)\n        assert_array_equal(np.partition(d, range(d.size)), tgt)\n        for k in range(d.size):\n            assert_equal(np.partition(d, k)[k], tgt[k])\n            assert_equal(d[np.argpartition(d, k)][k], tgt[k])\n\n\n    def test_flatten(self):\n        x0 = np.array([[1, 2, 3], [4, 5, 6]], np.int32)\n        x1 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]], np.int32)\n        y0 = np.array([1, 2, 3, 4, 5, 6], np.int32)\n        y0f = np.array([1, 4, 2, 5, 3, 6], np.int32)\n        y1 = np.array([1, 2, 3, 4, 5, 6, 7, 8], np.int32)\n        y1f = np.array([1, 5, 3, 7, 2, 6, 4, 8], np.int32)\n        assert_equal(x0.flatten(), y0)\n        assert_equal(x0.flatten('F'), y0f)\n        assert_equal(x0.flatten('F'), x0.T.flatten())\n        assert_equal(x1.flatten(), y1)\n        assert_equal(x1.flatten('F'), y1f)\n        assert_equal(x1.flatten('F'), x1.T.flatten())\n\n    def test_dot(self):\n        a = np.array([[1, 0], [0, 1]])\n        b = np.array([[0, 1], [1, 0]])\n        c = np.array([[9, 1], [1, -9]])\n\n        assert_equal(np.dot(a, b), a.dot(b))\n        assert_equal(np.dot(np.dot(a, b), c), a.dot(b).dot(c))\n\n        # test passing in an output array\n        c = np.zeros_like(a)\n        a.dot(b, c)\n        assert_equal(c, np.dot(a, b))\n\n        # test keyword args\n        c = np.zeros_like(a)\n        a.dot(b=b, out=c)\n        assert_equal(c, np.dot(a, b))\n\n    def test_dot_override(self):\n        class A(object):\n            def __numpy_ufunc__(self, ufunc, method, pos, inputs, **kwargs):\n                return \"A\"\n\n        class B(object):\n            def __numpy_ufunc__(self, ufunc, method, pos, inputs, **kwargs):\n                return NotImplemented\n\n        a = A()\n        b = B()\n        c = np.array([[1]])\n\n        assert_equal(np.dot(a, b), \"A\")\n        assert_equal(c.dot(a), \"A\")\n        assert_raises(TypeError, np.dot, b, c)\n        assert_raises(TypeError, c.dot, b)\n\n    def test_diagonal(self):\n        a = np.arange(12).reshape((3, 4))\n        assert_equal(a.diagonal(), [0, 5, 10])\n        assert_equal(a.diagonal(0), [0, 5, 10])\n        assert_equal(a.diagonal(1), [1, 6, 11])\n        assert_equal(a.diagonal(-1), [4, 9])\n\n        b = np.arange(8).reshape((2, 2, 2))\n        assert_equal(b.diagonal(), [[0, 6], [1, 7]])\n        assert_equal(b.diagonal(0), [[0, 6], [1, 7]])\n        assert_equal(b.diagonal(1), [[2], [3]])\n        assert_equal(b.diagonal(-1), [[4], [5]])\n        assert_raises(ValueError, b.diagonal, axis1=0, axis2=0)\n        assert_equal(b.diagonal(0, 1, 2), [[0, 3], [4, 7]])\n        assert_equal(b.diagonal(0, 0, 1), [[0, 6], [1, 7]])\n        assert_equal(b.diagonal(offset=1, axis1=0, axis2=2), [[1], [3]])\n        # Order of axis argument doesn't matter:\n        assert_equal(b.diagonal(0, 2, 1), [[0, 3], [4, 7]])\n\n    def test_diagonal_view_notwriteable(self):\n        # this test is only for 1.9, the diagonal view will be\n        # writeable in 1.10.\n        a = np.eye(3).diagonal()\n        assert_(not a.flags.writeable)\n        assert_(not a.flags.owndata)\n\n        a = np.diagonal(np.eye(3))\n        assert_(not a.flags.writeable)\n        assert_(not a.flags.owndata)\n\n        a = np.diag(np.eye(3))\n        assert_(not a.flags.writeable)\n        assert_(not a.flags.owndata)\n\n    def test_diagonal_memleak(self):\n        # Regression test for a bug that crept in at one point\n        a = np.zeros((100, 100))\n        assert_(sys.getrefcount(a) < 50)\n        for i in range(100):\n            a.diagonal()\n        assert_(sys.getrefcount(a) < 50)\n\n    def test_ravel(self):\n        a = np.array([[0, 1], [2, 3]])\n        assert_equal(a.ravel(), [0, 1, 2, 3])\n        assert_(not a.ravel().flags.owndata)\n        assert_equal(a.ravel('F'), [0, 2, 1, 3])\n        assert_equal(a.ravel(order='C'), [0, 1, 2, 3])\n        assert_equal(a.ravel(order='F'), [0, 2, 1, 3])\n        assert_equal(a.ravel(order='A'), [0, 1, 2, 3])\n        assert_(not a.ravel(order='A').flags.owndata)\n        assert_equal(a.ravel(order='K'), [0, 1, 2, 3])\n        assert_(not a.ravel(order='K').flags.owndata)\n        assert_equal(a.ravel(), a.reshape(-1))\n\n        a = np.array([[0, 1], [2, 3]], order='F')\n        assert_equal(a.ravel(), [0, 1, 2, 3])\n        assert_equal(a.ravel(order='A'), [0, 2, 1, 3])\n        assert_equal(a.ravel(order='K'), [0, 2, 1, 3])\n        assert_(not a.ravel(order='A').flags.owndata)\n        assert_(not a.ravel(order='K').flags.owndata)\n        assert_equal(a.ravel(), a.reshape(-1))\n        assert_equal(a.ravel(order='A'), a.reshape(-1, order='A'))\n\n        a = np.array([[0, 1], [2, 3]])[::-1,:]\n        assert_equal(a.ravel(), [2, 3, 0, 1])\n        assert_equal(a.ravel(order='C'), [2, 3, 0, 1])\n        assert_equal(a.ravel(order='F'), [2, 0, 3, 1])\n        assert_equal(a.ravel(order='A'), [2, 3, 0, 1])\n        # 'K' doesn't reverse the axes of negative strides\n        assert_equal(a.ravel(order='K'), [2, 3, 0, 1])\n        assert_(a.ravel(order='K').flags.owndata)\n\n\nclass TestBinop(object):\n    def test_ufunc_override_rop_precedence(self):\n        # Check that __rmul__ and other right-hand operations have\n        # precedence over __numpy_ufunc__\n\n        ops = {\n            '__add__':      ('__radd__', np.add, True),\n            '__sub__':      ('__rsub__', np.subtract, True),\n            '__mul__':      ('__rmul__', np.multiply, True),\n            '__truediv__':  ('__rtruediv__', np.true_divide, True),\n            '__floordiv__': ('__rfloordiv__', np.floor_divide, True),\n            '__mod__':      ('__rmod__', np.remainder, True),\n            '__divmod__':   ('__rdivmod__', None, False),\n            '__pow__':      ('__rpow__', np.power, True),\n            '__lshift__':   ('__rlshift__', np.left_shift, True),\n            '__rshift__':   ('__rrshift__', np.right_shift, True),\n            '__and__':      ('__rand__', np.bitwise_and, True),\n            '__xor__':      ('__rxor__', np.bitwise_xor, True),\n            '__or__':       ('__ror__', np.bitwise_or, True),\n            '__ge__':       ('__le__', np.less_equal, False),\n            '__gt__':       ('__lt__', np.less, False),\n            '__le__':       ('__ge__', np.greater_equal, False),\n            '__lt__':       ('__gt__', np.greater, False),\n            '__eq__':       ('__eq__', np.equal, False),\n            '__ne__':       ('__ne__', np.not_equal, False),\n        }\n\n        class OtherNdarraySubclass(ndarray):\n            pass\n\n        class OtherNdarraySubclassWithOverride(ndarray):\n            def __numpy_ufunc__(self, *a, **kw):\n                raise AssertionError((\"__numpy_ufunc__ %r %r shouldn't have \"\n                                      \"been called!\") % (a, kw))\n\n        def check(op_name, ndsubclass):\n            rop_name, np_op, has_iop = ops[op_name]\n\n            if has_iop:\n                iop_name = '__i' + op_name[2:]\n                iop = getattr(operator, iop_name)\n\n            if op_name == \"__divmod__\":\n                op = divmod\n            else:\n                op = getattr(operator, op_name)\n\n            # Dummy class\n            def __init__(self, *a, **kw):\n                pass\n\n            def __numpy_ufunc__(self, *a, **kw):\n                raise AssertionError((\"__numpy_ufunc__ %r %r shouldn't have \"\n                                      \"been called!\") % (a, kw))\n\n            def __op__(self, *other):\n                return \"op\"\n\n            def __rop__(self, *other):\n                return \"rop\"\n\n            if ndsubclass:\n                bases = (ndarray,)\n            else:\n                bases = (object,)\n\n            dct = {'__init__': __init__,\n                   '__numpy_ufunc__': __numpy_ufunc__,\n                   op_name: __op__}\n            if op_name != rop_name:\n                dct[rop_name] = __rop__\n\n            cls = type(\"Rop\" + rop_name, bases, dct)\n\n            # Check behavior against both bare ndarray objects and a\n            # ndarray subclasses with and without their own override\n            obj = cls((1,), buffer=np.ones(1,))\n\n            arr_objs = [np.array([1]),\n                        np.array([2]).view(OtherNdarraySubclass),\n                        np.array([3]).view(OtherNdarraySubclassWithOverride),\n                        ]\n\n            for arr in arr_objs:\n                err_msg = \"%r %r\" % (op_name, arr,)\n\n                # Check that ndarray op gives up if it sees a non-subclass\n                if not isinstance(obj, arr.__class__):\n                    assert_equal(getattr(arr, op_name)(obj),\n                                 NotImplemented, err_msg=err_msg)\n\n                # Check that the Python binops have priority\n                assert_equal(op(obj, arr), \"op\", err_msg=err_msg)\n                if op_name == rop_name:\n                    assert_equal(op(arr, obj), \"op\", err_msg=err_msg)\n                else:\n                    assert_equal(op(arr, obj), \"rop\", err_msg=err_msg)\n\n                # Check that Python binops have priority also for in-place ops\n                if has_iop:\n                    assert_equal(getattr(arr, iop_name)(obj),\n                                 NotImplemented, err_msg=err_msg)\n                    if op_name != \"__pow__\":\n                        # inplace pow requires the other object to be\n                        # integer-like?\n                        assert_equal(iop(arr, obj), \"rop\", err_msg=err_msg)\n\n                # Check that ufunc call __numpy_ufunc__ normally\n                if np_op is not None:\n                    assert_raises(AssertionError, np_op, arr, obj,\n                                  err_msg=err_msg)\n                    assert_raises(AssertionError, np_op, obj, arr,\n                                  err_msg=err_msg)\n\n        # Check all binary operations\n        for op_name in sorted(ops.keys()):\n            yield check, op_name, True\n            yield check, op_name, False\n\n    def test_ufunc_override_rop_simple(self):\n        # Check parts of the binary op overriding behavior in an\n        # explicit test case that is easier to understand.\n\n        class SomeClass(object):\n            def __numpy_ufunc__(self, *a, **kw):\n                return \"ufunc\"\n            def __mul__(self, other):\n                return 123\n            def __rmul__(self, other):\n                return 321\n            def __gt__(self, other):\n                return \"yep\"\n            def __lt__(self, other):\n                return \"nope\"\n\n        class SomeClass2(SomeClass, ndarray):\n            def __numpy_ufunc__(self, ufunc, method, i, inputs, **kw):\n                if ufunc is np.multiply:\n                    return \"ufunc\"\n                else:\n                    inputs = list(inputs)\n                    inputs[i] = np.asarray(self)\n                    func = getattr(ufunc, method)\n                    r = func(*inputs, **kw)\n                    if 'out' in kw:\n                        return r\n                    else:\n                        x = SomeClass2(r.shape, dtype=r.dtype)\n                        x[...] = r\n                        return x\n\n        arr = np.array([0])\n        obj = SomeClass()\n        obj2 = SomeClass2((1,), dtype=np.int_)\n        obj2[0] = 9\n\n        assert_equal(obj * arr, 123)\n        assert_equal(arr * obj, 321)\n        assert_equal(arr > obj, \"nope\")\n        assert_equal(arr < obj, \"yep\")\n        assert_equal(np.multiply(arr, obj), \"ufunc\")\n        arr *= obj\n        assert_equal(arr, 321)\n\n        assert_equal(obj2 * arr, 123)\n        assert_equal(arr * obj2, 321)\n        assert_equal(arr > obj2, \"nope\")\n        assert_equal(arr < obj2, \"yep\")\n        assert_equal(np.multiply(arr, obj2), \"ufunc\")\n        arr *= obj2\n        assert_equal(arr, 321)\n\n        obj2 += 33\n        assert_equal(obj2[0], 42)\n        assert_equal(obj2.sum(), 42)\n        assert_(isinstance(obj2, SomeClass2))\n\n\nclass TestSubscripting(TestCase):\n    def test_test_zero_rank(self):\n        x = array([1, 2, 3])\n        self.assertTrue(isinstance(x[0], np.int_))\n        if sys.version_info[0] < 3:\n            self.assertTrue(isinstance(x[0], int))\n        self.assertTrue(type(x[0, ...]) is ndarray)\n\n\nclass TestPickling(TestCase):\n    def test_roundtrip(self):\n        import pickle\n        carray = array([[2, 9], [7, 0], [3, 8]])\n        DATA = [\n            carray,\n            transpose(carray),\n            array([('xxx', 1, 2.0)], dtype=[('a', (str, 3)), ('b', int),\n                                            ('c', float)])\n        ]\n\n        for a in DATA:\n            assert_equal(a, pickle.loads(a.dumps()), err_msg=\"%r\" % a)\n\n    def _loads(self, obj):\n        if sys.version_info[0] >= 3:\n            return loads(obj, encoding='latin1')\n        else:\n            return loads(obj)\n\n    # version 0 pickles, using protocol=2 to pickle\n    # version 0 doesn't have a version field\n    def test_version0_int8(self):\n        s = '\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x04\\x85cnumpy\\ndtype\\nq\\x04U\\x02i1K\\x00K\\x01\\x87Rq\\x05(U\\x01|NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89U\\x04\\x01\\x02\\x03\\x04tb.'\n        a = array([1, 2, 3, 4], dtype=int8)\n        p = self._loads(asbytes(s))\n        assert_equal(a, p)\n\n    def test_version0_float32(self):\n        s = '\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x04\\x85cnumpy\\ndtype\\nq\\x04U\\x02f4K\\x00K\\x01\\x87Rq\\x05(U\\x01<NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89U\\x10\\x00\\x00\\x80?\\x00\\x00\\x00@\\x00\\x00@@\\x00\\x00\\x80@tb.'\n        a = array([1.0, 2.0, 3.0, 4.0], dtype=float32)\n        p = self._loads(asbytes(s))\n        assert_equal(a, p)\n\n    def test_version0_object(self):\n        s = '\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x02\\x85cnumpy\\ndtype\\nq\\x04U\\x02O8K\\x00K\\x01\\x87Rq\\x05(U\\x01|NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89]q\\x06(}q\\x07U\\x01aK\\x01s}q\\x08U\\x01bK\\x02setb.'\n        a = np.array([{'a':1}, {'b':2}])\n        p = self._loads(asbytes(s))\n        assert_equal(a, p)\n\n    # version 1 pickles, using protocol=2 to pickle\n    def test_version1_int8(self):\n        s = '\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x01K\\x04\\x85cnumpy\\ndtype\\nq\\x04U\\x02i1K\\x00K\\x01\\x87Rq\\x05(K\\x01U\\x01|NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89U\\x04\\x01\\x02\\x03\\x04tb.'\n        a = array([1, 2, 3, 4], dtype=int8)\n        p = self._loads(asbytes(s))\n        assert_equal(a, p)\n\n    def test_version1_float32(self):\n        s = '\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x01K\\x04\\x85cnumpy\\ndtype\\nq\\x04U\\x02f4K\\x00K\\x01\\x87Rq\\x05(K\\x01U\\x01<NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89U\\x10\\x00\\x00\\x80?\\x00\\x00\\x00@\\x00\\x00@@\\x00\\x00\\x80@tb.'\n        a = array([1.0, 2.0, 3.0, 4.0], dtype=float32)\n        p = self._loads(asbytes(s))\n        assert_equal(a, p)\n\n    def test_version1_object(self):\n        s = '\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x01K\\x02\\x85cnumpy\\ndtype\\nq\\x04U\\x02O8K\\x00K\\x01\\x87Rq\\x05(K\\x01U\\x01|NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89]q\\x06(}q\\x07U\\x01aK\\x01s}q\\x08U\\x01bK\\x02setb.'\n        a = array([{'a':1}, {'b':2}])\n        p = self._loads(asbytes(s))\n        assert_equal(a, p)\n\n    def test_subarray_int_shape(self):\n        s = \"cnumpy.core.multiarray\\n_reconstruct\\np0\\n(cnumpy\\nndarray\\np1\\n(I0\\ntp2\\nS'b'\\np3\\ntp4\\nRp5\\n(I1\\n(I1\\ntp6\\ncnumpy\\ndtype\\np7\\n(S'V6'\\np8\\nI0\\nI1\\ntp9\\nRp10\\n(I3\\nS'|'\\np11\\nN(S'a'\\np12\\ng3\\ntp13\\n(dp14\\ng12\\n(g7\\n(S'V4'\\np15\\nI0\\nI1\\ntp16\\nRp17\\n(I3\\nS'|'\\np18\\n(g7\\n(S'i1'\\np19\\nI0\\nI1\\ntp20\\nRp21\\n(I3\\nS'|'\\np22\\nNNNI-1\\nI-1\\nI0\\ntp23\\nb(I2\\nI2\\ntp24\\ntp25\\nNNI4\\nI1\\nI0\\ntp26\\nbI0\\ntp27\\nsg3\\n(g7\\n(S'V2'\\np28\\nI0\\nI1\\ntp29\\nRp30\\n(I3\\nS'|'\\np31\\n(g21\\nI2\\ntp32\\nNNI2\\nI1\\nI0\\ntp33\\nbI4\\ntp34\\nsI6\\nI1\\nI0\\ntp35\\nbI00\\nS'\\\\x01\\\\x01\\\\x01\\\\x01\\\\x01\\\\x02'\\np36\\ntp37\\nb.\"\n        a = np.array([(1, (1, 2))], dtype=[('a', 'i1', (2, 2)), ('b', 'i1', 2)])\n        p = self._loads(asbytes(s))\n        assert_equal(a, p)\n\n\nclass TestFancyIndexing(TestCase):\n    def test_list(self):\n        x = ones((1, 1))\n        x[:, [0]] = 2.0\n        assert_array_equal(x, array([[2.0]]))\n\n        x = ones((1, 1, 1))\n        x[:,:, [0]] = 2.0\n        assert_array_equal(x, array([[[2.0]]]))\n\n    def test_tuple(self):\n        x = ones((1, 1))\n        x[:, (0,)] = 2.0\n        assert_array_equal(x, array([[2.0]]))\n        x = ones((1, 1, 1))\n        x[:,:, (0,)] = 2.0\n        assert_array_equal(x, array([[[2.0]]]))\n\n    def test_mask(self):\n        x = array([1, 2, 3, 4])\n        m = array([0, 1], bool)\n        assert_array_equal(x[m], array([2]))\n\n    def test_mask2(self):\n        x = array([[1, 2, 3, 4], [5, 6, 7, 8]])\n        m = array([0, 1], bool)\n        m2 = array([[0, 1], [1, 0]], bool)\n        m3 = array([[0, 1]], bool)\n        assert_array_equal(x[m], array([[5, 6, 7, 8]]))\n        assert_array_equal(x[m2], array([2, 5]))\n        assert_array_equal(x[m3], array([2]))\n\n    def test_assign_mask(self):\n        x = array([1, 2, 3, 4])\n        m = array([0, 1], bool)\n        x[m] = 5\n        assert_array_equal(x, array([1, 5, 3, 4]))\n\n    def test_assign_mask2(self):\n        xorig = array([[1, 2, 3, 4], [5, 6, 7, 8]])\n        m = array([0, 1], bool)\n        m2 = array([[0, 1], [1, 0]], bool)\n        m3 = array([[0, 1]], bool)\n        x = xorig.copy()\n        x[m] = 10\n        assert_array_equal(x, array([[1, 2, 3, 4], [10, 10, 10, 10]]))\n        x = xorig.copy()\n        x[m2] = 10\n        assert_array_equal(x, array([[1, 10, 3, 4], [10, 6, 7, 8]]))\n        x = xorig.copy()\n        x[m3] = 10\n        assert_array_equal(x, array([[1, 10, 3, 4], [5, 6, 7, 8]]))\n\n\nclass TestStringCompare(TestCase):\n    def test_string(self):\n        g1 = array([\"This\", \"is\", \"example\"])\n        g2 = array([\"This\", \"was\", \"example\"])\n        assert_array_equal(g1 == g2, [g1[i] == g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 != g2, [g1[i] != g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 <= g2, [g1[i] <= g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 >= g2, [g1[i] >= g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 < g2, [g1[i] < g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 > g2, [g1[i] > g2[i] for i in [0, 1, 2]])\n\n    def test_mixed(self):\n        g1 = array([\"spam\", \"spa\", \"spammer\", \"and eggs\"])\n        g2 = \"spam\"\n        assert_array_equal(g1 == g2, [x == g2 for x in g1])\n        assert_array_equal(g1 != g2, [x != g2 for x in g1])\n        assert_array_equal(g1 < g2, [x < g2 for x in g1])\n        assert_array_equal(g1 > g2, [x > g2 for x in g1])\n        assert_array_equal(g1 <= g2, [x <= g2 for x in g1])\n        assert_array_equal(g1 >= g2, [x >= g2 for x in g1])\n\n\n    def test_unicode(self):\n        g1 = array([sixu(\"This\"), sixu(\"is\"), sixu(\"example\")])\n        g2 = array([sixu(\"This\"), sixu(\"was\"), sixu(\"example\")])\n        assert_array_equal(g1 == g2, [g1[i] == g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 != g2, [g1[i] != g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 <= g2, [g1[i] <= g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 >= g2, [g1[i] >= g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 < g2,  [g1[i] < g2[i] for i in [0, 1, 2]])\n        assert_array_equal(g1 > g2,  [g1[i] > g2[i] for i in [0, 1, 2]])\n\n\nclass TestArgmax(TestCase):\n\n    nan_arr = [\n        ([0, 1, 2, 3, np.nan], 4),\n        ([0, 1, 2, np.nan, 3], 3),\n        ([np.nan, 0, 1, 2, 3], 0),\n        ([np.nan, 0, np.nan, 2, 3], 0),\n        ([0, 1, 2, 3, complex(0, np.nan)], 4),\n        ([0, 1, 2, 3, complex(np.nan, 0)], 4),\n        ([0, 1, 2, complex(np.nan, 0), 3], 3),\n        ([0, 1, 2, complex(0, np.nan), 3], 3),\n        ([complex(0, np.nan), 0, 1, 2, 3], 0),\n        ([complex(np.nan, np.nan), 0, 1, 2, 3], 0),\n        ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, 1)], 0),\n        ([complex(np.nan, np.nan), complex(np.nan, 2), complex(np.nan, 1)], 0),\n        ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, np.nan)], 0),\n\n        ([complex(0, 0), complex(0, 2), complex(0, 1)], 1),\n        ([complex(1, 0), complex(0, 2), complex(0, 1)], 0),\n        ([complex(1, 0), complex(0, 2), complex(1, 1)], 2),\n\n        ([np.datetime64('1923-04-14T12:43:12'),\n          np.datetime64('1994-06-21T14:43:15'),\n          np.datetime64('2001-10-15T04:10:32'),\n          np.datetime64('1995-11-25T16:02:16'),\n          np.datetime64('2005-01-04T03:14:12'),\n          np.datetime64('2041-12-03T14:05:03')], 5),\n        ([np.datetime64('1935-09-14T04:40:11'),\n          np.datetime64('1949-10-12T12:32:11'),\n          np.datetime64('2010-01-03T05:14:12'),\n          np.datetime64('2015-11-20T12:20:59'),\n          np.datetime64('1932-09-23T10:10:13'),\n          np.datetime64('2014-10-10T03:50:30')], 3),\n        ([np.datetime64('2059-03-14T12:43:12'),\n          np.datetime64('1996-09-21T14:43:15'),\n          np.datetime64('2001-10-15T04:10:32'),\n          np.datetime64('2022-12-25T16:02:16'),\n          np.datetime64('1963-10-04T03:14:12'),\n          np.datetime64('2013-05-08T18:15:23')], 0),\n\n        ([timedelta(days=5, seconds=14), timedelta(days=2, seconds=35),\n          timedelta(days=-1, seconds=23)], 0),\n        ([timedelta(days=1, seconds=43), timedelta(days=10, seconds=5),\n          timedelta(days=5, seconds=14)], 1),\n        ([timedelta(days=10, seconds=24), timedelta(days=10, seconds=5),\n          timedelta(days=10, seconds=43)], 2),\n\n        # Can't reduce a \"flexible type\"\n        #(['a', 'z', 'aa', 'zz'], 3),\n        #(['zz', 'a', 'aa', 'a'], 0),\n        #(['aa', 'z', 'zz', 'a'], 2),\n    ]\n\n    def test_all(self):\n        a = np.random.normal(0, 1, (4, 5, 6, 7, 8))\n        for i in range(a.ndim):\n            amax = a.max(i)\n            aargmax = a.argmax(i)\n            axes = list(range(a.ndim))\n            axes.remove(i)\n            assert_(all(amax == aargmax.choose(*a.transpose(i,*axes))))\n\n    def test_combinations(self):\n        for arr, pos in self.nan_arr:\n            assert_equal(np.argmax(arr), pos, err_msg=\"%r\"%arr)\n            assert_equal(arr[np.argmax(arr)], np.max(arr), err_msg=\"%r\"%arr)\n\n    def test_output_shape(self):\n        # see also gh-616\n        a = np.ones((10, 5))\n        # Check some simple shape mismatches\n        out = np.ones(11, dtype=np.int_)\n        assert_raises(ValueError, a.argmax, -1, out)\n\n        out = np.ones((2, 5), dtype=np.int_)\n        assert_raises(ValueError, a.argmax, -1, out)\n\n        # these could be relaxed possibly (used to allow even the previous)\n        out = np.ones((1, 10), dtype=np.int_)\n        assert_raises(ValueError, a.argmax, -1, np.ones((1, 10)))\n\n        out = np.ones(10, dtype=np.int_)\n        a.argmax(-1, out=out)\n        assert_equal(out, a.argmax(-1))\n\n\nclass TestArgmin(TestCase):\n\n    nan_arr = [\n        ([0, 1, 2, 3, np.nan], 4),\n        ([0, 1, 2, np.nan, 3], 3),\n        ([np.nan, 0, 1, 2, 3], 0),\n        ([np.nan, 0, np.nan, 2, 3], 0),\n        ([0, 1, 2, 3, complex(0, np.nan)], 4),\n        ([0, 1, 2, 3, complex(np.nan, 0)], 4),\n        ([0, 1, 2, complex(np.nan, 0), 3], 3),\n        ([0, 1, 2, complex(0, np.nan), 3], 3),\n        ([complex(0, np.nan), 0, 1, 2, 3], 0),\n        ([complex(np.nan, np.nan), 0, 1, 2, 3], 0),\n        ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, 1)], 0),\n        ([complex(np.nan, np.nan), complex(np.nan, 2), complex(np.nan, 1)], 0),\n        ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, np.nan)], 0),\n\n        ([complex(0, 0), complex(0, 2), complex(0, 1)], 0),\n        ([complex(1, 0), complex(0, 2), complex(0, 1)], 2),\n        ([complex(1, 0), complex(0, 2), complex(1, 1)], 1),\n\n        ([np.datetime64('1923-04-14T12:43:12'),\n          np.datetime64('1994-06-21T14:43:15'),\n          np.datetime64('2001-10-15T04:10:32'),\n          np.datetime64('1995-11-25T16:02:16'),\n          np.datetime64('2005-01-04T03:14:12'),\n          np.datetime64('2041-12-03T14:05:03')], 0),\n        ([np.datetime64('1935-09-14T04:40:11'),\n          np.datetime64('1949-10-12T12:32:11'),\n          np.datetime64('2010-01-03T05:14:12'),\n          np.datetime64('2014-11-20T12:20:59'),\n          np.datetime64('2015-09-23T10:10:13'),\n          np.datetime64('1932-10-10T03:50:30')], 5),\n        ([np.datetime64('2059-03-14T12:43:12'),\n          np.datetime64('1996-09-21T14:43:15'),\n          np.datetime64('2001-10-15T04:10:32'),\n          np.datetime64('2022-12-25T16:02:16'),\n          np.datetime64('1963-10-04T03:14:12'),\n          np.datetime64('2013-05-08T18:15:23')], 4),\n\n        ([timedelta(days=5, seconds=14), timedelta(days=2, seconds=35),\n          timedelta(days=-1, seconds=23)], 2),\n        ([timedelta(days=1, seconds=43), timedelta(days=10, seconds=5),\n          timedelta(days=5, seconds=14)], 0),\n        ([timedelta(days=10, seconds=24), timedelta(days=10, seconds=5),\n          timedelta(days=10, seconds=43)], 1),\n\n        # Can't reduce a \"flexible type\"\n        #(['a', 'z', 'aa', 'zz'], 0),\n        #(['zz', 'a', 'aa', 'a'], 1),\n        #(['aa', 'z', 'zz', 'a'], 3),\n    ]\n\n    def test_all(self):\n        a = np.random.normal(0, 1, (4, 5, 6, 7, 8))\n        for i in range(a.ndim):\n            amin = a.min(i)\n            aargmin = a.argmin(i)\n            axes = list(range(a.ndim))\n            axes.remove(i)\n            assert_(all(amin == aargmin.choose(*a.transpose(i,*axes))))\n\n    def test_combinations(self):\n        for arr, pos in self.nan_arr:\n            assert_equal(np.argmin(arr), pos, err_msg=\"%r\"%arr)\n            assert_equal(arr[np.argmin(arr)], np.min(arr), err_msg=\"%r\"%arr)\n\n    def test_minimum_signed_integers(self):\n\n        a = np.array([1, -2**7, -2**7 + 1], dtype=np.int8)\n        assert_equal(np.argmin(a), 1)\n\n        a = np.array([1, -2**15, -2**15 + 1], dtype=np.int16)\n        assert_equal(np.argmin(a), 1)\n\n        a = np.array([1, -2**31, -2**31 + 1], dtype=np.int32)\n        assert_equal(np.argmin(a), 1)\n\n        a = np.array([1, -2**63, -2**63 + 1], dtype=np.int64)\n        assert_equal(np.argmin(a), 1)\n\n    def test_output_shape(self):\n        # see also gh-616\n        a = np.ones((10, 5))\n        # Check some simple shape mismatches\n        out = np.ones(11, dtype=np.int_)\n        assert_raises(ValueError, a.argmin, -1, out)\n\n        out = np.ones((2, 5), dtype=np.int_)\n        assert_raises(ValueError, a.argmin, -1, out)\n\n        # these could be relaxed possibly (used to allow even the previous)\n        out = np.ones((1, 10), dtype=np.int_)\n        assert_raises(ValueError, a.argmin, -1, np.ones((1, 10)))\n\n        out = np.ones(10, dtype=np.int_)\n        a.argmin(-1, out=out)\n        assert_equal(out, a.argmin(-1))\n\n\nclass TestMinMax(TestCase):\n    def test_scalar(self):\n        assert_raises(ValueError, np.amax, 1, 1)\n        assert_raises(ValueError, np.amin, 1, 1)\n\n        assert_equal(np.amax(1, axis=0), 1)\n        assert_equal(np.amin(1, axis=0), 1)\n        assert_equal(np.amax(1, axis=None), 1)\n        assert_equal(np.amin(1, axis=None), 1)\n\n    def test_axis(self):\n        assert_raises(ValueError, np.amax, [1, 2, 3], 1000)\n        assert_equal(np.amax([[1, 2, 3]], axis=1), 3)\n\nclass TestNewaxis(TestCase):\n    def test_basic(self):\n        sk = array([0, -0.1, 0.1])\n        res = 250*sk[:, newaxis]\n        assert_almost_equal(res.ravel(), 250*sk)\n\n\nclass TestClip(TestCase):\n    def _check_range(self, x, cmin, cmax):\n        assert_(np.all(x >= cmin))\n        assert_(np.all(x <= cmax))\n\n    def _clip_type(self,type_group,array_max,\n                   clip_min,clip_max,inplace=False,\n                   expected_min=None,expected_max=None):\n        if expected_min is None:\n            expected_min = clip_min\n        if expected_max is None:\n            expected_max = clip_max\n\n        for T in np.sctypes[type_group]:\n            if sys.byteorder == 'little':\n                byte_orders = ['=', '>']\n            else:\n                byte_orders = ['<', '=']\n\n            for byteorder in byte_orders:\n                dtype = np.dtype(T).newbyteorder(byteorder)\n\n                x = (np.random.random(1000) * array_max).astype(dtype)\n                if inplace:\n                    x.clip(clip_min, clip_max, x)\n                else:\n                    x = x.clip(clip_min, clip_max)\n                    byteorder = '='\n\n                if x.dtype.byteorder == '|': byteorder = '|'\n                assert_equal(x.dtype.byteorder, byteorder)\n                self._check_range(x, expected_min, expected_max)\n        return x\n\n    def test_basic(self):\n        for inplace in [False, True]:\n            self._clip_type('float', 1024, -12.8, 100.2, inplace=inplace)\n            self._clip_type('float', 1024, 0, 0, inplace=inplace)\n\n            self._clip_type('int', 1024, -120, 100.5, inplace=inplace)\n            self._clip_type('int', 1024, 0, 0, inplace=inplace)\n\n            x = self._clip_type('uint', 1024, -120, 100, expected_min=0,\n                    inplace=inplace)\n            x = self._clip_type('uint', 1024, 0, 0, inplace=inplace)\n\n    def test_record_array(self):\n        rec = np.array([(-5, 2.0, 3.0), (5.0, 4.0, 3.0)],\n                      dtype=[('x', '<f8'), ('y', '<f8'), ('z', '<f8')])\n        y = rec['x'].clip(-0.3, 0.5)\n        self._check_range(y, -0.3, 0.5)\n\n    def test_max_or_min(self):\n        val = np.array([0, 1, 2, 3, 4, 5, 6, 7])\n        x = val.clip(3)\n        assert_(np.all(x >= 3))\n        x = val.clip(min=3)\n        assert_(np.all(x >= 3))\n        x = val.clip(max=4)\n        assert_(np.all(x <= 4))\n\n\nclass TestPutmask(object):\n    def tst_basic(self, x, T, mask, val):\n        np.putmask(x, mask, val)\n        assert_(np.all(x[mask] == T(val)))\n        assert_(x.dtype == T)\n\n    def test_ip_types(self):\n        unchecked_types = [str, unicode, np.void, object]\n\n        x = np.random.random(1000)*100\n        mask = x < 40\n\n        for val in [-100, 0, 15]:\n            for types in np.sctypes.values():\n                for T in types:\n                    if T not in unchecked_types:\n                        yield self.tst_basic, x.copy().astype(T), T, mask, val\n\n    def test_mask_size(self):\n        assert_raises(ValueError, np.putmask, np.array([1, 2, 3]), [True], 5)\n\n    def tst_byteorder(self, dtype):\n        x = np.array([1, 2, 3], dtype)\n        np.putmask(x, [True, False, True], -1)\n        assert_array_equal(x, [-1, 2, -1])\n\n    def test_ip_byteorder(self):\n        for dtype in ('>i4', '<i4'):\n            yield self.tst_byteorder, dtype\n\n    def test_record_array(self):\n        # Note mixed byteorder.\n        rec = np.array([(-5, 2.0, 3.0), (5.0, 4.0, 3.0)],\n                      dtype=[('x', '<f8'), ('y', '>f8'), ('z', '<f8')])\n        np.putmask(rec['x'], [True, False], 10)\n        assert_array_equal(rec['x'], [10, 5])\n        assert_array_equal(rec['y'], [2, 4])\n        assert_array_equal(rec['z'], [3, 3])\n        np.putmask(rec['y'], [True, False], 11)\n        assert_array_equal(rec['x'], [10, 5])\n        assert_array_equal(rec['y'], [11, 4])\n        assert_array_equal(rec['z'], [3, 3])\n\n    def test_masked_array(self):\n        ## x = np.array([1,2,3])\n        ## z = np.ma.array(x,mask=[True,False,False])\n        ## np.putmask(z,[True,True,True],3)\n        pass\n\n\nclass TestTake(object):\n    def tst_basic(self, x):\n        ind = list(range(x.shape[0]))\n        assert_array_equal(x.take(ind, axis=0), x)\n\n    def test_ip_types(self):\n        unchecked_types = [str, unicode, np.void, object]\n\n        x = np.random.random(24)*100\n        x.shape = 2, 3, 4\n        for types in np.sctypes.values():\n            for T in types:\n                if T not in unchecked_types:\n                    yield self.tst_basic, x.copy().astype(T)\n\n    def test_raise(self):\n        x = np.random.random(24)*100\n        x.shape = 2, 3, 4\n        assert_raises(IndexError, x.take, [0, 1, 2], axis=0)\n        assert_raises(IndexError, x.take, [-3], axis=0)\n        assert_array_equal(x.take([-1], axis=0)[0], x[1])\n\n    def test_clip(self):\n        x = np.random.random(24)*100\n        x.shape = 2, 3, 4\n        assert_array_equal(x.take([-1], axis=0, mode='clip')[0], x[0])\n        assert_array_equal(x.take([2], axis=0, mode='clip')[0], x[1])\n\n    def test_wrap(self):\n        x = np.random.random(24)*100\n        x.shape = 2, 3, 4\n        assert_array_equal(x.take([-1], axis=0, mode='wrap')[0], x[1])\n        assert_array_equal(x.take([2], axis=0, mode='wrap')[0], x[0])\n        assert_array_equal(x.take([3], axis=0, mode='wrap')[0], x[1])\n\n    def tst_byteorder(self, dtype):\n        x = np.array([1, 2, 3], dtype)\n        assert_array_equal(x.take([0, 2, 1]), [1, 3, 2])\n\n    def test_ip_byteorder(self):\n        for dtype in ('>i4', '<i4'):\n            yield self.tst_byteorder, dtype\n\n    def test_record_array(self):\n        # Note mixed byteorder.\n        rec = np.array([(-5, 2.0, 3.0), (5.0, 4.0, 3.0)],\n                      dtype=[('x', '<f8'), ('y', '>f8'), ('z', '<f8')])\n        rec1 = rec.take([1])\n        assert_(rec1['x'] == 5.0 and rec1['y'] == 4.0)\n\n\nclass TestLexsort(TestCase):\n    def test_basic(self):\n        a = [1, 2, 1, 3, 1, 5]\n        b = [0, 4, 5, 6, 2, 3]\n        idx = np.lexsort((b, a))\n        expected_idx = np.array([0, 4, 2, 1, 3, 5])\n        assert_array_equal(idx, expected_idx)\n\n        x = np.vstack((b, a))\n        idx = np.lexsort(x)\n        assert_array_equal(idx, expected_idx)\n\n        assert_array_equal(x[1][idx], np.sort(x[1]))\n\n    def test_datetime(self):\n        a = np.array([0,0,0], dtype='datetime64[D]')\n        b = np.array([2,1,0], dtype='datetime64[D]')\n        idx = np.lexsort((b, a))\n        expected_idx = np.array([2, 1, 0])\n        assert_array_equal(idx, expected_idx)\n\n        a = np.array([0,0,0], dtype='timedelta64[D]')\n        b = np.array([2,1,0], dtype='timedelta64[D]')\n        idx = np.lexsort((b, a))\n        expected_idx = np.array([2, 1, 0])\n        assert_array_equal(idx, expected_idx)\n\n\nclass TestIO(object):\n    \"\"\"Test tofile, fromfile, tostring, and fromstring\"\"\"\n\n    def setUp(self):\n        shape = (2, 4, 3)\n        rand = np.random.random\n        self.x = rand(shape) + rand(shape).astype(np.complex)*1j\n        self.x[0,:, 1] = [nan, inf, -inf, nan]\n        self.dtype = self.x.dtype\n        self.file = tempfile.NamedTemporaryFile()\n        self.filename = self.file.name\n\n    def tearDown(self):\n        self.file.close()\n\n    def test_bool_fromstring(self):\n        v = np.array([True, False, True, False], dtype=np.bool_)\n        y = np.fromstring('1 0 -2.3 0.0', sep=' ', dtype=np.bool_)\n        assert_array_equal(v, y)\n\n    def test_empty_files_binary(self):\n        f = open(self.filename, 'w')\n        f.close()\n        y = fromfile(self.filename)\n        assert_(y.size == 0, \"Array not empty\")\n\n    def test_empty_files_text(self):\n        f = open(self.filename, 'w')\n        f.close()\n        y = fromfile(self.filename, sep=\" \")\n        assert_(y.size == 0, \"Array not empty\")\n\n    def test_roundtrip_file(self):\n        f = open(self.filename, 'wb')\n        self.x.tofile(f)\n        f.close()\n        # NB. doesn't work with flush+seek, due to use of C stdio\n        f = open(self.filename, 'rb')\n        y = np.fromfile(f, dtype=self.dtype)\n        f.close()\n        assert_array_equal(y, self.x.flat)\n\n    def test_roundtrip_filename(self):\n        self.x.tofile(self.filename)\n        y = np.fromfile(self.filename, dtype=self.dtype)\n        assert_array_equal(y, self.x.flat)\n\n    def test_roundtrip_binary_str(self):\n        s = self.x.tostring()\n        y = np.fromstring(s, dtype=self.dtype)\n        assert_array_equal(y, self.x.flat)\n\n        s = self.x.tostring('F')\n        y = np.fromstring(s, dtype=self.dtype)\n        assert_array_equal(y, self.x.flatten('F'))\n\n    def test_roundtrip_str(self):\n        x = self.x.real.ravel()\n        s = \"@\".join(map(str, x))\n        y = np.fromstring(s, sep=\"@\")\n        # NB. str imbues less precision\n        nan_mask = ~np.isfinite(x)\n        assert_array_equal(x[nan_mask], y[nan_mask])\n        assert_array_almost_equal(x[~nan_mask], y[~nan_mask], decimal=5)\n\n    def test_roundtrip_repr(self):\n        x = self.x.real.ravel()\n        s = \"@\".join(map(repr, x))\n        y = np.fromstring(s, sep=\"@\")\n        assert_array_equal(x, y)\n\n    def test_file_position_after_fromfile(self):\n        # gh-4118\n        sizes = [io.DEFAULT_BUFFER_SIZE//8,\n                 io.DEFAULT_BUFFER_SIZE,\n                 io.DEFAULT_BUFFER_SIZE*8]\n\n        for size in sizes:\n            f = open(self.filename, 'wb')\n            f.seek(size-1)\n            f.write(b'\\0')\n            f.close()\n\n            for mode in ['rb', 'r+b']:\n                err_msg = \"%d %s\" % (size, mode)\n\n                f = open(self.filename, mode)\n                f.read(2)\n                np.fromfile(f, dtype=np.float64, count=1)\n                pos = f.tell()\n                f.close()\n                assert_equal(pos, 10, err_msg=err_msg)\n\n    def test_file_position_after_tofile(self):\n        # gh-4118\n        sizes = [io.DEFAULT_BUFFER_SIZE//8,\n                 io.DEFAULT_BUFFER_SIZE,\n                 io.DEFAULT_BUFFER_SIZE*8]\n\n        for size in sizes:\n            err_msg = \"%d\" % (size,)\n\n            f = open(self.filename, 'wb')\n            f.seek(size-1)\n            f.write(b'\\0')\n            f.seek(10)\n            f.write(b'12')\n            np.array([0], dtype=np.float64).tofile(f)\n            pos = f.tell()\n            f.close()\n            assert_equal(pos, 10 + 2 + 8, err_msg=err_msg)\n\n            f = open(self.filename, 'r+b')\n            f.read(2)\n            f.seek(0, 1) # seek between read&write required by ANSI C\n            np.array([0], dtype=np.float64).tofile(f)\n            pos = f.tell()\n            f.close()\n            assert_equal(pos, 10, err_msg=err_msg)\n\n    def _check_from(self, s, value, **kw):\n        y = np.fromstring(asbytes(s), **kw)\n        assert_array_equal(y, value)\n\n        f = open(self.filename, 'wb')\n        f.write(asbytes(s))\n        f.close()\n        y = np.fromfile(self.filename, **kw)\n        assert_array_equal(y, value)\n\n    def test_nan(self):\n        self._check_from(\"nan +nan -nan NaN nan(foo) +NaN(BAR) -NAN(q_u_u_x_)\",\n                         [nan, nan, nan, nan, nan, nan, nan],\n                         sep=' ')\n\n    def test_inf(self):\n        self._check_from(\"inf +inf -inf infinity -Infinity iNfInItY -inF\",\n                         [inf, inf, -inf, inf, -inf, inf, -inf], sep=' ')\n\n    def test_numbers(self):\n        self._check_from(\"1.234 -1.234 .3 .3e55 -123133.1231e+133\",\n                         [1.234, -1.234, .3, .3e55, -123133.1231e+133], sep=' ')\n\n    def test_binary(self):\n        self._check_from('\\x00\\x00\\x80?\\x00\\x00\\x00@\\x00\\x00@@\\x00\\x00\\x80@',\n                         array([1, 2, 3, 4]),\n                         dtype='<f4')\n\n    @dec.slow # takes > 1 minute on mechanical hard drive\n    def test_big_binary(self):\n        \"\"\"Test workarounds for 32-bit limited fwrite, fseek, and ftell\n        calls in windows. These normally would hang doing something like this.\n        See http://projects.scipy.org/numpy/ticket/1660\"\"\"\n        if sys.platform != 'win32':\n            return\n        try:\n            # before workarounds, only up to 2**32-1 worked\n            fourgbplus = 2**32 + 2**16\n            testbytes = np.arange(8, dtype=np.int8)\n            n = len(testbytes)\n            flike = tempfile.NamedTemporaryFile()\n            f = flike.file\n            np.tile(testbytes, fourgbplus // testbytes.nbytes).tofile(f)\n            flike.seek(0)\n            a = np.fromfile(f, dtype=np.int8)\n            flike.close()\n            assert_(len(a) == fourgbplus)\n            # check only start and end for speed:\n            assert_((a[:n] == testbytes).all())\n            assert_((a[-n:] == testbytes).all())\n        except (MemoryError, ValueError):\n            pass\n\n    def test_string(self):\n        self._check_from('1,2,3,4', [1., 2., 3., 4.], sep=',')\n\n    def test_counted_string(self):\n        self._check_from('1,2,3,4', [1., 2., 3., 4.], count=4, sep=',')\n        self._check_from('1,2,3,4', [1., 2., 3.], count=3, sep=',')\n        self._check_from('1,2,3,4', [1., 2., 3., 4.], count=-1, sep=',')\n\n    def test_string_with_ws(self):\n        self._check_from('1 2  3     4   ', [1, 2, 3, 4], dtype=int, sep=' ')\n\n    def test_counted_string_with_ws(self):\n        self._check_from('1 2  3     4   ', [1, 2, 3], count=3, dtype=int,\n                         sep=' ')\n\n    def test_ascii(self):\n        self._check_from('1 , 2 , 3 , 4', [1., 2., 3., 4.], sep=',')\n        self._check_from('1,2,3,4', [1., 2., 3., 4.], dtype=float, sep=',')\n\n    def test_malformed(self):\n        self._check_from('1.234 1,234', [1.234, 1.], sep=' ')\n\n    def test_long_sep(self):\n        self._check_from('1_x_3_x_4_x_5', [1, 3, 4, 5], sep='_x_')\n\n    def test_dtype(self):\n        v = np.array([1, 2, 3, 4], dtype=np.int_)\n        self._check_from('1,2,3,4', v, sep=',', dtype=np.int_)\n\n    def test_dtype_bool(self):\n        # can't use _check_from because fromstring can't handle True/False\n        v = np.array([True, False, True, False], dtype=np.bool_)\n        s = '1,0,-2.3,0'\n        f = open(self.filename, 'wb')\n        f.write(asbytes(s))\n        f.close()\n        y = np.fromfile(self.filename, sep=',', dtype=np.bool_)\n        assert_(y.dtype == '?')\n        assert_array_equal(y, v)\n\n    def test_tofile_sep(self):\n        x = np.array([1.51, 2, 3.51, 4], dtype=float)\n        f = open(self.filename, 'w')\n        x.tofile(f, sep=',')\n        f.close()\n        f = open(self.filename, 'r')\n        s = f.read()\n        f.close()\n        assert_equal(s, '1.51,2.0,3.51,4.0')\n\n    def test_tofile_format(self):\n        x = np.array([1.51, 2, 3.51, 4], dtype=float)\n        f = open(self.filename, 'w')\n        x.tofile(f, sep=',', format='%.2f')\n        f.close()\n        f = open(self.filename, 'r')\n        s = f.read()\n        f.close()\n        assert_equal(s, '1.51,2.00,3.51,4.00')\n\n    def test_locale(self):\n        in_foreign_locale(self.test_numbers)()\n        in_foreign_locale(self.test_nan)()\n        in_foreign_locale(self.test_inf)()\n        in_foreign_locale(self.test_counted_string)()\n        in_foreign_locale(self.test_ascii)()\n        in_foreign_locale(self.test_malformed)()\n        in_foreign_locale(self.test_tofile_sep)()\n        in_foreign_locale(self.test_tofile_format)()\n\n\nclass TestFromBuffer(object):\n    def tst_basic(self, buffer, expected, kwargs):\n        assert_array_equal(np.frombuffer(buffer,**kwargs), expected)\n\n    def test_ip_basic(self):\n        for byteorder in ['<', '>']:\n            for dtype in [float, int, np.complex]:\n                dt = np.dtype(dtype).newbyteorder(byteorder)\n                x = (np.random.random((4, 7))*5).astype(dt)\n                buf = x.tostring()\n                yield self.tst_basic, buf, x.flat, {'dtype':dt}\n\n    def test_empty(self):\n        yield self.tst_basic, asbytes(''), np.array([]), {}\n\n\nclass TestFlat(TestCase):\n    def setUp(self):\n        a0 = arange(20.0)\n        a = a0.reshape(4, 5)\n        a0.shape = (4, 5)\n        a.flags.writeable = False\n        self.a = a\n        self.b = a[::2, ::2]\n        self.a0 = a0\n        self.b0 = a0[::2, ::2]\n\n    def test_contiguous(self):\n        testpassed = False\n        try:\n            self.a.flat[12] = 100.0\n        except ValueError:\n            testpassed = True\n        assert testpassed\n        assert self.a.flat[12] == 12.0\n\n    def test_discontiguous(self):\n        testpassed = False\n        try:\n            self.b.flat[4] = 100.0\n        except ValueError:\n            testpassed = True\n        assert testpassed\n        assert self.b.flat[4] == 12.0\n\n    def test___array__(self):\n        c = self.a.flat.__array__()\n        d = self.b.flat.__array__()\n        e = self.a0.flat.__array__()\n        f = self.b0.flat.__array__()\n\n        assert c.flags.writeable is False\n        assert d.flags.writeable is False\n        assert e.flags.writeable is True\n        assert f.flags.writeable is True\n\n        assert c.flags.updateifcopy is False\n        assert d.flags.updateifcopy is False\n        assert e.flags.updateifcopy is False\n        assert f.flags.updateifcopy is True\n        assert f.base is self.b0\n\nclass TestResize(TestCase):\n    def test_basic(self):\n        x = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        x.resize((5, 5))\n        assert_array_equal(x.flat[:9],\n                np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]).flat)\n        assert_array_equal(x[9:].flat, 0)\n\n    def test_check_reference(self):\n        x = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        y = x\n        self.assertRaises(ValueError, x.resize, (5, 1))\n\n    def test_int_shape(self):\n        x = np.eye(3)\n        x.resize(3)\n        assert_array_equal(x, np.eye(3)[0,:])\n\n    def test_none_shape(self):\n        x = np.eye(3)\n        x.resize(None)\n        assert_array_equal(x, np.eye(3))\n        x.resize()\n        assert_array_equal(x, np.eye(3))\n\n    def test_invalid_arguements(self):\n        self.assertRaises(TypeError, np.eye(3).resize, 'hi')\n        self.assertRaises(ValueError, np.eye(3).resize, -1)\n        self.assertRaises(TypeError, np.eye(3).resize, order=1)\n        self.assertRaises(TypeError, np.eye(3).resize, refcheck='hi')\n\n    def test_freeform_shape(self):\n        x = np.eye(3)\n        x.resize(3, 2, 1)\n        assert_(x.shape == (3, 2, 1))\n\n    def test_zeros_appended(self):\n        x = np.eye(3)\n        x.resize(2, 3, 3)\n        assert_array_equal(x[0], np.eye(3))\n        assert_array_equal(x[1], np.zeros((3, 3)))\n\n\nclass TestRecord(TestCase):\n    def test_field_rename(self):\n        dt = np.dtype([('f', float), ('i', int)])\n        dt.names = ['p', 'q']\n        assert_equal(dt.names, ['p', 'q'])\n\n    if sys.version_info[0] >= 3:\n        def test_bytes_fields(self):\n            # Bytes are not allowed in field names and not recognized in titles\n            # on Py3\n            assert_raises(TypeError, np.dtype, [(asbytes('a'), int)])\n            assert_raises(TypeError, np.dtype, [(('b', asbytes('a')), int)])\n\n            dt = np.dtype([((asbytes('a'), 'b'), int)])\n            assert_raises(ValueError, dt.__getitem__, asbytes('a'))\n\n            x = np.array([(1,), (2,), (3,)], dtype=dt)\n            assert_raises(ValueError, x.__getitem__, asbytes('a'))\n\n            y = x[0]\n            assert_raises(IndexError, y.__getitem__, asbytes('a'))\n    else:\n        def test_unicode_field_titles(self):\n            # Unicode field titles are added to field dict on Py2\n            title = unicode('b')\n            dt = np.dtype([((title, 'a'), int)])\n            dt[title]\n            dt['a']\n            x = np.array([(1,), (2,), (3,)], dtype=dt)\n            x[title]\n            x['a']\n            y = x[0]\n            y[title]\n            y['a']\n\n        def test_unicode_field_names(self):\n            # Unicode field names are not allowed on Py2\n            title = unicode('b')\n            assert_raises(TypeError, np.dtype, [(title, int)])\n            assert_raises(TypeError, np.dtype, [(('a', title), int)])\n\n    def test_field_names(self):\n        # Test unicode and 8-bit / byte strings can be used\n        a = np.zeros((1,), dtype=[('f1', 'i4'),\n                                  ('f2', 'i4'),\n                                  ('f3', [('sf1', 'i4')])])\n        is_py3 = sys.version_info[0] >= 3\n        if is_py3:\n            funcs = (str,)\n            # byte string indexing fails gracefully\n            assert_raises(ValueError, a.__setitem__, asbytes('f1'), 1)\n            assert_raises(ValueError, a.__getitem__, asbytes('f1'))\n            assert_raises(ValueError, a['f1'].__setitem__, asbytes('sf1'), 1)\n            assert_raises(ValueError, a['f1'].__getitem__, asbytes('sf1'))\n        else:\n            funcs = (str, unicode)\n        for func in funcs:\n            b = a.copy()\n            fn1 = func('f1')\n            b[fn1] = 1\n            assert_equal(b[fn1], 1)\n            fnn = func('not at all')\n            assert_raises(ValueError, b.__setitem__, fnn, 1)\n            assert_raises(ValueError, b.__getitem__, fnn)\n            b[0][fn1] = 2\n            assert_equal(b[fn1], 2)\n            # Subfield\n            assert_raises(IndexError, b[0].__setitem__, fnn, 1)\n            assert_raises(IndexError, b[0].__getitem__, fnn)\n            # Subfield\n            fn3 = func('f3')\n            sfn1 = func('sf1')\n            b[fn3][sfn1] = 1\n            assert_equal(b[fn3][sfn1], 1)\n            assert_raises(ValueError, b[fn3].__setitem__, fnn, 1)\n            assert_raises(ValueError, b[fn3].__getitem__, fnn)\n            # multiple Subfields\n            fn2 = func('f2')\n            b[fn2] = 3\n            assert_equal(b[['f1', 'f2']][0].tolist(), (2, 3))\n            assert_equal(b[['f2', 'f1']][0].tolist(), (3, 2))\n            assert_equal(b[['f1', 'f3']][0].tolist(), (2, (1,)))\n            # view of subfield view/copy\n            assert_equal(b[['f1', 'f2']][0].view(('i4', 2)).tolist(), (2, 3))\n            assert_equal(b[['f2', 'f1']][0].view(('i4', 2)).tolist(), (3, 2))\n            view_dtype=[('f1', 'i4'), ('f3', [('', 'i4')])]\n            assert_equal(b[['f1', 'f3']][0].view(view_dtype).tolist(), (2, (1,)))\n        # non-ascii unicode field indexing is well behaved\n        if not is_py3:\n            raise SkipTest('non ascii unicode field indexing skipped; '\n                           'raises segfault on python 2.x')\n        else:\n            assert_raises(ValueError, a.__setitem__, sixu('\\u03e0'), 1)\n            assert_raises(ValueError, a.__getitem__, sixu('\\u03e0'))\n\n    def test_field_names_deprecation(self):\n\n        def collect_warning_types(f, *args, **kwargs):\n            with warnings.catch_warnings(record=True) as log:\n                warnings.simplefilter(\"always\")\n                f(*args, **kwargs)\n            return [w.category for w in log]\n\n        a = np.zeros((1,), dtype=[('f1', 'i4'),\n                                  ('f2', 'i4'),\n                                  ('f3', [('sf1', 'i4')])])\n        a['f1'][0] = 1\n        a['f2'][0] = 2\n        a['f3'][0] = (3,)\n        b = np.zeros((1,), dtype=[('f1', 'i4'),\n                                  ('f2', 'i4'),\n                                  ('f3', [('sf1', 'i4')])])\n        b['f1'][0] = 1\n        b['f2'][0] = 2\n        b['f3'][0] = (3,)\n\n        # All the different functions raise a warning, but not an error, and\n        # 'a' is not modified:\n        assert_equal(collect_warning_types(a[['f1', 'f2']].__setitem__, 0, (10, 20)),\n                     [FutureWarning])\n        assert_equal(a, b)\n        # Views also warn\n        subset = a[['f1', 'f2']]\n        subset_view = subset.view()\n        assert_equal(collect_warning_types(subset_view['f1'].__setitem__, 0, 10),\n                     [FutureWarning])\n        # But the write goes through:\n        assert_equal(subset['f1'][0], 10)\n        # Only one warning per multiple field indexing, though (even if there are\n        # multiple views involved):\n        assert_equal(collect_warning_types(subset['f1'].__setitem__, 0, 10),\n                     [])\n\n    def test_record_hash(self):\n        a = np.array([(1, 2), (1, 2)], dtype='i1,i2')\n        a.flags.writeable = False\n        b = np.array([(1, 2), (3, 4)], dtype=[('num1', 'i1'), ('num2', 'i2')])\n        b.flags.writeable = False\n        c = np.array([(1, 2), (3, 4)], dtype='i1,i2')\n        c.flags.writeable = False\n        self.assertTrue(hash(a[0]) == hash(a[1]))\n        self.assertTrue(hash(a[0]) == hash(b[0]))\n        self.assertTrue(hash(a[0]) != hash(b[1]))\n        self.assertTrue(hash(c[0]) == hash(a[0]) and c[0] == a[0])\n\n    def test_record_no_hash(self):\n        a = np.array([(1, 2), (1, 2)], dtype='i1,i2')\n        self.assertRaises(TypeError, hash, a[0])\n\nclass TestView(TestCase):\n    def test_basic(self):\n        x = np.array([(1, 2, 3, 4), (5, 6, 7, 8)], dtype=[('r', np.int8), ('g', np.int8),\n                                                  ('b', np.int8), ('a', np.int8)])\n        # We must be specific about the endianness here:\n        y = x.view(dtype='<i4')\n        # ... and again without the keyword.\n        z = x.view('<i4')\n        assert_array_equal(y, z)\n        assert_array_equal(y, [67305985, 134678021])\n\ndef _mean(a, **args):\n    return a.mean(**args)\n\ndef _var(a, **args):\n    return a.var(**args)\n\ndef _std(a, **args):\n    return a.std(**args)\n\nclass TestStats(TestCase):\n\n    funcs = [_mean, _var, _std]\n\n    def setUp(self):\n        np.random.seed(range(3))\n        self.rmat = np.random.random((4, 5))\n        self.cmat = self.rmat + 1j * self.rmat\n\n    def test_keepdims(self):\n        mat = np.eye(3)\n        for f in self.funcs:\n            for axis in [0, 1]:\n                res = f(mat, axis=axis, keepdims=True)\n                assert_(res.ndim == mat.ndim)\n                assert_(res.shape[axis] == 1)\n            for axis in [None]:\n                res = f(mat, axis=axis, keepdims=True)\n                assert_(res.shape == (1, 1))\n\n    def test_out(self):\n        mat = np.eye(3)\n        for f in self.funcs:\n            out = np.zeros(3)\n            tgt = f(mat, axis=1)\n            res = f(mat, axis=1, out=out)\n            assert_almost_equal(res, out)\n            assert_almost_equal(res, tgt)\n        out = np.empty(2)\n        assert_raises(ValueError, f, mat, axis=1, out=out)\n        out = np.empty((2, 2))\n        assert_raises(ValueError, f, mat, axis=1, out=out)\n\n    def test_dtype_from_input(self):\n        icodes = np.typecodes['AllInteger']\n        fcodes = np.typecodes['AllFloat']\n\n        # integer types\n        for f in self.funcs:\n            for c in icodes:\n                mat = np.eye(3, dtype=c)\n                tgt = np.float64\n                res = f(mat, axis=1).dtype.type\n                assert_(res is tgt)\n                # scalar case\n                res = f(mat, axis=None).dtype.type\n                assert_(res is tgt)\n        # mean for float types\n        for f in [_mean]:\n            for c in fcodes:\n                mat = np.eye(3, dtype=c)\n                tgt = mat.dtype.type\n                res = f(mat, axis=1).dtype.type\n                assert_(res is tgt)\n                # scalar case\n                res = f(mat, axis=None).dtype.type\n                assert_(res is tgt)\n        # var, std for float types\n        for f in [_var, _std]:\n            for c in fcodes:\n                mat = np.eye(3, dtype=c)\n                tgt = mat.real.dtype.type\n                res = f(mat, axis=1).dtype.type\n                assert_(res is tgt)\n                # scalar case\n                res = f(mat, axis=None).dtype.type\n                assert_(res is tgt)\n\n    def test_dtype_from_dtype(self):\n        icodes = np.typecodes['AllInteger']\n        fcodes = np.typecodes['AllFloat']\n        mat = np.eye(3)\n\n        # stats for integer types\n        # fixme:\n        # this needs definition as there are lots places along the line\n        # where type casting may take place.\n        #for f in self.funcs:\n            #for c in icodes:\n                #tgt = np.dtype(c).type\n                #res = f(mat, axis=1, dtype=c).dtype.type\n                #assert_(res is tgt)\n                ## scalar case\n                #res = f(mat, axis=None, dtype=c).dtype.type\n                #assert_(res is tgt)\n\n        # stats for float types\n        for f in self.funcs:\n            for c in fcodes:\n                tgt = np.dtype(c).type\n                res = f(mat, axis=1, dtype=c).dtype.type\n                assert_(res is tgt)\n                # scalar case\n                res = f(mat, axis=None, dtype=c).dtype.type\n                assert_(res is tgt)\n\n    def test_ddof(self):\n        for f in [_var]:\n            for ddof in range(3):\n                dim = self.rmat.shape[1]\n                tgt = f(self.rmat, axis=1) * dim\n                res = f(self.rmat, axis=1, ddof=ddof) * (dim - ddof)\n        for f in [_std]:\n            for ddof in range(3):\n                dim = self.rmat.shape[1]\n                tgt = f(self.rmat, axis=1) * np.sqrt(dim)\n                res = f(self.rmat, axis=1, ddof=ddof) * np.sqrt(dim - ddof)\n                assert_almost_equal(res, tgt)\n                assert_almost_equal(res, tgt)\n\n    def test_ddof_too_big(self):\n        dim = self.rmat.shape[1]\n        for f in [_var, _std]:\n            for ddof in range(dim, dim + 2):\n                with warnings.catch_warnings(record=True) as w:\n                    warnings.simplefilter('always')\n                    res = f(self.rmat, axis=1, ddof=ddof)\n                    assert_(not (res < 0).any())\n                    assert_(len(w) > 0)\n                    assert_(issubclass(w[0].category, RuntimeWarning))\n\n    def test_empty(self):\n        A = np.zeros((0, 3))\n        for f in self.funcs:\n            for axis in [0, None]:\n                with warnings.catch_warnings(record=True) as w:\n                    warnings.simplefilter('always')\n                    assert_(np.isnan(f(A, axis=axis)).all())\n                    assert_(len(w) > 0)\n                    assert_(issubclass(w[0].category, RuntimeWarning))\n            for axis in [1]:\n                with warnings.catch_warnings(record=True) as w:\n                    warnings.simplefilter('always')\n                    assert_equal(f(A, axis=axis), np.zeros([]))\n\n    def test_mean_values(self):\n        for mat in [self.rmat, self.cmat]:\n            for axis in [0, 1]:\n                tgt = mat.sum(axis=axis)\n                res = _mean(mat, axis=axis) * mat.shape[axis]\n                assert_almost_equal(res, tgt)\n            for axis in [None]:\n                tgt = mat.sum(axis=axis)\n                res = _mean(mat, axis=axis) * np.prod(mat.shape)\n                assert_almost_equal(res, tgt)\n\n    def test_var_values(self):\n        for mat in [self.rmat, self.cmat]:\n            for axis in [0, 1, None]:\n                msqr = _mean(mat * mat.conj(), axis=axis)\n                mean = _mean(mat, axis=axis)\n                tgt = msqr - mean * mean.conj()\n                res = _var(mat, axis=axis)\n                assert_almost_equal(res, tgt)\n\n    def test_std_values(self):\n        for mat in [self.rmat, self.cmat]:\n            for axis in [0, 1, None]:\n                tgt = np.sqrt(_var(mat, axis=axis))\n                res = _std(mat, axis=axis)\n                assert_almost_equal(res, tgt)\n\n\n    def test_subclass(self):\n        class TestArray(np.ndarray):\n            def __new__(cls, data, info):\n                result = np.array(data)\n                result = result.view(cls)\n                result.info = info\n                return result\n            def __array_finalize__(self, obj):\n                self.info = getattr(obj, \"info\", '')\n\n        dat = TestArray([[1, 2, 3, 4], [5, 6, 7, 8]], 'jubba')\n        res = dat.mean(1)\n        assert_(res.info == dat.info)\n        res = dat.std(1)\n        assert_(res.info == dat.info)\n        res = dat.var(1)\n        assert_(res.info == dat.info)\n\nclass TestDot(TestCase):\n    def test_dot_2args(self):\n        from numpy.core.multiarray import dot\n\n        a = np.array([[1, 2], [3, 4]], dtype=float)\n        b = np.array([[1, 0], [1, 1]], dtype=float)\n        c = np.array([[3, 2], [7, 4]], dtype=float)\n\n        d = dot(a, b)\n        assert_allclose(c, d)\n\n    def test_dot_3args(self):\n        from numpy.core.multiarray import dot\n\n        np.random.seed(22)\n        f = np.random.random_sample((1024, 16))\n        v = np.random.random_sample((16, 32))\n\n        r = np.empty((1024, 32))\n        for i in range(12):\n            dot(f, v, r)\n        assert_equal(sys.getrefcount(r), 2)\n        r2 = dot(f, v, out=None)\n        assert_array_equal(r2, r)\n        assert_(r is dot(f, v, out=r))\n\n        v = v[:, 0].copy() # v.shape == (16,)\n        r = r[:, 0].copy() # r.shape == (1024,)\n        r2 = dot(f, v)\n        assert_(r is dot(f, v, r))\n        assert_array_equal(r2, r)\n\n    def test_dot_3args_errors(self):\n        from numpy.core.multiarray import dot\n\n        np.random.seed(22)\n        f = np.random.random_sample((1024, 16))\n        v = np.random.random_sample((16, 32))\n\n        r = np.empty((1024, 31))\n        assert_raises(ValueError, dot, f, v, r)\n\n        r = np.empty((1024,))\n        assert_raises(ValueError, dot, f, v, r)\n\n        r = np.empty((32,))\n        assert_raises(ValueError, dot, f, v, r)\n\n        r = np.empty((32, 1024))\n        assert_raises(ValueError, dot, f, v, r)\n        assert_raises(ValueError, dot, f, v, r.T)\n\n        r = np.empty((1024, 64))\n        assert_raises(ValueError, dot, f, v, r[:, ::2])\n        assert_raises(ValueError, dot, f, v, r[:, :32])\n\n        r = np.empty((1024, 32), dtype=np.float32)\n        assert_raises(ValueError, dot, f, v, r)\n\n        r = np.empty((1024, 32), dtype=int)\n        assert_raises(ValueError, dot, f, v, r)\n\n\nclass TestSummarization(TestCase):\n    def test_1d(self):\n        A = np.arange(1001)\n        strA = '[   0    1    2 ...,  998  999 1000]'\n        assert_(str(A) == strA)\n\n        reprA = 'array([   0,    1,    2, ...,  998,  999, 1000])'\n        assert_(repr(A) == reprA)\n\n    def test_2d(self):\n        A = np.arange(1002).reshape(2, 501)\n        strA = '[[   0    1    2 ...,  498  499  500]\\n' \\\n               ' [ 501  502  503 ...,  999 1000 1001]]'\n        assert_(str(A) == strA)\n\n        reprA = 'array([[   0,    1,    2, ...,  498,  499,  500],\\n' \\\n                '       [ 501,  502,  503, ...,  999, 1000, 1001]])'\n        assert_(repr(A) == reprA)\n\n\nclass TestChoose(TestCase):\n    def setUp(self):\n        self.x = 2*ones((3,), dtype=int)\n        self.y = 3*ones((3,), dtype=int)\n        self.x2 = 2*ones((2, 3), dtype=int)\n        self.y2 = 3*ones((2, 3), dtype=int)\n        self.ind = [0, 0, 1]\n\n    def test_basic(self):\n        A = np.choose(self.ind, (self.x, self.y))\n        assert_equal(A, [2, 2, 3])\n\n    def test_broadcast1(self):\n        A = np.choose(self.ind, (self.x2, self.y2))\n        assert_equal(A, [[2, 2, 3], [2, 2, 3]])\n\n    def test_broadcast2(self):\n        A = np.choose(self.ind, (self.x, self.y2))\n        assert_equal(A, [[2, 2, 3], [2, 2, 3]])\n\ndef can_use_decimal():\n    try:\n        from decimal import Decimal\n        return True\n    except ImportError:\n        return False\n\n# TODO: test for multidimensional\nNEIGH_MODE = {'zero': 0, 'one': 1, 'constant': 2, 'circular': 3, 'mirror': 4}\nclass TestNeighborhoodIter(TestCase):\n    # Simple, 2d tests\n    def _test_simple2d(self, dt):\n        # Test zero and one padding for simple data type\n        x = np.array([[0, 1], [2, 3]], dtype=dt)\n        r = [np.array([[0, 0, 0], [0, 0, 1]], dtype=dt),\n             np.array([[0, 0, 0], [0, 1, 0]], dtype=dt),\n             np.array([[0, 0, 1], [0, 2, 3]], dtype=dt),\n             np.array([[0, 1, 0], [2, 3, 0]], dtype=dt)]\n        l = test_neighborhood_iterator(x, [-1, 0, -1, 1], x[0],\n                NEIGH_MODE['zero'])\n        assert_array_equal(l, r)\n\n        r = [np.array([[1, 1, 1], [1, 0, 1]], dtype=dt),\n             np.array([[1, 1, 1], [0, 1, 1]], dtype=dt),\n             np.array([[1, 0, 1], [1, 2, 3]], dtype=dt),\n             np.array([[0, 1, 1], [2, 3, 1]], dtype=dt)]\n        l = test_neighborhood_iterator(x, [-1, 0, -1, 1], x[0],\n                NEIGH_MODE['one'])\n        assert_array_equal(l, r)\n\n        r = [np.array([[4, 4, 4], [4, 0, 1]], dtype=dt),\n             np.array([[4, 4, 4], [0, 1, 4]], dtype=dt),\n             np.array([[4, 0, 1], [4, 2, 3]], dtype=dt),\n             np.array([[0, 1, 4], [2, 3, 4]], dtype=dt)]\n        l = test_neighborhood_iterator(x, [-1, 0, -1, 1], 4,\n                NEIGH_MODE['constant'])\n        assert_array_equal(l, r)\n\n    def test_simple2d(self):\n        self._test_simple2d(np.float)\n\n    @dec.skipif(not can_use_decimal(),\n            \"Skip neighborhood iterator tests for decimal objects \" \\\n            \"(decimal module not available\")\n    def test_simple2d_object(self):\n        from decimal import Decimal\n        self._test_simple2d(Decimal)\n\n    def _test_mirror2d(self, dt):\n        x = np.array([[0, 1], [2, 3]], dtype=dt)\n        r = [np.array([[0, 0, 1], [0, 0, 1]], dtype=dt),\n             np.array([[0, 1, 1], [0, 1, 1]], dtype=dt),\n             np.array([[0, 0, 1], [2, 2, 3]], dtype=dt),\n             np.array([[0, 1, 1], [2, 3, 3]], dtype=dt)]\n        l = test_neighborhood_iterator(x, [-1, 0, -1, 1], x[0],\n                NEIGH_MODE['mirror'])\n        assert_array_equal(l, r)\n\n    def test_mirror2d(self):\n        self._test_mirror2d(np.float)\n\n    @dec.skipif(not can_use_decimal(),\n            \"Skip neighborhood iterator tests for decimal objects \" \\\n            \"(decimal module not available\")\n    def test_mirror2d_object(self):\n        from decimal import Decimal\n        self._test_mirror2d(Decimal)\n\n    # Simple, 1d tests\n    def _test_simple(self, dt):\n        # Test padding with constant values\n        x = np.linspace(1, 5, 5).astype(dt)\n        r = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 0]]\n        l = test_neighborhood_iterator(x, [-1, 1], x[0], NEIGH_MODE['zero'])\n        assert_array_equal(l, r)\n\n        r = [[1, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 1]]\n        l = test_neighborhood_iterator(x, [-1, 1], x[0], NEIGH_MODE['one'])\n        assert_array_equal(l, r)\n\n        r = [[x[4], 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, x[4]]]\n        l = test_neighborhood_iterator(x, [-1, 1], x[4], NEIGH_MODE['constant'])\n        assert_array_equal(l, r)\n\n    def test_simple_float(self):\n        self._test_simple(np.float)\n\n    @dec.skipif(not can_use_decimal(),\n            \"Skip neighborhood iterator tests for decimal objects \" \\\n            \"(decimal module not available\")\n    def test_simple_object(self):\n        from decimal import Decimal\n        self._test_simple(Decimal)\n\n    # Test mirror modes\n    def _test_mirror(self, dt):\n        x = np.linspace(1, 5, 5).astype(dt)\n        r = np.array([[2, 1, 1, 2, 3], [1, 1, 2, 3, 4], [1, 2, 3, 4, 5],\n                [2, 3, 4, 5, 5], [3, 4, 5, 5, 4]], dtype=dt)\n        l = test_neighborhood_iterator(x, [-2, 2], x[1], NEIGH_MODE['mirror'])\n        self.assertTrue([i.dtype == dt for i in l])\n        assert_array_equal(l, r)\n\n    def test_mirror(self):\n        self._test_mirror(np.float)\n\n    @dec.skipif(not can_use_decimal(),\n            \"Skip neighborhood iterator tests for decimal objects \" \\\n            \"(decimal module not available\")\n    def test_mirror_object(self):\n        from decimal import Decimal\n        self._test_mirror(Decimal)\n\n    # Circular mode\n    def _test_circular(self, dt):\n        x = np.linspace(1, 5, 5).astype(dt)\n        r = np.array([[4, 5, 1, 2, 3], [5, 1, 2, 3, 4], [1, 2, 3, 4, 5],\n                [2, 3, 4, 5, 1], [3, 4, 5, 1, 2]], dtype=dt)\n        l = test_neighborhood_iterator(x, [-2, 2], x[0], NEIGH_MODE['circular'])\n        assert_array_equal(l, r)\n\n    def test_circular(self):\n        self._test_circular(np.float)\n\n    @dec.skipif(not can_use_decimal(),\n            \"Skip neighborhood iterator tests for decimal objects \" \\\n            \"(decimal module not available\")\n    def test_circular_object(self):\n        from decimal import Decimal\n        self._test_circular(Decimal)\n\n# Test stacking neighborhood iterators\nclass TestStackedNeighborhoodIter(TestCase):\n    # Simple, 1d test: stacking 2 constant-padded neigh iterators\n    def test_simple_const(self):\n        dt = np.float64\n        # Test zero and one padding for simple data type\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([0], dtype=dt),\n             np.array([0], dtype=dt),\n             np.array([1], dtype=dt),\n             np.array([2], dtype=dt),\n             np.array([3], dtype=dt),\n             np.array([0], dtype=dt),\n             np.array([0], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-2, 4], NEIGH_MODE['zero'],\n                [0, 0], NEIGH_MODE['zero'])\n        assert_array_equal(l, r)\n\n        r = [np.array([1, 0, 1], dtype=dt),\n             np.array([0, 1, 2], dtype=dt),\n             np.array([1, 2, 3], dtype=dt),\n             np.array([2, 3, 0], dtype=dt),\n             np.array([3, 0, 1], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n                [-1, 1], NEIGH_MODE['one'])\n        assert_array_equal(l, r)\n\n    # 2nd simple, 1d test: stacking 2 neigh iterators, mixing const padding and\n    # mirror padding\n    def test_simple_mirror(self):\n        dt = np.float64\n        # Stacking zero on top of mirror\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([0, 1, 1], dtype=dt),\n             np.array([1, 1, 2], dtype=dt),\n             np.array([1, 2, 3], dtype=dt),\n             np.array([2, 3, 3], dtype=dt),\n             np.array([3, 3, 0], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['mirror'],\n                [-1, 1], NEIGH_MODE['zero'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([1, 0, 0], dtype=dt),\n             np.array([0, 0, 1], dtype=dt),\n             np.array([0, 1, 2], dtype=dt),\n             np.array([1, 2, 3], dtype=dt),\n             np.array([2, 3, 0], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n                [-2, 0], NEIGH_MODE['mirror'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero: 2nd\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([0, 1, 2], dtype=dt),\n             np.array([1, 2, 3], dtype=dt),\n             np.array([2, 3, 0], dtype=dt),\n             np.array([3, 0, 0], dtype=dt),\n             np.array([0, 0, 3], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n                [0, 2], NEIGH_MODE['mirror'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero: 3rd\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([1, 0, 0, 1, 2], dtype=dt),\n             np.array([0, 0, 1, 2, 3], dtype=dt),\n             np.array([0, 1, 2, 3, 0], dtype=dt),\n             np.array([1, 2, 3, 0, 0], dtype=dt),\n             np.array([2, 3, 0, 0, 3], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n                [-2, 2], NEIGH_MODE['mirror'])\n        assert_array_equal(l, r)\n\n    # 3rd simple, 1d test: stacking 2 neigh iterators, mixing const padding and\n    # circular padding\n    def test_simple_circular(self):\n        dt = np.float64\n        # Stacking zero on top of mirror\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([0, 3, 1], dtype=dt),\n             np.array([3, 1, 2], dtype=dt),\n             np.array([1, 2, 3], dtype=dt),\n             np.array([2, 3, 1], dtype=dt),\n             np.array([3, 1, 0], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['circular'],\n                [-1, 1], NEIGH_MODE['zero'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([3, 0, 0], dtype=dt),\n             np.array([0, 0, 1], dtype=dt),\n             np.array([0, 1, 2], dtype=dt),\n             np.array([1, 2, 3], dtype=dt),\n             np.array([2, 3, 0], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n                [-2, 0], NEIGH_MODE['circular'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero: 2nd\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([0, 1, 2], dtype=dt),\n             np.array([1, 2, 3], dtype=dt),\n             np.array([2, 3, 0], dtype=dt),\n             np.array([3, 0, 0], dtype=dt),\n             np.array([0, 0, 1], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n                [0, 2], NEIGH_MODE['circular'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero: 3rd\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([3, 0, 0, 1, 2], dtype=dt),\n             np.array([0, 0, 1, 2, 3], dtype=dt),\n             np.array([0, 1, 2, 3, 0], dtype=dt),\n             np.array([1, 2, 3, 0, 0], dtype=dt),\n             np.array([2, 3, 0, 0, 1], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n                [-2, 2], NEIGH_MODE['circular'])\n        assert_array_equal(l, r)\n\n    # 4th simple, 1d test: stacking 2 neigh iterators, but with lower iterator\n    # being strictly within the array\n    def test_simple_strict_within(self):\n        dt = np.float64\n        # Stacking zero on top of zero, first neighborhood strictly inside the\n        # array\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([1, 2, 3, 0], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [1, 1], NEIGH_MODE['zero'],\n                [-1, 2], NEIGH_MODE['zero'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero, first neighborhood strictly inside the\n        # array\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([1, 2, 3, 3], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [1, 1], NEIGH_MODE['zero'],\n                [-1, 2], NEIGH_MODE['mirror'])\n        assert_array_equal(l, r)\n\n        # Stacking mirror on top of zero, first neighborhood strictly inside the\n        # array\n        x = np.array([1, 2, 3], dtype=dt)\n        r = [np.array([1, 2, 3, 1], dtype=dt)]\n        l = test_neighborhood_iterator_oob(x, [1, 1], NEIGH_MODE['zero'],\n                [-1, 2], NEIGH_MODE['circular'])\n        assert_array_equal(l, r)\n\nclass TestWarnings(object):\n\n    def test_complex_warning(self):\n        x = np.array([1, 2])\n        y = np.array([1-2j, 1+2j])\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"error\", np.ComplexWarning)\n            assert_raises(np.ComplexWarning, x.__setitem__, slice(None), y)\n            assert_equal(x, [1, 2])\n\nclass TestMinScalarType(object):\n\n    def test_usigned_shortshort(self):\n        dt = np.min_scalar_type(2**8-1)\n        wanted = np.dtype('uint8')\n        assert_equal(wanted, dt)\n\n    def test_usigned_short(self):\n        dt = np.min_scalar_type(2**16-1)\n        wanted = np.dtype('uint16')\n        assert_equal(wanted, dt)\n\n    def test_usigned_int(self):\n        dt = np.min_scalar_type(2**32-1)\n        wanted = np.dtype('uint32')\n        assert_equal(wanted, dt)\n\n    def test_usigned_longlong(self):\n        dt = np.min_scalar_type(2**63-1)\n        wanted = np.dtype('uint64')\n        assert_equal(wanted, dt)\n\n    def test_object(self):\n        dt = np.min_scalar_type(2**64)\n        wanted = np.dtype('O')\n        assert_equal(wanted, dt)\n\n\nif sys.version_info[:2] == (2, 6):\n    from numpy.core.multiarray import memorysimpleview as memoryview\n\nfrom numpy.core._internal import _dtype_from_pep3118\n\nclass TestPEP3118Dtype(object):\n    def _check(self, spec, wanted):\n        dt = np.dtype(wanted)\n        if isinstance(wanted, list) and isinstance(wanted[-1], tuple):\n            if wanted[-1][0] == '':\n                names = list(dt.names)\n                names[-1] = ''\n                dt.names = tuple(names)\n        assert_equal(_dtype_from_pep3118(spec), dt,\n                     err_msg=\"spec %r != dtype %r\" % (spec, wanted))\n\n    def test_native_padding(self):\n        align = np.dtype('i').alignment\n        for j in range(8):\n            if j == 0:\n                s = 'bi'\n            else:\n                s = 'b%dxi' % j\n            self._check('@'+s, {'f0': ('i1', 0),\n                                'f1': ('i', align*(1 + j//align))})\n            self._check('='+s, {'f0': ('i1', 0),\n                                'f1': ('i', 1+j)})\n\n    def test_native_padding_2(self):\n        # Native padding should work also for structs and sub-arrays\n        self._check('x3T{xi}', {'f0': (({'f0': ('i', 4)}, (3,)), 4)})\n        self._check('^x3T{xi}', {'f0': (({'f0': ('i', 1)}, (3,)), 1)})\n\n    def test_trailing_padding(self):\n        # Trailing padding should be included, *and*, the item size\n        # should match the alignment if in aligned mode\n        align = np.dtype('i').alignment\n        def VV(n):\n            return 'V%d' % (align*(1 + (n-1)//align))\n\n        self._check('ix', [('f0', 'i'), ('', VV(1))])\n        self._check('ixx', [('f0', 'i'), ('', VV(2))])\n        self._check('ixxx', [('f0', 'i'), ('', VV(3))])\n        self._check('ixxxx', [('f0', 'i'), ('', VV(4))])\n        self._check('i7x', [('f0', 'i'), ('', VV(7))])\n\n        self._check('^ix', [('f0', 'i'), ('', 'V1')])\n        self._check('^ixx', [('f0', 'i'), ('', 'V2')])\n        self._check('^ixxx', [('f0', 'i'), ('', 'V3')])\n        self._check('^ixxxx', [('f0', 'i'), ('', 'V4')])\n        self._check('^i7x', [('f0', 'i'), ('', 'V7')])\n\n    def test_native_padding_3(self):\n        dt = np.dtype(\n                [('a', 'b'), ('b', 'i'),\n                    ('sub', np.dtype('b,i')), ('c', 'i')],\n                align=True)\n        self._check(\"T{b:a:xxxi:b:T{b:f0:=i:f1:}:sub:xxxi:c:}\", dt)\n\n        dt = np.dtype(\n                [('a', 'b'), ('b', 'i'), ('c', 'b'), ('d', 'b'),\n                    ('e', 'b'), ('sub', np.dtype('b,i', align=True))])\n        self._check(\"T{b:a:=i:b:b:c:b:d:b:e:T{b:f0:xxxi:f1:}:sub:}\", dt)\n\n    def test_padding_with_array_inside_struct(self):\n        dt = np.dtype(\n                [('a', 'b'), ('b', 'i'), ('c', 'b', (3,)),\n                    ('d', 'i')],\n                align=True)\n        self._check(\"T{b:a:xxxi:b:3b:c:xi:d:}\", dt)\n\n    def test_byteorder_inside_struct(self):\n        # The byte order after @T{=i} should be '=', not '@'.\n        # Check this by noting the absence of native alignment.\n        self._check('@T{^i}xi', {'f0': ({'f0': ('i', 0)}, 0),\n                                 'f1': ('i', 5)})\n\n    def test_intra_padding(self):\n        # Natively aligned sub-arrays may require some internal padding\n        align = np.dtype('i').alignment\n        def VV(n):\n            return 'V%d' % (align*(1 + (n-1)//align))\n\n        self._check('(3)T{ix}', ({'f0': ('i', 0), '': (VV(1), 4)}, (3,)))\n\nclass TestNewBufferProtocol(object):\n    def _check_roundtrip(self, obj):\n        obj = np.asarray(obj)\n        x = memoryview(obj)\n        y = np.asarray(x)\n        y2 = np.array(x)\n        assert_(not y.flags.owndata)\n        assert_(y2.flags.owndata)\n\n        assert_equal(y.dtype, obj.dtype)\n        assert_equal(y.shape, obj.shape)\n        assert_array_equal(obj, y)\n\n        assert_equal(y2.dtype, obj.dtype)\n        assert_equal(y2.shape, obj.shape)\n        assert_array_equal(obj, y2)\n\n    def test_roundtrip(self):\n        x = np.array([1, 2, 3, 4, 5], dtype='i4')\n        self._check_roundtrip(x)\n\n        x = np.array([[1, 2], [3, 4]], dtype=np.float64)\n        self._check_roundtrip(x)\n\n        x = np.zeros((3, 3, 3), dtype=np.float32)[:, 0,:]\n        self._check_roundtrip(x)\n\n        dt = [('a', 'b'),\n              ('b', 'h'),\n              ('c', 'i'),\n              ('d', 'l'),\n              ('dx', 'q'),\n              ('e', 'B'),\n              ('f', 'H'),\n              ('g', 'I'),\n              ('h', 'L'),\n              ('hx', 'Q'),\n              ('i', np.single),\n              ('j', np.double),\n              ('k', np.longdouble),\n              ('ix', np.csingle),\n              ('jx', np.cdouble),\n              ('kx', np.clongdouble),\n              ('l', 'S4'),\n              ('m', 'U4'),\n              ('n', 'V3'),\n              ('o', '?'),\n              ('p', np.half),\n             ]\n        x = np.array(\n                [(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                    asbytes('aaaa'), 'bbbb', asbytes('xxx'), True, 1.0)],\n                dtype=dt)\n        self._check_roundtrip(x)\n\n        x = np.array(([[1, 2], [3, 4]],), dtype=[('a', (int, (2, 2)))])\n        self._check_roundtrip(x)\n\n        x = np.array([1, 2, 3], dtype='>i2')\n        self._check_roundtrip(x)\n\n        x = np.array([1, 2, 3], dtype='<i2')\n        self._check_roundtrip(x)\n\n        x = np.array([1, 2, 3], dtype='>i4')\n        self._check_roundtrip(x)\n\n        x = np.array([1, 2, 3], dtype='<i4')\n        self._check_roundtrip(x)\n\n        # check long long can be represented as non-native\n        x = np.array([1, 2, 3], dtype='>q')\n        self._check_roundtrip(x)\n\n        # Native-only data types can be passed through the buffer interface\n        # only in native byte order\n        if sys.byteorder == 'little':\n            x = np.array([1, 2, 3], dtype='>g')\n            assert_raises(ValueError, self._check_roundtrip, x)\n            x = np.array([1, 2, 3], dtype='<g')\n            self._check_roundtrip(x)\n        else:\n            x = np.array([1, 2, 3], dtype='>g')\n            self._check_roundtrip(x)\n            x = np.array([1, 2, 3], dtype='<g')\n            assert_raises(ValueError, self._check_roundtrip, x)\n\n    def test_roundtrip_half(self):\n        half_list = [\n            1.0,\n            -2.0,\n            6.5504 * 10**4, #  (max half precision)\n            2**-14, # ~= 6.10352 * 10**-5 (minimum positive normal)\n            2**-24, # ~= 5.96046 * 10**-8 (minimum strictly positive subnormal)\n            0.0,\n            -0.0,\n            float('+inf'),\n            float('-inf'),\n            0.333251953125, # ~= 1/3\n        ]\n\n        x = np.array(half_list, dtype='>e')\n        self._check_roundtrip(x)\n        x = np.array(half_list, dtype='<e')\n        self._check_roundtrip(x)\n\n    def test_roundtrip_single_types(self):\n        for typ in np.typeDict.values():\n            dtype = np.dtype(typ)\n\n            if dtype.char in 'Mm':\n                # datetimes cannot be used in buffers\n                continue\n            if dtype.char == 'V':\n                # skip void\n                continue\n\n            x = np.zeros(4, dtype=dtype)\n            self._check_roundtrip(x)\n\n            if dtype.char not in 'qQgG':\n                dt = dtype.newbyteorder('<')\n                x = np.zeros(4, dtype=dt)\n                self._check_roundtrip(x)\n\n                dt = dtype.newbyteorder('>')\n                x = np.zeros(4, dtype=dt)\n                self._check_roundtrip(x)\n\n    def test_roundtrip_scalar(self):\n        # Issue #4015.\n        self._check_roundtrip(0)\n\n    def test_export_simple_1d(self):\n        x = np.array([1, 2, 3, 4, 5], dtype='i')\n        y = memoryview(x)\n        assert_equal(y.format, 'i')\n        assert_equal(y.shape, (5,))\n        assert_equal(y.ndim, 1)\n        assert_equal(y.strides, (4,))\n        assert_equal(y.suboffsets, EMPTY)\n        assert_equal(y.itemsize, 4)\n\n    def test_export_simple_nd(self):\n        x = np.array([[1, 2], [3, 4]], dtype=np.float64)\n        y = memoryview(x)\n        assert_equal(y.format, 'd')\n        assert_equal(y.shape, (2, 2))\n        assert_equal(y.ndim, 2)\n        assert_equal(y.strides, (16, 8))\n        assert_equal(y.suboffsets, EMPTY)\n        assert_equal(y.itemsize, 8)\n\n    def test_export_discontiguous(self):\n        x = np.zeros((3, 3, 3), dtype=np.float32)[:, 0,:]\n        y = memoryview(x)\n        assert_equal(y.format, 'f')\n        assert_equal(y.shape, (3, 3))\n        assert_equal(y.ndim, 2)\n        assert_equal(y.strides, (36, 4))\n        assert_equal(y.suboffsets, EMPTY)\n        assert_equal(y.itemsize, 4)\n\n    def test_export_record(self):\n        dt = [('a', 'b'),\n              ('b', 'h'),\n              ('c', 'i'),\n              ('d', 'l'),\n              ('dx', 'q'),\n              ('e', 'B'),\n              ('f', 'H'),\n              ('g', 'I'),\n              ('h', 'L'),\n              ('hx', 'Q'),\n              ('i', np.single),\n              ('j', np.double),\n              ('k', np.longdouble),\n              ('ix', np.csingle),\n              ('jx', np.cdouble),\n              ('kx', np.clongdouble),\n              ('l', 'S4'),\n              ('m', 'U4'),\n              ('n', 'V3'),\n              ('o', '?'),\n              ('p', np.half),\n             ]\n        x = np.array(\n                [(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                    asbytes('aaaa'), 'bbbb', asbytes('   '), True, 1.0)],\n                dtype=dt)\n        y = memoryview(x)\n        assert_equal(y.shape, (1,))\n        assert_equal(y.ndim, 1)\n        assert_equal(y.suboffsets, EMPTY)\n\n        sz = sum([dtype(b).itemsize for a, b in dt])\n        if dtype('l').itemsize == 4:\n            assert_equal(y.format, 'T{b:a:=h:b:i:c:l:d:q:dx:B:e:@H:f:=I:g:L:h:Q:hx:f:i:d:j:^g:k:=Zf:ix:Zd:jx:^Zg:kx:4s:l:=4w:m:3x:n:?:o:@e:p:}')\n        else:\n            assert_equal(y.format, 'T{b:a:=h:b:i:c:q:d:q:dx:B:e:@H:f:=I:g:Q:h:Q:hx:f:i:d:j:^g:k:=Zf:ix:Zd:jx:^Zg:kx:4s:l:=4w:m:3x:n:?:o:@e:p:}')\n        # Cannot test if NPY_RELAXED_STRIDES_CHECKING changes the strides\n        if not (np.ones(1).strides[0] == np.iinfo(np.intp).max):\n            assert_equal(y.strides, (sz,))\n        assert_equal(y.itemsize, sz)\n\n    def test_export_subarray(self):\n        x = np.array(([[1, 2], [3, 4]],), dtype=[('a', ('i', (2, 2)))])\n        y = memoryview(x)\n        assert_equal(y.format, 'T{(2,2)i:a:}')\n        assert_equal(y.shape, EMPTY)\n        assert_equal(y.ndim, 0)\n        assert_equal(y.strides, EMPTY)\n        assert_equal(y.suboffsets, EMPTY)\n        assert_equal(y.itemsize, 16)\n\n    def test_export_endian(self):\n        x = np.array([1, 2, 3], dtype='>i')\n        y = memoryview(x)\n        if sys.byteorder == 'little':\n            assert_equal(y.format, '>i')\n        else:\n            assert_equal(y.format, 'i')\n\n        x = np.array([1, 2, 3], dtype='<i')\n        y = memoryview(x)\n        if sys.byteorder == 'little':\n            assert_equal(y.format, 'i')\n        else:\n            assert_equal(y.format, '<i')\n\n    def test_export_flags(self):\n        # Check SIMPLE flag, see also gh-3613 (exception should be BufferError)\n        assert_raises(ValueError, get_buffer_info, np.arange(5)[::2], ('SIMPLE',))\n\n    def test_padding(self):\n        for j in range(8):\n            x = np.array([(1,), (2,)], dtype={'f0': (int, j)})\n            self._check_roundtrip(x)\n\n    def test_reference_leak(self):\n        count_1 = sys.getrefcount(np.core._internal)\n        a = np.zeros(4)\n        b = memoryview(a)\n        c = np.asarray(b)\n        count_2 = sys.getrefcount(np.core._internal)\n        assert_equal(count_1, count_2)\n\n    def test_padded_struct_array(self):\n        dt1 = np.dtype(\n                [('a', 'b'), ('b', 'i'), ('sub', np.dtype('b,i')), ('c', 'i')],\n                align=True)\n        x1 = np.arange(dt1.itemsize, dtype=np.int8).view(dt1)\n        self._check_roundtrip(x1)\n\n        dt2 = np.dtype(\n                [('a', 'b'), ('b', 'i'), ('c', 'b', (3,)), ('d', 'i')],\n                align=True)\n        x2 = np.arange(dt2.itemsize, dtype=np.int8).view(dt2)\n        self._check_roundtrip(x2)\n\n        dt3 = np.dtype(\n                [('a', 'b'), ('b', 'i'), ('c', 'b'), ('d', 'b'),\n                    ('e', 'b'), ('sub', np.dtype('b,i', align=True))])\n        x3 = np.arange(dt3.itemsize, dtype=np.int8).view(dt3)\n        self._check_roundtrip(x3)\n\n\nclass TestArrayAttributeDeletion(object):\n\n    def test_multiarray_writable_attributes_deletion(self):\n        \"\"\"ticket #2046, should not seqfault, raise AttributeError\"\"\"\n        a = np.ones(2)\n        attr =  ['shape', 'strides', 'data', 'dtype', 'real', 'imag', 'flat']\n        for s in attr:\n            assert_raises(AttributeError, delattr, a, s)\n\n\n    def test_multiarray_not_writable_attributes_deletion(self):\n        a = np.ones(2)\n        attr = [\"ndim\", \"flags\", \"itemsize\", \"size\", \"nbytes\", \"base\",\n                \"ctypes\", \"T\", \"__array_interface__\", \"__array_struct__\",\n                \"__array_priority__\", \"__array_finalize__\"]\n        for s in attr:\n            assert_raises(AttributeError, delattr, a, s)\n\n\n    def test_multiarray_flags_writable_attribute_deletion(self):\n        a = np.ones(2).flags\n        attr = ['updateifcopy', 'aligned', 'writeable']\n        for s in attr:\n            assert_raises(AttributeError, delattr, a, s)\n\n\n    def test_multiarray_flags_not_writable_attribute_deletion(self):\n        a = np.ones(2).flags\n        attr = [\"contiguous\", \"c_contiguous\", \"f_contiguous\", \"fortran\",\n                \"owndata\", \"fnc\", \"forc\", \"behaved\", \"carray\", \"farray\",\n                \"num\"]\n        for s in attr:\n            assert_raises(AttributeError, delattr, a, s)\n\n\ndef test_array_interface():\n    # Test scalar coercion within the array interface\n    class Foo(object):\n        def __init__(self, value):\n            self.value = value\n            self.iface = {'typestr' : '=f8'}\n        def __float__(self):\n            return float(self.value)\n        @property\n        def __array_interface__(self):\n            return self.iface\n    f = Foo(0.5)\n    assert_equal(np.array(f), 0.5)\n    assert_equal(np.array([f]), [0.5])\n    assert_equal(np.array([f, f]), [0.5, 0.5])\n    assert_equal(np.array(f).dtype, np.dtype('=f8'))\n    # Test various shape definitions\n    f.iface['shape'] = ()\n    assert_equal(np.array(f), 0.5)\n    f.iface['shape'] = None\n    assert_raises(TypeError, np.array, f)\n    f.iface['shape'] = (1, 1)\n    assert_equal(np.array(f), [[0.5]])\n    f.iface['shape'] = (2,)\n    assert_raises(ValueError, np.array, f)\n\n    # test scalar with no shape\n    class ArrayLike(object):\n        array = np.array(1)\n        __array_interface__ = array.__array_interface__\n    assert_equal(np.array(ArrayLike()), 1)\n\n\ndef test_flat_element_deletion():\n    it = np.ones(3).flat\n    try:\n        del it[1]\n        del it[1:2]\n    except TypeError:\n        pass\n    except:\n        raise AssertionError\n\ndef test_scalar_element_deletion():\n    a = np.zeros(2, dtype=[('x', 'int'), ('y', 'int')])\n    assert_raises(ValueError, a[0].__delitem__, 'x')\n\nclass TestMemEventHook(TestCase):\n    def test_mem_seteventhook(self):\n        # The actual tests are within the C code in\n        # multiarray/multiarray_tests.c.src\n        test_pydatamem_seteventhook_start()\n        # force an allocation and free of a numpy array\n        a = np.zeros(10)\n        del a\n        test_pydatamem_seteventhook_end()\n\nclass TestMapIter(TestCase):\n    def test_mapiter(self):\n        # The actual tests are within the C code in\n        # multiarray/multiarray_tests.c.src\n\n        a = arange(12).reshape((3, 4)).astype(float)\n        index = ([1, 1, 2, 0],\n                 [0, 0, 2, 3])\n        vals = [50, 50, 30, 16]\n\n        test_inplace_increment(a, index, vals)\n        assert_equal(a, [[   0.,   1.,    2.,   19.,],\n                         [ 104.,    5.,    6.,    7.,],\n                         [   8.,    9.,   40.,   11.,]])\n\n        b = arange(6).astype(float)\n        index = (array([1, 2, 0]),)\n        vals = [50, 4, 100.1]\n        test_inplace_increment(b, index, vals)\n        assert_equal(b, [ 100.1,  51.,   6.,   3.,   4.,   5. ])\n\n\nclass PriorityNdarray():\n    __array_priority__ = 1000\n\n    def __init__(self, array):\n        self.array = array\n\n    def __lt__(self, array):\n        if isinstance(array, PriorityNdarray):\n            array = array.array\n        return PriorityNdarray(self.array < array)\n\n    def __gt__(self, array):\n        if isinstance(array, PriorityNdarray):\n            array = array.array\n        return PriorityNdarray(self.array > array)\n\n    def __le__(self, array):\n        if isinstance(array, PriorityNdarray):\n            array = array.array\n        return PriorityNdarray(self.array <= array)\n\n    def __ge__(self, array):\n        if isinstance(array, PriorityNdarray):\n            array = array.array\n        return PriorityNdarray(self.array >= array)\n\n    def __eq__(self, array):\n        if isinstance(array, PriorityNdarray):\n            array = array.array\n        return PriorityNdarray(self.array == array)\n\n    def __ne__(self, array):\n        if isinstance(array, PriorityNdarray):\n            array = array.array\n        return PriorityNdarray(self.array != array)\n\n\nclass TestArrayPriority(TestCase):\n    def test_lt(self):\n        l = np.asarray([0., -1., 1.], dtype=dtype)\n        r = np.asarray([0., 1., -1.], dtype=dtype)\n        lp = PriorityNdarray(l)\n        rp = PriorityNdarray(r)\n        res1 = l < r\n        res2 = l < rp\n        res3 = lp < r\n        res4 = lp < rp\n\n        assert_array_equal(res1, res2.array)\n        assert_array_equal(res1, res3.array)\n        assert_array_equal(res1, res4.array)\n        assert_(isinstance(res1, np.ndarray))\n        assert_(isinstance(res2, PriorityNdarray))\n        assert_(isinstance(res3, PriorityNdarray))\n        assert_(isinstance(res4, PriorityNdarray))\n\n    def test_gt(self):\n        l = np.asarray([0., -1., 1.], dtype=dtype)\n        r = np.asarray([0., 1., -1.], dtype=dtype)\n        lp = PriorityNdarray(l)\n        rp = PriorityNdarray(r)\n        res1 = l > r\n        res2 = l > rp\n        res3 = lp > r\n        res4 = lp > rp\n\n        assert_array_equal(res1, res2.array)\n        assert_array_equal(res1, res3.array)\n        assert_array_equal(res1, res4.array)\n        assert_(isinstance(res1, np.ndarray))\n        assert_(isinstance(res2, PriorityNdarray))\n        assert_(isinstance(res3, PriorityNdarray))\n        assert_(isinstance(res4, PriorityNdarray))\n\n    def test_le(self):\n        l = np.asarray([0., -1., 1.], dtype=dtype)\n        r = np.asarray([0., 1., -1.], dtype=dtype)\n        lp = PriorityNdarray(l)\n        rp = PriorityNdarray(r)\n        res1 = l <= r\n        res2 = l <= rp\n        res3 = lp <= r\n        res4 = lp <= rp\n\n        assert_array_equal(res1, res2.array)\n        assert_array_equal(res1, res3.array)\n        assert_array_equal(res1, res4.array)\n        assert_(isinstance(res1, np.ndarray))\n        assert_(isinstance(res2, PriorityNdarray))\n        assert_(isinstance(res3, PriorityNdarray))\n        assert_(isinstance(res4, PriorityNdarray))\n\n    def test_ge(self):\n        l = np.asarray([0., -1., 1.], dtype=dtype)\n        r = np.asarray([0., 1., -1.], dtype=dtype)\n        lp = PriorityNdarray(l)\n        rp = PriorityNdarray(r)\n        res1 = l >= r\n        res2 = l >= rp\n        res3 = lp >= r\n        res4 = lp >= rp\n\n        assert_array_equal(res1, res2.array)\n        assert_array_equal(res1, res3.array)\n        assert_array_equal(res1, res4.array)\n        assert_(isinstance(res1, np.ndarray))\n        assert_(isinstance(res2, PriorityNdarray))\n        assert_(isinstance(res3, PriorityNdarray))\n        assert_(isinstance(res4, PriorityNdarray))\n\n    def test_eq(self):\n        l = np.asarray([0., -1., 1.], dtype=dtype)\n        r = np.asarray([0., 1., -1.], dtype=dtype)\n        lp = PriorityNdarray(l)\n        rp = PriorityNdarray(r)\n        res1 = l == r\n        res2 = l == rp\n        res3 = lp == r\n        res4 = lp == rp\n\n        assert_array_equal(res1, res2.array)\n        assert_array_equal(res1, res3.array)\n        assert_array_equal(res1, res4.array)\n        assert_(isinstance(res1, np.ndarray))\n        assert_(isinstance(res2, PriorityNdarray))\n        assert_(isinstance(res3, PriorityNdarray))\n        assert_(isinstance(res4, PriorityNdarray))\n\n    def test_ne(self):\n        l = np.asarray([0., -1., 1.], dtype=dtype)\n        r = np.asarray([0., 1., -1.], dtype=dtype)\n        lp = PriorityNdarray(l)\n        rp = PriorityNdarray(r)\n        res1 = l != r\n        res2 = l != rp\n        res3 = lp != r\n        res4 = lp != rp\n\n        assert_array_equal(res1, res2.array)\n        assert_array_equal(res1, res3.array)\n        assert_array_equal(res1, res4.array)\n        assert_(isinstance(res1, np.ndarray))\n        assert_(isinstance(res2, PriorityNdarray))\n        assert_(isinstance(res3, PriorityNdarray))\n        assert_(isinstance(res4, PriorityNdarray))\n\n\nclass TestConversion(TestCase):\n    def test_array_scalar_relational_operation(self):\n        #All integer\n        for dt1 in np.typecodes['AllInteger']:\n            assert_(1 > np.array(0, dtype=dt1), \"type %s failed\" % (dt1,))\n            assert_(not 1 < np.array(0, dtype=dt1), \"type %s failed\" % (dt1,))\n\n            for dt2 in np.typecodes['AllInteger']:\n                assert_(np.array(1, dtype=dt1) > np.array(0, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n                assert_(not np.array(1, dtype=dt1) < np.array(0, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n\n        #Unsigned integers\n        for dt1 in 'BHILQP':\n            assert_(-1 < np.array(1, dtype=dt1), \"type %s failed\" % (dt1,))\n            assert_(not -1 > np.array(1, dtype=dt1), \"type %s failed\" % (dt1,))\n            assert_(-1 != np.array(1, dtype=dt1), \"type %s failed\" % (dt1,))\n\n            #unsigned vs signed\n            for dt2 in 'bhilqp':\n                assert_(np.array(1, dtype=dt1) > np.array(-1, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n                assert_(not np.array(1, dtype=dt1) < np.array(-1, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n                assert_(np.array(1, dtype=dt1) != np.array(-1, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n\n        #Signed integers and floats\n        for dt1 in 'bhlqp' + np.typecodes['Float']:\n            assert_(1 > np.array(-1, dtype=dt1), \"type %s failed\" % (dt1,))\n            assert_(not 1 < np.array(-1, dtype=dt1), \"type %s failed\" % (dt1,))\n            assert_(-1 == np.array(-1, dtype=dt1), \"type %s failed\" % (dt1,))\n\n            for dt2 in 'bhlqp' + np.typecodes['Float']:\n                assert_(np.array(1, dtype=dt1) > np.array(-1, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n                assert_(not np.array(1, dtype=dt1) < np.array(-1, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n                assert_(np.array(-1, dtype=dt1) == np.array(-1, dtype=dt2),\n                        \"type %s and %s failed\" % (dt1, dt2))\n\n\nclass TestWhere(TestCase):\n    def test_basic(self):\n        dts = [np.bool, np.int16, np.int32, np.int64, np.double, np.complex128,\n               np.longdouble, np.clongdouble]\n        for dt in dts:\n            c = np.ones(53, dtype=np.bool)\n            assert_equal(np.where( c, dt(0), dt(1)), dt(0))\n            assert_equal(np.where(~c, dt(0), dt(1)), dt(1))\n            assert_equal(np.where(True, dt(0), dt(1)), dt(0))\n            assert_equal(np.where(False, dt(0), dt(1)), dt(1))\n            d = np.ones_like(c).astype(dt)\n            e = np.zeros_like(d)\n            r = d.astype(dt)\n            c[7] = False\n            r[7] = e[7]\n            assert_equal(np.where(c, e, e), e)\n            assert_equal(np.where(c, d, e), r)\n            assert_equal(np.where(c, d, e[0]), r)\n            assert_equal(np.where(c, d[0], e), r)\n            assert_equal(np.where(c[::2], d[::2], e[::2]), r[::2])\n            assert_equal(np.where(c[1::2], d[1::2], e[1::2]), r[1::2])\n            assert_equal(np.where(c[::3], d[::3], e[::3]), r[::3])\n            assert_equal(np.where(c[1::3], d[1::3], e[1::3]), r[1::3])\n            assert_equal(np.where(c[::-2], d[::-2], e[::-2]), r[::-2])\n            assert_equal(np.where(c[::-3], d[::-3], e[::-3]), r[::-3])\n            assert_equal(np.where(c[1::-3], d[1::-3], e[1::-3]), r[1::-3])\n\n    def test_exotic(self):\n        # object\n        assert_array_equal(np.where(True, None, None), np.array(None))\n        # zero sized\n        m = np.array([], dtype=bool).reshape(0, 3)\n        b = np.array([], dtype=np.float64).reshape(0, 3)\n        assert_array_equal(np.where(m, 0, b), np.array([]).reshape(0, 3))\n\n        # object cast\n        d = np.array([-1.34, -0.16, -0.54, -0.31, -0.08, -0.95, 0.000, 0.313,\n                      0.547, -0.18, 0.876, 0.236, 1.969, 0.310, 0.699, 1.013,\n                      1.267, 0.229, -1.39, 0.487])\n        nan = float('NaN')\n        e = np.array(['5z', '0l', nan, 'Wz', nan, nan, 'Xq', 'cs', nan, nan,\n                     'QN', nan, nan, 'Fd', nan, nan, 'kp', nan, '36', 'i1'],\n                     dtype=object);\n        m = np.array([0,0,1,0,1,1,0,0,1,1,0,1,1,0,1,1,0,1,0,0], dtype=bool)\n\n        r = e[:]\n        r[np.where(m)] = d[np.where(m)]\n        assert_array_equal(np.where(m, d, e), r)\n\n        r = e[:]\n        r[np.where(~m)] = d[np.where(~m)]\n        assert_array_equal(np.where(m, e, d), r)\n\n        assert_array_equal(np.where(m, e, e), e)\n\n        # minimal dtype result with NaN scalar (e.g required by pandas)\n        d =  np.array([1., 2.], dtype=np.float32)\n        e =  float('NaN')\n        assert_equal(np.where(True, d, e).dtype, np.float32)\n        e =  float('Infinity')\n        assert_equal(np.where(True, d, e).dtype, np.float32)\n        e =  float('-Infinity')\n        assert_equal(np.where(True, d, e).dtype, np.float32)\n        # also check upcast\n        e =  float(1e150)\n        assert_equal(np.where(True, d, e).dtype, np.float64)\n\n    def test_ndim(self):\n        c = [True, False]\n        a = np.zeros((2, 25))\n        b = np.ones((2, 25))\n        r = np.where(np.array(c)[:,np.newaxis], a, b)\n        assert_array_equal(r[0], a[0])\n        assert_array_equal(r[1], b[0])\n\n        a = a.T\n        b = b.T\n        r = np.where(c, a, b)\n        assert_array_equal(r[:,0], a[:,0])\n        assert_array_equal(r[:,1], b[:,0])\n\n    def test_dtype_mix(self):\n        c = np.array([False, True, False, False, False, False, True, False,\n                     False, False, True, False])\n        a = np.uint32(1)\n        b =  np.array([5., 0., 3., 2., -1., -4., 0., -10., 10., 1., 0., 3.],\n                      dtype=np.float64)\n        r = np.array([5., 1., 3., 2., -1., -4., 1., -10., 10., 1., 1., 3.],\n                     dtype=np.float64)\n        assert_equal(np.where(c, a, b), r)\n\n        a = a.astype(np.float32)\n        b = b.astype(np.int64)\n        assert_equal(np.where(c, a, b), r)\n\n        # non bool mask\n        c = c.astype(np.int)\n        c[c != 0] = 34242324\n        assert_equal(np.where(c, a, b), r)\n        # invert\n        tmpmask = c != 0\n        c[c == 0] = 41247212\n        c[tmpmask] = 0\n        assert_equal(np.where(c, b, a), r)\n\n    def test_foreign(self):\n        c = np.array([False, True, False, False, False, False, True, False,\n                     False, False, True, False])\n        r = np.array([5., 1., 3., 2., -1., -4., 1., -10., 10., 1., 1., 3.],\n                     dtype=np.float64)\n        a = np.ones(1, dtype='>i4')\n        b =  np.array([5., 0., 3., 2., -1., -4., 0., -10., 10., 1., 0., 3.],\n                      dtype=np.float64)\n        assert_equal(np.where(c, a, b), r)\n\n        b = b.astype('>f8')\n        assert_equal(np.where(c, a, b), r)\n\n        a = a.astype('<i4')\n        assert_equal(np.where(c, a, b), r)\n\n        c = c.astype('>i4')\n        assert_equal(np.where(c, a, b), r)\n\n    def test_error(self):\n        c = [True, True]\n        a = np.ones((4, 5))\n        b = np.ones((5, 5))\n        assert_raises(ValueError, np.where, c, a, a)\n        assert_raises(ValueError, np.where, c[0], a, b)\n\n\nif __name__ == \"__main__\":\n    run_module_suite()\n", "#!/usr/bin/env python\nfrom __future__ import division, absolute_import, print_function\n\n__all__ = ['run_main', 'compile', 'f2py_testing']\n\nimport os\nimport sys\nimport subprocess\n\nfrom . import f2py2e\nfrom . import f2py_testing\nfrom . import diagnose\n\nfrom .info import __doc__\n\nrun_main = f2py2e.run_main\nmain = f2py2e.main\n\ndef compile(source,\n            modulename = 'untitled',\n            extra_args = '',\n            verbose = 1,\n            source_fn = None\n            ):\n    ''' Build extension module from processing source with f2py.\n    Read the source of this function for more information.\n    '''\n    from numpy.distutils.exec_command import exec_command\n    import tempfile\n    if source_fn is None:\n        f = tempfile.NamedTemporaryFile(suffix='.f')\n    else:\n        f = open(source_fn, 'w')\n\n    try:\n        f.write(source)\n        f.flush()\n\n        args = ' -c -m %s %s %s'%(modulename, f.name, extra_args)\n        c = '%s -c \"import numpy.f2py as f2py2e;f2py2e.main()\" %s' % \\\n                (sys.executable, args)\n        s, o = exec_command(c)\n    finally:\n        f.close()\n    return s\n\nfrom numpy.testing import Tester\ntest = Tester().test\nbench = Tester().bench\n", "#!/usr/bin/env python\n\"\"\"\n\nf2py2e - Fortran to Python C/API generator. 2nd Edition.\n         See __usage__ below.\n\nCopyright 1999--2011 Pearu Peterson all rights reserved,\nPearu Peterson <pearu@cens.ioc.ee>\nPermission to use, modify, and distribute this software is given under the\nterms of the NumPy License.\n\nNO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.\n$Date: 2005/05/06 08:31:19 $\nPearu Peterson\n\n\"\"\"\nfrom __future__ import division, absolute_import, print_function\n\nimport sys\nimport os\nimport pprint\nimport re\n\nfrom . import crackfortran\nfrom . import rules\nfrom . import cb_rules\nfrom . import auxfuncs\nfrom . import cfuncs\nfrom . import f90mod_rules\nfrom . import __version__\n\nf2py_version = __version__.version\nerrmess = sys.stderr.write\n#outmess=sys.stdout.write\nshow = pprint.pprint\noutmess = auxfuncs.outmess\n\ntry:\n    from numpy import __version__ as numpy_version\nexcept ImportError:\n    numpy_version = 'N/A'\n\n__usage__ = \"\"\"\\\nUsage:\n\n1) To construct extension module sources:\n\n      f2py [<options>] <fortran files> [[[only:]||[skip:]] \\\\\n                                        <fortran functions> ] \\\\\n                                       [: <fortran files> ...]\n\n2) To compile fortran files and build extension modules:\n\n      f2py -c [<options>, <build_flib options>, <extra options>] <fortran files>\n\n3) To generate signature files:\n\n      f2py -h <filename.pyf> ...< same options as in (1) >\n\nDescription: This program generates a Python C/API file (<modulename>module.c)\n             that contains wrappers for given fortran functions so that they\n             can be called from Python. With the -c option the corresponding\n             extension modules are built.\n\nOptions:\n\n  --2d-numpy       Use numpy.f2py tool with NumPy support. [DEFAULT]\n  --2d-numeric     Use f2py2e tool with Numeric support.\n  --2d-numarray    Use f2py2e tool with Numarray support.\n  --g3-numpy       Use 3rd generation f2py from the separate f2py package.\n                   [NOT AVAILABLE YET]\n\n  -h <filename>    Write signatures of the fortran routines to file <filename>\n                   and exit. You can then edit <filename> and use it instead\n                   of <fortran files>. If <filename>==stdout then the\n                   signatures are printed to stdout.\n  <fortran functions>  Names of fortran routines for which Python C/API\n                   functions will be generated. Default is all that are found\n                   in <fortran files>.\n  <fortran files>  Paths to fortran/signature files that will be scanned for\n                   <fortran functions> in order to determine their signatures.\n  skip:            Ignore fortran functions that follow until `:'.\n  only:            Use only fortran functions that follow until `:'.\n  :                Get back to <fortran files> mode.\n\n  -m <modulename>  Name of the module; f2py generates a Python/C API\n                   file <modulename>module.c or extension module <modulename>.\n                   Default is 'untitled'.\n\n  --[no-]lower     Do [not] lower the cases in <fortran files>. By default,\n                   --lower is assumed with -h key, and --no-lower without -h key.\n\n  --build-dir <dirname>  All f2py generated files are created in <dirname>.\n                   Default is tempfile.mkdtemp().\n\n  --overwrite-signature  Overwrite existing signature file.\n\n  --[no-]latex-doc Create (or not) <modulename>module.tex.\n                   Default is --no-latex-doc.\n  --short-latex    Create 'incomplete' LaTeX document (without commands\n                   \\\\documentclass, \\\\tableofcontents, and \\\\begin{document},\n                   \\\\end{document}).\n\n  --[no-]rest-doc Create (or not) <modulename>module.rst.\n                   Default is --no-rest-doc.\n\n  --debug-capi     Create C/API code that reports the state of the wrappers\n                   during runtime. Useful for debugging.\n\n  --[no-]wrap-functions    Create Fortran subroutine wrappers to Fortran 77\n                   functions. --wrap-functions is default because it ensures\n                   maximum portability/compiler independence.\n\n  --include-paths <path1>:<path2>:...   Search include files from the given\n                   directories.\n\n  --help-link [..] List system resources found by system_info.py. See also\n                   --link-<resource> switch below. [..] is optional list\n                   of resources names. E.g. try 'f2py --help-link lapack_opt'.\n\n  --quiet          Run quietly.\n  --verbose        Run with extra verbosity.\n  -v               Print f2py version ID and exit.\n\n\nnumpy.distutils options (only effective with -c):\n\n  --fcompiler=         Specify Fortran compiler type by vendor\n  --compiler=          Specify C compiler type (as defined by distutils)\n\n  --help-fcompiler     List available Fortran compilers and exit\n  --f77exec=           Specify the path to F77 compiler\n  --f90exec=           Specify the path to F90 compiler\n  --f77flags=          Specify F77 compiler flags\n  --f90flags=          Specify F90 compiler flags\n  --opt=               Specify optimization flags\n  --arch=              Specify architecture specific optimization flags\n  --noopt              Compile without optimization\n  --noarch             Compile without arch-dependent optimization\n  --debug              Compile with debugging information\n\nExtra options (only effective with -c):\n\n  --link-<resource>    Link extension module with <resource> as defined\n                       by numpy.distutils/system_info.py. E.g. to link\n                       with optimized LAPACK libraries (vecLib on MacOSX,\n                       ATLAS elsewhere), use --link-lapack_opt.\n                       See also --help-link switch.\n\n  -L/path/to/lib/ -l<libname>\n  -D<define> -U<name>\n  -I/path/to/include/\n  <filename>.o <filename>.so <filename>.a\n\n  Using the following macros may be required with non-gcc Fortran\n  compilers:\n    -DPREPEND_FORTRAN -DNO_APPEND_FORTRAN -DUPPERCASE_FORTRAN\n    -DUNDERSCORE_G77\n\n  When using -DF2PY_REPORT_ATEXIT, a performance report of F2PY\n  interface is printed out at exit (platforms: Linux).\n\n  When using -DF2PY_REPORT_ON_ARRAY_COPY=<int>, a message is\n  sent to stderr whenever F2PY interface makes a copy of an\n  array. Integer <int> sets the threshold for array sizes when\n  a message should be shown.\n\nVersion:     %s\nnumpy Version: %s\nRequires:    Python 2.3 or higher.\nLicense:     NumPy license (see LICENSE.txt in the NumPy source code)\nCopyright 1999 - 2011 Pearu Peterson all rights reserved.\nhttp://cens.ioc.ee/projects/f2py2e/\"\"\"%(f2py_version, numpy_version)\n\ndef scaninputline(inputline):\n    files, funcs, skipfuncs, onlyfuncs, debug=[], [], [], [], []\n    f, f2, f3, f4, f5, f6, f7, f8, f9=1, 0, 0, 0, 0, 0, 0, 0, 0\n    verbose = 1\n    dolc=-1\n    dolatexdoc = 0\n    dorestdoc = 0\n    wrapfuncs = 1\n    buildpath = '.'\n    include_paths = []\n    signsfile, modulename=None, None\n    options = {'buildpath':buildpath,\n               'coutput': None,\n               'f2py_wrapper_output': None}\n    for l in inputline:\n        if l=='': pass\n        elif l=='only:': f=0\n        elif l=='skip:': f=-1\n        elif l==':': f=1;f4=0\n        elif l[:8]=='--debug-': debug.append(l[8:])\n        elif l=='--lower': dolc=1\n        elif l=='--build-dir': f6=1\n        elif l=='--no-lower': dolc=0\n        elif l=='--quiet': verbose = 0\n        elif l=='--verbose': verbose += 1\n        elif l=='--latex-doc': dolatexdoc=1\n        elif l=='--no-latex-doc': dolatexdoc=0\n        elif l=='--rest-doc': dorestdoc=1\n        elif l=='--no-rest-doc': dorestdoc=0\n        elif l=='--wrap-functions': wrapfuncs=1\n        elif l=='--no-wrap-functions': wrapfuncs=0\n        elif l=='--short-latex': options['shortlatex']=1\n        elif l=='--coutput': f8=1\n        elif l=='--f2py-wrapper-output': f9=1\n        elif l=='--overwrite-signature': options['h-overwrite']=1\n        elif l=='-h': f2=1\n        elif l=='-m': f3=1\n        elif l[:2]=='-v':\n            print(f2py_version)\n            sys.exit()\n        elif l=='--show-compilers':\n            f5=1\n        elif l[:8]=='-include':\n            cfuncs.outneeds['userincludes'].append(l[9:-1])\n            cfuncs.userincludes[l[9:-1]]='#include '+l[8:]\n        elif l[:15] in '--include_paths':\n            outmess('f2py option --include_paths is deprecated, use --include-paths instead.\\n')\n            f7=1\n        elif l[:15] in '--include-paths':\n            f7=1\n        elif l[0]=='-':\n            errmess('Unknown option %s\\n'%repr(l))\n            sys.exit()\n        elif f2: f2=0;signsfile=l\n        elif f3: f3=0;modulename=l\n        elif f6: f6=0;buildpath=l\n        elif f7: f7=0;include_paths.extend(l.split(os.pathsep))\n        elif f8: f8=0;options[\"coutput\"]=l\n        elif f9: f9=0;options[\"f2py_wrapper_output\"]=l\n        elif f==1:\n            try:\n                open(l).close()\n                files.append(l)\n            except IOError as detail:\n                errmess('IOError: %s. Skipping file \"%s\".\\n'%(str(detail), l))\n        elif f==-1: skipfuncs.append(l)\n        elif f==0: onlyfuncs.append(l)\n    if not f5 and not files and not modulename:\n        print(__usage__)\n        sys.exit()\n    if not os.path.isdir(buildpath):\n        if not verbose:\n            outmess('Creating build directory %s'%(buildpath))\n        os.mkdir(buildpath)\n    if signsfile:\n        signsfile = os.path.join(buildpath, signsfile)\n    if signsfile and os.path.isfile(signsfile) and 'h-overwrite' not in options:\n        errmess('Signature file \"%s\" exists!!! Use --overwrite-signature to overwrite.\\n'%(signsfile))\n        sys.exit()\n\n    options['debug']=debug\n    options['verbose']=verbose\n    if dolc==-1 and not signsfile: options['do-lower']=0\n    else: options['do-lower']=dolc\n    if modulename: options['module']=modulename\n    if signsfile: options['signsfile']=signsfile\n    if onlyfuncs: options['onlyfuncs']=onlyfuncs\n    if skipfuncs: options['skipfuncs']=skipfuncs\n    options['dolatexdoc'] = dolatexdoc\n    options['dorestdoc'] = dorestdoc\n    options['wrapfuncs'] = wrapfuncs\n    options['buildpath']=buildpath\n    options['include_paths']=include_paths\n    return files, options\n\ndef callcrackfortran(files, options):\n    rules.options=options\n    funcs=[]\n    crackfortran.debug=options['debug']\n    crackfortran.verbose=options['verbose']\n    if 'module' in options:\n        crackfortran.f77modulename=options['module']\n    if 'skipfuncs' in options:\n        crackfortran.skipfuncs=options['skipfuncs']\n    if 'onlyfuncs' in options:\n        crackfortran.onlyfuncs=options['onlyfuncs']\n    crackfortran.include_paths[:]=options['include_paths']\n    crackfortran.dolowercase=options['do-lower']\n    postlist=crackfortran.crackfortran(files)\n    if 'signsfile' in options:\n        outmess('Saving signatures to file \"%s\"\\n'%(options['signsfile']))\n        pyf=crackfortran.crack2fortran(postlist)\n        if options['signsfile'][-6:]=='stdout':\n            sys.stdout.write(pyf)\n        else:\n            f=open(options['signsfile'], 'w')\n            f.write(pyf)\n            f.close()\n    if options[\"coutput\"] is None:\n        for mod in postlist:\n            mod[\"coutput\"] = \"%smodule.c\" % mod[\"name\"]\n    else:\n        for mod in postlist:\n            mod[\"coutput\"] = options[\"coutput\"]\n    if options[\"f2py_wrapper_output\"] is None:\n        for mod in postlist:\n            mod[\"f2py_wrapper_output\"] = \"%s-f2pywrappers.f\" % mod[\"name\"]\n    else:\n        for mod in postlist:\n            mod[\"f2py_wrapper_output\"] = options[\"f2py_wrapper_output\"]\n    return postlist\n\ndef buildmodules(lst):\n    cfuncs.buildcfuncs()\n    outmess('Building modules...\\n')\n    modules, mnames, isusedby=[], [], {}\n    for i in range(len(lst)):\n        if '__user__' in lst[i]['name']:\n            cb_rules.buildcallbacks(lst[i])\n        else:\n            if 'use' in lst[i]:\n                for u in lst[i]['use'].keys():\n                    if u not in isusedby:\n                        isusedby[u]=[]\n                    isusedby[u].append(lst[i]['name'])\n            modules.append(lst[i])\n            mnames.append(lst[i]['name'])\n    ret = {}\n    for i in range(len(mnames)):\n        if mnames[i] in isusedby:\n            outmess('\\tSkipping module \"%s\" which is used by %s.\\n'%(mnames[i], ','.join(['\"%s\"'%s for s in isusedby[mnames[i]]])))\n        else:\n            um=[]\n            if 'use' in modules[i]:\n                for u in modules[i]['use'].keys():\n                    if u in isusedby and u in mnames:\n                        um.append(modules[mnames.index(u)])\n                    else:\n                        outmess('\\tModule \"%s\" uses nonexisting \"%s\" which will be ignored.\\n'%(mnames[i], u))\n            ret[mnames[i]] = {}\n            dict_append(ret[mnames[i]], rules.buildmodule(modules[i], um))\n    return ret\n\ndef dict_append(d_out, d_in):\n    for (k, v) in d_in.items():\n        if k not in d_out:\n            d_out[k] = []\n        if isinstance(v, list):\n            d_out[k] = d_out[k] + v\n        else:\n            d_out[k].append(v)\n\ndef run_main(comline_list):\n    \"\"\"Run f2py as if string.join(comline_list,' ') is used as a command line.\n    In case of using -h flag, return None.\n    \"\"\"\n    crackfortran.reset_global_f2py_vars()\n    f2pydir=os.path.dirname(os.path.abspath(cfuncs.__file__))\n    fobjhsrc = os.path.join(f2pydir, 'src', 'fortranobject.h')\n    fobjcsrc = os.path.join(f2pydir, 'src', 'fortranobject.c')\n    files, options=scaninputline(comline_list)\n    auxfuncs.options=options\n    postlist=callcrackfortran(files, options)\n    isusedby={}\n    for i in range(len(postlist)):\n        if 'use' in postlist[i]:\n            for u in postlist[i]['use'].keys():\n                if u not in isusedby:\n                    isusedby[u]=[]\n                isusedby[u].append(postlist[i]['name'])\n    for i in range(len(postlist)):\n        if postlist[i]['block']=='python module' and '__user__' in postlist[i]['name']:\n            if postlist[i]['name'] in isusedby:\n                #if not quiet:\n                outmess('Skipping Makefile build for module \"%s\" which is used by %s\\n'%(postlist[i]['name'], ','.join(['\"%s\"'%s for s in isusedby[postlist[i]['name']]])))\n    if 'signsfile' in options:\n        if options['verbose']>1:\n            outmess('Stopping. Edit the signature file and then run f2py on the signature file: ')\n            outmess('%s %s\\n'%(os.path.basename(sys.argv[0]), options['signsfile']))\n        return\n    for i in range(len(postlist)):\n        if postlist[i]['block']!='python module':\n            if 'python module' not in options:\n                errmess('Tip: If your original code is Fortran source then you must use -m option.\\n')\n            raise TypeError('All blocks must be python module blocks but got %s'%(repr(postlist[i]['block'])))\n    auxfuncs.debugoptions=options['debug']\n    f90mod_rules.options=options\n    auxfuncs.wrapfuncs=options['wrapfuncs']\n\n    ret=buildmodules(postlist)\n\n    for mn in ret.keys():\n        dict_append(ret[mn], {'csrc':fobjcsrc,'h':fobjhsrc})\n    return ret\n\ndef filter_files(prefix,suffix,files,remove_prefix=None):\n    \"\"\"\n    Filter files by prefix and suffix.\n    \"\"\"\n    filtered, rest = [], []\n    match = re.compile(prefix+r'.*'+suffix+r'\\Z').match\n    if remove_prefix:\n        ind = len(prefix)\n    else:\n        ind = 0\n    for file in [x.strip() for x in files]:\n        if match(file): filtered.append(file[ind:])\n        else: rest.append(file)\n    return filtered, rest\n\ndef get_prefix(module):\n    p = os.path.dirname(os.path.dirname(module.__file__))\n    return p\n\ndef run_compile():\n    \"\"\"\n    Do it all in one call!\n    \"\"\"\n    import tempfile\n\n    i = sys.argv.index('-c')\n    del sys.argv[i]\n\n    remove_build_dir = 0\n    try: i = sys.argv.index('--build-dir')\n    except ValueError: i=None\n    if i is not None:\n        build_dir = sys.argv[i+1]\n        del sys.argv[i+1]\n        del sys.argv[i]\n    else:\n        remove_build_dir = 1\n        build_dir = tempfile.mkdtemp()\n\n    _reg1 = re.compile(r'[-][-]link[-]')\n    sysinfo_flags = [_m for _m in sys.argv[1:] if _reg1.match(_m)]\n    sys.argv = [_m for _m in sys.argv if _m not in sysinfo_flags]\n    if sysinfo_flags:\n        sysinfo_flags = [f[7:] for f in sysinfo_flags]\n\n    _reg2 = re.compile(r'[-][-]((no[-]|)(wrap[-]functions|lower)|debug[-]capi|quiet)|[-]include')\n    f2py_flags = [_m for _m in sys.argv[1:] if _reg2.match(_m)]\n    sys.argv = [_m for _m in sys.argv if _m not in f2py_flags]\n    f2py_flags2 = []\n    fl = 0\n    for a in sys.argv[1:]:\n        if a in ['only:', 'skip:']:\n            fl = 1\n        elif a==':':\n            fl = 0\n        if fl or a==':':\n            f2py_flags2.append(a)\n    if f2py_flags2 and f2py_flags2[-1]!=':':\n        f2py_flags2.append(':')\n    f2py_flags.extend(f2py_flags2)\n\n    sys.argv = [_m for _m in sys.argv if _m not in f2py_flags2]\n    _reg3 = re.compile(r'[-][-]((f(90)?compiler([-]exec|)|compiler)=|help[-]compiler)')\n    flib_flags = [_m for _m in sys.argv[1:] if _reg3.match(_m)]\n    sys.argv = [_m for _m in sys.argv if _m not in flib_flags]\n    _reg4 = re.compile(r'[-][-]((f(77|90)(flags|exec)|opt|arch)=|(debug|noopt|noarch|help[-]fcompiler))')\n    fc_flags = [_m for _m in sys.argv[1:] if _reg4.match(_m)]\n    sys.argv = [_m for _m in sys.argv if _m not in fc_flags]\n\n    if 1:\n        del_list = []\n        for s in flib_flags:\n            v = '--fcompiler='\n            if s[:len(v)]==v:\n                from numpy.distutils import fcompiler\n                fcompiler.load_all_fcompiler_classes()\n                allowed_keys = list(fcompiler.fcompiler_class.keys())\n                nv = ov = s[len(v):].lower()\n                if ov not in allowed_keys:\n                    vmap = {} # XXX\n                    try:\n                        nv = vmap[ov]\n                    except KeyError:\n                        if ov not in vmap.values():\n                            print('Unknown vendor: \"%s\"' % (s[len(v):]))\n                    nv = ov\n                i = flib_flags.index(s)\n                flib_flags[i] = '--fcompiler=' + nv\n                continue\n        for s in del_list:\n            i = flib_flags.index(s)\n            del flib_flags[i]\n        assert len(flib_flags)<=2, repr(flib_flags)\n\n    _reg5 = re.compile(r'[-][-](verbose)')\n    setup_flags = [_m for _m in sys.argv[1:] if _reg5.match(_m)]\n    sys.argv = [_m for _m in sys.argv if _m not in setup_flags]\n\n    if '--quiet' in f2py_flags:\n        setup_flags.append('--quiet')\n\n    modulename = 'untitled'\n    sources = sys.argv[1:]\n\n    for optname in ['--include_paths', '--include-paths']:\n        if optname in sys.argv:\n            i = sys.argv.index (optname)\n            f2py_flags.extend (sys.argv[i:i+2])\n            del sys.argv[i+1], sys.argv[i]\n            sources = sys.argv[1:]\n\n    if '-m' in sys.argv:\n        i = sys.argv.index('-m')\n        modulename = sys.argv[i+1]\n        del sys.argv[i+1], sys.argv[i]\n        sources = sys.argv[1:]\n    else:\n        from numpy.distutils.command.build_src import get_f2py_modulename\n        pyf_files, sources = filter_files('', '[.]pyf([.]src|)', sources)\n        sources = pyf_files + sources\n        for f in pyf_files:\n            modulename = get_f2py_modulename(f)\n            if modulename:\n                break\n\n    extra_objects, sources = filter_files('', '[.](o|a|so)', sources)\n    include_dirs, sources = filter_files('-I', '', sources, remove_prefix=1)\n    library_dirs, sources = filter_files('-L', '', sources, remove_prefix=1)\n    libraries, sources = filter_files('-l', '', sources, remove_prefix=1)\n    undef_macros, sources = filter_files('-U', '', sources, remove_prefix=1)\n    define_macros, sources = filter_files('-D', '', sources, remove_prefix=1)\n    using_numarray = 0\n    using_numeric = 0\n    for i in range(len(define_macros)):\n        name_value = define_macros[i].split('=', 1)\n        if len(name_value)==1:\n            name_value.append(None)\n        if len(name_value)==2:\n            define_macros[i] = tuple(name_value)\n        else:\n            print('Invalid use of -D:', name_value)\n\n    from numpy.distutils.system_info import get_info\n\n    num_include_dir = None\n    num_info = {}\n    #import numpy\n    #n = 'numpy'\n    #p = get_prefix(numpy)\n    #from numpy.distutils.misc_util import get_numpy_include_dirs\n    #num_info = {'include_dirs': get_numpy_include_dirs()}\n\n    if num_info:\n        include_dirs.extend(num_info.get('include_dirs', []))\n\n    from numpy.distutils.core import setup, Extension\n    ext_args = {'name': modulename, 'sources': sources,\n                'include_dirs': include_dirs,\n                'library_dirs': library_dirs,\n                'libraries': libraries,\n                'define_macros': define_macros,\n                'undef_macros': undef_macros,\n                'extra_objects': extra_objects,\n                'f2py_options': f2py_flags,\n                }\n\n    if sysinfo_flags:\n        from numpy.distutils.misc_util import dict_append\n        for n in sysinfo_flags:\n            i = get_info(n)\n            if not i:\n                outmess('No %s resources found in system'\\\n                        ' (try `f2py --help-link`)\\n' % (repr(n)))\n            dict_append(ext_args,**i)\n\n    ext = Extension(**ext_args)\n    sys.argv = [sys.argv[0]] + setup_flags\n    sys.argv.extend(['build',\n                     '--build-temp', build_dir,\n                     '--build-base', build_dir,\n                     '--build-platlib', '.'])\n    if fc_flags:\n        sys.argv.extend(['config_fc']+fc_flags)\n    if flib_flags:\n        sys.argv.extend(['build_ext']+flib_flags)\n\n    setup(ext_modules = [ext])\n\n    if remove_build_dir and os.path.exists(build_dir):\n        import shutil\n        outmess('Removing build directory %s\\n'%(build_dir))\n        shutil.rmtree(build_dir)\n\ndef main():\n    if '--help-link' in sys.argv[1:]:\n        sys.argv.remove('--help-link')\n        from numpy.distutils.system_info import show_all\n        show_all()\n        return\n    if '-c' in sys.argv[1:]:\n        run_compile()\n    else:\n        run_main(sys.argv[1:])\n\n#if __name__ == \"__main__\":\n#    main()\n\n\n# EOF\n", "from __future__ import division, absolute_import, print_function\n\nimport sys\nimport gzip\nimport os\nimport threading\nimport shutil\nimport contextlib\nfrom tempfile import mkstemp, mkdtemp, NamedTemporaryFile\nimport time\nimport warnings\nimport gc\nfrom io import BytesIO\nfrom datetime import datetime\n\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy.lib._iotools import (ConverterError, ConverterLockError,\n                                ConversionWarning)\nfrom numpy.compat import asbytes, asbytes_nested, bytes, asstr\nfrom nose import SkipTest\nfrom numpy.ma.testutils import (TestCase, assert_equal, assert_array_equal,\n                                assert_raises, run_module_suite)\nfrom numpy.testing import assert_warns, assert_, build_err_msg\n\n@contextlib.contextmanager\ndef tempdir(change_dir=False):\n    tmpdir = mkdtemp()\n    yield tmpdir\n    shutil.rmtree(tmpdir)\n\n\nclass TextIO(BytesIO):\n    \"\"\"Helper IO class.\n\n    Writes encode strings to bytes if needed, reads return bytes.\n    This makes it easier to emulate files opened in binary mode\n    without needing to explicitly convert strings to bytes in\n    setting up the test data.\n\n    \"\"\"\n    def __init__(self, s=\"\"):\n        BytesIO.__init__(self, asbytes(s))\n\n    def write(self, s):\n        BytesIO.write(self, asbytes(s))\n\n    def writelines(self, lines):\n        BytesIO.writelines(self, [asbytes(s) for s in lines])\n\n\nMAJVER, MINVER = sys.version_info[:2]\nIS_64BIT = sys.maxsize > 2**32\n\n\ndef strptime(s, fmt=None):\n    \"\"\"This function is available in the datetime module only\n    from Python >= 2.5.\n\n    \"\"\"\n    if sys.version_info[0] >= 3:\n        return datetime(*time.strptime(s.decode('latin1'), fmt)[:3])\n    else:\n        return datetime(*time.strptime(s, fmt)[:3])\n\n\nclass RoundtripTest(object):\n    def roundtrip(self, save_func, *args, **kwargs):\n        \"\"\"\n        save_func : callable\n            Function used to save arrays to file.\n        file_on_disk : bool\n            If true, store the file on disk, instead of in a\n            string buffer.\n        save_kwds : dict\n            Parameters passed to `save_func`.\n        load_kwds : dict\n            Parameters passed to `numpy.load`.\n        args : tuple of arrays\n            Arrays stored to file.\n\n        \"\"\"\n        save_kwds = kwargs.get('save_kwds', {})\n        load_kwds = kwargs.get('load_kwds', {})\n        file_on_disk = kwargs.get('file_on_disk', False)\n\n        if file_on_disk:\n            # Do not delete the file on windows, because we can't\n            # reopen an already opened file on that platform, so we\n            # need to close the file and reopen it, implying no\n            # automatic deletion.\n            if sys.platform == 'win32' and MAJVER >= 2 and MINVER >= 6:\n                target_file = NamedTemporaryFile(delete=False)\n            else:\n                target_file = NamedTemporaryFile()\n            load_file = target_file.name\n        else:\n            target_file = BytesIO()\n            load_file = target_file\n\n        arr = args\n\n        save_func(target_file, *arr, **save_kwds)\n        target_file.flush()\n        target_file.seek(0)\n\n        if sys.platform == 'win32' and not isinstance(target_file, BytesIO):\n            target_file.close()\n\n        arr_reloaded = np.load(load_file, **load_kwds)\n\n        self.arr = arr\n        self.arr_reloaded = arr_reloaded\n\n    def check_roundtrips(self, a):\n        self.roundtrip(a)\n        self.roundtrip(a, file_on_disk=True)\n        self.roundtrip(np.asfortranarray(a))\n        self.roundtrip(np.asfortranarray(a), file_on_disk=True)\n        if a.shape[0] > 1:\n            # neither C nor Fortran contiguous for 2D arrays or more\n            self.roundtrip(np.asfortranarray(a)[1:])\n            self.roundtrip(np.asfortranarray(a)[1:], file_on_disk=True)\n\n    def test_array(self):\n        a = np.array([], float)\n        self.check_roundtrips(a)\n\n        a = np.array([[1, 2], [3, 4]], float)\n        self.check_roundtrips(a)\n\n        a = np.array([[1, 2], [3, 4]], int)\n        self.check_roundtrips(a)\n\n        a = np.array([[1 + 5j, 2 + 6j], [3 + 7j, 4 + 8j]], dtype=np.csingle)\n        self.check_roundtrips(a)\n\n        a = np.array([[1 + 5j, 2 + 6j], [3 + 7j, 4 + 8j]], dtype=np.cdouble)\n        self.check_roundtrips(a)\n\n    def test_array_object(self):\n        if sys.version_info[:2] >= (2, 7):\n            a = np.array([], object)\n            self.check_roundtrips(a)\n\n            a = np.array([[1, 2], [3, 4]], object)\n            self.check_roundtrips(a)\n        # Fails with UnpicklingError: could not find MARK on Python 2.6\n\n    def test_1D(self):\n        a = np.array([1, 2, 3, 4], int)\n        self.roundtrip(a)\n\n    @np.testing.dec.knownfailureif(sys.platform == 'win32', \"Fail on Win32\")\n    def test_mmap(self):\n        a = np.array([[1, 2.5], [4, 7.3]])\n        self.roundtrip(a, file_on_disk=True, load_kwds={'mmap_mode': 'r'})\n\n        a = np.asfortranarray([[1, 2.5], [4, 7.3]])\n        self.roundtrip(a, file_on_disk=True, load_kwds={'mmap_mode': 'r'})\n\n    def test_record(self):\n        a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])\n        self.check_roundtrips(a)\n\n\nclass TestSaveLoad(RoundtripTest, TestCase):\n    def roundtrip(self, *args, **kwargs):\n        RoundtripTest.roundtrip(self, np.save, *args, **kwargs)\n        assert_equal(self.arr[0], self.arr_reloaded)\n        assert_equal(self.arr[0].dtype, self.arr_reloaded.dtype)\n        assert_equal(self.arr[0].flags.fnc, self.arr_reloaded.flags.fnc)\n\n\nclass TestSavezLoad(RoundtripTest, TestCase):\n    def roundtrip(self, *args, **kwargs):\n        RoundtripTest.roundtrip(self, np.savez, *args, **kwargs)\n        for n, arr in enumerate(self.arr):\n            reloaded = self.arr_reloaded['arr_%d' % n]\n            assert_equal(arr, reloaded)\n            assert_equal(arr.dtype, reloaded.dtype)\n            assert_equal(arr.flags.fnc, reloaded.flags.fnc)\n\n    @np.testing.dec.skipif(not IS_64BIT, \"Works only with 64bit systems\")\n    @np.testing.dec.slow\n    def test_big_arrays(self):\n        L = (1 << 31) + 100000\n        a = np.empty(L, dtype=np.uint8)\n        with tempdir() as tmpdir:\n            tmp = open(os.path.join(tmpdir, \"file.npz\"), \"w\")\n            np.savez(tmp, a=a)\n            del a\n            npfile = np.load(tmp)\n            a = npfile['a']\n            npfile.close()\n\n    def test_multiple_arrays(self):\n        a = np.array([[1, 2], [3, 4]], float)\n        b = np.array([[1 + 2j, 2 + 7j], [3 - 6j, 4 + 12j]], complex)\n        self.roundtrip(a, b)\n\n    def test_named_arrays(self):\n        a = np.array([[1, 2], [3, 4]], float)\n        b = np.array([[1 + 2j, 2 + 7j], [3 - 6j, 4 + 12j]], complex)\n        c = BytesIO()\n        np.savez(c, file_a=a, file_b=b)\n        c.seek(0)\n        l = np.load(c)\n        assert_equal(a, l['file_a'])\n        assert_equal(b, l['file_b'])\n\n    def test_savez_filename_clashes(self):\n        # Test that issue #852 is fixed\n        # and savez functions in multithreaded environment\n\n        def writer(error_list):\n            fd, tmp = mkstemp(suffix='.npz')\n            os.close(fd)\n            try:\n                arr = np.random.randn(500, 500)\n                try:\n                    np.savez(tmp, arr=arr)\n                except OSError as err:\n                    error_list.append(err)\n            finally:\n                os.remove(tmp)\n\n        errors = []\n        threads = [threading.Thread(target=writer, args=(errors,))\n                   for j in range(3)]\n        for t in threads:\n            t.start()\n        for t in threads:\n            t.join()\n\n        if errors:\n            raise AssertionError(errors)\n\n    def test_not_closing_opened_fid(self):\n        # Test that issue #2178 is fixed:\n        # verify could seek on 'loaded' file\n\n        fd, tmp = mkstemp(suffix='.npz')\n        os.close(fd)\n        try:\n            fp = open(tmp, 'wb')\n            np.savez(fp, data='LOVELY LOAD')\n            fp.close()\n\n            fp = open(tmp, 'rb', 10000)\n            fp.seek(0)\n            assert_(not fp.closed)\n            _ = np.load(fp)['data']\n            assert_(not fp.closed)\n                    # must not get closed by .load(opened fp)\n            fp.seek(0)\n            assert_(not fp.closed)\n\n        finally:\n            fp.close()\n            os.remove(tmp)\n\n    def test_closing_fid(self):\n        # Test that issue #1517 (too many opened files) remains closed\n        # It might be a \"weak\" test since failed to get triggered on\n        # e.g. Debian sid of 2012 Jul 05 but was reported to\n        # trigger the failure on Ubuntu 10.04:\n        # http://projects.scipy.org/numpy/ticket/1517#comment:2\n        fd, tmp = mkstemp(suffix='.npz')\n        os.close(fd)\n\n        try:\n            fp = open(tmp, 'wb')\n            np.savez(fp, data='LOVELY LOAD')\n            fp.close()\n            # We need to check if the garbage collector can properly close\n            # numpy npz file returned by np.load when their reference count\n            # goes to zero.  Python 3 running in debug mode raises a\n            # ResourceWarning when file closing is left to the garbage\n            # collector, so we catch the warnings.  Because ResourceWarning\n            # is unknown in Python < 3.x, we take the easy way out and\n            # catch all warnings.\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"ignore\")\n                for i in range(1, 1025):\n                    try:\n                        np.load(tmp)[\"data\"]\n                    except Exception as e:\n                        msg = \"Failed to load data from a file: %s\" % e\n                        raise AssertionError(msg)\n        finally:\n            os.remove(tmp)\n\n    def test_closing_zipfile_after_load(self):\n        # Check that zipfile owns file and can close it.\n        # This needs to pass a file name to load for the\n        # test.\n        fd, tmp = mkstemp(suffix='.npz')\n        os.close(fd)\n        np.savez(tmp, lab='place holder')\n        data = np.load(tmp)\n        fp = data.zip.fp\n        data.close()\n        assert_(fp.closed)\n\n\nclass TestSaveTxt(TestCase):\n    def test_array(self):\n        a = np.array([[1, 2], [3, 4]], float)\n        fmt = \"%.18e\"\n        c = BytesIO()\n        np.savetxt(c, a, fmt=fmt)\n        c.seek(0)\n        assert_equal(c.readlines(),\n                     [asbytes((fmt + ' ' + fmt + '\\n') % (1, 2)),\n                      asbytes((fmt + ' ' + fmt + '\\n') % (3, 4))])\n\n        a = np.array([[1, 2], [3, 4]], int)\n        c = BytesIO()\n        np.savetxt(c, a, fmt='%d')\n        c.seek(0)\n        assert_equal(c.readlines(), [b'1 2\\n', b'3 4\\n'])\n\n    def test_1D(self):\n        a = np.array([1, 2, 3, 4], int)\n        c = BytesIO()\n        np.savetxt(c, a, fmt='%d')\n        c.seek(0)\n        lines = c.readlines()\n        assert_equal(lines, [b'1\\n', b'2\\n', b'3\\n', b'4\\n'])\n\n    def test_record(self):\n        a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])\n        c = BytesIO()\n        np.savetxt(c, a, fmt='%d')\n        c.seek(0)\n        assert_equal(c.readlines(), [b'1 2\\n', b'3 4\\n'])\n\n    def test_delimiter(self):\n        a = np.array([[1., 2.], [3., 4.]])\n        c = BytesIO()\n        np.savetxt(c, a, delimiter=',', fmt='%d')\n        c.seek(0)\n        assert_equal(c.readlines(), [b'1,2\\n', b'3,4\\n'])\n\n    def test_format(self):\n        a = np.array([(1, 2), (3, 4)])\n        c = BytesIO()\n        # Sequence of formats\n        np.savetxt(c, a, fmt=['%02d', '%3.1f'])\n        c.seek(0)\n        assert_equal(c.readlines(), [b'01 2.0\\n', b'03 4.0\\n'])\n\n        # A single multiformat string\n        c = BytesIO()\n        np.savetxt(c, a, fmt='%02d : %3.1f')\n        c.seek(0)\n        lines = c.readlines()\n        assert_equal(lines, [b'01 : 2.0\\n', b'03 : 4.0\\n'])\n\n        # Specify delimiter, should be overiden\n        c = BytesIO()\n        np.savetxt(c, a, fmt='%02d : %3.1f', delimiter=',')\n        c.seek(0)\n        lines = c.readlines()\n        assert_equal(lines, [b'01 : 2.0\\n', b'03 : 4.0\\n'])\n\n        # Bad fmt, should raise a ValueError\n        c = BytesIO()\n        assert_raises(ValueError, np.savetxt, c, a, fmt=99)\n\n    def test_header_footer(self):\n        \"\"\"\n        Test the functionality of the header and footer keyword argument.\n        \"\"\"\n        c = BytesIO()\n        a = np.array([(1, 2), (3, 4)], dtype=np.int)\n        test_header_footer = 'Test header / footer'\n        # Test the header keyword argument\n        np.savetxt(c, a, fmt='%1d', header=test_header_footer)\n        c.seek(0)\n        assert_equal(c.read(),\n                     asbytes('# ' + test_header_footer + '\\n1 2\\n3 4\\n'))\n        # Test the footer keyword argument\n        c = BytesIO()\n        np.savetxt(c, a, fmt='%1d', footer=test_header_footer)\n        c.seek(0)\n        assert_equal(c.read(),\n                     asbytes('1 2\\n3 4\\n# ' + test_header_footer + '\\n'))\n        # Test the commentstr keyword argument used on the header\n        c = BytesIO()\n        commentstr = '% '\n        np.savetxt(c, a, fmt='%1d',\n                   header=test_header_footer, comments=commentstr)\n        c.seek(0)\n        assert_equal(c.read(),\n                     asbytes(commentstr + test_header_footer + '\\n' + '1 2\\n3 4\\n'))\n        # Test the commentstr keyword argument used on the footer\n        c = BytesIO()\n        commentstr = '% '\n        np.savetxt(c, a, fmt='%1d',\n                   footer=test_header_footer, comments=commentstr)\n        c.seek(0)\n        assert_equal(c.read(),\n                     asbytes('1 2\\n3 4\\n' + commentstr + test_header_footer + '\\n'))\n\n    def test_file_roundtrip(self):\n        f, name = mkstemp()\n        os.close(f)\n        try:\n            a = np.array([(1, 2), (3, 4)])\n            np.savetxt(name, a)\n            b = np.loadtxt(name)\n            assert_array_equal(a, b)\n        finally:\n            os.unlink(name)\n\n    def test_complex_arrays(self):\n        ncols = 2\n        nrows = 2\n        a = np.zeros((ncols, nrows), dtype=np.complex128)\n        re = np.pi\n        im = np.e\n        a[:] = re + 1.0j * im\n\n        # One format only\n        c = BytesIO()\n        np.savetxt(c, a, fmt=' %+.3e')\n        c.seek(0)\n        lines = c.readlines()\n        assert_equal(\n            lines,\n            [b' ( +3.142e+00+ +2.718e+00j)  ( +3.142e+00+ +2.718e+00j)\\n',\n             b' ( +3.142e+00+ +2.718e+00j)  ( +3.142e+00+ +2.718e+00j)\\n'])\n\n        # One format for each real and imaginary part\n        c = BytesIO()\n        np.savetxt(c, a, fmt='  %+.3e' * 2 * ncols)\n        c.seek(0)\n        lines = c.readlines()\n        assert_equal(\n            lines,\n            [b'  +3.142e+00  +2.718e+00  +3.142e+00  +2.718e+00\\n',\n             b'  +3.142e+00  +2.718e+00  +3.142e+00  +2.718e+00\\n'])\n\n        # One format for each complex number\n        c = BytesIO()\n        np.savetxt(c, a, fmt=['(%.3e%+.3ej)'] * ncols)\n        c.seek(0)\n        lines = c.readlines()\n        assert_equal(\n            lines,\n            [b'(3.142e+00+2.718e+00j) (3.142e+00+2.718e+00j)\\n',\n             b'(3.142e+00+2.718e+00j) (3.142e+00+2.718e+00j)\\n'])\n\n    def test_custom_writer(self):\n\n        class CustomWriter(list):\n            def write(self, text):\n                self.extend(text.split(b'\\n'))\n\n        w = CustomWriter()\n        a = np.array([(1, 2), (3, 4)])\n        np.savetxt(w, a)\n        b = np.loadtxt(w)\n        assert_array_equal(a, b)\n\n\nclass TestLoadTxt(TestCase):\n    def test_record(self):\n        c = TextIO()\n        c.write('1 2\\n3 4')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=[('x', np.int32), ('y', np.int32)])\n        a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])\n        assert_array_equal(x, a)\n\n        d = TextIO()\n        d.write('M 64.0 75.0\\nF 25.0 60.0')\n        d.seek(0)\n        mydescriptor = {'names': ('gender', 'age', 'weight'),\n                        'formats': ('S1', 'i4', 'f4')}\n        b = np.array([('M', 64.0, 75.0),\n                      ('F', 25.0, 60.0)], dtype=mydescriptor)\n        y = np.loadtxt(d, dtype=mydescriptor)\n        assert_array_equal(y, b)\n\n    def test_array(self):\n        c = TextIO()\n        c.write('1 2\\n3 4')\n\n        c.seek(0)\n        x = np.loadtxt(c, dtype=np.int)\n        a = np.array([[1, 2], [3, 4]], int)\n        assert_array_equal(x, a)\n\n        c.seek(0)\n        x = np.loadtxt(c, dtype=float)\n        a = np.array([[1, 2], [3, 4]], float)\n        assert_array_equal(x, a)\n\n    def test_1D(self):\n        c = TextIO()\n        c.write('1\\n2\\n3\\n4\\n')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int)\n        a = np.array([1, 2, 3, 4], int)\n        assert_array_equal(x, a)\n\n        c = TextIO()\n        c.write('1,2,3,4\\n')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int, delimiter=',')\n        a = np.array([1, 2, 3, 4], int)\n        assert_array_equal(x, a)\n\n    def test_missing(self):\n        c = TextIO()\n        c.write('1,2,3,,5\\n')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int, delimiter=',',\n                       converters={3: lambda s: int(s or - 999)})\n        a = np.array([1, 2, 3, -999, 5], int)\n        assert_array_equal(x, a)\n\n    def test_converters_with_usecols(self):\n        c = TextIO()\n        c.write('1,2,3,,5\\n6,7,8,9,10\\n')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int, delimiter=',',\n                       converters={3: lambda s: int(s or - 999)},\n                       usecols=(1, 3,))\n        a = np.array([[2, -999], [7, 9]], int)\n        assert_array_equal(x, a)\n\n    def test_comments(self):\n        c = TextIO()\n        c.write('# comment\\n1,2,3,5\\n')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int, delimiter=',',\n                       comments='#')\n        a = np.array([1, 2, 3, 5], int)\n        assert_array_equal(x, a)\n\n    def test_skiprows(self):\n        c = TextIO()\n        c.write('comment\\n1,2,3,5\\n')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int, delimiter=',',\n                       skiprows=1)\n        a = np.array([1, 2, 3, 5], int)\n        assert_array_equal(x, a)\n\n        c = TextIO()\n        c.write('# comment\\n1,2,3,5\\n')\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int, delimiter=',',\n                       skiprows=1)\n        a = np.array([1, 2, 3, 5], int)\n        assert_array_equal(x, a)\n\n    def test_usecols(self):\n        a = np.array([[1, 2], [3, 4]], float)\n        c = BytesIO()\n        np.savetxt(c, a)\n        c.seek(0)\n        x = np.loadtxt(c, dtype=float, usecols=(1,))\n        assert_array_equal(x, a[:, 1])\n\n        a = np.array([[1, 2, 3], [3, 4, 5]], float)\n        c = BytesIO()\n        np.savetxt(c, a)\n        c.seek(0)\n        x = np.loadtxt(c, dtype=float, usecols=(1, 2))\n        assert_array_equal(x, a[:, 1:])\n\n        # Testing with arrays instead of tuples.\n        c.seek(0)\n        x = np.loadtxt(c, dtype=float, usecols=np.array([1, 2]))\n        assert_array_equal(x, a[:, 1:])\n\n        # Checking with dtypes defined converters.\n        data = '''JOE 70.1 25.3\n                BOB 60.5 27.9\n                '''\n        c = TextIO(data)\n        names = ['stid', 'temp']\n        dtypes = ['S4', 'f8']\n        arr = np.loadtxt(c, usecols=(0, 2), dtype=list(zip(names, dtypes)))\n        assert_equal(arr['stid'], [b\"JOE\", b\"BOB\"])\n        assert_equal(arr['temp'], [25.3, 27.9])\n\n    def test_fancy_dtype(self):\n        c = TextIO()\n        c.write('1,2,3.0\\n4,5,6.0\\n')\n        c.seek(0)\n        dt = np.dtype([('x', int), ('y', [('t', int), ('s', float)])])\n        x = np.loadtxt(c, dtype=dt, delimiter=',')\n        a = np.array([(1, (2, 3.0)), (4, (5, 6.0))], dt)\n        assert_array_equal(x, a)\n\n    def test_shaped_dtype(self):\n        c = TextIO(\"aaaa  1.0  8.0  1 2 3 4 5 6\")\n        dt = np.dtype([('name', 'S4'), ('x', float), ('y', float),\n                       ('block', int, (2, 3))])\n        x = np.loadtxt(c, dtype=dt)\n        a = np.array([('aaaa', 1.0, 8.0, [[1, 2, 3], [4, 5, 6]])],\n                     dtype=dt)\n        assert_array_equal(x, a)\n\n    def test_3d_shaped_dtype(self):\n        c = TextIO(\"aaaa  1.0  8.0  1 2 3 4 5 6 7 8 9 10 11 12\")\n        dt = np.dtype([('name', 'S4'), ('x', float), ('y', float),\n                       ('block', int, (2, 2, 3))])\n        x = np.loadtxt(c, dtype=dt)\n        a = np.array([('aaaa', 1.0, 8.0,\n                       [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])],\n                     dtype=dt)\n        assert_array_equal(x, a)\n\n    def test_empty_file(self):\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\",\n                                    message=\"loadtxt: Empty input file:\")\n            c = TextIO()\n            x = np.loadtxt(c)\n            assert_equal(x.shape, (0,))\n            x = np.loadtxt(c, dtype=np.int64)\n            assert_equal(x.shape, (0,))\n            assert_(x.dtype == np.int64)\n\n    def test_unused_converter(self):\n        c = TextIO()\n        c.writelines(['1 21\\n', '3 42\\n'])\n        c.seek(0)\n        data = np.loadtxt(c, usecols=(1,),\n                          converters={0: lambda s: int(s, 16)})\n        assert_array_equal(data, [21, 42])\n\n        c.seek(0)\n        data = np.loadtxt(c, usecols=(1,),\n                          converters={1: lambda s: int(s, 16)})\n        assert_array_equal(data, [33, 66])\n\n    def test_dtype_with_object(self):\n        \"Test using an explicit dtype with an object\"\n        from datetime import date\n        import time\n        data = \"\"\" 1; 2001-01-01\n                   2; 2002-01-31 \"\"\"\n        ndtype = [('idx', int), ('code', np.object)]\n        func = lambda s: strptime(s.strip(), \"%Y-%m-%d\")\n        converters = {1: func}\n        test = np.loadtxt(TextIO(data), delimiter=\";\", dtype=ndtype,\n                          converters=converters)\n        control = np.array(\n            [(1, datetime(2001, 1, 1)), (2, datetime(2002, 1, 31))],\n            dtype=ndtype)\n        assert_equal(test, control)\n\n    def test_uint64_type(self):\n        tgt = (9223372043271415339, 9223372043271415853)\n        c = TextIO()\n        c.write(\"%s %s\" % tgt)\n        c.seek(0)\n        res = np.loadtxt(c, dtype=np.uint64)\n        assert_equal(res, tgt)\n\n    def test_int64_type(self):\n        tgt = (-9223372036854775807, 9223372036854775807)\n        c = TextIO()\n        c.write(\"%s %s\" % tgt)\n        c.seek(0)\n        res = np.loadtxt(c, dtype=np.int64)\n        assert_equal(res, tgt)\n\n    def test_universal_newline(self):\n        f, name = mkstemp()\n        os.write(f, b'1 21\\r3 42\\r')\n        os.close(f)\n\n        try:\n            data = np.loadtxt(name)\n            assert_array_equal(data, [[1, 21], [3, 42]])\n        finally:\n            os.unlink(name)\n\n    def test_empty_field_after_tab(self):\n        c = TextIO()\n        c.write('1 \\t2 \\t3\\tstart \\n4\\t5\\t6\\t  \\n7\\t8\\t9.5\\t')\n        c.seek(0)\n        dt = {'names': ('x', 'y', 'z', 'comment'),\n              'formats': ('<i4', '<i4', '<f4', '|S8')}\n        x = np.loadtxt(c, dtype=dt, delimiter='\\t')\n        a = np.array([b'start ', b'  ', b''])\n        assert_array_equal(x['comment'], a)\n\n    def test_structure_unpack(self):\n        txt = TextIO(\"M 21 72\\nF 35 58\")\n        dt = {'names': ('a', 'b', 'c'), 'formats': ('|S1', '<i4', '<f4')}\n        a, b, c = np.loadtxt(txt, dtype=dt, unpack=True)\n        assert_(a.dtype.str == '|S1')\n        assert_(b.dtype.str == '<i4')\n        assert_(c.dtype.str == '<f4')\n        assert_array_equal(a, np.array([b'M', b'F']))\n        assert_array_equal(b, np.array([21, 35]))\n        assert_array_equal(c, np.array([72.,  58.]))\n\n    def test_ndmin_keyword(self):\n        c = TextIO()\n        c.write('1,2,3\\n4,5,6')\n        c.seek(0)\n        assert_raises(ValueError, np.loadtxt, c, ndmin=3)\n        c.seek(0)\n        assert_raises(ValueError, np.loadtxt, c, ndmin=1.5)\n        c.seek(0)\n        x = np.loadtxt(c, dtype=int, delimiter=',', ndmin=1)\n        a = np.array([[1, 2, 3], [4, 5, 6]])\n        assert_array_equal(x, a)\n\n        d = TextIO()\n        d.write('0,1,2')\n        d.seek(0)\n        x = np.loadtxt(d, dtype=int, delimiter=',', ndmin=2)\n        assert_(x.shape == (1, 3))\n        d.seek(0)\n        x = np.loadtxt(d, dtype=int, delimiter=',', ndmin=1)\n        assert_(x.shape == (3,))\n        d.seek(0)\n        x = np.loadtxt(d, dtype=int, delimiter=',', ndmin=0)\n        assert_(x.shape == (3,))\n\n        e = TextIO()\n        e.write('0\\n1\\n2')\n        e.seek(0)\n        x = np.loadtxt(e, dtype=int, delimiter=',', ndmin=2)\n        assert_(x.shape == (3, 1))\n        e.seek(0)\n        x = np.loadtxt(e, dtype=int, delimiter=',', ndmin=1)\n        assert_(x.shape == (3,))\n        e.seek(0)\n        x = np.loadtxt(e, dtype=int, delimiter=',', ndmin=0)\n        assert_(x.shape == (3,))\n\n        # Test ndmin kw with empty file.\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\",\n                                    message=\"loadtxt: Empty input file:\")\n            f = TextIO()\n            assert_(np.loadtxt(f, ndmin=2).shape == (0, 1,))\n            assert_(np.loadtxt(f, ndmin=1).shape == (0,))\n\n    def test_generator_source(self):\n        def count():\n            for i in range(10):\n                yield \"%d\" % i\n\n        res = np.loadtxt(count())\n        assert_array_equal(res, np.arange(10))\n\n\nclass Testfromregex(TestCase):\n    # np.fromregex expects files opened in binary mode.\n    def test_record(self):\n        c = TextIO()\n        c.write('1.312 foo\\n1.534 bar\\n4.444 qux')\n        c.seek(0)\n\n        dt = [('num', np.float64), ('val', 'S3')]\n        x = np.fromregex(c, r\"([0-9.]+)\\s+(...)\", dt)\n        a = np.array([(1.312, 'foo'), (1.534, 'bar'), (4.444, 'qux')],\n                     dtype=dt)\n        assert_array_equal(x, a)\n\n    def test_record_2(self):\n        c = TextIO()\n        c.write('1312 foo\\n1534 bar\\n4444 qux')\n        c.seek(0)\n\n        dt = [('num', np.int32), ('val', 'S3')]\n        x = np.fromregex(c, r\"(\\d+)\\s+(...)\", dt)\n        a = np.array([(1312, 'foo'), (1534, 'bar'), (4444, 'qux')],\n                     dtype=dt)\n        assert_array_equal(x, a)\n\n    def test_record_3(self):\n        c = TextIO()\n        c.write('1312 foo\\n1534 bar\\n4444 qux')\n        c.seek(0)\n\n        dt = [('num', np.float64)]\n        x = np.fromregex(c, r\"(\\d+)\\s+...\", dt)\n        a = np.array([(1312,), (1534,), (4444,)], dtype=dt)\n        assert_array_equal(x, a)\n\n\n#####--------------------------------------------------------------------------\n\n\nclass TestFromTxt(TestCase):\n    #\n    def test_record(self):\n        \"Test w/ explicit dtype\"\n        data = TextIO('1 2\\n3 4')\n#        data.seek(0)\n        test = np.ndfromtxt(data, dtype=[('x', np.int32), ('y', np.int32)])\n        control = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])\n        assert_equal(test, control)\n        #\n        data = TextIO('M 64.0 75.0\\nF 25.0 60.0')\n#        data.seek(0)\n        descriptor = {'names': ('gender', 'age', 'weight'),\n                      'formats': ('S1', 'i4', 'f4')}\n        control = np.array([('M', 64.0, 75.0), ('F', 25.0, 60.0)],\n                           dtype=descriptor)\n        test = np.ndfromtxt(data, dtype=descriptor)\n        assert_equal(test, control)\n\n    def test_array(self):\n        \"Test outputing a standard ndarray\"\n        data = TextIO('1 2\\n3 4')\n        control = np.array([[1, 2], [3, 4]], dtype=int)\n        test = np.ndfromtxt(data, dtype=int)\n        assert_array_equal(test, control)\n        #\n        data.seek(0)\n        control = np.array([[1, 2], [3, 4]], dtype=float)\n        test = np.loadtxt(data, dtype=float)\n        assert_array_equal(test, control)\n\n    def test_1D(self):\n        \"Test squeezing to 1D\"\n        control = np.array([1, 2, 3, 4], int)\n        #\n        data = TextIO('1\\n2\\n3\\n4\\n')\n        test = np.ndfromtxt(data, dtype=int)\n        assert_array_equal(test, control)\n        #\n        data = TextIO('1,2,3,4\\n')\n        test = np.ndfromtxt(data, dtype=int, delimiter=',')\n        assert_array_equal(test, control)\n\n    def test_comments(self):\n        \"Test the stripping of comments\"\n        control = np.array([1, 2, 3, 5], int)\n        # Comment on its own line\n        data = TextIO('# comment\\n1,2,3,5\\n')\n        test = np.ndfromtxt(data, dtype=int, delimiter=',', comments='#')\n        assert_equal(test, control)\n        # Comment at the end of a line\n        data = TextIO('1,2,3,5# comment\\n')\n        test = np.ndfromtxt(data, dtype=int, delimiter=',', comments='#')\n        assert_equal(test, control)\n\n    def test_skiprows(self):\n        \"Test row skipping\"\n        control = np.array([1, 2, 3, 5], int)\n        kwargs = dict(dtype=int, delimiter=',')\n        #\n        data = TextIO('comment\\n1,2,3,5\\n')\n        test = np.ndfromtxt(data, skip_header=1, **kwargs)\n        assert_equal(test, control)\n        #\n        data = TextIO('# comment\\n1,2,3,5\\n')\n        test = np.loadtxt(data, skiprows=1, **kwargs)\n        assert_equal(test, control)\n\n    def test_skip_footer(self):\n        data = [\"# %i\" % i for i in range(1, 6)]\n        data.append(\"A, B, C\")\n        data.extend([\"%i,%3.1f,%03s\" % (i, i, i) for i in range(51)])\n        data[-1] = \"99,99\"\n        kwargs = dict(delimiter=\",\", names=True, skip_header=5, skip_footer=10)\n        test = np.genfromtxt(TextIO(\"\\n\".join(data)), **kwargs)\n        ctrl = np.array([(\"%f\" % i, \"%f\" % i, \"%f\" % i) for i in range(41)],\n                        dtype=[(_, float) for _ in \"ABC\"])\n        assert_equal(test, ctrl)\n\n    def test_skip_footer_with_invalid(self):\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\")\n            basestr = '1 1\\n2 2\\n3 3\\n4 4\\n5  \\n6  \\n7  \\n'\n            # Footer too small to get rid of all invalid values\n            assert_raises(ValueError, np.genfromtxt,\n                          TextIO(basestr), skip_footer=1)\n    #        except ValueError:\n    #            pass\n            a = np.genfromtxt(\n                TextIO(basestr), skip_footer=1, invalid_raise=False)\n            assert_equal(a, np.array([[1., 1.], [2., 2.], [3., 3.], [4., 4.]]))\n            #\n            a = np.genfromtxt(TextIO(basestr), skip_footer=3)\n            assert_equal(a, np.array([[1., 1.], [2., 2.], [3., 3.], [4., 4.]]))\n            #\n            basestr = '1 1\\n2  \\n3 3\\n4 4\\n5  \\n6 6\\n7 7\\n'\n            a = np.genfromtxt(\n                TextIO(basestr), skip_footer=1, invalid_raise=False)\n            assert_equal(a, np.array([[1., 1.], [3., 3.], [4., 4.], [6., 6.]]))\n            a = np.genfromtxt(\n                TextIO(basestr), skip_footer=3, invalid_raise=False)\n            assert_equal(a, np.array([[1., 1.], [3., 3.], [4., 4.]]))\n\n    def test_header(self):\n        \"Test retrieving a header\"\n        data = TextIO('gender age weight\\nM 64.0 75.0\\nF 25.0 60.0')\n        test = np.ndfromtxt(data, dtype=None, names=True)\n        control = {'gender': np.array([b'M', b'F']),\n                   'age': np.array([64.0, 25.0]),\n                   'weight': np.array([75.0, 60.0])}\n        assert_equal(test['gender'], control['gender'])\n        assert_equal(test['age'], control['age'])\n        assert_equal(test['weight'], control['weight'])\n\n    def test_auto_dtype(self):\n        \"Test the automatic definition of the output dtype\"\n        data = TextIO('A 64 75.0 3+4j True\\nBCD 25 60.0 5+6j False')\n        test = np.ndfromtxt(data, dtype=None)\n        control = [np.array([b'A', b'BCD']),\n                   np.array([64, 25]),\n                   np.array([75.0, 60.0]),\n                   np.array([3 + 4j, 5 + 6j]),\n                   np.array([True, False]), ]\n        assert_equal(test.dtype.names, ['f0', 'f1', 'f2', 'f3', 'f4'])\n        for (i, ctrl) in enumerate(control):\n            assert_equal(test['f%i' % i], ctrl)\n\n    def test_auto_dtype_uniform(self):\n        \"Tests whether the output dtype can be uniformized\"\n        data = TextIO('1 2 3 4\\n5 6 7 8\\n')\n        test = np.ndfromtxt(data, dtype=None)\n        control = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\n        assert_equal(test, control)\n\n    def test_fancy_dtype(self):\n        \"Check that a nested dtype isn't MIA\"\n        data = TextIO('1,2,3.0\\n4,5,6.0\\n')\n        fancydtype = np.dtype([('x', int), ('y', [('t', int), ('s', float)])])\n        test = np.ndfromtxt(data, dtype=fancydtype, delimiter=',')\n        control = np.array([(1, (2, 3.0)), (4, (5, 6.0))], dtype=fancydtype)\n        assert_equal(test, control)\n\n    def test_names_overwrite(self):\n        \"Test overwriting the names of the dtype\"\n        descriptor = {'names': ('g', 'a', 'w'),\n                      'formats': ('S1', 'i4', 'f4')}\n        data = TextIO(b'M 64.0 75.0\\nF 25.0 60.0')\n        names = ('gender', 'age', 'weight')\n        test = np.ndfromtxt(data, dtype=descriptor, names=names)\n        descriptor['names'] = names\n        control = np.array([('M', 64.0, 75.0),\n                            ('F', 25.0, 60.0)], dtype=descriptor)\n        assert_equal(test, control)\n\n    def test_commented_header(self):\n        \"Check that names can be retrieved even if the line is commented out.\"\n        data = TextIO(\"\"\"\n#gender age weight\nM   21  72.100000\nF   35  58.330000\nM   33  21.99\n        \"\"\")\n        # The # is part of the first name and should be deleted automatically.\n        test = np.genfromtxt(data, names=True, dtype=None)\n        ctrl = np.array([('M', 21, 72.1), ('F', 35, 58.33), ('M', 33, 21.99)],\n                        dtype=[('gender', '|S1'), ('age', int), ('weight', float)])\n        assert_equal(test, ctrl)\n        # Ditto, but we should get rid of the first element\n        data = TextIO(b\"\"\"\n# gender age weight\nM   21  72.100000\nF   35  58.330000\nM   33  21.99\n        \"\"\")\n        test = np.genfromtxt(data, names=True, dtype=None)\n        assert_equal(test, ctrl)\n\n    def test_autonames_and_usecols(self):\n        \"Tests names and usecols\"\n        data = TextIO('A B C D\\n aaaa 121 45 9.1')\n        test = np.ndfromtxt(data, usecols=('A', 'C', 'D'),\n                            names=True, dtype=None)\n        control = np.array(('aaaa', 45, 9.1),\n                           dtype=[('A', '|S4'), ('C', int), ('D', float)])\n        assert_equal(test, control)\n\n    def test_converters_with_usecols(self):\n        \"Test the combination user-defined converters and usecol\"\n        data = TextIO('1,2,3,,5\\n6,7,8,9,10\\n')\n        test = np.ndfromtxt(data, dtype=int, delimiter=',',\n                            converters={3: lambda s: int(s or - 999)},\n                            usecols=(1, 3,))\n        control = np.array([[2, -999], [7, 9]], int)\n        assert_equal(test, control)\n\n    def test_converters_with_usecols_and_names(self):\n        \"Tests names and usecols\"\n        data = TextIO('A B C D\\n aaaa 121 45 9.1')\n        test = np.ndfromtxt(data, usecols=('A', 'C', 'D'), names=True,\n                            dtype=None, converters={'C': lambda s: 2 * int(s)})\n        control = np.array(('aaaa', 90, 9.1),\n                           dtype=[('A', '|S4'), ('C', int), ('D', float)])\n        assert_equal(test, control)\n\n    def test_converters_cornercases(self):\n        \"Test the conversion to datetime.\"\n        converter = {\n            'date': lambda s: strptime(s, '%Y-%m-%d %H:%M:%SZ')}\n        data = TextIO('2009-02-03 12:00:00Z, 72214.0')\n        test = np.ndfromtxt(data, delimiter=',', dtype=None,\n                            names=['date', 'stid'], converters=converter)\n        control = np.array((datetime(2009, 2, 3), 72214.),\n                           dtype=[('date', np.object_), ('stid', float)])\n        assert_equal(test, control)\n\n    def test_converters_cornercases2(self):\n        \"Test the conversion to datetime64.\"\n        converter = {\n            'date': lambda s: np.datetime64(strptime(s, '%Y-%m-%d %H:%M:%SZ'))}\n        data = TextIO('2009-02-03 12:00:00Z, 72214.0')\n        test = np.ndfromtxt(data, delimiter=',', dtype=None,\n                            names=['date', 'stid'], converters=converter)\n        control = np.array((datetime(2009, 2, 3), 72214.),\n                           dtype=[('date', 'datetime64[us]'), ('stid', float)])\n        assert_equal(test, control)\n\n    def test_unused_converter(self):\n        \"Test whether unused converters are forgotten\"\n        data = TextIO(\"1 21\\n  3 42\\n\")\n        test = np.ndfromtxt(data, usecols=(1,),\n                            converters={0: lambda s: int(s, 16)})\n        assert_equal(test, [21, 42])\n        #\n        data.seek(0)\n        test = np.ndfromtxt(data, usecols=(1,),\n                            converters={1: lambda s: int(s, 16)})\n        assert_equal(test, [33, 66])\n\n    def test_invalid_converter(self):\n        strip_rand = lambda x: float((b'r' in x.lower() and x.split()[-1]) or\n                                     (b'r' not in x.lower() and x.strip() or 0.0))\n        strip_per = lambda x: float((b'%' in x.lower() and x.split()[0]) or\n                                    (b'%' not in x.lower() and x.strip() or 0.0))\n        s = TextIO(\"D01N01,10/1/2003 ,1 %,R 75,400,600\\r\\n\"\n                   \"L24U05,12/5/2003, 2 %,1,300, 150.5\\r\\n\"\n                   \"D02N03,10/10/2004,R 1,,7,145.55\")\n        kwargs = dict(\n            converters={2: strip_per, 3: strip_rand}, delimiter=\",\",\n            dtype=None)\n        assert_raises(ConverterError, np.genfromtxt, s, **kwargs)\n\n    def test_tricky_converter_bug1666(self):\n        \"Test some corner case\"\n        s = TextIO('q1,2\\nq3,4')\n        cnv = lambda s: float(s[1:])\n        test = np.genfromtxt(s, delimiter=',', converters={0: cnv})\n        control = np.array([[1., 2.], [3., 4.]])\n        assert_equal(test, control)\n\n    def test_dtype_with_converters(self):\n        dstr = \"2009; 23; 46\"\n        test = np.ndfromtxt(TextIO(dstr,),\n                            delimiter=\";\", dtype=float, converters={0: bytes})\n        control = np.array([('2009', 23., 46)],\n                           dtype=[('f0', '|S4'), ('f1', float), ('f2', float)])\n        assert_equal(test, control)\n        test = np.ndfromtxt(TextIO(dstr,),\n                            delimiter=\";\", dtype=float, converters={0: float})\n        control = np.array([2009., 23., 46],)\n        assert_equal(test, control)\n\n    def test_dtype_with_object(self):\n        \"Test using an explicit dtype with an object\"\n        from datetime import date\n        import time\n        data = \"\"\" 1; 2001-01-01\n                   2; 2002-01-31 \"\"\"\n        ndtype = [('idx', int), ('code', np.object)]\n        func = lambda s: strptime(s.strip(), \"%Y-%m-%d\")\n        converters = {1: func}\n        test = np.genfromtxt(TextIO(data), delimiter=\";\", dtype=ndtype,\n                             converters=converters)\n        control = np.array(\n            [(1, datetime(2001, 1, 1)), (2, datetime(2002, 1, 31))],\n            dtype=ndtype)\n        assert_equal(test, control)\n        #\n        ndtype = [('nest', [('idx', int), ('code', np.object)])]\n        try:\n            test = np.genfromtxt(TextIO(data), delimiter=\";\",\n                                 dtype=ndtype, converters=converters)\n        except NotImplementedError:\n            pass\n        else:\n            errmsg = \"Nested dtype involving objects should be supported.\"\n            raise AssertionError(errmsg)\n\n    def test_userconverters_with_explicit_dtype(self):\n        \"Test user_converters w/ explicit (standard) dtype\"\n        data = TextIO('skip,skip,2001-01-01,1.0,skip')\n        test = np.genfromtxt(data, delimiter=\",\", names=None, dtype=float,\n                             usecols=(2, 3), converters={2: bytes})\n        control = np.array([('2001-01-01', 1.)],\n                           dtype=[('', '|S10'), ('', float)])\n        assert_equal(test, control)\n\n    def test_spacedelimiter(self):\n        \"Test space delimiter\"\n        data = TextIO(\"1  2  3  4   5\\n6  7  8  9  10\")\n        test = np.ndfromtxt(data)\n        control = np.array([[1., 2., 3., 4., 5.],\n                            [6., 7., 8., 9., 10.]])\n        assert_equal(test, control)\n\n    def test_integer_delimiter(self):\n        \"Test using an integer for delimiter\"\n        data = \"  1  2  3\\n  4  5 67\\n890123  4\"\n        test = np.genfromtxt(TextIO(data), delimiter=3)\n        control = np.array([[1, 2, 3], [4, 5, 67], [890, 123, 4]])\n        assert_equal(test, control)\n\n    def test_missing(self):\n        data = TextIO('1,2,3,,5\\n')\n        test = np.ndfromtxt(data, dtype=int, delimiter=',',\n                            converters={3: lambda s: int(s or - 999)})\n        control = np.array([1, 2, 3, -999, 5], int)\n        assert_equal(test, control)\n\n    def test_missing_with_tabs(self):\n        \"Test w/ a delimiter tab\"\n        txt = \"1\\t2\\t3\\n\\t2\\t\\n1\\t\\t3\"\n        test = np.genfromtxt(TextIO(txt), delimiter=\"\\t\",\n                             usemask=True,)\n        ctrl_d = np.array([(1, 2, 3), (np.nan, 2, np.nan), (1, np.nan, 3)],)\n        ctrl_m = np.array([(0, 0, 0), (1, 0, 1), (0, 1, 0)], dtype=bool)\n        assert_equal(test.data, ctrl_d)\n        assert_equal(test.mask, ctrl_m)\n\n    def test_usecols(self):\n        \"Test the selection of columns\"\n        # Select 1 column\n        control = np.array([[1, 2], [3, 4]], float)\n        data = TextIO()\n        np.savetxt(data, control)\n        data.seek(0)\n        test = np.ndfromtxt(data, dtype=float, usecols=(1,))\n        assert_equal(test, control[:, 1])\n        #\n        control = np.array([[1, 2, 3], [3, 4, 5]], float)\n        data = TextIO()\n        np.savetxt(data, control)\n        data.seek(0)\n        test = np.ndfromtxt(data, dtype=float, usecols=(1, 2))\n        assert_equal(test, control[:, 1:])\n        # Testing with arrays instead of tuples.\n        data.seek(0)\n        test = np.ndfromtxt(data, dtype=float, usecols=np.array([1, 2]))\n        assert_equal(test, control[:, 1:])\n\n    def test_usecols_as_css(self):\n        \"Test giving usecols with a comma-separated string\"\n        data = \"1 2 3\\n4 5 6\"\n        test = np.genfromtxt(TextIO(data),\n                             names=\"a, b, c\", usecols=\"a, c\")\n        ctrl = np.array([(1, 3), (4, 6)], dtype=[(_, float) for _ in \"ac\"])\n        assert_equal(test, ctrl)\n\n    def test_usecols_with_structured_dtype(self):\n        \"Test usecols with an explicit structured dtype\"\n        data = TextIO(\"JOE 70.1 25.3\\nBOB 60.5 27.9\")\n        names = ['stid', 'temp']\n        dtypes = ['S4', 'f8']\n        test = np.ndfromtxt(\n            data, usecols=(0, 2), dtype=list(zip(names, dtypes)))\n        assert_equal(test['stid'], [b\"JOE\", b\"BOB\"])\n        assert_equal(test['temp'], [25.3, 27.9])\n\n    def test_usecols_with_integer(self):\n        \"Test usecols with an integer\"\n        test = np.genfromtxt(TextIO(b\"1 2 3\\n4 5 6\"), usecols=0)\n        assert_equal(test, np.array([1., 4.]))\n\n    def test_usecols_with_named_columns(self):\n        \"Test usecols with named columns\"\n        ctrl = np.array([(1, 3), (4, 6)], dtype=[('a', float), ('c', float)])\n        data = \"1 2 3\\n4 5 6\"\n        kwargs = dict(names=\"a, b, c\")\n        test = np.genfromtxt(TextIO(data), usecols=(0, -1), **kwargs)\n        assert_equal(test, ctrl)\n        test = np.genfromtxt(TextIO(data),\n                             usecols=('a', 'c'), **kwargs)\n        assert_equal(test, ctrl)\n\n    def test_empty_file(self):\n        \"Test that an empty file raises the proper warning.\"\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\",\n                                    message=\"genfromtxt: Empty input file:\")\n            data = TextIO()\n            test = np.genfromtxt(data)\n            assert_equal(test, np.array([]))\n\n    def test_fancy_dtype_alt(self):\n        \"Check that a nested dtype isn't MIA\"\n        data = TextIO('1,2,3.0\\n4,5,6.0\\n')\n        fancydtype = np.dtype([('x', int), ('y', [('t', int), ('s', float)])])\n        test = np.mafromtxt(data, dtype=fancydtype, delimiter=',')\n        control = ma.array([(1, (2, 3.0)), (4, (5, 6.0))], dtype=fancydtype)\n        assert_equal(test, control)\n\n    def test_shaped_dtype(self):\n        c = TextIO(\"aaaa  1.0  8.0  1 2 3 4 5 6\")\n        dt = np.dtype([('name', 'S4'), ('x', float), ('y', float),\n                       ('block', int, (2, 3))])\n        x = np.ndfromtxt(c, dtype=dt)\n        a = np.array([('aaaa', 1.0, 8.0, [[1, 2, 3], [4, 5, 6]])],\n                     dtype=dt)\n        assert_array_equal(x, a)\n\n    def test_withmissing(self):\n        data = TextIO('A,B\\n0,1\\n2,N/A')\n        kwargs = dict(delimiter=\",\", missing_values=\"N/A\", names=True)\n        test = np.mafromtxt(data, dtype=None, **kwargs)\n        control = ma.array([(0, 1), (2, -1)],\n                           mask=[(False, False), (False, True)],\n                           dtype=[('A', np.int), ('B', np.int)])\n        assert_equal(test, control)\n        assert_equal(test.mask, control.mask)\n        #\n        data.seek(0)\n        test = np.mafromtxt(data, **kwargs)\n        control = ma.array([(0, 1), (2, -1)],\n                           mask=[(False, False), (False, True)],\n                           dtype=[('A', np.float), ('B', np.float)])\n        assert_equal(test, control)\n        assert_equal(test.mask, control.mask)\n\n    def test_user_missing_values(self):\n        data = \"A, B, C\\n0, 0., 0j\\n1, N/A, 1j\\n-9, 2.2, N/A\\n3, -99, 3j\"\n        basekwargs = dict(dtype=None, delimiter=\",\", names=True,)\n        mdtype = [('A', int), ('B', float), ('C', complex)]\n        #\n        test = np.mafromtxt(TextIO(data), missing_values=\"N/A\",\n                            **basekwargs)\n        control = ma.array([(0, 0.0, 0j), (1, -999, 1j),\n                            (-9, 2.2, -999j), (3, -99, 3j)],\n                           mask=[(0, 0, 0), (0, 1, 0), (0, 0, 1), (0, 0, 0)],\n                           dtype=mdtype)\n        assert_equal(test, control)\n        #\n        basekwargs['dtype'] = mdtype\n        test = np.mafromtxt(TextIO(data),\n                            missing_values={0: -9, 1: -99, 2: -999j}, **basekwargs)\n        control = ma.array([(0, 0.0, 0j), (1, -999, 1j),\n                            (-9, 2.2, -999j), (3, -99, 3j)],\n                           mask=[(0, 0, 0), (0, 1, 0), (1, 0, 1), (0, 1, 0)],\n                           dtype=mdtype)\n        assert_equal(test, control)\n        #\n        test = np.mafromtxt(TextIO(data),\n                            missing_values={0: -9, 'B': -99, 'C': -999j},\n                            **basekwargs)\n        control = ma.array([(0, 0.0, 0j), (1, -999, 1j),\n                            (-9, 2.2, -999j), (3, -99, 3j)],\n                           mask=[(0, 0, 0), (0, 1, 0), (1, 0, 1), (0, 1, 0)],\n                           dtype=mdtype)\n        assert_equal(test, control)\n\n    def test_user_filling_values(self):\n        \"Test with missing and filling values\"\n        ctrl = np.array([(0, 3), (4, -999)], dtype=[('a', int), ('b', int)])\n        data = \"N/A, 2, 3\\n4, ,???\"\n        kwargs = dict(delimiter=\",\",\n                      dtype=int,\n                      names=\"a,b,c\",\n                      missing_values={0: \"N/A\", 'b': \" \", 2: \"???\"},\n                      filling_values={0: 0, 'b': 0, 2: -999})\n        test = np.genfromtxt(TextIO(data), **kwargs)\n        ctrl = np.array([(0, 2, 3), (4, 0, -999)],\n                        dtype=[(_, int) for _ in \"abc\"])\n        assert_equal(test, ctrl)\n        #\n        test = np.genfromtxt(TextIO(data), usecols=(0, -1), **kwargs)\n        ctrl = np.array([(0, 3), (4, -999)], dtype=[(_, int) for _ in \"ac\"])\n        assert_equal(test, ctrl)\n\n    def test_withmissing_float(self):\n        data = TextIO('A,B\\n0,1.5\\n2,-999.00')\n        test = np.mafromtxt(data, dtype=None, delimiter=',',\n                            missing_values='-999.0', names=True,)\n        control = ma.array([(0, 1.5), (2, -1.)],\n                           mask=[(False, False), (False, True)],\n                           dtype=[('A', np.int), ('B', np.float)])\n        assert_equal(test, control)\n        assert_equal(test.mask, control.mask)\n\n    def test_with_masked_column_uniform(self):\n        \"Test masked column\"\n        data = TextIO('1 2 3\\n4 5 6\\n')\n        test = np.genfromtxt(data, dtype=None,\n                             missing_values='2,5', usemask=True)\n        control = ma.array([[1, 2, 3], [4, 5, 6]], mask=[[0, 1, 0], [0, 1, 0]])\n        assert_equal(test, control)\n\n    def test_with_masked_column_various(self):\n        \"Test masked column\"\n        data = TextIO('True 2 3\\nFalse 5 6\\n')\n        test = np.genfromtxt(data, dtype=None,\n                             missing_values='2,5', usemask=True)\n        control = ma.array([(1, 2, 3), (0, 5, 6)],\n                           mask=[(0, 1, 0), (0, 1, 0)],\n                           dtype=[('f0', bool), ('f1', bool), ('f2', int)])\n        assert_equal(test, control)\n\n    def test_invalid_raise(self):\n        \"Test invalid raise\"\n        data = [\"1, 1, 1, 1, 1\"] * 50\n        for i in range(5):\n            data[10 * i] = \"2, 2, 2, 2 2\"\n        data.insert(0, \"a, b, c, d, e\")\n        mdata = TextIO(\"\\n\".join(data))\n        #\n        kwargs = dict(delimiter=\",\", dtype=None, names=True)\n        # XXX: is there a better way to get the return value of the callable in\n        # assert_warns ?\n        ret = {}\n\n        def f(_ret={}):\n            _ret['mtest'] = np.ndfromtxt(mdata, invalid_raise=False, **kwargs)\n        assert_warns(ConversionWarning, f, _ret=ret)\n        mtest = ret['mtest']\n        assert_equal(len(mtest), 45)\n        assert_equal(mtest, np.ones(45, dtype=[(_, int) for _ in 'abcde']))\n        #\n        mdata.seek(0)\n        assert_raises(ValueError, np.ndfromtxt, mdata,\n                      delimiter=\",\", names=True)\n\n    def test_invalid_raise_with_usecols(self):\n        \"Test invalid_raise with usecols\"\n        data = [\"1, 1, 1, 1, 1\"] * 50\n        for i in range(5):\n            data[10 * i] = \"2, 2, 2, 2 2\"\n        data.insert(0, \"a, b, c, d, e\")\n        mdata = TextIO(\"\\n\".join(data))\n        kwargs = dict(delimiter=\",\", dtype=None, names=True,\n                      invalid_raise=False)\n        # XXX: is there a better way to get the return value of the callable in\n        # assert_warns ?\n        ret = {}\n\n        def f(_ret={}):\n            _ret['mtest'] = np.ndfromtxt(mdata, usecols=(0, 4), **kwargs)\n        assert_warns(ConversionWarning, f, _ret=ret)\n        mtest = ret['mtest']\n        assert_equal(len(mtest), 45)\n        assert_equal(mtest, np.ones(45, dtype=[(_, int) for _ in 'ae']))\n        #\n        mdata.seek(0)\n        mtest = np.ndfromtxt(mdata, usecols=(0, 1), **kwargs)\n        assert_equal(len(mtest), 50)\n        control = np.ones(50, dtype=[(_, int) for _ in 'ab'])\n        control[[10 * _ for _ in range(5)]] = (2, 2)\n        assert_equal(mtest, control)\n\n    def test_inconsistent_dtype(self):\n        \"Test inconsistent dtype\"\n        data = [\"1, 1, 1, 1, -1.1\"] * 50\n        mdata = TextIO(\"\\n\".join(data))\n\n        converters = {4: lambda x: \"(%s)\" % x}\n        kwargs = dict(delimiter=\",\", converters=converters,\n                      dtype=[(_, int) for _ in 'abcde'],)\n        assert_raises(ValueError, np.genfromtxt, mdata, **kwargs)\n\n    def test_default_field_format(self):\n        \"Test default format\"\n        data = \"0, 1, 2.3\\n4, 5, 6.7\"\n        mtest = np.ndfromtxt(TextIO(data),\n                             delimiter=\",\", dtype=None, defaultfmt=\"f%02i\")\n        ctrl = np.array([(0, 1, 2.3), (4, 5, 6.7)],\n                        dtype=[(\"f00\", int), (\"f01\", int), (\"f02\", float)])\n        assert_equal(mtest, ctrl)\n\n    def test_single_dtype_wo_names(self):\n        \"Test single dtype w/o names\"\n        data = \"0, 1, 2.3\\n4, 5, 6.7\"\n        mtest = np.ndfromtxt(TextIO(data),\n                             delimiter=\",\", dtype=float, defaultfmt=\"f%02i\")\n        ctrl = np.array([[0., 1., 2.3], [4., 5., 6.7]], dtype=float)\n        assert_equal(mtest, ctrl)\n\n    def test_single_dtype_w_explicit_names(self):\n        \"Test single dtype w explicit names\"\n        data = \"0, 1, 2.3\\n4, 5, 6.7\"\n        mtest = np.ndfromtxt(TextIO(data),\n                             delimiter=\",\", dtype=float, names=\"a, b, c\")\n        ctrl = np.array([(0., 1., 2.3), (4., 5., 6.7)],\n                        dtype=[(_, float) for _ in \"abc\"])\n        assert_equal(mtest, ctrl)\n\n    def test_single_dtype_w_implicit_names(self):\n        \"Test single dtype w implicit names\"\n        data = \"a, b, c\\n0, 1, 2.3\\n4, 5, 6.7\"\n        mtest = np.ndfromtxt(TextIO(data),\n                             delimiter=\",\", dtype=float, names=True)\n        ctrl = np.array([(0., 1., 2.3), (4., 5., 6.7)],\n                        dtype=[(_, float) for _ in \"abc\"])\n        assert_equal(mtest, ctrl)\n\n    def test_easy_structured_dtype(self):\n        \"Test easy structured dtype\"\n        data = \"0, 1, 2.3\\n4, 5, 6.7\"\n        mtest = np.ndfromtxt(TextIO(data), delimiter=\",\",\n                             dtype=(int, float, float), defaultfmt=\"f_%02i\")\n        ctrl = np.array([(0, 1., 2.3), (4, 5., 6.7)],\n                        dtype=[(\"f_00\", int), (\"f_01\", float), (\"f_02\", float)])\n        assert_equal(mtest, ctrl)\n\n    def test_autostrip(self):\n        \"Test autostrip\"\n        data = \"01/01/2003  , 1.3,   abcde\"\n        kwargs = dict(delimiter=\",\", dtype=None)\n        mtest = np.ndfromtxt(TextIO(data), **kwargs)\n        ctrl = np.array([('01/01/2003  ', 1.3, '   abcde')],\n                        dtype=[('f0', '|S12'), ('f1', float), ('f2', '|S8')])\n        assert_equal(mtest, ctrl)\n        mtest = np.ndfromtxt(TextIO(data), autostrip=True, **kwargs)\n        ctrl = np.array([('01/01/2003', 1.3, 'abcde')],\n                        dtype=[('f0', '|S10'), ('f1', float), ('f2', '|S5')])\n        assert_equal(mtest, ctrl)\n\n    def test_replace_space(self):\n        \"Test the 'replace_space' option\"\n        txt = \"A.A, B (B), C:C\\n1, 2, 3.14\"\n        # Test default: replace ' ' by '_' and delete non-alphanum chars\n        test = np.genfromtxt(TextIO(txt),\n                             delimiter=\",\", names=True, dtype=None)\n        ctrl_dtype = [(\"AA\", int), (\"B_B\", int), (\"CC\", float)]\n        ctrl = np.array((1, 2, 3.14), dtype=ctrl_dtype)\n        assert_equal(test, ctrl)\n        # Test: no replace, no delete\n        test = np.genfromtxt(TextIO(txt),\n                             delimiter=\",\", names=True, dtype=None,\n                             replace_space='', deletechars='')\n        ctrl_dtype = [(\"A.A\", int), (\"B (B)\", int), (\"C:C\", float)]\n        ctrl = np.array((1, 2, 3.14), dtype=ctrl_dtype)\n        assert_equal(test, ctrl)\n        # Test: no delete (spaces are replaced by _)\n        test = np.genfromtxt(TextIO(txt),\n                             delimiter=\",\", names=True, dtype=None,\n                             deletechars='')\n        ctrl_dtype = [(\"A.A\", int), (\"B_(B)\", int), (\"C:C\", float)]\n        ctrl = np.array((1, 2, 3.14), dtype=ctrl_dtype)\n        assert_equal(test, ctrl)\n\n    def test_incomplete_names(self):\n        \"Test w/ incomplete names\"\n        data = \"A,,C\\n0,1,2\\n3,4,5\"\n        kwargs = dict(delimiter=\",\", names=True)\n        # w/ dtype=None\n        ctrl = np.array([(0, 1, 2), (3, 4, 5)],\n                        dtype=[(_, int) for _ in ('A', 'f0', 'C')])\n        test = np.ndfromtxt(TextIO(data), dtype=None, **kwargs)\n        assert_equal(test, ctrl)\n        # w/ default dtype\n        ctrl = np.array([(0, 1, 2), (3, 4, 5)],\n                        dtype=[(_, float) for _ in ('A', 'f0', 'C')])\n        test = np.ndfromtxt(TextIO(data), **kwargs)\n\n    def test_names_auto_completion(self):\n        \"Make sure that names are properly completed\"\n        data = \"1 2 3\\n 4 5 6\"\n        test = np.genfromtxt(TextIO(data),\n                             dtype=(int, float, int), names=\"a\")\n        ctrl = np.array([(1, 2, 3), (4, 5, 6)],\n                        dtype=[('a', int), ('f0', float), ('f1', int)])\n        assert_equal(test, ctrl)\n\n    def test_names_with_usecols_bug1636(self):\n        \"Make sure we pick up the right names w/ usecols\"\n        data = \"A,B,C,D,E\\n0,1,2,3,4\\n0,1,2,3,4\\n0,1,2,3,4\"\n        ctrl_names = (\"A\", \"C\", \"E\")\n        test = np.genfromtxt(TextIO(data),\n                             dtype=(int, int, int), delimiter=\",\",\n                             usecols=(0, 2, 4), names=True)\n        assert_equal(test.dtype.names, ctrl_names)\n        #\n        test = np.genfromtxt(TextIO(data),\n                             dtype=(int, int, int), delimiter=\",\",\n                             usecols=(\"A\", \"C\", \"E\"), names=True)\n        assert_equal(test.dtype.names, ctrl_names)\n        #\n        test = np.genfromtxt(TextIO(data),\n                             dtype=int, delimiter=\",\",\n                             usecols=(\"A\", \"C\", \"E\"), names=True)\n        assert_equal(test.dtype.names, ctrl_names)\n\n    def test_fixed_width_names(self):\n        \"Test fix-width w/ names\"\n        data = \"    A    B   C\\n    0    1 2.3\\n   45   67   9.\"\n        kwargs = dict(delimiter=(5, 5, 4), names=True, dtype=None)\n        ctrl = np.array([(0, 1, 2.3), (45, 67, 9.)],\n                        dtype=[('A', int), ('B', int), ('C', float)])\n        test = np.ndfromtxt(TextIO(data), **kwargs)\n        assert_equal(test, ctrl)\n        #\n        kwargs = dict(delimiter=5, names=True, dtype=None)\n        ctrl = np.array([(0, 1, 2.3), (45, 67, 9.)],\n                        dtype=[('A', int), ('B', int), ('C', float)])\n        test = np.ndfromtxt(TextIO(data), **kwargs)\n        assert_equal(test, ctrl)\n\n    def test_filling_values(self):\n        \"Test missing values\"\n        data = b\"1, 2, 3\\n1, , 5\\n0, 6, \\n\"\n        kwargs = dict(delimiter=\",\", dtype=None, filling_values=-999)\n        ctrl = np.array([[1, 2, 3], [1, -999, 5], [0, 6, -999]], dtype=int)\n        test = np.ndfromtxt(TextIO(data), **kwargs)\n        assert_equal(test, ctrl)\n\n    def test_comments_is_none(self):\n        # Github issue 329 (None was previously being converted to 'None').\n        test = np.genfromtxt(TextIO(\"test1,testNonetherestofthedata\"),\n                             dtype=None, comments=None, delimiter=',')\n        assert_equal(test[1], b'testNonetherestofthedata')\n        test = np.genfromtxt(TextIO(\"test1, testNonetherestofthedata\"),\n                             dtype=None, comments=None, delimiter=',')\n        assert_equal(test[1], b' testNonetherestofthedata')\n\n    def test_recfromtxt(self):\n        #\n        data = TextIO('A,B\\n0,1\\n2,3')\n        kwargs = dict(delimiter=\",\", missing_values=\"N/A\", names=True)\n        test = np.recfromtxt(data, **kwargs)\n        control = np.array([(0, 1), (2, 3)],\n                           dtype=[('A', np.int), ('B', np.int)])\n        self.assertTrue(isinstance(test, np.recarray))\n        assert_equal(test, control)\n        #\n        data = TextIO('A,B\\n0,1\\n2,N/A')\n        test = np.recfromtxt(data, dtype=None, usemask=True, **kwargs)\n        control = ma.array([(0, 1), (2, -1)],\n                           mask=[(False, False), (False, True)],\n                           dtype=[('A', np.int), ('B', np.int)])\n        assert_equal(test, control)\n        assert_equal(test.mask, control.mask)\n        assert_equal(test.A, [0, 2])\n\n    def test_recfromcsv(self):\n        #\n        data = TextIO('A,B\\n0,1\\n2,3')\n        kwargs = dict(missing_values=\"N/A\", names=True, case_sensitive=True)\n        test = np.recfromcsv(data, dtype=None, **kwargs)\n        control = np.array([(0, 1), (2, 3)],\n                           dtype=[('A', np.int), ('B', np.int)])\n        self.assertTrue(isinstance(test, np.recarray))\n        assert_equal(test, control)\n        #\n        data = TextIO('A,B\\n0,1\\n2,N/A')\n        test = np.recfromcsv(data, dtype=None, usemask=True, **kwargs)\n        control = ma.array([(0, 1), (2, -1)],\n                           mask=[(False, False), (False, True)],\n                           dtype=[('A', np.int), ('B', np.int)])\n        assert_equal(test, control)\n        assert_equal(test.mask, control.mask)\n        assert_equal(test.A, [0, 2])\n        #\n        data = TextIO('A,B\\n0,1\\n2,3')\n        test = np.recfromcsv(data, missing_values='N/A',)\n        control = np.array([(0, 1), (2, 3)],\n                           dtype=[('a', np.int), ('b', np.int)])\n        self.assertTrue(isinstance(test, np.recarray))\n        assert_equal(test, control)\n\n    def test_gft_using_filename(self):\n        # Test that we can load data from a filename as well as a file object\n        wanted = np.arange(6).reshape((2, 3))\n        if sys.version_info[0] >= 3:\n            # python 3k is known to fail for '\\r'\n            linesep = ('\\n', '\\r\\n')\n        else:\n            linesep = ('\\n', '\\r\\n', '\\r')\n\n        for sep in linesep:\n            data = '0 1 2' + sep + '3 4 5'\n            f, name = mkstemp()\n            # We can't use NamedTemporaryFile on windows, because we cannot\n            # reopen the file.\n            try:\n                os.write(f, asbytes(data))\n                assert_array_equal(np.genfromtxt(name), wanted)\n            finally:\n                os.close(f)\n                os.unlink(name)\n\n    def test_gft_using_generator(self):\n        # gft doesn't work with unicode.\n        def count():\n            for i in range(10):\n                yield asbytes(\"%d\" % i)\n\n        res = np.genfromtxt(count())\n        assert_array_equal(res, np.arange(10))\n\n\ndef test_gzip_load():\n    a = np.random.random((5, 5))\n\n    s = BytesIO()\n    f = gzip.GzipFile(fileobj=s, mode=\"w\")\n\n    np.save(f, a)\n    f.close()\n    s.seek(0)\n\n    f = gzip.GzipFile(fileobj=s, mode=\"r\")\n    assert_array_equal(np.load(f), a)\n\n\ndef test_gzip_loadtxt():\n    # Thanks to another windows brokeness, we can't use\n    # NamedTemporaryFile: a file created from this function cannot be\n    # reopened by another open call. So we first put the gzipped string\n    # of the test reference array, write it to a securely opened file,\n    # which is then read from by the loadtxt function\n    s = BytesIO()\n    g = gzip.GzipFile(fileobj=s, mode='w')\n    g.write(b'1 2 3\\n')\n    g.close()\n    s.seek(0)\n\n    f, name = mkstemp(suffix='.gz')\n    try:\n        os.write(f, s.read())\n        s.close()\n        assert_array_equal(np.loadtxt(name), [1, 2, 3])\n    finally:\n        os.close(f)\n        os.unlink(name)\n\n\ndef test_gzip_loadtxt_from_string():\n    s = BytesIO()\n    f = gzip.GzipFile(fileobj=s, mode=\"w\")\n    f.write(b'1 2 3\\n')\n    f.close()\n    s.seek(0)\n\n    f = gzip.GzipFile(fileobj=s, mode=\"r\")\n    assert_array_equal(np.loadtxt(f), [1, 2, 3])\n\n\ndef test_npzfile_dict():\n    s = BytesIO()\n    x = np.zeros((3, 3))\n    y = np.zeros((3, 3))\n\n    np.savez(s, x=x, y=y)\n    s.seek(0)\n\n    z = np.load(s)\n\n    assert_('x' in z)\n    assert_('y' in z)\n    assert_('x' in z.keys())\n    assert_('y' in z.keys())\n\n    for f, a in z.items():\n        assert_(f in ['x', 'y'])\n        assert_equal(a.shape, (3, 3))\n\n    assert_(len(z.items()) == 2)\n\n    for f in z:\n        assert_(f in ['x', 'y'])\n\n    assert_('x' in z.keys())\n\n\ndef test_load_refcount():\n    # Check that objects returned by np.load are directly freed based on\n    # their refcount, rather than needing the gc to collect them.\n\n    f = BytesIO()\n    np.savez(f, [1, 2, 3])\n    f.seek(0)\n\n    gc.collect()\n    n_before = len(gc.get_objects())\n    np.load(f)\n    n_after = len(gc.get_objects())\n\n    assert_equal(n_before, n_after)\n\nif __name__ == \"__main__\":\n    run_module_suite()\n"], "filenames": ["numpy/core/tests/test_memmap.py", "numpy/core/tests/test_multiarray.py", "numpy/f2py/__init__.py", "numpy/f2py/f2py2e.py", "numpy/lib/tests/test_io.py"], "buggy_code_start_loc": [4, 2319, 31, 94, 7], "buggy_code_end_loc": [69, 2539, 45, 428, 188], "fixing_code_start_loc": [4, 2319, 31, 94, 7], "fixing_code_end_loc": [67, 2531, 45, 428, 196], "type": "CWE-59", "message": "(1) core/tests/test_memmap.py, (2) core/tests/test_multiarray.py, (3) f2py/f2py2e.py, and (4) lib/tests/test_io.py in NumPy before 1.8.1 allow local users to write to arbitrary files via a symlink attack on a temporary file.", "other": {"cve": {"id": "CVE-2014-1859", "sourceIdentifier": "cve@mitre.org", "published": "2018-01-08T19:29:00.297", "lastModified": "2019-04-22T17:48:00.643", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "(1) core/tests/test_memmap.py, (2) core/tests/test_multiarray.py, (3) f2py/f2py2e.py, and (4) lib/tests/test_io.py in NumPy before 1.8.1 allow local users to write to arbitrary files via a symlink attack on a temporary file."}, {"lang": "es", "value": "(1) core/tests/test_memmap.py, (2) core/tests/test_multiarray.py, (3) f2py/f2py2e.py y (4) lib/tests/test_io.py en NumPy en versiones anteriores a la 1.8.1 permiten que los usuarios locales escriban en archivos arbitrarios mediante un ataque symlink en un archivo temporal."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:numpy:numpy:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.8.0", "matchCriteriaId": "BDE35125-D40B-4286-BA33-6D3B4E3F3A99"}, {"vulnerable": true, "criteria": "cpe:2.3:a:numpy:numpy:1.8.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "9381F7BC-B4A0-4411-831F-02DE7D36DA96"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:19:*:*:*:*:*:*:*", "matchCriteriaId": "5991814D-CA77-4C25-90D2-DB542B17E0AD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:20:*:*:*:*:*:*:*", "matchCriteriaId": "FF47C9F0-D8DA-4B55-89EB-9B2C9383ADB9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-February/128358.html", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-February/128781.html", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/02/08/3", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/65440", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=737778", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1062009", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/91317", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/numpy/numpy/blob/maintenance/1.8.x/doc/release/1.8.1-notes.rst", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/numpy/numpy/commit/0bb46c1448b0d3f5453d5182a17ea7ac5854ee15", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/numpy/numpy/pull/4262", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/numpy/numpy/commit/0bb46c1448b0d3f5453d5182a17ea7ac5854ee15"}}