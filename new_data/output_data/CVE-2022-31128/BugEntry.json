{"buggy_code": ["<?php\n/**\n * Copyright (c) Enalean, 2022 - Present. All Rights Reserved.\n *\n * This file is a part of Tuleap.\n *\n * Tuleap is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Tuleap is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Tuleap; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nnamespace Tuleap\\Git\\REST\\v1\\Branch;\n\nuse Git;\nuse Git_Command_Exception;\nuse Luracast\\Restler\\RestException;\nuse Tuleap\\Git\\Branch\\BranchCreationExecutor;\nuse Tuleap\\Git\\Branch\\BranchName;\nuse Tuleap\\Git\\Branch\\CannotCreateNewBranchException;\nuse Tuleap\\Git\\Branch\\InvalidBranchNameException;\nuse Tuleap\\Git\\REST\\v1\\GitBranchPOSTRepresentation;\n\nclass BranchCreator\n{\n    private const BRANCH_PREFIX = \"refs/heads/\";\n\n    public function __construct(private \\Git_Exec $git_exec, private BranchCreationExecutor $branch_creation_executor)\n    {\n    }\n\n    /**\n     * @throws RestException\n     */\n    public function createBranch(\\PFUser $user, \\GitRepository $repository, GitBranchPOSTRepresentation $representation): void\n    {\n        if (\n            ! $user->hasPermission(Git::PERM_WRITE, $repository->getId(), $repository->getProjectId())\n            && ! $user->hasPermission(Git::PERM_WPLUS, $repository->getId(), $repository->getProjectId())\n        ) {\n            throw new RestException(\n                403,\n                \"User cannot update the content of the repository\"\n            );\n        }\n\n        try {\n            BranchName::fromBranchNameShortHand($representation->branch_name);\n        } catch (InvalidBranchNameException $exception) {\n            throw new RestException(\n                400,\n                sprintf(\n                    \"The branch name %s is not a valid branch name\",\n                    $representation->branch_name\n                )\n            );\n        }\n\n        $all_branches_names = $this->git_exec->getAllBranchesSortedByCreationDate();\n        if (in_array($representation->branch_name, $all_branches_names)) {\n            throw new RestException(\n                400,\n                sprintf(\n                    \"The branch %s already exists in the repository %s\",\n                    $representation->branch_name,\n                    $repository->getName()\n                )\n            );\n        }\n\n        try {\n            $object_type = $this->git_exec->getObjectType($representation->reference);\n        } catch (Git_Command_Exception $exception) {\n            throw new RestException(\n                400,\n                sprintf(\n                    \"The object %s does not exist in the repository %s\",\n                    $representation->reference,\n                    $repository->getName()\n                )\n            );\n        }\n\n        if (\n            ! in_array($representation->reference, $all_branches_names)\n            && $object_type !== 'commit'\n        ) {\n            throw new RestException(\n                400,\n                sprintf(\n                    \"The object %s is neither a branch nor a commit in repository %s.\",\n                    $representation->reference,\n                    $repository->getName()\n                )\n            );\n        }\n\n        try {\n            $this->branch_creation_executor->createNewBranch(\n                $this->git_exec,\n                self::BRANCH_PREFIX . $representation->branch_name,\n                $representation->reference\n            );\n        } catch (CannotCreateNewBranchException $exception) {\n            throw new RestException(\n                500,\n                \"An error occurred while creating the branch: \" . $exception->getMessage()\n            );\n        }\n    }\n}\n", "<?php\n/**\n * Copyright (c) Enalean, 2014 - Present. All Rights Reserved.\n *\n * This file is a part of Tuleap.\n *\n * Tuleap is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Tuleap is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Tuleap; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nnamespace Tuleap\\Git\\REST\\v1;\n\nuse EventManager;\nuse Exception;\nuse Git_Driver_Gerrit_GerritDriverFactory;\nuse Git_Driver_Gerrit_ProjectCreatorStatus;\nuse Git_Driver_Gerrit_ProjectCreatorStatusDao;\nuse Git_Exec;\nuse Git_GitRepositoryUrlManager;\nuse Git_PermissionsDao;\nuse Git_RemoteServer_Dao;\nuse Git_RemoteServer_GerritServerFactory;\nuse Git_RemoteServer_NotFoundException;\nuse Git_SystemEventManager;\nuse GitDao;\nuse GitPermissionsManager;\nuse GitRepoNotFoundException;\nuse GitRepoNotReadableException;\nuse GitRepository;\nuse GitRepositoryAlreadyExistsException;\nuse GitRepositoryFactory;\nuse Luracast\\Restler\\RestException;\nuse PFUser;\nuse ProjectHistoryDao;\nuse ProjectManager;\nuse SystemEventManager;\nuse Tuleap\\Git\\BigObjectAuthorization\\BigObjectAuthorizationDao;\nuse Tuleap\\Git\\BigObjectAuthorization\\BigObjectAuthorizationManager;\nuse Tuleap\\Git\\Branch\\BranchCreationExecutor;\nuse Tuleap\\Git\\CIBuilds\\BuildStatusChangePermissionDAO;\nuse Tuleap\\Git\\CIBuilds\\BuildStatusChangePermissionManager;\nuse Tuleap\\Git\\CIBuilds\\CITokenDao;\nuse Tuleap\\Git\\CIBuilds\\CITokenManager;\nuse Tuleap\\Git\\CommitMetadata\\CommitMetadataRetriever;\nuse Tuleap\\Git\\CommitStatus\\CommitDoesNotExistException;\nuse Tuleap\\Git\\CommitStatus\\CommitStatusCreator;\nuse Tuleap\\Git\\CommitStatus\\CommitStatusDAO;\nuse Tuleap\\Git\\CommitStatus\\CommitStatusRetriever;\nuse Tuleap\\Git\\CommitStatus\\InvalidCommitReferenceException;\nuse Tuleap\\Git\\DefaultBranch\\CannotSetANonExistingBranchAsDefaultException;\nuse Tuleap\\Git\\DefaultBranch\\DefaultBranchUpdateExecutorAsGitoliteUser;\nuse Tuleap\\Git\\DefaultBranch\\DefaultBranchUpdater;\nuse Tuleap\\Git\\Exceptions\\DeletePluginNotInstalledException;\nuse Tuleap\\Git\\Exceptions\\GitRepoRefNotFoundException;\nuse Tuleap\\Git\\Exceptions\\RepositoryAlreadyInQueueForMigrationException;\nuse Tuleap\\Git\\Exceptions\\RepositoryCannotBeMigratedException;\nuse Tuleap\\Git\\Exceptions\\RepositoryCannotBeMigratedOnRestrictedGerritServerException;\nuse Tuleap\\Git\\Exceptions\\RepositoryNotMigratedException;\nuse Tuleap\\Git\\Gitolite\\GitoliteAccessURLGenerator;\nuse Tuleap\\Git\\Gitolite\\VersionDetector;\nuse Tuleap\\Git\\GitPHP\\ProjectProvider;\nuse Tuleap\\Git\\GitPHP\\RepositoryAccessException;\nuse Tuleap\\Git\\GitPHP\\RepositoryNotExistingException;\nuse Tuleap\\Git\\Permissions\\DefaultFineGrainedPermissionFactory;\nuse Tuleap\\Git\\Permissions\\FineGrainedDao;\nuse Tuleap\\Git\\Permissions\\FineGrainedPatternValidator;\nuse Tuleap\\Git\\Permissions\\FineGrainedPermissionFactory;\nuse Tuleap\\Git\\Permissions\\FineGrainedPermissionReplicator;\nuse Tuleap\\Git\\Permissions\\FineGrainedPermissionSaver;\nuse Tuleap\\Git\\Permissions\\FineGrainedPermissionSorter;\nuse Tuleap\\Git\\Permissions\\FineGrainedRegexpValidator;\nuse Tuleap\\Git\\Permissions\\FineGrainedRetriever;\nuse Tuleap\\Git\\Permissions\\HistoryValueFormatter;\nuse Tuleap\\Git\\Permissions\\PatternValidator;\nuse Tuleap\\Git\\Permissions\\RegexpFineGrainedDao;\nuse Tuleap\\Git\\Permissions\\RegexpFineGrainedEnabler;\nuse Tuleap\\Git\\Permissions\\RegexpFineGrainedRetriever;\nuse Tuleap\\Git\\Permissions\\RegexpRepositoryDao;\nuse Tuleap\\Git\\Permissions\\RegexpTemplateDao;\nuse Tuleap\\Git\\RemoteServer\\Gerrit\\MigrationHandler;\nuse Tuleap\\Git\\Repository\\GitRepositoryNameIsInvalidException;\nuse Tuleap\\Git\\Repository\\RepositoryCreator;\nuse Tuleap\\Git\\REST\\v1\\Branch\\BranchCreator;\nuse Tuleap\\Git\\XmlUgroupRetriever;\nuse Tuleap\\Http\\HttpClientFactory;\nuse Tuleap\\PullRequest\\REST\\v1\\RepositoryPullRequestRepresentation;\nuse Tuleap\\REST\\AuthenticatedResource;\nuse Tuleap\\REST\\Header;\nuse Tuleap\\REST\\ProjectStatusVerificator;\nuse UserManager;\n\ninclude_once __DIR__ . '/../../../../../src/www/project/admin/permissions.php';\n\nclass RepositoryResource extends AuthenticatedResource\n{\n    public const MAX_LIMIT = 50;\n\n    public const MIGRATE_PERMISSION_DEFAULT = 'default';\n    public const MIGRATE_NO_PERMISSION      = 'none';\n    /**\n     * @var RepositoryCreator\n     */\n    private $repository_creator;\n    /**\n     * @var GitPermissionsManager\n     */\n    private $git_permission_manager;\n    /**\n     * @var ProjectManager\n     */\n    private $project_manager;\n\n    /**\n     * @var UserManager\n     */\n    private $user_manager;\n\n    /** @var GitRepositoryFactory */\n    private $repository_factory;\n\n    /** @var RepositoryRepresentationBuilder */\n    private $representation_builder;\n\n    /** @var Git_RemoteServer_GerritServerFactory */\n    private $gerrit_server_factory;\n\n    /** @var Git_SystemEventManager */\n    private $git_system_event_manager;\n\n    /** @var MigrationHandler */\n    private $migration_handler;\n\n    /**\n     * @var CITokenManager\n     */\n    private $ci_token_manager;\n    /**\n     * @var GitCommitRepresentationBuilder\n     */\n    private $commit_representation_builder;\n\n    public function __construct()\n    {\n        $git_dao               = new GitDao();\n        $this->project_manager = ProjectManager::instance();\n        $this->user_manager    = UserManager::instance();\n        $event_manager         = EventManager::instance();\n\n        $this->repository_factory = new GitRepositoryFactory(\n            $git_dao,\n            $this->project_manager\n        );\n\n        $this->git_system_event_manager = new Git_SystemEventManager(\n            SystemEventManager::instance(),\n            $this->repository_factory\n        );\n\n        $this->gerrit_server_factory = new Git_RemoteServer_GerritServerFactory(\n            new Git_RemoteServer_Dao(),\n            $git_dao,\n            $this->git_system_event_manager,\n            $this->project_manager\n        );\n\n        $fine_grained_dao       = new FineGrainedDao();\n        $fine_grained_retriever = new FineGrainedRetriever($fine_grained_dao);\n\n        $this->git_permission_manager = new GitPermissionsManager(\n            new Git_PermissionsDao(),\n            $this->git_system_event_manager,\n            $fine_grained_dao,\n            $fine_grained_retriever\n        );\n\n        $git_plugin = \\PluginFactory::instance()->getPluginByName('git');\n        assert($git_plugin instanceof \\GitPlugin);\n        $url_manager = new \\Git_GitRepositoryUrlManager($git_plugin);\n\n        $this->representation_builder = new RepositoryRepresentationBuilder(\n            $this->git_permission_manager,\n            $this->gerrit_server_factory,\n            new \\Git_LogDao(),\n            $event_manager,\n            $url_manager\n        );\n\n        $project_history_dao     = new ProjectHistoryDao();\n        $this->migration_handler = new MigrationHandler(\n            $this->git_system_event_manager,\n            $this->gerrit_server_factory,\n            new Git_Driver_Gerrit_GerritDriverFactory(\n                new \\Tuleap\\Git\\Driver\\GerritHTTPClientFactory(HttpClientFactory::createClient()),\n                \\Tuleap\\Http\\HTTPFactoryBuilder::requestFactory(),\n                \\Tuleap\\Http\\HTTPFactoryBuilder::streamFactory(),\n                \\BackendLogger::getDefaultLogger(\\GitPlugin::LOG_IDENTIFIER),\n            ),\n            $project_history_dao,\n            new Git_Driver_Gerrit_ProjectCreatorStatus(new Git_Driver_Gerrit_ProjectCreatorStatusDao()),\n            $this->project_manager\n        );\n\n        $this->ci_token_manager = new CITokenManager(new CITokenDao());\n\n        $mirror_data_mapper = new \\Git_Mirror_MirrorDataMapper(\n            new \\Git_Mirror_MirrorDao(),\n            $this->user_manager,\n            $this->repository_factory,\n            $this->project_manager,\n            $this->git_system_event_manager,\n            new \\Git_Gitolite_GitoliteRCReader(new VersionDetector()),\n            new \\DefaultProjectMirrorDao()\n        );\n\n        $regexp_retriever     = new RegexpFineGrainedRetriever(\n            new RegexpFineGrainedDao(),\n            new RegexpRepositoryDao(),\n            new RegexpTemplateDao()\n        );\n        $ugroup_manager       = new \\UGroupManager();\n        $normalizer           = new \\PermissionsNormalizer();\n        $permissions_manager  = new \\PermissionsManager(new \\PermissionsDao());\n        $validator            = new PatternValidator(\n            new FineGrainedPatternValidator(),\n            new FineGrainedRegexpValidator(),\n            $regexp_retriever\n        );\n        $sorter               = new FineGrainedPermissionSorter();\n        $xml_ugroup_retriever = new XmlUgroupRetriever(\\BackendLogger::getDefaultLogger(\\GitPlugin::LOG_IDENTIFIER), $ugroup_manager);\n\n        $fine_grained_permission_factory = new FineGrainedPermissionFactory(\n            $fine_grained_dao,\n            $ugroup_manager,\n            $normalizer,\n            $permissions_manager,\n            $validator,\n            $sorter,\n            $xml_ugroup_retriever\n        );\n        $fine_grained_replicator         = new FineGrainedPermissionReplicator(\n            $fine_grained_dao,\n            new DefaultFineGrainedPermissionFactory(\n                $fine_grained_dao,\n                $ugroup_manager,\n                $normalizer,\n                $permissions_manager,\n                $validator,\n                $sorter\n            ),\n            new FineGrainedPermissionSaver(\n                $fine_grained_dao\n            ),\n            $fine_grained_permission_factory,\n            new RegexpFineGrainedEnabler(\n                new RegexpFineGrainedDao(),\n                new RegexpRepositoryDao(),\n                new RegexpTemplateDao()\n            ),\n            $regexp_retriever,\n            $validator\n        );\n        $history_value_formatter         = new HistoryValueFormatter(\n            $permissions_manager,\n            $ugroup_manager,\n            $fine_grained_retriever,\n            new DefaultFineGrainedPermissionFactory(\n                $fine_grained_dao,\n                $ugroup_manager,\n                $normalizer,\n                $permissions_manager,\n                $validator,\n                $sorter\n            ),\n            $fine_grained_permission_factory\n        );\n\n        $this->repository_creator = new RepositoryCreator(\n            $this->repository_factory,\n            new \\Git_Backend_Gitolite(\n                new \\Git_GitoliteDriver(\n                    \\BackendLogger::getDefaultLogger(\\GitPlugin::LOG_IDENTIFIER),\n                    $this->git_system_event_manager,\n                    $url_manager,\n                    $git_dao,\n                    new \\Git_Mirror_MirrorDao(),\n                    $git_plugin,\n                    new BigObjectAuthorizationManager(\n                        new BigObjectAuthorizationDao(),\n                        ProjectManager::instance()\n                    ),\n                    new VersionDetector(),\n                    null,\n                    null,\n                    null,\n                    null,\n                    null,\n                    null,\n                ),\n                new GitoliteAccessURLGenerator($git_plugin->getPluginInfo()),\n                new DefaultBranchUpdateExecutorAsGitoliteUser(),\n                \\BackendLogger::getDefaultLogger(\\GitPlugin::LOG_IDENTIFIER),\n            ),\n            $mirror_data_mapper,\n            new \\GitRepositoryManager(\n                $this->repository_factory,\n                $this->git_system_event_manager,\n                $git_dao,\n                \"\",\n                new \\GitRepositoryMirrorUpdater($mirror_data_mapper, $project_history_dao),\n                $mirror_data_mapper,\n                $fine_grained_replicator,\n                $project_history_dao,\n                $history_value_formatter,\n                $event_manager\n            ),\n            $this->git_permission_manager,\n            $fine_grained_replicator,\n            $project_history_dao,\n            $history_value_formatter,\n            $this->ci_token_manager,\n            $event_manager\n        );\n\n        $status_retriever   = new CommitStatusRetriever(new CommitStatusDAO());\n        $metadata_retriever = new CommitMetadataRetriever($status_retriever, $this->user_manager);\n        $url_manager        = new Git_GitRepositoryUrlManager($git_plugin);\n\n        $this->commit_representation_builder = new GitCommitRepresentationBuilder($metadata_retriever, $url_manager);\n    }\n\n    /**\n     * Return info about repository if exists\n     *\n     * @url OPTIONS {id}\n     *\n     * @param string $id Id of the repository\n     *\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    public function optionsId($id)\n    {\n        $this->sendAllowHeaders();\n    }\n\n    /**\n     * @access hybrid\n     *\n     * @param int $id Id of the repository\n     * @return GitRepositoryRepresentation | null\n     *\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    public function get($id)\n    {\n        $this->checkAccess();\n\n        $user       = $this->getCurrentUser();\n        $repository = $this->getRepository($user, $id);\n\n        $this->sendAllowHeaders();\n\n        return $this->representation_builder->build($user, $repository, GitRepositoryRepresentation::FIELDS_ALL);\n    }\n\n    /**\n     * @url OPTIONS {id}/pull_requests\n     *\n     * @param int $id Id of the repository\n     *\n     * @throws RestException 404\n     */\n    public function optionsPullRequests($id)\n    {\n        $this->checkPullRequestEndpointsAvailable();\n        $this->sendAllowHeaders();\n    }\n\n    /**\n     * Get pull requests\n     *\n     * <p>Retrieve all git repository's pull requests.</p>\n     *\n     * <p>Pull requests are sorted by descending order of creation date.</p>\n     *\n     * <p>User is not able to see a pull request in a git repository where he is not able to READ.</p>\n     *\n     * <p>\n     * <code>$query</code> parameter is optional, by default we return all pull requests. If\n     * <code>query={\"status\":\"open\"}</code> then only open pull requests are returned and if\n     * <code>query={\"status\":\"closed\"}</code> then only closed pull requests are returned.\n     * </p>\n     *\n     * <pre>\n     * /!\\ PullRequest REST routes are under construction and subject to changes /!\\\n     * </pre>\n     *\n     * @url GET {id}/pull_requests\n     *\n     * @access protected\n     *\n     * @param int    $id     Id of the repository\n     * @param string $query  JSON object of search criteria properties {@from path}\n     * @param int    $limit  Number of elements displayed per page {@from path} {@min 0} {@max 50}\n     * @param int    $offset Position of the first element to display {@from path} {@min 0}\n     *\n     * @return RepositoryPullRequestRepresentation\n     *\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    public function getPullRequests($id, $query = '', $limit = self::MAX_LIMIT, $offset = 0)\n    {\n        $this->checkAccess();\n        $this->checkPullRequestEndpointsAvailable();\n\n        $user       = $this->getCurrentUser();\n        $repository = $this->getRepository($user, $id);\n        $result     = $this->getPaginatedPullRequests($repository, $query, $limit, $offset);\n\n        $this->sendAllowHeaders();\n        $this->sendPaginationHeaders($limit, $offset, $result->total_size);\n\n        return $result;\n    }\n\n    /**\n     * Post\n     *\n     * @url    POST\n     *\n     * @access hybrid\n     *\n     *\n     * @param $project_id {@type int} {@from body} project id\n     * @param $name       {@type string} {@from body} Repository name\n     *\n     * @status 201\n     * @throws RestException 400\n     * @throws RestException 401\n     * @throws RestException 404\n     * @throws RestException 500\n     */\n    public function post($project_id, $name)\n    {\n        $this->checkAccess();\n\n        Header::allowOptionsPost();\n\n        $user    = $this->user_manager->getCurrentUser();\n        $project = $this->project_manager->getProject($project_id);\n        if ($project->isError()) {\n            throw new RestException(404, \"Given project does not exist\");\n        }\n\n        if (! $project->usesService(\\GitPlugin::SERVICE_SHORTNAME)) {\n            throw new RestException(400, \"Project does not use Git service\");\n        }\n\n        ProjectStatusVerificator::build()->checkProjectStatusAllowsAllUsersToAccessIt(\n            $project\n        );\n\n        if (! $this->git_permission_manager->userIsGitAdmin($user, $project)) {\n            throw new RestException(403, \"User does not have permissions to create a Git Repository\");\n        }\n        try {\n            $repository = $this->repository_creator->create($project, $user, $name);\n        } catch (GitRepositoryNameIsInvalidException $e) {\n            throw new RestException(400, $e->getMessage());\n        } catch (GitRepositoryAlreadyExistsException $e) {\n            throw new RestException(400, $e->getMessage());\n        } catch (Exception $e) {\n            throw new RestException(500, $e->getMessage());\n        }\n\n        return $this->get($repository->getId());\n    }\n\n    /**\n     * @url OPTIONS\n     */\n    public function options()\n    {\n        Header::allowOptionsPost();\n    }\n\n    /**\n     * @url OPTIONS {id}/statuses/{commit_reference}\n     *\n     * @param int $id Git repository id\n     * @param string $commit_reference Commit SHA-1\n     */\n    public function optionsCommitStatus($id, $commit_reference)\n    {\n        Header::allowOptionsPost();\n    }\n\n    /**\n     * Post a commit status\n     *\n     * @url    POST {id_or_path}/statuses/{commit_reference}\n     *\n     * @access hybrid\n     *\n     * @param string $id_or_path       Git repository id or Git repository path\n     * @param string $commit_reference Commit SHA-1\n     * @param string $state            {@choice failure,success,pending} {@from body}\n     * @param string $token            {@from body}{@required false}\n     *\n     * @status 201\n     * @throws RestException 403\n     * @throws RestException 404\n     * @throws RestException 400\n     */\n    public function postCommitStatus($id_or_path, $commit_reference, $state, $token = null)\n    {\n        if (ctype_digit($id_or_path)) {\n            $repository = $this->repository_factory->getRepositoryById((int) $id_or_path);\n        } else {\n            preg_match(\"/(.+?)\\/(.+)/\", $id_or_path, $path);\n            if (count($path) !== 3) {\n                throw new RestException(400, 'Bad repository path format');\n            }\n            $repository = $this->repository_factory->getByProjectNameAndPath($path[1], $path[2]);\n        }\n        if (! $repository) {\n            throw new RestException(404, 'Repository not found.');\n        }\n\n        ProjectStatusVerificator::build()->checkProjectStatusAllowsAllUsersToAccessIt(\n            $repository->getProject()\n        );\n\n        if ($token !== null) {\n            $this->checkCITokenValidity($repository, $token);\n        } else {\n            $this->checkUserHasPermission($repository);\n        }\n\n        $commit_status_creator = new CommitStatusCreator(new CommitStatusDAO());\n\n        try {\n            $commit_status_creator->createCommitStatus(\n                $repository,\n                Git_Exec::buildFromRepository($repository),\n                $commit_reference,\n                $state\n            );\n        } catch (CommitDoesNotExistException $exception) {\n            throw new RestException(404, $exception->getMessage());\n        } catch (InvalidCommitReferenceException $exception) {\n            throw new RestException(400, $exception->getMessage());\n        }\n    }\n\n    /**\n     * @throws RestException\n     */\n    private function checkCITokenValidity(GitRepository $repository, string $ci_token): void\n    {\n        $repo_ci_token = $this->ci_token_manager->getToken($repository);\n        if ($repo_ci_token === null || ! \\hash_equals($ci_token, $repo_ci_token)) {\n            throw new RestException(403, 'Invalid token');\n        }\n    }\n\n    /**\n     * @throws RestException\n     */\n    private function checkUserHasPermission(GitRepository $repository): void\n    {\n        $user                                = $this->user_manager->getCurrentUser();\n        $set_build_status_permission_manager = new BuildStatusChangePermissionManager(\n            new BuildStatusChangePermissionDAO()\n        );\n\n        if (\n            ! $set_build_status_permission_manager->canUserSetBuildStatusInRepository($user, $repository)\n        ) {\n            throw new RestException(403, 'You are not allowed to set the build status');\n        }\n    }\n\n    /**\n     * Patch Git repository\n     *\n     * Patch properties of a given Git repository\n     *\n     * <pre>\n     * /!\\ This REST route is under construction and subject to changes /!\\\n     * </pre>\n     *\n     * <br>\n     * To migrate a repository in Gerrit:\n     * <pre>\n     * {<br>\n     * &nbsp;\"migrate_to_gerrit\": {<br/>\n     * &nbsp;&nbsp;\"server\": 1,<br/>\n     * &nbsp;&nbsp;\"permissions\": \"default\"<br/>\n     * &nbsp;}<br/>\n     * }\n     * </pre>\n     *\n     * <br>\n     * To disconnect a repository in Gerrit:\n     * <pre>\n     * {<br>\n     * &nbsp;\"disconnect_from_gerrit\": \"read-only\"<br/>\n     * }\n     * </pre>\n     * <br>\n     *\n     * To change the default branch of a repository:\n     * <pre>\n     * {<br>\n     * &nbsp;\"default_branch\": \"dev\"<br/>\n     * }\n     * </pre>\n     *\n     * @url PATCH {id}\n     * @access protected\n     *\n     * @param int    $id    Id of the Git repository\n     * @param GitRepositoryGerritMigratePATCHRepresentation $migrate_to_gerrit {@from body}{@required false}\n     * @param string $disconnect_from_gerrit {@from body}{@required false} {@choice delete,read-only,noop}\n     * @param string $default_branch {@from body}{@required false} New default branch to set, the branch needs to exist\n     * @psalm-param string|null $default_branch\n     *\n     *\n     * @throws RestException 400\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    protected function patchId(\n        $id,\n        ?GitRepositoryGerritMigratePATCHRepresentation $migrate_to_gerrit = null,\n        $disconnect_from_gerrit = null,\n        ?string $default_branch = null,\n    ) {\n        $this->checkAccess();\n\n        $user       = $this->getCurrentUser();\n        $repository = $this->getRepository($user, $id);\n\n        ProjectStatusVerificator::build()->checkProjectStatusAllowsAllUsersToAccessIt(\n            $repository->getProject()\n        );\n\n        if (! $repository->userCanAdmin($user)) {\n            throw new RestException(403, 'User is not allowed to administrate this repository');\n        }\n\n        if ($migrate_to_gerrit && $disconnect_from_gerrit) {\n            throw new RestException(403, 'Bad request. You can only migrate or disconnect a Git repository');\n        }\n\n        if ($migrate_to_gerrit) {\n            $this->migrate($repository, $user, $migrate_to_gerrit);\n        }\n\n        if ($disconnect_from_gerrit) {\n            $this->disconnect($repository, $disconnect_from_gerrit);\n        }\n\n        if ($default_branch !== null) {\n            $default_branch_updater = new DefaultBranchUpdater(new DefaultBranchUpdateExecutorAsGitoliteUser());\n            try {\n                $default_branch_updater->updateDefaultBranch(Git_Exec::buildFromRepository($repository), $default_branch);\n            } catch (CannotSetANonExistingBranchAsDefaultException $exception) {\n                throw new RestException(400, $exception->getMessage(), [], $exception);\n            }\n        }\n\n        $this->sendAllowHeaders();\n    }\n\n    /**\n     * Get the tree of a git repository.\n     *\n     * Returns the repository root content when the path is not given.\n     *\n     * @url    GET {id}/tree\n     *\n     * @access hybrid\n     *\n     * @param int    $id   Id of the git repository\n     * @param string $ref  reference {@from path} {@required true}\n     * @param string $path path of the file {@from path} {@required false}\n     * @param int $offset Position of the first element to display {@from path}{@min 0}\n     * @param int $limit  Number of elements displayed {@from path}{@min 1}{@max 50}\n     *\n     * @return array {@type Tuleap\\Git\\REST\\v1\\GitTreeRepresentation}\n     *\n     * @status 200\n     * @throws RestException 401\n     * @throws RestException 403\n     * @throws RestException 404\n     * @throws RestException 500\n     *\n     */\n    public function getTree(int $id, string $ref, string $path = \"\", int $offset = 0, int $limit = self::MAX_LIMIT): array\n    {\n        $this->checkAccess();\n        $tree_representation_factory = new GitTreeRepresentationFactory();\n        try {\n            $repository   = $this->getGitPHPProject($id);\n            $tree_content = $tree_representation_factory->getGitTreeRepresentation(\n                rtrim($path, DIRECTORY_SEPARATOR),\n                $ref,\n                $repository\n            );\n            $result       = array_slice(\n                $tree_content,\n                $offset,\n                $limit\n            );\n\n            Header::allowOptionsGet();\n            Header::sendPaginationHeaders($limit, $offset, count($tree_content), self::MAX_LIMIT);\n\n            return $result;\n        } catch (\\GitRepositoryException | GitRepoRefNotFoundException $exception) {\n            throw new RestException(404, $exception->getMessage());\n        } catch (RepositoryNotExistingException $exception) {\n            throw new RestException(404, \"Reference $ref does not exist\");\n        } catch (GitObjectTypeNotSupportedException $exception) {\n            throw new RestException(500, $exception->getMessage());\n        }\n    }\n\n    /**\n     * @url OPTIONS {id}/tree\n     *\n     * @param int    $id           Id of the git repository\n     * @param string $ref          ref {@from path} {@required true}\n     * @param string $path         path {@from path} {@required false}\n     */\n    public function optionsGetTree(int $id, string $ref, string $path = \"\"): void\n    {\n        Header::allowOptionsGet();\n    }\n\n    /**\n     * @url OPTIONS {id}/files\n     *\n     * @param int    $id           Id of the git repository\n     * @param string $path_to_file path of the file {@from path}\n     * @param string $ref          ref {@from path}\n     */\n    public function optionsGetFileContent($id, $path_to_file, $ref)\n    {\n        Header::allowOptionsGet();\n    }\n\n    /**\n     * Get the content of a specific file from a git repository.\n     *\n     * The file size is in Bytes. <br/>\n     * If no ref given, master is used.\n     *\n     * @url    GET {id}/files\n     *\n     * @access hybrid\n     *\n     * @param int    $id           Id of the git repository\n     * @param string $path_to_file path of the file {@from path}\n     * @param string $ref          reference {@from path}\n     *\n     * @return GitFileContentRepresentation\n     *\n     * @status 200\n     * @throws RestException 401\n     * @throws RestException 403\n     * @throws RestException 404\n     *\n     */\n    public function getFileContent($id, $path_to_file, $ref = 'master')\n    {\n        Header::allowOptionsGet();\n\n        $this->checkAccess();\n        $file_representation_factory = new GitFileRepresentationFactory();\n        try {\n            $repository = $this->getGitPHPProject($id);\n            $result     = $file_representation_factory->getGitFileRepresentation(\n                $path_to_file,\n                $ref,\n                $repository\n            );\n\n            return $result;\n        } catch (\\GitRepositoryException $exception) {\n            throw new RestException(404, $exception->getMessage());\n        } catch (GitRepoRefNotFoundException $exception) {\n            throw new RestException(404, $exception->getMessage());\n        } catch (RepositoryNotExistingException $exception) {\n            throw new RestException(404, \"Reference $ref does not exist\");\n        }\n    }\n\n    /**\n     * @url OPTIONS {id}/branches\n     *\n     * @param int $id Id of the git repository\n     */\n    public function optionsGetPostBranches($id): void\n    {\n        Header::allowOptionsGetPost();\n    }\n\n    /**\n     * Get all the branches of a git repository\n     *\n     * @url    GET {id}/branches\n     *\n     * @access hybrid\n     *\n     * @param int $id     Id of the git repository\n     * @param int $offset Position of the first element to display {@from path}{@min 0}\n     * @param int $limit  Number of elements displayed {@from path}{@min 1}{@max 50}\n     *\n     * @return array {@type \\Tuleap\\Git\\REST\\v1\\GitBranchRepresentation}\n     *\n     * @status 200\n     * @throws RestException 401\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    public function getBranches($id, $offset = 0, $limit = self::MAX_LIMIT)\n    {\n        $this->checkAccess();\n\n        $repository = $this->getRepositoryForCurrentUser($id);\n\n        try {\n            $project = $this->getGitPHPProject($id);\n        } catch (RepositoryNotExistingException $ex) {\n            $this->sendAllowHeaders();\n            Header::sendPaginationHeaders($limit, $offset, 0, self::MAX_LIMIT);\n            return [];\n        }\n\n        $branches_refs        = $project->GetHeads();\n        $total_size           = count($branches_refs);\n        $sliced_branches_refs = array_slice($branches_refs, $offset, $limit);\n\n        $commits = [];\n        foreach ($sliced_branches_refs as $branch) {\n            try {\n                $commit = $project->GetCommit($branch);\n                if ($commit !== null) {\n                    $commits[] = $commit;\n                }\n            } catch (GitRepoRefNotFoundException $e) {\n                // ignore the branch if by any chance it is invalid\n            }\n        }\n\n        $commit_representation_collection = $this->commit_representation_builder->buildCollection($repository, ...$commits);\n\n        $result = [];\n        foreach ($sliced_branches_refs as $branch) {\n            $name = $branch;\n            try {\n                $commit = $project->GetCommit($branch);\n                if ($commit !== null) {\n                    $commit_representation = $commit_representation_collection->getRepresentation($commit);\n                    $branch_representation = new GitBranchRepresentation();\n                    $branch_representation->build($name, $commit_representation);\n\n                    $result[] = $branch_representation;\n                }\n            } catch (GitRepoRefNotFoundException $e) {\n                // ignore the branch if by any chance it is invalid\n            }\n        }\n\n        $this->optionsGetPostBranches($id);\n        Header::sendPaginationHeaders($limit, $offset, $total_size, self::MAX_LIMIT);\n\n        return $result;\n    }\n\n    /**\n     * Create a Git branch\n     *\n     * Create a branch in a git repository.<br/>\n     * To create a branch, you have to provide the branch name and the reference (another branch name or a commit SHA1)\n     *\n     * @url POST {id}/branches\n     *\n     * @access protected\n     *\n     * @param int $id Id of the git repository\n     * @param GitBranchPOSTRepresentation $representation The representation of the POST data {@from body}\n     *\n     * @status 201\n     * @throws RestException 400\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    public function createBranch($id, GitBranchPOSTRepresentation $representation): void\n    {\n        $this->checkAccess();\n        $this->optionsGetPostBranches($id);\n\n        $repository = $this->getRepositoryForCurrentUser($id);\n\n        (new BranchCreator(new Git_Exec($repository->getFullPath(), $repository->getFullPath()), new BranchCreationExecutor()))->createBranch(\n            $this->getCurrentUser(),\n            $repository,\n            $representation\n        );\n    }\n\n    /**\n     * @url OPTIONS {id}/tags\n     *\n     * @param int $id Id of the git repository\n     */\n    public function optionsGetTags($id)\n    {\n        Header::allowOptionsGet();\n    }\n\n    /**\n     * Get all the tags of a git repository\n     *\n     * @url    GET {id}/tags\n     *\n     * @access hybrid\n     *\n     * @param int $id     Id of the git repository\n     * @param int $offset Position of the first element to display {@from path}{@min 0}\n     * @param int $limit  Number of elements displayed {@from path}{@min 1}{@max 50}\n     *\n     * @return array {@type \\Tuleap\\Git\\REST\\v1\\GitTagRepresentation}\n     *\n     * @status 200\n     * @throws RestException 401\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    public function getTags($id, $offset = 0, $limit = self::MAX_LIMIT)\n    {\n        $this->checkAccess();\n\n        $repository = $this->getRepositoryForCurrentUser($id);\n\n        try {\n            $project = $this->getGitPHPProject($id);\n        } catch (RepositoryNotExistingException $ex) {\n            $this->sendAllowHeaders();\n            Header::sendPaginationHeaders($limit, $offset, 0, self::MAX_LIMIT);\n            return [];\n        }\n\n        $tags_refs        = $project->GetTags();\n        $total_size       = count($tags_refs);\n        $sliced_tags_refs = array_slice($tags_refs, $offset, $limit);\n        $commits          = [];\n\n        foreach ($sliced_tags_refs as $tag) {\n            try {\n                $commit = $project->getCommit($tag);\n                if ($commit) {\n                    $commits[] = $commit;\n                }\n            } catch (GitRepoRefNotFoundException $e) {\n                // ignore the tag if by any chance it is invalid\n            }\n        }\n\n        $commit_representation_collection = $this->commit_representation_builder->buildCollection($repository, ...$commits);\n\n        $result = [];\n        foreach ($sliced_tags_refs as $tag) {\n            $name   = $tag;\n            $commit = $project->getCommit($tag);\n            if (! $commit) {\n                continue;\n            }\n\n            try {\n                $commit_representation = $commit_representation_collection->getRepresentation($commit);\n\n                $tag_representation = new GitTagRepresentation();\n                $tag_representation->build($name, $commit_representation);\n\n                $result[] = $tag_representation;\n            } catch (GitRepoRefNotFoundException $e) {\n                // ignore the tag if by any chance it is invalid\n            }\n        }\n\n        $this->sendAllowHeaders();\n        Header::sendPaginationHeaders($limit, $offset, $total_size, self::MAX_LIMIT);\n\n        return $result;\n    }\n\n    /**\n     * @url OPTIONS {id}/commits/{commit_reference}\n     *\n     * @param int $id Id of the repository\n     * @param string $commit_reference Commit SHA-1\n     */\n    public function optionsGetCommits(int $id, string $commit_reference): void\n    {\n        Header::allowOptionsGet();\n    }\n\n    /**\n     * Get a commit\n     *\n     * @url GET {id}/commits/{commit_reference}\n     *\n     * @access hybrid\n     *\n     * @param int $id      Git repository id\n     * @param string $commit_reference Commit reference (sha-1, branch etc...)\n     *\n     *\n     * @status 200\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    public function getCommits(int $id, string $commit_reference): GitCommitRepresentation\n    {\n        $this->checkAccess();\n\n        try {\n            $project = $this->getGitPHPProject($id);\n        } catch (RepositoryNotExistingException $exception) {\n            throw new RestException(404, 'Commit not found');\n        }\n\n        $commit = $project->GetCommit($commit_reference);\n        if (! $commit) {\n             throw new RestException(404, 'Commit not found');\n        }\n\n        $repository = $this->getRepositoryForCurrentUser($id);\n\n        Header::allowOptionsGet();\n\n        return $this->commit_representation_builder->build($repository, $commit);\n    }\n\n    /**\n     * @return \\Tuleap\\Git\\GitPHP\\Project\n     * @throws RepositoryNotExistingException\n     * @throws RepositoryAccessException\n     * @throws RestException\n     */\n    private function getGitPHPProject($repository_id)\n    {\n        $user       = $this->getCurrentUser();\n        $repository = $this->getRepository($user, $repository_id);\n        $provider   = new ProjectProvider($repository);\n\n        return $provider->GetProject();\n    }\n\n    private function disconnect(GitRepository $repository, $disconnect_from_gerrit)\n    {\n        try {\n            $this->migration_handler->disconnect($repository, $disconnect_from_gerrit);\n        } catch (DeletePluginNotInstalledException $e) {\n            throw new RestException(400, 'Gerrit delete plugin not installed.');\n        } catch (RepositoryNotMigratedException $e) {\n            //Do nothing\n        }\n    }\n\n    private function migrate(\n        GitRepository $repository,\n        PFUser $user,\n        GitRepositoryGerritMigratePATCHRepresentation $migrate_to_gerrit,\n    ): void {\n        $server_id   = $migrate_to_gerrit->server;\n        $permissions = $migrate_to_gerrit->permissions;\n\n        if ($permissions !== self::MIGRATE_NO_PERMISSION && $permissions !== self::MIGRATE_PERMISSION_DEFAULT) {\n            throw new RestException(\n                400,\n                'Invalid permission provided. Valid values are ' .\n                self::MIGRATE_NO_PERMISSION . ' or ' . self::MIGRATE_PERMISSION_DEFAULT\n            );\n        }\n\n        try {\n            $this->migration_handler->migrate($repository, $server_id, $permissions, $user);\n        } catch (RepositoryCannotBeMigratedOnRestrictedGerritServerException $exception) {\n            throw new RestException(403, $exception->getMessage());\n        } catch (RepositoryCannotBeMigratedException $exception) {\n            throw new RestException(403, $exception->getMessage());\n        } catch (Git_RemoteServer_NotFoundException $exception) {\n            throw new RestException(400, 'Gerrit server does not exist');\n        } catch (RepositoryAlreadyInQueueForMigrationException $exception) {\n            //Do nothing\n        }\n    }\n\n    private function getCurrentUser()\n    {\n        return UserManager::instance()->getCurrentUser();\n    }\n\n    /**\n     * @return GitRepository|\\GitRepositoryGitoliteAdmin\n     *\n     * @throws RestException\n     */\n    private function getRepository(PFUser $user, $id): GitRepository\n    {\n        try {\n            $repository = $this->repository_factory->getRepositoryByIdUserCanSee($user, $id);\n        } catch (GitRepoNotReadableException $exception) {\n            throw new RestException(403, 'Git repository not accessible for user');\n        } catch (GitRepoNotFoundException $exception) {\n            throw new RestException(404, 'Git repository not found');\n        } catch (Exception $exception) {\n            throw new RestException(403, 'Project not accessible for user');\n        }\n\n        return $repository;\n    }\n\n    private function getPaginatedPullRequests(GitRepository $repository, $query, $limit, $offset)\n    {\n        $result = null;\n\n        EventManager::instance()->processEvent(\n            REST_GIT_PULL_REQUEST_GET_FOR_REPOSITORY,\n            [\n                'version'    => 'v1',\n                'repository' => $repository,\n                'query'      => $query,\n                'limit'      => $limit,\n                'offset'     => $offset,\n                'result'     => &$result,\n            ]\n        );\n\n        return $result;\n    }\n\n    private function checkPullRequestEndpointsAvailable()\n    {\n        $available = false;\n\n        EventManager::instance()->processEvent(\n            REST_GIT_PULL_REQUEST_ENDPOINTS,\n            [\n                'available' => &$available,\n            ]\n        );\n\n        if ($available === false) {\n            throw new RestException(404, 'PullRequest plugin not activated');\n        }\n    }\n\n    private function sendAllowHeaders()\n    {\n        Header::allowOptionsGetPatch();\n    }\n\n    private function sendPaginationHeaders($limit, $offset, $size)\n    {\n        Header::sendPaginationHeaders($limit, $offset, $size, self::MAX_LIMIT);\n    }\n\n    /**\n     * @throws RestException\n     */\n    private function getRepositoryForCurrentUser($id): GitRepository\n    {\n        $user = $this->getCurrentUser();\n\n        return $this->getRepository($user, $id);\n    }\n}\n", "<?php\n/**\n * Copyright (c) Enalean, 2022-Present. All Rights Reserved.\n *\n * This file is a part of Tuleap.\n *\n * Tuleap is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Tuleap is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Tuleap. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=1);\n\nnamespace Tuleap\\Git\\REST\\v1\\Branch;\n\nuse Git;\nuse Git_Command_Exception;\nuse Luracast\\Restler\\RestException;\nuse Tuleap\\Git\\Branch\\BranchCreationExecutor;\nuse Tuleap\\Git\\Branch\\CannotCreateNewBranchException;\nuse Tuleap\\Git\\REST\\v1\\GitBranchPOSTRepresentation;\nuse Tuleap\\Test\\PHPUnit\\TestCase;\n\nfinal class BranchCreatorTest extends TestCase\n{\n    private const REPO_ID    = 1;\n    private const PROJECT_ID = 101;\n\n    private BranchCreator $creator;\n    /**\n     * @var \\Git_Exec&\\PHPUnit\\Framework\\MockObject\\MockObject\n     */\n    private $git_exec;\n    /**\n     * @var \\PHPUnit\\Framework\\MockObject\\MockObject&BranchCreationExecutor\n     */\n    private $branch_creation_executor;\n\n    protected function setUp(): void\n    {\n        parent::setUp();\n\n        $this->git_exec                 = $this->createMock(\\Git_Exec::class);\n        $this->branch_creation_executor = $this->createMock(BranchCreationExecutor::class);\n\n        $this->creator = new BranchCreator(\n            $this->git_exec,\n            $this->branch_creation_executor\n        );\n\n        $this->git_exec->method('getAllBranchesSortedByCreationDate')->willReturn([\n            \"main\",\n            \"existing_branch_01\",\n        ]);\n\n        $this->git_exec->method('getObjectType')->willReturnMap([\n            [\"main\", \"commit\"],\n            [\"tag01\", \"tag\"],\n        ]);\n    }\n\n    public function testItAsksToCreateABranch(): void\n    {\n        $this->branch_creation_executor->expects(self::once())\n            ->method(\"createNewBranch\");\n\n        $this->creator->createBranch(\n            $this->buildMockUserWithPermissions(),\n            $this->buildMockGitRepository(),\n            GitBranchPOSTRepresentation::build(\n                \"new_branch\",\n                \"main\"\n            )\n        );\n    }\n\n    public function testItThrowsAnExceptionIfUserCannotWriteInRepository(): void\n    {\n        $this->branch_creation_executor->expects(self::never())\n            ->method(\"createNewBranch\");\n\n        $this->expectException(RestException::class);\n        $this->expectExceptionMessage(\"User cannot update the content of the repository\");\n\n        $this->creator->createBranch(\n            $this->buildMockUserWithoutPermissions(),\n            $this->buildMockGitRepository(),\n            GitBranchPOSTRepresentation::build(\n                \"new_branch\",\n                \"main\"\n            )\n        );\n    }\n\n    public function testItThrowsAnExceptionIfBranchNameIsNotValid(): void\n    {\n        $this->branch_creation_executor->expects(self::never())\n            ->method(\"createNewBranch\");\n\n        $this->expectException(RestException::class);\n        $this->expectExceptionMessage(\"The branch name new~branch is not a valid branch name\");\n\n        $this->creator->createBranch(\n            $this->buildMockUserWithPermissions(),\n            $this->buildMockGitRepository(),\n            GitBranchPOSTRepresentation::build(\n                \"new~branch\",\n                \"main\"\n            )\n        );\n    }\n\n    public function testItThrowsAnExceptionIfBranchWillBeCreatedFromATag(): void\n    {\n        $this->branch_creation_executor->expects(self::never())\n            ->method(\"createNewBranch\");\n\n        $this->expectException(RestException::class);\n        $this->expectExceptionMessage(\"The object tag01 is neither a branch nor a commit in repository repo01.\");\n\n        $this->creator->createBranch(\n            $this->buildMockUserWithPermissions(),\n            $this->buildMockGitRepository(),\n            GitBranchPOSTRepresentation::build(\n                \"new_branch\",\n                \"tag01\"\n            )\n        );\n    }\n\n    public function testItThrowsAnExceptionIfBranchAlreadyExists(): void\n    {\n        $this->branch_creation_executor->expects(self::never())\n            ->method(\"createNewBranch\");\n\n        $this->expectException(RestException::class);\n        $this->expectExceptionMessage(\"The branch existing_branch_01 already exists in the repository repo01\");\n\n        $this->creator->createBranch(\n            $this->buildMockUserWithPermissions(),\n            $this->buildMockGitRepository(),\n            GitBranchPOSTRepresentation::build(\n                \"existing_branch_01\",\n                \"main\"\n            )\n        );\n    }\n\n    public function testItThrowsAnExceptionIfReferenceDoesNotExistInRepository(): void\n    {\n        $this->branch_creation_executor->expects(self::never())\n            ->method(\"createNewBranch\");\n\n        $this->git_exec->method('getObjectType')->with(\"0\")->willThrowException(\n            new Git_Command_Exception(\"cmd\", [], 128)\n        );\n\n        $this->expectException(RestException::class);\n        $this->expectExceptionMessage(\"The object 0 does not exist in the repository repo01\");\n\n        $this->creator->createBranch(\n            $this->buildMockUserWithPermissions(),\n            $this->buildMockGitRepository(),\n            GitBranchPOSTRepresentation::build(\n                \"new_branch\",\n                \"0\"\n            )\n        );\n    }\n\n    public function testItThrowsAnExceptionIfGitCommandFailed(): void\n    {\n        $this->branch_creation_executor->expects(self::once())\n            ->method(\"createNewBranch\")\n            ->willThrowException(\n                new CannotCreateNewBranchException(\"\")\n            );\n\n        $this->expectException(RestException::class);\n        $this->expectExceptionMessageMatches(\"*An error occurred while creating the branch*\");\n\n        $this->creator->createBranch(\n            $this->buildMockUserWithPermissions(),\n            $this->buildMockGitRepository(),\n            GitBranchPOSTRepresentation::build(\n                \"new_branch\",\n                \"main\"\n            )\n        );\n    }\n\n    private function buildMockUserWithPermissions(): \\PFUser\n    {\n        $user = $this->createMock(\\PFUser::class);\n        $user->method('hasPermission')->willReturnMap([\n            [Git::PERM_WRITE, self::REPO_ID, self::PROJECT_ID, true],\n            [Git::PERM_WPLUS, self::REPO_ID, self::PROJECT_ID, true],\n        ]);\n\n        return $user;\n    }\n\n    private function buildMockUserWithoutPermissions(): \\PFUser\n    {\n        $user = $this->createMock(\\PFUser::class);\n        $user->method('hasPermission')->willReturnMap([\n            [Git::PERM_WRITE, self::REPO_ID, self::PROJECT_ID, false],\n            [Git::PERM_WPLUS, self::REPO_ID, self::PROJECT_ID, false],\n        ]);\n\n        return $user;\n    }\n\n    private function buildMockGitRepository(): \\GitRepository\n    {\n        $repository = $this->createMock(\\GitRepository::class);\n        $repository->method('getId')->willReturn(self::REPO_ID);\n        $repository->method('getProjectId')->willReturn(self::PROJECT_ID);\n        $repository->method('getName')->willReturn(\"repo01\");\n\n        return $repository;\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * Copyright (c) Enalean, 2022 - Present. All Rights Reserved.\n *\n * This file is a part of Tuleap.\n *\n * Tuleap is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Tuleap is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Tuleap; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nnamespace Tuleap\\Git\\REST\\v1\\Branch;\n\nuse Git_Command_Exception;\nuse Luracast\\Restler\\RestException;\nuse Tuleap\\Git\\Branch\\BranchCreationExecutor;\nuse Tuleap\\Git\\Branch\\BranchName;\nuse Tuleap\\Git\\Branch\\CannotCreateNewBranchException;\nuse Tuleap\\Git\\Branch\\InvalidBranchNameException;\nuse Tuleap\\Git\\Permissions\\AccessControlVerifier;\nuse Tuleap\\Git\\REST\\v1\\GitBranchPOSTRepresentation;\n\nclass BranchCreator\n{\n    private const BRANCH_PREFIX = \"refs/heads/\";\n\n    public function __construct(\n        private \\Git_Exec $git_exec,\n        private BranchCreationExecutor $branch_creation_executor,\n        private AccessControlVerifier $access_control_verifier,\n    ) {\n    }\n\n    /**\n     * @throws RestException\n     */\n    public function createBranch(\\PFUser $user, \\GitRepository $repository, GitBranchPOSTRepresentation $representation): void\n    {\n        try {\n            BranchName::fromBranchNameShortHand($representation->branch_name);\n        } catch (InvalidBranchNameException $exception) {\n            throw new RestException(\n                400,\n                sprintf(\n                    \"The branch name %s is not a valid branch name\",\n                    $representation->branch_name\n                )\n            );\n        }\n\n        if (! $this->access_control_verifier->canWrite($user, $repository, self::BRANCH_PREFIX . $representation->branch_name)) {\n            throw new RestException(\n                403,\n                sprintf(\n                    \"You are not allowed to create the branch %s in repository %s\",\n                    $representation->branch_name,\n                    $repository->getName()\n                )\n            );\n        }\n\n        $all_branches_names = $this->git_exec->getAllBranchesSortedByCreationDate();\n        if (in_array($representation->branch_name, $all_branches_names)) {\n            throw new RestException(\n                400,\n                sprintf(\n                    \"The branch %s already exists in the repository %s\",\n                    $representation->branch_name,\n                    $repository->getName()\n                )\n            );\n        }\n\n        try {\n            $object_type = $this->git_exec->getObjectType($representation->reference);\n        } catch (Git_Command_Exception $exception) {\n            throw new RestException(\n                400,\n                sprintf(\n                    \"The object %s does not exist in the repository %s\",\n                    $representation->reference,\n                    $repository->getName()\n                )\n            );\n        }\n\n        if (\n            ! in_array($representation->reference, $all_branches_names)\n            && $object_type !== 'commit'\n        ) {\n            throw new RestException(\n                400,\n                sprintf(\n                    \"The object %s is neither a branch nor a commit in repository %s.\",\n                    $representation->reference,\n                    $repository->getName()\n                )\n            );\n        }\n\n        try {\n            $this->branch_creation_executor->createNewBranch(\n                $this->git_exec,\n                self::BRANCH_PREFIX . $representation->branch_name,\n                $representation->reference\n            );\n        } catch (CannotCreateNewBranchException $exception) {\n            throw new RestException(\n                500,\n                \"An error occurred while creating the branch: \" . $exception->getMessage()\n            );\n        }\n    }\n}\n", "<?php\n/**\n * Copyright (c) Enalean, 2014 - Present. All Rights Reserved.\n *\n * This file is a part of Tuleap.\n *\n * Tuleap is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Tuleap is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Tuleap; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nnamespace Tuleap\\Git\\REST\\v1;\n\nuse EventManager;\nuse Exception;\nuse Git_Driver_Gerrit_GerritDriverFactory;\nuse Git_Driver_Gerrit_ProjectCreatorStatus;\nuse Git_Driver_Gerrit_ProjectCreatorStatusDao;\nuse Git_Exec;\nuse Git_GitRepositoryUrlManager;\nuse Git_PermissionsDao;\nuse Git_RemoteServer_Dao;\nuse Git_RemoteServer_GerritServerFactory;\nuse Git_RemoteServer_NotFoundException;\nuse Git_SystemEventManager;\nuse GitDao;\nuse GitPermissionsManager;\nuse GitRepoNotFoundException;\nuse GitRepoNotReadableException;\nuse GitRepository;\nuse GitRepositoryAlreadyExistsException;\nuse GitRepositoryFactory;\nuse Luracast\\Restler\\RestException;\nuse PFUser;\nuse ProjectHistoryDao;\nuse ProjectManager;\nuse SystemEventManager;\nuse Tuleap\\Git\\BigObjectAuthorization\\BigObjectAuthorizationDao;\nuse Tuleap\\Git\\BigObjectAuthorization\\BigObjectAuthorizationManager;\nuse Tuleap\\Git\\Branch\\BranchCreationExecutor;\nuse Tuleap\\Git\\CIBuilds\\BuildStatusChangePermissionDAO;\nuse Tuleap\\Git\\CIBuilds\\BuildStatusChangePermissionManager;\nuse Tuleap\\Git\\CIBuilds\\CITokenDao;\nuse Tuleap\\Git\\CIBuilds\\CITokenManager;\nuse Tuleap\\Git\\CommitMetadata\\CommitMetadataRetriever;\nuse Tuleap\\Git\\CommitStatus\\CommitDoesNotExistException;\nuse Tuleap\\Git\\CommitStatus\\CommitStatusCreator;\nuse Tuleap\\Git\\CommitStatus\\CommitStatusDAO;\nuse Tuleap\\Git\\CommitStatus\\CommitStatusRetriever;\nuse Tuleap\\Git\\CommitStatus\\InvalidCommitReferenceException;\nuse Tuleap\\Git\\DefaultBranch\\CannotSetANonExistingBranchAsDefaultException;\nuse Tuleap\\Git\\DefaultBranch\\DefaultBranchUpdateExecutorAsGitoliteUser;\nuse Tuleap\\Git\\DefaultBranch\\DefaultBranchUpdater;\nuse Tuleap\\Git\\Exceptions\\DeletePluginNotInstalledException;\nuse Tuleap\\Git\\Exceptions\\GitRepoRefNotFoundException;\nuse Tuleap\\Git\\Exceptions\\RepositoryAlreadyInQueueForMigrationException;\nuse Tuleap\\Git\\Exceptions\\RepositoryCannotBeMigratedException;\nuse Tuleap\\Git\\Exceptions\\RepositoryCannotBeMigratedOnRestrictedGerritServerException;\nuse Tuleap\\Git\\Exceptions\\RepositoryNotMigratedException;\nuse Tuleap\\Git\\Gitolite\\GitoliteAccessURLGenerator;\nuse Tuleap\\Git\\Gitolite\\VersionDetector;\nuse Tuleap\\Git\\GitPHP\\ProjectProvider;\nuse Tuleap\\Git\\GitPHP\\RepositoryAccessException;\nuse Tuleap\\Git\\GitPHP\\RepositoryNotExistingException;\nuse Tuleap\\Git\\Permissions\\AccessControlVerifier;\nuse Tuleap\\Git\\Permissions\\DefaultFineGrainedPermissionFactory;\nuse Tuleap\\Git\\Permissions\\FineGrainedDao;\nuse Tuleap\\Git\\Permissions\\FineGrainedPatternValidator;\nuse Tuleap\\Git\\Permissions\\FineGrainedPermissionFactory;\nuse Tuleap\\Git\\Permissions\\FineGrainedPermissionReplicator;\nuse Tuleap\\Git\\Permissions\\FineGrainedPermissionSaver;\nuse Tuleap\\Git\\Permissions\\FineGrainedPermissionSorter;\nuse Tuleap\\Git\\Permissions\\FineGrainedRegexpValidator;\nuse Tuleap\\Git\\Permissions\\FineGrainedRetriever;\nuse Tuleap\\Git\\Permissions\\HistoryValueFormatter;\nuse Tuleap\\Git\\Permissions\\PatternValidator;\nuse Tuleap\\Git\\Permissions\\RegexpFineGrainedDao;\nuse Tuleap\\Git\\Permissions\\RegexpFineGrainedEnabler;\nuse Tuleap\\Git\\Permissions\\RegexpFineGrainedRetriever;\nuse Tuleap\\Git\\Permissions\\RegexpRepositoryDao;\nuse Tuleap\\Git\\Permissions\\RegexpTemplateDao;\nuse Tuleap\\Git\\RemoteServer\\Gerrit\\MigrationHandler;\nuse Tuleap\\Git\\Repository\\GitRepositoryNameIsInvalidException;\nuse Tuleap\\Git\\Repository\\RepositoryCreator;\nuse Tuleap\\Git\\REST\\v1\\Branch\\BranchCreator;\nuse Tuleap\\Git\\XmlUgroupRetriever;\nuse Tuleap\\Http\\HttpClientFactory;\nuse Tuleap\\PullRequest\\REST\\v1\\RepositoryPullRequestRepresentation;\nuse Tuleap\\REST\\AuthenticatedResource;\nuse Tuleap\\REST\\Header;\nuse Tuleap\\REST\\ProjectStatusVerificator;\nuse UserManager;\n\ninclude_once __DIR__ . '/../../../../../src/www/project/admin/permissions.php';\n\nclass RepositoryResource extends AuthenticatedResource\n{\n    public const MAX_LIMIT = 50;\n\n    public const MIGRATE_PERMISSION_DEFAULT = 'default';\n    public const MIGRATE_NO_PERMISSION      = 'none';\n    /**\n     * @var RepositoryCreator\n     */\n    private $repository_creator;\n    /**\n     * @var GitPermissionsManager\n     */\n    private $git_permission_manager;\n    /**\n     * @var ProjectManager\n     */\n    private $project_manager;\n\n    /**\n     * @var UserManager\n     */\n    private $user_manager;\n\n    /** @var GitRepositoryFactory */\n    private $repository_factory;\n\n    /** @var RepositoryRepresentationBuilder */\n    private $representation_builder;\n\n    /** @var Git_RemoteServer_GerritServerFactory */\n    private $gerrit_server_factory;\n\n    /** @var Git_SystemEventManager */\n    private $git_system_event_manager;\n\n    /** @var MigrationHandler */\n    private $migration_handler;\n\n    /**\n     * @var CITokenManager\n     */\n    private $ci_token_manager;\n    /**\n     * @var GitCommitRepresentationBuilder\n     */\n    private $commit_representation_builder;\n\n    public function __construct()\n    {\n        $git_dao               = new GitDao();\n        $this->project_manager = ProjectManager::instance();\n        $this->user_manager    = UserManager::instance();\n        $event_manager         = EventManager::instance();\n\n        $this->repository_factory = new GitRepositoryFactory(\n            $git_dao,\n            $this->project_manager\n        );\n\n        $this->git_system_event_manager = new Git_SystemEventManager(\n            SystemEventManager::instance(),\n            $this->repository_factory\n        );\n\n        $this->gerrit_server_factory = new Git_RemoteServer_GerritServerFactory(\n            new Git_RemoteServer_Dao(),\n            $git_dao,\n            $this->git_system_event_manager,\n            $this->project_manager\n        );\n\n        $fine_grained_dao       = new FineGrainedDao();\n        $fine_grained_retriever = new FineGrainedRetriever($fine_grained_dao);\n\n        $this->git_permission_manager = new GitPermissionsManager(\n            new Git_PermissionsDao(),\n            $this->git_system_event_manager,\n            $fine_grained_dao,\n            $fine_grained_retriever\n        );\n\n        $git_plugin = \\PluginFactory::instance()->getPluginByName('git');\n        assert($git_plugin instanceof \\GitPlugin);\n        $url_manager = new \\Git_GitRepositoryUrlManager($git_plugin);\n\n        $this->representation_builder = new RepositoryRepresentationBuilder(\n            $this->git_permission_manager,\n            $this->gerrit_server_factory,\n            new \\Git_LogDao(),\n            $event_manager,\n            $url_manager\n        );\n\n        $project_history_dao     = new ProjectHistoryDao();\n        $this->migration_handler = new MigrationHandler(\n            $this->git_system_event_manager,\n            $this->gerrit_server_factory,\n            new Git_Driver_Gerrit_GerritDriverFactory(\n                new \\Tuleap\\Git\\Driver\\GerritHTTPClientFactory(HttpClientFactory::createClient()),\n                \\Tuleap\\Http\\HTTPFactoryBuilder::requestFactory(),\n                \\Tuleap\\Http\\HTTPFactoryBuilder::streamFactory(),\n                \\BackendLogger::getDefaultLogger(\\GitPlugin::LOG_IDENTIFIER),\n            ),\n            $project_history_dao,\n            new Git_Driver_Gerrit_ProjectCreatorStatus(new Git_Driver_Gerrit_ProjectCreatorStatusDao()),\n            $this->project_manager\n        );\n\n        $this->ci_token_manager = new CITokenManager(new CITokenDao());\n\n        $mirror_data_mapper = new \\Git_Mirror_MirrorDataMapper(\n            new \\Git_Mirror_MirrorDao(),\n            $this->user_manager,\n            $this->repository_factory,\n            $this->project_manager,\n            $this->git_system_event_manager,\n            new \\Git_Gitolite_GitoliteRCReader(new VersionDetector()),\n            new \\DefaultProjectMirrorDao()\n        );\n\n        $regexp_retriever     = new RegexpFineGrainedRetriever(\n            new RegexpFineGrainedDao(),\n            new RegexpRepositoryDao(),\n            new RegexpTemplateDao()\n        );\n        $ugroup_manager       = new \\UGroupManager();\n        $normalizer           = new \\PermissionsNormalizer();\n        $permissions_manager  = new \\PermissionsManager(new \\PermissionsDao());\n        $validator            = new PatternValidator(\n            new FineGrainedPatternValidator(),\n            new FineGrainedRegexpValidator(),\n            $regexp_retriever\n        );\n        $sorter               = new FineGrainedPermissionSorter();\n        $xml_ugroup_retriever = new XmlUgroupRetriever(\\BackendLogger::getDefaultLogger(\\GitPlugin::LOG_IDENTIFIER), $ugroup_manager);\n\n        $fine_grained_permission_factory = new FineGrainedPermissionFactory(\n            $fine_grained_dao,\n            $ugroup_manager,\n            $normalizer,\n            $permissions_manager,\n            $validator,\n            $sorter,\n            $xml_ugroup_retriever\n        );\n        $fine_grained_replicator         = new FineGrainedPermissionReplicator(\n            $fine_grained_dao,\n            new DefaultFineGrainedPermissionFactory(\n                $fine_grained_dao,\n                $ugroup_manager,\n                $normalizer,\n                $permissions_manager,\n                $validator,\n                $sorter\n            ),\n            new FineGrainedPermissionSaver(\n                $fine_grained_dao\n            ),\n            $fine_grained_permission_factory,\n            new RegexpFineGrainedEnabler(\n                new RegexpFineGrainedDao(),\n                new RegexpRepositoryDao(),\n                new RegexpTemplateDao()\n            ),\n            $regexp_retriever,\n            $validator\n        );\n        $history_value_formatter         = new HistoryValueFormatter(\n            $permissions_manager,\n            $ugroup_manager,\n            $fine_grained_retriever,\n            new DefaultFineGrainedPermissionFactory(\n                $fine_grained_dao,\n                $ugroup_manager,\n                $normalizer,\n                $permissions_manager,\n                $validator,\n                $sorter\n            ),\n            $fine_grained_permission_factory\n        );\n\n        $this->repository_creator = new RepositoryCreator(\n            $this->repository_factory,\n            new \\Git_Backend_Gitolite(\n                new \\Git_GitoliteDriver(\n                    \\BackendLogger::getDefaultLogger(\\GitPlugin::LOG_IDENTIFIER),\n                    $this->git_system_event_manager,\n                    $url_manager,\n                    $git_dao,\n                    new \\Git_Mirror_MirrorDao(),\n                    $git_plugin,\n                    new BigObjectAuthorizationManager(\n                        new BigObjectAuthorizationDao(),\n                        ProjectManager::instance()\n                    ),\n                    new VersionDetector(),\n                    null,\n                    null,\n                    null,\n                    null,\n                    null,\n                    null,\n                ),\n                new GitoliteAccessURLGenerator($git_plugin->getPluginInfo()),\n                new DefaultBranchUpdateExecutorAsGitoliteUser(),\n                \\BackendLogger::getDefaultLogger(\\GitPlugin::LOG_IDENTIFIER),\n            ),\n            $mirror_data_mapper,\n            new \\GitRepositoryManager(\n                $this->repository_factory,\n                $this->git_system_event_manager,\n                $git_dao,\n                \"\",\n                new \\GitRepositoryMirrorUpdater($mirror_data_mapper, $project_history_dao),\n                $mirror_data_mapper,\n                $fine_grained_replicator,\n                $project_history_dao,\n                $history_value_formatter,\n                $event_manager\n            ),\n            $this->git_permission_manager,\n            $fine_grained_replicator,\n            $project_history_dao,\n            $history_value_formatter,\n            $this->ci_token_manager,\n            $event_manager\n        );\n\n        $status_retriever   = new CommitStatusRetriever(new CommitStatusDAO());\n        $metadata_retriever = new CommitMetadataRetriever($status_retriever, $this->user_manager);\n        $url_manager        = new Git_GitRepositoryUrlManager($git_plugin);\n\n        $this->commit_representation_builder = new GitCommitRepresentationBuilder($metadata_retriever, $url_manager);\n    }\n\n    /**\n     * Return info about repository if exists\n     *\n     * @url OPTIONS {id}\n     *\n     * @param string $id Id of the repository\n     *\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    public function optionsId($id)\n    {\n        $this->sendAllowHeaders();\n    }\n\n    /**\n     * @access hybrid\n     *\n     * @param int $id Id of the repository\n     * @return GitRepositoryRepresentation | null\n     *\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    public function get($id)\n    {\n        $this->checkAccess();\n\n        $user       = $this->getCurrentUser();\n        $repository = $this->getRepository($user, $id);\n\n        $this->sendAllowHeaders();\n\n        return $this->representation_builder->build($user, $repository, GitRepositoryRepresentation::FIELDS_ALL);\n    }\n\n    /**\n     * @url OPTIONS {id}/pull_requests\n     *\n     * @param int $id Id of the repository\n     *\n     * @throws RestException 404\n     */\n    public function optionsPullRequests($id)\n    {\n        $this->checkPullRequestEndpointsAvailable();\n        $this->sendAllowHeaders();\n    }\n\n    /**\n     * Get pull requests\n     *\n     * <p>Retrieve all git repository's pull requests.</p>\n     *\n     * <p>Pull requests are sorted by descending order of creation date.</p>\n     *\n     * <p>User is not able to see a pull request in a git repository where he is not able to READ.</p>\n     *\n     * <p>\n     * <code>$query</code> parameter is optional, by default we return all pull requests. If\n     * <code>query={\"status\":\"open\"}</code> then only open pull requests are returned and if\n     * <code>query={\"status\":\"closed\"}</code> then only closed pull requests are returned.\n     * </p>\n     *\n     * <pre>\n     * /!\\ PullRequest REST routes are under construction and subject to changes /!\\\n     * </pre>\n     *\n     * @url GET {id}/pull_requests\n     *\n     * @access protected\n     *\n     * @param int    $id     Id of the repository\n     * @param string $query  JSON object of search criteria properties {@from path}\n     * @param int    $limit  Number of elements displayed per page {@from path} {@min 0} {@max 50}\n     * @param int    $offset Position of the first element to display {@from path} {@min 0}\n     *\n     * @return RepositoryPullRequestRepresentation\n     *\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    public function getPullRequests($id, $query = '', $limit = self::MAX_LIMIT, $offset = 0)\n    {\n        $this->checkAccess();\n        $this->checkPullRequestEndpointsAvailable();\n\n        $user       = $this->getCurrentUser();\n        $repository = $this->getRepository($user, $id);\n        $result     = $this->getPaginatedPullRequests($repository, $query, $limit, $offset);\n\n        $this->sendAllowHeaders();\n        $this->sendPaginationHeaders($limit, $offset, $result->total_size);\n\n        return $result;\n    }\n\n    /**\n     * Post\n     *\n     * @url    POST\n     *\n     * @access hybrid\n     *\n     *\n     * @param $project_id {@type int} {@from body} project id\n     * @param $name       {@type string} {@from body} Repository name\n     *\n     * @status 201\n     * @throws RestException 400\n     * @throws RestException 401\n     * @throws RestException 404\n     * @throws RestException 500\n     */\n    public function post($project_id, $name)\n    {\n        $this->checkAccess();\n\n        Header::allowOptionsPost();\n\n        $user    = $this->user_manager->getCurrentUser();\n        $project = $this->project_manager->getProject($project_id);\n        if ($project->isError()) {\n            throw new RestException(404, \"Given project does not exist\");\n        }\n\n        if (! $project->usesService(\\GitPlugin::SERVICE_SHORTNAME)) {\n            throw new RestException(400, \"Project does not use Git service\");\n        }\n\n        ProjectStatusVerificator::build()->checkProjectStatusAllowsAllUsersToAccessIt(\n            $project\n        );\n\n        if (! $this->git_permission_manager->userIsGitAdmin($user, $project)) {\n            throw new RestException(403, \"User does not have permissions to create a Git Repository\");\n        }\n        try {\n            $repository = $this->repository_creator->create($project, $user, $name);\n        } catch (GitRepositoryNameIsInvalidException $e) {\n            throw new RestException(400, $e->getMessage());\n        } catch (GitRepositoryAlreadyExistsException $e) {\n            throw new RestException(400, $e->getMessage());\n        } catch (Exception $e) {\n            throw new RestException(500, $e->getMessage());\n        }\n\n        return $this->get($repository->getId());\n    }\n\n    /**\n     * @url OPTIONS\n     */\n    public function options()\n    {\n        Header::allowOptionsPost();\n    }\n\n    /**\n     * @url OPTIONS {id}/statuses/{commit_reference}\n     *\n     * @param int $id Git repository id\n     * @param string $commit_reference Commit SHA-1\n     */\n    public function optionsCommitStatus($id, $commit_reference)\n    {\n        Header::allowOptionsPost();\n    }\n\n    /**\n     * Post a commit status\n     *\n     * @url    POST {id_or_path}/statuses/{commit_reference}\n     *\n     * @access hybrid\n     *\n     * @param string $id_or_path       Git repository id or Git repository path\n     * @param string $commit_reference Commit SHA-1\n     * @param string $state            {@choice failure,success,pending} {@from body}\n     * @param string $token            {@from body}{@required false}\n     *\n     * @status 201\n     * @throws RestException 403\n     * @throws RestException 404\n     * @throws RestException 400\n     */\n    public function postCommitStatus($id_or_path, $commit_reference, $state, $token = null)\n    {\n        if (ctype_digit($id_or_path)) {\n            $repository = $this->repository_factory->getRepositoryById((int) $id_or_path);\n        } else {\n            preg_match(\"/(.+?)\\/(.+)/\", $id_or_path, $path);\n            if (count($path) !== 3) {\n                throw new RestException(400, 'Bad repository path format');\n            }\n            $repository = $this->repository_factory->getByProjectNameAndPath($path[1], $path[2]);\n        }\n        if (! $repository) {\n            throw new RestException(404, 'Repository not found.');\n        }\n\n        ProjectStatusVerificator::build()->checkProjectStatusAllowsAllUsersToAccessIt(\n            $repository->getProject()\n        );\n\n        if ($token !== null) {\n            $this->checkCITokenValidity($repository, $token);\n        } else {\n            $this->checkUserHasPermission($repository);\n        }\n\n        $commit_status_creator = new CommitStatusCreator(new CommitStatusDAO());\n\n        try {\n            $commit_status_creator->createCommitStatus(\n                $repository,\n                Git_Exec::buildFromRepository($repository),\n                $commit_reference,\n                $state\n            );\n        } catch (CommitDoesNotExistException $exception) {\n            throw new RestException(404, $exception->getMessage());\n        } catch (InvalidCommitReferenceException $exception) {\n            throw new RestException(400, $exception->getMessage());\n        }\n    }\n\n    /**\n     * @throws RestException\n     */\n    private function checkCITokenValidity(GitRepository $repository, string $ci_token): void\n    {\n        $repo_ci_token = $this->ci_token_manager->getToken($repository);\n        if ($repo_ci_token === null || ! \\hash_equals($ci_token, $repo_ci_token)) {\n            throw new RestException(403, 'Invalid token');\n        }\n    }\n\n    /**\n     * @throws RestException\n     */\n    private function checkUserHasPermission(GitRepository $repository): void\n    {\n        $user                                = $this->user_manager->getCurrentUser();\n        $set_build_status_permission_manager = new BuildStatusChangePermissionManager(\n            new BuildStatusChangePermissionDAO()\n        );\n\n        if (\n            ! $set_build_status_permission_manager->canUserSetBuildStatusInRepository($user, $repository)\n        ) {\n            throw new RestException(403, 'You are not allowed to set the build status');\n        }\n    }\n\n    /**\n     * Patch Git repository\n     *\n     * Patch properties of a given Git repository\n     *\n     * <pre>\n     * /!\\ This REST route is under construction and subject to changes /!\\\n     * </pre>\n     *\n     * <br>\n     * To migrate a repository in Gerrit:\n     * <pre>\n     * {<br>\n     * &nbsp;\"migrate_to_gerrit\": {<br/>\n     * &nbsp;&nbsp;\"server\": 1,<br/>\n     * &nbsp;&nbsp;\"permissions\": \"default\"<br/>\n     * &nbsp;}<br/>\n     * }\n     * </pre>\n     *\n     * <br>\n     * To disconnect a repository in Gerrit:\n     * <pre>\n     * {<br>\n     * &nbsp;\"disconnect_from_gerrit\": \"read-only\"<br/>\n     * }\n     * </pre>\n     * <br>\n     *\n     * To change the default branch of a repository:\n     * <pre>\n     * {<br>\n     * &nbsp;\"default_branch\": \"dev\"<br/>\n     * }\n     * </pre>\n     *\n     * @url PATCH {id}\n     * @access protected\n     *\n     * @param int    $id    Id of the Git repository\n     * @param GitRepositoryGerritMigratePATCHRepresentation $migrate_to_gerrit {@from body}{@required false}\n     * @param string $disconnect_from_gerrit {@from body}{@required false} {@choice delete,read-only,noop}\n     * @param string $default_branch {@from body}{@required false} New default branch to set, the branch needs to exist\n     * @psalm-param string|null $default_branch\n     *\n     *\n     * @throws RestException 400\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    protected function patchId(\n        $id,\n        ?GitRepositoryGerritMigratePATCHRepresentation $migrate_to_gerrit = null,\n        $disconnect_from_gerrit = null,\n        ?string $default_branch = null,\n    ) {\n        $this->checkAccess();\n\n        $user       = $this->getCurrentUser();\n        $repository = $this->getRepository($user, $id);\n\n        ProjectStatusVerificator::build()->checkProjectStatusAllowsAllUsersToAccessIt(\n            $repository->getProject()\n        );\n\n        if (! $repository->userCanAdmin($user)) {\n            throw new RestException(403, 'User is not allowed to administrate this repository');\n        }\n\n        if ($migrate_to_gerrit && $disconnect_from_gerrit) {\n            throw new RestException(403, 'Bad request. You can only migrate or disconnect a Git repository');\n        }\n\n        if ($migrate_to_gerrit) {\n            $this->migrate($repository, $user, $migrate_to_gerrit);\n        }\n\n        if ($disconnect_from_gerrit) {\n            $this->disconnect($repository, $disconnect_from_gerrit);\n        }\n\n        if ($default_branch !== null) {\n            $default_branch_updater = new DefaultBranchUpdater(new DefaultBranchUpdateExecutorAsGitoliteUser());\n            try {\n                $default_branch_updater->updateDefaultBranch(Git_Exec::buildFromRepository($repository), $default_branch);\n            } catch (CannotSetANonExistingBranchAsDefaultException $exception) {\n                throw new RestException(400, $exception->getMessage(), [], $exception);\n            }\n        }\n\n        $this->sendAllowHeaders();\n    }\n\n    /**\n     * Get the tree of a git repository.\n     *\n     * Returns the repository root content when the path is not given.\n     *\n     * @url    GET {id}/tree\n     *\n     * @access hybrid\n     *\n     * @param int    $id   Id of the git repository\n     * @param string $ref  reference {@from path} {@required true}\n     * @param string $path path of the file {@from path} {@required false}\n     * @param int $offset Position of the first element to display {@from path}{@min 0}\n     * @param int $limit  Number of elements displayed {@from path}{@min 1}{@max 50}\n     *\n     * @return array {@type Tuleap\\Git\\REST\\v1\\GitTreeRepresentation}\n     *\n     * @status 200\n     * @throws RestException 401\n     * @throws RestException 403\n     * @throws RestException 404\n     * @throws RestException 500\n     *\n     */\n    public function getTree(int $id, string $ref, string $path = \"\", int $offset = 0, int $limit = self::MAX_LIMIT): array\n    {\n        $this->checkAccess();\n        $tree_representation_factory = new GitTreeRepresentationFactory();\n        try {\n            $repository   = $this->getGitPHPProject($id);\n            $tree_content = $tree_representation_factory->getGitTreeRepresentation(\n                rtrim($path, DIRECTORY_SEPARATOR),\n                $ref,\n                $repository\n            );\n            $result       = array_slice(\n                $tree_content,\n                $offset,\n                $limit\n            );\n\n            Header::allowOptionsGet();\n            Header::sendPaginationHeaders($limit, $offset, count($tree_content), self::MAX_LIMIT);\n\n            return $result;\n        } catch (\\GitRepositoryException | GitRepoRefNotFoundException $exception) {\n            throw new RestException(404, $exception->getMessage());\n        } catch (RepositoryNotExistingException $exception) {\n            throw new RestException(404, \"Reference $ref does not exist\");\n        } catch (GitObjectTypeNotSupportedException $exception) {\n            throw new RestException(500, $exception->getMessage());\n        }\n    }\n\n    /**\n     * @url OPTIONS {id}/tree\n     *\n     * @param int    $id           Id of the git repository\n     * @param string $ref          ref {@from path} {@required true}\n     * @param string $path         path {@from path} {@required false}\n     */\n    public function optionsGetTree(int $id, string $ref, string $path = \"\"): void\n    {\n        Header::allowOptionsGet();\n    }\n\n    /**\n     * @url OPTIONS {id}/files\n     *\n     * @param int    $id           Id of the git repository\n     * @param string $path_to_file path of the file {@from path}\n     * @param string $ref          ref {@from path}\n     */\n    public function optionsGetFileContent($id, $path_to_file, $ref)\n    {\n        Header::allowOptionsGet();\n    }\n\n    /**\n     * Get the content of a specific file from a git repository.\n     *\n     * The file size is in Bytes. <br/>\n     * If no ref given, master is used.\n     *\n     * @url    GET {id}/files\n     *\n     * @access hybrid\n     *\n     * @param int    $id           Id of the git repository\n     * @param string $path_to_file path of the file {@from path}\n     * @param string $ref          reference {@from path}\n     *\n     * @return GitFileContentRepresentation\n     *\n     * @status 200\n     * @throws RestException 401\n     * @throws RestException 403\n     * @throws RestException 404\n     *\n     */\n    public function getFileContent($id, $path_to_file, $ref = 'master')\n    {\n        Header::allowOptionsGet();\n\n        $this->checkAccess();\n        $file_representation_factory = new GitFileRepresentationFactory();\n        try {\n            $repository = $this->getGitPHPProject($id);\n            $result     = $file_representation_factory->getGitFileRepresentation(\n                $path_to_file,\n                $ref,\n                $repository\n            );\n\n            return $result;\n        } catch (\\GitRepositoryException $exception) {\n            throw new RestException(404, $exception->getMessage());\n        } catch (GitRepoRefNotFoundException $exception) {\n            throw new RestException(404, $exception->getMessage());\n        } catch (RepositoryNotExistingException $exception) {\n            throw new RestException(404, \"Reference $ref does not exist\");\n        }\n    }\n\n    /**\n     * @url OPTIONS {id}/branches\n     *\n     * @param int $id Id of the git repository\n     */\n    public function optionsGetPostBranches($id): void\n    {\n        Header::allowOptionsGetPost();\n    }\n\n    /**\n     * Get all the branches of a git repository\n     *\n     * @url    GET {id}/branches\n     *\n     * @access hybrid\n     *\n     * @param int $id     Id of the git repository\n     * @param int $offset Position of the first element to display {@from path}{@min 0}\n     * @param int $limit  Number of elements displayed {@from path}{@min 1}{@max 50}\n     *\n     * @return array {@type \\Tuleap\\Git\\REST\\v1\\GitBranchRepresentation}\n     *\n     * @status 200\n     * @throws RestException 401\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    public function getBranches($id, $offset = 0, $limit = self::MAX_LIMIT)\n    {\n        $this->checkAccess();\n\n        $repository = $this->getRepositoryForCurrentUser($id);\n\n        try {\n            $project = $this->getGitPHPProject($id);\n        } catch (RepositoryNotExistingException $ex) {\n            $this->sendAllowHeaders();\n            Header::sendPaginationHeaders($limit, $offset, 0, self::MAX_LIMIT);\n            return [];\n        }\n\n        $branches_refs        = $project->GetHeads();\n        $total_size           = count($branches_refs);\n        $sliced_branches_refs = array_slice($branches_refs, $offset, $limit);\n\n        $commits = [];\n        foreach ($sliced_branches_refs as $branch) {\n            try {\n                $commit = $project->GetCommit($branch);\n                if ($commit !== null) {\n                    $commits[] = $commit;\n                }\n            } catch (GitRepoRefNotFoundException $e) {\n                // ignore the branch if by any chance it is invalid\n            }\n        }\n\n        $commit_representation_collection = $this->commit_representation_builder->buildCollection($repository, ...$commits);\n\n        $result = [];\n        foreach ($sliced_branches_refs as $branch) {\n            $name = $branch;\n            try {\n                $commit = $project->GetCommit($branch);\n                if ($commit !== null) {\n                    $commit_representation = $commit_representation_collection->getRepresentation($commit);\n                    $branch_representation = new GitBranchRepresentation();\n                    $branch_representation->build($name, $commit_representation);\n\n                    $result[] = $branch_representation;\n                }\n            } catch (GitRepoRefNotFoundException $e) {\n                // ignore the branch if by any chance it is invalid\n            }\n        }\n\n        $this->optionsGetPostBranches($id);\n        Header::sendPaginationHeaders($limit, $offset, $total_size, self::MAX_LIMIT);\n\n        return $result;\n    }\n\n    /**\n     * Create a Git branch\n     *\n     * Create a branch in a git repository.<br/>\n     * To create a branch, you have to provide the branch name and the reference (another branch name or a commit SHA1)\n     *\n     * @url POST {id}/branches\n     *\n     * @access protected\n     *\n     * @param int $id Id of the git repository\n     * @param GitBranchPOSTRepresentation $representation The representation of the POST data {@from body}\n     *\n     * @status 201\n     * @throws RestException 400\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    public function createBranch($id, GitBranchPOSTRepresentation $representation): void\n    {\n        $this->checkAccess();\n        $this->optionsGetPostBranches($id);\n\n        $repository = $this->getRepositoryForCurrentUser($id);\n\n        $branch_creator = new BranchCreator(\n            new Git_Exec($repository->getFullPath(), $repository->getFullPath()),\n            new BranchCreationExecutor(),\n            new AccessControlVerifier(\n                new FineGrainedRetriever(\n                    new FineGrainedDao(),\n                ),\n                new \\System_Command(),\n            )\n        );\n\n        $branch_creator->createBranch(\n            $this->getCurrentUser(),\n            $repository,\n            $representation\n        );\n    }\n\n    /**\n     * @url OPTIONS {id}/tags\n     *\n     * @param int $id Id of the git repository\n     */\n    public function optionsGetTags($id)\n    {\n        Header::allowOptionsGet();\n    }\n\n    /**\n     * Get all the tags of a git repository\n     *\n     * @url    GET {id}/tags\n     *\n     * @access hybrid\n     *\n     * @param int $id     Id of the git repository\n     * @param int $offset Position of the first element to display {@from path}{@min 0}\n     * @param int $limit  Number of elements displayed {@from path}{@min 1}{@max 50}\n     *\n     * @return array {@type \\Tuleap\\Git\\REST\\v1\\GitTagRepresentation}\n     *\n     * @status 200\n     * @throws RestException 401\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    public function getTags($id, $offset = 0, $limit = self::MAX_LIMIT)\n    {\n        $this->checkAccess();\n\n        $repository = $this->getRepositoryForCurrentUser($id);\n\n        try {\n            $project = $this->getGitPHPProject($id);\n        } catch (RepositoryNotExistingException $ex) {\n            $this->sendAllowHeaders();\n            Header::sendPaginationHeaders($limit, $offset, 0, self::MAX_LIMIT);\n            return [];\n        }\n\n        $tags_refs        = $project->GetTags();\n        $total_size       = count($tags_refs);\n        $sliced_tags_refs = array_slice($tags_refs, $offset, $limit);\n        $commits          = [];\n\n        foreach ($sliced_tags_refs as $tag) {\n            try {\n                $commit = $project->getCommit($tag);\n                if ($commit) {\n                    $commits[] = $commit;\n                }\n            } catch (GitRepoRefNotFoundException $e) {\n                // ignore the tag if by any chance it is invalid\n            }\n        }\n\n        $commit_representation_collection = $this->commit_representation_builder->buildCollection($repository, ...$commits);\n\n        $result = [];\n        foreach ($sliced_tags_refs as $tag) {\n            $name   = $tag;\n            $commit = $project->getCommit($tag);\n            if (! $commit) {\n                continue;\n            }\n\n            try {\n                $commit_representation = $commit_representation_collection->getRepresentation($commit);\n\n                $tag_representation = new GitTagRepresentation();\n                $tag_representation->build($name, $commit_representation);\n\n                $result[] = $tag_representation;\n            } catch (GitRepoRefNotFoundException $e) {\n                // ignore the tag if by any chance it is invalid\n            }\n        }\n\n        $this->sendAllowHeaders();\n        Header::sendPaginationHeaders($limit, $offset, $total_size, self::MAX_LIMIT);\n\n        return $result;\n    }\n\n    /**\n     * @url OPTIONS {id}/commits/{commit_reference}\n     *\n     * @param int $id Id of the repository\n     * @param string $commit_reference Commit SHA-1\n     */\n    public function optionsGetCommits(int $id, string $commit_reference): void\n    {\n        Header::allowOptionsGet();\n    }\n\n    /**\n     * Get a commit\n     *\n     * @url GET {id}/commits/{commit_reference}\n     *\n     * @access hybrid\n     *\n     * @param int $id      Git repository id\n     * @param string $commit_reference Commit reference (sha-1, branch etc...)\n     *\n     *\n     * @status 200\n     * @throws RestException 403\n     * @throws RestException 404\n     */\n    public function getCommits(int $id, string $commit_reference): GitCommitRepresentation\n    {\n        $this->checkAccess();\n\n        try {\n            $project = $this->getGitPHPProject($id);\n        } catch (RepositoryNotExistingException $exception) {\n            throw new RestException(404, 'Commit not found');\n        }\n\n        $commit = $project->GetCommit($commit_reference);\n        if (! $commit) {\n             throw new RestException(404, 'Commit not found');\n        }\n\n        $repository = $this->getRepositoryForCurrentUser($id);\n\n        Header::allowOptionsGet();\n\n        return $this->commit_representation_builder->build($repository, $commit);\n    }\n\n    /**\n     * @return \\Tuleap\\Git\\GitPHP\\Project\n     * @throws RepositoryNotExistingException\n     * @throws RepositoryAccessException\n     * @throws RestException\n     */\n    private function getGitPHPProject($repository_id)\n    {\n        $user       = $this->getCurrentUser();\n        $repository = $this->getRepository($user, $repository_id);\n        $provider   = new ProjectProvider($repository);\n\n        return $provider->GetProject();\n    }\n\n    private function disconnect(GitRepository $repository, $disconnect_from_gerrit)\n    {\n        try {\n            $this->migration_handler->disconnect($repository, $disconnect_from_gerrit);\n        } catch (DeletePluginNotInstalledException $e) {\n            throw new RestException(400, 'Gerrit delete plugin not installed.');\n        } catch (RepositoryNotMigratedException $e) {\n            //Do nothing\n        }\n    }\n\n    private function migrate(\n        GitRepository $repository,\n        PFUser $user,\n        GitRepositoryGerritMigratePATCHRepresentation $migrate_to_gerrit,\n    ): void {\n        $server_id   = $migrate_to_gerrit->server;\n        $permissions = $migrate_to_gerrit->permissions;\n\n        if ($permissions !== self::MIGRATE_NO_PERMISSION && $permissions !== self::MIGRATE_PERMISSION_DEFAULT) {\n            throw new RestException(\n                400,\n                'Invalid permission provided. Valid values are ' .\n                self::MIGRATE_NO_PERMISSION . ' or ' . self::MIGRATE_PERMISSION_DEFAULT\n            );\n        }\n\n        try {\n            $this->migration_handler->migrate($repository, $server_id, $permissions, $user);\n        } catch (RepositoryCannotBeMigratedOnRestrictedGerritServerException $exception) {\n            throw new RestException(403, $exception->getMessage());\n        } catch (RepositoryCannotBeMigratedException $exception) {\n            throw new RestException(403, $exception->getMessage());\n        } catch (Git_RemoteServer_NotFoundException $exception) {\n            throw new RestException(400, 'Gerrit server does not exist');\n        } catch (RepositoryAlreadyInQueueForMigrationException $exception) {\n            //Do nothing\n        }\n    }\n\n    private function getCurrentUser()\n    {\n        return UserManager::instance()->getCurrentUser();\n    }\n\n    /**\n     * @return GitRepository|\\GitRepositoryGitoliteAdmin\n     *\n     * @throws RestException\n     */\n    private function getRepository(PFUser $user, $id): GitRepository\n    {\n        try {\n            $repository = $this->repository_factory->getRepositoryByIdUserCanSee($user, $id);\n        } catch (GitRepoNotReadableException $exception) {\n            throw new RestException(403, 'Git repository not accessible for user');\n        } catch (GitRepoNotFoundException $exception) {\n            throw new RestException(404, 'Git repository not found');\n        } catch (Exception $exception) {\n            throw new RestException(403, 'Project not accessible for user');\n        }\n\n        return $repository;\n    }\n\n    private function getPaginatedPullRequests(GitRepository $repository, $query, $limit, $offset)\n    {\n        $result = null;\n\n        EventManager::instance()->processEvent(\n            REST_GIT_PULL_REQUEST_GET_FOR_REPOSITORY,\n            [\n                'version'    => 'v1',\n                'repository' => $repository,\n                'query'      => $query,\n                'limit'      => $limit,\n                'offset'     => $offset,\n                'result'     => &$result,\n            ]\n        );\n\n        return $result;\n    }\n\n    private function checkPullRequestEndpointsAvailable()\n    {\n        $available = false;\n\n        EventManager::instance()->processEvent(\n            REST_GIT_PULL_REQUEST_ENDPOINTS,\n            [\n                'available' => &$available,\n            ]\n        );\n\n        if ($available === false) {\n            throw new RestException(404, 'PullRequest plugin not activated');\n        }\n    }\n\n    private function sendAllowHeaders()\n    {\n        Header::allowOptionsGetPatch();\n    }\n\n    private function sendPaginationHeaders($limit, $offset, $size)\n    {\n        Header::sendPaginationHeaders($limit, $offset, $size, self::MAX_LIMIT);\n    }\n\n    /**\n     * @throws RestException\n     */\n    private function getRepositoryForCurrentUser($id): GitRepository\n    {\n        $user = $this->getCurrentUser();\n\n        return $this->getRepository($user, $id);\n    }\n}\n", "<?php\n/**\n * Copyright (c) Enalean, 2022-Present. All Rights Reserved.\n *\n * This file is a part of Tuleap.\n *\n * Tuleap is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Tuleap is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Tuleap. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=1);\n\nnamespace Tuleap\\Git\\REST\\v1\\Branch;\n\nuse Git_Command_Exception;\nuse Luracast\\Restler\\RestException;\nuse Tuleap\\Git\\Branch\\BranchCreationExecutor;\nuse Tuleap\\Git\\Branch\\CannotCreateNewBranchException;\nuse Tuleap\\Git\\Permissions\\AccessControlVerifier;\nuse Tuleap\\Git\\REST\\v1\\GitBranchPOSTRepresentation;\nuse Tuleap\\Test\\Builders\\UserTestBuilder;\nuse Tuleap\\Test\\PHPUnit\\TestCase;\n\nfinal class BranchCreatorTest extends TestCase\n{\n    private const REPO_ID    = 1;\n    private const PROJECT_ID = 101;\n\n    private BranchCreator $creator;\n    /**\n     * @var \\Git_Exec&\\PHPUnit\\Framework\\MockObject\\MockObject\n     */\n    private $git_exec;\n    /**\n     * @var \\PHPUnit\\Framework\\MockObject\\MockObject&BranchCreationExecutor\n     */\n    private $branch_creation_executor;\n    /**\n     * @var AccessControlVerifier&\\PHPUnit\\Framework\\MockObject\\MockObject\n     */\n    private $access_control_verifier;\n\n    protected function setUp(): void\n    {\n        parent::setUp();\n\n        $this->git_exec                 = $this->createMock(\\Git_Exec::class);\n        $this->branch_creation_executor = $this->createMock(BranchCreationExecutor::class);\n        $this->access_control_verifier  = $this->createMock(AccessControlVerifier::class);\n\n        $this->creator = new BranchCreator(\n            $this->git_exec,\n            $this->branch_creation_executor,\n            $this->access_control_verifier\n        );\n\n        $this->git_exec->method('getAllBranchesSortedByCreationDate')->willReturn([\n            \"main\",\n            \"existing_branch_01\",\n        ]);\n\n        $this->git_exec->method('getObjectType')->willReturnMap([\n            [\"main\", \"commit\"],\n            [\"tag01\", \"tag\"],\n        ]);\n    }\n\n    public function testItAsksToCreateABranch(): void\n    {\n        $this->branch_creation_executor->expects(self::once())\n            ->method(\"createNewBranch\");\n\n        $this->creator->createBranch(\n            $this->buildMockUserWithPermissions(),\n            $this->buildMockGitRepository(),\n            GitBranchPOSTRepresentation::build(\n                \"new_branch\",\n                \"main\"\n            )\n        );\n    }\n\n    public function testItThrowsAnExceptionIfUserCannotWriteInRepository(): void\n    {\n        $this->branch_creation_executor->expects(self::never())\n            ->method(\"createNewBranch\");\n\n        $this->expectException(RestException::class);\n        $this->expectExceptionMessage(\"You are not allowed to create the branch new_branch in repository repo01\");\n\n        $this->creator->createBranch(\n            $this->buildMockUserWithoutPermissions(),\n            $this->buildMockGitRepository(),\n            GitBranchPOSTRepresentation::build(\n                \"new_branch\",\n                \"main\"\n            )\n        );\n    }\n\n    public function testItThrowsAnExceptionIfBranchNameIsNotValid(): void\n    {\n        $this->branch_creation_executor->expects(self::never())\n            ->method(\"createNewBranch\");\n\n        $this->expectException(RestException::class);\n        $this->expectExceptionMessage(\"The branch name new~branch is not a valid branch name\");\n\n        $this->creator->createBranch(\n            $this->buildMockUserWithPermissions(),\n            $this->buildMockGitRepository(),\n            GitBranchPOSTRepresentation::build(\n                \"new~branch\",\n                \"main\"\n            )\n        );\n    }\n\n    public function testItThrowsAnExceptionIfBranchWillBeCreatedFromATag(): void\n    {\n        $this->branch_creation_executor->expects(self::never())\n            ->method(\"createNewBranch\");\n\n        $this->expectException(RestException::class);\n        $this->expectExceptionMessage(\"The object tag01 is neither a branch nor a commit in repository repo01.\");\n\n        $this->creator->createBranch(\n            $this->buildMockUserWithPermissions(),\n            $this->buildMockGitRepository(),\n            GitBranchPOSTRepresentation::build(\n                \"new_branch\",\n                \"tag01\"\n            )\n        );\n    }\n\n    public function testItThrowsAnExceptionIfBranchAlreadyExists(): void\n    {\n        $this->branch_creation_executor->expects(self::never())\n            ->method(\"createNewBranch\");\n\n        $this->expectException(RestException::class);\n        $this->expectExceptionMessage(\"The branch existing_branch_01 already exists in the repository repo01\");\n\n        $this->creator->createBranch(\n            $this->buildMockUserWithPermissions(),\n            $this->buildMockGitRepository(),\n            GitBranchPOSTRepresentation::build(\n                \"existing_branch_01\",\n                \"main\"\n            )\n        );\n    }\n\n    public function testItThrowsAnExceptionIfReferenceDoesNotExistInRepository(): void\n    {\n        $this->branch_creation_executor->expects(self::never())\n            ->method(\"createNewBranch\");\n\n        $this->git_exec->method('getObjectType')->with(\"0\")->willThrowException(\n            new Git_Command_Exception(\"cmd\", [], 128)\n        );\n\n        $this->expectException(RestException::class);\n        $this->expectExceptionMessage(\"The object 0 does not exist in the repository repo01\");\n\n        $this->creator->createBranch(\n            $this->buildMockUserWithPermissions(),\n            $this->buildMockGitRepository(),\n            GitBranchPOSTRepresentation::build(\n                \"new_branch\",\n                \"0\"\n            )\n        );\n    }\n\n    public function testItThrowsAnExceptionIfGitCommandFailed(): void\n    {\n        $this->branch_creation_executor->expects(self::once())\n            ->method(\"createNewBranch\")\n            ->willThrowException(\n                new CannotCreateNewBranchException(\"\")\n            );\n\n        $this->expectException(RestException::class);\n        $this->expectExceptionMessageMatches(\"*An error occurred while creating the branch*\");\n\n        $this->creator->createBranch(\n            $this->buildMockUserWithPermissions(),\n            $this->buildMockGitRepository(),\n            GitBranchPOSTRepresentation::build(\n                \"new_branch\",\n                \"main\"\n            )\n        );\n    }\n\n    private function buildMockUserWithPermissions(): \\PFUser\n    {\n        $user = UserTestBuilder::anActiveUser()->build();\n        $this->access_control_verifier->method('canWrite')->willReturn(true);\n\n        return $user;\n    }\n\n    private function buildMockUserWithoutPermissions(): \\PFUser\n    {\n        $user = UserTestBuilder::anActiveUser()->build();\n        $this->access_control_verifier->method('canWrite')->willReturn(false);\n\n        return $user;\n    }\n\n    private function buildMockGitRepository(): \\GitRepository\n    {\n        $repository = $this->createMock(\\GitRepository::class);\n        $repository->method('getId')->willReturn(self::REPO_ID);\n        $repository->method('getProjectId')->willReturn(self::PROJECT_ID);\n        $repository->method('getName')->willReturn(\"repo01\");\n\n        return $repository;\n    }\n}\n"], "filenames": ["plugins/git/include/REST/v1/Branch/BranchCreator.php", "plugins/git/include/REST/v1/RepositoryResource.class.php", "plugins/git/tests/unit/REST/v1/Branch/BranchCreatorTest.php"], "buggy_code_start_loc": [24, 74, 26], "buggy_code_end_loc": [63, 923, 220], "fixing_code_start_loc": [23, 75, 25], "fixing_code_end_loc": [68, 935, 221], "type": "CWE-862", "message": "Tuleap is a Free & Open Source Suite to improve management of software developments and collaboration. In affected versions Tuleap does not properly verify permissions when creating branches with the REST API in Git repositories using the fine grained permissions. Users can create branches via the REST endpoint `POST git/:id/branches` regardless of the permissions set on the repository. This issue has been fixed in version 13.10.99.82 Tuleap Community Edition as well as in version 13.10-3 of Tuleap Enterprise Edition. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-31128", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-01T17:15:08.403", "lastModified": "2022-08-06T02:42:11.500", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Tuleap is a Free & Open Source Suite to improve management of software developments and collaboration. In affected versions Tuleap does not properly verify permissions when creating branches with the REST API in Git repositories using the fine grained permissions. Users can create branches via the REST endpoint `POST git/:id/branches` regardless of the permissions set on the repository. This issue has been fixed in version 13.10.99.82 Tuleap Community Edition as well as in version 13.10-3 of Tuleap Enterprise Edition. Users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "Tuleap es una suite libre y de c\u00f3digo abierto para mejorar la administraci\u00f3n de los desarrollos de software y la colaboraci\u00f3n. En las versiones afectadas, Tuleap no verifica correctamente los permisos cuando son creadas ramas con la API REST en repositorios Git usando los permisos de grano fino. Los usuarios pueden crear ramas por medio del endpoint REST \"POST git/:id/branches\" independientemente de los permisos establecidos en el repositorio. Este problema ha sido corregido en la versi\u00f3n 13.10.99.82 de Tuleap Community Edition, as\u00ed como en la versi\u00f3n 13.10-3 de Tuleap Enterprise Edition. Es recomendado a usuarios actualizar. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:enalean:tuleap:*:*:*:*:community:*:*:*", "versionStartIncluding": "13.9.9.110", "versionEndExcluding": "13.10.99.82", "matchCriteriaId": "066172DD-53FB-4CD1-9A5D-3BEE64B96187"}, {"vulnerable": true, "criteria": "cpe:2.3:a:enalean:tuleap:*:*:*:*:enterprise:*:*:*", "versionStartIncluding": "13.10", "versionEndExcluding": "13.10-3", "matchCriteriaId": "20FB1276-F4A5-4123-B2E5-7220D5A41B25"}]}]}], "references": [{"url": "https://github.com/Enalean/tuleap/commit/58ecb1dee1c46075d3e089980301ebfbe0bafd33", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Enalean/tuleap/security/advisories/GHSA-2p49-vgcx-5w79", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://tuleap.net/plugins/git/tuleap/tuleap/stable?a=commit&h=58ecb1dee1c46075d3e089980301ebfbe0bafd33", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://tuleap.net/plugins/tracker/?aid=27538", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/Enalean/tuleap/commit/58ecb1dee1c46075d3e089980301ebfbe0bafd33"}}