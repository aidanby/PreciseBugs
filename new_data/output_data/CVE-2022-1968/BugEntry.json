{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * search.c: code for normal mode searching commands\n */\n\n#include \"vim.h\"\n\n#ifdef FEAT_EVAL\nstatic void set_vv_searchforward(void);\nstatic int first_submatch(regmmatch_T *rp);\n#endif\n#ifdef FEAT_FIND_ID\nstatic void show_pat_in_path(char_u *, int,\n\t\t\t\t\t int, int, FILE *, linenr_T *, long);\n#endif\n\ntypedef struct searchstat\n{\n    int\t    cur;\t    // current position of found words\n    int\t    cnt;\t    // total count of found words\n    int\t    exact_match;    // TRUE if matched exactly on specified position\n    int\t    incomplete;\t    // 0: search was fully completed\n\t\t\t    // 1: recomputing was timed out\n\t\t\t    // 2: max count exceeded\n    int\t    last_maxcount;  // the max count of the last search\n} searchstat_T;\n\nstatic void cmdline_search_stat(int dirc, pos_T *pos, pos_T *cursor_pos, int show_top_bot_msg, char_u *msgbuf, int recompute, int maxcount, long timeout);\nstatic void update_search_stat(int dirc, pos_T *pos, pos_T *cursor_pos, searchstat_T *stat, int recompute, int maxcount, long timeout);\n\n#define SEARCH_STAT_DEF_TIMEOUT 40L\n#define SEARCH_STAT_DEF_MAX_COUNT 99\n#define SEARCH_STAT_BUF_LEN 12\n\n/*\n * This file contains various searching-related routines. These fall into\n * three groups:\n * 1. string searches (for /, ?, n, and N)\n * 2. character searches within a single line (for f, F, t, T, etc)\n * 3. \"other\" kinds of searches like the '%' command, and 'word' searches.\n */\n\n/*\n * String searches\n *\n * The string search functions are divided into two levels:\n * lowest:  searchit(); uses an pos_T for starting position and found match.\n * Highest: do_search(); uses curwin->w_cursor; calls searchit().\n *\n * The last search pattern is remembered for repeating the same search.\n * This pattern is shared between the :g, :s, ? and / commands.\n * This is in search_regcomp().\n *\n * The actual string matching is done using a heavily modified version of\n * Henry Spencer's regular expression library.  See regexp.c.\n */\n\n/*\n * Two search patterns are remembered: One for the :substitute command and\n * one for other searches.  last_idx points to the one that was used the last\n * time.\n */\nstatic spat_T spats[2] =\n{\n    {NULL, TRUE, FALSE, {'/', 0, 0, 0L}},\t// last used search pat\n    {NULL, TRUE, FALSE, {'/', 0, 0, 0L}}\t// last used substitute pat\n};\n\nstatic int last_idx = 0;\t// index in spats[] for RE_LAST\n\nstatic char_u lastc[2] = {NUL, NUL};\t// last character searched for\nstatic int lastcdir = FORWARD;\t\t// last direction of character search\nstatic int last_t_cmd = TRUE;\t\t// last search t_cmd\nstatic char_u\tlastc_bytes[MB_MAXBYTES + 1];\nstatic int\tlastc_bytelen = 1;\t// >1 for multi-byte char\n\n// copy of spats[], for keeping the search patterns while executing autocmds\nstatic spat_T\t    saved_spats[2];\nstatic char_u\t    *saved_mr_pattern = NULL;\n# ifdef FEAT_SEARCH_EXTRA\nstatic int\t    saved_spats_last_idx = 0;\nstatic int\t    saved_spats_no_hlsearch = 0;\n# endif\n\n// allocated copy of pattern used by search_regcomp()\nstatic char_u\t    *mr_pattern = NULL;\n\n#ifdef FEAT_FIND_ID\n/*\n * Type used by find_pattern_in_path() to remember which included files have\n * been searched already.\n */\ntypedef struct SearchedFile\n{\n    FILE\t*fp;\t\t// File pointer\n    char_u\t*name;\t\t// Full name of file\n    linenr_T\tlnum;\t\t// Line we were up to in file\n    int\t\tmatched;\t// Found a match in this file\n} SearchedFile;\n#endif\n\n/*\n * translate search pattern for vim_regcomp()\n *\n * pat_save == RE_SEARCH: save pat in spats[RE_SEARCH].pat (normal search cmd)\n * pat_save == RE_SUBST: save pat in spats[RE_SUBST].pat (:substitute command)\n * pat_save == RE_BOTH: save pat in both patterns (:global command)\n * pat_use  == RE_SEARCH: use previous search pattern if \"pat\" is NULL\n * pat_use  == RE_SUBST: use previous substitute pattern if \"pat\" is NULL\n * pat_use  == RE_LAST: use last used pattern if \"pat\" is NULL\n * options & SEARCH_HIS: put search string in history\n * options & SEARCH_KEEP: keep previous search pattern\n *\n * returns FAIL if failed, OK otherwise.\n */\n    int\nsearch_regcomp(\n    char_u\t*pat,\n    int\t\tpat_save,\n    int\t\tpat_use,\n    int\t\toptions,\n    regmmatch_T\t*regmatch)\t// return: pattern and ignore-case flag\n{\n    int\t\tmagic;\n    int\t\ti;\n\n    rc_did_emsg = FALSE;\n    magic = magic_isset();\n\n    /*\n     * If no pattern given, use a previously defined pattern.\n     */\n    if (pat == NULL || *pat == NUL)\n    {\n\tif (pat_use == RE_LAST)\n\t    i = last_idx;\n\telse\n\t    i = pat_use;\n\tif (spats[i].pat == NULL)\t// pattern was never defined\n\t{\n\t    if (pat_use == RE_SUBST)\n\t\temsg(_(e_no_previous_substitute_regular_expression));\n\t    else\n\t\temsg(_(e_no_previous_regular_expression));\n\t    rc_did_emsg = TRUE;\n\t    return FAIL;\n\t}\n\tpat = spats[i].pat;\n\tmagic = spats[i].magic;\n\tno_smartcase = spats[i].no_scs;\n    }\n    else if (options & SEARCH_HIS)\t// put new pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\n    vim_free(mr_pattern);\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's')\n\tmr_pattern = reverse_text(pat);\n    else\n#endif\n\tmr_pattern = vim_strsave(pat);\n\n    /*\n     * Save the currently used pattern in the appropriate place,\n     * unless the pattern should not be remembered.\n     */\n    if (!(options & SEARCH_KEEP)\n\t\t\t       && (cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n    {\n\t// search or global command\n\tif (pat_save == RE_SEARCH || pat_save == RE_BOTH)\n\t    save_re_pat(RE_SEARCH, pat, magic);\n\t// substitute or global command\n\tif (pat_save == RE_SUBST || pat_save == RE_BOTH)\n\t    save_re_pat(RE_SUBST, pat, magic);\n    }\n\n    regmatch->rmm_ic = ignorecase(pat);\n    regmatch->rmm_maxcol = 0;\n    regmatch->regprog = vim_regcomp(pat, magic ? RE_MAGIC : 0);\n    if (regmatch->regprog == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Get search pattern used by search_regcomp().\n */\n    char_u *\nget_search_pat(void)\n{\n    return mr_pattern;\n}\n\n#if defined(FEAT_RIGHTLEFT) || defined(PROTO)\n/*\n * Reverse text into allocated memory.\n * Returns the allocated string, NULL when out of memory.\n */\n    char_u *\nreverse_text(char_u *s)\n{\n    unsigned\tlen;\n    unsigned\ts_i, rev_i;\n    char_u\t*rev;\n\n    /*\n     * Reverse the pattern.\n     */\n    len = (unsigned)STRLEN(s);\n    rev = alloc(len + 1);\n    if (rev != NULL)\n    {\n\trev_i = len;\n\tfor (s_i = 0; s_i < len; ++s_i)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tint\tmb_len;\n\n\t\tmb_len = (*mb_ptr2len)(s + s_i);\n\t\trev_i -= mb_len;\n\t\tmch_memmove(rev + rev_i, s + s_i, mb_len);\n\t\ts_i += mb_len - 1;\n\t    }\n\t    else\n\t\trev[--rev_i] = s[s_i];\n\n\t}\n\trev[len] = NUL;\n    }\n    return rev;\n}\n#endif\n\n    void\nsave_re_pat(int idx, char_u *pat, int magic)\n{\n    if (spats[idx].pat != pat)\n    {\n\tvim_free(spats[idx].pat);\n\tspats[idx].pat = vim_strsave(pat);\n\tspats[idx].magic = magic;\n\tspats[idx].no_scs = no_smartcase;\n\tlast_idx = idx;\n#ifdef FEAT_SEARCH_EXTRA\n\t// If 'hlsearch' set and search pat changed: need redraw.\n\tif (p_hls)\n\t    redraw_all_later(SOME_VALID);\n\tset_no_hlsearch(FALSE);\n#endif\n    }\n}\n\n/*\n * Save the search patterns, so they can be restored later.\n * Used before/after executing autocommands and user functions.\n */\nstatic int save_level = 0;\n\n    void\nsave_search_patterns(void)\n{\n    if (save_level++ == 0)\n    {\n\tsaved_spats[0] = spats[0];\n\tif (spats[0].pat != NULL)\n\t    saved_spats[0].pat = vim_strsave(spats[0].pat);\n\tsaved_spats[1] = spats[1];\n\tif (spats[1].pat != NULL)\n\t    saved_spats[1].pat = vim_strsave(spats[1].pat);\n\tif (mr_pattern == NULL)\n\t    saved_mr_pattern = NULL;\n\telse\n\t    saved_mr_pattern = vim_strsave(mr_pattern);\n#ifdef FEAT_SEARCH_EXTRA\n\tsaved_spats_last_idx = last_idx;\n\tsaved_spats_no_hlsearch = no_hlsearch;\n#endif\n    }\n}\n\n    void\nrestore_search_patterns(void)\n{\n    if (--save_level == 0)\n    {\n\tvim_free(spats[0].pat);\n\tspats[0] = saved_spats[0];\n#if defined(FEAT_EVAL)\n\tset_vv_searchforward();\n#endif\n\tvim_free(spats[1].pat);\n\tspats[1] = saved_spats[1];\n\tvim_free(mr_pattern);\n\tmr_pattern = saved_mr_pattern;\n#ifdef FEAT_SEARCH_EXTRA\n\tlast_idx = saved_spats_last_idx;\n\tset_no_hlsearch(saved_spats_no_hlsearch);\n#endif\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_search_patterns(void)\n{\n    vim_free(spats[0].pat);\n    vim_free(spats[1].pat);\n    VIM_CLEAR(mr_pattern);\n}\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n// copy of spats[RE_SEARCH], for keeping the search patterns while incremental\n// searching\nstatic spat_T\t    saved_last_search_spat;\nstatic int\t    did_save_last_search_spat = 0;\nstatic int\t    saved_last_idx = 0;\nstatic int\t    saved_no_hlsearch = 0;\nstatic int\t    saved_search_match_endcol;\nstatic int\t    saved_search_match_lines;\n\n/*\n * Save and restore the search pattern for incremental highlight search\n * feature.\n *\n * It's similar to but different from save_search_patterns() and\n * restore_search_patterns(), because the search pattern must be restored when\n * canceling incremental searching even if it's called inside user functions.\n */\n    void\nsave_last_search_pattern(void)\n{\n    if (++did_save_last_search_spat != 1)\n\t// nested call, nothing to do\n\treturn;\n\n    saved_last_search_spat = spats[RE_SEARCH];\n    if (spats[RE_SEARCH].pat != NULL)\n\tsaved_last_search_spat.pat = vim_strsave(spats[RE_SEARCH].pat);\n    saved_last_idx = last_idx;\n    saved_no_hlsearch = no_hlsearch;\n}\n\n    void\nrestore_last_search_pattern(void)\n{\n    if (--did_save_last_search_spat > 0)\n\t// nested call, nothing to do\n\treturn;\n    if (did_save_last_search_spat != 0)\n    {\n\tiemsg(\"restore_last_search_pattern() called more often than save_last_search_pattern()\");\n\treturn;\n    }\n\n    vim_free(spats[RE_SEARCH].pat);\n    spats[RE_SEARCH] = saved_last_search_spat;\n    saved_last_search_spat.pat = NULL;\n# if defined(FEAT_EVAL)\n    set_vv_searchforward();\n# endif\n    last_idx = saved_last_idx;\n    set_no_hlsearch(saved_no_hlsearch);\n}\n\n/*\n * Save and restore the incsearch highlighting variables.\n * This is required so that calling searchcount() at does not invalidate the\n * incsearch highlighting.\n */\n    static void\nsave_incsearch_state(void)\n{\n    saved_search_match_endcol = search_match_endcol;\n    saved_search_match_lines  = search_match_lines;\n}\n\n    static void\nrestore_incsearch_state(void)\n{\n    search_match_endcol = saved_search_match_endcol;\n    search_match_lines  = saved_search_match_lines;\n}\n\n    char_u *\nlast_search_pattern(void)\n{\n    return spats[RE_SEARCH].pat;\n}\n#endif\n\n/*\n * Return TRUE when case should be ignored for search pattern \"pat\".\n * Uses the 'ignorecase' and 'smartcase' options.\n */\n    int\nignorecase(char_u *pat)\n{\n    return ignorecase_opt(pat, p_ic, p_scs);\n}\n\n/*\n * As ignorecase() put pass the \"ic\" and \"scs\" flags.\n */\n    int\nignorecase_opt(char_u *pat, int ic_in, int scs)\n{\n    int\t\tic = ic_in;\n\n    if (ic && !no_smartcase && scs\n\t\t\t    && !(ctrl_x_mode_not_default() && curbuf->b_p_inf))\n\tic = !pat_has_uppercase(pat);\n    no_smartcase = FALSE;\n\n    return ic;\n}\n\n/*\n * Return TRUE if pattern \"pat\" has an uppercase character.\n */\n    int\npat_has_uppercase(char_u *pat)\n{\n    char_u *p = pat;\n    magic_T magic_val = MAGIC_ON;\n\n    // get the magicness of the pattern\n    (void)skip_regexp_ex(pat, NUL, magic_isset(), NULL, NULL, &magic_val);\n\n    while (*p != NUL)\n    {\n\tint\t\tl;\n\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t{\n\t    if (enc_utf8 && utf_isupper(utf_ptr2char(p)))\n\t\treturn TRUE;\n\t    p += l;\n\t}\n\telse if (*p == '\\\\' && magic_val <= MAGIC_ON)\n\t{\n\t    if (p[1] == '_' && p[2] != NUL)  // skip \"\\_X\"\n\t\tp += 3;\n\t    else if (p[1] == '%' && p[2] != NUL)  // skip \"\\%X\"\n\t\tp += 3;\n\t    else if (p[1] != NUL)  // skip \"\\X\"\n\t\tp += 2;\n\t    else\n\t\tp += 1;\n\t}\n\telse if ((*p == '%' || *p == '_') && magic_val == MAGIC_ALL)\n\t{\n\t    if (p[1] != NUL)  // skip \"_X\" and %X\n\t\tp += 2;\n\t    else\n\t\tp++;\n\t}\n\telse if (MB_ISUPPER(*p))\n\t    return TRUE;\n\telse\n\t    ++p;\n    }\n    return FALSE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    char_u *\nlast_csearch(void)\n{\n    return lastc_bytes;\n}\n\n    int\nlast_csearch_forward(void)\n{\n    return lastcdir == FORWARD;\n}\n\n    int\nlast_csearch_until(void)\n{\n    return last_t_cmd == TRUE;\n}\n\n    void\nset_last_csearch(int c, char_u *s UNUSED, int len UNUSED)\n{\n    *lastc = c;\n    lastc_bytelen = len;\n    if (len)\n\tmemcpy(lastc_bytes, s, len);\n    else\n\tCLEAR_FIELD(lastc_bytes);\n}\n#endif\n\n    void\nset_csearch_direction(int cdir)\n{\n    lastcdir = cdir;\n}\n\n    void\nset_csearch_until(int t_cmd)\n{\n    last_t_cmd = t_cmd;\n}\n\n    char_u *\nlast_search_pat(void)\n{\n    return spats[last_idx].pat;\n}\n\n/*\n * Reset search direction to forward.  For \"gd\" and \"gD\" commands.\n */\n    void\nreset_search_dir(void)\n{\n    spats[0].off.dir = '/';\n#if defined(FEAT_EVAL)\n    set_vv_searchforward();\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_VIMINFO)\n/*\n * Set the last search pattern.  For \":let @/ =\" and viminfo.\n * Also set the saved search pattern, so that this works in an autocommand.\n */\n    void\nset_last_search_pat(\n    char_u\t*s,\n    int\t\tidx,\n    int\t\tmagic,\n    int\t\tsetlast)\n{\n    vim_free(spats[idx].pat);\n    // An empty string means that nothing should be matched.\n    if (*s == NUL)\n\tspats[idx].pat = NULL;\n    else\n\tspats[idx].pat = vim_strsave(s);\n    spats[idx].magic = magic;\n    spats[idx].no_scs = FALSE;\n    spats[idx].off.dir = '/';\n#if defined(FEAT_EVAL)\n    set_vv_searchforward();\n#endif\n    spats[idx].off.line = FALSE;\n    spats[idx].off.end = FALSE;\n    spats[idx].off.off = 0;\n    if (setlast)\n\tlast_idx = idx;\n    if (save_level)\n    {\n\tvim_free(saved_spats[idx].pat);\n\tsaved_spats[idx] = spats[0];\n\tif (spats[idx].pat == NULL)\n\t    saved_spats[idx].pat = NULL;\n\telse\n\t    saved_spats[idx].pat = vim_strsave(spats[idx].pat);\n# ifdef FEAT_SEARCH_EXTRA\n\tsaved_spats_last_idx = last_idx;\n# endif\n    }\n# ifdef FEAT_SEARCH_EXTRA\n    // If 'hlsearch' set and search pat changed: need redraw.\n    if (p_hls && idx == last_idx && !no_hlsearch)\n\tredraw_all_later(SOME_VALID);\n# endif\n}\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n/*\n * Get a regexp program for the last used search pattern.\n * This is used for highlighting all matches in a window.\n * Values returned in regmatch->regprog and regmatch->rmm_ic.\n */\n    void\nlast_pat_prog(regmmatch_T *regmatch)\n{\n    if (spats[last_idx].pat == NULL)\n    {\n\tregmatch->regprog = NULL;\n\treturn;\n    }\n    ++emsg_off;\t\t// So it doesn't beep if bad expr\n    (void)search_regcomp((char_u *)\"\", 0, last_idx, SEARCH_KEEP, regmatch);\n    --emsg_off;\n}\n#endif\n\n/*\n * Lowest level search function.\n * Search for 'count'th occurrence of pattern \"pat\" in direction \"dir\".\n * Start at position \"pos\" and return the found position in \"pos\".\n *\n * if (options & SEARCH_MSG) == 0 don't give any messages\n * if (options & SEARCH_MSG) == SEARCH_NFMSG don't give 'notfound' messages\n * if (options & SEARCH_MSG) == SEARCH_MSG give all messages\n * if (options & SEARCH_HIS) put search pattern in history\n * if (options & SEARCH_END) return position at end of match\n * if (options & SEARCH_START) accept match at pos itself\n * if (options & SEARCH_KEEP) keep previous search pattern\n * if (options & SEARCH_FOLD) match only once in a closed fold\n * if (options & SEARCH_PEEK) check for typed char, cancel search\n * if (options & SEARCH_COL) start at pos->col instead of zero\n *\n * Return FAIL (zero) for failure, non-zero for success.\n * When FEAT_EVAL is defined, returns the index of the first matching\n * subpattern plus one; one if there was none.\n */\n    int\nsearchit(\n    win_T\t*win,\t\t// window to search in; can be NULL for a\n\t\t\t\t// buffer without a window!\n    buf_T\t*buf,\n    pos_T\t*pos,\n    pos_T\t*end_pos,\t// set to end of the match, unless NULL\n    int\t\tdir,\n    char_u\t*pat,\n    long\tcount,\n    int\t\toptions,\n    int\t\tpat_use,\t// which pattern to use when \"pat\" is empty\n    searchit_arg_T *extra_arg)\t// optional extra arguments, can be NULL\n{\n    int\t\tfound;\n    linenr_T\tlnum;\t\t// no init to shut up Apollo cc\n    colnr_T\tcol;\n    regmmatch_T\tregmatch;\n    char_u\t*ptr;\n    colnr_T\tmatchcol;\n    lpos_T\tendpos;\n    lpos_T\tmatchpos;\n    int\t\tloop;\n    pos_T\tstart_pos;\n    int\t\tat_first_line;\n    int\t\textra_col;\n    int\t\tstart_char_len;\n    int\t\tmatch_ok;\n    long\tnmatched;\n    int\t\tsubmatch = 0;\n    int\t\tfirst_match = TRUE;\n    int\t\tcalled_emsg_before = called_emsg;\n#ifdef FEAT_SEARCH_EXTRA\n    int\t\tbreak_loop = FALSE;\n#endif\n    linenr_T\tstop_lnum = 0;\t// stop after this line number when != 0\n#ifdef FEAT_RELTIME\n    proftime_T\t*tm = NULL;\t// timeout limit or NULL\n    int\t\t*timed_out = NULL;  // set when timed out or NULL\n#endif\n\n    if (extra_arg != NULL)\n    {\n\tstop_lnum = extra_arg->sa_stop_lnum;\n#ifdef FEAT_RELTIME\n\ttm = extra_arg->sa_tm;\n\ttimed_out = &extra_arg->sa_timed_out;\n#endif\n    }\n\n    if (search_regcomp(pat, RE_SEARCH, pat_use,\n\t\t   (options & (SEARCH_HIS + SEARCH_KEEP)), &regmatch) == FAIL)\n    {\n\tif ((options & SEARCH_MSG) && !rc_did_emsg)\n\t    semsg(_(e_invalid_search_string_str), mr_pattern);\n\treturn FAIL;\n    }\n\n    /*\n     * find the string\n     */\n    do\t// loop for count\n    {\n\t// When not accepting a match at the start position set \"extra_col\" to\n\t// a non-zero value.  Don't do that when starting at MAXCOL, since\n\t// MAXCOL + 1 is zero.\n\tif (pos->col == MAXCOL)\n\t    start_char_len = 0;\n\t// Watch out for the \"col\" being MAXCOL - 2, used in a closed fold.\n\telse if (has_mbyte\n\t\t    && pos->lnum >= 1 && pos->lnum <= buf->b_ml.ml_line_count\n\t\t\t\t\t\t    && pos->col < MAXCOL - 2)\n\t{\n\t    ptr = ml_get_buf(buf, pos->lnum, FALSE);\n\t    if ((int)STRLEN(ptr) <= pos->col)\n\t\tstart_char_len = 1;\n\t    else\n\t\tstart_char_len = (*mb_ptr2len)(ptr + pos->col);\n\t}\n\telse\n\t    start_char_len = 1;\n\tif (dir == FORWARD)\n\t{\n\t    if (options & SEARCH_START)\n\t\textra_col = 0;\n\t    else\n\t\textra_col = start_char_len;\n\t}\n\telse\n\t{\n\t    if (options & SEARCH_START)\n\t\textra_col = start_char_len;\n\t    else\n\t\textra_col = 0;\n\t}\n\n\tstart_pos = *pos;\t// remember start pos for detecting no match\n\tfound = 0;\t\t// default: not found\n\tat_first_line = TRUE;\t// default: start in first line\n\tif (pos->lnum == 0)\t// correct lnum for when starting in line 0\n\t{\n\t    pos->lnum = 1;\n\t    pos->col = 0;\n\t    at_first_line = FALSE;  // not in first line now\n\t}\n\n\t/*\n\t * Start searching in current line, unless searching backwards and\n\t * we're in column 0.\n\t * If we are searching backwards, in column 0, and not including the\n\t * current position, gain some efficiency by skipping back a line.\n\t * Otherwise begin the search in the current line.\n\t */\n\tif (dir == BACKWARD && start_pos.col == 0\n\t\t\t\t\t     && (options & SEARCH_START) == 0)\n\t{\n\t    lnum = pos->lnum - 1;\n\t    at_first_line = FALSE;\n\t}\n\telse\n\t    lnum = pos->lnum;\n\n\tfor (loop = 0; loop <= 1; ++loop)   // loop twice if 'wrapscan' set\n\t{\n\t    for ( ; lnum > 0 && lnum <= buf->b_ml.ml_line_count;\n\t\t\t\t\t   lnum += dir, at_first_line = FALSE)\n\t    {\n\t\t// Stop after checking \"stop_lnum\", if it's set.\n\t\tif (stop_lnum != 0 && (dir == FORWARD\n\t\t\t\t       ? lnum > stop_lnum : lnum < stop_lnum))\n\t\t    break;\n#ifdef FEAT_RELTIME\n\t\t// Stop after passing the \"tm\" time limit.\n\t\tif (tm != NULL && profile_passed_limit(tm))\n\t\t    break;\n#endif\n\n\t\t/*\n\t\t * Look for a match somewhere in line \"lnum\".\n\t\t */\n\t\tcol = at_first_line && (options & SEARCH_COL) ? pos->col\n\t\t\t\t\t\t\t\t : (colnr_T)0;\n\t\tnmatched = vim_regexec_multi(&regmatch, win, buf,\n\t\t\t\t\t     lnum, col,\n#ifdef FEAT_RELTIME\n\t\t\t\t\t     tm, timed_out\n#else\n\t\t\t\t\t     NULL, NULL\n#endif\n\t\t\t\t\t\t      );\n\t\t// vim_regexec_multi() may clear \"regprog\"\n\t\tif (regmatch.regprog == NULL)\n\t\t    break;\n\t\t// Abort searching on an error (e.g., out of stack).\n\t\tif (called_emsg > called_emsg_before\n#ifdef FEAT_RELTIME\n\t\t\t|| (timed_out != NULL && *timed_out)\n#endif\n\t\t\t)\n\t\t    break;\n\t\tif (nmatched > 0)\n\t\t{\n\t\t    // match may actually be in another line when using \\zs\n\t\t    matchpos = regmatch.startpos[0];\n\t\t    endpos = regmatch.endpos[0];\n#ifdef FEAT_EVAL\n\t\t    submatch = first_submatch(&regmatch);\n#endif\n\t\t    // \"lnum\" may be past end of buffer for \"\\n\\zs\".\n\t\t    if (lnum + matchpos.lnum > buf->b_ml.ml_line_count)\n\t\t\tptr = (char_u *)\"\";\n\t\t    else\n\t\t\tptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);\n\n\t\t    /*\n\t\t     * Forward search in the first line: match should be after\n\t\t     * the start position. If not, continue at the end of the\n\t\t     * match (this is vi compatible) or on the next char.\n\t\t     */\n\t\t    if (dir == FORWARD && at_first_line)\n\t\t    {\n\t\t\tmatch_ok = TRUE;\n\t\t\t/*\n\t\t\t * When the match starts in a next line it's certainly\n\t\t\t * past the start position.\n\t\t\t * When match lands on a NUL the cursor will be put\n\t\t\t * one back afterwards, compare with that position,\n\t\t\t * otherwise \"/$\" will get stuck on end of line.\n\t\t\t */\n\t\t\twhile (matchpos.lnum == 0\n\t\t\t\t&& ((options & SEARCH_END) && first_match\n\t\t\t\t    ?  (nmatched == 1\n\t\t\t\t\t&& (int)endpos.col - 1\n\t\t\t\t\t     < (int)start_pos.col + extra_col)\n\t\t\t\t    : ((int)matchpos.col\n\t\t\t\t\t\t  - (ptr[matchpos.col] == NUL)\n\t\t\t\t\t    < (int)start_pos.col + extra_col)))\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * If vi-compatible searching, continue at the end\n\t\t\t     * of the match, otherwise continue one position\n\t\t\t     * forward.\n\t\t\t     */\n\t\t\t    if (vim_strchr(p_cpo, CPO_SEARCH) != NULL)\n\t\t\t    {\n\t\t\t\tif (nmatched > 1)\n\t\t\t\t{\n\t\t\t\t    // end is in next line, thus no match in\n\t\t\t\t    // this line\n\t\t\t\t    match_ok = FALSE;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\tmatchcol = endpos.col;\n\t\t\t\t// for empty match: advance one char\n\t\t\t\tif (matchcol == matchpos.col\n\t\t\t\t\t\t      && ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol +=\n\t\t\t\t\t  (*mb_ptr2len)(ptr + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tmatchcol = matchpos.col;\n\t\t\t\tif (ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol += (*mb_ptr2len)(ptr\n\t\t\t\t\t\t\t\t  + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    if (matchcol == 0 && (options & SEARCH_START))\n\t\t\t\tbreak;\n\t\t\t    if (ptr[matchcol] == NUL\n\t\t\t\t    || (nmatched = vim_regexec_multi(&regmatch,\n\t\t\t\t\t      win, buf, lnum + matchpos.lnum,\n\t\t\t\t\t      matchcol,\n#ifdef FEAT_RELTIME\n\t\t\t\t\t      tm, timed_out\n#else\n\t\t\t\t\t      NULL, NULL\n#endif\n\t\t\t\t\t      )) == 0)\n\t\t\t    {\n\t\t\t\tmatch_ok = FALSE;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    // vim_regexec_multi() may clear \"regprog\"\n\t\t\t    if (regmatch.regprog == NULL)\n\t\t\t\tbreak;\n\t\t\t    matchpos = regmatch.startpos[0];\n\t\t\t    endpos = regmatch.endpos[0];\n# ifdef FEAT_EVAL\n\t\t\t    submatch = first_submatch(&regmatch);\n# endif\n\n\t\t\t    // Need to get the line pointer again, a\n\t\t\t    // multi-line search may have made it invalid.\n\t\t\t    ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);\n\t\t\t}\n\t\t\tif (!match_ok)\n\t\t\t    continue;\n\t\t    }\n\t\t    if (dir == BACKWARD)\n\t\t    {\n\t\t\t/*\n\t\t\t * Now, if there are multiple matches on this line,\n\t\t\t * we have to get the last one. Or the last one before\n\t\t\t * the cursor, if we're on that line.\n\t\t\t * When putting the new cursor at the end, compare\n\t\t\t * relative to the end of the match.\n\t\t\t */\n\t\t\tmatch_ok = FALSE;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t    // Remember a position that is before the start\n\t\t\t    // position, we use it if it's the last match in\n\t\t\t    // the line.  Always accept a position after\n\t\t\t    // wrapping around.\n\t\t\t    if (loop\n\t\t\t\t|| ((options & SEARCH_END)\n\t\t\t\t    ? (lnum + regmatch.endpos[0].lnum\n\t\t\t\t\t\t\t      < start_pos.lnum\n\t\t\t\t\t|| (lnum + regmatch.endpos[0].lnum\n\t\t\t\t\t\t\t     == start_pos.lnum\n\t\t\t\t\t     && (int)regmatch.endpos[0].col - 1\n\t\t\t\t\t\t\t< (int)start_pos.col\n\t\t\t\t\t\t\t\t+ extra_col))\n\t\t\t\t    : (lnum + regmatch.startpos[0].lnum\n\t\t\t\t\t\t\t      < start_pos.lnum\n\t\t\t\t\t|| (lnum + regmatch.startpos[0].lnum\n\t\t\t\t\t\t\t     == start_pos.lnum\n\t\t\t\t\t     && (int)regmatch.startpos[0].col\n\t\t\t\t\t\t      < (int)start_pos.col\n\t\t\t\t\t\t\t      + extra_col))))\n\t\t\t    {\n\t\t\t\tmatch_ok = TRUE;\n\t\t\t\tmatchpos = regmatch.startpos[0];\n\t\t\t\tendpos = regmatch.endpos[0];\n# ifdef FEAT_EVAL\n\t\t\t\tsubmatch = first_submatch(&regmatch);\n# endif\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tbreak;\n\n\t\t\t    /*\n\t\t\t     * We found a valid match, now check if there is\n\t\t\t     * another one after it.\n\t\t\t     * If vi-compatible searching, continue at the end\n\t\t\t     * of the match, otherwise continue one position\n\t\t\t     * forward.\n\t\t\t     */\n\t\t\t    if (vim_strchr(p_cpo, CPO_SEARCH) != NULL)\n\t\t\t    {\n\t\t\t\tif (nmatched > 1)\n\t\t\t\t    break;\n\t\t\t\tmatchcol = endpos.col;\n\t\t\t\t// for empty match: advance one char\n\t\t\t\tif (matchcol == matchpos.col\n\t\t\t\t\t\t      && ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol +=\n\t\t\t\t\t  (*mb_ptr2len)(ptr + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t// Stop when the match is in a next line.\n\t\t\t\tif (matchpos.lnum > 0)\n\t\t\t\t    break;\n\t\t\t\tmatchcol = matchpos.col;\n\t\t\t\tif (ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol +=\n\t\t\t\t\t  (*mb_ptr2len)(ptr + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    if (ptr[matchcol] == NUL\n\t\t\t\t    || (nmatched = vim_regexec_multi(&regmatch,\n\t\t\t\t\t      win, buf, lnum + matchpos.lnum,\n\t\t\t\t\t      matchcol,\n#ifdef FEAT_RELTIME\n\t\t\t\t\t      tm, timed_out\n#else\n\t\t\t\t\t      NULL, NULL\n#endif\n\t\t\t\t\t    )) == 0)\n\t\t\t    {\n#ifdef FEAT_RELTIME\n\t\t\t\t// If the search timed out, we did find a match\n\t\t\t\t// but it might be the wrong one, so that's not\n\t\t\t\t// OK.\n\t\t\t\tif (timed_out != NULL && *timed_out)\n\t\t\t\t    match_ok = FALSE;\n#endif\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    // vim_regexec_multi() may clear \"regprog\"\n\t\t\t    if (regmatch.regprog == NULL)\n\t\t\t\tbreak;\n\n\t\t\t    // Need to get the line pointer again, a\n\t\t\t    // multi-line search may have made it invalid.\n\t\t\t    ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If there is only a match after the cursor, skip\n\t\t\t * this match.\n\t\t\t */\n\t\t\tif (!match_ok)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // With the SEARCH_END option move to the last character\n\t\t    // of the match.  Don't do it for an empty match, end\n\t\t    // should be same as start then.\n\t\t    if ((options & SEARCH_END) && !(options & SEARCH_NOOF)\n\t\t\t    && !(matchpos.lnum == endpos.lnum\n\t\t\t\t&& matchpos.col == endpos.col))\n\t\t    {\n\t\t\t// For a match in the first column, set the position\n\t\t\t// on the NUL in the previous line.\n\t\t\tpos->lnum = lnum + endpos.lnum;\n\t\t\tpos->col = endpos.col;\n\t\t\tif (endpos.col == 0)\n\t\t\t{\n\t\t\t    if (pos->lnum > 1)  // just in case\n\t\t\t    {\n\t\t\t\t--pos->lnum;\n\t\t\t\tpos->col = (colnr_T)STRLEN(ml_get_buf(buf,\n\t\t\t\t\t\t\t   pos->lnum, FALSE));\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    --pos->col;\n\t\t\t    if (has_mbyte\n\t\t\t\t    && pos->lnum <= buf->b_ml.ml_line_count)\n\t\t\t    {\n\t\t\t\tptr = ml_get_buf(buf, pos->lnum, FALSE);\n\t\t\t\tpos->col -= (*mb_head_off)(ptr, ptr + pos->col);\n\t\t\t    }\n\t\t\t}\n\t\t\tif (end_pos != NULL)\n\t\t\t{\n\t\t\t    end_pos->lnum = lnum + matchpos.lnum;\n\t\t\t    end_pos->col = matchpos.col;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tpos->lnum = lnum + matchpos.lnum;\n\t\t\tpos->col = matchpos.col;\n\t\t\tif (end_pos != NULL)\n\t\t\t{\n\t\t\t    end_pos->lnum = lnum + endpos.lnum;\n\t\t\t    end_pos->col = endpos.col;\n\t\t\t}\n\t\t    }\n\t\t    pos->coladd = 0;\n\t\t    if (end_pos != NULL)\n\t\t\tend_pos->coladd = 0;\n\t\t    found = 1;\n\t\t    first_match = FALSE;\n\n\t\t    // Set variables used for 'incsearch' highlighting.\n\t\t    search_match_lines = endpos.lnum - matchpos.lnum;\n\t\t    search_match_endcol = endpos.col;\n\t\t    break;\n\t\t}\n\t\tline_breakcheck();\t// stop if ctrl-C typed\n\t\tif (got_int)\n\t\t    break;\n\n#ifdef FEAT_SEARCH_EXTRA\n\t\t// Cancel searching if a character was typed.  Used for\n\t\t// 'incsearch'.  Don't check too often, that would slowdown\n\t\t// searching too much.\n\t\tif ((options & SEARCH_PEEK)\n\t\t\t&& ((lnum - pos->lnum) & 0x3f) == 0\n\t\t\t&& char_avail())\n\t\t{\n\t\t    break_loop = TRUE;\n\t\t    break;\n\t\t}\n#endif\n\n\t\tif (loop && lnum == start_pos.lnum)\n\t\t    break;\t    // if second loop, stop where started\n\t    }\n\t    at_first_line = FALSE;\n\n\t    // vim_regexec_multi() may clear \"regprog\"\n\t    if (regmatch.regprog == NULL)\n\t\tbreak;\n\n\t    /*\n\t     * Stop the search if wrapscan isn't set, \"stop_lnum\" is\n\t     * specified, after an interrupt, after a match and after looping\n\t     * twice.\n\t     */\n\t    if (!p_ws || stop_lnum != 0 || got_int\n\t\t\t\t\t    || called_emsg > called_emsg_before\n#ifdef FEAT_RELTIME\n\t\t\t\t|| (timed_out != NULL && *timed_out)\n#endif\n#ifdef FEAT_SEARCH_EXTRA\n\t\t\t\t|| break_loop\n#endif\n\t\t\t\t|| found || loop)\n\t\tbreak;\n\n\t    /*\n\t     * If 'wrapscan' is set we continue at the other end of the file.\n\t     * If 'shortmess' does not contain 's', we give a message.\n\t     * This message is also remembered in keep_msg for when the screen\n\t     * is redrawn. The keep_msg is cleared whenever another message is\n\t     * written.\n\t     */\n\t    if (dir == BACKWARD)    // start second loop at the other end\n\t\tlnum = buf->b_ml.ml_line_count;\n\t    else\n\t\tlnum = 1;\n\t    if (!shortmess(SHM_SEARCH) && (options & SEARCH_MSG))\n\t\tgive_warning((char_u *)_(dir == BACKWARD\n\t\t\t\t\t  ? top_bot_msg : bot_top_msg), TRUE);\n\t    if (extra_arg != NULL)\n\t\textra_arg->sa_wrapped = TRUE;\n\t}\n\tif (got_int || called_emsg > called_emsg_before\n#ifdef FEAT_RELTIME\n\t\t|| (timed_out != NULL && *timed_out)\n#endif\n#ifdef FEAT_SEARCH_EXTRA\n\t\t|| break_loop\n#endif\n\t\t)\n\t    break;\n    }\n    while (--count > 0 && found);   // stop after count matches or no match\n\n    vim_regfree(regmatch.regprog);\n\n    if (!found)\t\t    // did not find it\n    {\n\tif (got_int)\n\t    emsg(_(e_interrupted));\n\telse if ((options & SEARCH_MSG) == SEARCH_MSG)\n\t{\n\t    if (p_ws)\n\t\tsemsg(_(e_pattern_not_found_str), mr_pattern);\n\t    else if (lnum == 0)\n\t\tsemsg(_(e_search_hit_top_without_match_for_str), mr_pattern);\n\t    else\n\t\tsemsg(_(e_search_hit_bottom_without_match_for_str), mr_pattern);\n\t}\n\treturn FAIL;\n    }\n\n    // A pattern like \"\\n\\zs\" may go past the last line.\n    if (pos->lnum > buf->b_ml.ml_line_count)\n    {\n\tpos->lnum = buf->b_ml.ml_line_count;\n\tpos->col = (int)STRLEN(ml_get_buf(buf, pos->lnum, FALSE));\n\tif (pos->col > 0)\n\t    --pos->col;\n    }\n\n    return submatch + 1;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_PROTO)\n    void\nset_search_direction(int cdir)\n{\n    spats[0].off.dir = cdir;\n}\n\n    static void\nset_vv_searchforward(void)\n{\n    set_vim_var_nr(VV_SEARCHFORWARD, (long)(spats[0].off.dir == '/'));\n}\n\n/*\n * Return the number of the first subpat that matched.\n * Return zero if none of them matched.\n */\n    static int\nfirst_submatch(regmmatch_T *rp)\n{\n    int\t\tsubmatch;\n\n    for (submatch = 1; ; ++submatch)\n    {\n\tif (rp->startpos[submatch].lnum >= 0)\n\t    break;\n\tif (submatch == 9)\n\t{\n\t    submatch = 0;\n\t    break;\n\t}\n    }\n    return submatch;\n}\n#endif\n\n/*\n * Highest level string search function.\n * Search for the 'count'th occurrence of pattern 'pat' in direction 'dirc'\n *\t\t  If 'dirc' is 0: use previous dir.\n *    If 'pat' is NULL or empty : use previous string.\n *    If 'options & SEARCH_REV' : go in reverse of previous dir.\n *    If 'options & SEARCH_ECHO': echo the search command and handle options\n *    If 'options & SEARCH_MSG' : may give error message\n *    If 'options & SEARCH_OPT' : interpret optional flags\n *    If 'options & SEARCH_HIS' : put search pattern in history\n *    If 'options & SEARCH_NOOF': don't add offset to position\n *    If 'options & SEARCH_MARK': set previous context mark\n *    If 'options & SEARCH_KEEP': keep previous search pattern\n *    If 'options & SEARCH_START': accept match at curpos itself\n *    If 'options & SEARCH_PEEK': check for typed char, cancel search\n *\n * Careful: If spats[0].off.line == TRUE and spats[0].off.off == 0 this\n * makes the movement linewise without moving the match position.\n *\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\n    int\ndo_search(\n    oparg_T\t    *oap,\t// can be NULL\n    int\t\t    dirc,\t// '/' or '?'\n    int\t\t    search_delim, // the delimiter for the search, e.g. '%' in\n\t\t\t\t  // s%regex%replacement%\n    char_u\t    *pat,\n    long\t    count,\n    int\t\t    options,\n    searchit_arg_T  *sia)\t// optional arguments or NULL\n{\n    pos_T\t    pos;\t// position of the last match\n    char_u\t    *searchstr;\n    soffset_T\t    old_off;\n    int\t\t    retval;\t// Return value\n    char_u\t    *p;\n    long\t    c;\n    char_u\t    *dircp;\n    char_u\t    *strcopy = NULL;\n    char_u\t    *ps;\n    char_u\t    *msgbuf = NULL;\n    size_t\t    len;\n    int\t\t    has_offset = FALSE;\n\n    /*\n     * A line offset is not remembered, this is vi compatible.\n     */\n    if (spats[0].off.line && vim_strchr(p_cpo, CPO_LINEOFF) != NULL)\n    {\n\tspats[0].off.line = FALSE;\n\tspats[0].off.off = 0;\n    }\n\n    /*\n     * Save the values for when (options & SEARCH_KEEP) is used.\n     * (there is no \"if ()\" around this because gcc wants them initialized)\n     */\n    old_off = spats[0].off;\n\n    pos = curwin->w_cursor;\t// start searching at the cursor position\n\n    /*\n     * Find out the direction of the search.\n     */\n    if (dirc == 0)\n\tdirc = spats[0].off.dir;\n    else\n    {\n\tspats[0].off.dir = dirc;\n#if defined(FEAT_EVAL)\n\tset_vv_searchforward();\n#endif\n    }\n    if (options & SEARCH_REV)\n    {\n#ifdef MSWIN\n\t// There is a bug in the Visual C++ 2.2 compiler which means that\n\t// dirc always ends up being '/'\n\tdirc = (dirc == '/')  ?  '?'  :  '/';\n#else\n\tif (dirc == '/')\n\t    dirc = '?';\n\telse\n\t    dirc = '/';\n#endif\n    }\n\n#ifdef FEAT_FOLDING\n    // If the cursor is in a closed fold, don't find another match in the same\n    // fold.\n    if (dirc == '/')\n    {\n\tif (hasFolding(pos.lnum, NULL, &pos.lnum))\n\t    pos.col = MAXCOL - 2;\t// avoid overflow when adding 1\n    }\n    else\n    {\n\tif (hasFolding(pos.lnum, &pos.lnum, NULL))\n\t    pos.col = 0;\n    }\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n    /*\n     * Turn 'hlsearch' highlighting back on.\n     */\n    if (no_hlsearch && !(options & SEARCH_KEEP))\n    {\n\tredraw_all_later(SOME_VALID);\n\tset_no_hlsearch(FALSE);\n    }\n#endif\n\n    /*\n     * Repeat the search when pattern followed by ';', e.g. \"/foo/;?bar\".\n     */\n    for (;;)\n    {\n\tint\t\tshow_top_bot_msg = FALSE;\n\n\tsearchstr = pat;\n\tdircp = NULL;\n\t\t\t\t\t    // use previous pattern\n\tif (pat == NULL || *pat == NUL || *pat == search_delim)\n\t{\n\t    if (spats[RE_SEARCH].pat == NULL)\t    // no previous pattern\n\t    {\n\t\tsearchstr = spats[RE_SUBST].pat;\n\t\tif (searchstr == NULL)\n\t\t{\n\t\t    emsg(_(e_no_previous_regular_expression));\n\t\t    retval = 0;\n\t\t    goto end_do_search;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// make search_regcomp() use spats[RE_SEARCH].pat\n\t\tsearchstr = (char_u *)\"\";\n\t    }\n\t}\n\n\tif (pat != NULL && *pat != NUL)\t// look for (new) offset\n\t{\n\t    /*\n\t     * Find end of regular expression.\n\t     * If there is a matching '/' or '?', toss it.\n\t     */\n\t    ps = strcopy;\n\t    p = skip_regexp_ex(pat, search_delim, magic_isset(),\n\t\t\t\t\t\t\t&strcopy, NULL, NULL);\n\t    if (strcopy != ps)\n\t    {\n\t\t// made a copy of \"pat\" to change \"\\?\" to \"?\"\n\t\tsearchcmdlen += (int)(STRLEN(pat) - STRLEN(strcopy));\n\t\tpat = strcopy;\n\t\tsearchstr = strcopy;\n\t    }\n\t    if (*p == search_delim)\n\t    {\n\t\tdircp = p;\t// remember where we put the NUL\n\t\t*p++ = NUL;\n\t    }\n\t    spats[0].off.line = FALSE;\n\t    spats[0].off.end = FALSE;\n\t    spats[0].off.off = 0;\n\t    /*\n\t     * Check for a line offset or a character offset.\n\t     * For get_address (echo off) we don't check for a character\n\t     * offset, because it is meaningless and the 's' could be a\n\t     * substitute command.\n\t     */\n\t    if (*p == '+' || *p == '-' || VIM_ISDIGIT(*p))\n\t\tspats[0].off.line = TRUE;\n\t    else if ((options & SEARCH_OPT)\n\t\t\t\t      && (*p == 'e' || *p == 's' || *p == 'b'))\n\t    {\n\t\tif (*p == 'e')\t\t// end\n\t\t    spats[0].off.end = SEARCH_END;\n\t\t++p;\n\t    }\n\t    if (VIM_ISDIGIT(*p) || *p == '+' || *p == '-')  // got an offset\n\t    {\n\t\t\t\t\t    // 'nr' or '+nr' or '-nr'\n\t\tif (VIM_ISDIGIT(*p) || VIM_ISDIGIT(*(p + 1)))\n\t\t    spats[0].off.off = atol((char *)p);\n\t\telse if (*p == '-')\t    // single '-'\n\t\t    spats[0].off.off = -1;\n\t\telse\t\t\t    // single '+'\n\t\t    spats[0].off.off = 1;\n\t\t++p;\n\t\twhile (VIM_ISDIGIT(*p))\t    // skip number\n\t\t    ++p;\n\t    }\n\n\t    // compute length of search command for get_address()\n\t    searchcmdlen += (int)(p - pat);\n\n\t    pat = p;\t\t\t    // put pat after search command\n\t}\n\n\tif ((options & SEARCH_ECHO) && messaging()\n\t\t&& !msg_silent\n\t\t&& (!cmd_silent || !shortmess(SHM_SEARCHCOUNT)))\n\t{\n\t    char_u\t*trunc;\n\t    char_u\toff_buf[40];\n\t    size_t\toff_len = 0;\n\n\t    // Compute msg_row early.\n\t    msg_start();\n\n\t    // Get the offset, so we know how long it is.\n\t    if (!cmd_silent &&\n\t\t    (spats[0].off.line || spats[0].off.end || spats[0].off.off))\n\t    {\n\t\tp = off_buf;\n\t\t*p++ = dirc;\n\t\tif (spats[0].off.end)\n\t\t    *p++ = 'e';\n\t\telse if (!spats[0].off.line)\n\t\t    *p++ = 's';\n\t\tif (spats[0].off.off > 0 || spats[0].off.line)\n\t\t    *p++ = '+';\n\t\t*p = NUL;\n\t\tif (spats[0].off.off != 0 || spats[0].off.line)\n\t\t    sprintf((char *)p, \"%ld\", spats[0].off.off);\n\t\toff_len = STRLEN(off_buf);\n\t    }\n\n\t    if (*searchstr == NUL)\n\t\tp = spats[0].pat;\n\t    else\n\t\tp = searchstr;\n\n\t    if (!shortmess(SHM_SEARCHCOUNT) || cmd_silent)\n\t    {\n\t\t// Reserve enough space for the search pattern + offset +\n\t\t// search stat.  Use all the space available, so that the\n\t\t// search state is right aligned.  If there is not enough space\n\t\t// msg_strtrunc() will shorten in the middle.\n\t\tif (msg_scrolled != 0 && !cmd_silent)\n\t\t    // Use all the columns.\n\t\t    len = (int)(Rows - msg_row) * Columns - 1;\n\t\telse\n\t\t    // Use up to 'showcmd' column.\n\t\t    len = (int)(Rows - msg_row - 1) * Columns + sc_col - 1;\n\t\tif (len < STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3)\n\t\t    len = STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3;\n\t    }\n\t    else\n\t\t// Reserve enough space for the search pattern + offset.\n\t\tlen = STRLEN(p) + off_len + 3;\n\n\t    vim_free(msgbuf);\n\t    msgbuf = alloc(len);\n\t    if (msgbuf != NULL)\n\t    {\n\t\tvim_memset(msgbuf, ' ', len);\n\t\tmsgbuf[len - 1] = NUL;\n\t\t// do not fill the msgbuf buffer, if cmd_silent is set, leave it\n\t\t// empty for the search_stat feature.\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    msgbuf[0] = dirc;\n\n\t\t    if (enc_utf8 && utf_iscomposing(utf_ptr2char(p)))\n\t\t    {\n\t\t\t// Use a space to draw the composing char on.\n\t\t\tmsgbuf[1] = ' ';\n\t\t\tmch_memmove(msgbuf + 2, p, STRLEN(p));\n\t\t    }\n\t\t    else\n\t\t\tmch_memmove(msgbuf + 1, p, STRLEN(p));\n\t\t    if (off_len > 0)\n\t\t\tmch_memmove(msgbuf + STRLEN(p) + 1, off_buf, off_len);\n\n\t\t    trunc = msg_strtrunc(msgbuf, TRUE);\n\t\t    if (trunc != NULL)\n\t\t    {\n\t\t\tvim_free(msgbuf);\n\t\t\tmsgbuf = trunc;\n\t\t    }\n\n#ifdef FEAT_RIGHTLEFT\n\t\t    // The search pattern could be shown on the right in\n\t\t    // rightleft mode, but the 'ruler' and 'showcmd' area use\n\t\t    // it too, thus it would be blanked out again very soon.\n\t\t    // Show it on the left, but do reverse the text.\n\t\t    if (curwin->w_p_rl && *curwin->w_p_rlc == 's')\n\t\t    {\n\t\t\tchar_u *r;\n\t\t\tsize_t pat_len;\n\n\t\t\tr = reverse_text(msgbuf);\n\t\t\tif (r != NULL)\n\t\t\t{\n\t\t\t    vim_free(msgbuf);\n\t\t\t    msgbuf = r;\n\t\t\t    // move reversed text to beginning of buffer\n\t\t\t    while (*r != NUL && *r == ' ')\n\t\t\t\tr++;\n\t\t\t    pat_len = msgbuf + STRLEN(msgbuf) - r;\n\t\t\t    mch_memmove(msgbuf, r, pat_len);\n\t\t\t    // overwrite old text\n\t\t\t    if ((size_t)(r - msgbuf) >= pat_len)\n\t\t\t\tvim_memset(r, ' ', pat_len);\n\t\t\t    else\n\t\t\t\tvim_memset(msgbuf + pat_len, ' ', r - msgbuf);\n\t\t\t}\n\t\t    }\n#endif\n\t\t    msg_outtrans(msgbuf);\n\t\t    msg_clr_eos();\n\t\t    msg_check();\n\n\t\t    gotocmdline(FALSE);\n\t\t    out_flush();\n\t\t    msg_nowait = TRUE;\t    // don't wait for this message\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * If there is a character offset, subtract it from the current\n\t * position, so we don't get stuck at \"?pat?e+2\" or \"/pat/s-2\".\n\t * Skip this if pos.col is near MAXCOL (closed fold).\n\t * This is not done for a line offset, because then we would not be vi\n\t * compatible.\n\t */\n\tif (!spats[0].off.line && spats[0].off.off && pos.col < MAXCOL - 2)\n\t{\n\t    if (spats[0].off.off > 0)\n\t    {\n\t\tfor (c = spats[0].off.off; c; --c)\n\t\t    if (decl(&pos) == -1)\n\t\t\tbreak;\n\t\tif (c)\t\t\t// at start of buffer\n\t\t{\n\t\t    pos.lnum = 0;\t// allow lnum == 0 here\n\t\t    pos.col = MAXCOL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tfor (c = spats[0].off.off; c; ++c)\n\t\t    if (incl(&pos) == -1)\n\t\t\tbreak;\n\t\tif (c)\t\t\t// at end of buffer\n\t\t{\n\t\t    pos.lnum = curbuf->b_ml.ml_line_count + 1;\n\t\t    pos.col = 0;\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * The actual search.\n\t */\n\tc = searchit(curwin, curbuf, &pos, NULL,\n\t\t\t\t\t      dirc == '/' ? FORWARD : BACKWARD,\n\t\tsearchstr, count, spats[0].off.end + (options &\n\t\t       (SEARCH_KEEP + SEARCH_PEEK + SEARCH_HIS\n\t\t\t+ SEARCH_MSG + SEARCH_START\n\t\t\t+ ((pat != NULL && *pat == ';') ? 0 : SEARCH_NOOF))),\n\t\tRE_LAST, sia);\n\n\tif (dircp != NULL)\n\t    *dircp = search_delim; // restore second '/' or '?' for normal_cmd()\n\n\tif (!shortmess(SHM_SEARCH)\n\t\t&& ((dirc == '/' && LT_POS(pos, curwin->w_cursor))\n\t\t\t    || (dirc == '?' && LT_POS(curwin->w_cursor, pos))))\n\t    show_top_bot_msg = TRUE;\n\n\tif (c == FAIL)\n\t{\n\t    retval = 0;\n\t    goto end_do_search;\n\t}\n\tif (spats[0].off.end && oap != NULL)\n\t    oap->inclusive = TRUE;  // 'e' includes last character\n\n\tretval = 1;\t\t    // pattern found\n\n\t/*\n\t * Add character and/or line offset\n\t */\n\tif (!(options & SEARCH_NOOF) || (pat != NULL && *pat == ';'))\n\t{\n\t    pos_T org_pos = pos;\n\n\t    if (spats[0].off.line)\t// Add the offset to the line number.\n\t    {\n\t\tc = pos.lnum + spats[0].off.off;\n\t\tif (c < 1)\n\t\t    pos.lnum = 1;\n\t\telse if (c > curbuf->b_ml.ml_line_count)\n\t\t    pos.lnum = curbuf->b_ml.ml_line_count;\n\t\telse\n\t\t    pos.lnum = c;\n\t\tpos.col = 0;\n\n\t\tretval = 2;\t    // pattern found, line offset added\n\t    }\n\t    else if (pos.col < MAXCOL - 2)\t// just in case\n\t    {\n\t\t// to the right, check for end of file\n\t\tc = spats[0].off.off;\n\t\tif (c > 0)\n\t\t{\n\t\t    while (c-- > 0)\n\t\t\tif (incl(&pos) == -1)\n\t\t\t    break;\n\t\t}\n\t\t// to the left, check for start of file\n\t\telse\n\t\t{\n\t\t    while (c++ < 0)\n\t\t\tif (decl(&pos) == -1)\n\t\t\t    break;\n\t\t}\n\t    }\n\t    if (!EQUAL_POS(pos, org_pos))\n\t\thas_offset = TRUE;\n\t}\n\n\t// Show [1/15] if 'S' is not in 'shortmess'.\n\tif ((options & SEARCH_ECHO)\n\t\t&& messaging()\n\t\t&& !msg_silent\n\t\t&& c != FAIL\n\t\t&& !shortmess(SHM_SEARCHCOUNT)\n\t\t&& msgbuf != NULL)\n\t     cmdline_search_stat(dirc, &pos, &curwin->w_cursor,\n\t\t\t\tshow_top_bot_msg, msgbuf,\n\t\t\t\t(count != 1 || has_offset\n#ifdef FEAT_FOLDING\n\t\t\t\t || (!(fdo_flags & FDO_SEARCH)\n\t\t\t\t     && hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t   NULL, NULL))\n#endif\n\t\t\t\t),\n\t\t\t\tSEARCH_STAT_DEF_MAX_COUNT,\n\t\t\t\tSEARCH_STAT_DEF_TIMEOUT);\n\n\t/*\n\t * The search command can be followed by a ';' to do another search.\n\t * For example: \"/pat/;/foo/+3;?bar\"\n\t * This is like doing another search command, except:\n\t * - The remembered direction '/' or '?' is from the first search.\n\t * - When an error happens the cursor isn't moved at all.\n\t * Don't do this when called by get_address() (it handles ';' itself).\n\t */\n\tif (!(options & SEARCH_OPT) || pat == NULL || *pat != ';')\n\t    break;\n\n\tdirc = *++pat;\n\tsearch_delim = dirc;\n\tif (dirc != '?' && dirc != '/')\n\t{\n\t    retval = 0;\n\t    emsg(_(e_expected_question_or_slash_after_semicolon));\n\t    goto end_do_search;\n\t}\n\t++pat;\n    }\n\n    if (options & SEARCH_MARK)\n\tsetpcmark();\n    curwin->w_cursor = pos;\n    curwin->w_set_curswant = TRUE;\n\nend_do_search:\n    if ((options & SEARCH_KEEP) || (cmdmod.cmod_flags & CMOD_KEEPPATTERNS))\n\tspats[0].off = old_off;\n    vim_free(strcopy);\n    vim_free(msgbuf);\n\n    return retval;\n}\n\n/*\n * search_for_exact_line(buf, pos, dir, pat)\n *\n * Search for a line starting with the given pattern (ignoring leading\n * white-space), starting from pos and going in direction \"dir\". \"pos\" will\n * contain the position of the match found.    Blank lines match only if\n * ADDING is set.  If p_ic is set then the pattern must be in lowercase.\n * Return OK for success, or FAIL if no line found.\n */\n    int\nsearch_for_exact_line(\n    buf_T\t*buf,\n    pos_T\t*pos,\n    int\t\tdir,\n    char_u\t*pat)\n{\n    linenr_T\tstart = 0;\n    char_u\t*ptr;\n    char_u\t*p;\n\n    if (buf->b_ml.ml_line_count == 0)\n\treturn FAIL;\n    for (;;)\n    {\n\tpos->lnum += dir;\n\tif (pos->lnum < 1)\n\t{\n\t    if (p_ws)\n\t    {\n\t\tpos->lnum = buf->b_ml.ml_line_count;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(top_bot_msg), TRUE);\n\t    }\n\t    else\n\t    {\n\t\tpos->lnum = 1;\n\t\tbreak;\n\t    }\n\t}\n\telse if (pos->lnum > buf->b_ml.ml_line_count)\n\t{\n\t    if (p_ws)\n\t    {\n\t\tpos->lnum = 1;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(bot_top_msg), TRUE);\n\t    }\n\t    else\n\t    {\n\t\tpos->lnum = 1;\n\t\tbreak;\n\t    }\n\t}\n\tif (pos->lnum == start)\n\t    break;\n\tif (start == 0)\n\t    start = pos->lnum;\n\tptr = ml_get_buf(buf, pos->lnum, FALSE);\n\tp = skipwhite(ptr);\n\tpos->col = (colnr_T) (p - ptr);\n\n\t// when adding lines the matching line may be empty but it is not\n\t// ignored because we are interested in the next line -- Acevedo\n\tif (compl_status_adding() && !compl_status_sol())\n\t{\n\t    if ((p_ic ? MB_STRICMP(p, pat) : STRCMP(p, pat)) == 0)\n\t\treturn OK;\n\t}\n\telse if (*p != NUL)\t// ignore empty lines\n\t{\t// expanding lines or words\n\t    if ((p_ic ? MB_STRNICMP(p, pat, ins_compl_len())\n\t\t\t\t   : STRNCMP(p, pat, ins_compl_len())) == 0)\n\t\treturn OK;\n\t}\n    }\n    return FAIL;\n}\n\n/*\n * Character Searches\n */\n\n/*\n * Search for a character in a line.  If \"t_cmd\" is FALSE, move to the\n * position of the character, otherwise move to just before the char.\n * Do this \"cap->count1\" times.\n * Return FAIL or OK.\n */\n    int\nsearchc(cmdarg_T *cap, int t_cmd)\n{\n    int\t\t\tc = cap->nchar;\t// char to search for\n    int\t\t\tdir = cap->arg;\t// TRUE for searching forward\n    long\t\tcount = cap->count1;\t// repeat count\n    int\t\t\tcol;\n    char_u\t\t*p;\n    int\t\t\tlen;\n    int\t\t\tstop = TRUE;\n\n    if (c != NUL)\t// normal search: remember args for repeat\n    {\n\tif (!KeyStuffed)    // don't remember when redoing\n\t{\n\t    *lastc = c;\n\t    set_csearch_direction(dir);\n\t    set_csearch_until(t_cmd);\n\t    lastc_bytelen = (*mb_char2bytes)(c, lastc_bytes);\n\t    if (cap->ncharC1 != 0)\n\t    {\n\t\tlastc_bytelen += (*mb_char2bytes)(cap->ncharC1,\n\t\t\tlastc_bytes + lastc_bytelen);\n\t\tif (cap->ncharC2 != 0)\n\t\t    lastc_bytelen += (*mb_char2bytes)(cap->ncharC2,\n\t\t\t    lastc_bytes + lastc_bytelen);\n\t    }\n\t}\n    }\n    else\t\t// repeat previous search\n    {\n\tif (*lastc == NUL && lastc_bytelen == 1)\n\t    return FAIL;\n\tif (dir)\t// repeat in opposite direction\n\t    dir = -lastcdir;\n\telse\n\t    dir = lastcdir;\n\tt_cmd = last_t_cmd;\n\tc = *lastc;\n\t// For multi-byte re-use last lastc_bytes[] and lastc_bytelen.\n\n\t// Force a move of at least one char, so \";\" and \",\" will move the\n\t// cursor, even if the cursor is right in front of char we are looking\n\t// at.\n\tif (vim_strchr(p_cpo, CPO_SCOLON) == NULL && count == 1 && t_cmd)\n\t    stop = FALSE;\n    }\n\n    if (dir == BACKWARD)\n\tcap->oap->inclusive = FALSE;\n    else\n\tcap->oap->inclusive = TRUE;\n\n    p = ml_get_curline();\n    col = curwin->w_cursor.col;\n    len = (int)STRLEN(p);\n\n    while (count--)\n    {\n\tif (has_mbyte)\n\t{\n\t    for (;;)\n\t    {\n\t\tif (dir > 0)\n\t\t{\n\t\t    col += (*mb_ptr2len)(p + col);\n\t\t    if (col >= len)\n\t\t\treturn FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (col == 0)\n\t\t\treturn FAIL;\n\t\t    col -= (*mb_head_off)(p, p + col - 1) + 1;\n\t\t}\n\t\tif (lastc_bytelen == 1)\n\t\t{\n\t\t    if (p[col] == c && stop)\n\t\t\tbreak;\n\t\t}\n\t\telse if (STRNCMP(p + col, lastc_bytes, lastc_bytelen) == 0\n\t\t\t\t\t\t\t\t       && stop)\n\t\t    break;\n\t\tstop = TRUE;\n\t    }\n\t}\n\telse\n\t{\n\t    for (;;)\n\t    {\n\t\tif ((col += dir) < 0 || col >= len)\n\t\t    return FAIL;\n\t\tif (p[col] == c && stop)\n\t\t    break;\n\t\tstop = TRUE;\n\t    }\n\t}\n    }\n\n    if (t_cmd)\n    {\n\t// backup to before the character (possibly double-byte)\n\tcol -= dir;\n\tif (has_mbyte)\n\t{\n\t    if (dir < 0)\n\t\t// Landed on the search char which is lastc_bytelen long\n\t\tcol += lastc_bytelen - 1;\n\t    else\n\t\t// To previous char, which may be multi-byte.\n\t\tcol -= (*mb_head_off)(p, p + col);\n\t}\n    }\n    curwin->w_cursor.col = col;\n\n    return OK;\n}\n\n/*\n * \"Other\" Searches\n */\n\n/*\n * findmatch - find the matching paren or brace\n *\n * Improvement over vi: Braces inside quotes are ignored.\n */\n    pos_T *\nfindmatch(oparg_T *oap, int initc)\n{\n    return findmatchlimit(oap, initc, 0, 0);\n}\n\n/*\n * Return TRUE if the character before \"linep[col]\" equals \"ch\".\n * Return FALSE if \"col\" is zero.\n * Update \"*prevcol\" to the column of the previous character, unless \"prevcol\"\n * is NULL.\n * Handles multibyte string correctly.\n */\n    static int\ncheck_prevcol(\n    char_u\t*linep,\n    int\t\tcol,\n    int\t\tch,\n    int\t\t*prevcol)\n{\n    --col;\n    if (col > 0 && has_mbyte)\n\tcol -= (*mb_head_off)(linep, linep + col);\n    if (prevcol)\n\t*prevcol = col;\n    return (col >= 0 && linep[col] == ch) ? TRUE : FALSE;\n}\n\n/*\n * Raw string start is found at linep[startpos.col - 1].\n * Return TRUE if the matching end can be found between startpos and endpos.\n */\n    static int\nfind_rawstring_end(char_u *linep, pos_T *startpos, pos_T *endpos)\n{\n    char_u\t*p;\n    char_u\t*delim_copy;\n    size_t\tdelim_len;\n    linenr_T\tlnum;\n    int\t\tfound = FALSE;\n\n    for (p = linep + startpos->col + 1; *p && *p != '('; ++p)\n\t;\n    delim_len = (p - linep) - startpos->col - 1;\n    delim_copy = vim_strnsave(linep + startpos->col + 1, delim_len);\n    if (delim_copy == NULL)\n\treturn FALSE;\n    for (lnum = startpos->lnum; lnum <= endpos->lnum; ++lnum)\n    {\n\tchar_u *line = ml_get(lnum);\n\n\tfor (p = line + (lnum == startpos->lnum\n\t\t\t\t\t    ? startpos->col + 1 : 0); *p; ++p)\n\t{\n\t    if (lnum == endpos->lnum && (colnr_T)(p - line) >= endpos->col)\n\t\tbreak;\n\t    if (*p == ')' && STRNCMP(delim_copy, p + 1, delim_len) == 0\n\t\t\t  && p[delim_len + 1] == '\"')\n\t    {\n\t\tfound = TRUE;\n\t\tbreak;\n\t    }\n\t}\n\tif (found)\n\t    break;\n    }\n    vim_free(delim_copy);\n    return found;\n}\n\n/*\n * Check matchpairs option for \"*initc\".\n * If there is a match set \"*initc\" to the matching character and \"*findc\" to\n * the opposite character.  Set \"*backwards\" to the direction.\n * When \"switchit\" is TRUE swap the direction.\n */\n    static void\nfind_mps_values(\n    int\t    *initc,\n    int\t    *findc,\n    int\t    *backwards,\n    int\t    switchit)\n{\n    char_u\t*ptr;\n\n    ptr = curbuf->b_p_mps;\n    while (*ptr != NUL)\n    {\n\tif (has_mbyte)\n\t{\n\t    char_u *prev;\n\n\t    if (mb_ptr2char(ptr) == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *findc = *initc;\n\t\t    *initc = mb_ptr2char(ptr + mb_ptr2len(ptr) + 1);\n\t\t    *backwards = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    *findc = mb_ptr2char(ptr + mb_ptr2len(ptr) + 1);\n\t\t    *backwards = FALSE;\n\t\t}\n\t\treturn;\n\t    }\n\t    prev = ptr;\n\t    ptr += mb_ptr2len(ptr) + 1;\n\t    if (mb_ptr2char(ptr) == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *findc = *initc;\n\t\t    *initc = mb_ptr2char(prev);\n\t\t    *backwards = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    *findc = mb_ptr2char(prev);\n\t\t    *backwards = TRUE;\n\t\t}\n\t\treturn;\n\t    }\n\t    ptr += mb_ptr2len(ptr);\n\t}\n\telse\n\t{\n\t    if (*ptr == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *backwards = TRUE;\n\t\t    *findc = *initc;\n\t\t    *initc = ptr[2];\n\t\t}\n\t\telse\n\t\t{\n\t\t    *backwards = FALSE;\n\t\t    *findc = ptr[2];\n\t\t}\n\t\treturn;\n\t    }\n\t    ptr += 2;\n\t    if (*ptr == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *backwards = FALSE;\n\t\t    *findc = *initc;\n\t\t    *initc = ptr[-2];\n\t\t}\n\t\telse\n\t\t{\n\t\t    *backwards = TRUE;\n\t\t    *findc =  ptr[-2];\n\t\t}\n\t\treturn;\n\t    }\n\t    ++ptr;\n\t}\n\tif (*ptr == ',')\n\t    ++ptr;\n    }\n}\n\n/*\n * findmatchlimit -- find the matching paren or brace, if it exists within\n * maxtravel lines of the cursor.  A maxtravel of 0 means search until falling\n * off the edge of the file.\n *\n * \"initc\" is the character to find a match for.  NUL means to find the\n * character at or after the cursor. Special values:\n * '*'  look for C-style comment / *\n * '/'  look for C-style comment / *, ignoring comment-end\n * '#'  look for preprocessor directives\n * 'R'  look for raw string start: R\"delim(text)delim\" (only backwards)\n *\n * flags: FM_BACKWARD\tsearch backwards (when initc is '/', '*' or '#')\n *\t  FM_FORWARD\tsearch forwards (when initc is '/', '*' or '#')\n *\t  FM_BLOCKSTOP\tstop at start/end of block ({ or } in column 0)\n *\t  FM_SKIPCOMM\tskip comments (not implemented yet!)\n *\n * \"oap\" is only used to set oap->motion_type for a linewise motion, it can be\n * NULL\n */\n\n    pos_T *\nfindmatchlimit(\n    oparg_T\t*oap,\n    int\t\tinitc,\n    int\t\tflags,\n    int\t\tmaxtravel)\n{\n    static pos_T pos;\t\t\t// current search position\n    int\t\tfindc = 0;\t\t// matching brace\n    int\t\tc;\n    int\t\tcount = 0;\t\t// cumulative number of braces\n    int\t\tbackwards = FALSE;\t// init for gcc\n    int\t\traw_string = FALSE;\t// search for raw string\n    int\t\tinquote = FALSE;\t// TRUE when inside quotes\n    char_u\t*linep;\t\t\t// pointer to current line\n    char_u\t*ptr;\n    int\t\tdo_quotes;\t\t// check for quotes in current line\n    int\t\tat_start;\t\t// do_quotes value at start position\n    int\t\thash_dir = 0;\t\t// Direction searched for # things\n    int\t\tcomment_dir = 0;\t// Direction searched for comments\n    pos_T\tmatch_pos;\t\t// Where last slash-star was found\n    int\t\tstart_in_quotes;\t// start position is in quotes\n    int\t\ttraveled = 0;\t\t// how far we've searched so far\n    int\t\tignore_cend = FALSE;    // ignore comment end\n    int\t\tcpo_match;\t\t// vi compatible matching\n    int\t\tcpo_bsl;\t\t// don't recognize backslashes\n    int\t\tmatch_escaped = 0;\t// search for escaped match\n    int\t\tdir;\t\t\t// Direction to search\n    int\t\tcomment_col = MAXCOL;   // start of / / comment\n    int\t\tlispcomm = FALSE;\t// inside of Lisp-style comment\n    int\t\tlisp = curbuf->b_p_lisp; // engage Lisp-specific hacks ;)\n\n    pos = curwin->w_cursor;\n    pos.coladd = 0;\n    linep = ml_get(pos.lnum);\n\n    cpo_match = (vim_strchr(p_cpo, CPO_MATCH) != NULL);\n    cpo_bsl = (vim_strchr(p_cpo, CPO_MATCHBSL) != NULL);\n\n    // Direction to search when initc is '/', '*' or '#'\n    if (flags & FM_BACKWARD)\n\tdir = BACKWARD;\n    else if (flags & FM_FORWARD)\n\tdir = FORWARD;\n    else\n\tdir = 0;\n\n    /*\n     * if initc given, look in the table for the matching character\n     * '/' and '*' are special cases: look for start or end of comment.\n     * When '/' is used, we ignore running backwards into an star-slash, for\n     * \"[*\" command, we just want to find any comment.\n     */\n    if (initc == '/' || initc == '*' || initc == 'R')\n    {\n\tcomment_dir = dir;\n\tif (initc == '/')\n\t    ignore_cend = TRUE;\n\tbackwards = (dir == FORWARD) ? FALSE : TRUE;\n\traw_string = (initc == 'R');\n\tinitc = NUL;\n    }\n    else if (initc != '#' && initc != NUL)\n    {\n\tfind_mps_values(&initc, &findc, &backwards, TRUE);\n\tif (dir)\n\t    backwards = (dir == FORWARD) ? FALSE : TRUE;\n\tif (findc == NUL)\n\t    return NULL;\n    }\n    else\n    {\n\t/*\n\t * Either initc is '#', or no initc was given and we need to look\n\t * under the cursor.\n\t */\n\tif (initc == '#')\n\t{\n\t    hash_dir = dir;\n\t}\n\telse\n\t{\n\t    /*\n\t     * initc was not given, must look for something to match under\n\t     * or near the cursor.\n\t     * Only check for special things when 'cpo' doesn't have '%'.\n\t     */\n\t    if (!cpo_match)\n\t    {\n\t\t// Are we before or at #if, #else etc.?\n\t\tptr = skipwhite(linep);\n\t\tif (*ptr == '#' && pos.col <= (colnr_T)(ptr - linep))\n\t\t{\n\t\t    ptr = skipwhite(ptr + 1);\n\t\t    if (   STRNCMP(ptr, \"if\", 2) == 0\n\t\t\t|| STRNCMP(ptr, \"endif\", 5) == 0\n\t\t\t|| STRNCMP(ptr, \"el\", 2) == 0)\n\t\t\thash_dir = 1;\n\t\t}\n\n\t\t// Are we on a comment?\n\t\telse if (linep[pos.col] == '/')\n\t\t{\n\t\t    if (linep[pos.col + 1] == '*')\n\t\t    {\n\t\t\tcomment_dir = FORWARD;\n\t\t\tbackwards = FALSE;\n\t\t\tpos.col++;\n\t\t    }\n\t\t    else if (pos.col > 0 && linep[pos.col - 1] == '*')\n\t\t    {\n\t\t\tcomment_dir = BACKWARD;\n\t\t\tbackwards = TRUE;\n\t\t\tpos.col--;\n\t\t    }\n\t\t}\n\t\telse if (linep[pos.col] == '*')\n\t\t{\n\t\t    if (linep[pos.col + 1] == '/')\n\t\t    {\n\t\t\tcomment_dir = BACKWARD;\n\t\t\tbackwards = TRUE;\n\t\t    }\n\t\t    else if (pos.col > 0 && linep[pos.col - 1] == '/')\n\t\t    {\n\t\t\tcomment_dir = FORWARD;\n\t\t\tbackwards = FALSE;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * If we are not on a comment or the # at the start of a line, then\n\t     * look for brace anywhere on this line after the cursor.\n\t     */\n\t    if (!hash_dir && !comment_dir)\n\t    {\n\t\t/*\n\t\t * Find the brace under or after the cursor.\n\t\t * If beyond the end of the line, use the last character in\n\t\t * the line.\n\t\t */\n\t\tif (linep[pos.col] == NUL && pos.col)\n\t\t    --pos.col;\n\t\tfor (;;)\n\t\t{\n\t\t    initc = PTR2CHAR(linep + pos.col);\n\t\t    if (initc == NUL)\n\t\t\tbreak;\n\n\t\t    find_mps_values(&initc, &findc, &backwards, FALSE);\n\t\t    if (findc)\n\t\t\tbreak;\n\t\t    pos.col += mb_ptr2len(linep + pos.col);\n\t\t}\n\t\tif (!findc)\n\t\t{\n\t\t    // no brace in the line, maybe use \"  #if\" then\n\t\t    if (!cpo_match && *skipwhite(linep) == '#')\n\t\t\thash_dir = 1;\n\t\t    else\n\t\t\treturn NULL;\n\t\t}\n\t\telse if (!cpo_bsl)\n\t\t{\n\t\t    int col, bslcnt = 0;\n\n\t\t    // Set \"match_escaped\" if there are an odd number of\n\t\t    // backslashes.\n\t\t    for (col = pos.col; check_prevcol(linep, col, '\\\\', &col);)\n\t\t\tbslcnt++;\n\t\t    match_escaped = (bslcnt & 1);\n\t\t}\n\t    }\n\t}\n\tif (hash_dir)\n\t{\n\t    /*\n\t     * Look for matching #if, #else, #elif, or #endif\n\t     */\n\t    if (oap != NULL)\n\t\toap->motion_type = MLINE;   // Linewise for this case only\n\t    if (initc != '#')\n\t    {\n\t\tptr = skipwhite(skipwhite(linep) + 1);\n\t\tif (STRNCMP(ptr, \"if\", 2) == 0 || STRNCMP(ptr, \"el\", 2) == 0)\n\t\t    hash_dir = 1;\n\t\telse if (STRNCMP(ptr, \"endif\", 5) == 0)\n\t\t    hash_dir = -1;\n\t\telse\n\t\t    return NULL;\n\t    }\n\t    pos.col = 0;\n\t    while (!got_int)\n\t    {\n\t\tif (hash_dir > 0)\n\t\t{\n\t\t    if (pos.lnum == curbuf->b_ml.ml_line_count)\n\t\t\tbreak;\n\t\t}\n\t\telse if (pos.lnum == 1)\n\t\t    break;\n\t\tpos.lnum += hash_dir;\n\t\tlinep = ml_get(pos.lnum);\n\t\tline_breakcheck();\t// check for CTRL-C typed\n\t\tptr = skipwhite(linep);\n\t\tif (*ptr != '#')\n\t\t    continue;\n\t\tpos.col = (colnr_T) (ptr - linep);\n\t\tptr = skipwhite(ptr + 1);\n\t\tif (hash_dir > 0)\n\t\t{\n\t\t    if (STRNCMP(ptr, \"if\", 2) == 0)\n\t\t\tcount++;\n\t\t    else if (STRNCMP(ptr, \"el\", 2) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t    }\n\t\t    else if (STRNCMP(ptr, \"endif\", 5) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t\tcount--;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (STRNCMP(ptr, \"if\", 2) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t\tcount--;\n\t\t    }\n\t\t    else if (initc == '#' && STRNCMP(ptr, \"el\", 2) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t    }\n\t\t    else if (STRNCMP(ptr, \"endif\", 5) == 0)\n\t\t\tcount++;\n\t\t}\n\t    }\n\t    return NULL;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    // This is just guessing: when 'rightleft' is set, search for a matching\n    // paren/brace in the other direction.\n    if (curwin->w_p_rl && vim_strchr((char_u *)\"()[]{}<>\", initc) != NULL)\n\tbackwards = !backwards;\n#endif\n\n    do_quotes = -1;\n    start_in_quotes = MAYBE;\n    CLEAR_POS(&match_pos);\n\n    // backward search: Check if this line contains a single-line comment\n    if ((backwards && comment_dir) || lisp)\n\tcomment_col = check_linecomment(linep);\n    if (lisp && comment_col != MAXCOL && pos.col > (colnr_T)comment_col)\n\tlispcomm = TRUE;    // find match inside this comment\n\n    while (!got_int)\n    {\n\t/*\n\t * Go to the next position, forward or backward. We could use\n\t * inc() and dec() here, but that is much slower\n\t */\n\tif (backwards)\n\t{\n\t    // char to match is inside of comment, don't search outside\n\t    if (lispcomm && pos.col < (colnr_T)comment_col)\n\t\tbreak;\n\t    if (pos.col == 0)\t\t// at start of line, go to prev. one\n\t    {\n\t\tif (pos.lnum == 1)\t// start of file\n\t\t    break;\n\t\t--pos.lnum;\n\n\t\tif (maxtravel > 0 && ++traveled > maxtravel)\n\t\t    break;\n\n\t\tlinep = ml_get(pos.lnum);\n\t\tpos.col = (colnr_T)STRLEN(linep); // pos.col on trailing NUL\n\t\tdo_quotes = -1;\n\t\tline_breakcheck();\n\n\t\t// Check if this line contains a single-line comment\n\t\tif (comment_dir || lisp)\n\t\t    comment_col = check_linecomment(linep);\n\t\t// skip comment\n\t\tif (lisp && comment_col != MAXCOL)\n\t\t    pos.col = comment_col;\n\t    }\n\t    else\n\t    {\n\t\t--pos.col;\n\t\tif (has_mbyte)\n\t\t    pos.col -= (*mb_head_off)(linep, linep + pos.col);\n\t    }\n\t}\n\telse\t\t\t\t// forward search\n\t{\n\t    if (linep[pos.col] == NUL\n\t\t    // at end of line, go to next one\n\t\t    // For lisp don't search for match in comment\n\t\t    || (lisp && comment_col != MAXCOL\n\t\t\t\t\t   && pos.col == (colnr_T)comment_col))\n\t    {\n\t\tif (pos.lnum == curbuf->b_ml.ml_line_count  // end of file\n\t\t\t// line is exhausted and comment with it,\n\t\t\t// don't search for match in code\n\t\t\t || lispcomm)\n\t\t    break;\n\t\t++pos.lnum;\n\n\t\tif (maxtravel && traveled++ > maxtravel)\n\t\t    break;\n\n\t\tlinep = ml_get(pos.lnum);\n\t\tpos.col = 0;\n\t\tdo_quotes = -1;\n\t\tline_breakcheck();\n\t\tif (lisp)   // find comment pos in new line\n\t\t    comment_col = check_linecomment(linep);\n\t    }\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t    pos.col += (*mb_ptr2len)(linep + pos.col);\n\t\telse\n\t\t    ++pos.col;\n\t    }\n\t}\n\n\t/*\n\t * If FM_BLOCKSTOP given, stop at a '{' or '}' in column 0.\n\t */\n\tif (pos.col == 0 && (flags & FM_BLOCKSTOP)\n\t\t\t\t       && (linep[0] == '{' || linep[0] == '}'))\n\t{\n\t    if (linep[0] == findc && count == 0)\t// match!\n\t\treturn &pos;\n\t    break;\t\t\t\t\t// out of scope\n\t}\n\n\tif (comment_dir)\n\t{\n\t    // Note: comments do not nest, and we ignore quotes in them\n\t    // TODO: ignore comment brackets inside strings\n\t    if (comment_dir == FORWARD)\n\t    {\n\t\tif (linep[pos.col] == '*' && linep[pos.col + 1] == '/')\n\t\t{\n\t\t    pos.col++;\n\t\t    return &pos;\n\t\t}\n\t    }\n\t    else    // Searching backwards\n\t    {\n\t\t/*\n\t\t * A comment may contain / * or / /, it may also start or end\n\t\t * with / * /.\tIgnore a / * after / / and after *.\n\t\t */\n\t\tif (pos.col == 0)\n\t\t    continue;\n\t\telse if (raw_string)\n\t\t{\n\t\t    if (linep[pos.col - 1] == 'R'\n\t\t\t&& linep[pos.col] == '\"'\n\t\t\t&& vim_strchr(linep + pos.col + 1, '(') != NULL)\n\t\t    {\n\t\t\t// Possible start of raw string. Now that we have the\n\t\t\t// delimiter we can check if it ends before where we\n\t\t\t// started searching, or before the previously found\n\t\t\t// raw string start.\n\t\t\tif (!find_rawstring_end(linep, &pos,\n\t\t\t\t  count > 0 ? &match_pos : &curwin->w_cursor))\n\t\t\t{\n\t\t\t    count++;\n\t\t\t    match_pos = pos;\n\t\t\t    match_pos.col--;\n\t\t\t}\n\t\t\tlinep = ml_get(pos.lnum); // may have been released\n\t\t    }\n\t\t}\n\t\telse if (  linep[pos.col - 1] == '/'\n\t\t\t&& linep[pos.col] == '*'\n\t\t\t&& (pos.col == 1 || linep[pos.col - 2] != '*')\n\t\t\t&& (int)pos.col < comment_col)\n\t\t{\n\t\t    count++;\n\t\t    match_pos = pos;\n\t\t    match_pos.col--;\n\t\t}\n\t\telse if (linep[pos.col - 1] == '*' && linep[pos.col] == '/')\n\t\t{\n\t\t    if (count > 0)\n\t\t\tpos = match_pos;\n\t\t    else if (pos.col > 1 && linep[pos.col - 2] == '/'\n\t\t\t\t\t       && (int)pos.col <= comment_col)\n\t\t\tpos.col -= 2;\n\t\t    else if (ignore_cend)\n\t\t\tcontinue;\n\t\t    else\n\t\t\treturn NULL;\n\t\t    return &pos;\n\t\t}\n\t    }\n\t    continue;\n\t}\n\n\t/*\n\t * If smart matching ('cpoptions' does not contain '%'), braces inside\n\t * of quotes are ignored, but only if there is an even number of\n\t * quotes in the line.\n\t */\n\tif (cpo_match)\n\t    do_quotes = 0;\n\telse if (do_quotes == -1)\n\t{\n\t    /*\n\t     * Count the number of quotes in the line, skipping \\\" and '\"'.\n\t     * Watch out for \"\\\\\".\n\t     */\n\t    at_start = do_quotes;\n\t    for (ptr = linep; *ptr; ++ptr)\n\t    {\n\t\tif (ptr == linep + pos.col + backwards)\n\t\t    at_start = (do_quotes & 1);\n\t\tif (*ptr == '\"'\n\t\t\t&& (ptr == linep || ptr[-1] != '\\'' || ptr[1] != '\\''))\n\t\t    ++do_quotes;\n\t\tif (*ptr == '\\\\' && ptr[1] != NUL)\n\t\t    ++ptr;\n\t    }\n\t    do_quotes &= 1;\t    // result is 1 with even number of quotes\n\n\t    /*\n\t     * If we find an uneven count, check current line and previous\n\t     * one for a '\\' at the end.\n\t     */\n\t    if (!do_quotes)\n\t    {\n\t\tinquote = FALSE;\n\t\tif (ptr[-1] == '\\\\')\n\t\t{\n\t\t    do_quotes = 1;\n\t\t    if (start_in_quotes == MAYBE)\n\t\t    {\n\t\t\t// Do we need to use at_start here?\n\t\t\tinquote = TRUE;\n\t\t\tstart_in_quotes = TRUE;\n\t\t    }\n\t\t    else if (backwards)\n\t\t\tinquote = TRUE;\n\t\t}\n\t\tif (pos.lnum > 1)\n\t\t{\n\t\t    ptr = ml_get(pos.lnum - 1);\n\t\t    if (*ptr && *(ptr + STRLEN(ptr) - 1) == '\\\\')\n\t\t    {\n\t\t\tdo_quotes = 1;\n\t\t\tif (start_in_quotes == MAYBE)\n\t\t\t{\n\t\t\t    inquote = at_start;\n\t\t\t    if (inquote)\n\t\t\t\tstart_in_quotes = TRUE;\n\t\t\t}\n\t\t\telse if (!backwards)\n\t\t\t    inquote = TRUE;\n\t\t    }\n\n\t\t    // ml_get() only keeps one line, need to get linep again\n\t\t    linep = ml_get(pos.lnum);\n\t\t}\n\t    }\n\t}\n\tif (start_in_quotes == MAYBE)\n\t    start_in_quotes = FALSE;\n\n\t/*\n\t * If 'smartmatch' is set:\n\t *   Things inside quotes are ignored by setting 'inquote'.  If we\n\t *   find a quote without a preceding '\\' invert 'inquote'.  At the\n\t *   end of a line not ending in '\\' we reset 'inquote'.\n\t *\n\t *   In lines with an uneven number of quotes (without preceding '\\')\n\t *   we do not know which part to ignore. Therefore we only set\n\t *   inquote if the number of quotes in a line is even, unless this\n\t *   line or the previous one ends in a '\\'.  Complicated, isn't it?\n\t */\n\tc = PTR2CHAR(linep + pos.col);\n\tswitch (c)\n\t{\n\tcase NUL:\n\t    // at end of line without trailing backslash, reset inquote\n\t    if (pos.col == 0 || linep[pos.col - 1] != '\\\\')\n\t    {\n\t\tinquote = FALSE;\n\t\tstart_in_quotes = FALSE;\n\t    }\n\t    break;\n\n\tcase '\"':\n\t    // a quote that is preceded with an odd number of backslashes is\n\t    // ignored\n\t    if (do_quotes)\n\t    {\n\t\tint col;\n\n\t\tfor (col = pos.col - 1; col >= 0; --col)\n\t\t    if (linep[col] != '\\\\')\n\t\t\tbreak;\n\t\tif ((((int)pos.col - 1 - col) & 1) == 0)\n\t\t{\n\t\t    inquote = !inquote;\n\t\t    start_in_quotes = FALSE;\n\t\t}\n\t    }\n\t    break;\n\n\t/*\n\t * If smart matching ('cpoptions' does not contain '%'):\n\t *   Skip things in single quotes: 'x' or '\\x'.  Be careful for single\n\t *   single quotes, eg jon's.  Things like '\\233' or '\\x3f' are not\n\t *   skipped, there is never a brace in them.\n\t *   Ignore this when finding matches for `'.\n\t */\n\tcase '\\'':\n\t    if (!cpo_match && initc != '\\'' && findc != '\\'')\n\t    {\n\t\tif (backwards)\n\t\t{\n\t\t    if (pos.col > 1)\n\t\t    {\n\t\t\tif (linep[pos.col - 2] == '\\'')\n\t\t\t{\n\t\t\t    pos.col -= 2;\n\t\t\t    break;\n\t\t\t}\n\t\t\telse if (linep[pos.col - 2] == '\\\\'\n\t\t\t\t  && pos.col > 2 && linep[pos.col - 3] == '\\'')\n\t\t\t{\n\t\t\t    pos.col -= 3;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (linep[pos.col + 1])\t// forward search\n\t\t{\n\t\t    if (linep[pos.col + 1] == '\\\\'\n\t\t\t   && linep[pos.col + 2] && linep[pos.col + 3] == '\\'')\n\t\t    {\n\t\t\tpos.col += 3;\n\t\t\tbreak;\n\t\t    }\n\t\t    else if (linep[pos.col + 2] == '\\'')\n\t\t    {\n\t\t\tpos.col += 2;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    // FALLTHROUGH\n\n\tdefault:\n\t    /*\n\t     * For Lisp skip over backslashed (), {} and [].\n\t     * (actually, we skip #\\( et al)\n\t     */\n\t    if (curbuf->b_p_lisp\n\t\t    && vim_strchr((char_u *)\"(){}[]\", c) != NULL\n\t\t    && pos.col > 1\n\t\t    && check_prevcol(linep, pos.col, '\\\\', NULL)\n\t\t    && check_prevcol(linep, pos.col - 1, '#', NULL))\n\t\tbreak;\n\n\t    // Check for match outside of quotes, and inside of\n\t    // quotes when the start is also inside of quotes.\n\t    if ((!inquote || start_in_quotes == TRUE)\n\t\t    && (c == initc || c == findc))\n\t    {\n\t\tint\tcol, bslcnt = 0;\n\n\t\tif (!cpo_bsl)\n\t\t{\n\t\t    for (col = pos.col; check_prevcol(linep, col, '\\\\', &col);)\n\t\t\tbslcnt++;\n\t\t}\n\t\t// Only accept a match when 'M' is in 'cpo' or when escaping\n\t\t// is what we expect.\n\t\tif (cpo_bsl || (bslcnt & 1) == match_escaped)\n\t\t{\n\t\t    if (c == initc)\n\t\t\tcount++;\n\t\t    else\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t\tcount--;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    if (comment_dir == BACKWARD && count > 0)\n    {\n\tpos = match_pos;\n\treturn &pos;\n    }\n    return (pos_T *)NULL;\t// never found it\n}\n\n/*\n * Check if line[] contains a / / comment.\n * Return MAXCOL if not, otherwise return the column.\n */\n    int\ncheck_linecomment(char_u *line)\n{\n    char_u  *p;\n\n    p = line;\n    // skip Lispish one-line comments\n    if (curbuf->b_p_lisp)\n    {\n\tif (vim_strchr(p, ';') != NULL) // there may be comments\n\t{\n\t    int in_str = FALSE;\t// inside of string\n\n\t    p = line;\t\t// scan from start\n\t    while ((p = vim_strpbrk(p, (char_u *)\"\\\";\")) != NULL)\n\t    {\n\t\tif (*p == '\"')\n\t\t{\n\t\t    if (in_str)\n\t\t    {\n\t\t\tif (*(p - 1) != '\\\\') // skip escaped quote\n\t\t\t    in_str = FALSE;\n\t\t    }\n\t\t    else if (p == line || ((p - line) >= 2\n\t\t\t\t      // skip #\\\" form\n\t\t\t\t      && *(p - 1) != '\\\\' && *(p - 2) != '#'))\n\t\t\tin_str = TRUE;\n\t\t}\n\t\telse if (!in_str && ((p - line) < 2\n\t\t\t\t    || (*(p - 1) != '\\\\' && *(p - 2) != '#'))\n\t\t\t       && !is_pos_in_string(line, (colnr_T)(p - line)))\n\t\t    break;\t// found!\n\t\t++p;\n\t    }\n\t}\n\telse\n\t    p = NULL;\n    }\n    else\n\twhile ((p = vim_strchr(p, '/')) != NULL)\n\t{\n\t    // Accept a double /, unless it's preceded with * and followed by\n\t    // *, because * / / * is an end and start of a C comment.  Only\n\t    // accept the position if it is not inside a string.\n\t    if (p[1] == '/' && (p == line || p[-1] != '*' || p[2] != '*')\n\t\t\t       && !is_pos_in_string(line, (colnr_T)(p - line)))\n\t\tbreak;\n\t    ++p;\n\t}\n\n    if (p == NULL)\n\treturn MAXCOL;\n    return (int)(p - line);\n}\n\n/*\n * Move cursor briefly to character matching the one under the cursor.\n * Used for Insert mode and \"r\" command.\n * Show the match only if it is visible on the screen.\n * If there isn't a match, then beep.\n */\n    void\nshowmatch(\n    int\t\tc)\t    // char to show match for\n{\n    pos_T\t*lpos, save_cursor;\n    pos_T\tmpos;\n    colnr_T\tvcol;\n    long\tsave_so;\n    long\tsave_siso;\n#ifdef CURSOR_SHAPE\n    int\t\tsave_state;\n#endif\n    colnr_T\tsave_dollar_vcol;\n    char_u\t*p;\n    long\t*so = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    long\t*siso = curwin->w_p_siso >= 0 ? &curwin->w_p_siso : &p_siso;\n\n    /*\n     * Only show match for chars in the 'matchpairs' option.\n     */\n    // 'matchpairs' is \"x:y,x:y\"\n    for (p = curbuf->b_p_mps; *p != NUL; ++p)\n    {\n#ifdef FEAT_RIGHTLEFT\n\tif (PTR2CHAR(p) == c && (curwin->w_p_rl ^ p_ri))\n\t    break;\n#endif\n\tp += mb_ptr2len(p) + 1;\n\tif (PTR2CHAR(p) == c\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !(curwin->w_p_rl ^ p_ri)\n#endif\n\t   )\n\t    break;\n\tp += mb_ptr2len(p);\n\tif (*p == NUL)\n\t    return;\n    }\n    if (*p == NUL)\n\treturn;\n\n    if ((lpos = findmatch(NULL, NUL)) == NULL)\t    // no match, so beep\n\tvim_beep(BO_MATCH);\n    else if (lpos->lnum >= curwin->w_topline && lpos->lnum < curwin->w_botline)\n    {\n\tif (!curwin->w_p_wrap)\n\t    getvcol(curwin, lpos, NULL, &vcol, NULL);\n\tif (curwin->w_p_wrap || (vcol >= curwin->w_leftcol\n\t\t\t       && vcol < curwin->w_leftcol + curwin->w_width))\n\t{\n\t    mpos = *lpos;    // save the pos, update_screen() may change it\n\t    save_cursor = curwin->w_cursor;\n\t    save_so = *so;\n\t    save_siso = *siso;\n\t    // Handle \"$\" in 'cpo': If the ')' is typed on top of the \"$\",\n\t    // stop displaying the \"$\".\n\t    if (dollar_vcol >= 0 && dollar_vcol == curwin->w_virtcol)\n\t\tdollar_vcol = -1;\n\t    ++curwin->w_virtcol;\t// do display ')' just before \"$\"\n\t    update_screen(VALID);\t// show the new char first\n\n\t    save_dollar_vcol = dollar_vcol;\n#ifdef CURSOR_SHAPE\n\t    save_state = State;\n\t    State = MODE_SHOWMATCH;\n\t    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\t    curwin->w_cursor = mpos;\t// move to matching char\n\t    *so = 0;\t\t\t// don't use 'scrolloff' here\n\t    *siso = 0;\t\t\t// don't use 'sidescrolloff' here\n\t    showruler(FALSE);\n\t    setcursor();\n\t    cursor_on();\t\t// make sure that the cursor is shown\n\t    out_flush_cursor(TRUE, FALSE);\n\n\t    // Restore dollar_vcol(), because setcursor() may call curs_rows()\n\t    // which resets it if the matching position is in a previous line\n\t    // and has a higher column number.\n\t    dollar_vcol = save_dollar_vcol;\n\n\t    /*\n\t     * brief pause, unless 'm' is present in 'cpo' and a character is\n\t     * available.\n\t     */\n\t    if (vim_strchr(p_cpo, CPO_SHOWMATCH) != NULL)\n\t\tui_delay(p_mat * 100L + 8, TRUE);\n\t    else if (!char_avail())\n\t\tui_delay(p_mat * 100L + 9, FALSE);\n\t    curwin->w_cursor = save_cursor;\t// restore cursor position\n\t    *so = save_so;\n\t    *siso = save_siso;\n#ifdef CURSOR_SHAPE\n\t    State = save_state;\n\t    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\t}\n    }\n}\n\n/*\n * Check if the pattern is zero-width.\n * If move is TRUE, check from the beginning of the buffer, else from position\n * \"cur\".\n * \"direction\" is FORWARD or BACKWARD.\n * Returns TRUE, FALSE or -1 for failure.\n */\n    static int\nis_zero_width(char_u *pattern, int move, pos_T *cur, int direction)\n{\n    regmmatch_T\tregmatch;\n    int\t\tnmatched = 0;\n    int\t\tresult = -1;\n    pos_T\tpos;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflag = 0;\n\n    if (pattern == NULL)\n\tpattern = spats[last_idx].pat;\n\n    if (search_regcomp(pattern, RE_SEARCH, RE_SEARCH,\n\t\t\t\t\t      SEARCH_KEEP, &regmatch) == FAIL)\n\treturn -1;\n\n    // init startcol correctly\n    regmatch.startpos[0].col = -1;\n    // move to match\n    if (move)\n    {\n\tCLEAR_POS(&pos);\n    }\n    else\n    {\n\tpos = *cur;\n\t// accept a match at the cursor position\n\tflag = SEARCH_START;\n    }\n\n    if (searchit(curwin, curbuf, &pos, NULL, direction, pattern, 1,\n\t\t\t\t  SEARCH_KEEP + flag, RE_SEARCH, NULL) != FAIL)\n    {\n\t// Zero-width pattern should match somewhere, then we can check if\n\t// start and end are in the same position.\n\tdo\n\t{\n\t    regmatch.startpos[0].col++;\n\t    nmatched = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t       pos.lnum, regmatch.startpos[0].col, NULL, NULL);\n\t    if (nmatched != 0)\n\t\tbreak;\n\t} while (regmatch.regprog != NULL\n\t\t&& direction == FORWARD ? regmatch.startpos[0].col < pos.col\n\t\t\t\t      : regmatch.startpos[0].col > pos.col);\n\n\tif (called_emsg == called_emsg_before)\n\t{\n\t    result = (nmatched != 0\n\t\t&& regmatch.startpos[0].lnum == regmatch.endpos[0].lnum\n\t\t&& regmatch.startpos[0].col == regmatch.endpos[0].col);\n\t}\n    }\n\n    vim_regfree(regmatch.regprog);\n    return result;\n}\n\n\n/*\n * Find next search match under cursor, cursor at end.\n * Used while an operator is pending, and in Visual mode.\n */\n    int\ncurrent_search(\n    long\tcount,\n    int\t\tforward)\t// TRUE for forward, FALSE for backward\n{\n    pos_T\tstart_pos;\t// start position of the pattern match\n    pos_T\tend_pos;\t// end position of the pattern match\n    pos_T\torig_pos;\t// position of the cursor at beginning\n    pos_T\tpos;\t\t// position after the pattern\n    int\t\ti;\n    int\t\tdir;\n    int\t\tresult;\t\t// result of various function calls\n    char_u\told_p_ws = p_ws;\n    int\t\tflags = 0;\n    pos_T\tsave_VIsual = VIsual;\n    int\t\tzero_width;\n    int\t\tskip_first_backward;\n\n    // Correct cursor when 'selection' is exclusive\n    if (VIsual_active && *p_sel == 'e' && LT_POS(VIsual, curwin->w_cursor))\n\tdec_cursor();\n\n    // When searching forward and the cursor is at the start of the Visual\n    // area, skip the first search backward, otherwise it doesn't move.\n    skip_first_backward = forward && VIsual_active\n\t\t\t\t\t   && LT_POS(curwin->w_cursor, VIsual);\n\n    orig_pos = pos = curwin->w_cursor;\n    if (VIsual_active)\n    {\n\tif (forward)\n\t    incl(&pos);\n\telse\n\t    decl(&pos);\n    }\n\n    // Is the pattern is zero-width?, this time, don't care about the direction\n    zero_width = is_zero_width(spats[last_idx].pat, TRUE, &curwin->w_cursor,\n\t\t\t\t\t\t\t\t      FORWARD);\n    if (zero_width == -1)\n\treturn FAIL;  // pattern not found\n\n    /*\n     * The trick is to first search backwards and then search forward again,\n     * so that a match at the current cursor position will be correctly\n     * captured.  When \"forward\" is false do it the other way around.\n     */\n    for (i = 0; i < 2; i++)\n    {\n\tif (forward)\n\t{\n\t    if (i == 0 && skip_first_backward)\n\t\tcontinue;\n\t    dir = i;\n\t}\n\telse\n\t    dir = !i;\n\n\tflags = 0;\n\tif (!dir && !zero_width)\n\t    flags = SEARCH_END;\n\tend_pos = pos;\n\n\t// wrapping should not occur in the first round\n\tif (i == 0)\n\t    p_ws = FALSE;\n\n\tresult = searchit(curwin, curbuf, &pos, &end_pos,\n\t\t(dir ? FORWARD : BACKWARD),\n\t\tspats[last_idx].pat, (long) (i ? count : 1),\n\t\tSEARCH_KEEP | flags, RE_SEARCH, NULL);\n\n\tp_ws = old_p_ws;\n\n\t// First search may fail, but then start searching from the\n\t// beginning of the file (cursor might be on the search match)\n\t// except when Visual mode is active, so that extending the visual\n\t// selection works.\n\tif (i == 1 && !result) // not found, abort\n\t{\n\t    curwin->w_cursor = orig_pos;\n\t    if (VIsual_active)\n\t\tVIsual = save_VIsual;\n\t    return FAIL;\n\t}\n\telse if (i == 0 && !result)\n\t{\n\t    if (forward)\n\t    {\n\t\t// try again from start of buffer\n\t\tCLEAR_POS(&pos);\n\t    }\n\t    else\n\t    {\n\t\t// try again from end of buffer\n\t\t// searching backwards, so set pos to last line and col\n\t\tpos.lnum = curwin->w_buffer->b_ml.ml_line_count;\n\t\tpos.col  = (colnr_T)STRLEN(\n\t\t\t\tml_get(curwin->w_buffer->b_ml.ml_line_count));\n\t    }\n\t}\n    }\n\n    start_pos = pos;\n\n    if (!VIsual_active)\n\tVIsual = start_pos;\n\n    // put the cursor after the match\n    curwin->w_cursor = end_pos;\n    if (LT_POS(VIsual, end_pos) && forward)\n    {\n\tif (skip_first_backward)\n\t    // put the cursor on the start of the match\n\t    curwin->w_cursor = pos;\n\telse\n\t    // put the cursor on last character of match\n\t    dec_cursor();\n    }\n    else if (VIsual_active && LT_POS(curwin->w_cursor, VIsual) && forward)\n\tcurwin->w_cursor = pos;   // put the cursor on the start of the match\n    VIsual_active = TRUE;\n    VIsual_mode = 'v';\n\n    if (*p_sel == 'e')\n    {\n\t// Correction for exclusive selection depends on the direction.\n\tif (forward && LTOREQ_POS(VIsual, curwin->w_cursor))\n\t    inc_cursor();\n\telse if (!forward && LTOREQ_POS(curwin->w_cursor, VIsual))\n\t    inc(&VIsual);\n    }\n\n#ifdef FEAT_FOLDING\n    if (fdo_flags & FDO_SEARCH && KeyTyped)\n\tfoldOpenCursor();\n#endif\n\n    may_start_select('c');\n    setmouse();\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end are still the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n    redraw_curbuf_later(INVERTED);\n    showmode();\n\n    return OK;\n}\n\n/*\n * return TRUE if line 'lnum' is empty or has white chars only.\n */\n    int\nlinewhite(linenr_T lnum)\n{\n    char_u  *p;\n\n    p = skipwhite(ml_get(lnum));\n    return (*p == NUL);\n}\n\n/*\n * Add the search count \"[3/19]\" to \"msgbuf\".\n * See update_search_stat() for other arguments.\n */\n    static void\ncmdline_search_stat(\n    int\t\tdirc,\n    pos_T\t*pos,\n    pos_T\t*cursor_pos,\n    int\t\tshow_top_bot_msg,\n    char_u\t*msgbuf,\n    int\t\trecompute,\n    int\t\tmaxcount,\n    long\ttimeout)\n{\n    searchstat_T stat;\n\n    update_search_stat(dirc, pos, cursor_pos, &stat, recompute, maxcount,\n\t\t\t\t\t\t\t\t      timeout);\n    if (stat.cur > 0)\n    {\n\tchar\tt[SEARCH_STAT_BUF_LEN];\n\tsize_t\tlen;\n\n#ifdef FEAT_RIGHTLEFT\n\tif (curwin->w_p_rl && *curwin->w_p_rlc == 's')\n\t{\n\t    if (stat.incomplete == 1)\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[?/??]\");\n\t    else if (stat.cnt > maxcount && stat.cur > maxcount)\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[>%d/>%d]\",\n\t\t\t\t\t\t\t   maxcount, maxcount);\n\t    else if (stat.cnt > maxcount)\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[>%d/%d]\",\n\t\t\t\t\t\t\t   maxcount, stat.cur);\n\t    else\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[%d/%d]\",\n\t\t\t\t\t\t\t   stat.cnt, stat.cur);\n\t}\n\telse\n#endif\n\t{\n\t    if (stat.incomplete == 1)\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[?/??]\");\n\t    else if (stat.cnt > maxcount && stat.cur > maxcount)\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[>%d/>%d]\",\n\t\t\t\t\t\t\t   maxcount, maxcount);\n\t    else if (stat.cnt > maxcount)\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[%d/>%d]\",\n\t\t\t\t\t\t\t   stat.cur, maxcount);\n\t    else\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[%d/%d]\",\n\t\t\t\t\t\t\t   stat.cur, stat.cnt);\n\t}\n\n\tlen = STRLEN(t);\n\tif (show_top_bot_msg && len + 2 < SEARCH_STAT_BUF_LEN)\n\t{\n\t    mch_memmove(t + 2, t, len);\n\t    t[0] = 'W';\n\t    t[1] = ' ';\n\t    len += 2;\n\t}\n\n\tmch_memmove(msgbuf + STRLEN(msgbuf) - len, t, len);\n\tif (dirc == '?' && stat.cur == maxcount + 1)\n\t    stat.cur = -1;\n\n\t// keep the message even after redraw, but don't put in history\n\tmsg_hist_off = TRUE;\n\tgive_warning(msgbuf, FALSE);\n\tmsg_hist_off = FALSE;\n    }\n}\n\n/*\n * Add the search count information to \"stat\".\n * \"stat\" must not be NULL.\n * When \"recompute\" is TRUE always recompute the numbers.\n * dirc == 0: don't find the next/previous match (only set the result to \"stat\")\n * dirc == '/': find the next match\n * dirc == '?': find the previous match\n */\n    static void\nupdate_search_stat(\n    int\t\t\tdirc,\n    pos_T\t\t*pos,\n    pos_T\t\t*cursor_pos,\n    searchstat_T\t*stat,\n    int\t\t\trecompute,\n    int\t\t\tmaxcount,\n    long\t\ttimeout UNUSED)\n{\n    int\t\t    save_ws = p_ws;\n    int\t\t    wraparound = FALSE;\n    pos_T\t    p = (*pos);\n    static pos_T    lastpos = {0, 0, 0};\n    static int\t    cur = 0;\n    static int\t    cnt = 0;\n    static int\t    exact_match = FALSE;\n    static int\t    incomplete = 0;\n    static int\t    last_maxcount = SEARCH_STAT_DEF_MAX_COUNT;\n    static int\t    chgtick = 0;\n    static char_u   *lastpat = NULL;\n    static buf_T    *lbuf = NULL;\n#ifdef FEAT_RELTIME\n    proftime_T  start;\n#endif\n\n    vim_memset(stat, 0, sizeof(searchstat_T));\n\n    if (dirc == 0 && !recompute && !EMPTY_POS(lastpos))\n    {\n\tstat->cur = cur;\n\tstat->cnt = cnt;\n\tstat->exact_match = exact_match;\n\tstat->incomplete = incomplete;\n\tstat->last_maxcount = last_maxcount;\n\treturn;\n    }\n    last_maxcount = maxcount;\n\n    wraparound = ((dirc == '?' && LT_POS(lastpos, p))\n\t       || (dirc == '/' && LT_POS(p, lastpos)));\n\n    // If anything relevant changed the count has to be recomputed.\n    // MB_STRNICMP ignores case, but we should not ignore case.\n    // Unfortunately, there is no MB_STRNICMP function.\n    // XXX: above comment should be \"no MB_STRCMP function\" ?\n    if (!(chgtick == CHANGEDTICK(curbuf)\n\t&& MB_STRNICMP(lastpat, spats[last_idx].pat, STRLEN(lastpat)) == 0\n\t&& STRLEN(lastpat) == STRLEN(spats[last_idx].pat)\n\t&& EQUAL_POS(lastpos, *cursor_pos)\n\t&& lbuf == curbuf) || wraparound || cur < 0\n\t    || (maxcount > 0 && cur > maxcount) || recompute)\n    {\n\tcur = 0;\n\tcnt = 0;\n\texact_match = FALSE;\n\tincomplete = 0;\n\tCLEAR_POS(&lastpos);\n\tlbuf = curbuf;\n    }\n\n    if (EQUAL_POS(lastpos, *cursor_pos) && !wraparound\n\t\t&& (dirc == 0 || dirc == '/' ? cur < cnt : cur > 0))\n\tcur += dirc == 0 ? 0 : dirc == '/' ? 1 : -1;\n    else\n    {\n\tint\tdone_search = FALSE;\n\tpos_T\tendpos = {0, 0, 0};\n\n\tp_ws = FALSE;\n#ifdef FEAT_RELTIME\n\tif (timeout > 0)\n\t    profile_setlimit(timeout, &start);\n#endif\n\twhile (!got_int && searchit(curwin, curbuf, &lastpos, &endpos,\n\t\t\t FORWARD, NULL, 1, SEARCH_KEEP, RE_LAST, NULL) != FAIL)\n\t{\n\t    done_search = TRUE;\n#ifdef FEAT_RELTIME\n\t    // Stop after passing the time limit.\n\t    if (timeout > 0 && profile_passed_limit(&start))\n\t    {\n\t\tincomplete = 1;\n\t\tbreak;\n\t    }\n#endif\n\t    cnt++;\n\t    if (LTOREQ_POS(lastpos, p))\n\t    {\n\t\tcur = cnt;\n\t\tif (LT_POS(p, endpos))\n\t\t    exact_match = TRUE;\n\t    }\n\t    fast_breakcheck();\n\t    if (maxcount > 0 && cnt > maxcount)\n\t    {\n\t\tincomplete = 2;    // max count exceeded\n\t\tbreak;\n\t    }\n\t}\n\tif (got_int)\n\t    cur = -1; // abort\n\tif (done_search)\n\t{\n\t    vim_free(lastpat);\n\t    lastpat = vim_strsave(spats[last_idx].pat);\n\t    chgtick = CHANGEDTICK(curbuf);\n\t    lbuf = curbuf;\n\t    lastpos = p;\n\t}\n    }\n    stat->cur = cur;\n    stat->cnt = cnt;\n    stat->exact_match = exact_match;\n    stat->incomplete = incomplete;\n    stat->last_maxcount = last_maxcount;\n    p_ws = save_ws;\n}\n\n#if defined(FEAT_FIND_ID) || defined(PROTO)\n/*\n * Find identifiers or defines in included files.\n * If p_ic && compl_status_sol() then ptr must be in lowercase.\n */\n    void\nfind_pattern_in_path(\n    char_u\t*ptr,\t\t// pointer to search pattern\n    int\t\tdir UNUSED,\t// direction of expansion\n    int\t\tlen,\t\t// length of search pattern\n    int\t\twhole,\t\t// match whole words only\n    int\t\tskip_comments,\t// don't match inside comments\n    int\t\ttype,\t\t// Type of search; are we looking for a type?\n\t\t\t\t// a macro?\n    long\tcount,\n    int\t\taction,\t\t// What to do when we find it\n    linenr_T\tstart_lnum,\t// first line to start searching\n    linenr_T\tend_lnum)\t// last line for searching\n{\n    SearchedFile *files;\t\t// Stack of included files\n    SearchedFile *bigger;\t\t// When we need more space\n    int\t\tmax_path_depth = 50;\n    long\tmatch_count = 1;\n\n    char_u\t*pat;\n    char_u\t*new_fname;\n    char_u\t*curr_fname = curbuf->b_fname;\n    char_u\t*prev_fname = NULL;\n    linenr_T\tlnum;\n    int\t\tdepth;\n    int\t\tdepth_displayed;\t// For type==CHECK_PATH\n    int\t\told_files;\n    int\t\talready_searched;\n    char_u\t*file_line;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\tsave_char;\n    int\t\tdefine_matched;\n    regmatch_T\tregmatch;\n    regmatch_T\tincl_regmatch;\n    regmatch_T\tdef_regmatch;\n    int\t\tmatched = FALSE;\n    int\t\tdid_show = FALSE;\n    int\t\tfound = FALSE;\n    int\t\ti;\n    char_u\t*already = NULL;\n    char_u\t*startp = NULL;\n    char_u\t*inc_opt = NULL;\n#if defined(FEAT_QUICKFIX)\n    win_T\t*curwin_save = NULL;\n#endif\n\n    regmatch.regprog = NULL;\n    incl_regmatch.regprog = NULL;\n    def_regmatch.regprog = NULL;\n\n    file_line = alloc(LSIZE);\n    if (file_line == NULL)\n\treturn;\n\n    if (type != CHECK_PATH && type != FIND_DEFINE\n\t    // when CONT_SOL is set compare \"ptr\" with the beginning of the\n\t    // line is faster than quote_meta/regcomp/regexec \"ptr\" -- Acevedo\n\t    && !compl_status_sol())\n    {\n\tpat = alloc(len + 5);\n\tif (pat == NULL)\n\t    goto fpip_end;\n\tsprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", len, ptr);\n\t// ignore case according to p_ic, p_scs and pat\n\tregmatch.rm_ic = ignorecase(pat);\n\tregmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0);\n\tvim_free(pat);\n\tif (regmatch.regprog == NULL)\n\t    goto fpip_end;\n    }\n    inc_opt = (*curbuf->b_p_inc == NUL) ? p_inc : curbuf->b_p_inc;\n    if (*inc_opt != NUL)\n    {\n\tincl_regmatch.regprog = vim_regcomp(inc_opt,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (incl_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tincl_regmatch.rm_ic = FALSE;\t// don't ignore case in incl. pat.\n    }\n    if (type == FIND_DEFINE && (*curbuf->b_p_def != NUL || *p_def != NUL))\n    {\n\tdef_regmatch.regprog = vim_regcomp(*curbuf->b_p_def == NUL\n\t\t\t   ? p_def : curbuf->b_p_def,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (def_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tdef_regmatch.rm_ic = FALSE;\t// don't ignore case in define pat.\n    }\n    files = lalloc_clear(max_path_depth * sizeof(SearchedFile), TRUE);\n    if (files == NULL)\n\tgoto fpip_end;\n    old_files = max_path_depth;\n    depth = depth_displayed = -1;\n\n    lnum = start_lnum;\n    if (end_lnum > curbuf->b_ml.ml_line_count)\n\tend_lnum = curbuf->b_ml.ml_line_count;\n    if (lnum > end_lnum)\t\t// do at least one line\n\tlnum = end_lnum;\n    line = ml_get(lnum);\n\n    for (;;)\n    {\n\tif (incl_regmatch.regprog != NULL\n\t\t&& vim_regexec(&incl_regmatch, line, (colnr_T)0))\n\t{\n\t    char_u *p_fname = (curr_fname == curbuf->b_fname)\n\t\t\t\t\t      ? curbuf->b_ffname : curr_fname;\n\n\t    if (inc_opt != NULL && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t// Use text from '\\zs' to '\\ze' (or end) of 'include'.\n\t\tnew_fname = find_file_name_in_path(incl_regmatch.startp[0],\n\t\t       (int)(incl_regmatch.endp[0] - incl_regmatch.startp[0]),\n\t\t\t\t FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname);\n\t    else\n\t\t// Use text after match with 'include'.\n\t\tnew_fname = file_name_in_line(incl_regmatch.endp[0], 0,\n\t\t\t     FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);\n\t    already_searched = FALSE;\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Check whether we have already searched in this file\n\t\tfor (i = 0;; i++)\n\t\t{\n\t\t    if (i == depth + 1)\n\t\t\ti = old_files;\n\t\t    if (i == max_path_depth)\n\t\t\tbreak;\n\t\t    if (fullpathcmp(new_fname, files[i].name, TRUE, TRUE)\n\t\t\t\t\t\t\t\t    & FPC_SAME)\n\t\t    {\n\t\t\tif (type != CHECK_PATH\n\t\t\t\t&& action == ACTION_SHOW_ALL\n\t\t\t\t&& files[i].matched)\n\t\t\t{\n\t\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\t\t    if (!got_int)\t    // don't display if 'q'\n\t\t\t\t\t\t    // typed at \"--more--\"\n\t\t\t\t\t\t    // message\n\t\t\t    {\n\t\t\t\tmsg_home_replace_hl(new_fname);\n\t\t\t\tmsg_puts(_(\" (includes previously listed match)\"));\n\t\t\t\tprev_fname = NULL;\n\t\t\t    }\n\t\t\t}\n\t\t\tVIM_CLEAR(new_fname);\n\t\t\talready_searched = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (type == CHECK_PATH && (action == ACTION_SHOW_ALL\n\t\t\t\t || (new_fname == NULL && !already_searched)))\n\t    {\n\t\tif (did_show)\n\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\telse\n\t\t{\n\t\t    gotocmdline(TRUE);\t    // cursor at status line\n\t\t    msg_puts_title(_(\"--- Included files \"));\n\t\t    if (action != ACTION_SHOW_ALL)\n\t\t\tmsg_puts_title(_(\"not found \"));\n\t\t    msg_puts_title(_(\"in path ---\\n\"));\n\t\t}\n\t\tdid_show = TRUE;\n\t\twhile (depth_displayed < depth && !got_int)\n\t\t{\n\t\t    ++depth_displayed;\n\t\t    for (i = 0; i < depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    msg_home_replace(files[depth_displayed].name);\n\t\t    msg_puts(\" -->\\n\");\n\t\t}\n\t\tif (!got_int)\t\t    // don't display if 'q' typed\n\t\t\t\t\t    // for \"--more--\" message\n\t\t{\n\t\t    for (i = 0; i <= depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    if (new_fname != NULL)\n\t\t    {\n\t\t\t// using \"new_fname\" is more reliable, e.g., when\n\t\t\t// 'includeexpr' is set.\n\t\t\tmsg_outtrans_attr(new_fname, HL_ATTR(HLF_D));\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/*\n\t\t\t * Isolate the file name.\n\t\t\t * Include the surrounding \"\" or <> if present.\n\t\t\t */\n\t\t\tif (inc_opt != NULL\n\t\t\t\t   && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t\t{\n\t\t\t    // pattern contains \\zs, use the match\n\t\t\t    p = incl_regmatch.startp[0];\n\t\t\t    i = (int)(incl_regmatch.endp[0]\n\t\t\t\t\t\t   - incl_regmatch.startp[0]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // find the file name after the end of the match\n\t\t\t    for (p = incl_regmatch.endp[0];\n\t\t\t\t\t\t  *p && !vim_isfilec(*p); p++)\n\t\t\t\t;\n\t\t\t    for (i = 0; vim_isfilec(p[i]); i++)\n\t\t\t\t;\n\t\t\t}\n\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t    // Nothing found, use the rest of the line.\n\t\t\t    p = incl_regmatch.endp[0];\n\t\t\t    i = (int)STRLEN(p);\n\t\t\t}\n\t\t\t// Avoid checking before the start of the line, can\n\t\t\t// happen if \\zs appears in the regexp.\n\t\t\telse if (p > line)\n\t\t\t{\n\t\t\t    if (p[-1] == '\"' || p[-1] == '<')\n\t\t\t    {\n\t\t\t\t--p;\n\t\t\t\t++i;\n\t\t\t    }\n\t\t\t    if (p[i] == '\"' || p[i] == '>')\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tsave_char = p[i];\n\t\t\tp[i] = NUL;\n\t\t\tmsg_outtrans_attr(p, HL_ATTR(HLF_D));\n\t\t\tp[i] = save_char;\n\t\t    }\n\n\t\t    if (new_fname == NULL && action == ACTION_SHOW_ALL)\n\t\t    {\n\t\t\tif (already_searched)\n\t\t\t    msg_puts(_(\"  (Already listed)\"));\n\t\t\telse\n\t\t\t    msg_puts(_(\"  NOT FOUND\"));\n\t\t    }\n\t\t}\n\t\tout_flush();\t    // output each line directly\n\t    }\n\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Push the new file onto the file stack\n\t\tif (depth + 1 == old_files)\n\t\t{\n\t\t    bigger = ALLOC_MULT(SearchedFile, max_path_depth * 2);\n\t\t    if (bigger != NULL)\n\t\t    {\n\t\t\tfor (i = 0; i <= depth; i++)\n\t\t\t    bigger[i] = files[i];\n\t\t\tfor (i = depth + 1; i < old_files + max_path_depth; i++)\n\t\t\t{\n\t\t\t    bigger[i].fp = NULL;\n\t\t\t    bigger[i].name = NULL;\n\t\t\t    bigger[i].lnum = 0;\n\t\t\t    bigger[i].matched = FALSE;\n\t\t\t}\n\t\t\tfor (i = old_files; i < max_path_depth; i++)\n\t\t\t    bigger[i + max_path_depth] = files[i];\n\t\t\told_files += max_path_depth;\n\t\t\tmax_path_depth *= 2;\n\t\t\tvim_free(files);\n\t\t\tfiles = bigger;\n\t\t    }\n\t\t}\n\t\tif ((files[depth + 1].fp = mch_fopen((char *)new_fname, \"r\"))\n\t\t\t\t\t\t\t\t    == NULL)\n\t\t    vim_free(new_fname);\n\t\telse\n\t\t{\n\t\t    if (++depth == old_files)\n\t\t    {\n\t\t\t/*\n\t\t\t * lalloc() for 'bigger' must have failed above.  We\n\t\t\t * will forget one of our already visited files now.\n\t\t\t */\n\t\t\tvim_free(files[old_files].name);\n\t\t\t++old_files;\n\t\t    }\n\t\t    files[depth].name = curr_fname = new_fname;\n\t\t    files[depth].lnum = 0;\n\t\t    files[depth].matched = FALSE;\n\t\t    if (action == ACTION_EXPAND)\n\t\t    {\n\t\t\tmsg_hist_off = TRUE;\t// reset in msg_trunc_attr()\n\t\t\tvim_snprintf((char*)IObuff, IOSIZE,\n\t\t\t\t_(\"Scanning included file: %s\"),\n\t\t\t\t(char *)new_fname);\n\t\t\tmsg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n\t\t    }\n\t\t    else if (p_verbose >= 5)\n\t\t    {\n\t\t\tverbose_enter();\n\t\t\tsmsg(_(\"Searching included file %s\"),\n\t\t\t\t\t\t\t   (char *)new_fname);\n\t\t\tverbose_leave();\n\t\t    }\n\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Check if the line is a define (type == FIND_DEFINE)\n\t     */\n\t    p = line;\nsearch_line:\n\t    define_matched = FALSE;\n\t    if (def_regmatch.regprog != NULL\n\t\t\t      && vim_regexec(&def_regmatch, line, (colnr_T)0))\n\t    {\n\t\t/*\n\t\t * Pattern must be first identifier after 'define', so skip\n\t\t * to that position before checking for match of pattern.  Also\n\t\t * don't let it match beyond the end of this identifier.\n\t\t */\n\t\tp = def_regmatch.endp[0];\n\t\twhile (*p && !vim_iswordc(*p))\n\t\t    p++;\n\t\tdefine_matched = TRUE;\n\t    }\n\n\t    /*\n\t     * Look for a match.  Don't do this if we are looking for a\n\t     * define and this line didn't match define_prog above.\n\t     */\n\t    if (def_regmatch.regprog == NULL || define_matched)\n\t    {\n\t\tif (define_matched || compl_status_sol())\n\t\t{\n\t\t    // compare the first \"len\" chars from \"ptr\"\n\t\t    startp = skipwhite(p);\n\t\t    if (p_ic)\n\t\t\tmatched = !MB_STRNICMP(startp, ptr, len);\n\t\t    else\n\t\t\tmatched = !STRNCMP(startp, ptr, len);\n\t\t    if (matched && define_matched && whole\n\t\t\t\t\t\t  && vim_iswordc(startp[len]))\n\t\t\tmatched = FALSE;\n\t\t}\n\t\telse if (regmatch.regprog != NULL\n\t\t\t && vim_regexec(&regmatch, line, (colnr_T)(p - line)))\n\t\t{\n\t\t    matched = TRUE;\n\t\t    startp = regmatch.startp[0];\n\t\t    /*\n\t\t     * Check if the line is not a comment line (unless we are\n\t\t     * looking for a define).  A line starting with \"# define\"\n\t\t     * is not considered to be a comment line.\n\t\t     */\n\t\t    if (!define_matched && skip_comments)\n\t\t    {\n\t\t\tif ((*line != '#' ||\n\t\t\t\tSTRNCMP(skipwhite(line + 1), \"define\", 6) != 0)\n\t\t\t\t&& get_leader_len(line, NULL, FALSE, TRUE))\n\t\t\t    matched = FALSE;\n\n\t\t\t/*\n\t\t\t * Also check for a \"/ *\" or \"/ /\" before the match.\n\t\t\t * Skips lines like \"int backwards;  / * normal index\n\t\t\t * * /\" when looking for \"normal\".\n\t\t\t * Note: Doesn't skip \"/ *\" in comments.\n\t\t\t */\n\t\t\tp = skipwhite(line);\n\t\t\tif (matched\n\t\t\t\t|| (p[0] == '/' && p[1] == '*') || p[0] == '*')\n\t\t\t    for (p = line; *p && p < startp; ++p)\n\t\t\t    {\n\t\t\t\tif (matched\n\t\t\t\t\t&& p[0] == '/'\n\t\t\t\t\t&& (p[1] == '*' || p[1] == '/'))\n\t\t\t\t{\n\t\t\t\t    matched = FALSE;\n\t\t\t\t    // After \"//\" all text is comment\n\t\t\t\t    if (p[1] == '/')\n\t\t\t\t\tbreak;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t\telse if (!matched && p[0] == '*' && p[1] == '/')\n\t\t\t\t{\n\t\t\t\t    // Can find match after \"* /\".\n\t\t\t\t    matched = TRUE;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t    }\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (matched)\n\t{\n\t    if (action == ACTION_EXPAND)\n\t    {\n\t\tint\tcont_s_ipos = FALSE;\n\t\tint\tadd_r;\n\t\tchar_u\t*aux;\n\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum)\n\t\t    break;\n\t\tfound = TRUE;\n\t\taux = p = startp;\n\t\tif (compl_status_adding())\n\t\t{\n\t\t    p += ins_compl_len();\n\t\t    if (vim_iswordp(p))\n\t\t\tgoto exit_matched;\n\t\t    p = find_word_start(p);\n\t\t}\n\t\tp = find_word_end(p);\n\t\ti = (int)(p - aux);\n\n\t\tif (compl_status_adding() && i == ins_compl_len())\n\t\t{\n\t\t    // IOSIZE > compl_length, so the STRNCPY works\n\t\t    STRNCPY(IObuff, aux, i);\n\n\t\t    // Get the next line: when \"depth\" < 0  from the current\n\t\t    // buffer, otherwise from the included file.  Jump to\n\t\t    // exit_matched when past the last line.\n\t\t    if (depth < 0)\n\t\t    {\n\t\t\tif (lnum >= end_lnum)\n\t\t\t    goto exit_matched;\n\t\t\tline = ml_get(++lnum);\n\t\t    }\n\t\t    else if (vim_fgets(line = file_line,\n\t\t\t\t\t\t      LSIZE, files[depth].fp))\n\t\t\tgoto exit_matched;\n\n\t\t    // we read a line, set \"already\" to check this \"line\" later\n\t\t    // if depth >= 0 we'll increase files[depth].lnum far\n\t\t    // below  -- Acevedo\n\t\t    already = aux = p = skipwhite(line);\n\t\t    p = find_word_start(p);\n\t\t    p = find_word_end(p);\n\t\t    if (p > aux)\n\t\t    {\n\t\t\tif (*aux != ')' && IObuff[i-1] != TAB)\n\t\t\t{\n\t\t\t    if (IObuff[i-1] != ' ')\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t    // IObuf =~ \"\\(\\k\\|\\i\\).* \", thus i >= 2\n\t\t\t    if (p_js\n\t\t\t\t&& (IObuff[i-2] == '.'\n\t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL\n\t\t\t\t\t&& (IObuff[i-2] == '?'\n\t\t\t\t\t    || IObuff[i-2] == '!'))))\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t}\n\t\t\t// copy as much as possible of the new word\n\t\t\tif (p - aux >= IOSIZE - i)\n\t\t\t    p = aux + IOSIZE - i - 1;\n\t\t\tSTRNCPY(IObuff + i, aux, p - aux);\n\t\t\ti += (int)(p - aux);\n\t\t\tcont_s_ipos = TRUE;\n\t\t    }\n\t\t    IObuff[i] = NUL;\n\t\t    aux = IObuff;\n\n\t\t    if (i == ins_compl_len())\n\t\t\tgoto exit_matched;\n\t\t}\n\n\t\tadd_r = ins_compl_add_infercase(aux, i, p_ic,\n\t\t\tcurr_fname == curbuf->b_fname ? NULL : curr_fname,\n\t\t\tdir, cont_s_ipos);\n\t\tif (add_r == OK)\n\t\t    // if dir was BACKWARD then honor it just once\n\t\t    dir = FORWARD;\n\t\telse if (add_r == FAIL)\n\t\t    break;\n\t    }\n\t    else if (action == ACTION_SHOW_ALL)\n\t    {\n\t\tfound = TRUE;\n\t\tif (!did_show)\n\t\t    gotocmdline(TRUE);\t\t// cursor at status line\n\t\tif (curr_fname != prev_fname)\n\t\t{\n\t\t    if (did_show)\n\t\t\tmsg_putchar('\\n');\t// cursor below last one\n\t\t    if (!got_int)\t\t// don't display if 'q' typed\n\t\t\t\t\t\t// at \"--more--\" message\n\t\t\tmsg_home_replace_hl(curr_fname);\n\t\t    prev_fname = curr_fname;\n\t\t}\n\t\tdid_show = TRUE;\n\t\tif (!got_int)\n\t\t    show_pat_in_path(line, type, TRUE, action,\n\t\t\t    (depth == -1) ? NULL : files[depth].fp,\n\t\t\t    (depth == -1) ? &lnum : &files[depth].lnum,\n\t\t\t    match_count++);\n\n\t\t// Set matched flag for this file and all the ones that\n\t\t// include it\n\t\tfor (i = 0; i <= depth; ++i)\n\t\t    files[i].matched = TRUE;\n\t    }\n\t    else if (--count <= 0)\n\t    {\n\t\tfound = TRUE;\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum\n#if defined(FEAT_QUICKFIX)\n\t\t\t\t\t\t      && g_do_tagpreview == 0\n#endif\n\t\t\t\t\t\t      )\n\t\t    emsg(_(e_match_is_on_current_line));\n\t\telse if (action == ACTION_SHOW)\n\t\t{\n\t\t    show_pat_in_path(line, type, did_show, action,\n\t\t\t(depth == -1) ? NULL : files[depth].fp,\n\t\t\t(depth == -1) ? &lnum : &files[depth].lnum, 1L);\n\t\t    did_show = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n#if defined(FEAT_QUICKFIX)\n\t\t    // \":psearch\" uses the preview window\n\t\t    if (g_do_tagpreview != 0)\n\t\t    {\n\t\t\tcurwin_save = curwin;\n\t\t\tprepare_tagpreview(TRUE, TRUE, FALSE);\n\t\t    }\n#endif\n\t\t    if (action == ACTION_SPLIT)\n\t\t    {\n\t\t\tif (win_split(0, 0) == FAIL)\n\t\t\t    break;\n\t\t\tRESET_BINDING(curwin);\n\t\t    }\n\t\t    if (depth == -1)\n\t\t    {\n\t\t\t// match in current file\n#if defined(FEAT_QUICKFIX)\n\t\t\tif (g_do_tagpreview != 0)\n\t\t\t{\n\t\t\t    if (!win_valid(curwin_save))\n\t\t\t\tbreak;\n\t\t\t    if (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t   curwin_save->w_buffer->b_fnum, NULL,\n\t\t\t\t\t\t     NULL, TRUE, lnum, FALSE)))\n\t\t\t\tbreak;\t// failed to jump to file\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    setpcmark();\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tcheck_cursor();\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t0, files[depth].name, NULL, TRUE,\n\t\t\t\t\t\t    files[depth].lnum, FALSE)))\n\t\t\t    break;\t// failed to jump to file\n\t\t\t// autocommands may have changed the lnum, we don't\n\t\t\t// want that here\n\t\t\tcurwin->w_cursor.lnum = files[depth].lnum;\n\t\t    }\n\t\t}\n\t\tif (action != ACTION_SHOW)\n\t\t{\n\t\t    curwin->w_cursor.col = (colnr_T)(startp - line);\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t}\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0\n\t\t\t   && curwin != curwin_save && win_valid(curwin_save))\n\t\t{\n\t\t    // Return cursor to where we were\n\t\t    validate_cursor();\n\t\t    redraw_later(VALID);\n\t\t    win_enter(curwin_save, TRUE);\n\t\t}\n# ifdef FEAT_PROP_POPUP\n\t\telse if (WIN_IS_POPUP(curwin))\n\t\t    // can't keep focus in popup window\n\t\t    win_enter(firstwin, TRUE);\n# endif\n#endif\n\t\tbreak;\n\t    }\nexit_matched:\n\t    matched = FALSE;\n\t    // look for other matches in the rest of the line if we\n\t    // are not at the end of it already\n\t    if (def_regmatch.regprog == NULL\n\t\t    && action == ACTION_EXPAND\n\t\t    && !compl_status_sol()\n\t\t    && *startp != NUL\n\t\t    && *(p = startp + mb_ptr2len(startp)) != NUL)\n\t\tgoto search_line;\n\t}\n\tline_breakcheck();\n\tif (action == ACTION_EXPAND)\n\t    ins_compl_check_keys(30, FALSE);\n\tif (got_int || ins_compl_interrupted())\n\t    break;\n\n\t/*\n\t * Read the next line.  When reading an included file and encountering\n\t * end-of-file, close the file and continue in the file that included\n\t * it.\n\t */\n\twhile (depth >= 0 && !already\n\t\t&& vim_fgets(line = file_line, LSIZE, files[depth].fp))\n\t{\n\t    fclose(files[depth].fp);\n\t    --old_files;\n\t    files[old_files].name = files[depth].name;\n\t    files[old_files].matched = files[depth].matched;\n\t    --depth;\n\t    curr_fname = (depth == -1) ? curbuf->b_fname\n\t\t\t\t       : files[depth].name;\n\t    if (depth < depth_displayed)\n\t\tdepth_displayed = depth;\n\t}\n\tif (depth >= 0)\t\t// we could read the line\n\t{\n\t    files[depth].lnum++;\n\t    // Remove any CR and LF from the line.\n\t    i = (int)STRLEN(line);\n\t    if (i > 0 && line[i - 1] == '\\n')\n\t\tline[--i] = NUL;\n\t    if (i > 0 && line[i - 1] == '\\r')\n\t\tline[--i] = NUL;\n\t}\n\telse if (!already)\n\t{\n\t    if (++lnum > end_lnum)\n\t\tbreak;\n\t    line = ml_get(lnum);\n\t}\n\talready = NULL;\n    }\n    // End of big for (;;) loop.\n\n    // Close any files that are still open.\n    for (i = 0; i <= depth; i++)\n    {\n\tfclose(files[i].fp);\n\tvim_free(files[i].name);\n    }\n    for (i = old_files; i < max_path_depth; i++)\n\tvim_free(files[i].name);\n    vim_free(files);\n\n    if (type == CHECK_PATH)\n    {\n\tif (!did_show)\n\t{\n\t    if (action != ACTION_SHOW_ALL)\n\t\tmsg(_(\"All included files were found\"));\n\t    else\n\t\tmsg(_(\"No included files\"));\n\t}\n    }\n    else if (!found && action != ACTION_EXPAND)\n    {\n\tif (got_int || ins_compl_interrupted())\n\t    emsg(_(e_interrupted));\n\telse if (type == FIND_DEFINE)\n\t    emsg(_(e_couldnt_find_definition));\n\telse\n\t    emsg(_(e_couldnt_find_pattern));\n    }\n    if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)\n\tmsg_end();\n\nfpip_end:\n    vim_free(file_line);\n    vim_regfree(regmatch.regprog);\n    vim_regfree(incl_regmatch.regprog);\n    vim_regfree(def_regmatch.regprog);\n}\n\n    static void\nshow_pat_in_path(\n    char_u  *line,\n    int\t    type,\n    int\t    did_show,\n    int\t    action,\n    FILE    *fp,\n    linenr_T *lnum,\n    long    count)\n{\n    char_u  *p;\n\n    if (did_show)\n\tmsg_putchar('\\n');\t// cursor below last one\n    else if (!msg_silent)\n\tgotocmdline(TRUE);\t// cursor at status line\n    if (got_int)\t\t// 'q' typed at \"--more--\" message\n\treturn;\n    for (;;)\n    {\n\tp = line + STRLEN(line) - 1;\n\tif (fp != NULL)\n\t{\n\t    // We used fgets(), so get rid of newline at end\n\t    if (p >= line && *p == '\\n')\n\t\t--p;\n\t    if (p >= line && *p == '\\r')\n\t\t--p;\n\t    *(p + 1) = NUL;\n\t}\n\tif (action == ACTION_SHOW_ALL)\n\t{\n\t    sprintf((char *)IObuff, \"%3ld: \", count);\t// show match nr\n\t    msg_puts((char *)IObuff);\n\t    sprintf((char *)IObuff, \"%4ld\", *lnum);\t// show line nr\n\t\t\t\t\t\t// Highlight line numbers\n\t    msg_puts_attr((char *)IObuff, HL_ATTR(HLF_N));\n\t    msg_puts(\" \");\n\t}\n\tmsg_prt_line(line, FALSE);\n\tout_flush();\t\t\t// show one line at a time\n\n\t// Definition continues until line that doesn't end with '\\'\n\tif (got_int || type != FIND_DEFINE || p < line || *p != '\\\\')\n\t    break;\n\n\tif (fp != NULL)\n\t{\n\t    if (vim_fgets(line, LSIZE, fp)) // end of file\n\t\tbreak;\n\t    ++*lnum;\n\t}\n\telse\n\t{\n\t    if (++*lnum > curbuf->b_ml.ml_line_count)\n\t\tbreak;\n\t    line = ml_get(*lnum);\n\t}\n\tmsg_putchar('\\n');\n    }\n}\n#endif\n\n#ifdef FEAT_VIMINFO\n/*\n * Return the last used search pattern at \"idx\".\n */\n    spat_T *\nget_spat(int idx)\n{\n    return &spats[idx];\n}\n\n/*\n * Return the last used search pattern index.\n */\n    int\nget_spat_last_idx(void)\n{\n    return last_idx;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(FEAT_PROTO)\n/*\n * \"searchcount()\" function\n */\n    void\nf_searchcount(typval_T *argvars, typval_T *rettv)\n{\n    pos_T\t\tpos = curwin->w_cursor;\n    char_u\t\t*pattern = NULL;\n    int\t\t\tmaxcount = SEARCH_STAT_DEF_MAX_COUNT;\n    long\t\ttimeout = SEARCH_STAT_DEF_TIMEOUT;\n    int\t\t\trecompute = TRUE;\n    searchstat_T\tstat;\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n\n    if (in_vim9script() && check_for_opt_dict_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (shortmess(SHM_SEARCHCOUNT))\t// 'shortmess' contains 'S' flag\n\trecompute = TRUE;\n\n    if (argvars[0].v_type != VAR_UNKNOWN)\n    {\n\tdict_T\t\t*dict;\n\tdictitem_T\t*di;\n\tlistitem_T\t*li;\n\tint\t\terror = FALSE;\n\n\tif (argvars[0].v_type != VAR_DICT || argvars[0].vval.v_dict == NULL)\n\t{\n\t    emsg(_(e_dictionary_required));\n\t    return;\n\t}\n\tdict = argvars[0].vval.v_dict;\n\tdi = dict_find(dict, (char_u *)\"timeout\", -1);\n\tif (di != NULL)\n\t{\n\t    timeout = (long)tv_get_number_chk(&di->di_tv, &error);\n\t    if (error)\n\t\treturn;\n\t}\n\tdi = dict_find(dict, (char_u *)\"maxcount\", -1);\n\tif (di != NULL)\n\t{\n\t    maxcount = (int)tv_get_number_chk(&di->di_tv, &error);\n\t    if (error)\n\t\treturn;\n\t}\n\trecompute = dict_get_bool(dict, (char_u *)\"recompute\", recompute);\n\tdi = dict_find(dict, (char_u *)\"pattern\", -1);\n\tif (di != NULL)\n\t{\n\t    pattern = tv_get_string_chk(&di->di_tv);\n\t    if (pattern == NULL)\n\t\treturn;\n\t}\n\tdi = dict_find(dict, (char_u *)\"pos\", -1);\n\tif (di != NULL)\n\t{\n\t    if (di->di_tv.v_type != VAR_LIST)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), \"pos\");\n\t\treturn;\n\t    }\n\t    if (list_len(di->di_tv.vval.v_list) != 3)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), \"List format should be [lnum, col, off]\");\n\t\treturn;\n\t    }\n\t    li = list_find(di->di_tv.vval.v_list, 0L);\n\t    if (li != NULL)\n\t    {\n\t\tpos.lnum = tv_get_number_chk(&li->li_tv, &error);\n\t\tif (error)\n\t\t    return;\n\t    }\n\t    li = list_find(di->di_tv.vval.v_list, 1L);\n\t    if (li != NULL)\n\t    {\n\t\tpos.col = tv_get_number_chk(&li->li_tv, &error) - 1;\n\t\tif (error)\n\t\t    return;\n\t    }\n\t    li = list_find(di->di_tv.vval.v_list, 2L);\n\t    if (li != NULL)\n\t    {\n\t\tpos.coladd = tv_get_number_chk(&li->li_tv, &error);\n\t\tif (error)\n\t\t    return;\n\t    }\n\t}\n    }\n\n    save_last_search_pattern();\n#ifdef FEAT_SEARCH_EXTRA\n    save_incsearch_state();\n#endif\n    if (pattern != NULL)\n    {\n\tif (*pattern == NUL)\n\t    goto the_end;\n\tvim_free(spats[last_idx].pat);\n\tspats[last_idx].pat = vim_strsave(pattern);\n    }\n    if (spats[last_idx].pat == NULL || *spats[last_idx].pat == NUL)\n\tgoto the_end;\t// the previous pattern was never defined\n\n    update_search_stat(0, &pos, &pos, &stat, recompute, maxcount, timeout);\n\n    dict_add_number(rettv->vval.v_dict, \"current\", stat.cur);\n    dict_add_number(rettv->vval.v_dict, \"total\", stat.cnt);\n    dict_add_number(rettv->vval.v_dict, \"exact_match\", stat.exact_match);\n    dict_add_number(rettv->vval.v_dict, \"incomplete\", stat.incomplete);\n    dict_add_number(rettv->vval.v_dict, \"maxcount\", stat.last_maxcount);\n\nthe_end:\n    restore_last_search_pattern();\n#ifdef FEAT_SEARCH_EXTRA\n    restore_incsearch_state();\n#endif\n}\n#endif\n\n/*\n * Fuzzy string matching\n *\n * Ported from the lib_fts library authored by Forrest Smith.\n * https://github.com/forrestthewoods/lib_fts/tree/master/code\n *\n * The following blog describes the fuzzy matching algorithm:\n * https://www.forrestthewoods.com/blog/reverse_engineering_sublime_texts_fuzzy_match/\n *\n * Each matching string is assigned a score. The following factors are checked:\n *   - Matched letter\n *   - Unmatched letter\n *   - Consecutively matched letters\n *   - Proximity to start\n *   - Letter following a separator (space, underscore)\n *   - Uppercase letter following lowercase (aka CamelCase)\n *\n * Matched letters are good. Unmatched letters are bad. Matching near the start\n * is good. Matching the first letter in the middle of a phrase is good.\n * Matching the uppercase letters in camel case entries is good.\n *\n * The score assigned for each factor is explained below.\n * File paths are different from file names. File extensions may be ignorable.\n * Single words care about consecutive matches but not separators or camel\n * case.\n *   Score starts at 100\n *   Matched letter: +0 points\n *   Unmatched letter: -1 point\n *   Consecutive match bonus: +15 points\n *   First letter bonus: +15 points\n *   Separator bonus: +30 points\n *   Camel case bonus: +30 points\n *   Unmatched leading letter: -5 points (max: -15)\n *\n * There is some nuance to this. Scores don\u2019t have an intrinsic meaning. The\n * score range isn\u2019t 0 to 100. It\u2019s roughly [50, 150]. Longer words have a\n * lower minimum score due to unmatched letter penalty. Longer search patterns\n * have a higher maximum score due to match bonuses.\n *\n * Separator and camel case bonus is worth a LOT. Consecutive matches are worth\n * quite a bit.\n *\n * There is a penalty if you DON\u2019T match the first three letters. Which\n * effectively rewards matching near the start. However there\u2019s no difference\n * in matching between the middle and end.\n *\n * There is not an explicit bonus for an exact match. Unmatched letters receive\n * a penalty. So shorter strings and closer matches are worth more.\n */\ntypedef struct\n{\n    int\t\tidx;\t\t// used for stable sort\n    listitem_T\t*item;\n    int\t\tscore;\n    list_T\t*lmatchpos;\n} fuzzyItem_T;\n\n// bonus for adjacent matches; this is higher than SEPARATOR_BONUS so that\n// matching a whole word is preferred.\n#define SEQUENTIAL_BONUS 40\n// bonus if match occurs after a path separator\n#define PATH_SEPARATOR_BONUS 30\n// bonus if match occurs after a word separator\n#define WORD_SEPARATOR_BONUS 25\n// bonus if match is uppercase and prev is lower\n#define CAMEL_BONUS 30\n// bonus if the first letter is matched\n#define FIRST_LETTER_BONUS 15\n// penalty applied for every letter in str before the first match\n#define LEADING_LETTER_PENALTY (-5)\n// maximum penalty for leading letters\n#define MAX_LEADING_LETTER_PENALTY (-15)\n// penalty for every letter that doesn't match\n#define UNMATCHED_LETTER_PENALTY (-1)\n// penalty for gap in matching positions (-2 * k)\n#define GAP_PENALTY\t(-2)\n// Score for a string that doesn't fuzzy match the pattern\n#define SCORE_NONE\t(-9999)\n\n#define FUZZY_MATCH_RECURSION_LIMIT\t10\n\n/*\n * Compute a score for a fuzzy matched string. The matching character locations\n * are in 'matches'.\n */\n    static int\nfuzzy_match_compute_score(\n\tchar_u\t\t*str,\n\tint\t\tstrSz,\n\tint_u\t\t*matches,\n\tint\t\tnumMatches)\n{\n    int\t\tscore;\n    int\t\tpenalty;\n    int\t\tunmatched;\n    int\t\ti;\n    char_u\t*p = str;\n    int_u\tsidx = 0;\n\n    // Initialize score\n    score = 100;\n\n    // Apply leading letter penalty\n    penalty = LEADING_LETTER_PENALTY * matches[0];\n    if (penalty < MAX_LEADING_LETTER_PENALTY)\n\tpenalty = MAX_LEADING_LETTER_PENALTY;\n    score += penalty;\n\n    // Apply unmatched penalty\n    unmatched = strSz - numMatches;\n    score += UNMATCHED_LETTER_PENALTY * unmatched;\n\n    // Apply ordering bonuses\n    for (i = 0; i < numMatches; ++i)\n    {\n\tint_u\tcurrIdx = matches[i];\n\n\tif (i > 0)\n\t{\n\t    int_u\tprevIdx = matches[i - 1];\n\n\t    // Sequential\n\t    if (currIdx == (prevIdx + 1))\n\t\tscore += SEQUENTIAL_BONUS;\n\t    else\n\t\tscore += GAP_PENALTY * (currIdx - prevIdx);\n\t}\n\n\t// Check for bonuses based on neighbor character value\n\tif (currIdx > 0)\n\t{\n\t    // Camel case\n\t    int\tneighbor = ' ';\n\t    int\tcurr;\n\n\t    if (has_mbyte)\n\t    {\n\t\twhile (sidx < currIdx)\n\t\t{\n\t\t    neighbor = (*mb_ptr2char)(p);\n\t\t    MB_PTR_ADV(p);\n\t\t    sidx++;\n\t\t}\n\t\tcurr = (*mb_ptr2char)(p);\n\t    }\n\t    else\n\t    {\n\t\tneighbor = str[currIdx - 1];\n\t\tcurr = str[currIdx];\n\t    }\n\n\t    if (vim_islower(neighbor) && vim_isupper(curr))\n\t\tscore += CAMEL_BONUS;\n\n\t    // Bonus if the match follows a separator character\n\t    if (neighbor == '/' || neighbor == '\\\\')\n\t\tscore += PATH_SEPARATOR_BONUS;\n\t    else if (neighbor == ' ' || neighbor == '_')\n\t\tscore += WORD_SEPARATOR_BONUS;\n\t}\n\telse\n\t{\n\t    // First letter\n\t    score += FIRST_LETTER_BONUS;\n\t}\n    }\n    return score;\n}\n\n/*\n * Perform a recursive search for fuzzy matching 'fuzpat' in 'str'.\n * Return the number of matching characters.\n */\n    static int\nfuzzy_match_recursive(\n\tchar_u\t\t*fuzpat,\n\tchar_u\t\t*str,\n\tint_u\t\tstrIdx,\n\tint\t\t*outScore,\n\tchar_u\t\t*strBegin,\n\tint\t\tstrLen,\n\tint_u\t\t*srcMatches,\n\tint_u\t\t*matches,\n\tint\t\tmaxMatches,\n\tint\t\tnextMatch,\n\tint\t\t*recursionCount)\n{\n    // Recursion params\n    int\t\trecursiveMatch = FALSE;\n    int_u\tbestRecursiveMatches[MAX_FUZZY_MATCHES];\n    int\t\tbestRecursiveScore = 0;\n    int\t\tfirst_match;\n    int\t\tmatched;\n\n    // Count recursions\n    ++*recursionCount;\n    if (*recursionCount >= FUZZY_MATCH_RECURSION_LIMIT)\n\treturn 0;\n\n    // Detect end of strings\n    if (*fuzpat == NUL || *str == NUL)\n\treturn 0;\n\n    // Loop through fuzpat and str looking for a match\n    first_match = TRUE;\n    while (*fuzpat != NUL && *str != NUL)\n    {\n\tint\tc1;\n\tint\tc2;\n\n\tc1 = PTR2CHAR(fuzpat);\n\tc2 = PTR2CHAR(str);\n\n\t// Found match\n\tif (vim_tolower(c1) == vim_tolower(c2))\n\t{\n\t    int_u\trecursiveMatches[MAX_FUZZY_MATCHES];\n\t    int\t\trecursiveScore = 0;\n\t    char_u\t*next_char;\n\n\t    // Supplied matches buffer was too short\n\t    if (nextMatch >= maxMatches)\n\t\treturn 0;\n\n\t    // \"Copy-on-Write\" srcMatches into matches\n\t    if (first_match && srcMatches)\n\t    {\n\t\tmemcpy(matches, srcMatches, nextMatch * sizeof(srcMatches[0]));\n\t\tfirst_match = FALSE;\n\t    }\n\n\t    // Recursive call that \"skips\" this match\n\t    if (has_mbyte)\n\t\tnext_char = str + (*mb_ptr2len)(str);\n\t    else\n\t\tnext_char = str + 1;\n\t    if (fuzzy_match_recursive(fuzpat, next_char, strIdx + 1,\n\t\t\t&recursiveScore, strBegin, strLen, matches,\n\t\t\trecursiveMatches,\n\t\t\tARRAY_LENGTH(recursiveMatches),\n\t\t\tnextMatch, recursionCount))\n\t    {\n\t\t// Pick best recursive score\n\t\tif (!recursiveMatch || recursiveScore > bestRecursiveScore)\n\t\t{\n\t\t    memcpy(bestRecursiveMatches, recursiveMatches,\n\t\t\t    MAX_FUZZY_MATCHES * sizeof(recursiveMatches[0]));\n\t\t    bestRecursiveScore = recursiveScore;\n\t\t}\n\t\trecursiveMatch = TRUE;\n\t    }\n\n\t    // Advance\n\t    matches[nextMatch++] = strIdx;\n\t    if (has_mbyte)\n\t\tMB_PTR_ADV(fuzpat);\n\t    else\n\t\t++fuzpat;\n\t}\n\tif (has_mbyte)\n\t    MB_PTR_ADV(str);\n\telse\n\t    ++str;\n\tstrIdx++;\n    }\n\n    // Determine if full fuzpat was matched\n    matched = *fuzpat == NUL ? TRUE : FALSE;\n\n    // Calculate score\n    if (matched)\n\t*outScore = fuzzy_match_compute_score(strBegin, strLen, matches,\n\t\tnextMatch);\n\n    // Return best result\n    if (recursiveMatch && (!matched || bestRecursiveScore > *outScore))\n    {\n\t// Recursive score is better than \"this\"\n\tmemcpy(matches, bestRecursiveMatches, maxMatches * sizeof(matches[0]));\n\t*outScore = bestRecursiveScore;\n\treturn nextMatch;\n    }\n    else if (matched)\n\treturn nextMatch;\t// \"this\" score is better than recursive\n\n    return 0;\t\t// no match\n}\n\n/*\n * fuzzy_match()\n *\n * Performs exhaustive search via recursion to find all possible matches and\n * match with highest score.\n * Scores values have no intrinsic meaning.  Possible score range is not\n * normalized and varies with pattern.\n * Recursion is limited internally (default=10) to prevent degenerate cases\n * (pat_arg=\"aaaaaa\" str=\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\").\n * Uses char_u for match indices. Therefore patterns are limited to\n * MAX_FUZZY_MATCHES characters.\n *\n * Returns TRUE if 'pat_arg' matches 'str'. Also returns the match score in\n * 'outScore' and the matching character positions in 'matches'.\n */\n    int\nfuzzy_match(\n\tchar_u\t\t*str,\n\tchar_u\t\t*pat_arg,\n\tint\t\tmatchseq,\n\tint\t\t*outScore,\n\tint_u\t\t*matches,\n\tint\t\tmaxMatches)\n{\n    int\t\trecursionCount = 0;\n    int\t\tlen = MB_CHARLEN(str);\n    char_u\t*save_pat;\n    char_u\t*pat;\n    char_u\t*p;\n    int\t\tcomplete = FALSE;\n    int\t\tscore = 0;\n    int\t\tnumMatches = 0;\n    int\t\tmatchCount;\n\n    *outScore = 0;\n\n    save_pat = vim_strsave(pat_arg);\n    if (save_pat == NULL)\n\treturn FALSE;\n    pat = save_pat;\n    p = pat;\n\n    // Try matching each word in 'pat_arg' in 'str'\n    while (TRUE)\n    {\n\tif (matchseq)\n\t    complete = TRUE;\n\telse\n\t{\n\t    // Extract one word from the pattern (separated by space)\n\t    p = skipwhite(p);\n\t    if (*p == NUL)\n\t\tbreak;\n\t    pat = p;\n\t    while (*p != NUL && !VIM_ISWHITE(PTR2CHAR(p)))\n\t    {\n\t\tif (has_mbyte)\n\t\t    MB_PTR_ADV(p);\n\t\telse\n\t\t    ++p;\n\t    }\n\t    if (*p == NUL)\t\t// processed all the words\n\t\tcomplete = TRUE;\n\t    *p = NUL;\n\t}\n\n\tscore = 0;\n\trecursionCount = 0;\n\tmatchCount = fuzzy_match_recursive(pat, str, 0, &score, str, len, NULL,\n\t\t\t\tmatches + numMatches, maxMatches - numMatches,\n\t\t\t\t0, &recursionCount);\n\tif (matchCount == 0)\n\t{\n\t    numMatches = 0;\n\t    break;\n\t}\n\n\t// Accumulate the match score and the number of matches\n\t*outScore += score;\n\tnumMatches += matchCount;\n\n\tif (complete)\n\t    break;\n\n\t// try matching the next word\n\t++p;\n    }\n\n    vim_free(save_pat);\n    return numMatches != 0;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_PROTO)\n/*\n * Sort the fuzzy matches in the descending order of the match score.\n * For items with same score, retain the order using the index (stable sort)\n */\n    static int\nfuzzy_match_item_compare(const void *s1, const void *s2)\n{\n    int\t\tv1 = ((fuzzyItem_T *)s1)->score;\n    int\t\tv2 = ((fuzzyItem_T *)s2)->score;\n    int\t\tidx1 = ((fuzzyItem_T *)s1)->idx;\n    int\t\tidx2 = ((fuzzyItem_T *)s2)->idx;\n\n    return v1 == v2 ? (idx1 - idx2) : v1 > v2 ? -1 : 1;\n}\n\n/*\n * Fuzzy search the string 'str' in a list of 'items' and return the matching\n * strings in 'fmatchlist'.\n * If 'matchseq' is TRUE, then for multi-word search strings, match all the\n * words in sequence.\n * If 'items' is a list of strings, then search for 'str' in the list.\n * If 'items' is a list of dicts, then either use 'key' to lookup the string\n * for each item or use 'item_cb' Funcref function to get the string.\n * If 'retmatchpos' is TRUE, then return a list of positions where 'str'\n * matches for each item.\n */\n    static void\nfuzzy_match_in_list(\n\tlist_T\t\t*l,\n\tchar_u\t\t*str,\n\tint\t\tmatchseq,\n\tchar_u\t\t*key,\n\tcallback_T\t*item_cb,\n\tint\t\tretmatchpos,\n\tlist_T\t\t*fmatchlist,\n\tlong\t\tmax_matches)\n{\n    long\tlen;\n    fuzzyItem_T\t*items;\n    listitem_T\t*li;\n    long\ti = 0;\n    long\tmatch_count = 0;\n    int_u\tmatches[MAX_FUZZY_MATCHES];\n\n    len = list_len(l);\n    if (len == 0)\n\treturn;\n    if (max_matches > 0 && len > max_matches)\n\tlen = max_matches;\n\n    items = ALLOC_CLEAR_MULT(fuzzyItem_T, len);\n    if (items == NULL)\n\treturn;\n\n    // For all the string items in items, get the fuzzy matching score\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\tint\t\tscore;\n\tchar_u\t\t*itemstr;\n\ttypval_T\trettv;\n\n\tif (max_matches > 0 && match_count >= max_matches)\n\t    break;\n\n\titemstr = NULL;\n\trettv.v_type = VAR_UNKNOWN;\n\tif (li->li_tv.v_type == VAR_STRING)\t// list of strings\n\t    itemstr = li->li_tv.vval.v_string;\n\telse if (li->li_tv.v_type == VAR_DICT\n\t\t\t\t&& (key != NULL || item_cb->cb_name != NULL))\n\t{\n\t    // For a dict, either use the specified key to lookup the string or\n\t    // use the specified callback function to get the string.\n\t    if (key != NULL)\n\t\titemstr = dict_get_string(li->li_tv.vval.v_dict, key, FALSE);\n\t    else\n\t    {\n\t\ttypval_T\targv[2];\n\n\t\t// Invoke the supplied callback (if any) to get the dict item\n\t\tli->li_tv.vval.v_dict->dv_refcount++;\n\t\targv[0].v_type = VAR_DICT;\n\t\targv[0].vval.v_dict = li->li_tv.vval.v_dict;\n\t\targv[1].v_type = VAR_UNKNOWN;\n\t\tif (call_callback(item_cb, -1, &rettv, 1, argv) != FAIL)\n\t\t{\n\t\t    if (rettv.v_type == VAR_STRING)\n\t\t\titemstr = rettv.vval.v_string;\n\t\t}\n\t\tdict_unref(li->li_tv.vval.v_dict);\n\t    }\n\t}\n\n\tif (itemstr != NULL\n\t\t&& fuzzy_match(itemstr, str, matchseq, &score, matches,\n\t\t\t\t\t\t\tMAX_FUZZY_MATCHES))\n\t{\n\t    items[match_count].idx = match_count;\n\t    items[match_count].item = li;\n\t    items[match_count].score = score;\n\n\t    // Copy the list of matching positions in itemstr to a list, if\n\t    // 'retmatchpos' is set.\n\t    if (retmatchpos)\n\t    {\n\t\tint\tj = 0;\n\t\tchar_u\t*p;\n\n\t\titems[match_count].lmatchpos = list_alloc();\n\t\tif (items[match_count].lmatchpos == NULL)\n\t\t    goto done;\n\n\t\tp = str;\n\t\twhile (*p != NUL)\n\t\t{\n\t\t    if (!VIM_ISWHITE(PTR2CHAR(p)) || matchseq)\n\t\t    {\n\t\t\tif (list_append_number(items[match_count].lmatchpos,\n\t\t\t\t    matches[j]) == FAIL)\n\t\t\t    goto done;\n\t\t\tj++;\n\t\t    }\n\t\t    if (has_mbyte)\n\t\t\tMB_PTR_ADV(p);\n\t\t    else\n\t\t\t++p;\n\t\t}\n\t    }\n\t    ++match_count;\n\t}\n\tclear_tv(&rettv);\n    }\n\n    if (match_count > 0)\n    {\n\tlist_T\t\t*retlist;\n\n\t// Sort the list by the descending order of the match score\n\tqsort((void *)items, (size_t)match_count, sizeof(fuzzyItem_T),\n\t\tfuzzy_match_item_compare);\n\n\t// For matchfuzzy(), return a list of matched strings.\n\t//\t    ['str1', 'str2', 'str3']\n\t// For matchfuzzypos(), return a list with three items.\n\t// The first item is a list of matched strings. The second item\n\t// is a list of lists where each list item is a list of matched\n\t// character positions. The third item is a list of matching scores.\n\t//\t[['str1', 'str2', 'str3'], [[1, 3], [1, 3], [1, 3]]]\n\tif (retmatchpos)\n\t{\n\t    li = list_find(fmatchlist, 0);\n\t    if (li == NULL || li->li_tv.vval.v_list == NULL)\n\t\tgoto done;\n\t    retlist = li->li_tv.vval.v_list;\n\t}\n\telse\n\t    retlist = fmatchlist;\n\n\t// Copy the matching strings with a valid score to the return list\n\tfor (i = 0; i < match_count; i++)\n\t{\n\t    if (items[i].score == SCORE_NONE)\n\t\tbreak;\n\t    list_append_tv(retlist, &items[i].item->li_tv);\n\t}\n\n\t// next copy the list of matching positions\n\tif (retmatchpos)\n\t{\n\t    li = list_find(fmatchlist, -2);\n\t    if (li == NULL || li->li_tv.vval.v_list == NULL)\n\t\tgoto done;\n\t    retlist = li->li_tv.vval.v_list;\n\n\t    for (i = 0; i < match_count; i++)\n\t    {\n\t\tif (items[i].score == SCORE_NONE)\n\t\t    break;\n\t\tif (items[i].lmatchpos != NULL\n\t\t\t&& list_append_list(retlist, items[i].lmatchpos)\n\t\t\t\t\t\t\t\t== FAIL)\n\t\t    goto done;\n\t    }\n\n\t    // copy the matching scores\n\t    li = list_find(fmatchlist, -1);\n\t    if (li == NULL || li->li_tv.vval.v_list == NULL)\n\t\tgoto done;\n\t    retlist = li->li_tv.vval.v_list;\n\t    for (i = 0; i < match_count; i++)\n\t    {\n\t\tif (items[i].score == SCORE_NONE)\n\t\t    break;\n\t\tif (list_append_number(retlist, items[i].score) == FAIL)\n\t\t    goto done;\n\t    }\n\t}\n    }\n\ndone:\n    vim_free(items);\n}\n\n/*\n * Do fuzzy matching. Returns the list of matched strings in 'rettv'.\n * If 'retmatchpos' is TRUE, also returns the matching character positions.\n */\n    static void\ndo_fuzzymatch(typval_T *argvars, typval_T *rettv, int retmatchpos)\n{\n    callback_T\tcb;\n    char_u\t*key = NULL;\n    int\t\tret;\n    int\t\tmatchseq = FALSE;\n    long\tmax_matches = 0;\n\n    if (in_vim9script()\n\t    && (check_for_list_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_dict_arg(argvars, 2) == FAIL))\n\treturn;\n\n    CLEAR_POINTER(&cb);\n\n    // validate and get the arguments\n    if (argvars[0].v_type != VAR_LIST || argvars[0].vval.v_list == NULL)\n    {\n\tsemsg(_(e_argument_of_str_must_be_list),\n\t\t\t     retmatchpos ? \"matchfuzzypos()\" : \"matchfuzzy()\");\n\treturn;\n    }\n    if (argvars[1].v_type != VAR_STRING\n\t    || argvars[1].vval.v_string == NULL)\n    {\n\tsemsg(_(e_invalid_argument_str), tv_get_string(&argvars[1]));\n\treturn;\n    }\n\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tdict_T\t\t*d;\n\tdictitem_T\t*di;\n\n\tif (argvars[2].v_type != VAR_DICT || argvars[2].vval.v_dict == NULL)\n\t{\n\t    emsg(_(e_dictionary_required));\n\t    return;\n\t}\n\n\t// To search a dict, either a callback function or a key can be\n\t// specified.\n\td = argvars[2].vval.v_dict;\n\tif ((di = dict_find(d, (char_u *)\"key\", -1)) != NULL)\n\t{\n\t    if (di->di_tv.v_type != VAR_STRING\n\t\t    || di->di_tv.vval.v_string == NULL\n\t\t    || *di->di_tv.vval.v_string == NUL)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), tv_get_string(&di->di_tv));\n\t\treturn;\n\t    }\n\t    key = tv_get_string(&di->di_tv);\n\t}\n\telse if ((di = dict_find(d, (char_u *)\"text_cb\", -1)) != NULL)\n\t{\n\t    cb = get_callback(&di->di_tv);\n\t    if (cb.cb_name == NULL)\n\t    {\n\t\tsemsg(_(e_invalid_value_for_argument_str), \"text_cb\");\n\t\treturn;\n\t    }\n\t}\n\telse if ((di = dict_find(d, (char_u *)\"limit\", -1)) != NULL)\n\t{\n\t    if (di->di_tv.v_type != VAR_NUMBER)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), tv_get_string(&di->di_tv));\n\t\treturn;\n\t    }\n\t    max_matches = (long)tv_get_number_chk(&di->di_tv, NULL);\n\t}\n\n\tif (dict_has_key(d, \"matchseq\"))\n\t    matchseq = TRUE;\n    }\n\n    // get the fuzzy matches\n    ret = rettv_list_alloc(rettv);\n    if (ret != OK)\n\tgoto done;\n    if (retmatchpos)\n    {\n\tlist_T\t*l;\n\n\t// For matchfuzzypos(), a list with three items are returned. First\n\t// item is a list of matching strings, the second item is a list of\n\t// lists with matching positions within each string and the third item\n\t// is the list of scores of the matches.\n\tl = list_alloc();\n\tif (l == NULL)\n\t    goto done;\n\tif (list_append_list(rettv->vval.v_list, l) == FAIL)\n\t    goto done;\n\tl = list_alloc();\n\tif (l == NULL)\n\t    goto done;\n\tif (list_append_list(rettv->vval.v_list, l) == FAIL)\n\t    goto done;\n\tl = list_alloc();\n\tif (l == NULL)\n\t    goto done;\n\tif (list_append_list(rettv->vval.v_list, l) == FAIL)\n\t    goto done;\n    }\n\n    fuzzy_match_in_list(argvars[0].vval.v_list, tv_get_string(&argvars[1]),\n\t    matchseq, key, &cb, retmatchpos, rettv->vval.v_list, max_matches);\n\ndone:\n    free_callback(&cb);\n}\n\n/*\n * \"matchfuzzy()\" function\n */\n    void\nf_matchfuzzy(typval_T *argvars, typval_T *rettv)\n{\n    do_fuzzymatch(argvars, rettv, FALSE);\n}\n\n/*\n * \"matchfuzzypos()\" function\n */\n    void\nf_matchfuzzypos(typval_T *argvars, typval_T *rettv)\n{\n    do_fuzzymatch(argvars, rettv, TRUE);\n}\n#endif\n\n/*\n * Same as fuzzy_match_item_compare() except for use with a string match\n */\n    static int\nfuzzy_match_str_compare(const void *s1, const void *s2)\n{\n    int\t\tv1 = ((fuzmatch_str_T *)s1)->score;\n    int\t\tv2 = ((fuzmatch_str_T *)s2)->score;\n    int\t\tidx1 = ((fuzmatch_str_T *)s1)->idx;\n    int\t\tidx2 = ((fuzmatch_str_T *)s2)->idx;\n\n    return v1 == v2 ? (idx1 - idx2) : v1 > v2 ? -1 : 1;\n}\n\n/*\n * Sort fuzzy matches by score\n */\n    static void\nfuzzy_match_str_sort(fuzmatch_str_T *fm, int sz)\n{\n    // Sort the list by the descending order of the match score\n    qsort((void *)fm, (size_t)sz, sizeof(fuzmatch_str_T),\n\t    fuzzy_match_str_compare);\n}\n\n/*\n * Same as fuzzy_match_item_compare() except for use with a function name\n * string match. <SNR> functions should be sorted to the end.\n */\n    static int\nfuzzy_match_func_compare(const void *s1, const void *s2)\n{\n    int\t\tv1 = ((fuzmatch_str_T *)s1)->score;\n    int\t\tv2 = ((fuzmatch_str_T *)s2)->score;\n    int\t\tidx1 = ((fuzmatch_str_T *)s1)->idx;\n    int\t\tidx2 = ((fuzmatch_str_T *)s2)->idx;\n    char_u\t*str1 = ((fuzmatch_str_T *)s1)->str;\n    char_u\t*str2 = ((fuzmatch_str_T *)s2)->str;\n\n    if (*str1 != '<' && *str2 == '<') return -1;\n    if (*str1 == '<' && *str2 != '<') return 1;\n    return v1 == v2 ? (idx1 - idx2) : v1 > v2 ? -1 : 1;\n}\n\n/*\n * Sort fuzzy matches of function names by score.\n * <SNR> functions should be sorted to the end.\n */\n    static void\nfuzzy_match_func_sort(fuzmatch_str_T *fm, int sz)\n{\n    // Sort the list by the descending order of the match score\n    qsort((void *)fm, (size_t)sz, sizeof(fuzmatch_str_T),\n\t\tfuzzy_match_func_compare);\n}\n\n/*\n * Fuzzy match 'pat' in 'str'. Returns 0 if there is no match. Otherwise,\n * returns the match score.\n */\n    int\nfuzzy_match_str(char_u *str, char_u *pat)\n{\n    int\t\tscore = 0;\n    int_u\tmatchpos[MAX_FUZZY_MATCHES];\n\n    if (str == NULL || pat == NULL)\n\treturn 0;\n\n    fuzzy_match(str, pat, TRUE, &score, matchpos,\n\t\t\t\tsizeof(matchpos) / sizeof(matchpos[0]));\n\n    return score;\n}\n\n/*\n * Free an array of fuzzy string matches \"fuzmatch[count]\".\n */\n    void\nfuzmatch_str_free(fuzmatch_str_T *fuzmatch, int count)\n{\n    int i;\n\n    if (fuzmatch == NULL)\n\treturn;\n    for (i = 0; i < count; ++i)\n\tvim_free(fuzmatch[i].str);\n    vim_free(fuzmatch);\n}\n\n/*\n * Copy a list of fuzzy matches into a string list after sorting the matches by\n * the fuzzy score. Frees the memory allocated for 'fuzmatch'.\n * Returns OK on success and FAIL on memory allocation failure.\n */\n    int\nfuzzymatches_to_strmatches(\n\tfuzmatch_str_T\t*fuzmatch,\n\tchar_u\t\t***matches,\n\tint\t\tcount,\n\tint\t\tfuncsort)\n{\n    int\t\ti;\n\n    if (count <= 0)\n\treturn OK;\n\n    *matches = ALLOC_MULT(char_u *, count);\n    if (*matches == NULL)\n    {\n\tfuzmatch_str_free(fuzmatch, count);\n\treturn FAIL;\n    }\n\n    // Sort the list by the descending order of the match score\n    if (funcsort)\n\tfuzzy_match_func_sort((void *)fuzmatch, (size_t)count);\n    else\n\tfuzzy_match_str_sort((void *)fuzmatch, (size_t)count);\n\n    for (i = 0; i < count; i++)\n\t(*matches)[i] = fuzmatch[i].str;\n    vim_free(fuzmatch);\n\n    return OK;\n}\n", "\" Tests for tagjump (tags and special searches)\n\nsource check.vim\nsource screendump.vim\n\n\" SEGV occurs in older versions.  (At least 7.4.1748 or older)\nfunc Test_ptag_with_notagstack()\n  CheckFeature quickfix\n\n  set notagstack\n  call assert_fails('ptag does_not_exist_tag_name', 'E433:')\n  set tagstack&vim\nendfunc\n\nfunc Test_ptjump()\n  CheckFeature quickfix\n\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"one\\tXfile\\t1\",\n        \\ \"three\\tXfile\\t3\",\n        \\ \"two\\tXfile\\t2\"],\n        \\ 'Xtags')\n  call writefile(['one', 'two', 'three'], 'Xfile')\n\n  %bw!\n  ptjump two\n  call assert_equal(2, winnr())\n  wincmd p\n  call assert_equal(1, &previewwindow)\n  call assert_equal('Xfile', expand(\"%:p:t\"))\n  call assert_equal(2, line('.'))\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, winnr())\n  close\n  call setline(1, ['one', 'two', 'three'])\n  exe \"normal 3G\\<C-W>g}\"\n  call assert_equal(2, winnr())\n  wincmd p\n  call assert_equal(1, &previewwindow)\n  call assert_equal('Xfile', expand(\"%:p:t\"))\n  call assert_equal(3, line('.'))\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, winnr())\n  close\n  exe \"normal 3G5\\<C-W>\\<C-G>}\"\n  wincmd p\n  call assert_equal(5, winheight(0))\n  close\n\n  call delete('Xtags')\n  call delete('Xfile')\n  set tags&\nendfunc\n\nfunc Test_cancel_ptjump()\n  CheckFeature quickfix\n\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"word\\tfile1\\tcmd1\",\n        \\ \"word\\tfile2\\tcmd2\"],\n        \\ 'Xtags')\n\n  only!\n  call feedkeys(\":ptjump word\\<CR>\\<CR>\", \"xt\")\n  help\n  call assert_equal(2, winnr('$'))\n\n  call delete('Xtags')\n  set tags&\n  quit\nendfunc\n\nfunc Test_static_tagjump()\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"one\\tXfile1\\t/^one/;\\\"\\tf\\tfile:\\tsignature:(void)\",\n        \\ \"word\\tXfile2\\tcmd2\"],\n        \\ 'Xtags')\n  new Xfile1\n  call setline(1, ['empty', 'one()', 'empty'])\n  write\n  tag one\n  call assert_equal(2, line('.'))\n\n  bwipe!\n  set tags&\n  call delete('Xtags')\n  call delete('Xfile1')\nendfunc\n\nfunc Test_duplicate_tagjump()\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"thesame\\tXfile1\\t1;\\\"\\td\\tfile:\",\n        \\ \"thesame\\tXfile1\\t2;\\\"\\td\\tfile:\",\n        \\ \"thesame\\tXfile1\\t3;\\\"\\td\\tfile:\",\n        \\ ],\n        \\ 'Xtags')\n  new Xfile1\n  call setline(1, ['thesame one', 'thesame two', 'thesame three'])\n  write\n  tag thesame\n  call assert_equal(1, line('.'))\n  tnext\n  call assert_equal(2, line('.'))\n  tnext\n  call assert_equal(3, line('.'))\n\n  bwipe!\n  set tags&\n  call delete('Xtags')\n  call delete('Xfile1')\nendfunc\n\nfunc Test_tagjump_switchbuf()\n  CheckFeature quickfix\n\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"second\\tXfile1\\t2\",\n        \\ \"third\\tXfile1\\t3\",],\n        \\ 'Xtags')\n  call writefile(['first', 'second', 'third'], 'Xfile1')\n\n  enew | only\n  set switchbuf=\n  stag second\n  call assert_equal(2, winnr('$'))\n  call assert_equal(2, line('.'))\n  stag third\n  call assert_equal(3, winnr('$'))\n  call assert_equal(3, line('.'))\n\n  enew | only\n  set switchbuf=useopen\n  stag second\n  call assert_equal(2, winnr('$'))\n  call assert_equal(2, line('.'))\n  stag third\n  call assert_equal(2, winnr('$'))\n  call assert_equal(3, line('.'))\n\n  enew | only\n  set switchbuf=usetab\n  tab stag second\n  call assert_equal(2, tabpagenr('$'))\n  call assert_equal(2, line('.'))\n  1tabnext | stag third\n  call assert_equal(2, tabpagenr('$'))\n  call assert_equal(3, line('.'))\n\n  tabclose!\n  enew | only\n  call delete('Xfile1')\n  call delete('Xtags')\n  set tags&\n  set switchbuf&vim\nendfunc\n\n\" Tests for [ CTRL-I and CTRL-W CTRL-I commands\nfunction Test_keyword_jump()\n  call writefile([\"#include Xinclude\", \"\",\n\t      \\ \"\",\n\t      \\ \"/* test text test tex start here\",\n\t      \\ \"\t\tsome text\",\n\t      \\ \"\t\ttest text\",\n\t      \\ \"\t\tstart OK if found this line\",\n\t      \\ \"\tstart found wrong line\",\n\t      \\ \"test text\"], 'Xtestfile')\n  call writefile([\"/* test text test tex start here\",\n\t      \\ \"\t\tsome text\",\n\t      \\ \"\t\ttest text\",\n\t      \\ \"\t\tstart OK if found this line\",\n\t      \\ \"\tstart found wrong line\",\n\t      \\ \"test text\"], 'Xinclude')\n  new Xtestfile\n  call cursor(1,1)\n  call search(\"start\")\n  exe \"normal! 5[\\<C-I>\"\n  call assert_equal(\"\t\tstart OK if found this line\", getline('.'))\n  call cursor(1,1)\n  call search(\"start\")\n  exe \"normal! 5\\<C-W>\\<C-I>\"\n  call assert_equal(\"\t\tstart OK if found this line\", getline('.'))\n\n  \" invalid tag search pattern\n  call assert_fails('tag /\\%(/', 'E426:')\n\n  enew! | only\n  call delete('Xtestfile')\n  call delete('Xinclude')\nendfunction\n\n\" Test for jumping to a tag with 'hidden' set, with symbolic link in path of\n\" tag.  This only works for Unix, because of the symbolic link.\nfunc Test_tag_symbolic()\n  CheckUnix\n\n  set hidden\n  call delete(\"Xtest.dir\", \"rf\")\n  call system(\"ln -s . Xtest.dir\")\n  \" Create a tags file with the current directory name inserted.\n  call writefile([\n        \\ \"SECTION_OFF\t\" . getcwd() . \"/Xtest.dir/Xtest.c\t/^#define  SECTION_OFF  3$/\",\n        \\ '',\n        \\ ], 'Xtags')\n  call writefile(['#define  SECTION_OFF  3',\n        \\ '#define  NUM_SECTIONS 3'], 'Xtest.c')\n\n  \" Try jumping to a tag, but with a path that contains a symbolic link.  When\n  \" wrong, this will give the ATTENTION message.  The next space will then be\n  \" eaten by hit-return, instead of moving the cursor to 'd'.\n  set tags=Xtags\n  enew!\n  call append(0, 'SECTION_OFF')\n  call cursor(1,1)\n  exe \"normal \\<C-]> \"\n  call assert_equal('Xtest.c', expand('%:t'))\n  call assert_equal(2, col('.'))\n\n  set hidden&\n  set tags&\n  enew!\n  call delete('Xtags')\n  call delete('Xtest.c')\n  call delete(\"Xtest.dir\", \"rf\")\n  %bwipe!\nendfunc\n\n\" Tests for tag search with !_TAG_FILE_ENCODING.\nfunc Test_tag_file_encoding()\n  if has('vms')\n    throw 'Skipped: does not work on VMS'\n  endif\n\n  if !has('iconv') || iconv(\"\\x82\\x60\", \"cp932\", \"utf-8\") != \"\\uff21\"\n    throw 'Skipped: iconv does not work'\n  endif\n\n  let save_enc = &encoding\n  set encoding=utf8\n\n  let content = ['text for tags1', 'abcdefghijklmnopqrs']\n  call writefile(content, 'Xtags1.txt')\n  let content = ['text for tags2', '\uff21\uff22\uff23']\n  call writefile(content, 'Xtags2.txt')\n  let content = ['text for tags3', '\uff21\uff22\uff23']\n  call writefile(content, 'Xtags3.txt')\n  let content = ['!_TAG_FILE_ENCODING\tutf-8\t//', 'abcdefghijklmnopqrs\tXtags1.txt\t/abcdefghijklmnopqrs']\n  call writefile(content, 'Xtags1')\n\n  \" case1:\n  new\n  set tags=Xtags1\n  tag abcdefghijklmnopqrs\n  call assert_equal('Xtags1.txt', expand('%:t'))\n  call assert_equal('abcdefghijklmnopqrs', getline('.'))\n  close\n\n  \" case2:\n  new\n  let content = ['!_TAG_FILE_ENCODING\tcp932\t//',\n        \\ \"\\x82`\\x82a\\x82b\tXtags2.txt\t/\\x82`\\x82a\\x82b\"]\n  call writefile(content, 'Xtags')\n  set tags=Xtags\n  tag /.\uff22\uff23\n  call assert_equal('Xtags2.txt', expand('%:t'))\n  call assert_equal('\uff21\uff22\uff23', getline('.'))\n  call delete('Xtags')\n  close\n\n  \" case3:\n  new\n  let contents = [\n      \\ \"!_TAG_FILE_SORTED\t1\t//\",\n      \\ \"!_TAG_FILE_ENCODING\tcp932\t//\"]\n  for i in range(1, 100)\n      call add(contents, 'abc' .. i\n            \\ .. \"\tXtags3.txt\t/\\x82`\\x82a\\x82b\")\n  endfor\n  call writefile(contents, 'Xtags')\n  set tags=Xtags\n  tag abc50\n  call assert_equal('Xtags3.txt', expand('%:t'))\n  call assert_equal('\uff21\uff22\uff23', getline('.'))\n  call delete('Xtags')\n  close\n\n  set tags&\n  let &encoding = save_enc\n  call delete('Xtags1.txt')\n  call delete('Xtags2.txt')\n  call delete('Xtags3.txt')\n  call delete('Xtags1')\nendfunc\n\n\" Test for emacs-style tags file (TAGS)\nfunc Test_tagjump_etags()\n  CheckFeature emacs_tags\n\n  call writefile([\n        \\ \"void foo() {}\",\n        \\ \"int main(int argc, char **argv)\",\n        \\ \"{\",\n        \\ \"\\tfoo();\",\n        \\ \"\\treturn 0;\",\n        \\ \"}\",\n        \\ ], 'Xmain.c')\n\n  call writefile([\n\t\\ \"\\x0c\",\n        \\ \"Xmain.c,64\",\n        \\ \"void foo() {}\\x7ffoo\\x011,0\",\n        \\ \"int main(int argc, char **argv)\\x7fmain\\x012,14\",\n\t\\ ], 'Xtags')\n  set tags=Xtags\n  ta foo\n  call assert_equal('void foo() {}', getline('.'))\n\n  \" Test for including another tags file\n  call writefile([\n        \\ \"\\x0c\",\n        \\ \"Xmain.c,64\",\n        \\ \"void foo() {}\\x7ffoo\\x011,0\",\n        \\ \"\\x0c\",\n        \\ \"Xnonexisting,include\",\n        \\ \"\\x0c\",\n        \\ \"Xtags2,include\"\n        \\ ], 'Xtags')\n  call writefile([\n        \\ \"\\x0c\",\n        \\ \"Xmain.c,64\",\n        \\ \"int main(int argc, char **argv)\\x7fmain\\x012,14\",\n        \\ ], 'Xtags2')\n  tag main\n  call assert_equal(2, line('.'))\n  call assert_fails('tag bar', 'E426:')\n\n  \" corrupted tag line\n  call writefile([\n        \\ \"\\x0c\",\n        \\ \"Xmain.c,8\",\n        \\ \"int main\"\n        \\ ], 'Xtags', 'b')\n  call assert_fails('tag foo', 'E426:')\n\n  \" invalid line number\n  call writefile([\n\t\\ \"\\x0c\",\n        \\ \"Xmain.c,64\",\n        \\ \"void foo() {}\\x7ffoo\\x0abc,0\",\n\t\\ ], 'Xtags')\n  call assert_fails('tag foo', 'E426:')\n\n  \" invalid tag name\n  call writefile([\n\t\\ \"\\x0c\",\n        \\ \"Xmain.c,64\",\n        \\ \";;;;\\x7f1,0\",\n\t\\ ], 'Xtags')\n  call assert_fails('tag foo', 'E431:')\n\n  \" end of file after a CTRL-L line\n  call writefile([\n\t\\ \"\\x0c\",\n        \\ \"Xmain.c,64\",\n        \\ \"void foo() {}\\x7ffoo\\x011,0\",\n\t\\ \"\\x0c\",\n\t\\ ], 'Xtags')\n  call assert_fails('tag main', 'E426:')\n\n  \" error in an included tags file\n  call writefile([\n        \\ \"\\x0c\",\n        \\ \"Xtags2,include\"\n        \\ ], 'Xtags')\n  call writefile([\n        \\ \"\\x0c\",\n        \\ \"Xmain.c,64\",\n        \\ \"void foo() {}\",\n        \\ ], 'Xtags2')\n  call assert_fails('tag foo', 'E431:')\n\n  call delete('Xtags')\n  call delete('Xtags2')\n  call delete('Xmain.c')\n  set tags&\n  bwipe!\nendfunc\n\n\" Test for getting and modifying the tag stack\nfunc Test_getsettagstack()\n  call writefile(['line1', 'line2', 'line3'], 'Xfile1')\n  call writefile(['line1', 'line2', 'line3'], 'Xfile2')\n  call writefile(['line1', 'line2', 'line3'], 'Xfile3')\n\n  enew | only\n  call settagstack(1, {'items' : []})\n  call assert_equal(0, gettagstack(1).length)\n  call assert_equal([], 1->gettagstack().items)\n  \" Error cases\n  call assert_equal({}, gettagstack(100))\n  call assert_equal(-1, settagstack(100, {'items' : []}))\n  call assert_fails('call settagstack(1, [1, 10])', 'E715:')\n  call assert_fails(\"call settagstack(1, {'items' : 10})\", 'E714:')\n  call assert_fails(\"call settagstack(1, {'items' : []}, 10)\", 'E928:')\n  call assert_fails(\"call settagstack(1, {'items' : []}, 'b')\", 'E962:')\n  call assert_equal(-1, settagstack(0, test_null_dict()))\n\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"one\\tXfile1\\t1\",\n        \\ \"three\\tXfile3\\t3\",\n        \\ \"two\\tXfile2\\t2\"],\n        \\ 'Xtags')\n\n  let stk = []\n  call add(stk, {'bufnr' : bufnr('%'), 'tagname' : 'one',\n\t\\ 'from' : [bufnr('%'), line('.'), col('.'), 0], 'matchnr' : 1})\n  tag one\n  call add(stk, {'bufnr' : bufnr('%'), 'tagname' : 'two',\n\t\\ 'from' : [bufnr('%'), line('.'), col('.'), 0], 'matchnr' : 1})\n  tag two\n  call add(stk, {'bufnr' : bufnr('%'), 'tagname' : 'three',\n\t\\ 'from' : [bufnr('%'), line('.'), col('.'), 0], 'matchnr' : 1})\n  tag three\n  call assert_equal(3, gettagstack(1).length)\n  call assert_equal(stk, gettagstack(1).items)\n  \" Check for default - current window\n  call assert_equal(3, gettagstack().length)\n  call assert_equal(stk, gettagstack().items)\n\n  \" Try to set current index to invalid values\n  call settagstack(1, {'curidx' : -1})\n  call assert_equal(1, gettagstack().curidx)\n  eval {'curidx' : 50}->settagstack(1)\n  call assert_equal(4, gettagstack().curidx)\n\n  \" Try pushing invalid items onto the stack\n  call settagstack(1, {'items' : []})\n  call settagstack(1, {'items' : [\"plate\"]}, 'a')\n  call assert_equal(0, gettagstack().length)\n  call assert_equal([], gettagstack().items)\n  call settagstack(1, {'items' : [{\"tagname\" : \"abc\"}]}, 'a')\n  call assert_equal(0, gettagstack().length)\n  call assert_equal([], gettagstack().items)\n  call settagstack(1, {'items' : [{\"from\" : 100}]}, 'a')\n  call assert_equal(0, gettagstack().length)\n  call assert_equal([], gettagstack().items)\n  call settagstack(1, {'items' : [{\"from\" : [2, 1, 0, 0]}]}, 'a')\n  call assert_equal(0, gettagstack().length)\n  call assert_equal([], gettagstack().items)\n\n  \" Push one item at a time to the stack\n  call settagstack(1, {'items' : []})\n  call settagstack(1, {'items' : [stk[0]]}, 'a')\n  call settagstack(1, {'items' : [stk[1]]}, 'a')\n  call settagstack(1, {'items' : [stk[2]]}, 'a')\n  call settagstack(1, {'curidx' : 4})\n  call assert_equal({'length' : 3, 'curidx' : 4, 'items' : stk},\n        \\ gettagstack(1))\n\n  \" Try pushing items onto a full stack\n  for i in range(7)\n    call settagstack(1, {'items' : stk}, 'a')\n  endfor\n  call assert_equal(20, gettagstack().length)\n  call settagstack(1,\n        \\ {'items' : [{'tagname' : 'abc', 'from' : [1, 10, 1, 0]}]}, 'a')\n  call assert_equal('abc', gettagstack().items[19].tagname)\n\n  \" truncate the tag stack\n  call settagstack(1,\n        \\ {'curidx' : 9,\n        \\  'items' : [{'tagname' : 'abc', 'from' : [1, 10, 1, 0]}]}, 't')\n  let t = gettagstack()\n  call assert_equal(9, t.length)\n  call assert_equal(10, t.curidx)\n\n  \" truncate the tag stack without pushing any new items\n  call settagstack(1, {'curidx' : 5}, 't')\n  let t = gettagstack()\n  call assert_equal(4, t.length)\n  call assert_equal(5, t.curidx)\n\n  \" truncate an empty tag stack and push new items\n  call settagstack(1, {'items' : []})\n  call settagstack(1,\n        \\ {'items' : [{'tagname' : 'abc', 'from' : [1, 10, 1, 0]}]}, 't')\n  let t = gettagstack()\n  call assert_equal(1, t.length)\n  call assert_equal(2, t.curidx)\n\n  \" Tag with multiple matches\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"two\\tXfile1\\t1\",\n        \\ \"two\\tXfile2\\t3\",\n        \\ \"two\\tXfile3\\t2\"],\n        \\ 'Xtags')\n  call settagstack(1, {'items' : []})\n  tag two\n  tnext\n  tnext\n  call assert_equal(1, gettagstack().length)\n  call assert_equal(3, gettagstack().items[0].matchnr)\n\n  \" Memory allocation failures\n  call test_alloc_fail(GetAllocId('tagstack_items'), 0, 0)\n  call assert_fails('call gettagstack()', 'E342:')\n  call test_alloc_fail(GetAllocId('tagstack_from'), 0, 0)\n  call assert_fails('call gettagstack()', 'E342:')\n  call test_alloc_fail(GetAllocId('tagstack_details'), 0, 0)\n  call assert_fails('call gettagstack()', 'E342:')\n\n  call settagstack(1, {'items' : []})\n  call delete('Xfile1')\n  call delete('Xfile2')\n  call delete('Xfile3')\n  call delete('Xtags')\n  set tags&\nendfunc\n\nfunc Test_tag_with_count()\n  call writefile([\n\t\\ 'test\tXtest.h\t/^void test();$/;\"\tp\ttyperef:typename:void\tsignature:()',\n\t\\ ], 'Xtags')\n  call writefile([\n\t\\ 'main\tXtest.c\t/^int main()$/;\"\tf\ttyperef:typename:int\tsignature:()',\n\t\\ 'test\tXtest.c\t/^void test()$/;\"\tf\ttyperef:typename:void\tsignature:()',\n\t\\ ], 'Ytags')\n  cal writefile([\n\t\\ 'int main()',\n\t\\ 'void test()',\n\t\\ ], 'Xtest.c')\n  cal writefile([\n\t\\ 'void test();',\n\t\\ ], 'Xtest.h')\n  set tags=Xtags,Ytags\n\n  new Xtest.c\n  let tl = taglist('test', 'Xtest.c')\n  call assert_equal(tl[0].filename, 'Xtest.c')\n  call assert_equal(tl[1].filename, 'Xtest.h')\n\n  tag test\n  call assert_equal(bufname('%'), 'Xtest.c')\n  1tag test\n  call assert_equal(bufname('%'), 'Xtest.c')\n  2tag test\n  call assert_equal(bufname('%'), 'Xtest.h')\n\n  set tags&\n  call delete('Xtags')\n  call delete('Ytags')\n  bwipe Xtest.h\n  bwipe Xtest.c\n  call delete('Xtest.h')\n  call delete('Xtest.c')\nendfunc\n\nfunc Test_tagnr_recall()\n  call writefile([\n\t\\ 'test\tXtest.h\t/^void test();$/;\"\tp',\n\t\\ 'main\tXtest.c\t/^int main()$/;\"\tf',\n\t\\ 'test\tXtest.c\t/^void test()$/;\"\tf',\n\t\\ ], 'Xtags')\n  cal writefile([\n\t\\ 'int main()',\n\t\\ 'void test()',\n\t\\ ], 'Xtest.c')\n  cal writefile([\n\t\\ 'void test();',\n\t\\ ], 'Xtest.h')\n  set tags=Xtags\n\n  new Xtest.c\n  let tl = taglist('test', 'Xtest.c')\n  call assert_equal(tl[0].filename, 'Xtest.c')\n  call assert_equal(tl[1].filename, 'Xtest.h')\n\n  2tag test\n  call assert_equal(bufname('%'), 'Xtest.h')\n  pop\n  call assert_equal(bufname('%'), 'Xtest.c')\n  tag\n  call assert_equal(bufname('%'), 'Xtest.h')\n\n  set tags&\n  call delete('Xtags')\n  bwipe Xtest.h\n  bwipe Xtest.c\n  call delete('Xtest.h')\n  call delete('Xtest.c')\nendfunc\n\nfunc Test_tag_line_toolong()\n  call writefile([\n\t\\ '1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678\tdjango/contrib/admin/templates/admin/edit_inline/stacked.html\t16;\"\tj\tline:16\tlanguage:HTML'\n\t\\ ], 'Xtags')\n  set tags=Xtags\n  let old_vbs = &verbose\n  set verbose=5\n  \" \":tjump\" should give \"tag not found\" not \"Format error in tags file\"\n  call assert_fails('tj /foo', 'E426:')\n  try\n    tj /foo\n  catch /^Vim\\%((\\a\\+)\\)\\=:E431/\n    call assert_report(v:exception)\n  catch /.*/\n  endtry\n  call assert_equal('Searching tags file Xtags', split(execute('messages'), '\\n')[-1])\n\n  call writefile([\n\t\\ '123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567\tdjango/contrib/admin/templates/admin/edit_inline/stacked.html\t16;\"\tj\tline:16\tlanguage:HTML'\n\t\\ ], 'Xtags')\n  call assert_fails('tj /foo', 'E426:')\n  try\n    tj /foo\n  catch /^Vim\\%((\\a\\+)\\)\\=:E431/\n    call assert_report(v:exception)\n  catch /.*/\n  endtry\n  call assert_equal('Searching tags file Xtags', split(execute('messages'), '\\n')[-1])\n\n  \" binary search works in file with long line\n  call writefile([\n        \\ 'asdfasfd\tnowhere\t16',\n\t\\ 'foobar\tXsomewhere\t3; \" 12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567',\n        \\ 'zasdfasfd\tnowhere\t16',\n\t\\ ], 'Xtags')\n  call writefile([\n        \\ 'one',\n        \\ 'two',\n        \\ 'trhee',\n        \\ 'four',\n        \\ ], 'Xsomewhere')\n  tag foobar\n  call assert_equal('Xsomewhere', expand('%'))\n  call assert_equal(3, getcurpos()[1])\n\n  \" expansion on command line works with long lines when &wildoptions contains\n  \" 'tagfile'\n  set wildoptions=tagfile\n  call writefile([\n\t\\ 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\tfile\t/^pattern$/;\"\tf'\n\t\\ ], 'Xtags')\n  call feedkeys(\":tag \\<Tab>\", 'tx')\n  \" Should not crash\n  call assert_true(v:true)\n\n  call delete('Xtags')\n  call delete('Xsomewhere')\n  set tags&\n  let &verbose = old_vbs\nendfunc\n\n\" Check that using :tselect does not run into the hit-enter prompt.\n\" Requires a terminal to trigger that prompt.\nfunc Test_tselect()\n  CheckScreendump\n\n  call writefile([\n\t\\ 'main\tXtest.h\t/^void test();$/;\"\tf',\n\t\\ 'main\tXtest.c\t/^int main()$/;\"\tf',\n\t\\ 'main\tXtest.x\t/^void test()$/;\"\tf',\n\t\\ ], 'Xtags')\n  cal writefile([\n\t\\ 'int main()',\n\t\\ 'void test()',\n\t\\ ], 'Xtest.c')\n\n  let lines =<< trim [SCRIPT]\n    set tags=Xtags\n  [SCRIPT]\n  call writefile(lines, 'XTest_tselect')\n  let buf = RunVimInTerminal('-S XTest_tselect', {'rows': 10, 'cols': 50})\n\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":tselect main\\<CR>2\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_tselect_1', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xtags')\n  call delete('Xtest.c')\n  call delete('XTest_tselect')\nendfunc\n\nfunc Test_tagline()\n  call writefile([\n\t\\ 'provision\tXtest.py\t/^    def provision(self, **kwargs):$/;\"\tm\tline:1\tlanguage:Python class:Foo',\n\t\\ 'provision\tXtest.py\t/^    def provision(self, **kwargs):$/;\"\tm\tline:3\tlanguage:Python class:Bar',\n\t\\], 'Xtags')\n  call writefile([\n\t\\ '    def provision(self, **kwargs):',\n\t\\ '        pass',\n\t\\ '    def provision(self, **kwargs):',\n\t\\ '        pass',\n\t\\], 'Xtest.py')\n\n  set tags=Xtags\n\n  1tag provision\n  call assert_equal(line('.'), 1)\n  2tag provision\n  call assert_equal(line('.'), 3)\n\n  call delete('Xtags')\n  call delete('Xtest.py')\n  set tags&\nendfunc\n\n\" Test for expanding environment variable in a tag file name\nfunc Test_tag_envvar()\n  call writefile([\"Func1\\t$FOO\\t/^Func1/\"], 'Xtags')\n  set tags=Xtags\n\n  let $FOO='TagTestEnv'\n\n  let caught_exception = v:false\n  try\n    tag Func1\n  catch /E429:/\n    call assert_match('E429:.*\"TagTestEnv\".*', v:exception)\n    let caught_exception = v:true\n  endtry\n  call assert_true(caught_exception)\n\n  set tags&\n  call delete('Xtags')\n  unlet $FOO\nendfunc\n\n\" Test for :ptag\nfunc Test_tag_preview()\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"second\\tXfile1\\t2\",\n        \\ \"third\\tXfile1\\t3\",],\n        \\ 'Xtags')\n  set tags=Xtags\n  call writefile(['first', 'second', 'third'], 'Xfile1')\n\n  enew | only\n  ptag third\n  call assert_equal(2, winnr())\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, getwinvar(1, '&previewwindow'))\n  call assert_equal(0, getwinvar(2, '&previewwindow'))\n  wincmd P\n  call assert_equal(3, line('.'))\n\n  \" jump to the tag again\n  wincmd w\n  ptag third\n  wincmd P\n  call assert_equal(3, line('.'))\n\n  \" jump to the newer tag\n  wincmd w\n  ptag\n  wincmd P\n  call assert_equal(3, line('.'))\n\n  \" close the preview window\n  pclose\n  call assert_equal(1, winnr('$'))\n\n  call delete('Xfile1')\n  call delete('Xtags')\n  set tags&\nendfunc\n\n\" Tests for guessing the tag location\nfunc Test_tag_guess()\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"func1\\tXfoo\\t/^int func1(int x)/\",\n        \\ \"func2\\tXfoo\\t/^int func2(int y)/\",\n        \\ \"func3\\tXfoo\\t/^func3/\",\n        \\ \"func4\\tXfoo\\t/^func4/\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n\n    int FUNC1  (int x) { }\n    int \n    func2   (int y) { }\n    int * func3 () { }\n\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  let v:statusmsg = ''\n  ta func1\n  call assert_match('E435:', v:statusmsg)\n  call assert_equal(2, line('.'))\n  let v:statusmsg = ''\n  ta func2\n  call assert_match('E435:', v:statusmsg)\n  call assert_equal(4, line('.'))\n  let v:statusmsg = ''\n  ta func3\n  call assert_match('E435:', v:statusmsg)\n  call assert_equal(5, line('.'))\n  call assert_fails('ta func4', 'E434:')\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\nendfunc\n\n\" Test for an unsorted tags file\nfunc Test_tag_sort()\n  let l = [\n        \\ \"first\\tXfoo\\t1\",\n        \\ \"ten\\tXfoo\\t3\",\n        \\ \"six\\tXfoo\\t2\"]\n  call writefile(l, 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int six() {}\n    int ten() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  call assert_fails('tag first', 'E432:')\n\n  \" When multiple tag files are not sorted, then message should be displayed\n  \" multiple times\n  call writefile(l, 'Xtags2')\n  set tags=Xtags,Xtags2\n  call assert_fails('tag first', ['E432:', 'E432:'])\n\n  call delete('Xtags')\n  call delete('Xtags2')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for an unsorted tags file\nfunc Test_tag_fold()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"!_TAG_FILE_SORTED\\t2\\t/0=unsorted, 1=sorted, 2=foldcase/\",\n        \\ \"first\\tXfoo\\t1\",\n        \\ \"second\\tXfoo\\t2\",\n        \\ \"third\\tXfoo\\t3\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int second() {}\n    int third() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  enew\n  tag second\n  call assert_equal('Xfoo', bufname(''))\n  call assert_equal(2, line('.'))\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for the :ltag command\nfunc Test_ltag()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo\\t1\",\n        \\ \"second\\tXfoo\\t/^int second() {}$/\",\n        \\ \"third\\tXfoo\\t3\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int second() {}\n    int third() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  enew\n  call setloclist(0, [], 'f')\n  ltag third\n  call assert_equal('Xfoo', bufname(''))\n  call assert_equal(3, line('.'))\n  call assert_equal([{'lnum': 3, 'end_lnum': 0, 'bufnr': bufnr('Xfoo'),\n        \\ 'col': 0, 'end_col': 0, 'pattern': '', 'valid': 1, 'vcol': 0,\n        \\ 'nr': 0, 'type': '', 'module': '', 'text': 'third'}], getloclist(0))\n\n  ltag second\n  call assert_equal(2, line('.'))\n  call assert_equal([{'lnum': 0, 'end_lnum': 0, 'bufnr': bufnr('Xfoo'),\n        \\ 'col': 0, 'end_col': 0, 'pattern': '^\\Vint second() {}\\$',\n        \\ 'valid': 1, 'vcol': 0, 'nr': 0, 'type': '', 'module': '',\n        \\ 'text': 'second'}], getloclist(0))\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for setting the last search pattern to the tag search pattern\n\" when cpoptions has 't'\nfunc Test_tag_last_search_pat()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo\\t/^int first() {}/\",\n        \\ \"second\\tXfoo\\t/^int second() {}/\",\n        \\ \"third\\tXfoo\\t/^int third() {}/\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int second() {}\n    int third() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  enew\n  let save_cpo = &cpo\n  set cpo+=t\n  let @/ = ''\n  tag second\n  call assert_equal('^int second() {}', @/)\n  let &cpo = save_cpo\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Tag stack tests\nfunc Test_tag_stack()\n  let l = []\n  for i in range(10, 31)\n    let l += [\"var\" .. i .. \"\\tXfoo\\t/^int var\" .. i .. \";$/\"]\n  endfor\n  call writefile(l, 'Xtags')\n  set tags=Xtags\n\n  let l = []\n  for i in range(10, 31)\n    let l += [\"int var\" .. i .. \";\"]\n  endfor\n  call writefile(l, 'Xfoo')\n\n  \" Jump to a tag when the tag stack is full. Oldest entry should be removed.\n  enew\n  for i in range(10, 30)\n    exe \"tag var\" .. i\n  endfor\n  let l = gettagstack()\n  call assert_equal(20, l.length)\n  call assert_equal('var11', l.items[0].tagname)\n  tag var31\n  let l = gettagstack()\n  call assert_equal('var12', l.items[0].tagname)\n  call assert_equal('var31', l.items[19].tagname)\n\n  \" Use tnext with a single match\n  call assert_fails('tnext', 'E427:')\n\n  \" Jump to newest entry from the top of the stack\n  call assert_fails('tag', 'E556:')\n\n  \" Pop with zero count from the top of the stack\n  call assert_fails('0pop', 'E556:')\n\n  \" Pop from an unsaved buffer\n  enew!\n  call append(1, \"sample text\")\n  call assert_fails('pop', 'E37:')\n  call assert_equal(21, gettagstack().curidx)\n  enew!\n\n  \" Pop all the entries in the tag stack\n  call assert_fails('30pop', 'E555:')\n\n  \" Pop with a count when already at the bottom of the stack\n  call assert_fails('exe \"normal 4\\<C-T>\"', 'E555:')\n  call assert_equal(1, gettagstack().curidx)\n\n  \" Jump to newest entry from the bottom of the stack with zero count\n  call assert_fails('0tag', 'E555:')\n\n  \" Pop the tag stack when it is empty\n  call settagstack(1, {'items' : []})\n  call assert_fails('pop', 'E73:')\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for browsing multiple matching tags\nfunc Test_tag_multimatch()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo\\t1\",\n        \\ \"first\\tXfoo\\t2\",\n        \\ \"first\\tXfoo\\t3\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int first() {}\n    int first() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  call settagstack(1, {'items' : []})\n  tag first\n  tlast\n  call assert_equal(3, line('.'))\n  call assert_fails('tnext', 'E428:')\n  tfirst\n  call assert_equal(1, line('.'))\n  call assert_fails('tprev', 'E425:')\n\n  tlast\n  call feedkeys(\"5\\<CR>\", 't')\n  tselect first\n  call assert_equal(2, gettagstack().curidx)\n\n  set ignorecase\n  tag FIRST\n  tnext\n  call assert_equal(2, line('.'))\n  tlast\n  tprev\n  call assert_equal(2, line('.'))\n  tNext\n  call assert_equal(1, line('.'))\n  set ignorecase&\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for previewing multiple matching tags\nfunc Test_preview_tag_multimatch()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo\\t1\",\n        \\ \"first\\tXfoo\\t2\",\n        \\ \"first\\tXfoo\\t3\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int first() {}\n    int first() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  enew | only\n  ptag first\n  ptlast\n  wincmd P\n  call assert_equal(3, line('.'))\n  wincmd w\n  call assert_fails('ptnext', 'E428:')\n  ptprev\n  wincmd P\n  call assert_equal(2, line('.'))\n  wincmd w\n  ptfirst\n  wincmd P\n  call assert_equal(1, line('.'))\n  wincmd w\n  call assert_fails('ptprev', 'E425:')\n  ptnext\n  wincmd P\n  call assert_equal(2, line('.'))\n  wincmd w\n  ptlast\n  call feedkeys(\"5\\<CR>\", 't')\n  ptselect first\n  wincmd P\n  call assert_equal(3, line('.'))\n\n  pclose\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for jumping to multiple matching tags across multiple :tags commands\nfunc Test_tnext_multimatch()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo1\\t1\",\n        \\ \"first\\tXfoo2\\t1\",\n        \\ \"first\\tXfoo3\\t1\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n  [CODE]\n  call writefile(code, 'Xfoo1')\n  call writefile(code, 'Xfoo2')\n  call writefile(code, 'Xfoo3')\n\n  tag first\n  tag first\n  pop\n  tnext\n  tnext\n  call assert_fails('tnext', 'E428:')\n\n  call delete('Xtags')\n  call delete('Xfoo1')\n  call delete('Xfoo2')\n  call delete('Xfoo3')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for jumping to multiple matching tags in non-existing files\nfunc Test_multimatch_non_existing_files()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo1\\t1\",\n        \\ \"first\\tXfoo2\\t1\",\n        \\ \"first\\tXfoo3\\t1\"],\n        \\ 'Xtags')\n  set tags=Xtags\n\n  call settagstack(1, {'items' : []})\n  call assert_fails('tag first', 'E429:')\n  call assert_equal(3, gettagstack().items[0].matchnr)\n\n  call delete('Xtags')\n  set tags&\n  %bwipe\nendfunc\n\nfunc Test_tselect_listing()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo\\t1\" .. ';\"' .. \"\\tv\\ttyperef:typename:int\\tfile:\",\n        \\ \"first\\tXfoo\\t2\" .. ';\"' .. \"\\tkind:v\\ttyperef:typename:char\\tfile:\"],\n        \\ 'Xtags')\n  set tags=Xtags\n\n  let code =<< trim [CODE]\n    static int first;\n    static char first;\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  call feedkeys(\"\\<CR>\", \"t\")\n  let l = split(execute(\"tselect first\"), \"\\n\")\n  let expected =<< [DATA]\n  # pri kind tag               file\n  1 FS  v    first             Xfoo\n               typeref:typename:int \n               1\n  2 FS  v    first             Xfoo\n               typeref:typename:char \n               2\nType number and <Enter> (q or empty cancels): \n[DATA]\n  call assert_equal(expected, l)\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for :isearch, :ilist, :ijump and :isplit commands\n\" Test for [i, ]i, [I, ]I, [ CTRL-I, ] CTRL-I and CTRL-W i commands\nfunc Test_inc_search()\n  new\n  call setline(1, ['1:foo', '2:foo', 'foo', '3:foo', '4:foo', '==='])\n  call cursor(3, 1)\n\n  \" Test for [i and ]i\n  call assert_equal('1:foo', execute('normal [i'))\n  call assert_equal('2:foo', execute('normal 2[i'))\n  call assert_fails('normal 3[i', 'E387:')\n  call assert_equal('3:foo', execute('normal ]i'))\n  call assert_equal('4:foo', execute('normal 2]i'))\n  call assert_fails('normal 3]i', 'E389:')\n  call assert_fails('normal G]i', 'E349:')\n  call assert_fails('normal [i', 'E349:')\n  call cursor(3, 1)\n\n  \" Test for :isearch\n  call assert_equal('1:foo', execute('isearch foo'))\n  call assert_equal('3:foo', execute('isearch 4 /foo/'))\n  call assert_fails('isearch 3 foo', 'E387:')\n  call assert_equal('3:foo', execute('+1,$isearch foo'))\n  call assert_fails('1,.-1isearch 3 foo', 'E389:')\n  call assert_fails('isearch bar', 'E389:')\n  call assert_fails('isearch /foo/3', 'E488:')\n\n  \" Test for [I and ]I\n  call assert_equal([\n        \\ '  1:    1 1:foo',\n        \\ '  2:    2 2:foo',\n        \\ '  3:    3 foo',\n        \\ '  4:    4 3:foo',\n        \\ '  5:    5 4:foo'], split(execute('normal [I'), \"\\n\"))\n  call assert_equal([\n        \\ '  1:    4 3:foo',\n        \\ '  2:    5 4:foo'], split(execute('normal ]I'), \"\\n\"))\n  call assert_fails('normal G]I', 'E349:')\n  call assert_fails('normal [I', 'E349:')\n  call cursor(3, 1)\n\n  \" Test for :ilist\n  call assert_equal([\n        \\ '  1:    1 1:foo',\n        \\ '  2:    2 2:foo',\n        \\ '  3:    3 foo',\n        \\ '  4:    4 3:foo',\n        \\ '  5:    5 4:foo'], split(execute('ilist foo'), \"\\n\"))\n  call assert_equal([\n        \\ '  1:    4 3:foo',\n        \\ '  2:    5 4:foo'], split(execute('+1,$ilist /foo/'), \"\\n\"))\n  call assert_fails('ilist bar', 'E389:')\n\n  \" Test for [ CTRL-I and ] CTRL-I\n  exe \"normal [\\t\"\n  call assert_equal([1, 3], [line('.'), col('.')])\n  exe \"normal 2j4[\\t\"\n  call assert_equal([4, 3], [line('.'), col('.')])\n  call assert_fails(\"normal k3[\\t\", 'E387:')\n  call assert_fails(\"normal 6[\\t\", 'E389:')\n  exe \"normal ]\\t\"\n  call assert_equal([4, 3], [line('.'), col('.')])\n  exe \"normal k2]\\t\"\n  call assert_equal([5, 3], [line('.'), col('.')])\n  call assert_fails(\"normal 2k3]\\t\", 'E389:')\n  call assert_fails(\"normal G[\\t\", 'E349:')\n  call assert_fails(\"normal ]\\t\", 'E349:')\n  call cursor(3, 1)\n\n  \" Test for :ijump\n  call cursor(3, 1)\n  ijump foo\n  call assert_equal([1, 3], [line('.'), col('.')])\n  call cursor(3, 1)\n  ijump 4 /foo/\n  call assert_equal([4, 3], [line('.'), col('.')])\n  call cursor(3, 1)\n  call assert_fails('ijump 3 foo', 'E387:')\n  +,$ijump 2 foo\n  call assert_equal([5, 3], [line('.'), col('.')])\n  call assert_fails('ijump bar', 'E389:')\n\n  \" Test for CTRL-W i\n  call cursor(3, 1)\n  wincmd i\n  call assert_equal([1, 3, 3], [line('.'), col('.'), winnr('$')])\n  close\n  5wincmd i\n  call assert_equal([5, 3, 3], [line('.'), col('.'), winnr('$')])\n  close\n  call assert_fails('3wincmd i', 'E387:')\n  call assert_fails('6wincmd i', 'E389:')\n  call assert_fails(\"normal G\\<C-W>i\", 'E349:')\n  call cursor(3, 1)\n\n  \" Test for :isplit\n  isplit foo\n  call assert_equal([1, 3, 3], [line('.'), col('.'), winnr('$')])\n  close\n  isplit 5 /foo/\n  call assert_equal([5, 3, 3], [line('.'), col('.'), winnr('$')])\n  close\n  call assert_fails('isplit 3 foo', 'E387:')\n  call assert_fails('isplit 6 foo', 'E389:')\n  call assert_fails('isplit bar', 'E389:')\n\n  close!\nendfunc\n\n\" Test for :dsearch, :dlist, :djump and :dsplit commands\n\" Test for [d, ]d, [D, ]D, [ CTRL-D, ] CTRL-D and CTRL-W d commands\nfunc Test_macro_search()\n  new\n  call setline(1, ['#define FOO 1', '#define FOO 2', '#define FOO 3',\n        \\ '#define FOO 4', '#define FOO 5'])\n  call cursor(3, 9)\n\n  \" Test for [d and ]d\n  call assert_equal('#define FOO 1', execute('normal [d'))\n  call assert_equal('#define FOO 2', execute('normal 2[d'))\n  call assert_fails('normal 3[d', 'E387:')\n  call assert_equal('#define FOO 4', execute('normal ]d'))\n  call assert_equal('#define FOO 5', execute('normal 2]d'))\n  call assert_fails('normal 3]d', 'E388:')\n\n  \" Test for :dsearch\n  call assert_equal('#define FOO 1', execute('dsearch FOO'))\n  call assert_equal('#define FOO 5', execute('dsearch 5 /FOO/'))\n  call assert_fails('dsearch 3 FOO', 'E387:')\n  call assert_equal('#define FOO 4', execute('+1,$dsearch FOO'))\n  call assert_fails('1,.-1dsearch 3 FOO', 'E388:')\n  call assert_fails('dsearch BAR', 'E388:')\n\n  \" Test for [D and ]D\n  call assert_equal([\n        \\ '  1:    1 #define FOO 1',\n        \\ '  2:    2 #define FOO 2',\n        \\ '  3:    3 #define FOO 3',\n        \\ '  4:    4 #define FOO 4',\n        \\ '  5:    5 #define FOO 5'], split(execute('normal [D'), \"\\n\"))\n  call assert_equal([\n        \\ '  1:    4 #define FOO 4',\n        \\ '  2:    5 #define FOO 5'], split(execute('normal ]D'), \"\\n\"))\n\n  \" Test for :dlist\n  call assert_equal([\n        \\ '  1:    1 #define FOO 1',\n        \\ '  2:    2 #define FOO 2',\n        \\ '  3:    3 #define FOO 3',\n        \\ '  4:    4 #define FOO 4',\n        \\ '  5:    5 #define FOO 5'], split(execute('dlist FOO'), \"\\n\"))\n  call assert_equal([\n        \\ '  1:    4 #define FOO 4',\n        \\ '  2:    5 #define FOO 5'], split(execute('+1,$dlist /FOO/'), \"\\n\"))\n  call assert_fails('dlist BAR', 'E388:')\n\n  \" Test for [ CTRL-D and ] CTRL-D\n  exe \"normal [\\<C-D>\"\n  call assert_equal([1, 9], [line('.'), col('.')])\n  exe \"normal 2j4[\\<C-D>\"\n  call assert_equal([4, 9], [line('.'), col('.')])\n  call assert_fails(\"normal k3[\\<C-D>\", 'E387:')\n  call assert_fails(\"normal 6[\\<C-D>\", 'E388:')\n  exe \"normal ]\\<C-D>\"\n  call assert_equal([4, 9], [line('.'), col('.')])\n  exe \"normal k2]\\<C-D>\"\n  call assert_equal([5, 9], [line('.'), col('.')])\n  call assert_fails(\"normal 2k3]\\<C-D>\", 'E388:')\n\n  \" Test for :djump\n  call cursor(3, 9)\n  djump FOO\n  call assert_equal([1, 9], [line('.'), col('.')])\n  call cursor(3, 9)\n  djump 4 /FOO/\n  call assert_equal([4, 9], [line('.'), col('.')])\n  call cursor(3, 9)\n  call assert_fails('djump 3 FOO', 'E387:')\n  +,$djump 2 FOO\n  call assert_equal([5, 9], [line('.'), col('.')])\n  call assert_fails('djump BAR', 'E388:')\n\n  \" Test for CTRL-W d\n  call cursor(3, 9)\n  wincmd d\n  call assert_equal([1, 9, 3], [line('.'), col('.'), winnr('$')])\n  close\n  5wincmd d\n  call assert_equal([5, 9, 3], [line('.'), col('.'), winnr('$')])\n  close\n  call assert_fails('3wincmd d', 'E387:')\n  call assert_fails('6wincmd d', 'E388:')\n  new\n  call assert_fails(\"normal \\<C-W>d\", 'E349:')\n  call assert_fails(\"normal \\<C-W>\\<C-D>\", 'E349:')\n  close\n\n  \" Test for :dsplit\n  dsplit FOO\n  call assert_equal([1, 9, 3], [line('.'), col('.'), winnr('$')])\n  close\n  dsplit 5 /FOO/\n  call assert_equal([5, 9, 3], [line('.'), col('.'), winnr('$')])\n  close\n  call assert_fails('dsplit 3 FOO', 'E387:')\n  call assert_fails('dsplit 6 FOO', 'E388:')\n  call assert_fails('dsplit BAR', 'E388:')\n\n  close!\nendfunc\n\nfunc Test_define_search()\n  \" this was accessing freed memory\n  new\n  call setline(1, ['first line', '', '#define something 0'])\n  sil norm o0\n  sil! norm \u0017\u0004\n  bwipe!\n\n  new somefile\n  call setline(1, ['first line', '', '#define something 0'])\n  sil norm 0o0\n  sil! norm ]d\n  bwipe!\nendfunc\n\n\" Test for [*, [/, ]* and ]/\nfunc Test_comment_search()\n  new\n  call setline(1, ['', '/*', ' *', ' *', ' */'])\n  normal! 4gg[/\n  call assert_equal([2, 1], [line('.'), col('.')])\n  normal! 3gg[*\n  call assert_equal([2, 1], [line('.'), col('.')])\n  normal! 3gg]/\n  call assert_equal([5, 3], [line('.'), col('.')])\n  normal! 3gg]*\n  call assert_equal([5, 3], [line('.'), col('.')])\n  %d\n  call setline(1, ['', '/*', ' *', ' *'])\n  call assert_beeps('normal! 3gg]/')\n  %d\n  call setline(1, ['', ' *', ' *', ' */'])\n  call assert_beeps('normal! 4gg[/')\n  %d\n  call setline(1, '        /* comment */')\n  normal! 15|[/\n  call assert_equal(9, col('.'))\n  normal! 15|]/\n  call assert_equal(21, col('.'))\n  call setline(1, '         comment */')\n  call assert_beeps('normal! 15|[/')\n  call setline(1, '        /* comment')\n  call assert_beeps('normal! 15|]/')\n  close!\nendfunc\n\n\" Test for the 'taglength' option\nfunc Test_tag_length()\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"tame\\tXfile1\\t1;\",\n        \\ \"tape\\tXfile2\\t1;\"], 'Xtags')\n  call writefile(['tame'], 'Xfile1')\n  call writefile(['tape'], 'Xfile2')\n\n  \" Jumping to the tag 'tape', should instead jump to 'tame'\n  new\n  set taglength=2\n  tag tape\n  call assert_equal('Xfile1', @%)\n  \" Tag search should jump to the right tag\n  enew\n  tag /^tape$\n  call assert_equal('Xfile2', @%)\n\n  call delete('Xtags')\n  call delete('Xfile1')\n  call delete('Xfile2')\n  set tags& taglength&\nendfunc\n\n\" Tests for errors in a tags file\nfunc Test_tagfile_errors()\n  set tags=Xtags\n\n  \" missing search pattern or line number for a tag\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"foo\\tXfile\\t\"], 'Xtags', 'b')\n  call writefile(['foo'], 'Xfile')\n\n  enew\n  tag foo\n  call assert_equal('', @%)\n  let caught_431 = v:false\n  try\n    eval taglist('.*')\n  catch /:E431:/\n    let caught_431 = v:true\n  endtry\n  call assert_equal(v:true, caught_431)\n\n  \" tag name and file name are not separated by a tab\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"foo Xfile 1\"], 'Xtags')\n  call assert_fails('tag foo', 'E431:')\n\n  \" file name and search pattern are not separated by a tab\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"foo\\tXfile 1;\"], 'Xtags')\n  call assert_fails('tag foo', 'E431:')\n\n  call delete('Xtags')\n  call delete('Xfile')\n  set tags&\nendfunc\n\n\" When :stag fails to open the file, should close the new window\nfunc Test_stag_close_window_on_error()\n  new | only\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"foo\\tXfile\\t1\"], 'Xtags')\n  call writefile(['foo'], 'Xfile')\n  call writefile([], '.Xfile.swp')\n  \" Remove the catch-all that runtest.vim adds\n  au! SwapExists\n  augroup StagTest\n    au!\n    autocmd SwapExists Xfile let v:swapchoice='q'\n  augroup END\n\n  stag foo\n  call assert_equal(1, winnr('$'))\n  call assert_equal('', @%)\n\n  augroup StagTest\n    au!\n  augroup END\n  call delete('Xfile')\n  call delete('.Xfile.swp')\n  set tags&\nendfunc\n\n\" Test for 'tagbsearch' (binary search)\nfunc Test_tagbsearch()\n  \" If a tags file header says the tags are sorted, but the tags are actually\n  \" unsorted, then binary search should fail and linear search should work.\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"!_TAG_FILE_SORTED\\t1\\t/0=unsorted, 1=sorted, 2=foldcase/\",\n        \\ \"third\\tXfoo\\t3\",\n        \\ \"second\\tXfoo\\t2\",\n        \\ \"first\\tXfoo\\t1\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int second() {}\n    int third() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  enew\n  set tagbsearch\n  call assert_fails('tag first', 'E426:')\n  call assert_equal('', bufname())\n  call assert_fails('tag second', 'E426:')\n  call assert_equal('', bufname())\n  tag third\n  call assert_equal('Xfoo', bufname())\n  call assert_equal(3, line('.'))\n  %bw!\n\n  set notagbsearch\n  tag first\n  call assert_equal('Xfoo', bufname())\n  call assert_equal(1, line('.'))\n  enew\n  tag second\n  call assert_equal('Xfoo', bufname())\n  call assert_equal(2, line('.'))\n  enew\n  tag third\n  call assert_equal('Xfoo', bufname())\n  call assert_equal(3, line('.'))\n  %bw!\n\n  \" If a tags file header says the tags are unsorted, but the tags are\n  \" actually sorted, then binary search should work.\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"!_TAG_FILE_SORTED\\t0\\t/0=unsorted, 1=sorted, 2=foldcase/\",\n        \\ \"first\\tXfoo\\t1\",\n        \\ \"second\\tXfoo\\t2\",\n        \\ \"third\\tXfoo\\t3\"],\n        \\ 'Xtags')\n\n  set tagbsearch\n  tag first\n  call assert_equal('Xfoo', bufname())\n  call assert_equal(1, line('.'))\n  enew\n  tag second\n  call assert_equal('Xfoo', bufname())\n  call assert_equal(2, line('.'))\n  enew\n  tag third\n  call assert_equal('Xfoo', bufname())\n  call assert_equal(3, line('.'))\n  %bw!\n\n  \" Binary search fails on EOF\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"!_TAG_FILE_SORTED\\t1\\t/0=unsorted, 1=sorted, 2=foldcase/\",\n        \\ \"bar\\tXfoo\\t1\",\n        \\ \"foo\\tXfoo\\t2\"],\n        \\ 'Xtags')\n  call assert_fails('tag bbb', 'E426:')\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags& tagbsearch&\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    5049,\n/**/\n    5048,\n/**/\n    5047,\n/**/\n    5046,\n/**/\n    5045,\n/**/\n    5044,\n/**/\n    5043,\n/**/\n    5042,\n/**/\n    5041,\n/**/\n    5040,\n/**/\n    5039,\n/**/\n    5038,\n/**/\n    5037,\n/**/\n    5036,\n/**/\n    5035,\n/**/\n    5034,\n/**/\n    5033,\n/**/\n    5032,\n/**/\n    5031,\n/**/\n    5030,\n/**/\n    5029,\n/**/\n    5028,\n/**/\n    5027,\n/**/\n    5026,\n/**/\n    5025,\n/**/\n    5024,\n/**/\n    5023,\n/**/\n    5022,\n/**/\n    5021,\n/**/\n    5020,\n/**/\n    5019,\n/**/\n    5018,\n/**/\n    5017,\n/**/\n    5016,\n/**/\n    5015,\n/**/\n    5014,\n/**/\n    5013,\n/**/\n    5012,\n/**/\n    5011,\n/**/\n    5010,\n/**/\n    5009,\n/**/\n    5008,\n/**/\n    5007,\n/**/\n    5006,\n/**/\n    5005,\n/**/\n    5004,\n/**/\n    5003,\n/**/\n    5002,\n/**/\n    5001,\n/**/\n    5000,\n/**/\n    4999,\n/**/\n    4998,\n/**/\n    4997,\n/**/\n    4996,\n/**/\n    4995,\n/**/\n    4994,\n/**/\n    4993,\n/**/\n    4992,\n/**/\n    4991,\n/**/\n    4990,\n/**/\n    4989,\n/**/\n    4988,\n/**/\n    4987,\n/**/\n    4986,\n/**/\n    4985,\n/**/\n    4984,\n/**/\n    4983,\n/**/\n    4982,\n/**/\n    4981,\n/**/\n    4980,\n/**/\n    4979,\n/**/\n    4978,\n/**/\n    4977,\n/**/\n    4976,\n/**/\n    4975,\n/**/\n    4974,\n/**/\n    4973,\n/**/\n    4972,\n/**/\n    4971,\n/**/\n    4970,\n/**/\n    4969,\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * search.c: code for normal mode searching commands\n */\n\n#include \"vim.h\"\n\n#ifdef FEAT_EVAL\nstatic void set_vv_searchforward(void);\nstatic int first_submatch(regmmatch_T *rp);\n#endif\n#ifdef FEAT_FIND_ID\nstatic void show_pat_in_path(char_u *, int,\n\t\t\t\t\t int, int, FILE *, linenr_T *, long);\n#endif\n\ntypedef struct searchstat\n{\n    int\t    cur;\t    // current position of found words\n    int\t    cnt;\t    // total count of found words\n    int\t    exact_match;    // TRUE if matched exactly on specified position\n    int\t    incomplete;\t    // 0: search was fully completed\n\t\t\t    // 1: recomputing was timed out\n\t\t\t    // 2: max count exceeded\n    int\t    last_maxcount;  // the max count of the last search\n} searchstat_T;\n\nstatic void cmdline_search_stat(int dirc, pos_T *pos, pos_T *cursor_pos, int show_top_bot_msg, char_u *msgbuf, int recompute, int maxcount, long timeout);\nstatic void update_search_stat(int dirc, pos_T *pos, pos_T *cursor_pos, searchstat_T *stat, int recompute, int maxcount, long timeout);\n\n#define SEARCH_STAT_DEF_TIMEOUT 40L\n#define SEARCH_STAT_DEF_MAX_COUNT 99\n#define SEARCH_STAT_BUF_LEN 12\n\n/*\n * This file contains various searching-related routines. These fall into\n * three groups:\n * 1. string searches (for /, ?, n, and N)\n * 2. character searches within a single line (for f, F, t, T, etc)\n * 3. \"other\" kinds of searches like the '%' command, and 'word' searches.\n */\n\n/*\n * String searches\n *\n * The string search functions are divided into two levels:\n * lowest:  searchit(); uses an pos_T for starting position and found match.\n * Highest: do_search(); uses curwin->w_cursor; calls searchit().\n *\n * The last search pattern is remembered for repeating the same search.\n * This pattern is shared between the :g, :s, ? and / commands.\n * This is in search_regcomp().\n *\n * The actual string matching is done using a heavily modified version of\n * Henry Spencer's regular expression library.  See regexp.c.\n */\n\n/*\n * Two search patterns are remembered: One for the :substitute command and\n * one for other searches.  last_idx points to the one that was used the last\n * time.\n */\nstatic spat_T spats[2] =\n{\n    {NULL, TRUE, FALSE, {'/', 0, 0, 0L}},\t// last used search pat\n    {NULL, TRUE, FALSE, {'/', 0, 0, 0L}}\t// last used substitute pat\n};\n\nstatic int last_idx = 0;\t// index in spats[] for RE_LAST\n\nstatic char_u lastc[2] = {NUL, NUL};\t// last character searched for\nstatic int lastcdir = FORWARD;\t\t// last direction of character search\nstatic int last_t_cmd = TRUE;\t\t// last search t_cmd\nstatic char_u\tlastc_bytes[MB_MAXBYTES + 1];\nstatic int\tlastc_bytelen = 1;\t// >1 for multi-byte char\n\n// copy of spats[], for keeping the search patterns while executing autocmds\nstatic spat_T\t    saved_spats[2];\nstatic char_u\t    *saved_mr_pattern = NULL;\n# ifdef FEAT_SEARCH_EXTRA\nstatic int\t    saved_spats_last_idx = 0;\nstatic int\t    saved_spats_no_hlsearch = 0;\n# endif\n\n// allocated copy of pattern used by search_regcomp()\nstatic char_u\t    *mr_pattern = NULL;\n\n#ifdef FEAT_FIND_ID\n/*\n * Type used by find_pattern_in_path() to remember which included files have\n * been searched already.\n */\ntypedef struct SearchedFile\n{\n    FILE\t*fp;\t\t// File pointer\n    char_u\t*name;\t\t// Full name of file\n    linenr_T\tlnum;\t\t// Line we were up to in file\n    int\t\tmatched;\t// Found a match in this file\n} SearchedFile;\n#endif\n\n/*\n * translate search pattern for vim_regcomp()\n *\n * pat_save == RE_SEARCH: save pat in spats[RE_SEARCH].pat (normal search cmd)\n * pat_save == RE_SUBST: save pat in spats[RE_SUBST].pat (:substitute command)\n * pat_save == RE_BOTH: save pat in both patterns (:global command)\n * pat_use  == RE_SEARCH: use previous search pattern if \"pat\" is NULL\n * pat_use  == RE_SUBST: use previous substitute pattern if \"pat\" is NULL\n * pat_use  == RE_LAST: use last used pattern if \"pat\" is NULL\n * options & SEARCH_HIS: put search string in history\n * options & SEARCH_KEEP: keep previous search pattern\n *\n * returns FAIL if failed, OK otherwise.\n */\n    int\nsearch_regcomp(\n    char_u\t*pat,\n    int\t\tpat_save,\n    int\t\tpat_use,\n    int\t\toptions,\n    regmmatch_T\t*regmatch)\t// return: pattern and ignore-case flag\n{\n    int\t\tmagic;\n    int\t\ti;\n\n    rc_did_emsg = FALSE;\n    magic = magic_isset();\n\n    /*\n     * If no pattern given, use a previously defined pattern.\n     */\n    if (pat == NULL || *pat == NUL)\n    {\n\tif (pat_use == RE_LAST)\n\t    i = last_idx;\n\telse\n\t    i = pat_use;\n\tif (spats[i].pat == NULL)\t// pattern was never defined\n\t{\n\t    if (pat_use == RE_SUBST)\n\t\temsg(_(e_no_previous_substitute_regular_expression));\n\t    else\n\t\temsg(_(e_no_previous_regular_expression));\n\t    rc_did_emsg = TRUE;\n\t    return FAIL;\n\t}\n\tpat = spats[i].pat;\n\tmagic = spats[i].magic;\n\tno_smartcase = spats[i].no_scs;\n    }\n    else if (options & SEARCH_HIS)\t// put new pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\n    vim_free(mr_pattern);\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's')\n\tmr_pattern = reverse_text(pat);\n    else\n#endif\n\tmr_pattern = vim_strsave(pat);\n\n    /*\n     * Save the currently used pattern in the appropriate place,\n     * unless the pattern should not be remembered.\n     */\n    if (!(options & SEARCH_KEEP)\n\t\t\t       && (cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n    {\n\t// search or global command\n\tif (pat_save == RE_SEARCH || pat_save == RE_BOTH)\n\t    save_re_pat(RE_SEARCH, pat, magic);\n\t// substitute or global command\n\tif (pat_save == RE_SUBST || pat_save == RE_BOTH)\n\t    save_re_pat(RE_SUBST, pat, magic);\n    }\n\n    regmatch->rmm_ic = ignorecase(pat);\n    regmatch->rmm_maxcol = 0;\n    regmatch->regprog = vim_regcomp(pat, magic ? RE_MAGIC : 0);\n    if (regmatch->regprog == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Get search pattern used by search_regcomp().\n */\n    char_u *\nget_search_pat(void)\n{\n    return mr_pattern;\n}\n\n#if defined(FEAT_RIGHTLEFT) || defined(PROTO)\n/*\n * Reverse text into allocated memory.\n * Returns the allocated string, NULL when out of memory.\n */\n    char_u *\nreverse_text(char_u *s)\n{\n    unsigned\tlen;\n    unsigned\ts_i, rev_i;\n    char_u\t*rev;\n\n    /*\n     * Reverse the pattern.\n     */\n    len = (unsigned)STRLEN(s);\n    rev = alloc(len + 1);\n    if (rev != NULL)\n    {\n\trev_i = len;\n\tfor (s_i = 0; s_i < len; ++s_i)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tint\tmb_len;\n\n\t\tmb_len = (*mb_ptr2len)(s + s_i);\n\t\trev_i -= mb_len;\n\t\tmch_memmove(rev + rev_i, s + s_i, mb_len);\n\t\ts_i += mb_len - 1;\n\t    }\n\t    else\n\t\trev[--rev_i] = s[s_i];\n\n\t}\n\trev[len] = NUL;\n    }\n    return rev;\n}\n#endif\n\n    void\nsave_re_pat(int idx, char_u *pat, int magic)\n{\n    if (spats[idx].pat != pat)\n    {\n\tvim_free(spats[idx].pat);\n\tspats[idx].pat = vim_strsave(pat);\n\tspats[idx].magic = magic;\n\tspats[idx].no_scs = no_smartcase;\n\tlast_idx = idx;\n#ifdef FEAT_SEARCH_EXTRA\n\t// If 'hlsearch' set and search pat changed: need redraw.\n\tif (p_hls)\n\t    redraw_all_later(SOME_VALID);\n\tset_no_hlsearch(FALSE);\n#endif\n    }\n}\n\n/*\n * Save the search patterns, so they can be restored later.\n * Used before/after executing autocommands and user functions.\n */\nstatic int save_level = 0;\n\n    void\nsave_search_patterns(void)\n{\n    if (save_level++ == 0)\n    {\n\tsaved_spats[0] = spats[0];\n\tif (spats[0].pat != NULL)\n\t    saved_spats[0].pat = vim_strsave(spats[0].pat);\n\tsaved_spats[1] = spats[1];\n\tif (spats[1].pat != NULL)\n\t    saved_spats[1].pat = vim_strsave(spats[1].pat);\n\tif (mr_pattern == NULL)\n\t    saved_mr_pattern = NULL;\n\telse\n\t    saved_mr_pattern = vim_strsave(mr_pattern);\n#ifdef FEAT_SEARCH_EXTRA\n\tsaved_spats_last_idx = last_idx;\n\tsaved_spats_no_hlsearch = no_hlsearch;\n#endif\n    }\n}\n\n    void\nrestore_search_patterns(void)\n{\n    if (--save_level == 0)\n    {\n\tvim_free(spats[0].pat);\n\tspats[0] = saved_spats[0];\n#if defined(FEAT_EVAL)\n\tset_vv_searchforward();\n#endif\n\tvim_free(spats[1].pat);\n\tspats[1] = saved_spats[1];\n\tvim_free(mr_pattern);\n\tmr_pattern = saved_mr_pattern;\n#ifdef FEAT_SEARCH_EXTRA\n\tlast_idx = saved_spats_last_idx;\n\tset_no_hlsearch(saved_spats_no_hlsearch);\n#endif\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_search_patterns(void)\n{\n    vim_free(spats[0].pat);\n    vim_free(spats[1].pat);\n    VIM_CLEAR(mr_pattern);\n}\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n// copy of spats[RE_SEARCH], for keeping the search patterns while incremental\n// searching\nstatic spat_T\t    saved_last_search_spat;\nstatic int\t    did_save_last_search_spat = 0;\nstatic int\t    saved_last_idx = 0;\nstatic int\t    saved_no_hlsearch = 0;\nstatic int\t    saved_search_match_endcol;\nstatic int\t    saved_search_match_lines;\n\n/*\n * Save and restore the search pattern for incremental highlight search\n * feature.\n *\n * It's similar to but different from save_search_patterns() and\n * restore_search_patterns(), because the search pattern must be restored when\n * canceling incremental searching even if it's called inside user functions.\n */\n    void\nsave_last_search_pattern(void)\n{\n    if (++did_save_last_search_spat != 1)\n\t// nested call, nothing to do\n\treturn;\n\n    saved_last_search_spat = spats[RE_SEARCH];\n    if (spats[RE_SEARCH].pat != NULL)\n\tsaved_last_search_spat.pat = vim_strsave(spats[RE_SEARCH].pat);\n    saved_last_idx = last_idx;\n    saved_no_hlsearch = no_hlsearch;\n}\n\n    void\nrestore_last_search_pattern(void)\n{\n    if (--did_save_last_search_spat > 0)\n\t// nested call, nothing to do\n\treturn;\n    if (did_save_last_search_spat != 0)\n    {\n\tiemsg(\"restore_last_search_pattern() called more often than save_last_search_pattern()\");\n\treturn;\n    }\n\n    vim_free(spats[RE_SEARCH].pat);\n    spats[RE_SEARCH] = saved_last_search_spat;\n    saved_last_search_spat.pat = NULL;\n# if defined(FEAT_EVAL)\n    set_vv_searchforward();\n# endif\n    last_idx = saved_last_idx;\n    set_no_hlsearch(saved_no_hlsearch);\n}\n\n/*\n * Save and restore the incsearch highlighting variables.\n * This is required so that calling searchcount() at does not invalidate the\n * incsearch highlighting.\n */\n    static void\nsave_incsearch_state(void)\n{\n    saved_search_match_endcol = search_match_endcol;\n    saved_search_match_lines  = search_match_lines;\n}\n\n    static void\nrestore_incsearch_state(void)\n{\n    search_match_endcol = saved_search_match_endcol;\n    search_match_lines  = saved_search_match_lines;\n}\n\n    char_u *\nlast_search_pattern(void)\n{\n    return spats[RE_SEARCH].pat;\n}\n#endif\n\n/*\n * Return TRUE when case should be ignored for search pattern \"pat\".\n * Uses the 'ignorecase' and 'smartcase' options.\n */\n    int\nignorecase(char_u *pat)\n{\n    return ignorecase_opt(pat, p_ic, p_scs);\n}\n\n/*\n * As ignorecase() put pass the \"ic\" and \"scs\" flags.\n */\n    int\nignorecase_opt(char_u *pat, int ic_in, int scs)\n{\n    int\t\tic = ic_in;\n\n    if (ic && !no_smartcase && scs\n\t\t\t    && !(ctrl_x_mode_not_default() && curbuf->b_p_inf))\n\tic = !pat_has_uppercase(pat);\n    no_smartcase = FALSE;\n\n    return ic;\n}\n\n/*\n * Return TRUE if pattern \"pat\" has an uppercase character.\n */\n    int\npat_has_uppercase(char_u *pat)\n{\n    char_u *p = pat;\n    magic_T magic_val = MAGIC_ON;\n\n    // get the magicness of the pattern\n    (void)skip_regexp_ex(pat, NUL, magic_isset(), NULL, NULL, &magic_val);\n\n    while (*p != NUL)\n    {\n\tint\t\tl;\n\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t{\n\t    if (enc_utf8 && utf_isupper(utf_ptr2char(p)))\n\t\treturn TRUE;\n\t    p += l;\n\t}\n\telse if (*p == '\\\\' && magic_val <= MAGIC_ON)\n\t{\n\t    if (p[1] == '_' && p[2] != NUL)  // skip \"\\_X\"\n\t\tp += 3;\n\t    else if (p[1] == '%' && p[2] != NUL)  // skip \"\\%X\"\n\t\tp += 3;\n\t    else if (p[1] != NUL)  // skip \"\\X\"\n\t\tp += 2;\n\t    else\n\t\tp += 1;\n\t}\n\telse if ((*p == '%' || *p == '_') && magic_val == MAGIC_ALL)\n\t{\n\t    if (p[1] != NUL)  // skip \"_X\" and %X\n\t\tp += 2;\n\t    else\n\t\tp++;\n\t}\n\telse if (MB_ISUPPER(*p))\n\t    return TRUE;\n\telse\n\t    ++p;\n    }\n    return FALSE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    char_u *\nlast_csearch(void)\n{\n    return lastc_bytes;\n}\n\n    int\nlast_csearch_forward(void)\n{\n    return lastcdir == FORWARD;\n}\n\n    int\nlast_csearch_until(void)\n{\n    return last_t_cmd == TRUE;\n}\n\n    void\nset_last_csearch(int c, char_u *s UNUSED, int len UNUSED)\n{\n    *lastc = c;\n    lastc_bytelen = len;\n    if (len)\n\tmemcpy(lastc_bytes, s, len);\n    else\n\tCLEAR_FIELD(lastc_bytes);\n}\n#endif\n\n    void\nset_csearch_direction(int cdir)\n{\n    lastcdir = cdir;\n}\n\n    void\nset_csearch_until(int t_cmd)\n{\n    last_t_cmd = t_cmd;\n}\n\n    char_u *\nlast_search_pat(void)\n{\n    return spats[last_idx].pat;\n}\n\n/*\n * Reset search direction to forward.  For \"gd\" and \"gD\" commands.\n */\n    void\nreset_search_dir(void)\n{\n    spats[0].off.dir = '/';\n#if defined(FEAT_EVAL)\n    set_vv_searchforward();\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_VIMINFO)\n/*\n * Set the last search pattern.  For \":let @/ =\" and viminfo.\n * Also set the saved search pattern, so that this works in an autocommand.\n */\n    void\nset_last_search_pat(\n    char_u\t*s,\n    int\t\tidx,\n    int\t\tmagic,\n    int\t\tsetlast)\n{\n    vim_free(spats[idx].pat);\n    // An empty string means that nothing should be matched.\n    if (*s == NUL)\n\tspats[idx].pat = NULL;\n    else\n\tspats[idx].pat = vim_strsave(s);\n    spats[idx].magic = magic;\n    spats[idx].no_scs = FALSE;\n    spats[idx].off.dir = '/';\n#if defined(FEAT_EVAL)\n    set_vv_searchforward();\n#endif\n    spats[idx].off.line = FALSE;\n    spats[idx].off.end = FALSE;\n    spats[idx].off.off = 0;\n    if (setlast)\n\tlast_idx = idx;\n    if (save_level)\n    {\n\tvim_free(saved_spats[idx].pat);\n\tsaved_spats[idx] = spats[0];\n\tif (spats[idx].pat == NULL)\n\t    saved_spats[idx].pat = NULL;\n\telse\n\t    saved_spats[idx].pat = vim_strsave(spats[idx].pat);\n# ifdef FEAT_SEARCH_EXTRA\n\tsaved_spats_last_idx = last_idx;\n# endif\n    }\n# ifdef FEAT_SEARCH_EXTRA\n    // If 'hlsearch' set and search pat changed: need redraw.\n    if (p_hls && idx == last_idx && !no_hlsearch)\n\tredraw_all_later(SOME_VALID);\n# endif\n}\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n/*\n * Get a regexp program for the last used search pattern.\n * This is used for highlighting all matches in a window.\n * Values returned in regmatch->regprog and regmatch->rmm_ic.\n */\n    void\nlast_pat_prog(regmmatch_T *regmatch)\n{\n    if (spats[last_idx].pat == NULL)\n    {\n\tregmatch->regprog = NULL;\n\treturn;\n    }\n    ++emsg_off;\t\t// So it doesn't beep if bad expr\n    (void)search_regcomp((char_u *)\"\", 0, last_idx, SEARCH_KEEP, regmatch);\n    --emsg_off;\n}\n#endif\n\n/*\n * Lowest level search function.\n * Search for 'count'th occurrence of pattern \"pat\" in direction \"dir\".\n * Start at position \"pos\" and return the found position in \"pos\".\n *\n * if (options & SEARCH_MSG) == 0 don't give any messages\n * if (options & SEARCH_MSG) == SEARCH_NFMSG don't give 'notfound' messages\n * if (options & SEARCH_MSG) == SEARCH_MSG give all messages\n * if (options & SEARCH_HIS) put search pattern in history\n * if (options & SEARCH_END) return position at end of match\n * if (options & SEARCH_START) accept match at pos itself\n * if (options & SEARCH_KEEP) keep previous search pattern\n * if (options & SEARCH_FOLD) match only once in a closed fold\n * if (options & SEARCH_PEEK) check for typed char, cancel search\n * if (options & SEARCH_COL) start at pos->col instead of zero\n *\n * Return FAIL (zero) for failure, non-zero for success.\n * When FEAT_EVAL is defined, returns the index of the first matching\n * subpattern plus one; one if there was none.\n */\n    int\nsearchit(\n    win_T\t*win,\t\t// window to search in; can be NULL for a\n\t\t\t\t// buffer without a window!\n    buf_T\t*buf,\n    pos_T\t*pos,\n    pos_T\t*end_pos,\t// set to end of the match, unless NULL\n    int\t\tdir,\n    char_u\t*pat,\n    long\tcount,\n    int\t\toptions,\n    int\t\tpat_use,\t// which pattern to use when \"pat\" is empty\n    searchit_arg_T *extra_arg)\t// optional extra arguments, can be NULL\n{\n    int\t\tfound;\n    linenr_T\tlnum;\t\t// no init to shut up Apollo cc\n    colnr_T\tcol;\n    regmmatch_T\tregmatch;\n    char_u\t*ptr;\n    colnr_T\tmatchcol;\n    lpos_T\tendpos;\n    lpos_T\tmatchpos;\n    int\t\tloop;\n    pos_T\tstart_pos;\n    int\t\tat_first_line;\n    int\t\textra_col;\n    int\t\tstart_char_len;\n    int\t\tmatch_ok;\n    long\tnmatched;\n    int\t\tsubmatch = 0;\n    int\t\tfirst_match = TRUE;\n    int\t\tcalled_emsg_before = called_emsg;\n#ifdef FEAT_SEARCH_EXTRA\n    int\t\tbreak_loop = FALSE;\n#endif\n    linenr_T\tstop_lnum = 0;\t// stop after this line number when != 0\n#ifdef FEAT_RELTIME\n    proftime_T\t*tm = NULL;\t// timeout limit or NULL\n    int\t\t*timed_out = NULL;  // set when timed out or NULL\n#endif\n\n    if (extra_arg != NULL)\n    {\n\tstop_lnum = extra_arg->sa_stop_lnum;\n#ifdef FEAT_RELTIME\n\ttm = extra_arg->sa_tm;\n\ttimed_out = &extra_arg->sa_timed_out;\n#endif\n    }\n\n    if (search_regcomp(pat, RE_SEARCH, pat_use,\n\t\t   (options & (SEARCH_HIS + SEARCH_KEEP)), &regmatch) == FAIL)\n    {\n\tif ((options & SEARCH_MSG) && !rc_did_emsg)\n\t    semsg(_(e_invalid_search_string_str), mr_pattern);\n\treturn FAIL;\n    }\n\n    /*\n     * find the string\n     */\n    do\t// loop for count\n    {\n\t// When not accepting a match at the start position set \"extra_col\" to\n\t// a non-zero value.  Don't do that when starting at MAXCOL, since\n\t// MAXCOL + 1 is zero.\n\tif (pos->col == MAXCOL)\n\t    start_char_len = 0;\n\t// Watch out for the \"col\" being MAXCOL - 2, used in a closed fold.\n\telse if (has_mbyte\n\t\t    && pos->lnum >= 1 && pos->lnum <= buf->b_ml.ml_line_count\n\t\t\t\t\t\t    && pos->col < MAXCOL - 2)\n\t{\n\t    ptr = ml_get_buf(buf, pos->lnum, FALSE);\n\t    if ((int)STRLEN(ptr) <= pos->col)\n\t\tstart_char_len = 1;\n\t    else\n\t\tstart_char_len = (*mb_ptr2len)(ptr + pos->col);\n\t}\n\telse\n\t    start_char_len = 1;\n\tif (dir == FORWARD)\n\t{\n\t    if (options & SEARCH_START)\n\t\textra_col = 0;\n\t    else\n\t\textra_col = start_char_len;\n\t}\n\telse\n\t{\n\t    if (options & SEARCH_START)\n\t\textra_col = start_char_len;\n\t    else\n\t\textra_col = 0;\n\t}\n\n\tstart_pos = *pos;\t// remember start pos for detecting no match\n\tfound = 0;\t\t// default: not found\n\tat_first_line = TRUE;\t// default: start in first line\n\tif (pos->lnum == 0)\t// correct lnum for when starting in line 0\n\t{\n\t    pos->lnum = 1;\n\t    pos->col = 0;\n\t    at_first_line = FALSE;  // not in first line now\n\t}\n\n\t/*\n\t * Start searching in current line, unless searching backwards and\n\t * we're in column 0.\n\t * If we are searching backwards, in column 0, and not including the\n\t * current position, gain some efficiency by skipping back a line.\n\t * Otherwise begin the search in the current line.\n\t */\n\tif (dir == BACKWARD && start_pos.col == 0\n\t\t\t\t\t     && (options & SEARCH_START) == 0)\n\t{\n\t    lnum = pos->lnum - 1;\n\t    at_first_line = FALSE;\n\t}\n\telse\n\t    lnum = pos->lnum;\n\n\tfor (loop = 0; loop <= 1; ++loop)   // loop twice if 'wrapscan' set\n\t{\n\t    for ( ; lnum > 0 && lnum <= buf->b_ml.ml_line_count;\n\t\t\t\t\t   lnum += dir, at_first_line = FALSE)\n\t    {\n\t\t// Stop after checking \"stop_lnum\", if it's set.\n\t\tif (stop_lnum != 0 && (dir == FORWARD\n\t\t\t\t       ? lnum > stop_lnum : lnum < stop_lnum))\n\t\t    break;\n#ifdef FEAT_RELTIME\n\t\t// Stop after passing the \"tm\" time limit.\n\t\tif (tm != NULL && profile_passed_limit(tm))\n\t\t    break;\n#endif\n\n\t\t/*\n\t\t * Look for a match somewhere in line \"lnum\".\n\t\t */\n\t\tcol = at_first_line && (options & SEARCH_COL) ? pos->col\n\t\t\t\t\t\t\t\t : (colnr_T)0;\n\t\tnmatched = vim_regexec_multi(&regmatch, win, buf,\n\t\t\t\t\t     lnum, col,\n#ifdef FEAT_RELTIME\n\t\t\t\t\t     tm, timed_out\n#else\n\t\t\t\t\t     NULL, NULL\n#endif\n\t\t\t\t\t\t      );\n\t\t// vim_regexec_multi() may clear \"regprog\"\n\t\tif (regmatch.regprog == NULL)\n\t\t    break;\n\t\t// Abort searching on an error (e.g., out of stack).\n\t\tif (called_emsg > called_emsg_before\n#ifdef FEAT_RELTIME\n\t\t\t|| (timed_out != NULL && *timed_out)\n#endif\n\t\t\t)\n\t\t    break;\n\t\tif (nmatched > 0)\n\t\t{\n\t\t    // match may actually be in another line when using \\zs\n\t\t    matchpos = regmatch.startpos[0];\n\t\t    endpos = regmatch.endpos[0];\n#ifdef FEAT_EVAL\n\t\t    submatch = first_submatch(&regmatch);\n#endif\n\t\t    // \"lnum\" may be past end of buffer for \"\\n\\zs\".\n\t\t    if (lnum + matchpos.lnum > buf->b_ml.ml_line_count)\n\t\t\tptr = (char_u *)\"\";\n\t\t    else\n\t\t\tptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);\n\n\t\t    /*\n\t\t     * Forward search in the first line: match should be after\n\t\t     * the start position. If not, continue at the end of the\n\t\t     * match (this is vi compatible) or on the next char.\n\t\t     */\n\t\t    if (dir == FORWARD && at_first_line)\n\t\t    {\n\t\t\tmatch_ok = TRUE;\n\t\t\t/*\n\t\t\t * When the match starts in a next line it's certainly\n\t\t\t * past the start position.\n\t\t\t * When match lands on a NUL the cursor will be put\n\t\t\t * one back afterwards, compare with that position,\n\t\t\t * otherwise \"/$\" will get stuck on end of line.\n\t\t\t */\n\t\t\twhile (matchpos.lnum == 0\n\t\t\t\t&& ((options & SEARCH_END) && first_match\n\t\t\t\t    ?  (nmatched == 1\n\t\t\t\t\t&& (int)endpos.col - 1\n\t\t\t\t\t     < (int)start_pos.col + extra_col)\n\t\t\t\t    : ((int)matchpos.col\n\t\t\t\t\t\t  - (ptr[matchpos.col] == NUL)\n\t\t\t\t\t    < (int)start_pos.col + extra_col)))\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * If vi-compatible searching, continue at the end\n\t\t\t     * of the match, otherwise continue one position\n\t\t\t     * forward.\n\t\t\t     */\n\t\t\t    if (vim_strchr(p_cpo, CPO_SEARCH) != NULL)\n\t\t\t    {\n\t\t\t\tif (nmatched > 1)\n\t\t\t\t{\n\t\t\t\t    // end is in next line, thus no match in\n\t\t\t\t    // this line\n\t\t\t\t    match_ok = FALSE;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\tmatchcol = endpos.col;\n\t\t\t\t// for empty match: advance one char\n\t\t\t\tif (matchcol == matchpos.col\n\t\t\t\t\t\t      && ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol +=\n\t\t\t\t\t  (*mb_ptr2len)(ptr + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tmatchcol = matchpos.col;\n\t\t\t\tif (ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol += (*mb_ptr2len)(ptr\n\t\t\t\t\t\t\t\t  + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    if (matchcol == 0 && (options & SEARCH_START))\n\t\t\t\tbreak;\n\t\t\t    if (ptr[matchcol] == NUL\n\t\t\t\t    || (nmatched = vim_regexec_multi(&regmatch,\n\t\t\t\t\t      win, buf, lnum + matchpos.lnum,\n\t\t\t\t\t      matchcol,\n#ifdef FEAT_RELTIME\n\t\t\t\t\t      tm, timed_out\n#else\n\t\t\t\t\t      NULL, NULL\n#endif\n\t\t\t\t\t      )) == 0)\n\t\t\t    {\n\t\t\t\tmatch_ok = FALSE;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    // vim_regexec_multi() may clear \"regprog\"\n\t\t\t    if (regmatch.regprog == NULL)\n\t\t\t\tbreak;\n\t\t\t    matchpos = regmatch.startpos[0];\n\t\t\t    endpos = regmatch.endpos[0];\n# ifdef FEAT_EVAL\n\t\t\t    submatch = first_submatch(&regmatch);\n# endif\n\n\t\t\t    // Need to get the line pointer again, a\n\t\t\t    // multi-line search may have made it invalid.\n\t\t\t    ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);\n\t\t\t}\n\t\t\tif (!match_ok)\n\t\t\t    continue;\n\t\t    }\n\t\t    if (dir == BACKWARD)\n\t\t    {\n\t\t\t/*\n\t\t\t * Now, if there are multiple matches on this line,\n\t\t\t * we have to get the last one. Or the last one before\n\t\t\t * the cursor, if we're on that line.\n\t\t\t * When putting the new cursor at the end, compare\n\t\t\t * relative to the end of the match.\n\t\t\t */\n\t\t\tmatch_ok = FALSE;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t    // Remember a position that is before the start\n\t\t\t    // position, we use it if it's the last match in\n\t\t\t    // the line.  Always accept a position after\n\t\t\t    // wrapping around.\n\t\t\t    if (loop\n\t\t\t\t|| ((options & SEARCH_END)\n\t\t\t\t    ? (lnum + regmatch.endpos[0].lnum\n\t\t\t\t\t\t\t      < start_pos.lnum\n\t\t\t\t\t|| (lnum + regmatch.endpos[0].lnum\n\t\t\t\t\t\t\t     == start_pos.lnum\n\t\t\t\t\t     && (int)regmatch.endpos[0].col - 1\n\t\t\t\t\t\t\t< (int)start_pos.col\n\t\t\t\t\t\t\t\t+ extra_col))\n\t\t\t\t    : (lnum + regmatch.startpos[0].lnum\n\t\t\t\t\t\t\t      < start_pos.lnum\n\t\t\t\t\t|| (lnum + regmatch.startpos[0].lnum\n\t\t\t\t\t\t\t     == start_pos.lnum\n\t\t\t\t\t     && (int)regmatch.startpos[0].col\n\t\t\t\t\t\t      < (int)start_pos.col\n\t\t\t\t\t\t\t      + extra_col))))\n\t\t\t    {\n\t\t\t\tmatch_ok = TRUE;\n\t\t\t\tmatchpos = regmatch.startpos[0];\n\t\t\t\tendpos = regmatch.endpos[0];\n# ifdef FEAT_EVAL\n\t\t\t\tsubmatch = first_submatch(&regmatch);\n# endif\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tbreak;\n\n\t\t\t    /*\n\t\t\t     * We found a valid match, now check if there is\n\t\t\t     * another one after it.\n\t\t\t     * If vi-compatible searching, continue at the end\n\t\t\t     * of the match, otherwise continue one position\n\t\t\t     * forward.\n\t\t\t     */\n\t\t\t    if (vim_strchr(p_cpo, CPO_SEARCH) != NULL)\n\t\t\t    {\n\t\t\t\tif (nmatched > 1)\n\t\t\t\t    break;\n\t\t\t\tmatchcol = endpos.col;\n\t\t\t\t// for empty match: advance one char\n\t\t\t\tif (matchcol == matchpos.col\n\t\t\t\t\t\t      && ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol +=\n\t\t\t\t\t  (*mb_ptr2len)(ptr + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t// Stop when the match is in a next line.\n\t\t\t\tif (matchpos.lnum > 0)\n\t\t\t\t    break;\n\t\t\t\tmatchcol = matchpos.col;\n\t\t\t\tif (ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol +=\n\t\t\t\t\t  (*mb_ptr2len)(ptr + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    if (ptr[matchcol] == NUL\n\t\t\t\t    || (nmatched = vim_regexec_multi(&regmatch,\n\t\t\t\t\t      win, buf, lnum + matchpos.lnum,\n\t\t\t\t\t      matchcol,\n#ifdef FEAT_RELTIME\n\t\t\t\t\t      tm, timed_out\n#else\n\t\t\t\t\t      NULL, NULL\n#endif\n\t\t\t\t\t    )) == 0)\n\t\t\t    {\n#ifdef FEAT_RELTIME\n\t\t\t\t// If the search timed out, we did find a match\n\t\t\t\t// but it might be the wrong one, so that's not\n\t\t\t\t// OK.\n\t\t\t\tif (timed_out != NULL && *timed_out)\n\t\t\t\t    match_ok = FALSE;\n#endif\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    // vim_regexec_multi() may clear \"regprog\"\n\t\t\t    if (regmatch.regprog == NULL)\n\t\t\t\tbreak;\n\n\t\t\t    // Need to get the line pointer again, a\n\t\t\t    // multi-line search may have made it invalid.\n\t\t\t    ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If there is only a match after the cursor, skip\n\t\t\t * this match.\n\t\t\t */\n\t\t\tif (!match_ok)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // With the SEARCH_END option move to the last character\n\t\t    // of the match.  Don't do it for an empty match, end\n\t\t    // should be same as start then.\n\t\t    if ((options & SEARCH_END) && !(options & SEARCH_NOOF)\n\t\t\t    && !(matchpos.lnum == endpos.lnum\n\t\t\t\t&& matchpos.col == endpos.col))\n\t\t    {\n\t\t\t// For a match in the first column, set the position\n\t\t\t// on the NUL in the previous line.\n\t\t\tpos->lnum = lnum + endpos.lnum;\n\t\t\tpos->col = endpos.col;\n\t\t\tif (endpos.col == 0)\n\t\t\t{\n\t\t\t    if (pos->lnum > 1)  // just in case\n\t\t\t    {\n\t\t\t\t--pos->lnum;\n\t\t\t\tpos->col = (colnr_T)STRLEN(ml_get_buf(buf,\n\t\t\t\t\t\t\t   pos->lnum, FALSE));\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    --pos->col;\n\t\t\t    if (has_mbyte\n\t\t\t\t    && pos->lnum <= buf->b_ml.ml_line_count)\n\t\t\t    {\n\t\t\t\tptr = ml_get_buf(buf, pos->lnum, FALSE);\n\t\t\t\tpos->col -= (*mb_head_off)(ptr, ptr + pos->col);\n\t\t\t    }\n\t\t\t}\n\t\t\tif (end_pos != NULL)\n\t\t\t{\n\t\t\t    end_pos->lnum = lnum + matchpos.lnum;\n\t\t\t    end_pos->col = matchpos.col;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tpos->lnum = lnum + matchpos.lnum;\n\t\t\tpos->col = matchpos.col;\n\t\t\tif (end_pos != NULL)\n\t\t\t{\n\t\t\t    end_pos->lnum = lnum + endpos.lnum;\n\t\t\t    end_pos->col = endpos.col;\n\t\t\t}\n\t\t    }\n\t\t    pos->coladd = 0;\n\t\t    if (end_pos != NULL)\n\t\t\tend_pos->coladd = 0;\n\t\t    found = 1;\n\t\t    first_match = FALSE;\n\n\t\t    // Set variables used for 'incsearch' highlighting.\n\t\t    search_match_lines = endpos.lnum - matchpos.lnum;\n\t\t    search_match_endcol = endpos.col;\n\t\t    break;\n\t\t}\n\t\tline_breakcheck();\t// stop if ctrl-C typed\n\t\tif (got_int)\n\t\t    break;\n\n#ifdef FEAT_SEARCH_EXTRA\n\t\t// Cancel searching if a character was typed.  Used for\n\t\t// 'incsearch'.  Don't check too often, that would slowdown\n\t\t// searching too much.\n\t\tif ((options & SEARCH_PEEK)\n\t\t\t&& ((lnum - pos->lnum) & 0x3f) == 0\n\t\t\t&& char_avail())\n\t\t{\n\t\t    break_loop = TRUE;\n\t\t    break;\n\t\t}\n#endif\n\n\t\tif (loop && lnum == start_pos.lnum)\n\t\t    break;\t    // if second loop, stop where started\n\t    }\n\t    at_first_line = FALSE;\n\n\t    // vim_regexec_multi() may clear \"regprog\"\n\t    if (regmatch.regprog == NULL)\n\t\tbreak;\n\n\t    /*\n\t     * Stop the search if wrapscan isn't set, \"stop_lnum\" is\n\t     * specified, after an interrupt, after a match and after looping\n\t     * twice.\n\t     */\n\t    if (!p_ws || stop_lnum != 0 || got_int\n\t\t\t\t\t    || called_emsg > called_emsg_before\n#ifdef FEAT_RELTIME\n\t\t\t\t|| (timed_out != NULL && *timed_out)\n#endif\n#ifdef FEAT_SEARCH_EXTRA\n\t\t\t\t|| break_loop\n#endif\n\t\t\t\t|| found || loop)\n\t\tbreak;\n\n\t    /*\n\t     * If 'wrapscan' is set we continue at the other end of the file.\n\t     * If 'shortmess' does not contain 's', we give a message.\n\t     * This message is also remembered in keep_msg for when the screen\n\t     * is redrawn. The keep_msg is cleared whenever another message is\n\t     * written.\n\t     */\n\t    if (dir == BACKWARD)    // start second loop at the other end\n\t\tlnum = buf->b_ml.ml_line_count;\n\t    else\n\t\tlnum = 1;\n\t    if (!shortmess(SHM_SEARCH) && (options & SEARCH_MSG))\n\t\tgive_warning((char_u *)_(dir == BACKWARD\n\t\t\t\t\t  ? top_bot_msg : bot_top_msg), TRUE);\n\t    if (extra_arg != NULL)\n\t\textra_arg->sa_wrapped = TRUE;\n\t}\n\tif (got_int || called_emsg > called_emsg_before\n#ifdef FEAT_RELTIME\n\t\t|| (timed_out != NULL && *timed_out)\n#endif\n#ifdef FEAT_SEARCH_EXTRA\n\t\t|| break_loop\n#endif\n\t\t)\n\t    break;\n    }\n    while (--count > 0 && found);   // stop after count matches or no match\n\n    vim_regfree(regmatch.regprog);\n\n    if (!found)\t\t    // did not find it\n    {\n\tif (got_int)\n\t    emsg(_(e_interrupted));\n\telse if ((options & SEARCH_MSG) == SEARCH_MSG)\n\t{\n\t    if (p_ws)\n\t\tsemsg(_(e_pattern_not_found_str), mr_pattern);\n\t    else if (lnum == 0)\n\t\tsemsg(_(e_search_hit_top_without_match_for_str), mr_pattern);\n\t    else\n\t\tsemsg(_(e_search_hit_bottom_without_match_for_str), mr_pattern);\n\t}\n\treturn FAIL;\n    }\n\n    // A pattern like \"\\n\\zs\" may go past the last line.\n    if (pos->lnum > buf->b_ml.ml_line_count)\n    {\n\tpos->lnum = buf->b_ml.ml_line_count;\n\tpos->col = (int)STRLEN(ml_get_buf(buf, pos->lnum, FALSE));\n\tif (pos->col > 0)\n\t    --pos->col;\n    }\n\n    return submatch + 1;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_PROTO)\n    void\nset_search_direction(int cdir)\n{\n    spats[0].off.dir = cdir;\n}\n\n    static void\nset_vv_searchforward(void)\n{\n    set_vim_var_nr(VV_SEARCHFORWARD, (long)(spats[0].off.dir == '/'));\n}\n\n/*\n * Return the number of the first subpat that matched.\n * Return zero if none of them matched.\n */\n    static int\nfirst_submatch(regmmatch_T *rp)\n{\n    int\t\tsubmatch;\n\n    for (submatch = 1; ; ++submatch)\n    {\n\tif (rp->startpos[submatch].lnum >= 0)\n\t    break;\n\tif (submatch == 9)\n\t{\n\t    submatch = 0;\n\t    break;\n\t}\n    }\n    return submatch;\n}\n#endif\n\n/*\n * Highest level string search function.\n * Search for the 'count'th occurrence of pattern 'pat' in direction 'dirc'\n *\t\t  If 'dirc' is 0: use previous dir.\n *    If 'pat' is NULL or empty : use previous string.\n *    If 'options & SEARCH_REV' : go in reverse of previous dir.\n *    If 'options & SEARCH_ECHO': echo the search command and handle options\n *    If 'options & SEARCH_MSG' : may give error message\n *    If 'options & SEARCH_OPT' : interpret optional flags\n *    If 'options & SEARCH_HIS' : put search pattern in history\n *    If 'options & SEARCH_NOOF': don't add offset to position\n *    If 'options & SEARCH_MARK': set previous context mark\n *    If 'options & SEARCH_KEEP': keep previous search pattern\n *    If 'options & SEARCH_START': accept match at curpos itself\n *    If 'options & SEARCH_PEEK': check for typed char, cancel search\n *\n * Careful: If spats[0].off.line == TRUE and spats[0].off.off == 0 this\n * makes the movement linewise without moving the match position.\n *\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\n    int\ndo_search(\n    oparg_T\t    *oap,\t// can be NULL\n    int\t\t    dirc,\t// '/' or '?'\n    int\t\t    search_delim, // the delimiter for the search, e.g. '%' in\n\t\t\t\t  // s%regex%replacement%\n    char_u\t    *pat,\n    long\t    count,\n    int\t\t    options,\n    searchit_arg_T  *sia)\t// optional arguments or NULL\n{\n    pos_T\t    pos;\t// position of the last match\n    char_u\t    *searchstr;\n    soffset_T\t    old_off;\n    int\t\t    retval;\t// Return value\n    char_u\t    *p;\n    long\t    c;\n    char_u\t    *dircp;\n    char_u\t    *strcopy = NULL;\n    char_u\t    *ps;\n    char_u\t    *msgbuf = NULL;\n    size_t\t    len;\n    int\t\t    has_offset = FALSE;\n\n    /*\n     * A line offset is not remembered, this is vi compatible.\n     */\n    if (spats[0].off.line && vim_strchr(p_cpo, CPO_LINEOFF) != NULL)\n    {\n\tspats[0].off.line = FALSE;\n\tspats[0].off.off = 0;\n    }\n\n    /*\n     * Save the values for when (options & SEARCH_KEEP) is used.\n     * (there is no \"if ()\" around this because gcc wants them initialized)\n     */\n    old_off = spats[0].off;\n\n    pos = curwin->w_cursor;\t// start searching at the cursor position\n\n    /*\n     * Find out the direction of the search.\n     */\n    if (dirc == 0)\n\tdirc = spats[0].off.dir;\n    else\n    {\n\tspats[0].off.dir = dirc;\n#if defined(FEAT_EVAL)\n\tset_vv_searchforward();\n#endif\n    }\n    if (options & SEARCH_REV)\n    {\n#ifdef MSWIN\n\t// There is a bug in the Visual C++ 2.2 compiler which means that\n\t// dirc always ends up being '/'\n\tdirc = (dirc == '/')  ?  '?'  :  '/';\n#else\n\tif (dirc == '/')\n\t    dirc = '?';\n\telse\n\t    dirc = '/';\n#endif\n    }\n\n#ifdef FEAT_FOLDING\n    // If the cursor is in a closed fold, don't find another match in the same\n    // fold.\n    if (dirc == '/')\n    {\n\tif (hasFolding(pos.lnum, NULL, &pos.lnum))\n\t    pos.col = MAXCOL - 2;\t// avoid overflow when adding 1\n    }\n    else\n    {\n\tif (hasFolding(pos.lnum, &pos.lnum, NULL))\n\t    pos.col = 0;\n    }\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n    /*\n     * Turn 'hlsearch' highlighting back on.\n     */\n    if (no_hlsearch && !(options & SEARCH_KEEP))\n    {\n\tredraw_all_later(SOME_VALID);\n\tset_no_hlsearch(FALSE);\n    }\n#endif\n\n    /*\n     * Repeat the search when pattern followed by ';', e.g. \"/foo/;?bar\".\n     */\n    for (;;)\n    {\n\tint\t\tshow_top_bot_msg = FALSE;\n\n\tsearchstr = pat;\n\tdircp = NULL;\n\t\t\t\t\t    // use previous pattern\n\tif (pat == NULL || *pat == NUL || *pat == search_delim)\n\t{\n\t    if (spats[RE_SEARCH].pat == NULL)\t    // no previous pattern\n\t    {\n\t\tsearchstr = spats[RE_SUBST].pat;\n\t\tif (searchstr == NULL)\n\t\t{\n\t\t    emsg(_(e_no_previous_regular_expression));\n\t\t    retval = 0;\n\t\t    goto end_do_search;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// make search_regcomp() use spats[RE_SEARCH].pat\n\t\tsearchstr = (char_u *)\"\";\n\t    }\n\t}\n\n\tif (pat != NULL && *pat != NUL)\t// look for (new) offset\n\t{\n\t    /*\n\t     * Find end of regular expression.\n\t     * If there is a matching '/' or '?', toss it.\n\t     */\n\t    ps = strcopy;\n\t    p = skip_regexp_ex(pat, search_delim, magic_isset(),\n\t\t\t\t\t\t\t&strcopy, NULL, NULL);\n\t    if (strcopy != ps)\n\t    {\n\t\t// made a copy of \"pat\" to change \"\\?\" to \"?\"\n\t\tsearchcmdlen += (int)(STRLEN(pat) - STRLEN(strcopy));\n\t\tpat = strcopy;\n\t\tsearchstr = strcopy;\n\t    }\n\t    if (*p == search_delim)\n\t    {\n\t\tdircp = p;\t// remember where we put the NUL\n\t\t*p++ = NUL;\n\t    }\n\t    spats[0].off.line = FALSE;\n\t    spats[0].off.end = FALSE;\n\t    spats[0].off.off = 0;\n\t    /*\n\t     * Check for a line offset or a character offset.\n\t     * For get_address (echo off) we don't check for a character\n\t     * offset, because it is meaningless and the 's' could be a\n\t     * substitute command.\n\t     */\n\t    if (*p == '+' || *p == '-' || VIM_ISDIGIT(*p))\n\t\tspats[0].off.line = TRUE;\n\t    else if ((options & SEARCH_OPT)\n\t\t\t\t      && (*p == 'e' || *p == 's' || *p == 'b'))\n\t    {\n\t\tif (*p == 'e')\t\t// end\n\t\t    spats[0].off.end = SEARCH_END;\n\t\t++p;\n\t    }\n\t    if (VIM_ISDIGIT(*p) || *p == '+' || *p == '-')  // got an offset\n\t    {\n\t\t\t\t\t    // 'nr' or '+nr' or '-nr'\n\t\tif (VIM_ISDIGIT(*p) || VIM_ISDIGIT(*(p + 1)))\n\t\t    spats[0].off.off = atol((char *)p);\n\t\telse if (*p == '-')\t    // single '-'\n\t\t    spats[0].off.off = -1;\n\t\telse\t\t\t    // single '+'\n\t\t    spats[0].off.off = 1;\n\t\t++p;\n\t\twhile (VIM_ISDIGIT(*p))\t    // skip number\n\t\t    ++p;\n\t    }\n\n\t    // compute length of search command for get_address()\n\t    searchcmdlen += (int)(p - pat);\n\n\t    pat = p;\t\t\t    // put pat after search command\n\t}\n\n\tif ((options & SEARCH_ECHO) && messaging()\n\t\t&& !msg_silent\n\t\t&& (!cmd_silent || !shortmess(SHM_SEARCHCOUNT)))\n\t{\n\t    char_u\t*trunc;\n\t    char_u\toff_buf[40];\n\t    size_t\toff_len = 0;\n\n\t    // Compute msg_row early.\n\t    msg_start();\n\n\t    // Get the offset, so we know how long it is.\n\t    if (!cmd_silent &&\n\t\t    (spats[0].off.line || spats[0].off.end || spats[0].off.off))\n\t    {\n\t\tp = off_buf;\n\t\t*p++ = dirc;\n\t\tif (spats[0].off.end)\n\t\t    *p++ = 'e';\n\t\telse if (!spats[0].off.line)\n\t\t    *p++ = 's';\n\t\tif (spats[0].off.off > 0 || spats[0].off.line)\n\t\t    *p++ = '+';\n\t\t*p = NUL;\n\t\tif (spats[0].off.off != 0 || spats[0].off.line)\n\t\t    sprintf((char *)p, \"%ld\", spats[0].off.off);\n\t\toff_len = STRLEN(off_buf);\n\t    }\n\n\t    if (*searchstr == NUL)\n\t\tp = spats[0].pat;\n\t    else\n\t\tp = searchstr;\n\n\t    if (!shortmess(SHM_SEARCHCOUNT) || cmd_silent)\n\t    {\n\t\t// Reserve enough space for the search pattern + offset +\n\t\t// search stat.  Use all the space available, so that the\n\t\t// search state is right aligned.  If there is not enough space\n\t\t// msg_strtrunc() will shorten in the middle.\n\t\tif (msg_scrolled != 0 && !cmd_silent)\n\t\t    // Use all the columns.\n\t\t    len = (int)(Rows - msg_row) * Columns - 1;\n\t\telse\n\t\t    // Use up to 'showcmd' column.\n\t\t    len = (int)(Rows - msg_row - 1) * Columns + sc_col - 1;\n\t\tif (len < STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3)\n\t\t    len = STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3;\n\t    }\n\t    else\n\t\t// Reserve enough space for the search pattern + offset.\n\t\tlen = STRLEN(p) + off_len + 3;\n\n\t    vim_free(msgbuf);\n\t    msgbuf = alloc(len);\n\t    if (msgbuf != NULL)\n\t    {\n\t\tvim_memset(msgbuf, ' ', len);\n\t\tmsgbuf[len - 1] = NUL;\n\t\t// do not fill the msgbuf buffer, if cmd_silent is set, leave it\n\t\t// empty for the search_stat feature.\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    msgbuf[0] = dirc;\n\n\t\t    if (enc_utf8 && utf_iscomposing(utf_ptr2char(p)))\n\t\t    {\n\t\t\t// Use a space to draw the composing char on.\n\t\t\tmsgbuf[1] = ' ';\n\t\t\tmch_memmove(msgbuf + 2, p, STRLEN(p));\n\t\t    }\n\t\t    else\n\t\t\tmch_memmove(msgbuf + 1, p, STRLEN(p));\n\t\t    if (off_len > 0)\n\t\t\tmch_memmove(msgbuf + STRLEN(p) + 1, off_buf, off_len);\n\n\t\t    trunc = msg_strtrunc(msgbuf, TRUE);\n\t\t    if (trunc != NULL)\n\t\t    {\n\t\t\tvim_free(msgbuf);\n\t\t\tmsgbuf = trunc;\n\t\t    }\n\n#ifdef FEAT_RIGHTLEFT\n\t\t    // The search pattern could be shown on the right in\n\t\t    // rightleft mode, but the 'ruler' and 'showcmd' area use\n\t\t    // it too, thus it would be blanked out again very soon.\n\t\t    // Show it on the left, but do reverse the text.\n\t\t    if (curwin->w_p_rl && *curwin->w_p_rlc == 's')\n\t\t    {\n\t\t\tchar_u *r;\n\t\t\tsize_t pat_len;\n\n\t\t\tr = reverse_text(msgbuf);\n\t\t\tif (r != NULL)\n\t\t\t{\n\t\t\t    vim_free(msgbuf);\n\t\t\t    msgbuf = r;\n\t\t\t    // move reversed text to beginning of buffer\n\t\t\t    while (*r != NUL && *r == ' ')\n\t\t\t\tr++;\n\t\t\t    pat_len = msgbuf + STRLEN(msgbuf) - r;\n\t\t\t    mch_memmove(msgbuf, r, pat_len);\n\t\t\t    // overwrite old text\n\t\t\t    if ((size_t)(r - msgbuf) >= pat_len)\n\t\t\t\tvim_memset(r, ' ', pat_len);\n\t\t\t    else\n\t\t\t\tvim_memset(msgbuf + pat_len, ' ', r - msgbuf);\n\t\t\t}\n\t\t    }\n#endif\n\t\t    msg_outtrans(msgbuf);\n\t\t    msg_clr_eos();\n\t\t    msg_check();\n\n\t\t    gotocmdline(FALSE);\n\t\t    out_flush();\n\t\t    msg_nowait = TRUE;\t    // don't wait for this message\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * If there is a character offset, subtract it from the current\n\t * position, so we don't get stuck at \"?pat?e+2\" or \"/pat/s-2\".\n\t * Skip this if pos.col is near MAXCOL (closed fold).\n\t * This is not done for a line offset, because then we would not be vi\n\t * compatible.\n\t */\n\tif (!spats[0].off.line && spats[0].off.off && pos.col < MAXCOL - 2)\n\t{\n\t    if (spats[0].off.off > 0)\n\t    {\n\t\tfor (c = spats[0].off.off; c; --c)\n\t\t    if (decl(&pos) == -1)\n\t\t\tbreak;\n\t\tif (c)\t\t\t// at start of buffer\n\t\t{\n\t\t    pos.lnum = 0;\t// allow lnum == 0 here\n\t\t    pos.col = MAXCOL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tfor (c = spats[0].off.off; c; ++c)\n\t\t    if (incl(&pos) == -1)\n\t\t\tbreak;\n\t\tif (c)\t\t\t// at end of buffer\n\t\t{\n\t\t    pos.lnum = curbuf->b_ml.ml_line_count + 1;\n\t\t    pos.col = 0;\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * The actual search.\n\t */\n\tc = searchit(curwin, curbuf, &pos, NULL,\n\t\t\t\t\t      dirc == '/' ? FORWARD : BACKWARD,\n\t\tsearchstr, count, spats[0].off.end + (options &\n\t\t       (SEARCH_KEEP + SEARCH_PEEK + SEARCH_HIS\n\t\t\t+ SEARCH_MSG + SEARCH_START\n\t\t\t+ ((pat != NULL && *pat == ';') ? 0 : SEARCH_NOOF))),\n\t\tRE_LAST, sia);\n\n\tif (dircp != NULL)\n\t    *dircp = search_delim; // restore second '/' or '?' for normal_cmd()\n\n\tif (!shortmess(SHM_SEARCH)\n\t\t&& ((dirc == '/' && LT_POS(pos, curwin->w_cursor))\n\t\t\t    || (dirc == '?' && LT_POS(curwin->w_cursor, pos))))\n\t    show_top_bot_msg = TRUE;\n\n\tif (c == FAIL)\n\t{\n\t    retval = 0;\n\t    goto end_do_search;\n\t}\n\tif (spats[0].off.end && oap != NULL)\n\t    oap->inclusive = TRUE;  // 'e' includes last character\n\n\tretval = 1;\t\t    // pattern found\n\n\t/*\n\t * Add character and/or line offset\n\t */\n\tif (!(options & SEARCH_NOOF) || (pat != NULL && *pat == ';'))\n\t{\n\t    pos_T org_pos = pos;\n\n\t    if (spats[0].off.line)\t// Add the offset to the line number.\n\t    {\n\t\tc = pos.lnum + spats[0].off.off;\n\t\tif (c < 1)\n\t\t    pos.lnum = 1;\n\t\telse if (c > curbuf->b_ml.ml_line_count)\n\t\t    pos.lnum = curbuf->b_ml.ml_line_count;\n\t\telse\n\t\t    pos.lnum = c;\n\t\tpos.col = 0;\n\n\t\tretval = 2;\t    // pattern found, line offset added\n\t    }\n\t    else if (pos.col < MAXCOL - 2)\t// just in case\n\t    {\n\t\t// to the right, check for end of file\n\t\tc = spats[0].off.off;\n\t\tif (c > 0)\n\t\t{\n\t\t    while (c-- > 0)\n\t\t\tif (incl(&pos) == -1)\n\t\t\t    break;\n\t\t}\n\t\t// to the left, check for start of file\n\t\telse\n\t\t{\n\t\t    while (c++ < 0)\n\t\t\tif (decl(&pos) == -1)\n\t\t\t    break;\n\t\t}\n\t    }\n\t    if (!EQUAL_POS(pos, org_pos))\n\t\thas_offset = TRUE;\n\t}\n\n\t// Show [1/15] if 'S' is not in 'shortmess'.\n\tif ((options & SEARCH_ECHO)\n\t\t&& messaging()\n\t\t&& !msg_silent\n\t\t&& c != FAIL\n\t\t&& !shortmess(SHM_SEARCHCOUNT)\n\t\t&& msgbuf != NULL)\n\t     cmdline_search_stat(dirc, &pos, &curwin->w_cursor,\n\t\t\t\tshow_top_bot_msg, msgbuf,\n\t\t\t\t(count != 1 || has_offset\n#ifdef FEAT_FOLDING\n\t\t\t\t || (!(fdo_flags & FDO_SEARCH)\n\t\t\t\t     && hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t   NULL, NULL))\n#endif\n\t\t\t\t),\n\t\t\t\tSEARCH_STAT_DEF_MAX_COUNT,\n\t\t\t\tSEARCH_STAT_DEF_TIMEOUT);\n\n\t/*\n\t * The search command can be followed by a ';' to do another search.\n\t * For example: \"/pat/;/foo/+3;?bar\"\n\t * This is like doing another search command, except:\n\t * - The remembered direction '/' or '?' is from the first search.\n\t * - When an error happens the cursor isn't moved at all.\n\t * Don't do this when called by get_address() (it handles ';' itself).\n\t */\n\tif (!(options & SEARCH_OPT) || pat == NULL || *pat != ';')\n\t    break;\n\n\tdirc = *++pat;\n\tsearch_delim = dirc;\n\tif (dirc != '?' && dirc != '/')\n\t{\n\t    retval = 0;\n\t    emsg(_(e_expected_question_or_slash_after_semicolon));\n\t    goto end_do_search;\n\t}\n\t++pat;\n    }\n\n    if (options & SEARCH_MARK)\n\tsetpcmark();\n    curwin->w_cursor = pos;\n    curwin->w_set_curswant = TRUE;\n\nend_do_search:\n    if ((options & SEARCH_KEEP) || (cmdmod.cmod_flags & CMOD_KEEPPATTERNS))\n\tspats[0].off = old_off;\n    vim_free(strcopy);\n    vim_free(msgbuf);\n\n    return retval;\n}\n\n/*\n * search_for_exact_line(buf, pos, dir, pat)\n *\n * Search for a line starting with the given pattern (ignoring leading\n * white-space), starting from pos and going in direction \"dir\". \"pos\" will\n * contain the position of the match found.    Blank lines match only if\n * ADDING is set.  If p_ic is set then the pattern must be in lowercase.\n * Return OK for success, or FAIL if no line found.\n */\n    int\nsearch_for_exact_line(\n    buf_T\t*buf,\n    pos_T\t*pos,\n    int\t\tdir,\n    char_u\t*pat)\n{\n    linenr_T\tstart = 0;\n    char_u\t*ptr;\n    char_u\t*p;\n\n    if (buf->b_ml.ml_line_count == 0)\n\treturn FAIL;\n    for (;;)\n    {\n\tpos->lnum += dir;\n\tif (pos->lnum < 1)\n\t{\n\t    if (p_ws)\n\t    {\n\t\tpos->lnum = buf->b_ml.ml_line_count;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(top_bot_msg), TRUE);\n\t    }\n\t    else\n\t    {\n\t\tpos->lnum = 1;\n\t\tbreak;\n\t    }\n\t}\n\telse if (pos->lnum > buf->b_ml.ml_line_count)\n\t{\n\t    if (p_ws)\n\t    {\n\t\tpos->lnum = 1;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(bot_top_msg), TRUE);\n\t    }\n\t    else\n\t    {\n\t\tpos->lnum = 1;\n\t\tbreak;\n\t    }\n\t}\n\tif (pos->lnum == start)\n\t    break;\n\tif (start == 0)\n\t    start = pos->lnum;\n\tptr = ml_get_buf(buf, pos->lnum, FALSE);\n\tp = skipwhite(ptr);\n\tpos->col = (colnr_T) (p - ptr);\n\n\t// when adding lines the matching line may be empty but it is not\n\t// ignored because we are interested in the next line -- Acevedo\n\tif (compl_status_adding() && !compl_status_sol())\n\t{\n\t    if ((p_ic ? MB_STRICMP(p, pat) : STRCMP(p, pat)) == 0)\n\t\treturn OK;\n\t}\n\telse if (*p != NUL)\t// ignore empty lines\n\t{\t// expanding lines or words\n\t    if ((p_ic ? MB_STRNICMP(p, pat, ins_compl_len())\n\t\t\t\t   : STRNCMP(p, pat, ins_compl_len())) == 0)\n\t\treturn OK;\n\t}\n    }\n    return FAIL;\n}\n\n/*\n * Character Searches\n */\n\n/*\n * Search for a character in a line.  If \"t_cmd\" is FALSE, move to the\n * position of the character, otherwise move to just before the char.\n * Do this \"cap->count1\" times.\n * Return FAIL or OK.\n */\n    int\nsearchc(cmdarg_T *cap, int t_cmd)\n{\n    int\t\t\tc = cap->nchar;\t// char to search for\n    int\t\t\tdir = cap->arg;\t// TRUE for searching forward\n    long\t\tcount = cap->count1;\t// repeat count\n    int\t\t\tcol;\n    char_u\t\t*p;\n    int\t\t\tlen;\n    int\t\t\tstop = TRUE;\n\n    if (c != NUL)\t// normal search: remember args for repeat\n    {\n\tif (!KeyStuffed)    // don't remember when redoing\n\t{\n\t    *lastc = c;\n\t    set_csearch_direction(dir);\n\t    set_csearch_until(t_cmd);\n\t    lastc_bytelen = (*mb_char2bytes)(c, lastc_bytes);\n\t    if (cap->ncharC1 != 0)\n\t    {\n\t\tlastc_bytelen += (*mb_char2bytes)(cap->ncharC1,\n\t\t\tlastc_bytes + lastc_bytelen);\n\t\tif (cap->ncharC2 != 0)\n\t\t    lastc_bytelen += (*mb_char2bytes)(cap->ncharC2,\n\t\t\t    lastc_bytes + lastc_bytelen);\n\t    }\n\t}\n    }\n    else\t\t// repeat previous search\n    {\n\tif (*lastc == NUL && lastc_bytelen == 1)\n\t    return FAIL;\n\tif (dir)\t// repeat in opposite direction\n\t    dir = -lastcdir;\n\telse\n\t    dir = lastcdir;\n\tt_cmd = last_t_cmd;\n\tc = *lastc;\n\t// For multi-byte re-use last lastc_bytes[] and lastc_bytelen.\n\n\t// Force a move of at least one char, so \";\" and \",\" will move the\n\t// cursor, even if the cursor is right in front of char we are looking\n\t// at.\n\tif (vim_strchr(p_cpo, CPO_SCOLON) == NULL && count == 1 && t_cmd)\n\t    stop = FALSE;\n    }\n\n    if (dir == BACKWARD)\n\tcap->oap->inclusive = FALSE;\n    else\n\tcap->oap->inclusive = TRUE;\n\n    p = ml_get_curline();\n    col = curwin->w_cursor.col;\n    len = (int)STRLEN(p);\n\n    while (count--)\n    {\n\tif (has_mbyte)\n\t{\n\t    for (;;)\n\t    {\n\t\tif (dir > 0)\n\t\t{\n\t\t    col += (*mb_ptr2len)(p + col);\n\t\t    if (col >= len)\n\t\t\treturn FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (col == 0)\n\t\t\treturn FAIL;\n\t\t    col -= (*mb_head_off)(p, p + col - 1) + 1;\n\t\t}\n\t\tif (lastc_bytelen == 1)\n\t\t{\n\t\t    if (p[col] == c && stop)\n\t\t\tbreak;\n\t\t}\n\t\telse if (STRNCMP(p + col, lastc_bytes, lastc_bytelen) == 0\n\t\t\t\t\t\t\t\t       && stop)\n\t\t    break;\n\t\tstop = TRUE;\n\t    }\n\t}\n\telse\n\t{\n\t    for (;;)\n\t    {\n\t\tif ((col += dir) < 0 || col >= len)\n\t\t    return FAIL;\n\t\tif (p[col] == c && stop)\n\t\t    break;\n\t\tstop = TRUE;\n\t    }\n\t}\n    }\n\n    if (t_cmd)\n    {\n\t// backup to before the character (possibly double-byte)\n\tcol -= dir;\n\tif (has_mbyte)\n\t{\n\t    if (dir < 0)\n\t\t// Landed on the search char which is lastc_bytelen long\n\t\tcol += lastc_bytelen - 1;\n\t    else\n\t\t// To previous char, which may be multi-byte.\n\t\tcol -= (*mb_head_off)(p, p + col);\n\t}\n    }\n    curwin->w_cursor.col = col;\n\n    return OK;\n}\n\n/*\n * \"Other\" Searches\n */\n\n/*\n * findmatch - find the matching paren or brace\n *\n * Improvement over vi: Braces inside quotes are ignored.\n */\n    pos_T *\nfindmatch(oparg_T *oap, int initc)\n{\n    return findmatchlimit(oap, initc, 0, 0);\n}\n\n/*\n * Return TRUE if the character before \"linep[col]\" equals \"ch\".\n * Return FALSE if \"col\" is zero.\n * Update \"*prevcol\" to the column of the previous character, unless \"prevcol\"\n * is NULL.\n * Handles multibyte string correctly.\n */\n    static int\ncheck_prevcol(\n    char_u\t*linep,\n    int\t\tcol,\n    int\t\tch,\n    int\t\t*prevcol)\n{\n    --col;\n    if (col > 0 && has_mbyte)\n\tcol -= (*mb_head_off)(linep, linep + col);\n    if (prevcol)\n\t*prevcol = col;\n    return (col >= 0 && linep[col] == ch) ? TRUE : FALSE;\n}\n\n/*\n * Raw string start is found at linep[startpos.col - 1].\n * Return TRUE if the matching end can be found between startpos and endpos.\n */\n    static int\nfind_rawstring_end(char_u *linep, pos_T *startpos, pos_T *endpos)\n{\n    char_u\t*p;\n    char_u\t*delim_copy;\n    size_t\tdelim_len;\n    linenr_T\tlnum;\n    int\t\tfound = FALSE;\n\n    for (p = linep + startpos->col + 1; *p && *p != '('; ++p)\n\t;\n    delim_len = (p - linep) - startpos->col - 1;\n    delim_copy = vim_strnsave(linep + startpos->col + 1, delim_len);\n    if (delim_copy == NULL)\n\treturn FALSE;\n    for (lnum = startpos->lnum; lnum <= endpos->lnum; ++lnum)\n    {\n\tchar_u *line = ml_get(lnum);\n\n\tfor (p = line + (lnum == startpos->lnum\n\t\t\t\t\t    ? startpos->col + 1 : 0); *p; ++p)\n\t{\n\t    if (lnum == endpos->lnum && (colnr_T)(p - line) >= endpos->col)\n\t\tbreak;\n\t    if (*p == ')' && STRNCMP(delim_copy, p + 1, delim_len) == 0\n\t\t\t  && p[delim_len + 1] == '\"')\n\t    {\n\t\tfound = TRUE;\n\t\tbreak;\n\t    }\n\t}\n\tif (found)\n\t    break;\n    }\n    vim_free(delim_copy);\n    return found;\n}\n\n/*\n * Check matchpairs option for \"*initc\".\n * If there is a match set \"*initc\" to the matching character and \"*findc\" to\n * the opposite character.  Set \"*backwards\" to the direction.\n * When \"switchit\" is TRUE swap the direction.\n */\n    static void\nfind_mps_values(\n    int\t    *initc,\n    int\t    *findc,\n    int\t    *backwards,\n    int\t    switchit)\n{\n    char_u\t*ptr;\n\n    ptr = curbuf->b_p_mps;\n    while (*ptr != NUL)\n    {\n\tif (has_mbyte)\n\t{\n\t    char_u *prev;\n\n\t    if (mb_ptr2char(ptr) == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *findc = *initc;\n\t\t    *initc = mb_ptr2char(ptr + mb_ptr2len(ptr) + 1);\n\t\t    *backwards = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    *findc = mb_ptr2char(ptr + mb_ptr2len(ptr) + 1);\n\t\t    *backwards = FALSE;\n\t\t}\n\t\treturn;\n\t    }\n\t    prev = ptr;\n\t    ptr += mb_ptr2len(ptr) + 1;\n\t    if (mb_ptr2char(ptr) == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *findc = *initc;\n\t\t    *initc = mb_ptr2char(prev);\n\t\t    *backwards = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    *findc = mb_ptr2char(prev);\n\t\t    *backwards = TRUE;\n\t\t}\n\t\treturn;\n\t    }\n\t    ptr += mb_ptr2len(ptr);\n\t}\n\telse\n\t{\n\t    if (*ptr == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *backwards = TRUE;\n\t\t    *findc = *initc;\n\t\t    *initc = ptr[2];\n\t\t}\n\t\telse\n\t\t{\n\t\t    *backwards = FALSE;\n\t\t    *findc = ptr[2];\n\t\t}\n\t\treturn;\n\t    }\n\t    ptr += 2;\n\t    if (*ptr == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *backwards = FALSE;\n\t\t    *findc = *initc;\n\t\t    *initc = ptr[-2];\n\t\t}\n\t\telse\n\t\t{\n\t\t    *backwards = TRUE;\n\t\t    *findc =  ptr[-2];\n\t\t}\n\t\treturn;\n\t    }\n\t    ++ptr;\n\t}\n\tif (*ptr == ',')\n\t    ++ptr;\n    }\n}\n\n/*\n * findmatchlimit -- find the matching paren or brace, if it exists within\n * maxtravel lines of the cursor.  A maxtravel of 0 means search until falling\n * off the edge of the file.\n *\n * \"initc\" is the character to find a match for.  NUL means to find the\n * character at or after the cursor. Special values:\n * '*'  look for C-style comment / *\n * '/'  look for C-style comment / *, ignoring comment-end\n * '#'  look for preprocessor directives\n * 'R'  look for raw string start: R\"delim(text)delim\" (only backwards)\n *\n * flags: FM_BACKWARD\tsearch backwards (when initc is '/', '*' or '#')\n *\t  FM_FORWARD\tsearch forwards (when initc is '/', '*' or '#')\n *\t  FM_BLOCKSTOP\tstop at start/end of block ({ or } in column 0)\n *\t  FM_SKIPCOMM\tskip comments (not implemented yet!)\n *\n * \"oap\" is only used to set oap->motion_type for a linewise motion, it can be\n * NULL\n */\n\n    pos_T *\nfindmatchlimit(\n    oparg_T\t*oap,\n    int\t\tinitc,\n    int\t\tflags,\n    int\t\tmaxtravel)\n{\n    static pos_T pos;\t\t\t// current search position\n    int\t\tfindc = 0;\t\t// matching brace\n    int\t\tc;\n    int\t\tcount = 0;\t\t// cumulative number of braces\n    int\t\tbackwards = FALSE;\t// init for gcc\n    int\t\traw_string = FALSE;\t// search for raw string\n    int\t\tinquote = FALSE;\t// TRUE when inside quotes\n    char_u\t*linep;\t\t\t// pointer to current line\n    char_u\t*ptr;\n    int\t\tdo_quotes;\t\t// check for quotes in current line\n    int\t\tat_start;\t\t// do_quotes value at start position\n    int\t\thash_dir = 0;\t\t// Direction searched for # things\n    int\t\tcomment_dir = 0;\t// Direction searched for comments\n    pos_T\tmatch_pos;\t\t// Where last slash-star was found\n    int\t\tstart_in_quotes;\t// start position is in quotes\n    int\t\ttraveled = 0;\t\t// how far we've searched so far\n    int\t\tignore_cend = FALSE;    // ignore comment end\n    int\t\tcpo_match;\t\t// vi compatible matching\n    int\t\tcpo_bsl;\t\t// don't recognize backslashes\n    int\t\tmatch_escaped = 0;\t// search for escaped match\n    int\t\tdir;\t\t\t// Direction to search\n    int\t\tcomment_col = MAXCOL;   // start of / / comment\n    int\t\tlispcomm = FALSE;\t// inside of Lisp-style comment\n    int\t\tlisp = curbuf->b_p_lisp; // engage Lisp-specific hacks ;)\n\n    pos = curwin->w_cursor;\n    pos.coladd = 0;\n    linep = ml_get(pos.lnum);\n\n    cpo_match = (vim_strchr(p_cpo, CPO_MATCH) != NULL);\n    cpo_bsl = (vim_strchr(p_cpo, CPO_MATCHBSL) != NULL);\n\n    // Direction to search when initc is '/', '*' or '#'\n    if (flags & FM_BACKWARD)\n\tdir = BACKWARD;\n    else if (flags & FM_FORWARD)\n\tdir = FORWARD;\n    else\n\tdir = 0;\n\n    /*\n     * if initc given, look in the table for the matching character\n     * '/' and '*' are special cases: look for start or end of comment.\n     * When '/' is used, we ignore running backwards into an star-slash, for\n     * \"[*\" command, we just want to find any comment.\n     */\n    if (initc == '/' || initc == '*' || initc == 'R')\n    {\n\tcomment_dir = dir;\n\tif (initc == '/')\n\t    ignore_cend = TRUE;\n\tbackwards = (dir == FORWARD) ? FALSE : TRUE;\n\traw_string = (initc == 'R');\n\tinitc = NUL;\n    }\n    else if (initc != '#' && initc != NUL)\n    {\n\tfind_mps_values(&initc, &findc, &backwards, TRUE);\n\tif (dir)\n\t    backwards = (dir == FORWARD) ? FALSE : TRUE;\n\tif (findc == NUL)\n\t    return NULL;\n    }\n    else\n    {\n\t/*\n\t * Either initc is '#', or no initc was given and we need to look\n\t * under the cursor.\n\t */\n\tif (initc == '#')\n\t{\n\t    hash_dir = dir;\n\t}\n\telse\n\t{\n\t    /*\n\t     * initc was not given, must look for something to match under\n\t     * or near the cursor.\n\t     * Only check for special things when 'cpo' doesn't have '%'.\n\t     */\n\t    if (!cpo_match)\n\t    {\n\t\t// Are we before or at #if, #else etc.?\n\t\tptr = skipwhite(linep);\n\t\tif (*ptr == '#' && pos.col <= (colnr_T)(ptr - linep))\n\t\t{\n\t\t    ptr = skipwhite(ptr + 1);\n\t\t    if (   STRNCMP(ptr, \"if\", 2) == 0\n\t\t\t|| STRNCMP(ptr, \"endif\", 5) == 0\n\t\t\t|| STRNCMP(ptr, \"el\", 2) == 0)\n\t\t\thash_dir = 1;\n\t\t}\n\n\t\t// Are we on a comment?\n\t\telse if (linep[pos.col] == '/')\n\t\t{\n\t\t    if (linep[pos.col + 1] == '*')\n\t\t    {\n\t\t\tcomment_dir = FORWARD;\n\t\t\tbackwards = FALSE;\n\t\t\tpos.col++;\n\t\t    }\n\t\t    else if (pos.col > 0 && linep[pos.col - 1] == '*')\n\t\t    {\n\t\t\tcomment_dir = BACKWARD;\n\t\t\tbackwards = TRUE;\n\t\t\tpos.col--;\n\t\t    }\n\t\t}\n\t\telse if (linep[pos.col] == '*')\n\t\t{\n\t\t    if (linep[pos.col + 1] == '/')\n\t\t    {\n\t\t\tcomment_dir = BACKWARD;\n\t\t\tbackwards = TRUE;\n\t\t    }\n\t\t    else if (pos.col > 0 && linep[pos.col - 1] == '/')\n\t\t    {\n\t\t\tcomment_dir = FORWARD;\n\t\t\tbackwards = FALSE;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * If we are not on a comment or the # at the start of a line, then\n\t     * look for brace anywhere on this line after the cursor.\n\t     */\n\t    if (!hash_dir && !comment_dir)\n\t    {\n\t\t/*\n\t\t * Find the brace under or after the cursor.\n\t\t * If beyond the end of the line, use the last character in\n\t\t * the line.\n\t\t */\n\t\tif (linep[pos.col] == NUL && pos.col)\n\t\t    --pos.col;\n\t\tfor (;;)\n\t\t{\n\t\t    initc = PTR2CHAR(linep + pos.col);\n\t\t    if (initc == NUL)\n\t\t\tbreak;\n\n\t\t    find_mps_values(&initc, &findc, &backwards, FALSE);\n\t\t    if (findc)\n\t\t\tbreak;\n\t\t    pos.col += mb_ptr2len(linep + pos.col);\n\t\t}\n\t\tif (!findc)\n\t\t{\n\t\t    // no brace in the line, maybe use \"  #if\" then\n\t\t    if (!cpo_match && *skipwhite(linep) == '#')\n\t\t\thash_dir = 1;\n\t\t    else\n\t\t\treturn NULL;\n\t\t}\n\t\telse if (!cpo_bsl)\n\t\t{\n\t\t    int col, bslcnt = 0;\n\n\t\t    // Set \"match_escaped\" if there are an odd number of\n\t\t    // backslashes.\n\t\t    for (col = pos.col; check_prevcol(linep, col, '\\\\', &col);)\n\t\t\tbslcnt++;\n\t\t    match_escaped = (bslcnt & 1);\n\t\t}\n\t    }\n\t}\n\tif (hash_dir)\n\t{\n\t    /*\n\t     * Look for matching #if, #else, #elif, or #endif\n\t     */\n\t    if (oap != NULL)\n\t\toap->motion_type = MLINE;   // Linewise for this case only\n\t    if (initc != '#')\n\t    {\n\t\tptr = skipwhite(skipwhite(linep) + 1);\n\t\tif (STRNCMP(ptr, \"if\", 2) == 0 || STRNCMP(ptr, \"el\", 2) == 0)\n\t\t    hash_dir = 1;\n\t\telse if (STRNCMP(ptr, \"endif\", 5) == 0)\n\t\t    hash_dir = -1;\n\t\telse\n\t\t    return NULL;\n\t    }\n\t    pos.col = 0;\n\t    while (!got_int)\n\t    {\n\t\tif (hash_dir > 0)\n\t\t{\n\t\t    if (pos.lnum == curbuf->b_ml.ml_line_count)\n\t\t\tbreak;\n\t\t}\n\t\telse if (pos.lnum == 1)\n\t\t    break;\n\t\tpos.lnum += hash_dir;\n\t\tlinep = ml_get(pos.lnum);\n\t\tline_breakcheck();\t// check for CTRL-C typed\n\t\tptr = skipwhite(linep);\n\t\tif (*ptr != '#')\n\t\t    continue;\n\t\tpos.col = (colnr_T) (ptr - linep);\n\t\tptr = skipwhite(ptr + 1);\n\t\tif (hash_dir > 0)\n\t\t{\n\t\t    if (STRNCMP(ptr, \"if\", 2) == 0)\n\t\t\tcount++;\n\t\t    else if (STRNCMP(ptr, \"el\", 2) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t    }\n\t\t    else if (STRNCMP(ptr, \"endif\", 5) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t\tcount--;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (STRNCMP(ptr, \"if\", 2) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t\tcount--;\n\t\t    }\n\t\t    else if (initc == '#' && STRNCMP(ptr, \"el\", 2) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t    }\n\t\t    else if (STRNCMP(ptr, \"endif\", 5) == 0)\n\t\t\tcount++;\n\t\t}\n\t    }\n\t    return NULL;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    // This is just guessing: when 'rightleft' is set, search for a matching\n    // paren/brace in the other direction.\n    if (curwin->w_p_rl && vim_strchr((char_u *)\"()[]{}<>\", initc) != NULL)\n\tbackwards = !backwards;\n#endif\n\n    do_quotes = -1;\n    start_in_quotes = MAYBE;\n    CLEAR_POS(&match_pos);\n\n    // backward search: Check if this line contains a single-line comment\n    if ((backwards && comment_dir) || lisp)\n\tcomment_col = check_linecomment(linep);\n    if (lisp && comment_col != MAXCOL && pos.col > (colnr_T)comment_col)\n\tlispcomm = TRUE;    // find match inside this comment\n\n    while (!got_int)\n    {\n\t/*\n\t * Go to the next position, forward or backward. We could use\n\t * inc() and dec() here, but that is much slower\n\t */\n\tif (backwards)\n\t{\n\t    // char to match is inside of comment, don't search outside\n\t    if (lispcomm && pos.col < (colnr_T)comment_col)\n\t\tbreak;\n\t    if (pos.col == 0)\t\t// at start of line, go to prev. one\n\t    {\n\t\tif (pos.lnum == 1)\t// start of file\n\t\t    break;\n\t\t--pos.lnum;\n\n\t\tif (maxtravel > 0 && ++traveled > maxtravel)\n\t\t    break;\n\n\t\tlinep = ml_get(pos.lnum);\n\t\tpos.col = (colnr_T)STRLEN(linep); // pos.col on trailing NUL\n\t\tdo_quotes = -1;\n\t\tline_breakcheck();\n\n\t\t// Check if this line contains a single-line comment\n\t\tif (comment_dir || lisp)\n\t\t    comment_col = check_linecomment(linep);\n\t\t// skip comment\n\t\tif (lisp && comment_col != MAXCOL)\n\t\t    pos.col = comment_col;\n\t    }\n\t    else\n\t    {\n\t\t--pos.col;\n\t\tif (has_mbyte)\n\t\t    pos.col -= (*mb_head_off)(linep, linep + pos.col);\n\t    }\n\t}\n\telse\t\t\t\t// forward search\n\t{\n\t    if (linep[pos.col] == NUL\n\t\t    // at end of line, go to next one\n\t\t    // For lisp don't search for match in comment\n\t\t    || (lisp && comment_col != MAXCOL\n\t\t\t\t\t   && pos.col == (colnr_T)comment_col))\n\t    {\n\t\tif (pos.lnum == curbuf->b_ml.ml_line_count  // end of file\n\t\t\t// line is exhausted and comment with it,\n\t\t\t// don't search for match in code\n\t\t\t || lispcomm)\n\t\t    break;\n\t\t++pos.lnum;\n\n\t\tif (maxtravel && traveled++ > maxtravel)\n\t\t    break;\n\n\t\tlinep = ml_get(pos.lnum);\n\t\tpos.col = 0;\n\t\tdo_quotes = -1;\n\t\tline_breakcheck();\n\t\tif (lisp)   // find comment pos in new line\n\t\t    comment_col = check_linecomment(linep);\n\t    }\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t    pos.col += (*mb_ptr2len)(linep + pos.col);\n\t\telse\n\t\t    ++pos.col;\n\t    }\n\t}\n\n\t/*\n\t * If FM_BLOCKSTOP given, stop at a '{' or '}' in column 0.\n\t */\n\tif (pos.col == 0 && (flags & FM_BLOCKSTOP)\n\t\t\t\t       && (linep[0] == '{' || linep[0] == '}'))\n\t{\n\t    if (linep[0] == findc && count == 0)\t// match!\n\t\treturn &pos;\n\t    break;\t\t\t\t\t// out of scope\n\t}\n\n\tif (comment_dir)\n\t{\n\t    // Note: comments do not nest, and we ignore quotes in them\n\t    // TODO: ignore comment brackets inside strings\n\t    if (comment_dir == FORWARD)\n\t    {\n\t\tif (linep[pos.col] == '*' && linep[pos.col + 1] == '/')\n\t\t{\n\t\t    pos.col++;\n\t\t    return &pos;\n\t\t}\n\t    }\n\t    else    // Searching backwards\n\t    {\n\t\t/*\n\t\t * A comment may contain / * or / /, it may also start or end\n\t\t * with / * /.\tIgnore a / * after / / and after *.\n\t\t */\n\t\tif (pos.col == 0)\n\t\t    continue;\n\t\telse if (raw_string)\n\t\t{\n\t\t    if (linep[pos.col - 1] == 'R'\n\t\t\t&& linep[pos.col] == '\"'\n\t\t\t&& vim_strchr(linep + pos.col + 1, '(') != NULL)\n\t\t    {\n\t\t\t// Possible start of raw string. Now that we have the\n\t\t\t// delimiter we can check if it ends before where we\n\t\t\t// started searching, or before the previously found\n\t\t\t// raw string start.\n\t\t\tif (!find_rawstring_end(linep, &pos,\n\t\t\t\t  count > 0 ? &match_pos : &curwin->w_cursor))\n\t\t\t{\n\t\t\t    count++;\n\t\t\t    match_pos = pos;\n\t\t\t    match_pos.col--;\n\t\t\t}\n\t\t\tlinep = ml_get(pos.lnum); // may have been released\n\t\t    }\n\t\t}\n\t\telse if (  linep[pos.col - 1] == '/'\n\t\t\t&& linep[pos.col] == '*'\n\t\t\t&& (pos.col == 1 || linep[pos.col - 2] != '*')\n\t\t\t&& (int)pos.col < comment_col)\n\t\t{\n\t\t    count++;\n\t\t    match_pos = pos;\n\t\t    match_pos.col--;\n\t\t}\n\t\telse if (linep[pos.col - 1] == '*' && linep[pos.col] == '/')\n\t\t{\n\t\t    if (count > 0)\n\t\t\tpos = match_pos;\n\t\t    else if (pos.col > 1 && linep[pos.col - 2] == '/'\n\t\t\t\t\t       && (int)pos.col <= comment_col)\n\t\t\tpos.col -= 2;\n\t\t    else if (ignore_cend)\n\t\t\tcontinue;\n\t\t    else\n\t\t\treturn NULL;\n\t\t    return &pos;\n\t\t}\n\t    }\n\t    continue;\n\t}\n\n\t/*\n\t * If smart matching ('cpoptions' does not contain '%'), braces inside\n\t * of quotes are ignored, but only if there is an even number of\n\t * quotes in the line.\n\t */\n\tif (cpo_match)\n\t    do_quotes = 0;\n\telse if (do_quotes == -1)\n\t{\n\t    /*\n\t     * Count the number of quotes in the line, skipping \\\" and '\"'.\n\t     * Watch out for \"\\\\\".\n\t     */\n\t    at_start = do_quotes;\n\t    for (ptr = linep; *ptr; ++ptr)\n\t    {\n\t\tif (ptr == linep + pos.col + backwards)\n\t\t    at_start = (do_quotes & 1);\n\t\tif (*ptr == '\"'\n\t\t\t&& (ptr == linep || ptr[-1] != '\\'' || ptr[1] != '\\''))\n\t\t    ++do_quotes;\n\t\tif (*ptr == '\\\\' && ptr[1] != NUL)\n\t\t    ++ptr;\n\t    }\n\t    do_quotes &= 1;\t    // result is 1 with even number of quotes\n\n\t    /*\n\t     * If we find an uneven count, check current line and previous\n\t     * one for a '\\' at the end.\n\t     */\n\t    if (!do_quotes)\n\t    {\n\t\tinquote = FALSE;\n\t\tif (ptr[-1] == '\\\\')\n\t\t{\n\t\t    do_quotes = 1;\n\t\t    if (start_in_quotes == MAYBE)\n\t\t    {\n\t\t\t// Do we need to use at_start here?\n\t\t\tinquote = TRUE;\n\t\t\tstart_in_quotes = TRUE;\n\t\t    }\n\t\t    else if (backwards)\n\t\t\tinquote = TRUE;\n\t\t}\n\t\tif (pos.lnum > 1)\n\t\t{\n\t\t    ptr = ml_get(pos.lnum - 1);\n\t\t    if (*ptr && *(ptr + STRLEN(ptr) - 1) == '\\\\')\n\t\t    {\n\t\t\tdo_quotes = 1;\n\t\t\tif (start_in_quotes == MAYBE)\n\t\t\t{\n\t\t\t    inquote = at_start;\n\t\t\t    if (inquote)\n\t\t\t\tstart_in_quotes = TRUE;\n\t\t\t}\n\t\t\telse if (!backwards)\n\t\t\t    inquote = TRUE;\n\t\t    }\n\n\t\t    // ml_get() only keeps one line, need to get linep again\n\t\t    linep = ml_get(pos.lnum);\n\t\t}\n\t    }\n\t}\n\tif (start_in_quotes == MAYBE)\n\t    start_in_quotes = FALSE;\n\n\t/*\n\t * If 'smartmatch' is set:\n\t *   Things inside quotes are ignored by setting 'inquote'.  If we\n\t *   find a quote without a preceding '\\' invert 'inquote'.  At the\n\t *   end of a line not ending in '\\' we reset 'inquote'.\n\t *\n\t *   In lines with an uneven number of quotes (without preceding '\\')\n\t *   we do not know which part to ignore. Therefore we only set\n\t *   inquote if the number of quotes in a line is even, unless this\n\t *   line or the previous one ends in a '\\'.  Complicated, isn't it?\n\t */\n\tc = PTR2CHAR(linep + pos.col);\n\tswitch (c)\n\t{\n\tcase NUL:\n\t    // at end of line without trailing backslash, reset inquote\n\t    if (pos.col == 0 || linep[pos.col - 1] != '\\\\')\n\t    {\n\t\tinquote = FALSE;\n\t\tstart_in_quotes = FALSE;\n\t    }\n\t    break;\n\n\tcase '\"':\n\t    // a quote that is preceded with an odd number of backslashes is\n\t    // ignored\n\t    if (do_quotes)\n\t    {\n\t\tint col;\n\n\t\tfor (col = pos.col - 1; col >= 0; --col)\n\t\t    if (linep[col] != '\\\\')\n\t\t\tbreak;\n\t\tif ((((int)pos.col - 1 - col) & 1) == 0)\n\t\t{\n\t\t    inquote = !inquote;\n\t\t    start_in_quotes = FALSE;\n\t\t}\n\t    }\n\t    break;\n\n\t/*\n\t * If smart matching ('cpoptions' does not contain '%'):\n\t *   Skip things in single quotes: 'x' or '\\x'.  Be careful for single\n\t *   single quotes, eg jon's.  Things like '\\233' or '\\x3f' are not\n\t *   skipped, there is never a brace in them.\n\t *   Ignore this when finding matches for `'.\n\t */\n\tcase '\\'':\n\t    if (!cpo_match && initc != '\\'' && findc != '\\'')\n\t    {\n\t\tif (backwards)\n\t\t{\n\t\t    if (pos.col > 1)\n\t\t    {\n\t\t\tif (linep[pos.col - 2] == '\\'')\n\t\t\t{\n\t\t\t    pos.col -= 2;\n\t\t\t    break;\n\t\t\t}\n\t\t\telse if (linep[pos.col - 2] == '\\\\'\n\t\t\t\t  && pos.col > 2 && linep[pos.col - 3] == '\\'')\n\t\t\t{\n\t\t\t    pos.col -= 3;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (linep[pos.col + 1])\t// forward search\n\t\t{\n\t\t    if (linep[pos.col + 1] == '\\\\'\n\t\t\t   && linep[pos.col + 2] && linep[pos.col + 3] == '\\'')\n\t\t    {\n\t\t\tpos.col += 3;\n\t\t\tbreak;\n\t\t    }\n\t\t    else if (linep[pos.col + 2] == '\\'')\n\t\t    {\n\t\t\tpos.col += 2;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    // FALLTHROUGH\n\n\tdefault:\n\t    /*\n\t     * For Lisp skip over backslashed (), {} and [].\n\t     * (actually, we skip #\\( et al)\n\t     */\n\t    if (curbuf->b_p_lisp\n\t\t    && vim_strchr((char_u *)\"(){}[]\", c) != NULL\n\t\t    && pos.col > 1\n\t\t    && check_prevcol(linep, pos.col, '\\\\', NULL)\n\t\t    && check_prevcol(linep, pos.col - 1, '#', NULL))\n\t\tbreak;\n\n\t    // Check for match outside of quotes, and inside of\n\t    // quotes when the start is also inside of quotes.\n\t    if ((!inquote || start_in_quotes == TRUE)\n\t\t    && (c == initc || c == findc))\n\t    {\n\t\tint\tcol, bslcnt = 0;\n\n\t\tif (!cpo_bsl)\n\t\t{\n\t\t    for (col = pos.col; check_prevcol(linep, col, '\\\\', &col);)\n\t\t\tbslcnt++;\n\t\t}\n\t\t// Only accept a match when 'M' is in 'cpo' or when escaping\n\t\t// is what we expect.\n\t\tif (cpo_bsl || (bslcnt & 1) == match_escaped)\n\t\t{\n\t\t    if (c == initc)\n\t\t\tcount++;\n\t\t    else\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t\tcount--;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    if (comment_dir == BACKWARD && count > 0)\n    {\n\tpos = match_pos;\n\treturn &pos;\n    }\n    return (pos_T *)NULL;\t// never found it\n}\n\n/*\n * Check if line[] contains a / / comment.\n * Return MAXCOL if not, otherwise return the column.\n */\n    int\ncheck_linecomment(char_u *line)\n{\n    char_u  *p;\n\n    p = line;\n    // skip Lispish one-line comments\n    if (curbuf->b_p_lisp)\n    {\n\tif (vim_strchr(p, ';') != NULL) // there may be comments\n\t{\n\t    int in_str = FALSE;\t// inside of string\n\n\t    p = line;\t\t// scan from start\n\t    while ((p = vim_strpbrk(p, (char_u *)\"\\\";\")) != NULL)\n\t    {\n\t\tif (*p == '\"')\n\t\t{\n\t\t    if (in_str)\n\t\t    {\n\t\t\tif (*(p - 1) != '\\\\') // skip escaped quote\n\t\t\t    in_str = FALSE;\n\t\t    }\n\t\t    else if (p == line || ((p - line) >= 2\n\t\t\t\t      // skip #\\\" form\n\t\t\t\t      && *(p - 1) != '\\\\' && *(p - 2) != '#'))\n\t\t\tin_str = TRUE;\n\t\t}\n\t\telse if (!in_str && ((p - line) < 2\n\t\t\t\t    || (*(p - 1) != '\\\\' && *(p - 2) != '#'))\n\t\t\t       && !is_pos_in_string(line, (colnr_T)(p - line)))\n\t\t    break;\t// found!\n\t\t++p;\n\t    }\n\t}\n\telse\n\t    p = NULL;\n    }\n    else\n\twhile ((p = vim_strchr(p, '/')) != NULL)\n\t{\n\t    // Accept a double /, unless it's preceded with * and followed by\n\t    // *, because * / / * is an end and start of a C comment.  Only\n\t    // accept the position if it is not inside a string.\n\t    if (p[1] == '/' && (p == line || p[-1] != '*' || p[2] != '*')\n\t\t\t       && !is_pos_in_string(line, (colnr_T)(p - line)))\n\t\tbreak;\n\t    ++p;\n\t}\n\n    if (p == NULL)\n\treturn MAXCOL;\n    return (int)(p - line);\n}\n\n/*\n * Move cursor briefly to character matching the one under the cursor.\n * Used for Insert mode and \"r\" command.\n * Show the match only if it is visible on the screen.\n * If there isn't a match, then beep.\n */\n    void\nshowmatch(\n    int\t\tc)\t    // char to show match for\n{\n    pos_T\t*lpos, save_cursor;\n    pos_T\tmpos;\n    colnr_T\tvcol;\n    long\tsave_so;\n    long\tsave_siso;\n#ifdef CURSOR_SHAPE\n    int\t\tsave_state;\n#endif\n    colnr_T\tsave_dollar_vcol;\n    char_u\t*p;\n    long\t*so = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    long\t*siso = curwin->w_p_siso >= 0 ? &curwin->w_p_siso : &p_siso;\n\n    /*\n     * Only show match for chars in the 'matchpairs' option.\n     */\n    // 'matchpairs' is \"x:y,x:y\"\n    for (p = curbuf->b_p_mps; *p != NUL; ++p)\n    {\n#ifdef FEAT_RIGHTLEFT\n\tif (PTR2CHAR(p) == c && (curwin->w_p_rl ^ p_ri))\n\t    break;\n#endif\n\tp += mb_ptr2len(p) + 1;\n\tif (PTR2CHAR(p) == c\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !(curwin->w_p_rl ^ p_ri)\n#endif\n\t   )\n\t    break;\n\tp += mb_ptr2len(p);\n\tif (*p == NUL)\n\t    return;\n    }\n    if (*p == NUL)\n\treturn;\n\n    if ((lpos = findmatch(NULL, NUL)) == NULL)\t    // no match, so beep\n\tvim_beep(BO_MATCH);\n    else if (lpos->lnum >= curwin->w_topline && lpos->lnum < curwin->w_botline)\n    {\n\tif (!curwin->w_p_wrap)\n\t    getvcol(curwin, lpos, NULL, &vcol, NULL);\n\tif (curwin->w_p_wrap || (vcol >= curwin->w_leftcol\n\t\t\t       && vcol < curwin->w_leftcol + curwin->w_width))\n\t{\n\t    mpos = *lpos;    // save the pos, update_screen() may change it\n\t    save_cursor = curwin->w_cursor;\n\t    save_so = *so;\n\t    save_siso = *siso;\n\t    // Handle \"$\" in 'cpo': If the ')' is typed on top of the \"$\",\n\t    // stop displaying the \"$\".\n\t    if (dollar_vcol >= 0 && dollar_vcol == curwin->w_virtcol)\n\t\tdollar_vcol = -1;\n\t    ++curwin->w_virtcol;\t// do display ')' just before \"$\"\n\t    update_screen(VALID);\t// show the new char first\n\n\t    save_dollar_vcol = dollar_vcol;\n#ifdef CURSOR_SHAPE\n\t    save_state = State;\n\t    State = MODE_SHOWMATCH;\n\t    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\t    curwin->w_cursor = mpos;\t// move to matching char\n\t    *so = 0;\t\t\t// don't use 'scrolloff' here\n\t    *siso = 0;\t\t\t// don't use 'sidescrolloff' here\n\t    showruler(FALSE);\n\t    setcursor();\n\t    cursor_on();\t\t// make sure that the cursor is shown\n\t    out_flush_cursor(TRUE, FALSE);\n\n\t    // Restore dollar_vcol(), because setcursor() may call curs_rows()\n\t    // which resets it if the matching position is in a previous line\n\t    // and has a higher column number.\n\t    dollar_vcol = save_dollar_vcol;\n\n\t    /*\n\t     * brief pause, unless 'm' is present in 'cpo' and a character is\n\t     * available.\n\t     */\n\t    if (vim_strchr(p_cpo, CPO_SHOWMATCH) != NULL)\n\t\tui_delay(p_mat * 100L + 8, TRUE);\n\t    else if (!char_avail())\n\t\tui_delay(p_mat * 100L + 9, FALSE);\n\t    curwin->w_cursor = save_cursor;\t// restore cursor position\n\t    *so = save_so;\n\t    *siso = save_siso;\n#ifdef CURSOR_SHAPE\n\t    State = save_state;\n\t    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\t}\n    }\n}\n\n/*\n * Check if the pattern is zero-width.\n * If move is TRUE, check from the beginning of the buffer, else from position\n * \"cur\".\n * \"direction\" is FORWARD or BACKWARD.\n * Returns TRUE, FALSE or -1 for failure.\n */\n    static int\nis_zero_width(char_u *pattern, int move, pos_T *cur, int direction)\n{\n    regmmatch_T\tregmatch;\n    int\t\tnmatched = 0;\n    int\t\tresult = -1;\n    pos_T\tpos;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflag = 0;\n\n    if (pattern == NULL)\n\tpattern = spats[last_idx].pat;\n\n    if (search_regcomp(pattern, RE_SEARCH, RE_SEARCH,\n\t\t\t\t\t      SEARCH_KEEP, &regmatch) == FAIL)\n\treturn -1;\n\n    // init startcol correctly\n    regmatch.startpos[0].col = -1;\n    // move to match\n    if (move)\n    {\n\tCLEAR_POS(&pos);\n    }\n    else\n    {\n\tpos = *cur;\n\t// accept a match at the cursor position\n\tflag = SEARCH_START;\n    }\n\n    if (searchit(curwin, curbuf, &pos, NULL, direction, pattern, 1,\n\t\t\t\t  SEARCH_KEEP + flag, RE_SEARCH, NULL) != FAIL)\n    {\n\t// Zero-width pattern should match somewhere, then we can check if\n\t// start and end are in the same position.\n\tdo\n\t{\n\t    regmatch.startpos[0].col++;\n\t    nmatched = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t       pos.lnum, regmatch.startpos[0].col, NULL, NULL);\n\t    if (nmatched != 0)\n\t\tbreak;\n\t} while (regmatch.regprog != NULL\n\t\t&& direction == FORWARD ? regmatch.startpos[0].col < pos.col\n\t\t\t\t      : regmatch.startpos[0].col > pos.col);\n\n\tif (called_emsg == called_emsg_before)\n\t{\n\t    result = (nmatched != 0\n\t\t&& regmatch.startpos[0].lnum == regmatch.endpos[0].lnum\n\t\t&& regmatch.startpos[0].col == regmatch.endpos[0].col);\n\t}\n    }\n\n    vim_regfree(regmatch.regprog);\n    return result;\n}\n\n\n/*\n * Find next search match under cursor, cursor at end.\n * Used while an operator is pending, and in Visual mode.\n */\n    int\ncurrent_search(\n    long\tcount,\n    int\t\tforward)\t// TRUE for forward, FALSE for backward\n{\n    pos_T\tstart_pos;\t// start position of the pattern match\n    pos_T\tend_pos;\t// end position of the pattern match\n    pos_T\torig_pos;\t// position of the cursor at beginning\n    pos_T\tpos;\t\t// position after the pattern\n    int\t\ti;\n    int\t\tdir;\n    int\t\tresult;\t\t// result of various function calls\n    char_u\told_p_ws = p_ws;\n    int\t\tflags = 0;\n    pos_T\tsave_VIsual = VIsual;\n    int\t\tzero_width;\n    int\t\tskip_first_backward;\n\n    // Correct cursor when 'selection' is exclusive\n    if (VIsual_active && *p_sel == 'e' && LT_POS(VIsual, curwin->w_cursor))\n\tdec_cursor();\n\n    // When searching forward and the cursor is at the start of the Visual\n    // area, skip the first search backward, otherwise it doesn't move.\n    skip_first_backward = forward && VIsual_active\n\t\t\t\t\t   && LT_POS(curwin->w_cursor, VIsual);\n\n    orig_pos = pos = curwin->w_cursor;\n    if (VIsual_active)\n    {\n\tif (forward)\n\t    incl(&pos);\n\telse\n\t    decl(&pos);\n    }\n\n    // Is the pattern is zero-width?, this time, don't care about the direction\n    zero_width = is_zero_width(spats[last_idx].pat, TRUE, &curwin->w_cursor,\n\t\t\t\t\t\t\t\t      FORWARD);\n    if (zero_width == -1)\n\treturn FAIL;  // pattern not found\n\n    /*\n     * The trick is to first search backwards and then search forward again,\n     * so that a match at the current cursor position will be correctly\n     * captured.  When \"forward\" is false do it the other way around.\n     */\n    for (i = 0; i < 2; i++)\n    {\n\tif (forward)\n\t{\n\t    if (i == 0 && skip_first_backward)\n\t\tcontinue;\n\t    dir = i;\n\t}\n\telse\n\t    dir = !i;\n\n\tflags = 0;\n\tif (!dir && !zero_width)\n\t    flags = SEARCH_END;\n\tend_pos = pos;\n\n\t// wrapping should not occur in the first round\n\tif (i == 0)\n\t    p_ws = FALSE;\n\n\tresult = searchit(curwin, curbuf, &pos, &end_pos,\n\t\t(dir ? FORWARD : BACKWARD),\n\t\tspats[last_idx].pat, (long) (i ? count : 1),\n\t\tSEARCH_KEEP | flags, RE_SEARCH, NULL);\n\n\tp_ws = old_p_ws;\n\n\t// First search may fail, but then start searching from the\n\t// beginning of the file (cursor might be on the search match)\n\t// except when Visual mode is active, so that extending the visual\n\t// selection works.\n\tif (i == 1 && !result) // not found, abort\n\t{\n\t    curwin->w_cursor = orig_pos;\n\t    if (VIsual_active)\n\t\tVIsual = save_VIsual;\n\t    return FAIL;\n\t}\n\telse if (i == 0 && !result)\n\t{\n\t    if (forward)\n\t    {\n\t\t// try again from start of buffer\n\t\tCLEAR_POS(&pos);\n\t    }\n\t    else\n\t    {\n\t\t// try again from end of buffer\n\t\t// searching backwards, so set pos to last line and col\n\t\tpos.lnum = curwin->w_buffer->b_ml.ml_line_count;\n\t\tpos.col  = (colnr_T)STRLEN(\n\t\t\t\tml_get(curwin->w_buffer->b_ml.ml_line_count));\n\t    }\n\t}\n    }\n\n    start_pos = pos;\n\n    if (!VIsual_active)\n\tVIsual = start_pos;\n\n    // put the cursor after the match\n    curwin->w_cursor = end_pos;\n    if (LT_POS(VIsual, end_pos) && forward)\n    {\n\tif (skip_first_backward)\n\t    // put the cursor on the start of the match\n\t    curwin->w_cursor = pos;\n\telse\n\t    // put the cursor on last character of match\n\t    dec_cursor();\n    }\n    else if (VIsual_active && LT_POS(curwin->w_cursor, VIsual) && forward)\n\tcurwin->w_cursor = pos;   // put the cursor on the start of the match\n    VIsual_active = TRUE;\n    VIsual_mode = 'v';\n\n    if (*p_sel == 'e')\n    {\n\t// Correction for exclusive selection depends on the direction.\n\tif (forward && LTOREQ_POS(VIsual, curwin->w_cursor))\n\t    inc_cursor();\n\telse if (!forward && LTOREQ_POS(curwin->w_cursor, VIsual))\n\t    inc(&VIsual);\n    }\n\n#ifdef FEAT_FOLDING\n    if (fdo_flags & FDO_SEARCH && KeyTyped)\n\tfoldOpenCursor();\n#endif\n\n    may_start_select('c');\n    setmouse();\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end are still the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n    redraw_curbuf_later(INVERTED);\n    showmode();\n\n    return OK;\n}\n\n/*\n * return TRUE if line 'lnum' is empty or has white chars only.\n */\n    int\nlinewhite(linenr_T lnum)\n{\n    char_u  *p;\n\n    p = skipwhite(ml_get(lnum));\n    return (*p == NUL);\n}\n\n/*\n * Add the search count \"[3/19]\" to \"msgbuf\".\n * See update_search_stat() for other arguments.\n */\n    static void\ncmdline_search_stat(\n    int\t\tdirc,\n    pos_T\t*pos,\n    pos_T\t*cursor_pos,\n    int\t\tshow_top_bot_msg,\n    char_u\t*msgbuf,\n    int\t\trecompute,\n    int\t\tmaxcount,\n    long\ttimeout)\n{\n    searchstat_T stat;\n\n    update_search_stat(dirc, pos, cursor_pos, &stat, recompute, maxcount,\n\t\t\t\t\t\t\t\t      timeout);\n    if (stat.cur > 0)\n    {\n\tchar\tt[SEARCH_STAT_BUF_LEN];\n\tsize_t\tlen;\n\n#ifdef FEAT_RIGHTLEFT\n\tif (curwin->w_p_rl && *curwin->w_p_rlc == 's')\n\t{\n\t    if (stat.incomplete == 1)\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[?/??]\");\n\t    else if (stat.cnt > maxcount && stat.cur > maxcount)\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[>%d/>%d]\",\n\t\t\t\t\t\t\t   maxcount, maxcount);\n\t    else if (stat.cnt > maxcount)\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[>%d/%d]\",\n\t\t\t\t\t\t\t   maxcount, stat.cur);\n\t    else\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[%d/%d]\",\n\t\t\t\t\t\t\t   stat.cnt, stat.cur);\n\t}\n\telse\n#endif\n\t{\n\t    if (stat.incomplete == 1)\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[?/??]\");\n\t    else if (stat.cnt > maxcount && stat.cur > maxcount)\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[>%d/>%d]\",\n\t\t\t\t\t\t\t   maxcount, maxcount);\n\t    else if (stat.cnt > maxcount)\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[%d/>%d]\",\n\t\t\t\t\t\t\t   stat.cur, maxcount);\n\t    else\n\t\tvim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[%d/%d]\",\n\t\t\t\t\t\t\t   stat.cur, stat.cnt);\n\t}\n\n\tlen = STRLEN(t);\n\tif (show_top_bot_msg && len + 2 < SEARCH_STAT_BUF_LEN)\n\t{\n\t    mch_memmove(t + 2, t, len);\n\t    t[0] = 'W';\n\t    t[1] = ' ';\n\t    len += 2;\n\t}\n\n\tmch_memmove(msgbuf + STRLEN(msgbuf) - len, t, len);\n\tif (dirc == '?' && stat.cur == maxcount + 1)\n\t    stat.cur = -1;\n\n\t// keep the message even after redraw, but don't put in history\n\tmsg_hist_off = TRUE;\n\tgive_warning(msgbuf, FALSE);\n\tmsg_hist_off = FALSE;\n    }\n}\n\n/*\n * Add the search count information to \"stat\".\n * \"stat\" must not be NULL.\n * When \"recompute\" is TRUE always recompute the numbers.\n * dirc == 0: don't find the next/previous match (only set the result to \"stat\")\n * dirc == '/': find the next match\n * dirc == '?': find the previous match\n */\n    static void\nupdate_search_stat(\n    int\t\t\tdirc,\n    pos_T\t\t*pos,\n    pos_T\t\t*cursor_pos,\n    searchstat_T\t*stat,\n    int\t\t\trecompute,\n    int\t\t\tmaxcount,\n    long\t\ttimeout UNUSED)\n{\n    int\t\t    save_ws = p_ws;\n    int\t\t    wraparound = FALSE;\n    pos_T\t    p = (*pos);\n    static pos_T    lastpos = {0, 0, 0};\n    static int\t    cur = 0;\n    static int\t    cnt = 0;\n    static int\t    exact_match = FALSE;\n    static int\t    incomplete = 0;\n    static int\t    last_maxcount = SEARCH_STAT_DEF_MAX_COUNT;\n    static int\t    chgtick = 0;\n    static char_u   *lastpat = NULL;\n    static buf_T    *lbuf = NULL;\n#ifdef FEAT_RELTIME\n    proftime_T  start;\n#endif\n\n    vim_memset(stat, 0, sizeof(searchstat_T));\n\n    if (dirc == 0 && !recompute && !EMPTY_POS(lastpos))\n    {\n\tstat->cur = cur;\n\tstat->cnt = cnt;\n\tstat->exact_match = exact_match;\n\tstat->incomplete = incomplete;\n\tstat->last_maxcount = last_maxcount;\n\treturn;\n    }\n    last_maxcount = maxcount;\n\n    wraparound = ((dirc == '?' && LT_POS(lastpos, p))\n\t       || (dirc == '/' && LT_POS(p, lastpos)));\n\n    // If anything relevant changed the count has to be recomputed.\n    // MB_STRNICMP ignores case, but we should not ignore case.\n    // Unfortunately, there is no MB_STRNICMP function.\n    // XXX: above comment should be \"no MB_STRCMP function\" ?\n    if (!(chgtick == CHANGEDTICK(curbuf)\n\t&& MB_STRNICMP(lastpat, spats[last_idx].pat, STRLEN(lastpat)) == 0\n\t&& STRLEN(lastpat) == STRLEN(spats[last_idx].pat)\n\t&& EQUAL_POS(lastpos, *cursor_pos)\n\t&& lbuf == curbuf) || wraparound || cur < 0\n\t    || (maxcount > 0 && cur > maxcount) || recompute)\n    {\n\tcur = 0;\n\tcnt = 0;\n\texact_match = FALSE;\n\tincomplete = 0;\n\tCLEAR_POS(&lastpos);\n\tlbuf = curbuf;\n    }\n\n    if (EQUAL_POS(lastpos, *cursor_pos) && !wraparound\n\t\t&& (dirc == 0 || dirc == '/' ? cur < cnt : cur > 0))\n\tcur += dirc == 0 ? 0 : dirc == '/' ? 1 : -1;\n    else\n    {\n\tint\tdone_search = FALSE;\n\tpos_T\tendpos = {0, 0, 0};\n\n\tp_ws = FALSE;\n#ifdef FEAT_RELTIME\n\tif (timeout > 0)\n\t    profile_setlimit(timeout, &start);\n#endif\n\twhile (!got_int && searchit(curwin, curbuf, &lastpos, &endpos,\n\t\t\t FORWARD, NULL, 1, SEARCH_KEEP, RE_LAST, NULL) != FAIL)\n\t{\n\t    done_search = TRUE;\n#ifdef FEAT_RELTIME\n\t    // Stop after passing the time limit.\n\t    if (timeout > 0 && profile_passed_limit(&start))\n\t    {\n\t\tincomplete = 1;\n\t\tbreak;\n\t    }\n#endif\n\t    cnt++;\n\t    if (LTOREQ_POS(lastpos, p))\n\t    {\n\t\tcur = cnt;\n\t\tif (LT_POS(p, endpos))\n\t\t    exact_match = TRUE;\n\t    }\n\t    fast_breakcheck();\n\t    if (maxcount > 0 && cnt > maxcount)\n\t    {\n\t\tincomplete = 2;    // max count exceeded\n\t\tbreak;\n\t    }\n\t}\n\tif (got_int)\n\t    cur = -1; // abort\n\tif (done_search)\n\t{\n\t    vim_free(lastpat);\n\t    lastpat = vim_strsave(spats[last_idx].pat);\n\t    chgtick = CHANGEDTICK(curbuf);\n\t    lbuf = curbuf;\n\t    lastpos = p;\n\t}\n    }\n    stat->cur = cur;\n    stat->cnt = cnt;\n    stat->exact_match = exact_match;\n    stat->incomplete = incomplete;\n    stat->last_maxcount = last_maxcount;\n    p_ws = save_ws;\n}\n\n#if defined(FEAT_FIND_ID) || defined(PROTO)\n\n/*\n * Get line \"lnum\" and copy it into \"buf[LSIZE]\".\n * The copy is made because the regexp may make the line invalid when using a\n * mark.\n */\n    static char_u *\nget_line_and_copy(linenr_T lnum, char_u *buf)\n{\n    char_u *line = ml_get(lnum);\n\n    vim_strncpy(buf, line, LSIZE - 1);\n    return buf;\n}\n\n/*\n * Find identifiers or defines in included files.\n * If p_ic && compl_status_sol() then ptr must be in lowercase.\n */\n    void\nfind_pattern_in_path(\n    char_u\t*ptr,\t\t// pointer to search pattern\n    int\t\tdir UNUSED,\t// direction of expansion\n    int\t\tlen,\t\t// length of search pattern\n    int\t\twhole,\t\t// match whole words only\n    int\t\tskip_comments,\t// don't match inside comments\n    int\t\ttype,\t\t// Type of search; are we looking for a type?\n\t\t\t\t// a macro?\n    long\tcount,\n    int\t\taction,\t\t// What to do when we find it\n    linenr_T\tstart_lnum,\t// first line to start searching\n    linenr_T\tend_lnum)\t// last line for searching\n{\n    SearchedFile *files;\t\t// Stack of included files\n    SearchedFile *bigger;\t\t// When we need more space\n    int\t\tmax_path_depth = 50;\n    long\tmatch_count = 1;\n\n    char_u\t*pat;\n    char_u\t*new_fname;\n    char_u\t*curr_fname = curbuf->b_fname;\n    char_u\t*prev_fname = NULL;\n    linenr_T\tlnum;\n    int\t\tdepth;\n    int\t\tdepth_displayed;\t// For type==CHECK_PATH\n    int\t\told_files;\n    int\t\talready_searched;\n    char_u\t*file_line;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\tsave_char;\n    int\t\tdefine_matched;\n    regmatch_T\tregmatch;\n    regmatch_T\tincl_regmatch;\n    regmatch_T\tdef_regmatch;\n    int\t\tmatched = FALSE;\n    int\t\tdid_show = FALSE;\n    int\t\tfound = FALSE;\n    int\t\ti;\n    char_u\t*already = NULL;\n    char_u\t*startp = NULL;\n    char_u\t*inc_opt = NULL;\n#if defined(FEAT_QUICKFIX)\n    win_T\t*curwin_save = NULL;\n#endif\n\n    regmatch.regprog = NULL;\n    incl_regmatch.regprog = NULL;\n    def_regmatch.regprog = NULL;\n\n    file_line = alloc(LSIZE);\n    if (file_line == NULL)\n\treturn;\n\n    if (type != CHECK_PATH && type != FIND_DEFINE\n\t    // when CONT_SOL is set compare \"ptr\" with the beginning of the\n\t    // line is faster than quote_meta/regcomp/regexec \"ptr\" -- Acevedo\n\t    && !compl_status_sol())\n    {\n\tpat = alloc(len + 5);\n\tif (pat == NULL)\n\t    goto fpip_end;\n\tsprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", len, ptr);\n\t// ignore case according to p_ic, p_scs and pat\n\tregmatch.rm_ic = ignorecase(pat);\n\tregmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0);\n\tvim_free(pat);\n\tif (regmatch.regprog == NULL)\n\t    goto fpip_end;\n    }\n    inc_opt = (*curbuf->b_p_inc == NUL) ? p_inc : curbuf->b_p_inc;\n    if (*inc_opt != NUL)\n    {\n\tincl_regmatch.regprog = vim_regcomp(inc_opt,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (incl_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tincl_regmatch.rm_ic = FALSE;\t// don't ignore case in incl. pat.\n    }\n    if (type == FIND_DEFINE && (*curbuf->b_p_def != NUL || *p_def != NUL))\n    {\n\tdef_regmatch.regprog = vim_regcomp(*curbuf->b_p_def == NUL\n\t\t\t   ? p_def : curbuf->b_p_def,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (def_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tdef_regmatch.rm_ic = FALSE;\t// don't ignore case in define pat.\n    }\n    files = lalloc_clear(max_path_depth * sizeof(SearchedFile), TRUE);\n    if (files == NULL)\n\tgoto fpip_end;\n    old_files = max_path_depth;\n    depth = depth_displayed = -1;\n\n    lnum = start_lnum;\n    if (end_lnum > curbuf->b_ml.ml_line_count)\n\tend_lnum = curbuf->b_ml.ml_line_count;\n    if (lnum > end_lnum)\t\t// do at least one line\n\tlnum = end_lnum;\n    line = get_line_and_copy(lnum, file_line);\n\n    for (;;)\n    {\n\tif (incl_regmatch.regprog != NULL\n\t\t&& vim_regexec(&incl_regmatch, line, (colnr_T)0))\n\t{\n\t    char_u *p_fname = (curr_fname == curbuf->b_fname)\n\t\t\t\t\t      ? curbuf->b_ffname : curr_fname;\n\n\t    if (inc_opt != NULL && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t// Use text from '\\zs' to '\\ze' (or end) of 'include'.\n\t\tnew_fname = find_file_name_in_path(incl_regmatch.startp[0],\n\t\t       (int)(incl_regmatch.endp[0] - incl_regmatch.startp[0]),\n\t\t\t\t FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname);\n\t    else\n\t\t// Use text after match with 'include'.\n\t\tnew_fname = file_name_in_line(incl_regmatch.endp[0], 0,\n\t\t\t     FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);\n\t    already_searched = FALSE;\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Check whether we have already searched in this file\n\t\tfor (i = 0;; i++)\n\t\t{\n\t\t    if (i == depth + 1)\n\t\t\ti = old_files;\n\t\t    if (i == max_path_depth)\n\t\t\tbreak;\n\t\t    if (fullpathcmp(new_fname, files[i].name, TRUE, TRUE)\n\t\t\t\t\t\t\t\t    & FPC_SAME)\n\t\t    {\n\t\t\tif (type != CHECK_PATH\n\t\t\t\t&& action == ACTION_SHOW_ALL\n\t\t\t\t&& files[i].matched)\n\t\t\t{\n\t\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\t\t    if (!got_int)\t    // don't display if 'q'\n\t\t\t\t\t\t    // typed at \"--more--\"\n\t\t\t\t\t\t    // message\n\t\t\t    {\n\t\t\t\tmsg_home_replace_hl(new_fname);\n\t\t\t\tmsg_puts(_(\" (includes previously listed match)\"));\n\t\t\t\tprev_fname = NULL;\n\t\t\t    }\n\t\t\t}\n\t\t\tVIM_CLEAR(new_fname);\n\t\t\talready_searched = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (type == CHECK_PATH && (action == ACTION_SHOW_ALL\n\t\t\t\t || (new_fname == NULL && !already_searched)))\n\t    {\n\t\tif (did_show)\n\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\telse\n\t\t{\n\t\t    gotocmdline(TRUE);\t    // cursor at status line\n\t\t    msg_puts_title(_(\"--- Included files \"));\n\t\t    if (action != ACTION_SHOW_ALL)\n\t\t\tmsg_puts_title(_(\"not found \"));\n\t\t    msg_puts_title(_(\"in path ---\\n\"));\n\t\t}\n\t\tdid_show = TRUE;\n\t\twhile (depth_displayed < depth && !got_int)\n\t\t{\n\t\t    ++depth_displayed;\n\t\t    for (i = 0; i < depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    msg_home_replace(files[depth_displayed].name);\n\t\t    msg_puts(\" -->\\n\");\n\t\t}\n\t\tif (!got_int)\t\t    // don't display if 'q' typed\n\t\t\t\t\t    // for \"--more--\" message\n\t\t{\n\t\t    for (i = 0; i <= depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    if (new_fname != NULL)\n\t\t    {\n\t\t\t// using \"new_fname\" is more reliable, e.g., when\n\t\t\t// 'includeexpr' is set.\n\t\t\tmsg_outtrans_attr(new_fname, HL_ATTR(HLF_D));\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/*\n\t\t\t * Isolate the file name.\n\t\t\t * Include the surrounding \"\" or <> if present.\n\t\t\t */\n\t\t\tif (inc_opt != NULL\n\t\t\t\t   && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t\t{\n\t\t\t    // pattern contains \\zs, use the match\n\t\t\t    p = incl_regmatch.startp[0];\n\t\t\t    i = (int)(incl_regmatch.endp[0]\n\t\t\t\t\t\t   - incl_regmatch.startp[0]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // find the file name after the end of the match\n\t\t\t    for (p = incl_regmatch.endp[0];\n\t\t\t\t\t\t  *p && !vim_isfilec(*p); p++)\n\t\t\t\t;\n\t\t\t    for (i = 0; vim_isfilec(p[i]); i++)\n\t\t\t\t;\n\t\t\t}\n\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t    // Nothing found, use the rest of the line.\n\t\t\t    p = incl_regmatch.endp[0];\n\t\t\t    i = (int)STRLEN(p);\n\t\t\t}\n\t\t\t// Avoid checking before the start of the line, can\n\t\t\t// happen if \\zs appears in the regexp.\n\t\t\telse if (p > line)\n\t\t\t{\n\t\t\t    if (p[-1] == '\"' || p[-1] == '<')\n\t\t\t    {\n\t\t\t\t--p;\n\t\t\t\t++i;\n\t\t\t    }\n\t\t\t    if (p[i] == '\"' || p[i] == '>')\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tsave_char = p[i];\n\t\t\tp[i] = NUL;\n\t\t\tmsg_outtrans_attr(p, HL_ATTR(HLF_D));\n\t\t\tp[i] = save_char;\n\t\t    }\n\n\t\t    if (new_fname == NULL && action == ACTION_SHOW_ALL)\n\t\t    {\n\t\t\tif (already_searched)\n\t\t\t    msg_puts(_(\"  (Already listed)\"));\n\t\t\telse\n\t\t\t    msg_puts(_(\"  NOT FOUND\"));\n\t\t    }\n\t\t}\n\t\tout_flush();\t    // output each line directly\n\t    }\n\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Push the new file onto the file stack\n\t\tif (depth + 1 == old_files)\n\t\t{\n\t\t    bigger = ALLOC_MULT(SearchedFile, max_path_depth * 2);\n\t\t    if (bigger != NULL)\n\t\t    {\n\t\t\tfor (i = 0; i <= depth; i++)\n\t\t\t    bigger[i] = files[i];\n\t\t\tfor (i = depth + 1; i < old_files + max_path_depth; i++)\n\t\t\t{\n\t\t\t    bigger[i].fp = NULL;\n\t\t\t    bigger[i].name = NULL;\n\t\t\t    bigger[i].lnum = 0;\n\t\t\t    bigger[i].matched = FALSE;\n\t\t\t}\n\t\t\tfor (i = old_files; i < max_path_depth; i++)\n\t\t\t    bigger[i + max_path_depth] = files[i];\n\t\t\told_files += max_path_depth;\n\t\t\tmax_path_depth *= 2;\n\t\t\tvim_free(files);\n\t\t\tfiles = bigger;\n\t\t    }\n\t\t}\n\t\tif ((files[depth + 1].fp = mch_fopen((char *)new_fname, \"r\"))\n\t\t\t\t\t\t\t\t    == NULL)\n\t\t    vim_free(new_fname);\n\t\telse\n\t\t{\n\t\t    if (++depth == old_files)\n\t\t    {\n\t\t\t/*\n\t\t\t * lalloc() for 'bigger' must have failed above.  We\n\t\t\t * will forget one of our already visited files now.\n\t\t\t */\n\t\t\tvim_free(files[old_files].name);\n\t\t\t++old_files;\n\t\t    }\n\t\t    files[depth].name = curr_fname = new_fname;\n\t\t    files[depth].lnum = 0;\n\t\t    files[depth].matched = FALSE;\n\t\t    if (action == ACTION_EXPAND)\n\t\t    {\n\t\t\tmsg_hist_off = TRUE;\t// reset in msg_trunc_attr()\n\t\t\tvim_snprintf((char*)IObuff, IOSIZE,\n\t\t\t\t_(\"Scanning included file: %s\"),\n\t\t\t\t(char *)new_fname);\n\t\t\tmsg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n\t\t    }\n\t\t    else if (p_verbose >= 5)\n\t\t    {\n\t\t\tverbose_enter();\n\t\t\tsmsg(_(\"Searching included file %s\"),\n\t\t\t\t\t\t\t   (char *)new_fname);\n\t\t\tverbose_leave();\n\t\t    }\n\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Check if the line is a define (type == FIND_DEFINE)\n\t     */\n\t    p = line;\nsearch_line:\n\t    define_matched = FALSE;\n\t    if (def_regmatch.regprog != NULL\n\t\t\t      && vim_regexec(&def_regmatch, line, (colnr_T)0))\n\t    {\n\t\t/*\n\t\t * Pattern must be first identifier after 'define', so skip\n\t\t * to that position before checking for match of pattern.  Also\n\t\t * don't let it match beyond the end of this identifier.\n\t\t */\n\t\tp = def_regmatch.endp[0];\n\t\twhile (*p && !vim_iswordc(*p))\n\t\t    p++;\n\t\tdefine_matched = TRUE;\n\t    }\n\n\t    /*\n\t     * Look for a match.  Don't do this if we are looking for a\n\t     * define and this line didn't match define_prog above.\n\t     */\n\t    if (def_regmatch.regprog == NULL || define_matched)\n\t    {\n\t\tif (define_matched || compl_status_sol())\n\t\t{\n\t\t    // compare the first \"len\" chars from \"ptr\"\n\t\t    startp = skipwhite(p);\n\t\t    if (p_ic)\n\t\t\tmatched = !MB_STRNICMP(startp, ptr, len);\n\t\t    else\n\t\t\tmatched = !STRNCMP(startp, ptr, len);\n\t\t    if (matched && define_matched && whole\n\t\t\t\t\t\t  && vim_iswordc(startp[len]))\n\t\t\tmatched = FALSE;\n\t\t}\n\t\telse if (regmatch.regprog != NULL\n\t\t\t && vim_regexec(&regmatch, line, (colnr_T)(p - line)))\n\t\t{\n\t\t    matched = TRUE;\n\t\t    startp = regmatch.startp[0];\n\t\t    /*\n\t\t     * Check if the line is not a comment line (unless we are\n\t\t     * looking for a define).  A line starting with \"# define\"\n\t\t     * is not considered to be a comment line.\n\t\t     */\n\t\t    if (!define_matched && skip_comments)\n\t\t    {\n\t\t\tif ((*line != '#' ||\n\t\t\t\tSTRNCMP(skipwhite(line + 1), \"define\", 6) != 0)\n\t\t\t\t&& get_leader_len(line, NULL, FALSE, TRUE))\n\t\t\t    matched = FALSE;\n\n\t\t\t/*\n\t\t\t * Also check for a \"/ *\" or \"/ /\" before the match.\n\t\t\t * Skips lines like \"int backwards;  / * normal index\n\t\t\t * * /\" when looking for \"normal\".\n\t\t\t * Note: Doesn't skip \"/ *\" in comments.\n\t\t\t */\n\t\t\tp = skipwhite(line);\n\t\t\tif (matched\n\t\t\t\t|| (p[0] == '/' && p[1] == '*') || p[0] == '*')\n\t\t\t    for (p = line; *p && p < startp; ++p)\n\t\t\t    {\n\t\t\t\tif (matched\n\t\t\t\t\t&& p[0] == '/'\n\t\t\t\t\t&& (p[1] == '*' || p[1] == '/'))\n\t\t\t\t{\n\t\t\t\t    matched = FALSE;\n\t\t\t\t    // After \"//\" all text is comment\n\t\t\t\t    if (p[1] == '/')\n\t\t\t\t\tbreak;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t\telse if (!matched && p[0] == '*' && p[1] == '/')\n\t\t\t\t{\n\t\t\t\t    // Can find match after \"* /\".\n\t\t\t\t    matched = TRUE;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t    }\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (matched)\n\t{\n\t    if (action == ACTION_EXPAND)\n\t    {\n\t\tint\tcont_s_ipos = FALSE;\n\t\tint\tadd_r;\n\t\tchar_u\t*aux;\n\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum)\n\t\t    break;\n\t\tfound = TRUE;\n\t\taux = p = startp;\n\t\tif (compl_status_adding())\n\t\t{\n\t\t    p += ins_compl_len();\n\t\t    if (vim_iswordp(p))\n\t\t\tgoto exit_matched;\n\t\t    p = find_word_start(p);\n\t\t}\n\t\tp = find_word_end(p);\n\t\ti = (int)(p - aux);\n\n\t\tif (compl_status_adding() && i == ins_compl_len())\n\t\t{\n\t\t    // IOSIZE > compl_length, so the STRNCPY works\n\t\t    STRNCPY(IObuff, aux, i);\n\n\t\t    // Get the next line: when \"depth\" < 0  from the current\n\t\t    // buffer, otherwise from the included file.  Jump to\n\t\t    // exit_matched when past the last line.\n\t\t    if (depth < 0)\n\t\t    {\n\t\t\tif (lnum >= end_lnum)\n\t\t\t    goto exit_matched;\n\t\t\tline = get_line_and_copy(++lnum, file_line);\n\t\t    }\n\t\t    else if (vim_fgets(line = file_line,\n\t\t\t\t\t\t      LSIZE, files[depth].fp))\n\t\t\tgoto exit_matched;\n\n\t\t    // we read a line, set \"already\" to check this \"line\" later\n\t\t    // if depth >= 0 we'll increase files[depth].lnum far\n\t\t    // below  -- Acevedo\n\t\t    already = aux = p = skipwhite(line);\n\t\t    p = find_word_start(p);\n\t\t    p = find_word_end(p);\n\t\t    if (p > aux)\n\t\t    {\n\t\t\tif (*aux != ')' && IObuff[i-1] != TAB)\n\t\t\t{\n\t\t\t    if (IObuff[i-1] != ' ')\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t    // IObuf =~ \"\\(\\k\\|\\i\\).* \", thus i >= 2\n\t\t\t    if (p_js\n\t\t\t\t&& (IObuff[i-2] == '.'\n\t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL\n\t\t\t\t\t&& (IObuff[i-2] == '?'\n\t\t\t\t\t    || IObuff[i-2] == '!'))))\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t}\n\t\t\t// copy as much as possible of the new word\n\t\t\tif (p - aux >= IOSIZE - i)\n\t\t\t    p = aux + IOSIZE - i - 1;\n\t\t\tSTRNCPY(IObuff + i, aux, p - aux);\n\t\t\ti += (int)(p - aux);\n\t\t\tcont_s_ipos = TRUE;\n\t\t    }\n\t\t    IObuff[i] = NUL;\n\t\t    aux = IObuff;\n\n\t\t    if (i == ins_compl_len())\n\t\t\tgoto exit_matched;\n\t\t}\n\n\t\tadd_r = ins_compl_add_infercase(aux, i, p_ic,\n\t\t\tcurr_fname == curbuf->b_fname ? NULL : curr_fname,\n\t\t\tdir, cont_s_ipos);\n\t\tif (add_r == OK)\n\t\t    // if dir was BACKWARD then honor it just once\n\t\t    dir = FORWARD;\n\t\telse if (add_r == FAIL)\n\t\t    break;\n\t    }\n\t    else if (action == ACTION_SHOW_ALL)\n\t    {\n\t\tfound = TRUE;\n\t\tif (!did_show)\n\t\t    gotocmdline(TRUE);\t\t// cursor at status line\n\t\tif (curr_fname != prev_fname)\n\t\t{\n\t\t    if (did_show)\n\t\t\tmsg_putchar('\\n');\t// cursor below last one\n\t\t    if (!got_int)\t\t// don't display if 'q' typed\n\t\t\t\t\t\t// at \"--more--\" message\n\t\t\tmsg_home_replace_hl(curr_fname);\n\t\t    prev_fname = curr_fname;\n\t\t}\n\t\tdid_show = TRUE;\n\t\tif (!got_int)\n\t\t    show_pat_in_path(line, type, TRUE, action,\n\t\t\t    (depth == -1) ? NULL : files[depth].fp,\n\t\t\t    (depth == -1) ? &lnum : &files[depth].lnum,\n\t\t\t    match_count++);\n\n\t\t// Set matched flag for this file and all the ones that\n\t\t// include it\n\t\tfor (i = 0; i <= depth; ++i)\n\t\t    files[i].matched = TRUE;\n\t    }\n\t    else if (--count <= 0)\n\t    {\n\t\tfound = TRUE;\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum\n#if defined(FEAT_QUICKFIX)\n\t\t\t\t\t\t      && g_do_tagpreview == 0\n#endif\n\t\t\t\t\t\t      )\n\t\t    emsg(_(e_match_is_on_current_line));\n\t\telse if (action == ACTION_SHOW)\n\t\t{\n\t\t    show_pat_in_path(line, type, did_show, action,\n\t\t\t(depth == -1) ? NULL : files[depth].fp,\n\t\t\t(depth == -1) ? &lnum : &files[depth].lnum, 1L);\n\t\t    did_show = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n#if defined(FEAT_QUICKFIX)\n\t\t    // \":psearch\" uses the preview window\n\t\t    if (g_do_tagpreview != 0)\n\t\t    {\n\t\t\tcurwin_save = curwin;\n\t\t\tprepare_tagpreview(TRUE, TRUE, FALSE);\n\t\t    }\n#endif\n\t\t    if (action == ACTION_SPLIT)\n\t\t    {\n\t\t\tif (win_split(0, 0) == FAIL)\n\t\t\t    break;\n\t\t\tRESET_BINDING(curwin);\n\t\t    }\n\t\t    if (depth == -1)\n\t\t    {\n\t\t\t// match in current file\n#if defined(FEAT_QUICKFIX)\n\t\t\tif (g_do_tagpreview != 0)\n\t\t\t{\n\t\t\t    if (!win_valid(curwin_save))\n\t\t\t\tbreak;\n\t\t\t    if (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t   curwin_save->w_buffer->b_fnum, NULL,\n\t\t\t\t\t\t     NULL, TRUE, lnum, FALSE)))\n\t\t\t\tbreak;\t// failed to jump to file\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    setpcmark();\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tcheck_cursor();\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t0, files[depth].name, NULL, TRUE,\n\t\t\t\t\t\t    files[depth].lnum, FALSE)))\n\t\t\t    break;\t// failed to jump to file\n\t\t\t// autocommands may have changed the lnum, we don't\n\t\t\t// want that here\n\t\t\tcurwin->w_cursor.lnum = files[depth].lnum;\n\t\t    }\n\t\t}\n\t\tif (action != ACTION_SHOW)\n\t\t{\n\t\t    curwin->w_cursor.col = (colnr_T)(startp - line);\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t}\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0\n\t\t\t   && curwin != curwin_save && win_valid(curwin_save))\n\t\t{\n\t\t    // Return cursor to where we were\n\t\t    validate_cursor();\n\t\t    redraw_later(VALID);\n\t\t    win_enter(curwin_save, TRUE);\n\t\t}\n# ifdef FEAT_PROP_POPUP\n\t\telse if (WIN_IS_POPUP(curwin))\n\t\t    // can't keep focus in popup window\n\t\t    win_enter(firstwin, TRUE);\n# endif\n#endif\n\t\tbreak;\n\t    }\nexit_matched:\n\t    matched = FALSE;\n\t    // look for other matches in the rest of the line if we\n\t    // are not at the end of it already\n\t    if (def_regmatch.regprog == NULL\n\t\t    && action == ACTION_EXPAND\n\t\t    && !compl_status_sol()\n\t\t    && *startp != NUL\n\t\t    && *(p = startp + mb_ptr2len(startp)) != NUL)\n\t\tgoto search_line;\n\t}\n\tline_breakcheck();\n\tif (action == ACTION_EXPAND)\n\t    ins_compl_check_keys(30, FALSE);\n\tif (got_int || ins_compl_interrupted())\n\t    break;\n\n\t/*\n\t * Read the next line.  When reading an included file and encountering\n\t * end-of-file, close the file and continue in the file that included\n\t * it.\n\t */\n\twhile (depth >= 0 && !already\n\t\t&& vim_fgets(line = file_line, LSIZE, files[depth].fp))\n\t{\n\t    fclose(files[depth].fp);\n\t    --old_files;\n\t    files[old_files].name = files[depth].name;\n\t    files[old_files].matched = files[depth].matched;\n\t    --depth;\n\t    curr_fname = (depth == -1) ? curbuf->b_fname\n\t\t\t\t       : files[depth].name;\n\t    if (depth < depth_displayed)\n\t\tdepth_displayed = depth;\n\t}\n\tif (depth >= 0)\t\t// we could read the line\n\t{\n\t    files[depth].lnum++;\n\t    // Remove any CR and LF from the line.\n\t    i = (int)STRLEN(line);\n\t    if (i > 0 && line[i - 1] == '\\n')\n\t\tline[--i] = NUL;\n\t    if (i > 0 && line[i - 1] == '\\r')\n\t\tline[--i] = NUL;\n\t}\n\telse if (!already)\n\t{\n\t    if (++lnum > end_lnum)\n\t\tbreak;\n\t    line = get_line_and_copy(lnum, file_line);\n\t}\n\talready = NULL;\n    }\n    // End of big for (;;) loop.\n\n    // Close any files that are still open.\n    for (i = 0; i <= depth; i++)\n    {\n\tfclose(files[i].fp);\n\tvim_free(files[i].name);\n    }\n    for (i = old_files; i < max_path_depth; i++)\n\tvim_free(files[i].name);\n    vim_free(files);\n\n    if (type == CHECK_PATH)\n    {\n\tif (!did_show)\n\t{\n\t    if (action != ACTION_SHOW_ALL)\n\t\tmsg(_(\"All included files were found\"));\n\t    else\n\t\tmsg(_(\"No included files\"));\n\t}\n    }\n    else if (!found && action != ACTION_EXPAND)\n    {\n\tif (got_int || ins_compl_interrupted())\n\t    emsg(_(e_interrupted));\n\telse if (type == FIND_DEFINE)\n\t    emsg(_(e_couldnt_find_definition));\n\telse\n\t    emsg(_(e_couldnt_find_pattern));\n    }\n    if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)\n\tmsg_end();\n\nfpip_end:\n    vim_free(file_line);\n    vim_regfree(regmatch.regprog);\n    vim_regfree(incl_regmatch.regprog);\n    vim_regfree(def_regmatch.regprog);\n}\n\n    static void\nshow_pat_in_path(\n    char_u  *line,\n    int\t    type,\n    int\t    did_show,\n    int\t    action,\n    FILE    *fp,\n    linenr_T *lnum,\n    long    count)\n{\n    char_u  *p;\n\n    if (did_show)\n\tmsg_putchar('\\n');\t// cursor below last one\n    else if (!msg_silent)\n\tgotocmdline(TRUE);\t// cursor at status line\n    if (got_int)\t\t// 'q' typed at \"--more--\" message\n\treturn;\n    for (;;)\n    {\n\tp = line + STRLEN(line) - 1;\n\tif (fp != NULL)\n\t{\n\t    // We used fgets(), so get rid of newline at end\n\t    if (p >= line && *p == '\\n')\n\t\t--p;\n\t    if (p >= line && *p == '\\r')\n\t\t--p;\n\t    *(p + 1) = NUL;\n\t}\n\tif (action == ACTION_SHOW_ALL)\n\t{\n\t    sprintf((char *)IObuff, \"%3ld: \", count);\t// show match nr\n\t    msg_puts((char *)IObuff);\n\t    sprintf((char *)IObuff, \"%4ld\", *lnum);\t// show line nr\n\t\t\t\t\t\t// Highlight line numbers\n\t    msg_puts_attr((char *)IObuff, HL_ATTR(HLF_N));\n\t    msg_puts(\" \");\n\t}\n\tmsg_prt_line(line, FALSE);\n\tout_flush();\t\t\t// show one line at a time\n\n\t// Definition continues until line that doesn't end with '\\'\n\tif (got_int || type != FIND_DEFINE || p < line || *p != '\\\\')\n\t    break;\n\n\tif (fp != NULL)\n\t{\n\t    if (vim_fgets(line, LSIZE, fp)) // end of file\n\t\tbreak;\n\t    ++*lnum;\n\t}\n\telse\n\t{\n\t    if (++*lnum > curbuf->b_ml.ml_line_count)\n\t\tbreak;\n\t    line = ml_get(*lnum);\n\t}\n\tmsg_putchar('\\n');\n    }\n}\n#endif\n\n#ifdef FEAT_VIMINFO\n/*\n * Return the last used search pattern at \"idx\".\n */\n    spat_T *\nget_spat(int idx)\n{\n    return &spats[idx];\n}\n\n/*\n * Return the last used search pattern index.\n */\n    int\nget_spat_last_idx(void)\n{\n    return last_idx;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(FEAT_PROTO)\n/*\n * \"searchcount()\" function\n */\n    void\nf_searchcount(typval_T *argvars, typval_T *rettv)\n{\n    pos_T\t\tpos = curwin->w_cursor;\n    char_u\t\t*pattern = NULL;\n    int\t\t\tmaxcount = SEARCH_STAT_DEF_MAX_COUNT;\n    long\t\ttimeout = SEARCH_STAT_DEF_TIMEOUT;\n    int\t\t\trecompute = TRUE;\n    searchstat_T\tstat;\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n\n    if (in_vim9script() && check_for_opt_dict_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (shortmess(SHM_SEARCHCOUNT))\t// 'shortmess' contains 'S' flag\n\trecompute = TRUE;\n\n    if (argvars[0].v_type != VAR_UNKNOWN)\n    {\n\tdict_T\t\t*dict;\n\tdictitem_T\t*di;\n\tlistitem_T\t*li;\n\tint\t\terror = FALSE;\n\n\tif (argvars[0].v_type != VAR_DICT || argvars[0].vval.v_dict == NULL)\n\t{\n\t    emsg(_(e_dictionary_required));\n\t    return;\n\t}\n\tdict = argvars[0].vval.v_dict;\n\tdi = dict_find(dict, (char_u *)\"timeout\", -1);\n\tif (di != NULL)\n\t{\n\t    timeout = (long)tv_get_number_chk(&di->di_tv, &error);\n\t    if (error)\n\t\treturn;\n\t}\n\tdi = dict_find(dict, (char_u *)\"maxcount\", -1);\n\tif (di != NULL)\n\t{\n\t    maxcount = (int)tv_get_number_chk(&di->di_tv, &error);\n\t    if (error)\n\t\treturn;\n\t}\n\trecompute = dict_get_bool(dict, (char_u *)\"recompute\", recompute);\n\tdi = dict_find(dict, (char_u *)\"pattern\", -1);\n\tif (di != NULL)\n\t{\n\t    pattern = tv_get_string_chk(&di->di_tv);\n\t    if (pattern == NULL)\n\t\treturn;\n\t}\n\tdi = dict_find(dict, (char_u *)\"pos\", -1);\n\tif (di != NULL)\n\t{\n\t    if (di->di_tv.v_type != VAR_LIST)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), \"pos\");\n\t\treturn;\n\t    }\n\t    if (list_len(di->di_tv.vval.v_list) != 3)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), \"List format should be [lnum, col, off]\");\n\t\treturn;\n\t    }\n\t    li = list_find(di->di_tv.vval.v_list, 0L);\n\t    if (li != NULL)\n\t    {\n\t\tpos.lnum = tv_get_number_chk(&li->li_tv, &error);\n\t\tif (error)\n\t\t    return;\n\t    }\n\t    li = list_find(di->di_tv.vval.v_list, 1L);\n\t    if (li != NULL)\n\t    {\n\t\tpos.col = tv_get_number_chk(&li->li_tv, &error) - 1;\n\t\tif (error)\n\t\t    return;\n\t    }\n\t    li = list_find(di->di_tv.vval.v_list, 2L);\n\t    if (li != NULL)\n\t    {\n\t\tpos.coladd = tv_get_number_chk(&li->li_tv, &error);\n\t\tif (error)\n\t\t    return;\n\t    }\n\t}\n    }\n\n    save_last_search_pattern();\n#ifdef FEAT_SEARCH_EXTRA\n    save_incsearch_state();\n#endif\n    if (pattern != NULL)\n    {\n\tif (*pattern == NUL)\n\t    goto the_end;\n\tvim_free(spats[last_idx].pat);\n\tspats[last_idx].pat = vim_strsave(pattern);\n    }\n    if (spats[last_idx].pat == NULL || *spats[last_idx].pat == NUL)\n\tgoto the_end;\t// the previous pattern was never defined\n\n    update_search_stat(0, &pos, &pos, &stat, recompute, maxcount, timeout);\n\n    dict_add_number(rettv->vval.v_dict, \"current\", stat.cur);\n    dict_add_number(rettv->vval.v_dict, \"total\", stat.cnt);\n    dict_add_number(rettv->vval.v_dict, \"exact_match\", stat.exact_match);\n    dict_add_number(rettv->vval.v_dict, \"incomplete\", stat.incomplete);\n    dict_add_number(rettv->vval.v_dict, \"maxcount\", stat.last_maxcount);\n\nthe_end:\n    restore_last_search_pattern();\n#ifdef FEAT_SEARCH_EXTRA\n    restore_incsearch_state();\n#endif\n}\n#endif\n\n/*\n * Fuzzy string matching\n *\n * Ported from the lib_fts library authored by Forrest Smith.\n * https://github.com/forrestthewoods/lib_fts/tree/master/code\n *\n * The following blog describes the fuzzy matching algorithm:\n * https://www.forrestthewoods.com/blog/reverse_engineering_sublime_texts_fuzzy_match/\n *\n * Each matching string is assigned a score. The following factors are checked:\n *   - Matched letter\n *   - Unmatched letter\n *   - Consecutively matched letters\n *   - Proximity to start\n *   - Letter following a separator (space, underscore)\n *   - Uppercase letter following lowercase (aka CamelCase)\n *\n * Matched letters are good. Unmatched letters are bad. Matching near the start\n * is good. Matching the first letter in the middle of a phrase is good.\n * Matching the uppercase letters in camel case entries is good.\n *\n * The score assigned for each factor is explained below.\n * File paths are different from file names. File extensions may be ignorable.\n * Single words care about consecutive matches but not separators or camel\n * case.\n *   Score starts at 100\n *   Matched letter: +0 points\n *   Unmatched letter: -1 point\n *   Consecutive match bonus: +15 points\n *   First letter bonus: +15 points\n *   Separator bonus: +30 points\n *   Camel case bonus: +30 points\n *   Unmatched leading letter: -5 points (max: -15)\n *\n * There is some nuance to this. Scores don\u2019t have an intrinsic meaning. The\n * score range isn\u2019t 0 to 100. It\u2019s roughly [50, 150]. Longer words have a\n * lower minimum score due to unmatched letter penalty. Longer search patterns\n * have a higher maximum score due to match bonuses.\n *\n * Separator and camel case bonus is worth a LOT. Consecutive matches are worth\n * quite a bit.\n *\n * There is a penalty if you DON\u2019T match the first three letters. Which\n * effectively rewards matching near the start. However there\u2019s no difference\n * in matching between the middle and end.\n *\n * There is not an explicit bonus for an exact match. Unmatched letters receive\n * a penalty. So shorter strings and closer matches are worth more.\n */\ntypedef struct\n{\n    int\t\tidx;\t\t// used for stable sort\n    listitem_T\t*item;\n    int\t\tscore;\n    list_T\t*lmatchpos;\n} fuzzyItem_T;\n\n// bonus for adjacent matches; this is higher than SEPARATOR_BONUS so that\n// matching a whole word is preferred.\n#define SEQUENTIAL_BONUS 40\n// bonus if match occurs after a path separator\n#define PATH_SEPARATOR_BONUS 30\n// bonus if match occurs after a word separator\n#define WORD_SEPARATOR_BONUS 25\n// bonus if match is uppercase and prev is lower\n#define CAMEL_BONUS 30\n// bonus if the first letter is matched\n#define FIRST_LETTER_BONUS 15\n// penalty applied for every letter in str before the first match\n#define LEADING_LETTER_PENALTY (-5)\n// maximum penalty for leading letters\n#define MAX_LEADING_LETTER_PENALTY (-15)\n// penalty for every letter that doesn't match\n#define UNMATCHED_LETTER_PENALTY (-1)\n// penalty for gap in matching positions (-2 * k)\n#define GAP_PENALTY\t(-2)\n// Score for a string that doesn't fuzzy match the pattern\n#define SCORE_NONE\t(-9999)\n\n#define FUZZY_MATCH_RECURSION_LIMIT\t10\n\n/*\n * Compute a score for a fuzzy matched string. The matching character locations\n * are in 'matches'.\n */\n    static int\nfuzzy_match_compute_score(\n\tchar_u\t\t*str,\n\tint\t\tstrSz,\n\tint_u\t\t*matches,\n\tint\t\tnumMatches)\n{\n    int\t\tscore;\n    int\t\tpenalty;\n    int\t\tunmatched;\n    int\t\ti;\n    char_u\t*p = str;\n    int_u\tsidx = 0;\n\n    // Initialize score\n    score = 100;\n\n    // Apply leading letter penalty\n    penalty = LEADING_LETTER_PENALTY * matches[0];\n    if (penalty < MAX_LEADING_LETTER_PENALTY)\n\tpenalty = MAX_LEADING_LETTER_PENALTY;\n    score += penalty;\n\n    // Apply unmatched penalty\n    unmatched = strSz - numMatches;\n    score += UNMATCHED_LETTER_PENALTY * unmatched;\n\n    // Apply ordering bonuses\n    for (i = 0; i < numMatches; ++i)\n    {\n\tint_u\tcurrIdx = matches[i];\n\n\tif (i > 0)\n\t{\n\t    int_u\tprevIdx = matches[i - 1];\n\n\t    // Sequential\n\t    if (currIdx == (prevIdx + 1))\n\t\tscore += SEQUENTIAL_BONUS;\n\t    else\n\t\tscore += GAP_PENALTY * (currIdx - prevIdx);\n\t}\n\n\t// Check for bonuses based on neighbor character value\n\tif (currIdx > 0)\n\t{\n\t    // Camel case\n\t    int\tneighbor = ' ';\n\t    int\tcurr;\n\n\t    if (has_mbyte)\n\t    {\n\t\twhile (sidx < currIdx)\n\t\t{\n\t\t    neighbor = (*mb_ptr2char)(p);\n\t\t    MB_PTR_ADV(p);\n\t\t    sidx++;\n\t\t}\n\t\tcurr = (*mb_ptr2char)(p);\n\t    }\n\t    else\n\t    {\n\t\tneighbor = str[currIdx - 1];\n\t\tcurr = str[currIdx];\n\t    }\n\n\t    if (vim_islower(neighbor) && vim_isupper(curr))\n\t\tscore += CAMEL_BONUS;\n\n\t    // Bonus if the match follows a separator character\n\t    if (neighbor == '/' || neighbor == '\\\\')\n\t\tscore += PATH_SEPARATOR_BONUS;\n\t    else if (neighbor == ' ' || neighbor == '_')\n\t\tscore += WORD_SEPARATOR_BONUS;\n\t}\n\telse\n\t{\n\t    // First letter\n\t    score += FIRST_LETTER_BONUS;\n\t}\n    }\n    return score;\n}\n\n/*\n * Perform a recursive search for fuzzy matching 'fuzpat' in 'str'.\n * Return the number of matching characters.\n */\n    static int\nfuzzy_match_recursive(\n\tchar_u\t\t*fuzpat,\n\tchar_u\t\t*str,\n\tint_u\t\tstrIdx,\n\tint\t\t*outScore,\n\tchar_u\t\t*strBegin,\n\tint\t\tstrLen,\n\tint_u\t\t*srcMatches,\n\tint_u\t\t*matches,\n\tint\t\tmaxMatches,\n\tint\t\tnextMatch,\n\tint\t\t*recursionCount)\n{\n    // Recursion params\n    int\t\trecursiveMatch = FALSE;\n    int_u\tbestRecursiveMatches[MAX_FUZZY_MATCHES];\n    int\t\tbestRecursiveScore = 0;\n    int\t\tfirst_match;\n    int\t\tmatched;\n\n    // Count recursions\n    ++*recursionCount;\n    if (*recursionCount >= FUZZY_MATCH_RECURSION_LIMIT)\n\treturn 0;\n\n    // Detect end of strings\n    if (*fuzpat == NUL || *str == NUL)\n\treturn 0;\n\n    // Loop through fuzpat and str looking for a match\n    first_match = TRUE;\n    while (*fuzpat != NUL && *str != NUL)\n    {\n\tint\tc1;\n\tint\tc2;\n\n\tc1 = PTR2CHAR(fuzpat);\n\tc2 = PTR2CHAR(str);\n\n\t// Found match\n\tif (vim_tolower(c1) == vim_tolower(c2))\n\t{\n\t    int_u\trecursiveMatches[MAX_FUZZY_MATCHES];\n\t    int\t\trecursiveScore = 0;\n\t    char_u\t*next_char;\n\n\t    // Supplied matches buffer was too short\n\t    if (nextMatch >= maxMatches)\n\t\treturn 0;\n\n\t    // \"Copy-on-Write\" srcMatches into matches\n\t    if (first_match && srcMatches)\n\t    {\n\t\tmemcpy(matches, srcMatches, nextMatch * sizeof(srcMatches[0]));\n\t\tfirst_match = FALSE;\n\t    }\n\n\t    // Recursive call that \"skips\" this match\n\t    if (has_mbyte)\n\t\tnext_char = str + (*mb_ptr2len)(str);\n\t    else\n\t\tnext_char = str + 1;\n\t    if (fuzzy_match_recursive(fuzpat, next_char, strIdx + 1,\n\t\t\t&recursiveScore, strBegin, strLen, matches,\n\t\t\trecursiveMatches,\n\t\t\tARRAY_LENGTH(recursiveMatches),\n\t\t\tnextMatch, recursionCount))\n\t    {\n\t\t// Pick best recursive score\n\t\tif (!recursiveMatch || recursiveScore > bestRecursiveScore)\n\t\t{\n\t\t    memcpy(bestRecursiveMatches, recursiveMatches,\n\t\t\t    MAX_FUZZY_MATCHES * sizeof(recursiveMatches[0]));\n\t\t    bestRecursiveScore = recursiveScore;\n\t\t}\n\t\trecursiveMatch = TRUE;\n\t    }\n\n\t    // Advance\n\t    matches[nextMatch++] = strIdx;\n\t    if (has_mbyte)\n\t\tMB_PTR_ADV(fuzpat);\n\t    else\n\t\t++fuzpat;\n\t}\n\tif (has_mbyte)\n\t    MB_PTR_ADV(str);\n\telse\n\t    ++str;\n\tstrIdx++;\n    }\n\n    // Determine if full fuzpat was matched\n    matched = *fuzpat == NUL ? TRUE : FALSE;\n\n    // Calculate score\n    if (matched)\n\t*outScore = fuzzy_match_compute_score(strBegin, strLen, matches,\n\t\tnextMatch);\n\n    // Return best result\n    if (recursiveMatch && (!matched || bestRecursiveScore > *outScore))\n    {\n\t// Recursive score is better than \"this\"\n\tmemcpy(matches, bestRecursiveMatches, maxMatches * sizeof(matches[0]));\n\t*outScore = bestRecursiveScore;\n\treturn nextMatch;\n    }\n    else if (matched)\n\treturn nextMatch;\t// \"this\" score is better than recursive\n\n    return 0;\t\t// no match\n}\n\n/*\n * fuzzy_match()\n *\n * Performs exhaustive search via recursion to find all possible matches and\n * match with highest score.\n * Scores values have no intrinsic meaning.  Possible score range is not\n * normalized and varies with pattern.\n * Recursion is limited internally (default=10) to prevent degenerate cases\n * (pat_arg=\"aaaaaa\" str=\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\").\n * Uses char_u for match indices. Therefore patterns are limited to\n * MAX_FUZZY_MATCHES characters.\n *\n * Returns TRUE if 'pat_arg' matches 'str'. Also returns the match score in\n * 'outScore' and the matching character positions in 'matches'.\n */\n    int\nfuzzy_match(\n\tchar_u\t\t*str,\n\tchar_u\t\t*pat_arg,\n\tint\t\tmatchseq,\n\tint\t\t*outScore,\n\tint_u\t\t*matches,\n\tint\t\tmaxMatches)\n{\n    int\t\trecursionCount = 0;\n    int\t\tlen = MB_CHARLEN(str);\n    char_u\t*save_pat;\n    char_u\t*pat;\n    char_u\t*p;\n    int\t\tcomplete = FALSE;\n    int\t\tscore = 0;\n    int\t\tnumMatches = 0;\n    int\t\tmatchCount;\n\n    *outScore = 0;\n\n    save_pat = vim_strsave(pat_arg);\n    if (save_pat == NULL)\n\treturn FALSE;\n    pat = save_pat;\n    p = pat;\n\n    // Try matching each word in 'pat_arg' in 'str'\n    while (TRUE)\n    {\n\tif (matchseq)\n\t    complete = TRUE;\n\telse\n\t{\n\t    // Extract one word from the pattern (separated by space)\n\t    p = skipwhite(p);\n\t    if (*p == NUL)\n\t\tbreak;\n\t    pat = p;\n\t    while (*p != NUL && !VIM_ISWHITE(PTR2CHAR(p)))\n\t    {\n\t\tif (has_mbyte)\n\t\t    MB_PTR_ADV(p);\n\t\telse\n\t\t    ++p;\n\t    }\n\t    if (*p == NUL)\t\t// processed all the words\n\t\tcomplete = TRUE;\n\t    *p = NUL;\n\t}\n\n\tscore = 0;\n\trecursionCount = 0;\n\tmatchCount = fuzzy_match_recursive(pat, str, 0, &score, str, len, NULL,\n\t\t\t\tmatches + numMatches, maxMatches - numMatches,\n\t\t\t\t0, &recursionCount);\n\tif (matchCount == 0)\n\t{\n\t    numMatches = 0;\n\t    break;\n\t}\n\n\t// Accumulate the match score and the number of matches\n\t*outScore += score;\n\tnumMatches += matchCount;\n\n\tif (complete)\n\t    break;\n\n\t// try matching the next word\n\t++p;\n    }\n\n    vim_free(save_pat);\n    return numMatches != 0;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_PROTO)\n/*\n * Sort the fuzzy matches in the descending order of the match score.\n * For items with same score, retain the order using the index (stable sort)\n */\n    static int\nfuzzy_match_item_compare(const void *s1, const void *s2)\n{\n    int\t\tv1 = ((fuzzyItem_T *)s1)->score;\n    int\t\tv2 = ((fuzzyItem_T *)s2)->score;\n    int\t\tidx1 = ((fuzzyItem_T *)s1)->idx;\n    int\t\tidx2 = ((fuzzyItem_T *)s2)->idx;\n\n    return v1 == v2 ? (idx1 - idx2) : v1 > v2 ? -1 : 1;\n}\n\n/*\n * Fuzzy search the string 'str' in a list of 'items' and return the matching\n * strings in 'fmatchlist'.\n * If 'matchseq' is TRUE, then for multi-word search strings, match all the\n * words in sequence.\n * If 'items' is a list of strings, then search for 'str' in the list.\n * If 'items' is a list of dicts, then either use 'key' to lookup the string\n * for each item or use 'item_cb' Funcref function to get the string.\n * If 'retmatchpos' is TRUE, then return a list of positions where 'str'\n * matches for each item.\n */\n    static void\nfuzzy_match_in_list(\n\tlist_T\t\t*l,\n\tchar_u\t\t*str,\n\tint\t\tmatchseq,\n\tchar_u\t\t*key,\n\tcallback_T\t*item_cb,\n\tint\t\tretmatchpos,\n\tlist_T\t\t*fmatchlist,\n\tlong\t\tmax_matches)\n{\n    long\tlen;\n    fuzzyItem_T\t*items;\n    listitem_T\t*li;\n    long\ti = 0;\n    long\tmatch_count = 0;\n    int_u\tmatches[MAX_FUZZY_MATCHES];\n\n    len = list_len(l);\n    if (len == 0)\n\treturn;\n    if (max_matches > 0 && len > max_matches)\n\tlen = max_matches;\n\n    items = ALLOC_CLEAR_MULT(fuzzyItem_T, len);\n    if (items == NULL)\n\treturn;\n\n    // For all the string items in items, get the fuzzy matching score\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\tint\t\tscore;\n\tchar_u\t\t*itemstr;\n\ttypval_T\trettv;\n\n\tif (max_matches > 0 && match_count >= max_matches)\n\t    break;\n\n\titemstr = NULL;\n\trettv.v_type = VAR_UNKNOWN;\n\tif (li->li_tv.v_type == VAR_STRING)\t// list of strings\n\t    itemstr = li->li_tv.vval.v_string;\n\telse if (li->li_tv.v_type == VAR_DICT\n\t\t\t\t&& (key != NULL || item_cb->cb_name != NULL))\n\t{\n\t    // For a dict, either use the specified key to lookup the string or\n\t    // use the specified callback function to get the string.\n\t    if (key != NULL)\n\t\titemstr = dict_get_string(li->li_tv.vval.v_dict, key, FALSE);\n\t    else\n\t    {\n\t\ttypval_T\targv[2];\n\n\t\t// Invoke the supplied callback (if any) to get the dict item\n\t\tli->li_tv.vval.v_dict->dv_refcount++;\n\t\targv[0].v_type = VAR_DICT;\n\t\targv[0].vval.v_dict = li->li_tv.vval.v_dict;\n\t\targv[1].v_type = VAR_UNKNOWN;\n\t\tif (call_callback(item_cb, -1, &rettv, 1, argv) != FAIL)\n\t\t{\n\t\t    if (rettv.v_type == VAR_STRING)\n\t\t\titemstr = rettv.vval.v_string;\n\t\t}\n\t\tdict_unref(li->li_tv.vval.v_dict);\n\t    }\n\t}\n\n\tif (itemstr != NULL\n\t\t&& fuzzy_match(itemstr, str, matchseq, &score, matches,\n\t\t\t\t\t\t\tMAX_FUZZY_MATCHES))\n\t{\n\t    items[match_count].idx = match_count;\n\t    items[match_count].item = li;\n\t    items[match_count].score = score;\n\n\t    // Copy the list of matching positions in itemstr to a list, if\n\t    // 'retmatchpos' is set.\n\t    if (retmatchpos)\n\t    {\n\t\tint\tj = 0;\n\t\tchar_u\t*p;\n\n\t\titems[match_count].lmatchpos = list_alloc();\n\t\tif (items[match_count].lmatchpos == NULL)\n\t\t    goto done;\n\n\t\tp = str;\n\t\twhile (*p != NUL)\n\t\t{\n\t\t    if (!VIM_ISWHITE(PTR2CHAR(p)) || matchseq)\n\t\t    {\n\t\t\tif (list_append_number(items[match_count].lmatchpos,\n\t\t\t\t    matches[j]) == FAIL)\n\t\t\t    goto done;\n\t\t\tj++;\n\t\t    }\n\t\t    if (has_mbyte)\n\t\t\tMB_PTR_ADV(p);\n\t\t    else\n\t\t\t++p;\n\t\t}\n\t    }\n\t    ++match_count;\n\t}\n\tclear_tv(&rettv);\n    }\n\n    if (match_count > 0)\n    {\n\tlist_T\t\t*retlist;\n\n\t// Sort the list by the descending order of the match score\n\tqsort((void *)items, (size_t)match_count, sizeof(fuzzyItem_T),\n\t\tfuzzy_match_item_compare);\n\n\t// For matchfuzzy(), return a list of matched strings.\n\t//\t    ['str1', 'str2', 'str3']\n\t// For matchfuzzypos(), return a list with three items.\n\t// The first item is a list of matched strings. The second item\n\t// is a list of lists where each list item is a list of matched\n\t// character positions. The third item is a list of matching scores.\n\t//\t[['str1', 'str2', 'str3'], [[1, 3], [1, 3], [1, 3]]]\n\tif (retmatchpos)\n\t{\n\t    li = list_find(fmatchlist, 0);\n\t    if (li == NULL || li->li_tv.vval.v_list == NULL)\n\t\tgoto done;\n\t    retlist = li->li_tv.vval.v_list;\n\t}\n\telse\n\t    retlist = fmatchlist;\n\n\t// Copy the matching strings with a valid score to the return list\n\tfor (i = 0; i < match_count; i++)\n\t{\n\t    if (items[i].score == SCORE_NONE)\n\t\tbreak;\n\t    list_append_tv(retlist, &items[i].item->li_tv);\n\t}\n\n\t// next copy the list of matching positions\n\tif (retmatchpos)\n\t{\n\t    li = list_find(fmatchlist, -2);\n\t    if (li == NULL || li->li_tv.vval.v_list == NULL)\n\t\tgoto done;\n\t    retlist = li->li_tv.vval.v_list;\n\n\t    for (i = 0; i < match_count; i++)\n\t    {\n\t\tif (items[i].score == SCORE_NONE)\n\t\t    break;\n\t\tif (items[i].lmatchpos != NULL\n\t\t\t&& list_append_list(retlist, items[i].lmatchpos)\n\t\t\t\t\t\t\t\t== FAIL)\n\t\t    goto done;\n\t    }\n\n\t    // copy the matching scores\n\t    li = list_find(fmatchlist, -1);\n\t    if (li == NULL || li->li_tv.vval.v_list == NULL)\n\t\tgoto done;\n\t    retlist = li->li_tv.vval.v_list;\n\t    for (i = 0; i < match_count; i++)\n\t    {\n\t\tif (items[i].score == SCORE_NONE)\n\t\t    break;\n\t\tif (list_append_number(retlist, items[i].score) == FAIL)\n\t\t    goto done;\n\t    }\n\t}\n    }\n\ndone:\n    vim_free(items);\n}\n\n/*\n * Do fuzzy matching. Returns the list of matched strings in 'rettv'.\n * If 'retmatchpos' is TRUE, also returns the matching character positions.\n */\n    static void\ndo_fuzzymatch(typval_T *argvars, typval_T *rettv, int retmatchpos)\n{\n    callback_T\tcb;\n    char_u\t*key = NULL;\n    int\t\tret;\n    int\t\tmatchseq = FALSE;\n    long\tmax_matches = 0;\n\n    if (in_vim9script()\n\t    && (check_for_list_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_dict_arg(argvars, 2) == FAIL))\n\treturn;\n\n    CLEAR_POINTER(&cb);\n\n    // validate and get the arguments\n    if (argvars[0].v_type != VAR_LIST || argvars[0].vval.v_list == NULL)\n    {\n\tsemsg(_(e_argument_of_str_must_be_list),\n\t\t\t     retmatchpos ? \"matchfuzzypos()\" : \"matchfuzzy()\");\n\treturn;\n    }\n    if (argvars[1].v_type != VAR_STRING\n\t    || argvars[1].vval.v_string == NULL)\n    {\n\tsemsg(_(e_invalid_argument_str), tv_get_string(&argvars[1]));\n\treturn;\n    }\n\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tdict_T\t\t*d;\n\tdictitem_T\t*di;\n\n\tif (argvars[2].v_type != VAR_DICT || argvars[2].vval.v_dict == NULL)\n\t{\n\t    emsg(_(e_dictionary_required));\n\t    return;\n\t}\n\n\t// To search a dict, either a callback function or a key can be\n\t// specified.\n\td = argvars[2].vval.v_dict;\n\tif ((di = dict_find(d, (char_u *)\"key\", -1)) != NULL)\n\t{\n\t    if (di->di_tv.v_type != VAR_STRING\n\t\t    || di->di_tv.vval.v_string == NULL\n\t\t    || *di->di_tv.vval.v_string == NUL)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), tv_get_string(&di->di_tv));\n\t\treturn;\n\t    }\n\t    key = tv_get_string(&di->di_tv);\n\t}\n\telse if ((di = dict_find(d, (char_u *)\"text_cb\", -1)) != NULL)\n\t{\n\t    cb = get_callback(&di->di_tv);\n\t    if (cb.cb_name == NULL)\n\t    {\n\t\tsemsg(_(e_invalid_value_for_argument_str), \"text_cb\");\n\t\treturn;\n\t    }\n\t}\n\telse if ((di = dict_find(d, (char_u *)\"limit\", -1)) != NULL)\n\t{\n\t    if (di->di_tv.v_type != VAR_NUMBER)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), tv_get_string(&di->di_tv));\n\t\treturn;\n\t    }\n\t    max_matches = (long)tv_get_number_chk(&di->di_tv, NULL);\n\t}\n\n\tif (dict_has_key(d, \"matchseq\"))\n\t    matchseq = TRUE;\n    }\n\n    // get the fuzzy matches\n    ret = rettv_list_alloc(rettv);\n    if (ret != OK)\n\tgoto done;\n    if (retmatchpos)\n    {\n\tlist_T\t*l;\n\n\t// For matchfuzzypos(), a list with three items are returned. First\n\t// item is a list of matching strings, the second item is a list of\n\t// lists with matching positions within each string and the third item\n\t// is the list of scores of the matches.\n\tl = list_alloc();\n\tif (l == NULL)\n\t    goto done;\n\tif (list_append_list(rettv->vval.v_list, l) == FAIL)\n\t    goto done;\n\tl = list_alloc();\n\tif (l == NULL)\n\t    goto done;\n\tif (list_append_list(rettv->vval.v_list, l) == FAIL)\n\t    goto done;\n\tl = list_alloc();\n\tif (l == NULL)\n\t    goto done;\n\tif (list_append_list(rettv->vval.v_list, l) == FAIL)\n\t    goto done;\n    }\n\n    fuzzy_match_in_list(argvars[0].vval.v_list, tv_get_string(&argvars[1]),\n\t    matchseq, key, &cb, retmatchpos, rettv->vval.v_list, max_matches);\n\ndone:\n    free_callback(&cb);\n}\n\n/*\n * \"matchfuzzy()\" function\n */\n    void\nf_matchfuzzy(typval_T *argvars, typval_T *rettv)\n{\n    do_fuzzymatch(argvars, rettv, FALSE);\n}\n\n/*\n * \"matchfuzzypos()\" function\n */\n    void\nf_matchfuzzypos(typval_T *argvars, typval_T *rettv)\n{\n    do_fuzzymatch(argvars, rettv, TRUE);\n}\n#endif\n\n/*\n * Same as fuzzy_match_item_compare() except for use with a string match\n */\n    static int\nfuzzy_match_str_compare(const void *s1, const void *s2)\n{\n    int\t\tv1 = ((fuzmatch_str_T *)s1)->score;\n    int\t\tv2 = ((fuzmatch_str_T *)s2)->score;\n    int\t\tidx1 = ((fuzmatch_str_T *)s1)->idx;\n    int\t\tidx2 = ((fuzmatch_str_T *)s2)->idx;\n\n    return v1 == v2 ? (idx1 - idx2) : v1 > v2 ? -1 : 1;\n}\n\n/*\n * Sort fuzzy matches by score\n */\n    static void\nfuzzy_match_str_sort(fuzmatch_str_T *fm, int sz)\n{\n    // Sort the list by the descending order of the match score\n    qsort((void *)fm, (size_t)sz, sizeof(fuzmatch_str_T),\n\t    fuzzy_match_str_compare);\n}\n\n/*\n * Same as fuzzy_match_item_compare() except for use with a function name\n * string match. <SNR> functions should be sorted to the end.\n */\n    static int\nfuzzy_match_func_compare(const void *s1, const void *s2)\n{\n    int\t\tv1 = ((fuzmatch_str_T *)s1)->score;\n    int\t\tv2 = ((fuzmatch_str_T *)s2)->score;\n    int\t\tidx1 = ((fuzmatch_str_T *)s1)->idx;\n    int\t\tidx2 = ((fuzmatch_str_T *)s2)->idx;\n    char_u\t*str1 = ((fuzmatch_str_T *)s1)->str;\n    char_u\t*str2 = ((fuzmatch_str_T *)s2)->str;\n\n    if (*str1 != '<' && *str2 == '<') return -1;\n    if (*str1 == '<' && *str2 != '<') return 1;\n    return v1 == v2 ? (idx1 - idx2) : v1 > v2 ? -1 : 1;\n}\n\n/*\n * Sort fuzzy matches of function names by score.\n * <SNR> functions should be sorted to the end.\n */\n    static void\nfuzzy_match_func_sort(fuzmatch_str_T *fm, int sz)\n{\n    // Sort the list by the descending order of the match score\n    qsort((void *)fm, (size_t)sz, sizeof(fuzmatch_str_T),\n\t\tfuzzy_match_func_compare);\n}\n\n/*\n * Fuzzy match 'pat' in 'str'. Returns 0 if there is no match. Otherwise,\n * returns the match score.\n */\n    int\nfuzzy_match_str(char_u *str, char_u *pat)\n{\n    int\t\tscore = 0;\n    int_u\tmatchpos[MAX_FUZZY_MATCHES];\n\n    if (str == NULL || pat == NULL)\n\treturn 0;\n\n    fuzzy_match(str, pat, TRUE, &score, matchpos,\n\t\t\t\tsizeof(matchpos) / sizeof(matchpos[0]));\n\n    return score;\n}\n\n/*\n * Free an array of fuzzy string matches \"fuzmatch[count]\".\n */\n    void\nfuzmatch_str_free(fuzmatch_str_T *fuzmatch, int count)\n{\n    int i;\n\n    if (fuzmatch == NULL)\n\treturn;\n    for (i = 0; i < count; ++i)\n\tvim_free(fuzmatch[i].str);\n    vim_free(fuzmatch);\n}\n\n/*\n * Copy a list of fuzzy matches into a string list after sorting the matches by\n * the fuzzy score. Frees the memory allocated for 'fuzmatch'.\n * Returns OK on success and FAIL on memory allocation failure.\n */\n    int\nfuzzymatches_to_strmatches(\n\tfuzmatch_str_T\t*fuzmatch,\n\tchar_u\t\t***matches,\n\tint\t\tcount,\n\tint\t\tfuncsort)\n{\n    int\t\ti;\n\n    if (count <= 0)\n\treturn OK;\n\n    *matches = ALLOC_MULT(char_u *, count);\n    if (*matches == NULL)\n    {\n\tfuzmatch_str_free(fuzmatch, count);\n\treturn FAIL;\n    }\n\n    // Sort the list by the descending order of the match score\n    if (funcsort)\n\tfuzzy_match_func_sort((void *)fuzmatch, (size_t)count);\n    else\n\tfuzzy_match_str_sort((void *)fuzmatch, (size_t)count);\n\n    for (i = 0; i < count; i++)\n\t(*matches)[i] = fuzmatch[i].str;\n    vim_free(fuzmatch);\n\n    return OK;\n}\n", "\" Tests for tagjump (tags and special searches)\n\nsource check.vim\nsource screendump.vim\n\n\" SEGV occurs in older versions.  (At least 7.4.1748 or older)\nfunc Test_ptag_with_notagstack()\n  CheckFeature quickfix\n\n  set notagstack\n  call assert_fails('ptag does_not_exist_tag_name', 'E433:')\n  set tagstack&vim\nendfunc\n\nfunc Test_ptjump()\n  CheckFeature quickfix\n\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"one\\tXfile\\t1\",\n        \\ \"three\\tXfile\\t3\",\n        \\ \"two\\tXfile\\t2\"],\n        \\ 'Xtags')\n  call writefile(['one', 'two', 'three'], 'Xfile')\n\n  %bw!\n  ptjump two\n  call assert_equal(2, winnr())\n  wincmd p\n  call assert_equal(1, &previewwindow)\n  call assert_equal('Xfile', expand(\"%:p:t\"))\n  call assert_equal(2, line('.'))\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, winnr())\n  close\n  call setline(1, ['one', 'two', 'three'])\n  exe \"normal 3G\\<C-W>g}\"\n  call assert_equal(2, winnr())\n  wincmd p\n  call assert_equal(1, &previewwindow)\n  call assert_equal('Xfile', expand(\"%:p:t\"))\n  call assert_equal(3, line('.'))\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, winnr())\n  close\n  exe \"normal 3G5\\<C-W>\\<C-G>}\"\n  wincmd p\n  call assert_equal(5, winheight(0))\n  close\n\n  call delete('Xtags')\n  call delete('Xfile')\n  set tags&\nendfunc\n\nfunc Test_cancel_ptjump()\n  CheckFeature quickfix\n\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"word\\tfile1\\tcmd1\",\n        \\ \"word\\tfile2\\tcmd2\"],\n        \\ 'Xtags')\n\n  only!\n  call feedkeys(\":ptjump word\\<CR>\\<CR>\", \"xt\")\n  help\n  call assert_equal(2, winnr('$'))\n\n  call delete('Xtags')\n  set tags&\n  quit\nendfunc\n\nfunc Test_static_tagjump()\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"one\\tXfile1\\t/^one/;\\\"\\tf\\tfile:\\tsignature:(void)\",\n        \\ \"word\\tXfile2\\tcmd2\"],\n        \\ 'Xtags')\n  new Xfile1\n  call setline(1, ['empty', 'one()', 'empty'])\n  write\n  tag one\n  call assert_equal(2, line('.'))\n\n  bwipe!\n  set tags&\n  call delete('Xtags')\n  call delete('Xfile1')\nendfunc\n\nfunc Test_duplicate_tagjump()\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"thesame\\tXfile1\\t1;\\\"\\td\\tfile:\",\n        \\ \"thesame\\tXfile1\\t2;\\\"\\td\\tfile:\",\n        \\ \"thesame\\tXfile1\\t3;\\\"\\td\\tfile:\",\n        \\ ],\n        \\ 'Xtags')\n  new Xfile1\n  call setline(1, ['thesame one', 'thesame two', 'thesame three'])\n  write\n  tag thesame\n  call assert_equal(1, line('.'))\n  tnext\n  call assert_equal(2, line('.'))\n  tnext\n  call assert_equal(3, line('.'))\n\n  bwipe!\n  set tags&\n  call delete('Xtags')\n  call delete('Xfile1')\nendfunc\n\nfunc Test_tagjump_switchbuf()\n  CheckFeature quickfix\n\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"second\\tXfile1\\t2\",\n        \\ \"third\\tXfile1\\t3\",],\n        \\ 'Xtags')\n  call writefile(['first', 'second', 'third'], 'Xfile1')\n\n  enew | only\n  set switchbuf=\n  stag second\n  call assert_equal(2, winnr('$'))\n  call assert_equal(2, line('.'))\n  stag third\n  call assert_equal(3, winnr('$'))\n  call assert_equal(3, line('.'))\n\n  enew | only\n  set switchbuf=useopen\n  stag second\n  call assert_equal(2, winnr('$'))\n  call assert_equal(2, line('.'))\n  stag third\n  call assert_equal(2, winnr('$'))\n  call assert_equal(3, line('.'))\n\n  enew | only\n  set switchbuf=usetab\n  tab stag second\n  call assert_equal(2, tabpagenr('$'))\n  call assert_equal(2, line('.'))\n  1tabnext | stag third\n  call assert_equal(2, tabpagenr('$'))\n  call assert_equal(3, line('.'))\n\n  tabclose!\n  enew | only\n  call delete('Xfile1')\n  call delete('Xtags')\n  set tags&\n  set switchbuf&vim\nendfunc\n\n\" Tests for [ CTRL-I and CTRL-W CTRL-I commands\nfunction Test_keyword_jump()\n  call writefile([\"#include Xinclude\", \"\",\n\t      \\ \"\",\n\t      \\ \"/* test text test tex start here\",\n\t      \\ \"\t\tsome text\",\n\t      \\ \"\t\ttest text\",\n\t      \\ \"\t\tstart OK if found this line\",\n\t      \\ \"\tstart found wrong line\",\n\t      \\ \"test text\"], 'Xtestfile')\n  call writefile([\"/* test text test tex start here\",\n\t      \\ \"\t\tsome text\",\n\t      \\ \"\t\ttest text\",\n\t      \\ \"\t\tstart OK if found this line\",\n\t      \\ \"\tstart found wrong line\",\n\t      \\ \"test text\"], 'Xinclude')\n  new Xtestfile\n  call cursor(1,1)\n  call search(\"start\")\n  exe \"normal! 5[\\<C-I>\"\n  call assert_equal(\"\t\tstart OK if found this line\", getline('.'))\n  call cursor(1,1)\n  call search(\"start\")\n  exe \"normal! 5\\<C-W>\\<C-I>\"\n  call assert_equal(\"\t\tstart OK if found this line\", getline('.'))\n\n  \" invalid tag search pattern\n  call assert_fails('tag /\\%(/', 'E426:')\n\n  enew! | only\n  call delete('Xtestfile')\n  call delete('Xinclude')\nendfunction\n\n\" Test for jumping to a tag with 'hidden' set, with symbolic link in path of\n\" tag.  This only works for Unix, because of the symbolic link.\nfunc Test_tag_symbolic()\n  CheckUnix\n\n  set hidden\n  call delete(\"Xtest.dir\", \"rf\")\n  call system(\"ln -s . Xtest.dir\")\n  \" Create a tags file with the current directory name inserted.\n  call writefile([\n        \\ \"SECTION_OFF\t\" . getcwd() . \"/Xtest.dir/Xtest.c\t/^#define  SECTION_OFF  3$/\",\n        \\ '',\n        \\ ], 'Xtags')\n  call writefile(['#define  SECTION_OFF  3',\n        \\ '#define  NUM_SECTIONS 3'], 'Xtest.c')\n\n  \" Try jumping to a tag, but with a path that contains a symbolic link.  When\n  \" wrong, this will give the ATTENTION message.  The next space will then be\n  \" eaten by hit-return, instead of moving the cursor to 'd'.\n  set tags=Xtags\n  enew!\n  call append(0, 'SECTION_OFF')\n  call cursor(1,1)\n  exe \"normal \\<C-]> \"\n  call assert_equal('Xtest.c', expand('%:t'))\n  call assert_equal(2, col('.'))\n\n  set hidden&\n  set tags&\n  enew!\n  call delete('Xtags')\n  call delete('Xtest.c')\n  call delete(\"Xtest.dir\", \"rf\")\n  %bwipe!\nendfunc\n\n\" Tests for tag search with !_TAG_FILE_ENCODING.\nfunc Test_tag_file_encoding()\n  if has('vms')\n    throw 'Skipped: does not work on VMS'\n  endif\n\n  if !has('iconv') || iconv(\"\\x82\\x60\", \"cp932\", \"utf-8\") != \"\\uff21\"\n    throw 'Skipped: iconv does not work'\n  endif\n\n  let save_enc = &encoding\n  set encoding=utf8\n\n  let content = ['text for tags1', 'abcdefghijklmnopqrs']\n  call writefile(content, 'Xtags1.txt')\n  let content = ['text for tags2', '\uff21\uff22\uff23']\n  call writefile(content, 'Xtags2.txt')\n  let content = ['text for tags3', '\uff21\uff22\uff23']\n  call writefile(content, 'Xtags3.txt')\n  let content = ['!_TAG_FILE_ENCODING\tutf-8\t//', 'abcdefghijklmnopqrs\tXtags1.txt\t/abcdefghijklmnopqrs']\n  call writefile(content, 'Xtags1')\n\n  \" case1:\n  new\n  set tags=Xtags1\n  tag abcdefghijklmnopqrs\n  call assert_equal('Xtags1.txt', expand('%:t'))\n  call assert_equal('abcdefghijklmnopqrs', getline('.'))\n  close\n\n  \" case2:\n  new\n  let content = ['!_TAG_FILE_ENCODING\tcp932\t//',\n        \\ \"\\x82`\\x82a\\x82b\tXtags2.txt\t/\\x82`\\x82a\\x82b\"]\n  call writefile(content, 'Xtags')\n  set tags=Xtags\n  tag /.\uff22\uff23\n  call assert_equal('Xtags2.txt', expand('%:t'))\n  call assert_equal('\uff21\uff22\uff23', getline('.'))\n  call delete('Xtags')\n  close\n\n  \" case3:\n  new\n  let contents = [\n      \\ \"!_TAG_FILE_SORTED\t1\t//\",\n      \\ \"!_TAG_FILE_ENCODING\tcp932\t//\"]\n  for i in range(1, 100)\n      call add(contents, 'abc' .. i\n            \\ .. \"\tXtags3.txt\t/\\x82`\\x82a\\x82b\")\n  endfor\n  call writefile(contents, 'Xtags')\n  set tags=Xtags\n  tag abc50\n  call assert_equal('Xtags3.txt', expand('%:t'))\n  call assert_equal('\uff21\uff22\uff23', getline('.'))\n  call delete('Xtags')\n  close\n\n  set tags&\n  let &encoding = save_enc\n  call delete('Xtags1.txt')\n  call delete('Xtags2.txt')\n  call delete('Xtags3.txt')\n  call delete('Xtags1')\nendfunc\n\n\" Test for emacs-style tags file (TAGS)\nfunc Test_tagjump_etags()\n  CheckFeature emacs_tags\n\n  call writefile([\n        \\ \"void foo() {}\",\n        \\ \"int main(int argc, char **argv)\",\n        \\ \"{\",\n        \\ \"\\tfoo();\",\n        \\ \"\\treturn 0;\",\n        \\ \"}\",\n        \\ ], 'Xmain.c')\n\n  call writefile([\n\t\\ \"\\x0c\",\n        \\ \"Xmain.c,64\",\n        \\ \"void foo() {}\\x7ffoo\\x011,0\",\n        \\ \"int main(int argc, char **argv)\\x7fmain\\x012,14\",\n\t\\ ], 'Xtags')\n  set tags=Xtags\n  ta foo\n  call assert_equal('void foo() {}', getline('.'))\n\n  \" Test for including another tags file\n  call writefile([\n        \\ \"\\x0c\",\n        \\ \"Xmain.c,64\",\n        \\ \"void foo() {}\\x7ffoo\\x011,0\",\n        \\ \"\\x0c\",\n        \\ \"Xnonexisting,include\",\n        \\ \"\\x0c\",\n        \\ \"Xtags2,include\"\n        \\ ], 'Xtags')\n  call writefile([\n        \\ \"\\x0c\",\n        \\ \"Xmain.c,64\",\n        \\ \"int main(int argc, char **argv)\\x7fmain\\x012,14\",\n        \\ ], 'Xtags2')\n  tag main\n  call assert_equal(2, line('.'))\n  call assert_fails('tag bar', 'E426:')\n\n  \" corrupted tag line\n  call writefile([\n        \\ \"\\x0c\",\n        \\ \"Xmain.c,8\",\n        \\ \"int main\"\n        \\ ], 'Xtags', 'b')\n  call assert_fails('tag foo', 'E426:')\n\n  \" invalid line number\n  call writefile([\n\t\\ \"\\x0c\",\n        \\ \"Xmain.c,64\",\n        \\ \"void foo() {}\\x7ffoo\\x0abc,0\",\n\t\\ ], 'Xtags')\n  call assert_fails('tag foo', 'E426:')\n\n  \" invalid tag name\n  call writefile([\n\t\\ \"\\x0c\",\n        \\ \"Xmain.c,64\",\n        \\ \";;;;\\x7f1,0\",\n\t\\ ], 'Xtags')\n  call assert_fails('tag foo', 'E431:')\n\n  \" end of file after a CTRL-L line\n  call writefile([\n\t\\ \"\\x0c\",\n        \\ \"Xmain.c,64\",\n        \\ \"void foo() {}\\x7ffoo\\x011,0\",\n\t\\ \"\\x0c\",\n\t\\ ], 'Xtags')\n  call assert_fails('tag main', 'E426:')\n\n  \" error in an included tags file\n  call writefile([\n        \\ \"\\x0c\",\n        \\ \"Xtags2,include\"\n        \\ ], 'Xtags')\n  call writefile([\n        \\ \"\\x0c\",\n        \\ \"Xmain.c,64\",\n        \\ \"void foo() {}\",\n        \\ ], 'Xtags2')\n  call assert_fails('tag foo', 'E431:')\n\n  call delete('Xtags')\n  call delete('Xtags2')\n  call delete('Xmain.c')\n  set tags&\n  bwipe!\nendfunc\n\n\" Test for getting and modifying the tag stack\nfunc Test_getsettagstack()\n  call writefile(['line1', 'line2', 'line3'], 'Xfile1')\n  call writefile(['line1', 'line2', 'line3'], 'Xfile2')\n  call writefile(['line1', 'line2', 'line3'], 'Xfile3')\n\n  enew | only\n  call settagstack(1, {'items' : []})\n  call assert_equal(0, gettagstack(1).length)\n  call assert_equal([], 1->gettagstack().items)\n  \" Error cases\n  call assert_equal({}, gettagstack(100))\n  call assert_equal(-1, settagstack(100, {'items' : []}))\n  call assert_fails('call settagstack(1, [1, 10])', 'E715:')\n  call assert_fails(\"call settagstack(1, {'items' : 10})\", 'E714:')\n  call assert_fails(\"call settagstack(1, {'items' : []}, 10)\", 'E928:')\n  call assert_fails(\"call settagstack(1, {'items' : []}, 'b')\", 'E962:')\n  call assert_equal(-1, settagstack(0, test_null_dict()))\n\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"one\\tXfile1\\t1\",\n        \\ \"three\\tXfile3\\t3\",\n        \\ \"two\\tXfile2\\t2\"],\n        \\ 'Xtags')\n\n  let stk = []\n  call add(stk, {'bufnr' : bufnr('%'), 'tagname' : 'one',\n\t\\ 'from' : [bufnr('%'), line('.'), col('.'), 0], 'matchnr' : 1})\n  tag one\n  call add(stk, {'bufnr' : bufnr('%'), 'tagname' : 'two',\n\t\\ 'from' : [bufnr('%'), line('.'), col('.'), 0], 'matchnr' : 1})\n  tag two\n  call add(stk, {'bufnr' : bufnr('%'), 'tagname' : 'three',\n\t\\ 'from' : [bufnr('%'), line('.'), col('.'), 0], 'matchnr' : 1})\n  tag three\n  call assert_equal(3, gettagstack(1).length)\n  call assert_equal(stk, gettagstack(1).items)\n  \" Check for default - current window\n  call assert_equal(3, gettagstack().length)\n  call assert_equal(stk, gettagstack().items)\n\n  \" Try to set current index to invalid values\n  call settagstack(1, {'curidx' : -1})\n  call assert_equal(1, gettagstack().curidx)\n  eval {'curidx' : 50}->settagstack(1)\n  call assert_equal(4, gettagstack().curidx)\n\n  \" Try pushing invalid items onto the stack\n  call settagstack(1, {'items' : []})\n  call settagstack(1, {'items' : [\"plate\"]}, 'a')\n  call assert_equal(0, gettagstack().length)\n  call assert_equal([], gettagstack().items)\n  call settagstack(1, {'items' : [{\"tagname\" : \"abc\"}]}, 'a')\n  call assert_equal(0, gettagstack().length)\n  call assert_equal([], gettagstack().items)\n  call settagstack(1, {'items' : [{\"from\" : 100}]}, 'a')\n  call assert_equal(0, gettagstack().length)\n  call assert_equal([], gettagstack().items)\n  call settagstack(1, {'items' : [{\"from\" : [2, 1, 0, 0]}]}, 'a')\n  call assert_equal(0, gettagstack().length)\n  call assert_equal([], gettagstack().items)\n\n  \" Push one item at a time to the stack\n  call settagstack(1, {'items' : []})\n  call settagstack(1, {'items' : [stk[0]]}, 'a')\n  call settagstack(1, {'items' : [stk[1]]}, 'a')\n  call settagstack(1, {'items' : [stk[2]]}, 'a')\n  call settagstack(1, {'curidx' : 4})\n  call assert_equal({'length' : 3, 'curidx' : 4, 'items' : stk},\n        \\ gettagstack(1))\n\n  \" Try pushing items onto a full stack\n  for i in range(7)\n    call settagstack(1, {'items' : stk}, 'a')\n  endfor\n  call assert_equal(20, gettagstack().length)\n  call settagstack(1,\n        \\ {'items' : [{'tagname' : 'abc', 'from' : [1, 10, 1, 0]}]}, 'a')\n  call assert_equal('abc', gettagstack().items[19].tagname)\n\n  \" truncate the tag stack\n  call settagstack(1,\n        \\ {'curidx' : 9,\n        \\  'items' : [{'tagname' : 'abc', 'from' : [1, 10, 1, 0]}]}, 't')\n  let t = gettagstack()\n  call assert_equal(9, t.length)\n  call assert_equal(10, t.curidx)\n\n  \" truncate the tag stack without pushing any new items\n  call settagstack(1, {'curidx' : 5}, 't')\n  let t = gettagstack()\n  call assert_equal(4, t.length)\n  call assert_equal(5, t.curidx)\n\n  \" truncate an empty tag stack and push new items\n  call settagstack(1, {'items' : []})\n  call settagstack(1,\n        \\ {'items' : [{'tagname' : 'abc', 'from' : [1, 10, 1, 0]}]}, 't')\n  let t = gettagstack()\n  call assert_equal(1, t.length)\n  call assert_equal(2, t.curidx)\n\n  \" Tag with multiple matches\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"two\\tXfile1\\t1\",\n        \\ \"two\\tXfile2\\t3\",\n        \\ \"two\\tXfile3\\t2\"],\n        \\ 'Xtags')\n  call settagstack(1, {'items' : []})\n  tag two\n  tnext\n  tnext\n  call assert_equal(1, gettagstack().length)\n  call assert_equal(3, gettagstack().items[0].matchnr)\n\n  \" Memory allocation failures\n  call test_alloc_fail(GetAllocId('tagstack_items'), 0, 0)\n  call assert_fails('call gettagstack()', 'E342:')\n  call test_alloc_fail(GetAllocId('tagstack_from'), 0, 0)\n  call assert_fails('call gettagstack()', 'E342:')\n  call test_alloc_fail(GetAllocId('tagstack_details'), 0, 0)\n  call assert_fails('call gettagstack()', 'E342:')\n\n  call settagstack(1, {'items' : []})\n  call delete('Xfile1')\n  call delete('Xfile2')\n  call delete('Xfile3')\n  call delete('Xtags')\n  set tags&\nendfunc\n\nfunc Test_tag_with_count()\n  call writefile([\n\t\\ 'test\tXtest.h\t/^void test();$/;\"\tp\ttyperef:typename:void\tsignature:()',\n\t\\ ], 'Xtags')\n  call writefile([\n\t\\ 'main\tXtest.c\t/^int main()$/;\"\tf\ttyperef:typename:int\tsignature:()',\n\t\\ 'test\tXtest.c\t/^void test()$/;\"\tf\ttyperef:typename:void\tsignature:()',\n\t\\ ], 'Ytags')\n  cal writefile([\n\t\\ 'int main()',\n\t\\ 'void test()',\n\t\\ ], 'Xtest.c')\n  cal writefile([\n\t\\ 'void test();',\n\t\\ ], 'Xtest.h')\n  set tags=Xtags,Ytags\n\n  new Xtest.c\n  let tl = taglist('test', 'Xtest.c')\n  call assert_equal(tl[0].filename, 'Xtest.c')\n  call assert_equal(tl[1].filename, 'Xtest.h')\n\n  tag test\n  call assert_equal(bufname('%'), 'Xtest.c')\n  1tag test\n  call assert_equal(bufname('%'), 'Xtest.c')\n  2tag test\n  call assert_equal(bufname('%'), 'Xtest.h')\n\n  set tags&\n  call delete('Xtags')\n  call delete('Ytags')\n  bwipe Xtest.h\n  bwipe Xtest.c\n  call delete('Xtest.h')\n  call delete('Xtest.c')\nendfunc\n\nfunc Test_tagnr_recall()\n  call writefile([\n\t\\ 'test\tXtest.h\t/^void test();$/;\"\tp',\n\t\\ 'main\tXtest.c\t/^int main()$/;\"\tf',\n\t\\ 'test\tXtest.c\t/^void test()$/;\"\tf',\n\t\\ ], 'Xtags')\n  cal writefile([\n\t\\ 'int main()',\n\t\\ 'void test()',\n\t\\ ], 'Xtest.c')\n  cal writefile([\n\t\\ 'void test();',\n\t\\ ], 'Xtest.h')\n  set tags=Xtags\n\n  new Xtest.c\n  let tl = taglist('test', 'Xtest.c')\n  call assert_equal(tl[0].filename, 'Xtest.c')\n  call assert_equal(tl[1].filename, 'Xtest.h')\n\n  2tag test\n  call assert_equal(bufname('%'), 'Xtest.h')\n  pop\n  call assert_equal(bufname('%'), 'Xtest.c')\n  tag\n  call assert_equal(bufname('%'), 'Xtest.h')\n\n  set tags&\n  call delete('Xtags')\n  bwipe Xtest.h\n  bwipe Xtest.c\n  call delete('Xtest.h')\n  call delete('Xtest.c')\nendfunc\n\nfunc Test_tag_line_toolong()\n  call writefile([\n\t\\ '1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678\tdjango/contrib/admin/templates/admin/edit_inline/stacked.html\t16;\"\tj\tline:16\tlanguage:HTML'\n\t\\ ], 'Xtags')\n  set tags=Xtags\n  let old_vbs = &verbose\n  set verbose=5\n  \" \":tjump\" should give \"tag not found\" not \"Format error in tags file\"\n  call assert_fails('tj /foo', 'E426:')\n  try\n    tj /foo\n  catch /^Vim\\%((\\a\\+)\\)\\=:E431/\n    call assert_report(v:exception)\n  catch /.*/\n  endtry\n  call assert_equal('Searching tags file Xtags', split(execute('messages'), '\\n')[-1])\n\n  call writefile([\n\t\\ '123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567\tdjango/contrib/admin/templates/admin/edit_inline/stacked.html\t16;\"\tj\tline:16\tlanguage:HTML'\n\t\\ ], 'Xtags')\n  call assert_fails('tj /foo', 'E426:')\n  try\n    tj /foo\n  catch /^Vim\\%((\\a\\+)\\)\\=:E431/\n    call assert_report(v:exception)\n  catch /.*/\n  endtry\n  call assert_equal('Searching tags file Xtags', split(execute('messages'), '\\n')[-1])\n\n  \" binary search works in file with long line\n  call writefile([\n        \\ 'asdfasfd\tnowhere\t16',\n\t\\ 'foobar\tXsomewhere\t3; \" 12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567',\n        \\ 'zasdfasfd\tnowhere\t16',\n\t\\ ], 'Xtags')\n  call writefile([\n        \\ 'one',\n        \\ 'two',\n        \\ 'trhee',\n        \\ 'four',\n        \\ ], 'Xsomewhere')\n  tag foobar\n  call assert_equal('Xsomewhere', expand('%'))\n  call assert_equal(3, getcurpos()[1])\n\n  \" expansion on command line works with long lines when &wildoptions contains\n  \" 'tagfile'\n  set wildoptions=tagfile\n  call writefile([\n\t\\ 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\tfile\t/^pattern$/;\"\tf'\n\t\\ ], 'Xtags')\n  call feedkeys(\":tag \\<Tab>\", 'tx')\n  \" Should not crash\n  call assert_true(v:true)\n\n  call delete('Xtags')\n  call delete('Xsomewhere')\n  set tags&\n  let &verbose = old_vbs\nendfunc\n\n\" Check that using :tselect does not run into the hit-enter prompt.\n\" Requires a terminal to trigger that prompt.\nfunc Test_tselect()\n  CheckScreendump\n\n  call writefile([\n\t\\ 'main\tXtest.h\t/^void test();$/;\"\tf',\n\t\\ 'main\tXtest.c\t/^int main()$/;\"\tf',\n\t\\ 'main\tXtest.x\t/^void test()$/;\"\tf',\n\t\\ ], 'Xtags')\n  cal writefile([\n\t\\ 'int main()',\n\t\\ 'void test()',\n\t\\ ], 'Xtest.c')\n\n  let lines =<< trim [SCRIPT]\n    set tags=Xtags\n  [SCRIPT]\n  call writefile(lines, 'XTest_tselect')\n  let buf = RunVimInTerminal('-S XTest_tselect', {'rows': 10, 'cols': 50})\n\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":tselect main\\<CR>2\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_tselect_1', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xtags')\n  call delete('Xtest.c')\n  call delete('XTest_tselect')\nendfunc\n\nfunc Test_tagline()\n  call writefile([\n\t\\ 'provision\tXtest.py\t/^    def provision(self, **kwargs):$/;\"\tm\tline:1\tlanguage:Python class:Foo',\n\t\\ 'provision\tXtest.py\t/^    def provision(self, **kwargs):$/;\"\tm\tline:3\tlanguage:Python class:Bar',\n\t\\], 'Xtags')\n  call writefile([\n\t\\ '    def provision(self, **kwargs):',\n\t\\ '        pass',\n\t\\ '    def provision(self, **kwargs):',\n\t\\ '        pass',\n\t\\], 'Xtest.py')\n\n  set tags=Xtags\n\n  1tag provision\n  call assert_equal(line('.'), 1)\n  2tag provision\n  call assert_equal(line('.'), 3)\n\n  call delete('Xtags')\n  call delete('Xtest.py')\n  set tags&\nendfunc\n\n\" Test for expanding environment variable in a tag file name\nfunc Test_tag_envvar()\n  call writefile([\"Func1\\t$FOO\\t/^Func1/\"], 'Xtags')\n  set tags=Xtags\n\n  let $FOO='TagTestEnv'\n\n  let caught_exception = v:false\n  try\n    tag Func1\n  catch /E429:/\n    call assert_match('E429:.*\"TagTestEnv\".*', v:exception)\n    let caught_exception = v:true\n  endtry\n  call assert_true(caught_exception)\n\n  set tags&\n  call delete('Xtags')\n  unlet $FOO\nendfunc\n\n\" Test for :ptag\nfunc Test_tag_preview()\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"second\\tXfile1\\t2\",\n        \\ \"third\\tXfile1\\t3\",],\n        \\ 'Xtags')\n  set tags=Xtags\n  call writefile(['first', 'second', 'third'], 'Xfile1')\n\n  enew | only\n  ptag third\n  call assert_equal(2, winnr())\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, getwinvar(1, '&previewwindow'))\n  call assert_equal(0, getwinvar(2, '&previewwindow'))\n  wincmd P\n  call assert_equal(3, line('.'))\n\n  \" jump to the tag again\n  wincmd w\n  ptag third\n  wincmd P\n  call assert_equal(3, line('.'))\n\n  \" jump to the newer tag\n  wincmd w\n  ptag\n  wincmd P\n  call assert_equal(3, line('.'))\n\n  \" close the preview window\n  pclose\n  call assert_equal(1, winnr('$'))\n\n  call delete('Xfile1')\n  call delete('Xtags')\n  set tags&\nendfunc\n\n\" Tests for guessing the tag location\nfunc Test_tag_guess()\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"func1\\tXfoo\\t/^int func1(int x)/\",\n        \\ \"func2\\tXfoo\\t/^int func2(int y)/\",\n        \\ \"func3\\tXfoo\\t/^func3/\",\n        \\ \"func4\\tXfoo\\t/^func4/\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n\n    int FUNC1  (int x) { }\n    int \n    func2   (int y) { }\n    int * func3 () { }\n\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  let v:statusmsg = ''\n  ta func1\n  call assert_match('E435:', v:statusmsg)\n  call assert_equal(2, line('.'))\n  let v:statusmsg = ''\n  ta func2\n  call assert_match('E435:', v:statusmsg)\n  call assert_equal(4, line('.'))\n  let v:statusmsg = ''\n  ta func3\n  call assert_match('E435:', v:statusmsg)\n  call assert_equal(5, line('.'))\n  call assert_fails('ta func4', 'E434:')\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\nendfunc\n\n\" Test for an unsorted tags file\nfunc Test_tag_sort()\n  let l = [\n        \\ \"first\\tXfoo\\t1\",\n        \\ \"ten\\tXfoo\\t3\",\n        \\ \"six\\tXfoo\\t2\"]\n  call writefile(l, 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int six() {}\n    int ten() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  call assert_fails('tag first', 'E432:')\n\n  \" When multiple tag files are not sorted, then message should be displayed\n  \" multiple times\n  call writefile(l, 'Xtags2')\n  set tags=Xtags,Xtags2\n  call assert_fails('tag first', ['E432:', 'E432:'])\n\n  call delete('Xtags')\n  call delete('Xtags2')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for an unsorted tags file\nfunc Test_tag_fold()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"!_TAG_FILE_SORTED\\t2\\t/0=unsorted, 1=sorted, 2=foldcase/\",\n        \\ \"first\\tXfoo\\t1\",\n        \\ \"second\\tXfoo\\t2\",\n        \\ \"third\\tXfoo\\t3\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int second() {}\n    int third() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  enew\n  tag second\n  call assert_equal('Xfoo', bufname(''))\n  call assert_equal(2, line('.'))\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for the :ltag command\nfunc Test_ltag()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo\\t1\",\n        \\ \"second\\tXfoo\\t/^int second() {}$/\",\n        \\ \"third\\tXfoo\\t3\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int second() {}\n    int third() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  enew\n  call setloclist(0, [], 'f')\n  ltag third\n  call assert_equal('Xfoo', bufname(''))\n  call assert_equal(3, line('.'))\n  call assert_equal([{'lnum': 3, 'end_lnum': 0, 'bufnr': bufnr('Xfoo'),\n        \\ 'col': 0, 'end_col': 0, 'pattern': '', 'valid': 1, 'vcol': 0,\n        \\ 'nr': 0, 'type': '', 'module': '', 'text': 'third'}], getloclist(0))\n\n  ltag second\n  call assert_equal(2, line('.'))\n  call assert_equal([{'lnum': 0, 'end_lnum': 0, 'bufnr': bufnr('Xfoo'),\n        \\ 'col': 0, 'end_col': 0, 'pattern': '^\\Vint second() {}\\$',\n        \\ 'valid': 1, 'vcol': 0, 'nr': 0, 'type': '', 'module': '',\n        \\ 'text': 'second'}], getloclist(0))\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for setting the last search pattern to the tag search pattern\n\" when cpoptions has 't'\nfunc Test_tag_last_search_pat()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo\\t/^int first() {}/\",\n        \\ \"second\\tXfoo\\t/^int second() {}/\",\n        \\ \"third\\tXfoo\\t/^int third() {}/\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int second() {}\n    int third() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  enew\n  let save_cpo = &cpo\n  set cpo+=t\n  let @/ = ''\n  tag second\n  call assert_equal('^int second() {}', @/)\n  let &cpo = save_cpo\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Tag stack tests\nfunc Test_tag_stack()\n  let l = []\n  for i in range(10, 31)\n    let l += [\"var\" .. i .. \"\\tXfoo\\t/^int var\" .. i .. \";$/\"]\n  endfor\n  call writefile(l, 'Xtags')\n  set tags=Xtags\n\n  let l = []\n  for i in range(10, 31)\n    let l += [\"int var\" .. i .. \";\"]\n  endfor\n  call writefile(l, 'Xfoo')\n\n  \" Jump to a tag when the tag stack is full. Oldest entry should be removed.\n  enew\n  for i in range(10, 30)\n    exe \"tag var\" .. i\n  endfor\n  let l = gettagstack()\n  call assert_equal(20, l.length)\n  call assert_equal('var11', l.items[0].tagname)\n  tag var31\n  let l = gettagstack()\n  call assert_equal('var12', l.items[0].tagname)\n  call assert_equal('var31', l.items[19].tagname)\n\n  \" Use tnext with a single match\n  call assert_fails('tnext', 'E427:')\n\n  \" Jump to newest entry from the top of the stack\n  call assert_fails('tag', 'E556:')\n\n  \" Pop with zero count from the top of the stack\n  call assert_fails('0pop', 'E556:')\n\n  \" Pop from an unsaved buffer\n  enew!\n  call append(1, \"sample text\")\n  call assert_fails('pop', 'E37:')\n  call assert_equal(21, gettagstack().curidx)\n  enew!\n\n  \" Pop all the entries in the tag stack\n  call assert_fails('30pop', 'E555:')\n\n  \" Pop with a count when already at the bottom of the stack\n  call assert_fails('exe \"normal 4\\<C-T>\"', 'E555:')\n  call assert_equal(1, gettagstack().curidx)\n\n  \" Jump to newest entry from the bottom of the stack with zero count\n  call assert_fails('0tag', 'E555:')\n\n  \" Pop the tag stack when it is empty\n  call settagstack(1, {'items' : []})\n  call assert_fails('pop', 'E73:')\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for browsing multiple matching tags\nfunc Test_tag_multimatch()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo\\t1\",\n        \\ \"first\\tXfoo\\t2\",\n        \\ \"first\\tXfoo\\t3\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int first() {}\n    int first() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  call settagstack(1, {'items' : []})\n  tag first\n  tlast\n  call assert_equal(3, line('.'))\n  call assert_fails('tnext', 'E428:')\n  tfirst\n  call assert_equal(1, line('.'))\n  call assert_fails('tprev', 'E425:')\n\n  tlast\n  call feedkeys(\"5\\<CR>\", 't')\n  tselect first\n  call assert_equal(2, gettagstack().curidx)\n\n  set ignorecase\n  tag FIRST\n  tnext\n  call assert_equal(2, line('.'))\n  tlast\n  tprev\n  call assert_equal(2, line('.'))\n  tNext\n  call assert_equal(1, line('.'))\n  set ignorecase&\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for previewing multiple matching tags\nfunc Test_preview_tag_multimatch()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo\\t1\",\n        \\ \"first\\tXfoo\\t2\",\n        \\ \"first\\tXfoo\\t3\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int first() {}\n    int first() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  enew | only\n  ptag first\n  ptlast\n  wincmd P\n  call assert_equal(3, line('.'))\n  wincmd w\n  call assert_fails('ptnext', 'E428:')\n  ptprev\n  wincmd P\n  call assert_equal(2, line('.'))\n  wincmd w\n  ptfirst\n  wincmd P\n  call assert_equal(1, line('.'))\n  wincmd w\n  call assert_fails('ptprev', 'E425:')\n  ptnext\n  wincmd P\n  call assert_equal(2, line('.'))\n  wincmd w\n  ptlast\n  call feedkeys(\"5\\<CR>\", 't')\n  ptselect first\n  wincmd P\n  call assert_equal(3, line('.'))\n\n  pclose\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for jumping to multiple matching tags across multiple :tags commands\nfunc Test_tnext_multimatch()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo1\\t1\",\n        \\ \"first\\tXfoo2\\t1\",\n        \\ \"first\\tXfoo3\\t1\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n  [CODE]\n  call writefile(code, 'Xfoo1')\n  call writefile(code, 'Xfoo2')\n  call writefile(code, 'Xfoo3')\n\n  tag first\n  tag first\n  pop\n  tnext\n  tnext\n  call assert_fails('tnext', 'E428:')\n\n  call delete('Xtags')\n  call delete('Xfoo1')\n  call delete('Xfoo2')\n  call delete('Xfoo3')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for jumping to multiple matching tags in non-existing files\nfunc Test_multimatch_non_existing_files()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo1\\t1\",\n        \\ \"first\\tXfoo2\\t1\",\n        \\ \"first\\tXfoo3\\t1\"],\n        \\ 'Xtags')\n  set tags=Xtags\n\n  call settagstack(1, {'items' : []})\n  call assert_fails('tag first', 'E429:')\n  call assert_equal(3, gettagstack().items[0].matchnr)\n\n  call delete('Xtags')\n  set tags&\n  %bwipe\nendfunc\n\nfunc Test_tselect_listing()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo\\t1\" .. ';\"' .. \"\\tv\\ttyperef:typename:int\\tfile:\",\n        \\ \"first\\tXfoo\\t2\" .. ';\"' .. \"\\tkind:v\\ttyperef:typename:char\\tfile:\"],\n        \\ 'Xtags')\n  set tags=Xtags\n\n  let code =<< trim [CODE]\n    static int first;\n    static char first;\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  call feedkeys(\"\\<CR>\", \"t\")\n  let l = split(execute(\"tselect first\"), \"\\n\")\n  let expected =<< [DATA]\n  # pri kind tag               file\n  1 FS  v    first             Xfoo\n               typeref:typename:int \n               1\n  2 FS  v    first             Xfoo\n               typeref:typename:char \n               2\nType number and <Enter> (q or empty cancels): \n[DATA]\n  call assert_equal(expected, l)\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe\nendfunc\n\n\" Test for :isearch, :ilist, :ijump and :isplit commands\n\" Test for [i, ]i, [I, ]I, [ CTRL-I, ] CTRL-I and CTRL-W i commands\nfunc Test_inc_search()\n  new\n  call setline(1, ['1:foo', '2:foo', 'foo', '3:foo', '4:foo', '==='])\n  call cursor(3, 1)\n\n  \" Test for [i and ]i\n  call assert_equal('1:foo', execute('normal [i'))\n  call assert_equal('2:foo', execute('normal 2[i'))\n  call assert_fails('normal 3[i', 'E387:')\n  call assert_equal('3:foo', execute('normal ]i'))\n  call assert_equal('4:foo', execute('normal 2]i'))\n  call assert_fails('normal 3]i', 'E389:')\n  call assert_fails('normal G]i', 'E349:')\n  call assert_fails('normal [i', 'E349:')\n  call cursor(3, 1)\n\n  \" Test for :isearch\n  call assert_equal('1:foo', execute('isearch foo'))\n  call assert_equal('3:foo', execute('isearch 4 /foo/'))\n  call assert_fails('isearch 3 foo', 'E387:')\n  call assert_equal('3:foo', execute('+1,$isearch foo'))\n  call assert_fails('1,.-1isearch 3 foo', 'E389:')\n  call assert_fails('isearch bar', 'E389:')\n  call assert_fails('isearch /foo/3', 'E488:')\n\n  \" Test for [I and ]I\n  call assert_equal([\n        \\ '  1:    1 1:foo',\n        \\ '  2:    2 2:foo',\n        \\ '  3:    3 foo',\n        \\ '  4:    4 3:foo',\n        \\ '  5:    5 4:foo'], split(execute('normal [I'), \"\\n\"))\n  call assert_equal([\n        \\ '  1:    4 3:foo',\n        \\ '  2:    5 4:foo'], split(execute('normal ]I'), \"\\n\"))\n  call assert_fails('normal G]I', 'E349:')\n  call assert_fails('normal [I', 'E349:')\n  call cursor(3, 1)\n\n  \" Test for :ilist\n  call assert_equal([\n        \\ '  1:    1 1:foo',\n        \\ '  2:    2 2:foo',\n        \\ '  3:    3 foo',\n        \\ '  4:    4 3:foo',\n        \\ '  5:    5 4:foo'], split(execute('ilist foo'), \"\\n\"))\n  call assert_equal([\n        \\ '  1:    4 3:foo',\n        \\ '  2:    5 4:foo'], split(execute('+1,$ilist /foo/'), \"\\n\"))\n  call assert_fails('ilist bar', 'E389:')\n\n  \" Test for [ CTRL-I and ] CTRL-I\n  exe \"normal [\\t\"\n  call assert_equal([1, 3], [line('.'), col('.')])\n  exe \"normal 2j4[\\t\"\n  call assert_equal([4, 3], [line('.'), col('.')])\n  call assert_fails(\"normal k3[\\t\", 'E387:')\n  call assert_fails(\"normal 6[\\t\", 'E389:')\n  exe \"normal ]\\t\"\n  call assert_equal([4, 3], [line('.'), col('.')])\n  exe \"normal k2]\\t\"\n  call assert_equal([5, 3], [line('.'), col('.')])\n  call assert_fails(\"normal 2k3]\\t\", 'E389:')\n  call assert_fails(\"normal G[\\t\", 'E349:')\n  call assert_fails(\"normal ]\\t\", 'E349:')\n  call cursor(3, 1)\n\n  \" Test for :ijump\n  call cursor(3, 1)\n  ijump foo\n  call assert_equal([1, 3], [line('.'), col('.')])\n  call cursor(3, 1)\n  ijump 4 /foo/\n  call assert_equal([4, 3], [line('.'), col('.')])\n  call cursor(3, 1)\n  call assert_fails('ijump 3 foo', 'E387:')\n  +,$ijump 2 foo\n  call assert_equal([5, 3], [line('.'), col('.')])\n  call assert_fails('ijump bar', 'E389:')\n\n  \" Test for CTRL-W i\n  call cursor(3, 1)\n  wincmd i\n  call assert_equal([1, 3, 3], [line('.'), col('.'), winnr('$')])\n  close\n  5wincmd i\n  call assert_equal([5, 3, 3], [line('.'), col('.'), winnr('$')])\n  close\n  call assert_fails('3wincmd i', 'E387:')\n  call assert_fails('6wincmd i', 'E389:')\n  call assert_fails(\"normal G\\<C-W>i\", 'E349:')\n  call cursor(3, 1)\n\n  \" Test for :isplit\n  isplit foo\n  call assert_equal([1, 3, 3], [line('.'), col('.'), winnr('$')])\n  close\n  isplit 5 /foo/\n  call assert_equal([5, 3, 3], [line('.'), col('.'), winnr('$')])\n  close\n  call assert_fails('isplit 3 foo', 'E387:')\n  call assert_fails('isplit 6 foo', 'E389:')\n  call assert_fails('isplit bar', 'E389:')\n\n  close!\nendfunc\n\n\" this was using a line from ml_get() freed by the regexp\nfunc Test_isearch_copy_line()\n  new\n  norm o\n  norm \u00160\n  0norm o\n  sil! norm bc0\n  sil! isearch \\%')\n  bwipe!\nendfunc\n\n\" Test for :dsearch, :dlist, :djump and :dsplit commands\n\" Test for [d, ]d, [D, ]D, [ CTRL-D, ] CTRL-D and CTRL-W d commands\nfunc Test_macro_search()\n  new\n  call setline(1, ['#define FOO 1', '#define FOO 2', '#define FOO 3',\n        \\ '#define FOO 4', '#define FOO 5'])\n  call cursor(3, 9)\n\n  \" Test for [d and ]d\n  call assert_equal('#define FOO 1', execute('normal [d'))\n  call assert_equal('#define FOO 2', execute('normal 2[d'))\n  call assert_fails('normal 3[d', 'E387:')\n  call assert_equal('#define FOO 4', execute('normal ]d'))\n  call assert_equal('#define FOO 5', execute('normal 2]d'))\n  call assert_fails('normal 3]d', 'E388:')\n\n  \" Test for :dsearch\n  call assert_equal('#define FOO 1', execute('dsearch FOO'))\n  call assert_equal('#define FOO 5', execute('dsearch 5 /FOO/'))\n  call assert_fails('dsearch 3 FOO', 'E387:')\n  call assert_equal('#define FOO 4', execute('+1,$dsearch FOO'))\n  call assert_fails('1,.-1dsearch 3 FOO', 'E388:')\n  call assert_fails('dsearch BAR', 'E388:')\n\n  \" Test for [D and ]D\n  call assert_equal([\n        \\ '  1:    1 #define FOO 1',\n        \\ '  2:    2 #define FOO 2',\n        \\ '  3:    3 #define FOO 3',\n        \\ '  4:    4 #define FOO 4',\n        \\ '  5:    5 #define FOO 5'], split(execute('normal [D'), \"\\n\"))\n  call assert_equal([\n        \\ '  1:    4 #define FOO 4',\n        \\ '  2:    5 #define FOO 5'], split(execute('normal ]D'), \"\\n\"))\n\n  \" Test for :dlist\n  call assert_equal([\n        \\ '  1:    1 #define FOO 1',\n        \\ '  2:    2 #define FOO 2',\n        \\ '  3:    3 #define FOO 3',\n        \\ '  4:    4 #define FOO 4',\n        \\ '  5:    5 #define FOO 5'], split(execute('dlist FOO'), \"\\n\"))\n  call assert_equal([\n        \\ '  1:    4 #define FOO 4',\n        \\ '  2:    5 #define FOO 5'], split(execute('+1,$dlist /FOO/'), \"\\n\"))\n  call assert_fails('dlist BAR', 'E388:')\n\n  \" Test for [ CTRL-D and ] CTRL-D\n  exe \"normal [\\<C-D>\"\n  call assert_equal([1, 9], [line('.'), col('.')])\n  exe \"normal 2j4[\\<C-D>\"\n  call assert_equal([4, 9], [line('.'), col('.')])\n  call assert_fails(\"normal k3[\\<C-D>\", 'E387:')\n  call assert_fails(\"normal 6[\\<C-D>\", 'E388:')\n  exe \"normal ]\\<C-D>\"\n  call assert_equal([4, 9], [line('.'), col('.')])\n  exe \"normal k2]\\<C-D>\"\n  call assert_equal([5, 9], [line('.'), col('.')])\n  call assert_fails(\"normal 2k3]\\<C-D>\", 'E388:')\n\n  \" Test for :djump\n  call cursor(3, 9)\n  djump FOO\n  call assert_equal([1, 9], [line('.'), col('.')])\n  call cursor(3, 9)\n  djump 4 /FOO/\n  call assert_equal([4, 9], [line('.'), col('.')])\n  call cursor(3, 9)\n  call assert_fails('djump 3 FOO', 'E387:')\n  +,$djump 2 FOO\n  call assert_equal([5, 9], [line('.'), col('.')])\n  call assert_fails('djump BAR', 'E388:')\n\n  \" Test for CTRL-W d\n  call cursor(3, 9)\n  wincmd d\n  call assert_equal([1, 9, 3], [line('.'), col('.'), winnr('$')])\n  close\n  5wincmd d\n  call assert_equal([5, 9, 3], [line('.'), col('.'), winnr('$')])\n  close\n  call assert_fails('3wincmd d', 'E387:')\n  call assert_fails('6wincmd d', 'E388:')\n  new\n  call assert_fails(\"normal \\<C-W>d\", 'E349:')\n  call assert_fails(\"normal \\<C-W>\\<C-D>\", 'E349:')\n  close\n\n  \" Test for :dsplit\n  dsplit FOO\n  call assert_equal([1, 9, 3], [line('.'), col('.'), winnr('$')])\n  close\n  dsplit 5 /FOO/\n  call assert_equal([5, 9, 3], [line('.'), col('.'), winnr('$')])\n  close\n  call assert_fails('dsplit 3 FOO', 'E387:')\n  call assert_fails('dsplit 6 FOO', 'E388:')\n  call assert_fails('dsplit BAR', 'E388:')\n\n  close!\nendfunc\n\nfunc Test_define_search()\n  \" this was accessing freed memory\n  new\n  call setline(1, ['first line', '', '#define something 0'])\n  sil norm o0\n  sil! norm \u0017\u0004\n  bwipe!\n\n  new somefile\n  call setline(1, ['first line', '', '#define something 0'])\n  sil norm 0o0\n  sil! norm ]d\n  bwipe!\nendfunc\n\n\" Test for [*, [/, ]* and ]/\nfunc Test_comment_search()\n  new\n  call setline(1, ['', '/*', ' *', ' *', ' */'])\n  normal! 4gg[/\n  call assert_equal([2, 1], [line('.'), col('.')])\n  normal! 3gg[*\n  call assert_equal([2, 1], [line('.'), col('.')])\n  normal! 3gg]/\n  call assert_equal([5, 3], [line('.'), col('.')])\n  normal! 3gg]*\n  call assert_equal([5, 3], [line('.'), col('.')])\n  %d\n  call setline(1, ['', '/*', ' *', ' *'])\n  call assert_beeps('normal! 3gg]/')\n  %d\n  call setline(1, ['', ' *', ' *', ' */'])\n  call assert_beeps('normal! 4gg[/')\n  %d\n  call setline(1, '        /* comment */')\n  normal! 15|[/\n  call assert_equal(9, col('.'))\n  normal! 15|]/\n  call assert_equal(21, col('.'))\n  call setline(1, '         comment */')\n  call assert_beeps('normal! 15|[/')\n  call setline(1, '        /* comment')\n  call assert_beeps('normal! 15|]/')\n  close!\nendfunc\n\n\" Test for the 'taglength' option\nfunc Test_tag_length()\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"tame\\tXfile1\\t1;\",\n        \\ \"tape\\tXfile2\\t1;\"], 'Xtags')\n  call writefile(['tame'], 'Xfile1')\n  call writefile(['tape'], 'Xfile2')\n\n  \" Jumping to the tag 'tape', should instead jump to 'tame'\n  new\n  set taglength=2\n  tag tape\n  call assert_equal('Xfile1', @%)\n  \" Tag search should jump to the right tag\n  enew\n  tag /^tape$\n  call assert_equal('Xfile2', @%)\n\n  call delete('Xtags')\n  call delete('Xfile1')\n  call delete('Xfile2')\n  set tags& taglength&\nendfunc\n\n\" Tests for errors in a tags file\nfunc Test_tagfile_errors()\n  set tags=Xtags\n\n  \" missing search pattern or line number for a tag\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"foo\\tXfile\\t\"], 'Xtags', 'b')\n  call writefile(['foo'], 'Xfile')\n\n  enew\n  tag foo\n  call assert_equal('', @%)\n  let caught_431 = v:false\n  try\n    eval taglist('.*')\n  catch /:E431:/\n    let caught_431 = v:true\n  endtry\n  call assert_equal(v:true, caught_431)\n\n  \" tag name and file name are not separated by a tab\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"foo Xfile 1\"], 'Xtags')\n  call assert_fails('tag foo', 'E431:')\n\n  \" file name and search pattern are not separated by a tab\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"foo\\tXfile 1;\"], 'Xtags')\n  call assert_fails('tag foo', 'E431:')\n\n  call delete('Xtags')\n  call delete('Xfile')\n  set tags&\nendfunc\n\n\" When :stag fails to open the file, should close the new window\nfunc Test_stag_close_window_on_error()\n  new | only\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"foo\\tXfile\\t1\"], 'Xtags')\n  call writefile(['foo'], 'Xfile')\n  call writefile([], '.Xfile.swp')\n  \" Remove the catch-all that runtest.vim adds\n  au! SwapExists\n  augroup StagTest\n    au!\n    autocmd SwapExists Xfile let v:swapchoice='q'\n  augroup END\n\n  stag foo\n  call assert_equal(1, winnr('$'))\n  call assert_equal('', @%)\n\n  augroup StagTest\n    au!\n  augroup END\n  call delete('Xfile')\n  call delete('.Xfile.swp')\n  set tags&\nendfunc\n\n\" Test for 'tagbsearch' (binary search)\nfunc Test_tagbsearch()\n  \" If a tags file header says the tags are sorted, but the tags are actually\n  \" unsorted, then binary search should fail and linear search should work.\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"!_TAG_FILE_SORTED\\t1\\t/0=unsorted, 1=sorted, 2=foldcase/\",\n        \\ \"third\\tXfoo\\t3\",\n        \\ \"second\\tXfoo\\t2\",\n        \\ \"first\\tXfoo\\t1\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int second() {}\n    int third() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  enew\n  set tagbsearch\n  call assert_fails('tag first', 'E426:')\n  call assert_equal('', bufname())\n  call assert_fails('tag second', 'E426:')\n  call assert_equal('', bufname())\n  tag third\n  call assert_equal('Xfoo', bufname())\n  call assert_equal(3, line('.'))\n  %bw!\n\n  set notagbsearch\n  tag first\n  call assert_equal('Xfoo', bufname())\n  call assert_equal(1, line('.'))\n  enew\n  tag second\n  call assert_equal('Xfoo', bufname())\n  call assert_equal(2, line('.'))\n  enew\n  tag third\n  call assert_equal('Xfoo', bufname())\n  call assert_equal(3, line('.'))\n  %bw!\n\n  \" If a tags file header says the tags are unsorted, but the tags are\n  \" actually sorted, then binary search should work.\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"!_TAG_FILE_SORTED\\t0\\t/0=unsorted, 1=sorted, 2=foldcase/\",\n        \\ \"first\\tXfoo\\t1\",\n        \\ \"second\\tXfoo\\t2\",\n        \\ \"third\\tXfoo\\t3\"],\n        \\ 'Xtags')\n\n  set tagbsearch\n  tag first\n  call assert_equal('Xfoo', bufname())\n  call assert_equal(1, line('.'))\n  enew\n  tag second\n  call assert_equal('Xfoo', bufname())\n  call assert_equal(2, line('.'))\n  enew\n  tag third\n  call assert_equal('Xfoo', bufname())\n  call assert_equal(3, line('.'))\n  %bw!\n\n  \" Binary search fails on EOF\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"!_TAG_FILE_SORTED\\t1\\t/0=unsorted, 1=sorted, 2=foldcase/\",\n        \\ \"bar\\tXfoo\\t1\",\n        \\ \"foo\\tXfoo\\t2\"],\n        \\ 'Xtags')\n  call assert_fails('tag bbb', 'E426:')\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags& tagbsearch&\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    5050,\n/**/\n    5049,\n/**/\n    5048,\n/**/\n    5047,\n/**/\n    5046,\n/**/\n    5045,\n/**/\n    5044,\n/**/\n    5043,\n/**/\n    5042,\n/**/\n    5041,\n/**/\n    5040,\n/**/\n    5039,\n/**/\n    5038,\n/**/\n    5037,\n/**/\n    5036,\n/**/\n    5035,\n/**/\n    5034,\n/**/\n    5033,\n/**/\n    5032,\n/**/\n    5031,\n/**/\n    5030,\n/**/\n    5029,\n/**/\n    5028,\n/**/\n    5027,\n/**/\n    5026,\n/**/\n    5025,\n/**/\n    5024,\n/**/\n    5023,\n/**/\n    5022,\n/**/\n    5021,\n/**/\n    5020,\n/**/\n    5019,\n/**/\n    5018,\n/**/\n    5017,\n/**/\n    5016,\n/**/\n    5015,\n/**/\n    5014,\n/**/\n    5013,\n/**/\n    5012,\n/**/\n    5011,\n/**/\n    5010,\n/**/\n    5009,\n/**/\n    5008,\n/**/\n    5007,\n/**/\n    5006,\n/**/\n    5005,\n/**/\n    5004,\n/**/\n    5003,\n/**/\n    5002,\n/**/\n    5001,\n/**/\n    5000,\n/**/\n    4999,\n/**/\n    4998,\n/**/\n    4997,\n/**/\n    4996,\n/**/\n    4995,\n/**/\n    4994,\n/**/\n    4993,\n/**/\n    4992,\n/**/\n    4991,\n/**/\n    4990,\n/**/\n    4989,\n/**/\n    4988,\n/**/\n    4987,\n/**/\n    4986,\n/**/\n    4985,\n/**/\n    4984,\n/**/\n    4983,\n/**/\n    4982,\n/**/\n    4981,\n/**/\n    4980,\n/**/\n    4979,\n/**/\n    4978,\n/**/\n    4977,\n/**/\n    4976,\n/**/\n    4975,\n/**/\n    4974,\n/**/\n    4973,\n/**/\n    4972,\n/**/\n    4971,\n/**/\n    4970,\n/**/\n    4969,\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/search.c", "src/testdir/test_tagjump.vim", "src/version.c"], "buggy_code_start_loc": [3307, 1290, 736], "buggy_code_end_loc": [3954, 1290, 736], "fixing_code_start_loc": [3308, 1291, 737], "fixing_code_end_loc": [3969, 1302, 739], "type": "CWE-416", "message": "Use After Free in GitHub repository vim/vim prior to 8.2.", "other": {"cve": {"id": "CVE-2022-1968", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-02T14:15:34.390", "lastModified": "2023-05-03T12:15:38.607", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository vim/vim prior to 8.2."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en el repositorio GitHub vim/vim versiones anteriores a 8.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.5050", "matchCriteriaId": "04C6E8E9-FA44-4636-AB44-9130A768D9B9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "13.0", "matchCriteriaId": "71E032AD-F827-4944-9699-BB1E6D4233FC"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Oct/28", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/41", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/409510c588b1eec1ae33511ae97a21eb8e110895", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/949090e5-f4ea-4edf-bd79-cd98f0498a5b", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/06/msg00014.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}, {"url": "https://support.apple.com/kb/HT213488", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/409510c588b1eec1ae33511ae97a21eb8e110895"}}