{"buggy_code": ["import { decode as base64url } from '../../runtime/base64url.js'\nimport decrypt from '../../runtime/decrypt.js'\nimport { inflate } from '../../runtime/zlib.js'\n\nimport { JOSEAlgNotAllowed, JOSENotSupported, JWEInvalid } from '../../util/errors.js'\nimport isDisjoint from '../../lib/is_disjoint.js'\nimport isObject from '../../lib/is_object.js'\nimport decryptKeyManagement from '../../lib/decrypt_key_management.js'\nimport type {\n  FlattenedDecryptResult,\n  KeyLike,\n  FlattenedJWE,\n  JWEHeaderParameters,\n  DecryptOptions,\n  GetKeyFunction,\n  ResolvedKey,\n} from '../../types.d'\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js'\nimport generateCek from '../../lib/cek.js'\nimport validateCrit from '../../lib/validate_crit.js'\nimport validateAlgorithms from '../../lib/validate_algorithms.js'\n\n/**\n * Interface for Flattened JWE Decryption dynamic key resolution. No token components have been\n * verified at the time of this function call.\n */\nexport interface FlattenedDecryptGetKey\n  extends GetKeyFunction<JWEHeaderParameters | undefined, FlattenedJWE> {}\n\n/**\n * Decrypts a Flattened JWE.\n *\n * @example Usage\n *\n * ```js\n * const jwe = {\n *   ciphertext: '9EzjFISUyoG-ifC2mSihfP0DPC80yeyrxhTzKt1C_VJBkxeBG0MI4Te61Pk45RAGubUvBpU9jm4',\n *   iv: '8Fy7A_IuoX5VXG9s',\n *   tag: 'W76IYV6arGRuDSaSyWrQNg',\n *   encrypted_key:\n *     'Z6eD4UK_yFb5ZoKvKkGAdqywEG_m0e4IYo0x8Vf30LAMJcsc-_zSgIeiF82teZyYi2YYduHKoqImk7MRnoPZOlEs0Q5BNK1OgBmSOhCE8DFyqh9Zh48TCTP6lmBQ52naqoUJFMtHzu-0LwZH26hxos0GP3Dt19O379MJB837TdKKa87skq0zHaVLAquRHOBF77GI54Bc7O49d8aOrSu1VEFGMThlW2caspPRiTSePDMDPq7_WGk50izRhB3Asl9wmP9wEeaTrkJKRnQj5ips1SAZ1hDBsqEQKKukxP1HtdcopHV5_qgwU8Hjm5EwSLMluMQuiE6hwlkXGOujZLVizA',\n *   aad: 'VGhlIEZlbGxvd3NoaXAgb2YgdGhlIFJpbmc',\n *   protected: 'eyJhbGciOiJSU0EtT0FFUC0yNTYiLCJlbmMiOiJBMjU2R0NNIn0',\n * }\n *\n * const { plaintext, protectedHeader, additionalAuthenticatedData } =\n *   await jose.flattenedDecrypt(jwe, privateKey)\n *\n * console.log(protectedHeader)\n * const decoder = new TextDecoder()\n * console.log(decoder.decode(plaintext))\n * console.log(decoder.decode(additionalAuthenticatedData))\n * ```\n *\n * @param jwe Flattened JWE.\n * @param key Private Key or Secret to decrypt the JWE with.\n * @param options JWE Decryption options.\n */\nexport function flattenedDecrypt(\n  jwe: FlattenedJWE,\n  key: KeyLike | Uint8Array,\n  options?: DecryptOptions,\n): Promise<FlattenedDecryptResult>\n/**\n * @param jwe Flattened JWE.\n * @param getKey Function resolving Private Key or Secret to decrypt the JWE with.\n * @param options JWE Decryption options.\n */\nexport function flattenedDecrypt(\n  jwe: FlattenedJWE,\n  getKey: FlattenedDecryptGetKey,\n  options?: DecryptOptions,\n): Promise<FlattenedDecryptResult & ResolvedKey>\nexport async function flattenedDecrypt(\n  jwe: FlattenedJWE,\n  key: KeyLike | Uint8Array | FlattenedDecryptGetKey,\n  options?: DecryptOptions,\n) {\n  if (!isObject(jwe)) {\n    throw new JWEInvalid('Flattened JWE must be an object')\n  }\n\n  if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {\n    throw new JWEInvalid('JOSE Header missing')\n  }\n\n  if (typeof jwe.iv !== 'string') {\n    throw new JWEInvalid('JWE Initialization Vector missing or incorrect type')\n  }\n\n  if (typeof jwe.ciphertext !== 'string') {\n    throw new JWEInvalid('JWE Ciphertext missing or incorrect type')\n  }\n\n  if (typeof jwe.tag !== 'string') {\n    throw new JWEInvalid('JWE Authentication Tag missing or incorrect type')\n  }\n\n  if (jwe.protected !== undefined && typeof jwe.protected !== 'string') {\n    throw new JWEInvalid('JWE Protected Header incorrect type')\n  }\n\n  if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') {\n    throw new JWEInvalid('JWE Encrypted Key incorrect type')\n  }\n\n  if (jwe.aad !== undefined && typeof jwe.aad !== 'string') {\n    throw new JWEInvalid('JWE AAD incorrect type')\n  }\n\n  if (jwe.header !== undefined && !isObject(jwe.header)) {\n    throw new JWEInvalid('JWE Shared Unprotected Header incorrect type')\n  }\n\n  if (jwe.unprotected !== undefined && !isObject(jwe.unprotected)) {\n    throw new JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type')\n  }\n\n  let parsedProt!: JWEHeaderParameters\n  if (jwe.protected) {\n    try {\n      const protectedHeader = base64url(jwe.protected)\n      parsedProt = JSON.parse(decoder.decode(protectedHeader))\n    } catch {\n      throw new JWEInvalid('JWE Protected Header is invalid')\n    }\n  }\n  if (!isDisjoint(parsedProt, jwe.header, jwe.unprotected)) {\n    throw new JWEInvalid(\n      'JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint',\n    )\n  }\n\n  const joseHeader: JWEHeaderParameters = {\n    ...parsedProt,\n    ...jwe.header,\n    ...jwe.unprotected,\n  }\n\n  validateCrit(JWEInvalid, new Map(), options?.crit, parsedProt, joseHeader)\n\n  if (joseHeader.zip !== undefined) {\n    if (!parsedProt || !parsedProt.zip) {\n      throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected')\n    }\n\n    if (joseHeader.zip !== 'DEF') {\n      throw new JOSENotSupported(\n        'Unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value',\n      )\n    }\n  }\n\n  const { alg, enc } = joseHeader\n\n  if (typeof alg !== 'string' || !alg) {\n    throw new JWEInvalid('missing JWE Algorithm (alg) in JWE Header')\n  }\n\n  if (typeof enc !== 'string' || !enc) {\n    throw new JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header')\n  }\n\n  const keyManagementAlgorithms =\n    options && validateAlgorithms('keyManagementAlgorithms', options.keyManagementAlgorithms)\n  const contentEncryptionAlgorithms =\n    options &&\n    validateAlgorithms('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms)\n\n  if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {\n    throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed')\n  }\n\n  if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n    throw new JOSEAlgNotAllowed('\"enc\" (Encryption Algorithm) Header Parameter not allowed')\n  }\n\n  let encryptedKey!: Uint8Array\n  if (jwe.encrypted_key !== undefined) {\n    encryptedKey = base64url(jwe.encrypted_key!)\n  }\n\n  let resolvedKey = false\n  if (typeof key === 'function') {\n    key = await key(parsedProt, jwe)\n    resolvedKey = true\n  }\n\n  let cek: KeyLike | Uint8Array\n  try {\n    cek = await decryptKeyManagement(alg, key, encryptedKey, joseHeader)\n  } catch (err) {\n    if (err instanceof TypeError) {\n      throw err\n    }\n    // https://www.rfc-editor.org/rfc/rfc7516#section-11.5\n    // To mitigate the attacks described in RFC 3218, the\n    // recipient MUST NOT distinguish between format, padding, and length\n    // errors of encrypted keys.  It is strongly recommended, in the event\n    // of receiving an improperly formatted key, that the recipient\n    // substitute a randomly generated CEK and proceed to the next step, to\n    // mitigate timing attacks.\n    cek = generateCek(enc)\n  }\n\n  const iv = base64url(jwe.iv)\n  const tag = base64url(jwe.tag)\n\n  const protectedHeader: Uint8Array = encoder.encode(jwe.protected ?? '')\n  let additionalData: Uint8Array\n\n  if (jwe.aad !== undefined) {\n    additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(jwe.aad))\n  } else {\n    additionalData = protectedHeader\n  }\n\n  let plaintext = await decrypt(enc, cek, base64url(jwe.ciphertext), iv, tag, additionalData)\n\n  if (joseHeader.zip === 'DEF') {\n    plaintext = await (options?.inflateRaw || inflate)(plaintext)\n  }\n\n  const result: FlattenedDecryptResult = { plaintext }\n\n  if (jwe.protected !== undefined) {\n    result.protectedHeader = parsedProt\n  }\n\n  if (jwe.aad !== undefined) {\n    result.additionalAuthenticatedData = base64url(jwe.aad!)\n  }\n\n  if (jwe.unprotected !== undefined) {\n    result.sharedUnprotectedHeader = jwe.unprotected\n  }\n\n  if (jwe.header !== undefined) {\n    result.unprotectedHeader = jwe.header\n  }\n\n  if (resolvedKey) {\n    return { ...result, key }\n  }\n\n  return result\n}\n", "import { unwrap as aesKw } from '../runtime/aeskw.js'\nimport * as ECDH from '../runtime/ecdhes.js'\nimport { decrypt as pbes2Kw } from '../runtime/pbes2kw.js'\nimport { decrypt as rsaEs } from '../runtime/rsaes.js'\nimport { decode as base64url } from '../runtime/base64url.js'\n\nimport type { JWEHeaderParameters, KeyLike, JWK } from '../types.d'\nimport { JOSENotSupported, JWEInvalid } from '../util/errors.js'\nimport { bitLength as cekLength } from '../lib/cek.js'\nimport { importJWK } from '../key/import.js'\nimport checkKeyType from './check_key_type.js'\nimport isObject from './is_object.js'\nimport { unwrap as aesGcmKw } from './aesgcmkw.js'\n\nasync function decryptKeyManagement(\n  alg: string,\n  key: KeyLike | Uint8Array,\n  encryptedKey: Uint8Array | undefined,\n  joseHeader: JWEHeaderParameters,\n): Promise<KeyLike | Uint8Array> {\n  checkKeyType(alg, key, 'decrypt')\n\n  switch (alg) {\n    case 'dir': {\n      // Direct Encryption\n      if (encryptedKey !== undefined)\n        throw new JWEInvalid('Encountered unexpected JWE Encrypted Key')\n\n      return key\n    }\n    case 'ECDH-ES':\n      // Direct Key Agreement\n      if (encryptedKey !== undefined)\n        throw new JWEInvalid('Encountered unexpected JWE Encrypted Key')\n\n    case 'ECDH-ES+A128KW':\n    case 'ECDH-ES+A192KW':\n    case 'ECDH-ES+A256KW': {\n      // Direct Key Agreement\n      if (!isObject<JWK>(joseHeader.epk))\n        throw new JWEInvalid(`JOSE Header \"epk\" (Ephemeral Public Key) missing or invalid`)\n\n      if (!ECDH.ecdhAllowed(key))\n        throw new JOSENotSupported(\n          'ECDH with the provided key is not allowed or not supported by your javascript runtime',\n        )\n\n      const epk = await importJWK(joseHeader.epk, alg)\n      let partyUInfo!: Uint8Array\n      let partyVInfo!: Uint8Array\n\n      if (joseHeader.apu !== undefined) {\n        if (typeof joseHeader.apu !== 'string')\n          throw new JWEInvalid(`JOSE Header \"apu\" (Agreement PartyUInfo) invalid`)\n        partyUInfo = base64url(joseHeader.apu)\n      }\n\n      if (joseHeader.apv !== undefined) {\n        if (typeof joseHeader.apv !== 'string')\n          throw new JWEInvalid(`JOSE Header \"apv\" (Agreement PartyVInfo) invalid`)\n        partyVInfo = base64url(joseHeader.apv)\n      }\n\n      const sharedSecret = await ECDH.deriveKey(\n        epk,\n        key,\n        alg === 'ECDH-ES' ? joseHeader.enc! : alg,\n        alg === 'ECDH-ES' ? cekLength(joseHeader.enc!) : parseInt(alg.slice(-5, -2), 10),\n        partyUInfo,\n        partyVInfo,\n      )\n\n      if (alg === 'ECDH-ES') return sharedSecret\n\n      // Key Agreement with Key Wrapping\n      if (encryptedKey === undefined) throw new JWEInvalid('JWE Encrypted Key missing')\n\n      return aesKw(alg.slice(-6), sharedSecret, encryptedKey)\n    }\n    case 'RSA1_5':\n    case 'RSA-OAEP':\n    case 'RSA-OAEP-256':\n    case 'RSA-OAEP-384':\n    case 'RSA-OAEP-512': {\n      // Key Encryption (RSA)\n      if (encryptedKey === undefined) throw new JWEInvalid('JWE Encrypted Key missing')\n\n      return rsaEs(alg, key, encryptedKey)\n    }\n    case 'PBES2-HS256+A128KW':\n    case 'PBES2-HS384+A192KW':\n    case 'PBES2-HS512+A256KW': {\n      // Key Encryption (PBES2)\n      if (encryptedKey === undefined) throw new JWEInvalid('JWE Encrypted Key missing')\n\n      if (typeof joseHeader.p2c !== 'number')\n        throw new JWEInvalid(`JOSE Header \"p2c\" (PBES2 Count) missing or invalid`)\n\n      if (typeof joseHeader.p2s !== 'string')\n        throw new JWEInvalid(`JOSE Header \"p2s\" (PBES2 Salt) missing or invalid`)\n\n      return pbes2Kw(alg, key, encryptedKey, joseHeader.p2c, base64url(joseHeader.p2s))\n    }\n    case 'A128KW':\n    case 'A192KW':\n    case 'A256KW': {\n      // Key Wrapping (AES KW)\n      if (encryptedKey === undefined) throw new JWEInvalid('JWE Encrypted Key missing')\n\n      return aesKw(alg, key, encryptedKey)\n    }\n    case 'A128GCMKW':\n    case 'A192GCMKW':\n    case 'A256GCMKW': {\n      // Key Wrapping (AES GCM KW)\n      if (encryptedKey === undefined) throw new JWEInvalid('JWE Encrypted Key missing')\n\n      if (typeof joseHeader.iv !== 'string')\n        throw new JWEInvalid(`JOSE Header \"iv\" (Initialization Vector) missing or invalid`)\n\n      if (typeof joseHeader.tag !== 'string')\n        throw new JWEInvalid(`JOSE Header \"tag\" (Authentication Tag) missing or invalid`)\n\n      const iv = base64url(joseHeader.iv)\n      const tag = base64url(joseHeader.tag)\n\n      return aesGcmKw(alg, key, encryptedKey, iv, tag)\n    }\n    default: {\n      throw new JOSENotSupported('Invalid or unsupported \"alg\" (JWE Algorithm) header value')\n    }\n  }\n}\n\nexport default decryptKeyManagement\n", "/**\n * KeyLike are runtime-specific classes representing asymmetric keys or symmetric secrets. These are\n * instances of [CryptoKey](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) and\n * additionally [KeyObject](https://nodejs.org/api/crypto.html#class-keyobject) in Node.js runtime.\n * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)\n * instances are also accepted as symmetric secret representation only.\n *\n * [Key Import Functions](../modules/key_import.md#readme) can be used to import PEM, or JWK\n * formatted asymmetric keys and certificates to these runtime-specific representations.\n *\n * In Node.js the [Buffer](https://nodejs.org/api/buffer.html#buffer) class is a subclass of\n * Uint8Array and so Buffer can be provided for symmetric secrets as well.\n *\n * [KeyObject](https://nodejs.org/api/crypto.html#class-keyobject) is a representation of a\n * key/secret available in the Node.js runtime. In addition to the import functions of this library\n * you may use the runtime APIs\n * [crypto.createPublicKey](https://nodejs.org/api/crypto.html#cryptocreatepublickeykey),\n * [crypto.createPrivateKey](https://nodejs.org/api/crypto.html#cryptocreateprivatekeykey), and\n * [crypto.createSecretKey](https://nodejs.org/api/crypto.html#cryptocreatesecretkeykey-encoding) to\n * obtain a KeyObject from your existing key material.\n *\n * [CryptoKey](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) is a representation of a\n * key/secret available in the Browser and Deno runtimes. In addition to the import functions of\n * this library you may use the\n * [SubtleCrypto.importKey](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey)\n * API to obtain a CryptoKey from your existing key material.\n *\n * @example Import a PEM-encoded SPKI Public Key\n *\n * ```js\n * const algorithm = 'ES256'\n * const spki = `-----BEGIN PUBLIC KEY-----\n * MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEFlHHWfLk0gLBbsLTcuCrbCqoHqmM\n * YJepMC+Q+Dd6RBmBiA41evUsNMwLeN+PNFqib+xwi9JkJ8qhZkq8Y/IzGg==\n * -----END PUBLIC KEY-----`\n * const ecPublicKey = await jose.importSPKI(spki, algorithm)\n * ```\n *\n * @example Import a X.509 Certificate\n *\n * ```js\n * const algorithm = 'ES256'\n * const x509 = `-----BEGIN CERTIFICATE-----\n * MIIBXjCCAQSgAwIBAgIGAXvykuMKMAoGCCqGSM49BAMCMDYxNDAyBgNVBAMMK3Np\n * QXBNOXpBdk1VaXhXVWVGaGtjZXg1NjJRRzFyQUhXaV96UlFQTVpQaG8wHhcNMjEw\n * OTE3MDcwNTE3WhcNMjIwNzE0MDcwNTE3WjA2MTQwMgYDVQQDDCtzaUFwTTl6QXZN\n * VWl4V1VlRmhrY2V4NTYyUUcxckFIV2lfelJRUE1aUGhvMFkwEwYHKoZIzj0CAQYI\n * KoZIzj0DAQcDQgAE8PbPvCv5D5xBFHEZlBp/q5OEUymq7RIgWIi7tkl9aGSpYE35\n * UH+kBKDnphJO3odpPZ5gvgKs2nwRWcrDnUjYLDAKBggqhkjOPQQDAgNIADBFAiEA\n * 1yyMTRe66MhEXID9+uVub7woMkNYd0LhSHwKSPMUUTkCIFQGsfm1ecXOpeGOufAh\n * v+A1QWZMuTWqYt+uh/YSRNDn\n * -----END CERTIFICATE-----`\n * const ecPublicKey = await jose.importX509(x509, algorithm)\n * ```\n *\n * @example Import a PEM-encoded PKCS8 Private Key\n *\n * ```js\n * const algorithm = 'ES256'\n * const pkcs8 = `-----BEGIN PRIVATE KEY-----\n * MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgiyvo0X+VQ0yIrOaN\n * nlrnUclopnvuuMfoc8HHly3505OhRANCAAQWUcdZ8uTSAsFuwtNy4KtsKqgeqYxg\n * l6kwL5D4N3pEGYGIDjV69Sw0zAt43480WqJv7HCL0mQnyqFmSrxj8jMa\n * -----END PRIVATE KEY-----`\n * const ecPrivateKey = await jose.importPKCS8(pkcs8, algorithm)\n * ```\n *\n * @example Import a JSON Web Key (JWK)\n *\n * ```js\n * const ecPublicKey = await jose.importJWK(\n *   {\n *     crv: 'P-256',\n *     kty: 'EC',\n *     x: 'ySK38C1jBdLwDsNWKzzBHqKYEE5Cgv-qjWvorUXk9fw',\n *     y: '_LeQBw07cf5t57Iavn4j-BqJsAD1dpoz8gokd3sBsOo',\n *   },\n *   'ES256',\n * )\n *\n * const rsaPublicKey = await jose.importJWK(\n *   {\n *     kty: 'RSA',\n *     e: 'AQAB',\n *     n: '12oBZRhCiZFJLcPg59LkZZ9mdhSMTKAQZYq32k_ti5SBB6jerkh-WzOMAO664r_qyLkqHUSp3u5SbXtseZEpN3XPWGKSxjsy-1JyEFTdLSYe6f9gfrmxkUF_7DTpq0gn6rntP05g2-wFW50YO7mosfdslfrTJYWHFhJALabAeYirYD7-9kqq9ebfFMF4sRRELbv9oi36As6Q9B3Qb5_C1rAzqfao_PCsf9EPsTZsVVVkA5qoIAr47lo1ipfiBPxUCCNSdvkmDTYgvvRm6ZoMjFbvOtgyts55fXKdMWv7I9HMD5HwE9uW839PWA514qhbcIsXEYSFMPMV6fnlsiZvQQ',\n *   },\n *   'PS256',\n * )\n * ```\n */\nexport type KeyLike = { type: string }\n\n/**\n * JSON Web Key ([JWK](https://www.rfc-editor.org/rfc/rfc7517)). \"RSA\", \"EC\", \"OKP\", and \"oct\" key\n * types are supported.\n */\nexport interface JWK {\n  /** JWK \"alg\" (Algorithm) Parameter. */\n  alg?: string\n  crv?: string\n  d?: string\n  dp?: string\n  dq?: string\n  e?: string\n  /** JWK \"ext\" (Extractable) Parameter. */\n  ext?: boolean\n  k?: string\n  /** JWK \"key_ops\" (Key Operations) Parameter. */\n  key_ops?: string[]\n  /** JWK \"kid\" (Key ID) Parameter. */\n  kid?: string\n  /** JWK \"kty\" (Key Type) Parameter. */\n  kty?: string\n  n?: string\n  oth?: Array<{\n    d?: string\n    r?: string\n    t?: string\n  }>\n  p?: string\n  q?: string\n  qi?: string\n  /** JWK \"use\" (Public Key Use) Parameter. */\n  use?: string\n  x?: string\n  y?: string\n  /** JWK \"x5c\" (X.509 Certificate Chain) Parameter. */\n  x5c?: string[]\n  /** JWK \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Parameter. */\n  x5t?: string\n  /** \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Parameter. */\n  'x5t#S256'?: string\n  /** JWK \"x5u\" (X.509 URL) Parameter. */\n  x5u?: string\n\n  [propName: string]: unknown\n}\n\n/**\n * Generic Interface for consuming operations dynamic key resolution. No token components have been\n * verified at the time of this function call.\n *\n * If you cannot match a key suitable for the token, throw an error instead.\n *\n * @param protectedHeader JWE or JWS Protected Header.\n * @param token The consumed JWE or JWS token.\n */\nexport interface GetKeyFunction<T, T2> {\n  (protectedHeader: T, token: T2): Promise<KeyLike | Uint8Array> | KeyLike | Uint8Array\n}\n\n/**\n * Flattened JWS definition for verify function inputs, allows payload as Uint8Array for detached\n * signature validation.\n */\nexport interface FlattenedJWSInput {\n  /**\n   * The \"header\" member MUST be present and contain the value JWS Unprotected Header when the JWS\n   * Unprotected Header value is non- empty; otherwise, it MUST be absent. This value is represented\n   * as an unencoded JSON object, rather than as a string. These Header Parameter values are not\n   * integrity protected.\n   */\n  header?: JWSHeaderParameters\n\n  /**\n   * The \"payload\" member MUST be present and contain the value BASE64URL(JWS Payload). When RFC7797\n   * \"b64\": false is used the value passed may also be a Uint8Array.\n   */\n  payload: string | Uint8Array\n\n  /**\n   * The \"protected\" member MUST be present and contain the value BASE64URL(UTF8(JWS Protected\n   * Header)) when the JWS Protected Header value is non-empty; otherwise, it MUST be absent. These\n   * Header Parameter values are integrity protected.\n   */\n  protected?: string\n\n  /** The \"signature\" member MUST be present and contain the value BASE64URL(JWS Signature). */\n  signature: string\n}\n\n/**\n * General JWS definition for verify function inputs, allows payload as Uint8Array for detached\n * signature validation.\n */\nexport interface GeneralJWSInput {\n  /**\n   * The \"payload\" member MUST be present and contain the value BASE64URL(JWS Payload). When RFC7797\n   * \"b64\": false is used the value passed may also be a Uint8Array.\n   */\n  payload: string | Uint8Array\n\n  /**\n   * The \"signatures\" member value MUST be an array of JSON objects. Each object represents a\n   * signature or MAC over the JWS Payload and the JWS Protected Header.\n   */\n  signatures: Omit<FlattenedJWSInput, 'payload'>[]\n}\n\n/**\n * Flattened JWS definition. Payload is returned as an empty string when JWS Unencoded Payload\n * Option [RFC7797](https://www.rfc-editor.org/rfc/rfc7797) is used.\n */\nexport interface FlattenedJWS extends Partial<FlattenedJWSInput> {\n  payload: string\n  signature: string\n}\n\n/**\n * General JWS definition. Payload is returned as an empty string when JWS Unencoded Payload Option\n * [RFC7797](https://www.rfc-editor.org/rfc/rfc7797) is used.\n */\nexport interface GeneralJWS {\n  payload: string\n  signatures: Omit<FlattenedJWSInput, 'payload'>[]\n}\n\nexport interface JoseHeaderParameters {\n  /** \"kid\" (Key ID) Header Parameter. */\n  kid?: string\n\n  /** \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter. */\n  x5t?: string\n\n  /** \"x5c\" (X.509 Certificate Chain) Header Parameter. */\n  x5c?: string[]\n\n  /** \"x5u\" (X.509 URL) Header Parameter. */\n  x5u?: string\n\n  /** \"jku\" (JWK Set URL) Header Parameter. */\n  jku?: string\n\n  /** \"jwk\" (JSON Web Key) Header Parameter. */\n  jwk?: Pick<JWK, 'kty' | 'crv' | 'x' | 'y' | 'e' | 'n'>\n\n  /** \"typ\" (Type) Header Parameter. */\n  typ?: string\n\n  /** \"cty\" (Content Type) Header Parameter. */\n  cty?: string\n}\n\n/** Recognized JWS Header Parameters, any other Header Members may also be present. */\nexport interface JWSHeaderParameters extends JoseHeaderParameters {\n  /** JWS \"alg\" (Algorithm) Header Parameter. */\n  alg?: string\n\n  /**\n   * This JWS Extension Header Parameter modifies the JWS Payload representation and the JWS Signing\n   * Input computation as per [RFC7797](https://www.rfc-editor.org/rfc/rfc7797).\n   */\n  b64?: boolean\n\n  /** JWS \"crit\" (Critical) Header Parameter. */\n  crit?: string[]\n\n  /** Any other JWS Header member. */\n  [propName: string]: unknown\n}\n\n/** Recognized JWE Key Management-related Header Parameters. */\nexport interface JWEKeyManagementHeaderParameters {\n  apu?: Uint8Array\n  apv?: Uint8Array\n  /**\n   * @deprecated You should not use this parameter. It is only really intended for test and vector\n   *   validation purposes.\n   */\n  p2c?: number\n  /**\n   * @deprecated You should not use this parameter. It is only really intended for test and vector\n   *   validation purposes.\n   */\n  p2s?: Uint8Array\n  /**\n   * @deprecated You should not use this parameter. It is only really intended for test and vector\n   *   validation purposes.\n   */\n  iv?: Uint8Array\n  /**\n   * @deprecated You should not use this parameter. It is only really intended for test and vector\n   *   validation purposes.\n   */\n  epk?: KeyLike\n}\n\n/** Flattened JWE definition. */\nexport interface FlattenedJWE {\n  /**\n   * The \"aad\" member MUST be present and contain the value BASE64URL(JWE AAD)) when the JWE AAD\n   * value is non-empty; otherwise, it MUST be absent. A JWE AAD value can be included to supply a\n   * base64url-encoded value to be integrity protected but not encrypted.\n   */\n  aad?: string\n\n  /** The \"ciphertext\" member MUST be present and contain the value BASE64URL(JWE Ciphertext). */\n  ciphertext: string\n\n  /**\n   * The \"encrypted_key\" member MUST be present and contain the value BASE64URL(JWE Encrypted Key)\n   * when the JWE Encrypted Key value is non-empty; otherwise, it MUST be absent.\n   */\n  encrypted_key?: string\n\n  /**\n   * The \"header\" member MUST be present and contain the value JWE Per- Recipient Unprotected Header\n   * when the JWE Per-Recipient Unprotected Header value is non-empty; otherwise, it MUST be absent.\n   * This value is represented as an unencoded JSON object, rather than as a string. These Header\n   * Parameter values are not integrity protected.\n   */\n  header?: JWEHeaderParameters\n\n  /**\n   * The \"iv\" member MUST be present and contain the value BASE64URL(JWE Initialization Vector) when\n   * the JWE Initialization Vector value is non-empty; otherwise, it MUST be absent.\n   */\n  iv: string\n\n  /**\n   * The \"protected\" member MUST be present and contain the value BASE64URL(UTF8(JWE Protected\n   * Header)) when the JWE Protected Header value is non-empty; otherwise, it MUST be absent. These\n   * Header Parameter values are integrity protected.\n   */\n  protected?: string\n\n  /**\n   * The \"tag\" member MUST be present and contain the value BASE64URL(JWE Authentication Tag) when\n   * the JWE Authentication Tag value is non-empty; otherwise, it MUST be absent.\n   */\n  tag: string\n\n  /**\n   * The \"unprotected\" member MUST be present and contain the value JWE Shared Unprotected Header\n   * when the JWE Shared Unprotected Header value is non-empty; otherwise, it MUST be absent. This\n   * value is represented as an unencoded JSON object, rather than as a string. These Header\n   * Parameter values are not integrity protected.\n   */\n  unprotected?: JWEHeaderParameters\n}\n\nexport interface GeneralJWE extends Omit<FlattenedJWE, 'encrypted_key' | 'header'> {\n  recipients: Pick<FlattenedJWE, 'encrypted_key' | 'header'>[]\n}\n\n/** Recognized JWE Header Parameters, any other Header members may also be present. */\nexport interface JWEHeaderParameters extends JoseHeaderParameters {\n  /** JWE \"alg\" (Algorithm) Header Parameter. */\n  alg?: string\n\n  /** JWE \"enc\" (Encryption Algorithm) Header Parameter. */\n  enc?: string\n\n  /** JWE \"crit\" (Critical) Header Parameter. */\n  crit?: string[]\n\n  /** JWE \"zip\" (Compression Algorithm) Header Parameter. */\n  zip?: string\n\n  /** Any other JWE Header member. */\n  [propName: string]: unknown\n}\n\n/** Shared Interface with a \"crit\" property for all sign, verify, encrypt and decrypt operations. */\nexport interface CritOption {\n  /**\n   * An object with keys representing recognized \"crit\" (Critical) Header Parameter names. The value\n   * for those is either `true` or `false`. `true` when the Header Parameter MUST be integrity\n   * protected, `false` when it's irrelevant.\n   *\n   * This makes the \"Extension Header Parameter \"${parameter}\" is not recognized\" error go away.\n   *\n   * Use this when a given JWS/JWT/JWE profile requires the use of proprietary non-registered \"crit\"\n   * (Critical) Header Parameters. This will only make sure the Header Parameter is syntactically\n   * correct when provided and that it is optionally integrity protected. It will not process the\n   * Header Parameter in any way or reject the operation if it is missing. You MUST still verify the\n   * Header Parameter was present and process it according to the profile's validation steps after\n   * the operation succeeds.\n   *\n   * The JWS extension Header Parameter `b64` is always recognized and processed properly. No other\n   * registered Header Parameters that need this kind of default built-in treatment are currently available.\n   */\n  crit?: {\n    [propName: string]: boolean\n  }\n}\n\n/** JWE Decryption options. */\nexport interface DecryptOptions extends CritOption {\n  /** A list of accepted JWE \"alg\" (Algorithm) Header Parameter values. */\n  keyManagementAlgorithms?: string[]\n\n  /**\n   * A list of accepted JWE \"enc\" (Encryption Algorithm) Header Parameter values. By default all\n   * \"enc\" (Encryption Algorithm) values applicable for the used key/secret are allowed.\n   */\n  contentEncryptionAlgorithms?: string[]\n\n  /**\n   * In a browser runtime you have to provide an implementation for Inflate Raw when you expect JWEs\n   * with compressed plaintext.\n   */\n  inflateRaw?: InflateFunction\n}\n\n/** JWE Deflate option. */\nexport interface DeflateOption {\n  /**\n   * In a browser runtime you have to provide an implementation for Deflate Raw when you will be\n   * producing JWEs with compressed plaintext.\n   */\n  deflateRaw?: DeflateFunction\n}\n\n/** JWE Encryption options. */\nexport interface EncryptOptions extends CritOption, DeflateOption {}\n\n/** JWT Claims Set verification options. */\nexport interface JWTClaimVerificationOptions {\n  /** Expected JWT \"aud\" (Audience) Claim value(s). */\n  audience?: string | string[]\n\n  /**\n   * Expected clock tolerance\n   *\n   * - In seconds when number (e.g. 5)\n   * - Parsed as seconds when a string (e.g. \"5 seconds\", \"10 minutes\", \"2 hours\").\n   */\n  clockTolerance?: string | number\n\n  /** Expected JWT \"iss\" (Issuer) Claim value(s). */\n  issuer?: string | string[]\n\n  /**\n   * Maximum time elapsed (in seconds) from the JWT \"iat\" (Issued At) Claim value.\n   *\n   * - In seconds when number (e.g. 5)\n   * - Parsed as seconds when a string (e.g. \"5 seconds\", \"10 minutes\", \"2 hours\").\n   */\n  maxTokenAge?: string | number\n\n  /** Expected JWT \"sub\" (Subject) Claim value. */\n  subject?: string\n\n  /** Expected JWT \"typ\" (Type) Header Parameter value. */\n  typ?: string\n\n  /** Date to use when comparing NumericDate claims, defaults to `new Date()`. */\n  currentDate?: Date\n}\n\n/** JWS Verification options. */\nexport interface VerifyOptions extends CritOption {\n  /**\n   * A list of accepted JWS \"alg\" (Algorithm) Header Parameter values. By default all \"alg\"\n   * (Algorithm) values applicable for the used key/secret are allowed. Note: \"none\" is never accepted.\n   */\n  algorithms?: string[]\n}\n\n/** JWS Signing options. */\nexport interface SignOptions extends CritOption {}\n\n/** Recognized JWT Claims Set members, any other members may also be present. */\nexport interface JWTPayload {\n  /** JWT Issuer - [RFC7519#section-4.1.1](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.1). */\n  iss?: string\n\n  /** JWT Subject - [RFC7519#section-4.1.2](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.2). */\n  sub?: string\n\n  /** JWT Audience [RFC7519#section-4.1.3](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.3). */\n  aud?: string | string[]\n\n  /** JWT ID - [RFC7519#section-4.1.7](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.7). */\n  jti?: string\n\n  /** JWT Not Before - [RFC7519#section-4.1.5](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.5). */\n  nbf?: number\n\n  /** JWT Expiration Time - [RFC7519#section-4.1.4](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.4). */\n  exp?: number\n\n  /** JWT Issued At - [RFC7519#section-4.1.6](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.6). */\n  iat?: number\n\n  /** Any other JWT Claim Set member. */\n  [propName: string]: unknown\n}\n\n/**\n * Deflate Raw implementation, e.g. promisified\n * [zlib.deflateRaw](https://nodejs.org/api/zlib.html#zlibdeflaterawbuffer-options-callback).\n */\nexport interface DeflateFunction {\n  (input: Uint8Array): Promise<Uint8Array>\n}\n\n/**\n * Inflate Raw implementation, e.g. promisified\n * [zlib.inflateRaw](https://nodejs.org/api/zlib.html#zlibinflaterawbuffer-options-callback).\n */\nexport interface InflateFunction {\n  (input: Uint8Array): Promise<Uint8Array>\n}\n\nexport interface FlattenedDecryptResult {\n  /** JWE AAD. */\n  additionalAuthenticatedData?: Uint8Array\n\n  /** Plaintext. */\n  plaintext: Uint8Array\n\n  /** JWE Protected Header. */\n  protectedHeader?: JWEHeaderParameters\n\n  /** JWE Shared Unprotected Header. */\n  sharedUnprotectedHeader?: JWEHeaderParameters\n\n  /** JWE Per-Recipient Unprotected Header. */\n  unprotectedHeader?: JWEHeaderParameters\n}\n\nexport interface GeneralDecryptResult extends FlattenedDecryptResult {}\n\nexport interface CompactDecryptResult {\n  /** Plaintext. */\n  plaintext: Uint8Array\n\n  /** JWE Protected Header. */\n  protectedHeader: CompactJWEHeaderParameters\n}\n\nexport interface FlattenedVerifyResult {\n  /** JWS Payload. */\n  payload: Uint8Array\n\n  /** JWS Protected Header. */\n  protectedHeader?: JWSHeaderParameters\n\n  /** JWS Unprotected Header. */\n  unprotectedHeader?: JWSHeaderParameters\n}\n\nexport interface GeneralVerifyResult extends FlattenedVerifyResult {}\n\nexport interface CompactVerifyResult {\n  /** JWS Payload. */\n  payload: Uint8Array\n\n  /** JWS Protected Header. */\n  protectedHeader: CompactJWSHeaderParameters\n}\n\nexport interface JWTVerifyResult {\n  /** JWT Claims Set. */\n  payload: JWTPayload\n\n  /** JWS Protected Header. */\n  protectedHeader: JWTHeaderParameters\n}\n\nexport interface JWTDecryptResult {\n  /** JWT Claims Set. */\n  payload: JWTPayload\n\n  /** JWE Protected Header. */\n  protectedHeader: CompactJWEHeaderParameters\n}\n\nexport interface ResolvedKey {\n  /** Key resolved from the key resolver function. */\n  key: KeyLike | Uint8Array\n}\n\n/** Recognized Compact JWS Header Parameters, any other Header Members may also be present. */\nexport interface CompactJWSHeaderParameters extends JWSHeaderParameters {\n  alg: string\n}\n\n/** Recognized Signed JWT Header Parameters, any other Header Members may also be present. */\nexport interface JWTHeaderParameters extends CompactJWSHeaderParameters {\n  b64?: true\n}\n\n/** Recognized Compact JWE Header Parameters, any other Header Members may also be present. */\nexport interface CompactJWEHeaderParameters extends JWEHeaderParameters {\n  alg: string\n  enc: string\n}\n\n/** JSON Web Key Set */\nexport interface JSONWebKeySet {\n  keys: JWK[]\n}\n", "import test from 'ava'\nimport * as crypto from 'crypto'\nimport { root } from '../dist.mjs'\n\nconst { FlattenedEncrypt, flattenedDecrypt, base64url } = await import(root)\n\ntest.before(async (t) => {\n  const encode = TextEncoder.prototype.encode.bind(new TextEncoder())\n  t.context.plaintext = encode('It\u2019s a dangerous business, Frodo, going out your door.')\n  t.context.additionalAuthenticatedData = encode('The Fellowship of the Ring')\n  t.context.initializationVector = new Uint8Array(12)\n  t.context.secret = new Uint8Array(16)\n})\n\ntest('JWE format validation', async (t) => {\n  const fullJwe = await new FlattenedEncrypt(t.context.plaintext)\n    .setProtectedHeader({ bar: 'baz' })\n    .setUnprotectedHeader({ foo: 'bar' })\n    .setSharedUnprotectedHeader({ alg: 'dir', enc: 'A128GCM' })\n    .setAdditionalAuthenticatedData(t.context.additionalAuthenticatedData)\n    .encrypt(t.context.secret)\n\n  {\n    await t.throwsAsync(flattenedDecrypt(null, t.context.secret), {\n      message: 'Flattened JWE must be an object',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    delete jwe.protected\n    delete jwe.header\n    delete jwe.unprotected\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'JOSE Header missing',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    delete jwe.iv\n    const assertion = {\n      message: 'JWE Initialization Vector missing or incorrect type',\n      code: 'ERR_JWE_INVALID',\n    }\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), assertion)\n    jwe.iv = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), assertion)\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    delete jwe.ciphertext\n    const assertion = {\n      message: 'JWE Ciphertext missing or incorrect type',\n      code: 'ERR_JWE_INVALID',\n    }\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), assertion)\n    jwe.ciphertext = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), assertion)\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    delete jwe.tag\n    const assertion = {\n      message: 'JWE Authentication Tag missing or incorrect type',\n      code: 'ERR_JWE_INVALID',\n    }\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), assertion)\n    jwe.tag = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), assertion)\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.protected = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'JWE Protected Header incorrect type',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    const assertion = {\n      message: 'JWE Protected Header is invalid',\n      code: 'ERR_JWE_INVALID',\n    }\n    jwe.protected = `1${jwe.protected}`\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), assertion)\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.encrypted_key = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'JWE Encrypted Key incorrect type',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.aad = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'JWE AAD incorrect type',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.header = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'JWE Shared Unprotected Header incorrect type',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.unprotected = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'JWE Per-Recipient Unprotected Header incorrect type',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.unprotected = { foo: 'bar' }\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message:\n        'JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.unprotected = { enc: 'A128GCM' }\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'missing JWE Algorithm (alg) in JWE Header',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.unprotected = { alg: 'dir' }\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'missing JWE Encryption Algorithm (enc) in JWE Header',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.encrypted_key = 'foo'\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'decryption operation failed',\n      code: 'ERR_JWE_DECRYPTION_FAILED',\n    })\n  }\n})\n\ntest('AES CBC + HMAC', async (t) => {\n  const secret = crypto.randomFillSync(new Uint8Array(32))\n  const jwe = await new FlattenedEncrypt(t.context.plaintext)\n    .setProtectedHeader({ alg: 'dir', enc: 'A128CBC-HS256' })\n    .encrypt(secret)\n\n  {\n    const jweBadTag = { ...jwe }\n    jweBadTag.tag = 'foo'\n    await t.throwsAsync(flattenedDecrypt(jweBadTag, secret), {\n      code: 'ERR_JWE_DECRYPTION_FAILED',\n      message: 'decryption operation failed',\n    })\n  }\n\n  {\n    const jweBadEnc = { ...jwe }\n    jweBadEnc.ciphertext = 'foo'\n    await t.throwsAsync(flattenedDecrypt(jweBadEnc, secret), {\n      code: 'ERR_JWE_DECRYPTION_FAILED',\n      message: 'decryption operation failed',\n    })\n  }\n\n  {\n    const altSecret = new Uint8Array(32)\n    altSecret.set(secret.slice(0, 16), 16)\n    altSecret.set(secret.slice(16), 0)\n    await t.throwsAsync(flattenedDecrypt(jwe, altSecret), {\n      code: 'ERR_JWE_DECRYPTION_FAILED',\n      message: 'decryption operation failed',\n    })\n  }\n})\n\ntest('decrypt empty data (GCM)', async (t) => {\n  const jwe = await new FlattenedEncrypt(new Uint8Array(0))\n    .setProtectedHeader({ alg: 'dir', enc: 'A128GCM' })\n    .encrypt(new Uint8Array(16))\n\n  t.is(jwe.ciphertext, '')\n\n  const { plaintext } = await flattenedDecrypt(jwe, new Uint8Array(16))\n  t.is(plaintext.byteLength, 0)\n})\n\ntest('decrypt empty data (CBC)', async (t) => {\n  const jwe = await new FlattenedEncrypt(new Uint8Array(0))\n    .setProtectedHeader({ alg: 'dir', enc: 'A128CBC-HS256' })\n    .encrypt(new Uint8Array(32))\n\n  t.is(base64url.decode(jwe.ciphertext).byteLength, 16)\n\n  const { plaintext } = await flattenedDecrypt(jwe, new Uint8Array(32))\n  t.is(plaintext.byteLength, 0)\n})\n"], "fixing_code": ["import { decode as base64url } from '../../runtime/base64url.js'\nimport decrypt from '../../runtime/decrypt.js'\nimport { inflate } from '../../runtime/zlib.js'\n\nimport { JOSEAlgNotAllowed, JOSENotSupported, JWEInvalid } from '../../util/errors.js'\nimport isDisjoint from '../../lib/is_disjoint.js'\nimport isObject from '../../lib/is_object.js'\nimport decryptKeyManagement from '../../lib/decrypt_key_management.js'\nimport type {\n  FlattenedDecryptResult,\n  KeyLike,\n  FlattenedJWE,\n  JWEHeaderParameters,\n  DecryptOptions,\n  GetKeyFunction,\n  ResolvedKey,\n} from '../../types.d'\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js'\nimport generateCek from '../../lib/cek.js'\nimport validateCrit from '../../lib/validate_crit.js'\nimport validateAlgorithms from '../../lib/validate_algorithms.js'\n\n/**\n * Interface for Flattened JWE Decryption dynamic key resolution. No token components have been\n * verified at the time of this function call.\n */\nexport interface FlattenedDecryptGetKey\n  extends GetKeyFunction<JWEHeaderParameters | undefined, FlattenedJWE> {}\n\n/**\n * Decrypts a Flattened JWE.\n *\n * @example Usage\n *\n * ```js\n * const jwe = {\n *   ciphertext: '9EzjFISUyoG-ifC2mSihfP0DPC80yeyrxhTzKt1C_VJBkxeBG0MI4Te61Pk45RAGubUvBpU9jm4',\n *   iv: '8Fy7A_IuoX5VXG9s',\n *   tag: 'W76IYV6arGRuDSaSyWrQNg',\n *   encrypted_key:\n *     'Z6eD4UK_yFb5ZoKvKkGAdqywEG_m0e4IYo0x8Vf30LAMJcsc-_zSgIeiF82teZyYi2YYduHKoqImk7MRnoPZOlEs0Q5BNK1OgBmSOhCE8DFyqh9Zh48TCTP6lmBQ52naqoUJFMtHzu-0LwZH26hxos0GP3Dt19O379MJB837TdKKa87skq0zHaVLAquRHOBF77GI54Bc7O49d8aOrSu1VEFGMThlW2caspPRiTSePDMDPq7_WGk50izRhB3Asl9wmP9wEeaTrkJKRnQj5ips1SAZ1hDBsqEQKKukxP1HtdcopHV5_qgwU8Hjm5EwSLMluMQuiE6hwlkXGOujZLVizA',\n *   aad: 'VGhlIEZlbGxvd3NoaXAgb2YgdGhlIFJpbmc',\n *   protected: 'eyJhbGciOiJSU0EtT0FFUC0yNTYiLCJlbmMiOiJBMjU2R0NNIn0',\n * }\n *\n * const { plaintext, protectedHeader, additionalAuthenticatedData } =\n *   await jose.flattenedDecrypt(jwe, privateKey)\n *\n * console.log(protectedHeader)\n * const decoder = new TextDecoder()\n * console.log(decoder.decode(plaintext))\n * console.log(decoder.decode(additionalAuthenticatedData))\n * ```\n *\n * @param jwe Flattened JWE.\n * @param key Private Key or Secret to decrypt the JWE with.\n * @param options JWE Decryption options.\n */\nexport function flattenedDecrypt(\n  jwe: FlattenedJWE,\n  key: KeyLike | Uint8Array,\n  options?: DecryptOptions,\n): Promise<FlattenedDecryptResult>\n/**\n * @param jwe Flattened JWE.\n * @param getKey Function resolving Private Key or Secret to decrypt the JWE with.\n * @param options JWE Decryption options.\n */\nexport function flattenedDecrypt(\n  jwe: FlattenedJWE,\n  getKey: FlattenedDecryptGetKey,\n  options?: DecryptOptions,\n): Promise<FlattenedDecryptResult & ResolvedKey>\nexport async function flattenedDecrypt(\n  jwe: FlattenedJWE,\n  key: KeyLike | Uint8Array | FlattenedDecryptGetKey,\n  options?: DecryptOptions,\n) {\n  if (!isObject(jwe)) {\n    throw new JWEInvalid('Flattened JWE must be an object')\n  }\n\n  if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {\n    throw new JWEInvalid('JOSE Header missing')\n  }\n\n  if (typeof jwe.iv !== 'string') {\n    throw new JWEInvalid('JWE Initialization Vector missing or incorrect type')\n  }\n\n  if (typeof jwe.ciphertext !== 'string') {\n    throw new JWEInvalid('JWE Ciphertext missing or incorrect type')\n  }\n\n  if (typeof jwe.tag !== 'string') {\n    throw new JWEInvalid('JWE Authentication Tag missing or incorrect type')\n  }\n\n  if (jwe.protected !== undefined && typeof jwe.protected !== 'string') {\n    throw new JWEInvalid('JWE Protected Header incorrect type')\n  }\n\n  if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') {\n    throw new JWEInvalid('JWE Encrypted Key incorrect type')\n  }\n\n  if (jwe.aad !== undefined && typeof jwe.aad !== 'string') {\n    throw new JWEInvalid('JWE AAD incorrect type')\n  }\n\n  if (jwe.header !== undefined && !isObject(jwe.header)) {\n    throw new JWEInvalid('JWE Shared Unprotected Header incorrect type')\n  }\n\n  if (jwe.unprotected !== undefined && !isObject(jwe.unprotected)) {\n    throw new JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type')\n  }\n\n  let parsedProt!: JWEHeaderParameters\n  if (jwe.protected) {\n    try {\n      const protectedHeader = base64url(jwe.protected)\n      parsedProt = JSON.parse(decoder.decode(protectedHeader))\n    } catch {\n      throw new JWEInvalid('JWE Protected Header is invalid')\n    }\n  }\n  if (!isDisjoint(parsedProt, jwe.header, jwe.unprotected)) {\n    throw new JWEInvalid(\n      'JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint',\n    )\n  }\n\n  const joseHeader: JWEHeaderParameters = {\n    ...parsedProt,\n    ...jwe.header,\n    ...jwe.unprotected,\n  }\n\n  validateCrit(JWEInvalid, new Map(), options?.crit, parsedProt, joseHeader)\n\n  if (joseHeader.zip !== undefined) {\n    if (!parsedProt || !parsedProt.zip) {\n      throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected')\n    }\n\n    if (joseHeader.zip !== 'DEF') {\n      throw new JOSENotSupported(\n        'Unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value',\n      )\n    }\n  }\n\n  const { alg, enc } = joseHeader\n\n  if (typeof alg !== 'string' || !alg) {\n    throw new JWEInvalid('missing JWE Algorithm (alg) in JWE Header')\n  }\n\n  if (typeof enc !== 'string' || !enc) {\n    throw new JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header')\n  }\n\n  const keyManagementAlgorithms =\n    options && validateAlgorithms('keyManagementAlgorithms', options.keyManagementAlgorithms)\n  const contentEncryptionAlgorithms =\n    options &&\n    validateAlgorithms('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms)\n\n  if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {\n    throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed')\n  }\n\n  if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n    throw new JOSEAlgNotAllowed('\"enc\" (Encryption Algorithm) Header Parameter not allowed')\n  }\n\n  let encryptedKey!: Uint8Array\n  if (jwe.encrypted_key !== undefined) {\n    encryptedKey = base64url(jwe.encrypted_key!)\n  }\n\n  let resolvedKey = false\n  if (typeof key === 'function') {\n    key = await key(parsedProt, jwe)\n    resolvedKey = true\n  }\n\n  let cek: KeyLike | Uint8Array\n  try {\n    cek = await decryptKeyManagement(alg, key, encryptedKey, joseHeader, options)\n  } catch (err) {\n    if (err instanceof TypeError || err instanceof JWEInvalid || err instanceof JOSENotSupported) {\n      throw err\n    }\n    // https://www.rfc-editor.org/rfc/rfc7516#section-11.5\n    // To mitigate the attacks described in RFC 3218, the\n    // recipient MUST NOT distinguish between format, padding, and length\n    // errors of encrypted keys.  It is strongly recommended, in the event\n    // of receiving an improperly formatted key, that the recipient\n    // substitute a randomly generated CEK and proceed to the next step, to\n    // mitigate timing attacks.\n    cek = generateCek(enc)\n  }\n\n  const iv = base64url(jwe.iv)\n  const tag = base64url(jwe.tag)\n\n  const protectedHeader: Uint8Array = encoder.encode(jwe.protected ?? '')\n  let additionalData: Uint8Array\n\n  if (jwe.aad !== undefined) {\n    additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(jwe.aad))\n  } else {\n    additionalData = protectedHeader\n  }\n\n  let plaintext = await decrypt(enc, cek, base64url(jwe.ciphertext), iv, tag, additionalData)\n\n  if (joseHeader.zip === 'DEF') {\n    plaintext = await (options?.inflateRaw || inflate)(plaintext)\n  }\n\n  const result: FlattenedDecryptResult = { plaintext }\n\n  if (jwe.protected !== undefined) {\n    result.protectedHeader = parsedProt\n  }\n\n  if (jwe.aad !== undefined) {\n    result.additionalAuthenticatedData = base64url(jwe.aad!)\n  }\n\n  if (jwe.unprotected !== undefined) {\n    result.sharedUnprotectedHeader = jwe.unprotected\n  }\n\n  if (jwe.header !== undefined) {\n    result.unprotectedHeader = jwe.header\n  }\n\n  if (resolvedKey) {\n    return { ...result, key }\n  }\n\n  return result\n}\n", "import { unwrap as aesKw } from '../runtime/aeskw.js'\nimport * as ECDH from '../runtime/ecdhes.js'\nimport { decrypt as pbes2Kw } from '../runtime/pbes2kw.js'\nimport { decrypt as rsaEs } from '../runtime/rsaes.js'\nimport { decode as base64url } from '../runtime/base64url.js'\n\nimport type { DecryptOptions, JWEHeaderParameters, KeyLike, JWK } from '../types.d'\nimport { JOSENotSupported, JWEInvalid } from '../util/errors.js'\nimport { bitLength as cekLength } from '../lib/cek.js'\nimport { importJWK } from '../key/import.js'\nimport checkKeyType from './check_key_type.js'\nimport isObject from './is_object.js'\nimport { unwrap as aesGcmKw } from './aesgcmkw.js'\n\nasync function decryptKeyManagement(\n  alg: string,\n  key: KeyLike | Uint8Array,\n  encryptedKey: Uint8Array | undefined,\n  joseHeader: JWEHeaderParameters,\n  options?: DecryptOptions,\n): Promise<KeyLike | Uint8Array> {\n  checkKeyType(alg, key, 'decrypt')\n\n  switch (alg) {\n    case 'dir': {\n      // Direct Encryption\n      if (encryptedKey !== undefined)\n        throw new JWEInvalid('Encountered unexpected JWE Encrypted Key')\n\n      return key\n    }\n    case 'ECDH-ES':\n      // Direct Key Agreement\n      if (encryptedKey !== undefined)\n        throw new JWEInvalid('Encountered unexpected JWE Encrypted Key')\n\n    case 'ECDH-ES+A128KW':\n    case 'ECDH-ES+A192KW':\n    case 'ECDH-ES+A256KW': {\n      // Direct Key Agreement\n      if (!isObject<JWK>(joseHeader.epk))\n        throw new JWEInvalid(`JOSE Header \"epk\" (Ephemeral Public Key) missing or invalid`)\n\n      if (!ECDH.ecdhAllowed(key))\n        throw new JOSENotSupported(\n          'ECDH with the provided key is not allowed or not supported by your javascript runtime',\n        )\n\n      const epk = await importJWK(joseHeader.epk, alg)\n      let partyUInfo!: Uint8Array\n      let partyVInfo!: Uint8Array\n\n      if (joseHeader.apu !== undefined) {\n        if (typeof joseHeader.apu !== 'string')\n          throw new JWEInvalid(`JOSE Header \"apu\" (Agreement PartyUInfo) invalid`)\n        partyUInfo = base64url(joseHeader.apu)\n      }\n\n      if (joseHeader.apv !== undefined) {\n        if (typeof joseHeader.apv !== 'string')\n          throw new JWEInvalid(`JOSE Header \"apv\" (Agreement PartyVInfo) invalid`)\n        partyVInfo = base64url(joseHeader.apv)\n      }\n\n      const sharedSecret = await ECDH.deriveKey(\n        epk,\n        key,\n        alg === 'ECDH-ES' ? joseHeader.enc! : alg,\n        alg === 'ECDH-ES' ? cekLength(joseHeader.enc!) : parseInt(alg.slice(-5, -2), 10),\n        partyUInfo,\n        partyVInfo,\n      )\n\n      if (alg === 'ECDH-ES') return sharedSecret\n\n      // Key Agreement with Key Wrapping\n      if (encryptedKey === undefined) throw new JWEInvalid('JWE Encrypted Key missing')\n\n      return aesKw(alg.slice(-6), sharedSecret, encryptedKey)\n    }\n    case 'RSA1_5':\n    case 'RSA-OAEP':\n    case 'RSA-OAEP-256':\n    case 'RSA-OAEP-384':\n    case 'RSA-OAEP-512': {\n      // Key Encryption (RSA)\n      if (encryptedKey === undefined) throw new JWEInvalid('JWE Encrypted Key missing')\n\n      return rsaEs(alg, key, encryptedKey)\n    }\n    case 'PBES2-HS256+A128KW':\n    case 'PBES2-HS384+A192KW':\n    case 'PBES2-HS512+A256KW': {\n      // Key Encryption (PBES2)\n      if (encryptedKey === undefined) throw new JWEInvalid('JWE Encrypted Key missing')\n\n      if (typeof joseHeader.p2c !== 'number')\n        throw new JWEInvalid(`JOSE Header \"p2c\" (PBES2 Count) missing or invalid`)\n\n      const p2cLimit = options?.maxPBES2Count || 10_000\n\n      if (joseHeader.p2c > p2cLimit)\n        throw new JWEInvalid(`JOSE Header \"p2c\" (PBES2 Count) out is of acceptable bounds`)\n\n      if (typeof joseHeader.p2s !== 'string')\n        throw new JWEInvalid(`JOSE Header \"p2s\" (PBES2 Salt) missing or invalid`)\n\n      return pbes2Kw(alg, key, encryptedKey, joseHeader.p2c, base64url(joseHeader.p2s))\n    }\n    case 'A128KW':\n    case 'A192KW':\n    case 'A256KW': {\n      // Key Wrapping (AES KW)\n      if (encryptedKey === undefined) throw new JWEInvalid('JWE Encrypted Key missing')\n\n      return aesKw(alg, key, encryptedKey)\n    }\n    case 'A128GCMKW':\n    case 'A192GCMKW':\n    case 'A256GCMKW': {\n      // Key Wrapping (AES GCM KW)\n      if (encryptedKey === undefined) throw new JWEInvalid('JWE Encrypted Key missing')\n\n      if (typeof joseHeader.iv !== 'string')\n        throw new JWEInvalid(`JOSE Header \"iv\" (Initialization Vector) missing or invalid`)\n\n      if (typeof joseHeader.tag !== 'string')\n        throw new JWEInvalid(`JOSE Header \"tag\" (Authentication Tag) missing or invalid`)\n\n      const iv = base64url(joseHeader.iv)\n      const tag = base64url(joseHeader.tag)\n\n      return aesGcmKw(alg, key, encryptedKey, iv, tag)\n    }\n    default: {\n      throw new JOSENotSupported('Invalid or unsupported \"alg\" (JWE Algorithm) header value')\n    }\n  }\n}\n\nexport default decryptKeyManagement\n", "/**\n * KeyLike are runtime-specific classes representing asymmetric keys or symmetric secrets. These are\n * instances of [CryptoKey](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) and\n * additionally [KeyObject](https://nodejs.org/api/crypto.html#class-keyobject) in Node.js runtime.\n * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)\n * instances are also accepted as symmetric secret representation only.\n *\n * [Key Import Functions](../modules/key_import.md#readme) can be used to import PEM, or JWK\n * formatted asymmetric keys and certificates to these runtime-specific representations.\n *\n * In Node.js the [Buffer](https://nodejs.org/api/buffer.html#buffer) class is a subclass of\n * Uint8Array and so Buffer can be provided for symmetric secrets as well.\n *\n * [KeyObject](https://nodejs.org/api/crypto.html#class-keyobject) is a representation of a\n * key/secret available in the Node.js runtime. In addition to the import functions of this library\n * you may use the runtime APIs\n * [crypto.createPublicKey](https://nodejs.org/api/crypto.html#cryptocreatepublickeykey),\n * [crypto.createPrivateKey](https://nodejs.org/api/crypto.html#cryptocreateprivatekeykey), and\n * [crypto.createSecretKey](https://nodejs.org/api/crypto.html#cryptocreatesecretkeykey-encoding) to\n * obtain a KeyObject from your existing key material.\n *\n * [CryptoKey](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) is a representation of a\n * key/secret available in the Browser and Deno runtimes. In addition to the import functions of\n * this library you may use the\n * [SubtleCrypto.importKey](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey)\n * API to obtain a CryptoKey from your existing key material.\n *\n * @example Import a PEM-encoded SPKI Public Key\n *\n * ```js\n * const algorithm = 'ES256'\n * const spki = `-----BEGIN PUBLIC KEY-----\n * MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEFlHHWfLk0gLBbsLTcuCrbCqoHqmM\n * YJepMC+Q+Dd6RBmBiA41evUsNMwLeN+PNFqib+xwi9JkJ8qhZkq8Y/IzGg==\n * -----END PUBLIC KEY-----`\n * const ecPublicKey = await jose.importSPKI(spki, algorithm)\n * ```\n *\n * @example Import a X.509 Certificate\n *\n * ```js\n * const algorithm = 'ES256'\n * const x509 = `-----BEGIN CERTIFICATE-----\n * MIIBXjCCAQSgAwIBAgIGAXvykuMKMAoGCCqGSM49BAMCMDYxNDAyBgNVBAMMK3Np\n * QXBNOXpBdk1VaXhXVWVGaGtjZXg1NjJRRzFyQUhXaV96UlFQTVpQaG8wHhcNMjEw\n * OTE3MDcwNTE3WhcNMjIwNzE0MDcwNTE3WjA2MTQwMgYDVQQDDCtzaUFwTTl6QXZN\n * VWl4V1VlRmhrY2V4NTYyUUcxckFIV2lfelJRUE1aUGhvMFkwEwYHKoZIzj0CAQYI\n * KoZIzj0DAQcDQgAE8PbPvCv5D5xBFHEZlBp/q5OEUymq7RIgWIi7tkl9aGSpYE35\n * UH+kBKDnphJO3odpPZ5gvgKs2nwRWcrDnUjYLDAKBggqhkjOPQQDAgNIADBFAiEA\n * 1yyMTRe66MhEXID9+uVub7woMkNYd0LhSHwKSPMUUTkCIFQGsfm1ecXOpeGOufAh\n * v+A1QWZMuTWqYt+uh/YSRNDn\n * -----END CERTIFICATE-----`\n * const ecPublicKey = await jose.importX509(x509, algorithm)\n * ```\n *\n * @example Import a PEM-encoded PKCS8 Private Key\n *\n * ```js\n * const algorithm = 'ES256'\n * const pkcs8 = `-----BEGIN PRIVATE KEY-----\n * MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgiyvo0X+VQ0yIrOaN\n * nlrnUclopnvuuMfoc8HHly3505OhRANCAAQWUcdZ8uTSAsFuwtNy4KtsKqgeqYxg\n * l6kwL5D4N3pEGYGIDjV69Sw0zAt43480WqJv7HCL0mQnyqFmSrxj8jMa\n * -----END PRIVATE KEY-----`\n * const ecPrivateKey = await jose.importPKCS8(pkcs8, algorithm)\n * ```\n *\n * @example Import a JSON Web Key (JWK)\n *\n * ```js\n * const ecPublicKey = await jose.importJWK(\n *   {\n *     crv: 'P-256',\n *     kty: 'EC',\n *     x: 'ySK38C1jBdLwDsNWKzzBHqKYEE5Cgv-qjWvorUXk9fw',\n *     y: '_LeQBw07cf5t57Iavn4j-BqJsAD1dpoz8gokd3sBsOo',\n *   },\n *   'ES256',\n * )\n *\n * const rsaPublicKey = await jose.importJWK(\n *   {\n *     kty: 'RSA',\n *     e: 'AQAB',\n *     n: '12oBZRhCiZFJLcPg59LkZZ9mdhSMTKAQZYq32k_ti5SBB6jerkh-WzOMAO664r_qyLkqHUSp3u5SbXtseZEpN3XPWGKSxjsy-1JyEFTdLSYe6f9gfrmxkUF_7DTpq0gn6rntP05g2-wFW50YO7mosfdslfrTJYWHFhJALabAeYirYD7-9kqq9ebfFMF4sRRELbv9oi36As6Q9B3Qb5_C1rAzqfao_PCsf9EPsTZsVVVkA5qoIAr47lo1ipfiBPxUCCNSdvkmDTYgvvRm6ZoMjFbvOtgyts55fXKdMWv7I9HMD5HwE9uW839PWA514qhbcIsXEYSFMPMV6fnlsiZvQQ',\n *   },\n *   'PS256',\n * )\n * ```\n */\nexport type KeyLike = { type: string }\n\n/**\n * JSON Web Key ([JWK](https://www.rfc-editor.org/rfc/rfc7517)). \"RSA\", \"EC\", \"OKP\", and \"oct\" key\n * types are supported.\n */\nexport interface JWK {\n  /** JWK \"alg\" (Algorithm) Parameter. */\n  alg?: string\n  crv?: string\n  d?: string\n  dp?: string\n  dq?: string\n  e?: string\n  /** JWK \"ext\" (Extractable) Parameter. */\n  ext?: boolean\n  k?: string\n  /** JWK \"key_ops\" (Key Operations) Parameter. */\n  key_ops?: string[]\n  /** JWK \"kid\" (Key ID) Parameter. */\n  kid?: string\n  /** JWK \"kty\" (Key Type) Parameter. */\n  kty?: string\n  n?: string\n  oth?: Array<{\n    d?: string\n    r?: string\n    t?: string\n  }>\n  p?: string\n  q?: string\n  qi?: string\n  /** JWK \"use\" (Public Key Use) Parameter. */\n  use?: string\n  x?: string\n  y?: string\n  /** JWK \"x5c\" (X.509 Certificate Chain) Parameter. */\n  x5c?: string[]\n  /** JWK \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Parameter. */\n  x5t?: string\n  /** \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Parameter. */\n  'x5t#S256'?: string\n  /** JWK \"x5u\" (X.509 URL) Parameter. */\n  x5u?: string\n\n  [propName: string]: unknown\n}\n\n/**\n * Generic Interface for consuming operations dynamic key resolution. No token components have been\n * verified at the time of this function call.\n *\n * If you cannot match a key suitable for the token, throw an error instead.\n *\n * @param protectedHeader JWE or JWS Protected Header.\n * @param token The consumed JWE or JWS token.\n */\nexport interface GetKeyFunction<T, T2> {\n  (protectedHeader: T, token: T2): Promise<KeyLike | Uint8Array> | KeyLike | Uint8Array\n}\n\n/**\n * Flattened JWS definition for verify function inputs, allows payload as Uint8Array for detached\n * signature validation.\n */\nexport interface FlattenedJWSInput {\n  /**\n   * The \"header\" member MUST be present and contain the value JWS Unprotected Header when the JWS\n   * Unprotected Header value is non- empty; otherwise, it MUST be absent. This value is represented\n   * as an unencoded JSON object, rather than as a string. These Header Parameter values are not\n   * integrity protected.\n   */\n  header?: JWSHeaderParameters\n\n  /**\n   * The \"payload\" member MUST be present and contain the value BASE64URL(JWS Payload). When RFC7797\n   * \"b64\": false is used the value passed may also be a Uint8Array.\n   */\n  payload: string | Uint8Array\n\n  /**\n   * The \"protected\" member MUST be present and contain the value BASE64URL(UTF8(JWS Protected\n   * Header)) when the JWS Protected Header value is non-empty; otherwise, it MUST be absent. These\n   * Header Parameter values are integrity protected.\n   */\n  protected?: string\n\n  /** The \"signature\" member MUST be present and contain the value BASE64URL(JWS Signature). */\n  signature: string\n}\n\n/**\n * General JWS definition for verify function inputs, allows payload as Uint8Array for detached\n * signature validation.\n */\nexport interface GeneralJWSInput {\n  /**\n   * The \"payload\" member MUST be present and contain the value BASE64URL(JWS Payload). When RFC7797\n   * \"b64\": false is used the value passed may also be a Uint8Array.\n   */\n  payload: string | Uint8Array\n\n  /**\n   * The \"signatures\" member value MUST be an array of JSON objects. Each object represents a\n   * signature or MAC over the JWS Payload and the JWS Protected Header.\n   */\n  signatures: Omit<FlattenedJWSInput, 'payload'>[]\n}\n\n/**\n * Flattened JWS definition. Payload is returned as an empty string when JWS Unencoded Payload\n * Option [RFC7797](https://www.rfc-editor.org/rfc/rfc7797) is used.\n */\nexport interface FlattenedJWS extends Partial<FlattenedJWSInput> {\n  payload: string\n  signature: string\n}\n\n/**\n * General JWS definition. Payload is returned as an empty string when JWS Unencoded Payload Option\n * [RFC7797](https://www.rfc-editor.org/rfc/rfc7797) is used.\n */\nexport interface GeneralJWS {\n  payload: string\n  signatures: Omit<FlattenedJWSInput, 'payload'>[]\n}\n\nexport interface JoseHeaderParameters {\n  /** \"kid\" (Key ID) Header Parameter. */\n  kid?: string\n\n  /** \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter. */\n  x5t?: string\n\n  /** \"x5c\" (X.509 Certificate Chain) Header Parameter. */\n  x5c?: string[]\n\n  /** \"x5u\" (X.509 URL) Header Parameter. */\n  x5u?: string\n\n  /** \"jku\" (JWK Set URL) Header Parameter. */\n  jku?: string\n\n  /** \"jwk\" (JSON Web Key) Header Parameter. */\n  jwk?: Pick<JWK, 'kty' | 'crv' | 'x' | 'y' | 'e' | 'n'>\n\n  /** \"typ\" (Type) Header Parameter. */\n  typ?: string\n\n  /** \"cty\" (Content Type) Header Parameter. */\n  cty?: string\n}\n\n/** Recognized JWS Header Parameters, any other Header Members may also be present. */\nexport interface JWSHeaderParameters extends JoseHeaderParameters {\n  /** JWS \"alg\" (Algorithm) Header Parameter. */\n  alg?: string\n\n  /**\n   * This JWS Extension Header Parameter modifies the JWS Payload representation and the JWS Signing\n   * Input computation as per [RFC7797](https://www.rfc-editor.org/rfc/rfc7797).\n   */\n  b64?: boolean\n\n  /** JWS \"crit\" (Critical) Header Parameter. */\n  crit?: string[]\n\n  /** Any other JWS Header member. */\n  [propName: string]: unknown\n}\n\n/** Recognized JWE Key Management-related Header Parameters. */\nexport interface JWEKeyManagementHeaderParameters {\n  apu?: Uint8Array\n  apv?: Uint8Array\n  /**\n   * @deprecated You should not use this parameter. It is only really intended for test and vector\n   *   validation purposes.\n   */\n  p2c?: number\n  /**\n   * @deprecated You should not use this parameter. It is only really intended for test and vector\n   *   validation purposes.\n   */\n  p2s?: Uint8Array\n  /**\n   * @deprecated You should not use this parameter. It is only really intended for test and vector\n   *   validation purposes.\n   */\n  iv?: Uint8Array\n  /**\n   * @deprecated You should not use this parameter. It is only really intended for test and vector\n   *   validation purposes.\n   */\n  epk?: KeyLike\n}\n\n/** Flattened JWE definition. */\nexport interface FlattenedJWE {\n  /**\n   * The \"aad\" member MUST be present and contain the value BASE64URL(JWE AAD)) when the JWE AAD\n   * value is non-empty; otherwise, it MUST be absent. A JWE AAD value can be included to supply a\n   * base64url-encoded value to be integrity protected but not encrypted.\n   */\n  aad?: string\n\n  /** The \"ciphertext\" member MUST be present and contain the value BASE64URL(JWE Ciphertext). */\n  ciphertext: string\n\n  /**\n   * The \"encrypted_key\" member MUST be present and contain the value BASE64URL(JWE Encrypted Key)\n   * when the JWE Encrypted Key value is non-empty; otherwise, it MUST be absent.\n   */\n  encrypted_key?: string\n\n  /**\n   * The \"header\" member MUST be present and contain the value JWE Per- Recipient Unprotected Header\n   * when the JWE Per-Recipient Unprotected Header value is non-empty; otherwise, it MUST be absent.\n   * This value is represented as an unencoded JSON object, rather than as a string. These Header\n   * Parameter values are not integrity protected.\n   */\n  header?: JWEHeaderParameters\n\n  /**\n   * The \"iv\" member MUST be present and contain the value BASE64URL(JWE Initialization Vector) when\n   * the JWE Initialization Vector value is non-empty; otherwise, it MUST be absent.\n   */\n  iv: string\n\n  /**\n   * The \"protected\" member MUST be present and contain the value BASE64URL(UTF8(JWE Protected\n   * Header)) when the JWE Protected Header value is non-empty; otherwise, it MUST be absent. These\n   * Header Parameter values are integrity protected.\n   */\n  protected?: string\n\n  /**\n   * The \"tag\" member MUST be present and contain the value BASE64URL(JWE Authentication Tag) when\n   * the JWE Authentication Tag value is non-empty; otherwise, it MUST be absent.\n   */\n  tag: string\n\n  /**\n   * The \"unprotected\" member MUST be present and contain the value JWE Shared Unprotected Header\n   * when the JWE Shared Unprotected Header value is non-empty; otherwise, it MUST be absent. This\n   * value is represented as an unencoded JSON object, rather than as a string. These Header\n   * Parameter values are not integrity protected.\n   */\n  unprotected?: JWEHeaderParameters\n}\n\nexport interface GeneralJWE extends Omit<FlattenedJWE, 'encrypted_key' | 'header'> {\n  recipients: Pick<FlattenedJWE, 'encrypted_key' | 'header'>[]\n}\n\n/** Recognized JWE Header Parameters, any other Header members may also be present. */\nexport interface JWEHeaderParameters extends JoseHeaderParameters {\n  /** JWE \"alg\" (Algorithm) Header Parameter. */\n  alg?: string\n\n  /** JWE \"enc\" (Encryption Algorithm) Header Parameter. */\n  enc?: string\n\n  /** JWE \"crit\" (Critical) Header Parameter. */\n  crit?: string[]\n\n  /** JWE \"zip\" (Compression Algorithm) Header Parameter. */\n  zip?: string\n\n  /** Any other JWE Header member. */\n  [propName: string]: unknown\n}\n\n/** Shared Interface with a \"crit\" property for all sign, verify, encrypt and decrypt operations. */\nexport interface CritOption {\n  /**\n   * An object with keys representing recognized \"crit\" (Critical) Header Parameter names. The value\n   * for those is either `true` or `false`. `true` when the Header Parameter MUST be integrity\n   * protected, `false` when it's irrelevant.\n   *\n   * This makes the \"Extension Header Parameter \"${parameter}\" is not recognized\" error go away.\n   *\n   * Use this when a given JWS/JWT/JWE profile requires the use of proprietary non-registered \"crit\"\n   * (Critical) Header Parameters. This will only make sure the Header Parameter is syntactically\n   * correct when provided and that it is optionally integrity protected. It will not process the\n   * Header Parameter in any way or reject the operation if it is missing. You MUST still verify the\n   * Header Parameter was present and process it according to the profile's validation steps after\n   * the operation succeeds.\n   *\n   * The JWS extension Header Parameter `b64` is always recognized and processed properly. No other\n   * registered Header Parameters that need this kind of default built-in treatment are currently available.\n   */\n  crit?: {\n    [propName: string]: boolean\n  }\n}\n\n/** JWE Decryption options. */\nexport interface DecryptOptions extends CritOption {\n  /** A list of accepted JWE \"alg\" (Algorithm) Header Parameter values. */\n  keyManagementAlgorithms?: string[]\n\n  /**\n   * A list of accepted JWE \"enc\" (Encryption Algorithm) Header Parameter values. By default all\n   * \"enc\" (Encryption Algorithm) values applicable for the used key/secret are allowed.\n   */\n  contentEncryptionAlgorithms?: string[]\n\n  /**\n   * In a browser runtime you have to provide an implementation for Inflate Raw when you expect JWEs\n   * with compressed plaintext.\n   */\n  inflateRaw?: InflateFunction\n\n  /**\n   * (PBES2 Key Management Algorithms only) Maximum allowed \"p2c\" (PBES2 Count) Header Parameter\n   * value. The PBKDF2 iteration count defines the algorithm's computational expense. By default\n   * this value is set to 10000.\n   */\n  maxPBES2Count?: number\n}\n\n/** JWE Deflate option. */\nexport interface DeflateOption {\n  /**\n   * In a browser runtime you have to provide an implementation for Deflate Raw when you will be\n   * producing JWEs with compressed plaintext.\n   */\n  deflateRaw?: DeflateFunction\n}\n\n/** JWE Encryption options. */\nexport interface EncryptOptions extends CritOption, DeflateOption {}\n\n/** JWT Claims Set verification options. */\nexport interface JWTClaimVerificationOptions {\n  /** Expected JWT \"aud\" (Audience) Claim value(s). */\n  audience?: string | string[]\n\n  /**\n   * Expected clock tolerance\n   *\n   * - In seconds when number (e.g. 5)\n   * - Parsed as seconds when a string (e.g. \"5 seconds\", \"10 minutes\", \"2 hours\").\n   */\n  clockTolerance?: string | number\n\n  /** Expected JWT \"iss\" (Issuer) Claim value(s). */\n  issuer?: string | string[]\n\n  /**\n   * Maximum time elapsed (in seconds) from the JWT \"iat\" (Issued At) Claim value.\n   *\n   * - In seconds when number (e.g. 5)\n   * - Parsed as seconds when a string (e.g. \"5 seconds\", \"10 minutes\", \"2 hours\").\n   */\n  maxTokenAge?: string | number\n\n  /** Expected JWT \"sub\" (Subject) Claim value. */\n  subject?: string\n\n  /** Expected JWT \"typ\" (Type) Header Parameter value. */\n  typ?: string\n\n  /** Date to use when comparing NumericDate claims, defaults to `new Date()`. */\n  currentDate?: Date\n}\n\n/** JWS Verification options. */\nexport interface VerifyOptions extends CritOption {\n  /**\n   * A list of accepted JWS \"alg\" (Algorithm) Header Parameter values. By default all \"alg\"\n   * (Algorithm) values applicable for the used key/secret are allowed. Note: \"none\" is never accepted.\n   */\n  algorithms?: string[]\n}\n\n/** JWS Signing options. */\nexport interface SignOptions extends CritOption {}\n\n/** Recognized JWT Claims Set members, any other members may also be present. */\nexport interface JWTPayload {\n  /** JWT Issuer - [RFC7519#section-4.1.1](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.1). */\n  iss?: string\n\n  /** JWT Subject - [RFC7519#section-4.1.2](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.2). */\n  sub?: string\n\n  /** JWT Audience [RFC7519#section-4.1.3](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.3). */\n  aud?: string | string[]\n\n  /** JWT ID - [RFC7519#section-4.1.7](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.7). */\n  jti?: string\n\n  /** JWT Not Before - [RFC7519#section-4.1.5](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.5). */\n  nbf?: number\n\n  /** JWT Expiration Time - [RFC7519#section-4.1.4](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.4). */\n  exp?: number\n\n  /** JWT Issued At - [RFC7519#section-4.1.6](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.6). */\n  iat?: number\n\n  /** Any other JWT Claim Set member. */\n  [propName: string]: unknown\n}\n\n/**\n * Deflate Raw implementation, e.g. promisified\n * [zlib.deflateRaw](https://nodejs.org/api/zlib.html#zlibdeflaterawbuffer-options-callback).\n */\nexport interface DeflateFunction {\n  (input: Uint8Array): Promise<Uint8Array>\n}\n\n/**\n * Inflate Raw implementation, e.g. promisified\n * [zlib.inflateRaw](https://nodejs.org/api/zlib.html#zlibinflaterawbuffer-options-callback).\n */\nexport interface InflateFunction {\n  (input: Uint8Array): Promise<Uint8Array>\n}\n\nexport interface FlattenedDecryptResult {\n  /** JWE AAD. */\n  additionalAuthenticatedData?: Uint8Array\n\n  /** Plaintext. */\n  plaintext: Uint8Array\n\n  /** JWE Protected Header. */\n  protectedHeader?: JWEHeaderParameters\n\n  /** JWE Shared Unprotected Header. */\n  sharedUnprotectedHeader?: JWEHeaderParameters\n\n  /** JWE Per-Recipient Unprotected Header. */\n  unprotectedHeader?: JWEHeaderParameters\n}\n\nexport interface GeneralDecryptResult extends FlattenedDecryptResult {}\n\nexport interface CompactDecryptResult {\n  /** Plaintext. */\n  plaintext: Uint8Array\n\n  /** JWE Protected Header. */\n  protectedHeader: CompactJWEHeaderParameters\n}\n\nexport interface FlattenedVerifyResult {\n  /** JWS Payload. */\n  payload: Uint8Array\n\n  /** JWS Protected Header. */\n  protectedHeader?: JWSHeaderParameters\n\n  /** JWS Unprotected Header. */\n  unprotectedHeader?: JWSHeaderParameters\n}\n\nexport interface GeneralVerifyResult extends FlattenedVerifyResult {}\n\nexport interface CompactVerifyResult {\n  /** JWS Payload. */\n  payload: Uint8Array\n\n  /** JWS Protected Header. */\n  protectedHeader: CompactJWSHeaderParameters\n}\n\nexport interface JWTVerifyResult {\n  /** JWT Claims Set. */\n  payload: JWTPayload\n\n  /** JWS Protected Header. */\n  protectedHeader: JWTHeaderParameters\n}\n\nexport interface JWTDecryptResult {\n  /** JWT Claims Set. */\n  payload: JWTPayload\n\n  /** JWE Protected Header. */\n  protectedHeader: CompactJWEHeaderParameters\n}\n\nexport interface ResolvedKey {\n  /** Key resolved from the key resolver function. */\n  key: KeyLike | Uint8Array\n}\n\n/** Recognized Compact JWS Header Parameters, any other Header Members may also be present. */\nexport interface CompactJWSHeaderParameters extends JWSHeaderParameters {\n  alg: string\n}\n\n/** Recognized Signed JWT Header Parameters, any other Header Members may also be present. */\nexport interface JWTHeaderParameters extends CompactJWSHeaderParameters {\n  b64?: true\n}\n\n/** Recognized Compact JWE Header Parameters, any other Header Members may also be present. */\nexport interface CompactJWEHeaderParameters extends JWEHeaderParameters {\n  alg: string\n  enc: string\n}\n\n/** JSON Web Key Set */\nexport interface JSONWebKeySet {\n  keys: JWK[]\n}\n", "import test from 'ava'\nimport * as crypto from 'crypto'\nimport { root, conditional } from '../dist.mjs'\n\nconst { FlattenedEncrypt, flattenedDecrypt, base64url } = await import(root)\n\ntest.before(async (t) => {\n  const encode = TextEncoder.prototype.encode.bind(new TextEncoder())\n  t.context.plaintext = encode('It\u2019s a dangerous business, Frodo, going out your door.')\n  t.context.additionalAuthenticatedData = encode('The Fellowship of the Ring')\n  t.context.initializationVector = new Uint8Array(12)\n  t.context.secret = new Uint8Array(16)\n})\n\ntest('JWE format validation', async (t) => {\n  const fullJwe = await new FlattenedEncrypt(t.context.plaintext)\n    .setProtectedHeader({ bar: 'baz' })\n    .setUnprotectedHeader({ foo: 'bar' })\n    .setSharedUnprotectedHeader({ alg: 'dir', enc: 'A128GCM' })\n    .setAdditionalAuthenticatedData(t.context.additionalAuthenticatedData)\n    .encrypt(t.context.secret)\n\n  {\n    await t.throwsAsync(flattenedDecrypt(null, t.context.secret), {\n      message: 'Flattened JWE must be an object',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    delete jwe.protected\n    delete jwe.header\n    delete jwe.unprotected\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'JOSE Header missing',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    delete jwe.iv\n    const assertion = {\n      message: 'JWE Initialization Vector missing or incorrect type',\n      code: 'ERR_JWE_INVALID',\n    }\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), assertion)\n    jwe.iv = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), assertion)\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    delete jwe.ciphertext\n    const assertion = {\n      message: 'JWE Ciphertext missing or incorrect type',\n      code: 'ERR_JWE_INVALID',\n    }\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), assertion)\n    jwe.ciphertext = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), assertion)\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    delete jwe.tag\n    const assertion = {\n      message: 'JWE Authentication Tag missing or incorrect type',\n      code: 'ERR_JWE_INVALID',\n    }\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), assertion)\n    jwe.tag = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), assertion)\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.protected = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'JWE Protected Header incorrect type',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    const assertion = {\n      message: 'JWE Protected Header is invalid',\n      code: 'ERR_JWE_INVALID',\n    }\n    jwe.protected = `1${jwe.protected}`\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), assertion)\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.encrypted_key = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'JWE Encrypted Key incorrect type',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.aad = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'JWE AAD incorrect type',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.header = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'JWE Shared Unprotected Header incorrect type',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.unprotected = null\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'JWE Per-Recipient Unprotected Header incorrect type',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.unprotected = { foo: 'bar' }\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message:\n        'JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.unprotected = { enc: 'A128GCM' }\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'missing JWE Algorithm (alg) in JWE Header',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.unprotected = { alg: 'dir' }\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'missing JWE Encryption Algorithm (enc) in JWE Header',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n\n  {\n    const jwe = { ...fullJwe }\n    jwe.encrypted_key = 'foo'\n\n    await t.throwsAsync(flattenedDecrypt(jwe, t.context.secret), {\n      message: 'Encountered unexpected JWE Encrypted Key',\n      code: 'ERR_JWE_INVALID',\n    })\n  }\n})\n\ntest('AES CBC + HMAC', async (t) => {\n  const secret = crypto.randomFillSync(new Uint8Array(32))\n  const jwe = await new FlattenedEncrypt(t.context.plaintext)\n    .setProtectedHeader({ alg: 'dir', enc: 'A128CBC-HS256' })\n    .encrypt(secret)\n\n  {\n    const jweBadTag = { ...jwe }\n    jweBadTag.tag = 'foo'\n    await t.throwsAsync(flattenedDecrypt(jweBadTag, secret), {\n      code: 'ERR_JWE_DECRYPTION_FAILED',\n      message: 'decryption operation failed',\n    })\n  }\n\n  {\n    const jweBadEnc = { ...jwe }\n    jweBadEnc.ciphertext = 'foo'\n    await t.throwsAsync(flattenedDecrypt(jweBadEnc, secret), {\n      code: 'ERR_JWE_DECRYPTION_FAILED',\n      message: 'decryption operation failed',\n    })\n  }\n\n  {\n    const altSecret = new Uint8Array(32)\n    altSecret.set(secret.slice(0, 16), 16)\n    altSecret.set(secret.slice(16), 0)\n    await t.throwsAsync(flattenedDecrypt(jwe, altSecret), {\n      code: 'ERR_JWE_DECRYPTION_FAILED',\n      message: 'decryption operation failed',\n    })\n  }\n})\n\ntest('decrypt empty data (GCM)', async (t) => {\n  const jwe = await new FlattenedEncrypt(new Uint8Array(0))\n    .setProtectedHeader({ alg: 'dir', enc: 'A128GCM' })\n    .encrypt(new Uint8Array(16))\n\n  t.is(jwe.ciphertext, '')\n\n  const { plaintext } = await flattenedDecrypt(jwe, new Uint8Array(16))\n  t.is(plaintext.byteLength, 0)\n})\n\ntest('decrypt empty data (CBC)', async (t) => {\n  const jwe = await new FlattenedEncrypt(new Uint8Array(0))\n    .setProtectedHeader({ alg: 'dir', enc: 'A128CBC-HS256' })\n    .encrypt(new Uint8Array(32))\n\n  t.is(base64url.decode(jwe.ciphertext).byteLength, 16)\n\n  const { plaintext } = await flattenedDecrypt(jwe, new Uint8Array(32))\n  t.is(plaintext.byteLength, 0)\n})\n\nconditional({ electron: 0 })('decrypt PBES2 p2c limit', async (t) => {\n  const jwe = await new FlattenedEncrypt(new Uint8Array(0))\n    .setProtectedHeader({ alg: 'PBES2-HS256+A128KW', enc: 'A128CBC-HS256' })\n    .setKeyManagementParameters({ p2c: 2049 })\n    .encrypt(new Uint8Array(32))\n\n  await t.throwsAsync(flattenedDecrypt(jwe, new Uint8Array(32), { maxPBES2Count: 2048 }), {\n    message: 'JOSE Header \"p2c\" (PBES2 Count) out is of acceptable bounds',\n    code: 'ERR_JWE_INVALID',\n  })\n})\n"], "filenames": ["src/jwe/flattened/decrypt.ts", "src/lib/decrypt_key_management.ts", "src/types.d.ts", "test/jwe/flattened.decrypt.test.mjs"], "buggy_code_start_loc": [191, 7, 403, 3], "buggy_code_end_loc": [194, 98, 403, 241], "fixing_code_start_loc": [191, 7, 404, 3], "fixing_code_end_loc": [194, 105, 411, 254], "type": "CWE-400", "message": "JOSE is \"JSON Web Almost Everything\" - JWA, JWS, JWE, JWT, JWK, JWKS with no dependencies using runtime's native crypto in Node.js, Browser, Cloudflare Workers, Electron, and Deno. The PBKDF2-based JWE key management algorithms expect a JOSE Header Parameter named `p2c` PBES2 Count, which determines how many PBKDF2 iterations must be executed in order to derive a CEK wrapping key. The purpose of this parameter is to intentionally slow down the key derivation function in order to make password brute-force and dictionary attacks more expensive. This makes the PBES2 algorithms unsuitable for situations where the JWE is coming from an untrusted source: an adversary can intentionally pick an extremely high PBES2 Count value, that will initiate a CPU-bound computation that may take an unreasonable amount of time to finish. Under certain conditions, it is possible to have the user's environment consume unreasonable amount of CPU time. The impact is limited only to users utilizing the JWE decryption APIs with symmetric secrets to decrypt JWEs from untrusted parties who do not limit the accepted JWE Key Management Algorithms (`alg` Header Parameter) using the `keyManagementAlgorithms` (or `algorithms` in v1.x) decryption option or through other means. The `v1.28.2`, `v2.0.6`, `v3.20.4`, and `v4.9.2` releases limit the maximum PBKDF2 iteration count to `10000` by default. It is possible to adjust this limit with a newly introduced `maxPBES2Count` decryption option. If users are unable to upgrade their required library version, they have two options depending on whether they expect to receive JWEs using any of the three PBKDF2-based JWE key management algorithms. They can use the `keyManagementAlgorithms` decryption option to disable accepting PBKDF2 altogether, or they can inspect the JOSE Header prior to using the decryption API and limit the PBKDF2 iteration count (`p2c` Header Parameter).", "other": {"cve": {"id": "CVE-2022-36083", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-07T22:15:08.657", "lastModified": "2022-09-13T15:47:01.203", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "JOSE is \"JSON Web Almost Everything\" - JWA, JWS, JWE, JWT, JWK, JWKS with no dependencies using runtime's native crypto in Node.js, Browser, Cloudflare Workers, Electron, and Deno. The PBKDF2-based JWE key management algorithms expect a JOSE Header Parameter named `p2c` PBES2 Count, which determines how many PBKDF2 iterations must be executed in order to derive a CEK wrapping key. The purpose of this parameter is to intentionally slow down the key derivation function in order to make password brute-force and dictionary attacks more expensive. This makes the PBES2 algorithms unsuitable for situations where the JWE is coming from an untrusted source: an adversary can intentionally pick an extremely high PBES2 Count value, that will initiate a CPU-bound computation that may take an unreasonable amount of time to finish. Under certain conditions, it is possible to have the user's environment consume unreasonable amount of CPU time. The impact is limited only to users utilizing the JWE decryption APIs with symmetric secrets to decrypt JWEs from untrusted parties who do not limit the accepted JWE Key Management Algorithms (`alg` Header Parameter) using the `keyManagementAlgorithms` (or `algorithms` in v1.x) decryption option or through other means. The `v1.28.2`, `v2.0.6`, `v3.20.4`, and `v4.9.2` releases limit the maximum PBKDF2 iteration count to `10000` by default. It is possible to adjust this limit with a newly introduced `maxPBES2Count` decryption option. If users are unable to upgrade their required library version, they have two options depending on whether they expect to receive JWEs using any of the three PBKDF2-based JWE key management algorithms. They can use the `keyManagementAlgorithms` decryption option to disable accepting PBKDF2 altogether, or they can inspect the JOSE Header prior to using the decryption API and limit the PBKDF2 iteration count (`p2c` Header Parameter)."}, {"lang": "es", "value": "JOSE es \"JSON Web Almost Everything\" - JWA, JWS, JWE, JWT, JWK, JWKS sin dependencias usando la criptograf\u00eda nativa del tiempo de ejecuci\u00f3n en Node.js, Browser, Cloudflare Workers, Electron y Deno. Los algoritmos de administraci\u00f3n de claves JWE basados en PBKDF2 esperan un par\u00e1metro de encabezado JOSE llamado \"p2c\" PBES2 Count, que determina cu\u00e1ntas iteraciones de PBKDF2 deben ejecutarse para derivar una clave envolvente CEK. El prop\u00f3sito de este par\u00e1metro es ralentizar intencionadamente la funci\u00f3n de derivaci\u00f3n de la clave para que los ataques de fuerza bruta y de diccionario a las contrase\u00f1as sean m\u00e1s costosos. Esto hace que los algoritmos PBES2 sean inapropiados para situaciones en las que el JWE procede de una fuente no confiable: un adversario puede elegir intencionadamente un valor de PBES2 Count extremadamente alto, que iniciar\u00e1 un c\u00e1lculo limitado por la CPU que puede tardar una cantidad de tiempo irrazonable en terminar. Bajo determinadas condiciones, es posible que el entorno del usuario consuma una cantidad irrazonable de tiempo de CPU. El impacto es limitado s\u00f3lo a usuarios que usan las API de descifrado de JWE con secretos sim\u00e9tricos para descifrar JWE de partes no confiables que no limitan los algoritmos de administraci\u00f3n de claves JWE aceptados (par\u00e1metro de cabecera \"alg\") usando la opci\u00f3n de descifrado \"keyManagementAlgorithms\" (o \"algorithms\" en v1.x) o por otros medios. Las versiones \"v1.28.2\", \"v2.0.6\", \"v3.20.4\" y \"v4.9.2\" limitan el n\u00famero m\u00e1ximo de iteraciones de PBKDF2 a \"10000\" por defecto. Es posible ajustar este l\u00edmite con la nueva opci\u00f3n de descifrado \"maxPBES2Count\". Si los usuarios no pueden actualizar la versi\u00f3n de la biblioteca que necesitan, se presentan dos opciones dependiendo de si esperan recibir JWEs que usen alguno de los tres algoritmos de administraci\u00f3n de claves JWE basados en PBKDF2. Pueden usar la opci\u00f3n de descifrado \"keyManagementAlgorithms\" para deshabilitar la aceptaci\u00f3n de PBKDF2 por completo, o pueden inspeccionar el encabezado JOSE antes de usar la API de descifrado y limitar el recuento de iteraciones de PBKDF2 (par\u00e1metro de encabezado \"p2c\")"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jose_project:jose:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "1.0.0", "versionEndExcluding": "1.28.2", "matchCriteriaId": "197D5C8A-778B-4EB5-9BD3-6E1E66CEBA64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jose_project:jose:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.6", "matchCriteriaId": "8C66BF3F-66C3-4D1E-A1FC-8404E9E666C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jose_project:jose:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.20.4", "matchCriteriaId": "99118C06-35D4-47A4-9AEC-5553D6EBCB65"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jose_project:jose:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.9.2", "matchCriteriaId": "C4DB52C4-C832-40DE-98F8-EED53AA21EFE"}]}]}], "references": [{"url": "https://github.com/panva/jose/commit/03d6d013bf6e070e85adfe5731f526978e3e8e4d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/panva/jose/releases/tag/v4.9.2", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/panva/jose/security/advisories/GHSA-jv3g-j58f-9mq9", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/panva/jose/commit/03d6d013bf6e070e85adfe5731f526978e3e8e4d"}}