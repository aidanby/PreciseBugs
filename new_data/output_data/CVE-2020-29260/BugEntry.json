{"buggy_code": ["/*\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n/*\n * vncviewer.c - the Xt-based VNC viewer.\n */\n\n#ifdef WIN32\n#include <winsock2.h>\n#endif\n\n#ifdef _MSC_VER\n#define strdup _strdup /* Prevent POSIX deprecation warnings */\n#endif\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#define _POSIX_SOURCE\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <rfb/rfbclient.h>\n#include \"tls.h\"\n\nstatic void Dummy(rfbClient* client) {\n}\nstatic rfbBool DummyPoint(rfbClient* client, int x, int y) {\n  return TRUE;\n}\nstatic void DummyRect(rfbClient* client, int x, int y, int w, int h) {\n}\n\n#ifndef WIN32\n#include <termios.h>\n#endif\n\nstatic char* ReadPassword(rfbClient* client) {\n\tint i;\n\tchar* p=calloc(1,9);\n\tif (!p) return p;\n#ifndef WIN32\n\tstruct termios save,noecho;\n\tif(tcgetattr(fileno(stdin),&save)!=0) return p;\n\tnoecho=save; noecho.c_lflag &= ~ECHO;\n\tif(tcsetattr(fileno(stdin),TCSAFLUSH,&noecho)!=0) return p;\n#endif\n\tfprintf(stderr,\"Password: \");\n\tfflush(stderr);\n\ti=0;\n\twhile(1) {\n\t\tint c=fgetc(stdin);\n\t\tif(c=='\\n')\n\t\t\tbreak;\n\t\tif(i<8) {\n\t\t\tp[i]=c;\n\t\t\ti++;\n\t\t\tp[i]=0;\n\t\t}\n\t}\n#ifndef WIN32\n\ttcsetattr(fileno(stdin),TCSAFLUSH,&save);\n#endif\n\treturn p;\n}\nstatic rfbBool MallocFrameBuffer(rfbClient* client) {\n  uint64_t allocSize;\n\n  if(client->frameBuffer)\n    free(client->frameBuffer);\n\n  /* SECURITY: promote 'width' into uint64_t so that the multiplication does not overflow\n     'width' and 'height' are 16-bit integers per RFB protocol design\n     SIZE_MAX is the maximum value that can fit into size_t\n  */\n  allocSize = (uint64_t)client->width * client->height * client->format.bitsPerPixel/8;\n\n  if (allocSize >= SIZE_MAX) {\n    rfbClientErr(\"CRITICAL: cannot allocate frameBuffer, requested size is too large\\n\");\n    return FALSE;\n  }\n\n  client->frameBuffer=malloc( (size_t)allocSize );\n\n  if (client->frameBuffer == NULL)\n    rfbClientErr(\"CRITICAL: frameBuffer allocation failed, requested size too large or not enough memory?\\n\");\n\n  return client->frameBuffer?TRUE:FALSE;\n}\n\n/* messages */\n\nstatic rfbBool CheckRect(rfbClient* client, int x, int y, int w, int h) {\n  return x + w <= client->width && y + h <= client->height;\n}\n\nstatic void FillRectangle(rfbClient* client, int x, int y, int w, int h, uint32_t colour) {\n  int i,j;\n\n  if (client->frameBuffer == NULL) {\n      return;\n  }\n\n  if (!CheckRect(client, x, y, w, h)) {\n    rfbClientLog(\"Rect out of bounds: %dx%d at (%d, %d)\\n\", x, y, w, h);\n    return;\n  }\n\n#define FILL_RECT(BPP) \\\n    for(j=y*client->width;j<(y+h)*client->width;j+=client->width) \\\n      for(i=x;i<x+w;i++) \\\n\t((uint##BPP##_t*)client->frameBuffer)[j+i]=colour;\n\n  switch(client->format.bitsPerPixel) {\n  case  8: FILL_RECT(8);  break;\n  case 16: FILL_RECT(16); break;\n  case 32: FILL_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}\n\nstatic void CopyRectangle(rfbClient* client, const uint8_t* buffer, int x, int y, int w, int h) {\n  int j;\n\n  if (client->frameBuffer == NULL) {\n      return;\n  }\n\n  if (!CheckRect(client, x, y, w, h)) {\n    rfbClientLog(\"Rect out of bounds: %dx%d at (%d, %d)\\n\", x, y, w, h);\n    return;\n  }\n\n#define COPY_RECT(BPP) \\\n  { \\\n    int rs = w * BPP / 8, rs2 = client->width * BPP / 8; \\\n    for (j = ((x * (BPP / 8)) + (y * rs2)); j < (y + h) * rs2; j += rs2) { \\\n      memcpy(client->frameBuffer + j, buffer, rs); \\\n      buffer += rs; \\\n    } \\\n  }\n\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT(8);  break;\n  case 16: COPY_RECT(16); break;\n  case 32: COPY_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}\n\n/* TODO: test */\nstatic void CopyRectangleFromRectangle(rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {\n  int i,j;\n\n  if (client->frameBuffer == NULL) {\n      return;\n  }\n\n  if (!CheckRect(client, src_x, src_y, w, h)) {\n    rfbClientLog(\"Source rect out of bounds: %dx%d at (%d, %d)\\n\", src_x, src_y, w, h);\n    return;\n  }\n\n  if (!CheckRect(client, dest_x, dest_y, w, h)) {\n    rfbClientLog(\"Dest rect out of bounds: %dx%d at (%d, %d)\\n\", dest_x, dest_y, w, h);\n    return;\n  }\n\n#define COPY_RECT_FROM_RECT(BPP) \\\n  { \\\n    uint##BPP##_t* _buffer=((uint##BPP##_t*)client->frameBuffer)+(src_y-dest_y)*client->width+src_x-dest_x; \\\n    if (dest_y < src_y) { \\\n      for(j = dest_y*client->width; j < (dest_y+h)*client->width; j += client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } else { \\\n      for(j = (dest_y+h-1)*client->width; j >= dest_y*client->width; j-=client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } \\\n  }\n\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT_FROM_RECT(8);  break;\n  case 16: COPY_RECT_FROM_RECT(16); break;\n  case 32: COPY_RECT_FROM_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}\n\nstatic void initAppData(AppData* data) {\n\tdata->shareDesktop=TRUE;\n\tdata->viewOnly=FALSE;\n\tdata->encodingsString=\"tight zrle ultra copyrect hextile zlib corre rre raw\";\n\tdata->useBGR233=FALSE;\n\tdata->nColours=0;\n\tdata->forceOwnCmap=FALSE;\n\tdata->forceTrueColour=FALSE;\n\tdata->requestedDepth=0;\n\tdata->compressLevel=3;\n\tdata->qualityLevel=5;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\tdata->enableJPEG=TRUE;\n#else\n\tdata->enableJPEG=FALSE;\n#endif\n\tdata->useRemoteCursor=FALSE;\n}\n\nrfbClient* rfbGetClient(int bitsPerSample,int samplesPerPixel,\n\t\t\tint bytesPerPixel) {\n#ifdef WIN32\n    WSADATA unused;\n#endif\n  rfbClient* client=(rfbClient*)calloc(sizeof(rfbClient),1);\n  if(!client) {\n    rfbClientErr(\"Couldn't allocate client structure!\\n\");\n    return NULL;\n  }\n#ifdef WIN32\n  if((errno = WSAStartup(MAKEWORD(2,0), &unused)) != 0) {\n      rfbClientErr(\"Could not init Windows Sockets: %s\\n\", strerror(errno));\n      return NULL;\n  }\n#endif\n  initAppData(&client->appData);\n  client->endianTest = 1;\n  client->programName=\"\";\n  client->serverHost=strdup(\"\");\n  client->serverPort=5900;\n\n  client->destHost = NULL;\n  client->destPort = 5900;\n  \n  client->connectTimeout = DEFAULT_CONNECT_TIMEOUT;\n  client->readTimeout = DEFAULT_READ_TIMEOUT;\n\n  /* default: use complete frame buffer */ \n  client->updateRect.x = -1;\n \n  client->frameBuffer = NULL;\n  client->outputWindow = 0;\n \n  client->format.bitsPerPixel = bytesPerPixel*8;\n  client->format.depth = bitsPerSample*samplesPerPixel;\n  client->appData.requestedDepth=client->format.depth;\n  client->format.bigEndian = *(char *)&client->endianTest?FALSE:TRUE;\n  client->format.trueColour = 1;\n\n  if (client->format.bitsPerPixel == 8) {\n    client->format.redMax = 7;\n    client->format.greenMax = 7;\n    client->format.blueMax = 3;\n    client->format.redShift = 0;\n    client->format.greenShift = 3;\n    client->format.blueShift = 6;\n  } else {\n    client->format.redMax = (1 << bitsPerSample) - 1;\n    client->format.greenMax = (1 << bitsPerSample) - 1;\n    client->format.blueMax = (1 << bitsPerSample) - 1;\n    if(!client->format.bigEndian) {\n      client->format.redShift = 0;\n      client->format.greenShift = bitsPerSample;\n      client->format.blueShift = bitsPerSample * 2;\n    } else {\n      if(client->format.bitsPerPixel==8*3) {\n\tclient->format.redShift = bitsPerSample*2;\n\tclient->format.greenShift = bitsPerSample*1;\n\tclient->format.blueShift = 0;\n      } else {\n\tclient->format.redShift = bitsPerSample*3;\n\tclient->format.greenShift = bitsPerSample*2;\n\tclient->format.blueShift = bitsPerSample;\n      }\n    }\n  }\n\n  client->bufoutptr=client->buf;\n  client->buffered=0;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  client->raw_buffer_size = -1;\n  client->decompStreamInited = FALSE;\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n  memset(client->zlibStreamActive,0,sizeof(rfbBool)*4);\n#endif\n#endif\n\n  client->HandleCursorPos = DummyPoint;\n  client->SoftCursorLockArea = DummyRect;\n  client->SoftCursorUnlockScreen = Dummy;\n  client->GotFrameBufferUpdate = DummyRect;\n  client->GotCopyRect = CopyRectangleFromRectangle;\n  client->GotFillRect = FillRectangle;\n  client->GotBitmap = CopyRectangle;\n  client->FinishedFrameBufferUpdate = NULL;\n  client->GetPassword = ReadPassword;\n  client->MallocFrameBuffer = MallocFrameBuffer;\n  client->Bell = Dummy;\n  client->CurrentKeyboardLedState = 0;\n  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;\n  client->QoS_DSCP = 0;\n\n  client->authScheme = 0;\n  client->subAuthScheme = 0;\n  client->GetCredential = NULL;\n  client->tlsSession = NULL;\n  client->LockWriteToTLS = NULL;\n  client->UnlockWriteToTLS = NULL;\n  client->sock = RFB_INVALID_SOCKET;\n  client->listenSock = RFB_INVALID_SOCKET;\n  client->listenAddress = NULL;\n  client->listen6Sock = RFB_INVALID_SOCKET;\n  client->listen6Address = NULL;\n  client->clientAuthSchemes = NULL;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n  client->GetSASLMechanism = NULL;\n  client->GetUser = NULL;\n  client->saslSecret = NULL;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  return client;\n}\n\nstatic rfbBool rfbInitConnection(rfbClient* client)\n{\n  /* Unless we accepted an incoming connection, make a TCP connection to the\n     given VNC server */\n\n  if (!client->listenSpecified) {\n    if (!client->serverHost)\n      return FALSE;\n    if (client->destHost) {\n      if (!ConnectToRFBRepeater(client,client->serverHost,client->serverPort,client->destHost,client->destPort))\n        return FALSE;\n    } else {\n      if (!ConnectToRFBServer(client,client->serverHost,client->serverPort))\n        return FALSE;\n    }\n  }\n\n  /* Initialise the VNC connection, including reading the password */\n\n  if (!InitialiseRFBConnection(client))\n    return FALSE;\n\n  client->width=client->si.framebufferWidth;\n  client->height=client->si.framebufferHeight;\n  if (!client->MallocFrameBuffer(client))\n    return FALSE;\n\n  if (!SetFormatAndEncodings(client))\n    return FALSE;\n\n  if (client->updateRect.x < 0) {\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n  }\n\n  if (client->appData.scaleSetting>1)\n  {\n      if (!SendScaleSetting(client, client->appData.scaleSetting))\n          return FALSE;\n      if (!SendFramebufferUpdateRequest(client,\n\t\t\t      client->updateRect.x / client->appData.scaleSetting,\n\t\t\t      client->updateRect.y / client->appData.scaleSetting,\n\t\t\t      client->updateRect.w / client->appData.scaleSetting,\n\t\t\t      client->updateRect.h / client->appData.scaleSetting,\n\t\t\t      FALSE))\n\t      return FALSE;\n  }\n  else\n  {\n      if (!SendFramebufferUpdateRequest(client,\n\t\t\t      client->updateRect.x, client->updateRect.y,\n\t\t\t      client->updateRect.w, client->updateRect.h,\n\t\t\t      FALSE))\n      return FALSE;\n  }\n\n  return TRUE;\n}\n\nrfbBool rfbInitClient(rfbClient* client,int* argc,char** argv) {\n  int i,j;\n\n  if(argv && argc && *argc) {\n    if(client->programName==0)\n      client->programName=argv[0];\n\n    for (i = 1; i < *argc; i++) {\n      j = i;\n      if (strcmp(argv[i], \"-listen\") == 0) {\n\tlistenForIncomingConnections(client);\n\tbreak;\n      } else if (strcmp(argv[i], \"-listennofork\") == 0) {\n\tlistenForIncomingConnectionsNoFork(client, -1);\n\tbreak;\n      } else if (strcmp(argv[i], \"-play\") == 0) {\n\tclient->serverPort = -1;\n\tj++;\n      } else if (i+1<*argc && strcmp(argv[i], \"-encodings\") == 0) {\n\tclient->appData.encodingsString = argv[i+1];\n\tj+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-compress\") == 0) {\n\tclient->appData.compressLevel = atoi(argv[i+1]);\n\tj+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-quality\") == 0) {\n\tclient->appData.qualityLevel = atoi(argv[i+1]);\n\tj+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-scale\") == 0) {\n        client->appData.scaleSetting = atoi(argv[i+1]);\n        j+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-qosdscp\") == 0) {\n        client->QoS_DSCP = atoi(argv[i+1]);\n        j+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-repeaterdest\") == 0) {\n\tchar* colon=strchr(argv[i+1],':');\n\n\tif(client->destHost)\n\t  free(client->destHost);\n        client->destPort = 5900;\n\n\tclient->destHost = strdup(argv[i+1]);\n\tif(client->destHost && colon) {\n\t  client->destHost[(int)(colon-argv[i+1])] = '\\0';\n\t  client->destPort = atoi(colon+1);\n\t}\n        j+=2;\n      } else {\n\tchar* colon=strrchr(argv[i],':');\n\n\tif(client->serverHost)\n\t  free(client->serverHost);\n\n\tif(colon) {\n\t  client->serverHost = strdup(argv[i]);\n\t  if(client->serverHost) {\n\t    client->serverHost[(int)(colon-argv[i])] = '\\0';\n\t    client->serverPort = atoi(colon+1);\n\t  }\n\t} else {\n\t  client->serverHost = strdup(argv[i]);\n\t}\n\tif(client->serverPort >= 0 && client->serverPort < 5900)\n\t  client->serverPort += 5900;\n      }\n      /* purge arguments */\n      if (j>i) {\n\t*argc-=j-i;\n\tmemmove(argv+i,argv+j,(*argc-i)*sizeof(char*));\n\ti--;\n      }\n    }\n  }\n\n  if(!rfbInitConnection(client)) {\n    rfbClientCleanup(client);\n    return FALSE;\n  }\n\n  return TRUE;\n}\n\nvoid rfbClientCleanup(rfbClient* client) {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  int i;\n\n  for ( i = 0; i < 4; i++ ) {\n    if (client->zlibStreamActive[i] == TRUE ) {\n      if (inflateEnd (&client->zlibStream[i]) != Z_OK &&\n\t  client->zlibStream[i].msg != NULL)\n\trfbClientLog(\"inflateEnd: %s\\n\", client->zlibStream[i].msg);\n    }\n  }\n\n  if ( client->decompStreamInited == TRUE ) {\n    if (inflateEnd (&client->decompStream) != Z_OK &&\n\tclient->decompStream.msg != NULL)\n      rfbClientLog(\"inflateEnd: %s\\n\", client->decompStream.msg );\n  }\n#endif\n\n  if (client->ultra_buffer)\n    free(client->ultra_buffer);\n\n  if (client->raw_buffer)\n    free(client->raw_buffer);\n\n  FreeTLS(client);\n\n  while (client->clientData) {\n    rfbClientData* next = client->clientData->next;\n    free(client->clientData);\n    client->clientData = next;\n  }\n\n  if (client->sock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->sock);\n  if (client->listenSock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->listenSock);\n  free(client->desktopName);\n  free(client->serverHost);\n  if (client->destHost)\n    free(client->destHost);\n  if (client->clientAuthSchemes)\n    free(client->clientAuthSchemes);\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n  if (client->saslSecret)\n    free(client->saslSecret);\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n#ifdef WIN32\n  if(WSACleanup() != 0) {\n      errno=WSAGetLastError();\n      rfbClientErr(\"Could not terminate Windows Sockets: %s\\n\", strerror(errno));\n  }\n#endif\n\n  free(client);\n}\n"], "fixing_code": ["/*\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n/*\n * vncviewer.c - the Xt-based VNC viewer.\n */\n\n#ifdef WIN32\n#include <winsock2.h>\n#endif\n\n#ifdef _MSC_VER\n#define strdup _strdup /* Prevent POSIX deprecation warnings */\n#endif\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#define _POSIX_SOURCE\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <rfb/rfbclient.h>\n#include \"tls.h\"\n\nstatic void Dummy(rfbClient* client) {\n}\nstatic rfbBool DummyPoint(rfbClient* client, int x, int y) {\n  return TRUE;\n}\nstatic void DummyRect(rfbClient* client, int x, int y, int w, int h) {\n}\n\n#ifndef WIN32\n#include <termios.h>\n#endif\n\nstatic char* ReadPassword(rfbClient* client) {\n\tint i;\n\tchar* p=calloc(1,9);\n\tif (!p) return p;\n#ifndef WIN32\n\tstruct termios save,noecho;\n\tif(tcgetattr(fileno(stdin),&save)!=0) return p;\n\tnoecho=save; noecho.c_lflag &= ~ECHO;\n\tif(tcsetattr(fileno(stdin),TCSAFLUSH,&noecho)!=0) return p;\n#endif\n\tfprintf(stderr,\"Password: \");\n\tfflush(stderr);\n\ti=0;\n\twhile(1) {\n\t\tint c=fgetc(stdin);\n\t\tif(c=='\\n')\n\t\t\tbreak;\n\t\tif(i<8) {\n\t\t\tp[i]=c;\n\t\t\ti++;\n\t\t\tp[i]=0;\n\t\t}\n\t}\n#ifndef WIN32\n\ttcsetattr(fileno(stdin),TCSAFLUSH,&save);\n#endif\n\treturn p;\n}\nstatic rfbBool MallocFrameBuffer(rfbClient* client) {\n  uint64_t allocSize;\n\n  if(client->frameBuffer)\n    free(client->frameBuffer);\n\n  /* SECURITY: promote 'width' into uint64_t so that the multiplication does not overflow\n     'width' and 'height' are 16-bit integers per RFB protocol design\n     SIZE_MAX is the maximum value that can fit into size_t\n  */\n  allocSize = (uint64_t)client->width * client->height * client->format.bitsPerPixel/8;\n\n  if (allocSize >= SIZE_MAX) {\n    rfbClientErr(\"CRITICAL: cannot allocate frameBuffer, requested size is too large\\n\");\n    return FALSE;\n  }\n\n  client->frameBuffer=malloc( (size_t)allocSize );\n\n  if (client->frameBuffer == NULL)\n    rfbClientErr(\"CRITICAL: frameBuffer allocation failed, requested size too large or not enough memory?\\n\");\n\n  return client->frameBuffer?TRUE:FALSE;\n}\n\n/* messages */\n\nstatic rfbBool CheckRect(rfbClient* client, int x, int y, int w, int h) {\n  return x + w <= client->width && y + h <= client->height;\n}\n\nstatic void FillRectangle(rfbClient* client, int x, int y, int w, int h, uint32_t colour) {\n  int i,j;\n\n  if (client->frameBuffer == NULL) {\n      return;\n  }\n\n  if (!CheckRect(client, x, y, w, h)) {\n    rfbClientLog(\"Rect out of bounds: %dx%d at (%d, %d)\\n\", x, y, w, h);\n    return;\n  }\n\n#define FILL_RECT(BPP) \\\n    for(j=y*client->width;j<(y+h)*client->width;j+=client->width) \\\n      for(i=x;i<x+w;i++) \\\n\t((uint##BPP##_t*)client->frameBuffer)[j+i]=colour;\n\n  switch(client->format.bitsPerPixel) {\n  case  8: FILL_RECT(8);  break;\n  case 16: FILL_RECT(16); break;\n  case 32: FILL_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}\n\nstatic void CopyRectangle(rfbClient* client, const uint8_t* buffer, int x, int y, int w, int h) {\n  int j;\n\n  if (client->frameBuffer == NULL) {\n      return;\n  }\n\n  if (!CheckRect(client, x, y, w, h)) {\n    rfbClientLog(\"Rect out of bounds: %dx%d at (%d, %d)\\n\", x, y, w, h);\n    return;\n  }\n\n#define COPY_RECT(BPP) \\\n  { \\\n    int rs = w * BPP / 8, rs2 = client->width * BPP / 8; \\\n    for (j = ((x * (BPP / 8)) + (y * rs2)); j < (y + h) * rs2; j += rs2) { \\\n      memcpy(client->frameBuffer + j, buffer, rs); \\\n      buffer += rs; \\\n    } \\\n  }\n\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT(8);  break;\n  case 16: COPY_RECT(16); break;\n  case 32: COPY_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}\n\n/* TODO: test */\nstatic void CopyRectangleFromRectangle(rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {\n  int i,j;\n\n  if (client->frameBuffer == NULL) {\n      return;\n  }\n\n  if (!CheckRect(client, src_x, src_y, w, h)) {\n    rfbClientLog(\"Source rect out of bounds: %dx%d at (%d, %d)\\n\", src_x, src_y, w, h);\n    return;\n  }\n\n  if (!CheckRect(client, dest_x, dest_y, w, h)) {\n    rfbClientLog(\"Dest rect out of bounds: %dx%d at (%d, %d)\\n\", dest_x, dest_y, w, h);\n    return;\n  }\n\n#define COPY_RECT_FROM_RECT(BPP) \\\n  { \\\n    uint##BPP##_t* _buffer=((uint##BPP##_t*)client->frameBuffer)+(src_y-dest_y)*client->width+src_x-dest_x; \\\n    if (dest_y < src_y) { \\\n      for(j = dest_y*client->width; j < (dest_y+h)*client->width; j += client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } else { \\\n      for(j = (dest_y+h-1)*client->width; j >= dest_y*client->width; j-=client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } \\\n  }\n\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT_FROM_RECT(8);  break;\n  case 16: COPY_RECT_FROM_RECT(16); break;\n  case 32: COPY_RECT_FROM_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}\n\nstatic void initAppData(AppData* data) {\n\tdata->shareDesktop=TRUE;\n\tdata->viewOnly=FALSE;\n\tdata->encodingsString=\"tight zrle ultra copyrect hextile zlib corre rre raw\";\n\tdata->useBGR233=FALSE;\n\tdata->nColours=0;\n\tdata->forceOwnCmap=FALSE;\n\tdata->forceTrueColour=FALSE;\n\tdata->requestedDepth=0;\n\tdata->compressLevel=3;\n\tdata->qualityLevel=5;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\tdata->enableJPEG=TRUE;\n#else\n\tdata->enableJPEG=FALSE;\n#endif\n\tdata->useRemoteCursor=FALSE;\n}\n\nrfbClient* rfbGetClient(int bitsPerSample,int samplesPerPixel,\n\t\t\tint bytesPerPixel) {\n#ifdef WIN32\n    WSADATA unused;\n#endif\n  rfbClient* client=(rfbClient*)calloc(sizeof(rfbClient),1);\n  if(!client) {\n    rfbClientErr(\"Couldn't allocate client structure!\\n\");\n    return NULL;\n  }\n#ifdef WIN32\n  if((errno = WSAStartup(MAKEWORD(2,0), &unused)) != 0) {\n      rfbClientErr(\"Could not init Windows Sockets: %s\\n\", strerror(errno));\n      return NULL;\n  }\n#endif\n  initAppData(&client->appData);\n  client->endianTest = 1;\n  client->programName=\"\";\n  client->serverHost=strdup(\"\");\n  client->serverPort=5900;\n\n  client->destHost = NULL;\n  client->destPort = 5900;\n  \n  client->connectTimeout = DEFAULT_CONNECT_TIMEOUT;\n  client->readTimeout = DEFAULT_READ_TIMEOUT;\n\n  /* default: use complete frame buffer */ \n  client->updateRect.x = -1;\n \n  client->frameBuffer = NULL;\n  client->outputWindow = 0;\n \n  client->format.bitsPerPixel = bytesPerPixel*8;\n  client->format.depth = bitsPerSample*samplesPerPixel;\n  client->appData.requestedDepth=client->format.depth;\n  client->format.bigEndian = *(char *)&client->endianTest?FALSE:TRUE;\n  client->format.trueColour = 1;\n\n  if (client->format.bitsPerPixel == 8) {\n    client->format.redMax = 7;\n    client->format.greenMax = 7;\n    client->format.blueMax = 3;\n    client->format.redShift = 0;\n    client->format.greenShift = 3;\n    client->format.blueShift = 6;\n  } else {\n    client->format.redMax = (1 << bitsPerSample) - 1;\n    client->format.greenMax = (1 << bitsPerSample) - 1;\n    client->format.blueMax = (1 << bitsPerSample) - 1;\n    if(!client->format.bigEndian) {\n      client->format.redShift = 0;\n      client->format.greenShift = bitsPerSample;\n      client->format.blueShift = bitsPerSample * 2;\n    } else {\n      if(client->format.bitsPerPixel==8*3) {\n\tclient->format.redShift = bitsPerSample*2;\n\tclient->format.greenShift = bitsPerSample*1;\n\tclient->format.blueShift = 0;\n      } else {\n\tclient->format.redShift = bitsPerSample*3;\n\tclient->format.greenShift = bitsPerSample*2;\n\tclient->format.blueShift = bitsPerSample;\n      }\n    }\n  }\n\n  client->bufoutptr=client->buf;\n  client->buffered=0;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  client->raw_buffer_size = -1;\n  client->decompStreamInited = FALSE;\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n  memset(client->zlibStreamActive,0,sizeof(rfbBool)*4);\n#endif\n#endif\n\n  client->HandleCursorPos = DummyPoint;\n  client->SoftCursorLockArea = DummyRect;\n  client->SoftCursorUnlockScreen = Dummy;\n  client->GotFrameBufferUpdate = DummyRect;\n  client->GotCopyRect = CopyRectangleFromRectangle;\n  client->GotFillRect = FillRectangle;\n  client->GotBitmap = CopyRectangle;\n  client->FinishedFrameBufferUpdate = NULL;\n  client->GetPassword = ReadPassword;\n  client->MallocFrameBuffer = MallocFrameBuffer;\n  client->Bell = Dummy;\n  client->CurrentKeyboardLedState = 0;\n  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;\n  client->QoS_DSCP = 0;\n\n  client->authScheme = 0;\n  client->subAuthScheme = 0;\n  client->GetCredential = NULL;\n  client->tlsSession = NULL;\n  client->LockWriteToTLS = NULL;\n  client->UnlockWriteToTLS = NULL;\n  client->sock = RFB_INVALID_SOCKET;\n  client->listenSock = RFB_INVALID_SOCKET;\n  client->listenAddress = NULL;\n  client->listen6Sock = RFB_INVALID_SOCKET;\n  client->listen6Address = NULL;\n  client->clientAuthSchemes = NULL;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n  client->GetSASLMechanism = NULL;\n  client->GetUser = NULL;\n  client->saslSecret = NULL;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  return client;\n}\n\nstatic rfbBool rfbInitConnection(rfbClient* client)\n{\n  /* Unless we accepted an incoming connection, make a TCP connection to the\n     given VNC server */\n\n  if (!client->listenSpecified) {\n    if (!client->serverHost)\n      return FALSE;\n    if (client->destHost) {\n      if (!ConnectToRFBRepeater(client,client->serverHost,client->serverPort,client->destHost,client->destPort))\n        return FALSE;\n    } else {\n      if (!ConnectToRFBServer(client,client->serverHost,client->serverPort))\n        return FALSE;\n    }\n  }\n\n  /* Initialise the VNC connection, including reading the password */\n\n  if (!InitialiseRFBConnection(client))\n    return FALSE;\n\n  client->width=client->si.framebufferWidth;\n  client->height=client->si.framebufferHeight;\n  if (!client->MallocFrameBuffer(client))\n    return FALSE;\n\n  if (!SetFormatAndEncodings(client))\n    return FALSE;\n\n  if (client->updateRect.x < 0) {\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n  }\n\n  if (client->appData.scaleSetting>1)\n  {\n      if (!SendScaleSetting(client, client->appData.scaleSetting))\n          return FALSE;\n      if (!SendFramebufferUpdateRequest(client,\n\t\t\t      client->updateRect.x / client->appData.scaleSetting,\n\t\t\t      client->updateRect.y / client->appData.scaleSetting,\n\t\t\t      client->updateRect.w / client->appData.scaleSetting,\n\t\t\t      client->updateRect.h / client->appData.scaleSetting,\n\t\t\t      FALSE))\n\t      return FALSE;\n  }\n  else\n  {\n      if (!SendFramebufferUpdateRequest(client,\n\t\t\t      client->updateRect.x, client->updateRect.y,\n\t\t\t      client->updateRect.w, client->updateRect.h,\n\t\t\t      FALSE))\n      return FALSE;\n  }\n\n  return TRUE;\n}\n\nrfbBool rfbInitClient(rfbClient* client,int* argc,char** argv) {\n  int i,j;\n\n  if(argv && argc && *argc) {\n    if(client->programName==0)\n      client->programName=argv[0];\n\n    for (i = 1; i < *argc; i++) {\n      j = i;\n      if (strcmp(argv[i], \"-listen\") == 0) {\n\tlistenForIncomingConnections(client);\n\tbreak;\n      } else if (strcmp(argv[i], \"-listennofork\") == 0) {\n\tlistenForIncomingConnectionsNoFork(client, -1);\n\tbreak;\n      } else if (strcmp(argv[i], \"-play\") == 0) {\n\tclient->serverPort = -1;\n\tj++;\n      } else if (i+1<*argc && strcmp(argv[i], \"-encodings\") == 0) {\n\tclient->appData.encodingsString = argv[i+1];\n\tj+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-compress\") == 0) {\n\tclient->appData.compressLevel = atoi(argv[i+1]);\n\tj+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-quality\") == 0) {\n\tclient->appData.qualityLevel = atoi(argv[i+1]);\n\tj+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-scale\") == 0) {\n        client->appData.scaleSetting = atoi(argv[i+1]);\n        j+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-qosdscp\") == 0) {\n        client->QoS_DSCP = atoi(argv[i+1]);\n        j+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-repeaterdest\") == 0) {\n\tchar* colon=strchr(argv[i+1],':');\n\n\tif(client->destHost)\n\t  free(client->destHost);\n        client->destPort = 5900;\n\n\tclient->destHost = strdup(argv[i+1]);\n\tif(client->destHost && colon) {\n\t  client->destHost[(int)(colon-argv[i+1])] = '\\0';\n\t  client->destPort = atoi(colon+1);\n\t}\n        j+=2;\n      } else {\n\tchar* colon=strrchr(argv[i],':');\n\n\tif(client->serverHost)\n\t  free(client->serverHost);\n\n\tif(colon) {\n\t  client->serverHost = strdup(argv[i]);\n\t  if(client->serverHost) {\n\t    client->serverHost[(int)(colon-argv[i])] = '\\0';\n\t    client->serverPort = atoi(colon+1);\n\t  }\n\t} else {\n\t  client->serverHost = strdup(argv[i]);\n\t}\n\tif(client->serverPort >= 0 && client->serverPort < 5900)\n\t  client->serverPort += 5900;\n      }\n      /* purge arguments */\n      if (j>i) {\n\t*argc-=j-i;\n\tmemmove(argv+i,argv+j,(*argc-i)*sizeof(char*));\n\ti--;\n      }\n    }\n  }\n\n  if(!rfbInitConnection(client)) {\n    rfbClientCleanup(client);\n    return FALSE;\n  }\n\n  return TRUE;\n}\n\nvoid rfbClientCleanup(rfbClient* client) {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  int i;\n\n  for ( i = 0; i < 4; i++ ) {\n    if (client->zlibStreamActive[i] == TRUE ) {\n      if (inflateEnd (&client->zlibStream[i]) != Z_OK &&\n\t  client->zlibStream[i].msg != NULL)\n\trfbClientLog(\"inflateEnd: %s\\n\", client->zlibStream[i].msg);\n    }\n  }\n\n  if ( client->decompStreamInited == TRUE ) {\n    if (inflateEnd (&client->decompStream) != Z_OK &&\n\tclient->decompStream.msg != NULL)\n      rfbClientLog(\"inflateEnd: %s\\n\", client->decompStream.msg );\n  }\n#endif\n\n  if (client->ultra_buffer)\n    free(client->ultra_buffer);\n\n  if (client->raw_buffer)\n    free(client->raw_buffer);\n\n  FreeTLS(client);\n\n  while (client->clientData) {\n    rfbClientData* next = client->clientData->next;\n    free(client->clientData);\n    client->clientData = next;\n  }\n\n  free(client->vncRec);\n\n  if (client->sock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->sock);\n  if (client->listenSock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->listenSock);\n  free(client->desktopName);\n  free(client->serverHost);\n  if (client->destHost)\n    free(client->destHost);\n  if (client->clientAuthSchemes)\n    free(client->clientAuthSchemes);\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n  if (client->saslSecret)\n    free(client->saslSecret);\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n#ifdef WIN32\n  if(WSACleanup() != 0) {\n      errno=WSAGetLastError();\n      rfbClientErr(\"Could not terminate Windows Sockets: %s\\n\", strerror(errno));\n  }\n#endif\n\n  free(client);\n}\n"], "filenames": ["libvncclient/vncviewer.c"], "buggy_code_start_loc": [536], "buggy_code_end_loc": [536], "fixing_code_start_loc": [537], "fixing_code_end_loc": [539], "type": "CWE-400", "message": "libvncclient v0.9.13 was discovered to contain a memory leak via the function rfbClientCleanup().", "other": {"cve": {"id": "CVE-2020-29260", "sourceIdentifier": "cve@mitre.org", "published": "2022-09-02T23:15:08.227", "lastModified": "2022-10-05T20:56:35.537", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libvncclient v0.9.13 was discovered to contain a memory leak via the function rfbClientCleanup()."}, {"lang": "es", "value": "Se ha detectado que libvncclient versi\u00f3n v0.9.13, contiene una p\u00e9rdida de memoria por medio de la funci\u00f3n rfbClientCleanup()"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libvncserver_project:libvncserver:0.9.13:*:*:*:*:*:*:*", "matchCriteriaId": "0B2BF37F-76E3-48C0-AD06-55FC616C7EB7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/LibVNC/libvncserver/commit/bef41f6ec4097a8ee094f90a1b34a708fbd757ec", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/09/msg00035.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibVNC/libvncserver/commit/bef41f6ec4097a8ee094f90a1b34a708fbd757ec"}}