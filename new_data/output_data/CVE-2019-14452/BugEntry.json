{"buggy_code": ["/************************************************************************\n**\n**  Copyright (C) 2016 - 2019 Kevin B. Hendricks, Stratford, Ontario, Canada\n**  Copyright (C) 2012 John Schember <john@nachtimwald.com>\n**  Copyright (C) 2009, 2010, 2011  Strahinja Markovic  <strahinja.markovic@gmail.com>\n**\n**  This file is part of Sigil.\n**\n**  Sigil is free software: you can redistribute it and/or modify\n**  it under the terms of the GNU General Public License as published by\n**  the Free Software Foundation, either version 3 of the License, or\n**  (at your option) any later version.\n**\n**  Sigil is distributed in the hope that it will be useful,\n**  but WITHOUT ANY WARRANTY; without even the implied warranty of\n**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n**  GNU General Public License for more details.\n**\n**  You should have received a copy of the GNU General Public License\n**  along with Sigil.  If not, see <http://www.gnu.org/licenses/>.\n**\n*************************************************************************/\n\n#ifdef _WIN32\n#define NOMINMAX\n#endif\n\n#include \"unzip.h\"\n#ifdef _WIN32\n#include \"iowin32.h\"\n#endif\n\n#include <string>\n\n#include <QApplication>\n#include <QtCore/QtCore>\n#include <QtCore/QDir>\n#include <QtCore/QFile>\n#include <QtCore/QFileInfo>\n#include <QtCore/QFutureSynchronizer>\n#include <QtConcurrent/QtConcurrent>\n#include <QtCore/QXmlStreamReader>\n#include <QDirIterator>\n#include <QRegularExpression>\n#include <QRegularExpressionMatch>\n#include <QStringList>\n#include <QMessageBox>\n#include <QUrl>\n\n#include \"BookManipulation/FolderKeeper.h\"\n#include \"BookManipulation/CleanSource.h\"\n#include \"Importers/ImportEPUB.h\"\n#include \"Misc/FontObfuscation.h\"\n#include \"Misc/HTMLEncodingResolver.h\"\n#include \"Misc/QCodePage437Codec.h\"\n#include \"Misc/SettingsStore.h\"\n#include \"Misc/Utility.h\"\n#include \"ResourceObjects/CSSResource.h\"\n#include \"ResourceObjects/HTMLResource.h\"\n#include \"ResourceObjects/OPFResource.h\"\n#include \"ResourceObjects/NCXResource.h\"\n#include \"ResourceObjects/Resource.h\"\n#include \"ResourceObjects/OPFParser.h\"\n#include \"SourceUpdates/UniversalUpdates.h\"\n#include \"sigil_constants.h\"\n#include \"sigil_exception.h\"\n\n#ifndef MAX_PATH\n// Set Max length to 256 because that's the max path size on many systems.\n#define MAX_PATH 256\n#endif\n// This is the same read buffer size used by Java and Perl.\n#define BUFF_SIZE 8192\n\nconst QString DUBLIN_CORE_NS             = \"http://purl.org/dc/elements/1.1/\";\nstatic const QString OEBPS_MIMETYPE      = \"application/oebps-package+xml\";\nstatic const QString UPDATE_ERROR_STRING = \"SG_ERROR\";\nconst QString NCX_MIMETYPE               = \"application/x-dtbncx+xml\";\nstatic const QString NCX_EXTENSION       = \"ncx\";\nconst QString ADOBE_FONT_ALGO_ID         = \"http://ns.adobe.com/pdf/enc#RC\";\nconst QString IDPF_FONT_ALGO_ID          = \"http://www.idpf.org/2008/embedding\";\nstatic const QString CONTAINER_XML       = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n        \"<container version=\\\"1.0\\\" xmlns=\\\"urn:oasis:names:tc:opendocument:xmlns:container\\\">\\n\"\n        \"    <rootfiles>\\n\"\n        \"        <rootfile full-path=\\\"%1\\\" media-type=\\\"application/oebps-package+xml\\\"/>\\n\"\n        \"   </rootfiles>\\n\"\n        \"</container>\\n\";\n\nstatic QCodePage437Codec *cp437 = 0;\n\n// Constructor;\n// The parameter is the file to be imported\nImportEPUB::ImportEPUB(const QString &fullfilepath)\n    : Importer(fullfilepath),\n      m_ExtractedFolderPath(m_TempFolder.GetPath()),\n      m_HasSpineItems(false),\n      m_NCXNotInManifest(false),\n      m_NavResource(NULL)\n{\n}\n\n// Reads and parses the file\n// and returns the created Book\nQSharedPointer<Book> ImportEPUB::GetBook(bool extract_metadata)\n{\n    QList<XMLResource *> non_well_formed;\n    SettingsStore ss;\n\n    if (!Utility::IsFileReadable(m_FullFilePath)) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot read EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    // These read the EPUB file\n    ExtractContainer();\n    QHash<QString, QString> encrypted_files = ParseEncryptionXml();\n\n    if (BookContentEncrypted(encrypted_files)) {\n        throw (FileEncryptedWithDrm(\"\"));\n    }\n\n    QApplication::setOverrideCursor(Qt::WaitCursor);\n\n    // These mutate the m_Book object\n    LocateOPF();\n    m_opfDir = QFileInfo(m_OPFFilePath).dir();\n    // These mutate the m_Book object\n    ReadOPF();\n    AddObfuscatedButUndeclaredFonts(encrypted_files);\n    AddNonStandardAppleXML();\n    LoadInfrastructureFiles();\n    // Check for files missing in the Manifest and create warning\n    QStringList notInManifest;\n    foreach(QString file_path, m_ZipFilePaths) {\n        // skip mimetype and anything in META-INF and the opf itself\n        if (file_path == \"mimetype\") continue;\n        if (file_path.startsWith(\"META-INF\")) continue;\n\tif (m_OPFFilePath.contains(file_path)) continue;\n\tif (!m_ManifestFilePaths.contains(file_path)) {\n\t    notInManifest << file_path;\n\t}\n    }\n    if (!notInManifest.isEmpty()) {\n        Utility::DisplayStdWarningDialog(tr(\"Files exist in epub that are not listed in the manifest, they will be ignored\"), notInManifest.join(\"\\n\"));\n    }\n    const QHash<QString, QString> updates = LoadFolderStructure();\n    const QList<Resource *> resources     = m_Book->GetFolderKeeper()->GetResourceList();\n\n    // We're going to check all html files until we find one that isn't well formed then we'll prompt\n    // the user if they want to auto fix or not.\n    //\n    // If we have non-well formed content and they shouldn't be auto fixed we'll pass that on to\n    // the universal update function so it knows to skip them. Otherwise we won't include them and\n    // let it modify the file.\n    for (int i=0; i<resources.count(); ++i) {\n        if (resources.at(i)->Type() == Resource::HTMLResourceType) {\n            HTMLResource *hresource = dynamic_cast<HTMLResource *>(resources.at(i));\n            if (!hresource) {\n                continue;\n            }\n            // Load the content into the HTMLResource so we can perform a well formed check.\n            try {\n                hresource->SetText(HTMLEncodingResolver::ReadHTMLFile(hresource->GetFullPath()));\n            } catch (...) {\n                if (ss.cleanOn() & CLEANON_OPEN) {\n                    non_well_formed << hresource;\n                    continue;\n                }\n            }\n            if (ss.cleanOn() & CLEANON_OPEN) {\n              if (!XhtmlDoc::IsDataWellFormed(hresource->GetText(),hresource->GetEpubVersion())) {\n                    non_well_formed << hresource;\n                }\n            }\n        }\n    }\n    if (!non_well_formed.isEmpty()) {\n        QApplication::restoreOverrideCursor();\n        if (QMessageBox::Yes == QMessageBox::warning(QApplication::activeWindow(),\n                tr(\"Sigil\"),\n                tr(\"This EPUB has HTML files that are not well formed. \"\n                   \"Sigil can attempt to automatically fix these files, although this \"\n                   \"can result in data loss.\\n\\n\"\n                   \"Do you want to automatically fix the files?\"),\n                QMessageBox::Yes|QMessageBox::No)\n           ) {\n            non_well_formed.clear();\n        }\n        QApplication::setOverrideCursor(Qt::WaitCursor);\n    }\n\n    const QStringList load_errors = UniversalUpdates::PerformUniversalUpdates(false, resources, updates, non_well_formed);\n\n    Q_FOREACH (QString err, load_errors) {\n        AddLoadWarning(QString(\"%1\").arg(err));\n    }\n\n    ProcessFontFiles(resources, updates, encrypted_files);\n\n    if (m_PackageVersion.startsWith('3')) {\n        HTMLResource * nav_resource = NULL;\n        if (m_NavResource) {\n            if (m_NavResource->Type() == Resource::HTMLResourceType) {\n                nav_resource = dynamic_cast<HTMLResource*>(m_NavResource);\n            }\n        }\n        if (!nav_resource) { \n            // we need to create a nav file here because one was not found\n            // it will automatically be added to the content.opf\n            nav_resource = m_Book->CreateEmptyNavFile(true);\n            Resource * res = dynamic_cast<Resource *>(nav_resource);\n            m_Book->GetOPF()->SetItemRefLinear(res, false);\n        }\n        m_Book->GetOPF()->SetNavResource(nav_resource);\n    }\n\n    if (m_NCXNotInManifest) {\n        // We manually created an NCX file because there wasn't one in the manifest.\n        // Need to create a new manifest id for it.\n        m_NCXId = m_Book->GetOPF()->AddNCXItem(m_NCXFilePath);\n    }\n\n    // Ensure that our spine has a <spine toc=\"ncx\"> element on it now in case it was missing.\n    m_Book->GetOPF()->UpdateNCXOnSpine(m_NCXId);\n    // Make sure the <item> for the NCX in the manifest reflects correct href path\n    m_Book->GetOPF()->UpdateNCXLocationInManifest(m_Book->GetNCX());\n\n    // If spine was not present or did not contain any items, recreate the OPF from scratch\n    // preserving any important metadata elements and making a new reading order.\n    if (!m_HasSpineItems) {\n        QList<MetaEntry> originalMetadata = m_Book->GetOPF()->GetDCMetadata();\n        m_Book->GetOPF()->AutoFixWellFormedErrors();\n        if (extract_metadata) {\n            m_Book->GetOPF()->SetDCMetadata(originalMetadata);\n        }\n        AddLoadWarning(QObject::tr(\"The OPF file does not contain a valid spine.\") % \"\\n\" %\n                       QObject::tr(\"Sigil has created a new one for you.\"));\n    }\n\n    // If we have modified the book to add spine attribute, manifest item or NCX mark as changed.\n    m_Book->SetModified(GetLoadWarnings().count() > 0);\n    QApplication::restoreOverrideCursor();\n    return m_Book;\n}\n\n\nQHash<QString, QString> ImportEPUB::ParseEncryptionXml()\n{\n    QString encrpytion_xml_path = m_ExtractedFolderPath + \"/META-INF/encryption.xml\";\n\n    if (!QFileInfo(encrpytion_xml_path).exists()) {\n        return QHash<QString, QString>();\n    }\n\n    QXmlStreamReader encryption(Utility::ReadUnicodeTextFile(encrpytion_xml_path));\n    QHash<QString, QString> encrypted_files;\n    QString encryption_algo;\n    QString uri;\n\n    while (!encryption.atEnd()) {\n        encryption.readNext();\n\n        if (encryption.isStartElement()) {\n            if (encryption.name() == \"EncryptionMethod\") {\n                encryption_algo = encryption.attributes().value(\"\", \"Algorithm\").toString();\n            } else if (encryption.name() == \"CipherReference\") {\n                uri = Utility::URLDecodePath(encryption.attributes().value(\"\", \"URI\").toString());\n                encrypted_files[ uri ] = encryption_algo;\n            }\n        }\n    }\n\n    if (encryption.hasError()) {\n        const QString error = QString(QObject::tr(\"Error parsing encryption xml.\\nLine: %1 Column %2 - %3\"))\n                              .arg(encryption.lineNumber())\n                              .arg(encryption.columnNumber())\n                              .arg(encryption.errorString());\n        throw (EPUBLoadParseError(error.toStdString()));\n    }\n\n    return encrypted_files;\n}\n\n\nbool ImportEPUB::BookContentEncrypted(const QHash<QString, QString> &encrypted_files)\n{\n    foreach(QString algorithm, encrypted_files.values()) {\n        if (algorithm != ADOBE_FONT_ALGO_ID &&\n            algorithm != IDPF_FONT_ALGO_ID) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n// This is basically a workaround for old versions of InDesign not listing the fonts it\n// embedded in the OPF manifest, even though the specs say it has to.\n// It does list them in the encryption.xml, so we use that.\nvoid ImportEPUB::AddObfuscatedButUndeclaredFonts(const QHash<QString, QString> &encrypted_files)\n{\n    if (encrypted_files.empty()) {\n        return;\n    }\n\n    QDir opf_dir = QFileInfo(m_OPFFilePath).dir();\n    foreach(QString filepath, encrypted_files.keys()) {\n        if (!FONT_EXTENSIONS.contains(QFileInfo(filepath).suffix().toLower())) {\n            continue;\n        }\n\n        // Only add the path to the manifest if it is not already included.\n        QMapIterator<QString, QString> valueSearch(m_Files);\n\n        if (!valueSearch.findNext(opf_dir.relativeFilePath(filepath))) {\n            m_Files[ Utility::CreateUUID() ] = opf_dir.relativeFilePath(filepath);\n        }\n    }\n}\n\n\n// Another workaround for non-standard Apple files\n// At present it only handles com.apple.ibooks.display-options.xml, but any\n// further iBooks aberrations should be handled here as well.\nvoid ImportEPUB::AddNonStandardAppleXML()\n{\n    QDir opf_dir = QFileInfo(m_OPFFilePath).dir();\n    QStringList aberrant_Apple_filenames;\n    aberrant_Apple_filenames.append(m_ExtractedFolderPath + \"/META-INF/com.apple.ibooks.display-options.xml\");\n\n    for (int i = 0; i < aberrant_Apple_filenames.size(); ++i) {\n        if (QFile::exists(aberrant_Apple_filenames.at(i))) {\n            m_Files[ Utility::CreateUUID() ]  = opf_dir.relativeFilePath(aberrant_Apple_filenames.at(i));\n        }\n    }\n}\n\n\n// Each resource can provide us with its new path. encrypted_files provides\n// a mapping from old resource paths to the obfuscation algorithms.\n// So we use the updates hash which provides a mapping from old paths to new\n// paths to match the resources to their algorithms.\nvoid ImportEPUB::ProcessFontFiles(const QList<Resource *> &resources,\n                                  const QHash<QString, QString> &updates,\n                                  const QHash<QString, QString> &encrypted_files)\n{\n    if (encrypted_files.empty()) {\n        return;\n    }\n\n    QList<FontResource *> font_resources = m_Book->GetFolderKeeper()->GetResourceTypeList<FontResource>();\n\n    if (font_resources.empty()) {\n        return;\n    }\n\n    QHash<QString, QString> new_font_paths_to_algorithms;\n    foreach(QString old_update_path, updates.keys()) {\n        if (!FONT_EXTENSIONS.contains(QFileInfo(old_update_path).suffix().toLower())) {\n            continue;\n        }\n\n        QString new_update_path = updates[ old_update_path ];\n        foreach(QString old_encrypted_path, encrypted_files.keys()) {\n            if (old_update_path == old_encrypted_path) {\n                new_font_paths_to_algorithms[ new_update_path ] = encrypted_files[ old_encrypted_path ];\n            }\n        }\n    }\n    foreach(FontResource * font_resource, font_resources) {\n        QString match_path = \"../\" + font_resource->GetRelativePathToOEBPS();\n        QString algorithm  = new_font_paths_to_algorithms.value(match_path);\n\n        if (algorithm.isEmpty()) {\n            continue;\n        }\n\n        font_resource->SetObfuscationAlgorithm(algorithm);\n\n        // Actually we are de-obfuscating, but the inverse operations of the obfuscation methods\n        // are the obfuscation methods themselves. For the math oriented, the obfuscation methods\n        // are involutary [ f( f( x ) ) = x ].\n        if (algorithm == ADOBE_FONT_ALGO_ID) {\n            FontObfuscation::ObfuscateFile(font_resource->GetFullPath(), algorithm, m_UuidIdentifierValue);\n        } else {\n            FontObfuscation::ObfuscateFile(font_resource->GetFullPath(), algorithm, m_UniqueIdentifierValue);\n        }\n    }\n}\n\nvoid ImportEPUB::ExtractContainer()\n{\n    int res = 0;\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData());\n#endif\n\n    if (zfile == NULL) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot unzip EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n\n\t        // for security reasons we need the file path to always be inside the \n                // target folder and not outside, so we will remove all relative upward \n                // paths segments \"..\" from the file path before prepending the target \n                // folder to create the final target path\n\t        qfile_name = qfile_name.replace(\"../\",\"\");\n                cp437_file_name = cp437_file_name.replace(\"../\",\"\");\n\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                QDir dir(m_ExtractedFolderPath);\n                // Full file path in the temporary directory.\n                QString file_path = m_ExtractedFolderPath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n\t\t    // add it to the list of files found inside the zip\n\t\t    if (cp437_file_name.isEmpty()) {\n\t\t        m_ZipFilePaths << qfile_name;\n\t\t    } else {\n                        m_ZipFilePaths << cp437_file_name;\n\t\t    }\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = m_ExtractedFolderPath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot open EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    unzClose(zfile);\n}\n\nvoid ImportEPUB::LocateOPF()\n{\n    QString fullpath = m_ExtractedFolderPath + \"/META-INF/container.xml\";\n    QXmlStreamReader container;\n    try {\n        container.addData(Utility::ReadUnicodeTextFile(fullpath));\n    } catch (CannotOpenFile) {\n        // Find the first OPF file.\n        QString OPFfile;\n        QDirIterator files(m_ExtractedFolderPath, QStringList() << \"*.opf\", QDir::NoFilter, QDirIterator::Subdirectories);\n        while (files.hasNext()) {\n            OPFfile = QDir(m_ExtractedFolderPath).relativeFilePath(files.next());\n            break;\n        }\n\n        if (OPFfile.isEmpty()) {\n            std::string msg = fullpath.toStdString() + \": \" + tr(\"Epub has missing or improperly specified OPF.\").toStdString();\n            throw (CannotOpenFile(msg));\n        }\n\n        // Create a default container.xml.\n        QDir folder(m_ExtractedFolderPath);\n        folder.mkdir(\"META-INF\");\n        Utility::WriteUnicodeTextFile(CONTAINER_XML.arg(OPFfile), fullpath);\n        container.addData(Utility::ReadUnicodeTextFile(fullpath));\n    }\n\n    while (!container.atEnd()) {\n        container.readNext();\n\n        if (container.isStartElement() &&\n            container.name() == \"rootfile\"\n           ) {\n            if (container.attributes().hasAttribute(\"media-type\") &&\n                container.attributes().value(\"\", \"media-type\") == OEBPS_MIMETYPE\n               ) {\n                m_OPFFilePath = m_ExtractedFolderPath + \"/\" + container.attributes().value(\"\", \"full-path\").toString();\n                // As per OCF spec, the first rootfile element\n                // with the OEBPS mimetype is considered the \"main\" one.\n                break;\n            }\n        }\n    }\n\n    if (container.hasError()) {\n        const QString error = QString(\n                                  QObject::tr(\"Unable to parse container.xml file.\\nLine: %1 Column %2 - %3\"))\n                              .arg(container.lineNumber())\n                              .arg(container.columnNumber())\n                              .arg(container.errorString());\n        throw (EPUBLoadParseError(error.toStdString()));\n    }\n\n    if (m_OPFFilePath.isEmpty() || !QFile::exists(m_OPFFilePath)) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"No appropriate OPF file found\")).toStdString()));\n    }\n}\n\n\nvoid ImportEPUB::ReadOPF()\n{\n    QString opf_text = CleanSource::ProcessXML(PrepareOPFForReading(Utility::ReadUnicodeTextFile(m_OPFFilePath)),OEBPS_MIMETYPE);\n    QXmlStreamReader opf_reader(opf_text);\n    QString ncx_id_on_spine;\n\n    while (!opf_reader.atEnd()) {\n        opf_reader.readNext();\n\n        if (!opf_reader.isStartElement()) {\n            continue;\n        }\n\n        if (opf_reader.name() == \"package\") {\n            m_UniqueIdentifierId = opf_reader.attributes().value(\"\", \"unique-identifier\").toString();\n            m_PackageVersion = opf_reader.attributes().value(\"\", \"version\").toString();\n            if (m_PackageVersion == \"1.0\") m_PackageVersion = \"2.0\";\n\t}\n\n        else if (opf_reader.name() == \"identifier\") {\n            ReadIdentifierElement(&opf_reader);\n\t}\n\n        // epub3 look for linked metadata resources that are included inside the epub \n        // but that are not and must not be included in the manifest\n        else if (opf_reader.name() == \"link\") {\n            ReadMetadataLinkElement(&opf_reader);\n\t}\n\n        // Get the list of content files that\n        // make up the publication\n        else if (opf_reader.name() == \"item\") {\n            ReadManifestItemElement(&opf_reader);\n        }\n\n        // We read this just to get the NCX id\n        else if (opf_reader.name() == \"spine\") {\n            ncx_id_on_spine = opf_reader.attributes().value(\"\", \"toc\").toString();\n        } \n\n        else if (opf_reader.name() == \"itemref\") {\n            m_HasSpineItems = true;\n        }\n    }\n\n    if (opf_reader.hasError()) {\n        const QString error = QString(QObject::tr(\"Unable to read OPF file.\\nLine: %1 Column %2 - %3\"))\n                              .arg(opf_reader.lineNumber())\n                              .arg(opf_reader.columnNumber())\n                              .arg(opf_reader.errorString());\n        throw (EPUBLoadParseError(error.toStdString()));\n    }\n\n    // Ensure we have an NCX available\n    LocateOrCreateNCX(ncx_id_on_spine);\n\n}\n\n\nvoid ImportEPUB::ReadIdentifierElement(QXmlStreamReader *opf_reader)\n{\n    QString id     = opf_reader->attributes().value(\"\", \"id\").toString();\n    QString scheme = opf_reader->attributes().value(\"\", \"scheme\").toString();\n    QString value  = opf_reader->readElementText();\n\n    if (id == m_UniqueIdentifierId) {\n        m_UniqueIdentifierValue = value;\n    }\n\n    if (m_UuidIdentifierValue.isEmpty() &&\n        (value.contains(\"urn:uuid:\") || scheme.toLower() == \"uuid\")) {\n        m_UuidIdentifierValue = value;\n    }\n}\n\nvoid ImportEPUB::ReadMetadataLinkElement(QXmlStreamReader *opf_reader)\n{\n    QString relation = opf_reader->attributes().value(\"\", \"rel\").toString();\n    QString mtype = opf_reader->attributes().value(\"\", \"media-type\").toString();\n    QString props = opf_reader->attributes().value(\"\", \"properties\").toString();\n    QString href = opf_reader->attributes().value(\"\", \"href\").toString();\n    if (!href.isEmpty()) {\n        QUrl url = QUrl(href);\n        if (url.isRelative()) {\n\t    // we have a local unmanifested metadata file to handle\n\t    // attempt to map deprecated record types into proper media-types\n\t    if (relation == \"marc21xml-record\") {\n                mtype = \"application/marcxml+xml\";\n\t    }\n\t    else if (relation == \"mods-record\") {\n                mtype = \"application/mods+xml\";\n\t    }\n\t    else if (relation == \"onix-record\") {\n                mtype = \"application/xml;onix\";\n            }\n\t    else if (relation == \"xmp-record\") {\n                mtype = \"application/xml;xmp\";\n\t    }\n            else if (relation == \"record\") {\n                if (props == \"onix\") mtype = \"application/xml;onix\";\n                if (props == \"xmp\") mtype = \"application/xml;xmp\";\n\t    }\n            QDir opf_dir = QFileInfo(m_OPFFilePath).dir();\n\t    QString path = opf_dir.absolutePath() + \"/\" + url.path();\n\t    if (QFile::exists(path)) {\n\t        QString id = Utility::CreateUUID();\n\t\tm_Files[ id ]  = opf_dir.relativeFilePath(path);\n\t\tm_FileMimetypes[ id ] = mtype;\n\t    }\n\t}\n    }\n}\n\nvoid ImportEPUB::ReadManifestItemElement(QXmlStreamReader *opf_reader)\n{\n    QString id   = opf_reader->attributes().value(\"\", \"id\").toString();\n    QString href = opf_reader->attributes().value(\"\", \"href\").toString();\n    QString type = opf_reader->attributes().value(\"\", \"media-type\").toString();\n    QString properties = opf_reader->attributes().value(\"\", \"properties\").toString();\n    // Paths are percent encoded in the OPF, we use \"normal\" paths internally.\n    href = Utility::URLDecodePath(href);\n    QString extension = QFileInfo(href).suffix().toLower();\n\n    // find the epub root relative file path from the opf location and the item href\n    QString file_path = m_opfDir.absolutePath() + \"/\" + href;\n    file_path = file_path.remove(0, m_ExtractedFolderPath.length() + 1); \n    \n    if (type != NCX_MIMETYPE && extension != NCX_EXTENSION) {\n        if (!m_ManifestFilePaths.contains(file_path)) {\n            if (m_Files.contains(id)) {\n                // We have an error situation with a duplicate id in the epub.\n                // We must warn the user, but attempt to use another id so the epub can still be loaded.\n                QString base_id = QFileInfo(href).fileName();\n                QString new_id(base_id);\n                int duplicate_index = 0;\n\n                while (m_Files.contains(new_id)) {\n                    duplicate_index++;\n                    new_id = QString(\"%1%2\").arg(base_id).arg(duplicate_index);\n                }\n\n                const QString load_warning = QObject::tr(\"The OPF manifest contains duplicate ids for: %1\").arg(id) +\n                  \" - \" + QObject::tr(\"A temporary id has been assigned to load this EPUB. You should edit your OPF file to remove the duplication.\");\n                id = new_id;\n                AddLoadWarning(load_warning);\n            }\n\n            m_Files[ id ] = href;\n            m_FileMimetypes[ id ] = type;\n            m_ManifestFilePaths << file_path;\n\n            // store information about any nav document\n            if (properties.contains(\"nav\")) {\n                m_NavId = id;\n                m_NavHref = href;\n            }\n        }\n    } else {\n        m_NcxCandidates[ id ] = href;\n\tm_ManifestFilePaths << file_path;\n    }\n}\n\n\nvoid ImportEPUB::LocateOrCreateNCX(const QString &ncx_id_on_spine)\n{\n    QString load_warning;\n    QString ncx_href = \"not_found\";\n    m_NCXId = ncx_id_on_spine;\n\n    // Handle various failure conditions, such as:\n    // - ncx not specified in the spine (search for a matching manifest item by extension)\n    // - ncx specified in spine, but no matching manifest item entry (create a new one)\n    // - ncx file not physically present (create a new one)\n    // - ncx not in spine or manifest item (create a new one)\n    if (!m_NCXId.isEmpty()) {\n        ncx_href = m_NcxCandidates[ m_NCXId ];\n    } else {\n        // Search for the ncx in the manifest by looking for files with\n        // a .ncx extension.\n        QHashIterator<QString, QString> ncxSearch(m_NcxCandidates);\n\n        while (ncxSearch.hasNext()) {\n            ncxSearch.next();\n\n            if (QFileInfo(ncxSearch.value()).suffix().toLower() == NCX_EXTENSION) {\n                m_NCXId = ncxSearch.key();\n                load_warning = QObject::tr(\"The OPF file did not identify the NCX file correctly.\") + \"\\n\" + \n                               \" - \"  +  QObject::tr(\"Sigil has used the following file as the NCX:\") + \n                               QString(\" %1\").arg(m_NcxCandidates[ m_NCXId ]);\n                ncx_href = m_NcxCandidates[ m_NCXId ];\n                break;\n            }\n        }\n    }\n\n    m_NCXFilePath = QFileInfo(m_OPFFilePath).absolutePath() % \"/\" % ncx_href;\n\n    if (ncx_href.isEmpty() || !QFile::exists(m_NCXFilePath)) {\n        m_NCXNotInManifest = m_NCXId.isEmpty() || ncx_href.isEmpty();\n        m_NCXId.clear();\n        // Things are really bad and no .ncx file was found in the manifest or\n        // the file does not physically exist.  We need to create a new one.\n        m_NCXFilePath = QFileInfo(m_OPFFilePath).absolutePath() % \"/\" % NCX_FILE_NAME;\n        // Create a new file for the NCX.\n        NCXResource ncx_resource(m_ExtractedFolderPath, m_NCXFilePath, m_Book->GetFolderKeeper());\n\n        // We are relying on an identifier being set from the metadata.\n        // It might not have one if the book does not have the urn:uuid: format.\n        if (!m_UuidIdentifierValue.isEmpty()) {\n            ncx_resource.SetMainID(m_UuidIdentifierValue);\n        }\n\n        ncx_resource.SaveToDisk();\n\n        if (m_PackageVersion.startsWith('3')) { \n            load_warning = QObject::tr(\"Sigil has created a template NCX\") + \"\\n\" + \n              QObject::tr(\"to support epub2 backwards compatibility.\");\n        } else {\n            if (ncx_href.isEmpty()) {\n                load_warning = QObject::tr(\"The OPF file does not contain an NCX file.\") + \"\\n\" + \n                               \" - \" +  QObject::tr(\"Sigil has created a new one for you.\");\n            } else {\n                load_warning = QObject::tr(\"The NCX file is not present in this EPUB.\") + \"\\n\" + \n                               \" - \" + QObject::tr(\"Sigil has created a new one for you.\");\n            }\n        }\n    }\n\n    if (!load_warning.isEmpty()) {\n        AddLoadWarning(load_warning);\n    }\n}\n\n\nvoid ImportEPUB::LoadInfrastructureFiles()\n{\n    // always SetEpubVersion before SetText in OPF as SetText will validate with it\n    m_Book->GetOPF()->SetEpubVersion(m_PackageVersion);\n    m_Book->GetOPF()->SetText(CleanSource::ProcessXML(PrepareOPFForReading(Utility::ReadUnicodeTextFile(m_OPFFilePath)),OEBPS_MIMETYPE));\n    QString OPFBookRelPath = m_OPFFilePath;\n    OPFBookRelPath = OPFBookRelPath.remove(0,m_ExtractedFolderPath.length()+1);\n    m_Book->GetOPF()->SetCurrentBookRelPath(OPFBookRelPath);\n\n    m_Book->GetNCX()->SetText(CleanSource::ProcessXML(Utility::ReadUnicodeTextFile(m_NCXFilePath),\"application/x-dtbncx+xml\"));\n    m_Book->GetNCX()->SetEpubVersion(m_PackageVersion);\n    QString NCXBookRelPath = m_NCXFilePath;\n    NCXBookRelPath = NCXBookRelPath.remove(0,m_ExtractedFolderPath.length()+1);\n    m_Book->GetNCX()->SetCurrentBookRelPath(NCXBookRelPath);\n}\n\n\nQHash<QString, QString> ImportEPUB::LoadFolderStructure()\n{\n    QList<QString> keys = m_Files.keys();\n    int num_files = keys.count();\n    QFutureSynchronizer<std::tuple<QString, QString>> sync;\n\n    for (int i = 0; i < num_files; ++i) {\n        QString id = keys.at(i);\n        sync.addFuture(QtConcurrent::run(\n                           this,\n                           &ImportEPUB::LoadOneFile,\n                           m_Files.value(id),\n                           m_FileMimetypes.value(id)));\n    }\n\n    sync.waitForFinished();\n    QList<QFuture<std::tuple<QString, QString>>> futures = sync.futures();\n    int num_futures = futures.count();\n    QHash<QString, QString> updates;\n\n    for (int i = 0; i < num_futures; ++i) {\n        std::tuple<QString, QString> result = futures.at(i).result();\n        updates[std::get<0>(result)] = std::get<1>(result);\n    }\n\n    updates.remove(UPDATE_ERROR_STRING);\n    return updates;\n}\n\n\nstd::tuple<QString, QString> ImportEPUB::LoadOneFile(const QString &path, const QString &mimetype)\n{\n    QString fullfilepath = QDir::cleanPath(QFileInfo(m_OPFFilePath).absolutePath() + \"/\" + path);\n    QString currentpath = fullfilepath;\n    currentpath = currentpath.remove(0,m_ExtractedFolderPath.length()+1);\n    try {\n        Resource *resource = m_Book->GetFolderKeeper()->AddContentFileToFolder(fullfilepath, false, mimetype);\n        if (path == m_NavHref) {\n            m_NavResource = resource;\n        }\n        resource->SetCurrentBookRelPath(currentpath);\n        QString newpath = \"../\" + resource->GetRelativePathToOEBPS();\n        return std::make_tuple(currentpath, newpath);\n    } catch (FileDoesNotExist) {\n        return std::make_tuple(UPDATE_ERROR_STRING, UPDATE_ERROR_STRING);\n    }\n}\n\n\nQString ImportEPUB::PrepareOPFForReading(const QString &source)\n{\n    QString source_copy(source);\n    QString prefix = source_copy.left(XML_DECLARATION_SEARCH_PREFIX_SIZE);\n    QRegularExpression version(VERSION_ATTRIBUTE);\n    QRegularExpressionMatch mo = version.match(prefix);\n    if (mo.hasMatch()) {\n        // MASSIVE hack for XML 1.1 \"support\";\n        // this is only for people who specify\n        // XML 1.1 when they actually only use XML 1.0\n        source_copy.replace(mo.capturedStart(1), mo.capturedLength(1), \"1.0\");\n    }\n    return source_copy;\n}\n"], "fixing_code": ["/************************************************************************\n**\n**  Copyright (C) 2016 - 2019 Kevin B. Hendricks, Stratford, Ontario, Canada\n**  Copyright (C) 2012 John Schember <john@nachtimwald.com>\n**  Copyright (C) 2009, 2010, 2011  Strahinja Markovic  <strahinja.markovic@gmail.com>\n**\n**  This file is part of Sigil.\n**\n**  Sigil is free software: you can redistribute it and/or modify\n**  it under the terms of the GNU General Public License as published by\n**  the Free Software Foundation, either version 3 of the License, or\n**  (at your option) any later version.\n**\n**  Sigil is distributed in the hope that it will be useful,\n**  but WITHOUT ANY WARRANTY; without even the implied warranty of\n**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n**  GNU General Public License for more details.\n**\n**  You should have received a copy of the GNU General Public License\n**  along with Sigil.  If not, see <http://www.gnu.org/licenses/>.\n**\n*************************************************************************/\n\n#ifdef _WIN32\n#define NOMINMAX\n#endif\n\n#include \"unzip.h\"\n#ifdef _WIN32\n#include \"iowin32.h\"\n#endif\n\n#include <string>\n\n#include <QApplication>\n#include <QtCore/QtCore>\n#include <QtCore/QDir>\n#include <QtCore/QFile>\n#include <QtCore/QFileInfo>\n#include <QtCore/QFutureSynchronizer>\n#include <QtConcurrent/QtConcurrent>\n#include <QtCore/QXmlStreamReader>\n#include <QDirIterator>\n#include <QRegularExpression>\n#include <QRegularExpressionMatch>\n#include <QStringList>\n#include <QMessageBox>\n#include <QUrl>\n\n#include \"BookManipulation/FolderKeeper.h\"\n#include \"BookManipulation/CleanSource.h\"\n#include \"Importers/ImportEPUB.h\"\n#include \"Misc/FontObfuscation.h\"\n#include \"Misc/HTMLEncodingResolver.h\"\n#include \"Misc/QCodePage437Codec.h\"\n#include \"Misc/SettingsStore.h\"\n#include \"Misc/Utility.h\"\n#include \"ResourceObjects/CSSResource.h\"\n#include \"ResourceObjects/HTMLResource.h\"\n#include \"ResourceObjects/OPFResource.h\"\n#include \"ResourceObjects/NCXResource.h\"\n#include \"ResourceObjects/Resource.h\"\n#include \"ResourceObjects/OPFParser.h\"\n#include \"SourceUpdates/UniversalUpdates.h\"\n#include \"sigil_constants.h\"\n#include \"sigil_exception.h\"\n\n#ifndef MAX_PATH\n// Set Max length to 256 because that's the max path size on many systems.\n#define MAX_PATH 256\n#endif\n// This is the same read buffer size used by Java and Perl.\n#define BUFF_SIZE 8192\n\nconst QString DUBLIN_CORE_NS             = \"http://purl.org/dc/elements/1.1/\";\nstatic const QString OEBPS_MIMETYPE      = \"application/oebps-package+xml\";\nstatic const QString UPDATE_ERROR_STRING = \"SG_ERROR\";\nconst QString NCX_MIMETYPE               = \"application/x-dtbncx+xml\";\nstatic const QString NCX_EXTENSION       = \"ncx\";\nconst QString ADOBE_FONT_ALGO_ID         = \"http://ns.adobe.com/pdf/enc#RC\";\nconst QString IDPF_FONT_ALGO_ID          = \"http://www.idpf.org/2008/embedding\";\nstatic const QString CONTAINER_XML       = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n        \"<container version=\\\"1.0\\\" xmlns=\\\"urn:oasis:names:tc:opendocument:xmlns:container\\\">\\n\"\n        \"    <rootfiles>\\n\"\n        \"        <rootfile full-path=\\\"%1\\\" media-type=\\\"application/oebps-package+xml\\\"/>\\n\"\n        \"   </rootfiles>\\n\"\n        \"</container>\\n\";\n\nstatic QCodePage437Codec *cp437 = 0;\n\n// Constructor;\n// The parameter is the file to be imported\nImportEPUB::ImportEPUB(const QString &fullfilepath)\n    : Importer(fullfilepath),\n      m_ExtractedFolderPath(m_TempFolder.GetPath()),\n      m_HasSpineItems(false),\n      m_NCXNotInManifest(false),\n      m_NavResource(NULL)\n{\n}\n\n// Reads and parses the file\n// and returns the created Book\nQSharedPointer<Book> ImportEPUB::GetBook(bool extract_metadata)\n{\n    QList<XMLResource *> non_well_formed;\n    SettingsStore ss;\n\n    if (!Utility::IsFileReadable(m_FullFilePath)) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot read EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    // These read the EPUB file\n    ExtractContainer();\n    QHash<QString, QString> encrypted_files = ParseEncryptionXml();\n\n    if (BookContentEncrypted(encrypted_files)) {\n        throw (FileEncryptedWithDrm(\"\"));\n    }\n\n    QApplication::setOverrideCursor(Qt::WaitCursor);\n\n    // These mutate the m_Book object\n    LocateOPF();\n    m_opfDir = QFileInfo(m_OPFFilePath).dir();\n    // These mutate the m_Book object\n    ReadOPF();\n    AddObfuscatedButUndeclaredFonts(encrypted_files);\n    AddNonStandardAppleXML();\n    LoadInfrastructureFiles();\n    // Check for files missing in the Manifest and create warning\n    QStringList notInManifest;\n    foreach(QString file_path, m_ZipFilePaths) {\n        // skip mimetype and anything in META-INF and the opf itself\n        if (file_path == \"mimetype\") continue;\n        if (file_path.startsWith(\"META-INF\")) continue;\n\tif (m_OPFFilePath.contains(file_path)) continue;\n\tif (!m_ManifestFilePaths.contains(file_path)) {\n\t    notInManifest << file_path;\n\t}\n    }\n    if (!notInManifest.isEmpty()) {\n        Utility::DisplayStdWarningDialog(tr(\"Files exist in epub that are not listed in the manifest, they will be ignored\"), notInManifest.join(\"\\n\"));\n    }\n    const QHash<QString, QString> updates = LoadFolderStructure();\n    const QList<Resource *> resources     = m_Book->GetFolderKeeper()->GetResourceList();\n\n    // We're going to check all html files until we find one that isn't well formed then we'll prompt\n    // the user if they want to auto fix or not.\n    //\n    // If we have non-well formed content and they shouldn't be auto fixed we'll pass that on to\n    // the universal update function so it knows to skip them. Otherwise we won't include them and\n    // let it modify the file.\n    for (int i=0; i<resources.count(); ++i) {\n        if (resources.at(i)->Type() == Resource::HTMLResourceType) {\n            HTMLResource *hresource = dynamic_cast<HTMLResource *>(resources.at(i));\n            if (!hresource) {\n                continue;\n            }\n            // Load the content into the HTMLResource so we can perform a well formed check.\n            try {\n                hresource->SetText(HTMLEncodingResolver::ReadHTMLFile(hresource->GetFullPath()));\n            } catch (...) {\n                if (ss.cleanOn() & CLEANON_OPEN) {\n                    non_well_formed << hresource;\n                    continue;\n                }\n            }\n            if (ss.cleanOn() & CLEANON_OPEN) {\n              if (!XhtmlDoc::IsDataWellFormed(hresource->GetText(),hresource->GetEpubVersion())) {\n                    non_well_formed << hresource;\n                }\n            }\n        }\n    }\n    if (!non_well_formed.isEmpty()) {\n        QApplication::restoreOverrideCursor();\n        if (QMessageBox::Yes == QMessageBox::warning(QApplication::activeWindow(),\n                tr(\"Sigil\"),\n                tr(\"This EPUB has HTML files that are not well formed. \"\n                   \"Sigil can attempt to automatically fix these files, although this \"\n                   \"can result in data loss.\\n\\n\"\n                   \"Do you want to automatically fix the files?\"),\n                QMessageBox::Yes|QMessageBox::No)\n           ) {\n            non_well_formed.clear();\n        }\n        QApplication::setOverrideCursor(Qt::WaitCursor);\n    }\n\n    const QStringList load_errors = UniversalUpdates::PerformUniversalUpdates(false, resources, updates, non_well_formed);\n\n    Q_FOREACH (QString err, load_errors) {\n        AddLoadWarning(QString(\"%1\").arg(err));\n    }\n\n    ProcessFontFiles(resources, updates, encrypted_files);\n\n    if (m_PackageVersion.startsWith('3')) {\n        HTMLResource * nav_resource = NULL;\n        if (m_NavResource) {\n            if (m_NavResource->Type() == Resource::HTMLResourceType) {\n                nav_resource = dynamic_cast<HTMLResource*>(m_NavResource);\n            }\n        }\n        if (!nav_resource) { \n            // we need to create a nav file here because one was not found\n            // it will automatically be added to the content.opf\n            nav_resource = m_Book->CreateEmptyNavFile(true);\n            Resource * res = dynamic_cast<Resource *>(nav_resource);\n            m_Book->GetOPF()->SetItemRefLinear(res, false);\n        }\n        m_Book->GetOPF()->SetNavResource(nav_resource);\n    }\n\n    if (m_NCXNotInManifest) {\n        // We manually created an NCX file because there wasn't one in the manifest.\n        // Need to create a new manifest id for it.\n        m_NCXId = m_Book->GetOPF()->AddNCXItem(m_NCXFilePath);\n    }\n\n    // Ensure that our spine has a <spine toc=\"ncx\"> element on it now in case it was missing.\n    m_Book->GetOPF()->UpdateNCXOnSpine(m_NCXId);\n    // Make sure the <item> for the NCX in the manifest reflects correct href path\n    m_Book->GetOPF()->UpdateNCXLocationInManifest(m_Book->GetNCX());\n\n    // If spine was not present or did not contain any items, recreate the OPF from scratch\n    // preserving any important metadata elements and making a new reading order.\n    if (!m_HasSpineItems) {\n        QList<MetaEntry> originalMetadata = m_Book->GetOPF()->GetDCMetadata();\n        m_Book->GetOPF()->AutoFixWellFormedErrors();\n        if (extract_metadata) {\n            m_Book->GetOPF()->SetDCMetadata(originalMetadata);\n        }\n        AddLoadWarning(QObject::tr(\"The OPF file does not contain a valid spine.\") % \"\\n\" %\n                       QObject::tr(\"Sigil has created a new one for you.\"));\n    }\n\n    // If we have modified the book to add spine attribute, manifest item or NCX mark as changed.\n    m_Book->SetModified(GetLoadWarnings().count() > 0);\n    QApplication::restoreOverrideCursor();\n    return m_Book;\n}\n\n\nQHash<QString, QString> ImportEPUB::ParseEncryptionXml()\n{\n    QString encrpytion_xml_path = m_ExtractedFolderPath + \"/META-INF/encryption.xml\";\n\n    if (!QFileInfo(encrpytion_xml_path).exists()) {\n        return QHash<QString, QString>();\n    }\n\n    QXmlStreamReader encryption(Utility::ReadUnicodeTextFile(encrpytion_xml_path));\n    QHash<QString, QString> encrypted_files;\n    QString encryption_algo;\n    QString uri;\n\n    while (!encryption.atEnd()) {\n        encryption.readNext();\n\n        if (encryption.isStartElement()) {\n            if (encryption.name() == \"EncryptionMethod\") {\n                encryption_algo = encryption.attributes().value(\"\", \"Algorithm\").toString();\n            } else if (encryption.name() == \"CipherReference\") {\n                uri = Utility::URLDecodePath(encryption.attributes().value(\"\", \"URI\").toString());\n                encrypted_files[ uri ] = encryption_algo;\n            }\n        }\n    }\n\n    if (encryption.hasError()) {\n        const QString error = QString(QObject::tr(\"Error parsing encryption xml.\\nLine: %1 Column %2 - %3\"))\n                              .arg(encryption.lineNumber())\n                              .arg(encryption.columnNumber())\n                              .arg(encryption.errorString());\n        throw (EPUBLoadParseError(error.toStdString()));\n    }\n\n    return encrypted_files;\n}\n\n\nbool ImportEPUB::BookContentEncrypted(const QHash<QString, QString> &encrypted_files)\n{\n    foreach(QString algorithm, encrypted_files.values()) {\n        if (algorithm != ADOBE_FONT_ALGO_ID &&\n            algorithm != IDPF_FONT_ALGO_ID) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n// This is basically a workaround for old versions of InDesign not listing the fonts it\n// embedded in the OPF manifest, even though the specs say it has to.\n// It does list them in the encryption.xml, so we use that.\nvoid ImportEPUB::AddObfuscatedButUndeclaredFonts(const QHash<QString, QString> &encrypted_files)\n{\n    if (encrypted_files.empty()) {\n        return;\n    }\n\n    QDir opf_dir = QFileInfo(m_OPFFilePath).dir();\n    foreach(QString filepath, encrypted_files.keys()) {\n        if (!FONT_EXTENSIONS.contains(QFileInfo(filepath).suffix().toLower())) {\n            continue;\n        }\n\n        // Only add the path to the manifest if it is not already included.\n        QMapIterator<QString, QString> valueSearch(m_Files);\n\n        if (!valueSearch.findNext(opf_dir.relativeFilePath(filepath))) {\n            m_Files[ Utility::CreateUUID() ] = opf_dir.relativeFilePath(filepath);\n        }\n    }\n}\n\n\n// Another workaround for non-standard Apple files\n// At present it only handles com.apple.ibooks.display-options.xml, but any\n// further iBooks aberrations should be handled here as well.\nvoid ImportEPUB::AddNonStandardAppleXML()\n{\n    QDir opf_dir = QFileInfo(m_OPFFilePath).dir();\n    QStringList aberrant_Apple_filenames;\n    aberrant_Apple_filenames.append(m_ExtractedFolderPath + \"/META-INF/com.apple.ibooks.display-options.xml\");\n\n    for (int i = 0; i < aberrant_Apple_filenames.size(); ++i) {\n        if (QFile::exists(aberrant_Apple_filenames.at(i))) {\n            m_Files[ Utility::CreateUUID() ]  = opf_dir.relativeFilePath(aberrant_Apple_filenames.at(i));\n        }\n    }\n}\n\n\n// Each resource can provide us with its new path. encrypted_files provides\n// a mapping from old resource paths to the obfuscation algorithms.\n// So we use the updates hash which provides a mapping from old paths to new\n// paths to match the resources to their algorithms.\nvoid ImportEPUB::ProcessFontFiles(const QList<Resource *> &resources,\n                                  const QHash<QString, QString> &updates,\n                                  const QHash<QString, QString> &encrypted_files)\n{\n    if (encrypted_files.empty()) {\n        return;\n    }\n\n    QList<FontResource *> font_resources = m_Book->GetFolderKeeper()->GetResourceTypeList<FontResource>();\n\n    if (font_resources.empty()) {\n        return;\n    }\n\n    QHash<QString, QString> new_font_paths_to_algorithms;\n    foreach(QString old_update_path, updates.keys()) {\n        if (!FONT_EXTENSIONS.contains(QFileInfo(old_update_path).suffix().toLower())) {\n            continue;\n        }\n\n        QString new_update_path = updates[ old_update_path ];\n        foreach(QString old_encrypted_path, encrypted_files.keys()) {\n            if (old_update_path == old_encrypted_path) {\n                new_font_paths_to_algorithms[ new_update_path ] = encrypted_files[ old_encrypted_path ];\n            }\n        }\n    }\n    foreach(FontResource * font_resource, font_resources) {\n        QString match_path = \"../\" + font_resource->GetRelativePathToOEBPS();\n        QString algorithm  = new_font_paths_to_algorithms.value(match_path);\n\n        if (algorithm.isEmpty()) {\n            continue;\n        }\n\n        font_resource->SetObfuscationAlgorithm(algorithm);\n\n        // Actually we are de-obfuscating, but the inverse operations of the obfuscation methods\n        // are the obfuscation methods themselves. For the math oriented, the obfuscation methods\n        // are involutary [ f( f( x ) ) = x ].\n        if (algorithm == ADOBE_FONT_ALGO_ID) {\n            FontObfuscation::ObfuscateFile(font_resource->GetFullPath(), algorithm, m_UuidIdentifierValue);\n        } else {\n            FontObfuscation::ObfuscateFile(font_resource->GetFullPath(), algorithm, m_UniqueIdentifierValue);\n        }\n    }\n}\n\nvoid ImportEPUB::ExtractContainer()\n{\n    int res = 0;\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData());\n#endif\n\n    if (zfile == NULL) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot unzip EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n\n\t        // for security reasons against maliciously crafted zip archives\n                // we need the file path to always be inside the target folder \n                // and not outside, so we will remove all illegal backslashes\n                // and all relative upward paths segments \"/../\" from the zip's local \n                // file name/path before prepending the target folder to create \n                // the final path\n\n\t        QString original_path = qfile_name;\n\t        bool evil_or_corrupt_epub = false;\n\n                if (qfile_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n\t        qfile_name = \"/\" + qfile_name.replace(\"\\\\\",\"\");\n\n                if (qfile_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        qfile_name = qfile_name.replace(\"/../\",\"/\");\n\n                while(qfile_name.startsWith(\"/\")) { \n\t\t    qfile_name = qfile_name.remove(0,1);\n\t\t}\n\n                if (cp437_file_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n                cp437_file_name = \"/\" + cp437_file_name.replace(\"\\\\\",\"\");\n\n                if (cp437_file_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        cp437_file_name = cp437_file_name.replace(\"/../\",\"/\");\n\n                while(cp437_file_name.startsWith(\"/\")) { \n\t\t    cp437_file_name = cp437_file_name.remove(0,1);\n\t\t}\n\n                if (evil_or_corrupt_epub) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Possible evil or corrupt epub file name: %1\")).arg(original_path).toStdString()));\n                }\n\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                QDir dir(m_ExtractedFolderPath);\n                // Full file path in the temporary directory.\n                QString file_path = m_ExtractedFolderPath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n\t\t    // add it to the list of files found inside the zip\n\t\t    if (cp437_file_name.isEmpty()) {\n\t\t        m_ZipFilePaths << qfile_name;\n\t\t    } else {\n                        m_ZipFilePaths << cp437_file_name;\n\t\t    }\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = m_ExtractedFolderPath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot open EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    unzClose(zfile);\n}\n\nvoid ImportEPUB::LocateOPF()\n{\n    QString fullpath = m_ExtractedFolderPath + \"/META-INF/container.xml\";\n    QXmlStreamReader container;\n    try {\n        container.addData(Utility::ReadUnicodeTextFile(fullpath));\n    } catch (CannotOpenFile) {\n        // Find the first OPF file.\n        QString OPFfile;\n        QDirIterator files(m_ExtractedFolderPath, QStringList() << \"*.opf\", QDir::NoFilter, QDirIterator::Subdirectories);\n        while (files.hasNext()) {\n            OPFfile = QDir(m_ExtractedFolderPath).relativeFilePath(files.next());\n            break;\n        }\n\n        if (OPFfile.isEmpty()) {\n            std::string msg = fullpath.toStdString() + \": \" + tr(\"Epub has missing or improperly specified OPF.\").toStdString();\n            throw (CannotOpenFile(msg));\n        }\n\n        // Create a default container.xml.\n        QDir folder(m_ExtractedFolderPath);\n        folder.mkdir(\"META-INF\");\n        Utility::WriteUnicodeTextFile(CONTAINER_XML.arg(OPFfile), fullpath);\n        container.addData(Utility::ReadUnicodeTextFile(fullpath));\n    }\n\n    while (!container.atEnd()) {\n        container.readNext();\n\n        if (container.isStartElement() &&\n            container.name() == \"rootfile\"\n           ) {\n            if (container.attributes().hasAttribute(\"media-type\") &&\n                container.attributes().value(\"\", \"media-type\") == OEBPS_MIMETYPE\n               ) {\n                m_OPFFilePath = m_ExtractedFolderPath + \"/\" + container.attributes().value(\"\", \"full-path\").toString();\n                // As per OCF spec, the first rootfile element\n                // with the OEBPS mimetype is considered the \"main\" one.\n                break;\n            }\n        }\n    }\n\n    if (container.hasError()) {\n        const QString error = QString(\n                                  QObject::tr(\"Unable to parse container.xml file.\\nLine: %1 Column %2 - %3\"))\n                              .arg(container.lineNumber())\n                              .arg(container.columnNumber())\n                              .arg(container.errorString());\n        throw (EPUBLoadParseError(error.toStdString()));\n    }\n\n    if (m_OPFFilePath.isEmpty() || !QFile::exists(m_OPFFilePath)) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"No appropriate OPF file found\")).toStdString()));\n    }\n}\n\n\nvoid ImportEPUB::ReadOPF()\n{\n    QString opf_text = CleanSource::ProcessXML(PrepareOPFForReading(Utility::ReadUnicodeTextFile(m_OPFFilePath)),OEBPS_MIMETYPE);\n    QXmlStreamReader opf_reader(opf_text);\n    QString ncx_id_on_spine;\n\n    while (!opf_reader.atEnd()) {\n        opf_reader.readNext();\n\n        if (!opf_reader.isStartElement()) {\n            continue;\n        }\n\n        if (opf_reader.name() == \"package\") {\n            m_UniqueIdentifierId = opf_reader.attributes().value(\"\", \"unique-identifier\").toString();\n            m_PackageVersion = opf_reader.attributes().value(\"\", \"version\").toString();\n            if (m_PackageVersion == \"1.0\") m_PackageVersion = \"2.0\";\n\t}\n\n        else if (opf_reader.name() == \"identifier\") {\n            ReadIdentifierElement(&opf_reader);\n\t}\n\n        // epub3 look for linked metadata resources that are included inside the epub \n        // but that are not and must not be included in the manifest\n        else if (opf_reader.name() == \"link\") {\n            ReadMetadataLinkElement(&opf_reader);\n\t}\n\n        // Get the list of content files that\n        // make up the publication\n        else if (opf_reader.name() == \"item\") {\n            ReadManifestItemElement(&opf_reader);\n        }\n\n        // We read this just to get the NCX id\n        else if (opf_reader.name() == \"spine\") {\n            ncx_id_on_spine = opf_reader.attributes().value(\"\", \"toc\").toString();\n        } \n\n        else if (opf_reader.name() == \"itemref\") {\n            m_HasSpineItems = true;\n        }\n    }\n\n    if (opf_reader.hasError()) {\n        const QString error = QString(QObject::tr(\"Unable to read OPF file.\\nLine: %1 Column %2 - %3\"))\n                              .arg(opf_reader.lineNumber())\n                              .arg(opf_reader.columnNumber())\n                              .arg(opf_reader.errorString());\n        throw (EPUBLoadParseError(error.toStdString()));\n    }\n\n    // Ensure we have an NCX available\n    LocateOrCreateNCX(ncx_id_on_spine);\n\n}\n\n\nvoid ImportEPUB::ReadIdentifierElement(QXmlStreamReader *opf_reader)\n{\n    QString id     = opf_reader->attributes().value(\"\", \"id\").toString();\n    QString scheme = opf_reader->attributes().value(\"\", \"scheme\").toString();\n    QString value  = opf_reader->readElementText();\n\n    if (id == m_UniqueIdentifierId) {\n        m_UniqueIdentifierValue = value;\n    }\n\n    if (m_UuidIdentifierValue.isEmpty() &&\n        (value.contains(\"urn:uuid:\") || scheme.toLower() == \"uuid\")) {\n        m_UuidIdentifierValue = value;\n    }\n}\n\nvoid ImportEPUB::ReadMetadataLinkElement(QXmlStreamReader *opf_reader)\n{\n    QString relation = opf_reader->attributes().value(\"\", \"rel\").toString();\n    QString mtype = opf_reader->attributes().value(\"\", \"media-type\").toString();\n    QString props = opf_reader->attributes().value(\"\", \"properties\").toString();\n    QString href = opf_reader->attributes().value(\"\", \"href\").toString();\n    if (!href.isEmpty()) {\n        QUrl url = QUrl(href);\n        if (url.isRelative()) {\n\t    // we have a local unmanifested metadata file to handle\n\t    // attempt to map deprecated record types into proper media-types\n\t    if (relation == \"marc21xml-record\") {\n                mtype = \"application/marcxml+xml\";\n\t    }\n\t    else if (relation == \"mods-record\") {\n                mtype = \"application/mods+xml\";\n\t    }\n\t    else if (relation == \"onix-record\") {\n                mtype = \"application/xml;onix\";\n            }\n\t    else if (relation == \"xmp-record\") {\n                mtype = \"application/xml;xmp\";\n\t    }\n            else if (relation == \"record\") {\n                if (props == \"onix\") mtype = \"application/xml;onix\";\n                if (props == \"xmp\") mtype = \"application/xml;xmp\";\n\t    }\n            QDir opf_dir = QFileInfo(m_OPFFilePath).dir();\n\t    QString path = opf_dir.absolutePath() + \"/\" + url.path();\n\t    if (QFile::exists(path)) {\n\t        QString id = Utility::CreateUUID();\n\t\tm_Files[ id ]  = opf_dir.relativeFilePath(path);\n\t\tm_FileMimetypes[ id ] = mtype;\n\t    }\n\t}\n    }\n}\n\nvoid ImportEPUB::ReadManifestItemElement(QXmlStreamReader *opf_reader)\n{\n    QString id   = opf_reader->attributes().value(\"\", \"id\").toString();\n    QString href = opf_reader->attributes().value(\"\", \"href\").toString();\n    QString type = opf_reader->attributes().value(\"\", \"media-type\").toString();\n    QString properties = opf_reader->attributes().value(\"\", \"properties\").toString();\n    // Paths are percent encoded in the OPF, we use \"normal\" paths internally.\n    href = Utility::URLDecodePath(href);\n    QString extension = QFileInfo(href).suffix().toLower();\n\n    // find the epub root relative file path from the opf location and the item href\n    QString file_path = m_opfDir.absolutePath() + \"/\" + href;\n    file_path = file_path.remove(0, m_ExtractedFolderPath.length() + 1); \n    \n    if (type != NCX_MIMETYPE && extension != NCX_EXTENSION) {\n        if (!m_ManifestFilePaths.contains(file_path)) {\n            if (m_Files.contains(id)) {\n                // We have an error situation with a duplicate id in the epub.\n                // We must warn the user, but attempt to use another id so the epub can still be loaded.\n                QString base_id = QFileInfo(href).fileName();\n                QString new_id(base_id);\n                int duplicate_index = 0;\n\n                while (m_Files.contains(new_id)) {\n                    duplicate_index++;\n                    new_id = QString(\"%1%2\").arg(base_id).arg(duplicate_index);\n                }\n\n                const QString load_warning = QObject::tr(\"The OPF manifest contains duplicate ids for: %1\").arg(id) +\n                  \" - \" + QObject::tr(\"A temporary id has been assigned to load this EPUB. You should edit your OPF file to remove the duplication.\");\n                id = new_id;\n                AddLoadWarning(load_warning);\n            }\n\n            m_Files[ id ] = href;\n            m_FileMimetypes[ id ] = type;\n            m_ManifestFilePaths << file_path;\n\n            // store information about any nav document\n            if (properties.contains(\"nav\")) {\n                m_NavId = id;\n                m_NavHref = href;\n            }\n        }\n    } else {\n        m_NcxCandidates[ id ] = href;\n\tm_ManifestFilePaths << file_path;\n    }\n}\n\n\nvoid ImportEPUB::LocateOrCreateNCX(const QString &ncx_id_on_spine)\n{\n    QString load_warning;\n    QString ncx_href = \"not_found\";\n    m_NCXId = ncx_id_on_spine;\n\n    // Handle various failure conditions, such as:\n    // - ncx not specified in the spine (search for a matching manifest item by extension)\n    // - ncx specified in spine, but no matching manifest item entry (create a new one)\n    // - ncx file not physically present (create a new one)\n    // - ncx not in spine or manifest item (create a new one)\n    if (!m_NCXId.isEmpty()) {\n        ncx_href = m_NcxCandidates[ m_NCXId ];\n    } else {\n        // Search for the ncx in the manifest by looking for files with\n        // a .ncx extension.\n        QHashIterator<QString, QString> ncxSearch(m_NcxCandidates);\n\n        while (ncxSearch.hasNext()) {\n            ncxSearch.next();\n\n            if (QFileInfo(ncxSearch.value()).suffix().toLower() == NCX_EXTENSION) {\n                m_NCXId = ncxSearch.key();\n                load_warning = QObject::tr(\"The OPF file did not identify the NCX file correctly.\") + \"\\n\" + \n                               \" - \"  +  QObject::tr(\"Sigil has used the following file as the NCX:\") + \n                               QString(\" %1\").arg(m_NcxCandidates[ m_NCXId ]);\n                ncx_href = m_NcxCandidates[ m_NCXId ];\n                break;\n            }\n        }\n    }\n\n    m_NCXFilePath = QFileInfo(m_OPFFilePath).absolutePath() % \"/\" % ncx_href;\n\n    if (ncx_href.isEmpty() || !QFile::exists(m_NCXFilePath)) {\n        m_NCXNotInManifest = m_NCXId.isEmpty() || ncx_href.isEmpty();\n        m_NCXId.clear();\n        // Things are really bad and no .ncx file was found in the manifest or\n        // the file does not physically exist.  We need to create a new one.\n        m_NCXFilePath = QFileInfo(m_OPFFilePath).absolutePath() % \"/\" % NCX_FILE_NAME;\n        // Create a new file for the NCX.\n        NCXResource ncx_resource(m_ExtractedFolderPath, m_NCXFilePath, m_Book->GetFolderKeeper());\n\n        // We are relying on an identifier being set from the metadata.\n        // It might not have one if the book does not have the urn:uuid: format.\n        if (!m_UuidIdentifierValue.isEmpty()) {\n            ncx_resource.SetMainID(m_UuidIdentifierValue);\n        }\n\n        ncx_resource.SaveToDisk();\n\n        if (m_PackageVersion.startsWith('3')) { \n            load_warning = QObject::tr(\"Sigil has created a template NCX\") + \"\\n\" + \n              QObject::tr(\"to support epub2 backwards compatibility.\");\n        } else {\n            if (ncx_href.isEmpty()) {\n                load_warning = QObject::tr(\"The OPF file does not contain an NCX file.\") + \"\\n\" + \n                               \" - \" +  QObject::tr(\"Sigil has created a new one for you.\");\n            } else {\n                load_warning = QObject::tr(\"The NCX file is not present in this EPUB.\") + \"\\n\" + \n                               \" - \" + QObject::tr(\"Sigil has created a new one for you.\");\n            }\n        }\n    }\n\n    if (!load_warning.isEmpty()) {\n        AddLoadWarning(load_warning);\n    }\n}\n\n\nvoid ImportEPUB::LoadInfrastructureFiles()\n{\n    // always SetEpubVersion before SetText in OPF as SetText will validate with it\n    m_Book->GetOPF()->SetEpubVersion(m_PackageVersion);\n    m_Book->GetOPF()->SetText(CleanSource::ProcessXML(PrepareOPFForReading(Utility::ReadUnicodeTextFile(m_OPFFilePath)),OEBPS_MIMETYPE));\n    QString OPFBookRelPath = m_OPFFilePath;\n    OPFBookRelPath = OPFBookRelPath.remove(0,m_ExtractedFolderPath.length()+1);\n    m_Book->GetOPF()->SetCurrentBookRelPath(OPFBookRelPath);\n\n    m_Book->GetNCX()->SetText(CleanSource::ProcessXML(Utility::ReadUnicodeTextFile(m_NCXFilePath),\"application/x-dtbncx+xml\"));\n    m_Book->GetNCX()->SetEpubVersion(m_PackageVersion);\n    QString NCXBookRelPath = m_NCXFilePath;\n    NCXBookRelPath = NCXBookRelPath.remove(0,m_ExtractedFolderPath.length()+1);\n    m_Book->GetNCX()->SetCurrentBookRelPath(NCXBookRelPath);\n}\n\n\nQHash<QString, QString> ImportEPUB::LoadFolderStructure()\n{\n    QList<QString> keys = m_Files.keys();\n    int num_files = keys.count();\n    QFutureSynchronizer<std::tuple<QString, QString>> sync;\n\n    for (int i = 0; i < num_files; ++i) {\n        QString id = keys.at(i);\n        sync.addFuture(QtConcurrent::run(\n                           this,\n                           &ImportEPUB::LoadOneFile,\n                           m_Files.value(id),\n                           m_FileMimetypes.value(id)));\n    }\n\n    sync.waitForFinished();\n    QList<QFuture<std::tuple<QString, QString>>> futures = sync.futures();\n    int num_futures = futures.count();\n    QHash<QString, QString> updates;\n\n    for (int i = 0; i < num_futures; ++i) {\n        std::tuple<QString, QString> result = futures.at(i).result();\n        updates[std::get<0>(result)] = std::get<1>(result);\n    }\n\n    updates.remove(UPDATE_ERROR_STRING);\n    return updates;\n}\n\n\nstd::tuple<QString, QString> ImportEPUB::LoadOneFile(const QString &path, const QString &mimetype)\n{\n    QString fullfilepath = QDir::cleanPath(QFileInfo(m_OPFFilePath).absolutePath() + \"/\" + path);\n    QString currentpath = fullfilepath;\n    currentpath = currentpath.remove(0,m_ExtractedFolderPath.length()+1);\n    try {\n        Resource *resource = m_Book->GetFolderKeeper()->AddContentFileToFolder(fullfilepath, false, mimetype);\n        if (path == m_NavHref) {\n            m_NavResource = resource;\n        }\n        resource->SetCurrentBookRelPath(currentpath);\n        QString newpath = \"../\" + resource->GetRelativePathToOEBPS();\n        return std::make_tuple(currentpath, newpath);\n    } catch (FileDoesNotExist) {\n        return std::make_tuple(UPDATE_ERROR_STRING, UPDATE_ERROR_STRING);\n    }\n}\n\n\nQString ImportEPUB::PrepareOPFForReading(const QString &source)\n{\n    QString source_copy(source);\n    QString prefix = source_copy.left(XML_DECLARATION_SEARCH_PREFIX_SIZE);\n    QRegularExpression version(VERSION_ATTRIBUTE);\n    QRegularExpressionMatch mo = version.match(prefix);\n    if (mo.hasMatch()) {\n        // MASSIVE hack for XML 1.1 \"support\";\n        // this is only for people who specify\n        // XML 1.1 when they actually only use XML 1.0\n        source_copy.replace(mo.capturedStart(1), mo.capturedLength(1), \"1.0\");\n    }\n    return source_copy;\n}\n"], "filenames": ["src/Importers/ImportEPUB.cpp"], "buggy_code_start_loc": [428], "buggy_code_end_loc": [434], "fixing_code_start_loc": [428], "fixing_code_end_loc": [463], "type": "CWE-22", "message": "Sigil before 0.9.16 is vulnerable to a directory traversal, allowing attackers to write arbitrary files via a ../ (dot dot slash) in a ZIP archive entry that is mishandled during extraction.", "other": {"cve": {"id": "CVE-2019-14452", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-31T02:15:10.977", "lastModified": "2019-08-05T22:15:11.407", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Sigil before 0.9.16 is vulnerable to a directory traversal, allowing attackers to write arbitrary files via a ../ (dot dot slash) in a ZIP archive entry that is mishandled during extraction."}, {"lang": "es", "value": "Sigil anterior a versi\u00f3n 0.9.16, es vulnerable a un salto de directorio, permitiendo a los atacantes escribir archivos arbitrarios por medio de un ../ (punto punto barra) en una entrada de archivo ZIP que es manejada inapropiadamente durante la extracci\u00f3n."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sigil-ebook:sigil:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.16", "matchCriteriaId": "32D6FADF-0530-42A9-81BA-E2A317470262"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flightcrew_project:flightcrew:*:*:*:*:*:sigil:*:*", "versionStartIncluding": "0.9.2", "matchCriteriaId": "3AF7EB27-3012-465F-A35E-D7214E6548A0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}], "references": [{"url": "https://github.com/Sigil-Ebook/Sigil/commit/04e2f280cc4a0766bedcc7b9eb56449ceecc2ad4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Sigil-Ebook/Sigil/commit/0979ba8d10c96ebca330715bfd4494ea0e019a8f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Sigil-Ebook/Sigil/commit/369eebe936e4a8c83cc54662a3412ce8bef189e4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Sigil-Ebook/Sigil/compare/ea7f27d...5b867e5", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Sigil-Ebook/Sigil/releases/tag/0.9.16", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/Sigil-Ebook/flightcrew/issues/52#issuecomment-505967936", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Sigil-Ebook/flightcrew/issues/52#issuecomment-505997355", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://salvatoresecurity.com/zip-slip-in-sigil-cve-2019-14452/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4085-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Sigil-Ebook/Sigil/commit/04e2f280cc4a0766bedcc7b9eb56449ceecc2ad4"}}