{"buggy_code": ["/**\n * @file\n * POP network mailbox\n *\n * @authors\n * Copyright (C) 2000-2002 Vsevolod Volkov <vvv@mutt.org.ua>\n * Copyright (C) 2006-2007,2009 Rocco Rutte <pdmef@gmx.net>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page pop POP network mailbox\n *\n * POP network mailbox\n */\n\n#include \"config.h\"\n#include <errno.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"pop.h\"\n#include \"bcache.h\"\n#include \"body.h\"\n#include \"context.h\"\n#include \"envelope.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"mailbox.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"ncrypt/ncrypt.h\"\n#include \"options.h\"\n#include \"progress.h\"\n#include \"protos.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\n#ifdef USE_HCACHE\n#define HC_FNAME \"neomutt\" /* filename for hcache as POP lacks paths */\n#define HC_FEXT \"hcache\"   /* extension for hcache as POP lacks paths */\n#endif\n\n/**\n * cache_id - Make a message-cache-compatible id\n * @param id POP message id\n * @retval ptr Sanitised string\n *\n * The POP message id may contain '/' and other awkward characters.\n *\n * @note This function returns a pointer to a static buffer.\n */\nstatic const char *cache_id(const char *id)\n{\n  static char clean[SHORT_STRING];\n  mutt_str_strfcpy(clean, id, sizeof(clean));\n  mutt_file_sanitize_filename(clean, true);\n  return clean;\n}\n\n/**\n * fetch_message - write line to file\n * @param line String to write\n * @param file FILE pointer to write to\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int fetch_message(char *line, void *file)\n{\n  FILE *f = (FILE *) file;\n\n  fputs(line, f);\n  if (fputc('\\n', f) == EOF)\n    return -1;\n\n  return 0;\n}\n\n/**\n * pop_read_header - Read header\n * @param pop_data POP data\n * @param h        Email header\n * @retval  0 Success\n * @retval -1 Connection lost\n * @retval -2 Invalid command or execution error\n * @retval -3 Error writing to tempfile\n */\nstatic int pop_read_header(struct PopData *pop_data, struct Header *h)\n{\n  int rc, index;\n  size_t length;\n  char buf[LONG_STRING];\n\n  FILE *f = mutt_file_mkstemp();\n  if (!f)\n  {\n    mutt_perror(\"mutt_file_mkstemp failed!\");\n    return -3;\n  }\n\n  snprintf(buf, sizeof(buf), \"LIST %d\\r\\n\", h->refno);\n  rc = pop_query(pop_data, buf, sizeof(buf));\n  if (rc == 0)\n  {\n    sscanf(buf, \"+OK %d %zu\", &index, &length);\n\n    snprintf(buf, sizeof(buf), \"TOP %d 0\\r\\n\", h->refno);\n    rc = pop_fetch_data(pop_data, buf, NULL, fetch_message, f);\n\n    if (pop_data->cmd_top == 2)\n    {\n      if (rc == 0)\n      {\n        pop_data->cmd_top = 1;\n\n        mutt_debug(1, \"set TOP capability\\n\");\n      }\n\n      if (rc == -2)\n      {\n        pop_data->cmd_top = 0;\n\n        mutt_debug(1, \"unset TOP capability\\n\");\n        snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), \"%s\",\n                 _(\"Command TOP is not supported by server.\"));\n      }\n    }\n  }\n\n  switch (rc)\n  {\n    case 0:\n    {\n      rewind(f);\n      h->env = mutt_rfc822_read_header(f, h, 0, 0);\n      h->content->length = length - h->content->offset + 1;\n      rewind(f);\n      while (!feof(f))\n      {\n        h->content->length--;\n        fgets(buf, sizeof(buf), f);\n      }\n      break;\n    }\n    case -2:\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      break;\n    }\n    case -3:\n    {\n      mutt_error(_(\"Can't write header to temporary file!\"));\n      break;\n    }\n  }\n\n  mutt_file_fclose(&f);\n  return rc;\n}\n\n/**\n * fetch_uidl - parse UIDL\n * @param line String to parse\n * @param data Mailbox Context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int fetch_uidl(char *line, void *data)\n{\n  int i, index;\n  struct Context *ctx = (struct Context *) data;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  char *endp = NULL;\n\n  errno = 0;\n  index = strtol(line, &endp, 10);\n  if (errno)\n    return -1;\n  while (*endp == ' ')\n    endp++;\n  memmove(line, endp, strlen(endp) + 1);\n\n  for (i = 0; i < ctx->msgcount; i++)\n    if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)\n      break;\n\n  if (i == ctx->msgcount)\n  {\n    mutt_debug(1, \"new header %d %s\\n\", index, line);\n\n    if (i >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n\n    ctx->msgcount++;\n    ctx->hdrs[i] = mutt_header_new();\n    ctx->hdrs[i]->data = mutt_str_strdup(line);\n  }\n  else if (ctx->hdrs[i]->index != index - 1)\n    pop_data->clear_cache = true;\n\n  ctx->hdrs[i]->refno = index;\n  ctx->hdrs[i]->index = index - 1;\n\n  return 0;\n}\n\n/**\n * msg_cache_check - Check the Body Cache for an ID\n * @param id     Cache ID\n * @param bcache Body cache\n * @param data   Mailbox Context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n{\n  struct Context *ctx = (struct Context *) data;\n  if (!ctx)\n    return -1;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  if (!pop_data)\n    return -1;\n\n#ifdef USE_HCACHE\n  /* keep hcache file if hcache == bcache */\n  if (strcmp(HC_FNAME \".\" HC_FEXT, id) == 0)\n    return 0;\n#endif\n\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    /* if the id we get is known for a header: done (i.e. keep in cache) */\n    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))\n      return 0;\n  }\n\n  /* message not found in context -> remove it from cache\n   * return the result of bcache, so we stop upon its first error\n   */\n  return mutt_bcache_del(bcache, cache_id(id));\n}\n\n#ifdef USE_HCACHE\n/**\n * pop_hcache_namer - Create a header cache filename for a POP mailbox\n * @param path    Path of mailbox\n * @param dest    Buffer for filename\n * @param destlen Length of buffer\n * @retval num Characters written to buffer\n */\nstatic int pop_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  return snprintf(dest, destlen, \"%s.\" HC_FEXT, path);\n}\n\n/**\n * pop_hcache_open - Open the header cache\n * @param pop_data POP server data\n * @param path     Path to the mailbox\n * @retval ptr Header cache\n */\nstatic header_cache_t *pop_hcache_open(struct PopData *pop_data, const char *path)\n{\n  struct Url url;\n  char p[LONG_STRING];\n\n  if (!pop_data || !pop_data->conn)\n    return mutt_hcache_open(HeaderCache, path, NULL);\n\n  mutt_account_tourl(&pop_data->conn->account, &url);\n  url.path = HC_FNAME;\n  url_tostring(&url, p, sizeof(p), U_PATH);\n  return mutt_hcache_open(HeaderCache, p, pop_hcache_namer);\n}\n#endif\n\n/**\n * pop_fetch_headers - Read headers\n * @param ctx Context\n * @retval  0 Success\n * @retval -1 Connection lost\n * @retval -2 Invalid command or execution error\n * @retval -3 Error writing to tempfile\n */\nstatic int pop_fetch_headers(struct Context *ctx)\n{\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n\n#ifdef USE_HCACHE\n  header_cache_t *hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n\n  time(&pop_data->check_time);\n  pop_data->clear_cache = false;\n\n  for (int i = 0; i < ctx->msgcount; i++)\n    ctx->hdrs[i]->refno = -1;\n\n  const int old_count = ctx->msgcount;\n  int ret = pop_fetch_data(pop_data, \"UIDL\\r\\n\", NULL, fetch_uidl, ctx);\n  const int new_count = ctx->msgcount;\n  ctx->msgcount = old_count;\n\n  if (pop_data->cmd_uidl == 2)\n  {\n    if (ret == 0)\n    {\n      pop_data->cmd_uidl = 1;\n\n      mutt_debug(1, \"set UIDL capability\\n\");\n    }\n\n    if (ret == -2 && pop_data->cmd_uidl == 2)\n    {\n      pop_data->cmd_uidl = 0;\n\n      mutt_debug(1, \"unset UIDL capability\\n\");\n      snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), \"%s\",\n               _(\"Command UIDL is not supported by server.\"));\n    }\n  }\n\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);\n  }\n\n  if (ret == 0)\n  {\n    int i, deleted;\n    for (i = 0, deleted = 0; i < old_count; i++)\n    {\n      if (ctx->hdrs[i]->refno == -1)\n      {\n        ctx->hdrs[i]->deleted = true;\n        deleted++;\n      }\n    }\n    if (deleted > 0)\n    {\n      mutt_error(\n          ngettext(\"%d message has been lost. Try reopening the mailbox.\",\n                   \"%d messages have been lost. Try reopening the mailbox.\", deleted),\n          deleted);\n    }\n\n    bool hcached = false;\n    for (i = old_count; i < new_count; i++)\n    {\n      if (!ctx->quiet)\n        mutt_progress_update(&progress, i + 1 - old_count, -1);\n#ifdef USE_HCACHE\n      void *data = mutt_hcache_fetch(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n      if (data)\n      {\n        char *uidl = mutt_str_strdup(ctx->hdrs[i]->data);\n        int refno = ctx->hdrs[i]->refno;\n        int index = ctx->hdrs[i]->index;\n        /*\n         * - POP dynamically numbers headers and relies on h->refno\n         *   to map messages; so restore header and overwrite restored\n         *   refno with current refno, same for index\n         * - h->data needs to a separate pointer as it's driver-specific\n         *   data freed separately elsewhere\n         *   (the old h->data should point inside a malloc'd block from\n         *   hcache so there shouldn't be a memleak here)\n         */\n        struct Header *h = mutt_hcache_restore((unsigned char *) data);\n        mutt_hcache_free(hc, &data);\n        mutt_header_free(&ctx->hdrs[i]);\n        ctx->hdrs[i] = h;\n        ctx->hdrs[i]->refno = refno;\n        ctx->hdrs[i]->index = index;\n        ctx->hdrs[i]->data = uidl;\n        ret = 0;\n        hcached = true;\n      }\n      else\n#endif\n          if ((ret = pop_read_header(pop_data, ctx->hdrs[i])) < 0)\n        break;\n#ifdef USE_HCACHE\n      else\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n\n      /*\n       * faked support for flags works like this:\n       * - if 'hcached' is true, we have the message in our hcache:\n       *        - if we also have a body: read\n       *        - if we don't have a body: old\n       *          (if $mark_old is set which is maybe wrong as\n       *          $mark_old should be considered for syncing the\n       *          folder and not when opening it XXX)\n       * - if 'hcached' is false, we don't have the message in our hcache:\n       *        - if we also have a body: read\n       *        - if we don't have a body: new\n       */\n      const bool bcached =\n          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);\n      ctx->hdrs[i]->old = false;\n      ctx->hdrs[i]->read = false;\n      if (hcached)\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n        else if (MarkOld)\n          ctx->hdrs[i]->old = true;\n      }\n      else\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n      }\n\n      ctx->msgcount++;\n    }\n\n    if (i > old_count)\n      mx_update_context(ctx, i - old_count);\n  }\n\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n\n  if (ret < 0)\n  {\n    for (int i = ctx->msgcount; i < new_count; i++)\n      mutt_header_free(&ctx->hdrs[i]);\n    return ret;\n  }\n\n  /* after putting the result into our structures,\n   * clean up cache, i.e. wipe messages deleted outside\n   * the availability of our cache\n   */\n  if (MessageCacheClean)\n    mutt_bcache_list(pop_data->bcache, msg_cache_check, (void *) ctx);\n\n  mutt_clear_error();\n  return (new_count - old_count);\n}\n\n/**\n * pop_open_mailbox - open POP mailbox, fetch only headers\n * @param ctx Mailbox Context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_open_mailbox(struct Context *ctx)\n{\n  char buf[PATH_MAX];\n  struct Connection *conn = NULL;\n  struct Account acct;\n  struct PopData *pop_data = NULL;\n  struct Url url;\n\n  if (pop_parse_path(ctx->path, &acct))\n  {\n    mutt_error(_(\"%s is an invalid POP path\"), ctx->path);\n    return -1;\n  }\n\n  mutt_account_tourl(&acct, &url);\n  url.path = NULL;\n  url_tostring(&url, buf, sizeof(buf), 0);\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return -1;\n\n  FREE(&ctx->path);\n  FREE(&ctx->realpath);\n  ctx->path = mutt_str_strdup(buf);\n  ctx->realpath = mutt_str_strdup(ctx->path);\n\n  pop_data = mutt_mem_calloc(1, sizeof(struct PopData));\n  pop_data->conn = conn;\n  ctx->data = pop_data;\n\n  if (pop_open_connection(pop_data) < 0)\n    return -1;\n\n  conn->data = pop_data;\n  pop_data->bcache = mutt_bcache_open(&acct, NULL);\n\n  /* init (hard-coded) ACL rights */\n  memset(ctx->rights, 0, sizeof(ctx->rights));\n  mutt_bit_set(ctx->rights, MUTT_ACL_SEEN);\n  mutt_bit_set(ctx->rights, MUTT_ACL_DELETE);\n#ifdef USE_HCACHE\n  /* flags are managed using header cache, so it only makes sense to\n   * enable them in that case */\n  mutt_bit_set(ctx->rights, MUTT_ACL_WRITE);\n#endif\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    ctx->size = pop_data->size;\n\n    mutt_message(_(\"Fetching list of messages...\"));\n\n    const int ret = pop_fetch_headers(ctx);\n\n    if (ret >= 0)\n      return 0;\n\n    if (ret < -1)\n    {\n      mutt_sleep(2);\n      return -1;\n    }\n  }\n}\n\n/**\n * pop_clear_cache - delete all cached messages\n * @param pop_data POP server data\n */\nstatic void pop_clear_cache(struct PopData *pop_data)\n{\n  if (!pop_data->clear_cache)\n    return;\n\n  mutt_debug(1, \"delete cached messages\\n\");\n\n  for (int i = 0; i < POP_CACHE_LEN; i++)\n  {\n    if (pop_data->cache[i].path)\n    {\n      unlink(pop_data->cache[i].path);\n      FREE(&pop_data->cache[i].path);\n    }\n  }\n}\n\n/**\n * pop_close_mailbox - close POP mailbox\n * @param ctx Mailbox Context\n * @retval 0 Always\n */\nstatic int pop_close_mailbox(struct Context *ctx)\n{\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n\n  if (!pop_data)\n    return 0;\n\n  pop_logout(ctx);\n\n  if (pop_data->status != POP_NONE)\n    mutt_socket_close(pop_data->conn);\n\n  pop_data->status = POP_NONE;\n\n  pop_data->clear_cache = true;\n  pop_clear_cache(pop_data);\n\n  if (!pop_data->conn->data)\n    mutt_socket_free(pop_data->conn);\n\n  mutt_bcache_close(&pop_data->bcache);\n\n  return 0;\n}\n\n/**\n * pop_fetch_message - fetch message from POP server\n * @param ctx   Mailbox Context\n * @param msg   Message\n * @param msgno Message number\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno)\n{\n  void *uidl = NULL;\n  char buf[LONG_STRING];\n  char path[PATH_MAX];\n  struct Progress progressbar;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct PopCache *cache = NULL;\n  struct Header *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  /* see if we already have the message in body cache */\n  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));\n  if (msg->fp)\n    return 0;\n\n  /*\n   * see if we already have the message in our cache in\n   * case $message_cachedir is unset\n   */\n  cache = &pop_data->cache[h->index % POP_CACHE_LEN];\n\n  if (cache->path)\n  {\n    if (cache->index == h->index)\n    {\n      /* yes, so just return a pointer to the message */\n      msg->fp = fopen(cache->path, \"r\");\n      if (msg->fp)\n        return 0;\n\n      mutt_perror(cache->path);\n      return -1;\n    }\n    else\n    {\n      /* clear the previous entry */\n      unlink(cache->path);\n      FREE(&cache->path);\n    }\n  }\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    /* verify that massage index is correct */\n    if (h->refno < 0)\n    {\n      mutt_error(\n          _(\"The message index is incorrect. Try reopening the mailbox.\"));\n      return -1;\n    }\n\n    mutt_progress_init(&progressbar, _(\"Fetching message...\"), MUTT_PROGRESS_SIZE,\n                       NetInc, h->content->length + h->content->offset - 1);\n\n    /* see if we can put in body cache; use our cache as fallback */\n    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));\n    if (!msg->fp)\n    {\n      /* no */\n      bcache = 0;\n      mutt_mktemp(path, sizeof(path));\n      msg->fp = mutt_file_fopen(path, \"w+\");\n      if (!msg->fp)\n      {\n        mutt_perror(path);\n        return -1;\n      }\n    }\n\n    snprintf(buf, sizeof(buf), \"RETR %d\\r\\n\", h->refno);\n\n    const int ret = pop_fetch_data(pop_data, buf, &progressbar, fetch_message, msg->fp);\n    if (ret == 0)\n      break;\n\n    mutt_file_fclose(&msg->fp);\n\n    /* if RETR failed (e.g. connection closed), be sure to remove either\n     * the file in bcache or from POP's own cache since the next iteration\n     * of the loop will re-attempt to put() the message */\n    if (!bcache)\n      unlink(path);\n\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n\n    if (ret == -3)\n    {\n      mutt_error(_(\"Can't write message to temporary file!\"));\n      return -1;\n    }\n  }\n\n  /* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   */\n  if (bcache)\n    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));\n  else\n  {\n    cache->index = h->index;\n    cache->path = mutt_str_strdup(path);\n  }\n  rewind(msg->fp);\n  uidl = h->data;\n\n  /* we replace envelop, key in subj_hash has to be updated as well */\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_delete(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_remove(ctx, h);\n  mutt_env_free(&h->env);\n  h->env = mutt_rfc822_read_header(msg->fp, h, 0, 0);\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_insert(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_add(ctx, h);\n\n  h->data = uidl;\n  h->lines = 0;\n  fgets(buf, sizeof(buf), msg->fp);\n  while (!feof(msg->fp))\n  {\n    ctx->hdrs[msgno]->lines++;\n    fgets(buf, sizeof(buf), msg->fp);\n  }\n\n  h->content->length = ftello(msg->fp) - h->content->offset;\n\n  /* This needs to be done in case this is a multipart message */\n  if (!WithCrypto)\n    h->security = crypt_query(h->content);\n\n  mutt_clear_error();\n  rewind(msg->fp);\n\n  return 0;\n}\n\n/**\n * pop_close_message - Close POP Message\n * @param ctx Mailbox Context\n * @param msg Message\n * @retval 0   Success\n * @retval EOF Error, see errno\n */\nstatic int pop_close_message(struct Context *ctx, struct Message *msg)\n{\n  return mutt_file_fclose(&msg->fp);\n}\n\n/**\n * pop_sync_mailbox - update POP mailbox, delete messages from server\n * @param ctx        Mailbox Context\n * @param index_hint Current Message\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n{\n  int i, j, ret = 0;\n  char buf[LONG_STRING];\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n#endif\n\n  pop_data->check_time = 0;\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    mutt_progress_init(&progress, _(\"Marking messages deleted...\"),\n                       MUTT_PROGRESS_MSG, WriteInc, ctx->deleted);\n\n#ifdef USE_HCACHE\n    hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n\n    for (i = 0, j = 0, ret = 0; ret == 0 && i < ctx->msgcount; i++)\n    {\n      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)\n      {\n        j++;\n        if (!ctx->quiet)\n          mutt_progress_update(&progress, j, -1);\n        snprintf(buf, sizeof(buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n        ret = pop_query(pop_data, buf, sizeof(buf));\n        if (ret == 0)\n        {\n          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n#ifdef USE_HCACHE\n          mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n#endif\n        }\n      }\n\n#ifdef USE_HCACHE\n      if (ctx->hdrs[i]->changed)\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n    }\n\n#ifdef USE_HCACHE\n    mutt_hcache_close(hc);\n#endif\n\n    if (ret == 0)\n    {\n      mutt_str_strfcpy(buf, \"QUIT\\r\\n\", sizeof(buf));\n      ret = pop_query(pop_data, buf, sizeof(buf));\n    }\n\n    if (ret == 0)\n    {\n      pop_data->clear_cache = true;\n      pop_clear_cache(pop_data);\n      pop_data->status = POP_DISCONNECTED;\n      return 0;\n    }\n\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n  }\n}\n\n/**\n * pop_check_mailbox - Check for new messages and fetch headers\n * @param ctx        Mailbox Context\n * @param index_hint Current Message\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_check_mailbox(struct Context *ctx, int *index_hint)\n{\n  int ret;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n\n  if ((pop_data->check_time + PopCheckinterval) > time(NULL))\n    return 0;\n\n  pop_logout(ctx);\n\n  mutt_socket_close(pop_data->conn);\n\n  if (pop_open_connection(pop_data) < 0)\n    return -1;\n\n  ctx->size = pop_data->size;\n\n  mutt_message(_(\"Checking for new messages...\"));\n\n  ret = pop_fetch_headers(ctx);\n  pop_clear_cache(pop_data);\n\n  if (ret < 0)\n    return -1;\n\n  if (ret > 0)\n    return MUTT_NEW_MAIL;\n\n  return 0;\n}\n\n/**\n * pop_fetch_mail - Fetch messages and save them in $spoolfile\n */\nvoid pop_fetch_mail(void)\n{\n  char buffer[LONG_STRING];\n  char msgbuf[SHORT_STRING];\n  char *url = NULL, *p = NULL;\n  int delanswer, last = 0, msgs, bytes, rset = 0, ret;\n  struct Connection *conn = NULL;\n  struct Context ctx;\n  struct Message *msg = NULL;\n  struct Account acct;\n  struct PopData *pop_data = NULL;\n\n  if (!PopHost)\n  {\n    mutt_error(_(\"POP host is not defined.\"));\n    return;\n  }\n\n  url = p = mutt_mem_calloc(strlen(PopHost) + 7, sizeof(char));\n  if (url_check_scheme(PopHost) == U_UNKNOWN)\n  {\n    strcpy(url, \"pop://\");\n    p = strchr(url, '\\0');\n  }\n  strcpy(p, PopHost);\n\n  ret = pop_parse_path(url, &acct);\n  FREE(&url);\n  if (ret)\n  {\n    mutt_error(_(\"%s is an invalid POP path\"), PopHost);\n    return;\n  }\n\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return;\n\n  pop_data = mutt_mem_calloc(1, sizeof(struct PopData));\n  pop_data->conn = conn;\n\n  if (pop_open_connection(pop_data) < 0)\n  {\n    mutt_socket_free(pop_data->conn);\n    FREE(&pop_data);\n    return;\n  }\n\n  conn->data = pop_data;\n\n  mutt_message(_(\"Checking for new messages...\"));\n\n  /* find out how many messages are in the mailbox. */\n  mutt_str_strfcpy(buffer, \"STAT\\r\\n\", sizeof(buffer));\n  ret = pop_query(pop_data, buffer, sizeof(buffer));\n  if (ret == -1)\n    goto fail;\n  if (ret == -2)\n  {\n    mutt_error(\"%s\", pop_data->err_msg);\n    goto finish;\n  }\n\n  sscanf(buffer, \"+OK %d %d\", &msgs, &bytes);\n\n  /* only get unread messages */\n  if (msgs > 0 && PopLast)\n  {\n    mutt_str_strfcpy(buffer, \"LAST\\r\\n\", sizeof(buffer));\n    ret = pop_query(pop_data, buffer, sizeof(buffer));\n    if (ret == -1)\n      goto fail;\n    if (ret == 0)\n      sscanf(buffer, \"+OK %d\", &last);\n  }\n\n  if (msgs <= last)\n  {\n    mutt_message(_(\"No new mail in POP mailbox.\"));\n    goto finish;\n  }\n\n  if (mx_mbox_open(NONULL(Spoolfile), MUTT_APPEND, &ctx) == NULL)\n    goto finish;\n\n  delanswer = query_quadoption(PopDelete, _(\"Delete messages from server?\"));\n\n  snprintf(msgbuf, sizeof(msgbuf),\n           ngettext(\"Reading new messages (%d byte)...\",\n                    \"Reading new messages (%d bytes)...\", bytes),\n           bytes);\n  mutt_message(\"%s\", msgbuf);\n\n  for (int i = last + 1; i <= msgs; i++)\n  {\n    msg = mx_msg_open_new(&ctx, NULL, MUTT_ADD_FROM);\n    if (!msg)\n      ret = -3;\n    else\n    {\n      snprintf(buffer, sizeof(buffer), \"RETR %d\\r\\n\", i);\n      ret = pop_fetch_data(pop_data, buffer, NULL, fetch_message, msg->fp);\n      if (ret == -3)\n        rset = 1;\n\n      if (ret == 0 && mx_msg_commit(&ctx, msg) != 0)\n      {\n        rset = 1;\n        ret = -3;\n      }\n\n      mx_msg_close(&ctx, &msg);\n    }\n\n    if (ret == 0 && delanswer == MUTT_YES)\n    {\n      /* delete the message on the server */\n      snprintf(buffer, sizeof(buffer), \"DELE %d\\r\\n\", i);\n      ret = pop_query(pop_data, buffer, sizeof(buffer));\n    }\n\n    if (ret == -1)\n    {\n      mx_mbox_close(&ctx, NULL);\n      goto fail;\n    }\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      break;\n    }\n    if (ret == -3)\n    {\n      mutt_error(_(\"Error while writing mailbox!\"));\n      break;\n    }\n\n    /* L10N: The plural is picked by the second numerical argument, i.e.\n     * the %d right before 'messages', i.e. the total number of messages. */\n    mutt_message(ngettext(\"%s [%d of %d message read]\",\n                          \"%s [%d of %d messages read]\", msgs - last),\n                 msgbuf, i - last, msgs - last);\n  }\n\n  mx_mbox_close(&ctx, NULL);\n\n  if (rset)\n  {\n    /* make sure no messages get deleted */\n    mutt_str_strfcpy(buffer, \"RSET\\r\\n\", sizeof(buffer));\n    if (pop_query(pop_data, buffer, sizeof(buffer)) == -1)\n      goto fail;\n  }\n\nfinish:\n  /* exit gracefully */\n  mutt_str_strfcpy(buffer, \"QUIT\\r\\n\", sizeof(buffer));\n  if (pop_query(pop_data, buffer, sizeof(buffer)) == -1)\n    goto fail;\n  mutt_socket_close(conn);\n  FREE(&pop_data);\n  return;\n\nfail:\n  mutt_error(_(\"Server closed connection!\"));\n  mutt_socket_close(conn);\n  FREE(&pop_data);\n}\n\n// clang-format off\n/**\n * mx_pop_ops - Mailbox callback functions for POP mailboxes\n */\nstruct MxOps mx_pop_ops = {\n  .mbox_open        = pop_open_mailbox,\n  .mbox_open_append = NULL,\n  .mbox_check       = pop_check_mailbox,\n  .mbox_sync        = pop_sync_mailbox,\n  .mbox_close       = pop_close_mailbox,\n  .msg_open         = pop_fetch_message,\n  .msg_open_new     = NULL,\n  .msg_commit       = NULL,\n  .msg_close        = pop_close_message,\n  .tags_edit        = NULL,\n  .tags_commit      = NULL,\n};\n// clang-format on\n"], "fixing_code": ["/**\n * @file\n * POP network mailbox\n *\n * @authors\n * Copyright (C) 2000-2002 Vsevolod Volkov <vvv@mutt.org.ua>\n * Copyright (C) 2006-2007,2009 Rocco Rutte <pdmef@gmx.net>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page pop POP network mailbox\n *\n * POP network mailbox\n */\n\n#include \"config.h\"\n#include <errno.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"pop.h\"\n#include \"bcache.h\"\n#include \"body.h\"\n#include \"context.h\"\n#include \"envelope.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"mailbox.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"ncrypt/ncrypt.h\"\n#include \"options.h\"\n#include \"progress.h\"\n#include \"protos.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\n#ifdef USE_HCACHE\n#define HC_FNAME \"neomutt\" /* filename for hcache as POP lacks paths */\n#define HC_FEXT \"hcache\"   /* extension for hcache as POP lacks paths */\n#endif\n\n/**\n * cache_id - Make a message-cache-compatible id\n * @param id POP message id\n * @retval ptr Sanitised string\n *\n * The POP message id may contain '/' and other awkward characters.\n *\n * @note This function returns a pointer to a static buffer.\n */\nstatic const char *cache_id(const char *id)\n{\n  static char clean[SHORT_STRING];\n  mutt_str_strfcpy(clean, id, sizeof(clean));\n  mutt_file_sanitize_filename(clean, true);\n  return clean;\n}\n\n/**\n * fetch_message - write line to file\n * @param line String to write\n * @param file FILE pointer to write to\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int fetch_message(char *line, void *file)\n{\n  FILE *f = (FILE *) file;\n\n  fputs(line, f);\n  if (fputc('\\n', f) == EOF)\n    return -1;\n\n  return 0;\n}\n\n/**\n * pop_read_header - Read header\n * @param pop_data POP data\n * @param h        Email header\n * @retval  0 Success\n * @retval -1 Connection lost\n * @retval -2 Invalid command or execution error\n * @retval -3 Error writing to tempfile\n */\nstatic int pop_read_header(struct PopData *pop_data, struct Header *h)\n{\n  int rc, index;\n  size_t length;\n  char buf[LONG_STRING];\n\n  FILE *f = mutt_file_mkstemp();\n  if (!f)\n  {\n    mutt_perror(\"mutt_file_mkstemp failed!\");\n    return -3;\n  }\n\n  snprintf(buf, sizeof(buf), \"LIST %d\\r\\n\", h->refno);\n  rc = pop_query(pop_data, buf, sizeof(buf));\n  if (rc == 0)\n  {\n    sscanf(buf, \"+OK %d %zu\", &index, &length);\n\n    snprintf(buf, sizeof(buf), \"TOP %d 0\\r\\n\", h->refno);\n    rc = pop_fetch_data(pop_data, buf, NULL, fetch_message, f);\n\n    if (pop_data->cmd_top == 2)\n    {\n      if (rc == 0)\n      {\n        pop_data->cmd_top = 1;\n\n        mutt_debug(1, \"set TOP capability\\n\");\n      }\n\n      if (rc == -2)\n      {\n        pop_data->cmd_top = 0;\n\n        mutt_debug(1, \"unset TOP capability\\n\");\n        snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), \"%s\",\n                 _(\"Command TOP is not supported by server.\"));\n      }\n    }\n  }\n\n  switch (rc)\n  {\n    case 0:\n    {\n      rewind(f);\n      h->env = mutt_rfc822_read_header(f, h, 0, 0);\n      h->content->length = length - h->content->offset + 1;\n      rewind(f);\n      while (!feof(f))\n      {\n        h->content->length--;\n        fgets(buf, sizeof(buf), f);\n      }\n      break;\n    }\n    case -2:\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      break;\n    }\n    case -3:\n    {\n      mutt_error(_(\"Can't write header to temporary file!\"));\n      break;\n    }\n  }\n\n  mutt_file_fclose(&f);\n  return rc;\n}\n\n/**\n * fetch_uidl - parse UIDL\n * @param line String to parse\n * @param data Mailbox Context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int fetch_uidl(char *line, void *data)\n{\n  int i, index;\n  struct Context *ctx = (struct Context *) data;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  char *endp = NULL;\n\n  errno = 0;\n  index = strtol(line, &endp, 10);\n  if (errno)\n    return -1;\n  while (*endp == ' ')\n    endp++;\n  memmove(line, endp, strlen(endp) + 1);\n\n  /* uid must be at least be 1 byte */\n  if (strlen(line) == 0)\n    return -1;\n\n  for (i = 0; i < ctx->msgcount; i++)\n    if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)\n      break;\n\n  if (i == ctx->msgcount)\n  {\n    mutt_debug(1, \"new header %d %s\\n\", index, line);\n\n    if (i >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n\n    ctx->msgcount++;\n    ctx->hdrs[i] = mutt_header_new();\n    ctx->hdrs[i]->data = mutt_str_strdup(line);\n  }\n  else if (ctx->hdrs[i]->index != index - 1)\n    pop_data->clear_cache = true;\n\n  ctx->hdrs[i]->refno = index;\n  ctx->hdrs[i]->index = index - 1;\n\n  return 0;\n}\n\n/**\n * msg_cache_check - Check the Body Cache for an ID\n * @param id     Cache ID\n * @param bcache Body cache\n * @param data   Mailbox Context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n{\n  struct Context *ctx = (struct Context *) data;\n  if (!ctx)\n    return -1;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  if (!pop_data)\n    return -1;\n\n#ifdef USE_HCACHE\n  /* keep hcache file if hcache == bcache */\n  if (strcmp(HC_FNAME \".\" HC_FEXT, id) == 0)\n    return 0;\n#endif\n\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    /* if the id we get is known for a header: done (i.e. keep in cache) */\n    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))\n      return 0;\n  }\n\n  /* message not found in context -> remove it from cache\n   * return the result of bcache, so we stop upon its first error\n   */\n  return mutt_bcache_del(bcache, cache_id(id));\n}\n\n#ifdef USE_HCACHE\n/**\n * pop_hcache_namer - Create a header cache filename for a POP mailbox\n * @param path    Path of mailbox\n * @param dest    Buffer for filename\n * @param destlen Length of buffer\n * @retval num Characters written to buffer\n */\nstatic int pop_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  return snprintf(dest, destlen, \"%s.\" HC_FEXT, path);\n}\n\n/**\n * pop_hcache_open - Open the header cache\n * @param pop_data POP server data\n * @param path     Path to the mailbox\n * @retval ptr Header cache\n */\nstatic header_cache_t *pop_hcache_open(struct PopData *pop_data, const char *path)\n{\n  struct Url url;\n  char p[LONG_STRING];\n\n  if (!pop_data || !pop_data->conn)\n    return mutt_hcache_open(HeaderCache, path, NULL);\n\n  mutt_account_tourl(&pop_data->conn->account, &url);\n  url.path = HC_FNAME;\n  url_tostring(&url, p, sizeof(p), U_PATH);\n  return mutt_hcache_open(HeaderCache, p, pop_hcache_namer);\n}\n#endif\n\n/**\n * pop_fetch_headers - Read headers\n * @param ctx Context\n * @retval  0 Success\n * @retval -1 Connection lost\n * @retval -2 Invalid command or execution error\n * @retval -3 Error writing to tempfile\n */\nstatic int pop_fetch_headers(struct Context *ctx)\n{\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n\n#ifdef USE_HCACHE\n  header_cache_t *hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n\n  time(&pop_data->check_time);\n  pop_data->clear_cache = false;\n\n  for (int i = 0; i < ctx->msgcount; i++)\n    ctx->hdrs[i]->refno = -1;\n\n  const int old_count = ctx->msgcount;\n  int ret = pop_fetch_data(pop_data, \"UIDL\\r\\n\", NULL, fetch_uidl, ctx);\n  const int new_count = ctx->msgcount;\n  ctx->msgcount = old_count;\n\n  if (pop_data->cmd_uidl == 2)\n  {\n    if (ret == 0)\n    {\n      pop_data->cmd_uidl = 1;\n\n      mutt_debug(1, \"set UIDL capability\\n\");\n    }\n\n    if (ret == -2 && pop_data->cmd_uidl == 2)\n    {\n      pop_data->cmd_uidl = 0;\n\n      mutt_debug(1, \"unset UIDL capability\\n\");\n      snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), \"%s\",\n               _(\"Command UIDL is not supported by server.\"));\n    }\n  }\n\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);\n  }\n\n  if (ret == 0)\n  {\n    int i, deleted;\n    for (i = 0, deleted = 0; i < old_count; i++)\n    {\n      if (ctx->hdrs[i]->refno == -1)\n      {\n        ctx->hdrs[i]->deleted = true;\n        deleted++;\n      }\n    }\n    if (deleted > 0)\n    {\n      mutt_error(\n          ngettext(\"%d message has been lost. Try reopening the mailbox.\",\n                   \"%d messages have been lost. Try reopening the mailbox.\", deleted),\n          deleted);\n    }\n\n    bool hcached = false;\n    for (i = old_count; i < new_count; i++)\n    {\n      if (!ctx->quiet)\n        mutt_progress_update(&progress, i + 1 - old_count, -1);\n#ifdef USE_HCACHE\n      void *data = mutt_hcache_fetch(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n      if (data)\n      {\n        char *uidl = mutt_str_strdup(ctx->hdrs[i]->data);\n        int refno = ctx->hdrs[i]->refno;\n        int index = ctx->hdrs[i]->index;\n        /*\n         * - POP dynamically numbers headers and relies on h->refno\n         *   to map messages; so restore header and overwrite restored\n         *   refno with current refno, same for index\n         * - h->data needs to a separate pointer as it's driver-specific\n         *   data freed separately elsewhere\n         *   (the old h->data should point inside a malloc'd block from\n         *   hcache so there shouldn't be a memleak here)\n         */\n        struct Header *h = mutt_hcache_restore((unsigned char *) data);\n        mutt_hcache_free(hc, &data);\n        mutt_header_free(&ctx->hdrs[i]);\n        ctx->hdrs[i] = h;\n        ctx->hdrs[i]->refno = refno;\n        ctx->hdrs[i]->index = index;\n        ctx->hdrs[i]->data = uidl;\n        ret = 0;\n        hcached = true;\n      }\n      else\n#endif\n          if ((ret = pop_read_header(pop_data, ctx->hdrs[i])) < 0)\n        break;\n#ifdef USE_HCACHE\n      else\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n\n      /*\n       * faked support for flags works like this:\n       * - if 'hcached' is true, we have the message in our hcache:\n       *        - if we also have a body: read\n       *        - if we don't have a body: old\n       *          (if $mark_old is set which is maybe wrong as\n       *          $mark_old should be considered for syncing the\n       *          folder and not when opening it XXX)\n       * - if 'hcached' is false, we don't have the message in our hcache:\n       *        - if we also have a body: read\n       *        - if we don't have a body: new\n       */\n      const bool bcached =\n          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);\n      ctx->hdrs[i]->old = false;\n      ctx->hdrs[i]->read = false;\n      if (hcached)\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n        else if (MarkOld)\n          ctx->hdrs[i]->old = true;\n      }\n      else\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n      }\n\n      ctx->msgcount++;\n    }\n\n    if (i > old_count)\n      mx_update_context(ctx, i - old_count);\n  }\n\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n\n  if (ret < 0)\n  {\n    for (int i = ctx->msgcount; i < new_count; i++)\n      mutt_header_free(&ctx->hdrs[i]);\n    return ret;\n  }\n\n  /* after putting the result into our structures,\n   * clean up cache, i.e. wipe messages deleted outside\n   * the availability of our cache\n   */\n  if (MessageCacheClean)\n    mutt_bcache_list(pop_data->bcache, msg_cache_check, (void *) ctx);\n\n  mutt_clear_error();\n  return (new_count - old_count);\n}\n\n/**\n * pop_open_mailbox - open POP mailbox, fetch only headers\n * @param ctx Mailbox Context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_open_mailbox(struct Context *ctx)\n{\n  char buf[PATH_MAX];\n  struct Connection *conn = NULL;\n  struct Account acct;\n  struct PopData *pop_data = NULL;\n  struct Url url;\n\n  if (pop_parse_path(ctx->path, &acct))\n  {\n    mutt_error(_(\"%s is an invalid POP path\"), ctx->path);\n    return -1;\n  }\n\n  mutt_account_tourl(&acct, &url);\n  url.path = NULL;\n  url_tostring(&url, buf, sizeof(buf), 0);\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return -1;\n\n  FREE(&ctx->path);\n  FREE(&ctx->realpath);\n  ctx->path = mutt_str_strdup(buf);\n  ctx->realpath = mutt_str_strdup(ctx->path);\n\n  pop_data = mutt_mem_calloc(1, sizeof(struct PopData));\n  pop_data->conn = conn;\n  ctx->data = pop_data;\n\n  if (pop_open_connection(pop_data) < 0)\n    return -1;\n\n  conn->data = pop_data;\n  pop_data->bcache = mutt_bcache_open(&acct, NULL);\n\n  /* init (hard-coded) ACL rights */\n  memset(ctx->rights, 0, sizeof(ctx->rights));\n  mutt_bit_set(ctx->rights, MUTT_ACL_SEEN);\n  mutt_bit_set(ctx->rights, MUTT_ACL_DELETE);\n#ifdef USE_HCACHE\n  /* flags are managed using header cache, so it only makes sense to\n   * enable them in that case */\n  mutt_bit_set(ctx->rights, MUTT_ACL_WRITE);\n#endif\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    ctx->size = pop_data->size;\n\n    mutt_message(_(\"Fetching list of messages...\"));\n\n    const int ret = pop_fetch_headers(ctx);\n\n    if (ret >= 0)\n      return 0;\n\n    if (ret < -1)\n    {\n      mutt_sleep(2);\n      return -1;\n    }\n  }\n}\n\n/**\n * pop_clear_cache - delete all cached messages\n * @param pop_data POP server data\n */\nstatic void pop_clear_cache(struct PopData *pop_data)\n{\n  if (!pop_data->clear_cache)\n    return;\n\n  mutt_debug(1, \"delete cached messages\\n\");\n\n  for (int i = 0; i < POP_CACHE_LEN; i++)\n  {\n    if (pop_data->cache[i].path)\n    {\n      unlink(pop_data->cache[i].path);\n      FREE(&pop_data->cache[i].path);\n    }\n  }\n}\n\n/**\n * pop_close_mailbox - close POP mailbox\n * @param ctx Mailbox Context\n * @retval 0 Always\n */\nstatic int pop_close_mailbox(struct Context *ctx)\n{\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n\n  if (!pop_data)\n    return 0;\n\n  pop_logout(ctx);\n\n  if (pop_data->status != POP_NONE)\n    mutt_socket_close(pop_data->conn);\n\n  pop_data->status = POP_NONE;\n\n  pop_data->clear_cache = true;\n  pop_clear_cache(pop_data);\n\n  if (!pop_data->conn->data)\n    mutt_socket_free(pop_data->conn);\n\n  mutt_bcache_close(&pop_data->bcache);\n\n  return 0;\n}\n\n/**\n * pop_fetch_message - fetch message from POP server\n * @param ctx   Mailbox Context\n * @param msg   Message\n * @param msgno Message number\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno)\n{\n  void *uidl = NULL;\n  char buf[LONG_STRING];\n  char path[PATH_MAX];\n  struct Progress progressbar;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct PopCache *cache = NULL;\n  struct Header *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  /* see if we already have the message in body cache */\n  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));\n  if (msg->fp)\n    return 0;\n\n  /*\n   * see if we already have the message in our cache in\n   * case $message_cachedir is unset\n   */\n  cache = &pop_data->cache[h->index % POP_CACHE_LEN];\n\n  if (cache->path)\n  {\n    if (cache->index == h->index)\n    {\n      /* yes, so just return a pointer to the message */\n      msg->fp = fopen(cache->path, \"r\");\n      if (msg->fp)\n        return 0;\n\n      mutt_perror(cache->path);\n      return -1;\n    }\n    else\n    {\n      /* clear the previous entry */\n      unlink(cache->path);\n      FREE(&cache->path);\n    }\n  }\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    /* verify that massage index is correct */\n    if (h->refno < 0)\n    {\n      mutt_error(\n          _(\"The message index is incorrect. Try reopening the mailbox.\"));\n      return -1;\n    }\n\n    mutt_progress_init(&progressbar, _(\"Fetching message...\"), MUTT_PROGRESS_SIZE,\n                       NetInc, h->content->length + h->content->offset - 1);\n\n    /* see if we can put in body cache; use our cache as fallback */\n    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));\n    if (!msg->fp)\n    {\n      /* no */\n      bcache = 0;\n      mutt_mktemp(path, sizeof(path));\n      msg->fp = mutt_file_fopen(path, \"w+\");\n      if (!msg->fp)\n      {\n        mutt_perror(path);\n        return -1;\n      }\n    }\n\n    snprintf(buf, sizeof(buf), \"RETR %d\\r\\n\", h->refno);\n\n    const int ret = pop_fetch_data(pop_data, buf, &progressbar, fetch_message, msg->fp);\n    if (ret == 0)\n      break;\n\n    mutt_file_fclose(&msg->fp);\n\n    /* if RETR failed (e.g. connection closed), be sure to remove either\n     * the file in bcache or from POP's own cache since the next iteration\n     * of the loop will re-attempt to put() the message */\n    if (!bcache)\n      unlink(path);\n\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n\n    if (ret == -3)\n    {\n      mutt_error(_(\"Can't write message to temporary file!\"));\n      return -1;\n    }\n  }\n\n  /* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   */\n  if (bcache)\n    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));\n  else\n  {\n    cache->index = h->index;\n    cache->path = mutt_str_strdup(path);\n  }\n  rewind(msg->fp);\n  uidl = h->data;\n\n  /* we replace envelop, key in subj_hash has to be updated as well */\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_delete(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_remove(ctx, h);\n  mutt_env_free(&h->env);\n  h->env = mutt_rfc822_read_header(msg->fp, h, 0, 0);\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_insert(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_add(ctx, h);\n\n  h->data = uidl;\n  h->lines = 0;\n  fgets(buf, sizeof(buf), msg->fp);\n  while (!feof(msg->fp))\n  {\n    ctx->hdrs[msgno]->lines++;\n    fgets(buf, sizeof(buf), msg->fp);\n  }\n\n  h->content->length = ftello(msg->fp) - h->content->offset;\n\n  /* This needs to be done in case this is a multipart message */\n  if (!WithCrypto)\n    h->security = crypt_query(h->content);\n\n  mutt_clear_error();\n  rewind(msg->fp);\n\n  return 0;\n}\n\n/**\n * pop_close_message - Close POP Message\n * @param ctx Mailbox Context\n * @param msg Message\n * @retval 0   Success\n * @retval EOF Error, see errno\n */\nstatic int pop_close_message(struct Context *ctx, struct Message *msg)\n{\n  return mutt_file_fclose(&msg->fp);\n}\n\n/**\n * pop_sync_mailbox - update POP mailbox, delete messages from server\n * @param ctx        Mailbox Context\n * @param index_hint Current Message\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n{\n  int i, j, ret = 0;\n  char buf[LONG_STRING];\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n#endif\n\n  pop_data->check_time = 0;\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    mutt_progress_init(&progress, _(\"Marking messages deleted...\"),\n                       MUTT_PROGRESS_MSG, WriteInc, ctx->deleted);\n\n#ifdef USE_HCACHE\n    hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n\n    for (i = 0, j = 0, ret = 0; ret == 0 && i < ctx->msgcount; i++)\n    {\n      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)\n      {\n        j++;\n        if (!ctx->quiet)\n          mutt_progress_update(&progress, j, -1);\n        snprintf(buf, sizeof(buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n        ret = pop_query(pop_data, buf, sizeof(buf));\n        if (ret == 0)\n        {\n          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n#ifdef USE_HCACHE\n          mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n#endif\n        }\n      }\n\n#ifdef USE_HCACHE\n      if (ctx->hdrs[i]->changed)\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n    }\n\n#ifdef USE_HCACHE\n    mutt_hcache_close(hc);\n#endif\n\n    if (ret == 0)\n    {\n      mutt_str_strfcpy(buf, \"QUIT\\r\\n\", sizeof(buf));\n      ret = pop_query(pop_data, buf, sizeof(buf));\n    }\n\n    if (ret == 0)\n    {\n      pop_data->clear_cache = true;\n      pop_clear_cache(pop_data);\n      pop_data->status = POP_DISCONNECTED;\n      return 0;\n    }\n\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n  }\n}\n\n/**\n * pop_check_mailbox - Check for new messages and fetch headers\n * @param ctx        Mailbox Context\n * @param index_hint Current Message\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_check_mailbox(struct Context *ctx, int *index_hint)\n{\n  int ret;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n\n  if ((pop_data->check_time + PopCheckinterval) > time(NULL))\n    return 0;\n\n  pop_logout(ctx);\n\n  mutt_socket_close(pop_data->conn);\n\n  if (pop_open_connection(pop_data) < 0)\n    return -1;\n\n  ctx->size = pop_data->size;\n\n  mutt_message(_(\"Checking for new messages...\"));\n\n  ret = pop_fetch_headers(ctx);\n  pop_clear_cache(pop_data);\n\n  if (ret < 0)\n    return -1;\n\n  if (ret > 0)\n    return MUTT_NEW_MAIL;\n\n  return 0;\n}\n\n/**\n * pop_fetch_mail - Fetch messages and save them in $spoolfile\n */\nvoid pop_fetch_mail(void)\n{\n  char buffer[LONG_STRING];\n  char msgbuf[SHORT_STRING];\n  char *url = NULL, *p = NULL;\n  int delanswer, last = 0, msgs, bytes, rset = 0, ret;\n  struct Connection *conn = NULL;\n  struct Context ctx;\n  struct Message *msg = NULL;\n  struct Account acct;\n  struct PopData *pop_data = NULL;\n\n  if (!PopHost)\n  {\n    mutt_error(_(\"POP host is not defined.\"));\n    return;\n  }\n\n  url = p = mutt_mem_calloc(strlen(PopHost) + 7, sizeof(char));\n  if (url_check_scheme(PopHost) == U_UNKNOWN)\n  {\n    strcpy(url, \"pop://\");\n    p = strchr(url, '\\0');\n  }\n  strcpy(p, PopHost);\n\n  ret = pop_parse_path(url, &acct);\n  FREE(&url);\n  if (ret)\n  {\n    mutt_error(_(\"%s is an invalid POP path\"), PopHost);\n    return;\n  }\n\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return;\n\n  pop_data = mutt_mem_calloc(1, sizeof(struct PopData));\n  pop_data->conn = conn;\n\n  if (pop_open_connection(pop_data) < 0)\n  {\n    mutt_socket_free(pop_data->conn);\n    FREE(&pop_data);\n    return;\n  }\n\n  conn->data = pop_data;\n\n  mutt_message(_(\"Checking for new messages...\"));\n\n  /* find out how many messages are in the mailbox. */\n  mutt_str_strfcpy(buffer, \"STAT\\r\\n\", sizeof(buffer));\n  ret = pop_query(pop_data, buffer, sizeof(buffer));\n  if (ret == -1)\n    goto fail;\n  if (ret == -2)\n  {\n    mutt_error(\"%s\", pop_data->err_msg);\n    goto finish;\n  }\n\n  sscanf(buffer, \"+OK %d %d\", &msgs, &bytes);\n\n  /* only get unread messages */\n  if (msgs > 0 && PopLast)\n  {\n    mutt_str_strfcpy(buffer, \"LAST\\r\\n\", sizeof(buffer));\n    ret = pop_query(pop_data, buffer, sizeof(buffer));\n    if (ret == -1)\n      goto fail;\n    if (ret == 0)\n      sscanf(buffer, \"+OK %d\", &last);\n  }\n\n  if (msgs <= last)\n  {\n    mutt_message(_(\"No new mail in POP mailbox.\"));\n    goto finish;\n  }\n\n  if (mx_mbox_open(NONULL(Spoolfile), MUTT_APPEND, &ctx) == NULL)\n    goto finish;\n\n  delanswer = query_quadoption(PopDelete, _(\"Delete messages from server?\"));\n\n  snprintf(msgbuf, sizeof(msgbuf),\n           ngettext(\"Reading new messages (%d byte)...\",\n                    \"Reading new messages (%d bytes)...\", bytes),\n           bytes);\n  mutt_message(\"%s\", msgbuf);\n\n  for (int i = last + 1; i <= msgs; i++)\n  {\n    msg = mx_msg_open_new(&ctx, NULL, MUTT_ADD_FROM);\n    if (!msg)\n      ret = -3;\n    else\n    {\n      snprintf(buffer, sizeof(buffer), \"RETR %d\\r\\n\", i);\n      ret = pop_fetch_data(pop_data, buffer, NULL, fetch_message, msg->fp);\n      if (ret == -3)\n        rset = 1;\n\n      if (ret == 0 && mx_msg_commit(&ctx, msg) != 0)\n      {\n        rset = 1;\n        ret = -3;\n      }\n\n      mx_msg_close(&ctx, &msg);\n    }\n\n    if (ret == 0 && delanswer == MUTT_YES)\n    {\n      /* delete the message on the server */\n      snprintf(buffer, sizeof(buffer), \"DELE %d\\r\\n\", i);\n      ret = pop_query(pop_data, buffer, sizeof(buffer));\n    }\n\n    if (ret == -1)\n    {\n      mx_mbox_close(&ctx, NULL);\n      goto fail;\n    }\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      break;\n    }\n    if (ret == -3)\n    {\n      mutt_error(_(\"Error while writing mailbox!\"));\n      break;\n    }\n\n    /* L10N: The plural is picked by the second numerical argument, i.e.\n     * the %d right before 'messages', i.e. the total number of messages. */\n    mutt_message(ngettext(\"%s [%d of %d message read]\",\n                          \"%s [%d of %d messages read]\", msgs - last),\n                 msgbuf, i - last, msgs - last);\n  }\n\n  mx_mbox_close(&ctx, NULL);\n\n  if (rset)\n  {\n    /* make sure no messages get deleted */\n    mutt_str_strfcpy(buffer, \"RSET\\r\\n\", sizeof(buffer));\n    if (pop_query(pop_data, buffer, sizeof(buffer)) == -1)\n      goto fail;\n  }\n\nfinish:\n  /* exit gracefully */\n  mutt_str_strfcpy(buffer, \"QUIT\\r\\n\", sizeof(buffer));\n  if (pop_query(pop_data, buffer, sizeof(buffer)) == -1)\n    goto fail;\n  mutt_socket_close(conn);\n  FREE(&pop_data);\n  return;\n\nfail:\n  mutt_error(_(\"Server closed connection!\"));\n  mutt_socket_close(conn);\n  FREE(&pop_data);\n}\n\n// clang-format off\n/**\n * mx_pop_ops - Mailbox callback functions for POP mailboxes\n */\nstruct MxOps mx_pop_ops = {\n  .mbox_open        = pop_open_mailbox,\n  .mbox_open_append = NULL,\n  .mbox_check       = pop_check_mailbox,\n  .mbox_sync        = pop_sync_mailbox,\n  .mbox_close       = pop_close_mailbox,\n  .msg_open         = pop_fetch_message,\n  .msg_open_new     = NULL,\n  .msg_commit       = NULL,\n  .msg_close        = pop_close_message,\n  .tags_edit        = NULL,\n  .tags_commit      = NULL,\n};\n// clang-format on\n"], "filenames": ["pop.c"], "buggy_code_start_loc": [204], "buggy_code_end_loc": [204], "fixing_code_start_loc": [205], "fixing_code_end_loc": [209], "type": "CWE-824", "message": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. pop.c mishandles a zero-length UID.", "other": {"cve": {"id": "CVE-2018-14356", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-17T17:29:00.637", "lastModified": "2020-05-20T01:07:42.630", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. pop.c mishandles a zero-length UID."}, {"lang": "es", "value": "Se ha descubierto un problema en Mutt en versiones anteriores a la 1.10.1 y NeoMutt en versiones anteriores al 2018-07-16. pop.c gestiona de manera incorrecta un UID de longitud cero."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-824"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mutt:mutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.1", "matchCriteriaId": "2FA2C3A6-423C-4BE5-8FA7-0241384D58D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:neomutt:neomutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "20180716", "matchCriteriaId": "1C15CCD1-1752-4913-9506-32035B52A513"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}]}]}], "references": [{"url": "http://www.mutt.org/news.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/neomutt/neomutt/commit/93b8ac558752d09e1c56d4f1bc82631316fa9c82", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://gitlab.com/muttmua/mutt/commit/e154cba1b3fc52bb8cb8aa846353c0db79b5d9c6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/08/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://neomutt.org/2018/07/16/release", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://security.gentoo.org/glsa/201810-07", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3719-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4277", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neomutt/neomutt/commit/93b8ac558752d09e1c56d4f1bc82631316fa9c82"}}