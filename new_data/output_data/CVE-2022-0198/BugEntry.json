{"buggy_code": ["package edu.stanford.nlp.process; \nimport edu.stanford.nlp.util.logging.Redwood;\n\n\nimport java.io.*;\nimport java.util.*;\n\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport java.util.function.Function;\nimport edu.stanford.nlp.io.IOUtils;\nimport edu.stanford.nlp.util.XMLUtils;\n\n\n/**\n * Reads XML from an input file or stream and writes XML to an output\n * file or stream, while transforming text appearing inside specified\n * XML tags by applying a specified {@link Function\n * <code>Function</code>}.  See TransformXMLApplications for examples.\n * <i>Implementation note:</i> This is done using SAX2.\n *\n * @param <T> The type of the output of the Function (from String to T)\n * @author Bill MacCartney\n * @author Anna Rafferty (refactoring, making SAXInterface easy to extend elsewhere)\n */\npublic class TransformXML<T>  {\n\n  /** A logger for this class */\n  private static Redwood.RedwoodChannels log = Redwood.channels(TransformXML.class);\n\n  private final SAXParser saxParser;\n\n  public SAXInterface<T> buildSaxInterface() { return new SAXInterface<>(); }\n\n  public static class SAXInterface<T> extends DefaultHandler {\n\n    protected List<String> elementsToBeTransformed;\n    protected StringBuilder textToBeTransformed;\n    protected PrintWriter outWriter = new PrintWriter(System.out, true);\n    protected Function<String,T> function;\n\n    /**\n     * How far down we are in the nested tags.  For example, if we've\n     * seen &lt;foo&gt; &lt;bar&gt; and \"foo\" and \"bar\" are both tags\n     * we care about, then depth = 2.\n     */\n    protected int depth = 0;\n\n    public SAXInterface() {\n      elementsToBeTransformed = new ArrayList<>();\n      depth = 0;\n      openingTag = null;\n      textToBeTransformed = new StringBuilder();\n    }\n\n    /**\n     * The first tag from {@link <code>elementsToBeTransformed</code>}\n     * that we saw the last time {@link <code>depth</code>} was\n     * <code>0</code>.\n     * <br>\n     * You would expect incoming XML to be well-formatted, but just in\n     * case it isn't, we keep track of this so we can output the\n     * correct closing tag.\n     */\n    String openingTag;\n\n    private void outputTextAndTag(String qName, Attributes attributes, boolean close) {\n      // If we're not already in an element to be transformed, first\n      // echo the previous text...\n      outWriter.print(XMLUtils.escapeXML(textToBeTransformed.toString()));\n      textToBeTransformed = new StringBuilder();\n      \n      // ... then echo the new tag to outStream \n      outWriter.print('<');\n      if (close) {\n        outWriter.print('/');\n      }\n      outWriter.print(qName);\n      if (attributes != null) {\n        for (int i = 0; i < attributes.getLength(); i++) {\n          outWriter.print(' ');\n          outWriter.print(attributes.getQName(i));\n          outWriter.print(\"=\\\"\");\n          outWriter.print(XMLUtils.escapeXML(attributes.getValue(i)));\n          outWriter.print('\"');\n        }\n      }\n      outWriter.print(\">\\n\");\n    }\n\n    @Override\n    public void endDocument() {\n      // Theoretically, there shouldn't be anything in the buffer after\n      // the last closing tag, but if there is, it's probably better to\n      // echo it than ignore it\n      outWriter.print(XMLUtils.escapeXML(textToBeTransformed.toString()));\n      // we need to flush because there are no other ways we\n      // explicitely flush\n      outWriter.flush();\n    }\n    \n    // Called at the beginning of each element.  If the tag is on the\n    // designated list, set flag to remember that we're in an element\n    // to be transformed.  In either case, echo tag.\n    @Override\n    public void startElement(String uri, String localName, String qName, \n                             Attributes attributes) throws SAXException {\n      //log.info(\"start element \" + qName);\n      \n      if (depth == 0) {\n        outputTextAndTag(qName, attributes, false);\n      }\n      \n      if (elementsToBeTransformed.contains(qName)) {\n        if (depth == 0) {\n          openingTag = qName;\n        }\n        ++depth;\n      }\n    }\n\n    // Called at the end of each element.  If the tag is on the\n    // designated list, apply the designated {@link Function\n    // <code>Function</code>} to the accumulated text and echo the the\n    // result.  In either case, echo the closing tag.\n    @Override\n    public void endElement(String uri, String localName, String qName) \n      throws SAXException \n    {\n      //log.info(\"end element \" + qName + \"; function is \" + function.getClass());\n      //log.info(\"elementsToBeTransformed is \" + elementsToBeTransformed);\n      //log.info(\"textToBeTransformed is \" + textToBeTransformed);\n      \n      if (depth == 0) {\n        outputTextAndTag(qName, null, true);\n      } else {\n        if (elementsToBeTransformed.contains(qName)) {\n          --depth;\n          if (depth == 0) {\n            String text = textToBeTransformed.toString().trim();\n            // factored out so subclasses can handle the text differently\n            processText(text);\n            textToBeTransformed = new StringBuilder();\n            outWriter.print(\"</\" + openingTag + \">\\n\");\n          }\n        }\n        // when we're inside a block to be transformed, we ignore\n        // elements that don't end the block.\n      }\n    }\n\n    public void processText(String text) {\n      if (text.length() > 0) {\n        text = function.apply(text).toString();\n        outWriter.print(XMLUtils.escapeXML(text));\n        outWriter.print('\\n');\n      }\n    }\n    \n\n    // Accumulate characters in buffer of text to be transformed\n    // (SAX may call this after each line break)\n    @Override\n    public void characters(char[] buf, int offset, int len) throws SAXException {\n      // log.info(\"characters |\" + new String(buf, offset, len) + \"|\");\n      textToBeTransformed.append(buf, offset, len);\n    }\n  } // end static class SAXInterface\n\n\n  /**\n   * This version of the SAXInterface doesn't escape the text produced\n   * by the function.  This is useful in the case where the function\n   * already produces well-formed XML.  One example of this is the\n   * Tagger, which already escapes the inner text and produces xml\n   * tags around the words.\n   */\n  public static class NoEscapingSAXInterface<T> extends SAXInterface<T> {\n    @Override\n    public void processText(String text) {\n      if (text.length() > 0) {\n        text = function.apply(text).toString();\n        outWriter.print(text);\n        outWriter.print('\\n');\n      }\n    }    \n  }\n\n\n  public TransformXML() {\n    try {\n      saxParser = SAXParserFactory.newInstance().newSAXParser();\n    } catch (Exception e) {\n      log.info(\"Error configuring XML parser: \" + e);\n      throw new RuntimeException(e);\n    }\n  }\n\n\n  /**\n   * Read XML from the specified file and write XML to stdout,\n   * while transforming text appearing inside the specified XML\n   * tags by applying the specified {@link Function\n   * <code>Function</code>}.  Note that the <code>Function</code>\n   * you supply must be prepared to accept <code>String</code>s as\n   * input; if your <code>Function</code> doesn't handle\n   * <code>String</code>s, you need to write a wrapper for it that\n   * does.\n   *\n   * @param tags an array of <code>String</code>s, each an XML tag\n   *             within which the transformation should be applied\n   * @param fn   the {@link Function <code>Function</code>} to apply\n   * @param in   the <code>File</code> to read from\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, File in) {\n    InputStream ins = null;\n    try {\n      ins = new BufferedInputStream(new FileInputStream(in));\n      transformXML(tags, fn, ins, System.out);\n    } catch (Exception e) {\n      log.info(\"Error reading file \" + in + \": \" + e);\n      e.printStackTrace();\n    } finally {\n      IOUtils.closeIgnoringExceptions(ins);\n    }\n  }\n\n  /**\n   * Read XML from the specified file and write XML to specified file,\n   * while transforming text appearing inside the specified XML tags\n   * by applying the specified {@link Function <code>Function</code>}.\n   * Note that the <code>Function</code> you supply must be\n   * prepared to accept <code>String</code>s as input; if your\n   * <code>Function</code> doesn't handle <code>String</code>s, you\n   * need to write a wrapper for it that does.\n   *\n   * @param tags an array of <code>String</code>s, each an XML tag\n   *             within which the transformation should be applied\n   * @param fn   the {@link Function <code>Function</code>} to apply\n   * @param in   the <code>File</code> to read from\n   * @param out  the <code>File</code> to write to\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, File in, File out) {\n    InputStream ins = null;\n    OutputStream outs = null;\n    try {\n      ins = new BufferedInputStream(new FileInputStream(in));\n      outs = new BufferedOutputStream(new FileOutputStream(out));\n      transformXML(tags, fn, ins, outs);\n    } catch (Exception e) {\n      log.info(\"Error reading file \" + in + \" or writing file \" + out + \": \" + e);\n      e.printStackTrace();\n    } finally {\n      IOUtils.closeIgnoringExceptions(ins);\n      IOUtils.closeIgnoringExceptions(outs);\n    }\n  }\n\n  /**\n   * Read XML from input stream and write XML to stdout, while\n   * transforming text appearing inside the specified XML tags by\n   * applying the specified {@link Function <code>Function</code>}.\n   * Note that the <code>Function</code> you supply must be\n   * prepared to accept <code>String</code>s as input; if your\n   * <code>Function</code> doesn't handle <code>String</code>s, you\n   * need to write a wrapper for it that does.\n   *\n   * @param tags an array of <code>String</code>s, each an XML tag\n   *             within which the transformation should be applied\n   * @param fn   the {@link Function <code>Function</code>} to apply\n   * @param in   the <code>InputStream</code> to read from\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, InputStream in) {\n    transformXML(tags, fn, in, System.out);\n  }\n\n  /**\n   * Read XML from input stream and write XML to output stream,\n   * while transforming text appearing inside the specified XML tags\n   * by applying the specified {@link Function <code>Function</code>}.\n   * Note that the <code>Function</code> you supply must be\n   * prepared to accept <code>String</code>s as input; if your\n   * <code>Function</code> doesn't handle <code>String</code>s, you\n   * need to write a wrapper for it that does.\n   *\n   * @param tags an array of <code>String</code>s, each an XML tag\n   *             within which the transformation should be applied\n   * @param fn   the {@link Function <code>Function</code>} to apply\n   * @param in   the <code>InputStream</code> to read from\n   * @param out  the <code>OutputStream</code> to write to\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, InputStream in, OutputStream out) {\n    transformXML(tags, fn, in, new OutputStreamWriter(out), \n                 buildSaxInterface());\n  }\n\n  /**\n   * Read XML from input stream and write XML to output stream,\n   * while transforming text appearing inside the specified XML tags\n   * by applying the specified {@link Function <code>Function</code>}.\n   * Note that the <code>Function</code> you supply must be\n   * prepared to accept <code>String</code>s as input; if your\n   * <code>Function</code> doesn't handle <code>String</code>s, you\n   * need to write a wrapper for it that does.\n   * <p><i>Implementation notes:</i> The InputStream is assumed to already\n   * be buffered if useful, and we need a stream, so that the XML decoder\n   * can determine the correct character encoding of the XML file. The output\n   * is to a Writer, and the provided Writer should again be buffered if\n   * desirable.  Internally, this Writer is wrapped as a PrintWriter.\n   *\n   * @param tags an array of <code>String</code>s, each an XML entity\n   *             within which the transformation should be applied\n   * @param fn   the {@link Function <code>Function</code>} to apply\n   * @param in   the <code>InputStream</code> to read from\n   * @param w    the <code>Writer</code> to write to\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, InputStream in, Writer w) {\n    transformXML(tags, fn, in, w, buildSaxInterface());\n  }\n\n  /**\n   * Calls the fully specified transformXML with an InputSource\n   * constructed from <code>in</code>.\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, InputStream in, Writer w, SAXInterface<T> handler) {\n    transformXML(tags, fn, new InputSource(in), w, handler);\n  }  \n\n  /**\n   * Calls the fully specified transformXML with an InputSource\n   * constructed from <code>in</code>.\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, Reader in, Writer w, SAXInterface<T> handler) {\n    transformXML(tags, fn, new InputSource(in), w, handler);\n  }\n\n  /**\n   * Read XML from input source and write XML to output writer,\n   * while transforming text appearing inside the specified XML tags\n   * by applying the specified {@link Function <code>Function</code>}.\n   * Note that the <code>Function</code> you supply must be\n   * prepared to accept <code>String</code>s as input; if your\n   * <code>Function</code> doesn't handle <code>String</code>s, you\n   * need to write a wrapper for it that does.\n   * <br>\n   * <p><i>Implementation notes:</i> The InputSource is assumed to already\n   * be buffered if useful, and we need a stream, so that the XML decoder\n   * can determine the correct character encoding of the XML file. \n   * TODO: does that mean there's a bug if you send it a Reader\n   * instead of an InputStream?  It seems to work with a Reader...\n   * <br>\n   * The output is to a Writer, and the provided Writer should again\n   * be buffered if desirable.  Internally, this Writer is wrapped as\n   * a PrintWriter.\n   *\n   * @param tags an array of <code>String</code>s, each an XML entity\n   *             within which the transformation should be applied\n   * @param fn   the {@link Function <code>Function</code>} to apply\n   * @param in   the <code>InputStream</code> to read from\n   * @param w    the <code>Writer</code> to write to\n   * @param saxInterface the sax handler you would like to use (default is SaxInterface, defined in this class, but you may define your own handler)\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, InputSource in, Writer w, SAXInterface<T> saxInterface) {\n    saxInterface.outWriter = new PrintWriter(w, true);\n    saxInterface.function = fn;\n    saxInterface.elementsToBeTransformed = new ArrayList<>();\n    saxInterface.elementsToBeTransformed.addAll(Arrays.asList(tags));\n    try {\n      saxParser.parse(in, saxInterface);\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n} // end class TransformXML\n"], "fixing_code": ["package edu.stanford.nlp.process; \nimport edu.stanford.nlp.util.logging.Redwood;\n\n\nimport java.io.*;\nimport java.util.*;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport java.util.function.Function;\nimport edu.stanford.nlp.io.IOUtils;\nimport edu.stanford.nlp.util.XMLUtils;\n\n\n/**\n * Reads XML from an input file or stream and writes XML to an output\n * file or stream, while transforming text appearing inside specified\n * XML tags by applying a specified {@link Function\n * <code>Function</code>}.  See TransformXMLApplications for examples.\n * <i>Implementation note:</i> This is done using SAX2.\n *\n * @param <T> The type of the output of the Function (from String to T)\n * @author Bill MacCartney\n * @author Anna Rafferty (refactoring, making SAXInterface easy to extend elsewhere)\n */\npublic class TransformXML<T>  {\n\n  /** A logger for this class */\n  private static Redwood.RedwoodChannels log = Redwood.channels(TransformXML.class);\n\n  private final SAXParser saxParser;\n\n  public SAXInterface<T> buildSaxInterface() { return new SAXInterface<>(); }\n\n  public static class SAXInterface<T> extends DefaultHandler {\n\n    protected List<String> elementsToBeTransformed;\n    protected StringBuilder textToBeTransformed;\n    protected PrintWriter outWriter = new PrintWriter(System.out, true);\n    protected Function<String,T> function;\n\n    /**\n     * How far down we are in the nested tags.  For example, if we've\n     * seen &lt;foo&gt; &lt;bar&gt; and \"foo\" and \"bar\" are both tags\n     * we care about, then depth = 2.\n     */\n    protected int depth = 0;\n\n    public SAXInterface() {\n      elementsToBeTransformed = new ArrayList<>();\n      depth = 0;\n      openingTag = null;\n      textToBeTransformed = new StringBuilder();\n    }\n\n    /**\n     * The first tag from {@link <code>elementsToBeTransformed</code>}\n     * that we saw the last time {@link <code>depth</code>} was\n     * <code>0</code>.\n     * <br>\n     * You would expect incoming XML to be well-formatted, but just in\n     * case it isn't, we keep track of this so we can output the\n     * correct closing tag.\n     */\n    String openingTag;\n\n    private void outputTextAndTag(String qName, Attributes attributes, boolean close) {\n      // If we're not already in an element to be transformed, first\n      // echo the previous text...\n      outWriter.print(XMLUtils.escapeXML(textToBeTransformed.toString()));\n      textToBeTransformed = new StringBuilder();\n      \n      // ... then echo the new tag to outStream \n      outWriter.print('<');\n      if (close) {\n        outWriter.print('/');\n      }\n      outWriter.print(qName);\n      if (attributes != null) {\n        for (int i = 0; i < attributes.getLength(); i++) {\n          outWriter.print(' ');\n          outWriter.print(attributes.getQName(i));\n          outWriter.print(\"=\\\"\");\n          outWriter.print(XMLUtils.escapeXML(attributes.getValue(i)));\n          outWriter.print('\"');\n        }\n      }\n      outWriter.print(\">\\n\");\n    }\n\n    @Override\n    public void endDocument() {\n      // Theoretically, there shouldn't be anything in the buffer after\n      // the last closing tag, but if there is, it's probably better to\n      // echo it than ignore it\n      outWriter.print(XMLUtils.escapeXML(textToBeTransformed.toString()));\n      // we need to flush because there are no other ways we\n      // explicitely flush\n      outWriter.flush();\n    }\n    \n    // Called at the beginning of each element.  If the tag is on the\n    // designated list, set flag to remember that we're in an element\n    // to be transformed.  In either case, echo tag.\n    @Override\n    public void startElement(String uri, String localName, String qName, \n                             Attributes attributes) throws SAXException {\n      //log.info(\"start element \" + qName);\n      \n      if (depth == 0) {\n        outputTextAndTag(qName, attributes, false);\n      }\n      \n      if (elementsToBeTransformed.contains(qName)) {\n        if (depth == 0) {\n          openingTag = qName;\n        }\n        ++depth;\n      }\n    }\n\n    // Called at the end of each element.  If the tag is on the\n    // designated list, apply the designated {@link Function\n    // <code>Function</code>} to the accumulated text and echo the the\n    // result.  In either case, echo the closing tag.\n    @Override\n    public void endElement(String uri, String localName, String qName) \n      throws SAXException \n    {\n      //log.info(\"end element \" + qName + \"; function is \" + function.getClass());\n      //log.info(\"elementsToBeTransformed is \" + elementsToBeTransformed);\n      //log.info(\"textToBeTransformed is \" + textToBeTransformed);\n      \n      if (depth == 0) {\n        outputTextAndTag(qName, null, true);\n      } else {\n        if (elementsToBeTransformed.contains(qName)) {\n          --depth;\n          if (depth == 0) {\n            String text = textToBeTransformed.toString().trim();\n            // factored out so subclasses can handle the text differently\n            processText(text);\n            textToBeTransformed = new StringBuilder();\n            outWriter.print(\"</\" + openingTag + \">\\n\");\n          }\n        }\n        // when we're inside a block to be transformed, we ignore\n        // elements that don't end the block.\n      }\n    }\n\n    public void processText(String text) {\n      if (text.length() > 0) {\n        text = function.apply(text).toString();\n        outWriter.print(XMLUtils.escapeXML(text));\n        outWriter.print('\\n');\n      }\n    }\n    \n\n    // Accumulate characters in buffer of text to be transformed\n    // (SAX may call this after each line break)\n    @Override\n    public void characters(char[] buf, int offset, int len) throws SAXException {\n      // log.info(\"characters |\" + new String(buf, offset, len) + \"|\");\n      textToBeTransformed.append(buf, offset, len);\n    }\n  } // end static class SAXInterface\n\n\n  /**\n   * This version of the SAXInterface doesn't escape the text produced\n   * by the function.  This is useful in the case where the function\n   * already produces well-formed XML.  One example of this is the\n   * Tagger, which already escapes the inner text and produces xml\n   * tags around the words.\n   */\n  public static class NoEscapingSAXInterface<T> extends SAXInterface<T> {\n    @Override\n    public void processText(String text) {\n      if (text.length() > 0) {\n        text = function.apply(text).toString();\n        outWriter.print(text);\n        outWriter.print('\\n');\n      }\n    }    \n  }\n\n\n  public TransformXML() {\n    try {\n      SAXParserFactory spf = SAXParserFactory.newInstance();\n      spf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n      saxParser = SAXParserFactory.newInstance().newSAXParser();\n    } catch (Exception e) {\n      log.info(\"Error configuring XML parser: \" + e);\n      throw new RuntimeException(e);\n    }\n  }\n\n\n  /**\n   * Read XML from the specified file and write XML to stdout,\n   * while transforming text appearing inside the specified XML\n   * tags by applying the specified {@link Function\n   * <code>Function</code>}.  Note that the <code>Function</code>\n   * you supply must be prepared to accept <code>String</code>s as\n   * input; if your <code>Function</code> doesn't handle\n   * <code>String</code>s, you need to write a wrapper for it that\n   * does.\n   *\n   * @param tags an array of <code>String</code>s, each an XML tag\n   *             within which the transformation should be applied\n   * @param fn   the {@link Function <code>Function</code>} to apply\n   * @param in   the <code>File</code> to read from\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, File in) {\n    InputStream ins = null;\n    try {\n      ins = new BufferedInputStream(new FileInputStream(in));\n      transformXML(tags, fn, ins, System.out);\n    } catch (Exception e) {\n      log.info(\"Error reading file \" + in + \": \" + e);\n      e.printStackTrace();\n    } finally {\n      IOUtils.closeIgnoringExceptions(ins);\n    }\n  }\n\n  /**\n   * Read XML from the specified file and write XML to specified file,\n   * while transforming text appearing inside the specified XML tags\n   * by applying the specified {@link Function <code>Function</code>}.\n   * Note that the <code>Function</code> you supply must be\n   * prepared to accept <code>String</code>s as input; if your\n   * <code>Function</code> doesn't handle <code>String</code>s, you\n   * need to write a wrapper for it that does.\n   *\n   * @param tags an array of <code>String</code>s, each an XML tag\n   *             within which the transformation should be applied\n   * @param fn   the {@link Function <code>Function</code>} to apply\n   * @param in   the <code>File</code> to read from\n   * @param out  the <code>File</code> to write to\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, File in, File out) {\n    InputStream ins = null;\n    OutputStream outs = null;\n    try {\n      ins = new BufferedInputStream(new FileInputStream(in));\n      outs = new BufferedOutputStream(new FileOutputStream(out));\n      transformXML(tags, fn, ins, outs);\n    } catch (Exception e) {\n      log.info(\"Error reading file \" + in + \" or writing file \" + out + \": \" + e);\n      e.printStackTrace();\n    } finally {\n      IOUtils.closeIgnoringExceptions(ins);\n      IOUtils.closeIgnoringExceptions(outs);\n    }\n  }\n\n  /**\n   * Read XML from input stream and write XML to stdout, while\n   * transforming text appearing inside the specified XML tags by\n   * applying the specified {@link Function <code>Function</code>}.\n   * Note that the <code>Function</code> you supply must be\n   * prepared to accept <code>String</code>s as input; if your\n   * <code>Function</code> doesn't handle <code>String</code>s, you\n   * need to write a wrapper for it that does.\n   *\n   * @param tags an array of <code>String</code>s, each an XML tag\n   *             within which the transformation should be applied\n   * @param fn   the {@link Function <code>Function</code>} to apply\n   * @param in   the <code>InputStream</code> to read from\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, InputStream in) {\n    transformXML(tags, fn, in, System.out);\n  }\n\n  /**\n   * Read XML from input stream and write XML to output stream,\n   * while transforming text appearing inside the specified XML tags\n   * by applying the specified {@link Function <code>Function</code>}.\n   * Note that the <code>Function</code> you supply must be\n   * prepared to accept <code>String</code>s as input; if your\n   * <code>Function</code> doesn't handle <code>String</code>s, you\n   * need to write a wrapper for it that does.\n   *\n   * @param tags an array of <code>String</code>s, each an XML tag\n   *             within which the transformation should be applied\n   * @param fn   the {@link Function <code>Function</code>} to apply\n   * @param in   the <code>InputStream</code> to read from\n   * @param out  the <code>OutputStream</code> to write to\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, InputStream in, OutputStream out) {\n    transformXML(tags, fn, in, new OutputStreamWriter(out), \n                 buildSaxInterface());\n  }\n\n  /**\n   * Read XML from input stream and write XML to output stream,\n   * while transforming text appearing inside the specified XML tags\n   * by applying the specified {@link Function <code>Function</code>}.\n   * Note that the <code>Function</code> you supply must be\n   * prepared to accept <code>String</code>s as input; if your\n   * <code>Function</code> doesn't handle <code>String</code>s, you\n   * need to write a wrapper for it that does.\n   * <p><i>Implementation notes:</i> The InputStream is assumed to already\n   * be buffered if useful, and we need a stream, so that the XML decoder\n   * can determine the correct character encoding of the XML file. The output\n   * is to a Writer, and the provided Writer should again be buffered if\n   * desirable.  Internally, this Writer is wrapped as a PrintWriter.\n   *\n   * @param tags an array of <code>String</code>s, each an XML entity\n   *             within which the transformation should be applied\n   * @param fn   the {@link Function <code>Function</code>} to apply\n   * @param in   the <code>InputStream</code> to read from\n   * @param w    the <code>Writer</code> to write to\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, InputStream in, Writer w) {\n    transformXML(tags, fn, in, w, buildSaxInterface());\n  }\n\n  /**\n   * Calls the fully specified transformXML with an InputSource\n   * constructed from <code>in</code>.\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, InputStream in, Writer w, SAXInterface<T> handler) {\n    transformXML(tags, fn, new InputSource(in), w, handler);\n  }  \n\n  /**\n   * Calls the fully specified transformXML with an InputSource\n   * constructed from <code>in</code>.\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, Reader in, Writer w, SAXInterface<T> handler) {\n    transformXML(tags, fn, new InputSource(in), w, handler);\n  }\n\n  /**\n   * Read XML from input source and write XML to output writer,\n   * while transforming text appearing inside the specified XML tags\n   * by applying the specified {@link Function <code>Function</code>}.\n   * Note that the <code>Function</code> you supply must be\n   * prepared to accept <code>String</code>s as input; if your\n   * <code>Function</code> doesn't handle <code>String</code>s, you\n   * need to write a wrapper for it that does.\n   * <br>\n   * <p><i>Implementation notes:</i> The InputSource is assumed to already\n   * be buffered if useful, and we need a stream, so that the XML decoder\n   * can determine the correct character encoding of the XML file. \n   * TODO: does that mean there's a bug if you send it a Reader\n   * instead of an InputStream?  It seems to work with a Reader...\n   * <br>\n   * The output is to a Writer, and the provided Writer should again\n   * be buffered if desirable.  Internally, this Writer is wrapped as\n   * a PrintWriter.\n   *\n   * @param tags an array of <code>String</code>s, each an XML entity\n   *             within which the transformation should be applied\n   * @param fn   the {@link Function <code>Function</code>} to apply\n   * @param in   the <code>InputStream</code> to read from\n   * @param w    the <code>Writer</code> to write to\n   * @param saxInterface the sax handler you would like to use (default is SaxInterface, defined in this class, but you may define your own handler)\n   */\n  public void transformXML(String[] tags, Function<String,T> fn, InputSource in, Writer w, SAXInterface<T> saxInterface) {\n    saxInterface.outWriter = new PrintWriter(w, true);\n    saxInterface.function = fn;\n    saxInterface.elementsToBeTransformed = new ArrayList<>();\n    saxInterface.elementsToBeTransformed.addAll(Arrays.asList(tags));\n    try {\n      saxParser.parse(in, saxInterface);\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n} // end class TransformXML\n"], "filenames": ["src/edu/stanford/nlp/process/TransformXML.java"], "buggy_code_start_loc": [7], "buggy_code_end_loc": [197], "fixing_code_start_loc": [8], "fixing_code_end_loc": [201], "type": "CWE-611", "message": "corenlp is vulnerable to Improper Restriction of XML External Entity Reference", "other": {"cve": {"id": "CVE-2022-0198", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-13T07:15:06.463", "lastModified": "2022-01-19T21:51:13.330", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "corenlp is vulnerable to Improper Restriction of XML External Entity Reference"}, {"lang": "es", "value": "corenlp es vulnerable a una Restricci\u00f3n Inapropiada de la Referencia a Entidades Externas XML"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:stanford:corenlp:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.3.2", "matchCriteriaId": "4A81475F-1CFF-435A-8F67-870478C33758"}]}]}], "references": [{"url": "https://github.com/stanfordnlp/corenlp/commit/1f52136321cfca68b991bd7870563d06cf96624d", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/3d7e70fe-dddd-4b79-af62-8e058c4d5763", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/stanfordnlp/corenlp/commit/1f52136321cfca68b991bd7870563d06cf96624d"}}