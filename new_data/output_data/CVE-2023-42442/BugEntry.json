{"buggy_code": ["# -*- coding: utf-8 -*-\n#\nimport time\n\nfrom django.conf import settings\nfrom rest_framework import permissions\n\nfrom authentication.const import ConfirmType\nfrom authentication.models import ConnectionToken\nfrom common.exceptions import UserConfirmRequired\nfrom common.utils import get_object_or_none\nfrom orgs.utils import tmp_to_root_org\n\n\nclass IsValidUser(permissions.IsAuthenticated, permissions.BasePermission):\n    \"\"\"Allows access to valid user, is active and not expired\"\"\"\n\n    def has_permission(self, request, view):\n        return super().has_permission(request, view) \\\n            and request.user.is_valid\n\n\nclass IsValidUserOrConnectionToken(IsValidUser):\n    def has_permission(self, request, view):\n        return super().has_permission(request, view) \\\n            or self.is_valid_connection_token(request)\n\n    @staticmethod\n    def is_valid_connection_token(request):\n        token_id = request.query_params.get('token')\n        if not token_id:\n            return False\n        with tmp_to_root_org():\n            token = get_object_or_none(ConnectionToken, id=token_id)\n        return token and token.is_valid\n\n\nclass OnlySuperUser(IsValidUser):\n    def has_permission(self, request, view):\n        return super().has_permission(request, view) \\\n            and request.user.is_superuser\n\n\nclass IsServiceAccount(IsValidUser):\n    def has_permission(self, request, view):\n        return super().has_permission(request, view) \\\n            and request.user.is_service_account\n\n\nclass WithBootstrapToken(permissions.BasePermission):\n    def has_permission(self, request, view):\n        authorization = request.META.get('HTTP_AUTHORIZATION', '')\n        if not authorization:\n            return False\n        request_bootstrap_token = authorization.split()[-1]\n        return settings.BOOTSTRAP_TOKEN == request_bootstrap_token\n\n\nclass UserConfirmation(permissions.BasePermission):\n    ttl = 60 * 5\n    min_level = 1\n    confirm_type = ConfirmType.ReLogin\n\n    def has_permission(self, request, view):\n        if not settings.SECURITY_VIEW_AUTH_NEED_MFA:\n            return True\n\n        confirm_level = request.session.get('CONFIRM_LEVEL')\n        confirm_time = request.session.get('CONFIRM_TIME')\n        ttl = self.get_ttl()\n        if not confirm_level or not confirm_time or \\\n                confirm_level < self.min_level or \\\n                confirm_time < time.time() - ttl:\n            raise UserConfirmRequired(code=self.confirm_type)\n        return True\n\n    def get_ttl(self):\n        if self.confirm_type == ConfirmType.MFA:\n            ttl = settings.SECURITY_MFA_VERIFY_TTL\n        else:\n            ttl = self.ttl\n        return ttl\n\n    @classmethod\n    def require(cls, confirm_type=ConfirmType.ReLogin, ttl=60 * 5):\n        min_level = ConfirmType.values.index(confirm_type) + 1\n        name = 'UserConfirmationLevel{}TTL{}'.format(min_level, ttl)\n        return type(name, (cls,), {'min_level': min_level, 'ttl': ttl, 'confirm_type': confirm_type})\n", "# ~*~ coding: utf-8 ~*~\n\npath_perms_map = {\n    'xpack': '*',\n    'settings': '*',\n    'replay': 'default',\n    'applets': 'terminal.view_applet',\n    'playbooks': 'ops.view_playbook'\n}\n\n\ndef allow_access(private_file):\n    request = private_file.request\n    request_path = private_file.request.path\n    path_list = str(request_path)[1:].split('/')\n    path_base = path_list[1] if len(path_list) > 1 else None\n    path_perm = path_perms_map.get(path_base, None)\n\n    if not path_perm:\n        return False\n    if path_perm == '*' or request.user.has_perms([path_perm]):\n        return True\n    if path_perm == 'default':\n        return request.user.is_authenticated and request.user.is_staff\n    return False\n", "from rest_framework import permissions\nfrom common.utils import get_logger\n\nlogger = get_logger(__file__)\n\n\n__all__ = ['IsSessionAssignee']\n\n\nclass IsSessionAssignee(permissions.BasePermission):\n\n    def has_object_permission(self, request, view, obj):\n        try:\n            return obj.ticket_relation.first().ticket.has_all_assignee(request.user)\n        except:\n            return False\n", "from rest_framework import permissions\n\n\nclass IsAssignee(permissions.BasePermission):\n    def has_object_permission(self, request, view, obj):\n        return obj.has_current_assignee(request.user)\n\n\nclass IsApplicant(permissions.BasePermission):\n\n    def has_object_permission(self, request, view, obj):\n        return obj.applicant == request.user\n", "from rest_framework import permissions\n\nfrom rbac.builtin import BuiltinRole\nfrom .utils import is_auth_password_time_valid\n\n\nclass IsAuthPasswdTimeValid(permissions.IsAuthenticated):\n\n    def has_permission(self, request, view):\n        return super().has_permission(request, view) \\\n            and is_auth_password_time_valid(request.session)\n\n\nclass UserObjectPermission(permissions.BasePermission):\n\n    def has_object_permission(self, request, view, obj):\n        if view.action not in ['update', 'partial_update', 'destroy']:\n            return True\n\n        if not request.user.is_superuser and obj.is_superuser:\n            return False\n\n        return True\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n#\nimport time\n\nfrom django.conf import settings\nfrom rest_framework import permissions\n\nfrom authentication.const import ConfirmType\nfrom authentication.models import ConnectionToken\nfrom common.exceptions import UserConfirmRequired\nfrom common.utils import get_object_or_none\nfrom orgs.utils import tmp_to_root_org\n\n\nclass IsValidUser(permissions.IsAuthenticated):\n    \"\"\"Allows access to valid user, is active and not expired\"\"\"\n\n    def has_permission(self, request, view):\n        return super().has_permission(request, view) \\\n            and request.user.is_valid\n\n\nclass IsValidUserOrConnectionToken(IsValidUser):\n    def has_permission(self, request, view):\n        return super().has_permission(request, view) \\\n            or self.is_valid_connection_token(request)\n\n    @staticmethod\n    def is_valid_connection_token(request):\n        token_id = request.query_params.get('token')\n        if not token_id:\n            return False\n        with tmp_to_root_org():\n            token = get_object_or_none(ConnectionToken, id=token_id)\n        return token and token.is_valid\n\n\nclass OnlySuperUser(IsValidUser):\n    def has_permission(self, request, view):\n        return super().has_permission(request, view) \\\n            and request.user.is_superuser\n\n\nclass IsServiceAccount(IsValidUser):\n    def has_permission(self, request, view):\n        return super().has_permission(request, view) \\\n            and request.user.is_service_account\n\n\nclass WithBootstrapToken(permissions.BasePermission):\n    def has_permission(self, request, view):\n        authorization = request.META.get('HTTP_AUTHORIZATION', '')\n        if not authorization:\n            return False\n        request_bootstrap_token = authorization.split()[-1]\n        return settings.BOOTSTRAP_TOKEN == request_bootstrap_token\n\n\nclass UserConfirmation(permissions.BasePermission):\n    ttl = 60 * 5\n    min_level = 1\n    confirm_type = ConfirmType.ReLogin\n\n    def has_permission(self, request, view):\n        if not settings.SECURITY_VIEW_AUTH_NEED_MFA:\n            return True\n\n        confirm_level = request.session.get('CONFIRM_LEVEL')\n        confirm_time = request.session.get('CONFIRM_TIME')\n        ttl = self.get_ttl()\n        if not confirm_level or not confirm_time or \\\n                confirm_level < self.min_level or \\\n                confirm_time < time.time() - ttl:\n            raise UserConfirmRequired(code=self.confirm_type)\n        return True\n\n    def get_ttl(self):\n        if self.confirm_type == ConfirmType.MFA:\n            ttl = settings.SECURITY_MFA_VERIFY_TTL\n        else:\n            ttl = self.ttl\n        return ttl\n\n    @classmethod\n    def require(cls, confirm_type=ConfirmType.ReLogin, ttl=60 * 5):\n        min_level = ConfirmType.values.index(confirm_type) + 1\n        name = 'UserConfirmationLevel{}TTL{}'.format(min_level, ttl)\n        return type(name, (cls,), {'min_level': min_level, 'ttl': ttl, 'confirm_type': confirm_type})\n", "# ~*~ coding: utf-8 ~*~\n\npath_perms_map = {\n    'xpack': '*',\n    'settings': '*',\n    'replay': 'default',\n    'applets': 'terminal.view_applet',\n    'playbooks': 'ops.view_playbook'\n}\n\n\ndef allow_access(private_file):\n    request = private_file.request\n    request_path = private_file.request.path\n    path_list = str(request_path)[1:].split('/')\n    path_base = path_list[1] if len(path_list) > 1 else None\n    path_perm = path_perms_map.get(path_base, None)\n\n    if \"..\" in request_path:\n        return False\n    if not path_perm:\n        return False\n    if path_perm == '*' or request.user.has_perms([path_perm]):\n        return True\n    if path_perm == 'default':\n        return request.user.is_authenticated and request.user.is_staff\n    return False\n", "from rest_framework import permissions\n\nfrom common.utils import get_logger\n\nlogger = get_logger(__file__)\n\n__all__ = ['IsSessionAssignee']\n\n\nclass IsSessionAssignee(permissions.IsAuthenticated):\n    def has_permission(self, request, view):\n        return False\n\n    def has_object_permission(self, request, view, obj):\n        try:\n            return obj.ticket_relation.first().ticket.has_all_assignee(request.user)\n        except:\n            return False\n", "from rest_framework import permissions\n\n\nclass IsAssignee(permissions.IsAuthenticated):\n    def has_object_permission(self, request, view, obj):\n        return obj.has_current_assignee(request.user)\n\n\nclass IsApplicant(permissions.IsAuthenticated):\n\n    def has_object_permission(self, request, view, obj):\n        return obj.applicant == request.user\n", "from rest_framework import permissions\n\nfrom .utils import is_auth_password_time_valid\n\n\nclass IsAuthPasswdTimeValid(permissions.IsAuthenticated):\n\n    def has_permission(self, request, view):\n        return super().has_permission(request, view) \\\n            and is_auth_password_time_valid(request.session)\n\n\nclass UserObjectPermission(permissions.IsAuthenticated):\n\n    def has_object_permission(self, request, view, obj):\n        if view.action not in ['update', 'partial_update', 'destroy']:\n            return True\n\n        if not request.user.is_superuser and obj.is_superuser:\n            return False\n\n        return True\n"], "filenames": ["apps/common/permissions.py", "apps/jumpserver/rewriting/storage/permissions.py", "apps/terminal/permissions.py", "apps/tickets/permissions/ticket.py", "apps/users/permissions.py"], "buggy_code_start_loc": [15, 18, 1, 4, 3], "buggy_code_end_loc": [16, 18, 11, 10, 15], "fixing_code_start_loc": [15, 19, 2, 4, 2], "fixing_code_end_loc": [16, 21, 13, 10, 14], "type": "CWE-287", "message": "JumpServer is an open source bastion host and a professional operation and maintenance security audit system. Starting in version 3.0.0 and prior to versions 3.5.5 and 3.6.4, session replays can download without authentication. Session replays stored in S3, OSS, or other cloud storage are not affected. The api `/api/v1/terminal/sessions/` permission control is broken and can be accessed anonymously. SessionViewSet permission classes set to `[RBACPermission | IsSessionAssignee]`, relation is or, so any permission matched will be allowed. Versions 3.5.5 and 3.6.4 have a fix. After upgrading, visit the api `$HOST/api/v1/terminal/sessions/?limit=1`. The expected http response code is 401 (`not_authenticated`).\n", "other": {"cve": {"id": "CVE-2023-42442", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-15T21:15:11.867", "lastModified": "2023-09-20T19:33:14.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "JumpServer is an open source bastion host and a professional operation and maintenance security audit system. Starting in version 3.0.0 and prior to versions 3.5.5 and 3.6.4, session replays can download without authentication. Session replays stored in S3, OSS, or other cloud storage are not affected. The api `/api/v1/terminal/sessions/` permission control is broken and can be accessed anonymously. SessionViewSet permission classes set to `[RBACPermission | IsSessionAssignee]`, relation is or, so any permission matched will be allowed. Versions 3.5.5 and 3.6.4 have a fix. After upgrading, visit the api `$HOST/api/v1/terminal/sessions/?limit=1`. The expected http response code is 401 (`not_authenticated`).\n"}, {"lang": "es", "value": "JumpServer es un host basti\u00f3n de c\u00f3digo abierto y un sistema profesional de auditor\u00eda de seguridad de operaci\u00f3n y mantenimiento. A partir de la versi\u00f3n 3.0.0 y anteriores a las versiones 3.5.5 y 3.6.4, las repeticiones de sesiones se pueden descargar sin autenticaci\u00f3n. Las repeticiones de sesiones almacenadas en S3, OSS u otro almacenamiento en la nube no se ven afectadas. El control de permisos de la API `/api/v1/terminal/sessions/` est\u00e1 broken y se puede acceder a \u00e9l de forma an\u00f3nima. Clases de permiso SessionViewSet establecidas en `[RBACPermission | IsSessionAssignee]`, la relaci\u00f3n es o, por lo que se permitir\u00e1 cualquier permiso coincidente. Las versiones 3.5.5 y 3.6.4 tienen una soluci\u00f3n. Despu\u00e9s de actualizar, visite la API `$HOST/api/v1/terminal/sessions/?limit=1`. El c\u00f3digo de respuesta http esperado es 401 (\"not_authenticated\")."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fit2cloud:jumpserver:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.5.5", "matchCriteriaId": "C7BB0ACD-6502-4F86-83CE-31210024EC75"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fit2cloud:jumpserver:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.6.0", "versionEndExcluding": "3.6.4", "matchCriteriaId": "D2933823-4D5E-4335-BEF8-E3A3058F1C76"}]}]}], "references": [{"url": "https://github.com/jumpserver/jumpserver/blob/v3.6.1/apps/terminal/api/session/session.py#L91", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/jumpserver/jumpserver/commit/0a58bba59cd275bab8e0ae58bf4b359fbc5eb74a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/jumpserver/jumpserver/security/advisories/GHSA-633x-3f4f-v9rw", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jumpserver/jumpserver/commit/0a58bba59cd275bab8e0ae58bf4b359fbc5eb74a"}}