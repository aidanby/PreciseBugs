{"buggy_code": ["// Copyright 2020 The Matrix.org Foundation C.I.C.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// TODO\n//\n// handle the case where we can't create a session with a device. clearing our\n// stale key share requests that we'll never be able to handle.\n//\n// If we don't trust the device store an object that remembers the request and\n// let the users introspect that object.\n\nuse std::{collections::BTreeMap, sync::Arc};\n\nuse dashmap::{mapref::entry::Entry, DashMap, DashSet};\nuse ruma::{\n    api::client::keys::claim_keys::v3::Request as KeysClaimRequest,\n    events::secret::request::{\n        RequestAction, SecretName, ToDeviceSecretRequestEvent as SecretRequestEvent,\n    },\n    DeviceId, DeviceKeyAlgorithm, OwnedDeviceId, OwnedTransactionId, OwnedUserId, RoomId,\n    TransactionId, UserId,\n};\nuse tracing::{debug, info, trace, warn};\nuse vodozemac::{megolm::SessionOrdering, Curve25519PublicKey};\n\nuse super::{GossipRequest, KeyForwardDecision, RequestEvent, RequestInfo, SecretInfo, WaitQueue};\nuse crate::{\n    error::{EventError, OlmError, OlmResult},\n    olm::{InboundGroupSession, Session, ShareState},\n    requests::{OutgoingRequest, ToDeviceRequest},\n    session_manager::GroupSessionCache,\n    store::{Changes, CryptoStoreError, SecretImportError, Store},\n    types::{\n        events::{\n            forwarded_room_key::{ForwardedMegolmV1AesSha2Content, ForwardedRoomKeyContent},\n            olm_v1::{DecryptedForwardedRoomKeyEvent, DecryptedSecretSendEvent},\n            room::encrypted::EncryptedEvent,\n            room_key_request::{\n                Action, MegolmV1AesSha2Content, RequestedKeyInfo, RoomKeyRequestEvent,\n            },\n            secret_send::SecretSendContent,\n            EventType,\n        },\n        EventEncryptionAlgorithm,\n    },\n    Device, MegolmError,\n};\n\n#[derive(Debug, Clone)]\npub(crate) struct GossipMachine {\n    user_id: Arc<UserId>,\n    device_id: Arc<DeviceId>,\n    store: Store,\n    outbound_group_sessions: GroupSessionCache,\n    outgoing_requests: Arc<DashMap<OwnedTransactionId, OutgoingRequest>>,\n    incoming_key_requests: Arc<DashMap<RequestInfo, RequestEvent>>,\n    wait_queue: WaitQueue,\n    users_for_key_claim: Arc<DashMap<OwnedUserId, DashSet<OwnedDeviceId>>>,\n}\n\nimpl GossipMachine {\n    pub fn new(\n        user_id: Arc<UserId>,\n        device_id: Arc<DeviceId>,\n        store: Store,\n        outbound_group_sessions: GroupSessionCache,\n        users_for_key_claim: Arc<DashMap<OwnedUserId, DashSet<OwnedDeviceId>>>,\n    ) -> Self {\n        Self {\n            user_id,\n            device_id,\n            store,\n            outbound_group_sessions,\n            outgoing_requests: Default::default(),\n            incoming_key_requests: Default::default(),\n            wait_queue: WaitQueue::new(),\n            users_for_key_claim,\n        }\n    }\n\n    /// Load stored outgoing requests that were not yet sent out.\n    async fn load_outgoing_requests(&self) -> Result<Vec<OutgoingRequest>, CryptoStoreError> {\n        Ok(self\n            .store\n            .get_unsent_secret_requests()\n            .await?\n            .into_iter()\n            .filter(|i| !i.sent_out)\n            .map(|info| info.to_request(self.device_id()))\n            .collect())\n    }\n\n    /// Our own user id.\n    pub fn user_id(&self) -> &UserId {\n        &self.user_id\n    }\n\n    /// Our own device ID.\n    pub fn device_id(&self) -> &DeviceId {\n        &self.device_id\n    }\n\n    pub async fn outgoing_to_device_requests(\n        &self,\n    ) -> Result<Vec<OutgoingRequest>, CryptoStoreError> {\n        let mut key_requests = self.load_outgoing_requests().await?;\n        let key_forwards: Vec<OutgoingRequest> =\n            self.outgoing_requests.iter().map(|i| i.value().clone()).collect();\n        key_requests.extend(key_forwards);\n\n        let users_for_key_claim: BTreeMap<_, _> = self\n            .users_for_key_claim\n            .iter()\n            .map(|i| {\n                let device_map = i\n                    .value()\n                    .iter()\n                    .map(|d| (d.key().to_owned(), DeviceKeyAlgorithm::SignedCurve25519))\n                    .collect();\n\n                (i.key().to_owned(), device_map)\n            })\n            .collect();\n\n        if !users_for_key_claim.is_empty() {\n            let key_claim_request = KeysClaimRequest::new(users_for_key_claim);\n            key_requests.push(OutgoingRequest {\n                request_id: TransactionId::new(),\n                request: Arc::new(key_claim_request.into()),\n            });\n        }\n\n        Ok(key_requests)\n    }\n\n    /// Receive a room key request event.\n    pub fn receive_incoming_key_request(&self, event: &RoomKeyRequestEvent) {\n        self.receive_event(event.clone().into())\n    }\n\n    fn receive_event(&self, event: RequestEvent) {\n        // Some servers might send to-device events to ourselves if we send one\n        // out using a wildcard instead of a specific device as a recipient.\n        //\n        // Check if we're the sender of this request event and ignore it if\n        // so.\n        if event.sender() == self.user_id() && event.requesting_device_id() == self.device_id() {\n            trace!(\"Received a secret request event from ourselves, ignoring\")\n        } else {\n            let request_info = event.to_request_info();\n            self.incoming_key_requests.insert(request_info, event);\n        }\n    }\n\n    pub fn receive_incoming_secret_request(&self, event: &SecretRequestEvent) {\n        self.receive_event(event.clone().into())\n    }\n\n    /// Handle all the incoming key requests that are queued up and empty our\n    /// key request queue.\n    pub async fn collect_incoming_key_requests(&self) -> OlmResult<Vec<Session>> {\n        let mut changed_sessions = Vec::new();\n\n        for item in self.incoming_key_requests.iter() {\n            let event = item.value();\n\n            if let Some(s) = match event {\n                RequestEvent::KeyShare(e) => self.handle_key_request(e).await?,\n                RequestEvent::Secret(e) => self.handle_secret_request(e).await?,\n            } {\n                changed_sessions.push(s);\n            }\n        }\n\n        self.incoming_key_requests.clear();\n\n        Ok(changed_sessions)\n    }\n\n    /// Store the key share request for later, once we get an Olm session with\n    /// the given device [`retry_keyshare`](#method.retry_keyshare) should be\n    /// called.\n    fn handle_key_share_without_session(&self, device: Device, event: RequestEvent) {\n        self.users_for_key_claim\n            .entry(device.user_id().to_owned())\n            .or_default()\n            .insert(device.device_id().into());\n        self.wait_queue.insert(&device, event);\n    }\n\n    /// Retry keyshares for a device that previously didn't have an Olm session\n    /// with us.\n    ///\n    /// This should be only called if the given user/device got a new Olm\n    /// session.\n    ///\n    /// # Arguments\n    ///\n    /// * `user_id` - The user id of the device that we created the Olm session\n    /// with.\n    ///\n    /// * `device_id` - The device ID of the device that got the Olm session.\n    pub fn retry_keyshare(&self, user_id: &UserId, device_id: &DeviceId) {\n        if let Entry::Occupied(e) = self.users_for_key_claim.entry(user_id.to_owned()) {\n            e.get().remove(device_id);\n\n            if e.get().is_empty() {\n                e.remove();\n            }\n        }\n\n        for (key, event) in self.wait_queue.remove(user_id, device_id) {\n            if !self.incoming_key_requests.contains_key(&key) {\n                self.incoming_key_requests.insert(key, event);\n            }\n        }\n    }\n\n    async fn handle_secret_request(\n        &self,\n        event: &SecretRequestEvent,\n    ) -> OlmResult<Option<Session>> {\n        let secret_name = match &event.content.action {\n            RequestAction::Request(s) => s,\n            // We ignore cancellations here since there's nothing to serve.\n            RequestAction::RequestCancellation => return Ok(None),\n            action => {\n                warn!(?action, \"Unknown secret request action\");\n                return Ok(None);\n            }\n        };\n\n        let content = if let Some(secret) = self.store.export_secret(secret_name).await {\n            SecretSendContent::new(event.content.request_id.to_owned(), secret)\n        } else {\n            info!(?secret_name, \"Can't serve a secret request, secret isn't found\");\n            return Ok(None);\n        };\n\n        let device =\n            self.store.get_device(&event.sender, &event.content.requesting_device_id).await?;\n\n        Ok(if let Some(device) = device {\n            if device.user_id() == self.user_id() {\n                if device.is_verified() {\n                    info!(\n                        user_id = device.user_id().as_str(),\n                        device_id = device.device_id().as_str(),\n                        ?secret_name,\n                        \"Sharing a secret with a device\",\n                    );\n\n                    match self.share_secret(&device, content).await {\n                        Ok(s) => Ok(Some(s)),\n                        Err(OlmError::MissingSession) => {\n                            info!(\n                                user_id = device.user_id().as_str(),\n                                device_id = device.device_id().as_str(),\n                                secret_name = secret_name.as_ref(),\n                                \"Secret request is missing an Olm session, \\\n                                putting the request in the wait queue\",\n                            );\n                            self.handle_key_share_without_session(device, event.clone().into());\n\n                            Ok(None)\n                        }\n                        Err(e) => Err(e),\n                    }?\n                } else {\n                    info!(\n                        user_id = device.user_id().as_str(),\n                        device_id = device.device_id().as_str(),\n                        ?secret_name,\n                        \"Received a secret request that we won't serve, the device isn't trusted\",\n                    );\n\n                    None\n                }\n            } else {\n                info!(\n                    user_id = device.user_id().as_str(),\n                    device_id = device.device_id().as_str(),\n                    ?secret_name,\n                    \"Received a secret request that we won't serve, the device doesn't belong to us\",\n                );\n\n                None\n            }\n        } else {\n            warn!(\n                user_id = event.sender.as_str(),\n                device_id = event.content.requesting_device_id.as_str(),\n                ?secret_name,\n                \"Received a secret request form an unknown device\",\n            );\n            self.store.update_tracked_user(&event.sender, true).await?;\n\n            None\n        })\n    }\n\n    async fn handle_megolm_v1_request(\n        &self,\n        event: &RoomKeyRequestEvent,\n        key_info: &MegolmV1AesSha2Content,\n    ) -> OlmResult<Option<Session>> {\n        let session = self\n            .store\n            .get_inbound_group_session(\n                &key_info.room_id,\n                &key_info.sender_key.to_base64(),\n                &key_info.session_id,\n            )\n            .await?;\n\n        let session = if let Some(s) = session {\n            s\n        } else {\n            debug!(\n                user_id = event.sender.as_str(),\n                device_id = event.content.requesting_device_id.as_str(),\n                session_id = key_info.session_id.as_str(),\n                room_id = key_info.room_id.as_str(),\n                \"Received a room key request for an unknown inbound group session\",\n            );\n            return Ok(None);\n        };\n\n        let device =\n            self.store.get_device(&event.sender, &event.content.requesting_device_id).await?;\n\n        if let Some(device) = device {\n            match self.should_share_key(&device, &session).await {\n                Err(e) => {\n                    if let KeyForwardDecision::ChangedSenderKey = e {\n                        warn!(\n                            user_id = device.user_id().as_str(),\n                            device_id = device.device_id().as_str(),\n                            \"Received a key request from a device that changed \\\n                            their curve25519 sender key\"\n                        );\n                    } else {\n                        debug!(\n                            user_id = device.user_id().as_str(),\n                            device_id = device.device_id().as_str(),\n                            reason = ?e,\n                            \"Received a key request that we won't serve\",\n                        );\n                    }\n\n                    Ok(None)\n                }\n                Ok(message_index) => {\n                    info!(\n                        user_id = device.user_id().as_str(),\n                        device_id = device.device_id().as_str(),\n                        session_id = key_info.session_id.as_str(),\n                        room_id = key_info.room_id.as_str(),\n                        ?message_index,\n                        \"Serving a room key request\",\n                    );\n\n                    match self.share_session(&session, &device, message_index).await {\n                        Ok(s) => Ok(Some(s)),\n                        Err(OlmError::MissingSession) => {\n                            info!(\n                                user_id = device.user_id().as_str(),\n                                device_id = device.device_id().as_str(),\n                                session_id = key_info.session_id.as_str(),\n                                \"Key request is missing an Olm session, \\\n                                putting the request in the wait queue\",\n                            );\n                            self.handle_key_share_without_session(device, event.to_owned().into());\n\n                            Ok(None)\n                        }\n                        Err(OlmError::SessionExport(e)) => {\n                            warn!(\n                                user_id = device.user_id().as_str(),\n                                device_id = device.device_id().as_str(),\n                                session_id = key_info.session_id.as_str(),\n                                \"Can't serve a room key request, the session \\\n                                can't be exported into a forwarded room key: \\\n                                {:?}\",\n                                e\n                            );\n                            Ok(None)\n                        }\n                        Err(e) => Err(e),\n                    }\n                }\n            }\n        } else {\n            warn!(\n                user_id = event.sender.as_str(),\n                device_id = event.content.requesting_device_id.as_str(),\n                \"Received a key request from an unknown device\",\n            );\n            self.store.update_tracked_user(&event.sender, true).await?;\n\n            Ok(None)\n        }\n    }\n\n    /// Handle a single incoming key request.\n    async fn handle_key_request(&self, event: &RoomKeyRequestEvent) -> OlmResult<Option<Session>> {\n        match &event.content.action {\n            Action::Request(info) => match info {\n                RequestedKeyInfo::MegolmV1AesSha2(i) => {\n                    self.handle_megolm_v1_request(event, i).await\n                }\n                // V2 room key requests don't have a sender_key field, we\n                // currently can't fetch an inbound group session without a\n                // sender key, so ignore the request.\n                #[cfg(feature = \"experimental-algorithms\")]\n                RequestedKeyInfo::MegolmV2AesSha2(_) => Ok(None),\n                RequestedKeyInfo::Unknown(i) => {\n                    debug!(\n                        sender = %event.sender,\n                        algorithm = %i.algorithm,\n                        \"Received a room key request for a unsupported algorithm\"\n                    );\n                    Ok(None)\n                }\n            },\n            // We ignore cancellations here since there's nothing to serve.\n            Action::Cancellation => Ok(None),\n        }\n    }\n\n    async fn share_secret(\n        &self,\n        device: &Device,\n        content: SecretSendContent,\n    ) -> OlmResult<Session> {\n        let event_type = content.event_type();\n        let content = serde_json::to_value(content)?;\n        let (used_session, content) = device.encrypt(event_type, content).await?;\n\n        let request = ToDeviceRequest::new(\n            device.user_id(),\n            device.device_id().to_owned(),\n            content.event_type(),\n            content.cast(),\n        );\n\n        let request = OutgoingRequest {\n            request_id: request.txn_id.clone(),\n            request: Arc::new(request.into()),\n        };\n        self.outgoing_requests.insert(request.request_id.clone(), request);\n\n        Ok(used_session)\n    }\n\n    async fn share_session(\n        &self,\n        session: &InboundGroupSession,\n        device: &Device,\n        message_index: Option<u32>,\n    ) -> OlmResult<Session> {\n        let (used_session, content) =\n            device.encrypt_room_key_for_forwarding(session.clone(), message_index).await?;\n\n        let request = ToDeviceRequest::new(\n            device.user_id(),\n            device.device_id().to_owned(),\n            content.event_type(),\n            content.cast(),\n        );\n\n        let request = OutgoingRequest {\n            request_id: request.txn_id.clone(),\n            request: Arc::new(request.into()),\n        };\n        self.outgoing_requests.insert(request.request_id.clone(), request);\n\n        Ok(used_session)\n    }\n\n    /// Check if it's ok to share a session with the given device.\n    ///\n    /// The logic for this is currently as follows:\n    ///\n    /// * Share the session in full, starting from the earliest known index, if\n    /// the requesting device is our own, trusted (verified) device.\n    ///\n    /// * For other requesting devices, share only a limited session and only if\n    /// we originally shared with that device because it was present when the\n    /// message was initially sent. By limited, we mean that the session will\n    /// not be shared in full, but only from the message index at that moment.\n    /// Since this information is recorded in the outbound session, we need to\n    /// have it for this to work.\n    ///\n    /// * In all other cases, refuse to share the session.\n    ///\n    /// # Arguments\n    ///\n    /// * `device` - The device that is requesting a session from us.\n    ///\n    /// * `session` - The session that was requested to be shared.\n    ///\n    /// # Return value\n    ///\n    /// A `Result` representing whether we should share the session:\n    ///\n    /// - `Ok(None)`: Should share the entire session, starting with the\n    ///   earliest known index.\n    /// - `Ok(Some(i))`: Should share the session, but only starting from index\n    ///   i.\n    /// - `Err(x)`: Should *refuse* to share the session. `x` is the reason for\n    ///   the refusal.\n    async fn should_share_key(\n        &self,\n        device: &Device,\n        session: &InboundGroupSession,\n    ) -> Result<Option<u32>, KeyForwardDecision> {\n        let outbound_session = self\n            .outbound_group_sessions\n            .get_with_id(session.room_id(), session.session_id())\n            .await\n            .ok()\n            .flatten();\n\n        // If this is our own, verified device, we share the entire session from the\n        // earliest known index.\n        if device.user_id() == self.user_id() && device.is_verified() {\n            Ok(None)\n        // Otherwise, if the records show we previously shared with this device,\n        // we'll reshare the session from the index we previously shared\n        // at. For this, we need an outbound session because this\n        // information is recorded there.\n        } else if let Some(outbound) = outbound_session {\n            match outbound.is_shared_with(device) {\n                ShareState::Shared(message_index) => Ok(Some(message_index)),\n                ShareState::SharedButChangedSenderKey => Err(KeyForwardDecision::ChangedSenderKey),\n                ShareState::NotShared => Err(KeyForwardDecision::OutboundSessionNotShared),\n            }\n        // Otherwise, there's not enough info to decide if we can safely share\n        // the session.\n        } else if device.user_id() == self.user_id() {\n            Err(KeyForwardDecision::UntrustedDevice)\n        } else {\n            Err(KeyForwardDecision::MissingOutboundSession)\n        }\n    }\n\n    /// Check if it's ok, or rather if it makes sense to automatically request\n    /// a key from our other devices.\n    ///\n    /// # Arguments\n    ///\n    /// * `key_info` - The info of our key request containing information about\n    /// the key we wish to request.\n    async fn should_request_key(&self, key_info: &SecretInfo) -> Result<bool, CryptoStoreError> {\n        let request = self.store.get_secret_request_by_info(key_info).await?;\n\n        // Don't send out duplicate requests, users can re-request them if they\n        // think a second request might succeed.\n        if request.is_none() {\n            let devices = self.store.get_user_devices(self.user_id()).await?;\n\n            // Devices will only respond to key requests if the devices are\n            // verified, if the device isn't verified by us it's unlikely that\n            // we're verified by them either. Don't request keys if there isn't\n            // at least one verified device.\n            if devices.is_any_verified() {\n                Ok(true)\n            } else {\n                Ok(false)\n            }\n        } else {\n            Ok(false)\n        }\n    }\n\n    /// Create a new outgoing key request for the key with the given session id.\n    ///\n    /// This will queue up a new to-device request and store the key info so\n    /// once we receive a forwarded room key we can check that it matches the\n    /// key we requested.\n    ///\n    /// This method will return a cancel request and a new key request if the\n    /// key was already requested, otherwise it will return just the key\n    /// request.\n    ///\n    /// # Arguments\n    ///\n    /// * `room_id` - The id of the room where the key is used in.\n    ///\n    /// * `event` - The event for which we would like to request the room key.\n    pub async fn request_key(\n        &self,\n        room_id: &RoomId,\n        event: &EncryptedEvent,\n    ) -> Result<(Option<OutgoingRequest>, OutgoingRequest), MegolmError> {\n        let secret_info =\n            event.room_key_info(room_id).ok_or(EventError::UnsupportedAlgorithm)?.into();\n\n        let request = self.store.get_secret_request_by_info(&secret_info).await?;\n\n        if let Some(request) = request {\n            let cancel = request.to_cancellation(self.device_id());\n            let request = request.to_request(self.device_id());\n\n            Ok((Some(cancel), request))\n        } else {\n            let request = self.request_key_helper(secret_info).await?;\n\n            Ok((None, request))\n        }\n    }\n\n    /// Create outgoing secret requests for the given\n    pub fn request_missing_secrets(\n        own_user_id: &UserId,\n        secret_names: Vec<SecretName>,\n    ) -> Vec<GossipRequest> {\n        if !secret_names.is_empty() {\n            info!(?secret_names, \"Creating new outgoing secret requests\");\n\n            secret_names\n                .into_iter()\n                .map(|n| GossipRequest::from_secret_name(own_user_id.to_owned(), n))\n                .collect()\n        } else {\n            trace!(\"No secrets are missing from our store, not requesting them\");\n            vec![]\n        }\n    }\n\n    async fn request_key_helper(\n        &self,\n        key_info: SecretInfo,\n    ) -> Result<OutgoingRequest, CryptoStoreError> {\n        let request = GossipRequest {\n            request_recipient: self.user_id().to_owned(),\n            request_id: TransactionId::new(),\n            info: key_info,\n            sent_out: false,\n        };\n\n        let outgoing_request = request.to_request(self.device_id());\n        self.save_outgoing_key_info(request).await?;\n\n        Ok(outgoing_request)\n    }\n\n    /// Create a new outgoing key request for the key with the given session id.\n    ///\n    /// This will queue up a new to-device request and store the key info so\n    /// once we receive a forwarded room key we can check that it matches the\n    /// key we requested.\n    ///\n    /// This does nothing if a request for this key has already been sent out.\n    ///\n    /// # Arguments\n    /// * `room_id` - The id of the room where the key is used in.\n    ///\n    /// * `event` - The event for which we would like to request the room key.\n    pub async fn create_outgoing_key_request(\n        &self,\n        room_id: &RoomId,\n        event: &EncryptedEvent,\n    ) -> Result<bool, CryptoStoreError> {\n        Ok(if let Some(info) = event.room_key_info(room_id).map(|i| i.into()) {\n            if self.should_request_key(&info).await? {\n                self.request_key_helper(info).await?;\n                true\n            } else {\n                false\n            }\n        } else {\n            false\n        })\n    }\n\n    /// Save an outgoing key info.\n    async fn save_outgoing_key_info(&self, info: GossipRequest) -> Result<(), CryptoStoreError> {\n        let mut changes = Changes::default();\n        changes.key_requests.push(info);\n        self.store.save_changes(changes).await?;\n\n        Ok(())\n    }\n\n    /// Get an outgoing key info that matches the forwarded room key content.\n    async fn get_key_info(\n        &self,\n        event: &DecryptedForwardedRoomKeyEvent,\n    ) -> Result<Option<GossipRequest>, CryptoStoreError> {\n        if let Some(info) = event.room_key_info().map(|i| i.into()) {\n            self.store.get_secret_request_by_info(&info).await\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Delete the given outgoing key info.\n    async fn delete_key_info(&self, info: &GossipRequest) -> Result<(), CryptoStoreError> {\n        self.store.delete_outgoing_secret_requests(&info.request_id).await\n    }\n\n    /// Mark the outgoing request as sent.\n    pub async fn mark_outgoing_request_as_sent(\n        &self,\n        id: &TransactionId,\n    ) -> Result<(), CryptoStoreError> {\n        let info = self.store.get_outgoing_secret_requests(id).await?;\n\n        if let Some(mut info) = info {\n            trace!(\n                recipient = info.request_recipient.as_str(),\n                request_type = info.request_type(),\n                request_id = info.request_id.to_string().as_str(),\n                \"Marking outgoing key request as sent\"\n            );\n            info.sent_out = true;\n            self.save_outgoing_key_info(info).await?;\n        }\n\n        self.outgoing_requests.remove(id);\n\n        Ok(())\n    }\n\n    /// Mark the given outgoing key info as done.\n    ///\n    /// This will queue up a request cancellation.\n    async fn mark_as_done(&self, key_info: &GossipRequest) -> Result<(), CryptoStoreError> {\n        trace!(\n            recipient = key_info.request_recipient.as_str(),\n            request_type = key_info.request_type(),\n            request_id = key_info.request_id.to_string().as_str(),\n            \"Successfully received a secret, removing the request\"\n        );\n\n        self.outgoing_requests.remove(&key_info.request_id);\n        // TODO return the key info instead of deleting it so the sync handler\n        // can delete it in one transaction.\n        self.delete_key_info(key_info).await?;\n\n        let request = key_info.to_cancellation(self.device_id());\n        self.outgoing_requests.insert(request.request_id.clone(), request);\n\n        Ok(())\n    }\n\n    async fn accept_secret(\n        &self,\n        event: &DecryptedSecretSendEvent,\n        request: &GossipRequest,\n        secret_name: &SecretName,\n    ) -> Result<(), CryptoStoreError> {\n        if secret_name != &SecretName::RecoveryKey {\n            match self.store.import_secret(secret_name, &event.content.secret).await {\n                Ok(_) => self.mark_as_done(request).await?,\n                Err(e) => {\n                    // If this is a store error propagate it up\n                    // the call stack.\n                    if let SecretImportError::Store(e) = e {\n                        return Err(e);\n                    } else {\n                        // Otherwise warn that there was\n                        // something wrong with the secret.\n                        warn!(\n                            secret_name = secret_name.as_ref(),\n                            error = ?e,\n                            \"Error while importing a secret\"\n                        )\n                    }\n                }\n            }\n        } else {\n            // Skip importing the recovery key here since\n            // we'll want to check if the public key matches\n            // to the latest version on the server. The key\n            // will not be zeroized and\n            // instead leave the key in the event and let\n            // the user import it later.\n        }\n\n        Ok(())\n    }\n\n    async fn receive_secret(\n        &self,\n        sender_key: Curve25519PublicKey,\n        event: &DecryptedSecretSendEvent,\n        request: &GossipRequest,\n        secret_name: &SecretName,\n    ) -> Result<(), CryptoStoreError> {\n        debug!(\n            sender = event.sender.as_str(),\n            request_id = event.content.request_id.as_str(),\n            secret_name = secret_name.as_ref(),\n            \"Received a m.secret.send event with a matching request\"\n        );\n\n        if let Some(device) =\n            self.store.get_device_from_curve_key(&event.sender, sender_key).await?\n        {\n            // Only accept secrets from one of our own trusted devices.\n            if device.user_id() == self.user_id() && device.is_verified() {\n                self.accept_secret(event, request, secret_name).await?;\n            } else {\n                warn!(\n                    sender = event.sender.as_str(),\n                    request_id = event.content.request_id.as_str(),\n                    secret_name = secret_name.as_ref(),\n                    \"Received a m.secret.send event from another user or from \\\n                    unverified device\"\n                );\n            }\n        } else {\n            warn!(\n                sender = event.sender.as_str(),\n                request_id = event.content.request_id.as_str(),\n                secret_name = secret_name.as_ref(),\n                \"Received a m.secret.send event from an unknown device\"\n            );\n            self.store.update_tracked_user(&event.sender, true).await?;\n        }\n\n        Ok(())\n    }\n\n    pub async fn receive_secret_event(\n        &self,\n        sender_key: Curve25519PublicKey,\n        event: &DecryptedSecretSendEvent,\n    ) -> Result<Option<SecretName>, CryptoStoreError> {\n        debug!(\n            sender = event.sender.as_str(),\n            request_id = event.content.request_id.as_str(),\n            \"Received a m.secret.send event\"\n        );\n\n        let request_id = <&TransactionId>::from(event.content.request_id.as_str());\n\n        Ok(if let Some(request) = self.store.get_outgoing_secret_requests(request_id).await? {\n            match &request.info {\n                SecretInfo::KeyRequest(_) => {\n                    warn!(\n                        sender = event.sender.as_str(),\n                        request_id = event.content.request_id.as_str(),\n                        \"Received a m.secret.send event but the request was for a room key\"\n                    );\n\n                    None\n                }\n                SecretInfo::SecretRequest(secret_name) => {\n                    self.receive_secret(sender_key, event, &request, secret_name).await?;\n\n                    Some(secret_name.to_owned())\n                }\n            }\n        } else {\n            None\n        })\n    }\n\n    async fn accept_forwarded_room_key(\n        &self,\n        info: &GossipRequest,\n        sender: &UserId,\n        sender_key: Curve25519PublicKey,\n        algorithm: EventEncryptionAlgorithm,\n        content: &ForwardedMegolmV1AesSha2Content,\n    ) -> Result<Option<InboundGroupSession>, CryptoStoreError> {\n        match InboundGroupSession::from_forwarded_key(&algorithm, content) {\n            Ok(session) => {\n                let old_session = self\n                    .store\n                    .get_inbound_group_session(\n                        session.room_id(),\n                        &session.sender_key.to_base64(),\n                        session.session_id(),\n                    )\n                    .await?;\n\n                let session_id = session.session_id().to_owned();\n\n                // If we have a previous session, check if we have a better version\n                // and store the new one if so.\n                let session = if let Some(old_session) = old_session {\n                    if session.compare(&old_session).await == SessionOrdering::Better {\n                        self.mark_as_done(info).await?;\n                        Some(session)\n                    } else {\n                        None\n                    }\n                // If we didn't have a previous session, store it.\n                } else {\n                    self.mark_as_done(info).await?;\n                    Some(session)\n                };\n\n                if let Some(s) = &session {\n                    info!(\n                        %sender,\n                        sender_key = sender_key.to_base64(),\n                        claimed_sender_key = content.claimed_sender_key.to_base64(),\n                        room_id = s.room_id().as_str(),\n                        session_id = session_id.as_str(),\n                        %algorithm,\n                        \"Received a forwarded room key\",\n                    );\n                } else {\n                    info!(\n                        %sender,\n                        sender_key = sender_key.to_base64(),\n                        claimed_sender_key = content.claimed_sender_key.to_base64(),\n                        room_id = %content.room_id,\n                        session_id = session_id.as_str(),\n                        %algorithm,\n                        \"Received a forwarded room key but we already have a better version of it\",\n                    );\n                }\n\n                Ok(session)\n            }\n            Err(e) => {\n                warn!(\n                    %sender,\n                    sender_key = sender_key.to_base64(),\n                    claimed_sender_key = content.claimed_sender_key.to_base64(),\n                    room_id = content.room_id.as_str(),\n                    %algorithm,\n                    \"Couldn't create a group session from a received room key\"\n                );\n                Err(e.into())\n            }\n        }\n    }\n\n    /// Receive a forwarded room key event that was sent using any of our\n    /// supported content types.\n    async fn receive_supported_keys(\n        &self,\n        sender_key: Curve25519PublicKey,\n        event: &DecryptedForwardedRoomKeyEvent,\n        content: &ForwardedMegolmV1AesSha2Content,\n    ) -> Result<Option<InboundGroupSession>, CryptoStoreError> {\n        let algorithm = event.content.algorithm();\n\n        if let Some(info) = self.get_key_info(event).await? {\n            self.accept_forwarded_room_key(&info, &event.sender, sender_key, algorithm, content)\n                .await\n        } else {\n            warn!(\n                sender = %event.sender,\n                sender_key = %sender_key,\n                room_id = %content.room_id,\n                session_id = content.session_id.as_str(),\n                claimed_sender_key = %content.claimed_sender_key,\n                algorithm = %algorithm,\n                \"Received a forwarded room key that we didn't request\",\n            );\n\n            Ok(None)\n        }\n    }\n\n    /// Receive a forwarded room key event.\n    pub async fn receive_forwarded_room_key(\n        &self,\n        sender_key: Curve25519PublicKey,\n        event: &DecryptedForwardedRoomKeyEvent,\n    ) -> Result<Option<InboundGroupSession>, CryptoStoreError> {\n        match &event.content {\n            ForwardedRoomKeyContent::MegolmV1AesSha2(content) => {\n                self.receive_supported_keys(sender_key, event, content).await\n            }\n            #[cfg(feature = \"experimental-algorithms\")]\n            ForwardedRoomKeyContent::MegolmV2AesSha2(content) => {\n                self.receive_supported_keys(sender_key, event, content).await\n            }\n            ForwardedRoomKeyContent::Unknown(_) => {\n                warn!(\n                    sender = event.sender.as_str(),\n                    sender_key = sender_key.to_base64(),\n                    algorithm = %event.content.algorithm(),\n                    \"Received a forwarded room key with an unsupported algorithm\",\n                );\n\n                Ok(None)\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::sync::Arc;\n\n    use dashmap::DashMap;\n    use matches::assert_matches;\n    use matrix_sdk_common::locks::Mutex;\n    use matrix_sdk_test::async_test;\n    use ruma::{\n        device_id, event_id,\n        events::{\n            secret::request::{RequestAction, SecretName, ToDeviceSecretRequestEventContent},\n            AnyToDeviceEventContent, ToDeviceEvent as RumaToDeviceEvent,\n        },\n        room_id,\n        serde::Raw,\n        user_id, DeviceId, RoomId, UserId,\n    };\n    use serde::{de::DeserializeOwned, Serialize};\n    use serde_json::json;\n\n    use super::{GossipMachine, KeyForwardDecision};\n    use crate::{\n        identities::{LocalTrust, ReadOnlyDevice},\n        olm::{Account, OutboundGroupSession, PrivateCrossSigningIdentity, ReadOnlyAccount},\n        session_manager::GroupSessionCache,\n        store::{Changes, CryptoStore, MemoryStore, Store},\n        types::events::{\n            forwarded_room_key::ForwardedRoomKeyContent,\n            olm_v1::{AnyDecryptedOlmEvent, DecryptedOlmV1Event},\n            room::encrypted::{EncryptedEvent, EncryptedToDeviceEvent, RoomEncryptedEventContent},\n            EventType, ToDeviceEvent,\n        },\n        verification::VerificationMachine,\n        OutgoingRequest, OutgoingRequests,\n    };\n\n    fn alice_id() -> &'static UserId {\n        user_id!(\"@alice:example.org\")\n    }\n\n    fn alice_device_id() -> &'static DeviceId {\n        device_id!(\"JLAFKJWSCS\")\n    }\n\n    fn bob_id() -> &'static UserId {\n        user_id!(\"@bob:example.org\")\n    }\n\n    fn bob_device_id() -> &'static DeviceId {\n        device_id!(\"ILMLKASTES\")\n    }\n\n    fn alice2_device_id() -> &'static DeviceId {\n        device_id!(\"ILMLKASTES\")\n    }\n\n    fn room_id() -> &'static RoomId {\n        room_id!(\"!test:example.org\")\n    }\n\n    fn account() -> ReadOnlyAccount {\n        ReadOnlyAccount::new(alice_id(), alice_device_id())\n    }\n\n    fn bob_account() -> ReadOnlyAccount {\n        ReadOnlyAccount::new(bob_id(), bob_device_id())\n    }\n\n    fn alice_2_account() -> ReadOnlyAccount {\n        ReadOnlyAccount::new(alice_id(), alice2_device_id())\n    }\n\n    fn test_gossip_machine(user_id: &UserId) -> GossipMachine {\n        let user_id = Arc::from(user_id);\n        let device_id = DeviceId::new();\n\n        let account = ReadOnlyAccount::new(&user_id, &device_id);\n        let store: Arc<dyn CryptoStore> = Arc::new(MemoryStore::new());\n        let identity = Arc::new(Mutex::new(PrivateCrossSigningIdentity::empty(alice_id())));\n        let verification = VerificationMachine::new(account, identity.clone(), store.clone());\n        let store = Store::new(user_id.to_owned(), identity, store, verification);\n        let session_cache = GroupSessionCache::new(store.clone());\n\n        GossipMachine::new(\n            user_id,\n            device_id.into(),\n            store,\n            session_cache,\n            Arc::new(DashMap::new()),\n        )\n    }\n\n    async fn get_machine() -> GossipMachine {\n        let user_id: Arc<UserId> = alice_id().into();\n        let account = ReadOnlyAccount::new(&user_id, alice_device_id());\n        let device = ReadOnlyDevice::from_account(&account).await;\n        let another_device =\n            ReadOnlyDevice::from_account(&ReadOnlyAccount::new(&user_id, alice2_device_id())).await;\n\n        let store: Arc<dyn CryptoStore> = Arc::new(MemoryStore::new());\n        let identity = Arc::new(Mutex::new(PrivateCrossSigningIdentity::empty(alice_id())));\n        let verification = VerificationMachine::new(account, identity.clone(), store.clone());\n\n        let store = Store::new(user_id.clone(), identity, store, verification);\n        store.save_devices(&[device, another_device]).await.unwrap();\n        let session_cache = GroupSessionCache::new(store.clone());\n\n        GossipMachine::new(\n            user_id,\n            alice_device_id().into(),\n            store,\n            session_cache,\n            Arc::new(DashMap::new()),\n        )\n    }\n\n    async fn machines_for_key_share(\n        create_sessions: bool,\n    ) -> (GossipMachine, Account, OutboundGroupSession, GossipMachine) {\n        let alice_machine = get_machine().await;\n        let alice_account = Account {\n            inner: alice_machine.store.account().clone(),\n            store: alice_machine.store.clone(),\n        };\n        let alice_device = ReadOnlyDevice::from_account(alice_machine.store.account()).await;\n\n        let bob_machine = test_gossip_machine(alice_id());\n        let bob_device = ReadOnlyDevice::from_account(bob_machine.store.account()).await;\n\n        // We need a trusted device, otherwise we won't request keys\n        bob_device.set_trust_state(LocalTrust::Verified);\n        alice_machine.store.save_devices(&[bob_device]).await.unwrap();\n        bob_machine.store.save_devices(&[alice_device.clone()]).await.unwrap();\n\n        if create_sessions {\n            // Create Olm sessions for our two accounts.\n            let (alice_session, bob_session) =\n                alice_machine.store.account().create_session_for(bob_machine.store.account()).await;\n\n            // Populate our stores with Olm sessions and a Megolm session.\n\n            alice_machine.store.save_sessions(&[alice_session]).await.unwrap();\n            bob_machine.store.save_sessions(&[bob_session]).await.unwrap();\n        }\n\n        let (group_session, inbound_group_session) =\n            bob_machine.store.account().create_group_session_pair_with_defaults(room_id()).await;\n\n        let content = group_session.encrypt(json!({}), \"m.dummy\").await;\n        let event = wrap_encrypted_content(bob_machine.user_id(), content);\n        bob_machine.store.save_inbound_group_sessions(&[inbound_group_session]).await.unwrap();\n\n        // Alice wants to request the outbound group session from bob.\n        assert!(\n            alice_machine.create_outgoing_key_request(room_id(), &event,).await.unwrap(),\n            \"We should request a room key\"\n        );\n\n        group_session\n            .mark_shared_with(\n                alice_device.user_id(),\n                alice_device.device_id(),\n                alice_device.curve25519_key().unwrap(),\n            )\n            .await;\n\n        // Put the outbound session into bobs store.\n        bob_machine.outbound_group_sessions.insert(group_session.clone());\n\n        (alice_machine, alice_account, group_session, bob_machine)\n    }\n\n    fn extract_content<'a>(\n        recipient: &UserId,\n        request: &'a OutgoingRequest,\n    ) -> &'a Raw<AnyToDeviceEventContent> {\n        request\n            .request()\n            .to_device()\n            .expect(\"The request should be always a to-device request\")\n            .messages\n            .get(recipient)\n            .unwrap()\n            .values()\n            .next()\n            .unwrap()\n    }\n\n    fn wrap_encrypted_content(\n        sender: &UserId,\n        content: Raw<RoomEncryptedEventContent>,\n    ) -> EncryptedEvent {\n        let content = content.deserialize().unwrap();\n\n        EncryptedEvent {\n            sender: sender.to_owned(),\n            event_id: event_id!(\"$143273582443PhrSn:example.org\").to_owned(),\n            content,\n            origin_server_ts: ruma::MilliSecondsSinceUnixEpoch::now(),\n            unsigned: Default::default(),\n            other: Default::default(),\n        }\n    }\n\n    fn request_to_event<C>(\n        recipient: &UserId,\n        sender: &UserId,\n        request: &OutgoingRequest,\n    ) -> ToDeviceEvent<C>\n    where\n        C: EventType + DeserializeOwned + Serialize + std::fmt::Debug,\n    {\n        let content = extract_content(recipient, request);\n        let content: C = content\n            .deserialize_as()\n            .expect(\"We can always deserialize the to-device event content\");\n\n        ToDeviceEvent::new(sender.to_owned(), content)\n    }\n\n    #[async_test]\n    async fn create_machine() {\n        let machine = get_machine().await;\n\n        assert!(machine.outgoing_to_device_requests().await.unwrap().is_empty());\n    }\n\n    #[async_test]\n    async fn re_request_keys() {\n        let machine = get_machine().await;\n        let account = account();\n\n        let (outbound, session) = account.create_group_session_pair_with_defaults(room_id()).await;\n\n        let content = outbound.encrypt(json!({}), \"m.dummy\").await;\n        let event = wrap_encrypted_content(machine.user_id(), content);\n\n        assert!(machine.outgoing_to_device_requests().await.unwrap().is_empty());\n        let (cancel, request) = machine.request_key(session.room_id(), &event).await.unwrap();\n\n        assert!(cancel.is_none());\n\n        machine.mark_outgoing_request_as_sent(&request.request_id).await.unwrap();\n\n        let (cancel, _) = machine.request_key(session.room_id(), &event).await.unwrap();\n\n        assert!(cancel.is_some());\n    }\n\n    #[async_test]\n    async fn create_key_request() {\n        let machine = get_machine().await;\n        let account = account();\n        let second_account = alice_2_account();\n        let alice_device = ReadOnlyDevice::from_account(&second_account).await;\n\n        // We need a trusted device, otherwise we won't request keys\n        alice_device.set_trust_state(LocalTrust::Verified);\n        machine.store.save_devices(&[alice_device]).await.unwrap();\n\n        let (outbound, session) = account.create_group_session_pair_with_defaults(room_id()).await;\n        let content = outbound.encrypt(json!({}), \"m.dummy\").await;\n        let event = wrap_encrypted_content(machine.user_id(), content);\n\n        assert!(machine.outgoing_to_device_requests().await.unwrap().is_empty());\n        machine.create_outgoing_key_request(session.room_id(), &event).await.unwrap();\n        assert!(!machine.outgoing_to_device_requests().await.unwrap().is_empty());\n        assert_eq!(machine.outgoing_to_device_requests().await.unwrap().len(), 1);\n\n        machine.create_outgoing_key_request(session.room_id(), &event).await.unwrap();\n\n        let requests = machine.outgoing_to_device_requests().await.unwrap();\n        assert_eq!(requests.len(), 1);\n\n        let request = requests.get(0).unwrap();\n\n        machine.mark_outgoing_request_as_sent(&request.request_id).await.unwrap();\n        assert!(machine.outgoing_to_device_requests().await.unwrap().is_empty());\n    }\n\n    #[async_test]\n    async fn receive_forwarded_key() {\n        let machine = get_machine().await;\n        let account = account();\n\n        let second_account = alice_2_account();\n        let alice_device = ReadOnlyDevice::from_account(&second_account).await;\n\n        // We need a trusted device, otherwise we won't request keys\n        alice_device.set_trust_state(LocalTrust::Verified);\n        machine.store.save_devices(&[alice_device.clone()]).await.unwrap();\n\n        let (outbound, session) = account.create_group_session_pair_with_defaults(room_id()).await;\n        let content = outbound.encrypt(json!({}), \"m.dummy\").await;\n        let room_event = wrap_encrypted_content(machine.user_id(), content);\n\n        machine.create_outgoing_key_request(session.room_id(), &room_event).await.unwrap();\n\n        let requests = machine.outgoing_to_device_requests().await.unwrap();\n        let request = requests.get(0).unwrap();\n        let id = &request.request_id;\n\n        machine.mark_outgoing_request_as_sent(id).await.unwrap();\n\n        let export = session.export_at_index(10).await;\n\n        let content: ForwardedRoomKeyContent = export.try_into().unwrap();\n\n        let event = DecryptedOlmV1Event::new(\n            alice_id(),\n            alice_id(),\n            alice_device.ed25519_key().unwrap(),\n            content,\n        );\n\n        assert!(machine\n            .store\n            .get_inbound_group_session(\n                session.room_id(),\n                &session.sender_key.to_base64(),\n                session.session_id(),\n            )\n            .await\n            .unwrap()\n            .is_none());\n\n        let first_session = machine\n            .receive_forwarded_room_key(alice_device.curve25519_key().unwrap(), &event)\n            .await\n            .unwrap();\n        let first_session = first_session.unwrap();\n\n        assert_eq!(first_session.first_known_index(), 10);\n\n        machine.store.save_inbound_group_sessions(&[first_session.clone()]).await.unwrap();\n\n        // Get the cancel request.\n        let request = machine.outgoing_requests.iter().next().unwrap();\n        let id = request.request_id.clone();\n        drop(request);\n        machine.mark_outgoing_request_as_sent(&id).await.unwrap();\n\n        machine.create_outgoing_key_request(session.room_id(), &room_event).await.unwrap();\n\n        let requests = machine.outgoing_to_device_requests().await.unwrap();\n        let request = &requests[0];\n\n        machine.mark_outgoing_request_as_sent(&request.request_id).await.unwrap();\n\n        let export = session.export_at_index(15).await;\n\n        let content: ForwardedRoomKeyContent = export.try_into().unwrap();\n\n        let event = DecryptedOlmV1Event::new(\n            alice_id(),\n            alice_id(),\n            alice_device.ed25519_key().unwrap(),\n            content,\n        );\n\n        let second_session = machine\n            .receive_forwarded_room_key(alice_device.curve25519_key().unwrap(), &event)\n            .await\n            .unwrap();\n\n        assert!(second_session.is_none());\n\n        let export = session.export_at_index(0).await;\n\n        let content: ForwardedRoomKeyContent = export.try_into().unwrap();\n\n        let event = DecryptedOlmV1Event::new(\n            alice_id(),\n            alice_id(),\n            alice_device.ed25519_key().unwrap(),\n            content,\n        );\n\n        let second_session = machine\n            .receive_forwarded_room_key(alice_device.curve25519_key().unwrap(), &event)\n            .await\n            .unwrap();\n\n        assert_eq!(second_session.unwrap().first_known_index(), 0);\n    }\n\n    #[async_test]\n    async fn should_share_key_test() {\n        let machine = get_machine().await;\n        let account = account();\n\n        let own_device =\n            machine.store.get_device(alice_id(), alice2_device_id()).await.unwrap().unwrap();\n\n        let (outbound, inbound) = account.create_group_session_pair_with_defaults(room_id()).await;\n\n        // We don't share keys with untrusted devices.\n        assert_matches!(\n            machine.should_share_key(&own_device, &inbound).await,\n            Err(KeyForwardDecision::UntrustedDevice)\n        );\n        own_device.set_trust_state(LocalTrust::Verified);\n        // Now we do want to share the keys.\n        machine.should_share_key(&own_device, &inbound).await.unwrap();\n\n        let bob_device = ReadOnlyDevice::from_account(&bob_account()).await;\n        machine.store.save_devices(&[bob_device]).await.unwrap();\n\n        let bob_device =\n            machine.store.get_device(bob_id(), bob_device_id()).await.unwrap().unwrap();\n\n        // We don't share sessions with other user's devices if no outbound\n        // session was provided.\n        assert_matches!(\n            machine.should_share_key(&bob_device, &inbound).await,\n            Err(KeyForwardDecision::MissingOutboundSession)\n        );\n\n        let mut changes = Changes::default();\n\n        changes.outbound_group_sessions.push(outbound.clone());\n        changes.inbound_group_sessions.push(inbound.clone());\n        machine.store.save_changes(changes).await.unwrap();\n        machine.outbound_group_sessions.insert(outbound.clone());\n\n        // We don't share sessions with other user's devices if the session\n        // wasn't shared in the first place.\n        assert_matches!(\n            machine.should_share_key(&bob_device, &inbound).await,\n            Err(KeyForwardDecision::OutboundSessionNotShared)\n        );\n\n        bob_device.set_trust_state(LocalTrust::Verified);\n\n        // We don't share sessions with other user's devices if the session\n        // wasn't shared in the first place even if the device is trusted.\n        assert_matches!(\n            machine.should_share_key(&bob_device, &inbound).await,\n            Err(KeyForwardDecision::OutboundSessionNotShared)\n        );\n\n        // We now share the session, since it was shared before.\n        outbound\n            .mark_shared_with(\n                bob_device.user_id(),\n                bob_device.device_id(),\n                bob_device.curve25519_key().unwrap(),\n            )\n            .await;\n        machine.should_share_key(&bob_device, &inbound).await.unwrap();\n\n        let (other_outbound, other_inbound) =\n            account.create_group_session_pair_with_defaults(room_id()).await;\n\n        // But we don't share some other session that doesn't match our outbound\n        // session.\n        assert_matches!(\n            machine.should_share_key(&bob_device, &other_inbound).await,\n            Err(KeyForwardDecision::MissingOutboundSession)\n        );\n\n        // Finally, let's ensure we don't share the session with a device that rotated\n        // its curve25519 key.\n        let bob_device = ReadOnlyDevice::from_account(&bob_account()).await;\n        machine.store.save_devices(&[bob_device]).await.unwrap();\n\n        let bob_device =\n            machine.store.get_device(bob_id(), bob_device_id()).await.unwrap().unwrap();\n        assert_matches!(\n            machine.should_share_key(&bob_device, &inbound).await,\n            Err(KeyForwardDecision::ChangedSenderKey)\n        );\n\n        // Now let's encrypt some messages in another session to increment the message\n        // index and then share it with our own untrusted device.\n        own_device.set_trust_state(LocalTrust::Unset);\n\n        for _ in 1..=3 {\n            other_outbound.encrypt_helper(\"foo\".to_owned()).await;\n        }\n        other_outbound\n            .mark_shared_with(\n                own_device.user_id(),\n                own_device.device_id(),\n                own_device.curve25519_key().unwrap(),\n            )\n            .await;\n\n        machine.outbound_group_sessions.insert(other_outbound.clone());\n\n        // Since our device is untrusted, we should share the session starting only from\n        // the current index (at which the message was marked as shared). This\n        // should be 3 since we encrypted 3 messages.\n        assert_matches!(machine.should_share_key(&own_device, &other_inbound).await, Ok(Some(3)));\n\n        own_device.set_trust_state(LocalTrust::Verified);\n\n        // However once our device is trusted, we share the entire session.\n        assert_matches!(machine.should_share_key(&own_device, &other_inbound).await, Ok(None));\n    }\n\n    #[async_test]\n    async fn key_share_cycle() {\n        let (alice_machine, alice_account, group_session, bob_machine) =\n            machines_for_key_share(true).await;\n\n        // Get the request and convert it into a event.\n        let requests = alice_machine.outgoing_to_device_requests().await.unwrap();\n        let request = &requests[0];\n        let event = request_to_event(alice_id(), alice_id(), request);\n\n        alice_machine.mark_outgoing_request_as_sent(&request.request_id).await.unwrap();\n\n        // Bob doesn't have any outgoing requests.\n        assert!(bob_machine.outgoing_requests.is_empty());\n\n        // Receive the room key request from alice.\n        bob_machine.receive_incoming_key_request(&event);\n        bob_machine.collect_incoming_key_requests().await.unwrap();\n        // Now bob does have an outgoing request.\n        assert!(!bob_machine.outgoing_requests.is_empty());\n\n        // Get the request and convert it to a encrypted to-device event.\n        let requests = bob_machine.outgoing_to_device_requests().await.unwrap();\n        let request = &requests[0];\n\n        let event: EncryptedToDeviceEvent = request_to_event(alice_id(), alice_id(), request);\n        bob_machine.mark_outgoing_request_as_sent(&request.request_id).await.unwrap();\n\n        // Check that alice doesn't have the session.\n        assert!(alice_machine\n            .store\n            .get_inbound_group_session(\n                room_id(),\n                &bob_machine.store.account().identity_keys().curve25519.to_base64(),\n                group_session.session_id()\n            )\n            .await\n            .unwrap()\n            .is_none());\n\n        let decrypted = alice_account.decrypt_to_device_event(&event).await.unwrap();\n\n        if let AnyDecryptedOlmEvent::ForwardedRoomKey(e) = decrypted.result.event {\n            let session = alice_machine\n                .receive_forwarded_room_key(decrypted.result.sender_key, &e)\n                .await\n                .unwrap();\n            alice_machine.store.save_inbound_group_sessions(&[session.unwrap()]).await.unwrap();\n        } else {\n            panic!(\"Invalid decrypted event type\");\n        }\n\n        // Check that alice now does have the session.\n        let session = alice_machine\n            .store\n            .get_inbound_group_session(\n                room_id(),\n                &decrypted.result.sender_key.to_base64(),\n                group_session.session_id(),\n            )\n            .await\n            .unwrap()\n            .unwrap();\n\n        assert_eq!(session.session_id(), group_session.session_id())\n    }\n\n    #[async_test]\n    async fn secret_share_cycle() {\n        let alice_machine = get_machine().await;\n        let alice_account = Account { inner: account(), store: alice_machine.store.clone() };\n\n        let second_account = alice_2_account();\n        let alice_device = ReadOnlyDevice::from_account(&second_account).await;\n\n        let bob_account = bob_account();\n        let bob_device = ReadOnlyDevice::from_account(&bob_account).await;\n\n        alice_machine.store.save_devices(&[alice_device.clone()]).await.unwrap();\n\n        // Create Olm sessions for our two accounts.\n        let (alice_session, _) = alice_account.create_session_for(&second_account).await;\n\n        alice_machine.store.save_sessions(&[alice_session]).await.unwrap();\n\n        let event = RumaToDeviceEvent {\n            sender: bob_account.user_id().to_owned(),\n            content: ToDeviceSecretRequestEventContent::new(\n                RequestAction::Request(SecretName::CrossSigningMasterKey),\n                bob_account.device_id().to_owned(),\n                \"request_id\".into(),\n            ),\n        };\n\n        // No secret found\n        assert!(alice_machine.outgoing_requests.is_empty());\n        alice_machine.receive_incoming_secret_request(&event);\n        alice_machine.collect_incoming_key_requests().await.unwrap();\n        assert!(alice_machine.outgoing_requests.is_empty());\n\n        // No device found\n        alice_machine.store.reset_cross_signing_identity().await;\n        alice_machine.receive_incoming_secret_request(&event);\n        alice_machine.collect_incoming_key_requests().await.unwrap();\n        assert!(alice_machine.outgoing_requests.is_empty());\n\n        alice_machine.store.save_devices(&[bob_device]).await.unwrap();\n\n        // The device doesn't belong to us\n        alice_machine.store.reset_cross_signing_identity().await;\n        alice_machine.receive_incoming_secret_request(&event);\n        alice_machine.collect_incoming_key_requests().await.unwrap();\n        assert!(alice_machine.outgoing_requests.is_empty());\n\n        let event = RumaToDeviceEvent {\n            sender: alice_id().to_owned(),\n            content: ToDeviceSecretRequestEventContent::new(\n                RequestAction::Request(SecretName::CrossSigningMasterKey),\n                second_account.device_id().into(),\n                \"request_id\".into(),\n            ),\n        };\n\n        // The device isn't trusted\n        alice_machine.receive_incoming_secret_request(&event);\n        alice_machine.collect_incoming_key_requests().await.unwrap();\n        assert!(alice_machine.outgoing_requests.is_empty());\n\n        // We need a trusted device, otherwise we won't serve secrets\n        alice_device.set_trust_state(LocalTrust::Verified);\n        alice_machine.store.save_devices(&[alice_device.clone()]).await.unwrap();\n\n        alice_machine.receive_incoming_secret_request(&event);\n        alice_machine.collect_incoming_key_requests().await.unwrap();\n        assert!(!alice_machine.outgoing_requests.is_empty());\n    }\n\n    #[async_test]\n    async fn key_share_cycle_without_session() {\n        let (alice_machine, alice_account, group_session, bob_machine) =\n            machines_for_key_share(false).await;\n\n        // Get the request and convert it into a event.\n        let requests = alice_machine.outgoing_to_device_requests().await.unwrap();\n        let request = &requests[0];\n        let event = request_to_event(alice_id(), alice_id(), request);\n\n        alice_machine.mark_outgoing_request_as_sent(&request.request_id).await.unwrap();\n\n        // Bob doesn't have any outgoing requests.\n        assert!(bob_machine.outgoing_to_device_requests().await.unwrap().is_empty());\n        assert!(bob_machine.users_for_key_claim.is_empty());\n        assert!(bob_machine.wait_queue.is_empty());\n\n        // Receive the room key request from alice.\n        bob_machine.receive_incoming_key_request(&event);\n        bob_machine.collect_incoming_key_requests().await.unwrap();\n        // Bob only has a keys claim request, since we're lacking a session\n        assert_eq!(bob_machine.outgoing_to_device_requests().await.unwrap().len(), 1);\n        assert_matches!(\n            bob_machine.outgoing_to_device_requests().await.unwrap().first().unwrap().request(),\n            OutgoingRequests::KeysClaim(_)\n        );\n        assert!(!bob_machine.users_for_key_claim.is_empty());\n        assert!(!bob_machine.wait_queue.is_empty());\n\n        let (alice_session, bob_session) =\n            alice_machine.store.account().create_session_for(bob_machine.store.account()).await;\n        // We create a session now.\n        alice_machine.store.save_sessions(&[alice_session]).await.unwrap();\n        bob_machine.store.save_sessions(&[bob_session]).await.unwrap();\n\n        bob_machine.retry_keyshare(alice_id(), alice_device_id());\n        assert!(bob_machine.users_for_key_claim.is_empty());\n        bob_machine.collect_incoming_key_requests().await.unwrap();\n        // Bob now has an outgoing requests.\n        assert!(!bob_machine.outgoing_to_device_requests().await.unwrap().is_empty());\n        assert!(bob_machine.wait_queue.is_empty());\n\n        // Get the request and convert it to a encrypted to-device event.\n        let requests = bob_machine.outgoing_to_device_requests().await.unwrap();\n        let request = &requests[0];\n\n        let event: EncryptedToDeviceEvent = request_to_event(alice_id(), alice_id(), request);\n        bob_machine.mark_outgoing_request_as_sent(&request.request_id).await.unwrap();\n\n        // Check that alice doesn't have the session.\n        assert!(alice_machine\n            .store\n            .get_inbound_group_session(\n                room_id(),\n                &bob_machine.store.account().identity_keys().curve25519.to_base64(),\n                group_session.session_id()\n            )\n            .await\n            .unwrap()\n            .is_none());\n\n        let decrypted = alice_account.decrypt_to_device_event(&event).await.unwrap();\n\n        if let AnyDecryptedOlmEvent::ForwardedRoomKey(e) = decrypted.result.event {\n            let session = alice_machine\n                .receive_forwarded_room_key(decrypted.result.sender_key, &e)\n                .await\n                .unwrap();\n            alice_machine.store.save_inbound_group_sessions(&[session.unwrap()]).await.unwrap();\n        } else {\n            panic!(\"Invalid decrypted event type\");\n        }\n\n        // Check that alice now does have the session.\n        let session = alice_machine\n            .store\n            .get_inbound_group_session(\n                room_id(),\n                &decrypted.result.sender_key.to_base64(),\n                group_session.session_id(),\n            )\n            .await\n            .unwrap()\n            .unwrap();\n\n        assert_eq!(session.session_id(), group_session.session_id())\n    }\n}\n"], "fixing_code": ["// Copyright 2020 The Matrix.org Foundation C.I.C.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// TODO\n//\n// handle the case where we can't create a session with a device. clearing our\n// stale key share requests that we'll never be able to handle.\n//\n// If we don't trust the device store an object that remembers the request and\n// let the users introspect that object.\n\nuse std::{collections::BTreeMap, sync::Arc};\n\nuse dashmap::{mapref::entry::Entry, DashMap, DashSet};\nuse ruma::{\n    api::client::keys::claim_keys::v3::Request as KeysClaimRequest,\n    events::secret::request::{\n        RequestAction, SecretName, ToDeviceSecretRequestEvent as SecretRequestEvent,\n    },\n    DeviceId, DeviceKeyAlgorithm, OwnedDeviceId, OwnedTransactionId, OwnedUserId, RoomId,\n    TransactionId, UserId,\n};\nuse tracing::{debug, info, trace, warn};\nuse vodozemac::{megolm::SessionOrdering, Curve25519PublicKey};\n\nuse super::{GossipRequest, KeyForwardDecision, RequestEvent, RequestInfo, SecretInfo, WaitQueue};\nuse crate::{\n    error::{EventError, OlmError, OlmResult},\n    olm::{InboundGroupSession, Session, ShareState},\n    requests::{OutgoingRequest, ToDeviceRequest},\n    session_manager::GroupSessionCache,\n    store::{Changes, CryptoStoreError, SecretImportError, Store},\n    types::{\n        events::{\n            forwarded_room_key::{ForwardedMegolmV1AesSha2Content, ForwardedRoomKeyContent},\n            olm_v1::{DecryptedForwardedRoomKeyEvent, DecryptedSecretSendEvent},\n            room::encrypted::EncryptedEvent,\n            room_key_request::{\n                Action, MegolmV1AesSha2Content, RequestedKeyInfo, RoomKeyRequestEvent,\n            },\n            secret_send::SecretSendContent,\n            EventType,\n        },\n        EventEncryptionAlgorithm,\n    },\n    Device, MegolmError,\n};\n\n#[derive(Debug, Clone)]\npub(crate) struct GossipMachine {\n    user_id: Arc<UserId>,\n    device_id: Arc<DeviceId>,\n    store: Store,\n    outbound_group_sessions: GroupSessionCache,\n    outgoing_requests: Arc<DashMap<OwnedTransactionId, OutgoingRequest>>,\n    incoming_key_requests: Arc<DashMap<RequestInfo, RequestEvent>>,\n    wait_queue: WaitQueue,\n    users_for_key_claim: Arc<DashMap<OwnedUserId, DashSet<OwnedDeviceId>>>,\n}\n\nimpl GossipMachine {\n    pub fn new(\n        user_id: Arc<UserId>,\n        device_id: Arc<DeviceId>,\n        store: Store,\n        outbound_group_sessions: GroupSessionCache,\n        users_for_key_claim: Arc<DashMap<OwnedUserId, DashSet<OwnedDeviceId>>>,\n    ) -> Self {\n        Self {\n            user_id,\n            device_id,\n            store,\n            outbound_group_sessions,\n            outgoing_requests: Default::default(),\n            incoming_key_requests: Default::default(),\n            wait_queue: WaitQueue::new(),\n            users_for_key_claim,\n        }\n    }\n\n    /// Load stored outgoing requests that were not yet sent out.\n    async fn load_outgoing_requests(&self) -> Result<Vec<OutgoingRequest>, CryptoStoreError> {\n        Ok(self\n            .store\n            .get_unsent_secret_requests()\n            .await?\n            .into_iter()\n            .filter(|i| !i.sent_out)\n            .map(|info| info.to_request(self.device_id()))\n            .collect())\n    }\n\n    /// Our own user id.\n    pub fn user_id(&self) -> &UserId {\n        &self.user_id\n    }\n\n    /// Our own device ID.\n    pub fn device_id(&self) -> &DeviceId {\n        &self.device_id\n    }\n\n    pub async fn outgoing_to_device_requests(\n        &self,\n    ) -> Result<Vec<OutgoingRequest>, CryptoStoreError> {\n        let mut key_requests = self.load_outgoing_requests().await?;\n        let key_forwards: Vec<OutgoingRequest> =\n            self.outgoing_requests.iter().map(|i| i.value().clone()).collect();\n        key_requests.extend(key_forwards);\n\n        let users_for_key_claim: BTreeMap<_, _> = self\n            .users_for_key_claim\n            .iter()\n            .map(|i| {\n                let device_map = i\n                    .value()\n                    .iter()\n                    .map(|d| (d.key().to_owned(), DeviceKeyAlgorithm::SignedCurve25519))\n                    .collect();\n\n                (i.key().to_owned(), device_map)\n            })\n            .collect();\n\n        if !users_for_key_claim.is_empty() {\n            let key_claim_request = KeysClaimRequest::new(users_for_key_claim);\n            key_requests.push(OutgoingRequest {\n                request_id: TransactionId::new(),\n                request: Arc::new(key_claim_request.into()),\n            });\n        }\n\n        Ok(key_requests)\n    }\n\n    /// Receive a room key request event.\n    pub fn receive_incoming_key_request(&self, event: &RoomKeyRequestEvent) {\n        self.receive_event(event.clone().into())\n    }\n\n    fn receive_event(&self, event: RequestEvent) {\n        // Some servers might send to-device events to ourselves if we send one\n        // out using a wildcard instead of a specific device as a recipient.\n        //\n        // Check if we're the sender of this request event and ignore it if\n        // so.\n        if event.sender() == self.user_id() && event.requesting_device_id() == self.device_id() {\n            trace!(\"Received a secret request event from ourselves, ignoring\")\n        } else {\n            let request_info = event.to_request_info();\n            self.incoming_key_requests.insert(request_info, event);\n        }\n    }\n\n    pub fn receive_incoming_secret_request(&self, event: &SecretRequestEvent) {\n        self.receive_event(event.clone().into())\n    }\n\n    /// Handle all the incoming key requests that are queued up and empty our\n    /// key request queue.\n    pub async fn collect_incoming_key_requests(&self) -> OlmResult<Vec<Session>> {\n        let mut changed_sessions = Vec::new();\n\n        for item in self.incoming_key_requests.iter() {\n            let event = item.value();\n\n            if let Some(s) = match event {\n                RequestEvent::KeyShare(e) => self.handle_key_request(e).await?,\n                RequestEvent::Secret(e) => self.handle_secret_request(e).await?,\n            } {\n                changed_sessions.push(s);\n            }\n        }\n\n        self.incoming_key_requests.clear();\n\n        Ok(changed_sessions)\n    }\n\n    /// Store the key share request for later, once we get an Olm session with\n    /// the given device [`retry_keyshare`](#method.retry_keyshare) should be\n    /// called.\n    fn handle_key_share_without_session(&self, device: Device, event: RequestEvent) {\n        self.users_for_key_claim\n            .entry(device.user_id().to_owned())\n            .or_default()\n            .insert(device.device_id().into());\n        self.wait_queue.insert(&device, event);\n    }\n\n    /// Retry keyshares for a device that previously didn't have an Olm session\n    /// with us.\n    ///\n    /// This should be only called if the given user/device got a new Olm\n    /// session.\n    ///\n    /// # Arguments\n    ///\n    /// * `user_id` - The user id of the device that we created the Olm session\n    /// with.\n    ///\n    /// * `device_id` - The device ID of the device that got the Olm session.\n    pub fn retry_keyshare(&self, user_id: &UserId, device_id: &DeviceId) {\n        if let Entry::Occupied(e) = self.users_for_key_claim.entry(user_id.to_owned()) {\n            e.get().remove(device_id);\n\n            if e.get().is_empty() {\n                e.remove();\n            }\n        }\n\n        for (key, event) in self.wait_queue.remove(user_id, device_id) {\n            if !self.incoming_key_requests.contains_key(&key) {\n                self.incoming_key_requests.insert(key, event);\n            }\n        }\n    }\n\n    async fn handle_secret_request(\n        &self,\n        event: &SecretRequestEvent,\n    ) -> OlmResult<Option<Session>> {\n        let secret_name = match &event.content.action {\n            RequestAction::Request(s) => s,\n            // We ignore cancellations here since there's nothing to serve.\n            RequestAction::RequestCancellation => return Ok(None),\n            action => {\n                warn!(?action, \"Unknown secret request action\");\n                return Ok(None);\n            }\n        };\n\n        let content = if let Some(secret) = self.store.export_secret(secret_name).await {\n            SecretSendContent::new(event.content.request_id.to_owned(), secret)\n        } else {\n            info!(?secret_name, \"Can't serve a secret request, secret isn't found\");\n            return Ok(None);\n        };\n\n        let device =\n            self.store.get_device(&event.sender, &event.content.requesting_device_id).await?;\n\n        Ok(if let Some(device) = device {\n            if device.user_id() == self.user_id() {\n                if device.is_verified() {\n                    info!(\n                        user_id = device.user_id().as_str(),\n                        device_id = device.device_id().as_str(),\n                        ?secret_name,\n                        \"Sharing a secret with a device\",\n                    );\n\n                    match self.share_secret(&device, content).await {\n                        Ok(s) => Ok(Some(s)),\n                        Err(OlmError::MissingSession) => {\n                            info!(\n                                user_id = device.user_id().as_str(),\n                                device_id = device.device_id().as_str(),\n                                secret_name = secret_name.as_ref(),\n                                \"Secret request is missing an Olm session, \\\n                                putting the request in the wait queue\",\n                            );\n                            self.handle_key_share_without_session(device, event.clone().into());\n\n                            Ok(None)\n                        }\n                        Err(e) => Err(e),\n                    }?\n                } else {\n                    info!(\n                        user_id = device.user_id().as_str(),\n                        device_id = device.device_id().as_str(),\n                        ?secret_name,\n                        \"Received a secret request that we won't serve, the device isn't trusted\",\n                    );\n\n                    None\n                }\n            } else {\n                info!(\n                    user_id = device.user_id().as_str(),\n                    device_id = device.device_id().as_str(),\n                    ?secret_name,\n                    \"Received a secret request that we won't serve, the device doesn't belong to us\",\n                );\n\n                None\n            }\n        } else {\n            warn!(\n                user_id = event.sender.as_str(),\n                device_id = event.content.requesting_device_id.as_str(),\n                ?secret_name,\n                \"Received a secret request form an unknown device\",\n            );\n            self.store.update_tracked_user(&event.sender, true).await?;\n\n            None\n        })\n    }\n\n    async fn handle_megolm_v1_request(\n        &self,\n        event: &RoomKeyRequestEvent,\n        key_info: &MegolmV1AesSha2Content,\n    ) -> OlmResult<Option<Session>> {\n        let session = self\n            .store\n            .get_inbound_group_session(\n                &key_info.room_id,\n                &key_info.sender_key.to_base64(),\n                &key_info.session_id,\n            )\n            .await?;\n\n        let session = if let Some(s) = session {\n            s\n        } else {\n            debug!(\n                user_id = event.sender.as_str(),\n                device_id = event.content.requesting_device_id.as_str(),\n                session_id = key_info.session_id.as_str(),\n                room_id = key_info.room_id.as_str(),\n                \"Received a room key request for an unknown inbound group session\",\n            );\n            return Ok(None);\n        };\n\n        let device =\n            self.store.get_device(&event.sender, &event.content.requesting_device_id).await?;\n\n        if let Some(device) = device {\n            match self.should_share_key(&device, &session).await {\n                Err(e) => {\n                    if let KeyForwardDecision::ChangedSenderKey = e {\n                        warn!(\n                            user_id = device.user_id().as_str(),\n                            device_id = device.device_id().as_str(),\n                            \"Received a key request from a device that changed \\\n                            their curve25519 sender key\"\n                        );\n                    } else {\n                        debug!(\n                            user_id = device.user_id().as_str(),\n                            device_id = device.device_id().as_str(),\n                            reason = ?e,\n                            \"Received a key request that we won't serve\",\n                        );\n                    }\n\n                    Ok(None)\n                }\n                Ok(message_index) => {\n                    info!(\n                        user_id = device.user_id().as_str(),\n                        device_id = device.device_id().as_str(),\n                        session_id = key_info.session_id.as_str(),\n                        room_id = key_info.room_id.as_str(),\n                        ?message_index,\n                        \"Serving a room key request\",\n                    );\n\n                    match self.share_session(&session, &device, message_index).await {\n                        Ok(s) => Ok(Some(s)),\n                        Err(OlmError::MissingSession) => {\n                            info!(\n                                user_id = device.user_id().as_str(),\n                                device_id = device.device_id().as_str(),\n                                session_id = key_info.session_id.as_str(),\n                                \"Key request is missing an Olm session, \\\n                                putting the request in the wait queue\",\n                            );\n                            self.handle_key_share_without_session(device, event.to_owned().into());\n\n                            Ok(None)\n                        }\n                        Err(OlmError::SessionExport(e)) => {\n                            warn!(\n                                user_id = device.user_id().as_str(),\n                                device_id = device.device_id().as_str(),\n                                session_id = key_info.session_id.as_str(),\n                                \"Can't serve a room key request, the session \\\n                                can't be exported into a forwarded room key: \\\n                                {:?}\",\n                                e\n                            );\n                            Ok(None)\n                        }\n                        Err(e) => Err(e),\n                    }\n                }\n            }\n        } else {\n            warn!(\n                user_id = event.sender.as_str(),\n                device_id = event.content.requesting_device_id.as_str(),\n                \"Received a key request from an unknown device\",\n            );\n            self.store.update_tracked_user(&event.sender, true).await?;\n\n            Ok(None)\n        }\n    }\n\n    /// Handle a single incoming key request.\n    async fn handle_key_request(&self, event: &RoomKeyRequestEvent) -> OlmResult<Option<Session>> {\n        match &event.content.action {\n            Action::Request(info) => match info {\n                RequestedKeyInfo::MegolmV1AesSha2(i) => {\n                    self.handle_megolm_v1_request(event, i).await\n                }\n                // V2 room key requests don't have a sender_key field, we\n                // currently can't fetch an inbound group session without a\n                // sender key, so ignore the request.\n                #[cfg(feature = \"experimental-algorithms\")]\n                RequestedKeyInfo::MegolmV2AesSha2(_) => Ok(None),\n                RequestedKeyInfo::Unknown(i) => {\n                    debug!(\n                        sender = %event.sender,\n                        algorithm = %i.algorithm,\n                        \"Received a room key request for a unsupported algorithm\"\n                    );\n                    Ok(None)\n                }\n            },\n            // We ignore cancellations here since there's nothing to serve.\n            Action::Cancellation => Ok(None),\n        }\n    }\n\n    async fn share_secret(\n        &self,\n        device: &Device,\n        content: SecretSendContent,\n    ) -> OlmResult<Session> {\n        let event_type = content.event_type();\n        let content = serde_json::to_value(content)?;\n        let (used_session, content) = device.encrypt(event_type, content).await?;\n\n        let request = ToDeviceRequest::new(\n            device.user_id(),\n            device.device_id().to_owned(),\n            content.event_type(),\n            content.cast(),\n        );\n\n        let request = OutgoingRequest {\n            request_id: request.txn_id.clone(),\n            request: Arc::new(request.into()),\n        };\n        self.outgoing_requests.insert(request.request_id.clone(), request);\n\n        Ok(used_session)\n    }\n\n    async fn share_session(\n        &self,\n        session: &InboundGroupSession,\n        device: &Device,\n        message_index: Option<u32>,\n    ) -> OlmResult<Session> {\n        let (used_session, content) =\n            device.encrypt_room_key_for_forwarding(session.clone(), message_index).await?;\n\n        let request = ToDeviceRequest::new(\n            device.user_id(),\n            device.device_id().to_owned(),\n            content.event_type(),\n            content.cast(),\n        );\n\n        let request = OutgoingRequest {\n            request_id: request.txn_id.clone(),\n            request: Arc::new(request.into()),\n        };\n        self.outgoing_requests.insert(request.request_id.clone(), request);\n\n        Ok(used_session)\n    }\n\n    /// Check if it's ok to share a session with the given device.\n    ///\n    /// The logic for this is currently as follows:\n    ///\n    /// * Share the session in full, starting from the earliest known index, if\n    /// the requesting device is our own, trusted (verified) device.\n    ///\n    /// * For other requesting devices, share only a limited session and only if\n    /// we originally shared with that device because it was present when the\n    /// message was initially sent. By limited, we mean that the session will\n    /// not be shared in full, but only from the message index at that moment.\n    /// Since this information is recorded in the outbound session, we need to\n    /// have it for this to work.\n    ///\n    /// * In all other cases, refuse to share the session.\n    ///\n    /// # Arguments\n    ///\n    /// * `device` - The device that is requesting a session from us.\n    ///\n    /// * `session` - The session that was requested to be shared.\n    ///\n    /// # Return value\n    ///\n    /// A `Result` representing whether we should share the session:\n    ///\n    /// - `Ok(None)`: Should share the entire session, starting with the\n    ///   earliest known index.\n    /// - `Ok(Some(i))`: Should share the session, but only starting from index\n    ///   i.\n    /// - `Err(x)`: Should *refuse* to share the session. `x` is the reason for\n    ///   the refusal.\n    async fn should_share_key(\n        &self,\n        device: &Device,\n        session: &InboundGroupSession,\n    ) -> Result<Option<u32>, KeyForwardDecision> {\n        let outbound_session = self\n            .outbound_group_sessions\n            .get_with_id(session.room_id(), session.session_id())\n            .await\n            .ok()\n            .flatten();\n\n        // If this is our own, verified device, we share the entire session from the\n        // earliest known index.\n        if device.user_id() == self.user_id() && device.is_verified() {\n            Ok(None)\n        // Otherwise, if the records show we previously shared with this device,\n        // we'll reshare the session from the index we previously shared\n        // at. For this, we need an outbound session because this\n        // information is recorded there.\n        } else if let Some(outbound) = outbound_session {\n            match outbound.is_shared_with(device) {\n                ShareState::Shared(message_index) => Ok(Some(message_index)),\n                ShareState::SharedButChangedSenderKey => Err(KeyForwardDecision::ChangedSenderKey),\n                ShareState::NotShared => Err(KeyForwardDecision::OutboundSessionNotShared),\n            }\n        // Otherwise, there's not enough info to decide if we can safely share\n        // the session.\n        } else if device.user_id() == self.user_id() {\n            Err(KeyForwardDecision::UntrustedDevice)\n        } else {\n            Err(KeyForwardDecision::MissingOutboundSession)\n        }\n    }\n\n    /// Check if it's ok, or rather if it makes sense to automatically request\n    /// a key from our other devices.\n    ///\n    /// # Arguments\n    ///\n    /// * `key_info` - The info of our key request containing information about\n    /// the key we wish to request.\n    async fn should_request_key(&self, key_info: &SecretInfo) -> Result<bool, CryptoStoreError> {\n        let request = self.store.get_secret_request_by_info(key_info).await?;\n\n        // Don't send out duplicate requests, users can re-request them if they\n        // think a second request might succeed.\n        if request.is_none() {\n            let devices = self.store.get_user_devices(self.user_id()).await?;\n\n            // Devices will only respond to key requests if the devices are\n            // verified, if the device isn't verified by us it's unlikely that\n            // we're verified by them either. Don't request keys if there isn't\n            // at least one verified device.\n            if devices.is_any_verified() {\n                Ok(true)\n            } else {\n                Ok(false)\n            }\n        } else {\n            Ok(false)\n        }\n    }\n\n    /// Create a new outgoing key request for the key with the given session id.\n    ///\n    /// This will queue up a new to-device request and store the key info so\n    /// once we receive a forwarded room key we can check that it matches the\n    /// key we requested.\n    ///\n    /// This method will return a cancel request and a new key request if the\n    /// key was already requested, otherwise it will return just the key\n    /// request.\n    ///\n    /// # Arguments\n    ///\n    /// * `room_id` - The id of the room where the key is used in.\n    ///\n    /// * `event` - The event for which we would like to request the room key.\n    pub async fn request_key(\n        &self,\n        room_id: &RoomId,\n        event: &EncryptedEvent,\n    ) -> Result<(Option<OutgoingRequest>, OutgoingRequest), MegolmError> {\n        let secret_info =\n            event.room_key_info(room_id).ok_or(EventError::UnsupportedAlgorithm)?.into();\n\n        let request = self.store.get_secret_request_by_info(&secret_info).await?;\n\n        if let Some(request) = request {\n            let cancel = request.to_cancellation(self.device_id());\n            let request = request.to_request(self.device_id());\n\n            Ok((Some(cancel), request))\n        } else {\n            let request = self.request_key_helper(secret_info).await?;\n\n            Ok((None, request))\n        }\n    }\n\n    /// Create outgoing secret requests for the given\n    pub fn request_missing_secrets(\n        own_user_id: &UserId,\n        secret_names: Vec<SecretName>,\n    ) -> Vec<GossipRequest> {\n        if !secret_names.is_empty() {\n            info!(?secret_names, \"Creating new outgoing secret requests\");\n\n            secret_names\n                .into_iter()\n                .map(|n| GossipRequest::from_secret_name(own_user_id.to_owned(), n))\n                .collect()\n        } else {\n            trace!(\"No secrets are missing from our store, not requesting them\");\n            vec![]\n        }\n    }\n\n    async fn request_key_helper(\n        &self,\n        key_info: SecretInfo,\n    ) -> Result<OutgoingRequest, CryptoStoreError> {\n        let request = GossipRequest {\n            request_recipient: self.user_id().to_owned(),\n            request_id: TransactionId::new(),\n            info: key_info,\n            sent_out: false,\n        };\n\n        let outgoing_request = request.to_request(self.device_id());\n        self.save_outgoing_key_info(request).await?;\n\n        Ok(outgoing_request)\n    }\n\n    /// Create a new outgoing key request for the key with the given session id.\n    ///\n    /// This will queue up a new to-device request and store the key info so\n    /// once we receive a forwarded room key we can check that it matches the\n    /// key we requested.\n    ///\n    /// This does nothing if a request for this key has already been sent out.\n    ///\n    /// # Arguments\n    /// * `room_id` - The id of the room where the key is used in.\n    ///\n    /// * `event` - The event for which we would like to request the room key.\n    pub async fn create_outgoing_key_request(\n        &self,\n        room_id: &RoomId,\n        event: &EncryptedEvent,\n    ) -> Result<bool, CryptoStoreError> {\n        Ok(if let Some(info) = event.room_key_info(room_id).map(|i| i.into()) {\n            if self.should_request_key(&info).await? {\n                self.request_key_helper(info).await?;\n                true\n            } else {\n                false\n            }\n        } else {\n            false\n        })\n    }\n\n    /// Save an outgoing key info.\n    async fn save_outgoing_key_info(&self, info: GossipRequest) -> Result<(), CryptoStoreError> {\n        let mut changes = Changes::default();\n        changes.key_requests.push(info);\n        self.store.save_changes(changes).await?;\n\n        Ok(())\n    }\n\n    /// Get an outgoing key info that matches the forwarded room key content.\n    async fn get_key_info(\n        &self,\n        event: &DecryptedForwardedRoomKeyEvent,\n    ) -> Result<Option<GossipRequest>, CryptoStoreError> {\n        if let Some(info) = event.room_key_info().map(|i| i.into()) {\n            self.store.get_secret_request_by_info(&info).await\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Delete the given outgoing key info.\n    async fn delete_key_info(&self, info: &GossipRequest) -> Result<(), CryptoStoreError> {\n        self.store.delete_outgoing_secret_requests(&info.request_id).await\n    }\n\n    /// Mark the outgoing request as sent.\n    pub async fn mark_outgoing_request_as_sent(\n        &self,\n        id: &TransactionId,\n    ) -> Result<(), CryptoStoreError> {\n        let info = self.store.get_outgoing_secret_requests(id).await?;\n\n        if let Some(mut info) = info {\n            trace!(\n                recipient = info.request_recipient.as_str(),\n                request_type = info.request_type(),\n                request_id = info.request_id.to_string().as_str(),\n                \"Marking outgoing key request as sent\"\n            );\n            info.sent_out = true;\n            self.save_outgoing_key_info(info).await?;\n        }\n\n        self.outgoing_requests.remove(id);\n\n        Ok(())\n    }\n\n    /// Mark the given outgoing key info as done.\n    ///\n    /// This will queue up a request cancellation.\n    async fn mark_as_done(&self, key_info: &GossipRequest) -> Result<(), CryptoStoreError> {\n        trace!(\n            recipient = key_info.request_recipient.as_str(),\n            request_type = key_info.request_type(),\n            request_id = key_info.request_id.to_string().as_str(),\n            \"Successfully received a secret, removing the request\"\n        );\n\n        self.outgoing_requests.remove(&key_info.request_id);\n        // TODO return the key info instead of deleting it so the sync handler\n        // can delete it in one transaction.\n        self.delete_key_info(key_info).await?;\n\n        let request = key_info.to_cancellation(self.device_id());\n        self.outgoing_requests.insert(request.request_id.clone(), request);\n\n        Ok(())\n    }\n\n    async fn accept_secret(\n        &self,\n        event: &DecryptedSecretSendEvent,\n        request: &GossipRequest,\n        secret_name: &SecretName,\n    ) -> Result<(), CryptoStoreError> {\n        if secret_name != &SecretName::RecoveryKey {\n            match self.store.import_secret(secret_name, &event.content.secret).await {\n                Ok(_) => self.mark_as_done(request).await?,\n                Err(e) => {\n                    // If this is a store error propagate it up\n                    // the call stack.\n                    if let SecretImportError::Store(e) = e {\n                        return Err(e);\n                    } else {\n                        // Otherwise warn that there was\n                        // something wrong with the secret.\n                        warn!(\n                            secret_name = secret_name.as_ref(),\n                            error = ?e,\n                            \"Error while importing a secret\"\n                        )\n                    }\n                }\n            }\n        } else {\n            // Skip importing the recovery key here since\n            // we'll want to check if the public key matches\n            // to the latest version on the server. The key\n            // will not be zeroized and\n            // instead leave the key in the event and let\n            // the user import it later.\n        }\n\n        Ok(())\n    }\n\n    async fn receive_secret(\n        &self,\n        sender_key: Curve25519PublicKey,\n        event: &DecryptedSecretSendEvent,\n        request: &GossipRequest,\n        secret_name: &SecretName,\n    ) -> Result<(), CryptoStoreError> {\n        debug!(\n            sender = event.sender.as_str(),\n            request_id = event.content.request_id.as_str(),\n            secret_name = secret_name.as_ref(),\n            \"Received a m.secret.send event with a matching request\"\n        );\n\n        if let Some(device) =\n            self.store.get_device_from_curve_key(&event.sender, sender_key).await?\n        {\n            // Only accept secrets from one of our own trusted devices.\n            if device.user_id() == self.user_id() && device.is_verified() {\n                self.accept_secret(event, request, secret_name).await?;\n            } else {\n                warn!(\n                    sender = event.sender.as_str(),\n                    request_id = event.content.request_id.as_str(),\n                    secret_name = secret_name.as_ref(),\n                    \"Received a m.secret.send event from another user or from \\\n                    unverified device\"\n                );\n            }\n        } else {\n            warn!(\n                sender = event.sender.as_str(),\n                request_id = event.content.request_id.as_str(),\n                secret_name = secret_name.as_ref(),\n                \"Received a m.secret.send event from an unknown device\"\n            );\n            self.store.update_tracked_user(&event.sender, true).await?;\n        }\n\n        Ok(())\n    }\n\n    pub async fn receive_secret_event(\n        &self,\n        sender_key: Curve25519PublicKey,\n        event: &DecryptedSecretSendEvent,\n    ) -> Result<Option<SecretName>, CryptoStoreError> {\n        debug!(\n            sender = event.sender.as_str(),\n            request_id = event.content.request_id.as_str(),\n            \"Received a m.secret.send event\"\n        );\n\n        let request_id = <&TransactionId>::from(event.content.request_id.as_str());\n\n        Ok(if let Some(request) = self.store.get_outgoing_secret_requests(request_id).await? {\n            match &request.info {\n                SecretInfo::KeyRequest(_) => {\n                    warn!(\n                        sender = event.sender.as_str(),\n                        request_id = event.content.request_id.as_str(),\n                        \"Received a m.secret.send event but the request was for a room key\"\n                    );\n\n                    None\n                }\n                SecretInfo::SecretRequest(secret_name) => {\n                    self.receive_secret(sender_key, event, &request, secret_name).await?;\n\n                    Some(secret_name.to_owned())\n                }\n            }\n        } else {\n            None\n        })\n    }\n\n    async fn accept_forwarded_room_key(\n        &self,\n        info: &GossipRequest,\n        sender: &UserId,\n        sender_key: Curve25519PublicKey,\n        algorithm: EventEncryptionAlgorithm,\n        content: &ForwardedMegolmV1AesSha2Content,\n    ) -> Result<Option<InboundGroupSession>, CryptoStoreError> {\n        match InboundGroupSession::from_forwarded_key(&algorithm, content) {\n            Ok(session) => {\n                let old_session = self\n                    .store\n                    .get_inbound_group_session(\n                        session.room_id(),\n                        &session.sender_key.to_base64(),\n                        session.session_id(),\n                    )\n                    .await?;\n\n                let session_id = session.session_id().to_owned();\n\n                // If we have a previous session, check if we have a better version\n                // and store the new one if so.\n                let session = if let Some(old_session) = old_session {\n                    if session.compare(&old_session).await == SessionOrdering::Better {\n                        self.mark_as_done(info).await?;\n                        Some(session)\n                    } else {\n                        None\n                    }\n                // If we didn't have a previous session, store it.\n                } else {\n                    self.mark_as_done(info).await?;\n                    Some(session)\n                };\n\n                if let Some(s) = &session {\n                    info!(\n                        %sender,\n                        sender_key = sender_key.to_base64(),\n                        claimed_sender_key = content.claimed_sender_key.to_base64(),\n                        room_id = s.room_id().as_str(),\n                        session_id = session_id.as_str(),\n                        %algorithm,\n                        \"Received a forwarded room key\",\n                    );\n                } else {\n                    info!(\n                        %sender,\n                        sender_key = sender_key.to_base64(),\n                        claimed_sender_key = content.claimed_sender_key.to_base64(),\n                        room_id = %content.room_id,\n                        session_id = session_id.as_str(),\n                        %algorithm,\n                        \"Received a forwarded room key but we already have a better version of it\",\n                    );\n                }\n\n                Ok(session)\n            }\n            Err(e) => {\n                warn!(\n                    %sender,\n                    sender_key = sender_key.to_base64(),\n                    claimed_sender_key = content.claimed_sender_key.to_base64(),\n                    room_id = content.room_id.as_str(),\n                    %algorithm,\n                    \"Couldn't create a group session from a received room key\"\n                );\n                Err(e.into())\n            }\n        }\n    }\n\n    async fn should_accept_forward(\n        &self,\n        info: &GossipRequest,\n        sender_key: Curve25519PublicKey,\n    ) -> Result<bool, CryptoStoreError> {\n        let device =\n            self.store.get_device_from_curve_key(&info.request_recipient, sender_key).await?;\n\n        if let Some(device) = device {\n            Ok(device.user_id() == self.user_id() && device.is_verified())\n        } else {\n            Ok(false)\n        }\n    }\n\n    /// Receive a forwarded room key event that was sent using any of our\n    /// supported content types.\n    async fn receive_supported_keys(\n        &self,\n        sender_key: Curve25519PublicKey,\n        event: &DecryptedForwardedRoomKeyEvent,\n        content: &ForwardedMegolmV1AesSha2Content,\n    ) -> Result<Option<InboundGroupSession>, CryptoStoreError> {\n        let algorithm = event.content.algorithm();\n\n        if let Some(info) = self.get_key_info(event).await? {\n            if self.should_accept_forward(&info, sender_key).await? {\n                self.accept_forwarded_room_key(&info, &event.sender, sender_key, algorithm, content)\n                    .await\n            } else {\n                warn!(\n                    sender = %event.sender,\n                    %sender_key,\n                    room_id = %content.room_id,\n                    session_id = content.session_id.as_str(),\n                    claimed_sender_key = %content.claimed_sender_key,\n                    \"Received a forwarded room key from an unknown device, or \\\n                     from a device that the key request recipient doesn't own\",\n                );\n\n                Ok(None)\n            }\n        } else {\n            warn!(\n                sender = %event.sender,\n                sender_key = %sender_key,\n                room_id = %content.room_id,\n                session_id = content.session_id.as_str(),\n                claimed_sender_key = %content.claimed_sender_key,\n                algorithm = %algorithm,\n                \"Received a forwarded room key that we didn't request\",\n            );\n\n            Ok(None)\n        }\n    }\n\n    /// Receive a forwarded room key event.\n    pub async fn receive_forwarded_room_key(\n        &self,\n        sender_key: Curve25519PublicKey,\n        event: &DecryptedForwardedRoomKeyEvent,\n    ) -> Result<Option<InboundGroupSession>, CryptoStoreError> {\n        match &event.content {\n            ForwardedRoomKeyContent::MegolmV1AesSha2(content) => {\n                self.receive_supported_keys(sender_key, event, content).await\n            }\n            #[cfg(feature = \"experimental-algorithms\")]\n            ForwardedRoomKeyContent::MegolmV2AesSha2(content) => {\n                self.receive_supported_keys(sender_key, event, content).await\n            }\n            ForwardedRoomKeyContent::Unknown(_) => {\n                warn!(\n                    sender = event.sender.as_str(),\n                    sender_key = sender_key.to_base64(),\n                    algorithm = %event.content.algorithm(),\n                    \"Received a forwarded room key with an unsupported algorithm\",\n                );\n\n                Ok(None)\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::sync::Arc;\n\n    use dashmap::DashMap;\n    use matches::assert_matches;\n    use matrix_sdk_common::locks::Mutex;\n    use matrix_sdk_test::async_test;\n    use ruma::{\n        device_id, event_id,\n        events::{\n            secret::request::{RequestAction, SecretName, ToDeviceSecretRequestEventContent},\n            AnyToDeviceEventContent, ToDeviceEvent as RumaToDeviceEvent,\n        },\n        room_id,\n        serde::Raw,\n        user_id, DeviceId, RoomId, UserId,\n    };\n    use serde::{de::DeserializeOwned, Serialize};\n    use serde_json::json;\n\n    use super::{GossipMachine, KeyForwardDecision};\n    use crate::{\n        identities::{LocalTrust, ReadOnlyDevice},\n        olm::{Account, OutboundGroupSession, PrivateCrossSigningIdentity, ReadOnlyAccount},\n        session_manager::GroupSessionCache,\n        store::{Changes, CryptoStore, MemoryStore, Store},\n        types::events::{\n            forwarded_room_key::ForwardedRoomKeyContent,\n            olm_v1::{AnyDecryptedOlmEvent, DecryptedOlmV1Event},\n            room::encrypted::{EncryptedEvent, EncryptedToDeviceEvent, RoomEncryptedEventContent},\n            EventType, ToDeviceEvent,\n        },\n        verification::VerificationMachine,\n        OutgoingRequest, OutgoingRequests,\n    };\n\n    fn alice_id() -> &'static UserId {\n        user_id!(\"@alice:example.org\")\n    }\n\n    fn alice_device_id() -> &'static DeviceId {\n        device_id!(\"JLAFKJWSCS\")\n    }\n\n    fn bob_id() -> &'static UserId {\n        user_id!(\"@bob:example.org\")\n    }\n\n    fn bob_device_id() -> &'static DeviceId {\n        device_id!(\"ILMLKASTES\")\n    }\n\n    fn alice2_device_id() -> &'static DeviceId {\n        device_id!(\"ILMLKASTES\")\n    }\n\n    fn room_id() -> &'static RoomId {\n        room_id!(\"!test:example.org\")\n    }\n\n    fn account() -> ReadOnlyAccount {\n        ReadOnlyAccount::new(alice_id(), alice_device_id())\n    }\n\n    fn bob_account() -> ReadOnlyAccount {\n        ReadOnlyAccount::new(bob_id(), bob_device_id())\n    }\n\n    fn alice_2_account() -> ReadOnlyAccount {\n        ReadOnlyAccount::new(alice_id(), alice2_device_id())\n    }\n\n    fn test_gossip_machine(user_id: &UserId) -> GossipMachine {\n        let user_id = Arc::from(user_id);\n        let device_id = DeviceId::new();\n\n        let account = ReadOnlyAccount::new(&user_id, &device_id);\n        let store: Arc<dyn CryptoStore> = Arc::new(MemoryStore::new());\n        let identity = Arc::new(Mutex::new(PrivateCrossSigningIdentity::empty(alice_id())));\n        let verification = VerificationMachine::new(account, identity.clone(), store.clone());\n        let store = Store::new(user_id.to_owned(), identity, store, verification);\n        let session_cache = GroupSessionCache::new(store.clone());\n\n        GossipMachine::new(\n            user_id,\n            device_id.into(),\n            store,\n            session_cache,\n            Arc::new(DashMap::new()),\n        )\n    }\n\n    async fn get_machine() -> GossipMachine {\n        let user_id: Arc<UserId> = alice_id().into();\n        let account = ReadOnlyAccount::new(&user_id, alice_device_id());\n        let device = ReadOnlyDevice::from_account(&account).await;\n        let another_device =\n            ReadOnlyDevice::from_account(&ReadOnlyAccount::new(&user_id, alice2_device_id())).await;\n\n        let store: Arc<dyn CryptoStore> = Arc::new(MemoryStore::new());\n        let identity = Arc::new(Mutex::new(PrivateCrossSigningIdentity::empty(alice_id())));\n        let verification = VerificationMachine::new(account, identity.clone(), store.clone());\n\n        let store = Store::new(user_id.clone(), identity, store, verification);\n        store.save_devices(&[device, another_device]).await.unwrap();\n        let session_cache = GroupSessionCache::new(store.clone());\n\n        GossipMachine::new(\n            user_id,\n            alice_device_id().into(),\n            store,\n            session_cache,\n            Arc::new(DashMap::new()),\n        )\n    }\n\n    async fn machines_for_key_share(\n        create_sessions: bool,\n    ) -> (GossipMachine, Account, OutboundGroupSession, GossipMachine) {\n        let alice_machine = get_machine().await;\n        let alice_account = Account {\n            inner: alice_machine.store.account().clone(),\n            store: alice_machine.store.clone(),\n        };\n        let alice_device = ReadOnlyDevice::from_account(alice_machine.store.account()).await;\n\n        let bob_machine = test_gossip_machine(alice_id());\n        let bob_device = ReadOnlyDevice::from_account(bob_machine.store.account()).await;\n\n        // We need a trusted device, otherwise we won't request keys\n        bob_device.set_trust_state(LocalTrust::Verified);\n        alice_machine.store.save_devices(&[bob_device]).await.unwrap();\n        bob_machine.store.save_devices(&[alice_device.clone()]).await.unwrap();\n\n        if create_sessions {\n            // Create Olm sessions for our two accounts.\n            let (alice_session, bob_session) =\n                alice_machine.store.account().create_session_for(bob_machine.store.account()).await;\n\n            // Populate our stores with Olm sessions and a Megolm session.\n\n            alice_machine.store.save_sessions(&[alice_session]).await.unwrap();\n            bob_machine.store.save_sessions(&[bob_session]).await.unwrap();\n        }\n\n        let (group_session, inbound_group_session) =\n            bob_machine.store.account().create_group_session_pair_with_defaults(room_id()).await;\n\n        let content = group_session.encrypt(json!({}), \"m.dummy\").await;\n        let event = wrap_encrypted_content(bob_machine.user_id(), content);\n        bob_machine.store.save_inbound_group_sessions(&[inbound_group_session]).await.unwrap();\n\n        // Alice wants to request the outbound group session from bob.\n        assert!(\n            alice_machine.create_outgoing_key_request(room_id(), &event,).await.unwrap(),\n            \"We should request a room key\"\n        );\n\n        group_session\n            .mark_shared_with(\n                alice_device.user_id(),\n                alice_device.device_id(),\n                alice_device.curve25519_key().unwrap(),\n            )\n            .await;\n\n        // Put the outbound session into bobs store.\n        bob_machine.outbound_group_sessions.insert(group_session.clone());\n\n        (alice_machine, alice_account, group_session, bob_machine)\n    }\n\n    fn extract_content<'a>(\n        recipient: &UserId,\n        request: &'a OutgoingRequest,\n    ) -> &'a Raw<AnyToDeviceEventContent> {\n        request\n            .request()\n            .to_device()\n            .expect(\"The request should be always a to-device request\")\n            .messages\n            .get(recipient)\n            .unwrap()\n            .values()\n            .next()\n            .unwrap()\n    }\n\n    fn wrap_encrypted_content(\n        sender: &UserId,\n        content: Raw<RoomEncryptedEventContent>,\n    ) -> EncryptedEvent {\n        let content = content.deserialize().unwrap();\n\n        EncryptedEvent {\n            sender: sender.to_owned(),\n            event_id: event_id!(\"$143273582443PhrSn:example.org\").to_owned(),\n            content,\n            origin_server_ts: ruma::MilliSecondsSinceUnixEpoch::now(),\n            unsigned: Default::default(),\n            other: Default::default(),\n        }\n    }\n\n    fn request_to_event<C>(\n        recipient: &UserId,\n        sender: &UserId,\n        request: &OutgoingRequest,\n    ) -> ToDeviceEvent<C>\n    where\n        C: EventType + DeserializeOwned + Serialize + std::fmt::Debug,\n    {\n        let content = extract_content(recipient, request);\n        let content: C = content\n            .deserialize_as()\n            .expect(\"We can always deserialize the to-device event content\");\n\n        ToDeviceEvent::new(sender.to_owned(), content)\n    }\n\n    #[async_test]\n    async fn create_machine() {\n        let machine = get_machine().await;\n\n        assert!(machine.outgoing_to_device_requests().await.unwrap().is_empty());\n    }\n\n    #[async_test]\n    async fn re_request_keys() {\n        let machine = get_machine().await;\n        let account = account();\n\n        let (outbound, session) = account.create_group_session_pair_with_defaults(room_id()).await;\n\n        let content = outbound.encrypt(json!({}), \"m.dummy\").await;\n        let event = wrap_encrypted_content(machine.user_id(), content);\n\n        assert!(machine.outgoing_to_device_requests().await.unwrap().is_empty());\n        let (cancel, request) = machine.request_key(session.room_id(), &event).await.unwrap();\n\n        assert!(cancel.is_none());\n\n        machine.mark_outgoing_request_as_sent(&request.request_id).await.unwrap();\n\n        let (cancel, _) = machine.request_key(session.room_id(), &event).await.unwrap();\n\n        assert!(cancel.is_some());\n    }\n\n    #[async_test]\n    async fn create_key_request() {\n        let machine = get_machine().await;\n        let account = account();\n        let second_account = alice_2_account();\n        let alice_device = ReadOnlyDevice::from_account(&second_account).await;\n\n        // We need a trusted device, otherwise we won't request keys\n        alice_device.set_trust_state(LocalTrust::Verified);\n        machine.store.save_devices(&[alice_device]).await.unwrap();\n\n        let (outbound, session) = account.create_group_session_pair_with_defaults(room_id()).await;\n        let content = outbound.encrypt(json!({}), \"m.dummy\").await;\n        let event = wrap_encrypted_content(machine.user_id(), content);\n\n        assert!(machine.outgoing_to_device_requests().await.unwrap().is_empty());\n        machine.create_outgoing_key_request(session.room_id(), &event).await.unwrap();\n        assert!(!machine.outgoing_to_device_requests().await.unwrap().is_empty());\n        assert_eq!(machine.outgoing_to_device_requests().await.unwrap().len(), 1);\n\n        machine.create_outgoing_key_request(session.room_id(), &event).await.unwrap();\n\n        let requests = machine.outgoing_to_device_requests().await.unwrap();\n        assert_eq!(requests.len(), 1);\n\n        let request = requests.get(0).unwrap();\n\n        machine.mark_outgoing_request_as_sent(&request.request_id).await.unwrap();\n        assert!(machine.outgoing_to_device_requests().await.unwrap().is_empty());\n    }\n\n    #[async_test]\n    async fn receive_forwarded_key() {\n        let machine = get_machine().await;\n        let account = account();\n\n        let second_account = alice_2_account();\n        let alice_device = ReadOnlyDevice::from_account(&second_account).await;\n\n        // We need a trusted device, otherwise we won't request keys\n        alice_device.set_trust_state(LocalTrust::Verified);\n        machine.store.save_devices(&[alice_device.clone()]).await.unwrap();\n\n        let (outbound, session) = account.create_group_session_pair_with_defaults(room_id()).await;\n        let content = outbound.encrypt(json!({}), \"m.dummy\").await;\n        let room_event = wrap_encrypted_content(machine.user_id(), content);\n\n        machine.create_outgoing_key_request(session.room_id(), &room_event).await.unwrap();\n\n        let requests = machine.outgoing_to_device_requests().await.unwrap();\n        let request = requests.get(0).unwrap();\n        let id = &request.request_id;\n\n        machine.mark_outgoing_request_as_sent(id).await.unwrap();\n\n        let export = session.export_at_index(10).await;\n\n        let content: ForwardedRoomKeyContent = export.try_into().unwrap();\n\n        let event = DecryptedOlmV1Event::new(\n            alice_id(),\n            alice_id(),\n            alice_device.ed25519_key().unwrap(),\n            content,\n        );\n\n        assert!(machine\n            .store\n            .get_inbound_group_session(\n                session.room_id(),\n                &session.sender_key.to_base64(),\n                session.session_id(),\n            )\n            .await\n            .unwrap()\n            .is_none());\n\n        let first_session = machine\n            .receive_forwarded_room_key(alice_device.curve25519_key().unwrap(), &event)\n            .await\n            .unwrap();\n        let first_session = first_session.unwrap();\n\n        assert_eq!(first_session.first_known_index(), 10);\n\n        machine.store.save_inbound_group_sessions(&[first_session.clone()]).await.unwrap();\n\n        // Get the cancel request.\n        let request = machine.outgoing_requests.iter().next().unwrap();\n        let id = request.request_id.clone();\n        drop(request);\n        machine.mark_outgoing_request_as_sent(&id).await.unwrap();\n\n        machine.create_outgoing_key_request(session.room_id(), &room_event).await.unwrap();\n\n        let requests = machine.outgoing_to_device_requests().await.unwrap();\n        let request = &requests[0];\n\n        machine.mark_outgoing_request_as_sent(&request.request_id).await.unwrap();\n\n        let export = session.export_at_index(15).await;\n\n        let content: ForwardedRoomKeyContent = export.try_into().unwrap();\n\n        let event = DecryptedOlmV1Event::new(\n            alice_id(),\n            alice_id(),\n            alice_device.ed25519_key().unwrap(),\n            content,\n        );\n\n        let second_session = machine\n            .receive_forwarded_room_key(alice_device.curve25519_key().unwrap(), &event)\n            .await\n            .unwrap();\n\n        assert!(second_session.is_none());\n\n        let export = session.export_at_index(0).await;\n\n        let content: ForwardedRoomKeyContent = export.try_into().unwrap();\n\n        let event = DecryptedOlmV1Event::new(\n            alice_id(),\n            alice_id(),\n            alice_device.ed25519_key().unwrap(),\n            content,\n        );\n\n        let second_session = machine\n            .receive_forwarded_room_key(alice_device.curve25519_key().unwrap(), &event)\n            .await\n            .unwrap();\n\n        assert_eq!(second_session.unwrap().first_known_index(), 0);\n    }\n\n    #[async_test]\n    async fn should_share_key_test() {\n        let machine = get_machine().await;\n        let account = account();\n\n        let own_device =\n            machine.store.get_device(alice_id(), alice2_device_id()).await.unwrap().unwrap();\n\n        let (outbound, inbound) = account.create_group_session_pair_with_defaults(room_id()).await;\n\n        // We don't share keys with untrusted devices.\n        assert_matches!(\n            machine.should_share_key(&own_device, &inbound).await,\n            Err(KeyForwardDecision::UntrustedDevice)\n        );\n        own_device.set_trust_state(LocalTrust::Verified);\n        // Now we do want to share the keys.\n        machine.should_share_key(&own_device, &inbound).await.unwrap();\n\n        let bob_device = ReadOnlyDevice::from_account(&bob_account()).await;\n        machine.store.save_devices(&[bob_device]).await.unwrap();\n\n        let bob_device =\n            machine.store.get_device(bob_id(), bob_device_id()).await.unwrap().unwrap();\n\n        // We don't share sessions with other user's devices if no outbound\n        // session was provided.\n        assert_matches!(\n            machine.should_share_key(&bob_device, &inbound).await,\n            Err(KeyForwardDecision::MissingOutboundSession)\n        );\n\n        let mut changes = Changes::default();\n\n        changes.outbound_group_sessions.push(outbound.clone());\n        changes.inbound_group_sessions.push(inbound.clone());\n        machine.store.save_changes(changes).await.unwrap();\n        machine.outbound_group_sessions.insert(outbound.clone());\n\n        // We don't share sessions with other user's devices if the session\n        // wasn't shared in the first place.\n        assert_matches!(\n            machine.should_share_key(&bob_device, &inbound).await,\n            Err(KeyForwardDecision::OutboundSessionNotShared)\n        );\n\n        bob_device.set_trust_state(LocalTrust::Verified);\n\n        // We don't share sessions with other user's devices if the session\n        // wasn't shared in the first place even if the device is trusted.\n        assert_matches!(\n            machine.should_share_key(&bob_device, &inbound).await,\n            Err(KeyForwardDecision::OutboundSessionNotShared)\n        );\n\n        // We now share the session, since it was shared before.\n        outbound\n            .mark_shared_with(\n                bob_device.user_id(),\n                bob_device.device_id(),\n                bob_device.curve25519_key().unwrap(),\n            )\n            .await;\n        machine.should_share_key(&bob_device, &inbound).await.unwrap();\n\n        let (other_outbound, other_inbound) =\n            account.create_group_session_pair_with_defaults(room_id()).await;\n\n        // But we don't share some other session that doesn't match our outbound\n        // session.\n        assert_matches!(\n            machine.should_share_key(&bob_device, &other_inbound).await,\n            Err(KeyForwardDecision::MissingOutboundSession)\n        );\n\n        // Finally, let's ensure we don't share the session with a device that rotated\n        // its curve25519 key.\n        let bob_device = ReadOnlyDevice::from_account(&bob_account()).await;\n        machine.store.save_devices(&[bob_device]).await.unwrap();\n\n        let bob_device =\n            machine.store.get_device(bob_id(), bob_device_id()).await.unwrap().unwrap();\n        assert_matches!(\n            machine.should_share_key(&bob_device, &inbound).await,\n            Err(KeyForwardDecision::ChangedSenderKey)\n        );\n\n        // Now let's encrypt some messages in another session to increment the message\n        // index and then share it with our own untrusted device.\n        own_device.set_trust_state(LocalTrust::Unset);\n\n        for _ in 1..=3 {\n            other_outbound.encrypt_helper(\"foo\".to_owned()).await;\n        }\n        other_outbound\n            .mark_shared_with(\n                own_device.user_id(),\n                own_device.device_id(),\n                own_device.curve25519_key().unwrap(),\n            )\n            .await;\n\n        machine.outbound_group_sessions.insert(other_outbound.clone());\n\n        // Since our device is untrusted, we should share the session starting only from\n        // the current index (at which the message was marked as shared). This\n        // should be 3 since we encrypted 3 messages.\n        assert_matches!(machine.should_share_key(&own_device, &other_inbound).await, Ok(Some(3)));\n\n        own_device.set_trust_state(LocalTrust::Verified);\n\n        // However once our device is trusted, we share the entire session.\n        assert_matches!(machine.should_share_key(&own_device, &other_inbound).await, Ok(None));\n    }\n\n    #[async_test]\n    async fn key_share_cycle() {\n        let (alice_machine, alice_account, group_session, bob_machine) =\n            machines_for_key_share(true).await;\n\n        // Get the request and convert it into a event.\n        let requests = alice_machine.outgoing_to_device_requests().await.unwrap();\n        let request = &requests[0];\n        let event = request_to_event(alice_id(), alice_id(), request);\n\n        alice_machine.mark_outgoing_request_as_sent(&request.request_id).await.unwrap();\n\n        // Bob doesn't have any outgoing requests.\n        assert!(bob_machine.outgoing_requests.is_empty());\n\n        // Receive the room key request from alice.\n        bob_machine.receive_incoming_key_request(&event);\n        bob_machine.collect_incoming_key_requests().await.unwrap();\n        // Now bob does have an outgoing request.\n        assert!(!bob_machine.outgoing_requests.is_empty());\n\n        // Get the request and convert it to a encrypted to-device event.\n        let requests = bob_machine.outgoing_to_device_requests().await.unwrap();\n        let request = &requests[0];\n\n        let event: EncryptedToDeviceEvent = request_to_event(alice_id(), alice_id(), request);\n        bob_machine.mark_outgoing_request_as_sent(&request.request_id).await.unwrap();\n\n        // Check that alice doesn't have the session.\n        assert!(alice_machine\n            .store\n            .get_inbound_group_session(\n                room_id(),\n                &bob_machine.store.account().identity_keys().curve25519.to_base64(),\n                group_session.session_id()\n            )\n            .await\n            .unwrap()\n            .is_none());\n\n        let decrypted = alice_account.decrypt_to_device_event(&event).await.unwrap();\n\n        if let AnyDecryptedOlmEvent::ForwardedRoomKey(e) = decrypted.result.event {\n            let session = alice_machine\n                .receive_forwarded_room_key(decrypted.result.sender_key, &e)\n                .await\n                .unwrap();\n            alice_machine.store.save_inbound_group_sessions(&[session.unwrap()]).await.unwrap();\n        } else {\n            panic!(\"Invalid decrypted event type\");\n        }\n\n        // Check that alice now does have the session.\n        let session = alice_machine\n            .store\n            .get_inbound_group_session(\n                room_id(),\n                &decrypted.result.sender_key.to_base64(),\n                group_session.session_id(),\n            )\n            .await\n            .unwrap()\n            .unwrap();\n\n        assert_eq!(session.session_id(), group_session.session_id())\n    }\n\n    #[async_test]\n    async fn secret_share_cycle() {\n        let alice_machine = get_machine().await;\n        let alice_account = Account { inner: account(), store: alice_machine.store.clone() };\n\n        let second_account = alice_2_account();\n        let alice_device = ReadOnlyDevice::from_account(&second_account).await;\n\n        let bob_account = bob_account();\n        let bob_device = ReadOnlyDevice::from_account(&bob_account).await;\n\n        alice_machine.store.save_devices(&[alice_device.clone()]).await.unwrap();\n\n        // Create Olm sessions for our two accounts.\n        let (alice_session, _) = alice_account.create_session_for(&second_account).await;\n\n        alice_machine.store.save_sessions(&[alice_session]).await.unwrap();\n\n        let event = RumaToDeviceEvent {\n            sender: bob_account.user_id().to_owned(),\n            content: ToDeviceSecretRequestEventContent::new(\n                RequestAction::Request(SecretName::CrossSigningMasterKey),\n                bob_account.device_id().to_owned(),\n                \"request_id\".into(),\n            ),\n        };\n\n        // No secret found\n        assert!(alice_machine.outgoing_requests.is_empty());\n        alice_machine.receive_incoming_secret_request(&event);\n        alice_machine.collect_incoming_key_requests().await.unwrap();\n        assert!(alice_machine.outgoing_requests.is_empty());\n\n        // No device found\n        alice_machine.store.reset_cross_signing_identity().await;\n        alice_machine.receive_incoming_secret_request(&event);\n        alice_machine.collect_incoming_key_requests().await.unwrap();\n        assert!(alice_machine.outgoing_requests.is_empty());\n\n        alice_machine.store.save_devices(&[bob_device]).await.unwrap();\n\n        // The device doesn't belong to us\n        alice_machine.store.reset_cross_signing_identity().await;\n        alice_machine.receive_incoming_secret_request(&event);\n        alice_machine.collect_incoming_key_requests().await.unwrap();\n        assert!(alice_machine.outgoing_requests.is_empty());\n\n        let event = RumaToDeviceEvent {\n            sender: alice_id().to_owned(),\n            content: ToDeviceSecretRequestEventContent::new(\n                RequestAction::Request(SecretName::CrossSigningMasterKey),\n                second_account.device_id().into(),\n                \"request_id\".into(),\n            ),\n        };\n\n        // The device isn't trusted\n        alice_machine.receive_incoming_secret_request(&event);\n        alice_machine.collect_incoming_key_requests().await.unwrap();\n        assert!(alice_machine.outgoing_requests.is_empty());\n\n        // We need a trusted device, otherwise we won't serve secrets\n        alice_device.set_trust_state(LocalTrust::Verified);\n        alice_machine.store.save_devices(&[alice_device.clone()]).await.unwrap();\n\n        alice_machine.receive_incoming_secret_request(&event);\n        alice_machine.collect_incoming_key_requests().await.unwrap();\n        assert!(!alice_machine.outgoing_requests.is_empty());\n    }\n\n    #[async_test]\n    async fn key_share_cycle_without_session() {\n        let (alice_machine, alice_account, group_session, bob_machine) =\n            machines_for_key_share(false).await;\n\n        // Get the request and convert it into a event.\n        let requests = alice_machine.outgoing_to_device_requests().await.unwrap();\n        let request = &requests[0];\n        let event = request_to_event(alice_id(), alice_id(), request);\n\n        alice_machine.mark_outgoing_request_as_sent(&request.request_id).await.unwrap();\n\n        // Bob doesn't have any outgoing requests.\n        assert!(bob_machine.outgoing_to_device_requests().await.unwrap().is_empty());\n        assert!(bob_machine.users_for_key_claim.is_empty());\n        assert!(bob_machine.wait_queue.is_empty());\n\n        // Receive the room key request from alice.\n        bob_machine.receive_incoming_key_request(&event);\n        bob_machine.collect_incoming_key_requests().await.unwrap();\n        // Bob only has a keys claim request, since we're lacking a session\n        assert_eq!(bob_machine.outgoing_to_device_requests().await.unwrap().len(), 1);\n        assert_matches!(\n            bob_machine.outgoing_to_device_requests().await.unwrap().first().unwrap().request(),\n            OutgoingRequests::KeysClaim(_)\n        );\n        assert!(!bob_machine.users_for_key_claim.is_empty());\n        assert!(!bob_machine.wait_queue.is_empty());\n\n        let (alice_session, bob_session) =\n            alice_machine.store.account().create_session_for(bob_machine.store.account()).await;\n        // We create a session now.\n        alice_machine.store.save_sessions(&[alice_session]).await.unwrap();\n        bob_machine.store.save_sessions(&[bob_session]).await.unwrap();\n\n        bob_machine.retry_keyshare(alice_id(), alice_device_id());\n        assert!(bob_machine.users_for_key_claim.is_empty());\n        bob_machine.collect_incoming_key_requests().await.unwrap();\n        // Bob now has an outgoing requests.\n        assert!(!bob_machine.outgoing_to_device_requests().await.unwrap().is_empty());\n        assert!(bob_machine.wait_queue.is_empty());\n\n        // Get the request and convert it to a encrypted to-device event.\n        let requests = bob_machine.outgoing_to_device_requests().await.unwrap();\n        let request = &requests[0];\n\n        let event: EncryptedToDeviceEvent = request_to_event(alice_id(), alice_id(), request);\n        bob_machine.mark_outgoing_request_as_sent(&request.request_id).await.unwrap();\n\n        // Check that alice doesn't have the session.\n        assert!(alice_machine\n            .store\n            .get_inbound_group_session(\n                room_id(),\n                &bob_machine.store.account().identity_keys().curve25519.to_base64(),\n                group_session.session_id()\n            )\n            .await\n            .unwrap()\n            .is_none());\n\n        let decrypted = alice_account.decrypt_to_device_event(&event).await.unwrap();\n\n        if let AnyDecryptedOlmEvent::ForwardedRoomKey(e) = decrypted.result.event {\n            let session = alice_machine\n                .receive_forwarded_room_key(decrypted.result.sender_key, &e)\n                .await\n                .unwrap();\n            alice_machine.store.save_inbound_group_sessions(&[session.unwrap()]).await.unwrap();\n        } else {\n            panic!(\"Invalid decrypted event type\");\n        }\n\n        // Check that alice now does have the session.\n        let session = alice_machine\n            .store\n            .get_inbound_group_session(\n                room_id(),\n                &decrypted.result.sender_key.to_base64(),\n                group_session.session_id(),\n            )\n            .await\n            .unwrap()\n            .unwrap();\n\n        assert_eq!(session.session_id(), group_session.session_id())\n    }\n}\n"], "filenames": ["crates/matrix-sdk-crypto/src/gossiping/machine.rs"], "buggy_code_start_loc": [947], "buggy_code_end_loc": [961], "fixing_code_start_loc": [948], "fixing_code_end_loc": [990], "type": "CWE-287", "message": "matrix-rust-sdk is an implementation of a Matrix client-server library in Rust, and matrix-sdk-crypto is the Matrix encryption library. Prior to version 0.6, when a user requests a room key from their devices, the software correctly remembers the request. When the user receives a forwarded room key, the software accepts it without checking who the room key came from. This allows homeservers to try to insert room keys of questionable validity, potentially mounting an impersonation attack. Version 0.6 fixes this issue.", "other": {"cve": {"id": "CVE-2022-39252", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-29T15:15:10.203", "lastModified": "2022-10-03T19:30:33.450", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "matrix-rust-sdk is an implementation of a Matrix client-server library in Rust, and matrix-sdk-crypto is the Matrix encryption library. Prior to version 0.6, when a user requests a room key from their devices, the software correctly remembers the request. When the user receives a forwarded room key, the software accepts it without checking who the room key came from. This allows homeservers to try to insert room keys of questionable validity, potentially mounting an impersonation attack. Version 0.6 fixes this issue."}, {"lang": "es", "value": "matrix-rust-sdk es una implementaci\u00f3n de una biblioteca cliente-servidor de Matrix en Rust, y matrix-sdk-crypto es la biblioteca de cifrado de Matrix. En versiones anteriores a 0.6, cuando un usuario solicita una clave de habitaci\u00f3n de sus dispositivos, el software recuerda correctamente la petici\u00f3n. Cuando el usuario recibe una clave de habitaci\u00f3n reenviada, el software la acepta sin comprobar de qui\u00e9n procede la clave de habitaci\u00f3n. Esto permite que los servidores dom\u00e9sticos intenten insertar llaves de habitaci\u00f3n de dudosa validez, montando potencialmente un ataque de suplantaci\u00f3n de identidad. La versi\u00f3n 0.6 corrige este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}, {"lang": "en", "value": "CWE-322"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matrix:matrix-rust-sdk:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6", "matchCriteriaId": "F1E85202-DC28-4527-AA25-2B465E267E80"}]}]}], "references": [{"url": "https://github.com/matrix-org/matrix-rust-sdk/commit/093fb5d0aa21c0b5eaea6ec96b477f1075271cbb", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/matrix-org/matrix-rust-sdk/commit/41449d2cc360e347f5d4e1c154ec1e3185f11acd", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/matrix-org/matrix-rust-sdk/releases/tag/matrix-sdk-0.6.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/matrix-org/matrix-rust-sdk/security/advisories/GHSA-vp68-2wrm-69qm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/matrix-org/matrix-rust-sdk/commit/093fb5d0aa21c0b5eaea6ec96b477f1075271cbb"}}