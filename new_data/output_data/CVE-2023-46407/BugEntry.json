{"buggy_code": ["/**\n * JPEG XL parser\n * Copyright (c) 2023 Leo Izen <leo.izen@gmail.com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <errno.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/error.h\"\n#include \"libavutil/intmath.h\"\n#include \"libavutil/macros.h\"\n#include \"libavutil/mem.h\"\n#include \"libavutil/pixfmt.h\"\n\n#include \"bytestream.h\"\n#include \"codec_id.h\"\n#define UNCHECKED_BITSTREAM_READER 0\n#define BITSTREAM_READER_LE\n#include \"get_bits.h\"\n#include \"jpegxl.h\"\n#include \"jpegxl_parse.h\"\n#include \"parser.h\"\n#include \"vlc.h\"\n\n#define JXL_FLAG_NOISE 1\n#define JXL_FLAG_PATCHES 2\n#define JXL_FLAG_SPLINES 16\n#define JXL_FLAG_USE_LF_FRAME 32\n#define JXL_FLAG_SKIP_ADAPTIVE_LF_SMOOTH 128\n\n#define MAX_PREFIX_ALPHABET_SIZE (1u << 15)\n\n#define clog1p(x) (ff_log2(x) + !!(x))\n#define unpack_signed(x) (((x) & 1 ? -(x)-1 : (x))/2)\n#define div_ceil(x, y) (((x) - 1) / (y) + 1)\n#define vlm(a,b) {.sym = (a), .len = (b)}\n\ntypedef struct JXLHybridUintConf {\n    int split_exponent;\n    uint32_t msb_in_token;\n    uint32_t lsb_in_token;\n} JXLHybridUintConf;\n\ntypedef struct JXLSymbolDistribution {\n    JXLHybridUintConf config;\n    int log_bucket_size;\n    /* this is the actual size of the alphabet */\n    int alphabet_size;\n    /* ceil(log(alphabet_size)) */\n    int log_alphabet_size;\n\n    /* for prefix code distributions */\n    VLC vlc;\n    /* in case bits == 0 */\n    uint32_t default_symbol;\n\n    /*\n     * each (1 << log_alphabet_size) length\n     * with log_alphabet_size <= 8\n     */\n    /* frequencies associated with this Distribution */\n    uint32_t freq[258];\n    /* cutoffs for using the symbol table */\n    uint16_t cutoffs[258];\n    /* the symbol table for this distribution */\n    uint16_t symbols[258];\n    /* the offset for symbols */\n    uint16_t offsets[258];\n\n    /* if this distribution contains only one symbol this is its index */\n    int uniq_pos;\n} JXLSymbolDistribution;\n\ntypedef struct JXLDistributionBundle {\n    /* lz77 flags */\n    int lz77_enabled;\n    uint32_t lz77_min_symbol;\n    uint32_t lz77_min_length;\n    JXLHybridUintConf lz_len_conf;\n\n    /* one entry for each distribution */\n    uint8_t *cluster_map;\n    /* length of cluster_map */\n    int num_dist;\n\n    /* one for each cluster */\n    JXLSymbolDistribution *dists;\n    int num_clusters;\n\n    /* whether to use brotli prefixes or ans */\n    int use_prefix_code;\n    /* bundle log alphabet size, dist ones may be smaller */\n    int log_alphabet_size;\n} JXLDistributionBundle;\n\ntypedef struct JXLEntropyDecoder {\n\n    /* state is a positive 32-bit integer, or -1 if unset */\n    int64_t state;\n\n    /* lz77 values */\n    uint32_t num_to_copy;\n    uint32_t copy_pos;\n    uint32_t num_decoded;\n\n    /* length is (1 << 20) */\n    /* if lz77 is enabled for this bundle */\n    /* if lz77 is disabled it's NULL */\n    uint32_t *window;\n\n    /* primary bundle associated with this distribution */\n    JXLDistributionBundle bundle;\n\n    /* for av_log */\n    void *logctx;\n} JXLEntropyDecoder;\n\ntypedef struct JXLFrame {\n    FFJXLFrameType type;\n    FFJXLFrameEncoding encoding;\n\n    int is_last;\n    int full_frame;\n\n    uint32_t total_length;\n    uint32_t body_length;\n} JXLFrame;\n\ntypedef struct JXLCodestream {\n    FFJXLMetadata meta;\n    JXLFrame frame;\n} JXLCodestream;\n\ntypedef struct JXLParseContext {\n    ParseContext pc;\n    JXLCodestream codestream;\n\n    /* using ISOBMFF-based container */\n    int container;\n    int skip;\n    int copied;\n    int collected_size;\n    int codestream_length;\n    int skipped_icc;\n    int next;\n\n    uint8_t cs_buffer[4096];\n} JXLParseContext;\n\n/* used for reading brotli prefixes */\nstatic const VLCElem level0_table[16] = {\n    vlm(0, 2), vlm(4, 2), vlm(3, 2), vlm(2, 3), vlm(0, 2), vlm(4, 2), vlm(3, 2), vlm(1, 4),\n    vlm(0, 2), vlm(4, 2), vlm(3, 2), vlm(2, 3), vlm(0, 2), vlm(4, 2), vlm(3, 2), vlm(5, 4),\n};\n\n/* prefix table for populating ANS distribution */\nstatic const VLCElem dist_prefix_table[128] = {\n    vlm(10, 3), vlm(12, 7), vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n    vlm(10, 3), vlm(0, 5),  vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n    vlm(10, 3), vlm(11, 6), vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n    vlm(10, 3), vlm(0, 5),  vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n    vlm(10, 3), vlm(13, 7), vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n    vlm(10, 3), vlm(0, 5),  vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n    vlm(10, 3), vlm(11, 6), vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n    vlm(10, 3), vlm(0, 5),  vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n};\n\nstatic const uint8_t prefix_codelen_map[18] = {\n    1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n};\n\n/**\n * Read a variable-length 8-bit integer.\n * Used when populating the ANS frequency tables.\n */\nstatic av_always_inline uint8_t jxl_u8(GetBitContext *gb)\n{\n    int n;\n    if (!get_bits1(gb))\n        return 0;\n    n = get_bits(gb, 3);\n\n    return get_bitsz(gb, n) | (1 << n);\n}\n\n/* read a U32(c_i + u(u_i)) */\nstatic av_always_inline uint32_t jxl_u32(GetBitContext *gb,\n                        uint32_t c0, uint32_t c1, uint32_t c2, uint32_t c3,\n                        uint32_t u0, uint32_t u1, uint32_t u2, uint32_t u3)\n{\n    const uint32_t constants[4] = {c0, c1, c2, c3};\n    const uint32_t ubits    [4] = {u0, u1, u2, u3};\n    uint32_t ret, choice = get_bits(gb, 2);\n\n    ret = constants[choice];\n    if (ubits[choice])\n        ret += get_bits_long(gb, ubits[choice]);\n\n    return ret;\n}\n\n/* read a U64() */\nstatic uint64_t jxl_u64(GetBitContext *gb)\n{\n    uint64_t shift = 12, ret;\n\n    switch (get_bits(gb, 2)) {\n    case 1:\n        ret = 1 + get_bits(gb, 4);\n        break;\n    case 2:\n        ret = 17 + get_bits(gb, 8);\n        break;\n    case 3:\n        ret = get_bits(gb, 12);\n        while (get_bits1(gb)) {\n            if (shift < 60) {\n                ret |= (uint64_t)get_bits(gb, 8) << shift;\n                shift += 8;\n            } else {\n                ret |= (uint64_t)get_bits(gb, 4) << shift;\n                break;\n            }\n        }\n        break;\n    default:\n        ret = 0;\n    }\n\n    return ret;\n}\n\nstatic int read_hybrid_uint_conf(GetBitContext *gb, JXLHybridUintConf *conf, int log_alphabet_size)\n{\n    conf->split_exponent = get_bitsz(gb, clog1p(log_alphabet_size));\n    if (conf->split_exponent == log_alphabet_size) {\n        conf->msb_in_token = conf->lsb_in_token = 0;\n        return 0;\n    }\n\n    conf->msb_in_token = get_bitsz(gb, clog1p(conf->split_exponent));\n    if (conf->msb_in_token > conf->split_exponent)\n        return AVERROR_INVALIDDATA;\n    conf->lsb_in_token = get_bitsz(gb, clog1p(conf->split_exponent - conf->msb_in_token));\n    if (conf->msb_in_token + conf->lsb_in_token > conf->split_exponent)\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\nstatic int read_hybrid_uint(GetBitContext *gb, const JXLHybridUintConf *conf, uint32_t token, uint32_t *hybrid_uint)\n{\n    uint32_t n, low, split = 1 << conf->split_exponent;\n\n    if (token < split) {\n        *hybrid_uint = token;\n        return 0;\n    }\n\n    n = conf->split_exponent - conf->lsb_in_token - conf->msb_in_token +\n        ((token - split) >> (conf->msb_in_token + conf->lsb_in_token));\n    if (n >= 32)\n        return AVERROR_INVALIDDATA;\n    low = token & ((1 << conf->lsb_in_token) - 1);\n    token >>= conf->lsb_in_token;\n    token &= (1 << conf->msb_in_token) - 1;\n    token |= 1 << conf->msb_in_token;\n    *hybrid_uint = (((token << n) | get_bits_long(gb, n)) << conf->lsb_in_token ) | low;\n\n    return 0;\n}\n\nstatic inline uint32_t read_prefix_symbol(GetBitContext *gb, const JXLSymbolDistribution *dist)\n{\n    if (!dist->vlc.bits)\n        return dist->default_symbol;\n\n    return get_vlc2(gb, dist->vlc.table, dist->vlc.bits, 1);\n}\n\nstatic uint32_t read_ans_symbol(GetBitContext *gb, JXLEntropyDecoder *dec, const JXLSymbolDistribution *dist)\n{\n    uint32_t index, i, pos, symbol, offset;\n\n    if (dec->state < 0)\n        dec->state = get_bits_long(gb, 32);\n\n    index = dec->state & 0xFFF;\n    i = index >> dist->log_bucket_size;\n    pos = index & ((1 << dist->log_bucket_size) - 1);\n    symbol = pos >= dist->cutoffs[i] ? dist->symbols[i] : i;\n    offset = pos >= dist->cutoffs[i] ? dist->offsets[i] + pos : pos;\n    dec->state = dist->freq[symbol] * (dec->state >> 12) + offset;\n    if (dec->state < (1 << 16))\n        dec->state = (dec->state << 16) | get_bits(gb, 16);\n    dec->state &= 0xFFFFFFFF;\n\n    return symbol;\n}\n\nstatic int decode_hybrid_varlen_uint(GetBitContext *gb, JXLEntropyDecoder *dec,\n                                     const JXLDistributionBundle *bundle,\n                                     uint32_t context, uint32_t *hybrid_uint)\n{\n    int ret;\n    uint32_t token, distance;\n    const JXLSymbolDistribution *dist;\n\n    if (dec->num_to_copy > 0) {\n        *hybrid_uint = dec->window[dec->copy_pos++ & 0xFFFFF];\n        dec->num_to_copy--;\n        dec->window[dec->num_decoded++ & 0xFFFFF] = *hybrid_uint;\n        return 0;\n    }\n\n    if (context >= bundle->num_dist)\n        return AVERROR(EINVAL);\n    if (bundle->cluster_map[context] >= bundle->num_clusters)\n        return AVERROR_INVALIDDATA;\n\n    dist = &bundle->dists[bundle->cluster_map[context]];\n    if (bundle->use_prefix_code)\n        token = read_prefix_symbol(gb, dist);\n    else\n        token = read_ans_symbol(gb, dec, dist);\n\n    if (bundle->lz77_enabled && token >= bundle->lz77_min_symbol) {\n        const JXLSymbolDistribution *lz77dist = &bundle->dists[bundle->cluster_map[bundle->num_dist - 1]];\n        ret = read_hybrid_uint(gb, &bundle->lz_len_conf, token - bundle->lz77_min_symbol, &dec->num_to_copy);\n        if (ret < 0)\n            return ret;\n        dec->num_to_copy += bundle->lz77_min_length;\n        if (bundle->use_prefix_code)\n            token = read_prefix_symbol(gb, lz77dist);\n        else\n            token = read_ans_symbol(gb, dec, lz77dist);\n        ret = read_hybrid_uint(gb, &lz77dist->config, token, &distance);\n        if (ret < 0)\n            return ret;\n        distance++;\n        distance = FFMIN3(distance, dec->num_decoded, 1 << 20);\n        dec->copy_pos = dec->num_decoded - distance;\n        return decode_hybrid_varlen_uint(gb, dec, bundle, context, hybrid_uint);\n    }\n    ret = read_hybrid_uint(gb, &dist->config, token, hybrid_uint);\n    if (ret < 0)\n        return ret;\n    if (bundle->lz77_enabled)\n        dec->window[dec->num_decoded++ & 0xFFFFF] = *hybrid_uint;\n\n    return 0;\n}\n\nstatic int populate_distribution(GetBitContext *gb, JXLSymbolDistribution *dist, int log_alphabet_size)\n{\n    int len = 0, shift, omit_log = -1, omit_pos = -1;\n    int prev = 0, num_same = 0;\n    uint32_t total_count = 0;\n    uint8_t logcounts[258] = { 0 };\n    uint8_t same[258] = { 0 };\n    dist->uniq_pos = -1;\n\n    if (get_bits1(gb)) {\n        /* simple code */\n        dist->alphabet_size = 256;\n        if (get_bits1(gb)) {\n            uint8_t v1 = jxl_u8(gb);\n            uint8_t v2 = jxl_u8(gb);\n            if (v1 == v2)\n                return AVERROR_INVALIDDATA;\n            dist->freq[v1] = get_bits(gb, 12);\n            dist->freq[v2] = (1 << 12) - dist->freq[v1];\n            if (!dist->freq[v1])\n                dist->uniq_pos = v2;\n        } else {\n            uint8_t x = jxl_u8(gb);\n            dist->freq[x] = 1 << 12;\n            dist->uniq_pos = x;\n        }\n        return 0;\n    }\n\n    if (get_bits1(gb)) {\n        /* flat code */\n        dist->alphabet_size = jxl_u8(gb) + 1;\n        for (int i = 0; i < dist->alphabet_size; i++)\n            dist->freq[i] = (1 << 12) / dist->alphabet_size;\n        for (int i = 0; i < (1 << 12) % dist->alphabet_size; i++)\n            dist->freq[i]++;\n        return 0;\n    }\n\n    do {\n        if (!get_bits1(gb))\n            break;\n    } while (++len < 3);\n\n    shift = (get_bitsz(gb, len) | (1 << len)) - 1;\n    if (shift > 13)\n        return AVERROR_INVALIDDATA;\n\n    dist->alphabet_size = jxl_u8(gb) + 3;\n    for (int i = 0; i < dist->alphabet_size; i++) {\n        logcounts[i] = get_vlc2(gb, dist_prefix_table, 7, 1);\n        if (logcounts[i] == 13) {\n            int rle = jxl_u8(gb);\n            same[i] = rle + 5;\n            i += rle + 3;\n            continue;\n        }\n        if (logcounts[i] > omit_log) {\n            omit_log = logcounts[i];\n            omit_pos = i;\n        }\n    }\n    if (omit_pos < 0 || omit_pos + 1 < dist->alphabet_size && logcounts[omit_pos + 1] == 13)\n        return AVERROR_INVALIDDATA;\n\n    for (int i = 0; i < dist->alphabet_size; i++) {\n        if (same[i]) {\n            num_same = same[i] - 1;\n            prev = i > 0 ? dist->freq[i - 1] : 0;\n        }\n        if (num_same) {\n            dist->freq[i] = prev;\n            num_same--;\n        } else {\n            if (i == omit_pos || !logcounts[i])\n                continue;\n            if (logcounts[i] == 1) {\n                dist->freq[i] = 1;\n            } else {\n                int bitcount = FFMIN(FFMAX(0, shift - ((12 - logcounts[i] + 1) >> 1)), logcounts[i] - 1);\n                dist->freq[i] = (1 << (logcounts[i] - 1)) + (get_bitsz(gb, bitcount) << (logcounts[i] - 1 - bitcount));\n            }\n        }\n        total_count += dist->freq[i];\n    }\n    dist->freq[omit_pos] = (1 << 12) - total_count;\n\n    return 0;\n}\n\nstatic void dist_bundle_close(JXLDistributionBundle *bundle)\n{\n    if (bundle->use_prefix_code && bundle->dists)\n        for (int i = 0; i < bundle->num_clusters; i++)\n            ff_vlc_free(&bundle->dists[i].vlc);\n    av_freep(&bundle->dists);\n    av_freep(&bundle->cluster_map);\n}\n\n\nstatic int read_distribution_bundle(GetBitContext *gb, JXLEntropyDecoder *dec,\n                                    JXLDistributionBundle *bundle, int num_dist, int disallow_lz77);\n\nstatic int read_dist_clustering(GetBitContext *gb, JXLEntropyDecoder *dec, JXLDistributionBundle *bundle)\n{\n    int ret;\n\n    bundle->cluster_map = av_malloc(bundle->num_dist);\n    if (!bundle->cluster_map)\n        return AVERROR(ENOMEM);\n\n    if (bundle->num_dist == 1) {\n        bundle->cluster_map[0] = 0;\n        bundle->num_clusters = 1;\n        return 0;\n    }\n\n    if (get_bits1(gb)) {\n        /* simple clustering */\n        uint32_t nbits = get_bits(gb, 2);\n        for (int i = 0; i < bundle->num_dist; i++)\n            bundle->cluster_map[i] = get_bitsz(gb, nbits);\n    } else {\n        /* complex clustering */\n        int use_mtf = get_bits1(gb);\n        JXLDistributionBundle nested = { 0 };\n        /* num_dist == 1 prevents this from recursing again */\n        ret = read_distribution_bundle(gb, dec, &nested, 1, bundle->num_dist <= 2);\n        if (ret < 0) {\n            dist_bundle_close(&nested);\n            return ret;\n        }\n        for (int i = 0; i < bundle->num_dist; i++) {\n            uint32_t clust;\n            ret = decode_hybrid_varlen_uint(gb, dec, &nested, 0, &clust);\n            if (ret < 0) {\n                dist_bundle_close(&nested);\n                return ret;\n            }\n            bundle->cluster_map[i] = clust;\n        }\n        dec->state = -1;\n        /* it's not going to necessarily be zero after reading */\n        dec->num_to_copy = 0;\n        dist_bundle_close(&nested);\n        if (use_mtf) {\n            uint8_t mtf[256];\n            for (int i = 0; i < 256; i++)\n                mtf[i] = i;\n            for (int i = 0; i < bundle->num_dist; i++) {\n                int index = bundle->cluster_map[i];\n                bundle->cluster_map[i] = mtf[index];\n                if (index) {\n                    int value = mtf[index];\n                    for (int j = index; j > 0; j--)\n                        mtf[j] = mtf[j - 1];\n                    mtf[0] = value;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < bundle->num_dist; i++) {\n        if (bundle->cluster_map[i] >= bundle->num_clusters)\n            bundle->num_clusters = bundle->cluster_map[i] + 1;\n    }\n\n    if (bundle->num_clusters > bundle->num_dist)\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\nstatic int gen_alias_map(JXLEntropyDecoder *dec, JXLSymbolDistribution *dist, int log_alphabet_size)\n{\n    uint32_t bucket_size, table_size;\n    uint8_t overfull[256], underfull[256];\n    int overfull_pos = 0, underfull_pos = 0;\n    dist->log_bucket_size = 12 - log_alphabet_size;\n    bucket_size = 1 << dist->log_bucket_size;\n    table_size = 1 << log_alphabet_size;\n\n    if (dist->uniq_pos >= 0) {\n        for (int i = 0; i < table_size; i++) {\n            dist->symbols[i] = dist->uniq_pos;\n            dist->offsets[i] = bucket_size * i;\n            dist->cutoffs[i] = 0;\n        }\n        return 0;\n    }\n\n    for (int i = 0; i < dist->alphabet_size; i++) {\n        dist->cutoffs[i] = dist->freq[i];\n        dist->symbols[i] = i;\n        if (dist->cutoffs[i] > bucket_size)\n            overfull[overfull_pos++] = i;\n        else if (dist->cutoffs[i] < bucket_size)\n            underfull[underfull_pos++] = i;\n    }\n\n    for (int i = dist->alphabet_size; i < table_size; i++) {\n        dist->cutoffs[i] = 0;\n        underfull[underfull_pos++] = i;\n    }\n\n    while (overfull_pos) {\n        int o, u, by;\n        /* this should be impossible */\n        if (!underfull_pos)\n            return AVERROR_INVALIDDATA;\n        u = underfull[--underfull_pos];\n        o = overfull[--overfull_pos];\n        by = bucket_size - dist->cutoffs[u];\n        dist->cutoffs[o] -= by;\n        dist->symbols[u] = o;\n        dist->offsets[u] = dist->cutoffs[o];\n        if (dist->cutoffs[o] < bucket_size)\n            underfull[underfull_pos++] = o;\n        else if (dist->cutoffs[o] > bucket_size)\n            overfull[overfull_pos++] = o;\n    }\n\n    for (int i = 0; i < table_size; i++) {\n        if (dist->cutoffs[i] == bucket_size) {\n            dist->symbols[i] = i;\n            dist->offsets[i] = 0;\n            dist->cutoffs[i] = 0;\n        } else {\n            dist->offsets[i] -= dist->cutoffs[i];\n        }\n    }\n\n    return 0;\n}\n\nstatic int read_simple_vlc_prefix(GetBitContext *gb, JXLEntropyDecoder *dec, JXLSymbolDistribution *dist)\n{\n    int nsym, tree_select, bits;\n\n    int8_t lens[4];\n    int16_t symbols[4];\n\n    nsym = 1 + get_bits(gb, 2);\n    for (int i = 0; i < nsym; i++)\n        symbols[i] = get_bitsz(gb, dist->log_alphabet_size);\n    if (nsym == 4)\n        tree_select = get_bits1(gb);\n    switch (nsym) {\n    case 1:\n        dist->vlc.bits = 0;\n        dist->default_symbol = symbols[0];\n        return 0;\n    case 2:\n        bits = 1;\n        lens[0] = 1, lens[1] = 1, lens[2] = 0, lens[3] = 0;\n        if (symbols[1] < symbols[0])\n            FFSWAP(int16_t, symbols[0], symbols[1]);\n        break;\n    case 3:\n        bits = 2;\n        lens[0] = 1, lens[1] = 2, lens[2] = 2, lens[3] = 0;\n        if (symbols[2] < symbols[1])\n            FFSWAP(int16_t, symbols[1], symbols[2]);\n        break;\n    case 4:\n        if (tree_select) {\n            bits = 3;\n            lens[0] = 1, lens[1] = 2, lens[2] = 3, lens[3] = 3;\n            if (symbols[3] < symbols[2])\n                FFSWAP(int16_t, symbols[2], symbols[3]);\n        } else {\n            bits = 2;\n            lens[0] = 2, lens[1] = 2, lens[2] = 2, lens[3] = 2;\n            while (1) {\n                if (symbols[1] < symbols[0])\n                    FFSWAP(int16_t, symbols[0], symbols[1]);\n                if (symbols[3] < symbols[2])\n                    FFSWAP(int16_t, symbols[2], symbols[3]);\n                if (symbols[1] <= symbols[2])\n                    break;\n                FFSWAP(int16_t, symbols[1], symbols[2]);\n            }\n        }\n        break;\n    default:\n        // Challenge Complete! How did we get here?\n        return AVERROR_BUG;\n    }\n\n    return ff_vlc_init_from_lengths(&dist->vlc, bits, nsym, lens, 1, symbols,\n                                    2, 2, 0, VLC_INIT_LE, dec->logctx);\n}\n\nstatic int read_vlc_prefix(GetBitContext *gb, JXLEntropyDecoder *dec, JXLSymbolDistribution *dist)\n{\n    int8_t level1_lens[18] = { 0 };\n    int8_t level1_lens_s[18] = { 0 };\n    int16_t level1_syms[18] = { 0 };\n    uint32_t level1_codecounts[19] = { 0 };\n    uint8_t *buf = NULL;\n    int8_t *level2_lens, *level2_lens_s;\n    int16_t *level2_syms;\n    uint32_t *level2_codecounts;\n\n    int repeat_count_prev = 0, repeat_count_zero = 0, prev = 8;\n    int total_code = 0, len, hskip, num_codes = 0, ret;\n\n    VLC level1_vlc;\n\n    if (dist->alphabet_size == 1) {\n        dist->vlc.bits = 0;\n        dist->default_symbol = 0;\n        return 0;\n    }\n\n    hskip = get_bits(gb, 2);\n    if (hskip == 1)\n        return read_simple_vlc_prefix(gb, dec, dist);\n\n    level1_codecounts[0] = hskip;\n    for (int i = hskip; i < 18; i++) {\n        len = level1_lens[prefix_codelen_map[i]] = get_vlc2(gb, level0_table, 4, 1);\n        level1_codecounts[len]++;\n        if (len) {\n            total_code += (32 >> len);\n            num_codes++;\n        }\n        if (total_code >= 32) {\n            level1_codecounts[0] += 18 - i - 1;\n            break;\n        }\n    }\n\n    if (total_code != 32 && num_codes >= 2 || num_codes < 1)\n        return AVERROR_INVALIDDATA;\n\n    for (int i = 1; i < 19; i++)\n         level1_codecounts[i] += level1_codecounts[i - 1];\n\n    for (int i = 17; i >= 0; i--) {\n        int idx = --level1_codecounts[level1_lens[i]];\n        level1_lens_s[idx] = level1_lens[i];\n        level1_syms[idx] = i;\n    }\n\n    ret = ff_vlc_init_from_lengths(&level1_vlc, 5, 18, level1_lens_s, 1, level1_syms, 2, 2,\n        0, VLC_INIT_LE, dec->logctx);\n    if (ret < 0)\n        goto end;\n\n    buf = av_mallocz(dist->alphabet_size * (2 * sizeof(int8_t) + sizeof(int16_t) + sizeof(uint32_t))\n                     + sizeof(uint32_t));\n    if (!buf) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    level2_lens = (int8_t *)buf;\n    level2_lens_s = (int8_t *)(buf + dist->alphabet_size * sizeof(int8_t));\n    level2_syms = (int16_t *)(buf + dist->alphabet_size * (2 * sizeof(int8_t)));\n    level2_codecounts = (uint32_t *)(buf + dist->alphabet_size * (2 * sizeof(int8_t) + sizeof(int16_t)));\n\n    total_code = 0;\n    for (int i = 0; i < dist->alphabet_size; i++) {\n        len = get_vlc2(gb, level1_vlc.table, 5, 1);\n        if (len == 16) {\n            int extra = 3 + get_bits(gb, 2);\n            if (repeat_count_prev)\n                extra = 4 * (repeat_count_prev - 2) - repeat_count_prev + extra;\n            if (i + extra > dist->alphabet_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto end;\n            }\n            for (int j = 0; j < extra; j++)\n                level2_lens[i + j] = prev;\n            total_code += (32768 >> prev) * extra;\n            i += extra - 1;\n            repeat_count_prev += extra;\n            repeat_count_zero = 0;\n            level2_codecounts[prev] += extra;\n        } else if (len == 17) {\n            int extra = 3 + get_bits(gb, 3);\n            if (repeat_count_zero > 0)\n                extra = 8 * (repeat_count_zero - 2) - repeat_count_zero + extra;\n            i += extra - 1;\n            repeat_count_prev = 0;\n            repeat_count_zero += extra;\n            level2_codecounts[0] += extra;\n        } else {\n            level2_lens[i] = len;\n            repeat_count_prev = repeat_count_zero = 0;\n            if (len) {\n                total_code += (32768 >> len);\n                prev = len;\n            }\n            level2_codecounts[len]++;\n        }\n        if (total_code >= 32768) {\n            level2_codecounts[0] += dist->alphabet_size - i - 1;\n            break;\n        }\n    }\n\n    if (total_code != 32768 && level2_codecounts[0] < dist->alphabet_size - 1) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    for (int i = 1; i < dist->alphabet_size + 1; i++)\n        level2_codecounts[i] += level2_codecounts[i - 1];\n\n    for (int i = dist->alphabet_size - 1; i >= 0; i--) {\n        int idx = --level2_codecounts[level2_lens[i]];\n        level2_lens_s[idx] = level2_lens[i];\n        level2_syms[idx] = i;\n    }\n\n    ret = ff_vlc_init_from_lengths(&dist->vlc, 15, dist->alphabet_size, level2_lens_s,\n                                    1, level2_syms, 2, 2, 0, VLC_INIT_LE, dec->logctx);\n\nend:\n    av_freep(&buf);\n    ff_vlc_free(&level1_vlc);\n\n    return ret;\n}\n\nstatic int read_distribution_bundle(GetBitContext *gb, JXLEntropyDecoder *dec,\n                                    JXLDistributionBundle *bundle, int num_dist, int disallow_lz77)\n{\n    int ret;\n\n    if (num_dist <= 0)\n        return AVERROR(EINVAL);\n\n    bundle->num_dist = num_dist;\n    bundle->lz77_enabled = get_bits1(gb);\n    if (bundle->lz77_enabled) {\n        if (disallow_lz77)\n            return AVERROR_INVALIDDATA;\n        bundle->lz77_min_symbol = jxl_u32(gb, 224, 512, 4096, 8, 0, 0, 0, 15);\n        bundle->lz77_min_length = jxl_u32(gb, 3, 4, 5, 9, 0, 0, 2, 8);\n        bundle->num_dist++;\n        ret = read_hybrid_uint_conf(gb, &bundle->lz_len_conf, 8);\n        if (ret < 0)\n            return ret;\n    }\n\n    if (bundle->lz77_enabled && !dec->window) {\n        dec->window = av_malloc_array(1 << 20, sizeof(uint32_t));\n        if (!dec->window)\n            return AVERROR(ENOMEM);\n    }\n\n    ret = read_dist_clustering(gb, dec, bundle);\n    if (ret < 0)\n        return ret;\n    if (get_bits_left(gb) < 0)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    bundle->dists = av_calloc(bundle->num_clusters, sizeof(JXLSymbolDistribution));\n    if (!bundle->dists)\n        return AVERROR(ENOMEM);\n\n    bundle->use_prefix_code = get_bits1(gb);\n    bundle->log_alphabet_size = bundle->use_prefix_code ? 15 : 5 + get_bits(gb, 2);\n\n    for (int i = 0; i < bundle->num_clusters; i++) {\n        ret = read_hybrid_uint_conf(gb, &bundle->dists[i].config, bundle->log_alphabet_size);\n        if (ret < 0)\n            return ret;\n        if (get_bits_left(gb) < 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n\n    if (bundle->use_prefix_code) {\n        for (int i = 0; i < bundle->num_clusters; i++) {\n            JXLSymbolDistribution *dist = &bundle->dists[i];\n            if (get_bits1(gb)) {\n                int n = get_bits(gb, 4);\n                dist->alphabet_size = 1 + (1 << n) + get_bitsz(gb, n);\n                if (dist->alphabet_size > MAX_PREFIX_ALPHABET_SIZE)\n                    return AVERROR_INVALIDDATA;\n            } else {\n                dist->alphabet_size = 1;\n            }\n            dist->log_alphabet_size = clog1p(dist->alphabet_size - 1);\n        }\n        for (int i = 0; i < bundle->num_clusters; i++) {\n            ret = read_vlc_prefix(gb, dec, &bundle->dists[i]);\n            if (ret < 0)\n                return ret;\n            if (get_bits_left(gb) < 0)\n                return AVERROR_BUFFER_TOO_SMALL;\n        }\n    } else {\n        for (int i = 0; i < bundle->num_clusters; i++) {\n            ret = populate_distribution(gb, &bundle->dists[i], bundle->log_alphabet_size);\n            if (ret < 0)\n                return ret;\n            if (get_bits_left(gb) < 0)\n                return AVERROR_BUFFER_TOO_SMALL;\n        }\n        for (int i = 0; i < bundle->num_clusters; i++) {\n            ret = gen_alias_map(dec, &bundle->dists[i], bundle->log_alphabet_size);\n            if (ret < 0)\n                return ret;\n        }\n    }\n\n    return 0;\n}\n\nstatic void entropy_decoder_close(JXLEntropyDecoder *dec)\n{\n    if (!dec)\n        return;\n    av_freep(&dec->window);\n    dist_bundle_close(&dec->bundle);\n}\n\nstatic int entropy_decoder_init(void *avctx, GetBitContext *gb, JXLEntropyDecoder *dec, int num_dist)\n{\n    int ret;\n\n    memset(dec, 0, sizeof(*dec));\n    dec->logctx = avctx;\n    dec->state = -1;\n\n    ret = read_distribution_bundle(gb, dec, &dec->bundle, num_dist, 0);\n    if (ret < 0) {\n        entropy_decoder_close(dec);\n        return ret;\n    }\n\n    return 0;\n}\n\nstatic int64_t entropy_decoder_read_symbol(GetBitContext *gb, JXLEntropyDecoder *dec, uint32_t context)\n{\n    int ret;\n    uint32_t hybrid_uint;\n\n    ret = decode_hybrid_varlen_uint(gb, dec, &dec->bundle, context, &hybrid_uint);\n    if (ret < 0)\n        return ret;\n\n    return hybrid_uint;\n}\n\nstatic inline uint32_t icc_context(uint64_t i, uint32_t b1, uint32_t b2)\n{\n    uint32_t p1, p2;\n    if (i <= 128)\n        return 0;\n    if (b1 >= 'a' && b1 <= 'z' || b1 >= 'A' && b1 <= 'Z')\n        p1 = 0;\n    else if (b1 >= '0' && b1 <= '9' || b1 == '.' || b1 == ',')\n        p1 = 1;\n    else if (b1 <= 1)\n        p1 = b1 + 2;\n    else if (b1 > 1 && b1 < 16)\n        p1 = 4;\n    else if (b1 > 240 && b1 < 255)\n        p1 = 5;\n    else if (b1 == 255)\n        p1 = 6;\n    else\n        p1 = 7;\n\n    if (b2 >= 'a' && b2 <= 'z' || b2 >= 'A' && b2 <= 'Z')\n        p2 = 0;\n    else if (b2 >= '0' && b2 <= '9' || b2 == '.' || b2 == ',')\n        p2 = 1;\n    else if (b2 < 16)\n        p2 = 2;\n    else if (b2 > 240)\n        p2 = 3;\n    else\n        p2 = 4;\n\n    return 1 + p1 + p2 * 8;\n}\n\nstatic inline uint32_t toc_context(uint32_t x)\n{\n    return FFMIN(7, clog1p(x));\n}\n\nstatic void populate_fields(AVCodecParserContext *s, AVCodecContext *avctx, const FFJXLMetadata *meta)\n{\n    s->width = meta->width;\n    s->height = meta->height;\n\n    switch (meta->csp) {\n    case JPEGXL_CS_RGB:\n    case JPEGXL_CS_XYB:\n        avctx->colorspace = AVCOL_SPC_RGB;\n        break;\n    default:\n        avctx->colorspace = AVCOL_SPC_UNSPECIFIED;\n    }\n\n    if (meta->wp == JPEGXL_WP_D65) {\n        switch (meta->primaries) {\n        case JPEGXL_PR_SRGB:\n            avctx->color_primaries = AVCOL_PRI_BT709;\n            break;\n        case JPEGXL_PR_P3:\n            avctx->color_primaries = AVCOL_PRI_SMPTE432;\n            break;\n        case JPEGXL_PR_2100:\n            avctx->color_primaries = AVCOL_PRI_BT2020;\n            break;\n        default:\n            avctx->color_primaries = AVCOL_PRI_UNSPECIFIED;\n        }\n    } else if (meta->wp == JPEGXL_WP_DCI && meta->primaries == JPEGXL_PR_P3) {\n        avctx->color_primaries = AVCOL_PRI_SMPTE431;\n    } else {\n        avctx->color_primaries = AVCOL_PRI_UNSPECIFIED;\n    }\n\n    if (meta->trc > JPEGXL_TR_GAMMA) {\n        FFJXLTransferCharacteristic trc = meta->trc - JPEGXL_TR_GAMMA;\n        switch (trc) {\n        case JPEGXL_TR_BT709:\n            avctx->color_trc = AVCOL_TRC_BT709;\n            break;\n        case JPEGXL_TR_LINEAR:\n            avctx->color_trc = AVCOL_TRC_LINEAR;\n            break;\n        case JPEGXL_TR_SRGB:\n            avctx->color_trc = AVCOL_TRC_IEC61966_2_1;\n            break;\n        case JPEGXL_TR_PQ:\n            avctx->color_trc = AVCOL_TRC_SMPTEST2084;\n            break;\n        case JPEGXL_TR_DCI:\n            avctx->color_trc = AVCOL_TRC_SMPTE428;\n            break;\n        case JPEGXL_TR_HLG:\n            avctx->color_trc = AVCOL_TRC_ARIB_STD_B67;\n            break;\n        default:\n            avctx->color_trc = AVCOL_TRC_UNSPECIFIED;\n        }\n    } else if (meta->trc > 0) {\n        if (meta->trc > 45355 && meta->trc < 45555)\n            avctx->color_trc = AVCOL_TRC_GAMMA22;\n        else if (meta->trc > 35614 && meta->trc < 35814)\n            avctx->color_trc = AVCOL_TRC_GAMMA28;\n        else\n            avctx->color_trc = AVCOL_TRC_UNSPECIFIED;\n    } else {\n        avctx->color_trc = AVCOL_TRC_UNSPECIFIED;\n    }\n\n    if (meta->csp == JPEGXL_CS_GRAY) {\n        if (meta->bit_depth <= 8)\n            s->format = meta->have_alpha ? AV_PIX_FMT_YA8 : AV_PIX_FMT_GRAY8;\n        else if (meta->bit_depth <= 16)\n            s->format = meta->have_alpha ? AV_PIX_FMT_YA16 : AV_PIX_FMT_GRAY16;\n        else\n            s->format = meta->have_alpha ? AV_PIX_FMT_NONE : AV_PIX_FMT_GRAYF32;\n    } else {\n        if (meta->bit_depth <= 8)\n            s->format = meta->have_alpha ? AV_PIX_FMT_RGBA : AV_PIX_FMT_RGB24;\n        else if (meta->bit_depth <= 16)\n            s->format = meta->have_alpha ? AV_PIX_FMT_RGBA64 : AV_PIX_FMT_RGB48;\n        else\n            s->format = meta->have_alpha ? AV_PIX_FMT_RGBAF32 : AV_PIX_FMT_RGBF32;\n    }\n}\n\nstatic int skip_icc_profile(void *avctx, JXLParseContext *ctx, GetBitContext *gb)\n{\n    int64_t ret;\n    uint32_t last = 0, last2 = 0;\n    JXLEntropyDecoder dec = { 0 };\n    uint64_t enc_size = jxl_u64(gb);\n    uint64_t output_size = 0;\n    int out_size_shift = 0;\n\n    if (!enc_size || enc_size > (1 << 22))\n        return AVERROR_INVALIDDATA;\n\n    ret = entropy_decoder_init(avctx, gb, &dec, 41);\n    if (ret < 0)\n        goto end;\n\n    if (get_bits_left(gb) < 0) {\n        ret = AVERROR_BUFFER_TOO_SMALL;\n        goto end;\n    }\n\n    for (uint64_t read = 0; read < enc_size; read++) {\n        ret = entropy_decoder_read_symbol(gb, &dec, icc_context(read, last, last2));\n        if (ret < 0)\n            goto end;\n        if (ret > 255) {\n            ret = AVERROR_INVALIDDATA;\n            goto end;\n        }\n        if (get_bits_left(gb) < 0) {\n            ret = AVERROR_BUFFER_TOO_SMALL;\n            goto end;\n        }\n        last2 = last;\n        last = ret;\n        if (out_size_shift < 63) {\n            output_size += (ret & UINT64_C(0x7F)) << out_size_shift;\n            if (!(ret & 0x80)) {\n                out_size_shift = 63;\n            } else {\n                out_size_shift += 7;\n                if (out_size_shift > 56) {\n                    ret = AVERROR_INVALIDDATA;\n                    goto end;\n                }\n            }\n        } else if (output_size < 132) {\n            ret = AVERROR_INVALIDDATA;\n            goto end;\n        }\n    }\n\n    ret = 0;\n\nend:\n    entropy_decoder_close(&dec);\n\n    return ret;\n}\n\nstatic int skip_extensions(GetBitContext *gb)\n{\n    uint64_t extensions = jxl_u64(gb), extensions_len = 0;\n\n    if (get_bits_left(gb) < 0)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    if (!extensions)\n        return 0;\n\n    for (int i = 0; i < 64; i++) {\n        if (extensions & (UINT64_C(1) << i))\n            extensions_len += jxl_u64(gb);\n        if (get_bits_left(gb) < 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n\n    if (extensions_len > INT_MAX || get_bits_left(gb) < extensions_len)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    skip_bits_long(gb, extensions_len);\n\n    return 0;\n}\n\nstatic int parse_frame_header(void *avctx, JXLParseContext *ctx, GetBitContext *gb)\n{\n    int all_default, do_yCbCr = 0, num_passes = 1, ret;\n    int group_size_shift = 1, lf_level = 0, save_as_ref = 0;\n    int have_crop = 0, full_frame = 1, resets_canvas = 1, upsampling = 1;\n    JXLFrame *frame = &ctx->codestream.frame;\n    const FFJXLMetadata *meta = &ctx->codestream.meta;\n    int32_t x0 = 0, y0 = 0;\n    uint32_t duration = 0, width = meta->coded_width, height = meta->coded_height;\n    uint32_t name_len, num_groups, num_lf_groups, group_dim, lf_group_dim, toc_count;\n    uint64_t flags = 0;\n    int start_len = get_bits_count(gb);\n\n    memset(frame, 0, sizeof(*frame));\n    frame->is_last = 1;\n\n    all_default = get_bits1(gb);\n    if (!all_default) {\n        frame->type = get_bits(gb, 2);\n        frame->encoding = get_bits1(gb);\n        flags = jxl_u64(gb);\n        if (!meta->xyb_encoded)\n            do_yCbCr = get_bits1(gb);\n        if (!(flags & JXL_FLAG_USE_LF_FRAME)) {\n            if (do_yCbCr)\n                skip_bits(gb, 6); // jpeg upsampling\n            upsampling = jxl_u32(gb, 1, 2, 4, 8, 0, 0, 0, 0);\n            skip_bits_long(gb, 2 * meta->num_extra_channels);\n            if (get_bits_left(gb) < 0)\n                return AVERROR_BUFFER_TOO_SMALL;\n        }\n        if (frame->encoding == JPEGXL_ENC_MODULAR)\n            group_size_shift = get_bits(gb, 2);\n        else if (meta->xyb_encoded)\n            skip_bits(gb, 6); // xqm and bqm scales\n        if (frame->type != JPEGXL_FRAME_REFERENCE_ONLY) {\n            num_passes = jxl_u32(gb, 1, 2, 3, 4, 0, 0, 0, 3);\n            if (num_passes != 1) {\n                int num_ds = jxl_u32(gb, 0, 1, 2, 3, 0, 0, 0, 1);\n                skip_bits(gb, 2 * (num_passes - 1)); // shift\n                skip_bits(gb, 2 * num_ds); // downsample\n                for (int i = 0; i < num_ds; i++)\n                    jxl_u32(gb, 0, 1, 2, 0, 0, 0, 0, 3);\n            }\n        }\n        if (frame->type == JPEGXL_FRAME_LF)\n            lf_level = 1 + get_bits(gb, 2);\n        else\n            have_crop = get_bits1(gb);\n        if (have_crop) {\n            if (frame->type != JPEGXL_FRAME_REFERENCE_ONLY) {\n                uint32_t ux0 = jxl_u32(gb, 0, 256, 2304, 18688, 8, 11, 14, 30);\n                uint32_t uy0 = jxl_u32(gb, 0, 256, 2304, 18688, 8, 11, 14, 30);\n                x0 = unpack_signed(ux0);\n                y0 = unpack_signed(uy0);\n            }\n            width = jxl_u32(gb, 0, 256, 2304, 18688, 8, 11, 14, 30);\n            height = jxl_u32(gb, 0, 256, 2304, 18688, 8, 11, 14, 30);\n            full_frame = x0 <= 0 && y0 <= 0 && width + x0 >= meta->coded_width\n                                            && height + y0 >= meta->coded_height;\n        }\n        if (get_bits_left(gb) < 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n        if (frame->type == JPEGXL_FRAME_REGULAR || frame->type == JPEGXL_FRAME_SKIP_PROGRESSIVE) {\n            for (int i = 0; i <= meta->num_extra_channels; i++) {\n                int mode = jxl_u32(gb, 0, 1, 2, 3, 0, 0, 0, 2);\n                if (meta->num_extra_channels && (mode == JPEGXL_BM_BLEND || mode == JPEGXL_BM_MULADD))\n                    jxl_u32(gb, 0, 1, 2, 3, 0, 0, 0, 2);\n                if (meta->num_extra_channels && (mode == JPEGXL_BM_BLEND || mode == JPEGXL_BM_MULADD\n                                              || mode == JPEGXL_BM_MUL))\n                    skip_bits1(gb);\n                if (!i)\n                    resets_canvas = mode == JPEGXL_BM_REPLACE && full_frame;\n                if (!resets_canvas)\n                    skip_bits(gb, 2);\n                if (get_bits_left(gb) < 0)\n                    return AVERROR_BUFFER_TOO_SMALL;\n            }\n            if (meta->animation_offset)\n                duration = jxl_u32(gb, 0, 1, 0, 0, 0, 0, 8, 32);\n            if (meta->have_timecodes)\n                skip_bits_long(gb, 32);\n            frame->is_last = get_bits1(gb);\n        } else {\n            frame->is_last = 0;\n        }\n        if (frame->type != JPEGXL_FRAME_LF && !frame->is_last)\n            save_as_ref = get_bits(gb, 2);\n        if (frame->type == JPEGXL_FRAME_REFERENCE_ONLY ||\n                (resets_canvas && !frame->is_last && (!duration || save_as_ref)\n                && frame->type != JPEGXL_FRAME_LF))\n            skip_bits1(gb); // save before color transform\n        name_len = 8 * jxl_u32(gb, 0, 0, 16, 48, 0, 4, 5, 10);\n        if (get_bits_left(gb) < name_len)\n            return AVERROR_BUFFER_TOO_SMALL;\n        skip_bits_long(gb, name_len);\n    }\n\n    if (!all_default) {\n        int restd = get_bits1(gb), gab = 1;\n        if (!restd)\n            gab = get_bits1(gb);\n        if (gab && !restd && get_bits1(gb))\n            // gab custom\n            skip_bits_long(gb, 16 * 6);\n        if (get_bits_left(gb) < 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n        if (!restd) {\n            int epf = get_bits(gb, 2);\n            if (epf) {\n                if (frame->encoding == JPEGXL_ENC_VARDCT && get_bits1(gb)) {\n                    skip_bits_long(gb, 16 * 8); // custom epf sharpness\n                    if (get_bits_left(gb) < 0)\n                        return AVERROR_BUFFER_TOO_SMALL;\n                }\n                if (get_bits1(gb)) {\n                    skip_bits_long(gb, 3 * 16 + 32); // custom epf weight\n                    if (get_bits_left(gb) < 0)\n                        return AVERROR_BUFFER_TOO_SMALL;\n                }\n                if (get_bits1(gb)) { // custom epf sigma\n                    if (frame->encoding == JPEGXL_ENC_VARDCT)\n                        skip_bits(gb, 16);\n                    skip_bits_long(gb, 16 * 3);\n                    if (get_bits_left(gb) < 0)\n                        return AVERROR_BUFFER_TOO_SMALL;\n                }\n                if (frame->encoding == JPEGXL_ENC_MODULAR)\n                    skip_bits(gb, 16);\n            }\n            ret = skip_extensions(gb);\n            if (ret < 0)\n                return ret;\n        }\n        ret = skip_extensions(gb);\n        if (ret < 0)\n            return ret;\n    }\n\n    width = div_ceil(div_ceil(width, upsampling), 1 << (3 * lf_level));\n    height = div_ceil(div_ceil(height, upsampling), 1 << (3 * lf_level));\n    group_dim = 128 << group_size_shift;\n    lf_group_dim = group_dim << 3;\n    num_groups = div_ceil(width, group_dim) * div_ceil(height, group_dim);\n    num_lf_groups = div_ceil(width, lf_group_dim) * div_ceil(height, lf_group_dim);\n    if (num_groups == 1 && num_passes == 1)\n        toc_count = 1;\n    else\n        toc_count = 2 + num_lf_groups + num_groups * num_passes;\n\n    // permuted toc\n    if (get_bits1(gb)) {\n        JXLEntropyDecoder dec;\n        uint32_t end, lehmer = 0;\n        ret = entropy_decoder_init(avctx, gb, &dec, 8);\n        if (ret < 0)\n            return ret;\n        if (get_bits_left(gb) < 0) {\n            entropy_decoder_close(&dec);\n            return AVERROR_BUFFER_TOO_SMALL;\n        }\n        end = entropy_decoder_read_symbol(gb, &dec, toc_context(toc_count));\n        if (end > toc_count) {\n            entropy_decoder_close(&dec);\n            return AVERROR_INVALIDDATA;\n        }\n        for (uint32_t i = 0; i < end; i++) {\n            lehmer = entropy_decoder_read_symbol(gb, &dec, toc_context(lehmer));\n            if (get_bits_left(gb) < 0) {\n                entropy_decoder_close(&dec);\n                return AVERROR_BUFFER_TOO_SMALL;\n            }\n        }\n        entropy_decoder_close(&dec);\n    }\n    align_get_bits(gb);\n\n    for (uint32_t i = 0; i < toc_count; i++) {\n        frame->body_length += 8 * jxl_u32(gb, 0, 1024, 17408, 4211712, 10, 14, 22, 30);\n        if (get_bits_left(gb) < 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n    align_get_bits(gb);\n\n    frame->total_length = frame->body_length + get_bits_count(gb) - start_len;\n\n    return 0;\n}\n\nstatic int skip_boxes(JXLParseContext *ctx, const uint8_t *buf, int buf_size)\n{\n    GetByteContext gb;\n\n    if (ctx->skip > buf_size)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    buf += ctx->skip;\n    buf_size -= ctx->skip;\n    bytestream2_init(&gb, buf, buf_size);\n\n    while (1) {\n        uint64_t size;\n        int head_size = 4;\n\n        if (bytestream2_peek_le16(&gb) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE)\n            break;\n        if (bytestream2_peek_le64(&gb) == FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            break;\n\n        if (bytestream2_get_bytes_left(&gb) < 8)\n            return AVERROR_BUFFER_TOO_SMALL;\n\n        size = bytestream2_get_be32(&gb);\n        if (size == 1) {\n            if (bytestream2_get_bytes_left(&gb) < 12)\n                return AVERROR_BUFFER_TOO_SMALL;\n            size = bytestream2_get_be64(&gb);\n            head_size = 12;\n        }\n        if (!size)\n            return AVERROR_INVALIDDATA;\n        /* invalid ISOBMFF size */\n        if (size <= head_size + 4 || size > INT_MAX - ctx->skip)\n            return AVERROR_INVALIDDATA;\n\n        ctx->skip += size;\n        bytestream2_skip(&gb, size - head_size);\n        if (bytestream2_get_bytes_left(&gb) <= 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n\n    return 0;\n}\n\nstatic int try_parse(AVCodecParserContext *s, AVCodecContext *avctx, JXLParseContext *ctx,\n                     const uint8_t *buf, int buf_size)\n{\n    int ret, cs_buflen, header_skip;\n    const uint8_t *cs_buffer;\n    GetBitContext gb;\n\n    if (ctx->skip > buf_size)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    buf += ctx->skip;\n    buf_size -= ctx->skip;\n\n    if (ctx->container || AV_RL64(buf) == FF_JPEGXL_CONTAINER_SIGNATURE_LE) {\n        ctx->container = 1;\n        ret = ff_jpegxl_collect_codestream_header(buf, buf_size, ctx->cs_buffer,\n                                                  sizeof(ctx->cs_buffer), &ctx->copied);\n        if (ret < 0)\n            return ret;\n        ctx->collected_size = ret;\n        if (!ctx->copied) {\n            ctx->skip += ret;\n            return AVERROR_BUFFER_TOO_SMALL;\n        }\n        cs_buffer = ctx->cs_buffer;\n        cs_buflen = FFMIN(sizeof(ctx->cs_buffer), ctx->copied);\n    } else {\n        cs_buffer = buf;\n        cs_buflen = buf_size;\n    }\n\n    if (!ctx->codestream_length) {\n        header_skip = ff_jpegxl_parse_codestream_header(cs_buffer, cs_buflen, &ctx->codestream.meta, 0);\n        if (header_skip < 0)\n            return header_skip;\n        ctx->codestream_length = header_skip;\n        populate_fields(s, avctx, &ctx->codestream.meta);\n    }\n\n    if (ctx->container)\n        return ctx->collected_size;\n\n    ret = init_get_bits8(&gb, cs_buffer, cs_buflen);\n    if (ret < 0)\n        return ret;\n\n    skip_bits_long(&gb, ctx->codestream_length);\n\n    if (!ctx->skipped_icc && ctx->codestream.meta.have_icc_profile) {\n        ret = skip_icc_profile(avctx, ctx, &gb);\n        if (ret < 0)\n            return ret;\n        ctx->skipped_icc = 1;\n        align_get_bits(&gb);\n        ctx->codestream_length = get_bits_count(&gb);\n    }\n\n    if (get_bits_left(&gb) <= 0)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    while (1) {\n        ret = parse_frame_header(avctx, ctx, &gb);\n        if (ret < 0)\n            return ret;\n        ctx->codestream_length += ctx->codestream.frame.total_length;\n        if (ctx->codestream.frame.is_last)\n            return ctx->codestream_length / 8;\n        if (get_bits_left(&gb) <= ctx->codestream.frame.body_length)\n            return AVERROR_BUFFER_TOO_SMALL;\n        skip_bits_long(&gb, ctx->codestream.frame.body_length);\n    }\n}\n\nstatic int jpegxl_parse(AVCodecParserContext *s, AVCodecContext *avctx,\n                        const uint8_t **poutbuf, int *poutbuf_size,\n                        const uint8_t *buf, int buf_size)\n{\n    JXLParseContext *ctx = s->priv_data;\n    int next = END_NOT_FOUND, ret;\n\n    *poutbuf_size = 0;\n    *poutbuf = NULL;\n\n    if (!ctx->pc.index)\n        goto flush;\n\n    if ((!ctx->container || !ctx->codestream_length) && !ctx->next) {\n        ret = try_parse(s, avctx, ctx, ctx->pc.buffer, ctx->pc.index);\n        if (ret < 0)\n            goto flush;\n        ctx->next = ret;\n        if (ctx->container)\n            ctx->skip += ctx->next;\n    }\n\n    if (ctx->container && ctx->next >= 0) {\n        ret = skip_boxes(ctx, ctx->pc.buffer, ctx->pc.index);\n        if (ret < 0) {\n            if (ret == AVERROR_INVALIDDATA)\n                ctx->next = -1;\n            goto flush;\n        }\n        ctx->next = ret + ctx->skip;\n    }\n\n    if (ctx->next >= 0)\n        next = ctx->next - ctx->pc.index;\n\nflush:\n    if (next > buf_size)\n        next = END_NOT_FOUND;\n\n    ret = ff_combine_frame(&ctx->pc, next, &buf, &buf_size);\n    if (ret < 0)\n        return buf_size;\n\n    *poutbuf      = buf;\n    *poutbuf_size = buf_size;\n\n    ctx->codestream_length = 0;\n    ctx->collected_size = 0;\n    ctx->container = 0;\n    ctx->copied = 0;\n    ctx->skip = 0;\n    ctx->skipped_icc = 0;\n    ctx->next = 0;\n    memset(&ctx->codestream, 0, sizeof(ctx->codestream));\n\n    return next;\n}\n\nconst AVCodecParser ff_jpegxl_parser = {\n    .codec_ids      = { AV_CODEC_ID_JPEGXL },\n    .priv_data_size = sizeof(JXLParseContext),\n    .parser_parse   = jpegxl_parse,\n    .parser_close   = ff_parse_close,\n};\n"], "fixing_code": ["/**\n * JPEG XL parser\n * Copyright (c) 2023 Leo Izen <leo.izen@gmail.com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <errno.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/error.h\"\n#include \"libavutil/intmath.h\"\n#include \"libavutil/macros.h\"\n#include \"libavutil/mem.h\"\n#include \"libavutil/pixfmt.h\"\n\n#include \"bytestream.h\"\n#include \"codec_id.h\"\n#define UNCHECKED_BITSTREAM_READER 0\n#define BITSTREAM_READER_LE\n#include \"get_bits.h\"\n#include \"jpegxl.h\"\n#include \"jpegxl_parse.h\"\n#include \"parser.h\"\n#include \"vlc.h\"\n\n#define JXL_FLAG_NOISE 1\n#define JXL_FLAG_PATCHES 2\n#define JXL_FLAG_SPLINES 16\n#define JXL_FLAG_USE_LF_FRAME 32\n#define JXL_FLAG_SKIP_ADAPTIVE_LF_SMOOTH 128\n\n#define MAX_PREFIX_ALPHABET_SIZE (1u << 15)\n\n#define clog1p(x) (ff_log2(x) + !!(x))\n#define unpack_signed(x) (((x) & 1 ? -(x)-1 : (x))/2)\n#define div_ceil(x, y) (((x) - 1) / (y) + 1)\n#define vlm(a,b) {.sym = (a), .len = (b)}\n\ntypedef struct JXLHybridUintConf {\n    int split_exponent;\n    uint32_t msb_in_token;\n    uint32_t lsb_in_token;\n} JXLHybridUintConf;\n\ntypedef struct JXLSymbolDistribution {\n    JXLHybridUintConf config;\n    int log_bucket_size;\n    /* this is the actual size of the alphabet */\n    int alphabet_size;\n    /* ceil(log(alphabet_size)) */\n    int log_alphabet_size;\n\n    /* for prefix code distributions */\n    VLC vlc;\n    /* in case bits == 0 */\n    uint32_t default_symbol;\n\n    /*\n     * each (1 << log_alphabet_size) length\n     * with log_alphabet_size <= 8\n     */\n    /* frequencies associated with this Distribution */\n    uint32_t freq[258];\n    /* cutoffs for using the symbol table */\n    uint16_t cutoffs[258];\n    /* the symbol table for this distribution */\n    uint16_t symbols[258];\n    /* the offset for symbols */\n    uint16_t offsets[258];\n\n    /* if this distribution contains only one symbol this is its index */\n    int uniq_pos;\n} JXLSymbolDistribution;\n\ntypedef struct JXLDistributionBundle {\n    /* lz77 flags */\n    int lz77_enabled;\n    uint32_t lz77_min_symbol;\n    uint32_t lz77_min_length;\n    JXLHybridUintConf lz_len_conf;\n\n    /* one entry for each distribution */\n    uint8_t *cluster_map;\n    /* length of cluster_map */\n    int num_dist;\n\n    /* one for each cluster */\n    JXLSymbolDistribution *dists;\n    int num_clusters;\n\n    /* whether to use brotli prefixes or ans */\n    int use_prefix_code;\n    /* bundle log alphabet size, dist ones may be smaller */\n    int log_alphabet_size;\n} JXLDistributionBundle;\n\ntypedef struct JXLEntropyDecoder {\n\n    /* state is a positive 32-bit integer, or -1 if unset */\n    int64_t state;\n\n    /* lz77 values */\n    uint32_t num_to_copy;\n    uint32_t copy_pos;\n    uint32_t num_decoded;\n\n    /* length is (1 << 20) */\n    /* if lz77 is enabled for this bundle */\n    /* if lz77 is disabled it's NULL */\n    uint32_t *window;\n\n    /* primary bundle associated with this distribution */\n    JXLDistributionBundle bundle;\n\n    /* for av_log */\n    void *logctx;\n} JXLEntropyDecoder;\n\ntypedef struct JXLFrame {\n    FFJXLFrameType type;\n    FFJXLFrameEncoding encoding;\n\n    int is_last;\n    int full_frame;\n\n    uint32_t total_length;\n    uint32_t body_length;\n} JXLFrame;\n\ntypedef struct JXLCodestream {\n    FFJXLMetadata meta;\n    JXLFrame frame;\n} JXLCodestream;\n\ntypedef struct JXLParseContext {\n    ParseContext pc;\n    JXLCodestream codestream;\n\n    /* using ISOBMFF-based container */\n    int container;\n    int skip;\n    int copied;\n    int collected_size;\n    int codestream_length;\n    int skipped_icc;\n    int next;\n\n    uint8_t cs_buffer[4096];\n} JXLParseContext;\n\n/* used for reading brotli prefixes */\nstatic const VLCElem level0_table[16] = {\n    vlm(0, 2), vlm(4, 2), vlm(3, 2), vlm(2, 3), vlm(0, 2), vlm(4, 2), vlm(3, 2), vlm(1, 4),\n    vlm(0, 2), vlm(4, 2), vlm(3, 2), vlm(2, 3), vlm(0, 2), vlm(4, 2), vlm(3, 2), vlm(5, 4),\n};\n\n/* prefix table for populating ANS distribution */\nstatic const VLCElem dist_prefix_table[128] = {\n    vlm(10, 3), vlm(12, 7), vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n    vlm(10, 3), vlm(0, 5),  vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n    vlm(10, 3), vlm(11, 6), vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n    vlm(10, 3), vlm(0, 5),  vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n    vlm(10, 3), vlm(13, 7), vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n    vlm(10, 3), vlm(0, 5),  vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n    vlm(10, 3), vlm(11, 6), vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n    vlm(10, 3), vlm(0, 5),  vlm(7, 3), vlm(3, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(5, 4),\n    vlm(10, 3), vlm(4, 4),  vlm(7, 3), vlm(1, 4), vlm(6, 3), vlm(8, 3), vlm(9, 3), vlm(2, 4),\n};\n\nstatic const uint8_t prefix_codelen_map[18] = {\n    1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n};\n\n/**\n * Read a variable-length 8-bit integer.\n * Used when populating the ANS frequency tables.\n */\nstatic av_always_inline uint8_t jxl_u8(GetBitContext *gb)\n{\n    int n;\n    if (!get_bits1(gb))\n        return 0;\n    n = get_bits(gb, 3);\n\n    return get_bitsz(gb, n) | (1 << n);\n}\n\n/* read a U32(c_i + u(u_i)) */\nstatic av_always_inline uint32_t jxl_u32(GetBitContext *gb,\n                        uint32_t c0, uint32_t c1, uint32_t c2, uint32_t c3,\n                        uint32_t u0, uint32_t u1, uint32_t u2, uint32_t u3)\n{\n    const uint32_t constants[4] = {c0, c1, c2, c3};\n    const uint32_t ubits    [4] = {u0, u1, u2, u3};\n    uint32_t ret, choice = get_bits(gb, 2);\n\n    ret = constants[choice];\n    if (ubits[choice])\n        ret += get_bits_long(gb, ubits[choice]);\n\n    return ret;\n}\n\n/* read a U64() */\nstatic uint64_t jxl_u64(GetBitContext *gb)\n{\n    uint64_t shift = 12, ret;\n\n    switch (get_bits(gb, 2)) {\n    case 1:\n        ret = 1 + get_bits(gb, 4);\n        break;\n    case 2:\n        ret = 17 + get_bits(gb, 8);\n        break;\n    case 3:\n        ret = get_bits(gb, 12);\n        while (get_bits1(gb)) {\n            if (shift < 60) {\n                ret |= (uint64_t)get_bits(gb, 8) << shift;\n                shift += 8;\n            } else {\n                ret |= (uint64_t)get_bits(gb, 4) << shift;\n                break;\n            }\n        }\n        break;\n    default:\n        ret = 0;\n    }\n\n    return ret;\n}\n\nstatic int read_hybrid_uint_conf(GetBitContext *gb, JXLHybridUintConf *conf, int log_alphabet_size)\n{\n    conf->split_exponent = get_bitsz(gb, clog1p(log_alphabet_size));\n    if (conf->split_exponent == log_alphabet_size) {\n        conf->msb_in_token = conf->lsb_in_token = 0;\n        return 0;\n    }\n\n    conf->msb_in_token = get_bitsz(gb, clog1p(conf->split_exponent));\n    if (conf->msb_in_token > conf->split_exponent)\n        return AVERROR_INVALIDDATA;\n    conf->lsb_in_token = get_bitsz(gb, clog1p(conf->split_exponent - conf->msb_in_token));\n    if (conf->msb_in_token + conf->lsb_in_token > conf->split_exponent)\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\nstatic int read_hybrid_uint(GetBitContext *gb, const JXLHybridUintConf *conf, uint32_t token, uint32_t *hybrid_uint)\n{\n    uint32_t n, low, split = 1 << conf->split_exponent;\n\n    if (token < split) {\n        *hybrid_uint = token;\n        return 0;\n    }\n\n    n = conf->split_exponent - conf->lsb_in_token - conf->msb_in_token +\n        ((token - split) >> (conf->msb_in_token + conf->lsb_in_token));\n    if (n >= 32)\n        return AVERROR_INVALIDDATA;\n    low = token & ((1 << conf->lsb_in_token) - 1);\n    token >>= conf->lsb_in_token;\n    token &= (1 << conf->msb_in_token) - 1;\n    token |= 1 << conf->msb_in_token;\n    *hybrid_uint = (((token << n) | get_bits_long(gb, n)) << conf->lsb_in_token ) | low;\n\n    return 0;\n}\n\nstatic inline uint32_t read_prefix_symbol(GetBitContext *gb, const JXLSymbolDistribution *dist)\n{\n    if (!dist->vlc.bits)\n        return dist->default_symbol;\n\n    return get_vlc2(gb, dist->vlc.table, dist->vlc.bits, 1);\n}\n\nstatic uint32_t read_ans_symbol(GetBitContext *gb, JXLEntropyDecoder *dec, const JXLSymbolDistribution *dist)\n{\n    uint32_t index, i, pos, symbol, offset;\n\n    if (dec->state < 0)\n        dec->state = get_bits_long(gb, 32);\n\n    index = dec->state & 0xFFF;\n    i = index >> dist->log_bucket_size;\n    pos = index & ((1 << dist->log_bucket_size) - 1);\n    symbol = pos >= dist->cutoffs[i] ? dist->symbols[i] : i;\n    offset = pos >= dist->cutoffs[i] ? dist->offsets[i] + pos : pos;\n    dec->state = dist->freq[symbol] * (dec->state >> 12) + offset;\n    if (dec->state < (1 << 16))\n        dec->state = (dec->state << 16) | get_bits(gb, 16);\n    dec->state &= 0xFFFFFFFF;\n\n    return symbol;\n}\n\nstatic int decode_hybrid_varlen_uint(GetBitContext *gb, JXLEntropyDecoder *dec,\n                                     const JXLDistributionBundle *bundle,\n                                     uint32_t context, uint32_t *hybrid_uint)\n{\n    int ret;\n    uint32_t token, distance;\n    const JXLSymbolDistribution *dist;\n\n    if (dec->num_to_copy > 0) {\n        *hybrid_uint = dec->window[dec->copy_pos++ & 0xFFFFF];\n        dec->num_to_copy--;\n        dec->window[dec->num_decoded++ & 0xFFFFF] = *hybrid_uint;\n        return 0;\n    }\n\n    if (context >= bundle->num_dist)\n        return AVERROR(EINVAL);\n    if (bundle->cluster_map[context] >= bundle->num_clusters)\n        return AVERROR_INVALIDDATA;\n\n    dist = &bundle->dists[bundle->cluster_map[context]];\n    if (bundle->use_prefix_code)\n        token = read_prefix_symbol(gb, dist);\n    else\n        token = read_ans_symbol(gb, dec, dist);\n\n    if (bundle->lz77_enabled && token >= bundle->lz77_min_symbol) {\n        const JXLSymbolDistribution *lz77dist = &bundle->dists[bundle->cluster_map[bundle->num_dist - 1]];\n        ret = read_hybrid_uint(gb, &bundle->lz_len_conf, token - bundle->lz77_min_symbol, &dec->num_to_copy);\n        if (ret < 0)\n            return ret;\n        dec->num_to_copy += bundle->lz77_min_length;\n        if (bundle->use_prefix_code)\n            token = read_prefix_symbol(gb, lz77dist);\n        else\n            token = read_ans_symbol(gb, dec, lz77dist);\n        ret = read_hybrid_uint(gb, &lz77dist->config, token, &distance);\n        if (ret < 0)\n            return ret;\n        distance++;\n        distance = FFMIN3(distance, dec->num_decoded, 1 << 20);\n        dec->copy_pos = dec->num_decoded - distance;\n        return decode_hybrid_varlen_uint(gb, dec, bundle, context, hybrid_uint);\n    }\n    ret = read_hybrid_uint(gb, &dist->config, token, hybrid_uint);\n    if (ret < 0)\n        return ret;\n    if (bundle->lz77_enabled)\n        dec->window[dec->num_decoded++ & 0xFFFFF] = *hybrid_uint;\n\n    return 0;\n}\n\nstatic int populate_distribution(GetBitContext *gb, JXLSymbolDistribution *dist, int log_alphabet_size)\n{\n    int len = 0, shift, omit_log = -1, omit_pos = -1;\n    int prev = 0, num_same = 0;\n    uint32_t total_count = 0;\n    uint8_t logcounts[258] = { 0 };\n    uint8_t same[258] = { 0 };\n    dist->uniq_pos = -1;\n\n    if (get_bits1(gb)) {\n        /* simple code */\n        dist->alphabet_size = 256;\n        if (get_bits1(gb)) {\n            uint8_t v1 = jxl_u8(gb);\n            uint8_t v2 = jxl_u8(gb);\n            if (v1 == v2)\n                return AVERROR_INVALIDDATA;\n            dist->freq[v1] = get_bits(gb, 12);\n            dist->freq[v2] = (1 << 12) - dist->freq[v1];\n            if (!dist->freq[v1])\n                dist->uniq_pos = v2;\n        } else {\n            uint8_t x = jxl_u8(gb);\n            dist->freq[x] = 1 << 12;\n            dist->uniq_pos = x;\n        }\n        return 0;\n    }\n\n    if (get_bits1(gb)) {\n        /* flat code */\n        dist->alphabet_size = jxl_u8(gb) + 1;\n        for (int i = 0; i < dist->alphabet_size; i++)\n            dist->freq[i] = (1 << 12) / dist->alphabet_size;\n        for (int i = 0; i < (1 << 12) % dist->alphabet_size; i++)\n            dist->freq[i]++;\n        return 0;\n    }\n\n    do {\n        if (!get_bits1(gb))\n            break;\n    } while (++len < 3);\n\n    shift = (get_bitsz(gb, len) | (1 << len)) - 1;\n    if (shift > 13)\n        return AVERROR_INVALIDDATA;\n\n    dist->alphabet_size = jxl_u8(gb) + 3;\n    for (int i = 0; i < dist->alphabet_size; i++) {\n        logcounts[i] = get_vlc2(gb, dist_prefix_table, 7, 1);\n        if (logcounts[i] == 13) {\n            int rle = jxl_u8(gb);\n            same[i] = rle + 5;\n            i += rle + 3;\n            continue;\n        }\n        if (logcounts[i] > omit_log) {\n            omit_log = logcounts[i];\n            omit_pos = i;\n        }\n    }\n    if (omit_pos < 0 || omit_pos + 1 < dist->alphabet_size && logcounts[omit_pos + 1] == 13)\n        return AVERROR_INVALIDDATA;\n\n    for (int i = 0; i < dist->alphabet_size; i++) {\n        if (same[i]) {\n            num_same = same[i] - 1;\n            prev = i > 0 ? dist->freq[i - 1] : 0;\n        }\n        if (num_same) {\n            dist->freq[i] = prev;\n            num_same--;\n        } else {\n            if (i == omit_pos || !logcounts[i])\n                continue;\n            if (logcounts[i] == 1) {\n                dist->freq[i] = 1;\n            } else {\n                int bitcount = FFMIN(FFMAX(0, shift - ((12 - logcounts[i] + 1) >> 1)), logcounts[i] - 1);\n                dist->freq[i] = (1 << (logcounts[i] - 1)) + (get_bitsz(gb, bitcount) << (logcounts[i] - 1 - bitcount));\n            }\n        }\n        total_count += dist->freq[i];\n    }\n    dist->freq[omit_pos] = (1 << 12) - total_count;\n\n    return 0;\n}\n\nstatic void dist_bundle_close(JXLDistributionBundle *bundle)\n{\n    if (bundle->use_prefix_code && bundle->dists)\n        for (int i = 0; i < bundle->num_clusters; i++)\n            ff_vlc_free(&bundle->dists[i].vlc);\n    av_freep(&bundle->dists);\n    av_freep(&bundle->cluster_map);\n}\n\n\nstatic int read_distribution_bundle(GetBitContext *gb, JXLEntropyDecoder *dec,\n                                    JXLDistributionBundle *bundle, int num_dist, int disallow_lz77);\n\nstatic int read_dist_clustering(GetBitContext *gb, JXLEntropyDecoder *dec, JXLDistributionBundle *bundle)\n{\n    int ret;\n\n    bundle->cluster_map = av_malloc(bundle->num_dist);\n    if (!bundle->cluster_map)\n        return AVERROR(ENOMEM);\n\n    if (bundle->num_dist == 1) {\n        bundle->cluster_map[0] = 0;\n        bundle->num_clusters = 1;\n        return 0;\n    }\n\n    if (get_bits1(gb)) {\n        /* simple clustering */\n        uint32_t nbits = get_bits(gb, 2);\n        for (int i = 0; i < bundle->num_dist; i++)\n            bundle->cluster_map[i] = get_bitsz(gb, nbits);\n    } else {\n        /* complex clustering */\n        int use_mtf = get_bits1(gb);\n        JXLDistributionBundle nested = { 0 };\n        /* num_dist == 1 prevents this from recursing again */\n        ret = read_distribution_bundle(gb, dec, &nested, 1, bundle->num_dist <= 2);\n        if (ret < 0) {\n            dist_bundle_close(&nested);\n            return ret;\n        }\n        for (int i = 0; i < bundle->num_dist; i++) {\n            uint32_t clust;\n            ret = decode_hybrid_varlen_uint(gb, dec, &nested, 0, &clust);\n            if (ret < 0) {\n                dist_bundle_close(&nested);\n                return ret;\n            }\n            bundle->cluster_map[i] = clust;\n        }\n        dec->state = -1;\n        /* it's not going to necessarily be zero after reading */\n        dec->num_to_copy = 0;\n        dist_bundle_close(&nested);\n        if (use_mtf) {\n            uint8_t mtf[256];\n            for (int i = 0; i < 256; i++)\n                mtf[i] = i;\n            for (int i = 0; i < bundle->num_dist; i++) {\n                int index = bundle->cluster_map[i];\n                bundle->cluster_map[i] = mtf[index];\n                if (index) {\n                    int value = mtf[index];\n                    for (int j = index; j > 0; j--)\n                        mtf[j] = mtf[j - 1];\n                    mtf[0] = value;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < bundle->num_dist; i++) {\n        if (bundle->cluster_map[i] >= bundle->num_clusters)\n            bundle->num_clusters = bundle->cluster_map[i] + 1;\n    }\n\n    if (bundle->num_clusters > bundle->num_dist)\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\nstatic int gen_alias_map(JXLEntropyDecoder *dec, JXLSymbolDistribution *dist, int log_alphabet_size)\n{\n    uint32_t bucket_size, table_size;\n    uint8_t overfull[256], underfull[256];\n    int overfull_pos = 0, underfull_pos = 0;\n    dist->log_bucket_size = 12 - log_alphabet_size;\n    bucket_size = 1 << dist->log_bucket_size;\n    table_size = 1 << log_alphabet_size;\n\n    if (dist->uniq_pos >= 0) {\n        for (int i = 0; i < table_size; i++) {\n            dist->symbols[i] = dist->uniq_pos;\n            dist->offsets[i] = bucket_size * i;\n            dist->cutoffs[i] = 0;\n        }\n        return 0;\n    }\n\n    for (int i = 0; i < dist->alphabet_size; i++) {\n        dist->cutoffs[i] = dist->freq[i];\n        dist->symbols[i] = i;\n        if (dist->cutoffs[i] > bucket_size)\n            overfull[overfull_pos++] = i;\n        else if (dist->cutoffs[i] < bucket_size)\n            underfull[underfull_pos++] = i;\n    }\n\n    for (int i = dist->alphabet_size; i < table_size; i++) {\n        dist->cutoffs[i] = 0;\n        underfull[underfull_pos++] = i;\n    }\n\n    while (overfull_pos) {\n        int o, u, by;\n        /* this should be impossible */\n        if (!underfull_pos)\n            return AVERROR_INVALIDDATA;\n        u = underfull[--underfull_pos];\n        o = overfull[--overfull_pos];\n        by = bucket_size - dist->cutoffs[u];\n        dist->cutoffs[o] -= by;\n        dist->symbols[u] = o;\n        dist->offsets[u] = dist->cutoffs[o];\n        if (dist->cutoffs[o] < bucket_size)\n            underfull[underfull_pos++] = o;\n        else if (dist->cutoffs[o] > bucket_size)\n            overfull[overfull_pos++] = o;\n    }\n\n    for (int i = 0; i < table_size; i++) {\n        if (dist->cutoffs[i] == bucket_size) {\n            dist->symbols[i] = i;\n            dist->offsets[i] = 0;\n            dist->cutoffs[i] = 0;\n        } else {\n            dist->offsets[i] -= dist->cutoffs[i];\n        }\n    }\n\n    return 0;\n}\n\nstatic int read_simple_vlc_prefix(GetBitContext *gb, JXLEntropyDecoder *dec, JXLSymbolDistribution *dist)\n{\n    int nsym, tree_select, bits;\n\n    int8_t lens[4];\n    int16_t symbols[4];\n\n    nsym = 1 + get_bits(gb, 2);\n    for (int i = 0; i < nsym; i++)\n        symbols[i] = get_bitsz(gb, dist->log_alphabet_size);\n    if (nsym == 4)\n        tree_select = get_bits1(gb);\n    switch (nsym) {\n    case 1:\n        dist->vlc.bits = 0;\n        dist->default_symbol = symbols[0];\n        return 0;\n    case 2:\n        bits = 1;\n        lens[0] = 1, lens[1] = 1, lens[2] = 0, lens[3] = 0;\n        if (symbols[1] < symbols[0])\n            FFSWAP(int16_t, symbols[0], symbols[1]);\n        break;\n    case 3:\n        bits = 2;\n        lens[0] = 1, lens[1] = 2, lens[2] = 2, lens[3] = 0;\n        if (symbols[2] < symbols[1])\n            FFSWAP(int16_t, symbols[1], symbols[2]);\n        break;\n    case 4:\n        if (tree_select) {\n            bits = 3;\n            lens[0] = 1, lens[1] = 2, lens[2] = 3, lens[3] = 3;\n            if (symbols[3] < symbols[2])\n                FFSWAP(int16_t, symbols[2], symbols[3]);\n        } else {\n            bits = 2;\n            lens[0] = 2, lens[1] = 2, lens[2] = 2, lens[3] = 2;\n            while (1) {\n                if (symbols[1] < symbols[0])\n                    FFSWAP(int16_t, symbols[0], symbols[1]);\n                if (symbols[3] < symbols[2])\n                    FFSWAP(int16_t, symbols[2], symbols[3]);\n                if (symbols[1] <= symbols[2])\n                    break;\n                FFSWAP(int16_t, symbols[1], symbols[2]);\n            }\n        }\n        break;\n    default:\n        // Challenge Complete! How did we get here?\n        return AVERROR_BUG;\n    }\n\n    return ff_vlc_init_from_lengths(&dist->vlc, bits, nsym, lens, 1, symbols,\n                                    2, 2, 0, VLC_INIT_LE, dec->logctx);\n}\n\nstatic int read_vlc_prefix(GetBitContext *gb, JXLEntropyDecoder *dec, JXLSymbolDistribution *dist)\n{\n    int8_t level1_lens[18] = { 0 };\n    int8_t level1_lens_s[18] = { 0 };\n    int16_t level1_syms[18] = { 0 };\n    uint32_t level1_codecounts[19] = { 0 };\n    uint8_t *buf = NULL;\n    int8_t *level2_lens, *level2_lens_s;\n    int16_t *level2_syms;\n    uint32_t *level2_codecounts;\n\n    int repeat_count_prev = 0, repeat_count_zero = 0, prev = 8;\n    int total_code = 0, len, hskip, num_codes = 0, ret;\n\n    VLC level1_vlc = { 0 };\n\n    if (dist->alphabet_size == 1) {\n        dist->vlc.bits = 0;\n        dist->default_symbol = 0;\n        return 0;\n    }\n\n    hskip = get_bits(gb, 2);\n    if (hskip == 1)\n        return read_simple_vlc_prefix(gb, dec, dist);\n\n    level1_codecounts[0] = hskip;\n    for (int i = hskip; i < 18; i++) {\n        len = level1_lens[prefix_codelen_map[i]] = get_vlc2(gb, level0_table, 4, 1);\n        level1_codecounts[len]++;\n        if (len) {\n            total_code += (32 >> len);\n            num_codes++;\n        }\n        if (total_code >= 32) {\n            level1_codecounts[0] += 18 - i - 1;\n            break;\n        }\n    }\n\n    if (total_code != 32 && num_codes >= 2 || num_codes < 1) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    for (int i = 1; i < 19; i++)\n         level1_codecounts[i] += level1_codecounts[i - 1];\n\n    for (int i = 17; i >= 0; i--) {\n        int idx = --level1_codecounts[level1_lens[i]];\n        level1_lens_s[idx] = level1_lens[i];\n        level1_syms[idx] = i;\n    }\n\n    ret = ff_vlc_init_from_lengths(&level1_vlc, 5, 18, level1_lens_s, 1, level1_syms, 2, 2,\n        0, VLC_INIT_LE, dec->logctx);\n    if (ret < 0)\n        goto end;\n\n    buf = av_mallocz(MAX_PREFIX_ALPHABET_SIZE * (2 * sizeof(int8_t) + sizeof(int16_t) + sizeof(uint32_t))\n                     + sizeof(uint32_t));\n    if (!buf) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    level2_lens = (int8_t *)buf;\n    level2_lens_s = (int8_t *)(buf + MAX_PREFIX_ALPHABET_SIZE * sizeof(int8_t));\n    level2_syms = (int16_t *)(buf + MAX_PREFIX_ALPHABET_SIZE * (2 * sizeof(int8_t)));\n    level2_codecounts = (uint32_t *)(buf + MAX_PREFIX_ALPHABET_SIZE * (2 * sizeof(int8_t) + sizeof(int16_t)));\n\n    total_code = 0;\n    for (int i = 0; i < dist->alphabet_size; i++) {\n        len = get_vlc2(gb, level1_vlc.table, 5, 1);\n        if (get_bits_left(gb) < 0) {\n            ret = AVERROR_BUFFER_TOO_SMALL;\n            goto end;\n        }\n        if (len == 16) {\n            int extra = 3 + get_bits(gb, 2);\n            if (repeat_count_prev)\n                extra += 4 * (repeat_count_prev - 2) - repeat_count_prev;\n            extra = FFMIN(extra, dist->alphabet_size - i);\n            for (int j = 0; j < extra; j++)\n                level2_lens[i + j] = prev;\n            total_code += (32768 >> prev) * extra;\n            i += extra - 1;\n            repeat_count_prev += extra;\n            repeat_count_zero = 0;\n            level2_codecounts[prev] += extra;\n        } else if (len == 17) {\n            int extra = 3 + get_bits(gb, 3);\n            if (repeat_count_zero > 0)\n                extra += 8 * (repeat_count_zero - 2) - repeat_count_zero;\n            extra = FFMIN(extra, dist->alphabet_size - i);\n            i += extra - 1;\n            repeat_count_prev = 0;\n            repeat_count_zero += extra;\n            level2_codecounts[0] += extra;\n        } else {\n            level2_lens[i] = len;\n            repeat_count_prev = repeat_count_zero = 0;\n            if (len) {\n                total_code += (32768 >> len);\n                prev = len;\n            }\n            level2_codecounts[len]++;\n        }\n        if (total_code >= 32768) {\n            level2_codecounts[0] += dist->alphabet_size - i - 1;\n            break;\n        }\n    }\n\n    if (total_code != 32768 && level2_codecounts[0] < dist->alphabet_size - 1) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    for (int i = 1; i < dist->alphabet_size + 1; i++)\n        level2_codecounts[i] += level2_codecounts[i - 1];\n\n    for (int i = dist->alphabet_size - 1; i >= 0; i--) {\n        int idx = --level2_codecounts[level2_lens[i]];\n        level2_lens_s[idx] = level2_lens[i];\n        level2_syms[idx] = i;\n    }\n\n    ret = ff_vlc_init_from_lengths(&dist->vlc, 15, dist->alphabet_size, level2_lens_s,\n                                    1, level2_syms, 2, 2, 0, VLC_INIT_LE, dec->logctx);\n\nend:\n    av_freep(&buf);\n    ff_vlc_free(&level1_vlc);\n\n    return ret;\n}\n\nstatic int read_distribution_bundle(GetBitContext *gb, JXLEntropyDecoder *dec,\n                                    JXLDistributionBundle *bundle, int num_dist, int disallow_lz77)\n{\n    int ret;\n\n    if (num_dist <= 0)\n        return AVERROR(EINVAL);\n\n    bundle->num_dist = num_dist;\n    bundle->lz77_enabled = get_bits1(gb);\n    if (bundle->lz77_enabled) {\n        if (disallow_lz77)\n            return AVERROR_INVALIDDATA;\n        bundle->lz77_min_symbol = jxl_u32(gb, 224, 512, 4096, 8, 0, 0, 0, 15);\n        bundle->lz77_min_length = jxl_u32(gb, 3, 4, 5, 9, 0, 0, 2, 8);\n        bundle->num_dist++;\n        ret = read_hybrid_uint_conf(gb, &bundle->lz_len_conf, 8);\n        if (ret < 0)\n            return ret;\n    }\n\n    if (bundle->lz77_enabled && !dec->window) {\n        dec->window = av_malloc_array(1 << 20, sizeof(uint32_t));\n        if (!dec->window)\n            return AVERROR(ENOMEM);\n    }\n\n    ret = read_dist_clustering(gb, dec, bundle);\n    if (ret < 0)\n        return ret;\n    if (get_bits_left(gb) < 0)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    bundle->dists = av_calloc(bundle->num_clusters, sizeof(JXLSymbolDistribution));\n    if (!bundle->dists)\n        return AVERROR(ENOMEM);\n\n    bundle->use_prefix_code = get_bits1(gb);\n    bundle->log_alphabet_size = bundle->use_prefix_code ? 15 : 5 + get_bits(gb, 2);\n\n    for (int i = 0; i < bundle->num_clusters; i++) {\n        ret = read_hybrid_uint_conf(gb, &bundle->dists[i].config, bundle->log_alphabet_size);\n        if (ret < 0)\n            return ret;\n        if (get_bits_left(gb) < 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n\n    if (bundle->use_prefix_code) {\n        for (int i = 0; i < bundle->num_clusters; i++) {\n            JXLSymbolDistribution *dist = &bundle->dists[i];\n            if (get_bits1(gb)) {\n                int n = get_bits(gb, 4);\n                dist->alphabet_size = 1 + (1 << n) + get_bitsz(gb, n);\n                if (dist->alphabet_size > MAX_PREFIX_ALPHABET_SIZE)\n                    return AVERROR_INVALIDDATA;\n            } else {\n                dist->alphabet_size = 1;\n            }\n            dist->log_alphabet_size = clog1p(dist->alphabet_size - 1);\n        }\n        for (int i = 0; i < bundle->num_clusters; i++) {\n            ret = read_vlc_prefix(gb, dec, &bundle->dists[i]);\n            if (ret < 0)\n                return ret;\n            if (get_bits_left(gb) < 0)\n                return AVERROR_BUFFER_TOO_SMALL;\n        }\n    } else {\n        for (int i = 0; i < bundle->num_clusters; i++) {\n            ret = populate_distribution(gb, &bundle->dists[i], bundle->log_alphabet_size);\n            if (ret < 0)\n                return ret;\n            if (get_bits_left(gb) < 0)\n                return AVERROR_BUFFER_TOO_SMALL;\n        }\n        for (int i = 0; i < bundle->num_clusters; i++) {\n            ret = gen_alias_map(dec, &bundle->dists[i], bundle->log_alphabet_size);\n            if (ret < 0)\n                return ret;\n        }\n    }\n\n    return 0;\n}\n\nstatic void entropy_decoder_close(JXLEntropyDecoder *dec)\n{\n    if (!dec)\n        return;\n    av_freep(&dec->window);\n    dist_bundle_close(&dec->bundle);\n}\n\nstatic int entropy_decoder_init(void *avctx, GetBitContext *gb, JXLEntropyDecoder *dec, int num_dist)\n{\n    int ret;\n\n    memset(dec, 0, sizeof(*dec));\n    dec->logctx = avctx;\n    dec->state = -1;\n\n    ret = read_distribution_bundle(gb, dec, &dec->bundle, num_dist, 0);\n    if (ret < 0) {\n        entropy_decoder_close(dec);\n        return ret;\n    }\n\n    return 0;\n}\n\nstatic int64_t entropy_decoder_read_symbol(GetBitContext *gb, JXLEntropyDecoder *dec, uint32_t context)\n{\n    int ret;\n    uint32_t hybrid_uint;\n\n    ret = decode_hybrid_varlen_uint(gb, dec, &dec->bundle, context, &hybrid_uint);\n    if (ret < 0)\n        return ret;\n\n    return hybrid_uint;\n}\n\nstatic inline uint32_t icc_context(uint64_t i, uint32_t b1, uint32_t b2)\n{\n    uint32_t p1, p2;\n    if (i <= 128)\n        return 0;\n    if (b1 >= 'a' && b1 <= 'z' || b1 >= 'A' && b1 <= 'Z')\n        p1 = 0;\n    else if (b1 >= '0' && b1 <= '9' || b1 == '.' || b1 == ',')\n        p1 = 1;\n    else if (b1 <= 1)\n        p1 = b1 + 2;\n    else if (b1 > 1 && b1 < 16)\n        p1 = 4;\n    else if (b1 > 240 && b1 < 255)\n        p1 = 5;\n    else if (b1 == 255)\n        p1 = 6;\n    else\n        p1 = 7;\n\n    if (b2 >= 'a' && b2 <= 'z' || b2 >= 'A' && b2 <= 'Z')\n        p2 = 0;\n    else if (b2 >= '0' && b2 <= '9' || b2 == '.' || b2 == ',')\n        p2 = 1;\n    else if (b2 < 16)\n        p2 = 2;\n    else if (b2 > 240)\n        p2 = 3;\n    else\n        p2 = 4;\n\n    return 1 + p1 + p2 * 8;\n}\n\nstatic inline uint32_t toc_context(uint32_t x)\n{\n    return FFMIN(7, clog1p(x));\n}\n\nstatic void populate_fields(AVCodecParserContext *s, AVCodecContext *avctx, const FFJXLMetadata *meta)\n{\n    s->width = meta->width;\n    s->height = meta->height;\n\n    switch (meta->csp) {\n    case JPEGXL_CS_RGB:\n    case JPEGXL_CS_XYB:\n        avctx->colorspace = AVCOL_SPC_RGB;\n        break;\n    default:\n        avctx->colorspace = AVCOL_SPC_UNSPECIFIED;\n    }\n\n    if (meta->wp == JPEGXL_WP_D65) {\n        switch (meta->primaries) {\n        case JPEGXL_PR_SRGB:\n            avctx->color_primaries = AVCOL_PRI_BT709;\n            break;\n        case JPEGXL_PR_P3:\n            avctx->color_primaries = AVCOL_PRI_SMPTE432;\n            break;\n        case JPEGXL_PR_2100:\n            avctx->color_primaries = AVCOL_PRI_BT2020;\n            break;\n        default:\n            avctx->color_primaries = AVCOL_PRI_UNSPECIFIED;\n        }\n    } else if (meta->wp == JPEGXL_WP_DCI && meta->primaries == JPEGXL_PR_P3) {\n        avctx->color_primaries = AVCOL_PRI_SMPTE431;\n    } else {\n        avctx->color_primaries = AVCOL_PRI_UNSPECIFIED;\n    }\n\n    if (meta->trc > JPEGXL_TR_GAMMA) {\n        FFJXLTransferCharacteristic trc = meta->trc - JPEGXL_TR_GAMMA;\n        switch (trc) {\n        case JPEGXL_TR_BT709:\n            avctx->color_trc = AVCOL_TRC_BT709;\n            break;\n        case JPEGXL_TR_LINEAR:\n            avctx->color_trc = AVCOL_TRC_LINEAR;\n            break;\n        case JPEGXL_TR_SRGB:\n            avctx->color_trc = AVCOL_TRC_IEC61966_2_1;\n            break;\n        case JPEGXL_TR_PQ:\n            avctx->color_trc = AVCOL_TRC_SMPTEST2084;\n            break;\n        case JPEGXL_TR_DCI:\n            avctx->color_trc = AVCOL_TRC_SMPTE428;\n            break;\n        case JPEGXL_TR_HLG:\n            avctx->color_trc = AVCOL_TRC_ARIB_STD_B67;\n            break;\n        default:\n            avctx->color_trc = AVCOL_TRC_UNSPECIFIED;\n        }\n    } else if (meta->trc > 0) {\n        if (meta->trc > 45355 && meta->trc < 45555)\n            avctx->color_trc = AVCOL_TRC_GAMMA22;\n        else if (meta->trc > 35614 && meta->trc < 35814)\n            avctx->color_trc = AVCOL_TRC_GAMMA28;\n        else\n            avctx->color_trc = AVCOL_TRC_UNSPECIFIED;\n    } else {\n        avctx->color_trc = AVCOL_TRC_UNSPECIFIED;\n    }\n\n    if (meta->csp == JPEGXL_CS_GRAY) {\n        if (meta->bit_depth <= 8)\n            s->format = meta->have_alpha ? AV_PIX_FMT_YA8 : AV_PIX_FMT_GRAY8;\n        else if (meta->bit_depth <= 16)\n            s->format = meta->have_alpha ? AV_PIX_FMT_YA16 : AV_PIX_FMT_GRAY16;\n        else\n            s->format = meta->have_alpha ? AV_PIX_FMT_NONE : AV_PIX_FMT_GRAYF32;\n    } else {\n        if (meta->bit_depth <= 8)\n            s->format = meta->have_alpha ? AV_PIX_FMT_RGBA : AV_PIX_FMT_RGB24;\n        else if (meta->bit_depth <= 16)\n            s->format = meta->have_alpha ? AV_PIX_FMT_RGBA64 : AV_PIX_FMT_RGB48;\n        else\n            s->format = meta->have_alpha ? AV_PIX_FMT_RGBAF32 : AV_PIX_FMT_RGBF32;\n    }\n}\n\nstatic int skip_icc_profile(void *avctx, JXLParseContext *ctx, GetBitContext *gb)\n{\n    int64_t ret;\n    uint32_t last = 0, last2 = 0;\n    JXLEntropyDecoder dec = { 0 };\n    uint64_t enc_size = jxl_u64(gb);\n    uint64_t output_size = 0;\n    int out_size_shift = 0;\n\n    if (!enc_size || enc_size > (1 << 22))\n        return AVERROR_INVALIDDATA;\n\n    ret = entropy_decoder_init(avctx, gb, &dec, 41);\n    if (ret < 0)\n        goto end;\n\n    if (get_bits_left(gb) < 0) {\n        ret = AVERROR_BUFFER_TOO_SMALL;\n        goto end;\n    }\n\n    for (uint64_t read = 0; read < enc_size; read++) {\n        ret = entropy_decoder_read_symbol(gb, &dec, icc_context(read, last, last2));\n        if (ret < 0)\n            goto end;\n        if (ret > 255) {\n            ret = AVERROR_INVALIDDATA;\n            goto end;\n        }\n        if (get_bits_left(gb) < 0) {\n            ret = AVERROR_BUFFER_TOO_SMALL;\n            goto end;\n        }\n        last2 = last;\n        last = ret;\n        if (out_size_shift < 63) {\n            output_size += (ret & UINT64_C(0x7F)) << out_size_shift;\n            if (!(ret & 0x80)) {\n                out_size_shift = 63;\n            } else {\n                out_size_shift += 7;\n                if (out_size_shift > 56) {\n                    ret = AVERROR_INVALIDDATA;\n                    goto end;\n                }\n            }\n        } else if (output_size < 132) {\n            ret = AVERROR_INVALIDDATA;\n            goto end;\n        }\n    }\n\n    ret = 0;\n\nend:\n    entropy_decoder_close(&dec);\n\n    return ret;\n}\n\nstatic int skip_extensions(GetBitContext *gb)\n{\n    uint64_t extensions = jxl_u64(gb), extensions_len = 0;\n\n    if (get_bits_left(gb) < 0)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    if (!extensions)\n        return 0;\n\n    for (int i = 0; i < 64; i++) {\n        if (extensions & (UINT64_C(1) << i))\n            extensions_len += jxl_u64(gb);\n        if (get_bits_left(gb) < 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n\n    if (extensions_len > INT_MAX || get_bits_left(gb) < extensions_len)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    skip_bits_long(gb, extensions_len);\n\n    return 0;\n}\n\nstatic int parse_frame_header(void *avctx, JXLParseContext *ctx, GetBitContext *gb)\n{\n    int all_default, do_yCbCr = 0, num_passes = 1, ret;\n    int group_size_shift = 1, lf_level = 0, save_as_ref = 0;\n    int have_crop = 0, full_frame = 1, resets_canvas = 1, upsampling = 1;\n    JXLFrame *frame = &ctx->codestream.frame;\n    const FFJXLMetadata *meta = &ctx->codestream.meta;\n    int32_t x0 = 0, y0 = 0;\n    uint32_t duration = 0, width = meta->coded_width, height = meta->coded_height;\n    uint32_t name_len, num_groups, num_lf_groups, group_dim, lf_group_dim, toc_count;\n    uint64_t flags = 0;\n    int start_len = get_bits_count(gb);\n\n    memset(frame, 0, sizeof(*frame));\n    frame->is_last = 1;\n\n    all_default = get_bits1(gb);\n    if (!all_default) {\n        frame->type = get_bits(gb, 2);\n        frame->encoding = get_bits1(gb);\n        flags = jxl_u64(gb);\n        if (!meta->xyb_encoded)\n            do_yCbCr = get_bits1(gb);\n        if (!(flags & JXL_FLAG_USE_LF_FRAME)) {\n            if (do_yCbCr)\n                skip_bits(gb, 6); // jpeg upsampling\n            upsampling = jxl_u32(gb, 1, 2, 4, 8, 0, 0, 0, 0);\n            skip_bits_long(gb, 2 * meta->num_extra_channels);\n            if (get_bits_left(gb) < 0)\n                return AVERROR_BUFFER_TOO_SMALL;\n        }\n        if (frame->encoding == JPEGXL_ENC_MODULAR)\n            group_size_shift = get_bits(gb, 2);\n        else if (meta->xyb_encoded)\n            skip_bits(gb, 6); // xqm and bqm scales\n        if (frame->type != JPEGXL_FRAME_REFERENCE_ONLY) {\n            num_passes = jxl_u32(gb, 1, 2, 3, 4, 0, 0, 0, 3);\n            if (num_passes != 1) {\n                int num_ds = jxl_u32(gb, 0, 1, 2, 3, 0, 0, 0, 1);\n                skip_bits(gb, 2 * (num_passes - 1)); // shift\n                skip_bits(gb, 2 * num_ds); // downsample\n                for (int i = 0; i < num_ds; i++)\n                    jxl_u32(gb, 0, 1, 2, 0, 0, 0, 0, 3);\n            }\n        }\n        if (frame->type == JPEGXL_FRAME_LF)\n            lf_level = 1 + get_bits(gb, 2);\n        else\n            have_crop = get_bits1(gb);\n        if (have_crop) {\n            if (frame->type != JPEGXL_FRAME_REFERENCE_ONLY) {\n                uint32_t ux0 = jxl_u32(gb, 0, 256, 2304, 18688, 8, 11, 14, 30);\n                uint32_t uy0 = jxl_u32(gb, 0, 256, 2304, 18688, 8, 11, 14, 30);\n                x0 = unpack_signed(ux0);\n                y0 = unpack_signed(uy0);\n            }\n            width = jxl_u32(gb, 0, 256, 2304, 18688, 8, 11, 14, 30);\n            height = jxl_u32(gb, 0, 256, 2304, 18688, 8, 11, 14, 30);\n            full_frame = x0 <= 0 && y0 <= 0 && width + x0 >= meta->coded_width\n                                            && height + y0 >= meta->coded_height;\n        }\n        if (get_bits_left(gb) < 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n        if (frame->type == JPEGXL_FRAME_REGULAR || frame->type == JPEGXL_FRAME_SKIP_PROGRESSIVE) {\n            for (int i = 0; i <= meta->num_extra_channels; i++) {\n                int mode = jxl_u32(gb, 0, 1, 2, 3, 0, 0, 0, 2);\n                if (meta->num_extra_channels && (mode == JPEGXL_BM_BLEND || mode == JPEGXL_BM_MULADD))\n                    jxl_u32(gb, 0, 1, 2, 3, 0, 0, 0, 2);\n                if (meta->num_extra_channels && (mode == JPEGXL_BM_BLEND || mode == JPEGXL_BM_MULADD\n                                              || mode == JPEGXL_BM_MUL))\n                    skip_bits1(gb);\n                if (!i)\n                    resets_canvas = mode == JPEGXL_BM_REPLACE && full_frame;\n                if (!resets_canvas)\n                    skip_bits(gb, 2);\n                if (get_bits_left(gb) < 0)\n                    return AVERROR_BUFFER_TOO_SMALL;\n            }\n            if (meta->animation_offset)\n                duration = jxl_u32(gb, 0, 1, 0, 0, 0, 0, 8, 32);\n            if (meta->have_timecodes)\n                skip_bits_long(gb, 32);\n            frame->is_last = get_bits1(gb);\n        } else {\n            frame->is_last = 0;\n        }\n        if (frame->type != JPEGXL_FRAME_LF && !frame->is_last)\n            save_as_ref = get_bits(gb, 2);\n        if (frame->type == JPEGXL_FRAME_REFERENCE_ONLY ||\n                (resets_canvas && !frame->is_last && (!duration || save_as_ref)\n                && frame->type != JPEGXL_FRAME_LF))\n            skip_bits1(gb); // save before color transform\n        name_len = 8 * jxl_u32(gb, 0, 0, 16, 48, 0, 4, 5, 10);\n        if (get_bits_left(gb) < name_len)\n            return AVERROR_BUFFER_TOO_SMALL;\n        skip_bits_long(gb, name_len);\n    }\n\n    if (!all_default) {\n        int restd = get_bits1(gb), gab = 1;\n        if (!restd)\n            gab = get_bits1(gb);\n        if (gab && !restd && get_bits1(gb))\n            // gab custom\n            skip_bits_long(gb, 16 * 6);\n        if (get_bits_left(gb) < 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n        if (!restd) {\n            int epf = get_bits(gb, 2);\n            if (epf) {\n                if (frame->encoding == JPEGXL_ENC_VARDCT && get_bits1(gb)) {\n                    skip_bits_long(gb, 16 * 8); // custom epf sharpness\n                    if (get_bits_left(gb) < 0)\n                        return AVERROR_BUFFER_TOO_SMALL;\n                }\n                if (get_bits1(gb)) {\n                    skip_bits_long(gb, 3 * 16 + 32); // custom epf weight\n                    if (get_bits_left(gb) < 0)\n                        return AVERROR_BUFFER_TOO_SMALL;\n                }\n                if (get_bits1(gb)) { // custom epf sigma\n                    if (frame->encoding == JPEGXL_ENC_VARDCT)\n                        skip_bits(gb, 16);\n                    skip_bits_long(gb, 16 * 3);\n                    if (get_bits_left(gb) < 0)\n                        return AVERROR_BUFFER_TOO_SMALL;\n                }\n                if (frame->encoding == JPEGXL_ENC_MODULAR)\n                    skip_bits(gb, 16);\n            }\n            ret = skip_extensions(gb);\n            if (ret < 0)\n                return ret;\n        }\n        ret = skip_extensions(gb);\n        if (ret < 0)\n            return ret;\n    }\n\n    width = div_ceil(div_ceil(width, upsampling), 1 << (3 * lf_level));\n    height = div_ceil(div_ceil(height, upsampling), 1 << (3 * lf_level));\n    group_dim = 128 << group_size_shift;\n    lf_group_dim = group_dim << 3;\n    num_groups = div_ceil(width, group_dim) * div_ceil(height, group_dim);\n    num_lf_groups = div_ceil(width, lf_group_dim) * div_ceil(height, lf_group_dim);\n    if (num_groups == 1 && num_passes == 1)\n        toc_count = 1;\n    else\n        toc_count = 2 + num_lf_groups + num_groups * num_passes;\n\n    // permuted toc\n    if (get_bits1(gb)) {\n        JXLEntropyDecoder dec;\n        uint32_t end, lehmer = 0;\n        ret = entropy_decoder_init(avctx, gb, &dec, 8);\n        if (ret < 0)\n            return ret;\n        if (get_bits_left(gb) < 0) {\n            entropy_decoder_close(&dec);\n            return AVERROR_BUFFER_TOO_SMALL;\n        }\n        end = entropy_decoder_read_symbol(gb, &dec, toc_context(toc_count));\n        if (end > toc_count) {\n            entropy_decoder_close(&dec);\n            return AVERROR_INVALIDDATA;\n        }\n        for (uint32_t i = 0; i < end; i++) {\n            lehmer = entropy_decoder_read_symbol(gb, &dec, toc_context(lehmer));\n            if (get_bits_left(gb) < 0) {\n                entropy_decoder_close(&dec);\n                return AVERROR_BUFFER_TOO_SMALL;\n            }\n        }\n        entropy_decoder_close(&dec);\n    }\n    align_get_bits(gb);\n\n    for (uint32_t i = 0; i < toc_count; i++) {\n        frame->body_length += 8 * jxl_u32(gb, 0, 1024, 17408, 4211712, 10, 14, 22, 30);\n        if (get_bits_left(gb) < 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n    align_get_bits(gb);\n\n    frame->total_length = frame->body_length + get_bits_count(gb) - start_len;\n\n    return 0;\n}\n\nstatic int skip_boxes(JXLParseContext *ctx, const uint8_t *buf, int buf_size)\n{\n    GetByteContext gb;\n\n    if (ctx->skip > buf_size)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    buf += ctx->skip;\n    buf_size -= ctx->skip;\n    bytestream2_init(&gb, buf, buf_size);\n\n    while (1) {\n        uint64_t size;\n        int head_size = 4;\n\n        if (bytestream2_peek_le16(&gb) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE)\n            break;\n        if (bytestream2_peek_le64(&gb) == FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            break;\n\n        if (bytestream2_get_bytes_left(&gb) < 8)\n            return AVERROR_BUFFER_TOO_SMALL;\n\n        size = bytestream2_get_be32(&gb);\n        if (size == 1) {\n            if (bytestream2_get_bytes_left(&gb) < 12)\n                return AVERROR_BUFFER_TOO_SMALL;\n            size = bytestream2_get_be64(&gb);\n            head_size = 12;\n        }\n        if (!size)\n            return AVERROR_INVALIDDATA;\n        /* invalid ISOBMFF size */\n        if (size <= head_size + 4 || size > INT_MAX - ctx->skip)\n            return AVERROR_INVALIDDATA;\n\n        ctx->skip += size;\n        bytestream2_skip(&gb, size - head_size);\n        if (bytestream2_get_bytes_left(&gb) <= 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n\n    return 0;\n}\n\nstatic int try_parse(AVCodecParserContext *s, AVCodecContext *avctx, JXLParseContext *ctx,\n                     const uint8_t *buf, int buf_size)\n{\n    int ret, cs_buflen, header_skip;\n    const uint8_t *cs_buffer;\n    GetBitContext gb;\n\n    if (ctx->skip > buf_size)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    buf += ctx->skip;\n    buf_size -= ctx->skip;\n\n    if (ctx->container || AV_RL64(buf) == FF_JPEGXL_CONTAINER_SIGNATURE_LE) {\n        ctx->container = 1;\n        ret = ff_jpegxl_collect_codestream_header(buf, buf_size, ctx->cs_buffer,\n                                                  sizeof(ctx->cs_buffer), &ctx->copied);\n        if (ret < 0)\n            return ret;\n        ctx->collected_size = ret;\n        if (!ctx->copied) {\n            ctx->skip += ret;\n            return AVERROR_BUFFER_TOO_SMALL;\n        }\n        cs_buffer = ctx->cs_buffer;\n        cs_buflen = FFMIN(sizeof(ctx->cs_buffer), ctx->copied);\n    } else {\n        cs_buffer = buf;\n        cs_buflen = buf_size;\n    }\n\n    if (!ctx->codestream_length) {\n        header_skip = ff_jpegxl_parse_codestream_header(cs_buffer, cs_buflen, &ctx->codestream.meta, 0);\n        if (header_skip < 0)\n            return header_skip;\n        ctx->codestream_length = header_skip;\n        populate_fields(s, avctx, &ctx->codestream.meta);\n    }\n\n    if (ctx->container)\n        return ctx->collected_size;\n\n    ret = init_get_bits8(&gb, cs_buffer, cs_buflen);\n    if (ret < 0)\n        return ret;\n\n    skip_bits_long(&gb, ctx->codestream_length);\n\n    if (!ctx->skipped_icc && ctx->codestream.meta.have_icc_profile) {\n        ret = skip_icc_profile(avctx, ctx, &gb);\n        if (ret < 0)\n            return ret;\n        ctx->skipped_icc = 1;\n        align_get_bits(&gb);\n        ctx->codestream_length = get_bits_count(&gb);\n    }\n\n    if (get_bits_left(&gb) <= 0)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    while (1) {\n        ret = parse_frame_header(avctx, ctx, &gb);\n        if (ret < 0)\n            return ret;\n        ctx->codestream_length += ctx->codestream.frame.total_length;\n        if (ctx->codestream.frame.is_last)\n            return ctx->codestream_length / 8;\n        if (get_bits_left(&gb) <= ctx->codestream.frame.body_length)\n            return AVERROR_BUFFER_TOO_SMALL;\n        skip_bits_long(&gb, ctx->codestream.frame.body_length);\n    }\n}\n\nstatic int jpegxl_parse(AVCodecParserContext *s, AVCodecContext *avctx,\n                        const uint8_t **poutbuf, int *poutbuf_size,\n                        const uint8_t *buf, int buf_size)\n{\n    JXLParseContext *ctx = s->priv_data;\n    int next = END_NOT_FOUND, ret;\n\n    *poutbuf_size = 0;\n    *poutbuf = NULL;\n\n    if (!ctx->pc.index)\n        goto flush;\n\n    if ((!ctx->container || !ctx->codestream_length) && !ctx->next) {\n        ret = try_parse(s, avctx, ctx, ctx->pc.buffer, ctx->pc.index);\n        if (ret < 0)\n            goto flush;\n        ctx->next = ret;\n        if (ctx->container)\n            ctx->skip += ctx->next;\n    }\n\n    if (ctx->container && ctx->next >= 0) {\n        ret = skip_boxes(ctx, ctx->pc.buffer, ctx->pc.index);\n        if (ret < 0) {\n            if (ret == AVERROR_INVALIDDATA)\n                ctx->next = -1;\n            goto flush;\n        }\n        ctx->next = ret + ctx->skip;\n    }\n\n    if (ctx->next >= 0)\n        next = ctx->next - ctx->pc.index;\n\nflush:\n    if (next > buf_size)\n        next = END_NOT_FOUND;\n\n    ret = ff_combine_frame(&ctx->pc, next, &buf, &buf_size);\n    if (ret < 0)\n        return buf_size;\n\n    *poutbuf      = buf;\n    *poutbuf_size = buf_size;\n\n    ctx->codestream_length = 0;\n    ctx->collected_size = 0;\n    ctx->container = 0;\n    ctx->copied = 0;\n    ctx->skip = 0;\n    ctx->skipped_icc = 0;\n    ctx->next = 0;\n    memset(&ctx->codestream, 0, sizeof(ctx->codestream));\n\n    return next;\n}\n\nconst AVCodecParser ff_jpegxl_parser = {\n    .codec_ids      = { AV_CODEC_ID_JPEGXL },\n    .priv_data_size = sizeof(JXLParseContext),\n    .parser_parse   = jpegxl_parse,\n    .parser_close   = ff_parse_close,\n};\n"], "filenames": ["libavcodec/jpegxl_parser.c"], "buggy_code_start_loc": [686], "buggy_code_end_loc": [763], "fixing_code_start_loc": [686], "fixing_code_end_loc": [767], "type": "CWE-125", "message": "FFmpeg prior to commit bf814 was discovered to contain an out of bounds read via the dist->alphabet_size variable in the read_vlc_prefix() function.", "other": {"cve": {"id": "CVE-2023-46407", "sourceIdentifier": "cve@mitre.org", "published": "2023-10-27T20:15:09.087", "lastModified": "2024-01-30T20:17:05.310", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FFmpeg prior to commit bf814 was discovered to contain an out of bounds read via the dist->alphabet_size variable in the read_vlc_prefix() function."}, {"lang": "es", "value": "Se descubri\u00f3 que FFmpeg antes del commit bf814 conten\u00eda una lectura fuera de los l\u00edmites a trav\u00e9s de la variable dist-&gt;alphabet_size en la funci\u00f3n read_vlc_prefix()."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.1", "matchCriteriaId": "54E3D89D-E427-413B-A8E1-C9ED6D2409F3"}]}]}], "references": [{"url": "https://github.com/FFmpeg/FFmpeg/commit/bf814387f42e9b0dea9d75c03db4723c88e7d962", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://patchwork.ffmpeg.org/project/ffmpeg/patch/20231013014959.536776-1-leo.izen%40gmail.com/", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://patchwork.ffmpeg.org/project/ffmpeg/patch/20231015004924.597746-1-leo.izen%40gmail.com/", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/bf814387f42e9b0dea9d75c03db4723c88e7d962"}}