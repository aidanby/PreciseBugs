{"buggy_code": ["/*\n * card-myeid.c\n *\n * Copyright (C) 2008-2019 Aventra Ltd.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <string.h>\n#include <stdlib.h>\n\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"cardctl.h\"\n#include \"types.h\"\n\n/* Low byte is the MyEID card's key type specific component ID. High byte is used\n * internally for key type, so myeid_loadkey() is aware of the exact component. */\n#define LOAD_KEY_MODULUS\t\t0x0080\n#define LOAD_KEY_PUBLIC_EXPONENT\t0x0081\n#define LOAD_KEY_PRIME_P\t\t0x0083\n#define LOAD_KEY_PRIME_Q\t\t0x0084\n#define LOAD_KEY_DP1\t\t\t0x0085\n#define LOAD_KEY_DQ1\t\t\t0x0086\n#define LOAD_KEY_INVQ\t\t\t0x0087\n#define LOAD_KEY_EC_PUBLIC\t\t0x1086\n#define LOAD_KEY_EC_PRIVATE\t\t0x1087\n#define LOAD_KEY_SYMMETRIC\t\t0x20a0\n\n#define MYEID_CARD_NAME_MAX_LEN\t\t100\n\n/* The following flags define the features supported by the card currently in use.\n  They are used in 'card_supported_features' field in myeid_card_caps struct */\n#define MYEID_CARD_CAP_RSA\t\t0x01\n#define MYEID_CARD_CAP_3DES\t\t0x02\n#define MYEID_CARD_CAP_AES\t\t0x04\n#define MYEID_CARD_CAP_ECC\t\t0x08\n#define MYEID_CARD_CAP_GRIDPIN\t\t0x10\n#define MYEID_CARD_CAP_PIV_EMU\t\t0x20\n\n#define MYEID_MAX_APDU_DATA_LEN\t\t0xFF\n#define MYEID_MAX_RSA_KEY_LEN\t\t4096\n\n#define MYEID_MAX_EXT_APDU_BUFFER_SIZE\t(MYEID_MAX_RSA_KEY_LEN/8+16)\n\nstatic const char *myeid_card_name = \"MyEID\";\nstatic const char *oseid_card_name = \"OsEID\";\nstatic char card_name_buf[MYEID_CARD_NAME_MAX_LEN];\n\nstatic struct sc_card_operations myeid_ops;\nstatic struct sc_card_driver myeid_drv = {\n\t\"MyEID cards with PKCS#15 applet\",\n\t\"myeid\",\n\t&myeid_ops,\n\tNULL,\n\t0,\n\tNULL\n};\n\ntypedef struct myeid_private_data {\n\tint card_state;\n\n\tunsigned short change_counter;\n\tunsigned char cap_chaining;\n\t/* the driver sets sec_env pointer in myeid_set_security_env and\n\t it is used immediately in myeid_decipher to differentiate between RSA decryption and\n\t ECDH key agreement. Note that this pointer is usually not valid\n\t after this pair of calls and must not be used elsewhere. */\n\tconst struct sc_security_env* sec_env;\n\tint disable_hw_pkcs1_padding;\n\t/* buffers for AES(DES) block cipher */\n\tuint8_t sym_crypt_buffer[16];\n\tuint8_t sym_plain_buffer[16];\n\tuint8_t sym_crypt_buffer_len;\n\tuint8_t sym_plain_buffer_len;\n\t/* PSO for AES/DES need algo+flags from sec env */\n\tunsigned int algorithm, algorithm_flags;\n} myeid_private_data_t;\n\ntypedef struct myeid_card_caps {\n\tunsigned char card_caps_ver;\n\tunsigned short card_supported_features;\n\tunsigned short max_rsa_key_length;\n\tunsigned short max_des_key_length;\n\tunsigned short max_aes_key_length;\n\tunsigned short max_ecc_key_length;\n} myeid_card_caps_t;\n\nstatic struct myeid_supported_ec_curves {\n\tchar *curve_name;\n\tstruct sc_object_id curve_oid;\n\tsize_t size;\n} ec_curves[] = {\n\t{\"secp192r1\", {{1, 2, 840, 10045, 3, 1, 1, -1}},192},\n\t/* {\"secp224r1\", {{1, 3, 132, 0, 33, -1}},\t\t224}, */\n\t{\"secp256r1\", {{1, 2, 840, 10045, 3, 1, 7, -1}},256},\n\t{\"secp384r1\", {{1, 3, 132, 0, 34, -1}},\t\t384},\n\t{\"secp521r1\", {{1, 3, 132, 0, 35, -1}},\t\t521},\n\t{NULL, {{-1}}, 0},\n};\n\nstatic int myeid_get_info(struct sc_card *card, u8 *rbuf, size_t buflen);\nstatic int myeid_get_card_caps(struct sc_card *card, myeid_card_caps_t* card_caps);\n\nstatic int myeid_match_card(struct sc_card *card)\n{\n\tsize_t len = card->reader->atr_info.hist_bytes_len;\n\t/* Normally the historical bytes are exactly \"MyEID\", but there might\n\t * be some historic units which have a small prefix byte sequence. */\n\tif (len >= 5) {\n\t\tif (!memcmp(&card->reader->atr_info.hist_bytes[len - 5], \"MyEID\", 5)) {\n\t\t\tsc_log(card->ctx, \"Matched MyEID card\");\n\t\t\tcard->type = SC_CARD_TYPE_MYEID_GENERIC;\n\t\t\treturn 1;\n\t\t}\n\t\t/* The software implementation of MyEID is identified by OsEID bytes */\n\t\tif (!memcmp(&card->reader->atr_info.hist_bytes[len - 5], \"OsEID\", 5)) {\n\t\t\tsc_log(card->ctx, \"Matched OsEID card\");\n\t\t\tcard->type = SC_CARD_TYPE_MYEID_OSEID;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nmyeid_select_aid(struct sc_card *card, struct sc_aid *aid, unsigned char *out, size_t *out_len)\n{\n\tstruct sc_apdu apdu;\n\tunsigned char apdu_resp[SC_MAX_APDU_BUFFER_SIZE];\n\tint rv;\n\n\t/* Select application (deselect previously selected application) */\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x04, 0x00);\n\tapdu.lc = aid->len;\n\tapdu.data = aid->value;\n\tapdu.datalen = aid->len;\n\tapdu.resplen = sizeof(apdu_resp);\n\tapdu.resp = apdu_resp;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, rv, \"Cannot select AID\");\n\n\tif (*out_len > 0) {\n\t\tif (*out_len < apdu.resplen)\n\t\t\tLOG_TEST_RET(card->ctx, SC_ERROR_BUFFER_TOO_SMALL, \"Cannot select AID - response buffer too small.\");\n\t\tif (out == NULL)\n\t\t\tLOG_TEST_RET(card->ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot select AID - invalid arguments.\");\n\t\tmemcpy(out, apdu.resp, apdu.resplen);\n\t\t*out_len = apdu.resplen;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int myeid_load_options(sc_context_t *ctx, myeid_private_data_t *priv)\n{\n\tint r;\n\tsize_t i, j;\n\tscconf_block **found_blocks, *block;\n\n\tif (!ctx || !priv) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tpriv->disable_hw_pkcs1_padding = 0;\n\tfor (i = 0; ctx->conf_blocks[i]; i++) {\n\t\tfound_blocks = scconf_find_blocks(ctx->conf, ctx->conf_blocks[i],\n\t\t\t\t\"card_driver\", \"myeid\");\n\t\tif (!found_blocks)\n\t\t\tcontinue;\n\t\tfor (j = 0, block = found_blocks[j]; block; j++, block = found_blocks[j]) {\n\t\t\tpriv->disable_hw_pkcs1_padding = scconf_get_int(block, \"disable_hw_pkcs1_padding\", 0);\n\t\t\tsc_log(ctx,\"Found config option: disable_hw_pkcs1_padding = %d\\n\", priv->disable_hw_pkcs1_padding);\n\t\t}\n\t\tfree(found_blocks);\n\t}\n\tr = SC_SUCCESS;\n\nerr:\n\treturn r;\n}\n\nstatic int myeid_init(struct sc_card *card)\n{\n\tunsigned long flags = 0, ext_flags = 0;\n\tmyeid_private_data_t *priv;\n\tu8 appletInfo[20];\n\tsize_t appletInfoLen;\n\tmyeid_card_caps_t card_caps;\n\tsize_t resp_len = 0;\n\tstatic struct sc_aid myeid_aid = { \"\\xA0\\x00\\x00\\x00\\x63\\x50\\x4B\\x43\\x53\\x2D\\x31\\x35\", 0x0C };\n\tint rv = 0;\n\tvoid *old_drv_data = card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tswitch (card->type) {\n\tcase SC_CARD_TYPE_MYEID_OSEID:\n\t\tcard->name = oseid_card_name;\n\t\tbreak;\n\tcase SC_CARD_TYPE_MYEID_GENERIC:\n\t\tcard->name = myeid_card_name;\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_CARD);\n\t}\n\n\tpriv = calloc(1, sizeof(myeid_private_data_t));\n\n\tif (!priv)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\trv = myeid_load_options (card->ctx, priv);\n\tLOG_TEST_GOTO_ERR(card->ctx, rv, \"Unable to read options from opensc.conf\");\n\n\tpriv->card_state = SC_FILE_STATUS_CREATION;\n\tcard->drv_data = priv;\n\n\t/* Ensure that the MyEID applet is selected. */\t\n\trv = myeid_select_aid(card, &myeid_aid, NULL, &resp_len);\n\tLOG_TEST_GOTO_ERR(card->ctx, rv, \"Failed to select MyEID applet.\");\n\n\t/* find out MyEID version */\n\n\tappletInfoLen = 20;\n\n\tif (0 > myeid_get_info(card, appletInfo, appletInfoLen))\n\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_CARD, \"Failed to get MyEID applet information.\");\n\n\tpriv->change_counter = appletInfo[19] | appletInfo[18] << 8;\n\n\tmemset(&card_caps, 0, sizeof(myeid_card_caps_t));\n\tcard_caps.max_ecc_key_length = 256;\n\tcard_caps.max_rsa_key_length = 2048;\n\n\tif (card->version.fw_major >= 40) {\n\t    /* Since 4.0, we can query available algorithms and key sizes.\n\t     * Since 3.5.0 RSA up to 2048 and ECC up to 256 are always supported, so we check only max ECC key length. */\n\t    if (myeid_get_card_caps(card, &card_caps) != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \"Failed to get card capabilities. Using default max ECC key length 256.\");\n\t    }\n\t}\n\n\tflags = SC_ALGORITHM_RSA_RAW | SC_ALGORITHM_ONBOARD_KEY_GEN;\n\tif (priv->disable_hw_pkcs1_padding == 0)\n\t\tflags |= SC_ALGORITHM_RSA_PAD_PKCS1;\n\tflags |= SC_ALGORITHM_RSA_HASH_NONE;\n\n\t_sc_card_add_rsa_alg(card,  512, flags, 0);\n\t_sc_card_add_rsa_alg(card,  768, flags, 0);\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0);\n\t_sc_card_add_rsa_alg(card, 1536, flags, 0);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0);\n\n\tif (card_caps.card_supported_features & MYEID_CARD_CAP_RSA) {\n\t\tif (card_caps.max_rsa_key_length >= 3072)\n\t\t\t_sc_card_add_rsa_alg(card, 3072, flags, 0);\n\t\tif (card_caps.max_rsa_key_length >= 4096)\n\t\t\t_sc_card_add_rsa_alg(card, 4096, flags, 0);\n\t}\n\n\t/* show ECC algorithms if the applet version of the inserted card supports them */\n\tif (card->version.fw_major >= 35) {\n\t\tint i;\n\n\t\tflags = SC_ALGORITHM_ECDSA_RAW | SC_ALGORITHM_ECDH_CDH_RAW | SC_ALGORITHM_ONBOARD_KEY_GEN;\n\t\tflags |= SC_ALGORITHM_ECDSA_HASH_NONE;\n\t\text_flags = SC_ALGORITHM_EXT_EC_NAMEDCURVE | SC_ALGORITHM_EXT_EC_UNCOMPRESES;\n\n\t\tfor (i=0; ec_curves[i].curve_name != NULL; i++) {\n\t\t\tif (card_caps.max_ecc_key_length >= ec_curves[i].size)\n\t\t\t\t_sc_card_add_ec_alg(card, ec_curves[i].size, flags, ext_flags, &ec_curves[i].curve_oid);\n\t\t}\n\t}\n\n\t/* show supported symmetric algorithms */\n\tflags = 0;\n\tif (card_caps.card_supported_features & MYEID_CARD_CAP_3DES) {\n\t\tif (card_caps.max_des_key_length >= 64)\n\t\t\t_sc_card_add_symmetric_alg(card, SC_ALGORITHM_DES, 64, flags);\n\t\tif (card_caps.max_des_key_length >= 128)\n\t\t\t_sc_card_add_symmetric_alg(card, SC_ALGORITHM_3DES, 128, flags);\n\t\tif (card_caps.max_des_key_length >= 192)\n\t\t\t_sc_card_add_symmetric_alg(card, SC_ALGORITHM_3DES, 192, flags);\n\t}\n\tif (card_caps.card_supported_features & MYEID_CARD_CAP_AES) {\n\t\tif (card_caps.max_aes_key_length >= 128)\n\t\t\t_sc_card_add_symmetric_alg(card, SC_ALGORITHM_AES, 128, flags);\n\t\tif (card_caps.max_aes_key_length >= 256)\n\t\t\t_sc_card_add_symmetric_alg(card, SC_ALGORITHM_AES, 256, flags);\n\t}\n\n\t/* State that we have an RNG */\n\tcard->caps |= SC_CARD_CAP_RNG | SC_CARD_CAP_ISO7816_PIN_INFO;\n\n\tif ((card->version.fw_major == 40 && card->version.fw_minor >= 10 )\n\t\t|| card->version.fw_major >= 41)\n\t\tcard->caps |= SC_CARD_CAP_WRAP_KEY | SC_CARD_CAP_UNWRAP_KEY\n\t\t\t   | SC_CARD_CAP_ONCARD_SESSION_OBJECTS;\n\n\tif (card->version.fw_major >= 45)\n\t\tpriv->cap_chaining = 1;\n\tif (card->version.fw_major >= 40)\n\t\tcard->max_recv_size = 256;\n\telse\n\t\tcard->max_recv_size = 255;\n\tcard->max_send_size = 255;\n\n\trv = SC_SUCCESS;\n\nerr:\n\tif (rv < 0) {\n\t\tfree(priv);\n\t\tcard->drv_data = old_drv_data;\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, rv);\n}\n\nstatic const struct sc_card_operations *iso_ops = NULL;\n\nstatic int acl_to_byte(const struct sc_acl_entry *e)\n{\n\tif (NULL == e)\n\t\treturn 0x00;\n\tswitch (e->method) {\n\tcase SC_AC_NONE:\n\t\treturn 0x00;\n\tcase SC_AC_CHV:\n\tcase SC_AC_TERM:\n\tcase SC_AC_AUT:\n\t\tif (e->key_ref == SC_AC_KEY_REF_NONE)\n\t\t\treturn 0x00;\n\t\tif (e->key_ref < 1 || e->key_ref > 14)\n\t\t\treturn 0x00;\n\t\treturn e->key_ref;\n\tcase SC_AC_NEVER:\n\t\treturn 0x0F;\n\t}\n\treturn 0x00;\n}\n\nstatic void add_acl_entry(struct sc_file *file, int op, u8 byte)\n{\n\tunsigned int method, key_ref = SC_AC_KEY_REF_NONE;\n\n\tswitch (byte)\n\t{\n\tcase 0:\n\t\tmethod = SC_AC_NONE;\n\t\tbreak;\n\tcase 15:\n\t\tmethod = SC_AC_NEVER;\n\t\tbreak;\n\tdefault:\n\t\tmethod = SC_AC_CHV;\n\t\tkey_ref = byte;\n\t\tbreak;\n\t}\n\tsc_file_add_acl_entry(file, op, method, key_ref);\n}\n\nstatic void parse_sec_attr(struct sc_file *file, const u8 *buf, size_t len)\n{\n\tint i;\n\tconst int df_ops[4] =\n\t\t{ SC_AC_OP_CREATE, SC_AC_OP_CREATE, SC_AC_OP_DELETE, -1 };\n\tconst int ef_ops[4] =\n\t\t{ SC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_DELETE, -1 };\n\tconst int key_ops[4] =\n\t\t{ SC_AC_OP_CRYPTO, SC_AC_OP_UPDATE, SC_AC_OP_DELETE, SC_AC_OP_GENERATE };\n\n\tconst int *ops;\n\n\tif (len < 2)\n\t\treturn;\n\n\tswitch (file->type) {\n\tcase SC_FILE_TYPE_WORKING_EF:\n\t\tops = ef_ops;\n\t\tbreak;\n\tcase SC_FILE_TYPE_INTERNAL_EF:\n\t\tops = key_ops;\n\t\tbreak;\n\tcase SC_FILE_TYPE_DF:\n\t\tops = df_ops;\n\t\tbreak;\n\tdefault:\n\t\tops = key_ops;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\tif (ops[i] == -1)\n\t\t\tcontinue;\n\t\tif ((i & 1) == 0)\n\t\t\tadd_acl_entry(file, ops[i], (u8)(buf[i / 2] >> 4));\n\t\telse\n\t\t\tadd_acl_entry(file, ops[i], (u8)(buf[i / 2] & 0x0F));\n\t}\n}\n\nstatic int myeid_select_file(struct sc_card *card, const struct sc_path *in_path,\n\t\tstruct sc_file **file)\n{\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tr = iso_ops->select_file(card, in_path, file);\n\n\tif (r == 0 && file != NULL && *file != NULL)\n\t\tparse_sec_attr(*file, (*file)->sec_attr, (*file)->sec_attr_len);\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_logout(struct sc_card *card)\n{\n\tsc_apdu_t apdu;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x2E, 0x00, 0x00 /*pin ref: 0x01-0x0E, 0=ALL*/);\n\tapdu.cla = 0;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tLOG_FUNC_RETURN(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n\nstatic int myeid_list_files(struct sc_card *card, u8 *buf, size_t buflen)\n{\n\tstruct sc_apdu apdu;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xCA, 0x01, 0xA1);\n\tapdu.resp = buf;\n\tapdu.resplen = buflen;\n\tapdu.le = buflen > 256 ? 256 : buflen;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (apdu.resplen == 0)\n\t\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\n\treturn apdu.resplen;\n}\n\nstatic int myeid_process_fci(struct sc_card *card, struct sc_file *file,\n\t\tconst u8 *buf, size_t buflen)\n{\n\tmyeid_private_data_t *priv = (myeid_private_data_t *) card->drv_data;\n\tsize_t taglen = 0;\n\tconst u8 *tag = NULL;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tr = iso_ops->process_fci(card, file, buf, buflen);\n\tif (r < 0)\n\t LOG_FUNC_RETURN(card->ctx, r);\n\n\tif(file->type == SC_FILE_EF_UNKNOWN)\n\t{\n\t\ttag = sc_asn1_find_tag(NULL, buf, buflen, 0x82, &taglen);\n\t\tif (tag != NULL && taglen > 0 && *tag == 17)\n\t\t{\n\t\t\tfile->type = SC_FILE_TYPE_INTERNAL_EF;\n\t\t}\n\t}\n\tif(file->sec_attr_len >= 3)\n\t{\n\t\tsc_log(card->ctx, \"id (%X) sec_attr (%X %X %X)\", file->id,\n\t\t\tfile->sec_attr[0],file->sec_attr[1],file->sec_attr[2]);\n\t}\n\n\tpriv->card_state = file->status;\n\tswitch (file->status) {\n\t\tcase SC_FILE_STATUS_CREATION:\n\t\t\tfile->acl_inactive = 1;\n\t\t\tsc_log(card->ctx, \"File id (%X) status SC_FILE_STATUS_CREATION\", file->id);\n\t\t\tbreak;\n\t\tcase SC_FILE_STATUS_ACTIVATED:\n\t\t\tsc_log(card->ctx, \"File id (%X) status SC_FILE_STATUS_ACTIVATED\", file->id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsc_log(card->ctx, \"File id (%X) unusual status (0x%X)\", file->id, file->status);\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, 0);\n}\n\nstatic int encode_file_structure(sc_card_t *card, const sc_file_t *file,\n\t\tu8 *buf, size_t *outlen)\n{\n\tconst sc_acl_entry_t *read, *update, *delete, *generate;\n\tsize_t i;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (!buf || !outlen || *outlen < 45)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\n\t/* PrivateKey\n\t * 0E0000019 6217 81020400 820111 83024B01 8603000000 85028000 8A0100 RESULT 6984\n\t *\t   6217 81020400 820111 83024B01 8603000000 85021000 8A0100 */\n\tmemset(buf, 0x0, *outlen);\n\n\tbuf[0] = 0x62;\n\tbuf[1] = 0x17;\n\t/* File size */\n\tbuf[2] = (SC_FILE_TYPE_WORKING_EF == file->type ? 0x80 : 0x81);\n\tbuf[3] = 0x02;\n\tbuf[4] = (file->size >> 8) & 0xFF;\n\tbuf[5] = file->size & 0xFF;\n\n\t/* File Description tag */\n\tbuf[6] = 0x82;\n\tbuf[7] = 0x01;\n\tbuf[8] = 0x01;\n\n\t/* File Identifier tag */\n\tbuf[9]  = 0x83;\n\tbuf[10] = 0x02;\n\tbuf[11] = (file->id >> 8) & 0xFF;\n\tbuf[12] = file->id & 0xFF;\n\n\t/* Security Attributes Tag */\n\tbuf[13] = 0x86;\n\tbuf[14] = 0x03;\n\tbuf[15] = 0xFF;\n\tbuf[16] = 0xFF;\n\tbuf[17] = 0xFF;\n\n\tif (file->sec_attr_len == 3 && file->sec_attr)   {\n\t\tbuf[15] = file->sec_attr[0];\n\t\tbuf[16] = file->sec_attr[1];\n\t\tbuf[17] = file->sec_attr[2];\n\n\t\tsc_log(card->ctx, \"id (%X), sec_attr %X %X %X\", file->id,\n\t\t\t\tfile->sec_attr[0],file->sec_attr[1],file->sec_attr[2]);\n\t}\n\telse   {\n\t\tdelete = sc_file_get_acl_entry(file, SC_AC_OP_DELETE);\n\n\t\tsc_log(card->ctx, \"id (%X), type (%X)\", file->id, file->type);\n\n\t\tswitch (file->type) {\n\t\tcase SC_FILE_TYPE_WORKING_EF:\n\n\t\t\tread = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\t\tupdate = sc_file_get_acl_entry(file, SC_AC_OP_UPDATE);\n\n\t\t\tbuf[15] = (acl_to_byte(read) << 4) | acl_to_byte(update);\n\t\t\tbuf[16] = (acl_to_byte(delete)<< 4) | 0x0F;\n\t\t\tbreak;\n\t\tcase SC_FILE_TYPE_INTERNAL_EF:\n\n\t\t\tread = sc_file_get_acl_entry(file, SC_AC_OP_CRYPTO);\n\t\t\tupdate = sc_file_get_acl_entry(file, SC_AC_OP_UPDATE);\n\t\t\tgenerate = sc_file_get_acl_entry(file, SC_AC_OP_GENERATE);\n\n\t\t\tbuf[15] = (acl_to_byte(read) << 4) | acl_to_byte(update);\n\t\t\tbuf[16] = (acl_to_byte(delete)<< 4) | acl_to_byte(generate);\n\t\t\tbreak;\n\t\tcase SC_FILE_TYPE_DF:\n\n\t\t\tupdate = sc_file_get_acl_entry(file, SC_AC_OP_CREATE);\n\n\t\t\tbuf[15] = (acl_to_byte(update) << 4) | acl_to_byte(update);\n\t\t\tbuf[16] = (acl_to_byte(delete) << 4) | 0x0F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Proprietary Information */\n\tbuf[18] = 0x85;\n\tbuf[19] = 0x02;\n\tif (file->prop_attr_len == 2 && file->prop_attr != NULL)\n\t    memcpy(&buf[20], file->prop_attr, 2);\n\telse\n\t{\n\t\tbuf[20] = 0x00;\n\t\tbuf[21] = 0x00;\n\t}\n\n\t/* Life Cycle Status tag */\n\tbuf[22] = 0x8A;\n\tbuf[23] = 0x01;\n\tbuf[24] = 0x0; /* RFU */\n\n\tswitch (file->type)\n\t{\n\tcase SC_FILE_TYPE_WORKING_EF:\n\t\tbreak;\n\n\tcase SC_FILE_TYPE_INTERNAL_EF:\n\t\tbuf[8] = file->ef_structure; /* RSA or EC */\n\t\tbreak;\n\n\tcase SC_FILE_TYPE_DF:\n\t\tbuf[8] = 0x38;\n\t\tif(file->namelen > 0 && file->namelen <= 16)\n\t\t{\n\t\t\tbuf[25] = 0x84;\n\t\t\tbuf[26] = (u8)file->namelen;\n\n\t\t\tfor(i=0;i < file->namelen;i++)\n\t\t\t\tbuf[i + 27] = file->name[i];\n\n\t\t\tbuf[1] = 27 + file->namelen;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsc_log(card->ctx, \"Unknown file type\\n\");\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\t*outlen = buf[1]+2;\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\nstatic int myeid_create_file(struct sc_card *card, struct sc_file *file)\n{\n\tsc_apdu_t apdu;\n\tu8 sbuf[45];\n\tsize_t buflen = sizeof sbuf;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = encode_file_structure(card, file, sbuf, &buflen);\n\tif (r)\n\t  LOG_FUNC_RETURN(card->ctx, r);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE0, 0x00, 0x00);\n\tapdu.data = sbuf;\n\tapdu.datalen = buflen;\n\tapdu.lc = buflen;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (apdu.sw1 == 0x6A && apdu.sw2 == 0x89)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_ALREADY_EXISTS);\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_delete_file(struct sc_card *card, const struct sc_path *path)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (path->type != SC_PATH_TYPE_FILE_ID && path->len != 2)\n\t{\n\t\tsc_log(card->ctx, \"File type has to be SC_PATH_TYPE_FILE_ID\\n\");\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tr = sc_select_file(card, path, NULL);\n\tLOG_TEST_RET(card->ctx, r, \"Unable to select file to be deleted\");\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0xE4, 0x00, 0x00);\n\tapdu.cla = 0xA0;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tLOG_FUNC_RETURN(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n\nstatic int myeid_pin_cmd(sc_card_t *card, struct sc_pin_cmd_data *data,\n\t\t\t int *tries_left)\n{\n\tmyeid_private_data_t *priv = (myeid_private_data_t *) card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_log(card->ctx, \"ref (%d), pin1 len(%d), pin2 len (%d)\\n\",\n\t\t\tdata->pin_reference, data->pin1.len, data->pin2.len);\n\n\tif(data->pin1.len > 8 || data->pin2.len > 8)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_PIN_LENGTH);\n\n\tdata->pin1.pad_length = data->pin2.pad_length = 8;\n\tdata->pin1.pad_char = data->pin2.pad_char = 0xFF;\n\n\tif (data->cmd == SC_PIN_CMD_VERIFY && priv->card_state == SC_FILE_STATUS_CREATION) {\n\t\tsc_log(card->ctx, \"Card in creation state, no need to verify\");\n\t\treturn SC_SUCCESS;\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, iso_ops->pin_cmd(card, data, tries_left));\n}\n\n#define IS_SYMETRIC_CRYPT(x) ((x) == SC_SEC_OPERATION_ENCRYPT_SYM || (x) == SC_SEC_OPERATION_DECRYPT_SYM)\n\nstatic int myeid_set_security_env_rsa(sc_card_t *card, const sc_security_env_t *env,\n\t\tint se_num)\n{\n\tsc_apdu_t apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 *p;\n\tint r;\n\tsize_t i;\n\tsc_path_t *target_file;\n\n\tassert(card != NULL && env != NULL);\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (env->flags & SC_SEC_ENV_KEY_REF_SYMMETRIC)\n\t{\n\t\tsc_log(card->ctx, \"symmetric keyref not supported.\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\tif (se_num > 0)\n\t{\n\t\tsc_log(card->ctx, \"restore security environment not supported.\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0, 0);\n\tswitch (env->operation)\n\t{\n\tcase SC_SEC_OPERATION_DECIPHER:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_SIGN:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB6;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_UNWRAP:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_WRAP:\n\t\tapdu.p1 = 0x81;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_ENCRYPT_SYM:\n\t\tapdu.p1 = 0x81;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_DECRYPT_SYM:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tapdu.le = 0;\n\tp = sbuf;\n\tif (env->flags & SC_SEC_ENV_ALG_REF_PRESENT)\n\t{\n\t\t*p++ = 0x80;\t/* algorithm reference */\n\t\t*p++ = 0x01;\n\t\t*p++ = env->algorithm_ref & 0xFF;\n\t}\n\tif (env->flags & SC_SEC_ENV_FILE_REF_PRESENT)\n\t{\n\t\t*p++ = 0x81;\n\t\t*p++ = 2;\n\t\tmemcpy(p, env->file_ref.value, 2);\n\t\tp += 2;\n\t}\n\t/* symmetric operations: we need to set the key reference */\n\tif (IS_SYMETRIC_CRYPT(env->operation)) {\n\t\t*p++ = 0x83;\n\t\t*p++ = 1;\n\t\t*p++ = 0;\n\t}\n\tif (env->flags & SC_SEC_ENV_KEY_REF_PRESENT && env->operation != SC_SEC_OPERATION_UNWRAP &&\n\t\t\tenv->operation != SC_SEC_OPERATION_WRAP &&\n\t\t\tenv->operation != SC_SEC_OPERATION_ENCRYPT_SYM &&\n\t\t\tenv->operation != SC_SEC_OPERATION_DECRYPT_SYM) {\n\t\t*p++ = 0x84;\n\t\t*p++ = 1;\n\t\t*p++ = 0;\n\t}\n\tfor (i = 0; i < SC_SEC_ENV_MAX_PARAMS; i++)\n\t    if (env->params[i].param_type == SC_SEC_ENV_PARAM_TARGET_FILE) {\n\t\t\ttarget_file = (sc_path_t*) env->params[i].value;\n\t\t\tif (env->params[i].value_len < sizeof(sc_path_t) || target_file->len != 2) {\n\t\t\t\tsc_log(card->ctx, \"wrong length of target file reference.\\n\");\n\t\t\t\treturn SC_ERROR_WRONG_LENGTH;\n\t\t\t}\n\t\t\t*p++ = 0x83;\n\t\t\t*p++ = 2;\n\t\t\tmemcpy(p, target_file->value, 2);\n\t\t\tp+= 2;\n\t\t\tbreak;\n\t    }\n\n\tr = 0;\n\tif (env->operation == SC_SEC_OPERATION_UNWRAP || env->operation == SC_SEC_OPERATION_WRAP ||\n\t\t\tIS_SYMETRIC_CRYPT(env->operation)) {\n\t\t/* add IV if present */\n\t\tfor (i = 0; i < SC_SEC_ENV_MAX_PARAMS; i++)\n\t\t\tif (env->params[i].param_type == SC_SEC_ENV_PARAM_IV) {\n\t\t\t\tr = 1;\n\t\t\t\t*p++ = 0x87;\n\t\t\t\t*p++ = (unsigned char) env->params[i].value_len;\n\t\t\t\tif (p + env->params[i].value_len >= sbuf + SC_MAX_APDU_BUFFER_SIZE) {\n\t\t\t\t\tsc_log(card->ctx, \"IV too long.\\n\");\n\t\t\t\t\treturn SC_ERROR_WRONG_LENGTH;\n\t\t\t\t}\n\t\t\t\tmemcpy(p, env->params[i].value, env->params[i].value_len);\n\t\t\t\tp+=(unsigned char) env->params[i].value_len;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\t/* for AES_ECB we need to reset the IV but we respect if the IV is already present */\n\tif (IS_SYMETRIC_CRYPT(env->operation) && env->algorithm == SC_ALGORITHM_AES &&\n\t\t\tenv->algorithm_flags == SC_ALGORITHM_AES_ECB && r == 0) {\n\t\t*p++ = 0x87;\n\t\t*p++ = 16;\n\t\tmemset(p, 0, 16);\n\t\tp += 16;\n\t}\n\n\tr = p - sbuf;\n\tapdu.lc = r;\n\tapdu.datalen = r;\n\tapdu.data = sbuf;\n\tapdu.resplen = 0;\n\tif (apdu.datalen != 0)\n\t{\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r)\n\t\t{\n\t\t\tsc_log(card->ctx,\n\t\t\t\t\"%s: APDU transmit failed\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tif (r)\n\t\t{\n\t\t\tsc_log(card->ctx,\n\t\t\t\t\"%s: Card returned error\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t}\nerr:\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_set_security_env_ec(sc_card_t *card, const sc_security_env_t *env,\n\t\tint se_num)\n{\n\tsc_apdu_t apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 *p;\n\tint r;\n\n\tassert(card != NULL && env != NULL);\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (env->flags & SC_SEC_ENV_KEY_REF_SYMMETRIC)\n\t{\n\t\tsc_log(card->ctx, \"symmetric keyref not supported.\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\tif (se_num > 0)\n\t{\n\t\tsc_log(card->ctx, \"restore security environment not supported.\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0, 0);\n\tswitch (env->operation)\n\t{\n\tcase SC_SEC_OPERATION_DECIPHER:\n\t\tsc_log(card->ctx, \"Decipher operation is not supported with EC keys.\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_SIGN:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB6;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_DERIVE:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xA4;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tapdu.le = 0;\n\tp = sbuf;\n\tif (env->flags & SC_SEC_ENV_ALG_REF_PRESENT)\n\t{\n\t\t*p++ = 0x80;\t/* algorithm reference */\n\t\t*p++ = 0x01;\n\t\t*p++ = env->algorithm_ref & 0xFF;\n\t}\n\tif (env->flags & SC_SEC_ENV_FILE_REF_PRESENT)\n\t{\n\t\t*p++ = 0x81;\n\t\t*p++ = 0x02;\n\t\tmemcpy(p, env->file_ref.value, 2);\n\t\tp += 2;\n\t}\n\tif (env->flags & SC_SEC_ENV_KEY_REF_PRESENT)\n\t{\n\t\t*p++ = 0x84;\n\t\t*p++ = 1;\n\t\t*p++ = 0;\n\t}\n\tr = p - sbuf;\n\tapdu.lc = r;\n\tapdu.datalen = r;\n\tapdu.data = sbuf;\n\tapdu.resplen = 0;\n\tif (apdu.datalen != 0)\n\t{\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r)\n\t\t{\n\t\t\tsc_log(card->ctx,\n\t\t\t\t\"%s: APDU transmit failed\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tif (r)\n\t\t{\n\t\t\tsc_log(card->ctx,\n\t\t\t\t\"%s: Card returned error\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t}\nerr:\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_set_security_env(struct sc_card *card,\n\t\tconst struct sc_security_env *env, int se_num)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tmyeid_private_data_t* priv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tpriv = (myeid_private_data_t*) card->drv_data;\n\t/* store security environment to differentiate between ECDH and RSA in decipher - Hannu*/\n\tpriv->sec_env = env;\n\n\t/* for symmetric operation save algo and algo flags */\n\tpriv->algorithm_flags = env->algorithm_flags;\n\tpriv->algorithm = env->algorithm;\n\n\tif (env->flags & SC_SEC_ENV_ALG_PRESENT)\n\t{\n\t\tsc_security_env_t tmp;\n\n\t\ttmp = *env;\n\t\ttmp.flags &= ~SC_SEC_ENV_ALG_PRESENT;\n\t\ttmp.flags |= SC_SEC_ENV_ALG_REF_PRESENT;\n\n\t\tif (tmp.algorithm == SC_ALGORITHM_RSA)\n\t\t{\n\t\t\tif (tmp.operation == SC_SEC_OPERATION_UNWRAP || tmp.operation == SC_SEC_OPERATION_WRAP)\n\t\t\t{\n\t\t\t    tmp.algorithm_ref = 0x0A;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmp.algorithm_ref = 0x00;\n\t\t\t\t/* potential FIXME: return an error, if an unsupported\n\t\t\t\t* pad or hash was requested, although this shouldn't happen */\n\t\t\t\tif (env->algorithm_flags & SC_ALGORITHM_RSA_PAD_PKCS1)\n\t\t\t\t\ttmp.algorithm_ref = 0x02;\n\t\t\t\tif (tmp.algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA1)\n\t\t\t\t\ttmp.algorithm_ref |= 0x10;\n\t\t\t}\n\n\t\t\treturn myeid_set_security_env_rsa(card, &tmp, se_num);\n\t\t}\n\t\telse if (tmp.algorithm == SC_ALGORITHM_EC)\n\t\t{\n\t\t\ttmp.algorithm_ref = 0x04;\n\t\t\ttmp.algorithm_flags = 0;\n\t\t\treturn myeid_set_security_env_ec(card, &tmp, se_num);\n\t\t}\n\t\telse if (tmp.algorithm == SC_ALGORITHM_AES)\n\t\t{\n\t\t\tif (tmp.operation == SC_SEC_OPERATION_UNWRAP || tmp.operation == SC_SEC_OPERATION_WRAP)\n\t\t\t{\n\t\t\t\ttmp.algorithm_ref = 0x0A;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmp.algorithm_ref = 0x00;\n\t\t\t}\n\n\t\t\tif ((tmp.algorithm_flags & SC_ALGORITHM_AES_CBC_PAD) == SC_ALGORITHM_AES_CBC_PAD)\n\t\t\t\ttmp.algorithm_ref |= 0x80;\t\t/* set PKCS#7 padding */\n\t\t\t/* Tag 0x80 algorithm_ref - value 0x80 or 0x8A is working only for UNWRAP/WRAP\n\t\t\t * AES is supported from version 4.0 but without pkcs#7 padding.\n\t\t\t * For SC_SEC_OPERATION_ENCRYPT_SYM and SC_SEC_OPERATION_DECRYPT_SYM we running\n\t\t\t * PKCS#7 in software, here we fix the algorithm_ref variable.\n\t\t\t */\n\t\t\tif (IS_SYMETRIC_CRYPT(env->operation))\n\t\t\t\ttmp.algorithm_ref &= ~0x80; /* do not handle padding in card */\n\n\t\t\t/* from this point, there's no difference to RSA SE */\n\t\t\treturn myeid_set_security_env_rsa(card, &tmp, se_num);\n\t\t}\n\t\telse\n\t\t{\n\n\t\t\tsc_log(ctx, \"Unsupported algorithm.\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t}\n\treturn myeid_set_security_env_rsa(card, env, se_num);\n}\n\n\nstatic int\nmyeid_convert_ec_signature(struct sc_context *ctx, size_t s_len, unsigned char *data, size_t datalen)\n{\n\tunsigned char *buf;\n\tsize_t buflen;\n\tint r;\n\tsize_t len_size = 1;\n\tsize_t sig_len = 0;\n\n\tassert(data && datalen && datalen > 3);\n\n\t/*\n\t *\tWhen validating the signature data, we have to consider that length of the signature\n\t *\tcan be encoded in either one or two bytes depending on key size. With 521 bit keys\n\t *\tlength of the structure takes two bytes.\n\t */\n\n\tif (*data != 0x30)\n\t\treturn SC_ERROR_INVALID_DATA;\n\n\tif ((*(data + 1) & 0x80) == 0x80)\n\t\tlen_size += *(data + 1) & 0x7F;\n\n\tif (len_size == 1)\n\t    sig_len = *(data + 1);\n\telse if (len_size == 2)\n\t    sig_len = *(data + 2);\n\telse if (len_size == 3)\n\t{\n\t    sig_len = *(data + 2) | (*data + 3) << 8;\n\t}\n\telse\n\t    return SC_ERROR_INVALID_DATA;\n\n\tif (*(data + 1 + len_size) != 0x02)\t\t/* Verify that it is an INTEGER */\n\n\tif (sig_len != (datalen - len_size - 1))\t/* validate size of the DER structure */\n\t    return SC_ERROR_INVALID_DATA;\n\n\t/* test&fail early */\n\tbuflen = (s_len + 7)/8*2;\n\tif (buflen > datalen)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);\n\n\tbuf = calloc(1, buflen);\n\tif (!buf)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tr = sc_asn1_sig_value_sequence_to_rs(ctx, data, datalen, buf, buflen);\n\tif (r < 0) {\n\t\tfree(buf);\n\t\tsc_log(ctx, \"Failed to convert Sig-Value to the raw RS format\");\n\t\treturn r;\n\t}\n\n\tmemmove(data, buf, buflen);\n\tfree(buf);\n\treturn buflen;\n}\n/* MyEID cards before version 4.5 do not support RAW RSA signature for 2048 bit RSA keys.\n * (Source: MyEID reference manual 2.1.4)\n *\n * This function uses decipher operation for calculating RAW 2048 bit signature. */\nstatic int\nmyeid_compute_raw_2048_signature(struct sc_card *card, const u8 * data, size_t datalen,\n\t\tu8 * out, size_t outlen)\n{\n\tint r;\n\tstruct sc_context *ctx;\n\tstruct myeid_private_data *priv;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tsc_security_env_t env;\n\n\tctx = card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\n\tpriv = (myeid_private_data_t *) card->drv_data;\n\n/* security env change - use DECIPHER operation */\n\tmemcpy(&env, priv->sec_env, sizeof(sc_security_env_t));\n\tenv.flags |= SC_SEC_ENV_ALG_REF_PRESENT;\n\tenv.flags |= SC_SEC_ENV_FILE_REF_PRESENT;\n\tenv.flags |= SC_SEC_ENV_KEY_REF_PRESENT;\n\tenv.operation = SC_SEC_OPERATION_DECIPHER;\n\tmyeid_set_security_env_rsa(card, &env, 0);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = 0;\t/* there is no response to 1st part of data */\n\n/* prepare 1st part of data */\n\tsbuf[0] = 0x81;\n\tmemcpy(sbuf + 1, data, datalen / 2);\n\tapdu.lc = datalen / 2 + 1;\n\tapdu.datalen = apdu.lc;\n\tapdu.data = sbuf;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {\n/* prepare 2nd part of data */\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = datalen;\n\t\tsbuf[0] = 0x82;\n\t\tmemcpy(sbuf + 1, data + datalen / 2, datalen / 2);\n\t\tapdu.lc = datalen / 2 + 1;\n\t\tapdu.datalen = apdu.lc;\n\t\tapdu.data = sbuf;\n\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\t\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {\n\t\t\tint len = apdu.resplen > outlen ? outlen : apdu.resplen;\n\t\t\tmemcpy(out, apdu.resp, len);\n\t\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t\t}\n\t}\n\tLOG_FUNC_RETURN(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n\nstatic int\nmyeid_compute_signature(struct sc_card *card, const u8 * data, size_t datalen,\n\t\tu8 * out, size_t outlen)\n{\n\tstruct sc_context *ctx;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[MYEID_MAX_EXT_APDU_BUFFER_SIZE];\n\tu8 sbuf[MYEID_MAX_EXT_APDU_BUFFER_SIZE];\n\tstruct myeid_private_data* priv;\n\tint r;\n\tsize_t field_length = 0;\n\tsize_t pad_chars = 0;\n\n\n\tassert(card != NULL && data != NULL && out != NULL);\n\tctx = card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\n\tpriv = (myeid_private_data_t*) card->drv_data;\n\tsc_log(ctx, \"key type %i, key length %i\", priv->sec_env->algorithm, priv->sec_env->algorithm_ref);\n\n\tif (priv->sec_env->algorithm == SC_ALGORITHM_EC ) {\n\n\t    field_length = priv->sec_env->algorithm_ref;\n\n\t    /* pad with zeros if needed */\n\t\tif (datalen < (field_length + 7) / 8 ) {\n\t\t\tpad_chars = ((field_length + 7) / 8) - datalen;\n\n\t\t\tmemset(sbuf, 0, pad_chars);\n\t\t}\n\t}\n\n\tif ((datalen + pad_chars) > sizeof(sbuf))\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tif (priv->sec_env->algorithm == SC_ALGORITHM_RSA && datalen == 256 && !priv->cap_chaining)\n\t\treturn myeid_compute_raw_2048_signature(card, data, datalen, out, outlen);\n\n\t/* INS: 0x2A  PERFORM SECURITY OPERATION\n\t\t* P1:  0x9E  Resp: Digital Signature\n\t\t* P2:  0x9A  Cmd: Input for Digital Signature */\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x9E, 0x9A);\n\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = 256;\n\tmemcpy(sbuf + pad_chars, data, datalen);\n\tapdu.lc = datalen + pad_chars;\n\tapdu.datalen = datalen + pad_chars;\n\n\tapdu.data = sbuf;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, r, \"compute_signature failed\");\n\n\tif (priv->sec_env->algorithm == SC_ALGORITHM_EC) {\n\t\tr = myeid_convert_ec_signature(ctx, priv->sec_env->algorithm_ref, apdu.resp, apdu.resplen);\n\t\tLOG_TEST_RET(ctx, r, \"compute_signature convert signature failed\");\n\t\tapdu.resplen = r;\n\t}\n\n\tif (apdu.resplen > outlen)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);\n\n\tmemcpy(out, apdu.resp, apdu.resplen);\n\tLOG_FUNC_RETURN(ctx, apdu.resplen);\n}\n\n\n/* takes other party's public key as input, performs ECDH key derivation and returns the shared secret in [out]. */\nint myeid_ecdh_derive(struct sc_card *card, const u8* pubkey, size_t pubkey_len, u8* out, size_t outlen)\n{\n\n\t/* MyEID uses GENERAL AUTHENTICATE ISO command for ECDH */\n\n\tstruct sc_apdu apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\n\tint r;\n\tsize_t ext_len_bytes;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x86, 0x00, 0x00);\n\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\n\t/* Fill in \"Data objects in dynamic authentication template\" (tag 0x7C) structure\n\t*\n\t* TODO: encode the structure using OpenSC's ASN1-functions.\n\t*\n\t*  Size of the structure depends on key length. With 521 bit keys two bytes are needed for defining length of a point.\n\t*/\n\n\tsbuf[0] = 0x7C;\n\text_len_bytes = 0;\n\n\tif (pubkey_len > 127)\n\t{\n\t\tsbuf[1] = 0x81;\n\t\tsbuf[2] = (u8) (pubkey_len + 3);\n\t\tsbuf[3] = 0x85;\n\t\tsbuf[4] = 0x81;\n\t\tsbuf[5] = (u8) (pubkey_len);\n\t\text_len_bytes = 2;\n\t}\n\telse\n\t{\n\t\tsbuf[1] = pubkey_len + 2;\n\t\tsbuf[2] = 0x85;\n\t\tsbuf[3] = pubkey_len;\n\t}\n\n\tmemcpy(&sbuf[4 + ext_len_bytes], pubkey, pubkey_len);\n\n\tapdu.lc = pubkey_len + 4 + ext_len_bytes;\n\tapdu.le = pubkey_len / 2;\n\tapdu.datalen = apdu.lc;\n\tapdu.data = sbuf;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed.\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"ECDH operation failed - GENERAL AUTHENTICATE returned error.\");\n\n\tif (outlen < apdu.resplen)\n\t{\n\t\tr = SC_ERROR_BUFFER_TOO_SMALL;\n\t\tLOG_TEST_RET(card->ctx, r, \"Buffer too small to hold shared secret.\");\n\t}\n\n\tmemcpy(out, rbuf, apdu.resplen);\n\n\tLOG_FUNC_RETURN(card->ctx, apdu.resplen);\n}\n\nstatic int myeid_transmit_decipher_pi_split(struct sc_card *card, struct sc_apdu *apdu, u8 *sbuf)\n{\n\t/* MyEID before 4.5.x does not support APDU chaining. The payload\n\t * is split to two regular APDUs and Padding Indicator field is used to\n\t * describe which slice it is. */\n\tsize_t crgram_len = apdu->lc - 1;\n\tsize_t crgram_half = crgram_len / 2;\n\tsize_t resplen = apdu->resplen;\n\tunsigned char *resp = apdu->resp;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t/* Send 1st part, no response */\n\tapdu->cse = SC_APDU_CASE_3_SHORT;\n\tapdu->data = &sbuf[0];\n\tapdu->datalen = apdu->lc = crgram_half + 1;\n\tapdu->resp = 0;\n\tapdu->resplen = 0;\n\tapdu->le = 0;\n\tsbuf[0] = 0x81;\t\t\t/* Padding Indicator, 0x81 = First half */\n\n\tr = sc_transmit_apdu(card, apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (apdu->sw1 != 0x90 || apdu->sw2 != 0x00)\n\t\treturn 0;\n\n\t/* Send 2nd part, expect response */\n\tapdu->cse = resplen ? SC_APDU_CASE_4_SHORT : SC_APDU_CASE_3_SHORT;\n\tapdu->data = &sbuf[crgram_half];\n\tapdu->datalen = apdu->lc = crgram_len - crgram_half + 1;\n\tapdu->resp = resp;\n\tapdu->resplen = resplen;\n\tapdu->le = resplen ? MIN(card->max_recv_size, crgram_len) : 0;\n\tsbuf[crgram_half] = 0x82;\t/* Padding Indicator, 0x82 = Second half */\n\n\tr = sc_transmit_apdu(card, apdu);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_transmit_decipher(struct sc_card *card, u8 p1, u8 p2,\n\t\tconst u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tmyeid_private_data_t *priv = card->drv_data;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_EXT_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_EXT_APDU_BUFFER_SIZE];\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t/* INS: 0x2A  PERFORM SECURITY OPERATION\n\t * P1:  0x00  Resp: No response (unwrapping)\n\t * P1:  0x80  Resp: Plain value\n\t * P2:  0x84  Cmd: Cryptogram (no padding byte)\n\t * P2:  0x86  Cmd: Padding indicator byte followed by cryptogram */\n\tsc_format_apdu(card, &apdu, p1 ? SC_APDU_CASE_4_SHORT : SC_APDU_CASE_3_SHORT, 0x2A, p1, p2);\n\tif (p2 == 0x86) {\n\t\tif (crgram_len+1 > sizeof(sbuf))\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t\tsbuf[0] = 0; /* Padding indicator: 0x00 = No further indication */\n\t\tmemcpy(sbuf + 1, crgram, crgram_len);\n\t\tapdu.data = sbuf;\n\t\tapdu.datalen = apdu.lc = crgram_len + 1;\n\t} else {\n\t\tapdu.data = crgram;\n\t\tapdu.datalen = apdu.lc = crgram_len;\n\t}\n\tif (p1 != 0x00) {\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = MIN(card->max_recv_size, crgram_len);\n\t}\n\n\tif (p2 == 0x86 && crgram_len == 256 && priv && !priv->cap_chaining) {\n\t\tr = myeid_transmit_decipher_pi_split(card, &apdu, sbuf);\n\t} else {\n\t\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t}\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"DECIPHER returned error\");\n\n\tif (out && outlen) {\n\t\toutlen = MIN(apdu.resplen, outlen);\n\t\tmemcpy(out, apdu.resp, outlen);\n\t} else {\n\t\toutlen = 0;\n\t}\n\tLOG_FUNC_RETURN(card->ctx, outlen);\n}\n\nstatic int myeid_decipher(struct sc_card *card, const u8 * crgram,\n\t\tsize_t crgram_len, u8 * out, size_t outlen)\n{\n\tint r;\n\tmyeid_private_data_t* priv;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tassert(card != NULL && crgram != NULL && out != NULL);\n\n\tpriv = (myeid_private_data_t*) card->drv_data;\n\n\tif (priv->sec_env && priv->sec_env->algorithm == SC_ALGORITHM_EC\n\t\t&& priv->sec_env->operation == SC_SEC_OPERATION_DERIVE\n\t\t&& priv->sec_env->algorithm_flags & SC_ALGORITHM_ECDH_CDH_RAW)\n\t{\n\t\tr = myeid_ecdh_derive(card, crgram, crgram_len, out, outlen);\n\t\tpriv->sec_env = NULL; /* clear after operation */\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\n\tr = myeid_transmit_decipher(card, 0x80, 0x86, crgram, crgram_len, out, outlen);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n\nstatic int myeid_wrap_key(struct sc_card *card, u8 *out, size_t outlen)\n{\n\tstruct sc_context *ctx;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint r;\n\n\tassert(card != NULL);\n\tctx = card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\n\t/* INS: 0x2A  PERFORM SECURITY OPERATION\n\t   P1:  0x84  Resp: Return a cryptogram\n\t * P2:  0x00  The data field is absent */\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0x2A, 0x84, 0x00);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = sizeof(rbuf) <= 256 ? sizeof(rbuf) : 256;\n\tapdu.lc = 0;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, r, \"wrap key failed\");\n\n\tif (apdu.resplen <= outlen && out != NULL)\n\t\tmemcpy(out, apdu.resp, apdu.resplen);\n\n\tLOG_FUNC_RETURN(ctx, apdu.resplen);\n}\n\nstatic int myeid_unwrap_key(struct sc_card *card, const u8 *crgram, size_t crgram_len)\n{\n\tmyeid_private_data_t* priv;\n\tu8 p2 = 0x86; /* init P2 for asymmetric crypto by default.*/\n\tint r;\n\n\tif (card == NULL || crgram == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tpriv = card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (crgram_len > MYEID_MAX_RSA_KEY_LEN / 8)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tif (priv && priv->sec_env)\n\t{\n\t\tif (priv->sec_env->algorithm == SC_ALGORITHM_AES ||\n\t\t\tpriv->sec_env->algorithm == SC_ALGORITHM_3DES ||\n\t\t\tpriv->sec_env->algorithm == SC_ALGORITHM_DES)\n\t\t\t\tp2 = 0x84;\n\t}\n\n\tif (p2 == 0x84 && crgram_len > MYEID_MAX_APDU_DATA_LEN)\n\t\tLOG_TEST_RET(card->ctx, SC_ERROR_WRONG_LENGTH, \"Unwrapping symmetric data longer that 255 bytes is not supported\\n\");\n\n\t/* INS: 0x2A  PERFORM SECURITY OPERATION\n\t * P1:  0x00  Do not expect response - the deciphered data will be placed into the target key EF.\n\t * P2:  0x86  Cmd: Padding indicator byte followed by cryptogram\n\t * P2:  0x84  Cmd: AES/3DES Cryptogram (plain value encoded in BER-TLV DO, but not including SM DOs) */\n\tr = myeid_transmit_decipher(card, 0x00, p2, crgram, crgram_len, 0, 0);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n\n/* Write internal data, e.g. add default pin-records to pin */\nstatic int myeid_putdata(struct sc_card *card, struct sc_cardctl_myeid_data_obj* data_obj)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tmemset(&apdu, 0, sizeof(apdu));\n\tapdu.cse     = SC_APDU_CASE_3_SHORT;\n\tapdu.cla     = 0x00;\n\tapdu.ins     = 0xDA;\n\tapdu.p1      = data_obj->P1;\n\tapdu.p2      = data_obj->P2;\n\tapdu.lc      = data_obj->DataLen;\n\tapdu.datalen = data_obj->DataLen;\n\tapdu.data    = data_obj->Data;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"PUT_DATA returned error\");\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/* Read internal data, e.g. get RSA public key */\nstatic int myeid_getdata(struct sc_card *card, struct sc_cardctl_myeid_data_obj* data_obj)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tmemset(&apdu, 0, sizeof(apdu));\n\tapdu.cse     = SC_APDU_CASE_2_SHORT;\n\tapdu.cla     = 0x00;\n\tapdu.ins     = 0xCA;\t\t/* GET DATA */\n\tapdu.p1      = data_obj->P1;\n\tapdu.p2      = data_obj->P2;\n\tapdu.lc      = 0;\n\tapdu.datalen = 0;\n\tapdu.data    = data_obj->Data;\n\n\tapdu.le      = card->max_recv_size;\n\tapdu.resp    = data_obj->Data;\n\tapdu.resplen = data_obj->DataLen;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"GET_DATA returned error\");\n\n\tif (apdu.resplen > data_obj->DataLen)\n\t\tr = SC_ERROR_WRONG_LENGTH;\n\telse\n\t\tdata_obj->DataLen = apdu.resplen;\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_loadkey(sc_card_t *card, unsigned mode, u8* value, int value_len)\n{\n\tmyeid_private_data_t *priv = (myeid_private_data_t *) card->drv_data;\n\tsc_apdu_t apdu;\n\tu8 sbuf[MYEID_MAX_EXT_APDU_BUFFER_SIZE];\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (value_len == 0 || value == NULL)\n\t\treturn 0;\n\n\tif (mode == LOAD_KEY_MODULUS && value_len == 256 && !priv->cap_chaining)\n\t{\n\t\tmode = 0x88;\n\t\tmemset(&apdu, 0, sizeof(apdu));\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xDA, 0x01, mode);\n\n\t\tapdu.cla     = 0x00;\n\t\tapdu.data    = value;\n\t\tapdu.datalen = 128;\n\t\tapdu.lc\t     = 128;\n\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(card->ctx, r, \"LOAD KEY returned error\");\n\n\t\tmode = 0x89;\n\t\tvalue += 128;\n\t\tvalue_len -= 128;\n\t}\n\telse if ((mode & 0xff00) == 0 && mode != LOAD_KEY_PUBLIC_EXPONENT &&\n\t\t value[0] != 0x00)\n\t{\n\t\t/* RSA components needing leading zero byte */\n\t\tsbuf[0] = 0x0;\n\t\tmemcpy(&sbuf[1], value, value_len);\n\t\tvalue = sbuf;\n\t\tvalue_len ++;\n\t}\n\n\tmemset(&apdu, 0, sizeof(apdu));\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xDA, 0x01, mode & 0xFF);\n\tapdu.flags   = SC_APDU_FLAGS_CHAINING;\n\tapdu.cla     = 0x00;\n\tapdu.data    = value;\n\tapdu.datalen = value_len;\n\tapdu.lc\t     = value_len;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/* Generate or store a key */\nstatic int myeid_generate_store_key(struct sc_card *card,\n\tstruct sc_cardctl_myeid_gen_store_key_info *data)\n{\n\tstruct\tsc_apdu apdu;\n\tu8\tsbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint\tr=0,len;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\t/* Setup key-generation parameters */\n\tif (data->op_type == OP_TYPE_GENERATE)\n\t{\n\t\tlen = 0;\n\t\tmemset(&apdu, 0, sizeof(apdu));\n\n\t\tif(data->key_type == SC_CARDCTL_MYEID_KEY_RSA)\n\t\t{\n\t\t    sbuf[len++] = 0x30;\n\t\t    sbuf[len++] = 0x05;\n\t\t    sbuf[len++] = 0x81;\n\t\t    sbuf[len++] = data->pubexp_len;\n\n\t\t    memcpy(sbuf + len, data->pubexp, data->pubexp_len);\n\t\t    len += data->pubexp_len;\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46, 0x00, 0x00);\n\t\t\tapdu.data    = sbuf;\n\t\t}\n\t\telse if(data->key_type == SC_CARDCTL_MYEID_KEY_EC) {\n\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x46, 0x00, 0x00);\n\n\t\t\tapdu.data    = NULL;\n\t\t\tapdu.resp\t = sbuf;\n\t\t\tapdu.resplen = 0x00;\n\t\t\tapdu.le\t\t = 0x00;\n\t\t}\n\n\t\tapdu.cla     = 0x00;\n\t\tapdu.datalen = len;\n\t\tapdu.lc\t     = len;\n\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(card->ctx, r, \"GENERATE_KEY returned error\");\n\t}\n\telse\n\t{\n\t\tif(data->key_type == SC_CARDCTL_MYEID_KEY_RSA)\n\t\t{\n\t\t\tif((r=myeid_loadkey(card, LOAD_KEY_PRIME_P,\n\t\t\t\tdata->primep, data->primep_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_PRIME_Q,\n\t\t\t\tdata->primeq, data->primeq_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_DP1,\n\t\t\t\tdata->dp1, data->dp1_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_DQ1,\n\t\t\t\tdata->dq1, data->dq1_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_INVQ,\n\t\t\t\tdata->invq, data->invq_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_MODULUS,\n\t\t\t\tdata->mod, data->key_len_bits)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_PUBLIC_EXPONENT,\n\t\t\t\tdata->pubexp, data->pubexp_len)) >= 0)\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t}\n\t\telse if(data->key_type == SC_CARDCTL_MYEID_KEY_EC) {\n\t\t\tif((r = myeid_loadkey(card, LOAD_KEY_EC_PRIVATE, data->d,\n\t\t\t\t\tdata->d_len)) >= 0 &&\n\t\t\t\t(r = myeid_loadkey(card, LOAD_KEY_EC_PUBLIC, data->ecpublic_point,\n\t\t\t\t\tdata->ecpublic_point_len)) >= 0)\n\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t}\n\t\telse if(data->key_type == SC_CARDCTL_MYEID_KEY_AES ||\n\t\t\tdata->key_type == SC_CARDCTL_MYEID_KEY_DES) {\n\t\t\tif((r = myeid_loadkey(card, LOAD_KEY_SYMMETRIC, data->d,\n\t\t\t\t\tdata->d_len)) >= 0)\n\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_activate_card(struct sc_card *card)\n{\n\tint r;\n\tu8 sbuf[] =\"\\xA0\\x00\\x00\\x00\\x63\\x50\\x4B\\x43\\x53\\x2D\\x31\\x35\";\n\tsc_apdu_t apdu;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x44, 0x04, 0x00);\n\tapdu.cla     = 0x00;\n\tapdu.data    = sbuf;\n\tapdu.datalen = 0x0C;\n\tapdu.lc\t     = 0x0C;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"ACTIVATE_APPLET returned error\");\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_get_info(struct sc_card *card, u8 *rbuf, size_t buflen)\n{\n\tsc_apdu_t apdu;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xca, 0x01, 0xA0);\n\tapdu.resp    = rbuf;\n\tapdu.resplen = buflen;\n\tapdu.le      = buflen;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r,  \"APDU transmit failed\");\n\n\tif (apdu.sw1 != 0x90 || apdu.sw2 != 0x00)\n\t\treturn SC_ERROR_INTERNAL;\n\n\tif (apdu.resplen != 20)\n\t{\n\t\tsc_log(card->ctx, \"Unexpected response to GET DATA (applet info)\");\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\t/* store the applet version */\n\tcard->version.fw_major = rbuf[5] * 10 + rbuf[6];\n\tcard->version.fw_minor = rbuf[7];\n\t/* add version to name */\n\tsnprintf(card_name_buf, sizeof(card_name_buf),\n\t\t\t\"%s %d.%d.%d\", card->name, rbuf[5], rbuf[6], rbuf[7]);\n\tcard->name = card_name_buf;\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_get_serialnr(sc_card_t *card, sc_serial_number_t *serial)\n{\n\tint r;\n\tu8  rbuf[256];\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t/* if number cached, get it\n\tif(card->serialnr.value) {\n\t\tmemcpy(serial, &card->serialnr, sizeof(*serial));\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}*/\n\n\t/* get number from card */\n\tr = myeid_get_info(card, rbuf, sizeof(rbuf));\n\tLOG_TEST_RET(card->ctx, r,  \"Get applet info failed\");\n\n\t/* cache serial number */\n\tmemcpy(card->serialnr.value, &rbuf[8], 10);\n\tcard->serialnr.len = 10;\n\n\t/* copy and return serial number */\n\tmemcpy(serial, &card->serialnr, sizeof(*serial));\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int\nmyeid_get_change_counter(sc_card_t *card, size_t *change_counter)\n{\n\tint r;\n\tu8 rbuf[256];\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t/* get change counter from card */\n\tr = myeid_get_info(card, rbuf, sizeof(rbuf));\n\tLOG_TEST_RET(card->ctx, r, \"Get applet info failed\");\n\n\t*change_counter = rbuf[18] * 256 + rbuf[19];\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/*\n Get information of features that the card supports. MyEID 4.x cards are available on different\n hardware and maximum key sizes cannot be determined simply from the version number anymore.\n */\nstatic int myeid_get_card_caps(struct sc_card *card, myeid_card_caps_t* card_caps)\n{\n\tsc_apdu_t apdu;\n\tint r;\n\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xca, 0x01, 0xAA);\n\tapdu.resp    = rbuf;\n\tapdu.resplen = sizeof(myeid_card_caps_t);\n\tapdu.le      = sizeof(myeid_card_caps_t);\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r,  \"APDU transmit failed\");\n\n\tif (apdu.sw1 != 0x90 || apdu.sw2 != 0x00)\n\t\treturn SC_ERROR_INTERNAL;\n\n\tif (apdu.resplen < 11) {\n\t\tsc_log(card->ctx, \"Unexpected response to GET DATA (MyEIC card capabilities)\");\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\tcard_caps->card_caps_ver = rbuf[0];\n\t/* the card returns big endian values */\n\tcard_caps->card_supported_features = (unsigned short) rbuf[1] << 8 | rbuf[2];\n\tcard_caps->max_rsa_key_length = (unsigned short) rbuf[3] << 8 | rbuf[4];\n\tcard_caps->max_des_key_length = (unsigned short) rbuf[5] << 8 | rbuf[6];\n\tcard_caps->max_aes_key_length = (unsigned short) rbuf[7] << 8 | rbuf[8];\n\tcard_caps->max_ecc_key_length = (unsigned short) rbuf[9] << 8 | rbuf[10];\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_card_ctl(struct sc_card *card, unsigned long cmd, void *ptr)\n{\n\tint r = SC_ERROR_NOT_SUPPORTED;\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tswitch(cmd) {\n\tcase SC_CARDCTL_MYEID_PUTDATA:\n\t\tr = myeid_putdata(card,\n\t\t\t(struct sc_cardctl_myeid_data_obj*) ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_MYEID_GETDATA:\n\t\tr = myeid_getdata(card,\n\t\t\t(struct sc_cardctl_myeid_data_obj*) ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_MYEID_GENERATE_STORE_KEY:\n\t\tr = myeid_generate_store_key(card,\n\t\t\t(struct sc_cardctl_myeid_gen_store_key_info *) ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_MYEID_ACTIVATE_CARD:\n\t\tr = myeid_activate_card(card);\n\t\tbreak;\n\tcase SC_CARDCTL_GET_SERIALNR:\n\t\tr = myeid_get_serialnr(card, (sc_serial_number_t *)ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_GET_CHANGE_COUNTER:\n\t\tr = myeid_get_change_counter(card, (size_t *)ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_GET_DEFAULT_KEY:\n\tcase SC_CARDCTL_LIFECYCLE_SET:\n\tcase SC_CARDCTL_LIFECYCLE_GET:\n\t\tbreak;\n\t}\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_finish(sc_card_t * card)\n{\n\tstruct myeid_private_data *priv = (struct myeid_private_data *) card->drv_data;\n\tfree(priv);\n\treturn SC_SUCCESS;\n}\n\nstatic int\nmyeid_enc_dec_sym(struct sc_card *card, const u8 *data, size_t datalen,\n\t\tu8 *out, size_t *outlen, int decipher)\n{\n\n\tstruct sc_context *ctx;\n\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 *sdata;\n\tint r, padding = 0, cbc = 0;\n\n\tsize_t block_size;\n\tsize_t len, rest_len;\n\tsize_t return_len = 0;\n\n\tsize_t max_apdu_datalen;\n\tsize_t apdu_datalen;\n\n\tassert(card != NULL);\n\n\tctx = card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\n\tmyeid_private_data_t *priv;\n\tpriv = (myeid_private_data_t *)card->drv_data;\n\n\t/* How many cipher blocks will fit in the APDU. We do not use the APDU chaining\n\t * mechanism from OpenSC, because we need the size of the APDU data block\n\t * to match a multiple of the cipher block size */\n\n\tmax_apdu_datalen = sc_get_max_send_size(card);\n\tif (max_apdu_datalen > sc_get_max_recv_size(card))\n\t\tmax_apdu_datalen = sc_get_max_recv_size(card);\n\n\tif (max_apdu_datalen > SC_MAX_APDU_BUFFER_SIZE)\n\t\tmax_apdu_datalen = SC_MAX_APDU_BUFFER_SIZE;\n\n\tsc_log(ctx, \"algorithm %d algorithm_flags %x\", priv->algorithm, priv->algorithm_flags);\n\n\t/* for C_Encrypt/C_EncryptUpdate/C_EncryptFinalize/C_Decrypt/C_DecryptUpdate/C_DecryptFinalize\n\t * the 'outlen' is always not NULL (src/pkcs11/framework-pkcs15.c).\n\t * For C_EncryptInit and C_DecrytpInit the 'outlen' is set to NULL\n\t */\n\tif (outlen == NULL) {\n\t\t/* C_EncryptInit/C_DecryptInit - clear buffers */\n\t\tsc_log(ctx, \"%s (symmetric key) initialized\", decipher ? \"C_DecryptInit\" : \"C_EncryptInit\");\n\t\tpriv->sym_crypt_buffer_len = 0;\n\t\tpriv->sym_plain_buffer_len = 0;\n\t\treturn SC_SUCCESS;\n\t}\n\n\tswitch (priv->algorithm) {\n\tcase SC_ALGORITHM_AES:\n\t\tblock_size = 16;\n\t\tif (priv->algorithm_flags & SC_ALGORITHM_AES_ECB) {\n\t\t\tpadding = 0;\n\t\t\tcbc = 0;\n\t\t} else if (priv->algorithm_flags & SC_ALGORITHM_AES_CBC) {\n\t\t\tpadding = 0;\n\t\t\tcbc = 1;\n\t\t} else if (priv->algorithm_flags & SC_ALGORITHM_AES_CBC_PAD) {\n\t\t\tpadding = 1;\n\t\t\tcbc = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\t/* MyEID: ECB APDU must match exact cipher block size in CBC\n\t * mode up to 240 bytes can be handled in one APDU\n\t * round max_apdu_datalen to multiple of block_size (CBC mode) */\n\n\tif (cbc)\n\t\tmax_apdu_datalen -= max_apdu_datalen % block_size;\n\telse\n\t\tmax_apdu_datalen = block_size;\n\n\t/* Maybe we have more input data (from previous PSO operation). */\n\trest_len = priv->sym_crypt_buffer_len;\n\n\t/* no input data from application (this is C_EncryptFinalize/C_DecryptFinalize */\n\tif (data == NULL) {\n\t\tif (datalen != 0)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\t\tif (decipher) {\n\t\t\t/* C_DecryptFinalize */\n\t\t\t/* decrypted buffer size must match the block size */\n\t\t\tif (priv->sym_plain_buffer_len != block_size)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\t\t\t/* do we have any encrypted data left? */\n\t\t\tif (rest_len)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\n\t\t\treturn_len = block_size;\n\t\t\tif (padding) {\n\t\t\t\t/* check padding */\n\t\t\t\tuint8_t i, pad_byte = *(priv->sym_plain_buffer + block_size - 1);\n\n\t\t\t\tsc_log(ctx, \"Found padding byte %02x\", pad_byte);\n\t\t\t\tif (pad_byte == 0 || pad_byte > block_size)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);\n\t\t\t\tsdata = priv->sym_plain_buffer + block_size - pad_byte;\n\t\t\t\tfor (i = 0; i < pad_byte; i++)\n\t\t\t\t\tif (sdata[i] != pad_byte)\n\t\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);\n\t\t\t\treturn_len = block_size - pad_byte;\n\t\t\t}\n\t\t\t*outlen = return_len;\n\t\t\t/* application can request buffer size or actual buffer size is too small */\n\t\t\tif (out == NULL)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t\t\tif (return_len > *outlen)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);\n\t\t\tmemcpy(out, priv->sym_plain_buffer, return_len);\n\t\t\tsc_log(ctx, \"C_DecryptFinal %zu bytes\", *outlen);\n\t\t\treturn SC_SUCCESS;\n\t\t} else {\n\t\t\t/* C_EncryptFinalize */\n\t\t\tif (padding) {\n\t\t\t\tuint8_t pad_byte = block_size - rest_len;\n\t\t\t\tsc_log(ctx, \"Generating padding, padding byte: %d\", pad_byte);\n\t\t\t\tsdata = priv->sym_crypt_buffer + rest_len;\n\t\t\t\tmemset(sdata, pad_byte, pad_byte);\n\t\t\t\trest_len = block_size;\n\n\t\t\t} else if (rest_len) {\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\t\t\t}\n\t\t\t/* fall through - encipher last block */\n\t\t}\n\t}\n\t/* check output buffer size */\n\tlen = datalen + rest_len;\n\n\tsc_log(ctx, \"datalen=%zu rest_len=%zu len=%zu outlen=%zu\", datalen, rest_len, len, *outlen);\n\t/* there is block_size bytes space that can be saved to next run */\n\tlen -= (len % block_size);\n\n\t/* application can request buffer size or actual buffer size is too small */\n\t*outlen = len;\n\tif (out == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t/* application buffer is too small */\n\tif (*outlen < len)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);\n\n\t/* main loop */\n\twhile (len >= block_size) {\n\t\tif (!decipher)\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x84, 0x80);\n\t\telse\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x84);\n\t\tapdu.cla = 0;\n\n\t\tif (len > max_apdu_datalen)\n\t\t\tapdu_datalen = max_apdu_datalen;\n\t\telse\n\t\t\tapdu_datalen = len;\n\n\t\tif (cbc)\n\t\t\tapdu.cla = 0x10;\n\n\t\tlen -= apdu_datalen;\n\t\tsdata = sbuf;\n\n\t\tapdu.le = apdu_datalen;\n\t\tapdu.lc = apdu_datalen;\n\t\tapdu.datalen = apdu_datalen;\n\t\tapdu.data = sbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.resp = rbuf;\n\n\t\t/* do we have any data from the previous step ? */\n\t\tif (rest_len) {\n\t\t\tmemcpy(sbuf, priv->sym_crypt_buffer, rest_len);\n\t\t\tsdata += rest_len;\n\t\t\tapdu_datalen -= rest_len;\n\t\t\tpriv->sym_crypt_buffer_len = 0;\n\t\t\trest_len = 0;\n\t\t}\n\t\tif (data) {\n\t\t\tmemcpy(sdata, data, apdu_datalen);\n\t\t\tdata += apdu_datalen;\n\t\t\tdatalen -= apdu_datalen;\n\t\t}\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, r, \"decrypt_sym/encrypt_sym failed\");\n\t\tif (apdu.resplen != apdu.datalen)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\t\tmemcpy(out, apdu.resp, apdu.resplen);\n\t\tout += apdu.resplen;\n\t\treturn_len += apdu.resplen;\n\t}\n\t/* last block is stored in buffer and is returned to application\n\t * in next call to C_DecryptUpdate or C_DecryptFinal. This allow us\n\t * to compute how many bytes is to be returned after padding removal.\n\t * Whole handling of this is here, because \"data\" and \"out\" buffer\n\t * can be in the same place.\n\t */\n\tif (decipher) {\n\t\tuint8_t tmp_buf[16];\n\t\tif (return_len >= block_size) {\n\t\t\t/* save last block to temp buffer */\n\t\t\tmemcpy(tmp_buf, out - block_size, block_size);\n\t\t\tif (priv->sym_plain_buffer_len) {\n\t\t\t\t/* insert previous last block to output buffer */\n\t\t\t\tsc_log(ctx, \"inserting block from previous decrypt\");\n\t\t\t\tmemmove(out - return_len + block_size, out - return_len, return_len - block_size);\n\t\t\t\tmemcpy(out - return_len, priv->sym_plain_buffer, block_size);\n\t\t\t} else\n\t\t\t\treturn_len -= block_size;\n\t\t\t/* save last (decrypted) block */\n\t\t\tmemcpy(priv->sym_plain_buffer, tmp_buf, block_size);\n\t\t\tpriv->sym_plain_buffer_len = block_size;\n\n\t\t} else\n\t\t\tpriv->sym_plain_buffer_len = 0;\n\t}\n\t/* save rest of data for next run */\n\tpriv->sym_crypt_buffer_len = datalen;\n\tsc_log(ctx, \"rest data len = %zu\", datalen);\n\tif (data)\n\t\tmemcpy(priv->sym_crypt_buffer, data, datalen);\n\tsc_log(ctx, \"return data len = %zu\", return_len);\n\t*outlen = return_len;\n\treturn SC_SUCCESS;\n}\n\nstatic int\nmyeid_encrypt_sym(struct sc_card *card, const u8 *data, size_t datalen, u8 *out, size_t *outlen)\n{\n\treturn myeid_enc_dec_sym(card, data, datalen, out, outlen, 0);\n}\n\nstatic int\nmyeid_decrypt_sym(struct sc_card *card, const u8 *data, size_t datalen, u8 *out, size_t *outlen)\n{\n\treturn myeid_enc_dec_sym(card, data, datalen, out, outlen, 1);\n}\n\nstatic struct sc_card_driver * sc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tif (iso_ops == NULL)\n\t\tiso_ops = iso_drv->ops;\n\n\tmyeid_ops\t\t\t= *iso_drv->ops;\n\tmyeid_ops.match_card\t\t= myeid_match_card;\n\tmyeid_ops.init\t\t\t= myeid_init;\n\tmyeid_ops.finish\t\t= myeid_finish;\n\t/* no record oriented file services */\n\tmyeid_ops.read_record\t\t= NULL;\n\tmyeid_ops.write_record\t\t= NULL;\n\tmyeid_ops.append_record\t\t= NULL;\n\tmyeid_ops.update_record\t\t= NULL;\n\tmyeid_ops.select_file\t\t= myeid_select_file;\n\tmyeid_ops.get_response\t\t= iso_ops->get_response;\n\tmyeid_ops.logout\t\t= myeid_logout;\n\tmyeid_ops.create_file\t\t= myeid_create_file;\n\tmyeid_ops.delete_file\t\t= myeid_delete_file;\n\tmyeid_ops.list_files\t\t= myeid_list_files;\n\tmyeid_ops.set_security_env\t= myeid_set_security_env;\n\tmyeid_ops.compute_signature\t= myeid_compute_signature;\n\tmyeid_ops.decipher\t\t= myeid_decipher;\n\tmyeid_ops.process_fci\t\t= myeid_process_fci;\n\tmyeid_ops.card_ctl\t\t= myeid_card_ctl;\n\tmyeid_ops.pin_cmd\t\t= myeid_pin_cmd;\n\tmyeid_ops.wrap\t\t\t= myeid_wrap_key;\n\tmyeid_ops.unwrap\t\t= myeid_unwrap_key;\n\tmyeid_ops.encrypt_sym\t\t= myeid_encrypt_sym;\n\tmyeid_ops.decrypt_sym\t\t= myeid_decrypt_sym;\n\treturn &myeid_drv;\n}\n\nstruct sc_card_driver * sc_get_myeid_driver(void)\n{\n\treturn sc_get_driver();\n}\n\n"], "fixing_code": ["/*\n * card-myeid.c\n *\n * Copyright (C) 2008-2019 Aventra Ltd.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <string.h>\n#include <stdlib.h>\n\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"cardctl.h\"\n#include \"types.h\"\n\n/* Low byte is the MyEID card's key type specific component ID. High byte is used\n * internally for key type, so myeid_loadkey() is aware of the exact component. */\n#define LOAD_KEY_MODULUS\t\t0x0080\n#define LOAD_KEY_PUBLIC_EXPONENT\t0x0081\n#define LOAD_KEY_PRIME_P\t\t0x0083\n#define LOAD_KEY_PRIME_Q\t\t0x0084\n#define LOAD_KEY_DP1\t\t\t0x0085\n#define LOAD_KEY_DQ1\t\t\t0x0086\n#define LOAD_KEY_INVQ\t\t\t0x0087\n#define LOAD_KEY_EC_PUBLIC\t\t0x1086\n#define LOAD_KEY_EC_PRIVATE\t\t0x1087\n#define LOAD_KEY_SYMMETRIC\t\t0x20a0\n\n#define MYEID_CARD_NAME_MAX_LEN\t\t100\n\n/* The following flags define the features supported by the card currently in use.\n  They are used in 'card_supported_features' field in myeid_card_caps struct */\n#define MYEID_CARD_CAP_RSA\t\t0x01\n#define MYEID_CARD_CAP_3DES\t\t0x02\n#define MYEID_CARD_CAP_AES\t\t0x04\n#define MYEID_CARD_CAP_ECC\t\t0x08\n#define MYEID_CARD_CAP_GRIDPIN\t\t0x10\n#define MYEID_CARD_CAP_PIV_EMU\t\t0x20\n\n#define MYEID_MAX_APDU_DATA_LEN\t\t0xFF\n#define MYEID_MAX_RSA_KEY_LEN\t\t4096\n\n#define MYEID_MAX_EXT_APDU_BUFFER_SIZE\t(MYEID_MAX_RSA_KEY_LEN/8+16)\n\nstatic const char *myeid_card_name = \"MyEID\";\nstatic const char *oseid_card_name = \"OsEID\";\nstatic char card_name_buf[MYEID_CARD_NAME_MAX_LEN];\n\nstatic struct sc_card_operations myeid_ops;\nstatic struct sc_card_driver myeid_drv = {\n\t\"MyEID cards with PKCS#15 applet\",\n\t\"myeid\",\n\t&myeid_ops,\n\tNULL,\n\t0,\n\tNULL\n};\n\ntypedef struct myeid_private_data {\n\tint card_state;\n\n\tunsigned short change_counter;\n\tunsigned char cap_chaining;\n\t/* the driver sets sec_env pointer in myeid_set_security_env and\n\t it is used immediately in myeid_decipher to differentiate between RSA decryption and\n\t ECDH key agreement. Note that this pointer is usually not valid\n\t after this pair of calls and must not be used elsewhere. */\n\tconst struct sc_security_env* sec_env;\n\tint disable_hw_pkcs1_padding;\n\t/* buffers for AES(DES) block cipher */\n\tuint8_t sym_crypt_buffer[16];\n\tuint8_t sym_plain_buffer[16];\n\tuint8_t sym_crypt_buffer_len;\n\tuint8_t sym_plain_buffer_len;\n\t/* PSO for AES/DES need algo+flags from sec env */\n\tunsigned int algorithm, algorithm_flags;\n} myeid_private_data_t;\n\ntypedef struct myeid_card_caps {\n\tunsigned char card_caps_ver;\n\tunsigned short card_supported_features;\n\tunsigned short max_rsa_key_length;\n\tunsigned short max_des_key_length;\n\tunsigned short max_aes_key_length;\n\tunsigned short max_ecc_key_length;\n} myeid_card_caps_t;\n\nstatic struct myeid_supported_ec_curves {\n\tchar *curve_name;\n\tstruct sc_object_id curve_oid;\n\tsize_t size;\n} ec_curves[] = {\n\t{\"secp192r1\", {{1, 2, 840, 10045, 3, 1, 1, -1}},192},\n\t/* {\"secp224r1\", {{1, 3, 132, 0, 33, -1}},\t\t224}, */\n\t{\"secp256r1\", {{1, 2, 840, 10045, 3, 1, 7, -1}},256},\n\t{\"secp384r1\", {{1, 3, 132, 0, 34, -1}},\t\t384},\n\t{\"secp521r1\", {{1, 3, 132, 0, 35, -1}},\t\t521},\n\t{NULL, {{-1}}, 0},\n};\n\nstatic int myeid_get_info(struct sc_card *card, u8 *rbuf, size_t buflen);\nstatic int myeid_get_card_caps(struct sc_card *card, myeid_card_caps_t* card_caps);\n\nstatic int myeid_match_card(struct sc_card *card)\n{\n\tsize_t len = card->reader->atr_info.hist_bytes_len;\n\t/* Normally the historical bytes are exactly \"MyEID\", but there might\n\t * be some historic units which have a small prefix byte sequence. */\n\tif (len >= 5) {\n\t\tif (!memcmp(&card->reader->atr_info.hist_bytes[len - 5], \"MyEID\", 5)) {\n\t\t\tsc_log(card->ctx, \"Matched MyEID card\");\n\t\t\tcard->type = SC_CARD_TYPE_MYEID_GENERIC;\n\t\t\treturn 1;\n\t\t}\n\t\t/* The software implementation of MyEID is identified by OsEID bytes */\n\t\tif (!memcmp(&card->reader->atr_info.hist_bytes[len - 5], \"OsEID\", 5)) {\n\t\t\tsc_log(card->ctx, \"Matched OsEID card\");\n\t\t\tcard->type = SC_CARD_TYPE_MYEID_OSEID;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nmyeid_select_aid(struct sc_card *card, struct sc_aid *aid, unsigned char *out, size_t *out_len)\n{\n\tstruct sc_apdu apdu;\n\tunsigned char apdu_resp[SC_MAX_APDU_BUFFER_SIZE];\n\tint rv;\n\n\t/* Select application (deselect previously selected application) */\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x04, 0x00);\n\tapdu.lc = aid->len;\n\tapdu.data = aid->value;\n\tapdu.datalen = aid->len;\n\tapdu.resplen = sizeof(apdu_resp);\n\tapdu.resp = apdu_resp;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, rv, \"Cannot select AID\");\n\n\tif (*out_len > 0) {\n\t\tif (*out_len < apdu.resplen)\n\t\t\tLOG_TEST_RET(card->ctx, SC_ERROR_BUFFER_TOO_SMALL, \"Cannot select AID - response buffer too small.\");\n\t\tif (out == NULL)\n\t\t\tLOG_TEST_RET(card->ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot select AID - invalid arguments.\");\n\t\tmemcpy(out, apdu.resp, apdu.resplen);\n\t\t*out_len = apdu.resplen;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int myeid_load_options(sc_context_t *ctx, myeid_private_data_t *priv)\n{\n\tint r;\n\tsize_t i, j;\n\tscconf_block **found_blocks, *block;\n\n\tif (!ctx || !priv) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tpriv->disable_hw_pkcs1_padding = 0;\n\tfor (i = 0; ctx->conf_blocks[i]; i++) {\n\t\tfound_blocks = scconf_find_blocks(ctx->conf, ctx->conf_blocks[i],\n\t\t\t\t\"card_driver\", \"myeid\");\n\t\tif (!found_blocks)\n\t\t\tcontinue;\n\t\tfor (j = 0, block = found_blocks[j]; block; j++, block = found_blocks[j]) {\n\t\t\tpriv->disable_hw_pkcs1_padding = scconf_get_int(block, \"disable_hw_pkcs1_padding\", 0);\n\t\t\tsc_log(ctx,\"Found config option: disable_hw_pkcs1_padding = %d\\n\", priv->disable_hw_pkcs1_padding);\n\t\t}\n\t\tfree(found_blocks);\n\t}\n\tr = SC_SUCCESS;\n\nerr:\n\treturn r;\n}\n\nstatic int myeid_init(struct sc_card *card)\n{\n\tunsigned long flags = 0, ext_flags = 0;\n\tmyeid_private_data_t *priv;\n\tu8 appletInfo[20];\n\tsize_t appletInfoLen;\n\tmyeid_card_caps_t card_caps;\n\tsize_t resp_len = 0;\n\tstatic struct sc_aid myeid_aid = { \"\\xA0\\x00\\x00\\x00\\x63\\x50\\x4B\\x43\\x53\\x2D\\x31\\x35\", 0x0C };\n\tint rv = 0;\n\tvoid *old_drv_data = card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tswitch (card->type) {\n\tcase SC_CARD_TYPE_MYEID_OSEID:\n\t\tcard->name = oseid_card_name;\n\t\tbreak;\n\tcase SC_CARD_TYPE_MYEID_GENERIC:\n\t\tcard->name = myeid_card_name;\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_CARD);\n\t}\n\n\tpriv = calloc(1, sizeof(myeid_private_data_t));\n\n\tif (!priv)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\trv = myeid_load_options (card->ctx, priv);\n\tLOG_TEST_GOTO_ERR(card->ctx, rv, \"Unable to read options from opensc.conf\");\n\n\tpriv->card_state = SC_FILE_STATUS_CREATION;\n\tcard->drv_data = priv;\n\n\t/* Ensure that the MyEID applet is selected. */\t\n\trv = myeid_select_aid(card, &myeid_aid, NULL, &resp_len);\n\tLOG_TEST_GOTO_ERR(card->ctx, rv, \"Failed to select MyEID applet.\");\n\n\t/* find out MyEID version */\n\n\tappletInfoLen = 20;\n\n\tif (0 > myeid_get_info(card, appletInfo, appletInfoLen))\n\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_CARD, \"Failed to get MyEID applet information.\");\n\n\tpriv->change_counter = appletInfo[19] | appletInfo[18] << 8;\n\n\tmemset(&card_caps, 0, sizeof(myeid_card_caps_t));\n\tcard_caps.max_ecc_key_length = 256;\n\tcard_caps.max_rsa_key_length = 2048;\n\n\tif (card->version.fw_major >= 40) {\n\t    /* Since 4.0, we can query available algorithms and key sizes.\n\t     * Since 3.5.0 RSA up to 2048 and ECC up to 256 are always supported, so we check only max ECC key length. */\n\t    if (myeid_get_card_caps(card, &card_caps) != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \"Failed to get card capabilities. Using default max ECC key length 256.\");\n\t    }\n\t}\n\n\tflags = SC_ALGORITHM_RSA_RAW | SC_ALGORITHM_ONBOARD_KEY_GEN;\n\tif (priv->disable_hw_pkcs1_padding == 0)\n\t\tflags |= SC_ALGORITHM_RSA_PAD_PKCS1;\n\tflags |= SC_ALGORITHM_RSA_HASH_NONE;\n\n\t_sc_card_add_rsa_alg(card,  512, flags, 0);\n\t_sc_card_add_rsa_alg(card,  768, flags, 0);\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0);\n\t_sc_card_add_rsa_alg(card, 1536, flags, 0);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0);\n\n\tif (card_caps.card_supported_features & MYEID_CARD_CAP_RSA) {\n\t\tif (card_caps.max_rsa_key_length >= 3072)\n\t\t\t_sc_card_add_rsa_alg(card, 3072, flags, 0);\n\t\tif (card_caps.max_rsa_key_length >= 4096)\n\t\t\t_sc_card_add_rsa_alg(card, 4096, flags, 0);\n\t}\n\n\t/* show ECC algorithms if the applet version of the inserted card supports them */\n\tif (card->version.fw_major >= 35) {\n\t\tint i;\n\n\t\tflags = SC_ALGORITHM_ECDSA_RAW | SC_ALGORITHM_ECDH_CDH_RAW | SC_ALGORITHM_ONBOARD_KEY_GEN;\n\t\tflags |= SC_ALGORITHM_ECDSA_HASH_NONE;\n\t\text_flags = SC_ALGORITHM_EXT_EC_NAMEDCURVE | SC_ALGORITHM_EXT_EC_UNCOMPRESES;\n\n\t\tfor (i=0; ec_curves[i].curve_name != NULL; i++) {\n\t\t\tif (card_caps.max_ecc_key_length >= ec_curves[i].size)\n\t\t\t\t_sc_card_add_ec_alg(card, ec_curves[i].size, flags, ext_flags, &ec_curves[i].curve_oid);\n\t\t}\n\t}\n\n\t/* show supported symmetric algorithms */\n\tflags = 0;\n\tif (card_caps.card_supported_features & MYEID_CARD_CAP_3DES) {\n\t\tif (card_caps.max_des_key_length >= 64)\n\t\t\t_sc_card_add_symmetric_alg(card, SC_ALGORITHM_DES, 64, flags);\n\t\tif (card_caps.max_des_key_length >= 128)\n\t\t\t_sc_card_add_symmetric_alg(card, SC_ALGORITHM_3DES, 128, flags);\n\t\tif (card_caps.max_des_key_length >= 192)\n\t\t\t_sc_card_add_symmetric_alg(card, SC_ALGORITHM_3DES, 192, flags);\n\t}\n\tif (card_caps.card_supported_features & MYEID_CARD_CAP_AES) {\n\t\tif (card_caps.max_aes_key_length >= 128)\n\t\t\t_sc_card_add_symmetric_alg(card, SC_ALGORITHM_AES, 128, flags);\n\t\tif (card_caps.max_aes_key_length >= 256)\n\t\t\t_sc_card_add_symmetric_alg(card, SC_ALGORITHM_AES, 256, flags);\n\t}\n\n\t/* State that we have an RNG */\n\tcard->caps |= SC_CARD_CAP_RNG | SC_CARD_CAP_ISO7816_PIN_INFO;\n\n\tif ((card->version.fw_major == 40 && card->version.fw_minor >= 10 )\n\t\t|| card->version.fw_major >= 41)\n\t\tcard->caps |= SC_CARD_CAP_WRAP_KEY | SC_CARD_CAP_UNWRAP_KEY\n\t\t\t   | SC_CARD_CAP_ONCARD_SESSION_OBJECTS;\n\n\tif (card->version.fw_major >= 45)\n\t\tpriv->cap_chaining = 1;\n\tif (card->version.fw_major >= 40)\n\t\tcard->max_recv_size = 256;\n\telse\n\t\tcard->max_recv_size = 255;\n\tcard->max_send_size = 255;\n\n\trv = SC_SUCCESS;\n\nerr:\n\tif (rv < 0) {\n\t\tfree(priv);\n\t\tcard->drv_data = old_drv_data;\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, rv);\n}\n\nstatic const struct sc_card_operations *iso_ops = NULL;\n\nstatic int acl_to_byte(const struct sc_acl_entry *e)\n{\n\tif (NULL == e)\n\t\treturn 0x00;\n\tswitch (e->method) {\n\tcase SC_AC_NONE:\n\t\treturn 0x00;\n\tcase SC_AC_CHV:\n\tcase SC_AC_TERM:\n\tcase SC_AC_AUT:\n\t\tif (e->key_ref == SC_AC_KEY_REF_NONE)\n\t\t\treturn 0x00;\n\t\tif (e->key_ref < 1 || e->key_ref > 14)\n\t\t\treturn 0x00;\n\t\treturn e->key_ref;\n\tcase SC_AC_NEVER:\n\t\treturn 0x0F;\n\t}\n\treturn 0x00;\n}\n\nstatic void add_acl_entry(struct sc_file *file, int op, u8 byte)\n{\n\tunsigned int method, key_ref = SC_AC_KEY_REF_NONE;\n\n\tswitch (byte)\n\t{\n\tcase 0:\n\t\tmethod = SC_AC_NONE;\n\t\tbreak;\n\tcase 15:\n\t\tmethod = SC_AC_NEVER;\n\t\tbreak;\n\tdefault:\n\t\tmethod = SC_AC_CHV;\n\t\tkey_ref = byte;\n\t\tbreak;\n\t}\n\tsc_file_add_acl_entry(file, op, method, key_ref);\n}\n\nstatic void parse_sec_attr(struct sc_file *file, const u8 *buf, size_t len)\n{\n\tint i;\n\tconst int df_ops[4] =\n\t\t{ SC_AC_OP_CREATE, SC_AC_OP_CREATE, SC_AC_OP_DELETE, -1 };\n\tconst int ef_ops[4] =\n\t\t{ SC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_DELETE, -1 };\n\tconst int key_ops[4] =\n\t\t{ SC_AC_OP_CRYPTO, SC_AC_OP_UPDATE, SC_AC_OP_DELETE, SC_AC_OP_GENERATE };\n\n\tconst int *ops;\n\n\tif (len < 2)\n\t\treturn;\n\n\tswitch (file->type) {\n\tcase SC_FILE_TYPE_WORKING_EF:\n\t\tops = ef_ops;\n\t\tbreak;\n\tcase SC_FILE_TYPE_INTERNAL_EF:\n\t\tops = key_ops;\n\t\tbreak;\n\tcase SC_FILE_TYPE_DF:\n\t\tops = df_ops;\n\t\tbreak;\n\tdefault:\n\t\tops = key_ops;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\tif (ops[i] == -1)\n\t\t\tcontinue;\n\t\tif ((i & 1) == 0)\n\t\t\tadd_acl_entry(file, ops[i], (u8)(buf[i / 2] >> 4));\n\t\telse\n\t\t\tadd_acl_entry(file, ops[i], (u8)(buf[i / 2] & 0x0F));\n\t}\n}\n\nstatic int myeid_select_file(struct sc_card *card, const struct sc_path *in_path,\n\t\tstruct sc_file **file)\n{\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tr = iso_ops->select_file(card, in_path, file);\n\n\tif (r == 0 && file != NULL && *file != NULL)\n\t\tparse_sec_attr(*file, (*file)->sec_attr, (*file)->sec_attr_len);\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_logout(struct sc_card *card)\n{\n\tsc_apdu_t apdu;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x2E, 0x00, 0x00 /*pin ref: 0x01-0x0E, 0=ALL*/);\n\tapdu.cla = 0;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tLOG_FUNC_RETURN(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n\nstatic int myeid_list_files(struct sc_card *card, u8 *buf, size_t buflen)\n{\n\tstruct sc_apdu apdu;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xCA, 0x01, 0xA1);\n\tapdu.resp = buf;\n\tapdu.resplen = buflen;\n\tapdu.le = buflen > 256 ? 256 : buflen;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (apdu.resplen == 0)\n\t\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\n\treturn apdu.resplen;\n}\n\nstatic int myeid_process_fci(struct sc_card *card, struct sc_file *file,\n\t\tconst u8 *buf, size_t buflen)\n{\n\tmyeid_private_data_t *priv = (myeid_private_data_t *) card->drv_data;\n\tsize_t taglen = 0;\n\tconst u8 *tag = NULL;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tr = iso_ops->process_fci(card, file, buf, buflen);\n\tif (r < 0)\n\t LOG_FUNC_RETURN(card->ctx, r);\n\n\tif(file->type == SC_FILE_EF_UNKNOWN)\n\t{\n\t\ttag = sc_asn1_find_tag(NULL, buf, buflen, 0x82, &taglen);\n\t\tif (tag != NULL && taglen > 0 && *tag == 17)\n\t\t{\n\t\t\tfile->type = SC_FILE_TYPE_INTERNAL_EF;\n\t\t}\n\t}\n\tif(file->sec_attr_len >= 3)\n\t{\n\t\tsc_log(card->ctx, \"id (%X) sec_attr (%X %X %X)\", file->id,\n\t\t\tfile->sec_attr[0],file->sec_attr[1],file->sec_attr[2]);\n\t}\n\n\tpriv->card_state = file->status;\n\tswitch (file->status) {\n\t\tcase SC_FILE_STATUS_CREATION:\n\t\t\tfile->acl_inactive = 1;\n\t\t\tsc_log(card->ctx, \"File id (%X) status SC_FILE_STATUS_CREATION\", file->id);\n\t\t\tbreak;\n\t\tcase SC_FILE_STATUS_ACTIVATED:\n\t\t\tsc_log(card->ctx, \"File id (%X) status SC_FILE_STATUS_ACTIVATED\", file->id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsc_log(card->ctx, \"File id (%X) unusual status (0x%X)\", file->id, file->status);\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, 0);\n}\n\nstatic int encode_file_structure(sc_card_t *card, const sc_file_t *file,\n\t\tu8 *buf, size_t *outlen)\n{\n\tconst sc_acl_entry_t *read, *update, *delete, *generate;\n\tsize_t i;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (!buf || !outlen || *outlen < 45)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\n\t/* PrivateKey\n\t * 0E0000019 6217 81020400 820111 83024B01 8603000000 85028000 8A0100 RESULT 6984\n\t *\t   6217 81020400 820111 83024B01 8603000000 85021000 8A0100 */\n\tmemset(buf, 0x0, *outlen);\n\n\tbuf[0] = 0x62;\n\tbuf[1] = 0x17;\n\t/* File size */\n\tbuf[2] = (SC_FILE_TYPE_WORKING_EF == file->type ? 0x80 : 0x81);\n\tbuf[3] = 0x02;\n\tbuf[4] = (file->size >> 8) & 0xFF;\n\tbuf[5] = file->size & 0xFF;\n\n\t/* File Description tag */\n\tbuf[6] = 0x82;\n\tbuf[7] = 0x01;\n\tbuf[8] = 0x01;\n\n\t/* File Identifier tag */\n\tbuf[9]  = 0x83;\n\tbuf[10] = 0x02;\n\tbuf[11] = (file->id >> 8) & 0xFF;\n\tbuf[12] = file->id & 0xFF;\n\n\t/* Security Attributes Tag */\n\tbuf[13] = 0x86;\n\tbuf[14] = 0x03;\n\tbuf[15] = 0xFF;\n\tbuf[16] = 0xFF;\n\tbuf[17] = 0xFF;\n\n\tif (file->sec_attr_len == 3 && file->sec_attr)   {\n\t\tbuf[15] = file->sec_attr[0];\n\t\tbuf[16] = file->sec_attr[1];\n\t\tbuf[17] = file->sec_attr[2];\n\n\t\tsc_log(card->ctx, \"id (%X), sec_attr %X %X %X\", file->id,\n\t\t\t\tfile->sec_attr[0],file->sec_attr[1],file->sec_attr[2]);\n\t}\n\telse   {\n\t\tdelete = sc_file_get_acl_entry(file, SC_AC_OP_DELETE);\n\n\t\tsc_log(card->ctx, \"id (%X), type (%X)\", file->id, file->type);\n\n\t\tswitch (file->type) {\n\t\tcase SC_FILE_TYPE_WORKING_EF:\n\n\t\t\tread = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\t\tupdate = sc_file_get_acl_entry(file, SC_AC_OP_UPDATE);\n\n\t\t\tbuf[15] = (acl_to_byte(read) << 4) | acl_to_byte(update);\n\t\t\tbuf[16] = (acl_to_byte(delete)<< 4) | 0x0F;\n\t\t\tbreak;\n\t\tcase SC_FILE_TYPE_INTERNAL_EF:\n\n\t\t\tread = sc_file_get_acl_entry(file, SC_AC_OP_CRYPTO);\n\t\t\tupdate = sc_file_get_acl_entry(file, SC_AC_OP_UPDATE);\n\t\t\tgenerate = sc_file_get_acl_entry(file, SC_AC_OP_GENERATE);\n\n\t\t\tbuf[15] = (acl_to_byte(read) << 4) | acl_to_byte(update);\n\t\t\tbuf[16] = (acl_to_byte(delete)<< 4) | acl_to_byte(generate);\n\t\t\tbreak;\n\t\tcase SC_FILE_TYPE_DF:\n\n\t\t\tupdate = sc_file_get_acl_entry(file, SC_AC_OP_CREATE);\n\n\t\t\tbuf[15] = (acl_to_byte(update) << 4) | acl_to_byte(update);\n\t\t\tbuf[16] = (acl_to_byte(delete) << 4) | 0x0F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Proprietary Information */\n\tbuf[18] = 0x85;\n\tbuf[19] = 0x02;\n\tif (file->prop_attr_len == 2 && file->prop_attr != NULL)\n\t    memcpy(&buf[20], file->prop_attr, 2);\n\telse\n\t{\n\t\tbuf[20] = 0x00;\n\t\tbuf[21] = 0x00;\n\t}\n\n\t/* Life Cycle Status tag */\n\tbuf[22] = 0x8A;\n\tbuf[23] = 0x01;\n\tbuf[24] = 0x0; /* RFU */\n\n\tswitch (file->type)\n\t{\n\tcase SC_FILE_TYPE_WORKING_EF:\n\t\tbreak;\n\n\tcase SC_FILE_TYPE_INTERNAL_EF:\n\t\tbuf[8] = file->ef_structure; /* RSA or EC */\n\t\tbreak;\n\n\tcase SC_FILE_TYPE_DF:\n\t\tbuf[8] = 0x38;\n\t\tif(file->namelen > 0 && file->namelen <= 16)\n\t\t{\n\t\t\tbuf[25] = 0x84;\n\t\t\tbuf[26] = (u8)file->namelen;\n\n\t\t\tfor(i=0;i < file->namelen;i++)\n\t\t\t\tbuf[i + 27] = file->name[i];\n\n\t\t\tbuf[1] = 27 + file->namelen;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsc_log(card->ctx, \"Unknown file type\\n\");\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\t*outlen = buf[1]+2;\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\nstatic int myeid_create_file(struct sc_card *card, struct sc_file *file)\n{\n\tsc_apdu_t apdu;\n\tu8 sbuf[45];\n\tsize_t buflen = sizeof sbuf;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = encode_file_structure(card, file, sbuf, &buflen);\n\tif (r)\n\t  LOG_FUNC_RETURN(card->ctx, r);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE0, 0x00, 0x00);\n\tapdu.data = sbuf;\n\tapdu.datalen = buflen;\n\tapdu.lc = buflen;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (apdu.sw1 == 0x6A && apdu.sw2 == 0x89)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_ALREADY_EXISTS);\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_delete_file(struct sc_card *card, const struct sc_path *path)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (path->type != SC_PATH_TYPE_FILE_ID && path->len != 2)\n\t{\n\t\tsc_log(card->ctx, \"File type has to be SC_PATH_TYPE_FILE_ID\\n\");\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tr = sc_select_file(card, path, NULL);\n\tLOG_TEST_RET(card->ctx, r, \"Unable to select file to be deleted\");\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0xE4, 0x00, 0x00);\n\tapdu.cla = 0xA0;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tLOG_FUNC_RETURN(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n\nstatic int myeid_pin_cmd(sc_card_t *card, struct sc_pin_cmd_data *data,\n\t\t\t int *tries_left)\n{\n\tmyeid_private_data_t *priv = (myeid_private_data_t *) card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_log(card->ctx, \"ref (%d), pin1 len(%d), pin2 len (%d)\\n\",\n\t\t\tdata->pin_reference, data->pin1.len, data->pin2.len);\n\n\tif(data->pin1.len > 8 || data->pin2.len > 8)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_PIN_LENGTH);\n\n\tdata->pin1.pad_length = data->pin2.pad_length = 8;\n\tdata->pin1.pad_char = data->pin2.pad_char = 0xFF;\n\n\tif (data->cmd == SC_PIN_CMD_VERIFY && priv->card_state == SC_FILE_STATUS_CREATION) {\n\t\tsc_log(card->ctx, \"Card in creation state, no need to verify\");\n\t\treturn SC_SUCCESS;\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, iso_ops->pin_cmd(card, data, tries_left));\n}\n\n#define IS_SYMETRIC_CRYPT(x) ((x) == SC_SEC_OPERATION_ENCRYPT_SYM || (x) == SC_SEC_OPERATION_DECRYPT_SYM)\n\nstatic int myeid_set_security_env_rsa(sc_card_t *card, const sc_security_env_t *env,\n\t\tint se_num)\n{\n\tsc_apdu_t apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 *p;\n\tint r;\n\tsize_t i;\n\tsc_path_t *target_file;\n\n\tassert(card != NULL && env != NULL);\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (env->flags & SC_SEC_ENV_KEY_REF_SYMMETRIC)\n\t{\n\t\tsc_log(card->ctx, \"symmetric keyref not supported.\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\tif (se_num > 0)\n\t{\n\t\tsc_log(card->ctx, \"restore security environment not supported.\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0, 0);\n\tswitch (env->operation)\n\t{\n\tcase SC_SEC_OPERATION_DECIPHER:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_SIGN:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB6;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_UNWRAP:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_WRAP:\n\t\tapdu.p1 = 0x81;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_ENCRYPT_SYM:\n\t\tapdu.p1 = 0x81;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_DECRYPT_SYM:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tapdu.le = 0;\n\tp = sbuf;\n\tif (env->flags & SC_SEC_ENV_ALG_REF_PRESENT)\n\t{\n\t\t*p++ = 0x80;\t/* algorithm reference */\n\t\t*p++ = 0x01;\n\t\t*p++ = env->algorithm_ref & 0xFF;\n\t}\n\tif (env->flags & SC_SEC_ENV_FILE_REF_PRESENT)\n\t{\n\t\t*p++ = 0x81;\n\t\t*p++ = 2;\n\t\tmemcpy(p, env->file_ref.value, 2);\n\t\tp += 2;\n\t}\n\t/* symmetric operations: we need to set the key reference */\n\tif (IS_SYMETRIC_CRYPT(env->operation)) {\n\t\t*p++ = 0x83;\n\t\t*p++ = 1;\n\t\t*p++ = 0;\n\t}\n\tif (env->flags & SC_SEC_ENV_KEY_REF_PRESENT && env->operation != SC_SEC_OPERATION_UNWRAP &&\n\t\t\tenv->operation != SC_SEC_OPERATION_WRAP &&\n\t\t\tenv->operation != SC_SEC_OPERATION_ENCRYPT_SYM &&\n\t\t\tenv->operation != SC_SEC_OPERATION_DECRYPT_SYM) {\n\t\t*p++ = 0x84;\n\t\t*p++ = 1;\n\t\t*p++ = 0;\n\t}\n\tfor (i = 0; i < SC_SEC_ENV_MAX_PARAMS; i++)\n\t    if (env->params[i].param_type == SC_SEC_ENV_PARAM_TARGET_FILE) {\n\t\t\ttarget_file = (sc_path_t*) env->params[i].value;\n\t\t\tif (env->params[i].value_len < sizeof(sc_path_t) || target_file->len != 2) {\n\t\t\t\tsc_log(card->ctx, \"wrong length of target file reference.\\n\");\n\t\t\t\treturn SC_ERROR_WRONG_LENGTH;\n\t\t\t}\n\t\t\t*p++ = 0x83;\n\t\t\t*p++ = 2;\n\t\t\tmemcpy(p, target_file->value, 2);\n\t\t\tp+= 2;\n\t\t\tbreak;\n\t    }\n\n\tr = 0;\n\tif (env->operation == SC_SEC_OPERATION_UNWRAP || env->operation == SC_SEC_OPERATION_WRAP ||\n\t\t\tIS_SYMETRIC_CRYPT(env->operation)) {\n\t\t/* add IV if present */\n\t\tfor (i = 0; i < SC_SEC_ENV_MAX_PARAMS; i++)\n\t\t\tif (env->params[i].param_type == SC_SEC_ENV_PARAM_IV) {\n\t\t\t\tr = 1;\n\t\t\t\t*p++ = 0x87;\n\t\t\t\t*p++ = (unsigned char) env->params[i].value_len;\n\t\t\t\tif (p + env->params[i].value_len >= sbuf + SC_MAX_APDU_BUFFER_SIZE) {\n\t\t\t\t\tsc_log(card->ctx, \"IV too long.\\n\");\n\t\t\t\t\treturn SC_ERROR_WRONG_LENGTH;\n\t\t\t\t}\n\t\t\t\tmemcpy(p, env->params[i].value, env->params[i].value_len);\n\t\t\t\tp+=(unsigned char) env->params[i].value_len;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\t/* for AES_ECB we need to reset the IV but we respect if the IV is already present */\n\tif (IS_SYMETRIC_CRYPT(env->operation) && env->algorithm == SC_ALGORITHM_AES &&\n\t\t\tenv->algorithm_flags == SC_ALGORITHM_AES_ECB && r == 0) {\n\t\t*p++ = 0x87;\n\t\t*p++ = 16;\n\t\tmemset(p, 0, 16);\n\t\tp += 16;\n\t}\n\n\tr = p - sbuf;\n\tapdu.lc = r;\n\tapdu.datalen = r;\n\tapdu.data = sbuf;\n\tapdu.resplen = 0;\n\tif (apdu.datalen != 0)\n\t{\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r)\n\t\t{\n\t\t\tsc_log(card->ctx,\n\t\t\t\t\"%s: APDU transmit failed\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tif (r)\n\t\t{\n\t\t\tsc_log(card->ctx,\n\t\t\t\t\"%s: Card returned error\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t}\nerr:\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_set_security_env_ec(sc_card_t *card, const sc_security_env_t *env,\n\t\tint se_num)\n{\n\tsc_apdu_t apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 *p;\n\tint r;\n\n\tassert(card != NULL && env != NULL);\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (env->flags & SC_SEC_ENV_KEY_REF_SYMMETRIC)\n\t{\n\t\tsc_log(card->ctx, \"symmetric keyref not supported.\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\tif (se_num > 0)\n\t{\n\t\tsc_log(card->ctx, \"restore security environment not supported.\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0, 0);\n\tswitch (env->operation)\n\t{\n\tcase SC_SEC_OPERATION_DECIPHER:\n\t\tsc_log(card->ctx, \"Decipher operation is not supported with EC keys.\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_SIGN:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB6;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_DERIVE:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xA4;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tapdu.le = 0;\n\tp = sbuf;\n\tif (env->flags & SC_SEC_ENV_ALG_REF_PRESENT)\n\t{\n\t\t*p++ = 0x80;\t/* algorithm reference */\n\t\t*p++ = 0x01;\n\t\t*p++ = env->algorithm_ref & 0xFF;\n\t}\n\tif (env->flags & SC_SEC_ENV_FILE_REF_PRESENT)\n\t{\n\t\t*p++ = 0x81;\n\t\t*p++ = 0x02;\n\t\tmemcpy(p, env->file_ref.value, 2);\n\t\tp += 2;\n\t}\n\tif (env->flags & SC_SEC_ENV_KEY_REF_PRESENT)\n\t{\n\t\t*p++ = 0x84;\n\t\t*p++ = 1;\n\t\t*p++ = 0;\n\t}\n\tr = p - sbuf;\n\tapdu.lc = r;\n\tapdu.datalen = r;\n\tapdu.data = sbuf;\n\tapdu.resplen = 0;\n\tif (apdu.datalen != 0)\n\t{\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r)\n\t\t{\n\t\t\tsc_log(card->ctx,\n\t\t\t\t\"%s: APDU transmit failed\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tif (r)\n\t\t{\n\t\t\tsc_log(card->ctx,\n\t\t\t\t\"%s: Card returned error\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t}\nerr:\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_set_security_env(struct sc_card *card,\n\t\tconst struct sc_security_env *env, int se_num)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tmyeid_private_data_t* priv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tpriv = (myeid_private_data_t*) card->drv_data;\n\t/* store security environment to differentiate between ECDH and RSA in decipher - Hannu*/\n\tpriv->sec_env = env;\n\n\t/* for symmetric operation save algo and algo flags */\n\tpriv->algorithm_flags = env->algorithm_flags;\n\tpriv->algorithm = env->algorithm;\n\n\tif (env->flags & SC_SEC_ENV_ALG_PRESENT)\n\t{\n\t\tsc_security_env_t tmp;\n\n\t\ttmp = *env;\n\t\ttmp.flags &= ~SC_SEC_ENV_ALG_PRESENT;\n\t\ttmp.flags |= SC_SEC_ENV_ALG_REF_PRESENT;\n\n\t\tif (tmp.algorithm == SC_ALGORITHM_RSA)\n\t\t{\n\t\t\tif (tmp.operation == SC_SEC_OPERATION_UNWRAP || tmp.operation == SC_SEC_OPERATION_WRAP)\n\t\t\t{\n\t\t\t    tmp.algorithm_ref = 0x0A;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmp.algorithm_ref = 0x00;\n\t\t\t\t/* potential FIXME: return an error, if an unsupported\n\t\t\t\t* pad or hash was requested, although this shouldn't happen */\n\t\t\t\tif (env->algorithm_flags & SC_ALGORITHM_RSA_PAD_PKCS1)\n\t\t\t\t\ttmp.algorithm_ref = 0x02;\n\t\t\t\tif (tmp.algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA1)\n\t\t\t\t\ttmp.algorithm_ref |= 0x10;\n\t\t\t}\n\n\t\t\treturn myeid_set_security_env_rsa(card, &tmp, se_num);\n\t\t}\n\t\telse if (tmp.algorithm == SC_ALGORITHM_EC)\n\t\t{\n\t\t\ttmp.algorithm_ref = 0x04;\n\t\t\ttmp.algorithm_flags = 0;\n\t\t\treturn myeid_set_security_env_ec(card, &tmp, se_num);\n\t\t}\n\t\telse if (tmp.algorithm == SC_ALGORITHM_AES)\n\t\t{\n\t\t\tif (tmp.operation == SC_SEC_OPERATION_UNWRAP || tmp.operation == SC_SEC_OPERATION_WRAP)\n\t\t\t{\n\t\t\t\ttmp.algorithm_ref = 0x0A;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmp.algorithm_ref = 0x00;\n\t\t\t}\n\n\t\t\tif ((tmp.algorithm_flags & SC_ALGORITHM_AES_CBC_PAD) == SC_ALGORITHM_AES_CBC_PAD)\n\t\t\t\ttmp.algorithm_ref |= 0x80;\t\t/* set PKCS#7 padding */\n\t\t\t/* Tag 0x80 algorithm_ref - value 0x80 or 0x8A is working only for UNWRAP/WRAP\n\t\t\t * AES is supported from version 4.0 but without pkcs#7 padding.\n\t\t\t * For SC_SEC_OPERATION_ENCRYPT_SYM and SC_SEC_OPERATION_DECRYPT_SYM we running\n\t\t\t * PKCS#7 in software, here we fix the algorithm_ref variable.\n\t\t\t */\n\t\t\tif (IS_SYMETRIC_CRYPT(env->operation))\n\t\t\t\ttmp.algorithm_ref &= ~0x80; /* do not handle padding in card */\n\n\t\t\t/* from this point, there's no difference to RSA SE */\n\t\t\treturn myeid_set_security_env_rsa(card, &tmp, se_num);\n\t\t}\n\t\telse\n\t\t{\n\n\t\t\tsc_log(ctx, \"Unsupported algorithm.\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t}\n\treturn myeid_set_security_env_rsa(card, env, se_num);\n}\n\n\nstatic int\nmyeid_convert_ec_signature(struct sc_context *ctx, size_t s_len, unsigned char *data, size_t datalen)\n{\n\tunsigned char *buf;\n\tsize_t buflen;\n\tint r;\n\tsize_t len_size = 1;\n\tsize_t sig_len = 0;\n\n\tassert(data && datalen && datalen > 3);\n\n\t/*\n\t *\tWhen validating the signature data, we have to consider that length of the signature\n\t *\tcan be encoded in either one or two bytes depending on key size. With 521 bit keys\n\t *\tlength of the structure takes two bytes.\n\t */\n\n\tif (*data != 0x30)\n\t\treturn SC_ERROR_INVALID_DATA;\n\n\tif ((*(data + 1) & 0x80) == 0x80)\n\t\tlen_size += *(data + 1) & 0x7F;\n\n\tif (len_size == 1)\n\t    sig_len = *(data + 1);\n\telse if (len_size == 2)\n\t    sig_len = *(data + 2);\n\telse if (len_size == 3)\n\t{\n\t    sig_len = *(data + 2) | (*data + 3) << 8;\n\t}\n\telse\n\t    return SC_ERROR_INVALID_DATA;\n\n\tif (*(data + 1 + len_size) != 0x02)\t\t/* Verify that it is an INTEGER */\n\n\tif (sig_len != (datalen - len_size - 1))\t/* validate size of the DER structure */\n\t    return SC_ERROR_INVALID_DATA;\n\n\t/* test&fail early */\n\tbuflen = (s_len + 7)/8*2;\n\tif (buflen > datalen)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);\n\n\tbuf = calloc(1, buflen);\n\tif (!buf)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tr = sc_asn1_sig_value_sequence_to_rs(ctx, data, datalen, buf, buflen);\n\tif (r < 0) {\n\t\tfree(buf);\n\t\tsc_log(ctx, \"Failed to convert Sig-Value to the raw RS format\");\n\t\treturn r;\n\t}\n\n\tmemmove(data, buf, buflen);\n\tfree(buf);\n\treturn buflen;\n}\n/* MyEID cards before version 4.5 do not support RAW RSA signature for 2048 bit RSA keys.\n * (Source: MyEID reference manual 2.1.4)\n *\n * This function uses decipher operation for calculating RAW 2048 bit signature. */\nstatic int\nmyeid_compute_raw_2048_signature(struct sc_card *card, const u8 * data, size_t datalen,\n\t\tu8 * out, size_t outlen)\n{\n\tint r;\n\tstruct sc_context *ctx;\n\tstruct myeid_private_data *priv;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tsc_security_env_t env;\n\n\tctx = card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\n\tpriv = (myeid_private_data_t *) card->drv_data;\n\n/* security env change - use DECIPHER operation */\n\tmemcpy(&env, priv->sec_env, sizeof(sc_security_env_t));\n\tenv.flags |= SC_SEC_ENV_ALG_REF_PRESENT;\n\tenv.flags |= SC_SEC_ENV_FILE_REF_PRESENT;\n\tenv.flags |= SC_SEC_ENV_KEY_REF_PRESENT;\n\tenv.operation = SC_SEC_OPERATION_DECIPHER;\n\tmyeid_set_security_env_rsa(card, &env, 0);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = 0;\t/* there is no response to 1st part of data */\n\n/* prepare 1st part of data */\n\tsbuf[0] = 0x81;\n\tmemcpy(sbuf + 1, data, datalen / 2);\n\tapdu.lc = datalen / 2 + 1;\n\tapdu.datalen = apdu.lc;\n\tapdu.data = sbuf;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {\n/* prepare 2nd part of data */\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = datalen;\n\t\tsbuf[0] = 0x82;\n\t\tmemcpy(sbuf + 1, data + datalen / 2, datalen / 2);\n\t\tapdu.lc = datalen / 2 + 1;\n\t\tapdu.datalen = apdu.lc;\n\t\tapdu.data = sbuf;\n\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\t\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {\n\t\t\tint len = apdu.resplen > outlen ? outlen : apdu.resplen;\n\t\t\tmemcpy(out, apdu.resp, len);\n\t\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t\t}\n\t}\n\tLOG_FUNC_RETURN(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n\nstatic int\nmyeid_compute_signature(struct sc_card *card, const u8 * data, size_t datalen,\n\t\tu8 * out, size_t outlen)\n{\n\tstruct sc_context *ctx;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[MYEID_MAX_EXT_APDU_BUFFER_SIZE];\n\tu8 sbuf[MYEID_MAX_EXT_APDU_BUFFER_SIZE];\n\tstruct myeid_private_data* priv;\n\tint r;\n\tsize_t field_length = 0;\n\tsize_t pad_chars = 0;\n\n\n\tassert(card != NULL && data != NULL && out != NULL);\n\tctx = card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\n\tpriv = (myeid_private_data_t*) card->drv_data;\n\tsc_log(ctx, \"key type %i, key length %i\", priv->sec_env->algorithm, priv->sec_env->algorithm_ref);\n\n\tif (priv->sec_env->algorithm == SC_ALGORITHM_EC ) {\n\n\t    field_length = priv->sec_env->algorithm_ref;\n\n\t    /* pad with zeros if needed */\n\t\tif (datalen < (field_length + 7) / 8 ) {\n\t\t\tpad_chars = ((field_length + 7) / 8) - datalen;\n\n\t\t\tmemset(sbuf, 0, pad_chars);\n\t\t}\n\t}\n\n\tif ((datalen + pad_chars) > sizeof(sbuf))\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tif (priv->sec_env->algorithm == SC_ALGORITHM_RSA && datalen == 256 && !priv->cap_chaining)\n\t\treturn myeid_compute_raw_2048_signature(card, data, datalen, out, outlen);\n\n\t/* INS: 0x2A  PERFORM SECURITY OPERATION\n\t\t* P1:  0x9E  Resp: Digital Signature\n\t\t* P2:  0x9A  Cmd: Input for Digital Signature */\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x9E, 0x9A);\n\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = 256;\n\tmemcpy(sbuf + pad_chars, data, datalen);\n\tapdu.lc = datalen + pad_chars;\n\tapdu.datalen = datalen + pad_chars;\n\n\tapdu.data = sbuf;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, r, \"compute_signature failed\");\n\n\tif (priv->sec_env->algorithm == SC_ALGORITHM_EC) {\n\t\tr = myeid_convert_ec_signature(ctx, priv->sec_env->algorithm_ref, apdu.resp, apdu.resplen);\n\t\tLOG_TEST_RET(ctx, r, \"compute_signature convert signature failed\");\n\t\tapdu.resplen = r;\n\t}\n\n\tif (apdu.resplen > outlen)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);\n\n\tmemcpy(out, apdu.resp, apdu.resplen);\n\tLOG_FUNC_RETURN(ctx, apdu.resplen);\n}\n\n\n/* takes other party's public key as input, performs ECDH key derivation and returns the shared secret in [out]. */\nint myeid_ecdh_derive(struct sc_card *card, const u8* pubkey, size_t pubkey_len, u8* out, size_t outlen)\n{\n\n\t/* MyEID uses GENERAL AUTHENTICATE ISO command for ECDH */\n\n\tstruct sc_apdu apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\n\tint r;\n\tsize_t ext_len_bytes;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x86, 0x00, 0x00);\n\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\n\t/* Fill in \"Data objects in dynamic authentication template\" (tag 0x7C) structure\n\t*\n\t* TODO: encode the structure using OpenSC's ASN1-functions.\n\t*\n\t*  Size of the structure depends on key length. With 521 bit keys two bytes are needed for defining length of a point.\n\t*/\n\n\tsbuf[0] = 0x7C;\n\text_len_bytes = 0;\n\n\tif (pubkey_len > 127)\n\t{\n\t\tsbuf[1] = 0x81;\n\t\tsbuf[2] = (u8) (pubkey_len + 3);\n\t\tsbuf[3] = 0x85;\n\t\tsbuf[4] = 0x81;\n\t\tsbuf[5] = (u8) (pubkey_len);\n\t\text_len_bytes = 2;\n\t}\n\telse\n\t{\n\t\tsbuf[1] = pubkey_len + 2;\n\t\tsbuf[2] = 0x85;\n\t\tsbuf[3] = pubkey_len;\n\t}\n\n\tmemcpy(&sbuf[4 + ext_len_bytes], pubkey, pubkey_len);\n\n\tapdu.lc = pubkey_len + 4 + ext_len_bytes;\n\tapdu.le = pubkey_len / 2;\n\tapdu.datalen = apdu.lc;\n\tapdu.data = sbuf;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed.\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"ECDH operation failed - GENERAL AUTHENTICATE returned error.\");\n\n\tif (outlen < apdu.resplen)\n\t{\n\t\tr = SC_ERROR_BUFFER_TOO_SMALL;\n\t\tLOG_TEST_RET(card->ctx, r, \"Buffer too small to hold shared secret.\");\n\t}\n\n\tmemcpy(out, rbuf, apdu.resplen);\n\n\tLOG_FUNC_RETURN(card->ctx, apdu.resplen);\n}\n\nstatic int myeid_transmit_decipher_pi_split(struct sc_card *card, struct sc_apdu *apdu, u8 *sbuf)\n{\n\t/* MyEID before 4.5.x does not support APDU chaining. The payload\n\t * is split to two regular APDUs and Padding Indicator field is used to\n\t * describe which slice it is. */\n\tsize_t crgram_len = apdu->lc - 1;\n\tsize_t crgram_half = crgram_len / 2;\n\tsize_t resplen = apdu->resplen;\n\tunsigned char *resp = apdu->resp;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t/* Send 1st part, no response */\n\tapdu->cse = SC_APDU_CASE_3_SHORT;\n\tapdu->data = &sbuf[0];\n\tapdu->datalen = apdu->lc = crgram_half + 1;\n\tapdu->resp = 0;\n\tapdu->resplen = 0;\n\tapdu->le = 0;\n\tsbuf[0] = 0x81;\t\t\t/* Padding Indicator, 0x81 = First half */\n\n\tr = sc_transmit_apdu(card, apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (apdu->sw1 != 0x90 || apdu->sw2 != 0x00)\n\t\treturn 0;\n\n\t/* Send 2nd part, expect response */\n\tapdu->cse = resplen ? SC_APDU_CASE_4_SHORT : SC_APDU_CASE_3_SHORT;\n\tapdu->data = &sbuf[crgram_half];\n\tapdu->datalen = apdu->lc = crgram_len - crgram_half + 1;\n\tapdu->resp = resp;\n\tapdu->resplen = resplen;\n\tapdu->le = resplen ? MIN(card->max_recv_size, crgram_len) : 0;\n\tsbuf[crgram_half] = 0x82;\t/* Padding Indicator, 0x82 = Second half */\n\n\tr = sc_transmit_apdu(card, apdu);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_transmit_decipher(struct sc_card *card, u8 p1, u8 p2,\n\t\tconst u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tmyeid_private_data_t *priv = card->drv_data;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_EXT_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_EXT_APDU_BUFFER_SIZE];\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t/* INS: 0x2A  PERFORM SECURITY OPERATION\n\t * P1:  0x00  Resp: No response (unwrapping)\n\t * P1:  0x80  Resp: Plain value\n\t * P2:  0x84  Cmd: Cryptogram (no padding byte)\n\t * P2:  0x86  Cmd: Padding indicator byte followed by cryptogram */\n\tsc_format_apdu(card, &apdu, p1 ? SC_APDU_CASE_4_SHORT : SC_APDU_CASE_3_SHORT, 0x2A, p1, p2);\n\tif (p2 == 0x86) {\n\t\tif (crgram_len+1 > sizeof(sbuf))\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t\tsbuf[0] = 0; /* Padding indicator: 0x00 = No further indication */\n\t\tmemcpy(sbuf + 1, crgram, crgram_len);\n\t\tapdu.data = sbuf;\n\t\tapdu.datalen = apdu.lc = crgram_len + 1;\n\t} else {\n\t\tapdu.data = crgram;\n\t\tapdu.datalen = apdu.lc = crgram_len;\n\t}\n\tif (p1 != 0x00) {\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = MIN(card->max_recv_size, crgram_len);\n\t}\n\n\tif (p2 == 0x86 && crgram_len == 256 && priv && !priv->cap_chaining) {\n\t\tr = myeid_transmit_decipher_pi_split(card, &apdu, sbuf);\n\t} else {\n\t\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t}\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"DECIPHER returned error\");\n\n\tif (out && outlen) {\n\t\toutlen = MIN(apdu.resplen, outlen);\n\t\tmemcpy(out, apdu.resp, outlen);\n\t} else {\n\t\toutlen = 0;\n\t}\n\tLOG_FUNC_RETURN(card->ctx, outlen);\n}\n\nstatic int myeid_decipher(struct sc_card *card, const u8 * crgram,\n\t\tsize_t crgram_len, u8 * out, size_t outlen)\n{\n\tint r;\n\tmyeid_private_data_t* priv;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tassert(card != NULL && crgram != NULL && out != NULL);\n\n\tpriv = (myeid_private_data_t*) card->drv_data;\n\n\tif (priv->sec_env && priv->sec_env->algorithm == SC_ALGORITHM_EC\n\t\t&& priv->sec_env->operation == SC_SEC_OPERATION_DERIVE\n\t\t&& priv->sec_env->algorithm_flags & SC_ALGORITHM_ECDH_CDH_RAW)\n\t{\n\t\tr = myeid_ecdh_derive(card, crgram, crgram_len, out, outlen);\n\t\tpriv->sec_env = NULL; /* clear after operation */\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\n\tr = myeid_transmit_decipher(card, 0x80, 0x86, crgram, crgram_len, out, outlen);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n\nstatic int myeid_wrap_key(struct sc_card *card, u8 *out, size_t outlen)\n{\n\tstruct sc_context *ctx;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint r;\n\n\tassert(card != NULL);\n\tctx = card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\n\t/* INS: 0x2A  PERFORM SECURITY OPERATION\n\t   P1:  0x84  Resp: Return a cryptogram\n\t * P2:  0x00  The data field is absent */\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0x2A, 0x84, 0x00);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = sizeof(rbuf) <= 256 ? sizeof(rbuf) : 256;\n\tapdu.lc = 0;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, r, \"wrap key failed\");\n\n\tif (apdu.resplen <= outlen && out != NULL)\n\t\tmemcpy(out, apdu.resp, apdu.resplen);\n\n\tLOG_FUNC_RETURN(ctx, apdu.resplen);\n}\n\nstatic int myeid_unwrap_key(struct sc_card *card, const u8 *crgram, size_t crgram_len)\n{\n\tmyeid_private_data_t* priv;\n\tu8 p2 = 0x86; /* init P2 for asymmetric crypto by default.*/\n\tint r;\n\n\tif (card == NULL || crgram == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tpriv = card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (crgram_len > MYEID_MAX_RSA_KEY_LEN / 8)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tif (priv && priv->sec_env)\n\t{\n\t\tif (priv->sec_env->algorithm == SC_ALGORITHM_AES ||\n\t\t\tpriv->sec_env->algorithm == SC_ALGORITHM_3DES ||\n\t\t\tpriv->sec_env->algorithm == SC_ALGORITHM_DES)\n\t\t\t\tp2 = 0x84;\n\t}\n\n\tif (p2 == 0x84 && crgram_len > MYEID_MAX_APDU_DATA_LEN)\n\t\tLOG_TEST_RET(card->ctx, SC_ERROR_WRONG_LENGTH, \"Unwrapping symmetric data longer that 255 bytes is not supported\\n\");\n\n\t/* INS: 0x2A  PERFORM SECURITY OPERATION\n\t * P1:  0x00  Do not expect response - the deciphered data will be placed into the target key EF.\n\t * P2:  0x86  Cmd: Padding indicator byte followed by cryptogram\n\t * P2:  0x84  Cmd: AES/3DES Cryptogram (plain value encoded in BER-TLV DO, but not including SM DOs) */\n\tr = myeid_transmit_decipher(card, 0x00, p2, crgram, crgram_len, 0, 0);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n\n/* Write internal data, e.g. add default pin-records to pin */\nstatic int myeid_putdata(struct sc_card *card, struct sc_cardctl_myeid_data_obj* data_obj)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tmemset(&apdu, 0, sizeof(apdu));\n\tapdu.cse     = SC_APDU_CASE_3_SHORT;\n\tapdu.cla     = 0x00;\n\tapdu.ins     = 0xDA;\n\tapdu.p1      = data_obj->P1;\n\tapdu.p2      = data_obj->P2;\n\tapdu.lc      = data_obj->DataLen;\n\tapdu.datalen = data_obj->DataLen;\n\tapdu.data    = data_obj->Data;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"PUT_DATA returned error\");\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/* Read internal data, e.g. get RSA public key */\nstatic int myeid_getdata(struct sc_card *card, struct sc_cardctl_myeid_data_obj* data_obj)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tmemset(&apdu, 0, sizeof(apdu));\n\tapdu.cse     = SC_APDU_CASE_2_SHORT;\n\tapdu.cla     = 0x00;\n\tapdu.ins     = 0xCA;\t\t/* GET DATA */\n\tapdu.p1      = data_obj->P1;\n\tapdu.p2      = data_obj->P2;\n\tapdu.lc      = 0;\n\tapdu.datalen = 0;\n\tapdu.data    = data_obj->Data;\n\n\tapdu.le      = card->max_recv_size;\n\tapdu.resp    = data_obj->Data;\n\tapdu.resplen = data_obj->DataLen;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"GET_DATA returned error\");\n\n\tif (apdu.resplen > data_obj->DataLen)\n\t\tr = SC_ERROR_WRONG_LENGTH;\n\telse\n\t\tdata_obj->DataLen = apdu.resplen;\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_loadkey(sc_card_t *card, unsigned mode, u8* value, int value_len)\n{\n\tmyeid_private_data_t *priv = (myeid_private_data_t *) card->drv_data;\n\tsc_apdu_t apdu;\n\tu8 sbuf[MYEID_MAX_EXT_APDU_BUFFER_SIZE];\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (value_len == 0 || value == NULL)\n\t\treturn 0;\n\n\tif (mode == LOAD_KEY_MODULUS && value_len == 256 && !priv->cap_chaining)\n\t{\n\t\tmode = 0x88;\n\t\tmemset(&apdu, 0, sizeof(apdu));\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xDA, 0x01, mode);\n\n\t\tapdu.cla     = 0x00;\n\t\tapdu.data    = value;\n\t\tapdu.datalen = 128;\n\t\tapdu.lc\t     = 128;\n\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(card->ctx, r, \"LOAD KEY returned error\");\n\n\t\tmode = 0x89;\n\t\tvalue += 128;\n\t\tvalue_len -= 128;\n\t}\n\telse if ((mode & 0xff00) == 0 && mode != LOAD_KEY_PUBLIC_EXPONENT &&\n\t\t value[0] != 0x00)\n\t{\n\t\t/* RSA components needing leading zero byte */\n\t\tsbuf[0] = 0x0;\n\t\tmemcpy(&sbuf[1], value, value_len);\n\t\tvalue = sbuf;\n\t\tvalue_len ++;\n\t}\n\n\tmemset(&apdu, 0, sizeof(apdu));\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xDA, 0x01, mode & 0xFF);\n\tapdu.flags   = SC_APDU_FLAGS_CHAINING;\n\tapdu.cla     = 0x00;\n\tapdu.data    = value;\n\tapdu.datalen = value_len;\n\tapdu.lc\t     = value_len;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/* Generate or store a key */\nstatic int myeid_generate_store_key(struct sc_card *card,\n\tstruct sc_cardctl_myeid_gen_store_key_info *data)\n{\n\tstruct\tsc_apdu apdu;\n\tu8\tsbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint\tr=0,len;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\t/* Setup key-generation parameters */\n\tif (data->op_type == OP_TYPE_GENERATE)\n\t{\n\t\tlen = 0;\n\t\tmemset(&apdu, 0, sizeof(apdu));\n\n\t\tif(data->key_type == SC_CARDCTL_MYEID_KEY_RSA)\n\t\t{\n\t\t    sbuf[len++] = 0x30;\n\t\t    sbuf[len++] = 0x05;\n\t\t    sbuf[len++] = 0x81;\n\t\t    sbuf[len++] = data->pubexp_len;\n\n\t\t    memcpy(sbuf + len, data->pubexp, data->pubexp_len);\n\t\t    len += data->pubexp_len;\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46, 0x00, 0x00);\n\t\t\tapdu.data    = sbuf;\n\t\t}\n\t\telse if(data->key_type == SC_CARDCTL_MYEID_KEY_EC) {\n\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x46, 0x00, 0x00);\n\n\t\t\tapdu.data    = NULL;\n\t\t\tapdu.resp\t = sbuf;\n\t\t\tapdu.resplen = 0x00;\n\t\t\tapdu.le\t\t = 0x00;\n\t\t}\n\n\t\tapdu.cla     = 0x00;\n\t\tapdu.datalen = len;\n\t\tapdu.lc\t     = len;\n\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(card->ctx, r, \"GENERATE_KEY returned error\");\n\t}\n\telse\n\t{\n\t\tif(data->key_type == SC_CARDCTL_MYEID_KEY_RSA)\n\t\t{\n\t\t\tif((r=myeid_loadkey(card, LOAD_KEY_PRIME_P,\n\t\t\t\tdata->primep, data->primep_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_PRIME_Q,\n\t\t\t\tdata->primeq, data->primeq_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_DP1,\n\t\t\t\tdata->dp1, data->dp1_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_DQ1,\n\t\t\t\tdata->dq1, data->dq1_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_INVQ,\n\t\t\t\tdata->invq, data->invq_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_MODULUS,\n\t\t\t\tdata->mod, data->key_len_bits)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_PUBLIC_EXPONENT,\n\t\t\t\tdata->pubexp, data->pubexp_len)) >= 0)\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t}\n\t\telse if(data->key_type == SC_CARDCTL_MYEID_KEY_EC) {\n\t\t\tif((r = myeid_loadkey(card, LOAD_KEY_EC_PRIVATE, data->d,\n\t\t\t\t\tdata->d_len)) >= 0 &&\n\t\t\t\t(r = myeid_loadkey(card, LOAD_KEY_EC_PUBLIC, data->ecpublic_point,\n\t\t\t\t\tdata->ecpublic_point_len)) >= 0)\n\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t}\n\t\telse if(data->key_type == SC_CARDCTL_MYEID_KEY_AES ||\n\t\t\tdata->key_type == SC_CARDCTL_MYEID_KEY_DES) {\n\t\t\tif((r = myeid_loadkey(card, LOAD_KEY_SYMMETRIC, data->d,\n\t\t\t\t\tdata->d_len)) >= 0)\n\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_activate_card(struct sc_card *card)\n{\n\tint r;\n\tu8 sbuf[] =\"\\xA0\\x00\\x00\\x00\\x63\\x50\\x4B\\x43\\x53\\x2D\\x31\\x35\";\n\tsc_apdu_t apdu;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x44, 0x04, 0x00);\n\tapdu.cla     = 0x00;\n\tapdu.data    = sbuf;\n\tapdu.datalen = 0x0C;\n\tapdu.lc\t     = 0x0C;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"ACTIVATE_APPLET returned error\");\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_get_info(struct sc_card *card, u8 *rbuf, size_t buflen)\n{\n\tsc_apdu_t apdu;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xca, 0x01, 0xA0);\n\tapdu.resp    = rbuf;\n\tapdu.resplen = buflen;\n\tapdu.le      = buflen;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r,  \"APDU transmit failed\");\n\n\tif (apdu.sw1 != 0x90 || apdu.sw2 != 0x00)\n\t\treturn SC_ERROR_INTERNAL;\n\n\tif (apdu.resplen != 20)\n\t{\n\t\tsc_log(card->ctx, \"Unexpected response to GET DATA (applet info)\");\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\t/* store the applet version */\n\tcard->version.fw_major = rbuf[5] * 10 + rbuf[6];\n\tcard->version.fw_minor = rbuf[7];\n\t/* add version to name */\n\tsnprintf(card_name_buf, sizeof(card_name_buf),\n\t\t\t\"%s %d.%d.%d\", card->name, rbuf[5], rbuf[6], rbuf[7]);\n\tcard->name = card_name_buf;\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_get_serialnr(sc_card_t *card, sc_serial_number_t *serial)\n{\n\tint r;\n\tu8  rbuf[256];\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t/* if number cached, get it\n\tif(card->serialnr.value) {\n\t\tmemcpy(serial, &card->serialnr, sizeof(*serial));\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}*/\n\n\t/* get number from card */\n\tr = myeid_get_info(card, rbuf, sizeof(rbuf));\n\tLOG_TEST_RET(card->ctx, r,  \"Get applet info failed\");\n\n\t/* cache serial number */\n\tmemcpy(card->serialnr.value, &rbuf[8], 10);\n\tcard->serialnr.len = 10;\n\n\t/* copy and return serial number */\n\tmemcpy(serial, &card->serialnr, sizeof(*serial));\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int\nmyeid_get_change_counter(sc_card_t *card, size_t *change_counter)\n{\n\tint r;\n\tu8 rbuf[256];\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t/* get change counter from card */\n\tr = myeid_get_info(card, rbuf, sizeof(rbuf));\n\tLOG_TEST_RET(card->ctx, r, \"Get applet info failed\");\n\n\t*change_counter = rbuf[18] * 256 + rbuf[19];\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/*\n Get information of features that the card supports. MyEID 4.x cards are available on different\n hardware and maximum key sizes cannot be determined simply from the version number anymore.\n */\nstatic int myeid_get_card_caps(struct sc_card *card, myeid_card_caps_t* card_caps)\n{\n\tsc_apdu_t apdu;\n\tint r;\n\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xca, 0x01, 0xAA);\n\tapdu.resp    = rbuf;\n\tapdu.resplen = sizeof(myeid_card_caps_t);\n\tapdu.le      = sizeof(myeid_card_caps_t);\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r,  \"APDU transmit failed\");\n\n\tif (apdu.sw1 != 0x90 || apdu.sw2 != 0x00)\n\t\treturn SC_ERROR_INTERNAL;\n\n\tif (apdu.resplen < 11) {\n\t\tsc_log(card->ctx, \"Unexpected response to GET DATA (MyEIC card capabilities)\");\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\tcard_caps->card_caps_ver = rbuf[0];\n\t/* the card returns big endian values */\n\tcard_caps->card_supported_features = (unsigned short) rbuf[1] << 8 | rbuf[2];\n\tcard_caps->max_rsa_key_length = (unsigned short) rbuf[3] << 8 | rbuf[4];\n\tcard_caps->max_des_key_length = (unsigned short) rbuf[5] << 8 | rbuf[6];\n\tcard_caps->max_aes_key_length = (unsigned short) rbuf[7] << 8 | rbuf[8];\n\tcard_caps->max_ecc_key_length = (unsigned short) rbuf[9] << 8 | rbuf[10];\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_card_ctl(struct sc_card *card, unsigned long cmd, void *ptr)\n{\n\tint r = SC_ERROR_NOT_SUPPORTED;\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tswitch(cmd) {\n\tcase SC_CARDCTL_MYEID_PUTDATA:\n\t\tr = myeid_putdata(card,\n\t\t\t(struct sc_cardctl_myeid_data_obj*) ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_MYEID_GETDATA:\n\t\tr = myeid_getdata(card,\n\t\t\t(struct sc_cardctl_myeid_data_obj*) ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_MYEID_GENERATE_STORE_KEY:\n\t\tr = myeid_generate_store_key(card,\n\t\t\t(struct sc_cardctl_myeid_gen_store_key_info *) ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_MYEID_ACTIVATE_CARD:\n\t\tr = myeid_activate_card(card);\n\t\tbreak;\n\tcase SC_CARDCTL_GET_SERIALNR:\n\t\tr = myeid_get_serialnr(card, (sc_serial_number_t *)ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_GET_CHANGE_COUNTER:\n\t\tr = myeid_get_change_counter(card, (size_t *)ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_GET_DEFAULT_KEY:\n\tcase SC_CARDCTL_LIFECYCLE_SET:\n\tcase SC_CARDCTL_LIFECYCLE_GET:\n\t\tbreak;\n\t}\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int myeid_finish(sc_card_t * card)\n{\n\tstruct myeid_private_data *priv = (struct myeid_private_data *) card->drv_data;\n\tfree(priv);\n\treturn SC_SUCCESS;\n}\n\nstatic int\nmyeid_enc_dec_sym(struct sc_card *card, const u8 *data, size_t datalen,\n\t\tu8 *out, size_t *outlen, int decipher)\n{\n\n\tstruct sc_context *ctx;\n\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 *sdata;\n\tint r, padding = 0, cbc = 0;\n\n\tsize_t block_size;\n\tsize_t len, rest_len;\n\tsize_t return_len = 0;\n\n\tsize_t max_apdu_datalen;\n\tsize_t apdu_datalen;\n\n\tassert(card != NULL);\n\n\tctx = card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\n\tmyeid_private_data_t *priv;\n\tpriv = (myeid_private_data_t *)card->drv_data;\n\n\t/* How many cipher blocks will fit in the APDU. We do not use the APDU chaining\n\t * mechanism from OpenSC, because we need the size of the APDU data block\n\t * to match a multiple of the cipher block size */\n\n\tmax_apdu_datalen = sc_get_max_send_size(card);\n\tif (max_apdu_datalen > sc_get_max_recv_size(card))\n\t\tmax_apdu_datalen = sc_get_max_recv_size(card);\n\n\tif (max_apdu_datalen > SC_MAX_APDU_BUFFER_SIZE)\n\t\tmax_apdu_datalen = SC_MAX_APDU_BUFFER_SIZE;\n\n\tsc_log(ctx, \"algorithm %d algorithm_flags %x\", priv->algorithm, priv->algorithm_flags);\n\n\t/* for C_Encrypt/C_EncryptUpdate/C_EncryptFinalize/C_Decrypt/C_DecryptUpdate/C_DecryptFinalize\n\t * the 'outlen' is always not NULL (src/pkcs11/framework-pkcs15.c).\n\t * For C_EncryptInit and C_DecrytpInit the 'outlen' is set to NULL\n\t */\n\tif (outlen == NULL) {\n\t\t/* C_EncryptInit/C_DecryptInit - clear buffers */\n\t\tsc_log(ctx, \"%s (symmetric key) initialized\", decipher ? \"C_DecryptInit\" : \"C_EncryptInit\");\n\t\tpriv->sym_crypt_buffer_len = 0;\n\t\tpriv->sym_plain_buffer_len = 0;\n\t\treturn SC_SUCCESS;\n\t}\n\n\tswitch (priv->algorithm) {\n\tcase SC_ALGORITHM_AES:\n\t\tblock_size = 16;\n\t\tif (priv->algorithm_flags & SC_ALGORITHM_AES_ECB) {\n\t\t\tpadding = 0;\n\t\t\tcbc = 0;\n\t\t} else if (priv->algorithm_flags & SC_ALGORITHM_AES_CBC) {\n\t\t\tpadding = 0;\n\t\t\tcbc = 1;\n\t\t} else if (priv->algorithm_flags & SC_ALGORITHM_AES_CBC_PAD) {\n\t\t\tpadding = 1;\n\t\t\tcbc = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\t/* MyEID: ECB APDU must match exact cipher block size in CBC\n\t * mode up to 240 bytes can be handled in one APDU\n\t * round max_apdu_datalen to multiple of block_size (CBC mode) */\n\n\tif (cbc)\n\t\tmax_apdu_datalen -= max_apdu_datalen % block_size;\n\telse\n\t\tmax_apdu_datalen = block_size;\n\n\t/* Maybe we have more input data (from previous PSO operation). */\n\trest_len = priv->sym_crypt_buffer_len;\n\n\t/* no input data from application (this is C_EncryptFinalize/C_DecryptFinalize */\n\tif (data == NULL) {\n\t\tif (datalen != 0)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\t\tif (decipher) {\n\t\t\t/* C_DecryptFinalize */\n\t\t\t/* decrypted buffer size must match the block size */\n\t\t\tif (priv->sym_plain_buffer_len != block_size)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\t\t\t/* do we have any encrypted data left? */\n\t\t\tif (rest_len)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\n\t\t\treturn_len = block_size;\n\t\t\tif (padding) {\n\t\t\t\t/* check padding */\n\t\t\t\tuint8_t i, pad_byte = *(priv->sym_plain_buffer + block_size - 1);\n\n\t\t\t\tsc_log(ctx, \"Found padding byte %02x\", pad_byte);\n\t\t\t\tif (pad_byte == 0 || pad_byte > block_size)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);\n\t\t\t\tsdata = priv->sym_plain_buffer + block_size;\n\t\t\t\tfor (i = 0; i < pad_byte; i++)\n\t\t\t\t\tif (*(--sdata) != pad_byte)\n\t\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);\n\t\t\t\treturn_len = block_size - pad_byte;\n\t\t\t}\n\t\t\t/* application can request buffer size or actual buffer size is too small */\n\t\t\tif (out == NULL) {\n\t\t\t\t*outlen = return_len;\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t\t\t}\n\t\t\tif (return_len > *outlen)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);\n\t\t\t*outlen = return_len;\n\t\t\tmemcpy(out, priv->sym_plain_buffer, return_len);\n\t\t\tsc_log(ctx, \"C_DecryptFinal %zu bytes\", *outlen);\n\t\t\treturn SC_SUCCESS;\n\t\t} else {\n\t\t\t/* C_EncryptFinalize */\n\t\t\tif (padding) {\n\t\t\t\tuint8_t pad_byte = block_size - rest_len;\n\t\t\t\tsc_log(ctx, \"Generating padding, padding byte: %d\", pad_byte);\n\t\t\t\tsdata = priv->sym_crypt_buffer + rest_len;\n\t\t\t\tmemset(sdata, pad_byte, pad_byte);\n\t\t\t\trest_len = block_size;\n\n\t\t\t} else if (rest_len) {\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\t\t\t}\n\t\t\t/* fall through - encipher last block */\n\t\t}\n\t}\n\t/* check output buffer size */\n\tlen = datalen + rest_len;\n\n\tsc_log(ctx, \"datalen=%zu rest_len=%zu len=%zu outlen=%zu\", datalen, rest_len, len, *outlen);\n\t/* there is block_size bytes space that can be saved to next run */\n\tlen -= (len % block_size);\n\n\t/* application can request buffer size or actual buffer size is too small */\n\t*outlen = len;\n\tif (out == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t/* application buffer is too small */\n\tif (*outlen < len)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);\n\n\t/* main loop */\n\twhile (len >= block_size) {\n\t\tif (!decipher)\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x84, 0x80);\n\t\telse\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x84);\n\t\tapdu.cla = 0;\n\n\t\tif (len > max_apdu_datalen)\n\t\t\tapdu_datalen = max_apdu_datalen;\n\t\telse\n\t\t\tapdu_datalen = len;\n\n\t\tif (cbc)\n\t\t\tapdu.cla = 0x10;\n\n\t\tlen -= apdu_datalen;\n\t\tsdata = sbuf;\n\n\t\tapdu.le = apdu_datalen;\n\t\tapdu.lc = apdu_datalen;\n\t\tapdu.datalen = apdu_datalen;\n\t\tapdu.data = sbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.resp = rbuf;\n\n\t\t/* do we have any data from the previous step ? */\n\t\tif (rest_len) {\n\t\t\tmemcpy(sbuf, priv->sym_crypt_buffer, rest_len);\n\t\t\tsdata += rest_len;\n\t\t\tapdu_datalen -= rest_len;\n\t\t\tpriv->sym_crypt_buffer_len = 0;\n\t\t\trest_len = 0;\n\t\t}\n\t\tif (data) {\n\t\t\tmemcpy(sdata, data, apdu_datalen);\n\t\t\tdata += apdu_datalen;\n\t\t\tdatalen -= apdu_datalen;\n\t\t}\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, r, \"decrypt_sym/encrypt_sym failed\");\n\t\tif (apdu.resplen != apdu.datalen)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\t\tmemcpy(out, apdu.resp, apdu.resplen);\n\t\tout += apdu.resplen;\n\t\treturn_len += apdu.resplen;\n\t}\n\t/* last block is stored in buffer and is returned to application\n\t * in next call to C_DecryptUpdate or C_DecryptFinal. This allow us\n\t * to compute how many bytes is to be returned after padding removal.\n\t * Whole handling of this is here, because \"data\" and \"out\" buffer\n\t * can be in the same place.\n\t */\n\tif (decipher) {\n\t\tuint8_t tmp_buf[16];\n\t\tif (return_len >= block_size) {\n\t\t\t/* save last block to temp buffer */\n\t\t\tmemcpy(tmp_buf, out - block_size, block_size);\n\t\t\tif (priv->sym_plain_buffer_len) {\n\t\t\t\t/* insert previous last block to output buffer */\n\t\t\t\tsc_log(ctx, \"inserting block from previous decrypt\");\n\t\t\t\tmemmove(out - return_len + block_size, out - return_len, return_len - block_size);\n\t\t\t\tmemcpy(out - return_len, priv->sym_plain_buffer, block_size);\n\t\t\t} else\n\t\t\t\treturn_len -= block_size;\n\t\t\t/* save last (decrypted) block */\n\t\t\tmemcpy(priv->sym_plain_buffer, tmp_buf, block_size);\n\t\t\tpriv->sym_plain_buffer_len = block_size;\n\n\t\t} else\n\t\t\tpriv->sym_plain_buffer_len = 0;\n\t}\n\t/* save rest of data for next run */\n\tpriv->sym_crypt_buffer_len = datalen;\n\tsc_log(ctx, \"rest data len = %zu\", datalen);\n\tif (data)\n\t\tmemcpy(priv->sym_crypt_buffer, data, datalen);\n\tsc_log(ctx, \"return data len = %zu\", return_len);\n\t*outlen = return_len;\n\treturn SC_SUCCESS;\n}\n\nstatic int\nmyeid_encrypt_sym(struct sc_card *card, const u8 *data, size_t datalen, u8 *out, size_t *outlen)\n{\n\treturn myeid_enc_dec_sym(card, data, datalen, out, outlen, 0);\n}\n\nstatic int\nmyeid_decrypt_sym(struct sc_card *card, const u8 *data, size_t datalen, u8 *out, size_t *outlen)\n{\n\treturn myeid_enc_dec_sym(card, data, datalen, out, outlen, 1);\n}\n\nstatic struct sc_card_driver * sc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tif (iso_ops == NULL)\n\t\tiso_ops = iso_drv->ops;\n\n\tmyeid_ops\t\t\t= *iso_drv->ops;\n\tmyeid_ops.match_card\t\t= myeid_match_card;\n\tmyeid_ops.init\t\t\t= myeid_init;\n\tmyeid_ops.finish\t\t= myeid_finish;\n\t/* no record oriented file services */\n\tmyeid_ops.read_record\t\t= NULL;\n\tmyeid_ops.write_record\t\t= NULL;\n\tmyeid_ops.append_record\t\t= NULL;\n\tmyeid_ops.update_record\t\t= NULL;\n\tmyeid_ops.select_file\t\t= myeid_select_file;\n\tmyeid_ops.get_response\t\t= iso_ops->get_response;\n\tmyeid_ops.logout\t\t= myeid_logout;\n\tmyeid_ops.create_file\t\t= myeid_create_file;\n\tmyeid_ops.delete_file\t\t= myeid_delete_file;\n\tmyeid_ops.list_files\t\t= myeid_list_files;\n\tmyeid_ops.set_security_env\t= myeid_set_security_env;\n\tmyeid_ops.compute_signature\t= myeid_compute_signature;\n\tmyeid_ops.decipher\t\t= myeid_decipher;\n\tmyeid_ops.process_fci\t\t= myeid_process_fci;\n\tmyeid_ops.card_ctl\t\t= myeid_card_ctl;\n\tmyeid_ops.pin_cmd\t\t= myeid_pin_cmd;\n\tmyeid_ops.wrap\t\t\t= myeid_wrap_key;\n\tmyeid_ops.unwrap\t\t= myeid_unwrap_key;\n\tmyeid_ops.encrypt_sym\t\t= myeid_encrypt_sym;\n\tmyeid_ops.decrypt_sym\t\t= myeid_decrypt_sym;\n\treturn &myeid_drv;\n}\n\nstruct sc_card_driver * sc_get_myeid_driver(void)\n{\n\treturn sc_get_driver();\n}\n\n"], "filenames": ["src/libopensc/card-myeid.c"], "buggy_code_start_loc": [1989], "buggy_code_end_loc": [2000], "fixing_code_start_loc": [1989], "fixing_code_end_loc": [2003], "type": "CWE-125", "message": "An out-of-bounds read vulnerability was found in OpenSC packages within the MyEID driver when handling symmetric key encryption. Exploiting this flaw requires an attacker to have physical access to the computer and a specially crafted USB device or smart card. This flaw allows the attacker to manipulate APDU responses and potentially gain unauthorized access to sensitive data, compromising the system's security.", "other": {"cve": {"id": "CVE-2023-4535", "sourceIdentifier": "secalert@redhat.com", "published": "2023-11-06T17:15:12.083", "lastModified": "2024-02-23T20:13:02.827", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An out-of-bounds read vulnerability was found in OpenSC packages within the MyEID driver when handling symmetric key encryption. Exploiting this flaw requires an attacker to have physical access to the computer and a specially crafted USB device or smart card. This flaw allows the attacker to manipulate APDU responses and potentially gain unauthorized access to sensitive data, compromising the system's security."}, {"lang": "es", "value": "Se encontr\u00f3 una vulnerabilidad de lectura fuera de los l\u00edmites en los paquetes OpenSC dentro del controlador MyEID al manejar el cifrado de clave sim\u00e9trica. Explotar esta falla requiere que un atacante tenga acceso f\u00edsico a la computadora y a un dispositivo USB o tarjeta inteligente especialmente manipulado. Esta falla permite al atacante manipular las respuestas de APDU y potencialmente obtener acceso no autorizado a datos confidenciales, comprometiendo la seguridad del sistema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:H/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "PHYSICAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 3.8, "baseSeverity": "LOW"}, "exploitabilityScore": 0.4, "impactScore": 3.4}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:H/PR:N/UI:R/S:C/C:L/I:L/A:L", "attackVector": "PHYSICAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.4, "impactScore": 3.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:0.23.0:-:*:*:*:*:*:*", "matchCriteriaId": "5359CB94-DE52-425E-AA8D-2792F953364F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:0.23.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "5A5A2D65-6BDA-464B-A5FA-BC79240E5EBF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:0.23.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "83814E22-74DD-41C3-AA1E-62B500D84B41"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2023:7879", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/security/cve/CVE-2023-4535", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2240914", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/OpenSC/OpenSC/commit/f1993dc4e0b33050b8f72a3558ee88b24c4063b2", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/OpenSC/OpenSC/issues/2792#issuecomment-1674806651", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/OpenSC/OpenSC/releases/tag/0.24.0-rc1", "source": "secalert@redhat.com", "tags": ["Release Notes"]}, {"url": "https://github.com/OpenSC/OpenSC/wiki/OpenSC-security-advisories", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3CPQOMCDWFRBMEFR5VK4N5MMXXU42ODE/", "source": "secalert@redhat.com", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GLYEFIBBA37TK3UNMZN5NOJ7IWCIXLQP/", "source": "secalert@redhat.com", "tags": ["Mailing List"]}]}, "github_commit_url": "https://github.com/OpenSC/OpenSC/commit/f1993dc4e0b33050b8f72a3558ee88b24c4063b2"}}