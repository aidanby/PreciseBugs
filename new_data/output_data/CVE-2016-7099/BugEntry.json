{"buggy_code": ["'use strict';\n\nconst internalUtil = require('internal/util');\ninternalUtil.assertCrypto(exports);\n\nconst net = require('net');\nconst url = require('url');\nconst binding = process.binding('crypto');\nconst Buffer = require('buffer').Buffer;\n\n// Allow {CLIENT_RENEG_LIMIT} client-initiated session renegotiations\n// every {CLIENT_RENEG_WINDOW} seconds. An error event is emitted if more\n// renegotations are seen. The settings are applied to all remote client\n// connections.\nexports.CLIENT_RENEG_LIMIT = 3;\nexports.CLIENT_RENEG_WINDOW = 600;\n\nexports.SLAB_BUFFER_SIZE = 10 * 1024 * 1024;\n\nexports.DEFAULT_CIPHERS =\n    process.binding('constants').crypto.defaultCipherList;\n\nexports.DEFAULT_ECDH_CURVE = 'prime256v1';\n\nexports.getCiphers = internalUtil.cachedResult(() => {\n  return internalUtil.filterDuplicateStrings(binding.getSSLCiphers(), true);\n});\n\n// Convert protocols array into valid OpenSSL protocols list\n// (\"\\x06spdy/2\\x08http/1.1\\x08http/1.0\")\nfunction convertProtocols(protocols) {\n  const lens = Array(protocols.length);\n  const buff = Buffer.allocUnsafe(protocols.reduce((p, c, i) => {\n    var len = Buffer.byteLength(c);\n    lens[i] = len;\n    return p + 1 + len;\n  }, 0));\n\n  var offset = 0;\n  for (var i = 0, c = protocols.length; i < c; i++) {\n    buff[offset++] = lens[i];\n    buff.write(protocols[i], offset);\n    offset += lens[i];\n  }\n\n  return buff;\n}\n\nexports.convertNPNProtocols = function(protocols, out) {\n  // If protocols is Array - translate it into buffer\n  if (Array.isArray(protocols)) {\n    out.NPNProtocols = convertProtocols(protocols);\n  } else if (protocols instanceof Buffer) {\n    // Copy new buffer not to be modified by user.\n    out.NPNProtocols = Buffer.from(protocols);\n  }\n};\n\nexports.convertALPNProtocols = function(protocols, out) {\n  // If protocols is Array - translate it into buffer\n  if (Array.isArray(protocols)) {\n    out.ALPNProtocols = convertProtocols(protocols);\n  } else if (protocols instanceof Buffer) {\n    // Copy new buffer not to be modified by user.\n    out.ALPNProtocols = Buffer.from(protocols);\n  }\n};\n\nexports.checkServerIdentity = function checkServerIdentity(host, cert) {\n  // Create regexp to much hostnames\n  function regexpify(host, wildcards) {\n    // Add trailing dot (make hostnames uniform)\n    if (!host || !host.endsWith('.')) host += '.';\n\n    // The same applies to hostname with more than one wildcard,\n    // if hostname has wildcard when wildcards are not allowed,\n    // or if there are less than two dots after wildcard (i.e. *.com or *d.com)\n    //\n    // also\n    //\n    // \"The client SHOULD NOT attempt to match a presented identifier in\n    // which the wildcard character comprises a label other than the\n    // left-most label (e.g., do not match bar.*.example.net).\"\n    // RFC6125\n    if (!wildcards && /\\*/.test(host) || /[\\.\\*].*\\*/.test(host) ||\n        /\\*/.test(host) && !/\\*.*\\..+\\..+/.test(host)) {\n      return /$./;\n    }\n\n    // Replace wildcard chars with regexp's wildcard and\n    // escape all characters that have special meaning in regexps\n    // (i.e. '.', '[', '{', '*', and others)\n    var re = host.replace(\n        /\\*([a-z0-9\\\\-_\\.])|[\\.,\\-\\\\\\^\\$+?*\\[\\]\\(\\):!\\|{}]/g,\n        function(all, sub) {\n          if (sub) return '[a-z0-9\\\\-_]*' + (sub === '-' ? '\\\\-' : sub);\n          return '\\\\' + all;\n        });\n\n    return new RegExp('^' + re + '$', 'i');\n  }\n\n  var dnsNames = [];\n  var uriNames = [];\n  const ips = [];\n  var matchCN = true;\n  var valid = false;\n  var reason = 'Unknown reason';\n\n  // There're several names to perform check against:\n  // CN and altnames in certificate extension\n  // (DNS names, IP addresses, and URIs)\n  //\n  // Walk through altnames and generate lists of those names\n  if (cert.subjectaltname) {\n    cert.subjectaltname.split(/, /g).forEach(function(altname) {\n      var option = altname.match(/^(DNS|IP Address|URI):(.*)$/);\n      if (!option)\n        return;\n      if (option[1] === 'DNS') {\n        dnsNames.push(option[2]);\n      } else if (option[1] === 'IP Address') {\n        ips.push(option[2]);\n      } else if (option[1] === 'URI') {\n        var uri = url.parse(option[2]);\n        if (uri) uriNames.push(uri.hostname);\n      }\n    });\n  }\n\n  // If hostname is an IP address, it should be present in the list of IP\n  // addresses.\n  if (net.isIP(host)) {\n    valid = ips.some(function(ip) {\n      return ip === host;\n    });\n    if (!valid) {\n      reason = `IP: ${host} is not in the cert's list: ${ips.join(', ')}`;\n    }\n  } else if (cert.subject) {\n    // Transform hostname to canonical form\n    if (!host || !host.endsWith('.')) host += '.';\n\n    // Otherwise check all DNS/URI records from certificate\n    // (with allowed wildcards)\n    dnsNames = dnsNames.map(function(name) {\n      return regexpify(name, true);\n    });\n\n    // Wildcards ain't allowed in URI names\n    uriNames = uriNames.map(function(name) {\n      return regexpify(name, false);\n    });\n\n    dnsNames = dnsNames.concat(uriNames);\n\n    if (dnsNames.length > 0) matchCN = false;\n\n    // Match against Common Name (CN) only if no supported identifiers are\n    // present.\n    //\n    // \"As noted, a client MUST NOT seek a match for a reference identifier\n    //  of CN-ID if the presented identifiers include a DNS-ID, SRV-ID,\n    //  URI-ID, or any application-specific identifier types supported by the\n    //  client.\"\n    // RFC6125\n    if (matchCN) {\n      var commonNames = cert.subject.CN;\n      if (Array.isArray(commonNames)) {\n        for (var i = 0, k = commonNames.length; i < k; ++i) {\n          dnsNames.push(regexpify(commonNames[i], true));\n        }\n      } else {\n        dnsNames.push(regexpify(commonNames, true));\n      }\n    }\n\n    valid = dnsNames.some(function(re) {\n      return re.test(host);\n    });\n\n    if (!valid) {\n      if (cert.subjectaltname) {\n        reason =\n            `Host: ${host} is not in the cert's altnames: ` +\n            `${cert.subjectaltname}`;\n      } else {\n        reason = `Host: ${host} is not cert's CN: ${cert.subject.CN}`;\n      }\n    }\n  } else {\n    reason = 'Cert is empty';\n  }\n\n  if (!valid) {\n    var err = new Error(\n        `Hostname/IP doesn't match certificate's altnames: \"${reason}\"`);\n    err.reason = reason;\n    err.host = host;\n    err.cert = cert;\n    return err;\n  }\n};\n\n// Example:\n// C=US\\nST=CA\\nL=SF\\nO=Joyent\\nOU=Node.js\\nCN=ca1\\nemailAddress=ry@clouds.org\nexports.parseCertString = function parseCertString(s) {\n  var out = {};\n  var parts = s.split('\\n');\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var sepIndex = parts[i].indexOf('=');\n    if (sepIndex > 0) {\n      var key = parts[i].slice(0, sepIndex);\n      var value = parts[i].slice(sepIndex + 1);\n      if (key in out) {\n        if (!Array.isArray(out[key])) {\n          out[key] = [out[key]];\n        }\n        out[key].push(value);\n      } else {\n        out[key] = value;\n      }\n    }\n  }\n  return out;\n};\n\n// Public API\nexports.createSecureContext = require('_tls_common').createSecureContext;\nexports.SecureContext = require('_tls_common').SecureContext;\nexports.TLSSocket = require('_tls_wrap').TLSSocket;\nexports.Server = require('_tls_wrap').Server;\nexports.createServer = require('_tls_wrap').createServer;\nexports.connect = require('_tls_wrap').connect;\nexports.createSecurePair = require('_tls_legacy').createSecurePair;\n", "'use strict';\nvar common = require('../common');\nvar assert = require('assert');\nvar util = require('util');\n\nif (!common.hasCrypto) {\n  common.skip('missing crypto');\n  return;\n}\nvar tls = require('tls');\n\n\nvar tests = [\n  // Basic CN handling\n  { host: 'a.com', cert: { subject: { CN: 'a.com' } } },\n  { host: 'a.com', cert: { subject: { CN: 'A.COM' } } },\n  {\n    host: 'a.com',\n    cert: { subject: { CN: 'b.com' } },\n    error: 'Host: a.com. is not cert\\'s CN: b.com'\n  },\n  { host: 'a.com', cert: { subject: { CN: 'a.com.' } } },\n\n  // Wildcards in CN\n  { host: 'b.a.com', cert: { subject: { CN: '*.a.com' } } },\n  { host: 'b.a.com', cert: {\n    subjectaltname: 'DNS:omg.com',\n    subject: { CN: '*.a.com' } },\n    error: 'Host: b.a.com. is not in the cert\\'s altnames: ' +\n           'DNS:omg.com'\n  },\n\n  // Empty Cert\n  {\n    host: 'a.com',\n    cert: { },\n    error: 'Cert is empty'\n  },\n\n  // Multiple CN fields\n  {\n    host: 'foo.com', cert: {\n      subject: { CN: ['foo.com', 'bar.com'] } // CN=foo.com; CN=bar.com;\n    }\n  },\n\n  // DNS names and CN\n  {\n    host: 'a.com', cert: {\n      subjectaltname: 'DNS:*',\n      subject: { CN: 'b.com' }\n    },\n    error: 'Host: a.com. is not in the cert\\'s altnames: ' +\n           'DNS:*'\n  },\n  {\n    host: 'a.com', cert: {\n      subjectaltname: 'DNS:*.com',\n      subject: { CN: 'b.com' }\n    },\n    error: 'Host: a.com. is not in the cert\\'s altnames: ' +\n           'DNS:*.com'\n  },\n  {\n    host: 'a.co.uk', cert: {\n      subjectaltname: 'DNS:*.co.uk',\n      subject: { CN: 'b.com' }\n    }\n  },\n  {\n    host: 'a.com', cert: {\n      subjectaltname: 'DNS:*.a.com',\n      subject: { CN: 'a.com' }\n    },\n    error: 'Host: a.com. is not in the cert\\'s altnames: ' +\n           'DNS:*.a.com'\n  },\n  {\n    host: 'a.com', cert: {\n      subjectaltname: 'DNS:*.a.com',\n      subject: { CN: 'b.com' }\n    },\n    error: 'Host: a.com. is not in the cert\\'s altnames: ' +\n           'DNS:*.a.com'\n  },\n  {\n    host: 'a.com', cert: {\n      subjectaltname: 'DNS:a.com',\n      subject: { CN: 'b.com' }\n    }\n  },\n  {\n    host: 'a.com', cert: {\n      subjectaltname: 'DNS:A.COM',\n      subject: { CN: 'b.com' }\n    }\n  },\n\n  // DNS names\n  {\n    host: 'a.com', cert: {\n      subjectaltname: 'DNS:*.a.com',\n      subject: {}\n    },\n    error: 'Host: a.com. is not in the cert\\'s altnames: ' +\n           'DNS:*.a.com'\n  },\n  {\n    host: 'b.a.com', cert: {\n      subjectaltname: 'DNS:*.a.com',\n      subject: {}\n    }\n  },\n  {\n    host: 'c.b.a.com', cert: {\n      subjectaltname: 'DNS:*.a.com',\n      subject: {}\n    },\n    error: 'Host: c.b.a.com. is not in the cert\\'s altnames: ' +\n           'DNS:*.a.com'\n  },\n  {\n    host: 'b.a.com', cert: {\n      subjectaltname: 'DNS:*b.a.com',\n      subject: {}\n    }\n  },\n  {\n    host: 'a-cb.a.com', cert: {\n      subjectaltname: 'DNS:*b.a.com',\n      subject: {}\n    }\n  },\n  {\n    host: 'a.b.a.com', cert: {\n      subjectaltname: 'DNS:*b.a.com',\n      subject: {}\n    },\n    error: 'Host: a.b.a.com. is not in the cert\\'s altnames: ' +\n           'DNS:*b.a.com'\n  },\n  // Mutliple DNS names\n  {\n    host: 'a.b.a.com', cert: {\n      subjectaltname: 'DNS:*b.a.com, DNS:a.b.a.com',\n      subject: {}\n    }\n  },\n  // URI names\n  {\n    host: 'a.b.a.com', cert: {\n      subjectaltname: 'URI:http://a.b.a.com/',\n      subject: {}\n    }\n  },\n  {\n    host: 'a.b.a.com', cert: {\n      subjectaltname: 'URI:http://*.b.a.com/',\n      subject: {}\n    },\n    error: 'Host: a.b.a.com. is not in the cert\\'s altnames: ' +\n           'URI:http://*.b.a.com/'\n  },\n  // IP addresses\n  {\n    host: 'a.b.a.com', cert: {\n      subjectaltname: 'IP Address:127.0.0.1',\n      subject: {}\n    },\n    error: 'Host: a.b.a.com. is not in the cert\\'s altnames: ' +\n           'IP Address:127.0.0.1'\n  },\n  {\n    host: '127.0.0.1', cert: {\n      subjectaltname: 'IP Address:127.0.0.1',\n      subject: {}\n    }\n  },\n  {\n    host: '127.0.0.2', cert: {\n      subjectaltname: 'IP Address:127.0.0.1',\n      subject: {}\n    },\n    error: 'IP: 127.0.0.2 is not in the cert\\'s list: ' +\n           '127.0.0.1'\n  },\n  {\n    host: '127.0.0.1', cert: {\n      subjectaltname: 'DNS:a.com',\n      subject: {}\n    },\n    error: 'IP: 127.0.0.1 is not in the cert\\'s list: '\n  },\n  {\n    host: 'localhost', cert: {\n      subjectaltname: 'DNS:a.com',\n      subject: { CN: 'localhost' }\n    },\n    error: 'Host: localhost. is not in the cert\\'s altnames: ' +\n           'DNS:a.com'\n  },\n];\n\ntests.forEach(function(test, i) {\n  var err = tls.checkServerIdentity(test.host, test.cert);\n  assert.equal(err && err.reason,\n               test.error,\n               'Test#' + i + ' failed: ' + util.inspect(test) + '\\n' +\n               test.error + ' != ' + (err && err.reason));\n});\n"], "fixing_code": ["'use strict';\n\nconst internalUtil = require('internal/util');\ninternalUtil.assertCrypto(exports);\n\nconst net = require('net');\nconst url = require('url');\nconst binding = process.binding('crypto');\nconst Buffer = require('buffer').Buffer;\n\n// Allow {CLIENT_RENEG_LIMIT} client-initiated session renegotiations\n// every {CLIENT_RENEG_WINDOW} seconds. An error event is emitted if more\n// renegotations are seen. The settings are applied to all remote client\n// connections.\nexports.CLIENT_RENEG_LIMIT = 3;\nexports.CLIENT_RENEG_WINDOW = 600;\n\nexports.SLAB_BUFFER_SIZE = 10 * 1024 * 1024;\n\nexports.DEFAULT_CIPHERS =\n    process.binding('constants').crypto.defaultCipherList;\n\nexports.DEFAULT_ECDH_CURVE = 'prime256v1';\n\nexports.getCiphers = internalUtil.cachedResult(() => {\n  return internalUtil.filterDuplicateStrings(binding.getSSLCiphers(), true);\n});\n\n// Convert protocols array into valid OpenSSL protocols list\n// (\"\\x06spdy/2\\x08http/1.1\\x08http/1.0\")\nfunction convertProtocols(protocols) {\n  const lens = Array(protocols.length);\n  const buff = Buffer.allocUnsafe(protocols.reduce((p, c, i) => {\n    var len = Buffer.byteLength(c);\n    lens[i] = len;\n    return p + 1 + len;\n  }, 0));\n\n  var offset = 0;\n  for (var i = 0, c = protocols.length; i < c; i++) {\n    buff[offset++] = lens[i];\n    buff.write(protocols[i], offset);\n    offset += lens[i];\n  }\n\n  return buff;\n}\n\nexports.convertNPNProtocols = function(protocols, out) {\n  // If protocols is Array - translate it into buffer\n  if (Array.isArray(protocols)) {\n    out.NPNProtocols = convertProtocols(protocols);\n  } else if (protocols instanceof Buffer) {\n    // Copy new buffer not to be modified by user.\n    out.NPNProtocols = Buffer.from(protocols);\n  }\n};\n\nexports.convertALPNProtocols = function(protocols, out) {\n  // If protocols is Array - translate it into buffer\n  if (Array.isArray(protocols)) {\n    out.ALPNProtocols = convertProtocols(protocols);\n  } else if (protocols instanceof Buffer) {\n    // Copy new buffer not to be modified by user.\n    out.ALPNProtocols = Buffer.from(protocols);\n  }\n};\n\nfunction unfqdn(host) {\n  return host.replace(/[.]$/, '');\n}\n\nfunction splitHost(host) {\n  // String#toLowerCase() is locale-sensitive so we use\n  // a conservative version that only lowercases A-Z.\n  const replacer = (c) => String.fromCharCode(32 + c.charCodeAt(0));\n  return unfqdn(host).replace(/[A-Z]/g, replacer).split('.');\n}\n\nfunction check(hostParts, pattern, wildcards) {\n  // Empty strings, null, undefined, etc. never match.\n  if (!pattern)\n    return false;\n\n  const patternParts = splitHost(pattern);\n\n  if (hostParts.length !== patternParts.length)\n    return false;\n\n  // Pattern has empty components, e.g. \"bad..example.com\".\n  if (patternParts.includes(''))\n    return false;\n\n  // RFC 6125 allows IDNA U-labels (Unicode) in names but we have no\n  // good way to detect their encoding or normalize them so we simply\n  // reject them.  Control characters and blanks are rejected as well\n  // because nothing good can come from accepting them.\n  const isBad = (s) => /[^\\u0021-\\u007F]/u.test(s);\n  if (patternParts.some(isBad))\n    return false;\n\n  // Check host parts from right to left first.\n  for (let i = hostParts.length - 1; i > 0; i -= 1)\n    if (hostParts[i] !== patternParts[i])\n      return false;\n\n  const hostSubdomain = hostParts[0];\n  const patternSubdomain = patternParts[0];\n  const patternSubdomainParts = patternSubdomain.split('*');\n\n  // Short-circuit when the subdomain does not contain a wildcard.\n  // RFC 6125 does not allow wildcard substitution for components\n  // containing IDNA A-labels (Punycode) so match those verbatim.\n  if (patternSubdomainParts.length === 1 || patternSubdomain.includes('xn--'))\n    return hostSubdomain === patternSubdomain;\n\n  if (!wildcards)\n    return false;\n\n  // More than one wildcard is always wrong.\n  if (patternSubdomainParts.length > 2)\n    return false;\n\n  // *.tld wildcards are not allowed.\n  if (patternParts.length <= 2)\n    return false;\n\n  const [prefix, suffix] = patternSubdomainParts;\n\n  if (prefix.length + suffix.length > hostSubdomain.length)\n    return false;\n\n  if (!hostSubdomain.startsWith(prefix))\n    return false;\n\n  if (!hostSubdomain.endsWith(suffix))\n    return false;\n\n  return true;\n}\n\nexports.checkServerIdentity = function checkServerIdentity(host, cert) {\n  const subject = cert.subject;\n  const altNames = cert.subjectaltname;\n  const dnsNames = [];\n  const uriNames = [];\n  const ips = [];\n\n  host = '' + host;\n\n  if (altNames) {\n    for (const name of altNames.split(', ')) {\n      if (name.startsWith('DNS:')) {\n        dnsNames.push(name.slice(4));\n      } else if (name.startsWith('URI:')) {\n        const uri = url.parse(name.slice(4));\n        uriNames.push(uri.hostname);  // TODO(bnoordhuis) Also use scheme.\n      } else if (name.startsWith('IP Address:')) {\n        ips.push(name.slice(11));\n      }\n    }\n  }\n\n  let valid = false;\n  let reason = 'Unknown reason';\n\n  if (net.isIP(host)) {\n    valid = ips.includes(host);\n    if (!valid)\n      reason = `IP: ${host} is not in the cert's list: ${ips.join(', ')}`;\n    // TODO(bnoordhuis) Also check URI SANs that are IP addresses.\n  } else if (subject) {\n    host = unfqdn(host);  // Remove trailing dot for error messages.\n    const hostParts = splitHost(host);\n    const wildcard = (pattern) => check(hostParts, pattern, true);\n    const noWildcard = (pattern) => check(hostParts, pattern, false);\n\n    // Match against Common Name only if no supported identifiers are present.\n    if (dnsNames.length === 0 && ips.length === 0 && uriNames.length === 0) {\n      const cn = subject.CN;\n\n      if (Array.isArray(cn))\n        valid = cn.some(wildcard);\n      else if (cn)\n        valid = wildcard(cn);\n\n      if (!valid)\n        reason = `Host: ${host}. is not cert's CN: ${cn}`;\n    } else {\n      valid = dnsNames.some(wildcard) || uriNames.some(noWildcard);\n      if (!valid)\n        reason = `Host: ${host}. is not in the cert's altnames: ${altNames}`;\n    }\n  } else {\n    reason = 'Cert is empty';\n  }\n\n  if (!valid) {\n    const err = new Error(\n        `Hostname/IP doesn't match certificate's altnames: \"${reason}\"`);\n    err.reason = reason;\n    err.host = host;\n    err.cert = cert;\n    return err;\n  }\n};\n\n// Example:\n// C=US\\nST=CA\\nL=SF\\nO=Joyent\\nOU=Node.js\\nCN=ca1\\nemailAddress=ry@clouds.org\nexports.parseCertString = function parseCertString(s) {\n  var out = {};\n  var parts = s.split('\\n');\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var sepIndex = parts[i].indexOf('=');\n    if (sepIndex > 0) {\n      var key = parts[i].slice(0, sepIndex);\n      var value = parts[i].slice(sepIndex + 1);\n      if (key in out) {\n        if (!Array.isArray(out[key])) {\n          out[key] = [out[key]];\n        }\n        out[key].push(value);\n      } else {\n        out[key] = value;\n      }\n    }\n  }\n  return out;\n};\n\n// Public API\nexports.createSecureContext = require('_tls_common').createSecureContext;\nexports.SecureContext = require('_tls_common').SecureContext;\nexports.TLSSocket = require('_tls_wrap').TLSSocket;\nexports.Server = require('_tls_wrap').Server;\nexports.createServer = require('_tls_wrap').createServer;\nexports.connect = require('_tls_wrap').connect;\nexports.createSecurePair = require('_tls_legacy').createSecurePair;\n", "'use strict';\nvar common = require('../common');\nvar assert = require('assert');\nvar util = require('util');\n\nif (!common.hasCrypto) {\n  common.skip('missing crypto');\n  return;\n}\nvar tls = require('tls');\n\n\nvar tests = [\n  // False-y values.\n  {\n    host: false,\n    cert: { subject: { CN: 'a.com' } },\n    error: 'Host: false. is not cert\\'s CN: a.com'\n  },\n  {\n    host: null,\n    cert: { subject: { CN: 'a.com' } },\n    error: 'Host: null. is not cert\\'s CN: a.com'\n  },\n  {\n    host: undefined,\n    cert: { subject: { CN: 'a.com' } },\n    error: 'Host: undefined. is not cert\\'s CN: a.com'\n  },\n\n  // Basic CN handling\n  { host: 'a.com', cert: { subject: { CN: 'a.com' } } },\n  { host: 'a.com', cert: { subject: { CN: 'A.COM' } } },\n  {\n    host: 'a.com',\n    cert: { subject: { CN: 'b.com' } },\n    error: 'Host: a.com. is not cert\\'s CN: b.com'\n  },\n  { host: 'a.com', cert: { subject: { CN: 'a.com.' } } },\n  {\n    host: 'a.com',\n    cert: { subject: { CN: '.a.com' } },\n    error: 'Host: a.com. is not cert\\'s CN: .a.com'\n  },\n\n  // Wildcards in CN\n  { host: 'b.a.com', cert: { subject: { CN: '*.a.com' } } },\n  {\n    host: 'ba.com',\n    cert: { subject: { CN: '*.a.com' } },\n    error: 'Host: ba.com. is not cert\\'s CN: *.a.com'\n  },\n  {\n    host: '\\n.b.com',\n    cert: { subject: { CN: '*n.b.com' } },\n    error: 'Host: \\n.b.com. is not cert\\'s CN: *n.b.com'\n  },\n  { host: 'b.a.com', cert: {\n    subjectaltname: 'DNS:omg.com',\n    subject: { CN: '*.a.com' } },\n    error: 'Host: b.a.com. is not in the cert\\'s altnames: ' +\n           'DNS:omg.com'\n  },\n  {\n    host: 'b.a.com',\n    cert: { subject: { CN: 'b*b.a.com' } },\n    error: 'Host: b.a.com. is not cert\\'s CN: b*b.a.com'\n  },\n\n  // Empty Cert\n  {\n    host: 'a.com',\n    cert: { },\n    error: 'Cert is empty'\n  },\n\n  // Multiple CN fields\n  {\n    host: 'foo.com', cert: {\n      subject: { CN: ['foo.com', 'bar.com'] } // CN=foo.com; CN=bar.com;\n    }\n  },\n\n  // DNS names and CN\n  {\n    host: 'a.com', cert: {\n      subjectaltname: 'DNS:*',\n      subject: { CN: 'b.com' }\n    },\n    error: 'Host: a.com. is not in the cert\\'s altnames: ' +\n           'DNS:*'\n  },\n  {\n    host: 'a.com', cert: {\n      subjectaltname: 'DNS:*.com',\n      subject: { CN: 'b.com' }\n    },\n    error: 'Host: a.com. is not in the cert\\'s altnames: ' +\n           'DNS:*.com'\n  },\n  {\n    host: 'a.co.uk', cert: {\n      subjectaltname: 'DNS:*.co.uk',\n      subject: { CN: 'b.com' }\n    }\n  },\n  {\n    host: 'a.com', cert: {\n      subjectaltname: 'DNS:*.a.com',\n      subject: { CN: 'a.com' }\n    },\n    error: 'Host: a.com. is not in the cert\\'s altnames: ' +\n           'DNS:*.a.com'\n  },\n  {\n    host: 'a.com', cert: {\n      subjectaltname: 'DNS:*.a.com',\n      subject: { CN: 'b.com' }\n    },\n    error: 'Host: a.com. is not in the cert\\'s altnames: ' +\n           'DNS:*.a.com'\n  },\n  {\n    host: 'a.com', cert: {\n      subjectaltname: 'DNS:a.com',\n      subject: { CN: 'b.com' }\n    }\n  },\n  {\n    host: 'a.com', cert: {\n      subjectaltname: 'DNS:A.COM',\n      subject: { CN: 'b.com' }\n    }\n  },\n\n  // DNS names\n  {\n    host: 'a.com', cert: {\n      subjectaltname: 'DNS:*.a.com',\n      subject: {}\n    },\n    error: 'Host: a.com. is not in the cert\\'s altnames: ' +\n           'DNS:*.a.com'\n  },\n  {\n    host: 'b.a.com', cert: {\n      subjectaltname: 'DNS:*.a.com',\n      subject: {}\n    }\n  },\n  {\n    host: 'c.b.a.com', cert: {\n      subjectaltname: 'DNS:*.a.com',\n      subject: {}\n    },\n    error: 'Host: c.b.a.com. is not in the cert\\'s altnames: ' +\n           'DNS:*.a.com'\n  },\n  {\n    host: 'b.a.com', cert: {\n      subjectaltname: 'DNS:*b.a.com',\n      subject: {}\n    }\n  },\n  {\n    host: 'a-cb.a.com', cert: {\n      subjectaltname: 'DNS:*b.a.com',\n      subject: {}\n    }\n  },\n  {\n    host: 'a.b.a.com', cert: {\n      subjectaltname: 'DNS:*b.a.com',\n      subject: {}\n    },\n    error: 'Host: a.b.a.com. is not in the cert\\'s altnames: ' +\n           'DNS:*b.a.com'\n  },\n  // Mutliple DNS names\n  {\n    host: 'a.b.a.com', cert: {\n      subjectaltname: 'DNS:*b.a.com, DNS:a.b.a.com',\n      subject: {}\n    }\n  },\n  // URI names\n  {\n    host: 'a.b.a.com', cert: {\n      subjectaltname: 'URI:http://a.b.a.com/',\n      subject: {}\n    }\n  },\n  {\n    host: 'a.b.a.com', cert: {\n      subjectaltname: 'URI:http://*.b.a.com/',\n      subject: {}\n    },\n    error: 'Host: a.b.a.com. is not in the cert\\'s altnames: ' +\n           'URI:http://*.b.a.com/'\n  },\n  // IP addresses\n  {\n    host: 'a.b.a.com', cert: {\n      subjectaltname: 'IP Address:127.0.0.1',\n      subject: {}\n    },\n    error: 'Host: a.b.a.com. is not in the cert\\'s altnames: ' +\n           'IP Address:127.0.0.1'\n  },\n  {\n    host: '127.0.0.1', cert: {\n      subjectaltname: 'IP Address:127.0.0.1',\n      subject: {}\n    }\n  },\n  {\n    host: '127.0.0.2', cert: {\n      subjectaltname: 'IP Address:127.0.0.1',\n      subject: {}\n    },\n    error: 'IP: 127.0.0.2 is not in the cert\\'s list: ' +\n           '127.0.0.1'\n  },\n  {\n    host: '127.0.0.1', cert: {\n      subjectaltname: 'DNS:a.com',\n      subject: {}\n    },\n    error: 'IP: 127.0.0.1 is not in the cert\\'s list: '\n  },\n  {\n    host: 'localhost', cert: {\n      subjectaltname: 'DNS:a.com',\n      subject: { CN: 'localhost' }\n    },\n    error: 'Host: localhost. is not in the cert\\'s altnames: ' +\n           'DNS:a.com'\n  },\n  // IDNA\n  {\n    host: 'xn--bcher-kva.example.com',\n    cert: { subject: { CN: '*.example.com' } },\n  },\n  // RFC 6125, section 6.4.3: \"[...] the client SHOULD NOT attempt to match\n  // a presented identifier where the wildcard character is embedded within\n  // an A-label [...]\"\n  {\n    host: 'xn--bcher-kva.example.com',\n    cert: { subject: { CN: 'xn--*.example.com' } },\n    error: 'Host: xn--bcher-kva.example.com. is not cert\\'s CN: ' +\n            'xn--*.example.com',\n  },\n];\n\ntests.forEach(function(test, i) {\n  var err = tls.checkServerIdentity(test.host, test.cert);\n  assert.equal(err && err.reason,\n               test.error,\n               'Test#' + i + ' failed: ' + util.inspect(test) + '\\n' +\n               test.error + ' != ' + (err && err.reason));\n});\n"], "filenames": ["lib/tls.js", "test/parallel/test-tls-check-server-identity.js"], "buggy_code_start_loc": [68, 13], "buggy_code_end_loc": [197, 200], "fixing_code_start_loc": [69, 14], "fixing_code_end_loc": [200, 252], "type": "CWE-19", "message": "The tls.checkServerIdentity function in Node.js 0.10.x before 0.10.47, 0.12.x before 0.12.16, 4.x before 4.6.0, and 6.x before 6.7.0 does not properly handle wildcards in name fields of X.509 certificates, which allows man-in-the-middle attackers to spoof servers via a crafted certificate.", "other": {"cve": {"id": "CVE-2016-7099", "sourceIdentifier": "cve@mitre.org", "published": "2016-10-10T16:59:01.277", "lastModified": "2018-01-05T02:31:10.917", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The tls.checkServerIdentity function in Node.js 0.10.x before 0.10.47, 0.12.x before 0.12.16, 4.x before 4.6.0, and 6.x before 6.7.0 does not properly handle wildcards in name fields of X.509 certificates, which allows man-in-the-middle attackers to spoof servers via a crafted certificate."}, {"lang": "es", "value": "La funci\u00f3n tls.checkServerIdentity en Node.js 0.10.x en versiones anteriores a 0.10.47, 0.12.x en versiones anteriores a 0.12.16, 4.x en versiones anteriores a 4.6.0 y 6.x en versiones anteriores a 6.7.0 no maneja adecuadamente comodines en los campos de nombres de certificados X.509, lo que permite a atacantes man-in-the-middle suplantar servidores a trav\u00e9s de un certificado manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-19"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "BF2E637C-EA49-4DB6-B4D5-B4684A9549C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "C1966CED-11A1-4328-A57E-308BE5E4CCD1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "A9F46AD2-BB74-4391-8A4F-7BE49EF41F0D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "EC36E36A-9592-49DA-AACE-B3638FC55F4D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "B98E9F42-08BC-49B5-90C8-AC3EA7960C45"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "ABA37EF5-DF97-467B-9A56-1611345387FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "5F0BD0C1-2294-4AFB-B4AE-C81576FB9AFF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "4057D560-81EE-49ED-888C-89560DBE3348"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.8:*:*:*:*:*:*:*", "matchCriteriaId": "F87810E1-BDAD-455D-82E3-334CC102AB2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.9:*:*:*:*:*:*:*", "matchCriteriaId": "8BC00B3A-3C9D-4487-9686-775CBAA1CC42"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.10:*:*:*:*:*:*:*", "matchCriteriaId": "7C0A4F5B-4546-414C-A209-07C27ED1C944"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.11:*:*:*:*:*:*:*", "matchCriteriaId": "2515087F-B272-4B76-99F4-ACA0C2460046"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.12:*:*:*:*:*:*:*", "matchCriteriaId": "0C7016DE-A3A5-450B-9FBD-2C98A07FF3C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.13:*:*:*:*:*:*:*", "matchCriteriaId": "8C1848A7-E68E-4CB4-B73C-C5200ABAC9DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.14:*:*:*:*:*:*:*", "matchCriteriaId": "59F861AB-574A-41BF-8E2D-6440B35C2AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.15:*:*:*:*:*:*:*", "matchCriteriaId": "41C8CEF8-49E1-4CB0-837B-E85C76BF9DF5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.16:*:*:*:*:*:*:*", "matchCriteriaId": "8C7101A5-FDC9-4897-B8E8-6A07790D42A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.16-isaacs-manual:*:*:*:*:*:*:*", "matchCriteriaId": "F7776F01-29AC-4161-9C91-C7392C6A356E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.17:*:*:*:*:*:*:*", "matchCriteriaId": "3CADD766-8328-4669-BE66-A4757D5FB471"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.18:*:*:*:*:*:*:*", "matchCriteriaId": "AD9792E9-2593-46B4-9633-E2F2DB11106B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.19:*:*:*:*:*:*:*", "matchCriteriaId": "FF209248-8921-419A-86EB-30E7095E4514"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.20:*:*:*:*:*:*:*", "matchCriteriaId": "2C0D6C34-E046-40BD-907D-0E2510C09A14"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.21:*:*:*:*:*:*:*", "matchCriteriaId": "E5CBB83F-19AD-44BD-B7D4-19C1A8F80011"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.22:*:*:*:*:*:*:*", "matchCriteriaId": "D6E2EA97-156D-4870-8967-78E4ED6EF64F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.23:*:*:*:*:*:*:*", "matchCriteriaId": "54961BCA-8730-4B40-8385-41F6D65797F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.24:*:*:*:*:*:*:*", "matchCriteriaId": "B22FA598-E613-4652-92CD-237F749D13DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.25:*:*:*:*:*:*:*", "matchCriteriaId": "B4F321AF-FCC7-456D-AFE2-2CEF9CBAFCC1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.26:*:*:*:*:*:*:*", "matchCriteriaId": "18F2EC65-2A47-4C45-8D58-63D18443B767"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.27:*:*:*:*:*:*:*", "matchCriteriaId": "D0517A28-70F9-4947-BEF0-9CC645388BFA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.28:*:*:*:*:*:*:*", "matchCriteriaId": "C5DD5BBD-922E-4026-9DEC-98CF9411CE95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.29:*:*:*:*:*:*:*", "matchCriteriaId": "63E078BA-8BDC-47EB-84B9-09B785FD1213"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.30:*:*:*:*:*:*:*", "matchCriteriaId": "4B9971A7-1C18-43C0-97BC-27096609EFC3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.31:*:*:*:*:*:*:*", "matchCriteriaId": "0EA5107B-4347-4D43-ADA6-141527A40333"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.32:*:*:*:*:*:*:*", "matchCriteriaId": "0C679CFA-50D4-430B-B372-113CE236EACC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.33:*:*:*:*:*:*:*", "matchCriteriaId": "F7AA6FEE-C630-4545-BCCF-3C211461C6C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.34:*:*:*:*:*:*:*", "matchCriteriaId": "682E8A32-1F1E-4427-BAD8-58596F85F170"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.35:*:*:*:*:*:*:*", "matchCriteriaId": "C9827EF0-E340-4A75-9735-F20CDF09CA42"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.36:*:*:*:*:*:*:*", "matchCriteriaId": "E6C02C09-D738-45B1-BF6F-A4499E5F8D60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.37:*:*:*:*:*:*:*", "matchCriteriaId": "EE85CACC-842F-46C7-966D-48E866055A5F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.38:*:*:*:*:*:*:*", "matchCriteriaId": "771BCA5F-B762-4569-AB46-08A13A4EFD5C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.39:*:*:*:*:*:*:*", "matchCriteriaId": "21E05024-3647-456D-A731-D19411FED2DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.40:*:*:*:*:*:*:*", "matchCriteriaId": "89929EB1-D723-496B-A7C6-4B4CD9C176B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.41:*:*:*:*:*:*:*", "matchCriteriaId": "D3EA4652-EF0E-414C-AEB8-AEFE788B66A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.42:*:*:*:*:*:*:*", "matchCriteriaId": "BB746835-B498-4217-B909-69C597AD9431"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.43:*:*:*:*:*:*:*", "matchCriteriaId": "B759B4D1-90E2-4BB6-B38E-F7FBA7620B9C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.44:*:*:*:*:*:*:*", "matchCriteriaId": "898AD4C5-4B93-453D-AAE3-C04FE6486C19"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.45:*:*:*:*:*:*:*", "matchCriteriaId": "87401457-F8C1-4372-8B71-694D2B35CCDA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.10.46:*:*:*:*:*:*:*", "matchCriteriaId": "72552CF7-31C4-48D2-9028-03F71CEC9BEB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "CBC8B78D-1131-4F21-919D-8AC79A410FB9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:6.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "5A53CB0E-3FBA-4796-BC81-6003A7DC29DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:6.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "B4F3F415-CD69-4E19-A4F9-3673D2907932"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:6.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "758E9981-966B-4BB5-8982-183683C76228"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:6.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "BD05686C-E548-43CB-81C1-5AE3E3E5ECBE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:6.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "5D1FAA74-207E-4E37-90F7-75202ED64E37"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:6.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "F747352F-DFE4-45C3-9806-CBDC1E4A64E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:6.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "1E144BC9-0D69-4C9B-9AF0-D7730F1719EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:6.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "82EA5976-2268-4FF3-BE6A-5680D45073E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:6.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "E85F98DB-A43D-47C0-B271-0E25DCF0EA65"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:6.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "94E82A49-5897-43D4-8EF7-F743B8B909E2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.0:*:*:*:*:*:*:*", "matchCriteriaId": "BC9002F9-87C4-4C7F-9BD9-430EB15CD4BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.1:*:*:*:*:*:*:*", "matchCriteriaId": "21EF734D-9E6B-4E01-9AFE-C0B847D583A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.2:*:*:*:*:*:*:*", "matchCriteriaId": "12606C39-6F39-4DDF-9B36-A160875B265F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.3:*:*:*:*:*:*:*", "matchCriteriaId": "EC4D8789-33C3-498A-857D-CC6576732C31"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.4:*:*:*:*:*:*:*", "matchCriteriaId": "466E8851-6BE7-4716-AB16-3E985411C35C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.5:*:*:*:*:*:*:*", "matchCriteriaId": "E5C4DB21-F35A-4567-8B04-85DB3089CDF2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.6:*:*:*:*:*:*:*", "matchCriteriaId": "BA7E7436-117A-4F79-BA7A-2A0059BB9694"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.7:*:*:*:*:*:*:*", "matchCriteriaId": "037511C2-3FA9-4A4C-996B-A1462C221DA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.8:*:*:*:*:*:*:*", "matchCriteriaId": "65EEB1B9-2E75-46F4-B70C-94991D38B427"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.9:*:*:*:*:*:*:*", "matchCriteriaId": "0E5C5750-10F3-45D7-AC9B-7EA06F4B3887"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.10:*:*:*:*:*:*:*", "matchCriteriaId": "75621360-0F11-42A1-95D5-5DC637DA81EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.11:*:*:*:*:*:*:*", "matchCriteriaId": "A46C3701-CD93-4F50-8307-998499B5909B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.12:*:*:*:*:*:*:*", "matchCriteriaId": "4DCC0D52-5473-4794-BB66-4CA32FEC074D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.13:*:*:*:*:*:*:*", "matchCriteriaId": "176B1165-2665-4541-9248-851996A22FCD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.14:*:*:*:*:*:*:*", "matchCriteriaId": "5639B573-4A05-4F5E-BA10-9A3D757F0F8F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:0.12.15:*:*:*:*:*:*:*", "matchCriteriaId": "6544D0F7-4026-4E2C-85D1-FEE9564E8022"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "0390D600-532D-4675-95BB-10EC4E06F3E0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "35AAF7CD-9AE6-4A4B-858E-4B17031BD058"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "5DCB6010-AC31-4B61-9DA6-E119ADC5D70B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "E5364365-36F1-49C0-BF8D-2D5054BC7B1D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "0740684D-989A-4957-8AC1-AAB01A04E393"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "08C97202-6AEC-4B8D-B3F6-49F6AEF9CFD1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "7EFA073A-9AC2-4162-9DDA-B6CD0AE53D3F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F8FD4B3-D515-486A-94A3-29CBDA2E25CD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "55E18631-9502-42CC-A85A-EA5742FDC317"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "4CCBC213-1524-4C88-9EB3-52E003070A3B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "C928FB55-2F33-4458-8484-4010AE8883A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "5CEEFA5F-2B32-4CA0-84AD-E0ECA0F81078"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "4754B0A8-A7D7-41A1-BFE5-10D84E7CEC1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D132104E-163C-47EE-B247-578D64AC88D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "4E208FB1-A772-4002-BD56-3360BDDFEF37"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "14BE6C0B-E6EC-4CD2-912B-45DE9F94BA59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "714EBE27-F0D0-4B2E-90E1-4C73DF7FAA81"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "0BE8859F-1EBE-4B9A-A5ED-7FA63D68C947"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "1249AA75-5676-4AFC-99B4-A59DC9BE1F33"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "E875B302-1923-40AF-B956-A063714BBA9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "10940F9C-6671-4C0D-89F9-6111A44FA74D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "5F031F09-0AF1-4825-8C8C-AC5A65119E92"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:4.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "413C8F30-5B76-49D6-95C2-E62FC34911EC"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2016-10/msg00013.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0002.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/93191", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/nodejs/node/commit/743f0c916469f3129dfae406fa104dc46782e20b", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://nodejs.org/en/blog/vulnerability/september-2016-security-releases/", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/nodejs/node/commit/743f0c916469f3129dfae406fa104dc46782e20b"}}