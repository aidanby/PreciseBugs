{"buggy_code": ["/* BGP attributes management routines.\n * Copyright (C) 1996, 97, 98, 1999 Kunihiro Ishiguro\n *\n * This file is part of GNU Zebra.\n *\n * GNU Zebra is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2, or (at your option) any\n * later version.\n *\n * GNU Zebra is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; see the file COPYING; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <zebra.h>\n\n#include \"linklist.h\"\n#include \"prefix.h\"\n#include \"memory.h\"\n#include \"vector.h\"\n#include \"stream.h\"\n#include \"log.h\"\n#include \"hash.h\"\n#include \"jhash.h\"\n#include \"queue.h\"\n#include \"table.h\"\n#include \"filter.h\"\n#include \"command.h\"\n\n#include \"bgpd/bgpd.h\"\n#include \"bgpd/bgp_attr.h\"\n#include \"bgpd/bgp_route.h\"\n#include \"bgpd/bgp_aspath.h\"\n#include \"bgpd/bgp_community.h\"\n#include \"bgpd/bgp_debug.h\"\n#include \"bgpd/bgp_errors.h\"\n#include \"bgpd/bgp_label.h\"\n#include \"bgpd/bgp_packet.h\"\n#include \"bgpd/bgp_ecommunity.h\"\n#include \"bgpd/bgp_lcommunity.h\"\n#include \"bgpd/bgp_updgrp.h\"\n#include \"bgpd/bgp_encap_types.h\"\n#if ENABLE_BGP_VNC\n#include \"bgpd/rfapi/bgp_rfapi_cfg.h\"\n#include \"bgp_encap_types.h\"\n#include \"bgp_vnc_types.h\"\n#endif\n#include \"bgp_encap_types.h\"\n#include \"bgp_evpn.h\"\n#include \"bgp_flowspec_private.h\"\n\n/* Attribute strings for logging. */\nstatic const struct message attr_str[] = {\n\t{BGP_ATTR_ORIGIN, \"ORIGIN\"},\n\t{BGP_ATTR_AS_PATH, \"AS_PATH\"},\n\t{BGP_ATTR_NEXT_HOP, \"NEXT_HOP\"},\n\t{BGP_ATTR_MULTI_EXIT_DISC, \"MULTI_EXIT_DISC\"},\n\t{BGP_ATTR_LOCAL_PREF, \"LOCAL_PREF\"},\n\t{BGP_ATTR_ATOMIC_AGGREGATE, \"ATOMIC_AGGREGATE\"},\n\t{BGP_ATTR_AGGREGATOR, \"AGGREGATOR\"},\n\t{BGP_ATTR_COMMUNITIES, \"COMMUNITY\"},\n\t{BGP_ATTR_ORIGINATOR_ID, \"ORIGINATOR_ID\"},\n\t{BGP_ATTR_CLUSTER_LIST, \"CLUSTER_LIST\"},\n\t{BGP_ATTR_DPA, \"DPA\"},\n\t{BGP_ATTR_ADVERTISER, \"ADVERTISER\"},\n\t{BGP_ATTR_RCID_PATH, \"RCID_PATH\"},\n\t{BGP_ATTR_MP_REACH_NLRI, \"MP_REACH_NLRI\"},\n\t{BGP_ATTR_MP_UNREACH_NLRI, \"MP_UNREACH_NLRI\"},\n\t{BGP_ATTR_EXT_COMMUNITIES, \"EXT_COMMUNITIES\"},\n\t{BGP_ATTR_AS4_PATH, \"AS4_PATH\"},\n\t{BGP_ATTR_AS4_AGGREGATOR, \"AS4_AGGREGATOR\"},\n\t{BGP_ATTR_AS_PATHLIMIT, \"AS_PATHLIMIT\"},\n\t{BGP_ATTR_PMSI_TUNNEL, \"PMSI_TUNNEL_ATTRIBUTE\"},\n\t{BGP_ATTR_ENCAP, \"ENCAP\"},\n#if ENABLE_BGP_VNC\n\t{BGP_ATTR_VNC, \"VNC\"},\n#endif\n\t{BGP_ATTR_LARGE_COMMUNITIES, \"LARGE_COMMUNITY\"},\n\t{BGP_ATTR_PREFIX_SID, \"PREFIX_SID\"},\n\t{0}};\n\nstatic const struct message attr_flag_str[] = {\n\t{BGP_ATTR_FLAG_OPTIONAL, \"Optional\"},\n\t{BGP_ATTR_FLAG_TRANS, \"Transitive\"},\n\t{BGP_ATTR_FLAG_PARTIAL, \"Partial\"},\n\t/* bgp_attr_flags_diagnose() relies on this bit being last in\n\t   this list */\n\t{BGP_ATTR_FLAG_EXTLEN, \"Extended Length\"},\n\t{0}};\n\nstatic struct hash *cluster_hash;\n\nstatic void *cluster_hash_alloc(void *p)\n{\n\tconst struct cluster_list *val = (const struct cluster_list *)p;\n\tstruct cluster_list *cluster;\n\n\tcluster = XMALLOC(MTYPE_CLUSTER, sizeof(struct cluster_list));\n\tcluster->length = val->length;\n\n\tif (cluster->length) {\n\t\tcluster->list = XMALLOC(MTYPE_CLUSTER_VAL, val->length);\n\t\tmemcpy(cluster->list, val->list, val->length);\n\t} else\n\t\tcluster->list = NULL;\n\n\tcluster->refcnt = 0;\n\n\treturn cluster;\n}\n\n/* Cluster list related functions. */\nstatic struct cluster_list *cluster_parse(struct in_addr *pnt, int length)\n{\n\tstruct cluster_list tmp;\n\tstruct cluster_list *cluster;\n\n\ttmp.length = length;\n\ttmp.list = pnt;\n\n\tcluster = hash_get(cluster_hash, &tmp, cluster_hash_alloc);\n\tcluster->refcnt++;\n\treturn cluster;\n}\n\nint cluster_loop_check(struct cluster_list *cluster, struct in_addr originator)\n{\n\tint i;\n\n\tfor (i = 0; i < cluster->length / 4; i++)\n\t\tif (cluster->list[i].s_addr == originator.s_addr)\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic unsigned int cluster_hash_key_make(void *p)\n{\n\tconst struct cluster_list *cluster = p;\n\n\treturn jhash(cluster->list, cluster->length, 0);\n}\n\nstatic bool cluster_hash_cmp(const void *p1, const void *p2)\n{\n\tconst struct cluster_list *cluster1 = p1;\n\tconst struct cluster_list *cluster2 = p2;\n\n\treturn (cluster1->length == cluster2->length\n\t\t&& memcmp(cluster1->list, cluster2->list, cluster1->length)\n\t\t\t   == 0);\n}\n\nstatic void cluster_free(struct cluster_list *cluster)\n{\n\tif (cluster->list)\n\t\tXFREE(MTYPE_CLUSTER_VAL, cluster->list);\n\tXFREE(MTYPE_CLUSTER, cluster);\n}\n\nstatic struct cluster_list *cluster_intern(struct cluster_list *cluster)\n{\n\tstruct cluster_list *find;\n\n\tfind = hash_get(cluster_hash, cluster, cluster_hash_alloc);\n\tfind->refcnt++;\n\n\treturn find;\n}\n\nvoid cluster_unintern(struct cluster_list *cluster)\n{\n\tif (cluster->refcnt)\n\t\tcluster->refcnt--;\n\n\tif (cluster->refcnt == 0) {\n\t\thash_release(cluster_hash, cluster);\n\t\tcluster_free(cluster);\n\t}\n}\n\nstatic void cluster_init(void)\n{\n\tcluster_hash = hash_create(cluster_hash_key_make, cluster_hash_cmp,\n\t\t\t\t   \"BGP Cluster\");\n}\n\nstatic void cluster_finish(void)\n{\n\thash_clean(cluster_hash, (void (*)(void *))cluster_free);\n\thash_free(cluster_hash);\n\tcluster_hash = NULL;\n}\n\nstatic struct hash *encap_hash = NULL;\n#if ENABLE_BGP_VNC\nstatic struct hash *vnc_hash = NULL;\n#endif\n\nstruct bgp_attr_encap_subtlv *encap_tlv_dup(struct bgp_attr_encap_subtlv *orig)\n{\n\tstruct bgp_attr_encap_subtlv *new;\n\tstruct bgp_attr_encap_subtlv *tail;\n\tstruct bgp_attr_encap_subtlv *p;\n\n\tfor (p = orig, tail = new = NULL; p; p = p->next) {\n\t\tint size = sizeof(struct bgp_attr_encap_subtlv) + p->length;\n\t\tif (tail) {\n\t\t\ttail->next = XCALLOC(MTYPE_ENCAP_TLV, size);\n\t\t\ttail = tail->next;\n\t\t} else {\n\t\t\ttail = new = XCALLOC(MTYPE_ENCAP_TLV, size);\n\t\t}\n\t\tassert(tail);\n\t\tmemcpy(tail, p, size);\n\t\ttail->next = NULL;\n\t}\n\n\treturn new;\n}\n\nstatic void encap_free(struct bgp_attr_encap_subtlv *p)\n{\n\tstruct bgp_attr_encap_subtlv *next;\n\twhile (p) {\n\t\tnext = p->next;\n\t\tp->next = NULL;\n\t\tXFREE(MTYPE_ENCAP_TLV, p);\n\t\tp = next;\n\t}\n}\n\nvoid bgp_attr_flush_encap(struct attr *attr)\n{\n\tif (!attr)\n\t\treturn;\n\n\tif (attr->encap_subtlvs) {\n\t\tencap_free(attr->encap_subtlvs);\n\t\tattr->encap_subtlvs = NULL;\n\t}\n#if ENABLE_BGP_VNC\n\tif (attr->vnc_subtlvs) {\n\t\tencap_free(attr->vnc_subtlvs);\n\t\tattr->vnc_subtlvs = NULL;\n\t}\n#endif\n}\n\n/*\n * Compare encap sub-tlv chains\n *\n *\t1 = equivalent\n *\t0 = not equivalent\n *\n * This algorithm could be made faster if needed\n */\nstatic int encap_same(const struct bgp_attr_encap_subtlv *h1,\n\t\t      const struct bgp_attr_encap_subtlv *h2)\n{\n\tconst struct bgp_attr_encap_subtlv *p;\n\tconst struct bgp_attr_encap_subtlv *q;\n\n\tif (h1 == h2)\n\t\treturn 1;\n\tif (h1 == NULL || h2 == NULL)\n\t\treturn 0;\n\n\tfor (p = h1; p; p = p->next) {\n\t\tfor (q = h2; q; q = q->next) {\n\t\t\tif ((p->type == q->type) && (p->length == q->length)\n\t\t\t    && !memcmp(p->value, q->value, p->length)) {\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!q)\n\t\t\treturn 0;\n\t}\n\n\tfor (p = h2; p; p = p->next) {\n\t\tfor (q = h1; q; q = q->next) {\n\t\t\tif ((p->type == q->type) && (p->length == q->length)\n\t\t\t    && !memcmp(p->value, q->value, p->length)) {\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!q)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void *encap_hash_alloc(void *p)\n{\n\t/* Encap structure is already allocated.  */\n\treturn p;\n}\n\ntypedef enum {\n\tENCAP_SUBTLV_TYPE,\n#if ENABLE_BGP_VNC\n\tVNC_SUBTLV_TYPE\n#endif\n} encap_subtlv_type;\n\nstatic struct bgp_attr_encap_subtlv *\nencap_intern(struct bgp_attr_encap_subtlv *encap, encap_subtlv_type type)\n{\n\tstruct bgp_attr_encap_subtlv *find;\n\tstruct hash *hash = encap_hash;\n#if ENABLE_BGP_VNC\n\tif (type == VNC_SUBTLV_TYPE)\n\t\thash = vnc_hash;\n#endif\n\n\tfind = hash_get(hash, encap, encap_hash_alloc);\n\tif (find != encap)\n\t\tencap_free(encap);\n\tfind->refcnt++;\n\n\treturn find;\n}\n\nstatic void encap_unintern(struct bgp_attr_encap_subtlv **encapp,\n\t\t\t   encap_subtlv_type type)\n{\n\tstruct bgp_attr_encap_subtlv *encap = *encapp;\n\tif (encap->refcnt)\n\t\tencap->refcnt--;\n\n\tif (encap->refcnt == 0) {\n\t\tstruct hash *hash = encap_hash;\n#if ENABLE_BGP_VNC\n\t\tif (type == VNC_SUBTLV_TYPE)\n\t\t\thash = vnc_hash;\n#endif\n\t\thash_release(hash, encap);\n\t\tencap_free(encap);\n\t\t*encapp = NULL;\n\t}\n}\n\nstatic unsigned int encap_hash_key_make(void *p)\n{\n\tconst struct bgp_attr_encap_subtlv *encap = p;\n\n\treturn jhash(encap->value, encap->length, 0);\n}\n\nstatic bool encap_hash_cmp(const void *p1, const void *p2)\n{\n\treturn encap_same((const struct bgp_attr_encap_subtlv *)p1,\n\t\t\t  (const struct bgp_attr_encap_subtlv *)p2);\n}\n\nstatic void encap_init(void)\n{\n\tencap_hash = hash_create(encap_hash_key_make, encap_hash_cmp,\n\t\t\t\t \"BGP Encap Hash\");\n#if ENABLE_BGP_VNC\n\tvnc_hash = hash_create(encap_hash_key_make, encap_hash_cmp,\n\t\t\t       \"BGP VNC Hash\");\n#endif\n}\n\nstatic void encap_finish(void)\n{\n\thash_clean(encap_hash, (void (*)(void *))encap_free);\n\thash_free(encap_hash);\n\tencap_hash = NULL;\n#if ENABLE_BGP_VNC\n\thash_clean(vnc_hash, (void (*)(void *))encap_free);\n\thash_free(vnc_hash);\n\tvnc_hash = NULL;\n#endif\n}\n\nstatic bool overlay_index_same(const struct attr *a1, const struct attr *a2)\n{\n\tif (!a1 && a2)\n\t\treturn false;\n\tif (!a2 && a1)\n\t\treturn false;\n\tif (!a1 && !a2)\n\t\treturn true;\n\treturn !memcmp(&(a1->evpn_overlay), &(a2->evpn_overlay),\n\t\t       sizeof(struct overlay_index));\n}\n\n/* Unknown transit attribute. */\nstatic struct hash *transit_hash;\n\nstatic void transit_free(struct transit *transit)\n{\n\tif (transit->val)\n\t\tXFREE(MTYPE_TRANSIT_VAL, transit->val);\n\tXFREE(MTYPE_TRANSIT, transit);\n}\n\nstatic void *transit_hash_alloc(void *p)\n{\n\t/* Transit structure is already allocated.  */\n\treturn p;\n}\n\nstatic struct transit *transit_intern(struct transit *transit)\n{\n\tstruct transit *find;\n\n\tfind = hash_get(transit_hash, transit, transit_hash_alloc);\n\tif (find != transit)\n\t\ttransit_free(transit);\n\tfind->refcnt++;\n\n\treturn find;\n}\n\nvoid transit_unintern(struct transit *transit)\n{\n\tif (transit->refcnt)\n\t\ttransit->refcnt--;\n\n\tif (transit->refcnt == 0) {\n\t\thash_release(transit_hash, transit);\n\t\ttransit_free(transit);\n\t}\n}\n\nstatic unsigned int transit_hash_key_make(void *p)\n{\n\tconst struct transit *transit = p;\n\n\treturn jhash(transit->val, transit->length, 0);\n}\n\nstatic bool transit_hash_cmp(const void *p1, const void *p2)\n{\n\tconst struct transit *transit1 = p1;\n\tconst struct transit *transit2 = p2;\n\n\treturn (transit1->length == transit2->length\n\t\t&& memcmp(transit1->val, transit2->val, transit1->length) == 0);\n}\n\nstatic void transit_init(void)\n{\n\ttransit_hash = hash_create(transit_hash_key_make, transit_hash_cmp,\n\t\t\t\t   \"BGP Transit Hash\");\n}\n\nstatic void transit_finish(void)\n{\n\thash_clean(transit_hash, (void (*)(void *))transit_free);\n\thash_free(transit_hash);\n\ttransit_hash = NULL;\n}\n\n/* Attribute hash routines. */\nstatic struct hash *attrhash;\n\n/* Shallow copy of an attribute\n * Though, not so shallow that it doesn't copy the contents\n * of the attr_extra pointed to by 'extra'\n */\nvoid bgp_attr_dup(struct attr *new, struct attr *orig)\n{\n\t*new = *orig;\n}\n\nunsigned long int attr_count(void)\n{\n\treturn attrhash->count;\n}\n\nunsigned long int attr_unknown_count(void)\n{\n\treturn transit_hash->count;\n}\n\nunsigned int attrhash_key_make(void *p)\n{\n\tconst struct attr *attr = (struct attr *)p;\n\tuint32_t key = 0;\n#define MIX(val)\tkey = jhash_1word(val, key)\n#define MIX3(a, b, c)\tkey = jhash_3words((a), (b), (c), key)\n\n\tMIX3(attr->origin, attr->nexthop.s_addr, attr->med);\n\tMIX3(attr->local_pref, attr->aggregator_as,\n\t     attr->aggregator_addr.s_addr);\n\tMIX3(attr->weight, attr->mp_nexthop_global_in.s_addr,\n\t     attr->originator_id.s_addr);\n\tMIX3(attr->tag, attr->label, attr->label_index);\n\n\tif (attr->aspath)\n\t\tMIX(aspath_key_make(attr->aspath));\n\tif (attr->community)\n\t\tMIX(community_hash_make(attr->community));\n\n\tif (attr->lcommunity)\n\t\tMIX(lcommunity_hash_make(attr->lcommunity));\n\tif (attr->ecommunity)\n\t\tMIX(ecommunity_hash_make(attr->ecommunity));\n\tif (attr->cluster)\n\t\tMIX(cluster_hash_key_make(attr->cluster));\n\tif (attr->transit)\n\t\tMIX(transit_hash_key_make(attr->transit));\n\tif (attr->encap_subtlvs)\n\t\tMIX(encap_hash_key_make(attr->encap_subtlvs));\n#if ENABLE_BGP_VNC\n\tif (attr->vnc_subtlvs)\n\t\tMIX(encap_hash_key_make(attr->vnc_subtlvs));\n#endif\n\tMIX(attr->mp_nexthop_len);\n\tkey = jhash(attr->mp_nexthop_global.s6_addr, IPV6_MAX_BYTELEN, key);\n\tkey = jhash(attr->mp_nexthop_local.s6_addr, IPV6_MAX_BYTELEN, key);\n\tMIX(attr->nh_ifindex);\n\tMIX(attr->nh_lla_ifindex);\n\n\treturn key;\n}\n\nbool attrhash_cmp(const void *p1, const void *p2)\n{\n\tconst struct attr *attr1 = p1;\n\tconst struct attr *attr2 = p2;\n\n\tif (attr1->flag == attr2->flag && attr1->origin == attr2->origin\n\t    && attr1->nexthop.s_addr == attr2->nexthop.s_addr\n\t    && attr1->aspath == attr2->aspath\n\t    && attr1->community == attr2->community && attr1->med == attr2->med\n\t    && attr1->local_pref == attr2->local_pref\n\t    && attr1->rmap_change_flags == attr2->rmap_change_flags) {\n\t\tif (attr1->aggregator_as == attr2->aggregator_as\n\t\t    && attr1->aggregator_addr.s_addr\n\t\t\t       == attr2->aggregator_addr.s_addr\n\t\t    && attr1->weight == attr2->weight\n\t\t    && attr1->tag == attr2->tag\n\t\t    && attr1->label_index == attr2->label_index\n\t\t    && attr1->mp_nexthop_len == attr2->mp_nexthop_len\n\t\t    && attr1->ecommunity == attr2->ecommunity\n\t\t    && attr1->lcommunity == attr2->lcommunity\n\t\t    && attr1->cluster == attr2->cluster\n\t\t    && attr1->transit == attr2->transit\n\t\t    && (attr1->encap_tunneltype == attr2->encap_tunneltype)\n\t\t    && encap_same(attr1->encap_subtlvs, attr2->encap_subtlvs)\n#if ENABLE_BGP_VNC\n\t\t    && encap_same(attr1->vnc_subtlvs, attr2->vnc_subtlvs)\n#endif\n\t\t    && IPV6_ADDR_SAME(&attr1->mp_nexthop_global,\n\t\t\t\t      &attr2->mp_nexthop_global)\n\t\t    && IPV6_ADDR_SAME(&attr1->mp_nexthop_local,\n\t\t\t\t      &attr2->mp_nexthop_local)\n\t\t    && IPV4_ADDR_SAME(&attr1->mp_nexthop_global_in,\n\t\t\t\t      &attr2->mp_nexthop_global_in)\n\t\t    && IPV4_ADDR_SAME(&attr1->originator_id,\n\t\t\t\t      &attr2->originator_id)\n\t\t    && overlay_index_same(attr1, attr2)\n\t\t    && attr1->nh_ifindex == attr2->nh_ifindex\n\t\t    && attr1->nh_lla_ifindex == attr2->nh_lla_ifindex)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void attrhash_init(void)\n{\n\tattrhash =\n\t\thash_create(attrhash_key_make, attrhash_cmp, \"BGP Attributes\");\n}\n\n/*\n * special for hash_clean below\n */\nstatic void attr_vfree(void *attr)\n{\n\tXFREE(MTYPE_ATTR, attr);\n}\n\nstatic void attrhash_finish(void)\n{\n\thash_clean(attrhash, attr_vfree);\n\thash_free(attrhash);\n\tattrhash = NULL;\n}\n\nstatic void attr_show_all_iterator(struct hash_backet *backet, struct vty *vty)\n{\n\tstruct attr *attr = backet->data;\n\n\tvty_out(vty, \"attr[%ld] nexthop %s\\n\", attr->refcnt,\n\t\tinet_ntoa(attr->nexthop));\n\tvty_out(vty, \"\\tflags: %\" PRIu64 \" med: %u local_pref: %u origin: %u weight: %u label: %u\\n\",\n\t\tattr->flag, attr->med, attr->local_pref, attr->origin,\n\t\tattr->weight, attr->label);\n}\n\nvoid attr_show_all(struct vty *vty)\n{\n\thash_iterate(attrhash, (void (*)(struct hash_backet *,\n\t\t\t\t\t void *))attr_show_all_iterator,\n\t\t     vty);\n}\n\nstatic void *bgp_attr_hash_alloc(void *p)\n{\n\tstruct attr *val = (struct attr *)p;\n\tstruct attr *attr;\n\n\tattr = XMALLOC(MTYPE_ATTR, sizeof(struct attr));\n\t*attr = *val;\n\tif (val->encap_subtlvs) {\n\t\tval->encap_subtlvs = NULL;\n\t}\n#if ENABLE_BGP_VNC\n\tif (val->vnc_subtlvs) {\n\t\tval->vnc_subtlvs = NULL;\n\t}\n#endif\n\tattr->refcnt = 0;\n\treturn attr;\n}\n\n/* Internet argument attribute. */\nstruct attr *bgp_attr_intern(struct attr *attr)\n{\n\tstruct attr *find;\n\n\t/* Intern referenced strucutre. */\n\tif (attr->aspath) {\n\t\tif (!attr->aspath->refcnt)\n\t\t\tattr->aspath = aspath_intern(attr->aspath);\n\t\telse\n\t\t\tattr->aspath->refcnt++;\n\t}\n\tif (attr->community) {\n\t\tif (!attr->community->refcnt)\n\t\t\tattr->community = community_intern(attr->community);\n\t\telse\n\t\t\tattr->community->refcnt++;\n\t}\n\n\tif (attr->ecommunity) {\n\t\tif (!attr->ecommunity->refcnt)\n\t\t\tattr->ecommunity = ecommunity_intern(attr->ecommunity);\n\t\telse\n\t\t\tattr->ecommunity->refcnt++;\n\t}\n\tif (attr->lcommunity) {\n\t\tif (!attr->lcommunity->refcnt)\n\t\t\tattr->lcommunity = lcommunity_intern(attr->lcommunity);\n\t\telse\n\t\t\tattr->lcommunity->refcnt++;\n\t}\n\tif (attr->cluster) {\n\t\tif (!attr->cluster->refcnt)\n\t\t\tattr->cluster = cluster_intern(attr->cluster);\n\t\telse\n\t\t\tattr->cluster->refcnt++;\n\t}\n\tif (attr->transit) {\n\t\tif (!attr->transit->refcnt)\n\t\t\tattr->transit = transit_intern(attr->transit);\n\t\telse\n\t\t\tattr->transit->refcnt++;\n\t}\n\tif (attr->encap_subtlvs) {\n\t\tif (!attr->encap_subtlvs->refcnt)\n\t\t\tattr->encap_subtlvs = encap_intern(attr->encap_subtlvs,\n\t\t\t\t\t\t\t   ENCAP_SUBTLV_TYPE);\n\t\telse\n\t\t\tattr->encap_subtlvs->refcnt++;\n\t}\n#if ENABLE_BGP_VNC\n\tif (attr->vnc_subtlvs) {\n\t\tif (!attr->vnc_subtlvs->refcnt)\n\t\t\tattr->vnc_subtlvs = encap_intern(attr->vnc_subtlvs,\n\t\t\t\t\t\t\t VNC_SUBTLV_TYPE);\n\t\telse\n\t\t\tattr->vnc_subtlvs->refcnt++;\n\t}\n#endif\n\n\t/* At this point, attr only contains intern'd pointers.  that means\n\t * if we find it in attrhash, it has all the same pointers and we\n\t * correctly updated the refcounts on these.\n\t * If we don't find it, we need to allocate a one because in all\n\t * cases this returns a new reference to a hashed attr, but the input\n\t * wasn't on hash. */\n\tfind = (struct attr *)hash_get(attrhash, attr, bgp_attr_hash_alloc);\n\tfind->refcnt++;\n\n\treturn find;\n}\n\n/* Make network statement's attribute. */\nstruct attr *bgp_attr_default_set(struct attr *attr, uint8_t origin)\n{\n\tmemset(attr, 0, sizeof(struct attr));\n\n\tattr->origin = origin;\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_ORIGIN);\n\tattr->aspath = aspath_empty();\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AS_PATH);\n\tattr->weight = BGP_ATTR_DEFAULT_WEIGHT;\n\tattr->tag = 0;\n\tattr->label_index = BGP_INVALID_LABEL_INDEX;\n\tattr->label = MPLS_INVALID_LABEL;\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP);\n\tattr->mp_nexthop_len = IPV6_MAX_BYTELEN;\n\n\treturn attr;\n}\n\n/* Create the attributes for an aggregate */\nstruct attr *bgp_attr_aggregate_intern(struct bgp *bgp, uint8_t origin,\n\t\t\t\t       struct aspath *aspath,\n\t\t\t\t       struct community *community,\n\t\t\t\t       struct ecommunity *ecommunity,\n\t\t\t\t       struct lcommunity *lcommunity,\n\t\t\t\t       int as_set, uint8_t atomic_aggregate)\n{\n\tstruct attr attr;\n\tstruct attr *new;\n\n\tmemset(&attr, 0, sizeof(struct attr));\n\n\t/* Origin attribute. */\n\tattr.origin = origin;\n\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_ORIGIN);\n\n\t/* AS path attribute. */\n\tif (aspath)\n\t\tattr.aspath = aspath_intern(aspath);\n\telse\n\t\tattr.aspath = aspath_empty();\n\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_AS_PATH);\n\n\t/* Next hop attribute.  */\n\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP);\n\n\tif (community) {\n\t\tuint32_t gshut = COMMUNITY_GSHUT;\n\n\t\t/* If we are not shutting down ourselves and we are\n\t\t * aggregating a route that contains the GSHUT community we\n\t\t * need to remove that community when creating the aggregate */\n\t\tif (!bgp_flag_check(bgp, BGP_FLAG_GRACEFUL_SHUTDOWN)\n\t\t    && community_include(community, gshut)) {\n\t\t\tcommunity_del_val(community, &gshut);\n\t\t}\n\n\t\tattr.community = community;\n\t\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES);\n\t}\n\n\tif (ecommunity) {\n\t\tattr.ecommunity = ecommunity;\n\t\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES);\n\t}\n\n\tif (lcommunity) {\n\t\tattr.lcommunity = lcommunity;\n\t\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES);\n\t}\n\n\tif (bgp_flag_check(bgp, BGP_FLAG_GRACEFUL_SHUTDOWN)) {\n\t\tbgp_attr_add_gshut_community(&attr);\n\t}\n\n\tattr.label_index = BGP_INVALID_LABEL_INDEX;\n\tattr.label = MPLS_INVALID_LABEL;\n\tattr.weight = BGP_ATTR_DEFAULT_WEIGHT;\n\tattr.mp_nexthop_len = IPV6_MAX_BYTELEN;\n\tif (!as_set || atomic_aggregate)\n\t\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE);\n\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR);\n\tif (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION))\n\t\tattr.aggregator_as = bgp->confed_id;\n\telse\n\t\tattr.aggregator_as = bgp->as;\n\tattr.aggregator_addr = bgp->router_id;\n\tattr.label_index = BGP_INVALID_LABEL_INDEX;\n\tattr.label = MPLS_INVALID_LABEL;\n\n\tnew = bgp_attr_intern(&attr);\n\n\taspath_unintern(&new->aspath);\n\treturn new;\n}\n\n/* Unintern just the sub-components of the attr, but not the attr */\nvoid bgp_attr_unintern_sub(struct attr *attr)\n{\n\t/* aspath refcount shoud be decrement. */\n\tif (attr->aspath)\n\t\taspath_unintern(&attr->aspath);\n\tUNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH));\n\n\tif (attr->community)\n\t\tcommunity_unintern(&attr->community);\n\tUNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES));\n\n\tif (attr->ecommunity)\n\t\tecommunity_unintern(&attr->ecommunity);\n\tUNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES));\n\n\tif (attr->lcommunity)\n\t\tlcommunity_unintern(&attr->lcommunity);\n\tUNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES));\n\n\tif (attr->cluster)\n\t\tcluster_unintern(attr->cluster);\n\tUNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_CLUSTER_LIST));\n\n\tif (attr->transit)\n\t\ttransit_unintern(attr->transit);\n\n\tif (attr->encap_subtlvs)\n\t\tencap_unintern(&attr->encap_subtlvs, ENCAP_SUBTLV_TYPE);\n\n#if ENABLE_BGP_VNC\n\tif (attr->vnc_subtlvs)\n\t\tencap_unintern(&attr->vnc_subtlvs, VNC_SUBTLV_TYPE);\n#endif\n}\n\n/*\n * We have some show commands that let you experimentally\n * apply a route-map.  When we apply the route-map\n * we are reseting values but not saving them for\n * posterity via intern'ing( because route-maps don't\n * do that) but at this point in time we need\n * to compare the new attr to the old and if the\n * routemap has changed it we need to, as Snoop Dog says,\n * Drop it like it's hot\n */\nvoid bgp_attr_undup(struct attr *new, struct attr *old)\n{\n\tif (new->aspath != old->aspath)\n\t\taspath_free(new->aspath);\n\n\tif (new->community != old->community)\n\t\tcommunity_free(&new->community);\n\n\tif (new->ecommunity != old->ecommunity)\n\t\tecommunity_free(&new->ecommunity);\n\n\tif (new->lcommunity != old->lcommunity)\n\t\tlcommunity_free(&new->lcommunity);\n}\n\n/* Free bgp attribute and aspath. */\nvoid bgp_attr_unintern(struct attr **pattr)\n{\n\tstruct attr *attr = *pattr;\n\tstruct attr *ret;\n\tstruct attr tmp;\n\n\t/* Decrement attribute reference. */\n\tattr->refcnt--;\n\n\ttmp = *attr;\n\n\t/* If reference becomes zero then free attribute object. */\n\tif (attr->refcnt == 0) {\n\t\tret = hash_release(attrhash, attr);\n\t\tassert(ret != NULL);\n\t\tXFREE(MTYPE_ATTR, attr);\n\t\t*pattr = NULL;\n\t}\n\n\tbgp_attr_unintern_sub(&tmp);\n}\n\nvoid bgp_attr_flush(struct attr *attr)\n{\n\tif (attr->aspath && !attr->aspath->refcnt) {\n\t\taspath_free(attr->aspath);\n\t\tattr->aspath = NULL;\n\t}\n\tif (attr->community && !attr->community->refcnt)\n\t\tcommunity_free(&attr->community);\n\tif (attr->ecommunity && !attr->ecommunity->refcnt)\n\t\tecommunity_free(&attr->ecommunity);\n\tif (attr->lcommunity && !attr->lcommunity->refcnt)\n\t\tlcommunity_free(&attr->lcommunity);\n\tif (attr->cluster && !attr->cluster->refcnt) {\n\t\tcluster_free(attr->cluster);\n\t\tattr->cluster = NULL;\n\t}\n\tif (attr->transit && !attr->transit->refcnt) {\n\t\ttransit_free(attr->transit);\n\t\tattr->transit = NULL;\n\t}\n\tif (attr->encap_subtlvs && !attr->encap_subtlvs->refcnt) {\n\t\tencap_free(attr->encap_subtlvs);\n\t\tattr->encap_subtlvs = NULL;\n\t}\n#if ENABLE_BGP_VNC\n\tif (attr->vnc_subtlvs && !attr->vnc_subtlvs->refcnt) {\n\t\tencap_free(attr->vnc_subtlvs);\n\t\tattr->vnc_subtlvs = NULL;\n\t}\n#endif\n}\n\n/* Implement draft-scudder-idr-optional-transitive behaviour and\n * avoid resetting sessions for malformed attributes which are\n * are partial/optional and hence where the error likely was not\n * introduced by the sending neighbour.\n */\nstatic bgp_attr_parse_ret_t\nbgp_attr_malformed(struct bgp_attr_parser_args *args, uint8_t subcode,\n\t\t   bgp_size_t length)\n{\n\tstruct peer *const peer = args->peer;\n\tconst uint8_t flags = args->flags;\n\t/* startp and length must be special-cased, as whether or not to\n\t * send the attribute data with the NOTIFY depends on the error,\n\t * the caller therefore signals this with the seperate length argument\n\t */\n\tuint8_t *notify_datap = (length > 0 ? args->startp : NULL);\n\n\t/* Only relax error handling for eBGP peers */\n\tif (peer->sort != BGP_PEER_EBGP) {\n\t\tbgp_notify_send_with_data(peer, BGP_NOTIFY_UPDATE_ERR, subcode,\n\t\t\t\t\t  notify_datap, length);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\t/* Adjust the stream getp to the end of the attribute, in case we can\n\t * still proceed but the caller hasn't read all the attribute.\n\t */\n\tstream_set_getp(BGP_INPUT(peer),\n\t\t\t(args->startp - STREAM_DATA(BGP_INPUT(peer)))\n\t\t\t\t+ args->total);\n\n\tswitch (args->type) {\n\t/* where an attribute is relatively inconsequential, e.g. it does not\n\t * affect route selection, and can be safely ignored, then any such\n\t * attributes which are malformed should just be ignored and the route\n\t * processed as normal.\n\t */\n\tcase BGP_ATTR_AS4_AGGREGATOR:\n\tcase BGP_ATTR_AGGREGATOR:\n\tcase BGP_ATTR_ATOMIC_AGGREGATE:\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\n\t/* Core attributes, particularly ones which may influence route\n\t * selection, should always cause session resets\n\t */\n\tcase BGP_ATTR_ORIGIN:\n\tcase BGP_ATTR_AS_PATH:\n\tcase BGP_ATTR_NEXT_HOP:\n\tcase BGP_ATTR_MULTI_EXIT_DISC:\n\tcase BGP_ATTR_LOCAL_PREF:\n\tcase BGP_ATTR_COMMUNITIES:\n\tcase BGP_ATTR_ORIGINATOR_ID:\n\tcase BGP_ATTR_CLUSTER_LIST:\n\tcase BGP_ATTR_MP_REACH_NLRI:\n\tcase BGP_ATTR_MP_UNREACH_NLRI:\n\tcase BGP_ATTR_EXT_COMMUNITIES:\n\t\tbgp_notify_send_with_data(peer, BGP_NOTIFY_UPDATE_ERR, subcode,\n\t\t\t\t\t  notify_datap, length);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\t/* Partial optional attributes that are malformed should not cause\n\t * the whole session to be reset. Instead treat it as a withdrawal\n\t * of the routes, if possible.\n\t */\n\tif (CHECK_FLAG(flags, BGP_ATTR_FLAG_TRANS)\n\t    && CHECK_FLAG(flags, BGP_ATTR_FLAG_OPTIONAL)\n\t    && CHECK_FLAG(flags, BGP_ATTR_FLAG_PARTIAL))\n\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\n\t/* default to reset */\n\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n}\n\n/* Find out what is wrong with the path attribute flag bits and log the error.\n   \"Flag bits\" here stand for Optional, Transitive and Partial, but not for\n   Extended Length. Checking O/T/P bits at once implies, that the attribute\n   being diagnosed is defined by RFC as either a \"well-known\" or an \"optional,\n   non-transitive\" attribute. */\nstatic void\nbgp_attr_flags_diagnose(struct bgp_attr_parser_args *args,\n\t\t\tuint8_t desired_flags /* how RFC says it must be */\n)\n{\n\tuint8_t seen = 0, i;\n\tuint8_t real_flags = args->flags;\n\tconst uint8_t attr_code = args->type;\n\n\tdesired_flags &= ~BGP_ATTR_FLAG_EXTLEN;\n\treal_flags &= ~BGP_ATTR_FLAG_EXTLEN;\n\tfor (i = 0; i <= 2; i++) /* O,T,P, but not E */\n\t\tif (CHECK_FLAG(desired_flags, attr_flag_str[i].key)\n\t\t    != CHECK_FLAG(real_flags, attr_flag_str[i].key)) {\n\t\t\tflog_err(EC_BGP_ATTR_FLAG,\n\t\t\t\t \"%s attribute must%s be flagged as \\\"%s\\\"\",\n\t\t\t\t lookup_msg(attr_str, attr_code, NULL),\n\t\t\t\t CHECK_FLAG(desired_flags, attr_flag_str[i].key)\n\t\t\t\t\t ? \"\"\n\t\t\t\t\t : \" not\",\n\t\t\t\t attr_flag_str[i].str);\n\t\t\tseen = 1;\n\t\t}\n\tif (!seen) {\n\t\tzlog_debug(\n\t\t\t\"Strange, %s called for attr %s, but no problem found with flags\"\n\t\t\t\" (real flags 0x%x, desired 0x%x)\",\n\t\t\t__func__, lookup_msg(attr_str, attr_code, NULL),\n\t\t\treal_flags, desired_flags);\n\t}\n}\n\n/* Required flags for attributes. EXTLEN will be masked off when testing,\n * as will PARTIAL for optional+transitive attributes.\n */\nconst uint8_t attr_flags_values[] = {\n\t[BGP_ATTR_ORIGIN] = BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_AS_PATH] = BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_NEXT_HOP] = BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_MULTI_EXIT_DISC] = BGP_ATTR_FLAG_OPTIONAL,\n\t[BGP_ATTR_LOCAL_PREF] = BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_ATOMIC_AGGREGATE] = BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_AGGREGATOR] = BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL,\n\t[BGP_ATTR_COMMUNITIES] = BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL,\n\t[BGP_ATTR_ORIGINATOR_ID] = BGP_ATTR_FLAG_OPTIONAL,\n\t[BGP_ATTR_CLUSTER_LIST] = BGP_ATTR_FLAG_OPTIONAL,\n\t[BGP_ATTR_MP_REACH_NLRI] = BGP_ATTR_FLAG_OPTIONAL,\n\t[BGP_ATTR_MP_UNREACH_NLRI] = BGP_ATTR_FLAG_OPTIONAL,\n\t[BGP_ATTR_EXT_COMMUNITIES] =\n\t\tBGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_AS4_PATH] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_AS4_AGGREGATOR] =\n\t\tBGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_PMSI_TUNNEL] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_LARGE_COMMUNITIES] =\n\t\tBGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_PREFIX_SID] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,\n};\nstatic const size_t attr_flags_values_max = array_size(attr_flags_values) - 1;\n\nstatic int bgp_attr_flag_invalid(struct bgp_attr_parser_args *args)\n{\n\tuint8_t mask = BGP_ATTR_FLAG_EXTLEN;\n\tconst uint8_t flags = args->flags;\n\tconst uint8_t attr_code = args->type;\n\n\t/* there may be attributes we don't know about */\n\tif (attr_code > attr_flags_values_max)\n\t\treturn 0;\n\tif (attr_flags_values[attr_code] == 0)\n\t\treturn 0;\n\n\t/* RFC4271, \"For well-known attributes, the Transitive bit MUST be set\n\t * to\n\t * 1.\"\n\t */\n\tif (!CHECK_FLAG(BGP_ATTR_FLAG_OPTIONAL, flags)\n\t    && !CHECK_FLAG(BGP_ATTR_FLAG_TRANS, flags)) {\n\t\tflog_err(\n\t\t\tEC_BGP_ATTR_FLAG,\n\t\t\t\"%s well-known attributes must have transitive flag set (%x)\",\n\t\t\tlookup_msg(attr_str, attr_code, NULL), flags);\n\t\treturn 1;\n\t}\n\n\t/* \"For well-known attributes and for optional non-transitive\n\t * attributes,\n\t *  the Partial bit MUST be set to 0.\"\n\t */\n\tif (CHECK_FLAG(flags, BGP_ATTR_FLAG_PARTIAL)) {\n\t\tif (!CHECK_FLAG(flags, BGP_ATTR_FLAG_OPTIONAL)) {\n\t\t\tflog_err(EC_BGP_ATTR_FLAG,\n\t\t\t\t \"%s well-known attribute \"\n\t\t\t\t \"must NOT have the partial flag set (%x)\",\n\t\t\t\t lookup_msg(attr_str, attr_code, NULL), flags);\n\t\t\treturn 1;\n\t\t}\n\t\tif (CHECK_FLAG(flags, BGP_ATTR_FLAG_OPTIONAL)\n\t\t    && !CHECK_FLAG(flags, BGP_ATTR_FLAG_TRANS)) {\n\t\t\tflog_err(EC_BGP_ATTR_FLAG,\n\t\t\t\t \"%s optional + transitive attribute \"\n\t\t\t\t \"must NOT have the partial flag set (%x)\",\n\t\t\t\t lookup_msg(attr_str, attr_code, NULL), flags);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Optional transitive attributes may go through speakers that don't\n\t * reocgnise them and set the Partial bit.\n\t */\n\tif (CHECK_FLAG(flags, BGP_ATTR_FLAG_OPTIONAL)\n\t    && CHECK_FLAG(flags, BGP_ATTR_FLAG_TRANS))\n\t\tSET_FLAG(mask, BGP_ATTR_FLAG_PARTIAL);\n\n\tif ((flags & ~mask) == attr_flags_values[attr_code])\n\t\treturn 0;\n\n\tbgp_attr_flags_diagnose(args, attr_flags_values[attr_code]);\n\treturn 1;\n}\n\n/* Get origin attribute of the update message. */\nstatic bgp_attr_parse_ret_t bgp_attr_origin(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/* If any recognized attribute has Attribute Length that conflicts\n\t   with the expected length (based on the attribute type code), then\n\t   the Error Subcode is set to Attribute Length Error.  The Data\n\t   field contains the erroneous attribute (type, length and\n\t   value). */\n\tif (length != 1) {\n\t\tflog_err(EC_BGP_ATTR_LEN,\n\t\t\t \"Origin attribute length is not one %d\", length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\t/* Fetch origin attribute. */\n\tattr->origin = stream_getc(BGP_INPUT(peer));\n\n\t/* If the ORIGIN attribute has an undefined value, then the Error\n\t   Subcode is set to Invalid Origin Attribute.  The Data field\n\t   contains the unrecognized attribute (type, length and value). */\n\tif ((attr->origin != BGP_ORIGIN_IGP) && (attr->origin != BGP_ORIGIN_EGP)\n\t    && (attr->origin != BGP_ORIGIN_INCOMPLETE)) {\n\t\tflog_err(EC_BGP_ATTR_ORIGIN,\n\t\t\t \"Origin attribute value is invalid %d\", attr->origin);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_INVAL_ORIGIN,\n\t\t\t\t\t  args->total);\n\t}\n\n\t/* Set oring attribute flag. */\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_ORIGIN);\n\n\treturn 0;\n}\n\n/* Parse AS path information.  This function is wrapper of\n   aspath_parse. */\nstatic int bgp_attr_aspath(struct bgp_attr_parser_args *args)\n{\n\tstruct attr *const attr = args->attr;\n\tstruct peer *const peer = args->peer;\n\tconst bgp_size_t length = args->length;\n\n\t/*\n\t * peer with AS4 => will get 4Byte ASnums\n\t * otherwise, will get 16 Bit\n\t */\n\tattr->aspath = aspath_parse(peer->curr, length,\n\t\t\t\t    CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV));\n\n\t/* In case of IBGP, length will be zero. */\n\tif (!attr->aspath) {\n\t\tflog_err(EC_BGP_ATTR_MAL_AS_PATH,\n\t\t\t \"Malformed AS path from %s, length is %d\", peer->host,\n\t\t\t length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_MAL_AS_PATH,\n\t\t\t\t\t  0);\n\t}\n\n\t/* Set aspath attribute flag. */\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AS_PATH);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\nstatic bgp_attr_parse_ret_t bgp_attr_aspath_check(struct peer *const peer,\n\t\t\t\t\t\t  struct attr *const attr)\n{\n\t/* These checks were part of bgp_attr_aspath, but with\n\t * as4 we should to check aspath things when\n\t * aspath synthesizing with as4_path has already taken place.\n\t * Otherwise we check ASPATH and use the synthesized thing, and that is\n\t * not right.\n\t * So do the checks later, i.e. here\n\t */\n\tstruct aspath *aspath;\n\n\t/* Confederation sanity check. */\n\tif ((peer->sort == BGP_PEER_CONFED\n\t     && !aspath_left_confed_check(attr->aspath))\n\t    || (peer->sort == BGP_PEER_EBGP\n\t\t&& aspath_confed_check(attr->aspath))) {\n\t\tflog_err(EC_BGP_ATTR_MAL_AS_PATH, \"Malformed AS path from %s\",\n\t\t\t peer->host);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_AS_PATH);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\t/* First AS check for EBGP. */\n\tif (CHECK_FLAG(peer->flags, PEER_FLAG_ENFORCE_FIRST_AS)) {\n\t\tif (peer->sort == BGP_PEER_EBGP\n\t\t    && !aspath_firstas_check(attr->aspath, peer->as)) {\n\t\t\tflog_err(EC_BGP_ATTR_FIRST_AS,\n\t\t\t\t \"%s incorrect first AS (must be %u)\",\n\t\t\t\t peer->host, peer->as);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_MAL_AS_PATH);\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\t}\n\n\t/* local-as prepend */\n\tif (peer->change_local_as\n\t    && !CHECK_FLAG(peer->flags, PEER_FLAG_LOCAL_AS_NO_PREPEND)) {\n\t\taspath = aspath_dup(attr->aspath);\n\t\taspath = aspath_add_seq(aspath, peer->change_local_as);\n\t\taspath_unintern(&attr->aspath);\n\t\tattr->aspath = aspath_intern(aspath);\n\t}\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Parse AS4 path information.  This function is another wrapper of\n   aspath_parse. */\nstatic int bgp_attr_as4_path(struct bgp_attr_parser_args *args,\n\t\t\t     struct aspath **as4_path)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t*as4_path = aspath_parse(peer->curr, length, 1);\n\n\t/* In case of IBGP, length will be zero. */\n\tif (!*as4_path) {\n\t\tflog_err(EC_BGP_ATTR_MAL_AS_PATH,\n\t\t\t \"Malformed AS4 path from %s, length is %d\", peer->host,\n\t\t\t length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_MAL_AS_PATH,\n\t\t\t\t\t  0);\n\t}\n\n\t/* Set aspath attribute flag. */\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AS4_PATH);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Nexthop attribute. */\nstatic bgp_attr_parse_ret_t bgp_attr_nexthop(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\tin_addr_t nexthop_h, nexthop_n;\n\n\t/* Check nexthop attribute length. */\n\tif (length != 4) {\n\t\tflog_err(EC_BGP_ATTR_LEN,\n\t\t\t \"Nexthop attribute length isn't four [%d]\", length);\n\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\t/* According to section 6.3 of RFC4271, syntactically incorrect NEXT_HOP\n\t   attribute must result in a NOTIFICATION message (this is implemented\n\t   below).\n\t   At the same time, semantically incorrect NEXT_HOP is more likely to\n\t   be just\n\t   logged locally (this is implemented somewhere else). The UPDATE\n\t   message\n\t   gets ignored in any of these cases. */\n\tnexthop_n = stream_get_ipv4(peer->curr);\n\tnexthop_h = ntohl(nexthop_n);\n\tif ((IPV4_NET0(nexthop_h) || IPV4_NET127(nexthop_h)\n\t     || IPV4_CLASS_DE(nexthop_h))\n\t    && !BGP_DEBUG(\n\t\t       allow_martians,\n\t\t       ALLOW_MARTIANS)) /* loopbacks may be used in testing */\n\t{\n\t\tchar buf[INET_ADDRSTRLEN];\n\t\tinet_ntop(AF_INET, &nexthop_n, buf, INET_ADDRSTRLEN);\n\t\tflog_err(EC_BGP_ATTR_MARTIAN_NH, \"Martian nexthop %s\", buf);\n\t\treturn bgp_attr_malformed(\n\t\t\targs, BGP_NOTIFY_UPDATE_INVAL_NEXT_HOP, args->total);\n\t}\n\n\tattr->nexthop.s_addr = nexthop_n;\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* MED atrribute. */\nstatic bgp_attr_parse_ret_t bgp_attr_med(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/* Length check. */\n\tif (length != 4) {\n\t\tflog_err(EC_BGP_ATTR_LEN,\n\t\t\t \"MED attribute length isn't four [%d]\", length);\n\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\tattr->med = stream_getl(peer->curr);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Local preference attribute. */\nstatic bgp_attr_parse_ret_t\nbgp_attr_local_pref(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/* Length check. */\n\tif (length != 4) {\n\t\tflog_err(EC_BGP_ATTR_LEN,\n\t\t\t \"LOCAL_PREF attribute length isn't 4 [%u]\", length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\t/* If it is contained in an UPDATE message that is received from an\n\t   external peer, then this attribute MUST be ignored by the\n\t   receiving speaker. */\n\tif (peer->sort == BGP_PEER_EBGP) {\n\t\tstream_forward_getp(peer->curr, length);\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\t}\n\n\tattr->local_pref = stream_getl(peer->curr);\n\n\t/* Set the local-pref flag. */\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Atomic aggregate. */\nstatic int bgp_attr_atomic(struct bgp_attr_parser_args *args)\n{\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/* Length check. */\n\tif (length != 0) {\n\t\tflog_err(EC_BGP_ATTR_LEN,\n\t\t\t \"ATOMIC_AGGREGATE attribute length isn't 0 [%u]\",\n\t\t\t length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\t/* Set atomic aggregate flag. */\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Aggregator attribute */\nstatic int bgp_attr_aggregator(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\tint wantedlen = 6;\n\n\t/* peer with AS4 will send 4 Byte AS, peer without will send 2 Byte */\n\tif (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV))\n\t\twantedlen = 8;\n\n\tif (length != wantedlen) {\n\t\tflog_err(EC_BGP_ATTR_LEN,\n\t\t\t \"AGGREGATOR attribute length isn't %u [%u]\", wantedlen,\n\t\t\t length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\tif (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV))\n\t\tattr->aggregator_as = stream_getl(peer->curr);\n\telse\n\t\tattr->aggregator_as = stream_getw(peer->curr);\n\tattr->aggregator_addr.s_addr = stream_get_ipv4(peer->curr);\n\n\t/* Set atomic aggregate flag. */\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* New Aggregator attribute */\nstatic bgp_attr_parse_ret_t\nbgp_attr_as4_aggregator(struct bgp_attr_parser_args *args,\n\t\t\tas_t *as4_aggregator_as,\n\t\t\tstruct in_addr *as4_aggregator_addr)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\tif (length != 8) {\n\t\tflog_err(EC_BGP_ATTR_LEN, \"New Aggregator length is not 8 [%d]\",\n\t\t\t length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  0);\n\t}\n\n\t*as4_aggregator_as = stream_getl(peer->curr);\n\tas4_aggregator_addr->s_addr = stream_get_ipv4(peer->curr);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AS4_AGGREGATOR);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Munge Aggregator and New-Aggregator, AS_PATH and NEW_AS_PATH.\n */\nstatic bgp_attr_parse_ret_t\nbgp_attr_munge_as4_attrs(struct peer *const peer, struct attr *const attr,\n\t\t\t struct aspath *as4_path, as_t as4_aggregator,\n\t\t\t struct in_addr *as4_aggregator_addr)\n{\n\tint ignore_as4_path = 0;\n\tstruct aspath *newpath;\n\n\tif (!attr->aspath) {\n\t\t/* NULL aspath shouldn't be possible as bgp_attr_parse should\n\t\t * have\n\t\t * checked that all well-known, mandatory attributes were\n\t\t * present.\n\t\t *\n\t\t * Can only be a problem with peer itself - hard error\n\t\t */\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\tif (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV)) {\n\t\t/* peer can do AS4, so we ignore AS4_PATH and AS4_AGGREGATOR\n\t\t * if given.\n\t\t * It is worth a warning though, because the peer really\n\t\t * should not send them\n\t\t */\n\t\tif (BGP_DEBUG(as4, AS4)) {\n\t\t\tif (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS4_PATH)))\n\t\t\t\tzlog_debug(\"[AS4] %s %s AS4_PATH\", peer->host,\n\t\t\t\t\t   \"AS4 capable peer, yet it sent\");\n\n\t\t\tif (attr->flag\n\t\t\t    & (ATTR_FLAG_BIT(BGP_ATTR_AS4_AGGREGATOR)))\n\t\t\t\tzlog_debug(\"[AS4] %s %s AS4_AGGREGATOR\",\n\t\t\t\t\t   peer->host,\n\t\t\t\t\t   \"AS4 capable peer, yet it sent\");\n\t\t}\n\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\t}\n\n\t/* We have a asn16 peer.  First, look for AS4_AGGREGATOR\n\t * because that may override AS4_PATH\n\t */\n\tif (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS4_AGGREGATOR))) {\n\t\tif (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR))) {\n\t\t\t/* received both.\n\t\t\t * if the as_number in aggregator is not AS_TRANS,\n\t\t\t *  then AS4_AGGREGATOR and AS4_PATH shall be ignored\n\t\t\t *        and the Aggregator shall be taken as\n\t\t\t *        info on the aggregating node, and the AS_PATH\n\t\t\t *        shall be taken as the AS_PATH\n\t\t\t *  otherwise\n\t\t\t *        the Aggregator shall be ignored and the\n\t\t\t *        AS4_AGGREGATOR shall be taken as the\n\t\t\t *        Aggregating node and the AS_PATH is to be\n\t\t\t *        constructed \"as in all other cases\"\n\t\t\t */\n\t\t\tif (attr->aggregator_as != BGP_AS_TRANS) {\n\t\t\t\t/* ignore */\n\t\t\t\tif (BGP_DEBUG(as4, AS4))\n\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\"[AS4] %s BGP not AS4 capable peer\"\n\t\t\t\t\t\t\" send AGGREGATOR != AS_TRANS and\"\n\t\t\t\t\t\t\" AS4_AGGREGATOR, so ignore\"\n\t\t\t\t\t\t\" AS4_AGGREGATOR and AS4_PATH\",\n\t\t\t\t\t\tpeer->host);\n\t\t\t\tignore_as4_path = 1;\n\t\t\t} else {\n\t\t\t\t/* \"New_aggregator shall be taken as aggregator\"\n\t\t\t\t */\n\t\t\t\tattr->aggregator_as = as4_aggregator;\n\t\t\t\tattr->aggregator_addr.s_addr =\n\t\t\t\t\tas4_aggregator_addr->s_addr;\n\t\t\t}\n\t\t} else {\n\t\t\t/* We received a AS4_AGGREGATOR but no AGGREGATOR.\n\t\t\t * That is bogus - but reading the conditions\n\t\t\t * we have to handle AS4_AGGREGATOR as if it were\n\t\t\t * AGGREGATOR in that case\n\t\t\t */\n\t\t\tif (BGP_DEBUG(as4, AS4))\n\t\t\t\tzlog_debug(\n\t\t\t\t\t\"[AS4] %s BGP not AS4 capable peer send\"\n\t\t\t\t\t\" AS4_AGGREGATOR but no AGGREGATOR, will take\"\n\t\t\t\t\t\" it as if AGGREGATOR with AS_TRANS had been there\",\n\t\t\t\t\tpeer->host);\n\t\t\tattr->aggregator_as = as4_aggregator;\n\t\t\t/* sweep it under the carpet and simulate a \"good\"\n\t\t\t * AGGREGATOR */\n\t\t\tattr->flag |= (ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR));\n\t\t}\n\t}\n\n\t/* need to reconcile NEW_AS_PATH and AS_PATH */\n\tif (!ignore_as4_path\n\t    && (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS4_PATH)))) {\n\t\tnewpath = aspath_reconcile_as4(attr->aspath, as4_path);\n\t\tif (!newpath)\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\n\t\taspath_unintern(&attr->aspath);\n\t\tattr->aspath = aspath_intern(newpath);\n\t}\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Community attribute. */\nstatic bgp_attr_parse_ret_t\nbgp_attr_community(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\tif (length == 0) {\n\t\tattr->community = NULL;\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\t}\n\n\tattr->community =\n\t\tcommunity_parse((uint32_t *)stream_pnt(peer->curr), length);\n\n\t/* XXX: fix community_parse to use stream API and remove this */\n\tstream_forward_getp(peer->curr, length);\n\n\tif (!attr->community)\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,\n\t\t\t\t\t  args->total);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Originator ID attribute. */\nstatic bgp_attr_parse_ret_t\nbgp_attr_originator_id(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/* Length check. */\n\tif (length != 4) {\n\t\tflog_err(EC_BGP_ATTR_LEN, \"Bad originator ID length %d\",\n\t\t\t length);\n\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\tattr->originator_id.s_addr = stream_get_ipv4(peer->curr);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Cluster list attribute. */\nstatic bgp_attr_parse_ret_t\nbgp_attr_cluster_list(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/* Check length. */\n\tif (length % 4) {\n\t\tflog_err(EC_BGP_ATTR_LEN, \"Bad cluster list length %d\", length);\n\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\tattr->cluster =\n\t\tcluster_parse((struct in_addr *)stream_pnt(peer->curr), length);\n\n\t/* XXX: Fix cluster_parse to use stream API and then remove this */\n\tstream_forward_getp(peer->curr, length);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_CLUSTER_LIST);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Multiprotocol reachability information parse. */\nint bgp_mp_reach_parse(struct bgp_attr_parser_args *args,\n\t\t       struct bgp_nlri *mp_update)\n{\n\tiana_afi_t pkt_afi;\n\tafi_t afi;\n\tiana_safi_t pkt_safi;\n\tsafi_t safi;\n\tbgp_size_t nlri_len;\n\tsize_t start;\n\tstruct stream *s;\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/* Set end of packet. */\n\ts = BGP_INPUT(peer);\n\tstart = stream_get_getp(s);\n\n/* safe to read statically sized header? */\n#define BGP_MP_REACH_MIN_SIZE 5\n#define LEN_LEFT\t(length - (stream_get_getp(s) - start))\n\tif ((length > STREAM_READABLE(s)) || (length < BGP_MP_REACH_MIN_SIZE)) {\n\t\tzlog_info(\"%s: %s sent invalid length, %lu\", __func__,\n\t\t\t  peer->host, (unsigned long)length);\n\t\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n\t}\n\n\t/* Load AFI, SAFI. */\n\tpkt_afi = stream_getw(s);\n\tpkt_safi = stream_getc(s);\n\n\t/* Convert AFI, SAFI to internal values, check. */\n\tif (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi, &safi)) {\n\t\t/* Log if AFI or SAFI is unrecognized. This is not an error\n\t\t * unless\n\t\t * the attribute is otherwise malformed.\n\t\t */\n\t\tif (bgp_debug_update(peer, NULL, NULL, 0))\n\t\t\tzlog_debug(\n\t\t\t\t\"%s: MP_REACH received AFI %u or SAFI %u is unrecognized\",\n\t\t\t\tpeer->host, pkt_afi, pkt_safi);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\t/* Get nexthop length. */\n\tattr->mp_nexthop_len = stream_getc(s);\n\n\tif (LEN_LEFT < attr->mp_nexthop_len) {\n\t\tzlog_info(\n\t\t\t\"%s: %s, MP nexthop length, %u, goes past end of attribute\",\n\t\t\t__func__, peer->host, attr->mp_nexthop_len);\n\t\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n\t}\n\n\t/* Nexthop length check. */\n\tswitch (attr->mp_nexthop_len) {\n\tcase 0:\n\t\tif (safi != SAFI_FLOWSPEC) {\n\t\t\tzlog_info(\"%s: (%s) Wrong multiprotocol next hop length: %d\",\n\t\t\t\t  __func__, peer->host, attr->mp_nexthop_len);\n\t\t\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n\t\t}\n\t\tbreak;\n\tcase BGP_ATTR_NHLEN_VPNV4:\n\t\tstream_getl(s); /* RD high */\n\t\tstream_getl(s); /* RD low */\n\t\t\t\t/*\n\t\t\t\t * NOTE: intentional fall through\n\t\t\t\t * - for consistency in rx processing\n\t\t\t\t *\n\t\t\t\t * The following comment is to signal GCC this intention\n\t\t\t\t * and suppress the warning\n\t\t\t\t */\n\t/* FALLTHRU */\n\tcase BGP_ATTR_NHLEN_IPV4:\n\t\tstream_get(&attr->mp_nexthop_global_in, s, IPV4_MAX_BYTELEN);\n\t\t/* Probably needed for RFC 2283 */\n\t\tif (attr->nexthop.s_addr == 0)\n\t\t\tmemcpy(&attr->nexthop.s_addr,\n\t\t\t       &attr->mp_nexthop_global_in, IPV4_MAX_BYTELEN);\n\t\tbreak;\n\tcase BGP_ATTR_NHLEN_IPV6_GLOBAL:\n\tcase BGP_ATTR_NHLEN_VPNV6_GLOBAL:\n\t\tif (attr->mp_nexthop_len == BGP_ATTR_NHLEN_VPNV6_GLOBAL) {\n\t\t\tstream_getl(s); /* RD high */\n\t\t\tstream_getl(s); /* RD low */\n\t\t}\n\t\tstream_get(&attr->mp_nexthop_global, s, IPV6_MAX_BYTELEN);\n\t\tif (IN6_IS_ADDR_LINKLOCAL(&attr->mp_nexthop_global)) {\n\t\t\tif (!peer->nexthop.ifp) {\n\t\t\t\tzlog_warn(\"%s: interface not set appropriately to handle some attributes\",\n\t\t\t\t\t  peer->host);\n\t\t\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\t\t\t}\n\t\t\tattr->nh_ifindex = peer->nexthop.ifp->ifindex;\n\t\t}\n\t\tbreak;\n\tcase BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL:\n\tcase BGP_ATTR_NHLEN_VPNV6_GLOBAL_AND_LL:\n\t\tif (attr->mp_nexthop_len\n\t\t    == BGP_ATTR_NHLEN_VPNV6_GLOBAL_AND_LL) {\n\t\t\tstream_getl(s); /* RD high */\n\t\t\tstream_getl(s); /* RD low */\n\t\t}\n\t\tstream_get(&attr->mp_nexthop_global, s, IPV6_MAX_BYTELEN);\n\t\tif (IN6_IS_ADDR_LINKLOCAL(&attr->mp_nexthop_global)) {\n\t\t\tif (!peer->nexthop.ifp) {\n\t\t\t\tzlog_warn(\"%s: interface not set appropriately to handle some attributes\",\n\t\t\t\t\t  peer->host);\n\t\t\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\t\t\t}\n\t\t\tattr->nh_ifindex = peer->nexthop.ifp->ifindex;\n\t\t}\n\t\tif (attr->mp_nexthop_len\n\t\t    == BGP_ATTR_NHLEN_VPNV6_GLOBAL_AND_LL) {\n\t\t\tstream_getl(s); /* RD high */\n\t\t\tstream_getl(s); /* RD low */\n\t\t}\n\t\tstream_get(&attr->mp_nexthop_local, s, IPV6_MAX_BYTELEN);\n\t\tif (!IN6_IS_ADDR_LINKLOCAL(&attr->mp_nexthop_local)) {\n\t\t\tchar buf1[INET6_ADDRSTRLEN];\n\t\t\tchar buf2[INET6_ADDRSTRLEN];\n\n\t\t\tif (bgp_debug_update(peer, NULL, NULL, 1))\n\t\t\t\tzlog_debug(\n\t\t\t\t\t\"%s rcvd nexthops %s, %s -- ignoring non-LL value\",\n\t\t\t\t\tpeer->host,\n\t\t\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t\t\t  &attr->mp_nexthop_global,\n\t\t\t\t\t\t  buf1, INET6_ADDRSTRLEN),\n\t\t\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t\t\t  &attr->mp_nexthop_local, buf2,\n\t\t\t\t\t\t  INET6_ADDRSTRLEN));\n\n\t\t\tattr->mp_nexthop_len = IPV6_MAX_BYTELEN;\n\t\t}\n\t\tif (!peer->nexthop.ifp) {\n\t\t\tzlog_warn(\"%s: Interface not set appropriately to handle this some attributes\",\n\t\t\t\t  peer->host);\n\t\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\t\t}\n\t\tattr->nh_lla_ifindex = peer->nexthop.ifp->ifindex;\n\t\tbreak;\n\tdefault:\n\t\tzlog_info(\"%s: (%s) Wrong multiprotocol next hop length: %d\",\n\t\t\t  __func__, peer->host, attr->mp_nexthop_len);\n\t\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n\t}\n\n\tif (!LEN_LEFT) {\n\t\tzlog_info(\"%s: (%s) Failed to read SNPA and NLRI(s)\", __func__,\n\t\t\t  peer->host);\n\t\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n\t}\n\n\t{\n\t\tuint8_t val;\n\t\tif ((val = stream_getc(s)))\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_DEFUNCT_SNPA_LEN,\n\t\t\t\t\"%s sent non-zero value, %u, for defunct SNPA-length field\",\n\t\t\t\tpeer->host, val);\n\t}\n\n\t/* must have nrli_len, what is left of the attribute */\n\tnlri_len = LEN_LEFT;\n\tif (nlri_len > STREAM_READABLE(s)) {\n\t\tzlog_info(\"%s: (%s) Failed to read NLRI\", __func__, peer->host);\n\t\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n\t}\n\n\tif (!nlri_len) {\n\t\tzlog_info(\"%s: (%s) No Reachability, Treating as a EOR marker\",\n\t\t\t  __func__, peer->host);\n\n\t\tmp_update->afi = afi;\n\t\tmp_update->safi = safi;\n\t\treturn BGP_ATTR_PARSE_EOR;\n\t}\n\n\tmp_update->afi = afi;\n\tmp_update->safi = safi;\n\tmp_update->nlri = stream_pnt(s);\n\tmp_update->length = nlri_len;\n\n\tstream_forward_getp(s, nlri_len);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n#undef LEN_LEFT\n}\n\n/* Multiprotocol unreachable parse */\nint bgp_mp_unreach_parse(struct bgp_attr_parser_args *args,\n\t\t\t struct bgp_nlri *mp_withdraw)\n{\n\tstruct stream *s;\n\tiana_afi_t pkt_afi;\n\tafi_t afi;\n\tiana_safi_t pkt_safi;\n\tsafi_t safi;\n\tuint16_t withdraw_len;\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\ts = peer->curr;\n\n#define BGP_MP_UNREACH_MIN_SIZE 3\n\tif ((length > STREAM_READABLE(s)) || (length < BGP_MP_UNREACH_MIN_SIZE))\n\t\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n\n\tpkt_afi = stream_getw(s);\n\tpkt_safi = stream_getc(s);\n\n\t/* Convert AFI, SAFI to internal values, check. */\n\tif (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi, &safi)) {\n\t\t/* Log if AFI or SAFI is unrecognized. This is not an error\n\t\t * unless\n\t\t * the attribute is otherwise malformed.\n\t\t */\n\t\tif (bgp_debug_update(peer, NULL, NULL, 0))\n\t\t\tzlog_debug(\n\t\t\t\t\"%s: MP_UNREACH received AFI %u or SAFI %u is unrecognized\",\n\t\t\t\tpeer->host, pkt_afi, pkt_safi);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\twithdraw_len = length - BGP_MP_UNREACH_MIN_SIZE;\n\n\tmp_withdraw->afi = afi;\n\tmp_withdraw->safi = safi;\n\tmp_withdraw->nlri = stream_pnt(s);\n\tmp_withdraw->length = withdraw_len;\n\n\tstream_forward_getp(s, withdraw_len);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Large Community attribute. */\nstatic bgp_attr_parse_ret_t\nbgp_attr_large_community(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/*\n\t * Large community follows new attribute format.\n\t */\n\tif (length == 0) {\n\t\tattr->lcommunity = NULL;\n\t\t/* Empty extcomm doesn't seem to be invalid per se */\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\t}\n\n\tattr->lcommunity =\n\t\tlcommunity_parse((uint8_t *)stream_pnt(peer->curr), length);\n\t/* XXX: fix ecommunity_parse to use stream API */\n\tstream_forward_getp(peer->curr, length);\n\n\tif (!attr->lcommunity)\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,\n\t\t\t\t\t  args->total);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Extended Community attribute. */\nstatic bgp_attr_parse_ret_t\nbgp_attr_ext_communities(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\tuint8_t sticky = 0;\n\n\tif (length == 0) {\n\t\tattr->ecommunity = NULL;\n\t\t/* Empty extcomm doesn't seem to be invalid per se */\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\t}\n\n\tattr->ecommunity =\n\t\tecommunity_parse((uint8_t *)stream_pnt(peer->curr), length);\n\t/* XXX: fix ecommunity_parse to use stream API */\n\tstream_forward_getp(peer->curr, length);\n\n\tif (!attr->ecommunity)\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,\n\t\t\t\t\t  args->total);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES);\n\n\t/* Extract MAC mobility sequence number, if any. */\n\tattr->mm_seqnum = bgp_attr_mac_mobility_seqnum(attr, &sticky);\n\tattr->sticky = sticky;\n\n\t/* Check if this is a Gateway MAC-IP advertisement */\n\tattr->default_gw = bgp_attr_default_gw(attr);\n\n\t/* Handle scenario where router flag ecommunity is not\n\t * set but default gw ext community is present.\n\t * Use default gateway, set and propogate R-bit.\n\t */\n\tif (attr->default_gw)\n\t\tattr->router_flag = 1;\n\n\t/* Check EVPN Neighbor advertisement flags, R-bit */\n\tbgp_attr_evpn_na_flag(attr, &attr->router_flag);\n\n\t/* Extract the Rmac, if any */\n\tbgp_attr_rmac(attr, &attr->rmac);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Parse Tunnel Encap attribute in an UPDATE */\nstatic int bgp_attr_encap(uint8_t type, struct peer *peer, /* IN */\n\t\t\t  bgp_size_t length, /* IN: attr's length field */\n\t\t\t  struct attr *attr, /* IN: caller already allocated */\n\t\t\t  uint8_t flag,      /* IN: attr's flags field */\n\t\t\t  uint8_t *startp)\n{\n\tbgp_size_t total;\n\tuint16_t tunneltype = 0;\n\n\ttotal = length + (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);\n\n\tif (!CHECK_FLAG(flag, BGP_ATTR_FLAG_TRANS)\n\t    || !CHECK_FLAG(flag, BGP_ATTR_FLAG_OPTIONAL)) {\n\t\tzlog_info(\n\t\t\t\"Tunnel Encap attribute flag isn't optional and transitive %d\",\n\t\t\tflag);\n\t\tbgp_notify_send_with_data(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t  BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,\n\t\t\t\t\t  startp, total);\n\t\treturn -1;\n\t}\n\n\tif (BGP_ATTR_ENCAP == type) {\n\t\t/* read outer TLV type and length */\n\t\tuint16_t tlv_length;\n\n\t\tif (length < 4) {\n\t\t\tzlog_info(\n\t\t\t\t\"Tunnel Encap attribute not long enough to contain outer T,L\");\n\t\t\tbgp_notify_send_with_data(\n\t\t\t\tpeer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_OPT_ATTR_ERR, startp, total);\n\t\t\treturn -1;\n\t\t}\n\t\ttunneltype = stream_getw(BGP_INPUT(peer));\n\t\ttlv_length = stream_getw(BGP_INPUT(peer));\n\t\tlength -= 4;\n\n\t\tif (tlv_length != length) {\n\t\t\tzlog_info(\"%s: tlv_length(%d) != length(%d)\", __func__,\n\t\t\t\t  tlv_length, length);\n\t\t}\n\t}\n\n\twhile (length >= 4) {\n\t\tuint16_t subtype = 0;\n\t\tuint16_t sublength = 0;\n\t\tstruct bgp_attr_encap_subtlv *tlv;\n\n\t\tif (BGP_ATTR_ENCAP == type) {\n\t\t\tsubtype = stream_getc(BGP_INPUT(peer));\n\t\t\tsublength = stream_getc(BGP_INPUT(peer));\n\t\t\tlength -= 2;\n#if ENABLE_BGP_VNC\n\t\t} else {\n\t\t\tsubtype = stream_getw(BGP_INPUT(peer));\n\t\t\tsublength = stream_getw(BGP_INPUT(peer));\n\t\t\tlength -= 4;\n#endif\n\t\t}\n\n\t\tif (sublength > length) {\n\t\t\tzlog_info(\n\t\t\t\t\"Tunnel Encap attribute sub-tlv length %d exceeds remaining length %d\",\n\t\t\t\tsublength, length);\n\t\t\tbgp_notify_send_with_data(\n\t\t\t\tpeer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_OPT_ATTR_ERR, startp, total);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* alloc and copy sub-tlv */\n\t\t/* TBD make sure these are freed when attributes are released */\n\t\ttlv = XCALLOC(MTYPE_ENCAP_TLV,\n\t\t\t      sizeof(struct bgp_attr_encap_subtlv) + sublength);\n\t\ttlv->type = subtype;\n\t\ttlv->length = sublength;\n\t\tstream_get(tlv->value, peer->curr, sublength);\n\t\tlength -= sublength;\n\n\t\t/* attach tlv to encap chain */\n\t\tif (BGP_ATTR_ENCAP == type) {\n\t\t\tstruct bgp_attr_encap_subtlv *stlv_last;\n\t\t\tfor (stlv_last = attr->encap_subtlvs;\n\t\t\t     stlv_last && stlv_last->next;\n\t\t\t     stlv_last = stlv_last->next)\n\t\t\t\t;\n\t\t\tif (stlv_last) {\n\t\t\t\tstlv_last->next = tlv;\n\t\t\t} else {\n\t\t\t\tattr->encap_subtlvs = tlv;\n\t\t\t}\n#if ENABLE_BGP_VNC\n\t\t} else {\n\t\t\tstruct bgp_attr_encap_subtlv *stlv_last;\n\t\t\tfor (stlv_last = attr->vnc_subtlvs;\n\t\t\t     stlv_last && stlv_last->next;\n\t\t\t     stlv_last = stlv_last->next)\n\t\t\t\t;\n\t\t\tif (stlv_last) {\n\t\t\t\tstlv_last->next = tlv;\n\t\t\t} else {\n\t\t\t\tattr->vnc_subtlvs = tlv;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\tif (BGP_ATTR_ENCAP == type) {\n\t\tattr->encap_tunneltype = tunneltype;\n\t}\n\n\tif (length) {\n\t\t/* spurious leftover data */\n\t\tzlog_info(\n\t\t\t\"Tunnel Encap attribute length is bad: %d leftover octets\",\n\t\t\tlength);\n\t\tbgp_notify_send_with_data(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t  BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,\n\t\t\t\t\t  startp, total);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Read an individual SID value returning how much data we have read\n * Returns 0 if there was an error that needs to be passed up the stack\n */\nstatic bgp_attr_parse_ret_t bgp_attr_psid_sub(int32_t type,\n\t\t\t\t\t      int32_t length,\n\t\t\t\t\t      struct bgp_attr_parser_args *args,\n\t\t\t\t\t      struct bgp_nlri *mp_update)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tuint32_t label_index;\n\tstruct in6_addr ipv6_sid;\n\tuint32_t srgb_base;\n\tuint32_t srgb_range;\n\tint srgb_count;\n\n\tif (type == BGP_PREFIX_SID_LABEL_INDEX) {\n\t\tif (length != BGP_PREFIX_SID_LABEL_INDEX_LENGTH) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_ATTR_LEN,\n\t\t\t\t\"Prefix SID label index length is %d instead of %d\",\n\t\t\t\tlength, BGP_PREFIX_SID_LABEL_INDEX_LENGTH);\n\t\t\treturn bgp_attr_malformed(args,\n\t\t\t\t\t\t  BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t\t  args->total);\n\t\t}\n\n\t\t/* Ignore flags and reserved */\n\t\tstream_getc(peer->curr);\n\t\tstream_getw(peer->curr);\n\n\t\t/* Fetch the label index and see if it is valid. */\n\t\tlabel_index = stream_getl(peer->curr);\n\t\tif (label_index == BGP_INVALID_LABEL_INDEX)\n\t\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,\n\t\t\t\t\t\t  args->total);\n\n\t\t/* Store label index; subsequently, we'll check on\n\t\t * address-family */\n\t\tattr->label_index = label_index;\n\n\t\t/*\n\t\t * Ignore the Label index attribute unless received for\n\t\t * labeled-unicast\n\t\t * SAFI.\n\t\t */\n\t\tif (!mp_update->length\n\t\t    || mp_update->safi != SAFI_LABELED_UNICAST)\n\t\t\tattr->label_index = BGP_INVALID_LABEL_INDEX;\n\t}\n\n\t/* Placeholder code for the IPv6 SID type */\n\telse if (type == BGP_PREFIX_SID_IPV6) {\n\t\tif (length != BGP_PREFIX_SID_IPV6_LENGTH) {\n\t\t\tflog_err(EC_BGP_ATTR_LEN,\n\t\t\t\t \"Prefix SID IPv6 length is %d instead of %d\",\n\t\t\t\t length, BGP_PREFIX_SID_IPV6_LENGTH);\n\t\t\treturn bgp_attr_malformed(args,\n\t\t\t\t\t\t  BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t\t  args->total);\n\t\t}\n\n\t\t/* Ignore reserved */\n\t\tstream_getc(peer->curr);\n\t\tstream_getw(peer->curr);\n\n\t\tstream_get(&ipv6_sid, peer->curr, 16);\n\t}\n\n\t/* Placeholder code for the Originator SRGB type */\n\telse if (type == BGP_PREFIX_SID_ORIGINATOR_SRGB) {\n\t\t/* Ignore flags */\n\t\tstream_getw(peer->curr);\n\n\t\tlength -= 2;\n\n\t\tif (length % BGP_PREFIX_SID_ORIGINATOR_SRGB_LENGTH) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_ATTR_LEN,\n\t\t\t\t\"Prefix SID Originator SRGB length is %d, it must be a multiple of %d \",\n\t\t\t\tlength, BGP_PREFIX_SID_ORIGINATOR_SRGB_LENGTH);\n\t\t\treturn bgp_attr_malformed(\n\t\t\t\targs, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\targs->total);\n\t\t}\n\n\t\tsrgb_count = length / BGP_PREFIX_SID_ORIGINATOR_SRGB_LENGTH;\n\n\t\tfor (int i = 0; i < srgb_count; i++) {\n\t\t\tstream_get(&srgb_base, peer->curr, 3);\n\t\t\tstream_get(&srgb_range, peer->curr, 3);\n\t\t}\n\t}\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Prefix SID attribute\n * draft-ietf-idr-bgp-prefix-sid-05\n */\nbgp_attr_parse_ret_t\nbgp_attr_prefix_sid(int32_t tlength, struct bgp_attr_parser_args *args,\n\t\t    struct bgp_nlri *mp_update)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tbgp_attr_parse_ret_t ret;\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID);\n\n\twhile (tlength) {\n\t\tint32_t type, length;\n\n\t\ttype = stream_getc(peer->curr);\n\t\tlength = stream_getw(peer->curr);\n\n\t\tret = bgp_attr_psid_sub(type, length, args, mp_update);\n\n\t\tif (ret != BGP_ATTR_PARSE_PROCEED)\n\t\t\treturn ret;\n\t\t/*\n\t\t * Subtract length + the T and the L\n\t\t * since length is the Vector portion\n\t\t */\n\t\ttlength -= length + 3;\n\n\t\tif (tlength < 0) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_ATTR_LEN,\n\t\t\t\t\"Prefix SID internal length %d causes us to read beyond the total Prefix SID length\",\n\t\t\t\tlength);\n\t\t\treturn bgp_attr_malformed(args,\n\t\t\t\t\t\t  BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t\t  args->total);\n\t\t}\n\t}\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* PMSI tunnel attribute (RFC 6514)\n * Basic validation checks done here.\n */\nstatic bgp_attr_parse_ret_t\nbgp_attr_pmsi_tunnel(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\tuint8_t tnl_type;\n\n\t/* Verify that the receiver is expecting \"ingress replication\" as we\n\t * can only support that.\n\t */\n\tif (length < 2) {\n\t\tflog_err(EC_BGP_ATTR_LEN, \"Bad PMSI tunnel attribute length %d\",\n\t\t\t length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\tstream_getc(peer->curr); /* Flags */\n\ttnl_type = stream_getc(peer->curr);\n\tif (tnl_type > PMSI_TNLTYPE_MAX) {\n\t\tflog_err(EC_BGP_ATTR_PMSI_TYPE,\n\t\t\t \"Invalid PMSI tunnel attribute type %d\", tnl_type);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\tif (tnl_type == PMSI_TNLTYPE_INGR_REPL) {\n\t\tif (length != 9) {\n\t\t\tflog_err(EC_BGP_ATTR_PMSI_LEN,\n\t\t\t\t \"Bad PMSI tunnel attribute length %d for IR\",\n\t\t\t\t length);\n\t\t\treturn bgp_attr_malformed(\n\t\t\t\targs, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\targs->total);\n\t\t}\n\t}\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_PMSI_TUNNEL);\n\tattr->pmsi_tnl_type = tnl_type;\n\n\t/* Forward read pointer of input stream. */\n\tstream_forward_getp(peer->curr, length - 2);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* BGP unknown attribute treatment. */\nstatic bgp_attr_parse_ret_t bgp_attr_unknown(struct bgp_attr_parser_args *args)\n{\n\tbgp_size_t total = args->total;\n\tstruct transit *transit;\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tuint8_t *const startp = args->startp;\n\tconst uint8_t type = args->type;\n\tconst uint8_t flag = args->flags;\n\tconst bgp_size_t length = args->length;\n\n\tif (bgp_debug_update(peer, NULL, NULL, 1))\n\t\tzlog_debug(\n\t\t\t\"%s Unknown attribute is received (type %d, length %d)\",\n\t\t\tpeer->host, type, length);\n\n\t/* Forward read pointer of input stream. */\n\tstream_forward_getp(peer->curr, length);\n\n\t/* If any of the mandatory well-known attributes are not recognized,\n\t   then the Error Subcode is set to Unrecognized Well-known\n\t   Attribute.  The Data field contains the unrecognized attribute\n\t   (type, length and value). */\n\tif (!CHECK_FLAG(flag, BGP_ATTR_FLAG_OPTIONAL)) {\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_UNREC_ATTR,\n\t\t\t\t\t  args->total);\n\t}\n\n\t/* Unrecognized non-transitive optional attributes must be quietly\n\t   ignored and not passed along to other BGP peers. */\n\tif (!CHECK_FLAG(flag, BGP_ATTR_FLAG_TRANS))\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\n\t/* If a path with recognized transitive optional attribute is\n\t   accepted and passed along to other BGP peers and the Partial bit\n\t   in the Attribute Flags octet is set to 1 by some previous AS, it\n\t   is not set back to 0 by the current AS. */\n\tSET_FLAG(*startp, BGP_ATTR_FLAG_PARTIAL);\n\n\t/* Store transitive attribute to the end of attr->transit. */\n\tif (!attr->transit)\n\t\tattr->transit = XCALLOC(MTYPE_TRANSIT, sizeof(struct transit));\n\n\ttransit = attr->transit;\n\n\tif (transit->val)\n\t\ttransit->val = XREALLOC(MTYPE_TRANSIT_VAL, transit->val,\n\t\t\t\t\ttransit->length + total);\n\telse\n\t\ttransit->val = XMALLOC(MTYPE_TRANSIT_VAL, total);\n\n\tmemcpy(transit->val + transit->length, startp, total);\n\ttransit->length += total;\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Well-known attribute check. */\nstatic int bgp_attr_check(struct peer *peer, struct attr *attr)\n{\n\tuint8_t type = 0;\n\n\t/* BGP Graceful-Restart End-of-RIB for IPv4 unicast is signaled as an\n\t * empty UPDATE.  */\n\tif (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag)\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\n\t/* \"An UPDATE message that contains the MP_UNREACH_NLRI is not required\n\t   to carry any other path attributes.\", though if MP_REACH_NLRI or NLRI\n\t   are present, it should.  Check for any other attribute being present\n\t   instead.\n\t */\n\tif ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) &&\n\t     CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI))))\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_ORIGIN)))\n\t\ttype = BGP_ATTR_ORIGIN;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH)))\n\t\ttype = BGP_ATTR_AS_PATH;\n\n\t/* RFC 2858 makes Next-Hop optional/ignored, if MP_REACH_NLRI is present\n\t * and\n\t * NLRI is empty. We can't easily check NLRI empty here though.\n\t */\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)))\n\t\ttype = BGP_ATTR_NEXT_HOP;\n\n\tif (peer->sort == BGP_PEER_IBGP\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)))\n\t\ttype = BGP_ATTR_LOCAL_PREF;\n\n\tif (type) {\n\t\tflog_warn(EC_BGP_MISSING_ATTRIBUTE,\n\t\t\t  \"%s Missing well-known attribute %s.\", peer->host,\n\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\tbgp_notify_send_with_data(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t  BGP_NOTIFY_UPDATE_MISS_ATTR, &type,\n\t\t\t\t\t  1);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Read attribute of update packet.  This function is called from\n   bgp_update_receive() in bgp_packet.c.  */\nbgp_attr_parse_ret_t bgp_attr_parse(struct peer *peer, struct attr *attr,\n\t\t\t\t    bgp_size_t size, struct bgp_nlri *mp_update,\n\t\t\t\t    struct bgp_nlri *mp_withdraw)\n{\n\tbgp_attr_parse_ret_t ret;\n\tuint8_t flag = 0;\n\tuint8_t type = 0;\n\tbgp_size_t length;\n\tuint8_t *startp, *endp;\n\tuint8_t *attr_endp;\n\tuint8_t seen[BGP_ATTR_BITMAP_SIZE];\n\t/* we need the as4_path only until we have synthesized the as_path with\n\t * it */\n\t/* same goes for as4_aggregator */\n\tstruct aspath *as4_path = NULL;\n\tas_t as4_aggregator = 0;\n\tstruct in_addr as4_aggregator_addr = {.s_addr = 0};\n\n\t/* Initialize bitmap. */\n\tmemset(seen, 0, BGP_ATTR_BITMAP_SIZE);\n\n\t/* End pointer of BGP attribute. */\n\tendp = BGP_INPUT_PNT(peer) + size;\n\n\t/* Get attributes to the end of attribute length. */\n\twhile (BGP_INPUT_PNT(peer) < endp) {\n\t\t/* Check remaining length check.*/\n\t\tif (endp - BGP_INPUT_PNT(peer) < BGP_ATTR_MIN_LEN) {\n\t\t\t/* XXX warning: long int format, int arg (arg 5) */\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_TOO_SMALL,\n\t\t\t\t\"%s: error BGP attribute length %lu is smaller than min len\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(endp\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\n\t\t/* Fetch attribute flag and type. */\n\t\tstartp = BGP_INPUT_PNT(peer);\n\t\t/* \"The lower-order four bits of the Attribute Flags octet are\n\t\t   unused.  They MUST be zero when sent and MUST be ignored when\n\t\t   received.\" */\n\t\tflag = 0xF0 & stream_getc(BGP_INPUT(peer));\n\t\ttype = stream_getc(BGP_INPUT(peer));\n\n\t\t/* Check whether Extended-Length applies and is in bounds */\n\t\tif (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN)\n\t\t    && ((endp - startp) < (BGP_ATTR_MIN_LEN + 1))) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_EXT_ATTRIBUTE_TOO_SMALL,\n\t\t\t\t\"%s: Extended length set, but just %lu bytes of attr header\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(endp\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\n\t\t/* Check extended attribue length bit. */\n\t\tif (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN))\n\t\t\tlength = stream_getw(BGP_INPUT(peer));\n\t\telse\n\t\t\tlength = stream_getc(BGP_INPUT(peer));\n\n\t\t/* If any attribute appears more than once in the UPDATE\n\t\t   message, then the Error Subcode is set to Malformed Attribute\n\t\t   List. */\n\n\t\tif (CHECK_BITMAP(seen, type)) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_REPEATED,\n\t\t\t\t\"%s: error BGP attribute type %d appears twice in a message\",\n\t\t\t\tpeer->host, type);\n\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\n\t\t/* Set type to bitmap to check duplicate attribute.  `type' is\n\t\t   unsigned char so it never overflow bitmap range. */\n\n\t\tSET_BITMAP(seen, type);\n\n\t\t/* Overflow check. */\n\t\tattr_endp = BGP_INPUT_PNT(peer) + length;\n\n\t\tif (attr_endp > endp) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_TOO_LARGE,\n\t\t\t\t\"%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p\",\n\t\t\t\tpeer->host, type, length, size, attr_endp,\n\t\t\t\tendp);\n\t\t\t/*\n\t\t\t * RFC 4271 6.3\n\t\t\t * If any recognized attribute has an Attribute\n\t\t\t * Length that conflicts with the expected length\n\t\t\t * (based on the attribute type code), then the\n\t\t\t * Error Subcode MUST be set to Attribute Length\n\t\t\t * Error.  The Data field MUST contain the erroneous\n\t\t\t * attribute (type, length, and value).\n\t\t\t * ----------\n\t\t\t * We do not currently have a good way to determine the\n\t\t\t * length of the attribute independent of the length\n\t\t\t * received in the message. Instead we send the\n\t\t\t * minimum between the amount of data we have and the\n\t\t\t * amount specified by the attribute length field.\n\t\t\t *\n\t\t\t * Instead of directly passing in the packet buffer and\n\t\t\t * offset we use the stream_get* functions to read into\n\t\t\t * a stack buffer, since they perform bounds checking\n\t\t\t * and we are working with untrusted data.\n\t\t\t */\n\t\t\tunsigned char ndata[BGP_MAX_PACKET_SIZE];\n\t\t\tmemset(ndata, 0x00, sizeof(ndata));\n\t\t\tsize_t lfl =\n\t\t\t\tCHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN) ? 2 : 1;\n\t\t\t/* Rewind to end of flag field */\n\t\t\tstream_forward_getp(BGP_INPUT(peer), -(1 + lfl));\n\t\t\t/* Type */\n\t\t\tstream_get(&ndata[0], BGP_INPUT(peer), 1);\n\t\t\t/* Length */\n\t\t\tstream_get(&ndata[1], BGP_INPUT(peer), lfl);\n\t\t\t/* Value */\n\t\t\tsize_t atl = attr_endp - startp;\n\t\t\tsize_t ndl = MIN(atl, STREAM_READABLE(BGP_INPUT(peer)));\n\t\t\tstream_get(&ndata[lfl + 1], BGP_INPUT(peer), ndl);\n\n\t\t\tbgp_notify_send_with_data(\n\t\t\t\tpeer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR, ndata,\n\t\t\t\tndl + lfl + 1);\n\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\n\t\tstruct bgp_attr_parser_args attr_args = {\n\t\t\t.peer = peer,\n\t\t\t.length = length,\n\t\t\t.attr = attr,\n\t\t\t.type = type,\n\t\t\t.flags = flag,\n\t\t\t.startp = startp,\n\t\t\t.total = attr_endp - startp,\n\t\t};\n\n\n\t\t/* If any recognized attribute has Attribute Flags that conflict\n\t\t   with the Attribute Type Code, then the Error Subcode is set\n\t\t   to\n\t\t   Attribute Flags Error.  The Data field contains the erroneous\n\t\t   attribute (type, length and value). */\n\t\tif (bgp_attr_flag_invalid(&attr_args)) {\n\t\t\tret = bgp_attr_malformed(\n\t\t\t\t&attr_args, BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,\n\t\t\t\tattr_args.total);\n\t\t\tif (ret == BGP_ATTR_PARSE_PROCEED)\n\t\t\t\tcontinue;\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* OK check attribute and store it's value. */\n\t\tswitch (type) {\n\t\tcase BGP_ATTR_ORIGIN:\n\t\t\tret = bgp_attr_origin(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS_PATH:\n\t\t\tret = bgp_attr_aspath(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS4_PATH:\n\t\t\tret = bgp_attr_as4_path(&attr_args, &as4_path);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_NEXT_HOP:\n\t\t\tret = bgp_attr_nexthop(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MULTI_EXIT_DISC:\n\t\t\tret = bgp_attr_med(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_LOCAL_PREF:\n\t\t\tret = bgp_attr_local_pref(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_ATOMIC_AGGREGATE:\n\t\t\tret = bgp_attr_atomic(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AGGREGATOR:\n\t\t\tret = bgp_attr_aggregator(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS4_AGGREGATOR:\n\t\t\tret = bgp_attr_as4_aggregator(&attr_args,\n\t\t\t\t\t\t      &as4_aggregator,\n\t\t\t\t\t\t      &as4_aggregator_addr);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_COMMUNITIES:\n\t\t\tret = bgp_attr_community(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_LARGE_COMMUNITIES:\n\t\t\tret = bgp_attr_large_community(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_ORIGINATOR_ID:\n\t\t\tret = bgp_attr_originator_id(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_CLUSTER_LIST:\n\t\t\tret = bgp_attr_cluster_list(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MP_REACH_NLRI:\n\t\t\tret = bgp_mp_reach_parse(&attr_args, mp_update);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MP_UNREACH_NLRI:\n\t\t\tret = bgp_mp_unreach_parse(&attr_args, mp_withdraw);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_EXT_COMMUNITIES:\n\t\t\tret = bgp_attr_ext_communities(&attr_args);\n\t\t\tbreak;\n#if ENABLE_BGP_VNC\n\t\tcase BGP_ATTR_VNC:\n#endif\n\t\tcase BGP_ATTR_ENCAP:\n\t\t\tret = bgp_attr_encap(type, peer, length, attr, flag,\n\t\t\t\t\t     startp);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_PREFIX_SID:\n\t\t\tret = bgp_attr_prefix_sid(length,\n\t\t\t\t\t\t  &attr_args, mp_update);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_PMSI_TUNNEL:\n\t\t\tret = bgp_attr_pmsi_tunnel(&attr_args);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = bgp_attr_unknown(&attr_args);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret == BGP_ATTR_PARSE_ERROR_NOTIFYPLS) {\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t}\n\n\t\tif (ret == BGP_ATTR_PARSE_EOR) {\n\t\t\tif (as4_path)\n\t\t\t\taspath_unintern(&as4_path);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If hard error occurred immediately return to the caller. */\n\t\tif (ret == BGP_ATTR_PARSE_ERROR) {\n\t\t\tflog_warn(EC_BGP_ATTRIBUTE_PARSE_ERROR,\n\t\t\t\t  \"%s: Attribute %s, parse error\", peer->host,\n\t\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\t\tif (as4_path)\n\t\t\t\taspath_unintern(&as4_path);\n\t\t\treturn ret;\n\t\t}\n\t\tif (ret == BGP_ATTR_PARSE_WITHDRAW) {\n\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_PARSE_WITHDRAW,\n\t\t\t\t\"%s: Attribute %s, parse error - treating as withdrawal\",\n\t\t\t\tpeer->host, lookup_msg(attr_str, type, NULL));\n\t\t\tif (as4_path)\n\t\t\t\taspath_unintern(&as4_path);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* Check the fetched length. */\n\t\tif (BGP_INPUT_PNT(peer) != attr_endp) {\n\t\t\tflog_warn(EC_BGP_ATTRIBUTE_FETCH_ERROR,\n\t\t\t\t  \"%s: BGP attribute %s, fetch error\",\n\t\t\t\t  peer->host, lookup_msg(attr_str, type, NULL));\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\tif (as4_path)\n\t\t\t\taspath_unintern(&as4_path);\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\t}\n\n\t/* Check final read pointer is same as end pointer. */\n\tif (BGP_INPUT_PNT(peer) != endp) {\n\t\tflog_warn(EC_BGP_ATTRIBUTES_MISMATCH,\n\t\t\t  \"%s: BGP attribute %s, length mismatch\", peer->host,\n\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\tif (as4_path)\n\t\t\taspath_unintern(&as4_path);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\t/* Check all mandatory well-known attributes are present */\n\tif ((ret = bgp_attr_check(peer, attr)) < 0) {\n\t\tif (as4_path)\n\t\t\taspath_unintern(&as4_path);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * At this place we can see whether we got AS4_PATH and/or\n\t * AS4_AGGREGATOR from a 16Bit peer and act accordingly.\n\t * We can not do this before we've read all attributes because\n\t * the as4 handling does not say whether AS4_PATH has to be sent\n\t * after AS_PATH or not - and when AS4_AGGREGATOR will be send\n\t * in relationship to AGGREGATOR.\n\t * So, to be defensive, we are not relying on any order and read\n\t * all attributes first, including these 32bit ones, and now,\n\t * afterwards, we look what and if something is to be done for as4.\n\t *\n\t * It is possible to not have AS_PATH, e.g. GR EoR and sole\n\t * MP_UNREACH_NLRI.\n\t */\n\t/* actually... this doesn't ever return failure currently, but\n\t * better safe than sorry */\n\tif (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))\n\t    && bgp_attr_munge_as4_attrs(peer, attr, as4_path, as4_aggregator,\n\t\t\t\t\t&as4_aggregator_addr)) {\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\tif (as4_path)\n\t\t\taspath_unintern(&as4_path);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\t/* At this stage, we have done all fiddling with as4, and the\n\t * resulting info is in attr->aggregator resp. attr->aspath\n\t * so we can chuck as4_aggregator and as4_path alltogether in\n\t * order to save memory\n\t */\n\tif (as4_path) {\n\t\taspath_unintern(&as4_path); /* unintern - it is in the hash */\n\t\t/* The flag that we got this is still there, but that does not\n\t\t * do any trouble\n\t\t */\n\t}\n\t/*\n\t * The \"rest\" of the code does nothing with as4_aggregator.\n\t * there is no memory attached specifically which is not part\n\t * of the attr.\n\t * so ignoring just means do nothing.\n\t */\n\t/*\n\t * Finally do the checks on the aspath we did not do yet\n\t * because we waited for a potentially synthesized aspath.\n\t */\n\tif (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))) {\n\t\tret = bgp_attr_aspath_check(peer, attr);\n\t\tif (ret != BGP_ATTR_PARSE_PROCEED)\n\t\t\treturn ret;\n\t}\n\t/* Finally intern unknown attribute. */\n\tif (attr->transit)\n\t\tattr->transit = transit_intern(attr->transit);\n\tif (attr->encap_subtlvs)\n\t\tattr->encap_subtlvs =\n\t\t\tencap_intern(attr->encap_subtlvs, ENCAP_SUBTLV_TYPE);\n#if ENABLE_BGP_VNC\n\tif (attr->vnc_subtlvs)\n\t\tattr->vnc_subtlvs =\n\t\t\tencap_intern(attr->vnc_subtlvs, VNC_SUBTLV_TYPE);\n#endif\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\nsize_t bgp_packet_mpattr_start(struct stream *s, struct peer *peer, afi_t afi,\n\t\t\t       safi_t safi, struct bpacket_attr_vec_arr *vecarr,\n\t\t\t       struct attr *attr)\n{\n\tsize_t sizep;\n\tiana_afi_t pkt_afi;\n\tiana_safi_t pkt_safi;\n\tafi_t nh_afi;\n\n\t/* Set extended bit always to encode the attribute length as 2 bytes */\n\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN);\n\tstream_putc(s, BGP_ATTR_MP_REACH_NLRI);\n\tsizep = stream_get_endp(s);\n\tstream_putw(s, 0); /* Marker: Attribute length. */\n\n\n\t/* Convert AFI, SAFI to values for packet. */\n\tbgp_map_afi_safi_int2iana(afi, safi, &pkt_afi, &pkt_safi);\n\n\tstream_putw(s, pkt_afi);  /* AFI */\n\tstream_putc(s, pkt_safi); /* SAFI */\n\n\t/* Nexthop AFI */\n\tif (afi == AFI_IP\n\t    && (safi == SAFI_UNICAST || safi == SAFI_LABELED_UNICAST))\n\t\tnh_afi = peer_cap_enhe(peer, afi, safi) ? AFI_IP6 : AFI_IP;\n\telse\n\t\tnh_afi = BGP_NEXTHOP_AFI_FROM_NHLEN(attr->mp_nexthop_len);\n\n\t/* Nexthop */\n\tbpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s, attr);\n\tswitch (nh_afi) {\n\tcase AFI_IP:\n\t\tswitch (safi) {\n\t\tcase SAFI_UNICAST:\n\t\tcase SAFI_MULTICAST:\n\t\tcase SAFI_LABELED_UNICAST:\n\t\t\tstream_putc(s, 4);\n\t\t\tstream_put_ipv4(s, attr->nexthop.s_addr);\n\t\t\tbreak;\n\t\tcase SAFI_MPLS_VPN:\n\t\t\tstream_putc(s, 12);\n\t\t\tstream_putl(s, 0); /* RD = 0, per RFC */\n\t\t\tstream_putl(s, 0);\n\t\t\tstream_put(s, &attr->mp_nexthop_global_in, 4);\n\t\t\tbreak;\n\t\tcase SAFI_ENCAP:\n\t\tcase SAFI_EVPN:\n\t\t\tstream_putc(s, 4);\n\t\t\tstream_put(s, &attr->mp_nexthop_global_in, 4);\n\t\t\tbreak;\n\t\tcase SAFI_FLOWSPEC:\n\t\t\tstream_putc(s, 0); /* no nexthop for flowspec */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AFI_IP6:\n\t\tswitch (safi) {\n\t\tcase SAFI_UNICAST:\n\t\tcase SAFI_MULTICAST:\n\t\tcase SAFI_LABELED_UNICAST:\n\t\tcase SAFI_EVPN: {\n\t\t\tif (attr->mp_nexthop_len\n\t\t\t    == BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL) {\n\t\t\t\tstream_putc(s,\n\t\t\t\t\t    BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL);\n\t\t\t\tstream_put(s, &attr->mp_nexthop_global,\n\t\t\t\t\t   IPV6_MAX_BYTELEN);\n\t\t\t\tstream_put(s, &attr->mp_nexthop_local,\n\t\t\t\t\t   IPV6_MAX_BYTELEN);\n\t\t\t} else {\n\t\t\t\tstream_putc(s, IPV6_MAX_BYTELEN);\n\t\t\t\tstream_put(s, &attr->mp_nexthop_global,\n\t\t\t\t\t   IPV6_MAX_BYTELEN);\n\t\t\t}\n\t\t} break;\n\t\tcase SAFI_MPLS_VPN: {\n\t\t\tif (attr->mp_nexthop_len\n\t\t\t    == BGP_ATTR_NHLEN_IPV6_GLOBAL) {\n\t\t\t\tstream_putc(s, 24);\n\t\t\t\tstream_putl(s, 0); /* RD = 0, per RFC */\n\t\t\t\tstream_putl(s, 0);\n\t\t\t\tstream_put(s, &attr->mp_nexthop_global,\n\t\t\t\t\t   IPV6_MAX_BYTELEN);\n\t\t\t} else if (attr->mp_nexthop_len\n\t\t\t\t   == BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL) {\n\t\t\t\tstream_putc(s, 48);\n\t\t\t\tstream_putl(s, 0); /* RD = 0, per RFC */\n\t\t\t\tstream_putl(s, 0);\n\t\t\t\tstream_put(s, &attr->mp_nexthop_global,\n\t\t\t\t\t   IPV6_MAX_BYTELEN);\n\t\t\t\tstream_putl(s, 0); /* RD = 0, per RFC */\n\t\t\t\tstream_putl(s, 0);\n\t\t\t\tstream_put(s, &attr->mp_nexthop_local,\n\t\t\t\t\t   IPV6_MAX_BYTELEN);\n\t\t\t}\n\t\t} break;\n\t\tcase SAFI_ENCAP:\n\t\t\tstream_putc(s, IPV6_MAX_BYTELEN);\n\t\t\tstream_put(s, &attr->mp_nexthop_global,\n\t\t\t\t   IPV6_MAX_BYTELEN);\n\t\t\tbreak;\n\t\tcase SAFI_FLOWSPEC:\n\t\t\tstream_putc(s, 0); /* no nexthop for flowspec */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (safi != SAFI_FLOWSPEC)\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_ATTR_NH_SEND_LEN,\n\t\t\t\t\"Bad nexthop when sending to %s, AFI %u SAFI %u nhlen %d\",\n\t\t\t\tpeer->host, afi, safi, attr->mp_nexthop_len);\n\t\tbreak;\n\t}\n\n\t/* SNPA */\n\tstream_putc(s, 0);\n\treturn sizep;\n}\n\nvoid bgp_packet_mpattr_prefix(struct stream *s, afi_t afi, safi_t safi,\n\t\t\t      struct prefix *p, struct prefix_rd *prd,\n\t\t\t      mpls_label_t *label, uint32_t num_labels,\n\t\t\t      int addpath_encode, uint32_t addpath_tx_id,\n\t\t\t      struct attr *attr)\n{\n\tif (safi == SAFI_MPLS_VPN) {\n\t\tif (addpath_encode)\n\t\t\tstream_putl(s, addpath_tx_id);\n\t\t/* Label, RD, Prefix write. */\n\t\tstream_putc(s, p->prefixlen + 88);\n\t\tstream_put(s, label, BGP_LABEL_BYTES);\n\t\tstream_put(s, prd->val, 8);\n\t\tstream_put(s, &p->u.prefix, PSIZE(p->prefixlen));\n\t} else if (afi == AFI_L2VPN && safi == SAFI_EVPN) {\n\t\t/* EVPN prefix - contents depend on type */\n\t\tbgp_evpn_encode_prefix(s, p, prd, label, num_labels, attr,\n\t\t\t\t       addpath_encode, addpath_tx_id);\n\t} else if (safi == SAFI_LABELED_UNICAST) {\n\t\t/* Prefix write with label. */\n\t\tstream_put_labeled_prefix(s, p, label);\n\t} else if (safi == SAFI_FLOWSPEC) {\n\t\tif (PSIZE (p->prefixlen)+2 < FLOWSPEC_NLRI_SIZELIMIT)\n\t\t\tstream_putc(s, PSIZE (p->prefixlen)+2);\n\t\telse\n\t\t\tstream_putw(s, (PSIZE (p->prefixlen)+2)|(0xf<<12));\n\t\tstream_putc(s, 2);/* Filter type */\n\t\tstream_putc(s, p->prefixlen);/* Prefix length */\n\t\tstream_put(s, &p->u.prefix, PSIZE (p->prefixlen));\n\t} else\n\t\tstream_put_prefix_addpath(s, p, addpath_encode, addpath_tx_id);\n}\n\nsize_t bgp_packet_mpattr_prefix_size(afi_t afi, safi_t safi, struct prefix *p)\n{\n\tint size = PSIZE(p->prefixlen);\n\tif (safi == SAFI_MPLS_VPN)\n\t\tsize += 88;\n\telse if (afi == AFI_L2VPN && safi == SAFI_EVPN)\n\t\tsize += 232; // TODO: Maximum possible for type-2, type-3 and\n\t\t\t     // type-5\n\treturn size;\n}\n\n/*\n * Encodes the tunnel encapsulation attribute,\n * and with ENABLE_BGP_VNC the VNC attribute which uses\n * almost the same TLV format\n */\nstatic void bgp_packet_mpattr_tea(struct bgp *bgp, struct peer *peer,\n\t\t\t\t  struct stream *s, struct attr *attr,\n\t\t\t\t  uint8_t attrtype)\n{\n\tunsigned int attrlenfield = 0;\n\tunsigned int attrhdrlen = 0;\n\tstruct bgp_attr_encap_subtlv *subtlvs;\n\tstruct bgp_attr_encap_subtlv *st;\n\tconst char *attrname;\n\n\tif (!attr || (attrtype == BGP_ATTR_ENCAP\n\t\t      && (!attr->encap_tunneltype\n\t\t\t  || attr->encap_tunneltype == BGP_ENCAP_TYPE_MPLS)))\n\t\treturn;\n\n\tswitch (attrtype) {\n\tcase BGP_ATTR_ENCAP:\n\t\tattrname = \"Tunnel Encap\";\n\t\tsubtlvs = attr->encap_subtlvs;\n\t\tif (subtlvs == NULL) /* nothing to do */\n\t\t\treturn;\n\t\t/*\n\t\t * The tunnel encap attr has an \"outer\" tlv.\n\t\t * T = tunneltype,\n\t\t * L = total length of subtlvs,\n\t\t * V = concatenated subtlvs.\n\t\t */\n\t\tattrlenfield = 2 + 2; /* T + L */\n\t\tattrhdrlen = 1 + 1;   /* subTLV T + L */\n\t\tbreak;\n\n#if ENABLE_BGP_VNC\n\tcase BGP_ATTR_VNC:\n\t\tattrname = \"VNC\";\n\t\tsubtlvs = attr->vnc_subtlvs;\n\t\tif (subtlvs == NULL) /* nothing to do */\n\t\t\treturn;\n\t\tattrlenfield = 0;   /* no outer T + L */\n\t\tattrhdrlen = 2 + 2; /* subTLV T + L */\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tassert(0);\n\t}\n\n\t/* compute attr length */\n\tfor (st = subtlvs; st; st = st->next) {\n\t\tattrlenfield += (attrhdrlen + st->length);\n\t}\n\n\tif (attrlenfield > 0xffff) {\n\t\tzlog_info(\"%s attribute is too long (length=%d), can't send it\",\n\t\t\t  attrname, attrlenfield);\n\t\treturn;\n\t}\n\n\tif (attrlenfield > 0xff) {\n\t\t/* 2-octet length field */\n\t\tstream_putc(s,\n\t\t\t    BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\tstream_putc(s, attrtype);\n\t\tstream_putw(s, attrlenfield & 0xffff);\n\t} else {\n\t\t/* 1-octet length field */\n\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL);\n\t\tstream_putc(s, attrtype);\n\t\tstream_putc(s, attrlenfield & 0xff);\n\t}\n\n\tif (attrtype == BGP_ATTR_ENCAP) {\n\t\t/* write outer T+L */\n\t\tstream_putw(s, attr->encap_tunneltype);\n\t\tstream_putw(s, attrlenfield - 4);\n\t}\n\n\t/* write each sub-tlv */\n\tfor (st = subtlvs; st; st = st->next) {\n\t\tif (attrtype == BGP_ATTR_ENCAP) {\n\t\t\tstream_putc(s, st->type);\n\t\t\tstream_putc(s, st->length);\n#if ENABLE_BGP_VNC\n\t\t} else {\n\t\t\tstream_putw(s, st->type);\n\t\t\tstream_putw(s, st->length);\n#endif\n\t\t}\n\t\tstream_put(s, st->value, st->length);\n\t}\n}\n\nvoid bgp_packet_mpattr_end(struct stream *s, size_t sizep)\n{\n\t/* Set MP attribute length. Don't count the (2) bytes used to encode\n\t   the attr length */\n\tstream_putw_at(s, sizep, (stream_get_endp(s) - sizep) - 2);\n}\n\n/* Make attribute packet. */\nbgp_size_t bgp_packet_attribute(struct bgp *bgp, struct peer *peer,\n\t\t\t\tstruct stream *s, struct attr *attr,\n\t\t\t\tstruct bpacket_attr_vec_arr *vecarr,\n\t\t\t\tstruct prefix *p, afi_t afi, safi_t safi,\n\t\t\t\tstruct peer *from, struct prefix_rd *prd,\n\t\t\t\tmpls_label_t *label, uint32_t num_labels,\n\t\t\t\tint addpath_encode, uint32_t addpath_tx_id)\n{\n\tsize_t cp;\n\tsize_t aspath_sizep;\n\tstruct aspath *aspath;\n\tint send_as4_path = 0;\n\tint send_as4_aggregator = 0;\n\tint use32bit = (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV)) ? 1 : 0;\n\n\tif (!bgp)\n\t\tbgp = peer->bgp;\n\n\t/* Remember current pointer. */\n\tcp = stream_get_endp(s);\n\n\tif (p\n\t    && !((afi == AFI_IP && safi == SAFI_UNICAST)\n\t\t && !peer_cap_enhe(peer, afi, safi))) {\n\t\tsize_t mpattrlen_pos = 0;\n\n\t\tmpattrlen_pos = bgp_packet_mpattr_start(s, peer, afi, safi,\n\t\t\t\t\t\t\tvecarr, attr);\n\t\tbgp_packet_mpattr_prefix(s, afi, safi, p, prd, label,\n\t\t\t\t\t num_labels, addpath_encode,\n\t\t\t\t\t addpath_tx_id, attr);\n\t\tbgp_packet_mpattr_end(s, mpattrlen_pos);\n\t}\n\n\t/* Origin attribute. */\n\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\tstream_putc(s, BGP_ATTR_ORIGIN);\n\tstream_putc(s, 1);\n\tstream_putc(s, attr->origin);\n\n\t/* AS path attribute. */\n\n\t/* If remote-peer is EBGP */\n\tif (peer->sort == BGP_PEER_EBGP\n\t    && (!CHECK_FLAG(peer->af_flags[afi][safi],\n\t\t\t    PEER_FLAG_AS_PATH_UNCHANGED)\n\t\t|| attr->aspath->segments == NULL)\n\t    && (!CHECK_FLAG(peer->af_flags[afi][safi],\n\t\t\t    PEER_FLAG_RSERVER_CLIENT))) {\n\t\taspath = aspath_dup(attr->aspath);\n\n\t\t/* Even though we may not be configured for confederations we\n\t\t * may have\n\t\t * RXed an AS_PATH with AS_CONFED_SEQUENCE or AS_CONFED_SET */\n\t\taspath = aspath_delete_confed_seq(aspath);\n\n\t\tif (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)) {\n\t\t\t/* Stuff our path CONFED_ID on the front */\n\t\t\taspath = aspath_add_seq(aspath, bgp->confed_id);\n\t\t} else {\n\t\t\tif (peer->change_local_as) {\n\t\t\t\t/* If replace-as is specified, we only use the\n\t\t\t\t   change_local_as when\n\t\t\t\t   advertising routes. */\n\t\t\t\tif (!CHECK_FLAG(\n\t\t\t\t\t    peer->flags,\n\t\t\t\t\t    PEER_FLAG_LOCAL_AS_REPLACE_AS)) {\n\t\t\t\t\taspath = aspath_add_seq(aspath,\n\t\t\t\t\t\t\t\tpeer->local_as);\n\t\t\t\t}\n\t\t\t\taspath = aspath_add_seq(aspath,\n\t\t\t\t\t\t\tpeer->change_local_as);\n\t\t\t} else {\n\t\t\t\taspath = aspath_add_seq(aspath, peer->local_as);\n\t\t\t}\n\t\t}\n\t} else if (peer->sort == BGP_PEER_CONFED) {\n\t\t/* A confed member, so we need to do the AS_CONFED_SEQUENCE\n\t\t * thing */\n\t\taspath = aspath_dup(attr->aspath);\n\t\taspath = aspath_add_confed_seq(aspath, peer->local_as);\n\t} else\n\t\taspath = attr->aspath;\n\n\t/* If peer is not AS4 capable, then:\n\t * - send the created AS_PATH out as AS4_PATH (optional, transitive),\n\t *   but ensure that no AS_CONFED_SEQUENCE and AS_CONFED_SET path\n\t * segment\n\t *   types are in it (i.e. exclude them if they are there)\n\t *   AND do this only if there is at least one asnum > 65535 in the\n\t * path!\n\t * - send an AS_PATH out, but put 16Bit ASnums in it, not 32bit, and\n\t * change\n\t *   all ASnums > 65535 to BGP_AS_TRANS\n\t */\n\n\tstream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN);\n\tstream_putc(s, BGP_ATTR_AS_PATH);\n\taspath_sizep = stream_get_endp(s);\n\tstream_putw(s, 0);\n\tstream_putw_at(s, aspath_sizep, aspath_put(s, aspath, use32bit));\n\n\t/* OLD session may need NEW_AS_PATH sent, if there are 4-byte ASNs\n\t * in the path\n\t */\n\tif (!use32bit && aspath_has_as4(aspath))\n\t\tsend_as4_path =\n\t\t\t1; /* we'll do this later, at the correct place */\n\n\t/* Nexthop attribute. */\n\tif (afi == AFI_IP && safi == SAFI_UNICAST\n\t    && !peer_cap_enhe(peer, afi, safi)) {\n\t\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP)) {\n\t\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\t\t\tstream_putc(s, BGP_ATTR_NEXT_HOP);\n\t\t\tbpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s,\n\t\t\t\t\t\t     attr);\n\t\t\tstream_putc(s, 4);\n\t\t\tstream_put_ipv4(s, attr->nexthop.s_addr);\n\t\t} else if (peer_cap_enhe(from, afi, safi)) {\n\t\t\t/*\n\t\t\t * Likely this is the case when an IPv4 prefix was\n\t\t\t * received with\n\t\t\t * Extended Next-hop capability and now being advertised\n\t\t\t * to\n\t\t\t * non-ENHE peers.\n\t\t\t * Setting the mandatory (ipv4) next-hop attribute here\n\t\t\t * to enable\n\t\t\t * implicit next-hop self with correct (ipv4 address\n\t\t\t * family).\n\t\t\t */\n\t\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\t\t\tstream_putc(s, BGP_ATTR_NEXT_HOP);\n\t\t\tbpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s,\n\t\t\t\t\t\t     NULL);\n\t\t\tstream_putc(s, 4);\n\t\t\tstream_put_ipv4(s, 0);\n\t\t}\n\t}\n\n\t/* MED attribute. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC)\n\t    || bgp->maxmed_active) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL);\n\t\tstream_putc(s, BGP_ATTR_MULTI_EXIT_DISC);\n\t\tstream_putc(s, 4);\n\t\tstream_putl(s, (bgp->maxmed_active ? bgp->maxmed_value\n\t\t\t\t\t\t   : attr->med));\n\t}\n\n\t/* Local preference. */\n\tif (peer->sort == BGP_PEER_IBGP || peer->sort == BGP_PEER_CONFED) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_LOCAL_PREF);\n\t\tstream_putc(s, 4);\n\t\tstream_putl(s, attr->local_pref);\n\t}\n\n\t/* Atomic aggregate. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE)) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_ATOMIC_AGGREGATE);\n\t\tstream_putc(s, 0);\n\t}\n\n\t/* Aggregator. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR)) {\n\t\t/* Common to BGP_ATTR_AGGREGATOR, regardless of ASN size */\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_AGGREGATOR);\n\n\t\tif (use32bit) {\n\t\t\t/* AS4 capable peer */\n\t\t\tstream_putc(s, 8);\n\t\t\tstream_putl(s, attr->aggregator_as);\n\t\t} else {\n\t\t\t/* 2-byte AS peer */\n\t\t\tstream_putc(s, 6);\n\n\t\t\t/* Is ASN representable in 2-bytes? Or must AS_TRANS be\n\t\t\t * used? */\n\t\t\tif (attr->aggregator_as > 65535) {\n\t\t\t\tstream_putw(s, BGP_AS_TRANS);\n\n\t\t\t\t/* we have to send AS4_AGGREGATOR, too.\n\t\t\t\t * we'll do that later in order to send\n\t\t\t\t * attributes in ascending\n\t\t\t\t * order.\n\t\t\t\t */\n\t\t\t\tsend_as4_aggregator = 1;\n\t\t\t} else\n\t\t\t\tstream_putw(s, (uint16_t)attr->aggregator_as);\n\t\t}\n\t\tstream_put_ipv4(s, attr->aggregator_addr.s_addr);\n\t}\n\n\t/* Community attribute. */\n\tif (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY)\n\t    && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES))) {\n\t\tif (attr->community->size * 4 > 255) {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS\n\t\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\t\tstream_putc(s, BGP_ATTR_COMMUNITIES);\n\t\t\tstream_putw(s, attr->community->size * 4);\n\t\t} else {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);\n\t\t\tstream_putc(s, BGP_ATTR_COMMUNITIES);\n\t\t\tstream_putc(s, attr->community->size * 4);\n\t\t}\n\t\tstream_put(s, attr->community->val, attr->community->size * 4);\n\t}\n\n\t/*\n\t * Large Community attribute.\n\t */\n\tif (CHECK_FLAG(peer->af_flags[afi][safi],\n\t\t       PEER_FLAG_SEND_LARGE_COMMUNITY)\n\t    && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES))) {\n\t\tif (lcom_length(attr->lcommunity) > 255) {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS\n\t\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\t\tstream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);\n\t\t\tstream_putw(s, lcom_length(attr->lcommunity));\n\t\t} else {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);\n\t\t\tstream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);\n\t\t\tstream_putc(s, lcom_length(attr->lcommunity));\n\t\t}\n\t\tstream_put(s, attr->lcommunity->val,\n\t\t\t   lcom_length(attr->lcommunity));\n\t}\n\n\t/* Route Reflector. */\n\tif (peer->sort == BGP_PEER_IBGP && from\n\t    && from->sort == BGP_PEER_IBGP) {\n\t\t/* Originator ID. */\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL);\n\t\tstream_putc(s, BGP_ATTR_ORIGINATOR_ID);\n\t\tstream_putc(s, 4);\n\n\t\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID))\n\t\t\tstream_put_in_addr(s, &attr->originator_id);\n\t\telse\n\t\t\tstream_put_in_addr(s, &from->remote_id);\n\n\t\t/* Cluster list. */\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL);\n\t\tstream_putc(s, BGP_ATTR_CLUSTER_LIST);\n\n\t\tif (attr->cluster) {\n\t\t\tstream_putc(s, attr->cluster->length + 4);\n\t\t\t/* If this peer configuration's parent BGP has\n\t\t\t * cluster_id. */\n\t\t\tif (bgp->config & BGP_CONFIG_CLUSTER_ID)\n\t\t\t\tstream_put_in_addr(s, &bgp->cluster_id);\n\t\t\telse\n\t\t\t\tstream_put_in_addr(s, &bgp->router_id);\n\t\t\tstream_put(s, attr->cluster->list,\n\t\t\t\t   attr->cluster->length);\n\t\t} else {\n\t\t\tstream_putc(s, 4);\n\t\t\t/* If this peer configuration's parent BGP has\n\t\t\t * cluster_id. */\n\t\t\tif (bgp->config & BGP_CONFIG_CLUSTER_ID)\n\t\t\t\tstream_put_in_addr(s, &bgp->cluster_id);\n\t\t\telse\n\t\t\t\tstream_put_in_addr(s, &bgp->router_id);\n\t\t}\n\t}\n\n\t/* Extended Communities attribute. */\n\tif (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY)\n\t    && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES))) {\n\t\tif (peer->sort == BGP_PEER_IBGP\n\t\t    || peer->sort == BGP_PEER_CONFED) {\n\t\t\tif (attr->ecommunity->size * 8 > 255) {\n\t\t\t\tstream_putc(s,\n\t\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS\n\t\t\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\t\t\tstream_putc(s, BGP_ATTR_EXT_COMMUNITIES);\n\t\t\t\tstream_putw(s, attr->ecommunity->size * 8);\n\t\t\t} else {\n\t\t\t\tstream_putc(s,\n\t\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);\n\t\t\t\tstream_putc(s, BGP_ATTR_EXT_COMMUNITIES);\n\t\t\t\tstream_putc(s, attr->ecommunity->size * 8);\n\t\t\t}\n\t\t\tstream_put(s, attr->ecommunity->val,\n\t\t\t\t   attr->ecommunity->size * 8);\n\t\t} else {\n\t\t\tuint8_t *pnt;\n\t\t\tint tbit;\n\t\t\tint ecom_tr_size = 0;\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < attr->ecommunity->size; i++) {\n\t\t\t\tpnt = attr->ecommunity->val + (i * 8);\n\t\t\t\ttbit = *pnt;\n\n\t\t\t\tif (CHECK_FLAG(tbit,\n\t\t\t\t\t       ECOMMUNITY_FLAG_NON_TRANSITIVE))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tecom_tr_size++;\n\t\t\t}\n\n\t\t\tif (ecom_tr_size) {\n\t\t\t\tif (ecom_tr_size * 8 > 255) {\n\t\t\t\t\tstream_putc(\n\t\t\t\t\t\ts,\n\t\t\t\t\t\tBGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t\t\t| BGP_ATTR_FLAG_TRANS\n\t\t\t\t\t\t\t| BGP_ATTR_FLAG_EXTLEN);\n\t\t\t\t\tstream_putc(s,\n\t\t\t\t\t\t    BGP_ATTR_EXT_COMMUNITIES);\n\t\t\t\t\tstream_putw(s, ecom_tr_size * 8);\n\t\t\t\t} else {\n\t\t\t\t\tstream_putc(\n\t\t\t\t\t\ts,\n\t\t\t\t\t\tBGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t\t\t| BGP_ATTR_FLAG_TRANS);\n\t\t\t\t\tstream_putc(s,\n\t\t\t\t\t\t    BGP_ATTR_EXT_COMMUNITIES);\n\t\t\t\t\tstream_putc(s, ecom_tr_size * 8);\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < attr->ecommunity->size; i++) {\n\t\t\t\t\tpnt = attr->ecommunity->val + (i * 8);\n\t\t\t\t\ttbit = *pnt;\n\n\t\t\t\t\tif (CHECK_FLAG(\n\t\t\t\t\t\t    tbit,\n\t\t\t\t\t\t    ECOMMUNITY_FLAG_NON_TRANSITIVE))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tstream_put(s, pnt, 8);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Label index attribute. */\n\tif (safi == SAFI_LABELED_UNICAST) {\n\t\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID)) {\n\t\t\tuint32_t label_index;\n\n\t\t\tlabel_index = attr->label_index;\n\n\t\t\tif (label_index != BGP_INVALID_LABEL_INDEX) {\n\t\t\t\tstream_putc(s,\n\t\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);\n\t\t\t\tstream_putc(s, BGP_ATTR_PREFIX_SID);\n\t\t\t\tstream_putc(s, 10);\n\t\t\t\tstream_putc(s, BGP_PREFIX_SID_LABEL_INDEX);\n\t\t\t\tstream_putw(s,\n\t\t\t\t\t    BGP_PREFIX_SID_LABEL_INDEX_LENGTH);\n\t\t\t\tstream_putc(s, 0); // reserved\n\t\t\t\tstream_putw(s, 0); // flags\n\t\t\t\tstream_putl(s, label_index);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (send_as4_path) {\n\t\t/* If the peer is NOT As4 capable, AND */\n\t\t/* there are ASnums > 65535 in path  THEN\n\t\t * give out AS4_PATH */\n\n\t\t/* Get rid of all AS_CONFED_SEQUENCE and AS_CONFED_SET\n\t\t * path segments!\n\t\t * Hm, I wonder...  confederation things *should* only be at\n\t\t * the beginning of an aspath, right?  Then we should use\n\t\t * aspath_delete_confed_seq for this, because it is already\n\t\t * there! (JK)\n\t\t * Folks, talk to me: what is reasonable here!?\n\t\t */\n\t\taspath = aspath_delete_confed_seq(aspath);\n\n\t\tstream_putc(s,\n\t\t\t    BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\tstream_putc(s, BGP_ATTR_AS4_PATH);\n\t\taspath_sizep = stream_get_endp(s);\n\t\tstream_putw(s, 0);\n\t\tstream_putw_at(s, aspath_sizep, aspath_put(s, aspath, 1));\n\t}\n\n\tif (aspath != attr->aspath)\n\t\taspath_free(aspath);\n\n\tif (send_as4_aggregator) {\n\t\t/* send AS4_AGGREGATOR, at this place */\n\t\t/* this section of code moved here in order to ensure the\n\t\t * correct\n\t\t * *ascending* order of attributes\n\t\t */\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_AS4_AGGREGATOR);\n\t\tstream_putc(s, 8);\n\t\tstream_putl(s, attr->aggregator_as);\n\t\tstream_put_ipv4(s, attr->aggregator_addr.s_addr);\n\t}\n\n\tif (((afi == AFI_IP || afi == AFI_IP6)\n\t     && (safi == SAFI_ENCAP || safi == SAFI_MPLS_VPN))\n\t    || (afi == AFI_L2VPN && safi == SAFI_EVPN)) {\n\t\t/* Tunnel Encap attribute */\n\t\tbgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_ENCAP);\n\n#if ENABLE_BGP_VNC\n\t\t/* VNC attribute */\n\t\tbgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_VNC);\n#endif\n\t}\n\n\t/* PMSI Tunnel */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PMSI_TUNNEL)) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_PMSI_TUNNEL);\n\t\tstream_putc(s, 9); // Length\n\t\tstream_putc(s, 0); // Flags\n\t\tstream_putc(s, PMSI_TNLTYPE_INGR_REPL); // IR (6)\n\t\tstream_put(s, &(attr->label),\n\t\t\t   BGP_LABEL_BYTES); // MPLS Label / VXLAN VNI\n\t\tstream_put_ipv4(s, attr->nexthop.s_addr);\n\t\t// Unicast tunnel endpoint IP address\n\t}\n\n\t/* Unknown transit attribute. */\n\tif (attr->transit)\n\t\tstream_put(s, attr->transit->val, attr->transit->length);\n\n\t/* Return total size of attribute. */\n\treturn stream_get_endp(s) - cp;\n}\n\nsize_t bgp_packet_mpunreach_start(struct stream *s, afi_t afi, safi_t safi)\n{\n\tunsigned long attrlen_pnt;\n\tiana_afi_t pkt_afi;\n\tiana_safi_t pkt_safi;\n\n\t/* Set extended bit always to encode the attribute length as 2 bytes */\n\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN);\n\tstream_putc(s, BGP_ATTR_MP_UNREACH_NLRI);\n\n\tattrlen_pnt = stream_get_endp(s);\n\tstream_putw(s, 0); /* Length of this attribute. */\n\n\t/* Convert AFI, SAFI to values for packet. */\n\tbgp_map_afi_safi_int2iana(afi, safi, &pkt_afi, &pkt_safi);\n\n\tstream_putw(s, pkt_afi);\n\tstream_putc(s, pkt_safi);\n\n\treturn attrlen_pnt;\n}\n\nvoid bgp_packet_mpunreach_prefix(struct stream *s, struct prefix *p, afi_t afi,\n\t\t\t\t safi_t safi, struct prefix_rd *prd,\n\t\t\t\t mpls_label_t *label, uint32_t num_labels,\n\t\t\t\t int addpath_encode, uint32_t addpath_tx_id,\n\t\t\t\t struct attr *attr)\n{\n\tuint8_t wlabel[3] = {0x80, 0x00, 0x00};\n\n\tif (safi == SAFI_LABELED_UNICAST) {\n\t\tlabel = (mpls_label_t *)wlabel;\n\t\tnum_labels = 1;\n\t}\n\n\tbgp_packet_mpattr_prefix(s, afi, safi, p, prd, label, num_labels,\n\t\t\t\t addpath_encode, addpath_tx_id, attr);\n}\n\nvoid bgp_packet_mpunreach_end(struct stream *s, size_t attrlen_pnt)\n{\n\tbgp_packet_mpattr_end(s, attrlen_pnt);\n}\n\n/* Initialization of attribute. */\nvoid bgp_attr_init(void)\n{\n\taspath_init();\n\tattrhash_init();\n\tcommunity_init();\n\tecommunity_init();\n\tlcommunity_init();\n\tcluster_init();\n\ttransit_init();\n\tencap_init();\n}\n\nvoid bgp_attr_finish(void)\n{\n\taspath_finish();\n\tattrhash_finish();\n\tcommunity_finish();\n\tecommunity_finish();\n\tlcommunity_finish();\n\tcluster_finish();\n\ttransit_finish();\n\tencap_finish();\n}\n\n/* Make attribute packet. */\nvoid bgp_dump_routes_attr(struct stream *s, struct attr *attr,\n\t\t\t  struct prefix *prefix)\n{\n\tunsigned long cp;\n\tunsigned long len;\n\tsize_t aspath_lenp;\n\tstruct aspath *aspath;\n\tint addpath_encode = 0;\n\tuint32_t addpath_tx_id = 0;\n\n\t/* Remember current pointer. */\n\tcp = stream_get_endp(s);\n\n\t/* Place holder of length. */\n\tstream_putw(s, 0);\n\n\t/* Origin attribute. */\n\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\tstream_putc(s, BGP_ATTR_ORIGIN);\n\tstream_putc(s, 1);\n\tstream_putc(s, attr->origin);\n\n\taspath = attr->aspath;\n\n\tstream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN);\n\tstream_putc(s, BGP_ATTR_AS_PATH);\n\taspath_lenp = stream_get_endp(s);\n\tstream_putw(s, 0);\n\n\tstream_putw_at(s, aspath_lenp, aspath_put(s, aspath, 1));\n\n\t/* Nexthop attribute. */\n\t/* If it's an IPv6 prefix, don't dump the IPv4 nexthop to save space */\n\tif (prefix != NULL && prefix->family != AF_INET6) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_NEXT_HOP);\n\t\tstream_putc(s, 4);\n\t\tstream_put_ipv4(s, attr->nexthop.s_addr);\n\t}\n\n\t/* MED attribute. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC)) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL);\n\t\tstream_putc(s, BGP_ATTR_MULTI_EXIT_DISC);\n\t\tstream_putc(s, 4);\n\t\tstream_putl(s, attr->med);\n\t}\n\n\t/* Local preference. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_LOCAL_PREF);\n\t\tstream_putc(s, 4);\n\t\tstream_putl(s, attr->local_pref);\n\t}\n\n\t/* Atomic aggregate. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE)) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_ATOMIC_AGGREGATE);\n\t\tstream_putc(s, 0);\n\t}\n\n\t/* Aggregator. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR)) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_AGGREGATOR);\n\t\tstream_putc(s, 8);\n\t\tstream_putl(s, attr->aggregator_as);\n\t\tstream_put_ipv4(s, attr->aggregator_addr.s_addr);\n\t}\n\n\t/* Community attribute. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES)) {\n\t\tif (attr->community->size * 4 > 255) {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS\n\t\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\t\tstream_putc(s, BGP_ATTR_COMMUNITIES);\n\t\t\tstream_putw(s, attr->community->size * 4);\n\t\t} else {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);\n\t\t\tstream_putc(s, BGP_ATTR_COMMUNITIES);\n\t\t\tstream_putc(s, attr->community->size * 4);\n\t\t}\n\t\tstream_put(s, attr->community->val, attr->community->size * 4);\n\t}\n\n\t/* Large Community attribute. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES)) {\n\t\tif (lcom_length(attr->lcommunity) > 255) {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS\n\t\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\t\tstream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);\n\t\t\tstream_putw(s, lcom_length(attr->lcommunity));\n\t\t} else {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);\n\t\t\tstream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);\n\t\t\tstream_putc(s, lcom_length(attr->lcommunity));\n\t\t}\n\n\t\tstream_put(s, attr->lcommunity->val,\n\t\t\t   lcom_length(attr->lcommunity));\n\t}\n\n\t/* Add a MP_NLRI attribute to dump the IPv6 next hop */\n\tif (prefix != NULL && prefix->family == AF_INET6\n\t    && (attr->mp_nexthop_len == BGP_ATTR_NHLEN_IPV6_GLOBAL\n\t\t|| attr->mp_nexthop_len == BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL)) {\n\t\tint sizep;\n\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL);\n\t\tstream_putc(s, BGP_ATTR_MP_REACH_NLRI);\n\t\tsizep = stream_get_endp(s);\n\n\t\t/* MP header */\n\t\tstream_putc(s, 0);\t    /* Marker: Attribute length. */\n\t\tstream_putw(s, AFI_IP6);      /* AFI */\n\t\tstream_putc(s, SAFI_UNICAST); /* SAFI */\n\n\t\t/* Next hop */\n\t\tstream_putc(s, attr->mp_nexthop_len);\n\t\tstream_put(s, &attr->mp_nexthop_global, IPV6_MAX_BYTELEN);\n\t\tif (attr->mp_nexthop_len == BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL)\n\t\t\tstream_put(s, &attr->mp_nexthop_local,\n\t\t\t\t   IPV6_MAX_BYTELEN);\n\n\t\t/* SNPA */\n\t\tstream_putc(s, 0);\n\n\t\t/* Prefix */\n\t\tstream_put_prefix_addpath(s, prefix, addpath_encode,\n\t\t\t\t\t  addpath_tx_id);\n\n\t\t/* Set MP attribute length. */\n\t\tstream_putc_at(s, sizep, (stream_get_endp(s) - sizep) - 1);\n\t}\n\n\t/* Prefix SID */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID)) {\n\t\tif (attr->label_index != BGP_INVALID_LABEL_INDEX) {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);\n\t\t\tstream_putc(s, BGP_ATTR_PREFIX_SID);\n\t\t\tstream_putc(s, 10);\n\t\t\tstream_putc(s, BGP_PREFIX_SID_LABEL_INDEX);\n\t\t\tstream_putc(s, BGP_PREFIX_SID_LABEL_INDEX_LENGTH);\n\t\t\tstream_putc(s, 0); // reserved\n\t\t\tstream_putw(s, 0); // flags\n\t\t\tstream_putl(s, attr->label_index);\n\t\t}\n\t}\n\n\t/* Return total size of attribute. */\n\tlen = stream_get_endp(s) - cp - 2;\n\tstream_putw_at(s, cp, len);\n}\n", "/* BGP message definition header.\n * Copyright (C) 1996, 97, 98, 99, 2000 Kunihiro Ishiguro\n *\n * This file is part of GNU Zebra.\n *\n * GNU Zebra is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2, or (at your option) any\n * later version.\n *\n * GNU Zebra is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; see the file COPYING; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef _QUAGGA_BGPD_H\n#define _QUAGGA_BGPD_H\n\n#include \"qobj.h\"\n#include <pthread.h>\n\n#include \"frr_pthread.h\"\n#include \"lib/json.h\"\n#include \"vrf.h\"\n#include \"vty.h\"\n\n/* For union sockunion.  */\n#include \"queue.h\"\n#include \"sockunion.h\"\n#include \"routemap.h\"\n#include \"linklist.h\"\n#include \"defaults.h\"\n#include \"bgp_memory.h\"\n#include \"bitfield.h\"\n#include \"vxlan.h\"\n#include \"bgp_labelpool.h\"\n#include \"bgp_addpath_types.h\"\n\n#define BGP_MAX_HOSTNAME 64\t/* Linux max, is larger than most other sys */\n#define BGP_PEER_MAX_HASH_SIZE 16384\n\n/* Default interval for IPv6 RAs when triggered by BGP unnumbered neighbor. */\n#define BGP_UNNUM_DEFAULT_RA_INTERVAL 10\n\nstruct update_subgroup;\nstruct bpacket;\nstruct bgp_pbr_config;\n\n/*\n * Allow the neighbor XXXX remote-as to take internal or external\n * AS_SPECIFIED is zero to auto-inherit original non-feature/enhancement\n * behavior\n * in the system.\n */\nenum { AS_UNSPECIFIED = 0,\n       AS_SPECIFIED,\n       AS_INTERNAL,\n       AS_EXTERNAL,\n};\n\n/* Typedef BGP specific types.  */\ntypedef uint32_t as_t;\ntypedef uint16_t as16_t; /* we may still encounter 16 Bit asnums */\ntypedef uint16_t bgp_size_t;\n\n#define max(a, b)                                                              \\\n\t({                                                                     \\\n\t\t__typeof__(a) _a = (a);                                        \\\n\t\t__typeof__(b) _b = (b);                                        \\\n\t\t_a > _b ? _a : _b;                                             \\\n\t})\n\nenum bgp_af_index {\n\tBGP_AF_START,\n\tBGP_AF_IPV4_UNICAST = BGP_AF_START,\n\tBGP_AF_IPV4_MULTICAST,\n\tBGP_AF_IPV4_VPN,\n\tBGP_AF_IPV6_UNICAST,\n\tBGP_AF_IPV6_MULTICAST,\n\tBGP_AF_IPV6_VPN,\n\tBGP_AF_IPV4_ENCAP,\n\tBGP_AF_IPV6_ENCAP,\n\tBGP_AF_L2VPN_EVPN,\n\tBGP_AF_IPV4_LBL_UNICAST,\n\tBGP_AF_IPV6_LBL_UNICAST,\n\tBGP_AF_IPV4_FLOWSPEC,\n\tBGP_AF_IPV6_FLOWSPEC,\n\tBGP_AF_MAX\n};\n\n#define AF_FOREACH(af) for ((af) = BGP_AF_START; (af) < BGP_AF_MAX; (af)++)\n\n#define FOREACH_AFI_SAFI(afi, safi)                                            \\\n\tfor (afi = AFI_IP; afi < AFI_MAX; afi++)                               \\\n\t\tfor (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)\n\nextern struct frr_pthread *bgp_pth_io;\nextern struct frr_pthread *bgp_pth_ka;\n\n/* BGP master for system wide configurations and variables.  */\nstruct bgp_master {\n\t/* BGP instance list.  */\n\tstruct list *bgp;\n\n\t/* BGP thread master.  */\n\tstruct thread_master *master;\n\n\t/* work queues */\n\tstruct work_queue *process_main_queue;\n\n\t/* Listening sockets */\n\tstruct list *listen_sockets;\n\n\t/* BGP port number.  */\n\tuint16_t port;\n\n\t/* Listener address */\n\tchar *address;\n\n\t/* BGP start time.  */\n\ttime_t start_time;\n\n\t/* Various BGP global configuration.  */\n\tuint8_t options;\n#define BGP_OPT_NO_FIB                   (1 << 0)\n#define BGP_OPT_MULTIPLE_INSTANCE        (1 << 1)\n#define BGP_OPT_CONFIG_CISCO             (1 << 2)\n#define BGP_OPT_NO_LISTEN                (1 << 3)\n#define BGP_OPT_NO_ZEBRA                 (1 << 4)\n\n\tuint64_t updgrp_idspace;\n\tuint64_t subgrp_idspace;\n\n\t/* timer to dampen route map changes */\n\tstruct thread *t_rmap_update; /* Handle route map updates */\n\tuint32_t rmap_update_timer;   /* Route map update timer */\n#define RMAP_DEFAULT_UPDATE_TIMER 5 /* disabled by default */\n\n\t/* Id space for automatic RD derivation for an EVI/VRF */\n\tbitfield_t rd_idspace;\n\n\t/* dynamic mpls label allocation pool */\n\tstruct labelpool labelpool;\n\n\tbool terminating;\t/* global flag that sigint terminate seen */\n\tQOBJ_FIELDS\n};\nDECLARE_QOBJ_TYPE(bgp_master)\n\n/* BGP route-map structure.  */\nstruct bgp_rmap {\n\tchar *name;\n\tstruct route_map *map;\n};\n\nstruct bgp_redist {\n\tunsigned short instance;\n\n\t/* BGP redistribute metric configuration. */\n\tuint8_t redist_metric_flag;\n\tuint32_t redist_metric;\n\n\t/* BGP redistribute route-map.  */\n\tstruct bgp_rmap rmap;\n};\n\ntypedef enum {\n\tBGP_VPN_POLICY_DIR_FROMVPN = 0,\n\tBGP_VPN_POLICY_DIR_TOVPN = 1,\n\tBGP_VPN_POLICY_DIR_MAX = 2\n} vpn_policy_direction_t;\n\nstruct vpn_policy {\n\tstruct bgp *bgp; /* parent */\n\tafi_t afi;\n\tstruct ecommunity *rtlist[BGP_VPN_POLICY_DIR_MAX];\n\tstruct ecommunity *import_redirect_rtlist;\n\tchar *rmap_name[BGP_VPN_POLICY_DIR_MAX];\n\tstruct route_map *rmap[BGP_VPN_POLICY_DIR_MAX];\n\n\t/* should be mpls_label_t? */\n\tuint32_t tovpn_label; /* may be MPLS_LABEL_NONE */\n\tuint32_t tovpn_zebra_vrf_label_last_sent;\n\tstruct prefix_rd tovpn_rd;\n\tstruct prefix tovpn_nexthop; /* unset => set to 0 */\n\tuint32_t flags;\n#define BGP_VPN_POLICY_TOVPN_LABEL_AUTO        (1 << 0)\n#define BGP_VPN_POLICY_TOVPN_RD_SET            (1 << 1)\n#define BGP_VPN_POLICY_TOVPN_NEXTHOP_SET       (1 << 2)\n\n\t/*\n\t * If we are importing another vrf into us keep a list of\n\t * vrf names that are being imported into us.\n\t */\n\tstruct list *import_vrf;\n\n\t/*\n\t * if we are being exported to another vrf keep a list of\n\t * vrf names that we are being exported to.\n\t */\n\tstruct list *export_vrf;\n};\n\n/*\n * Type of 'struct bgp'.\n * - Default: The default instance\n * - VRF: A specific (non-default) VRF\n * - View: An instance used for route exchange\n * The \"default\" instance is treated separately to simplify the code. Note\n * that if deployed in a Multi-VRF environment, it may not exist.\n */\nenum bgp_instance_type {\n\tBGP_INSTANCE_TYPE_DEFAULT,\n\tBGP_INSTANCE_TYPE_VRF,\n\tBGP_INSTANCE_TYPE_VIEW\n};\n\n/* BGP instance structure.  */\nstruct bgp {\n\t/* AS number of this BGP instance.  */\n\tas_t as;\n\n\t/* Name of this BGP instance.  */\n\tchar *name;\n\tchar *name_pretty;\t/* printable \"VRF|VIEW name|default\" */\n\n\t/* Type of instance and VRF id. */\n\tenum bgp_instance_type inst_type;\n\tvrf_id_t vrf_id;\n\n\t/* Reference count to allow peer_delete to finish after bgp_delete */\n\tint lock;\n\n\t/* Self peer.  */\n\tstruct peer *peer_self;\n\n\t/* BGP peer. */\n\tstruct list *peer;\n\tstruct hash *peerhash;\n\n\t/* BGP peer group.  */\n\tstruct list *group;\n\n\t/* The maximum number of BGP dynamic neighbors that can be created */\n\tint dynamic_neighbors_limit;\n\n\t/* The current number of BGP dynamic neighbors */\n\tint dynamic_neighbors_count;\n\n\tstruct hash *update_groups[BGP_AF_MAX];\n\n\t/*\n\t * Global statistics for update groups.\n\t */\n\tstruct {\n\t\tuint32_t join_events;\n\t\tuint32_t prune_events;\n\t\tuint32_t merge_events;\n\t\tuint32_t split_events;\n\t\tuint32_t updgrp_switch_events;\n\t\tuint32_t peer_refreshes_combined;\n\t\tuint32_t adj_count;\n\t\tuint32_t merge_checks_triggered;\n\n\t\tuint32_t updgrps_created;\n\t\tuint32_t updgrps_deleted;\n\t\tuint32_t subgrps_created;\n\t\tuint32_t subgrps_deleted;\n\t} update_group_stats;\n\n\t/* BGP configuration.  */\n\tuint16_t config;\n#define BGP_CONFIG_CLUSTER_ID             (1 << 0)\n#define BGP_CONFIG_CONFEDERATION          (1 << 1)\n\n\t/* BGP router identifier.  */\n\tstruct in_addr router_id;\n\tstruct in_addr router_id_static;\n\tstruct in_addr router_id_zebra;\n\n\t/* BGP route reflector cluster ID.  */\n\tstruct in_addr cluster_id;\n\n\t/* BGP confederation information.  */\n\tas_t confed_id;\n\tas_t *confed_peers;\n\tint confed_peers_cnt;\n\n\tstruct thread\n\t\t*t_startup; /* start-up timer on only once at the beginning */\n\n\tuint32_t v_maxmed_onstartup; /* Duration of max-med on start-up */\n#define BGP_MAXMED_ONSTARTUP_UNCONFIGURED  0 /* 0 means off, its the default */\n\tuint32_t maxmed_onstartup_value;     /* Max-med value when active on\n\t\t\t\t\t\t start-up */\n\tstruct thread\n\t\t*t_maxmed_onstartup; /* non-null when max-med onstartup is on */\n\tuint8_t maxmed_onstartup_over; /* Flag to make it effective only once */\n\n\tuint8_t v_maxmed_admin; /* 1/0 if max-med administrative is on/off */\n#define BGP_MAXMED_ADMIN_UNCONFIGURED  0 /* Off by default */\n\tuint32_t maxmed_admin_value; /* Max-med value when administrative in on\n\t\t\t\t      */\n#define BGP_MAXMED_VALUE_DEFAULT  4294967294 /* Maximum by default */\n\n\tuint8_t maxmed_active; /* 1/0 if max-med is active or not */\n\tuint32_t maxmed_value; /* Max-med value when its active */\n\n\t/* BGP update delay on startup */\n\tstruct thread *t_update_delay;\n\tstruct thread *t_establish_wait;\n\tuint8_t update_delay_over;\n\tuint8_t main_zebra_update_hold;\n\tuint8_t main_peers_update_hold;\n\tuint16_t v_update_delay;\n\tuint16_t v_establish_wait;\n\tchar update_delay_begin_time[64];\n\tchar update_delay_end_time[64];\n\tchar update_delay_zebra_resume_time[64];\n\tchar update_delay_peers_resume_time[64];\n\tuint32_t established;\n\tuint32_t restarted_peers;\n\tuint32_t implicit_eors;\n\tuint32_t explicit_eors;\n#define BGP_UPDATE_DELAY_DEF              0\n#define BGP_UPDATE_DELAY_MIN              0\n#define BGP_UPDATE_DELAY_MAX              3600\n\n\t/* BGP flags. */\n\tuint32_t flags;\n#define BGP_FLAG_ALWAYS_COMPARE_MED       (1 << 0)\n#define BGP_FLAG_DETERMINISTIC_MED        (1 << 1)\n#define BGP_FLAG_MED_MISSING_AS_WORST     (1 << 2)\n#define BGP_FLAG_MED_CONFED               (1 << 3)\n#define BGP_FLAG_NO_DEFAULT_IPV4          (1 << 4)\n#define BGP_FLAG_NO_CLIENT_TO_CLIENT      (1 << 5)\n#define BGP_FLAG_ENFORCE_FIRST_AS         (1 << 6)\n#define BGP_FLAG_COMPARE_ROUTER_ID        (1 << 7)\n#define BGP_FLAG_ASPATH_IGNORE            (1 << 8)\n#define BGP_FLAG_IMPORT_CHECK             (1 << 9)\n#define BGP_FLAG_NO_FAST_EXT_FAILOVER     (1 << 10)\n#define BGP_FLAG_LOG_NEIGHBOR_CHANGES     (1 << 11)\n#define BGP_FLAG_GRACEFUL_RESTART         (1 << 12)\n#define BGP_FLAG_ASPATH_CONFED            (1 << 13)\n#define BGP_FLAG_ASPATH_MULTIPATH_RELAX   (1 << 14)\n#define BGP_FLAG_RR_ALLOW_OUTBOUND_POLICY (1 << 15)\n#define BGP_FLAG_DISABLE_NH_CONNECTED_CHK (1 << 16)\n#define BGP_FLAG_MULTIPATH_RELAX_AS_SET   (1 << 17)\n#define BGP_FLAG_FORCE_STATIC_PROCESS     (1 << 18)\n#define BGP_FLAG_SHOW_HOSTNAME            (1 << 19)\n#define BGP_FLAG_GR_PRESERVE_FWD          (1 << 20)\n#define BGP_FLAG_GRACEFUL_SHUTDOWN        (1 << 21)\n\n\t/* BGP Per AF flags */\n\tuint16_t af_flags[AFI_MAX][SAFI_MAX];\n#define BGP_CONFIG_DAMPENING\t\t\t\t(1 << 0)\n/* l2vpn evpn flags - 1 << 0 is used for DAMPENNG */\n#define BGP_L2VPN_EVPN_ADVERTISE_IPV4_UNICAST\t\t(1 << 1)\n#define BGP_L2VPN_EVPN_ADVERTISE_IPV6_UNICAST\t\t(1 << 2)\n#define BGP_L2VPN_EVPN_DEFAULT_ORIGINATE_IPV4\t\t(1 << 3)\n#define BGP_L2VPN_EVPN_DEFAULT_ORIGINATE_IPV6\t\t(1 << 4)\n/* import/export between address families */\n#define BGP_CONFIG_VRF_TO_MPLSVPN_EXPORT\t\t(1 << 5)\n#define BGP_CONFIG_MPLSVPN_TO_VRF_IMPORT\t\t(1 << 6)\n/* vrf-route leaking flags */\n#define BGP_CONFIG_VRF_TO_VRF_IMPORT\t\t\t(1 << 7)\n#define BGP_CONFIG_VRF_TO_VRF_EXPORT\t\t\t(1 << 8)\n\n\t/* Route table for next-hop lookup cache. */\n\tstruct bgp_table *nexthop_cache_table[AFI_MAX];\n\n\t/* Route table for import-check */\n\tstruct bgp_table *import_check_table[AFI_MAX];\n\n\tstruct bgp_table *connected_table[AFI_MAX];\n\n\tstruct hash *address_hash;\n\n\t/* DB for all local tunnel-ips - used mainly for martian checks\n\t   Currently it only has all VxLan tunnel IPs*/\n\tstruct hash *tip_hash;\n\n\t/* Static route configuration.  */\n\tstruct bgp_table *route[AFI_MAX][SAFI_MAX];\n\n\t/* Aggregate address configuration.  */\n\tstruct bgp_table *aggregate[AFI_MAX][SAFI_MAX];\n\n\t/* BGP routing information base.  */\n\tstruct bgp_table *rib[AFI_MAX][SAFI_MAX];\n\n\t/* BGP table route-map.  */\n\tstruct bgp_rmap table_map[AFI_MAX][SAFI_MAX];\n\n\t/* BGP redistribute configuration. */\n\tstruct list *redist[AFI_MAX][ZEBRA_ROUTE_MAX];\n\n\t/* Allocate MPLS labels */\n\tuint8_t allocate_mpls_labels[AFI_MAX][SAFI_MAX];\n\n\t/* Allocate hash entries to store policy routing information\n\t * The hash are used to host pbr rules somewhere.\n\t * Actually, pbr will only be used by flowspec\n\t * those hash elements will have relationship together as\n\t * illustrated in below diagram:\n\t *\n\t *  pbr_action a <----- pbr_match i <--- pbr_match_entry 1..n\n\t *              <----- pbr_match j <--- pbr_match_entry 1..m\n\t *\n\t * - here in BGP structure, the list of match and actions will\n\t * stand for the list of ipset sets, and table_ids in the kernel\n\t * - the arrow above between pbr_match and pbr_action indicate\n\t * that a backpointer permits match to find the action\n\t * - the arrow betwen match_entry and match is a hash list\n\t * contained in match, that lists the whole set of entries\n\t */\n\tstruct hash *pbr_match_hash;\n\tstruct hash *pbr_action_hash;\n\n\t/* timer to re-evaluate neighbor default-originate route-maps */\n\tstruct thread *t_rmap_def_originate_eval;\n#define RMAP_DEFAULT_ORIGINATE_EVAL_TIMER 5\n\n\t/* BGP distance configuration.  */\n\tuint8_t distance_ebgp[AFI_MAX][SAFI_MAX];\n\tuint8_t distance_ibgp[AFI_MAX][SAFI_MAX];\n\tuint8_t distance_local[AFI_MAX][SAFI_MAX];\n\n\t/* BGP default local-preference.  */\n\tuint32_t default_local_pref;\n\n\t/* BGP default subgroup pkt queue max  */\n\tuint32_t default_subgroup_pkt_queue_max;\n\n\t/* BGP default timer.  */\n\tuint32_t default_holdtime;\n\tuint32_t default_keepalive;\n\n\t/* BGP graceful restart */\n\tuint32_t restart_time;\n\tuint32_t stalepath_time;\n\n\t/* Maximum-paths configuration */\n\tstruct bgp_maxpaths_cfg {\n\t\tuint16_t maxpaths_ebgp;\n\t\tuint16_t maxpaths_ibgp;\n\t\tuint16_t ibgp_flags;\n#define BGP_FLAG_IBGP_MULTIPATH_SAME_CLUSTERLEN (1 << 0)\n\t} maxpaths[AFI_MAX][SAFI_MAX];\n\n\t_Atomic uint32_t wpkt_quanta; // max # packets to write per i/o cycle\n\t_Atomic uint32_t rpkt_quanta; // max # packets to read per i/o cycle\n\n\t/* Automatic coalesce adjust on/off */\n\tbool heuristic_coalesce;\n\t/* Actual coalesce time */\n\tuint32_t coalesce_time;\n\n\t/* Auto-shutdown new peers */\n\tbool autoshutdown;\n\n\tstruct bgp_addpath_bgp_data tx_addpath;\n\n#if ENABLE_BGP_VNC\n\tstruct rfapi_cfg *rfapi_cfg;\n\tstruct rfapi *rfapi;\n#endif\n\n\t/* EVPN related information */\n\n\t/* EVI hash table */\n\tstruct hash *vnihash;\n\n\t/* EVPN enable - advertise gateway macip routes */\n\tint advertise_gw_macip;\n\n\t/* EVPN enable - advertise local VNIs and their MACs etc. */\n\tint advertise_all_vni;\n\n\tstruct bgp_evpn_info *evpn_info;\n\n\t/* EVPN - use RFC 8365 to auto-derive RT */\n\tint advertise_autort_rfc8365;\n\n\t/*\n\t * Flooding mechanism for BUM packets for VxLAN-EVPN.\n\t */\n\tenum vxlan_flood_control vxlan_flood_ctrl;\n\n\t/* Hash table of Import RTs to EVIs */\n\tstruct hash *import_rt_hash;\n\n\t/* Hash table of VRF import RTs to VRFs */\n\tstruct hash *vrf_import_rt_hash;\n\n\t/* L3-VNI corresponding to this vrf */\n\tvni_t l3vni;\n\n\t/* router-mac to be used in mac-ip routes for this vrf */\n\tstruct ethaddr rmac;\n\n\t/* originator ip - to be used as NH for type-5 routes */\n\tstruct in_addr originator_ip;\n\n\t/* vrf flags */\n\tuint32_t vrf_flags;\n#define BGP_VRF_AUTO                        (1 << 0)\n#define BGP_VRF_IMPORT_RT_CFGD              (1 << 1)\n#define BGP_VRF_EXPORT_RT_CFGD              (1 << 2)\n#define BGP_VRF_RD_CFGD                     (1 << 3)\n#define BGP_VRF_L3VNI_PREFIX_ROUTES_ONLY    (1 << 4)\n\n\n\t/* unique ID for auto derivation of RD for this vrf */\n\tuint16_t vrf_rd_id;\n\n\t/* Automatically derived RD for this VRF */\n\tstruct prefix_rd vrf_prd_auto;\n\n\t/* RD for this VRF */\n\tstruct prefix_rd vrf_prd;\n\n\t/* import rt list for the vrf instance */\n\tstruct list *vrf_import_rtl;\n\n\t/* export rt list for the vrf instance */\n\tstruct list *vrf_export_rtl;\n\n\t/* list of corresponding l2vnis (struct bgpevpn) */\n\tstruct list *l2vnis;\n\n\t/* route map for advertise ipv4/ipv6 unicast (type-5 routes) */\n\tstruct bgp_rmap adv_cmd_rmap[AFI_MAX][SAFI_MAX];\n\n\tstruct vpn_policy vpn_policy[AFI_MAX];\n\n\tstruct bgp_pbr_config *bgp_pbr_cfg;\n\n\t/* local esi hash table */\n\tstruct hash *esihash;\n\n\t/* Count of peers in established state */\n\tuint32_t established_peers;\n\n\tQOBJ_FIELDS\n};\nDECLARE_QOBJ_TYPE(bgp)\n\n#define BGP_ROUTE_ADV_HOLD(bgp) (bgp->main_peers_update_hold)\n\n#define IS_BGP_INST_KNOWN_TO_ZEBRA(bgp)                                        \\\n\t(bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT                           \\\n\t || (bgp->inst_type == BGP_INSTANCE_TYPE_VRF                           \\\n\t     && bgp->vrf_id != VRF_UNKNOWN))\n\n/* BGP peer-group support. */\nstruct peer_group {\n\t/* Name of the peer-group. */\n\tchar *name;\n\n\t/* Pointer to BGP.  */\n\tstruct bgp *bgp;\n\n\t/* Peer-group client list. */\n\tstruct list *peer;\n\n\t/** Dynamic neighbor listening ranges */\n\tstruct list *listen_range[AFI_MAX];\n\n\t/* Peer-group config */\n\tstruct peer *conf;\n};\n\n/* BGP Notify message format. */\nstruct bgp_notify {\n\tuint8_t code;\n\tuint8_t subcode;\n\tchar *data;\n\tbgp_size_t length;\n\tuint8_t *raw_data;\n};\n\n/* Next hop self address. */\nstruct bgp_nexthop {\n\tstruct interface *ifp;\n\tstruct in_addr v4;\n\tstruct in6_addr v6_global;\n\tstruct in6_addr v6_local;\n};\n\n/* BGP addpath values */\n#define BGP_ADDPATH_RX     1\n#define BGP_ADDPATH_TX     2\n#define BGP_ADDPATH_ID_LEN 4\n\n#define BGP_ADDPATH_TX_ID_FOR_DEFAULT_ORIGINATE 1\n\n/* Route map direction */\n#define RMAP_IN  0\n#define RMAP_OUT 1\n#define RMAP_MAX 2\n\n#include \"filter.h\"\n\n/* BGP filter structure. */\nstruct bgp_filter {\n\t/* Distribute-list.  */\n\tstruct {\n\t\tchar *name;\n\t\tstruct access_list *alist;\n\t} dlist[FILTER_MAX];\n\n\t/* Prefix-list.  */\n\tstruct {\n\t\tchar *name;\n\t\tstruct prefix_list *plist;\n\t} plist[FILTER_MAX];\n\n\t/* Filter-list.  */\n\tstruct {\n\t\tchar *name;\n\t\tstruct as_list *aslist;\n\t} aslist[FILTER_MAX];\n\n\t/* Route-map.  */\n\tstruct {\n\t\tchar *name;\n\t\tstruct route_map *map;\n\t} map[RMAP_MAX];\n\n\t/* Unsuppress-map.  */\n\tstruct {\n\t\tchar *name;\n\t\tstruct route_map *map;\n\t} usmap;\n};\n\n/* IBGP/EBGP identifier.  We also have a CONFED peer, which is to say,\n   a peer who's AS is part of our Confederation.  */\ntypedef enum {\n\tBGP_PEER_IBGP = 1,\n\tBGP_PEER_EBGP,\n\tBGP_PEER_INTERNAL,\n\tBGP_PEER_CONFED,\n} bgp_peer_sort_t;\n\n/* BGP message header and packet size.  */\n#define BGP_MARKER_SIZE\t\t                16\n#define BGP_HEADER_SIZE\t\t                19\n#define BGP_MAX_PACKET_SIZE                   4096\n#define BGP_MAX_PACKET_SIZE_OVERFLOW          1024\n\n/*\n * Trigger delay for bgp_announce_route().\n */\n#define BGP_ANNOUNCE_ROUTE_SHORT_DELAY_MS  100\n#define BGP_ANNOUNCE_ROUTE_DELAY_MS        500\n\nstruct peer_af {\n\t/* back pointer to the peer */\n\tstruct peer *peer;\n\n\t/* which subgroup the peer_af belongs to */\n\tstruct update_subgroup *subgroup;\n\n\t/* for being part of an update subgroup's peer list */\n\tLIST_ENTRY(peer_af) subgrp_train;\n\n\t/* for being part of a packet's peer list */\n\tLIST_ENTRY(peer_af) pkt_train;\n\n\tstruct bpacket *next_pkt_to_send;\n\n\t/*\n\t * Trigger timer for bgp_announce_route().\n\t */\n\tstruct thread *t_announce_route;\n\n\tafi_t afi;\n\tsafi_t safi;\n\tint afid;\n};\n\n/* BGP neighbor structure. */\nstruct peer {\n\t/* BGP structure.  */\n\tstruct bgp *bgp;\n\n\t/* reference count, primarily to allow bgp_process'ing of route_node's\n\t * to be done after a struct peer is deleted.\n\t *\n\t * named 'lock' for hysterical reasons within Quagga.\n\t */\n\tint lock;\n\n\t/* BGP peer group.  */\n\tstruct peer_group *group;\n\tuint64_t version[AFI_MAX][SAFI_MAX];\n\n\t/* BGP peer_af structures, per configured AF on this peer */\n\tstruct peer_af *peer_af_array[BGP_AF_MAX];\n\n\t/* Peer's remote AS number. */\n\tint as_type;\n\tas_t as;\n\n\t/* Peer's local AS number. */\n\tas_t local_as;\n\n\tbgp_peer_sort_t sort;\n\n\t/* Peer's Change local AS number. */\n\tas_t change_local_as;\n\n\t/* Remote router ID. */\n\tstruct in_addr remote_id;\n\n\t/* Local router ID. */\n\tstruct in_addr local_id;\n\n\t/* Packet receive and send buffer. */\n\tpthread_mutex_t io_mtx;   // guards ibuf, obuf\n\tstruct stream_fifo *ibuf; // packets waiting to be processed\n\tstruct stream_fifo *obuf; // packets waiting to be written\n\n\tstruct ringbuf *ibuf_work; // WiP buffer used by bgp_read() only\n\tstruct stream *obuf_work;  // WiP buffer used to construct packets\n\n\tstruct stream *curr; // the current packet being parsed\n\n\t/* We use a separate stream to encode MP_REACH_NLRI for efficient\n\t * NLRI packing. peer->obuf_work stores all the other attributes. The\n\t * actual packet is then constructed by concatenating the two.\n\t */\n\tstruct stream *scratch;\n\n\t/* the doppelganger peer structure, due to dual TCP conn setup */\n\tstruct peer *doppelganger;\n\n\t/* Status of the peer. */\n\tint status;\n\tint ostatus;\n\n\t/* FSM events, stored for debug purposes.\n\t * Note: uchar used for reduced memory usage.\n\t */\n\tunsigned char cur_event;\n\tunsigned char last_event;\n\tunsigned char last_major_event;\n\n\t/* Peer index, used for dumping TABLE_DUMP_V2 format */\n\tuint16_t table_dump_index;\n\n\t/* Peer information */\n\tint fd;\t\t     /* File descriptor */\n\tint ttl;\t     /* TTL of TCP connection to the peer. */\n\tint rtt;\t     /* Estimated round-trip-time from TCP_INFO */\n\tint gtsm_hops;       /* minimum hopcount to peer */\n\tchar *desc;\t  /* Description of the peer. */\n\tunsigned short port; /* Destination port for peer */\n\tchar *host;\t  /* Printable address of the peer. */\n\tunion sockunion su;  /* Sockunion address of the peer. */\n#define BGP_PEER_SU_UNSPEC(peer) (peer->su.sa.sa_family == AF_UNSPEC)\n\ttime_t uptime;       /* Last Up/Down time */\n\ttime_t readtime;     /* Last read time */\n\ttime_t resettime;    /* Last reset time */\n\n\tchar *conf_if;\t /* neighbor interface config name. */\n\tstruct interface *ifp; /* corresponding interface */\n\tchar *ifname;\t  /* bind interface name. */\n\tchar *update_if;\n\tunion sockunion *update_source;\n\n\tunion sockunion *su_local;  /* Sockunion of local address.  */\n\tunion sockunion *su_remote; /* Sockunion of remote address.  */\n\tint shared_network;\t /* Is this peer shared same network. */\n\tstruct bgp_nexthop nexthop; /* Nexthop */\n\n\t/* Peer address family configuration. */\n\tuint8_t afc[AFI_MAX][SAFI_MAX];\n\tuint8_t afc_nego[AFI_MAX][SAFI_MAX];\n\tuint8_t afc_adv[AFI_MAX][SAFI_MAX];\n\tuint8_t afc_recv[AFI_MAX][SAFI_MAX];\n\n\t/* Capability flags (reset in bgp_stop) */\n\tuint32_t cap;\n#define PEER_CAP_REFRESH_ADV                (1 << 0) /* refresh advertised */\n#define PEER_CAP_REFRESH_OLD_RCV            (1 << 1) /* refresh old received */\n#define PEER_CAP_REFRESH_NEW_RCV            (1 << 2) /* refresh rfc received */\n#define PEER_CAP_DYNAMIC_ADV                (1 << 3) /* dynamic advertised */\n#define PEER_CAP_DYNAMIC_RCV                (1 << 4) /* dynamic received */\n#define PEER_CAP_RESTART_ADV                (1 << 5) /* restart advertised */\n#define PEER_CAP_RESTART_RCV                (1 << 6) /* restart received */\n#define PEER_CAP_AS4_ADV                    (1 << 7) /* as4 advertised */\n#define PEER_CAP_AS4_RCV                    (1 << 8) /* as4 received */\n#define PEER_CAP_RESTART_BIT_ADV            (1 << 9) /* sent restart state */\n#define PEER_CAP_RESTART_BIT_RCV            (1 << 10) /* peer restart state */\n#define PEER_CAP_ADDPATH_ADV                (1 << 11) /* addpath advertised */\n#define PEER_CAP_ADDPATH_RCV                (1 << 12) /* addpath received */\n#define PEER_CAP_ENHE_ADV                   (1 << 13) /* Extended nexthop advertised */\n#define PEER_CAP_ENHE_RCV                   (1 << 14) /* Extended nexthop received */\n#define PEER_CAP_HOSTNAME_ADV               (1 << 15) /* hostname advertised */\n#define PEER_CAP_HOSTNAME_RCV               (1 << 16) /* hostname received */\n\n\t/* Capability flags (reset in bgp_stop) */\n\tuint32_t af_cap[AFI_MAX][SAFI_MAX];\n#define PEER_CAP_ORF_PREFIX_SM_ADV          (1 << 0) /* send-mode advertised */\n#define PEER_CAP_ORF_PREFIX_RM_ADV          (1 << 1) /* receive-mode advertised */\n#define PEER_CAP_ORF_PREFIX_SM_RCV          (1 << 2) /* send-mode received */\n#define PEER_CAP_ORF_PREFIX_RM_RCV          (1 << 3) /* receive-mode received */\n#define PEER_CAP_ORF_PREFIX_SM_OLD_RCV      (1 << 4) /* send-mode received */\n#define PEER_CAP_ORF_PREFIX_RM_OLD_RCV      (1 << 5) /* receive-mode received */\n#define PEER_CAP_RESTART_AF_RCV             (1 << 6) /* graceful restart afi/safi received */\n#define PEER_CAP_RESTART_AF_PRESERVE_RCV    (1 << 7) /* graceful restart afi/safi F-bit received */\n#define PEER_CAP_ADDPATH_AF_TX_ADV          (1 << 8) /* addpath tx advertised */\n#define PEER_CAP_ADDPATH_AF_TX_RCV          (1 << 9) /* addpath tx received */\n#define PEER_CAP_ADDPATH_AF_RX_ADV          (1 << 10) /* addpath rx advertised */\n#define PEER_CAP_ADDPATH_AF_RX_RCV          (1 << 11) /* addpath rx received */\n#define PEER_CAP_ENHE_AF_ADV                (1 << 12) /* Extended nexthopi afi/safi advertised */\n#define PEER_CAP_ENHE_AF_RCV                (1 << 13) /* Extended nexthop afi/safi received */\n#define PEER_CAP_ENHE_AF_NEGO               (1 << 14) /* Extended nexthop afi/safi negotiated */\n\n\t/* Global configuration flags. */\n\t/*\n\t * Parallel array to flags that indicates whether each flag originates\n\t * from a peer-group or if it is config that is specific to this\n\t * individual peer. If a flag is set independent of the peer-group, the\n\t * same bit should be set here. If this peer is a peer-group, this\n\t * memory region should be all zeros.\n\t *\n\t * The assumption is that the default state for all flags is unset,\n\t * so if a flag is unset, the corresponding override flag is unset too.\n\t * However if a flag is set, the corresponding override flag is set.\n\t */\n\tuint32_t flags_override;\n\t/*\n\t * Parallel array to flags that indicates whether the default behavior\n\t * of *flags_override* should be inverted. If a flag is unset and the\n\t * corresponding invert flag is set, the corresponding override flag\n\t * would be set. However if a flag is set and the corresponding invert\n\t * flag is unset, the corresponding override flag would be unset.\n\t *\n\t * This can be used for attributes like *send-community*, which are\n\t * implicitely enabled and have to be disabled explicitely, compared to\n\t * 'normal' attributes like *next-hop-self* which are implicitely set.\n\t *\n\t * All operations dealing with flags should apply the following boolean\n\t * logic to keep the internal flag system in a sane state:\n\t *\n\t * value=0 invert=0\tInherit flag if member, otherwise unset flag\n\t * value=0 invert=1\tUnset flag unconditionally\n\t * value=1 invert=0\tSet flag unconditionally\n\t * value=1 invert=1\tInherit flag if member, otherwise set flag\n\t *\n\t * Contrary to the implementation of *flags_override*, the flag\n\t * inversion state can be set either on the peer OR the peer *and* the\n\t * peer-group. This was done on purpose, as the inversion state of a\n\t * flag can be determined on either the peer or the peer-group.\n\t *\n\t * Example: Enabling the cisco configuration mode inverts all flags\n\t * related to *send-community* unconditionally for both peer-groups and\n\t * peers.\n\t *\n\t * This behavior is different for interface peers though, which enable\n\t * the *extended-nexthop* flag by default, which regular peers do not.\n\t * As the peer-group can contain both regular and interface peers, the\n\t * flag inversion state must be set on the peer only.\n\t *\n\t * When a peer inherits the configuration from a peer-group and the\n\t * inversion state of the flag differs between peer and peer-group, the\n\t * newly set value must equal to the inverted state of the peer-group.\n\t */\n\tuint32_t flags_invert;\n\t/*\n\t * Effective array for storing the peer/peer-group flags. In case of a\n\t * peer-group, the peer-specific overrides (see flags_override and\n\t * flags_invert) must be respected.\n\t */\n\tuint32_t flags;\n#define PEER_FLAG_PASSIVE                   (1 << 0) /* passive mode */\n#define PEER_FLAG_SHUTDOWN                  (1 << 1) /* shutdown */\n#define PEER_FLAG_DONT_CAPABILITY           (1 << 2) /* dont-capability */\n#define PEER_FLAG_OVERRIDE_CAPABILITY       (1 << 3) /* override-capability */\n#define PEER_FLAG_STRICT_CAP_MATCH          (1 << 4) /* strict-match */\n#define PEER_FLAG_DYNAMIC_CAPABILITY        (1 << 5) /* dynamic capability */\n#define PEER_FLAG_DISABLE_CONNECTED_CHECK   (1 << 6) /* disable-connected-check */\n#define PEER_FLAG_LOCAL_AS_NO_PREPEND       (1 << 7) /* local-as no-prepend */\n#define PEER_FLAG_LOCAL_AS_REPLACE_AS       (1 << 8) /* local-as no-prepend replace-as */\n#define PEER_FLAG_DELETE                    (1 << 9) /* mark the peer for deleting */\n#define PEER_FLAG_CONFIG_NODE               (1 << 10) /* the node to update configs on */\n#define PEER_FLAG_LONESOUL                  (1 << 11)\n#define PEER_FLAG_DYNAMIC_NEIGHBOR          (1 << 12) /* dynamic neighbor */\n#define PEER_FLAG_CAPABILITY_ENHE           (1 << 13) /* Extended next-hop (rfc 5549)*/\n#define PEER_FLAG_IFPEER_V6ONLY             (1 << 14) /* if-based peer is v6 only */\n#define PEER_FLAG_IS_RFAPI_HD               (1 << 15) /* attached to rfapi HD */\n#define PEER_FLAG_ENFORCE_FIRST_AS          (1 << 16) /* enforce-first-as */\n#define PEER_FLAG_ROUTEADV                  (1 << 17) /* route advertise */\n#define PEER_FLAG_TIMER                     (1 << 18) /* keepalive & holdtime */\n#define PEER_FLAG_TIMER_CONNECT             (1 << 19) /* connect timer */\n#define PEER_FLAG_PASSWORD                  (1 << 20) /* password */\n#define PEER_FLAG_LOCAL_AS                  (1 << 21) /* local-as */\n#define PEER_FLAG_UPDATE_SOURCE             (1 << 22) /* update-source */\n\n\t/* outgoing message sent in CEASE_ADMIN_SHUTDOWN notify */\n\tchar *tx_shutdown_message;\n\n\t/* NSF mode (graceful restart) */\n\tuint8_t nsf[AFI_MAX][SAFI_MAX];\n\n\t/* Peer Per AF flags */\n\t/*\n\t * Please consult the comments for *flags_override*, *flags_invert* and\n\t * *flags* to understand what these three arrays do. The address-family\n\t * specific attributes are being treated the exact same way as global\n\t * peer attributes.\n\t */\n\tuint32_t af_flags_override[AFI_MAX][SAFI_MAX];\n\tuint32_t af_flags_invert[AFI_MAX][SAFI_MAX];\n\tuint32_t af_flags[AFI_MAX][SAFI_MAX];\n#define PEER_FLAG_SEND_COMMUNITY            (1 << 0) /* send-community */\n#define PEER_FLAG_SEND_EXT_COMMUNITY        (1 << 1) /* send-community ext. */\n#define PEER_FLAG_NEXTHOP_SELF              (1 << 2) /* next-hop-self */\n#define PEER_FLAG_REFLECTOR_CLIENT          (1 << 3) /* reflector-client */\n#define PEER_FLAG_RSERVER_CLIENT            (1 << 4) /* route-server-client */\n#define PEER_FLAG_SOFT_RECONFIG             (1 << 5) /* soft-reconfiguration */\n#define PEER_FLAG_AS_PATH_UNCHANGED         (1 << 6) /* transparent-as */\n#define PEER_FLAG_NEXTHOP_UNCHANGED         (1 << 7) /* transparent-next-hop */\n#define PEER_FLAG_MED_UNCHANGED             (1 << 8) /* transparent-next-hop */\n#define PEER_FLAG_DEFAULT_ORIGINATE         (1 << 9) /* default-originate */\n#define PEER_FLAG_REMOVE_PRIVATE_AS         (1 << 10) /* remove-private-as */\n#define PEER_FLAG_ALLOWAS_IN                (1 << 11) /* set allowas-in */\n#define PEER_FLAG_ORF_PREFIX_SM             (1 << 12) /* orf capability send-mode */\n#define PEER_FLAG_ORF_PREFIX_RM             (1 << 13) /* orf capability receive-mode */\n#define PEER_FLAG_MAX_PREFIX                (1 << 14) /* maximum prefix */\n#define PEER_FLAG_MAX_PREFIX_WARNING        (1 << 15) /* maximum prefix warning-only */\n#define PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED   (1 << 16) /* leave link-local nexthop unchanged */\n#define PEER_FLAG_FORCE_NEXTHOP_SELF        (1 << 17) /* next-hop-self force */\n#define PEER_FLAG_REMOVE_PRIVATE_AS_ALL     (1 << 18) /* remove-private-as all */\n#define PEER_FLAG_REMOVE_PRIVATE_AS_REPLACE (1 << 19) /* remove-private-as replace-as */\n#define PEER_FLAG_AS_OVERRIDE               (1 << 20) /* as-override */\n#define PEER_FLAG_REMOVE_PRIVATE_AS_ALL_REPLACE (1 << 21) /* remove-private-as all replace-as */\n#define PEER_FLAG_WEIGHT                    (1 << 24) /* weight */\n#define PEER_FLAG_ALLOWAS_IN_ORIGIN         (1 << 25) /* allowas-in origin */\n#define PEER_FLAG_SEND_LARGE_COMMUNITY      (1 << 26) /* Send large Communities */\n\n\tenum bgp_addpath_strat addpath_type[AFI_MAX][SAFI_MAX];\n\n\t/* MD5 password */\n\tchar *password;\n\n\t/* default-originate route-map.  */\n\tstruct {\n\t\tchar *name;\n\t\tstruct route_map *map;\n\t} default_rmap[AFI_MAX][SAFI_MAX];\n\n\t/* Peer status flags. */\n\tuint16_t sflags;\n#define PEER_STATUS_ACCEPT_PEER\t      (1 << 0) /* accept peer */\n#define PEER_STATUS_PREFIX_OVERFLOW   (1 << 1) /* prefix-overflow */\n#define PEER_STATUS_CAPABILITY_OPEN   (1 << 2) /* capability open send */\n#define PEER_STATUS_HAVE_ACCEPT       (1 << 3) /* accept peer's parent */\n#define PEER_STATUS_GROUP             (1 << 4) /* peer-group conf */\n#define PEER_STATUS_NSF_MODE          (1 << 5) /* NSF aware peer */\n#define PEER_STATUS_NSF_WAIT          (1 << 6) /* wait comeback peer */\n\n\t/* Peer status af flags (reset in bgp_stop) */\n\tuint16_t af_sflags[AFI_MAX][SAFI_MAX];\n#define PEER_STATUS_ORF_PREFIX_SEND   (1 << 0) /* prefix-list send peer */\n#define PEER_STATUS_ORF_WAIT_REFRESH  (1 << 1) /* wait refresh received peer */\n#define PEER_STATUS_PREFIX_THRESHOLD  (1 << 2) /* exceed prefix-threshold */\n#define PEER_STATUS_PREFIX_LIMIT      (1 << 3) /* exceed prefix-limit */\n#define PEER_STATUS_EOR_SEND          (1 << 4) /* end-of-rib send to peer */\n#define PEER_STATUS_EOR_RECEIVED      (1 << 5) /* end-of-rib received from peer */\n\n\t/* Configured timer values. */\n\t_Atomic uint32_t holdtime;\n\t_Atomic uint32_t keepalive;\n\t_Atomic uint32_t connect;\n\t_Atomic uint32_t routeadv;\n\n\t/* Timer values. */\n\t_Atomic uint32_t v_start;\n\t_Atomic uint32_t v_connect;\n\t_Atomic uint32_t v_holdtime;\n\t_Atomic uint32_t v_keepalive;\n\t_Atomic uint32_t v_routeadv;\n\t_Atomic uint32_t v_pmax_restart;\n\t_Atomic uint32_t v_gr_restart;\n\n\t/* Threads. */\n\tstruct thread *t_read;\n\tstruct thread *t_write;\n\tstruct thread *t_start;\n\tstruct thread *t_connect_check_r;\n\tstruct thread *t_connect_check_w;\n\tstruct thread *t_connect;\n\tstruct thread *t_holdtime;\n\tstruct thread *t_routeadv;\n\tstruct thread *t_pmax_restart;\n\tstruct thread *t_gr_restart;\n\tstruct thread *t_gr_stale;\n\tstruct thread *t_generate_updgrp_packets;\n\tstruct thread *t_process_packet;\n\n\t/* Thread flags. */\n\t_Atomic uint32_t thread_flags;\n#define PEER_THREAD_WRITES_ON         (1 << 0)\n#define PEER_THREAD_READS_ON          (1 << 1)\n#define PEER_THREAD_KEEPALIVES_ON     (1 << 2)\n\t/* workqueues */\n\tstruct work_queue *clear_node_queue;\n\n#define PEER_TOTAL_RX(peer)                                                    \\\n\tatomic_load_explicit(&peer->open_in, memory_order_relaxed)             \\\n\t\t+ atomic_load_explicit(&peer->update_in, memory_order_relaxed) \\\n\t\t+ atomic_load_explicit(&peer->notify_in, memory_order_relaxed) \\\n\t\t+ atomic_load_explicit(&peer->refresh_in,                      \\\n\t\t\t\t       memory_order_relaxed)                   \\\n\t\t+ atomic_load_explicit(&peer->keepalive_in,                    \\\n\t\t\t\t       memory_order_relaxed)                   \\\n\t\t+ atomic_load_explicit(&peer->dynamic_cap_in,                  \\\n\t\t\t\t       memory_order_relaxed)\n\n#define PEER_TOTAL_TX(peer)                                                    \\\n\tatomic_load_explicit(&peer->open_out, memory_order_relaxed)            \\\n\t\t+ atomic_load_explicit(&peer->update_out,                      \\\n\t\t\t\t       memory_order_relaxed)                   \\\n\t\t+ atomic_load_explicit(&peer->notify_out,                      \\\n\t\t\t\t       memory_order_relaxed)                   \\\n\t\t+ atomic_load_explicit(&peer->refresh_out,                     \\\n\t\t\t\t       memory_order_relaxed)                   \\\n\t\t+ atomic_load_explicit(&peer->keepalive_out,                   \\\n\t\t\t\t       memory_order_relaxed)                   \\\n\t\t+ atomic_load_explicit(&peer->dynamic_cap_out,                 \\\n\t\t\t\t       memory_order_relaxed)\n\n\t/* Statistics field */\n\t_Atomic uint32_t open_in;\t /* Open message input count */\n\t_Atomic uint32_t open_out;\t/* Open message output count */\n\t_Atomic uint32_t update_in;       /* Update message input count */\n\t_Atomic uint32_t update_out;      /* Update message ouput count */\n\t_Atomic time_t update_time;       /* Update message received time. */\n\t_Atomic uint32_t keepalive_in;    /* Keepalive input count */\n\t_Atomic uint32_t keepalive_out;   /* Keepalive output count */\n\t_Atomic uint32_t notify_in;       /* Notify input count */\n\t_Atomic uint32_t notify_out;      /* Notify output count */\n\t_Atomic uint32_t refresh_in;      /* Route Refresh input count */\n\t_Atomic uint32_t refresh_out;     /* Route Refresh output count */\n\t_Atomic uint32_t dynamic_cap_in;  /* Dynamic Capability input count.  */\n\t_Atomic uint32_t dynamic_cap_out; /* Dynamic Capability output count. */\n\n\t/* BGP state count */\n\tuint32_t established; /* Established */\n\tuint32_t dropped;     /* Dropped */\n\n\t/* Update delay related fields */\n\tuint8_t update_delay_over; /* When this is set, BGP is no more waiting\n\t\t\t\t     for EOR */\n\n\t/* Syncronization list and time.  */\n\tstruct bgp_synchronize *sync[AFI_MAX][SAFI_MAX];\n\ttime_t synctime;\n\t/* timestamp when the last UPDATE msg was written */\n\t_Atomic time_t last_write;\n\t/* timestamp when the last msg was written */\n\t_Atomic time_t last_update;\n\n\t/* Send prefix count. */\n\tunsigned long scount[AFI_MAX][SAFI_MAX];\n\n\t/* Notify data. */\n\tstruct bgp_notify notify;\n\n\t/* Filter structure. */\n\tstruct bgp_filter filter[AFI_MAX][SAFI_MAX];\n\n\t/*\n\t * Parallel array to filter that indicates whether each filter\n\t * originates from a peer-group or if it is config that is specific to\n\t * this individual peer. If a filter is set independent of the\n\t * peer-group the appropriate bit should be set here. If this peer is a\n\t * peer-group, this memory region should be all zeros. The assumption\n\t * is that the default state for all flags is unset. Due to filters\n\t * having a direction (e.g. in/out/...), this array has a third\n\t * dimension for storing the overrides independently per direction.\n\t *\n\t * Notes:\n\t * - if a filter for an individual peer is unset, the corresponding\n\t *   override flag is unset and the peer is considered to be back in\n\t *   sync with the peer-group.\n\t * - This does *not* contain the filter values, rather it contains\n\t *   whether the filter in filter (struct bgp_filter) is peer-specific.\n\t */\n\tuint8_t filter_override[AFI_MAX][SAFI_MAX][(FILTER_MAX > RMAP_MAX)\n\t\t\t\t\t\t\t   ? FILTER_MAX\n\t\t\t\t\t\t\t   : RMAP_MAX];\n#define PEER_FT_DISTRIBUTE_LIST       (1 << 0) /* distribute-list */\n#define PEER_FT_FILTER_LIST           (1 << 1) /* filter-list */\n#define PEER_FT_PREFIX_LIST           (1 << 2) /* prefix-list */\n#define PEER_FT_ROUTE_MAP             (1 << 3) /* route-map */\n#define PEER_FT_UNSUPPRESS_MAP        (1 << 4) /* unsuppress-map */\n\n\t/* ORF Prefix-list */\n\tstruct prefix_list *orf_plist[AFI_MAX][SAFI_MAX];\n\n\t/* Text description of last attribute rcvd */\n\tchar rcvd_attr_str[BUFSIZ];\n\n\t/* Track if we printed the attribute in debugs */\n\tint rcvd_attr_printed;\n\n\t/* Prefix count. */\n\tunsigned long pcount[AFI_MAX][SAFI_MAX];\n\n\t/* Max prefix count. */\n\tunsigned long pmax[AFI_MAX][SAFI_MAX];\n\tuint8_t pmax_threshold[AFI_MAX][SAFI_MAX];\n\tuint16_t pmax_restart[AFI_MAX][SAFI_MAX];\n#define MAXIMUM_PREFIX_THRESHOLD_DEFAULT 75\n\n\t/* allowas-in. */\n\tchar allowas_in[AFI_MAX][SAFI_MAX];\n\n\t/* weight */\n\tunsigned long weight[AFI_MAX][SAFI_MAX];\n\n\t/* peer reset cause */\n\tchar last_reset;\n#define PEER_DOWN_RID_CHANGE             1 /* bgp router-id command */\n#define PEER_DOWN_REMOTE_AS_CHANGE       2 /* neighbor remote-as command */\n#define PEER_DOWN_LOCAL_AS_CHANGE        3 /* neighbor local-as command */\n#define PEER_DOWN_CLID_CHANGE            4 /* bgp cluster-id command */\n#define PEER_DOWN_CONFED_ID_CHANGE       5 /* bgp confederation identifier command */\n#define PEER_DOWN_CONFED_PEER_CHANGE     6 /* bgp confederation peer command */\n#define PEER_DOWN_RR_CLIENT_CHANGE       7 /* neighbor route-reflector-client command */\n#define PEER_DOWN_RS_CLIENT_CHANGE       8 /* neighbor route-server-client command */\n#define PEER_DOWN_UPDATE_SOURCE_CHANGE   9 /* neighbor update-source command */\n#define PEER_DOWN_AF_ACTIVATE           10 /* neighbor activate command */\n#define PEER_DOWN_USER_SHUTDOWN         11 /* neighbor shutdown command */\n#define PEER_DOWN_USER_RESET            12 /* clear ip bgp command */\n#define PEER_DOWN_NOTIFY_RECEIVED       13 /* notification received */\n#define PEER_DOWN_NOTIFY_SEND           14 /* notification send */\n#define PEER_DOWN_CLOSE_SESSION         15 /* tcp session close */\n#define PEER_DOWN_NEIGHBOR_DELETE       16 /* neghbor delete */\n#define PEER_DOWN_RMAP_BIND             17 /* neghbor peer-group command */\n#define PEER_DOWN_RMAP_UNBIND           18 /* no neighbor peer-group command */\n#define PEER_DOWN_CAPABILITY_CHANGE     19 /* neighbor capability command */\n#define PEER_DOWN_PASSIVE_CHANGE        20 /* neighbor passive command */\n#define PEER_DOWN_MULTIHOP_CHANGE       21 /* neighbor multihop command */\n#define PEER_DOWN_NSF_CLOSE_SESSION     22 /* NSF tcp session close */\n#define PEER_DOWN_V6ONLY_CHANGE         23 /* if-based peering v6only toggled */\n#define PEER_DOWN_BFD_DOWN              24 /* BFD down */\n#define PEER_DOWN_IF_DOWN               25 /* Interface down */\n#define PEER_DOWN_NBR_ADDR_DEL          26 /* Peer address lost */\n\tunsigned long last_reset_cause_size;\n\tuint8_t last_reset_cause[BGP_MAX_PACKET_SIZE];\n\n\t/* The kind of route-map Flags.*/\n\tuint8_t rmap_type;\n#define PEER_RMAP_TYPE_IN             (1 << 0) /* neighbor route-map in */\n#define PEER_RMAP_TYPE_OUT            (1 << 1) /* neighbor route-map out */\n#define PEER_RMAP_TYPE_NETWORK        (1 << 2) /* network route-map */\n#define PEER_RMAP_TYPE_REDISTRIBUTE   (1 << 3) /* redistribute route-map */\n#define PEER_RMAP_TYPE_DEFAULT        (1 << 4) /* default-originate route-map */\n#define PEER_RMAP_TYPE_NOSET          (1 << 5) /* not allow to set commands */\n#define PEER_RMAP_TYPE_IMPORT         (1 << 6) /* neighbor route-map import */\n#define PEER_RMAP_TYPE_EXPORT         (1 << 7) /* neighbor route-map export */\n\n\t/* peer specific BFD information */\n\tstruct bfd_info *bfd_info;\n\n\t/* hostname and domainname advertised by host */\n\tchar *hostname;\n\tchar *domainname;\n\n\tQOBJ_FIELDS\n};\nDECLARE_QOBJ_TYPE(peer)\n\n/* Inherit peer attribute from peer-group. */\n#define PEER_ATTR_INHERIT(peer, group, attr)                                   \\\n\t((peer)->attr = (group)->conf->attr)\n#define PEER_STR_ATTR_INHERIT(peer, group, attr, mt)                           \\\n\tdo {                                                                   \\\n\t\tif ((peer)->attr)                                              \\\n\t\t\tXFREE(mt, (peer)->attr);                               \\\n\t\tif ((group)->conf->attr)                                       \\\n\t\t\t(peer)->attr = XSTRDUP(mt, (group)->conf->attr);       \\\n\t\telse                                                           \\\n\t\t\t(peer)->attr = NULL;                                   \\\n\t} while (0)\n#define PEER_SU_ATTR_INHERIT(peer, group, attr)                                \\\n\tdo {                                                                   \\\n\t\tif ((peer)->attr)                                              \\\n\t\t\tsockunion_free((peer)->attr);                          \\\n\t\tif ((group)->conf->attr)                                       \\\n\t\t\t(peer)->attr = sockunion_dup((group)->conf->attr);     \\\n\t\telse                                                           \\\n\t\t\t(peer)->attr = NULL;                                   \\\n\t} while (0)\n\n/* Check if suppress start/restart of sessions to peer. */\n#define BGP_PEER_START_SUPPRESSED(P)                                           \\\n\t(CHECK_FLAG((P)->flags, PEER_FLAG_SHUTDOWN)                            \\\n\t || CHECK_FLAG((P)->sflags, PEER_STATUS_PREFIX_OVERFLOW))\n\n#define PEER_PASSWORD_MINLEN\t(1)\n#define PEER_PASSWORD_MAXLEN\t(80)\n\n/* This structure's member directly points incoming packet data\n   stream. */\nstruct bgp_nlri {\n\t/* AFI.  */\n\tuint16_t afi; /* iana_afi_t */\n\n\t/* SAFI.  */\n\tuint8_t safi; /* iana_safi_t */\n\n\t/* Pointer to NLRI byte stream.  */\n\tuint8_t *nlri;\n\n\t/* Length of whole NLRI.  */\n\tbgp_size_t length;\n};\n\n/* BGP versions.  */\n#define BGP_VERSION_4\t\t                 4\n\n/* Default BGP port number.  */\n#define BGP_PORT_DEFAULT                       179\n\n/* BGP minimum message size.  */\n#define BGP_MSG_OPEN_MIN_SIZE                   (BGP_HEADER_SIZE + 10)\n#define BGP_MSG_UPDATE_MIN_SIZE                 (BGP_HEADER_SIZE + 4)\n#define BGP_MSG_NOTIFY_MIN_SIZE                 (BGP_HEADER_SIZE + 2)\n#define BGP_MSG_KEEPALIVE_MIN_SIZE              (BGP_HEADER_SIZE + 0)\n#define BGP_MSG_ROUTE_REFRESH_MIN_SIZE          (BGP_HEADER_SIZE + 4)\n#define BGP_MSG_CAPABILITY_MIN_SIZE             (BGP_HEADER_SIZE + 3)\n\n/* BGP message types.  */\n#define\tBGP_MSG_OPEN\t\t                 1\n#define\tBGP_MSG_UPDATE\t\t                 2\n#define\tBGP_MSG_NOTIFY\t\t                 3\n#define\tBGP_MSG_KEEPALIVE\t                 4\n#define BGP_MSG_ROUTE_REFRESH_NEW                5\n#define BGP_MSG_CAPABILITY                       6\n#define BGP_MSG_ROUTE_REFRESH_OLD              128\n\n/* BGP open optional parameter.  */\n#define BGP_OPEN_OPT_AUTH                        1\n#define BGP_OPEN_OPT_CAP                         2\n\n/* BGP4 attribute type codes.  */\n#define BGP_ATTR_ORIGIN                          1\n#define BGP_ATTR_AS_PATH                         2\n#define BGP_ATTR_NEXT_HOP                        3\n#define BGP_ATTR_MULTI_EXIT_DISC                 4\n#define BGP_ATTR_LOCAL_PREF                      5\n#define BGP_ATTR_ATOMIC_AGGREGATE                6\n#define BGP_ATTR_AGGREGATOR                      7\n#define BGP_ATTR_COMMUNITIES                     8\n#define BGP_ATTR_ORIGINATOR_ID                   9\n#define BGP_ATTR_CLUSTER_LIST                   10\n#define BGP_ATTR_DPA                            11\n#define BGP_ATTR_ADVERTISER                     12\n#define BGP_ATTR_RCID_PATH                      13\n#define BGP_ATTR_MP_REACH_NLRI                  14\n#define BGP_ATTR_MP_UNREACH_NLRI                15\n#define BGP_ATTR_EXT_COMMUNITIES                16\n#define BGP_ATTR_AS4_PATH                       17\n#define BGP_ATTR_AS4_AGGREGATOR                 18\n#define BGP_ATTR_AS_PATHLIMIT                   21\n#define BGP_ATTR_PMSI_TUNNEL                    22\n#define BGP_ATTR_ENCAP                          23\n#define BGP_ATTR_LARGE_COMMUNITIES              32\n#define BGP_ATTR_PREFIX_SID                     40\n#if ENABLE_BGP_VNC\n#define BGP_ATTR_VNC                           255\n#endif\n\n/* BGP update origin.  */\n#define BGP_ORIGIN_IGP                           0\n#define BGP_ORIGIN_EGP                           1\n#define BGP_ORIGIN_INCOMPLETE                    2\n\n/* BGP notify message codes.  */\n#define BGP_NOTIFY_HEADER_ERR                    1\n#define BGP_NOTIFY_OPEN_ERR                      2\n#define BGP_NOTIFY_UPDATE_ERR                    3\n#define BGP_NOTIFY_HOLD_ERR                      4\n#define BGP_NOTIFY_FSM_ERR                       5\n#define BGP_NOTIFY_CEASE                         6\n#define BGP_NOTIFY_CAPABILITY_ERR                7\n\n#define BGP_NOTIFY_SUBCODE_UNSPECIFIC            0\n\n/* BGP_NOTIFY_HEADER_ERR sub codes.  */\n#define BGP_NOTIFY_HEADER_NOT_SYNC               1\n#define BGP_NOTIFY_HEADER_BAD_MESLEN             2\n#define BGP_NOTIFY_HEADER_BAD_MESTYPE            3\n\n/* BGP_NOTIFY_OPEN_ERR sub codes.  */\n#define BGP_NOTIFY_OPEN_MALFORMED_ATTR           0\n#define BGP_NOTIFY_OPEN_UNSUP_VERSION            1\n#define BGP_NOTIFY_OPEN_BAD_PEER_AS              2\n#define BGP_NOTIFY_OPEN_BAD_BGP_IDENT            3\n#define BGP_NOTIFY_OPEN_UNSUP_PARAM              4\n#define BGP_NOTIFY_OPEN_AUTH_FAILURE             5\n#define BGP_NOTIFY_OPEN_UNACEP_HOLDTIME          6\n#define BGP_NOTIFY_OPEN_UNSUP_CAPBL              7\n\n/* BGP_NOTIFY_UPDATE_ERR sub codes.  */\n#define BGP_NOTIFY_UPDATE_MAL_ATTR               1\n#define BGP_NOTIFY_UPDATE_UNREC_ATTR             2\n#define BGP_NOTIFY_UPDATE_MISS_ATTR              3\n#define BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR          4\n#define BGP_NOTIFY_UPDATE_ATTR_LENG_ERR          5\n#define BGP_NOTIFY_UPDATE_INVAL_ORIGIN           6\n#define BGP_NOTIFY_UPDATE_AS_ROUTE_LOOP          7\n#define BGP_NOTIFY_UPDATE_INVAL_NEXT_HOP         8\n#define BGP_NOTIFY_UPDATE_OPT_ATTR_ERR           9\n#define BGP_NOTIFY_UPDATE_INVAL_NETWORK         10\n#define BGP_NOTIFY_UPDATE_MAL_AS_PATH           11\n\n/* BGP_NOTIFY_CEASE sub codes (RFC 4486).  */\n#define BGP_NOTIFY_CEASE_MAX_PREFIX              1\n#define BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN          2\n#define BGP_NOTIFY_CEASE_PEER_UNCONFIG           3\n#define BGP_NOTIFY_CEASE_ADMIN_RESET             4\n#define BGP_NOTIFY_CEASE_CONNECT_REJECT          5\n#define BGP_NOTIFY_CEASE_CONFIG_CHANGE           6\n#define BGP_NOTIFY_CEASE_COLLISION_RESOLUTION    7\n#define BGP_NOTIFY_CEASE_OUT_OF_RESOURCE         8\n\n/* BGP_NOTIFY_CAPABILITY_ERR sub codes (draft-ietf-idr-dynamic-cap-02). */\n#define BGP_NOTIFY_CAPABILITY_INVALID_ACTION     1\n#define BGP_NOTIFY_CAPABILITY_INVALID_LENGTH     2\n#define BGP_NOTIFY_CAPABILITY_MALFORMED_CODE     3\n\n/* BGP finite state machine status.  */\n#define Idle                                     1\n#define Connect                                  2\n#define Active                                   3\n#define OpenSent                                 4\n#define OpenConfirm                              5\n#define Established                              6\n#define Clearing                                 7\n#define Deleted                                  8\n#define BGP_STATUS_MAX                           9\n\n/* BGP finite state machine events.  */\n#define BGP_Start                                1\n#define BGP_Stop                                 2\n#define TCP_connection_open                      3\n#define TCP_connection_closed                    4\n#define TCP_connection_open_failed               5\n#define TCP_fatal_error                          6\n#define ConnectRetry_timer_expired               7\n#define Hold_Timer_expired                       8\n#define KeepAlive_timer_expired                  9\n#define Receive_OPEN_message                    10\n#define Receive_KEEPALIVE_message               11\n#define Receive_UPDATE_message                  12\n#define Receive_NOTIFICATION_message            13\n#define Clearing_Completed                      14\n#define BGP_EVENTS_MAX                          15\n\n/* BGP timers default value.  */\n/* note: the DFLT_ ones depend on compile-time \"defaults\" selection */\n#define BGP_INIT_START_TIMER                     1\n#define BGP_DEFAULT_HOLDTIME                      DFLT_BGP_HOLDTIME\n#define BGP_DEFAULT_KEEPALIVE                     DFLT_BGP_KEEPALIVE\n#define BGP_DEFAULT_EBGP_ROUTEADV                0\n#define BGP_DEFAULT_IBGP_ROUTEADV                0\n#define BGP_DEFAULT_CONNECT_RETRY                 DFLT_BGP_TIMERS_CONNECT\n\n/* BGP default local preference.  */\n#define BGP_DEFAULT_LOCAL_PREF                 100\n\n/* BGP local-preference to send when 'bgp graceful-shutdown'\n * is configured */\n#define BGP_GSHUT_LOCAL_PREF                     0\n\n/* BGP default subgroup packet queue max .  */\n#define BGP_DEFAULT_SUBGROUP_PKT_QUEUE_MAX      40\n\n/* BGP graceful restart  */\n#define BGP_DEFAULT_RESTART_TIME               120\n#define BGP_DEFAULT_STALEPATH_TIME             360\n\n/* BGP uptime string length.  */\n#define BGP_UPTIME_LEN 25\n\n/* Default configuration settings for bgpd.  */\n#define BGP_VTY_PORT                          2605\n#define BGP_DEFAULT_CONFIG             \"bgpd.conf\"\n\n/* Check AS path loop when we send NLRI.  */\n/* #define BGP_SEND_ASPATH_CHECK */\n\n/* BGP Dynamic Neighbors feature */\n#define BGP_DYNAMIC_NEIGHBORS_LIMIT_DEFAULT    100\n#define BGP_DYNAMIC_NEIGHBORS_LIMIT_MIN          1\n#define BGP_DYNAMIC_NEIGHBORS_LIMIT_MAX       5000\n\n/* Flag for peer_clear_soft().  */\nenum bgp_clear_type {\n\tBGP_CLEAR_SOFT_NONE,\n\tBGP_CLEAR_SOFT_OUT,\n\tBGP_CLEAR_SOFT_IN,\n\tBGP_CLEAR_SOFT_BOTH,\n\tBGP_CLEAR_SOFT_IN_ORF_PREFIX\n};\n\n/* Macros. */\n#define BGP_INPUT(P)         ((P)->curr)\n#define BGP_INPUT_PNT(P)     (stream_pnt(BGP_INPUT(P)))\n#define BGP_IS_VALID_STATE_FOR_NOTIF(S)                                        \\\n\t(((S) == OpenSent) || ((S) == OpenConfirm) || ((S) == Established))\n\n/* BGP error codes.  */\n#define BGP_SUCCESS                               0\n#define BGP_ERR_INVALID_VALUE                    -1\n#define BGP_ERR_INVALID_FLAG                     -2\n#define BGP_ERR_INVALID_AS                       -3\n#define BGP_ERR_INVALID_BGP                      -4\n#define BGP_ERR_PEER_GROUP_MEMBER                -5\n#define BGP_ERR_MULTIPLE_INSTANCE_USED           -6\n#define BGP_ERR_PEER_GROUP_NO_REMOTE_AS          -7\n#define BGP_ERR_PEER_GROUP_CANT_CHANGE           -8\n#define BGP_ERR_PEER_GROUP_MISMATCH              -9\n#define BGP_ERR_PEER_GROUP_PEER_TYPE_DIFFERENT  -10\n#define BGP_ERR_MULTIPLE_INSTANCE_NOT_SET       -11\n#define BGP_ERR_AS_MISMATCH                     -12\n#define BGP_ERR_PEER_FLAG_CONFLICT              -13\n#define BGP_ERR_PEER_GROUP_SHUTDOWN             -14\n#define BGP_ERR_PEER_FILTER_CONFLICT            -15\n#define BGP_ERR_NOT_INTERNAL_PEER               -16\n#define BGP_ERR_REMOVE_PRIVATE_AS               -17\n#define BGP_ERR_AF_UNCONFIGURED                 -18\n#define BGP_ERR_SOFT_RECONFIG_UNCONFIGURED      -19\n#define BGP_ERR_INSTANCE_MISMATCH               -20\n#define BGP_ERR_LOCAL_AS_ALLOWED_ONLY_FOR_EBGP  -21\n#define BGP_ERR_CANNOT_HAVE_LOCAL_AS_SAME_AS    -22\n#define BGP_ERR_TCPSIG_FAILED\t\t\t-23\n#define BGP_ERR_NO_EBGP_MULTIHOP_WITH_TTLHACK\t-24\n#define BGP_ERR_NO_IBGP_WITH_TTLHACK\t\t-25\n#define BGP_ERR_NO_INTERFACE_CONFIG             -26\n#define BGP_ERR_CANNOT_HAVE_LOCAL_AS_SAME_AS_REMOTE_AS    -27\n#define BGP_ERR_AS_OVERRIDE                     -28\n#define BGP_ERR_INVALID_DYNAMIC_NEIGHBORS_LIMIT -29\n#define BGP_ERR_DYNAMIC_NEIGHBORS_RANGE_EXISTS  -30\n#define BGP_ERR_DYNAMIC_NEIGHBORS_RANGE_NOT_FOUND -31\n#define BGP_ERR_INVALID_FOR_DYNAMIC_PEER        -32\n#define BGP_ERR_MAX                             -33\n#define BGP_ERR_INVALID_FOR_DIRECT_PEER         -34\n#define BGP_ERR_PEER_SAFI_CONFLICT              -35\n\n/*\n * Enumeration of different policy kinds a peer can be configured with.\n */\ntypedef enum {\n\tBGP_POLICY_ROUTE_MAP,\n\tBGP_POLICY_FILTER_LIST,\n\tBGP_POLICY_PREFIX_LIST,\n\tBGP_POLICY_DISTRIBUTE_LIST,\n} bgp_policy_type_e;\n\n/* peer_flag_change_type. */\nenum peer_change_type {\n\tpeer_change_none,\n\tpeer_change_reset,\n\tpeer_change_reset_in,\n\tpeer_change_reset_out,\n};\n\nextern struct bgp_master *bm;\nextern unsigned int multipath_num;\n\n/* Prototypes. */\nextern void bgp_terminate(void);\nextern void bgp_reset(void);\nextern time_t bgp_clock(void);\nextern void bgp_zclient_reset(void);\nextern struct bgp *bgp_get_default(void);\nextern struct bgp *bgp_lookup(as_t, const char *);\nextern struct bgp *bgp_lookup_by_name(const char *);\nextern struct bgp *bgp_lookup_by_vrf_id(vrf_id_t);\nextern struct peer *peer_lookup(struct bgp *, union sockunion *);\nextern struct peer *peer_lookup_by_conf_if(struct bgp *, const char *);\nextern struct peer *peer_lookup_by_hostname(struct bgp *, const char *);\nextern void bgp_peer_conf_if_to_su_update(struct peer *);\nextern int peer_group_listen_range_del(struct peer_group *, struct prefix *);\nextern struct peer_group *peer_group_lookup(struct bgp *, const char *);\nextern struct peer_group *peer_group_get(struct bgp *, const char *);\nextern struct peer *peer_create_bind_dynamic_neighbor(struct bgp *,\n\t\t\t\t\t\t      union sockunion *,\n\t\t\t\t\t\t      struct peer_group *);\nextern struct prefix *\npeer_group_lookup_dynamic_neighbor_range(struct peer_group *, struct prefix *);\nextern struct peer_group *peer_group_lookup_dynamic_neighbor(struct bgp *,\n\t\t\t\t\t\t\t     struct prefix *,\n\t\t\t\t\t\t\t     struct prefix **);\nextern struct peer *peer_lookup_dynamic_neighbor(struct bgp *,\n\t\t\t\t\t\t union sockunion *);\n\n/*\n * Peers are incredibly easy to memory leak\n * due to the various ways that they are actually used\n * Provide some functionality to debug locks and unlocks\n */\nextern struct peer *peer_lock_with_caller(const char *, struct peer *);\nextern struct peer *peer_unlock_with_caller(const char *, struct peer *);\n#define peer_unlock(A) peer_unlock_with_caller(__FUNCTION__, (A))\n#define peer_lock(B) peer_lock_with_caller(__FUNCTION__, (B))\n\nextern bgp_peer_sort_t peer_sort(struct peer *peer);\nextern int peer_active(struct peer *);\nextern int peer_active_nego(struct peer *);\nextern void bgp_recalculate_all_bestpaths(struct bgp *bgp);\nextern struct peer *peer_create(union sockunion *, const char *, struct bgp *,\n\t\t\t\tas_t, as_t, int, afi_t, safi_t,\n\t\t\t\tstruct peer_group *);\nextern struct peer *peer_create_accept(struct bgp *);\nextern void peer_xfer_config(struct peer *dst, struct peer *src);\nextern char *peer_uptime(time_t uptime2, char *buf, size_t len, bool use_json,\n\t\t\t json_object *json);\n\nextern int bgp_config_write(struct vty *);\n\nextern void bgp_master_init(struct thread_master *master);\n\nextern void bgp_init(unsigned short instance);\nextern void bgp_pthreads_run(void);\nextern void bgp_pthreads_finish(void);\nextern void bgp_route_map_init(void);\nextern void bgp_session_reset(struct peer *);\n\nextern int bgp_option_set(int);\nextern int bgp_option_unset(int);\nextern int bgp_option_check(int);\n\nextern int bgp_get(struct bgp **, as_t *, const char *, enum bgp_instance_type);\nextern void bgp_instance_up(struct bgp *);\nextern void bgp_instance_down(struct bgp *);\nextern int bgp_delete(struct bgp *);\n\nextern int bgp_handle_socket(struct bgp *bgp, struct vrf *vrf,\n\t\t\t     vrf_id_t old_vrf_id, bool create);\n\nextern int bgp_flag_set(struct bgp *, int);\nextern int bgp_flag_unset(struct bgp *, int);\nextern int bgp_flag_check(struct bgp *, int);\n\nextern void bgp_router_id_zebra_bump(vrf_id_t, const struct prefix *);\nextern int bgp_router_id_static_set(struct bgp *, struct in_addr);\n\nextern int bgp_cluster_id_set(struct bgp *, struct in_addr *);\nextern int bgp_cluster_id_unset(struct bgp *);\n\nextern int bgp_confederation_id_set(struct bgp *, as_t);\nextern int bgp_confederation_id_unset(struct bgp *);\nextern int bgp_confederation_peers_check(struct bgp *, as_t);\n\nextern int bgp_confederation_peers_add(struct bgp *, as_t);\nextern int bgp_confederation_peers_remove(struct bgp *, as_t);\n\nextern int bgp_timers_set(struct bgp *, uint32_t keepalive, uint32_t holdtime);\nextern int bgp_timers_unset(struct bgp *);\n\nextern int bgp_default_local_preference_set(struct bgp *, uint32_t);\nextern int bgp_default_local_preference_unset(struct bgp *);\n\nextern int bgp_default_subgroup_pkt_queue_max_set(struct bgp *bgp, uint32_t);\nextern int bgp_default_subgroup_pkt_queue_max_unset(struct bgp *bgp);\n\nextern int bgp_listen_limit_set(struct bgp *, int);\nextern int bgp_listen_limit_unset(struct bgp *);\n\nextern int bgp_update_delay_active(struct bgp *);\nextern int bgp_update_delay_configured(struct bgp *);\nextern int bgp_afi_safi_peer_exists(struct bgp *bgp, afi_t afi, safi_t safi);\nextern void peer_as_change(struct peer *, as_t, int);\nextern int peer_remote_as(struct bgp *, union sockunion *, const char *, as_t *,\n\t\t\t  int, afi_t, safi_t);\nextern int peer_group_remote_as(struct bgp *, const char *, as_t *, int);\nextern int peer_delete(struct peer *peer);\nextern int peer_group_delete(struct peer_group *);\nextern int peer_group_remote_as_delete(struct peer_group *);\nextern int peer_group_listen_range_add(struct peer_group *, struct prefix *);\n\nextern int peer_activate(struct peer *, afi_t, safi_t);\nextern int peer_deactivate(struct peer *, afi_t, safi_t);\nextern int peer_afc_set(struct peer *, afi_t, safi_t, int);\n\nextern int peer_group_bind(struct bgp *, union sockunion *, struct peer *,\n\t\t\t   struct peer_group *, as_t *);\n\nextern int peer_flag_set(struct peer *, uint32_t);\nextern int peer_flag_unset(struct peer *, uint32_t);\nextern void peer_flag_inherit(struct peer *peer, uint32_t flag);\n\nextern int peer_af_flag_set(struct peer *, afi_t, safi_t, uint32_t);\nextern int peer_af_flag_unset(struct peer *, afi_t, safi_t, uint32_t);\nextern int peer_af_flag_check(struct peer *, afi_t, safi_t, uint32_t);\nextern void peer_af_flag_inherit(struct peer *peer, afi_t afi, safi_t safi,\n\t\t\t\t uint32_t flag);\nextern void peer_change_action(struct peer *peer, afi_t afi, safi_t safi,\n\t\t\t       enum peer_change_type type);\n\nextern int peer_ebgp_multihop_set(struct peer *, int);\nextern int peer_ebgp_multihop_unset(struct peer *);\nextern int is_ebgp_multihop_configured(struct peer *peer);\n\nextern int peer_description_set(struct peer *, const char *);\nextern int peer_description_unset(struct peer *);\n\nextern int peer_update_source_if_set(struct peer *, const char *);\nextern int peer_update_source_addr_set(struct peer *, const union sockunion *);\nextern int peer_update_source_unset(struct peer *);\n\nextern int peer_default_originate_set(struct peer *peer, afi_t afi, safi_t safi,\n\t\t\t\t      const char *rmap,\n\t\t\t\t      struct route_map *route_map);\nextern int peer_default_originate_unset(struct peer *, afi_t, safi_t);\n\nextern int peer_port_set(struct peer *, uint16_t);\nextern int peer_port_unset(struct peer *);\n\nextern int peer_weight_set(struct peer *, afi_t, safi_t, uint16_t);\nextern int peer_weight_unset(struct peer *, afi_t, safi_t);\n\nextern int peer_timers_set(struct peer *, uint32_t keepalive,\n\t\t\t   uint32_t holdtime);\nextern int peer_timers_unset(struct peer *);\n\nextern int peer_timers_connect_set(struct peer *, uint32_t);\nextern int peer_timers_connect_unset(struct peer *);\n\nextern int peer_advertise_interval_set(struct peer *, uint32_t);\nextern int peer_advertise_interval_unset(struct peer *);\n\nextern void peer_interface_set(struct peer *, const char *);\nextern void peer_interface_unset(struct peer *);\n\nextern int peer_distribute_set(struct peer *, afi_t, safi_t, int, const char *);\nextern int peer_distribute_unset(struct peer *, afi_t, safi_t, int);\n\nextern int peer_allowas_in_set(struct peer *, afi_t, safi_t, int, int);\nextern int peer_allowas_in_unset(struct peer *, afi_t, safi_t);\n\nextern int peer_local_as_set(struct peer *, as_t, int, int);\nextern int peer_local_as_unset(struct peer *);\n\nextern int peer_prefix_list_set(struct peer *, afi_t, safi_t, int,\n\t\t\t\tconst char *);\nextern int peer_prefix_list_unset(struct peer *, afi_t, safi_t, int);\n\nextern int peer_aslist_set(struct peer *, afi_t, safi_t, int, const char *);\nextern int peer_aslist_unset(struct peer *, afi_t, safi_t, int);\n\nextern int peer_route_map_set(struct peer *peer, afi_t afi, safi_t safi, int,\n\t\t\t      const char *name, struct route_map *route_map);\nextern int peer_route_map_unset(struct peer *, afi_t, safi_t, int);\n\nextern int peer_unsuppress_map_set(struct peer *peer, afi_t afi, safi_t safi,\n\t\t\t\t   const char *name,\n\t\t\t\t   struct route_map *route_map);\n\nextern int peer_password_set(struct peer *, const char *);\nextern int peer_password_unset(struct peer *);\n\nextern int peer_unsuppress_map_unset(struct peer *, afi_t, safi_t);\n\nextern int peer_maximum_prefix_set(struct peer *, afi_t, safi_t, uint32_t,\n\t\t\t\t   uint8_t, int, uint16_t);\nextern int peer_maximum_prefix_unset(struct peer *, afi_t, safi_t);\n\nextern int peer_clear(struct peer *, struct listnode **);\nextern int peer_clear_soft(struct peer *, afi_t, safi_t, enum bgp_clear_type);\n\nextern int peer_ttl_security_hops_set(struct peer *, int);\nextern int peer_ttl_security_hops_unset(struct peer *);\n\nextern int peer_tx_shutdown_message_set(struct peer *, const char *msg);\nextern int peer_tx_shutdown_message_unset(struct peer *);\n\nextern int bgp_route_map_update_timer(struct thread *thread);\nextern void bgp_route_map_terminate(void);\n\nextern int peer_cmp(struct peer *p1, struct peer *p2);\n\nextern int bgp_map_afi_safi_iana2int(iana_afi_t pkt_afi, iana_safi_t pkt_safi,\n\t\t\t\t     afi_t *afi, safi_t *safi);\nextern int bgp_map_afi_safi_int2iana(afi_t afi, safi_t safi,\n\t\t\t\t     iana_afi_t *pkt_afi,\n\t\t\t\t     iana_safi_t *pkt_safi);\n\nextern struct peer_af *peer_af_create(struct peer *, afi_t, safi_t);\nextern struct peer_af *peer_af_find(struct peer *, afi_t, safi_t);\nextern int peer_af_delete(struct peer *, afi_t, safi_t);\n\nextern void bgp_close(void);\nextern void bgp_free(struct bgp *);\n\nstatic inline struct bgp *bgp_lock(struct bgp *bgp)\n{\n\tbgp->lock++;\n\treturn bgp;\n}\n\nstatic inline void bgp_unlock(struct bgp *bgp)\n{\n\tassert(bgp->lock > 0);\n\tif (--bgp->lock == 0)\n\t\tbgp_free(bgp);\n}\n\nstatic inline int afindex(afi_t afi, safi_t safi)\n{\n\tswitch (afi) {\n\tcase AFI_IP:\n\t\tswitch (safi) {\n\t\tcase SAFI_UNICAST:\n\t\t\treturn BGP_AF_IPV4_UNICAST;\n\t\t\tbreak;\n\t\tcase SAFI_MULTICAST:\n\t\t\treturn BGP_AF_IPV4_MULTICAST;\n\t\t\tbreak;\n\t\tcase SAFI_LABELED_UNICAST:\n\t\t\treturn BGP_AF_IPV4_LBL_UNICAST;\n\t\t\tbreak;\n\t\tcase SAFI_MPLS_VPN:\n\t\t\treturn BGP_AF_IPV4_VPN;\n\t\t\tbreak;\n\t\tcase SAFI_ENCAP:\n\t\t\treturn BGP_AF_IPV4_ENCAP;\n\t\t\tbreak;\n\t\tcase SAFI_FLOWSPEC:\n\t\t\treturn BGP_AF_IPV4_FLOWSPEC;\n\t\tdefault:\n\t\t\treturn BGP_AF_MAX;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AFI_IP6:\n\t\tswitch (safi) {\n\t\tcase SAFI_UNICAST:\n\t\t\treturn BGP_AF_IPV6_UNICAST;\n\t\t\tbreak;\n\t\tcase SAFI_MULTICAST:\n\t\t\treturn BGP_AF_IPV6_MULTICAST;\n\t\t\tbreak;\n\t\tcase SAFI_LABELED_UNICAST:\n\t\t\treturn BGP_AF_IPV6_LBL_UNICAST;\n\t\t\tbreak;\n\t\tcase SAFI_MPLS_VPN:\n\t\t\treturn BGP_AF_IPV6_VPN;\n\t\t\tbreak;\n\t\tcase SAFI_ENCAP:\n\t\t\treturn BGP_AF_IPV6_ENCAP;\n\t\t\tbreak;\n\t\tcase SAFI_FLOWSPEC:\n\t\t\treturn BGP_AF_IPV6_FLOWSPEC;\n\t\tdefault:\n\t\t\treturn BGP_AF_MAX;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AFI_L2VPN:\n\t\tswitch (safi) {\n\t\tcase SAFI_EVPN:\n\t\t\treturn BGP_AF_L2VPN_EVPN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn BGP_AF_MAX;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn BGP_AF_MAX;\n\t\tbreak;\n\t}\n}\n\n/* If the peer is not a peer-group but is bound to a peer-group return 1 */\nstatic inline int peer_group_active(struct peer *peer)\n{\n\tif (!CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP) && peer->group)\n\t\treturn 1;\n\treturn 0;\n}\n\n/* If peer is negotiated at least one address family return 1. */\nstatic inline int peer_afi_active_nego(const struct peer *peer, afi_t afi)\n{\n\tif (peer->afc_nego[afi][SAFI_UNICAST]\n\t    || peer->afc_nego[afi][SAFI_MULTICAST]\n\t    || peer->afc_nego[afi][SAFI_LABELED_UNICAST]\n\t    || peer->afc_nego[afi][SAFI_MPLS_VPN]\n\t    || peer->afc_nego[afi][SAFI_ENCAP]\n\t    || peer->afc_nego[afi][SAFI_FLOWSPEC]\n\t    || peer->afc_nego[afi][SAFI_EVPN])\n\t\treturn 1;\n\treturn 0;\n}\n\n/* If at least one address family activated for group, return 1. */\nstatic inline int peer_group_af_configured(struct peer_group *group)\n{\n\tstruct peer *peer = group->conf;\n\n\tif (peer->afc[AFI_IP][SAFI_UNICAST] || peer->afc[AFI_IP][SAFI_MULTICAST]\n\t    || peer->afc[AFI_IP][SAFI_LABELED_UNICAST]\n\t    || peer->afc[AFI_IP][SAFI_FLOWSPEC]\n\t    || peer->afc[AFI_IP][SAFI_MPLS_VPN] || peer->afc[AFI_IP][SAFI_ENCAP]\n\t    || peer->afc[AFI_IP6][SAFI_UNICAST]\n\t    || peer->afc[AFI_IP6][SAFI_MULTICAST]\n\t    || peer->afc[AFI_IP6][SAFI_LABELED_UNICAST]\n\t    || peer->afc[AFI_IP6][SAFI_MPLS_VPN]\n\t    || peer->afc[AFI_IP6][SAFI_ENCAP]\n\t    || peer->afc[AFI_IP6][SAFI_FLOWSPEC]\n\t    || peer->afc[AFI_L2VPN][SAFI_EVPN])\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline char *timestamp_string(time_t ts)\n{\n\ttime_t tbuf;\n\ttbuf = time(NULL) - (bgp_clock() - ts);\n\treturn ctime(&tbuf);\n}\n\nstatic inline int peer_established(struct peer *peer)\n{\n\tif (peer->status == Established)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int peer_dynamic_neighbor(struct peer *peer)\n{\n\treturn (CHECK_FLAG(peer->flags, PEER_FLAG_DYNAMIC_NEIGHBOR)) ? 1 : 0;\n}\n\nstatic inline int peer_cap_enhe(struct peer *peer, afi_t afi, safi_t safi)\n{\n\treturn (CHECK_FLAG(peer->af_cap[afi][safi], PEER_CAP_ENHE_AF_NEGO));\n}\n\n/* Lookup VRF for BGP instance based on its type. */\nstatic inline struct vrf *bgp_vrf_lookup_by_instance_type(struct bgp *bgp)\n{\n\tstruct vrf *vrf;\n\n\tif (bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT)\n\t\tvrf = vrf_lookup_by_id(VRF_DEFAULT);\n\telse if (bgp->inst_type == BGP_INSTANCE_TYPE_VRF)\n\t\tvrf = vrf_lookup_by_name(bgp->name);\n\telse\n\t\tvrf = NULL;\n\n\treturn vrf;\n}\n\n/* Link BGP instance to VRF. */\nstatic inline void bgp_vrf_link(struct bgp *bgp, struct vrf *vrf)\n{\n\tbgp->vrf_id = vrf->vrf_id;\n\tif (vrf->info != (void *)bgp)\n\t\tvrf->info = (void *)bgp_lock(bgp);\n}\n\n/* Unlink BGP instance from VRF. */\nstatic inline void bgp_vrf_unlink(struct bgp *bgp, struct vrf *vrf)\n{\n\tif (vrf->info == (void *)bgp) {\n\t\tvrf->info = NULL;\n\t\tbgp_unlock(bgp);\n\t}\n\tbgp->vrf_id = VRF_UNKNOWN;\n}\n\nextern void bgp_update_redist_vrf_bitmaps(struct bgp *, vrf_id_t);\n\n/* For benefit of rfapi */\nextern struct peer *peer_new(struct bgp *bgp);\n#endif /* _QUAGGA_BGPD_H */\n"], "fixing_code": ["/* BGP attributes management routines.\n * Copyright (C) 1996, 97, 98, 1999 Kunihiro Ishiguro\n *\n * This file is part of GNU Zebra.\n *\n * GNU Zebra is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2, or (at your option) any\n * later version.\n *\n * GNU Zebra is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; see the file COPYING; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <zebra.h>\n\n#include \"linklist.h\"\n#include \"prefix.h\"\n#include \"memory.h\"\n#include \"vector.h\"\n#include \"stream.h\"\n#include \"log.h\"\n#include \"hash.h\"\n#include \"jhash.h\"\n#include \"queue.h\"\n#include \"table.h\"\n#include \"filter.h\"\n#include \"command.h\"\n\n#include \"bgpd/bgpd.h\"\n#include \"bgpd/bgp_attr.h\"\n#include \"bgpd/bgp_route.h\"\n#include \"bgpd/bgp_aspath.h\"\n#include \"bgpd/bgp_community.h\"\n#include \"bgpd/bgp_debug.h\"\n#include \"bgpd/bgp_errors.h\"\n#include \"bgpd/bgp_label.h\"\n#include \"bgpd/bgp_packet.h\"\n#include \"bgpd/bgp_ecommunity.h\"\n#include \"bgpd/bgp_lcommunity.h\"\n#include \"bgpd/bgp_updgrp.h\"\n#include \"bgpd/bgp_encap_types.h\"\n#if ENABLE_BGP_VNC\n#include \"bgpd/rfapi/bgp_rfapi_cfg.h\"\n#include \"bgp_encap_types.h\"\n#include \"bgp_vnc_types.h\"\n#endif\n#include \"bgp_encap_types.h\"\n#include \"bgp_evpn.h\"\n#include \"bgp_flowspec_private.h\"\n\n/* Attribute strings for logging. */\nstatic const struct message attr_str[] = {\n\t{BGP_ATTR_ORIGIN, \"ORIGIN\"},\n\t{BGP_ATTR_AS_PATH, \"AS_PATH\"},\n\t{BGP_ATTR_NEXT_HOP, \"NEXT_HOP\"},\n\t{BGP_ATTR_MULTI_EXIT_DISC, \"MULTI_EXIT_DISC\"},\n\t{BGP_ATTR_LOCAL_PREF, \"LOCAL_PREF\"},\n\t{BGP_ATTR_ATOMIC_AGGREGATE, \"ATOMIC_AGGREGATE\"},\n\t{BGP_ATTR_AGGREGATOR, \"AGGREGATOR\"},\n\t{BGP_ATTR_COMMUNITIES, \"COMMUNITY\"},\n\t{BGP_ATTR_ORIGINATOR_ID, \"ORIGINATOR_ID\"},\n\t{BGP_ATTR_CLUSTER_LIST, \"CLUSTER_LIST\"},\n\t{BGP_ATTR_DPA, \"DPA\"},\n\t{BGP_ATTR_ADVERTISER, \"ADVERTISER\"},\n\t{BGP_ATTR_RCID_PATH, \"RCID_PATH\"},\n\t{BGP_ATTR_MP_REACH_NLRI, \"MP_REACH_NLRI\"},\n\t{BGP_ATTR_MP_UNREACH_NLRI, \"MP_UNREACH_NLRI\"},\n\t{BGP_ATTR_EXT_COMMUNITIES, \"EXT_COMMUNITIES\"},\n\t{BGP_ATTR_AS4_PATH, \"AS4_PATH\"},\n\t{BGP_ATTR_AS4_AGGREGATOR, \"AS4_AGGREGATOR\"},\n\t{BGP_ATTR_AS_PATHLIMIT, \"AS_PATHLIMIT\"},\n\t{BGP_ATTR_PMSI_TUNNEL, \"PMSI_TUNNEL_ATTRIBUTE\"},\n\t{BGP_ATTR_ENCAP, \"ENCAP\"},\n#if ENABLE_BGP_VNC_ATTR\n\t{BGP_ATTR_VNC, \"VNC\"},\n#endif\n\t{BGP_ATTR_LARGE_COMMUNITIES, \"LARGE_COMMUNITY\"},\n\t{BGP_ATTR_PREFIX_SID, \"PREFIX_SID\"},\n\t{0}};\n\nstatic const struct message attr_flag_str[] = {\n\t{BGP_ATTR_FLAG_OPTIONAL, \"Optional\"},\n\t{BGP_ATTR_FLAG_TRANS, \"Transitive\"},\n\t{BGP_ATTR_FLAG_PARTIAL, \"Partial\"},\n\t/* bgp_attr_flags_diagnose() relies on this bit being last in\n\t   this list */\n\t{BGP_ATTR_FLAG_EXTLEN, \"Extended Length\"},\n\t{0}};\n\nstatic struct hash *cluster_hash;\n\nstatic void *cluster_hash_alloc(void *p)\n{\n\tconst struct cluster_list *val = (const struct cluster_list *)p;\n\tstruct cluster_list *cluster;\n\n\tcluster = XMALLOC(MTYPE_CLUSTER, sizeof(struct cluster_list));\n\tcluster->length = val->length;\n\n\tif (cluster->length) {\n\t\tcluster->list = XMALLOC(MTYPE_CLUSTER_VAL, val->length);\n\t\tmemcpy(cluster->list, val->list, val->length);\n\t} else\n\t\tcluster->list = NULL;\n\n\tcluster->refcnt = 0;\n\n\treturn cluster;\n}\n\n/* Cluster list related functions. */\nstatic struct cluster_list *cluster_parse(struct in_addr *pnt, int length)\n{\n\tstruct cluster_list tmp;\n\tstruct cluster_list *cluster;\n\n\ttmp.length = length;\n\ttmp.list = pnt;\n\n\tcluster = hash_get(cluster_hash, &tmp, cluster_hash_alloc);\n\tcluster->refcnt++;\n\treturn cluster;\n}\n\nint cluster_loop_check(struct cluster_list *cluster, struct in_addr originator)\n{\n\tint i;\n\n\tfor (i = 0; i < cluster->length / 4; i++)\n\t\tif (cluster->list[i].s_addr == originator.s_addr)\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic unsigned int cluster_hash_key_make(void *p)\n{\n\tconst struct cluster_list *cluster = p;\n\n\treturn jhash(cluster->list, cluster->length, 0);\n}\n\nstatic bool cluster_hash_cmp(const void *p1, const void *p2)\n{\n\tconst struct cluster_list *cluster1 = p1;\n\tconst struct cluster_list *cluster2 = p2;\n\n\treturn (cluster1->length == cluster2->length\n\t\t&& memcmp(cluster1->list, cluster2->list, cluster1->length)\n\t\t\t   == 0);\n}\n\nstatic void cluster_free(struct cluster_list *cluster)\n{\n\tif (cluster->list)\n\t\tXFREE(MTYPE_CLUSTER_VAL, cluster->list);\n\tXFREE(MTYPE_CLUSTER, cluster);\n}\n\nstatic struct cluster_list *cluster_intern(struct cluster_list *cluster)\n{\n\tstruct cluster_list *find;\n\n\tfind = hash_get(cluster_hash, cluster, cluster_hash_alloc);\n\tfind->refcnt++;\n\n\treturn find;\n}\n\nvoid cluster_unintern(struct cluster_list *cluster)\n{\n\tif (cluster->refcnt)\n\t\tcluster->refcnt--;\n\n\tif (cluster->refcnt == 0) {\n\t\thash_release(cluster_hash, cluster);\n\t\tcluster_free(cluster);\n\t}\n}\n\nstatic void cluster_init(void)\n{\n\tcluster_hash = hash_create(cluster_hash_key_make, cluster_hash_cmp,\n\t\t\t\t   \"BGP Cluster\");\n}\n\nstatic void cluster_finish(void)\n{\n\thash_clean(cluster_hash, (void (*)(void *))cluster_free);\n\thash_free(cluster_hash);\n\tcluster_hash = NULL;\n}\n\nstatic struct hash *encap_hash = NULL;\n#if ENABLE_BGP_VNC\nstatic struct hash *vnc_hash = NULL;\n#endif\n\nstruct bgp_attr_encap_subtlv *encap_tlv_dup(struct bgp_attr_encap_subtlv *orig)\n{\n\tstruct bgp_attr_encap_subtlv *new;\n\tstruct bgp_attr_encap_subtlv *tail;\n\tstruct bgp_attr_encap_subtlv *p;\n\n\tfor (p = orig, tail = new = NULL; p; p = p->next) {\n\t\tint size = sizeof(struct bgp_attr_encap_subtlv) + p->length;\n\t\tif (tail) {\n\t\t\ttail->next = XCALLOC(MTYPE_ENCAP_TLV, size);\n\t\t\ttail = tail->next;\n\t\t} else {\n\t\t\ttail = new = XCALLOC(MTYPE_ENCAP_TLV, size);\n\t\t}\n\t\tassert(tail);\n\t\tmemcpy(tail, p, size);\n\t\ttail->next = NULL;\n\t}\n\n\treturn new;\n}\n\nstatic void encap_free(struct bgp_attr_encap_subtlv *p)\n{\n\tstruct bgp_attr_encap_subtlv *next;\n\twhile (p) {\n\t\tnext = p->next;\n\t\tp->next = NULL;\n\t\tXFREE(MTYPE_ENCAP_TLV, p);\n\t\tp = next;\n\t}\n}\n\nvoid bgp_attr_flush_encap(struct attr *attr)\n{\n\tif (!attr)\n\t\treturn;\n\n\tif (attr->encap_subtlvs) {\n\t\tencap_free(attr->encap_subtlvs);\n\t\tattr->encap_subtlvs = NULL;\n\t}\n#if ENABLE_BGP_VNC\n\tif (attr->vnc_subtlvs) {\n\t\tencap_free(attr->vnc_subtlvs);\n\t\tattr->vnc_subtlvs = NULL;\n\t}\n#endif\n}\n\n/*\n * Compare encap sub-tlv chains\n *\n *\t1 = equivalent\n *\t0 = not equivalent\n *\n * This algorithm could be made faster if needed\n */\nstatic int encap_same(const struct bgp_attr_encap_subtlv *h1,\n\t\t      const struct bgp_attr_encap_subtlv *h2)\n{\n\tconst struct bgp_attr_encap_subtlv *p;\n\tconst struct bgp_attr_encap_subtlv *q;\n\n\tif (h1 == h2)\n\t\treturn 1;\n\tif (h1 == NULL || h2 == NULL)\n\t\treturn 0;\n\n\tfor (p = h1; p; p = p->next) {\n\t\tfor (q = h2; q; q = q->next) {\n\t\t\tif ((p->type == q->type) && (p->length == q->length)\n\t\t\t    && !memcmp(p->value, q->value, p->length)) {\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!q)\n\t\t\treturn 0;\n\t}\n\n\tfor (p = h2; p; p = p->next) {\n\t\tfor (q = h1; q; q = q->next) {\n\t\t\tif ((p->type == q->type) && (p->length == q->length)\n\t\t\t    && !memcmp(p->value, q->value, p->length)) {\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!q)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void *encap_hash_alloc(void *p)\n{\n\t/* Encap structure is already allocated.  */\n\treturn p;\n}\n\ntypedef enum {\n\tENCAP_SUBTLV_TYPE,\n#if ENABLE_BGP_VNC\n\tVNC_SUBTLV_TYPE\n#endif\n} encap_subtlv_type;\n\nstatic struct bgp_attr_encap_subtlv *\nencap_intern(struct bgp_attr_encap_subtlv *encap, encap_subtlv_type type)\n{\n\tstruct bgp_attr_encap_subtlv *find;\n\tstruct hash *hash = encap_hash;\n#if ENABLE_BGP_VNC\n\tif (type == VNC_SUBTLV_TYPE)\n\t\thash = vnc_hash;\n#endif\n\n\tfind = hash_get(hash, encap, encap_hash_alloc);\n\tif (find != encap)\n\t\tencap_free(encap);\n\tfind->refcnt++;\n\n\treturn find;\n}\n\nstatic void encap_unintern(struct bgp_attr_encap_subtlv **encapp,\n\t\t\t   encap_subtlv_type type)\n{\n\tstruct bgp_attr_encap_subtlv *encap = *encapp;\n\tif (encap->refcnt)\n\t\tencap->refcnt--;\n\n\tif (encap->refcnt == 0) {\n\t\tstruct hash *hash = encap_hash;\n#if ENABLE_BGP_VNC\n\t\tif (type == VNC_SUBTLV_TYPE)\n\t\t\thash = vnc_hash;\n#endif\n\t\thash_release(hash, encap);\n\t\tencap_free(encap);\n\t\t*encapp = NULL;\n\t}\n}\n\nstatic unsigned int encap_hash_key_make(void *p)\n{\n\tconst struct bgp_attr_encap_subtlv *encap = p;\n\n\treturn jhash(encap->value, encap->length, 0);\n}\n\nstatic bool encap_hash_cmp(const void *p1, const void *p2)\n{\n\treturn encap_same((const struct bgp_attr_encap_subtlv *)p1,\n\t\t\t  (const struct bgp_attr_encap_subtlv *)p2);\n}\n\nstatic void encap_init(void)\n{\n\tencap_hash = hash_create(encap_hash_key_make, encap_hash_cmp,\n\t\t\t\t \"BGP Encap Hash\");\n#if ENABLE_BGP_VNC\n\tvnc_hash = hash_create(encap_hash_key_make, encap_hash_cmp,\n\t\t\t       \"BGP VNC Hash\");\n#endif\n}\n\nstatic void encap_finish(void)\n{\n\thash_clean(encap_hash, (void (*)(void *))encap_free);\n\thash_free(encap_hash);\n\tencap_hash = NULL;\n#if ENABLE_BGP_VNC\n\thash_clean(vnc_hash, (void (*)(void *))encap_free);\n\thash_free(vnc_hash);\n\tvnc_hash = NULL;\n#endif\n}\n\nstatic bool overlay_index_same(const struct attr *a1, const struct attr *a2)\n{\n\tif (!a1 && a2)\n\t\treturn false;\n\tif (!a2 && a1)\n\t\treturn false;\n\tif (!a1 && !a2)\n\t\treturn true;\n\treturn !memcmp(&(a1->evpn_overlay), &(a2->evpn_overlay),\n\t\t       sizeof(struct overlay_index));\n}\n\n/* Unknown transit attribute. */\nstatic struct hash *transit_hash;\n\nstatic void transit_free(struct transit *transit)\n{\n\tif (transit->val)\n\t\tXFREE(MTYPE_TRANSIT_VAL, transit->val);\n\tXFREE(MTYPE_TRANSIT, transit);\n}\n\nstatic void *transit_hash_alloc(void *p)\n{\n\t/* Transit structure is already allocated.  */\n\treturn p;\n}\n\nstatic struct transit *transit_intern(struct transit *transit)\n{\n\tstruct transit *find;\n\n\tfind = hash_get(transit_hash, transit, transit_hash_alloc);\n\tif (find != transit)\n\t\ttransit_free(transit);\n\tfind->refcnt++;\n\n\treturn find;\n}\n\nvoid transit_unintern(struct transit *transit)\n{\n\tif (transit->refcnt)\n\t\ttransit->refcnt--;\n\n\tif (transit->refcnt == 0) {\n\t\thash_release(transit_hash, transit);\n\t\ttransit_free(transit);\n\t}\n}\n\nstatic unsigned int transit_hash_key_make(void *p)\n{\n\tconst struct transit *transit = p;\n\n\treturn jhash(transit->val, transit->length, 0);\n}\n\nstatic bool transit_hash_cmp(const void *p1, const void *p2)\n{\n\tconst struct transit *transit1 = p1;\n\tconst struct transit *transit2 = p2;\n\n\treturn (transit1->length == transit2->length\n\t\t&& memcmp(transit1->val, transit2->val, transit1->length) == 0);\n}\n\nstatic void transit_init(void)\n{\n\ttransit_hash = hash_create(transit_hash_key_make, transit_hash_cmp,\n\t\t\t\t   \"BGP Transit Hash\");\n}\n\nstatic void transit_finish(void)\n{\n\thash_clean(transit_hash, (void (*)(void *))transit_free);\n\thash_free(transit_hash);\n\ttransit_hash = NULL;\n}\n\n/* Attribute hash routines. */\nstatic struct hash *attrhash;\n\n/* Shallow copy of an attribute\n * Though, not so shallow that it doesn't copy the contents\n * of the attr_extra pointed to by 'extra'\n */\nvoid bgp_attr_dup(struct attr *new, struct attr *orig)\n{\n\t*new = *orig;\n}\n\nunsigned long int attr_count(void)\n{\n\treturn attrhash->count;\n}\n\nunsigned long int attr_unknown_count(void)\n{\n\treturn transit_hash->count;\n}\n\nunsigned int attrhash_key_make(void *p)\n{\n\tconst struct attr *attr = (struct attr *)p;\n\tuint32_t key = 0;\n#define MIX(val)\tkey = jhash_1word(val, key)\n#define MIX3(a, b, c)\tkey = jhash_3words((a), (b), (c), key)\n\n\tMIX3(attr->origin, attr->nexthop.s_addr, attr->med);\n\tMIX3(attr->local_pref, attr->aggregator_as,\n\t     attr->aggregator_addr.s_addr);\n\tMIX3(attr->weight, attr->mp_nexthop_global_in.s_addr,\n\t     attr->originator_id.s_addr);\n\tMIX3(attr->tag, attr->label, attr->label_index);\n\n\tif (attr->aspath)\n\t\tMIX(aspath_key_make(attr->aspath));\n\tif (attr->community)\n\t\tMIX(community_hash_make(attr->community));\n\n\tif (attr->lcommunity)\n\t\tMIX(lcommunity_hash_make(attr->lcommunity));\n\tif (attr->ecommunity)\n\t\tMIX(ecommunity_hash_make(attr->ecommunity));\n\tif (attr->cluster)\n\t\tMIX(cluster_hash_key_make(attr->cluster));\n\tif (attr->transit)\n\t\tMIX(transit_hash_key_make(attr->transit));\n\tif (attr->encap_subtlvs)\n\t\tMIX(encap_hash_key_make(attr->encap_subtlvs));\n#if ENABLE_BGP_VNC\n\tif (attr->vnc_subtlvs)\n\t\tMIX(encap_hash_key_make(attr->vnc_subtlvs));\n#endif\n\tMIX(attr->mp_nexthop_len);\n\tkey = jhash(attr->mp_nexthop_global.s6_addr, IPV6_MAX_BYTELEN, key);\n\tkey = jhash(attr->mp_nexthop_local.s6_addr, IPV6_MAX_BYTELEN, key);\n\tMIX(attr->nh_ifindex);\n\tMIX(attr->nh_lla_ifindex);\n\n\treturn key;\n}\n\nbool attrhash_cmp(const void *p1, const void *p2)\n{\n\tconst struct attr *attr1 = p1;\n\tconst struct attr *attr2 = p2;\n\n\tif (attr1->flag == attr2->flag && attr1->origin == attr2->origin\n\t    && attr1->nexthop.s_addr == attr2->nexthop.s_addr\n\t    && attr1->aspath == attr2->aspath\n\t    && attr1->community == attr2->community && attr1->med == attr2->med\n\t    && attr1->local_pref == attr2->local_pref\n\t    && attr1->rmap_change_flags == attr2->rmap_change_flags) {\n\t\tif (attr1->aggregator_as == attr2->aggregator_as\n\t\t    && attr1->aggregator_addr.s_addr\n\t\t\t       == attr2->aggregator_addr.s_addr\n\t\t    && attr1->weight == attr2->weight\n\t\t    && attr1->tag == attr2->tag\n\t\t    && attr1->label_index == attr2->label_index\n\t\t    && attr1->mp_nexthop_len == attr2->mp_nexthop_len\n\t\t    && attr1->ecommunity == attr2->ecommunity\n\t\t    && attr1->lcommunity == attr2->lcommunity\n\t\t    && attr1->cluster == attr2->cluster\n\t\t    && attr1->transit == attr2->transit\n\t\t    && (attr1->encap_tunneltype == attr2->encap_tunneltype)\n\t\t    && encap_same(attr1->encap_subtlvs, attr2->encap_subtlvs)\n#if ENABLE_BGP_VNC\n\t\t    && encap_same(attr1->vnc_subtlvs, attr2->vnc_subtlvs)\n#endif\n\t\t    && IPV6_ADDR_SAME(&attr1->mp_nexthop_global,\n\t\t\t\t      &attr2->mp_nexthop_global)\n\t\t    && IPV6_ADDR_SAME(&attr1->mp_nexthop_local,\n\t\t\t\t      &attr2->mp_nexthop_local)\n\t\t    && IPV4_ADDR_SAME(&attr1->mp_nexthop_global_in,\n\t\t\t\t      &attr2->mp_nexthop_global_in)\n\t\t    && IPV4_ADDR_SAME(&attr1->originator_id,\n\t\t\t\t      &attr2->originator_id)\n\t\t    && overlay_index_same(attr1, attr2)\n\t\t    && attr1->nh_ifindex == attr2->nh_ifindex\n\t\t    && attr1->nh_lla_ifindex == attr2->nh_lla_ifindex)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void attrhash_init(void)\n{\n\tattrhash =\n\t\thash_create(attrhash_key_make, attrhash_cmp, \"BGP Attributes\");\n}\n\n/*\n * special for hash_clean below\n */\nstatic void attr_vfree(void *attr)\n{\n\tXFREE(MTYPE_ATTR, attr);\n}\n\nstatic void attrhash_finish(void)\n{\n\thash_clean(attrhash, attr_vfree);\n\thash_free(attrhash);\n\tattrhash = NULL;\n}\n\nstatic void attr_show_all_iterator(struct hash_backet *backet, struct vty *vty)\n{\n\tstruct attr *attr = backet->data;\n\n\tvty_out(vty, \"attr[%ld] nexthop %s\\n\", attr->refcnt,\n\t\tinet_ntoa(attr->nexthop));\n\tvty_out(vty, \"\\tflags: %\" PRIu64 \" med: %u local_pref: %u origin: %u weight: %u label: %u\\n\",\n\t\tattr->flag, attr->med, attr->local_pref, attr->origin,\n\t\tattr->weight, attr->label);\n}\n\nvoid attr_show_all(struct vty *vty)\n{\n\thash_iterate(attrhash, (void (*)(struct hash_backet *,\n\t\t\t\t\t void *))attr_show_all_iterator,\n\t\t     vty);\n}\n\nstatic void *bgp_attr_hash_alloc(void *p)\n{\n\tstruct attr *val = (struct attr *)p;\n\tstruct attr *attr;\n\n\tattr = XMALLOC(MTYPE_ATTR, sizeof(struct attr));\n\t*attr = *val;\n\tif (val->encap_subtlvs) {\n\t\tval->encap_subtlvs = NULL;\n\t}\n#if ENABLE_BGP_VNC\n\tif (val->vnc_subtlvs) {\n\t\tval->vnc_subtlvs = NULL;\n\t}\n#endif\n\tattr->refcnt = 0;\n\treturn attr;\n}\n\n/* Internet argument attribute. */\nstruct attr *bgp_attr_intern(struct attr *attr)\n{\n\tstruct attr *find;\n\n\t/* Intern referenced strucutre. */\n\tif (attr->aspath) {\n\t\tif (!attr->aspath->refcnt)\n\t\t\tattr->aspath = aspath_intern(attr->aspath);\n\t\telse\n\t\t\tattr->aspath->refcnt++;\n\t}\n\tif (attr->community) {\n\t\tif (!attr->community->refcnt)\n\t\t\tattr->community = community_intern(attr->community);\n\t\telse\n\t\t\tattr->community->refcnt++;\n\t}\n\n\tif (attr->ecommunity) {\n\t\tif (!attr->ecommunity->refcnt)\n\t\t\tattr->ecommunity = ecommunity_intern(attr->ecommunity);\n\t\telse\n\t\t\tattr->ecommunity->refcnt++;\n\t}\n\tif (attr->lcommunity) {\n\t\tif (!attr->lcommunity->refcnt)\n\t\t\tattr->lcommunity = lcommunity_intern(attr->lcommunity);\n\t\telse\n\t\t\tattr->lcommunity->refcnt++;\n\t}\n\tif (attr->cluster) {\n\t\tif (!attr->cluster->refcnt)\n\t\t\tattr->cluster = cluster_intern(attr->cluster);\n\t\telse\n\t\t\tattr->cluster->refcnt++;\n\t}\n\tif (attr->transit) {\n\t\tif (!attr->transit->refcnt)\n\t\t\tattr->transit = transit_intern(attr->transit);\n\t\telse\n\t\t\tattr->transit->refcnt++;\n\t}\n\tif (attr->encap_subtlvs) {\n\t\tif (!attr->encap_subtlvs->refcnt)\n\t\t\tattr->encap_subtlvs = encap_intern(attr->encap_subtlvs,\n\t\t\t\t\t\t\t   ENCAP_SUBTLV_TYPE);\n\t\telse\n\t\t\tattr->encap_subtlvs->refcnt++;\n\t}\n#if ENABLE_BGP_VNC\n\tif (attr->vnc_subtlvs) {\n\t\tif (!attr->vnc_subtlvs->refcnt)\n\t\t\tattr->vnc_subtlvs = encap_intern(attr->vnc_subtlvs,\n\t\t\t\t\t\t\t VNC_SUBTLV_TYPE);\n\t\telse\n\t\t\tattr->vnc_subtlvs->refcnt++;\n\t}\n#endif\n\n\t/* At this point, attr only contains intern'd pointers.  that means\n\t * if we find it in attrhash, it has all the same pointers and we\n\t * correctly updated the refcounts on these.\n\t * If we don't find it, we need to allocate a one because in all\n\t * cases this returns a new reference to a hashed attr, but the input\n\t * wasn't on hash. */\n\tfind = (struct attr *)hash_get(attrhash, attr, bgp_attr_hash_alloc);\n\tfind->refcnt++;\n\n\treturn find;\n}\n\n/* Make network statement's attribute. */\nstruct attr *bgp_attr_default_set(struct attr *attr, uint8_t origin)\n{\n\tmemset(attr, 0, sizeof(struct attr));\n\n\tattr->origin = origin;\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_ORIGIN);\n\tattr->aspath = aspath_empty();\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AS_PATH);\n\tattr->weight = BGP_ATTR_DEFAULT_WEIGHT;\n\tattr->tag = 0;\n\tattr->label_index = BGP_INVALID_LABEL_INDEX;\n\tattr->label = MPLS_INVALID_LABEL;\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP);\n\tattr->mp_nexthop_len = IPV6_MAX_BYTELEN;\n\n\treturn attr;\n}\n\n/* Create the attributes for an aggregate */\nstruct attr *bgp_attr_aggregate_intern(struct bgp *bgp, uint8_t origin,\n\t\t\t\t       struct aspath *aspath,\n\t\t\t\t       struct community *community,\n\t\t\t\t       struct ecommunity *ecommunity,\n\t\t\t\t       struct lcommunity *lcommunity,\n\t\t\t\t       int as_set, uint8_t atomic_aggregate)\n{\n\tstruct attr attr;\n\tstruct attr *new;\n\n\tmemset(&attr, 0, sizeof(struct attr));\n\n\t/* Origin attribute. */\n\tattr.origin = origin;\n\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_ORIGIN);\n\n\t/* AS path attribute. */\n\tif (aspath)\n\t\tattr.aspath = aspath_intern(aspath);\n\telse\n\t\tattr.aspath = aspath_empty();\n\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_AS_PATH);\n\n\t/* Next hop attribute.  */\n\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP);\n\n\tif (community) {\n\t\tuint32_t gshut = COMMUNITY_GSHUT;\n\n\t\t/* If we are not shutting down ourselves and we are\n\t\t * aggregating a route that contains the GSHUT community we\n\t\t * need to remove that community when creating the aggregate */\n\t\tif (!bgp_flag_check(bgp, BGP_FLAG_GRACEFUL_SHUTDOWN)\n\t\t    && community_include(community, gshut)) {\n\t\t\tcommunity_del_val(community, &gshut);\n\t\t}\n\n\t\tattr.community = community;\n\t\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES);\n\t}\n\n\tif (ecommunity) {\n\t\tattr.ecommunity = ecommunity;\n\t\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES);\n\t}\n\n\tif (lcommunity) {\n\t\tattr.lcommunity = lcommunity;\n\t\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES);\n\t}\n\n\tif (bgp_flag_check(bgp, BGP_FLAG_GRACEFUL_SHUTDOWN)) {\n\t\tbgp_attr_add_gshut_community(&attr);\n\t}\n\n\tattr.label_index = BGP_INVALID_LABEL_INDEX;\n\tattr.label = MPLS_INVALID_LABEL;\n\tattr.weight = BGP_ATTR_DEFAULT_WEIGHT;\n\tattr.mp_nexthop_len = IPV6_MAX_BYTELEN;\n\tif (!as_set || atomic_aggregate)\n\t\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE);\n\tattr.flag |= ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR);\n\tif (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION))\n\t\tattr.aggregator_as = bgp->confed_id;\n\telse\n\t\tattr.aggregator_as = bgp->as;\n\tattr.aggregator_addr = bgp->router_id;\n\tattr.label_index = BGP_INVALID_LABEL_INDEX;\n\tattr.label = MPLS_INVALID_LABEL;\n\n\tnew = bgp_attr_intern(&attr);\n\n\taspath_unintern(&new->aspath);\n\treturn new;\n}\n\n/* Unintern just the sub-components of the attr, but not the attr */\nvoid bgp_attr_unintern_sub(struct attr *attr)\n{\n\t/* aspath refcount shoud be decrement. */\n\tif (attr->aspath)\n\t\taspath_unintern(&attr->aspath);\n\tUNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH));\n\n\tif (attr->community)\n\t\tcommunity_unintern(&attr->community);\n\tUNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES));\n\n\tif (attr->ecommunity)\n\t\tecommunity_unintern(&attr->ecommunity);\n\tUNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES));\n\n\tif (attr->lcommunity)\n\t\tlcommunity_unintern(&attr->lcommunity);\n\tUNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES));\n\n\tif (attr->cluster)\n\t\tcluster_unintern(attr->cluster);\n\tUNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_CLUSTER_LIST));\n\n\tif (attr->transit)\n\t\ttransit_unintern(attr->transit);\n\n\tif (attr->encap_subtlvs)\n\t\tencap_unintern(&attr->encap_subtlvs, ENCAP_SUBTLV_TYPE);\n\n#if ENABLE_BGP_VNC\n\tif (attr->vnc_subtlvs)\n\t\tencap_unintern(&attr->vnc_subtlvs, VNC_SUBTLV_TYPE);\n#endif\n}\n\n/*\n * We have some show commands that let you experimentally\n * apply a route-map.  When we apply the route-map\n * we are reseting values but not saving them for\n * posterity via intern'ing( because route-maps don't\n * do that) but at this point in time we need\n * to compare the new attr to the old and if the\n * routemap has changed it we need to, as Snoop Dog says,\n * Drop it like it's hot\n */\nvoid bgp_attr_undup(struct attr *new, struct attr *old)\n{\n\tif (new->aspath != old->aspath)\n\t\taspath_free(new->aspath);\n\n\tif (new->community != old->community)\n\t\tcommunity_free(&new->community);\n\n\tif (new->ecommunity != old->ecommunity)\n\t\tecommunity_free(&new->ecommunity);\n\n\tif (new->lcommunity != old->lcommunity)\n\t\tlcommunity_free(&new->lcommunity);\n}\n\n/* Free bgp attribute and aspath. */\nvoid bgp_attr_unintern(struct attr **pattr)\n{\n\tstruct attr *attr = *pattr;\n\tstruct attr *ret;\n\tstruct attr tmp;\n\n\t/* Decrement attribute reference. */\n\tattr->refcnt--;\n\n\ttmp = *attr;\n\n\t/* If reference becomes zero then free attribute object. */\n\tif (attr->refcnt == 0) {\n\t\tret = hash_release(attrhash, attr);\n\t\tassert(ret != NULL);\n\t\tXFREE(MTYPE_ATTR, attr);\n\t\t*pattr = NULL;\n\t}\n\n\tbgp_attr_unintern_sub(&tmp);\n}\n\nvoid bgp_attr_flush(struct attr *attr)\n{\n\tif (attr->aspath && !attr->aspath->refcnt) {\n\t\taspath_free(attr->aspath);\n\t\tattr->aspath = NULL;\n\t}\n\tif (attr->community && !attr->community->refcnt)\n\t\tcommunity_free(&attr->community);\n\tif (attr->ecommunity && !attr->ecommunity->refcnt)\n\t\tecommunity_free(&attr->ecommunity);\n\tif (attr->lcommunity && !attr->lcommunity->refcnt)\n\t\tlcommunity_free(&attr->lcommunity);\n\tif (attr->cluster && !attr->cluster->refcnt) {\n\t\tcluster_free(attr->cluster);\n\t\tattr->cluster = NULL;\n\t}\n\tif (attr->transit && !attr->transit->refcnt) {\n\t\ttransit_free(attr->transit);\n\t\tattr->transit = NULL;\n\t}\n\tif (attr->encap_subtlvs && !attr->encap_subtlvs->refcnt) {\n\t\tencap_free(attr->encap_subtlvs);\n\t\tattr->encap_subtlvs = NULL;\n\t}\n#if ENABLE_BGP_VNC\n\tif (attr->vnc_subtlvs && !attr->vnc_subtlvs->refcnt) {\n\t\tencap_free(attr->vnc_subtlvs);\n\t\tattr->vnc_subtlvs = NULL;\n\t}\n#endif\n}\n\n/* Implement draft-scudder-idr-optional-transitive behaviour and\n * avoid resetting sessions for malformed attributes which are\n * are partial/optional and hence where the error likely was not\n * introduced by the sending neighbour.\n */\nstatic bgp_attr_parse_ret_t\nbgp_attr_malformed(struct bgp_attr_parser_args *args, uint8_t subcode,\n\t\t   bgp_size_t length)\n{\n\tstruct peer *const peer = args->peer;\n\tconst uint8_t flags = args->flags;\n\t/* startp and length must be special-cased, as whether or not to\n\t * send the attribute data with the NOTIFY depends on the error,\n\t * the caller therefore signals this with the seperate length argument\n\t */\n\tuint8_t *notify_datap = (length > 0 ? args->startp : NULL);\n\n\t/* Only relax error handling for eBGP peers */\n\tif (peer->sort != BGP_PEER_EBGP) {\n\t\tbgp_notify_send_with_data(peer, BGP_NOTIFY_UPDATE_ERR, subcode,\n\t\t\t\t\t  notify_datap, length);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\t/* Adjust the stream getp to the end of the attribute, in case we can\n\t * still proceed but the caller hasn't read all the attribute.\n\t */\n\tstream_set_getp(BGP_INPUT(peer),\n\t\t\t(args->startp - STREAM_DATA(BGP_INPUT(peer)))\n\t\t\t\t+ args->total);\n\n\tswitch (args->type) {\n\t/* where an attribute is relatively inconsequential, e.g. it does not\n\t * affect route selection, and can be safely ignored, then any such\n\t * attributes which are malformed should just be ignored and the route\n\t * processed as normal.\n\t */\n\tcase BGP_ATTR_AS4_AGGREGATOR:\n\tcase BGP_ATTR_AGGREGATOR:\n\tcase BGP_ATTR_ATOMIC_AGGREGATE:\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\n\t/* Core attributes, particularly ones which may influence route\n\t * selection, should always cause session resets\n\t */\n\tcase BGP_ATTR_ORIGIN:\n\tcase BGP_ATTR_AS_PATH:\n\tcase BGP_ATTR_NEXT_HOP:\n\tcase BGP_ATTR_MULTI_EXIT_DISC:\n\tcase BGP_ATTR_LOCAL_PREF:\n\tcase BGP_ATTR_COMMUNITIES:\n\tcase BGP_ATTR_ORIGINATOR_ID:\n\tcase BGP_ATTR_CLUSTER_LIST:\n\tcase BGP_ATTR_MP_REACH_NLRI:\n\tcase BGP_ATTR_MP_UNREACH_NLRI:\n\tcase BGP_ATTR_EXT_COMMUNITIES:\n\t\tbgp_notify_send_with_data(peer, BGP_NOTIFY_UPDATE_ERR, subcode,\n\t\t\t\t\t  notify_datap, length);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\t/* Partial optional attributes that are malformed should not cause\n\t * the whole session to be reset. Instead treat it as a withdrawal\n\t * of the routes, if possible.\n\t */\n\tif (CHECK_FLAG(flags, BGP_ATTR_FLAG_TRANS)\n\t    && CHECK_FLAG(flags, BGP_ATTR_FLAG_OPTIONAL)\n\t    && CHECK_FLAG(flags, BGP_ATTR_FLAG_PARTIAL))\n\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\n\t/* default to reset */\n\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n}\n\n/* Find out what is wrong with the path attribute flag bits and log the error.\n   \"Flag bits\" here stand for Optional, Transitive and Partial, but not for\n   Extended Length. Checking O/T/P bits at once implies, that the attribute\n   being diagnosed is defined by RFC as either a \"well-known\" or an \"optional,\n   non-transitive\" attribute. */\nstatic void\nbgp_attr_flags_diagnose(struct bgp_attr_parser_args *args,\n\t\t\tuint8_t desired_flags /* how RFC says it must be */\n)\n{\n\tuint8_t seen = 0, i;\n\tuint8_t real_flags = args->flags;\n\tconst uint8_t attr_code = args->type;\n\n\tdesired_flags &= ~BGP_ATTR_FLAG_EXTLEN;\n\treal_flags &= ~BGP_ATTR_FLAG_EXTLEN;\n\tfor (i = 0; i <= 2; i++) /* O,T,P, but not E */\n\t\tif (CHECK_FLAG(desired_flags, attr_flag_str[i].key)\n\t\t    != CHECK_FLAG(real_flags, attr_flag_str[i].key)) {\n\t\t\tflog_err(EC_BGP_ATTR_FLAG,\n\t\t\t\t \"%s attribute must%s be flagged as \\\"%s\\\"\",\n\t\t\t\t lookup_msg(attr_str, attr_code, NULL),\n\t\t\t\t CHECK_FLAG(desired_flags, attr_flag_str[i].key)\n\t\t\t\t\t ? \"\"\n\t\t\t\t\t : \" not\",\n\t\t\t\t attr_flag_str[i].str);\n\t\t\tseen = 1;\n\t\t}\n\tif (!seen) {\n\t\tzlog_debug(\n\t\t\t\"Strange, %s called for attr %s, but no problem found with flags\"\n\t\t\t\" (real flags 0x%x, desired 0x%x)\",\n\t\t\t__func__, lookup_msg(attr_str, attr_code, NULL),\n\t\t\treal_flags, desired_flags);\n\t}\n}\n\n/* Required flags for attributes. EXTLEN will be masked off when testing,\n * as will PARTIAL for optional+transitive attributes.\n */\nconst uint8_t attr_flags_values[] = {\n\t[BGP_ATTR_ORIGIN] = BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_AS_PATH] = BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_NEXT_HOP] = BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_MULTI_EXIT_DISC] = BGP_ATTR_FLAG_OPTIONAL,\n\t[BGP_ATTR_LOCAL_PREF] = BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_ATOMIC_AGGREGATE] = BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_AGGREGATOR] = BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL,\n\t[BGP_ATTR_COMMUNITIES] = BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL,\n\t[BGP_ATTR_ORIGINATOR_ID] = BGP_ATTR_FLAG_OPTIONAL,\n\t[BGP_ATTR_CLUSTER_LIST] = BGP_ATTR_FLAG_OPTIONAL,\n\t[BGP_ATTR_MP_REACH_NLRI] = BGP_ATTR_FLAG_OPTIONAL,\n\t[BGP_ATTR_MP_UNREACH_NLRI] = BGP_ATTR_FLAG_OPTIONAL,\n\t[BGP_ATTR_EXT_COMMUNITIES] =\n\t\tBGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_AS4_PATH] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_AS4_AGGREGATOR] =\n\t\tBGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_PMSI_TUNNEL] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_LARGE_COMMUNITIES] =\n\t\tBGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,\n\t[BGP_ATTR_PREFIX_SID] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,\n};\nstatic const size_t attr_flags_values_max = array_size(attr_flags_values) - 1;\n\nstatic int bgp_attr_flag_invalid(struct bgp_attr_parser_args *args)\n{\n\tuint8_t mask = BGP_ATTR_FLAG_EXTLEN;\n\tconst uint8_t flags = args->flags;\n\tconst uint8_t attr_code = args->type;\n\n\t/* there may be attributes we don't know about */\n\tif (attr_code > attr_flags_values_max)\n\t\treturn 0;\n\tif (attr_flags_values[attr_code] == 0)\n\t\treturn 0;\n\n\t/* RFC4271, \"For well-known attributes, the Transitive bit MUST be set\n\t * to\n\t * 1.\"\n\t */\n\tif (!CHECK_FLAG(BGP_ATTR_FLAG_OPTIONAL, flags)\n\t    && !CHECK_FLAG(BGP_ATTR_FLAG_TRANS, flags)) {\n\t\tflog_err(\n\t\t\tEC_BGP_ATTR_FLAG,\n\t\t\t\"%s well-known attributes must have transitive flag set (%x)\",\n\t\t\tlookup_msg(attr_str, attr_code, NULL), flags);\n\t\treturn 1;\n\t}\n\n\t/* \"For well-known attributes and for optional non-transitive\n\t * attributes,\n\t *  the Partial bit MUST be set to 0.\"\n\t */\n\tif (CHECK_FLAG(flags, BGP_ATTR_FLAG_PARTIAL)) {\n\t\tif (!CHECK_FLAG(flags, BGP_ATTR_FLAG_OPTIONAL)) {\n\t\t\tflog_err(EC_BGP_ATTR_FLAG,\n\t\t\t\t \"%s well-known attribute \"\n\t\t\t\t \"must NOT have the partial flag set (%x)\",\n\t\t\t\t lookup_msg(attr_str, attr_code, NULL), flags);\n\t\t\treturn 1;\n\t\t}\n\t\tif (CHECK_FLAG(flags, BGP_ATTR_FLAG_OPTIONAL)\n\t\t    && !CHECK_FLAG(flags, BGP_ATTR_FLAG_TRANS)) {\n\t\t\tflog_err(EC_BGP_ATTR_FLAG,\n\t\t\t\t \"%s optional + transitive attribute \"\n\t\t\t\t \"must NOT have the partial flag set (%x)\",\n\t\t\t\t lookup_msg(attr_str, attr_code, NULL), flags);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Optional transitive attributes may go through speakers that don't\n\t * reocgnise them and set the Partial bit.\n\t */\n\tif (CHECK_FLAG(flags, BGP_ATTR_FLAG_OPTIONAL)\n\t    && CHECK_FLAG(flags, BGP_ATTR_FLAG_TRANS))\n\t\tSET_FLAG(mask, BGP_ATTR_FLAG_PARTIAL);\n\n\tif ((flags & ~mask) == attr_flags_values[attr_code])\n\t\treturn 0;\n\n\tbgp_attr_flags_diagnose(args, attr_flags_values[attr_code]);\n\treturn 1;\n}\n\n/* Get origin attribute of the update message. */\nstatic bgp_attr_parse_ret_t bgp_attr_origin(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/* If any recognized attribute has Attribute Length that conflicts\n\t   with the expected length (based on the attribute type code), then\n\t   the Error Subcode is set to Attribute Length Error.  The Data\n\t   field contains the erroneous attribute (type, length and\n\t   value). */\n\tif (length != 1) {\n\t\tflog_err(EC_BGP_ATTR_LEN,\n\t\t\t \"Origin attribute length is not one %d\", length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\t/* Fetch origin attribute. */\n\tattr->origin = stream_getc(BGP_INPUT(peer));\n\n\t/* If the ORIGIN attribute has an undefined value, then the Error\n\t   Subcode is set to Invalid Origin Attribute.  The Data field\n\t   contains the unrecognized attribute (type, length and value). */\n\tif ((attr->origin != BGP_ORIGIN_IGP) && (attr->origin != BGP_ORIGIN_EGP)\n\t    && (attr->origin != BGP_ORIGIN_INCOMPLETE)) {\n\t\tflog_err(EC_BGP_ATTR_ORIGIN,\n\t\t\t \"Origin attribute value is invalid %d\", attr->origin);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_INVAL_ORIGIN,\n\t\t\t\t\t  args->total);\n\t}\n\n\t/* Set oring attribute flag. */\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_ORIGIN);\n\n\treturn 0;\n}\n\n/* Parse AS path information.  This function is wrapper of\n   aspath_parse. */\nstatic int bgp_attr_aspath(struct bgp_attr_parser_args *args)\n{\n\tstruct attr *const attr = args->attr;\n\tstruct peer *const peer = args->peer;\n\tconst bgp_size_t length = args->length;\n\n\t/*\n\t * peer with AS4 => will get 4Byte ASnums\n\t * otherwise, will get 16 Bit\n\t */\n\tattr->aspath = aspath_parse(peer->curr, length,\n\t\t\t\t    CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV));\n\n\t/* In case of IBGP, length will be zero. */\n\tif (!attr->aspath) {\n\t\tflog_err(EC_BGP_ATTR_MAL_AS_PATH,\n\t\t\t \"Malformed AS path from %s, length is %d\", peer->host,\n\t\t\t length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_MAL_AS_PATH,\n\t\t\t\t\t  0);\n\t}\n\n\t/* Set aspath attribute flag. */\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AS_PATH);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\nstatic bgp_attr_parse_ret_t bgp_attr_aspath_check(struct peer *const peer,\n\t\t\t\t\t\t  struct attr *const attr)\n{\n\t/* These checks were part of bgp_attr_aspath, but with\n\t * as4 we should to check aspath things when\n\t * aspath synthesizing with as4_path has already taken place.\n\t * Otherwise we check ASPATH and use the synthesized thing, and that is\n\t * not right.\n\t * So do the checks later, i.e. here\n\t */\n\tstruct aspath *aspath;\n\n\t/* Confederation sanity check. */\n\tif ((peer->sort == BGP_PEER_CONFED\n\t     && !aspath_left_confed_check(attr->aspath))\n\t    || (peer->sort == BGP_PEER_EBGP\n\t\t&& aspath_confed_check(attr->aspath))) {\n\t\tflog_err(EC_BGP_ATTR_MAL_AS_PATH, \"Malformed AS path from %s\",\n\t\t\t peer->host);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_AS_PATH);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\t/* First AS check for EBGP. */\n\tif (CHECK_FLAG(peer->flags, PEER_FLAG_ENFORCE_FIRST_AS)) {\n\t\tif (peer->sort == BGP_PEER_EBGP\n\t\t    && !aspath_firstas_check(attr->aspath, peer->as)) {\n\t\t\tflog_err(EC_BGP_ATTR_FIRST_AS,\n\t\t\t\t \"%s incorrect first AS (must be %u)\",\n\t\t\t\t peer->host, peer->as);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_MAL_AS_PATH);\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\t}\n\n\t/* local-as prepend */\n\tif (peer->change_local_as\n\t    && !CHECK_FLAG(peer->flags, PEER_FLAG_LOCAL_AS_NO_PREPEND)) {\n\t\taspath = aspath_dup(attr->aspath);\n\t\taspath = aspath_add_seq(aspath, peer->change_local_as);\n\t\taspath_unintern(&attr->aspath);\n\t\tattr->aspath = aspath_intern(aspath);\n\t}\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Parse AS4 path information.  This function is another wrapper of\n   aspath_parse. */\nstatic int bgp_attr_as4_path(struct bgp_attr_parser_args *args,\n\t\t\t     struct aspath **as4_path)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t*as4_path = aspath_parse(peer->curr, length, 1);\n\n\t/* In case of IBGP, length will be zero. */\n\tif (!*as4_path) {\n\t\tflog_err(EC_BGP_ATTR_MAL_AS_PATH,\n\t\t\t \"Malformed AS4 path from %s, length is %d\", peer->host,\n\t\t\t length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_MAL_AS_PATH,\n\t\t\t\t\t  0);\n\t}\n\n\t/* Set aspath attribute flag. */\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AS4_PATH);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Nexthop attribute. */\nstatic bgp_attr_parse_ret_t bgp_attr_nexthop(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\tin_addr_t nexthop_h, nexthop_n;\n\n\t/* Check nexthop attribute length. */\n\tif (length != 4) {\n\t\tflog_err(EC_BGP_ATTR_LEN,\n\t\t\t \"Nexthop attribute length isn't four [%d]\", length);\n\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\t/* According to section 6.3 of RFC4271, syntactically incorrect NEXT_HOP\n\t   attribute must result in a NOTIFICATION message (this is implemented\n\t   below).\n\t   At the same time, semantically incorrect NEXT_HOP is more likely to\n\t   be just\n\t   logged locally (this is implemented somewhere else). The UPDATE\n\t   message\n\t   gets ignored in any of these cases. */\n\tnexthop_n = stream_get_ipv4(peer->curr);\n\tnexthop_h = ntohl(nexthop_n);\n\tif ((IPV4_NET0(nexthop_h) || IPV4_NET127(nexthop_h)\n\t     || IPV4_CLASS_DE(nexthop_h))\n\t    && !BGP_DEBUG(\n\t\t       allow_martians,\n\t\t       ALLOW_MARTIANS)) /* loopbacks may be used in testing */\n\t{\n\t\tchar buf[INET_ADDRSTRLEN];\n\t\tinet_ntop(AF_INET, &nexthop_n, buf, INET_ADDRSTRLEN);\n\t\tflog_err(EC_BGP_ATTR_MARTIAN_NH, \"Martian nexthop %s\", buf);\n\t\treturn bgp_attr_malformed(\n\t\t\targs, BGP_NOTIFY_UPDATE_INVAL_NEXT_HOP, args->total);\n\t}\n\n\tattr->nexthop.s_addr = nexthop_n;\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* MED atrribute. */\nstatic bgp_attr_parse_ret_t bgp_attr_med(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/* Length check. */\n\tif (length != 4) {\n\t\tflog_err(EC_BGP_ATTR_LEN,\n\t\t\t \"MED attribute length isn't four [%d]\", length);\n\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\tattr->med = stream_getl(peer->curr);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Local preference attribute. */\nstatic bgp_attr_parse_ret_t\nbgp_attr_local_pref(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/* Length check. */\n\tif (length != 4) {\n\t\tflog_err(EC_BGP_ATTR_LEN,\n\t\t\t \"LOCAL_PREF attribute length isn't 4 [%u]\", length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\t/* If it is contained in an UPDATE message that is received from an\n\t   external peer, then this attribute MUST be ignored by the\n\t   receiving speaker. */\n\tif (peer->sort == BGP_PEER_EBGP) {\n\t\tstream_forward_getp(peer->curr, length);\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\t}\n\n\tattr->local_pref = stream_getl(peer->curr);\n\n\t/* Set the local-pref flag. */\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Atomic aggregate. */\nstatic int bgp_attr_atomic(struct bgp_attr_parser_args *args)\n{\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/* Length check. */\n\tif (length != 0) {\n\t\tflog_err(EC_BGP_ATTR_LEN,\n\t\t\t \"ATOMIC_AGGREGATE attribute length isn't 0 [%u]\",\n\t\t\t length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\t/* Set atomic aggregate flag. */\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Aggregator attribute */\nstatic int bgp_attr_aggregator(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\tint wantedlen = 6;\n\n\t/* peer with AS4 will send 4 Byte AS, peer without will send 2 Byte */\n\tif (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV))\n\t\twantedlen = 8;\n\n\tif (length != wantedlen) {\n\t\tflog_err(EC_BGP_ATTR_LEN,\n\t\t\t \"AGGREGATOR attribute length isn't %u [%u]\", wantedlen,\n\t\t\t length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\tif (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV))\n\t\tattr->aggregator_as = stream_getl(peer->curr);\n\telse\n\t\tattr->aggregator_as = stream_getw(peer->curr);\n\tattr->aggregator_addr.s_addr = stream_get_ipv4(peer->curr);\n\n\t/* Set atomic aggregate flag. */\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* New Aggregator attribute */\nstatic bgp_attr_parse_ret_t\nbgp_attr_as4_aggregator(struct bgp_attr_parser_args *args,\n\t\t\tas_t *as4_aggregator_as,\n\t\t\tstruct in_addr *as4_aggregator_addr)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\tif (length != 8) {\n\t\tflog_err(EC_BGP_ATTR_LEN, \"New Aggregator length is not 8 [%d]\",\n\t\t\t length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  0);\n\t}\n\n\t*as4_aggregator_as = stream_getl(peer->curr);\n\tas4_aggregator_addr->s_addr = stream_get_ipv4(peer->curr);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AS4_AGGREGATOR);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Munge Aggregator and New-Aggregator, AS_PATH and NEW_AS_PATH.\n */\nstatic bgp_attr_parse_ret_t\nbgp_attr_munge_as4_attrs(struct peer *const peer, struct attr *const attr,\n\t\t\t struct aspath *as4_path, as_t as4_aggregator,\n\t\t\t struct in_addr *as4_aggregator_addr)\n{\n\tint ignore_as4_path = 0;\n\tstruct aspath *newpath;\n\n\tif (!attr->aspath) {\n\t\t/* NULL aspath shouldn't be possible as bgp_attr_parse should\n\t\t * have\n\t\t * checked that all well-known, mandatory attributes were\n\t\t * present.\n\t\t *\n\t\t * Can only be a problem with peer itself - hard error\n\t\t */\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\tif (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV)) {\n\t\t/* peer can do AS4, so we ignore AS4_PATH and AS4_AGGREGATOR\n\t\t * if given.\n\t\t * It is worth a warning though, because the peer really\n\t\t * should not send them\n\t\t */\n\t\tif (BGP_DEBUG(as4, AS4)) {\n\t\t\tif (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS4_PATH)))\n\t\t\t\tzlog_debug(\"[AS4] %s %s AS4_PATH\", peer->host,\n\t\t\t\t\t   \"AS4 capable peer, yet it sent\");\n\n\t\t\tif (attr->flag\n\t\t\t    & (ATTR_FLAG_BIT(BGP_ATTR_AS4_AGGREGATOR)))\n\t\t\t\tzlog_debug(\"[AS4] %s %s AS4_AGGREGATOR\",\n\t\t\t\t\t   peer->host,\n\t\t\t\t\t   \"AS4 capable peer, yet it sent\");\n\t\t}\n\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\t}\n\n\t/* We have a asn16 peer.  First, look for AS4_AGGREGATOR\n\t * because that may override AS4_PATH\n\t */\n\tif (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS4_AGGREGATOR))) {\n\t\tif (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR))) {\n\t\t\t/* received both.\n\t\t\t * if the as_number in aggregator is not AS_TRANS,\n\t\t\t *  then AS4_AGGREGATOR and AS4_PATH shall be ignored\n\t\t\t *        and the Aggregator shall be taken as\n\t\t\t *        info on the aggregating node, and the AS_PATH\n\t\t\t *        shall be taken as the AS_PATH\n\t\t\t *  otherwise\n\t\t\t *        the Aggregator shall be ignored and the\n\t\t\t *        AS4_AGGREGATOR shall be taken as the\n\t\t\t *        Aggregating node and the AS_PATH is to be\n\t\t\t *        constructed \"as in all other cases\"\n\t\t\t */\n\t\t\tif (attr->aggregator_as != BGP_AS_TRANS) {\n\t\t\t\t/* ignore */\n\t\t\t\tif (BGP_DEBUG(as4, AS4))\n\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\"[AS4] %s BGP not AS4 capable peer\"\n\t\t\t\t\t\t\" send AGGREGATOR != AS_TRANS and\"\n\t\t\t\t\t\t\" AS4_AGGREGATOR, so ignore\"\n\t\t\t\t\t\t\" AS4_AGGREGATOR and AS4_PATH\",\n\t\t\t\t\t\tpeer->host);\n\t\t\t\tignore_as4_path = 1;\n\t\t\t} else {\n\t\t\t\t/* \"New_aggregator shall be taken as aggregator\"\n\t\t\t\t */\n\t\t\t\tattr->aggregator_as = as4_aggregator;\n\t\t\t\tattr->aggregator_addr.s_addr =\n\t\t\t\t\tas4_aggregator_addr->s_addr;\n\t\t\t}\n\t\t} else {\n\t\t\t/* We received a AS4_AGGREGATOR but no AGGREGATOR.\n\t\t\t * That is bogus - but reading the conditions\n\t\t\t * we have to handle AS4_AGGREGATOR as if it were\n\t\t\t * AGGREGATOR in that case\n\t\t\t */\n\t\t\tif (BGP_DEBUG(as4, AS4))\n\t\t\t\tzlog_debug(\n\t\t\t\t\t\"[AS4] %s BGP not AS4 capable peer send\"\n\t\t\t\t\t\" AS4_AGGREGATOR but no AGGREGATOR, will take\"\n\t\t\t\t\t\" it as if AGGREGATOR with AS_TRANS had been there\",\n\t\t\t\t\tpeer->host);\n\t\t\tattr->aggregator_as = as4_aggregator;\n\t\t\t/* sweep it under the carpet and simulate a \"good\"\n\t\t\t * AGGREGATOR */\n\t\t\tattr->flag |= (ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR));\n\t\t}\n\t}\n\n\t/* need to reconcile NEW_AS_PATH and AS_PATH */\n\tif (!ignore_as4_path\n\t    && (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS4_PATH)))) {\n\t\tnewpath = aspath_reconcile_as4(attr->aspath, as4_path);\n\t\tif (!newpath)\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\n\t\taspath_unintern(&attr->aspath);\n\t\tattr->aspath = aspath_intern(newpath);\n\t}\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Community attribute. */\nstatic bgp_attr_parse_ret_t\nbgp_attr_community(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\tif (length == 0) {\n\t\tattr->community = NULL;\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\t}\n\n\tattr->community =\n\t\tcommunity_parse((uint32_t *)stream_pnt(peer->curr), length);\n\n\t/* XXX: fix community_parse to use stream API and remove this */\n\tstream_forward_getp(peer->curr, length);\n\n\tif (!attr->community)\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,\n\t\t\t\t\t  args->total);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Originator ID attribute. */\nstatic bgp_attr_parse_ret_t\nbgp_attr_originator_id(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/* Length check. */\n\tif (length != 4) {\n\t\tflog_err(EC_BGP_ATTR_LEN, \"Bad originator ID length %d\",\n\t\t\t length);\n\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\tattr->originator_id.s_addr = stream_get_ipv4(peer->curr);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Cluster list attribute. */\nstatic bgp_attr_parse_ret_t\nbgp_attr_cluster_list(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/* Check length. */\n\tif (length % 4) {\n\t\tflog_err(EC_BGP_ATTR_LEN, \"Bad cluster list length %d\", length);\n\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\tattr->cluster =\n\t\tcluster_parse((struct in_addr *)stream_pnt(peer->curr), length);\n\n\t/* XXX: Fix cluster_parse to use stream API and then remove this */\n\tstream_forward_getp(peer->curr, length);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_CLUSTER_LIST);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Multiprotocol reachability information parse. */\nint bgp_mp_reach_parse(struct bgp_attr_parser_args *args,\n\t\t       struct bgp_nlri *mp_update)\n{\n\tiana_afi_t pkt_afi;\n\tafi_t afi;\n\tiana_safi_t pkt_safi;\n\tsafi_t safi;\n\tbgp_size_t nlri_len;\n\tsize_t start;\n\tstruct stream *s;\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/* Set end of packet. */\n\ts = BGP_INPUT(peer);\n\tstart = stream_get_getp(s);\n\n/* safe to read statically sized header? */\n#define BGP_MP_REACH_MIN_SIZE 5\n#define LEN_LEFT\t(length - (stream_get_getp(s) - start))\n\tif ((length > STREAM_READABLE(s)) || (length < BGP_MP_REACH_MIN_SIZE)) {\n\t\tzlog_info(\"%s: %s sent invalid length, %lu\", __func__,\n\t\t\t  peer->host, (unsigned long)length);\n\t\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n\t}\n\n\t/* Load AFI, SAFI. */\n\tpkt_afi = stream_getw(s);\n\tpkt_safi = stream_getc(s);\n\n\t/* Convert AFI, SAFI to internal values, check. */\n\tif (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi, &safi)) {\n\t\t/* Log if AFI or SAFI is unrecognized. This is not an error\n\t\t * unless\n\t\t * the attribute is otherwise malformed.\n\t\t */\n\t\tif (bgp_debug_update(peer, NULL, NULL, 0))\n\t\t\tzlog_debug(\n\t\t\t\t\"%s: MP_REACH received AFI %u or SAFI %u is unrecognized\",\n\t\t\t\tpeer->host, pkt_afi, pkt_safi);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\t/* Get nexthop length. */\n\tattr->mp_nexthop_len = stream_getc(s);\n\n\tif (LEN_LEFT < attr->mp_nexthop_len) {\n\t\tzlog_info(\n\t\t\t\"%s: %s, MP nexthop length, %u, goes past end of attribute\",\n\t\t\t__func__, peer->host, attr->mp_nexthop_len);\n\t\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n\t}\n\n\t/* Nexthop length check. */\n\tswitch (attr->mp_nexthop_len) {\n\tcase 0:\n\t\tif (safi != SAFI_FLOWSPEC) {\n\t\t\tzlog_info(\"%s: (%s) Wrong multiprotocol next hop length: %d\",\n\t\t\t\t  __func__, peer->host, attr->mp_nexthop_len);\n\t\t\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n\t\t}\n\t\tbreak;\n\tcase BGP_ATTR_NHLEN_VPNV4:\n\t\tstream_getl(s); /* RD high */\n\t\tstream_getl(s); /* RD low */\n\t\t\t\t/*\n\t\t\t\t * NOTE: intentional fall through\n\t\t\t\t * - for consistency in rx processing\n\t\t\t\t *\n\t\t\t\t * The following comment is to signal GCC this intention\n\t\t\t\t * and suppress the warning\n\t\t\t\t */\n\t/* FALLTHRU */\n\tcase BGP_ATTR_NHLEN_IPV4:\n\t\tstream_get(&attr->mp_nexthop_global_in, s, IPV4_MAX_BYTELEN);\n\t\t/* Probably needed for RFC 2283 */\n\t\tif (attr->nexthop.s_addr == 0)\n\t\t\tmemcpy(&attr->nexthop.s_addr,\n\t\t\t       &attr->mp_nexthop_global_in, IPV4_MAX_BYTELEN);\n\t\tbreak;\n\tcase BGP_ATTR_NHLEN_IPV6_GLOBAL:\n\tcase BGP_ATTR_NHLEN_VPNV6_GLOBAL:\n\t\tif (attr->mp_nexthop_len == BGP_ATTR_NHLEN_VPNV6_GLOBAL) {\n\t\t\tstream_getl(s); /* RD high */\n\t\t\tstream_getl(s); /* RD low */\n\t\t}\n\t\tstream_get(&attr->mp_nexthop_global, s, IPV6_MAX_BYTELEN);\n\t\tif (IN6_IS_ADDR_LINKLOCAL(&attr->mp_nexthop_global)) {\n\t\t\tif (!peer->nexthop.ifp) {\n\t\t\t\tzlog_warn(\"%s: interface not set appropriately to handle some attributes\",\n\t\t\t\t\t  peer->host);\n\t\t\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\t\t\t}\n\t\t\tattr->nh_ifindex = peer->nexthop.ifp->ifindex;\n\t\t}\n\t\tbreak;\n\tcase BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL:\n\tcase BGP_ATTR_NHLEN_VPNV6_GLOBAL_AND_LL:\n\t\tif (attr->mp_nexthop_len\n\t\t    == BGP_ATTR_NHLEN_VPNV6_GLOBAL_AND_LL) {\n\t\t\tstream_getl(s); /* RD high */\n\t\t\tstream_getl(s); /* RD low */\n\t\t}\n\t\tstream_get(&attr->mp_nexthop_global, s, IPV6_MAX_BYTELEN);\n\t\tif (IN6_IS_ADDR_LINKLOCAL(&attr->mp_nexthop_global)) {\n\t\t\tif (!peer->nexthop.ifp) {\n\t\t\t\tzlog_warn(\"%s: interface not set appropriately to handle some attributes\",\n\t\t\t\t\t  peer->host);\n\t\t\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\t\t\t}\n\t\t\tattr->nh_ifindex = peer->nexthop.ifp->ifindex;\n\t\t}\n\t\tif (attr->mp_nexthop_len\n\t\t    == BGP_ATTR_NHLEN_VPNV6_GLOBAL_AND_LL) {\n\t\t\tstream_getl(s); /* RD high */\n\t\t\tstream_getl(s); /* RD low */\n\t\t}\n\t\tstream_get(&attr->mp_nexthop_local, s, IPV6_MAX_BYTELEN);\n\t\tif (!IN6_IS_ADDR_LINKLOCAL(&attr->mp_nexthop_local)) {\n\t\t\tchar buf1[INET6_ADDRSTRLEN];\n\t\t\tchar buf2[INET6_ADDRSTRLEN];\n\n\t\t\tif (bgp_debug_update(peer, NULL, NULL, 1))\n\t\t\t\tzlog_debug(\n\t\t\t\t\t\"%s rcvd nexthops %s, %s -- ignoring non-LL value\",\n\t\t\t\t\tpeer->host,\n\t\t\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t\t\t  &attr->mp_nexthop_global,\n\t\t\t\t\t\t  buf1, INET6_ADDRSTRLEN),\n\t\t\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t\t\t  &attr->mp_nexthop_local, buf2,\n\t\t\t\t\t\t  INET6_ADDRSTRLEN));\n\n\t\t\tattr->mp_nexthop_len = IPV6_MAX_BYTELEN;\n\t\t}\n\t\tif (!peer->nexthop.ifp) {\n\t\t\tzlog_warn(\"%s: Interface not set appropriately to handle this some attributes\",\n\t\t\t\t  peer->host);\n\t\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\t\t}\n\t\tattr->nh_lla_ifindex = peer->nexthop.ifp->ifindex;\n\t\tbreak;\n\tdefault:\n\t\tzlog_info(\"%s: (%s) Wrong multiprotocol next hop length: %d\",\n\t\t\t  __func__, peer->host, attr->mp_nexthop_len);\n\t\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n\t}\n\n\tif (!LEN_LEFT) {\n\t\tzlog_info(\"%s: (%s) Failed to read SNPA and NLRI(s)\", __func__,\n\t\t\t  peer->host);\n\t\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n\t}\n\n\t{\n\t\tuint8_t val;\n\t\tif ((val = stream_getc(s)))\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_DEFUNCT_SNPA_LEN,\n\t\t\t\t\"%s sent non-zero value, %u, for defunct SNPA-length field\",\n\t\t\t\tpeer->host, val);\n\t}\n\n\t/* must have nrli_len, what is left of the attribute */\n\tnlri_len = LEN_LEFT;\n\tif (nlri_len > STREAM_READABLE(s)) {\n\t\tzlog_info(\"%s: (%s) Failed to read NLRI\", __func__, peer->host);\n\t\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n\t}\n\n\tif (!nlri_len) {\n\t\tzlog_info(\"%s: (%s) No Reachability, Treating as a EOR marker\",\n\t\t\t  __func__, peer->host);\n\n\t\tmp_update->afi = afi;\n\t\tmp_update->safi = safi;\n\t\treturn BGP_ATTR_PARSE_EOR;\n\t}\n\n\tmp_update->afi = afi;\n\tmp_update->safi = safi;\n\tmp_update->nlri = stream_pnt(s);\n\tmp_update->length = nlri_len;\n\n\tstream_forward_getp(s, nlri_len);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n#undef LEN_LEFT\n}\n\n/* Multiprotocol unreachable parse */\nint bgp_mp_unreach_parse(struct bgp_attr_parser_args *args,\n\t\t\t struct bgp_nlri *mp_withdraw)\n{\n\tstruct stream *s;\n\tiana_afi_t pkt_afi;\n\tafi_t afi;\n\tiana_safi_t pkt_safi;\n\tsafi_t safi;\n\tuint16_t withdraw_len;\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\ts = peer->curr;\n\n#define BGP_MP_UNREACH_MIN_SIZE 3\n\tif ((length > STREAM_READABLE(s)) || (length < BGP_MP_UNREACH_MIN_SIZE))\n\t\treturn BGP_ATTR_PARSE_ERROR_NOTIFYPLS;\n\n\tpkt_afi = stream_getw(s);\n\tpkt_safi = stream_getc(s);\n\n\t/* Convert AFI, SAFI to internal values, check. */\n\tif (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi, &safi)) {\n\t\t/* Log if AFI or SAFI is unrecognized. This is not an error\n\t\t * unless\n\t\t * the attribute is otherwise malformed.\n\t\t */\n\t\tif (bgp_debug_update(peer, NULL, NULL, 0))\n\t\t\tzlog_debug(\n\t\t\t\t\"%s: MP_UNREACH received AFI %u or SAFI %u is unrecognized\",\n\t\t\t\tpeer->host, pkt_afi, pkt_safi);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\twithdraw_len = length - BGP_MP_UNREACH_MIN_SIZE;\n\n\tmp_withdraw->afi = afi;\n\tmp_withdraw->safi = safi;\n\tmp_withdraw->nlri = stream_pnt(s);\n\tmp_withdraw->length = withdraw_len;\n\n\tstream_forward_getp(s, withdraw_len);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Large Community attribute. */\nstatic bgp_attr_parse_ret_t\nbgp_attr_large_community(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/*\n\t * Large community follows new attribute format.\n\t */\n\tif (length == 0) {\n\t\tattr->lcommunity = NULL;\n\t\t/* Empty extcomm doesn't seem to be invalid per se */\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\t}\n\n\tattr->lcommunity =\n\t\tlcommunity_parse((uint8_t *)stream_pnt(peer->curr), length);\n\t/* XXX: fix ecommunity_parse to use stream API */\n\tstream_forward_getp(peer->curr, length);\n\n\tif (!attr->lcommunity)\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,\n\t\t\t\t\t  args->total);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Extended Community attribute. */\nstatic bgp_attr_parse_ret_t\nbgp_attr_ext_communities(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\tuint8_t sticky = 0;\n\n\tif (length == 0) {\n\t\tattr->ecommunity = NULL;\n\t\t/* Empty extcomm doesn't seem to be invalid per se */\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\t}\n\n\tattr->ecommunity =\n\t\tecommunity_parse((uint8_t *)stream_pnt(peer->curr), length);\n\t/* XXX: fix ecommunity_parse to use stream API */\n\tstream_forward_getp(peer->curr, length);\n\n\tif (!attr->ecommunity)\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,\n\t\t\t\t\t  args->total);\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES);\n\n\t/* Extract MAC mobility sequence number, if any. */\n\tattr->mm_seqnum = bgp_attr_mac_mobility_seqnum(attr, &sticky);\n\tattr->sticky = sticky;\n\n\t/* Check if this is a Gateway MAC-IP advertisement */\n\tattr->default_gw = bgp_attr_default_gw(attr);\n\n\t/* Handle scenario where router flag ecommunity is not\n\t * set but default gw ext community is present.\n\t * Use default gateway, set and propogate R-bit.\n\t */\n\tif (attr->default_gw)\n\t\tattr->router_flag = 1;\n\n\t/* Check EVPN Neighbor advertisement flags, R-bit */\n\tbgp_attr_evpn_na_flag(attr, &attr->router_flag);\n\n\t/* Extract the Rmac, if any */\n\tbgp_attr_rmac(attr, &attr->rmac);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Parse Tunnel Encap attribute in an UPDATE */\nstatic int bgp_attr_encap(uint8_t type, struct peer *peer, /* IN */\n\t\t\t  bgp_size_t length, /* IN: attr's length field */\n\t\t\t  struct attr *attr, /* IN: caller already allocated */\n\t\t\t  uint8_t flag,      /* IN: attr's flags field */\n\t\t\t  uint8_t *startp)\n{\n\tbgp_size_t total;\n\tuint16_t tunneltype = 0;\n\n\ttotal = length + (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);\n\n\tif (!CHECK_FLAG(flag, BGP_ATTR_FLAG_TRANS)\n\t    || !CHECK_FLAG(flag, BGP_ATTR_FLAG_OPTIONAL)) {\n\t\tzlog_info(\n\t\t\t\"Tunnel Encap attribute flag isn't optional and transitive %d\",\n\t\t\tflag);\n\t\tbgp_notify_send_with_data(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t  BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,\n\t\t\t\t\t  startp, total);\n\t\treturn -1;\n\t}\n\n\tif (BGP_ATTR_ENCAP == type) {\n\t\t/* read outer TLV type and length */\n\t\tuint16_t tlv_length;\n\n\t\tif (length < 4) {\n\t\t\tzlog_info(\n\t\t\t\t\"Tunnel Encap attribute not long enough to contain outer T,L\");\n\t\t\tbgp_notify_send_with_data(\n\t\t\t\tpeer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_OPT_ATTR_ERR, startp, total);\n\t\t\treturn -1;\n\t\t}\n\t\ttunneltype = stream_getw(BGP_INPUT(peer));\n\t\ttlv_length = stream_getw(BGP_INPUT(peer));\n\t\tlength -= 4;\n\n\t\tif (tlv_length != length) {\n\t\t\tzlog_info(\"%s: tlv_length(%d) != length(%d)\", __func__,\n\t\t\t\t  tlv_length, length);\n\t\t}\n\t}\n\n\twhile (length >= 4) {\n\t\tuint16_t subtype = 0;\n\t\tuint16_t sublength = 0;\n\t\tstruct bgp_attr_encap_subtlv *tlv;\n\n\t\tif (BGP_ATTR_ENCAP == type) {\n\t\t\tsubtype = stream_getc(BGP_INPUT(peer));\n\t\t\tsublength = stream_getc(BGP_INPUT(peer));\n\t\t\tlength -= 2;\n#if ENABLE_BGP_VNC\n\t\t} else {\n\t\t\tsubtype = stream_getw(BGP_INPUT(peer));\n\t\t\tsublength = stream_getw(BGP_INPUT(peer));\n\t\t\tlength -= 4;\n#endif\n\t\t}\n\n\t\tif (sublength > length) {\n\t\t\tzlog_info(\n\t\t\t\t\"Tunnel Encap attribute sub-tlv length %d exceeds remaining length %d\",\n\t\t\t\tsublength, length);\n\t\t\tbgp_notify_send_with_data(\n\t\t\t\tpeer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_OPT_ATTR_ERR, startp, total);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* alloc and copy sub-tlv */\n\t\t/* TBD make sure these are freed when attributes are released */\n\t\ttlv = XCALLOC(MTYPE_ENCAP_TLV,\n\t\t\t      sizeof(struct bgp_attr_encap_subtlv) + sublength);\n\t\ttlv->type = subtype;\n\t\ttlv->length = sublength;\n\t\tstream_get(tlv->value, peer->curr, sublength);\n\t\tlength -= sublength;\n\n\t\t/* attach tlv to encap chain */\n\t\tif (BGP_ATTR_ENCAP == type) {\n\t\t\tstruct bgp_attr_encap_subtlv *stlv_last;\n\t\t\tfor (stlv_last = attr->encap_subtlvs;\n\t\t\t     stlv_last && stlv_last->next;\n\t\t\t     stlv_last = stlv_last->next)\n\t\t\t\t;\n\t\t\tif (stlv_last) {\n\t\t\t\tstlv_last->next = tlv;\n\t\t\t} else {\n\t\t\t\tattr->encap_subtlvs = tlv;\n\t\t\t}\n#if ENABLE_BGP_VNC\n\t\t} else {\n\t\t\tstruct bgp_attr_encap_subtlv *stlv_last;\n\t\t\tfor (stlv_last = attr->vnc_subtlvs;\n\t\t\t     stlv_last && stlv_last->next;\n\t\t\t     stlv_last = stlv_last->next)\n\t\t\t\t;\n\t\t\tif (stlv_last) {\n\t\t\t\tstlv_last->next = tlv;\n\t\t\t} else {\n\t\t\t\tattr->vnc_subtlvs = tlv;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\tif (BGP_ATTR_ENCAP == type) {\n\t\tattr->encap_tunneltype = tunneltype;\n\t}\n\n\tif (length) {\n\t\t/* spurious leftover data */\n\t\tzlog_info(\n\t\t\t\"Tunnel Encap attribute length is bad: %d leftover octets\",\n\t\t\tlength);\n\t\tbgp_notify_send_with_data(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t  BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,\n\t\t\t\t\t  startp, total);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Read an individual SID value returning how much data we have read\n * Returns 0 if there was an error that needs to be passed up the stack\n */\nstatic bgp_attr_parse_ret_t bgp_attr_psid_sub(int32_t type,\n\t\t\t\t\t      int32_t length,\n\t\t\t\t\t      struct bgp_attr_parser_args *args,\n\t\t\t\t\t      struct bgp_nlri *mp_update)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tuint32_t label_index;\n\tstruct in6_addr ipv6_sid;\n\tuint32_t srgb_base;\n\tuint32_t srgb_range;\n\tint srgb_count;\n\n\tif (type == BGP_PREFIX_SID_LABEL_INDEX) {\n\t\tif (length != BGP_PREFIX_SID_LABEL_INDEX_LENGTH) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_ATTR_LEN,\n\t\t\t\t\"Prefix SID label index length is %d instead of %d\",\n\t\t\t\tlength, BGP_PREFIX_SID_LABEL_INDEX_LENGTH);\n\t\t\treturn bgp_attr_malformed(args,\n\t\t\t\t\t\t  BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t\t  args->total);\n\t\t}\n\n\t\t/* Ignore flags and reserved */\n\t\tstream_getc(peer->curr);\n\t\tstream_getw(peer->curr);\n\n\t\t/* Fetch the label index and see if it is valid. */\n\t\tlabel_index = stream_getl(peer->curr);\n\t\tif (label_index == BGP_INVALID_LABEL_INDEX)\n\t\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,\n\t\t\t\t\t\t  args->total);\n\n\t\t/* Store label index; subsequently, we'll check on\n\t\t * address-family */\n\t\tattr->label_index = label_index;\n\n\t\t/*\n\t\t * Ignore the Label index attribute unless received for\n\t\t * labeled-unicast\n\t\t * SAFI.\n\t\t */\n\t\tif (!mp_update->length\n\t\t    || mp_update->safi != SAFI_LABELED_UNICAST)\n\t\t\tattr->label_index = BGP_INVALID_LABEL_INDEX;\n\t}\n\n\t/* Placeholder code for the IPv6 SID type */\n\telse if (type == BGP_PREFIX_SID_IPV6) {\n\t\tif (length != BGP_PREFIX_SID_IPV6_LENGTH) {\n\t\t\tflog_err(EC_BGP_ATTR_LEN,\n\t\t\t\t \"Prefix SID IPv6 length is %d instead of %d\",\n\t\t\t\t length, BGP_PREFIX_SID_IPV6_LENGTH);\n\t\t\treturn bgp_attr_malformed(args,\n\t\t\t\t\t\t  BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t\t  args->total);\n\t\t}\n\n\t\t/* Ignore reserved */\n\t\tstream_getc(peer->curr);\n\t\tstream_getw(peer->curr);\n\n\t\tstream_get(&ipv6_sid, peer->curr, 16);\n\t}\n\n\t/* Placeholder code for the Originator SRGB type */\n\telse if (type == BGP_PREFIX_SID_ORIGINATOR_SRGB) {\n\t\t/* Ignore flags */\n\t\tstream_getw(peer->curr);\n\n\t\tlength -= 2;\n\n\t\tif (length % BGP_PREFIX_SID_ORIGINATOR_SRGB_LENGTH) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_ATTR_LEN,\n\t\t\t\t\"Prefix SID Originator SRGB length is %d, it must be a multiple of %d \",\n\t\t\t\tlength, BGP_PREFIX_SID_ORIGINATOR_SRGB_LENGTH);\n\t\t\treturn bgp_attr_malformed(\n\t\t\t\targs, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\targs->total);\n\t\t}\n\n\t\tsrgb_count = length / BGP_PREFIX_SID_ORIGINATOR_SRGB_LENGTH;\n\n\t\tfor (int i = 0; i < srgb_count; i++) {\n\t\t\tstream_get(&srgb_base, peer->curr, 3);\n\t\t\tstream_get(&srgb_range, peer->curr, 3);\n\t\t}\n\t}\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Prefix SID attribute\n * draft-ietf-idr-bgp-prefix-sid-05\n */\nbgp_attr_parse_ret_t\nbgp_attr_prefix_sid(int32_t tlength, struct bgp_attr_parser_args *args,\n\t\t    struct bgp_nlri *mp_update)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tbgp_attr_parse_ret_t ret;\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID);\n\n\twhile (tlength) {\n\t\tint32_t type, length;\n\n\t\ttype = stream_getc(peer->curr);\n\t\tlength = stream_getw(peer->curr);\n\n\t\tret = bgp_attr_psid_sub(type, length, args, mp_update);\n\n\t\tif (ret != BGP_ATTR_PARSE_PROCEED)\n\t\t\treturn ret;\n\t\t/*\n\t\t * Subtract length + the T and the L\n\t\t * since length is the Vector portion\n\t\t */\n\t\ttlength -= length + 3;\n\n\t\tif (tlength < 0) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_ATTR_LEN,\n\t\t\t\t\"Prefix SID internal length %d causes us to read beyond the total Prefix SID length\",\n\t\t\t\tlength);\n\t\t\treturn bgp_attr_malformed(args,\n\t\t\t\t\t\t  BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t\t  args->total);\n\t\t}\n\t}\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* PMSI tunnel attribute (RFC 6514)\n * Basic validation checks done here.\n */\nstatic bgp_attr_parse_ret_t\nbgp_attr_pmsi_tunnel(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\tuint8_t tnl_type;\n\n\t/* Verify that the receiver is expecting \"ingress replication\" as we\n\t * can only support that.\n\t */\n\tif (length < 2) {\n\t\tflog_err(EC_BGP_ATTR_LEN, \"Bad PMSI tunnel attribute length %d\",\n\t\t\t length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\tstream_getc(peer->curr); /* Flags */\n\ttnl_type = stream_getc(peer->curr);\n\tif (tnl_type > PMSI_TNLTYPE_MAX) {\n\t\tflog_err(EC_BGP_ATTR_PMSI_TYPE,\n\t\t\t \"Invalid PMSI tunnel attribute type %d\", tnl_type);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\tif (tnl_type == PMSI_TNLTYPE_INGR_REPL) {\n\t\tif (length != 9) {\n\t\t\tflog_err(EC_BGP_ATTR_PMSI_LEN,\n\t\t\t\t \"Bad PMSI tunnel attribute length %d for IR\",\n\t\t\t\t length);\n\t\t\treturn bgp_attr_malformed(\n\t\t\t\targs, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\targs->total);\n\t\t}\n\t}\n\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_PMSI_TUNNEL);\n\tattr->pmsi_tnl_type = tnl_type;\n\n\t/* Forward read pointer of input stream. */\n\tstream_forward_getp(peer->curr, length - 2);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* BGP unknown attribute treatment. */\nstatic bgp_attr_parse_ret_t bgp_attr_unknown(struct bgp_attr_parser_args *args)\n{\n\tbgp_size_t total = args->total;\n\tstruct transit *transit;\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tuint8_t *const startp = args->startp;\n\tconst uint8_t type = args->type;\n\tconst uint8_t flag = args->flags;\n\tconst bgp_size_t length = args->length;\n\n\tif (bgp_debug_update(peer, NULL, NULL, 1))\n\t\tzlog_debug(\n\t\t\t\"%s Unknown attribute is received (type %d, length %d)\",\n\t\t\tpeer->host, type, length);\n\n\t/* Forward read pointer of input stream. */\n\tstream_forward_getp(peer->curr, length);\n\n\t/* If any of the mandatory well-known attributes are not recognized,\n\t   then the Error Subcode is set to Unrecognized Well-known\n\t   Attribute.  The Data field contains the unrecognized attribute\n\t   (type, length and value). */\n\tif (!CHECK_FLAG(flag, BGP_ATTR_FLAG_OPTIONAL)) {\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_UNREC_ATTR,\n\t\t\t\t\t  args->total);\n\t}\n\n\t/* Unrecognized non-transitive optional attributes must be quietly\n\t   ignored and not passed along to other BGP peers. */\n\tif (!CHECK_FLAG(flag, BGP_ATTR_FLAG_TRANS))\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\n\t/* If a path with recognized transitive optional attribute is\n\t   accepted and passed along to other BGP peers and the Partial bit\n\t   in the Attribute Flags octet is set to 1 by some previous AS, it\n\t   is not set back to 0 by the current AS. */\n\tSET_FLAG(*startp, BGP_ATTR_FLAG_PARTIAL);\n\n\t/* Store transitive attribute to the end of attr->transit. */\n\tif (!attr->transit)\n\t\tattr->transit = XCALLOC(MTYPE_TRANSIT, sizeof(struct transit));\n\n\ttransit = attr->transit;\n\n\tif (transit->val)\n\t\ttransit->val = XREALLOC(MTYPE_TRANSIT_VAL, transit->val,\n\t\t\t\t\ttransit->length + total);\n\telse\n\t\ttransit->val = XMALLOC(MTYPE_TRANSIT_VAL, total);\n\n\tmemcpy(transit->val + transit->length, startp, total);\n\ttransit->length += total;\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Well-known attribute check. */\nstatic int bgp_attr_check(struct peer *peer, struct attr *attr)\n{\n\tuint8_t type = 0;\n\n\t/* BGP Graceful-Restart End-of-RIB for IPv4 unicast is signaled as an\n\t * empty UPDATE.  */\n\tif (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag)\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\n\t/* \"An UPDATE message that contains the MP_UNREACH_NLRI is not required\n\t   to carry any other path attributes.\", though if MP_REACH_NLRI or NLRI\n\t   are present, it should.  Check for any other attribute being present\n\t   instead.\n\t */\n\tif ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) &&\n\t     CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI))))\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_ORIGIN)))\n\t\ttype = BGP_ATTR_ORIGIN;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH)))\n\t\ttype = BGP_ATTR_AS_PATH;\n\n\t/* RFC 2858 makes Next-Hop optional/ignored, if MP_REACH_NLRI is present\n\t * and\n\t * NLRI is empty. We can't easily check NLRI empty here though.\n\t */\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)))\n\t\ttype = BGP_ATTR_NEXT_HOP;\n\n\tif (peer->sort == BGP_PEER_IBGP\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)))\n\t\ttype = BGP_ATTR_LOCAL_PREF;\n\n\tif (type) {\n\t\tflog_warn(EC_BGP_MISSING_ATTRIBUTE,\n\t\t\t  \"%s Missing well-known attribute %s.\", peer->host,\n\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\tbgp_notify_send_with_data(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t  BGP_NOTIFY_UPDATE_MISS_ATTR, &type,\n\t\t\t\t\t  1);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\n/* Read attribute of update packet.  This function is called from\n   bgp_update_receive() in bgp_packet.c.  */\nbgp_attr_parse_ret_t bgp_attr_parse(struct peer *peer, struct attr *attr,\n\t\t\t\t    bgp_size_t size, struct bgp_nlri *mp_update,\n\t\t\t\t    struct bgp_nlri *mp_withdraw)\n{\n\tbgp_attr_parse_ret_t ret;\n\tuint8_t flag = 0;\n\tuint8_t type = 0;\n\tbgp_size_t length;\n\tuint8_t *startp, *endp;\n\tuint8_t *attr_endp;\n\tuint8_t seen[BGP_ATTR_BITMAP_SIZE];\n\t/* we need the as4_path only until we have synthesized the as_path with\n\t * it */\n\t/* same goes for as4_aggregator */\n\tstruct aspath *as4_path = NULL;\n\tas_t as4_aggregator = 0;\n\tstruct in_addr as4_aggregator_addr = {.s_addr = 0};\n\n\t/* Initialize bitmap. */\n\tmemset(seen, 0, BGP_ATTR_BITMAP_SIZE);\n\n\t/* End pointer of BGP attribute. */\n\tendp = BGP_INPUT_PNT(peer) + size;\n\n\t/* Get attributes to the end of attribute length. */\n\twhile (BGP_INPUT_PNT(peer) < endp) {\n\t\t/* Check remaining length check.*/\n\t\tif (endp - BGP_INPUT_PNT(peer) < BGP_ATTR_MIN_LEN) {\n\t\t\t/* XXX warning: long int format, int arg (arg 5) */\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_TOO_SMALL,\n\t\t\t\t\"%s: error BGP attribute length %lu is smaller than min len\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(endp\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\n\t\t/* Fetch attribute flag and type. */\n\t\tstartp = BGP_INPUT_PNT(peer);\n\t\t/* \"The lower-order four bits of the Attribute Flags octet are\n\t\t   unused.  They MUST be zero when sent and MUST be ignored when\n\t\t   received.\" */\n\t\tflag = 0xF0 & stream_getc(BGP_INPUT(peer));\n\t\ttype = stream_getc(BGP_INPUT(peer));\n\n\t\t/* Check whether Extended-Length applies and is in bounds */\n\t\tif (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN)\n\t\t    && ((endp - startp) < (BGP_ATTR_MIN_LEN + 1))) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_EXT_ATTRIBUTE_TOO_SMALL,\n\t\t\t\t\"%s: Extended length set, but just %lu bytes of attr header\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(endp\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\n\t\t/* Check extended attribue length bit. */\n\t\tif (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN))\n\t\t\tlength = stream_getw(BGP_INPUT(peer));\n\t\telse\n\t\t\tlength = stream_getc(BGP_INPUT(peer));\n\n\t\t/* If any attribute appears more than once in the UPDATE\n\t\t   message, then the Error Subcode is set to Malformed Attribute\n\t\t   List. */\n\n\t\tif (CHECK_BITMAP(seen, type)) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_REPEATED,\n\t\t\t\t\"%s: error BGP attribute type %d appears twice in a message\",\n\t\t\t\tpeer->host, type);\n\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\n\t\t/* Set type to bitmap to check duplicate attribute.  `type' is\n\t\t   unsigned char so it never overflow bitmap range. */\n\n\t\tSET_BITMAP(seen, type);\n\n\t\t/* Overflow check. */\n\t\tattr_endp = BGP_INPUT_PNT(peer) + length;\n\n\t\tif (attr_endp > endp) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_TOO_LARGE,\n\t\t\t\t\"%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p\",\n\t\t\t\tpeer->host, type, length, size, attr_endp,\n\t\t\t\tendp);\n\t\t\t/*\n\t\t\t * RFC 4271 6.3\n\t\t\t * If any recognized attribute has an Attribute\n\t\t\t * Length that conflicts with the expected length\n\t\t\t * (based on the attribute type code), then the\n\t\t\t * Error Subcode MUST be set to Attribute Length\n\t\t\t * Error.  The Data field MUST contain the erroneous\n\t\t\t * attribute (type, length, and value).\n\t\t\t * ----------\n\t\t\t * We do not currently have a good way to determine the\n\t\t\t * length of the attribute independent of the length\n\t\t\t * received in the message. Instead we send the\n\t\t\t * minimum between the amount of data we have and the\n\t\t\t * amount specified by the attribute length field.\n\t\t\t *\n\t\t\t * Instead of directly passing in the packet buffer and\n\t\t\t * offset we use the stream_get* functions to read into\n\t\t\t * a stack buffer, since they perform bounds checking\n\t\t\t * and we are working with untrusted data.\n\t\t\t */\n\t\t\tunsigned char ndata[BGP_MAX_PACKET_SIZE];\n\t\t\tmemset(ndata, 0x00, sizeof(ndata));\n\t\t\tsize_t lfl =\n\t\t\t\tCHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN) ? 2 : 1;\n\t\t\t/* Rewind to end of flag field */\n\t\t\tstream_forward_getp(BGP_INPUT(peer), -(1 + lfl));\n\t\t\t/* Type */\n\t\t\tstream_get(&ndata[0], BGP_INPUT(peer), 1);\n\t\t\t/* Length */\n\t\t\tstream_get(&ndata[1], BGP_INPUT(peer), lfl);\n\t\t\t/* Value */\n\t\t\tsize_t atl = attr_endp - startp;\n\t\t\tsize_t ndl = MIN(atl, STREAM_READABLE(BGP_INPUT(peer)));\n\t\t\tstream_get(&ndata[lfl + 1], BGP_INPUT(peer), ndl);\n\n\t\t\tbgp_notify_send_with_data(\n\t\t\t\tpeer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR, ndata,\n\t\t\t\tndl + lfl + 1);\n\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\n\t\tstruct bgp_attr_parser_args attr_args = {\n\t\t\t.peer = peer,\n\t\t\t.length = length,\n\t\t\t.attr = attr,\n\t\t\t.type = type,\n\t\t\t.flags = flag,\n\t\t\t.startp = startp,\n\t\t\t.total = attr_endp - startp,\n\t\t};\n\n\n\t\t/* If any recognized attribute has Attribute Flags that conflict\n\t\t   with the Attribute Type Code, then the Error Subcode is set\n\t\t   to\n\t\t   Attribute Flags Error.  The Data field contains the erroneous\n\t\t   attribute (type, length and value). */\n\t\tif (bgp_attr_flag_invalid(&attr_args)) {\n\t\t\tret = bgp_attr_malformed(\n\t\t\t\t&attr_args, BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,\n\t\t\t\tattr_args.total);\n\t\t\tif (ret == BGP_ATTR_PARSE_PROCEED)\n\t\t\t\tcontinue;\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* OK check attribute and store it's value. */\n\t\tswitch (type) {\n\t\tcase BGP_ATTR_ORIGIN:\n\t\t\tret = bgp_attr_origin(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS_PATH:\n\t\t\tret = bgp_attr_aspath(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS4_PATH:\n\t\t\tret = bgp_attr_as4_path(&attr_args, &as4_path);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_NEXT_HOP:\n\t\t\tret = bgp_attr_nexthop(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MULTI_EXIT_DISC:\n\t\t\tret = bgp_attr_med(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_LOCAL_PREF:\n\t\t\tret = bgp_attr_local_pref(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_ATOMIC_AGGREGATE:\n\t\t\tret = bgp_attr_atomic(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AGGREGATOR:\n\t\t\tret = bgp_attr_aggregator(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS4_AGGREGATOR:\n\t\t\tret = bgp_attr_as4_aggregator(&attr_args,\n\t\t\t\t\t\t      &as4_aggregator,\n\t\t\t\t\t\t      &as4_aggregator_addr);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_COMMUNITIES:\n\t\t\tret = bgp_attr_community(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_LARGE_COMMUNITIES:\n\t\t\tret = bgp_attr_large_community(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_ORIGINATOR_ID:\n\t\t\tret = bgp_attr_originator_id(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_CLUSTER_LIST:\n\t\t\tret = bgp_attr_cluster_list(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MP_REACH_NLRI:\n\t\t\tret = bgp_mp_reach_parse(&attr_args, mp_update);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MP_UNREACH_NLRI:\n\t\t\tret = bgp_mp_unreach_parse(&attr_args, mp_withdraw);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_EXT_COMMUNITIES:\n\t\t\tret = bgp_attr_ext_communities(&attr_args);\n\t\t\tbreak;\n#if ENABLE_BGP_VNC_ATTR\n\t\tcase BGP_ATTR_VNC:\n#endif\n\t\tcase BGP_ATTR_ENCAP:\n\t\t\tret = bgp_attr_encap(type, peer, length, attr, flag,\n\t\t\t\t\t     startp);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_PREFIX_SID:\n\t\t\tret = bgp_attr_prefix_sid(length,\n\t\t\t\t\t\t  &attr_args, mp_update);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_PMSI_TUNNEL:\n\t\t\tret = bgp_attr_pmsi_tunnel(&attr_args);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = bgp_attr_unknown(&attr_args);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret == BGP_ATTR_PARSE_ERROR_NOTIFYPLS) {\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t}\n\n\t\tif (ret == BGP_ATTR_PARSE_EOR) {\n\t\t\tif (as4_path)\n\t\t\t\taspath_unintern(&as4_path);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If hard error occurred immediately return to the caller. */\n\t\tif (ret == BGP_ATTR_PARSE_ERROR) {\n\t\t\tflog_warn(EC_BGP_ATTRIBUTE_PARSE_ERROR,\n\t\t\t\t  \"%s: Attribute %s, parse error\", peer->host,\n\t\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\t\tif (as4_path)\n\t\t\t\taspath_unintern(&as4_path);\n\t\t\treturn ret;\n\t\t}\n\t\tif (ret == BGP_ATTR_PARSE_WITHDRAW) {\n\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_PARSE_WITHDRAW,\n\t\t\t\t\"%s: Attribute %s, parse error - treating as withdrawal\",\n\t\t\t\tpeer->host, lookup_msg(attr_str, type, NULL));\n\t\t\tif (as4_path)\n\t\t\t\taspath_unintern(&as4_path);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* Check the fetched length. */\n\t\tif (BGP_INPUT_PNT(peer) != attr_endp) {\n\t\t\tflog_warn(EC_BGP_ATTRIBUTE_FETCH_ERROR,\n\t\t\t\t  \"%s: BGP attribute %s, fetch error\",\n\t\t\t\t  peer->host, lookup_msg(attr_str, type, NULL));\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\tif (as4_path)\n\t\t\t\taspath_unintern(&as4_path);\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\t}\n\n\t/* Check final read pointer is same as end pointer. */\n\tif (BGP_INPUT_PNT(peer) != endp) {\n\t\tflog_warn(EC_BGP_ATTRIBUTES_MISMATCH,\n\t\t\t  \"%s: BGP attribute %s, length mismatch\", peer->host,\n\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\tif (as4_path)\n\t\t\taspath_unintern(&as4_path);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\t/* Check all mandatory well-known attributes are present */\n\tif ((ret = bgp_attr_check(peer, attr)) < 0) {\n\t\tif (as4_path)\n\t\t\taspath_unintern(&as4_path);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * At this place we can see whether we got AS4_PATH and/or\n\t * AS4_AGGREGATOR from a 16Bit peer and act accordingly.\n\t * We can not do this before we've read all attributes because\n\t * the as4 handling does not say whether AS4_PATH has to be sent\n\t * after AS_PATH or not - and when AS4_AGGREGATOR will be send\n\t * in relationship to AGGREGATOR.\n\t * So, to be defensive, we are not relying on any order and read\n\t * all attributes first, including these 32bit ones, and now,\n\t * afterwards, we look what and if something is to be done for as4.\n\t *\n\t * It is possible to not have AS_PATH, e.g. GR EoR and sole\n\t * MP_UNREACH_NLRI.\n\t */\n\t/* actually... this doesn't ever return failure currently, but\n\t * better safe than sorry */\n\tif (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))\n\t    && bgp_attr_munge_as4_attrs(peer, attr, as4_path, as4_aggregator,\n\t\t\t\t\t&as4_aggregator_addr)) {\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\tif (as4_path)\n\t\t\taspath_unintern(&as4_path);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\t/* At this stage, we have done all fiddling with as4, and the\n\t * resulting info is in attr->aggregator resp. attr->aspath\n\t * so we can chuck as4_aggregator and as4_path alltogether in\n\t * order to save memory\n\t */\n\tif (as4_path) {\n\t\taspath_unintern(&as4_path); /* unintern - it is in the hash */\n\t\t/* The flag that we got this is still there, but that does not\n\t\t * do any trouble\n\t\t */\n\t}\n\t/*\n\t * The \"rest\" of the code does nothing with as4_aggregator.\n\t * there is no memory attached specifically which is not part\n\t * of the attr.\n\t * so ignoring just means do nothing.\n\t */\n\t/*\n\t * Finally do the checks on the aspath we did not do yet\n\t * because we waited for a potentially synthesized aspath.\n\t */\n\tif (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))) {\n\t\tret = bgp_attr_aspath_check(peer, attr);\n\t\tif (ret != BGP_ATTR_PARSE_PROCEED)\n\t\t\treturn ret;\n\t}\n\t/* Finally intern unknown attribute. */\n\tif (attr->transit)\n\t\tattr->transit = transit_intern(attr->transit);\n\tif (attr->encap_subtlvs)\n\t\tattr->encap_subtlvs =\n\t\t\tencap_intern(attr->encap_subtlvs, ENCAP_SUBTLV_TYPE);\n#if ENABLE_BGP_VNC\n\tif (attr->vnc_subtlvs)\n\t\tattr->vnc_subtlvs =\n\t\t\tencap_intern(attr->vnc_subtlvs, VNC_SUBTLV_TYPE);\n#endif\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n\nsize_t bgp_packet_mpattr_start(struct stream *s, struct peer *peer, afi_t afi,\n\t\t\t       safi_t safi, struct bpacket_attr_vec_arr *vecarr,\n\t\t\t       struct attr *attr)\n{\n\tsize_t sizep;\n\tiana_afi_t pkt_afi;\n\tiana_safi_t pkt_safi;\n\tafi_t nh_afi;\n\n\t/* Set extended bit always to encode the attribute length as 2 bytes */\n\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN);\n\tstream_putc(s, BGP_ATTR_MP_REACH_NLRI);\n\tsizep = stream_get_endp(s);\n\tstream_putw(s, 0); /* Marker: Attribute length. */\n\n\n\t/* Convert AFI, SAFI to values for packet. */\n\tbgp_map_afi_safi_int2iana(afi, safi, &pkt_afi, &pkt_safi);\n\n\tstream_putw(s, pkt_afi);  /* AFI */\n\tstream_putc(s, pkt_safi); /* SAFI */\n\n\t/* Nexthop AFI */\n\tif (afi == AFI_IP\n\t    && (safi == SAFI_UNICAST || safi == SAFI_LABELED_UNICAST))\n\t\tnh_afi = peer_cap_enhe(peer, afi, safi) ? AFI_IP6 : AFI_IP;\n\telse\n\t\tnh_afi = BGP_NEXTHOP_AFI_FROM_NHLEN(attr->mp_nexthop_len);\n\n\t/* Nexthop */\n\tbpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s, attr);\n\tswitch (nh_afi) {\n\tcase AFI_IP:\n\t\tswitch (safi) {\n\t\tcase SAFI_UNICAST:\n\t\tcase SAFI_MULTICAST:\n\t\tcase SAFI_LABELED_UNICAST:\n\t\t\tstream_putc(s, 4);\n\t\t\tstream_put_ipv4(s, attr->nexthop.s_addr);\n\t\t\tbreak;\n\t\tcase SAFI_MPLS_VPN:\n\t\t\tstream_putc(s, 12);\n\t\t\tstream_putl(s, 0); /* RD = 0, per RFC */\n\t\t\tstream_putl(s, 0);\n\t\t\tstream_put(s, &attr->mp_nexthop_global_in, 4);\n\t\t\tbreak;\n\t\tcase SAFI_ENCAP:\n\t\tcase SAFI_EVPN:\n\t\t\tstream_putc(s, 4);\n\t\t\tstream_put(s, &attr->mp_nexthop_global_in, 4);\n\t\t\tbreak;\n\t\tcase SAFI_FLOWSPEC:\n\t\t\tstream_putc(s, 0); /* no nexthop for flowspec */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AFI_IP6:\n\t\tswitch (safi) {\n\t\tcase SAFI_UNICAST:\n\t\tcase SAFI_MULTICAST:\n\t\tcase SAFI_LABELED_UNICAST:\n\t\tcase SAFI_EVPN: {\n\t\t\tif (attr->mp_nexthop_len\n\t\t\t    == BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL) {\n\t\t\t\tstream_putc(s,\n\t\t\t\t\t    BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL);\n\t\t\t\tstream_put(s, &attr->mp_nexthop_global,\n\t\t\t\t\t   IPV6_MAX_BYTELEN);\n\t\t\t\tstream_put(s, &attr->mp_nexthop_local,\n\t\t\t\t\t   IPV6_MAX_BYTELEN);\n\t\t\t} else {\n\t\t\t\tstream_putc(s, IPV6_MAX_BYTELEN);\n\t\t\t\tstream_put(s, &attr->mp_nexthop_global,\n\t\t\t\t\t   IPV6_MAX_BYTELEN);\n\t\t\t}\n\t\t} break;\n\t\tcase SAFI_MPLS_VPN: {\n\t\t\tif (attr->mp_nexthop_len\n\t\t\t    == BGP_ATTR_NHLEN_IPV6_GLOBAL) {\n\t\t\t\tstream_putc(s, 24);\n\t\t\t\tstream_putl(s, 0); /* RD = 0, per RFC */\n\t\t\t\tstream_putl(s, 0);\n\t\t\t\tstream_put(s, &attr->mp_nexthop_global,\n\t\t\t\t\t   IPV6_MAX_BYTELEN);\n\t\t\t} else if (attr->mp_nexthop_len\n\t\t\t\t   == BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL) {\n\t\t\t\tstream_putc(s, 48);\n\t\t\t\tstream_putl(s, 0); /* RD = 0, per RFC */\n\t\t\t\tstream_putl(s, 0);\n\t\t\t\tstream_put(s, &attr->mp_nexthop_global,\n\t\t\t\t\t   IPV6_MAX_BYTELEN);\n\t\t\t\tstream_putl(s, 0); /* RD = 0, per RFC */\n\t\t\t\tstream_putl(s, 0);\n\t\t\t\tstream_put(s, &attr->mp_nexthop_local,\n\t\t\t\t\t   IPV6_MAX_BYTELEN);\n\t\t\t}\n\t\t} break;\n\t\tcase SAFI_ENCAP:\n\t\t\tstream_putc(s, IPV6_MAX_BYTELEN);\n\t\t\tstream_put(s, &attr->mp_nexthop_global,\n\t\t\t\t   IPV6_MAX_BYTELEN);\n\t\t\tbreak;\n\t\tcase SAFI_FLOWSPEC:\n\t\t\tstream_putc(s, 0); /* no nexthop for flowspec */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (safi != SAFI_FLOWSPEC)\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_ATTR_NH_SEND_LEN,\n\t\t\t\t\"Bad nexthop when sending to %s, AFI %u SAFI %u nhlen %d\",\n\t\t\t\tpeer->host, afi, safi, attr->mp_nexthop_len);\n\t\tbreak;\n\t}\n\n\t/* SNPA */\n\tstream_putc(s, 0);\n\treturn sizep;\n}\n\nvoid bgp_packet_mpattr_prefix(struct stream *s, afi_t afi, safi_t safi,\n\t\t\t      struct prefix *p, struct prefix_rd *prd,\n\t\t\t      mpls_label_t *label, uint32_t num_labels,\n\t\t\t      int addpath_encode, uint32_t addpath_tx_id,\n\t\t\t      struct attr *attr)\n{\n\tif (safi == SAFI_MPLS_VPN) {\n\t\tif (addpath_encode)\n\t\t\tstream_putl(s, addpath_tx_id);\n\t\t/* Label, RD, Prefix write. */\n\t\tstream_putc(s, p->prefixlen + 88);\n\t\tstream_put(s, label, BGP_LABEL_BYTES);\n\t\tstream_put(s, prd->val, 8);\n\t\tstream_put(s, &p->u.prefix, PSIZE(p->prefixlen));\n\t} else if (afi == AFI_L2VPN && safi == SAFI_EVPN) {\n\t\t/* EVPN prefix - contents depend on type */\n\t\tbgp_evpn_encode_prefix(s, p, prd, label, num_labels, attr,\n\t\t\t\t       addpath_encode, addpath_tx_id);\n\t} else if (safi == SAFI_LABELED_UNICAST) {\n\t\t/* Prefix write with label. */\n\t\tstream_put_labeled_prefix(s, p, label);\n\t} else if (safi == SAFI_FLOWSPEC) {\n\t\tif (PSIZE (p->prefixlen)+2 < FLOWSPEC_NLRI_SIZELIMIT)\n\t\t\tstream_putc(s, PSIZE (p->prefixlen)+2);\n\t\telse\n\t\t\tstream_putw(s, (PSIZE (p->prefixlen)+2)|(0xf<<12));\n\t\tstream_putc(s, 2);/* Filter type */\n\t\tstream_putc(s, p->prefixlen);/* Prefix length */\n\t\tstream_put(s, &p->u.prefix, PSIZE (p->prefixlen));\n\t} else\n\t\tstream_put_prefix_addpath(s, p, addpath_encode, addpath_tx_id);\n}\n\nsize_t bgp_packet_mpattr_prefix_size(afi_t afi, safi_t safi, struct prefix *p)\n{\n\tint size = PSIZE(p->prefixlen);\n\tif (safi == SAFI_MPLS_VPN)\n\t\tsize += 88;\n\telse if (afi == AFI_L2VPN && safi == SAFI_EVPN)\n\t\tsize += 232; // TODO: Maximum possible for type-2, type-3 and\n\t\t\t     // type-5\n\treturn size;\n}\n\n/*\n * Encodes the tunnel encapsulation attribute,\n * and with ENABLE_BGP_VNC the VNC attribute which uses\n * almost the same TLV format\n */\nstatic void bgp_packet_mpattr_tea(struct bgp *bgp, struct peer *peer,\n\t\t\t\t  struct stream *s, struct attr *attr,\n\t\t\t\t  uint8_t attrtype)\n{\n\tunsigned int attrlenfield = 0;\n\tunsigned int attrhdrlen = 0;\n\tstruct bgp_attr_encap_subtlv *subtlvs;\n\tstruct bgp_attr_encap_subtlv *st;\n\tconst char *attrname;\n\n\tif (!attr || (attrtype == BGP_ATTR_ENCAP\n\t\t      && (!attr->encap_tunneltype\n\t\t\t  || attr->encap_tunneltype == BGP_ENCAP_TYPE_MPLS)))\n\t\treturn;\n\n\tswitch (attrtype) {\n\tcase BGP_ATTR_ENCAP:\n\t\tattrname = \"Tunnel Encap\";\n\t\tsubtlvs = attr->encap_subtlvs;\n\t\tif (subtlvs == NULL) /* nothing to do */\n\t\t\treturn;\n\t\t/*\n\t\t * The tunnel encap attr has an \"outer\" tlv.\n\t\t * T = tunneltype,\n\t\t * L = total length of subtlvs,\n\t\t * V = concatenated subtlvs.\n\t\t */\n\t\tattrlenfield = 2 + 2; /* T + L */\n\t\tattrhdrlen = 1 + 1;   /* subTLV T + L */\n\t\tbreak;\n\n#if ENABLE_BGP_VNC_ATTR\n\tcase BGP_ATTR_VNC:\n\t\tattrname = \"VNC\";\n\t\tsubtlvs = attr->vnc_subtlvs;\n\t\tif (subtlvs == NULL) /* nothing to do */\n\t\t\treturn;\n\t\tattrlenfield = 0;   /* no outer T + L */\n\t\tattrhdrlen = 2 + 2; /* subTLV T + L */\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tassert(0);\n\t}\n\n\t/* compute attr length */\n\tfor (st = subtlvs; st; st = st->next) {\n\t\tattrlenfield += (attrhdrlen + st->length);\n\t}\n\n\tif (attrlenfield > 0xffff) {\n\t\tzlog_info(\"%s attribute is too long (length=%d), can't send it\",\n\t\t\t  attrname, attrlenfield);\n\t\treturn;\n\t}\n\n\tif (attrlenfield > 0xff) {\n\t\t/* 2-octet length field */\n\t\tstream_putc(s,\n\t\t\t    BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\tstream_putc(s, attrtype);\n\t\tstream_putw(s, attrlenfield & 0xffff);\n\t} else {\n\t\t/* 1-octet length field */\n\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL);\n\t\tstream_putc(s, attrtype);\n\t\tstream_putc(s, attrlenfield & 0xff);\n\t}\n\n\tif (attrtype == BGP_ATTR_ENCAP) {\n\t\t/* write outer T+L */\n\t\tstream_putw(s, attr->encap_tunneltype);\n\t\tstream_putw(s, attrlenfield - 4);\n\t}\n\n\t/* write each sub-tlv */\n\tfor (st = subtlvs; st; st = st->next) {\n\t\tif (attrtype == BGP_ATTR_ENCAP) {\n\t\t\tstream_putc(s, st->type);\n\t\t\tstream_putc(s, st->length);\n#if ENABLE_BGP_VNC\n\t\t} else {\n\t\t\tstream_putw(s, st->type);\n\t\t\tstream_putw(s, st->length);\n#endif\n\t\t}\n\t\tstream_put(s, st->value, st->length);\n\t}\n}\n\nvoid bgp_packet_mpattr_end(struct stream *s, size_t sizep)\n{\n\t/* Set MP attribute length. Don't count the (2) bytes used to encode\n\t   the attr length */\n\tstream_putw_at(s, sizep, (stream_get_endp(s) - sizep) - 2);\n}\n\n/* Make attribute packet. */\nbgp_size_t bgp_packet_attribute(struct bgp *bgp, struct peer *peer,\n\t\t\t\tstruct stream *s, struct attr *attr,\n\t\t\t\tstruct bpacket_attr_vec_arr *vecarr,\n\t\t\t\tstruct prefix *p, afi_t afi, safi_t safi,\n\t\t\t\tstruct peer *from, struct prefix_rd *prd,\n\t\t\t\tmpls_label_t *label, uint32_t num_labels,\n\t\t\t\tint addpath_encode, uint32_t addpath_tx_id)\n{\n\tsize_t cp;\n\tsize_t aspath_sizep;\n\tstruct aspath *aspath;\n\tint send_as4_path = 0;\n\tint send_as4_aggregator = 0;\n\tint use32bit = (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV)) ? 1 : 0;\n\n\tif (!bgp)\n\t\tbgp = peer->bgp;\n\n\t/* Remember current pointer. */\n\tcp = stream_get_endp(s);\n\n\tif (p\n\t    && !((afi == AFI_IP && safi == SAFI_UNICAST)\n\t\t && !peer_cap_enhe(peer, afi, safi))) {\n\t\tsize_t mpattrlen_pos = 0;\n\n\t\tmpattrlen_pos = bgp_packet_mpattr_start(s, peer, afi, safi,\n\t\t\t\t\t\t\tvecarr, attr);\n\t\tbgp_packet_mpattr_prefix(s, afi, safi, p, prd, label,\n\t\t\t\t\t num_labels, addpath_encode,\n\t\t\t\t\t addpath_tx_id, attr);\n\t\tbgp_packet_mpattr_end(s, mpattrlen_pos);\n\t}\n\n\t/* Origin attribute. */\n\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\tstream_putc(s, BGP_ATTR_ORIGIN);\n\tstream_putc(s, 1);\n\tstream_putc(s, attr->origin);\n\n\t/* AS path attribute. */\n\n\t/* If remote-peer is EBGP */\n\tif (peer->sort == BGP_PEER_EBGP\n\t    && (!CHECK_FLAG(peer->af_flags[afi][safi],\n\t\t\t    PEER_FLAG_AS_PATH_UNCHANGED)\n\t\t|| attr->aspath->segments == NULL)\n\t    && (!CHECK_FLAG(peer->af_flags[afi][safi],\n\t\t\t    PEER_FLAG_RSERVER_CLIENT))) {\n\t\taspath = aspath_dup(attr->aspath);\n\n\t\t/* Even though we may not be configured for confederations we\n\t\t * may have\n\t\t * RXed an AS_PATH with AS_CONFED_SEQUENCE or AS_CONFED_SET */\n\t\taspath = aspath_delete_confed_seq(aspath);\n\n\t\tif (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)) {\n\t\t\t/* Stuff our path CONFED_ID on the front */\n\t\t\taspath = aspath_add_seq(aspath, bgp->confed_id);\n\t\t} else {\n\t\t\tif (peer->change_local_as) {\n\t\t\t\t/* If replace-as is specified, we only use the\n\t\t\t\t   change_local_as when\n\t\t\t\t   advertising routes. */\n\t\t\t\tif (!CHECK_FLAG(\n\t\t\t\t\t    peer->flags,\n\t\t\t\t\t    PEER_FLAG_LOCAL_AS_REPLACE_AS)) {\n\t\t\t\t\taspath = aspath_add_seq(aspath,\n\t\t\t\t\t\t\t\tpeer->local_as);\n\t\t\t\t}\n\t\t\t\taspath = aspath_add_seq(aspath,\n\t\t\t\t\t\t\tpeer->change_local_as);\n\t\t\t} else {\n\t\t\t\taspath = aspath_add_seq(aspath, peer->local_as);\n\t\t\t}\n\t\t}\n\t} else if (peer->sort == BGP_PEER_CONFED) {\n\t\t/* A confed member, so we need to do the AS_CONFED_SEQUENCE\n\t\t * thing */\n\t\taspath = aspath_dup(attr->aspath);\n\t\taspath = aspath_add_confed_seq(aspath, peer->local_as);\n\t} else\n\t\taspath = attr->aspath;\n\n\t/* If peer is not AS4 capable, then:\n\t * - send the created AS_PATH out as AS4_PATH (optional, transitive),\n\t *   but ensure that no AS_CONFED_SEQUENCE and AS_CONFED_SET path\n\t * segment\n\t *   types are in it (i.e. exclude them if they are there)\n\t *   AND do this only if there is at least one asnum > 65535 in the\n\t * path!\n\t * - send an AS_PATH out, but put 16Bit ASnums in it, not 32bit, and\n\t * change\n\t *   all ASnums > 65535 to BGP_AS_TRANS\n\t */\n\n\tstream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN);\n\tstream_putc(s, BGP_ATTR_AS_PATH);\n\taspath_sizep = stream_get_endp(s);\n\tstream_putw(s, 0);\n\tstream_putw_at(s, aspath_sizep, aspath_put(s, aspath, use32bit));\n\n\t/* OLD session may need NEW_AS_PATH sent, if there are 4-byte ASNs\n\t * in the path\n\t */\n\tif (!use32bit && aspath_has_as4(aspath))\n\t\tsend_as4_path =\n\t\t\t1; /* we'll do this later, at the correct place */\n\n\t/* Nexthop attribute. */\n\tif (afi == AFI_IP && safi == SAFI_UNICAST\n\t    && !peer_cap_enhe(peer, afi, safi)) {\n\t\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP)) {\n\t\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\t\t\tstream_putc(s, BGP_ATTR_NEXT_HOP);\n\t\t\tbpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s,\n\t\t\t\t\t\t     attr);\n\t\t\tstream_putc(s, 4);\n\t\t\tstream_put_ipv4(s, attr->nexthop.s_addr);\n\t\t} else if (peer_cap_enhe(from, afi, safi)) {\n\t\t\t/*\n\t\t\t * Likely this is the case when an IPv4 prefix was\n\t\t\t * received with\n\t\t\t * Extended Next-hop capability and now being advertised\n\t\t\t * to\n\t\t\t * non-ENHE peers.\n\t\t\t * Setting the mandatory (ipv4) next-hop attribute here\n\t\t\t * to enable\n\t\t\t * implicit next-hop self with correct (ipv4 address\n\t\t\t * family).\n\t\t\t */\n\t\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\t\t\tstream_putc(s, BGP_ATTR_NEXT_HOP);\n\t\t\tbpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s,\n\t\t\t\t\t\t     NULL);\n\t\t\tstream_putc(s, 4);\n\t\t\tstream_put_ipv4(s, 0);\n\t\t}\n\t}\n\n\t/* MED attribute. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC)\n\t    || bgp->maxmed_active) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL);\n\t\tstream_putc(s, BGP_ATTR_MULTI_EXIT_DISC);\n\t\tstream_putc(s, 4);\n\t\tstream_putl(s, (bgp->maxmed_active ? bgp->maxmed_value\n\t\t\t\t\t\t   : attr->med));\n\t}\n\n\t/* Local preference. */\n\tif (peer->sort == BGP_PEER_IBGP || peer->sort == BGP_PEER_CONFED) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_LOCAL_PREF);\n\t\tstream_putc(s, 4);\n\t\tstream_putl(s, attr->local_pref);\n\t}\n\n\t/* Atomic aggregate. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE)) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_ATOMIC_AGGREGATE);\n\t\tstream_putc(s, 0);\n\t}\n\n\t/* Aggregator. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR)) {\n\t\t/* Common to BGP_ATTR_AGGREGATOR, regardless of ASN size */\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_AGGREGATOR);\n\n\t\tif (use32bit) {\n\t\t\t/* AS4 capable peer */\n\t\t\tstream_putc(s, 8);\n\t\t\tstream_putl(s, attr->aggregator_as);\n\t\t} else {\n\t\t\t/* 2-byte AS peer */\n\t\t\tstream_putc(s, 6);\n\n\t\t\t/* Is ASN representable in 2-bytes? Or must AS_TRANS be\n\t\t\t * used? */\n\t\t\tif (attr->aggregator_as > 65535) {\n\t\t\t\tstream_putw(s, BGP_AS_TRANS);\n\n\t\t\t\t/* we have to send AS4_AGGREGATOR, too.\n\t\t\t\t * we'll do that later in order to send\n\t\t\t\t * attributes in ascending\n\t\t\t\t * order.\n\t\t\t\t */\n\t\t\t\tsend_as4_aggregator = 1;\n\t\t\t} else\n\t\t\t\tstream_putw(s, (uint16_t)attr->aggregator_as);\n\t\t}\n\t\tstream_put_ipv4(s, attr->aggregator_addr.s_addr);\n\t}\n\n\t/* Community attribute. */\n\tif (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY)\n\t    && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES))) {\n\t\tif (attr->community->size * 4 > 255) {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS\n\t\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\t\tstream_putc(s, BGP_ATTR_COMMUNITIES);\n\t\t\tstream_putw(s, attr->community->size * 4);\n\t\t} else {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);\n\t\t\tstream_putc(s, BGP_ATTR_COMMUNITIES);\n\t\t\tstream_putc(s, attr->community->size * 4);\n\t\t}\n\t\tstream_put(s, attr->community->val, attr->community->size * 4);\n\t}\n\n\t/*\n\t * Large Community attribute.\n\t */\n\tif (CHECK_FLAG(peer->af_flags[afi][safi],\n\t\t       PEER_FLAG_SEND_LARGE_COMMUNITY)\n\t    && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES))) {\n\t\tif (lcom_length(attr->lcommunity) > 255) {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS\n\t\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\t\tstream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);\n\t\t\tstream_putw(s, lcom_length(attr->lcommunity));\n\t\t} else {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);\n\t\t\tstream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);\n\t\t\tstream_putc(s, lcom_length(attr->lcommunity));\n\t\t}\n\t\tstream_put(s, attr->lcommunity->val,\n\t\t\t   lcom_length(attr->lcommunity));\n\t}\n\n\t/* Route Reflector. */\n\tif (peer->sort == BGP_PEER_IBGP && from\n\t    && from->sort == BGP_PEER_IBGP) {\n\t\t/* Originator ID. */\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL);\n\t\tstream_putc(s, BGP_ATTR_ORIGINATOR_ID);\n\t\tstream_putc(s, 4);\n\n\t\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID))\n\t\t\tstream_put_in_addr(s, &attr->originator_id);\n\t\telse\n\t\t\tstream_put_in_addr(s, &from->remote_id);\n\n\t\t/* Cluster list. */\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL);\n\t\tstream_putc(s, BGP_ATTR_CLUSTER_LIST);\n\n\t\tif (attr->cluster) {\n\t\t\tstream_putc(s, attr->cluster->length + 4);\n\t\t\t/* If this peer configuration's parent BGP has\n\t\t\t * cluster_id. */\n\t\t\tif (bgp->config & BGP_CONFIG_CLUSTER_ID)\n\t\t\t\tstream_put_in_addr(s, &bgp->cluster_id);\n\t\t\telse\n\t\t\t\tstream_put_in_addr(s, &bgp->router_id);\n\t\t\tstream_put(s, attr->cluster->list,\n\t\t\t\t   attr->cluster->length);\n\t\t} else {\n\t\t\tstream_putc(s, 4);\n\t\t\t/* If this peer configuration's parent BGP has\n\t\t\t * cluster_id. */\n\t\t\tif (bgp->config & BGP_CONFIG_CLUSTER_ID)\n\t\t\t\tstream_put_in_addr(s, &bgp->cluster_id);\n\t\t\telse\n\t\t\t\tstream_put_in_addr(s, &bgp->router_id);\n\t\t}\n\t}\n\n\t/* Extended Communities attribute. */\n\tif (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY)\n\t    && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES))) {\n\t\tif (peer->sort == BGP_PEER_IBGP\n\t\t    || peer->sort == BGP_PEER_CONFED) {\n\t\t\tif (attr->ecommunity->size * 8 > 255) {\n\t\t\t\tstream_putc(s,\n\t\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS\n\t\t\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\t\t\tstream_putc(s, BGP_ATTR_EXT_COMMUNITIES);\n\t\t\t\tstream_putw(s, attr->ecommunity->size * 8);\n\t\t\t} else {\n\t\t\t\tstream_putc(s,\n\t\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);\n\t\t\t\tstream_putc(s, BGP_ATTR_EXT_COMMUNITIES);\n\t\t\t\tstream_putc(s, attr->ecommunity->size * 8);\n\t\t\t}\n\t\t\tstream_put(s, attr->ecommunity->val,\n\t\t\t\t   attr->ecommunity->size * 8);\n\t\t} else {\n\t\t\tuint8_t *pnt;\n\t\t\tint tbit;\n\t\t\tint ecom_tr_size = 0;\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < attr->ecommunity->size; i++) {\n\t\t\t\tpnt = attr->ecommunity->val + (i * 8);\n\t\t\t\ttbit = *pnt;\n\n\t\t\t\tif (CHECK_FLAG(tbit,\n\t\t\t\t\t       ECOMMUNITY_FLAG_NON_TRANSITIVE))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tecom_tr_size++;\n\t\t\t}\n\n\t\t\tif (ecom_tr_size) {\n\t\t\t\tif (ecom_tr_size * 8 > 255) {\n\t\t\t\t\tstream_putc(\n\t\t\t\t\t\ts,\n\t\t\t\t\t\tBGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t\t\t| BGP_ATTR_FLAG_TRANS\n\t\t\t\t\t\t\t| BGP_ATTR_FLAG_EXTLEN);\n\t\t\t\t\tstream_putc(s,\n\t\t\t\t\t\t    BGP_ATTR_EXT_COMMUNITIES);\n\t\t\t\t\tstream_putw(s, ecom_tr_size * 8);\n\t\t\t\t} else {\n\t\t\t\t\tstream_putc(\n\t\t\t\t\t\ts,\n\t\t\t\t\t\tBGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t\t\t| BGP_ATTR_FLAG_TRANS);\n\t\t\t\t\tstream_putc(s,\n\t\t\t\t\t\t    BGP_ATTR_EXT_COMMUNITIES);\n\t\t\t\t\tstream_putc(s, ecom_tr_size * 8);\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < attr->ecommunity->size; i++) {\n\t\t\t\t\tpnt = attr->ecommunity->val + (i * 8);\n\t\t\t\t\ttbit = *pnt;\n\n\t\t\t\t\tif (CHECK_FLAG(\n\t\t\t\t\t\t    tbit,\n\t\t\t\t\t\t    ECOMMUNITY_FLAG_NON_TRANSITIVE))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tstream_put(s, pnt, 8);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Label index attribute. */\n\tif (safi == SAFI_LABELED_UNICAST) {\n\t\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID)) {\n\t\t\tuint32_t label_index;\n\n\t\t\tlabel_index = attr->label_index;\n\n\t\t\tif (label_index != BGP_INVALID_LABEL_INDEX) {\n\t\t\t\tstream_putc(s,\n\t\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);\n\t\t\t\tstream_putc(s, BGP_ATTR_PREFIX_SID);\n\t\t\t\tstream_putc(s, 10);\n\t\t\t\tstream_putc(s, BGP_PREFIX_SID_LABEL_INDEX);\n\t\t\t\tstream_putw(s,\n\t\t\t\t\t    BGP_PREFIX_SID_LABEL_INDEX_LENGTH);\n\t\t\t\tstream_putc(s, 0); // reserved\n\t\t\t\tstream_putw(s, 0); // flags\n\t\t\t\tstream_putl(s, label_index);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (send_as4_path) {\n\t\t/* If the peer is NOT As4 capable, AND */\n\t\t/* there are ASnums > 65535 in path  THEN\n\t\t * give out AS4_PATH */\n\n\t\t/* Get rid of all AS_CONFED_SEQUENCE and AS_CONFED_SET\n\t\t * path segments!\n\t\t * Hm, I wonder...  confederation things *should* only be at\n\t\t * the beginning of an aspath, right?  Then we should use\n\t\t * aspath_delete_confed_seq for this, because it is already\n\t\t * there! (JK)\n\t\t * Folks, talk to me: what is reasonable here!?\n\t\t */\n\t\taspath = aspath_delete_confed_seq(aspath);\n\n\t\tstream_putc(s,\n\t\t\t    BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\tstream_putc(s, BGP_ATTR_AS4_PATH);\n\t\taspath_sizep = stream_get_endp(s);\n\t\tstream_putw(s, 0);\n\t\tstream_putw_at(s, aspath_sizep, aspath_put(s, aspath, 1));\n\t}\n\n\tif (aspath != attr->aspath)\n\t\taspath_free(aspath);\n\n\tif (send_as4_aggregator) {\n\t\t/* send AS4_AGGREGATOR, at this place */\n\t\t/* this section of code moved here in order to ensure the\n\t\t * correct\n\t\t * *ascending* order of attributes\n\t\t */\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_AS4_AGGREGATOR);\n\t\tstream_putc(s, 8);\n\t\tstream_putl(s, attr->aggregator_as);\n\t\tstream_put_ipv4(s, attr->aggregator_addr.s_addr);\n\t}\n\n\tif (((afi == AFI_IP || afi == AFI_IP6)\n\t     && (safi == SAFI_ENCAP || safi == SAFI_MPLS_VPN))\n\t    || (afi == AFI_L2VPN && safi == SAFI_EVPN)) {\n\t\t/* Tunnel Encap attribute */\n\t\tbgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_ENCAP);\n\n#if ENABLE_BGP_VNC_ATTR\n\t\t/* VNC attribute */\n\t\tbgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_VNC);\n#endif\n\t}\n\n\t/* PMSI Tunnel */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PMSI_TUNNEL)) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_PMSI_TUNNEL);\n\t\tstream_putc(s, 9); // Length\n\t\tstream_putc(s, 0); // Flags\n\t\tstream_putc(s, PMSI_TNLTYPE_INGR_REPL); // IR (6)\n\t\tstream_put(s, &(attr->label),\n\t\t\t   BGP_LABEL_BYTES); // MPLS Label / VXLAN VNI\n\t\tstream_put_ipv4(s, attr->nexthop.s_addr);\n\t\t// Unicast tunnel endpoint IP address\n\t}\n\n\t/* Unknown transit attribute. */\n\tif (attr->transit)\n\t\tstream_put(s, attr->transit->val, attr->transit->length);\n\n\t/* Return total size of attribute. */\n\treturn stream_get_endp(s) - cp;\n}\n\nsize_t bgp_packet_mpunreach_start(struct stream *s, afi_t afi, safi_t safi)\n{\n\tunsigned long attrlen_pnt;\n\tiana_afi_t pkt_afi;\n\tiana_safi_t pkt_safi;\n\n\t/* Set extended bit always to encode the attribute length as 2 bytes */\n\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN);\n\tstream_putc(s, BGP_ATTR_MP_UNREACH_NLRI);\n\n\tattrlen_pnt = stream_get_endp(s);\n\tstream_putw(s, 0); /* Length of this attribute. */\n\n\t/* Convert AFI, SAFI to values for packet. */\n\tbgp_map_afi_safi_int2iana(afi, safi, &pkt_afi, &pkt_safi);\n\n\tstream_putw(s, pkt_afi);\n\tstream_putc(s, pkt_safi);\n\n\treturn attrlen_pnt;\n}\n\nvoid bgp_packet_mpunreach_prefix(struct stream *s, struct prefix *p, afi_t afi,\n\t\t\t\t safi_t safi, struct prefix_rd *prd,\n\t\t\t\t mpls_label_t *label, uint32_t num_labels,\n\t\t\t\t int addpath_encode, uint32_t addpath_tx_id,\n\t\t\t\t struct attr *attr)\n{\n\tuint8_t wlabel[3] = {0x80, 0x00, 0x00};\n\n\tif (safi == SAFI_LABELED_UNICAST) {\n\t\tlabel = (mpls_label_t *)wlabel;\n\t\tnum_labels = 1;\n\t}\n\n\tbgp_packet_mpattr_prefix(s, afi, safi, p, prd, label, num_labels,\n\t\t\t\t addpath_encode, addpath_tx_id, attr);\n}\n\nvoid bgp_packet_mpunreach_end(struct stream *s, size_t attrlen_pnt)\n{\n\tbgp_packet_mpattr_end(s, attrlen_pnt);\n}\n\n/* Initialization of attribute. */\nvoid bgp_attr_init(void)\n{\n\taspath_init();\n\tattrhash_init();\n\tcommunity_init();\n\tecommunity_init();\n\tlcommunity_init();\n\tcluster_init();\n\ttransit_init();\n\tencap_init();\n}\n\nvoid bgp_attr_finish(void)\n{\n\taspath_finish();\n\tattrhash_finish();\n\tcommunity_finish();\n\tecommunity_finish();\n\tlcommunity_finish();\n\tcluster_finish();\n\ttransit_finish();\n\tencap_finish();\n}\n\n/* Make attribute packet. */\nvoid bgp_dump_routes_attr(struct stream *s, struct attr *attr,\n\t\t\t  struct prefix *prefix)\n{\n\tunsigned long cp;\n\tunsigned long len;\n\tsize_t aspath_lenp;\n\tstruct aspath *aspath;\n\tint addpath_encode = 0;\n\tuint32_t addpath_tx_id = 0;\n\n\t/* Remember current pointer. */\n\tcp = stream_get_endp(s);\n\n\t/* Place holder of length. */\n\tstream_putw(s, 0);\n\n\t/* Origin attribute. */\n\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\tstream_putc(s, BGP_ATTR_ORIGIN);\n\tstream_putc(s, 1);\n\tstream_putc(s, attr->origin);\n\n\taspath = attr->aspath;\n\n\tstream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN);\n\tstream_putc(s, BGP_ATTR_AS_PATH);\n\taspath_lenp = stream_get_endp(s);\n\tstream_putw(s, 0);\n\n\tstream_putw_at(s, aspath_lenp, aspath_put(s, aspath, 1));\n\n\t/* Nexthop attribute. */\n\t/* If it's an IPv6 prefix, don't dump the IPv4 nexthop to save space */\n\tif (prefix != NULL && prefix->family != AF_INET6) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_NEXT_HOP);\n\t\tstream_putc(s, 4);\n\t\tstream_put_ipv4(s, attr->nexthop.s_addr);\n\t}\n\n\t/* MED attribute. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC)) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL);\n\t\tstream_putc(s, BGP_ATTR_MULTI_EXIT_DISC);\n\t\tstream_putc(s, 4);\n\t\tstream_putl(s, attr->med);\n\t}\n\n\t/* Local preference. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_LOCAL_PREF);\n\t\tstream_putc(s, 4);\n\t\tstream_putl(s, attr->local_pref);\n\t}\n\n\t/* Atomic aggregate. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE)) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_ATOMIC_AGGREGATE);\n\t\tstream_putc(s, 0);\n\t}\n\n\t/* Aggregator. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR)) {\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);\n\t\tstream_putc(s, BGP_ATTR_AGGREGATOR);\n\t\tstream_putc(s, 8);\n\t\tstream_putl(s, attr->aggregator_as);\n\t\tstream_put_ipv4(s, attr->aggregator_addr.s_addr);\n\t}\n\n\t/* Community attribute. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES)) {\n\t\tif (attr->community->size * 4 > 255) {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS\n\t\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\t\tstream_putc(s, BGP_ATTR_COMMUNITIES);\n\t\t\tstream_putw(s, attr->community->size * 4);\n\t\t} else {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);\n\t\t\tstream_putc(s, BGP_ATTR_COMMUNITIES);\n\t\t\tstream_putc(s, attr->community->size * 4);\n\t\t}\n\t\tstream_put(s, attr->community->val, attr->community->size * 4);\n\t}\n\n\t/* Large Community attribute. */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES)) {\n\t\tif (lcom_length(attr->lcommunity) > 255) {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS\n\t\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\t\tstream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);\n\t\t\tstream_putw(s, lcom_length(attr->lcommunity));\n\t\t} else {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);\n\t\t\tstream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);\n\t\t\tstream_putc(s, lcom_length(attr->lcommunity));\n\t\t}\n\n\t\tstream_put(s, attr->lcommunity->val,\n\t\t\t   lcom_length(attr->lcommunity));\n\t}\n\n\t/* Add a MP_NLRI attribute to dump the IPv6 next hop */\n\tif (prefix != NULL && prefix->family == AF_INET6\n\t    && (attr->mp_nexthop_len == BGP_ATTR_NHLEN_IPV6_GLOBAL\n\t\t|| attr->mp_nexthop_len == BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL)) {\n\t\tint sizep;\n\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL);\n\t\tstream_putc(s, BGP_ATTR_MP_REACH_NLRI);\n\t\tsizep = stream_get_endp(s);\n\n\t\t/* MP header */\n\t\tstream_putc(s, 0);\t    /* Marker: Attribute length. */\n\t\tstream_putw(s, AFI_IP6);      /* AFI */\n\t\tstream_putc(s, SAFI_UNICAST); /* SAFI */\n\n\t\t/* Next hop */\n\t\tstream_putc(s, attr->mp_nexthop_len);\n\t\tstream_put(s, &attr->mp_nexthop_global, IPV6_MAX_BYTELEN);\n\t\tif (attr->mp_nexthop_len == BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL)\n\t\t\tstream_put(s, &attr->mp_nexthop_local,\n\t\t\t\t   IPV6_MAX_BYTELEN);\n\n\t\t/* SNPA */\n\t\tstream_putc(s, 0);\n\n\t\t/* Prefix */\n\t\tstream_put_prefix_addpath(s, prefix, addpath_encode,\n\t\t\t\t\t  addpath_tx_id);\n\n\t\t/* Set MP attribute length. */\n\t\tstream_putc_at(s, sizep, (stream_get_endp(s) - sizep) - 1);\n\t}\n\n\t/* Prefix SID */\n\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID)) {\n\t\tif (attr->label_index != BGP_INVALID_LABEL_INDEX) {\n\t\t\tstream_putc(s,\n\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);\n\t\t\tstream_putc(s, BGP_ATTR_PREFIX_SID);\n\t\t\tstream_putc(s, 10);\n\t\t\tstream_putc(s, BGP_PREFIX_SID_LABEL_INDEX);\n\t\t\tstream_putc(s, BGP_PREFIX_SID_LABEL_INDEX_LENGTH);\n\t\t\tstream_putc(s, 0); // reserved\n\t\t\tstream_putw(s, 0); // flags\n\t\t\tstream_putl(s, attr->label_index);\n\t\t}\n\t}\n\n\t/* Return total size of attribute. */\n\tlen = stream_get_endp(s) - cp - 2;\n\tstream_putw_at(s, cp, len);\n}\n", "/* BGP message definition header.\n * Copyright (C) 1996, 97, 98, 99, 2000 Kunihiro Ishiguro\n *\n * This file is part of GNU Zebra.\n *\n * GNU Zebra is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2, or (at your option) any\n * later version.\n *\n * GNU Zebra is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; see the file COPYING; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef _QUAGGA_BGPD_H\n#define _QUAGGA_BGPD_H\n\n#include \"qobj.h\"\n#include <pthread.h>\n\n#include \"frr_pthread.h\"\n#include \"lib/json.h\"\n#include \"vrf.h\"\n#include \"vty.h\"\n\n/* For union sockunion.  */\n#include \"queue.h\"\n#include \"sockunion.h\"\n#include \"routemap.h\"\n#include \"linklist.h\"\n#include \"defaults.h\"\n#include \"bgp_memory.h\"\n#include \"bitfield.h\"\n#include \"vxlan.h\"\n#include \"bgp_labelpool.h\"\n#include \"bgp_addpath_types.h\"\n\n#define BGP_MAX_HOSTNAME 64\t/* Linux max, is larger than most other sys */\n#define BGP_PEER_MAX_HASH_SIZE 16384\n\n/* Default interval for IPv6 RAs when triggered by BGP unnumbered neighbor. */\n#define BGP_UNNUM_DEFAULT_RA_INTERVAL 10\n\nstruct update_subgroup;\nstruct bpacket;\nstruct bgp_pbr_config;\n\n/*\n * Allow the neighbor XXXX remote-as to take internal or external\n * AS_SPECIFIED is zero to auto-inherit original non-feature/enhancement\n * behavior\n * in the system.\n */\nenum { AS_UNSPECIFIED = 0,\n       AS_SPECIFIED,\n       AS_INTERNAL,\n       AS_EXTERNAL,\n};\n\n/* Typedef BGP specific types.  */\ntypedef uint32_t as_t;\ntypedef uint16_t as16_t; /* we may still encounter 16 Bit asnums */\ntypedef uint16_t bgp_size_t;\n\n#define max(a, b)                                                              \\\n\t({                                                                     \\\n\t\t__typeof__(a) _a = (a);                                        \\\n\t\t__typeof__(b) _b = (b);                                        \\\n\t\t_a > _b ? _a : _b;                                             \\\n\t})\n\nenum bgp_af_index {\n\tBGP_AF_START,\n\tBGP_AF_IPV4_UNICAST = BGP_AF_START,\n\tBGP_AF_IPV4_MULTICAST,\n\tBGP_AF_IPV4_VPN,\n\tBGP_AF_IPV6_UNICAST,\n\tBGP_AF_IPV6_MULTICAST,\n\tBGP_AF_IPV6_VPN,\n\tBGP_AF_IPV4_ENCAP,\n\tBGP_AF_IPV6_ENCAP,\n\tBGP_AF_L2VPN_EVPN,\n\tBGP_AF_IPV4_LBL_UNICAST,\n\tBGP_AF_IPV6_LBL_UNICAST,\n\tBGP_AF_IPV4_FLOWSPEC,\n\tBGP_AF_IPV6_FLOWSPEC,\n\tBGP_AF_MAX\n};\n\n#define AF_FOREACH(af) for ((af) = BGP_AF_START; (af) < BGP_AF_MAX; (af)++)\n\n#define FOREACH_AFI_SAFI(afi, safi)                                            \\\n\tfor (afi = AFI_IP; afi < AFI_MAX; afi++)                               \\\n\t\tfor (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)\n\nextern struct frr_pthread *bgp_pth_io;\nextern struct frr_pthread *bgp_pth_ka;\n\n/* BGP master for system wide configurations and variables.  */\nstruct bgp_master {\n\t/* BGP instance list.  */\n\tstruct list *bgp;\n\n\t/* BGP thread master.  */\n\tstruct thread_master *master;\n\n\t/* work queues */\n\tstruct work_queue *process_main_queue;\n\n\t/* Listening sockets */\n\tstruct list *listen_sockets;\n\n\t/* BGP port number.  */\n\tuint16_t port;\n\n\t/* Listener address */\n\tchar *address;\n\n\t/* BGP start time.  */\n\ttime_t start_time;\n\n\t/* Various BGP global configuration.  */\n\tuint8_t options;\n#define BGP_OPT_NO_FIB                   (1 << 0)\n#define BGP_OPT_MULTIPLE_INSTANCE        (1 << 1)\n#define BGP_OPT_CONFIG_CISCO             (1 << 2)\n#define BGP_OPT_NO_LISTEN                (1 << 3)\n#define BGP_OPT_NO_ZEBRA                 (1 << 4)\n\n\tuint64_t updgrp_idspace;\n\tuint64_t subgrp_idspace;\n\n\t/* timer to dampen route map changes */\n\tstruct thread *t_rmap_update; /* Handle route map updates */\n\tuint32_t rmap_update_timer;   /* Route map update timer */\n#define RMAP_DEFAULT_UPDATE_TIMER 5 /* disabled by default */\n\n\t/* Id space for automatic RD derivation for an EVI/VRF */\n\tbitfield_t rd_idspace;\n\n\t/* dynamic mpls label allocation pool */\n\tstruct labelpool labelpool;\n\n\tbool terminating;\t/* global flag that sigint terminate seen */\n\tQOBJ_FIELDS\n};\nDECLARE_QOBJ_TYPE(bgp_master)\n\n/* BGP route-map structure.  */\nstruct bgp_rmap {\n\tchar *name;\n\tstruct route_map *map;\n};\n\nstruct bgp_redist {\n\tunsigned short instance;\n\n\t/* BGP redistribute metric configuration. */\n\tuint8_t redist_metric_flag;\n\tuint32_t redist_metric;\n\n\t/* BGP redistribute route-map.  */\n\tstruct bgp_rmap rmap;\n};\n\ntypedef enum {\n\tBGP_VPN_POLICY_DIR_FROMVPN = 0,\n\tBGP_VPN_POLICY_DIR_TOVPN = 1,\n\tBGP_VPN_POLICY_DIR_MAX = 2\n} vpn_policy_direction_t;\n\nstruct vpn_policy {\n\tstruct bgp *bgp; /* parent */\n\tafi_t afi;\n\tstruct ecommunity *rtlist[BGP_VPN_POLICY_DIR_MAX];\n\tstruct ecommunity *import_redirect_rtlist;\n\tchar *rmap_name[BGP_VPN_POLICY_DIR_MAX];\n\tstruct route_map *rmap[BGP_VPN_POLICY_DIR_MAX];\n\n\t/* should be mpls_label_t? */\n\tuint32_t tovpn_label; /* may be MPLS_LABEL_NONE */\n\tuint32_t tovpn_zebra_vrf_label_last_sent;\n\tstruct prefix_rd tovpn_rd;\n\tstruct prefix tovpn_nexthop; /* unset => set to 0 */\n\tuint32_t flags;\n#define BGP_VPN_POLICY_TOVPN_LABEL_AUTO        (1 << 0)\n#define BGP_VPN_POLICY_TOVPN_RD_SET            (1 << 1)\n#define BGP_VPN_POLICY_TOVPN_NEXTHOP_SET       (1 << 2)\n\n\t/*\n\t * If we are importing another vrf into us keep a list of\n\t * vrf names that are being imported into us.\n\t */\n\tstruct list *import_vrf;\n\n\t/*\n\t * if we are being exported to another vrf keep a list of\n\t * vrf names that we are being exported to.\n\t */\n\tstruct list *export_vrf;\n};\n\n/*\n * Type of 'struct bgp'.\n * - Default: The default instance\n * - VRF: A specific (non-default) VRF\n * - View: An instance used for route exchange\n * The \"default\" instance is treated separately to simplify the code. Note\n * that if deployed in a Multi-VRF environment, it may not exist.\n */\nenum bgp_instance_type {\n\tBGP_INSTANCE_TYPE_DEFAULT,\n\tBGP_INSTANCE_TYPE_VRF,\n\tBGP_INSTANCE_TYPE_VIEW\n};\n\n/* BGP instance structure.  */\nstruct bgp {\n\t/* AS number of this BGP instance.  */\n\tas_t as;\n\n\t/* Name of this BGP instance.  */\n\tchar *name;\n\tchar *name_pretty;\t/* printable \"VRF|VIEW name|default\" */\n\n\t/* Type of instance and VRF id. */\n\tenum bgp_instance_type inst_type;\n\tvrf_id_t vrf_id;\n\n\t/* Reference count to allow peer_delete to finish after bgp_delete */\n\tint lock;\n\n\t/* Self peer.  */\n\tstruct peer *peer_self;\n\n\t/* BGP peer. */\n\tstruct list *peer;\n\tstruct hash *peerhash;\n\n\t/* BGP peer group.  */\n\tstruct list *group;\n\n\t/* The maximum number of BGP dynamic neighbors that can be created */\n\tint dynamic_neighbors_limit;\n\n\t/* The current number of BGP dynamic neighbors */\n\tint dynamic_neighbors_count;\n\n\tstruct hash *update_groups[BGP_AF_MAX];\n\n\t/*\n\t * Global statistics for update groups.\n\t */\n\tstruct {\n\t\tuint32_t join_events;\n\t\tuint32_t prune_events;\n\t\tuint32_t merge_events;\n\t\tuint32_t split_events;\n\t\tuint32_t updgrp_switch_events;\n\t\tuint32_t peer_refreshes_combined;\n\t\tuint32_t adj_count;\n\t\tuint32_t merge_checks_triggered;\n\n\t\tuint32_t updgrps_created;\n\t\tuint32_t updgrps_deleted;\n\t\tuint32_t subgrps_created;\n\t\tuint32_t subgrps_deleted;\n\t} update_group_stats;\n\n\t/* BGP configuration.  */\n\tuint16_t config;\n#define BGP_CONFIG_CLUSTER_ID             (1 << 0)\n#define BGP_CONFIG_CONFEDERATION          (1 << 1)\n\n\t/* BGP router identifier.  */\n\tstruct in_addr router_id;\n\tstruct in_addr router_id_static;\n\tstruct in_addr router_id_zebra;\n\n\t/* BGP route reflector cluster ID.  */\n\tstruct in_addr cluster_id;\n\n\t/* BGP confederation information.  */\n\tas_t confed_id;\n\tas_t *confed_peers;\n\tint confed_peers_cnt;\n\n\tstruct thread\n\t\t*t_startup; /* start-up timer on only once at the beginning */\n\n\tuint32_t v_maxmed_onstartup; /* Duration of max-med on start-up */\n#define BGP_MAXMED_ONSTARTUP_UNCONFIGURED  0 /* 0 means off, its the default */\n\tuint32_t maxmed_onstartup_value;     /* Max-med value when active on\n\t\t\t\t\t\t start-up */\n\tstruct thread\n\t\t*t_maxmed_onstartup; /* non-null when max-med onstartup is on */\n\tuint8_t maxmed_onstartup_over; /* Flag to make it effective only once */\n\n\tuint8_t v_maxmed_admin; /* 1/0 if max-med administrative is on/off */\n#define BGP_MAXMED_ADMIN_UNCONFIGURED  0 /* Off by default */\n\tuint32_t maxmed_admin_value; /* Max-med value when administrative in on\n\t\t\t\t      */\n#define BGP_MAXMED_VALUE_DEFAULT  4294967294 /* Maximum by default */\n\n\tuint8_t maxmed_active; /* 1/0 if max-med is active or not */\n\tuint32_t maxmed_value; /* Max-med value when its active */\n\n\t/* BGP update delay on startup */\n\tstruct thread *t_update_delay;\n\tstruct thread *t_establish_wait;\n\tuint8_t update_delay_over;\n\tuint8_t main_zebra_update_hold;\n\tuint8_t main_peers_update_hold;\n\tuint16_t v_update_delay;\n\tuint16_t v_establish_wait;\n\tchar update_delay_begin_time[64];\n\tchar update_delay_end_time[64];\n\tchar update_delay_zebra_resume_time[64];\n\tchar update_delay_peers_resume_time[64];\n\tuint32_t established;\n\tuint32_t restarted_peers;\n\tuint32_t implicit_eors;\n\tuint32_t explicit_eors;\n#define BGP_UPDATE_DELAY_DEF              0\n#define BGP_UPDATE_DELAY_MIN              0\n#define BGP_UPDATE_DELAY_MAX              3600\n\n\t/* BGP flags. */\n\tuint32_t flags;\n#define BGP_FLAG_ALWAYS_COMPARE_MED       (1 << 0)\n#define BGP_FLAG_DETERMINISTIC_MED        (1 << 1)\n#define BGP_FLAG_MED_MISSING_AS_WORST     (1 << 2)\n#define BGP_FLAG_MED_CONFED               (1 << 3)\n#define BGP_FLAG_NO_DEFAULT_IPV4          (1 << 4)\n#define BGP_FLAG_NO_CLIENT_TO_CLIENT      (1 << 5)\n#define BGP_FLAG_ENFORCE_FIRST_AS         (1 << 6)\n#define BGP_FLAG_COMPARE_ROUTER_ID        (1 << 7)\n#define BGP_FLAG_ASPATH_IGNORE            (1 << 8)\n#define BGP_FLAG_IMPORT_CHECK             (1 << 9)\n#define BGP_FLAG_NO_FAST_EXT_FAILOVER     (1 << 10)\n#define BGP_FLAG_LOG_NEIGHBOR_CHANGES     (1 << 11)\n#define BGP_FLAG_GRACEFUL_RESTART         (1 << 12)\n#define BGP_FLAG_ASPATH_CONFED            (1 << 13)\n#define BGP_FLAG_ASPATH_MULTIPATH_RELAX   (1 << 14)\n#define BGP_FLAG_RR_ALLOW_OUTBOUND_POLICY (1 << 15)\n#define BGP_FLAG_DISABLE_NH_CONNECTED_CHK (1 << 16)\n#define BGP_FLAG_MULTIPATH_RELAX_AS_SET   (1 << 17)\n#define BGP_FLAG_FORCE_STATIC_PROCESS     (1 << 18)\n#define BGP_FLAG_SHOW_HOSTNAME            (1 << 19)\n#define BGP_FLAG_GR_PRESERVE_FWD          (1 << 20)\n#define BGP_FLAG_GRACEFUL_SHUTDOWN        (1 << 21)\n\n\t/* BGP Per AF flags */\n\tuint16_t af_flags[AFI_MAX][SAFI_MAX];\n#define BGP_CONFIG_DAMPENING\t\t\t\t(1 << 0)\n/* l2vpn evpn flags - 1 << 0 is used for DAMPENNG */\n#define BGP_L2VPN_EVPN_ADVERTISE_IPV4_UNICAST\t\t(1 << 1)\n#define BGP_L2VPN_EVPN_ADVERTISE_IPV6_UNICAST\t\t(1 << 2)\n#define BGP_L2VPN_EVPN_DEFAULT_ORIGINATE_IPV4\t\t(1 << 3)\n#define BGP_L2VPN_EVPN_DEFAULT_ORIGINATE_IPV6\t\t(1 << 4)\n/* import/export between address families */\n#define BGP_CONFIG_VRF_TO_MPLSVPN_EXPORT\t\t(1 << 5)\n#define BGP_CONFIG_MPLSVPN_TO_VRF_IMPORT\t\t(1 << 6)\n/* vrf-route leaking flags */\n#define BGP_CONFIG_VRF_TO_VRF_IMPORT\t\t\t(1 << 7)\n#define BGP_CONFIG_VRF_TO_VRF_EXPORT\t\t\t(1 << 8)\n\n\t/* Route table for next-hop lookup cache. */\n\tstruct bgp_table *nexthop_cache_table[AFI_MAX];\n\n\t/* Route table for import-check */\n\tstruct bgp_table *import_check_table[AFI_MAX];\n\n\tstruct bgp_table *connected_table[AFI_MAX];\n\n\tstruct hash *address_hash;\n\n\t/* DB for all local tunnel-ips - used mainly for martian checks\n\t   Currently it only has all VxLan tunnel IPs*/\n\tstruct hash *tip_hash;\n\n\t/* Static route configuration.  */\n\tstruct bgp_table *route[AFI_MAX][SAFI_MAX];\n\n\t/* Aggregate address configuration.  */\n\tstruct bgp_table *aggregate[AFI_MAX][SAFI_MAX];\n\n\t/* BGP routing information base.  */\n\tstruct bgp_table *rib[AFI_MAX][SAFI_MAX];\n\n\t/* BGP table route-map.  */\n\tstruct bgp_rmap table_map[AFI_MAX][SAFI_MAX];\n\n\t/* BGP redistribute configuration. */\n\tstruct list *redist[AFI_MAX][ZEBRA_ROUTE_MAX];\n\n\t/* Allocate MPLS labels */\n\tuint8_t allocate_mpls_labels[AFI_MAX][SAFI_MAX];\n\n\t/* Allocate hash entries to store policy routing information\n\t * The hash are used to host pbr rules somewhere.\n\t * Actually, pbr will only be used by flowspec\n\t * those hash elements will have relationship together as\n\t * illustrated in below diagram:\n\t *\n\t *  pbr_action a <----- pbr_match i <--- pbr_match_entry 1..n\n\t *              <----- pbr_match j <--- pbr_match_entry 1..m\n\t *\n\t * - here in BGP structure, the list of match and actions will\n\t * stand for the list of ipset sets, and table_ids in the kernel\n\t * - the arrow above between pbr_match and pbr_action indicate\n\t * that a backpointer permits match to find the action\n\t * - the arrow betwen match_entry and match is a hash list\n\t * contained in match, that lists the whole set of entries\n\t */\n\tstruct hash *pbr_match_hash;\n\tstruct hash *pbr_action_hash;\n\n\t/* timer to re-evaluate neighbor default-originate route-maps */\n\tstruct thread *t_rmap_def_originate_eval;\n#define RMAP_DEFAULT_ORIGINATE_EVAL_TIMER 5\n\n\t/* BGP distance configuration.  */\n\tuint8_t distance_ebgp[AFI_MAX][SAFI_MAX];\n\tuint8_t distance_ibgp[AFI_MAX][SAFI_MAX];\n\tuint8_t distance_local[AFI_MAX][SAFI_MAX];\n\n\t/* BGP default local-preference.  */\n\tuint32_t default_local_pref;\n\n\t/* BGP default subgroup pkt queue max  */\n\tuint32_t default_subgroup_pkt_queue_max;\n\n\t/* BGP default timer.  */\n\tuint32_t default_holdtime;\n\tuint32_t default_keepalive;\n\n\t/* BGP graceful restart */\n\tuint32_t restart_time;\n\tuint32_t stalepath_time;\n\n\t/* Maximum-paths configuration */\n\tstruct bgp_maxpaths_cfg {\n\t\tuint16_t maxpaths_ebgp;\n\t\tuint16_t maxpaths_ibgp;\n\t\tuint16_t ibgp_flags;\n#define BGP_FLAG_IBGP_MULTIPATH_SAME_CLUSTERLEN (1 << 0)\n\t} maxpaths[AFI_MAX][SAFI_MAX];\n\n\t_Atomic uint32_t wpkt_quanta; // max # packets to write per i/o cycle\n\t_Atomic uint32_t rpkt_quanta; // max # packets to read per i/o cycle\n\n\t/* Automatic coalesce adjust on/off */\n\tbool heuristic_coalesce;\n\t/* Actual coalesce time */\n\tuint32_t coalesce_time;\n\n\t/* Auto-shutdown new peers */\n\tbool autoshutdown;\n\n\tstruct bgp_addpath_bgp_data tx_addpath;\n\n#if ENABLE_BGP_VNC\n\tstruct rfapi_cfg *rfapi_cfg;\n\tstruct rfapi *rfapi;\n#endif\n\n\t/* EVPN related information */\n\n\t/* EVI hash table */\n\tstruct hash *vnihash;\n\n\t/* EVPN enable - advertise gateway macip routes */\n\tint advertise_gw_macip;\n\n\t/* EVPN enable - advertise local VNIs and their MACs etc. */\n\tint advertise_all_vni;\n\n\tstruct bgp_evpn_info *evpn_info;\n\n\t/* EVPN - use RFC 8365 to auto-derive RT */\n\tint advertise_autort_rfc8365;\n\n\t/*\n\t * Flooding mechanism for BUM packets for VxLAN-EVPN.\n\t */\n\tenum vxlan_flood_control vxlan_flood_ctrl;\n\n\t/* Hash table of Import RTs to EVIs */\n\tstruct hash *import_rt_hash;\n\n\t/* Hash table of VRF import RTs to VRFs */\n\tstruct hash *vrf_import_rt_hash;\n\n\t/* L3-VNI corresponding to this vrf */\n\tvni_t l3vni;\n\n\t/* router-mac to be used in mac-ip routes for this vrf */\n\tstruct ethaddr rmac;\n\n\t/* originator ip - to be used as NH for type-5 routes */\n\tstruct in_addr originator_ip;\n\n\t/* vrf flags */\n\tuint32_t vrf_flags;\n#define BGP_VRF_AUTO                        (1 << 0)\n#define BGP_VRF_IMPORT_RT_CFGD              (1 << 1)\n#define BGP_VRF_EXPORT_RT_CFGD              (1 << 2)\n#define BGP_VRF_RD_CFGD                     (1 << 3)\n#define BGP_VRF_L3VNI_PREFIX_ROUTES_ONLY    (1 << 4)\n\n\n\t/* unique ID for auto derivation of RD for this vrf */\n\tuint16_t vrf_rd_id;\n\n\t/* Automatically derived RD for this VRF */\n\tstruct prefix_rd vrf_prd_auto;\n\n\t/* RD for this VRF */\n\tstruct prefix_rd vrf_prd;\n\n\t/* import rt list for the vrf instance */\n\tstruct list *vrf_import_rtl;\n\n\t/* export rt list for the vrf instance */\n\tstruct list *vrf_export_rtl;\n\n\t/* list of corresponding l2vnis (struct bgpevpn) */\n\tstruct list *l2vnis;\n\n\t/* route map for advertise ipv4/ipv6 unicast (type-5 routes) */\n\tstruct bgp_rmap adv_cmd_rmap[AFI_MAX][SAFI_MAX];\n\n\tstruct vpn_policy vpn_policy[AFI_MAX];\n\n\tstruct bgp_pbr_config *bgp_pbr_cfg;\n\n\t/* local esi hash table */\n\tstruct hash *esihash;\n\n\t/* Count of peers in established state */\n\tuint32_t established_peers;\n\n\tQOBJ_FIELDS\n};\nDECLARE_QOBJ_TYPE(bgp)\n\n#define BGP_ROUTE_ADV_HOLD(bgp) (bgp->main_peers_update_hold)\n\n#define IS_BGP_INST_KNOWN_TO_ZEBRA(bgp)                                        \\\n\t(bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT                           \\\n\t || (bgp->inst_type == BGP_INSTANCE_TYPE_VRF                           \\\n\t     && bgp->vrf_id != VRF_UNKNOWN))\n\n/* BGP peer-group support. */\nstruct peer_group {\n\t/* Name of the peer-group. */\n\tchar *name;\n\n\t/* Pointer to BGP.  */\n\tstruct bgp *bgp;\n\n\t/* Peer-group client list. */\n\tstruct list *peer;\n\n\t/** Dynamic neighbor listening ranges */\n\tstruct list *listen_range[AFI_MAX];\n\n\t/* Peer-group config */\n\tstruct peer *conf;\n};\n\n/* BGP Notify message format. */\nstruct bgp_notify {\n\tuint8_t code;\n\tuint8_t subcode;\n\tchar *data;\n\tbgp_size_t length;\n\tuint8_t *raw_data;\n};\n\n/* Next hop self address. */\nstruct bgp_nexthop {\n\tstruct interface *ifp;\n\tstruct in_addr v4;\n\tstruct in6_addr v6_global;\n\tstruct in6_addr v6_local;\n};\n\n/* BGP addpath values */\n#define BGP_ADDPATH_RX     1\n#define BGP_ADDPATH_TX     2\n#define BGP_ADDPATH_ID_LEN 4\n\n#define BGP_ADDPATH_TX_ID_FOR_DEFAULT_ORIGINATE 1\n\n/* Route map direction */\n#define RMAP_IN  0\n#define RMAP_OUT 1\n#define RMAP_MAX 2\n\n#include \"filter.h\"\n\n/* BGP filter structure. */\nstruct bgp_filter {\n\t/* Distribute-list.  */\n\tstruct {\n\t\tchar *name;\n\t\tstruct access_list *alist;\n\t} dlist[FILTER_MAX];\n\n\t/* Prefix-list.  */\n\tstruct {\n\t\tchar *name;\n\t\tstruct prefix_list *plist;\n\t} plist[FILTER_MAX];\n\n\t/* Filter-list.  */\n\tstruct {\n\t\tchar *name;\n\t\tstruct as_list *aslist;\n\t} aslist[FILTER_MAX];\n\n\t/* Route-map.  */\n\tstruct {\n\t\tchar *name;\n\t\tstruct route_map *map;\n\t} map[RMAP_MAX];\n\n\t/* Unsuppress-map.  */\n\tstruct {\n\t\tchar *name;\n\t\tstruct route_map *map;\n\t} usmap;\n};\n\n/* IBGP/EBGP identifier.  We also have a CONFED peer, which is to say,\n   a peer who's AS is part of our Confederation.  */\ntypedef enum {\n\tBGP_PEER_IBGP = 1,\n\tBGP_PEER_EBGP,\n\tBGP_PEER_INTERNAL,\n\tBGP_PEER_CONFED,\n} bgp_peer_sort_t;\n\n/* BGP message header and packet size.  */\n#define BGP_MARKER_SIZE\t\t                16\n#define BGP_HEADER_SIZE\t\t                19\n#define BGP_MAX_PACKET_SIZE                   4096\n#define BGP_MAX_PACKET_SIZE_OVERFLOW          1024\n\n/*\n * Trigger delay for bgp_announce_route().\n */\n#define BGP_ANNOUNCE_ROUTE_SHORT_DELAY_MS  100\n#define BGP_ANNOUNCE_ROUTE_DELAY_MS        500\n\nstruct peer_af {\n\t/* back pointer to the peer */\n\tstruct peer *peer;\n\n\t/* which subgroup the peer_af belongs to */\n\tstruct update_subgroup *subgroup;\n\n\t/* for being part of an update subgroup's peer list */\n\tLIST_ENTRY(peer_af) subgrp_train;\n\n\t/* for being part of a packet's peer list */\n\tLIST_ENTRY(peer_af) pkt_train;\n\n\tstruct bpacket *next_pkt_to_send;\n\n\t/*\n\t * Trigger timer for bgp_announce_route().\n\t */\n\tstruct thread *t_announce_route;\n\n\tafi_t afi;\n\tsafi_t safi;\n\tint afid;\n};\n\n/* BGP neighbor structure. */\nstruct peer {\n\t/* BGP structure.  */\n\tstruct bgp *bgp;\n\n\t/* reference count, primarily to allow bgp_process'ing of route_node's\n\t * to be done after a struct peer is deleted.\n\t *\n\t * named 'lock' for hysterical reasons within Quagga.\n\t */\n\tint lock;\n\n\t/* BGP peer group.  */\n\tstruct peer_group *group;\n\tuint64_t version[AFI_MAX][SAFI_MAX];\n\n\t/* BGP peer_af structures, per configured AF on this peer */\n\tstruct peer_af *peer_af_array[BGP_AF_MAX];\n\n\t/* Peer's remote AS number. */\n\tint as_type;\n\tas_t as;\n\n\t/* Peer's local AS number. */\n\tas_t local_as;\n\n\tbgp_peer_sort_t sort;\n\n\t/* Peer's Change local AS number. */\n\tas_t change_local_as;\n\n\t/* Remote router ID. */\n\tstruct in_addr remote_id;\n\n\t/* Local router ID. */\n\tstruct in_addr local_id;\n\n\t/* Packet receive and send buffer. */\n\tpthread_mutex_t io_mtx;   // guards ibuf, obuf\n\tstruct stream_fifo *ibuf; // packets waiting to be processed\n\tstruct stream_fifo *obuf; // packets waiting to be written\n\n\tstruct ringbuf *ibuf_work; // WiP buffer used by bgp_read() only\n\tstruct stream *obuf_work;  // WiP buffer used to construct packets\n\n\tstruct stream *curr; // the current packet being parsed\n\n\t/* We use a separate stream to encode MP_REACH_NLRI for efficient\n\t * NLRI packing. peer->obuf_work stores all the other attributes. The\n\t * actual packet is then constructed by concatenating the two.\n\t */\n\tstruct stream *scratch;\n\n\t/* the doppelganger peer structure, due to dual TCP conn setup */\n\tstruct peer *doppelganger;\n\n\t/* Status of the peer. */\n\tint status;\n\tint ostatus;\n\n\t/* FSM events, stored for debug purposes.\n\t * Note: uchar used for reduced memory usage.\n\t */\n\tunsigned char cur_event;\n\tunsigned char last_event;\n\tunsigned char last_major_event;\n\n\t/* Peer index, used for dumping TABLE_DUMP_V2 format */\n\tuint16_t table_dump_index;\n\n\t/* Peer information */\n\tint fd;\t\t     /* File descriptor */\n\tint ttl;\t     /* TTL of TCP connection to the peer. */\n\tint rtt;\t     /* Estimated round-trip-time from TCP_INFO */\n\tint gtsm_hops;       /* minimum hopcount to peer */\n\tchar *desc;\t  /* Description of the peer. */\n\tunsigned short port; /* Destination port for peer */\n\tchar *host;\t  /* Printable address of the peer. */\n\tunion sockunion su;  /* Sockunion address of the peer. */\n#define BGP_PEER_SU_UNSPEC(peer) (peer->su.sa.sa_family == AF_UNSPEC)\n\ttime_t uptime;       /* Last Up/Down time */\n\ttime_t readtime;     /* Last read time */\n\ttime_t resettime;    /* Last reset time */\n\n\tchar *conf_if;\t /* neighbor interface config name. */\n\tstruct interface *ifp; /* corresponding interface */\n\tchar *ifname;\t  /* bind interface name. */\n\tchar *update_if;\n\tunion sockunion *update_source;\n\n\tunion sockunion *su_local;  /* Sockunion of local address.  */\n\tunion sockunion *su_remote; /* Sockunion of remote address.  */\n\tint shared_network;\t /* Is this peer shared same network. */\n\tstruct bgp_nexthop nexthop; /* Nexthop */\n\n\t/* Peer address family configuration. */\n\tuint8_t afc[AFI_MAX][SAFI_MAX];\n\tuint8_t afc_nego[AFI_MAX][SAFI_MAX];\n\tuint8_t afc_adv[AFI_MAX][SAFI_MAX];\n\tuint8_t afc_recv[AFI_MAX][SAFI_MAX];\n\n\t/* Capability flags (reset in bgp_stop) */\n\tuint32_t cap;\n#define PEER_CAP_REFRESH_ADV                (1 << 0) /* refresh advertised */\n#define PEER_CAP_REFRESH_OLD_RCV            (1 << 1) /* refresh old received */\n#define PEER_CAP_REFRESH_NEW_RCV            (1 << 2) /* refresh rfc received */\n#define PEER_CAP_DYNAMIC_ADV                (1 << 3) /* dynamic advertised */\n#define PEER_CAP_DYNAMIC_RCV                (1 << 4) /* dynamic received */\n#define PEER_CAP_RESTART_ADV                (1 << 5) /* restart advertised */\n#define PEER_CAP_RESTART_RCV                (1 << 6) /* restart received */\n#define PEER_CAP_AS4_ADV                    (1 << 7) /* as4 advertised */\n#define PEER_CAP_AS4_RCV                    (1 << 8) /* as4 received */\n#define PEER_CAP_RESTART_BIT_ADV            (1 << 9) /* sent restart state */\n#define PEER_CAP_RESTART_BIT_RCV            (1 << 10) /* peer restart state */\n#define PEER_CAP_ADDPATH_ADV                (1 << 11) /* addpath advertised */\n#define PEER_CAP_ADDPATH_RCV                (1 << 12) /* addpath received */\n#define PEER_CAP_ENHE_ADV                   (1 << 13) /* Extended nexthop advertised */\n#define PEER_CAP_ENHE_RCV                   (1 << 14) /* Extended nexthop received */\n#define PEER_CAP_HOSTNAME_ADV               (1 << 15) /* hostname advertised */\n#define PEER_CAP_HOSTNAME_RCV               (1 << 16) /* hostname received */\n\n\t/* Capability flags (reset in bgp_stop) */\n\tuint32_t af_cap[AFI_MAX][SAFI_MAX];\n#define PEER_CAP_ORF_PREFIX_SM_ADV          (1 << 0) /* send-mode advertised */\n#define PEER_CAP_ORF_PREFIX_RM_ADV          (1 << 1) /* receive-mode advertised */\n#define PEER_CAP_ORF_PREFIX_SM_RCV          (1 << 2) /* send-mode received */\n#define PEER_CAP_ORF_PREFIX_RM_RCV          (1 << 3) /* receive-mode received */\n#define PEER_CAP_ORF_PREFIX_SM_OLD_RCV      (1 << 4) /* send-mode received */\n#define PEER_CAP_ORF_PREFIX_RM_OLD_RCV      (1 << 5) /* receive-mode received */\n#define PEER_CAP_RESTART_AF_RCV             (1 << 6) /* graceful restart afi/safi received */\n#define PEER_CAP_RESTART_AF_PRESERVE_RCV    (1 << 7) /* graceful restart afi/safi F-bit received */\n#define PEER_CAP_ADDPATH_AF_TX_ADV          (1 << 8) /* addpath tx advertised */\n#define PEER_CAP_ADDPATH_AF_TX_RCV          (1 << 9) /* addpath tx received */\n#define PEER_CAP_ADDPATH_AF_RX_ADV          (1 << 10) /* addpath rx advertised */\n#define PEER_CAP_ADDPATH_AF_RX_RCV          (1 << 11) /* addpath rx received */\n#define PEER_CAP_ENHE_AF_ADV                (1 << 12) /* Extended nexthopi afi/safi advertised */\n#define PEER_CAP_ENHE_AF_RCV                (1 << 13) /* Extended nexthop afi/safi received */\n#define PEER_CAP_ENHE_AF_NEGO               (1 << 14) /* Extended nexthop afi/safi negotiated */\n\n\t/* Global configuration flags. */\n\t/*\n\t * Parallel array to flags that indicates whether each flag originates\n\t * from a peer-group or if it is config that is specific to this\n\t * individual peer. If a flag is set independent of the peer-group, the\n\t * same bit should be set here. If this peer is a peer-group, this\n\t * memory region should be all zeros.\n\t *\n\t * The assumption is that the default state for all flags is unset,\n\t * so if a flag is unset, the corresponding override flag is unset too.\n\t * However if a flag is set, the corresponding override flag is set.\n\t */\n\tuint32_t flags_override;\n\t/*\n\t * Parallel array to flags that indicates whether the default behavior\n\t * of *flags_override* should be inverted. If a flag is unset and the\n\t * corresponding invert flag is set, the corresponding override flag\n\t * would be set. However if a flag is set and the corresponding invert\n\t * flag is unset, the corresponding override flag would be unset.\n\t *\n\t * This can be used for attributes like *send-community*, which are\n\t * implicitely enabled and have to be disabled explicitely, compared to\n\t * 'normal' attributes like *next-hop-self* which are implicitely set.\n\t *\n\t * All operations dealing with flags should apply the following boolean\n\t * logic to keep the internal flag system in a sane state:\n\t *\n\t * value=0 invert=0\tInherit flag if member, otherwise unset flag\n\t * value=0 invert=1\tUnset flag unconditionally\n\t * value=1 invert=0\tSet flag unconditionally\n\t * value=1 invert=1\tInherit flag if member, otherwise set flag\n\t *\n\t * Contrary to the implementation of *flags_override*, the flag\n\t * inversion state can be set either on the peer OR the peer *and* the\n\t * peer-group. This was done on purpose, as the inversion state of a\n\t * flag can be determined on either the peer or the peer-group.\n\t *\n\t * Example: Enabling the cisco configuration mode inverts all flags\n\t * related to *send-community* unconditionally for both peer-groups and\n\t * peers.\n\t *\n\t * This behavior is different for interface peers though, which enable\n\t * the *extended-nexthop* flag by default, which regular peers do not.\n\t * As the peer-group can contain both regular and interface peers, the\n\t * flag inversion state must be set on the peer only.\n\t *\n\t * When a peer inherits the configuration from a peer-group and the\n\t * inversion state of the flag differs between peer and peer-group, the\n\t * newly set value must equal to the inverted state of the peer-group.\n\t */\n\tuint32_t flags_invert;\n\t/*\n\t * Effective array for storing the peer/peer-group flags. In case of a\n\t * peer-group, the peer-specific overrides (see flags_override and\n\t * flags_invert) must be respected.\n\t */\n\tuint32_t flags;\n#define PEER_FLAG_PASSIVE                   (1 << 0) /* passive mode */\n#define PEER_FLAG_SHUTDOWN                  (1 << 1) /* shutdown */\n#define PEER_FLAG_DONT_CAPABILITY           (1 << 2) /* dont-capability */\n#define PEER_FLAG_OVERRIDE_CAPABILITY       (1 << 3) /* override-capability */\n#define PEER_FLAG_STRICT_CAP_MATCH          (1 << 4) /* strict-match */\n#define PEER_FLAG_DYNAMIC_CAPABILITY        (1 << 5) /* dynamic capability */\n#define PEER_FLAG_DISABLE_CONNECTED_CHECK   (1 << 6) /* disable-connected-check */\n#define PEER_FLAG_LOCAL_AS_NO_PREPEND       (1 << 7) /* local-as no-prepend */\n#define PEER_FLAG_LOCAL_AS_REPLACE_AS       (1 << 8) /* local-as no-prepend replace-as */\n#define PEER_FLAG_DELETE                    (1 << 9) /* mark the peer for deleting */\n#define PEER_FLAG_CONFIG_NODE               (1 << 10) /* the node to update configs on */\n#define PEER_FLAG_LONESOUL                  (1 << 11)\n#define PEER_FLAG_DYNAMIC_NEIGHBOR          (1 << 12) /* dynamic neighbor */\n#define PEER_FLAG_CAPABILITY_ENHE           (1 << 13) /* Extended next-hop (rfc 5549)*/\n#define PEER_FLAG_IFPEER_V6ONLY             (1 << 14) /* if-based peer is v6 only */\n#define PEER_FLAG_IS_RFAPI_HD               (1 << 15) /* attached to rfapi HD */\n#define PEER_FLAG_ENFORCE_FIRST_AS          (1 << 16) /* enforce-first-as */\n#define PEER_FLAG_ROUTEADV                  (1 << 17) /* route advertise */\n#define PEER_FLAG_TIMER                     (1 << 18) /* keepalive & holdtime */\n#define PEER_FLAG_TIMER_CONNECT             (1 << 19) /* connect timer */\n#define PEER_FLAG_PASSWORD                  (1 << 20) /* password */\n#define PEER_FLAG_LOCAL_AS                  (1 << 21) /* local-as */\n#define PEER_FLAG_UPDATE_SOURCE             (1 << 22) /* update-source */\n\n\t/* outgoing message sent in CEASE_ADMIN_SHUTDOWN notify */\n\tchar *tx_shutdown_message;\n\n\t/* NSF mode (graceful restart) */\n\tuint8_t nsf[AFI_MAX][SAFI_MAX];\n\n\t/* Peer Per AF flags */\n\t/*\n\t * Please consult the comments for *flags_override*, *flags_invert* and\n\t * *flags* to understand what these three arrays do. The address-family\n\t * specific attributes are being treated the exact same way as global\n\t * peer attributes.\n\t */\n\tuint32_t af_flags_override[AFI_MAX][SAFI_MAX];\n\tuint32_t af_flags_invert[AFI_MAX][SAFI_MAX];\n\tuint32_t af_flags[AFI_MAX][SAFI_MAX];\n#define PEER_FLAG_SEND_COMMUNITY            (1 << 0) /* send-community */\n#define PEER_FLAG_SEND_EXT_COMMUNITY        (1 << 1) /* send-community ext. */\n#define PEER_FLAG_NEXTHOP_SELF              (1 << 2) /* next-hop-self */\n#define PEER_FLAG_REFLECTOR_CLIENT          (1 << 3) /* reflector-client */\n#define PEER_FLAG_RSERVER_CLIENT            (1 << 4) /* route-server-client */\n#define PEER_FLAG_SOFT_RECONFIG             (1 << 5) /* soft-reconfiguration */\n#define PEER_FLAG_AS_PATH_UNCHANGED         (1 << 6) /* transparent-as */\n#define PEER_FLAG_NEXTHOP_UNCHANGED         (1 << 7) /* transparent-next-hop */\n#define PEER_FLAG_MED_UNCHANGED             (1 << 8) /* transparent-next-hop */\n#define PEER_FLAG_DEFAULT_ORIGINATE         (1 << 9) /* default-originate */\n#define PEER_FLAG_REMOVE_PRIVATE_AS         (1 << 10) /* remove-private-as */\n#define PEER_FLAG_ALLOWAS_IN                (1 << 11) /* set allowas-in */\n#define PEER_FLAG_ORF_PREFIX_SM             (1 << 12) /* orf capability send-mode */\n#define PEER_FLAG_ORF_PREFIX_RM             (1 << 13) /* orf capability receive-mode */\n#define PEER_FLAG_MAX_PREFIX                (1 << 14) /* maximum prefix */\n#define PEER_FLAG_MAX_PREFIX_WARNING        (1 << 15) /* maximum prefix warning-only */\n#define PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED   (1 << 16) /* leave link-local nexthop unchanged */\n#define PEER_FLAG_FORCE_NEXTHOP_SELF        (1 << 17) /* next-hop-self force */\n#define PEER_FLAG_REMOVE_PRIVATE_AS_ALL     (1 << 18) /* remove-private-as all */\n#define PEER_FLAG_REMOVE_PRIVATE_AS_REPLACE (1 << 19) /* remove-private-as replace-as */\n#define PEER_FLAG_AS_OVERRIDE               (1 << 20) /* as-override */\n#define PEER_FLAG_REMOVE_PRIVATE_AS_ALL_REPLACE (1 << 21) /* remove-private-as all replace-as */\n#define PEER_FLAG_WEIGHT                    (1 << 24) /* weight */\n#define PEER_FLAG_ALLOWAS_IN_ORIGIN         (1 << 25) /* allowas-in origin */\n#define PEER_FLAG_SEND_LARGE_COMMUNITY      (1 << 26) /* Send large Communities */\n\n\tenum bgp_addpath_strat addpath_type[AFI_MAX][SAFI_MAX];\n\n\t/* MD5 password */\n\tchar *password;\n\n\t/* default-originate route-map.  */\n\tstruct {\n\t\tchar *name;\n\t\tstruct route_map *map;\n\t} default_rmap[AFI_MAX][SAFI_MAX];\n\n\t/* Peer status flags. */\n\tuint16_t sflags;\n#define PEER_STATUS_ACCEPT_PEER\t      (1 << 0) /* accept peer */\n#define PEER_STATUS_PREFIX_OVERFLOW   (1 << 1) /* prefix-overflow */\n#define PEER_STATUS_CAPABILITY_OPEN   (1 << 2) /* capability open send */\n#define PEER_STATUS_HAVE_ACCEPT       (1 << 3) /* accept peer's parent */\n#define PEER_STATUS_GROUP             (1 << 4) /* peer-group conf */\n#define PEER_STATUS_NSF_MODE          (1 << 5) /* NSF aware peer */\n#define PEER_STATUS_NSF_WAIT          (1 << 6) /* wait comeback peer */\n\n\t/* Peer status af flags (reset in bgp_stop) */\n\tuint16_t af_sflags[AFI_MAX][SAFI_MAX];\n#define PEER_STATUS_ORF_PREFIX_SEND   (1 << 0) /* prefix-list send peer */\n#define PEER_STATUS_ORF_WAIT_REFRESH  (1 << 1) /* wait refresh received peer */\n#define PEER_STATUS_PREFIX_THRESHOLD  (1 << 2) /* exceed prefix-threshold */\n#define PEER_STATUS_PREFIX_LIMIT      (1 << 3) /* exceed prefix-limit */\n#define PEER_STATUS_EOR_SEND          (1 << 4) /* end-of-rib send to peer */\n#define PEER_STATUS_EOR_RECEIVED      (1 << 5) /* end-of-rib received from peer */\n\n\t/* Configured timer values. */\n\t_Atomic uint32_t holdtime;\n\t_Atomic uint32_t keepalive;\n\t_Atomic uint32_t connect;\n\t_Atomic uint32_t routeadv;\n\n\t/* Timer values. */\n\t_Atomic uint32_t v_start;\n\t_Atomic uint32_t v_connect;\n\t_Atomic uint32_t v_holdtime;\n\t_Atomic uint32_t v_keepalive;\n\t_Atomic uint32_t v_routeadv;\n\t_Atomic uint32_t v_pmax_restart;\n\t_Atomic uint32_t v_gr_restart;\n\n\t/* Threads. */\n\tstruct thread *t_read;\n\tstruct thread *t_write;\n\tstruct thread *t_start;\n\tstruct thread *t_connect_check_r;\n\tstruct thread *t_connect_check_w;\n\tstruct thread *t_connect;\n\tstruct thread *t_holdtime;\n\tstruct thread *t_routeadv;\n\tstruct thread *t_pmax_restart;\n\tstruct thread *t_gr_restart;\n\tstruct thread *t_gr_stale;\n\tstruct thread *t_generate_updgrp_packets;\n\tstruct thread *t_process_packet;\n\n\t/* Thread flags. */\n\t_Atomic uint32_t thread_flags;\n#define PEER_THREAD_WRITES_ON         (1 << 0)\n#define PEER_THREAD_READS_ON          (1 << 1)\n#define PEER_THREAD_KEEPALIVES_ON     (1 << 2)\n\t/* workqueues */\n\tstruct work_queue *clear_node_queue;\n\n#define PEER_TOTAL_RX(peer)                                                    \\\n\tatomic_load_explicit(&peer->open_in, memory_order_relaxed)             \\\n\t\t+ atomic_load_explicit(&peer->update_in, memory_order_relaxed) \\\n\t\t+ atomic_load_explicit(&peer->notify_in, memory_order_relaxed) \\\n\t\t+ atomic_load_explicit(&peer->refresh_in,                      \\\n\t\t\t\t       memory_order_relaxed)                   \\\n\t\t+ atomic_load_explicit(&peer->keepalive_in,                    \\\n\t\t\t\t       memory_order_relaxed)                   \\\n\t\t+ atomic_load_explicit(&peer->dynamic_cap_in,                  \\\n\t\t\t\t       memory_order_relaxed)\n\n#define PEER_TOTAL_TX(peer)                                                    \\\n\tatomic_load_explicit(&peer->open_out, memory_order_relaxed)            \\\n\t\t+ atomic_load_explicit(&peer->update_out,                      \\\n\t\t\t\t       memory_order_relaxed)                   \\\n\t\t+ atomic_load_explicit(&peer->notify_out,                      \\\n\t\t\t\t       memory_order_relaxed)                   \\\n\t\t+ atomic_load_explicit(&peer->refresh_out,                     \\\n\t\t\t\t       memory_order_relaxed)                   \\\n\t\t+ atomic_load_explicit(&peer->keepalive_out,                   \\\n\t\t\t\t       memory_order_relaxed)                   \\\n\t\t+ atomic_load_explicit(&peer->dynamic_cap_out,                 \\\n\t\t\t\t       memory_order_relaxed)\n\n\t/* Statistics field */\n\t_Atomic uint32_t open_in;\t /* Open message input count */\n\t_Atomic uint32_t open_out;\t/* Open message output count */\n\t_Atomic uint32_t update_in;       /* Update message input count */\n\t_Atomic uint32_t update_out;      /* Update message ouput count */\n\t_Atomic time_t update_time;       /* Update message received time. */\n\t_Atomic uint32_t keepalive_in;    /* Keepalive input count */\n\t_Atomic uint32_t keepalive_out;   /* Keepalive output count */\n\t_Atomic uint32_t notify_in;       /* Notify input count */\n\t_Atomic uint32_t notify_out;      /* Notify output count */\n\t_Atomic uint32_t refresh_in;      /* Route Refresh input count */\n\t_Atomic uint32_t refresh_out;     /* Route Refresh output count */\n\t_Atomic uint32_t dynamic_cap_in;  /* Dynamic Capability input count.  */\n\t_Atomic uint32_t dynamic_cap_out; /* Dynamic Capability output count. */\n\n\t/* BGP state count */\n\tuint32_t established; /* Established */\n\tuint32_t dropped;     /* Dropped */\n\n\t/* Update delay related fields */\n\tuint8_t update_delay_over; /* When this is set, BGP is no more waiting\n\t\t\t\t     for EOR */\n\n\t/* Syncronization list and time.  */\n\tstruct bgp_synchronize *sync[AFI_MAX][SAFI_MAX];\n\ttime_t synctime;\n\t/* timestamp when the last UPDATE msg was written */\n\t_Atomic time_t last_write;\n\t/* timestamp when the last msg was written */\n\t_Atomic time_t last_update;\n\n\t/* Send prefix count. */\n\tunsigned long scount[AFI_MAX][SAFI_MAX];\n\n\t/* Notify data. */\n\tstruct bgp_notify notify;\n\n\t/* Filter structure. */\n\tstruct bgp_filter filter[AFI_MAX][SAFI_MAX];\n\n\t/*\n\t * Parallel array to filter that indicates whether each filter\n\t * originates from a peer-group or if it is config that is specific to\n\t * this individual peer. If a filter is set independent of the\n\t * peer-group the appropriate bit should be set here. If this peer is a\n\t * peer-group, this memory region should be all zeros. The assumption\n\t * is that the default state for all flags is unset. Due to filters\n\t * having a direction (e.g. in/out/...), this array has a third\n\t * dimension for storing the overrides independently per direction.\n\t *\n\t * Notes:\n\t * - if a filter for an individual peer is unset, the corresponding\n\t *   override flag is unset and the peer is considered to be back in\n\t *   sync with the peer-group.\n\t * - This does *not* contain the filter values, rather it contains\n\t *   whether the filter in filter (struct bgp_filter) is peer-specific.\n\t */\n\tuint8_t filter_override[AFI_MAX][SAFI_MAX][(FILTER_MAX > RMAP_MAX)\n\t\t\t\t\t\t\t   ? FILTER_MAX\n\t\t\t\t\t\t\t   : RMAP_MAX];\n#define PEER_FT_DISTRIBUTE_LIST       (1 << 0) /* distribute-list */\n#define PEER_FT_FILTER_LIST           (1 << 1) /* filter-list */\n#define PEER_FT_PREFIX_LIST           (1 << 2) /* prefix-list */\n#define PEER_FT_ROUTE_MAP             (1 << 3) /* route-map */\n#define PEER_FT_UNSUPPRESS_MAP        (1 << 4) /* unsuppress-map */\n\n\t/* ORF Prefix-list */\n\tstruct prefix_list *orf_plist[AFI_MAX][SAFI_MAX];\n\n\t/* Text description of last attribute rcvd */\n\tchar rcvd_attr_str[BUFSIZ];\n\n\t/* Track if we printed the attribute in debugs */\n\tint rcvd_attr_printed;\n\n\t/* Prefix count. */\n\tunsigned long pcount[AFI_MAX][SAFI_MAX];\n\n\t/* Max prefix count. */\n\tunsigned long pmax[AFI_MAX][SAFI_MAX];\n\tuint8_t pmax_threshold[AFI_MAX][SAFI_MAX];\n\tuint16_t pmax_restart[AFI_MAX][SAFI_MAX];\n#define MAXIMUM_PREFIX_THRESHOLD_DEFAULT 75\n\n\t/* allowas-in. */\n\tchar allowas_in[AFI_MAX][SAFI_MAX];\n\n\t/* weight */\n\tunsigned long weight[AFI_MAX][SAFI_MAX];\n\n\t/* peer reset cause */\n\tchar last_reset;\n#define PEER_DOWN_RID_CHANGE             1 /* bgp router-id command */\n#define PEER_DOWN_REMOTE_AS_CHANGE       2 /* neighbor remote-as command */\n#define PEER_DOWN_LOCAL_AS_CHANGE        3 /* neighbor local-as command */\n#define PEER_DOWN_CLID_CHANGE            4 /* bgp cluster-id command */\n#define PEER_DOWN_CONFED_ID_CHANGE       5 /* bgp confederation identifier command */\n#define PEER_DOWN_CONFED_PEER_CHANGE     6 /* bgp confederation peer command */\n#define PEER_DOWN_RR_CLIENT_CHANGE       7 /* neighbor route-reflector-client command */\n#define PEER_DOWN_RS_CLIENT_CHANGE       8 /* neighbor route-server-client command */\n#define PEER_DOWN_UPDATE_SOURCE_CHANGE   9 /* neighbor update-source command */\n#define PEER_DOWN_AF_ACTIVATE           10 /* neighbor activate command */\n#define PEER_DOWN_USER_SHUTDOWN         11 /* neighbor shutdown command */\n#define PEER_DOWN_USER_RESET            12 /* clear ip bgp command */\n#define PEER_DOWN_NOTIFY_RECEIVED       13 /* notification received */\n#define PEER_DOWN_NOTIFY_SEND           14 /* notification send */\n#define PEER_DOWN_CLOSE_SESSION         15 /* tcp session close */\n#define PEER_DOWN_NEIGHBOR_DELETE       16 /* neghbor delete */\n#define PEER_DOWN_RMAP_BIND             17 /* neghbor peer-group command */\n#define PEER_DOWN_RMAP_UNBIND           18 /* no neighbor peer-group command */\n#define PEER_DOWN_CAPABILITY_CHANGE     19 /* neighbor capability command */\n#define PEER_DOWN_PASSIVE_CHANGE        20 /* neighbor passive command */\n#define PEER_DOWN_MULTIHOP_CHANGE       21 /* neighbor multihop command */\n#define PEER_DOWN_NSF_CLOSE_SESSION     22 /* NSF tcp session close */\n#define PEER_DOWN_V6ONLY_CHANGE         23 /* if-based peering v6only toggled */\n#define PEER_DOWN_BFD_DOWN              24 /* BFD down */\n#define PEER_DOWN_IF_DOWN               25 /* Interface down */\n#define PEER_DOWN_NBR_ADDR_DEL          26 /* Peer address lost */\n\tunsigned long last_reset_cause_size;\n\tuint8_t last_reset_cause[BGP_MAX_PACKET_SIZE];\n\n\t/* The kind of route-map Flags.*/\n\tuint8_t rmap_type;\n#define PEER_RMAP_TYPE_IN             (1 << 0) /* neighbor route-map in */\n#define PEER_RMAP_TYPE_OUT            (1 << 1) /* neighbor route-map out */\n#define PEER_RMAP_TYPE_NETWORK        (1 << 2) /* network route-map */\n#define PEER_RMAP_TYPE_REDISTRIBUTE   (1 << 3) /* redistribute route-map */\n#define PEER_RMAP_TYPE_DEFAULT        (1 << 4) /* default-originate route-map */\n#define PEER_RMAP_TYPE_NOSET          (1 << 5) /* not allow to set commands */\n#define PEER_RMAP_TYPE_IMPORT         (1 << 6) /* neighbor route-map import */\n#define PEER_RMAP_TYPE_EXPORT         (1 << 7) /* neighbor route-map export */\n\n\t/* peer specific BFD information */\n\tstruct bfd_info *bfd_info;\n\n\t/* hostname and domainname advertised by host */\n\tchar *hostname;\n\tchar *domainname;\n\n\tQOBJ_FIELDS\n};\nDECLARE_QOBJ_TYPE(peer)\n\n/* Inherit peer attribute from peer-group. */\n#define PEER_ATTR_INHERIT(peer, group, attr)                                   \\\n\t((peer)->attr = (group)->conf->attr)\n#define PEER_STR_ATTR_INHERIT(peer, group, attr, mt)                           \\\n\tdo {                                                                   \\\n\t\tif ((peer)->attr)                                              \\\n\t\t\tXFREE(mt, (peer)->attr);                               \\\n\t\tif ((group)->conf->attr)                                       \\\n\t\t\t(peer)->attr = XSTRDUP(mt, (group)->conf->attr);       \\\n\t\telse                                                           \\\n\t\t\t(peer)->attr = NULL;                                   \\\n\t} while (0)\n#define PEER_SU_ATTR_INHERIT(peer, group, attr)                                \\\n\tdo {                                                                   \\\n\t\tif ((peer)->attr)                                              \\\n\t\t\tsockunion_free((peer)->attr);                          \\\n\t\tif ((group)->conf->attr)                                       \\\n\t\t\t(peer)->attr = sockunion_dup((group)->conf->attr);     \\\n\t\telse                                                           \\\n\t\t\t(peer)->attr = NULL;                                   \\\n\t} while (0)\n\n/* Check if suppress start/restart of sessions to peer. */\n#define BGP_PEER_START_SUPPRESSED(P)                                           \\\n\t(CHECK_FLAG((P)->flags, PEER_FLAG_SHUTDOWN)                            \\\n\t || CHECK_FLAG((P)->sflags, PEER_STATUS_PREFIX_OVERFLOW))\n\n#define PEER_PASSWORD_MINLEN\t(1)\n#define PEER_PASSWORD_MAXLEN\t(80)\n\n/* This structure's member directly points incoming packet data\n   stream. */\nstruct bgp_nlri {\n\t/* AFI.  */\n\tuint16_t afi; /* iana_afi_t */\n\n\t/* SAFI.  */\n\tuint8_t safi; /* iana_safi_t */\n\n\t/* Pointer to NLRI byte stream.  */\n\tuint8_t *nlri;\n\n\t/* Length of whole NLRI.  */\n\tbgp_size_t length;\n};\n\n/* BGP versions.  */\n#define BGP_VERSION_4\t\t                 4\n\n/* Default BGP port number.  */\n#define BGP_PORT_DEFAULT                       179\n\n/* BGP minimum message size.  */\n#define BGP_MSG_OPEN_MIN_SIZE                   (BGP_HEADER_SIZE + 10)\n#define BGP_MSG_UPDATE_MIN_SIZE                 (BGP_HEADER_SIZE + 4)\n#define BGP_MSG_NOTIFY_MIN_SIZE                 (BGP_HEADER_SIZE + 2)\n#define BGP_MSG_KEEPALIVE_MIN_SIZE              (BGP_HEADER_SIZE + 0)\n#define BGP_MSG_ROUTE_REFRESH_MIN_SIZE          (BGP_HEADER_SIZE + 4)\n#define BGP_MSG_CAPABILITY_MIN_SIZE             (BGP_HEADER_SIZE + 3)\n\n/* BGP message types.  */\n#define\tBGP_MSG_OPEN\t\t                 1\n#define\tBGP_MSG_UPDATE\t\t                 2\n#define\tBGP_MSG_NOTIFY\t\t                 3\n#define\tBGP_MSG_KEEPALIVE\t                 4\n#define BGP_MSG_ROUTE_REFRESH_NEW                5\n#define BGP_MSG_CAPABILITY                       6\n#define BGP_MSG_ROUTE_REFRESH_OLD              128\n\n/* BGP open optional parameter.  */\n#define BGP_OPEN_OPT_AUTH                        1\n#define BGP_OPEN_OPT_CAP                         2\n\n/* BGP4 attribute type codes.  */\n#define BGP_ATTR_ORIGIN                          1\n#define BGP_ATTR_AS_PATH                         2\n#define BGP_ATTR_NEXT_HOP                        3\n#define BGP_ATTR_MULTI_EXIT_DISC                 4\n#define BGP_ATTR_LOCAL_PREF                      5\n#define BGP_ATTR_ATOMIC_AGGREGATE                6\n#define BGP_ATTR_AGGREGATOR                      7\n#define BGP_ATTR_COMMUNITIES                     8\n#define BGP_ATTR_ORIGINATOR_ID                   9\n#define BGP_ATTR_CLUSTER_LIST                   10\n#define BGP_ATTR_DPA                            11\n#define BGP_ATTR_ADVERTISER                     12\n#define BGP_ATTR_RCID_PATH                      13\n#define BGP_ATTR_MP_REACH_NLRI                  14\n#define BGP_ATTR_MP_UNREACH_NLRI                15\n#define BGP_ATTR_EXT_COMMUNITIES                16\n#define BGP_ATTR_AS4_PATH                       17\n#define BGP_ATTR_AS4_AGGREGATOR                 18\n#define BGP_ATTR_AS_PATHLIMIT                   21\n#define BGP_ATTR_PMSI_TUNNEL                    22\n#define BGP_ATTR_ENCAP                          23\n#define BGP_ATTR_LARGE_COMMUNITIES              32\n#define BGP_ATTR_PREFIX_SID                     40\n#if ENABLE_BGP_VNC_ATTR\n#define BGP_ATTR_VNC                           255\n#endif\n\n/* BGP update origin.  */\n#define BGP_ORIGIN_IGP                           0\n#define BGP_ORIGIN_EGP                           1\n#define BGP_ORIGIN_INCOMPLETE                    2\n\n/* BGP notify message codes.  */\n#define BGP_NOTIFY_HEADER_ERR                    1\n#define BGP_NOTIFY_OPEN_ERR                      2\n#define BGP_NOTIFY_UPDATE_ERR                    3\n#define BGP_NOTIFY_HOLD_ERR                      4\n#define BGP_NOTIFY_FSM_ERR                       5\n#define BGP_NOTIFY_CEASE                         6\n#define BGP_NOTIFY_CAPABILITY_ERR                7\n\n#define BGP_NOTIFY_SUBCODE_UNSPECIFIC            0\n\n/* BGP_NOTIFY_HEADER_ERR sub codes.  */\n#define BGP_NOTIFY_HEADER_NOT_SYNC               1\n#define BGP_NOTIFY_HEADER_BAD_MESLEN             2\n#define BGP_NOTIFY_HEADER_BAD_MESTYPE            3\n\n/* BGP_NOTIFY_OPEN_ERR sub codes.  */\n#define BGP_NOTIFY_OPEN_MALFORMED_ATTR           0\n#define BGP_NOTIFY_OPEN_UNSUP_VERSION            1\n#define BGP_NOTIFY_OPEN_BAD_PEER_AS              2\n#define BGP_NOTIFY_OPEN_BAD_BGP_IDENT            3\n#define BGP_NOTIFY_OPEN_UNSUP_PARAM              4\n#define BGP_NOTIFY_OPEN_AUTH_FAILURE             5\n#define BGP_NOTIFY_OPEN_UNACEP_HOLDTIME          6\n#define BGP_NOTIFY_OPEN_UNSUP_CAPBL              7\n\n/* BGP_NOTIFY_UPDATE_ERR sub codes.  */\n#define BGP_NOTIFY_UPDATE_MAL_ATTR               1\n#define BGP_NOTIFY_UPDATE_UNREC_ATTR             2\n#define BGP_NOTIFY_UPDATE_MISS_ATTR              3\n#define BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR          4\n#define BGP_NOTIFY_UPDATE_ATTR_LENG_ERR          5\n#define BGP_NOTIFY_UPDATE_INVAL_ORIGIN           6\n#define BGP_NOTIFY_UPDATE_AS_ROUTE_LOOP          7\n#define BGP_NOTIFY_UPDATE_INVAL_NEXT_HOP         8\n#define BGP_NOTIFY_UPDATE_OPT_ATTR_ERR           9\n#define BGP_NOTIFY_UPDATE_INVAL_NETWORK         10\n#define BGP_NOTIFY_UPDATE_MAL_AS_PATH           11\n\n/* BGP_NOTIFY_CEASE sub codes (RFC 4486).  */\n#define BGP_NOTIFY_CEASE_MAX_PREFIX              1\n#define BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN          2\n#define BGP_NOTIFY_CEASE_PEER_UNCONFIG           3\n#define BGP_NOTIFY_CEASE_ADMIN_RESET             4\n#define BGP_NOTIFY_CEASE_CONNECT_REJECT          5\n#define BGP_NOTIFY_CEASE_CONFIG_CHANGE           6\n#define BGP_NOTIFY_CEASE_COLLISION_RESOLUTION    7\n#define BGP_NOTIFY_CEASE_OUT_OF_RESOURCE         8\n\n/* BGP_NOTIFY_CAPABILITY_ERR sub codes (draft-ietf-idr-dynamic-cap-02). */\n#define BGP_NOTIFY_CAPABILITY_INVALID_ACTION     1\n#define BGP_NOTIFY_CAPABILITY_INVALID_LENGTH     2\n#define BGP_NOTIFY_CAPABILITY_MALFORMED_CODE     3\n\n/* BGP finite state machine status.  */\n#define Idle                                     1\n#define Connect                                  2\n#define Active                                   3\n#define OpenSent                                 4\n#define OpenConfirm                              5\n#define Established                              6\n#define Clearing                                 7\n#define Deleted                                  8\n#define BGP_STATUS_MAX                           9\n\n/* BGP finite state machine events.  */\n#define BGP_Start                                1\n#define BGP_Stop                                 2\n#define TCP_connection_open                      3\n#define TCP_connection_closed                    4\n#define TCP_connection_open_failed               5\n#define TCP_fatal_error                          6\n#define ConnectRetry_timer_expired               7\n#define Hold_Timer_expired                       8\n#define KeepAlive_timer_expired                  9\n#define Receive_OPEN_message                    10\n#define Receive_KEEPALIVE_message               11\n#define Receive_UPDATE_message                  12\n#define Receive_NOTIFICATION_message            13\n#define Clearing_Completed                      14\n#define BGP_EVENTS_MAX                          15\n\n/* BGP timers default value.  */\n/* note: the DFLT_ ones depend on compile-time \"defaults\" selection */\n#define BGP_INIT_START_TIMER                     1\n#define BGP_DEFAULT_HOLDTIME                      DFLT_BGP_HOLDTIME\n#define BGP_DEFAULT_KEEPALIVE                     DFLT_BGP_KEEPALIVE\n#define BGP_DEFAULT_EBGP_ROUTEADV                0\n#define BGP_DEFAULT_IBGP_ROUTEADV                0\n#define BGP_DEFAULT_CONNECT_RETRY                 DFLT_BGP_TIMERS_CONNECT\n\n/* BGP default local preference.  */\n#define BGP_DEFAULT_LOCAL_PREF                 100\n\n/* BGP local-preference to send when 'bgp graceful-shutdown'\n * is configured */\n#define BGP_GSHUT_LOCAL_PREF                     0\n\n/* BGP default subgroup packet queue max .  */\n#define BGP_DEFAULT_SUBGROUP_PKT_QUEUE_MAX      40\n\n/* BGP graceful restart  */\n#define BGP_DEFAULT_RESTART_TIME               120\n#define BGP_DEFAULT_STALEPATH_TIME             360\n\n/* BGP uptime string length.  */\n#define BGP_UPTIME_LEN 25\n\n/* Default configuration settings for bgpd.  */\n#define BGP_VTY_PORT                          2605\n#define BGP_DEFAULT_CONFIG             \"bgpd.conf\"\n\n/* Check AS path loop when we send NLRI.  */\n/* #define BGP_SEND_ASPATH_CHECK */\n\n/* BGP Dynamic Neighbors feature */\n#define BGP_DYNAMIC_NEIGHBORS_LIMIT_DEFAULT    100\n#define BGP_DYNAMIC_NEIGHBORS_LIMIT_MIN          1\n#define BGP_DYNAMIC_NEIGHBORS_LIMIT_MAX       5000\n\n/* Flag for peer_clear_soft().  */\nenum bgp_clear_type {\n\tBGP_CLEAR_SOFT_NONE,\n\tBGP_CLEAR_SOFT_OUT,\n\tBGP_CLEAR_SOFT_IN,\n\tBGP_CLEAR_SOFT_BOTH,\n\tBGP_CLEAR_SOFT_IN_ORF_PREFIX\n};\n\n/* Macros. */\n#define BGP_INPUT(P)         ((P)->curr)\n#define BGP_INPUT_PNT(P)     (stream_pnt(BGP_INPUT(P)))\n#define BGP_IS_VALID_STATE_FOR_NOTIF(S)                                        \\\n\t(((S) == OpenSent) || ((S) == OpenConfirm) || ((S) == Established))\n\n/* BGP error codes.  */\n#define BGP_SUCCESS                               0\n#define BGP_ERR_INVALID_VALUE                    -1\n#define BGP_ERR_INVALID_FLAG                     -2\n#define BGP_ERR_INVALID_AS                       -3\n#define BGP_ERR_INVALID_BGP                      -4\n#define BGP_ERR_PEER_GROUP_MEMBER                -5\n#define BGP_ERR_MULTIPLE_INSTANCE_USED           -6\n#define BGP_ERR_PEER_GROUP_NO_REMOTE_AS          -7\n#define BGP_ERR_PEER_GROUP_CANT_CHANGE           -8\n#define BGP_ERR_PEER_GROUP_MISMATCH              -9\n#define BGP_ERR_PEER_GROUP_PEER_TYPE_DIFFERENT  -10\n#define BGP_ERR_MULTIPLE_INSTANCE_NOT_SET       -11\n#define BGP_ERR_AS_MISMATCH                     -12\n#define BGP_ERR_PEER_FLAG_CONFLICT              -13\n#define BGP_ERR_PEER_GROUP_SHUTDOWN             -14\n#define BGP_ERR_PEER_FILTER_CONFLICT            -15\n#define BGP_ERR_NOT_INTERNAL_PEER               -16\n#define BGP_ERR_REMOVE_PRIVATE_AS               -17\n#define BGP_ERR_AF_UNCONFIGURED                 -18\n#define BGP_ERR_SOFT_RECONFIG_UNCONFIGURED      -19\n#define BGP_ERR_INSTANCE_MISMATCH               -20\n#define BGP_ERR_LOCAL_AS_ALLOWED_ONLY_FOR_EBGP  -21\n#define BGP_ERR_CANNOT_HAVE_LOCAL_AS_SAME_AS    -22\n#define BGP_ERR_TCPSIG_FAILED\t\t\t-23\n#define BGP_ERR_NO_EBGP_MULTIHOP_WITH_TTLHACK\t-24\n#define BGP_ERR_NO_IBGP_WITH_TTLHACK\t\t-25\n#define BGP_ERR_NO_INTERFACE_CONFIG             -26\n#define BGP_ERR_CANNOT_HAVE_LOCAL_AS_SAME_AS_REMOTE_AS    -27\n#define BGP_ERR_AS_OVERRIDE                     -28\n#define BGP_ERR_INVALID_DYNAMIC_NEIGHBORS_LIMIT -29\n#define BGP_ERR_DYNAMIC_NEIGHBORS_RANGE_EXISTS  -30\n#define BGP_ERR_DYNAMIC_NEIGHBORS_RANGE_NOT_FOUND -31\n#define BGP_ERR_INVALID_FOR_DYNAMIC_PEER        -32\n#define BGP_ERR_MAX                             -33\n#define BGP_ERR_INVALID_FOR_DIRECT_PEER         -34\n#define BGP_ERR_PEER_SAFI_CONFLICT              -35\n\n/*\n * Enumeration of different policy kinds a peer can be configured with.\n */\ntypedef enum {\n\tBGP_POLICY_ROUTE_MAP,\n\tBGP_POLICY_FILTER_LIST,\n\tBGP_POLICY_PREFIX_LIST,\n\tBGP_POLICY_DISTRIBUTE_LIST,\n} bgp_policy_type_e;\n\n/* peer_flag_change_type. */\nenum peer_change_type {\n\tpeer_change_none,\n\tpeer_change_reset,\n\tpeer_change_reset_in,\n\tpeer_change_reset_out,\n};\n\nextern struct bgp_master *bm;\nextern unsigned int multipath_num;\n\n/* Prototypes. */\nextern void bgp_terminate(void);\nextern void bgp_reset(void);\nextern time_t bgp_clock(void);\nextern void bgp_zclient_reset(void);\nextern struct bgp *bgp_get_default(void);\nextern struct bgp *bgp_lookup(as_t, const char *);\nextern struct bgp *bgp_lookup_by_name(const char *);\nextern struct bgp *bgp_lookup_by_vrf_id(vrf_id_t);\nextern struct peer *peer_lookup(struct bgp *, union sockunion *);\nextern struct peer *peer_lookup_by_conf_if(struct bgp *, const char *);\nextern struct peer *peer_lookup_by_hostname(struct bgp *, const char *);\nextern void bgp_peer_conf_if_to_su_update(struct peer *);\nextern int peer_group_listen_range_del(struct peer_group *, struct prefix *);\nextern struct peer_group *peer_group_lookup(struct bgp *, const char *);\nextern struct peer_group *peer_group_get(struct bgp *, const char *);\nextern struct peer *peer_create_bind_dynamic_neighbor(struct bgp *,\n\t\t\t\t\t\t      union sockunion *,\n\t\t\t\t\t\t      struct peer_group *);\nextern struct prefix *\npeer_group_lookup_dynamic_neighbor_range(struct peer_group *, struct prefix *);\nextern struct peer_group *peer_group_lookup_dynamic_neighbor(struct bgp *,\n\t\t\t\t\t\t\t     struct prefix *,\n\t\t\t\t\t\t\t     struct prefix **);\nextern struct peer *peer_lookup_dynamic_neighbor(struct bgp *,\n\t\t\t\t\t\t union sockunion *);\n\n/*\n * Peers are incredibly easy to memory leak\n * due to the various ways that they are actually used\n * Provide some functionality to debug locks and unlocks\n */\nextern struct peer *peer_lock_with_caller(const char *, struct peer *);\nextern struct peer *peer_unlock_with_caller(const char *, struct peer *);\n#define peer_unlock(A) peer_unlock_with_caller(__FUNCTION__, (A))\n#define peer_lock(B) peer_lock_with_caller(__FUNCTION__, (B))\n\nextern bgp_peer_sort_t peer_sort(struct peer *peer);\nextern int peer_active(struct peer *);\nextern int peer_active_nego(struct peer *);\nextern void bgp_recalculate_all_bestpaths(struct bgp *bgp);\nextern struct peer *peer_create(union sockunion *, const char *, struct bgp *,\n\t\t\t\tas_t, as_t, int, afi_t, safi_t,\n\t\t\t\tstruct peer_group *);\nextern struct peer *peer_create_accept(struct bgp *);\nextern void peer_xfer_config(struct peer *dst, struct peer *src);\nextern char *peer_uptime(time_t uptime2, char *buf, size_t len, bool use_json,\n\t\t\t json_object *json);\n\nextern int bgp_config_write(struct vty *);\n\nextern void bgp_master_init(struct thread_master *master);\n\nextern void bgp_init(unsigned short instance);\nextern void bgp_pthreads_run(void);\nextern void bgp_pthreads_finish(void);\nextern void bgp_route_map_init(void);\nextern void bgp_session_reset(struct peer *);\n\nextern int bgp_option_set(int);\nextern int bgp_option_unset(int);\nextern int bgp_option_check(int);\n\nextern int bgp_get(struct bgp **, as_t *, const char *, enum bgp_instance_type);\nextern void bgp_instance_up(struct bgp *);\nextern void bgp_instance_down(struct bgp *);\nextern int bgp_delete(struct bgp *);\n\nextern int bgp_handle_socket(struct bgp *bgp, struct vrf *vrf,\n\t\t\t     vrf_id_t old_vrf_id, bool create);\n\nextern int bgp_flag_set(struct bgp *, int);\nextern int bgp_flag_unset(struct bgp *, int);\nextern int bgp_flag_check(struct bgp *, int);\n\nextern void bgp_router_id_zebra_bump(vrf_id_t, const struct prefix *);\nextern int bgp_router_id_static_set(struct bgp *, struct in_addr);\n\nextern int bgp_cluster_id_set(struct bgp *, struct in_addr *);\nextern int bgp_cluster_id_unset(struct bgp *);\n\nextern int bgp_confederation_id_set(struct bgp *, as_t);\nextern int bgp_confederation_id_unset(struct bgp *);\nextern int bgp_confederation_peers_check(struct bgp *, as_t);\n\nextern int bgp_confederation_peers_add(struct bgp *, as_t);\nextern int bgp_confederation_peers_remove(struct bgp *, as_t);\n\nextern int bgp_timers_set(struct bgp *, uint32_t keepalive, uint32_t holdtime);\nextern int bgp_timers_unset(struct bgp *);\n\nextern int bgp_default_local_preference_set(struct bgp *, uint32_t);\nextern int bgp_default_local_preference_unset(struct bgp *);\n\nextern int bgp_default_subgroup_pkt_queue_max_set(struct bgp *bgp, uint32_t);\nextern int bgp_default_subgroup_pkt_queue_max_unset(struct bgp *bgp);\n\nextern int bgp_listen_limit_set(struct bgp *, int);\nextern int bgp_listen_limit_unset(struct bgp *);\n\nextern int bgp_update_delay_active(struct bgp *);\nextern int bgp_update_delay_configured(struct bgp *);\nextern int bgp_afi_safi_peer_exists(struct bgp *bgp, afi_t afi, safi_t safi);\nextern void peer_as_change(struct peer *, as_t, int);\nextern int peer_remote_as(struct bgp *, union sockunion *, const char *, as_t *,\n\t\t\t  int, afi_t, safi_t);\nextern int peer_group_remote_as(struct bgp *, const char *, as_t *, int);\nextern int peer_delete(struct peer *peer);\nextern int peer_group_delete(struct peer_group *);\nextern int peer_group_remote_as_delete(struct peer_group *);\nextern int peer_group_listen_range_add(struct peer_group *, struct prefix *);\n\nextern int peer_activate(struct peer *, afi_t, safi_t);\nextern int peer_deactivate(struct peer *, afi_t, safi_t);\nextern int peer_afc_set(struct peer *, afi_t, safi_t, int);\n\nextern int peer_group_bind(struct bgp *, union sockunion *, struct peer *,\n\t\t\t   struct peer_group *, as_t *);\n\nextern int peer_flag_set(struct peer *, uint32_t);\nextern int peer_flag_unset(struct peer *, uint32_t);\nextern void peer_flag_inherit(struct peer *peer, uint32_t flag);\n\nextern int peer_af_flag_set(struct peer *, afi_t, safi_t, uint32_t);\nextern int peer_af_flag_unset(struct peer *, afi_t, safi_t, uint32_t);\nextern int peer_af_flag_check(struct peer *, afi_t, safi_t, uint32_t);\nextern void peer_af_flag_inherit(struct peer *peer, afi_t afi, safi_t safi,\n\t\t\t\t uint32_t flag);\nextern void peer_change_action(struct peer *peer, afi_t afi, safi_t safi,\n\t\t\t       enum peer_change_type type);\n\nextern int peer_ebgp_multihop_set(struct peer *, int);\nextern int peer_ebgp_multihop_unset(struct peer *);\nextern int is_ebgp_multihop_configured(struct peer *peer);\n\nextern int peer_description_set(struct peer *, const char *);\nextern int peer_description_unset(struct peer *);\n\nextern int peer_update_source_if_set(struct peer *, const char *);\nextern int peer_update_source_addr_set(struct peer *, const union sockunion *);\nextern int peer_update_source_unset(struct peer *);\n\nextern int peer_default_originate_set(struct peer *peer, afi_t afi, safi_t safi,\n\t\t\t\t      const char *rmap,\n\t\t\t\t      struct route_map *route_map);\nextern int peer_default_originate_unset(struct peer *, afi_t, safi_t);\n\nextern int peer_port_set(struct peer *, uint16_t);\nextern int peer_port_unset(struct peer *);\n\nextern int peer_weight_set(struct peer *, afi_t, safi_t, uint16_t);\nextern int peer_weight_unset(struct peer *, afi_t, safi_t);\n\nextern int peer_timers_set(struct peer *, uint32_t keepalive,\n\t\t\t   uint32_t holdtime);\nextern int peer_timers_unset(struct peer *);\n\nextern int peer_timers_connect_set(struct peer *, uint32_t);\nextern int peer_timers_connect_unset(struct peer *);\n\nextern int peer_advertise_interval_set(struct peer *, uint32_t);\nextern int peer_advertise_interval_unset(struct peer *);\n\nextern void peer_interface_set(struct peer *, const char *);\nextern void peer_interface_unset(struct peer *);\n\nextern int peer_distribute_set(struct peer *, afi_t, safi_t, int, const char *);\nextern int peer_distribute_unset(struct peer *, afi_t, safi_t, int);\n\nextern int peer_allowas_in_set(struct peer *, afi_t, safi_t, int, int);\nextern int peer_allowas_in_unset(struct peer *, afi_t, safi_t);\n\nextern int peer_local_as_set(struct peer *, as_t, int, int);\nextern int peer_local_as_unset(struct peer *);\n\nextern int peer_prefix_list_set(struct peer *, afi_t, safi_t, int,\n\t\t\t\tconst char *);\nextern int peer_prefix_list_unset(struct peer *, afi_t, safi_t, int);\n\nextern int peer_aslist_set(struct peer *, afi_t, safi_t, int, const char *);\nextern int peer_aslist_unset(struct peer *, afi_t, safi_t, int);\n\nextern int peer_route_map_set(struct peer *peer, afi_t afi, safi_t safi, int,\n\t\t\t      const char *name, struct route_map *route_map);\nextern int peer_route_map_unset(struct peer *, afi_t, safi_t, int);\n\nextern int peer_unsuppress_map_set(struct peer *peer, afi_t afi, safi_t safi,\n\t\t\t\t   const char *name,\n\t\t\t\t   struct route_map *route_map);\n\nextern int peer_password_set(struct peer *, const char *);\nextern int peer_password_unset(struct peer *);\n\nextern int peer_unsuppress_map_unset(struct peer *, afi_t, safi_t);\n\nextern int peer_maximum_prefix_set(struct peer *, afi_t, safi_t, uint32_t,\n\t\t\t\t   uint8_t, int, uint16_t);\nextern int peer_maximum_prefix_unset(struct peer *, afi_t, safi_t);\n\nextern int peer_clear(struct peer *, struct listnode **);\nextern int peer_clear_soft(struct peer *, afi_t, safi_t, enum bgp_clear_type);\n\nextern int peer_ttl_security_hops_set(struct peer *, int);\nextern int peer_ttl_security_hops_unset(struct peer *);\n\nextern int peer_tx_shutdown_message_set(struct peer *, const char *msg);\nextern int peer_tx_shutdown_message_unset(struct peer *);\n\nextern int bgp_route_map_update_timer(struct thread *thread);\nextern void bgp_route_map_terminate(void);\n\nextern int peer_cmp(struct peer *p1, struct peer *p2);\n\nextern int bgp_map_afi_safi_iana2int(iana_afi_t pkt_afi, iana_safi_t pkt_safi,\n\t\t\t\t     afi_t *afi, safi_t *safi);\nextern int bgp_map_afi_safi_int2iana(afi_t afi, safi_t safi,\n\t\t\t\t     iana_afi_t *pkt_afi,\n\t\t\t\t     iana_safi_t *pkt_safi);\n\nextern struct peer_af *peer_af_create(struct peer *, afi_t, safi_t);\nextern struct peer_af *peer_af_find(struct peer *, afi_t, safi_t);\nextern int peer_af_delete(struct peer *, afi_t, safi_t);\n\nextern void bgp_close(void);\nextern void bgp_free(struct bgp *);\n\nstatic inline struct bgp *bgp_lock(struct bgp *bgp)\n{\n\tbgp->lock++;\n\treturn bgp;\n}\n\nstatic inline void bgp_unlock(struct bgp *bgp)\n{\n\tassert(bgp->lock > 0);\n\tif (--bgp->lock == 0)\n\t\tbgp_free(bgp);\n}\n\nstatic inline int afindex(afi_t afi, safi_t safi)\n{\n\tswitch (afi) {\n\tcase AFI_IP:\n\t\tswitch (safi) {\n\t\tcase SAFI_UNICAST:\n\t\t\treturn BGP_AF_IPV4_UNICAST;\n\t\t\tbreak;\n\t\tcase SAFI_MULTICAST:\n\t\t\treturn BGP_AF_IPV4_MULTICAST;\n\t\t\tbreak;\n\t\tcase SAFI_LABELED_UNICAST:\n\t\t\treturn BGP_AF_IPV4_LBL_UNICAST;\n\t\t\tbreak;\n\t\tcase SAFI_MPLS_VPN:\n\t\t\treturn BGP_AF_IPV4_VPN;\n\t\t\tbreak;\n\t\tcase SAFI_ENCAP:\n\t\t\treturn BGP_AF_IPV4_ENCAP;\n\t\t\tbreak;\n\t\tcase SAFI_FLOWSPEC:\n\t\t\treturn BGP_AF_IPV4_FLOWSPEC;\n\t\tdefault:\n\t\t\treturn BGP_AF_MAX;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AFI_IP6:\n\t\tswitch (safi) {\n\t\tcase SAFI_UNICAST:\n\t\t\treturn BGP_AF_IPV6_UNICAST;\n\t\t\tbreak;\n\t\tcase SAFI_MULTICAST:\n\t\t\treturn BGP_AF_IPV6_MULTICAST;\n\t\t\tbreak;\n\t\tcase SAFI_LABELED_UNICAST:\n\t\t\treturn BGP_AF_IPV6_LBL_UNICAST;\n\t\t\tbreak;\n\t\tcase SAFI_MPLS_VPN:\n\t\t\treturn BGP_AF_IPV6_VPN;\n\t\t\tbreak;\n\t\tcase SAFI_ENCAP:\n\t\t\treturn BGP_AF_IPV6_ENCAP;\n\t\t\tbreak;\n\t\tcase SAFI_FLOWSPEC:\n\t\t\treturn BGP_AF_IPV6_FLOWSPEC;\n\t\tdefault:\n\t\t\treturn BGP_AF_MAX;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AFI_L2VPN:\n\t\tswitch (safi) {\n\t\tcase SAFI_EVPN:\n\t\t\treturn BGP_AF_L2VPN_EVPN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn BGP_AF_MAX;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn BGP_AF_MAX;\n\t\tbreak;\n\t}\n}\n\n/* If the peer is not a peer-group but is bound to a peer-group return 1 */\nstatic inline int peer_group_active(struct peer *peer)\n{\n\tif (!CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP) && peer->group)\n\t\treturn 1;\n\treturn 0;\n}\n\n/* If peer is negotiated at least one address family return 1. */\nstatic inline int peer_afi_active_nego(const struct peer *peer, afi_t afi)\n{\n\tif (peer->afc_nego[afi][SAFI_UNICAST]\n\t    || peer->afc_nego[afi][SAFI_MULTICAST]\n\t    || peer->afc_nego[afi][SAFI_LABELED_UNICAST]\n\t    || peer->afc_nego[afi][SAFI_MPLS_VPN]\n\t    || peer->afc_nego[afi][SAFI_ENCAP]\n\t    || peer->afc_nego[afi][SAFI_FLOWSPEC]\n\t    || peer->afc_nego[afi][SAFI_EVPN])\n\t\treturn 1;\n\treturn 0;\n}\n\n/* If at least one address family activated for group, return 1. */\nstatic inline int peer_group_af_configured(struct peer_group *group)\n{\n\tstruct peer *peer = group->conf;\n\n\tif (peer->afc[AFI_IP][SAFI_UNICAST] || peer->afc[AFI_IP][SAFI_MULTICAST]\n\t    || peer->afc[AFI_IP][SAFI_LABELED_UNICAST]\n\t    || peer->afc[AFI_IP][SAFI_FLOWSPEC]\n\t    || peer->afc[AFI_IP][SAFI_MPLS_VPN] || peer->afc[AFI_IP][SAFI_ENCAP]\n\t    || peer->afc[AFI_IP6][SAFI_UNICAST]\n\t    || peer->afc[AFI_IP6][SAFI_MULTICAST]\n\t    || peer->afc[AFI_IP6][SAFI_LABELED_UNICAST]\n\t    || peer->afc[AFI_IP6][SAFI_MPLS_VPN]\n\t    || peer->afc[AFI_IP6][SAFI_ENCAP]\n\t    || peer->afc[AFI_IP6][SAFI_FLOWSPEC]\n\t    || peer->afc[AFI_L2VPN][SAFI_EVPN])\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline char *timestamp_string(time_t ts)\n{\n\ttime_t tbuf;\n\ttbuf = time(NULL) - (bgp_clock() - ts);\n\treturn ctime(&tbuf);\n}\n\nstatic inline int peer_established(struct peer *peer)\n{\n\tif (peer->status == Established)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int peer_dynamic_neighbor(struct peer *peer)\n{\n\treturn (CHECK_FLAG(peer->flags, PEER_FLAG_DYNAMIC_NEIGHBOR)) ? 1 : 0;\n}\n\nstatic inline int peer_cap_enhe(struct peer *peer, afi_t afi, safi_t safi)\n{\n\treturn (CHECK_FLAG(peer->af_cap[afi][safi], PEER_CAP_ENHE_AF_NEGO));\n}\n\n/* Lookup VRF for BGP instance based on its type. */\nstatic inline struct vrf *bgp_vrf_lookup_by_instance_type(struct bgp *bgp)\n{\n\tstruct vrf *vrf;\n\n\tif (bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT)\n\t\tvrf = vrf_lookup_by_id(VRF_DEFAULT);\n\telse if (bgp->inst_type == BGP_INSTANCE_TYPE_VRF)\n\t\tvrf = vrf_lookup_by_name(bgp->name);\n\telse\n\t\tvrf = NULL;\n\n\treturn vrf;\n}\n\n/* Link BGP instance to VRF. */\nstatic inline void bgp_vrf_link(struct bgp *bgp, struct vrf *vrf)\n{\n\tbgp->vrf_id = vrf->vrf_id;\n\tif (vrf->info != (void *)bgp)\n\t\tvrf->info = (void *)bgp_lock(bgp);\n}\n\n/* Unlink BGP instance from VRF. */\nstatic inline void bgp_vrf_unlink(struct bgp *bgp, struct vrf *vrf)\n{\n\tif (vrf->info == (void *)bgp) {\n\t\tvrf->info = NULL;\n\t\tbgp_unlock(bgp);\n\t}\n\tbgp->vrf_id = VRF_UNKNOWN;\n}\n\nextern void bgp_update_redist_vrf_bitmaps(struct bgp *, vrf_id_t);\n\n/* For benefit of rfapi */\nextern struct peer *peer_new(struct bgp *bgp);\n#endif /* _QUAGGA_BGPD_H */\n"], "filenames": ["bgpd/bgp_attr.c", "bgpd/bgpd.h"], "buggy_code_start_loc": [81, 1283], "buggy_code_end_loc": [3437, 1284], "fixing_code_start_loc": [81, 1283], "fixing_code_end_loc": [3437, 1284], "type": "CWE-436", "message": "bgpd in FRRouting FRR (aka Free Range Routing) 2.x and 3.x before 3.0.4, 4.x before 4.0.1, 5.x before 5.0.2, and 6.x before 6.0.2 (not affecting Cumulus Linux or VyOS), when ENABLE_BGP_VNC is used for Virtual Network Control, allows remote attackers to cause a denial of service (peering session flap) via attribute 255 in a BGP UPDATE packet. This occurred during Disco in January 2019 because FRR does not implement RFC 7606, and therefore the packets with 255 were considered invalid VNC data and the BGP session was closed.", "other": {"cve": {"id": "CVE-2019-5892", "sourceIdentifier": "cve@mitre.org", "published": "2019-01-10T17:29:00.333", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "bgpd in FRRouting FRR (aka Free Range Routing) 2.x and 3.x before 3.0.4, 4.x before 4.0.1, 5.x before 5.0.2, and 6.x before 6.0.2 (not affecting Cumulus Linux or VyOS), when ENABLE_BGP_VNC is used for Virtual Network Control, allows remote attackers to cause a denial of service (peering session flap) via attribute 255 in a BGP UPDATE packet. This occurred during Disco in January 2019 because FRR does not implement RFC 7606, and therefore the packets with 255 were considered invalid VNC data and the BGP session was closed."}, {"lang": "es", "value": "bgpd en FRRouting FRR (tambi\u00e9n conocido como Free Range Routing), en versiones 2.x y 3.x anteriores a la 3.0.4, versiones 4.x anteriores a la 4.0.1, versiones 5.x anteriores a la 5.0.2 y versiones 6.x anteriores a la 6.0.2 (no afecta a Cumulus Linux o VyOS), cuando ENABLE_BGP_VNC se emplea para Virtual Network Control, permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (flap de la sesi\u00f3n de emparejamiento) mediante el atributo 255 en un paquete BGP UPDATE. Esto ocurri\u00f3 durante Disco en enero de 2019 debido a que FRR no implementa RFC 7606 y, por lo tanto, los paquetes con 255 se consideraron datos VNC inv\u00e1lidos y la sesi\u00f3n BGP se cerr\u00f3."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-436"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:frrouting:frrouting:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0", "versionEndIncluding": "2.0.2", "matchCriteriaId": "2EB9C06A-DC04-433E-9012-B139F04DC7DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:frrouting:frrouting:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0", "versionEndExcluding": "3.0.4", "matchCriteriaId": "B42930C4-9A88-4F82-9D58-DA25C755D240"}, {"vulnerable": true, "criteria": "cpe:2.3:a:frrouting:frrouting:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0", "versionEndExcluding": "5.0.2", "matchCriteriaId": "D9572E38-F6C9-436E-A64D-AE2F6DC6149A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:frrouting:frrouting:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0", "versionEndExcluding": "6.0.2", "matchCriteriaId": "2E4F4AF6-15F5-4D84-AA45-410F192FD0B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:frrouting:frrouting:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "1B24931C-786E-4AAE-B942-309B9E4D97A9"}]}]}], "references": [{"url": "https://frrouting.org/community/security/cve-2019-5892.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/FRRouting/frr/commit/943d595a018e69b550db08cccba1d0778a86705a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FRRouting/frr/releases/tag/frr-3.0.4", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/FRRouting/frr/releases/tag/frr-4.0.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/FRRouting/frr/releases/tag/frr-5.0.2", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/FRRouting/frr/releases/tag/frr-6.0.2", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.frrouting.org/pipermail/frog/2019-January/000404.html", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/FRRouting/frr/commit/943d595a018e69b550db08cccba1d0778a86705a"}}