{"buggy_code": ["/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <memory>\n#include <string>\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/resource_mgr.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/kernels/boosted_trees/resources.h\"\n#include \"tensorflow/core/lib/core/refcount.h\"\n\nnamespace tensorflow {\n\nREGISTER_RESOURCE_HANDLE_KERNEL(BoostedTreesEnsembleResource);\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"IsBoostedTreesEnsembleInitialized\").Device(DEVICE_CPU),\n    IsResourceInitialized<BoostedTreesEnsembleResource>);\n\n// Creates a tree ensemble resource.\nclass BoostedTreesCreateEnsembleOp : public OpKernel {\n public:\n  explicit BoostedTreesCreateEnsembleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    // Get the stamp token.\n    const Tensor* stamp_token_t;\n    OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n    int64_t stamp_token = stamp_token_t->scalar<int64>()();\n\n    // Get the tree ensemble proto.\n    const Tensor* tree_ensemble_serialized_t;\n    OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                           &tree_ensemble_serialized_t));\n    std::unique_ptr<BoostedTreesEnsembleResource> result(\n        new BoostedTreesEnsembleResource());\n    if (!result->InitFromSerialized(\n            tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token)) {\n      result->Unref();\n      OP_REQUIRES(\n          context, false,\n          errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n    }\n\n    // Only create one, if one does not exist already. Report status for all\n    // other exceptions.\n    auto status =\n        CreateResource(context, HandleFromInput(context, 0), result.release());\n    if (status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES_OK(context, status);\n    }\n  }\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"BoostedTreesCreateEnsemble\").Device(DEVICE_CPU),\n                        BoostedTreesCreateEnsembleOp);\n\n// Op for retrieving some model states (needed for training).\nclass BoostedTreesGetEnsembleStatesOp : public OpKernel {\n public:\n  explicit BoostedTreesGetEnsembleStatesOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    // Looks up the resource.\n    core::RefCountPtr<BoostedTreesEnsembleResource> tree_ensemble_resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &tree_ensemble_resource));\n    tf_shared_lock l(*tree_ensemble_resource->get_mutex());\n\n    // Sets the outputs.\n    const int num_trees = tree_ensemble_resource->num_trees();\n    const int num_finalized_trees =\n        (num_trees <= 0 ||\n         tree_ensemble_resource->IsTreeFinalized(num_trees - 1))\n            ? num_trees\n            : num_trees - 1;\n    const int num_attempted_layers =\n        tree_ensemble_resource->GetNumLayersAttempted();\n\n    // growing_metadata\n    Tensor* output_stamp_token_t = nullptr;\n    Tensor* output_num_trees_t = nullptr;\n    Tensor* output_num_finalized_trees_t = nullptr;\n    Tensor* output_num_attempted_layers_t = nullptr;\n    Tensor* output_last_layer_nodes_range_t = nullptr;\n\n    OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape(),\n                                                     &output_stamp_token_t));\n    OP_REQUIRES_OK(context, context->allocate_output(1, TensorShape(),\n                                                     &output_num_trees_t));\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(2, TensorShape(),\n                                            &output_num_finalized_trees_t));\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(3, TensorShape(),\n                                            &output_num_attempted_layers_t));\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                4, {2}, &output_last_layer_nodes_range_t));\n\n    output_stamp_token_t->scalar<int64>()() = tree_ensemble_resource->stamp();\n    output_num_trees_t->scalar<int32>()() = num_trees;\n    output_num_finalized_trees_t->scalar<int32>()() = num_finalized_trees;\n    output_num_attempted_layers_t->scalar<int32>()() = num_attempted_layers;\n\n    int32_t range_start;\n    int32_t range_end;\n    tree_ensemble_resource->GetLastLayerNodesRange(&range_start, &range_end);\n\n    output_last_layer_nodes_range_t->vec<int32>()(0) = range_start;\n    // For a completely empty ensemble, this will be 0. To make it a valid range\n    // we add this max cond.\n    output_last_layer_nodes_range_t->vec<int32>()(1) = std::max(1, range_end);\n  }\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesGetEnsembleStates\").Device(DEVICE_CPU),\n    BoostedTreesGetEnsembleStatesOp);\n\n// Op for serializing a model.\nclass BoostedTreesSerializeEnsembleOp : public OpKernel {\n public:\n  explicit BoostedTreesSerializeEnsembleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> tree_ensemble_resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &tree_ensemble_resource));\n    tf_shared_lock l(*tree_ensemble_resource->get_mutex());\n    Tensor* output_stamp_token_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape(),\n                                                     &output_stamp_token_t));\n    output_stamp_token_t->scalar<int64>()() = tree_ensemble_resource->stamp();\n    Tensor* output_proto_t = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, TensorShape(), &output_proto_t));\n    output_proto_t->scalar<tstring>()() =\n        tree_ensemble_resource->SerializeAsString();\n  }\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesSerializeEnsemble\").Device(DEVICE_CPU),\n    BoostedTreesSerializeEnsembleOp);\n\n// Op for deserializing a tree ensemble variable from a checkpoint.\nclass BoostedTreesDeserializeEnsembleOp : public OpKernel {\n public:\n  explicit BoostedTreesDeserializeEnsembleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> tree_ensemble_resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &tree_ensemble_resource));\n    mutex_lock l(*tree_ensemble_resource->get_mutex());\n\n    // Get the stamp token.\n    const Tensor* stamp_token_t;\n    OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n    int64_t stamp_token = stamp_token_t->scalar<int64>()();\n\n    // Get the tree ensemble proto.\n    const Tensor* tree_ensemble_serialized_t;\n    OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                           &tree_ensemble_serialized_t));\n    // Deallocate all the previous objects on the resource.\n    tree_ensemble_resource->Reset();\n    OP_REQUIRES(\n        context,\n        tree_ensemble_resource->InitFromSerialized(\n            tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token),\n        errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n  }\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesDeserializeEnsemble\").Device(DEVICE_CPU),\n    BoostedTreesDeserializeEnsembleOp);\n\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <memory>\n#include <string>\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/resource_mgr.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/kernels/boosted_trees/resources.h\"\n#include \"tensorflow/core/lib/core/refcount.h\"\n\nnamespace tensorflow {\n\nREGISTER_RESOURCE_HANDLE_KERNEL(BoostedTreesEnsembleResource);\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"IsBoostedTreesEnsembleInitialized\").Device(DEVICE_CPU),\n    IsResourceInitialized<BoostedTreesEnsembleResource>);\n\n// Creates a tree ensemble resource.\nclass BoostedTreesCreateEnsembleOp : public OpKernel {\n public:\n  explicit BoostedTreesCreateEnsembleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    // Get the stamp token.\n    const Tensor* stamp_token_t;\n    OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n    int64_t stamp_token = stamp_token_t->scalar<int64>()();\n\n    // Get the tree ensemble proto.\n    const Tensor* tree_ensemble_serialized_t;\n    OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                           &tree_ensemble_serialized_t));\n    std::unique_ptr<BoostedTreesEnsembleResource> result(\n        new BoostedTreesEnsembleResource());\n    if (!result->InitFromSerialized(\n            tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token)) {\n      result->Unref();\n      result.release();  // Needed due to the `->Unref` above, to prevent UAF\n      OP_REQUIRES(\n          context, false,\n          errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n    }\n\n    // Only create one, if one does not exist already. Report status for all\n    // other exceptions.\n    auto status =\n        CreateResource(context, HandleFromInput(context, 0), result.release());\n    if (status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES_OK(context, status);\n    }\n  }\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"BoostedTreesCreateEnsemble\").Device(DEVICE_CPU),\n                        BoostedTreesCreateEnsembleOp);\n\n// Op for retrieving some model states (needed for training).\nclass BoostedTreesGetEnsembleStatesOp : public OpKernel {\n public:\n  explicit BoostedTreesGetEnsembleStatesOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    // Looks up the resource.\n    core::RefCountPtr<BoostedTreesEnsembleResource> tree_ensemble_resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &tree_ensemble_resource));\n    tf_shared_lock l(*tree_ensemble_resource->get_mutex());\n\n    // Sets the outputs.\n    const int num_trees = tree_ensemble_resource->num_trees();\n    const int num_finalized_trees =\n        (num_trees <= 0 ||\n         tree_ensemble_resource->IsTreeFinalized(num_trees - 1))\n            ? num_trees\n            : num_trees - 1;\n    const int num_attempted_layers =\n        tree_ensemble_resource->GetNumLayersAttempted();\n\n    // growing_metadata\n    Tensor* output_stamp_token_t = nullptr;\n    Tensor* output_num_trees_t = nullptr;\n    Tensor* output_num_finalized_trees_t = nullptr;\n    Tensor* output_num_attempted_layers_t = nullptr;\n    Tensor* output_last_layer_nodes_range_t = nullptr;\n\n    OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape(),\n                                                     &output_stamp_token_t));\n    OP_REQUIRES_OK(context, context->allocate_output(1, TensorShape(),\n                                                     &output_num_trees_t));\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(2, TensorShape(),\n                                            &output_num_finalized_trees_t));\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(3, TensorShape(),\n                                            &output_num_attempted_layers_t));\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                4, {2}, &output_last_layer_nodes_range_t));\n\n    output_stamp_token_t->scalar<int64>()() = tree_ensemble_resource->stamp();\n    output_num_trees_t->scalar<int32>()() = num_trees;\n    output_num_finalized_trees_t->scalar<int32>()() = num_finalized_trees;\n    output_num_attempted_layers_t->scalar<int32>()() = num_attempted_layers;\n\n    int32_t range_start;\n    int32_t range_end;\n    tree_ensemble_resource->GetLastLayerNodesRange(&range_start, &range_end);\n\n    output_last_layer_nodes_range_t->vec<int32>()(0) = range_start;\n    // For a completely empty ensemble, this will be 0. To make it a valid range\n    // we add this max cond.\n    output_last_layer_nodes_range_t->vec<int32>()(1) = std::max(1, range_end);\n  }\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesGetEnsembleStates\").Device(DEVICE_CPU),\n    BoostedTreesGetEnsembleStatesOp);\n\n// Op for serializing a model.\nclass BoostedTreesSerializeEnsembleOp : public OpKernel {\n public:\n  explicit BoostedTreesSerializeEnsembleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> tree_ensemble_resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &tree_ensemble_resource));\n    tf_shared_lock l(*tree_ensemble_resource->get_mutex());\n    Tensor* output_stamp_token_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape(),\n                                                     &output_stamp_token_t));\n    output_stamp_token_t->scalar<int64>()() = tree_ensemble_resource->stamp();\n    Tensor* output_proto_t = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, TensorShape(), &output_proto_t));\n    output_proto_t->scalar<tstring>()() =\n        tree_ensemble_resource->SerializeAsString();\n  }\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesSerializeEnsemble\").Device(DEVICE_CPU),\n    BoostedTreesSerializeEnsembleOp);\n\n// Op for deserializing a tree ensemble variable from a checkpoint.\nclass BoostedTreesDeserializeEnsembleOp : public OpKernel {\n public:\n  explicit BoostedTreesDeserializeEnsembleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> tree_ensemble_resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &tree_ensemble_resource));\n    mutex_lock l(*tree_ensemble_resource->get_mutex());\n\n    // Get the stamp token.\n    const Tensor* stamp_token_t;\n    OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n    int64_t stamp_token = stamp_token_t->scalar<int64>()();\n\n    // Get the tree ensemble proto.\n    const Tensor* tree_ensemble_serialized_t;\n    OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                           &tree_ensemble_serialized_t));\n    // Deallocate all the previous objects on the resource.\n    tree_ensemble_resource->Reset();\n    OP_REQUIRES(\n        context,\n        tree_ensemble_resource->InitFromSerialized(\n            tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token),\n        errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n  }\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesDeserializeEnsemble\").Device(DEVICE_CPU),\n    BoostedTreesDeserializeEnsembleOp);\n\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/boosted_trees/resource_ops.cc"], "buggy_code_start_loc": [55], "buggy_code_end_loc": [55], "fixing_code_start_loc": [56], "fixing_code_end_loc": [57], "type": "CWE-415", "message": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.BoostedTreesCreateEnsemble` can result in a use after free error if an attacker supplies specially crafted arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/boosted_trees/resource_ops.cc#L55) uses a reference counted resource and decrements the refcount if the initialization fails, as it should. However, when the code was written, the resource was represented as a naked pointer but later refactoring has changed it to be a smart pointer. Thus, when the pointer leaves the scope, a subsequent `free`-ing of the resource occurs, but this fails to take into account that the refcount has already reached 0, thus the resource has been already freed. During this double-free process, members of the resource object are accessed for cleanup but they are invalid as the entire resource has been freed. We have patched the issue in GitHub commit 5ecec9c6fbdbc6be03295685190a45e7eee726ab. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-37652", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-12T22:15:08.130", "lastModified": "2022-10-25T16:03:54.407", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.BoostedTreesCreateEnsemble` can result in a use after free error if an attacker supplies specially crafted arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/boosted_trees/resource_ops.cc#L55) uses a reference counted resource and decrements the refcount if the initialization fails, as it should. However, when the code was written, the resource was represented as a naked pointer but later refactoring has changed it to be a smart pointer. Thus, when the pointer leaves the scope, a subsequent `free`-ing of the resource occurs, but this fails to take into account that the refcount has already reached 0, thus the resource has been already freed. During this double-free process, members of the resource object are accessed for cleanup but they are invalid as the entire resource has been freed. We have patched the issue in GitHub commit 5ecec9c6fbdbc6be03295685190a45e7eee726ab. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico. En las versiones afectadas, la implementaci\u00f3n  \"tf.raw_ops.BoostedTreesCreateEnsemble\" puede dar lugar a un error de uso de memoria previamente liberada si un atacante suministra argumentos especialmente dise\u00f1ados. La [implementaci\u00f3n](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/boosted_trees/resource_ops.cc#L55) usa un recurso contado por referencias y decrementa el refcount si ocurre un fallo en la inicializaci\u00f3n, como deber\u00eda. Sin embargo, cuando se escribi\u00f3 el c\u00f3digo, el recurso se representaba como un puntero desnudo, pero la refactorizaci\u00f3n posterior lo ha cambiado a un puntero inteligente. As\u00ed, cuando el puntero abandona el \u00e1mbito, se produce una \"liberaci\u00f3n\" posterior del recurso, pero \u00e9sta no presenta en cuenta que el refcount ya ha llegado a 0, por lo que el recurso ya ha sido liberado. Durante este proceso de doble liberaci\u00f3n, se accede a los miembros del objeto recurso para su limpieza, pero no son v\u00e1lidos ya que todo el recurso ha sido liberado. Hemos parcheado el problema en el commit 5ecec9c6fbdbc6be03295685190a45e7eee726ab de GitHub. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.6.0. Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.5.1, TensorFlow versi\u00f3n 2.4.3, y TensorFlow versi\u00f3n 2.3.4, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango de soporte."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.4", "matchCriteriaId": "0F83C081-51CC-415F-A8C0-0A44C75E2CD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.3", "matchCriteriaId": "BD3F2BF8-EBA9-42BF-8F9B-D918B880B15A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "D03E99A7-4E3D-427D-A156-C0713E9FB02A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "70FA6E48-6C57-40CA-809F-4E3D07CBF348"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "42187561-E491-434D-828C-F36701446634"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C66B61C8-450A-4C5E-9174-F970D6DEE778"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/5ecec9c6fbdbc6be03295685190a45e7eee726ab", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-m7fm-4jfh-jrg6", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/5ecec9c6fbdbc6be03295685190a45e7eee726ab"}}