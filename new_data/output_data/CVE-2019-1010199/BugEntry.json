{"buggy_code": ["using System;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing ServiceStack.Serialization;\nusing ServiceStack.Templates;\nusing ServiceStack.Web;\n\nnamespace ServiceStack.Formats\n{\n    public class HtmlFormat : IPlugin\n    {\n        public static string TitleFormat\n            = @\"{0} Snapshot of {1}\";\n\n        public static string HtmlTitleFormat\n            = @\"Snapshot of <i>{0}</i> generated by <a href=\"\"https://servicestack.net\"\">ServiceStack</a> on <b>{1}</b>\";\n\n        public static bool Humanize = true;\n\n        private IAppHost AppHost { get; set; }\n\n        public const string ModelKey = \"Model\";\n        public const string ErrorStatusKey = \"__errorStatus\";\n\n        public void Register(IAppHost appHost)\n        {\n            AppHost = appHost;\n            //Register this in ServiceStack with the custom formats\n            appHost.ContentTypes.RegisterAsync(MimeTypes.Html, SerializeToStreamAsync, null);\n            appHost.ContentTypes.RegisterAsync(MimeTypes.JsonReport, SerializeToStreamAsync, null);\n\n            appHost.Config.DefaultContentType = MimeTypes.Html;\n            appHost.Config.IgnoreFormatsInMetadata.Add(MimeTypes.Html.ToContentFormat());\n            appHost.Config.IgnoreFormatsInMetadata.Add(MimeTypes.JsonReport.ToContentFormat());\n        }\n\n        public async Task SerializeToStreamAsync(IRequest req, object response, Stream outputStream)\n        {\n            var res = req.Response;\n            if (req.GetItem(\"HttpResult\") is IHttpResult httpResult && httpResult.Headers.ContainsKey(HttpHeaders.Location) \n                && httpResult.StatusCode != System.Net.HttpStatusCode.Created)  \n                return;\n\n            try\n            {\n                if (res.StatusCode >= 400)\n                {\n                    var responseStatus = response.GetResponseStatus();\n                    req.Items[ErrorStatusKey] = responseStatus;\n                }\n\n                if (response is CompressedResult)\n                {\n                    if (res.Dto != null)\n                        response = res.Dto;\n                    else \n                        throw new ArgumentException(\"Cannot use Cached Result as ViewModel\");\n                }\n\n                foreach (var viewEngine in AppHost.ViewEngines)\n                {\n                    var handled = await viewEngine.ProcessRequestAsync(req, response, outputStream);\n                    if (handled)\n                        return;\n                }\n            }\n            catch (Exception ex)\n            {\n                if (res.StatusCode < 400)\n                    throw;\n\n                //If there was an exception trying to render a Error with a View, \n                //It can't handle errors so just write it out here.\n                response = DtoUtils.CreateErrorResponse(req.Dto, ex);\n            }\n\n            //Handle Exceptions returning string\n            if (req.ResponseContentType == MimeTypes.PlainText)\n            {\n                req.ResponseContentType = MimeTypes.Html;\n                res.ContentType = MimeTypes.Html;\n            }\n\n            if (req.ResponseContentType != MimeTypes.Html && req.ResponseContentType != MimeTypes.JsonReport) \n                return;\n\n            var dto = response.GetDto();\n            if (!(dto is string html))\n            {\n                // Serialize then escape any potential script tags to avoid XSS when displaying as HTML\n                var json = JsonDataContractSerializer.Instance.SerializeToString(dto) ?? \"null\";\n                json = json.Replace(\"<\", \"&lt;\").Replace(\">\", \"&gt;\");\n\n                var url = req.ResolveAbsoluteUrl()\n                    .Replace(\"format=html\", \"\")\n                    .Replace(\"format=shtm\", \"\")\n                    .TrimEnd('?', '&');\n\n                url += url.Contains(\"?\") ? \"&\" : \"?\";\n\n                var now = DateTime.UtcNow;\n                var requestName = req.OperationName ?? dto.GetType().GetOperationName();\n\n                html = HtmlTemplates.GetHtmlFormatTemplate()\n                    .Replace(\"${Dto}\", json)\n                    .Replace(\"${Title}\", string.Format(TitleFormat, requestName, now))\n                    .Replace(\"${MvcIncludes}\", MiniProfiler.Profiler.RenderIncludes().ToString())\n                    .Replace(\"${Header}\", string.Format(HtmlTitleFormat, requestName, now))\n                    .Replace(\"${ServiceUrl}\", url)\n                    .Replace(\"${Humanize}\", Humanize.ToString().ToLower());\n            }\n\n            var utf8Bytes = html.ToUtf8Bytes();\n            await outputStream.WriteAsync(utf8Bytes, 0, utf8Bytes.Length);\n        }\n    }\n}"], "fixing_code": ["using System;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing ServiceStack.Serialization;\nusing ServiceStack.Templates;\nusing ServiceStack.Web;\n\nnamespace ServiceStack.Formats\n{\n    public class HtmlFormat : IPlugin\n    {\n        public static string TitleFormat\n            = @\"{0} Snapshot of {1}\";\n\n        public static string HtmlTitleFormat\n            = @\"Snapshot of <i>{0}</i> generated by <a href=\"\"https://servicestack.net\"\">ServiceStack</a> on <b>{1}</b>\";\n\n        public static bool Humanize = true;\n\n        private IAppHost AppHost { get; set; }\n\n        public const string ModelKey = \"Model\";\n        public const string ErrorStatusKey = \"__errorStatus\";\n\n        public void Register(IAppHost appHost)\n        {\n            AppHost = appHost;\n            //Register this in ServiceStack with the custom formats\n            appHost.ContentTypes.RegisterAsync(MimeTypes.Html, SerializeToStreamAsync, null);\n            appHost.ContentTypes.RegisterAsync(MimeTypes.JsonReport, SerializeToStreamAsync, null);\n\n            appHost.Config.DefaultContentType = MimeTypes.Html;\n            appHost.Config.IgnoreFormatsInMetadata.Add(MimeTypes.Html.ToContentFormat());\n            appHost.Config.IgnoreFormatsInMetadata.Add(MimeTypes.JsonReport.ToContentFormat());\n        }\n\n        public async Task SerializeToStreamAsync(IRequest req, object response, Stream outputStream)\n        {\n            var res = req.Response;\n            if (req.GetItem(\"HttpResult\") is IHttpResult httpResult && httpResult.Headers.ContainsKey(HttpHeaders.Location) \n                && httpResult.StatusCode != System.Net.HttpStatusCode.Created)  \n                return;\n\n            try\n            {\n                if (res.StatusCode >= 400)\n                {\n                    var responseStatus = response.GetResponseStatus();\n                    req.Items[ErrorStatusKey] = responseStatus;\n                }\n\n                if (response is CompressedResult)\n                {\n                    if (res.Dto != null)\n                        response = res.Dto;\n                    else \n                        throw new ArgumentException(\"Cannot use Cached Result as ViewModel\");\n                }\n\n                foreach (var viewEngine in AppHost.ViewEngines)\n                {\n                    var handled = await viewEngine.ProcessRequestAsync(req, response, outputStream);\n                    if (handled)\n                        return;\n                }\n            }\n            catch (Exception ex)\n            {\n                if (res.StatusCode < 400)\n                    throw;\n\n                //If there was an exception trying to render a Error with a View, \n                //It can't handle errors so just write it out here.\n                response = DtoUtils.CreateErrorResponse(req.Dto, ex);\n            }\n\n            //Handle Exceptions returning string\n            if (req.ResponseContentType == MimeTypes.PlainText)\n            {\n                req.ResponseContentType = MimeTypes.Html;\n                res.ContentType = MimeTypes.Html;\n            }\n\n            if (req.ResponseContentType != MimeTypes.Html && req.ResponseContentType != MimeTypes.JsonReport) \n                return;\n\n            var dto = response.GetDto();\n            if (!(dto is string html))\n            {\n                // Serialize then escape any potential script tags to avoid XSS when displaying as HTML\n                var json = JsonDataContractSerializer.Instance.SerializeToString(dto) ?? \"null\";\n                json = json.HtmlEncode();\n\n                var url = req.ResolveAbsoluteUrl()\n                    .Replace(\"format=html\", \"\")\n                    .Replace(\"format=shtm\", \"\")\n                    .TrimEnd('?', '&')\n                    .HtmlEncode();\n\n                url += url.Contains(\"?\") ? \"&\" : \"?\";\n\n                var now = DateTime.UtcNow;\n                var requestName = req.OperationName ?? dto.GetType().GetOperationName();\n\n                html = HtmlTemplates.GetHtmlFormatTemplate()\n                    .Replace(\"${Dto}\", json)\n                    .Replace(\"${Title}\", string.Format(TitleFormat, requestName, now))\n                    .Replace(\"${MvcIncludes}\", MiniProfiler.Profiler.RenderIncludes().ToString())\n                    .Replace(\"${Header}\", string.Format(HtmlTitleFormat, requestName, now))\n                    .Replace(\"${ServiceUrl}\", url)\n                    .Replace(\"${Humanize}\", Humanize.ToString().ToLower());\n            }\n\n            var utf8Bytes = html.ToUtf8Bytes();\n            await outputStream.WriteAsync(utf8Bytes, 0, utf8Bytes.Length);\n        }\n    }\n}"], "filenames": ["src/ServiceStack/Formats/HtmlFormat.cs"], "buggy_code_start_loc": [93], "buggy_code_end_loc": [99], "fixing_code_start_loc": [93], "fixing_code_end_loc": [100], "type": "CWE-79", "message": "ServiceStack ServiceStack Framework 4.5.14 is affected by: Cross Site Scripting (XSS). The impact is: JavaScrpit is reflected in the server response, hence executed by the browser. The component is: the query used in the GET request is prone. The attack vector is: Since there is no server-side validation and If Browser encoding is bypassed, the victim is affected when opening a crafted URL. The fixed version is: 5.2.0.", "other": {"cve": {"id": "CVE-2019-1010199", "sourceIdentifier": "josh@bress.net", "published": "2019-07-23T18:15:14.313", "lastModified": "2019-07-25T19:19:14.330", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ServiceStack ServiceStack Framework 4.5.14 is affected by: Cross Site Scripting (XSS). The impact is: JavaScrpit is reflected in the server response, hence executed by the browser. The component is: the query used in the GET request is prone. The attack vector is: Since there is no server-side validation and If Browser encoding is bypassed, the victim is affected when opening a crafted URL. The fixed version is: 5.2.0."}, {"lang": "es", "value": "ServiceStack ServiceStack Framework 4.5.14 est\u00e1 afectado por: Cross Site Scripting (XSS). El impacto es: JavaScrpit se refleja en la respuesta del servidor, por lo tanto, es ejecutado por el navegador. El componente es: la consulta utilizada en la solicitud GET es propensa. El vector de ataque es: ya que no hay una validaci\u00f3n del lado del servidor y si se omite la codificaci\u00f3n del navegador, la v\u00edctima se ve afectada al abrir una URL especialmente dise\u00f1ada. La versi\u00f3n fija es: 5.2.0."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:servicestack:servicestack:4.5.14:*:*:*:*:*:*:*", "matchCriteriaId": "7B4DF434-BB63-4558-A49A-789861256390"}]}]}], "references": [{"url": "https://github.com/ServiceStack/ServiceStack/commit/a0e0d7de20f5d1712f1793f925496def4383c610", "source": "josh@bress.net", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ServiceStack/ServiceStack/commit/a0e0d7de20f5d1712f1793f925496def4383c610"}}