{"buggy_code": ["/* $Id$ */\n\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"gd_intern.h\"\n\n/* 2.03: don't include zlib here or we can't build without PNG */\n#include \"gd.h\"\n#include \"gdhelpers.h\"\n#include \"gd_color.h\"\n#include \"gd_errors.h\"\n\n/* 2.0.12: this now checks the clipping rectangle */\n#define gdImageBoundsSafeMacro(im, x, y) (!((((y) < (im)->cy1) || ((y) > (im)->cy2)) || (((x) < (im)->cx1) || ((x) > (im)->cx2))))\n\n#ifdef _OSD_POSIX\t\t/* BS2000 uses the EBCDIC char set instead of ASCII */\n#define CHARSET_EBCDIC\n#define __attribute__(any)\t/*nothing */\n#endif\n/*_OSD_POSIX*/\n\n#ifndef CHARSET_EBCDIC\n#define ASC(ch)  ch\n#else /*CHARSET_EBCDIC */\n#define ASC(ch) gd_toascii[(unsigned char)ch]\nstatic const unsigned char gd_toascii[256] = {\n\t/*00 */ 0x00, 0x01, 0x02, 0x03, 0x85, 0x09, 0x86, 0x7f,\n\t0x87, 0x8d, 0x8e, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\t/*................ */\n\t/*10 */ 0x10, 0x11, 0x12, 0x13, 0x8f, 0x0a, 0x08, 0x97,\n\t0x18, 0x19, 0x9c, 0x9d, 0x1c, 0x1d, 0x1e, 0x1f,\t/*................ */\n\t/*20 */ 0x80, 0x81, 0x82, 0x83, 0x84, 0x92, 0x17, 0x1b,\n\t0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x05, 0x06, 0x07,\t/*................ */\n\t/*30 */ 0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04,\n\t0x98, 0x99, 0x9a, 0x9b, 0x14, 0x15, 0x9e, 0x1a,\t/*................ */\n\t/*40 */ 0x20, 0xa0, 0xe2, 0xe4, 0xe0, 0xe1, 0xe3, 0xe5,\n\t0xe7, 0xf1, 0x60, 0x2e, 0x3c, 0x28, 0x2b, 0x7c,\t/* .........`.<(+| */\n\t/*50 */ 0x26, 0xe9, 0xea, 0xeb, 0xe8, 0xed, 0xee, 0xef,\n\t0xec, 0xdf, 0x21, 0x24, 0x2a, 0x29, 0x3b, 0x9f,\t/*&.........!$*);. */\n\t/*60 */ 0x2d, 0x2f, 0xc2, 0xc4, 0xc0, 0xc1, 0xc3, 0xc5,\n\t0xc7, 0xd1, 0x5e, 0x2c, 0x25, 0x5f, 0x3e, 0x3f,\n\t/*-/........^,%_>?*/\n\t/*70 */ 0xf8, 0xc9, 0xca, 0xcb, 0xc8, 0xcd, 0xce, 0xcf,\n\t0xcc, 0xa8, 0x3a, 0x23, 0x40, 0x27, 0x3d, 0x22,\t/*..........:#@'=\" */\n\t/*80 */ 0xd8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t0x68, 0x69, 0xab, 0xbb, 0xf0, 0xfd, 0xfe, 0xb1,\t/*.abcdefghi...... */\n\t/*90 */ 0xb0, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,\n\t0x71, 0x72, 0xaa, 0xba, 0xe6, 0xb8, 0xc6, 0xa4,\t/*.jklmnopqr...... */\n\t/*a0 */ 0xb5, 0xaf, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n\t0x79, 0x7a, 0xa1, 0xbf, 0xd0, 0xdd, 0xde, 0xae,\t/*..stuvwxyz...... */\n\t/*b0 */ 0xa2, 0xa3, 0xa5, 0xb7, 0xa9, 0xa7, 0xb6, 0xbc,\n\t0xbd, 0xbe, 0xac, 0x5b, 0x5c, 0x5d, 0xb4, 0xd7,\t/*...........[\\].. */\n\t/*c0 */ 0xf9, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n\t0x48, 0x49, 0xad, 0xf4, 0xf6, 0xf2, 0xf3, 0xf5,\t/*.ABCDEFGHI...... */\n\t/*d0 */ 0xa6, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,\n\t0x51, 0x52, 0xb9, 0xfb, 0xfc, 0xdb, 0xfa, 0xff,\t/*.JKLMNOPQR...... */\n\t/*e0 */ 0xd9, 0xf7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n\t0x59, 0x5a, 0xb2, 0xd4, 0xd6, 0xd2, 0xd3, 0xd5,\t/*..STUVWXYZ...... */\n\t/*f0 */ 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n\t0x38, 0x39, 0xb3, 0x7b, 0xdc, 0x7d, 0xda, 0x7e\t/*0123456789.{.}.~ */\n};\n#endif /*CHARSET_EBCDIC */\n\nextern const int gdCosT[];\nextern const int gdSinT[];\n\nvoid gd_stderr_error(int priority, const char *format, va_list args)\n{\n\tswitch (priority) {\n\tcase GD_ERROR:\n\t\tfputs(\"GD Error: \", stderr);\n\t\tbreak;\n\tcase GD_WARNING:\n\t\tfputs(\"GD Warning: \", stderr);\n\t\tbreak;\n\tcase GD_NOTICE:\n\t\tfputs(\"GD Notice: \", stderr);\n\t\tbreak;\n\tcase GD_INFO:\n\t\tfputs(\"GD Info: \", stderr);\n\t\tbreak;\n\tcase GD_DEBUG:\n\t\tfputs(\"GD Debug: \", stderr);\n\t\tbreak;\n\t}\n\tvfprintf(stderr, format, args);\n\tfflush(stderr);\n}\n\nstatic gdErrorMethod gd_error_method = gd_stderr_error;\n\nvoid gd_error(const char *format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tgd_error_ex(GD_WARNING, format, args);\n\tva_end(args);\n}\nvoid gd_error_ex(int priority, const char *format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tif (gd_error_method) {\n\t\tgd_error_method(priority, format, args);\n\t}\n\tva_end(args);\n}\n\nBGD_DECLARE(void) gdSetErrorMethod(gdErrorMethod error_method)\n{\n\tgd_error_method = error_method;\n}\n\nBGD_DECLARE(void) gdClearErrorMethod(void)\n{\n\tgd_error_method = gd_stderr_error;\n}\n\nstatic void gdImageBrushApply (gdImagePtr im, int x, int y);\nstatic void gdImageTileApply (gdImagePtr im, int x, int y);\nBGD_DECLARE(int) gdImageGetTrueColorPixel (gdImagePtr im, int x, int y);\n\n\n/*\n    Function: gdImageCreate\n\n      gdImageCreate is called to create palette-based images, with no\n      more than 256 colors. The image must eventually be destroyed using\n      gdImageDestroy().\n\n    Parameters:\n\n        sx - The image width.\n        sy - The image height.\n\n    Returns:\n\n        A pointer to the new image or NULL if an error occurred.\n\n    Example:\n\n        >   gdImagePtr im;\n        >   im = gdImageCreate(64, 64);\n        >   // ... Use the image ...\n        >   gdImageDestroy(im);\n\n    See Also:\n\n        <gdImageCreateTrueColor>        \n\n */\nBGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\n\tif (overflow2(sizeof (unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char *), sx)) {\n\t\treturn NULL;\n\t}\n\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n\n\t/* Row-major ever since gd 1.3 */\n\tim->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; (i < sy); i++) {\n\t\t/* Row-major ever since gd 1.3 */\n\t\tim->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\tif (!im->pixels[i]) {\n\t\t\tfor (--i ; i >= 0; i--) {\n\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t}\n\t\t\tgdFree(im->pixels);\n\t\t\tgdFree(im);\n\t\t\treturn NULL;\n\t\t}\n\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tim->open[i] = 1;\n\t};\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->res_x = GD_RESOLUTION;\n\tim->res_y = GD_RESOLUTION;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}\n\n\n\n/*\n    Function: gdImageCreateTrueColor\n\n      <gdImageCreateTrueColor> is called to create truecolor images,\n      with an essentially unlimited number of colors. Invoke\n      <gdImageCreateTrueColor> with the x and y dimensions of the\n      desired image. <gdImageCreateTrueColor> returns a <gdImagePtr>\n      to the new image, or NULL if unable to allocate the image. The\n      image must eventually be destroyed using <gdImageDestroy>().\n\n      Truecolor images are always filled with black at creation\n      time. There is no concept of a \"background\" color index.\n\n    Parameters:\n\n        sx - The image width.\n        sy - The image height.\n\n    Returns:\n\n        A pointer to the new image or NULL if an error occurred.\n\n    Example:\n\n        > gdImagePtr im;\n        > im = gdImageCreateTrueColor(64, 64);\n        > // ... Use the image ...\n        > gdImageDestroy(im);\n\n    See Also:\n\n        <gdImageCreateTrueColor>        \n\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateTrueColor (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\n\tif (overflow2(sizeof (int *), sy)) {\n\t\treturn 0;\n\t}\n\n\tif (overflow2(sizeof(int), sx)) {\n\t\treturn NULL;\n\t}\n\n\tim = (gdImage *) gdMalloc (sizeof (gdImage));\n\tif (!im) {\n\t\treturn 0;\n\t}\n\tmemset (im, 0, sizeof (gdImage));\n\n\tim->tpixels = (int **) gdMalloc (sizeof (int *) * sy);\n\tif (!im->tpixels) {\n\t\tgdFree(im);\n\t\treturn 0;\n\t}\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; (i < sy); i++) {\n\t\tim->tpixels[i] = (int *) gdCalloc (sx, sizeof (int));\n\t\tif (!im->tpixels[i]) {\n\t\t\t/* 2.0.34 */\n\t\t\ti--;\n\t\t\twhile (i >= 0) {\n\t\t\t\tgdFree(im->tpixels[i]);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tgdFree(im->tpixels);\n\t\t\tgdFree(im);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->trueColor = 1;\n\t/* 2.0.2: alpha blending is now on by default, and saving of alpha is\n\t   off by default. This allows font antialiasing to work as expected\n\t   on the first try in JPEGs -- quite important -- and also allows\n\t   for smaller PNGs when saving of alpha channel is not really\n\t   desired, which it usually isn't! */\n\tim->saveAlphaFlag = 0;\n\tim->alphaBlendingFlag = 1;\n\tim->thick = 1;\n\tim->AA = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->res_x = GD_RESOLUTION;\n\tim->res_y = GD_RESOLUTION;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}\n\n/*\n  Function: gdImageDestroy\n\n    <gdImageDestroy> is used to free the memory associated with an\n    image. It is important to invoke <gdImageDestroy> before exiting\n    your program or assigning a new image to a <gdImagePtr> variable.\n\n  Parameters:\n\n    im  - Pointer to the gdImage to delete.\n\n  Returns:\n\n    Nothing.\n\n  Example:\n\n    > gdImagePtr im;\n    > im = gdImageCreate(10, 10);\n    > // ... Use the image ...\n    > // Now destroy it\n    > gdImageDestroy(im);\n\n*/\n\nBGD_DECLARE(void) gdImageDestroy (gdImagePtr im)\n{\n\tint i;\n\tif (im->pixels) {\n\t\tfor (i = 0; (i < im->sy); i++) {\n\t\t\tgdFree (im->pixels[i]);\n\t\t}\n\t\tgdFree (im->pixels);\n\t}\n\tif (im->tpixels) {\n\t\tfor (i = 0; (i < im->sy); i++) {\n\t\t\tgdFree (im->tpixels[i]);\n\t\t}\n\t\tgdFree (im->tpixels);\n\t}\n\tif (im->polyInts) {\n\t\tgdFree (im->polyInts);\n\t}\n\tif (im->style) {\n\t\tgdFree (im->style);\n\t}\n\tgdFree (im);\n}\n\nBGD_DECLARE(int) gdImageColorClosest (gdImagePtr im, int r, int g, int b)\n{\n\treturn gdImageColorClosestAlpha (im, r, g, b, gdAlphaOpaque);\n}\n\nBGD_DECLARE(int) gdImageColorClosestAlpha (gdImagePtr im, int r, int g, int b, int a)\n{\n\tint i;\n\tlong rd, gd, bd, ad;\n\tint ct = (-1);\n\tint first = 1;\n\tlong mindist = 0;\n\tif (im->trueColor) {\n\t\treturn gdTrueColorAlpha (r, g, b, a);\n\t}\n\tfor (i = 0; (i < (im->colorsTotal)); i++) {\n\t\tlong dist;\n\t\tif (im->open[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\trd = (im->red[i] - r);\n\t\tgd = (im->green[i] - g);\n\t\tbd = (im->blue[i] - b);\n\t\t/* gd 2.02: whoops, was - b (thanks to David Marwood) */\n\t\t/* gd 2.16: was blue rather than alpha! Geez! Thanks to\n\t\t   Artur Jakub Jerzak */\n\t\tad = (im->alpha[i] - a);\n\t\tdist = rd * rd + gd * gd + bd * bd + ad * ad;\n\t\tif (first || (dist < mindist)) {\n\t\t\tmindist = dist;\n\t\t\tct = i;\n\t\t\tfirst = 0;\n\t\t}\n\t}\n\treturn ct;\n}\n\n/* This code is taken from http://www.acm.org/jgt/papers/SmithLyons96/hwb_rgb.html, an article\n * on colour conversion to/from RBG and HWB colour systems.\n * It has been modified to return the converted value as a * parameter.\n */\n\n#define RETURN_HWB(h, w, b) {HWB->H = h; HWB->W = w; HWB->B = b; return HWB;}\n#define RETURN_RGB(r, g, b) {RGB->R = r; RGB->G = g; RGB->B = b; return RGB;}\n#define HWB_UNDEFINED -1\n#define SETUP_RGB(s, r, g, b) {s.R = r/255.0; s.G = g/255.0; s.B = b/255.0;}\n\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define MIN3(a,b,c) ((a)<(b)?(MIN(a,c)):(MIN(b,c)))\n#define MAX(a,b) ((a)<(b)?(b):(a))\n#define MAX3(a,b,c) ((a)<(b)?(MAX(b,c)):(MAX(a,c)))\n\n\n/*\n * Theoretically, hue 0 (pure red) is identical to hue 6 in these transforms. Pure\n * red always maps to 6 in this implementation. Therefore UNDEFINED can be\n * defined as 0 in situations where only unsigned numbers are desired.\n */\ntypedef struct {\n\tfloat R, G, B;\n}\nRGBType;\ntypedef struct {\n\tfloat H, W, B;\n}\nHWBType;\n\nstatic HWBType *\nRGB_to_HWB (RGBType RGB, HWBType * HWB)\n{\n\n\t/*\n\t * RGB are each on [0, 1]. W and B are returned on [0, 1] and H is\n\t * returned on [0, 6]. Exception: H is returned UNDEFINED if W == 1 - B.\n\t */\n\n\tfloat R = RGB.R, G = RGB.G, B = RGB.B, w, v, b, f;\n\tint i;\n\n\tw = MIN3 (R, G, B);\n\tv = MAX3 (R, G, B);\n\tb = 1 - v;\n\tif (v == w)\n\t\tRETURN_HWB (HWB_UNDEFINED, w, b);\n\tf = (R == w) ? G - B : ((G == w) ? B - R : R - G);\n\ti = (R == w) ? 3 : ((G == w) ? 5 : 1);\n\tRETURN_HWB (i - f / (v - w), w, b);\n\n}\n\nstatic float\nHWB_Diff (int r1, int g1, int b1, int r2, int g2, int b2)\n{\n\tRGBType RGB1, RGB2;\n\tHWBType HWB1, HWB2;\n\tfloat diff;\n\n\tSETUP_RGB (RGB1, r1, g1, b1);\n\tSETUP_RGB (RGB2, r2, g2, b2);\n\n\tRGB_to_HWB (RGB1, &HWB1);\n\tRGB_to_HWB (RGB2, &HWB2);\n\n\t/*\n\t * I made this bit up; it seems to produce OK results, and it is certainly\n\t * more visually correct than the current RGB metric. (PJW)\n\t */\n\n\tif ((HWB1.H == HWB_UNDEFINED) || (HWB2.H == HWB_UNDEFINED)) {\n\t\tdiff = 0;\t\t\t/* Undefined hues always match... */\n\t} else {\n\t\tdiff = fabs (HWB1.H - HWB2.H);\n\t\tif (diff > 3) {\n\t\t\tdiff = 6 - diff;\t/* Remember, it's a colour circle */\n\t\t}\n\t}\n\n\tdiff =\n\t    diff * diff + (HWB1.W - HWB2.W) * (HWB1.W - HWB2.W) + (HWB1.B -\n\t            HWB2.B) * (HWB1.B -\n\t                       HWB2.B);\n\n\treturn diff;\n}\n\n\n#if 0\n/*\n * This is not actually used, but is here for completeness, in case someone wants to\n * use the HWB stuff for anything else...\n */\nstatic RGBType *\nHWB_to_RGB (HWBType HWB, RGBType * RGB)\n{\n\n\t/*\n\t * H is given on [0, 6] or UNDEFINED. W and B are given on [0, 1].\n\t * RGB are each returned on [0, 1].\n\t */\n\n\tfloat h = HWB.H, w = HWB.W, b = HWB.B, v, n, f;\n\tint i;\n\n\tv = 1 - b;\n\tif (h == HWB_UNDEFINED)\n\t\tRETURN_RGB (v, v, v);\n\ti = floor (h);\n\tf = h - i;\n\tif (i & 1)\n\t\tf = 1 - f;\t\t\t/* if i is odd */\n\tn = w + f * (v - w);\t\t/* linear interpolation between w and v */\n\tswitch (i) {\n\tcase 6:\n\tcase 0:\n\t\tRETURN_RGB (v, n, w);\n\tcase 1:\n\t\tRETURN_RGB (n, v, w);\n\tcase 2:\n\t\tRETURN_RGB (w, v, n);\n\tcase 3:\n\t\tRETURN_RGB (w, n, v);\n\tcase 4:\n\t\tRETURN_RGB (n, w, v);\n\tcase 5:\n\t\tRETURN_RGB (v, w, n);\n\t}\n\n\treturn RGB;\n\n}\n#endif\n\nBGD_DECLARE(int) gdImageColorClosestHWB (gdImagePtr im, int r, int g, int b)\n{\n\tint i;\n\t/* long rd, gd, bd; */\n\tint ct = (-1);\n\tint first = 1;\n\tfloat mindist = 0;\n\tif (im->trueColor) {\n\t\treturn gdTrueColor (r, g, b);\n\t}\n\tfor (i = 0; (i < (im->colorsTotal)); i++) {\n\t\tfloat dist;\n\t\tif (im->open[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tdist = HWB_Diff (im->red[i], im->green[i], im->blue[i], r, g, b);\n\t\tif (first || (dist < mindist)) {\n\t\t\tmindist = dist;\n\t\t\tct = i;\n\t\t\tfirst = 0;\n\t\t}\n\t}\n\treturn ct;\n}\n\nBGD_DECLARE(int) gdImageColorExact (gdImagePtr im, int r, int g, int b)\n{\n\treturn gdImageColorExactAlpha (im, r, g, b, gdAlphaOpaque);\n}\n\nBGD_DECLARE(int) gdImageColorExactAlpha (gdImagePtr im, int r, int g, int b, int a)\n{\n\tint i;\n\tif (im->trueColor) {\n\t\treturn gdTrueColorAlpha (r, g, b, a);\n\t}\n\tfor (i = 0; (i < (im->colorsTotal)); i++) {\n\t\tif (im->open[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ((im->red[i] == r) &&\n\t\t        (im->green[i] == g) && (im->blue[i] == b) && (im->alpha[i] == a)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nBGD_DECLARE(int) gdImageColorAllocate (gdImagePtr im, int r, int g, int b)\n{\n\treturn gdImageColorAllocateAlpha (im, r, g, b, gdAlphaOpaque);\n}\n\nBGD_DECLARE(int) gdImageColorAllocateAlpha (gdImagePtr im, int r, int g, int b, int a)\n{\n\tint i;\n\tint ct = (-1);\n\tif (im->trueColor) {\n\t\treturn gdTrueColorAlpha (r, g, b, a);\n\t}\n\tfor (i = 0; (i < (im->colorsTotal)); i++) {\n\t\tif (im->open[i]) {\n\t\t\tct = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ct == (-1)) {\n\t\tct = im->colorsTotal;\n\t\tif (ct == gdMaxColors) {\n\t\t\treturn -1;\n\t\t}\n\t\tim->colorsTotal++;\n\t}\n\tim->red[ct] = r;\n\tim->green[ct] = g;\n\tim->blue[ct] = b;\n\tim->alpha[ct] = a;\n\tim->open[ct] = 0;\n\treturn ct;\n}\n\n/*\n * gdImageColorResolve is an alternative for the code fragment:\n *\n *      if ((color=gdImageColorExact(im,R,G,B)) < 0)\n *        if ((color=gdImageColorAllocate(im,R,G,B)) < 0)\n *          color=gdImageColorClosest(im,R,G,B);\n *\n * in a single function.    Its advantage is that it is guaranteed to\n * return a color index in one search over the color table.\n */\n\nBGD_DECLARE(int) gdImageColorResolve (gdImagePtr im, int r, int g, int b)\n{\n\treturn gdImageColorResolveAlpha (im, r, g, b, gdAlphaOpaque);\n}\n\nBGD_DECLARE(int) gdImageColorResolveAlpha (gdImagePtr im, int r, int g, int b, int a)\n{\n\tint c;\n\tint ct = -1;\n\tint op = -1;\n\tlong rd, gd, bd, ad, dist;\n\tlong mindist = 4 * 255 * 255;\t/* init to max poss dist */\n\tif (im->trueColor) {\n\t\treturn gdTrueColorAlpha (r, g, b, a);\n\t}\n\n\tfor (c = 0; c < im->colorsTotal; c++) {\n\t\tif (im->open[c]) {\n\t\t\top = c;\t\t/* Save open slot */\n\t\t\tcontinue;\t\t/* Color not in use */\n\t\t}\n\t\tif (c == im->transparent) {\n\t\t\t/* don't ever resolve to the color that has\n\t\t\t * been designated as the transparent color */\n\t\t\tcontinue;\n\t\t}\n\t\trd = (long) (im->red[c] - r);\n\t\tgd = (long) (im->green[c] - g);\n\t\tbd = (long) (im->blue[c] - b);\n\t\tad = (long) (im->alpha[c] - a);\n\t\tdist = rd * rd + gd * gd + bd * bd + ad * ad;\n\t\tif (dist < mindist) {\n\t\t\tif (dist == 0) {\n\t\t\t\treturn c;\t\t/* Return exact match color */\n\t\t\t}\n\t\t\tmindist = dist;\n\t\t\tct = c;\n\t\t}\n\t}\n\t/* no exact match.  We now know closest, but first try to allocate exact */\n\tif (op == -1) {\n\t\top = im->colorsTotal;\n\t\tif (op == gdMaxColors) {\n\t\t\t/* No room for more colors */\n\t\t\treturn ct;\t\t/* Return closest available color */\n\t\t}\n\t\tim->colorsTotal++;\n\t}\n\tim->red[op] = r;\n\tim->green[op] = g;\n\tim->blue[op] = b;\n\tim->alpha[op] = a;\n\tim->open[op] = 0;\n\treturn op;\t\t\t/* Return newly allocated color */\n}\n\nBGD_DECLARE(void) gdImageColorDeallocate (gdImagePtr im, int color)\n{\n\tif (im->trueColor || (color >= gdMaxColors) || (color < 0)) {\n\t\treturn;\n\t}\n\t/* Mark it open. */\n\tim->open[color] = 1;\n}\n\nBGD_DECLARE(void) gdImageColorTransparent (gdImagePtr im, int color)\n{\n\tif (!im->trueColor) {\n\t\tif((color < -1) || (color >= gdMaxColors)) {\n\t\t\treturn;\n\t\t}\n\t\tif (im->transparent != -1) {\n\t\t\tim->alpha[im->transparent] = gdAlphaOpaque;\n\t\t}\n\t\tif (color != -1) {\n\t\t\tim->alpha[color] = gdAlphaTransparent;\n\t\t}\n\t}\n\tim->transparent = color;\n}\n\nBGD_DECLARE(void) gdImagePaletteCopy (gdImagePtr to, gdImagePtr from)\n{\n\tint i;\n\tint x, y, p;\n\tint xlate[256];\n\tif (to->trueColor) {\n\t\treturn;\n\t}\n\tif (from->trueColor) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 256; i++) {\n\t\txlate[i] = -1;\n\t};\n\n\tfor (y = 0; y < (to->sy); y++) {\n\t\tfor (x = 0; x < (to->sx); x++) {\n\t\t\t/* Optimization: no gdImageGetPixel */\n\t\t\tp = to->pixels[y][x];\n\t\t\tif (xlate[p] == -1) {\n\t\t\t\t/* This ought to use HWB, but we don't have an alpha-aware\n\t\t\t\t   version of that yet. */\n\t\t\t\txlate[p] =\n\t\t\t\t    gdImageColorClosestAlpha (from, to->red[p], to->green[p],\n\t\t\t\t                              to->blue[p], to->alpha[p]);\n\t\t\t\t/*printf(\"Mapping %d (%d, %d, %d, %d) to %d (%d, %d, %d, %d)\\n\", */\n\t\t\t\t/*      p,  to->red[p], to->green[p], to->blue[p], to->alpha[p], */\n\t\t\t\t/*      xlate[p], from->red[xlate[p]], from->green[xlate[p]], from->blue[xlate[p]], from->alpha[xlate[p]]); */\n\t\t\t};\n\t\t\t/* Optimization: no gdImageSetPixel */\n\t\t\tto->pixels[y][x] = xlate[p];\n\t\t};\n\t};\n\n\tfor (i = 0; (i < (from->colorsTotal)); i++) {\n\t\t/*printf(\"Copying color %d (%d, %d, %d, %d)\\n\", i, from->red[i], from->blue[i], from->green[i], from->alpha[i]); */\n\t\tto->red[i] = from->red[i];\n\t\tto->blue[i] = from->blue[i];\n\t\tto->green[i] = from->green[i];\n\t\tto->alpha[i] = from->alpha[i];\n\t\tto->open[i] = 0;\n\t};\n\n\tfor (i = from->colorsTotal; (i < to->colorsTotal); i++) {\n\t\tto->open[i] = 1;\n\t};\n\n\tto->colorsTotal = from->colorsTotal;\n\n}\n\nBGD_DECLARE(int) gdImageColorReplace (gdImagePtr im, int src, int dst)\n{\n\tregister int x, y;\n\tint n = 0;\n\n\tif (src == dst) {\n\t\treturn 0;\n\t}\n\n#define REPLACING_LOOP(pixel) do {\t\t\t\t\t\t\t\t\\\n\t\tfor (y = im->cy1; y <= im->cy2; y++) {\t\t\t\t\t\\\n\t\t\tfor (x = im->cx1; x <= im->cx2; x++) {\t\t\t\t\\\n\t\t\t\tif (pixel(im, x, y) == src) {\t\t\t\t\t\\\n\t\t\t\t\tgdImageSetPixel(im, x, y, dst);\t\t\t\t\\\n\t\t\t\t\tn++;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tif (im->trueColor) {\n\t\tREPLACING_LOOP(gdImageTrueColorPixel);\n\t} else {\n\t\tREPLACING_LOOP(gdImagePalettePixel);\n\t}\n\n#undef REPLACING_LOOP\n\n\treturn n;\n}\n\nBGD_DECLARE(int) gdImageColorReplaceThreshold (gdImagePtr im, int src, int dst, float threshold)\n{\n\tregister int x, y;\n\tint n = 0;\n\n\tif (src == dst) {\n\t\treturn 0;\n\t}\n\n#define REPLACING_LOOP(pixel) do {\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (y = im->cy1; y <= im->cy2; y++) {\t\t\t\t\t\t\t\\\n\t\t\tfor (x = im->cx1; x <= im->cx2; x++) {\t\t\t\t\t\t\\\n\t\t\t\tif (gdColorMatch(im, src, pixel(im, x, y), threshold)) { \\\n\t\t\t\t\tgdImageSetPixel(im, x, y, dst);\t\t\t\t\t\t\\\n\t\t\t\t\tn++;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tif (im->trueColor) {\n\t\tREPLACING_LOOP(gdImageTrueColorPixel);\n\t} else {\n\t\tREPLACING_LOOP(gdImagePalettePixel);\n\t}\n\n#undef REPLACING_LOOP\n\n\treturn n;\n}\n\nstatic int colorCmp (const void *x, const void *y)\n{\n\tint a = *(int const *)x;\n\tint b = *(int const *)y;\n\treturn (a > b) - (a < b);\n}\n\nBGD_DECLARE(int) gdImageColorReplaceArray (gdImagePtr im, int len, int *src, int *dst)\n{\n\tregister int x, y;\n\tint c, *d, *base;\n\tint i, n = 0;\n\n\tif (len <= 0 || src == dst) {\n\t\treturn 0;\n\t}\n\tif (len == 1) {\n\t\treturn gdImageColorReplace(im, src[0], dst[0]);\n\t}\n\tif (overflow2(len, sizeof(int)<<1)) {\n\t\treturn -1;\n\t}\n\tbase = (int *)gdMalloc(len * (sizeof(int)<<1));\n\tif (!base) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tbase[(i<<1)]   = src[i];\n\t\tbase[(i<<1)+1] = dst[i];\n\t}\n\tqsort(base, len, sizeof(int)<<1, colorCmp);\n\n#define REPLACING_LOOP(pixel) do {\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (y = im->cy1; y <= im->cy2; y++) {\t\t\t\t\t\t\t\\\n\t\t\tfor (x = im->cx1; x <= im->cx2; x++) {\t\t\t\t\t\t\\\n\t\t\t\tc = pixel(im, x, y);\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif ( (d = (int *)bsearch(&c, base, len, sizeof(int)<<1, colorCmp)) ) { \\\n\t\t\t\t\tgdImageSetPixel(im, x, y, d[1]);\t\t\t\t\t\\\n\t\t\t\t\tn++;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tif (im->trueColor) {\n\t\tREPLACING_LOOP(gdImageTrueColorPixel);\n\t} else {\n\t\tREPLACING_LOOP(gdImagePalettePixel);\n\t}\n\n#undef REPLACING_LOOP\n\n\tgdFree(base);\n\treturn n;\n}\n\nBGD_DECLARE(int) gdImageColorReplaceCallback (gdImagePtr im, gdCallbackImageColor callback)\n{\n\tint c, d, n = 0;\n\n\tif (!callback) {\n\t\treturn 0;\n\t}\n\tif (im->trueColor) {\n\t\tregister int x, y;\n\n\t\tfor (y = im->cy1; y <= im->cy2; y++) {\n\t\t\tfor (x = im->cx1; x <= im->cx2; x++) {\n\t\t\t\tc = gdImageTrueColorPixel(im, x, y);\n\t\t\t\tif ( (d = callback(im, c)) != c) {\n\t\t\t\t\tgdImageSetPixel(im, x, y, d);\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else { /* palette */\n\t\tint *sarr, *darr;\n\t\tint k, len = 0;\n\n\t\tsarr = (int *)gdCalloc(im->colorsTotal, sizeof(int));\n\t\tif (!sarr) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (c = 0; c < im->colorsTotal; c++) {\n\t\t\tif (!im->open[c]) {\n\t\t\t\tsarr[len++] = c;\n\t\t\t}\n\t\t}\n\t\tdarr = (int *)gdCalloc(len, sizeof(int));\n\t\tif (!darr) {\n\t\t\tgdFree(sarr);\n\t\t\treturn -1;\n\t\t}\n\t\tfor (k = 0; k < len; k++) {\n\t\t\tdarr[k] = callback(im, sarr[k]);\n\t\t}\n\t\tn = gdImageColorReplaceArray(im, k, sarr, darr);\n\t\tgdFree(darr);\n\t\tgdFree(sarr);\n\t}\n\treturn n;\n}\n\n/* 2.0.10: before the drawing routines, some code to clip points that are\n * outside the drawing window.  Nick Atty (nick@canalplan.org.uk)\n *\n * This is the Sutherland Hodgman Algorithm, as implemented by\n * Duvanenko, Robbins and Gyurcsik - SH(DRG) for short.  See Dr Dobb's\n * Journal, January 1996, pp107-110 and 116-117\n *\n * Given the end points of a line, and a bounding rectangle (which we\n * know to be from (0,0) to (SX,SY)), adjust the endpoints to be on\n * the edges of the rectangle if the line should be drawn at all,\n * otherwise return a failure code */\n\n/* this does \"one-dimensional\" clipping: note that the second time it\n   is called, all the x parameters refer to height and the y to width\n   - the comments ignore this (if you can understand it when it's\n   looking at the X parameters, it should become clear what happens on\n   the second call!)  The code is simplified from that in the article,\n   as we know that gd images always start at (0,0) */\n\n/* 2.0.26, TBB: we now have to respect a clipping rectangle, it won't\n\tnecessarily start at 0. */\n\nstatic int\nclip_1d (int *x0, int *y0, int *x1, int *y1, int mindim, int maxdim)\n{\n\tdouble m;\t\t\t/* gradient of line */\n\tif (*x0 < mindim) {\n\t\t/* start of line is left of window */\n\t\tif (*x1 < mindim)\t\t/* as is the end, so the line never cuts the window */\n\t\t\treturn 0;\n\t\tm = (*y1 - *y0) / (double) (*x1 - *x0);\t/* calculate the slope of the line */\n\t\t/* adjust x0 to be on the left boundary (ie to be zero), and y0 to match */\n\t\t*y0 -= (int)(m * (*x0 - mindim));\n\t\t*x0 = mindim;\n\t\t/* now, perhaps, adjust the far end of the line as well */\n\t\tif (*x1 > maxdim) {\n\t\t\t*y1 += m * (maxdim - *x1);\n\t\t\t*x1 = maxdim;\n\t\t}\n\t\treturn 1;\n\t}\n\tif (*x0 > maxdim) {\n\t\t/* start of line is right of window -\n\t\tcomplement of above */\n\t\tif (*x1 > maxdim)\t\t/* as is the end, so the line misses the window */\n\t\t\treturn 0;\n\t\tm = (*y1 - *y0) / (double) (*x1 - *x0);\t/* calculate the slope of the line */\n\t\t*y0 += (int)(m * (maxdim - *x0));\t/* adjust so point is on the right\n\t\t\t\t\t\t\t   boundary */\n\t\t*x0 = maxdim;\n\t\t/* now, perhaps, adjust the end of the line */\n\t\tif (*x1 < mindim) {\n\t\t\t*y1 -= (int)(m * (*x1 - mindim));\n\t\t\t*x1 = mindim;\n\t\t}\n\t\treturn 1;\n\t}\n\t/* the final case - the start of the line is inside the window */\n\tif (*x1 > maxdim) {\n\t\t/* other end is outside to the right */\n\t\tm = (*y1 - *y0) / (double) (*x1 - *x0);\t/* calculate the slope of the line */\n\t\t*y1 += (int)(m * (maxdim - *x1));\n\t\t*x1 = maxdim;\n\t\treturn 1;\n\t}\n\tif (*x1 < mindim) {\n\t\t/* other end is outside to the left */\n\t\tm = (*y1 - *y0) / (double) (*x1 - *x0);\t/* calculate the slope of the line */\n\t\t*y1 -= (int)(m * (*x1 - mindim));\n\t\t*x1 = mindim;\n\t\treturn 1;\n\t}\n\t/* only get here if both points are inside the window */\n\treturn 1;\n}\n\n/* end of line clipping code */\n\nBGD_DECLARE(void) gdImageSetPixel (gdImagePtr im, int x, int y, int color)\n{\n\tint p;\n\tswitch (color) {\n\tcase gdStyled:\n\t\tif (!im->style) {\n\t\t\t/* Refuse to draw if no style is set. */\n\t\t\treturn;\n\t\t} else {\n\t\t\tp = im->style[im->stylePos++];\n\t\t}\n\t\tif (p != (gdTransparent)) {\n\t\t\tgdImageSetPixel (im, x, y, p);\n\t\t}\n\t\tim->stylePos = im->stylePos % im->styleLength;\n\t\tbreak;\n\tcase gdStyledBrushed:\n\t\tif (!im->style) {\n\t\t\t/* Refuse to draw if no style is set. */\n\t\t\treturn;\n\t\t}\n\t\tp = im->style[im->stylePos++];\n\t\tif ((p != gdTransparent) && (p != 0)) {\n\t\t\tgdImageSetPixel (im, x, y, gdBrushed);\n\t\t}\n\t\tim->stylePos = im->stylePos % im->styleLength;\n\t\tbreak;\n\tcase gdBrushed:\n\t\tgdImageBrushApply (im, x, y);\n\t\tbreak;\n\tcase gdTiled:\n\t\tgdImageTileApply (im, x, y);\n\t\tbreak;\n\tcase gdAntiAliased:\n\t\t/* This shouldn't happen (2.0.26) because we just call\n\t\t  gdImageAALine now, but do something sane. */\n\t\tgdImageSetPixel(im, x, y, im->AA_color);\n\t\tbreak;\n\tdefault:\n\t\tif (gdImageBoundsSafeMacro (im, x, y)) {\n\t\t\tif (im->trueColor) {\n\t\t\t\tswitch (im->alphaBlendingFlag) {\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase gdEffectReplace:\n\t\t\t\t\t\tim->tpixels[y][x] = color;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase gdEffectAlphaBlend:\n\t\t\t\t\tcase gdEffectNormal:\n\t\t\t\t\t\tim->tpixels[y][x] = gdAlphaBlend(im->tpixels[y][x], color);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase gdEffectOverlay :\n\t\t\t\t\t\tim->tpixels[y][x] = gdLayerOverlay(im->tpixels[y][x], color);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase gdEffectMultiply :\n\t\t\t\t\t\tim->tpixels[y][x] = gdLayerMultiply(im->tpixels[y][x], color);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tim->pixels[y][x] = color;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void\ngdImageBrushApply (gdImagePtr im, int x, int y)\n{\n\tint lx, ly;\n\tint hy;\n\tint hx;\n\tint x1, y1, x2, y2;\n\tint srcx, srcy;\n\tif (!im->brush) {\n\t\treturn;\n\t}\n\thy = gdImageSY (im->brush) / 2;\n\ty1 = y - hy;\n\ty2 = y1 + gdImageSY (im->brush);\n\thx = gdImageSX (im->brush) / 2;\n\tx1 = x - hx;\n\tx2 = x1 + gdImageSX (im->brush);\n\tsrcy = 0;\n\tif (im->trueColor) {\n\t\tif (im->brush->trueColor) {\n\t\t\tfor (ly = y1; (ly < y2); ly++) {\n\t\t\t\tsrcx = 0;\n\t\t\t\tfor (lx = x1; (lx < x2); lx++) {\n\t\t\t\t\tint p;\n\t\t\t\t\tp = gdImageGetTrueColorPixel (im->brush, srcx, srcy);\n\t\t\t\t\t/* 2.0.9, Thomas Winzig: apply simple full transparency */\n\t\t\t\t\tif (p != gdImageGetTransparent (im->brush)) {\n\t\t\t\t\t\tgdImageSetPixel (im, lx, ly, p);\n\t\t\t\t\t}\n\t\t\t\t\tsrcx++;\n\t\t\t\t}\n\t\t\t\tsrcy++;\n\t\t\t}\n\t\t} else {\n\t\t\t/* 2.0.12: Brush palette, image truecolor (thanks to Thorben Kundinger\n\t\t\t   for pointing out the issue) */\n\t\t\tfor (ly = y1; (ly < y2); ly++) {\n\t\t\t\tsrcx = 0;\n\t\t\t\tfor (lx = x1; (lx < x2); lx++) {\n\t\t\t\t\tint p, tc;\n\t\t\t\t\tp = gdImageGetPixel (im->brush, srcx, srcy);\n\t\t\t\t\ttc = gdImageGetTrueColorPixel (im->brush, srcx, srcy);\n\t\t\t\t\t/* 2.0.9, Thomas Winzig: apply simple full transparency */\n\t\t\t\t\tif (p != gdImageGetTransparent (im->brush)) {\n\t\t\t\t\t\tgdImageSetPixel (im, lx, ly, tc);\n\t\t\t\t\t}\n\t\t\t\t\tsrcx++;\n\t\t\t\t}\n\t\t\t\tsrcy++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (ly = y1; (ly < y2); ly++) {\n\t\t\tsrcx = 0;\n\t\t\tfor (lx = x1; (lx < x2); lx++) {\n\t\t\t\tint p;\n\t\t\t\tp = gdImageGetPixel (im->brush, srcx, srcy);\n\t\t\t\t/* Allow for non-square brushes! */\n\t\t\t\tif (p != gdImageGetTransparent (im->brush)) {\n\t\t\t\t\t/* Truecolor brush. Very slow\n\t\t\t\t\t   on a palette destination. */\n\t\t\t\t\tif (im->brush->trueColor) {\n\t\t\t\t\t\tgdImageSetPixel (im, lx, ly,\n\t\t\t\t\t\t                 gdImageColorResolveAlpha (im,\n\t\t\t\t\t\t                         gdTrueColorGetRed\n\t\t\t\t\t\t                         (p),\n\t\t\t\t\t\t                         gdTrueColorGetGreen\n\t\t\t\t\t\t                         (p),\n\t\t\t\t\t\t                         gdTrueColorGetBlue\n\t\t\t\t\t\t                         (p),\n\t\t\t\t\t\t                         gdTrueColorGetAlpha\n\t\t\t\t\t\t                         (p)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgdImageSetPixel (im, lx, ly, im->brushColorMap[p]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrcx++;\n\t\t\t}\n\t\t\tsrcy++;\n\t\t}\n\t}\n}\n\nstatic void\ngdImageTileApply (gdImagePtr im, int x, int y)\n{\n\tgdImagePtr tile = im->tile;\n\tint srcx, srcy;\n\tint p;\n\tif (!tile) {\n\t\treturn;\n\t}\n\tsrcx = x % gdImageSX (tile);\n\tsrcy = y % gdImageSY (tile);\n\tif (im->trueColor) {\n\t\tp = gdImageGetPixel (tile, srcx, srcy);\n\t\tif (p != gdImageGetTransparent (tile)) {\n\t\t\tif (!tile->trueColor) {\n\t\t\t\tp = gdTrueColorAlpha(tile->red[p], tile->green[p], tile->blue[p], tile->alpha[p]);\n\t\t\t}\n\t\t\tgdImageSetPixel (im, x, y, p);\n\t\t}\n\t} else {\n\t\tp = gdImageGetPixel (tile, srcx, srcy);\n\t\t/* Allow for transparency */\n\t\tif (p != gdImageGetTransparent (tile)) {\n\t\t\tif (tile->trueColor) {\n\t\t\t\t/* Truecolor tile. Very slow\n\t\t\t\t   on a palette destination. */\n\t\t\t\tgdImageSetPixel (im, x, y,\n\t\t\t\t                 gdImageColorResolveAlpha (im,\n\t\t\t\t                         gdTrueColorGetRed\n\t\t\t\t                         (p),\n\t\t\t\t                         gdTrueColorGetGreen\n\t\t\t\t                         (p),\n\t\t\t\t                         gdTrueColorGetBlue\n\t\t\t\t                         (p),\n\t\t\t\t                         gdTrueColorGetAlpha\n\t\t\t\t                         (p)));\n\t\t\t} else {\n\t\t\t\tgdImageSetPixel (im, x, y, im->tileColorMap[p]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nBGD_DECLARE(int) gdImageGetPixel (gdImagePtr im, int x, int y)\n{\n\tif (gdImageBoundsSafeMacro (im, x, y)) {\n\t\tif (im->trueColor) {\n\t\t\treturn im->tpixels[y][x];\n\t\t} else {\n\t\t\treturn im->pixels[y][x];\n\t\t}\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nBGD_DECLARE(int) gdImageGetTrueColorPixel (gdImagePtr im, int x, int y)\n{\n\tint p = gdImageGetPixel (im, x, y);\n\tif (!im->trueColor) {\n\t\treturn gdTrueColorAlpha (im->red[p], im->green[p], im->blue[p],\n\t\t                         (im->transparent == p) ? gdAlphaTransparent :\n\t\t                         im->alpha[p]);\n\t} else {\n\t\treturn p;\n\t}\n}\n\nBGD_DECLARE(void) gdImageAABlend (gdImagePtr im)\n{\n\t/* NO-OP, kept for library compatibility. */\n\t(void)im;\n}\n\nstatic void gdImageAALine (gdImagePtr im, int x1, int y1, int x2, int y2, int col);\n\nstatic void gdImageHLine(gdImagePtr im, int y, int x1, int x2, int col)\n{\n\tif (im->thick > 1) {\n\t\tint thickhalf = im->thick >> 1;\n\t\tgdImageFilledRectangle(im, x1, y - thickhalf, x2, y + im->thick - thickhalf - 1, col);\n\t} else {\n\t\tif (x2 < x1) {\n\t\t\tint t = x2;\n\t\t\tx2 = x1;\n\t\t\tx1 = t;\n\t\t}\n\n\t\tfor (; x1 <= x2; x1++) {\n\t\t\tgdImageSetPixel(im, x1, y, col);\n\t\t}\n\t}\n\treturn;\n}\n\nstatic void gdImageVLine(gdImagePtr im, int x, int y1, int y2, int col)\n{\n\tif (im->thick > 1) {\n\t\tint thickhalf = im->thick >> 1;\n\t\tgdImageFilledRectangle(im, x - thickhalf, y1, x + im->thick - thickhalf - 1, y2, col);\n\t} else {\n\t\tif (y2 < y1) {\n\t\t\tint t = y1;\n\t\t\ty1 = y2;\n\t\t\ty2 = t;\n\t\t}\n\n\t\tfor (; y1 <= y2; y1++) {\n\t\t\tgdImageSetPixel(im, x, y1, col);\n\t\t}\n\t}\n\treturn;\n}\n\n/* Bresenham as presented in Foley & Van Dam */\nBGD_DECLARE(void) gdImageLine (gdImagePtr im, int x1, int y1, int x2, int y2, int color)\n{\n\tint dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag;\n\tint wid;\n\tint w, wstart;\n\tint thick;\n\n\tif (color == gdAntiAliased) {\n\t\t/*\n\t\t  gdAntiAliased passed as color: use the much faster, much cheaper\n\t\t  and equally attractive gdImageAALine implementation. That\n\t\t  clips too, so don't clip twice.\n\t\t*/\n\t\tgdImageAALine(im, x1, y1, x2, y2, im->AA_color);\n\t\treturn;\n\t}\n\t/* 2.0.10: Nick Atty: clip to edges of drawing rectangle, return if no\n\t   points need to be drawn. 2.0.26, TBB: clip to edges of clipping\n\t   rectangle. We were getting away with this because gdImageSetPixel\n\t   is used for actual drawing, but this is still more efficient and opens\n\t   the way to skip per-pixel bounds checking in the future. */\n\n\tif (clip_1d (&x1, &y1, &x2, &y2, im->cx1, im->cx2) == 0)\n\t\treturn;\n\tif (clip_1d (&y1, &x1, &y2, &x2, im->cy1, im->cy2) == 0)\n\t\treturn;\n\tthick = im->thick;\n\n\tdx = abs (x2 - x1);\n\tdy = abs (y2 - y1);\n\n\tif (dx == 0) {\n\t\tgdImageVLine(im, x1, y1, y2, color);\n\t\treturn;\n\t} else if (dy == 0) {\n\t\tgdImageHLine(im, y1, x1, x2, color);\n\t\treturn;\n\t}\n\n\tif (dy <= dx) {\n\t\t/* More-or-less horizontal. use wid for vertical stroke */\n\t\t/* Doug Claar: watch out for NaN in atan2 (2.0.5) */\n\t\t\n\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\n\t\t\t  TBB: but watch out for /0! */\n\t\tdouble ac = cos (atan2 (dy, dx));\n\t\tif (ac != 0) {\n\t\t\twid = thick / ac;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tif (wid == 0) {\n\t\t\twid = 1;\n\t\t}\n\t\td = 2 * dy - dx;\n\t\tincr1 = 2 * dy;\n\t\tincr2 = 2 * (dy - dx);\n\t\tif (x1 > x2) {\n\t\t\tx = x2;\n\t\t\ty = y2;\n\t\t\tydirflag = (-1);\n\t\t\txend = x1;\n\t\t} else {\n\t\t\tx = x1;\n\t\t\ty = y1;\n\t\t\tydirflag = 1;\n\t\t\txend = x2;\n\t\t}\n\n\t\t/* Set up line thickness */\n\t\twstart = y - wid / 2;\n\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\tgdImageSetPixel (im, x, w, color);\n\n\t\tif (((y2 - y1) * ydirflag) > 0) {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = y - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t\t}\n\t\t} else {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = y - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* More-or-less vertical. use wid for horizontal stroke */\n\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\n\t\t   TBB: but watch out for /0! */\n\t\tdouble as = sin (atan2 (dy, dx));\n\t\tif (as != 0) {\n\t\t\twid = thick / as;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tif (wid == 0)\n\t\t\twid = 1;\n\n\t\td = 2 * dx - dy;\n\t\tincr1 = 2 * dx;\n\t\tincr2 = 2 * (dx - dy);\n\t\tif (y1 > y2) {\n\t\t\ty = y2;\n\t\t\tx = x2;\n\t\t\tyend = y1;\n\t\t\txdirflag = (-1);\n\t\t} else {\n\t\t\ty = y1;\n\t\t\tx = x1;\n\t\t\tyend = y2;\n\t\t\txdirflag = 1;\n\t\t}\n\n\t\t/* Set up line thickness */\n\t\twstart = x - wid / 2;\n\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\tgdImageSetPixel (im, w, y, color);\n\n\t\tif (((x2 - x1) * xdirflag) > 0) {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = x - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t\t}\n\t\t} else {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = x - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t\t}\n\t\t}\n\t}\n\n}\nstatic void dashedSet (gdImagePtr im, int x, int y, int color,\n\t\t\t\t\t   int *onP, int *dashStepP, int wid, int vert);\n\nBGD_DECLARE(void) gdImageDashedLine (gdImagePtr im, int x1, int y1, int x2, int y2, int color)\n{\n\tint dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag;\n\tint dashStep = 0;\n\tint on = 1;\n\tint wid;\n\tint vert;\n\tint thick = im->thick;\n\n\tdx = abs (x2 - x1);\n\tdy = abs (y2 - y1);\n\tif (dy <= dx) {\n\t\t/* More-or-less horizontal. use wid for vertical stroke */\n\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\n\t\t   TBB: but watch out for /0! */\n\t\tdouble as = sin (atan2 (dy, dx));\n\t\tif (as != 0) {\n\t\t\twid = thick / as;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tvert = 1;\n\n\t\td = 2 * dy - dx;\n\t\tincr1 = 2 * dy;\n\t\tincr2 = 2 * (dy - dx);\n\t\tif (x1 > x2) {\n\t\t\tx = x2;\n\t\t\ty = y2;\n\t\t\tydirflag = (-1);\n\t\t\txend = x1;\n\t\t} else {\n\t\t\tx = x1;\n\t\t\ty = y1;\n\t\t\tydirflag = 1;\n\t\t\txend = x2;\n\t\t}\n\t\tdashedSet (im, x, y, color, &on, &dashStep, wid, vert);\n\t\tif (((y2 - y1) * ydirflag) > 0) {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\tdashedSet (im, x, y, color, &on, &dashStep, wid, vert);\n\t\t\t}\n\t\t} else {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\tdashedSet (im, x, y, color, &on, &dashStep, wid, vert);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\n\t\t   TBB: but watch out for /0! */\n\t\tdouble as = sin (atan2 (dy, dx));\n\t\tif (as != 0) {\n\t\t\twid = thick / as;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tvert = 0;\n\n\t\td = 2 * dx - dy;\n\t\tincr1 = 2 * dx;\n\t\tincr2 = 2 * (dx - dy);\n\t\tif (y1 > y2) {\n\t\t\ty = y2;\n\t\t\tx = x2;\n\t\t\tyend = y1;\n\t\t\txdirflag = (-1);\n\t\t} else {\n\t\t\ty = y1;\n\t\t\tx = x1;\n\t\t\tyend = y2;\n\t\t\txdirflag = 1;\n\t\t}\n\t\tdashedSet (im, x, y, color, &on, &dashStep, wid, vert);\n\t\tif (((x2 - x1) * xdirflag) > 0) {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\tdashedSet (im, x, y, color, &on, &dashStep, wid, vert);\n\t\t\t}\n\t\t} else {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\tdashedSet (im, x, y, color, &on, &dashStep, wid, vert);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\ndashedSet (gdImagePtr im, int x, int y, int color,\n\t\t   int *onP, int *dashStepP, int wid, int vert)\n{\n\tint dashStep = *dashStepP;\n\tint on = *onP;\n\tint w, wstart;\n\n\tdashStep++;\n\tif (dashStep == gdDashSize) {\n\t\tdashStep = 0;\n\t\ton = !on;\n\t}\n\tif (on) {\n\t\tif (vert) {\n\t\t\twstart = y - wid / 2;\n\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t} else {\n\t\t\twstart = x - wid / 2;\n\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t}\n\t}\n\t*dashStepP = dashStep;\n\t*onP = on;\n}\n\nBGD_DECLARE(int) gdImageBoundsSafe (gdImagePtr im, int x, int y)\n{\n\treturn gdImageBoundsSafeMacro (im, x, y);\n}\n\nBGD_DECLARE(void) gdImageChar (gdImagePtr im, gdFontPtr f, int x, int y, int c, int color)\n{\n\tint cx, cy;\n\tint px, py;\n\tint fline;\n\tcx = 0;\n\tcy = 0;\n#ifdef CHARSET_EBCDIC\n\tc = ASC (c);\n#endif /*CHARSET_EBCDIC */\n\tif ((c < f->offset) || (c >= (f->offset + f->nchars))) {\n\t\treturn;\n\t}\n\tfline = (c - f->offset) * f->h * f->w;\n\tfor (py = y; (py < (y + f->h)); py++) {\n\t\tfor (px = x; (px < (x + f->w)); px++) {\n\t\t\tif (f->data[fline + cy * f->w + cx]) {\n\t\t\t\tgdImageSetPixel (im, px, py, color);\n\t\t\t}\n\t\t\tcx++;\n\t\t}\n\t\tcx = 0;\n\t\tcy++;\n\t}\n}\n\nBGD_DECLARE(void) gdImageCharUp (gdImagePtr im, gdFontPtr f, int x, int y, int c, int color)\n{\n\tint cx, cy;\n\tint px, py;\n\tint fline;\n\tcx = 0;\n\tcy = 0;\n#ifdef CHARSET_EBCDIC\n\tc = ASC (c);\n#endif /*CHARSET_EBCDIC */\n\tif ((c < f->offset) || (c >= (f->offset + f->nchars))) {\n\t\treturn;\n\t}\n\tfline = (c - f->offset) * f->h * f->w;\n\tfor (py = y; (py > (y - f->w)); py--) {\n\t\tfor (px = x; (px < (x + f->h)); px++) {\n\t\t\tif (f->data[fline + cy * f->w + cx]) {\n\t\t\t\tgdImageSetPixel (im, px, py, color);\n\t\t\t}\n\t\t\tcy++;\n\t\t}\n\t\tcy = 0;\n\t\tcx++;\n\t}\n}\n\nBGD_DECLARE(void) gdImageString (gdImagePtr im, gdFontPtr f,\n\t\t\t\t\t\t\t\t int x, int y, unsigned char *s, int color)\n{\n\tint i;\n\tint l;\n\tl = strlen ((char *) s);\n\tfor (i = 0; (i < l); i++) {\n\t\tgdImageChar (im, f, x, y, s[i], color);\n\t\tx += f->w;\n\t}\n}\n\nBGD_DECLARE(void) gdImageStringUp (gdImagePtr im, gdFontPtr f,\n\t\t\t\t\t\t\t\t   int x, int y, unsigned char *s, int color)\n{\n\tint i;\n\tint l;\n\tl = strlen ((char *) s);\n\tfor (i = 0; (i < l); i++) {\n\t\tgdImageCharUp (im, f, x, y, s[i], color);\n\t\ty -= f->w;\n\t}\n}\n\nstatic int strlen16 (unsigned short *s);\n\nBGD_DECLARE(void) gdImageString16 (gdImagePtr im, gdFontPtr f,\n\t\t\t\t\t\t\t\t   int x, int y, unsigned short *s, int color)\n{\n\tint i;\n\tint l;\n\tl = strlen16 (s);\n\tfor (i = 0; (i < l); i++) {\n\t\tgdImageChar (im, f, x, y, s[i], color);\n\t\tx += f->w;\n\t}\n}\n\nBGD_DECLARE(void) gdImageStringUp16 (gdImagePtr im, gdFontPtr f,\n\t\t\t\t\t\t\t\t\t int x, int y, unsigned short *s, int color)\n{\n\tint i;\n\tint l;\n\tl = strlen16 (s);\n\tfor (i = 0; (i < l); i++) {\n\t\tgdImageCharUp (im, f, x, y, s[i], color);\n\t\ty -= f->w;\n\t}\n}\n\nstatic int\nstrlen16 (unsigned short *s)\n{\n\tint len = 0;\n\twhile (*s) {\n\t\ts++;\n\t\tlen++;\n\t}\n\treturn len;\n}\n\n#ifndef HAVE_LSQRT\n/* If you don't have a nice square root function for longs, you can use\n   ** this hack\n */\nlong\nlsqrt (long n)\n{\n\tlong result = (long) sqrt ((double) n);\n\treturn result;\n}\n#endif\n\n/* s and e are integers modulo 360 (degrees), with 0 degrees\n   being the rightmost extreme and degrees changing clockwise.\n   cx and cy are the center in pixels; w and h are the horizontal\n   and vertical diameter in pixels. Nice interface, but slow.\n   See gd_arc_f_buggy.c for a better version that doesn't\n   seem to be bug-free yet. */\n\nBGD_DECLARE(void) gdImageArc (gdImagePtr im, int cx, int cy, int w, int h, int s, int e,\n\t\t\t\t\t\t\t  int color)\n{\n\tgdImageFilledArc (im, cx, cy, w, h, s, e, color, gdNoFill);\n}\n\nBGD_DECLARE(void) gdImageFilledArc (gdImagePtr im, int cx, int cy, int w, int h, int s, int e,\n\t\t\t\t\t\t\t\t\tint color, int style)\n{\n\tgdPoint pts[3];\n\tint i;\n\tint lx = 0, ly = 0;\n\tint fx = 0, fy = 0;\n\n\tif ((s % 360)  == (e % 360)) {\n\t\ts = 0;\n\t\te = 360;\n\t} else {\n\t\tif (s > 360) {\n\t\t\ts = s % 360;\n\t\t}\n\n\t\tif (e > 360) {\n\t\t\te = e % 360;\n\t\t}\n\n\t\twhile (s < 0) {\n\t\t\ts += 360;\n\t\t}\n\n\t\twhile (e < s) {\n\t\t\te += 360;\n\t\t}\n\n\t\tif (s == e) {\n\t\t\ts = 0;\n\t\t\te = 360;\n\t\t}\n\t}\n\n\tfor (i = s; (i <= e); i++) {\n\t\tint x, y;\n\t\tx = ((long) gdCosT[i % 360] * (long) w / (2 * 1024)) + cx;\n\t\ty = ((long) gdSinT[i % 360] * (long) h / (2 * 1024)) + cy;\n\t\tif (i != s) {\n\t\t\tif (!(style & gdChord)) {\n\t\t\t\tif (style & gdNoFill) {\n\t\t\t\t\tgdImageLine (im, lx, ly, x, y, color);\n\t\t\t\t} else {\n\t\t\t\t\t/* This is expensive! */\n\t\t\t\t\tpts[0].x = lx;\n\t\t\t\t\tpts[0].y = ly;\n\t\t\t\t\tpts[1].x = x;\n\t\t\t\t\tpts[1].y = y;\n\t\t\t\t\tpts[2].x = cx;\n\t\t\t\t\tpts[2].y = cy;\n\t\t\t\t\tgdImageFilledPolygon (im, pts, 3, color);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfx = x;\n\t\t\tfy = y;\n\t\t}\n\t\tlx = x;\n\t\tly = y;\n\t}\n\tif (style & gdChord) {\n\t\tif (style & gdNoFill) {\n\t\t\tif (style & gdEdged) {\n\t\t\t\tgdImageLine (im, cx, cy, lx, ly, color);\n\t\t\t\tgdImageLine (im, cx, cy, fx, fy, color);\n\t\t\t}\n\t\t\tgdImageLine (im, fx, fy, lx, ly, color);\n\t\t} else {\n\t\t\tpts[0].x = fx;\n\t\t\tpts[0].y = fy;\n\t\t\tpts[1].x = lx;\n\t\t\tpts[1].y = ly;\n\t\t\tpts[2].x = cx;\n\t\t\tpts[2].y = cy;\n\t\t\tgdImageFilledPolygon (im, pts, 3, color);\n\t\t}\n\t} else {\n\t\tif (style & gdNoFill) {\n\t\t\tif (style & gdEdged) {\n\t\t\t\tgdImageLine (im, cx, cy, lx, ly, color);\n\t\t\t\tgdImageLine (im, cx, cy, fx, fy, color);\n\t\t\t}\n\t\t}\n\t}\n}\n\nBGD_DECLARE(void) gdImageEllipse(gdImagePtr im, int mx, int my, int w, int h, int c)\n{\n\tint x=0,mx1=0,mx2=0,my1=0,my2=0;\n\tlong aq,bq,dx,dy,r,rx,ry,a,b;\n\n\ta=w>>1;\n\tb=h>>1;\n\tgdImageSetPixel(im,mx+a, my, c);\n\tgdImageSetPixel(im,mx-a, my, c);\n\tmx1 = mx-a;\n\tmy1 = my;\n\tmx2 = mx+a;\n\tmy2 = my;\n\n\taq = a * a;\n\tbq = b * b;\n\tdx = aq << 1;\n\tdy = bq << 1;\n\tr  = a * bq;\n\trx = r << 1;\n\try = 0;\n\tx = a;\n\twhile (x > 0) {\n\t\tif (r > 0) {\n\t\t\tmy1++;\n\t\t\tmy2--;\n\t\t\try +=dx;\n\t\t\tr  -=ry;\n\t\t}\n\t\tif (r <= 0) {\n\t\t\tx--;\n\t\t\tmx1++;\n\t\t\tmx2--;\n\t\t\trx -=dy;\n\t\t\tr  +=rx;\n\t\t}\n\t\tgdImageSetPixel(im,mx1, my1, c);\n\t\tgdImageSetPixel(im,mx1, my2, c);\n\t\tgdImageSetPixel(im,mx2, my1, c);\n\t\tgdImageSetPixel(im,mx2, my2, c);\n\t}\n}\n\n\nBGD_DECLARE(void) gdImageFilledEllipse (gdImagePtr im, int mx, int my, int w, int h, int c)\n{\n\tint x=0,mx1=0,mx2=0,my1=0,my2=0;\n\tlong aq,bq,dx,dy,r,rx,ry,a,b;\n\tint i;\n\tint old_y2;\n\n\ta=w>>1;\n\tb=h>>1;\n\n\tfor (x = mx-a; x <= mx+a; x++) {\n\t\tgdImageSetPixel(im, x, my, c);\n\t}\n\n\tmx1 = mx-a;\n\tmy1 = my;\n\tmx2 = mx+a;\n\tmy2 = my;\n\n\taq = a * a;\n\tbq = b * b;\n\tdx = aq << 1;\n\tdy = bq << 1;\n\tr  = a * bq;\n\trx = r << 1;\n\try = 0;\n\tx = a;\n\told_y2=-2;\n\twhile (x > 0) {\n\t\tif (r > 0) {\n\t\t\tmy1++;\n\t\t\tmy2--;\n\t\t\try +=dx;\n\t\t\tr  -=ry;\n\t\t}\n\t\tif (r <= 0) {\n\t\t\tx--;\n\t\t\tmx1++;\n\t\t\tmx2--;\n\t\t\trx -=dy;\n\t\t\tr  +=rx;\n\t\t}\n\t\tif(old_y2!=my2) {\n\t\t\tfor(i=mx1; i<=mx2; i++) {\n\t\t\t\tgdImageSetPixel(im,i,my1,c);\n\t\t\t}\n\t\t}\n\t\tif(old_y2!=my2) {\n\t\t\tfor(i=mx1; i<=mx2; i++) {\n\t\t\t\tgdImageSetPixel(im,i,my2,c);\n\t\t\t}\n\t\t}\n\t\told_y2 = my2;\n\t}\n}\n\nBGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit, rightLimit;\n\tint i;\n\tint restoreAlphaBleding;\n\n\tif (border < 0) {\n\t\t/* Refuse to fill to a non-solid border */\n\t\treturn;\n\t}\n\n\tleftLimit = (-1);\n\n\trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\t\n\tfor (i = x; (i >= 0); i--) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == (-1)) {\n\t\tim->alphaBlendingFlag = restoreAlphaBleding;\n\t\treturn;\n\t}\n\t/* Seek right */\n\trightLimit = x;\n\tfor (i = (x + 1); (i < im->sx); i++) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t/* Look at lines above and below and start paints */\n\t/* Above */\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c;\n\t\t\tc = gdImageGetPixel (im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\t/* Below */\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c = gdImageGetPixel (im, i, y + 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBleding;\n}\n\n/*\n * set the pixel at (x,y) and its 4-connected neighbors\n * with the same pixel value to the new pixel value nc (new color).\n * A 4-connected neighbor:  pixel above, below, left, or right of a pixel.\n * ideas from comp.graphics discussions.\n * For tiled fill, the use of a flag buffer is mandatory. As the tile image can\n * contain the same color as the color to fill. To do not bloat normal filling\n * code I added a 2nd private function.\n */\n\nstatic int gdImageTileGet (gdImagePtr im, int x, int y)\n{\n\tint srcx, srcy;\n\tint tileColor,p;\n\tif (!im->tile) {\n\t\treturn -1;\n\t}\n\tsrcx = x % gdImageSX(im->tile);\n\tsrcy = y % gdImageSY(im->tile);\n\tp = gdImageGetPixel(im->tile, srcx, srcy);\n\tif (p == im->tile->transparent) {\n\t\ttileColor = im->transparent;\n\t} else if (im->trueColor) {\n\t\tif (im->tile->trueColor) {\n\t\t\ttileColor = p;\n\t\t} else {\n\t\t\ttileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));\n\t\t}\n\t} else {\n\t\tif (im->tile->trueColor) {\n\t\t\ttileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));\n\t\t} else {\n\t\t\ttileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));\n\t\t}\n\t}\n\treturn tileColor;\n}\n\n\n\n/* horizontal segment of scan line y */\nstruct seg {\n\tint y, xl, xr, dy;\n};\n\n/* max depth of stack */\n#define FILL_MAX ((int)(im->sy*im->sx)/4)\n#define FILL_PUSH(Y, XL, XR, DY) \\\n\tif (sp<stack+FILL_MAX && Y+(DY)>=0 && Y+(DY)<wy2) \\\n\t{sp->y = Y; sp->xl = XL; sp->xr = XR; sp->dy = DY; sp++;}\n\n#define FILL_POP(Y, XL, XR, DY) \\\n\t{sp--; Y = sp->y+(DY = sp->dy); XL = sp->xl; XR = sp->xr;}\n\nstatic void _gdImageFillTiled(gdImagePtr im, int x, int y, int nc);\nBGD_DECLARE(void) gdImageFill(gdImagePtr im, int x, int y, int nc)\n{\n\tint l, x1, x2, dy;\n\tint oc;   /* old pixel value */\n\tint wx2,wy2;\n\n\tint alphablending_bak;\n\n\t/* stack of filled segments */\n\t/* struct seg stack[FILL_MAX],*sp = stack; */\n\tstruct seg *stack;\n\tstruct seg *sp;\n\n\tif (!im->trueColor && nc > (im->colorsTotal - 1)) {\n\t\treturn;\n\t}\n\n\talphablending_bak = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (nc==gdTiled) {\n\t\t_gdImageFillTiled(im,x,y,nc);\n\t\tim->alphaBlendingFlag = alphablending_bak;\n\t\treturn;\n\t}\n\n\twx2=im->sx;\n\twy2=im->sy;\n\toc = gdImageGetPixel(im, x, y);\n\tif (oc==nc || x<0 || x>wx2 || y<0 || y>wy2) {\n\t\tim->alphaBlendingFlag = alphablending_bak;\n\t\treturn;\n\t}\n\n\t/* Do not use the 4 neighbors implementation with\n\t* small images\n\t*/\n\tif (im->sx < 4) {\n\t\tint ix = x, iy = y, c;\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tc = gdImageGetPixel(im, ix, iy);\n\t\t\t\tif (c != oc) {\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tgdImageSetPixel(im, ix, iy, nc);\n\t\t\t} while(ix++ < (im->sx -1));\n\t\t\tix = x;\n\t\t} while(iy++ < (im->sy -1));\n\t\tgoto done;\n\t}\n\n\tif(overflow2(im->sy, im->sx)) {\n\t\treturn;\n\t}\n\n\tif(overflow2(sizeof(struct seg), ((im->sy * im->sx) / 4))) {\n\t\treturn;\n\t}\n\n\tstack = (struct seg *)gdMalloc(sizeof(struct seg) * ((int)(im->sy*im->sx)/4));\n\tif (!stack) {\n\t\treturn;\n\t}\n\tsp = stack;\n\n\t/* required! */\n\tFILL_PUSH(y,x,x,1);\n\t/* seed segment (popped 1st) */\n\tFILL_PUSH(y+1, x, x, -1);\n\twhile (sp>stack) {\n\t\tFILL_POP(y, x1, x2, dy);\n\n\t\tfor (x=x1; x>=0 && gdImageGetPixel(im,x, y)==oc; x--) {\n\t\t\tgdImageSetPixel(im,x, y, nc);\n\t\t}\n\t\tif (x>=x1) {\n\t\t\tgoto skip;\n\t\t}\n\t\tl = x+1;\n\n\t\t/* leak on left? */\n\t\tif (l<x1) {\n\t\t\tFILL_PUSH(y, l, x1-1, -dy);\n\t\t}\n\t\tx = x1+1;\n\t\tdo {\n\t\t\tfor (; x<=wx2 && gdImageGetPixel(im,x, y)==oc; x++) {\n\t\t\t\tgdImageSetPixel(im, x, y, nc);\n\t\t\t}\n\t\t\tFILL_PUSH(y, l, x-1, dy);\n\t\t\t/* leak on right? */\n\t\t\tif (x>x2+1) {\n\t\t\t\tFILL_PUSH(y, x2+1, x-1, -dy);\n\t\t\t}\nskip:\n\t\t\tfor (x++; x<=x2 && (gdImageGetPixel(im, x, y)!=oc); x++);\n\n\t\t\tl = x;\n\t\t} while (x<=x2);\n\t}\n\n\tgdFree(stack);\n\ndone:\n\tim->alphaBlendingFlag = alphablending_bak;\n}\n\nstatic void _gdImageFillTiled(gdImagePtr im, int x, int y, int nc)\n{\n\tint l, x1, x2, dy;\n\tint oc;   /* old pixel value */\n\tint wx2,wy2;\n\t/* stack of filled segments */\n\tstruct seg *stack;\n\tstruct seg *sp;\n\tchar *pts;\n\n\tif (!im->tile) {\n\t\treturn;\n\t}\n\n\twx2=im->sx;\n\twy2=im->sy;\n\n\tif(overflow2(im->sy, im->sx)) {\n\t\treturn;\n\t}\n\n\tif(overflow2(sizeof(struct seg), ((im->sy * im->sx) / 4))) {\n\t\treturn;\n\t}\n\n\tpts = (char *) gdCalloc(im->sy * im->sx, sizeof(char));\n\tif (!pts) {\n\t\treturn;\n\t}\n\n\tstack = (struct seg *)gdMalloc(sizeof(struct seg) * ((int)(im->sy*im->sx)/4));\n\tif (!stack) {\n\t\tgdFree(pts);\n\t\treturn;\n\t}\n\tsp = stack;\n\n\toc = gdImageGetPixel(im, x, y);\n\n\t/* required! */\n\tFILL_PUSH(y,x,x,1);\n\t/* seed segment (popped 1st) */\n\tFILL_PUSH(y+1, x, x, -1);\n\twhile (sp>stack) {\n\t\tFILL_POP(y, x1, x2, dy);\n\t\tfor (x=x1; x>=0 && (!pts[y + x*wy2] && gdImageGetPixel(im,x,y)==oc); x--) {\n\t\t\tnc = gdImageTileGet(im,x,y);\n\t\t\tpts[y + x*wy2]=1;\n\t\t\tgdImageSetPixel(im,x, y, nc);\n\t\t}\n\t\tif (x>=x1) {\n\t\t\tgoto skip;\n\t\t}\n\t\tl = x+1;\n\n\t\t/* leak on left? */\n\t\tif (l<x1) {\n\t\t\tFILL_PUSH(y, l, x1-1, -dy);\n\t\t}\n\t\tx = x1+1;\n\t\tdo {\n\t\t\tfor (; x<wx2 && (!pts[y + x*wy2] && gdImageGetPixel(im,x, y)==oc) ; x++) {\n\t\t\t\tif (pts[y + x*wy2]) {\n\t\t\t\t\t/* we should never be here */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnc = gdImageTileGet(im,x,y);\n\t\t\t\tpts[y + x*wy2]=1;\n\t\t\t\tgdImageSetPixel(im, x, y, nc);\n\t\t\t}\n\t\t\tFILL_PUSH(y, l, x-1, dy);\n\t\t\t/* leak on right? */\n\t\t\tif (x>x2+1) {\n\t\t\t\tFILL_PUSH(y, x2+1, x-1, -dy);\n\t\t\t}\nskip:\n\t\t\tfor (x++; x<=x2 && (pts[y + x*wy2] || gdImageGetPixel(im,x, y)!=oc); x++);\n\t\t\tl = x;\n\t\t} while (x<=x2);\n\t}\n\n\tgdFree(pts);\n\tgdFree(stack);\n}\n\nBGD_DECLARE(void) gdImageRectangle (gdImagePtr im, int x1, int y1, int x2, int y2, int color)\n{\n\tint thick = im->thick;\n\n\tif (x1 == x2 && y1 == y2 && thick == 1) {\n\t\tgdImageSetPixel(im, x1, y1, color);\n\t\treturn;\n\t}\n\n\tif (y2 < y1) {\n\t\tint t;\n\t\tt = y1;\n\t\ty1 = y2;\n\t\ty2 = t;\n\n\t\tt = x1;\n\t\tx1 = x2;\n\t\tx2 = t;\n\t}\n\n\tif (thick > 1) {\n\t\tint cx, cy, x1ul, y1ul, x2lr, y2lr;\n\t\tint half = thick >> 1;\n\t\tx1ul = x1 - half;\n\t\ty1ul = y1 - half;\n\n\t\tx2lr = x2 + half;\n\t\ty2lr = y2 + half;\n\n\t\tcy = y1ul + thick;\n\t\twhile (cy-- > y1ul) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y2lr - thick;\n\t\twhile (cy++ < y2lr) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y1ul + thick - 1;\n\t\twhile (cy++ < y2lr -thick) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x1ul + thick) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y1ul + thick - 1;\n\t\twhile (cy++ < y2lr -thick) {\n\t\t\tcx = x2lr - thick - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t} else {\n\t\tgdImageLine(im, x1, y1, x2, y1, color);\n\t\tgdImageLine(im, x1, y2, x2, y2, color);\n\t\tgdImageLine(im, x1, y1 + 1, x1, y2 - 1, color);\n\t\tgdImageLine(im, x2, y1 + 1, x2, y2 - 1, color);\n\t}\n}\n\nBGD_DECLARE(void) gdImageFilledRectangle (gdImagePtr im, int x1, int y1, int x2, int y2,\n\t\tint color)\n{\n\tint x, y;\n\n\tif (x1 == x2 && y1 == y2) {\n\t\tgdImageSetPixel(im, x1, y1, color);\n\t\treturn;\n\t}\n\n\tif (x1 > x2) {\n\t\tx = x1;\n\t\tx1 = x2;\n\t\tx2 = x;\n\t}\n\n\tif (y1 > y2) {\n\t\ty = y1;\n\t\ty1 = y2;\n\t\ty2 = y;\n\t}\n\n\tif (x1 < 0) {\n\t\tx1 = 0;\n\t}\n\n\tif (x2 >= gdImageSX(im)) {\n\t\tx2 = gdImageSX(im) - 1;\n\t}\n\n\tif (y1 < 0) {\n\t\ty1 = 0;\n\t}\n\n\tif (y2 >= gdImageSY(im)) {\n\t\ty2 = gdImageSY(im) - 1;\n\t}\n\n\tfor (y = y1; (y <= y2); y++) {\n\t\tfor (x = x1; (x <= x2); x++) {\n\t\t\tgdImageSetPixel (im, x, y, color);\n\t\t}\n\t}\n}\n\nBGD_DECLARE(gdImagePtr) gdImageClone (gdImagePtr src) {\n\tgdImagePtr dst;\n\tregister int i, x;\n\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(src->sx , src->sy);\n\t} else {\n\t\tdst = gdImageCreate(src->sx , src->sy);\n\t}\n\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (src->trueColor == 0) {\n\t\tdst->colorsTotal = src->colorsTotal;\n\t\tfor (i = 0; i < gdMaxColors; i++) {\n\t\t\tdst->red[i]   = src->red[i];\n\t\t\tdst->green[i] = src->green[i];\n\t\t\tdst->blue[i]  = src->blue[i];\n\t\t\tdst->alpha[i] = src->alpha[i];\n\t\t\tdst->open[i]  = src->open[i];\n\t\t}\n\t\tfor (i = 0; i < src->sy; i++) {\n\t\t\tfor (x = 0; x < src->sx; x++) {\n\t\t\t\tdst->pixels[i][x] = src->pixels[i][x];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < src->sy; i++) {\n\t\t\tfor (x = 0; x < src->sx; x++) {\n\t\t\t\tdst->tpixels[i][x] = src->tpixels[i][x];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (src->styleLength > 0) {\n\t\tdst->styleLength = src->styleLength;\n\t\tdst->stylePos    = src->stylePos;\n\t\tfor (i = 0; i < src->styleLength; i++) {\n\t\t\tdst->style[i] = src->style[i];\n\t\t}\n\t}\n\n\tdst->interlace   = src->interlace;\n\n\tdst->alphaBlendingFlag = src->alphaBlendingFlag;\n\tdst->saveAlphaFlag     = src->saveAlphaFlag;\n\tdst->AA                = src->AA;\n\tdst->AA_color          = src->AA_color;\n\tdst->AA_dont_blend     = src->AA_dont_blend;\n\n\tdst->cx1 = src->cx1;\n\tdst->cy1 = src->cy1;\n\tdst->cx2 = src->cx2;\n\tdst->cy2 = src->cy2;\n\n\tdst->res_x = src->res_x;\n\tdst->res_y = src->res_x;\n\n\tdst->paletteQuantizationMethod     = src->paletteQuantizationMethod;\n\tdst->paletteQuantizationSpeed      = src->paletteQuantizationSpeed;\n\tdst->paletteQuantizationMinQuality = src->paletteQuantizationMinQuality;\n\tdst->paletteQuantizationMinQuality = src->paletteQuantizationMinQuality;\n\n\tdst->interpolation_id = src->interpolation_id;\n\tdst->interpolation    = src->interpolation;\n\n\tif (src->brush) {\n\t\tdst->brush = gdImageClone(src->brush);\n\t}\n\n\tif (src->tile) {\n\t\tdst->tile = gdImageClone(src->tile);\n\t}\n\n\tif (src->style) {\n\t\tgdImageSetStyle(dst, src->style, src->styleLength);\n\t}\n\n\tfor (i = 0; i < gdMaxColors; i++) {\n\t\tdst->brushColorMap[i] = src->brushColorMap[i];\n\t\tdst->tileColorMap[i] = src->tileColorMap[i];\n\t}\n\n\tif (src->polyAllocated > 0) {\n\t\tdst->polyAllocated = src->polyAllocated;\n\t\tfor (i = 0; i < src->polyAllocated; i++) {\n\t\t\tdst->polyInts[i] = src->polyInts[i];\n\t\t}\n\t}\n\n\treturn dst;\n}\n\nBGD_DECLARE(void) gdImageCopy (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX,\n\t\t\t\t\t\t\t   int srcY, int w, int h)\n{\n\tint c;\n\tint x, y;\n\tint tox, toy;\n\tint i;\n\tint colorMap[gdMaxColors];\n\n\tif (dst->trueColor) {\n\t\t/* 2.0: much easier when the destination is truecolor. */\n\t\t/* 2.0.10: needs a transparent-index check that is still valid if\n\t\t *          * the source is not truecolor. Thanks to Frank Warmerdam.\n\t\t */\n\n\t\tif (src->trueColor) {\n\t\t\tfor (y = 0; (y < h); y++) {\n\t\t\t\tfor (x = 0; (x < w); x++) {\n\t\t\t\t\tint c = gdImageGetTrueColorPixel (src, srcX + x, srcY + y);\n\t\t\t\t\tif (c != src->transparent) {\n\t\t\t\t\t\tgdImageSetPixel (dst, dstX + x, dstY + y, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* source is palette based */\n\t\t\tfor (y = 0; (y < h); y++) {\n\t\t\t\tfor (x = 0; (x < w); x++) {\n\t\t\t\t\tint c = gdImageGetPixel (src, srcX + x, srcY + y);\n\t\t\t\t\tif (c != src->transparent) {\n\t\t\t\t\t\tgdImageSetPixel(dst, dstX + x, dstY + y, gdTrueColorAlpha(src->red[c], src->green[c], src->blue[c], src->alpha[c]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tcolorMap[i] = (-1);\n\t}\n\ttoy = dstY;\n\tfor (y = srcY; (y < (srcY + h)); y++) {\n\t\ttox = dstX;\n\t\tfor (x = srcX; (x < (srcX + w)); x++) {\n\t\t\tint nc;\n\t\t\tint mapTo;\n\t\t\tc = gdImageGetPixel (src, x, y);\n\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\tif (gdImageGetTransparent (src) == c) {\n\t\t\t\ttox++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Have we established a mapping for this color? */\n\t\t\tif (src->trueColor) {\n\t\t\t\t/* 2.05: remap to the palette available in the\n\t\t\t\t destination image. This is slow and\n\t\t\t\t works badly, but it beats crashing! Thanks\n\t\t\t\t to Padhrig McCarthy. */\n\t\t\t\tmapTo = gdImageColorResolveAlpha (dst,\n\t\t\t\t                                  gdTrueColorGetRed (c),\n\t\t\t\t                                  gdTrueColorGetGreen (c),\n\t\t\t\t                                  gdTrueColorGetBlue (c),\n\t\t\t\t                                  gdTrueColorGetAlpha (c));\n\t\t\t} else if (colorMap[c] == (-1)) {\n\t\t\t\t/* If it's the same image, mapping is trivial */\n\t\t\t\tif (dst == src) {\n\t\t\t\t\tnc = c;\n\t\t\t\t} else {\n\t\t\t\t\t/* Get best match possible. This\n\t\t\t\t\t   function never returns error. */\n\t\t\t\t\tnc = gdImageColorResolveAlpha (dst,\n\t\t\t\t\t                               src->red[c], src->green[c],\n\t\t\t\t\t                               src->blue[c], src->alpha[c]);\n\t\t\t\t}\n\t\t\t\tcolorMap[c] = nc;\n\t\t\t\tmapTo = colorMap[c];\n\t\t\t} else {\n\t\t\t\tmapTo = colorMap[c];\n\t\t\t}\n\t\t\tgdImageSetPixel (dst, tox, toy, mapTo);\n\t\t\ttox++;\n\t\t}\n\t\ttoy++;\n\t}\n}\n\n/* This function is a substitute for real alpha channel operations,\n   so it doesn't pay attention to the alpha channel. */\nBGD_DECLARE(void) gdImageCopyMerge (gdImagePtr dst, gdImagePtr src, int dstX, int dstY,\n\t\t\t\t\t\t\t\t\tint srcX, int srcY, int w, int h, int pct)\n{\n\n\tint c, dc;\n\tint x, y;\n\tint tox, toy;\n\tint ncR, ncG, ncB;\n\ttoy = dstY;\n\tfor (y = srcY; (y < (srcY + h)); y++) {\n\t\ttox = dstX;\n\t\tfor (x = srcX; (x < (srcX + w)); x++) {\n\t\t\tint nc;\n\t\t\tc = gdImageGetPixel (src, x, y);\n\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\tif (gdImageGetTransparent (src) == c) {\n\t\t\t\ttox++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* If it's the same image, mapping is trivial */\n\t\t\tif (dst == src) {\n\t\t\t\tnc = c;\n\t\t\t} else {\n\t\t\t\tdc = gdImageGetPixel (dst, tox, toy);\n\n\t\t\t\tncR = gdImageRed (src, c) * (pct / 100.0)\n\t\t\t\t      + gdImageRed (dst, dc) * ((100 - pct) / 100.0);\n\t\t\t\tncG = gdImageGreen (src, c) * (pct / 100.0)\n\t\t\t\t      + gdImageGreen (dst, dc) * ((100 - pct) / 100.0);\n\t\t\t\tncB = gdImageBlue (src, c) * (pct / 100.0)\n\t\t\t\t      + gdImageBlue (dst, dc) * ((100 - pct) / 100.0);\n\n\t\t\t\t/* Find a reasonable color */\n\t\t\t\tnc = gdImageColorResolve (dst, ncR, ncG, ncB);\n\t\t\t}\n\t\t\tgdImageSetPixel (dst, tox, toy, nc);\n\t\t\ttox++;\n\t\t}\n\t\ttoy++;\n\t}\n}\n\n/* This function is a substitute for real alpha channel operations,\n   so it doesn't pay attention to the alpha channel. */\nBGD_DECLARE(void) gdImageCopyMergeGray (gdImagePtr dst, gdImagePtr src, int dstX, int dstY,\n\t\t\t\t\t\t\t\t\t\tint srcX, int srcY, int w, int h, int pct)\n{\n\n\tint c, dc;\n\tint x, y;\n\tint tox, toy;\n\tint ncR, ncG, ncB;\n\tfloat g;\n\ttoy = dstY;\n\tfor (y = srcY; (y < (srcY + h)); y++) {\n\t\ttox = dstX;\n\t\tfor (x = srcX; (x < (srcX + w)); x++) {\n\t\t\tint nc;\n\t\t\tc = gdImageGetPixel (src, x, y);\n\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\tif (gdImageGetTransparent (src) == c) {\n\t\t\t\ttox++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If it's the same image, mapping is NOT trivial since we\n\t\t\t * merge with greyscale target, but if pct is 100, the grey\n\t\t\t * value is not used, so it becomes trivial. pjw 2.0.12.\n\t\t\t */\n\t\t\tif (dst == src && pct == 100) {\n\t\t\t\tnc = c;\n\t\t\t} else {\n\t\t\t\tdc = gdImageGetPixel (dst, tox, toy);\n\t\t\t\tg = 0.29900 * gdImageRed(dst, dc)\n\t\t\t\t    + 0.58700 * gdImageGreen(dst, dc) + 0.11400 * gdImageBlue(dst, dc);\n\n\t\t\t\tncR = gdImageRed (src, c) * (pct / 100.0)\n\t\t\t\t      + g * ((100 - pct) / 100.0);\n\t\t\t\tncG = gdImageGreen (src, c) * (pct / 100.0)\n\t\t\t\t      + g * ((100 - pct) / 100.0);\n\t\t\t\tncB = gdImageBlue (src, c) * (pct / 100.0)\n\t\t\t\t      + g * ((100 - pct) / 100.0);\n\n\t\t\t\t/* First look for an exact match */\n\t\t\t\tnc = gdImageColorExact (dst, ncR, ncG, ncB);\n\t\t\t\tif (nc == (-1)) {\n\t\t\t\t\t/* No, so try to allocate it */\n\t\t\t\t\tnc = gdImageColorAllocate (dst, ncR, ncG, ncB);\n\t\t\t\t\t/* If we're out of colors, go for the\n\t\t\t\t\t   closest color */\n\t\t\t\t\tif (nc == (-1)) {\n\t\t\t\t\t\tnc = gdImageColorClosest (dst, ncR, ncG, ncB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgdImageSetPixel (dst, tox, toy, nc);\n\t\t\ttox++;\n\t\t}\n\t\ttoy++;\n\t}\n}\n\nBGD_DECLARE(void) gdImageCopyResized (gdImagePtr dst, gdImagePtr src, int dstX, int dstY,\n\t\t\t\t\t\t\t\t\t  int srcX, int srcY, int dstW, int dstH, int srcW,\n\t\t\t\t\t\t\t\t\t  int srcH)\n{\n\tint c;\n\tint x, y;\n\tint tox, toy;\n\tint ydest;\n\tint i;\n\tint colorMap[gdMaxColors];\n\t/* Stretch vectors */\n\tint *stx;\n\tint *sty;\n\t/* We only need to use floating point to determine the correct\n\t   stretch vector for one line's worth. */\n\tif (overflow2(sizeof (int), srcW)) {\n\t\treturn;\n\t}\n\tif (overflow2(sizeof (int), srcH)) {\n\t\treturn;\n\t}\n\tstx = (int *) gdMalloc (sizeof (int) * srcW);\n\tif (!stx) {\n\t\treturn;\n\t}\n\n\tsty = (int *) gdMalloc (sizeof (int) * srcH);\n\tif (!sty) {\n\t\tgdFree(stx);\n\t\treturn;\n\t}\n\n\t/* Fixed by Mao Morimoto 2.0.16 */\n\tfor (i = 0; (i < srcW); i++) {\n\t\tstx[i] = dstW * (i + 1) / srcW - dstW * i / srcW;\n\t}\n\tfor (i = 0; (i < srcH); i++) {\n\t\tsty[i] = dstH * (i + 1) / srcH - dstH * i / srcH;\n\t}\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tcolorMap[i] = (-1);\n\t}\n\ttoy = dstY;\n\tfor (y = srcY; (y < (srcY + srcH)); y++) {\n\t\tfor (ydest = 0; (ydest < sty[y - srcY]); ydest++) {\n\t\t\ttox = dstX;\n\t\t\tfor (x = srcX; (x < (srcX + srcW)); x++) {\n\t\t\t\tint nc = 0;\n\t\t\t\tint mapTo;\n\t\t\t\tif (!stx[x - srcX]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (dst->trueColor) {\n\t\t\t\t\t/* 2.0.9: Thorben Kundinger: Maybe the source image is not\n\t\t\t\t\t   a truecolor image */\n\t\t\t\t\tif (!src->trueColor) {\n\t\t\t\t\t\tint tmp = gdImageGetPixel (src, x, y);\n\t\t\t\t\t\tmapTo = gdImageGetTrueColorPixel (src, x, y);\n\t\t\t\t\t\tif (gdImageGetTransparent (src) == tmp) {\n\t\t\t\t\t\t\t/* 2.0.21, TK: not tox++ */\n\t\t\t\t\t\t\ttox += stx[x - srcX];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* TK: old code follows */\n\t\t\t\t\t\tmapTo = gdImageGetTrueColorPixel (src, x, y);\n\t\t\t\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\t\t\t\tif (gdImageGetTransparent (src) == mapTo) {\n\t\t\t\t\t\t\t/* 2.0.21, TK: not tox++ */\n\t\t\t\t\t\t\ttox += stx[x - srcX];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tc = gdImageGetPixel (src, x, y);\n\t\t\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\t\t\tif (gdImageGetTransparent (src) == c) {\n\t\t\t\t\t\ttox += stx[x - srcX];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (src->trueColor) {\n\t\t\t\t\t\t/* Remap to the palette available in the\n\t\t\t\t\t\t   destination image. This is slow and\n\t\t\t\t\t\t   works badly. */\n\t\t\t\t\t\tmapTo = gdImageColorResolveAlpha (dst,\n\t\t\t\t\t\t                                  gdTrueColorGetRed (c),\n\t\t\t\t\t\t                                  gdTrueColorGetGreen\n\t\t\t\t\t\t                                  (c),\n\t\t\t\t\t\t                                  gdTrueColorGetBlue\n\t\t\t\t\t\t                                  (c),\n\t\t\t\t\t\t                                  gdTrueColorGetAlpha\n\t\t\t\t\t\t                                  (c));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Have we established a mapping for this color? */\n\t\t\t\t\t\tif (colorMap[c] == (-1)) {\n\t\t\t\t\t\t\t/* If it's the same image, mapping is trivial */\n\t\t\t\t\t\t\tif (dst == src) {\n\t\t\t\t\t\t\t\tnc = c;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t/* Find or create the best match */\n\t\t\t\t\t\t\t\t/* 2.0.5: can't use gdTrueColorGetRed, etc with palette */\n\t\t\t\t\t\t\t\tnc = gdImageColorResolveAlpha (dst,\n\t\t\t\t\t\t\t\t                               gdImageRed (src,\n\t\t\t\t\t\t\t\t                                       c),\n\t\t\t\t\t\t\t\t                               gdImageGreen\n\t\t\t\t\t\t\t\t                               (src, c),\n\t\t\t\t\t\t\t\t                               gdImageBlue (src,\n\t\t\t\t\t\t\t\t                                       c),\n\t\t\t\t\t\t\t\t                               gdImageAlpha\n\t\t\t\t\t\t\t\t                               (src, c));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcolorMap[c] = nc;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapTo = colorMap[c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i = 0; (i < stx[x - srcX]); i++) {\n\t\t\t\t\tgdImageSetPixel (dst, tox, toy, mapTo);\n\t\t\t\t\ttox++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoy++;\n\t\t}\n\t}\n\tgdFree (stx);\n\tgdFree (sty);\n}\n\n/* gd 2.0.8: gdImageCopyRotated is added. Source\n\tis a rectangle, with its upper left corner at\n\tsrcX and srcY. Destination is the *center* of\n\t\tthe rotated copy. Angle is in degrees, same as\n\t\tgdImageArc. Floating point destination center\n\tcoordinates allow accurate rotation of\n\tobjects of odd-numbered width or height. */\n\nBGD_DECLARE(void) gdImageCopyRotated (gdImagePtr dst,\n\t\t\t\t\t\t\t\t\t  gdImagePtr src,\n\t\t\t\t\t\t\t\t\t  double dstX, double dstY,\n\t\t\t\t\t\t\t\t\t  int srcX, int srcY,\n\t\t\t\t\t\t\t\t\t  int srcWidth, int srcHeight, int angle)\n{\n\tdouble dx, dy;\n\tdouble radius = sqrt (srcWidth * srcWidth + srcHeight * srcHeight);\n\tdouble aCos = cos (angle * .0174532925);\n\tdouble aSin = sin (angle * .0174532925);\n\tdouble scX = srcX + ((double) srcWidth) / 2;\n\tdouble scY = srcY + ((double) srcHeight) / 2;\n\tint cmap[gdMaxColors];\n\tint i;\n\n\t/*\n\t\t 2.0.34: transparency preservation. The transparentness of\n\t\t the transparent color is more important than its hue.\n\t*/\n\tif (src->transparent != -1) {\n\t\tif (dst->transparent == -1) {\n\t\t\tdst->transparent = src->transparent;\n\t\t}\n\t}\n\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tcmap[i] = (-1);\n\t}\n\tfor (dy = dstY - radius; (dy <= dstY + radius); dy++) {\n\t\tfor (dx = dstX - radius; (dx <= dstX + radius); dx++) {\n\t\t\tdouble sxd = (dx - dstX) * aCos - (dy - dstY) * aSin;\n\t\t\tdouble syd = (dy - dstY) * aCos + (dx - dstX) * aSin;\n\t\t\tint sx = sxd + scX;\n\t\t\tint sy = syd + scY;\n\t\t\tif ((sx >= srcX) && (sx < srcX + srcWidth) &&\n\t\t\t        (sy >= srcY) && (sy < srcY + srcHeight)) {\n\t\t\t\tint c = gdImageGetPixel (src, sx, sy);\n\t\t\t\t/* 2.0.34: transparency wins */\n\t\t\t\tif (c == src->transparent) {\n\t\t\t\t\tgdImageSetPixel (dst, dx, dy, dst->transparent);\n\t\t\t\t} else if (!src->trueColor) {\n\t\t\t\t\t/* Use a table to avoid an expensive\n\t\t\t\t\t   lookup on every single pixel */\n\t\t\t\t\tif (cmap[c] == -1) {\n\t\t\t\t\t\tcmap[c] = gdImageColorResolveAlpha (dst,\n\t\t\t\t\t\t                                    gdImageRed (src, c),\n\t\t\t\t\t\t                                    gdImageGreen (src,\n\t\t\t\t\t\t                                            c),\n\t\t\t\t\t\t                                    gdImageBlue (src,\n\t\t\t\t\t\t                                            c),\n\t\t\t\t\t\t                                    gdImageAlpha (src,\n\t\t\t\t\t\t                                            c));\n\t\t\t\t\t}\n\t\t\t\t\tgdImageSetPixel (dst, dx, dy, cmap[c]);\n\t\t\t\t} else {\n\t\t\t\t\tgdImageSetPixel (dst,\n\t\t\t\t\t                 dx, dy,\n\t\t\t\t\t                 gdImageColorResolveAlpha (dst,\n\t\t\t\t\t                         gdImageRed (src,\n\t\t\t\t\t                                     c),\n\t\t\t\t\t                         gdImageGreen\n\t\t\t\t\t                         (src, c),\n\t\t\t\t\t                         gdImageBlue (src,\n\t\t\t\t\t                                      c),\n\t\t\t\t\t                         gdImageAlpha\n\t\t\t\t\t                         (src, c)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* When gd 1.x was first created, floating point was to be avoided.\n   These days it is often faster than table lookups or integer\n   arithmetic. The routine below is shamelessly, gloriously\n   floating point. TBB */\n\n/* 2.0.10: cast instead of floor() yields 35% performance improvement.\n\tThanks to John Buckman. */\n\n#define floor2(exp) ((long) exp)\n/*#define floor2(exp) floor(exp)*/\n\nBGD_DECLARE(void) gdImageCopyResampled (gdImagePtr dst,\n\t\t\t\t\t\t\t\t\t\tgdImagePtr src,\n\t\t\t\t\t\t\t\t\t\tint dstX, int dstY,\n\t\t\t\t\t\t\t\t\t\tint srcX, int srcY,\n\t\t\t\t\t\t\t\t\t\tint dstW, int dstH, int srcW, int srcH)\n{\n\tint x, y;\n\tdouble sy1, sy2, sx1, sx2;\n\tif (!dst->trueColor) {\n\t\tgdImageCopyResized (dst, src, dstX, dstY, srcX, srcY, dstW, dstH,\n\t\t                    srcW, srcH);\n\t\treturn;\n\t}\n\tfor (y = dstY; (y < dstY + dstH); y++) {\n\t\tsy1 = ((double) y - (double) dstY) * (double) srcH / (double) dstH;\n\t\tsy2 = ((double) (y + 1) - (double) dstY) * (double) srcH /\n\t\t      (double) dstH;\n\t\tfor (x = dstX; (x < dstX + dstW); x++) {\n\t\t\tdouble sx, sy;\n\t\t\tdouble spixels = 0;\n\t\t\tdouble red = 0.0, green = 0.0, blue = 0.0, alpha = 0.0;\n\t\t\tdouble alpha_sum = 0.0, contrib_sum = 0.0;\n\n\t\t\tsx1 = ((double) x - (double) dstX) * (double) srcW / dstW;\n\t\t\tsx2 = ((double) (x + 1) - (double) dstX) * (double) srcW / dstW;\n\t\t\tsy = sy1;\n\t\t\tdo {\n\t\t\t\tdouble yportion;\n\t\t\t\tif (floor2 (sy) == floor2 (sy1)) {\n\t\t\t\t\typortion = 1.0 - (sy - floor2 (sy));\n\t\t\t\t\tif (yportion > sy2 - sy1) {\n\t\t\t\t\t\typortion = sy2 - sy1;\n\t\t\t\t\t}\n\t\t\t\t\tsy = floor2 (sy);\n\t\t\t\t} else if (sy == floor2 (sy2)) {\n\t\t\t\t\typortion = sy2 - floor2 (sy2);\n\t\t\t\t} else {\n\t\t\t\t\typortion = 1.0;\n\t\t\t\t}\n\t\t\t\tsx = sx1;\n\t\t\t\tdo {\n\t\t\t\t\tdouble xportion;\n\t\t\t\t\tdouble pcontribution;\n\t\t\t\t\tint p;\n\t\t\t\t\tif (floor2 (sx) == floor2 (sx1)) {\n\t\t\t\t\t\txportion = 1.0 - (sx - floor2 (sx));\n\t\t\t\t\t\tif (xportion > sx2 - sx1) {\n\t\t\t\t\t\t\txportion = sx2 - sx1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsx = floor2 (sx);\n\t\t\t\t\t} else if (sx == floor2 (sx2)) {\n\t\t\t\t\t\txportion = sx2 - floor2 (sx2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\txportion = 1.0;\n\t\t\t\t\t}\n\t\t\t\t\tpcontribution = xportion * yportion;\n\t\t\t\t\t/* 2.08: previously srcX and srcY were ignored.\n\t\t\t\t\t   Andrew Pattison */\n\t\t\t\t\tp = gdImageGetTrueColorPixel (src,\n\t\t\t\t\t                              (int) sx + srcX,\n\t\t\t\t\t                              (int) sy + srcY);\n\t\t\t\t\tred += gdTrueColorGetRed (p) * pcontribution;\n\t\t\t\t\tgreen += gdTrueColorGetGreen (p) * pcontribution;\n\t\t\t\t\tblue += gdTrueColorGetBlue (p) * pcontribution;\n\t\t\t\t\talpha += gdTrueColorGetAlpha (p) * pcontribution;\n\t\t\t\t\tspixels += xportion * yportion;\n\t\t\t\t\tsx += 1.0;\n\t\t\t\t} while (sx < sx2);\n\t\t\t\tsy += 1.0;\n\t\t\t} while (sy < sy2);\n\t\t\tif (spixels != 0.0) {\n\t\t\t\tred /= spixels;\n\t\t\t\tgreen /= spixels;\n\t\t\t\tblue /= spixels;\n\t\t\t\talpha /= spixels;\n\t\t\t\talpha += 0.5;\n\t\t\t}\n\t\t\tif ( alpha_sum != 0.0f) {\n\t\t\t\tif( contrib_sum != 0.0f) {\n\t\t\t\t\talpha_sum /= contrib_sum;\n\t\t\t\t}\n\t\t\t\tred /= alpha_sum;\n\t\t\t\tgreen /= alpha_sum;\n\t\t\t\tblue /= alpha_sum;\n\t\t\t}\n\t\t\t/* Clamping to allow for rounding errors above */\n\t\t\tif (red > 255.0) {\n\t\t\t\tred = 255.0;\n\t\t\t}\n\t\t\tif (green > 255.0) {\n\t\t\t\tgreen = 255.0;\n\t\t\t}\n\t\t\tif (blue > 255.0) {\n\t\t\t\tblue = 255.0;\n\t\t\t}\n\t\t\tif (alpha > gdAlphaMax) {\n\t\t\t\talpha = gdAlphaMax;\n\t\t\t}\n\t\t\tgdImageSetPixel (dst,\n\t\t\t                 x, y,\n\t\t\t                 gdTrueColorAlpha ((int) red,\n\t\t\t                                   (int) green,\n\t\t\t                                   (int) blue, (int) alpha));\n\t\t}\n\t}\n}\n\nBGD_DECLARE(void) gdImagePolygon (gdImagePtr im, gdPointPtr p, int n, int c)\n{\n\tif (n <= 0) {\n\t\treturn;\n\t}\n\n\n\tgdImageLine (im, p->x, p->y, p[n - 1].x, p[n - 1].y, c);\n\tgdImageOpenPolygon (im, p, n, c);\n}\n\nBGD_DECLARE(void) gdImageOpenPolygon (gdImagePtr im, gdPointPtr p, int n, int c)\n{\n\tint i;\n\tint lx, ly;\n\tif (n <= 0) {\n\t\treturn;\n\t}\n\n\n\tlx = p->x;\n\tly = p->y;\n\tfor (i = 1; (i < n); i++) {\n\t\tp++;\n\t\tgdImageLine (im, lx, ly, p->x, p->y, c);\n\t\tlx = p->x;\n\t\tly = p->y;\n\t}\n\n}\n\n/* THANKS to Kirsten Schulz for the polygon fixes! */\n\n/* The intersection finding technique of this code could be improved  */\n/* by remembering the previous intertersection, and by using the slope. */\n/* That could help to adjust intersections  to produce a nice */\n/* interior_extrema. */\n\nBGD_DECLARE(void) gdImageFilledPolygon (gdImagePtr im, gdPointPtr p, int n, int c)\n{\n\tint i;\n\tint j;\n\tint index;\n\tint y;\n\tint miny, maxy, pmaxy;\n\tint x1, y1;\n\tint x2, y2;\n\tint ind1, ind2;\n\tint ints;\n\tint fill_color;\n\tif (n <= 0) {\n\t\treturn;\n\t}\n\n\tif (c == gdAntiAliased) {\n\t\tfill_color = im->AA_color;\n\t} else {\n\t\tfill_color = c;\n\t}\n\tif (!im->polyAllocated) {\n\t\tif (overflow2(sizeof (int), n)) {\n\t\t\treturn;\n\t\t}\n\t\tim->polyInts = (int *) gdMalloc (sizeof (int) * n);\n\t\tif (!im->polyInts) {\n\t\t\treturn;\n\t\t}\n\t\tim->polyAllocated = n;\n\t}\n\tif (im->polyAllocated < n) {\n\t\twhile (im->polyAllocated < n) {\n\t\t\tim->polyAllocated *= 2;\n\t\t}\n\t\tif (overflow2(sizeof (int), im->polyAllocated)) {\n\t\t\treturn;\n\t\t}\n\t\tim->polyInts = (int *) gdReallocEx (im->polyInts,\n\t\t\t\t\t\t    sizeof (int) * im->polyAllocated);\n\t\tif (!im->polyInts) {\n\t\t\treturn;\n\t\t}\n\t}\n\tminy = p[0].y;\n\tmaxy = p[0].y;\n\tfor (i = 1; (i < n); i++) {\n\t\tif (p[i].y < miny) {\n\t\t\tminy = p[i].y;\n\t\t}\n\t\tif (p[i].y > maxy) {\n\t\t\tmaxy = p[i].y;\n\t\t}\n\t}\n\tpmaxy = maxy;\n\t/* 2.0.16: Optimization by Ilia Chipitsine -- don't waste time offscreen */\n\t/* 2.0.26: clipping rectangle is even better */\n\tif (miny < im->cy1) {\n\t\tminy = im->cy1;\n\t}\n\tif (maxy > im->cy2) {\n\t\tmaxy = im->cy2;\n\t}\n\t/* Fix in 1.3: count a vertex only once */\n\tfor (y = miny; (y <= maxy); y++) {\n\t\tints = 0;\n\t\tfor (i = 0; (i < n); i++) {\n\t\t\tif (!i) {\n\t\t\t\tind1 = n - 1;\n\t\t\t\tind2 = 0;\n\t\t\t} else {\n\t\t\t\tind1 = i - 1;\n\t\t\t\tind2 = i;\n\t\t\t}\n\t\t\ty1 = p[ind1].y;\n\t\t\ty2 = p[ind2].y;\n\t\t\tif (y1 < y2) {\n\t\t\t\tx1 = p[ind1].x;\n\t\t\t\tx2 = p[ind2].x;\n\t\t\t} else if (y1 > y2) {\n\t\t\t\ty2 = p[ind1].y;\n\t\t\t\ty1 = p[ind2].y;\n\t\t\t\tx2 = p[ind1].x;\n\t\t\t\tx1 = p[ind2].x;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Do the following math as float intermediately, and round to ensure\n\t\t\t * that Polygon and FilledPolygon for the same set of points have the\n\t\t\t * same footprint. */\n\n\t\t\tif ((y >= y1) && (y < y2)) {\n\t\t\t\tim->polyInts[ints++] = (int) ((float) ((y - y1) * (x2 - x1)) /\n\t\t\t\t                              (float) (y2 - y1) + 0.5 + x1);\n\t\t\t} else if ((y == pmaxy) && (y == y2)) {\n\t\t\t\tim->polyInts[ints++] = x2;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t  2.0.26: polygons pretty much always have less than 100 points,\n\t\t  and most of the time they have considerably less. For such trivial\n\t\t  cases, insertion sort is a good choice. Also a good choice for\n\t\t  future implementations that may wish to indirect through a table.\n\t\t*/\n\t\tfor (i = 1; (i < ints); i++) {\n\t\t\tindex = im->polyInts[i];\n\t\t\tj = i;\n\t\t\twhile ((j > 0) && (im->polyInts[j - 1] > index)) {\n\t\t\t\tim->polyInts[j] = im->polyInts[j - 1];\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tim->polyInts[j] = index;\n\t\t}\n\t\tfor (i = 0; (i < (ints-1)); i += 2) {\n\t\t\t/* 2.0.29: back to gdImageLine to prevent segfaults when\n\t\t\t  performing a pattern fill */\n\t\t\tgdImageLine (im, im->polyInts[i], y, im->polyInts[i + 1], y,\n\t\t\t             fill_color);\n\t\t}\n\t}\n\t/* If we are drawing this AA, then redraw the border with AA lines. */\n\t/* This doesn't work as well as I'd like, but it doesn't clash either. */\n\tif (c == gdAntiAliased) {\n\t\tgdImagePolygon (im, p, n, c);\n\t}\n}\n\nstatic void gdImageSetAAPixelColor(gdImagePtr im, int x, int y, int color, int t);\n\nBGD_DECLARE(void) gdImageSetStyle (gdImagePtr im, int *style, int noOfPixels)\n{\n\tif (im->style) {\n\t\tgdFree (im->style);\n\t}\n\tif (overflow2(sizeof (int), noOfPixels)) {\n\t\treturn;\n\t}\n\tim->style = (int *) gdMalloc (sizeof (int) * noOfPixels);\n\tif (!im->style) {\n\t\treturn;\n\t}\n\tmemcpy (im->style, style, sizeof (int) * noOfPixels);\n\tim->styleLength = noOfPixels;\n\tim->stylePos = 0;\n}\n\nBGD_DECLARE(void) gdImageSetThickness (gdImagePtr im, int thickness)\n{\n\tim->thick = thickness;\n}\n\nBGD_DECLARE(void) gdImageSetBrush (gdImagePtr im, gdImagePtr brush)\n{\n\tint i;\n\tim->brush = brush;\n\tif ((!im->trueColor) && (!im->brush->trueColor)) {\n\t\tfor (i = 0; (i < gdImageColorsTotal (brush)); i++) {\n\t\t\tint index;\n\t\t\tindex = gdImageColorResolveAlpha (im,\n\t\t\t                                  gdImageRed (brush, i),\n\t\t\t                                  gdImageGreen (brush, i),\n\t\t\t                                  gdImageBlue (brush, i),\n\t\t\t                                  gdImageAlpha (brush, i));\n\t\t\tim->brushColorMap[i] = index;\n\t\t}\n\t}\n}\n\nBGD_DECLARE(void) gdImageSetTile (gdImagePtr im, gdImagePtr tile)\n{\n\tint i;\n\tim->tile = tile;\n\tif ((!im->trueColor) && (!im->tile->trueColor)) {\n\t\tfor (i = 0; (i < gdImageColorsTotal (tile)); i++) {\n\t\t\tint index;\n\t\t\tindex = gdImageColorResolveAlpha (im,\n\t\t\t                                  gdImageRed (tile, i),\n\t\t\t                                  gdImageGreen (tile, i),\n\t\t\t                                  gdImageBlue (tile, i),\n\t\t\t                                  gdImageAlpha (tile, i));\n\t\t\tim->tileColorMap[i] = index;\n\t\t}\n\t}\n}\n\nBGD_DECLARE(void) gdImageSetAntiAliased (gdImagePtr im, int c)\n{\n\tim->AA = 1;\n\tim->AA_color = c;\n\tim->AA_dont_blend = -1;\n}\n\nBGD_DECLARE(void) gdImageSetAntiAliasedDontBlend (gdImagePtr im, int c, int dont_blend)\n{\n\tim->AA = 1;\n\tim->AA_color = c;\n\tim->AA_dont_blend = dont_blend;\n}\n\nBGD_DECLARE(void) gdImageInterlace (gdImagePtr im, int interlaceArg)\n{\n\tim->interlace = interlaceArg;\n}\n\nBGD_DECLARE(int) gdImageCompare (gdImagePtr im1, gdImagePtr im2)\n{\n\tint x, y;\n\tint p1, p2;\n\tint cmpStatus = 0;\n\tint sx, sy;\n\n\tif (im1->interlace != im2->interlace) {\n\t\tcmpStatus |= GD_CMP_INTERLACE;\n\t}\n\n\tif (im1->transparent != im2->transparent) {\n\t\tcmpStatus |= GD_CMP_TRANSPARENT;\n\t}\n\n\tif (im1->trueColor != im2->trueColor) {\n\t\tcmpStatus |= GD_CMP_TRUECOLOR;\n\t}\n\n\tsx = im1->sx;\n\tif (im1->sx != im2->sx) {\n\t\tcmpStatus |= GD_CMP_SIZE_X + GD_CMP_IMAGE;\n\t\tif (im2->sx < im1->sx) {\n\t\t\tsx = im2->sx;\n\t\t}\n\t}\n\n\tsy = im1->sy;\n\tif (im1->sy != im2->sy) {\n\t\tcmpStatus |= GD_CMP_SIZE_Y + GD_CMP_IMAGE;\n\t\tif (im2->sy < im1->sy) {\n\t\t\tsy = im2->sy;\n\t\t}\n\t}\n\n\tif (im1->colorsTotal != im2->colorsTotal) {\n\t\tcmpStatus |= GD_CMP_NUM_COLORS;\n\t}\n\n\tfor (y = 0; (y < sy); y++) {\n\t\tfor (x = 0; (x < sx); x++) {\n\t\t\tp1 =\n\t\t\t    im1->trueColor ? gdImageTrueColorPixel (im1, x,\n\t\t\t            y) :\n\t\t\t    gdImagePalettePixel (im1, x, y);\n\t\t\tp2 =\n\t\t\t    im2->trueColor ? gdImageTrueColorPixel (im2, x,\n\t\t\t            y) :\n\t\t\t    gdImagePalettePixel (im2, x, y);\n\t\t\tif (gdImageRed (im1, p1) != gdImageRed (im2, p2)) {\n\t\t\t\tcmpStatus |= GD_CMP_COLOR + GD_CMP_IMAGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (gdImageGreen (im1, p1) != gdImageGreen (im2, p2)) {\n\t\t\t\tcmpStatus |= GD_CMP_COLOR + GD_CMP_IMAGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (gdImageBlue (im1, p1) != gdImageBlue (im2, p2)) {\n\t\t\t\tcmpStatus |= GD_CMP_COLOR + GD_CMP_IMAGE;\n\t\t\t\tbreak;\n\t\t\t}\n#if 0\n\t\t\t/* Soon we'll add alpha channel to palettes */\n\t\t\tif (gdImageAlpha (im1, p1) != gdImageAlpha (im2, p2)) {\n\t\t\t\tcmpStatus |= GD_CMP_COLOR + GD_CMP_IMAGE;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t}\n\t\tif (cmpStatus & GD_CMP_COLOR) {\n\t\t\tbreak;\n\t\t};\n\t}\n\n\treturn cmpStatus;\n}\n\n\n/* Thanks to Frank Warmerdam for this superior implementation\n\tof gdAlphaBlend(), which merges alpha in the\n\tdestination color much better. */\n\nBGD_DECLARE(int) gdAlphaBlend (int dst, int src)\n{\n\tint src_alpha = gdTrueColorGetAlpha(src);\n\tint dst_alpha, alpha, red, green, blue;\n\tint src_weight, dst_weight, tot_weight;\n\n\t/* -------------------------------------------------------------------- */\n\t/*      Simple cases we want to handle fast.                            */\n\t/* -------------------------------------------------------------------- */\n\tif( src_alpha == gdAlphaOpaque )\n\t\treturn src;\n\n\tdst_alpha = gdTrueColorGetAlpha(dst);\n\tif( src_alpha == gdAlphaTransparent )\n\t\treturn dst;\n\tif( dst_alpha == gdAlphaTransparent )\n\t\treturn src;\n\n\t/* -------------------------------------------------------------------- */\n\t/*      What will the source and destination alphas be?  Note that      */\n\t/*      the destination weighting is substantially reduced as the       */\n\t/*      overlay becomes quite opaque.                                   */\n\t/* -------------------------------------------------------------------- */\n\tsrc_weight = gdAlphaTransparent - src_alpha;\n\tdst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n\ttot_weight = src_weight + dst_weight;\n\n\t/* -------------------------------------------------------------------- */\n\t/*      What red, green and blue result values will we use?             */\n\t/* -------------------------------------------------------------------- */\n\talpha = src_alpha * dst_alpha / gdAlphaMax;\n\n\tred = (gdTrueColorGetRed(src) * src_weight\n\t       + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n\tgreen = (gdTrueColorGetGreen(src) * src_weight\n\t         + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n\tblue = (gdTrueColorGetBlue(src) * src_weight\n\t        + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n\n\t/* -------------------------------------------------------------------- */\n\t/*      Return merged result.                                           */\n\t/* -------------------------------------------------------------------- */\n\treturn ((alpha << 24) + (red << 16) + (green << 8) + blue);\n}\n\nstatic int gdAlphaOverlayColor (int src, int dst, int max );\nBGD_DECLARE(int) gdLayerOverlay (int dst, int src)\n{\n\tint a1, a2;\n\ta1 = gdAlphaMax - gdTrueColorGetAlpha(dst);\n\ta2 = gdAlphaMax - gdTrueColorGetAlpha(src);\n\treturn ( ((gdAlphaMax - a1*a2/gdAlphaMax) << 24) +\n\t\t(gdAlphaOverlayColor( gdTrueColorGetRed(src), gdTrueColorGetRed(dst), gdRedMax ) << 16) +\n\t\t(gdAlphaOverlayColor( gdTrueColorGetGreen(src), gdTrueColorGetGreen(dst), gdGreenMax ) << 8) +\n\t\t(gdAlphaOverlayColor( gdTrueColorGetBlue(src), gdTrueColorGetBlue(dst), gdBlueMax ))\n\t\t);\n}\n\n/* Apply 'overlay' effect - background pixels are colourised by the foreground colour */\nstatic int gdAlphaOverlayColor (int src, int dst, int max )\n{\n\tdst = dst << 1;\n\tif( dst > max ) {\n\t\t/* in the \"light\" zone */\n\t\treturn dst + (src << 1) - (dst * src / max) - max;\n\t} else {\n\t\t/* in the \"dark\" zone */\n\t\treturn dst * src / max;\n\t}\n}\n\n/* Apply 'multiply' effect */\nBGD_DECLARE(int) gdLayerMultiply (int dst, int src)\n{\n\tint a1, a2, r1, r2, g1, g2, b1, b2;\n\ta1 = gdAlphaMax - gdTrueColorGetAlpha(src);\n\ta2 = gdAlphaMax - gdTrueColorGetAlpha(dst);\n\n\tr1 = gdRedMax - (a1 * (gdRedMax - gdTrueColorGetRed(src))) / gdAlphaMax;\n\tr2 = gdRedMax - (a2 * (gdRedMax - gdTrueColorGetRed(dst))) / gdAlphaMax;\n\tg1 = gdGreenMax - (a1 * (gdGreenMax - gdTrueColorGetGreen(src))) / gdAlphaMax;\n\tg2 = gdGreenMax - (a2 * (gdGreenMax - gdTrueColorGetGreen(dst))) / gdAlphaMax;\n\tb1 = gdBlueMax - (a1 * (gdBlueMax - gdTrueColorGetBlue(src))) / gdAlphaMax;\n\tb2 = gdBlueMax - (a2 * (gdBlueMax - gdTrueColorGetBlue(dst))) / gdAlphaMax ;\n\n\ta1 = gdAlphaMax - a1;\n\ta2 = gdAlphaMax - a2;\n\treturn ( ((a1*a2/gdAlphaMax) << 24) +\n\t\t\t ((r1*r2/gdRedMax) << 16) +\n\t\t\t ((g1*g2/gdGreenMax) << 8) +\n\t\t\t ((b1*b2/gdBlueMax))\n\t\t);\n}\n\nBGD_DECLARE(void) gdImageAlphaBlending (gdImagePtr im, int alphaBlendingArg)\n{\n\tim->alphaBlendingFlag = alphaBlendingArg;\n}\n\nBGD_DECLARE(void) gdImageSaveAlpha (gdImagePtr im, int saveAlphaArg)\n{\n\tim->saveAlphaFlag = saveAlphaArg;\n}\n\nBGD_DECLARE(void) gdImageSetClip (gdImagePtr im, int x1, int y1, int x2, int y2)\n{\n\tif (x1 < 0) {\n\t\tx1 = 0;\n\t}\n\tif (x1 >= im->sx) {\n\t\tx1 = im->sx - 1;\n\t}\n\tif (x2 < 0) {\n\t\tx2 = 0;\n\t}\n\tif (x2 >= im->sx) {\n\t\tx2 = im->sx - 1;\n\t}\n\tif (y1 < 0) {\n\t\ty1 = 0;\n\t}\n\tif (y1 >= im->sy) {\n\t\ty1 = im->sy - 1;\n\t}\n\tif (y2 < 0) {\n\t\ty2 = 0;\n\t}\n\tif (y2 >= im->sy) {\n\t\ty2 = im->sy - 1;\n\t}\n\tim->cx1 = x1;\n\tim->cy1 = y1;\n\tim->cx2 = x2;\n\tim->cy2 = y2;\n}\n\nBGD_DECLARE(void) gdImageGetClip (gdImagePtr im, int *x1P, int *y1P, int *x2P, int *y2P)\n{\n\t*x1P = im->cx1;\n\t*y1P = im->cy1;\n\t*x2P = im->cx2;\n\t*y2P = im->cy2;\n}\n\nBGD_DECLARE(void) gdImageSetResolution(gdImagePtr im, const unsigned int res_x, const unsigned int res_y)\n{\n\tif (res_x > 0) im->res_x = res_x;\n\tif (res_y > 0) im->res_y = res_y;\n}\n\n/*\n * Added on 2003/12 by Pierre-Alain Joye (pajoye@pearfr.org)\n * */\n#define BLEND_COLOR(a, nc, c, cc) \\\nnc = (cc) + (((((c) - (cc)) * (a)) + ((((c) - (cc)) * (a)) >> 8) + 0x80) >> 8);\n\nstatic void gdImageSetAAPixelColor(gdImagePtr im, int x, int y, int color, int t)\n{\n\tint dr,dg,db,p,r,g,b;\n\n\t/* 2.0.34: watch out for out of range calls */\n\tif (!gdImageBoundsSafeMacro(im, x, y)) {\n\t\treturn;\n\t}\n\tp = gdImageGetPixel(im,x,y);\n\t/* TBB: we have to implement the dont_blend stuff to provide\n\t  the full feature set of the old implementation */\n\tif ((p == color)\n\t        || ((p == im->AA_dont_blend)\n\t            && (t != 0x00))) {\n\t\treturn;\n\t}\n\tdr = gdTrueColorGetRed(color);\n\tdg = gdTrueColorGetGreen(color);\n\tdb = gdTrueColorGetBlue(color);\n\n\tr = gdTrueColorGetRed(p);\n\tg = gdTrueColorGetGreen(p);\n\tb = gdTrueColorGetBlue(p);\n\n\tBLEND_COLOR(t, dr, r, dr);\n\tBLEND_COLOR(t, dg, g, dg);\n\tBLEND_COLOR(t, db, b, db);\n\tim->tpixels[y][x] = gdTrueColorAlpha(dr, dg, db, gdAlphaOpaque);\n}\n\nstatic void gdImageAALine (gdImagePtr im, int x1, int y1, int x2, int y2, int col)\n{\n\t/* keep them as 32bits */\n\tlong x, y, inc, frac;\n\tlong dx, dy,tmp;\n\tint w, wid, wstart; \n\tint thick = im->thick; \n\n\tif (!im->trueColor) {\n\t\t/* TBB: don't crash when the image is of the wrong type */\n\t\tgdImageLine(im, x1, y1, x2, y2, col);\n\t\treturn;\n\t}\n\n\t/* TBB: use the clipping rectangle */\n\tif (clip_1d (&x1, &y1, &x2, &y2, im->cx1, im->cx2) == 0)\n\t\treturn;\n\tif (clip_1d (&y1, &x1, &y2, &x2, im->cy1, im->cy2) == 0)\n\t\treturn;\n\n\tdx = x2 - x1;\n\tdy = y2 - y1;\n\n\tif (dx == 0 && dy == 0) {\n\t\t/* TBB: allow setting points */\n\t\tgdImageSetAAPixelColor(im, x1, y1, col, 0xFF);\n\t\treturn;\n\t} else {\n\t\tdouble ag;\n\t\t/* Cast the long to an int to avoid compiler warnings about truncation.\n\t\t * This isn't a problem as computed dy/dx values came from ints above. */\n\t\tag = fabs(abs((int)dy) < abs((int)dx) ? cos(atan2(dy, dx)) : sin(atan2(dy, dx)));\n\t\tif (ag != 0) {\n\t\t\twid = thick / ag;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tif (wid == 0) {\n\t\t\twid = 1;\n\t\t}\n\t}\n\n\t/* Axis aligned lines */\n\tif (dx == 0) {\n\t\tgdImageVLine(im, x1, y1, y2, col);\n\t\treturn;\n\t} else if (dy == 0) {\n\t\tgdImageHLine(im, y1, x1, x2, col);\n\t\treturn;\n\t}\n\n\tif (abs((int)dx) > abs((int)dy)) {\n\t\tif (dx < 0) {\n\t\t\ttmp = x1;\n\t\t\tx1 = x2;\n\t\t\tx2 = tmp;\n\t\t\ttmp = y1;\n\t\t\ty1 = y2;\n\t\t\ty2 = tmp;\n\t\t\tdx = x2 - x1;\n\t\t\tdy = y2 - y1;\n\t\t}\n\t\ty = y1;\n\t\tinc = (dy * 65536) / dx;\n\t\tfrac = 0;\n\t\t/* TBB: set the last pixel for consistency (<=) */\n\t\tfor (x = x1 ; x <= x2 ; x++) {\n\t\t\twstart = y - wid / 2;\n\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t    gdImageSetAAPixelColor(im, x , w , col , (frac >> 8) & 0xFF);\n\t\t\t    gdImageSetAAPixelColor(im, x , w + 1 , col, (~frac >> 8) & 0xFF);\n\t\t\t}\n\t\t\tfrac += inc;\n\t\t\tif (frac >= 65536) {\n\t\t\t\tfrac -= 65536;\n\t\t\t\ty++;\n\t\t\t} else if (frac < 0) {\n\t\t\t\tfrac += 65536;\n\t\t\t\ty--;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (dy < 0) {\n\t\t\ttmp = x1;\n\t\t\tx1 = x2;\n\t\t\tx2 = tmp;\n\t\t\ttmp = y1;\n\t\t\ty1 = y2;\n\t\t\ty2 = tmp;\n\t\t\tdx = x2 - x1;\n\t\t\tdy = y2 - y1;\n\t\t}\n\t\tx = x1;\n\t\tinc = (dx * 65536) / dy;\n\t\tfrac = 0;\n\t\t/* TBB: set the last pixel for consistency (<=) */\n\t\tfor (y = y1 ; y <= y2 ; y++) {\n\t\t\twstart = x - wid / 2;\n\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t    gdImageSetAAPixelColor(im, w , y  , col, (frac >> 8) & 0xFF);\n\t\t\t    gdImageSetAAPixelColor(im, w + 1, y, col, (~frac >> 8) & 0xFF);\n\t\t\t}\n\t\t\tfrac += inc;\n\t\t\tif (frac >= 65536) {\n\t\t\t\tfrac -= 65536;\n\t\t\t\tx++;\n\t\t\t} else if (frac < 0) {\n\t\t\t\tfrac += 65536;\n\t\t\t\tx--;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/* convert a palette image to true color */\nBGD_DECLARE(int) gdImagePaletteToTrueColor(gdImagePtr src)\n{\n\tunsigned int y;\n\tunsigned int yy;\n\n\tif (src == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (src->trueColor == 1) {\n\t\treturn 1;\n\t} else {\n\t\tunsigned int x;\n\t\tconst unsigned int sy = gdImageSY(src);\n\t\tconst unsigned int sx = gdImageSX(src);\n\n\t\tsrc->tpixels = (int **) gdMalloc(sizeof(int *) * sy);\n\t\tif (src->tpixels == NULL) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (y = 0; y < sy; y++) {\n\t\t\tconst unsigned char *src_row = src->pixels[y];\n\t\t\tint * dst_row;\n\n\t\t\t/* no need to calloc it, we overwrite all pxl anyway */\n\t\t\tsrc->tpixels[y] = (int *) gdMalloc(sx * sizeof(int));\n\t\t\tif (src->tpixels[y] == NULL) {\n\t\t\t\tgoto clean_on_error;\n\t\t\t}\n\n\t\t\tdst_row = src->tpixels[y];\n\t\t\tfor (x = 0; x < sx; x++) {\n\t\t\t\tconst unsigned char c = *(src_row + x);\n\t\t\t\tif (c == src->transparent) {\n\t\t\t\t\t*(dst_row + x) = gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t\t} else {\n\t\t\t\t\t*(dst_row + x) = gdTrueColorAlpha(src->red[c], src->green[c], src->blue[c], src->alpha[c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* free old palette buffer (y is sy) */\n\tfor (yy = 0; yy < y; yy++) {\n\t\tgdFree(src->pixels[yy]);\n\t}\n\tgdFree(src->pixels);\n\tsrc->trueColor = 1;\n\tsrc->pixels = NULL;\n\tsrc->alphaBlendingFlag = 0;\n\tsrc->saveAlphaFlag = 1;\n\treturn 1;\n\nclean_on_error:\n\t/* free new true color buffer (y is not allocated, have failed) */\n\tfor (yy = 0; yy < y; yy++) {\n\t\tgdFree(src->tpixels[yy]);\n\t}\n\tgdFree(src->tpixels);\n\treturn 0;\n}\n", "/bug00037\n", "SET(TESTS_FILES\n\tbug00037\n)\n\nADD_GD_TESTS()\n", "if HAVE_LIBPNG\nlibgd_test_programs += \\\n\tgdimagefilltoborder/bug00037\nendif\n\nEXTRA_DIST += \\\n\tgdimagefilltoborder/CMakeLists.txt\n"], "fixing_code": ["/* $Id$ */\n\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"gd_intern.h\"\n\n/* 2.03: don't include zlib here or we can't build without PNG */\n#include \"gd.h\"\n#include \"gdhelpers.h\"\n#include \"gd_color.h\"\n#include \"gd_errors.h\"\n\n/* 2.0.12: this now checks the clipping rectangle */\n#define gdImageBoundsSafeMacro(im, x, y) (!((((y) < (im)->cy1) || ((y) > (im)->cy2)) || (((x) < (im)->cx1) || ((x) > (im)->cx2))))\n\n#ifdef _OSD_POSIX\t\t/* BS2000 uses the EBCDIC char set instead of ASCII */\n#define CHARSET_EBCDIC\n#define __attribute__(any)\t/*nothing */\n#endif\n/*_OSD_POSIX*/\n\n#ifndef CHARSET_EBCDIC\n#define ASC(ch)  ch\n#else /*CHARSET_EBCDIC */\n#define ASC(ch) gd_toascii[(unsigned char)ch]\nstatic const unsigned char gd_toascii[256] = {\n\t/*00 */ 0x00, 0x01, 0x02, 0x03, 0x85, 0x09, 0x86, 0x7f,\n\t0x87, 0x8d, 0x8e, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\t/*................ */\n\t/*10 */ 0x10, 0x11, 0x12, 0x13, 0x8f, 0x0a, 0x08, 0x97,\n\t0x18, 0x19, 0x9c, 0x9d, 0x1c, 0x1d, 0x1e, 0x1f,\t/*................ */\n\t/*20 */ 0x80, 0x81, 0x82, 0x83, 0x84, 0x92, 0x17, 0x1b,\n\t0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x05, 0x06, 0x07,\t/*................ */\n\t/*30 */ 0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04,\n\t0x98, 0x99, 0x9a, 0x9b, 0x14, 0x15, 0x9e, 0x1a,\t/*................ */\n\t/*40 */ 0x20, 0xa0, 0xe2, 0xe4, 0xe0, 0xe1, 0xe3, 0xe5,\n\t0xe7, 0xf1, 0x60, 0x2e, 0x3c, 0x28, 0x2b, 0x7c,\t/* .........`.<(+| */\n\t/*50 */ 0x26, 0xe9, 0xea, 0xeb, 0xe8, 0xed, 0xee, 0xef,\n\t0xec, 0xdf, 0x21, 0x24, 0x2a, 0x29, 0x3b, 0x9f,\t/*&.........!$*);. */\n\t/*60 */ 0x2d, 0x2f, 0xc2, 0xc4, 0xc0, 0xc1, 0xc3, 0xc5,\n\t0xc7, 0xd1, 0x5e, 0x2c, 0x25, 0x5f, 0x3e, 0x3f,\n\t/*-/........^,%_>?*/\n\t/*70 */ 0xf8, 0xc9, 0xca, 0xcb, 0xc8, 0xcd, 0xce, 0xcf,\n\t0xcc, 0xa8, 0x3a, 0x23, 0x40, 0x27, 0x3d, 0x22,\t/*..........:#@'=\" */\n\t/*80 */ 0xd8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t0x68, 0x69, 0xab, 0xbb, 0xf0, 0xfd, 0xfe, 0xb1,\t/*.abcdefghi...... */\n\t/*90 */ 0xb0, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,\n\t0x71, 0x72, 0xaa, 0xba, 0xe6, 0xb8, 0xc6, 0xa4,\t/*.jklmnopqr...... */\n\t/*a0 */ 0xb5, 0xaf, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n\t0x79, 0x7a, 0xa1, 0xbf, 0xd0, 0xdd, 0xde, 0xae,\t/*..stuvwxyz...... */\n\t/*b0 */ 0xa2, 0xa3, 0xa5, 0xb7, 0xa9, 0xa7, 0xb6, 0xbc,\n\t0xbd, 0xbe, 0xac, 0x5b, 0x5c, 0x5d, 0xb4, 0xd7,\t/*...........[\\].. */\n\t/*c0 */ 0xf9, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n\t0x48, 0x49, 0xad, 0xf4, 0xf6, 0xf2, 0xf3, 0xf5,\t/*.ABCDEFGHI...... */\n\t/*d0 */ 0xa6, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,\n\t0x51, 0x52, 0xb9, 0xfb, 0xfc, 0xdb, 0xfa, 0xff,\t/*.JKLMNOPQR...... */\n\t/*e0 */ 0xd9, 0xf7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n\t0x59, 0x5a, 0xb2, 0xd4, 0xd6, 0xd2, 0xd3, 0xd5,\t/*..STUVWXYZ...... */\n\t/*f0 */ 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n\t0x38, 0x39, 0xb3, 0x7b, 0xdc, 0x7d, 0xda, 0x7e\t/*0123456789.{.}.~ */\n};\n#endif /*CHARSET_EBCDIC */\n\nextern const int gdCosT[];\nextern const int gdSinT[];\n\nvoid gd_stderr_error(int priority, const char *format, va_list args)\n{\n\tswitch (priority) {\n\tcase GD_ERROR:\n\t\tfputs(\"GD Error: \", stderr);\n\t\tbreak;\n\tcase GD_WARNING:\n\t\tfputs(\"GD Warning: \", stderr);\n\t\tbreak;\n\tcase GD_NOTICE:\n\t\tfputs(\"GD Notice: \", stderr);\n\t\tbreak;\n\tcase GD_INFO:\n\t\tfputs(\"GD Info: \", stderr);\n\t\tbreak;\n\tcase GD_DEBUG:\n\t\tfputs(\"GD Debug: \", stderr);\n\t\tbreak;\n\t}\n\tvfprintf(stderr, format, args);\n\tfflush(stderr);\n}\n\nstatic gdErrorMethod gd_error_method = gd_stderr_error;\n\nvoid gd_error(const char *format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tgd_error_ex(GD_WARNING, format, args);\n\tva_end(args);\n}\nvoid gd_error_ex(int priority, const char *format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tif (gd_error_method) {\n\t\tgd_error_method(priority, format, args);\n\t}\n\tva_end(args);\n}\n\nBGD_DECLARE(void) gdSetErrorMethod(gdErrorMethod error_method)\n{\n\tgd_error_method = error_method;\n}\n\nBGD_DECLARE(void) gdClearErrorMethod(void)\n{\n\tgd_error_method = gd_stderr_error;\n}\n\nstatic void gdImageBrushApply (gdImagePtr im, int x, int y);\nstatic void gdImageTileApply (gdImagePtr im, int x, int y);\nBGD_DECLARE(int) gdImageGetTrueColorPixel (gdImagePtr im, int x, int y);\n\n\n/*\n    Function: gdImageCreate\n\n      gdImageCreate is called to create palette-based images, with no\n      more than 256 colors. The image must eventually be destroyed using\n      gdImageDestroy().\n\n    Parameters:\n\n        sx - The image width.\n        sy - The image height.\n\n    Returns:\n\n        A pointer to the new image or NULL if an error occurred.\n\n    Example:\n\n        >   gdImagePtr im;\n        >   im = gdImageCreate(64, 64);\n        >   // ... Use the image ...\n        >   gdImageDestroy(im);\n\n    See Also:\n\n        <gdImageCreateTrueColor>        \n\n */\nBGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\n\tif (overflow2(sizeof (unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char *), sx)) {\n\t\treturn NULL;\n\t}\n\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n\n\t/* Row-major ever since gd 1.3 */\n\tim->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; (i < sy); i++) {\n\t\t/* Row-major ever since gd 1.3 */\n\t\tim->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\tif (!im->pixels[i]) {\n\t\t\tfor (--i ; i >= 0; i--) {\n\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t}\n\t\t\tgdFree(im->pixels);\n\t\t\tgdFree(im);\n\t\t\treturn NULL;\n\t\t}\n\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tim->open[i] = 1;\n\t};\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->res_x = GD_RESOLUTION;\n\tim->res_y = GD_RESOLUTION;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}\n\n\n\n/*\n    Function: gdImageCreateTrueColor\n\n      <gdImageCreateTrueColor> is called to create truecolor images,\n      with an essentially unlimited number of colors. Invoke\n      <gdImageCreateTrueColor> with the x and y dimensions of the\n      desired image. <gdImageCreateTrueColor> returns a <gdImagePtr>\n      to the new image, or NULL if unable to allocate the image. The\n      image must eventually be destroyed using <gdImageDestroy>().\n\n      Truecolor images are always filled with black at creation\n      time. There is no concept of a \"background\" color index.\n\n    Parameters:\n\n        sx - The image width.\n        sy - The image height.\n\n    Returns:\n\n        A pointer to the new image or NULL if an error occurred.\n\n    Example:\n\n        > gdImagePtr im;\n        > im = gdImageCreateTrueColor(64, 64);\n        > // ... Use the image ...\n        > gdImageDestroy(im);\n\n    See Also:\n\n        <gdImageCreateTrueColor>        \n\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateTrueColor (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\n\tif (overflow2(sizeof (int *), sy)) {\n\t\treturn 0;\n\t}\n\n\tif (overflow2(sizeof(int), sx)) {\n\t\treturn NULL;\n\t}\n\n\tim = (gdImage *) gdMalloc (sizeof (gdImage));\n\tif (!im) {\n\t\treturn 0;\n\t}\n\tmemset (im, 0, sizeof (gdImage));\n\n\tim->tpixels = (int **) gdMalloc (sizeof (int *) * sy);\n\tif (!im->tpixels) {\n\t\tgdFree(im);\n\t\treturn 0;\n\t}\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; (i < sy); i++) {\n\t\tim->tpixels[i] = (int *) gdCalloc (sx, sizeof (int));\n\t\tif (!im->tpixels[i]) {\n\t\t\t/* 2.0.34 */\n\t\t\ti--;\n\t\t\twhile (i >= 0) {\n\t\t\t\tgdFree(im->tpixels[i]);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tgdFree(im->tpixels);\n\t\t\tgdFree(im);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->trueColor = 1;\n\t/* 2.0.2: alpha blending is now on by default, and saving of alpha is\n\t   off by default. This allows font antialiasing to work as expected\n\t   on the first try in JPEGs -- quite important -- and also allows\n\t   for smaller PNGs when saving of alpha channel is not really\n\t   desired, which it usually isn't! */\n\tim->saveAlphaFlag = 0;\n\tim->alphaBlendingFlag = 1;\n\tim->thick = 1;\n\tim->AA = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->res_x = GD_RESOLUTION;\n\tim->res_y = GD_RESOLUTION;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}\n\n/*\n  Function: gdImageDestroy\n\n    <gdImageDestroy> is used to free the memory associated with an\n    image. It is important to invoke <gdImageDestroy> before exiting\n    your program or assigning a new image to a <gdImagePtr> variable.\n\n  Parameters:\n\n    im  - Pointer to the gdImage to delete.\n\n  Returns:\n\n    Nothing.\n\n  Example:\n\n    > gdImagePtr im;\n    > im = gdImageCreate(10, 10);\n    > // ... Use the image ...\n    > // Now destroy it\n    > gdImageDestroy(im);\n\n*/\n\nBGD_DECLARE(void) gdImageDestroy (gdImagePtr im)\n{\n\tint i;\n\tif (im->pixels) {\n\t\tfor (i = 0; (i < im->sy); i++) {\n\t\t\tgdFree (im->pixels[i]);\n\t\t}\n\t\tgdFree (im->pixels);\n\t}\n\tif (im->tpixels) {\n\t\tfor (i = 0; (i < im->sy); i++) {\n\t\t\tgdFree (im->tpixels[i]);\n\t\t}\n\t\tgdFree (im->tpixels);\n\t}\n\tif (im->polyInts) {\n\t\tgdFree (im->polyInts);\n\t}\n\tif (im->style) {\n\t\tgdFree (im->style);\n\t}\n\tgdFree (im);\n}\n\nBGD_DECLARE(int) gdImageColorClosest (gdImagePtr im, int r, int g, int b)\n{\n\treturn gdImageColorClosestAlpha (im, r, g, b, gdAlphaOpaque);\n}\n\nBGD_DECLARE(int) gdImageColorClosestAlpha (gdImagePtr im, int r, int g, int b, int a)\n{\n\tint i;\n\tlong rd, gd, bd, ad;\n\tint ct = (-1);\n\tint first = 1;\n\tlong mindist = 0;\n\tif (im->trueColor) {\n\t\treturn gdTrueColorAlpha (r, g, b, a);\n\t}\n\tfor (i = 0; (i < (im->colorsTotal)); i++) {\n\t\tlong dist;\n\t\tif (im->open[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\trd = (im->red[i] - r);\n\t\tgd = (im->green[i] - g);\n\t\tbd = (im->blue[i] - b);\n\t\t/* gd 2.02: whoops, was - b (thanks to David Marwood) */\n\t\t/* gd 2.16: was blue rather than alpha! Geez! Thanks to\n\t\t   Artur Jakub Jerzak */\n\t\tad = (im->alpha[i] - a);\n\t\tdist = rd * rd + gd * gd + bd * bd + ad * ad;\n\t\tif (first || (dist < mindist)) {\n\t\t\tmindist = dist;\n\t\t\tct = i;\n\t\t\tfirst = 0;\n\t\t}\n\t}\n\treturn ct;\n}\n\n/* This code is taken from http://www.acm.org/jgt/papers/SmithLyons96/hwb_rgb.html, an article\n * on colour conversion to/from RBG and HWB colour systems.\n * It has been modified to return the converted value as a * parameter.\n */\n\n#define RETURN_HWB(h, w, b) {HWB->H = h; HWB->W = w; HWB->B = b; return HWB;}\n#define RETURN_RGB(r, g, b) {RGB->R = r; RGB->G = g; RGB->B = b; return RGB;}\n#define HWB_UNDEFINED -1\n#define SETUP_RGB(s, r, g, b) {s.R = r/255.0; s.G = g/255.0; s.B = b/255.0;}\n\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define MIN3(a,b,c) ((a)<(b)?(MIN(a,c)):(MIN(b,c)))\n#define MAX(a,b) ((a)<(b)?(b):(a))\n#define MAX3(a,b,c) ((a)<(b)?(MAX(b,c)):(MAX(a,c)))\n\n\n/*\n * Theoretically, hue 0 (pure red) is identical to hue 6 in these transforms. Pure\n * red always maps to 6 in this implementation. Therefore UNDEFINED can be\n * defined as 0 in situations where only unsigned numbers are desired.\n */\ntypedef struct {\n\tfloat R, G, B;\n}\nRGBType;\ntypedef struct {\n\tfloat H, W, B;\n}\nHWBType;\n\nstatic HWBType *\nRGB_to_HWB (RGBType RGB, HWBType * HWB)\n{\n\n\t/*\n\t * RGB are each on [0, 1]. W and B are returned on [0, 1] and H is\n\t * returned on [0, 6]. Exception: H is returned UNDEFINED if W == 1 - B.\n\t */\n\n\tfloat R = RGB.R, G = RGB.G, B = RGB.B, w, v, b, f;\n\tint i;\n\n\tw = MIN3 (R, G, B);\n\tv = MAX3 (R, G, B);\n\tb = 1 - v;\n\tif (v == w)\n\t\tRETURN_HWB (HWB_UNDEFINED, w, b);\n\tf = (R == w) ? G - B : ((G == w) ? B - R : R - G);\n\ti = (R == w) ? 3 : ((G == w) ? 5 : 1);\n\tRETURN_HWB (i - f / (v - w), w, b);\n\n}\n\nstatic float\nHWB_Diff (int r1, int g1, int b1, int r2, int g2, int b2)\n{\n\tRGBType RGB1, RGB2;\n\tHWBType HWB1, HWB2;\n\tfloat diff;\n\n\tSETUP_RGB (RGB1, r1, g1, b1);\n\tSETUP_RGB (RGB2, r2, g2, b2);\n\n\tRGB_to_HWB (RGB1, &HWB1);\n\tRGB_to_HWB (RGB2, &HWB2);\n\n\t/*\n\t * I made this bit up; it seems to produce OK results, and it is certainly\n\t * more visually correct than the current RGB metric. (PJW)\n\t */\n\n\tif ((HWB1.H == HWB_UNDEFINED) || (HWB2.H == HWB_UNDEFINED)) {\n\t\tdiff = 0;\t\t\t/* Undefined hues always match... */\n\t} else {\n\t\tdiff = fabs (HWB1.H - HWB2.H);\n\t\tif (diff > 3) {\n\t\t\tdiff = 6 - diff;\t/* Remember, it's a colour circle */\n\t\t}\n\t}\n\n\tdiff =\n\t    diff * diff + (HWB1.W - HWB2.W) * (HWB1.W - HWB2.W) + (HWB1.B -\n\t            HWB2.B) * (HWB1.B -\n\t                       HWB2.B);\n\n\treturn diff;\n}\n\n\n#if 0\n/*\n * This is not actually used, but is here for completeness, in case someone wants to\n * use the HWB stuff for anything else...\n */\nstatic RGBType *\nHWB_to_RGB (HWBType HWB, RGBType * RGB)\n{\n\n\t/*\n\t * H is given on [0, 6] or UNDEFINED. W and B are given on [0, 1].\n\t * RGB are each returned on [0, 1].\n\t */\n\n\tfloat h = HWB.H, w = HWB.W, b = HWB.B, v, n, f;\n\tint i;\n\n\tv = 1 - b;\n\tif (h == HWB_UNDEFINED)\n\t\tRETURN_RGB (v, v, v);\n\ti = floor (h);\n\tf = h - i;\n\tif (i & 1)\n\t\tf = 1 - f;\t\t\t/* if i is odd */\n\tn = w + f * (v - w);\t\t/* linear interpolation between w and v */\n\tswitch (i) {\n\tcase 6:\n\tcase 0:\n\t\tRETURN_RGB (v, n, w);\n\tcase 1:\n\t\tRETURN_RGB (n, v, w);\n\tcase 2:\n\t\tRETURN_RGB (w, v, n);\n\tcase 3:\n\t\tRETURN_RGB (w, n, v);\n\tcase 4:\n\t\tRETURN_RGB (n, w, v);\n\tcase 5:\n\t\tRETURN_RGB (v, w, n);\n\t}\n\n\treturn RGB;\n\n}\n#endif\n\nBGD_DECLARE(int) gdImageColorClosestHWB (gdImagePtr im, int r, int g, int b)\n{\n\tint i;\n\t/* long rd, gd, bd; */\n\tint ct = (-1);\n\tint first = 1;\n\tfloat mindist = 0;\n\tif (im->trueColor) {\n\t\treturn gdTrueColor (r, g, b);\n\t}\n\tfor (i = 0; (i < (im->colorsTotal)); i++) {\n\t\tfloat dist;\n\t\tif (im->open[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tdist = HWB_Diff (im->red[i], im->green[i], im->blue[i], r, g, b);\n\t\tif (first || (dist < mindist)) {\n\t\t\tmindist = dist;\n\t\t\tct = i;\n\t\t\tfirst = 0;\n\t\t}\n\t}\n\treturn ct;\n}\n\nBGD_DECLARE(int) gdImageColorExact (gdImagePtr im, int r, int g, int b)\n{\n\treturn gdImageColorExactAlpha (im, r, g, b, gdAlphaOpaque);\n}\n\nBGD_DECLARE(int) gdImageColorExactAlpha (gdImagePtr im, int r, int g, int b, int a)\n{\n\tint i;\n\tif (im->trueColor) {\n\t\treturn gdTrueColorAlpha (r, g, b, a);\n\t}\n\tfor (i = 0; (i < (im->colorsTotal)); i++) {\n\t\tif (im->open[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ((im->red[i] == r) &&\n\t\t        (im->green[i] == g) && (im->blue[i] == b) && (im->alpha[i] == a)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nBGD_DECLARE(int) gdImageColorAllocate (gdImagePtr im, int r, int g, int b)\n{\n\treturn gdImageColorAllocateAlpha (im, r, g, b, gdAlphaOpaque);\n}\n\nBGD_DECLARE(int) gdImageColorAllocateAlpha (gdImagePtr im, int r, int g, int b, int a)\n{\n\tint i;\n\tint ct = (-1);\n\tif (im->trueColor) {\n\t\treturn gdTrueColorAlpha (r, g, b, a);\n\t}\n\tfor (i = 0; (i < (im->colorsTotal)); i++) {\n\t\tif (im->open[i]) {\n\t\t\tct = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ct == (-1)) {\n\t\tct = im->colorsTotal;\n\t\tif (ct == gdMaxColors) {\n\t\t\treturn -1;\n\t\t}\n\t\tim->colorsTotal++;\n\t}\n\tim->red[ct] = r;\n\tim->green[ct] = g;\n\tim->blue[ct] = b;\n\tim->alpha[ct] = a;\n\tim->open[ct] = 0;\n\treturn ct;\n}\n\n/*\n * gdImageColorResolve is an alternative for the code fragment:\n *\n *      if ((color=gdImageColorExact(im,R,G,B)) < 0)\n *        if ((color=gdImageColorAllocate(im,R,G,B)) < 0)\n *          color=gdImageColorClosest(im,R,G,B);\n *\n * in a single function.    Its advantage is that it is guaranteed to\n * return a color index in one search over the color table.\n */\n\nBGD_DECLARE(int) gdImageColorResolve (gdImagePtr im, int r, int g, int b)\n{\n\treturn gdImageColorResolveAlpha (im, r, g, b, gdAlphaOpaque);\n}\n\nBGD_DECLARE(int) gdImageColorResolveAlpha (gdImagePtr im, int r, int g, int b, int a)\n{\n\tint c;\n\tint ct = -1;\n\tint op = -1;\n\tlong rd, gd, bd, ad, dist;\n\tlong mindist = 4 * 255 * 255;\t/* init to max poss dist */\n\tif (im->trueColor) {\n\t\treturn gdTrueColorAlpha (r, g, b, a);\n\t}\n\n\tfor (c = 0; c < im->colorsTotal; c++) {\n\t\tif (im->open[c]) {\n\t\t\top = c;\t\t/* Save open slot */\n\t\t\tcontinue;\t\t/* Color not in use */\n\t\t}\n\t\tif (c == im->transparent) {\n\t\t\t/* don't ever resolve to the color that has\n\t\t\t * been designated as the transparent color */\n\t\t\tcontinue;\n\t\t}\n\t\trd = (long) (im->red[c] - r);\n\t\tgd = (long) (im->green[c] - g);\n\t\tbd = (long) (im->blue[c] - b);\n\t\tad = (long) (im->alpha[c] - a);\n\t\tdist = rd * rd + gd * gd + bd * bd + ad * ad;\n\t\tif (dist < mindist) {\n\t\t\tif (dist == 0) {\n\t\t\t\treturn c;\t\t/* Return exact match color */\n\t\t\t}\n\t\t\tmindist = dist;\n\t\t\tct = c;\n\t\t}\n\t}\n\t/* no exact match.  We now know closest, but first try to allocate exact */\n\tif (op == -1) {\n\t\top = im->colorsTotal;\n\t\tif (op == gdMaxColors) {\n\t\t\t/* No room for more colors */\n\t\t\treturn ct;\t\t/* Return closest available color */\n\t\t}\n\t\tim->colorsTotal++;\n\t}\n\tim->red[op] = r;\n\tim->green[op] = g;\n\tim->blue[op] = b;\n\tim->alpha[op] = a;\n\tim->open[op] = 0;\n\treturn op;\t\t\t/* Return newly allocated color */\n}\n\nBGD_DECLARE(void) gdImageColorDeallocate (gdImagePtr im, int color)\n{\n\tif (im->trueColor || (color >= gdMaxColors) || (color < 0)) {\n\t\treturn;\n\t}\n\t/* Mark it open. */\n\tim->open[color] = 1;\n}\n\nBGD_DECLARE(void) gdImageColorTransparent (gdImagePtr im, int color)\n{\n\tif (!im->trueColor) {\n\t\tif((color < -1) || (color >= gdMaxColors)) {\n\t\t\treturn;\n\t\t}\n\t\tif (im->transparent != -1) {\n\t\t\tim->alpha[im->transparent] = gdAlphaOpaque;\n\t\t}\n\t\tif (color != -1) {\n\t\t\tim->alpha[color] = gdAlphaTransparent;\n\t\t}\n\t}\n\tim->transparent = color;\n}\n\nBGD_DECLARE(void) gdImagePaletteCopy (gdImagePtr to, gdImagePtr from)\n{\n\tint i;\n\tint x, y, p;\n\tint xlate[256];\n\tif (to->trueColor) {\n\t\treturn;\n\t}\n\tif (from->trueColor) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 256; i++) {\n\t\txlate[i] = -1;\n\t};\n\n\tfor (y = 0; y < (to->sy); y++) {\n\t\tfor (x = 0; x < (to->sx); x++) {\n\t\t\t/* Optimization: no gdImageGetPixel */\n\t\t\tp = to->pixels[y][x];\n\t\t\tif (xlate[p] == -1) {\n\t\t\t\t/* This ought to use HWB, but we don't have an alpha-aware\n\t\t\t\t   version of that yet. */\n\t\t\t\txlate[p] =\n\t\t\t\t    gdImageColorClosestAlpha (from, to->red[p], to->green[p],\n\t\t\t\t                              to->blue[p], to->alpha[p]);\n\t\t\t\t/*printf(\"Mapping %d (%d, %d, %d, %d) to %d (%d, %d, %d, %d)\\n\", */\n\t\t\t\t/*      p,  to->red[p], to->green[p], to->blue[p], to->alpha[p], */\n\t\t\t\t/*      xlate[p], from->red[xlate[p]], from->green[xlate[p]], from->blue[xlate[p]], from->alpha[xlate[p]]); */\n\t\t\t};\n\t\t\t/* Optimization: no gdImageSetPixel */\n\t\t\tto->pixels[y][x] = xlate[p];\n\t\t};\n\t};\n\n\tfor (i = 0; (i < (from->colorsTotal)); i++) {\n\t\t/*printf(\"Copying color %d (%d, %d, %d, %d)\\n\", i, from->red[i], from->blue[i], from->green[i], from->alpha[i]); */\n\t\tto->red[i] = from->red[i];\n\t\tto->blue[i] = from->blue[i];\n\t\tto->green[i] = from->green[i];\n\t\tto->alpha[i] = from->alpha[i];\n\t\tto->open[i] = 0;\n\t};\n\n\tfor (i = from->colorsTotal; (i < to->colorsTotal); i++) {\n\t\tto->open[i] = 1;\n\t};\n\n\tto->colorsTotal = from->colorsTotal;\n\n}\n\nBGD_DECLARE(int) gdImageColorReplace (gdImagePtr im, int src, int dst)\n{\n\tregister int x, y;\n\tint n = 0;\n\n\tif (src == dst) {\n\t\treturn 0;\n\t}\n\n#define REPLACING_LOOP(pixel) do {\t\t\t\t\t\t\t\t\\\n\t\tfor (y = im->cy1; y <= im->cy2; y++) {\t\t\t\t\t\\\n\t\t\tfor (x = im->cx1; x <= im->cx2; x++) {\t\t\t\t\\\n\t\t\t\tif (pixel(im, x, y) == src) {\t\t\t\t\t\\\n\t\t\t\t\tgdImageSetPixel(im, x, y, dst);\t\t\t\t\\\n\t\t\t\t\tn++;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tif (im->trueColor) {\n\t\tREPLACING_LOOP(gdImageTrueColorPixel);\n\t} else {\n\t\tREPLACING_LOOP(gdImagePalettePixel);\n\t}\n\n#undef REPLACING_LOOP\n\n\treturn n;\n}\n\nBGD_DECLARE(int) gdImageColorReplaceThreshold (gdImagePtr im, int src, int dst, float threshold)\n{\n\tregister int x, y;\n\tint n = 0;\n\n\tif (src == dst) {\n\t\treturn 0;\n\t}\n\n#define REPLACING_LOOP(pixel) do {\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (y = im->cy1; y <= im->cy2; y++) {\t\t\t\t\t\t\t\\\n\t\t\tfor (x = im->cx1; x <= im->cx2; x++) {\t\t\t\t\t\t\\\n\t\t\t\tif (gdColorMatch(im, src, pixel(im, x, y), threshold)) { \\\n\t\t\t\t\tgdImageSetPixel(im, x, y, dst);\t\t\t\t\t\t\\\n\t\t\t\t\tn++;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tif (im->trueColor) {\n\t\tREPLACING_LOOP(gdImageTrueColorPixel);\n\t} else {\n\t\tREPLACING_LOOP(gdImagePalettePixel);\n\t}\n\n#undef REPLACING_LOOP\n\n\treturn n;\n}\n\nstatic int colorCmp (const void *x, const void *y)\n{\n\tint a = *(int const *)x;\n\tint b = *(int const *)y;\n\treturn (a > b) - (a < b);\n}\n\nBGD_DECLARE(int) gdImageColorReplaceArray (gdImagePtr im, int len, int *src, int *dst)\n{\n\tregister int x, y;\n\tint c, *d, *base;\n\tint i, n = 0;\n\n\tif (len <= 0 || src == dst) {\n\t\treturn 0;\n\t}\n\tif (len == 1) {\n\t\treturn gdImageColorReplace(im, src[0], dst[0]);\n\t}\n\tif (overflow2(len, sizeof(int)<<1)) {\n\t\treturn -1;\n\t}\n\tbase = (int *)gdMalloc(len * (sizeof(int)<<1));\n\tif (!base) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tbase[(i<<1)]   = src[i];\n\t\tbase[(i<<1)+1] = dst[i];\n\t}\n\tqsort(base, len, sizeof(int)<<1, colorCmp);\n\n#define REPLACING_LOOP(pixel) do {\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (y = im->cy1; y <= im->cy2; y++) {\t\t\t\t\t\t\t\\\n\t\t\tfor (x = im->cx1; x <= im->cx2; x++) {\t\t\t\t\t\t\\\n\t\t\t\tc = pixel(im, x, y);\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif ( (d = (int *)bsearch(&c, base, len, sizeof(int)<<1, colorCmp)) ) { \\\n\t\t\t\t\tgdImageSetPixel(im, x, y, d[1]);\t\t\t\t\t\\\n\t\t\t\t\tn++;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tif (im->trueColor) {\n\t\tREPLACING_LOOP(gdImageTrueColorPixel);\n\t} else {\n\t\tREPLACING_LOOP(gdImagePalettePixel);\n\t}\n\n#undef REPLACING_LOOP\n\n\tgdFree(base);\n\treturn n;\n}\n\nBGD_DECLARE(int) gdImageColorReplaceCallback (gdImagePtr im, gdCallbackImageColor callback)\n{\n\tint c, d, n = 0;\n\n\tif (!callback) {\n\t\treturn 0;\n\t}\n\tif (im->trueColor) {\n\t\tregister int x, y;\n\n\t\tfor (y = im->cy1; y <= im->cy2; y++) {\n\t\t\tfor (x = im->cx1; x <= im->cx2; x++) {\n\t\t\t\tc = gdImageTrueColorPixel(im, x, y);\n\t\t\t\tif ( (d = callback(im, c)) != c) {\n\t\t\t\t\tgdImageSetPixel(im, x, y, d);\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else { /* palette */\n\t\tint *sarr, *darr;\n\t\tint k, len = 0;\n\n\t\tsarr = (int *)gdCalloc(im->colorsTotal, sizeof(int));\n\t\tif (!sarr) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (c = 0; c < im->colorsTotal; c++) {\n\t\t\tif (!im->open[c]) {\n\t\t\t\tsarr[len++] = c;\n\t\t\t}\n\t\t}\n\t\tdarr = (int *)gdCalloc(len, sizeof(int));\n\t\tif (!darr) {\n\t\t\tgdFree(sarr);\n\t\t\treturn -1;\n\t\t}\n\t\tfor (k = 0; k < len; k++) {\n\t\t\tdarr[k] = callback(im, sarr[k]);\n\t\t}\n\t\tn = gdImageColorReplaceArray(im, k, sarr, darr);\n\t\tgdFree(darr);\n\t\tgdFree(sarr);\n\t}\n\treturn n;\n}\n\n/* 2.0.10: before the drawing routines, some code to clip points that are\n * outside the drawing window.  Nick Atty (nick@canalplan.org.uk)\n *\n * This is the Sutherland Hodgman Algorithm, as implemented by\n * Duvanenko, Robbins and Gyurcsik - SH(DRG) for short.  See Dr Dobb's\n * Journal, January 1996, pp107-110 and 116-117\n *\n * Given the end points of a line, and a bounding rectangle (which we\n * know to be from (0,0) to (SX,SY)), adjust the endpoints to be on\n * the edges of the rectangle if the line should be drawn at all,\n * otherwise return a failure code */\n\n/* this does \"one-dimensional\" clipping: note that the second time it\n   is called, all the x parameters refer to height and the y to width\n   - the comments ignore this (if you can understand it when it's\n   looking at the X parameters, it should become clear what happens on\n   the second call!)  The code is simplified from that in the article,\n   as we know that gd images always start at (0,0) */\n\n/* 2.0.26, TBB: we now have to respect a clipping rectangle, it won't\n\tnecessarily start at 0. */\n\nstatic int\nclip_1d (int *x0, int *y0, int *x1, int *y1, int mindim, int maxdim)\n{\n\tdouble m;\t\t\t/* gradient of line */\n\tif (*x0 < mindim) {\n\t\t/* start of line is left of window */\n\t\tif (*x1 < mindim)\t\t/* as is the end, so the line never cuts the window */\n\t\t\treturn 0;\n\t\tm = (*y1 - *y0) / (double) (*x1 - *x0);\t/* calculate the slope of the line */\n\t\t/* adjust x0 to be on the left boundary (ie to be zero), and y0 to match */\n\t\t*y0 -= (int)(m * (*x0 - mindim));\n\t\t*x0 = mindim;\n\t\t/* now, perhaps, adjust the far end of the line as well */\n\t\tif (*x1 > maxdim) {\n\t\t\t*y1 += m * (maxdim - *x1);\n\t\t\t*x1 = maxdim;\n\t\t}\n\t\treturn 1;\n\t}\n\tif (*x0 > maxdim) {\n\t\t/* start of line is right of window -\n\t\tcomplement of above */\n\t\tif (*x1 > maxdim)\t\t/* as is the end, so the line misses the window */\n\t\t\treturn 0;\n\t\tm = (*y1 - *y0) / (double) (*x1 - *x0);\t/* calculate the slope of the line */\n\t\t*y0 += (int)(m * (maxdim - *x0));\t/* adjust so point is on the right\n\t\t\t\t\t\t\t   boundary */\n\t\t*x0 = maxdim;\n\t\t/* now, perhaps, adjust the end of the line */\n\t\tif (*x1 < mindim) {\n\t\t\t*y1 -= (int)(m * (*x1 - mindim));\n\t\t\t*x1 = mindim;\n\t\t}\n\t\treturn 1;\n\t}\n\t/* the final case - the start of the line is inside the window */\n\tif (*x1 > maxdim) {\n\t\t/* other end is outside to the right */\n\t\tm = (*y1 - *y0) / (double) (*x1 - *x0);\t/* calculate the slope of the line */\n\t\t*y1 += (int)(m * (maxdim - *x1));\n\t\t*x1 = maxdim;\n\t\treturn 1;\n\t}\n\tif (*x1 < mindim) {\n\t\t/* other end is outside to the left */\n\t\tm = (*y1 - *y0) / (double) (*x1 - *x0);\t/* calculate the slope of the line */\n\t\t*y1 -= (int)(m * (*x1 - mindim));\n\t\t*x1 = mindim;\n\t\treturn 1;\n\t}\n\t/* only get here if both points are inside the window */\n\treturn 1;\n}\n\n/* end of line clipping code */\n\nBGD_DECLARE(void) gdImageSetPixel (gdImagePtr im, int x, int y, int color)\n{\n\tint p;\n\tswitch (color) {\n\tcase gdStyled:\n\t\tif (!im->style) {\n\t\t\t/* Refuse to draw if no style is set. */\n\t\t\treturn;\n\t\t} else {\n\t\t\tp = im->style[im->stylePos++];\n\t\t}\n\t\tif (p != (gdTransparent)) {\n\t\t\tgdImageSetPixel (im, x, y, p);\n\t\t}\n\t\tim->stylePos = im->stylePos % im->styleLength;\n\t\tbreak;\n\tcase gdStyledBrushed:\n\t\tif (!im->style) {\n\t\t\t/* Refuse to draw if no style is set. */\n\t\t\treturn;\n\t\t}\n\t\tp = im->style[im->stylePos++];\n\t\tif ((p != gdTransparent) && (p != 0)) {\n\t\t\tgdImageSetPixel (im, x, y, gdBrushed);\n\t\t}\n\t\tim->stylePos = im->stylePos % im->styleLength;\n\t\tbreak;\n\tcase gdBrushed:\n\t\tgdImageBrushApply (im, x, y);\n\t\tbreak;\n\tcase gdTiled:\n\t\tgdImageTileApply (im, x, y);\n\t\tbreak;\n\tcase gdAntiAliased:\n\t\t/* This shouldn't happen (2.0.26) because we just call\n\t\t  gdImageAALine now, but do something sane. */\n\t\tgdImageSetPixel(im, x, y, im->AA_color);\n\t\tbreak;\n\tdefault:\n\t\tif (gdImageBoundsSafeMacro (im, x, y)) {\n\t\t\tif (im->trueColor) {\n\t\t\t\tswitch (im->alphaBlendingFlag) {\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase gdEffectReplace:\n\t\t\t\t\t\tim->tpixels[y][x] = color;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase gdEffectAlphaBlend:\n\t\t\t\t\tcase gdEffectNormal:\n\t\t\t\t\t\tim->tpixels[y][x] = gdAlphaBlend(im->tpixels[y][x], color);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase gdEffectOverlay :\n\t\t\t\t\t\tim->tpixels[y][x] = gdLayerOverlay(im->tpixels[y][x], color);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase gdEffectMultiply :\n\t\t\t\t\t\tim->tpixels[y][x] = gdLayerMultiply(im->tpixels[y][x], color);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tim->pixels[y][x] = color;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void\ngdImageBrushApply (gdImagePtr im, int x, int y)\n{\n\tint lx, ly;\n\tint hy;\n\tint hx;\n\tint x1, y1, x2, y2;\n\tint srcx, srcy;\n\tif (!im->brush) {\n\t\treturn;\n\t}\n\thy = gdImageSY (im->brush) / 2;\n\ty1 = y - hy;\n\ty2 = y1 + gdImageSY (im->brush);\n\thx = gdImageSX (im->brush) / 2;\n\tx1 = x - hx;\n\tx2 = x1 + gdImageSX (im->brush);\n\tsrcy = 0;\n\tif (im->trueColor) {\n\t\tif (im->brush->trueColor) {\n\t\t\tfor (ly = y1; (ly < y2); ly++) {\n\t\t\t\tsrcx = 0;\n\t\t\t\tfor (lx = x1; (lx < x2); lx++) {\n\t\t\t\t\tint p;\n\t\t\t\t\tp = gdImageGetTrueColorPixel (im->brush, srcx, srcy);\n\t\t\t\t\t/* 2.0.9, Thomas Winzig: apply simple full transparency */\n\t\t\t\t\tif (p != gdImageGetTransparent (im->brush)) {\n\t\t\t\t\t\tgdImageSetPixel (im, lx, ly, p);\n\t\t\t\t\t}\n\t\t\t\t\tsrcx++;\n\t\t\t\t}\n\t\t\t\tsrcy++;\n\t\t\t}\n\t\t} else {\n\t\t\t/* 2.0.12: Brush palette, image truecolor (thanks to Thorben Kundinger\n\t\t\t   for pointing out the issue) */\n\t\t\tfor (ly = y1; (ly < y2); ly++) {\n\t\t\t\tsrcx = 0;\n\t\t\t\tfor (lx = x1; (lx < x2); lx++) {\n\t\t\t\t\tint p, tc;\n\t\t\t\t\tp = gdImageGetPixel (im->brush, srcx, srcy);\n\t\t\t\t\ttc = gdImageGetTrueColorPixel (im->brush, srcx, srcy);\n\t\t\t\t\t/* 2.0.9, Thomas Winzig: apply simple full transparency */\n\t\t\t\t\tif (p != gdImageGetTransparent (im->brush)) {\n\t\t\t\t\t\tgdImageSetPixel (im, lx, ly, tc);\n\t\t\t\t\t}\n\t\t\t\t\tsrcx++;\n\t\t\t\t}\n\t\t\t\tsrcy++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (ly = y1; (ly < y2); ly++) {\n\t\t\tsrcx = 0;\n\t\t\tfor (lx = x1; (lx < x2); lx++) {\n\t\t\t\tint p;\n\t\t\t\tp = gdImageGetPixel (im->brush, srcx, srcy);\n\t\t\t\t/* Allow for non-square brushes! */\n\t\t\t\tif (p != gdImageGetTransparent (im->brush)) {\n\t\t\t\t\t/* Truecolor brush. Very slow\n\t\t\t\t\t   on a palette destination. */\n\t\t\t\t\tif (im->brush->trueColor) {\n\t\t\t\t\t\tgdImageSetPixel (im, lx, ly,\n\t\t\t\t\t\t                 gdImageColorResolveAlpha (im,\n\t\t\t\t\t\t                         gdTrueColorGetRed\n\t\t\t\t\t\t                         (p),\n\t\t\t\t\t\t                         gdTrueColorGetGreen\n\t\t\t\t\t\t                         (p),\n\t\t\t\t\t\t                         gdTrueColorGetBlue\n\t\t\t\t\t\t                         (p),\n\t\t\t\t\t\t                         gdTrueColorGetAlpha\n\t\t\t\t\t\t                         (p)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgdImageSetPixel (im, lx, ly, im->brushColorMap[p]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrcx++;\n\t\t\t}\n\t\t\tsrcy++;\n\t\t}\n\t}\n}\n\nstatic void\ngdImageTileApply (gdImagePtr im, int x, int y)\n{\n\tgdImagePtr tile = im->tile;\n\tint srcx, srcy;\n\tint p;\n\tif (!tile) {\n\t\treturn;\n\t}\n\tsrcx = x % gdImageSX (tile);\n\tsrcy = y % gdImageSY (tile);\n\tif (im->trueColor) {\n\t\tp = gdImageGetPixel (tile, srcx, srcy);\n\t\tif (p != gdImageGetTransparent (tile)) {\n\t\t\tif (!tile->trueColor) {\n\t\t\t\tp = gdTrueColorAlpha(tile->red[p], tile->green[p], tile->blue[p], tile->alpha[p]);\n\t\t\t}\n\t\t\tgdImageSetPixel (im, x, y, p);\n\t\t}\n\t} else {\n\t\tp = gdImageGetPixel (tile, srcx, srcy);\n\t\t/* Allow for transparency */\n\t\tif (p != gdImageGetTransparent (tile)) {\n\t\t\tif (tile->trueColor) {\n\t\t\t\t/* Truecolor tile. Very slow\n\t\t\t\t   on a palette destination. */\n\t\t\t\tgdImageSetPixel (im, x, y,\n\t\t\t\t                 gdImageColorResolveAlpha (im,\n\t\t\t\t                         gdTrueColorGetRed\n\t\t\t\t                         (p),\n\t\t\t\t                         gdTrueColorGetGreen\n\t\t\t\t                         (p),\n\t\t\t\t                         gdTrueColorGetBlue\n\t\t\t\t                         (p),\n\t\t\t\t                         gdTrueColorGetAlpha\n\t\t\t\t                         (p)));\n\t\t\t} else {\n\t\t\t\tgdImageSetPixel (im, x, y, im->tileColorMap[p]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nBGD_DECLARE(int) gdImageGetPixel (gdImagePtr im, int x, int y)\n{\n\tif (gdImageBoundsSafeMacro (im, x, y)) {\n\t\tif (im->trueColor) {\n\t\t\treturn im->tpixels[y][x];\n\t\t} else {\n\t\t\treturn im->pixels[y][x];\n\t\t}\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nBGD_DECLARE(int) gdImageGetTrueColorPixel (gdImagePtr im, int x, int y)\n{\n\tint p = gdImageGetPixel (im, x, y);\n\tif (!im->trueColor) {\n\t\treturn gdTrueColorAlpha (im->red[p], im->green[p], im->blue[p],\n\t\t                         (im->transparent == p) ? gdAlphaTransparent :\n\t\t                         im->alpha[p]);\n\t} else {\n\t\treturn p;\n\t}\n}\n\nBGD_DECLARE(void) gdImageAABlend (gdImagePtr im)\n{\n\t/* NO-OP, kept for library compatibility. */\n\t(void)im;\n}\n\nstatic void gdImageAALine (gdImagePtr im, int x1, int y1, int x2, int y2, int col);\n\nstatic void gdImageHLine(gdImagePtr im, int y, int x1, int x2, int col)\n{\n\tif (im->thick > 1) {\n\t\tint thickhalf = im->thick >> 1;\n\t\tgdImageFilledRectangle(im, x1, y - thickhalf, x2, y + im->thick - thickhalf - 1, col);\n\t} else {\n\t\tif (x2 < x1) {\n\t\t\tint t = x2;\n\t\t\tx2 = x1;\n\t\t\tx1 = t;\n\t\t}\n\n\t\tfor (; x1 <= x2; x1++) {\n\t\t\tgdImageSetPixel(im, x1, y, col);\n\t\t}\n\t}\n\treturn;\n}\n\nstatic void gdImageVLine(gdImagePtr im, int x, int y1, int y2, int col)\n{\n\tif (im->thick > 1) {\n\t\tint thickhalf = im->thick >> 1;\n\t\tgdImageFilledRectangle(im, x - thickhalf, y1, x + im->thick - thickhalf - 1, y2, col);\n\t} else {\n\t\tif (y2 < y1) {\n\t\t\tint t = y1;\n\t\t\ty1 = y2;\n\t\t\ty2 = t;\n\t\t}\n\n\t\tfor (; y1 <= y2; y1++) {\n\t\t\tgdImageSetPixel(im, x, y1, col);\n\t\t}\n\t}\n\treturn;\n}\n\n/* Bresenham as presented in Foley & Van Dam */\nBGD_DECLARE(void) gdImageLine (gdImagePtr im, int x1, int y1, int x2, int y2, int color)\n{\n\tint dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag;\n\tint wid;\n\tint w, wstart;\n\tint thick;\n\n\tif (color == gdAntiAliased) {\n\t\t/*\n\t\t  gdAntiAliased passed as color: use the much faster, much cheaper\n\t\t  and equally attractive gdImageAALine implementation. That\n\t\t  clips too, so don't clip twice.\n\t\t*/\n\t\tgdImageAALine(im, x1, y1, x2, y2, im->AA_color);\n\t\treturn;\n\t}\n\t/* 2.0.10: Nick Atty: clip to edges of drawing rectangle, return if no\n\t   points need to be drawn. 2.0.26, TBB: clip to edges of clipping\n\t   rectangle. We were getting away with this because gdImageSetPixel\n\t   is used for actual drawing, but this is still more efficient and opens\n\t   the way to skip per-pixel bounds checking in the future. */\n\n\tif (clip_1d (&x1, &y1, &x2, &y2, im->cx1, im->cx2) == 0)\n\t\treturn;\n\tif (clip_1d (&y1, &x1, &y2, &x2, im->cy1, im->cy2) == 0)\n\t\treturn;\n\tthick = im->thick;\n\n\tdx = abs (x2 - x1);\n\tdy = abs (y2 - y1);\n\n\tif (dx == 0) {\n\t\tgdImageVLine(im, x1, y1, y2, color);\n\t\treturn;\n\t} else if (dy == 0) {\n\t\tgdImageHLine(im, y1, x1, x2, color);\n\t\treturn;\n\t}\n\n\tif (dy <= dx) {\n\t\t/* More-or-less horizontal. use wid for vertical stroke */\n\t\t/* Doug Claar: watch out for NaN in atan2 (2.0.5) */\n\t\t\n\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\n\t\t\t  TBB: but watch out for /0! */\n\t\tdouble ac = cos (atan2 (dy, dx));\n\t\tif (ac != 0) {\n\t\t\twid = thick / ac;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tif (wid == 0) {\n\t\t\twid = 1;\n\t\t}\n\t\td = 2 * dy - dx;\n\t\tincr1 = 2 * dy;\n\t\tincr2 = 2 * (dy - dx);\n\t\tif (x1 > x2) {\n\t\t\tx = x2;\n\t\t\ty = y2;\n\t\t\tydirflag = (-1);\n\t\t\txend = x1;\n\t\t} else {\n\t\t\tx = x1;\n\t\t\ty = y1;\n\t\t\tydirflag = 1;\n\t\t\txend = x2;\n\t\t}\n\n\t\t/* Set up line thickness */\n\t\twstart = y - wid / 2;\n\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\tgdImageSetPixel (im, x, w, color);\n\n\t\tif (((y2 - y1) * ydirflag) > 0) {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = y - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t\t}\n\t\t} else {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = y - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* More-or-less vertical. use wid for horizontal stroke */\n\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\n\t\t   TBB: but watch out for /0! */\n\t\tdouble as = sin (atan2 (dy, dx));\n\t\tif (as != 0) {\n\t\t\twid = thick / as;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tif (wid == 0)\n\t\t\twid = 1;\n\n\t\td = 2 * dx - dy;\n\t\tincr1 = 2 * dx;\n\t\tincr2 = 2 * (dx - dy);\n\t\tif (y1 > y2) {\n\t\t\ty = y2;\n\t\t\tx = x2;\n\t\t\tyend = y1;\n\t\t\txdirflag = (-1);\n\t\t} else {\n\t\t\ty = y1;\n\t\t\tx = x1;\n\t\t\tyend = y2;\n\t\t\txdirflag = 1;\n\t\t}\n\n\t\t/* Set up line thickness */\n\t\twstart = x - wid / 2;\n\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\tgdImageSetPixel (im, w, y, color);\n\n\t\tif (((x2 - x1) * xdirflag) > 0) {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = x - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t\t}\n\t\t} else {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = x - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t\t}\n\t\t}\n\t}\n\n}\nstatic void dashedSet (gdImagePtr im, int x, int y, int color,\n\t\t\t\t\t   int *onP, int *dashStepP, int wid, int vert);\n\nBGD_DECLARE(void) gdImageDashedLine (gdImagePtr im, int x1, int y1, int x2, int y2, int color)\n{\n\tint dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag;\n\tint dashStep = 0;\n\tint on = 1;\n\tint wid;\n\tint vert;\n\tint thick = im->thick;\n\n\tdx = abs (x2 - x1);\n\tdy = abs (y2 - y1);\n\tif (dy <= dx) {\n\t\t/* More-or-less horizontal. use wid for vertical stroke */\n\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\n\t\t   TBB: but watch out for /0! */\n\t\tdouble as = sin (atan2 (dy, dx));\n\t\tif (as != 0) {\n\t\t\twid = thick / as;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tvert = 1;\n\n\t\td = 2 * dy - dx;\n\t\tincr1 = 2 * dy;\n\t\tincr2 = 2 * (dy - dx);\n\t\tif (x1 > x2) {\n\t\t\tx = x2;\n\t\t\ty = y2;\n\t\t\tydirflag = (-1);\n\t\t\txend = x1;\n\t\t} else {\n\t\t\tx = x1;\n\t\t\ty = y1;\n\t\t\tydirflag = 1;\n\t\t\txend = x2;\n\t\t}\n\t\tdashedSet (im, x, y, color, &on, &dashStep, wid, vert);\n\t\tif (((y2 - y1) * ydirflag) > 0) {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\tdashedSet (im, x, y, color, &on, &dashStep, wid, vert);\n\t\t\t}\n\t\t} else {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\tdashedSet (im, x, y, color, &on, &dashStep, wid, vert);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\n\t\t   TBB: but watch out for /0! */\n\t\tdouble as = sin (atan2 (dy, dx));\n\t\tif (as != 0) {\n\t\t\twid = thick / as;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tvert = 0;\n\n\t\td = 2 * dx - dy;\n\t\tincr1 = 2 * dx;\n\t\tincr2 = 2 * (dx - dy);\n\t\tif (y1 > y2) {\n\t\t\ty = y2;\n\t\t\tx = x2;\n\t\t\tyend = y1;\n\t\t\txdirflag = (-1);\n\t\t} else {\n\t\t\ty = y1;\n\t\t\tx = x1;\n\t\t\tyend = y2;\n\t\t\txdirflag = 1;\n\t\t}\n\t\tdashedSet (im, x, y, color, &on, &dashStep, wid, vert);\n\t\tif (((x2 - x1) * xdirflag) > 0) {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\tdashedSet (im, x, y, color, &on, &dashStep, wid, vert);\n\t\t\t}\n\t\t} else {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\tdashedSet (im, x, y, color, &on, &dashStep, wid, vert);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\ndashedSet (gdImagePtr im, int x, int y, int color,\n\t\t   int *onP, int *dashStepP, int wid, int vert)\n{\n\tint dashStep = *dashStepP;\n\tint on = *onP;\n\tint w, wstart;\n\n\tdashStep++;\n\tif (dashStep == gdDashSize) {\n\t\tdashStep = 0;\n\t\ton = !on;\n\t}\n\tif (on) {\n\t\tif (vert) {\n\t\t\twstart = y - wid / 2;\n\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t} else {\n\t\t\twstart = x - wid / 2;\n\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t}\n\t}\n\t*dashStepP = dashStep;\n\t*onP = on;\n}\n\nBGD_DECLARE(int) gdImageBoundsSafe (gdImagePtr im, int x, int y)\n{\n\treturn gdImageBoundsSafeMacro (im, x, y);\n}\n\nBGD_DECLARE(void) gdImageChar (gdImagePtr im, gdFontPtr f, int x, int y, int c, int color)\n{\n\tint cx, cy;\n\tint px, py;\n\tint fline;\n\tcx = 0;\n\tcy = 0;\n#ifdef CHARSET_EBCDIC\n\tc = ASC (c);\n#endif /*CHARSET_EBCDIC */\n\tif ((c < f->offset) || (c >= (f->offset + f->nchars))) {\n\t\treturn;\n\t}\n\tfline = (c - f->offset) * f->h * f->w;\n\tfor (py = y; (py < (y + f->h)); py++) {\n\t\tfor (px = x; (px < (x + f->w)); px++) {\n\t\t\tif (f->data[fline + cy * f->w + cx]) {\n\t\t\t\tgdImageSetPixel (im, px, py, color);\n\t\t\t}\n\t\t\tcx++;\n\t\t}\n\t\tcx = 0;\n\t\tcy++;\n\t}\n}\n\nBGD_DECLARE(void) gdImageCharUp (gdImagePtr im, gdFontPtr f, int x, int y, int c, int color)\n{\n\tint cx, cy;\n\tint px, py;\n\tint fline;\n\tcx = 0;\n\tcy = 0;\n#ifdef CHARSET_EBCDIC\n\tc = ASC (c);\n#endif /*CHARSET_EBCDIC */\n\tif ((c < f->offset) || (c >= (f->offset + f->nchars))) {\n\t\treturn;\n\t}\n\tfline = (c - f->offset) * f->h * f->w;\n\tfor (py = y; (py > (y - f->w)); py--) {\n\t\tfor (px = x; (px < (x + f->h)); px++) {\n\t\t\tif (f->data[fline + cy * f->w + cx]) {\n\t\t\t\tgdImageSetPixel (im, px, py, color);\n\t\t\t}\n\t\t\tcy++;\n\t\t}\n\t\tcy = 0;\n\t\tcx++;\n\t}\n}\n\nBGD_DECLARE(void) gdImageString (gdImagePtr im, gdFontPtr f,\n\t\t\t\t\t\t\t\t int x, int y, unsigned char *s, int color)\n{\n\tint i;\n\tint l;\n\tl = strlen ((char *) s);\n\tfor (i = 0; (i < l); i++) {\n\t\tgdImageChar (im, f, x, y, s[i], color);\n\t\tx += f->w;\n\t}\n}\n\nBGD_DECLARE(void) gdImageStringUp (gdImagePtr im, gdFontPtr f,\n\t\t\t\t\t\t\t\t   int x, int y, unsigned char *s, int color)\n{\n\tint i;\n\tint l;\n\tl = strlen ((char *) s);\n\tfor (i = 0; (i < l); i++) {\n\t\tgdImageCharUp (im, f, x, y, s[i], color);\n\t\ty -= f->w;\n\t}\n}\n\nstatic int strlen16 (unsigned short *s);\n\nBGD_DECLARE(void) gdImageString16 (gdImagePtr im, gdFontPtr f,\n\t\t\t\t\t\t\t\t   int x, int y, unsigned short *s, int color)\n{\n\tint i;\n\tint l;\n\tl = strlen16 (s);\n\tfor (i = 0; (i < l); i++) {\n\t\tgdImageChar (im, f, x, y, s[i], color);\n\t\tx += f->w;\n\t}\n}\n\nBGD_DECLARE(void) gdImageStringUp16 (gdImagePtr im, gdFontPtr f,\n\t\t\t\t\t\t\t\t\t int x, int y, unsigned short *s, int color)\n{\n\tint i;\n\tint l;\n\tl = strlen16 (s);\n\tfor (i = 0; (i < l); i++) {\n\t\tgdImageCharUp (im, f, x, y, s[i], color);\n\t\ty -= f->w;\n\t}\n}\n\nstatic int\nstrlen16 (unsigned short *s)\n{\n\tint len = 0;\n\twhile (*s) {\n\t\ts++;\n\t\tlen++;\n\t}\n\treturn len;\n}\n\n#ifndef HAVE_LSQRT\n/* If you don't have a nice square root function for longs, you can use\n   ** this hack\n */\nlong\nlsqrt (long n)\n{\n\tlong result = (long) sqrt ((double) n);\n\treturn result;\n}\n#endif\n\n/* s and e are integers modulo 360 (degrees), with 0 degrees\n   being the rightmost extreme and degrees changing clockwise.\n   cx and cy are the center in pixels; w and h are the horizontal\n   and vertical diameter in pixels. Nice interface, but slow.\n   See gd_arc_f_buggy.c for a better version that doesn't\n   seem to be bug-free yet. */\n\nBGD_DECLARE(void) gdImageArc (gdImagePtr im, int cx, int cy, int w, int h, int s, int e,\n\t\t\t\t\t\t\t  int color)\n{\n\tgdImageFilledArc (im, cx, cy, w, h, s, e, color, gdNoFill);\n}\n\nBGD_DECLARE(void) gdImageFilledArc (gdImagePtr im, int cx, int cy, int w, int h, int s, int e,\n\t\t\t\t\t\t\t\t\tint color, int style)\n{\n\tgdPoint pts[3];\n\tint i;\n\tint lx = 0, ly = 0;\n\tint fx = 0, fy = 0;\n\n\tif ((s % 360)  == (e % 360)) {\n\t\ts = 0;\n\t\te = 360;\n\t} else {\n\t\tif (s > 360) {\n\t\t\ts = s % 360;\n\t\t}\n\n\t\tif (e > 360) {\n\t\t\te = e % 360;\n\t\t}\n\n\t\twhile (s < 0) {\n\t\t\ts += 360;\n\t\t}\n\n\t\twhile (e < s) {\n\t\t\te += 360;\n\t\t}\n\n\t\tif (s == e) {\n\t\t\ts = 0;\n\t\t\te = 360;\n\t\t}\n\t}\n\n\tfor (i = s; (i <= e); i++) {\n\t\tint x, y;\n\t\tx = ((long) gdCosT[i % 360] * (long) w / (2 * 1024)) + cx;\n\t\ty = ((long) gdSinT[i % 360] * (long) h / (2 * 1024)) + cy;\n\t\tif (i != s) {\n\t\t\tif (!(style & gdChord)) {\n\t\t\t\tif (style & gdNoFill) {\n\t\t\t\t\tgdImageLine (im, lx, ly, x, y, color);\n\t\t\t\t} else {\n\t\t\t\t\t/* This is expensive! */\n\t\t\t\t\tpts[0].x = lx;\n\t\t\t\t\tpts[0].y = ly;\n\t\t\t\t\tpts[1].x = x;\n\t\t\t\t\tpts[1].y = y;\n\t\t\t\t\tpts[2].x = cx;\n\t\t\t\t\tpts[2].y = cy;\n\t\t\t\t\tgdImageFilledPolygon (im, pts, 3, color);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfx = x;\n\t\t\tfy = y;\n\t\t}\n\t\tlx = x;\n\t\tly = y;\n\t}\n\tif (style & gdChord) {\n\t\tif (style & gdNoFill) {\n\t\t\tif (style & gdEdged) {\n\t\t\t\tgdImageLine (im, cx, cy, lx, ly, color);\n\t\t\t\tgdImageLine (im, cx, cy, fx, fy, color);\n\t\t\t}\n\t\t\tgdImageLine (im, fx, fy, lx, ly, color);\n\t\t} else {\n\t\t\tpts[0].x = fx;\n\t\t\tpts[0].y = fy;\n\t\t\tpts[1].x = lx;\n\t\t\tpts[1].y = ly;\n\t\t\tpts[2].x = cx;\n\t\t\tpts[2].y = cy;\n\t\t\tgdImageFilledPolygon (im, pts, 3, color);\n\t\t}\n\t} else {\n\t\tif (style & gdNoFill) {\n\t\t\tif (style & gdEdged) {\n\t\t\t\tgdImageLine (im, cx, cy, lx, ly, color);\n\t\t\t\tgdImageLine (im, cx, cy, fx, fy, color);\n\t\t\t}\n\t\t}\n\t}\n}\n\nBGD_DECLARE(void) gdImageEllipse(gdImagePtr im, int mx, int my, int w, int h, int c)\n{\n\tint x=0,mx1=0,mx2=0,my1=0,my2=0;\n\tlong aq,bq,dx,dy,r,rx,ry,a,b;\n\n\ta=w>>1;\n\tb=h>>1;\n\tgdImageSetPixel(im,mx+a, my, c);\n\tgdImageSetPixel(im,mx-a, my, c);\n\tmx1 = mx-a;\n\tmy1 = my;\n\tmx2 = mx+a;\n\tmy2 = my;\n\n\taq = a * a;\n\tbq = b * b;\n\tdx = aq << 1;\n\tdy = bq << 1;\n\tr  = a * bq;\n\trx = r << 1;\n\try = 0;\n\tx = a;\n\twhile (x > 0) {\n\t\tif (r > 0) {\n\t\t\tmy1++;\n\t\t\tmy2--;\n\t\t\try +=dx;\n\t\t\tr  -=ry;\n\t\t}\n\t\tif (r <= 0) {\n\t\t\tx--;\n\t\t\tmx1++;\n\t\t\tmx2--;\n\t\t\trx -=dy;\n\t\t\tr  +=rx;\n\t\t}\n\t\tgdImageSetPixel(im,mx1, my1, c);\n\t\tgdImageSetPixel(im,mx1, my2, c);\n\t\tgdImageSetPixel(im,mx2, my1, c);\n\t\tgdImageSetPixel(im,mx2, my2, c);\n\t}\n}\n\n\nBGD_DECLARE(void) gdImageFilledEllipse (gdImagePtr im, int mx, int my, int w, int h, int c)\n{\n\tint x=0,mx1=0,mx2=0,my1=0,my2=0;\n\tlong aq,bq,dx,dy,r,rx,ry,a,b;\n\tint i;\n\tint old_y2;\n\n\ta=w>>1;\n\tb=h>>1;\n\n\tfor (x = mx-a; x <= mx+a; x++) {\n\t\tgdImageSetPixel(im, x, my, c);\n\t}\n\n\tmx1 = mx-a;\n\tmy1 = my;\n\tmx2 = mx+a;\n\tmy2 = my;\n\n\taq = a * a;\n\tbq = b * b;\n\tdx = aq << 1;\n\tdy = bq << 1;\n\tr  = a * bq;\n\trx = r << 1;\n\try = 0;\n\tx = a;\n\told_y2=-2;\n\twhile (x > 0) {\n\t\tif (r > 0) {\n\t\t\tmy1++;\n\t\t\tmy2--;\n\t\t\try +=dx;\n\t\t\tr  -=ry;\n\t\t}\n\t\tif (r <= 0) {\n\t\t\tx--;\n\t\t\tmx1++;\n\t\t\tmx2--;\n\t\t\trx -=dy;\n\t\t\tr  +=rx;\n\t\t}\n\t\tif(old_y2!=my2) {\n\t\t\tfor(i=mx1; i<=mx2; i++) {\n\t\t\t\tgdImageSetPixel(im,i,my1,c);\n\t\t\t}\n\t\t}\n\t\tif(old_y2!=my2) {\n\t\t\tfor(i=mx1; i<=mx2; i++) {\n\t\t\t\tgdImageSetPixel(im,i,my2,c);\n\t\t\t}\n\t\t}\n\t\told_y2 = my2;\n\t}\n}\n\nBGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit, rightLimit;\n\tint i;\n\tint restoreAlphaBleding;\n\n\tif (border < 0 || color < 0) {\n\t\t/* Refuse to fill to a non-solid border */\n\t\treturn;\n\t}\n\n\tif (!im->trueColor) {\n\t\tif ((color > (im->colorsTotal - 1)) || (border > (im->colorsTotal - 1))) {\n\t\t\treturn;\n\t\t}\n    }\n\n\tleftLimit = (-1);\n\n\trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\t\n\tfor (i = x; (i >= 0); i--) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == (-1)) {\n\t\tim->alphaBlendingFlag = restoreAlphaBleding;\n\t\treturn;\n\t}\n\t/* Seek right */\n\trightLimit = x;\n\tfor (i = (x + 1); (i < im->sx); i++) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t/* Look at lines above and below and start paints */\n\t/* Above */\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c;\n\t\t\tc = gdImageGetPixel (im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\t/* Below */\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c = gdImageGetPixel (im, i, y + 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBleding;\n}\n\n/*\n * set the pixel at (x,y) and its 4-connected neighbors\n * with the same pixel value to the new pixel value nc (new color).\n * A 4-connected neighbor:  pixel above, below, left, or right of a pixel.\n * ideas from comp.graphics discussions.\n * For tiled fill, the use of a flag buffer is mandatory. As the tile image can\n * contain the same color as the color to fill. To do not bloat normal filling\n * code I added a 2nd private function.\n */\n\nstatic int gdImageTileGet (gdImagePtr im, int x, int y)\n{\n\tint srcx, srcy;\n\tint tileColor,p;\n\tif (!im->tile) {\n\t\treturn -1;\n\t}\n\tsrcx = x % gdImageSX(im->tile);\n\tsrcy = y % gdImageSY(im->tile);\n\tp = gdImageGetPixel(im->tile, srcx, srcy);\n\tif (p == im->tile->transparent) {\n\t\ttileColor = im->transparent;\n\t} else if (im->trueColor) {\n\t\tif (im->tile->trueColor) {\n\t\t\ttileColor = p;\n\t\t} else {\n\t\t\ttileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));\n\t\t}\n\t} else {\n\t\tif (im->tile->trueColor) {\n\t\t\ttileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));\n\t\t} else {\n\t\t\ttileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));\n\t\t}\n\t}\n\treturn tileColor;\n}\n\n\n\n/* horizontal segment of scan line y */\nstruct seg {\n\tint y, xl, xr, dy;\n};\n\n/* max depth of stack */\n#define FILL_MAX ((int)(im->sy*im->sx)/4)\n#define FILL_PUSH(Y, XL, XR, DY) \\\n\tif (sp<stack+FILL_MAX && Y+(DY)>=0 && Y+(DY)<wy2) \\\n\t{sp->y = Y; sp->xl = XL; sp->xr = XR; sp->dy = DY; sp++;}\n\n#define FILL_POP(Y, XL, XR, DY) \\\n\t{sp--; Y = sp->y+(DY = sp->dy); XL = sp->xl; XR = sp->xr;}\n\nstatic void _gdImageFillTiled(gdImagePtr im, int x, int y, int nc);\nBGD_DECLARE(void) gdImageFill(gdImagePtr im, int x, int y, int nc)\n{\n\tint l, x1, x2, dy;\n\tint oc;   /* old pixel value */\n\tint wx2,wy2;\n\n\tint alphablending_bak;\n\n\t/* stack of filled segments */\n\t/* struct seg stack[FILL_MAX],*sp = stack; */\n\tstruct seg *stack;\n\tstruct seg *sp;\n\n\tif (!im->trueColor && nc > (im->colorsTotal - 1)) {\n\t\treturn;\n\t}\n\n\talphablending_bak = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (nc==gdTiled) {\n\t\t_gdImageFillTiled(im,x,y,nc);\n\t\tim->alphaBlendingFlag = alphablending_bak;\n\t\treturn;\n\t}\n\n\twx2=im->sx;\n\twy2=im->sy;\n\toc = gdImageGetPixel(im, x, y);\n\tif (oc==nc || x<0 || x>wx2 || y<0 || y>wy2) {\n\t\tim->alphaBlendingFlag = alphablending_bak;\n\t\treturn;\n\t}\n\n\t/* Do not use the 4 neighbors implementation with\n\t* small images\n\t*/\n\tif (im->sx < 4) {\n\t\tint ix = x, iy = y, c;\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tc = gdImageGetPixel(im, ix, iy);\n\t\t\t\tif (c != oc) {\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tgdImageSetPixel(im, ix, iy, nc);\n\t\t\t} while(ix++ < (im->sx -1));\n\t\t\tix = x;\n\t\t} while(iy++ < (im->sy -1));\n\t\tgoto done;\n\t}\n\n\tif(overflow2(im->sy, im->sx)) {\n\t\treturn;\n\t}\n\n\tif(overflow2(sizeof(struct seg), ((im->sy * im->sx) / 4))) {\n\t\treturn;\n\t}\n\n\tstack = (struct seg *)gdMalloc(sizeof(struct seg) * ((int)(im->sy*im->sx)/4));\n\tif (!stack) {\n\t\treturn;\n\t}\n\tsp = stack;\n\n\t/* required! */\n\tFILL_PUSH(y,x,x,1);\n\t/* seed segment (popped 1st) */\n\tFILL_PUSH(y+1, x, x, -1);\n\twhile (sp>stack) {\n\t\tFILL_POP(y, x1, x2, dy);\n\n\t\tfor (x=x1; x>=0 && gdImageGetPixel(im,x, y)==oc; x--) {\n\t\t\tgdImageSetPixel(im,x, y, nc);\n\t\t}\n\t\tif (x>=x1) {\n\t\t\tgoto skip;\n\t\t}\n\t\tl = x+1;\n\n\t\t/* leak on left? */\n\t\tif (l<x1) {\n\t\t\tFILL_PUSH(y, l, x1-1, -dy);\n\t\t}\n\t\tx = x1+1;\n\t\tdo {\n\t\t\tfor (; x<=wx2 && gdImageGetPixel(im,x, y)==oc; x++) {\n\t\t\t\tgdImageSetPixel(im, x, y, nc);\n\t\t\t}\n\t\t\tFILL_PUSH(y, l, x-1, dy);\n\t\t\t/* leak on right? */\n\t\t\tif (x>x2+1) {\n\t\t\t\tFILL_PUSH(y, x2+1, x-1, -dy);\n\t\t\t}\nskip:\n\t\t\tfor (x++; x<=x2 && (gdImageGetPixel(im, x, y)!=oc); x++);\n\n\t\t\tl = x;\n\t\t} while (x<=x2);\n\t}\n\n\tgdFree(stack);\n\ndone:\n\tim->alphaBlendingFlag = alphablending_bak;\n}\n\nstatic void _gdImageFillTiled(gdImagePtr im, int x, int y, int nc)\n{\n\tint l, x1, x2, dy;\n\tint oc;   /* old pixel value */\n\tint wx2,wy2;\n\t/* stack of filled segments */\n\tstruct seg *stack;\n\tstruct seg *sp;\n\tchar *pts;\n\n\tif (!im->tile) {\n\t\treturn;\n\t}\n\n\twx2=im->sx;\n\twy2=im->sy;\n\n\tif(overflow2(im->sy, im->sx)) {\n\t\treturn;\n\t}\n\n\tif(overflow2(sizeof(struct seg), ((im->sy * im->sx) / 4))) {\n\t\treturn;\n\t}\n\n\tpts = (char *) gdCalloc(im->sy * im->sx, sizeof(char));\n\tif (!pts) {\n\t\treturn;\n\t}\n\n\tstack = (struct seg *)gdMalloc(sizeof(struct seg) * ((int)(im->sy*im->sx)/4));\n\tif (!stack) {\n\t\tgdFree(pts);\n\t\treturn;\n\t}\n\tsp = stack;\n\n\toc = gdImageGetPixel(im, x, y);\n\n\t/* required! */\n\tFILL_PUSH(y,x,x,1);\n\t/* seed segment (popped 1st) */\n\tFILL_PUSH(y+1, x, x, -1);\n\twhile (sp>stack) {\n\t\tFILL_POP(y, x1, x2, dy);\n\t\tfor (x=x1; x>=0 && (!pts[y + x*wy2] && gdImageGetPixel(im,x,y)==oc); x--) {\n\t\t\tnc = gdImageTileGet(im,x,y);\n\t\t\tpts[y + x*wy2]=1;\n\t\t\tgdImageSetPixel(im,x, y, nc);\n\t\t}\n\t\tif (x>=x1) {\n\t\t\tgoto skip;\n\t\t}\n\t\tl = x+1;\n\n\t\t/* leak on left? */\n\t\tif (l<x1) {\n\t\t\tFILL_PUSH(y, l, x1-1, -dy);\n\t\t}\n\t\tx = x1+1;\n\t\tdo {\n\t\t\tfor (; x<wx2 && (!pts[y + x*wy2] && gdImageGetPixel(im,x, y)==oc) ; x++) {\n\t\t\t\tif (pts[y + x*wy2]) {\n\t\t\t\t\t/* we should never be here */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnc = gdImageTileGet(im,x,y);\n\t\t\t\tpts[y + x*wy2]=1;\n\t\t\t\tgdImageSetPixel(im, x, y, nc);\n\t\t\t}\n\t\t\tFILL_PUSH(y, l, x-1, dy);\n\t\t\t/* leak on right? */\n\t\t\tif (x>x2+1) {\n\t\t\t\tFILL_PUSH(y, x2+1, x-1, -dy);\n\t\t\t}\nskip:\n\t\t\tfor (x++; x<=x2 && (pts[y + x*wy2] || gdImageGetPixel(im,x, y)!=oc); x++);\n\t\t\tl = x;\n\t\t} while (x<=x2);\n\t}\n\n\tgdFree(pts);\n\tgdFree(stack);\n}\n\nBGD_DECLARE(void) gdImageRectangle (gdImagePtr im, int x1, int y1, int x2, int y2, int color)\n{\n\tint thick = im->thick;\n\n\tif (x1 == x2 && y1 == y2 && thick == 1) {\n\t\tgdImageSetPixel(im, x1, y1, color);\n\t\treturn;\n\t}\n\n\tif (y2 < y1) {\n\t\tint t;\n\t\tt = y1;\n\t\ty1 = y2;\n\t\ty2 = t;\n\n\t\tt = x1;\n\t\tx1 = x2;\n\t\tx2 = t;\n\t}\n\n\tif (thick > 1) {\n\t\tint cx, cy, x1ul, y1ul, x2lr, y2lr;\n\t\tint half = thick >> 1;\n\t\tx1ul = x1 - half;\n\t\ty1ul = y1 - half;\n\n\t\tx2lr = x2 + half;\n\t\ty2lr = y2 + half;\n\n\t\tcy = y1ul + thick;\n\t\twhile (cy-- > y1ul) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y2lr - thick;\n\t\twhile (cy++ < y2lr) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y1ul + thick - 1;\n\t\twhile (cy++ < y2lr -thick) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x1ul + thick) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y1ul + thick - 1;\n\t\twhile (cy++ < y2lr -thick) {\n\t\t\tcx = x2lr - thick - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t} else {\n\t\tgdImageLine(im, x1, y1, x2, y1, color);\n\t\tgdImageLine(im, x1, y2, x2, y2, color);\n\t\tgdImageLine(im, x1, y1 + 1, x1, y2 - 1, color);\n\t\tgdImageLine(im, x2, y1 + 1, x2, y2 - 1, color);\n\t}\n}\n\nBGD_DECLARE(void) gdImageFilledRectangle (gdImagePtr im, int x1, int y1, int x2, int y2,\n\t\tint color)\n{\n\tint x, y;\n\n\tif (x1 == x2 && y1 == y2) {\n\t\tgdImageSetPixel(im, x1, y1, color);\n\t\treturn;\n\t}\n\n\tif (x1 > x2) {\n\t\tx = x1;\n\t\tx1 = x2;\n\t\tx2 = x;\n\t}\n\n\tif (y1 > y2) {\n\t\ty = y1;\n\t\ty1 = y2;\n\t\ty2 = y;\n\t}\n\n\tif (x1 < 0) {\n\t\tx1 = 0;\n\t}\n\n\tif (x2 >= gdImageSX(im)) {\n\t\tx2 = gdImageSX(im) - 1;\n\t}\n\n\tif (y1 < 0) {\n\t\ty1 = 0;\n\t}\n\n\tif (y2 >= gdImageSY(im)) {\n\t\ty2 = gdImageSY(im) - 1;\n\t}\n\n\tfor (y = y1; (y <= y2); y++) {\n\t\tfor (x = x1; (x <= x2); x++) {\n\t\t\tgdImageSetPixel (im, x, y, color);\n\t\t}\n\t}\n}\n\nBGD_DECLARE(gdImagePtr) gdImageClone (gdImagePtr src) {\n\tgdImagePtr dst;\n\tregister int i, x;\n\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(src->sx , src->sy);\n\t} else {\n\t\tdst = gdImageCreate(src->sx , src->sy);\n\t}\n\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (src->trueColor == 0) {\n\t\tdst->colorsTotal = src->colorsTotal;\n\t\tfor (i = 0; i < gdMaxColors; i++) {\n\t\t\tdst->red[i]   = src->red[i];\n\t\t\tdst->green[i] = src->green[i];\n\t\t\tdst->blue[i]  = src->blue[i];\n\t\t\tdst->alpha[i] = src->alpha[i];\n\t\t\tdst->open[i]  = src->open[i];\n\t\t}\n\t\tfor (i = 0; i < src->sy; i++) {\n\t\t\tfor (x = 0; x < src->sx; x++) {\n\t\t\t\tdst->pixels[i][x] = src->pixels[i][x];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < src->sy; i++) {\n\t\t\tfor (x = 0; x < src->sx; x++) {\n\t\t\t\tdst->tpixels[i][x] = src->tpixels[i][x];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (src->styleLength > 0) {\n\t\tdst->styleLength = src->styleLength;\n\t\tdst->stylePos    = src->stylePos;\n\t\tfor (i = 0; i < src->styleLength; i++) {\n\t\t\tdst->style[i] = src->style[i];\n\t\t}\n\t}\n\n\tdst->interlace   = src->interlace;\n\n\tdst->alphaBlendingFlag = src->alphaBlendingFlag;\n\tdst->saveAlphaFlag     = src->saveAlphaFlag;\n\tdst->AA                = src->AA;\n\tdst->AA_color          = src->AA_color;\n\tdst->AA_dont_blend     = src->AA_dont_blend;\n\n\tdst->cx1 = src->cx1;\n\tdst->cy1 = src->cy1;\n\tdst->cx2 = src->cx2;\n\tdst->cy2 = src->cy2;\n\n\tdst->res_x = src->res_x;\n\tdst->res_y = src->res_x;\n\n\tdst->paletteQuantizationMethod     = src->paletteQuantizationMethod;\n\tdst->paletteQuantizationSpeed      = src->paletteQuantizationSpeed;\n\tdst->paletteQuantizationMinQuality = src->paletteQuantizationMinQuality;\n\tdst->paletteQuantizationMinQuality = src->paletteQuantizationMinQuality;\n\n\tdst->interpolation_id = src->interpolation_id;\n\tdst->interpolation    = src->interpolation;\n\n\tif (src->brush) {\n\t\tdst->brush = gdImageClone(src->brush);\n\t}\n\n\tif (src->tile) {\n\t\tdst->tile = gdImageClone(src->tile);\n\t}\n\n\tif (src->style) {\n\t\tgdImageSetStyle(dst, src->style, src->styleLength);\n\t}\n\n\tfor (i = 0; i < gdMaxColors; i++) {\n\t\tdst->brushColorMap[i] = src->brushColorMap[i];\n\t\tdst->tileColorMap[i] = src->tileColorMap[i];\n\t}\n\n\tif (src->polyAllocated > 0) {\n\t\tdst->polyAllocated = src->polyAllocated;\n\t\tfor (i = 0; i < src->polyAllocated; i++) {\n\t\t\tdst->polyInts[i] = src->polyInts[i];\n\t\t}\n\t}\n\n\treturn dst;\n}\n\nBGD_DECLARE(void) gdImageCopy (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX,\n\t\t\t\t\t\t\t   int srcY, int w, int h)\n{\n\tint c;\n\tint x, y;\n\tint tox, toy;\n\tint i;\n\tint colorMap[gdMaxColors];\n\n\tif (dst->trueColor) {\n\t\t/* 2.0: much easier when the destination is truecolor. */\n\t\t/* 2.0.10: needs a transparent-index check that is still valid if\n\t\t *          * the source is not truecolor. Thanks to Frank Warmerdam.\n\t\t */\n\n\t\tif (src->trueColor) {\n\t\t\tfor (y = 0; (y < h); y++) {\n\t\t\t\tfor (x = 0; (x < w); x++) {\n\t\t\t\t\tint c = gdImageGetTrueColorPixel (src, srcX + x, srcY + y);\n\t\t\t\t\tif (c != src->transparent) {\n\t\t\t\t\t\tgdImageSetPixel (dst, dstX + x, dstY + y, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* source is palette based */\n\t\t\tfor (y = 0; (y < h); y++) {\n\t\t\t\tfor (x = 0; (x < w); x++) {\n\t\t\t\t\tint c = gdImageGetPixel (src, srcX + x, srcY + y);\n\t\t\t\t\tif (c != src->transparent) {\n\t\t\t\t\t\tgdImageSetPixel(dst, dstX + x, dstY + y, gdTrueColorAlpha(src->red[c], src->green[c], src->blue[c], src->alpha[c]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tcolorMap[i] = (-1);\n\t}\n\ttoy = dstY;\n\tfor (y = srcY; (y < (srcY + h)); y++) {\n\t\ttox = dstX;\n\t\tfor (x = srcX; (x < (srcX + w)); x++) {\n\t\t\tint nc;\n\t\t\tint mapTo;\n\t\t\tc = gdImageGetPixel (src, x, y);\n\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\tif (gdImageGetTransparent (src) == c) {\n\t\t\t\ttox++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Have we established a mapping for this color? */\n\t\t\tif (src->trueColor) {\n\t\t\t\t/* 2.05: remap to the palette available in the\n\t\t\t\t destination image. This is slow and\n\t\t\t\t works badly, but it beats crashing! Thanks\n\t\t\t\t to Padhrig McCarthy. */\n\t\t\t\tmapTo = gdImageColorResolveAlpha (dst,\n\t\t\t\t                                  gdTrueColorGetRed (c),\n\t\t\t\t                                  gdTrueColorGetGreen (c),\n\t\t\t\t                                  gdTrueColorGetBlue (c),\n\t\t\t\t                                  gdTrueColorGetAlpha (c));\n\t\t\t} else if (colorMap[c] == (-1)) {\n\t\t\t\t/* If it's the same image, mapping is trivial */\n\t\t\t\tif (dst == src) {\n\t\t\t\t\tnc = c;\n\t\t\t\t} else {\n\t\t\t\t\t/* Get best match possible. This\n\t\t\t\t\t   function never returns error. */\n\t\t\t\t\tnc = gdImageColorResolveAlpha (dst,\n\t\t\t\t\t                               src->red[c], src->green[c],\n\t\t\t\t\t                               src->blue[c], src->alpha[c]);\n\t\t\t\t}\n\t\t\t\tcolorMap[c] = nc;\n\t\t\t\tmapTo = colorMap[c];\n\t\t\t} else {\n\t\t\t\tmapTo = colorMap[c];\n\t\t\t}\n\t\t\tgdImageSetPixel (dst, tox, toy, mapTo);\n\t\t\ttox++;\n\t\t}\n\t\ttoy++;\n\t}\n}\n\n/* This function is a substitute for real alpha channel operations,\n   so it doesn't pay attention to the alpha channel. */\nBGD_DECLARE(void) gdImageCopyMerge (gdImagePtr dst, gdImagePtr src, int dstX, int dstY,\n\t\t\t\t\t\t\t\t\tint srcX, int srcY, int w, int h, int pct)\n{\n\n\tint c, dc;\n\tint x, y;\n\tint tox, toy;\n\tint ncR, ncG, ncB;\n\ttoy = dstY;\n\tfor (y = srcY; (y < (srcY + h)); y++) {\n\t\ttox = dstX;\n\t\tfor (x = srcX; (x < (srcX + w)); x++) {\n\t\t\tint nc;\n\t\t\tc = gdImageGetPixel (src, x, y);\n\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\tif (gdImageGetTransparent (src) == c) {\n\t\t\t\ttox++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* If it's the same image, mapping is trivial */\n\t\t\tif (dst == src) {\n\t\t\t\tnc = c;\n\t\t\t} else {\n\t\t\t\tdc = gdImageGetPixel (dst, tox, toy);\n\n\t\t\t\tncR = gdImageRed (src, c) * (pct / 100.0)\n\t\t\t\t      + gdImageRed (dst, dc) * ((100 - pct) / 100.0);\n\t\t\t\tncG = gdImageGreen (src, c) * (pct / 100.0)\n\t\t\t\t      + gdImageGreen (dst, dc) * ((100 - pct) / 100.0);\n\t\t\t\tncB = gdImageBlue (src, c) * (pct / 100.0)\n\t\t\t\t      + gdImageBlue (dst, dc) * ((100 - pct) / 100.0);\n\n\t\t\t\t/* Find a reasonable color */\n\t\t\t\tnc = gdImageColorResolve (dst, ncR, ncG, ncB);\n\t\t\t}\n\t\t\tgdImageSetPixel (dst, tox, toy, nc);\n\t\t\ttox++;\n\t\t}\n\t\ttoy++;\n\t}\n}\n\n/* This function is a substitute for real alpha channel operations,\n   so it doesn't pay attention to the alpha channel. */\nBGD_DECLARE(void) gdImageCopyMergeGray (gdImagePtr dst, gdImagePtr src, int dstX, int dstY,\n\t\t\t\t\t\t\t\t\t\tint srcX, int srcY, int w, int h, int pct)\n{\n\n\tint c, dc;\n\tint x, y;\n\tint tox, toy;\n\tint ncR, ncG, ncB;\n\tfloat g;\n\ttoy = dstY;\n\tfor (y = srcY; (y < (srcY + h)); y++) {\n\t\ttox = dstX;\n\t\tfor (x = srcX; (x < (srcX + w)); x++) {\n\t\t\tint nc;\n\t\t\tc = gdImageGetPixel (src, x, y);\n\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\tif (gdImageGetTransparent (src) == c) {\n\t\t\t\ttox++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If it's the same image, mapping is NOT trivial since we\n\t\t\t * merge with greyscale target, but if pct is 100, the grey\n\t\t\t * value is not used, so it becomes trivial. pjw 2.0.12.\n\t\t\t */\n\t\t\tif (dst == src && pct == 100) {\n\t\t\t\tnc = c;\n\t\t\t} else {\n\t\t\t\tdc = gdImageGetPixel (dst, tox, toy);\n\t\t\t\tg = 0.29900 * gdImageRed(dst, dc)\n\t\t\t\t    + 0.58700 * gdImageGreen(dst, dc) + 0.11400 * gdImageBlue(dst, dc);\n\n\t\t\t\tncR = gdImageRed (src, c) * (pct / 100.0)\n\t\t\t\t      + g * ((100 - pct) / 100.0);\n\t\t\t\tncG = gdImageGreen (src, c) * (pct / 100.0)\n\t\t\t\t      + g * ((100 - pct) / 100.0);\n\t\t\t\tncB = gdImageBlue (src, c) * (pct / 100.0)\n\t\t\t\t      + g * ((100 - pct) / 100.0);\n\n\t\t\t\t/* First look for an exact match */\n\t\t\t\tnc = gdImageColorExact (dst, ncR, ncG, ncB);\n\t\t\t\tif (nc == (-1)) {\n\t\t\t\t\t/* No, so try to allocate it */\n\t\t\t\t\tnc = gdImageColorAllocate (dst, ncR, ncG, ncB);\n\t\t\t\t\t/* If we're out of colors, go for the\n\t\t\t\t\t   closest color */\n\t\t\t\t\tif (nc == (-1)) {\n\t\t\t\t\t\tnc = gdImageColorClosest (dst, ncR, ncG, ncB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgdImageSetPixel (dst, tox, toy, nc);\n\t\t\ttox++;\n\t\t}\n\t\ttoy++;\n\t}\n}\n\nBGD_DECLARE(void) gdImageCopyResized (gdImagePtr dst, gdImagePtr src, int dstX, int dstY,\n\t\t\t\t\t\t\t\t\t  int srcX, int srcY, int dstW, int dstH, int srcW,\n\t\t\t\t\t\t\t\t\t  int srcH)\n{\n\tint c;\n\tint x, y;\n\tint tox, toy;\n\tint ydest;\n\tint i;\n\tint colorMap[gdMaxColors];\n\t/* Stretch vectors */\n\tint *stx;\n\tint *sty;\n\t/* We only need to use floating point to determine the correct\n\t   stretch vector for one line's worth. */\n\tif (overflow2(sizeof (int), srcW)) {\n\t\treturn;\n\t}\n\tif (overflow2(sizeof (int), srcH)) {\n\t\treturn;\n\t}\n\tstx = (int *) gdMalloc (sizeof (int) * srcW);\n\tif (!stx) {\n\t\treturn;\n\t}\n\n\tsty = (int *) gdMalloc (sizeof (int) * srcH);\n\tif (!sty) {\n\t\tgdFree(stx);\n\t\treturn;\n\t}\n\n\t/* Fixed by Mao Morimoto 2.0.16 */\n\tfor (i = 0; (i < srcW); i++) {\n\t\tstx[i] = dstW * (i + 1) / srcW - dstW * i / srcW;\n\t}\n\tfor (i = 0; (i < srcH); i++) {\n\t\tsty[i] = dstH * (i + 1) / srcH - dstH * i / srcH;\n\t}\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tcolorMap[i] = (-1);\n\t}\n\ttoy = dstY;\n\tfor (y = srcY; (y < (srcY + srcH)); y++) {\n\t\tfor (ydest = 0; (ydest < sty[y - srcY]); ydest++) {\n\t\t\ttox = dstX;\n\t\t\tfor (x = srcX; (x < (srcX + srcW)); x++) {\n\t\t\t\tint nc = 0;\n\t\t\t\tint mapTo;\n\t\t\t\tif (!stx[x - srcX]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (dst->trueColor) {\n\t\t\t\t\t/* 2.0.9: Thorben Kundinger: Maybe the source image is not\n\t\t\t\t\t   a truecolor image */\n\t\t\t\t\tif (!src->trueColor) {\n\t\t\t\t\t\tint tmp = gdImageGetPixel (src, x, y);\n\t\t\t\t\t\tmapTo = gdImageGetTrueColorPixel (src, x, y);\n\t\t\t\t\t\tif (gdImageGetTransparent (src) == tmp) {\n\t\t\t\t\t\t\t/* 2.0.21, TK: not tox++ */\n\t\t\t\t\t\t\ttox += stx[x - srcX];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* TK: old code follows */\n\t\t\t\t\t\tmapTo = gdImageGetTrueColorPixel (src, x, y);\n\t\t\t\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\t\t\t\tif (gdImageGetTransparent (src) == mapTo) {\n\t\t\t\t\t\t\t/* 2.0.21, TK: not tox++ */\n\t\t\t\t\t\t\ttox += stx[x - srcX];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tc = gdImageGetPixel (src, x, y);\n\t\t\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\t\t\tif (gdImageGetTransparent (src) == c) {\n\t\t\t\t\t\ttox += stx[x - srcX];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (src->trueColor) {\n\t\t\t\t\t\t/* Remap to the palette available in the\n\t\t\t\t\t\t   destination image. This is slow and\n\t\t\t\t\t\t   works badly. */\n\t\t\t\t\t\tmapTo = gdImageColorResolveAlpha (dst,\n\t\t\t\t\t\t                                  gdTrueColorGetRed (c),\n\t\t\t\t\t\t                                  gdTrueColorGetGreen\n\t\t\t\t\t\t                                  (c),\n\t\t\t\t\t\t                                  gdTrueColorGetBlue\n\t\t\t\t\t\t                                  (c),\n\t\t\t\t\t\t                                  gdTrueColorGetAlpha\n\t\t\t\t\t\t                                  (c));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Have we established a mapping for this color? */\n\t\t\t\t\t\tif (colorMap[c] == (-1)) {\n\t\t\t\t\t\t\t/* If it's the same image, mapping is trivial */\n\t\t\t\t\t\t\tif (dst == src) {\n\t\t\t\t\t\t\t\tnc = c;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t/* Find or create the best match */\n\t\t\t\t\t\t\t\t/* 2.0.5: can't use gdTrueColorGetRed, etc with palette */\n\t\t\t\t\t\t\t\tnc = gdImageColorResolveAlpha (dst,\n\t\t\t\t\t\t\t\t                               gdImageRed (src,\n\t\t\t\t\t\t\t\t                                       c),\n\t\t\t\t\t\t\t\t                               gdImageGreen\n\t\t\t\t\t\t\t\t                               (src, c),\n\t\t\t\t\t\t\t\t                               gdImageBlue (src,\n\t\t\t\t\t\t\t\t                                       c),\n\t\t\t\t\t\t\t\t                               gdImageAlpha\n\t\t\t\t\t\t\t\t                               (src, c));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcolorMap[c] = nc;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapTo = colorMap[c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i = 0; (i < stx[x - srcX]); i++) {\n\t\t\t\t\tgdImageSetPixel (dst, tox, toy, mapTo);\n\t\t\t\t\ttox++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoy++;\n\t\t}\n\t}\n\tgdFree (stx);\n\tgdFree (sty);\n}\n\n/* gd 2.0.8: gdImageCopyRotated is added. Source\n\tis a rectangle, with its upper left corner at\n\tsrcX and srcY. Destination is the *center* of\n\t\tthe rotated copy. Angle is in degrees, same as\n\t\tgdImageArc. Floating point destination center\n\tcoordinates allow accurate rotation of\n\tobjects of odd-numbered width or height. */\n\nBGD_DECLARE(void) gdImageCopyRotated (gdImagePtr dst,\n\t\t\t\t\t\t\t\t\t  gdImagePtr src,\n\t\t\t\t\t\t\t\t\t  double dstX, double dstY,\n\t\t\t\t\t\t\t\t\t  int srcX, int srcY,\n\t\t\t\t\t\t\t\t\t  int srcWidth, int srcHeight, int angle)\n{\n\tdouble dx, dy;\n\tdouble radius = sqrt (srcWidth * srcWidth + srcHeight * srcHeight);\n\tdouble aCos = cos (angle * .0174532925);\n\tdouble aSin = sin (angle * .0174532925);\n\tdouble scX = srcX + ((double) srcWidth) / 2;\n\tdouble scY = srcY + ((double) srcHeight) / 2;\n\tint cmap[gdMaxColors];\n\tint i;\n\n\t/*\n\t\t 2.0.34: transparency preservation. The transparentness of\n\t\t the transparent color is more important than its hue.\n\t*/\n\tif (src->transparent != -1) {\n\t\tif (dst->transparent == -1) {\n\t\t\tdst->transparent = src->transparent;\n\t\t}\n\t}\n\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tcmap[i] = (-1);\n\t}\n\tfor (dy = dstY - radius; (dy <= dstY + radius); dy++) {\n\t\tfor (dx = dstX - radius; (dx <= dstX + radius); dx++) {\n\t\t\tdouble sxd = (dx - dstX) * aCos - (dy - dstY) * aSin;\n\t\t\tdouble syd = (dy - dstY) * aCos + (dx - dstX) * aSin;\n\t\t\tint sx = sxd + scX;\n\t\t\tint sy = syd + scY;\n\t\t\tif ((sx >= srcX) && (sx < srcX + srcWidth) &&\n\t\t\t        (sy >= srcY) && (sy < srcY + srcHeight)) {\n\t\t\t\tint c = gdImageGetPixel (src, sx, sy);\n\t\t\t\t/* 2.0.34: transparency wins */\n\t\t\t\tif (c == src->transparent) {\n\t\t\t\t\tgdImageSetPixel (dst, dx, dy, dst->transparent);\n\t\t\t\t} else if (!src->trueColor) {\n\t\t\t\t\t/* Use a table to avoid an expensive\n\t\t\t\t\t   lookup on every single pixel */\n\t\t\t\t\tif (cmap[c] == -1) {\n\t\t\t\t\t\tcmap[c] = gdImageColorResolveAlpha (dst,\n\t\t\t\t\t\t                                    gdImageRed (src, c),\n\t\t\t\t\t\t                                    gdImageGreen (src,\n\t\t\t\t\t\t                                            c),\n\t\t\t\t\t\t                                    gdImageBlue (src,\n\t\t\t\t\t\t                                            c),\n\t\t\t\t\t\t                                    gdImageAlpha (src,\n\t\t\t\t\t\t                                            c));\n\t\t\t\t\t}\n\t\t\t\t\tgdImageSetPixel (dst, dx, dy, cmap[c]);\n\t\t\t\t} else {\n\t\t\t\t\tgdImageSetPixel (dst,\n\t\t\t\t\t                 dx, dy,\n\t\t\t\t\t                 gdImageColorResolveAlpha (dst,\n\t\t\t\t\t                         gdImageRed (src,\n\t\t\t\t\t                                     c),\n\t\t\t\t\t                         gdImageGreen\n\t\t\t\t\t                         (src, c),\n\t\t\t\t\t                         gdImageBlue (src,\n\t\t\t\t\t                                      c),\n\t\t\t\t\t                         gdImageAlpha\n\t\t\t\t\t                         (src, c)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* When gd 1.x was first created, floating point was to be avoided.\n   These days it is often faster than table lookups or integer\n   arithmetic. The routine below is shamelessly, gloriously\n   floating point. TBB */\n\n/* 2.0.10: cast instead of floor() yields 35% performance improvement.\n\tThanks to John Buckman. */\n\n#define floor2(exp) ((long) exp)\n/*#define floor2(exp) floor(exp)*/\n\nBGD_DECLARE(void) gdImageCopyResampled (gdImagePtr dst,\n\t\t\t\t\t\t\t\t\t\tgdImagePtr src,\n\t\t\t\t\t\t\t\t\t\tint dstX, int dstY,\n\t\t\t\t\t\t\t\t\t\tint srcX, int srcY,\n\t\t\t\t\t\t\t\t\t\tint dstW, int dstH, int srcW, int srcH)\n{\n\tint x, y;\n\tdouble sy1, sy2, sx1, sx2;\n\tif (!dst->trueColor) {\n\t\tgdImageCopyResized (dst, src, dstX, dstY, srcX, srcY, dstW, dstH,\n\t\t                    srcW, srcH);\n\t\treturn;\n\t}\n\tfor (y = dstY; (y < dstY + dstH); y++) {\n\t\tsy1 = ((double) y - (double) dstY) * (double) srcH / (double) dstH;\n\t\tsy2 = ((double) (y + 1) - (double) dstY) * (double) srcH /\n\t\t      (double) dstH;\n\t\tfor (x = dstX; (x < dstX + dstW); x++) {\n\t\t\tdouble sx, sy;\n\t\t\tdouble spixels = 0;\n\t\t\tdouble red = 0.0, green = 0.0, blue = 0.0, alpha = 0.0;\n\t\t\tdouble alpha_sum = 0.0, contrib_sum = 0.0;\n\n\t\t\tsx1 = ((double) x - (double) dstX) * (double) srcW / dstW;\n\t\t\tsx2 = ((double) (x + 1) - (double) dstX) * (double) srcW / dstW;\n\t\t\tsy = sy1;\n\t\t\tdo {\n\t\t\t\tdouble yportion;\n\t\t\t\tif (floor2 (sy) == floor2 (sy1)) {\n\t\t\t\t\typortion = 1.0 - (sy - floor2 (sy));\n\t\t\t\t\tif (yportion > sy2 - sy1) {\n\t\t\t\t\t\typortion = sy2 - sy1;\n\t\t\t\t\t}\n\t\t\t\t\tsy = floor2 (sy);\n\t\t\t\t} else if (sy == floor2 (sy2)) {\n\t\t\t\t\typortion = sy2 - floor2 (sy2);\n\t\t\t\t} else {\n\t\t\t\t\typortion = 1.0;\n\t\t\t\t}\n\t\t\t\tsx = sx1;\n\t\t\t\tdo {\n\t\t\t\t\tdouble xportion;\n\t\t\t\t\tdouble pcontribution;\n\t\t\t\t\tint p;\n\t\t\t\t\tif (floor2 (sx) == floor2 (sx1)) {\n\t\t\t\t\t\txportion = 1.0 - (sx - floor2 (sx));\n\t\t\t\t\t\tif (xportion > sx2 - sx1) {\n\t\t\t\t\t\t\txportion = sx2 - sx1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsx = floor2 (sx);\n\t\t\t\t\t} else if (sx == floor2 (sx2)) {\n\t\t\t\t\t\txportion = sx2 - floor2 (sx2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\txportion = 1.0;\n\t\t\t\t\t}\n\t\t\t\t\tpcontribution = xportion * yportion;\n\t\t\t\t\t/* 2.08: previously srcX and srcY were ignored.\n\t\t\t\t\t   Andrew Pattison */\n\t\t\t\t\tp = gdImageGetTrueColorPixel (src,\n\t\t\t\t\t                              (int) sx + srcX,\n\t\t\t\t\t                              (int) sy + srcY);\n\t\t\t\t\tred += gdTrueColorGetRed (p) * pcontribution;\n\t\t\t\t\tgreen += gdTrueColorGetGreen (p) * pcontribution;\n\t\t\t\t\tblue += gdTrueColorGetBlue (p) * pcontribution;\n\t\t\t\t\talpha += gdTrueColorGetAlpha (p) * pcontribution;\n\t\t\t\t\tspixels += xportion * yportion;\n\t\t\t\t\tsx += 1.0;\n\t\t\t\t} while (sx < sx2);\n\t\t\t\tsy += 1.0;\n\t\t\t} while (sy < sy2);\n\t\t\tif (spixels != 0.0) {\n\t\t\t\tred /= spixels;\n\t\t\t\tgreen /= spixels;\n\t\t\t\tblue /= spixels;\n\t\t\t\talpha /= spixels;\n\t\t\t\talpha += 0.5;\n\t\t\t}\n\t\t\tif ( alpha_sum != 0.0f) {\n\t\t\t\tif( contrib_sum != 0.0f) {\n\t\t\t\t\talpha_sum /= contrib_sum;\n\t\t\t\t}\n\t\t\t\tred /= alpha_sum;\n\t\t\t\tgreen /= alpha_sum;\n\t\t\t\tblue /= alpha_sum;\n\t\t\t}\n\t\t\t/* Clamping to allow for rounding errors above */\n\t\t\tif (red > 255.0) {\n\t\t\t\tred = 255.0;\n\t\t\t}\n\t\t\tif (green > 255.0) {\n\t\t\t\tgreen = 255.0;\n\t\t\t}\n\t\t\tif (blue > 255.0) {\n\t\t\t\tblue = 255.0;\n\t\t\t}\n\t\t\tif (alpha > gdAlphaMax) {\n\t\t\t\talpha = gdAlphaMax;\n\t\t\t}\n\t\t\tgdImageSetPixel (dst,\n\t\t\t                 x, y,\n\t\t\t                 gdTrueColorAlpha ((int) red,\n\t\t\t                                   (int) green,\n\t\t\t                                   (int) blue, (int) alpha));\n\t\t}\n\t}\n}\n\nBGD_DECLARE(void) gdImagePolygon (gdImagePtr im, gdPointPtr p, int n, int c)\n{\n\tif (n <= 0) {\n\t\treturn;\n\t}\n\n\n\tgdImageLine (im, p->x, p->y, p[n - 1].x, p[n - 1].y, c);\n\tgdImageOpenPolygon (im, p, n, c);\n}\n\nBGD_DECLARE(void) gdImageOpenPolygon (gdImagePtr im, gdPointPtr p, int n, int c)\n{\n\tint i;\n\tint lx, ly;\n\tif (n <= 0) {\n\t\treturn;\n\t}\n\n\n\tlx = p->x;\n\tly = p->y;\n\tfor (i = 1; (i < n); i++) {\n\t\tp++;\n\t\tgdImageLine (im, lx, ly, p->x, p->y, c);\n\t\tlx = p->x;\n\t\tly = p->y;\n\t}\n\n}\n\n/* THANKS to Kirsten Schulz for the polygon fixes! */\n\n/* The intersection finding technique of this code could be improved  */\n/* by remembering the previous intertersection, and by using the slope. */\n/* That could help to adjust intersections  to produce a nice */\n/* interior_extrema. */\n\nBGD_DECLARE(void) gdImageFilledPolygon (gdImagePtr im, gdPointPtr p, int n, int c)\n{\n\tint i;\n\tint j;\n\tint index;\n\tint y;\n\tint miny, maxy, pmaxy;\n\tint x1, y1;\n\tint x2, y2;\n\tint ind1, ind2;\n\tint ints;\n\tint fill_color;\n\tif (n <= 0) {\n\t\treturn;\n\t}\n\n\tif (c == gdAntiAliased) {\n\t\tfill_color = im->AA_color;\n\t} else {\n\t\tfill_color = c;\n\t}\n\tif (!im->polyAllocated) {\n\t\tif (overflow2(sizeof (int), n)) {\n\t\t\treturn;\n\t\t}\n\t\tim->polyInts = (int *) gdMalloc (sizeof (int) * n);\n\t\tif (!im->polyInts) {\n\t\t\treturn;\n\t\t}\n\t\tim->polyAllocated = n;\n\t}\n\tif (im->polyAllocated < n) {\n\t\twhile (im->polyAllocated < n) {\n\t\t\tim->polyAllocated *= 2;\n\t\t}\n\t\tif (overflow2(sizeof (int), im->polyAllocated)) {\n\t\t\treturn;\n\t\t}\n\t\tim->polyInts = (int *) gdReallocEx (im->polyInts,\n\t\t\t\t\t\t    sizeof (int) * im->polyAllocated);\n\t\tif (!im->polyInts) {\n\t\t\treturn;\n\t\t}\n\t}\n\tminy = p[0].y;\n\tmaxy = p[0].y;\n\tfor (i = 1; (i < n); i++) {\n\t\tif (p[i].y < miny) {\n\t\t\tminy = p[i].y;\n\t\t}\n\t\tif (p[i].y > maxy) {\n\t\t\tmaxy = p[i].y;\n\t\t}\n\t}\n\tpmaxy = maxy;\n\t/* 2.0.16: Optimization by Ilia Chipitsine -- don't waste time offscreen */\n\t/* 2.0.26: clipping rectangle is even better */\n\tif (miny < im->cy1) {\n\t\tminy = im->cy1;\n\t}\n\tif (maxy > im->cy2) {\n\t\tmaxy = im->cy2;\n\t}\n\t/* Fix in 1.3: count a vertex only once */\n\tfor (y = miny; (y <= maxy); y++) {\n\t\tints = 0;\n\t\tfor (i = 0; (i < n); i++) {\n\t\t\tif (!i) {\n\t\t\t\tind1 = n - 1;\n\t\t\t\tind2 = 0;\n\t\t\t} else {\n\t\t\t\tind1 = i - 1;\n\t\t\t\tind2 = i;\n\t\t\t}\n\t\t\ty1 = p[ind1].y;\n\t\t\ty2 = p[ind2].y;\n\t\t\tif (y1 < y2) {\n\t\t\t\tx1 = p[ind1].x;\n\t\t\t\tx2 = p[ind2].x;\n\t\t\t} else if (y1 > y2) {\n\t\t\t\ty2 = p[ind1].y;\n\t\t\t\ty1 = p[ind2].y;\n\t\t\t\tx2 = p[ind1].x;\n\t\t\t\tx1 = p[ind2].x;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Do the following math as float intermediately, and round to ensure\n\t\t\t * that Polygon and FilledPolygon for the same set of points have the\n\t\t\t * same footprint. */\n\n\t\t\tif ((y >= y1) && (y < y2)) {\n\t\t\t\tim->polyInts[ints++] = (int) ((float) ((y - y1) * (x2 - x1)) /\n\t\t\t\t                              (float) (y2 - y1) + 0.5 + x1);\n\t\t\t} else if ((y == pmaxy) && (y == y2)) {\n\t\t\t\tim->polyInts[ints++] = x2;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t  2.0.26: polygons pretty much always have less than 100 points,\n\t\t  and most of the time they have considerably less. For such trivial\n\t\t  cases, insertion sort is a good choice. Also a good choice for\n\t\t  future implementations that may wish to indirect through a table.\n\t\t*/\n\t\tfor (i = 1; (i < ints); i++) {\n\t\t\tindex = im->polyInts[i];\n\t\t\tj = i;\n\t\t\twhile ((j > 0) && (im->polyInts[j - 1] > index)) {\n\t\t\t\tim->polyInts[j] = im->polyInts[j - 1];\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tim->polyInts[j] = index;\n\t\t}\n\t\tfor (i = 0; (i < (ints-1)); i += 2) {\n\t\t\t/* 2.0.29: back to gdImageLine to prevent segfaults when\n\t\t\t  performing a pattern fill */\n\t\t\tgdImageLine (im, im->polyInts[i], y, im->polyInts[i + 1], y,\n\t\t\t             fill_color);\n\t\t}\n\t}\n\t/* If we are drawing this AA, then redraw the border with AA lines. */\n\t/* This doesn't work as well as I'd like, but it doesn't clash either. */\n\tif (c == gdAntiAliased) {\n\t\tgdImagePolygon (im, p, n, c);\n\t}\n}\n\nstatic void gdImageSetAAPixelColor(gdImagePtr im, int x, int y, int color, int t);\n\nBGD_DECLARE(void) gdImageSetStyle (gdImagePtr im, int *style, int noOfPixels)\n{\n\tif (im->style) {\n\t\tgdFree (im->style);\n\t}\n\tif (overflow2(sizeof (int), noOfPixels)) {\n\t\treturn;\n\t}\n\tim->style = (int *) gdMalloc (sizeof (int) * noOfPixels);\n\tif (!im->style) {\n\t\treturn;\n\t}\n\tmemcpy (im->style, style, sizeof (int) * noOfPixels);\n\tim->styleLength = noOfPixels;\n\tim->stylePos = 0;\n}\n\nBGD_DECLARE(void) gdImageSetThickness (gdImagePtr im, int thickness)\n{\n\tim->thick = thickness;\n}\n\nBGD_DECLARE(void) gdImageSetBrush (gdImagePtr im, gdImagePtr brush)\n{\n\tint i;\n\tim->brush = brush;\n\tif ((!im->trueColor) && (!im->brush->trueColor)) {\n\t\tfor (i = 0; (i < gdImageColorsTotal (brush)); i++) {\n\t\t\tint index;\n\t\t\tindex = gdImageColorResolveAlpha (im,\n\t\t\t                                  gdImageRed (brush, i),\n\t\t\t                                  gdImageGreen (brush, i),\n\t\t\t                                  gdImageBlue (brush, i),\n\t\t\t                                  gdImageAlpha (brush, i));\n\t\t\tim->brushColorMap[i] = index;\n\t\t}\n\t}\n}\n\nBGD_DECLARE(void) gdImageSetTile (gdImagePtr im, gdImagePtr tile)\n{\n\tint i;\n\tim->tile = tile;\n\tif ((!im->trueColor) && (!im->tile->trueColor)) {\n\t\tfor (i = 0; (i < gdImageColorsTotal (tile)); i++) {\n\t\t\tint index;\n\t\t\tindex = gdImageColorResolveAlpha (im,\n\t\t\t                                  gdImageRed (tile, i),\n\t\t\t                                  gdImageGreen (tile, i),\n\t\t\t                                  gdImageBlue (tile, i),\n\t\t\t                                  gdImageAlpha (tile, i));\n\t\t\tim->tileColorMap[i] = index;\n\t\t}\n\t}\n}\n\nBGD_DECLARE(void) gdImageSetAntiAliased (gdImagePtr im, int c)\n{\n\tim->AA = 1;\n\tim->AA_color = c;\n\tim->AA_dont_blend = -1;\n}\n\nBGD_DECLARE(void) gdImageSetAntiAliasedDontBlend (gdImagePtr im, int c, int dont_blend)\n{\n\tim->AA = 1;\n\tim->AA_color = c;\n\tim->AA_dont_blend = dont_blend;\n}\n\nBGD_DECLARE(void) gdImageInterlace (gdImagePtr im, int interlaceArg)\n{\n\tim->interlace = interlaceArg;\n}\n\nBGD_DECLARE(int) gdImageCompare (gdImagePtr im1, gdImagePtr im2)\n{\n\tint x, y;\n\tint p1, p2;\n\tint cmpStatus = 0;\n\tint sx, sy;\n\n\tif (im1->interlace != im2->interlace) {\n\t\tcmpStatus |= GD_CMP_INTERLACE;\n\t}\n\n\tif (im1->transparent != im2->transparent) {\n\t\tcmpStatus |= GD_CMP_TRANSPARENT;\n\t}\n\n\tif (im1->trueColor != im2->trueColor) {\n\t\tcmpStatus |= GD_CMP_TRUECOLOR;\n\t}\n\n\tsx = im1->sx;\n\tif (im1->sx != im2->sx) {\n\t\tcmpStatus |= GD_CMP_SIZE_X + GD_CMP_IMAGE;\n\t\tif (im2->sx < im1->sx) {\n\t\t\tsx = im2->sx;\n\t\t}\n\t}\n\n\tsy = im1->sy;\n\tif (im1->sy != im2->sy) {\n\t\tcmpStatus |= GD_CMP_SIZE_Y + GD_CMP_IMAGE;\n\t\tif (im2->sy < im1->sy) {\n\t\t\tsy = im2->sy;\n\t\t}\n\t}\n\n\tif (im1->colorsTotal != im2->colorsTotal) {\n\t\tcmpStatus |= GD_CMP_NUM_COLORS;\n\t}\n\n\tfor (y = 0; (y < sy); y++) {\n\t\tfor (x = 0; (x < sx); x++) {\n\t\t\tp1 =\n\t\t\t    im1->trueColor ? gdImageTrueColorPixel (im1, x,\n\t\t\t            y) :\n\t\t\t    gdImagePalettePixel (im1, x, y);\n\t\t\tp2 =\n\t\t\t    im2->trueColor ? gdImageTrueColorPixel (im2, x,\n\t\t\t            y) :\n\t\t\t    gdImagePalettePixel (im2, x, y);\n\t\t\tif (gdImageRed (im1, p1) != gdImageRed (im2, p2)) {\n\t\t\t\tcmpStatus |= GD_CMP_COLOR + GD_CMP_IMAGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (gdImageGreen (im1, p1) != gdImageGreen (im2, p2)) {\n\t\t\t\tcmpStatus |= GD_CMP_COLOR + GD_CMP_IMAGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (gdImageBlue (im1, p1) != gdImageBlue (im2, p2)) {\n\t\t\t\tcmpStatus |= GD_CMP_COLOR + GD_CMP_IMAGE;\n\t\t\t\tbreak;\n\t\t\t}\n#if 0\n\t\t\t/* Soon we'll add alpha channel to palettes */\n\t\t\tif (gdImageAlpha (im1, p1) != gdImageAlpha (im2, p2)) {\n\t\t\t\tcmpStatus |= GD_CMP_COLOR + GD_CMP_IMAGE;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t}\n\t\tif (cmpStatus & GD_CMP_COLOR) {\n\t\t\tbreak;\n\t\t};\n\t}\n\n\treturn cmpStatus;\n}\n\n\n/* Thanks to Frank Warmerdam for this superior implementation\n\tof gdAlphaBlend(), which merges alpha in the\n\tdestination color much better. */\n\nBGD_DECLARE(int) gdAlphaBlend (int dst, int src)\n{\n\tint src_alpha = gdTrueColorGetAlpha(src);\n\tint dst_alpha, alpha, red, green, blue;\n\tint src_weight, dst_weight, tot_weight;\n\n\t/* -------------------------------------------------------------------- */\n\t/*      Simple cases we want to handle fast.                            */\n\t/* -------------------------------------------------------------------- */\n\tif( src_alpha == gdAlphaOpaque )\n\t\treturn src;\n\n\tdst_alpha = gdTrueColorGetAlpha(dst);\n\tif( src_alpha == gdAlphaTransparent )\n\t\treturn dst;\n\tif( dst_alpha == gdAlphaTransparent )\n\t\treturn src;\n\n\t/* -------------------------------------------------------------------- */\n\t/*      What will the source and destination alphas be?  Note that      */\n\t/*      the destination weighting is substantially reduced as the       */\n\t/*      overlay becomes quite opaque.                                   */\n\t/* -------------------------------------------------------------------- */\n\tsrc_weight = gdAlphaTransparent - src_alpha;\n\tdst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n\ttot_weight = src_weight + dst_weight;\n\n\t/* -------------------------------------------------------------------- */\n\t/*      What red, green and blue result values will we use?             */\n\t/* -------------------------------------------------------------------- */\n\talpha = src_alpha * dst_alpha / gdAlphaMax;\n\n\tred = (gdTrueColorGetRed(src) * src_weight\n\t       + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n\tgreen = (gdTrueColorGetGreen(src) * src_weight\n\t         + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n\tblue = (gdTrueColorGetBlue(src) * src_weight\n\t        + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n\n\t/* -------------------------------------------------------------------- */\n\t/*      Return merged result.                                           */\n\t/* -------------------------------------------------------------------- */\n\treturn ((alpha << 24) + (red << 16) + (green << 8) + blue);\n}\n\nstatic int gdAlphaOverlayColor (int src, int dst, int max );\nBGD_DECLARE(int) gdLayerOverlay (int dst, int src)\n{\n\tint a1, a2;\n\ta1 = gdAlphaMax - gdTrueColorGetAlpha(dst);\n\ta2 = gdAlphaMax - gdTrueColorGetAlpha(src);\n\treturn ( ((gdAlphaMax - a1*a2/gdAlphaMax) << 24) +\n\t\t(gdAlphaOverlayColor( gdTrueColorGetRed(src), gdTrueColorGetRed(dst), gdRedMax ) << 16) +\n\t\t(gdAlphaOverlayColor( gdTrueColorGetGreen(src), gdTrueColorGetGreen(dst), gdGreenMax ) << 8) +\n\t\t(gdAlphaOverlayColor( gdTrueColorGetBlue(src), gdTrueColorGetBlue(dst), gdBlueMax ))\n\t\t);\n}\n\n/* Apply 'overlay' effect - background pixels are colourised by the foreground colour */\nstatic int gdAlphaOverlayColor (int src, int dst, int max )\n{\n\tdst = dst << 1;\n\tif( dst > max ) {\n\t\t/* in the \"light\" zone */\n\t\treturn dst + (src << 1) - (dst * src / max) - max;\n\t} else {\n\t\t/* in the \"dark\" zone */\n\t\treturn dst * src / max;\n\t}\n}\n\n/* Apply 'multiply' effect */\nBGD_DECLARE(int) gdLayerMultiply (int dst, int src)\n{\n\tint a1, a2, r1, r2, g1, g2, b1, b2;\n\ta1 = gdAlphaMax - gdTrueColorGetAlpha(src);\n\ta2 = gdAlphaMax - gdTrueColorGetAlpha(dst);\n\n\tr1 = gdRedMax - (a1 * (gdRedMax - gdTrueColorGetRed(src))) / gdAlphaMax;\n\tr2 = gdRedMax - (a2 * (gdRedMax - gdTrueColorGetRed(dst))) / gdAlphaMax;\n\tg1 = gdGreenMax - (a1 * (gdGreenMax - gdTrueColorGetGreen(src))) / gdAlphaMax;\n\tg2 = gdGreenMax - (a2 * (gdGreenMax - gdTrueColorGetGreen(dst))) / gdAlphaMax;\n\tb1 = gdBlueMax - (a1 * (gdBlueMax - gdTrueColorGetBlue(src))) / gdAlphaMax;\n\tb2 = gdBlueMax - (a2 * (gdBlueMax - gdTrueColorGetBlue(dst))) / gdAlphaMax ;\n\n\ta1 = gdAlphaMax - a1;\n\ta2 = gdAlphaMax - a2;\n\treturn ( ((a1*a2/gdAlphaMax) << 24) +\n\t\t\t ((r1*r2/gdRedMax) << 16) +\n\t\t\t ((g1*g2/gdGreenMax) << 8) +\n\t\t\t ((b1*b2/gdBlueMax))\n\t\t);\n}\n\nBGD_DECLARE(void) gdImageAlphaBlending (gdImagePtr im, int alphaBlendingArg)\n{\n\tim->alphaBlendingFlag = alphaBlendingArg;\n}\n\nBGD_DECLARE(void) gdImageSaveAlpha (gdImagePtr im, int saveAlphaArg)\n{\n\tim->saveAlphaFlag = saveAlphaArg;\n}\n\nBGD_DECLARE(void) gdImageSetClip (gdImagePtr im, int x1, int y1, int x2, int y2)\n{\n\tif (x1 < 0) {\n\t\tx1 = 0;\n\t}\n\tif (x1 >= im->sx) {\n\t\tx1 = im->sx - 1;\n\t}\n\tif (x2 < 0) {\n\t\tx2 = 0;\n\t}\n\tif (x2 >= im->sx) {\n\t\tx2 = im->sx - 1;\n\t}\n\tif (y1 < 0) {\n\t\ty1 = 0;\n\t}\n\tif (y1 >= im->sy) {\n\t\ty1 = im->sy - 1;\n\t}\n\tif (y2 < 0) {\n\t\ty2 = 0;\n\t}\n\tif (y2 >= im->sy) {\n\t\ty2 = im->sy - 1;\n\t}\n\tim->cx1 = x1;\n\tim->cy1 = y1;\n\tim->cx2 = x2;\n\tim->cy2 = y2;\n}\n\nBGD_DECLARE(void) gdImageGetClip (gdImagePtr im, int *x1P, int *y1P, int *x2P, int *y2P)\n{\n\t*x1P = im->cx1;\n\t*y1P = im->cy1;\n\t*x2P = im->cx2;\n\t*y2P = im->cy2;\n}\n\nBGD_DECLARE(void) gdImageSetResolution(gdImagePtr im, const unsigned int res_x, const unsigned int res_y)\n{\n\tif (res_x > 0) im->res_x = res_x;\n\tif (res_y > 0) im->res_y = res_y;\n}\n\n/*\n * Added on 2003/12 by Pierre-Alain Joye (pajoye@pearfr.org)\n * */\n#define BLEND_COLOR(a, nc, c, cc) \\\nnc = (cc) + (((((c) - (cc)) * (a)) + ((((c) - (cc)) * (a)) >> 8) + 0x80) >> 8);\n\nstatic void gdImageSetAAPixelColor(gdImagePtr im, int x, int y, int color, int t)\n{\n\tint dr,dg,db,p,r,g,b;\n\n\t/* 2.0.34: watch out for out of range calls */\n\tif (!gdImageBoundsSafeMacro(im, x, y)) {\n\t\treturn;\n\t}\n\tp = gdImageGetPixel(im,x,y);\n\t/* TBB: we have to implement the dont_blend stuff to provide\n\t  the full feature set of the old implementation */\n\tif ((p == color)\n\t        || ((p == im->AA_dont_blend)\n\t            && (t != 0x00))) {\n\t\treturn;\n\t}\n\tdr = gdTrueColorGetRed(color);\n\tdg = gdTrueColorGetGreen(color);\n\tdb = gdTrueColorGetBlue(color);\n\n\tr = gdTrueColorGetRed(p);\n\tg = gdTrueColorGetGreen(p);\n\tb = gdTrueColorGetBlue(p);\n\n\tBLEND_COLOR(t, dr, r, dr);\n\tBLEND_COLOR(t, dg, g, dg);\n\tBLEND_COLOR(t, db, b, db);\n\tim->tpixels[y][x] = gdTrueColorAlpha(dr, dg, db, gdAlphaOpaque);\n}\n\nstatic void gdImageAALine (gdImagePtr im, int x1, int y1, int x2, int y2, int col)\n{\n\t/* keep them as 32bits */\n\tlong x, y, inc, frac;\n\tlong dx, dy,tmp;\n\tint w, wid, wstart; \n\tint thick = im->thick; \n\n\tif (!im->trueColor) {\n\t\t/* TBB: don't crash when the image is of the wrong type */\n\t\tgdImageLine(im, x1, y1, x2, y2, col);\n\t\treturn;\n\t}\n\n\t/* TBB: use the clipping rectangle */\n\tif (clip_1d (&x1, &y1, &x2, &y2, im->cx1, im->cx2) == 0)\n\t\treturn;\n\tif (clip_1d (&y1, &x1, &y2, &x2, im->cy1, im->cy2) == 0)\n\t\treturn;\n\n\tdx = x2 - x1;\n\tdy = y2 - y1;\n\n\tif (dx == 0 && dy == 0) {\n\t\t/* TBB: allow setting points */\n\t\tgdImageSetAAPixelColor(im, x1, y1, col, 0xFF);\n\t\treturn;\n\t} else {\n\t\tdouble ag;\n\t\t/* Cast the long to an int to avoid compiler warnings about truncation.\n\t\t * This isn't a problem as computed dy/dx values came from ints above. */\n\t\tag = fabs(abs((int)dy) < abs((int)dx) ? cos(atan2(dy, dx)) : sin(atan2(dy, dx)));\n\t\tif (ag != 0) {\n\t\t\twid = thick / ag;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tif (wid == 0) {\n\t\t\twid = 1;\n\t\t}\n\t}\n\n\t/* Axis aligned lines */\n\tif (dx == 0) {\n\t\tgdImageVLine(im, x1, y1, y2, col);\n\t\treturn;\n\t} else if (dy == 0) {\n\t\tgdImageHLine(im, y1, x1, x2, col);\n\t\treturn;\n\t}\n\n\tif (abs((int)dx) > abs((int)dy)) {\n\t\tif (dx < 0) {\n\t\t\ttmp = x1;\n\t\t\tx1 = x2;\n\t\t\tx2 = tmp;\n\t\t\ttmp = y1;\n\t\t\ty1 = y2;\n\t\t\ty2 = tmp;\n\t\t\tdx = x2 - x1;\n\t\t\tdy = y2 - y1;\n\t\t}\n\t\ty = y1;\n\t\tinc = (dy * 65536) / dx;\n\t\tfrac = 0;\n\t\t/* TBB: set the last pixel for consistency (<=) */\n\t\tfor (x = x1 ; x <= x2 ; x++) {\n\t\t\twstart = y - wid / 2;\n\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t    gdImageSetAAPixelColor(im, x , w , col , (frac >> 8) & 0xFF);\n\t\t\t    gdImageSetAAPixelColor(im, x , w + 1 , col, (~frac >> 8) & 0xFF);\n\t\t\t}\n\t\t\tfrac += inc;\n\t\t\tif (frac >= 65536) {\n\t\t\t\tfrac -= 65536;\n\t\t\t\ty++;\n\t\t\t} else if (frac < 0) {\n\t\t\t\tfrac += 65536;\n\t\t\t\ty--;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (dy < 0) {\n\t\t\ttmp = x1;\n\t\t\tx1 = x2;\n\t\t\tx2 = tmp;\n\t\t\ttmp = y1;\n\t\t\ty1 = y2;\n\t\t\ty2 = tmp;\n\t\t\tdx = x2 - x1;\n\t\t\tdy = y2 - y1;\n\t\t}\n\t\tx = x1;\n\t\tinc = (dx * 65536) / dy;\n\t\tfrac = 0;\n\t\t/* TBB: set the last pixel for consistency (<=) */\n\t\tfor (y = y1 ; y <= y2 ; y++) {\n\t\t\twstart = x - wid / 2;\n\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t    gdImageSetAAPixelColor(im, w , y  , col, (frac >> 8) & 0xFF);\n\t\t\t    gdImageSetAAPixelColor(im, w + 1, y, col, (~frac >> 8) & 0xFF);\n\t\t\t}\n\t\t\tfrac += inc;\n\t\t\tif (frac >= 65536) {\n\t\t\t\tfrac -= 65536;\n\t\t\t\tx++;\n\t\t\t} else if (frac < 0) {\n\t\t\t\tfrac += 65536;\n\t\t\t\tx--;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/* convert a palette image to true color */\nBGD_DECLARE(int) gdImagePaletteToTrueColor(gdImagePtr src)\n{\n\tunsigned int y;\n\tunsigned int yy;\n\n\tif (src == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (src->trueColor == 1) {\n\t\treturn 1;\n\t} else {\n\t\tunsigned int x;\n\t\tconst unsigned int sy = gdImageSY(src);\n\t\tconst unsigned int sx = gdImageSX(src);\n\n\t\tsrc->tpixels = (int **) gdMalloc(sizeof(int *) * sy);\n\t\tif (src->tpixels == NULL) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (y = 0; y < sy; y++) {\n\t\t\tconst unsigned char *src_row = src->pixels[y];\n\t\t\tint * dst_row;\n\n\t\t\t/* no need to calloc it, we overwrite all pxl anyway */\n\t\t\tsrc->tpixels[y] = (int *) gdMalloc(sx * sizeof(int));\n\t\t\tif (src->tpixels[y] == NULL) {\n\t\t\t\tgoto clean_on_error;\n\t\t\t}\n\n\t\t\tdst_row = src->tpixels[y];\n\t\t\tfor (x = 0; x < sx; x++) {\n\t\t\t\tconst unsigned char c = *(src_row + x);\n\t\t\t\tif (c == src->transparent) {\n\t\t\t\t\t*(dst_row + x) = gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t\t} else {\n\t\t\t\t\t*(dst_row + x) = gdTrueColorAlpha(src->red[c], src->green[c], src->blue[c], src->alpha[c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* free old palette buffer (y is sy) */\n\tfor (yy = 0; yy < y; yy++) {\n\t\tgdFree(src->pixels[yy]);\n\t}\n\tgdFree(src->pixels);\n\tsrc->trueColor = 1;\n\tsrc->pixels = NULL;\n\tsrc->alphaBlendingFlag = 0;\n\tsrc->saveAlphaFlag = 1;\n\treturn 1;\n\nclean_on_error:\n\t/* free new true color buffer (y is not allocated, have failed) */\n\tfor (yy = 0; yy < y; yy++) {\n\t\tgdFree(src->tpixels[yy]);\n\t}\n\tgdFree(src->tpixels);\n\treturn 0;\n}\n", "/bug00037\n/github_bug_215\n", "SET(TESTS_FILES\n\tbug00037\n\tgithub_bug_215\n)\n\nADD_GD_TESTS()\n", "if HAVE_LIBPNG\nlibgd_test_programs += \\\n\tgdimagefilltoborder/bug00037 \\\n\tgdimagefilltoborder/github_bug_215\nendif\n\nEXTRA_DIST += \\\n\tgdimagefilltoborder/CMakeLists.txt\n"], "filenames": ["src/gd.c", "tests/gdimagefilltoborder/.gitignore", "tests/gdimagefilltoborder/CMakeLists.txt", "tests/gdimagefilltoborder/Makemodule.am"], "buggy_code_start_loc": [1931, 1, 2, 3], "buggy_code_end_loc": [1934, 1, 2, 4], "fixing_code_start_loc": [1931, 2, 3, 3], "fixing_code_end_loc": [1941, 3, 4, 5], "type": "CWE-119", "message": "Stack consumption vulnerability in the gdImageFillToBorder function in gd.c in the GD Graphics Library (aka libgd) before 2.2.2, as used in PHP before 5.6.28 and 7.x before 7.0.13, allows remote attackers to cause a denial of service (segmentation violation) via a crafted imagefilltoborder call that triggers use of a negative color value.", "other": {"cve": {"id": "CVE-2016-9933", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-04T20:59:00.480", "lastModified": "2018-05-04T01:29:01.987", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Stack consumption vulnerability in the gdImageFillToBorder function in gd.c in the GD Graphics Library (aka libgd) before 2.2.2, as used in PHP before 5.6.28 and 7.x before 7.0.13, allows remote attackers to cause a denial of service (segmentation violation) via a crafted imagefilltoborder call that triggers use of a negative color value."}, {"lang": "es", "value": "Vulnerabilidad de consumo de pila en la funci\u00f3n gdImageFillToBorder en gd.c en la GD Graphics Library (tambi\u00e9n conocida como libgd) en versiones anteriores a 2.2.2, como se utiliza en PHP en versiones anteriores a 5.6.28 y 7.x en versiones anteriores a 7.0.13, permite a atacantes remotos provocar una denegaci\u00f3n de servicio (violaci\u00f3n de segmentaci\u00f3n) a trav\u00e9s de una llamada imagefilltoborder manipulada que desencadena el uso de un valor de color negativo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libgd:libgd:2.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "5AB26BF9-D145-4F4C-A71F-F9C886AFB272"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.6.27", "matchCriteriaId": "DEBFD36E-4559-474C-ADEE-3686F156180C"}, {"vulnerable": false, "criteria": "cpe:2.3:a:php:php:7.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "DB6890AF-8A0A-46EE-AAD5-CF9AAE14A321"}, {"vulnerable": false, "criteria": "cpe:2.3:a:php:php:7.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "6B90B947-7B54-47F3-9637-2F4AC44079EE"}, {"vulnerable": false, "criteria": "cpe:2.3:a:php:php:7.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "35848414-BD5D-4164-84DC-61ABBB1C4152"}, {"vulnerable": false, "criteria": "cpe:2.3:a:php:php:7.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "2B1F8402-8551-4F66-A9A7-81D472AB058E"}, {"vulnerable": false, "criteria": "cpe:2.3:a:php:php:7.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "7A773E8E-48CD-4D35-A0FD-629BD9334486"}, {"vulnerable": false, "criteria": "cpe:2.3:a:php:php:7.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "FC492340-79AF-4676-A161-079A97EC6F0C"}, {"vulnerable": false, "criteria": "cpe:2.3:a:php:php:7.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "F1C2D8FE-C380-4B43-B634-A3DBA4700A71"}, {"vulnerable": false, "criteria": "cpe:2.3:a:php:php:7.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "3EB58393-0C10-413C-8D95-6BAA8BC19A1B"}, {"vulnerable": false, "criteria": "cpe:2.3:a:php:php:7.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "751F51CA-9D88-4971-A6EC-8C0B72E8E22B"}, {"vulnerable": false, "criteria": "cpe:2.3:a:php:php:7.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "37B74118-8FC2-44CB-9673-A83DF777B2E6"}, {"vulnerable": false, "criteria": "cpe:2.3:a:php:php:7.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "4D56A200-1477-40DA-9444-CFC946157C69"}, {"vulnerable": false, "criteria": "cpe:2.3:a:php:php:7.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "FD0D1CCC-A857-4C15-899E-08F9255CEE34"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2016-12/msg00133.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-12/msg00142.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-updates/2017-01/msg00002.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-updates/2017-01/msg00034.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-updates/2017-01/msg00054.html", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2017/dsa-3751", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2016/12/12/2", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.php.net/ChangeLog-5.php", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.php.net/ChangeLog-7.php", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/94865", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:1296", "source": "cve@mitre.org"}, {"url": "https://bugs.php.net/bug.php?id=72696", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/libgd/libgd/commit/77f619d48259383628c3ec4654b1ad578e9eb40e", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/libgd/libgd/issues/215", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/php/php-src/commit/863d37ea66d5c960db08d6f4a2cbd2518f0f80d1", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/libgd/libgd/commit/77f619d48259383628c3ec4654b1ad578e9eb40e"}}